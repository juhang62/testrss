<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>使用Jenkins pipeline流水线构建docker镜像和发布 - Ryan.Miao</title>
<link>http://www.cnblogs.com/woshimrf/p/jenkins-pipeline.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/woshimrf/p/jenkins-pipeline.html</guid>
<description>[unable to retrieve full-text content]新建一个pipeline job 选择Pipeline任务，然后进入配置页面。 对于Pipeline, Definition选择 &quot;Pipeline script from SCM&quot;. 需要注意的是Script Path, 这里要指定项目中Jenkinsfile文件的具体位置。默认是根目录。我这里是</description>
<pubDate>Sat, 29 Dec 2018 07:33:00 +0000</pubDate>
<dc:creator>Ryan.Miao</dc:creator>
<dc:identifier>http://www.cnblogs.com/woshimrf/p/jenkins-pipeline.html</dc:identifier>
</item>
<item>
<title>2018总结，今年的自己有些丧 - 小浩学长</title>
<link>http://www.cnblogs.com/xiaohaoxuezhang/p/10196234.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaohaoxuezhang/p/10196234.html</guid>
<description>[unable to retrieve full-text content]今年8102，从年初写完去年的总结开始，回忆起这整整一年时间，得到的只有颓废、没干劲、玩物丧志这些负面的词汇，再次阅读去年的总结，不禁面红耳赤起来。 本来这篇文章几天前就已经想写了，自己内心想要逃避。这段时间病了很久，躺在床上思考自己，今天大病初愈，站在镜子前，看了自己很久，感觉去年那个自己又回来了</description>
<pubDate>Sat, 29 Dec 2018 07:29:00 +0000</pubDate>
<dc:creator>小浩学长</dc:creator>
<dc:identifier>http://www.cnblogs.com/xiaohaoxuezhang/p/10196234.html</dc:identifier>
</item>
<item>
<title>浅谈SpringCloud (三)   Ribbon负载均衡 - 阿来丶</title>
<link>http://www.cnblogs.com/JiangLai/p/10186186.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/JiangLai/p/10186186.html</guid>
<description>&lt;p&gt;当一台服务器的单位时间内的访问量越大时，服务器压力就越大，大到超过自身承受能力时，服务器就会崩溃。为了避免服务器崩溃，让用户有更好的体验，我们通过负载均衡的方式来分担服务器压力。&lt;/p&gt;
&lt;p&gt;我们可以建立很多很多服务器，组成一个服务器集群，当用户访问网站时，先访问一个中间服务器，在让这个中间服务器在服务器集群中选择一个压力较小的服务器，然后将该访问请求引入该服务器。如此以来，用户的每次访问，都会保证服务器集群中的每个服务器压力趋于平衡，分担了服务器压力，避免了服务器崩溃的情况。&lt;/p&gt;

&lt;p&gt;　　Spring Cloud Ribbons是基于Netflix Ribbon实现的一套客户端负载均衡的工具。&lt;/p&gt;
&lt;div readability=&quot;66&quot;&gt;
&lt;p&gt;　　Spring Cloud Ribbon虽然只是一个工具类框架，它不像服务注册中心、配置中心、API网关那样需要独立部署，但是它几乎存在于每一个Spring Cloud构建的微服务和基础设施中。因为微服务间的调用，API网关的请求转发等内容，实际上都是通过Ribbon来实现的，包括后续我们将要介绍的Feign，它也是基于Ribbon实现的工具。所以，对Spring Cloud Ribbon的理解和使用，对于我们使用Spring Cloud来构建微服务非常重要。&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/8796251-20be966344ffe722.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/786/format/webp&quot; alt=&quot;&quot; width=&quot;669&quot; height=&quot;408&quot;/&gt;&lt;/p&gt;

&lt;p&gt;1.修改客户端的pom.xml文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;project &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://maven.apache.org/POM/4.0.0&quot;&lt;/span&gt;&lt;span&gt; xmlns:xsi&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;span&gt;
         xsi:schemaLocation&lt;/span&gt;&lt;span&gt;=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;parent&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;springclouddemo&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.aomeibox&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.0-SNAPSHOT&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;parent&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;modelVersion&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;4.0.0&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;modelVersion&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;customer-order&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;customer-order&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;url&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;http://www.example.com&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;url&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;properties&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;project.build.sourceEncoding&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;UTF-8&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;project.build.sourceEncoding&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;maven.compiler.source&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.7&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;maven.compiler.source&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;maven.compiler.target&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.7&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;maven.compiler.target&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;properties&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;junit&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;junit&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;4.11&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;test&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.cloud&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-cloud-starter-netflix-eureka-client&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.4.0.RELEASE&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-web&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-actuator&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; Ribbon 相关&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.cloud&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-cloud-starter-config&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.1.0.RELEASE&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.cloud&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-cloud-starter-ribbon&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;project&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;2.修改客户端的MyConfig类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.aomeibox.config;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cloud.client.loadbalancer.LoadBalanced;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.Bean;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.Configuration;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.client.RestTemplate;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * Created by jl on 2018/12/27.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Configuration
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyConfig {

    @Bean
    @LoadBalanced  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;负载均衡工具&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; RestTemplate restTemplate(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RestTemplate();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;3.修改客户端的controller,通过在Eureka中注册的ApplicaitonName进行访问&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.aomeibox.con;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.aomeibox.pojo.User;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Autowired;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.bind.annotation.GetMapping;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.bind.annotation.PathVariable;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.bind.annotation.RestController;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.client.RestTemplate;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * Created by leo on 2018/12/24.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@RestController
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; OrderController {

    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; RestTemplate template;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;spring提供的一个用于访问rest接口的模板对象&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String url = &quot;http://PROVIDER-USER&quot;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    @Autowired
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    private EurekaClient eurekaClient;&lt;/span&gt;
&lt;span&gt;
    @GetMapping(&lt;/span&gt;&quot;/order/{id}&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; User getUser(@PathVariable Integer id){

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        InstanceInfo eureka = eurekaClient.getNextServerFromEureka(&quot;PROVIDER-USER&quot;, false);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;访问提供者获取数据
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        User user = template.getForObject(eureka.getHomePageUrl()+&quot;/user/&quot;+ id, User.class);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过访问rest 获取到json数据，然后转换成User对象&lt;/span&gt;
&lt;span&gt;
        User user &lt;/span&gt;= template.getForObject(url+&quot;/user/&quot;+ id, User.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; user;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;4.运行项目&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1350478/201812/1350478-20181227174436643-1105657231.png&quot; alt=&quot;&quot; width=&quot;597&quot; height=&quot;218&quot;/&gt;&lt;/p&gt;

&lt;p&gt;使用负载均衡带来的好处很明显：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当集群里的1台或者多台服务器down的时候，剩余的没有down的服务器可以保证服务的继续使用&lt;/li&gt;
&lt;li&gt;使用了更多的机器保证了机器的良性使用，不会由于某一高峰时刻导致系统cpu急剧上升&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;负载均衡有好几种实现策略，常见的有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;随机 (RandomRuler)&lt;/li&gt;
&lt;li&gt;轮询 (RoundRobinRuler)   （默认）&lt;/li&gt;
&lt;li&gt;一致性哈希 (ConsistentHashRuler)&lt;/li&gt;
&lt;li&gt;哈希 (HashRuler)&lt;/li&gt;
&lt;li&gt;加权（WeightedRuler）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; 　　RoundRobinRule轮询策略表示每次都取下一个服务器，比如一共有5台服务器，第1次取第1台，第2次取第2台，第3次取第3台，以此类推。&lt;/p&gt;
&lt;p&gt; 　　WeightedResponseTimeRule继承了RoundRobinRule，开始的时候还没有权重列表，采用父类的轮询方式，有一个默认每30秒更新一次权重列表的定时任务，该定时任务会根据实例的响应时间来更新权重列表，choose方法做的事情就是，用一个(0,1)的随机double数乘以最大的权重得到randomWeight，然后遍历权重列表，找出第一个比randomWeight大的实例下标，然后返回该实例。&lt;/p&gt;
&lt;p&gt;　　 BestAvailableRule策略用来选取最少并发量请求的服务器。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果需要改变轮训的策略，需要修改自己的配置类。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.aomeibox.config;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.netflix.loadbalancer.IRule;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.netflix.loadbalancer.RandomRule;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cloud.client.loadbalancer.LoadBalanced;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.Bean;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.Configuration;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.client.RestTemplate;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * Created by leo on 2018/12/27.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Configuration
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MyConfig {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;@Configuration + 本类  = applicationContext.xml文件&lt;/span&gt;
&lt;span&gt;
    @Bean
    @LoadBalanced  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;负载均衡工具&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; RestTemplate restTemplate(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RestTemplate();
    }

    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; IRule myRule(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RandomRule();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;随机策略&lt;/span&gt;
&lt;span&gt;    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;1.主启动类新增注解。&lt;span&gt;注意，自己编写的Rule类，不能和主启动类放在同一个包下&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.aomeibox;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.aomei.MySelfRule;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.boot.SpringApplication;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.boot.autoconfigure.SpringBootApplication;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cloud.netflix.eureka.EnableEurekaClient;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cloud.netflix.ribbon.RibbonClient;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 *
 * 消费者
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@SpringBootApplication
@EnableEurekaClient
@RibbonClient(name &lt;/span&gt;= &quot;PROVIDER-USER&quot;,configuration = MySelfRule.&lt;span&gt;class&lt;/span&gt;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;MySelfRule.class不能在本类的包或者子包下&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CustomerOrder
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main( String[] args )
    {
        SpringApplication.run(CustomerOrder.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;



&lt;p&gt;2.新增MyRule类。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.aomei;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.netflix.loadbalancer.BestAvailableRule;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.netflix.loadbalancer.IRule;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.Bean;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.Configuration;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * Created by leo on 2018/12/29.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Configuration
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MySelfRule {

    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; IRule myRule(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BestAvailableRule();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　上述的Ribbon功能很强大，可以自定义算法。&lt;/p&gt;
&lt;p&gt;　　Feign 是一个声明web服务客户端，这便得编写web服务客户端更容易，使用Feign 创建一个接口并对它进行注解，它具有可插拔的注解支持包括Feign注解与JAX-RS注解，Feign还支持可插拔的编码器与解码器，Spring Cloud 增加了对 Spring MVC的注解，Spring Web 默认使用了HttpMessageConverters, Spring Cloud 集成 Ribbon 和 Eureka 提供的负载均衡的HTTP客户端 Feign。&lt;/p&gt;

&lt;p&gt;　　上述大部分，我们通常是以微服务的ApplicaitonName进行访问的。但是在开发编程过程中，我们通常是面向接口编程。因此出现了Feign。Feign可以使用接口+注解，调用其他项目的接口。&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
@FeignClient(&quot;provider-user&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; UserClient {
 
    @RequestMapping(method &lt;/span&gt;= RequestMethod.GET, value = &quot;/getuser&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; User getuserinfo();
     
    @RequestMapping(method &lt;/span&gt;= RequestMethod.GET, value = &quot;/getuser&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getuserinfostr();
     
    @RequestMapping(method &lt;/span&gt;= RequestMethod.GET, value = &quot;/info&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;  String  info();
 
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@SpringBootApplication
@EnableDiscoveryClient
@EnableFeignClients
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FeignApplication {
 
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        SpringApplication.run(FeignApplication.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, args);
    }
 
}&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@RestController
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserController {
 
    @Autowired
    UserClient userClient;
 
    @RequestMapping(value &lt;/span&gt;= &quot;/getuserinfo&quot;, method =&lt;span&gt; RequestMethod.GET)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; User getuserinfo() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; userClient.getuserinfo();
    }
     
    @RequestMapping(value &lt;/span&gt;= &quot;/getuserinfostr&quot;, method =&lt;span&gt; RequestMethod.GET)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getuserinfostr() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; userClient.getuserinfostr();
    }
     
    @RequestMapping(value &lt;/span&gt;= &quot;/info&quot;, method =&lt;span&gt; RequestMethod.GET)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String info() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; userClient.info();
    }
 
 
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sat, 29 Dec 2018 07:25:00 +0000</pubDate>
<dc:creator>阿来丶</dc:creator>
<og:description>什么是负载均衡 当一台服务器的单位时间内的访问量越大时，服务器压力就越大，大到超过自身承受能力时，服务器就会崩溃。为了避免服务器崩溃，让用户有更好的体验，我们通过负载均衡的方式来分担服务器压力。 我们</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/JiangLai/p/10186186.html</dc:identifier>
</item>
<item>
<title>并发编程（七）——AbstractQueuedSynchronizer 之 CountDownLatch、CyclicBarrier、Semaphore  源码分析 - chen_hao</title>
<link>http://www.cnblogs.com/java-chen-hao/p/10191106.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/java-chen-hao/p/10191106.html</guid>
<description>&lt;p&gt;这篇，我们的关注点是 AQS 最后的部分，共享模式的使用。本文先用 CountDownLatch 将共享模式说清楚，然后顺着把其他 AQS 相关的类 CyclicBarrier、Semaphore 的源码一起过一下。&lt;/p&gt;
&lt;h2 id=&quot;CountDownLatch&quot;&gt;CountDownLatch&lt;/h2&gt;
&lt;p&gt;CountDownLatch 这个类是比较典型的 AQS 的共享模式的使用，这是一个高频使用的类。使用方法在前面一篇文章中有介绍 &lt;a href=&quot;https://www.cnblogs.com/java-chen-hao/p/9970581.html&quot; target=&quot;_blank&quot;&gt;并发编程（二）—— CountDownLatch、CyclicBarrier和Semaphore&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;%E4%BD%BF%E7%94%A8%E4%BE%8B%E5%AD%90&quot;&gt;使用例子&lt;/h3&gt;
&lt;p&gt;我们看下 Doug Lea 在 java doc 中给出的例子，这个例子非常实用，我们经常会写这个代码。&lt;/p&gt;
&lt;p&gt;假设我们有 N ( N &amp;gt; 0 ) 个任务，那么我们会用 N 来初始化一个 CountDownLatch，然后将这个 latch 的引用传递到各个线程中，在每个线程完成了任务后，调用 latch.countDown() 代表完成了一个任务。&lt;/p&gt;
&lt;p&gt;调用 latch.await() 的方法的线程会阻塞，直到所有的任务完成。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt; Driver2 { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main() throws InterruptedException {
        CountDownLatch doneSignal &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CountDownLatch(N);
        Executor e &lt;/span&gt;= Executors.newFixedThreadPool(&lt;span&gt;8&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建 N 个任务，提交给线程池来执行&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; N; ++i) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; create and start threads&lt;/span&gt;
            e.execute(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; WorkerRunnable(doneSignal, i));

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 等待所有的任务完成，这个方法才会返回&lt;/span&gt;
        doneSignal.&lt;span&gt;await&lt;/span&gt;();           &lt;span&gt;//&lt;/span&gt;&lt;span&gt; wait for all to finish&lt;/span&gt;
&lt;span&gt;    }
}

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; WorkerRunnable implements Runnable {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; final CountDownLatch doneSignal;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; final &lt;span&gt;int&lt;/span&gt;&lt;span&gt; i;

    WorkerRunnable(CountDownLatch doneSignal, &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.doneSignal =&lt;span&gt; doneSignal;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.i =&lt;span&gt; i;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            doWork(i);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这个线程的任务完成了，调用 countDown 方法&lt;/span&gt;
&lt;span&gt;            doneSignal.countDown();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException ex) {
        } &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; return;&lt;/span&gt;
&lt;span&gt;    }

    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; doWork() { ...}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;所以说 CountDownLatch 非常实用，我们常常会将一个比较大的任务进行拆分，然后开启多个线程来执行，等所有线程都执行完了以后，再往下执行其他操作。这里例子中，只有 main 线程调用了 await 方法。&lt;/p&gt;
&lt;p&gt;我们再来看另一个例子，这个例子很典型，用了两个 CountDownLatch：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt; Driver { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main() throws InterruptedException {
        CountDownLatch startSignal &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; CountDownLatch(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
        CountDownLatch doneSignal &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CountDownLatch(N);

        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; N; ++i) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; create and start threads&lt;/span&gt;
            &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Worker(startSignal, doneSignal)).start();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这边插入一些代码，确保上面的每个线程先启动起来，才执行下面的代码。&lt;/span&gt;
        doSomethingElse();            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; don't let run yet
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 因为这里 N == 1，所以，只要调用一次，那么所有的 await 方法都可以通过&lt;/span&gt;
        startSignal.countDown();      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; let all threads proceed&lt;/span&gt;
&lt;span&gt;        doSomethingElse();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 等待所有任务结束&lt;/span&gt;
        doneSignal.&lt;span&gt;await&lt;/span&gt;();           &lt;span&gt;//&lt;/span&gt;&lt;span&gt; wait for all to finish&lt;/span&gt;
&lt;span&gt;    }
}

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Worker implements Runnable {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; final CountDownLatch startSignal;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; final CountDownLatch doneSignal;

    Worker(CountDownLatch startSignal, CountDownLatch doneSignal) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.startSignal =&lt;span&gt; startSignal;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.doneSignal =&lt;span&gt; doneSignal;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 为了让所有线程同时开始任务，我们让所有线程先阻塞在这里
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 等大家都准备好了，再打开这个门栓&lt;/span&gt;
            startSignal.&lt;span&gt;await&lt;/span&gt;&lt;span&gt;();
            doWork();
            doneSignal.countDown();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException ex) {
        } &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; return;&lt;/span&gt;
&lt;span&gt;    }

    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; doWork() { ...}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个例子中，doneSignal 同第一个例子的使用，我们说说这里的 startSignal。N 个新开启的线程都调用了startSignal.await() 进行阻塞等待，它们阻塞在栅栏上，只有当条件满足的时候（startSignal.countDown()），它们才能同时通过这个栅栏。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1168971/201812/1168971-20181228145249869-1687803573.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果始终只有一个线程调用 await 方法等待任务完成，那么 CountDownLatch 就会简单很多，所以之后的源码分析读者一定要在脑海中构建出这么一个场景：有 m 个线程是做任务的，有 n 个线程在某个栅栏上等待这 m 个线程做完任务，直到所有 m 个任务完成后，n 个线程同时通过栅栏。&lt;/p&gt;
&lt;h3 id=&quot;%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90&quot;&gt;源码分析&lt;/h3&gt;
&lt;p&gt;构造方法，需要传入一个不小于 0 的整数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; CountDownLatch(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; count) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (count &amp;lt; &lt;span&gt;0&lt;/span&gt;) &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;count &amp;lt; 0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.sync = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Sync(count);
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 老套路了，内部封装一个 Sync 类继承自 AQS&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; final &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Sync extends AbstractQueuedSynchronizer {
    Sync(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; count) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这样就 state == count 了&lt;/span&gt;
&lt;span&gt;        setState(count);
    }
    ...
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;先分析套路：AQS 里面的 state 是一个整数值，这边用一个 int count 参数其实初始化就是设置了这个值，所有调用了 await 方法的等待线程会挂起，然后有其他一些线程调用会做 state = state - 1 操作，当 state 减到 0 的同时，那个线程会负责唤醒调用了 await 方法的所有线程。&lt;/p&gt;
&lt;p&gt;对于 CountDownLatch，我们仅仅需要关心两个方法，一个是 countDown() 方法，另一个是 await() 方法。countDown() 方法每次调用都会将 state 减 1，直到 state 的值为 0；而 await 是一个阻塞方法，当 state 减为 0 的时候，await 方法才会返回。await 可以被多个线程调用，读者这个时候脑子里要有个图：所有调用了 await 方法的线程阻塞在 AQS 的阻塞队列中，等待条件满足（state == 0），将线程从队列中一个个唤醒过来。&lt;/p&gt;
&lt;p&gt;我们用以下程序来分析源码，t1 和 t2 负责调用 countDown() 方法，t3 和 t4 调用 await 方法阻塞：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CountDownLatchDemo {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;         CountDownLatch latch = &lt;span&gt;new&lt;/span&gt; CountDownLatch(&lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;         Thread t1 = &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;            @Override
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                 &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                     Thread.sleep(&lt;span&gt;5000&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException ignore) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 休息 5 秒后(模拟线程工作了 5 秒)，调用 countDown()&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;                latch.countDown();
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         }, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;t1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;         Thread t2 = &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;            @Override
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                 &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                     Thread.sleep(&lt;span&gt;10000&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                 } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException ignore) {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 休息 10 秒后(模拟线程工作了 10 秒)，调用 countDown()&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;                latch.countDown();
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         }, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;t2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt; &lt;span&gt;        t1.start();
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;        t2.start();
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; 
&lt;span&gt;34&lt;/span&gt;         Thread t3 = &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;            @Override
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;                 &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 阻塞，等待 state 减为 0&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt;                     latch.&lt;span&gt;await&lt;/span&gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;                     System.&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;线程 t3 从 await 中返回了&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;                 } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;                     System.&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;线程 t3 await 被中断&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;                    Thread.currentThread().interrupt();
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;         }, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;t3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;         Thread t4 = &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;            @Override
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;                 &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 阻塞，等待 state 减为 0&lt;/span&gt;
&lt;span&gt;52&lt;/span&gt;                     latch.&lt;span&gt;await&lt;/span&gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;                     System.&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;线程 t4 从 await 中返回了&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;                 } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;                     System.&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;线程 t4 await 被中断&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; &lt;span&gt;                    Thread.currentThread().interrupt();
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;         }, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;t4&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt; 
&lt;span&gt;61&lt;/span&gt; &lt;span&gt;        t3.start();
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt; &lt;span&gt;        t4.start();
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 上述程序，大概在过了 10 秒左右的时候，会输出：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
线程 t3 从 &lt;span&gt;await&lt;/span&gt;&lt;span&gt; 中返回了
线程 t4 从 &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; 中返回了
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这两条输出，顺序不是绝对的
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 后面的分析，我们假设 t3 先进入阻塞队列&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;接下来，我们按照流程一步一步走：先 await 等待，然后被唤醒，await 方法返回。&lt;/p&gt;
&lt;p&gt;首先，我们来看 await() 方法，它代表线程阻塞，等待 state 的值减为 0。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;await&lt;/span&gt;&lt;span&gt;() throws InterruptedException {
    sync.acquireSharedInterruptibly(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; final &lt;span&gt;void&lt;/span&gt; acquireSharedInterruptibly(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; arg)
        throws InterruptedException {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这也是老套路了，我在第二篇的中断那一节说过了&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (Thread.interrupted())
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; InterruptedException();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; t3 和 t4 调用 await 的时候，state 都大于 0。
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 也就是说，这个 if 返回 true，然后往里看&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (tryAcquireShared(arg) &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
        doAcquireSharedInterruptibly(arg);
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 只有当 state == 0 的时候，这个方法才会返回 1&lt;/span&gt;
&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; tryAcquireShared(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; acquires) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (getState() == &lt;span&gt;0&lt;/span&gt;) ? &lt;span&gt;1&lt;/span&gt; : -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从方法名我们就可以看出，这个方法是获取共享锁，并且此方法是可中断的（中断的时候抛出 InterruptedException 退出这个方法）。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; doAcquireSharedInterruptibly(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; arg)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    throws InterruptedException {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1. 入队&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     final Node node =&lt;span&gt; addWaiter(Node.SHARED);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     boolean failed = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (;;) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             final Node p =&lt;span&gt; node.predecessor();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (p ==&lt;span&gt; head) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 同上，只要 state 不等于 0，那么这个方法返回 -1&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;                 &lt;span&gt;int&lt;/span&gt; r =&lt;span&gt; tryAcquireShared(arg);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; r=-1时，这里if不会进入&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (r &amp;gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;                    setHeadAndPropagate(node, r);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                     p.next = &lt;span&gt;null&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; help GC&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;                     failed = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2. 这和第一篇AQS里面代码一样，修改前驱节点的waitStatus 为-1,同时挂起当前线程&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (shouldParkAfterFailedAcquire(p, node) &amp;amp;&amp;amp;
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;                parkAndCheckInterrupt())
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                 &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; InterruptedException();
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     } &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (failed)
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;            cancelAcquire(node);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们来仔细分析这个方法，线程 t3 经过第 1 步 第4行 addWaiter 入队以后，我们应该可以得到这个：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1168971/201812/1168971-20181228150947833-2057561998.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由于 tryAcquireShared 这个方法会返回 -1，所以 if (r &amp;gt;= 0) 这个分支不会进去。到 shouldParkAfterFailedAcquire 的时候，t3 将 head 的 waitStatus 值设置为 -1，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1168971/201812/1168971-20181228151017379-500706798.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后进入到 parkAndCheckInterrupt 的时候，t3 挂起。&lt;/p&gt;
&lt;p&gt;我们再分析 t4 入队，t4 会将前驱节点 t3 所在节点的 waitStatus 设置为 -1，t4 入队后，应该是这样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1168971/201812/1168971-20181228151058268-2133757989.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后，t4 也挂起。接下来，t3 和 t4 就等待唤醒了。&lt;/p&gt;
&lt;p&gt;接下来，我们来看唤醒的流程，我们假设用 10 初始化 CountDownLatch。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1168971/201812/1168971-20181228151135062-211890929.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当然，我们的例子中，其实没有 10 个线程，只有 2 个线程 t1 和 t2，只是为了让图好看些罢了。&lt;/p&gt;
&lt;p&gt;我们再一步步看具体的流程。首先，我们看 countDown() 方法:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; countDown() {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     sync.releaseShared(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; final boolean releaseShared(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; arg) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 只有当 state 减为 0 的时候，tryReleaseShared 才返回 true
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 否则只是简单的 state = state - 1 那么 countDown 方法就结束了&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (tryReleaseShared(arg)) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 唤醒 await 的线程&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        doReleaseShared();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这个方法很简单，用自旋的方法实现 state 减 1&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;protected&lt;/span&gt; boolean tryReleaseShared(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; releases) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (;;) {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; c =&lt;span&gt; getState();
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (c == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; nextc = c-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过CAS将state的值减1，失败就不会进入return,继续for循环，直至CAS成功&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (compareAndSetState(c, nextc))
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;state减到0就返回true,否则返回false&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; nextc == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;countDown 方法就是每次调用都将 state 值减 1，如果 state 减到 0 了，那么就调用下面的方法进行唤醒阻塞队列中的线程：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用这个方法的时候，state == 0&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; doReleaseShared() {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (;;) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         Node h =&lt;span&gt; head;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (h != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; h !=&lt;span&gt; tail) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; ws =&lt;span&gt; h.waitStatus;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; t3 入队的时候，已经将头节点的 waitStatus 设置为 Node.SIGNAL（-1） 了&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (ws ==&lt;span&gt; Node.SIGNAL) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (!compareAndSetWaitStatus(h, Node.SIGNAL, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                     &lt;span&gt;continue&lt;/span&gt;;            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; loop to recheck cases
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 就是这里，唤醒 head 的后继节点，也就是阻塞队列中的第一个节点
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在这里，也就是唤醒 t3 , t3的await()方法可以接着运行了&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;                unparkSuccessor(h);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (ws == &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp;
&lt;span&gt;16&lt;/span&gt;                      !compareAndSetWaitStatus(h, &lt;span&gt;0&lt;/span&gt;, Node.PROPAGATE)) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; todo&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;                 &lt;span&gt;continue&lt;/span&gt;;                &lt;span&gt;//&lt;/span&gt;&lt;span&gt; loop on failed CAS&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;此时 h == head 说明被唤醒的 t3线程 还没有执行到await()方法中的setHeadAndPropagate(node, r)这一步,则此时循环结束;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果执行完setHeadAndPropagate(node, r)，则head就为t3了，这里的h和head就不相等，会继续循环&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (h == head)                   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; loop if head changed&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;             &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;一旦 t3 被唤醒后，我们继续回到 await 的这段代码，在第24行代码 parkAndCheckInterrupt 返回继续接着运行，我们先不考虑中断的情况：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; doAcquireSharedInterruptibly(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; arg)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    throws InterruptedException {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     final Node node =&lt;span&gt; addWaiter(Node.SHARED);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     boolean failed = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (;;) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;p表示当前节点的前驱节点&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;             final Node p =&lt;span&gt; node.predecessor();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;此时被唤醒的是之前head的后继节点，所以此线程的前驱节点是head&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (p ==&lt;span&gt; head) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;此时state已经为0，r为1&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;                 &lt;span&gt;int&lt;/span&gt; r =&lt;span&gt; tryAcquireShared(arg);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (r &amp;gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2. 这里将唤醒t3的后续节点t4,以此类推，t4被唤醒后，会在t4的await中唤醒t4的后续节点&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;                    setHeadAndPropagate(node, r); 
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将已经唤醒的t3节点从队列中去除&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;                     p.next = &lt;span&gt;null&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; help GC&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;                     failed = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (shouldParkAfterFailedAcquire(p, node) &amp;amp;&amp;amp;
&lt;span&gt;23&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1. 唤醒后这个方法返回&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;                parkAndCheckInterrupt())
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;                 &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; InterruptedException();
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     } &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (failed)
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;            cancelAcquire(node);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;接下来，t3 会循环一次进到 setHeadAndPropagate(node, r) 这个方法，先把 head 给占了，然后唤醒队列中其他的线程：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setHeadAndPropagate(Node node, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; propagate) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     Node h = head; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Record old head for check below&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    setHead(node);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 下面说的是，唤醒当前 node 之后的节点，即 t3 已经醒了，马上唤醒 t4
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 类似的，如果 t4 后面还有 t5，那么 t4 醒了以后，马上将 t5 给唤醒了&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (propagate &amp;gt; &lt;span&gt;0&lt;/span&gt; || h == &lt;span&gt;null&lt;/span&gt; || h.waitStatus &amp;lt; &lt;span&gt;0&lt;/span&gt; ||
&lt;span&gt; 8&lt;/span&gt;         (h = head) == &lt;span&gt;null&lt;/span&gt; || h.waitStatus &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         Node s =&lt;span&gt; node.next;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (s == &lt;span&gt;null&lt;/span&gt; ||&lt;span&gt; s.isShared())
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 又是这个方法，只是现在的 head 已经不是原来的空节点了，是 t3 的节点了&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;            doReleaseShared();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;又回到这个方法了，那么接下来，我们好好分析 doReleaseShared 这个方法，我们根据流程，头节点 head 此时是 t3 节点了：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用这个方法的时候，state == 0&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; doReleaseShared() {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (;;) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         Node h =&lt;span&gt; head;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (h != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; h !=&lt;span&gt; tail) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; ws =&lt;span&gt; h.waitStatus;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; t4 将头节点(此时是 t3)的 waitStatus 设置为 Node.SIGNAL（-1） 了&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (ws ==&lt;span&gt; Node.SIGNAL) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (!compareAndSetWaitStatus(h, Node.SIGNAL, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                     &lt;span&gt;continue&lt;/span&gt;;            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; loop to recheck cases
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 就是这里，唤醒 head 的后继节点，也就是阻塞队列中的第一个节点
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在这里，也就是唤醒 t4&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;                unparkSuccessor(h);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (ws == &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp;
&lt;span&gt;16&lt;/span&gt;                      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这个 CAS 失败的场景是：执行到这里的时候，刚好有一个节点入队，入队会将这个 ws 设置为 -1&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;                      !compareAndSetWaitStatus(h, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, Node.PROPAGATE))
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                 &lt;span&gt;continue&lt;/span&gt;;                &lt;span&gt;//&lt;/span&gt;&lt;span&gt; loop on failed CAS&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果到这里的时候，前面唤醒的线程已经占领了 head，那么再循环
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 否则，就是 head 没变，那么退出循环，
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 退出循环是不是意味着阻塞队列中的其他节点就不唤醒了？当然不是，唤醒的线程之后还是会在await()方法中调用此方法接着唤醒后续节点&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (h == head)                   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; loop if head changed&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;             &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;总结&lt;/h3&gt;
&lt;p&gt;总的来说，CountDownLatch 就是线程入队阻塞，依次唤醒的过程&lt;/p&gt;
&lt;p&gt;使用过程会执行以下操作：&lt;/p&gt;
&lt;p&gt;　　1.当创建一个CountDownLatch 的实例后，AQS中的state会设置一个正整数&lt;/p&gt;
&lt;p&gt;　　2.一个线程调用await(),当前线程加入到阻塞队列中，当前线程挂起&lt;/p&gt;
&lt;p&gt;　　3.一个线程调用countDown()唤醒方法，state减1,直到state被减为0时，唤醒阻塞队列中第一个等待节点中的线程&lt;/p&gt;
&lt;p&gt;　　4.第一个线程被唤醒后，当前线程继续执行await()方法，将当前线程设置为head,并在此方法中唤醒head的下一个节点，依次类推&lt;/p&gt;

&lt;h2 id=&quot;CyclicBarrier&quot;&gt;CyclicBarrier&lt;/h2&gt;
&lt;p&gt;字面意思是“可重复使用的栅栏”，CyclicBarrier 相比 CountDownLatch 来说，要简单很多，其源码没有什么高深的地方，它是 ReentrantLock 和 Condition 的组合使用。看如下示意图，CyclicBarrier 和 CountDownLatch 是不是很像，只是 CyclicBarrier 可以有不止一个栅栏，因为它的栅栏（Barrier）可以重复使用（Cyclic）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1168971/201812/1168971-20181229151538696-527942080.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先，CyclicBarrier 的源码实现和 CountDownLatch 大相径庭，CountDownLatch 基于 AQS 的共享模式的使用，而 CyclicBarrier 基于 Condition 来实现。&lt;/p&gt;
&lt;p&gt;因为 CyclicBarrier 的源码相对来说简单许多，读者只要熟悉了前面关于 Condition 的分析，那么这里的源码是毫无压力的，就是几个特殊概念罢了。&lt;/p&gt;
&lt;p&gt;废话结束，先上基本属性和构造方法，往下拉一点点，和图一起看：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CyclicBarrier {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 我们说了，CyclicBarrier 是可以重复使用的，我们把每次从开始使用到穿过栅栏当做&quot;一代&quot;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Generation {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         boolean broken = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;* The lock for guarding barrier entry &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; final ReentrantLock &lt;span&gt;lock&lt;/span&gt; = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ReentrantLock();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; CyclicBarrier 是基于 Condition 的
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Condition 是“条件”的意思，CyclicBarrier 的等待线程通过 barrier 的“条件”是大家都到了栅栏上&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; final Condition trip = &lt;span&gt;lock&lt;/span&gt;&lt;span&gt;.newCondition();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 参与的线程数&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; final &lt;span&gt;int&lt;/span&gt;&lt;span&gt; parties;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果设置了这个，代表越过栅栏之前，要执行相应的操作&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; final Runnable barrierCommand;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当前所处的“代”&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; Generation generation = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Generation();
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 还没有到栅栏的线程数，这个值初始为 parties，然后递减
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 还没有到栅栏的线程数 = parties - 已经到栅栏的数量&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; count;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; CyclicBarrier(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; parties, Runnable barrierAction) {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (parties &amp;lt;= &lt;span&gt;0&lt;/span&gt;) &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalArgumentException();
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.parties =&lt;span&gt; parties;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.count =&lt;span&gt; parties;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.barrierCommand =&lt;span&gt; barrierAction;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; CyclicBarrier(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; parties) {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;(parties, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我用一图来描绘下 CyclicBarrier 里面的一些概念：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1168971/201812/1168971-20181229151614812-180387985.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在开始分析最重要的等待通过栅栏方法 await 方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 不带超时机制&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;await&lt;/span&gt;&lt;span&gt;() throws InterruptedException, BrokenBarrierException {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; dowait(&lt;span&gt;false&lt;/span&gt;, &lt;span&gt;0L&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (TimeoutException toe) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Error(toe); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; cannot happen&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 带超时机制，如果超时抛出 TimeoutException 异常&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;await&lt;/span&gt;(&lt;span&gt;long&lt;/span&gt;&lt;span&gt; timeout, TimeUnit unit)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    throws InterruptedException,
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;           BrokenBarrierException,
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;           TimeoutException {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; dowait(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;, unit.toNanos(timeout));
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;继续往里看：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; dowait(boolean timed, &lt;span&gt;long&lt;/span&gt;&lt;span&gt; nanos)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;        throws InterruptedException, BrokenBarrierException,
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;               TimeoutException {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     final ReentrantLock &lt;span&gt;lock&lt;/span&gt; = &lt;span&gt;this&lt;/span&gt;.&lt;span&gt;lock&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 先要获取到锁，然后在 finally 中要记得释放锁
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果记得 Condition 部分的话，我们知道 condition 的 await 会释放锁，signal 的时候需要重新获取锁&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;lock&lt;/span&gt;.&lt;span&gt;lock&lt;/span&gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         final Generation g =&lt;span&gt; generation;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 检查栅栏是否被打破，如果被打破，抛出 BrokenBarrierException 异常&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (g.broken)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BrokenBarrierException();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 检查中断状态，如果中断了，抛出 InterruptedException 异常&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (Thread.interrupted()) {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;            breakBarrier();
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; InterruptedException();
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; index 是这个 await 方法的返回值
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 注意到这里，这个是从 count 递减后得到的值&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; index = --&lt;span&gt;count;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;最后一个线程到达后, 唤醒所有等待的线程，开启新的一代（设置新的generation）
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果等于 0，说明所有的线程都到栅栏上了，准备通过&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (index == &lt;span&gt;0&lt;/span&gt;) {  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; tripped&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;             boolean ranAction = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果在初始化的时候，指定了通过栅栏前需要执行的操作，在这里会得到执行&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;                 final Runnable command =&lt;span&gt; barrierCommand;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (command != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;                    command.run();
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果 ranAction 为 true，说明执行 command.run() 的时候，没有发生异常退出的情况&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;                 ranAction = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 唤醒等待的线程，然后开启新的一代&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt; &lt;span&gt;                nextGeneration();
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;             } &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;ranAction)
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 进到这里，说明执行指定操作的时候，发生了异常，那么需要打破栅栏
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 之前我们说了，打破栅栏意味着唤醒所有等待的线程，设置 broken 为 true，重置 count 为 parties&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt; &lt;span&gt;                    breakBarrier();
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; 
&lt;span&gt;44&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; loop until tripped, broken, interrupted, or timed out
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果是最后一个线程调用 await，那么上面就返回了
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 下面的操作是给那些不是最后一个到达栅栏的线程执行的&lt;/span&gt;
&lt;span&gt;47&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (;;) {
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果带有超时机制，调用带超时的 Condition 的 await 方法等待，直到最后一个线程调用 await&lt;/span&gt;
&lt;span&gt;50&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;timed)
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;此线程会添加到Condition条件队列中，并在此阻塞&lt;/span&gt;
&lt;span&gt;52&lt;/span&gt;                     trip.&lt;span&gt;await&lt;/span&gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;                 &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (nanos &amp;gt; &lt;span&gt;0L&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;                     nanos =&lt;span&gt; trip.awaitNanos(nanos);
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;             } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException ie) {
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果到这里，说明等待的线程在 await（是 Condition 的 await）的时候被中断&lt;/span&gt;
&lt;span&gt;57&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (g == generation &amp;amp;&amp;amp; !&lt;span&gt; g.broken) {
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 打破栅栏&lt;/span&gt;
&lt;span&gt;59&lt;/span&gt; &lt;span&gt;                    breakBarrier();
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 打破栅栏后，重新抛出这个 InterruptedException 异常给外层调用的方法&lt;/span&gt;
&lt;span&gt;61&lt;/span&gt;                     &lt;span&gt;throw&lt;/span&gt;&lt;span&gt; ie;
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;                 } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; &lt;span&gt;                    Thread.currentThread().interrupt();
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt; 
&lt;span&gt;67&lt;/span&gt;               &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 唤醒后，检查栅栏是否是“破的”&lt;/span&gt;
&lt;span&gt;68&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (g.broken)
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt;                 &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BrokenBarrierException();
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt;                 
&lt;span&gt;71&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 上面最后一个线程执行nextGeneration()后，generation被重写设置
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 我们要清楚，最后一个线程在执行完指定任务(如果有的话)，会调用 nextGeneration 来开启一个新的代
&lt;/span&gt;&lt;span&gt;73&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 然后释放掉锁，其他线程从 Condition 的 await 方法中得到锁并返回，然后到这里的时候，其实就会满足 g != generation 的，因为最后一个到达的线程已经重写设置了generation&lt;/span&gt;
&lt;span&gt;74&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (g !=&lt;span&gt; generation)
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; index;
&lt;/span&gt;&lt;span&gt;76&lt;/span&gt; 
&lt;span&gt;77&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果醒来发现超时了，打破栅栏，抛出异常&lt;/span&gt;
&lt;span&gt;78&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (timed &amp;amp;&amp;amp; nanos &amp;lt;= &lt;span&gt;0L&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;79&lt;/span&gt; &lt;span&gt;                breakBarrier();
&lt;/span&gt;&lt;span&gt;80&lt;/span&gt;                 &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TimeoutException();
&lt;/span&gt;&lt;span&gt;81&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;82&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;83&lt;/span&gt;     } &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;84&lt;/span&gt;         &lt;span&gt;lock&lt;/span&gt;&lt;span&gt;.unlock();
&lt;/span&gt;&lt;span&gt;85&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;86&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;我们看看怎么开启新的一代：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 开启新的一代，当最后一个线程到达栅栏上的时候，调用这个方法来唤醒其他线程，同时初始化“下一代”&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; nextGeneration() {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 首先，需要唤醒所有的在栅栏上等待的线程&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;    trip.signalAll();
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 更新 count 的值&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt;     count =&lt;span&gt; parties;
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 重新生成“新一代”&lt;/span&gt;
&lt;span&gt;8&lt;/span&gt;     generation = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Generation();
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;看看怎么打破一个栅栏：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; breakBarrier() {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置状态 broken 为 true&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;     generation.broken = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 重置 count 为初始值 parties&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt;     count =&lt;span&gt; parties;
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 唤醒所有已经在等待的线程&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt; &lt;span&gt;    trip.signalAll();
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;整个过程已经很清楚了。&lt;/p&gt;
&lt;p&gt;下面我们来看看怎么得到有多少个线程到了栅栏上，处于等待状态：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getNumberWaiting() {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     final ReentrantLock &lt;span&gt;lock&lt;/span&gt; = &lt;span&gt;this&lt;/span&gt;.&lt;span&gt;lock&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;lock&lt;/span&gt;.&lt;span&gt;lock&lt;/span&gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; parties -&lt;span&gt; count;
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     } &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;         &lt;span&gt;lock&lt;/span&gt;&lt;span&gt;.unlock();
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;判断一个栅栏是否被打破了，这个很简单，直接看 broken 的值即可：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; boolean isBroken() {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     final ReentrantLock &lt;span&gt;lock&lt;/span&gt; = &lt;span&gt;this&lt;/span&gt;.&lt;span&gt;lock&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;lock&lt;/span&gt;.&lt;span&gt;lock&lt;/span&gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; generation.broken;
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     } &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;         &lt;span&gt;lock&lt;/span&gt;&lt;span&gt;.unlock();
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后，我们来看看怎么重置一个栅栏：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; reset() {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     final ReentrantLock &lt;span&gt;lock&lt;/span&gt; = &lt;span&gt;this&lt;/span&gt;.&lt;span&gt;lock&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;lock&lt;/span&gt;.&lt;span&gt;lock&lt;/span&gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         breakBarrier();   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; break the current generation&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;         nextGeneration(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; start a new generation&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     } &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;lock&lt;/span&gt;&lt;span&gt;.unlock();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;


&lt;h2 id=&quot;Semaphore&quot;&gt;Semaphore&lt;/h2&gt;
&lt;p&gt;有了 CountDownLatch 的基础后，分析 Semaphore 会简单很多。Semaphore 是什么呢？它类似一个资源池（读者可以类比线程池），每个线程需要调用 acquire() 方法获取资源，然后才能执行，执行完后，需要 release 资源，让给其他的线程用。&lt;/p&gt;
&lt;p&gt;套路解读：创建 Semaphore 实例的时候，需要一个参数 permits，这个基本上可以确定是设置给 AQS 的 state 的，然后每个线程调用 acquire 的时候，执行 state = state - 1，release 的时候执行 state = state + 1，当然，acquire 的时候，如果 state = 0，说明没有资源了，需要等待其他线程 release。&lt;/p&gt;
&lt;p&gt;构造方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; Semaphore(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; permits) {
    sync &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NonfairSync(permits);
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Semaphore(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; permits, boolean fair) {
    sync &lt;/span&gt;= fair ? &lt;span&gt;new&lt;/span&gt; FairSync(permits) : &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NonfairSync(permits);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 这里和 ReentrantLock 类似，用了公平策略和非公平策略。&lt;/p&gt;
&lt;p&gt;看 acquire 方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; acquire() throws InterruptedException {
    sync.acquireSharedInterruptibly(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; acquireUninterruptibly() {
    sync.acquireShared(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; acquire(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; permits) throws InterruptedException {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (permits &amp;lt; &lt;span&gt;0&lt;/span&gt;) &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalArgumentException();
    sync.acquireSharedInterruptibly(permits);
}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; acquireUninterruptibly(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; permits) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (permits &amp;lt; &lt;span&gt;0&lt;/span&gt;) &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalArgumentException();
    sync.acquireShared(permits);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这几个方法也是老套路了，大家基本都懂了吧，这边多了两个可以传参的 acquire 方法，不过大家也都懂的吧，如果我们需要一次获取超过一个的资源，会用得着这个的。&lt;/p&gt;
&lt;p&gt;我们接下来看不抛出 InterruptedException 异常的 acquireUninterruptibly() 方法吧：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; acquireUninterruptibly() {
    sync.acquireShared(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; final &lt;span&gt;void&lt;/span&gt; acquireShared(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; arg) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (tryAcquireShared(arg) &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
        doAcquireShared(arg);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;前面说了，Semaphore 分公平策略和非公平策略，我们对比一下两个 tryAcquireShared 方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 公平策略：&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; tryAcquireShared(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; acquires) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (;;) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 区别就在于是不是会先判断是否有线程在排队，然后才进行 CAS 减操作
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这个就不分析了，第一篇AQS中已经讲过&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (hasQueuedPredecessors())
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;进入到这里说明阻塞队列中已经有线程在等着获取资源&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; available =&lt;span&gt; getState();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; remaining = available -&lt;span&gt; acquires;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;当remaining最小为0时，会CAS设置state为0,成功返回remaining
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;当remaining小于0时，这里会直接返回remaining，这里不会执行compareAndSetState&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (remaining &amp;lt; &lt;span&gt;0&lt;/span&gt; ||
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;            compareAndSetState(available, remaining))
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; remaining;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 非公平策略：&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; tryAcquireShared(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; acquires) {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; nonfairTryAcquireShared(acquires);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; final &lt;span&gt;int&lt;/span&gt; nonfairTryAcquireShared(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; acquires) {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (;;) {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; available =&lt;span&gt; getState();
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; remaining = available -&lt;span&gt; acquires;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (remaining &amp;lt; &lt;span&gt;0&lt;/span&gt; ||
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;            compareAndSetState(available, remaining))
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; remaining;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们再回到 acquireShared 方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; final &lt;span&gt;void&lt;/span&gt; acquireShared(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; arg) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (tryAcquireShared(arg) &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;        doAcquireShared(arg);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;当 tryAcquireShared(arg)大于或者等于0时，获取资源成功，接着执行acquire()后面的业务代码;&lt;/p&gt;
&lt;p&gt;当 tryAcquireShared(arg) 返回小于 0 的时候，说明 state 已经小于 0 了（没资源了），此时 acquire 不能立马拿到资源，需要进入到阻塞队列等待,即执行上面第3行代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; doAcquireShared(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; arg) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     final Node node =&lt;span&gt; addWaiter(Node.SHARED);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     boolean failed = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         boolean interrupted = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (;;) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             final Node p =&lt;span&gt; node.predecessor();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (p ==&lt;span&gt; head) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                 &lt;span&gt;int&lt;/span&gt; r =&lt;span&gt; tryAcquireShared(arg);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (r &amp;gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;                    setHeadAndPropagate(node, r);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                     p.next = &lt;span&gt;null&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; help GC&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (interrupted)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;                        selfInterrupt();
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                     failed = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (shouldParkAfterFailedAcquire(p, node) &amp;amp;&amp;amp;
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;                parkAndCheckInterrupt())
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                 interrupted = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     } &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (failed)
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;            cancelAcquire(node);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个方法我就不介绍了，前面有很多地方介绍过这个方法，线程挂起后等待有资源被 release 出来。接下来，我们就要看 release 的方法了：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 任务介绍，释放一个资源&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; release() {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     sync.releaseShared(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; final boolean releaseShared(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; arg) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (tryReleaseShared(arg)) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        doReleaseShared();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;protected&lt;/span&gt; final boolean tryReleaseShared(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; releases) {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (;;) {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; current =&lt;span&gt; getState();
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; next = current +&lt;span&gt; releases;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 溢出，当然，我们一般也不会用这么大的数&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (next &amp;lt; current) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; overflow&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Error(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Maximum permit count exceeded&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 　　　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt;释放资源后，将state的值又加上释放资源数&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (compareAndSetState(current, next))
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;tryReleaseShared 方法总是会返回 true，此时state的资源数已经加上了，然后是 doReleaseShared，这个也是我们熟悉的方法了，我就贴下代码，不分析了，这个方法用于唤醒所有的等待线程中的第一个等待的线程：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; doReleaseShared() {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (;;) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         Node h =&lt;span&gt; head;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (h != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; h !=&lt;span&gt; tail) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; ws =&lt;span&gt; h.waitStatus;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (ws ==&lt;span&gt; Node.SIGNAL) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (!compareAndSetWaitStatus(h, Node.SIGNAL, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                     &lt;span&gt;continue&lt;/span&gt;;            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; loop to recheck cases&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;                unparkSuccessor(h);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (ws == &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp;
&lt;span&gt;12&lt;/span&gt;                      !compareAndSetWaitStatus(h, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, Node.PROPAGATE))
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 &lt;span&gt;continue&lt;/span&gt;;                &lt;span&gt;//&lt;/span&gt;&lt;span&gt; loop on failed CAS&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (h == head)                   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; loop if head changed&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;第一个等待的线程被唤醒后，doReleaseShared终止，接着doAcquireShared()方法被唤醒接着运行，如果资源还够用，则唏嘘唤醒下一个等待节点，可以看到doAcquireShared()方法中第11行处 设置当前节点为head节点，并唤醒下一个等待节点&lt;/p&gt;
&lt;p&gt;Semphore 的源码确实很简单，方法都和CountDownLatch 中差不多，基本上都是分析过的老代码的组合使用了。&lt;/p&gt;

</description>
<pubDate>Sat, 29 Dec 2018 07:24:00 +0000</pubDate>
<dc:creator>chen_hao</dc:creator>
<og:description>这篇，我们的关注点是 AQS 最后的部分，共享模式的使用。本文先用 CountDownLatch 将共享模式说清楚，然后顺着把其他 AQS 相关的类 CyclicBarrier、Semaphore 的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/java-chen-hao/p/10191106.html</dc:identifier>
</item>
<item>
<title>Python机器学习笔记：sklearn库的学习 - 战争热诚</title>
<link>http://www.cnblogs.com/wj-1314/p/10179741.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wj-1314/p/10179741.html</guid>
<description>&lt;p&gt;　　网上有很多关于sklearn的学习教程，大部分都是简单的讲清楚某一方面，其实最好的教程就是官方文档。&lt;/p&gt;
&lt;p&gt;　　官方文档地址：&lt;a href=&quot;https://scikit-learn.org/stable/&quot; target=&quot;_blank&quot;&gt;https://scikit-learn.org/stable/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;（可是官方文档非常详细，同时许多人对官方文档的理解和结构上都不能很好地把握，我也打算好好学习sklearn，比较这可能是机器学习的神器），下面先简单介绍一下sklearn。&lt;/p&gt;
&lt;p&gt;　　自2007年发布以来，scikit-learn已经成为Python重要的机器学习库了，scikit-learn简称sklearn，支持包括分类，回归，降维和聚类四大机器学习算法。还包括了特征提取，数据处理和模型评估者三大模块。&lt;/p&gt;
&lt;p&gt;　　sklearn是Scipy的扩展，建立在Numpy和matplolib库的基础上。利用这几大模块的优势，可以大大的提高机器学习的效率。&lt;/p&gt;
&lt;p&gt;　　sklearn拥有着完善的文档，上手容易，具有着丰富的API，在学术界颇受欢迎。sklearn已经封装了大量的机器学习算法，包括LIBSVM和LIBINEAR。同时sklearn内置了大量数据集，节省了获取和整理数据集的时间。&lt;/p&gt;
&lt;h2&gt;一，sklearn官方文档的内容和结构&lt;/h2&gt;
&lt;h3&gt;1.1 sklearn官方文档的内容&lt;/h3&gt;
&lt;p&gt;　　定义：针对经验E和一系列的任务T和一定表现的衡量P，如果随着经验E的积累，针对定义好的任务T可以提高表现P，就说明机器具有学习能力。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201812/1226410-20181226160327923-368331861.png&quot; alt=&quot;&quot; width=&quot;658&quot; height=&quot;461&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;1.2 sklearn官方文档结构&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201812/1226410-20181226160551706-1877457387.png&quot; alt=&quot;&quot; width=&quot;638&quot; height=&quot;397&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　由图中，可以看到库的算法主要有四类：分类，回归，聚类，降维。其中：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;常用的回归：线性、决策树、SVM、KNN ；集成回归：随机森林、Adaboost、GradientBoosting、Bagging、ExtraTrees&lt;/li&gt;
&lt;li&gt;常用的分类：线性、决策树、SVM、KNN，朴素贝叶斯；集成分类：随机森林、Adaboost、GradientBoosting、Bagging、ExtraTrees&lt;/li&gt;
&lt;li&gt;常用聚类：k均值（K-means）、层次聚类（Hierarchical clustering）、DBSCAN&lt;/li&gt;
&lt;li&gt;常用降维：LinearDiscriminantAnalysis、PCA&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这个流程图代表：蓝色圆圈是判断条件，绿色方框是可以选择的算法，我们可以根据自己的数据特征和任务目标去找一条自己的操作路线。&lt;/p&gt;
&lt;h2&gt; 二，sklearn的快速使用&lt;/h2&gt;
&lt;p&gt;　　传统的机器学习任务从开始到建模的一般流程就是：获取数据——》数据预处理——》训练模型——》模型评估——》预测，分类。本次我们将根据传统机器学习的流程，看看在每一步流程中都有哪些常用的函数以及他们的用法是怎么样的。那么首先先看一个简单的例子：&lt;/p&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;div readability=&quot;13&quot;&gt;
&lt;p&gt;　　鸢尾花识别是一个经典的机器学习分类问题，它的数据样本中包括了4个特征变量，1个类别变量，样本总数为150。&lt;/p&gt;
&lt;p&gt;　　它的目标是为了根据花萼长度（sepal length）、花萼宽度（sepal width）、花瓣长度（petal length）、花瓣宽度（petal width）这四个特征来识别出鸢尾花属于山鸢尾（iris-setosa）、变色鸢尾（iris-versicolor）和维吉尼亚鸢尾（iris-virginica）中的哪一种。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;42&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
# 引入数据集，sklearn包含众多数据集
from sklearn import datasets
# 将数据分为测试集和训练集
from sklearn.model_selection import train_test_split
# 利用邻近点方式训练数据
from sklearn.neighbors import KNeighborsClassifier

# 引入数据,本次导入鸢尾花数据，iris数据包含4个特征变量
iris = datasets.load_iris()
# 特征变量
iris_X = iris.data
# 目标值
iris_y = iris.target
# 利用train_test_split进行训练集和测试机进行分开，test_size占30%
X_train,X_test,y_train,y_test=train_test_split(iris_X,iris_y,test_size=0.3)
# 我们看到训练数据的特征值分为3类
print(y_train)
'''
[1 1 0 2 0 0 0 2 2 2 1 0 2 0 2 1 0 1 0 2 0 1 0 0 2 1 2 0 0 1 0 0 1 0 0 0 0
 2 2 2 1 1 1 2 0 2 0 1 1 1 1 2 2 1 2 2 2 0 2 2 2 0 1 0 1 0 0 1 2 2 2 1 1 1
 2 0 0 1 0 2 1 2 0 1 2 2 2 1 2 1 0 0 1 0 0 1 1 1 0 2 1 1 0 2 2]
 '''
# 训练数据
# 引入训练方法
knn = KNeighborsClassifier()
# 进行填充测试数据进行训练
knn.fit(X_train,y_train)

# 预测数据，预测特征值
print(knn.predict(X_test))
'''
[0 2 2 2 2 0 0 0 0 2 2 0 2 0 2 1 2 0 2 1 0 2 1 0 1 2 2 0 2 1 0 2 1 1 2 0 2
 1 2 0 2 1 0 1 2]
'''
# 打印真实特征值
print(y_test)
'''
[1 2 2 2 2 1 1 1 1 2 1 1 1 1 2 1 1 0 2 1 1 1 0 2 0 2 0 0 2 0 2 0 2 0 2 2 0
 2 2 0 1 0 2 0 0]

'''
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　下面，我们开始一步步介绍、&lt;/p&gt;
&lt;h3&gt;1，获取数据&lt;/h3&gt;
&lt;h4&gt;1.1 导入sklearn数据集&lt;/h4&gt;
&lt;p&gt;　　sklearn中包含了大量的优质的数据集，在我们学习机器学习的过程中，我们可以使用这些数据集实现出不同的模型，从而提高你动手实践能力，同时这个过程也可以加深对理论知识的理解和把握。除了引入数据之外，我们还可以通过load_sample_images()来引入图片。&lt;/p&gt;
&lt;p&gt;　　首先，要使用sklearn中的数据集，必须导入datasets模块。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
from sklearn import datasets
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　下面两个图中包含了大部分sklearn中的数据集，调用方式也图中给出，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201812/1226410-20181226200207982-56843137.png&quot; alt=&quot;&quot; width=&quot;546&quot; height=&quot;189&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201812/1226410-20181226200224113-110288242.png&quot; alt=&quot;&quot; width=&quot;548&quot; height=&quot;200&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201812/1226410-20181228164725522-211528755.png&quot; alt=&quot;&quot; width=&quot;591&quot; height=&quot;111&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这里我们使用iris的数据来举个例子，表示导出数据集：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
iris = datasets.load_iris() # 导入数据集
X = iris.data # 获得其特征向量
y = iris.target # 获得样本label
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;1.2 创建数据集&lt;/h4&gt;
&lt;p&gt;　　我们除了可以使用sklearn自带的数据集，还可以自己去创建训练样本，&lt;/p&gt;
&lt;p&gt;具体用法可以参考：&lt;a href=&quot;https://scikit-learn.org/stable/datasets/&quot; target=&quot;_blank&quot;&gt;　https://scikit-learn.org/stable/datasets/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201812/1226410-20181226202513959-392987018.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201812/1226410-20181226202635194-891354015.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　下面我们拿分类问题的样本生成器举例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;43&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
from sklearn.datasets.samples_generator import make_classification

X, y = make_classification(n_samples=6, n_features=5, n_informative=2, 
    n_redundant=2, n_classes=2, n_clusters_per_class=2, scale=1.0, 
    random_state=20)

# n_samples：指定样本数
# n_features：指定特征数
# n_classes：指定几分类
# random_state：随机种子，使得随机状可重
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　测试如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&amp;gt;&amp;gt;&amp;gt; for x_,y_ in zip(X,y):
    print(y_,end=': ')
    print(x_)

    
0: [-0.6600737  -0.0558978   0.82286793  1.1003977  -0.93493796]
1: [ 0.4113583   0.06249216 -0.90760075 -1.41296696  2.059838  ]
1: [ 1.52452016 -0.01867812  0.20900899  1.34422289 -1.61299022]
0: [-1.25725859  0.02347952 -0.28764782 -1.32091378 -0.88549315]
0: [-3.28323172  0.03899168 -0.43251277 -2.86249859 -1.10457948]
1: [ 1.68841011  0.06754955 -1.02805579 -0.83132182  0.93286635]
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;2，数据预处理&lt;/h3&gt;
&lt;p&gt;　　　数据预处理阶段是机器学习中不可缺少的一环，它会使得数据更加有效的被模型或者评估器识别。下面我们来看一下sklearn中有哪些平时我们常用的函数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
from sklearn import preprocessing
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　为了使得训练数据的标准化规则与测试数据的标准化规则同步，preprocessing中提供了很多的Scaler：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;StandardScaler&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MaxAbsScaler&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MinMaxScaler&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RobustScaler&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Normalizer&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;等其他预处理操作&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　对应的有直接的函数使用：scale()，maxabs_scale()，minmax_scale()，robust_scale()，normaizer（）&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
sklearn.preprocessing.scale(X)
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;2.1 数据标准化&lt;/h4&gt;
&lt;p&gt;　　标准化：在机器学习中，我们可能要处理不同种类的资料，例如，音讯和图片上的像素值，这些资料可能是高纬度的，资料标准化后会使得每个特征中的数值平均变为0（将每个特征的值都减掉原始资料中该特征的平均），标准差变为1，这个方法被广泛的使用在许多机器学习算法中（例如：支持向量机，逻辑回归和类神经网络）。&lt;/p&gt;
&lt;p&gt;　　StandardScaler计算训练集的平均值和标准差，以便测试数据及使用相同的变换。&lt;/p&gt;
&lt;p&gt;　　变换后各维特征有0均值，单位方差，也叫z-score规范化（零均值规范化），计算方式是将特征值减去均值，除以标准差。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;fit&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　用于计算训练数据的均值和方差，后面就会用均值和方差来转换训练数据&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;fit_transform&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　不仅计算训练数据的均值和方差，还会基于计算出来的均值和方差来转换训练数据，从而把数据转化成标准的正态分布。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;transform&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　很显然，它只是进行转换，只是把训练数据转换成标准的正态分布。（一般会把train和test集放在一起做标准化，或者在train集上做标准化后，用同样的标准化器去标准化test集，此时可以使用scaler)。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
data = [[0, 0], [0, 0], [1, 1], [1, 1]]
# 1. 基于mean和std的标准化
scaler = preprocessing.StandardScaler().fit(train_data)
scaler.transform(train_data)
scaler.transform(test_data)

&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　一般来说先使用fit：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
scaler = preocessing.StandardScaler().fit(X)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这一步可以计算得到scaler，scaler里面存的有计算出来的均值和方差。&lt;/p&gt;
&lt;p&gt;　　再使用transform&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
scaler.transform(X)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这一步再用scaler中的均值和方差来转换X，使X标准化。&lt;/p&gt;
&lt;p&gt;　　最后，在预测的时候，也要对数据做同样的标准化处理，即也要用上面的scaler中的均值和方差来对预测时候的特征进行标准化。&lt;/p&gt;
&lt;p&gt;　　注意：测试数据和预测数据的标准化的方式要和训练数据标准化的方式一样，必须使用同一个scaler来进行transform&lt;/p&gt;
&lt;h4&gt;2.2 最小-最大规范化&lt;/h4&gt;
&lt;p&gt;　　最小最大规范化对原始数据进行线性变换，变换到[0,1]区间（也可以是其他固定最小最大值的区间）。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
# 2. 将每个特征值归一化到一个固定范围
scaler = preprocessing.MinMaxScaler(feature_range=(0, 1)).fit(train_data)
scaler.transform(train_data)
scaler.transform(test_data)
#feature_range: 定义归一化范围，注用（）括起来
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;2.3 正则化（normalize）&lt;/h4&gt;
&lt;p&gt; 　　当你想要计算两个样本的相似度时必不可少的一个操作，就是正则化。其思想是：首先求出样本的p范数，然后该样本的所有元素都要除以该范数，这样最终使得每个样本的范数都是1。规范化（Normalization）是将不同变化范围的值映射到相同的固定范围，常见的是[0,1]，也成为归一化。&lt;/p&gt;
&lt;p&gt;　　如下例子，将每个样本变换成unit norm。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;51&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&amp;gt;&amp;gt;&amp;gt; X = [[ 1., -1.,  2.],
...      [ 2.,  0.,  0.],
...      [ 0.,  1., -1.]]
&amp;gt;&amp;gt;&amp;gt; X_normalized = preprocessing.normalize(X, norm='l2')

&amp;gt;&amp;gt;&amp;gt; X_normalized                                      
array([[ 0.40..., -0.40...,  0.81...],
       [ 1.  ...,  0.  ...,  0.  ...],
       [ 0.  ...,  0.70..., -0.70...]])
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　我们可以发现对于每一个样本都有0.4^2+0.4^2+0.81^2=1。这就是L2 norm，变换后每个样本的各维特征的平方和为1.类似的，L1 norm则是变换后每个样本的各维特征的绝对值之和为1.还有max norm，则是将每个样本的各维特征除以该样本各维特征的最大值，&lt;/p&gt;
&lt;p&gt;　　在度量样本之间相似性时，如果使用的是二次型kernel，则需要做Normalization。&lt;/p&gt;

&lt;h4&gt;2.4 one-hot编码&lt;/h4&gt;
&lt;p&gt;　　one-hot编码是一种对离散特征值的编码方式，在LR模型中常用到，用于给线性模型增加非线性能力。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;44&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
data = [[0, 0, 3], [1, 1, 0], [0, 2, 1], [1, 0, 2]]
encoder = preprocessing.OneHotEncoder().fit(data)
enc.transform(data).toarray()
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;2.5 特征二值化（Binarization）&lt;/h4&gt;
&lt;p&gt;　　给定阈值，将特征转换为0/1.&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
binarizer = sklearn.preprocessing.Binarizer(threshold=1.1)

binarizer.transform(X)
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;2.6 类别特征编码&lt;/h4&gt;
&lt;p&gt;　　有时候特征时类别型的，而一些算法的输入必须是数值型，此时需要对其编码，&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;54&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
enc = preprocessing.OneHotEncoder()
enc.fit([[0, 0, 3], [1, 1, 0], [0, 2, 1], [1, 0, 2]])
enc.transform([[0, 1, 3]]).toarray()  #array([[ 1., 0., 0., 1., 0., 0., 0., 0., 1.]])
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面这个例子，第一维特征有两种值0和1，用两位去编码。第二维用三位，第三维用四位。&lt;/p&gt;
&lt;h4&gt;2.7 标签编码（Label encoding）&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;50&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
le = sklearn.preprocessing.LabelEncoder()  
le.fit([1, 2, 2, 6]) 
le.transform([1, 1, 2, 6])  #array([0, 0, 1, 2]) 
#非数值型转化为数值型
le.fit([&quot;paris&quot;, &quot;paris&quot;, &quot;tokyo&quot;, &quot;amsterdam&quot;])
le.transform([&quot;tokyo&quot;, &quot;tokyo&quot;, &quot;paris&quot;])  #array([2, 2, 1])
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;3，数据集拆分&lt;/h3&gt;
&lt;p&gt;　　在得到训练数据集时，通常我们经常会把训练数据进一步拆分成训练集和验证集，这样有助于我们模型参数的选取。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;43&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
# 作用：将数据集划分为 训练集和测试集
# 格式：train_test_split(*arrays, **options)
from sklearn.mode_selection import train_test_split

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)
&quot;&quot;&quot;
参数
---
arrays：样本数组，包含特征向量和标签

test_size：
　　float-获得多大比重的测试样本 （默认：0.25）
　　int - 获得多少个测试样本

train_size: 同test_size

random_state:
　　int - 随机种子（种子固定，实验可复现）
　　
shuffle - 是否在分割之前对数据进行洗牌（默认True）

返回
---
分割后的列表，长度=2*len(arrays), 
　　(train-test split)
&quot;&quot;&quot;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;4，定义模型&lt;/h3&gt;
&lt;p&gt;　　在这一步我们首先要分析自己数据的类型，明白自己要用什么模型来做，然后我们就可以在sklearn中定义模型了，sklearn为所有模型提供了非常相似的接口，这样使得我们可以更加快速的熟悉所有模型的用法，在这之前，我们先来看看模型的常用属性和功能。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
# 拟合模型
model.fit(X_train, y_train)
# 模型预测
model.predict(X_test)

# 获得这个模型的参数
model.get_params()
# 为模型进行打分
model.score(data_X, data_y) # 线性回归：R square； 分类问题： acc
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;4.1 线性回归&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201812/1226410-20181228161106488-773605000.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
from sklearn.linear_model import LinearRegression
# 定义线性回归模型
model = LinearRegression(fit_intercept=True, normalize=False, 
    copy_X=True, n_jobs=1)

&quot;&quot;&quot;
参数
---
    fit_intercept：是否计算截距。False-模型没有截距
    normalize： 当fit_intercept设置为False时，该参数将被忽略。 如果为真，
则回归前的回归系数X将通过减去平均值并除以l2-范数而归一化。
     n_jobs：指定线程数
&quot;&quot;&quot;
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;4.2 逻辑回归LR&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;48&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
from sklearn.linear_model import LogisticRegression
# 定义逻辑回归模型
model = LogisticRegression(penalty=’l2’, dual=False, tol=0.0001, C=1.0, 
    fit_intercept=True, intercept_scaling=1, class_weight=None, 
    random_state=None, solver=’liblinear’, max_iter=100, multi_class=’ovr’, 
    verbose=0, warm_start=False, n_jobs=1)

&quot;&quot;&quot;参数
---
    penalty：使用指定正则化项（默认：l2）
    dual: n_samples &amp;gt; n_features取False（默认）
    C：正则化强度的反，值越小正则化强度越大
    n_jobs: 指定线程数
    random_state：随机数生成器
    fit_intercept: 是否需要常量
&quot;&quot;&quot;
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;4.3 朴素贝叶斯算法NB（Naive Bayes）&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
from sklearn import naive_bayes
model = naive_bayes.GaussianNB() # 高斯贝叶斯
model = naive_bayes.MultinomialNB(alpha=1.0, fit_prior=True, class_prior=None)
model = naive_bayes.BernoulliNB(alpha=1.0, binarize=0.0, fit_prior=True, class_prior=None)
&quot;&quot;&quot;
文本分类问题常用MultinomialNB
参数
---
    alpha：平滑参数
    fit_prior：是否要学习类的先验概率；false-使用统一的先验概率
    class_prior: 是否指定类的先验概率；若指定则不能根据参数调整
    binarize: 二值化的阈值，若为None，则假设输入由二进制向量组成
&quot;&quot;&quot;
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt; 4.4 决策树DT&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;46&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
from sklearn import tree 
model = tree.DecisionTreeClassifier(criterion=’gini’, max_depth=None, 
    min_samples_split=2, min_samples_leaf=1, min_weight_fraction_leaf=0.0, 
    max_features=None, random_state=None, max_leaf_nodes=None, 
    min_impurity_decrease=0.0, min_impurity_split=None,
     class_weight=None, presort=False)
&quot;&quot;&quot;参数
---
    criterion ：特征选择准则gini/entropy
    max_depth：树的最大深度，None-尽量下分
    min_samples_split：分裂内部节点，所需要的最小样本树
    min_samples_leaf：叶子节点所需要的最小样本数
    max_features: 寻找最优分割点时的最大特征数
    max_leaf_nodes：优先增长到最大叶子节点数
    min_impurity_decrease：如果这种分离导致杂质的减少大于或等于这个值，则节点将被拆分。
&quot;&quot;&quot;
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;4.5 支持向量机SVM&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
from sklearn.svm import SVC
model = SVC(C=1.0, kernel=’rbf’, gamma=’auto’)
&quot;&quot;&quot;参数
---
    C：误差项的惩罚参数C
    gamma: 核相关系数。浮点数，If gamma is ‘auto’ then 1/n_features will be used instead.
&quot;&quot;&quot;
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;4.6 k近邻算法KNN&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
from sklearn import neighbors
#定义kNN分类模型
model = neighbors.KNeighborsClassifier(n_neighbors=5, n_jobs=1) # 分类
model = neighbors.KNeighborsRegressor(n_neighbors=5, n_jobs=1) # 回归
&quot;&quot;&quot;参数
---
    n_neighbors： 使用邻居的数目
    n_jobs：并行任务数
&quot;&quot;&quot;
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;4.7 多层感知器（神经网络）&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
from sklearn.neural_network import MLPClassifier
# 定义多层感知机分类算法
model = MLPClassifier(activation='relu', solver='adam', alpha=0.0001)
&quot;&quot;&quot;参数
---
    hidden_layer_sizes: 元祖
    activation：激活函数
    solver ：优化算法{‘lbfgs’, ‘sgd’, ‘adam’}
    alpha：L2惩罚(正则化项)参数。
&quot;&quot;&quot;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;5，模型评估与选择&lt;/h3&gt;
&lt;p&gt;　　评价指标针对不同的机器学习任务有不同的指标，同一任务也有不同侧重点的评价指标。以下方法，sklearn中都在sklearn.metrics类下，务必记住那些指标适合分类，那些适合回归。&lt;/p&gt;
&lt;p&gt; 　　机器学习常用的评估指标请参考博文：&lt;a href=&quot;https://www.cnblogs.com/wj-1314/p/9400375.html&quot; target=&quot;_blank&quot;&gt;Python机器学习笔记：常用评估指标的前世今生&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;5.1 交叉验证&lt;/h4&gt;
&lt;p&gt;交叉验证cross_val_score的scoring参数&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;分类：accuracy(准确率)、f1、f1_micro、f1_macro（这两个用于多分类的f1_score）、precision(精确度)、recall(召回率)、roc_auc&lt;/li&gt;
&lt;li&gt;回归：neg_mean_squared_error（MSE、均方误差）、r2&lt;/li&gt;
&lt;li&gt;聚类：adjusted_rand_score、completeness_score等 &lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
from sklearn.model_selection import cross_val_score
cross_val_score(model, X, y=None, scoring=None, cv=None, n_jobs=1)
&quot;&quot;&quot;参数
---
    model：拟合数据的模型
    cv ： k-fold
    scoring: 打分参数-‘accuracy’、‘f1’、‘precision’、‘recall’ 、‘roc_auc’、'neg_log_loss'等等
&quot;&quot;&quot;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;（补充）：交叉验证的学习&lt;/h3&gt;
&lt;h4&gt;　　1，导入k折交叉验证模块&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
from sklearn.cross_validation import cross_val_score
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;　　2，交叉验证的思想&lt;/h4&gt;
&lt;p&gt;　　把某种意义下将原始数据（dataset）进行分组，一部分作为训练集（train set），另一部分作为验证集（validation set or test set），首先用训练集对分类器进行训练，再利用验证集来测试训练得到的模型（model），以此来作为评价分类器的性能指标。&lt;/p&gt;
&lt;h4&gt;　　3，为什么使用交叉验证法&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;交叉验证用于评估模型的预测性能，尤其是训练好的模型在新数据上的表现，可以在一定程序熵减少过拟合。&lt;/li&gt;
&lt;li&gt;交叉验证还可以从有限的数据中获取尽可能多的有效信息&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;　　4，主要有哪些方法&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;1，留出法（holdout cross validation）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　在机器学习任务中，拿到数据后，我们首先会将原始数据集分为三部分：训练集，验证集和测试集。&lt;/p&gt;
&lt;p&gt;　　训练集用于训练模型，验证集用于模型的参数选择配置，测试集对于模型来说是未知数据，用于评估模型的泛化能力。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201812/1226410-20181228152012837-14189740.png&quot; alt=&quot;&quot; width=&quot;586&quot; height=&quot;373&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这个方法操作简单，只需要随机将原始数据分为三组即可。&lt;/p&gt;
&lt;p&gt;　　不过如果只做一次分割，它对训练集，验证集和测试机的样本比例，还有分割后数据的分布是否和原始数据集的分布相同等因素比较敏感，不同的划分会得到不同的最优模型，，而且分成三个集合后，用于训练的数据更少了。于是又了2.k折交叉验证（k-fold cross validation）.&lt;/p&gt;
&lt;p&gt;　　下面例子，一共有150条数据：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&amp;gt;&amp;gt;&amp;gt; import numpy as np
&amp;gt;&amp;gt;&amp;gt; from sklearn.model_selection import train_test_split
&amp;gt;&amp;gt;&amp;gt; from sklearn import datasets
&amp;gt;&amp;gt;&amp;gt; from sklearn import svm

&amp;gt;&amp;gt;&amp;gt; iris = datasets.load_iris()
&amp;gt;&amp;gt;&amp;gt; iris.data.shape, iris.target.shape
((150, 4), (150,))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　用train_test_split来随机划分数据集，其中40%用于测试集，有60条数据，60%为训练集，有90条数据：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;48&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&amp;gt;&amp;gt;&amp;gt; X_train, X_test, y_train, y_test = train_test_split(
...     iris.data, iris.target, test_size=0.4, random_state=0)

&amp;gt;&amp;gt;&amp;gt; X_train.shape, y_train.shape
((90, 4), (90,))
&amp;gt;&amp;gt;&amp;gt; X_test.shape, y_test.shape
((60, 4), (60,))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　用train来训练，用test来评价模型的分数。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&amp;gt;&amp;gt;&amp;gt; clf = svm.SVC(kernel='linear', C=1).fit(X_train, y_train)
&amp;gt;&amp;gt;&amp;gt; clf.score(X_test, y_test)                           
0.96...
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;2，2. k 折交叉验证（k-fold cross validation）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201812/1226410-20181228150306228-2016486943.png&quot; alt=&quot;&quot; width=&quot;540&quot; height=&quot;297&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　K折交叉验证通过对k个不同分组训练的结果进行平均来减少方差，因此模型的性能对数据的划分就不那么敏感。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第一步，不重复抽样将原始数据随机分为 k 份。&lt;/li&gt;
&lt;li&gt;第二步，每一次挑选其中 1 份作为测试集，剩余 k-1 份作为训练集用于模型训练。&lt;/li&gt;
&lt;li&gt;第三步，重复第二步 k 次，这样每个子集都有一次机会作为测试集，其余机会作为训练集。&lt;/li&gt;
&lt;li&gt;在每个训练集上训练后得到一个模型，&lt;/li&gt;
&lt;li&gt;用这个模型在相应的测试集上测试，计算并保存模型的评估指标，&lt;/li&gt;
&lt;li&gt;第四步，计算 k 组测试结果的平均值作为模型精度的估计，并作为当前 k 折交叉验证下模型的性能指标。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;K一般取10，数据量小的是，k可以设大一点，这样训练集占整体比例就比较大，不过同时训练的模型个数也增多。数据量大的时候，k可以设置小一点。当k=m的时候，即样本总数，出现了留一法。&lt;/p&gt;
&lt;p&gt;　　举例，这里直接调用了cross_val_score，这里用了5折交叉验证&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;42&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&amp;gt;&amp;gt;&amp;gt; from sklearn.model_selection import cross_val_score
&amp;gt;&amp;gt;&amp;gt; clf = svm.SVC(kernel='linear', C=1)
&amp;gt;&amp;gt;&amp;gt; scores = cross_val_score(clf, iris.data, iris.target, cv=5)
&amp;gt;&amp;gt;&amp;gt; scores                                              
array([ 0.96...,  1.  ...,  0.96...,  0.96...,  1.        ])
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　得到最后平均分数为0.98，以及它的95%置信区间：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&amp;gt;&amp;gt;&amp;gt; print(&quot;Accuracy: %0.2f (+/- %0.2f)&quot; % (scores.mean(), scores.std() * 2))
Accuracy: 0.98 (+/- 0.03)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　我们可以直接看一下K-Fold是怎么样划分数据的：X有四个数据，把它分成2折，结构中最后一个集合是测试集，前面的是训练集，每一行为1折：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&amp;gt;&amp;gt;&amp;gt; import numpy as np
&amp;gt;&amp;gt;&amp;gt; from sklearn.model_selection import KFold

&amp;gt;&amp;gt;&amp;gt; X = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]
&amp;gt;&amp;gt;&amp;gt; kf = KFold(n_splits=2)
&amp;gt;&amp;gt;&amp;gt; for train, test in kf.split(X):
...     print(&quot;%s %s&quot; % (train, test))
[2 3] [0 1]
[0 1] [2 3]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　同样的数据X，我们来看LeaveOneOut后是什么样子，那就是把它分成4折，结果中最后一个集合是测试集，只有一个元素，前面的是训练集，每一行为1折：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&amp;gt;&amp;gt;&amp;gt; from sklearn.model_selection import LeaveOneOut

&amp;gt;&amp;gt;&amp;gt; X = [1, 2, 3, 4]
&amp;gt;&amp;gt;&amp;gt; loo = LeaveOneOut()
&amp;gt;&amp;gt;&amp;gt; for train, test in loo.split(X):
...     print(&quot;%s %s&quot; % (train, test))
[1 2 3] [0]
[0 2 3] [1]
[0 1 3] [2]
[0 1 2] [3]
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;3，留一法（Leave one out cross validation）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　&lt;/strong&gt;　每次的测试集都只有一个样本，要进行m次训练和预测，这个方法用于训练的数据只比整体数据集少一个样本，因此最接近原始样本的分布。但是训练复杂度增加了，因为模型的数量与原始数据样本数量相同。一般在数据缺少时使用。&lt;/p&gt;
&lt;p&gt;此外：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;多次 k 折交叉验证再求均值，例如：10 次 10 折交叉验证，以求更精确一点。&lt;/li&gt;
&lt;li&gt;划分时有多种方法，例如对非平衡数据可以用分层采样，就是在每一份子集中都保持和原始数据集相同的类别比例。&lt;/li&gt;
&lt;li&gt;模型训练过程的所有步骤，包括模型选择，特征选择等都是在单个折叠 fold 中独立执行的。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;4，Bootstrapping&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　通过自助采样法，即在含有 m 个样本的数据集中，每次随机挑选一个样本，再放回到数据集中，再随机挑选一个样本，这样有放回地进行抽样 m 次，组成了新的数据集作为训练集。&lt;/p&gt;
&lt;p&gt;　　这里会有重复多次的样本，也会有一次都没有出现的样本，原数据集中大概有 36.8% 的样本不会出现在新组数据集中。&lt;/p&gt;
&lt;p&gt;　　优点是训练集的样本总数和原数据集一样都是 m，并且仍有约 1/3 的数据不被训练而可以作为测试集。 &lt;br/&gt;　　缺点是这样产生的训练集的数据分布和原数据集的不一样了，会引入估计偏差。 &lt;br/&gt;　　（此种方法不是很常用，除非数据量真的很少）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;h4&gt;5.2 检验曲线&lt;/h4&gt;
&lt;p&gt;　　使用检验曲线，我们可以更加方便的改变模型参数，获取模型表现。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;44&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
from sklearn.model_selection import validation_curve
train_score, test_score = validation_curve(model, X, y, param_name, param_range, cv=None, scoring=None, n_jobs=1)
&quot;&quot;&quot;参数
---
    model:用于fit和predict的对象
    X, y: 训练集的特征和标签
    param_name：将被改变的参数的名字
    param_range： 参数的改变范围
    cv：k-fold
   
返回值
---
   train_score: 训练集得分（array）
    test_score: 验证集得分（array）
&quot;&quot;&quot;
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;5.3 分类模型&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;accuracy_score（准确率得分）是模型分类正确的数据除以样本总数 【模型的score方法算的也是准确率】&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
accuracy_score(y_test,y_pre)
# 或者 model.score(x_test,y_test)，大多模型都是有score方法的
&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;&lt;li&gt;classification_report中的各项得分的avg/total 是每一分类占总数的比例加权算出来的&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
print(classification_report(y_test,y_log_pre))

             precision    recall  f1-score   support

          0       0.87      0.94      0.90       105
          1       0.91      0.79      0.85        73

avg / total       0.88      0.88      0.88       178
&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;&lt;li&gt;confusion_matrix（混淆矩阵），用来评估分类的准确性&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;52&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&amp;gt;&amp;gt;&amp;gt; from sklearn.metrics import confusion_matrix
&amp;gt;&amp;gt;&amp;gt; y_true = [2, 0, 2, 2, 0, 1]
&amp;gt;&amp;gt;&amp;gt; y_pred = [0, 0, 2, 2, 0, 2]
&amp;gt;&amp;gt;&amp;gt; confusion_matrix(y_true, y_pred)
array([[2, 0, 0],
       [0, 0, 1],
       [1, 0, 2]])
&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;&lt;li&gt;precision_score(精确度)、recall_score(召回率)、f1_score（后者由前两个推导出的）&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
这三个不仅适合二分类，也适合多分类。只需要指出参数average=‘micro’/‘macro’/'weighted’

    macro：计算二分类metrics的均值，为每个类给出相同权重的分值。
当小类很重要时会出问题，因为该macro-averging方法是对性能的平均。
另一方面，该方法假设所有分类都是一样重要的，因此macro-averaging
方法会对小类的性能影响很大

    micro： 给出了每个样本类以及它对整个metrics的贡献的pair（sample-
weight），而非对整个类的metrics求和，它会每个类的metrics上的权重及
因子进行求和，来计算整个份额。Micro-averaging方法在多标签（multilabel）
问题中设置，包含多分类，此时，大类将被忽略

    weighted: 对于不均衡数量的类来说，计算二分类metrics的平均，
通过在每个类的score上进行加权实现
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;roc_curve（ROC曲线，用于二分类）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;6 保存模型&lt;/h3&gt;
&lt;p&gt;　　最后，我们可以将我们训练好的model保存到本地，或者放到线上供用户使用，那么如何保存训练好的model呢？主要有下面两种方式：&lt;/p&gt;
&lt;h4&gt;6.1 保存为pickle文件&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
import pickle

# 保存模型
with open('model.pickle', 'wb') as f:
    pickle.dump(model, f)

# 读取模型
with open('model.pickle', 'rb') as f:
    model = pickle.load(f)
model.predict(X_test)
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;6.2 sklearn自带方法joblib&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
from sklearn.externals import joblib

# 保存模型
joblib.dump(model, 'model.pickle')

#载入模型
model = joblib.load('model.pickle')
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;7，模型评分&lt;/h3&gt;
&lt;p&gt;　　1，模型的score方法：最简单的模型评估方法就是调用模型自己的方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
# 预测
y_predict = knnClf.predict(x_test)
print(&quot;score on the testdata:&quot;,knnClf.score(x_test,y_test))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　2，sklearn的指标函数：库提供的一些计算方法，常用的有classification_report方法&lt;/p&gt;
&lt;p&gt;　　3，sklearn也支持自己开发评价方法。&lt;/p&gt;



&lt;p&gt;参考文献：http://www.cnblogs.com/lianyingteng/p/7811126.html&lt;/p&gt;
&lt;p&gt;https://www.cnblogs.com/magle/p/5638409.html&lt;/p&gt;
&lt;p&gt;https://blog.csdn.net/u014248127/article/details/78885180&lt;/p&gt;
</description>
<pubDate>Sat, 29 Dec 2018 07:13:00 +0000</pubDate>
<dc:creator>战争热诚</dc:creator>
<og:description>网上有很多关于sklearn的学习教程，大部分都是简单的讲清楚某一方面，其实最好的教程就是官方文档。 官方文档地址：https://scikit-learn.org/stable/ （可是官方文档非常</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wj-1314/p/10179741.html</dc:identifier>
</item>
<item>
<title>Android并发编程 原子类与并发容器 - 马飞标</title>
<link>http://www.cnblogs.com/wangle12138/p/10196050.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wangle12138/p/10196050.html</guid>
<description>&lt;p&gt;&lt;em&gt;在Android开发的漫漫长途上的一点感想和记录，如果能给各位看官带来一丝启发或者帮助，那真是极好的。&lt;/em&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;上一篇博文中，主要说了些线程以及锁的东西，我们大多数的并发开发需求，基本上可以用synchronized或者volatile解决，虽然synchronized已经被JDK优化了，但有的时候我们还是觉得synchronized太重了，&lt;/p&gt;
&lt;p&gt;比如说一个电影院卖票，这个票数是一定的而且共享的，我想尽快的卖票并且知道还有多少余票。在程序员看来这就是个票数自减以及获取最新票数的操作。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private static Long sCount = 10000L;
final Object obj = new Object();
//这里开了1000个线程对sCount并发操作
for (int i = 0; i &amp;lt; 1000; i++) {
    new Thread(new Runnable() {
        @Override
        public void run() {
            synchronized (obj) {
                //这里加锁保证同步，使用synchronized总觉得没有
                //必要，毕竟就是自减操作，如果不使用synchronized又有什么办法呢？
                sCount--;
            }

        }
    }).start();
}


Thread.sleep(5000);
System.out.println(sCount);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再有，我们平常使用的容器类List以及Map,如ArrayList、HashMap这些容器是非线程安全的，那我们如果需要支持并发的容器，我们该怎么办呢？？读者莫急，这正是本篇分享的内容。&lt;/p&gt;

&lt;p&gt;我们先来解决第一个问题，JDK1.5之后为我们提供了一系列的原子操作类，位于&lt;strong&gt;java.util.concurrent.atomic&lt;/strong&gt;包下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/JTSXKPb.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;原子操作基本类型类&quot;&gt;原子操作基本类型类&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;AtomicBoolean：原子更新布尔类型。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;AtomicInteger：原子更新整型。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;AtomicLong：原子更新长整型。&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;以上3个类提供的方法几乎一模一样，所以本篇仅以AtomicInteger为例进行讲解，&lt;br/&gt;AtomicInteger的常用方法如下。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;int addAndGet（int delta）：以原子方式将输入的数值与实例中的值（AtomicInteger里的&lt;br/&gt;value）相加，并返回结果。&lt;/li&gt;
&lt;li&gt;boolean compareAndSet（int expect，int update）：如果当前值(调用该函数的值)等于预期值(expect)，则以原子方式将当前值(调用该函数的值)设置为更新的值(update)。&lt;/li&gt;
&lt;li&gt;int getAndIncrement()：以原子方式将当前值加1，返回旧值。&lt;/li&gt;
&lt;li&gt;int incrementAndGet()以原子方式将当前值加1，返回新值。&lt;/li&gt;
&lt;li&gt;int getAndSet（int newValue）：以原子方式设置为newValue的值，并返回旧值。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;那按照上面的知识重新对上面的卖票问题编程如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private static AtomicLong sAtomicLong = new AtomicLong(10000L);

//这里开了1000个线程对sCount并发操作
for (int i = 0; i &amp;lt; 1000; i++) {
    new Thread(new Runnable() {
        @Override
        public void run() {
          sAtomicLong.decrementAndGet();
        }
    }).start();
}


Thread.sleep(5000);
System.out.println(sAtomicLong);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的是原子更新基本类型，那对于对象呢，JDK也提供了原子更新对象引用的原子类&lt;/p&gt;
&lt;h2 id=&quot;原子更新引用类型&quot;&gt;原子更新引用类型&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;AtomicReference：原子更新引用类型。&lt;/li&gt;
&lt;li&gt;AtomicReferenceFieldUpdater：原子更新引用类型里的字段。&lt;/li&gt;
&lt;li&gt;AtomicMarkableReference：原子更新带有标记位的引用类型。可以原子更新一个布尔类&lt;br/&gt;型的标记位和引用类型。构造方法是AtomicMarkableReference（V initialRef，boolean&lt;br/&gt;initialMark）。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以上几个类提供的方法几乎一样，所以本节仅以AtomicReference为例进行讲解&lt;/p&gt;
&lt;p&gt;boolean compareAndSet(V expect, V update)：如果当前对象(调用该函数的对象)等于预期对象(expect)，则以原子方式将当前对象(调用该函数的对象)设置为更新的对象(update)。&lt;/p&gt;
&lt;p&gt;V get()：获取找对象&lt;/p&gt;
&lt;p&gt;void set(V newValue)：设置对象&lt;/p&gt;
&lt;p&gt;V getAndSet(V newValue)：以原子方式将当前对象(调用该函数的对象)设置为指定的对象(newValue)，并返回原来的对象(设置之前)&lt;/p&gt;
&lt;p&gt;那这个东西用在哪里呢，我在著名的Rxjava源码中看到了原子更新对象的用法。&lt;/p&gt;
&lt;p&gt;CachedThreadScheduler.java&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//原子引用AtomicReference
AtomicReference&amp;lt;CachedWorkerPool&amp;gt; pool；
static final CachedWorkerPool NONE;
static {
    NONE = new CachedWorkerPool(0, null);
    NONE.shutdown();
}

public CachedThreadScheduler() {
    this.pool = new AtomicReference&amp;lt;CachedWorkerPool&amp;gt;(NONE);
    start();
}

@Override
public void start() {
    CachedWorkerPool update = new CachedWorkerPool(KEEP_ALIVE_TIME, KEEP_ALIVE_UNIT);
    //调用AtomicReference的compareAndSet方法
    if (!pool.compareAndSet(NONE, update)) {
        update.shutdown();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在创建线程调度器的时候把初始的工作线程池更新为新的工作线程池&lt;/p&gt;
&lt;p&gt;AtomicReferenceFieldUpdater以原子方式更新一个对象的属性值&lt;/p&gt;
&lt;p&gt;AtomicMarkableReference是带有标记的原子更新引用的类，可以有效解决ABA问题，什么是ABA问题，&lt;br/&gt;我们就以上面的代码为例&lt;/p&gt;
&lt;p&gt;假设pool.compareAndSet调用之前，pool内的对象NONE被更新成了update,然后又更新成了NONE,那么在调用pool.compareAndSet的时候还是会把pool内的对象更新为update,也就是说AtomicReference不关心对象的中间历程，这对于一些&lt;strong&gt;以当前对象是否被更改过为判断条件&lt;/strong&gt;的特殊情境，AtomicReference就不适用了。&lt;/p&gt;
&lt;p&gt;所以JDK提供了AtomicMarkableReference&lt;/p&gt;
&lt;p&gt;那除了上面的原子更新引用类型之外，JDK还为我们提供了原子更新数组&lt;/p&gt;
&lt;h2 id=&quot;原子更新数组&quot;&gt;原子更新数组&lt;/h2&gt;
&lt;p&gt;通过原子的方式更新数组里的某个元素，Atomic包提供了以下4个类。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;AtomicIntegerArray：原子更新整型数组里的元素。&lt;/li&gt;
&lt;li&gt;AtomicLongArray：原子更新长整型数组里的元素。&lt;/li&gt;
&lt;li&gt;AtomicReferenceArray：原子更新引用类型数组里的元素。&lt;/li&gt;
&lt;li&gt;AtomicIntegerArray类主要是提供原子的方式更新数组里的整型，其常用方法如下。&lt;/li&gt;
&lt;li&gt;int addAndGet（int i，int delta）：以原子方式将输入值与数组中索引i的元素相加。&lt;/li&gt;
&lt;li&gt;boolean compareAndSet（int i，int expect，int update）：如果当前值等于预期值，则以原子&lt;br/&gt;方式将数组位置i的元素设置成update值。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以上几个类提供的方法几乎一样，所以本节仅以AtomicIntegerArray为例进行讲解&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class AtomicIntegerArrayTest {
    static int[] value = new int[]{2, 3};
    static AtomicIntegerArray ai = new AtomicIntegerArray(value);

    public static void main(String[] args) {
        ai.getAndSet(0, 4);
        System.out.println(ai.get(0));
        System.out.println(value[0]);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以下是输出的结果。&lt;br/&gt;4&lt;br/&gt;2&lt;/p&gt;
&lt;h2 id=&quot;更快的原子操作基本类longadder-douleadder&quot;&gt;更快的原子操作基本类LongAdder DouleAdder&lt;/h2&gt;
&lt;p&gt;JDK1.8为我们提供了更快的原子操作基本类LongAdder DouleAdder，&lt;/p&gt;
&lt;p&gt;LongAdder的doc部分说明如下&lt;/p&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;This class is usually preferable to {@link AtomicLong} when&lt;br/&gt;multiple threads update a common sum that is used for purposes such&lt;br/&gt;as collecting statistics, not for fine-grained synchronization&lt;br/&gt;control. Under low update contention, the two classes have similar&lt;br/&gt;characteristics. But under high contention, expected throughput of&lt;br/&gt;this class is significantly higher, at the expense of higher space&lt;br/&gt;consumption&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上面那段话翻译过来就是&lt;/p&gt;
&lt;p&gt;当我们的场景是为了统计计数，而不是为了更细粒度的同步控制时，并且是在多线程更新的场景时，LongAdder类比AtomicLong更好用。 在小并发的环境下，论更新的效率，两者都差不多。但是高并发的场景下，LongAdder有着明显更高的吞吐量，但是有着更高的空间复杂度。&lt;/p&gt;
&lt;p&gt;从LongAdder的doc文档上我们就可以知道LongAdder更适用于统计求和场景，而不是细粒度的同步控制。&lt;/p&gt;

&lt;p&gt;我们在开发中遇到比较简单的并发操作像自增自减，求和之类的问题，上一节原子类已经能比较好的解决了，但对于本篇文章来说只是开胃小菜，下面正菜来喽&lt;/p&gt;
&lt;h2 id=&quot;concurrentlinkedqueue并发的队列&quot;&gt;ConcurrentLinkedQueue(并发的队列)&lt;/h2&gt;
&lt;p&gt;ConcurrentLinkedQueue是一个&lt;strong&gt;基于链表的无界线程安全队列&lt;/strong&gt;，它采用先进先出的规则对节点进行排序，我们添加一个元素的时候，它会添加到队列的尾部；当我们获取一个元素时，它会返回队列头部的元素。&lt;/p&gt;
&lt;p&gt;我们先来看一下ConcurrentLinkedQueue的类图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/8jqe3vI.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;ConcurrentLinkedQueue由head节点和tail节点组成，每个节点（Node）由节点元素（item）和指向下一个节点（next）的引用组成，节点与节点之间就是通过这个next关联起来，从而组成一张链表结构的队列。默认情况下head节点存储的元素为空，tail节点等于head节点&lt;/p&gt;
&lt;p&gt;以下源码来自JDK1.8&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public ConcurrentLinkedQueue() {
    //默认情况下head节点存储的元素为空，tail节点等于head节点,哨兵节点
    head = tail = new Node&amp;lt;E&amp;gt;(null);
}

private static class Node&amp;lt;E&amp;gt; {
    volatile E item;
    volatile Node&amp;lt;E&amp;gt; next;


    Node(E item) {
        //设置item值
        //这种的设置方式类似于C++的指针，直接操作内存地址，
        //例如此行代码，就是以CAS的方式把值(item)赋值给当前对象即Node地址偏移itemOffset后的地址
        //下面出现的casItem以及casNext也是同理
        UNSAFE.putObject(this, itemOffset, item);
    }

    boolean casItem(E cmp, E val) {
        return UNSAFE.compareAndSwapObject(this, itemOffset, cmp, val);
    }

    void lazySetNext(Node&amp;lt;E&amp;gt; val) {
        UNSAFE.putOrderedObject(this, nextOffset, val);
    }

    boolean casNext(Node&amp;lt;E&amp;gt; cmp, Node&amp;lt;E&amp;gt; val) {
        return UNSAFE.compareAndSwapObject(this, nextOffset, cmp, val);
    }


    private static final sun.misc.Unsafe UNSAFE;
    private static final long itemOffset;
    private static final long nextOffset;

    static {
        try {
            UNSAFE = sun.misc.Unsafe.getUnsafe();
            Class&amp;lt;?&amp;gt; k = Node.class;
            itemOffset = UNSAFE.objectFieldOffset
                (k.getDeclaredField(&quot;item&quot;));
            nextOffset = UNSAFE.objectFieldOffset
                (k.getDeclaredField(&quot;next&quot;));
        } catch (Exception e) {
            throw new Error(e);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看完了初始化，我们来看一下这个线程安全队列的进队和出队方法&lt;/p&gt;
&lt;h3 id=&quot;offere-e-以及-poll-方法&quot;&gt;offer(E e) 以及 poll() 方法&lt;/h3&gt;
&lt;h4 id=&quot;offere-e&quot;&gt;offer(E e)&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;public boolean offer(E e) {  
        checkNotNull(e);// 检查，为空直接异常  
        // 创建新节点，并将e 作为节点的item  
        final Node&amp;lt;E&amp;gt; newNode = new Node&amp;lt;E&amp;gt;(e);  
        // 这里操作比较多，将尾节点tail 赋给变量 t,p  
        for (Node&amp;lt;E&amp;gt; t = tail, p = t;;) {  
            // 并获取q 也就是 tail 的下一个节点  
            Node&amp;lt;E&amp;gt; q = p.next;  
            // 如果下一个节点是null,说明tail 是处于尾节点上  
            if (q == null) {  
                // 然后用cas 将下一个节点设置成为新节点  
                // 这里用cas 操作，如果多线程的情况，总会有一个先执行成功，失败的线程继续执行循环。  
               
                // &amp;lt;1&amp;gt;   
                if (p.casNext(null, newNode)) {  
                    // 如果p.casNext有个线程成功了，p=newNode   
                    // 比较 t (tail) 是不是 最后一个节点  
                    if (p != t)   
                        // 如果不等，就利用cas将，尾节点移到最后  
                        // 如果失败了，那么说明有其他线程已经把tail移动过，也是OK的  
                        casTail(t, newNode);    
                    return true;  
                }  
                // 如果&amp;lt;1&amp;gt;失败了，说明肯定有个线程成功了，  
                // 这时候失败的线程，又会执行for 循环，再次设值，直到成功。  
            }  
            else if (p == q)   
                // 有可能刚好插入一个，然后P 就被删除了，那么 p==q  
                // 这时候在头结点需要从新定位。  
                p = (t != (t = tail)) ? t : head;  
            else  
                // 这里是为了当P不是尾节点的时候，将P 移到尾节点，方便下一次插入  
                // 也就是一直保持向前推进  
                p = (p != t &amp;amp;&amp;amp; t != (t = tail)) ? t : q;  
        }  
    }  


private boolean casTail(Node&amp;lt;E&amp;gt; cmp, Node&amp;lt;E&amp;gt; val) {
    return UNSAFE.compareAndSwapObject(this, tailOffset, cmp, val);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上述代码可知入队列过程可归纳为3步&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;定位出尾节点；&lt;/li&gt;
&lt;li&gt;使用CAS算法将入队节点设置成尾节点的next节点，如不成功则重试&lt;/li&gt;
&lt;li&gt;更新尾节点&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;1.定位尾节点&lt;/p&gt;
&lt;p&gt;tail节点并不总是尾节点，所以每次入队都必须先通过tail节点来找到尾节点。&lt;br/&gt;尾节点可能是tail节点，也可能是tail节点的next节点。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;17&quot;&gt;
&lt;p&gt;2.设置入队节点为尾节点&lt;/p&gt;
&lt;p&gt;p.casNext(null, newNode)方法用于将入队节点设置为当前队列尾节点的next节点，如果p是null，&lt;br/&gt;表示p是当前队列的尾节点，如果不为null，表示有其他线程更新了尾节点，则需要重新获取当前队列的尾节点&lt;/p&gt;
&lt;p&gt;3.更新尾节点&lt;br/&gt;casTail(t, newNode);&lt;/p&gt;
&lt;p&gt;将尾节点移到最后(即把tail指向新节点)&lt;br/&gt;如果失败了，那么说明有其他线程已经把tail移动过，此时新节点newNode为尾节点,tail为其前驱结点&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;poll&quot;&gt;poll(）&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;public E poll() {  
        // 设置起始点  
        restartFromHead:  
        for (;;) {  
            for (Node&amp;lt;E&amp;gt; h = head, p = h, q;;) {  
                E item = p.item;  
                // 利用cas 将第一个节点设置为null  
                if (item != null &amp;amp;&amp;amp; p.casItem(item, null)) {  
                    // 和上面类似，p的next被删了，  
                    // 然后然后判断一下，目的为了保证head的next不为空  
                    if (p != h) // hop two nodes at a time  
                        updateHead(h, ((q = p.next) != null) ? q : p);  
                    return item;  
                }  
                else if ((q = p.next) == null) {  
                    // 有可能已经被另外线程先删除了下一个节点  
                    // 那么需要先设定head 的位置，并返回null  
                    updateHead(h, p);  
                    return null;  
                }  
                else if (p == q)  
                    
                    continue restartFromHead;  
                else  
                    // 和offer 类似，保证下一个节点有值，才能删除  
                    p = q;  
            }  
        }  
    }  &lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;concurrenthashmap并发的hashmap&quot;&gt;ConcurrentHashMap(并发的HashMap)&lt;/h2&gt;
&lt;p&gt;JDK1.7与JDK1.8 ConcurrentHashMap的实现还是有不小的区别的&lt;/p&gt;
&lt;h3 id=&quot;jdk1.7&quot;&gt;JDK1.7&lt;/h3&gt;
&lt;p&gt;在JDK1.7版本中，ConcurrentHashMap的数据结构是由一个Segment数组和多个HashEntry组成。&lt;/p&gt;
&lt;p&gt;Segment数组的意义就是将一个大的table分割成多个小的table来进行加锁，也就是上面的提到的锁分离技术，而每一个Segment元素存储的是HashEntry数组+链表，这个和HashMap的数据存储结构一样.&lt;br/&gt;&lt;img src=&quot;https://i.imgur.com/hmfGYzp.jpg&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://i.imgur.com/1tEKjDv.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;jdk1.8&quot;&gt;JDK1.8&lt;/h3&gt;
&lt;p&gt;1.8中放弃了Segment臃肿的设计，取而代之的是采用Node + CAS + Synchronized来保证并发安全进行实现，结构如下：&lt;br/&gt;&lt;img src=&quot;https://i.imgur.com/BYurn1U.jpg&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://i.imgur.com/6h5M1eu.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;put实现&quot;&gt;put实现&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;public V put(K key, V value) {
    return putVal(key, value, false);
}

/** Implementation for put and putIfAbsent */
final V putVal(K key, V value, boolean onlyIfAbsent) {
    if (key == null || value == null) throw new NullPointerException();
    int hash = spread(key.hashCode());
    int binCount = 0;
    for (Node&amp;lt;K,V&amp;gt;[] tab = table;;) {
        Node&amp;lt;K,V&amp;gt; f; int n, i, fh;
        if (tab == null || (n = tab.length) == 0)
            //① 只有在执行第一次put方法时才会调用initTable()初始化Node数组
            tab = initTable();
        //② 如果相应位置的Node还未初始化，则通过CAS插入相应的数据；
        else if ((f = tabAt(tab, i = (n - 1) &amp;amp; hash)) == null) {
            if (casTabAt(tab, i, null,
                         new Node&amp;lt;K,V&amp;gt;(hash, key, value, null)))
                break;                   // no lock when adding to empty bin
        }
        //③ 如果相应位置的Node不为空，且当前该节点处于移动状态 帮助转移数据
        else if ((fh = f.hash) == MOVED)
            tab = helpTransfer(tab, f);
        //④ 如果相应位置的Node不为空，且当前该节点不处于移动状态，则对该节点加synchronized锁，
        
        else {
            V oldVal = null;
            synchronized (f) {
                if (tabAt(tab, i) == f) {
                    //⑤ 如果该节点的hash不小于0，则遍历链表更新节点或插入新节点；
                    if (fh &amp;gt;= 0) {
                        binCount = 1;
                        for (Node&amp;lt;K,V&amp;gt; e = f;; ++binCount) {
                            K ek;
                            if (e.hash == hash &amp;amp;&amp;amp;
                                ((ek = e.key) == key ||
                                 (ek != null &amp;amp;&amp;amp; key.equals(ek)))) {
                                oldVal = e.val;
                                if (!onlyIfAbsent)
                                    e.val = value;
                                break;
                            }
                            Node&amp;lt;K,V&amp;gt; pred = e;
                            if ((e = e.next) == null) {
                                pred.next = new Node&amp;lt;K,V&amp;gt;(hash, key,
                                                          value, null);
                                break;
                            }
                        }
                    }
                    //⑥ 如果该节点是TreeBin类型的节点，说明是红黑树结构，则通过putTreeVal方法往红黑树中插入节点；
                    else if (f instanceof TreeBin) {
                        Node&amp;lt;K,V&amp;gt; p;
                        binCount = 2;
                        if ((p = ((TreeBin&amp;lt;K,V&amp;gt;)f).putTreeVal(hash, key,
                                                       value)) != null) {
                            oldVal = p.val;
                            if (!onlyIfAbsent)
                                p.val = value;
                        }
                    }
                }
            }
            /**
            *如果binCount不为0，说明put操作对数据产生了影响，如果当前链表的个数达到8个，
            *通过treeifyBin方法转化为红黑树，
            *如果oldVal不为空，说明是一次更新操作，没有对元素个数产生影响，则直接返回旧值；
            */
            if (binCount != 0) {
                if (binCount &amp;gt;= TREEIFY_THRESHOLD)
                    treeifyBin(tab, i);
                if (oldVal != null)
                    return oldVal;
                break;
            }
        }
    }
    
    addCount(1L, binCount);
    return null;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;copyonwritearraylist线程安全的arraylist&quot;&gt;CopyOnWriteArrayList(线程安全的ArrayList)&lt;/h2&gt;
&lt;p&gt;JDK1.8中关于CopyOnWriteArrayList的官方介绍如下&lt;/p&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;A thread-safe variant of {@link java.util.ArrayList} in which all mutative&lt;br/&gt;operations ({@code add}, {@code set}, and so on)&lt;br/&gt;are implemented bymaking a fresh copy of the underlying array.&lt;/p&gt;
&lt;p&gt;中文翻译大致是&lt;/p&gt;
&lt;p&gt;CopyOnWriteArrayList是一个线程安全的java.util.ArrayList的变体，&lt;br/&gt;add,set等改变CopyOnWriteArrayList的操作是通过制作当前数据的副本实现的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其实意思很简单，假设有一个数组如下所示&lt;br/&gt;&lt;img src=&quot;https://i.imgur.com/sieMSmd.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;并发读取&quot;&gt;并发读取&lt;/h3&gt;
&lt;p&gt;多个线程并发读取是没有任何问题的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/kBTOeQj.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;更新数组&quot;&gt;更新数组&lt;/h3&gt;
&lt;p&gt;我们来看add 源码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public boolean add(E e) {
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {
        Object[] elements = getArray();
        int len = elements.length;
        Object[] newElements = Arrays.copyOf(elements, len + 1);
        newElements[len] = e;
        setArray(newElements);
        return true;
    } finally {
        lock.unlock();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有了前面的积淀，这段代码可以说没有任何难度&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;获取重入锁（线程互斥锁）&lt;/li&gt;
&lt;li&gt;创一个新的数组（在原有数据长度的基础上加1）并把原数组的数据拷贝到新数组&lt;/li&gt;
&lt;li&gt;把新数组的引用设置为老数组&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;注 写入过程中，若有其他线程读取数据，那么读取的依然是老数组的数据&lt;/p&gt;
&lt;h3 id=&quot;使用场景&quot;&gt;使用场景&lt;/h3&gt;
&lt;p&gt;由上面的结构以及源码分析就知道CopyOnWriteArrayList用在&lt;strong&gt;读多写少&lt;/strong&gt;的多线程环境中。&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;本篇分享了一些原子操作类以及并发容器，这些在多线程开发中都很有作用。希望帮到你。&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;Android 并发工具类与线程池&lt;/p&gt;
&lt;hr/&gt;
&lt;hr/&gt;&lt;p&gt;此致，敬礼&lt;/p&gt;
</description>
<pubDate>Sat, 29 Dec 2018 07:01:00 +0000</pubDate>
<dc:creator>马飞标</dc:creator>
<og:description>在Android开发的漫漫长途上的一点感想和记录，如果能给各位看官带来一丝启发或者帮助，那真是极好的。 前言 上一篇博文中，主要说了些线程以及锁的东西，我们大多数的并发开发需求，基本上可以用synch</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wangle12138/p/10196050.html</dc:identifier>
</item>
<item>
<title>知识图谱基础知识之一——人人都能理解的知识图谱 - cooldream2009</title>
<link>http://www.cnblogs.com/coodream2009/p/10195964.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/coodream2009/p/10195964.html</guid>
<description>&lt;p&gt;1 知识图谱和人工智能&lt;br/&gt;说起知识图谱，可能很多人不太了解，但要说到人工智能，大家就耳熟能详了。人工智能是指机器要像人一样可以思考，具有智慧。现在这个阶段，人工智能研究的人越来越多，在很多行业也实现了部分的人工智能，让机器代替了人进行简单重复性的工作。&lt;br/&gt;在这里我们可以把人工智呢分为两个层次，一个是感知层次，也就是听觉、视觉、嗅觉、味觉等等，目前人工智能在听觉和视觉方面做的比较好，语音识别，图像识别，研究的人多，也有产品出来。但总起来说，感知层次的人工智能还没有体现人类的独有的智慧，其它动物可能在感知层次比人要好，比如鹰的眼睛，狼的耳朵，豹的速度，熊的力量等等。&lt;br/&gt;真正体现人工智能的还是第二个层次，也就是认知层次，能够认识这个客观世界。而认知世界是通过大量的知识积累实现的，小孩子见到狗和猫，见过几次就能分辨出狗和猫，让机器来分辨难度就比较大，当然现在通过大数据训练也在提升。这种认知能力是知识的运用，小孩子见到狗，他就会在潜意识中总结狗的特征，长耳朵，瘦脸，汪汪叫。猫的特征，短耳朵，圆脸，喵喵叫。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/935893/201812/935893-20181229144545851-1834754274.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这些知识会存储在人类的大脑中，作为经验知识，再次碰到类似的动物，人们马上就从记忆中想起该动物的特征，对号入座，马上判断出动物的类型。机器要想具有认知能力，也需要建立一个知识库，然后运用知识库来做一些事，这个知识库就是我们要说的知识图谱。从这个角度说，知识图谱是人工职能的一个重要分支，也是机器具有认知能力的基石，在人工智能领域具有非常重要的地位。&lt;/p&gt;
&lt;p&gt;2 知识图谱的由来&lt;br/&gt;知识图谱（Knowledge graph）首先是由Google提出来的，大家知道Google是做搜索引擎的，知识图谱出现之前，我们使用google、百度进行搜索的时候，搜索的结果是一堆网页，我们会根据搜索结果的网页题目再点击链接，才能看到具体内容，2012年google提出Google Knowldge Graph之后，利用知识图谱技术改善了搜索引擎核心，表现出来的效果就是我们现在使用搜索引擎进行搜索的时候，搜索结果会以一定的组织结构呈现，比如我们搜索比尔盖茨，结果如图所示&lt;img src=&quot;https://img2018.cnblogs.com/blog/935893/201812/935893-20181229144559553-575365779.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样的搜索结果，与知识图谱出现之前的结果有什么区别呢，辛格尔博士对知识图谱的介绍很简短，things，not string，抓住了知识图谱的核心，也点出了知识图谱加入之后搜索发生的变化，以前的搜索，都是将要搜索的内容看作字符串，结果是和字符串进行匹配，将匹配程度高的排在前面，后面按照匹配度依次显示。利用知识图谱之后，将搜索的内容不再看作字符串，而是看作客观世界的事物，也就是一个个的个体。搜索比尔盖茨的时候，搜索引擎不是搜索“比尔盖茨”这个字符串，而是搜索比尔盖茨这个人，围绕比尔盖茨这个人，展示与他相关的人和事，左侧百科会把比尔盖茨的主要情况列举出来，右侧显示比尔盖茨的微软产品和与他类似的人，主要是一些IT行业的创始人。一个搜索结果页面就把和比尔盖茨的基本情况和他的主要关系都列出来了，搜索的人很容易找到自己感兴趣的结果。&lt;/p&gt;
&lt;p&gt;3 知识图谱是什么&lt;br/&gt;知识图谱本质上是一种语义网络，用图的形式描述客观事物，这里的图指的是数据结构中的图，也就是由节点和边组成的，这也是知识图谱（Knowledge Graph）的真实含义。知识图谱中的节点表示概念和实体，概念是抽象出来的事物，实体是具体的事物；边表示事物的关系和属性，事物的内部特征用属性来表示，外部联系用关系来表示。很多时候，人们简化了对知识图谱的描述，将实体和概念统称为实体，将关系和属性统称为关系，这样就可以说知识图谱就是描述实体以及实体之间的关系。实体可以是人，地方，组织机构，概念等等，关系的种类更多，可以是人与人之间的关系，人与组织之间的关系，概念与某个物体之间的关系等等，以下是一个例子。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/935893/201812/935893-20181229144610860-674615848.jpg&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;4 知识图谱是怎么组织数据的&lt;br/&gt;知识图谱是由实体和实体的关系组成，通过图的形式表现出来，那么实体和实体关系的这些数据在知识图谱中怎么组织呢，这就涉及到三元组的概念，在知识图谱中，节点-边-节点可以看作一条记录，第一个节点看作主语，边看作谓语，第二个节点看作宾语，主谓宾构成一条记录。比如曹操的儿子是曹丕，曹操是主语，儿子是谓语，曹丕是宾语。再比如，曹操的小名是阿瞒，主语是曹操，谓语是小名，宾语是阿瞒。知识图谱就是由这样的一条条三元组构成，围绕着一个主语，可以有很多的关系呈现，随着知识的不断积累，最终会形成一个庞大的知识图谱，知识图谱建设完成后，会包含海量的数据，内涵丰富的知识。&lt;/p&gt;
&lt;p&gt;5 知识图谱的应用场景&lt;br/&gt;知识图谱构建完成之后，主要用在哪些地方，比较典型应用是语义搜索、智能问答、推荐系统等方面。知识图谱是一个具有本体特征的语义网络，可以看成是按照本体模式组织数据的知识库，以知识图谱为基础进行搜索，可以根据查询的内容进行语义搜索，查找需要找的本体或者本体的信息，这种语义搜索功能在google、百度、阿里巴巴等数据量大的公司里得到应用。智能问答，和语义搜索类似，对于提问内容，计算机首先要分析提问问题的语义，然后再将语义转换为查询语句，到知识图谱中查找，将最贴近的答案提供给提问者。推荐系统首先要采集用户的需求，分析用户的以往数据，提取共同特征，然后根据一定的规则，对用户提供推荐的产品。比如淘宝中记录用户经常购买的商品，经常浏览的商品，提取这些商品的共同特征，然后给这个用户打上标签，然后就给用户推荐具有类似特征的商品。&lt;br/&gt;知识图谱主要反映的事物之间的关系，对于和关系链条有关的场景，也可以用知识图谱解决，一些应用场景包括反欺诈、不一致性验证、异常分析、客户管理等&lt;/p&gt;
</description>
<pubDate>Sat, 29 Dec 2018 06:47:00 +0000</pubDate>
<dc:creator>cooldream2009</dc:creator>
<og:description>1 知识图谱和人工智能说起知识图谱，可能很多人不太了解，但要说到人工智能，大家就耳熟能详了。人工智能是指机器要像人一样可以思考，具有智慧。现在这个阶段，人工智能研究的人越来越多，在很多行业也实现了部分</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/coodream2009/p/10195964.html</dc:identifier>
</item>
<item>
<title>2018年列车已到站，请您下车 - 逆袭之路666</title>
<link>http://www.cnblogs.com/liudw-0215/p/10195836.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liudw-0215/p/10195836.html</guid>
<description>&lt;p&gt;　　首先，祝看到这篇博客的老铁们，2019新春来临之际，祝您事业百尺竿头，挣钱富得流油；写代码无bug，身体健康不掉头发!&lt;/p&gt;
&lt;h2&gt;　　列车到站&lt;/h2&gt;
&lt;p&gt;　　2018年还有两天就结束了，公司已没什么人了，工作一年半年了，比上学时时间过得还快！18年的标签应该是转折！可以说是往后余生的一个转折点！&lt;/p&gt;
&lt;h2&gt;　　18年的flag&lt;/h2&gt;
&lt;p&gt;　　18年立了些flag，来看看吧：&lt;img src=&quot;https://img2018.cnblogs.com/blog/1249620/201812/1249620-20181229140223167-201910303.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　来看看完成情况吧!&lt;/p&gt;
&lt;p&gt;　　第一条：算上年终奖还差点&lt;/p&gt;
&lt;p&gt;　　第二条：没有实现，有些遗憾&lt;/p&gt;
&lt;p&gt;　　第三条：实现了，很有纪念意义&lt;/p&gt;
&lt;p&gt;　　第四条：虽然没有实现胖10斤！但是保持了健康，早睡早起，下半年开始不玩游戏了，体检一切正常最让我欣慰了！&lt;/p&gt;
&lt;p&gt;　　第五条：没赚到5万，反而负了5万！&lt;/p&gt;
&lt;p&gt;　　下面回顾一下之前的一些经历吧！&lt;/p&gt;
&lt;h2&gt;　　毕业那年&lt;/h2&gt;
&lt;p&gt;　　 毕业一年多了，也就是去年毕业的，毕业之后毅然决然的来到了北京，也许不知道为什么要来北京，也可能是因为高中时说过：我要去北京，所以就傻乎乎地来了！并没有通过校招拿到北京的offer,在沈阳实习的，有个一起实习的同事说：去北京能干嘛？也买不起房，最后还不是要回老家；当时，觉得好像很有道理，竟无力反驳，但洪荒之力依然驱使着我想去北京看看，虽然，女票也不支持我去，因为这样就异地了，还是百般说服，最后同意了，非常感谢她的支持！&lt;/p&gt;
&lt;h2&gt;　　初来匝道&lt;/h2&gt;
&lt;p&gt;　　记得特别清晰，17年7月2号早晨7点到了北京站，办了地铁卡，倒了三趟地铁倒了住的地方，舍友都很好，帮我拿行李，看我没有褥子，给我褥子，在此谢过，祝前程似锦！&lt;/p&gt;
&lt;h2&gt;　　求职经历&lt;/h2&gt;
&lt;p&gt;　　开始疯狂投递简历，主要在智联上进行投递的，然后陆续接到面试的邀约!记得印象特别深刻的一次，那家公司特别远，要倒4趟地铁，2趟公交，当是北京还特别热，30多度，提前4小时就去了，下了公交了，还有一段距离，找了辆小黄车，疯狂瞪着，一看就在马路对面，直接转弯，但后面正好来了一辆车，因为着急我也没注意看，司机急刹车，可能当时只有1毫米的距离，我就起飞了，要与太阳肩并肩了，司机立马下车，大骂道：曹尼玛...,当时蒙圈了，只知道说：对不起，对不起...,但心里想着这口音好像东北的，老乡啊，哪还有时间套近乎，赶紧跑进面试公司，做了一套笔试题，主管不在，让一个小弟跟我简单的聊了几句，然后HR然我回去等通知，当时，真的会傻乎乎地去盼着电话再次想起；现在，才懂让回去等通知，大概率就是委婉拒绝了！&lt;/p&gt;
&lt;h2&gt;　　得到offer&lt;/h2&gt;
&lt;p&gt;　　来北京的第二周周五下午2点让我去面试，提前1个小时就到了，但楼下保安不让进，吃个饭1点半去了，HR说：毕业生不用做技术题，给了我8页的逻辑题，然后来了面试题，本来有些忐忑，但看来了一位特别慈祥的长者，就放松了很多，让我自我介绍，然后就很少说话了，还是我主动把简历给她的，最后让我问问题，我说：这就通过了？然后简单说了下薪资情况等，就走了！这么简单，那时特别担心会不会是传销，因为面试时还说要去广州培训，特别害怕，百度了好久。然后周日，收到HR电话：什么时能入职？我说：随时，那下周一就来吧！然后7月11号就正式入职了&lt;/p&gt;
&lt;h2&gt;　　工作ing&lt;/h2&gt;
&lt;p&gt;　　刚开始内训了三个月，然后参与了一个小项目，并测试，测试一直持续了大约一年，这让我很反感!跟我一起进公司的还有很多校招的，我比他们做的需求多、改bug也更多了，因为我几乎第一个到公司，最后一个走的！做完几个项目之后，发现我可能要成为&quot;只会业务逻辑和增删改查的程序员了&quot;；转正一年之后涨了一次工资，好像没比其他人多，或者只多了300。渐渐就不想做项目，因为都是重复的工作，ctrl+c和Ctrl+v，就开始疯狂学习了&lt;/p&gt;
&lt;h2&gt;　　转折点&lt;/h2&gt;
&lt;p&gt;　　P2P平台接连暴雷，很多人应该都知道吧，不幸的是，我也是其中的一份子，工作之后攒的积蓄，都没了，低迷了也开始思考了！照现在的状态，下班之后、周末都在玩游戏，感觉余生也就一般般了，心里觉得自己会成为&quot;二班&quot;的人！开始，觉得游戏无聊了，下班、周末都在疯狂学习，进步也是非常明显的，有了清晰的认知和规划！所以，塞翁失马，焉知非福，不要因为一些不顺心的事情，就颓废了，可能上天让你觉醒！&lt;/p&gt;
&lt;h2&gt;　　19年计划&lt;/h2&gt;
&lt;p&gt;　　1、工资达到1万5；努力进入大公司，一直在努力，从未停止！&lt;/p&gt;
&lt;p&gt;　　2、保持健康！发现有些掉头发，坚持晨跑和做早餐1&lt;/p&gt;
&lt;p&gt;　　3、坚持学习！利用一切空闲时间学习！&lt;/p&gt;
&lt;p&gt;　　4、希望对象考研成功！&lt;/p&gt;

&lt;p&gt;　　可以说，19年也是重要转折的一年，希望一切顺利，大家加油！&lt;/p&gt;
</description>
<pubDate>Sat, 29 Dec 2018 06:28:00 +0000</pubDate>
<dc:creator>逆袭之路666</dc:creator>
<og:description>首先，祝看到这篇博客的老铁们，2019新春来临之际，祝您事业百尺竿头，挣钱富得流油；写代码无bug，身体健康不掉头发! 列车到站 2018年还有两天就结束了，公司已没什么人了，工作一年半年了，比上学时</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liudw-0215/p/10195836.html</dc:identifier>
</item>
<item>
<title>一键发布和测试之持续集成工具Jenkins - arch-system</title>
<link>http://www.cnblogs.com/dotnet-arch-system/p/10195670.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dotnet-arch-system/p/10195670.html</guid>
<description>&lt;p&gt;&lt;strong&gt;一、Jenkins简介&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-3423802&quot;&gt;当每月发布次数变得越来越多时，如超过500次，发布工作人员的工作量会翻倍增长，此时由人工发布操作失误引起的风险会变得越来越大。为了提高项目的发布效率，也为了降低由人工操作失误带来的风险，需要引进持续集成工具。&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-3423802&quot;&gt;Jenkins是一个用Java语言编写的开源的持续集成工具，最开始被称作Hudson。Jenkins在持续集成领域市场份额中居于主导地位，被各种大小规模的团队用于用各种语言实现的各类项目中，语言例如C#、Java、Ruby、Groovy、Grails、PHP等。选择Jenkins的理由如下：&lt;/p&gt;
&lt;ol class=&quot;ql-long-3423802&quot; data-list-style=&quot;decimal&quot;&gt;&lt;li class=&quot;ordered-item ql-long-3423802&quot; data-list-id=&quot;gBnx&quot; data-list-number=&quot;1&quot; data-list-content=&quot;1.&quot;&gt;&lt;strong&gt;易于使用：&lt;/strong&gt;Jenkins的用户界面简单、直观、友好，发布工作人员只需要通过简单的UI操作就可以替代原来繁琐的发布工作。&lt;/li&gt;
&lt;/ol&gt;&lt;ol class=&quot;ql-long-3423802&quot; data-list-style=&quot;decimal&quot;&gt;&lt;li class=&quot;ordered-item ql-long-3423802&quot; data-list-id=&quot;gBnx&quot; data-list-number=&quot;2&quot; data-list-content=&quot;2.&quot;&gt;&lt;strong&gt;拥有良好的扩展性：&lt;/strong&gt;提供数以百计的开源插件可供使用，而且几乎每周会有新的开源插件贡献进来，这些插件的安装都十分快捷和简单。&lt;/li&gt;
&lt;/ol&gt;&lt;ol class=&quot;ql-long-3423802&quot; data-list-style=&quot;decimal&quot;&gt;&lt;li class=&quot;ordered-item ql-long-3423802&quot; data-list-id=&quot;gBnx&quot; data-list-number=&quot;3&quot; data-list-content=&quot;3.&quot;&gt;&lt;strong&gt;受大众喜欢：&lt;/strong&gt;Jenkins开源社区的规模变得越来越大、活跃度也变得越来越高，发展速度非常快。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;二、Jenkins插件与相关工具&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;ql-long-3423802&quot;&gt;1、Jenkins：持续集成工具。&lt;/p&gt;
&lt;p class=&quot;ql-long-3423802&quot;&gt;2、Git：源代码管理工具，是目前流行的分布式版本控制系统。需要安装的Jenkins插件有：&lt;/p&gt;
&lt;p class=&quot;ql-long-3423802&quot;&gt;&lt;img src=&quot;https://images-cdn.shimo.im/LngCnRqnwpghI1IW/%E5%9B%BE1-%E4%B8%BB%E8%A6%81%E5%AE%89%E8%A3%85%E7%9A%84%E6%8F%92%E4%BB%B6-Git%E3%80%81GitHub%E3%80%81GitLab.png!thumbnail&quot; alt=&quot;&quot; width=&quot;612px&quot; height=&quot;202.859px&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;ql-long-3423802&quot;&gt;3、TFS：可选，源代码管理工具。&lt;/p&gt;
&lt;p class=&quot;ql-long-3423802&quot;&gt;4、MSBuild：Visual Studio里面自带的一个程序编译组件。需要安装的Jenkins插件是MSBuild Plugin插件。&lt;/p&gt;
&lt;p class=&quot;ql-long-3423802&quot;&gt;5、FTP：可选，通过FTP把编译好的发布文件部署到应用服务器中。需要安装的Jenkins插件是Publish Over FTP插件。&lt;/p&gt;
&lt;p class=&quot;ql-long-3423802&quot;&gt;6、Jenkins角色及权限管理： 需要安装的Jenkins插件是Role-based Authorization Strategy插件。&lt;/p&gt;
&lt;p class=&quot;ql-long-3423802&quot;&gt;7、Python脚本：自写的Python脚本放在Jenkins服务器中。可以实现Jenkins把编译好的发布文件部署到远程应用站点服务器，以及实现回滚操作Rollback。&lt;/p&gt;
&lt;p class=&quot;ql-long-3423802&quot;&gt;8、PxExec.exe工具：装在Jenkins服务器中，利用这个工具，可以在远程服务器中执行命令如xcopy。&lt;/p&gt;
&lt;p class=&quot;ql-long-3423802&quot;&gt;9、SoapUI自动化测试：用于接口测试自动化，同时需要安装Jenkins插件是HTML Publisher plugin插件。&lt;/p&gt;
&lt;p class=&quot;ql-long-3423802&quot;&gt;10、回滚操作Rollback：需要安装的Jenkins插件是Build with Parameters插件，用于指定哪个项目回滚到哪个备份版本。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三、Jenkins关键配置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.1 邮件配置&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;ql-long-3423802&quot;&gt;Email是Jenkins最基本的通知技术。什么情况下，需要Jenkins发送电子邮件通知？例如，在一个构建失败（例如因为编译错误）后。&lt;/p&gt;
&lt;p class=&quot;ql-long-3423802&quot;&gt;&lt;img src=&quot;https://images-cdn.shimo.im/QH5csn8V610A0Vqv/%E5%9B%BE8-%E9%82%AE%E4%BB%B6%E9%80%9A%E7%9F%A5-%E7%94%A8%E5%88%B0%E9%82%AE%E4%BB%B6%E5%B0%B1%E8%A6%81%E9%85%8D%EF%BC%8C%E6%B2%A1%E7%94%A8%E5%88%B0%E5%B0%B1%E4%B8%8D%E7%94%A8%E9%85%8D.png!thumbnail&quot; alt=&quot;&quot; width=&quot;612px&quot; height=&quot;242.828px&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;ql-align-center ql-long-3423802&quot;&gt;&lt;img src=&quot;https://images-cdn.shimo.im/ik1k7q6Cu6gXNdR6/image.png!thumbnail&quot; alt=&quot;&quot; width=&quot;612px&quot; height=&quot;446.781px&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.2 角色及权限管理&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;ql-long-3423802&quot;&gt;首先设置全局角色和项目角色，其中Pattern是用来设置构建作业名的命名规范，例如：规定了构建作业名的命名规范是{发布环境}.{产品线英文名全称}.{项目名}，那么要发到生产环境、属于Trip产品线的所有构建作业，其Pattern设置的值为【(?i)prod.trip.*】，表示构建作业名必须以prod.trip开头，而且不区分大小写，用于发布到生产环境。&lt;/p&gt;
&lt;p class=&quot;ql-long-3423802&quot;&gt;&lt;img src=&quot;https://images-cdn.shimo.im/Sm69Ac5VZfM901Ho/%E5%9B%BE15-Manage%20Roles.png!thumbnail&quot; alt=&quot;&quot; width=&quot;612px&quot; height=&quot;289.109px&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;ql-long-3423802&quot;&gt;然后，分别为Jenkins账号分派全局角色和项目角色：&lt;/p&gt;
&lt;p class=&quot;ql-long-3423802&quot;&gt;&lt;img src=&quot;https://images-cdn.shimo.im/MSe8M3eOTiko5TyN/%E5%9B%BE16-Assign%20Roles.png!thumbnail&quot; alt=&quot;&quot; width=&quot;612px&quot; height=&quot;498.813px&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.3 部署到集群&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;ql-long-3423802&quot;&gt;Jenkins通过运行自写的Python脚本把编译好的发布文件部署到远程应用站点服务器中，以及同步到集群内其他应用站点服务器，所以需要新增构建步骤配置，参考如下：&lt;/p&gt;
&lt;p class=&quot;ql-long-3423802&quot;&gt;&lt;img src=&quot;https://images-cdn.shimo.im/WPPQZC91d24UbnZs/%E5%9B%BE25-%E9%85%8D%E7%BD%AE%E6%9E%84%E5%BB%BA%E6%AD%A5%E9%AA%A42.png!thumbnail&quot; alt=&quot;&quot; width=&quot;612px&quot; height=&quot;127.797px&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;ql-long-3423802&quot;&gt;其中，.py脚本（即Python脚本）内容如下：&lt;/p&gt;
&lt;p class=&quot;ql-long-3423802&quot;&gt;&lt;img src=&quot;https://images-cdn.shimo.im/QTP3O9I2QhIfu5KH/%E5%9B%BE26-%E9%85%8D%E7%BD%AE%E6%9E%84%E5%BB%BA%E6%AD%A5%E9%AA%A42.png!thumbnail&quot; alt=&quot;&quot; width=&quot;612px&quot; height=&quot;234.156px&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;ql-long-3423802&quot;&gt;&lt;strong&gt;.py脚本实现了如下逻辑：&lt;/strong&gt;&lt;/p&gt;
&lt;ul class=&quot;ql-long-3423802&quot; data-list-style=&quot;circle&quot;&gt;&lt;li class=&quot;bullet-item ql-long-3423802&quot; data-bullet-id=&quot;faPx&quot;&gt;&lt;strong&gt;第1步备份：&lt;/strong&gt;在远程应用站点服务器中，备份将要部署新版本的那个应用系统的所有文件。利用PxExec.exe工具，让Jenkins服务器远程连到应用站点服务器。然后在这台应用站点服务器中，利用xcopy命令，把将要部署新版本的这个应用系统站点目录之下的所有文件拷贝到这台应用站点服务器中的备份目录下。&lt;/li&gt;
&lt;/ul&gt;&lt;ul class=&quot;ql-long-3423802&quot; data-list-style=&quot;circle&quot;&gt;&lt;li class=&quot;bullet-item ql-long-3423802&quot; data-bullet-id=&quot;faPx&quot;&gt;&lt;strong&gt;第2步部署：&lt;/strong&gt;部署到这台远程应用站点服务器。先利用xcopy命令，把由Jenkins编译好的、位于Jenkins服务器的文件拷贝到这台应用站点服务器共享目录之下，以.config结尾的配置文件不会被拷贝。再利用PxExec.exe工具，让Jenkins服务器远程连到这台应用站点服务器。然后在这台应用站点服务器中，利用xcopy命令，把临时存放目录下的文件拷贝到这个应用系统站点目录之下。&lt;/li&gt;
&lt;/ul&gt;&lt;ul class=&quot;ql-long-3423802&quot; data-list-style=&quot;circle&quot;&gt;&lt;li class=&quot;bullet-item ql-long-3423802&quot; data-bullet-id=&quot;faPx&quot;&gt;&lt;strong&gt;第3步同步：&lt;/strong&gt;同步发布文件到该应用系统集群内的其他应用站点服务器。利用PxExec.exe工具，让Jenkins服务器远程连到这台应用站点服务器，然后在这台应用站点服务器中，利用xcopy命令，把该应用系统站点目录下的所有文件拷贝到集群内的其他应用站点服务器的该应用系统站点目录之下。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;3.4 接口自动化测试SoapUI&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;ql-long-3423802&quot;&gt;测试用例提交到版本库（如Git）后，通过Jenkins把它编译，编译后，通过SoapUI一键调用，开始了自动化测试。一旦自动化测试完成，会生成份报表，是通过HTML Report把它给呈现出来，如下图所示。&lt;/p&gt;
&lt;p class=&quot;ql-long-3423802&quot;&gt;&lt;img src=&quot;https://images-cdn.shimo.im/KGkRDDOrowkrv0wz/%E5%9B%BE7_SoapUI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%8E%A5%E5%8F%A3_HTML_Report1.png!thumbnail&quot; alt=&quot;&quot; width=&quot;563px&quot; height=&quot;481px&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;ql-long-3423802&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;ql-long-3423802&quot;&gt;&lt;img src=&quot;https://images-cdn.shimo.im/EqVyroVDd2czDMLU/%E5%9B%BE9_SoapUI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%8E%A5%E5%8F%A3_HTML_Report2.png!thumbnail&quot; alt=&quot;&quot; width=&quot;612px&quot; height=&quot;240.875px&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.5 界面自动化测试UFT&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;ql-long-3423802&quot;&gt;&lt;img src=&quot;https://images-cdn.shimo.im/B1JkKSEZxJUaURCX/UFT%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95_HTML_Report1.png!thumbnail&quot; alt=&quot;&quot; width=&quot;518px&quot; height=&quot;436px&quot;/&gt;&lt;/p&gt;

&lt;p class=&quot;ql-long-3423802&quot;&gt;&lt;img src=&quot;https://images-cdn.shimo.im/qO1rG7dzKEUVIe8s/UFT%E7%95%8C%E9%9D%A2%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95_HTML_Report2.png!thumbnail&quot; alt=&quot;&quot; width=&quot;612px&quot; height=&quot;324.875px&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.6 回滚操作Rollback&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;ql-long-3423802&quot;&gt;General配置：&lt;/p&gt;
&lt;p class=&quot;ql-long-3423802&quot;&gt;&lt;img src=&quot;https://images-cdn.shimo.im/7JHM7MQfejoPTW5D/%E5%9B%9E%E6%BB%9A%E6%93%8D%E4%BD%9CRollback%E7%9A%84General%E9%85%8D%E7%BD%AE.png!thumbnail&quot; alt=&quot;&quot; width=&quot;612px&quot; height=&quot;380.734px&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;ql-long-3423802&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;ql-long-3423802&quot;&gt;构建配置：&lt;/p&gt;
&lt;p class=&quot;ql-long-3423802&quot;&gt;&lt;img src=&quot;https://images-cdn.shimo.im/pkgevrUCDBAeB5iA/%E5%9B%9E%E6%BB%9A%E6%93%8D%E4%BD%9CRollback%E7%9A%84%E6%9E%84%E5%BB%BA%E9%85%8D%E7%BD%AE.png!thumbnail&quot; alt=&quot;&quot; width=&quot;612px&quot; height=&quot;293.781px&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;ql-long-3423802&quot;&gt; 选择将要回滚哪个项目以及回滚到哪个备份版本号：&lt;/p&gt;
&lt;p class=&quot;ql-long-3423802&quot;&gt;&lt;img src=&quot;https://images-cdn.shimo.im/eNHbF5hVDngr2lkD/%E9%80%89%E6%8B%A9%E9%A1%B9%E7%9B%AE%E5%92%8C%E5%9B%9E%E9%80%80%E5%88%B0%E7%9A%84%E5%A4%87%E4%BB%BD%E7%89%88%E6%9C%AC%E5%8F%B7.png!thumbnail&quot; alt=&quot;&quot; width=&quot;612px&quot; height=&quot;321.641px&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.7 暂未解决的问题&lt;/strong&gt;&lt;/p&gt;
&lt;ul class=&quot;ql-long-3423802&quot; data-list-style=&quot;circle&quot;&gt;&lt;li class=&quot;bullet-item ql-long-3423802&quot; data-bullet-id=&quot;7S4Y&quot;&gt;数据库发布与回滚；&lt;/li&gt;
&lt;/ul&gt;&lt;ul class=&quot;ql-long-3423802&quot; data-list-style=&quot;circle&quot;&gt;&lt;li class=&quot;bullet-item ql-long-3423802&quot; data-bullet-id=&quot;7S4Y&quot;&gt;应用配置文件的发布与回滚；&lt;/li&gt;
&lt;/ul&gt;&lt;ul class=&quot;ql-long-3423802&quot; data-list-style=&quot;circle&quot;&gt;&lt;li class=&quot;bullet-item ql-long-3423802&quot; data-bullet-id=&quot;7S4Y&quot;&gt;加入QA流程控制，经过测试工程师确定后，方可发布。&lt;/li&gt;
&lt;/ul&gt;&lt;ul class=&quot;ql-long-3423802&quot; data-list-style=&quot;circle&quot;&gt;&lt;li class=&quot;bullet-item ql-long-3423802&quot; data-bullet-id=&quot;7S4Y&quot;&gt;以上三个问题也可以借助其它工具来实现，分别是数据库发布工具、集中式配置服务、流程管理工具甚至邮件确认。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;四、Jenkins的使用价值&lt;/strong&gt;&lt;/p&gt;
&lt;ol class=&quot;ql-long-3423802&quot; data-list-style=&quot;decimal&quot;&gt;&lt;li class=&quot;ordered-item ql-long-3423802&quot; data-list-id=&quot;ESPi&quot; data-list-number=&quot;1&quot; data-list-content=&quot;1.&quot;&gt;减少发布工作人员的大量日常工作量，大大提高项目的发布效率。&lt;/li&gt;
&lt;/ol&gt;&lt;ol class=&quot;ql-long-3423802&quot; data-list-style=&quot;decimal&quot;&gt;&lt;li class=&quot;ordered-item ql-long-3423802&quot; data-list-id=&quot;ESPi&quot; data-list-number=&quot;2&quot; data-list-content=&quot;2.&quot;&gt;不容易出错，降低人工发布带来的风险。&lt;/li&gt;
&lt;/ol&gt;&lt;ol class=&quot;ql-long-3423802&quot; data-list-style=&quot;decimal&quot;&gt;&lt;li class=&quot;ordered-item ql-long-3423802&quot; data-list-id=&quot;ESPi&quot; data-list-number=&quot;3&quot; data-list-content=&quot;3.&quot;&gt;可集成UI和接口自动化测试功能，提供测试报告。&lt;/li&gt;
&lt;/ol&gt;&lt;ol class=&quot;ql-long-3423802&quot; data-list-style=&quot;decimal&quot;&gt;&lt;li class=&quot;ordered-item ql-long-3423802&quot; data-list-id=&quot;ESPi&quot; data-list-number=&quot;4&quot; data-list-content=&quot;4.&quot;&gt;可24小时随时发布。&lt;/li&gt;
&lt;/ol&gt;&lt;ol class=&quot;ql-long-3423802&quot; data-list-style=&quot;decimal&quot;&gt;&lt;li class=&quot;ordered-item ql-long-3423802&quot; data-list-id=&quot;ESPi&quot; data-list-number=&quot;5&quot; data-list-content=&quot;5.&quot;&gt;方便紧急修复或回滚操作Rollback。&lt;/li&gt;
&lt;/ol&gt;&lt;ol class=&quot;ql-long-3423802&quot; data-list-style=&quot;decimal&quot;&gt;&lt;li class=&quot;ordered-item ql-long-3423802&quot; data-list-id=&quot;ESPi&quot; data-list-number=&quot;6&quot; data-list-content=&quot;6.&quot;&gt;方便对发布流程进行控制、标准化。&lt;/li&gt;
&lt;/ol&gt;&lt;ol class=&quot;ql-long-3423802&quot; data-list-style=&quot;decimal&quot;&gt;&lt;li class=&quot;ordered-item ql-long-3423802&quot; data-list-id=&quot;ESPi&quot; data-list-number=&quot;7&quot; data-list-content=&quot;7.&quot;&gt;方便发布统计、历史版本可追溯。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;五、更多资料&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 29 Dec 2018 06:06:00 +0000</pubDate>
<dc:creator>arch-system</dc:creator>
<og:description>一、Jenkins简介 当每月发布次数变得越来越多时，如超过500次，发布工作人员的工作量会翻倍增长，此时由人工发布操作失误引起的风险会变得越来越大。为了提高项目的发布效率，也为了降低由人工操作失误带</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dotnet-arch-system/p/10195670.html</dc:identifier>
</item>
<item>
<title>vue 兼容IE报错解决方案 - 风吹De麦浪</title>
<link>http://www.cnblogs.com/CandyManPing/p/10195377.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CandyManPing/p/10195377.html</guid>
<description>&lt;p&gt;报错信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/825196/201812/825196-20181229121708438-517047458.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/825196/201812/825196-20181229121729260-1790836608.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 此时页面一片空白&lt;/p&gt;

&lt;p&gt;Babel 默认只转换新的 JavaScript 语法（如箭头函数），而不转换新的 API ，比如 Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise 等新的对象或者方法。&lt;/p&gt;
&lt;p&gt;例如 Promise 、新的原生方法如 String.padStart (left-pad) 等。为了解决这个问题，我们使用一种叫做 Polyfill（代码填充，也可译作兼容性补丁）的技术。&lt;/p&gt;
&lt;p&gt;简单的说，兼容问题一般是IE 对于es6 的部分新对象、表达式，语法并不支持，解决方案是使用 babel-polyfill 来正常使用ES6。&lt;/p&gt;

&lt;p&gt;举个例子，有些旧浏览器不支持 Number.isNaN方法，Polyfill就可以是这样的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;Number.isNaN) {
    Number.isNaN &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(num) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;(num !==&lt;span&gt; num);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Polyfill就是类似这样解决API的兼容问题&lt;/p&gt;

&lt;h2&gt;1、使用babel-polyfill&lt;/h2&gt;
&lt;h3&gt;引入 babel-polyfill &lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
npm i -S babel-polyfill
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;如何使用&lt;/h3&gt;
&lt;p&gt;使用它时需要在你应用程序的入口点顶部或打包配置中引入。&lt;/p&gt;
&lt;p&gt;在main.js 引入&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
import 'babel-polyfill'
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;或者在config中的 webpack.base.conf.js中 修改配置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;entry:{
    app:[&lt;/span&gt;'babel-polyfill','./src/main.js'&lt;span&gt;]      
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;2、在index.html 加入以下代码（非必须）&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;3、babel-loader 中指定模块转码&lt;/h2&gt;
&lt;p&gt;增加了poly-fill还是报错，这一般是使用了第三方的ui框架、库、插件等，并且这些ui框架、库、插件底层有es6的语法。&lt;/p&gt;
&lt;p&gt;找到webpack.base.conf.js 中的babel-loader&lt;/p&gt;
&lt;p&gt;比如我这里用了element-ui 跟 v-charts  修改成如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt; {
        test: &lt;/span&gt;/\.js$/&lt;span&gt;,
        loader: &lt;/span&gt;'babel-loader'&lt;span&gt;,
        include: [
          resolve(&lt;/span&gt;'src'&lt;span&gt;),
          resolve(&lt;/span&gt;'test'&lt;span&gt;),
          resolve(&lt;/span&gt;'node_modules/webpack-dev-server/client'&lt;span&gt;),
          resolve(&lt;/span&gt;'node_modules/v-charts/src'&lt;span&gt;),
          resolve(&lt;/span&gt;'node_modules/vue-awesome'&lt;span&gt;),
          resolve(&lt;/span&gt;'node_modules/element-ui/packages'&lt;span&gt;),
          resolve(&lt;/span&gt;'node_modules/element-ui/src'&lt;span&gt;)
        ]
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;4、打包问题&lt;/h2&gt;
&lt;p&gt;如果是webpack代码打包出错，一般到 &lt;span&gt;&lt;strong&gt;github webpack Issues &lt;/strong&gt;&lt;/span&gt;中可以找到答案&lt;/p&gt;
&lt;p&gt;这个错误是因为webpack-dev-server 版本问题&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/825196/201812/825196-20181229122203738-955932243.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;5、Babel 配置 .babelrc文件&lt;/h2&gt;
&lt;p&gt;.babelrc是Babel的配置文件，放在项目根目录下。一般情况下.babelrc文件不需要修改，如果以上都做了，还是报错，可以看下官网文档来配置下该文件&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/825196/201812/825196-20181229122245682-1588373654.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在项目使用 vue-cli 生成的代码中，根目录有一个 .babelrc 文件。在默认生成的模板内容中，增加 &lt;span&gt;&lt;strong&gt;&quot;useBuiltIns&quot;: &quot;entry&quot;&lt;/strong&gt;&lt;/span&gt; ，这是一个指定哪些内容需要被 polyfill(兼容) 的设置&lt;br/&gt;&lt;span&gt;&lt;strong&gt;useBuiltIns&lt;/strong&gt;&lt;/span&gt; 有三个设置&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;false - 不做任何操作&lt;/li&gt;
&lt;li&gt;entry - 根据浏览器版本的支持，将 polyfill 需求拆分引入，仅引入有浏览器不支持的polyfill&lt;/li&gt;
&lt;li&gt;usage - 检测代码中 ES6/7/8 等的使用情况，仅仅加载代码中用到的 polyfill&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &lt;/span&gt;&quot;presets&quot;&lt;span&gt;: [
    [&lt;/span&gt;&quot;env&quot;&lt;span&gt;, {
      &lt;/span&gt;&quot;modules&quot;: &lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&quot;useBuiltIns&quot;: &quot;entry&quot;&lt;span&gt;
    }],
    &lt;/span&gt;&quot;stage-2&quot;&lt;span&gt;
  ],
  &lt;/span&gt;&quot;plugins&quot;: [&quot;transform-runtime&quot;, &quot;transform-vue-jsx&quot;&lt;span&gt;],
  &lt;/span&gt;&quot;env&quot;&lt;span&gt;: {
    &lt;/span&gt;&quot;test&quot;&lt;span&gt;: {
      &lt;/span&gt;&quot;presets&quot;: [&quot;env&quot;, &quot;stage-2&quot;&lt;span&gt;],
      &lt;/span&gt;&quot;plugins&quot;: [&quot;istanbul&quot;&lt;span&gt;]
    }
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;具体相关可以查看Babel官网：&lt;a href=&quot;https://www.babeljs.cn/&quot; target=&quot;_blank&quot;&gt;https://www.babeljs.cn/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;1、用vue 写的项目最多可以兼容到IE9 及以上版本&lt;/p&gt;
&lt;p&gt;2、使用 babel-polyfill&lt;/p&gt;
&lt;p&gt;3、在babel-loader中指定需要转码的第三方的ui框架、库、插件路径&lt;/p&gt;
&lt;p&gt;4、配置 .babelrc文件&lt;/p&gt;
&lt;p&gt;5、Babel 是一个厉害的东西 &lt;a href=&quot;https://www.babeljs.cn/&quot; target=&quot;_blank&quot;&gt;https://www.babeljs.cn/&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 29 Dec 2018 05:25:00 +0000</pubDate>
<dc:creator>风吹De麦浪</dc:creator>
<og:description>IE 页面空白 报错信息 此时页面一片空白 报错原因 Babel 默认只转换新的 JavaScript 语法（如箭头函数），而不转换新的 API ，比如 Iterator、Generator、Set、</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CandyManPing/p/10195377.html</dc:identifier>
</item>
</channel>
</rss>