<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>re模块 - 咸鱼Chen</title>
<link>http://www.cnblogs.com/nickchen121/p/10808645.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nickchen121/p/10808645.html</guid>
<description>&lt;div class=&quot;toc&quot;&gt;
&lt;p class=&quot;toc-title&quot;&gt;目录&lt;/p&gt;
&lt;div class=&quot;toc-list&quot;&gt;
&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/nickchen121/p/10808645.html#正则表达式了解&quot;&gt;正则表达式(了解)&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/nickchen121/p/10808645.html#re模块的基本使用掌握&quot;&gt;re模块的基本使用(掌握)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/nickchen121/p/10808645.html#re模块中常用功能函数掌握&quot;&gt;re模块中常用功能函数(掌握)&lt;/a&gt;
&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/nickchen121/p/10808645.html#正则表达式的两种书写方式&quot;&gt;正则表达式的两种书写方式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/nickchen121/p/10808645.html#re.compilestrpattern-flag函数了解&quot;&gt;re.compile(strPattern[, flag])函数(了解)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/nickchen121/p/10808645.html#re.matchpattern-string-flags函数常用&quot;&gt;re.match(pattern, string[, flags])函数(常用)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/nickchen121/p/10808645.html#分组函数&quot;&gt;分组函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/nickchen121/p/10808645.html#re.searchpattern-string-flags函数&quot;&gt;re.search(pattern, string[, flags])函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/nickchen121/p/10808645.html#re.findallpattern-string-flags函数常用&quot;&gt;re.findall(pattern, string[, flags])函数(常用)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/nickchen121/p/10808645.html#re.splitpattern-string-maxsplit函数&quot;&gt;re.split(pattern, string[, maxsplit])函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/nickchen121/p/10808645.html#re.subpattern-repl-string-count函数&quot;&gt;re.sub(pattern, repl, string[, count])函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/nickchen121/p/10808645.html#re.subnpattern-repl-string-count-flags函数&quot;&gt;re.subn(pattern, repl, string,[, count][, flags])函数&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/nickchen121/p/10808645.html#注意事项掌握&quot;&gt;注意事项(掌握)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;正则表达式本身是一种小型的、高度专业化的编程语言，它并不是Python的一部分。正则表达式是用于处理字符串的强大工具，拥有自己独特的语法以及一个独立的处理引擎，效率上可能不如str自带的方法，但功能十分强大。得益于这一点，在提供了正则表达式的语言里，正则表达式的语法都是一样的，区别只在于不同的编程语言实现支持的语法数量不同；但不用担心，不被支持的语法通常是不常用的部分。如果已经在其他语言里使用过正则表达式，只需要简单看一看就可以上手了。而在python中，通过内嵌集成re模块，程序员们可以直接调用来实现正则匹配。正则表达式模式被编译成一系列的字节码，然后由用C编写的匹配引擎执行。&lt;/p&gt;
&lt;p&gt;下图展示了使用正则表达式进行匹配的流程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/nickchen121/1447696/o_80re%E6%A8%A1%E5%9D%97-%E6%B5%81%E7%A8%8B%E5%9B%BE.png&quot; alt=&quot;80re模块-流程图.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;正则表达式的大致匹配过程是：依次拿出表达式和文本中的字符比较，如果每一个字符都能匹配，则匹配成功；一旦有匹配不成功的字符则匹配失败。如果表达式中有量词或边界，这个过程会稍微有一些不同，但也是很好理解的，看下图中的示例以及自己多使用几次就能明白。&lt;/p&gt;
&lt;p&gt;下图列出了Python支持的正则表达式元字符和语法：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/nickchen121/1447696/o_80re%E6%A8%A1%E5%9D%97-%E5%8C%B9%E9%85%8D%E5%9B%BE.png&quot; alt=&quot;80re模块-匹配图.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;数量词的贪婪模式与非贪婪模式&quot;&gt;数量词的贪婪模式与非贪婪模式&lt;/h2&gt;
&lt;p&gt;正则表达式通常用于在文本中查找匹配的字符串。Python里数量词默认是贪婪的（在少数语言里也可能是默认非贪婪），总是尝试匹配尽可能多的字符；非贪婪的则相反，总是尝试匹配尽可能少的字符。例如：正则表达式&quot;ab&lt;em&gt;&quot;如果用于查找&quot;abbbc&quot;，将找到&quot;abbb&quot;。而如果使用非贪婪的数量词&quot;ab&lt;/em&gt;?&quot;，将找到&quot;a&quot;。&lt;/p&gt;
&lt;h2 id=&quot;反斜杠的困扰&quot;&gt;反斜杠的困扰&lt;/h2&gt;
&lt;p&gt;与大多数编程语言相同，正则表达式里使用&quot;&quot;作为转义字符，这就可能造成反斜杠困扰。假如你需要匹配文本中的字符&quot;&quot;，那么使用编程语言表示的正则表达式里将需要4个反斜杠&quot;\\&quot;：前两个和后两个分别用于在编程语言里转义成反斜杠，转换成两个反斜杠后再在正则表达式里转义成一个反斜杠。Python里的原生字符串很好地解决了这个问题，这个例子中的正则表达式可以使用r&quot;\&quot;表示。同样，匹配一个数字的&quot;\d&quot;可以写成r&quot;\d&quot;。有了原生字符串，你再也不用担心是不是漏写了反斜杠，写出来的表达式也更直观。&lt;/p&gt;
&lt;h2 id=&quot;匹配模式&quot;&gt;匹配模式&lt;/h2&gt;
&lt;p&gt;正则表达式提供了一些可用的匹配模式，比如忽略大小写、多行匹配等，这部分内容将在Pattern类的工厂方法re.compile(pattern[, flags])中一起介绍。&lt;/p&gt;

&lt;p&gt;正则表达式是用来匹配处理字符串的 python 中使用正则表达式需要引入re模块&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import re  # 第一步，要引入re模块
a = re.findall(&quot;匹配规则&quot;, &quot;这个字符串是否有匹配规则的字符&quot;)  # 第二步，调用模块函数
print(a)  # 以列表形式返回匹配到的字符串&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;['匹配规则']&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;^元字符&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;字符串开始位置与匹配规则符合就匹配，否则不匹配&lt;/p&gt;
&lt;p&gt;匹配字符串开头。在多行模式中匹配每一行的开头&lt;/p&gt;
&lt;p&gt;^元字符如果写到[]字符集里就是反取&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import re
a = re.findall(&quot;^匹配规则&quot;, &quot;匹配规则这个字符串是否匹配&quot;)  # 字符串开始位置与匹配规则符合就匹配，否则不匹配
print(a)
#打印出 ['匹配规则']&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;['匹配规则']&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;[^a-z]反取&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;匹配出除字母外的字符，^元字符如果写到字符集里就是反取&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import re
a = re.findall(&quot;[^a-z]&quot;, &quot;匹配s规则这s个字符串是否s匹配f规则则re则则则&quot;)  # 反取，匹配出除字母外的字符
print(a)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;['匹', '配', '规', '则', '这', '个', '字', '符', '串', '是', '否', '匹', '配', '规', '则', '则', '则', '则', '则']&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;$元字符&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;字符串结束位置与匹配规则符合就匹配，否则不匹配&lt;/p&gt;
&lt;p&gt;匹配字符串末尾，在多行模式中匹配每一行的末尾&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import re
a = re.findall(&quot;匹配规则$&quot;, &quot;这个字符串是否匹配规则&quot;)  # 字符串结束位置与匹配规则符合就匹配，否则不匹配
print(a)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;['匹配规则']&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;*元字符&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;需要字符串里完全符合，匹配规则，就匹配，（规则里的*元字符）前面的一个字符可以是0个或多个原本字符&lt;/p&gt;
&lt;p&gt;匹配前一个字符0或多次，贪婪匹配前导字符有多少个就匹配多少个很贪婪&lt;/p&gt;
&lt;p&gt;如果规则里只有一个分组，尽量避免用*否则会有可能匹配出空字符串&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import re
# 需要字符串里完全符合，匹配规则，就匹配，（规则里的*元字符）前面的一个字符可以是0或多个原本字符
a = re.findall(&quot;匹配规则*&quot;, &quot;这个字符串是否匹配规则则则则则&quot;)
print(a)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;['匹配规则则则则则']&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;+元字符&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;需要字符串里完全符合，匹配规则，就匹配，（规则里的+元字符）前面的一个字符可以是1个或多个原本字符&lt;/p&gt;
&lt;p&gt;匹配前一个字符1次或无限次，贪婪匹配前导字符有多少个就匹配多少个很贪婪&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import re
# 需要字符串里完全符合，匹配规则，就匹配，（规则里的+元字符）前面的一个字符可以是1个或多个原本字符
a = re.findall(&quot;匹配+&quot;, &quot;匹配配配配配规则这个字符串是否匹配规则则则则则&quot;)
print(a)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;['匹配配配配配', '匹配']&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;?元字符&lt;/strong&gt;(防止贪婪匹配)&lt;/p&gt;
&lt;p&gt;需要字符串里完全符合，匹配规则，就匹配，（规则里的?元字符）前面的一个字符可以是0个或1个原本字符&lt;/p&gt;
&lt;p&gt;匹配一个字符0次或1次&lt;/p&gt;
&lt;p&gt;还有一个功能是可以防止贪婪匹配，详情见防贪婪匹配&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import re
# 需要字符串里完全符合，匹配规则，就匹配，（规则里的?元字符）前面的一个字符可以是0个或1个原本字符
a = re.findall(&quot;匹配规则?&quot;, &quot;匹配规这个字符串是否匹配规则则则则则&quot;)
print(a)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;['匹配规', '匹配规则']&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;{}元字符&lt;/strong&gt;(范围)&lt;/p&gt;
&lt;p&gt;需要字符串里完全符合，匹配规则，就匹配，（规则里的 {} 元字符）前面的一个字符，是自定义字符数，位数的原本字符&lt;/p&gt;
&lt;p&gt;{m}匹配前一个字符m次，{m,n}匹配前一个字符m至n次，若省略n，则匹配m至无限次&lt;/p&gt;
&lt;p&gt;{0,}匹配前一个字符0或多次,等同于*元字符&lt;br/&gt;{+,}匹配前一个字符1次或无限次,等同于+元字符&lt;br/&gt;{0,1}匹配前一个字符0次或1次,等同于?元字符&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import re
# {m}匹配前一个字符m次，{m,n}匹配前一个字符m至n次，若省略n，则匹配m至无限次
a = re.findall(&quot;匹配规则{3}&quot;, &quot;匹配规这个字符串是否匹配规则则则则则&quot;)
print(a)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;['匹配规则则则']&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;[]元字符&lt;/strong&gt;(字符集)&lt;/p&gt;
&lt;p&gt;需要字符串里完全符合，匹配规则，就匹配，（规则里的 [] 元字符）对应位置是[]里的任意一个字符就匹配&lt;/p&gt;
&lt;p&gt;字符集。对应的位置可以是字符集中任意字符。字符集中的字符可以逐个列出，也可以给出范围，如[abc]或[a-c]。[^abc]表示取反，即非abc。&lt;br/&gt;所有特殊字符在字符集中都失去其原有的特殊含义。用\反斜杠转义恢复特殊字符的特殊含义。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import re
# 需要字符串里完全符合，匹配规则，就匹配，（规则里的 [] 元字符）对应位置是[]里的任意一个字符就匹配
a = re.findall(&quot;匹配[a,b,c]规则&quot;, &quot;匹配a规则这个字符串是否匹配b规则则则则则&quot;)
print(a)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;['匹配a规则', '匹配b规则']&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;[^]&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;非，反取，匹配出除[^]里面的字符，^元字符如果写到字符集里就是反取&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import re
a = re.findall(&quot;[^a-z]&quot;, &quot;匹配s规则这s个字符串是否s匹配f规则则re则则则&quot;)  # 反取，匹配出除字母外的字符
print(a)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;['匹', '配', '规', '则', '这', '个', '字', '符', '串', '是', '否', '匹', '配', '规', '则', '则', '则', '则', '则']&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;反斜杠后边跟普通字符实现特殊功能&lt;/strong&gt;(预定义字符)&lt;/p&gt;
&lt;p&gt;预定义字符是在字符集和组里都是有用的&lt;/p&gt;
&lt;p&gt;\d匹配任何十进制数，它相当于类[0-9]&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import re
a = re.findall(&quot;\d&quot;, &quot;匹配规则这2个字符串3是否匹配规则5则则则7则&quot;)  # \d匹配任何十进制数，它相当于类[0-9]
print(a)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;['2', '3', '5', '7']&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;\d+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;匹配一位或者多位数的数字时用&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import re
a = re.findall(&quot;\d+&quot;, &quot;匹配规则这2个字符串134444是否匹配规则5则则则7则&quot;)  # \d+如果需要匹配一位或者多位数的数字时用
print(a)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;['2', '134444', '5', '7']&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;\D&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;匹配任何非数字字符，它相当于类[^0-9]&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import re
a = re.findall(&quot;\D&quot;, &quot;匹配规则这2个字符串3是否匹配规则5则则则7则&quot;)  # \D匹配任何非数字字符，它相当于类[^0-9]
print(a)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;['匹', '配', '规', '则', '这', '个', '字', '符', '串', '是', '否', '匹', '配', '规', '则', '则', '则', '则', '则']&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;\s&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;匹配任何空白字符，它相当于类[\t\n\r\f\v]&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import re
# \s匹配任何空白字符，它相当于类[\t\n\r\f\v]
a = re.findall(&quot;\s&quot;, &quot;匹配规则   这2个字符串3是否匹\n配规则5则则则7则&quot;)
print(a)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;[' ', ' ', ' ', '\n']&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;\S&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;匹配任何非空白字符，它相当于类[^\t\n\r\f\v]&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import re
# \S匹配任何非空白字符，它相当于类[^\t\n\r\f\v]
a = re.findall(&quot;\S&quot;, &quot;匹配规则   这2个字符串3是否匹\n配规则5则则则7则&quot;)
print(a)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;['匹', '配', '规', '则', '这', '2', '个', '字', '符', '串', '3', '是', '否', '匹', '配', '规', '则', '5', '则', '则', '则', '7', '则']&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;\w&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;匹配包括下划线在内任何字母数字字符，它相当于类[a-zA-Z0-9_]&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import re
# \w匹配包括下划线在内任何字母数字字符，它相当于类[a-zA-Z0-9_]
a = re.findall('\w', &quot;https://www.cnblogs.com/&quot;)
print(a)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;['h', 't', 't', 'p', 's', 'w', 'w', 'w', 'c', 'n', 'b', 'l', 'o', 'g', 's', 'c', 'o', 'm']&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;\W&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;匹配非任何字母数字字符包括下划线在内，它相当于类[^a-zA-Z0-9_]&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import re
# \w匹配包括下划线在内任何字母数字字符，它相当于类[a-zA-Z0-9_]
a = re.findall('\W', &quot;https://www.cnblogs.com/&quot;)
print(a)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;[':', '/', '/', '.', '.', '/']&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;()元字符&lt;/strong&gt;(分组)&lt;/p&gt;
&lt;p&gt;也就是分组匹配，()里面的为一个组也可以理解成一个整体&lt;/p&gt;
&lt;p&gt;如果()后面跟的是特殊元字符如 (adc)* 那么*控制的前导字符就是()里的整体内容，不再是前导一个字符&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import re
# 也就是分组匹配，()里面的为一个组也可以理解成一个整体
a = re.search(&quot;(a4)+&quot;, &quot;a4a4a4a4a4dg4g654gb&quot;)  # 匹配一个或多个a4
b = a.group()
print(b)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;a4a4a4a4a4&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import re
# 也就是分组匹配，()里面的为一个组也可以理解成一个整体
# 匹配 (a) (\d0-9的数字) (+可以是1个到多个0-9的数字)
a = re.search(&quot;a(\d+)&quot;, &quot;a466666664a4a4a4dg4g654gb&quot;)
b = a.group()
print(b)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;a466666664&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;|元字符&lt;/strong&gt;(或)&lt;/p&gt;
&lt;p&gt;|或，或就是前后其中一个符合就匹配&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import re
a = re.findall(r&quot;你|好&quot;, &quot;a4a4a你4aabc4a4dgg好dg4g654g&quot;)  # |或，或就是前后其中一个符合就匹配
print(a)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;['你', '好']&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;正则表达式的两种书写方式&quot;&gt;正则表达式的两种书写方式&lt;/h2&gt;
&lt;p&gt;1.一种是直接在函数里书写规则，&lt;strong&gt;推荐使用&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import re
a = re.findall(&quot;匹配规则&quot;, &quot;这个字符串是否有匹配规则的字符&quot;)
print(a)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;['匹配规则']&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.另一种是先将正则表达式的字符串形式编译为Pattern实例，然后使用Pattern实例处理文本并获得匹配结果（一个Match实例），最后使用Match实例获得信息，进行其他的操作。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import re

# 将正则表达式编译成Pattern对象
pattern = re.compile(r'hello')

# 使用Pattern匹配文本，获得匹配结果，无法匹配时将返回None
match = pattern.match('hello world!')

if match:
    # 使用Match获得分组信息
    print(match.group())&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;hello&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;re.compilestrpattern-flag函数了解&quot;&gt;re.compile(strPattern[, flag])函数(了解)&lt;/h2&gt;
&lt;p&gt;这个方法是Pattern类的工厂方法，用于将字符串形式的正则表达式编译为Pattern对象。 第二个参数flag是匹配模式，取值可以使用按位或运算符'|'表示同时生效，比如re.I | re.M。另外，你也可以在regex字符串中指定模式，比如re.compile('pattern', re.I | re.M)与re.compile('(?im)pattern')是等价的。&lt;/p&gt;
&lt;p&gt;下表是所有的正则匹配模式：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;7.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;re.S(DOTALL)&lt;/td&gt;
&lt;td&gt;使.匹配包括换行在内的所有字符&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;re.I（IGNORECASE）&lt;/td&gt;
&lt;td&gt;使匹配对大小写不敏感&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;re.L（LOCALE）&lt;/td&gt;
&lt;td&gt;做本地化识别（locale-aware)匹配，法语等&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;re.M(MULTILINE)&lt;/td&gt;
&lt;td&gt;多行匹配，影响^和$&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;re.X(VERBOSE)&lt;/td&gt;
&lt;td&gt;该标志通过给予更灵活的格式以便将正则表达式写得更易于理解&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td&gt;re.U&lt;/td&gt;
&lt;td&gt;根据Unicode字符集解析字符，这个标志影响\w,\W,\b,\B&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;re.matchpattern-string-flags函数常用&quot;&gt;re.match(pattern, string[, flags])函数(常用)&lt;/h2&gt;
&lt;p&gt;match，从头匹配一个符合规则的字符串，从起始位置开始匹配，匹配成功返回一个对象，未匹配成功返回None&lt;br/&gt;match(pattern, string, flags=0)&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;pattern： 正则模型&lt;/li&gt;
&lt;li&gt;string ： 要匹配的字符串&lt;/li&gt;
&lt;li&gt;falgs ： 匹配模式&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;注意：match()函数 与 search()函数基本是一样的功能，不一样的就是match()匹配字符串开始位置的一个符合规则的字符串，search()是在字符串全局匹配第一个合规则的字符串&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import re
# 无分组
origin = &quot;hello egon bcd egon lge egon acd 19&quot;
r = re.match(&quot;h\w+&quot;, origin)  # match，从起始位置开始匹配，匹配成功返回一个对象，未匹配成功返回None
print(r.group())  # 获取匹配到的所有结果，不管有没有分组将匹配到的全部拿出来
print(r.groups())  # 获取模型中匹配到的分组结果，只拿出匹配到的字符串中分组部分的结果
print(r.groupdict())  # 获取模型中匹配到的分组结果，只拿出匹配到的字符串中分组部分定义了key的组结果&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;hello
()
{}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 有分组
# 为何要有分组？提取匹配成功的指定内容（先匹配成功全部正则，再匹配成功的局部内容提取出来）
r = re.match(&quot;h(\w+)&quot;, origin)  # match，从起始位置开始匹配，匹配成功返回一个对象，未匹配成功返回None
print(r.group())  # 获取匹配到的所有结果，不管有没有分组将匹配到的全部拿出来
print(r.groups())  # 获取模型中匹配到的分组结果，只拿出匹配到的字符串中分组部分的结果
print(r.groupdict())  # 获取模型中匹配到的分组结果，只拿出匹配到的字符串中分组部分定义了key的组结果&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;hello
('ello',)
{}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 有两个分组定义了key
# 为何要有分组？提取匹配成功的指定内容（先匹配成功全部正则，再匹配成功的局部内容提取出来）
# ?P&amp;lt;&amp;gt;定义组里匹配内容的key(键)，&amp;lt;&amp;gt;里面写key名称，值就是匹配到的内容
r = re.match(&quot;(?P&amp;lt;n1&amp;gt;h)(?P&amp;lt;n2&amp;gt;\w+)&quot;, origin)
print(r.group())  # 获取匹配到的所有结果，不管有没有分组将匹配到的全部拿出来
print(r.groups())  # 获取模型中匹配到的分组结果，只拿出匹配到的字符串中分组部分的结果
print(r.groupdict())  # 获取模型中匹配到的分组结果，只拿出匹配到的字符串中分组部分定义了key的组结果&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;hello
('h', 'ello')
{'n1': 'h', 'n2': 'ello'}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;分组函数&quot;&gt;分组函数&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;?P&amp;lt;n1&amp;gt;&lt;/code&gt; # ?P&amp;lt;&amp;gt;定义组里匹配内容的key(键)，&amp;lt;&amp;gt;里面写key名称，值就是匹配到的内容（只对正则函数返回对象时有用）&lt;/p&gt;
&lt;p&gt;取出匹配对象方法&lt;/p&gt;
&lt;p&gt;只对正则函数返回对象的有用&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;group() # 获取匹配到的所有结果，不管有没有分组将匹配到的全部拿出来，有参取匹配到的第几个如2&lt;/li&gt;
&lt;li&gt;groups() # 获取模型中匹配到的分组结果，只拿出匹配到的字符串中分组部分的结果&lt;/li&gt;
&lt;li&gt;groupdict() # 获取模型中匹配到的分组结果，只拿出匹配到的字符串中分组部分定义了key的组结果&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;re.searchpattern-string-flags函数&quot;&gt;re.search(pattern, string[, flags])函数&lt;/h2&gt;
&lt;p&gt;search,浏览全部字符串，匹配第一符合规则的字符串，浏览整个字符串去匹配第一个，未匹配成功返回None&lt;/p&gt;
&lt;p&gt;search(pattern, string, flags=0)&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;pattern： 正则模型&lt;/li&gt;
&lt;li&gt;string ： 要匹配的字符串&lt;/li&gt;
&lt;li&gt;falgs ： 匹配模式&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;注意：match()函数 与 search()函数基本是一样的功能，不一样的就是match()匹配字符串开始位置的一个符合规则的字符串，search()是在字符串全局匹配第一个合规则的字符串&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import re
# 无分组
origin = &quot;hello alex bcd alex lge alex acd 19&quot;
# search浏览全部字符串，匹配第一符合规则的字符串，浏览整个字符串去匹配第一个，未匹配成功返回None
r = re.search(&quot;a\w+&quot;, origin)
print(r.group())  # 获取匹配到的所有结果，不管有没有分组将匹配到的全部拿出来
print(r.groups())  # 获取模型中匹配到的分组结果，只拿出匹配到的字符串中分组部分的结果
print(r.groupdict())  # 获取模型中匹配到的分组结果，只拿出匹配到的字符串中分组部分定义了key的组结果&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;alex
()
{}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 有分组
# 为何要有分组？提取匹配成功的指定内容（先匹配成功全部正则，再匹配成功的局部内容提取出来）
r = re.search(&quot;a(\w+).*(\d)&quot;, origin)
print(r.group())  # 获取匹配到的所有结果，不管有没有分组将匹配到的全部拿出来
print(r.groups())  # 获取模型中匹配到的分组结果，只拿出匹配到的字符串中分组部分的结果
print(r.groupdict())  # 获取模型中匹配到的分组结果，只拿出匹配到的字符串中分组部分定义了key的组结果&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;alex bcd alex lge alex acd 19
('lex', '9')
{}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 有两个分组定义了key
# 为何要有分组？提取匹配成功的指定内容（先匹配成功全部正则，再匹配成功的局部内容提取出来）
# ?P&amp;lt;&amp;gt;定义组里匹配内容的key(键)，&amp;lt;&amp;gt;里面写key名称，值就是匹配到的内容
r = re.search(&quot;a(?P&amp;lt;n1&amp;gt;\w+).*(?P&amp;lt;n2&amp;gt;\d)&quot;, origin)
print(r.group())  # 获取匹配到的所有结果，不管有没有分组将匹配到的全部拿出来
print(r.groups())  # 获取模型中匹配到的分组结果，只拿出匹配到的字符串中分组部分的结果
print(r.groupdict())  # 获取模型中匹配到的分组结果，只拿出匹配到的字符串中分组部分定义了key的组结果&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;alex bcd alex lge alex acd 19
('lex', '9')
{'n1': 'lex', 'n2': '9'}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;re.findallpattern-string-flags函数常用&quot;&gt;re.findall(pattern, string[, flags])函数(常用)&lt;/h2&gt;
&lt;p&gt;findall(pattern, string, flags=0)&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;pattern： 正则模型&lt;/li&gt;
&lt;li&gt;string ： 要匹配的字符串&lt;/li&gt;
&lt;li&gt;falgs ： 匹配模式&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;浏览全部字符串，匹配所有合规则的字符串，匹配到的字符串放到一个列表中，未匹配成功返回空列表&lt;/p&gt;
&lt;p&gt;注意：一旦匹配成，再次匹配，是从前一次匹配成功的，后面一位开始的，也可以理解为匹配成功的字符串，不在参与下次匹配&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import re
# 无分组
r = re.findall(&quot;\d+\w\d+&quot;, &quot;a2b3c4d5&quot;)  # 浏览全部字符串，匹配所有合规则的字符串，匹配到的字符串放到一个列表中
print(r)  # 注意：匹配成功的字符串，不在参与下次匹配,所以3c4也符合规则但是没匹配到&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;['2b3', '4d5']&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：如果没写匹配规则，也就是空规则，返回的是一个比原始字符串多一位的，空字符串列表&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import re
# 无分组
r = re.findall(&quot;&quot;, &quot;a2b3c4d5&quot;)  # 浏览全部字符串，匹配所有合规则的字符串，匹配到的字符串放到一个列表中
print(r)  # 注意：如果没写匹配规则，也就是空规则，返回的是一个比原始字符串多一位的，空字符串列表&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;['', '', '', '', '', '', '', '', '']&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：正则匹配到空字符的情况，如果规则里只有一个组，而组后面是&lt;em&gt;就表示组里的内容可以是0个或者多过，这样组里就有了两个意思，一个意思是匹配组里的内容，二个意思是匹配组里0内容（即是空白）所以尽量避免用&lt;/em&gt;否则会有可能匹配出空字符串&lt;/p&gt;
&lt;p&gt;注意：正则只拿组里最后一位，如果规则里只有一个组，匹配到的字符串里在拿组内容是，拿的是匹配到的内容最后一位&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import re
origin = &quot;hello alex bcd alex lge alex acd 19&quot;
r = re.findall(&quot;(a)*&quot;, origin)
print(r)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;['', '', '', '', '', '', 'a', '', '', '', '', '', '', '', '', 'a', '', '', '', '', '', '', '', '', 'a', '', '', '', '', 'a', '', '', '', '', '', '']&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;无分组：匹配所有合规则的字符串，匹配到的字符串放到一个列表中&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import re
# 无分组
origin = &quot;hello alex bcd alex lge alex acd 19&quot;
r = re.findall(&quot;a\w+&quot;, origin)  # 浏览全部字符串，匹配所有合规则的字符串，匹配到的字符串放到一个列表中
print(r)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;['alex', 'alex', 'alex', 'acd']&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有分组：只将匹配到的字符串里，组的部分放到列表里返回，相当于groups()方法&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import re
origin = &quot;hello alex bcd alex lge alex acd 19&quot;
r = re.findall(&quot;a(\w+)&quot;, origin)  # 有分组：只将匹配到的字符串里，组的部分放到列表里返回
print(r)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;['lex', 'lex', 'lex', 'cd']&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;多个分组：只将匹配到的字符串里，组的部分放到一个元组中，最后将所有元组放到一个列表里返&lt;/p&gt;
&lt;p&gt;相当于在group()结果里再将组的部分，分别，拿出来放入一个元组，最后将所有元组放入一个列表返回&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import re
origin = &quot;hello alex bcd alex lge alex acd 19&quot;
# 多个分组：只将匹配到的字符串里，组的部分放到一个元组中，最后将所有元组放到一个列表里返回
r = re.findall(&quot;(a)(\w+)&quot;, origin)
print(r)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;[('a', 'lex'), ('a', 'lex'), ('a', 'lex'), ('a', 'cd')]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;分组中有分组：只将匹配到的字符串里，组的部分放到一个元组中，先将包含有组的组，看作一个整体也就是一个组，把这个整体组放入一个元组里，然后在把组里的组放入一个元组，最后将所有组放入一个列表返回&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import re
origin = &quot;hello alex bcd alex lge alex acd 19&quot;
# 分组中有分组：只将匹配到的字符串里，组的部分放到一个元组中，先将包含有组的组，看作一个整体也就是一个组，把这个整体组放入一个元组里，然后在把组里的组放入一个元组，最后将所有组放入一个列表返回
r = re.findall(&quot;(a)(\w+(e))&quot;, origin)
print(r)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;[('a', 'le', 'e'), ('a', 'le', 'e'), ('a', 'le', 'e')]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;?:在有分组的情况下findall()函数，不只拿分组里的字符串，拿所有匹配到的字符串，注意?:只用于不是返回正则对象的函数如findall()&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import re
origin = &quot;hello alex bcd alex lge alex acd 19&quot;
# ?:在有分组的情况下，不只拿分组里的字符串，拿所有匹配到的字符串，注意?:只用于不是返回正则对象的函数如findall()
b = re.findall(&quot;a(?:\w+)&quot;, origin)
print(b)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;['alex', 'alex', 'alex', 'acd']&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;re.splitpattern-string-maxsplit函数&quot;&gt;re.split(pattern, string[, maxsplit])函数&lt;/h2&gt;
&lt;p&gt;根据正则匹配分割字符串，返回分割后的一个列表&lt;/p&gt;
&lt;p&gt;split(pattern, string, maxsplit=0, flags=0)&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;pattern： 正则模型&lt;/li&gt;
&lt;li&gt;string ： 要匹配的字符串&lt;/li&gt;
&lt;li&gt;maxsplit：指定分割个数&lt;/li&gt;
&lt;li&gt;flags ： 匹配模式&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;按照一个字符将全部字符串进行分割&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import re
origin = &quot;hello alex bcd alex lge alex acd 19&quot;
r = re.split(&quot;a&quot;, origin)  # 根据正则匹配分割字符串
print(r)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;['hello ', 'lex bcd ', 'lex lge ', 'lex ', 'cd 19']&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将匹配到的字符串作为分割标准进行分割&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import re
origin = &quot;hello alex bcd alex lge alex 2acd 19&quot;
r = re.split(&quot;a\w+&quot;, origin)  # 根据正则匹配分割字符串
print(r)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;['hello ', ' bcd ', ' lge ', ' 2', ' 19']&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;re.subpattern-repl-string-count函数&quot;&gt;re.sub(pattern, repl, string[, count])函数&lt;/h2&gt;
&lt;p&gt;替换匹配成功的指定位置字符串&lt;/p&gt;
&lt;p&gt;sub(pattern, repl, string, count=0, flags=0)&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;pattern： 正则模型&lt;/li&gt;
&lt;li&gt;repl ： 要替换的字符串&lt;/li&gt;
&lt;li&gt;string ： 要匹配的字符串&lt;/li&gt;
&lt;li&gt;count ： 指定匹配个数&lt;/li&gt;
&lt;li&gt;flags ： 匹配模式&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import re
origin = &quot;hello alex bcd alex lge alex acd 19&quot;
r = re.sub(&quot;a&quot;, &quot;替换&quot;, origin)  # 替换匹配成功的指定位置字符串
print(r)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;hello 替换lex bcd 替换lex lge 替换lex 替换cd 19&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;re.subnpattern-repl-string-count-flags函数&quot;&gt;re.subn(pattern, repl, string,[, count][, flags])函数&lt;/h2&gt;
&lt;p&gt;替换匹配成功的指定位置字符串,并且返回替换次数，可以用两个变量分别接受&lt;/p&gt;
&lt;p&gt;subn(pattern, repl, string, count=0, flags=0)&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;pattern： 正则模型&lt;/li&gt;
&lt;li&gt;repl ： 要替换的字符串&lt;/li&gt;
&lt;li&gt;string ： 要匹配的字符串&lt;/li&gt;
&lt;li&gt;count ： 指定匹配个数&lt;/li&gt;
&lt;li&gt;flags ： 匹配模式&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import re
origin = &quot;hello alex bcd alex lge alex acd 19&quot;
a, b = re.subn(&quot;a&quot;, &quot;替换&quot;, origin)  # 替换匹配成功的指定位置字符串,并且返回替换次数，可以用两个变量分别接受
print(a)
print(b)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;hello 替换lex bcd 替换lex lge 替换lex 替换cd 19
4&lt;/code&gt;
&lt;/pre&gt;

&lt;ol&gt;&lt;li&gt;r原生字符：让在python里有特殊意义的字符如\b，转换成原生字符（就是去除它在python的特殊意义），不然会给正则表达式有冲突，为了避免这种冲突可以在规则前加原始字符r&lt;/li&gt;
&lt;li&gt;正则表达式，返回类型为表达式对象的，如：&amp;lt;_sre.SRE_Match object; span=(6, 7), match='a'&amp;gt;，返回对象时，需要用正则方法取字符串，方法有：
&lt;ol&gt;&lt;li&gt;group() # 获取匹配到的所有结果，不管有没有分组将匹配到的全部拿出来，有参取匹配到的第几个如2&lt;/li&gt;
&lt;li&gt;groups() # 获取模型中匹配到的分组结果，只拿出匹配到的字符串中分组部分的结果&lt;/li&gt;
&lt;li&gt;groupdict() # 获取模型中匹配到的分组结果，只拿出匹配到的字符串中分组部分定义了key的组结果&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;匹配到的字符串里出现空字符：注意：正则匹配到空字符的情况，如果规则里只有一个组，而组后面是*就表示组里的内容可以是0个或者多过，这样组里就有了两个意思，一个意思是匹配组里的内容，二个意思是匹配组里0内容（即是空白）所以尽量避免用*否则会有可能匹配出空字符串&lt;/li&gt;
&lt;li&gt;()分组：注意：分组的意义，就是在匹配成功的字符串中，再提取()里的内容，也就是组里面的字符串&lt;/li&gt;
&lt;li&gt;?:在有分组的情况下findall()函数，不只拿分组里的字符串，拿所有匹配到的字符串，注意?:只用于不是返回正则对象的函数如findall()&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Sat, 04 May 2019 07:29:00 +0000</pubDate>
<dc:creator>咸鱼Chen</dc:creator>
<og:description>Python之re模块，正则表达式。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/nickchen121/p/10808645.html</dc:identifier>
</item>
<item>
<title>从实践认识修饰符 - 布尔bl</title>
<link>http://www.cnblogs.com/chenzhuantou/p/10808585.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenzhuantou/p/10808585.html</guid>
<description>&lt;h2 id=&quot;修饰符分类&quot;&gt;1 修饰符分类&lt;/h2&gt;
&lt;p&gt;说到修饰符，大家都知道有private deafult protect public，说到它们的区别，相信大家脑海会出现一张图。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;private&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;default&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;protected&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;public&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;那么怎么从代码层面解释呢，学东西不能停留在理论层面，毕竟只是一份实践的工作。所以请看下面讲解，毕竟实践才是检验真理的唯一标准，说白了就是写一些demo，验证一下，工作中我们不了解某个方法或者某个类的时候，本人推荐写一些demo，做一些test，本人觉得这是技巧之一。&lt;/p&gt;
&lt;h2 id=&quot;代码展示&quot;&gt;2 代码展示&lt;/h2&gt;
&lt;p&gt;本实例访问方法只有两种&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;创建对象访问，形成组合关系&lt;/li&gt;
&lt;li&gt;继承类，形成继承关系&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;引入必要的maven&quot;&gt;2.1 引入必要的maven&lt;/h3&gt;
&lt;p&gt;写demo验证自己想法时候，推荐使用test框架，不同每次都写一个main方法，只要一个注解@test就能解决问题&lt;/p&gt;
&lt;pre class=&quot;pom&quot;&gt;
&lt;code&gt; &amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;4.12&amp;lt;/version&amp;gt;
    &amp;lt;scope&amp;gt;compile&amp;lt;/scope&amp;gt;
 &amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也可以使用slf4j框架来打印信息&lt;/p&gt;
&lt;pre class=&quot;pom&quot;&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.slf4j&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;slf4j-api&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.7.5&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.slf4j&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;slf4j-simple&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.6.4&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也可以使用lombok框架，实现注解@getter和@setter代替getter方法和setter方法&lt;/p&gt;
&lt;pre class=&quot;pom&quot;&gt;
&lt;code&gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.projectlombok&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;lombok&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.16.16&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;private&quot;&gt;2.2 private&lt;/h3&gt;
&lt;p&gt;需要创建对象 调用类中属性&lt;/p&gt;
&lt;h4 id=&quot;实例&quot;&gt;2.2.1 实例&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package classtest;

import lombok.Getter;
import lombok.Setter;
import org.junit.Test;

/**
 * @Author buer
 * @create 2019/4/28 10:06
 * @description 父类
 */
@Getter@Setter
public class Animal {
    public int id = 1;
    private String name=&quot;chen&quot;;
    protected String parent = &quot;parent&quot;;

    @Test
    public void eat(){
        Animal animal  = new Animal();
        System.out.println(animal.name);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;结果&quot;&gt;2.2.2 结果&lt;/h4&gt;
&lt;p&gt;chen&lt;/p&gt;
&lt;p&gt;ps：贴图很麻烦 就贴字了&lt;/p&gt;
&lt;h4 id=&quot;结论&quot;&gt;2.2.3 结论&lt;/h4&gt;
&lt;p&gt;在本类创建对象可以直接访问private属性字段&lt;/p&gt;
&lt;h3 id=&quot;default&quot;&gt;2.3 default&lt;/h3&gt;
&lt;p&gt;创建对象，访问属性&lt;/p&gt;
&lt;h4 id=&quot;实例-1&quot;&gt;2.3.1 实例&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package classtest;
@Getter
@Setter
public class Classtest {
    @Test
    public void defaultTest(){
        Animal animal  = new Animal();
        System.out.println(animal.name);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;另一个类name属性改变--》protected&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package classtest;
@Getter
@Setter
 public class Animal {
    private int id;
    String name=&quot;chen&quot;;
    protected String parent;

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;结果-1&quot;&gt;2.3.2 结果&lt;/h4&gt;
&lt;p&gt;chen&lt;/p&gt;
&lt;h4 id=&quot;结论-1&quot;&gt;2.3.3 结论&lt;/h4&gt;
&lt;p&gt;在同一个包中创建对象可以直接访问，不同包下创建对象不能访问default 默认属性字段，例子省略&lt;/p&gt;
&lt;h3 id=&quot;protected&quot;&gt;2.4 protected&lt;/h3&gt;
&lt;p&gt;继承父类，不需要创建父类对象，直接访问protected属性字段&lt;/p&gt;
&lt;h4 id=&quot;实例-2&quot;&gt;2.4.1 实例&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package butong;

import classtest.Animal;
import org.junit.Test;

/**
 * @Author buer
 * @create 2019/5/4 14:37
 * @description
 */


public class Animalbutong extends Animal{

    @Test
    public void defaultTest(){
        System.out.println(parent);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;结果-2&quot;&gt;2.4.2 结果&lt;/h4&gt;
&lt;p&gt;chen&lt;/p&gt;
&lt;h4 id=&quot;结论-2&quot;&gt;2.4.3 结论&lt;/h4&gt;
&lt;p&gt;在子类中可以直接进访问父类字段，不需要创建对象&lt;/p&gt;
&lt;h3 id=&quot;public&quot;&gt;2.5 public&lt;/h3&gt;
&lt;p&gt;在不同包以及非子类关系下，创建对象可以访问public属性字段&lt;/p&gt;
&lt;h4 id=&quot;实例-3&quot;&gt;2.5.1 实例&lt;/h4&gt;
&lt;p&gt;test属性是public&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
package butong;

import classtest.Animal;
import org.junit.Test;

/**
 * @Author buer
 * @create 2019/5/4 14:37
 * @description
 */


public class Animalbutong {

    @Test
    public void defaultTest(){
        Animal animal = new Animal();
        System.out.println(animal.test);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;结果-3&quot;&gt;2.5.2 结果&lt;/h4&gt;
&lt;p&gt;chen&lt;/p&gt;
&lt;h4 id=&quot;结论-3&quot;&gt;2.5.3 结论&lt;/h4&gt;
&lt;p&gt;在不同包以及非子类关系下，创建对象可以访问public属性字段&lt;/p&gt;
</description>
<pubDate>Sat, 04 May 2019 07:13:00 +0000</pubDate>
<dc:creator>布尔bl</dc:creator>
<og:description>从实践认识修饰符 1 修饰符分类 说到修饰符，大家都知道有private deafult protect public，说到它们的区别，相信大家脑海会出现一张图。  |同一个类|同包非子类|</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenzhuantou/p/10808585.html</dc:identifier>
</item>
<item>
<title>[wxpusher]分享一个服务器推送消息到微信上的小工具，可以用于微信推送提醒和告警。 - zjiecode</title>
<link>http://www.cnblogs.com/zjiecode/p/zjiecode.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zjiecode/p/zjiecode.html</guid>
<description>&lt;p&gt;&lt;strong&gt;背景&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;作为一个程序员，业余搞点自己的东西很正常，一般程序员都会有一两台自己的服务器，谁叫今天xx云搞活动，明天yy云搞活动呢。&lt;/p&gt;
&lt;p&gt;自家的服务器用来跑爬虫，跑博客，或者跑一些个人业务，但当服务有新状态，抢到课了，刷到车票了，爬虫cookie过期了等，需要及时提醒我们。&lt;/p&gt;
&lt;p&gt;现有的方案，大概就是下面2种：&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr&gt;&lt;td&gt;方式&lt;/td&gt;
&lt;td&gt;优点&lt;/td&gt;
&lt;td&gt;缺点&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;短信&lt;/td&gt;
&lt;td&gt;实时性强&lt;/td&gt;
&lt;td&gt;要钱&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;邮件&lt;/td&gt;
&lt;td&gt;免费&lt;/td&gt;
&lt;td&gt;实时性不强，不查收邮件可能看不到。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;我们觉得2种方案都不是很完美，因此去申请了“开发者服务”这个公众号。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;消息推送服务&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我给他取了一个形象的名字[wxpusher]&lt;/p&gt;
&lt;p&gt;现在大家使用微信的频率都非常高，把服务器的消息通过微信推送，实时性和到达率，都会非常高，不仅对接非常简单，不需要做用户鉴权，而且还是完全免费的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1558243/201905/1558243-20190504145457645-1434424264.jpg&quot; alt=&quot;&quot; width=&quot;414&quot; height=&quot;194&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用方法[只需要2步]&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、关注公众号:wxpusher(开发者服务)，文末有二维码，消息会通过这个公号推送。&lt;/p&gt;
&lt;p&gt;2、把要推送的消息通过一个简单的GET请求发送到我们的服务即可，就像这样：http://wxmsg.dingliqc.com/send?msg=test&amp;amp;userIds=123 （详细API协议关注公众号以后可以看到）。&lt;/p&gt;
&lt;p&gt;不要授权，不需要登录，不要签名啥的，是不是觉得很简单？&lt;/p&gt;
&lt;p&gt;如果你使用的是Java，可以直接使用SDK调用，&lt;a href=&quot;https://github.com/zjiecode/wxpusher-client&quot;&gt;https://github.com/zjiecode/wxpusher-client&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;本服务使用的是微信的模版消息，需要企业账号认证，你可以直接使用我们的服务，避免个人申请不了企业服务号的麻烦。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;实现的效果&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;实时性非常强，推送消息以后，1-2秒手机就可以收到了，并且免费的，收到推送后大概是下面这个样子。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1558243/201905/1558243-20190504145723245-2059789200.jpg&quot; alt=&quot;&quot; width=&quot;492&quot; height=&quot;498&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本服务永久免费，欢迎扫描下面二维码关注，体验使用。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1558243/201905/1558243-20190504145801005-482508714.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 04 May 2019 07:00:00 +0000</pubDate>
<dc:creator>zjiecode</dc:creator>
<og:description>微信消息实时推送服务[WxPusher]，可以通过API实时给个人微信推送消息.http://wxpusher.dingliqc.com/</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zjiecode/p/zjiecode.html</dc:identifier>
</item>
<item>
<title>一篇短文带您了解一下EasyCaching - Catcher8</title>
<link>http://www.cnblogs.com/catcher1994/p/10806607.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/catcher1994/p/10806607.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;从2017年11月11号在Github创建&lt;a href=&quot;https://github.com/dotnetcore/EasyCaching&quot;&gt;EasyCaching&lt;/a&gt;这个仓库，到现在也已经将近一年半的时间了，基本都是在下班之后和假期在完善这个项目。&lt;/p&gt;
&lt;p&gt;由于EasyCaching目前只有英文的&lt;a href=&quot;https://easycaching.readthedocs.io/en/latest/&quot;&gt;文档&lt;/a&gt;托管在Read the Docs上面，当初选的MkDocs现在还不支持多语言，所以这个中文的要等它支持之后才会有计划。&lt;/p&gt;
&lt;p&gt;之前在群里有看到过有人说没找到EasyCaching的相关介绍，这也是为什么要写这篇博客的原因。&lt;/p&gt;
&lt;p&gt;下面就先简单介绍一下EasyCaching。&lt;/p&gt;
&lt;h2 id=&quot;什么是easycaching&quot;&gt;什么是EasyCaching&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/558945/201905/558945-20190503210108828-943190236.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;EasyCaching，这个名字就很大程度上解释了它是做什么的，easy和caching放在一起，其最终的目的就是为了让我们大家在操作缓存的时候更加的方便。&lt;/p&gt;
&lt;p&gt;它的发展大概经历了这几个比较重要的时间节点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;18年3月，在茶叔的帮助下进入了NCC&lt;/li&gt;
&lt;li&gt;19年1月，镇汐大大提了很多改进意见&lt;/li&gt;
&lt;li&gt;19年3月，NopCommerce引入EasyCaching (可以看这个 &lt;a href=&quot;https://github.com/nopSolutions/nopCommerce/commit/4b045ea39ea649cb531d98b3a3c086db874d5311&quot;&gt;commit记录&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;19年4月，列入&lt;a href=&quot;https://github.com/thangchung/awesome-dotnet-core&quot;&gt;awesome-dotnet-core&lt;/a&gt;(自己提pr过去的，有点小自恋。。)&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;在EasyCaching出来之前，大部分人应该会对&lt;a href=&quot;https://github.com/MichaCo/CacheManager&quot;&gt;CacheManager&lt;/a&gt;比较熟悉，因为两者的定位和功能都差不多，所以偶尔会听到有朋友拿这两个去对比。&lt;/p&gt;
&lt;p&gt;为了大家可以更好的进行对比，下面就重点介绍EasyCaching现有的功能了。&lt;/p&gt;
&lt;h2 id=&quot;easycaching的主要功能&quot;&gt;EasyCaching的主要功能&lt;/h2&gt;
&lt;p&gt;EasyCaching主要提供了下面的几个功能&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;统一的抽象缓存接口&lt;/li&gt;
&lt;li&gt;多种常用的缓存Provider(InMemory，Redis，Memcached，SQLite)&lt;/li&gt;
&lt;li&gt;为分布式缓存的数据序列化提供了多种选择&lt;/li&gt;
&lt;li&gt;二级缓存&lt;/li&gt;
&lt;li&gt;缓存的AOP操作(able, put，evict)&lt;/li&gt;
&lt;li&gt;多实例支持&lt;/li&gt;
&lt;li&gt;支持Diagnostics&lt;/li&gt;
&lt;li&gt;Redis的特殊Provider&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;当然除了这8个还有一些比较小的就不在这里列出来说明了。&lt;/p&gt;
&lt;p&gt;下面就分别来介绍一下上面的这8个功能。&lt;/p&gt;
&lt;h3 id=&quot;统一的抽象缓存接口&quot;&gt;统一的抽象缓存接口&lt;/h3&gt;
&lt;p&gt;缓存，本身也可以算作是一个数据源，也是包含了一堆CURD的操作，所以会有一个统一的抽象接口。面向接口编程，虽然EasyCaching提供了一些简单的实现，不一定能满足您的需要，但是呢，只要你愿意，完全可以一言不合就实现自己的provider。&lt;/p&gt;
&lt;p&gt;对于缓存操作，目前提供了下面几个，基本都会有同步和异步的操作。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;TrySet/TrySetAsync&lt;/li&gt;
&lt;li&gt;Set/SetAsync&lt;/li&gt;
&lt;li&gt;SetAll/SetAllAsync&lt;/li&gt;
&lt;li&gt;Get/GetAsync(with data retriever)&lt;/li&gt;
&lt;li&gt;Get/GetAsync(without data retriever)&lt;/li&gt;
&lt;li&gt;GetByPrefix/GetByPrefixAsync&lt;/li&gt;
&lt;li&gt;GetAll/GetAllAsync&lt;/li&gt;
&lt;li&gt;Remove/RemoveAsync&lt;/li&gt;
&lt;li&gt;RemoveByPrefix/RemoveByPrefixAsync&lt;/li&gt;
&lt;li&gt;RemoveAll/RemoveAllAsync&lt;/li&gt;
&lt;li&gt;Flush/FlushAsync&lt;/li&gt;
&lt;li&gt;GetCount&lt;/li&gt;
&lt;li&gt;GetExpiration/GetExpirationAsync&lt;/li&gt;
&lt;li&gt;&lt;del&gt;Refresh/RefreshAsync&lt;/del&gt;(这个后面会被废弃，直接用set就可以了)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;从名字的定义，应该就可以知道它们做了什么，这里就不继续展开了。&lt;/p&gt;
&lt;h3 id=&quot;多种常用的缓存provider&quot;&gt;多种常用的缓存Provider&lt;/h3&gt;
&lt;p&gt;我们会把这些provider分为两大类，一类是本地缓存，一类是分布式缓存。&lt;/p&gt;
&lt;p&gt;目前的实现有下面五个&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;本地缓存，InMemory，SQLite&lt;/li&gt;
&lt;li&gt;分布式缓存，StackExchange.Redis，csredis，EnyimMemcachedCore&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;它们的用法都是十分简单的。下面以InMemory这个Provider为例来说明。&lt;/p&gt;
&lt;p&gt;首先是通过nuget安装对应的包。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;dotnet add package EasyCaching.InMemory&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其次是添加配置&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;public void ConfigureServices(IServiceCollection services)
{
    // 添加EasyCaching
    services.AddEasyCaching(option =&amp;gt; 
    {
        // 使用InMemory最简单的配置
        option.UseInMemory(&quot;default&quot;);

        //// 使用InMemory自定义的配置
        //option.UseInMemory(options =&amp;gt; 
        //{
        //     // DBConfig这个是每种Provider的特有配置
        //     options.DBConfig = new InMemoryCachingOptions
        //     {
        //         // InMemory的过期扫描频率，默认值是60秒
        //         ExpirationScanFrequency = 60, 
        //         // InMemory的最大缓存数量, 默认值是10000
        //         SizeLimit = 100 
        //     };
        //     // 预防缓存在同一时间全部失效，可以为每个key的过期时间添加一个随机的秒数，默认值是120秒
        //     options.MaxRdSecond = 120;
        //     // 是否开启日志，默认值是false
        //     options.EnableLogging = false;
        //     // 互斥锁的存活时间, 默认值是5000毫秒
        //     options.LockMs = 5000;
        //     // 没有获取到互斥锁时的休眠时间，默认值是300毫秒
        //     options.SleepMs = 300;
        // }, &quot;m2&quot;);         
        
        //// 读取配置文件
        //option.UseInMemory(Configuration, &quot;m3&quot;);
    });    
}    

public void Configure(IApplicationBuilder app, IHostingEnvironment env, ILoggerFactory loggerFactory)
{
    // 如果使用的是Memcached或SQLite，还需要下面这个做一些初始化的操作
    app.UseEasyCaching();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配置文件的示例&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;&quot;easycaching&quot;: {
    &quot;inmemory&quot;: {
        &quot;MaxRdSecond&quot;: 120,
        &quot;EnableLogging&quot;: false,
        &quot;LockMs&quot;: 5000,
        &quot;SleepMs&quot;: 300,
        &quot;DBConfig&quot;:{
            &quot;SizeLimit&quot;: 10000,
            &quot;ExpirationScanFrequency&quot;: 60
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;关于配置，这里有必要说明一点，那就是&lt;code&gt;MaxRdSecond&lt;/code&gt;的值，因为这个把老猫子大哥坑了一次，所以要拎出来特别说一下，这个值的作用是预防在同一时刻出现大批量缓存同时失效，为每个key原有的过期时间上面加了一个随机的秒数，尽可能的分散它们的过期时间，如果您的应用场景不需要这个，可以将其设置为0。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最后的话就是使用了。&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;[Route(&quot;api/[controller]&quot;)]
public class ValuesController : Controller
{
    // 单个provider的时候可以直接用IEasyCachingProvider
    private readonly IEasyCachingProvider _provider;

    public ValuesController(IEasyCachingProvider provider)
    {
        this._provider = provider;
    }
    
    // GET api/values/sync
    [HttpGet]
    [Route(&quot;sync&quot;)]
    public string Get()
    {
        var res1 = _provider.Get(&quot;demo&quot;, () =&amp;gt; &quot;456&quot;, TimeSpan.FromMinutes(1));
        var res2 = _provider.Get&amp;lt;string&amp;gt;(&quot;demo&quot;);
        
        _provider.Set(&quot;demo&quot;, &quot;123&quot;, TimeSpan.FromMinutes(1));
        
        _provider.Remove(&quot;demo&quot;);
        
        // others..
        return &quot;sync&quot;;
    }
    
    // GET api/values/async
    [HttpGet]
    [Route(&quot;async&quot;)]
    public async Task&amp;lt;string&amp;gt; GetAsync(string str)
    {
        var res1 = await _provider.GetAsync(&quot;demo&quot;, async () =&amp;gt; await Task.FromResult(&quot;456&quot;), TimeSpan.FromMinutes(1));
        var res2 = await _provider.GetAsync&amp;lt;string&amp;gt;(&quot;demo&quot;);
    
        await _provider.SetAsync(&quot;demo&quot;, &quot;123&quot;, TimeSpan.FromMinutes(1));
        
        await _provider.RemoveAsync(&quot;demo&quot;);
        
        // others..
        return &quot;async&quot;;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;还有一个要注意的地方是，如果用的get方法是带有查询的，它在没有命中缓存的情况下去数据库查询前，会有一个加锁操作，避免一个key在同一时刻去查了n次数据库，这个锁的生存时间和休眠时间是由配置中的&lt;code&gt;LockMs&lt;/code&gt;和&lt;code&gt;SleepMs&lt;/code&gt;决定的。&lt;/p&gt;
&lt;h3 id=&quot;分布式缓存的序列化选择&quot;&gt;分布式缓存的序列化选择&lt;/h3&gt;
&lt;p&gt;对于分布式缓存的操作，我们不可避免的会遇到序列化的问题.&lt;/p&gt;
&lt;p&gt;目前这个主要是针对redis和memcached的。当然，对于序列化，都会有一个默认的实现是基于&lt;strong&gt;BinaryFormatter&lt;/strong&gt;，因为这个不依赖于第三方的类库，如果没有指定其它的，就会使用这个去进行序列化的操作了。&lt;/p&gt;
&lt;p&gt;除了这个默认的实现，还提供了三种额外的选择。Newtonsoft.Json，MessagePack和Protobuf。下面以在Redis的provider使用MessagePack为例，来看看它的用法。&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;services.AddEasyCaching(option=&amp;gt; 
{
    // 使用redis
    option.UseRedis(config =&amp;gt; 
    {
        config.DBConfig.Endpoints.Add(new ServerEndPoint(&quot;127.0.0.1&quot;, 6379));
    }, &quot;redis1&quot;)
    // 使用MessagePack替换BinaryFormatter
    .WithMessagePack()
    //// 使用Newtonsoft.Json替换BinaryFormatter
    //.WithJson()
    //// 使用Protobuf替换BinaryFormatter
    //.WithProtobuf()
    ;
}); &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不过这里需要注意的是，目前这些Serializer并不会跟着Provider走，意思就是不能说这个provider用messagepack，那个provider用json，只能有一种Serializer，可能这一个后面需要加强。&lt;/p&gt;
&lt;h3 id=&quot;多实例支持&quot;&gt;多实例支持&lt;/h3&gt;
&lt;p&gt;可能有人会问多实例是什么意思，这里的多实例主要是指，在同一个项目中，同时使用多个provider，包括多个同一类型的provider或着是不同类型的provider。&lt;/p&gt;
&lt;p&gt;这样说可能不太清晰，再来举一个虚构的小例子，可能大家就会更清晰了。&lt;/p&gt;
&lt;p&gt;现在我们的商品缓存在redis集群一中，用户信息在redis集群二中，商品评论缓存在mecached集群中，一些简单的配置信息在应用服务器的本地缓存中。&lt;/p&gt;
&lt;p&gt;在这种情况下，我们想简单的通过&lt;code&gt;IEasyCachingProvider&lt;/code&gt;来直接操作这么多不同的缓存，显然是没办法做到的！&lt;/p&gt;
&lt;p&gt;这个时候想同时操作这么多不同的缓存，就要借助&lt;code&gt;IEasyCachingProviderFactory&lt;/code&gt;来指定使用那个provider。&lt;/p&gt;
&lt;p&gt;这个工厂是通过provider的&lt;strong&gt;名字&lt;/strong&gt;来获取要使用的provider。&lt;/p&gt;
&lt;p&gt;下面来看个例子。&lt;/p&gt;
&lt;p&gt;我们先添加两个不同名字的InMemory缓存&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;services.AddEasyCaching(option =&amp;gt;
{
    // 指定当前provider的名字为m1
    option.UseInMemory(&quot;m1&quot;);
    
    // 指定当前provider的名字为m2
    config.UseInMemory(options =&amp;gt; 
    {
        options.DBConfig = new InMemoryCachingOptions
        {
            SizeLimit = 100 
        };
    }, &quot;m2&quot;);
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用的时候&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;[Route(&quot;api/[controller]&quot;)]  
public class ValuesController : Controller  
{  
    private readonly IEasyCachingProviderFactory _factory;  
  
    public ValuesController(IEasyCachingProviderFactory factory)  
    {  
        this._factory = factory;  
    }  
  
    // GET api/values
    [HttpGet]  
    [Route(&quot;&quot;)]  
    public string Get()  
    {  
        // 获取名字为m1的provider
        var provider_1 = _factory.GetCachingProvider(&quot;m1&quot;);  
        // 获取名字为m2的provider
        var provider_2 = _factory.GetCachingProvider(&quot;m2&quot;);
        
        // provider_1.xxx
        // provider_2.xxx
    
        return $&quot;multi instances&quot;;                 
    }  
}  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面这个例子中，provider_1和provider_2是不会互相干扰对方的，因为它们是不同的provider！&lt;/p&gt;
&lt;p&gt;直观感觉，有点类似区域(region)的概念，可以这样去理解，但是严格意义上它并不是区域。&lt;/p&gt;
&lt;h3 id=&quot;缓存的aop操作&quot;&gt;缓存的AOP操作&lt;/h3&gt;
&lt;p&gt;说起AOP，可能大家第一印象会是记录日志操作，把参数打一下，结果打一下。&lt;/p&gt;
&lt;p&gt;其实这个在缓存操作中同样有简化的作用。&lt;/p&gt;
&lt;p&gt;一般情况下，我们可能是这样操作缓存的。&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;public async Task&amp;lt;Product&amp;gt; GetProductAsync(int id)  
{  
    string cacheKey = $&quot;product:{id}&quot;;  
      
    var val = await _cache.GetAsync&amp;lt;Product&amp;gt;(cacheKey);  
      
    if(val.HasValue)  
        return val.Value;  
      
    var product = await _db.GetProductAsync(id);  
      
    if(product != null)  
        _cache.Set&amp;lt;Product&amp;gt;(cacheKey, product, expiration);  
          
    return val;  
}  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果使用缓存的地方很多，那么我们可能就会觉得烦锁。&lt;/p&gt;
&lt;p&gt;我们同样可以使用AOP来简化这一操作。&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;public interface IProductService 
{
    [EasyCachingAble(Expiration = 10)]
    Task&amp;lt;Product&amp;gt; GetProductAsync(int id);
}

public class ProductService : IProductService
{
    public Task&amp;lt;Product&amp;gt; GetProductAsync(int id)
    {
        return Task.FromResult(new Product { ... });   
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，我们只要在接口的定义上面加上一个Attribute标识一下就可以了。&lt;/p&gt;
&lt;p&gt;当然，只加Attribute，不加配置，它也是不会生效的。下面以&lt;code&gt;EasyCaching.Interceptor.AspectCore&lt;/code&gt;为例，添加相应的配置。&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;public IServiceProvider ConfigureServices(IServiceCollection services)
{
    services.AddScoped&amp;lt;IProductService, ProductService&amp;gt;();

    services.AddEasyCaching(options =&amp;gt;
    {
        options.UseInMemory(&quot;m1&quot;);
    });

    return services.ConfigureAspectCoreInterceptor(options =&amp;gt;
    {
        // 可以在这里指定你要用那个provider
        // 或者在Attribute上面指定
        options.CacheProviderName = &quot;m1&quot;;
    });
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这两步就可以让你在调用方法的时候优先取缓存，没有缓存的时候会去执行方法。&lt;/p&gt;
&lt;p&gt;下面再来说一下三个Attritebute的一些参数。&lt;/p&gt;
&lt;p&gt;首先是三个通用配置&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;CacheKeyPrefix&lt;/td&gt;
&lt;td&gt;指定生成缓存键的前缀，正常情况下是用在修改和删除的缓存上&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;CacheProviderName&lt;/td&gt;
&lt;td&gt;可以指定特殊的provider名字&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;IsHightAvailability&lt;/td&gt;
&lt;td&gt;缓存相关操作出现异常时，是否还能继续执行业务方法&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;EasyCachingAble和EasyCachingPut还有一个同名和配置。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Expiration&lt;/td&gt;
&lt;td&gt;key的过期时间，单位是秒&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;EasyCachingEvict有两个特殊的配置。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;IsAll&lt;/td&gt;
&lt;td&gt;这个要搭配CacheKeyPrefix来用，就是删除这个前缀的所有key&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;IsBefore&lt;/td&gt;
&lt;td&gt;在业务方法执行之前删除缓存还是执行之后&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;支持diagnostics&quot;&gt;支持Diagnostics&lt;/h3&gt;
&lt;p&gt;为了方便接入第三方的APM，提供了Diagnostics的支持，便于实现追踪。&lt;/p&gt;
&lt;p&gt;下图是我司接入Jaeger的一个案例。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/558945/201905/558945-20190503210152571-149441270.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;二级缓存&quot;&gt;二级缓存&lt;/h3&gt;
&lt;p&gt;二级缓存，多级缓存，其实在缓存的小世界中还算是一个比较重要的东西！&lt;/p&gt;
&lt;p&gt;一个最为头疼的问题就是不同级的缓存如何做到近似实时的同步。&lt;/p&gt;
&lt;p&gt;在EasyCaching中，二级缓存的实现逻辑大致就是下面的这张图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/558945/201905/558945-20190503210211709-594362089.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果某个服务器上面的本地缓存被修改了，就会通过缓存总线去通知其他服务器把对应的本地缓存&lt;strong&gt;移除掉&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;下面来看一个简单的使用例子。&lt;/p&gt;
&lt;p&gt;首先是添加nuget包。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;dotnet add package EasyCaching.InMemory
dotnet add package EasyCaching.Redis
dotnet add package EasyCaching.HybridCache
dotnet add package EasyCaching.Bus.Redis&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其次是添加配置。&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;services.AddEasyCaching(option =&amp;gt;
{
    // 添加两个基本的provider
    option.UseInMemory(&quot;m1&quot;);
    option.UseRedis(config =&amp;gt;
    {
        config.DBConfig.Endpoints.Add(new Core.Configurations.ServerEndPoint(&quot;127.0.0.1&quot;, 6379));
        config.DBConfig.Database = 5;
    }, &quot;myredis&quot;);

    //  使用hybird
    option.UseHybrid(config =&amp;gt;
    {
        config.EnableLogging = false;
        // 缓存总线的订阅主题
        config.TopicName = &quot;test_topic&quot;;
        // 本地缓存的名字
        config.LocalCacheProviderName = &quot;m1&quot;;
        // 分布式缓存的名字
        config.DistributedCacheProviderName = &quot;myredis&quot;;
    });

    // 使用redis作为缓存总线
    option.WithRedisBus(config =&amp;gt;
    {
        config.Endpoints.Add(new Core.Configurations.ServerEndPoint(&quot;127.0.0.1&quot;, 6379));
        config.Database = 6;
    });
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后就是使用了。&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;[Route(&quot;api/[controller]&quot;)]  
public class ValuesController : Controller  
{  
    private readonly IHybridCachingProvider _provider;  
  
    public ValuesController(IHybridCachingProvider provider)  
    {  
        this._provider = provider;  
    }  
  
    // GET api/values
    [HttpGet]  
    [Route(&quot;&quot;)]  
    public string Get()  
    {  
        _provider.Set(cacheKey, &quot;val&quot;, TimeSpan.FromSeconds(30));
    
        return $&quot;hybrid&quot;;                 
    }  
} &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果觉得不清楚，可以再看看这个完整的例子&lt;a href=&quot;https://github.com/catcherwong-archive/EasyCachingHybridDemo&quot;&gt;EasyCachingHybridDemo&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;redis的特殊provider&quot;&gt;Redis的特殊Provider&lt;/h3&gt;
&lt;p&gt;大家都知道redis支持多种数据结构，还有一些原子递增递减的操作等等。为了支持这些操作，EasyCaching提供了一个独立的接口，IRedisCachingProvider。&lt;/p&gt;
&lt;p&gt;这个接口，目前也只支持了百分之六七十常用的一些操作，还有一些可能用的少的就没加进去。&lt;/p&gt;
&lt;p&gt;同样的，这个接口也是支持多实例的，也可以通过&lt;code&gt;IEasyCachingProviderFactory&lt;/code&gt;来获取不同的provider实例。&lt;/p&gt;
&lt;p&gt;在注入的时候，不需要额外的操作，和添加Redis是一样的。不同的是，在使用的时候，不再是用&lt;code&gt;IEasyCachingProvider&lt;/code&gt;，而是要用&lt;code&gt;IRedisCachingProvider&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;下面是一个简单的使用例子。&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;[Route(&quot;api/mredis&quot;)]
public class MultiRedisController : Controller
{
    private readonly IRedisCachingProvider _redis1;
    private readonly IRedisCachingProvider _redis2;

    public MultiRedisController(IEasyCachingProviderFactory factory)
    {
        this._redis1 = factory.GetRedisProvider(&quot;redis1&quot;);
        this._redis2 = factory.GetRedisProvider(&quot;redis2&quot;);
    }

    // GET api/mredis
    [HttpGet]
    public string Get()
    {
        _redis1.StringSet(&quot;keyredis1&quot;, &quot;val&quot;);

        var res1 = _redis1.StringGet(&quot;keyredis1&quot;);
        var res2 = _redis2.StringGet(&quot;keyredis1&quot;);

        return $&quot;redis1 cached value: {res1}, redis2 cached value : {res2}&quot;;
    }             
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;除了这些基础功能，还有一些扩展性的功能，在这里要非常感谢&lt;a href=&quot;https://github.com/yrinleung&quot;&gt;yrinleung&lt;/a&gt;，他把EasyCaching和WebApiClient，CAP等项目结合起来了。感兴趣的可以看看这个项目&lt;a href=&quot;https://github.com/yrinleung/EasyCaching.Extensions&quot;&gt;EasyCaching.Extensions&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;写在最后&quot;&gt;写在最后&lt;/h2&gt;
&lt;p&gt;以上就是EasyCaching目前支持的一些功能特性，如果大家在使用的过程中有遇到问题的话，希望可以积极的反馈，帮助EasyCaching变得越来越好。&lt;/p&gt;
&lt;p&gt;如果您对这个项目有兴趣，可以在Github上点个Star，也可以加入我们一起进行开发和维护。&lt;/p&gt;
&lt;p&gt;前段时间开了一个&lt;a href=&quot;https://github.com/dotnetcore/EasyCaching/issues/108&quot;&gt;Issue&lt;/a&gt;用来记录正在使用EasyCaching的相关用户和案例，如果您正在使用EasyCaching，并且不介意透露您的相关信息，可以在这个Issue上面回复。&lt;/p&gt;
</description>
<pubDate>Sat, 04 May 2019 06:06:00 +0000</pubDate>
<dc:creator>Catcher8</dc:creator>
<og:description>简单介绍EasyCaching提供的一些功能特性</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/catcher1994/p/10806607.html</dc:identifier>
</item>
<item>
<title>春招两次腾讯面试都挂二面，分享下我失败+傻傻的面试经历 - 帅地</title>
<link>http://www.cnblogs.com/kubidemanong/p/10808107.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kubidemanong/p/10808107.html</guid>
<description>&lt;p&gt;这个春招估计也要介绍了吧，自己投的公司也不多吧，投简历的时候，如果你提前批和正常网申都投的话，可能会获得两次笔试/面试的机会，我投了两次腾讯，不过，两次都在二面挂了，特别是第二次二面，我真的决定自己太他妈傻了。作为一个新人，谈谈我面试过程中犯过的一些错吧，或许对你也有点收获。&lt;/p&gt;
&lt;h3 id=&quot;提前批笔试&quot;&gt;提前批笔试&lt;/h3&gt;
&lt;p&gt;腾讯提前批的面试应该是一个月前就开始的，我第一个投的公司就是腾讯了，人生的第一次笔试和面试也献给了腾讯。先说下笔试吧，笔试是 5 道编程题，个人觉得，腾讯的笔试题比较简单吧，也就是说，获得腾讯的面试机会应该算是不难的吧，5 道我好像是做出了 3道 + 一道90%测试用例通过 + 一道也是百分之几十来着的，忘了。&lt;/p&gt;
&lt;p&gt;最后的结论就是，个人感觉腾讯笔试不怎么难，投了之后获得面试的机会应该非常大，我的简历背景是没有任何亮点的，没有啥比赛，没拿过啥奖，非211/985，普普通通。这里建议秋招有兴趣的一定要投一下，万一面试也过了呢，好像我听说腾讯技术研发是 2轮技术 + 一轮HR面，万一2轮技术面过了拿offer机会还是挺大。&lt;/p&gt;
&lt;p&gt;当然，我听说前端的 HR 面是综合面，听说比比前面的两轮还难还难过。&lt;/p&gt;
&lt;h3 id=&quot;提前批一面&quot;&gt;提前批一面&lt;/h3&gt;
&lt;p&gt;一面是视频面，人生第一次面试，可以说我是很紧张的，一面我完全就是个小白啥套路也不懂，面试官问啥我答啥，完全不会引导，面试完后我感觉自己是真的傻，主要是问了一下问题：&lt;/p&gt;
&lt;p&gt;1、浏览器输入一个地址回车之后都发生了啥？&lt;/p&gt;
&lt;p&gt;这个可以说是非常高频的面试题了，我觉得自己这方面还可以，压抑自己的紧张，好好详细秀一波，然而，由于我事先并没有去准备过这个问题，而这个问题又涉及到很多步骤，所以我在逻辑上讲非非常非常不好，卡住了好几下，最后不管三七二十一，就说关键词了：有DNS转换啊，ip网络寻址啊，三次挥手啊，可能还有NAT地址转换啊，还有ARP啊。&lt;/p&gt;
&lt;p&gt;可能平时看我文章的人会发现，我是喜欢把这些技术一点点推出来，有逻辑着连起来的，这样说出来会特别舒服，不过我这次面试的时候，连不起来的，归根到底就是，&lt;strong&gt;没有准备&lt;/strong&gt;，头脑觉得自己都懂，但是不意味着讲的出来，所以我在这里是建议各位，对于那些高频的面试题，自己最后尝试着口头去表述一下，或者文字书写一下，要是你来回答，你会怎么说？&lt;/p&gt;
&lt;p&gt;2、TCP 和 UTP 有什么区别？&lt;/p&gt;
&lt;p&gt;我在回答这道题的时候，也是非常简单着回答他们的区别，例如一个面向连接一个非面向连接，一个可靠一个非可靠，非常简单就答完的。&lt;/p&gt;
&lt;p&gt;不过这道题是一个高频题目，按上面的那个回答，就算回答出来，我觉得也是一点优势都没有。因为这些简单的区别，99%的人都懂，我觉得我们应该再往深入回答，例如TCP有流量控制，拥塞控制，面向流以及基于这些区别，他们的使用场景等等。&lt;/p&gt;
&lt;p&gt;不过我并没有回答，不是我不知道，而是我想假装不说，等着他来问，因为我听说面试官都会一直往深问到你不会为止，然而现实是他并没有问，换话题了。感觉自己错过了一些表现的机会。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这里我想说的就是&lt;/strong&gt;：如果你知道，你可以多说一点，千万别像我这么傻，等着别人来问。&lt;/p&gt;
&lt;p&gt;3、写个快速排序&lt;/p&gt;
&lt;p&gt;和算法有关的，我觉得自己还好，写的虽然不是特别快，但感觉自己写的还好，无论是从代码的排版（因为这个一般都是在笔记本写的，不可能给你IDE），以及代码的简便程度，我觉得都不错，这里我想说的就是，自己平时写代码的时候，一定要注意排版，别老是依靠IDE给你一键排版。&lt;/p&gt;
&lt;p&gt;虽然我已经写出来了，不过他之后让我说下快速排序的步骤，我老实说了，不过我觉得，这些题都太简单，如果面试官的很基础，你也答的很基础，我觉得没啥优势，对于快速排序，我本来想补充的，例如对&lt;strong&gt;中轴&lt;/strong&gt;的选择问题，与其他排序算法的一些比较，应用场景等，不过，我是想着等他来问我......&lt;/p&gt;
&lt;p&gt;按照我这样写文章的话，估计得上万字，我下面简便说下就行了。如果你们感兴趣我这么啰嗦的话，下次我再来吐槽说说我回答的不够好的地方。&lt;/p&gt;
&lt;p&gt;4、一条SQL执行的很慢的原因？（之前写过文章，建议看看）&lt;/p&gt;
&lt;p&gt;5、MySQL有哪些存储引擎以及他们之间的区别（我其他引擎忘了名字叫啥）&lt;/p&gt;
&lt;p&gt;6、如何查看SQL语句的执行状态，知道这条命令吗？（我当时MySQL其实几乎没学，很多都不知道）&lt;/p&gt;
&lt;p&gt;7、qq用的是tcp还是udp（两种都有涉及）&lt;/p&gt;
&lt;p&gt;8、说说jvm内存模型（其实并没有JVM内存模型，只有Java内存模型以及JVM内存结构，你要问清楚是哪个再答）&lt;/p&gt;
&lt;p&gt;9、JVM内存结构中有栈堆等，为啥要用栈这种数据结构？（主要是操作简便，快速）&lt;/p&gt;
&lt;p&gt;10、说说垃圾回收？（老年代，新生代，永生代的区别等，各自使用的回收算法，新生代又分eden和survivor区等）&lt;/p&gt;
&lt;p&gt;11、说说aop和ioc&lt;/p&gt;
&lt;p&gt;12、大致看过哪些书？有逛技术论坛的习惯吗？说几个你常见的技术博客平台？有去逛过国外的技术博客吗？看的懂文档吗？&lt;/p&gt;
&lt;p&gt;总体上一面比较简单，面试官没有深入问，不过问的很广，这里问一些，那里问一下。感觉自己答的还好，也顺利过了。第一次面试收获还是挺大。&lt;/p&gt;
&lt;p&gt;1、对于懂的一定要多说，可以延伸，只要面试官不打断你的回答。&lt;/p&gt;
&lt;p&gt;2、对于高频面试题，一定要自己模拟说一下，而且这些题一般不难，一定要多延伸，不然没啥优势。&lt;/p&gt;
&lt;p&gt;3、感觉以后面试不那么紧张了，也就这么回事。&lt;/p&gt;
&lt;h3 id=&quot;提前提二面&quot;&gt;提前提二面&lt;/h3&gt;
&lt;p&gt;几天后收到复试通知，二面是电话面，二面操作系统和Linux问的有点多，我二面感觉自己就挂在Linux上，我Linux不大懂，被问了好几个个基础的问题都不懂，自己也是醉了，感觉自己应该和面试官说一下我Linux还没学😹。操作系统很多细节也忘了，说说二面的面试题吧。&lt;/p&gt;
&lt;p&gt;1、说下四次挥手，什么时候会出现time_wait状态？（我扯了一下，面试结束后，发现自己弄错了，真想给自己一巴掌，主要是，其实我对三次握手和四次挥手没去准备过，虽然看过挺多文章，但是具体的没记住，凉凉）&lt;/p&gt;
&lt;p&gt;2、红黑树知道吗？说说，为啥有了平衡树还需要红黑树？（平衡树太严格，插入很容易打破平衡，经常需要调整，而红黑树是一种折中方案......）&lt;/p&gt;
&lt;p&gt;3、红黑树是如何保证查找效率不会太低下的？（我后面再写一篇关于红黑树，B+树，平衡树这些的文章吧，现在先给出这些遇到过的面试题）&lt;/p&gt;
&lt;p&gt;4、红黑树在调整的时候，不是会用到左旋右旋吗？说说会不会出现无限左旋右旋的情况，如果不会，那最多旋转几次？&lt;/p&gt;
&lt;p&gt;5、为什么索引能加快查找效率？&lt;/p&gt;
&lt;p&gt;6、说说B+树是怎么分裂、合并的，知道具体步骤逻辑吗？&lt;/p&gt;
&lt;p&gt;7、你项目用到redis，知道跳跃表吗？说说他是怎么实现的，查找时间复杂度？&lt;/p&gt;
&lt;p&gt;数据结构这部分我觉得自己答的还行，几乎都答出来的，不过下面的Linux和操作系统有点惨，怪自己没准备，不过面试就是一个查漏补缺的过程吧。&lt;/p&gt;
&lt;p&gt;8、Linux的proc目录有啥用？（忘了，，，，）&lt;/p&gt;
&lt;p&gt;9、怎么查看端口的状态？（有条啥命令来着的，忘了）&lt;/p&gt;
&lt;p&gt;10、怎么查看某个进程的状态？（也忘了，呵呵，，，，，）&lt;/p&gt;
&lt;p&gt;我简历上是写着&lt;strong&gt;熟悉Linux常用命令&lt;/strong&gt;，然而一个也没答出来，尴尬啊，其实我会用的是那些 ls, cp, mkdir, tar等常用命令，对于线程、网络相关的都不会，感觉危险了，这么基础的问题都不会。&lt;/p&gt;
&lt;p&gt;11、说说什么是进程，进程包括哪些数据？进程切换的过程是怎么样的？&lt;/p&gt;
&lt;p&gt;12、如果想要让多个线程执行到某个点，都达到之后再继续执行，可以用java的那些类来实现？（CountDownLatch和CyclicBarrier这两个）&lt;/p&gt;
&lt;p&gt;13、什么是反射？反射有啥用？&lt;/p&gt;
&lt;p&gt;14、说说垃圾回收，jvm是如何知道这个对象可以回收的？计数法有啥问题？如果我们想要指定某种垃圾回收算法，该怎么设置？&lt;/p&gt;
&lt;p&gt;15说说aop（这个问的刁难了，我该说的都说），他说，那我也可以通过自己配置文件来实现这种切面啊，为啥就要用AOP呢？（他问的问题就相当于，我用servlet也能使用实现一个网站啊，为啥要用spring这些框架呢？我当时应该要吹一波spring中AOP带来的好处的，不过我没说，感觉自己应该吹一下的）&lt;/p&gt;
&lt;p&gt;15、接着是问了我那个&lt;strong&gt;高并发秒杀系统的项目&lt;/strong&gt;，说了里面的线程安全问题，然后我这个项目早忘光了，自己也没准备，代码我不是自己敲的，直接看视频的。自己没做过什么项目，就充当了，结果面试官问了一下线程的问题，我一直没get到点，搞的自己也好懵，最后才知道他说的是啥，不过项目这块答的也不好，主要自己也没动手弄过，又是去年快速看视频学的。&lt;/p&gt;
&lt;p&gt;总体上，二面除了Linux答的非常非常不好，还有四次挥手说错了，线程包括哪些数据说的也不全之外，以及项目感觉有点被认识不是我做的之后，其它感觉还好。不过。一个多星期后，结果出来，挂了。&lt;/p&gt;
&lt;p&gt;不过我也不意外，知道自己有很多需要补的，面试有时运气不好，可能连续问到好几个不好的，估计就得挂了，不过这没方法，最好的做法就是面试过后把自己不足的补上来。&lt;/p&gt;
&lt;h3 id=&quot;常规网申一面&quot;&gt;常规网申一面&lt;/h3&gt;
&lt;p&gt;常规网申的笔试题中是&lt;strong&gt;20道选择题+3道编程题&lt;/strong&gt;，过几天就收到面试通知了，有了前面两次之后的面试经验之后，也了解到腾讯是特别喜欢问&lt;strong&gt;操作系统+计算机网络+Linux&lt;/strong&gt;的，于是我把这方面的高频面试题都好好准备了，Linux 进程等相关都准备了，操作系统也大致准备了，下面说说这次涉及到的面试题。&lt;/p&gt;
&lt;p&gt;1、说说网络建立连接之后是怎么关闭的（其实就是四次挥手，我详细说了，之前写过文章）。如果出现大量time_wait 状态的连接是怎么回事？（我说了第四次挥手出现了丢包、超时等），假如不会出现丢包、超时等，网络非常流畅呢？（说了短连接导致的）那怎么解决？（我说了限制最大连接，用队列来缓冲），问我还有其他方法吗？（我不大知道，好像面试官不大满意我的回答。不过最好的做法应该是修改 time_wait 等待的最大之间，把时间改小一点）。&lt;/p&gt;
&lt;p&gt;2、说说IO阻塞与非阻塞是什么？各自有啥好处？知道多路复用吗？了解过 select 吗？说说他与 epoll 的区别。&lt;/p&gt;
&lt;p&gt;我知道的也不是很深入，就常规答法，他问啥就答啥。这里我要说一下，我觉得很多人可能&lt;strong&gt;混淆了阻塞、非阻塞与异步、同步的概念&lt;/strong&gt;。我实话，我觉得自己已经理解了，结果我看了好几篇文章，发现自己反而不懂了，懵了，总觉得缺了点什么影响我对阻塞非阻塞与异步同步的理解，说实话，我看了大概有10篇文章，有80%我觉得都没有说清楚阻塞非阻塞与异步同步的本质区别。这会影响你对同步阻塞，同步非阻塞，异步阻塞，异步非阻塞的理解。有时间我再来写一篇文章说说他们的区别，相信看了你就一定懂了。&lt;/p&gt;
&lt;p&gt;3、知道乐观锁吗？说说他们适合应用的情景。&lt;/p&gt;
&lt;p&gt;4、说说自适应锁，与其他锁相比，他的优缺点，什么情况下你觉得可以用自适应锁？（之前写过几种锁的文章，不懂的建议看）&lt;/p&gt;
&lt;p&gt;5、你平时开发是在Linux上开发的吗？（我靠，Linux上开发？？那不是得对Linux上很熟悉？我虽然准备了Linux面试相关，可是这Linux上开发压根没体验过啊，我马上怂了，马上说没有，并且还加了我对Linux不熟，这门课刚学没几天。之后他就不问了Linux了，然后接下来我就扎心了）&lt;/p&gt;
&lt;p&gt;6、那你平时就是在windows下开发了，那如果你平时项目要上线，这个项目的性能突然很差，你是怎么定位问题的？（我靠，在下从来没有上线过项目，连用心写过项目都没有，这下完，我迟疑了一会），他补充说，例如你可以通过观察你电脑的&lt;strong&gt;cup, 内存，IO 的指标&lt;/strong&gt;来进行行定位，可以分析下吗？（可以打开任务管理器来查看cup等的运行情况，然后.....其实我没有上线过项目，也没有这样的经历），他说没事，假如遇到这种情况你会怎么分析？（我下面说一下我是怎么扯的）&lt;/p&gt;
&lt;p&gt;心想，扎心了，其实我不大知道究竟要分析啥，好吧不管三七二十一了，然后我开始扯了：&lt;/p&gt;
&lt;p&gt;1、如果cup一直很高而其他地方内存，IO很低的话，那很有可能项目里面有某些东西在疯狂运行，但却没啥用，很有可能就是自己设计了乐观锁，但竞争的线程太多，导致一直做无用功。&lt;/p&gt;
&lt;p&gt;2、如果磁盘操作很高，但cup很低，这是意味着项目一直在做IO操作，很有可能是SQL语句写的不好，导致扫描了大量的磁盘，然后我就针对SQL语句的问题开始扯了，例如没有用上索引啊，选错索引啊，扯了一大堆，哈哈。（心想，舒服，刚好写过sql语句执行的很慢的原因有哪些）。&lt;/p&gt;
&lt;p&gt;7、说说进程与线程的区别？进程有哪些通信方式，（我说了共享内存，消息队列，管道，信号量，套接字，信号驱动），他问还有吗？（我说其他的不知道了），描述下这些具体的通信方式（我有些具体的给忘了，大致描述了几个）&lt;/p&gt;
&lt;p&gt;8、说说快速排序的思想，删除单链表倒数第二个节点，你会怎么做？&lt;/p&gt;
&lt;p&gt;9、了解MySQL事务吗？说说ACID是啥（我靠，我对事务的隔离理解还强，研究过隔离是如何实现的，然而，，，我突然短路，ACID的D忘了啥，就像你高中那会对一首古诗背的很熟，然后突然就忘了哪句，心里有点扎心），那你具体说说ACID是啥（原子性是，，，隔离性是，，，，一致性？？？？？，我靠，我觉得自己对这四大特性很理解，感觉看名字就知道是啥了，然后说到一致性的时候，我自己的心中产生了疑问，感觉自己并没有真正意义上理解了一致性，然后我没说出来）&lt;/p&gt;
&lt;p&gt;心中那个苦，一致性都没说出来，其实我是可以说出来的，但是我总觉得缺了点什么，&lt;strong&gt;就像你看了几篇文章觉得自己懂了，结果让你在看几篇文章，你感觉自己有点醒悟了，然后突然发现自己并没有真正意义上的懂&lt;/strong&gt;，我查了好多篇文章，呵呵，千篇一律，都不能解答我的疑惑，说实话，别觉得自己懂了，其实你根本就没有懂，最后是懵逼了好久，才觉得自己应该是懂了，有时间也要写一篇事务的四大特性的文章。&lt;/p&gt;
&lt;p&gt;说实话，网上的很多文章，真的是千篇一律，当你产生了疑惑，很难找到解答，因为你会发现，这几篇说的都是一样的，那个你感觉&lt;strong&gt;特别重要的疑惑&lt;/strong&gt;都没有说到。好吧，不吐槽了，等下要被大佬门怼我写的文章了。&lt;/p&gt;
&lt;p&gt;一面大致说了这么多，有些忘了。比起提前批一面，我觉得自己在表述上好多了，也会扯了，这里我想跟大家说的就是，问题就那些，一定要搞懂，延伸，要理解，该背的要背，例如进程有哪些通信方式。如果要面试腾讯的时候，计算机网络、操作系统，Linux这些底层的，要学好，尽管你是面试 java 岗位的，可能他一个 Java 的问题都不问的。&lt;/p&gt;
&lt;h3 id=&quot;想杀了自己的二面&quot;&gt;想杀了自己的二面&lt;/h3&gt;
&lt;p&gt;二面我应该就是个傻逼吧，自己给自己挖坑了，最近这些题一直在刷题，复习基础，对于数据结构，算法题，Java，操作系统什么的，自己也想看看有哪些不足，然后他一开始就叫我介绍项目。&lt;/p&gt;
&lt;p&gt;1、说说你做的项目。&lt;/p&gt;
&lt;p&gt;其实这期间我为了应付以后的面试弄过做过一个项目，不过还没弄好。然后我之前不是说了自己有个很水的高并发秒杀系统项目吗？我自己也没啥项目经验，然后我觉得&lt;strong&gt;高并发&lt;/strong&gt;也是很牛逼的样子，就打算用它了，简历上也写了。不过这个项目我自己没实操过，看视频的，很短，几个小时而已，用到了redis等，不过我已经准备了很多redis相关的知识了，怎么优化的也准备好了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;现实是，呵呵，我被怼的体无完肤&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;优化之一就是通过&lt;strong&gt;减少事务持有锁的时间&lt;/strong&gt;来优化的，例如我们秒杀一个物品的话，如果减库存和插入订单两个操作都成功的话，代表秒杀成功，这两个操作会在一个事务里完成。问题来了，是先减库存呢？还是先插入订单呢？&lt;/p&gt;
&lt;p&gt;我说了先插入订单在减库存能够减少事务锁的持有时间，然后我就被面试官怼死了，如下：&lt;/p&gt;
&lt;p&gt;面试官：你觉得你这个优化有用吗？&lt;/p&gt;
&lt;p&gt;我：有啊，可以减少锁的持有时间（确实可以减少锁的持有时间）&lt;/p&gt;
&lt;p&gt;面试官：那你说说提高了多少并发量？&lt;/p&gt;
&lt;p&gt;我：这个，，没测试过（我是看视频的，自己也没有这样的测试工具，有点尴尬，连测试过都没有？？）&lt;/p&gt;
&lt;p&gt;面试官：那你说说这条事务执行需要多少时间&lt;/p&gt;
&lt;p&gt;我：我，，好像忘了具体数据，大概是0.00几秒吧。&lt;/p&gt;
&lt;p&gt;面试官：你自己都说0.00几秒了，这么短时间，你觉得你的这个优化，用处大吗？有数据来支撑下吗？&lt;/p&gt;
&lt;p&gt;我：,,,,，（真的自己给自己挖坑了，早知道随便介绍下就好了，不主动说自己的优化了过程了，毕竟自己没实操过）&lt;/p&gt;
&lt;p&gt;面试官：你这个系统能扛多少并发量？&lt;/p&gt;
&lt;p&gt;我：...没测试过（我觉得，面试官觉得这个项目是假的了，可能觉得我是从网上随便找的，然后来应付面试的，我觉得自己凉了，&lt;strong&gt;欺骗&lt;/strong&gt;可是非常严重的）。&lt;/p&gt;
&lt;p&gt;面试官：那你说说，完成一条请求用了多少时间（测试最大的并发量可能需要相应的工具，他可能为了再次确认我的真伪，故意是一条请求的？这样就不需要工具了）&lt;/p&gt;
&lt;p&gt;我：.....没测试过（好吧，我的心已凉）&lt;/p&gt;
&lt;p&gt;面试官：好吧，就说到这里，你用过lowJS吗？&lt;/p&gt;
&lt;p&gt;我：啊？？lowJS，什么鬼东西？而且他的声音有点小，我再次确认，是指lowJS吗？他说是，我说没听说过（后来才知道，他说的是Node.js，，，，，，麻痹，，，）。&lt;/p&gt;
&lt;p&gt;面试官：你还有啥问题要问的？&lt;/p&gt;
&lt;p&gt;呵呵，，，已经凉了，这次面试真的是自己给自己挖坑，面试官肯定是知道我项目是伪造的，这是非常严重的事情，然后这个面试大概是持续了10几分钟，其他的面试官的也没问了。想找给人吐槽下自己。&lt;/p&gt;
&lt;p&gt;然后，明天就查到挂的信息了，之前二面是一个星期多才查到挂了，这次是十二个小时之后就收到挂了，我也知道10000%挂的了。此刻需要一波安慰！！&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;总结就是一首凉凉送给自己，还有就是有一些建议，当然，这也是我自己给自己的建义。&lt;/p&gt;
&lt;p&gt;1、高频面试题，别停留于表面，大家都懂，说的很表面没啥优势。&lt;/p&gt;
&lt;p&gt;2、别以为自己懂了，如果可以，最好自己尝试描述一下，你可能会描述的很没有逻辑。&lt;/p&gt;
&lt;p&gt;3、好好准备一个项目吧，一定要自己脚踏实地做一下， 别像我，被怼的体无完肤。&lt;/p&gt;
&lt;p&gt;4、框架真的问的很少，好好打基础，数据结构与算法，计算机网络，操作系统，Linux 进程等相关的命令。&lt;/p&gt;
&lt;p&gt;5、面试的第一关是笔试，一般都是编程题，建议要刷刷题，不然面试的机会都没有。&lt;/p&gt;
&lt;p&gt;先写到这里了，后面会写一下面试相关的题，建议最后看，虽然你看过相关文章了，但看我的，可能你也能够有新的收获！还有就是祝各位大佬面试顺序，不好的运气我来帮你们包揽就行了（留下了委屈的眼泪）&lt;/p&gt;
&lt;p&gt;最后推荐下我的公众号：苦逼的码农，主要分享一下技术文章、面试题、算法题，各种工具、视频资源等，里面已有100多篇原创文章，期待各路英雄来交流。(欢迎扫右上角的二维码关注哦)&lt;/p&gt;
</description>
<pubDate>Sat, 04 May 2019 04:16:00 +0000</pubDate>
<dc:creator>帅地</dc:creator>
<og:description>这个春招估计也要介绍了吧，自己投的公司也不多吧，投简历的时候，如果你提前批和正常网申都投的话，可能会获得两次笔试/面试的机会，我投了两次腾讯，不过，两次都在二面挂了，特别是第二次二面，我真的决定自己太</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kubidemanong/p/10808107.html</dc:identifier>
</item>
<item>
<title>大白话5分钟带你走进人工智能 - 第二十一节 牛顿法和L-BFGS求函数最优解 - LHBlog</title>
<link>http://www.cnblogs.com/LHWorldBlog/p/10807354.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/LHWorldBlog/p/10807354.html</guid>
<description>&lt;p&gt;&lt;span&gt;                                                              &lt;strong&gt;   第二十一节 牛顿法和L-BFGS求函数最优解&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这一节中，我们讲解一个新的求函数最优化的方法就是L-BFGS。以下是本节目录。&lt;/span&gt;&lt;/p&gt;
&lt;p id=&quot;main-toc&quot;&gt;&lt;span&gt;&lt;strong&gt;           目录&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p id=&quot;1-L-BFGS%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B-toc&quot;&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/LHWorldBlog/p/10807354.html#1-L-BFGS算法简介&quot; data-cke-saved-href=&quot;#1-L-BFGS%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B&quot;&gt;1-L-BFGS算法简介&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p id=&quot;2-%E7%89%9B%E9%A1%BF%E6%B3%95%E6%B1%82%E6%A0%B9%E9%97%AE%E9%A2%98-toc&quot;&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/LHWorldBlog/p/10807354.html#2-牛顿法求根问题&quot; data-cke-saved-href=&quot;#2-%E7%89%9B%E9%A1%BF%E6%B3%95%E6%B1%82%E6%A0%B9%E9%97%AE%E9%A2%98&quot;&gt;2-牛顿法求根问题&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p id=&quot;3-%E7%89%9B%E9%A1%BF%E6%B3%95%E6%B1%82%E9%A9%BB%E7%82%B9%E9%97%AE%E9%A2%98-toc&quot;&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/LHWorldBlog/p/10807354.html#3-牛顿法求驻点问题&quot; data-cke-saved-href=&quot;#3-%E7%89%9B%E9%A1%BF%E6%B3%95%E6%B1%82%E9%A9%BB%E7%82%B9%E9%97%AE%E9%A2%98&quot;&gt;3-牛顿法求驻点问题&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p id=&quot;4-%E7%89%9B%E9%A1%BF%E6%B3%95%E6%B1%82%E9%A9%BB%E7%82%B9%E7%9A%84%E6%9C%AC%E8%B4%A8-toc&quot;&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/LHWorldBlog/p/10807354.html#4-牛顿法求驻点的本质&quot; data-cke-saved-href=&quot;#4-%E7%89%9B%E9%A1%BF%E6%B3%95%E6%B1%82%E9%A9%BB%E7%82%B9%E7%9A%84%E6%9C%AC%E8%B4%A8&quot;&gt;4-牛顿法求驻点的本质&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p id=&quot;5-%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E5%88%A9%E7%94%A8%E7%89%9B%E9%A1%BF%E6%B3%95%E6%B1%82%E9%A9%BB%E7%82%B9%C2%A0%C2%A0-toc&quot;&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/LHWorldBlog/p/10807354.html#5-多元函数利用牛顿法求驻点  &quot; data-cke-saved-href=&quot;#5-%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E5%88%A9%E7%94%A8%E7%89%9B%E9%A1%BF%E6%B3%95%E6%B1%82%E9%A9%BB%E7%82%B9%C2%A0%C2%A0&quot;&gt;5-多元函数利用牛顿法求驻点  &lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p id=&quot;%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%207-L-BFGS%E7%AE%97%E6%B3%95-toc&quot;&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/LHWorldBlog/p/10807354.html#6-BFGS算法&quot; data-cke-saved-href=&quot;#6-BFGS%E7%AE%97%E6%B3%95&quot;&gt;6-BFGS算法&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/LHWorldBlog/p/10807354.html#     %207-L-BFGS算法&quot; data-cke-saved-href=&quot;#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%207-L-BFGS%E7%AE%97%E6%B3%95&quot;&gt;7-L-BFGS算法&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr id=&quot;hr-toc&quot;/&gt;&lt;h3 id=&quot;1-L-BFGS%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B&quot;&gt;&lt;span&gt;&lt;strong&gt;1-L-BFGS算法简介&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;我们知道算法在计算机中运行的时候是需要很大的内存空间的.就像我们解决函数最优化问题常用的梯度下降,它背后的原理就是依据了泰勒一次展开式.泰勒展开式展开的次数越多,结果越精确,没有使用三阶四阶或者更高阶展开式的原因就是目前硬件内存不足以存储计算过程中演变出来更复杂体积更庞大的矩阵.L-BFGS算法翻译过来就是有限内存中进行BFGS算法,L是limited memory的意思.那算法为什么叫BFGS呢,请看下图:&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;上图中从左到右依次是Broyden,Fletcher,Goldfarb,Shanno.四位数学家名字的首字母是BFGS,所以算法的名字就叫做BFGS算法.接下来我们就一起来学习BFGS算法的内容。&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;2-%E7%89%9B%E9%A1%BF%E6%B3%95%E6%B1%82%E6%A0%B9%E9%97%AE%E9%A2%98&quot;&gt;&lt;span&gt;&lt;strong&gt;2-牛顿法求根问题&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;我们先来回顾下&lt;strong&gt;牛顿法求根问题&lt;/strong&gt;，比如求1元2次方程的根公式为&lt;img class=&quot;mathcode&quot; src=&quot;https://private.codecogs.com/gif.latex?x%3D%5Cfrac%7B-b%20%5Cpm%20%5Csqrt%7Bb%5E%7B2%7D-4%20a%20c%7D%7D%7B2%20a%7D&quot; alt=&quot;x=\frac{-b \pm \sqrt{b^{2}-4 a c}}{2 a}&quot; data-cke-saved-src=&quot;https://private.codecogs.com/gif.latex?x%3D%5Cfrac%7B-b%20%5Cpm%20%5Csqrt%7Bb%5E%7B2%7D-4%20a%20c%7D%7D%7B2%20a%7D&quot; data-cke-widget-data=&quot;{}&quot; data-cke-widget-upcasted=&quot;1&quot;/&gt;，我们通常管这种形式的根叫解析根。所谓解析解就是你不用给我具体的值，就是一个公式。3次方程也是有解析解的，但是当函数达到5次方以上，就不好找解析解了，对于这种复杂的函数，很遗憾我们不能找到它的全部根，但是至少有办法找到它的一个根。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们看一个对于&lt;strong&gt;一元函数的例子&lt;/strong&gt;：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;对于一个无法解出解析解的函数来说，现在是一元函数，在只有一个x的情况下，我最终想找到&lt;strong&gt;x令y=0，即函数的根&lt;/strong&gt;，怎么找到它？牛顿和另外一个人同时分别发现，假如这个函数是连续可导的，我随机出来一个x1，总能求它在这点x1的导数，导数是一个实数，它是能代表切线的斜率，那么我们就在这个x1点上画一个原函数切线，这个切线一定会与x轴相交，除非特别倒霉，你一步就随机到它的驻点上了，也不用求了，你找的就是驻点。不倒霉的情况下一定会使x1点的切线和x轴有个交点，我们命名为x2。 点完之后，又可以找一下x2对应在函数上的点，再画一条切线找到了x3，这时候相比x1，距离跟的位置来说比较近，然后发现经过有限次数的迭代之后，怎么迭代都不会变化。它还是会产生震荡，经过震荡之后，最终会收敛在某一个点上，而这个点就是函数的根。所以说&lt;strong&gt;牛顿法利用几何直觉就是在找到某一个函数与x轴的交点。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们分析下几何原理：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;函数本身f(x)也是已知的，那么f(x1)就可以计算。x2是x1切线的位置，我们建立一个关于x2，x1的解析式，三角形这条边是x1-x2，另外一条边是f(x1)，如果用f(x1)/ x1-x2就应该是这条线的斜率，斜率又等于x1这点导数的值。所以x2，x1建立一个关系，x2 = x1-f(x1)/ f`(x1)，此时x2就可求了。我们大的思路想从x1找到x2，从x2找到x3，最终找着发现xn，xn+1它俩没区别的时候xn就是函数的根。因此建立了一个&lt;strong&gt;xn，xn-1的之间关系的迭代公式：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;                                                                    xn=xn-1- f(xn-1)/ f`(xn-1)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们在求数值解的时候，虽然我们求根法是求损失函数最小值，当最小值只差一点点的时候，对模型的预测结果影响不大，但是它在底部会震荡很久。 &lt;strong&gt;对于这种在底部频繁震荡的情况下，通常会设置超参tolerance&lt;/strong&gt;，当xk，xk+1的变化已经小于你设的阈值的时候，我就认为它已经收敛了，而不去非得接近它，驻点数本身就是不那么可控的。设置超参tolerance，它几乎在不牺牲精度的情况下来对我们这个函数最优化算法进行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;总结下牛顿法求根的流程：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;.1、已知函数f(x)的情况下随机产生x0。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 2、由已知的x0按照&lt;strong&gt;   xn=xn-1- f(xn-1)/ f`(xn-1)公式进行n次迭代。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; 3、当迭代结果xn与上一次迭代结果xn-1&lt;/strong&gt;相同或小于一定阈值时，本次的结果即为函数f(x)的根。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;3-%E7%89%9B%E9%A1%BF%E6%B3%95%E6%B1%82%E9%A9%BB%E7%82%B9%E9%97%AE%E9%A2%98&quot;&gt;&lt;span&gt;&lt;strong&gt;3-牛顿法求驻点问题&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;既然利用&lt;strong&gt;上述办法找到任意函数的根，能不能借这个找到函数最小值呢&lt;/strong&gt;？我们可以利用驻点的知识，&lt;strong&gt;虽然驻点不一定是极值点，极值点也不一定是驻点，但大部分情况下两个值相等，驻点也就是导数为零的点，即原函数最小值的点。&lt;/strong&gt; 所以我们需要找到导函数为零的点，实际上也就是导函数的根。导函数是一个函数，它是用来计算一个函数导数的工具，给我一个x，我就算这个原函数在这个点的导数是多少的这么一个函数。如果我们能把原函数的导函数写出来，进而求导函数的根，就解决了求原函数最小值的问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;既然都是求根问题，我们可不可以利用上面的方法呢？肯定是可以的，&lt;strong&gt;只不过现在的函数是我们要求的导函数而已&lt;/strong&gt;。我们看下刚才原函数&lt;strong&gt;求根的迭代公式：xn+1 = xn-f(xn)/ f`(xn)&lt;/strong&gt;。对于导函数来说，唯一的区别就是f(xn)表达式不同，所以我们此时的原函数就是f`(xn)，此时f`(xn)的导函数就是f``(xn)。最终的迭代公式就是：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;                                                                   xk = xk-1-f'(xk-1)/ f''( xk-1&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通过这个东西，我最终找到xn不再是f(x)的根，而是f(x)导数的根，也就是驻点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;          总结下&lt;span&gt;利用牛顿法求函数的驻点过程：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;               1、当函数&lt;span&gt;f(x&lt;span&gt;) &lt;span&gt;的一阶导数 &lt;span&gt;f’(x&lt;span&gt;) = &lt;span&gt;0 &lt;span&gt;时点&lt;span&gt;(x,f(x))&lt;span&gt;为函数&lt;span&gt;f(x)&lt;span&gt;的驻点&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;               2、求某函数的驻点即为求该函数的导函数的根&lt;span&gt;,&lt;span&gt;同样可以利用牛顿法进行求解&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;               3、对于&lt;span&gt;f(x) &lt;span&gt;函数来说 迭代公式为 &lt;span&gt;xk&lt;span&gt; = &lt;span&gt;xk-1&lt;span&gt; - &lt;span&gt;f’(xk-1)/f’’(xk-1)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;4-%E7%89%9B%E9%A1%BF%E6%B3%95%E6%B1%82%E9%A9%BB%E7%82%B9%E7%9A%84%E6%9C%AC%E8%B4%A8&quot;&gt;&lt;span&gt;&lt;strong&gt;4-牛顿法求驻点的本质&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;牛顿法求驻点本质实际上是二阶泰勒展开公式&lt;/strong&gt;。我们先来回顾下什么是泰勒展开。&lt;strong&gt;所谓泰勒展开就是把任意一个复杂函数在某个点附近，用一个有限长度的多项式来拟合&lt;/strong&gt;，那么通常多项式在xk点附近展开是φ（x）=f(x)+ f’(x-xk)+ 1/2！f''(xk)*(x-xk)^2+1/3！f'''(xk)(x-xn)^3...，一直往上加，越加越像原函数。 我们看下一阶展开就是φ（x）=f(x)+ f’(x-xk)。它本质就是y=ax+b，一条直线，只不过a和b里面杂糅了很多关于xk函数的数值，a和b是通过xk这个点的函数还有一阶导函数算出来的，所以一阶泰勒展开就是在xk附近用一条直线尽量的去拟合原函数。什么叫做xk尽量的去拟合原函数？意思是在xk点附近，我不关注其它地方，我就在你周围画一条直线，你能跟我原先xk点的附近重合的越多越好。而二阶泰勒展开式是ax2+bx+c，只不过a，b，c是通过这些导数什么杂糅在一起算出来，无论这些东西等于多少，它始终是一个实数，它一定就是这个形势，这个形式是一个抛物线。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们看下&lt;span&gt;任意函数在 &lt;span&gt;xk&lt;span&gt;点附近的二阶泰勒展开公&lt;span&gt;式为：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                                           &lt;img class=&quot;mathcode&quot; src=&quot;https://private.codecogs.com/gif.latex?%5Cvarphi%28x%29%3Df%5Cleft%28x_%7Bk%7D%5Cright%29&amp;amp;plus;f%5E%7B%5Cprime%7D%5Cleft%28x_%7Bk%7D%5Cright%29%5Cleft%28x-x_%7Bk%7D%5Cright%29&amp;amp;plus;%5Cfrac%7B1%7D%7B2%7D%20f%5E%7B%5Cprime%20%5Cprime%7D%5Cleft%28x_%7Bk%7D%5Cright%29%5Cleft%28x-x_%7Bk%7D%5Cright%29%5E%7B2%7D&quot; alt=&quot;\varphi(x)=f\left(x_{k}\right)+f^{\prime}\left(x_{k}\right)\left(x-x_{k}\right)+\frac{1}{2} f^{\prime \prime}\left(x_{k}\right)\left(x-x_{k}\right)^{2}&quot; data-cke-saved-src=&quot;https://private.codecogs.com/gif.latex?%5Cvarphi%28x%29%3Df%5Cleft%28x_%7Bk%7D%5Cright%29&amp;amp;plus;f%5E%7B%5Cprime%7D%5Cleft%28x_%7Bk%7D%5Cright%29%5Cleft%28x-x_%7Bk%7D%5Cright%29&amp;amp;plus;%5Cfrac%7B1%7D%7B2%7D%20f%5E%7B%5Cprime%20%5Cprime%7D%5Cleft%28x_%7Bk%7D%5Cright%29%5Cleft%28x-x_%7Bk%7D%5Cright%29%5E%7B2%7D&quot; data-cke-widget-data=&quot;{}&quot; data-cke-widget-upcasted=&quot;1&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;该公式表达的函数φ（x） &lt;span&gt;的几何意义为&lt;span&gt;：&lt;span&gt;通过2次函数对于原函数的最佳拟合。当φ'（x）=0时：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                                                        &lt;img class=&quot;mathcode&quot; src=&quot;https://private.codecogs.com/gif.latex?%24f%5E%7B%5Cprime%7D%5Cleft%28x_%7Bk%7D%5Cright%29&amp;amp;plus;f%5E%7B%5Cprime%20%5Cprime%7D%5Cleft%28x_%7Bk%7D%5Cright%29%5Cleft%28x-x_%7Bk%7D%5Cright%29%3D0%24&quot; alt=&quot;$f^{\prime}\left(x_{k}\right)+f^{\prime \prime}\left(x_{k}\right)\left(x-x_{k}\right)=0$&quot; data-cke-saved-src=&quot;https://private.codecogs.com/gif.latex?%24f%5E%7B%5Cprime%7D%5Cleft%28x_%7Bk%7D%5Cright%29&amp;amp;plus;f%5E%7B%5Cprime%20%5Cprime%7D%5Cleft%28x_%7Bk%7D%5Cright%29%5Cleft%28x-x_%7Bk%7D%5Cright%29%3D0%24&quot; data-cke-widget-data=&quot;{}&quot; data-cke-widget-upcasted=&quot;1&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;解释下这个公式怎么来的：对x求导，没有对xk求导的，xk是个已知数，第一项f(xk)没有x，求导等于0。第二项对x的求导，把它展开变成x*f’（xk）就剩这么一个东西，f’（xk）它是个数，它不是x函数。第三项对x求导结果是1/2 f''(xk).2(x-xk) 。综合以上结果就得到φ'（x）=0的解析式，也就是函数二阶泰勒展开所拟合出来的抛物线的最小值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;把上述φ'（x）=0的解析式展开成x= xk -f’(xk)/f’’(xk)。发现刚好和之前牛顿法求驻点&lt;span&gt;xk&lt;span&gt; = &lt;span&gt;xk-1&lt;span&gt; - &lt;span&gt;f’(xk-1)/f’’(xk-1)的迭代公式一致。所以下一次xxk的迭代值就是以它拟合出来的抛物线的最小值对应的x来作为我原函数根的下一次迭代值。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们画图示意牛顿法求驻点的本质：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;因为一阶泰勒展开是一条直线它没有最小值，而抛物线有最小值，实际上它就是在拿拟合出来的抛物线的最小值当成更好一点的x作为下一次的起始点，下次到这新的点，就又找了一个抛物线，以此类推，类似于我们每次拿一个碗形的曲线去套原先的曲线，所以它能更好的拟合在某一点附近的真实曲线情况，正因为如此，这个东西带来的好处就是&lt;strong&gt;牛顿法比梯度下降在底部震荡次数小很多，它能够让我们在求函数最优解的过程中有更少的收敛次数。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;5-%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E5%88%A9%E7%94%A8%E7%89%9B%E9%A1%BF%E6%B3%95%E6%B1%82%E9%A9%BB%E7%82%B9%C2%A0%C2%A0&quot;&gt;&lt;span&gt;&lt;strong&gt;5-多元函数利用牛顿法求驻点  &lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;上面所说的都是针对一元的，而机器学习里面都是多元的，所谓的x在机器学习里面是谁？你要优化损失函数，损失函数是跟着w来的，我们一定要了然一个事，在机器学习的训练集里，x是已知数，你唯一未知数就是w。x都是w的系数，它在损失函数里面无论什么情况，最终都会变成w的系数。那么这里面的w实际上是机器学习里面的未知数x，w有多少个，往往不止一个。对于多元函数求驻点怎么求？实际在多元函数中，一阶导数映射到多元函数里就是梯度：即&lt;strong&gt;一阶导数f'(x) -----&amp;gt;梯度&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                                                                                &lt;img class=&quot;mathcode&quot; src=&quot;https://private.codecogs.com/gif.latex?%5Cnabla%20f%3D%5Cleft%5B%20%5Cbegin%7Barray%7D%7Bc%7D%7B%5Cfrac%7B%5Cpartial%20f%7D%7B%5Cpartial%20x_%7B1%7D%7D%7D%20%5C%5C%20%7B%5Cfrac%7B%5Cpartial%20f%7D%7B%5Cpartial%20x_%7B2%7D%7D%7D%20%5C%5C%20%7B%5Cvdots%7D%20%5C%5C%20%7B%5Cfrac%7B%5Cpartial%20f%7D%7B%5Cpartial%20x_%7BN%7D%7D%7D%5Cend%7Barray%7D%5Cright%5D&quot; alt=&quot;\nabla f=\left[ \begin{array}{c}{\frac{\partial f}{\partial x_{1}}} \\ {\frac{\partial f}{\partial x_{2}}} \\ {\vdots} \\ {\frac{\partial f}{\partial x_{N}}}\end{array}\right]&quot; data-cke-saved-src=&quot;https://private.codecogs.com/gif.latex?%5Cnabla%20f%3D%5Cleft%5B%20%5Cbegin%7Barray%7D%7Bc%7D%7B%5Cfrac%7B%5Cpartial%20f%7D%7B%5Cpartial%20x_%7B1%7D%7D%7D%20%5C%5C%20%7B%5Cfrac%7B%5Cpartial%20f%7D%7B%5Cpartial%20x_%7B2%7D%7D%7D%20%5C%5C%20%7B%5Cvdots%7D%20%5C%5C%20%7B%5Cfrac%7B%5Cpartial%20f%7D%7B%5Cpartial%20x_%7BN%7D%7D%7D%5Cend%7Barray%7D%5Cright%5D&quot; data-cke-widget-data=&quot;{}&quot; data-cke-widget-upcasted=&quot;1&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;梯度就是它的所有一阶导数给它写一块去。比如你原来就一个x，求个导就完事了。你现在有十个x，你求谁都不合适，你就干脆把十个逐个求个叫偏导，然后把这第一个x求偏导的函数放在这个向量的第一位&lt;img class=&quot;mathcode&quot; src=&quot;https://private.codecogs.com/gif.latex?%5Cfrac%7B%5Cpartial%20f%7D%7B%5Cpartial%20x_%7B1%7D%7D&quot; alt=&quot;\frac{\partial f}{\partial x_{1}}&quot; data-cke-saved-src=&quot;https://private.codecogs.com/gif.latex?%5Cfrac%7B%5Cpartial%20f%7D%7B%5Cpartial%20x_%7B1%7D%7D&quot; data-cke-widget-data=&quot;{}&quot; data-cke-widget-upcasted=&quot;1&quot;/&gt;，第二个求偏导的函数放在向量第二位&lt;img class=&quot;mathcode&quot; src=&quot;https://private.codecogs.com/gif.latex?%5Cfrac%7B%5Cpartial%20f%7D%7B%5Cpartial%20x_%7B2%7D%7D&quot; alt=&quot;\frac{\partial f}{\partial x_{2}}&quot; data-cke-saved-src=&quot;https://private.codecogs.com/gif.latex?%5Cfrac%7B%5Cpartial%20f%7D%7B%5Cpartial%20x_%7B2%7D%7D&quot; data-cke-widget-data=&quot;{}&quot; data-cke-widget-upcasted=&quot;1&quot;/&gt;，最后一个求偏导放在最后一位，组成一个向量。这个向量里面存的目前来讲还是一个函数，这个叫做&lt;strong&gt;梯度函数向量&lt;/strong&gt;，而梯度是不是指的是某个点的梯度，就像导数指的是某一个点的导数一样，那么梯度里边存的就不再是函数，而是把某组x带到这一组函数里面，去得到了那一组实数的向量值，所有你只要说梯度，虽然它里面写的是字母，但实际上知道这是一个真真切切的实数。 它是一个实数向量。   那么梯度是什么情况？假设你有十个w，梯度就有10个元素，因为要对10个未知的w逐个求偏导放到向量里面。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对第一个w求偏导，它得的结果是一个导函数，它们通常我们在写梯度的时候，有时候会这么写，&lt;strong&gt;&lt;img class=&quot;mathcode&quot; src=&quot;https://private.codecogs.com/gif.latex?%24g%5Cleft%28%5Cvec%7Bx%7D_%7Bk%7D%5Cright%29%24&quot; alt=&quot;$g\left(\vec{x}_{k}\right)$&quot; data-cke-saved-src=&quot;https://private.codecogs.com/gif.latex?%24g%5Cleft%28%5Cvec%7Bx%7D_%7Bk%7D%5Cright%29%24&quot; data-cke-widget-data=&quot;{}&quot; data-cke-widget-upcasted=&quot;1&quot;/&gt;这个x代表一个向量，它并不是向量中的某个元素，这个x就已经包含了若干个x了，x1到xn，k就代表第几代x&lt;/strong&gt;。 这个梯度的意思就是说你先把这些偏导函数搁在这之后，然后再对当前这一代xk的具体的值带到这里来求出的结果，这个东西叫梯度。涉及到梯度，就意味着有一定的方向。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;多元函数中，我们之前的求驻点的迭代公式&lt;span&gt;xk&lt;span&gt; = &lt;span&gt;xk-1&lt;span&gt; - &lt;span&gt;f’(xk-1)/f’’(xk-1)，f’(x)在多元函数中就是它对应的的梯度g（x） ，f’’( x)叫做Hessian矩阵对应关系为：&lt;strong&gt;一阶导数f''(x) -----&amp;gt;Hessian矩阵&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;这个矩阵是怎么求？就是它要求两次导，假如说原来对x1求导，求了之后还对x1求一次导，它还需要再对x1到xn分别求一次导，这样就形成了一个巨大的偏导数的矩阵，这个矩阵的情况应该是N乘N的，它的对角线元素是对同一个自变量求两次，而其它是各种各样的排列组合。这个就是二阶导数Hessian矩阵。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以我们的迭代公式演变为：从&lt;img class=&quot;mathcode&quot; src=&quot;https://private.codecogs.com/gif.latex?x_%7Bk&amp;amp;plus;1%7D%3Dx_%7Bk%7D-%5Cfrac%7Bf%5E%7B%5Cprime%7D%5Cleft%28x_%7Bk%7D%5Cright%29%7D%7Bf%5E%7B%5Cprime%20%5Cprime%7D%5Cleft%28x_%7Bk%7D%5Cright%29%7D&quot; alt=&quot;x_{k+1}=x_{k}-\frac{f^{\prime}\left(x_{k}\right)}{f^{\prime \prime}\left(x_{k}\right)}&quot; data-cke-saved-src=&quot;https://private.codecogs.com/gif.latex?x_%7Bk&amp;amp;plus;1%7D%3Dx_%7Bk%7D-%5Cfrac%7Bf%5E%7B%5Cprime%7D%5Cleft%28x_%7Bk%7D%5Cright%29%7D%7Bf%5E%7B%5Cprime%20%5Cprime%7D%5Cleft%28x_%7Bk%7D%5Cright%29%7D&quot; data-cke-widget-data=&quot;{}&quot; data-cke-widget-upcasted=&quot;1&quot;/&gt;到&lt;img class=&quot;mathcode&quot; src=&quot;https://private.codecogs.com/gif.latex?%24%5Cmathbf%7Bx%7D_%7Bk&amp;amp;plus;1%7D%3D%5Cmathbf%7Bx%7D_%7Bk%7D-H_%7Bk%7D%5E%7B-1%7D%20%5Ccdot%20%5Cmathbf%7Bg%7D_%7Bk%7D%2C%20%5Cquad%20k%3D0%2C1%2C%20%5Ccdots%24&quot; alt=&quot;$\mathbf{x}_{k+1}=\mathbf{x}_{k}-H_{k}^{-1} \cdot \mathbf{g}_{k}, \quad k=0,1, \cdots$&quot; data-cke-saved-src=&quot;https://private.codecogs.com/gif.latex?%24%5Cmathbf%7Bx%7D_%7Bk&amp;amp;plus;1%7D%3D%5Cmathbf%7Bx%7D_%7Bk%7D-H_%7Bk%7D%5E%7B-1%7D%20%5Ccdot%20%5Cmathbf%7Bg%7D_%7Bk%7D%2C%20%5Cquad%20k%3D0%2C1%2C%20%5Ccdots%24&quot; data-cke-widget-data=&quot;{}&quot; data-cke-widget-upcasted=&quot;1&quot;/&gt; 其中gk就是多元函数一阶导，Hk就是多元函数二阶导。gk原来在分子中，Hessian矩阵应该是除以二阶导数，所以变成了矩阵的逆。我们可以看一下Hk矩阵，逆矩阵还是一个N*N的，gk是一个N*1的矩阵，它俩相乘得到是一个N*1的向量，就是一个高高的向量， N行1列。xk本身也是一个高高的向量，它俩做减法完全没有问题。但是Hk矩阵的N*N就给我们带来了一个非常不喜欢的问题，这个矩阵太难运算的，当你有1000个维度的时候，就是1000×1000的矩阵，然后1万个维度的时候，10000×10000，维度就爆炸了。而牛顿法求驻点又是一个迭代算法,所以这个困难我们还要面临无限多次,导致了牛顿法求驻点在机器学习中无法使用.有没有什么解决办法呢。&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;6-BFGS%E7%AE%97%E6%B3%95&quot;&gt;&lt;span&gt;&lt;strong&gt;6-BFGS算法&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt; BFGS算法是通过迭代来逼近&lt;img class=&quot;mathcode&quot; src=&quot;https://private.codecogs.com/gif.latex?H_%7Bk%7D%5E%7B-1%7D&quot; alt=&quot;H_{k}^{-1}&quot; data-cke-saved-src=&quot;https://private.codecogs.com/gif.latex?H_%7Bk%7D%5E%7B-1%7D&quot; data-cke-widget-data=&quot;{}&quot; data-cke-widget-upcasted=&quot;1&quot;/&gt;的算法.逼近的方式如下:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                                      &lt;img class=&quot;mathcode&quot; src=&quot;https://private.codecogs.com/gif.latex?D_%7Bk&amp;amp;plus;1%7D%3D%5Cleft%28I-%5Cfrac%7B%5Cmathbf%7Bs%7D_%7Bk%7D%20%5Cmathbf%7By%7D_%7Bk%7D%5E%7BT%7D%7D%7B%5Cmathbf%7By%7D_%7Bk%7D%5E%7BT%7D%20%5Cmathbf%7Bs%7D_%7Bk%7D%7D%5Cright%29%20D_%7Bk%7D%5Cleft%28I-%5Cfrac%7B%5Cmathbf%7By%7D_%7Bk%7D%20%5Cmathbf%7Bs%7D_%7Bk%7D%5E%7BT%7D%7D%7B%5Cmathbf%7By%7D_%7Bk%7D%5E%7BT%7D%20%5Cmathbf%7Bs%7D_%7Bk%7D%7D%5Cright%29&amp;amp;plus;%5Cfrac%7B%5Cmathbf%7Bs%7D_%7Bk%7D%20%5Cmathbf%7Bs%7D_%7Bk%7D%5E%7BT%7D%7D%7B%5Cmathbf%7By%7D_%7Bk%7D%5E%7BT%7D%20%5Cmathbf%7Bs%7D_%7Bk%7D%7D&quot; alt=&quot;D_{k+1}=\left(I-\frac{\mathbf{s}_{k} \mathbf{y}_{k}^{T}}{\mathbf{y}_{k}^{T} \mathbf{s}_{k}}\right) D_{k}\left(I-\frac{\mathbf{y}_{k} \mathbf{s}_{k}^{T}}{\mathbf{y}_{k}^{T} \mathbf{s}_{k}}\right)+\frac{\mathbf{s}_{k} \mathbf{s}_{k}^{T}}{\mathbf{y}_{k}^{T} \mathbf{s}_{k}}&quot; data-cke-saved-src=&quot;https://private.codecogs.com/gif.latex?D_%7Bk&amp;amp;plus;1%7D%3D%5Cleft%28I-%5Cfrac%7B%5Cmathbf%7Bs%7D_%7Bk%7D%20%5Cmathbf%7By%7D_%7Bk%7D%5E%7BT%7D%7D%7B%5Cmathbf%7By%7D_%7Bk%7D%5E%7BT%7D%20%5Cmathbf%7Bs%7D_%7Bk%7D%7D%5Cright%29%20D_%7Bk%7D%5Cleft%28I-%5Cfrac%7B%5Cmathbf%7By%7D_%7Bk%7D%20%5Cmathbf%7Bs%7D_%7Bk%7D%5E%7BT%7D%7D%7B%5Cmathbf%7By%7D_%7Bk%7D%5E%7BT%7D%20%5Cmathbf%7Bs%7D_%7Bk%7D%7D%5Cright%29&amp;amp;plus;%5Cfrac%7B%5Cmathbf%7Bs%7D_%7Bk%7D%20%5Cmathbf%7Bs%7D_%7Bk%7D%5E%7BT%7D%7D%7B%5Cmathbf%7By%7D_%7Bk%7D%5E%7BT%7D%20%5Cmathbf%7Bs%7D_%7Bk%7D%7D&quot; data-cke-widget-data=&quot;{}&quot; data-cke-widget-upcasted=&quot;1&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        其中：&lt;img class=&quot;mathcode&quot; src=&quot;https://private.codecogs.com/gif.latex?%24%5Cmathrm%7Bs%7D_%7Bk%7D%3D%5Cmathrm%7Bx%7D_%7Bk&amp;amp;plus;1%7D-%5Cmathrm%7Bx%7D_%7Bk%7D%2C%20%5Cmathrm%7By%7D_%7Bk%7D%3D%5Cmathrm%7Bg%7D_%7Bk&amp;amp;plus;1%7D-%5Cmathrm%7Bg%7D_%7Bk%7D%24&quot; alt=&quot;$\mathrm{s}_{k}=\mathrm{x}_{k+1}-\mathrm{x}_{k}, \mathrm{y}_{k}=\mathrm{g}_{k+1}-\mathrm{g}_{k}$&quot; data-cke-saved-src=&quot;https://private.codecogs.com/gif.latex?%24%5Cmathrm%7Bs%7D_%7Bk%7D%3D%5Cmathrm%7Bx%7D_%7Bk&amp;amp;plus;1%7D-%5Cmathrm%7Bx%7D_%7Bk%7D%2C%20%5Cmathrm%7By%7D_%7Bk%7D%3D%5Cmathrm%7Bg%7D_%7Bk&amp;amp;plus;1%7D-%5Cmathrm%7Bg%7D_%7Bk%7D%24&quot; data-cke-widget-data=&quot;{}&quot; data-cke-widget-upcasted=&quot;1&quot;/&gt;。I是单位矩阵，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        BFGS就是通过迭代来逼近Hk的逆矩阵矩阵,其中第一步的D矩阵是单位矩阵.所谓单位矩阵就是只有对角线元素为1，其余全为零的矩阵。根据之前的迭代公式：&lt;img class=&quot;mathcode&quot; src=&quot;https://private.codecogs.com/gif.latex?%24%5Cmathrm%7Bx%7D_%7Bk&amp;amp;plus;1%7D%3D%5Cmathrm%7Bx%7D_%7Bk%7D-H_%7Bk%7D%5E%7B-1%7D%20%5Ccdot%20%5Cmathrm%7Bg%7D_%7Bk%7D%2C%20%5Cquad%20k%3D0%2C1%2C%20%5Ccdots%24&quot; alt=&quot;$\mathrm{x}_{k+1}=\mathrm{x}_{k}-H_{k}^{-1} \cdot \mathrm{g}_{k}, \quad k=0,1, \cdots$&quot; data-cke-saved-src=&quot;https://private.codecogs.com/gif.latex?%24%5Cmathrm%7Bx%7D_%7Bk&amp;amp;plus;1%7D%3D%5Cmathrm%7Bx%7D_%7Bk%7D-H_%7Bk%7D%5E%7B-1%7D%20%5Ccdot%20%5Cmathrm%7Bg%7D_%7Bk%7D%2C%20%5Cquad%20k%3D0%2C1%2C%20%5Ccdots%24&quot; data-cke-widget-data=&quot;{}&quot; data-cke-widget-upcasted=&quot;1&quot;/&gt;，除了第一步还是需要计算之前的逆矩阵H1，第一步迭代需要计算出x2=x1-H1*g1，s1=x2-x1，y1=g2-g1。因为有x2，所以g2是其梯度，也可求，有了s1,y1便可以求D2来近似代替H2的逆矩阵，然后一步步迭代，求出驻点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         我们要通过牛顿求驻点法和BFGS算法来求得一个函数的根,两个算法都需要迭代,慢慢逼近函数根,经过k次迭代以后,所得到的解就是机器学习中目标函数导函数的根.这种&lt;strong&gt;两个算法共同迭代的计算方式,我们称之为On The Fly。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;          回顾一下梯度下降的表达式&lt;img class=&quot;mathcode&quot; src=&quot;https://private.codecogs.com/gif.latex?%5CTheta_%7Bk%7D%20%3D%20%5CTheta_%7Bk&amp;amp;plus;1%7D%20-%20%5Calpha%20%5Ccdot%20g&quot; alt=&quot;\Theta_{k} = \Theta_{k+1} - \alpha \cdot g&quot; data-cke-saved-src=&quot;https://private.codecogs.com/gif.latex?%5CTheta_%7Bk%7D%20%3D%20%5CTheta_%7Bk&amp;amp;plus;1%7D%20-%20%5Calpha%20%5Ccdot%20g&quot; data-cke-widget-data=&quot;{}&quot; data-cke-widget-upcasted=&quot;1&quot;/&gt;，在BFGS算法迭代的第一步x2=x1-D1*g1,单位矩阵与梯度g相乘,就等于梯度g，形式上同梯度下降的表达式是相同的。相当于学习率等于1的梯度下降，所以&lt;strong&gt;BFGS算法可以理解为从梯度下降逐步转换为牛顿法求函数解的一个算法.&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         虽然我们使用了BFGS算法来利用单位矩阵逐步逼近H矩阵,但是根据Dk+1的公式，每次计算的时候都要存储上一代的Dk矩阵,Dk矩阵有多大呢.假设我们的数据集有十万个维度(不算特别大),那么每次迭代所要存储D矩阵的结果是74.5GB.&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;我们无法保存如此巨大的矩阵内容,如何解决呢? L-BFGS 算法上阵。&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%207-L-BFGS%E7%AE%97%E6%B3%95&quot;&gt;&lt;span&gt; &lt;strong&gt;7-L-BFGS算法&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;我们每一次对D矩阵的迭代,都是通过迭代计算sk和yk得到的.既然存不下D矩阵,那么我们存储下所有的sk和yk,想要得到D10就用单位矩阵同存储下的s1和y1到s10和y10计算就可以了.这样一个时间换空间的办法，有效节省了内存空间。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         但是,仅仅是这样还是不够的,因为当迭代次数非常大的时候,我们的内存同样存不下.这个时候只能丢掉一些存不下的数据.假设我们设置的存储向量数为100,当s和y迭代超过100时,就会扔掉第一个s和y,存储s2到s101和y2到y101,每多一次迭代就对应的扔掉最前边的s和y。假如最后收敛次数是1000的话，只保留s901，y901从而计算出D901 ，然后再保留s902，y902计算出D902，依次根据s1000,y1000，从而算出D1000，按理说需要D900才能计算出D901 ，此时我们粗暴的将D901置为单位矩阵I，这样虽然损失了精度,但确可以保证使用有限的内存将函数的解通过BFGS算法求得到。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;虽然L-BFGS算法是线性收敛，但是每次迭代的开销非常小，因此L-BFGS算法执行速度还是很快的，而且由于每一步迭代都能保证近似矩阵的正定，因此算法的鲁棒性还是很强的。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 04 May 2019 03:26:00 +0000</pubDate>
<dc:creator>LHBlog</dc:creator>
<og:description>第二十一节 牛顿法和L-BFGS求函数最优解 这一节中，我们讲解一个新的求函数最优化的方法就是L-BFGS。以下是本节目录。 目录 1-L-BFGS算法简介 2-牛顿法求根问题 3-牛顿法求驻点问题</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/LHWorldBlog/p/10807354.html</dc:identifier>
</item>
<item>
<title>004-python-列表、元组、字典 - do康解U</title>
<link>http://www.cnblogs.com/David-domain/p/10807968.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/David-domain/p/10807968.html</guid>
<description>&lt;p&gt;1. 什么是列表&lt;/p&gt;
&lt;p&gt;列表是一个可变的数据类型&lt;br/&gt;列表由[]来表示, 每一项元素使用逗号隔开. 列表什么都能装. 能装对象的对象.&lt;br/&gt;列表可以装大量的数据&lt;br/&gt;2. 列表的索引和切片&lt;br/&gt;列表和字符串一样. 也有索引和切片. 只不过切出来的内容是列表&lt;br/&gt;索引的下标从0开始&lt;br/&gt;[起始位置:结束位置:步长]&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;49&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
lst = [&quot;移动硬盘&quot;, &quot;手机&quot;, 110, True, False, [&quot;人民币&quot;, &quot;美金&quot;, '欧元']]

lst = [&quot;海上钢琴师&quot;, &quot;奥特曼&quot;, &quot;咒怨&quot;, &quot;舌尖上的中国&quot;, &quot;穹顶之下&quot;, &quot;金刚&quot;]

print(lst[3][2]) # 上
print(lst[-2])  # 穹顶之下
print(lst[1:4])  # ['奥特曼', '咒怨', '舌尖上的中国']
print(lst[-3:-1]) # 顾头不顾尾
print(lst[1::2])
print(lst[-1:-5:-2])
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;3. 列表的增删改查*&lt;br/&gt;1. 增加&lt;br/&gt;append() 追加&lt;br/&gt;insert(index, 元素) 在index位置添加元素&lt;br/&gt;extend() 迭代添加&lt;br/&gt;2. 删除&lt;br/&gt;pop(index) 按照位置删除元素&lt;br/&gt;remove(元素) 直接删除元素&lt;br/&gt;del 切片.&lt;br/&gt;clear() 清空列表&lt;br/&gt;3. 修改&lt;br/&gt;索引修改&lt;br/&gt;切片修改&lt;br/&gt;4. 查询&lt;br/&gt;for el in list:&lt;br/&gt;el&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;52&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
lst = [&quot;赵四&quot;, &quot;施瓦星格&quot;, &quot;黄渤&quot;, &quot;郭达森&quot;, &quot;赛利亚&quot;]

# 在屁股后面添加
lst.append(&quot;黄宏&quot;) # 在原有的基础上进行的操作
# 在xxx位置插入xxxx内容
lst.insert(1,&quot;王力宏&quot;)
lst.extend([&quot;麻花藤&quot;, &quot;马云&quot;, &quot;王健林&quot;, &quot;许家印&quot;]) # 迭代添加
print(lst)

# 删除
data = lst.pop(2) # 返回被删除的数据
print(data)
print(lst)

lst.remove(&quot;赵四&quot;) # 删除元素.
lst.remove(&quot;刘能&quot;) # 如果不存在会报错

# 切片删除
del lst[1:3]

# 清空
lst.clear()
print(lst)

lst = [&quot;王者农药&quot;, &quot;魔兽世界&quot;, &quot;DNF&quot;, &quot;逆水寒&quot;, &quot;反恐精英&quot;]
lst[0] = &quot;扫雷&quot;
print(lst)
lst[3] = &quot;吃鸡&quot;

lst[1:3] = [&quot;跑跑卡丁车&quot;]  # 先删除后添加
lst[1::2] = [&quot;QQ华夏&quot;,&quot;QQ三国&quot;] # 切片修改的时候. 如果步长不是1. 注意元素的个数
print(lst)

lst = [&quot;锅包肉&quot;, &quot;好人家火锅&quot;, &quot;巫山烤鱼&quot;, &quot;清水煮白菜&quot;, &quot;烤鸭&quot;]
for el in lst: # element(元素)
    print(el)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;5. 常用操作&lt;br/&gt;1. sort() 排序 reverse=True降序&lt;br/&gt;2. reverse() 翻转&lt;br/&gt;3. len() 求长度&lt;br/&gt;4. 列表的嵌套&lt;br/&gt;降维. 一层一层看&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;57&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
lst = [&quot;alex&quot;, &quot;gay&quot;,&quot;wusir&quot;,[&quot;范冰冰&quot;,&quot;李冰冰&quot;,[1, &quot;火锅&quot;, &quot;ritian&quot;, &quot;凤爪&quot;],&quot;王冰冰&quot;]]
print(lst[3][2][1]) # 火锅

lst[3][2][2] = lst[3][2][2].upper()
print(lst)

lst[3][2][0] = lst[3][2][0] + 99
print(lst)

lst = [1,5,3,4,3,2,44,3,2,22]
lst.sort(reverse=True) # 排序. 默认升序, reverse=True 降序
print(lst)

lst = ['晓雪',&quot;小茹&quot;, &quot;小花&quot;,&quot;晓梅&quot;]
lst.reverse() # 翻转
print(lst)

print(len(lst))
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;5. 元组&lt;br/&gt;只读列表. 只能看啥也不能干.&lt;br/&gt;使用()表示元组&lt;br/&gt;如果元祖中只有一个元素(元素, )&lt;br/&gt;空元组: tuple()&lt;br/&gt;元祖是一个可迭代对象, 可以使用for循环&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;44&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
print((1+3)*5)
print((3))
tu = (3, ) # 元组中如果只有一个元素. 需要在括号里写一个,
tu = tuple() # 空元组
print(type(tu))

tu = (&quot;人民币&quot;, &quot;美元&quot;, &quot;英镑&quot;, &quot;欧元&quot;)
tu.append(&quot;哈哈&quot;)
tu[0] = &quot;日元&quot; # 不予许修改
del tu[2] # 删除也不行

print(tu[2]) # 索引可以用
print(tu[::2])

for el in tu:
    print(el)

# 元组的第一层是不能进行赋值的. 内部元素是没有要求
tu = (1, &quot;哈喽&quot;, &quot;how are you?&quot;, &quot;alex&quot;, [&quot;alex&quot;])
tu[3].upper()
print(tu)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;6. range&lt;br/&gt;range(n) 从0到n-1&lt;br/&gt;range(m,n) 从m到n-1&lt;br/&gt;range(m,n,q) 从m到n-1 每q个取1个&lt;br/&gt;综上就是切片&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;48&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
# range()是一个可迭代对象
1. range(n)  0 -&amp;gt; n-1
for i in range(10):
    print(i)
# 2. range(m,n) m -&amp;gt; n-1
for i in range(1,10):
    print(i)
# 3. range(m,n,q) m -&amp;gt; n-1 每q个取一个
for i in range(1,10,3):
    print(i)

for i in range(100, 90, -1):
    print(i)
#       0        1      2         3            4        5
lst = [&quot;砂锅&quot;, &quot;馒头&quot;, &quot;盖浇饭&quot;, &quot;刀削面&quot;, &quot;大麻花&quot;, &quot;大煎饼&quot;]
# 获取到列表的索引. 拿到索引之后. 可以拿到元素
for i in range(len(lst)):
    print(i)    # i就是lst的索引
    print(lst[i])

for el in lst:
    print(el)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;7. 使用range和for循环来获取列表中的索引&lt;br/&gt;for i in range(len(列表)):&lt;br/&gt;i 索引&lt;br/&gt;列表[i] 元素&lt;/p&gt;
</description>
<pubDate>Sat, 04 May 2019 03:26:00 +0000</pubDate>
<dc:creator>do康解U</dc:creator>
<og:description>1. 什么是列表 列表是一个可变的数据类型 列表由[]来表示, 每一项元素使用逗号隔开. 列表什么都能装. 能装对象的对象. 列表可以装大量的数据 2. 列表的索引和切片 列表和字符串一样. 也有索引</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/David-domain/p/10807968.html</dc:identifier>
</item>
<item>
<title>物联网架构_对AWS的Greengrass的认识与理解 - 血夜之末</title>
<link>http://www.cnblogs.com/Tiancheng-Duan/p/10804804.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Tiancheng-Duan/p/10804804.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;物联网架构_对AWS的Greengrass的认识与理解&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;一，前言：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这段时间有许多的收获，分析，还有总结，其中包括新系统的设计与开发，以及其中新技术的踩坑等等等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是最近真的很忙，项目的推进，面试工作等，尤其五月份还有考试。所以，赶紧趁着五一假期有些空暇，先发一些东西。之后，有机会再对自己的素材（周报，技术总结什么的），做一些整理，再发出来哈。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这篇文章，主要是在之前项目架构设计时，了解了现有的一些项目，其中就有AWS的Greengrass项目，这里简单介绍一下自己的认识。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;物联网方面的介绍可以参考我回答的百度知道（@link：https://zhidao.baidu.com/question/1501072861578680979.html?entry=qb_uhome_tag）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;说简单点，就是物联网会是接下来的五到十年的一个小风口吧。可以试着，去了解，去学习，去感受其中的技术的变革（并不一定非要从事专门的工作，而是从变革中看到技术演变的过程，领悟它）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这篇文章是简单看了AWS有关物联网的项目Greengrass后，感觉其角度与之前了解的百度物联网架构有所不同，所以查阅了一些资料后，给出我的看法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（百度物联网的资料，可以参考@link：https://blog.csdn.net/robert_tina/article/details/78979405，条理比较清晰，我就不给出自己的XMIND了）&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;二，XMIND：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/987666/201905/987666-20190503120257395-1533269196.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（图片看不清的，请单独打开图片，或放大图片，或下载图片。图片绝对清晰，谢谢）&lt;/span&gt; &lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;三，补充：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;之前@博达智联写的博客与这个结构图的关注点有较大差异，前者倾向于技术领域，后者虽然重心仍然在技术领域，但是涉及了一些业务，乃至领域性的问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如为什么我们需要边缘计算，或者说物联网领域为什么要采用边缘计算，边缘计算的边缘又是指什么？边缘计算的理由，可以看上图中问题及解决/源位置处理数据的价值的三个原因。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如无人驾驶中，车速假定10m/s，前方5m处出现障碍物。系统采集数据（数据清洗），上传数据（涉及网络延迟），云平台计算（可能涉及服务调用等延迟），数据下发（涉及网络延迟），本地数据解析与运用。这样的流程可能需要200ms，即0.2s。那么车子距离障碍物就只有3m了，制动距离可能就不够了。当然这些数据都是假设的，可能不符合实际场景，但是我所要表达的意思是这样的。其中数据清洗，云平台的服务调用等，你都可以通过一定的技术手段去缩减，甚至接近0耗时。但是如今的网络延迟，你是无法大幅度缩减的，因为这涉及到物理定律。你所提出的技术解决方案是不可能打破物理定律的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那么，我们可以调整一下我们的逻辑模型，进而改变我们的架构。比如我们可以赋予边缘节点（边缘指远离计算中心）一定的计算能力，从而实现简单的处理能力。在上述例子中，我们可以在汽车的计算单元中，简单评估障碍物所带来的危险程度与现在的速度等，决定是缓慢减速，还是急刹车。在0.2s后，再根据云平台发回的精准结果，来进行调整。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当然我只是举了一个有关物理定律的例子，还有经济定律中的资源损耗。如现有阶段，你无法将无人汽车的视频24x7小时的上传，那太消耗带宽了。另外还有国家法律方面的隐私保护，如军事领域的汽车（即便只是首长回家，因为涉及首长安全），恐怕很难允许你获取无人汽车的详细行驶资料。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而这些都是技术之外的。我一直相信，技术与业务之前需要交流与权衡。因为很多问题在业务看来，只是简单地做一些调整与舍弃，却能解决技术巨大的压力。同样，很多在业务看来，很难实现的方案，也许在技术领域来看，只是多写一些服务的问题。所以，团队要注重交流，leader（当然这个leader并不是指绝对的一个人，而是指相关事件的决策者。解释起来比较麻烦，之后有机会，会在敏捷开发等文章中来解释我的这一想法）要权衡技术与业务。&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;四，分析：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其实简单来说，AWS的Greengrass就是将整个系统分为三个部分：底层硬件（AIOT SDK），计算核心（GGC），云平台（AWS服务）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其中Greengrass为底层硬件，如倾斜传感器，温度传感器等提供了对应SDK，封装了与上层GGC的通讯等，提高了开发效率。这就类似于我们封装了Jedis，形成JedisUtils，来快速方便调用redis，实现我们的功能。但是底层硬件并无法实现基础计算之外的功能，所以我们需要GGC来帮我们完成边缘计算的计算部分。当然即使GGC也在对应的硬件上时，逻辑上，我们仍然拆分两者，这是为了更好地管理与实现功能。而云平台则是提供了数据的高阶应用，如数据挖掘，机器学习，并为企业决策提供支持等。另外AWS的Greengrass的云平台部分，可以直接调用AWS的数据处理服务，也就是说改云平台与AWS的其它服务是可以横向连接，调用的（其安全性是通过设备上的SigV4凭证实现的）。&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;五，总结：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;AWS的物联网架构值得我们去参考学习，但是于此同时，我们也要根据实际业务场景的需求，进行自己架构调整与设计。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如实际场景中，我所在公司的客户中，有的要求拥有自己的中控平台，并且部分客户为了数据安全，还要求不对云平台提供数据（当然也有要求只提供部分结论数据的）。为此，我们在计算核心与云平台间，增加了企业服务器，完成了不向云平台上传数据的企业的数据处理要求（当然，我们暂时不会对这样的公司提供行业数据的横向分析业务）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（之后有机会，我会在保密的前提下，简单介绍我负责的系统的分析与设计过程。）&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 04 May 2019 02:50:00 +0000</pubDate>
<dc:creator>血夜之末</dc:creator>
<og:description>物联网架构_对AWS的Greengrass的认识与理解 一，前言： 这段时间有许多的收获，分析，还有总结，其中包括新系统的设计与开发，以及其中新技术的踩坑等等等。 但是最近真的很忙，项目的推进，面试工</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Tiancheng-Duan/p/10804804.html</dc:identifier>
</item>
<item>
<title>Spring Cloud Gateway入坑记 - throwable</title>
<link>http://www.cnblogs.com/throwable/p/10807704.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/throwable/p/10807704.html</guid>
<description>&lt;h2 id=&quot;前提&quot;&gt;前提&lt;/h2&gt;
&lt;p&gt;最近在做老系统的重构，重构完成后新系统中需要引入一个网关服务，作为新系统和老系统接口的适配和代理。之前，很多网关应用使用的是&lt;code&gt;Spring-Cloud-Netfilx&lt;/code&gt;基于&lt;code&gt;Zuul1.x&lt;/code&gt;版本实现的那套方案，但是鉴于&lt;code&gt;Zuul1.x&lt;/code&gt;已经停止迭代，它使用的是比较传统的阻塞(B)IO + 多线程的实现方案，其实性能不太好。后来Spring团队干脆自己重新研发了一套网关组件，这个就是本次要调研的&lt;code&gt;Spring-Cloud-Gateway&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;Spring Cloud Gateway&lt;/span&gt;依赖于&lt;a href=&quot;https://spring.io/projects/spring-boot#learn&quot;&gt;Spring Boot 2.0&lt;/a&gt;, &lt;a href=&quot;https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html&quot;&gt;Spring WebFlux&lt;/a&gt;,和&lt;a href=&quot;https://projectreactor.io/docs&quot;&gt;Project Reactor&lt;/a&gt;。许多熟悉的同步类库(例如&lt;code&gt;Spring-Data&lt;/code&gt;和&lt;code&gt;Spring-Security&lt;/code&gt;)和同步编程模式在&lt;code&gt;Spring Cloud Gateway&lt;/code&gt;中并不适用，所以最好先阅读一下上面提到的三个框架的文档。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Spring Cloud Gateway&lt;/code&gt;依赖于&lt;code&gt;Spring Boot&lt;/code&gt;和&lt;code&gt;Spring WebFlux&lt;/code&gt;提供的基于&lt;code&gt;Netty&lt;/code&gt;的运行时环境，它并非构建为一个WAR包或者运行在传统的&lt;code&gt;Servlet&lt;/code&gt;容器中。&lt;/p&gt;
&lt;h3 id=&quot;专有名词&quot;&gt;专有名词&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;路由(Route)：路由是网关的基本组件。它由ID，目标URI，谓词(Predicate)集合和过滤器集合定义。如果谓词聚合判断为真，则匹配路由。&lt;/li&gt;
&lt;li&gt;谓词(Predicate)：使用的是Java8中基于函数式编程引入的&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/function/Predicate.html&quot;&gt;java.util.Predicate&lt;/a&gt;。使用谓词(聚合)判断的时候，输入的参数是&lt;code&gt;ServerWebExchange&lt;/code&gt;类型，它允许开发者匹配来自HTTP请求的任意参数，例如HTTP请求头、HTTP请求参数等等。&lt;/li&gt;
&lt;li&gt;过滤器(Filter)：使用的是指定的&lt;code&gt;GatewayFilter&lt;/code&gt;工厂所创建出来的&lt;code&gt;GatewayFilter&lt;/code&gt;实例，可以在发送请求到下游之前或者之后修改请求(参数)或者响应(参数)。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其实&lt;code&gt;Filter&lt;/code&gt;还包括了&lt;code&gt;GlobalFilter&lt;/code&gt;，不过在官方文档中没有提到。&lt;/p&gt;
&lt;h3 id=&quot;工作原理&quot;&gt;工作原理&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/201905/s-c-g-e-1.png&quot; alt=&quot;s-c-g-e-1.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;客户端向&lt;code&gt;Spring Cloud Gateway&lt;/code&gt;发出请求，如果&lt;code&gt;Gateway Handler Mapping&lt;/code&gt;模块处理当前请求如果匹配到一个目标路由配置，该请求就会转发到&lt;code&gt;Gateway Web Handler&lt;/code&gt;模块。&lt;code&gt;Gateway Web Handler&lt;/code&gt;模块在发送请求的时候，会把该请求通过一个匹配于该请求的过滤器链。上图中过滤器被虚线分隔的原因是：过滤器的处理逻辑可以在代理请求发送之前或者之后执行。所有&lt;code&gt;pre&lt;/code&gt;类型的过滤器执行之后，代理请求才会创建(和发送)，当代理请求创建(和发送)完成之后，所有的&lt;code&gt;post&lt;/code&gt;类型的过滤器才会执行。&lt;/p&gt;
&lt;p&gt;见上图，外部请求进来后如果落入过滤器链，那么虚线左边的就是&lt;code&gt;pre&lt;/code&gt;类型的过滤器，请求先经过&lt;code&gt;pre&lt;/code&gt;类型的过滤器，再发送到目标被代理的服务。目标被代理的服务响应请求，响应会再次经过滤器链，也就是走虚线右侧的过滤器链，这些过滤器就是&lt;code&gt;post&lt;/code&gt;类型的过滤器。&lt;/p&gt;
&lt;p&gt;注意，如果在路由配置中没有明确指定对应的路由端口，那么会使用如下的默认端口：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;HTTP协议，使用80端口。&lt;/li&gt;
&lt;li&gt;HTTPS协议，使用443端口。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;引入依赖&quot;&gt;引入依赖&lt;/h2&gt;
&lt;p&gt;建议直接通过Train版本(其实笔者考究过，Train版本的代号其实是伦敦地铁站的命名，像当前的&lt;code&gt;Spring Cloud&lt;/code&gt;最新版本是&lt;code&gt;Greenwich.SR1&lt;/code&gt;，&lt;code&gt;Greenwich&lt;/code&gt;可以在伦敦地铁站的地图查到这个站点，对应的&lt;code&gt;SpringBoot&lt;/code&gt;版本是2.1.x)引入&lt;code&gt;Spring-Cloud-Gateway&lt;/code&gt;，因为这样可以跟上最新稳定版本的&lt;code&gt;Spring-Cloud&lt;/code&gt;版本，另外由于&lt;code&gt;Spring-Cloud-Gateway&lt;/code&gt;基于&lt;code&gt;Netty&lt;/code&gt;的运行时环境启动，不需要引入带&lt;code&gt;Servlet&lt;/code&gt;容器的&lt;code&gt;spring-boot-starter-web&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;父POM引入下面的配置：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;dependencyManagement&amp;gt;
        &amp;lt;dependencies&amp;gt;
            &amp;lt;dependency&amp;gt;
                &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;spring-cloud-dependencies&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;Greenwich.SR1&amp;lt;/version&amp;gt;
                &amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt;
                &amp;lt;scope&amp;gt;import&amp;lt;/scope&amp;gt;
            &amp;lt;/dependency&amp;gt;
            &amp;lt;dependency&amp;gt;
                &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;spring-boot-dependencies&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;2.1.4.RELEASE&amp;lt;/version&amp;gt;
                &amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt;
                &amp;lt;scope&amp;gt;import&amp;lt;/scope&amp;gt;
            &amp;lt;/dependency&amp;gt;
        &amp;lt;/dependencies&amp;gt;
&amp;lt;/dependencyManagement&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;子模块或者需要引入&lt;code&gt;Spring-Cloud-Gateway&lt;/code&gt;的模块POM引入下面的配置：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-cloud-starter-gateway&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建一个启动类即可：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@SpringBootApplication
public class RouteServerApplication {

    public static void main(String[] args) {
        SpringApplication.run(RouteServerApplication.class, args);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;网关配置&quot;&gt;网关配置&lt;/h2&gt;
&lt;p&gt;网关配置最终需要转化为一个&lt;code&gt;RouteDefinition&lt;/code&gt;的集合，配置的定义接口如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface RouteDefinitionLocator {
    Flux&amp;lt;RouteDefinition&amp;gt; getRouteDefinitions();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过YAML文件配置或者流式编程式配置（其实文档中还有配合Eureka的&lt;code&gt;DiscoveryClient&lt;/code&gt;进行配置，这里暂时不研究），最终都是为了创建一个&lt;code&gt;RouteDefinition&lt;/code&gt;的集合。&lt;/p&gt;
&lt;h3 id=&quot;yaml配置&quot;&gt;Yaml配置&lt;/h3&gt;
&lt;p&gt;配置实现是&lt;code&gt;PropertiesRouteDefinitionLocator&lt;/code&gt;，关联着配置类&lt;code&gt;GatewayProperties&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;spring:
  cloud:
    gateway:
      routes:
       - id: datetime_after_route    # &amp;lt;------ 这里是路由配置的ID
        uri: http://www.throwable.club  # &amp;lt;------ 这里是路由最终目标Server的URI(Host)
        predicates:                     # &amp;lt;------ 谓词集合配置，多个是用and逻辑连接
         - Path=/blog    # &amp;lt;------- Key(name)=Expression，键是谓词规则工厂的ID，值一般是匹配规则的正则表示&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;编程式流式配置&quot;&gt;编程式流式配置&lt;/h3&gt;
&lt;p&gt;编程式和流式编程配置需要依赖&lt;code&gt;RouteLocatorBuilder&lt;/code&gt;，目标是构造一个&lt;code&gt;RouteLocator&lt;/code&gt;实例：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Bean
public RouteLocator customRouteLocator(RouteLocatorBuilder builder) {
    return builder.routes()
            .route(r -&amp;gt; r.path(&quot;/blog&quot;)
                .uri(&quot;http://www.throwable.club&quot;)
            )
            .build();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;路由谓词工厂&quot;&gt;路由谓词工厂&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Spring Cloud Gateway&lt;/code&gt;将路由(Route)作为&lt;code&gt;Spring-WebFlux&lt;/code&gt;的&lt;code&gt;HandlerMapping&lt;/code&gt;组件基础设施的一部分，也就是&lt;code&gt;HandlerMapping&lt;/code&gt;进行匹配的时候，会把配置好的路由规则也纳入匹配机制之中。&lt;code&gt;Spring Cloud Gateway&lt;/code&gt;自身包含了很多内建的路由谓词工厂。这些谓词分别匹配一个HTTP请求的不同属性。多个路由谓词工厂可以用&lt;code&gt;and&lt;/code&gt;的逻辑组合在一起。&lt;/p&gt;
&lt;p&gt;目前&lt;code&gt;Spring Cloud Gateway&lt;/code&gt;提供的内置的路由谓词工厂如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/201905/s-c-g-e-2.png&quot; alt=&quot;s-c-g-e-2.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;指定日期时间规则路由谓词&quot;&gt;指定日期时间规则路由谓词&lt;/h3&gt;
&lt;p&gt;按照配置的日期时间指定的路由谓词有三种可选规则：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;匹配请求在指定日期时间之前。&lt;/li&gt;
&lt;li&gt;匹配请求在指定日期时间之后。&lt;/li&gt;
&lt;li&gt;匹配请求在指定日期时间之间。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;值得注意的是，配置的日期时间必须满足&lt;code&gt;ZonedDateTime&lt;/code&gt;的格式：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//年月日和时分秒用'T'分隔,接着-07:00是和UTC相差的时间，最后的[America/Denver]是所在的时间地区
2017-01-20T17:42:47.789-07:00[America/Denver]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;例如网关的应用是&lt;code&gt;2019-05-01T00:00:00+08:00[Asia/Shanghai]&lt;/code&gt;上线的，上线之后的请求都路由奥&lt;code&gt;www.throwable.club&lt;/code&gt;，那么配置如下：&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;server 
  port: 9090
spring:
  cloud:
    gateway:
      routes:
       - id: datetime_after_route
        uri: http://www.throwable.club
        predicates:
         - After=2019-05-01T00:00:00+08:00[Asia/Shanghai]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时，只要请求网关&lt;code&gt;http://localhost:9090&lt;/code&gt;，请求就会转发到&lt;code&gt;http://www.throwable.club&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如果想要只允许&lt;code&gt;2019-05-01T00:00:00+08:00[Asia/Shanghai]&lt;/code&gt;之前的请求，那么只需要改为：&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;server 
  port: 9091
spring:
  cloud:
    gateway:
      routes:
       - id: datetime_before_route
        uri: http://www.throwable.club
        predicates:
         - Before=2019-05-01T00:00:00+08:00[Asia/Shanghai]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果只允许两个日期时间段之间的时间进行请求，那么只需要改为：&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;server 
  port: 9090
spring:
  cloud:
    gateway:
      routes:
       - id: datetime_between_route
        uri: http://www.throwable.club
        predicates:
         - Between=2019-05-01T00:00:00+08:00[Asia/Shanghai],2019-05-02T00:00:00+08:00[Asia/Shanghai]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么只有2019年5月1日0时到5月2日0时的请求才能正常路由。&lt;/p&gt;
&lt;h3 id=&quot;cookie路由谓词&quot;&gt;Cookie路由谓词&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;CookieRoutePredicateFactory&lt;/code&gt;需要提供两个参数，分别是Cookie的name和一个正则表达式(value)。只有在请求中的Cookie对应的name和value和Cookie路由谓词中配置的值匹配的时候，才能匹配命中进行路由。&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;server 
  port: 9090
spring:
  cloud:
    gateway:
      routes:
       - id: cookie_route
        uri: http://www.throwable.club
        predicates:
         - Cookie=doge,throwable&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;请求需要携带一个Cookie，name为doge，value需要匹配正则表达式&quot;throwable&quot;才能路由到&lt;code&gt;http://www.throwable.club&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这里尝试本地搭建一个订单&lt;code&gt;Order&lt;/code&gt;服务，基于SpringBoot2.1.4搭建，启动在9091端口：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 入口类
@RestController
@RequestMapping(path = &quot;/order&quot;)
@SpringBootApplication
public class OrderServiceApplication {

    public static void main(String[] args) {
        SpringApplication.run(OrderServiceApplication.class, args);
    }

    @GetMapping(value = &quot;/cookie&quot;)
    public ResponseEntity&amp;lt;String&amp;gt; cookie(@CookieValue(name = &quot;doge&quot;) String doge) {
        return ResponseEntity.ok(doge);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;订单服务application.yaml配置：&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;spring:
  application:
    name: order-service
server:
  port: 9091&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;网关路由配置：&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;spring:
  application:
    name: route-server
  cloud:
    gateway:
      routes:
        - id: cookie_route
          uri: http://localhost:9091
          predicates:
            - Cookie=doge,throwable&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;curl http://localhost:9090/order/cookie --cookie &quot;doge=throwable&quot;

//响应结果
throwable&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;HeaderRoutePredicateFactory&lt;/code&gt;需要提供两个参数，分别是Header的name和一个正则表达式(value)。只有在请求中的Header对应的name和value和Header路由谓词中配置的值匹配的时候，才能匹配命中进行路由。&lt;/p&gt;
&lt;p&gt;订单服务中新增一个&lt;code&gt;/header&lt;/code&gt;端点：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@RestController
@RequestMapping(path = &quot;/order&quot;)
@SpringBootApplication
public class OrderServiceApplication {

    public static void main(String[] args) {
        SpringApplication.run(OrderServiceApplication.class, args);
    }

    @GetMapping(value = &quot;/header&quot;)
    public ResponseEntity&amp;lt;String&amp;gt; header(@RequestHeader(name = &quot;accessToken&quot;) String accessToken) {
        return ResponseEntity.ok(accessToken);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;网关的路由配置如下：&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;spring:
  cloud:
    gateway:
      routes:
        - id: header_route
          uri: http://localhost:9091
          predicates:
            - Header=accessToken,Doge&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;curl -H &quot;accessToken:Doge&quot; http://localhost:9090/order/header

//响应结果
Doge&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;host路由谓词&quot;&gt;Host路由谓词&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;HostRoutePredicateFactory&lt;/code&gt;只需要指定一个主机名列表，列表中的每个元素支持Ant命名样式，使用&lt;code&gt;.&lt;/code&gt;作为分隔符，多个元素之间使用&lt;code&gt;,&lt;/code&gt;区分。Host路由谓词实际上针对的是HTTP请求头中的&lt;code&gt;Host&lt;/code&gt;属性。&lt;/p&gt;
&lt;p&gt;订单服务中新增一个&lt;code&gt;/header&lt;/code&gt;端点：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@RestController
@RequestMapping(path = &quot;/order&quot;)
@SpringBootApplication
public class OrderServiceApplication {

    public static void main(String[] args) {
        SpringApplication.run(OrderServiceApplication.class, args);
    }

    @GetMapping(value = &quot;/host&quot;)
    public ResponseEntity&amp;lt;String&amp;gt; host(@RequestHeader(name = &quot;Host&quot;) String host) {
        return ResponseEntity.ok(host);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;网关的路由配置如下：&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;spring:
  cloud:
    gateway:
      routes:
        - id: host_route
          uri: http://localhost:9091
          predicates:
            - Host=localhost:9090&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;curl http://localhost:9090/order/host

//响应结果
localhost:9091  # &amp;lt;--------- 这里要注意一下，路由到订单服务的时候，Host会被修改为localhost:9091&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其实可以定制更多样化的Host匹配模式，甚至可以支持URI模板变量。&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;- Host=www.throwable.**,**.throwable.**

- Host={sub}.throwable.club&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;请求方法路由谓词&quot;&gt;请求方法路由谓词&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;MethodRoutePredicateFactory&lt;/code&gt;只需要一个参数：要匹配的HTTP请求方法。&lt;/p&gt;
&lt;p&gt;网关的路由配置如下：&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;spring:
  cloud:
    gateway:
      routes:
        - id: method_route
          uri: http://localhost:9091
          predicates:
            - Method=GET&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样配置，所有的进入到网关的GET方法的请求都会路由到&lt;code&gt;http://localhost:9091&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;订单服务中新增一个&lt;code&gt;/get&lt;/code&gt;端点：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@GetMapping(value = &quot;/get&quot;)
public ResponseEntity&amp;lt;String&amp;gt; get() {
    return ResponseEntity.ok(&quot;get&quot;);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;curl http://localhost:9090/order/get

//响应结果
get &lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;请求路径路由谓词&quot;&gt;请求路径路由谓词&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;PathRoutePredicateFactory&lt;/code&gt;需要&lt;code&gt;PathMatcher&lt;/code&gt;模式路径列表和一个可选的标志位参数&lt;code&gt;matchOptionalTrailingSeparator&lt;/code&gt;。这个是最常用的一个路由谓词。&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;spring:
  cloud:
    gateway:
      routes:
        - id: path_route
          uri: http://localhost:9091
          predicates:
            - Path=/order/path&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@GetMapping(value = &quot;/path&quot;)
public ResponseEntity&amp;lt;String&amp;gt; path() {
    return ResponseEntity.ok(&quot;path&quot;);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;curl http://localhost:9090/order/path

//响应结果
path &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此外，可以通过&lt;code&gt;{segment}&lt;/code&gt;占位符配置路径如&lt;code&gt;/foo/1&lt;/code&gt;或&lt;code&gt;/foo/bar&lt;/code&gt;或&lt;code&gt;/bar/baz&lt;/code&gt;，如果通过这种形式配置，在匹配命中进行路由的时候，会提取路径中对应的内容并且将键值对放在&lt;code&gt;ServerWebExchange.getAttributes()&lt;/code&gt;集合中，KEY为&lt;code&gt;ServerWebExchangeUtils.URI_TEMPLATE_VARIABLES_ATTRIBUTE&lt;/code&gt;，这些提取出来的属性可以供&lt;code&gt;GatewayFilter Factories&lt;/code&gt;使用。&lt;/p&gt;
&lt;h3 id=&quot;请求查询参数路由谓词&quot;&gt;请求查询参数路由谓词&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;QueryRoutePredicateFactory&lt;/code&gt;需要一个必须的请求查询参数(param的name)以及一个可选的正则表达式(regexp)。&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;spring:
  cloud:
    gateway:
      routes:
      - id: query_route
        uri: http://localhost:9091
        predicates:
        - Query=doge,throwabl.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里配置的param就是&lt;code&gt;doge&lt;/code&gt;，正则表达式是&lt;code&gt;throwabl.&lt;/code&gt;。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@GetMapping(value = &quot;/query&quot;)
public ResponseEntity&amp;lt;String&amp;gt; query(@RequestParam(&quot;name&quot;) String doge) {
  return ResponseEntity.ok(doge);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;curl http://localhost:9090/order/query?doge=throwable

//响应结果
throwable &lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;远程ip地址路由谓词&quot;&gt;远程IP地址路由谓词&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;RemoteAddrRoutePredicateFactory&lt;/code&gt;匹配规则采用CIDR符号（IPv4或IPv6）字符串的列表（最小值为1），例如192.168.0.1/16（其中192.168.0.1是远程IP地址并且16是子网掩码）。&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;spring:
  cloud:
    gateway:
      routes:
      - id: remoteaddr_route
        uri: http://localhost:9091
        predicates:
        - RemoteAddr=127.0.0.1&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@GetMapping(value = &quot;/remote&quot;)
public ResponseEntity&amp;lt;String&amp;gt; remote() {
  return ResponseEntity.ok(&quot;remote&quot;);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;curl http://localhost:9090/order/remote

//响应结果
remote &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;关于远程IP路由这一个路由谓词其实还有很多扩展手段，这里暂时不展开。&lt;/p&gt;
&lt;h3 id=&quot;多个路由谓词组合&quot;&gt;多个路由谓词组合&lt;/h3&gt;
&lt;p&gt;因为路由配置中的&lt;code&gt;predicates&lt;/code&gt;属性其实是一个列表，可以直接添加多个路由规则：&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;spring:
  cloud:
    gateway:
      routes:
      - id: remoteaddr_route
        uri: http://localhost:9091
        predicates:
        - RemoteAddr=xxxx
        - Path=/yyyy
        - Query=zzzz,aaaa&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这些规则是用&lt;code&gt;and&lt;/code&gt;逻辑组合的，例如上面的例子相当于：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;request = ...
if(request.getRemoteAddr == 'xxxx' &amp;amp;&amp;amp; request.getPath match '/yyyy' &amp;amp;&amp;amp; request.getQuery('zzzz') match 'aaaa') {
    return true;
}
return false;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;gatewayfilter工厂&quot;&gt;GatewayFilter工厂&lt;/h2&gt;
&lt;p&gt;路由过滤器&lt;code&gt;GatewayFilter&lt;/code&gt;允许修改进来的HTTP请求内容或者返回的HTTP响应内容。路由过滤器的作用域是一个具体的路由配置。&lt;code&gt;Spring Cloud Gateway&lt;/code&gt;提供了丰富的内建的&lt;code&gt;GatewayFilter&lt;/code&gt;工厂，可以按需选用。&lt;/p&gt;
&lt;p&gt;因为&lt;code&gt;GatewayFilter&lt;/code&gt;工厂类实在太多，笔者这里举个简单的例子。&lt;/p&gt;
&lt;p&gt;如果我们想对某些请求附加特殊的HTTP请求头，可以选用&lt;code&gt;AddRequestHeaderX-Request-Foo:Bar&lt;/code&gt;，&lt;code&gt;application.yml&lt;/code&gt;如下：&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;spring:
  cloud:
    gateway:
      routes:
      - id: add_request_header_route
        uri: https://example.org
        filters:
        - AddRequestHeader=X-Request-Foo,Bar&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么所有的从网关入口的HTTP请求都会添加一个特殊的HTTP请求头：&lt;code&gt;X-Request-Foo:Bar&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;目前&lt;code&gt;GatewayFilter&lt;/code&gt;工厂的内建实现如下：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;37&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;StripPrefix&lt;/td&gt;
&lt;td&gt;StripPrefixGatewayFilterFactory&lt;/td&gt;
&lt;td&gt;pre&lt;/td&gt;
&lt;td&gt;移除请求URL路径的第一部分，例如原始请求路径是/order/query，处理后是/query&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;SetStatus&lt;/td&gt;
&lt;td&gt;SetStatusGatewayFilterFactory&lt;/td&gt;
&lt;td&gt;post&lt;/td&gt;
&lt;td&gt;设置请求响应的状态码，会从org.springframework.http.HttpStatus中解析&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;SetResponseHeader&lt;/td&gt;
&lt;td&gt;SetResponseHeaderGatewayFilterFactory&lt;/td&gt;
&lt;td&gt;post&lt;/td&gt;
&lt;td&gt;设置(添加)请求响应的响应头&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;SetRequestHeader&lt;/td&gt;
&lt;td&gt;SetRequestHeaderGatewayFilterFactory&lt;/td&gt;
&lt;td&gt;pre&lt;/td&gt;
&lt;td&gt;设置(添加)请求头&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;SetPath&lt;/td&gt;
&lt;td&gt;SetPathGatewayFilterFactory&lt;/td&gt;
&lt;td&gt;pre&lt;/td&gt;
&lt;td&gt;设置(覆盖)请求路径&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;SecureHeader&lt;/td&gt;
&lt;td&gt;SecureHeadersGatewayFilterFactory&lt;/td&gt;
&lt;td&gt;pre&lt;/td&gt;
&lt;td&gt;设置安全相关的请求头，见SecureHeadersProperties&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;SaveSession&lt;/td&gt;
&lt;td&gt;SaveSessionGatewayFilterFactory&lt;/td&gt;
&lt;td&gt;pre&lt;/td&gt;
&lt;td&gt;保存WebSession&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;RewriteResponseHeader&lt;/td&gt;
&lt;td&gt;RewriteResponseHeaderGatewayFilterFactory&lt;/td&gt;
&lt;td&gt;post&lt;/td&gt;
&lt;td&gt;重新响应头&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;RewritePath&lt;/td&gt;
&lt;td&gt;RewritePathGatewayFilterFactory&lt;/td&gt;
&lt;td&gt;pre&lt;/td&gt;
&lt;td&gt;重写请求路径&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;Retry&lt;/td&gt;
&lt;td&gt;RetryGatewayFilterFactory&lt;/td&gt;
&lt;td&gt;pre&lt;/td&gt;
&lt;td&gt;基于条件对请求进行重试&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;RequestSize&lt;/td&gt;
&lt;td&gt;RequestSizeGatewayFilterFactory&lt;/td&gt;
&lt;td&gt;pre&lt;/td&gt;
&lt;td&gt;限制请求的大小，单位是byte，超过设定值返回&lt;code&gt;413 Payload Too Large&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;RequestRateLimiter&lt;/td&gt;
&lt;td&gt;RequestRateLimiterGatewayFilterFactory&lt;/td&gt;
&lt;td&gt;pre&lt;/td&gt;
&lt;td&gt;限流&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;6&quot;&gt;&lt;td&gt;RequestHeaderToRequestUri&lt;/td&gt;
&lt;td&gt;RequestHeaderToRequestUriGatewayFilterFactory&lt;/td&gt;
&lt;td&gt;pre&lt;/td&gt;
&lt;td&gt;通过请求头的值改变请求URL&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;RemoveResponseHeader&lt;/td&gt;
&lt;td&gt;RemoveResponseHeaderGatewayFilterFactory&lt;/td&gt;
&lt;td&gt;post&lt;/td&gt;
&lt;td&gt;移除配置的响应头&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;RemoveRequestHeader&lt;/td&gt;
&lt;td&gt;RemoveRequestHeaderGatewayFilterFactory&lt;/td&gt;
&lt;td&gt;pre&lt;/td&gt;
&lt;td&gt;移除配置的请求头&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;RedirectTo&lt;/td&gt;
&lt;td&gt;RedirectToGatewayFilterFactory&lt;/td&gt;
&lt;td&gt;pre&lt;/td&gt;
&lt;td&gt;重定向，需要指定HTTP状态码和重定向URL&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;PreserveHostHeader&lt;/td&gt;
&lt;td&gt;PreserveHostHeaderGatewayFilterFactory&lt;/td&gt;
&lt;td&gt;pre&lt;/td&gt;
&lt;td&gt;设置请求携带的属性preserveHostHeader为true&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;PrefixPath&lt;/td&gt;
&lt;td&gt;PrefixPathGatewayFilterFactory&lt;/td&gt;
&lt;td&gt;pre&lt;/td&gt;
&lt;td&gt;请求路径添加前置路径&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Hystrix&lt;/td&gt;
&lt;td&gt;HystrixGatewayFilterFactory&lt;/td&gt;
&lt;td&gt;pre&lt;/td&gt;
&lt;td&gt;整合Hystrix&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;FallbackHeaders&lt;/td&gt;
&lt;td&gt;FallbackHeadersGatewayFilterFactory&lt;/td&gt;
&lt;td&gt;pre&lt;/td&gt;
&lt;td&gt;Hystrix执行如果命中降级逻辑允许通过请求头携带异常明细信息&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;AddResponseHeader&lt;/td&gt;
&lt;td&gt;AddResponseHeaderGatewayFilterFactory&lt;/td&gt;
&lt;td&gt;post&lt;/td&gt;
&lt;td&gt;添加响应头&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;AddRequestParameter&lt;/td&gt;
&lt;td&gt;AddRequestParameterGatewayFilterFactory&lt;/td&gt;
&lt;td&gt;pre&lt;/td&gt;
&lt;td&gt;添加请求参数，仅仅限于URL的Query参数&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;AddRequestHeader&lt;/td&gt;
&lt;td&gt;AddRequestHeaderGatewayFilterFactory&lt;/td&gt;
&lt;td&gt;pre&lt;/td&gt;
&lt;td&gt;添加请求头&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;code&gt;GatewayFilter&lt;/code&gt;工厂使用的时候需要知道其ID以及配置方式，配置方式可以看对应工厂类的公有静态内部类&lt;code&gt;XXXXConfig&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;globalfilter工厂&quot;&gt;GlobalFilter工厂&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;GlobalFilter&lt;/code&gt;的功能其实和&lt;code&gt;GatewayFilter&lt;/code&gt;是相同的，只是&lt;code&gt;GlobalFilter&lt;/code&gt;的作用域是所有的路由配置，而不是绑定在指定的路由配置上。多个&lt;code&gt;GlobalFilter&lt;/code&gt;可以通过&lt;code&gt;@Order&lt;/code&gt;或者&lt;code&gt;getOrder()&lt;/code&gt;方法指定每个&lt;code&gt;GlobalFilter&lt;/code&gt;的执行顺序，order值越小，&lt;code&gt;GlobalFilter&lt;/code&gt;执行的优先级越高。&lt;/p&gt;
&lt;p&gt;注意，由于过滤器有pre和post两种类型，pre类型过滤器如果order值越小，那么它就应该在pre过滤器链的顶层，post类型过滤器如果order值越小，那么它就应该在pre过滤器链的底层。示意图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/201905/s-c-g-e-3.png&quot; alt=&quot;s-c-g-e-3.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;例如要实现负载均衡的功能，&lt;code&gt;application.yml&lt;/code&gt;配置如下：&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;spring:
  cloud:
    gateway:
      routes:
      - id: myRoute
        uri: lb://myservice   # &amp;lt;-------- lb特殊标记会使用LoadBalancerClient搜索目标服务进行负载均衡
        predicates:
        - Path=/service/**&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;目前&lt;code&gt;Spring Cloud Gateway&lt;/code&gt;提供的内建的&lt;code&gt;GlobalFilter&lt;/code&gt;如下：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;ForwardRoutingFilter&lt;/td&gt;
&lt;td&gt;重定向&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;LoadBalancerClientFilter&lt;/td&gt;
&lt;td&gt;负载均衡&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;NettyRoutingFilter&lt;/td&gt;
&lt;td&gt;Netty的HTTP客户端的路由&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;NettyWriteResponseFilter&lt;/td&gt;
&lt;td&gt;Netty响应进行写操作&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;RouteToRequestUrlFilter&lt;/td&gt;
&lt;td&gt;基于路由配置更新URL&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;WebsocketRoutingFilter&lt;/td&gt;
&lt;td&gt;Websocket请求转发到下游&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;内建的&lt;code&gt;GlobalFilter&lt;/code&gt;大多数和&lt;code&gt;ServerWebExchangeUtils&lt;/code&gt;的属性相关，这里就不深入展开。&lt;/p&gt;
&lt;h2 id=&quot;跨域配置&quot;&gt;跨域配置&lt;/h2&gt;
&lt;p&gt;网关可以通过配置来控制全局的CORS行为。全局的CORS配置对应的类是&lt;code&gt;CorsConfiguration&lt;/code&gt;，这个配置是一个URL模式的映射。例如&lt;code&gt;application.yaml&lt;/code&gt;文件如下：&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;spring:
  cloud:
    gateway:
      globalcors:
        corsConfigurations:
          '[/**]':
            allowedOrigins: &quot;https://docs.spring.io&quot;
            allowedMethods:
            - GET&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在上面的示例中，对于所有请求的路径，将允许来自&lt;code&gt;docs.spring.io&lt;/code&gt;并且是GET方法的CORS请求。&lt;/p&gt;
&lt;h2 id=&quot;actuator端点相关&quot;&gt;Actuator端点相关&lt;/h2&gt;
&lt;p&gt;引入&lt;code&gt;spring-boot-starter-actuator&lt;/code&gt;，需要做以下配置开启&lt;code&gt;gateway&lt;/code&gt;监控端点：&lt;/p&gt;
&lt;pre class=&quot;properties&quot;&gt;
&lt;code&gt;management.endpoint.gateway.enabled=true 
management.endpoints.web.exposure.include=gateway&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;目前支持的端点列表：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;12&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;globalfilters&lt;/td&gt;
&lt;td&gt;/actuator/gateway/globalfilters&lt;/td&gt;
&lt;td&gt;GET&lt;/td&gt;
&lt;td&gt;展示路由配置中的GlobalFilter列表&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;routefilters&lt;/td&gt;
&lt;td&gt;/actuator/gateway/routefilters&lt;/td&gt;
&lt;td&gt;GET&lt;/td&gt;
&lt;td&gt;展示绑定到对应路由配置的GatewayFilter列表&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;refresh&lt;/td&gt;
&lt;td&gt;/actuator/gateway/refresh&lt;/td&gt;
&lt;td&gt;POST&lt;/td&gt;
&lt;td&gt;清空路由配置缓存&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;routes&lt;/td&gt;
&lt;td&gt;/actuator/gateway/routes&lt;/td&gt;
&lt;td&gt;GET&lt;/td&gt;
&lt;td&gt;展示已经定义的路由配置列表&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;routes/{id}&lt;/td&gt;
&lt;td&gt;/actuator/gateway/routes/{id}&lt;/td&gt;
&lt;td&gt;GET&lt;/td&gt;
&lt;td&gt;展示对应ID已经定义的路由配置&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;routes/{id}&lt;/td&gt;
&lt;td&gt;/actuator/gateway/routes/{id}&lt;/td&gt;
&lt;td&gt;POST&lt;/td&gt;
&lt;td&gt;添加一个新的路由配置&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;routes/{id}&lt;/td&gt;
&lt;td&gt;/actuator/gateway/routes/{id}&lt;/td&gt;
&lt;td&gt;DELETE&lt;/td&gt;
&lt;td&gt;删除指定ID的路由配置&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;其中&lt;code&gt;/actuator/gateway/routes/{id}&lt;/code&gt;添加一个新的路由配置请求参数的格式如下：&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
  &quot;id&quot;: &quot;first_route&quot;,
  &quot;predicates&quot;: [{
    &quot;name&quot;: &quot;Path&quot;,
    &quot;args&quot;: {&quot;doge&quot;:&quot;/throwable&quot;}
  }],
  &quot;filters&quot;: [],
  &quot;uri&quot;: &quot;https://www.throwable.club&quot;,
  &quot;order&quot;: 0
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;笔者虽然是一个底层的码畜，但是很久之前就向身边的朋友说：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;反应式编程结合同步非阻塞IO或者异步非阻塞IO是目前网络编程框架的主流方向，最好要跟上主流的步伐掌握这些框架的使用，有能力最好成为它们的贡献者。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;目前常见的反应式编程框架有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://projectreactor.io/&quot;&gt;Reactor&lt;/a&gt;和&lt;code&gt;RxJava2&lt;/code&gt;，其中&lt;code&gt;Reactor&lt;/code&gt;在后端的JVM应用比较常见，&lt;code&gt;RxJava2&lt;/code&gt;在安卓编写的APP客户端比较常见。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Reactor-Netty&lt;/code&gt;，这个是基于&lt;code&gt;Reactor&lt;/code&gt;和&lt;code&gt;Netty&lt;/code&gt;封装的。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Spring-WebFlux&lt;/code&gt;和&lt;code&gt;Spring-Cloud-Gateway&lt;/code&gt;，其中&lt;code&gt;Spring-Cloud-Gateway&lt;/code&gt;依赖&lt;code&gt;Spring-WebFlux&lt;/code&gt;，而&lt;code&gt;Spring-WebFlux&lt;/code&gt;底层依赖于&lt;code&gt;Reactor-Netty&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;根据这个链式关系，最好系统学习一下&lt;code&gt;Reactor&lt;/code&gt;和&lt;code&gt;Netty&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;h2 id=&quot;附录&quot;&gt;附录&lt;/h2&gt;
&lt;p&gt;选用&lt;code&gt;Spring-Cloud-Gateway&lt;/code&gt;不仅仅是为了使用新的技术，更重要的是它的性能有了不俗的提升，基准测试项目&lt;a href=&quot;https://github.com/spencergibb/spring-cloud-gateway-bench&quot;&gt;spring-cloud-gateway-bench&lt;/a&gt;的结果如下：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Spring Cloud Gateway&lt;/td&gt;
&lt;td&gt;6.61ms&lt;/td&gt;
&lt;td&gt;32213.38&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;Linkered&lt;/td&gt;
&lt;td&gt;7.62ms&lt;/td&gt;
&lt;td&gt;28050.76&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Zuul(1.x)&lt;/td&gt;
&lt;td&gt;12.56ms&lt;/td&gt;
&lt;td&gt;20800.13&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;None(直接调用)&lt;/td&gt;
&lt;td&gt;2.09ms&lt;/td&gt;
&lt;td&gt;116841.15&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;原文链接&quot;&gt;原文链接&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;Github Page：http://www.throwable.club/2019/05/04/spring-cloud-gateway-guide&lt;/li&gt;
&lt;li&gt;Coding Page：http://throwable.coding.me/2019/05/04/spring-cloud-gateway-guide&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;(本文完 c-3-d e-a-20190504)&lt;/p&gt;
</description>
<pubDate>Sat, 04 May 2019 02:42:00 +0000</pubDate>
<dc:creator>throwable</dc:creator>
<og:description>Spring Cloud Gateway入坑记 前提 最近在做老系统的重构，重构完成后新系统中需要引入一个网关服务，作为新系统和老系统接口的适配和代理。之前，很多网关应用使用的是 基于 版本实现的那套</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/throwable/p/10807704.html</dc:identifier>
</item>
<item>
<title>Python机器学习笔记 Grid SearchCV（网格搜索） - 战争热诚</title>
<link>http://www.cnblogs.com/wj-1314/p/10422159.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wj-1314/p/10422159.html</guid>
<description>&lt;p&gt;　　在机器学习模型中，需要人工选择的参数称为超参数。比如随机森林中决策树的个数，人工神经网络模型中隐藏层层数和每层的节点个数，正则项中常数大小等等，他们都需要事先指定。超参数选择不恰当，就会出现欠拟合或者过拟合的问题。而在选择超参数的时候，有两个途径，一个是凭经验微调，另一个就是选择不同大小的参数，带入模型中，挑选表现最好的参数。&lt;/p&gt;
&lt;p&gt;　　微调的一种方法是手工调制超参数，直到找到一个好的超参数组合，这么做的话会非常冗长，你也可能没有时间探索多种组合，所以可以使用Scikit-Learn的GridSearchCV来做这项搜索工作。下面让我们一一探索。&lt;/p&gt;
&lt;h3&gt;1，为什么叫网格搜索（GridSearchCV）？&lt;/h3&gt;
&lt;p&gt;　　GridSearchCV的名字其实可以拆分为两部分，GridSearch和CV，即网格搜索和交叉验证。这两个名字都非常好理解。网格搜索，搜索的是参数，即在指定的参数范围内，按步长依次调整参数，利用调整的参数训练学习器，从所有的参数中找到在验证集上精度最高的参数，这其实是一个训练和比较的过程。&lt;/p&gt;
&lt;p&gt;　　GridSearchCV可以保证在指定的参数范围内找到精度最高的参数，但是这也是网格搜索的缺陷所在，他要求遍历所有可能参数的组合，在面对大数据集和多参数的情况下，非常耗时。&lt;/p&gt;

&lt;h3&gt;2，什么是Grid Search网格搜索？&lt;/h3&gt;
&lt;p&gt;　　Grid Search：一种调参手段；穷举搜索：在所有候选的参数选择中，通过循环遍历，尝试每一种可能性，表现最好的参数就是最终的结果。其原理就像是在数组里找到最大值。这种方法的主要缺点是比较耗时！&lt;/p&gt;
&lt;p&gt;　　所以网格搜索适用于三四个（或者更少）的超参数（当超参数的数量增长时，网格搜索的计算复杂度会呈现指数增长，这时候则使用随机搜索），用户列出一个较小的超参数值域，这些超参数至于的笛卡尔积（排列组合）为一组组超参数。网格搜索算法使用每组超参数训练模型并挑选验证集误差最小的超参数组合。&lt;/p&gt;
&lt;h4&gt;2.1，以随机森林为例说明GridSearch网格搜索&lt;/h4&gt;
&lt;p&gt;　　下面代码，我们要搜索两种网格，一种是n_estimators，一种是max_features。GridSearch会挑选出最适合的超参数值。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;52&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
from sklearn.model_selection import GridSearchCV
param_grid = [
{'n_estimators': [3, 10, 30], 'max_features': [2, 4, 6, 8]},
{'bootstrap': [False], 'n_estimators': [3, 10], 'max_features': [2, 3, 4]},
]

forest_reg = RandomForestRegressor()
grid_search = GridSearchCV(forest_reg, param_grid, cv=5,
                          scoring='neg_mean_squared_error')

grid_search.fit(housing_prepared, housing_labels)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　sklearn 根据param_grid的值，首先会评估3×4=12种n_estimators和max_features的组合方式，接下来在会在bootstrap=False的情况下（默认该值为True），评估2×3=6种12种n_estimators和max_features的组合方式，所以最终会有12+6=18种不同的超参数组合方式,而每一种组合方式要在训练集上训练5次， 所以一共要训练18×5=90 次，当训练结束后，你可以通过best_params_获得最好的组合方式。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
grid_search.best_params_
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　输出结果如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
{‘max_features’: 8, ‘n_estimators’: 30}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　得到最好的模型：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
grid_search.best_estimator_
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　输出如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;50&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
RandomForestRegressor(bootstrap=True, criterion=‘mse’, max_depth=None,
max_features=8, max_leaf_nodes=None, min_impurity_decrease=0.0,
min_impurity_split=None, min_samples_leaf=1,
min_samples_split=2, min_weight_fraction_leaf=0.0,
n_estimators=30, n_jobs=1, oob_score=False, random_state=None,
verbose=0, warm_start=False)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　如果GridSearchCV初始化时，refit=True（默认的初始化值）,在交叉验证时，一旦发现最好的模型（estimator）,将会在整个训练集上重新训练，这通常是一个好主意，因为使用更多的数据集会提升模型的性能。&lt;/p&gt;
&lt;p&gt;　　以上面有两个参数的模型为例，参数a有3中可能，参数b有4种可能，把所有可能性列出来，可以表示成一个3*4的表格，其中每个cell就是一个网格，循环过程就像是在每个网格里遍历，搜索，所以叫grid search。&lt;/p&gt;

&lt;h4&gt;2.2，以Xgboost为例说明GridSearch网格搜索&lt;/h4&gt;
&lt;p&gt;　　下面以阿里IJCAI广告推荐数据集与XgboostClassifier分类器为例，用代码形式说明sklearn中GridSearchCV的使用方法。（此小例的代码是参考这里：&lt;a href=&quot;https://blog.csdn.net/juezhanangle/article/details/80051256&quot; target=&quot;_blank&quot;&gt;请点击我&lt;/a&gt;）&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;61&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
import numpy as np
import pandas as pd
import xgboost as xgb
from sklearn.grid_search import GridSearchCV
 
 
#导入训练数据
traindata = pd.read_csv(&quot;/traindata_4_3.txt&quot;,sep = ',')
traindata = traindata.set_index('instance_id')
trainlabel = traindata['is_trade']
del traindata['is_trade']
print(traindata.shape,trainlabel.shape)
 
 
#分类器使用 xgboost
clf1 = xgb.XGBClassifier()
 
#设定网格搜索的xgboost参数搜索范围，值搜索XGBoost的主要6个参数
param_dist = {
        'n_estimators':range(80,200,4),
        'max_depth':range(2,15,1),
        'learning_rate':np.linspace(0.01,2,20),
        'subsample':np.linspace(0.7,0.9,20),
        'colsample_bytree':np.linspace(0.5,0.98,10),
        'min_child_weight':range(1,9,1)
        }


#GridSearchCV参数说明，clf1设置训练的学习器
#param_dist字典类型，放入参数搜索范围
#scoring = 'neg_log_loss'，精度评价方式设定为“neg_log_loss“
#n_iter=300，训练300次，数值越大，获得的参数精度越大，但是搜索时间越长
#n_jobs = -1，使用所有的CPU进行训练，默认为1，使用1个CPU
grid = GridSearchCV(clf1,param_dist,cv = 3,scoring = 'neg_log_loss',n_iter=300,n_jobs = -1)
 
#在训练集上训练
grid.fit(traindata.values,np.ravel(trainlabel.values))
#返回最优的训练器
best_estimator = grid.best_estimator_
print(best_estimator)
#输出最优训练器的精度
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这里关于网格搜索的几个参数在说明一下，评分参数“scoring”，需要根据实际的评价标准设定，阿里的IJCAI的标准时“neg_log_loss”，所以这里设定为“neg_log_loss”，sklearn中备选的评价标准如下：在一些情况下，sklearn中没有现成的评价函数，sklearn是允许我们自定义的，但是需要注意格式。&lt;/p&gt;
&lt;p&gt;　　接下来看一下我们定义的评价函数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;42&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
import numpy as np
from sklearn.metrics import make_scorer
 
def logloss(act, pred):
    epsilon = 1e-15
    pred = sp.maximum(epsilon, pred)
    pred = sp.minimum(1-epsilon, pred)
    ll = sum(act*sp.log(pred) + sp.subtract(1, act)*sp.log(sp.subtract(1, pred)))
    ll = ll * -1.0/len(act)
    return ll
 
#这里的greater_is_better参数决定了自定义的评价指标是越大越好还是越小越好
loss  = make_scorer(logloss, greater_is_better=False)
score = make_scorer(logloss, greater_is_better=True)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　定义好以后，再将其带入GridSearchCV函数就好。&lt;/p&gt;
&lt;p&gt;　　这里再贴一下常用的集成学习算法比较重要的需要调参的参数：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201904/1226410-20190430112339421-889015410.png&quot; alt=&quot;&quot; width=&quot;577&quot; height=&quot;430&quot;/&gt;&lt;/p&gt;

&lt;h4&gt;2.3，以SVR为例说明GridSearch网格搜索&lt;/h4&gt;
&lt;p&gt;　　以两个参数的调优过程为例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;52&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
from sklearn.datasets import load_iris
from sklearn.svm import SVC
from sklearn.model_selection import train_test_split

iris_data = load_iris()
X_train,X_test,y_train,y_test = train_test_split(iris_data.data,iris_data.target,random_state=0)

# grid search start
best_score = 0
for gamma in [0.001,0.01,1,10,100]:
    for c in [0.001,0.01,1,10,100]:
        # 对于每种参数可能的组合，进行一次训练
        svm = SVC(gamma=gamma,C=c)
        svm.fit(X_train,y_train)
        score = svm.score(X_test,y_test)
        # 找到表现最好的参数
        if score &amp;gt; best_score:
            best_score = score
            best_parameters = {'gamma':gamma,&quot;C&quot;:c}

print('Best socre:{:.2f}'.format(best_score))
print('Best parameters:{}'.format(best_parameters))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　输出结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
Best socre:0.97
Best parameters:{'gamma': 0.001, 'C': 100}
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;2.4  上面调参存在的问题是什么呢？&lt;/h4&gt;
&lt;p&gt;　　原始数据集划分成训练集和测试集以后，其中测试集除了用作调整参数，也用来测量模型的好坏；这样做导致最终的评分结果比实际效果好。（因为测试集在调参过程中，送到了模型里，而我们的目的是将训练模型应用到unseen data上）。&lt;/p&gt;
&lt;h4&gt;2.5  解决方法是什么呢？&lt;/h4&gt;
&lt;p&gt;　　对训练集再进行一次划分，分为训练集和验证集，这样划分的结果就是：原始数据划分为3份，分别为：训练集，验证集和测试集；其中训练集用来模型训练，验证集用来调整参数，而测试集用来衡量模型表现好坏。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201902/1226410-20190223134944232-1298995594.png&quot; alt=&quot;&quot; width=&quot;571&quot; height=&quot;78&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;64&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
from sklearn.datasets import load_iris
from sklearn.svm import SVC
from sklearn.model_selection import train_test_split

iris_data = load_iris()
# X_train,X_test,y_train,y_test = train_test_split(iris_data.data,iris_data.target,random_state=0)
X_trainval,X_test,y_trainval,y_test = train_test_split(iris_data.data,iris_data.target,random_state=0)
X_train ,X_val,y_train,y_val = train_test_split(X_trainval,y_trainval,random_state=1)
# grid search start
best_score = 0
for gamma in [0.001,0.01,1,10,100]:
    for c in [0.001,0.01,1,10,100]:
        # 对于每种参数可能的组合，进行一次训练
        svm = SVC(gamma=gamma,C=c)
        svm.fit(X_train,y_train)
        score = svm.score(X_val,y_val)
        # 找到表现最好的参数
        if score &amp;gt; best_score:
            best_score = score
            best_parameters = {'gamma':gamma,&quot;C&quot;:c}

# 使用最佳参数，构建新的模型
svm = SVC(**best_parameters)

# 使用训练集和验证集进行训练 more data always resultd in good performance
svm.fit(X_trainval,y_trainval)

# evalyation 模型评估
test_score = svm.score(X_test,y_test)

print('Best socre:{:.2f}'.format(best_score))
print('Best parameters:{}'.format(best_parameters))
print('Best score on test set:{:.2f}'.format(test_score))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
Best socre:0.96
Best parameters:{'gamma': 0.001, 'C': 10}
Best score on test set:0.92
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　然而，这种简洁的grid search方法，其最终的表现好坏与初始数据的划分结果有很大的关系，为了处理这种情况，我们采用交叉验证的方式来减少偶然性。&lt;/p&gt;

&lt;h4&gt;2.6，交叉验证改进SVM代码（Grid Search with Cross Validation）&lt;/h4&gt;
&lt;p&gt; 　　代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;66&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
from sklearn.datasets import load_iris
from sklearn.svm import SVC
from sklearn.model_selection import train_test_split,cross_val_score

iris_data = load_iris()
# X_train,X_test,y_train,y_test = train_test_split(iris_data.data,iris_data.target,random_state=0)
X_trainval,X_test,y_trainval,y_test = train_test_split(iris_data.data,iris_data.target,random_state=0)
X_train ,X_val,y_train,y_val = train_test_split(X_trainval,y_trainval,random_state=1)
# grid search start
best_score = 0
for gamma in [0.001,0.01,1,10,100]:
    for c in [0.001,0.01,1,10,100]:
        # 对于每种参数可能的组合，进行一次训练
        svm = SVC(gamma=gamma,C=c)
        # 5 折交叉验证
        scores = cross_val_score(svm,X_trainval,y_trainval,cv=5)
        score = scores.mean()
        # 找到表现最好的参数
        if score &amp;gt; best_score:
            best_score = score
            best_parameters = {'gamma':gamma,&quot;C&quot;:c}

# 使用最佳参数，构建新的模型
svm = SVC(**best_parameters)

# 使用训练集和验证集进行训练 more data always resultd in good performance
svm.fit(X_trainval,y_trainval)

# evalyation 模型评估
test_score = svm.score(X_test,y_test)

print('Best socre:{:.2f}'.format(best_score))
print('Best parameters:{}'.format(best_parameters))
print('Best score on test set:{:.2f}'.format(test_score))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
Best socre:0.97
Best parameters:{'gamma': 0.01, 'C': 100}
Best score on test set:0.97
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　交叉验证经常与网络搜索进行结合，作为参数评价的一种方法，这种方法叫做grid search with cross validation。&lt;/p&gt;
&lt;p&gt;　　sklearn因此设计了一个这样的类GridSearchCV，这个类实现fit，predict，score等方法。被当做一个estimator，使用fit方法，该过程中：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;（1） 搜索到最佳参数&lt;/li&gt;
&lt;li&gt;（2）实例化了一个最佳参数的estimator&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;3，RandomizedSearchCV——（随机搜索）&lt;/h3&gt;
&lt;p&gt;　　文献地址可以参考：&lt;a href=&quot;%20http://www.jmlr.org/papers/volume13/bergstra12a/bergstra12a.pdf&quot; target=&quot;_blank&quot;&gt;请点击我&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　所谓的模型配置，一般统称为模型的超参数（Hyperparameters），比如KNN算法中的K值，SVM中不同的核函数（Kernal）等。多数情况下，超参数等选择是无限的。在有限的时间内，除了可以验证人工预设几种超参数组合以外，也可以通过启发式的搜索方法对超参数组合进行调优。称这种启发式的超参数搜索方法为网格搜索。 &lt;/p&gt;
&lt;p&gt;　　我们在搜索超参数的时候，如果超参数个数较少（三四个或者更少），那么我们可以采用网格搜索，一种穷尽式的搜索方法。但是当超参数个数比较多的时候，我们仍然采用网格搜索，那么搜索所需时间将会指数级上升。&lt;/p&gt;
&lt;p&gt; 　　所以有人就提出了随机搜索的方法，随机在超参数空间中搜索几十几百个点，其中就有可能有比较小的值。这种做法比上面稀疏化网格的做法快，而且实验证明，随机搜索法结果比稀疏网格法稍好。&lt;/p&gt;
&lt;p class=&quot;title-article&quot;&gt;　　RandomizedSearchCV使用方法和类GridSearchCV 很相似，但他不是尝试所有可能的组合，而是通过选择每一个超参数的一个随机值的特定数量的随机组合，这个方法有两个优点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果你让随机搜索运行， 比如1000次，它会探索每个超参数的1000个不同的值（而不是像网格搜索那样，只搜索每个超参数的几个值）&lt;/li&gt;
&lt;li&gt;你可以方便的通过设定搜索次数，控制超参数搜索的计算量。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　RandomizedSearchCV的使用方法其实是和GridSearchCV一致的，但它以随机在参数空间中采样的方式代替了GridSearchCV对于参数的网格搜索，在对于有连续变量的参数时，RandomizedSearchCV会将其当做一个分布进行采样进行这是网格搜索做不到的，它的搜索能力取决于设定的n_iter参数，同样的给出代码。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201904/1226410-20190430100650150-385702207.png&quot; alt=&quot;&quot; width=&quot;472&quot; height=&quot;230&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;61&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
import numpy as np
import pandas as pd
import xgboost as xgb
from sklearn.grid_search import RandomizedSearchCV
 
 
#导入训练数据
traindata = pd.read_csv(&quot;/traindata.txt&quot;,sep = ',')
traindata = traindata.set_index('instance_id')
trainlabel = traindata['is_trade']
del traindata['is_trade']
print(traindata.shape,trainlabel.shape)
 
 
#分类器使用 xgboost
clf1 = xgb.XGBClassifier()
 
#设定搜索的xgboost参数搜索范围，值搜索XGBoost的主要6个参数
param_dist = {
        'n_estimators':range(80,200,4),
        'max_depth':range(2,15,1),
        'learning_rate':np.linspace(0.01,2,20),
        'subsample':np.linspace(0.7,0.9,20),
        'colsample_bytree':np.linspace(0.5,0.98,10),
        'min_child_weight':range(1,9,1)
        }
 
#RandomizedSearchCV参数说明，clf1设置训练的学习器
#param_dist字典类型，放入参数搜索范围
#scoring = 'neg_log_loss'，精度评价方式设定为“neg_log_loss“
#n_iter=300，训练300次，数值越大，获得的参数精度越大，但是搜索时间越长
#n_jobs = -1，使用所有的CPU进行训练，默认为1，使用1个CPU
grid = RandomizedSearchCV(clf1,param_dist,cv = 3,scoring = 'neg_log_loss',n_iter=300,n_jobs = -1)
 
#在训练集上训练
grid.fit(traindata.values,np.ravel(trainlabel.values))
#返回最优的训练器
best_estimator = grid.best_estimator_
print(best_estimator)
#输出最优训练器的精度
print(grid.best_score_)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　建议使用随机搜索。&lt;/p&gt;
&lt;h4&gt; 超参数搜索——网格搜索&amp;amp;并行搜索代码&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;68&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
#-*- coding:utf-8 -*-

#1.使用单线程对文本分类的朴素贝叶斯模型的超参数组合执行网格搜索

from sklearn.datasets import fetch_20newsgroups
import numpy as np 
news = fetch_20newsgroups(subset='all')
from sklearn.cross_validation import train_test_split
#取前3000条新闻文本进行数据分割
X_train,X_test,y_train,y_test=train_test_split(news.data[:3000],
                                            news.target[:3000],test_size=0.25,random_state=33)


from sklearn.svm import SVC
from sklearn.feature_extraction.text import TfidfVectorizer
#*************导入pipeline*************
from sklearn.pipeline import Pipeline
#使用Pipeline简化系统搭建流程，sklean提供的pipeline来将多个学习器组成流水线，通常流水线的形式为： 
#将数据标准化的学习器---特征提取的学习器---执行预测的学习器 
#将文本特征与分类器模型串联起来,[(),()]里有两个参数
#参数1:执行 vect = TfidfVectorizer(stop_words='english',analyzer='word')操作
#参数2:执行 svc = SVC()操作
clf = Pipeline([('vect',TfidfVectorizer(stop_words='english',analyzer='word')),('svc',SVC())])

#这里需要试验的2个超参数svc_gamma和svc_C的元素个数分别为4、3,这样我们一共有12种超参数对集合
#numpy.linspace用于创建等差数列，numpy.logspace用于创建等比数列
#logspace中，开始点和结束点是10的幂
#例如logspace(-2,1,4)表示起始数字为10^-2，结尾数字为10^1即10，元素个数为4的等比数列
#parameters变量里面的key都有一个前缀,这个前缀其实就是在Pipeline中定义的操作名。二者相结合，使我们的代码变得十分简洁。
#还有注意的是，这里对参数名是&amp;lt;两条&amp;gt;下划线 __
parameters = {'svc__gamma':np.logspace(-2,1,4),'svc__C':np.logspace(-1,1,3)}

#从sklearn.grid_search中导入网格搜索模块GridSearchCV
from sklearn.grid_search import GridSearchCV
#GridSearchCV参数解释:
#1.estimator : estimator(评估) object.
#2.param_grid : dict or list of dictionaries
#3.verbose:Controls the verbosity(冗余度): the higher, the more messages.
#4.refit:default=True, Refit(再次拟合)the best estimator with the entire dataset
#5.cv : int, cross-validation generator 此处表示3折交叉验证
gs = GridSearchCV(clf,parameters,verbose=2,refit=True,cv=3)

#执行单线程网格搜索
gs.fit(X_train,y_train)

print gs.best_params_,gs.best_score_

#最后输出最佳模型在测试集上的准确性
print 'the accuracy of best model in test set is',gs.score(X_test,y_test) 

#小结：
#1.由输出结果可知，使用单线程的网格搜索技术 对朴素贝叶斯模型在文本分类任务中的超参数组合进行调优，
#  共有12组超参数组合*3折交叉验证 =36项独立运行的计算任务
#2.在本机上，该过程一共运行了2.9min，寻找到最佳的超参数组合在测试集上达到的分类准确性为82.27%
&lt;/pre&gt;&lt;/div&gt;


&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;45&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
#2.使用多线程对文本分类的朴素贝叶斯模型的超参数组合执行网格搜索

#n_jobs=-1,表示使用该计算机的全部cpu
gs = GridSearchCV(clf,parameters,verbose=2,refit=True,cv=3,n_jobs=-1)
gs.fit(X_train,y_train)
print gs.best_params_,gs.best_score_
#输出最佳模型在测试集上的准确性
print 'the accuracy of best model in test set is',gs.score(X_test,y_test) 

#小结：
#总任务相同的情况下，使用并行搜索技术进行计算的话，执行时间只花费了1.1min；
#而且最终所得的的best_params_和score没有发生变化，说明并行搜索可以在不影响准确性的前提下，
#有效的利用计算机的CPU资源，大大节省了最佳超参数的搜索时间。
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;4， 超参数估计的随机搜索和网格搜索的比较&lt;/h3&gt;
&lt;p&gt;　　&lt;strong&gt;使用的数据集是小数据集 手写数字数据集 load_digits() 分类   数据规模 5620*64&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　（sklearn中的小数据可以直接使用，大数据集在第一次使用的时候会自动下载）&lt;/p&gt;
&lt;p&gt;　　比较随机森林超参数优化的随机搜索和网格搜索。所有影响学习的参数都是同时搜索的（除了估计值的数量，它会造成时间/质量的权衡）。&lt;/p&gt;
&lt;p&gt;　　随机搜索和网格搜索探索的是完全相同的参数空间。参数设置的结果非常相似，而随机搜索的运行时间要低的多。&lt;/p&gt;
&lt;p&gt;　　随机搜索的性能稍差，不过这很可能是噪声效应，不会延续到外置测试集&lt;/p&gt;
&lt;p&gt;　　注意：在实践中，人们不会使用网格搜索同时搜索这么多不同的参数，而是只选择那些被认为最重要的参数。&lt;/p&gt;
&lt;p&gt;　　代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;69&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
#_*_coding:utf-8_*_
# 输出文件开头注释的内容  __doc__的作用
'''
Python有个特性叫做文档字符串，即DocString ，这个特性可以让你的程序文档更加清晰易懂
'''
print(__doc__)
import numpy as np
from time import time
from scipy.stats import randint as sp_randint

from sklearn.model_selection import GridSearchCV
from sklearn.model_selection import RandomizedSearchCV
from sklearn.datasets import load_digits
from sklearn.ensemble import RandomForestClassifier

# get some  data
digits = load_digits()
X, y = digits.data , digits.target

# build a classifier
clf = RandomForestClassifier(n_estimators=20)

# utility function to report best scores
def report(results, n_top= 3):
    for i in range(1, n_top + 1):
        candidates = np.flatnonzero(results['rank_test_score'] == i)
        for candidate in candidates:
            print(&quot;Model with rank:{0}&quot;.format(i))
            print(&quot;Mean validation score : {0:.3f} (std: {1:.3f})&quot;.
                  format(results['mean_test_score'][candidate],
                         results['std_test_score'][candidate]))
            print(&quot;Parameters: {0}&quot;.format(results['params'][candidate]))
            print(&quot;&quot;)

# 指定取样的参数和分布 specify parameters and distributions to sample from
param_dist = {&quot;max_depth&quot;:[3,None],
              &quot;max_features&quot;:sp_randint(1,11),
              &quot;min_samples_split&quot;:sp_randint(2,11),
              &quot;bootstrap&quot;:[True, False],
              &quot;criterion&quot;:[&quot;gini&quot;,&quot;entropy&quot;]
              }

# run randomized search
n_iter_search = 20
random_search = RandomizedSearchCV(clf,param_distributions=param_dist,
                                   n_iter=n_iter_search,cv =5)
start = time()
random_search.fit(X, y)
print(&quot;RandomizedSearchCV took %.2f seconds for %d candidates&quot;
      &quot; parameter settings.&quot; % ((time() - start), n_iter_search))
report(random_search.cv_results_)

# use a full grid over all parameters
param_grid = {&quot;max_depth&quot;:[3,None],
              &quot;max_features&quot;:[1, 3, 10],
              &quot;min_samples_split&quot;:[2, 3, 10],
              &quot;bootstrap&quot;:[True, False],
              &quot;criterion&quot;:[&quot;gini&quot;,&quot;entropy&quot;]
    }
# run grid search
grid_search = GridSearchCV(clf, param_grid=param_grid, cv =5)
start = time()
grid_search.fit(X , y)
print(&quot;GridSearchCV took %.2f seconds for %d candidate parameter settings.&quot;
      % (time() - start, len(grid_search.cv_results_['params'])))
report(grid_search.cv_results_)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　结果如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;59&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
RandomizedSearchCV took 6.20 seconds for 20 candidates parameter settings.
Model with rank:1
Mean validation score : 0.930 (std: 0.031)
Parameters: {'bootstrap': False, 'criterion': 'entropy', 'max_depth': None, 'max_features': 6, 'min_samples_split': 5}

Model with rank:2
Mean validation score : 0.929 (std: 0.024)
Parameters: {'bootstrap': False, 'criterion': 'entropy', 'max_depth': None, 'max_features': 6, 'min_samples_split': 9}

Model with rank:3
Mean validation score : 0.924 (std: 0.020)
Parameters: {'bootstrap': False, 'criterion': 'gini', 'max_depth': None, 'max_features': 3, 'min_samples_split': 6}


Model with rank:1
Mean validation score : 0.932 (std: 0.023)
Parameters: {'bootstrap': False, 'criterion': 'gini', 'max_depth': None, 'max_features': 10, 'min_samples_split': 3}

Model with rank:2
Mean validation score : 0.931 (std: 0.014)
Parameters: {'bootstrap': False, 'criterion': 'gini', 'max_depth': None, 'max_features': 3, 'min_samples_split': 3}

Model with rank:3
Mean validation score : 0.929 (std: 0.021)
Parameters: {'bootstrap': False, 'criterion': 'entropy', 'max_depth': None, 'max_features': 3, 'min_samples_split': 2}
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;scikit-learn GridSearch库概述&lt;/h2&gt;
&lt;p&gt;sklearn的Grid Search官网地址：&lt;a href=&quot;https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.GridSearchCV.html#sklearn.model_selection.GridSearchCV&quot; target=&quot;_blank&quot;&gt;请点击我&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;1，GridSearchCV简介&lt;/h3&gt;
&lt;p&gt;　　GridSearchCV，它存在的意义就是自动调参，只要把参数输进去，就能给出最优化结果和参数。但是这个方法适合于小数据集，一旦数据的量级上去了，很难得到结果。这个时候就需要动脑筋了。数据量比较大的时候可以使用一个快速调优的方法——坐标下降。它其实是一种贪心算法：拿当前对模型影响最大的参数调参，直到最优化；再拿下一个影响最大的参数调优，如此下去，直到所有的参数调整完毕。这个方法的缺点就是可能会跳到局部最优而不是全局最优，但是省时间省力，巨大的优势面前，还是试一试，后续可以再拿bagging再优化。&lt;/p&gt;
&lt;p&gt;　　通常算法不够好，需要调试参数时必不可少。比如SVM的惩罚因子C，核函数kernel，gamma参数等，对于不同的数据使用不同的参数，结果效果可能差1~5个点，sklearn为我们专门调试参数的函数grid_search。&lt;/p&gt;
&lt;h3&gt;2，GridSearchCV参数说明&lt;/h3&gt;
&lt;p&gt;　　参数如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;45&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
class sklearn.model_selection.GridSearchCV(estimator, param_grid, scoring=None, 
fit_params=None, n_jobs=None, iid=’warn’, refit=True, cv=’warn’, verbose=0, 
pre_dispatch=‘2*n_jobs’, error_score=’raise-deprecating’, return_train_score=’warn’)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明如下：&lt;/p&gt;
&lt;p&gt;　　　　1）estimator：选择使用的分类器，并且传入除需要确定最佳的参数之外的其他参数。每一个分类器都需要一个scoring参数，或者score方法：如estimator = RandomForestClassifier(min_sample_split=100,min_samples_leaf = 20,max_depth = 8,max_features = 'sqrt' , random_state =10),&lt;/p&gt;
&lt;p&gt;　　　　2）param_grid：需要最优化的参数的取值，值为字典或者列表，例如：param_grid = param_test1,param_test1 = {'n_estimators' : range(10,71,10)}&lt;/p&gt;
&lt;p&gt;　　　　3）scoring = None ：模型评价标准，默认为None，这时需要使用score函数；或者如scoring = 'roc_auc'，根据所选模型不同，评价准则不同，字符串（函数名），或是可调用对象，需要其函数签名，形如：scorer(estimator，X，y）；如果是None，则使用estimator的误差估计函数。&lt;/p&gt;
&lt;p&gt;　　　　4）fit_para,s = None&lt;/p&gt;
&lt;p&gt;　　　　5）n_jobs = 1 ： n_jobs：并行数，int：个数，-1：跟CPU核数一致，1：默认值&lt;/p&gt;
&lt;p&gt;　　　　6）iid = True：iid：默认为True，为True时，默认为各个样本fold概率分布一致，误差估计为所有样本之和，而非各个fold的平均。&lt;/p&gt;
&lt;p&gt;　　　　7）refit = True ：默认为True，程序将会以交叉验证训练集得到的最佳参数，重新对所有可能的训练集与开发集进行，作为最终用于性能评估的最佳模型参数。即在搜索参数结束后，用最佳参数结果再次fit一遍全部数据集。&lt;/p&gt;
&lt;p&gt;　　　　8）cv = None：交叉验证参数，默认None，使用三折交叉验证。指定fold数量，默认为3，也可以是yield训练/测试数据的生成器。&lt;/p&gt;
&lt;p&gt;　　　　9）verbose = 0 ,scoring = None　　verbose：日志冗长度，int：冗长度，0：不输出训练过程，1：偶尔输出，&amp;gt;1：对每个子模型都输出。&lt;/p&gt;
&lt;p&gt;　　　　10）pre_dispatch = '2*n_jobs' ：指定总共发的并行任务数，当n_jobs大于1时候，数据将在每个运行点进行复制，这可能导致OOM，而设置pre_dispatch参数，则可以预先划分总共的job数量，使数据最多被复制pre_dispatch次。&lt;/p&gt;

&lt;h3&gt;3，进行预测的常用方法和属性&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;grid.fit()  ：运行网格搜索&lt;/li&gt;
&lt;li&gt;&lt;span&gt;grid_scores_   ：给出不同参数情况下的评价结果&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;best_params_  ：描述了已取得最佳结果的参数的组合&lt;/li&gt;
&lt;li&gt;best_score_    ：提供优化过程期间观察到的最好的评分&lt;/li&gt;
&lt;li&gt;cv_results_  ：具体用法模型不同参数下交叉验证的结果&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;4，GridSearchCV属性说明&lt;/h3&gt;
&lt;p&gt;　　　　（1） cv_results_ : dict of numpy (masked) ndarrays&lt;/p&gt;
&lt;p&gt;　　　　具有键作为列标题和值作为列的dict，可以导入到DataFrame中。注意，“params”键用于存储所有参数候选项的参数设置列表。&lt;/p&gt;
&lt;p&gt;　　　　（2） best_estimator_ : estimator&lt;/p&gt;
&lt;p&gt;　　　　通过搜索选择的估计器，即在左侧数据上给出最高分数（或指定的最小损失）的估计器。如果refit = False，则不可用。&lt;/p&gt;
&lt;p&gt;　　　　（3）best_score_ ：float  best_estimator的分数&lt;/p&gt;
&lt;p&gt;　　　　（4）best_parmas_ : dict  在保存数据上给出最佳结果的参数设置&lt;/p&gt;
&lt;p&gt;　　　　（5） best_index_ : int 对应于最佳候选参数设置的索引（cv_results_数组）&lt;/p&gt;
&lt;p&gt;　　　　search.cv_results _ ['params'] [search.best_index_]&lt;span class=&quot;js-evernote-checked&quot;&gt;中的dict&lt;span class=&quot;js-evernote-checked&quot;&gt;给出了最佳模型的参数设置，给出了最高的平均分数（search.best_score_&lt;span class=&quot;js-evernote-checked&quot;&gt;）。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　（6）scorer_ : function&lt;/p&gt;
&lt;p&gt;　　　　Scorer function used on the held out data to choose the best parameters for the model.&lt;/p&gt;
&lt;p&gt;　　　　（7）n_splits_ : int&lt;/p&gt;
&lt;p&gt;　　　　The number of cross-validation splits (folds/iterations).&lt;/p&gt;

&lt;h3&gt;3，利用决策树预测乳腺癌的例子（网格搜索算法优化）&lt;/h3&gt;
&lt;h4&gt;3.1 网格搜索算法与K折交叉验证理论知识&lt;/h4&gt;
&lt;p&gt;　　网格搜索算法是一种通过遍历给定的参数组合来优化模型表现的方法。&lt;/p&gt;
&lt;p&gt;　　以决策树为例，当我们确定了要使用决策树算法的时候，为了能够更好地拟合和预测，我们需要调整它的参数。在决策树算法中，我们通常选择的参数是决策树的最大深度。&lt;/p&gt;
&lt;p&gt;　　于是下面我们会给出一系列的最大深度的值，比如{‘max_depth’：[1,2,3,4,5] }，我们就会尽可能包含最优最大深度。&lt;/p&gt;
&lt;p&gt;　　不过我们如何知道哪个最大深度的模型是最好的呢？我们需要一种可靠的评分方法，对每个最大深度的决策树模型都进行评价，这其中非常经典的一种方法就是交叉验证，下面我们就以K折交叉验证为例，详细介绍一下其算法过程。&lt;/p&gt;
&lt;p&gt;　　首先我们先看一下数据集时如何分割的，我们拿到的原始数据集首先会按照一定的比例划分出训练集和测试集。比如下图，以8:2分割的数据集：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201902/1226410-20190225095153176-1862814495.png&quot; alt=&quot;&quot; width=&quot;454&quot; height=&quot;168&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　训练集是用来训练我们的模型，它的作用就像我们平时做的练习题；测试集用来评估我们训练好的模型表现如何，它不能被提前被模型看到。&lt;/p&gt;
&lt;p&gt;　　因此，在K折交叉验证中，我们用到的数据是训练集中的所有数据，我们将训练集的所有数据平均划分出K份（通常选择K=10），取第K份作为验证集，它的作用就像我们用来估计高考分数的模拟题，余下的K-1份作为交叉验证的训练集。&lt;/p&gt;
&lt;p&gt;　　对于我们最开始选择的决策树的5个最大深度，以max_depth=1为例，我们先用第2-10份数据作为训练集训练模型，用第一份数据作为验证集对这次训练的模型进行评分，得到第一个分数；然后重新构建一个max_depth = 1的决策树，用第1和3-10份数据作为训练集训练模型，用第2份数据作为验证集对这次训练的模型进行评分，得到第二个分数.....以此类推，最后构建一个max_depth = 1的决策树用第1-9份数据作为训练集训练模型，用第10份数据作为验证集对这次训练的模型进行评分，得到10个验证分数，然后计算着10个验证分数的平均分数，就是max_depth = 1的决策树模型的最终验证分数。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201902/1226410-20190225101032541-1168063435.png&quot; alt=&quot;&quot; width=&quot;515&quot; height=&quot;374&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　对于max_depth = 2,3,4,5时，分别进行和max_depth =1 相同的交叉验证过程，得到他们的最终验证分数，然后我们就可以对这5个最大深度的决策树的最终验证分数进行比较，分数最高的那个就是最优最大深度，我们利用最优参数在全部训练集上训练一个新的模型，整个模型就是最优模型。&lt;/p&gt;
&lt;h4&gt;3.2 简单的利用决策树预测乳腺癌的例子&lt;/h4&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;57&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
from sklearn.model_selection import GridSearchCV,KFold,train_test_split
from sklearn.metrics import make_scorer , accuracy_score
from sklearn.tree  import DecisionTreeClassifier
from sklearn.datasets import load_breast_cancer
import warnings
from sklearn.neighbors import KNeighborsClassifier as KNN

warnings.filterwarnings('ignore')

# load  data
data = load_breast_cancer()
print(data.data.shape)
print(data.target.shape)
# (569, 30)
# (569,)
X,y = data['data'] , data['target']

X_train,X_test,y_train,y_test = train_test_split(
    X,y,train_size=0.8 , random_state=0
)

regressor = DecisionTreeClassifier(random_state=0)
parameters = {'max_depth':range(1,6)}
scorin_fnc = make_scorer(accuracy_score)
kflod = KFold(n_splits=10)

grid = GridSearchCV(regressor,parameters,scorin_fnc,cv=kflod)
grid = grid.fit(X_train,y_train)
reg = grid.best_estimator_

print('best score:%f'%grid.best_score_)
print('best parameters:')
for key in parameters.keys():
    print('%s:%d'%(key,reg.get_params()[key]))

print('test score : %f'%reg.score(X_test,y_test))

# import pandas as pd
# pd.DataFrame(grid.cv_results_).T

# 引入KNN训练方法
knn = KNN()
# 进行填充测试数据进行训练
knn.fit(X_train,y_train)
params = knn.get_params()
score  = knn.score(X_test,y_test)
print(&quot;KNN 预测得分为：%s&quot;%score)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
(569, 30)
(569,)
best score:0.938462
best parameters:
max_depth:4
test score : 0.956140
KNN 预测得分为：0.9385964912280702
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;问题一：AttributeError: 'GridSearchCV' object has no attribute 'grid_scores_'&lt;/h3&gt;
&lt;h4&gt;问题描述：&lt;/h4&gt;
&lt;p&gt;　　Python运行代码的时候，到gsearch1.grid_scores_ 时报错：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
AttributeError: 'GridSearchCV' object has no attribute 'grid_scores_'
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;原因：&lt;/h4&gt;
&lt;p&gt;　　之所以出现以上问题，原因在于grid_scores_在sklearn0.20版本中已被删除，取而代之的是cv_results_。&lt;/p&gt;
&lt;h4&gt;解决方法：&lt;/h4&gt;
&lt;p&gt;　　将下面代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
a,b,c = gsearch1.grid_scores_, gsearch1.best_params_, gsearch1.best_score_
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　换成：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
a,b,c = gsearch1.cv_results_, gsearch1.best_params_, gsearch1.best_score_
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 class=&quot;title-article&quot;&gt;问题二：ModuleNotFoundError: No module named 'sklearn.grid_search'&lt;/h3&gt;
&lt;h4&gt;问题描述：&lt;/h4&gt;
&lt;p&gt;　　Python运行代码时候，到from  sklearn.grid_search import GridSearchCV时报错：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
ModuleNotFoundError: No module named 'sklearn.grid_search'
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;原因：&lt;/h4&gt;
&lt;p&gt;　　sklearn.grid_search模块在0.18版本中被弃用，它所支持的类转移到model_selection 模板中。还要注意，新的CV迭代器的接口与这个模块的接口不同，sklearn.grid_search在0.20中被删除。&lt;/p&gt;
&lt;h4&gt;解决方法：&lt;/h4&gt;
&lt;p&gt;　　将下面代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
from sklearn.grid_search import GridSearchCV
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　修改成：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
from sklearn.model_selection import GridSearchCV
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;参考文献：https://blog.51cto.com/emily18/2088128&lt;/p&gt;
&lt;p&gt;https://blog.csdn.net/jh1137921986/article/details/79827945&lt;/p&gt;
&lt;p&gt;https://blog.csdn.net/juezhanangle/article/details/80051256&lt;/p&gt;
</description>
<pubDate>Sat, 04 May 2019 02:06:00 +0000</pubDate>
<dc:creator>战争热诚</dc:creator>
<og:description>在机器学习模型中，需要人工选择的参数称为超参数。比如随机森林中决策树的个数，人工神经网络模型中隐藏层层数和每层的节点个数，正则项中常数大小等等，他们都需要事先指定。超参数选择不恰当，就会出现欠拟合或者</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wj-1314/p/10422159.html</dc:identifier>
</item>
</channel>
</rss>