<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>C# 注释 - Fode</title>
<link>http://www.cnblogs.com/fode/p/11071510.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fode/p/11071510.html</guid>
<description>&lt;p&gt;为了使用C＃提供的XML注释功能，你的注释应该使用特殊的注释语法（///）开头。在///之后，你可以使用预先定义的标签注释你的代码，也可以插入你自己定义的标签。你定制的标签将会在随后加入到生成的注释文档中。&lt;/p&gt;
&lt;p&gt; 预定义的标签 用处&lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;&amp;lt;c&amp;gt; 将说明中的文本标记为代码&lt;br/&gt;&amp;lt;code&amp;gt; 提供了一种将多行指示为代码的方法&lt;br/&gt;&amp;lt;example&amp;gt; 指定使用方法或其他库成员的示例&lt;br/&gt;&amp;lt;exception&amp;gt; 允许你指定可能发生的异常类&lt;br/&gt;&amp;lt;include&amp;gt; 允许你引用描述源代码中类型和成员的另一文件中的注释, 使用 XML XPath 语法来描述你的源代码中的类型和成员。&lt;br/&gt;&amp;lt;list&amp;gt; 向XML注释文档中插入一个列表&lt;br/&gt;&amp;lt;para&amp;gt; 向XML注释文档中插入一个段落&lt;br/&gt;&amp;lt;param&amp;gt; 描述一个参数&lt;br/&gt;&amp;lt;paramref&amp;gt; 提供了一种指示一个词为参数的方法&lt;br/&gt;&amp;lt;permission&amp;gt; 允许你将成员的访问许可加入到文档中&lt;br/&gt;&amp;lt;remarks&amp;gt; 用于添加有关某个类型的信息&lt;br/&gt;&amp;lt;returns&amp;gt; 描述返回值&lt;br/&gt;&amp;lt;see&amp;gt; 指定链接&lt;br/&gt;&amp;lt;seealso&amp;gt; 指定希望在“请参见”一节中出现的文本&lt;br/&gt;&amp;lt;summary&amp;gt; 类型或类型成员的通用描述&lt;br/&gt;&amp;lt;value&amp;gt; 描述属性&lt;/em&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 22 Jun 2019 19:15:00 +0000</pubDate>
<dc:creator>Fode</dc:creator>
<og:description>为了使用C＃提供的XML注释功能，你的注释应该使用特殊的注释语法（///）开头。在///之后，你可以使用预先定义的标签注释你的代码，也可以插入你自己定义的标签。你定制的标签将会在随后加入到生成的注释文</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/fode/p/11071510.html</dc:identifier>
</item>
<item>
<title>Bootstrap初始化过程源码分析--netty客户端的启动 - _朱葛</title>
<link>http://www.cnblogs.com/zhuge134/p/11071413.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhuge134/p/11071413.html</guid>
<description>&lt;h2 id=&quot;bootstrap初始化过程&quot;&gt;Bootstrap初始化过程&lt;/h2&gt;
&lt;p&gt;netty的客户端引导类是Bootstrap，我们看一下spark的rpc中客户端部分对Bootstrap的初始化过程&lt;/p&gt;
&lt;h3 id=&quot;transportclientfactory.createclientinetsocketaddress-address&quot;&gt;TransportClientFactory.createClient(InetSocketAddress address)&lt;/h3&gt;
&lt;p&gt;只需要贴出Bootstrap初始化部分的代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 客户端引导对象
Bootstrap bootstrap = new Bootstrap();
// 设置各种参数
bootstrap.group(workerGroup)
  .channel(socketChannelClass)
  // Disable Nagle's Algorithm since we don't want packets to wait
  // 关闭Nagle算法
  .option(ChannelOption.TCP_NODELAY, true)
  .option(ChannelOption.SO_KEEPALIVE, true)
  .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, conf.connectionTimeoutMs())
  .option(ChannelOption.ALLOCATOR, pooledAllocator);

// socket接收缓冲区
if (conf.receiveBuf() &amp;gt; 0) {
  bootstrap.option(ChannelOption.SO_RCVBUF, conf.receiveBuf());
}

// socket发送缓冲区
// 对于接收和发送缓冲区的设置应该用如下的公式计算：
// 延迟 *带宽
// 例如延迟是1ms，带宽是10Gbps，那么缓冲区大小应该设为1.25MB
if (conf.sendBuf() &amp;gt; 0) {
  bootstrap.option(ChannelOption.SO_SNDBUF, conf.sendBuf());
}

final AtomicReference&amp;lt;TransportClient&amp;gt; clientRef = new AtomicReference&amp;lt;&amp;gt;();
final AtomicReference&amp;lt;Channel&amp;gt; channelRef = new AtomicReference&amp;lt;&amp;gt;();

// 设置handler（处理器对象）
bootstrap.handler(new ChannelInitializer&amp;lt;SocketChannel&amp;gt;() {
  @Override
  public void initChannel(SocketChannel ch) {
    TransportChannelHandler clientHandler = context.initializePipeline(ch);
    clientRef.set(clientHandler.getClient());
    channelRef.set(ch);
  }
});

// Connect to the remote server
long preConnect = System.nanoTime();
// 与服务端建立连接，启动方法
ChannelFuture cf = bootstrap.connect(address);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;分为几个主要的步骤：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先创建一个Bootstrap对象，调用的是无参构造器&lt;/li&gt;
&lt;li&gt;设置各种参数，如通道类型，关闭Nagle算法，接收和发送缓冲区大小，设置处理器&lt;/li&gt;
&lt;li&gt;调用connect与服务端建立连接&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;接下来，我们主要通过两条线索来分析Bootstrap的启动过程，即构造器和connect两个方法，而对于设置参数的过程仅仅是给内部的一些成员变量赋值，所以不需要详细展开。&lt;/p&gt;
&lt;h3 id=&quot;bootstrap.bootstrap&quot;&gt;Bootstrap.Bootstrap()&lt;/h3&gt;
&lt;p&gt;Bootstrap继承了AbstractBootstrap，看了一下他们的无参构造方法，都是个空方法。。。。。。所以这一步，我们就省了，瞬间感觉飞起来了有没有^_^&lt;/p&gt;
&lt;h3 id=&quot;bootstrap.connectsocketaddress-remoteaddress&quot;&gt;Bootstrap.connect(SocketAddress remoteAddress)&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;public ChannelFuture connect(SocketAddress remoteAddress) {
    // 检查非空
    ObjectUtil.checkNotNull(remoteAddress, &quot;remoteAddress&quot;);
    // 同样是对一些成员变量检查非空，主要检查EventLoopGroup，ChannelFactory，handler对象
    validate();
    return doResolveAndConnect(remoteAddress, config.localAddress());
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;主要是做了一些非空检查，需要注意的是，ChannelFactory对象的设置，前面的spark中在对Bootstrap初始化设置的时候调用了.channel(socketChannelClass)方法，这个方法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public B channel(Class&amp;lt;? extends C&amp;gt; channelClass) {
    return channelFactory(new ReflectiveChannelFactory&amp;lt;C&amp;gt;(
            ObjectUtil.checkNotNull(channelClass, &quot;channelClass&quot;)
    ));
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建了一个ReflectiveChannelFactory对象，并赋值给内部的channelFactory成员。这个工厂类会根据传进来的Class对象通过反射创建一个Channel实例。&lt;/p&gt;
&lt;h3 id=&quot;doresolveandconnect&quot;&gt;doResolveAndConnect&lt;/h3&gt;
&lt;p&gt;从这个方法的逻辑中可以看出来，创建一个连接的过程分为两个主要的步骤;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;初始化一个Channel对象并注册到EventLoop中&lt;/li&gt;
&lt;li&gt;调用doResolveAndConnect0方法完成tcp连接的建立&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;值得注意的是，initAndRegister方法返回一个Future对象，这个类型通常用于异步机制的实现。在这里，如果注册没有立即成功的话，会给返回的futrue对象添加一个监听器，在注册成功以后建立tcp连接。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private ChannelFuture doResolveAndConnect(final SocketAddress remoteAddress, final SocketAddress localAddress) {
    // 初始化一个Channel对象并注册到EventLoop中
    final ChannelFuture regFuture = initAndRegister();
    final Channel channel = regFuture.channel();

    if (regFuture.isDone()) {
        // 如果注册失败，世界返回失败的future对象
        if (!regFuture.isSuccess()) {
            return regFuture;
        }
        return doResolveAndConnect0(channel, remoteAddress, localAddress, channel.newPromise());
    } else {// 如果注册还在进行中，需要向future对象添加一个监听器，以便在注册成功的时候做一些工作，监听器实际上就是一个回调对象
        // Registration future is almost always fulfilled already, but just in case it's not.
        final PendingRegistrationPromise promise = new PendingRegistrationPromise(channel);
        regFuture.addListener(new ChannelFutureListener() {
            @Override
            public void operationComplete(ChannelFuture future) throws Exception {
                // Directly obtain the cause and do a null check so we only need one volatile read in case of a
                // failure.
                Throwable cause = future.cause();
                if (cause != null) {
                    // Registration on the EventLoop failed so fail the ChannelPromise directly to not cause an
                    // IllegalStateException once we try to access the EventLoop of the Channel.
                    promise.setFailure(cause);
                } else {
                    // Registration was successful, so set the correct executor to use.
                    // See https://github.com/netty/netty/issues/2586
                    promise.registered();
                    // 注册成功后仍然调用doResolveAndConnect0方法完成连接建立的过程
                    doResolveAndConnect0(channel, remoteAddress, localAddress, promise);
                }
            }
        });
        return promise;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;initandregister&quot;&gt;initAndRegister&lt;/h3&gt;
&lt;p&gt;仍然分为两个步骤：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;通过channel工厂类创建一个channel对象，通过反射获取指定的channel类型的无参构造器，调用构造器来创建对象&lt;/li&gt;
&lt;li&gt;调用init方法对channel对象进行初始化，init方法是一个抽象方法，Bootstrap和ServerBootstrap的实现不同&lt;/li&gt;
&lt;li&gt;将channel注册到EventLoopGroup中&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;注意看源码中的一段注释，这段注释对netty的线程模型的理解很有帮助，大致意思是说：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果当前的代码是在EventLoopEvent线程中执行的，那么代码运行到这里说明channel已经成功注册到EventLoopEvent上了，此时再调用bind() 或 connect()方法肯定是没有问题的&lt;/li&gt;
&lt;li&gt;如果当前代码不是在EventLoopEvent线程中执行的，也就是说当前线程是另外的线程，在这里继续调用bind() 或 connect()方法仍然是安全的，并不会由于并发引起方法执行顺序的错乱，原因是netty中一个channel只会绑定到一个线程上，所有关于这个channel的操作包括注册，bind或connect都会以排队任务的形式在一个线程中串行执行，这种做法也为netty规避了很多线程安全问题，从而减少了很多加锁，同步的代码，减少了线程之间的竞争资源导致的线程切换，侧面上提高了线程执行效率。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;final ChannelFuture initAndRegister() {&lt;br/&gt;Channel channel = null;&lt;br/&gt;try {&lt;br/&gt;// 通过channel工厂类创建一个channel对象&lt;br/&gt;channel = channelFactory.newChannel();&lt;br/&gt;// 调用init方法对channel进行一些初始化的设置&lt;br/&gt;init(channel);&lt;br/&gt;} catch (Throwable t) {&lt;br/&gt;if (channel != null) {&lt;br/&gt;// channel can be null if newChannel crashed (eg SocketException(&quot;too many open files&quot;))&lt;br/&gt;channel.unsafe().closeForcibly();&lt;br/&gt;// as the Channel is not registered yet we need to force the usage of the GlobalEventExecutor&lt;br/&gt;return new DefaultChannelPromise(channel, GlobalEventExecutor.INSTANCE).setFailure(t);&lt;br/&gt;}&lt;br/&gt;// as the Channel is not registered yet we need to force the usage of the GlobalEventExecutor&lt;br/&gt;return new DefaultChannelPromise(new FailedChannel(), GlobalEventExecutor.INSTANCE).setFailure(t);&lt;br/&gt;}&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    // 注册到EventLoopGroup中
    ChannelFuture regFuture = config().group().register(channel);
    // 如果发生异常，需要关闭已经建立的连接
    if (regFuture.cause() != null) {
        if (channel.isRegistered()) {
            channel.close();
        } else {
            channel.unsafe().closeForcibly();
        }
    }

    // If we are here and the promise is not failed, it's one of the following cases:
    // 1) If we attempted registration from the event loop, the registration has been completed at this point.
    //    i.e. It's safe to attempt bind() or connect() now because the channel has been registered.
    // 2) If we attempted registration from the other thread, the registration request has been successfully
    //    added to the event loop's task queue for later execution.
    //    i.e. It's safe to attempt bind() or connect() now:
    //         because bind() or connect() will be executed *after* the scheduled registration task is executed
    //         because register(), bind(), and connect() are all bound to the same thread.
    
    return regFuture;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;niosocketchannel初始化&quot;&gt;NioSocketChannel初始化&lt;/h2&gt;
&lt;p&gt;DEFAULT_SELECTOR_PROVIDER是默认的SelectorProvider对象，这时jdk中定义的一个类，主要作用是生成选择器selector对象和通道channel对象&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public NioSocketChannel() {
    this(DEFAULT_SELECTOR_PROVIDER);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;newSocket中通过调用provider.openSocketChannel()方法创建了一个SocketChannel对象，它的默认实现是SocketChannelImpl。&lt;br/&gt;public NioSocketChannel(SelectorProvider provider) {&lt;br/&gt;this(newSocket(provider));&lt;br/&gt;}&lt;/p&gt;
&lt;p&gt;然后经过几次调用，最后调用了下面的构造器，首先调用了父类AbstractNioByteChannel的构造器，&lt;br/&gt;然后创建了一个SocketChannelConfig对象，这个类有点类似于门面模式，对NioSocketChannel对象和Socket对象的一些参数设置和获取的接口进行封装。&lt;br/&gt;public NioSocketChannel(Channel parent, SocketChannel socket) {&lt;br/&gt;super(parent, socket);&lt;br/&gt;config = new NioSocketChannelConfig(this, socket.socket());&lt;br/&gt;}&lt;/p&gt;
&lt;p&gt;我们在接着看父类AbstractNioByteChannel的构造方法&lt;/p&gt;
&lt;h3 id=&quot;abstractniobytechannelchannel-parent-selectablechannel-ch&quot;&gt;AbstractNioByteChannel(Channel parent, SelectableChannel ch)&lt;/h3&gt;
&lt;p&gt;没有做任何工作，直接调用了父类的构造方法，注意这里多了一个参数SelectionKey.OP_READ，这个参数表示channel初始时的感兴趣的事件，channel刚创建好之后对read事件感兴趣&lt;br/&gt;protected AbstractNioByteChannel(Channel parent, SelectableChannel ch) {&lt;br/&gt;super(parent, ch, SelectionKey.OP_READ);&lt;br/&gt;}&lt;/p&gt;
&lt;h3 id=&quot;abstractniochannelchannel-parent-selectablechannel-ch-int-readinterestop&quot;&gt;AbstractNioChannel(Channel parent, SelectableChannel ch, int readInterestOp)&lt;/h3&gt;
&lt;p&gt;主要还是调用父类的构造方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;protected AbstractNioChannel(Channel parent, SelectableChannel ch, int readInterestOp) {
    // 父类构造方法
    super(parent);
    this.ch = ch;
    this.readInterestOp = readInterestOp;
    try {
        // 设置非阻塞
        ch.configureBlocking(false);
    } catch (IOException e) {
        try {
            // 如果发生异常，关闭该channel
            ch.close();
        } catch (IOException e2) {
            if (logger.isWarnEnabled()) {
                logger.warn(
                        &quot;Failed to close a partially initialized socket.&quot;, e2);
            }
        }

        throw new ChannelException(&quot;Failed to enter non-blocking mode.&quot;, e);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;abstractchannelchannel-parent&quot;&gt;AbstractChannel(Channel parent)&lt;/h3&gt;
&lt;p&gt;最关键的初始化逻辑在这个最顶层的基类中，其中很重的两个对象Unsafe对象和ChannelPipeline对象，前者封装了jdk底层api的调用，后者是实现netty对事件的链式处理的核心类。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;protected AbstractChannel(Channel parent) {
    this.parent = parent;
    // 创建一个ChannelId对象，唯一标识该channel
    id = newId();
    // Unsafe对象，封装了jdk底层的api调用
    unsafe = newUnsafe();
    // 创建一个DefaultChannelPipeline对象
    pipeline = newChannelPipeline();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;前面一小节，我们主要简单分析了一下NioSocketChannel的初始化过程，可以看到最主要的逻辑在AbstractChannel的构造方法中，这里我们看到了两个重要的类的创建过程。&lt;/p&gt;
&lt;h3 id=&quot;bootstrap.init&quot;&gt;Bootstrap.init&lt;/h3&gt;
&lt;p&gt;回到AbstractBootstrap.initAndRegister方法中，在完成通过反射调用NioSocketChannel构造方法并创建一个实例后，紧接着就要对这个新创建的Channel实例进行初始化设置工作，我们看一下Bootstrap对新创建的Channel的初始化过程：&lt;/p&gt;
&lt;ul readability=&quot;4&quot;&gt;&lt;li&gt;向channel的Pipeline中添加一个处理器，ChannelPipeline我们可以理解为一个流水线，在这条流水线上有各种各样的处理器，一个channel事件产生后会在这个流水线上进行传播，依次经过所有的处理器&lt;/li&gt;
&lt;li&gt;设置参数，也就是以ChannelOption为key的一些参数，可以通过DefaultChannelConfig.setOption方法看到具体可以设置哪些参数。&lt;/li&gt;
&lt;li readability=&quot;11&quot;&gt;
&lt;p&gt;设置属性&lt;/p&gt;
&lt;p&gt;void init(Channel channel) throws Exception {&lt;br/&gt;ChannelPipeline p = channel.pipeline();&lt;br/&gt;// 向ChannelPipeline中添加一个处理器，这个处理器就是我们之前设置的处理器&lt;br/&gt;p.addLast(config.handler());&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  final Map&amp;lt;ChannelOption&amp;lt;?&amp;gt;, Object&amp;gt; options = options0();
  // 设置参数，最终是通过调用SocketChannelConfig的一些参数设置接口设置参数
  synchronized (options) {
      setChannelOptions(channel, options, logger);
  }

  final Map&amp;lt;AttributeKey&amp;lt;?&amp;gt;, Object&amp;gt; attrs = attrs0();
  // 设置属性
  synchronized (attrs) {
      for (Entry&amp;lt;AttributeKey&amp;lt;?&amp;gt;, Object&amp;gt; e: attrs.entrySet()) {
          channel.attr((AttributeKey&amp;lt;Object&amp;gt;) e.getKey()).set(e.getValue());
      }
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;multithreadeventloopgroup.register&quot;&gt;MultithreadEventLoopGroup.register&lt;/h3&gt;
&lt;p&gt;在完成channel的创建和初始化之后，我们就要将这个channel注册到一个EventLoop中，NioNioEventLoop继承自MultithreadEventLoopGroup, 通过调用SingleThreadEventLoop的register方法完成注册&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public ChannelFuture register(Channel channel) {
    return next().register(channel);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，通过next()方法选出了其中的一个EventLoop进行注册。MultithreadEventLoopGroup是对多个真正的EventLoopGroup的封装，每个实现了实际功能的真正的EventLoopGroup运行在一个线程内，&lt;br/&gt;所以我们接下来应该看单个的EventLoopGroup的注册方法。&lt;/p&gt;
&lt;h3 id=&quot;singlethreadeventloop.register&quot;&gt;SingleThreadEventLoop.register&lt;/h3&gt;
&lt;p&gt;这里创建了一个DefaultChannelPromise对象，用于作为返回值。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public ChannelFuture register(Channel channel) {
    return register(new DefaultChannelPromise(channel, this));
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最终调用了Unsafe的register方法将channel绑定到当前的EventLoopGroup对象上。&lt;br/&gt;public ChannelFuture register(final ChannelPromise promise) {&lt;br/&gt;ObjectUtil.checkNotNull(promise, &quot;promise&quot;);&lt;br/&gt;promise.channel().unsafe().register(this, promise);&lt;br/&gt;return promise;&lt;br/&gt;}&lt;/p&gt;
&lt;h3 id=&quot;abstractchannel.abstractunsafe.register&quot;&gt;AbstractChannel.AbstractUnsafe.register&lt;/h3&gt;
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li&gt;首先是做一些前置检查，包括变量非空检查，重复注册检查，检查channel类型和EventLoopGroup类型是否匹配&lt;/li&gt;
&lt;li&gt;将这个channel绑定到指定的eventLoop对象上，&lt;/li&gt;
&lt;li readability=&quot;8&quot;&gt;
&lt;p&gt;调用register0完成注册&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  public final void register(EventLoop eventLoop, final ChannelPromise promise) {
      // 做一些非空检查
      if (eventLoop == null) {
          throw new NullPointerException(&quot;eventLoop&quot;);
      }
      // 如果重复注册，通过future对象抛出一个异常
      // 一个channel只能注册到一个EventLoopGroup对象上
      if (isRegistered()) {
          promise.setFailure(new IllegalStateException(&quot;registered to an event loop already&quot;));
          return;
      }
      // 检查channel类型和EventLoopGroup类型是否匹配
      if (!isCompatible(eventLoop)) {
          promise.setFailure(
                  new IllegalStateException(&quot;incompatible event loop type: &quot; + eventLoop.getClass().getName()));
          return;
      }

      // 将channel内部的eventLoop成员设置为相应的对象
      // 也就是将这个channel绑定到指定顶eventLoop上
      AbstractChannel.this.eventLoop = eventLoop;

      // 这里做了一个判断，如果当前处于eventLoop对应的线程内，那么直接执行代码
      // 如果当前运行的线程与eventLoop不是同一个，那么将这个注册的任务添加到eventLoop的任务队列中
      if (eventLoop.inEventLoop()) {
          register0(promise);
      } else {
          try {
              eventLoop.execute(new Runnable() {
                  @Override
                  public void run() {
                      register0(promise);
                  }
              });
          } catch (Throwable t) {
              logger.warn(
                      &quot;Force-closing a channel whose registration task was not accepted by an event loop: {}&quot;,
                      AbstractChannel.this, t);
              closeForcibly();
              closeFuture.setClosed();
              safeSetFailure(promise, t);
          }
      }
  }&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;abstractchannel.abstractunsafe.register0&quot;&gt;AbstractChannel.AbstractUnsafe.register0&lt;/h3&gt;
&lt;p&gt;这个方法实现了实际的注册逻辑，&lt;/p&gt;
&lt;ul readability=&quot;3.5&quot;&gt;&lt;li&gt;依然要做一些前置的设置和检查工作，包括在注册过程中不可取消，检查channel是否存活，&lt;/li&gt;
&lt;li&gt;调用jdk的api完成注册。例如，对于jdk Nio的通道的注册就是调用SelectableChannel.register(Selector sel, int ops, Object att)&lt;/li&gt;
&lt;li&gt;调用所有的已添加的处理器节点的ChannelHandler.handlerAdded方法,实际上这也会调用handler.handlerRemoved方法，如果在此之前有handler被移除掉的话&lt;/li&gt;
&lt;li&gt;通知future对象已经注册成功了&lt;/li&gt;
&lt;li&gt;触发一个channel注册成功的事件，这个事件会在pipeline中传播，所有注册的handler会依次接收到该事件并作出相应的处理&lt;/li&gt;
&lt;li readability=&quot;10&quot;&gt;
&lt;p&gt;如果是第一次注册，还需要触发一个channel存活的事件，让所有的handler作出相应的处理&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  private void register0(ChannelPromise promise) {
      try {
          // check if the channel is still open as it could be closed in the mean time when the register
          // call was outside of the eventLoop
          // 将ChannelPromise设置为不可取消，并检查channel是否还存活,通过内部的jdk的channel检查是否存活
          if (!promise.setUncancellable() || !ensureOpen(promise)) {
              return;
          }
          // 是否第一次注册，
          // TODO 说明情况下会注册多次？？
          boolean firstRegistration = neverRegistered;
          // 完成实际的注册，即底层api的调用
          // 如果对于jdk Nio的通道的注册就是调用SelectableChannel.register(Selector sel, int ops, Object att)
          doRegister();
          // 更新标志变量
          neverRegistered = false;
          registered = true;

          // Ensure we call handlerAdded(...) before we actually notify the promise. This is needed as the
          // user may already fire events through the pipeline in the ChannelFutureListener.
          // 调用所有的已添加的处理器节点的ChannelHandler.handlerAdded方法
          pipeline.invokeHandlerAddedIfNeeded();

          // 通过future对象已经注册成功了
          safeSetSuccess(promise);
          // 触发一个channel注册成功的事件，这个事件会在pipeline中传播，
          // 所有注册的handler会依次接收到该事件并作出相应的处理
          pipeline.fireChannelRegistered();
          // Only fire a channelActive if the channel has never been registered. This prevents firing
          // multiple channel actives if the channel is deregistered and re-registered.
          if (isActive()) {
              if (firstRegistration) {
                  // 如果是第一次注册，还需要触发一个channel存活的事件，让所有的handler作出相应的处理
                  pipeline.fireChannelActive();
              } else if (config().isAutoRead()) {
                  // This channel was registered before and autoRead() is set. This means we need to begin read
                  // again so that we process inbound data.
                  //
                  // See https://github.com/netty/netty/issues/4805
                  // 开始接收读事件
                  // 对于Nio类型的channel, 通过调用jdk的相关api注册读事件为感兴趣的事件
                  beginRead();
              }
          }
      } catch (Throwable t) {
          // Close the channel directly to avoid FD leak.
          closeForcibly();
          closeFuture.setClosed();
          safeSetFailure(promise, t);
      }
  }&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;小结-1&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;到此，我们就完成了对channel的创建，初始化，和注册到EventLoop过程的分析，整个过程看下来，其实并不复杂，只不过代码的嵌套比较深，继承结构复杂，有些简单的功能可能要看好几层才能找到真正实现的地方，所以还需要耐心和熟悉。这里，我把主干逻辑再提炼一下，去掉所有细枝末节的逻辑，一遍能有一个整体的认识：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先通过反射创建了一个NioSocketChannel(通过反射调用无参构造器)&lt;/li&gt;
&lt;li&gt;然后对channel对象进行初始化，主要是想这个channel的ChannelPipeline中添加用户设置的handler&lt;/li&gt;
&lt;li&gt;最后将这个channel注册到一个EventLoop上，注册过程设计jdk底层的selector注册api的调用，调用handler的回调方法，在channelPipeline中触发一个channel注册的事件，这些事件最终回调各个handler对象的channelRegistered方法。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;接下来，我们回到Bootstrap.doResolveAndConnect方法中，继续完成建立连接的过程的分析。&lt;/p&gt;
&lt;h3 id=&quot;bootstrap.doresolveandconnect0&quot;&gt;Bootstrap.doResolveAndConnect0&lt;/h3&gt;
&lt;p&gt;连接的建立在方法doResolveAndConnect0中实现:&lt;/p&gt;
&lt;p&gt;这个方法的主要工作就是对远程地址进行解析，比如通过dns服务器对域名进行解析，&lt;br/&gt;然后使用解析后的地址进行连接的建立，连接建立调用doConnect方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private ChannelFuture doResolveAndConnect0(final Channel channel, SocketAddress remoteAddress,
                                           final SocketAddress localAddress, final ChannelPromise promise) {
    try {
        final EventLoop eventLoop = channel.eventLoop();
        // 获取一个地址解析器
        final AddressResolver&amp;lt;SocketAddress&amp;gt; resolver = this.resolver.getResolver(eventLoop);

        // 如果解析器不支持该地址或者改地址已经被解析过了，那么直接开始创建连接
        if (!resolver.isSupported(remoteAddress) || resolver.isResolved(remoteAddress)) {
            // Resolver has no idea about what to do with the specified remote address or it's resolved already.
            doConnect(remoteAddress, localAddress, promise);
            return promise;
        }

        // 对远程地址进行解析
        final Future&amp;lt;SocketAddress&amp;gt; resolveFuture = resolver.resolve(remoteAddress);

        if (resolveFuture.isDone()) {
            final Throwable resolveFailureCause = resolveFuture.cause();

            if (resolveFailureCause != null) {
                // Failed to resolve immediately
                channel.close();
                promise.setFailure(resolveFailureCause);
            } else {
                // Succeeded to resolve immediately; cached? (or did a blocking lookup)
                // 解析成功后进行连接
                doConnect(resolveFuture.getNow(), localAddress, promise);
            }
            return promise;
        }

        // Wait until the name resolution is finished.
        // 给future对象添加一个回调，采用异步方法进行连接，
        resolveFuture.addListener(new FutureListener&amp;lt;SocketAddress&amp;gt;() {
            @Override
            public void operationComplete(Future&amp;lt;SocketAddress&amp;gt; future) throws Exception {
                if (future.cause() != null) {
                    channel.close();
                    promise.setFailure(future.cause());
                } else {
                    doConnect(future.getNow(), localAddress, promise);
                }
            }
        });
    } catch (Throwable cause) {
        promise.tryFailure(cause);
    }
    return promise;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;bootstrap.doconnect&quot;&gt;Bootstrap.doConnect&lt;/h3&gt;
&lt;p&gt;调用channel的connect方法完成连接过程。&lt;br/&gt;也许是之前看scala代码习惯了，回过头来看java代码感觉很冗余，一大堆代码就表达了那一点逻辑，感觉信息密度太低，现在有很多人认为java会渐渐的没落，而最优可能取代java的语言中，scala绝对是强有力的竞争者之一，没有对比就没有伤害，跟java比,scala语言真的是简洁太多了，几句话就能把所要表达的逻辑精准而又直接地表达出来。好像向声明式编程更靠近了一点。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private static void doConnect(
        final SocketAddress remoteAddress, final SocketAddress localAddress, final ChannelPromise connectPromise) {

    // This method is invoked before channelRegistered() is triggered.  Give user handlers a chance to set up
    // the pipeline in its channelRegistered() implementation.
    final Channel channel = connectPromise.channel();
    channel.eventLoop().execute(new Runnable() {
        @Override
        public void run() {
            if (localAddress == null) {
                // 调用 channel.connect方法完成连接
                channel.connect(remoteAddress, connectPromise);
            } else {
                channel.connect(remoteAddress, localAddress, connectPromise);
            }
            connectPromise.addListener(ChannelFutureListener.CLOSE_ON_FAILURE);
        }
    });
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;abstractchannel.connect&quot;&gt;AbstractChannel.connect&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;public ChannelFuture connect(SocketAddress remoteAddress, ChannelPromise promise) {
    return pipeline.connect(remoteAddress, promise);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;defaultchannelpipeline.connect&quot;&gt;DefaultChannelPipeline.connect&lt;/h3&gt;
&lt;p&gt;这里稍微说明一下，tail是整个链条的尾节点，如果对netty比较熟悉的话，应该知道netty对于io事件的处理采用责任链的模式，即用户可以设置多个处理器，这些处理器组成一个链条，io事件在这个链条上传播，被特定的一些处理器所处理，而其中有两个特殊的处理器head和tail，他们分别是这个链条的头和尾，他们的存在主要是为了实现一些特殊的逻辑。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public final ChannelFuture connect(SocketAddress remoteAddress, ChannelPromise promise) {
    return tail.connect(remoteAddress, promise);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;abstractchannelhandlercontext.connect&quot;&gt;AbstractChannelHandlerContext.connect&lt;/h3&gt;
&lt;p&gt;中间经过几个调用之后，最终调用该方法。这里有一句关键代码findContextOutbound(MASK_CONNECT)，这个方法的代码我就不贴了，大概说一下它的作用，更为具体的机制等后面分析Channelpipeline是在详细说明。这个方法会在处理器链中从后向前遍历，直到找到能够处理connect事件的处理器，能否处理某种类型的事件是通过比特位判断的，每个AbstractChannelHandlerContext对象内部有一个int型变量用于存储标志各种类型事件的比特位。一般，connect事件会有头结点head来处理，也就是DefaultChannelPipeline.HeadContext类，所以我们直接看DefaultChannelPipeline.HeadContext.connect方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public ChannelFuture connect(
        final SocketAddress remoteAddress, final SocketAddress localAddress, final ChannelPromise promise) {

    if (remoteAddress == null) {
        throw new NullPointerException(&quot;remoteAddress&quot;);
    }
    if (isNotValidPromise(promise, false)) {
        // cancelled
        return promise;
    }

    // 找到下一个能够进行connect操作的，这里用比特位来标记各种不同类型的操作，
    final AbstractChannelHandlerContext next = findContextOutbound(MASK_CONNECT);
    EventExecutor executor = next.executor();
    if (executor.inEventLoop()) {
        // 调用AbstractChannelHandlerContext.invokeConnect
        next.invokeConnect(remoteAddress, localAddress, promise);
    } else {
        safeExecute(executor, new Runnable() {
            @Override
            public void run() {
                next.invokeConnect(remoteAddress, localAddress, promise);
            }
        }, promise, null);
    }
    return promise;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;defaultchannelpipeline.headcontext.connect&quot;&gt;DefaultChannelPipeline.HeadContext.connect&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;public void connect(
            ChannelHandlerContext ctx,
            SocketAddress remoteAddress, SocketAddress localAddress,
            ChannelPromise promise) {
        unsafe.connect(remoteAddress, localAddress, promise);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;unsafe对象的赋值：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    HeadContext(DefaultChannelPipeline pipeline) {
        super(pipeline, null, HEAD_NAME, HeadContext.class);
        unsafe = pipeline.channel().unsafe();
        setAddComplete();
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以我们直接看unsafe.connect&lt;/p&gt;
&lt;h3 id=&quot;abstractniochannel.connect&quot;&gt;AbstractNioChannel.connect&lt;/h3&gt;
&lt;p&gt;主要逻辑：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;状态检查，非空检查&lt;/li&gt;
&lt;li&gt;调用doConnect方法进行连接&lt;/li&gt;
&lt;li&gt;如果立即就连接成功了，那么将future对象设置为成功&lt;/li&gt;
&lt;li&gt;如果超时大于0，会提交一个延迟调度的任务，在超时时间到达后执行这个任务检查是否连接成功，如果为连接成功连接说明连接超时，需要关闭通道&lt;/li&gt;
&lt;li&gt;向future对象添加一个回调，在future被外部调用者取消时将通道关闭&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;可见建立连接的核心方法是doConnect，这是一个抽象方法，我们看NioSocketChannel，也就是tcp连接的建立过程，查看AbstractNioChannel的实现类发现还有UDP,SCTP等协议&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public final void connect(
            final SocketAddress remoteAddress, final SocketAddress localAddress, final ChannelPromise promise) {
        // 检查promise状态，channel存活状态
        if (!promise.setUncancellable() || !ensureOpen(promise)) {
            return;
        }

        try {
            // 防止重复连接
            if (connectPromise != null) {
                // Already a connect in process.
                throw new ConnectionPendingException();
            }

            boolean wasActive = isActive();
            // 调用doConnect方法进行连接
            if (doConnect(remoteAddress, localAddress)) {
                // 如果立即就连接成功了，那么将future对象设置为成功
                fulfillConnectPromise(promise, wasActive);
            } else {
                connectPromise = promise;
                requestedRemoteAddress = remoteAddress;

                // Schedule connect timeout.
                int connectTimeoutMillis = config().getConnectTimeoutMillis();
                // 如果超时大于0，那么会在超时到达后检查是否连接成功
                if (connectTimeoutMillis &amp;gt; 0) {
                    connectTimeoutFuture = eventLoop().schedule(new Runnable() {
                        @Override
                        public void run() {
                            ChannelPromise connectPromise = AbstractNioChannel.this.connectPromise;
                            ConnectTimeoutException cause =
                                    new ConnectTimeoutException(&quot;connection timed out: &quot; + remoteAddress);
                            // 如果connectPromise能够标记为失败，说明此时还没有连接成功，也就是连接超时了
                            // 此时需要关闭该通道
                            if (connectPromise != null &amp;amp;&amp;amp; connectPromise.tryFailure(cause)) {
                                close(voidPromise());
                            }
                        }
                    }, connectTimeoutMillis, TimeUnit.MILLISECONDS);
                }

                // 向future对象添加一个回调，在future被外部调用者取消时将通道关闭
                promise.addListener(new ChannelFutureListener() {
                    @Override
                    public void operationComplete(ChannelFuture future) throws Exception {
                        if (future.isCancelled()) {
                            if (connectTimeoutFuture != null) {
                                connectTimeoutFuture.cancel(false);
                            }
                            connectPromise = null;
                            close(voidPromise());
                        }
                    }
                });
            }
        } catch (Throwable t) {
            promise.tryFailure(annotateConnectException(t, remoteAddress));
            closeIfClosed();
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;niosocketchannel.doconnect&quot;&gt;NioSocketChannel.doConnect&lt;/h3&gt;
&lt;ul readability=&quot;3&quot;&gt;&lt;li&gt;首先绑定指定的本地地址&lt;/li&gt;
&lt;li readability=&quot;9&quot;&gt;
&lt;p&gt;调用SocketUtils.connect建立连接&lt;/p&gt;
&lt;p&gt;protected boolean doConnect(SocketAddress remoteAddress, SocketAddress localAddress) throws Exception {&lt;br/&gt;// 绑定指定的本地地址&lt;br/&gt;if (localAddress != null) {&lt;br/&gt;doBind0(localAddress);&lt;br/&gt;}&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  // 这个变量标记建立连接的动作是否发起成功
  // 成功发起建立连接的工作并不表示连接已经成功建立
  boolean success = false;
  try {
      // 实际建立连接的语句
      boolean connected = SocketUtils.connect(javaChannel(), remoteAddress);
      if (!connected) {
          selectionKey().interestOps(SelectionKey.OP_CONNECT);
      }
      success = true;
      // 返回连接是否已经成功建立
      return connected;
  } finally {
      if (!success) {
          doClose();
      }
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;socketutils.connect&quot;&gt;SocketUtils.connect&lt;/h3&gt;
&lt;p&gt;可以看到，最终是通过调用jdk的api来实现连接的建立，也就是SocketChannel.connect方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static boolean connect(final SocketChannel socketChannel, final SocketAddress remoteAddress)
        throws IOException {
    try {
        return AccessController.doPrivileged(new PrivilegedExceptionAction&amp;lt;Boolean&amp;gt;() {
            @Override
            public Boolean run() throws IOException {
                // 调用jdk api建立连接，SocketChannel.connect
                return socketChannel.connect(remoteAddress);
            }
        });
    } catch (PrivilegedActionException e) {
        throw (IOException) e.getCause();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;一句话，这代码是真的很深! 非常不直接，初次看的话，如果没有一个代码框架图在旁边参考，很容易迷失在层层的继承结构中，很多代码层层调用，真正有用的逻辑隐藏的很深，所以看这中代码必须要有耐心，有毅力，要有打破砂锅问到底的决心。不过这样的复杂的代码结构好处也是显而易见的，那就是良好的扩展性，你可以在任意层级进行扩展。&lt;/p&gt;
&lt;p&gt;总结一下建立连接的过程，我认为可以归结为三个主要的方面：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第一, 实际建立逻辑的代码肯定还是jdk api&lt;/li&gt;
&lt;li&gt;第二，这么多方法调用，主要的作用就是迎合框架的要求，本质上是为了代码的扩展性，比如ChannelPipeline的处理器链&lt;/li&gt;
&lt;li&gt;第三，另一个主要的工作就是对future对象的处理，这时实现异步的重要手段，future对象也是外部调用者和对象内部状态之间的连接纽带，调用者通过future对象完成一些功能，如查状态，发出取消动作，实现阻塞等待等。&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Sat, 22 Jun 2019 18:15:00 +0000</pubDate>
<dc:creator>_朱葛</dc:creator>
<og:description>Bootstrap初始化过程 netty的客户端引导类是Bootstrap，我们看一下spark的rpc中客户端部分对Bootstrap的初始化过程 TransportClientFactory.cr</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhuge134/p/11071413.html</dc:identifier>
</item>
<item>
<title>React组件中对子组件children进行加强 - tornoda</title>
<link>http://www.cnblogs.com/looyulong/p/11071367.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/looyulong/p/11071367.html</guid>
<description>&lt;h2 id=&quot;问题&quot;&gt;问题&lt;/h2&gt;
&lt;p&gt;如何对组件的children进行加强，如：添加属性、绑定事件，而不是使用&lt;code&gt;&amp;lt;div&amp;gt;{this.props.children}&amp;lt;/div&amp;gt;&lt;/code&gt;在&lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;上进行处理。&lt;/p&gt;
&lt;h2 id=&quot;前车之鉴&quot;&gt;前车之鉴&lt;/h2&gt;
&lt;p&gt;今天写组件遇到这个问题，在网上查阅了很多资料，都说可以使用&lt;code&gt;React.cloneElement&lt;/code&gt;进行处理，但是结果并不是预期想要的。&lt;/p&gt;
&lt;p&gt;先看看这个东西有什么用：&lt;/p&gt;
&lt;pre class=&quot;react&quot;&gt;
&lt;code&gt;React.cloneElement(element, [props], [...childrn])&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;根据React官网的说法，以上代码等价于：&lt;/p&gt;
&lt;pre class=&quot;react&quot;&gt;
&lt;code&gt;&amp;lt;element.type {...element.props} {...props}&amp;gt;{children}&amp;lt;/element.type&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这么做其实也是给&lt;code&gt;children&lt;/code&gt;包了一层标签，再对其进行间接处理，没有直接修改&lt;code&gt;children&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如：&lt;/p&gt;
&lt;pre class=&quot;react&quot;&gt;
&lt;code&gt;// App.jsx
&amp;lt;Father&amp;gt;
    &amp;lt;div style={{ color: 'red' }} onClick={() =&amp;gt; console.log('hello')}&amp;gt;
        demo
    &amp;lt;/div&amp;gt;
&amp;lt;Father&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们希望在&lt;code&gt;Father.jsx&lt;/code&gt;的内部将&lt;code&gt;div&lt;/code&gt;转为&lt;code&gt;inline-block&lt;/code&gt;。按照网上的做法，是这样的：&lt;/p&gt;
&lt;pre class=&quot;react&quot;&gt;
&lt;code&gt;// Father.jsx
const Son = React.cloneElement(
    this.props.children,
    {
        style: {
            display: 'inline-block'
        }
    }
)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是实际效果是这样的：&lt;/p&gt;
&lt;pre class=&quot;react&quot;&gt;
&lt;code&gt;&amp;lt;div style={{ dispaly: 'inline-block' }}&amp;gt;
    &amp;lt;div style={{ color: 'red' }} onClick={() =&amp;gt; console.log('hello')}&amp;gt;
        demo
    &amp;lt;/div&amp;gt;
&amp;lt;div&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;哈！？子元素的父元素被设为了&lt;code&gt;inline-block&lt;/code&gt;，和我们想要的&lt;code&gt;&amp;lt;div&amp;gt;demo&amp;lt;/div&amp;gt;&lt;/code&gt;被设为&lt;code&gt;inline-block&lt;/code&gt;。结果与预期完全不同，简直大失所望！！！&lt;/p&gt;
&lt;p&gt;&lt;code&gt;React.clone&lt;/code&gt;根本对不起它&lt;code&gt;clone&lt;/code&gt;的名字！！！&lt;/p&gt;
&lt;h2 id=&quot;自我探索&quot;&gt;自我探索&lt;/h2&gt;
&lt;p&gt;思路： jsx语法表示的元素只是react组件的一个语法糖。所以组件是对象。既然是对象我们就可以直接对其进行修改。&lt;/p&gt;
&lt;p&gt;尝试在控制台打印一个如下react组件：&lt;/p&gt;
&lt;pre class=&quot;react&quot;&gt;
&lt;code&gt;// this.props.children
console.log(
    &amp;lt;div
        style={{ color: 'red' }}
        onClick={() =&amp;gt; {
            console.log('hello');
        }}
    &amp;gt;
        demo
    &amp;lt;/div&amp;gt;
);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1431071/201906/1431071-20190623014821050-375080705.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以直接修改&lt;code&gt;this.props.children&lt;/code&gt;即可：&lt;/p&gt;
&lt;pre class=&quot;react&quot;&gt;
&lt;code&gt;// Father.jsx
const { children } = this.props;
const Son = {
    ...children,
    props: {
            ...children.props,
        dispaly: {
            ...children.style,
            display: 'inline-block'
        },
        onTransitionEnd: () =&amp;gt; { console.log('hello world') }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;如何对组件的children进行&lt;strong&gt;直接&lt;/strong&gt;加强，直接修改&lt;code&gt;this.props.children&lt;/code&gt;对象即可。&lt;/p&gt;
</description>
<pubDate>Sat, 22 Jun 2019 17:52:00 +0000</pubDate>
<dc:creator>tornoda</dc:creator>
<og:description>React组件中对子组件children进行加强 问题 如何对组件的children进行加强，如：添加属性、绑定事件，而不是使用 在``上进行处理。 前车之鉴 今天写组件遇到这个问题，在网上查阅了很多</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/looyulong/p/11071367.html</dc:identifier>
</item>
<item>
<title>304441事务管理与并发控制 - Zander_Zhao</title>
<link>http://www.cnblogs.com/ZanderZhao/p/11062400.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ZanderZhao/p/11062400.html</guid>
<description>&lt;p align=&quot;center&quot;&gt;第10章事务管理与并发控制&lt;/p&gt;
&lt;h2&gt;•    10.1 事务的基本概念&lt;/h2&gt;

&lt;h3&gt;10.1.1 事务&lt;/h3&gt;
&lt;p&gt;Ø 事务(Transaction)是构成单一逻辑工作单元的数据库操作序列。这些操作是一个统一的整体，要么全部成功执行（执行结果写到物理数据文件），要么全部不执行（执行结果没有写到任何的物理数据文件）。也可以这样理解，事务是若干操作语句的序列，这些语句序列要么全部成功执行，要么全部都不执行。全部不执行的情况是：在执行到这些语句序列中的某一条语句时，由于某种原因（如断电、磁盘故障等）而导致该语句执行失败，这时将撤销在该语句之前已经执行的语句所产生的结果，使数据库恢复到执行这些语句序列之前的状态。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;【例子】对于银行转帐问题，可以表述为：将帐户A1上的金额x转到帐户A2。这个操作过程可以用如图10.1所示的流程表示。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1427277/201906/1427277-20190622215826891-1164814688.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;•         如果转帐程序在刚好执行完操作③的时刻出现硬件故障，并由此导致程序运行中断，那么数据库就处于这样的状态：帐号A1中已经被扣除金额x（转出部分），而帐号A2并没有增加相应的金额x。也就是说，已经从帐号A1上转出金额x，但帐号A2并没有收到这批钱。显然，这种情况在实际应用决不允许出现。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;•         如果将上述操作①至⑤定义为一个事务，由于事务中的操作要么全都执行，要么全都不执行，那么就可以避免出现上述错误的状态。这就是事务的魅力。&lt;/span&gt;&lt;/p&gt;


&lt;h3&gt;10.1.2 事务的ACID特性&lt;/h3&gt;
&lt;p&gt;Ø 作为一种特殊的数据库操作序列，事务的主要特性体现以下四个方面：&lt;/p&gt;
&lt;p&gt;（1）原子性（Atomicity）&lt;/p&gt;
&lt;p&gt;      &lt;span&gt;  事务是数据库操作的逻辑工作单位。就操作而言，事务中的操作是一个整体，不能再被分割，要么全部成功执行，要么全部不成功执行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（2）一致性（Consistency）&lt;/p&gt;
&lt;p&gt;    &lt;span&gt;   事务的一致性是指出事务执行前后都能够保持数据库状态的一致性，即事务的执行结果是将数据库从一个一致状态转变为另一个一致状态。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Ø  实际上，事务的一致性和原子性是密切相关的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Ø  对于前面转帐的例子，当操作操作③被执行后，出于某种客观原因而导致操作④不能被执行时，如果操作③和④都是同一个事务中的操作，那么由于事务具有&lt;/span&gt;&lt;span&gt;原子性，所以操作①、②和③执行的结果也自动被取消，这样数据库就回到执行操作①前的状态，从而保持数据库的一致性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Ø  数据库的一致性状态除了取决于事务的一致性以外，还要求在事务开始执行时的数据库状态也必须一致的。否则就算事务具有一致性，但在执行该事务后并不一定能够保持数据库状态的一致性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（3）隔离性（Isolation）&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        隔离性是指多个事务在执行时不相互干扰的一种特性。事务的隔离性意味着一个事务的内部操作及其使用的数据对其他事务是不透明的，其他事务感觉不到这些操作和数据的存在，更不会干扰这些操作和数据。也就是说，事务的隔离性使系统中的每个事务都感觉到“只有自己在工作”，而感觉不到系统中还有其他事务在并发执行，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（4）持久性（Durability）&lt;/p&gt;
&lt;p&gt;        &lt;span&gt;持久性或称永久性（Permanence），是指一个事务一旦成功提交，其结果对数据库的改变将是永久的，即使是出现系统故障等问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;事务的这四个特性通常被称为事务的ACID特性。一个数据库管理系统及其并发控制机制应该能确保这些特性不遭到破坏。&lt;/span&gt;&lt;/p&gt;


&lt;h2&gt;•    10.2 事务的管理&lt;/h2&gt;


&lt;h3&gt;10.2.1 启动事务&lt;/h3&gt;
&lt;p&gt;Ø 启动事务方式有三种：显式启动、自动提交和隐式启动。&lt;/p&gt;
&lt;p&gt;1. 显式启动&lt;/p&gt;
&lt;p&gt;       显式启动是以BEGIN TRANSACTION命令开始的，即当执行到该语句的时SQL Server将认为这是一个事务的起点。&lt;/p&gt;
&lt;p&gt;        BEGIN TRANSACTION的语法如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
   &lt;span&gt;BEGIN&lt;/span&gt; { &lt;span&gt;TRAN&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;TRANSACTION&lt;/span&gt;&lt;span&gt; }

       &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt; { transaction_name | @tran_name_variable }

      [ WITH MARK [ 'description' &lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt; ]

    ]

   &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt; ; &lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;u 其参数意义如下：&lt;/p&gt;
&lt;p&gt;Ø transaction_name | @tran_name_variable&lt;/p&gt;
&lt;p&gt;     指定事务的名称，可以用变量提供名称。该项是可选项。如果是事务是嵌套的，则仅在最外面的BEGIN...COMMIT或BEGIN...ROLLBACK嵌套语句对中使用事务名。&lt;/p&gt;
&lt;p&gt;Ø WITH MARK [ 'description' ]&lt;/p&gt;
&lt;p&gt;      指定在日志中标记事务。description 是描述该标记的字符串。如果使用了WITH MARK，则必须指定事务名。WITH MARK允许将事务日志还原到命名标记。&lt;/p&gt;
&lt;p&gt;     显式启动的事务通常称为显式事务。本章介绍的主要是显式事务。&lt;/p&gt;


&lt;p&gt;2. 自动提交&lt;/p&gt;
&lt;p&gt;Ø 自动提交是指用户每发出一条SQL语句，SQL Server会自动启动一个事务，语句执行完了以后SQL Server自动执行提交操作来提交该事务。也就是说，在自动提交方式下，每一条SQL语句就是一个事务，通常称为自动提交事务，这是SQL Server的默认模式。&lt;/p&gt;
&lt;p&gt;Ø  CREATE TABLE语句是一个事务，因此不可能出现这样的情况：在执行该语句时，有的字段被创建而有的没有被创建。&lt;/p&gt;


&lt;p&gt;3. 隐式启动&lt;/p&gt;
&lt;p&gt;Ø 当将SIMPLICIT_TRANSACTIONS设置为ON时，表示将隐式事务模式设置为打开，设置语句如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SET&lt;/span&gt; IMPLICIT_TRANSACTIONS &lt;span&gt;ON&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Ø 在隐式事务模式下，任何DML语句（DELETE、UPDATE、INSERT）都自动启动一个事务，直到遇到事务提交语句或事务回滚语句，该事务才结束。结束后，自动启动新的事务，而无需用BEGIN TRANSACTION描述事务的开始。隐式启动的事务通常称为隐性事务。在隐性事务模式生下，事务会形成连续的事务链。&lt;/p&gt;
&lt;p&gt;Ø 如果已将IMPLICIT_TRANSACTIONS设置为ON，建议随时将之设置回OFF。另外，事务的结束是使用COMMIT或ROLLBACK语句来实现，这将在下一节介绍。&lt;/p&gt;


&lt;h3&gt;10.2.2 终止事务&lt;/h3&gt;
&lt;p&gt;Ø 有启动，就必有终止。&lt;/p&gt;
&lt;p&gt;Ø 终止方法有两种，一种是使用COMMIT命令（提交命令），另一种是使用ROLLBACK命令（回滚命令）。这两种方法有本质上的区别：当执行到COMMIT命令时，会将语句执行的结果保存到数据库中（提交事务），并终止事务；当执行到ROLLBACK命令时，数据库将返回到事务开始时的初始状态，并终止事务。如果ROLLBACK命令是采用ROLLBACK TRANSACTION savepoint_name时，则数据库将返回到savepoint_name标识的状态。&lt;/p&gt;


&lt;p&gt;1. 提交事务——COMMIT TRANSACTION&lt;/p&gt;
&lt;p&gt;Ø 执行COMMIT TRANSACTION语句时，将终止隐式启动或显式启动的事务。&lt;/p&gt;
&lt;p&gt;ü 如果@@TRANCOUNT为1，COMMIT TRANSACTION使得自从事务开始以来所执行的所有数据修改成为数据库的永久部分，释放事务所占用的资源，并将@@TRANCOUNT减少到0。&lt;/p&gt;
&lt;p&gt;ü 如果@@TRANCOUNT大于1，则COMMIT TRANSACTION使@@TRANCOUNT按1递减并且事务将保持活动状态。&lt;/p&gt;
&lt;p&gt;Ø COMMIT TRANSACTION语句的语法如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;COMMIT&lt;/span&gt; { &lt;span&gt;TRAN&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;TRANSACTION&lt;/span&gt; } &lt;span&gt;[&lt;/span&gt;&lt;span&gt; transaction_name | @tran_name_variable &lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt; ]

&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt; ; &lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;      其中，transaction_name | @tran_name_variable用于设置要结束的事务的名称（该名称是由BEGIN TRANSACTION语句指定），但SQL Server会忽略此参数，设置它的目的是给程序员看的，向程序员指明COMMIT TRANSACTION与哪些BEGIN TRANSACTION相关联，以提高代码的可读性。&lt;/p&gt;


&lt;p&gt;&lt;span&gt;【例10.1】创建关于银行转帐的事务。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Ø 假设用UserTable表保存银行客户信息，该表的定义代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt;&lt;span&gt; UserTable

(

    UserId           &lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;18&lt;/span&gt;)       &lt;span&gt;PRIMARY&lt;/span&gt; &lt;span&gt;KEY&lt;/span&gt;,            &lt;span&gt;--&lt;/span&gt;&lt;span&gt;身份证号&lt;/span&gt;
&lt;span&gt;
    username          &lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;20&lt;/span&gt;)    &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;,                       &lt;span&gt;--&lt;/span&gt;&lt;span&gt;用户名&lt;/span&gt;
&lt;span&gt;
    account              &lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;20&lt;/span&gt;)     &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;UNIQUE&lt;/span&gt;,                         &lt;span&gt;--&lt;/span&gt;&lt;span&gt;帐号&lt;/span&gt;
&lt;span&gt;
    balance          &lt;/span&gt;&lt;span&gt;float&lt;/span&gt;           &lt;span&gt;DEFAULT&lt;/span&gt;  &lt;span&gt;0&lt;/span&gt;,          &lt;span&gt;--&lt;/span&gt;&lt;span&gt;余额&lt;/span&gt;
&lt;span&gt;
    address          &lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;100&lt;/span&gt;)                     &lt;span&gt;--&lt;/span&gt;&lt;span&gt;地址&lt;/span&gt;
&lt;span&gt;
);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;Ø 用下面两条语句分别添加两条用户记录：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; UserTable &lt;span&gt;VALUES&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;430302x1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;王伟志&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;020000y1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;10000&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;中关村南路&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; UserTable &lt;span&gt;VALUES&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;430302x2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;张宇&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;020000y2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;100&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;火器营桥&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;u 现在将账户020000y1上的2000元转到账户430302x2上。为了使得不出现前面所述的情况（转出帐号上已经被扣钱，但转入帐号上的余额并没有增加），我们把转帐操作涉及的关键语句放到一个事务中，这样就可以避免出现上述错误情况。下面代码是对转帐操作的一个简化模拟：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;BEGIN&lt;/span&gt; &lt;span&gt;TRANSACTION&lt;/span&gt; virement            &lt;span&gt;--&lt;/span&gt;&lt;span&gt; 显式启动事务&lt;/span&gt;
&lt;span&gt;DECLARE&lt;/span&gt; &lt;span&gt;@balance&lt;/span&gt; &lt;span&gt;float&lt;/span&gt;,&lt;span&gt;@x&lt;/span&gt; &lt;span&gt;float&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt; ①设置转帐金额&lt;/span&gt;
&lt;span&gt;SET&lt;/span&gt; &lt;span&gt;@x&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;200&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt; ②如果转出帐号上的金额小于x,则取消转帐操作&lt;/span&gt;
&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;@balance&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; balance &lt;span&gt;FROM&lt;/span&gt;  UserTable &lt;span&gt;WHERE&lt;/span&gt; account &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;020000y1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;IF&lt;/span&gt;(&lt;span&gt;@balance&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt; &lt;span&gt;@x&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt; 否则执行下列操作&lt;/span&gt;
&lt;span&gt;--&lt;/span&gt;&lt;span&gt; ③从转出帐号上扣除金额x&lt;/span&gt;
&lt;span&gt;UPDATE&lt;/span&gt; UserTable &lt;span&gt;SET&lt;/span&gt; balance &lt;span&gt;=&lt;/span&gt; balance &lt;span&gt;-&lt;/span&gt; &lt;span&gt;@x&lt;/span&gt; &lt;span&gt;WHERE&lt;/span&gt; account &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;020000y1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt; ④在转入帐号上加上金额x&lt;/span&gt;
&lt;span&gt;UPDATE&lt;/span&gt; UserTable &lt;span&gt;SET&lt;/span&gt; balance &lt;span&gt;=&lt;/span&gt; balance &lt;span&gt;+&lt;/span&gt; &lt;span&gt;@x&lt;/span&gt; &lt;span&gt;WHERE&lt;/span&gt; account &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;020000y2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt; ⑤转帐操作结束&lt;/span&gt;
&lt;span&gt;GO&lt;/span&gt;
&lt;span&gt;COMMIT&lt;/span&gt; &lt;span&gt;TRANSACTION&lt;/span&gt; virement;         &lt;span&gt;--&lt;/span&gt;&lt;span&gt; 提交事务，事务终止&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;Ø  利用以上启动的事务，操作③和操作④要么都对数据库产生影响，要么对数据库都不产生影响，从而避免了“转出帐号上已经被扣钱，但转入帐号上的余额并没有增加”的情况。实际上，只是需要将操作③和操作④对应的语句放在BEGIN TRANSACTION …COMMIT TRANSACTION即可。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Ø  有时候DML语句执行失败并不一定是由硬件故障等外部因素造成的，也有可能是由内部运行错误（如违反约束等）造成的，从而导致相应的DML语句执行失败。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Ø  如果在一个事务中，既有成功执行的DML语句，也有因内部错误而导致失败执行的DML语句，那么该事务会自动回滚吗？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   &lt;/span&gt; 一般来说，执行SQL语句产生运行时错误时，SQL Server只回滚产生错误的SQL语句，而不会回滚整个事务。如果希望当遇到某一个SQL 语句产生运行时错误时，事务能够自动回滚整个事务，则SET XACT_ABORT选项设置为ON（默认值为OFF）：SET XACT_ABORT ON&lt;/p&gt;
&lt;p&gt;ü 即当SET XACT_ABORT为ON时，如果执行SQL语句产生运行时错误，则整个事务将终止并回滚；&lt;/p&gt;
&lt;p&gt;ü 当SET XACT_ABORT为OFF时，有时只回滚产生错误的SQL语句，而事务将继续进行处理。&lt;/p&gt;
&lt;p&gt;ü 如果错误很严重，那么即使SET XACT_ABORT为OFF，也可能回滚整个事务。OFF 是默认设置。&lt;/p&gt;
&lt;p&gt;Ø  注意，编译错误（如语法错误）不受SET XACT_ABORT的影响。&lt;/p&gt;

&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;【例10.2】回滚包含运行时错误的事务。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Ø 先观察下列代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;USE&lt;/span&gt;&lt;span&gt; MyDatabase;

&lt;/span&gt;&lt;span&gt;GO&lt;/span&gt;

&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt; TestTransTable1(c1 &lt;span&gt;char&lt;/span&gt;(&lt;span&gt;3&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;, c2 &lt;span&gt;char&lt;/span&gt;(&lt;span&gt;3&lt;/span&gt;&lt;span&gt;));

&lt;/span&gt;&lt;span&gt;GO&lt;/span&gt;

&lt;span&gt;BEGIN&lt;/span&gt; &lt;span&gt;TRAN&lt;/span&gt; 

   &lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; TestTransTable1 &lt;span&gt;VALUES&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;aa1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;aa2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);       

   &lt;/span&gt;&lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; TestTransTable1 &lt;span&gt;VALUES&lt;/span&gt;(&lt;span&gt;NULL&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;bb2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;);   &lt;span&gt;--&lt;/span&gt;&lt;span&gt; 违反非空约束&lt;/span&gt;

   &lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; TestTransTable1 &lt;span&gt;VALUES&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;cc1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;cc2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;COMMIT&lt;/span&gt; &lt;span&gt;TRAN&lt;/span&gt;; 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;span&gt;Ø 上述代码的作用是：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  （1）先创建表TestTransTable1，其中字段c1有非空约束；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  （2）创建了一个事务，其中包含三条INSERT语句，用于向表TestTransTable1插入数据。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;Ø 第二条INSER语句违反了非空约束。根据事务的概念，于是许多读者可能会得到这样的结论：由于第二条INSERT语句违反非空约束，因此该语句执行失败，从而导致整个事务被回滚，使得所有的INSERT语句都不被执行，数据库回到事务开始时的状态——表TestTransTable1仍然为空。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Ø  但实际情况并不是这样。我们使用SELECT语句查看表TestTransTable1：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;SELECT * FROM TestTransTable1;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Ø  结果如图10.2所示。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1427277/201906/1427277-20190622221249628-2061631821.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Ø  图10.2表明，只有第二条记录没有被插入，第一和第三条都被成功插入了，可见事务并没有产生回滚。但如果将XACT_ABORT设置为ON，当出现违反非空约束而导致语句执行失败时，整个事务将被回滚。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; 【例子】执行下列代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;USE&lt;/span&gt;&lt;span&gt; MyDatabase;

&lt;/span&gt;&lt;span&gt;GO&lt;/span&gt;

&lt;span&gt;SET&lt;/span&gt; XACT_ABORT &lt;span&gt;ON&lt;/span&gt;;     &lt;span&gt;--&lt;/span&gt;&lt;span&gt; 将XACT_ABORT设置为ON  xact_abort&lt;/span&gt;

&lt;span&gt;GO&lt;/span&gt;

&lt;span&gt;DROP&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt;&lt;span&gt; TestTransTable1;

&lt;/span&gt;&lt;span&gt;GO&lt;/span&gt;

&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt; TestTransTable1(c1 &lt;span&gt;char&lt;/span&gt;(&lt;span&gt;3&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;, c2 &lt;span&gt;char&lt;/span&gt;(&lt;span&gt;3&lt;/span&gt;&lt;span&gt;));

&lt;/span&gt;&lt;span&gt;GO&lt;/span&gt;

&lt;span&gt;BEGIN&lt;/span&gt; &lt;span&gt;TRAN&lt;/span&gt; 

   &lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; TestTransTable1 &lt;span&gt;VALUES&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;aa1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;aa2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);       

   &lt;/span&gt;&lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; TestTransTable1 &lt;span&gt;VALUES&lt;/span&gt;(&lt;span&gt;NULL&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;bb2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;);   &lt;span&gt;--&lt;/span&gt;&lt;span&gt; 违反非空约束&lt;/span&gt;

   &lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; TestTransTable1 &lt;span&gt;VALUES&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;cc1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;cc2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;COMMIT&lt;/span&gt; &lt;span&gt;TRAN&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;SET&lt;/span&gt; XACT_ABORT &lt;span&gt;OFF&lt;/span&gt;;     &lt;span&gt;--&lt;/span&gt;&lt;span&gt; 将XACT_ABORT改回默认设置OFF&lt;/span&gt;

&lt;span&gt;GO&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;Ø然后用SELECT语句查询表TestTransTable1，结果发现，表TestTransTable1中并没有数据。这说明，上述事务已经被回滚。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Ø类似地，例10.1也有同样的问题。比如，如果用CHECK将字段balance设置在一定的范围内，那么余额超出这个范围时会违反这个CHECK约束。但定义的事务virement在出现违反约束情况下却无法保证数据的一致性。显然，通过将XACT_ABORT设置为ON，这个问题就可以得到解决。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;


&lt;p&gt;2. 回滚事务——ROLLBACK TRANSACTION&lt;/p&gt;
&lt;p&gt;        回滚事务是利用ROLLBACK TRANSACTION语句来实现，它可以将显式事务或隐性事务回滚到事务的起点或事务内的某个保存点（savepoint）。该语句的语法如下： &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;ROLLBACK&lt;/span&gt; { &lt;span&gt;TRAN&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;TRANSACTION&lt;/span&gt;&lt;span&gt; }

     &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt; transaction_name | @tran_name_variable

     | savepoint_name | @savepoint_variable &lt;/span&gt;&lt;span&gt;]&lt;/span&gt;

&lt;span&gt;[&lt;/span&gt;&lt;span&gt; ; &lt;/span&gt;&lt;span&gt;]&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Ø  transaction_name | @tran_name_variable &lt;/p&gt;
&lt;p&gt;      该参数用于指定由BEGIN TRANSACTION语句分配的事务的名称。嵌套事务时，transaction_name 必须是最外面的BEGIN TRANSACTION语句中的名称。&lt;/p&gt;


&lt;p&gt;Ø savepoint_name | @savepoint_variable&lt;/p&gt;
&lt;p&gt;        该参数为SAVE TRANSACTION语句中指定的保存点。指定了该参数，则回滚时数据库将恢复到该保存点时的状态（而不是事务开始时的状态）。不带savepoint_name和transaction_name的ROLLBACK TRANSACTION语句将使事务回滚到起点。&lt;/p&gt;
&lt;p&gt;Ø  根据在ROLLBACK TRANSACTION语句中是否使用保存点，可以将回滚分为全部回滚和部分回滚。&lt;/p&gt;
&lt;p&gt;    （1）全部回滚&lt;/p&gt;

&lt;p&gt;&lt;span&gt;【例10.3】全部回滚事务。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       下面代码先定义表TestTransTable2，然后在事务myTrans1中执行三条插入语句，事务结束时用ROLLBACK TRANSACTION语句全部回滚事务，之后又执行两条插入语句，以观察全部回滚事务的效果。代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;USE&lt;/span&gt;&lt;span&gt; MyDatabase;

&lt;/span&gt;&lt;span&gt;GO&lt;/span&gt;

&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt; TestTransTable2(c1 &lt;span&gt;char&lt;/span&gt;(&lt;span&gt;3&lt;/span&gt;), c2 &lt;span&gt;char&lt;/span&gt;(&lt;span&gt;3&lt;/span&gt;&lt;span&gt;));

&lt;/span&gt;&lt;span&gt;GO&lt;/span&gt;

&lt;span&gt;DECLARE&lt;/span&gt; &lt;span&gt;@TransactionName&lt;/span&gt; &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;20&lt;/span&gt;) &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;myTrans1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;BEGIN&lt;/span&gt; &lt;span&gt;TRAN&lt;/span&gt; &lt;span&gt;@TransactionName&lt;/span&gt;

    &lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; TestTransTable2 &lt;span&gt;VALUES&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;aa1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;aa2’);

    INSERT INTO TestTransTable2 VALUES(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;bb1&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;bb2’);

    &lt;/span&gt;&lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; TestTransTable2 &lt;span&gt;VALUES&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;cc1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;cc2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;ROLLBACK&lt;/span&gt; &lt;span&gt;TRAN&lt;/span&gt; &lt;span&gt;@TransactionName&lt;/span&gt;  &lt;span&gt;--&lt;/span&gt;&lt;span&gt; 回滚事务&lt;/span&gt;

&lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; TestTransTable2 &lt;span&gt;VALUES&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;dd1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;dd2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; TestTransTable2 &lt;span&gt;VALUES&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ee1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ee2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;FROM&lt;/span&gt; TestTransTable2
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1427277/201906/1427277-20190622221711686-1048117750.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;     执行上述代码，结果如图10.3所示&lt;/p&gt;

&lt;p&gt;Ø  以上可以看到，事务myTrans1中包含的三条插入语句并没有实现将相应的三条数据记录插入到表TestTransTable2中，&lt;/p&gt;
&lt;p&gt;     原因：在于ROLLBACK TRAN语句对整个事务进行全部回滚，使得数据库回到执行这三条插入语句之前的状态。事务myTrans1之后又执行了两条插入语句，这时是处于事务自动提交模式（每一条SQL语句就是一个事务，并且这种事务结束后会自动提交，而没有回滚）下，因此这两条插入语句成功地将两条数据记录插入到数据库中。&lt;/p&gt;
&lt;p&gt;Ø  根据ROLLBACK的语法，在本例中，BEGIN TRAN及其ROLLBACK TRAN后面的@TransactionName可以省略，其效果是一样的。&lt;/p&gt;



&lt;p&gt;（2）部分回滚&lt;/p&gt;
&lt;p&gt;Ø 如果在事务中设置了保存点（即ROLLBACK TRANSACTION语句带参数savepoint_name | @savepoint_variable）时，ROLLBACK TRANSACTION语句将回滚到由savepoint_name或@savepoint_variable指定的保存点上。&lt;/p&gt;
&lt;p&gt;Ø 在事务内设置保存点是使用SAVE TRANSACTION语句来实现，其语法如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SAVE&lt;/span&gt; { &lt;span&gt;TRAN&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;TRANSACTION&lt;/span&gt; } { savepoint_name &lt;span&gt;|&lt;/span&gt; &lt;span&gt;@savepoint_variable&lt;/span&gt;&lt;span&gt; }

&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt; ; &lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;savepoint_name | @savepoint_variable是保存点的名称，必须指定。&lt;/p&gt;


&lt;p&gt;&lt;span&gt;【例10.4】部分回滚事务。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     在例10.3所定义的事务中利用SAVE TRANSACTION语句增加一个保存点save1，同时修改ROLLBACK语句，其他代码相同。所有代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;USE&lt;/span&gt;&lt;span&gt; MyDatabase;

&lt;/span&gt;&lt;span&gt;GO&lt;/span&gt;

&lt;span&gt;DROP&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt;&lt;span&gt; TestTransTable2;

&lt;/span&gt;&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt; TestTransTable2(c1 &lt;span&gt;char&lt;/span&gt;(&lt;span&gt;3&lt;/span&gt;), c2 &lt;span&gt;char&lt;/span&gt;(&lt;span&gt;3&lt;/span&gt;&lt;span&gt;));

&lt;/span&gt;&lt;span&gt;GO&lt;/span&gt;

&lt;span&gt;DECLARE&lt;/span&gt; &lt;span&gt;@TransactionName&lt;/span&gt; &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;20&lt;/span&gt;) &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;myTrans1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;BEGIN&lt;/span&gt; &lt;span&gt;TRAN&lt;/span&gt; &lt;span&gt;@TransactionName&lt;/span&gt;

&lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; TestTransTable2 &lt;span&gt;VALUES&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;aa1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;aa2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; TestTransTable2 &lt;span&gt;VALUES&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;bb1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;bb2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;SAVE&lt;/span&gt; &lt;span&gt;TRANSACTION&lt;/span&gt; save1;          &lt;span&gt;--&lt;/span&gt;&lt;span&gt; 设置保存点&lt;/span&gt;

    &lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; TestTransTable2 &lt;span&gt;VALUES&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;cc1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;cc2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);         

&lt;/span&gt;&lt;span&gt;ROLLBACK&lt;/span&gt; &lt;span&gt;TRAN&lt;/span&gt;&lt;span&gt; save1;   

&lt;/span&gt;&lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; TestTransTable2 &lt;span&gt;VALUES&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;dd1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;dd2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; TestTransTable2 &lt;span&gt;VALUES&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ee1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ee2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;FROM&lt;/span&gt; TestTransTable2
&lt;/pre&gt;&lt;/div&gt;




&lt;p&gt;      执行结果如图10.4所示。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1427277/201906/1427277-20190622221932740-1812578036.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;    此结果表明，只有第三条插入语句的执行结果被撤销了。其原因在于，事务myTrans1结束时ROLLBACK TRAN语句回滚保存点save1处，即回滚到第三条插入语句执行之前，故第三条插入语句的执行结果被撤销，其他插入语句的执行结果是有效的。&lt;/p&gt;

&lt;h3&gt;10.2.3 嵌套事务&lt;/h3&gt;
&lt;p&gt;Ø 事务是允许嵌套的，即一个事务内可以包含另外一个事务。当事务嵌套时，就存在多个事务同时处于活动状态。&lt;/p&gt;

&lt;p&gt;Ø 系统全局变量@@TRANCOUNT可返回当前连接的活动事务的个数。对@@TRANCOUNT返回值有影响的是BEGIN TRANSACTION、ROLLBACK TRANSACTION和COMMIT语句。具体影响方式如下：&lt;/p&gt;
&lt;p&gt;ü 每执行一次BEGIN TRANSACTION命令就会使@@TRANCOUNT的值增加1；&lt;/p&gt;
&lt;p&gt;ü 每执行一次COMMIT命令时，@@TRANCOUNT的值就减1；&lt;/p&gt;
&lt;p&gt;ü 一旦执行到ROLLBACK TRANSACTION命令（全部回滚）时，@@TRANCOUNT的值将变为0；&lt;/p&gt;
&lt;p&gt;ü 但ROLLBACK TRANSACTION savepoint_name（部分回滚）不影响@@TRANCOUNT的值。&lt;/p&gt;


&lt;p&gt;&lt;span&gt;【例10.5】嵌套事务。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       本例中，先创建表TestTransTable3，然后在有三个嵌套层的嵌套事务中向该表插入数据，并在每次启动或提交一个事务时都打印@@TRANCOUNT的值。代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;USE&lt;/span&gt;&lt;span&gt; MyDatabase;

&lt;/span&gt;&lt;span&gt;GO&lt;/span&gt;

&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt; TestTransTable3(c1 &lt;span&gt;char&lt;/span&gt;(&lt;span&gt;3&lt;/span&gt;), c2 &lt;span&gt;char&lt;/span&gt;(&lt;span&gt;3&lt;/span&gt;&lt;span&gt;));

&lt;/span&gt;&lt;span&gt;GO&lt;/span&gt;

&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;@@TRANCOUNT&lt;/span&gt;&lt;span&gt;!=&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;) &lt;span&gt;ROLLBACK&lt;/span&gt; &lt;span&gt;TRAN&lt;/span&gt;;  &lt;span&gt;--&lt;/span&gt;&lt;span&gt; 先终止所有事务&lt;/span&gt;

&lt;span&gt;BEGIN&lt;/span&gt; &lt;span&gt;TRAN&lt;/span&gt;&lt;span&gt; Trans1

      &lt;/span&gt;&lt;span&gt;PRINT&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;启动事务Trans1后@@TRANCOUNT的值：&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;CAST&lt;/span&gt;(&lt;span&gt;@@TRANCOUNT&lt;/span&gt; &lt;span&gt;AS&lt;/span&gt; &lt;span&gt;VARCHAR&lt;/span&gt;(&lt;span&gt;10&lt;/span&gt;&lt;span&gt;));

       &lt;/span&gt;&lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; TestTransTable3 &lt;span&gt;VALUES&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;aa1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;aa2’);

       BEGIN TRAN Trans2

    PRINT &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;启动事务Trans2后&lt;span&gt;@@TRANCOUNT的值&lt;/span&gt;：&lt;span&gt;'&lt;/span&gt;&lt;span&gt;+CAST(@@TRANCOUNT AS VARCHAR(10));

   INSERT INTO TestTransTable3 VALUES(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;bb1&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;bb2&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);

      BEGIN TRAN Trans3

            PRINT &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;启动事务Trans3后&lt;span&gt;@@TRANCOUNT的值&lt;/span&gt;：&lt;span&gt;'&lt;/span&gt;&lt;span&gt;+CAST(@@TRANCOUNT AS VARCHAR(10));

            INSERT INTO TestTransTable3 VALUES(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;cc1&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;cc2&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);        

            SAVE TRANSACTION save1;         -- 设置保存点

            PRINT &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;设置保存点save1后&lt;span&gt;@@TRANCOUNT的值&lt;/span&gt;：&lt;span&gt;'&lt;/span&gt;&lt;span&gt;+CAST(@@TRANCOUNT AS VARCHAR(10));

            INSERT INTO TestTransTable3 VALUES(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;dd1&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;dd2&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);         

            ROLLBACK TRAN save1;

            PRINT &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;回滚到保存点save1后&lt;span&gt;@@TRANCOUNT的值&lt;/span&gt;：&lt;span&gt;'&lt;/span&gt;&lt;span&gt;+CAST(@@TRANCOUNT AS VARCHAR(10));  

           INSERT INTO TestTransTable3 VALUES(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;ee1&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;ee2&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);

       COMMIT TRAN Trans3

       PRINT &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;提交Trans3后&lt;span&gt;@@TRANCOUNT的值&lt;/span&gt;：&lt;span&gt;'&lt;/span&gt;&lt;span&gt;+CAST(@@TRANCOUNT AS VARCHAR(10));

       INSERT INTO TestTransTable3 VALUES(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;ff1&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ff2’);

              &lt;/span&gt;&lt;span&gt;COMMIT&lt;/span&gt; &lt;span&gt;TRAN&lt;/span&gt;&lt;span&gt; Trans2

              &lt;/span&gt;&lt;span&gt;PRINT&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;提交Trans2后@@TRANCOUNT的值：&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;CAST&lt;/span&gt;(&lt;span&gt;@@TRANCOUNT&lt;/span&gt; &lt;span&gt;AS&lt;/span&gt; &lt;span&gt;VARCHAR&lt;/span&gt;(&lt;span&gt;10&lt;/span&gt;&lt;span&gt;));

     &lt;/span&gt;&lt;span&gt;COMMIT&lt;/span&gt; &lt;span&gt;TRAN&lt;/span&gt;&lt;span&gt; Trans1

     &lt;/span&gt;&lt;span&gt;PRINT&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;提交Trans1后@@TRANCOUNT的值：&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;CAST&lt;/span&gt;(&lt;span&gt;@@TRANCOUNT&lt;/span&gt; &lt;span&gt;AS&lt;/span&gt; &lt;span&gt;VARCHAR&lt;/span&gt;(&lt;span&gt;10&lt;/span&gt;));
&lt;/pre&gt;&lt;/div&gt;



&lt;p&gt;Ø  执行上述代码，结果如图13.5所示。&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1427277/201906/1427277-20190622222144928-1965957777.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;Ø  从图10.5中也可以可以看出，每执行一次BEGIN TRANSACTION命令就会使@@TRANCOUNT的值增加1，每执行一次COMMIT命令时，@@TRANCOUNT的值就减1，但ROLLBACK TRANSACTION savepoint_name不影响@@TRANCOUNT的值。&lt;/p&gt;

&lt;p&gt;Ø  如果遇到ROLLBACK TRANSACTION命令，不管该命令之后是否还有其他的COMMIT命令，系统中所有的事务都被终止（不提交），@@TRANCOUNT的值为0。&lt;/p&gt;
&lt;p&gt;Ø  执行上述嵌套事务后，表TestTransTable3中的数据如图10.6所示。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1427277/201906/1427277-20190622222222359-1469788262.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;Ø  如果将上述代码中的语句COMMIT TRAN Trans1（倒数第二条）改为ROLLBACK TRAN（不带参数），则表TestTransTable3中将没有任何数据。这说明，对于嵌套事务，不管内层是否使用COMMIT命令来提交事务，只要外层事务中使用ROLLBACK TRAN来回滚，那么整个嵌套事务都被回滚，数据库将回到嵌套事务开始时的状态。&lt;/p&gt;

&lt;h2&gt;•    10.3 并发控制&lt;/h2&gt;

&lt;h3&gt;10.3.1 并发控制的概念&lt;/h3&gt;
&lt;p&gt;Ø 数据共享是数据库的基本功能之一。一个数据库可能同时拥有多个用户，这意味着在同一时刻系统中可能同时运行上百上千个事务。而每个事务又是由若干个数据库操作构成的操作序列，如何有效地控制这些操作的执行对提高系统的安全性和运行效率有着十分重要的意义。&lt;/p&gt;
&lt;p&gt;Ø 在单CPU系统中，事务的运行有两种方式，一种是串行执行，一种是并发执行。串行执行是指每个时刻系统中只有一个事务在运行，其他事务必须等到该事务中所有的操作执行完了以后才能运行。这种执行方式的优点是方便控制，但其缺点却是十分突出，那就是整个系统的运行效率很低。因为在串行方式中，不同的操作需要不同的资源，但一个操作一般不会使用所有的资源且使用时间长短不一，所以串行执行的事务会使许多系统资源处于空闲状态。&lt;/p&gt;
&lt;p&gt;Ø  如果能够充分利用这些空闲的资源，无疑可以有效提高系统的运行效率，这是考虑事务并发控制的主要原因之一。另外，并发控制可以更好保证数据的一致性，从而实现数据的安全性。&lt;/p&gt;
&lt;p&gt;Ø  在并发执行方式中，系统允许同一个时刻有多个事务在并行执行。这种并行执行实际上是通过事务操作的轮流交叉执行来实现的。虽然在同一时刻只有某一个事务的某一个操作在占用CPU资源，但其他事务中的操作可以使用该操作没有占用的有关资源，这样可以在总体上提高系统的运行效率。&lt;/p&gt;
&lt;p&gt;Ø  对于并发运行的事务，如果没有有效地控制其操作，就可能导致对资源的不合理使用，对数据库而言就可能导致数据的不一致性和不完整性等问题。因此，DBMS必须提供一种允许多个用户同时对数据进行存取访问的并发控制机制，以确保数据库的一致性和完整性。&lt;/p&gt;
&lt;p&gt;Ø  简而言之，并发控制就是针对并发执行的事务，如何有效地控制和调度其交叉执行的数据库操作，使各事务的执行不相互干扰，以避免出现数据库的不一致性和不完整性等问题。&lt;/p&gt;


&lt;h3&gt;10.3.2 几种并发问题&lt;/h3&gt;
&lt;p&gt;        当多个用户同时访问数据库时，如果没有必要的访问控制措施，可能会引发数据不一致等并发问题，这是诱发并发控制的主要原因。为进行有效的并发控制，首先要明确并发问题的类型，分析不一致问题产生的根源。&lt;/p&gt;
&lt;p&gt;1. 丢失修改（Lost Update）&lt;/p&gt;
&lt;p&gt;       下面看一个经典的关于民航订票系统的例子。它可以说明多个事务对数据库的并发操作带来的不一致性问题。&lt;/p&gt;
&lt;p&gt;【&lt;span&gt;例子】假设某个民航订票系统有两个售票点，分别为售票点A和售票点B。假设系统把一次订票业务定义为一个事务，其包含的数据库操作序列如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;T：Begin Transaction&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     读取机票余数x;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     售出机票y张，机票余数x ← x – y;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     把x写回数据库，修改数据库中机票的余数;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Commit;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;Ø  假设当前机票余数为10张，售票点A和售票点B同时进行一次订票业务，分别有用户订4张和3张机票。于是在系统中同时形成两个事务，分别记为TA和TB。如果事务TA和TB中的操作交叉执行，执行过程如图10.7所示。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1427277/201906/1427277-20190622222504646-796284162.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;











&lt;p&gt;     &lt;span&gt;  事务TA和TB执行完了以后，由于B_op3是最后的操作，所以数据库中机票的余数6。而实际情况是，售票点A售出4张，售票点B售出3张，所以实际剩下10-(4+3) = 3张机票。这就造成了数据库反映的信息与实际情况不符，从而产生了数据的不一致性。这种不一致性是由操作B_op3的（对数据库的）修改结果将操作A_op3的修改结果覆盖掉而产生的，即A_op3的修改结果“丢了”，所以称为丢失修改。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;2. 读“脏”数据（Dirty Read）&lt;/p&gt;
&lt;p&gt;Ø 事务TC对某一数据处理了以后将结果写回到数据区，然后事务TD从数据区中读取该数据。但事务TC出于某种原因进行回滚操作，撤消已做出的操作，这时TD刚读取的数据又被恢复到原值（事务TC开始执行时的值），这样TD读到的数据就与数据库中的实际数据不一致了，而TD读取的数据就是所谓的“脏”数据（不正确的数据）。“脏”数据是指那些被某事务更改、但还没有被提交的数据。&lt;/p&gt;


&lt;p&gt;&lt;span&gt;   【例子】  在订票系统中，事务TC在读出机票余数10并售出4张票后，将机票余数10-4=6写到数据区（还没来得及提交），恰在此时事务TD读取机票余数6，而TC出于某种原因（如断电等）进行回滚操作，机票余数恢复到了原来的值10并撤销此次售票操作，但这时事务TD仍然使用着读到的机票余数6，这与数据库中实际的机票余数不一致，这个“机票余数6”就是所谓的“脏”数据，如图10.8所示。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1427277/201906/1427277-20190622222620655-403853201.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;




&lt;p&gt;3. 不可重复读（Non-Repeatable Read）&lt;/p&gt;
&lt;p&gt;Ø  事务TE按照一定条件读取数据库中某数据x，随后事务TF又修改了数据x，这样当事务TE操作完了以后又按照相同条件读取数据x，但这时由于数据x已经被修改，所以这次读取值与上一次不一致，从而在进行同样的操作后却得到不一样的结果。由于另一个事务对数据的修改而导致当前事务两次读到的数据不一致，这种情况就是不可重复读。这与读“脏”数据有相似之处。&lt;/p&gt;
&lt;p&gt;   &lt;span&gt;【例子】  在图10.9中c代表机票的价格，n代表机票的张数。机票查询事务TE读取机票价格c = 800和机票张数n = 7，接着计算这7张票的总价钱5600（可能有人想查询7张机票总共需要多少钱）；恰好在计算总价钱完后，管理事务TF（相关航空公司执行）读取c = 800并进行六五折降价处理后将c = 520写回数据库；这时机票查询事务TE重读c（可能为验证总价钱的正确性），结果得到c=520，这与第一次读取值不一致。显然，这种不一致性会导致系统给出错误的信息，这是不允许的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1427277/201906/1427277-20190622232210046-310746144.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;



&lt;p&gt;4. 幻影读（Phantom Row）&lt;/p&gt;
&lt;p&gt;Ø 假设事务TG按照一定条件两次读取表中的某些数据记录，在第一次读取数据记录后事务TH在该表中删除（或添加）某些记录。这样在事务TG第二次按照同样条件读取数据记录时会发现有些记录“幻影”般地消失（或增多）了，这称为幻影（Phantom Row）读。&lt;/p&gt;
&lt;p&gt;Ø 导致以上四种不一致性产生的原因是并发操作的随机调度，这使事务的隔离性遭到破坏。为此，需要采取相应措施，对所有数据库操作的执行次序进行合理而有效的安排，使得各个事务都能够独立地运行、彼此不相互干扰，保证事务的ACID特性，避免出现数据不一致性等并发问题。&lt;/p&gt;


&lt;h3&gt;10.3.3 基于事务隔离级别的并发控制&lt;/h3&gt;
&lt;p&gt;Ø 保证事务的隔离性可以有效防止数据不一致等并发问题。事务的隔离性有程度之别，这就是事务隔离级别。在SQL Server中，事务的隔离级别用于表征一个事务与其他事务进行隔离的程度。隔离级别越高，就可以更好地保证数据的正确性，但并发程度和效率就越低；相反，隔离级别越低，出现数据不一致性的可能性就越大，但其并发程度和效率就越高。通过设定不同事务隔离级别可以实现不同层次的访问控制需求。&lt;/p&gt;


&lt;p&gt;Ø 在SQL Server中，事务隔离级别分为四种：READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ、SERIALIZABLE，它们对数据访问的限制程度依次从低到高。设置隔离级别是通过SET TRANSACTION ISOLATION LEVEL语句来实现，其语法如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
ET &lt;span&gt;TRANSACTION&lt;/span&gt; &lt;span&gt;ISOLATION&lt;/span&gt; &lt;span&gt;LEVEL&lt;/span&gt;&lt;span&gt;

    { &lt;/span&gt;&lt;span&gt;READ&lt;/span&gt; &lt;span&gt;UNCOMMITTED&lt;/span&gt;

    &lt;span&gt;|&lt;/span&gt; &lt;span&gt;READ&lt;/span&gt; &lt;span&gt;COMMITTED&lt;/span&gt;

    &lt;span&gt;|&lt;/span&gt; &lt;span&gt;REPEATABLE&lt;/span&gt; &lt;span&gt;READ&lt;/span&gt;

    &lt;span&gt;|&lt;/span&gt; &lt;span&gt;SERIALIZABLE&lt;/span&gt;&lt;span&gt;

    }

&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt; ; &lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;





&lt;p&gt;1. 使用READ UNCOMMITTED&lt;/p&gt;
&lt;p&gt;Ø 该隔离级别允许读取已经被其他事务修改过但尚未提交的数据，实际上该隔离级别根本就没有提供事务间的隔离。这种隔离级别是四种隔离级别中限制最少的一种，级别最低。&lt;/p&gt;
&lt;p&gt;Ø 其作用可简记为：允许读取未提交数据。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  【例10.6】使用READ UNCOMMITTED隔离级别，允许丢失修改。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    当事务的隔离级别设置为READ UNCOMMITTED时，SQL Server允许用户读取未提交的数据，因此会造成丢失修改。为观察这种效果，按序完成下列步骤：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）创建表TestTransTable4并插入两条数据：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt; TestTransTable4(flight &lt;span&gt;char&lt;/span&gt;(&lt;span&gt;4&lt;/span&gt;), price &lt;span&gt;float&lt;/span&gt;, &lt;span&gt;number&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; TestTransTable4 &lt;span&gt;VALUES&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;A111&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;800&lt;/span&gt;,&lt;span&gt;10&lt;/span&gt;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; TestTransTable4 &lt;span&gt;VALUES&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;A222&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;1200&lt;/span&gt;,&lt;span&gt;20&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;     其中，flight、price、number分别代表航班号、机票价格、剩余票数。&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;（2）编写事务TA和TB的代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;--&lt;/span&gt;&lt;span&gt; 事务TA的代码&lt;/span&gt;

&lt;span&gt;SET&lt;/span&gt; &lt;span&gt;TRANSACTION&lt;/span&gt; &lt;span&gt;ISOLATION&lt;/span&gt; &lt;span&gt;LEVEL&lt;/span&gt; &lt;span&gt;READ&lt;/span&gt; &lt;span&gt;UNCOMMITTED&lt;/span&gt;; &lt;span&gt;--&lt;/span&gt;&lt;span&gt; 设置事务隔离级别&lt;/span&gt;

&lt;span&gt;BEGIN&lt;/span&gt; &lt;span&gt;TRAN&lt;/span&gt;&lt;span&gt; TA

      &lt;/span&gt;&lt;span&gt;DECLARE&lt;/span&gt; &lt;span&gt;@n&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;;

      &lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;@n&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;number&lt;/span&gt; &lt;span&gt;FROM&lt;/span&gt; TestTransTable4 &lt;span&gt;WHERE&lt;/span&gt; flight &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;A111’;

      WAITFOR DELAY &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;10&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;              -- 等待事务TB读数据

      SET @n = @n - 4;

      UPDATE TestTransTable4 SET number = @n WHERE flight = &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;A111&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

COMMIT TRAN TA

 

-- 事务TB的代码

SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

BEGIN TRAN TB

     DECLARE @n int;

     SELECT @n = number FROM TestTransTable4 WHERE flight = &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;A111’;

     &lt;/span&gt;&lt;span&gt;WAITFOR&lt;/span&gt; DELAY &lt;span&gt;'&lt;/span&gt;&lt;span&gt;00:00:15&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;         &lt;span&gt;--&lt;/span&gt;&lt;span&gt; 等待，以让事务TA先提交数据&lt;/span&gt;

     &lt;span&gt;SET&lt;/span&gt; &lt;span&gt;@n&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;@n&lt;/span&gt; &lt;span&gt;-&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;UPDATE&lt;/span&gt; TestTransTable4 &lt;span&gt;SET&lt;/span&gt; &lt;span&gt;number&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;@n&lt;/span&gt; &lt;span&gt;WHERE&lt;/span&gt; flight &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;A111&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;COMMIT&lt;/span&gt; &lt;span&gt;TRAN&lt;/span&gt;  TB
&lt;/pre&gt;&lt;/div&gt;



&lt;p&gt;&lt;span&gt;（3）打开两个查询窗口，分别在两个窗口中先后执行事务TA和TB（执行TA后应该在10秒以内执行TB，否则看不到预设的结果），分别如图10.10和图10.11所示。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1427277/201906/1427277-20190622232650888-1972323657.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1427277/201906/1427277-20190622232706983-941332866.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;




&lt;p&gt;（4）查询表中的数据：&lt;/p&gt;
&lt;p&gt;          SELECT * FROM TestTransTable4;&lt;/p&gt;
&lt;p&gt;          结果如图10.12所示。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1427277/201906/1427277-20190622232808868-856037319.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;        由代码可知，事务TA和TB分别售出了4张和3张票，因此应该剩下10-(4+3) = 3张票。但由图10.12可以看到，系统还剩下7张票。这就是丢失修改的结果。当隔离级别为READ UNCOMMITTED时，事务不能防止丢失修改。&lt;/p&gt;
&lt;p&gt;        实际上，对于前面介绍的四种数据不一致情况，READ UNCOMMITTED隔离级别都不能防止它们。这是READ UNCOMMITTED隔离级别的缺点。其优点是可避免并发控制所需增加的系统开销，一般用于单用户系统（不适用于并发场合）或者系统中两个事务同时访问同一资源的可能性为零或几乎为零。&lt;/p&gt;


&lt;p&gt;2. 使用READ COMMITTED&lt;/p&gt;
&lt;p&gt;Ø 在使用该隔离级别时，当一个事务已经对一个数据块进行了修改（UPDATE）但尚未提交或回滚时，其他事务不允许读取该数据块，即该隔离级别不允许读取未提交的数据。它的隔离级别比READ UNCOMMITTED高一层，可以防止读“脏”，但不能防止丢失修改，也不能防止不可重复读和“幻影”读。 &lt;/p&gt;
&lt;p&gt;Ø 其作用可简记为：不允许读取已修改但未提交数据。&lt;/p&gt;
&lt;p&gt;Ø READ COMMITTED是SQL Server默认的事务隔离级别。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  【例10.7】使用READ COMMITTED隔离级别，防止读“脏”数据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     先恢复表TestTransTable4中的数据：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;DELETE FROM TestTransTable4;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;INSERT INTO TestTransTable4 VALUES('A111',800,10);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;INSERT INTO TestTransTable4 VALUES('A222',1200,20);&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;Ø  为观察读“脏”数据，先将事务的隔离级别设置为READ UNCOMMITTED，分别在两个查询窗口中先后执行事务TC和TD：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;--&lt;/span&gt;&lt;span&gt; 事务TC的代码&lt;/span&gt;
&lt;span&gt;SET&lt;/span&gt; &lt;span&gt;TRANSACTION&lt;/span&gt; &lt;span&gt;ISOLATION&lt;/span&gt; &lt;span&gt;LEVEL&lt;/span&gt; &lt;span&gt;READ&lt;/span&gt; &lt;span&gt;UNCOMMITTED&lt;/span&gt;; &lt;span&gt;--&lt;/span&gt;&lt;span&gt; 设置事务隔离级别&lt;/span&gt;
&lt;span&gt;BEGIN&lt;/span&gt; &lt;span&gt;TRAN&lt;/span&gt;&lt;span&gt; TC
    &lt;/span&gt;&lt;span&gt;DECLARE&lt;/span&gt; &lt;span&gt;@n&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;@n&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;number&lt;/span&gt; &lt;span&gt;FROM&lt;/span&gt; TestTransTable4 &lt;span&gt;WHERE&lt;/span&gt; flight &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;A111’;
    SET @n = @n - 4;
    UPDATE TestTransTable4 SET number = @n WHERE flight = &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;A111’;
    &lt;/span&gt;&lt;span&gt;WAITFOR&lt;/span&gt; DELAY &lt;span&gt;'&lt;/span&gt;&lt;span&gt;00:00:10&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;             &lt;span&gt;--&lt;/span&gt;&lt;span&gt; 等待事务TD读“脏”数据&lt;/span&gt;
&lt;span&gt;ROLLBACK&lt;/span&gt; &lt;span&gt;TRAN&lt;/span&gt; TC                 &lt;span&gt;--&lt;/span&gt;&lt;span&gt; 回滚事务&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;




&lt;p&gt;&lt;span&gt;-- 事务TD的代码&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SET&lt;/span&gt; &lt;span&gt;TRANSACTION&lt;/span&gt; &lt;span&gt;ISOLATION&lt;/span&gt; &lt;span&gt;LEVEL&lt;/span&gt; &lt;span&gt;READ&lt;/span&gt; &lt;span&gt;UNCOMMITTED&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;BEGIN&lt;/span&gt; &lt;span&gt;TRAN&lt;/span&gt;&lt;span&gt; TD

     &lt;/span&gt;&lt;span&gt;DECLARE&lt;/span&gt; &lt;span&gt;@n&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;;

     &lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;@n&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;number&lt;/span&gt; &lt;span&gt;FROM&lt;/span&gt; TestTransTable4 &lt;span&gt;WHERE&lt;/span&gt; flight &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;A111&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;; &lt;span&gt;--&lt;/span&gt;&lt;span&gt; 读“脏”数据&lt;/span&gt;

     &lt;span&gt;PRINT&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;剩余机票数：&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;CONVERT&lt;/span&gt;(&lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;10&lt;/span&gt;),&lt;span&gt;@n&lt;/span&gt;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;COMMIT&lt;/span&gt; &lt;span&gt;TRAN&lt;/span&gt;    TD
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Ø  结果事务TD输出如下的结果：     剩余机票数：6&lt;/p&gt;
&lt;p&gt;Ø  在等待事务TC执行完了以后，利用SELECT语句查询表TestTransTable4，结果发现剩余机票数为10。6就是事务TD读到的“脏”数据。&lt;/p&gt;
&lt;p&gt;Ø  为了避免读到这个“脏”数据，只需将上述的隔离级别由READ UNCOMMITTED改为READ COMMITTED即可（其他代码不变）。但在将隔离级别更改了以后，我们发现事务TD要等事务TC回滚了以后（ROLLBACK）才执行读操作。READ COMMITTED虽然可以比READ UNCOMMITTED具有更好解决并发问题的能力，但是其效率较后者低。&lt;/p&gt;


&lt;p&gt;3. 使用REPEATABLE READ&lt;/p&gt;
&lt;p&gt;Ø 在该隔离级别下，如果一个数据块已经被一个事务读取但尚未作提交操作，则任何其他事务都不能修改（UPDATE）该数据块（但可以执行INSERT和DELETE），直到该事务提交或回滚后才能修改。该隔离级别的层次又在READ COMMITTED之上，即比READ COMMITTED有更多的限制，&lt;/p&gt;
&lt;p&gt;Ø 它可以防止读“脏”数据和不可重复读。但由于一个事务读取数据块后另一个事务可以执行INSERT和DELETE操作，所以它不能防止“幻影”读。另外，该隔离级别容易造成死锁。例如，将它用于解决例10.6中的丢失修改问题时，就造成死锁。&lt;/p&gt;
&lt;p&gt;Ø 其作用可简记为：不允许读取未提交数据，不允许修改已读数据。&lt;/p&gt;


&lt;p&gt;&lt;span&gt;【例10.8】使用REPEATABLE READ隔离级别，防止不可重复读。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Ø 先看看存在不可重复读的事务TE： 

&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt; 事务TE的代码&lt;/span&gt;

&lt;span&gt;SET&lt;/span&gt; &lt;span&gt;TRANSACTION&lt;/span&gt; &lt;span&gt;ISOLATION&lt;/span&gt; &lt;span&gt;LEVEL&lt;/span&gt; &lt;span&gt;READ&lt;/span&gt; &lt;span&gt;COMMITTED&lt;/span&gt;;  &lt;span&gt;--&lt;/span&gt;&lt;span&gt; 设置事务隔离级别&lt;/span&gt;

&lt;span&gt;BEGIN&lt;/span&gt; &lt;span&gt;TRAN&lt;/span&gt;&lt;span&gt; TE

       &lt;/span&gt;&lt;span&gt;DECLARE&lt;/span&gt; &lt;span&gt;@n&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;, &lt;span&gt;@c&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;;

       &lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt; 顾客先查询张机票的价格&lt;/span&gt;

      &lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;@c&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; price &lt;span&gt;FROM&lt;/span&gt; TestTransTable4 &lt;span&gt;WHERE&lt;/span&gt; flight &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;A111&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;;  &lt;span&gt;--&lt;/span&gt;&lt;span&gt; 第一次读&lt;/span&gt;

      &lt;span&gt;SET&lt;/span&gt; &lt;span&gt;@n&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;7&lt;/span&gt;&lt;span&gt;;

      &lt;/span&gt;&lt;span&gt;PRINT&lt;/span&gt; &lt;span&gt;CONVERT&lt;/span&gt;(&lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;10&lt;/span&gt;),&lt;span&gt;@n&lt;/span&gt;)&lt;span&gt;+&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;张机票的价格：&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;CONVERT&lt;/span&gt;(&lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;10&lt;/span&gt;),&lt;span&gt;@n&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;@c&lt;/span&gt;)&lt;span&gt;+&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;元’;

      WAITFOR DELAY &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;10&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;   -- 为观察效果，让该事务等待10秒

      -- 接着购买张机票

      SELECT @c = price FROM TestTransTable4 WHERE flight = &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;A111&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;  -- 第二次读

      SET @n = 7;

        PRINT &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;总共&lt;span&gt;'&lt;/span&gt;&lt;span&gt;+CONVERT(varchar(10),@n)+&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;张机票，应付款：&lt;span&gt;'&lt;/span&gt;&lt;span&gt;+CONVERT(varchar(10),@n*@c)+&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;元&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

COMMIT TRAN TE -- 提交事务&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Ø  另一事务TF的代码如下：

&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt; 事务TF的代码&lt;/span&gt;

&lt;span&gt;SET&lt;/span&gt; &lt;span&gt;TRANSACTION&lt;/span&gt; &lt;span&gt;ISOLATION&lt;/span&gt; &lt;span&gt;LEVEL&lt;/span&gt; &lt;span&gt;READ&lt;/span&gt; &lt;span&gt;COMMITTED&lt;/span&gt;;  &lt;span&gt;--&lt;/span&gt;&lt;span&gt; 设置事务隔离级别&lt;/span&gt;

&lt;span&gt;BEGIN&lt;/span&gt; &lt;span&gt;TRAN&lt;/span&gt;&lt;span&gt; TF

      &lt;/span&gt;&lt;span&gt;UPDATE&lt;/span&gt; TestTransTable4 &lt;span&gt;SET&lt;/span&gt; price &lt;span&gt;=&lt;/span&gt; price&lt;span&gt;*&lt;/span&gt;&lt;span&gt;0.65&lt;/span&gt; &lt;span&gt;WHERE&lt;/span&gt; flight &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;A111&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;; &lt;span&gt;--&lt;/span&gt;&lt;span&gt; 折价65折&lt;/span&gt;

&lt;span&gt;COMMIT&lt;/span&gt; &lt;span&gt;TRAN&lt;/span&gt; TF
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Ø  分别在两个查询窗口中先后运行事务TE和事务TF（时间间隔要小于10秒），事务TE输出的结果如图10.13所示。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1427277/201906/1427277-20190622233152238-1253209098.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;





&lt;p&gt;Ø  该结果说了事务TE出现了不可重复读：在相同条件下，利用两次读取的信息来计算的机票价格却不一样。原因在于，当事务TE处于10秒等待期时，事务TF对机票价格（price）进行六五折处理，结果导致了在同一事务中的两次读取操作获得不同的结果。&lt;/p&gt;
&lt;p&gt;Ø  如果将事务隔离级别由原来的READ COMMITTED改为REPEATABLE READ（其他代码不变），则就可以防止上述的不可重复读，如图10.14所示。这是因为REPEATABLE READ隔离级别不允许对事务TE已经读取的数据（价格）进行任何的更新操作，这样事务TF只能等待事务TE结束后才能对价格进行五六折处理，从而避免不可重复读问题。显然，由于出现事务TF等待事务TE的情况，因此使用REPEATABLE READ隔离级别时要比使用READ COMMITTED的效率低。&lt;/p&gt;

&lt;p&gt;4. 使用SERIALIZABLE&lt;/p&gt;
&lt;p&gt;Ø SERIALIZABLE是SQL Server最高的隔离级别。在该隔离级别下，一个数据块一旦被一个事务读取或修改，则不允许别的事务对这些数据进行更新操作（包括UPDATE, INSERT, DELETE），直到该事务提交或回滚。也就是说，一旦一个数据块被一个事务锁定，则其他事务如果需要修改此数据块，它们只能排队等待。SERIALIZABLE隔离级别的这些性质决定了它能够解决“幻影”读问题。&lt;/p&gt;
&lt;p&gt;Ø 其作用可简记为：事务必须串行执行。&lt;/p&gt;


&lt;p&gt;&lt;span&gt;【例10.9】使用SERIALIZABLE隔离级别，防止“幻影”读。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Ø 先看看存在“幻影”读的事务TG：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;--&lt;/span&gt;&lt;span&gt; 事务TG的代码&lt;/span&gt;

&lt;span&gt;SET&lt;/span&gt; &lt;span&gt;TRANSACTION&lt;/span&gt; &lt;span&gt;ISOLATION&lt;/span&gt; &lt;span&gt;LEVEL&lt;/span&gt; &lt;span&gt;REPEATABLE&lt;/span&gt; &lt;span&gt;READ&lt;/span&gt;         &lt;span&gt;--&lt;/span&gt;&lt;span&gt; 设置事务隔离级别 &lt;/span&gt;

&lt;span&gt;BEGIN&lt;/span&gt; &lt;span&gt;TRAN&lt;/span&gt;&lt;span&gt; TG

     &lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;FROM&lt;/span&gt; TestTransTable4 &lt;span&gt;WHERE&lt;/span&gt; price &lt;span&gt;&amp;lt;=&lt;/span&gt; &lt;span&gt;1200&lt;/span&gt;;    &lt;span&gt;--&lt;/span&gt;&lt;span&gt; 第一次读&lt;/span&gt;

     &lt;span&gt;WAITFOR&lt;/span&gt; DELAY &lt;span&gt;'&lt;/span&gt;&lt;span&gt;00:00:10&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;                      &lt;span&gt;--&lt;/span&gt;&lt;span&gt; 事务等待10秒&lt;/span&gt;

     &lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;FROM&lt;/span&gt; TestTransTable4 &lt;span&gt;WHERE&lt;/span&gt; price &lt;span&gt;&amp;lt;=&lt;/span&gt; &lt;span&gt;1200&lt;/span&gt;;   &lt;span&gt;--&lt;/span&gt;&lt;span&gt; 第二次读&lt;/span&gt;

&lt;span&gt;COMMIT&lt;/span&gt; &lt;span&gt;TRAN&lt;/span&gt; TG &lt;span&gt;--&lt;/span&gt;&lt;span&gt; 提交事务&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;Ø 构造另一事务TH：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;--&lt;/span&gt;&lt;span&gt; 事务TH的代码&lt;/span&gt;

&lt;span&gt;SET&lt;/span&gt; &lt;span&gt;TRANSACTION&lt;/span&gt; &lt;span&gt;ISOLATION&lt;/span&gt; &lt;span&gt;LEVEL&lt;/span&gt; &lt;span&gt;REPEATABLE&lt;/span&gt; &lt;span&gt;READ&lt;/span&gt;; &lt;span&gt;--&lt;/span&gt;&lt;span&gt; 设置事务隔离级别&lt;/span&gt;

&lt;span&gt;BEGIN&lt;/span&gt; &lt;span&gt;TRAN&lt;/span&gt;&lt;span&gt; TH

     &lt;/span&gt;&lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; TestTransTable4 &lt;span&gt;VALUES&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;A333&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;1000&lt;/span&gt;,&lt;span&gt;20&lt;/span&gt;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;COMMIT&lt;/span&gt; &lt;span&gt;TRAN&lt;/span&gt; TH
&lt;/pre&gt;&lt;/div&gt;



&lt;p&gt;Ø  分别在两个查询窗口中先后运行事务TG和事务TH（时间间隔要小于10秒，且先恢复表TestTransTable4中的数据），事务TG中的两条SELECT语句输出的结果分别如图10.15和图10.16所示：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1427277/201906/1427277-20190622233257201-425484714.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;






&lt;p&gt;Ø  在事务TG中完全相同的两个查询语句在两次执行后得到的结果不一样，其中在第二次查询结果中“幻影”般地增加了一个票价为1000元的航班信息。可见，REPEATABLE READ隔离级别虽然比前二者均高，但还是不能防止“幻影”读。&lt;/p&gt;

&lt;p&gt;Ø  如果将事务隔离级别由原来的REPEATABLE READ改为SERIALIZABLE（其他代码不变），按照上述同样方法执行这两个事务后，事务TG中的两次查询得到的结果均如图10.15所示。这表明“幻影”读已经不复存在了，隔离级别SERIALIZABLE可以防止上述的“幻影”读。如果这时进一步查询表TestTransTable4中的数据，可以看到其结果与图10.16所示的结果一样。这是因为，在SERIALIZABLE隔离级别下，事务TG执行完了以后再执行事务TH，即串行事务TG和TH，因此事务TH中的语句不会影响到事务TG，从而避免“幻影”读。&lt;/p&gt;
&lt;p&gt;Ø  需要说明的是，REPEATABLE READ和SERIALIZABLE隔离级别对系统性能的影响都很大，特别是SERIALIZABLE隔离级别，不是非不得以，最好不要使用。&lt;/p&gt;
&lt;p&gt;Ø   根据以上分析，四种隔离级对事务“读”和“写”操作的处理关系说明如表10.1所示。&lt;/p&gt;


&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1427277/201906/1427277-20190622233317451-19283849.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;表10.1中，“读”、“写”、“插”和“删”分别指SELECT、UPDATE、INSERT和DELETE操作。&lt;br/&gt;“读了,可再读”表述的意思是，执行了SELECT后，在事务还没有提交或回滚之前，还可以继续执行SELECT；&lt;br/&gt;“读了,不可再写”是指，执行了SELECT后，在事务还没有提交或回滚之前，是不允许执行UPDATE操作的。其他项的意思可以照此类推。&lt;/p&gt;

&lt;p&gt;Ø  根据表10.1，我们可进一步总结四种隔离级别对支持解决并发问题的情况，结果如表10.2所示。&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1427277/201906/1427277-20190622233526328-1478629616.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;                 注：√表示“防止”，×表示“不一定防止”      &lt;/p&gt;
&lt;p&gt;严格说，REPEATABLE READ和SERIALIZABLE是不支持解决丢失修改问题的，因为它们用于此类问题时，容易造成死锁。&lt;/p&gt;
&lt;p&gt;  &lt;span&gt;【例子】对于例10.6中的事务TA和TB，如果将其中的UNCOMMITTED替换成REPEATABLE READ或SERIALIZABLE，然后按照例10.6中的方法执行这两个事务，结果虽然没有造成数据的不一致，但出现了死锁（死锁最后是由SQL Server自动终止一个事务来解除）。隔离级别的方法并不能完全解决涉及的并发问题。&lt;/span&gt;&lt;/p&gt;



&lt;h3&gt;10.3.4 基于锁的并发控制&lt;/h3&gt;
&lt;p&gt;Ø 锁定是指对数据块的锁定，是SQL Server数据库引擎用来同步多个用户同时对同一个数据块进行访问的一种控制机制。这种机制的实现是利用锁（LOCK）来完成的。一个用户（事务）可以申请对一个资源加锁，如果申请成功的话，则在该事务访问此资源的时候其他用户对此资源的访问受到诸多的限制，以保证数据的完整性和一致性。&lt;/p&gt;
&lt;p&gt;Ø SQL Server提供了多种不同类型的锁。有的锁类型是兼容的，有的是不兼容的。不同类型的锁决定了事务对数据块的访问模式。SQL Serve常用的锁类型主要包括：&lt;/p&gt;
&lt;p&gt;（1）共享锁（S）：允许多个事务并发读取同一数据块，但不允许其他事务修改当前事务加锁的数据块。一个事务对一个数据块加上一个共享锁后，其他事务也可以继续对该数据块加上共享锁。这就是说，当一个数据块被多个事务同时加上共享锁的时候，所有的事务都不能对这个数据块进行修改，直到数据读取完成，共享锁释放。&lt;/p&gt;


&lt;p&gt;（2）排它锁（X）：也称独占锁、写锁，当一个事务对一个数据块加上排它锁后，它可以对该数据块进行UPDATE、DELETE、INSERT等操作，而其他事务不能对该数据块加上任何锁，因而也不能执行任何的更新操作（包括UPDATE、DELETE和INSERT）。一般用于对数据块进行更新操作时的并发控制，它可以保证同一数据块不会被多个事务同时进行更新操作，避免由此引发的数据不一致。&lt;/p&gt;
&lt;p&gt;（3）更新锁：更新锁介于共享锁和排它锁之间，主要用于数据更新，可以较好地防止死锁。一个数据块的更新锁一次只能分配给一个事务，在读数据的时候该更新锁是共享锁，一旦更新数据时它就变成排他锁，更新完后又变为共享锁。但在变换过程中，可能出现锁等待等问题，且变换本身也需要时间，因此使用这种锁时，效率并不十分理想。&lt;/p&gt;


&lt;p&gt;（4）意向锁：表示SQL Server需要在层次结构中的某些底层资源上（如行，列）获取共享锁、排它锁或更新锁。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     【例子】表级放置了意向共享锁，就表示事务要对表的页或行上使用共享锁；在表的某一行上上放置意向锁，可以防止其它事务获取其它不兼容的锁。意向锁的优点是可以提高性能，因为数据引擎不需要检测资源的每一列每一行，就能判断是否可以获取到该资源的兼容锁。它包括三种类型：意向共享锁，意向排他锁，意向排他共享锁。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（5）架构锁：架构锁用于在修改表结构时，阻止其他事务对表的并发访问。&lt;/p&gt;
&lt;p&gt;（6）键范围锁：用于锁定表中记录之间的范围的锁，以防止记录集中的“幻影”插入或删除，确保事务的串行执行。&lt;/p&gt;
&lt;p&gt;（7）大容量更新锁：允许多个进程将大容量数据并发的复制到同一个表中，在复制加载的同时，不允许其它非复制进程访问该表。&lt;/p&gt;



&lt;p&gt;     在这些锁当中，共享锁（S锁）和排他锁（X锁）尤为重要，它们之间的相容关系描述如下：&lt;/p&gt;
&lt;p&gt;Ø 如果事务T对数据块D成功加上共享锁，则其他事务只能对D再加共享锁，不能加排他锁，且此时事务T只能读数据块D，不能修改它（除非其他事务没有对该数据块加共享锁）。&lt;/p&gt;
&lt;p&gt;Ø 如果事务T对数据块D成功加上排他锁，则其他事务不能再对D加上任何类型的锁，也对D进行读操作和写操作，而此时事务T既能读数据块D，也又能修改该数据块。&lt;/p&gt;

&lt;p&gt;Ø  下面主要是结合SQL Server提供的表提示（table_hint），介绍共享锁和排他锁在并发控制中的使用方法。加锁情况的动态信息可以通过查询系统表sys.dm_tran_locks获得。&lt;/p&gt;
&lt;p&gt;Ø  通过在SELECT、INSERT、UPDATE及DELETE语句中为单个表引用指定表提示，可以实现对数据块的加锁功能，实现事务对数据访问的并发控制。&lt;/p&gt;
&lt;p&gt;Ø  为数据表指定表提示的简化语法如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
{&lt;span&gt;SELECT&lt;/span&gt; … &lt;span&gt;|&lt;/span&gt; &lt;span&gt;INSERT&lt;/span&gt; … &lt;span&gt;|&lt;/span&gt; &lt;span&gt;UPDATE&lt;/span&gt; … &lt;span&gt;|&lt;/span&gt; DELECT … &lt;span&gt;|&lt;/span&gt; MERGE …} &lt;span&gt;[&lt;/span&gt;&lt;span&gt; WITH ( &amp;lt;table_hint&amp;gt; ) &lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;table_hint&lt;span&gt;&amp;gt;&lt;/span&gt; ::&lt;span&gt;=&lt;/span&gt;
&lt;span&gt;[&lt;/span&gt;&lt;span&gt; NOEXPAND &lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;INDEX&lt;/span&gt; ( index_value &lt;span&gt;[&lt;/span&gt;&lt;span&gt; ,...n &lt;/span&gt;&lt;span&gt;]&lt;/span&gt; ) &lt;span&gt;|&lt;/span&gt; &lt;span&gt;INDEX&lt;/span&gt; &lt;span&gt;=&lt;/span&gt;&lt;span&gt; ( index_value )
  &lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;span&gt; FASTFIRSTROW
  &lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;span&gt; FORCESEEK
  &lt;/span&gt;&lt;span&gt;|&lt;/span&gt; &lt;span&gt;HOLDLOCK&lt;/span&gt;
  &lt;span&gt;|&lt;/span&gt;&lt;span&gt; NOLOCK
  &lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;span&gt; NOWAIT
  &lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;span&gt; PAGLOCK
  &lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;span&gt; READCOMMITTED
  &lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;span&gt; READCOMMITTEDLOCK 
  &lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;span&gt; READPAST 
  &lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;span&gt; READUNCOMMITTED 
  &lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;span&gt; REPEATABLEREAD 
  &lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;span&gt; ROWLOCK 
  &lt;/span&gt;&lt;span&gt;|&lt;/span&gt; &lt;span&gt;SERIALIZABLE&lt;/span&gt; 
  &lt;span&gt;|&lt;/span&gt;&lt;span&gt; TABLOCK 
  &lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;span&gt; TABLOCKX 
  &lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;span&gt; UPDLOCK 
  &lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;span&gt; XLOCK 
} &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;




&lt;p&gt;u 表提示语法中有很多选项，下面主要介绍与表级锁有密切相关的几个选项：&lt;/p&gt;
&lt;p&gt;Ø HOLDLOCK &lt;/p&gt;
&lt;p&gt;   表示使用共享锁，使用共享锁更具有限制性，保持共享锁直到事务完成。而不是无论事务是否完成，都在不再需要所需表或数据页时立即释放共享锁。HOLDLOCK不能被用于包含FOR BROWSE选项的SELECT语句。它同等于SERIALIZABLE隔离级别。&lt;/p&gt;
&lt;p&gt;Ø NOLOCK&lt;/p&gt;
&lt;p&gt; 表示不发布共享锁来阻止其他事务修改当前事务在读的数据，允许读“脏”数据。它同等于等同于READ UNCOMMITTED隔离级别。&lt;/p&gt;
&lt;p&gt;Ø PAGLOCK&lt;/p&gt;
&lt;p&gt;表示使用页锁，通常使用在行或键采用单个锁的地方，或者采用单个表锁的地方。&lt;/p&gt;
&lt;p&gt;Ø READPAST&lt;/p&gt;
&lt;p&gt;    指定数据库引擎跳过（不读取）由其他事务锁定的行。在大多数情况下，这同样适用于页。数据库引擎跳过这些行或页，而不是在释放锁之前阻塞当前事务。它仅适用于READ COMMITTED或REPEATABLE READ隔离级别的事务中。&lt;/p&gt;


&lt;p&gt;Ø  ROWLOCK&lt;/p&gt;
&lt;p&gt;     表示使用行锁，通常在采用页锁或表锁时使用。&lt;/p&gt;
&lt;p&gt;Ø  TABLOCK&lt;/p&gt;
&lt;p&gt;     指定对表采用共享锁并让其一直持有，直至语句结束。如果同时指定了HOLDLOCK，则会一直持有共享表锁，直至事务结束。&lt;/p&gt;
&lt;p&gt;Ø  TABLOCKX&lt;/p&gt;
&lt;p&gt;    指定对表采用排他锁（独占表级锁）。如果同时指定了HOLDLOCK，则会一直持有该锁，直至事务完成。在整个事务期间，其他事务不能访问该数据表。&lt;/p&gt;
&lt;p&gt;Ø  UPDLOCK&lt;/p&gt;
&lt;p&gt;   指定要使用更新锁（而不是共享锁），并保持到事务完成。&lt;/p&gt;

&lt;p&gt;     注意：如果设置了事务隔离级别，同时指定了锁提示，则锁提示将覆盖会话的当前事务隔离级别。&lt;/p&gt;


&lt;p&gt;&lt;span&gt;【例10.10】使用表级共享锁。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Ø 对于数据表TestTransTable4，事务T1对其加上表级共享锁，使得在事务期内其他事务不能更新此数据表。事务T1的代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;BEGIN TRAN T1&lt;/p&gt;
&lt;p&gt;     DECLARE @s varchar(10);&lt;/p&gt;
&lt;p&gt;     -- 下面一条语句的唯一作用是对表加共享锁&lt;/p&gt;
&lt;p&gt;    SELECT @s = flight FROM TestTransTable4 WITH(HOLDLOCK,TABLOCK) WHERE 1=2;&lt;/p&gt;
&lt;p&gt;    PRINT '加锁时间：'+CONVERT(varchar(30), GETDATE(), 20);&lt;/p&gt;
&lt;p&gt;   WAITFOR DELAY '00:00:10'               -- 事务等待10秒&lt;/p&gt;
&lt;p&gt;   PRINT '解锁时间：'+CONVERT(varchar(30), GETDATE(), 20);&lt;/p&gt;
&lt;p&gt;COMMIT TRAN T1&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Ø 为观察共享锁的效果，进一步定义事务T2：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;BEGIN TRAN T2&lt;/p&gt;
&lt;p&gt;     UPDATE TestTransTable4 SET price = price*0.65 WHERE flight = 'A111’;&lt;/p&gt;
&lt;p&gt;    PRINT '数据更新时间：'+CONVERT(varchar(30), GETDATE(), 20); &lt;/p&gt;
&lt;p&gt;COMMIT TRAN T2&lt;/p&gt;



&lt;p&gt;Ø  然后分别在两个查询窗口中先后运行事务T1和事务T2（时间间隔要小于10秒），事务T1和T2输出的结果分别如图10.17和图10.18所示。&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1427277/201906/1427277-20190622233924457-1516389070.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;







&lt;p&gt;Ø  对比图10.17和图10.18，事务T1对表TestTransTable4的更新操作（包括删除和添加）必须等到事务T2解除共享锁以后才能进行（但在事务T1期内，事务T2可以使用SELECT语句查询表TestTransTable4）。&lt;/p&gt;

&lt;p&gt;Ø  使用HOLDLOCK和TABLOCK可以避免在事务期内被锁定对象受到更新（包括删除和添加），因而可以避免“幻影”读；但由于T1在进行UPDATE操作后，T2能够继续SELECT数据，因此这种控制策略不能防止读“脏”数据；共享锁也不能防止丢失修改。&lt;/p&gt;
&lt;p&gt;Ø  如果同时在T1和T2中添加读操作和写操作，则容易造成死锁。&lt;/p&gt;
&lt;p&gt;      &lt;span&gt;【例子】如果在例10.6的两个事务TA和TB中改用共享锁进行并发控制，同样会出现死锁的现象。但更新锁能够自动实现在共享锁和排他锁之间的切换，完成对数据的读取和更新，且在防止死锁方面有优势。如果在例10.6的两个事务TA和TB中改用更新锁，结果是可以对这两个事务成功进行并发控制的。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;【例10.11】利用更新锁解决丢失修改问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       对于例10.6的两个事务TA和TB，用事务隔离级别的方法难以解决丢失修改问题，但用更新锁则可以较好地解决这个问题。更新锁是用UPDLOCK选项来定义，修改后事务TA和TB的代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;--&lt;/span&gt;&lt;span&gt; 事务TA的代码&lt;/span&gt;

&lt;span&gt;BEGIN&lt;/span&gt; &lt;span&gt;TRAN&lt;/span&gt;&lt;span&gt; TA 

&lt;/span&gt;&lt;span&gt;DECLARE&lt;/span&gt; &lt;span&gt;@n&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;; 

&lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;@n&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;number&lt;/span&gt; &lt;span&gt;FROM&lt;/span&gt; TestTransTable4 &lt;span&gt;WITH&lt;/span&gt;(UPDLOCK,TABLOCK) &lt;span&gt;WHERE&lt;/span&gt; flight &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;A111&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;WAITFOR&lt;/span&gt; DELAY &lt;span&gt;'&lt;/span&gt;&lt;span&gt;00:00:10&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;         &lt;span&gt;--&lt;/span&gt;&lt;span&gt; 等待10秒，以让事务TB读数据&lt;/span&gt;

&lt;span&gt;SET&lt;/span&gt; &lt;span&gt;@n&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;@n&lt;/span&gt; &lt;span&gt;-&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;UPDATE&lt;/span&gt; TestTransTable4 &lt;span&gt;SET&lt;/span&gt; &lt;span&gt;number&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;@n&lt;/span&gt; &lt;span&gt;WHERE&lt;/span&gt; flight &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;A111&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;COMMIT&lt;/span&gt; &lt;span&gt;TRAN&lt;/span&gt;&lt;span&gt;   TA

 

&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt; 事务TB的代码&lt;/span&gt;

&lt;span&gt;BEGIN&lt;/span&gt; &lt;span&gt;TRAN&lt;/span&gt;&lt;span&gt; TB

&lt;/span&gt;&lt;span&gt;DECLARE&lt;/span&gt; &lt;span&gt;@n&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;@n&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;number&lt;/span&gt; &lt;span&gt;FROM&lt;/span&gt; TestTransTable4 &lt;span&gt;WITH&lt;/span&gt;(UPDLOCK,TABLOCK) &lt;span&gt;WHERE&lt;/span&gt; flight &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;A111&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;WAITFOR&lt;/span&gt; DELAY &lt;span&gt;'&lt;/span&gt;&lt;span&gt;00:00:15&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;           

&lt;span&gt;SET&lt;/span&gt; &lt;span&gt;@n&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;@n&lt;/span&gt; &lt;span&gt;-&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;UPDATE&lt;/span&gt; TestTransTable4 &lt;span&gt;SET&lt;/span&gt; &lt;span&gt;number&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;@n&lt;/span&gt; &lt;span&gt;WHERE&lt;/span&gt; flight &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;A111&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;COMMIT&lt;/span&gt; &lt;span&gt;TRAN&lt;/span&gt;&lt;span&gt;  TB

 &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  【例10.12】   利用排他锁来实现事务执行的串行化。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        下面代码是为表TestTransTable4加上表级排他锁（TABLOCKX），并将其作用范围设置为整个事务期：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;BEGIN&lt;/span&gt; &lt;span&gt;TRAN&lt;/span&gt;&lt;span&gt; T3

     &lt;/span&gt;&lt;span&gt;DECLARE&lt;/span&gt; &lt;span&gt;@s&lt;/span&gt; &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;10&lt;/span&gt;&lt;span&gt;);

     &lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt; 下面一条语句的唯一作用是对表加排他锁&lt;/span&gt;

     &lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;@s&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; flight &lt;span&gt;FROM&lt;/span&gt; TestTransTable4 &lt;span&gt;WITH&lt;/span&gt;(&lt;span&gt;HOLDLOCK&lt;/span&gt;,TABLOCKX) &lt;span&gt;WHERE&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;;

     &lt;/span&gt;&lt;span&gt;PRINT&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;加锁时间：&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;CONVERT&lt;/span&gt;(&lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;30&lt;/span&gt;), &lt;span&gt;GETDATE&lt;/span&gt;(), &lt;span&gt;20&lt;/span&gt;&lt;span&gt;);

     &lt;/span&gt;&lt;span&gt;WAITFOR&lt;/span&gt; DELAY &lt;span&gt;'&lt;/span&gt;&lt;span&gt;00:00:10&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;            &lt;span&gt;--&lt;/span&gt;&lt;span&gt; 事务等待10秒   &lt;/span&gt;

     &lt;span&gt;PRINT&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;解锁时间：&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;CONVERT&lt;/span&gt;(&lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;30&lt;/span&gt;), &lt;span&gt;GETDATE&lt;/span&gt;(), &lt;span&gt;20&lt;/span&gt;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;COMMIT&lt;/span&gt; &lt;span&gt;TRAN&lt;/span&gt;&lt;span&gt; T3

进一步定义事务T4：

&lt;/span&gt;&lt;span&gt;BEGIN&lt;/span&gt; &lt;span&gt;TRAN&lt;/span&gt;&lt;span&gt; T4

      &lt;/span&gt;&lt;span&gt;DECLARE&lt;/span&gt; &lt;span&gt;@s&lt;/span&gt; &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;10&lt;/span&gt;&lt;span&gt;);

     &lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;@s&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; flight &lt;span&gt;FROM&lt;/span&gt;&lt;span&gt; TestTransTable4;

     &lt;/span&gt;&lt;span&gt;PRINT&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;数据查询时间：&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;CONVERT&lt;/span&gt;(&lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;30&lt;/span&gt;), &lt;span&gt;GETDATE&lt;/span&gt;(), &lt;span&gt;20&lt;/span&gt;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;COMMIT&lt;/span&gt; &lt;span&gt;TRAN&lt;/span&gt; T4
&lt;/pre&gt;&lt;/div&gt;




&lt;p&gt;&lt;span&gt;Ø  与例13.10类似，分别在两个查询窗口中先后运行事务T3和事务T4（时间间隔要小于10秒），事务T3和T4输出的结果分别如图10.19和图10.20所示。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1427277/201906/1427277-20190622234104902-1574053475.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Ø  事务T3通过利用TABLOCKX选项对表TestTransTable4加上排他锁以后，事务T4对该表的查询操作只能在事务T3结束之后才能进行，其他更新操作（如INSERT、UPDATE、DELETE）更是如此。因此，利用排他锁可以实现事务执行的串行化控制。&lt;/p&gt;

</description>
<pubDate>Sat, 22 Jun 2019 15:42:00 +0000</pubDate>
<dc:creator>Zander_Zhao</dc:creator>
<og:description>第10章事务管理与并发控制 • 10.1 事务的基本概念 10.1.1 事务 Ø 事务(Transaction)是构成单一逻辑工作单元的数据库操作序列。这些操作是一个统一的整体，要么全部成功</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ZanderZhao/p/11062400.html</dc:identifier>
</item>
<item>
<title>spring cloud之RabbitMQ简单介绍 - liYanLong</title>
<link>http://www.cnblogs.com/li-yan-long/p/11070945.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/li-yan-long/p/11070945.html</guid>
<description>[unable to retrieve full-text content]RabbitMQ：是spring cloud支持的一种消息中间件，消息中间件有很多，主要所用就是：解耦服务之间的消息关系，将同步变异步，流量削锋。 解耦服务之间的消息关系：例如：发邮件，在一个商城服务中购买商品后需要发送邮件给购买者，则需要请求邮件服务，此时是商城服务直接请求邮件服务，而有了MQ后，</description>
<pubDate>Sat, 22 Jun 2019 15:37:00 +0000</pubDate>
<dc:creator>liYanLong</dc:creator>
<og:description>第10章事务管理与并发控制 • 10.1 事务的基本概念 10.1.1 事务 Ø 事务(Transaction)是构成单一逻辑工作单元的数据库操作序列。这些操作是一个统一的整体，要么全部成功</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ZanderZhao/p/11062400.html</dc:identifier>
</item>
<item>
<title>《编译原理》LR 分析法与构造 LR(1) 分析表的步骤 - 例题解析 - 肖朋伟</title>
<link>http://www.cnblogs.com/xpwi/p/11070888.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xpwi/p/11070888.html</guid>
<description>&lt;h3 id=&quot;编译原理lr-分析法与构造-lr1-分析表的步骤---例题解析&quot;&gt;《编译原理》LR 分析法与构造 LR(1) 分析表的步骤 - 例题解析&lt;/h3&gt;
&lt;p&gt;笔记&lt;/p&gt;
&lt;p&gt;直接做题是有一些特定步骤，有技巧。但也必须先了解一些基本概念，本篇会通过例题形式解释概念，会容易理解和记忆，以及解决类似问题。&lt;/p&gt;
&lt;p&gt;如果只想做题可以直接下拉至习题部分。&lt;/p&gt;
&lt;h4 id=&quot;一关于状态&quot;&gt;（一）关于状态&lt;/h4&gt;
&lt;p&gt;对于产生式 A→aBcD，就可以分解为下面几个不同的识别状态：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;（1）A→.aBcD&lt;br/&gt;（2）A→a.BcD&lt;br/&gt;（3）A→aB.cD&lt;br/&gt;（4）A→aBc.D&lt;br/&gt;（5）A→aBcD.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;“.” 的左部符号表示已被识别出来的那部分句柄符号&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;状态（1）表示：处于句柄的头&lt;br/&gt;状态（2）表示：已经识别出字符 a，&lt;strong&gt;等待&lt;/strong&gt; 形成以 B 为产生式左部的右部&lt;br/&gt;状态（3）表示：刚刚进行了一次规约，即把关于 B 的产生式右部规约成 B&lt;br/&gt;状态（4）表示：已经识别出字符 c，&lt;strong&gt;等待&lt;/strong&gt; 形成以 D 为产生式左部的右部&lt;br/&gt;状态（5）表示：已经到达句柄的尾巴，可以把 aBcD 规约为产生式左部的符号 A&lt;/p&gt;
&lt;h4 id=&quot;二什么是-lrk-分析法&quot;&gt;（二）什么是 LR(k) 分析法？&lt;/h4&gt;
&lt;p&gt;字面意思理解：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;L&lt;/td&gt;
&lt;td&gt;表示 &lt;strong&gt;从左到右&lt;/strong&gt; 扫描输入串&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;R&lt;/td&gt;
&lt;td&gt;表示利用 &lt;strong&gt;最右分析方法&lt;/strong&gt; 来识别句子，即构造一个 &lt;strong&gt;最右推导的逆过程&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;k&lt;/td&gt;
&lt;td&gt;表示向右查看输入串符号的个数&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;LR 分析过程是规范归约的过程&lt;/p&gt;
&lt;p&gt;规范规约是最右推导的逆过程，最右推导是规范推导，所以 &lt;strong&gt;最左规约是规范规约。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;LR 分析法根据当前分析栈中的符号串和向右顺序查看输入串的 k 个符号就可以唯一确定分析器的动作是移进还是归约、利用那个产生式进行归约。&lt;/p&gt;
&lt;p&gt;当没有指明 k 是几的时候，默认为 1&lt;/p&gt;
&lt;h4 id=&quot;三文法的拓广&quot;&gt;（三）文法的拓广？&lt;/h4&gt;
&lt;p&gt;文法的拓广是对现有文法，添加一个 S'，并对文法进行展开。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;例如：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;对于文法 G[E]:&lt;br/&gt;E → E+T|T&lt;br/&gt;T → T*F|F&lt;br/&gt;F → i|(E)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以把它拓广为&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;文法 G[E']:&lt;br/&gt;E' → E&lt;br/&gt;E → E+T|T&lt;br/&gt;T → T*F|F&lt;br/&gt;F → i|(E)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;此时可能会有疑问，不就是加了个开始符号，有什么意义呢？为什么要再加个开始符号呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;加开始符号是为了状态的表示，这样原来的 S 会成为右部，可以表示 .S 和 S.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;那同一非终结符的右部有多种情况为什么不展开呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里是说拓广文法，是添加开始符号，可以展开可以不展开，但是一般默认要展开，一般一道题不会只让求拓广文法，而是为了后面。一般题目中是说 “&lt;strong&gt;求该文法的拓广文法并编号&lt;/strong&gt;”，此时请一定要展开。展开后应该是这样：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;1.E'→E&lt;br/&gt;2.E → E+T&lt;br/&gt;3.E → T&lt;br/&gt;4.T → T*F&lt;br/&gt;5.T → F&lt;br/&gt;6.F → i&lt;br/&gt;7.F → (E)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;四什么是项目项目有哪些分类等价状态&quot;&gt;（四）什么是项目？项目有哪些分类？等价状态？&lt;/h4&gt;
&lt;p&gt;上面提到拓广文法，展开，以及编号。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;先看例题：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;对于文法 G[S]:&lt;br/&gt;S → vI:T&lt;br/&gt;I → I,i&lt;br/&gt;I → i&lt;br/&gt;T → r&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;可以把它拓广并编号，如下：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;文法 G[S']:&lt;br/&gt;1.S' → S&lt;br/&gt;2.S → vI:T&lt;br/&gt;3.I → I,i&lt;br/&gt;4.I → i&lt;br/&gt;5.T → r&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;它的全部 LR(0) 项目，如下：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;1.S' → .S&lt;br/&gt;2.S' → S.&lt;br/&gt;3.S → .vI:T&lt;br/&gt;4.S → v.I:T&lt;br/&gt;5.S → vI.:T&lt;br/&gt;6.S → vI:.T&lt;br/&gt;7.S → vI:T.&lt;br/&gt;8.I → .I,i&lt;br/&gt;9.I → I.,i&lt;br/&gt;10.I → I,.i&lt;br/&gt;11.I → I,i.&lt;br/&gt;12.I → .i&lt;br/&gt;13.I → i.&lt;br/&gt;14.T → .r&lt;br/&gt;15.T → r.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;对上面 LR(0) 项目进行分类&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;规约项目&lt;/td&gt;
&lt;td&gt;2, 7, 11, 13, 15&lt;/td&gt;
&lt;td&gt;. 在右部的末尾&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;接收项目&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;. 在开始符号的末尾&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;移进项目&lt;/td&gt;
&lt;td&gt;3, 5, 9, 10, 12, 14&lt;/td&gt;
&lt;td&gt;. 后面跟着终结符，表移进&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;待约项目&lt;/td&gt;
&lt;td&gt;1, 4, 6, 8&lt;/td&gt;
&lt;td&gt;. 后面跟着非终结符，表等待后面非终结符的规约，简称待约&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;谁和谁是等价状态？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;例如：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;待约项目 4 即 S→v.I:T 它的含义是等待栈顶规约出 I，但尚未识别对应 I 的那些句柄的任何符号；&lt;/p&gt;
&lt;p&gt;项目 8 即 I→.I,i 和项目 12 即 I→.i 的含义也是期待栈顶形成 I 的句柄，所以这三个项目的含义是一样的，即 4, 8, 12 三个状态是等价的。&lt;/p&gt;
&lt;p&gt;同理：项目 6 即 S → vI:.T 和项目 14 即 T → .r 也是等价的&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为什么它们是等价状态？怎么判断等价状态？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;上面有说因为他们表示的含义是一样的，并且会发现等价肯定涉及至少一个待约项目，以及一个 . 在最左端的移进项目。&lt;/p&gt;
&lt;p&gt;这是因为，待约项目是 . 后面跟非终结符，这个 . 是在非终结符的前面；当存在该非终结符的产生式时，且 . 在最左端的时候。因为 . 在最左端，其实也是相当于在该非终结符的前面。所以是一个等价的状态。&lt;/p&gt;
&lt;h4 id=&quot;五lr-分析表介绍&quot;&gt;（五）LR 分析表介绍&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;LR 分析器的关键部分是 分析表的构造。分析表有以下几种：&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;规范的 LR 分析表：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;LR(0)，能力最弱，局限性较大，但理论上最重要。&lt;/li&gt;
&lt;li&gt;LR(1)，它功能最强，但代价也最大。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;简单的 LR 分析表：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;简称 SLR ，最容易实现，但功能最弱。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;向前看的 LR 分析表：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;简称 LALR，功能和代价处于前两者之间，适用于绝大多数程序语言的文法&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt; LR(0) 功能最弱，功能弱是说当文法中产生式比较复杂，出现某些问题时，无法解决。这些问题一部分可以由 SLR 分析法解决。但还有一部分 SLR 解决不了，可以用 LR(1) 来解决。&lt;/p&gt;
&lt;h4 id=&quot;六关于-展望&quot;&gt;（六）关于 “&lt;strong&gt;展望&lt;/strong&gt;”&lt;/h4&gt;
&lt;p&gt;在规范归约过程中，一方面记住已移进和归约出的整个符号串，即记住 “&lt;strong&gt;历史&lt;/strong&gt;”，另一方面根据所用的产生式推测未来可能碰到的输入符号，即对未来进行 “&lt;strong&gt;展望&lt;/strong&gt;”。&lt;/p&gt;
&lt;p&gt;当一串貌似句柄的符号串呈现于分析栈的顶端时，根据所记载的 “历史” 和 “展望” 材料，来确定栈顶的符号串是否构成句柄。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为了记住分析的 “历史” 和汇集 “展望” 的信息，LR 分析法这样处理：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;将归约过程的 “历史” 和 “展望” 材料综合抽象成某些状态，存放在一个状态栈中，栈中每个状态都概括了从分析开始直到某一归约阶段的全部“历史”和“展望”材料。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;LR(1) 分析法这样处理：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先，明白了在 LR(1) 分析法中展望是为了解决其他分析法解决不了的问题。简单的说就是，状态会出现冲突，我们不能只通过后 1 个输入串符号，直接确定选用哪个产生式，这是严重的错误。&lt;/p&gt;
&lt;p&gt;所以 &lt;strong&gt;展望&lt;/strong&gt; 是通过展望后面的内容，所以展望对应的终结符，应该 &lt;strong&gt;属于该非终结符的 FOLLOW 集（确切的说，属于 FOLLOW 集中的具体哪个个终结符，应该根据产生式的推导过程确定，通过语法树来分析，是最直观的方法）&lt;/strong&gt;，来帮助唯一确定选择产生式。&lt;/p&gt;
&lt;p&gt;在 LR(1) 中，用&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;状态, 终结符&lt;/strong&gt;&lt;br/&gt;例如：S' → # （#表示开始符号FOLLOW集会提到那个符号，有的地方用 $，是一样的 ）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这种形式是表式展望，终结符就是展望的后面的终结符，具体的下面例题中还会提到。&lt;/p&gt;
&lt;h4 id=&quot;七终极例题---lr1-分析表的构造&quot;&gt;（七）终极例题 - LR(1) 分析表的构造&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;给定文法 G[S]：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;S→L=R | R&lt;br/&gt;L→*R | id&lt;br/&gt;R→L&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;回答以下问题：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（1）文法的拓广并编号&lt;br/&gt;（2）LR(1) 项目集规范族所对应的识别活前缀的 DFA&lt;br/&gt;（3）构造 LR(1) 分析表&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解析：&lt;/strong&gt;&lt;/p&gt;
&lt;h5 id=&quot;文法的拓广并编号&quot;&gt;1）文法的拓广并编号：&lt;/h5&gt;
&lt;p&gt;拓广文法 G[S']：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;（0）S'→S&lt;br/&gt;（1）S→L=R&lt;br/&gt;（2）S→R&lt;br/&gt;（3）L→*R&lt;br/&gt;（4）L→id&lt;br/&gt;（5）R→L&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;lr1-项目集规范族所对应的识别活前缀的-dfa&quot;&gt;2）LR(1) 项目集规范族所对应的识别活前缀的 DFA*&lt;/h5&gt;
&lt;p&gt;这里就涉及到 “展望” 这个知识点了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1483449/201906/1483449-20190622232000888-1029096343.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（图片来源：中国大学慕课 -《编译原理》哈尔滨工业大学 陈老师）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;该 DFA 有穷自动机的解释：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（1）这样表示形式就是自动机，每个方框表示一个状态，从 I&lt;sub&gt;0&lt;/sub&gt; 到 I&lt;sub&gt;13&lt;/sub&gt; 所以共有 14 个状态。&lt;br/&gt;（2）每个状态中包含的多个项目，都是等价的。&lt;br/&gt;（3）每个项目中逗号后面的终结符或者 # 表示展望的终结符。&lt;br/&gt;（4）关于画出 DFA 的步骤：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;以 I&lt;sub&gt;0&lt;/sub&gt; 为例，首先对于 0 号产生式 S' → S，可知应该有 S' → .S 和 S' → S. 两个状态，因为 S' 是开始符号，展望是属于 FOLLOW 集的，展望应该是 #，可以得出 S' → .S, #&lt;/li&gt;
&lt;li&gt;因为 .S 表示等待规约出 S 的状态。并且 S→L=R，所以 .S 和 .L=R 是两个等价的状态。但需要注意的是此时的 FOLLOW 集应该 S 的 FOLLOW 集，而不是 L 的，也不 R 的&lt;/li&gt;
&lt;li&gt;同理，因为有 S→R，则 .S 和 .R 是两个等价的状态。&lt;/li&gt;
&lt;li&gt;有了 .R，应该继续去找 R 为左部的产生式，因为有 R→L，所以 .S 和 .L 是两个等价的状态。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;注意：&lt;/strong&gt; 在找 R 的展望终结符时，&lt;strong&gt;展望&lt;/strong&gt; 是通过展望后面的内容，所以展望对应的终结符，应该 &lt;strong&gt;属于该非终结符的 FOLLOW 集（确切的说，属于 FOLLOW 集中的具体哪个个终结符，应该根据产生式的推导过程确定，通过语法树来分析，是最直观的方法）&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1483449/201906/1483449-20190622232019993-506648610.jpg&quot;/&gt;&lt;br/&gt;（图片来源：中国大学慕课 -《编译原理》哈尔滨工业大学 陈老师）&lt;/p&gt;
&lt;p&gt;可以看出来 R 的展望应该有两种情况，一个是 =，一种是 #&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;但此时，我们通过 S → R 找到的 R，所以应该是 #&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;不断循环通过，将 . 后移，判断下一个状态，找出等价状态，直到判断完成。&lt;/p&gt;
&lt;h5 id=&quot;构造-lr1-分析表&quot;&gt;3）构造 LR(1) 分析表&lt;/h5&gt;
&lt;p&gt;根据自动机即可构造 LL(1) 分析表：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1483449/201906/1483449-20190622232030438-1347115743.png&quot;/&gt;&lt;br/&gt;（图片来源：中国大学慕课 -《编译原理》哈尔滨工业大学 陈老师）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LL(1) 分析表解释补充：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（1）内容 LL(1) 分析表 = 动作表 (ACTION) + 状态转移表(GOTO)&lt;/p&gt;
&lt;p&gt;（2）&lt;strong&gt;动作表&lt;/strong&gt; 中的每一个元素 ACTION[S,a] 规定了当 &lt;strong&gt;栈顶状态&lt;/strong&gt; 为 S，且面临输入符号 a 时应采取的动作。根据自动机中的终结符边可判断。&lt;/p&gt;
&lt;p&gt;（3）&lt;strong&gt;状态转换表&lt;/strong&gt; 中的每一个元素 GOTO[S,x] 规定了当状态 S 面对文法符号位 x 时的下一个状态。根据自动机中的非终结符边可判断。&lt;/p&gt;
&lt;p&gt;（4）&lt;strong&gt;动作表&lt;/strong&gt; 的列对应所有终结符加上 #&lt;/p&gt;
&lt;p&gt;（5）&lt;strong&gt;状态转换表&lt;/strong&gt; 的列对应所有非终结符，不包括 S'，因为 S 就是开始符号，S' 是为了使 “&lt;strong&gt;接收状态&lt;/strong&gt;” 易于识别，所引入的。&lt;/p&gt;
&lt;p&gt;（6）&lt;strong&gt;动作表&lt;/strong&gt; 中例如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ACTION[0, *] 的 &lt;strong&gt;S4 表示移进，入栈，就是当前状态为 0，当输入串为 &lt;em&gt;，则将状态 4 移进状态栈，将&lt;/em&gt; 移进文法符号栈&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;ACTION[5, =] 的 &lt;strong&gt;r4 表示符合产生式 4，将栈顶符号 id 规约为产生式左部&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;acc 表示接收&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;（7）&lt;strong&gt;状态转换表&lt;/strong&gt; 中例如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;GOTO[0, S] 的 &lt;strong&gt;数字为 1 表示转入 1 状态，置当前文法符号栈顶为 S，栈顶状态为 1&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;（8）&lt;strong&gt;构造 LL(1) 分析表的步骤，重要 ！！！：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;确定对应列&lt;/strong&gt; ，&lt;strong&gt;列是自动机中识别的边，加上某状态的展望终结符&lt;/strong&gt;，简单的说就是，在该状态时，判断下一个输入串，如果等于展望终结符，就用 Si。如果下一个输入串，如果不等于展望终结符，但是存在一条输出的边，指向另一个状态，就用 rj（j 是产生式的序号），如果不是展望，也不是输出的边，则报错，上表中表示为空白。
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;例如：&lt;/strong&gt; 上例题 2 状态，展望，加上输出的边共有两个符号 = 和 #，所以表中就有两个位置需要填。因为 = 是展望所以用 S6，因为 # 是输出的边用 r5&lt;/li&gt;
&lt;li&gt;上面也可以更深入理解展望的意义及含义，首先，&lt;strong&gt;展望是存在一个状态中的，所以如果就是某些 FOLLOW 集中展望终结符，对应的应该为是当前等价的状态，操作也就应该是移进。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;如果是输出的边，就是说不是当前状态了，所以对应的是规约。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;确定对应行&lt;/strong&gt; ，行就是所以状态&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;总结&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;易错点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;求 &lt;strong&gt;展望对应的终结符&lt;/strong&gt; 是通过展望后面的内容，所以展望对应的终结符，应该 &lt;strong&gt;属于该非终结符的 FOLLOW 集（确切的说，属于 FOLLOW 集中的具体哪个个终结符，应该根据产生式的推导过程确定，通过语法树来分析，是最直观的方法）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;各教材描述可能存在差异，但思想是相同的
&lt;ul&gt;&lt;li&gt;比如 $ 和 #&lt;/li&gt;
&lt;li&gt;比如展望终结的表示方法，有的分开写，有的直接用或&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Sat, 22 Jun 2019 15:21:00 +0000</pubDate>
<dc:creator>肖朋伟</dc:creator>
<og:description>《编译原理》LR 分析法与构造 LR(1) 分析表的步骤 例题解析 笔记 直接做题是有一些特定步骤，有技巧。但也必须先了解一些基本概念，本篇会通过例题形式解释概念，会容易理解和记忆，以及解决类似问题。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xpwi/p/11070888.html</dc:identifier>
</item>
<item>
<title>GMTC全球大前端技术大会干货分享 - 化身西湖云</title>
<link>http://www.cnblogs.com/yiyi17/p/11070872.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yiyi17/p/11070872.html</guid>
<description>&lt;h3 id=&quot;gmtc-2019%E5%8C%97%E4%BA%AC&quot; class=&quot;code-line code-line code-line&quot; data-line=&quot;0&quot;&gt;&lt;span&gt;&lt;a title=&quot;https://ppt.geekbang.org/list/gmtcbj2019?from=groupmessage&quot; href=&quot;https://ppt.geekbang.org/list/gmtcbj2019?from=groupmessage&quot;&gt;&lt;span&gt;GMTC-2019北京&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;code-line code-line code-line&quot; data-line=&quot;2&quot;&gt;GMTC这次的大会的热词肯定是监控、性能，当然跨平台依然是热点，&lt;code&gt;write once,run anywhere!&lt;/code&gt;,以下是自己参加的总结心得。&lt;/p&gt;
&lt;h2 id=&quot;620%E4%B8%8A%E5%8D%88&quot; class=&quot;code-line code-line code-line&quot; data-line=&quot;4&quot;&gt;6.20上午&lt;/h2&gt;
&lt;p class=&quot;code-line code-line code-line&quot; data-line=&quot;6&quot;&gt;前端的演化&lt;/p&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li class=&quot;code-line code-line code-line&quot; data-line=&quot;7&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;code-line code-line code-line&quot; data-line=&quot;7&quot;&gt;核心理念：结构+样式+表现分离 -2003&lt;/p&gt;
&lt;p class=&quot;code-line code-line code-line&quot; data-line=&quot;9&quot;&gt;前端岗位的出现&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;code-line code-line code-line&quot; data-line=&quot;11&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;code-line code-line code-line&quot; data-line=&quot;11&quot;&gt;核心理念90%优化在前端&lt;/p&gt;
&lt;p class=&quot;code-line code-line code-line&quot; data-line=&quot;13&quot;&gt;工程化的开始&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;code-line code-line code-line&quot; data-line=&quot;15&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;code-line code-line code-line&quot; data-line=&quot;15&quot;&gt;核心理念：前后端分离&lt;/p&gt;
&lt;p class=&quot;code-line code-line code-line&quot; data-line=&quot;17&quot;&gt;全栈的演进&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;code-line code-line code-line&quot; data-line=&quot;19&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;code-line code-line code-line&quot; data-line=&quot;19&quot;&gt;核心理念：mobile first&lt;/p&gt;
&lt;p class=&quot;code-line code-line code-line&quot; data-line=&quot;21&quot;&gt;无线时代来临&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;code-line code-line code-line&quot; data-line=&quot;23&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;code-line code-line code-line&quot; data-line=&quot;23&quot;&gt;核心理念：LOw/No Code&lt;/p&gt;
&lt;p class=&quot;code-line code-line code-line&quot; data-line=&quot;25&quot;&gt;中后台的重塑&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;code-line code-line code-line&quot; data-line=&quot;27&quot;&gt;
&lt;p class=&quot;code-line code-line code-line&quot; data-line=&quot;27&quot;&gt;未来？&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1094273/201906/1094273-20190622231648468-1857436646.png&quot; alt=&quot;&quot; width=&quot;568&quot; height=&quot;227&quot;/&gt;&lt;/p&gt;

&lt;p class=&quot;code-line code-line code-line&quot; data-line=&quot;31&quot;&gt;最大的感触是阿里的圆心讲的，国内前端的标准与世界的差距，前端世界权威组织机构是TC39、W3C和node基金会，国内对行业标准的贡献度有很大差距&lt;/p&gt;

&lt;h2 id=&quot;621%E4%B8%8B%E5%8D%88&quot; class=&quot;code-line code-line code-line&quot; data-line=&quot;33&quot;&gt;6.21下午&lt;/h2&gt;
&lt;h3 id=&quot;%E6%9E%81%E8%87%B4%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%8E%A2%E7%B4%A2-%E8%B4%9D%E5%A3%B3&quot; class=&quot;code-line code-line code-line&quot; data-line=&quot;35&quot;&gt;极致前端性能优化探索 贝壳&lt;/h3&gt;
&lt;p class=&quot;code-line code-line code-line&quot; data-line=&quot;37&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1094273/201906/1094273-20190622232035018-633604427.png&quot; alt=&quot;&quot; width=&quot;735&quot; height=&quot;380&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;code-line code-line code-line&quot; data-line=&quot;37&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1094273/201906/1094273-20190622232208956-1364613576.png&quot; alt=&quot;&quot; width=&quot;756&quot; height=&quot;302&quot;/&gt;&lt;/p&gt;

&lt;p class=&quot;code-line code-line code-line&quot; data-line=&quot;40&quot;&gt;项目自研做监控系统，时光机、日志分析平台&lt;/p&gt;
&lt;p class=&quot;code-line code-line code-line&quot; data-line=&quot;42&quot;&gt;对了还分享了下gizip的原理：LZ77算法、Huffman&lt;/p&gt;
&lt;ul&gt;&lt;li class=&quot;code-line code-line code-line&quot; data-line=&quot;43&quot;&gt;文本68%&lt;/li&gt;
&lt;li class=&quot;code-line code-line code-line&quot; data-line=&quot;44&quot;&gt;图片6.3%&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;%E5%AF%B9%E5%9B%BE%E7%89%87%E5%81%9A%E5%8E%8B%E7%BC%A9&quot; class=&quot;code-line code-line code-line&quot; data-line=&quot;46&quot;&gt;对图片做压缩&lt;/h4&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li class=&quot;code-line code-line code-line&quot; data-line=&quot;47&quot;&gt;
&lt;p class=&quot;code-line code-line code-line&quot; data-line=&quot;47&quot;&gt;消除替换图像&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;code-line code-line code-line&quot; data-line=&quot;48&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;code-line code-line code-line&quot; data-line=&quot;48&quot;&gt;矢量图、光栅图优化&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;code-line code-line code-line&quot; data-line=&quot;49&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;code-line code-line code-line&quot; data-line=&quot;49&quot;&gt;有损压缩与无损压缩&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;code-line code-line code-line&quot; data-line=&quot;50&quot;&gt;
&lt;p class=&quot;code-line code-line code-line&quot; data-line=&quot;50&quot;&gt;图片转行样式表&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;code-line code-line code-line&quot; data-line=&quot;51&quot;&gt;
&lt;p class=&quot;code-line code-line code-line&quot; data-line=&quot;51&quot;&gt;抽离像素通道&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;code-line code-line code-line&quot; data-line=&quot;52&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;code-line code-line code-line&quot; data-line=&quot;52&quot;&gt;手动刷新运营商缓存，强制缓存图片&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;code-line code-line code-line&quot; data-line=&quot;53&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;code-line code-line code-line&quot; data-line=&quot;53&quot;&gt;投放广告，携带图片缓存到本地&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;622&quot; class=&quot;code-line code-line code-line code-line&quot; data-line=&quot;64&quot;&gt;6.22&lt;/h2&gt;
&lt;h3 id=&quot;b%E7%AB%99%E7%9A%84%E8%A7%86%E9%A2%91%E4%BD%93%E9%AA%8C%E8%BF%9B%E5%8C%96%E4%B9%8B%E8%B7%AF-bilibili&quot; class=&quot;code-line code-line code-line code-line&quot; data-line=&quot;65&quot;&gt;B站的视频体验进化之路 bilibili&lt;/h3&gt;
&lt;ul&gt;&lt;li class=&quot;code-line code-line code-line code-line&quot; data-line=&quot;67&quot;&gt;关键资源优先加载&lt;/li&gt;
&lt;li class=&quot;code-line code-line code-line code-line&quot; data-line=&quot;68&quot;&gt;bundle缩小&lt;/li&gt;
&lt;li class=&quot;code-line code-line code-line code-line&quot; data-line=&quot;69&quot;&gt;SSR+SPA&lt;/li&gt;
&lt;li class=&quot;code-line code-line code-line code-line&quot; data-line=&quot;70&quot;&gt;弹幕：mask-image&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;03%E7%A7%92%E5%AE%8C%E6%88%90%E6%B8%B2%E6%9F%93%E4%BF%A1%E6%81%AF%E6%B5%81%E5%86%85%E5%AE%B9%E9%A1%B5%E9%97%AA%E5%BC%80%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93%E5%92%8C%E6%80%9D%E8%80%83-%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4&quot; class=&quot;code-line code-line code-line code-line&quot; data-line=&quot;72&quot;&gt;0.3秒完成渲染！信息流内容页“闪开”优化总结和思考 阿里巴巴&lt;/h3&gt;
&lt;p class=&quot;code-line code-line code-line code-line&quot; data-line=&quot;74&quot;&gt;直出无白屏，动画流畅不卡顿&lt;/p&gt;
&lt;ul&gt;&lt;li class=&quot;code-line code-line code-line code-line&quot; data-line=&quot;76&quot;&gt;CSR&lt;/li&gt;
&lt;li class=&quot;code-line code-line code-line code-line&quot; data-line=&quot;77&quot;&gt;SSR&lt;/li&gt;
&lt;li class=&quot;code-line code-line code-line code-line&quot; data-line=&quot;78&quot;&gt;NSR&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;code-line code-line code-line code-line&quot; data-line=&quot;80&quot;&gt;data、image的prefetch，这是基本操作&lt;/p&gt;
&lt;p class=&quot;code-line code-line code-line code-line&quot; data-line=&quot;82&quot;&gt;优化方案：&lt;/p&gt;
&lt;p class=&quot;code-line code-line code-line code-line&quot; data-line=&quot;86&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;code-line code-line code-line code-line&quot; data-line=&quot;86&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1094273/201906/1094273-20190622232457607-1408841513.png&quot; alt=&quot;&quot; width=&quot;671&quot; height=&quot;305&quot;/&gt;&lt;/p&gt;

&lt;p class=&quot;code-line code-line code-line code-line&quot; data-line=&quot;94&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1094273/201906/1094273-20190622232702859-1986340291.png&quot; alt=&quot;&quot; width=&quot;568&quot; height=&quot;258&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;code-line code-line code-line code-line&quot; data-line=&quot;96&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1094273/201906/1094273-20190622232811700-2073726421.png&quot; alt=&quot;&quot; width=&quot;568&quot; height=&quot;258&quot;/&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li class=&quot;code-line code-line code-line code-line&quot; data-line=&quot;98&quot;&gt;
&lt;p class=&quot;code-line code-line code-line code-line&quot; data-line=&quot;98&quot;&gt;框架演化&lt;/p&gt;
&lt;ul&gt;&lt;li class=&quot;code-line code-line code-line code-line&quot; data-line=&quot;100&quot;&gt;首屏 pureJSX&lt;/li&gt;
&lt;li class=&quot;code-line code-line code-line code-line&quot; data-line=&quot;101&quot;&gt;非首屏 preact&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li class=&quot;code-line code-line code-line code-line&quot; data-line=&quot;103&quot;&gt;
&lt;p class=&quot;code-line code-line code-line code-line&quot; data-line=&quot;103&quot;&gt;结果展示&lt;/p&gt;
&lt;p class=&quot;code-line code-line code-line code-line&quot; data-line=&quot;105&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1094273/201906/1094273-20190622232946100-1461866416.png&quot; alt=&quot;&quot; width=&quot;568&quot; height=&quot;258&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1094273/201906/1094273-20190622233038743-2083963226.png&quot; alt=&quot;&quot; width=&quot;568&quot; height=&quot;258&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1094273/201906/1094273-20190622233206978-1305175205.png&quot; alt=&quot;&quot; width=&quot;568&quot; height=&quot;258&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 未完，待续～&lt;/p&gt;

&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1094273/201902/1094273-20190213190853884-988641900.png&quot; alt=&quot;&quot; width=&quot;219&quot; height=&quot;217&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果你觉得这篇文章不错，可以给小编发个红包给予鼓励。&lt;/p&gt;
&lt;h2 id=&quot;%E6%8D%A2%E4%B8%AA%E8%A7%92%E5%BA%A6%E7%9C%8B-vue-%E7%BB%84%E4%BB%B6&quot; class=&quot;code-line code-line code-line code-line&quot; data-line=&quot;122&quot;&gt; &lt;/h2&gt;

</description>
<pubDate>Sat, 22 Jun 2019 15:18:00 +0000</pubDate>
<dc:creator>化身西湖云</dc:creator>
<og:description>GMTC-2019北京 GMTC这次的大会的热词肯定是监控、性能，当然跨平台依然是热点，write once,run anywhere!,以下是自己参加的总结心得。 6.20上午 前端的演化 核心理念</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yiyi17/p/11070872.html</dc:identifier>
</item>
<item>
<title>【干货分享】C# 实体类生成工具 - 艾三元</title>
<link>http://www.cnblogs.com/i3yuan/p/11070840.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/i3yuan/p/11070840.html</guid>
<description>&lt;p&gt;&lt;span&gt;前言&lt;/span&gt;：&lt;/p&gt;
&lt;p&gt;  项目实战中不论是业务编码还是通用编码，总会归纳出一些通用的工具类。放入项目中一劳永逸，让兄弟姐妹们避免编写重复代码。所以利用了工作之余的时间，将这些散落在多个项目中精致优雅的工具类，归纳起来形成工程，方便后续工作的使用和便捷开发。&lt;/p&gt;
&lt;p&gt;根据实际需求，编写了此工具。目前只支持SQLServer数据库，不过我自己有时间也会完成其他数据库支持的，有兴趣的读者可以继续扩展支持其他数据库。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;功能&lt;/span&gt;：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1&lt;/span&gt;、&lt;span&gt;能自动获得用户数据库中的所有数据表；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2&lt;/span&gt;、&lt;span&gt;能根据用户所选的数据表，自动生成实体类&lt;/span&gt;；&lt;br/&gt;&lt;span&gt;3&lt;/span&gt;、&lt;span&gt;能自动产生 C# 实体类的(*.cs)代码文件；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;实体工具&lt;/span&gt;：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一、界面截图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1576550/201906/1576550-20190622223321402-654656107.png&quot; alt=&quot;&quot; width=&quot;770&quot; height=&quot;633&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;二、SQL语句部分代码&lt;/span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--1. 获取所有的数据库名-----&lt;/span&gt;
&lt;span&gt;SELECT&lt;/span&gt; NAME &lt;span&gt;FROM&lt;/span&gt; MASTER.DBO.SYSDATABASES &lt;span&gt;ORDER&lt;/span&gt; &lt;span&gt;BY&lt;/span&gt;&lt;span&gt; NAME

&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;---2. 获取所有的表名------&lt;/span&gt;
&lt;span&gt;SELECT&lt;/span&gt; NAME &lt;span&gt;FROM&lt;/span&gt; SYSOBJECTS &lt;span&gt;WHERE&lt;/span&gt; XTYPE&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;U&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;ORDER&lt;/span&gt; &lt;span&gt;BY&lt;/span&gt;&lt;span&gt; NAME
&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;XTYPE='U':表示所有用户表;&lt;/span&gt;&lt;span&gt;
--&lt;/span&gt;&lt;span&gt;XTYPE='S':表示所有系统表;&lt;/span&gt;
&lt;span&gt;SELECT&lt;/span&gt; NAME &lt;span&gt;FROM&lt;/span&gt; SYSOBJECTS &lt;span&gt;WHERE&lt;/span&gt; TYPE &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;U&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;AND&lt;/span&gt; SYSSTAT &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;83&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--注意：一般情况只需要TYPE = 'U'，但有时候会有系统表混在其中（不知道什么原因），加上后面一句后就能删除这些系统表了。&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;三、C#部分代码&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 获取所有数据库
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;connection&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; List&amp;lt;DbTable&amp;gt; GetAllDataBaseName(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; connection)
        {
            List&lt;/span&gt;&amp;lt;DbTable&amp;gt; dic = &lt;span&gt;new&lt;/span&gt; List&amp;lt;DbTable&amp;gt;&lt;span&gt;();
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; ConnString = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;select name from Master.sys.SysDatabases order by name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            SqlConnection connect &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SqlConnection(connection);
            SqlCommand cmd &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SqlCommand(ConnString, connect);
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (connect.State ==&lt;span&gt; ConnectionState.Closed)
                {
                    connect.Open();
                    IDataReader dr &lt;/span&gt;=&lt;span&gt; cmd.ExecuteReader();
                    dic.Clear();
                    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (dr.Read())
                    {
                        dic.Add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; DbTable { value = dr[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;].ToString(), key = dr[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;].ToString() });
                    }
                    dr.Close();

                }
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
            {
                 &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; AggregateException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;获得数据库地址错误，你想上天吗？&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }
            &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (connect != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; connect.State ==&lt;span&gt; ConnectionState.Open)
                {
                    connect.Dispose();
                }
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; dic;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 写文件
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;fileName&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;文件完整路径&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;content&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;内容&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; WriteAndSave(&lt;span&gt;string&lt;/span&gt; fileName, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; content)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;实例化一个文件流---&amp;gt;与写入文件相关联&lt;/span&gt;
            &lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; fs = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FileStream(fileName, FileMode.Create, FileAccess.Write))
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;实例化一个StreamWriter--&amp;gt;与fs相关联&lt;/span&gt;
                &lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; sw = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StreamWriter(fs))
                {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;开始写入&lt;/span&gt;
&lt;span&gt;                    sw.Write(content);
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;清空缓冲区&lt;/span&gt;
&lt;span&gt;                    sw.Flush();
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭流&lt;/span&gt;
&lt;span&gt;                    sw.Close();
                    fs.Close();
                }
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;工具下载&lt;/span&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;C#实体类工具&quot; href=&quot;https://files-cdn.cnblogs.com/files/i3yuan/CodeTool.rar&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;实体类生成工具[下载]&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;总结&lt;/span&gt;&lt;strong&gt;：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.避免编写重复代码，编写此工具生成实体类快速开发。&lt;/p&gt;
&lt;p&gt;2.这类工具在网上已有不少，但是自己可以归纳起来形成工程，放入项目中，不仅自己从中可以学到新的知识也同时提升了自己的总结归纳能力。&lt;/p&gt;
&lt;p&gt;3.此工具还未完善，只支持SQLServer数据库，不过我自己有时间也会完成其他数据库支持的，有兴趣的读者可以继续扩展支持其他数据库。&lt;/p&gt;
&lt;p&gt;4.如果有不对的或不理解的地方，希望大家可以多多指正，提出问题，才能站在更多用户角度，编写了出更便捷实用的工具。&lt;/p&gt;
</description>
<pubDate>Sat, 22 Jun 2019 15:16:00 +0000</pubDate>
<dc:creator>艾三元</dc:creator>
<og:description>前言： 项目实战中不论是业务编码还是通用编码，总会归纳出一些通用的工具类。放入项目中一劳永逸，让兄弟姐妹们避免编写重复代码。所以利用了工作之余的时间，将这些散落在多个项目中精致优雅的工具类，归纳起来形</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/i3yuan/p/11070840.html</dc:identifier>
</item>
<item>
<title>Golang 编写 Tcp 服务器 - -Finley-</title>
<link>http://www.cnblogs.com/Finley/p/11070669.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Finley/p/11070669.html</guid>
<description>&lt;p&gt;Golang 作为广泛用于服务端和云计算领域的编程语言，tcp socket 是其中至关重要的功能。无论是 WEB 服务器还是各类中间件都离不开 tcp socket 的支持。&lt;/p&gt;
&lt;p&gt;与早期的每个线程持有一个 socket 的 block IO 模型不同, 多路IO复用模型使用单个线程监听多个 socket, 当某个 socket 准备好数据后再进行响应。在逻辑上与使用 select 语句监听多个 channel 的模式相同。&lt;/p&gt;
&lt;p&gt;目前主要的多路IO复用实现主要包括: SELECT, POLL 和 EPOLL。 为了提高开发效率社区也出现很多封装库， 如Netty(Java), Tornado(Python) 和 libev(C)等。&lt;/p&gt;
&lt;p&gt;Golang Runtime 封装了各操作系统平台上的多路IO复用接口， 并允许使用 goroutine 快速开发高性能的 tcp 服务器。&lt;/p&gt;

&lt;p&gt;作为开始，我们来实现一个简单的 Echo 服务器。它会接受客户端连接并将客户端发送的内容原样传回客户端。&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;package main

import (
    &quot;fmt&quot;
    &quot;net&quot;
    &quot;io&quot;
    &quot;log&quot;
    &quot;bufio&quot;
)

func ListenAndServe(address string) {
    // 绑定监听地址
    listener, err := net.Listen(&quot;tcp&quot;, address)
    if err != nil {
        log.Fatal(fmt.Sprintf(&quot;listen err: %v&quot;, err))
    }
    defer listener.Close()
    log.Println(fmt.Sprintf(&quot;bind: %s, start listening...&quot;, address))

    for {
        // Accept 会一直阻塞直到有新的连接建立或者listen中断才会返回
        conn, err := listener.Accept()
        if err != nil {
            // 通常是由于listener被关闭无法继续监听导致的错误
            log.Fatal(fmt.Sprintf(&quot;accept err: %v&quot;, err))
        }
        // 开启新的 goroutine 处理该连接
        go Handle(conn)
    }
}

func Handle(conn net.Conn) {
    // 使用 bufio 标准库提供的缓冲区功能
    reader := bufio.NewReader(conn)
    for {
        // ReadString 会一直阻塞直到遇到分隔符 '\n'
        // 遇到分隔符后会返回上次遇到分隔符或连接建立后收到的所有数据, 包括分隔符本身
        // 若在遇到分隔符之前遇到异常, ReadString 会返回已收到的数据和错误信息
        msg, err := reader.ReadString('\n')
        if err != nil {
            // 通常遇到的错误是连接中断或被关闭，用io.EOF表示
            if err == io.EOF {
                log.Println(&quot;connection close&quot;)
            } else {
                log.Println(err)
            }
            return
        }
        b := []byte(msg)
        // 将收到的信息发送给客户端
        conn.Write(b)
    }
}

func main() {
    ListenAndServe(&quot;:8000&quot;)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用 telnet 工具测试我们编写的 Echo 服务器:&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ telnet 127.0.0.1 8000
Trying 127.0.0.1...
Connected to 127.0.0.1.
Escape character is '^]'.
&amp;gt; a
a
&amp;gt; b
b
Connection closed by foreign host.&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;HTTP 等应用层协议只有收到一条完整的消息后才能进行处理，而工作在传输层的TCP协议并不了解应用层消息的结构。&lt;/p&gt;
&lt;p&gt;因此，可能遇到一条应用层消息分为两个TCP包发送或者一个TCP包中含有两条应用层消息片段的情况，前者称为拆包后者称为粘包。&lt;/p&gt;
&lt;p&gt;在 Echo 服务器的示例中，我们定义用&lt;code&gt;\n&lt;/code&gt;表示消息结束。我们可能遇到下列几种情况:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;收到两个 tcp 包: &quot;abc&quot;, &quot;def\n&quot;, 应发出一条响应 &quot;abcdef\n&quot;, 这是拆包的情况&lt;/li&gt;
&lt;li&gt;收到一个 tcp 包: &quot;abc\ndef\n&quot;, 应发出两条响应 &quot;abc\n&quot;, &quot;def\n&quot;, 这是粘包的情况&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;当我们使用 tcp socket 开发应用层程序时必须正确处理拆包和粘包。&lt;/p&gt;
&lt;p&gt;bufio 标准库会缓存收到的数据直到遇到分隔符才会返回，它可以正确处理拆包和粘包。&lt;/p&gt;
&lt;p&gt;上层协议通常采用下列几种思路之一来定义消息，以保证完整地进行读取:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;定长消息&lt;/li&gt;
&lt;li&gt;在消息尾部添加特殊分隔符，如示例中的Echo协议和FTP控制协议&lt;/li&gt;
&lt;li&gt;将消息分为header 和 body, 并在 header 提供消息总长度。这是应用最广泛的策略，如HTTP协议。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在生产环境下需要保证TCP服务器关闭前完成必要的清理工作，包括将完成正在进行的数据传输，关闭TCP连接等。这种关闭模式称为优雅关闭，可以避免资源泄露以及客户端未收到完整数据造成异常。&lt;/p&gt;
&lt;p&gt;TCP 服务器的优雅关闭模式通常为: 先关闭listener阻止新连接进入，然后遍历所有连接逐个进行关闭。&lt;/p&gt;
&lt;p&gt;本节完整源代码地址: &lt;a href=&quot;https://github.com/HDT3213/godis/tree/master/src/server&quot; class=&quot;uri&quot;&gt;https://github.com/HDT3213/godis/tree/master/src/server&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;首先修改一下TCP服务器:&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;// handler 是应用层服务器的抽象
type Handler interface {
    Handle(ctx context.Context, conn net.Conn)
    Close()error
}

func ListenAndServe(cfg *Config, handler tcp.Handler) {
    listener, err := net.Listen(&quot;tcp&quot;, cfg.Address)
    if err != nil {
        logger.Fatal(fmt.Sprintf(&quot;listen err: %v&quot;, err))
    }

    // 监听中断信号
    // atomic.AtomicBool 是作者写的封装: https://github.com/HDT3213/godis/blob/master/src/lib/sync/atomic/bool.go
    var closing atomic.AtomicBool 
    sigCh := make(chan os.Signal, 1)
    signal.Notify(sigCh, syscall.SIGHUP, syscall.SIGQUIT, syscall.SIGTERM, syscall.SIGINT)
    go func() {
        sig := &amp;lt;-sigCh
        switch sig {
        case syscall.SIGHUP, syscall.SIGQUIT, syscall.SIGTERM, syscall.SIGINT:
            // 收到中断信号后开始关闭流程
            logger.Info(&quot;shuting down...&quot;)
            // 设置标志位为关闭中, 使用原子操作保证线程可见性
            closing.Set(true)
            // listener 关闭后 listener.Accept() 会立即返回错误
            listener.Close() 
        }
    }()


    logger.Info(fmt.Sprintf(&quot;bind: %s, start listening...&quot;, cfg.Address))
    // 在出现未知错误或panic后保证正常关闭
    // 注意defer顺序，先关闭 listener 再关闭应用层服务器 handler
    defer handler.Close()
    defer listener.Close()
    ctx, _ := context.WithCancel(context.Background())
    for {
        conn, err := listener.Accept()
        if err != nil {
            if closing.Get() {
                // 收到关闭信号后进入此流程，此时listener已被监听系统信号的 goroutine 关闭
                // handler 会被上文的 defer 语句关闭直接返回
                return 
            }
            logger.Error(fmt.Sprintf(&quot;accept err: %v&quot;, err))
            continue
        }
        // handle
        logger.Info(&quot;accept link&quot;)
        go handler.Handle(ctx, conn)
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来修改应用层服务器:&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;// 客户端连接的抽象
type Client struct {
    // tcp 连接
    Conn net.Conn
    // 当服务端开始发送数据时进入waiting, 阻止其它goroutine关闭连接
    // wait.Wait是作者编写的带有最大等待时间的封装: 
    // https://github.com/HDT3213/godis/blob/master/src/lib/sync/wait/wait.go
    Waiting wait.Wait
}

type EchoHandler struct {
    
    // 保存所有工作状态client的集合(把map当set用)
    // 需使用并发安全的容器
    activeConn sync.Map 

    // 和 tcp server 中作用相同的关闭状态标识位
    closing atomic.AtomicBool
}

func MakeEchoHandler()(*EchoHandler) {
    return &amp;amp;EchoHandler{
    }
}

// 关闭客户端连接
func (c *Client)Close()error {
    // 等待数据发送完成或超时
    c.Waiting.WaitWithTimeout(10 * time.Second)
    c.Conn.Close()
    return nil
}

func (h *EchoHandler)Handle(ctx context.Context, conn net.Conn) {
    if h.closing.Get() {
        // closing handler refuse new connection
        conn.Close()
    }

    client := &amp;amp;Client {
        Conn: conn,
    }
    h.activeConn.Store(client, 1)

    reader := bufio.NewReader(conn)
    for {
        msg, err := reader.ReadString('\n')
        if err != nil {
            if err == io.EOF {
                logger.Info(&quot;connection close&quot;)
                h.activeConn.Delete(conn)
            } else {
                logger.Warn(err)
            }
            return
        }
        // 发送数据前先置为waiting状态
        client.Waiting.Add(1)

        // 模拟关闭时未完成发送的情况
        //logger.Info(&quot;sleeping&quot;)
        //time.Sleep(10 * time.Second)

        b := []byte(msg)
        conn.Write(b)
        // 发送完毕, 结束waiting
        client.Waiting.Done()
    }
}

func (h *EchoHandler)Close()error {
    logger.Info(&quot;handler shuting down...&quot;)
    h.closing.Set(true)
    // TODO: concurrent wait
    h.activeConn.Range(func(key interface{}, val interface{})bool {
        client := key.(*Client)
        client.Close()
        return true
    })
    return nil
}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sat, 22 Jun 2019 14:20:00 +0000</pubDate>
<dc:creator>-Finley-</dc:creator>
<og:description>Golang 开发 Tcp 服务器及拆包粘包、优雅关闭的解决方案</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Finley/p/11070669.html</dc:identifier>
</item>
<item>
<title>java内存模型的实现 - murphy_gb</title>
<link>http://www.cnblogs.com/kyoner/p/11070496.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kyoner/p/11070496.html</guid>
<description>&lt;p&gt;前几天，发了一篇文章，介绍了一下&lt;a href=&quot;https://www.cnblogs.com/kyoner/p/11067680.html&quot;&gt;JVM内存结构、Java内存模型以及Java对象模型之间的区别&lt;/a&gt;。其中，Java内存模型，是这三个知识点当中最晦涩难懂的一个，而且涉及到很多背景知识和相关知识。&lt;/p&gt;
&lt;p&gt;网上有很多关于Java内存模型的文章，在《深入理解Java虚拟机》和《Java并发编程的艺术》等书中也都有关于这个知识点的介绍。但是，很多人读完之后还是搞不清楚，甚至有的人说自己更懵了。本文，就来整体的介绍一下Java内存模型，目的很简单，让你读完本文以后，就知道到底Java内存模型是什么，为什么要有Java内存模型，Java内存模型解决了什么问题等。&lt;/p&gt;
&lt;p&gt;本文中，有很多定义和说法，都是笔者自己理解后定义出来的。希望能够让读者可以对Java内存模型有更加清晰的认识。当然，如有偏颇，欢迎指正。&lt;/p&gt;

&lt;p&gt;在介绍Java内存模型之前，先来看一下到底什么是计算机内存模型，然后再来看Java内存模型在计算机内存模型的基础上做了哪些事情。要说计算机的内存模型，就要说一下一段古老的历史，看一下为什么要有内存模型。&lt;/p&gt;
&lt;h3 id=&quot;cpu和缓存一致性&quot;&gt;CPU和缓存一致性&lt;/h3&gt;
&lt;p&gt;我们应该都知道，计算机在执行程序的时候，每条指令都是在CPU中执行的，而执行的时候，又免不了要和数据打交道。而计算机上面的数据，是存放在主存当中的，也就是计算机的物理内存。&lt;/p&gt;
&lt;p&gt;刚开始，还相安无事的，但是随着CPU技术的发展，CPU的执行速度越来越快。而由于内存的技术并没有太大的变化，所以从内存中读取和写入数据的过程和CPU的执行速度比起来差距就会越来越大,这就导致CPU每次操作内存都要耗费很多等待时间。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;这就像一家创业公司，刚开始，创始人和员工之间工作关系其乐融融，但是随着创始人的能力和野心越来越大，逐渐和员工之间出现了差距，普通员工越来越跟不上CEO的脚步。老板的每一个命令，传到到基层员工之后，由于基层员工的理解能力、执行能力的欠缺，就会耗费很多时间。这也就无形中拖慢了整家公司的工作效率。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可是，不能因为内存的读写速度慢，就不发展CPU技术了吧，总不能让内存成为计算机处理的瓶颈吧。&lt;/p&gt;
&lt;p&gt;所以，人们想出来了一个好的办法，就是在CPU和内存之间增加高速缓存。缓存的概念大家都知道，就是保存一份数据拷贝。他的特点是速度快，内存小，并且昂贵。&lt;/p&gt;
&lt;p&gt;那么，程序的执行过程就变成了：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;之后，这家公司开始设立中层管理人员，管理人员直接归CEO领导，领导有什么指示，直接告诉管理人员，然后就可以去做自己的事情了。管理人员负责去协调底层员工的工作。因为管理人员是了解手下的人员以及自己负责的事情的。所以，大多数时候，公司的各种决策，通知等，CEO只要和管理人员之间沟通就够了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;而随着CPU能力的不断提升，一层缓存就慢慢的无法满足要求了，就逐渐的衍生出多级缓存。&lt;/p&gt;
&lt;p&gt;按照数据读取顺序和与CPU结合的紧密程度，CPU缓存可以分为一级缓存（L1），二级缓存（L2），部分高端CPU还具有三级缓存（L3），&lt;strong&gt;每一级缓存中所储存的全部数据都是下一级缓存的一部分。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这三种缓存的技术难度和制造成本是相对递减的，所以其容量也是相对递增的。&lt;/p&gt;
&lt;p&gt;那么，在有了多级缓存之后，程序的执行就变成了：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当CPU要读取一个数据时，首先从一级缓存中查找，如果没有找到再从二级缓存中查找，如果还是没有就从三级缓存或内存中查找。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;随着公司越来越大，老板要管的事情越来越多，公司的管理部门开始改革，开始出现高层，中层，底层等管理者。一级一级之间逐层管理。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;单核CPU只含有一套L1，L2，L3缓存；&lt;/p&gt;
&lt;p&gt;如果CPU含有多个核心，即多核CPU，则每个核心都含有一套L1（甚至和L2）缓存，而共享L3（或者和L2）缓存。&lt;/p&gt;
&lt;blockquote readability=&quot;16&quot;&gt;
&lt;p&gt;公司也分很多种，有些公司只有一个大Boss，他一个人说了算。但是有些公司有比如联席总经理、合伙人等机制。&lt;/p&gt;
&lt;p&gt;单核CPU就像一家公司只有一个老板，所有命令都来自于他，那么就只需要一套管理班底就够了。&lt;/p&gt;
&lt;p&gt;多核CPU就像一家公司是由多个合伙人共同创办的，那么，就需要给每个合伙人都设立一套供自己直接领导的高层管理人员，多个合伙人共享使用的是公司的底层员工。&lt;/p&gt;
&lt;p&gt;还有的公司，不断壮大，开始差分出各个子公司。各个子公司就是多个CPU了，互相之间没有共用的资源。互不影响。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下图为一个单CPU双核的缓存结构。&lt;/p&gt;
&lt;p&gt;&lt;embed src=&quot;https://img2018.cnblogs.com/blog/1566782/201906/1566782-20190622214103719-356085566.webp&quot;/&gt;&lt;/p&gt;
&lt;p&gt;随着计算机能力不断提升，开始支持多线程。那么问题就来了。我们分别来分析下单线程、多线程在单核CPU、多核CPU中的影响。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;单线程。&lt;/strong&gt;cpu核心的缓存只被一个线程访问。缓存独占，不会出现访问冲突等问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;单核CPU，多线程。&lt;/strong&gt;进程中的多个线程会同时访问进程中的共享数据，CPU将某块内存加载到缓存后，不同线程在访问相同的物理地址的时候，都会映射到相同的缓存位置，这样即使发生线程的切换，缓存仍然不会失效。但由于任何时刻只能有一个线程在执行，因此不会出现缓存访问冲突。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;多核CPU，多线程。&lt;/strong&gt;每个核都至少有一个L1 缓存。多个线程访问进程中的某个共享内存，且这多个线程分别在不同的核心上执行，则每个核心都会在各自的caehe中保留一份共享内存的缓冲。由于多核是可以并行的，可能会出现多个线程同时写各自的缓存的情况，而各自的cache之间的数据就有可能不同。&lt;/p&gt;
&lt;p&gt;在CPU和主存之间增加缓存，在多线程场景下就可能存在&lt;strong&gt;缓存一致性问题&lt;/strong&gt;，也就是说，在多核CPU中，每个核的自己的缓存中，关于同一个数据的缓存内容可能不一致。&lt;/p&gt;
&lt;blockquote readability=&quot;17&quot;&gt;
&lt;p&gt;如果这家公司的命令都是串行下发的话，那么就没有任何问题。&lt;/p&gt;
&lt;p&gt;如果这家公司的命令都是并行下发的话，并且这些命令都是由同一个CEO下发的，这种机制是也没有什么问题。因为他的命令执行者只有一套管理体系。&lt;/p&gt;
&lt;p&gt;如果这家公司的命令都是并行下发的话，并且这些命令是由多个合伙人下发的，这就有问题了。因为每个合伙人只会把命令下达给自己直属的管理人员，而多个管理人员管理的底层员工可能是公用的。&lt;/p&gt;
&lt;p&gt;比如，合伙人1要辞退员工a，合伙人2要给员工a升职，升职后的话他再被辞退需要多个合伙人开会决议。两个合伙人分别把命令下发给了自己的管理人员。合伙人1命令下达后，管理人员a在辞退了员工后，他就知道这个员工被开除了。而合伙人2的管理人员2这时候在没得到消息之前，还认为员工a是在职的，他就欣然的接收了合伙人给他的升职a的命令。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;embed src=&quot;https://img2018.cnblogs.com/blog/1566782/201906/1566782-20190622214026182-1947118414.webp&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;处理器优化和指令重排&quot;&gt;处理器优化和指令重排&lt;/h3&gt;
&lt;p&gt;上面提到在在CPU和主存之间增加缓存，在多线程场景下会存在&lt;strong&gt;缓存一致性问题&lt;/strong&gt;。除了这种情况，还有一种硬件问题也比较重要。那就是为了使处理器内部的运算单元能够尽量的被充分利用，处理器可能会对输入代码进行乱序执行处理。这就是&lt;strong&gt;处理器优化&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;除了现在很多流行的处理器会对代码进行优化乱序处理，很多编程语言的编译器也会有类似的优化，比如Java虚拟机的即时编译器（JIT）也会做&lt;strong&gt;指令重排&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;可想而知，如果任由处理器优化和编译器对指令重排的话，就可能导致各种各样的问题。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;关于员工组织调整的情况，如果允许人事部在接到多个命令后进行随意拆分乱序执行或者重排的话，那么对于这个员工以及这家公司的影响是非常大的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;并发编程的问题&quot;&gt;并发编程的问题&lt;/h3&gt;
&lt;p&gt;前面说的和硬件有关的概念你可能听得有点蒙，还不知道他到底和软件有啥关系。但是关于并发编程的问题你应该有所了解，比如原子性问题，可见性问题和有序性问题。&lt;/p&gt;
&lt;p&gt;其实，原子性问题，可见性问题和有序性问题。是人们抽象定义出来的。而这个抽象的底层问题就是前面提到的缓存一致性问题、处理器优化问题和指令重排问题等。&lt;/p&gt;
&lt;p&gt;这里简单回顾下这三个问题，并不准备深入展开，感兴趣的读者可以自行学习。我们说，并发编程，为了保证数据的安全，需要满足以下三个特性：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;原子性&lt;/strong&gt;是指在一个操作中就是cpu不可以在中途暂停然后再调度，既不被中断操作，要不执行完成，要不就不执行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可见性&lt;/strong&gt;是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;有序性&lt;/strong&gt;即程序执行的顺序按照代码的先后顺序执行。&lt;/p&gt;
&lt;p&gt;有没有发现，&lt;strong&gt;缓存一致性问题&lt;/strong&gt;其实就是&lt;strong&gt;可见性问题&lt;/strong&gt;。而&lt;strong&gt;处理器优化&lt;/strong&gt;是可以导致&lt;strong&gt;原子性问题&lt;/strong&gt;的。&lt;strong&gt;指令重排&lt;/strong&gt;即会导致&lt;strong&gt;有序性问题&lt;/strong&gt;。所以，后文将不再提起硬件层面的那些概念，而是直接使用大家熟悉的原子性、可见性和有序性。&lt;/p&gt;
&lt;p&gt;前面提到的，缓存一致性问题、处理器器优化的指令重排问题是硬件的不断升级导致的。那么，有没有什么机制可以很好的解决上面的这些问题呢？&lt;/p&gt;
&lt;p&gt;最简单直接的做法就是废除处理器和处理器的优化技术、废除CPU缓存，让CPU直接和主存交互。但是，这么做虽然可以保证多线程下的并发问题。但是，这就有点因噎废食了。&lt;/p&gt;
&lt;p&gt;所以，为了保证并发编程中可以满足原子性、可见性及有序性。有一个重要的概念，那就是——内存模型。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为了保证共享内存的正确性（可见性、有序性、原子性），内存模型定义了共享内存系统中多线程程序读写操作行为的规范。&lt;/strong&gt;通过这些规则来规范对内存的读写操作，从而保证指令执行的正确性。它与处理器有关、与缓存有关、与并发有关、与编译器也有关。他解决了CPU多级缓存、处理器优化、指令重排等导致的内存访问问题，保证了并发场景下的一致性、原子性和有序性。&lt;/p&gt;
&lt;p&gt;内存模型解决并发问题主要采用两种方式：&lt;strong&gt;限制处理器优化&lt;/strong&gt;和&lt;strong&gt;使用内存屏障&lt;/strong&gt;。本文就不深入底层原理来展开介绍了，感兴趣的朋友可以自行学习。&lt;/p&gt;

&lt;p&gt;前面介绍过了计算机内存模型，这是解决多线程场景下并发问题的一个重要规范。那么具体的实现是如何的呢，不同的编程语言，在实现上可能有所不同。&lt;/p&gt;
&lt;p&gt;我们知道，Java程序是需要运行在Java虚拟机上面的，&lt;strong&gt;Java内存模型（Java Memory Model ,JMM）就是一种符合内存模型规范的，屏蔽了各种硬件和操作系统的访问差异的，保证了Java程序在各种平台下对内存的访问都能保证效果一致的机制及规范。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;提到Java内存模型，一般指的是JDK 5 开始使用的新的内存模型，主要由JSR-133: JavaTM Memory Model and Thread Specification 描述。感兴趣的可以参看下这份PDF文档（&lt;a href=&quot;http://www.cs.umd.edu/~pugh/java/memoryModel/jsr133.pdf&quot; class=&quot;uri&quot;&gt;http://www.cs.umd.edu/~pugh/java/memoryModel/jsr133.pdf&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;Java内存模型规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了该线程中是用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。&lt;/p&gt;
&lt;p&gt;而JMM就作用于工作内存和主存之间数据同步过程。他规定了如何做数据同步以及什么时候做数据同步。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1566782/201906/1566782-20190622214217831-495649967.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里面提到的主内存和工作内存，读者可以简单的类比成计算机内存模型中的主存和缓存的概念。特别需要注意的是，主内存和工作内存与JVM内存结构中的Java堆、栈、方法区等并不是同一个层次的内存划分，无法直接类比。《深入理解Java虚拟机》中认为，如果一定要勉强对应起来的话，从变量、主内存、工作内存的定义来看，主内存主要对应于Java堆中的对象实例数据部分。工作内存则对应于虚拟机栈中的部分区域。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所以，再来总结下，JMM是一种规范，目的是解决由于多线程通过共享内存进行通信时，存在的本地内存数据不一致、编译器会对代码指令重排序、处理器会对代码乱序执行等带来的问题。目的是保证并发编程场景中的原子性、可见性和有序性。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;了解Java多线程的朋友都知道，在Java中提供了一系列和并发处理相关的关键字，比如&lt;code&gt;volatile&lt;/code&gt;、&lt;code&gt;synchronized&lt;/code&gt;、&lt;code&gt;final&lt;/code&gt;、&lt;code&gt;concurren&lt;/code&gt;包等。其实这些就是Java内存模型封装了底层的实现后提供给程序员使用的一些关键字。&lt;/p&gt;
&lt;p&gt;在开发多线程的代码的时候，我们可以直接使用&lt;code&gt;synchronized&lt;/code&gt;等关键字来控制并发，从来就不需要关心底层的编译器优化、缓存一致性等问题。所以，&lt;strong&gt;Java内存模型，除了定义了一套规范，还提供了一系列原语，封装了底层实现后，供开发者直接使用。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本文并不准备把所有的关键字逐一介绍其用法，因为关于各个关键字的用法，网上有很多资料。读者可以自行学习。本文还有一个重点要介绍的就是，我们前面提到，并发编程要解决原子性、有序性和一致性的问题，我们就再来看下，在Java中，分别使用什么方式来保证。&lt;/p&gt;
&lt;h3 id=&quot;原子性&quot;&gt;原子性&lt;/h3&gt;
&lt;p&gt;在Java中，为了保证原子性，提供了两个高级的字节码指令&lt;code&gt;monitorenter&lt;/code&gt;和&lt;code&gt;monitorexit, 这两个字节码，在Java中对应的关键字就是&lt;/code&gt;synchronized`。&lt;/p&gt;
&lt;p&gt;因此，在Java中可以使用&lt;code&gt;synchronized&lt;/code&gt;来保证方法和代码块内的操作是原子性的。&lt;/p&gt;
&lt;h3 id=&quot;可见性&quot;&gt;可见性&lt;/h3&gt;
&lt;p&gt;Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值的这种依赖主内存作为传递媒介的方式来实现的。&lt;/p&gt;
&lt;p&gt;Java中的&lt;code&gt;volatile&lt;/code&gt;关键字提供了一个功能，那就是被其修饰的变量在被修改后可以立即同步到主内存，被其修饰的变量在每次是用之前都从主内存刷新。因此，可以使用&lt;code&gt;volatile&lt;/code&gt;来保证多线程操作时变量的可见性。&lt;/p&gt;
&lt;p&gt;除了&lt;code&gt;volatile&lt;/code&gt;，Java中的&lt;code&gt;synchronized&lt;/code&gt;和&lt;code&gt;final&lt;/code&gt;两个关键字也可以实现可见性。只不过实现方式不同，这里不再展开了。&lt;/p&gt;
&lt;h3 id=&quot;有序性&quot;&gt;有序性&lt;/h3&gt;
&lt;p&gt;在Java中，可以使用&lt;code&gt;synchronized&lt;/code&gt;和&lt;code&gt;volatile&lt;/code&gt;来保证多线程之间操作的有序性。实现方式有所区别：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;volatile&lt;/code&gt;关键字会禁止指令重排。&lt;code&gt;synchronized&lt;/code&gt;关键字保证同一时刻只允许一条线程操作。&lt;/p&gt;
&lt;p&gt;好了，这里简单的介绍完了Java并发编程中解决原子性、可见性以及有序性可以使用的关键字。读者可能发现了，好像&lt;code&gt;synchronized&lt;/code&gt;关键字是万能的，他可以同时满足以上三种特性，这其实也是很多人滥用&lt;code&gt;synchronized&lt;/code&gt;的原因。&lt;/p&gt;
&lt;p&gt;但是&lt;code&gt;synchronized&lt;/code&gt;是比较影响性能的，虽然编译器提供了很多锁优化技术，但是也不建议过度使用。&lt;/p&gt;
</description>
<pubDate>Sat, 22 Jun 2019 13:45:00 +0000</pubDate>
<dc:creator>murphy_gb</dc:creator>
<og:description>前几天，发了一篇文章，介绍了一下 'JVM内存结构、Java内存模型以及Java对象模型之间的区别' 。其中，Java内存模型，是这三个知识点当中最晦涩难懂的一个，而且涉及到很多背景知识和相关知识。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/kyoner/p/11070496.html</dc:identifier>
</item>
</channel>
</rss>