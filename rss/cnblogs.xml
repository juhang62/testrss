<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Tomcat 第二篇：启动流程 - 极客挖掘机</title>
<link>http://www.cnblogs.com/babycomeon/p/13689281.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/babycomeon/p/13689281.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://cdn.geekdigging.com/java/tomcat/tomcat_header.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-tomcat-基本知识&quot;&gt;1 Tomcat 基本知识&lt;/h2&gt;
&lt;p&gt;首先介绍一些 Tomcat 的基本知识，防止有纯小白看的云里雾里的。&lt;/p&gt;
&lt;p&gt;下面这张图是一个下载好二进制版的的 Tomcat ，直接解压得到的，虽然版本是 9.x ，但是这个目录结构和 8.5 是一致的，不影响介绍。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.geekdigging.com/java/tomcat/tomcat02/tomcat_mulu.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;bin : 主要用来存放一些脚本文件，一种格式是 sh 的是在 Linux 使用的脚本，另一种格式是 bat 的是在 Windows 中使用的脚本。&lt;/li&gt;
&lt;li&gt;conf : 主要用来存放一些 Tomcat 的配置文件，有 xml 格式的也有 properties 格式的。&lt;/li&gt;
&lt;li&gt;lib : 用来存放一些 Tomcat 运行时所需要的 jar 包。&lt;/li&gt;
&lt;li&gt;logs : 日志目录。&lt;/li&gt;
&lt;li&gt;temp : 存放一些运行过程中产生的临时文件。&lt;/li&gt;
&lt;li&gt;webapps : 这个应该很熟悉，主要用来存放应用程序，可以是 war 包或者是 jar 包。&lt;/li&gt;
&lt;li&gt;work : 主要用来存放 Tomcat 在运行时的编译后文件。清空work目录，然后重启 Tomcat ，可以达到清除缓存的作用。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;现在的 &lt;code&gt;IDE(Integrated Development Environment)&lt;/code&gt; 工具可以直接将 Tomcat 配置在工具中，比如最常用的 Eclipse 和 IDEA ，启动 Tomcat 的时候只需要点一下按钮就可以启动，实际上这两个 IDE 工具只是帮我们调用了 Tomcat 的启动脚本。&lt;/p&gt;
&lt;p&gt;Tomcat 的各种脚本都放在 bin 这个目录下，我们打开看一下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.geekdigging.com/java/tomcat/tomcat02/tomcat_shell.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以轻易的找到两个启动脚本 &lt;code&gt;startup.bat&lt;/code&gt; 和 &lt;code&gt;startup.sh&lt;/code&gt; 。一个是 Windows 下的脚本，一个 Linux 下的。&lt;/p&gt;
&lt;p&gt;同样，还可以看到两个停止脚本 &lt;code&gt;shutdown.bat&lt;/code&gt; 和 &lt;code&gt;shutdown.sh&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;这是在 Tomcat 的二进制包中，我们还可以看下源码包下是什么样的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.geekdigging.com/java/tomcat/tomcat02/source_shell.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，基本上该有的都有，最重要的启停脚本都还在。&lt;/p&gt;
&lt;p&gt;既然我现在是在 Windows 环境下，那么启动就从 &lt;code&gt;startup.bat&lt;/code&gt; 看起。&lt;/p&gt;
&lt;h2 id=&quot;2-tomcat-启动第一步：startupbat&quot;&gt;2 Tomcat 启动第一步：startup.bat&lt;/h2&gt;
&lt;p&gt;第一个打开 &lt;code&gt;startup.bat&lt;/code&gt; 这个启动脚本，看下里面写了啥具体，这段脚本不长，我把里面的内容摘出来：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bat&quot;&gt;setlocal

rem Guess CATALINA_HOME if not defined
set &quot;CURRENT_DIR=%cd%&quot;
if not &quot;%CATALINA_HOME%&quot; == &quot;&quot; goto gotHome
set &quot;CATALINA_HOME=%CURRENT_DIR%&quot;
if exist &quot;%CATALINA_HOME%\bin\catalina.bat&quot; goto okHome
cd ..
set &quot;CATALINA_HOME=%cd%&quot;
cd &quot;%CURRENT_DIR%&quot;
:gotHome
if exist &quot;%CATALINA_HOME%\bin\catalina.bat&quot; goto okHome
echo The CATALINA_HOME environment variable is not defined correctly
echo This environment variable is needed to run this program
goto end
:okHome

set &quot;EXECUTABLE=%CATALINA_HOME%\bin\catalina.bat&quot;

rem Check that target executable exists
if exist &quot;%EXECUTABLE%&quot; goto okExec
echo Cannot find &quot;%EXECUTABLE%&quot;
echo This file is needed to run this program
goto end
:okExec

rem Get remaining unshifted command line arguments and save them in the
set CMD_LINE_ARGS=
:setArgs
if &quot;&quot;%1&quot;&quot;==&quot;&quot;&quot;&quot; goto doneSetArgs
set CMD_LINE_ARGS=%CMD_LINE_ARGS% %1
shift
goto setArgs
:doneSetArgs

call &quot;%EXECUTABLE%&quot; start %CMD_LINE_ARGS%

:end
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最开始一大段的 rem 注释我没摘，只摘了最后一部分会执行的内容。&lt;/p&gt;
&lt;p&gt;第一段是在设置当前的 &lt;code&gt;CATALINA_HOME&lt;/code&gt; 的环境变量，如果没有设置的话，会将当前运行脚本的目录作为该环境变量的值，然后跳转到 &lt;code&gt;:okHome&lt;/code&gt; 那里。&lt;/p&gt;
&lt;p&gt;接下来设置了 &lt;code&gt;EXECUTABLE&lt;/code&gt; 的路径是 &lt;code&gt;%CATALINA_HOME%\bin\catalina.bat&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;然后开始验证验证设置的 &lt;code&gt;EXECUTABLE&lt;/code&gt; 中的 &lt;code&gt;catalina.bat&lt;/code&gt; 这个文件存不存在，如果不存在的话直接结束，如果存在的话接着往下走。&lt;/p&gt;
&lt;p&gt;接下来是将运行脚本前设置的其他参数保存到 &lt;code&gt;CMD_LINE_ARGS&lt;/code&gt; 这个变量中，然后在最后执行了 &lt;code&gt;catalina.bat&lt;/code&gt; 这个文件，跟了两个参数，第一个是 &lt;code&gt;start&lt;/code&gt; ，第二个就是刚才保存的变量 &lt;code&gt;CMD_LINE_ARGS&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;这种脚本代码建议放在编辑器里看，千万不要使用那个 Windows 自带的记事本，用那玩意看估计大多数人直接就看懵了。&lt;/p&gt;
&lt;p&gt;我通常是放在 VSCode 中看，会自动对代码进行高亮展示，给大家看下上面这段脚本放在 VSCode 中的样子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.geekdigging.com/java/tomcat/tomcat02/vs_code_bat.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，正常注释变灰，关键字变蓝高亮，并且跳转语句直接变橙色，非常方便我们阅读。&lt;/p&gt;
&lt;h2 id=&quot;3-tomcat-启动第二步：catalinabat&quot;&gt;3 Tomcat 启动第二步：catalina.bat&lt;/h2&gt;
&lt;p&gt;这个脚本太长了，我就单纯的截取比较重要的进行介绍。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;set &quot;CURRENT_DIR=%cd%&quot;
if not &quot;%CATALINA_HOME%&quot; == &quot;&quot; goto gotHome
set &quot;CATALINA_HOME=%CURRENT_DIR%&quot;
if exist &quot;%CATALINA_HOME%\bin\catalina.bat&quot; goto okHome
cd ..
set &quot;CATALINA_HOME=%cd%&quot;
cd &quot;%CURRENT_DIR%&quot;
:gotHome

if exist &quot;%CATALINA_HOME%\bin\catalina.bat&quot; goto okHome
echo The CATALINA_HOME environment variable is not defined correctly
echo This environment variable is needed to run this program
goto end
:okHome
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在最开头的地方，校验 &lt;code&gt;CATALINA_HOME&lt;/code&gt; 是否存在，如果不存在，则设置 &lt;code&gt;CATALINA_HOME&lt;/code&gt; 为当前路径。&lt;/p&gt;
&lt;p&gt;接着下面设置了一下 &lt;code&gt;CATALINA_BASE&lt;/code&gt; 这个变量。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;if not &quot;%CATALINA_BASE%&quot; == &quot;&quot; goto gotBase
set &quot;CATALINA_BASE=%CATALINA_HOME%&quot;
:gotBase
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来到了一个重点内容，判断 &lt;code&gt;setclasspath.bat&lt;/code&gt; 是否存在，如果存在的话就执行一下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;rem Get standard Java environment variables
if exist &quot;%CATALINA_HOME%\bin\setclasspath.bat&quot; goto okSetclasspath
echo Cannot find &quot;%CATALINA_HOME%\bin\setclasspath.bat&quot;
echo This file is needed to run this program
goto end
:okSetclasspath
call &quot;%CATALINA_HOME%\bin\setclasspath.bat&quot; %1
if errorlevel 1 goto end
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个文件实际上是校验是否设置了 &lt;code&gt;JAVA_HOME&lt;/code&gt; 或者 &lt;code&gt;JRE_HOME&lt;/code&gt; 的环境变量，如果没有设置则会在控制台打印对应的信息。&lt;/p&gt;
&lt;p&gt;接下来是有关于 &lt;code&gt;CLASSPATH&lt;/code&gt; 的设置和校验，然后是一堆变量的设置和校验，无需关注，接着使用 &lt;code&gt;echo&lt;/code&gt; 打印了一些信息：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;echo Using CATALINA_BASE:   &quot;%CATALINA_BASE%&quot;
echo Using CATALINA_HOME:   &quot;%CATALINA_HOME%&quot;
echo Using CATALINA_TMPDIR: &quot;%CATALINA_TMPDIR%&quot;
if &quot;&quot;%1&quot;&quot; == &quot;&quot;debug&quot;&quot; goto use_jdk
echo Using JRE_HOME:        &quot;%JRE_HOME%&quot;
goto java_dir_displayed
:use_jdk
echo Using JAVA_HOME:       &quot;%JAVA_HOME%&quot;
:java_dir_displayed
echo Using CLASSPATH:       &quot;%CLASSPATH%&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;各种比较重要的变量在这里进行了一些打印，接下来又设置了一些比较重要的变量：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;set _EXECJAVA=%_RUNJAVA%
set MAINCLASS=org.apache.catalina.startup.Bootstrap
set ACTION=start
set SECURITY_POLICY_FILE=
set DEBUG_OPTS=
set JPDA=
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的 &lt;code&gt;_EXECJAVA&lt;/code&gt; 实际上是我们在 &lt;code&gt;JAVA_HOME&lt;/code&gt; 或者是 &lt;code&gt;JRE_HOME&lt;/code&gt; 中 bin 下面的 &lt;code&gt;java.exe&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;这里出现的 &lt;code&gt;_RUNJAVA&lt;/code&gt; 变量，是在上面的 &lt;code&gt;setclasspath.bat&lt;/code&gt; 那个脚本中进行设置的。&lt;/p&gt;
&lt;p&gt;而这个 &lt;code&gt;MAINCLASS&lt;/code&gt; 的值是 &lt;code&gt;org.apache.catalina.startup.Bootstrap&lt;/code&gt; ，这个是我们第一篇文章启动 Tomcat 时候的那个类，不知道各位还有印象不。&lt;/p&gt;
&lt;p&gt;接下来设置了一个变量 &lt;code&gt;ACTION&lt;/code&gt; 的动作时 &lt;code&gt;start&lt;/code&gt; ，用屁股想想应该是启动的意思。&lt;/p&gt;
&lt;p&gt;然后对参数进行了一次判断：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;if &quot;&quot;%1&quot;&quot; == &quot;&quot;debug&quot;&quot; goto doDebug
if &quot;&quot;%1&quot;&quot; == &quot;&quot;run&quot;&quot; goto doRun
if &quot;&quot;%1&quot;&quot; == &quot;&quot;start&quot;&quot; goto doStart
if &quot;&quot;%1&quot;&quot; == &quot;&quot;stop&quot;&quot; goto doStop
if &quot;&quot;%1&quot;&quot; == &quot;&quot;configtest&quot;&quot; goto doConfigTest
if &quot;&quot;%1&quot;&quot; == &quot;&quot;version&quot;&quot; goto doVersion
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果没有其他参数做覆盖，这里的参数就是上面设置的 &lt;code&gt;start&lt;/code&gt; ，直接跳转到最后的 &lt;code&gt;doStart&lt;/code&gt; 去了，不过可以看到， Tomcat 启动可以接受的参数有 &lt;code&gt;debug&lt;/code&gt; , &lt;code&gt;run&lt;/code&gt; , &lt;code&gt;start&lt;/code&gt; , &lt;code&gt;stop&lt;/code&gt; , &lt;code&gt;configtest&lt;/code&gt; 和 &lt;code&gt;version&lt;/code&gt; ，我们平时在 IDE 工具里用的比较多的应该有 &lt;code&gt;debug&lt;/code&gt; , &lt;code&gt;run&lt;/code&gt; , &lt;code&gt;start&lt;/code&gt; , &lt;code&gt;stop&lt;/code&gt; , 剩下的两个至少我是基本上没有使用过，如果不是今天看到这里了，我都不知道 Tomcat 还能有 &lt;code&gt;configtest&lt;/code&gt; 和 &lt;code&gt;version&lt;/code&gt; 这两个参数。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;:doDebug
shift
set _EXECJAVA=%_RUNJDB%
set DEBUG_OPTS=-sourcepath &quot;%CATALINA_HOME%\..\..\java&quot;
if not &quot;&quot;%1&quot;&quot; == &quot;&quot;-security&quot;&quot; goto execCmd
shift
echo Using Security Manager
set &quot;SECURITY_POLICY_FILE=%CATALINA_BASE%\conf\catalina.policy&quot;
goto execCmd

:doRun
shift
if not &quot;&quot;%1&quot;&quot; == &quot;&quot;-security&quot;&quot; goto execCmd
shift
echo Using Security Manager
set &quot;SECURITY_POLICY_FILE=%CATALINA_BASE%\conf\catalina.policy&quot;
goto execCmd

:doStart
shift
if &quot;%TITLE%&quot; == &quot;&quot; set TITLE=Tomcat
set _EXECJAVA=start &quot;%TITLE%&quot; %_RUNJAVA%
if not &quot;&quot;%1&quot;&quot; == &quot;&quot;-security&quot;&quot; goto execCmd
shift
echo Using Security Manager
set &quot;SECURITY_POLICY_FILE=%CATALINA_BASE%\conf\catalina.policy&quot;
goto execCmd
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面这一段就是我们最常用的三种启动方式，从脚本上来看， &lt;code&gt;debug&lt;/code&gt; 比 &lt;code&gt;run&lt;/code&gt; 单纯的多设置了两个变量 &lt;code&gt;_EXECJAVA&lt;/code&gt; 和 &lt;code&gt;DEBUG_OPTS&lt;/code&gt; ，而 &lt;code&gt;start&lt;/code&gt; 则是多了一个 &lt;code&gt;TITLE&lt;/code&gt; 的判断。&lt;/p&gt;
&lt;p&gt;接着往下看，基本上就已经到了这个脚本的最底部，这里执行了一句话，也是核心的一句话：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;%_EXECJAVA% %CATALINA_LOGGING_CONFIG% %LOGGING_MANAGER% %JAVA_OPTS% %CATALINA_OPTS% %DEBUG_OPTS% -D%ENDORSED_PROP%=&quot;%JAVA_ENDORSED_DIRS%&quot; -classpath &quot;%CLASSPATH%&quot; -Dcatalina.base=&quot;%CATALINA_BASE%&quot; -Dcatalina.home=&quot;%CATALINA_HOME%&quot; -Djava.io.tmpdir=&quot;%CATALINA_TMPDIR%&quot; %MAINCLASS% %CMD_LINE_ARGS% %ACTION%
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;_EXECJAVA&lt;/code&gt; 是我们刚才说的那个 &lt;code&gt;java.exe&lt;/code&gt; ，然后是各种运行时参数和系统属性，最后面的 &lt;code&gt;MAINCLASS&lt;/code&gt; ，也就是 &lt;code&gt;org.apache.catalina.startup.Bootstrap&lt;/code&gt; ，接着是 &lt;code&gt;CMD_LINE_ARGS&lt;/code&gt; ，这也是一个命令参数，就是 &lt;code&gt;main&lt;/code&gt; 方法上的那个 &lt;code&gt;args&lt;/code&gt; 参数，最后一个参数是 &lt;code&gt;ACTION&lt;/code&gt; 也就是 &lt;code&gt;start&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;最后归根结底就是一句话，执行 &lt;code&gt;Bootstrap&lt;/code&gt; 里面的 &lt;code&gt;main&lt;/code&gt; 方法，别看这些个脚本写了一大堆，主要工作就是在校验环境配置以及一些基础系统设置和一些运行时参数的设置。&lt;/p&gt;
&lt;h2 id=&quot;4-小结&quot;&gt;4 小结&lt;/h2&gt;
&lt;p&gt;脚本整体来讲不难，而且每段脚本上面都已经有了简单的英文注释，简明扼要的写清楚了这一段脚本在做什么，稍微了解一些基础的 DOS 命令，都可以进行阅读。&lt;/p&gt;
&lt;p&gt;至于其他的脚本可以大致浏览下，基本上兜兜转转最后还是会回到 &lt;code&gt;catalina.bat&lt;/code&gt; 这个脚本，而在这个脚本中，最后肯定会执行 &lt;code&gt;Bootstrap&lt;/code&gt; 里面的 &lt;code&gt;main&lt;/code&gt; 方法。&lt;/p&gt;
&lt;p&gt;在 Windows 系统中，使用的是 bat 脚本，在 Linux 系统中，就会使用 sh 脚本，这个本质上没有什么大的差别，整体原理都是一样的，有兴趣的同学可以自己研究下 sh 脚本，就当学 shell 语法了。&lt;/p&gt;
</description>
<pubDate>Fri, 18 Sep 2020 00:53:00 +0000</pubDate>
<dc:creator>极客挖掘机</dc:creator>
<og:description>1 Tomcat 基本知识 首先介绍一些 Tomcat 的基本知识，防止有纯小白看的云里雾里的。 下面这张图是一个下载好二进制版的的 Tomcat ，直接解压得到的，虽然版本是 9.x ，但是这个目录</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/babycomeon/p/13689281.html</dc:identifier>
</item>
<item>
<title>数据库：浅谈DML、DDL、DCL的区别 - 谁主沉浮oo7</title>
<link>http://www.cnblogs.com/feifuzeng/p/13626463.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/feifuzeng/p/13626463.html</guid>
<description>&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;SQL是一个标准的数据库语言，是面向集合的描述性非过程化语言。它功能强，效率高，简单易学易维护（迄今为止，我还没见过比它还好学的语言）。然而SQL语言由于以上优点，同时也出现了这样一个问题：它是非过程性语言，即大多数语句都是独立执行的，与上下文无关，而绝大部分应用都是一个完整的过程，显然用SQL完全实现这些功能是很困难的。&lt;/p&gt;
&lt;p&gt;所以大多数数据库公司为了解决此问题，作了如下两方面的工作：&lt;/p&gt;
&lt;ol readability=&quot;-1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;扩充SQL，在SQL中引入过程性结构；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;把SQL嵌入到高级语言中，以便一起完成一个完整的应用。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;sql语言的分类&quot;&gt;SQL语言的分类&lt;/h2&gt;
&lt;p&gt;SQL语言共分为四大类：数据查询语言DQL，数据操纵语言DML，数据定义语言DDL，数据控制语言DCL。&lt;/p&gt;
&lt;h3 id=&quot;dql&quot;&gt;DQL&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;DML（data query language）数据查询语言&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;数据查询语言DQL基本结构是由SELECT子句，FROM子句，WHERE&lt;br/&gt;子句组成的查询块：&lt;br/&gt;SELECT &amp;lt;字段名表&amp;gt;&lt;br/&gt;FROM &amp;lt;表或视图名&amp;gt;&lt;br/&gt;WHERE &amp;lt;查询条件&amp;gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;SELECT 列名称 FROM 表名称
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;dml&quot;&gt;DML&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;DML（data manipulation language）数据操纵语言&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;就是我们最经常用到的 UPDATE、INSERT、DELETE。 主要用来对数据库的数据进行一些操作。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;UPDATE 表名称 SET 列名称 = 新值 WHERE 列名称 = 某值
INSERT INTO table_name (列1, 列2,...) VALUES (值1, 值2,....)
DELETE FROM 表名称 WHERE 列名称 = 值
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;ddl&quot;&gt;DDL&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;DDL（data definition language）数据库定义语言&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其实就是我们在创建表的时候用到的一些sql，比如说：CREATE、ALTER、DROP等。DDL主要是用在定义或改变表的结构，数据类型，表之间的链接和约束等初始化工作上&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;CREATE TABLE 表名称
(
列名称1 数据类型,
列名称2 数据类型,
列名称3 数据类型,
....
)

ALTER TABLE table_name
ALTER COLUMN column_name datatype

DROP TABLE 表名称
DROP DATABASE 数据库名称
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;dcl&quot;&gt;DCL&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;DCL（Data Control Language）数据库控制语言&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;是用来设置或更改数据库用户或角色权限的语句，包括（grant,deny,revoke等）语句。这个比较少用到。&lt;/p&gt;
&lt;h3 id=&quot;结语&quot;&gt;结语&lt;/h3&gt;
&lt;p&gt;欢迎关注微信公众号『码仔zonE』，专注于分享Java、云计算相关内容，包括SpringBoot、SpringCloud、微服务、Docker、Kubernetes、Python等领域相关技术干货，期待与您相遇！&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/908629/202008/908629-20200819141402537-1758432824.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 18 Sep 2020 00:50:00 +0000</pubDate>
<dc:creator>谁主沉浮oo7</dc:creator>
<og:description>简介 SQL是一个标准的数据库语言，是面向集合的描述性非过程化语言。它功能强，效率高，简单易学易维护（迄今为止，我还没见过比它还好学的语言）。然而SQL语言由于以上优点，同时也出现了这样一个问题：它是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/feifuzeng/p/13626463.html</dc:identifier>
</item>
<item>
<title>我在项目内使用了设计模式后，同事直呼看不懂 - _tom</title>
<link>http://www.cnblogs.com/doNetTom/p/13685988.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/doNetTom/p/13685988.html</guid>
<description>&lt;p&gt;&lt;span&gt;　　一切抛开业务的设计，都是扯淡！在项目中有个我们会对多个接口进行多业务逻辑判断，项目开始工期紧，所以先以实现功能为主，最近打算优化一番，一开始的代码是这样的&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; checkProjectAdd(List&amp;lt;OrderDetail&amp;gt;&lt;span&gt; list) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;CollectionUtils.isEmpty(list)) {
            orderService.check(list);
            stockService.check(list);
            orderAddress.check(list);
            userScoreService.check(list);
            activityService.check(list);
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.check();
        }
        excute();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; 　  虽然对检查类的方法做了简单的封装，但在好多地方可能会存在重复的判断，比如订单提交，加入购物车等等，冗余代码随处可见，且不易扩展。在此情形下，废话不多说，准备开干，先来分析分析业务，因为我们的各个检查接口的处理原则是要保证顺序性的，而在检查的过程中可能根据商品提交参数而实质去动态改变list参数中的内容，比如一个库存当两个卖，用户会员等级结合实际商品数判断能否享受折扣等等，所以每一级的检查或手动处理值都是要求检查类代码&lt;span&gt;&lt;strong&gt;执行顺序&lt;/strong&gt;&lt;/span&gt;，思前想后，想起曾在阅读mybatis源码时觉得其设计的plugins模式很适合此类场景，于是决定使用《责任链模式》来进行这一次代码的优化。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　首先简单介绍一下什么是责任链，说到链，大家就能想到链表，这里我们只说最简单的链表（单向链表）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/426186/202009/426186-20200917165722813-818386152.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 　　单向链表就是当前对象内存储着下一个对象的引用地址，责任链模式的概念也描述下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;责任链模式（Chain of Responsibility Pattern）为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。这种类型的设计模式属于行为型模式。在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;em&gt;　　概念都是标准，一般都很难理解是什么意思，我们拿图说事&lt;br/&gt;&lt;/em&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;em&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/426186/202009/426186-20200917171723020-1441429016.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/em&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 　　这每一层都是大哥，想要跨过难关还是不太容易呀。但是没办法为了要干真正的实事还是要一关一关闯的，接下来我们要开始进行包装，AOP大家都知道（面向切面），既然我们最终的提交方法是excute，那切面就是excute了，在切面之前如何执行自定义的Interceptor（拦截器）呢？这里我是用的是jdk动态代理模式，动态代理，不太了解的看这里（&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/zuidongfeng/p/8735241.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;JDK动态代理&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;），使用动态代理的好处是我们可以对成百上千个已知与将来可能要编写的接口进行包装，比如我的订单提交事件叫做submitOrder，加入购车addCart，我都可以通过我的代理模式对这些接口进行包装，在代理模式中我规定好Interceptor，这样就能统一了&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;em&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/426186/202009/426186-20200917173457078-275916411.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt; 　　通过一级一级的代理模型，最终我们才能真正调用到IOrderService的具体实现上，废话不多说，开始撸代码&lt;/p&gt;
&lt;p&gt;　　首先定义好我们自己拦截器类&lt;em id=&quot;__mceDel&quot;&gt;　　&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Interceptor {
    Object intercept(Invocation invocation) &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InvocationTargetException, IllegalAccessException;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　接下来代理工厂：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ProxyFactory &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; InvocationHandler {


    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Object target;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Interceptor interceptor;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; ProxyFactory(Object target, Interceptor interceptor) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.target =&lt;span&gt; target;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.interceptor =&lt;span&gt; interceptor;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Object wrap(Object target, Interceptor filter) {

        ProxyFactory proxyFactory &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ProxyFactory(target, filter);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Proxy.newProxyInstance(
                target.getClass().getClassLoader(),
                target.getClass().getInterfaces(), proxyFactory);

    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Object invoke(Object proxy, Method method, Object[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable {
        Invocation invocation &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Invocation(target, method, args);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; interceptor.intercept(invocation);
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　代理工厂主要就是对目标对象target进行包装，这里的target可能是原对象，也有可能是包装过后代理对象二次包装代理，简单来说是这样，我们的IOrderService中的submitOrder方法，在托管给JDK动态代理后，为了实现责任链的链式原则，我们会基于此对象再次调用wrap方法进行二次包装，将我们的各式各样的拦截器一层一层的包装上去，这样处理成上一级引用下一级的链式关系。&lt;/p&gt;
&lt;p&gt;　　接下来定义我们具体都又那些拦截器大哥&lt;em id=&quot;__mceDel&quot;&gt;　　&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; TodoInterceptor &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Interceptor {
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Object intercept(Invocation invocation) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InvocationTargetException, IllegalAccessException {
        System.out.println(&lt;/span&gt;&quot; todo something &quot;&lt;span&gt;);
        Object result &lt;/span&gt;=&lt;span&gt; invocation.proceed();
        System.out.println(&lt;/span&gt;&quot; to do end something &quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
    }
}


&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; LogInterceptor &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Interceptor {
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Object intercept(Invocation invocation) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InvocationTargetException, IllegalAccessException {
        System.out.println(&lt;/span&gt;&quot; do log &quot;&lt;span&gt;);
        Object result &lt;/span&gt;=&lt;span&gt; invocation.proceed();
        System.out.println(&lt;/span&gt;&quot; do log &quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　两位拦路大哥已再此，接下来我们吧拦路大哥们放入工厂进行包装&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; checkSubmitOrder() {
        IOrderService orderService &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; OrderService();
        orderService &lt;/span&gt;= (IOrderService) ProxyFactory.wrap(orderService, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LogInterceptor());
        orderService &lt;/span&gt;= (IOrderService) ProxyFactory.wrap(orderService, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TodoInterceptor());
        orderService.submitOrder();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　代码执行效果如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/426186/202009/426186-20200917175305932-1343598756.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　例子挺简单的，主要是说明责任链可以使用的场景，结合此责任链的扩展就非常多了，例如我把拦截器统一交给spring 托管，在每个检查方法上自定义注解，标记需要执行的拦截器，在AOP切面扫描业务方法时，判断是否存在此类责任链的拦截注解，有的话则执行业务判断，这样子就统一了业务检查代码的封装，再也不用再每行代码里写那些重复的chek()了，介于篇幅，就不在过多介绍了，有兴趣可以私聊我。&lt;/p&gt;

&lt;blockquote data-tool=&quot;mdnice编辑器&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;我是tom：一切的恐惧都源于自己的未知。&lt;/p&gt;

&lt;/blockquote&gt;

</description>
<pubDate>Fri, 18 Sep 2020 00:46:00 +0000</pubDate>
<dc:creator>_tom</dc:creator>
<og:description>一切抛开业务的设计，都是扯淡！在项目中有个我们会对多个接口进行多业务逻辑判断，项目开始工期紧，所以先以实现功能为主，最近打算优化一番，一开始的代码是这样的 public void checkProje</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/doNetTom/p/13685988.html</dc:identifier>
</item>
<item>
<title>知识全聚集 .Net Core  技术突破 | 如何实现一个模块化方案一 - 初久的私房菜</title>
<link>http://www.cnblogs.com/HDONG/p/13689123.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/HDONG/p/13689123.html</guid>
<description>&lt;p&gt;模块化的介绍一共2篇&lt;/p&gt;
&lt;p&gt;这一篇我们实现一个功能非常简单的StartupModules模块化。&lt;/p&gt;
&lt;p&gt;第二篇我们来实现一个ABP的模块化效果。&lt;/p&gt;

&lt;p&gt;其实来简单想一下模块化的实验思路，写个接口=&amp;gt;模块类继承该接口=&amp;gt;项目启动反射检索=&amp;gt;调用接口实现。&lt;br/&gt;那么具体到代码实践应该怎么写呢。&lt;/p&gt;

&lt;h3 id=&quot;第一步&quot;&gt;第一步&lt;/h3&gt;
&lt;p&gt;第一步就是写一个模块化接口类的嘛！&lt;br/&gt;新建类 IStartupModule&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://git.imweb.io/hdong/ImageBed/raw/master/StartModularImages/20200917142221.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后写一个反射检索全文谁继承了这个接口的方法&lt;br/&gt;新建类 StartupModulesOptions&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://git.imweb.io/hdong/ImageBed/raw/master/StartModularImages/20200917144454.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://git.imweb.io/hdong/ImageBed/raw/master/StartModularImages/20200917144539.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代码解释： Activator.CreateInstance 与指定参数匹配程度最高的构造函数来创建指定类型的实例&lt;br/&gt;ps：白话文就是，你给我Type我给你创建个对应的实例&lt;br/&gt;更一个有意思的是 Assembly.GetEntryAssembly()! 这个! 是不是很好奇怕&lt;br/&gt;ps：我第一次看到这个语法也蒙了，问了好多人大家都没用过，这个语法同TS中的断言，是非null类型断言，意思就是我断言我这个方法返回的内容绝对不是null。&lt;/p&gt;
&lt;h3 id=&quot;第二步&quot;&gt;第二步&lt;/h3&gt;
&lt;p&gt;到这里来看我们是不是已经拿到了所有继承接口的模块那么怎么在该调用的地方调用呢，缺啥写啥&lt;br/&gt;&lt;img src=&quot;https://git.imweb.io/hdong/ImageBed/raw/master/StartModularImages/20200917150845.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;第三步&quot;&gt;第三步&lt;/h3&gt;
&lt;p&gt;运行代码也有了，我该怎么调用呢。&lt;br/&gt;接下来只要在 在Program 的 WebHost 调用.UseStartupModules() 流程就可以加载我们的 ConfigureServices 了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://git.imweb.io/hdong/ImageBed/raw/master/StartModularImages/20200917153039.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;中间来插播一下&quot;&gt;中间来插播一下&lt;/h4&gt;
&lt;p&gt;请让我掏出来一个器大的东西来说 他就是： &lt;code&gt;IStartupFilter&lt;/code&gt; ，这个东西是个啥东西呢。来看一段源码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;namespace Microsoft.AspNetCore.Hosting
{
    public interface IStartupFilter
    {
        Action&amp;lt;IApplicationBuilder&amp;gt; Configure(Action&amp;lt;IApplicationBuilder&amp;gt; next);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里我们看到了 Configure 他返回一个 IApplicationBuilder 他是怎么用的呢&lt;br/&gt;我们新建一个空的Web项目的时候不知道有没有注意过 UseStaticFiles 这个函数&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; public void Configure(IApplicationBuilder app)
        {
            app.UseStaticFiles();
            app.UseRouting();

            app.UseEndpoints(endpoints =&amp;gt;
            {
                endpoints.MapControllerRoute(&quot;default&quot;, &quot;{controller=Home}/{action=Index}/{id?}&quot;);
            });
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这个方法中，你可以直接使用方法提供的IApplicationBuilder参数，并且可以向其中添加各种中间件。使用IStartupFilter, 你可以指定并返回一个Action类型的泛型委托，这意味你除了可以使用方法提供的泛型委托配置IApplicationBuilder对象， 还需要返回一个泛型委托。&lt;/p&gt;
&lt;p&gt;我们来看一段代码 Build(); 这个会调用BuildApplication方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Program
{
    public static void Main(string[] args)
    {
        var host = new WebHostBuilder()
            .UseKestrel()    
            .UseContentRoot(Directory.GetCurrentDirectory())
            .UseStartup&amp;lt;Startup&amp;gt;()
            .Build();

        host.Run(); 
    }
}

private RequestDelegate BuildApplication()
{
    ..
    IApplicationBuilder builder = builderFactory.CreateBuilder(Server.Features);
    builder.ApplicationServices = _applicationServices;

    var startupFilters = _applicationServices.GetService&amp;lt;IEnumerable&amp;lt;IStartupFilter&amp;gt;&amp;gt;();
    Action&amp;lt;IApplicationBuilder&amp;gt; configure = _startup.Configure;
    foreach (var filter in startupFilters.Reverse())
    {
        configure = filter.Configure(configure);
    }

    configure(builder);

    return builder.Build();
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先，此方法创建IApplicationBuilder的实例，该实例将用于构建中间件管道，并将ApplicationServices设置为已配置的DI容器。&lt;br/&gt;接下来的代码块很意思。首先，从DI容器中获取了一个集合&lt;code&gt;IEnumerable&amp;lt;IStartupFilter&amp;gt;&lt;/code&gt;&lt;br/&gt;我们可以配置多个IStartupFilter来形成一个管道，所以这个方法只是从容器中取出它们。&lt;br/&gt;现在我们通过循环遍历每个IStartupFilter（以相反的顺序），传入Startup.Configure方法，然后更新局部变量configure来创建Configure方法的管道。&lt;/p&gt;
&lt;h3 id=&quot;第四步&quot;&gt;第四步&lt;/h3&gt;
&lt;p&gt;我们自己如何来实现 一个IStartupFilter 让他帮我们调用 Configure。&lt;br/&gt;&lt;img src=&quot;https://git.imweb.io/hdong/ImageBed/raw/master/StartModularImages/20200917175810.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;第五步&quot;&gt;第五步&lt;/h3&gt;
&lt;p&gt;在 WebHostBuilderExtensions类 UseStartupModules 方法 ConfigureServices 下用 IStartupFilter 注入实现&lt;br/&gt;这样在Build() 的时候就会调用模块的方法了&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ActivatorUtilities.CreateInstance&amp;lt;ModulesStartupFilter&amp;gt;(sp, runner) // 第二个参数是在创建实例的时候 给构造函数注入的第一个参数
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://git.imweb.io/hdong/ImageBed/raw/master/StartModularImages/20200917180105.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;测试一下&quot;&gt;测试一下&lt;/h3&gt;
&lt;h5 id=&quot;新建-core-web项目-在-programcs&quot;&gt;新建 Core Web项目 在 Program.cs&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt; Host.CreateDefaultBuilder(args)
 .ConfigureWebHostDefaults(webBuilder =&amp;gt;
    {
         // 进行模块映射
         webBuilder.UseStartupModules().UseStartup&amp;lt;Startup&amp;gt;();
});
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://git.imweb.io/hdong/ImageBed/raw/master/StartModularImages/20200917181322.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;在-startupcs---configureservices和configure-下打一个-consolewriteline&quot;&gt;在 Startup.cs ConfigureServices和Configure 下打一个 Console.WriteLine&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://git.imweb.io/hdong/ImageBed/raw/master/StartModularImages/20200917181558.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;新建-类-hangfirestartupmodule-继承-istartupmodule&quot;&gt;新建 类 HangfireStartupModule 继承 IStartupModule&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;public class HangfireStartupModule : IStartupModule
{
        public void ConfigureServices(IServiceCollection services)
        {
            Console.WriteLine(&quot;HangfireStartupModule----ConfigureServices&quot;);
        }
        public void Configure(IApplicationBuilder app)
        {
            Console.WriteLine(&quot;HangfireStartupModule----Configure&quot;);
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;结果&quot;&gt;结果&lt;/h5&gt;
&lt;p&gt;一个非常简单的模块化就完工了，当然这个是基础版本，只能拿来借鉴思路学习下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://git.imweb.io/hdong/ImageBed/raw/master/StartModularImages/20200917181252.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;补充模块的-configureservices-和-configure-传递上下文&quot;&gt;补充模块的 ConfigureServices 和 Configure 传递上下文&lt;/h3&gt;
&lt;p&gt;新建类 ConfigureServicesContext 和 ConfigureMiddlewareContext&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  public class ConfigureMiddlewareContext
    {
        public ConfigureMiddlewareContext(IConfiguration configuration, IWebHostEnvironment hostingEnvironment, IServiceProvider serviceProvider, StartupModulesOptions options)
        {
            Configuration = configuration;
            HostingEnvironment = hostingEnvironment;
            ServiceProvider = serviceProvider;
            Options = options;
        }

        public IConfiguration Configuration { get; }

        public IWebHostEnvironment HostingEnvironment { get; }
        public IServiceProvider ServiceProvider { get; }

        public StartupModulesOptions Options { get; }
    }

    public class ConfigureServicesContext
    {
        public ConfigureServicesContext(IConfiguration configuration, IWebHostEnvironment hostingEnvironment, StartupModulesOptions options)
        {
            Configuration = configuration;
            HostingEnvironment = hostingEnvironment;
            Options = options;
        }

        public IConfiguration Configuration { get; }
        public IWebHostEnvironment HostingEnvironment { get; }
        public StartupModulesOptions Options { get; }
    }

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改 StartupModuleRunner 的方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; public void ConfigureServices(IServiceCollection services, IConfiguration configuration, IWebHostEnvironment hostingEnvironment)
        {
            var ctx = new ConfigureServicesContext(configuration, hostingEnvironment, _options);
            foreach (var cfg in _options.StartupModules)
            {
                cfg.ConfigureServices(services, ctx);
            }
        }

        public void Configure(IApplicationBuilder app, IConfiguration configuration, IWebHostEnvironment hostingEnvironment)
        {
            using (var scope = app.ApplicationServices.CreateScope()) {
                var ctx = new ConfigureMiddlewareContext(configuration, hostingEnvironment, scope.ServiceProvider, _options);

                foreach (var cfg in _options.StartupModules)
                {
                    cfg.Configure(app, ctx);
                }
            }
               
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://git.imweb.io/hdong/ImageBed/raw/master/StartModularImages/20200917185508.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;h3 id=&quot;玩双截棍的熊猫、netcore-大黄瓜&quot;&gt;玩双截棍的熊猫、NETCore-大黄瓜&lt;/h3&gt;
&lt;h3 id=&quot;思路来源：httpsgithubcomhenkmollemastartupmodules&quot;&gt;思路来源：&lt;a href=&quot;https://github.com/henkmollema/StartupModules&quot;&gt;https://github.com/henkmollema/StartupModules&lt;/a&gt;&lt;/h3&gt;
</description>
<pubDate>Fri, 18 Sep 2020 00:43:00 +0000</pubDate>
<dc:creator>初久的私房菜</dc:creator>
<og:description>简介 模块化的介绍一共2篇 这一篇我们实现一个功能非常简单的StartupModules模块化。 第二篇我们来实现一个ABP的模块化效果。 思考 其实来简单想一下模块化的实验思路，写个接口=&amp;amp;</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/HDONG/p/13689123.html</dc:identifier>
</item>
<item>
<title>Java使用ObjectMapper的简单示例 - 学海无涯519</title>
<link>http://www.cnblogs.com/wgx519/p/13688615.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wgx519/p/13688615.html</guid>
<description>&lt;h2&gt;一、什么是ObjectMapper?&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;ObjectMapper类是Jackson库的主要类，它提供一些功能将数据集或对象转换的实现。&lt;/li&gt;
&lt;li&gt;它将使用JsonParser和JsonGenerator实例来实现JSON的实际读/写。&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;二、ObjectMapper怎么使用？&lt;/h2&gt;
&lt;h3&gt;2.1 配置&lt;/h3&gt;
&lt;h4&gt;2.1.1 普通Java项目（引入如下依赖即可）&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.fasterxml.jackson.core&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;jackson-databind&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;2.9.5&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
 
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-core &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.fasterxml.jackson.core&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;jackson-core&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;2.9.5&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
 
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-annotations &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.fasterxml.jackson.core&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;jackson-annotations&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;2.9.5&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;2.1.2 Sring Boot项目&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;重要说明&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;　　由于Spring Boot的自动配置JacksonAutoConfiguration中有如下图所示的依赖引入和配置，所以不需要我们额外配置&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2153469/202009/2153469-20200917231259846-1842788510.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2153469/202009/2153469-20200917231431840-31508886.png&quot; alt=&quot;&quot; width=&quot;1008&quot; height=&quot;435&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;2.2 实战&lt;/h3&gt;
&lt;p&gt; &lt;strong&gt;User类&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;@Data
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; @EqualsAndHashCode(callSuper = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; @Accessors(chain = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; User &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Serializable {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; serialVersionUID = 1L&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 姓名&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 性别&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String sex;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 年龄&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Integer age;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;2.2.1 Java对象、集合转JSON&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;         ObjectMapper objectMapper = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ObjectMapper();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;         User user = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; User();
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         user.setName(&quot;张三&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         user.setAge(20&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         user.setSex(&quot;男&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;         List&amp;lt;User&amp;gt; userList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        userList.add(user);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对象转换为JSON&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;         String userJsonString =&lt;span&gt; objectMapper.writeValueAsString(user);&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 集合转换为JSON&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;         String userListJsonString =&lt;span&gt; objectMapper.writeValueAsString(userList);&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;2.2.2 JSON转Java对象、集合&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; 　　　　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt; JOSN转对象（java对象）&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;         User newUser = objectMapper.readValue(userJsonString, User.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; 
&lt;span&gt;4&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; JOSN转集合（集合）&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt;         List&amp;lt;User&amp;gt; list = objectMapper.readValue(userListJsonString, &lt;span&gt;new&lt;/span&gt; TypeReference&amp;lt;List&amp;lt;User&amp;gt;&amp;gt;(){});
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;2.2.3 json转JsonNode、ObjectNode&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;Jackson的JsonNode和ObjectNode两个类，前者是不可变的，一般用于读取。后者可变，一般用于创建Json对象图。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; 　　　　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt; json转JsonNode&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;         JsonNode jsonNode =&lt;span&gt; objectMapper.readTree(userJsonString);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         String sex = jsonNode.get(&quot;sex&quot;&lt;span&gt;).asText();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; JsonNode转ObjectNode&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;         ObjectNode objectNode =&lt;span&gt; (ObjectNode)jsonNode;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; json转JsonNode&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;         JsonNode jsonNodeList =&lt;span&gt; objectMapper.readTree(userListJsonString);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; JsonNode转ObjectNode&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;         ArrayNode arrayNode = (ArrayNode)jsonNodeList;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt; 2.2.4 jsonNode转对象、集合&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; 　　　　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt; jsonNode转为json字符串&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;         String jsonNodeString =&lt;span&gt; objectMapper.writeValueAsString(jsonNode);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         String jsonNodeListString =&lt;span&gt; objectMapper.writeValueAsString(jsonNodeList);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; 
&lt;span&gt;5&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; json字符串转对象、集合&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt;         User user1 = objectMapper.readValue(jsonNodeString, User.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;         List&amp;lt;User&amp;gt; list1 = objectMapper.readValue(jsonNodeListString, &lt;span&gt;new&lt;/span&gt; TypeReference&amp;lt;List&amp;lt;User&amp;gt;&amp;gt;() {});
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt; 2.3 注意事项&lt;/h3&gt;
&lt;h4&gt;2.3.1 &lt;strong&gt;微服务&lt;/strong&gt;中从&lt;strong&gt;其他服务&lt;/strong&gt;获取过来的对象，如果从Object强转为自定义的类型会报错，利用ObjectMapper转换。&lt;/h4&gt;
&lt;p&gt;正确示例：&lt;/p&gt;
&lt;p&gt;　　说明：Schedule类、OutpOrderBill类都是类似于User类的Java对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对象&lt;/span&gt;
Schedule schedule = objectMapper.convertValue(callNurseCenterService.getSchedule(registRecord.getScheCode()).getData(), Schedule.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 泛型为对象的集合&lt;/span&gt;
List&amp;lt;OutpOrderBill&amp;gt; outpOrderBillList =&lt;span&gt; objectMapper.convertValue(
                            callChargeCenterService.getOrderBillByOrderCode(orders.getOrgCode(),orders.getOrderCode()).getData(), 
                            &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; TypeReference&amp;lt;List&amp;lt;OutpOrderBill&amp;gt;&amp;gt;() {});
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt; 2.3.2 上面转换的过程中，如果返回的字段你不是都需要，需要忽略其中的几个字段，在自定义的类中添加标红注解&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;@Data
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; @EqualsAndHashCode(callSuper = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; @Accessors(chain = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;@JsonIgnoreProperties(ignoreUnknown = true)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; User  &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Serializable {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; serialVersionUID = 1L&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;      &lt;span&gt;////&lt;/span&gt;&lt;span&gt;提供有这个参数，但是不想获取
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 姓名
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    private String name;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 性别&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String sex;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 年龄&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Integer age;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;em&gt;如果不想添加注解，可以使用下面两种方式&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37.5&quot;&gt;
&lt;pre readability=&quot;8&quot;&gt;
第一种方式：&lt;p&gt;ObjectMapper mapper = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ObjectMapper().setVisibility(JsonMethod.FIELD,Visibility.ANY);&lt;br/&gt;mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;);
&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre readability=&quot;7&quot;&gt;
第二种方式：&lt;p&gt;ObjectMapper objectMapper = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ObjectMapper();&lt;br/&gt;mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;);
&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;2.3.3 在转换的过程中，有可能有的属性被设成空就不序列化等的需求，可以在类的属性上或直接在类上加上一下注解。用在属性上就是只针对一个属性，用在类上就是针对类里的所有属性。&lt;em&gt;&lt;br/&gt;&lt;/em&gt;&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@JsonInclude(Include.NON_NULL) 

@JsonInclude(Include.Include.ALWAYS) 默认 

@JsonInclude(Include.NON_DEFAULT) 属性为默认值不序列化 

@JsonInclude(Include.NON_EMPTY) 属性为 空（“”） 或者为 NULL 都不序列化 

@JsonInclude(Include.NON_NULL) 属性为NULL 不序列化 &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;em id=&quot;__mceDel&quot;&gt; &lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参考网址：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;a href=&quot;https://tool.oschina.net/uploads/apidocs/jackson-1.9.9/overview-summary.html&quot; target=&quot;_blank&quot;&gt;Jackson-1.9.9在线文档&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 18 Sep 2020 00:29:00 +0000</pubDate>
<dc:creator>学海无涯519</dc:creator>
<og:description>一、什么是ObjectMapper? ObjectMapper类是Jackson库的主要类，它提供一些功能将数据集或对象转换的实现。 它将使用JsonParser和JsonGenerator实例来实现</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wgx519/p/13688615.html</dc:identifier>
</item>
<item>
<title>一代巨星的陨落！ - 码农田小齐</title>
<link>http://www.cnblogs.com/nycsde/p/13689088.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nycsde/p/13689088.html</guid>
<description>&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;em&gt;这里是《齐姐聊大厂》系列的第 6 篇&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;（前 5 篇见文末）&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;每周五早上 8 点，与你唠唠大厂的那些事。&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小齐说：&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2016 年 7 月 25 日，Verizon 最终敲定以 48 亿美金收购雅虎的核心资产，与之前收购的 AOL 合并，成立名为 Oath 的公司，后更名为 Verizon Media。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;雅虎的剩余业务更名为 Altaba Inc，CEO - Marissa Mayer 在收购完成之后退出董事会。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作为昔日互联网的巨头，创立于 1994 年的雅虎两年后便在华尔街上市。在那个年代，雅虎的搜索业务无人能及，并且还首创在搜索中插入广告来盈利，这种盈利模式让它在短短几年之内实现了市值的成倍增长。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;于是，雅虎开始扩张业务种类，而此时，越来越多的人看到了这个行业。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;后来，雅虎的搜索业务被谷歌赶超；分类广告业务输给了 Craigslist；就连拍卖业务也被 eBay 碾压；更有 Facebook 等强大竞争对手，导致其市场份额不断缩小。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从 2007 年开始，雅虎在四年间换了四任 CEO，2012 年 Marissa Mayer 从谷歌离任来到雅虎，但也未能挽救其颓势。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;雅虎并不是一个人，曾经的诺基亚、摩托罗拉都是它的好伙伴。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这个瞬息万变的时代，唯有变化才是不变，这是其魅力所在，也是其残酷所在。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天我邀请到我的朋友 FrostA，曾在雅虎工作了三年，完整经历了从 Yahoo 到 Oath 到 Verizon Media 的全过程，从第一视角跟大家分享她在雅虎的工作体验。&lt;/p&gt;
&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;先吐槽&lt;/span&gt;&lt;/h3&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;技术&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;雅虎现在的技术其实还有一些能拿得出手的，比如说前两年开源的 Vespa，据说当年 M 姐把所有关键组都转移到总部不然就直接砍掉，结果只有 Vespa 坚持在挪威不搬家，M 姐也拿他们没办法。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每年公司内部还有自己的科技论坛会议，去过两次，其实能看到很多有趣的创新的东西。不过想一想我写的那种垃圾都能被选上，好像水平也不怎么高，括弧笑。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只不过我觉得公司内部最大的问题是没有一个强有力的 CTO 去推行很多平台性的东西，没有统一的 ML 平台，没有统一的 Microservice，不是说没有人做，但是推广程度不高，更像是有一两个组在从零建立起整个用户群。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;福利&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;曾经湾区数一数二的食堂现在简直难以下咽。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;刚入职那段时间还有每周一次的 sushi time，赶上夏天有实习生的时候呼朋唤友好不热闹。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在各种大刀阔斧的砍食物，中餐每天就三个菜爱吃不吃，咖喱倒是单独搞了个柜台，队伍还是那么长。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;啊对，晚饭没了。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;矿泉水砍了，你说是为了保护环境我也算是支持吧。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;零食饮料都跟着前 CEO 一起走了，省钱俩字就差写脸上了。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;卖大楼&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一流企业卖大楼，用了多少年的 HeadQuarter 以后就是 G 家的了，但是早知道要卖你干嘛还折腾了一整年全部重新装修了一遍呢。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;改名&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;中间改叫了一年的 Oath，也跟前 CEO 一起被换了。现在官方名字变成了 Verizon Media，但是还是 Oath Holdings 给你发钱，过海关我都不知道我该说给谁工作，括弧笑*2。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;缺钱&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这干了 3 年，晋升的还算快，进来是 SDE1，半年升职到 SDE2，又一年升到 SDE3，到最后总包大概一年能有 180、190K 左右？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是一个同期的同事，干了一年跳西雅图 A，又一年跳回湾区 G，一问人家 250K，估计还是照顾我感受往少了说。。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;401K 干满 3 年才给。&lt;/p&gt;
&lt;blockquote data-tool=&quot;mdnice编辑器&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;❝&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;401K 是美国的退休金计划，自己存一部分，公司会给交一部分。&lt;/p&gt;
&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RSU 分三年给。升职的时候画个饼，年终填点渣，这几年攒下来没拿到手的饼大概有 70k，估计不如其他几家一次 refresh。&lt;/p&gt;
&lt;blockquote data-tool=&quot;mdnice编辑器&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;❝&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;RSU：Restricted Stock Unit，就是股票。&lt;/p&gt;
&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;裁员&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从 17 年入职以来公司大裁员三次的样子吧，头两年小裁员也搞了不少，不过最近一年多好像就裁了一次，估计是裁的差不多了吧，括弧笑*3。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;离职&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;裁员带来的直接结果就是大量本来没什么被裁风险的人纷纷主动离职，高层频繁变动很容易给人一种不安感，所以很多排期老哥选择了主动离开。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;缺人&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;裁员+离职我就不重复了，再加上给不出有竞争力的 offer，这两年我面过 30+应届生，看好的无一例外都去了 G。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;开源节流加起来，跟我说少了一半的人我都信，刚来的时候起晚了停车位都难找，到现在 11 点上班还能停楼门前，怪不得要卖大楼。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;缺人的直接影响就是很多项目没人负责，大量的交接占据了工作的很大一部分，有什么疑问点开 git log 发现 user undefined。&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1ginnfpwfsvj3068068dft.jpg&quot; alt=&quot;&quot;/&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;个人发展&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;缺点说了一堆，不过我还是在这个公司待了 3 年，主要的原因还是我觉得这里对我个人发展有帮助，从几个角度说吧。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;晋升&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然我还是 junior 级别主要靠混日子，不过&lt;strong&gt;晋升这种一个萝卜一个坑的事，想要快速升职，要么去一家高速发展的公司能不断产生新的空位，要么就是去一家能不断腾出空位的公司。&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为人才流失，所以公司对于还留在公司的人还算慷慨，身边年长的同事晋升都没有遇到什么太大阻碍，甚至十来个人的组大老板已经成了 senior director，水涨船高我也能跟着升职容易一些。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;学习&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;因为缺人，所以什么项目都能掺一脚。&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这几年我从前端做到后端，从大数据做到调参，时不时还跟 TL 讨论一下新系统的架构设计，这种接触到各种不同领域的机会单纯做一颗高薪螺丝钉是遇不到的。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再加上瘦死的骆驼比马大，单说雅虎邮箱现在每天数据量还是上 B 的，跑一个 hadoop 还是有几千个 node 的，而且用起来没什么限制，这种平台也算是有一定的竞争力。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;自由度&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这点可能跟组有关，我印度老板对我做什么工作基本就是放任，有想法了就去做，想尝试换个领域就安排不同的工作内容，不能说完全没有烦心的工作，不过自主权比较大，可以自己决定很多事情做不做，怎么做。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;WLB&lt;/span&gt;&lt;/h2&gt;
&lt;blockquote data-tool=&quot;mdnice编辑器&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;❝&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;WLB: work life balance，以后这个不写注释了哦！&lt;/p&gt;
&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我从最开始 9 点上班到 10 点到 10 点半踩点开早会到 11 点，反正大家都在摸，我稍微摸会鱼好像问题也不大，所以这些年一直没怎么感受到秃头的压力，括弧笑*4。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总的来说，虽然雅虎这些年一直走下坡路，不过如果能找到恰当的机会，我感觉还是很适合一部分人的。&lt;/p&gt;
&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;非常感谢 FrostA 的无私分享！行业内对雅虎的评价不一，但凡事都有两面，顺应时代变化，抓住属于自己的机会，为自己做积累，你就是那颗最亮的星～&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文已收录至我的 Github 上：&lt;code&gt;https://github.com/xiaoqi6666/NYCSDE&lt;/code&gt;，这个 Github 汇总了我所有的文章和资料，之后也会一直更新和维护。点击阅读原文即可直达，&lt;strong&gt;还希望大家帮忙点个 &lt;code&gt;Star&lt;/code&gt;&lt;/strong&gt;，你们的支持和认可，就是我创作的最大动力！&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;这是《齐姐聊大厂》系列的第 6 篇，如果你喜欢这篇文章，不要忘记点赞哦！也欢迎留言告诉小齐你感兴趣的大厂～&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;我是小齐，终身学习者，每晚 9 点，自习室里我们不见不散 ❤️&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 18 Sep 2020 00:23:00 +0000</pubDate>
<dc:creator>码农田小齐</dc:creator>
<og:description>这里是《齐姐聊大厂》系列的第 6 篇 （前 5 篇见文末） 每周五早上 8 点，与你唠唠大厂的那些事。 小齐说： 2016 年 7 月 25 日，Verizon 最终敲定以 48 亿美金收购雅虎的核心</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/nycsde/p/13689088.html</dc:identifier>
</item>
<item>
<title>掌握SpringBoot-2.3的容器探针：实战篇 - 程序员欣宸</title>
<link>http://www.cnblogs.com/bolingcavalry/p/13689063.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bolingcavalry/p/13689063.html</guid>
<description>&lt;h3 id=&quot;欢迎访问我的github&quot;&gt;欢迎访问我的GitHub&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;内容：原创文章分类汇总，及配套源码，涉及Java、Docker、K8S、DevOPS等&lt;br/&gt;经过多篇知识积累终于来到实战章节，亲爱的读者们，请将装备就位，一起动手体验SpringBoot官方带给我们的最新技术；&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;关于《springboot-23容器化技术》系列&quot;&gt;关于《SpringBoot-2.3容器化技术》系列&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;《SpringBoot-2.3容器化技术》系列，旨在和大家一起学习实践2.3版本带来的最新容器化技术，让咱们的Java应用更加适应容器化环境，在云计算时代依旧紧跟主流，保持竞争力；&lt;/li&gt;
&lt;li&gt;全系列文章分为主题和辅助两部分，主题部分如下：&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/boling_cavalry/article/details/106597358&quot;&gt;《体验SpringBoot(2.3)应用制作Docker镜像(官方方案)》&lt;/a&gt;；&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/boling_cavalry/article/details/106598189&quot;&gt;《详解SpringBoot(2.3)应用制作Docker镜像(官方方案)》&lt;/a&gt;；&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/boling_cavalry/article/details/106605264&quot;&gt;《掌握SpringBoot-2.3的容器探针：基础篇》&lt;/a&gt;；&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/boling_cavalry/article/details/106606442&quot;&gt;《掌握SpringBoot-2.3的容器探针：深入篇》&lt;/a&gt;；&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/boling_cavalry/article/details/106607225&quot;&gt;《掌握SpringBoot-2.3的容器探针：实战篇》&lt;/a&gt;；&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;辅助部分是一些参考资料和备忘总结，如下：&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/boling_cavalry/article/details/106600620&quot;&gt;《SpringBoot-2.3镜像方案为什么要做多个layer》&lt;/a&gt;；&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/boling_cavalry/article/details/106590784&quot;&gt;《设置非root账号不用sudo直接执行docker命令》&lt;/a&gt;；&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/boling_cavalry/article/details/106594392&quot;&gt;《开发阶段，将SpringBoot应用快速部署到K8S》&lt;/a&gt;；&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;springboot-23容器探针知识点小结&quot;&gt;SpringBoot-2.3容器探针知识点小结&lt;/h3&gt;
&lt;p&gt;经过前面的知识积累，我们知道了SpringBoot-2.3新增的探针规范以及适用场景，这里做个简短的回顾：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;kubernetes要求业务容器提供一个名为&lt;span&gt;livenessProbe&lt;/span&gt;的地址，kubernetes会定时访问该地址，如果该地址的返回码不在200到400之间，kubernetes认为该容器不健康，&lt;span&gt;会杀死该容器重建新的容器&lt;/span&gt;，这个地址就是&lt;span&gt;存活探针&lt;/span&gt;；&lt;/li&gt;
&lt;li&gt;kubernetes要求业务容器提供一个名为&lt;span&gt;readinessProbe&lt;/span&gt;的地址，kubernetes会定时访问该地址，如果该地址的返回码不在200到400之间，kubernetes认为该容器无法对外提供服务，&lt;span&gt;不会把请求调度到该容器&lt;/span&gt;，这个地址就是&lt;span&gt;就绪探针&lt;/span&gt;；&lt;/li&gt;
&lt;li&gt;SpringBoot的2.3.0.RELEASE发布了两个新的actuator地址，&lt;span&gt;/actuator/health/liveness&lt;/span&gt;和&lt;span&gt;/actuator/health/readiness&lt;/span&gt;，前者用作存活探针，后者用作就绪探针，这两个地址的返回值来自两个新增的actuator：&lt;span&gt;Liveness State&lt;/span&gt;和&lt;span&gt;Readiness State&lt;/span&gt;；&lt;/li&gt;
&lt;li&gt;SpringBoot应用根据特殊环境变量是否存在来判定自己是否运行在容器环境，如果是，&lt;span&gt;/actuator/health/liveness&lt;/span&gt;和&lt;span&gt;/actuator/health/readiness&lt;/span&gt;这两个地址就有返回码，具体的值是和应用的状态有对应关系的，例如应用启动过程中，/actuator/health/readiness返回&lt;span&gt;503&lt;/span&gt;，启动成功后返回&lt;span&gt;200&lt;/span&gt;；&lt;/li&gt;
&lt;li&gt;业务应用可以通过Spring系统事件机制来读取&lt;span&gt;Liveness State&lt;/span&gt;和&lt;span&gt;Readiness State&lt;/span&gt;，也可以订阅这两个actuator的变更事件；&lt;/li&gt;
&lt;li&gt;业务应用可以通过Spring系统事件机制来修改&lt;span&gt;Liveness State&lt;/span&gt;和&lt;span&gt;Readiness State&lt;/span&gt;，此时/actuator/health/liveness和/actuator/health/readiness的返回值都会发生变更，从而影响kubernetes对此容器的行为（参照第一点和第二点），例如livenessProbe返回码变成503，导致kubernetes认为容器不健康，从而杀死容器；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;小结完毕，接下来开始实打实的编码和操作实战，验证上述理论；&lt;/p&gt;
&lt;h3 id=&quot;实战环境信息&quot;&gt;实战环境信息&lt;/h3&gt;
&lt;p&gt;本次实战有两个环境：开发和运行环境，其中开发环境信息如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;操作系统：Ubuntu 20.04 LTS 桌面版&lt;/li&gt;
&lt;li&gt;CPU ：2.30GHz × 4，内存：32G，硬盘：1T NVMe&lt;/li&gt;
&lt;li&gt;JDK：1.8.0_231&lt;/li&gt;
&lt;li&gt;MAVEN：3.6.3&lt;/li&gt;
&lt;li&gt;SpringBoot：2.3.0.RELEASE&lt;/li&gt;
&lt;li&gt;Docker：19.03.10&lt;/li&gt;
&lt;li&gt;开发工具：IDEA 2020.1.1 (Ultimate Edition)&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;运行环境信息如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;操作系统：CentOS Linux release 7.8.2003&lt;/li&gt;
&lt;li&gt;Kubernetes：1.15&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;事实证明，用Ubuntu桌面版作为开发环境是可行的，体验十分顺畅，IDEA、SubLime、SSH、Chrome、微信都能正常使用，下图是我的Ubuntu开发环境：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202009/485422-20200918074820683-1698100241.jpg&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;实战内容简介&quot;&gt;实战内容简介&lt;/h3&gt;
&lt;p&gt;本次实战包括以下内容：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;开发SpringBoot应用，部署在kubernetes；&lt;/li&gt;
&lt;li&gt;检查应用状态和kubernetes的pod状态的关联变化；&lt;/li&gt;
&lt;li&gt;修改Readiness State，看kubernetes是否还会把请求调度到pod；&lt;/li&gt;
&lt;li&gt;修改Liveness State，看kubernetes会不是杀死pod；&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;源码下载&quot;&gt;源码下载&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;本次实战用到了一个普通的SpringBoot工程，源码可在GitHub下载到，地址和链接信息如下表所示(&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;)：&lt;/li&gt;
&lt;/ol&gt;&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;这个git项目中有多个文件夹，本章的应用在&lt;span&gt;probedemo&lt;/span&gt;文件夹下，如下图红框所示：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202009/485422-20200918074821211-349033275.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;开发springboot应用&quot;&gt;开发SpringBoot应用&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;请在IDEA上安装lombok插件：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202009/485422-20200918074821604-448692037.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;在IDEA上新建名为&lt;span&gt;probedemo&lt;/span&gt;的SpringBoot工程，版本选择&lt;span&gt;2.3.0&lt;/span&gt;：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202009/485422-20200918074821948-2121997571.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;该工程的pom.xml内容如下，注意要有&lt;span&gt;spring-boot-starter-actuator&lt;/span&gt;和&lt;span&gt;lombok&lt;/span&gt;依赖，另外插件&lt;span&gt;spring-boot-maven-plugin&lt;/span&gt;也要增加&lt;span&gt;layers&lt;/span&gt;节点：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;
    &amp;lt;parent&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;2.3.0.RELEASE&amp;lt;/version&amp;gt;
        &amp;lt;relativePath/&amp;gt; &amp;lt;!-- lookup parent from repository --&amp;gt;
    &amp;lt;/parent&amp;gt;
    &amp;lt;groupId&amp;gt;com.bolingcavalry&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;probedemo&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt;
    &amp;lt;name&amp;gt;probedemo&amp;lt;/name&amp;gt;
    &amp;lt;description&amp;gt;Demo project for Spring Boot&amp;lt;/description&amp;gt;

    &amp;lt;properties&amp;gt;
        &amp;lt;java.version&amp;gt;1.8&amp;lt;/java.version&amp;gt;
    &amp;lt;/properties&amp;gt;

    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
            &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
            &amp;lt;exclusions&amp;gt;
                &amp;lt;exclusion&amp;gt;
                    &amp;lt;groupId&amp;gt;org.junit.vintage&amp;lt;/groupId&amp;gt;
                    &amp;lt;artifactId&amp;gt;junit-vintage-engine&amp;lt;/artifactId&amp;gt;
                &amp;lt;/exclusion&amp;gt;
            &amp;lt;/exclusions&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-actuator&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.projectlombok&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;lombok&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;

    &amp;lt;build&amp;gt;
        &amp;lt;plugins&amp;gt;
            &amp;lt;plugin&amp;gt;
                &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;2.3.0.RELEASE&amp;lt;/version&amp;gt;
                &amp;lt;!--该配置会在jar中增加layer描述文件，以及提取layer的工具--&amp;gt;
                &amp;lt;configuration&amp;gt;
                    &amp;lt;layers&amp;gt;
                        &amp;lt;enabled&amp;gt;true&amp;lt;/enabled&amp;gt;
                    &amp;lt;/layers&amp;gt;
                &amp;lt;/configuration&amp;gt;
            &amp;lt;/plugin&amp;gt;
        &amp;lt;/plugins&amp;gt;
    &amp;lt;/build&amp;gt;
&amp;lt;/project&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;应用启动类&lt;span&gt;ProbedemoApplication&lt;/span&gt;是个最普通的启动类：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.bolingcavalry.probedemo;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class ProbedemoApplication {
    public static void main(String[] args) {
        SpringApplication.run(ProbedemoApplication.class, args);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;5&quot;&gt;&lt;li&gt;增加一个监听类，可以监听存活和就绪状态的变化：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.bolingcavalry.probedemo.listener;

import lombok.extern.slf4j.Slf4j;
import org.springframework.boot.availability.AvailabilityChangeEvent;
import org.springframework.boot.availability.AvailabilityState;
import org.springframework.context.event.EventListener;
import org.springframework.stereotype.Component;

/**
 * description: 监听系统事件的类 &amp;lt;br&amp;gt;
 * date: 2020/6/4 下午12:57 &amp;lt;br&amp;gt;
 * author: willzhao &amp;lt;br&amp;gt;
 * email: zq2599@gmail.com &amp;lt;br&amp;gt;
 * version: 1.0 &amp;lt;br&amp;gt;
 */
@Component
@Slf4j
public class AvailabilityListener {

    /**
     * 监听系统消息，
     * AvailabilityChangeEvent类型的消息都从会触发此方法被回调
     * @param event
     */
    @EventListener
    public void onStateChange(AvailabilityChangeEvent&amp;lt;? extends AvailabilityState&amp;gt; event) {
        log.info(event.getState().getClass().getSimpleName() + &quot; : &quot; + event.getState());
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;6&quot;&gt;&lt;li&gt;增加名为&lt;span&gt;StateReader的Controller&lt;/span&gt;的Controller，用于获取存活和就绪状态：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.bolingcavalry.probedemo.controller;

import org.springframework.boot.availability.ApplicationAvailability;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import javax.annotation.Resource;
import java.util.Date;

@RestController
@RequestMapping(&quot;/statereader&quot;)
public class StateReader {

    @Resource
    ApplicationAvailability applicationAvailability;

    @RequestMapping(value=&quot;/get&quot;)
    public String state() {
        return &quot;livenessState : &quot; + applicationAvailability.getLivenessState()
               + &quot;&amp;lt;br&amp;gt;readinessState : &quot; + applicationAvailability.getReadinessState()
               + &quot;&amp;lt;br&amp;gt;&quot; + new Date();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;7&quot;&gt;&lt;li&gt;增加名为&lt;span&gt;StateWritter&lt;/span&gt;的Controller，用于设置存活和就绪状态：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.bolingcavalry.probedemo.controller;

import org.springframework.boot.availability.AvailabilityChangeEvent;
import org.springframework.boot.availability.LivenessState;
import org.springframework.boot.availability.ReadinessState;
import org.springframework.context.ApplicationEventPublisher;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import javax.annotation.Resource;
import java.util.Date;

/**
 * description: 修改状态的controller &amp;lt;br&amp;gt;
 * date: 2020/6/4 下午1:21 &amp;lt;br&amp;gt;
 * author: willzhao &amp;lt;br&amp;gt;
 * email: zq2599@gmail.com &amp;lt;br&amp;gt;
 * version: 1.0 &amp;lt;br&amp;gt;
 */
@RestController
@RequestMapping(&quot;/staterwriter&quot;)
public class StateWritter {

    @Resource
    ApplicationEventPublisher applicationEventPublisher;

    /**
     * 将存活状态改为BROKEN（会导致kubernetes杀死pod）
     * @return
     */
    @RequestMapping(value=&quot;/broken&quot;)
    public String broken(){
        AvailabilityChangeEvent.publish(applicationEventPublisher, StateWritter.this, LivenessState.BROKEN);
        return &quot;success broken, &quot; + new Date();
    }

    /**
     * 将存活状态改为CORRECT
     * @return
     */
    @RequestMapping(value=&quot;/correct&quot;)
    public String correct(){
        AvailabilityChangeEvent.publish(applicationEventPublisher, StateWritter.this, LivenessState.CORRECT);
        return &quot;success correct, &quot; + new Date();
    }

    /**
     * 将就绪状态改为REFUSING_TRAFFIC（导致kubernetes不再把外部请求转发到此pod）
     * @return
     */
    @RequestMapping(value=&quot;/refuse&quot;)
    public String refuse(){
        AvailabilityChangeEvent.publish(applicationEventPublisher, StateWritter.this, ReadinessState.REFUSING_TRAFFIC);
        return &quot;success refuse, &quot; + new Date();
    }

    /**
     * 将就绪状态改为ACCEPTING_TRAFFIC（导致kubernetes会把外部请求转发到此pod）
     * @return
     */
    @RequestMapping(value=&quot;/accept&quot;)
    public String accept(){
        AvailabilityChangeEvent.publish(applicationEventPublisher, StateWritter.this, ReadinessState.ACCEPTING_TRAFFIC);
        return &quot;success accept, &quot; + new Date();
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;8&quot;&gt;&lt;li&gt;增加名为&lt;span&gt;Hello&lt;/span&gt;的controller，此接口能返回当前pod的IP地址，在后面测试时会用到：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.bolingcavalry.probedemo.controller;

import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.net.Inet4Address;
import java.net.InetAddress;
import java.net.NetworkInterface;
import java.net.SocketException;
import java.util.ArrayList;
import java.util.Date;
import java.util.Enumeration;
import java.util.List;

/**
 * description: hello demo &amp;lt;br&amp;gt;
 * date: 2020/6/4 下午4:38 &amp;lt;br&amp;gt;
 * author: willzhao &amp;lt;br&amp;gt;
 * email: zq2599@gmail.com &amp;lt;br&amp;gt;
 * version: 1.0 &amp;lt;br&amp;gt;
 */
@RestController
public class Hello {

    /**
     * 返回的是当前服务器IP地址，在k8s环境就是pod地址
     * @return
     * @throws SocketException
     */
    @RequestMapping(value=&quot;/hello&quot;)
    public String hello() throws SocketException {
        List&amp;lt;Inet4Address&amp;gt; addresses = getLocalIp4AddressFromNetworkInterface();
        if(null==addresses || addresses.isEmpty()) {
            return  &quot;empty ip address, &quot; + new Date();
        }

        return addresses.get(0).toString() + &quot;, &quot; + new Date();
    }

    public static List&amp;lt;Inet4Address&amp;gt; getLocalIp4AddressFromNetworkInterface() throws SocketException {
        List&amp;lt;Inet4Address&amp;gt; addresses = new ArrayList&amp;lt;&amp;gt;(1);
        Enumeration e = NetworkInterface.getNetworkInterfaces();
        if (e == null) {
            return addresses;
        }
        while (e.hasMoreElements()) {
            NetworkInterface n = (NetworkInterface) e.nextElement();
            if (!isValidInterface(n)) {
                continue;
            }
            Enumeration ee = n.getInetAddresses();
            while (ee.hasMoreElements()) {
                InetAddress i = (InetAddress) ee.nextElement();
                if (isValidAddress(i)) {
                    addresses.add((Inet4Address) i);
                }
            }
        }
        return addresses;
    }

    /**
     * 过滤回环网卡、点对点网卡、非活动网卡、虚拟网卡并要求网卡名字是eth或ens开头
     * @param ni 网卡
     * @return 如果满足要求则true，否则false
     */
    private static boolean isValidInterface(NetworkInterface ni) throws SocketException {
        return !ni.isLoopback() &amp;amp;&amp;amp; !ni.isPointToPoint() &amp;amp;&amp;amp; ni.isUp() &amp;amp;&amp;amp; !ni.isVirtual()
                &amp;amp;&amp;amp; (ni.getName().startsWith(&quot;eth&quot;) || ni.getName().startsWith(&quot;ens&quot;));
    }

    /**
     * 判断是否是IPv4，并且内网地址并过滤回环地址.
     */
    private static boolean isValidAddress(InetAddress address) {
        return address instanceof Inet4Address &amp;amp;&amp;amp; address.isSiteLocalAddress() &amp;amp;&amp;amp; !address.isLoopbackAddress();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上就是该SpringBoot工程的所有代码了，请确保可以编译运行；&lt;/p&gt;
&lt;h3 id=&quot;制作docker镜像&quot;&gt;制作Docker镜像&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;在pom.xml所在目录创建文件Dockerfile，内容如下：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;# 指定基础镜像，这是分阶段构建的前期阶段
FROM openjdk:8u212-jdk-stretch as builder
# 执行工作目录
WORKDIR application
# 配置参数
ARG JAR_FILE=target/*.jar
# 将编译构建得到的jar文件复制到镜像空间中
COPY ${JAR_FILE} application.jar
# 通过工具spring-boot-jarmode-layertools从application.jar中提取拆分后的构建结果
RUN java -Djarmode=layertools -jar application.jar extract

# 正式构建镜像
FROM openjdk:8u212-jdk-stretch
WORKDIR application
# 前一阶段从jar中提取除了多个文件，这里分别执行COPY命令复制到镜像空间中，每次COPY都是一个layer
COPY --from=builder application/dependencies/ ./
COPY --from=builder application/spring-boot-loader/ ./
COPY --from=builder application/snapshot-dependencies/ ./
COPY --from=builder application/application/ ./
ENTRYPOINT [&quot;java&quot;, &quot;org.springframework.boot.loader.JarLauncher&quot;]
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;先编译构建工程，执行以下命令：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;mvn clean package -U -DskipTests 
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;编译成功后，通过&lt;span&gt;Dockerfile&lt;/span&gt;文件创建镜像：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;sudo docker build -t bolingcavalry/probedemo:0.0.1 .
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;镜像创建成功：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202009/485422-20200918074822384-1654999639.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;SpringBoot的镜像准备完毕，接下来要让kubernetes环境用上这个镜像；&lt;/p&gt;
&lt;h3 id=&quot;将镜像加载到kubernetes环境&quot;&gt;将镜像加载到kubernetes环境&lt;/h3&gt;
&lt;p&gt;此时的镜像保存在开发环境的电脑上，可以有以下三种方式加载到kubernetes环境：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;push到私有仓库，kubernetes上使用时也从私有仓库获取；&lt;/li&gt;
&lt;li&gt;push到hub.docker.com，kubernetes上使用时也从hub.docker.com获取，&lt;span&gt;目前我已经将此镜像push到hub.docker.com，您在kubernetes直接使用即可&lt;/span&gt;，就像nginx、tomcat这些官方镜像一样下载；&lt;/li&gt;
&lt;li&gt;在开发环境执行&lt;span&gt;docker save bolingcavalry/probedemo:0.0.1 &amp;gt; probedemo.tar&lt;/span&gt;，可将此镜像另存为本地文件，再scp到kubernetes服务器，再在kubernetes服务器执行&lt;span&gt;docker load &amp;lt; /root/temp/202006/04/probedemo.tar&lt;/span&gt;就能加载到kubernetes服务器的本地docker缓存中；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;以上三种方法的优缺点整理如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;首推第一种，但是需要您搭建私有仓库；&lt;/li&gt;
&lt;li&gt;由于springboot-2.3官方对镜像构建作了优化，第二种方法也就执行第一次的时候上传和下载很耗时，之后修改java代码重新构建时，不论上传还是下载都很快（只上传下载某个layer）；&lt;/li&gt;
&lt;li&gt;在开发阶段，使用第三种方法最为便捷，但如果kubernetes环境有多台机器，就不合适了，因为镜像是存在指定机器的本地缓存的；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;我的kubernetes环境只有一台电脑，因此用的是方法三，参考命令如下(建议安装sshpass，就不用每次输入帐号密码了)：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;# 将镜像保存为tar文件
sudo docker save bolingcavalry/probedemo:0.0.1 &amp;gt; probedemo.tar

# scp到kubernetes服务器
sshpass -p 888888 scp ./probedemo.tar root@192.168.50.135:/root/temp/202006/04/ 
  
# 远程执行ssh命令，加载docker镜像
sshpass -p 888888 ssh root@192.168.50.135 &quot;docker load &amp;lt; /root/temp/202006/04/probedemo.tar&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;kubernetes部署deployment和service&quot;&gt;kubernetes部署deployment和service&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;在kubernetes创建名为&lt;span&gt;probedemo.yaml&lt;/span&gt;的文件，内容如下，注意pod副本数是&lt;span&gt;2&lt;/span&gt;，另外请关注livenessProbe和readinessProbe的参数配置：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-yaml&quot;&gt;apiVersion: v1
kind: Service
metadata:
  name: probedemo
spec:
  type: NodePort
  ports:
    - port: 8080
      nodePort: 30080
  selector:
    name: probedemo
---
apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  name: probedemo
spec:
  replicas: 2
  template:
    metadata:
      labels:
        name: probedemo
    spec:
      containers:
        - name: probedemo
          image: bolingcavalry/probedemo:0.0.1
          tty: true
          livenessProbe:
            httpGet:
              path: /actuator/health/liveness
              port: 8080
            initialDelaySeconds: 5
            failureThreshold: 10
            timeoutSeconds: 10
            periodSeconds: 5
          readinessProbe:
            httpGet:
              path: /actuator/health/readiness
              port: 8080
            initialDelaySeconds: 5
            timeoutSeconds: 10
            periodSeconds: 5
          ports:
            - containerPort: 8080
          resources:
            requests:
              memory: &quot;512Mi&quot;
              cpu: &quot;100m&quot;
            limits:
              memory: &quot;1Gi&quot;
              cpu: &quot;500m&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;执行命令&lt;span&gt;kubectl apply -f probedemo..yaml&lt;/span&gt;，即可创建deployment和service：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202009/485422-20200918074822927-1033259420.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;这里要重点关注的是&lt;span&gt;livenessProbe&lt;/span&gt;的&lt;span&gt;initialDelaySeconds&lt;/span&gt;和&lt;span&gt;failureThreshold&lt;/span&gt;参数，initialDelaySeconds等于5，表示pod创建5秒后检查存活探针，如果10秒内应用没有完成启动，存活探针不返回200，就会重试10次(failureThreshold等于10)，如果重试10次后存活探针依旧无法返回200，该pod就会被kubernetes杀死重建，要是每次启动都耗时这么长，pod就会不停的被杀死重建；&lt;/li&gt;
&lt;li&gt;执行命令&lt;span&gt;kubectl apply -f probedemo.yaml&lt;/span&gt;，创建deployment和service，如下图，可见在第十秒的时候pod创建成功，但是此时还未就绪：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202009/485422-20200918074824039-75173218.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;5&quot;&gt;&lt;li&gt;继续查看状态，创建一分钟后两个pod终于就绪：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202009/485422-20200918074824760-990337150.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;6&quot;&gt;&lt;li&gt;用&lt;span&gt;kubectl describe&lt;/span&gt;命令查看pod状态，事件通知显示存活和就绪探针都有失败情况，不过因为有重试，因此后来状态会变为成功：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202009/485422-20200918074825683-1969886222.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至此，从编码到部署都完成了，接下来验证SpringBoot-2.3.0.RELEASE的探针技术；&lt;/p&gt;
&lt;h3 id=&quot;验证springboot-230release的探针技术&quot;&gt;验证SpringBoot-2.3.0.RELEASE的探针技术&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;监听类&lt;span&gt;AvailabilityListener&lt;/span&gt;的作用是监听状态变化，看看pod日志，看AvailabilityListener的代码是否有效，如下图红框，在应用启动阶段AvailabilityListener被成功回调，打印了存活和就绪状态：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202009/485422-20200918074827378-1781194060.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;2&quot; readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;kubernetes所在机器的IP地址是&lt;span&gt;192.168.50.135&lt;/span&gt;，因此SpringBoot服务的访问地址是&lt;a href=&quot;http://192.168.50.135:30080/xxx&quot;&gt;&lt;span&gt;http://192.168.50.135:30080/xxx&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;访问地址&lt;a href=&quot;http://192.168.50.135:30080/actuator/health/liveness&quot;&gt;&lt;span&gt;http://192.168.50.135:30080/actuator/health/liveness&lt;/span&gt;&lt;/a&gt;，返回码如下图红框，可见存活探针已开启：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202009/485422-20200918074828031-2103394446.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;就绪探针也正常：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202009/485422-20200918074828670-277837184.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;5&quot;&gt;&lt;li&gt;打开两个浏览器，都访问：&lt;a href=&quot;http://192.168.50.135:30080/hello&quot;&gt;&lt;span&gt;http://192.168.50.135:30080/hello&lt;/span&gt;&lt;/a&gt;，多次Ctrl+F5强刷，如下图，很快就能得到不同结果，证明响应来自不同的Pod：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202009/485422-20200918074829238-1367753741.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;6&quot;&gt;&lt;li&gt;访问：&lt;a href=&quot;http://192.168.50.135:30080/statereader/get&quot;&gt;&lt;span&gt;http://192.168.50.135:30080/statereader/get&lt;/span&gt;&lt;/a&gt;，可以得到存活和就绪的状态，可见StateReader的代码已经生效，可以通过ApplicationAvailability接口取得状态：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202009/485422-20200918074829749-1105365258.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;7&quot;&gt;&lt;li&gt;修改就绪状态，访问：&lt;a href=&quot;http://192.168.50.135:30080/statewriter/refuse&quot;&gt;&lt;span&gt;http://192.168.50.135:30080/statewriter/refuse&lt;/span&gt;&lt;/a&gt;，如下图红框，可见收到请求的pod，其就绪状态已经出现了异常，证明&lt;span&gt;StateWritter.java中修改就绪状态后，可以让kubernetes感知到这个pod的异常&lt;/span&gt;：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202009/485422-20200918074830436-1627308383.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;8&quot;&gt;&lt;li&gt;用浏览器反复强刷hello接口，返回的Pod地址也只有一个，证明只有一个Pod在响应请求：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202009/485422-20200918074830986-1971428714.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;9&quot;&gt;&lt;li&gt;尝试恢复服务，注意请求要在服务器后台发送，而且IP地址要用刚才被设置为refuse的&lt;span&gt;pod地址&lt;/span&gt;：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;curl http://10.233.90.195:8080/statewriter/accept
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;10&quot;&gt;&lt;li&gt;如下图，状态已经恢复：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202009/485422-20200918074831790-1392485678.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;11&quot;&gt;&lt;li&gt;最后再来试试将存活状态从&lt;span&gt;CORRECT&lt;/span&gt;改成&lt;span&gt;BROKEN&lt;/span&gt;，浏览器访问：&lt;a href=&quot;http://192.168.50.135:30080/statewriter/broken&quot;&gt;&lt;span&gt;http://192.168.50.135:30080/statewriter/broken&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;如下图红框，重启次数变成1，表示pod被杀死了一次，并且由于重启导致当前还未就绪，证明&lt;span&gt;在SpringBoot中修改了存活探针的状态，是会触发kubernetes杀死pod的&lt;/span&gt;：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202009/485422-20200918074832455-1183217519.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;13&quot;&gt;&lt;li&gt;等待pod重启、就绪探针正常后，一切恢复如初：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202009/485422-20200918074833308-2100873232.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;14&quot;&gt;&lt;li&gt;强刷浏览器，如下图红框，两个Pod都能正常响应：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202009/485422-20200918074833875-2815730.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;官方忠告&quot;&gt;官方忠告&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;至此，《掌握SpringBoot-2.3的容器探针》系列就全部完成了，从理论到实践，咱们一起学习了SpringBoot官方带给我们的容器化技术，最后以一段官方忠告来结尾，大家一起将此忠告牢记在心：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202009/485422-20200918074834728-1783888807.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;我对以上内容的理解：选择外部系统的服务作为探针的时候要谨慎（外部系统可能是数据库，也可能是其他web服务），如果外部系统出现问题，会导致kubernetes杀死pod(存活探针问题)，或者导致kubernetes不再调度请求到pod(就绪探针问题)；（再请感谢大家容忍我的英语水平）&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;欢迎关注我的公众号：程序员欣宸&quot;&gt;欢迎关注我的公众号：程序员欣宸&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202009/485422-20200918074835052-156929511.jpg&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 17 Sep 2020 23:49:00 +0000</pubDate>
<dc:creator>程序员欣宸</dc:creator>
<og:description>欢迎访问我的GitHub https://github.com/zq2599/blog_demos 内容：原创文章分类汇总，及配套源码，涉及Java、Docker、K8S、DevOPS等 经过多篇知识</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/bolingcavalry/p/13689063.html</dc:identifier>
</item>
<item>
<title>【Flutter 实战】文件系统目录 - 老孟Flutter</title>
<link>http://www.cnblogs.com/mengqd/p/13689014.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mengqd/p/13689014.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202009/467322-20200918064927647-600712682.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;老孟导读&lt;/strong&gt;：Flutter 中获取文件路径，我们都知道使用 &lt;strong&gt;path_provider&lt;/strong&gt;，但对其目录对含义不是很清楚，此文介绍 Android、iOS 系统的文件目录，不同场景下建议使用的目录。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不同的平台对应的文件系统是不同的，比如文件路径，因此 Flutter 中获取文件路径需要原生支持，原生端通过 MethodChannel 传递文件路径到 Flutter，如果没有特殊的需求，推荐大家使用 Google 官方维护的插件 &lt;strong&gt;path_provider&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;1.304347826087&quot;&gt;
&lt;p&gt;pub 地址：&lt;a href=&quot;https://pub.flutter-io.cn/packages/path_provider&quot;&gt;https://pub.flutter-io.cn/packages/path_provider&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Github 地址：&lt;a href=&quot;https://github.com/flutter/plugins/tree/master/packages/path_provider/path_provider&quot;&gt;https://github.com/flutter/plugins/tree/master/packages/path_provider/path_provider&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;添加依赖&quot;&gt;添加依赖&lt;/h3&gt;
&lt;p&gt;在项目的 &lt;code&gt;pubspec.yaml&lt;/code&gt; 文件中添加依赖：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;dependencies:
  path_provider: ^1.6.14
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;flutter pub get
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;文件路径&quot;&gt;文件路径&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;path_provider&lt;/strong&gt;（版本：1.6.14）提供了8个方法获取不同的文件路径，目前 Flutter（Flutter 1.20.1 • channel stable ）只发布了正式版本的 Android 和 iOS，因此下面仅介绍 Android 和 iOS 平台的文件路径。&lt;/p&gt;
&lt;ul readability=&quot;28.5&quot;&gt;&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;&lt;strong&gt;getTemporaryDirectory&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;临时目录，适用于下载的缓存文件，此目录随时可以清除，此目录为应用程序私有目录，其他应用程序无法访问此目录。&lt;/p&gt;
&lt;p&gt;Android 上对应&lt;code&gt;getCacheDir&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;iOS上对应&lt;code&gt;NSCachesDirectory&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;getApplicationSupportDirectory&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;应用程序可以在其中放置应用程序支持文件的目录的路径。&lt;/p&gt;
&lt;p&gt;将此文件用于您不想向用户公开的文件。 您的应用不应将此目录用于存放用户数据文件。&lt;/p&gt;
&lt;p&gt;在iOS上，对应&lt;code&gt;NSApplicationSupportDirectory&lt;/code&gt; ，如果此目录不存在，则会自动创建。&lt;br/&gt;在Android上，对应&lt;code&gt;getFilesDir&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;getLibraryDirectory&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;应用程序可以在其中存储持久性文件，备份文件以及对用户不可见的文件的目录路径，例如storage.sqlite.db。&lt;/p&gt;
&lt;p&gt;在Android上，此函数抛出[UnsupportedError]异常，没有等效项路径存在。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;strong&gt;getApplicationDocumentsDirectory&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;应用程序可能在其中放置用户生成的数据或应用程序无法重新创建的数据的目录路径。&lt;/p&gt;
&lt;p&gt;在iOS上，对应&lt;code&gt;NSDocumentDirectory&lt;/code&gt; API。 如果数据不是用户生成的，考虑使用[getApplicationSupportDirectory]。&lt;/p&gt;
&lt;p&gt;在Android上，对应&lt;code&gt;getDataDirectory&lt;/code&gt; API。 如果要让用户看到数据，请考虑改用[getExternalStorageDirectory]。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;getExternalStorageDirectory&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;应用程序可以访问顶级存储的目录的路径。由于此功能仅在Android上可用，因此应在发出此函数调用之前确定当前操作系统。&lt;/p&gt;
&lt;p&gt;在iOS上，此功能会引发[UnsupportedError]异常，因为无法在应用程序的沙箱外部访问。&lt;/p&gt;
&lt;p&gt;在Android上，对应&lt;code&gt;getExternalFilesDir（null）&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;getExternalCacheDirectories&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;存储特定于应用程序的外部缓存数据的目录的路径。 这些路径通常位于外部存储（如单独的分区或SD卡）上。 电话可能具有多个可用的存储目录。&lt;br/&gt;由于此功能仅在Android上可用，因此应在发出此函数调用之前确定当前操作系统。&lt;br/&gt;在iOS上，此功能会抛出UnsupportedError，因为这是不可能的在应用程序的沙箱外部访问。&lt;/p&gt;
&lt;p&gt;在Android上，对应&lt;code&gt;Context.getExternalCacheDirs（）&lt;/code&gt;或API Level 低于19的&lt;code&gt;Context.getExternalCacheDir（）&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;&lt;strong&gt;getExternalStorageDirectories&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以存储应用程序特定数据的目录的路径。 这些路径通常位于外部存储（如单独的分区或SD卡）上。&lt;br/&gt;由于此功能仅在Android上可用，因此应在发出此函数调用之前确定当前操作系统。&lt;br/&gt;在iOS上，此功能会抛出UnsupportedError，因为这是不可能的在应用程序的沙箱外部访问。&lt;br/&gt;在Android上，对应&lt;code&gt;Context.getExternalFilesDirs（String type）&lt;/code&gt;或API Level 低于19的&lt;code&gt;Context.getExternalFilesDir（String type）&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;getDownloadsDirectory&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;存储下载文件的目录的路径，这通常仅与台式机操作系统有关。&lt;br/&gt;在Android和iOS上，此函数将引发[UnsupportedError]异常。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果没有 Android 或者 iOS开发经验，看完上面的说明应该是&lt;strong&gt;一脸懵逼&lt;/strong&gt;的，这么多路径到底用哪个？有什么区别？下面从 Android 和 iOS 平台的角度介绍其文件路径，最后给出路径使用的建议以及使用过程中需要注意的事项。&lt;/p&gt;
&lt;h3 id=&quot;android-文件存储&quot;&gt;Android 文件存储&lt;/h3&gt;
&lt;p&gt;Android 文件存储分为&lt;strong&gt;内部存储&lt;/strong&gt;和&lt;strong&gt;外部存储&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&quot;内部存储&quot;&gt;内部存储&lt;/h4&gt;
&lt;p&gt;用于保存应用的私有文件，其他应用无法访问这些数据，创建的文件在此应用的包名目录下，没有 &lt;strong&gt;root 权限&lt;/strong&gt; 的手机无法在手机的 &lt;strong&gt;文件管理&lt;/strong&gt; 应用中看到此目录，不过可以通过 Android Studio 工具查看，路径为：data/data/包名：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202009/467322-20200918064928178-978188697.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看下包名下具体的目录结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202009/467322-20200918064928347-1999515585.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;cache 目录：对应 &lt;strong&gt;getTemporaryDirectory&lt;/strong&gt; 方法，用于缓存文件，此目录随时可能被系统清除。&lt;/li&gt;
&lt;li&gt;files 目录：对应 &lt;strong&gt;getApplicationSupportDirectory&lt;/strong&gt; 方法。&lt;/li&gt;
&lt;li&gt;code_cache：此目录存储 Flutter 相关代码和资源。
&lt;ul&gt;&lt;li&gt;flutter_engine/skia：Flutter 渲染引擎。&lt;/li&gt;
&lt;li&gt;flutter_guidePVWGWK/flutter_guide/build/flutter_assets：Flutter 资源文件。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;shared_prefs： &lt;strong&gt;SharePreferences&lt;/strong&gt; 的默认路径。&lt;/li&gt;
&lt;li&gt;app_flutter：对应 &lt;strong&gt;getApplicationDocumentsDirectory&lt;/strong&gt;方法。&lt;/li&gt;
&lt;li&gt;app_flutter/dbName：使用 &lt;strong&gt;sqlite&lt;/strong&gt; 的默认路径，&lt;strong&gt;sqlite&lt;/strong&gt; 也可以指定位置。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;SharePreferences&lt;/strong&gt; 和 &lt;strong&gt;sqlite&lt;/strong&gt; 是两种保存数据的第三方插件。&lt;/p&gt;
&lt;p&gt;内部存储的特点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;安全性，其他应用无法访问这些数据。&lt;/li&gt;
&lt;li&gt;当应用卸载的时候，这些数据也会被删除，避免垃圾文件。&lt;/li&gt;
&lt;li&gt;不需要申请额外权限。&lt;/li&gt;
&lt;li&gt;存储的空间有限，此目录数据随时可能被系统清除，也可以通过 &lt;strong&gt;设置&lt;/strong&gt; 中的 &lt;strong&gt;清除数据&lt;/strong&gt; 可以清除此目录数据。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;国内特色&lt;/strong&gt;，不同手机厂商对此目录做了不同的限制，比如总体大小限制、单个应用程序所占空间大小限制、清除数据策略不同等。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;外部存储&quot;&gt;外部存储&lt;/h4&gt;
&lt;p&gt;外部存储可以通过手机的 &lt;strong&gt;文件管理&lt;/strong&gt; 应用查看，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202009/467322-20200918064928554-2103294065.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里面有一个特殊的目录：Android/data/包名:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202009/467322-20200918064928728-880725581.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看到这个目录是不是觉得和内部存储目录非常相似，一个包名代表一个应用程序：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202009/467322-20200918064928957-236386613.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;cache：缓存目录，对应 &lt;strong&gt;getExternalCacheDirectories&lt;/strong&gt; 方法。&lt;/li&gt;
&lt;li&gt;files：对应 &lt;strong&gt;getExternalStorageDirectories&lt;/strong&gt; 方法。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;此目录的特点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当应用卸载的时候，这些数据也会被删除，避免垃圾文件。&lt;/li&gt;
&lt;li&gt;不需要申请额外权限。&lt;/li&gt;
&lt;li&gt;空间大且不会被系统清除，通过 &lt;strong&gt;设置&lt;/strong&gt; 中的 &lt;strong&gt;清除数据&lt;/strong&gt; 可以清除此目录数据。&lt;/li&gt;
&lt;li&gt;用户可以直接对文件进行删除、导入操作。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;外部存储除了 &lt;strong&gt;Android/data/&lt;/strong&gt; 目录，还有和此目录同级的目录，特点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;所有应用程序均可访问。&lt;/li&gt;
&lt;li&gt;用户可以直接对文件进行删除、导入操作。&lt;/li&gt;
&lt;li&gt;需要申请&lt;strong&gt;读写权限&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Android 官方对此目录的管理越来越严格， &lt;strong&gt;Android 11&lt;/strong&gt; 系统已经开始强制执行分区存储，详情见：&lt;a href=&quot;https://developer.android.com/preview/privacy/storage?hl=zh-cn&quot;&gt;https://developer.android.com/preview/privacy/storage?hl=zh-cn&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;上面说了这么多，总结如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;SharePreferences&lt;/strong&gt; 和 &lt;strong&gt;sqlite&lt;/strong&gt; 数据建议存放在内部存储，插件已经帮我们完成了，无需手动处理。&lt;/li&gt;
&lt;li&gt;严格保密的数据，比如用户数据，建议存放在内部存储，对应 &lt;strong&gt;getApplicationSupportDirectory&lt;/strong&gt; 方法。&lt;/li&gt;
&lt;li&gt;其余所有的数据建议存放 &lt;strong&gt;Android/data/包名/&lt;/strong&gt; ，对应 &lt;strong&gt;getExternalCacheDirectories&lt;/strong&gt; 和 &lt;strong&gt;getExternalStorageDirectories&lt;/strong&gt; 方法。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;ios-文件存储&quot;&gt;iOS 文件存储&lt;/h3&gt;
&lt;p&gt;iOS 文件存储相比 Android 要简单的多，因为 iOS 对用户隐私保护非常严格，每个 iOS 应用程序都有一个单独的文件系统，而且只能在对应的文件系统中进行操作，此区域被称为沙盒。&lt;/p&gt;
&lt;p&gt;每个应用沙盒含有3个文件夹：Documents, Library 和 tmp：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202009/467322-20200918064929323-482694394.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Documents：应用程序数据文件写入到这个目录下。这个目录用于存储用户数据。保存应用程序的重要数据文件和用户数据文件等。iTunes 同步时会备份该目录，对应 &lt;strong&gt;getApplicationDocumentsDirectory&lt;/strong&gt; 方法。&lt;/li&gt;
&lt;li&gt;Library：对应 &lt;strong&gt;getLibraryDirectory&lt;/strong&gt; 方法。
&lt;ul&gt;&lt;li&gt;Caches：保存应用程序使用时产生的支持文件、缓存文件、日志文件等，比如下载的音乐,视频,SDWebImage缓存等。对应 &lt;strong&gt;getTemporaryDirectory&lt;/strong&gt; 方法。&lt;/li&gt;
&lt;li&gt;Preferences：包含应用程序的偏好设置文件，iCloud会备份设置信息。&lt;/li&gt;
&lt;li&gt;Application Support：对应 &lt;strong&gt;getApplicationSupportDirectory&lt;/strong&gt; 方法。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;tmp：存放临时文件，不会被备份，而且这个文件下的数据有可能随时被清除的可能，按照官方说法每三天清理一次缓存数据。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;path_provider-使用&quot;&gt;path_provider 使用&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;import 'dart:io';

import 'package:flutter/material.dart';
import 'package:path_provider/path_provider.dart';

///
/// desc:
///

class PathProviderDemo extends StatefulWidget {
  @override
  _PathProviderDemoState createState() =&amp;gt; _PathProviderDemoState();
}

class _PathProviderDemoState extends State&amp;lt;PathProviderDemo&amp;gt; {
  Future&amp;lt;Directory&amp;gt; _tempDirectory;
  Future&amp;lt;Directory&amp;gt; _appSupportDirectory;
  Future&amp;lt;Directory&amp;gt; _appLibraryDirectory;
  Future&amp;lt;Directory&amp;gt; _appDocumentsDirectory;
  Future&amp;lt;Directory&amp;gt; _externalStorageDirectory;
  Future&amp;lt;List&amp;lt;Directory&amp;gt;&amp;gt; _externalStorageDirectories;
  Future&amp;lt;List&amp;lt;Directory&amp;gt;&amp;gt; _externalCacheDirectories;
  Future&amp;lt;Directory&amp;gt; _downloadDirectory;

  @override
  void initState() {
    super.initState();
    setState(() {
      _tempDirectory = getTemporaryDirectory();
      _appSupportDirectory = getApplicationSupportDirectory();
      _appLibraryDirectory = getLibraryDirectory();
      _appDocumentsDirectory = getApplicationDocumentsDirectory();
      _externalStorageDirectory = getExternalStorageDirectory();
      _externalCacheDirectories = getExternalCacheDirectories();
      _externalStorageDirectories = getExternalStorageDirectories();
      _downloadDirectory = getDownloadsDirectory();
    });
  }

  Widget _buildDirectory(
      BuildContext context, AsyncSnapshot&amp;lt;Directory&amp;gt; snapshot) {
    Text text = const Text('');
    if (snapshot.connectionState == ConnectionState.done) {
      if (snapshot.hasError) {
        text = Text('Error: ${snapshot.error}');
      } else if (snapshot.hasData) {
        text = Text('path: ${snapshot.data.path}');
      } else {
        text = const Text('path unavailable');
      }
    }
    return Padding(padding: EdgeInsets.symmetric(horizontal: 16), child: text);
  }

  Widget _buildDirectories(
      BuildContext context, AsyncSnapshot&amp;lt;List&amp;lt;Directory&amp;gt;&amp;gt; snapshot) {
    Text text = const Text('');
    if (snapshot.connectionState == ConnectionState.done) {
      if (snapshot.hasError) {
        text = Text('Error: ${snapshot.error}');
      } else if (snapshot.hasData) {
        final String combined =
            snapshot.data.map((Directory d) =&amp;gt; d.path).join(', ');
        text = Text('paths: $combined');
      } else {
        text = const Text('path unavailable');
      }
    }
    return Padding(
        padding: const EdgeInsets.symmetric(horizontal: 16), child: text);
  }

  Widget _buildItem(String title, Future&amp;lt;Directory&amp;gt; future) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Padding(
          padding: const EdgeInsets.symmetric(horizontal: 16),
          child: Text(title),
        ),
        FutureBuilder&amp;lt;Directory&amp;gt;(future: future, builder: _buildDirectory),
      ],
    );
  }

  Widget _buildItem1(String title, Future&amp;lt;List&amp;lt;Directory&amp;gt;&amp;gt; future) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Padding(
          padding: const EdgeInsets.symmetric(horizontal: 16),
          child: Text(title),
        ),
        FutureBuilder&amp;lt;List&amp;lt;Directory&amp;gt;&amp;gt;(
            future: future,
            builder: _buildDirectories),
      ],
    );
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(),
      body: Center(
        child: ListView(
          itemExtent: 120,
          children: &amp;lt;Widget&amp;gt;[
            _buildItem('getTemporaryDirectory', _tempDirectory),
            _buildItem('getApplicationSupportDirectory', _appSupportDirectory),
            _buildItem('getLibraryDirectory', _appLibraryDirectory),
            _buildItem(
                'getApplicationDocumentsDirectory', _appDocumentsDirectory),
            _buildItem(
                'getExternalStorageDirectory', _externalStorageDirectory),
            _buildItem('getDownloadsDirectory', _downloadDirectory),

            _buildItem1('getExternalStorageDirectories',_externalStorageDirectories),
            _buildItem1('getExternalCacheDirectories',_externalCacheDirectories),

          ],
        ),
      ),
    );
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Android 系统各个路径：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202009/467322-20200918064929594-1699145300.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;iOS 系统各个路径：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202009/467322-20200918064929814-1311183596.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;交流&quot;&gt;交流&lt;/h2&gt;
&lt;h2 id=&quot;交流-2&quot;&gt;交流&lt;/h2&gt;
&lt;p&gt;老孟Flutter博客（330个控件用法+实战入门系列文章）：&lt;a href=&quot;http://laomengit.com&quot;&gt;http://laomengit.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎加入Flutter交流群（微信：laomengit）、关注公众号【老孟Flutter】：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th/&gt;
&lt;th/&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202009/467322-20200918064930216-554605029.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/td&gt;
&lt;td&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202009/467322-20200918064930503-1277457825.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;</description>
<pubDate>Thu, 17 Sep 2020 22:50:00 +0000</pubDate>
<dc:creator>老孟Flutter</dc:creator>
<og:description>老孟导读：Flutter 中获取文件路径，我们都知道使用 path_provider，但对其目录对含义不是很清楚，此文介绍 Android、iOS 系统的文件目录，不同场景下建议使用的目录。 不同的平</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mengqd/p/13689014.html</dc:identifier>
</item>
<item>
<title>规则引擎在IoT的重要性？ - 三升水</title>
<link>http://www.cnblogs.com/sanshengshui/p/13686677.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sanshengshui/p/13686677.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://james-1258744956.cos.ap-shanghai.myqcloud.com/rule-engine/Chestnut.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;物联网的强大功能主要来自于它使我们能够实时做出更准确的决策的能力，这些在通知、自动化和预测性维护上都有所体现。因此我们需要能对实时数据进行实时响应的工具，答案就是&lt;strong&gt;规则引擎&lt;/strong&gt;。规则引擎可以通过摄取实时数据，对该数据进行推理并根据该推理过程的结果调用&lt;strong&gt;自动操作&lt;/strong&gt;或者&lt;strong&gt;第三方API&lt;/strong&gt;来履行职责。&lt;/p&gt;
&lt;h2 id=&quot;iot案例探讨&quot;&gt;IoT案例探讨&lt;/h2&gt;
&lt;p&gt;这里有一个智能农业的场景：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;如果某种植物的生长需要维持恒温恒湿的环境，温度为18～20℃，相对湿度为85~90%。如果温度低于18℃，我们需要升温并对湿度进行补充；当高于20℃，我们需要降温并对湿度进行检查。
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;您可以在应用程序中轻松实现上述的规则或逻辑。但是，如果您将接到了其他一些需求，例如:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果存在大量逻辑，那么您将如何有效的编写和处理它们? (很好的代码设计模式)&lt;/li&gt;
&lt;li&gt;如果逻辑经常更改，并且您通常在应用程序中编写逻辑代码，那么您将如何管理或频繁更改代码? (避免频繁部署)&lt;/li&gt;
&lt;li&gt;设计应用程序以便让业务人员可以轻松维护和理解。（非技术成员使用）&lt;/li&gt;
&lt;li&gt;如果您必须将所有业务逻辑都放在一个项目中，和其他所有应用程序分开，那么您将在哪里保存它? （微服务架构）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;为了在我们的应用程序中满足所有这些要求，但是在启动规则引擎之前，让我们先了解一下规则引擎是什么?&lt;/p&gt;
&lt;h2 id=&quot;什么是规则引擎？&quot;&gt;什么是规则引擎？&lt;/h2&gt;
&lt;p&gt;下面是来自&lt;a href=&quot;https://martinfowler.com/&quot;&gt;Martin Fowler&lt;/a&gt;的一篇文章&lt;a href=&quot;https://martinfowler.com/bliki/RulesEngine.html&quot;&gt;“&lt;em&gt;我应该使用规则引擎吗？&lt;/em&gt;”&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;17&quot;&gt;
&lt;p&gt;规则引擎是一种工具，可以更轻松地使用此计算模型进行编程。它可能是完整的开发环境，也可能是可与传统平台一起使用的框架。近年来，我所见的大多数工具都是设计为适合现有平台的工具。曾经有一种想法是使用这样的工具来构建整个系统，但是现在人们（明智地）倾向于仅将规则引擎用于系统的各个部分。生产规则计算模型最适合仅解决一部分计算问题，因此规则引擎可以更好地嵌入到较大的系统中。&lt;/p&gt;
&lt;p&gt;您可以自己构建一个简单的规则引擎。您所需要做的就是创建一堆带有条件和动作的对象，将它们存储在一个集合中，然后遍历它们以评估条件并执行这些动作。但是大多数情况下，当人们提到“规则引擎”时，它们是指专门用来帮助您构建和运行规则引擎的产品。用于指定规则的技术可能有所不同，包括人们将API描述为Java对象的API，表达规则的DSL或允许人们输入规则的GUI。高效的执行引擎有助于使用专门的算法（例如Rete算法）快速评估数百条规则的条件。&lt;/p&gt;
&lt;p&gt;规则引擎的一个重要属性是&lt;strong&gt;链接&lt;/strong&gt; -一条规则的操作部分以改变另一条规则的条件部分的值的方式更改系统状态。链接听起来很吸引人，因为它支持更复杂的行为，但很容易导致很难推理和调试。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这是一个运行在数据上的系统程序, 如果任何条件匹配，那么它就会执行相应的操作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://james-1258744956.cos.ap-shanghai.myqcloud.com/rule-engine/rule-engine-system.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在上图中，显示了我们以规则(&lt;strong&gt;if-then&lt;/strong&gt;)的形式收集知识并将其存储在任何地方。规则可以存储在文件或数据库之类的任何存储中。现在，规则引擎根据需求选择规则，并在输入数据或查询上运行它们。如果有任何模式/条件匹配，则它将执行相应的操作并返回结果或解决方案。&lt;/p&gt;
&lt;h2 id=&quot;规则引擎的类型&quot;&gt;规则引擎的类型&lt;/h2&gt;
&lt;h3 id=&quot;前向链接forward-chaining引擎&quot;&gt;前向链接(Forward-Chaining)引擎&lt;/h3&gt;
&lt;p&gt;使用前向链接的推理引擎应用一组规则和事实来推导结论，搜索规则，直到发现IF子句为真为止。根据规则匹配新的或现有事实的过程称为模式匹配，它是由前向链接推理引擎通过各种算法执行的，如Linear、Rete、Treat、Leaps等。&lt;/p&gt;
&lt;p&gt;当发现条件为真时，引擎将执行THEN子句，这将导致向其数据集添加新信息。换句话说，引擎从大量事实开始，并应用规则从这些事实中得出所有可能的结论。这就是“前向链接”这一名称的由来——即推理引擎从数据开始，通过推理向前得到答案，这与反向链接相反，后者的工作方式是相反的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;应用案例：&lt;/strong&gt;目前市场上的大多数物联网平台实际上都有这种类型的规则引擎。下面是几个基于前向链接引擎的自动化工具的例子，这些工具在我们写这篇博客的时候已经在市场上出现了:Redhat Drools, Cumulocity, Eclipse Smart Home, AWS Rules, Thingsboard等等。&lt;/p&gt;
&lt;h3 id=&quot;条件动作condition-action引擎&quot;&gt;条件动作(Condition-Action)引擎&lt;/h3&gt;
&lt;p&gt;基于条件-动作(CA)规则引擎属于前向链接引擎，但存在一些相关的差异，特别是在物联网领域。与前向链接引擎相比，条件-动作规则引擎不允许多个条件，这使得它们一方面在逻辑表达能力上非常有限，另一方面——可伸缩性更强。条件操作规则引擎(如果-那么)有时使用ELSE语句进行扩展(如果-那么- 或者 - 那么)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;应用案例：&lt;/strong&gt;物联网领域中这种规则引擎最流行的例子之一是ifttt.com服务。&lt;/p&gt;
&lt;h3 id=&quot;流处理flow-processing引擎&quot;&gt;流处理(flow processing)引擎&lt;/h3&gt;
&lt;p&gt;基于流的编程是一种将应用程序定义为“黑盒”流程网络的编程范式。这些进程，即函数，被表示为节点，通过消息传递在预定义的连接之间交换数据。节点可以被不断地重新连接，从而形成不同的应用程序，而不必更改它们相关联的功能。&lt;/p&gt;
&lt;p&gt;基于流的编程(&lt;strong&gt;FBP&lt;/strong&gt;)自然是“面向组件的”。FBP的好处包括:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;更改连接接线而不重写组件。&lt;/li&gt;
&lt;li&gt;本质上是并发的——适合多核CPU世界。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;应用案例：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Yahoo! Pipes&lt;/strong&gt;和&lt;strong&gt;Node-RED&lt;/strong&gt;是使用基于流的编程构建的规则引擎的两个例子。随着“serverless”计算的引入，基于流的编程变得更加流行，在“serverless”计算中，可以通过链接函数构建云应用程序。&lt;/p&gt;
&lt;p&gt;IBM的OpenWhisk是一个基于流的编程示例，它通过链接云函数(IBM称之为动作)实现编程。另一种无服务器编排方法(如AWS step functions)基于有限状态机规则引擎。&lt;/p&gt;
&lt;h3 id=&quot;决策树decision-trees引擎&quot;&gt;决策树(decision trees)引擎&lt;/h3&gt;
&lt;p&gt;捕获条件规则复杂性的一种流行方法是使用决策树，决策树是使用分支方法来说明决策的每一个可能结果的图。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;应用案例：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Drools主要以其基于前向链接的规则引擎而闻名，它有一个可与决策表集成的扩展，可以将excel表与嵌入代码片段结合使用，以容纳任何额外的逻辑或所需的阈值。&lt;/p&gt;
&lt;h3 id=&quot;有限状态机finite-state-machines引擎&quot;&gt;有限状态机(finite state machines)引擎&lt;/h3&gt;
&lt;p&gt;状态机可用于根据系统经历的一组状态来描述系统。状态是对等待执行转换的系统状态的描述。过渡是在满足条件或接收到事件时要执行的一组动作。&lt;/p&gt;
&lt;p&gt;FSM的概念易于由不同类型的用户掌握。BRE（业务规则引擎）的主要销售论点是BRE软件允许非程序员在业务流程管理（BPM）系统中实现业务逻辑。&lt;/p&gt;
&lt;p&gt;FSM经常忽略的一件事是状态暗含着过渡，也就是说，将某种事物建模为状态的唯一目的是导航特定的决策流程。&lt;/p&gt;
&lt;p&gt;这样做的直接结果是，FSM缺乏可读性，因为规则变得更加复杂，或者需要将特定的极端情况建模为状态。由于FSM一次只能执行一个转换，因此当用户尝试引入在某些条件下可能发生的事件时，她需要添加一个新状态。当状态数过多时，状态机的可读性会大大下降。&lt;/p&gt;
&lt;h2 id=&quot;规则引擎的优势&quot;&gt;规则引擎的优势&lt;/h2&gt;
&lt;p&gt;我们可以将给定示例中的所有上述特定要求视为规则引擎的优势。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;规则很容易被业务分析师，客户团队等任何非技术人员阅读和编码。在这里，您必须专注于“该做什么”，而不是“该怎么做”。&lt;/li&gt;
&lt;li&gt;您可以将所有规则存储在中心存储中。这意味着您将拥有所有业务规则和逻辑的中心位置。这将是您的真理之源。&lt;/li&gt;
&lt;li&gt;逻辑与核心应用程序逻辑分开管理，因此可以对其进行管理和重用。&lt;/li&gt;
&lt;li&gt;在规则引擎中，我们使用不同的模式匹配和冲突解决算法，可提供高性能。&lt;/li&gt;
&lt;li&gt;对于经常变化的需求，我们可以轻松地更新规则。无需更改代码。&lt;/li&gt;
&lt;li&gt;如果代码包含许多决策点，则代码的复杂性会更高。规则引擎可以更好地处理它，因为它们使用业务规则的一致表示形式。&lt;/li&gt;
&lt;li&gt;不同的应用程序可以将相同的规则引擎用于相同的逻辑。它提高了可重用性。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://james-1258744956.cos.ap-shanghai.myqcloud.com/JWT-No-MySQL/%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BF%A1%E6%81%AF.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 17 Sep 2020 17:56:00 +0000</pubDate>
<dc:creator>三升水</dc:creator>
<og:description>前言 物联网的强大功能主要来自于它使我们能够实时做出更准确的决策的能力，这些在通知、自动化和预测性维护上都有所体现。因此我们需要能对实时数据进行实时响应的工具，答案就是规则引擎。规则引擎可以通过摄取实</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/sanshengshui/p/13686677.html</dc:identifier>
</item>
<item>
<title>【高并发】面试官：性能优化有哪些衡量指标？需要注意什么？ - 冰河团队</title>
<link>http://www.cnblogs.com/binghe001/p/13688432.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/binghe001/p/13688432.html</guid>
<description>&lt;h2 id=&quot;写在前面&quot;&gt;写在前面&lt;/h2&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;最近，很多小伙伴都在说，我没做过性能优化的工作，在公司只是做些CRUD的工作，接触不到性能优化相关的工作。现在出去找工作面试的时候，面试官总是问些很刁钻的问题来为难我，很多我都不会啊！那怎么办呢？那我就专门写一些与高并发系统相关的面试容易问到的问题吧。今天，我们就来说说在高并发场景下做性能优化有哪些衡量标准，以及做优化时需要注意哪些问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;面试场景&quot;&gt;面试场景&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;面试官：平时工作中有没有做过一些性能优化相关的工作呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先，我们来分析下面试官的这个问题。其实，以我本人招聘面试的经验来说，如果面试官问出了这样的一个问题。本质上不只是想让面试者简单的回答：做过或者没做过。而是想通过这个简单的问题来考察下面试者的思考能力和对于问题的理解能力。面试官本质上是想让面试者通过这个问题，讲述一下自己做性能优化相关工作的经验、以及对于性能优化工作的一些理论的理解，比如就包括：性能优化的衡量指标，期间需要注意的问题等等。&lt;/p&gt;
&lt;p&gt;如果面试者在面试过程中，不能充分理解面试官的意图，回答问题时，像挤牙膏一样，挤点出点，那么，大多数情况下，面试官就会认为这个人没啥性能优化的经验。此时，面试者就会在面试官心理的印象大打折扣，面试结果就有非常大的概率凉凉了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200917231719280.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;衡量指标&quot;&gt;衡量指标&lt;/h2&gt;
&lt;p&gt;对于性能优化来说，衡量的指标有很多，大体上可以分为：性能指标、响应时间、并发量、秒开率和正确性等。我们可以使用下图来表示这些衡量指标。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200917231734525.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来，我们就分别说明下这些衡量指标。&lt;/p&gt;
&lt;h3 id=&quot;性能指标&quot;&gt;性能指标&lt;/h3&gt;
&lt;p&gt;性能指标又可以包含：吞吐量和响应速度。我们平时所说的QPS、TPS和HPS等，就可以归结为吞吐量。有很多小伙伴可能对于QPS、TPS和HPS等不太了解，我们先来说下这几个字母的含义。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;QPS代表的是每秒的查询数量。&lt;/li&gt;
&lt;li&gt;TPS代表的是每秒事务的数量。&lt;/li&gt;
&lt;li&gt;HPS代表的是每秒的HTTP请求数量。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这些都是与吞吐量相关的衡量指标。&lt;/p&gt;
&lt;p&gt;平时我们在做优化工作的时候，首先要明确需要优化的事项。比如：我们做的优化工作是要提高系统的吞吐量？还是要提升系统的响应速度呢？举一个具体点的例子：比如我们的程序中存在一些数据库或者缓存的批量操作，虽然在数据的读取上，响应速度下降了，但是我们优化的目标就是吞吐量，只要我们优化后系统的整体吞吐量明显上升了，那这也是提升了程序的性能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所以说，优化性能不只是提升系统的响应速度。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里，优化性能也并不是一味的优化吞吐量和优化响应速度，而是在吞吐量和响应速度之间找到一个平衡点，使用有限的服务器资源来更好的提升用户体验。&lt;/p&gt;
&lt;h3 id=&quot;响应时间&quot;&gt;响应时间&lt;/h3&gt;
&lt;p&gt;对于响应时间来说，有两个非常重要的衡量指标。那就是：&lt;strong&gt;平均响应时间和百分位数。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（1）平均响应时间&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通常，平均响应时间体现的是服务接口的平均处理能力。计算方式就是把所有的请求所耗费的时间加起来，然后除以请求的次数。举个简单的例子：比如：我们向一个网站发送了5次请求，每次请求所耗费的时间分别为：1ms，2ms，1ms，3ms，2ms，那么，平均响应时间就是（1+2+1+3+2）/ 5 = 1.8ms，所以，平均响应时间就是1.8ms。&lt;/p&gt;
&lt;p&gt;平均响应时间这个指标存在一个问题：如果在短时间内请求变得很慢，但很快过去了，此时使用平均响应时间就无法很好的体现出性能的波动问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（2）百分位数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;百分位数就是我们在优化的时候，圈定一个时间范围，把每次请求的耗时加入一个列表中，然后按照从小到大的顺序将这些时间进行排序。这样，我们取出特定百分位的耗时，这个数字就是 TP 值。&lt;/p&gt;
&lt;p&gt;TP值表示的含义就是：超过 N% 的请求都在 X 时间内返回。比如 TP90 = 50ms，意思是超过 90th 的请求，都在 50ms 内返回。&lt;/p&gt;
&lt;p&gt;百分位数这个指标也是很重要的，它反映的是应用接口的整体响应情况。&lt;/p&gt;
&lt;p&gt;我们一般会将百分位数分为 TP50、TP90、TP95、TP99、TP99.9 等多个段，对高百分位的值要求越高，对系统响应能力的稳定性要求越高。&lt;/p&gt;
&lt;h3 id=&quot;并发量&quot;&gt;并发量&lt;/h3&gt;
&lt;p&gt;并发量指的是系统能够同时处理的请求数量，反映的是系统的负载能力。&lt;/p&gt;
&lt;p&gt;我们在对高并发系统进行优化的时候，往往也会在并发量上进行调优，调优方式也是多种多样的，目的就是提高系统同时处理请求的能力。&lt;/p&gt;
&lt;p&gt;总体来说，并发量这个指标理解起来还是比较简单的，我就不做过多的描述了。&lt;/p&gt;
&lt;h3 id=&quot;秒开率&quot;&gt;秒开率&lt;/h3&gt;
&lt;p&gt;秒开率主要针对的是前端网页或者移动端APP来说的，如果一个前端网页或者APP能够在1秒内很平滑的打开，尤其是首页的加载。此时，用户就会感到前端网页或者APP使用起来很顺畅，如果超过3秒甚至更长的时间，用户就有可能会直接退出前端网页或者APP不再使用。&lt;/p&gt;
&lt;p&gt;所以，在高并发场景下优化程序，不只要对后端程序进行优化，对于前端和APP也是要进行优化的。&lt;/p&gt;
&lt;h3 id=&quot;正确性&quot;&gt;正确性&lt;/h3&gt;
&lt;p&gt;正确性说的是无论我们以何种方式，何种手段对应用进行优化，优化后的交互数据结果必须是正确的。不能出现优化前性能比较低，数据正确，而优化后性能比较高，反而数据不正确的现象。&lt;/p&gt;
&lt;h2 id=&quot;优化需要注意的问题&quot;&gt;优化需要注意的问题&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200917231746932.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;除非必要,一开始不要优化(尤其是开发阶段)&lt;/li&gt;
&lt;li&gt;有些优化准则已经过时,需要考虑当下的软硬件环境(不要墨守成规)&lt;/li&gt;
&lt;li&gt;不要过分强调某些系统级指标,如cache 命中率,而应该聚焦性能瓶颈点&lt;/li&gt;
&lt;li&gt;不盲从，测试、找到系统的性能瓶颈，再确定优化手段&lt;/li&gt;
&lt;li&gt;注意权衡优化的成本和收益（有些优化可能需要现有架构做出调整、增加开发/运维成本）&lt;/li&gt;
&lt;li&gt;优化的目标是用户体验、降低硬件成本（降低集群规模、不依赖单机高性能）&lt;/li&gt;
&lt;li&gt;测试环境的优化手段未必对生产环境有效（优化需要针对真实情况）&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;重磅福利&quot;&gt;重磅福利&lt;/h2&gt;
&lt;p&gt;关注「 &lt;strong&gt;冰河技术&lt;/strong&gt; 」微信公众号，后台回复 “&lt;strong&gt;设计模式&lt;/strong&gt;” 关键字领取《&lt;strong&gt;深入浅出Java 23种设计模式&lt;/strong&gt;》PDF文档。回复“&lt;strong&gt;Java8&lt;/strong&gt;”关键字领取《&lt;strong&gt;Java8新特性教程&lt;/strong&gt;》PDF文档。回复“&lt;strong&gt;限流&lt;/strong&gt;”关键字获取《&lt;strong&gt;亿级流量下的分布式限流解决方案&lt;/strong&gt;》PDF文档，三本PDF均是由冰河原创并整理的超硬核教程，面试必备！！&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;好了，今天就聊到这儿吧！别忘了点个赞，给个在看和转发，让更多的人看到，一起学习，一起进步！！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;写在最后&quot;&gt;写在最后&lt;/h2&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;如果你觉得冰河写的还不错，请微信搜索并关注「 &lt;strong&gt;冰河技术&lt;/strong&gt; 」微信公众号，跟冰河学习高并发、分布式、微服务、大数据、互联网和云原生技术，「 &lt;strong&gt;冰河技术&lt;/strong&gt; 」微信公众号更新了大量技术专题，每一篇技术文章干货满满！不少读者已经通过阅读「 &lt;strong&gt;冰河技术&lt;/strong&gt; 」微信公众号文章，吊打面试官，成功跳槽到大厂；也有不少读者实现了技术上的飞跃，成为公司的技术骨干！如果你也想像他们一样提升自己的能力，实现技术能力的飞跃，进大厂，升职加薪，那就关注「 &lt;strong&gt;冰河技术&lt;/strong&gt; 」微信公众号吧，每天更新超硬核技术干货，让你对如何提升技术能力不再迷茫！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200906013715889.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 17 Sep 2020 15:22:00 +0000</pubDate>
<dc:creator>冰河团队</dc:creator>
<og:description>写在前面 最近，很多小伙伴都在说，我没做过性能优化的工作，在公司只是做些CRUD的工作，接触不到性能优化相关的工作。现在出去找工作面试的时候，面试官总是问些很刁钻的问题来为难我，很多我都不会啊！那怎么</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/binghe001/p/13688432.html</dc:identifier>
</item>
</channel>
</rss>