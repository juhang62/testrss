<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Django的Admin站点管理 - 哈撒king</title>
<link>http://www.cnblogs.com/Rain2017/p/10269665.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Rain2017/p/10269665.html</guid>
<description>&lt;h3&gt;一、概述&lt;/h3&gt;
&lt;p&gt;　　内容发布：负责添加、修改、删除内容&lt;/p&gt;
&lt;p&gt;　　公告访问&lt;/p&gt;
&lt;h3&gt;二、配置Admin应用&lt;/h3&gt;
&lt;p&gt;　　在settings.py文件中的INSTALLED_APPS中添加'django.contrib.admin'，&lt;span&gt;默认&lt;/span&gt;是添加好的&lt;/p&gt;
&lt;h3&gt;三、创建管理员用户&lt;/h3&gt;
&lt;p&gt;　　在项目的根目录下，执行命令：python manage.py createsuperuser&lt;/p&gt;
&lt;p&gt;依次输入用户名、邮箱、密码（密码不能太复杂）&lt;/p&gt;
&lt;h3&gt;四、汉化&lt;/h3&gt;
&lt;p&gt;　　修改setting.py&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
LANGUAGE_CODE = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;zh-Hans&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
TIME_ZONE &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Asia/Shanghai&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;五、管理数据表&lt;/h3&gt;

</description>
<pubDate>Mon, 14 Jan 2019 15:23:00 +0000</pubDate>
<dc:creator>哈撒king</dc:creator>
<og:description>一、概述 内容发布：负责添加、修改、删除内容 公告访问 二、配置Admin应用 在settings.py文件中的INSTALLED_APPS中添加'django.contrib.admin</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Rain2017/p/10269665.html</dc:identifier>
</item>
<item>
<title>设计模式第七篇-适配器模式 - 茶底世界</title>
<link>http://www.cnblogs.com/yuanqinnan/p/10217368.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuanqinnan/p/10217368.html</guid>
<description>&lt;h2&gt;一、引言&lt;/h2&gt;
&lt;p&gt;最近懒劲又上来了，隔了几天没有学习，最近的博文阅读量也比较少，不过还是希望自己坚持下去，相信水滴石穿，量变总会引起质变的。&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;今天要学习的是适配器模式，顾名思义，适配器模式是将两个不兼容的接口进行适配，类似转换器的功能。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;先看一个例子，我们一个播放器，它有一个播放功能（继承一个播放接口，只有一个播放方法），最开始的时候它只支持播放MP3功能，现随着播放源的增多，我们想让它支持播放更多的文件类型。有一个厂商提供了其他的播放接口，但是其中的方法并不是叫做播放方法，这个时候我们必须把新厂商的接口转换成开始继承的播放接口，也就是把现在厂商的接口伪装成最先继承的播放接口，让它能够适配原先的方法&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;实际目的是让将一个接口转换成客户想要的另一个接口，适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;二、适配器模式&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;定义：&lt;/strong&gt;&lt;span&gt;适配器模式把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;意图：&lt;/strong&gt;&lt;span&gt;将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;主要解决：&lt;/strong&gt;&lt;span&gt;主要解决在软件系统中，常常要将一些&quot;现存的对象&quot;放到新的环境中，而新环境要求的接口是现对象不能满足的。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;何时使用：&lt;/strong&gt; &lt;span&gt;1、系统需要使用现有的类，而此类的接口不符合系统的需要。 2、想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作，这些源类不一定有一致的接口。 3、通过接口转换，将一个类插入另一个类系中。（比如老虎和飞禽，现在多了一个飞虎，在不增加实体的需求下，增加一个适配器，在里面包容一个虎对象，实现飞的接口。）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;&lt;strong&gt;如何解决：&lt;/strong&gt;&lt;span&gt;继承或依赖&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;strong&gt;类图：&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201901/1113901-20190114231519262-321141700.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;三、代码实现&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;原先的播放器接口&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; MediaPlayer {
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; play(String audioType, String fileName);
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;新的高级播放器接口&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; AdvancedMediaPlayer {
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; playVlc(String fileName);
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; playMp4(String fileName);
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;继承高级播放接口的MP4播放器&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Mp4Player &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; AdvancedMediaPlayer {
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; playVlc(String fileName) {
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; playMp4(String fileName) {
        System.out.println(&lt;/span&gt;&quot;Playing mp4 file. Name: &quot;+&lt;span&gt; fileName);
    }
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;继承高级播放接口的VlC播放器&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; VlcPlayer &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; AdvancedMediaPlayer {
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; playVlc(String fileName) {
        System.out.println(&lt;/span&gt;&quot;Playing vlc file. Name: &quot;+&lt;span&gt; fileName);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; playMp4(String fileName) {

    }
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;适配器类&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MediaAdapter &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; MediaPlayer {
    MediaAdapter mediaAdapter; 
    AdvancedMediaPlayer advancedMediaPlayer;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; MediaAdapter(String audioType){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(audioType.equalsIgnoreCase(&quot;vlc&quot;&lt;span&gt;)){
            advancedMediaPlayer&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; VlcPlayer();
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            advancedMediaPlayer&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Mp4Player();
        }
    }

    @Override
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将现在的接口方法转换成原先接口的方法&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; play(String audioType, String fileName) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(audioType.equalsIgnoreCase(&quot;vlc&quot;&lt;span&gt;)){
            advancedMediaPlayer.playVlc(fileName);
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            advancedMediaPlayer.playMp4(fileName);
        }
    }
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;播放器&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; AudioPlayer &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; MediaPlayer  {
    MediaAdapter mediaAdapter;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; play(String audioType, String fileName) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;播放 mp3 音乐文件的内置支持&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(audioType.equalsIgnoreCase(&quot;mp3&quot;&lt;span&gt;)){
            System.out.println(&lt;/span&gt;&quot;Playing mp3 file. Name: &quot;+&lt;span&gt; fileName);
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;mediaAdapter 提供了播放其他文件格式的支持&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(audioType.equalsIgnoreCase(&quot;vlc&quot;&lt;span&gt;)
                &lt;/span&gt;|| audioType.equalsIgnoreCase(&quot;mp4&quot;&lt;span&gt;)){
            mediaAdapter &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MediaAdapter(audioType);
            mediaAdapter.play(audioType, fileName);
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            System.out.println(&lt;/span&gt;&quot;Invalid media. &quot;+&lt;span&gt;
                    audioType &lt;/span&gt;+ &quot; format not supported&quot;&lt;span&gt;);
        }
    }
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;实现&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; adapter() {
        AudioPlayer audioPlayer &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AudioPlayer();
        audioPlayer.play(&lt;/span&gt;&quot;mp3&quot;, &quot;beyond the horizon.mp3&quot;&lt;span&gt;);
        audioPlayer.play(&lt;/span&gt;&quot;mp4&quot;, &quot;alone.mp4&quot;&lt;span&gt;);
        audioPlayer.play(&lt;/span&gt;&quot;vlc&quot;, &quot;far far away.vlc&quot;&lt;span&gt;);
        audioPlayer.play(&lt;/span&gt;&quot;avi&quot;, &quot;mind me.avi&quot;&lt;span&gt;);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;结果：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201901/1113901-20190114231949497-185740072.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;四、总结&lt;/h2&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;优点：&lt;/strong&gt; &lt;span&gt;1、可以让任何两个没有关联的类一起运行。 2、提高了类的复用。 3、增加了类的透明度。 4、灵活性好。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;缺点：&lt;/strong&gt; &lt;span&gt;1、过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。 2.由于 JAVA 至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;使用场景：&lt;/strong&gt;&lt;span&gt;有动机地修改一个正常运行的系统的接口，这时应该考虑使用适配器模式。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;&lt;strong&gt;注意事项：&lt;/strong&gt;&lt;span&gt;适配器不是在详细设计时添加的，而是解决正在服役的项目的问题。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;&lt;span&gt;源代码地址：&lt;a title=&quot;源码地址&quot; href=&quot;https://gitee.com/yuanqinnan/pattern&quot; target=&quot;_blank&quot;&gt;https://gitee.com/yuanqinnan/pattern&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 14 Jan 2019 15:18:00 +0000</pubDate>
<dc:creator>茶底世界</dc:creator>
<og:description>一、引言 最近懒劲又上来了，隔了几天没有学习，最近的博文阅读量也比较少，不过还是希望自己坚持下去，相信水滴石穿，量变总会引起质变的。 今天要学习的是适配器模式，顾名思义，适配器模式是将两个不兼容的接口</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yuanqinnan/p/10217368.html</dc:identifier>
</item>
<item>
<title>轻松实现支付宝服务窗网页授权从配置到获取授权获取用户信息 - 追逐时光</title>
<link>http://www.cnblogs.com/Can-daydayup/p/10269630.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Can-daydayup/p/10269630.html</guid>
<description>&lt;h2&gt;&lt;span&gt;前言：&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　&lt;span&gt;　最近在开发一个商业街区的聚合扫码支付功能，其中需要用到的有支付宝，微信两种支付方式，当然对于开发微信支付而已作为自己的老本行已经比较熟悉了，然而对于我来说支付宝支付还是头一次涉及到。这次项目中需要用到的是支付宝公众号支付这一功能，因为需要进行支付宝授权获取到用户的User_ID然后在进行支付宝公众号支付,在这里我就顺带把用户信息也获取了。因为第一次玩，大概配置支付宝开发平台的应用信息到获取到用户User_ID遇到了几个坑，今天记录一下希望能够帮助一下没有做个这样方面的同仁哪些的方有坑，并且加深一下自己的印象，最后我要声明一下我所开发语言是.net mvc 非JAVA，因为这里java和非java的秘钥生成的秘钥格式有所不同。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;第一步：登录支付宝开放平台，注册开发者，创建应用添加所需功能和配置应用信息：&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;&lt;span&gt;登录地址:&lt;a href=&quot;https://openhome.alipay.com/&quot; target=&quot;_blank&quot;&gt;https://openhome.alipay.com/&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;h3&gt;&lt;span&gt;&lt;span&gt;1、创建应用：点击开发者中心&amp;gt;创建一个应用&amp;gt;获取拿到对应应用的appid（后期程序中会用到）&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;h3&gt;&lt;span&gt;&lt;span&gt;2、添加对应功能：因为我在这里只需要使用到获取会员信息授权的功能，所以添加（获取会员信息的功能即可），如下图所示：&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1336199/201901/1336199-20190114215533810-338933597.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1336199/201901/1336199-20190114215546244-2055946599.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;第三步、应用信息配置，这里最为主要的还是RSA(SHA256)密钥生成，有坑需注意：&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;在应用信息配置的时候我们需要配置：应用网管（没有时不需要配置），授权回调地址，加签方式（RSA(SHA256)密钥）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.这里主要讲的是RSA(SHA256秘钥生成)：在这里首先我们下载秘钥生成工具使用这个最后，可视化（window系统的用户）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下载地址：&lt;a href=&quot;https://docs.open.alipay.com/291/105971&quot; target=&quot;_blank&quot;&gt;https://docs.open.alipay.com/291/105971&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;秘钥生成指导视频：&lt;a href=&quot;https://openclub.alipay.com/index.php?c=read&amp;amp;a=video&amp;amp;fid=76&amp;amp;tid=3699&quot; target=&quot;_blank&quot;&gt;https://openclub.alipay.com/index.php?c=read&amp;amp;a=video&amp;amp;fid=76&amp;amp;tid=3699&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.下载完成后我们需要打开工具，这里还要强调一下因为我是.Net MVC，所以我们要选择的Rsa秘钥格式为：PKCS1(非Java适用)，秘钥长度选择2048（因为支付宝配置所需的是RSA256,假如是RSA的话适用1024即可），如下图所示：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1336199/201901/1336199-20190114221400353-1264471073.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;第二步：适用.Net MVC 实现支付宝网页授权代码（功能可以，已在开发环境适用此代码）：&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;1.了解支付宝授权的流程：&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1336199/201901/1336199-20190114223902094-1699247033.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;如上图所示，需要拿取到用户信息需要分四步走：&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;1、获取Auth_Code（授权码）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、通过Auth_Code换取接口access_token及其用户user_id&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、调用接口获取用户信息&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;2.代码实现：&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;在写代码之前，先下载 &lt;a href=&quot;https://pan.baidu.com/s/1CeKWycjpCIWNmeqg89McMg&quot; target=&quot;_blank&quot;&gt;AopSdk.dll&lt;/a&gt; （我编译，生产的SDK）阿里已经给我们写好了所需的方法我们只需调用其类型，传递参数即可。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;阿里未编译的SDK下载地址：&lt;a href=&quot;https://docs.open.alipay.com/54/103419&quot; target=&quot;_blank&quot;&gt;https://docs.open.alipay.com/54/103419&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;猛料来了，业务逻辑实现：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;54&quot;&gt;
&lt;pre readability=&quot;4&quot;&gt;
&lt;span&gt;#region&lt;/span&gt; 支付宝网页授权获取userid
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt;&lt;span&gt;支付宝授权登录
&lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;Sid&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;店铺编号&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; ActionResult SupplierAliPay(&lt;span&gt;)
{
&lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
{
&lt;/span&gt;&lt;span&gt;string&lt;/span&gt; ReturnUrl = &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;第一步：获取auth_code接口拼接&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; admins = &lt;span&gt;new&lt;/span&gt; admins { Id = &lt;span&gt;1&lt;/span&gt;&lt;span&gt; }.SelectObject();
&lt;/span&gt;&lt;span&gt;string&lt;/span&gt; AliRedirect_url =&quot;获取回调地址&lt;span&gt;&quot;&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;http请求格式必须与公众平台配置的一致&lt;/span&gt;
&lt;span&gt;//注意假如你需要获取到用户的新的的话SCOPe类型使用auth_userinfo,而我在支付那里使用的是auth_base这样不需要用户授权，可以让用户丝毫没有感觉，体验性好
ReturnUrl &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://openauth.alipay.com/oauth2/publicAppAuthorize.htm?app_id=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +应用APPid+ &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;amp;scope=auth_base&amp;amp;state=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + 自定义参数（非必填）+ &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;amp;redirect_uri=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + Url.Encode(AliRedirect_url) + &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Redirect(ReturnUrl);
}
&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
{
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; View(&lt;span&gt;);
}
}

&lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt;&lt;span&gt;获取用户buyer_id调转AliPaypage获取支付宝账号的userid (授权回调)
&lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;auth_code&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;state&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt;  ActionResult GetUserAliUserID(&lt;span&gt;string&lt;/span&gt; auth_code, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; state)
{

&lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
{
auth_code&lt;/span&gt;= Request.QueryString[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;auth_code&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];//授权码
state &lt;/span&gt;= Request.QueryString[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;state&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span readability=&quot;2&quot;&gt;];&lt;p&gt;string AliAppid=&quot;&quot;;//支付宝应用Appid
&lt;/p&gt;&lt;/span&gt;&lt;span&gt;string&lt;/span&gt; Userid = &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;//支付宝用户唯一编号&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;应用私钥&lt;/span&gt;
&lt;span&gt;string&lt;/span&gt; YOUR_PRIVATE_KEY= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;支付宝公钥&lt;/span&gt;
&lt;span&gt;string&lt;/span&gt; ALIPAY_PUBLIC_KEY = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                    
 Aop.Api.IAopClient client &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; DefaultAopClient(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://openapi.alipay.com/gateway.do&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,AliAppid, YOUR_PRIVATE_KEY, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1.0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;RSA2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, ALIPAY_PUBLIC_KEY, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;GBK&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取access_token&lt;/span&gt;
AlipaySystemOauthTokenRequest requestAccess_token = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AlipaySystemOauthTokenRequest();
requestAccess_token.GrantType &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;authorization_code&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
requestAccess_token.Code &lt;/span&gt;=&lt;span&gt; auth_code;
AlipaySystemOauthTokenResponse responseAccess_token &lt;/span&gt;=&lt;span&gt; client.Execute(requestAccess_token);
&lt;br/&gt;Userid &lt;/span&gt;= responseAccess_token.UserId;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;支付宝用户的唯一userId &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;responseAccess_token.AlipayUserId;用户的open_id（ 已废弃，请勿使用 ）&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;  //获取用户信息，通过access_token调用用户信息共享接口获取用户信息&lt;br/&gt;  AlipayUserInfoShareRequest requestUserinfo = new AlipayUserInfoShareRequest();&lt;br/&gt;  AlipayUserInfoShareResponse responseUserinfo = client.Execute(requestUserinfo, responseAccess_token.AccessToken);&lt;br/&gt;  UserName = responseUserinfo.NickName;&lt;br/&gt;  Address = responseUserinfo.City;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;return&lt;/span&gt; Redirect(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/mobile_user/HstyAliPayPayment/AliPayPage?Sid=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+Sid+ &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;amp;buyer_id=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+Userid+&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;);
}
&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
{
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; view();&lt;span&gt;
}
}
&lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;总结：&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;span&gt;其实做第三方对接开发的时候我们第一要做的是读懂文档，熟悉开发流程，流程不清晰可能导致程序设计推翻重做，有的时候往往一个空格一个字母问题可以让你找上一天，所以做任何事情我们都要细心、仔细、认真。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 14 Jan 2019 15:09:00 +0000</pubDate>
<dc:creator>追逐时光</dc:creator>
<og:description>前言： 最近在开发一个商业街区的聚合扫码支付功能，其中需要用到的有支付宝，微信两种支付方式，当然对于开发微信支付而已作为自己的老本行已经比较熟悉了，然而对于我来说支付宝支付还是头一次涉及到。这次项目中</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Can-daydayup/p/10269630.html</dc:identifier>
</item>
<item>
<title>轻量级.Net Core服务注册工具CodeDi发布啦 - 码农阿宇</title>
<link>http://www.cnblogs.com/CoderAyu/p/10269610.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CoderAyu/p/10269610.html</guid>
<description>&lt;h2 id=&quot;为什么做这么一个工具&quot;&gt;为什么做这么一个工具&lt;/h2&gt;
&lt;p&gt;因为我们的系统往往时面向接口编程的,所以在开发Asp .net core项目的时候,一定会有大量大接口及其对应的实现要在&lt;code&gt;ConfigureService&lt;/code&gt;注册到&lt;code&gt;ServiceCollection&lt;/code&gt;中,传统的做法是加了一个服务,我们就要注册一次(&lt;code&gt;service.AddService()&lt;/code&gt;),又比如,当一个接口有多个实现,在构造函数中获取服务也不是很友好,而据我所知, .Net Core目前是没有什么自带的库或者方法解决这些问题,当然,如果引入第三方容器如AutoFac这些问题时能迎刃而解的,但是如何在不引入第三方容器来解决这个问题呢?&lt;br/&gt;所以我就设计了这样的一个轻量级工具.&lt;/p&gt;
&lt;p&gt;首先,放上该项目的Github地址(记得Star哦!!)&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/liuzhenyulive/CodeDi&quot; class=&quot;uri&quot;&gt;https://github.com/liuzhenyulive/CodeDi&lt;/a&gt;&lt;a href=&quot;https://ci.appveyor.com/project/liuzhenyulive/codedi&quot;&gt;&lt;img src=&quot;https://ci.appveyor.com/api/projects/status/eeo8aua4n8r5fnce?svg=true&quot; alt=&quot;Build status&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;CodeDi是一个基于 .Net Standard的工具库,它能帮助我们自动地在Asp .net core或者 .net core项目中完成服务的注册.&lt;/p&gt;
&lt;h2 id=&quot;overview&quot;&gt;Overview&lt;/h2&gt;
&lt;p&gt;CodeDi 是 Code Dependency Injection的意思,在上次我在看了由依乐祝写的&lt;a href=&quot;https://www.cnblogs.com/yilezhu/p/10236163.html&quot; title=&quot;.NET Core中的一个接口多种实现的依赖注入与动态选择看这篇就够了&quot;&gt;&amp;lt;.NET Core中的一个接口多种实现的依赖注入与动态选择看这篇就够了&amp;gt;&lt;/a&gt;后,回想起我之前遇到的那些问题,感觉拨云见日,所以,我就开始着手写这个工具了.&lt;/p&gt;
&lt;h2 id=&quot;如何使用codedi&quot;&gt;如何使用CodeDi&lt;/h2&gt;
&lt;h3 id=&quot;安装nuget包&quot;&gt;安装Nuget包&lt;/h3&gt;
&lt;p&gt;CodeDi的Nuget包已经发布到了 nuget.org,您可以通过以下指令在您的项目中安装CodeDi&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;PM&amp;gt; Install-Package CodeDi&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;configureservices中的配置&quot;&gt;ConfigureServices中的配置&lt;/h3&gt;
&lt;h4 id=&quot;方法-1&quot;&gt;方法 1&lt;/h4&gt;
&lt;p&gt;您可以在&lt;code&gt;Startup&lt;/code&gt;的&lt;code&gt;ConfigureService&lt;/code&gt;方法中添加AddCodeDi完成对CodeDi的调用.服务的注册CodeDi会自动为您完成.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;        public void ConfigureServices(IServiceCollection services)
        {
            services.AddCoreDi();
            services.AddMvc();
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;方法-2&quot;&gt;方法 2&lt;/h4&gt;
&lt;p&gt;您也可以在AddCodeDi方法中传入一个&lt;code&gt;Action&amp;lt;CodeDiOptions&amp;gt;&lt;/code&gt;参数,在这个action中,您可以对CodeDiOptions的属性进行配置.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;       public void ConfigureServices(IServiceCollection services)
        {
            services.AddCoreDi(options =&amp;gt;
            {
                options.DefaultServiceLifetime = ServiceLifetime.Scoped;

            });
            services.AddMvc();
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;方法-3&quot;&gt;方法 3&lt;/h4&gt;
&lt;p&gt;当然您也可以直接给&lt;code&gt;AddCodeDi()&lt;/code&gt;方法直接传入一个&lt;code&gt;CodeDiOptions&lt;/code&gt;实例.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;        public void ConfigureServices(IServiceCollection services)
        {
            services.AddCoreDi(new CodeDiOptions()
            {
                DefaultServiceLifetime = ServiceLifetime.Scoped
            });
            services.AddMvc();
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你也可以在&lt;code&gt;appsetting.json&lt;/code&gt;文件中配置&lt;code&gt;CodeDiOptions&lt;/code&gt;的信息,并通过&lt;code&gt;Configuration.Bind(&quot;CodeDiOptions&quot;, options)&lt;/code&gt;把配置信息绑定到一个&lt;code&gt;CodeDiOptions&lt;/code&gt;实例.&lt;/p&gt;
&lt;p&gt;appsetting.json file&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
  &quot;Logging&quot;: {
    &quot;LogLevel&quot;: {
      &quot;Default&quot;: &quot;Warning&quot;
    }
  },
  &quot;AllowedHosts&quot;: &quot;*&quot;,
  &quot;CodeDiOptions&quot;: {
    &quot;DefaultServiceLifetime&quot;: 1,
    &quot;AssemblyNames&quot;: [
      &quot;*CodeDi&quot;
    ],
    &quot;AssemblyPaths&quot;: [
      &quot;C:\\MyBox\\Github\\CodeDI\\CodeDI\\bin\\Debug\\netstandard2.0&quot;
    ],
    &quot;IgnoreAssemblies&quot;: [
      &quot;*Test&quot;
    ],
    &quot;IncludeSystemAssemblies&quot;: false,
    &quot;IgnoreInterface&quot;: [
      &quot;*Say&quot;
    ],
    &quot;InterfaceMappings&quot;: {
      &quot;*Say&quot;: &quot;*English&quot;
    },
    &quot;ServiceLifeTimeMappings&quot;: {
      &quot;*Say&quot;: 0
    }
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ConfigureService方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;        public void ConfigureServices(IServiceCollection services)
        {
            var options=new CodeDiOptions();
            Configuration.Bind(&quot;CodeDiOptions&quot;, options);
            services.AddCoreDi(options);
            services.AddMvc();
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;codedioptions详解&quot;&gt;CodeDiOptions详解&lt;/h3&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;19.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;AssemblyPaths&lt;/td&gt;
&lt;td&gt;在指定目录下加载Dll程序集&lt;/td&gt;
&lt;td&gt;string[]&lt;/td&gt;
&lt;td&gt;Bin目录&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;AssemblyNames&lt;/td&gt;
&lt;td&gt;选择要加载的程序集名称 (支持通配符)&lt;/td&gt;
&lt;td&gt;string[]&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;IgnoreAssemblies&lt;/td&gt;
&lt;td&gt;忽略的程序集名称 (支持通配符)&lt;/td&gt;
&lt;td&gt;string[]&lt;/td&gt;
&lt;td&gt;null&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;10&quot;&gt;&lt;td&gt;IncludeSystemAssemblies&lt;/td&gt;
&lt;td&gt;是否包含系统程序集(当为false时,会忽略含有System,Microsoft,CppCodeProvider,WebMatrix,SMDiagnostics,Newtonsoft关键词和在App_Web,App_global目录下的程序集)&lt;/td&gt;
&lt;td&gt;bool&lt;/td&gt;
&lt;td&gt;false&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;IgnoreInterface&lt;/td&gt;
&lt;td&gt;忽略的接口 (支持通配符)&lt;/td&gt;
&lt;td&gt;string[]&lt;/td&gt;
&lt;td&gt;null&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;9&quot;&gt;&lt;td&gt;InterfaceMappings&lt;/td&gt;
&lt;td&gt;接口对应的服务 (支持通配符) ,当一个接口有多个实现时,如果不进行配置,则多个实现都会注册到SerciceCollection中&lt;/td&gt;
&lt;td&gt;Dictionary&amp;lt;string, string&amp;gt;&lt;/td&gt;
&lt;td&gt;null&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;6&quot;&gt;&lt;td&gt;DefaultServiceLifetime&lt;/td&gt;
&lt;td&gt;默认的服务生命周期&lt;/td&gt;
&lt;td&gt;ServuceLifetime( Singleton,Scoped,Transient)&lt;/td&gt;
&lt;td&gt;ServiceLifetime.Scope&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;6&quot;&gt;&lt;td&gt;ServiceLifeTimeMappings&lt;/td&gt;
&lt;td&gt;指定某个接口的服务生命周期,不指定为默认的生命周期&lt;/td&gt;
&lt;td&gt;Dictionary&amp;lt;string, ServiceLifetime&amp;gt;&lt;/td&gt;
&lt;td&gt;null&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4 id=&quot;interfacemappings&quot;&gt;InterfaceMappings&lt;/h4&gt;
&lt;p&gt;如果 &lt;code&gt;ISay&lt;/code&gt; 接口有&lt;code&gt;SayInChinese&lt;/code&gt; 和&lt;code&gt;SayInEnglish&lt;/code&gt; 两个实现,我们只想把SayInEnglish注册到&lt;code&gt;ServiceCollection&lt;/code&gt;中&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; public interface ISay
    {
        string Hello();
    }

      public class SayInChinese:ISay
    {
        public string Hello()
        {
            return &quot;您好&quot;;
        }
    }

        public class SayInEnglish:ISay
    {
        public string Hello()
        {
            return &quot;Hello&quot;;
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么我们可以这样配置&lt;code&gt;InterfaceMappings&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;options.InterfaceMappings=new Dictionary&amp;lt;string, string&amp;gt;(){{ &quot;ISay&quot;, &quot;SayInChinese&quot; } }&lt;/p&gt;
&lt;p&gt;也就是{&lt;code&gt;接口名称&lt;/code&gt;(支持通配符),&lt;code&gt;实现名称&lt;/code&gt;(支持通配符)}&lt;/p&gt;
&lt;h4 id=&quot;servicelifetimemappings&quot;&gt;ServiceLifeTimeMappings&lt;/h4&gt;
&lt;p&gt;如果我们希望ISay接口的服务的生命周期为&lt;code&gt;Singleton&lt;/code&gt;,我们可以这样配置&lt;code&gt;ServiceLifeTimeMappings&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;options.ServiceLifeTimeMappings = new Dictionary&amp;lt;string, ServiceLifetime&amp;gt;(){{&quot;*Say&quot;,ServiceLifetime.Singleton}};&lt;/p&gt;
&lt;p&gt;也就是也就是{&lt;code&gt;接口名称&lt;/code&gt;(支持通配符),&lt;code&gt;Servicelifetime&lt;/code&gt;}&lt;/p&gt;
&lt;p&gt;关于ServiceLifetime: https://github.com/aspnet/DependencyInjection/blob/master/src/DI.Abstractions/ServiceLifetime.cs&lt;/p&gt;
&lt;h3 id=&quot;获取服务实例&quot;&gt;获取服务实例&lt;/h3&gt;
&lt;p&gt;当然, 您可以和之前一样,直接在构造函数中进行依赖的注入,但是当某个接口有多个实现而且都注册到了ServiceCollection中,获取就没有那么方便了,您可以用&lt;code&gt;ICodeDiServiceProvider&lt;/code&gt; 来帮助您获取服务实例.&lt;/p&gt;
&lt;p&gt;例如,当 &lt;code&gt;ISay&lt;/code&gt; 接口有 &lt;code&gt;SayInChinese&lt;/code&gt; 和 &lt;code&gt;SayInEnglish&lt;/code&gt;两个实现, 我们我们如何获取我们想要的服务实例呢?&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; public interface ISay
    {
        string Hello();
    }

      public class SayInChinese:ISay
    {
        public string Hello()
        {
            return &quot;您好&quot;;
        }
    }

        public class SayInEnglish:ISay
    {
        public string Hello()
        {
            return &quot;Hello&quot;;
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt; public class HomeController : Controller
    {
        private readonly ISay _say;

        public HomeController(ICodeDiServiceProvider serviceProvider)
        {
            _say = serviceProvider.GetService&amp;lt;ISay&amp;gt;(&quot;*Chinese&quot;);
        }

        public string Index()
        {
            return _say.Hello();
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;ICodeDiServiceProvider.GetService&amp;lt;T&amp;gt;(string name=null)&lt;/code&gt;&lt;br/&gt;参数中的Name支持通配符.&lt;/p&gt;
&lt;h2 id=&quot;codedi如何实现的&quot;&gt;CodeDi如何实现的?&lt;/h2&gt;
&lt;p&gt;既然是一个&lt;code&gt;轻量级工具&lt;/code&gt;,那么实现起来自然不会太复杂,我来说说比较核心的代码.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  private Dictionary&amp;lt;Type, List&amp;lt;Type&amp;gt;&amp;gt; GetInterfaceMapping(IList&amp;lt;Assembly&amp;gt; assemblies)
        {
            var mappings = new Dictionary&amp;lt;Type, List&amp;lt;Type&amp;gt;&amp;gt;();
            var allInterfaces = assemblies.SelectMany(u =&amp;gt; u.GetTypes()).Where(u =&amp;gt; u.IsInterface);
            foreach (var @interface in allInterfaces)
            {
                mappings.Add(@interface, assemblies.SelectMany(a =&amp;gt;
                        a.GetTypes().
                            Where(t =&amp;gt;
                                t.GetInterfaces().Contains(@interface)
                            )
                    )
                    .ToList());
            }
            return mappings;
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;GetInterfaceMapping通过反射机制,首先获取程序集中的所有接口&lt;code&gt;allInterfaces&lt;/code&gt;,然后遍历&lt;code&gt;allInterfaces&lt;/code&gt;找到该接口对应的实现,最终,该方法返回接口和实现的匹配关系,为Dictionary&amp;lt;Type, List&amp;gt;类型的数据.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;        private void AddToService(Dictionary&amp;lt;Type, List&amp;lt;Type&amp;gt;&amp;gt; interfaceMappings)
        {
            foreach (var mapping in interfaceMappings)
            {
                if (mapping.Key.FullName == null || (_options.IgnoreInterface != null &amp;amp;&amp;amp;
                   _options.IgnoreInterface.Any(i =&amp;gt; mapping.Key.FullName.Matches(i))))
                    continue;

                if (mapping.Key.FullName != null &amp;amp;&amp;amp; _options.InterfaceMappings != null &amp;amp;&amp;amp;
                    _options.InterfaceMappings.Any(u =&amp;gt; mapping.Key.FullName.Matches(u.Key)))
                {
                    foreach (var item in mapping.Value.Where(value =&amp;gt; value.FullName != null).
                        Where(value =&amp;gt; value.FullName.Matches(_options.InterfaceMappings.FirstOrDefault(u =&amp;gt; mapping.Key.FullName.Matches(u.Key)).Value)))
                    {
                        AddToService(mapping.Key, item);
                    }
                    continue;
                }

                foreach (var item in mapping.Value)
                {
                    AddToService(mapping.Key, item);
                }
            }
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该方法要判断CodeDiOptions中是否忽略了该接口,同时,是否指定实现映射关系.&lt;br/&gt;什么叫实现映射关系呢?参见&lt;a href=&quot;http://www.cnblogs.com/CoderAyu/p/10269610.html#interfacemappings&quot;&gt;InterfaceMappings&lt;/a&gt;&lt;br/&gt;如果指定了,那么就按指定的来实现,如果没指定,就会把每个实现都注册到ServiceCollection中.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;        private readonly IServiceCollection _service;
        private readonly CodeDiOptions _options;
        private readonly ServiceDescriptor[] _addedService;

        public CodeDiService(IServiceCollection service, CodeDiOptions options)
        {
            _service = service ?? throw new ArgumentNullException(nameof(service));
            _options = options ?? new CodeDiOptions();
            _addedService = new ServiceDescriptor[service.Count];
            service.CopyTo(_addedService, 0);
            //在构造函数中,我们通过这种方式把Service中已经添加的服务读取出来
            //后面进行服务注册时,会进行判断,避免重复添加
        }

        private void AddToService(Type serviceType, Type implementationType)
        {
            ServiceLifetime serviceLifetime;
            try
            {
                serviceLifetime = _options.DefaultServiceLifetime;
                if (_options.ServiceLifeTimeMappings != null &amp;amp;&amp;amp; serviceType.FullName != null)
                {
                    var lifeTimeMapping =
                        _options.ServiceLifeTimeMappings.FirstOrDefault(u =&amp;gt; serviceType.FullName.Matches(u.Key));

                    serviceLifetime = lifeTimeMapping.Key != null ? lifeTimeMapping.Value : _options.DefaultServiceLifetime;

                }
            }
            catch
            {
                throw new Exception(&quot;Service Life Time Only Can be set in range of 0-2&quot;);
            }

            if (_addedService.Where(u =&amp;gt; u.ServiceType == serviceType).Any(u =&amp;gt; u.ImplementationType == implementationType))
                return;
            _service.Add(new ServiceDescriptor(serviceType, implementationType, serviceLifetime));
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;AddToService中,要判断有没有对接口的生命周期进行配置,参见&lt;a href=&quot;http://www.cnblogs.com/CoderAyu/p/10269610.html#servicelifetimemappings&quot;&gt;ServiceLifeTimeMappings&lt;/a&gt;,如果没有配置,就按DefaultServiceLifetime进行配置,DefaultServiceLifetime如果没有修改的情况下时ServiceLifetime.Scoped,即每个Request创建一个实例.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;        private readonly IServiceProvider _serviceProvider;
        public CodeDiServiceProvider(IServiceProvider serviceProvider)
        {
            _serviceProvider = serviceProvider;
        }
        public T GetService&amp;lt;T&amp;gt;(string name) where T : class
        {
            return _serviceProvider.GetService&amp;lt;IEnumerable&amp;lt;T&amp;gt;&amp;gt;().FirstOrDefault(u =&amp;gt; u.GetType().Name.Matches( name));
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这CodeDiServiceProvider的实现代码,这里参考了依乐祝写的&lt;a href=&quot;https://www.cnblogs.com/yilezhu/p/10236163.html&quot; title=&quot;.NET Core中的一个接口多种实现的依赖注入与动态选择看这篇就够了&quot;&gt;&amp;lt;.NET Core中的一个接口多种实现的依赖注入与动态选择看这篇就够了&amp;gt;&lt;/a&gt;给出的一种解决方案,即当某个接口注册了多个实现,其实可以通过IEnumerable获取所有的实现,CodeDiServiceProvider对其进行了封装.&lt;/p&gt;
&lt;h2 id=&quot;enjoy-it&quot;&gt;Enjoy it&lt;/h2&gt;
&lt;p&gt;只要进行一次简单的CodeDi配置,以后系统中添加了新的接口以及对应的服务实现后,就不用再去一个个地Add到IServiceCollection中了.&lt;/p&gt;
&lt;p&gt;如果有问题,欢迎Issue,欢迎PR.&lt;br/&gt;最后,赏个Star呗! &lt;a href=&quot;https://github.com/liuzhenyulive/CodeDi&quot;&gt;前往Star&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 14 Jan 2019 15:05:00 +0000</pubDate>
<dc:creator>码农阿宇</dc:creator>
<og:description>CodeDi是一个基于 .Net Standard的工具库,它能帮助我们自动地在Asp .net core或者 .net core项目中完成服务的注册.</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CoderAyu/p/10269610.html</dc:identifier>
</item>
<item>
<title>组件化设计：如何构建一套出色的组件系统 - 仲强</title>
<link>http://www.cnblogs.com/GerryOfZhong/p/10207535.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/GerryOfZhong/p/10207535.html</guid>
<description>&lt;p&gt;&lt;span&gt;写在前面的话&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      写了好多年业务，想输出一套前端的UI组件，但是对&lt;span&gt;&lt;strong&gt;组件&lt;/strong&gt;&lt;/span&gt;这个概念不是很深入了解，所以参考了很多资料，以及结合自己的理解，做出归纳和总结。所以才有了这一篇，从什么是组件，到什么是软件中的组件化设计，再到组件设计中有什么优势和挑战，到最后如何构建一套出色的组件系统。每个人的想法都不是一样的，所以这一套组件设计思想，可能也并不完善，仅作为大家的参考，也欢迎大家补充。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;什么是组件？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/801930/201812/801930-20181229172006331-576246931.png&quot; alt=&quot;&quot; width=&quot;390&quot; height=&quot;232&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/801930/201812/801930-20181229172210903-168341163.png&quot; alt=&quot;&quot; width=&quot;385&quot; height=&quot;246&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/801930/201812/801930-20181229173324175-1110134968.png&quot; alt=&quot;&quot; width=&quot;345&quot; height=&quot;231&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;这就是我们现实生活中，最形象最贴切的物品了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      图一是一堆齿轮驱动的机器，每个齿轮都是单独存在的，如果一个齿轮坏了，我们只要替换下来换一个好的就好了，这个机器一样跑起来啦。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      图二是个人PC的主板，大家也特别熟悉，对于插在主板上的每一个单独功能的组件，如果坏了一个，可以换一个好的，通过插槽替换上去，也可以跑起来了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以生活中有很多组件的实体，我们看看这些关于组件的定义：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;1. 供装配整台机器、构件或元件的零件组合&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;2. 在电子或机械设备中组装在一起形成一个功能单元的一组元件&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;3. 组装产品(如书橱或碗橱)时所组合的通常或多或少重复的部分&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;4. 可被组装或被重新组装的几个部件之一&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;这些都是我们看得到，摸得到的，下面我们再跳出现实表象，上升到一个更高的层面去看问题（这样的高逼格的说法叫抽象） &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      图三：是一个完整的中国地图，地图上每个省级的地域，我们不管你在这片区域是平原、高山、还是海岛、还是大海等，只要你属于规划范畴，那么就属于一个省级区域，由这些区域组成了我们一个完整的国家，丢一块都不行。我们可以把每个省级抽象成一个组件，国家机器，就是由这些组件一起跑起来的。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;我们将信息进行汇总和整理，得出如下结论：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;1. 从外观和功能上来讲，他们都是一个独立的部分，可能是零件或者是原件&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;2. 从行为上来讲，他们拥有组装这个属性，可以和其他组件相互组合&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;3. 可以被重新组装，重复利用&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;      当然我们做软件设计的，也是通过参考现实，抽象到软件设计中，然后根据落地环境，去实现组件化设计思想，前人已经走在了路上，去摸索这块土地，也获得了一些实用的理论，比如&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Component-based_software_engineering&quot; target=&quot;_blank&quot;&gt;基于组件的软件工程（Component-based software engineering&lt;/a&gt;&lt;span class=&quot;s1&quot;&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Component-based_software_engineering&quot; target=&quot;_blank&quot;&gt;，简称CBSE&lt;/a&gt;&lt;span class=&quot;s1&quot;&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Component-based_software_engineering&quot; target=&quot;_blank&quot;&gt;）&lt;/a&gt;或&lt;a href=&quot;https://en.wikipedia.org/wiki/Component-based_software_engineering&quot; target=&quot;_blank&quot;&gt;基于组件的开发（Component-Based Development&lt;/a&gt;&lt;span class=&quot;s1&quot;&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Component-based_software_engineering&quot; target=&quot;_blank&quot;&gt;，简称CBD&lt;/a&gt;&lt;span class=&quot;s1&quot;&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Component-based_software_engineering&quot; target=&quot;_blank&quot;&gt;）的软件开发范型&lt;/a&gt;等等，有兴趣的可以自己去看下。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span&gt;下面是前人对组件的定义：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;1. 一个不透明的功能实体，能够被第三方组装，且符合一个构件模型。 &lt;span class=&quot;s1&quot;&gt;— 卡耐基梅隆大学&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;2. 是软件系统中具有相对独立功能、接口由契约指定、和语境有明显依赖关系、可独立部署、可组装的软件实体。&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;  — 计算机百科全书&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;3. 是一个组装单元，它具有约定式规范的接口，以及明确的依赖环境。构建可以被独立的部署，由第三方组装。&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;  — 软件构件著作&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;4. 为自包含的、可编程的、可重用的、与语言无关的软件单元,软件组件可以很容易被用于组装应用程序中。 &lt;span class=&quot;s1&quot;&gt;— 百度百科&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;span class=&quot;s1&quot;&gt;5. ......&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span&gt;&lt;span&gt;每个结论针对的都是各自稳定软件领域的抽象，我们还可以看到更多对于组件的定义。所以我们针对这些结论，做一个总结，&lt;span&gt;&lt;strong&gt;&lt;span&gt;组件具有什么样的特性&lt;/span&gt;？&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;1. 高度内聚，不透明&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;  — 不需要关心这个东西怎么搞出来的，知道怎么用就好了&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;2. 对外以接口契约 &lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;— 有说明书，知道这个东西给了需要的就变成你想要的&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;3. 功能相对独立 &lt;span class=&quot;s1&quot;&gt;— 相对概括的指明这个东西的使用途径&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;4. 环境依赖 &lt;span class=&quot;s1&quot;&gt;—&lt;span class=&quot;Apple-converted-space&quot;&gt;  对环境的依赖比较重要&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;5. 可重用 &lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;— 可以多次使用&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;6. 可组装&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;  —&lt;span class=&quot;Apple-converted-space&quot;&gt;  可以和其他东西组成其他的玩意&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span&gt;组件系统中有哪些组件？&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span&gt;原子组件：原子级别组件，单一功能，不能继续拆分。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span&gt;复合组件：多组件组合，组成的能完成某一功能的组件。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span&gt;插槽组件：为组件的组装完成一个功能而提供的基础设施。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span&gt;拓展组件：在原有组件上派生出一个新的组件，为原有组件增加新的性能或者更改原有组件的功能。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span&gt;适配组件：通过适配组件去封装不同组件，保证对外契约一致&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span&gt;什么是组件设计思想？&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span&gt;将需求场景领域化，将场景领域模块化，以符合系统需求为衡量，以稳定领域最大复用为目的，使其可以通过组合拆分来构建整个系统的独立解决方案&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span&gt;&lt;strong&gt;如图：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/801930/201901/801930-20190104161901851-1935066860.png&quot; alt=&quot;&quot; width=&quot;911&quot; height=&quot;497&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;案例：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      比如我们需要做一个简单的前端的活动系统，需求要有&lt;/span&gt;&lt;span&gt;登录系统、&lt;/span&gt;&lt;span&gt;查看活动、&lt;/span&gt;&lt;span&gt;创建活动、&lt;/span&gt;&lt;span&gt;修改活动、&lt;/span&gt;&lt;span&gt;删除活动。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;将需求场景领域化：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;登录系统  --&amp;gt;  表单提交　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;查看活动  --&amp;gt;  数据展示&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;创建活动  --&amp;gt;  表单提交　　　　=====&amp;gt;   抽象出表单提交、数据展示和行为操作这些稳定领域&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;修改活动  --&amp;gt;  表单提交&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;删除活动  --&amp;gt;  行为操作&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;场景领域模块拆分：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;表单领域拆分模块（简单拆分2个）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1. 文本输入模块&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2. 密码输入模块&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　......&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;PS：其他领域跟表单领域一样，进行模块拆分。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;概括共性：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      比如表单领域的2个简单模块，我们需要对其概括共性，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　  1. 他们都是输入的文本，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　  2. 一个输入文本可见，一个输入文本不可见。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　结论：我们可以设计一个输入文本的组件，对外开放契约，如果你告诉我你需要把输入不可见，我内部就做处理将这些东西遮住。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;产出组件：&lt;/p&gt;
&lt;p&gt;组件：输入组件&lt;/p&gt;
&lt;p&gt;契约：是否需要遮挡输入&lt;/p&gt;
&lt;p&gt;功能：输入文本的&lt;/p&gt;
&lt;p&gt;领域：表单输入使用&lt;/p&gt;

&lt;p&gt;&lt;span&gt;以这样的方式做组件设计，如果整个系统都有这样的稳定领域，那么这些组件的意义就是针对该系统是最好的，不仅满足了需求，还可以最大功能复用。&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;组件化设计的好处？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;. &lt;span class=&quot;Apple-tab-span&quot;&gt;可重用，对于一个功能独立且单一的组件，不需要花费其他资源，可以直接使用组件达到效果&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. 拓展和替换，对于系统的维护和更新来说，可以通过基础组件进行拓展，然后可以通过替换组件去为系统进行更新&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3. 复杂合作可能性，独立拆分模块和组件，已组件拆分组合构建完整系统，使大型项目合作成为可能。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4. 提高效率，这包括对软件复杂性更有效率的管理，快速地推向市场，以及更高的生产力（迭代效率），更高的质量等等&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;组件化设计开发有什么挑战？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. 开发组件所需要的时间和精力。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      开发组件不是单独完成一个功能或者一个页面，如果开发成组件，所需要的时间和精力成本是远远大于只是纯粹完成一个功能的成本的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. 不可描述需求的开发。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      对于软件的需求阶段，在现实开发中，不可能是所有需求都特别明确的，所以对于这些不定性，不可描述需求的开发，对于组件的挑战是很大的，因为领域不稳定，最终可能抽象的组件也是不定且变化的，这样导致的组件变化成本是急剧上升的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3. 可用性和可重用的冲突。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      对于系统中最后形成的组件的衡量，不是一个固定标准的。可能组件对于现阶段的可用性已经完全满足，但是对于未来变化和爆发是否需要前瞻性的做预留和拓展，以达到更高一层的可复用的冲突，需要开发者自己衡量的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4. 组件维护。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      组件的维护在小型项目还可以忽略，但是在大型项目中，如果维护需要自己一个代码一个代码的去寻找痕迹，那么这样的组件设计开发不理想，反而违背了组件设计最初的梦想。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5. 可靠性以及容错机制。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      因为组件内部是相对独立的，我们不知道内部的变化，所以衡量一个组件除了是否满足我的需求以外，是否可靠，以及组件不可靠，出现意外的反应机制是否能够准确定位和降级容错（损失一些功能，保证其他功能完善）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6. 持续增长的挑战。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      组件开发是为了更高的减轻开发中的各种负担，但是在组件持续的增长中，组件本身也会成为一种负担，对于本身的负担是否有完善的处理机制，可以在持续增长中hold住。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;7. 组件的规范。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      每个攻城狮的开发风格都有各种差异，组件的规范，在这样的合作中就是重中之重，减少多套理解成本。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;8. 解析组件的“内核”。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      对于核心大脑的健壮是整个系统的灵魂。这个不多说，挂了就直接game over！&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;有挑战，是真实存在的，但是我们可以通过一系列的方法和规范去解决这些挑战，让组件化设计更好的服务我们的系统。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;如何设计一套出色的组件系统？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/801930/201901/801930-20190114162827824-517748860.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;构建组件系统有2个方向：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;设计一套符合系统需求的组件，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;设计一套可以通用的组件。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;罗列一些不管哪个方向都要考虑的因素：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. 统一收口和管理组件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　对于任何一个系统来说，快速迭代和增长中势必会带来组件的爆发式增长，如果不能将组件统一收口，可能会带来组件的重复开发利用率低下（可能和一个组件功能80%相同，只需要拓展一个原子组件就可以解决问题。或者无收口不知道其他地方有个类似可以满足的组件导致二次开发）。其次管理也一样，好的管理可以最大化发挥组件式开发的优势，不善的管理就会带来这样的疑问，&quot;这样的组件化开发，增加了更多的复杂度，还有什么意义？&quot;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;2.组件升级和更新，乃至替换做到可控&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　忘本式迭代，抛弃旧包袱，迎接新时代这是一种很爽的开发体验。但是也会带来，开发一时爽，xxxxx（大家自己体会）。组件每次的升级，在没有完整的方案前，势必要考虑组件的兼容性，否则我每次迭代一个新的组件，使用的组件都不兼容，都需要从头返工手把手替换使用的组件。那就呵呵了。但是有完整灰度方案以后可以实施，比如组件整体升级2.0版本，才能使用新特性，且有足够的组件升级迁移方案保证升级无影响。这样的可控，可以最大化组件开发的优势。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;3.容错，核心与非核心组件的容错方案的处理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　容错式，也分很多种方式，在传统window大型系统中，对于核心组件的容错式就特别的低，因为有些是核心组件，比如CPU，丢了这个就不能玩了。但是对于USB插槽，音频输出插槽等等这些容错率就很高，你坏了无所谓，我系统能跑。只是我会断掉你的组件提供的功能。所以组件的容错，需要针对系统本身去评估，无统一方案。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;4.安全性，除对外暴露契约影响，对内应自成沙盒&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这个就跟浏览器一样，我受影响的东西，只有我自己对外抛出的约定和契约，否则其他东西都不能影响到我。这样才不会导致会有非本身的变动，而让组件自身出现问题，解耦万物，才能达到内心的聚合和独立。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;5.文档，组件的自描述，功能和对外契约&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　没有文档就是没有自我介绍，谁知道你是谁，能干什么，能不能胜任我的解决方案。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;6. 可信，组件开发授于任何开发者，必须减少风险的可能，以及全面的测试。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　组件设计最终的执行者是开发者，如果一个未受评估或者没有全面测试的组件引入整个系统构建中，那么就是引入了一个很大的风险，以后对于这个风险你可能会承受多余自身的时间去把控这个问题。这也是一个合格的软件开发工程师需要评估的问题。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;7. 适配器和胶水代码：包装更复杂复合通用组件，应通过适配器设计和胶水代码组合，保证符合组件规范&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　组件的重复利用和组件之间的组装，肯定会带来更多组件的出现和更复杂的组件出现，自然而然会得到更高的复杂度。但是基于本系统的组件规范和开发规范，可以使用更多的胶水代码去适配成和本系统组件一致的模型，这样你我都一样，学习和使用成本都不高。业内很多都是创建一个组件的原始类，定义组件的基础功能和契约，所有的组件都会去继承这个原始类，达到组件的一致性。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;8. 友好，对开发者更友好，学习成本和使用成本更低廉&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在软件开发中，下游消费的是程序员，是将你创建的东西发扬光大的信教徒，你的布道需要更多的友好。否则程序员内心就会出现这样粗俗的声音，“你上来就给老子一棒子，写着写着又给老子一棒子，还玩个蛋！”&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;9. 稳定，一切以稳定为重，远离危险代码&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　相信每个公司都会安利这样的思维，生产代码是能经历风吹雨打，是能扛得住大山的。你的组件一样必须这样，太多的问题，最终会导致无法维护，成本太高，问题千奇百怪等等，然后你被干掉了。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;10. 特色，独特的系统有自己的特色和亮点&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　一般这个都是可选项，毕竟你想的轮子，可能前人都造了N个，你有什么特色去让别人去选择你，使用你。是因为爱吗？还是因为爱吗？&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;11. 更符合使用者习惯&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　站在别人的角度去思考问题，才能知道别人需要什么，才能让别人离不开你。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;设计一套符合系统经需求的组件（面向需求的组件开发）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/801930/201901/801930-20190114161836845-1140564746.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一要素：以需求为中心，以满足需求为衡量标准&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. 挖掘符合本系统的组件做基础组件和样本组件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　一个系统的组件系统很少是自己从头搭建，因为成本问题。在业务的快速迭代中，一般都会选择一些提供原子组件的第三方的库和包，通过包装第三方的组件，形成符合本系统需求的组件系统。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;2.构建需求组件，适应现有系统的组件模型和需求规范&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　不同组件定义了自己不同的对外接口契约，千变万化的契约会带来杂、乱、差。不管哪一方的组件，乃至自己的组件，都需要遵守本系统的组件模型规范。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;3.可选拓展，在需求可伸缩范围支持拓展和收缩&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在需求组件的开发中，对需求的发展，乃至回滚都有很清楚的认识。在这样的基础之上，可以在组件开发中留有可选拓展项，需求伸缩和回滚都能把控。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;4. 适可而止，不过多设计&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　一切以需求为准，满足即是最好。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;5. 自描述性更高，组件设计对需求的耦合性更高，需要更多的描述&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　因业务的复杂度耦合更多的独特的规则，这样的组件更需要更高的自描述性内容。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;设计一套可以通用的组件（面向复用的组件开发）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/801930/201901/801930-20190114161912053-872200055.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一要素：以通用为中心，以抽象共性解决同类问题为衡量标准&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. 关联稳定的领域抽象&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　通用，即是稳定的，形成共识的领域。所以通用组件，也是稳定领域抽象出的组件&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;2.将组件一般化&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　一般组件都是为了解决特定问题而产生的应用，将这个应用进行一般化，关联更普遍的业务对象&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;3. 控制复杂度和可读性&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　越通用的组件，可复用性越高，但是复杂度性对也越高，可读性也越差&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;4.一致性&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　统一的接口和契约，乃至统一的对外异常暴露，只有大家越一致，更通用才会成为可能&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;5. 适应性&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　为组件增加一个配置接口，为组件伸缩提供一种可能&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt; 针对组件设计的挑战，我们从未因为有挑战就停止前进的步伐，所以结合前人探索和自己开发中的经验和理解，对于想构建一套出色的组件系统的各位攻城狮提供一个指南和参考。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;后记：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果你感觉对你有用，请&lt;strong&gt;&lt;a href=&quot;https://github.com/GerryIsWarrior/design/blob/master/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E5%A5%97%E5%87%BA%E8%89%B2%E7%9A%84%E7%BB%84%E4%BB%B6%E7%B3%BB%E7%BB%9F.md&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;点个star&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;，继续支持我更多的研究。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果有任何问题，请到这里&lt;strong&gt;&lt;span&gt;&lt;a href=&quot;https://github.com/GerryIsWarrior/design/issues&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;提issues&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;，一起探讨问题的可能性。&lt;/span&gt;&lt;/p&gt;


</description>
<pubDate>Mon, 14 Jan 2019 15:01:00 +0000</pubDate>
<dc:creator>仲强</dc:creator>
<og:description>写在前面的话 写了好多年业务，想输出一套前端的UI组件，但是对组件这个概念不是很深入了解，所以参考了很多资料，以及结合自己的理解，做出归纳和总结。所以才有了这一篇，从什么是组件，到什么是软件中的组件化</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/GerryOfZhong/p/10207535.html</dc:identifier>
</item>
<item>
<title>SpringCloud学习系列之一 ----- 搭建一个高可用的注册中心(Eureka) - 虚无境</title>
<link>http://www.cnblogs.com/xuwujing/p/10269570.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xuwujing/p/10269570.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;本篇主要介绍的是SpringCloud相关知识、微服务架构以及搭建一个高可用的服务注册与发现的服务模块(Eureka)。&lt;/p&gt;
&lt;h2 id=&quot;springcloud介绍&quot;&gt;SpringCloud介绍&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Spring Cloud是在Spring Boot的基础上构建的，用于简化分布式系统构建的工具集，为开发人员提供快速建立分布式系统中的一些常见的模式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;配置管理（configuration management），服务发现（service&lt;br/&gt;discovery），断路器（circuit breakers），智能路由（ intelligent routing），微代理（micro-proxy），控制总线（control bus），一次性令牌（ one-time okens），全局锁（global locks），领导选举（leadership election），分布式会话(distributed sessions），集群状态（cluster state)等等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;微服务架构是什么&quot;&gt;微服务架构是什么&lt;/h2&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;微服务架构风格是一种将单个应用程序开发为一套小型服务的方法，每个小型服务都在自己的流程中运行，并与轻量级机制（通常是HTTP资源API）进行通信。这些服务围绕业务功能构建，可通过全自动部署机制独立部署。这些服务至少集中管理，可以用不同的编程语言编写，并使用不同的数据存储技术。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;springcloud-eureka&quot;&gt;SpringCloud Eureka&lt;/h2&gt;
&lt;h3 id=&quot;eureka-介绍&quot;&gt;Eureka 介绍&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Eureka是Netflix开源的一款提供服务注册和发现的产品，它提供了完整的Service Registry和Service Discovery实现。也是springcloud体系中最重要最核心的组件之一。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Eureka主要由两个组件组成：Eureka服务器和Eureka客户端。&lt;br/&gt;Eureka服务器用作服务注册服务器。&lt;br/&gt;Eureka客户端是一个java客户端，用来简化与服务器的交互、作为轮询负载均衡器，并提供服务的故障切换支持。&lt;/p&gt;
&lt;h3 id=&quot;开发准备&quot;&gt;开发准备&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;开发环境&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;JDK&lt;/strong&gt;:1.8&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SpringBoot&lt;/strong&gt;:2.1.1.RELEASE&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SpringCloud&lt;/strong&gt;：Finchley&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;注:不一定非要用上述的版本，可以根据情况进行相应的调整。需要注意的是SpringBoot2.x以后，jdk的版本必须是1.8以上！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;确认了开发环境之后，我们再来添加相关的pom依赖。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;dependencies&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-cloud-starter&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-eureka&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
        &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
    &amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注:&lt;/strong&gt; 基于SpringBoot1.x以上SpringCloud是Dalston版本的eureka 依赖是 &lt;code&gt;&amp;lt;artifactId&amp;gt;spring-cloud-starter-eureka&amp;lt;/artifactId&amp;gt;&lt;/code&gt;，少了个 netflix 。SpringCloud的版本命名方式是通过伦敦的地方来命名的，版本顺序是根据首字母的顺序来的。&lt;/p&gt;
&lt;h3 id=&quot;springcloud-eureka-hello-world&quot;&gt;SpringCloud Eureka Hello World&lt;/h3&gt;
&lt;p&gt;我们先来实现Eureka的Hello World版，其实也就是实现简单的服务注册和发现功能。&lt;/p&gt;
&lt;h4 id=&quot;服务端&quot;&gt;服务端&lt;/h4&gt;
&lt;p&gt;首先建立一个服务端的工程，添加如上的依赖之后，在&lt;code&gt;application.properties&lt;/code&gt;添加如下的配置:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;配置信息:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;spring.application.name=springcloud-eureka-client
server.port=8000
eureka.client.register-with-eureka=false
eureka.client.fetch-registry=false
eureka.client.serviceUrl.defaultZone=http://localhost:8000/eureka/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;配置说明:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;spring.application.name： 这个是指定服务名称。&lt;/li&gt;
&lt;li&gt;server.port:服务指定的端口。&lt;/li&gt;
&lt;li&gt;eureka.client.register-with-eureka：表示是否将自己注册到Eureka Server，默认是true。&lt;/li&gt;
&lt;li&gt;eureka.client.fetch-registry：表示是否从Eureka Server获取注册信息，默认为true。&lt;/li&gt;
&lt;li&gt;eureka.client.serviceUrl.defaultZone： 这个是设置与Eureka Server交互的地址，客户端的查询服务和注册服务都需要依赖这个地址。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;完成配置信息的添加后，我们再来看代码如何实现。&lt;br/&gt;在服务端这边只需要在SpringBoot启动类添加&lt;code&gt;@EnableEurekaServer&lt;/code&gt;注解就可以了，该注解表示此服务是一个服务注册中心服务。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码示例:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    @EnableEurekaServer
    @SpringBootApplication
    public class App {
      public static void main(String[] args) {
          SpringApplication.run(App.class, args);
          System.out.println(&quot;注册中心服务启动...&quot;);
      }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;客户端&quot;&gt;客户端&lt;/h4&gt;
&lt;p&gt;这里我们在新建一个客户端的项目，添加如上的依赖之后，在&lt;code&gt;application.properties&lt;/code&gt;添加如下的配置:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;配置信息:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;spring.application.name=springcloud-eureka-client
server.port=9001
eureka.client.serviceUrl.defaultZone=http://localhost:8000/eureka/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;配置说明:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;spring.application.name： 这个是客户端的服务名称。如果有多个服务使用同一个名称但是访问地址不同，结合ribbon 使用，则可以实现负载均衡功能。&lt;/li&gt;
&lt;li&gt;server.port:服务指定的端口。&lt;/li&gt;
&lt;li&gt;eureka.client.serviceUrl.defaultZone： 注册中心服务端的地址。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;服务端这边的实现也很简单，只需在启动类上添加&lt;code&gt;@EnableDiscoveryClient&lt;/code&gt;该注解即可，使用该注解表示该项目就具有了服务注册的功能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码示例:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    @SpringBootApplication
    @EnableDiscoveryClient
    public class App {
    
        public static void main(String[] args) {
            SpringApplication.run(App.class, args);
            System.out.println(&quot;客户端服务启动...&quot;);
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;功能测试&quot;&gt;功能测试&lt;/h3&gt;
&lt;p&gt;完成如上的工程开发之后，我们依次启动服务端和客户端程序，然后在浏览器界面输入:&lt;code&gt;http://localhost:8000/&lt;/code&gt;，即可查看注册中心的信息。&lt;/p&gt;
&lt;p&gt;访问界面地址:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190111165555121.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhendzeHBjbQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过上述示例图中，可以看到Eureka启动成功了，并且有一个服务进行注册了。&lt;/p&gt;
&lt;p&gt;成功的实现了服务注册功能之后，我们来测试下Eureka服务的保护机制。&lt;br/&gt;这里我们先关闭客户端，查看界面信息，发现没什么改变，等待大约15分钟左右之后，再到Eureka界面查看信息，发现出现了一长串红字描述,描述的语句如下:&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;EMERGENCY! EUREKA MAY BE INCORRECTLY CLAIMING INSTANCES ARE UP WHEN THEY'RE NOT. RENEWALS ARE LESSER THAN THRESHOLD AND HENCE THE INSTANCES ARE NOT BEING EXPIRED JUST TO BE SAFE.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;翻译之后的意思:&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;紧急!EUREKA可能错误地声称实例已经启动，而实际上并没有。续订小于阈值，因此实例不会为了安全而过期。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;界面示例图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190114153229585.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhendzeHBjbQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里就顺便说下Eureka的自我保护机制。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;自我保护模式正是一种针对网络异常波动的安全保护措施，使用自我保护模式能使Eureka集群更加的健壮、稳定的运行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;自我保护机制的工作机制是如果在15分钟内超过85%的客户端节点都没有正常的心跳，那么Eureka就认为客户端与注册中心出现了网络故障，Eureka Server自动进入自我保护机制，此时会出现以下几种情况：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Eureka Server不再从注册列表中移除因为长时间没收到心跳而应该过期的服务。&lt;/li&gt;
&lt;li&gt;Eureka Server仍然能够接受新服务的注册和查询请求，但是不会被同步到其它节点上，保证当前节点依然可用。&lt;/li&gt;
&lt;li&gt;当网络稳定时，当前Eureka Server新的注册信息会被同步到其它节点中。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;因此Eureka Server可以很好的应对因网络故障导致部分节点失联的情况，而不会像ZK那样如果有一半不可用的情况会导致整个集群不可用而变成瘫痪。&lt;/p&gt;
&lt;p&gt;自我保护机制的相关配置如下:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;服务端的配置：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;eureka.server.enable-self-preservation: 该配置可以移除这种自我保护机制，防止失效的服务也被一直访问 (Spring Cloud默认该配置是 true)。&lt;/li&gt;
&lt;li&gt;eureka.server.eviction-interval-timer-in-ms:该配置可以修改检查失效服务的时间，每隔10s检查失效服务，并移除列表 (Spring Cloud默认该配置是 60s)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;客户端的配置:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;eureka.instance.lease-renewal-interval-in-seconds: 该配置指示eureka客户端需要向eureka服务器发送心跳的频率 (Spring Cloud默认该配置是 30s)。&lt;/li&gt;
&lt;li&gt;eureka.instance.lease-expiration-duration-in-seconds: 该配置指示eureka服务器在接收到最后一个心跳之后等待的时间，然后才能从列表中删除此实例 (Spring Cloud默认该配置是 90s)。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里顺便说下Eureka的的心跳机制。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;Eureka Client需要每30秒给Eureka Server发一次心跳，同时更新Server上最新的注册信息到本地，如果Server多次没有收到来自客户端的心跳，那么在90秒内会被Server上剔除。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;高可用的注册中心&quot;&gt;高可用的注册中心&lt;/h3&gt;
&lt;p&gt;上述的服务注册中心示例是单点的，如果在生产环境中就显得不适合，显然这并不适合应用于线上生产环境。作为分布式系统最重要的注册服务功能，为了使其高可用，使用集群是最普遍的方式。Eureka可以通过互相注册的方式来实现高可用的部署。&lt;/p&gt;
&lt;p&gt;Eureka实现相互注册的方式很简单，只需要将各个服务端的地址相互进行配置即可。&lt;br/&gt;那么我们再来新建两个服务端的工程，其中配置信息如下:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;server2配置信息:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;spring.application.name=springcloud-eureka-server
server.port=8002
eureka.instance.hostname = server2
eureka.client.serviceUrl.defaultZone=http://server3:8003/eureka/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;server3配置信息:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;spring.application.name=springcloud-eureka-server
server.port=8003
eureka.instance.hostname = server3
eureka.client.serviceUrl.defaultZone=http://server2:8002/eureka/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述的配置在之前已经说过了，这里就不在过多描述了。这里的服务端配置和之前项目的服务端配置略有不同，允许自己进行注册了。并且这里的&lt;code&gt;eureka.instance.hostname&lt;/code&gt;相当于是对服务地址起一个别名，也可以不配置，默认将会使用IP进行查找。&lt;code&gt;eureka.client.serviceUrl.defaultZone&lt;/code&gt;这里配置的是另一个服务端的地址，如果是多个就通过 &quot;，&quot;逗号隔开。&lt;/p&gt;
&lt;p&gt;因为这里使用了别名进行区分服务，所以需要在hosts文件添加如下配置，用于做映射。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;127.0.0.1     server2
127.0.0.1     server3&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;hosts文件地址:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Windows 系统地址:&lt;code&gt;C:\Windows\System32\drivers\etc\hosts&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Linux系统地址: &lt;code&gt;/etc/hosts&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;配置完成之后，启动这两个服务，然后在浏览器输入:&lt;br/&gt;&lt;code&gt;http://server2:8002/&lt;/code&gt;&lt;br/&gt;或&lt;br/&gt;&lt;code&gt;http://server3:8003/&lt;/code&gt;&lt;br/&gt;即可查看信息.&lt;/p&gt;
&lt;p&gt;高可用注册中心示例图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190114153210968.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhendzeHBjbQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里我们把之前的客户端程序的配置改下，改成指定这个高可用注册中心的地址，然后在关闭其中一个服务，查看是否能够正常的使用。&lt;/p&gt;
&lt;p&gt;示例图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190114153159941.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhendzeHBjbQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到其中一个服务可以正常运行和使用！&lt;/p&gt;
&lt;h2 id=&quot;其他&quot;&gt;其他&lt;/h2&gt;
&lt;h3 id=&quot;项目地址&quot;&gt;项目地址&lt;/h3&gt;
&lt;p&gt;基于SpringBoot1.x、SpringCloud的Dalston版本开发的地址:&lt;code&gt;https://github.com/xuwujing/springcloud-study&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;基于SpringBoot1.x、SpringCloud 的Dalston版本开发的地址: &lt;code&gt;https://github.com/xuwujing/springcloud-study-old&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如果感觉项目不错，希望能给个star，谢谢!&lt;/p&gt;
&lt;h3 id=&quot;音乐推荐&quot;&gt;音乐推荐&lt;/h3&gt;
&lt;p&gt;挺有节奏感的一首纯音乐！&lt;/p&gt;

&lt;p&gt;原创不易，如果感觉不错，希望给个推荐！您的支持是我写作的最大动力！&lt;br/&gt;版权声明:&lt;br/&gt;作者：虚无境&lt;br/&gt;博客园出处：http://www.cnblogs.com/xuwujing&lt;br/&gt;CSDN出处：http://blog.csdn.net/qazwsxpcm　　　　&lt;br/&gt;个人博客出处：http://www.panchengming.com&lt;/p&gt;
</description>
<pubDate>Mon, 14 Jan 2019 15:00:00 +0000</pubDate>
<dc:creator>虚无境</dc:creator>
<og:description>本篇主要介绍的是SpringCloud相关知识、微服务架构以及搭建一个高可用的服务注册与发现的服务模块(Eureka)。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xuwujing/p/10269570.html</dc:identifier>
</item>
<item>
<title>【Ray Tracing The Next Week 超详解】 光线追踪2-1 - 林-兮</title>
<link>http://www.cnblogs.com/lv-anchoret/p/10269488.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lv-anchoret/p/10269488.html</guid>
<description>
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Preface&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;博主刚放假回家就进了医院，今天刚完事儿，来续写第二本书&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1316111/201901/1316111-20190114111249764-1756318228.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Ready&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们来总结一下上一本书的笔记中我们的一些规定&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. 数学表达式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们采用小写粗黑体代表向量，大写粗黑体代表矩阵，其他代表标量&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.我们将eye(or camera)发出的光线称为视线（sight）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.我们目前将所有的非特定（不专属于任何一个类）的通用物理数学运算函数封装到泛型库中，并以lvgm命名空间限定，暂时不准备划分子命名空间&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.我们写库，拟采用全hpp书写，因.h和.cpp之间关于父类纯虚函数的子类相关声明与实现出现了无法链接的神奇编译错误，问过很多大佬，最后还是采用hpp&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;基础工程代码见第一本书总结篇&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;Chapter 1  Motion Blur&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;今天先来一个开胃菜，一个简单易懂的技术——运动模糊&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; 先看效果&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1316111/201901/1316111-20190114215100658-1207130937.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;好像我们之前也提到过类似的模糊，例如：散焦模糊（&lt;a href=&quot;https://www.cnblogs.com/lv-anchoret/p/10223222.html&quot; target=&quot;_blank&quot;&gt;defucos blur&lt;/a&gt;）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;它和今天的模糊还是有一定区别的，从物理成因上讲，defucos是因为未正确对焦，如果没有玩过生活中的相机也没关系，大家都用手机拍过照吧，有些时候，手机相机打开对着拍摄对象，屏幕中的物体或字迹的边缘是模糊的，通常我们会做一个动作，即，点一下屏幕（会出现一个小框），然后图像就会变清晰（边缘明显）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;运动模糊的意思是，现实世界中，相机快门开启的时间间隔内，相机内物体发生了位移，画面最后呈现出来的像素，是移动过程中像素的平均值。它不是由相机造成的，而是由物体运动状态造成的形状模糊，比如，你拍摄一张正在下落小球的照片，它所造成的模糊是在段时间内停留在历史轨迹中的重影&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;弄清楚这个，就开始我们的正题&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如何模拟真实生活中的运动模糊，我们先来回顾一下光线追踪的过程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. 我们选定屏幕中的一个位置，作为待计算的像素点&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. 从eye发出一条视线指向该上述位置周围的采样点&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3. 如果中途有物体相交，那么根据物体表面材质进行视线计算&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3. 至多递归计算50次，确定该位置的一个采样值&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4. 该位置周围采样100次，计算均值作为该位置的最终像素值&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那么我们看一下上述过程中，需要改动哪些地方以支持模拟物体的运动模糊行为&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先，我们只需要模拟相机快门开启的时间间隔内的物体运动情况，所以，物体一定有一个运动的起点和终点位置&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果是球体，我们用球心代表运动的位置(heart1,heart2)，另外相机时间间隔是一段时间，需要起止时间点确定(time1,time2)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其次，我们模拟物体运动模糊，还要根据相机原理：画面最后呈现出来的像素，是移动过程中像素的平均值&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以，我们依旧采用随机取样，我们之前已经确定采样像素点为100个，采样周围点是为了抗锯齿，这一节我们更重要的是要采样物体的运动位置&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们有物体运动的起止位置和起止时间点（确定运动时间间隔），所以我们取0~1的随机数作为物体从heart1到heart2运动路径长度比例，进而确定物体在该随机时刻的具体位置heart，我们取多个随机时间进行采样，之后再进行均值处理，作为移动过程中像素的平均值&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;完成上述理论，还需在光线追踪过程中下手&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一步就不用说了，就是确定屏幕位置&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第二步就很重要了，视线发出就要接触物体，也就是说视线产生就要确定该时刻的物体具体位置，因为它要和物体进行相交计算，所以，视线承担着记录当前时间点的作用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而我们还需要做运动位置采样，所以，eye需要发出多条视线，基于不同的随机时间，这样我们就做到了根据不同的随机时间发出多条采样视线对物体的运动位置进行采样&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们不妨把抗锯齿的采样和运动位置采样视线生成放在一起&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;ray.hpp&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;///&lt;/span&gt;&lt;span&gt; ray.h&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt; -----------------------------------------------------
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; [author]        lv
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; [begin ]        2019.1
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; [brief ]        the ray-class for the ray-tracing project
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                from the 《ray tracing The Next week》
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; -----------------------------------------------------&lt;/span&gt;
&lt;span&gt;#pragma&lt;/span&gt; once&lt;span&gt;

#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;RTdef.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; rt
{

    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; ray
    {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
        ray()
            :_a{ rtvec() }
            , _b{ rtvec() }
        {  }

        ray(&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; rtvec&amp;amp; a, &lt;span&gt;const&lt;/span&gt; rtvec&amp;amp; b, &lt;span&gt;const&lt;/span&gt; rtvar time = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;.)
            :_a(a)
            , _b(b)
            ,_time(time)
        {  }

        ray(&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; ray&amp;amp;&lt;span&gt; r)
            :_a(r._a)
            , _b(r._b)
        {    }

        inline rtvec origin()&lt;/span&gt;&lt;span&gt;const&lt;/span&gt;        { &lt;span&gt;return&lt;/span&gt;&lt;span&gt; _a; }

        inline rtvec direction()&lt;/span&gt;&lt;span&gt;const&lt;/span&gt;    { &lt;span&gt;return&lt;/span&gt;&lt;span&gt; _b; }

        inline rtvar time()&lt;/span&gt;&lt;span&gt;const&lt;/span&gt;        { &lt;span&gt;return&lt;/span&gt;&lt;span&gt; _time; }

        inline rtvec go(&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; rtvar t)&lt;span&gt;const&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt; _a + t *&lt;span&gt; _b; }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt;:
        rtvec _a;

        rtvec _b;

        rtvar _time;

    };
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;camera.hpp&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1316111/201901/1316111-20190114222054199-564927024.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1316111/201901/1316111-20190114222017877-1686822833.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; 这样，我们就做好了产生记录随机时间的视线&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接下来就是采样了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;main.cpp&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1316111/201901/1316111-20190114222506018-1592931511.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;我们再来说第三步，视线和物体的相交计算&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个是最重要的，我们要 根据视线记录的随机时间，来确定物体的轮廓，然后进行计算交点&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;显然，我们不能用之前的sphere了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面是我们新写的moving_sphere&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;54&quot;&gt;
&lt;pre&gt;
&lt;span&gt;///&lt;/span&gt;&lt;span&gt; moving_sphere.h&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt; -----------------------------------------------------
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; [author]        lv
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; [begin ]        2019.1
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; [brief ]        the moving_sphere-class for the ray-tracing project
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                from the 《ray tracing in one week》
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; -----------------------------------------------------&lt;/span&gt;

&lt;span&gt;#pragma&lt;/span&gt; once&lt;span&gt;
#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ray.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;intersect.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; rt
{

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; moving_sphere :&lt;span&gt;public&lt;/span&gt;&lt;span&gt; intersect
    {
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
    moving_sphere() {  }
    moving_sphere(rtvec heart1, rtvec heart2, rtvar t1, rtvar t2, rtvar r, material&lt;/span&gt;*&lt;span&gt; mp)
        :_heart1(heart1)
        , _heart2(heart2)
        , _time1(t1)
        , _time2(t2)
        , _radius(r)
        , _materialp(mp)
        {
        }

    &lt;/span&gt;&lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; hit(&lt;span&gt;const&lt;/span&gt; ray&amp;amp; r, rtvar tmin, rtvar tmax, hitInfo&amp;amp; info)&lt;span&gt;const&lt;/span&gt; &lt;span&gt;override&lt;/span&gt;&lt;span&gt;;

    inline rtvec heart(rtvar t)&lt;/span&gt;&lt;span&gt;const&lt;/span&gt;&lt;span&gt;
        {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; _heart1 + ((t - _time1) / (_time2 - _time1)) * (_heart2 -&lt;span&gt; _heart1);
        }

&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt;:
    rtvec _heart1;
    rtvec _heart2;
    rtvar _time1;
    rtvar _time2;
    rtvar _radius;
    material&lt;/span&gt;*&lt;span&gt; _materialp;
    };

&lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; moving_sphere::hit(&lt;span&gt;const&lt;/span&gt; ray&amp;amp; sight, rtvar t_min, rtvar t_max, hitInfo&amp;amp; info)&lt;span&gt;const&lt;/span&gt;&lt;span&gt;
{
    rtvec trace &lt;/span&gt;= sight.origin() -&lt;span&gt; heart(sight.time());
    rtvar a &lt;/span&gt;=&lt;span&gt; dot(sight.direction(), sight.direction());
    rtvar b &lt;/span&gt;= &lt;span&gt;2.0&lt;/span&gt; *&lt;span&gt; dot(trace, sight.direction());
    rtvar c &lt;/span&gt;= dot(trace, trace) - _radius *&lt;span&gt; _radius;
    rtvar delt &lt;/span&gt;= b*b - &lt;span&gt;4.0&lt;/span&gt;*a*&lt;span&gt;c;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (delt &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
    {
        info.materialp &lt;/span&gt;=&lt;span&gt; _materialp;
        rtvar x &lt;/span&gt;= (-b - sqrt(delt)) / (&lt;span&gt;2.0&lt;/span&gt;*&lt;span&gt;a);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (x &amp;lt; t_max &amp;amp;&amp;amp; x &amp;gt;&lt;span&gt; t_min)
        {
            info._t &lt;/span&gt;=&lt;span&gt; x;
            info._p &lt;/span&gt;=&lt;span&gt; sight.go(x);
            info._n &lt;/span&gt;= (info._p - heart(sight.time())) /&lt;span&gt; _radius;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }
        x &lt;/span&gt;= (-b + sqrt(delt)) / (&lt;span&gt;2.0&lt;/span&gt;*&lt;span&gt;a);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (x &amp;lt; t_max &amp;amp;&amp;amp; x &amp;gt;&lt;span&gt; t_min)
        {
            info._t &lt;/span&gt;=&lt;span&gt; x;
            info._p &lt;/span&gt;=&lt;span&gt; sight.go(x);
            info._n &lt;/span&gt;= (info._p - heart(sight.time())) /&lt;span&gt; _radius;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
}

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt; 我们用vec3 heart（time）;来计算某个随机时间某个物体从开始位置向终止位置运动time时间之后的具体位置&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第四步和第五步就不说了，都是上述过程的重复自动计算&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;下面是开篇图片中球体参数设置&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;79&quot;&gt;
&lt;pre&gt;
intersect*&lt;span&gt; random_sphere()
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; cnt = &lt;span&gt;50000&lt;/span&gt;&lt;span&gt;;
    intersect &lt;/span&gt;**list = &lt;span&gt;new&lt;/span&gt; intersect*[cnt + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
    list[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;] = &lt;span&gt;new&lt;/span&gt; sphere(rtvec(&lt;span&gt;0&lt;/span&gt;, -&lt;span&gt;1000&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;), &lt;span&gt;1000&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt; lambertian(rtvec(&lt;span&gt;0.5&lt;/span&gt;, &lt;span&gt;0.5&lt;/span&gt;, &lt;span&gt;0.5&lt;/span&gt;&lt;span&gt;)));
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; size = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; a = -&lt;span&gt;10&lt;/span&gt;; a &amp;lt; &lt;span&gt;10&lt;/span&gt;; ++&lt;span&gt;a)
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; b = -&lt;span&gt;10&lt;/span&gt;; b &amp;lt; &lt;span&gt;10&lt;/span&gt;; ++&lt;span&gt;b)
        {
            rtvar choose_mat &lt;/span&gt;=&lt;span&gt; lvgm::rand01();
            rtvec center(a &lt;/span&gt;+ &lt;span&gt;0.9&lt;/span&gt; * lvgm::rand01(), &lt;span&gt;0.2&lt;/span&gt;, b + &lt;span&gt;0.9&lt;/span&gt;*&lt;span&gt;lvgm::rand01());
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((center - rtvec(&lt;span&gt;4&lt;/span&gt;, &lt;span&gt;0.2&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;)).normal()&amp;gt;&lt;span&gt;0.9&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (choose_mat &amp;lt; &lt;span&gt;0.75&lt;/span&gt;&lt;span&gt;)
                    list[size&lt;/span&gt;++] = &lt;span&gt;new&lt;/span&gt; moving_sphere(center, center + rtvec(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0.5&lt;/span&gt;*lvgm::rand01(), &lt;span&gt;0&lt;/span&gt;), &lt;span&gt;0&lt;/span&gt;., &lt;span&gt;1&lt;/span&gt;., &lt;span&gt;0.2&lt;/span&gt;&lt;span&gt;,
                        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; lambertian(rtvec(lvgm::rand01()*lvgm::rand01(), lvgm::rand01()*lvgm::rand01(), lvgm::rand01()*&lt;span&gt;lvgm::rand01())));

                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (choose_mat &amp;lt; &lt;span&gt;0.9&lt;/span&gt;&lt;span&gt;)
                    list[size&lt;/span&gt;++] = &lt;span&gt;new&lt;/span&gt; sphere(center, &lt;span&gt;0.2&lt;/span&gt;&lt;span&gt;,
                        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; metal(rtvec(&lt;span&gt;0.5&lt;/span&gt;*(&lt;span&gt;1&lt;/span&gt; + lvgm::rand01()), &lt;span&gt;0.5&lt;/span&gt;*(&lt;span&gt;1&lt;/span&gt; + lvgm::rand01()), &lt;span&gt;0.5&lt;/span&gt;*(&lt;span&gt;1&lt;/span&gt; + lvgm::rand01())), &lt;span&gt;0.5&lt;/span&gt;*&lt;span&gt;lvgm::rand01()));

                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                    list[size&lt;/span&gt;++] = &lt;span&gt;new&lt;/span&gt; sphere(center, &lt;span&gt;0.2&lt;/span&gt;&lt;span&gt;,
                        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; dielectric(&lt;span&gt;1.5&lt;/span&gt;&lt;span&gt;));
            }
        }

    list[size&lt;/span&gt;++] = &lt;span&gt;new&lt;/span&gt; sphere(rtvec(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;), &lt;span&gt;1.0&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt; dielectric(&lt;span&gt;1.5&lt;/span&gt;&lt;span&gt;));
    list[size&lt;/span&gt;++] = &lt;span&gt;new&lt;/span&gt; sphere(rtvec(-&lt;span&gt;4&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;), &lt;span&gt;1.0&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt; lambertian(rtvec(&lt;span&gt;0.4&lt;/span&gt;, &lt;span&gt;0.2&lt;/span&gt;, &lt;span&gt;0.1&lt;/span&gt;&lt;span&gt;)));
    list[size&lt;/span&gt;++] = &lt;span&gt;new&lt;/span&gt; sphere(rtvec(&lt;span&gt;4&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;), &lt;span&gt;1.0&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt; metal(rtvec(&lt;span&gt;0.7&lt;/span&gt;, &lt;span&gt;0.6&lt;/span&gt;, &lt;span&gt;0.5&lt;/span&gt;), &lt;span&gt;0&lt;/span&gt;&lt;span&gt;.));

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; intersections(list, size);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 相机参数设置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
rtvec lookfrom(&lt;span&gt;13&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;&lt;span&gt;);
rtvec lookat(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;float&lt;/span&gt; dist_to_focus = &lt;span&gt;10.0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;float&lt;/span&gt; aperture = &lt;span&gt;0.0&lt;/span&gt;&lt;span&gt;;
camera cma(lookfrom, lookat, rtvec(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;), &lt;span&gt;20&lt;/span&gt;, rtvar(W) / rtvar(H), aperture, &lt;span&gt;0.7&lt;/span&gt;*dist_to_focus, &lt;span&gt;0&lt;/span&gt;., &lt;span&gt;1&lt;/span&gt;.);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;还有水平运动模糊的图片正在渲染中，完成之后会贴在下面&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;感谢您的阅读，生活愉快~&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 14 Jan 2019 14:42:00 +0000</pubDate>
<dc:creator>林-兮</dc:creator>
<og:description>模拟实际生活中相机的运动模糊技术</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lv-anchoret/p/10269488.html</dc:identifier>
</item>
<item>
<title>C# 8:new关键字将能够推断类型 - 白色橡皮</title>
<link>http://www.cnblogs.com/SuperChan/p/10269394.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/SuperChan/p/10269394.html</guid>
<description>&lt;p&gt;在许多情况下，在给定的位置只能是确定的类型。但是C#却要求显示的列出类型名称。如果&lt;a href=&quot;https://github.com/dotnet/csharplang/blob/master/proposals/target-typed-new.md&quot; target=&quot;_blank&quot;&gt;Target-typed new&lt;/a&gt;表达式的建议被采纳，像这样的模板代码将不再需要。&lt;/p&gt;
&lt;p&gt;表面上看，这个特征跟var关键字相反。但是它不是从表达式中推断变量类型，而是从变量中推断表达式的类型。下面分别是使用当前语法及建议语法的例子。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前语法&lt;/span&gt;
Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, List&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&amp;gt; field = &lt;span&gt;new&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, List&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;建议语法&lt;/span&gt;
Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, List&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&amp;gt; field = &lt;span&gt;new&lt;/span&gt;();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;像你看到的一样，当C#能够根据上下文推断出类型时，就不需要再详细制定类型了。对于局部变量，它并不是很有趣。它更能在临时参数的场景下发挥作用。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前写法&lt;/span&gt;
XmlReader.Create(reader, &lt;span&gt;new&lt;/span&gt; XmlReaderSettings() { IgnoreWhitespace = &lt;span&gt;true&lt;/span&gt;&lt;span&gt; });
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;建议写法&lt;/span&gt;
XmlReader.Create(reader, &lt;span&gt;new&lt;/span&gt;() { IgnoreWhitespace = &lt;span&gt;true&lt;/span&gt; });
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再上面的代码中，类XmlReaderSettings并不是很有趣。它只不过是为了将选项值赋值给XmlReader。甚至有人认为XmlReaderSettings的出现能让我们忽视真正重要的信息。&lt;/p&gt;
&lt;p&gt;在var关键字并不适用的场景下，比如字段和属性，这个特征比较有用。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; s_syncObj = &lt;span&gt;new&lt;/span&gt;();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;根据这项建议，如下四种场景不适合使用。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;枚举： 并不是所有的枚举类型都包含0，因此应该明确列出每一个枚举成员。&lt;/li&gt;
&lt;li&gt;接口：这是一个小众的特征，最好明确的提出类型。&lt;/li&gt;
&lt;li&gt;数组： 数组的语法要求提供数组长度。&lt;/li&gt;
&lt;li&gt;结构体的默认构造函数： 这排除了所有基本类型和大多数值类型。如果您想使用此类类型的默认值，那么可以编写default。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;目前，调用者表达式属性在&lt;a href=&quot;https://github.com/dotnet/roslyn/blob/master/docs/Language%20Feature%20Status.md&quot; target=&quot;_blank&quot;&gt;c# 8路线图&lt;/a&gt;中以状态“Prototype”列出。&lt;a href=&quot;https://github.com/dotnet/roslyn/issues/28489&quot; target=&quot;_blank&quot;&gt;特性测试计划&lt;/a&gt;在GitHub上可用。&lt;/p&gt;
&lt;p&gt;本文翻译自：&lt;a href=&quot;https://www.infoq.com/news/2019/01/c-sharp-targeted-type-new&quot; target=&quot;_blank&quot;&gt;C# 8: Type Inference for the new Keyword&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 14 Jan 2019 14:21:00 +0000</pubDate>
<dc:creator>白色橡皮</dc:creator>
<og:description>在许多情况下，在给定的位置只能是确定的类型。但是C#却要求显示的列出类型名称。如果Target-typed new表达式的建议被采纳，像这样的模板代码将不再需要。 表面上看，这个特征跟var关键字相反</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/SuperChan/p/10269394.html</dc:identifier>
</item>
<item>
<title>知行：成长的迭代之路 - mindwind</title>
<link>http://www.cnblogs.com/mindwind/p/10269386.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mindwind/p/10269386.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/815275/201901/815275-20190114221607992-1148786130.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在「极客时间」更新了半年专栏，正好在年末更新完了，这篇算是专栏的尾声，算是一个总结式感悟，也在这里分享下。&lt;/p&gt;
&lt;p&gt;专栏的主题关乎成长，而成长的本质，就是两个字：知行 —— 始于知，终于行。&lt;/p&gt;
&lt;h2 id=&quot;知&quot;&gt;知&lt;/h2&gt;
&lt;p&gt;知，起于阅读；当你决定学习一样东西时，自然就会从阅读开始。从阅读中学习，要么是直接获得知识，要么就是从别人的学习经历或经验中找到值得自身借鉴的参考与启发。&lt;/p&gt;
&lt;p&gt;我硕士毕业于广州中山大学，一直让我铭记的是当年学校的校训，那是孙中山先生于 1924 年 11 月 11 日在广东大学（原校名，后为纪念孙中山先生改名）举行成立典礼时亲笔提写的十字训词：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;博学 审问 慎思 明辨 笃行&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这十字训词原文出自儒家经典《礼记·中庸》：“博学之，审问之，慎思之，明辨之，笃行之”，但孙中山先生赋予了它新时代的涵义。&lt;/p&gt;
&lt;p&gt;“博学” 好理解，在校训牌旁边不远处就是陈寅恪的故居，陈寅恪是中国现代历史学家、古典文学研究家、语言学家、中央研究院院士、中华民国清华大学国学院四大导师之一（其余三人为梁启超、王国维、赵元任），通晓二十余种语言，堪称博学之人。&lt;/p&gt;
&lt;p&gt;相比九十多年前孙中山先生的时代，今天是信息爆炸与过载的时代，知识与学问也淹没在这些爆炸的信息中，谁还能轻易堪称博学，我们只能说在信息的洪流中，保持永无止境地学习。如果能坚持学下去，那么今天的自己就比昨天的自己稍微博学一点，今年的自己也比去年的自己要博学一些。&lt;/p&gt;
&lt;p&gt;正因为信息过载，我们通过各式各样的大量阅读来接收信息，因此对这些信息进行 “审问、慎思、明辨” 就显得十分重要和关键了。“问、思、辨” 是对信息进行筛选、分析与处理，去其糟粕取其精华。经过降噪、筛选、分析处理后的信息再与我们自身已有的知识和经验结合形成属于自己的独立思考与观点，而这些独立的思考和观点才能用来指导我们的行动，也即 “笃行”。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;先有 “知”，方有 “行”。知，只是行的方法；行，才是知的目的。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;行&quot;&gt;行&lt;/h2&gt;
&lt;p&gt;在中大学习的年间，我每天早上去实验室，晚上又回来，多少次要从校训牌前来回经过。十多年后再回想当初在学校习得的那点知识和技能，要么已经过时，要么也遗忘殆尽了。最终留在心里的反倒是校训牌上那无比清晰的十字训词，并一直指导着我未来的学习与成长之路。&lt;/p&gt;
&lt;p&gt;十字训词，前 8 字 4 词占了 80% 的文字内容，但我觉着用在上面的时间和精力应该正好反过来：花 20% 时间和精力研究如何更好地 “知”，而 80% 的时间和精力放在持续地 “行” 上。搞错了比例，很可能最终也就无所成就，收获寥寥。&lt;/p&gt;
&lt;p&gt;但 “笃行” 往往是最消耗时间的阶段，一旦方向搞错了，可能大量的努力就浪费了。因此，“行” 之前的 “学、问、思、辨” 就很关键了，它们是行之前甚至行程中不断修正方向的指南针。&lt;/p&gt;
&lt;p&gt;我的专栏能提供给你的也不过是我的一些经历、经验与思考，供你行路参考。你的阅读会让你更 “博学” 一点，但这只是第一步的信息传递与接收阶段，如果没有后面的 “问、思、辨、行”， 于你又有多大的意义呢？所以，后面的部分只能靠你自己来完成了。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;纸上得来终觉浅，绝知此事要躬行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在 “行” 的路上，也许一开始都是参照走前人走过的路，虽然我们经常想走自己的路，其实绝大部分人终其一生都是在走前人的路。写到这，想起一个前几年关于我自己的真实 “行路” 的感悟。&lt;/p&gt;
&lt;p&gt;几年前，我考了驾照买了车，然后就跑去自驾。从成都出发，经过了红军长征走过的草原，绕过了青海湖边，经古代丝绸之路的路线一路开到了敦煌。丝绸之路从敦煌出去，分出两条，北上经玉门关，南下出阳关，走到那里突然有种诗和远方的感觉。&lt;/p&gt;
&lt;p&gt;但无论自驾如何自由，我们也不过是在走前人的路。在敦煌的洞窟里看到了张大千临摹的笔迹，才了解到战争年代大师也曾在这里临摹古人的壁画，走着前人的路。&lt;/p&gt;
&lt;p&gt;开着车走在路上，两边是沙漠，偶尔看见前面有车，超过，再前行，两边的沙漠变成戈壁，路看不到头，一望之下再也看不到其他的人和车，走在路上感觉有些心慌然，仅仅是走在前人的路上已有些慌然，那走出这条路的前人又该是怎样的心境？&lt;/p&gt;
&lt;p&gt;回程中，入蜀后国道一来一去两条车道，车多起来了后都只能跟着走，大车在路上慢悠悠地挡着道，小车都会借道超车。借道本身是有一定危险的，超大车还好，如果前面是小车，本身开得不慢，跟着走是不是更能在安全和速度之间取得平衡？我试过跟着小车走，不超车，结果跟不了多久就跟丢了。&lt;/p&gt;
&lt;p&gt;当你决定跟车时就放弃了超越的心，安稳是安稳些了，但节奏掌握在前车手里，最终只会被远远甩下。开车行路如此尚可，但人生之路终究是无法去跟住别人的，有一颗超越的心，按自己的节奏一直走下去，你终究会慢慢走出一条属于自己的路。&lt;/p&gt;
&lt;p&gt;这条路，难不难走？难，感觉走不下去时，不妨读读李白的诗吧。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;行路难！行路难！多歧路，今安在？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以，近年啊，我总不时读读唐诗。&lt;/p&gt;
&lt;p&gt;...&lt;/p&gt;
&lt;p&gt;感谢一路同行读到这里，希望这是你又一次 “知” 的起点，后面该看你的 “行” 了。成长，不过就是不断从 “知” 到 “行” 的迭代循环。&lt;/p&gt;
&lt;p&gt;最后，新年伊始，也祝大家：前路无碍，挂帆破浪。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;写点文字，画点画儿，记录成长瞬间。&lt;br/&gt;微信公众号「瞬息之间」，既然遇见，不如同行。&lt;br/&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/815275/201602/815275-20160216164606173-1251141402.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 14 Jan 2019 14:17:00 +0000</pubDate>
<dc:creator>mindwind</dc:creator>
<og:description>在「极客时间」更新了半年专栏，正好在年末更新完了，这篇算是专栏的尾声，算是一个总结式感悟，也在这里分享下。 专栏的主题关乎成长，而成长的本质，就是两个字：知行 —— 始于知，终于行。 知 知，起于阅读</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mindwind/p/10269386.html</dc:identifier>
</item>
<item>
<title>Django REST Framework  数码宝贝 - 3步进化 - 混合类 --&gt; - 孔辉</title>
<link>http://www.cnblogs.com/konghui/p/10268393.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/konghui/p/10268393.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　读了我这篇博客, 你会刷新对面对对象的认知, 之前的面对对象都是LJ~~~&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;表结构&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Publisher(models.Model):
    name &lt;/span&gt;= models.CharField(max_length=32&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__str__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; self.name


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Author(models.Model):
    name &lt;/span&gt;= models.CharField(max_length=32&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__str__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; self.name


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Book(models.Model):
    title &lt;/span&gt;= models.CharField(max_length=32&lt;span&gt;)
    pub_date &lt;/span&gt;=&lt;span&gt; models.DateField()
    CHOICES &lt;/span&gt;= ((1, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Python&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;), (2, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Go&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;), (3, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;linux&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
    category &lt;/span&gt;= models.IntegerField(choices=&lt;span&gt;CHOICES)
    publisher &lt;/span&gt;= models.ForeignKey(to=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Publisher&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, on_delete=&lt;span&gt;models.CASCADE)
    authors &lt;/span&gt;= models.ManyToManyField(to=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Author&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__str__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; self.title
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt; 原路由:&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
urlpatterns =&lt;span&gt; [
    url(r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;^admin/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, admin.site.urls),
    url(r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;^books/$&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, views.BookListView.as_view()),
    url(r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;book/(?P&amp;lt;pk&amp;gt;\d+)$&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, views.BookDetailView.as_view()),

    url(r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;^publishers/$&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, views.PublisherView.as_view()),
    url(r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;publishers/(?P&amp;lt;pk&amp;gt;\d+)$&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, views.PublisherDetailView.as_view()),

]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;原始版:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;获取出版社信息  &lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取出版社信息&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; PublisherView(APIView):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;使用Django REST framework 内置的序列化&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; get(self,request):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;Json格式返回所有的书籍信息&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        queryset &lt;/span&gt;=&lt;span&gt; models.Publisher.objects.all()
        ser_obj &lt;/span&gt;= ModelPublisherSerlizer(queryset, many=&lt;span&gt;True)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Response(ser_obj.data)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; post(self, request):
        ser_obj &lt;/span&gt;= ModelPublisherSerlizer(data=&lt;span&gt;request.data)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; ser_obj:
            ser_obj.save()
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Response(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ok&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Response(ser_obj.errors)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　&lt;strong&gt;&lt;span&gt;获取具体某个出版社信息 查 改 删 -- &amp;gt;&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;　&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取具体某个出版社信息&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; PublisherDetailView(APIView):

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; get(self,pk):
        publisher_ob &lt;/span&gt;= models.Publisher.objects.filter(pk=&lt;span&gt;pk)
        publisher_obj &lt;/span&gt;= models.Publisher.objects.filter(pk=&lt;span&gt;pk).first()
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;publisher_ob&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, publisher_ob, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;publisher_obj&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, publisher_obj)

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; publisher_obj:
            ser_obj &lt;/span&gt;=&lt;span&gt; ModelPublisherSerlizer(publisher_obj)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Response(ser_obj.data)
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Response(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;无效的id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; put(self, request, pk):
        publisher_obj &lt;/span&gt;= models.Publisher.objects.filter(pk=&lt;span&gt;pk).first()

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; publisher_obj:
            ser_obj &lt;/span&gt;= ModelPublisherSerlizer(instance=publisher_obj, data=request.data, partial=&lt;span&gt;True)
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; ser_obj.is_valid():
                ser_obj.save()
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Response(ser_obj.data)
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Response(ser_obj.errors)
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Response(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;没有这本书&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)


    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; delete(self,pk):
        publisher_obj &lt;/span&gt;= models.Publisher.objects.filter(pk=&lt;span&gt;pk)

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; publisher_obj:
            publisher_obj.delete()
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Response(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;删除成功&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Response(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;没有这本书&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;

&lt;hr/&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;进化版:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　把出版社相关信息封装起来&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; CemericView(APIView):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;视图中可能用到的配置和方法封装起来&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    queryset &lt;/span&gt;=&lt;span&gt; None
    serializer_class &lt;/span&gt;=&lt;span&gt; None

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_queryset(self):
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 让每次请求来的时候都先查一次数据&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; self.queryset.all()


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; ListMinxin(object):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; get(self, request):
        queryset &lt;/span&gt;=&lt;span&gt; self.get_queryset()
        ser_obj &lt;/span&gt;= self.serializer_class(queryset, many=&lt;span&gt;True)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Response(ser_obj.data)

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; CreateMixin(object):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; post(self, request):
        ser_obj &lt;/span&gt;= self.serializer_class(data=&lt;span&gt;request.data)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; ser_obj:
            ser_obj.save()
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Response(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ok&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Response(ser_obj.errors)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取出版社信息&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; PublisherView(CemericView, ListMinxin, CreateMixin):

    queryset &lt;/span&gt;=&lt;span&gt; models.Publisher.objects.all()
    serializer_class &lt;/span&gt;= ModelPublisherSerlizer
&lt;/pre&gt;&lt;/div&gt;

&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;超级进化版:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　把某个出版社的信息也封装起来&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;70&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; GemericView(APIView):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;视图中可能用到的配置和方法封装起来&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    queryset &lt;/span&gt;=&lt;span&gt; None
    serializer_class &lt;/span&gt;=&lt;span&gt; None

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_queryset(self):
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 让每次请求来的时候都先查一次数据&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; self.queryset.all()

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; get_obj(self, request, pk, *args, **&lt;span&gt;kwargs):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; self.get_queryset().filter(pk=pk).filter(pk=&lt;span&gt;pk).first()
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; ListMinxin(object):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; get(self, request):
        queryset &lt;/span&gt;=&lt;span&gt; self.get_queryset()
        ser_obj &lt;/span&gt;= self.serializer_class(queryset, many=&lt;span&gt;True)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Response(ser_obj.data)


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; CreateMixin(object):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; post(self, request):
        ser_obj &lt;/span&gt;= self.serializer_class(data=&lt;span&gt;request.data)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; ser_obj.is_valid():
            ser_obj.save()
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Response(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ok&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Response(ser_obj.errors)


&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取出版社信息&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; PublisherView(GemericView, ListMinxin, CreateMixin):

    queryset &lt;/span&gt;=&lt;span&gt; models.Publisher.objects.all()
    serializer_class &lt;/span&gt;=&lt;span&gt; ModelPublisherSerlizer


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; RetrieveMixin(object):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; get(self, request, pk, *args, **&lt;span&gt;kwargs):
        obj &lt;/span&gt;= self.get_obj(request, pk, *args, **&lt;span&gt;kwargs)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; obj:
            ser_obj &lt;/span&gt;=&lt;span&gt; self.serializer_class(obj)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Response(ser_obj.data)
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Response(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;无效的id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; UpdateMixin(object):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; put(self, request, pk, *args, **&lt;span&gt;kwargs):
        obj &lt;/span&gt;= self.get_obj(request, pk, *args, **&lt;span&gt;kwargs)

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; obj:
            ser_obj &lt;/span&gt;= ModelPublisherSerlizer(instance=obj, data=request.data, partial=&lt;span&gt;True)
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; ser_obj.is_valid():
                ser_obj.save()
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Response(ser_obj.data)
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Response(ser_obj.errors)
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Response(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;没有这本书&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; DelMixin(object):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; delete(self, request, pk, *args, **&lt;span&gt;kwargs):
        obj &lt;/span&gt;= self.get_obj(request, pk, *args, **&lt;span&gt;kwargs)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(obj)
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; print(obj.filter(pk = pk))&lt;/span&gt;

        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; obj:
            obj.delete()
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Response(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;删除成功&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Response(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;没有这本书&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)


&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取具体某个出版社信息&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; PublisherDetailView(GemericView, RetrieveMixin, UpdateMixin, DelMixin):
    queryset &lt;/span&gt;=&lt;span&gt; models.Publisher.objects.all()
    serializer_class &lt;/span&gt;= ModelPublisherSerlizer
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　&lt;strong&gt;&lt;span&gt;如果在写一个api 的话 只需要3行代码, &lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　　　但是 封装的代码好像有点多, 继承关系有点乱,&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　　　　　其实框架本身提供了内置方法, &lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; rest_framework.mixins &lt;span&gt;import&lt;/span&gt; ListModelMixin, CreateModelMixin, RetrieveModelMixin, UpdateModelMixin, DestroyModelMixin
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;注意: 单纯的导入 不能成功, 因为 此方法中不是以 get ,post 等命名的, 导致 MVC模型中 as.view(), 找不到 请求的方式, 需要 对 这些方法进行进一步封装&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1479869/201901/1479869-20190114210439671-1177335428.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt; 就有了下面的内置方法&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; rest_framework.generics &lt;span&gt;import&lt;/span&gt;&lt;span&gt; ListCreateAPIView,RetrieveDestroyAPIView

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;这个包里里面 封装了 各种用于API 开发的浏览器 请求方式, 及组合方式, 直接调用即可&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;&lt;em&gt;一共 7行 代码解决&lt;/em&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; rest_framework.generics &lt;span&gt;import&lt;/span&gt;&lt;span&gt; ListCreateAPIView, RetrieveDestroyAPIView

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取出版社信息&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; PublisherView(ListCreateAPIView):

    queryset &lt;/span&gt;=&lt;span&gt; models.Publisher.objects.all()
    serializer_class &lt;/span&gt;=&lt;span&gt; ModelPublisherSerlizer

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取具体某个出版社信息&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; PublisherDetailView(RetrieveDestroyAPIView):
    queryset &lt;/span&gt;=&lt;span&gt; models.Publisher.objects.all()
    serializer_class &lt;/span&gt;= ModelPublisherSerlizer
&lt;/pre&gt;&lt;/div&gt;

&lt;hr/&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;究极进化版&lt;/span&gt;:&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　上面超级进化版 一张表要写两个视图 定义queryset和serializer_class 重复,&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　而且  路由也需要重复, 显然, 究极进化是不允许的~~&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;md-focus-p&quot;&gt;&lt;span class=&quot;md-line md-end-block md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;　　　　&lt;strong&gt;&lt;span&gt;重写了&lt;code&gt;as_view()&lt;/code&gt;方法，实现了根据请求的方法执行具体的类方法&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;　　　路由注册的时候，利用actions参数，实现路由的定向分发 而不是简单的 反射&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
url(r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;authors/$&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, views.AuthorViewSet.as_view(actions={&lt;span&gt;'&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;post&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;create&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;})),  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 作者列表&lt;/span&gt;
url(r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;authors/(?P&amp;lt;pk&amp;gt;\d+)/$&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, views.AuthorViewSet.as_view(
        actions&lt;/span&gt;={&lt;span&gt;'&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;retrieve&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;put&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;update&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;delete&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;destroy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;})
        ),  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 作者详情&lt;/span&gt;　　　
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-focus-p&quot;&gt;&lt;span class=&quot;md-line md-end-block md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;　　　　&lt;span&gt;&lt;strong&gt;路由都重复写两条：&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;　　　还可以利用内置的DefaultRouter来实现路由的注册&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; rest_framework.routers &lt;span&gt;import&lt;/span&gt;&lt;span&gt; DefaultRouter

router &lt;/span&gt;=&lt;span&gt; DefaultRouter()
router.register(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;authors&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, views.AuthorViewSet)

urlpatterns &lt;/span&gt;+= router.urls
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; rest_framework.viewsets &lt;span&gt;import&lt;/span&gt;&lt;span&gt; ModelViewSet
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; AuthorViewSet(ModelViewSet):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        list()
        create()
        retrieve()
        update()
        destroy()

    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    queryset &lt;/span&gt;=&lt;span&gt; models.Author.objects.all()
    serializer_class &lt;/span&gt;= AuthorModelSerializer
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;总结: &lt;/span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　&lt;span&gt;建议用以下两种方式&lt;/span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1479869/201901/1479869-20190114220105178-568867006.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 14 Jan 2019 14:08:00 +0000</pubDate>
<dc:creator>孔辉</dc:creator>
<og:description>读了我这篇博客, 你会刷新对面对对象的认知, 之前的面对对象都是LJ~~~ 表结构 原路由: 原始版: 获取出版社信息 获取具体某个出版社信息 查 改 删 -- &gt; 进化版: 把出版社相关信息封</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/konghui/p/10268393.html</dc:identifier>
</item>
</channel>
</rss>