<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>纪念 Vamei - 豌豆花下猫</title>
<link>http://www.cnblogs.com/pythonista/p/10503790.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pythonista/p/10503790.html</guid>
<description>&lt;p&gt;偶然在某公众号里看到一篇文章，得知 Vamei 去世的消息。&lt;/p&gt;
&lt;p&gt;看到它之前，我并不知道这位“知名的 Python 技术博主”。我写 Python 技术文章有一小段时间了，也认识了很多圈内的博主。但是，这个 Vamei 是谁呢？竟不认识。我很好奇。&lt;/p&gt;
&lt;p&gt;因为消息是从豆瓣里传出来的，我就去搜他的豆瓣。然后，一路看到了他的知乎，他的书，他的技术博客，他的演讲，他的微博，甚至他的公众号，也看到了一些友人的纪念文章。&lt;/p&gt;
&lt;p&gt;看得越多，我就越放不下了。正好我在写一篇荐书栏目，就发现他跟我恰巧同时在读着一本未上市的新书。这个难得的巧合让我更不能释怀，我自以为这是一个神秘主义的讯息。&lt;/p&gt;
&lt;p&gt;该拿他怎么办呢？我决定就写下这篇东西，以作纪念吧。&lt;/p&gt;
&lt;h2 id=&quot;h1&quot;&gt;（1）一首诗&lt;/h2&gt;
&lt;p&gt;他在豆瓣的最后一篇日记是一首诗：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;《寻影》&lt;/p&gt;
&lt;p&gt;远处的光臆造身前的影。&lt;/p&gt;
&lt;p&gt;影高而大，&lt;/p&gt;
&lt;p&gt;噬我，缠绕我，御我为奴。&lt;/p&gt;
&lt;p&gt;我与影欢歌。&lt;/p&gt;
&lt;p&gt;倏忽，&lt;/p&gt;
&lt;p&gt;光灭影消。&lt;/p&gt;
&lt;p&gt;黑漆漆的我，&lt;/p&gt;
&lt;p&gt;不知何处寻影。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;发布时间 2 月 21 日，距离世日期仅一周。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;http://ww1.sinaimg.cn/large/68b02e3bgy1g0wy6ejeipj20u00u0754.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一个臆造的高大的影，吃人奴役人，然而他说，与影欢歌。这是哪种的乐？是愚者后知后觉，还是英雄苦中寻乐？&lt;/p&gt;
&lt;p&gt;光灭影消，不去寻光，却要找影，为什么？是因为没有了光，还是他离不开影？&lt;/p&gt;
&lt;p&gt;黑漆漆的 Vamei，他的外号是“挖煤”。&lt;/p&gt;
&lt;p&gt;挖煤，挖煤，挖的是什么煤？&lt;/p&gt;
&lt;p&gt;挖出来知识的煤、技术的煤，照亮了读者。可是没有挖出生命的煤，又或者是，挖出的那生命的煤已烧干净了呢，没办法再继续照亮他自己？&lt;/p&gt;
&lt;h2 id=&quot;h2&quot;&gt;（2）他是谁？&lt;/h2&gt;
&lt;p&gt;他生于 1988 年，本科毕业于中科大，博士毕业于南洋理工。&lt;/p&gt;
&lt;p&gt;他出版了两本纸书《从Python开始学编程》和《树莓派开始，玩转Linux》，在豆瓣读书上出了 6 本电子书，内容既有网络协议、新加坡考古、气象人物与历史，还有手机摄影，以及一本中篇科幻小说。&lt;/p&gt;
&lt;p&gt;他写技术博客，内容有 Python/Linux/网络协议/算法/Java/数据科学的系列文章，200 多篇，据统计，总阅读量超过 800 万。按照积分排名，他是 156 名。&lt;/p&gt;
&lt;p&gt;他是某智能农业公司的首席技术官，因 AI 养猪而闻名，被邀请上《一席》节目做过分享。他演讲时幽默风趣，堪称程序员界的段子手。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;Vamei制服一头猪&quot; src=&quot;http://ww1.sinaimg.cn/large/68b02e3bgy1g0wxw14l05j20p20hm1b9.jpg&quot; alt=&quot;Vamei制服一头猪&quot;/&gt;Vamei制服一头猪&lt;/p&gt;
&lt;p&gt;他兴趣广泛，学识渊博，从电影中聊历史，从名画中聊天气，写过科普，写过手机摄影教程。有作品发表在南方人物周刊、国家人文历史、澎湃新闻、果壳网这样的主流媒体上。&lt;/p&gt;
&lt;p&gt;他研究过创伤心理学，写过一篇《没有杀死我的》。语自尼采——&lt;strong&gt;没有杀死我的让我更强大。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在这篇文章的末尾，他写道：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;我的记忆中有一些窘迫或者恐惧的片段，希望有一天能够淡然看待这些。&lt;/p&gt;
&lt;p&gt;痛并快乐着，送给所有努力和创伤斗争的朋友。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;h3&quot;&gt;（3）什么杀了他？&lt;/h2&gt;
&lt;p&gt;我想在他留下来的痕迹里找出一个解释：这么一个有趣的人，是什么杀了他？&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;一个友人的豆瓣广播&quot; src=&quot;http://ww1.sinaimg.cn/large/68b02e3bgy1g0wv9p3qnhj20q00eago3.jpg&quot; alt=&quot;一个友人的豆瓣广播&quot;/&gt;一个友人的豆瓣广播&lt;/p&gt;
&lt;p&gt;所有认识他的人都表示震惊，一个阳光男孩，一个风趣博主，怎么说走就走了呢？&lt;/p&gt;
&lt;p&gt;一个插画师说：“回来吧 你书稿还没写完啊”。&lt;/p&gt;
&lt;p&gt;一个朋友说：“记得几个月前还在问我办理准生证的事”。另一个朋友说：“我还以为他忙于工作和照看婴儿，像我在我女儿刚出生那时一样，无暇顾及社交”。&lt;/p&gt;
&lt;p&gt;大家都没想到。没有任何迹象，除了那首短诗。&lt;/p&gt;
&lt;p&gt;人们常说，女性可能会得产后抑郁。可是，作为一个新晋爸爸，他怎么也抑郁了呢？那到底是多重的抑郁，才会使一个丈夫、一个爸爸，抛家弃子，纵身跃下高楼？&lt;/p&gt;
&lt;p&gt;Vamei 写下了很多文字，但几乎没有写过家庭和家人。我做了一番侦探工作，才仅仅获得几条零碎的线索。最近的一条是 2015 年的年终回顾，他写到：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;最先浮现的是一些快乐的孤点。和太太躲在阳台上吃自制的麻辣香锅，被辣得快要晕过去。生日那天被忽悠到公园，在亭子里意外收到一堆生日礼物。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;往前一年，他得意地晒出“挖夫人送给挖煤君的生日礼物”，那是一本手工相册，贴了他的摄影作品。相册背部依稀写着“By Vivian With love”。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;http://ww1.sinaimg.cn/large/68b02e3bgy1g0wya6scj1j20u00u0wkv.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再往前一年，是他们相识的第三年，大概正是那时，婚姻、蜜月、搬家，和乐融融。&lt;/p&gt;
&lt;p&gt;其它时候，其它家人，没有踪迹可寻。他全部的世界似乎都在几大网络平台中，豆瓣、微博、博客园、知乎，身份始终是网红、科普达人、技术达人、撰稿人和文青。&lt;/p&gt;
&lt;p&gt;他的豆瓣签名解释了自己的身份：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Vamei 是赤道附近一个台风的名字。按照气象规律，台风不常出现在赤道。所以，Vamei 是一个离群的风，无所顾忌地生长，不着边际地游荡。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;抑郁症的倾向深深地隐藏在其中，你甚至可能怀疑，这样一个高智商的、自由的、成功的、热爱生活的人，绝对不会做出那种事来。&lt;/p&gt;
&lt;p&gt;可是，越是聪明而理智的人，越是善于藏住自己的阴郁，所以，即使是他的深夜自白中，你也看不出文字的密码：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;我也提笔写文，作一些历史与自然的文章，用一知半解和胡思乱想编织成一个自己的精神世界。然而骗得了他人，却开解不了自己：那些文章，只不过是为了安放无处可去的自己。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那些试图并且成功杀死了他的东西，究竟是什么呢？我仍不得而知。&lt;/p&gt;
&lt;p&gt;继续读那篇《没有杀死我的》。他为什么会关心创伤心理学呢？&lt;/p&gt;
&lt;p&gt;他在说创伤是一种财富，说创伤是一个成长的机会，说要不断体验创伤造成的痛苦，来达到自我的实现，这个时候，他说的是自我疗伤的经验，还是仅仅在作一份科普呢？&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;http://ww1.sinaimg.cn/large/68b02e3bgy1g0wy7q0wnxj20qo0qo75q.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;没有杀死我的让我更强大，可是，我变强大，那杀人犯也在变强大啊。那想要杀我的东西，并不是一把痛快的刀，而是一把吱呀吱呀的锯子，磨啊磨，等你麻木了的时候，时间就站到了死神的一边。&lt;/p&gt;
&lt;p&gt;Vamei 啊，Vamei 啊，你要指出我的错谬么？&lt;/p&gt;
&lt;p&gt;愿在天国，仍有撰稿创作的平台，有代码和猪。&lt;/p&gt;
&lt;p&gt;愿在天国，没有抑郁症。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;相关文章：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一席演讲：https://mp.weixin.qq.com/s/usQ3vBg0EqAiHiysJ5ZRjQ&lt;/p&gt;
&lt;p&gt;没有杀死我的：https://www.cnblogs.com/vamei/archive/2013/01/15/2861928.html&lt;/p&gt;
&lt;p&gt;朋友纪念1：https://mp.weixin.qq.com/s/BsP8pCtuIjD7mOPQThlWzg&lt;/p&gt;
&lt;p&gt;朋友纪念2：https://mp.weixin.qq.com/s/_S8P0uxU_jT81lNfJzRztA&lt;/p&gt;
&lt;p&gt;技术圈纪念1：https://mp.weixin.qq.com/s/mKqrqt0gFfpifEnTzccYbQ&lt;/p&gt;
&lt;p&gt;技术圈纪念2：https://mp.weixin.qq.com/s/EOhJXsXO8tgibZ9PDZXLfg&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;http://ww1.sinaimg.cn/large/68b02e3bgy1g0wy5wiwu6j20u00u0n0r.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;PS：除驯猪图，其它照片皆 Vamei 所摄，取自豆瓣&lt;/p&gt;
</description>
<pubDate>Sat, 09 Mar 2019 15:55:00 +0000</pubDate>
<dc:creator>豌豆花下猫</dc:creator>
<og:description>偶然在某公众号里看到一篇文章，得知 Vamei 去世的消息。 看到它之前，我并不知道这位“知名的 Python 技术博主”。我写 Python 技术文章有一小段时间了，也认识了很多圈内的博主。但是，这</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pythonista/p/10503790.html</dc:identifier>
</item>
<item>
<title>Linux内核 - |瑾诺学长|</title>
<link>http://www.cnblogs.com/jin-nuo/p/10503774.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jin-nuo/p/10503774.html</guid>
<description>&lt;p&gt;今天，我来为大家解读一幅来自 TurnOff.us 的漫画 “InSide The &lt;a href=&quot;https://mb.yidianzixun.com/channel/w/linux&quot;&gt;Linux&lt;/a&gt; Kernel” 。 TurnOff.us 是一个极客漫画网站，作者Daniel Stori 画了一些非常有趣的关于编程语言、Web、云计算、Linux 相关的漫画。今天解读的便是其中的一篇。&lt;/p&gt;
&lt;p&gt;在开始，我们先来看看这幅漫画的全貌！&lt;/p&gt;
&lt;div&gt;&lt;span class=&quot;a-image&quot;&gt;&lt;span class=&quot;a-image&quot;&gt;&lt;img src=&quot;https://i1.go2yd.com/image.php?url=0LOyG05fVJ&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;

&lt;/div&gt;
&lt;p&gt;这幅漫画是以一个房子的侧方刨面图来绘画的。使用这样的一个房子来代表 Linux 内核。&lt;/p&gt;
&lt;h2&gt;地基&lt;/h2&gt;
&lt;p&gt;作为一个房子，最重要的莫过于其地基，在这个图片里，我们也从最下面的地基开始看起：&lt;/p&gt;
&lt;div&gt;&lt;span class=&quot;a-image&quot;&gt;&lt;span class=&quot;a-image&quot;&gt;&lt;img src=&quot;https://i1.go2yd.com/image.php?url=0LOyG0W7LA&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;

&lt;/div&gt;
&lt;p&gt;&lt;em&gt;地基&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;地基（底层）由一排排的文件柜组成，井然有序，文件柜里放置着“文件”——&lt;a href=&quot;https://mb.yidianzixun.com/channel/w/%E7%94%B5%E8%84%91&quot;&gt;电脑&lt;/a&gt;中的文件。左上角，有一只胸前挂着 421 号牌的小企鹅，它表示着 PID（进程 IDProcess ID） 为 421 的进程，它正在查看文件柜中的文件，这代表系统中正有一个进程在访问文件系统。在右下角有一只小狗，它是&lt;a href=&quot;https://mb.yidianzixun.com/channel/w/%E7%9C%8B%E9%97%A8%E7%8B%97watchdog&quot;&gt;看门狗watchdog&lt;/a&gt; ，这代表对文件系统的监控。&lt;/p&gt;
&lt;div&gt;&lt;span class=&quot;a-image&quot;&gt;&lt;span class=&quot;a-image&quot;&gt;&lt;img src=&quot;https://i1.go2yd.com/image.php?url=0LOyG0uETA&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;

&lt;/div&gt;
&lt;p&gt;&lt;em&gt;一层（地面层）&lt;/em&gt;&lt;/p&gt;
&lt;h2&gt;一层（地面层）&lt;/h2&gt;
&lt;p&gt;看完了地基，接下来我们来看地基上面的一层，都有哪些东西。&lt;/p&gt;
&lt;div&gt;&lt;span class=&quot;a-image&quot;&gt;&lt;span class=&quot;a-image&quot;&gt;&lt;img src=&quot;https://i1.go2yd.com/image.php?url=0LOyG07ZMM&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;

&lt;/div&gt;
&lt;p&gt;&lt;em&gt;进程表&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;这一层，最引人瞩目的莫过于中间的一块垫子，众多小企鹅在围着着桌子坐着。这个垫子的区域代表进程表。&lt;/p&gt;
&lt;p&gt;左上角有一个小企鹅，站着，仿佛在说些什么这显然是一位家长式的人物，不过看起来周围坐的那些小企鹅不是很听话——你看有好多走神、自顾自聊天的——“喂喂，说你呢，哇塞娃（171），转过身来”。它代表着 &lt;a href=&quot;https://mb.yidianzixun.com/channel/w/linux&quot;&gt;Linux&lt;/a&gt; 内核中的初始化（init）进程，也就是我们常说的 PID 为 1 的进程。桌子上坐的小企鹅都在等待状态wait中，等待工作任务。&lt;/p&gt;
&lt;div&gt;&lt;span class=&quot;a-image&quot;&gt;&lt;span class=&quot;a-image&quot;&gt;&lt;img src=&quot;https://i1.go2yd.com/image.php?url=0LOyG0d203&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;

&lt;/div&gt;
&lt;p&gt;&lt;em&gt;看门狗&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;瞧瞧，垫子（进程表）两旁有两只小狗，它会监控小企鹅的状态（监控进程），当小企鹅们不听话时，它就会汪汪地叫喊起来。&lt;/p&gt;
&lt;div&gt;&lt;span class=&quot;a-image&quot;&gt;&lt;span class=&quot;a-image&quot;&gt;&lt;img src=&quot;https://i1.go2yd.com/image.php?url=0LOyG0QTCH&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;

&lt;/div&gt;
&lt;p&gt;&lt;em&gt;http 进程&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;在这层的左侧，有一只号牌为 1341 的小企鹅，守在门口，门上写着 80，说明这个 PID 为 1341 的小企鹅负责接待 80 端口，也就是我们常说的 HTTP （网站）的端口。小企鹅头上有一片羽毛，这片羽毛大有来历，它是著名的 HTTP 服务器 &lt;a href=&quot;https://mb.yidianzixun.com/channel/w/apache&quot;&gt;Apache&lt;/a&gt; 的 Logo。喏，就是这只：&lt;/p&gt;
&lt;div&gt;&lt;span class=&quot;a-image&quot;&gt;&lt;span class=&quot;a-image&quot;&gt;&lt;img src=&quot;https://i1.go2yd.com/image.php?url=0LOyG0F1mE&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;

&lt;/div&gt;
&lt;p&gt;&lt;em&gt;&lt;a href=&quot;https://mb.yidianzixun.com/channel/w/apache&quot;&gt;apache&lt;/a&gt; logo&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;向右看，我们可以看到这里仍有一扇门，门上写着 21，但是，看起来这扇门似乎年久失修，上面的门牌号都歪了，门口也没人守着。看起来这个 21 端口的 FTP 协议有点老旧了，目前用的人也比以前少了，以至于这里都没人接待了。&lt;/p&gt;
&lt;div&gt;&lt;span class=&quot;a-image&quot;&gt;&lt;span class=&quot;a-image&quot;&gt;&lt;img src=&quot;https://i1.go2yd.com/image.php?url=0LOyG0yPZt&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;

&lt;/div&gt;
&lt;p&gt;&lt;em&gt;无人看守的 FTP 进程&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;而在最右侧的一个门牌号 22 的们的待遇就大为不同，居然有一只带着墨镜的小企鹅在守着，看起来好酷啊，它是黑衣人叔叔吗？为什么要这么酷的一个企鹅呢，因为 22 端口是 &lt;a href=&quot;https://mb.yidianzixun.com/channel/w/ssh&quot;&gt;SSH&lt;/a&gt; 端口，是一个非常重要的&lt;a href=&quot;https://mb.yidianzixun.com/channel/w/%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5&quot;&gt;远程连接&lt;/a&gt;端口，通常通过这个端口进行远程管理，所以对这个端口进来的人要仔细审查。&lt;/p&gt;
&lt;div&gt;&lt;span class=&quot;a-image&quot;&gt;&lt;span class=&quot;a-image&quot;&gt;&lt;img src=&quot;https://i1.go2yd.com/image.php?url=0LOyG091um&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;

&lt;/div&gt;
&lt;p&gt;&lt;em&gt;&lt;a href=&quot;https://mb.yidianzixun.com/channel/w/ssh&quot;&gt;SSH&lt;/a&gt; 守护进程&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;它的身上写着 52，说明它是第 52 个小企鹅。&lt;/p&gt;
&lt;div&gt;&lt;span class=&quot;a-image&quot;&gt;&lt;span class=&quot;a-image&quot;&gt;&lt;img src=&quot;https://i1.go2yd.com/image.php?url=0LOyG0PdjT&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;

&lt;/div&gt;
&lt;p&gt;&lt;em&gt;到达文件系统&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;在图片的左上角，有一个向下台阶。这个台阶是底层（地基）的文件系统中的，进程们可以通过这个台阶，到文件系统中去读取文件，进行操作。&lt;/p&gt;
&lt;div&gt;&lt;span class=&quot;a-image&quot;&gt;&lt;span class=&quot;a-image&quot;&gt;&lt;img src=&quot;https://i1.go2yd.com/image.php?url=0LOyG0d2BJ&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;

&lt;/div&gt;
&lt;p&gt;&lt;em&gt;cron 任务&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;在这一层中，有一个身上写着 217 的小企鹅，他正满头大汗地看着自己的手表。这只小企鹅就是定时任务（&lt;a href=&quot;https://mb.yidianzixun.com/channel/w/crontab&quot;&gt;Crontab&lt;/a&gt;），他会时刻关注时间，查看是否要去做某个工作。&lt;/p&gt;
&lt;div&gt;&lt;span class=&quot;a-image&quot;&gt;&lt;span class=&quot;a-image&quot;&gt;&lt;img src=&quot;https://i1.go2yd.com/image.php?url=0LOyG0me1k&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;

&lt;/div&gt;
&lt;p&gt;&lt;em&gt;管道&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;在图片的中部，有两个小企鹅扛着管道（&lt;a href=&quot;https://mb.yidianzixun.com/channel/w/pipeline&quot;&gt;PipeLine&lt;/a&gt;）在行走，一只小企鹅可以把自己手上的东西通过这个管道，传递给后面的小企鹅。不过怎么看起来前面这种（男？）企鹅累得满头大汗，而后面那只（女？）企鹅似乎游刃有余——喂喂，前面那个，裤子快掉了~&lt;/p&gt;
&lt;div&gt;&lt;span class=&quot;a-image&quot;&gt;&lt;span class=&quot;a-image&quot;&gt;&lt;img src=&quot;https://i1.go2yd.com/image.php?url=0LOyG0yq1V&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;

&lt;/div&gt;
&lt;p&gt;&lt;em&gt;&lt;a href=&quot;https://mb.yidianzixun.com/channel/w/wine&quot;&gt;Wine&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;在这一层还有另外的一个小企鹅，它手上拿着一杯红酒，身上写着 411，看起来有点不胜酒力。它就是红酒（&lt;a href=&quot;https://mb.yidianzixun.com/channel/w/wine&quot;&gt;Wine&lt;/a&gt;）小企鹅,它可以干（执行）一些来自 Windows 的任务。&lt;/p&gt;
&lt;h2&gt;跃层&lt;/h2&gt;
&lt;p&gt;在一层之上，还有一个跃层，这里有很多不同的屏幕，每个屏幕上写着 TTY（这就是对外的终端）。比如说最左边 tty4 上输入了“fre”——这是想输入“freshmeat…”么 ：d ；它旁边的 tty2 和 tty3 就正常多了，看起来是比较正常的命令；tty7 显示的图形界面嗳，对，图形界面（X Window）一般就在 7 号终端；tty5 和 tty6 是空的，这表示这两个终端没人用。等等，tty1 呢？&lt;/p&gt;
&lt;div&gt;&lt;span class=&quot;a-image&quot;&gt;&lt;span class=&quot;a-image&quot;&gt;&lt;img src=&quot;https://i1.go2yd.com/image.php?url=0LOyG08k2u&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;

&lt;/div&gt;
&lt;p&gt;&lt;em&gt;跃层&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;tty（终端）是对外沟通的渠道之一，但是，不是每一个进程都需要 tty，某些进程可以直接通过其他途径（比如端口）来和外部进行通信，对外提供服务的，所以，这一层不是完整的一层，只是个跃层。&lt;/p&gt;
&lt;p&gt;好了，我们有落下什么吗？&lt;/p&gt;
&lt;div&gt;&lt;span class=&quot;a-image&quot;&gt;&lt;span class=&quot;a-image&quot;&gt;&lt;img src=&quot;https://i1.go2yd.com/image.php?url=0LOyG0flqf&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;

&lt;/div&gt;
&lt;p&gt;&lt;em&gt;&lt;a href=&quot;https://mb.yidianzixun.com/channel/w/%E5%B0%8F%E4%B8%91&quot;&gt;小丑&lt;/a&gt;？&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;这&lt;a href=&quot;https://mb.yidianzixun.com/channel/w/%E5%B0%8F%E4%B8%91&quot;&gt;小丑&lt;/a&gt;是谁啊？&lt;/p&gt;
&lt;p&gt;啊哈，我也不知道，或许是病毒&lt;/p&gt;
</description>
<pubDate>Sat, 09 Mar 2019 15:49:00 +0000</pubDate>
<dc:creator>|瑾诺学长|</dc:creator>
<og:description>今天，我来为大家解读一幅来自 TurnOff.us 的漫画 “InSide The Linux Kernel” 。 TurnOff.us 是一个极客漫画网站，作者Daniel St</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jin-nuo/p/10503774.html</dc:identifier>
</item>
<item>
<title>OpenCV 4.0.1 找不到R.styleable解决 - 2523984508</title>
<link>http://www.cnblogs.com/qq2523984508/p/10503775.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qq2523984508/p/10503775.html</guid>
<description>&lt;p&gt;OpenCV 4.0.1作为模块导入Android Studio会有找不到R.styleable的问题。&lt;/p&gt;

&lt;p&gt;解决方法&lt;/p&gt;

&lt;p&gt;1.导入模块前&lt;/p&gt;
&lt;p&gt;　　将 opencv-4.0.1-android-sdk\OpenCV-android-sdk\sdk\java目录下build.gradle文件里的res.srcDirs = ['/build/master_pack-android/opencv/modules/java/android_sdk/android_gradle_lib/res']改为res.srcDirs = ['res']之后再导入模块。此法一劳永逸,之后在别的项目里使用OpenCV时配置都是正确的。&lt;/p&gt;

&lt;p&gt;2.导入模块后&lt;/p&gt;
&lt;p&gt;　　将导入模块的build.gradle文件做相应修改即可。其实这个build.gradle文件就是从opencv-4.0.1-android-sdk\OpenCV-android-sdk\sdk\java复制过来的。&lt;/p&gt;

&lt;p&gt;感谢:&lt;/p&gt;
&lt;p&gt;　　1.&lt;a href=&quot;http://answers.opencv.org/question/207462/working-with-opencv-401-and-android-studio-but-getting-rstyleable-errors/&quot; target=&quot;_blank&quot;&gt;Working with OpenCV 4.0.1 and Android Studio but getting R.Styleable errors&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　2.&lt;a href=&quot;https://github.com/opencv/opencv/issues/13522&quot; target=&quot;_blank&quot;&gt;Hardcoded gradle `res.srcDirs` in OpenCV 4.0.1 Android pack&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 09 Mar 2019 15:49:00 +0000</pubDate>
<dc:creator>2523984508</dc:creator>
<og:description>OpenCV 4.0.1作为模块导入Android Studio会有找不到R.styleable的问题。 解决方法 1.导入模块前 将 opencv-4.0.1-android-sdk\Op</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qq2523984508/p/10503775.html</dc:identifier>
</item>
<item>
<title>GitHub笔记（二）——远程仓库的操作 - 未名w</title>
<link>http://www.cnblogs.com/weimingai/p/10503701.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/weimingai/p/10503701.html</guid>
<description>&lt;p align=&quot;left&quot;&gt;&lt;span&gt;二 远程仓库&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;1 创建联系&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;第1步：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;2 创建远程项目&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;首先，登陆GitHub，然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;在Repository name填入learngit，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;现在，我们根据GitHub的提示，在本地的learngit仓库下运行命令：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;$ git remote add origin git@github.com:Weimingai/learngit.git&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;下一步，就可以把本地库的所有内容推送到远程库上：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;$ git push -u origin master&lt;br/&gt;Counting objects: 20, done.&lt;br/&gt;Delta compression using up to 4 threads.&lt;br/&gt;Compressing objects: 100% (15/15), done.&lt;br/&gt;Writing objects: 100% (20/20), 1.64 KiB | 560.00 KiB/s, done.&lt;br/&gt;Total 20 (delta 5), reused 0 (delta 0)&lt;br/&gt;remote: Resolving deltas: 100% (5/5), done.&lt;br/&gt;To github.com:michaelliao/learngit.git&lt;br/&gt; * [new branch]      master -&amp;gt; master&lt;br/&gt;Branch 'master' &lt;strong&gt;set&lt;/strong&gt; up &lt;strong&gt;to&lt;/strong&gt; track remote branch 'master' &lt;strong&gt;from &lt;/strong&gt;'origin'.&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;从现在起，只要本地作了提交，就可以通过命令：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;$ git push origin master&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;把本地master分支的最新修改推送至GitHub，现在，你就拥有了真正的分布式版本库！&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;SSH警告&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;当你第一次使用Git的clone或者push命令连接GitHub时，会得到一个警告：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;The authenticity of host 'github.com (xx.xx.xx.xx)' can't be established.&lt;br/&gt;RSA key fingerprint is xx.xx.xx.xx.xx.&lt;br/&gt;Are you sure you want to continue connecting (yes/no)?&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;这是因为Git使用SSH连接，而SSH连接在第一次验证GitHub服务器的Key时，需要你确认GitHub的Key的指纹信息是否真的来自GitHub的服务器，输入yes回车即可。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;Git会输出一个警告，告诉你已经把GitHub的Key添加到本机的一个信任列表里了：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;Warning: Permanently added 'github.com' (RSA) to the &lt;strong&gt;list&lt;/strong&gt; of known hosts.&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;这个警告只会出现一次，后面的操作就不会有任何警告了。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;如果你实在担心有人冒充GitHub服务器，输入yes前可以对照&lt;a href=&quot;https://help.github.com/articles/what-are-github-s-ssh-key-fingerprints/&quot;&gt;GitHub的RSA Key的指纹信息&lt;/a&gt;是否与SSH连接给出的一致。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;3 从远程库克隆&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;现在，远程库已经准备好了，下一步是用命令git clone克隆一个本地库：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;$ git clone git@github.com:michaelliao/gitskills.git&lt;br/&gt;Cloning into 'gitskills'...&lt;br/&gt;remote: Counting objects: 3, done.&lt;br/&gt;remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 3&lt;br/&gt;Receiving objects: 100% (3/3), done.&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;注意把Git库的地址换成你自己的，然后进入gitskills目录看看，已经有README.md文件了：&lt;/p&gt;
&lt;p&gt;$ cd gitskills&lt;br/&gt;$ ls&lt;br/&gt;README.md&lt;/p&gt;
</description>
<pubDate>Sat, 09 Mar 2019 15:29:00 +0000</pubDate>
<dc:creator>未名w</dc:creator>
<og:description>基于廖雪峰老师的git笔记摘要</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/weimingai/p/10503701.html</dc:identifier>
</item>
<item>
<title>Java使用递归的方法进行冒泡排序 - 我是白小白</title>
<link>http://www.cnblogs.com/SpaceKiller/p/10503666.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/SpaceKiller/p/10503666.html</guid>
<description>&lt;p&gt;      我一直在园子里没见到过java用递归写冒泡排序的，为啥不给通过？管理员，你给个理由！&lt;/p&gt;
&lt;p&gt;      我是一个小白而已，面试官居然问我，研究过算法吗？用递归写冒泡排序会吗？差点疯掉，说实在的真没怎么用过递归。&lt;/p&gt;
&lt;p&gt;我跟他说，你让我用电脑试试，我肯定能整出来，结果面试官没给机会。特此纪念一下吧！&lt;/p&gt;
&lt;p&gt;      递归是什么？通俗的讲：在方法内部调用自己（相当于现实中的“鬼打墙”，不过我也没遇到过）。&lt;/p&gt;
&lt;p&gt;      写递归方法，一定要记得给自己留门哈，不然就是只进不出了！（就是for循环一定是能出来的才行）  &lt;/p&gt;
&lt;p&gt;     花了几分钟整出来的，递归冒泡排序分享给各位跟我一样的新手们&lt;/p&gt;
&lt;p&gt;   1.冒泡排序(递归)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SortTest {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;      &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;          &lt;span&gt;int&lt;/span&gt;[] arr={12,5,16,3,9,0,158,214,85&lt;span&gt;};
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;         queue(arr);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;         System.out.println(Arrays.toString(arr));
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;｝
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[] queue(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] a) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;           &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=1;i&amp;lt;a.length-1;i++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;               &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; j=a.length-i;j&amp;gt;0;j--&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                   &lt;span&gt;if&lt;/span&gt;(a[j]&amp;lt;a[j-1&lt;span&gt;]){
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                           &lt;span&gt;int&lt;/span&gt; t=&lt;span&gt;a[j];
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                           a[j]=a[j-1&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                           a[j-1]=&lt;span&gt;t;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                   &lt;span&gt;return&lt;/span&gt;&lt;span&gt; queue(a);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;           }     
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; a;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; ｝
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2. 从1乘到n的方法(递归)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SortTest {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;      &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;          &lt;span&gt;long&lt;/span&gt; k=Sort(20&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;         System.out.println(k);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; Sort(&lt;span&gt;long&lt;/span&gt;&lt;span&gt; n){
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;          &lt;span&gt;if&lt;/span&gt;(n==1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;              &lt;span&gt;return&lt;/span&gt; 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;              &lt;span&gt;return&lt;/span&gt; Sort(n-1)*&lt;span&gt;n;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;         }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第二个赠送的,博客太短园子管理员不让发。等我学好了之后，会把递归再好好整理一下的。&lt;/p&gt;
&lt;p&gt;好了,就这样了,看完了之后,面试官如果再问你,研究过算法吗?&lt;/p&gt;
&lt;p&gt;你就可以自豪的回答,我使用递归写过冒泡排序,然后把上面的代码背给面试官就可以了!!&lt;/p&gt;
&lt;p&gt;加油吧,和我一样奋起的菜鸟们,别相信什么困难,java不好学的,我只想告诉你的是,只要你敢想,低下头去学,没有什么是你学不会的。因为你正在走的路，正是别人走出来的。&lt;/p&gt;
&lt;p&gt;人生没有白走的路，每一步都算数！加油！！！&lt;/p&gt;
</description>
<pubDate>Sat, 09 Mar 2019 15:19:00 +0000</pubDate>
<dc:creator>我是白小白</dc:creator>
<og:description>我一直在园子里没见到过java用递归写冒泡排序的，为啥不给通过？管理员，你给个理由！ 我是一个小白而已，面试官居然问我，研究过算法吗？用递归写冒泡排序会吗？差点疯掉，说实在的真没怎么用过递归。 我跟他</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/SpaceKiller/p/10503666.html</dc:identifier>
</item>
<item>
<title>Redhat6.8下安装Oracle11gR2 - 喜欢日向雏田一样的女子啊</title>
<link>http://www.cnblogs.com/lvbinbin2yujie/p/10496837.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lvbinbin2yujie/p/10496837.html</guid>
<description>&lt;p&gt;Step1.配置本地yum源,方便安装依赖包&lt;/p&gt;
&lt;pre class=&quot;brush: bash;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: true;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
df -h
&lt;/pre&gt;
&lt;p&gt;&lt;img title=&quot;1&quot; src=&quot;https://img2018.cnblogs.com/blog/1550387/201903/1550387-20190308165401392-299028312.png&quot; alt=&quot;1&quot; width=&quot;900&quot; height=&quot;153&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;
&lt;p&gt;   补充: df命令查看 linux系统磁盘空间以及使用情况,-h代表方便阅读方式显示  ；/dev/sr0为光驱设备名&lt;/p&gt;
&lt;hr/&gt;&lt;pre class=&quot;brush: bash;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: true;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
mkdir cdrom
mount /dev/sr0 /mnt/cdrom
&lt;/pre&gt;
&lt;p&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/1550387/201903/1550387-20190308165401970-1513334869.png&quot; alt=&quot;image&quot; width=&quot;900&quot; height=&quot;67&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  补充: 将光驱挂在到 /mnt/cdrom下&lt;/p&gt;
&lt;hr/&gt;&lt;pre class=&quot;brush: bash;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: true;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
vim /etc/yum.repos.d/redhat.repo
&lt;/pre&gt;
&lt;p&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/1550387/201903/1550387-20190308165402575-2138709443.png&quot; alt=&quot;image&quot; width=&quot;900&quot; height=&quot;370&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;
&lt;p&gt;补充：本地yum源，enabled为1代表启用&lt;/p&gt;

&lt;p&gt;Redhat修改了redhat.repo之后, 每次yum操作之后redhat.repo改动都没了，只会保留注释行,解决方法重命名自己的repo文件 或者 取消插件自动检查:&lt;/p&gt;
&lt;p&gt;下图为该插件功能，每次都会检测并提示没有注册到Redhat的yum源，&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/1550387/201903/1550387-20190308165403139-1386768983.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/1550387/201903/1550387-20190308165403741-2131069449.png&quot; alt=&quot;image&quot; width=&quot;900&quot; height=&quot;112&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这时候回去看之前改动的redhat.repo文件，改动地方没了已经，取消插件自动检查方法（将enabled由0改为1即可，然后将redhat.repo文件内容重新写一遍  或者一开始就将文件名随便重新取一个）:&lt;/p&gt;
&lt;pre class=&quot;brush: bash;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: true;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
vim /etc/yum/pluginconf.d/subscription-manager.conf
&lt;/pre&gt;
&lt;p&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/1550387/201903/1550387-20190308165404116-1232890007.png&quot; alt=&quot;image&quot; width=&quot;900&quot; height=&quot;86&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;上面准备工作完成就可以准备安装Oracle依赖了, 测试之前安装是否成功可以通过以下简单尝试:&lt;/p&gt;
&lt;p&gt;Root用户下安装lrzsz成功之后，rz可以弹出文件选择框上传文件 ；  或者yum  list 命令弹出一大可安装，每行最后都有 Server的名字，就是我们之前配置的源名字[Server]&lt;/p&gt;
&lt;pre class=&quot;brush: bash;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: true;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
yum install -y lrzsz
&lt;/pre&gt;

&lt;p&gt;Step2.Oracle安装步骤准备&lt;/p&gt;
&lt;p&gt;以下配置需要Root用户执行&lt;/p&gt;
&lt;p&gt;2.1 配置Oracle内核参数信息  补充说明：内核参数设置  &lt;a href=&quot;https://www.cnblogs.com/colben/p/4120439.html&quot; target=&quot;_blank&quot;&gt;Oracle安装内核参数详解&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: bash;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: true;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
vi /etc/sysctl.conf
&lt;/pre&gt;
&lt;p&gt;追加以下内容：&lt;/p&gt;
&lt;pre class=&quot;brush: bash;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: true;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
kernel.shmmax = 68719476736
kernel.shmall = 4294967296
fs.file-max = 6815744
kernel.shmmni = 4096
kernel.sem = 250 32000 100 128
net.ipv4.ip_local_port_range = 9000 65500
net.core.rmem_default = 262144
net.core.rmem_max = 4194304
net.core.wmem_default = 262144
net.core.wmem_max = 1048586
fs.aio-max-nr = 1048576
&lt;/pre&gt;
&lt;p&gt;执行命令使之生效&lt;/p&gt;
&lt;pre class=&quot;brush: bash;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: true;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
sysctl -p
&lt;/pre&gt;
&lt;hr/&gt;
&lt;p&gt;2.2 配置Oracle 资源使用情况 补充说明：资源使用情况解释 &lt;a href=&quot;http://blog.itpub.net/30130773/viewspace-2122120/&quot; target=&quot;_blank&quot;&gt;Oracle资源使用情况详解&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: bash;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: true;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
vi /etc/security/limits.conf
&lt;/pre&gt;
&lt;p&gt;追加以下内容&lt;/p&gt;
&lt;pre class=&quot;brush: bash;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: true;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
oracle soft nproc 2047
oracle hard nproc 16384
oracle soft nofile 1024
oracle hard nofile 65536
oracle hard stack 10240
&lt;/pre&gt;
&lt;hr/&gt;&lt;p&gt;2.3 配置Oracle 登陆设置  补充说明：&lt;a href=&quot;http://www.cnblogs.com/hftian/p/6944133.html&quot; target=&quot;_blank&quot;&gt;Oracle登陆设置解释&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: bash;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: true;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
vi /etc/pam.d/login
&lt;/pre&gt;
&lt;p&gt;追加以下内容 (说明：当前机器为64位 所以是lib64目录下, 32位的机器目录下 lib下 ，查看机器目录方式有 getconf LONG_BIT)&lt;/p&gt;
&lt;pre class=&quot;brush: bash;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: true;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
session required /lib64/security/pam_limits.so
session required pam_limits.so
&lt;/pre&gt;
&lt;p&gt;&lt;br/&gt;注意上面的目录写错了会导致linux系统登陆出现问题，虽然没遇到这样的问题，但是贴上解决的博客，万一遇到：&lt;a href=&quot;https://www.cnblogs.com/qtong1992/p/5920177.html&quot; target=&quot;_blank&quot;&gt;解决Oracle安装后linux登陆出现问题&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;2.4 同样Root用户下修改/etc/profile&lt;/p&gt;
&lt;pre class=&quot;brush: bash;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: true;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
vi /etc/profile
&lt;/pre&gt;
&lt;p&gt;添加以下内容：&lt;/p&gt;
&lt;pre class=&quot;brush: bash;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: true;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
if [ $USER = &quot;oracle&quot; ]; then
 if [ $SHELL = &quot;/bin/ksh&quot; ]; then
  ulimit -p 16384
  ulimit -n 65536
 else
  ulimit -u 16384 -n 65536
 fi
fi
&lt;/pre&gt;
&lt;hr/&gt;&lt;p&gt;2.5 添加用户 (补充说明:为什么linux下安装oracle需要创建用户，以及用户组呢？个人见解，先说创建Oracle用户，不可能每次操作数据库都用root用户来登陆服务器，所以肯定要有这样一个用户来管理数据库，处于系统安全、数据完整考虑；第二点，用户组个人认为两个组才可以，OINSTALL以及DBA组，OINSTALL软件安装组，Oracle软件的所有者，而DBA组安全性来说就比较重要了，DBA组用户可以 conn / as sysdba方式通过操作系统认证进而登陆任意数据库实例，后面会补充介绍；以上都是这四天从零完成测试环境Oracle安装的发现，有不对之处欢迎讨论)&lt;/p&gt;
&lt;pre class=&quot;brush: bash;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: true;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
groupadd  oinstall
groupadd  dba
useradd  -g  oinstall  -G  dba  oracle
passwd  oracle
&lt;/pre&gt;
&lt;p&gt;之后输入两次密码即可完成给oracle用户设置密码；  补充说明：useradd 的 –g代表 指定用户所属群组，-G 指定用户所属附加群组， 也就是说 -g是覆盖式的 -G是增量式的 ；&lt;/p&gt;
&lt;p&gt;比如useradd  -g  oinstall –g dba XXX  这样XXX只属于oinstall组&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;2.6 配置环境变量以及 设定好安装目录&lt;/p&gt;
&lt;p&gt;  先规划好打算安装oracle的路径，我将oracle安装到 /data/app/oracle目录，安装时候记得查看 磁盘空间大小，不要安装到一半没有空间了；&lt;/p&gt;
&lt;pre class=&quot;brush: bash;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: true;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
mkdir  -p  /data/app/oracle
chown  -R   oracle:oinstall  /data/app/
&lt;/pre&gt;
&lt;p&gt;补充说明：mkdir  -p 需要时创建上级目录，  chown –R  递归将目录拥有者给oinstall组的oracle用户&lt;/p&gt;

&lt;p&gt;设定ORACLE用户环境变量，当然要切换用户到ORACLE ，.bash_profile在ORACLE的家目录下， ls –al可以查看到该文件&lt;/p&gt;
&lt;pre class=&quot;brush: bash;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: true;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
su  -  oracle
vi   .bash_profile

&lt;/pre&gt;
&lt;p&gt;这里可以提前设置环境变量：解释下，ORACLE_SID代表你后面想要创建的数据库实例名，这里可以先写上，文章后面会说有什么用处； ORACLE_HOME代表你打算安装ORACLE产品的目录，这里写了后面就要按照这个来，可以先把目录手动创建起来&lt;/p&gt;
&lt;pre class=&quot;brush: bash;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: true;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
export ORACLE_BASE=/data/app/oracle
export ORACLE_HOME=$ORACLE_BASE/product/dbhome_1
export ORACLE_SID=olcom114DB
export PATH=$PATH:$HOME/bin:$ORACLE_HOME/bin
export LD_LIBRARY_PATH=$ORACLE_HOME/lib:/usr/lib

&lt;/pre&gt;
&lt;p&gt;修改完成.bash_profile文件，立即生效命令 ; 可以通过 echo  $环境变量名字 查看是否起作用了&lt;/p&gt;
&lt;pre class=&quot;brush: bash;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: true;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
 source   .bash_profile
&lt;/pre&gt;
&lt;hr/&gt;&lt;p&gt;2.7 上传好Oracle安装包并完成解压&lt;/p&gt;
&lt;p&gt;Oracle11gR2安装包Oracle官网就需要登录才能下载，因为公司内网不知道啥情况，点击下载连接死活下不了，就去用积分下载，这里吐槽下某些链接，写的64位，装到一半报错什么libxxso的，才发现是32位的压缩包；&lt;/p&gt;
&lt;p&gt;这里Oracle64位的安装包是linux.x64……..这样的，而linux_11gR2这种是32位的，直接通过fxp工具上传到服务器某个目录下，注意磁盘空间大小，2个文件加起来2G多；&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/1550387/201903/1550387-20190308165404575-1336548044.png&quot; alt=&quot;image&quot; width=&quot;900&quot; height=&quot;116&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;
&lt;p&gt;解压命令： unzip解压就会解压到database目录下&lt;/p&gt;
&lt;pre class=&quot;brush: bash;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: true;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
unzip linux.x64_11gR2_database_1of2.zip
unzip linux.x64_11gR2_database_2of2.zip
&lt;/pre&gt;

&lt;hr/&gt;&lt;p&gt;2.8 依赖包的安装&lt;/p&gt;
&lt;p&gt;前面Step1配置过了本地yum源之后，现在安装这些依赖包应该不存在问题，第一天安装的时候完全不知道什么命令查看哪些依赖，厚脸皮去请教一位数据库工程师，前辈发来一段命令&lt;/p&gt;
&lt;pre class=&quot;brush: bash;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: true;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
 rpm -q --queryformat &quot;%{NAME}-%{VERSION}-%{RELEASE} (%{ARCH})\n&quot; \
binutils.x86_64 \
compat-libcap1.x86_64 \
compat-libstdc++-33.i686 \
compat-libstdc++-33.x86_64 \
gcc-c++.x86_64 \
glibc.i686 \
glibc.x86_64 \
glibc-devel.i686 \
glibc-devel.x86_64 \
ksh-*.x86_64 \
libaio.i686 \
libaio.x86_64 \
libaio-devel.i686 \
libaio-devel.x86_64 \
libX11.i686 \
libX11.x86_64 \
libXau.i686 \
libXau.x86_64 \
libXi.i686 \
libXi.x86_64 \
libXtst.i686 \
libXtst.x86_64 \
libgcc.i686 \
libgcc.x86_64 \
libstdc++.i686 \
libstdc++.x86_64 \
libstdc++-devel.i686 \
libstdc++-devel.x86_64 \
libxcb.i686 \
libxcb.x86_64 \
make.x86_64 \
net-tools.x86_64 \
smartmontools.x86_64 \
sysstat.x86_64 | grep &quot;not installed\|未安装&quot;
&lt;/pre&gt;
&lt;p&gt;查看下当前依赖： （补充下，有些依赖通过后面安装，没发现需要这样依赖）&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/1550387/201903/1550387-20190309225530433-1916810975.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/1550387/201903/1550387-20190309225530870-1837140670.png&quot; alt=&quot;image&quot; width=&quot;587&quot; height=&quot;371&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Root用户下执行下面的安装命令:&lt;/p&gt;
&lt;pre class=&quot;brush: bash;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: true;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
yum install compat-libcap1

yum install compat-libstdc++-33*

yum install compat-libstdc++-33*.i686

yum install gcc*

yum install glibc-devel-*.i686

yum install libstdc++-devel*.i686

yum install libaio*.i686

yum install libaio-devel*

yum install unixODBC*

yum install unixODBC*.i686

yum install ksh
&lt;/pre&gt;

&lt;p&gt;执行完之后，查看还有哪些依赖没有安装(这些依赖后面安装 check dependencies时候没发现需要，也就没有继续安装)&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/1550387/201903/1550387-20190308165405566-2018856007.png&quot; alt=&quot;image&quot; width=&quot;900&quot; height=&quot;165&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;Step3.图形化界面安装Oracle,因为习惯图形化安装，下面的只介绍图形化安装，我是先安装数据库软件 (因为服务器需要VPN连接，VPN经常断，没办法坚持到安装数据库软件建库一起完成)，然后dbca建库，netca建立监听,dbca\netca图形以及静默安装方式都有；&lt;/p&gt;
&lt;p&gt;3.1 安装数据库软件(图形化界面)&lt;/p&gt;
&lt;p&gt;   图形化安装工具使用的是Xshell，以Oracle用户登陆XShell工具，进入到上面2.7的解压目录database&lt;/p&gt;
&lt;pre class=&quot;brush: bash;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: true;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
 ./runInstaller
&lt;/pre&gt;
&lt;p&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/1550387/201903/1550387-20190308165406264-1377897825.png&quot; alt=&quot;image&quot; width=&quot;900&quot; height=&quot;295&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一切正常的话就会弹出来Oracle安装界面，也会出现检查不通过，临时空间、交换空间不足，这两个我没有遇到就自行解决啦；&lt;/p&gt;
&lt;p&gt;安装过程第一个问题就出现了：&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/1550387/201903/1550387-20190308165406907-1693822008.png&quot; alt=&quot;image&quot; width=&quot;631&quot; height=&quot;349&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;
&lt;p&gt;解决方案: &lt;/p&gt;
&lt;pre class=&quot;brush: bash;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: true;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
vi /etc/hosts
&lt;/pre&gt;
&lt;p&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/1550387/201903/1550387-20190308165407439-1504754352.png&quot; alt=&quot;image&quot; width=&quot;900&quot; height=&quot;75&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;
&lt;p&gt;修改添加当前主机名，主机名通过  hostname 命令查看，由于localhost.localdomain我觉得没啥用途，就全删掉改成主机名了&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/1550387/201903/1550387-20190308165407843-1054680142.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/1550387/201903/1550387-20190308165408078-1275141219.png&quot; alt=&quot;image&quot; width=&quot;900&quot; height=&quot;75&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;再次启动安装命令 ./runInstaller 不警告，通过；&lt;/p&gt;
&lt;p&gt;简单通过 LICECap 将之前安装过程中图片做成动画形式，简单记录下安装说明：&lt;/p&gt;
&lt;p&gt;1. 将安全更新的√取消 ；&lt;/p&gt;
&lt;p&gt;2. 这里暂时只安装数据库软件，不创建实例(服务器VPN不稳定，数据库实例创建时间稍长，所以只安装数据库软件)；&lt;/p&gt;
&lt;p&gt;3.选择单实例数据库；&lt;/p&gt;
&lt;p&gt;4. 语言只选择了英语；&lt;/p&gt;
&lt;p&gt;5. 这里安装的是企业版 ；&lt;/p&gt;
&lt;p&gt;6. ORACLE_BASE、ORACLE_HOME 在前面2.6环境变量写好了，这里指定ORACLE_BASE为 /data/app/oracle 以及 ORACLE_HOME为/data/app/oracle/product/dbhome_1 ;&lt;/p&gt;
&lt;p&gt;7. Inventory目录为清单目录，这最好不要在ORACLE_BASE目录下，安装过程中的日志都在清单目录里面，下面还指定了ORACLE清单组，oinstall就可以了； &lt;/p&gt;
&lt;p&gt;8. 指定DBA组为之前添加的dba组，OSOPER组为之前的oinstall组就可以；&lt;/p&gt;
&lt;p&gt;9.依赖检查，这里如果按照之前yum全部安装了，仍然会包缺少依赖，咨询过相关DBA说最好依赖版本相同，但是安装时候gcc版本安装时候 gcc如果不小心安装就会导致系统宕机、崩溃等各种问题；&lt;/p&gt;
&lt;p&gt;如果确认之前2.8步骤的yum  install都执行成功，那点击右上角的Ignore All再点击下一步；（没执行2.9的yum install可能会出现一种情况，生成的bin目录里面lsnrctl可能为空，我第一次安装就有这样的问题）&lt;/p&gt;
&lt;p&gt;10.安装产品步骤时，快完成时候会跳出来提示框，Root用户下执行两个脚本即可，截图也在下面有；&lt;/p&gt;
&lt;p&gt;11.回到安装界面，点击OK，至此Oracle软件安装完成。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;1&quot; src=&quot;https://img2018.cnblogs.com/blog/1550387/201903/1550387-20190309224832161-2057925819.gif&quot; alt=&quot;1&quot; width=&quot;635&quot; height=&quot;484&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span id=&quot;MyQuest&quot;/&gt;Step4.Oracle用户  图形化 dbca建库、netca建立监听&lt;/p&gt;
&lt;p&gt;环境变量如果之前设置正确，xshell工具 Oracle用户登录后 输入  dbca ，会弹出如下界面进行建库操作：&lt;/p&gt;
&lt;p&gt;Create a database  创建数据库 ； 数据库实例名SID 设置，和前面环境变量里的ORACLE_SID一致 (这里有篇文章介绍 环境变量ORACLE_SID的作用 &lt;a href=&quot;https://www.2cto.com/database/201411/355622.html&quot; target=&quot;_blank&quot;&gt;关于环境变量ORACLE_SID简单谈下&lt;/a&gt;)； 后面有很多具体配置，&lt;/p&gt;
&lt;p&gt;Enterprise Manger (企业管理，就会有个类似控制台的东西),SGA、PGA等等，具体自行百度设置；  这里有个不太明白的地方： 前面会先设置一遍 All account的密码，后面建库完毕弹出来的Password Management打开发现密码都是空的， 这里重新设置一遍Sys用户和Sysadmin等用户，点击OK，这样就建库完毕 ( &lt;span&gt;点击OK之前再开打密码管理器，发现还是空白, 但是后面登陆时候密码确实是设置上的，这块希望有人知道能评论告诉我&lt;/span&gt;,)&lt;/p&gt;
&lt;p&gt; &lt;img title=&quot;4&quot; src=&quot;https://img2018.cnblogs.com/blog/1550387/201903/1550387-20190309225041996-733369441.gif&quot; alt=&quot;4&quot; width=&quot;716&quot; height=&quot;516&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;环境变量设置正确的话，xshell工具 Oracle用户登录后 输入  netcat ，会弹出如下界面进行建库操作：&lt;/p&gt;
&lt;p&gt;建立监听的目的是让其他机器可通过PLSQL等工具连接上本机的数据库实例， 具体监听这里有篇资料mark &lt;a href=&quot;http://www.360doc.com/content/11/0412/10/6670178_109025796.shtml&quot; target=&quot;_blank&quot;&gt;Oracle 监听器 Listener&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;5&quot; src=&quot;https://img2018.cnblogs.com/blog/1550387/201903/1550387-20190309225043460-1127126095.gif&quot; alt=&quot;5&quot; width=&quot;691&quot; height=&quot;476&quot;/&gt;&lt;/p&gt;
&lt;p&gt;查看监听器是否启动可以通过如下两种方式：&lt;/p&gt;
&lt;pre class=&quot;brush: bash;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: true;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
netstat -tnlp |grep 1521
&lt;/pre&gt;
&lt;p&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/1550387/201903/1550387-20190309224313048-1849307733.png&quot; alt=&quot;image&quot; width=&quot;900&quot; height=&quot;41&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;
&lt;p&gt;或者&lt;/p&gt;
&lt;pre class=&quot;brush: bash;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: true;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
lsnrctl status
&lt;/pre&gt;
&lt;p&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/1550387/201903/1550387-20190309225044851-331043436.png&quot; alt=&quot;image&quot; width=&quot;737&quot; height=&quot;422&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;Step5.到这里建库，监听建立都完毕可以测试下，按照以上安装步骤都是没有问题的，本机安装了两次，服务器也装了一次，有什么问题后续会补充；&lt;/p&gt;
&lt;p&gt;本机测试连接(后面会有介绍 本机Oracle用户登录SYS用户哪怕不要密码 密码错误都可以登陆)：&lt;/p&gt;
&lt;pre class=&quot;brush: bash;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: true;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
sqlplus  /nolog
conn / as sysdba
select * from v$instance;
&lt;/pre&gt;
&lt;p&gt; &lt;a href=&quot;https://img2018.cnblogs.com/blog/1550387/201903/1550387-20190309225433076-1146672632.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/1550387/201903/1550387-20190309225433852-1460286850.png&quot; alt=&quot;image&quot; width=&quot;667&quot; height=&quot;366&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可能登陆会有 connected to an idle instance ,启动下数据库实例 startup 即可&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/1550387/201903/1550387-20190309225046164-727081716.png&quot; alt=&quot;image&quot; width=&quot;689&quot; height=&quot;367&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;
&lt;p&gt;外部机器测试连接(通过PLSQL测试连接)  数据库访问这么写：192.168.88.114:1521/olcom114DB ， 记得Oracle所在机器开放监听端口；&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/1550387/201903/1550387-20190309224314906-393164598.png&quot; alt=&quot;image&quot; width=&quot;402&quot; height=&quot;229&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/1550387/201903/1550387-20190309224315320-1620861252.png&quot; alt=&quot;image&quot; width=&quot;900&quot; height=&quot;168&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;Step6. 图形化安装过程中遇到的几个错误 以及解决方案&lt;/p&gt;
&lt;p&gt;问题一. 安装Oracle软件过程指定清单目录时候，报错 Unable to create a new central  Inventory at the specified location.&lt;/p&gt;
&lt;p&gt;   问题说明：安装的时候没注意到清单所在目录/data/oracle/oraInventory下面有其他文件，解决方案把该文件夹下面文件清掉或者换个文件夹； &lt;/p&gt;
&lt;p&gt;另外，该目录最好不要在ORACLE_BASE目录下&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/1550387/201903/1550387-20190309225531372-2142396616.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/1550387/201903/1550387-20190309225531767-1312141059.png&quot; alt=&quot;image&quot; width=&quot;681&quot; height=&quot;523&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;hr/&gt;&lt;p&gt;问题二. 安装Oracle软件检查依赖时候，交换空间不足&lt;/p&gt;

&lt;pre class=&quot;brush: bash;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: true;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
/root目录下(目录随意)
dd if=/dev/zero of=swapfree  bs=32k  count=65515
mkswap  swapfree
swapon  swapfree
free  
/etc/fstab编辑开启自启动交换分区
/root/swapfree  swap  swap  defaults 0 0
&lt;/pre&gt;
&lt;p&gt;之后Check Again就可以通过了&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/1550387/201903/1550387-20190309225532463-80455664.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/1550387/201903/1550387-20190309225533234-1317281733.png&quot; alt=&quot;image&quot; width=&quot;685&quot; height=&quot;523&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;问题三.Oracle dbca建库过程中 Tns could not resolve the connect identifier specified&lt;/p&gt;
&lt;p&gt;说明DBCA建库为啥会报这种错，一般我以为只有PLSQL连接时候才报错， 这种错误我这里出现情况是设置数据库用户密码中包含了@ 符号，把密码稍微改动下 去掉 @ 试试&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/1550387/201903/1550387-20190309225533600-670328838.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/1550387/201903/1550387-20190309225533932-1979157045.png&quot; alt=&quot;image&quot; width=&quot;632&quot; height=&quot;452&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;Step7.静默方式dbca  netca建库&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;至于为什么采用dbca 静默方式建库呢？ 因为服务器需要用VPN连接不太稳定， 好几次建库等进度条的时候VPN断了，尝试了多次VPN死心时候，采用静默dbca建库；&lt;/p&gt;
&lt;p&gt;dbca命令在安装完Oracle软件之后就可以使用，配置文件 dbca.rsp到 database/responseFile/dbca.rsp复制过来就可以&lt;/p&gt;
&lt;pre class=&quot;brush: bash;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: true;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
[GENERAL]
RESPONSEFILE_VERSION = &quot;11.2.0&quot;

OPERATION_TYPE = &quot;createDatabase&quot;

[CREATEDATABASE]
GDBNAME = &quot;olcom114DB&quot;

SID = &quot;olcom114DB&quot;

TEMPLATENAME = &quot;General_Purpose.dbc&quot;

SYSPASSWORD = &quot;你的SYS用户密码&quot;

SYSTEMPASSWORD = &quot;你的SYSTEM用户密码&quot;

DATAFILEDESTINATION = /data/app/oracle/oradata/

CHARACTERSET = &quot;ZHS16GBK&quot;

NATIONALCHARACTERSET= &quot;UTF8&quot;

TOTALMEMORY = &quot;2048&quot;
&lt;/pre&gt;
&lt;p&gt;这是最基础的配置，全局数据库名、实例名、字符集、数据文件存储位置等&lt;/p&gt;

&lt;p&gt;Oracle用户下执行命令,执行成功就可以在服务器上使用SQLPLUS连接Oracle&lt;/p&gt;
&lt;pre class=&quot;brush: bash;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: true;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
dbca  -silent  -responseFile  /data/oracle/dbca.rsp
&lt;/pre&gt;
&lt;p&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/1550387/201903/1550387-20190309224318966-1002802726.png&quot; alt=&quot;image&quot; width=&quot;803&quot; height=&quot;340&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;netca建立监听才可以通过其他机器的PLSQL连接本机的ORACLE数据库&lt;/p&gt;
&lt;pre class=&quot;brush: bash;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: true;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
netca  /silent  /responseFile    /data/database/responseFile/netca.rsp
&lt;/pre&gt;
&lt;p&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/1550387/201903/1550387-20190309224319324-2129161178.png&quot; alt=&quot;image&quot; width=&quot;811&quot; height=&quot;249&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;Step8.好了 文章感觉第一次写这么长的，谢谢你这么好看，还看完这篇，希望能帮到你们，也希望懂的大兄弟告诉下我，之前那块密码安装时候没显示的问题。&lt;a href=&quot;http://www.cnblogs.com/lvbinbin2yujie/p/10496837.html#MyQuest&quot;&gt;点我回到问题的地方&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/lvbinbin2yujie/p/10496837.html#MyQuest&quot;&gt; &lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 09 Mar 2019 15:09:00 +0000</pubDate>
<dc:creator>喜欢日向雏田一样的女子啊</dc:creator>
<og:description>Step1.配置本地yum源,方便安装依赖包 补充: df命令查看 linux系统磁盘空间以及使用情况,-h代表方便阅读方式显示 ；/dev/sr0为光驱设备名 补充: 将光驱挂在到 /mnt/cdr</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lvbinbin2yujie/p/10496837.html</dc:identifier>
</item>
<item>
<title>==运算符和equals()方法的区别 - 冰湖一角</title>
<link>http://www.cnblogs.com/bingyimeiling/p/10503054.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bingyimeiling/p/10503054.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;Java语言程序中判断两个变量是否相等有两种方式：一是运用==运算符，二是运用equals方法。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1. ==运算符&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;对于==运算符来说，如果两个变量是基本类型的，并且是数值类型，则只要它们的值相等，就会返回true；然而如果是两个引用类型的变量，则分为两种情况：1）它们指向同一个对象，结果返回true；2）它们指向不同的对象，即使对象内容相同，结果还是返回false；下面程序示范了使用==运算符比较两个变量是否相等的结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; a = 5&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; b = 5&lt;span&gt;;
        String s1 &lt;/span&gt;= &quot;helloJava&quot;&lt;span&gt;;
        String s2 &lt;/span&gt;= &quot;helloJava&quot;&lt;span&gt;;
        String s3 &lt;/span&gt;= &quot;hello&quot;+&quot;Java&quot;&lt;span&gt;;
        String s4 &lt;/span&gt;= &quot;hello&quot;&lt;span&gt;;
        String s5 &lt;/span&gt;= &quot;Java&quot;&lt;span&gt;;
        String s6 &lt;/span&gt;= s4 +&lt;span&gt; s5;
        String s7 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; String(&quot;helloJava&quot;&lt;span&gt;);
        System.out.println(&lt;/span&gt;&quot;a==b?:  &quot;+(a==&lt;span&gt;b));
        System.out.println(&lt;/span&gt;&quot;s1==s2?:  &quot;+(s1==&lt;span&gt;s2));
        System.out.println(&lt;/span&gt;&quot;s1==s3?:  &quot;+(s1==&lt;span&gt;s3));
        System.out.println(&lt;/span&gt;&quot;s1==s6?:  &quot;+(s1==&lt;span&gt;s6));
        System.out.println(&lt;/span&gt;&quot;s1==s7?:  &quot;+(s1==&lt;span&gt;s7));
        System.out.println(&lt;/span&gt;&quot;s1.equals(s6)?:  &quot;+&lt;span&gt;(s1.equals(s6)));
        System.out.println(&lt;/span&gt;&quot;s1.equals(s7)?:  &quot;+&lt;span&gt;(s1.equals(s7)));
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果为：&lt;/p&gt;
&lt;p&gt;a==b?: true&lt;br/&gt;s1==s2?: true&lt;br/&gt;s1==s3?: true&lt;br/&gt;s1==s6?: false&lt;br/&gt;s1==s7?: false&lt;br/&gt;s1.equals(s6)?: true&lt;br/&gt;s1.equals(s7)?: true&lt;/p&gt;
&lt;p&gt;结果分析：两个int类型的a和b相等，不需要多解释；s1、s2和s3所引用的字符串在编译期间就已经确定下来，因此它们都将引用常量池中的同一个字符串对象；s6对应的字符串值不能在编译期间确定下来；s7使用new构造器将会创建一个新的String对象，s7引用堆内存中创建的String对象，不在常量池中。（关于String字符串的创建和存储机制将在下篇介绍，望大家置顶公众号，第一时间收看）。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2. equals()方法&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;equals()方法是Object类提供的一个方法，直接使用这个方法判断两个对象相等的标准与使用==运算符没有区别，但是怎么样实现类似于“值相等”的判断规则呢？答案是重写equals方法。&lt;/p&gt;
&lt;p&gt;String已经重写了Object的equals()方法，String的equals()方法判断两个字符串相等的标准是：如果两个字符串所包含的字符序列相等，通过equals()方法比较将返回true，否则返回false。&lt;/p&gt;
&lt;p&gt;一般而言，重写equals()方法应该满足下列条件：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1）自反性：&lt;/span&gt;对任意x，x.equals(x)一定返回true。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2）对称性：&lt;/span&gt;对任意x，y，如果x.equals(y)返回true，则y.equals(x)也一定返回true。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3）传递性：&lt;/span&gt;对任意x，y，z，如果x.equals(y)返回true，y.equals(z)也返回true，则x.equals(z)也一定返回true。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4）一致性：&lt;/span&gt;对任意x，y，如果对象中用于比较的信息没有改变，那么无论调用多少次x.equals(y)，返回的结果应该保持一致，要么一直返回true，要么一直返回false。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5）对任意不是null的x，x.equals(null)一定返回false。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;实际应用中常常需要根据业务本身重写equals()方法，equals()方法的实现也是由业务决定的，下面示范了一种符合实际情况的重写equals()方法的示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; String name;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;姓名&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; age;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;年龄&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; String idNum;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;身份证号&lt;/span&gt;
    
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Person() {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;();
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Person(String name, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; age, String idNum) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.idNum =&lt;span&gt; idNum;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;重写equals方法&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; equals(Object obj){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果两个对象是同一个对象，返回true&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt; ==&lt;span&gt; obj){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;obj是Person对象&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(obj!=&lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; obj.getClass()==Person.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;){
            Person p &lt;/span&gt;=&lt;span&gt; (Person)obj;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;并且身份证号相同才判断两个对象相等&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.idNum.equals(p.getIdNum())){
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getName() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; name;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setName(String name) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getAge() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; age;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setAge(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; age) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getIdNum() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; idNum;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setIdNum(String idNum) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.idNum =&lt;span&gt; idNum;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        Person p1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Person(&quot;张三&quot;, 14, &quot;zs14abc&quot;&lt;span&gt;);
        Person p2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Person(&quot;张三2&quot;, 15, &quot;zs14abc&quot;&lt;span&gt;);
        Person p3 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Person(&quot;张三&quot;, 14, &quot;zs14abc2&quot;&lt;span&gt;);
        System.out.println(&lt;/span&gt;&quot;p1.equals(p2)?:  &quot;+&lt;span&gt;(p1.equals(p2)));
        System.out.println(&lt;/span&gt;&quot;p1.equals(p3)?:  &quot;+&lt;span&gt;(p1.equals(p3)));
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;p1.equals(p2)?: true&lt;br/&gt;p1.equals(p3)?: false&lt;/p&gt;
&lt;p&gt;大家都明白了==和equals的区别和用法了吗？网上很多说equals()方法是判断两个对象的值相等，这个说法并不太准确，因为你可以重写equals()方法，你想让它们怎么相等就怎么相等，在极端情况下你可以让Person对象个Pig对象相等。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以为了便于初学者记忆，可以说==运算符用来比较两个变量的值是否相等；equals()方法用于比较两个对象的内容是否相同。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;欢迎关注微信公众号【Java典籍】，收看更多Java技术干货！&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;　 &lt;/strong&gt;▼微信扫一扫下图↓↓↓二维码关注&lt;/p&gt;

&lt;p&gt;　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1362965/201901/1362965-20190109201610986-215386546.jpg&quot; alt=&quot;&quot; width=&quot;211&quot; height=&quot;211&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 09 Mar 2019 14:31:00 +0000</pubDate>
<dc:creator>冰湖一角</dc:creator>
<og:description>Java语言程序中判断两个变量是否相等有两种方式：一是运用==运算符，二是运用equals方法。 1. ==运算符 对于==运算符来说，如果两个变量是基本类型的，并且是数值类型，则只要它们的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bingyimeiling/p/10503054.html</dc:identifier>
</item>
<item>
<title>Java中递归和循环的优劣 - 吴永吉</title>
<link>http://www.cnblogs.com/wuyongji/p/10503391.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wuyongji/p/10503391.html</guid>
<description>&lt;p&gt;介绍：&lt;br/&gt;　　你用你手中的钥匙打开一扇门，结果去发现前方还有一扇门，紧接着你又用钥匙打开了这扇门，然后你又看到一扇门......但是当你开到一扇门时，发现前方是一堵墙无路可走了，你选择原路返回--这就是递归。&lt;br/&gt;　　但是如果你打开一扇门后，同样发现前方也有一扇门，紧接着你又打开下一扇门.....但是却一直没有碰到尽头--这就是循环。&lt;br/&gt;　　简单来说：循环是有去无回，而递归是有去有回（因为存在终止条件）。&lt;br/&gt;　　循环：当满足某一条件时反复执行某一操作（循环体）。&lt;br/&gt;　　递归：在一个方法内部对自身进行调用的方法。&lt;br/&gt;递归结构包括两个部分：&lt;br/&gt;　　1、递归头：即什么时候不调用自身方法，也就是递归的结束条件。如果没有递归头，程序将陷入死循环。&lt;br/&gt;　　2、递归体：即什么时候需要调用自身方法。&lt;br/&gt;好了，废话不多说，直接来撸代码（计算阶乘的方法）。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
package com.bjwyj.method;
/**
 * 递归和循环的比较
 * @author 吴永吉
 *
 */
public class TestRecursion {
        public static void main(String[] args) {
                //以下调用System下的currentTimeMillis()方法只是为了说明递归调用比循环调用更耗时
                long l1 = System.currentTimeMillis();   
                System.out.println(factorial(5));
                long l2 = System.currentTimeMillis();
                System.out.println(&quot;递归计算阶乘耗时：&quot;+(l2-l1));
                
                System.out.println(&quot;$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$&quot;);
                long time1 = System.currentTimeMillis();
                System.out.println(factorialLoop(5));
                long time2 = System.currentTimeMillis();
                System.out.println(&quot;循环计算阶乘耗时：&quot;+(time2-time1));
        }
        
        //使用递归定义计算阶乘的方法
        public static long factorial(int num) {
                if(num==1) {    //递归头
                        return 1;
                }else {
                        return num*factorial(num-1);    //递归体
                }
        }
        
        //使用循环定义计算阶乘的方法
        public static long factorialLoop(int n) {
                int result = 1; //接收计算结果
                while(n&amp;gt;1) {
                        result *= n*(n-1);      //实现计算结果的累乘操作
                        n -= 2; //每次减去2，实现数字的迭代操作
                }
                return result;
        }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　执行结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
120
递归计算阶乘耗时：1
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
120
循环计算阶乘耗时：0
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　由结果可以看出，使用递归算法比使用循环算法更耗时。&lt;br/&gt;　　为了更好地比较递归算法的优劣，上述采用while循环与递归算法进行对比。&lt;br/&gt;　　先来分析上述递归方法的执行过程，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1533339/201903/1533339-20190309220940299-942700918.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　循环方法的执行过程，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1533339/201903/1533339-20190309221000549-380467648.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这里为了看起来清晰，只是简单地画出了栈内存中的执行过程（这样画更便于理解）。&lt;/p&gt;
&lt;p&gt;总结：&lt;br/&gt;　　栈，主要是用来存放栈帧的，每执行一个方法就会出现压栈操作，所以采用递归的时候产生的栈帧比较多，递归就会影响到内存，非常消耗内存。而使用循环就执行了一个方法，压入栈帧一次，只存在一个栈帧，所以比较节省内存。&lt;/p&gt;
</description>
<pubDate>Sat, 09 Mar 2019 14:14:00 +0000</pubDate>
<dc:creator>吴永吉</dc:creator>
<og:description>递归和循环的比较</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wuyongji/p/10503391.html</dc:identifier>
</item>
<item>
<title>【机器学习】多项式回归原理介绍 - AI_developer</title>
<link>http://www.cnblogs.com/ai-developer/p/10503364.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ai-developer/p/10503364.html</guid>
<description>&lt;p&gt;在上一节中我们介绍了线性回归的原理，然后分别用python和sklearn实现了不同变量个数的线性回归的几个例子。线性回归模型形式简单，有很好的可解释性，但是它只适用于X和y之间存在线性关系的数据集。对于非线性关系的数据集，线性回归不能很好的工作。因此本文介绍线性回归模型的扩展——「多项式回归」，我们可以用它来拟合非线性关系的数据集。&lt;/p&gt;
&lt;p&gt;假设我们有一个单变量数据集，如下图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190309213805237.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为了观察它们之间的关系，我们用 matplotlib 画出散点图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190309213825938.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI0NjcxOTQx,size_16,color_FFFFFF,t_70&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从图中看，它们有点像在一条直线上，但仔细看更像是在一个抛物线上。&lt;/p&gt;
&lt;p&gt;首先我们假设它们满足线性关系，使用线性回归模型得到的结果如下图中黄线所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2019030921385855.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI0NjcxOTQx,size_16,color_FFFFFF,t_70&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看起来似乎还可以，但是来看看误差，太大了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190309213908107.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面我们试试用抛物线拟合它们。&lt;/p&gt;
&lt;p&gt;线性回归可以通过从系数构造多项式的特征来扩展。为了使推导过程更具有代表性，我们先以一个双变量的为例，然后再看我们上面的单变量的例子。&lt;/p&gt;
&lt;p&gt;双变量线性回归模型形如下面式子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190309213918767.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过结合二阶多项式的特征，添加二次方项，将它从平面转换为抛物面：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190309213937320.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;用z替换x：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190309213946476.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以，我们的式子可以写成：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2019030921395666.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样就变为线性回归模型。&lt;/p&gt;
&lt;p&gt;同理，我们的数据集是单变量的，转换后的式子为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190309214016515.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;计算结果如图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190309214029738.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI0NjcxOTQx,size_16,color_FFFFFF,t_70&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;线性回归得到的模型为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190309214041775.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;多项式回归得到的模型为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190309214050906.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;两个模型如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190309214059420.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI0NjcxOTQx,size_16,color_FFFFFF,t_70&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看出多项式回归模型的效果（绿线）要明显好于线性回归模型（黄线）。&lt;/p&gt;
&lt;p&gt;更高阶的同理。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;

&lt;div&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190309214142193.png&quot; alt=&quot;&quot; width=&quot;500&quot; height=&quot;400&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Sat, 09 Mar 2019 14:08:00 +0000</pubDate>
<dc:creator>AI_developer</dc:creator>
<og:description>【机器学习】多项式回归原理介绍 【机器学习】多项式回归python实现 【机器学习】多项式回归sklearn实现 在上一节中我们介绍了线性回归的原理，然后分别用python和sklearn实现了不同变</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ai-developer/p/10503364.html</dc:identifier>
</item>
<item>
<title>那些年我们爬过的山 - mybatis批量导入 - 五色花的</title>
<link>http://www.cnblogs.com/luao/p/10503345.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/luao/p/10503345.html</guid>
<description>&lt;p&gt;写这篇文章之前想着给这篇博客起一个文艺一点的标题，思来想去，想到了那些年我们爬过的山，或者我们一起趟过的河？代码不规范，同事两行泪，这是多么痛的领悟啊！&lt;/p&gt;

&lt;p&gt;本组一名实习生，由于学校有事情需要回去处理，我便将他的代码接管过来，正好赶上本次迭代上线，需要将同事的代码提交测试，如果被测试出来有bug，我就来负责bug修复，代码优化等。由于不同的开发人员都有自己的编程习惯，所以不同人员所写的代码多少都会有些差异，比如：变量的命名、代码的格式等，即使组内有一套开发规范也还是会出现一些差异，这就是所谓的个性？特点？ 当然 特点只是特点，并不能称得上个性。既然风格不同，那么看别人代码的时候会有值得学习的地方，也有自己感觉不舒服的地方。也罢，毕竟人都有“个性”。&lt;/p&gt;

&lt;p&gt;这次我接手同事的代码主要是一个Excel导入数据库这样一个功能，在测试人员测试导入数据的时候，使用的导入数据有2w条作为测试数据导入数据库，现象是 导入后发现页面先是显示上传中，之后页面没有任何反馈，经排查后发现是因为后台还在处理导入数据逻辑，时间过长页面没有得到反馈，导致页面超时。&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;接着查看了导入逻辑，发现导入的时候，使用的是将2w条数据循环导入数据库，每一次导入都会进行数据库交互，导致数据库连接池的连接被耗尽，会再次进行创建、分配、释放等操作，从而导致之后的处理变得缓慢。&lt;/li&gt;
&lt;li&gt;基于这些考虑使用了批量导入，批量导入的目的就是一次导入多条数据，减少和数据库交互次数，减轻数据库压力。&lt;/li&gt;
&lt;li&gt;修改程序后测试导入所用的时间并不理想，继续排查发现 在导入前还有判断卡密是否存在数据库 这样一个操作，和循环插入没有什么区别，也是会循环2w次数据库查询。因此首先想到的是减少和数据库的交互次数，先把数据查询出来，放到内存中，再将两个集合进行比较，发现数据量小的时候还可以，数据量大了就会很缓慢，尝试了几个网上搜到的“高效”list去重，发现效果并不明显。&lt;/li&gt;
&lt;li&gt;遂继续找其他的方法，最后找到使用MySQL的ignore关键字【作用：若有导致unique key 冲突的记录，则该条记录不会被插入到数据库中，去重字段一定要是唯一索引】就可以解决判断卡密重复的问题，** 经过测试 导入2w条数据由原来的16分钟，减少到目前的10秒 左右** 。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于本次问题的排查，可以总结为问题发现，和问题排查。发现问题时首先要快速了解该功能的主要逻辑是什么，这次的导入主要有两点，一是 导入前判断是否有和数据库重复，二是导入操作。弄明白主要逻辑之后，就要分析，导入慢肯定是这两个逻辑的某一个逻辑慢，或者是两个逻辑都慢。经过分析发现，这两个逻辑都出现了循环建立数据库连接的问题，发现了问题的根本原因后，就要减少建立数据库连接次数，问题便得到解决。&lt;/p&gt;

&lt;p&gt;对于导入前和数据库判断是否有重复的，使用了mysql的一个关键字ignore，关键字的作用是：若有导致unique key 冲突的记录，则该条记录不会被插入到数据库中，去重字段一定要是唯一索引。其他就是拼接SQL使用批量导入。下面将主要的代码贴出来供大家参考。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;批量导入时每次批量插入100条数据，这样数据库连接建立的次数就从原来的 20000次减少到200次。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;        // 批量入库，每次批量插入100条
List&amp;lt;Detail&amp;gt; detailList = new ArrayList&amp;lt;&amp;gt;(); 
List&amp;lt;List&amp;lt;Detail&amp;gt;&amp;gt; tempList = new ArrayList&amp;lt;&amp;gt;();
    int insertCount = 100;
    for (int i = 0; i &amp;lt; detailList.size(); i += insertCount) {
        if ((i + insertCount) &amp;lt; detailList.size()) {
            List&amp;lt;Detail&amp;gt; newList = new ArrayList&amp;lt;&amp;gt;();
            newList.addAll(detailList.subList(i, i + insertCount));
            tempList.add(newList);
        } else {
            List&amp;lt;Detail&amp;gt; newList = new ArrayList&amp;lt;&amp;gt;();
            newList.addAll(detailList.subList(i, detailList.size()));
            tempList.add(newList);
        }
    }
Map&amp;lt;String, Object&amp;gt; map = detailManager.batchInsertDetail(tempList);
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;mybatis的写法&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;insert id=&quot;batchInsertDetail&quot; parameterType=&quot;java.util.List&quot;&amp;gt;
      insert ignore into my_table
        (id,code,status)
      values
        &amp;lt;foreach collection =&quot;list&quot; item=&quot;detail&quot; index= &quot;index&quot; separator =&quot;,&quot;&amp;gt;
            (#{detail.id,jdbcType=BIGINT},#{detail.code,jdbcType=VARCHAR},#{detail.status,jdbcType=TINYINT})
        &amp;lt;/foreach &amp;gt;
&amp;lt;/insert&amp;gt;&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sat, 09 Mar 2019 14:05:00 +0000</pubDate>
<dc:creator>五色花的</dc:creator>
<og:description>写这篇文章之前想着给这篇博客起一个文艺一点的标题，思来想去，想到了那些年我们爬过的山，或者我们一起趟过的河？代码不规范，同事两行泪，这是多么痛的领悟啊！ 背景 本组一名实习生，由于学校有事情需要回去处</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/luao/p/10503345.html</dc:identifier>
</item>
</channel>
</rss>