<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>@程序员，请掌握这些核心生存技能 - 沉默王二</title>
<link>http://www.cnblogs.com/qing-gee/p/12014503.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qing-gee/p/12014503.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;大咖你好，作为一个编程初学者，有什么需要注意的？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以上是一个读者流年似水的提问。我把他的问题置顶了，但一直没想好怎么回答，因为问题太过笼统了。后来，他也可能意识到了这一点，就又给我发了一条微信：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;在吗？老师。我们作为新人应该在编写代码的过程中注意哪些问题呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个问题其实也不太好回答，因为要注意的问题蛮多的，多得就像雾霾中的颗粒。不过，有趣的是，流年似水这两次的提问中，对我的称呼大有不同。&lt;/p&gt;
&lt;p&gt;“大咖”中略带一些调皮，而“老师”就显得过于庄重了。凭良心说，我喜欢“老师”这个称谓。但我知道这顶皇冠戴我头上，会把我 185 的身高压扁到 173。再说，我也不是什么“大咖”，无非比较接地气一点，喜欢和读者交流的感觉而已。&lt;/p&gt;
&lt;p&gt;那么接下来，我就针对流年似水的提问，做一些回答。希望对有类似问题的同学起到一个参考的作用。&lt;/p&gt;
&lt;h3 id=&quot;把编程吃透&quot;&gt;01、把编程吃透&lt;/h3&gt;
&lt;p&gt;父亲总是喜欢教育我说，你要懂得人情世故，要学会与人打交道。诚然，父亲说得没有错，人情世故、与人沟通非常的重要，重要到缺少这些会碰很多壁。&lt;/p&gt;
&lt;p&gt;但我更希望父亲教育我说：&lt;strong&gt;你作为一名程序员，要把编程吃透&lt;/strong&gt;！人总要先把本职工作干好，才能去完善其他的软技能嘛。当然了，我的希望是注定要落空的，因为父亲压根就不知道“程序员”是一个什么样的名词。&lt;/p&gt;
&lt;p&gt;我是知道的，程序员（英文 Programmer）是从事程序开发、程序维护的专业人员。 那么作为一名拥有 10 年开发经验的老鸟，我认为&lt;strong&gt;程序员最核心的生存技能当然是熟练地掌握一门编程语言&lt;/strong&gt;。这也是编程初学者最应该注意的，但往往会被忽视。&lt;/p&gt;
&lt;p&gt;别的编程语言我不太懂，Java 我是懂的。假如你想把 Java 这门编程语言吃透，我建议你这么做。&lt;/p&gt;
&lt;ul readability=&quot;4.7798165137615&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;轻松驾驭 IDE，比如 Eclipse 和 IDEA。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;快速查阅 Javadoc。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;掌握流程控制语句。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;理解类和对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;掌握三大特性：封装、继承和多态。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;会用&lt;a href=&quot;https://mp.weixin.qq.com/s/rEpGT1Tc3t3EDbA4Ir8ELQ&quot;&gt;接口&lt;/a&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;懂得泛型。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;掌握异常处理。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;熟悉 java.util 和 java.lang 包下的类。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;略懂 lambda 表达式和 Stream API。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;掌握 IO 流。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;会用 Socket 编程。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/iRViTgfiS5VenJ2rDBuG4Q&quot;&gt;掌握并发编程&lt;/a&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;懂得性能优化。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;会用 Junit 等单元测试工具。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;会用 Log4J 等日志工具。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;熟悉 Mybatis、MySql 和 Spring。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;入门 SpringBoot。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;熟悉设计模式。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;熟练地掌握一门编程语言，就是程序员的立命之本。知道了自己是靠什么吃饭的，就应该在这方面狠下功夫。&lt;/p&gt;
&lt;h3 id=&quot;巧用数据结构和算法&quot;&gt;02、巧用数据结构和算法&lt;/h3&gt;
&lt;p&gt;说起数据结构和算法，我就觉得不好意思，脸上泛起难为情的红晕。但为什么我还要说呢？&lt;/p&gt;
&lt;p&gt;因为我深受其苦。&lt;/p&gt;
&lt;p&gt;我是一个农村走出来的娃，体会过其中的酸甜苦辣，所以我会奉劝各位，以后碰上什么知识分子上山下乡的活动，千万不要去。那不叫体验生活，那叫体验“艰苦”生活。&lt;/p&gt;
&lt;p&gt;那&lt;strong&gt;在敲代码的过程中，我就经常遇到一些实际的问题，由于无法充分利用数据结构，将数据之间的关系通过合适的算法策略进行有效地存储转换，就导致程序的性能很低&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;所以我劝各位新人，趁有大把的时间和精力，多投入一点到数据结构和算法上面去。基础知识就像是一座大楼的地基，它决定了我们的技术高度。数据结构和算法就是最重要的基础知识，学习它们的过程就像是在打地基。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.itwanger.com/assets/images/2019/12/programmer-core-shengcun-jineng-2.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面这张思维导图提到的数据结构在工作当中太经常使用了，频率高得就像隔三差五会看到隔壁老王这个词一样。&lt;/p&gt;
&lt;p&gt;对于算法，如果觉得《算法导论》这本鸿篇巨制太过枯燥的话，可以选择《趣学算法》、《啊哈算法》等一些非译作的，相对趣味化的入门书。&lt;/p&gt;
&lt;p&gt;可能很多人会存在这样一个误区：算法在工作当中很少会用到，需要的时候面向搜索引擎解决一下就行了。&lt;/p&gt;
&lt;p&gt;但我想说的是，跳槽的时候很有用，因为一些大厂就喜欢考算法。除此之外，算法对阅读源码也很有帮助；况且，谁不想做一名编程的艺术家呢？长期来看，大脑思考能力是一个人最重要的核心竞争力，而算法是为数不多的能够有效训练大脑思考能力的途径之一。&lt;/p&gt;
&lt;h3 id=&quot;学会测试&quot;&gt;03、学会测试&lt;/h3&gt;
&lt;p&gt;为什么开发还需要了解测试？&lt;/p&gt;
&lt;p&gt;天真了吧！自古以来（其实也没多久了），程序员就身兼两职，既是开发工程师，又是测试工程师。&lt;/p&gt;
&lt;p&gt;说到这，不由得想起一段伤心的往事。在我刚做 Team Leader 的时候，手下有一名新人叫小董，他竟然使用“=”号操作符而不是“==”操作符作为 if 语句的条件判断。&lt;/p&gt;
&lt;p&gt;可能很多读者不相信：“怎么可能啊？？？IDE 会检测出来的！”交代一下背景，当时用的语言叫 ActionScript，和 Flex 配套开发富客户端页面——八年前了，估计没几个读者知道这门技术了。&lt;/p&gt;
&lt;p&gt;领导在日本出差，代码 Review 的时候被日方负责人查了出来，领导当场被骂得狗血喷头，没脸见人。我的遭遇可想而知，被领导骂得在厕所里面委屈地默默落泪，毕竟我是代码负责人。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;差点乌纱帽就丢了。这让我对那些写完代码不做测试的程序员恨得牙痒痒&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;从那以后，我就养成了一个好习惯（甚至说是强迫症），所有我负责的代码（包括我自己写的），在提交之前，代码 review、集成测试一个都不能少，提交代码的时候仍然要再次比对，确认无误后再提交。&lt;/p&gt;
&lt;p&gt;建议大家了解一下&lt;a href=&quot;https://mp.weixin.qq.com/s/qhuZbmtZEdQoQQKR6km10g&quot;&gt;测试驱动开发&lt;/a&gt;，英文缩写为 TDD，之前蛮流行的一种开发方式。测试与开发应该是相辅相成的关系。&lt;/p&gt;
&lt;h3 id=&quot;编码规范&quot;&gt;04、编码规范&lt;/h3&gt;
&lt;p&gt;规范化的代码看起来赏心悦目，让人仿佛置身于中世纪的哥特建筑中。&lt;/p&gt;
&lt;p&gt;这里必须提一提 Bob 大叔的《代码整洁之道》，这是一本每个程序员都要读的好书。里面提到的 KISS（Keep It Simple Stupid）原则，非常值得推崇。比如说：&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;整洁代码力求专注，每个函数、每个类和每个模块都应该全神贯注于一件事。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;整洁代码简单直接，从不隐藏设计者的意图。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;整洁代码使用有意义的命名，代码通过其字面表达含义。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;整洁代码力求消除重复代码，提高代码表达力。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;来看这样一段非常糟糕的代码。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private boolean isEligible(int age){
  boolean result;
  if(age &amp;gt; 18){
    result = true;
  }else{
    result = false;
  }
  return result;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你能从中挑出几个问题呢？&lt;/p&gt;
&lt;p&gt;1）&lt;code&gt;)&lt;/code&gt; 和 &lt;code&gt;{&lt;/code&gt; 之间没有空格。&lt;/p&gt;
&lt;p&gt;2）&lt;code&gt;return&lt;/code&gt; 语句太多了。&lt;/p&gt;
&lt;p&gt;3）代码过于臃肿。&lt;/p&gt;
&lt;p&gt;优化后的代码是这样子的。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private boolean isEligible(int age) {
  return age &amp;gt; 18;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那怎么写出规范化的代码呢？&lt;/p&gt;
&lt;p&gt;1）找一份规范的代码模板，导入到 IDE 中，保存代码之前进行格式化。&lt;/p&gt;
&lt;p&gt;2）使用 CheckStyle 或者 FindBugs 对代码进行检查，规避一些新手爱犯的低级错误。&lt;/p&gt;
&lt;p&gt;3）多看看阿里巴巴的开发手册，里面的一些建议还是非常值得参照的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.itwanger.com/assets/images/2019/12/programmer-core-shengcun-jineng-3.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;记住这句话：&lt;strong&gt;任何一个傻瓜都能写出计算机可以理解的代码，唯有写出人类容易理解的代码，才是优秀的程序员&lt;/strong&gt;。编码规范可以改善代码的可读性，让协作的同行拥有一个美丽的心情。&lt;/p&gt;
&lt;h3 id=&quot;源码管理&quot;&gt;05、源码管理&lt;/h3&gt;
&lt;p&gt;在我最初参加工作的时候，源码管理工具用的还是 CVS，后来迁移到 SVN。近些年来，选择 Git 的程序员渐渐多了起来。&lt;/p&gt;
&lt;p&gt;记得我刚开始用 CVS 的时候，经常弄丢版本，被领导批评过很多次，因为用的不熟（忍不住伤感）。幸好当时负责的代码都不怎么重要，丢了还可以重写。&lt;/p&gt;
&lt;p&gt;那为什么要使用源码管理工具呢？答案如下。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;多人并行开发&lt;/li&gt;
&lt;li&gt;多人协作同一份代码&lt;/li&gt;
&lt;li&gt;历史版本管理&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;除此之外，还有一个重要的作用，防止甩锅！大家都懂吧。&lt;/p&gt;
&lt;h3 id=&quot;鸣谢&quot;&gt;06、鸣谢&lt;/h3&gt;
&lt;p&gt;好了各位读者朋友们，以上就是本文的全部内容了。&lt;strong&gt;能看到这里的都是人才，二哥必须要为你点个赞&lt;/strong&gt;👍。如果觉得不过瘾，还想看到更多，可以查看我的&lt;a href=&quot;http://www.itwanger.com/&quot;&gt;个人博客&lt;/a&gt;。另外呢，给大家一个承诺，我每周都会更新一篇《程序人生》和一篇 Java 技术栈相关的文章，敬请期待。&lt;strong&gt;如果你有什么问题需要我的帮助，或者想喷我了，欢迎留言哟&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;养成好习惯！如果觉得这篇文章有点用的话，&lt;strong&gt;求点赞、求关注、求分享、求留言&lt;/strong&gt;，这将是我写下去的最强动力！如果大家想要第一时间看到二哥更新的文章，可以扫描下方的二维码，关注我的公众号。我们下篇文章见！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.itwanger.com/assets/images/cmower_3.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 10 Dec 2019 00:31:00 +0000</pubDate>
<dc:creator>沉默王二</dc:creator>
<og:description>大咖你好，作为一个编程初学者，有什么需要注意的？ 以上是一个读者流年似水的提问。我把他的问题置顶了，但一直没想好怎么回答，因为问题太过笼统了。后来，他也可能意识到了这一点，就又给我发了一条微信： 在吗</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qing-gee/p/12014503.html</dc:identifier>
</item>
<item>
<title> java多线程与线程池 - 软件老王</title>
<link>http://www.cnblogs.com/ruanjianlaowang/p/12014490.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ruanjianlaowang/p/12014490.html</guid>
<description>&lt;h3 id=&quot;场景描述&quot;&gt;1. 场景描述&lt;/h3&gt;
&lt;p&gt;以前多线程也常用，这次因需再页面上用到多线程，如下图，总结下，有需要的朋友可以参考下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1727736/201912/1727736-20191210081757081-203106493.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;解决方案&quot;&gt;2. 解决方案&lt;/h3&gt;
&lt;h4 id=&quot;线程池概念&quot;&gt;2.1 线程池概念&lt;/h4&gt;
&lt;p&gt;线程池官方定义不说了，通俗说下：池子的概念，事先（预定义）创建后，后续的线程可以直接从池子中拿，好处：&lt;/p&gt;
&lt;p&gt;（1）来创建线程比较消耗资源，不用重复创建；&lt;/p&gt;
&lt;p&gt;（2）池子事先定义好，避免无节制创建线程，导致系统出现不可预测风险。&lt;/p&gt;
&lt;h4 id=&quot;创建方式&quot;&gt;2.2 创建方式&lt;/h4&gt;
&lt;p&gt;采用jdk自带的线程池创建方式，jdk1.5开始提供，在java.util.concurrent 的包下面。&lt;/p&gt;
&lt;p&gt;表面上有两种创建方式，其实一种。&lt;/p&gt;
&lt;p&gt;（1）一种是采用new ThreadPoolExecutor进行创建；&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue&amp;lt;Runnable&amp;gt; workQueue,
                              ThreadFactory threadFactory,
                              RejectedExecutionHandler handler) {&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（2）一种是采用Executors.newFixedThreadPool(3)，不过还是调用的new ThreadPoolExecutor进行的线程池创建，赋值了几个默认参数而已。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;new ThreadPoolExecutor(nThreads, nThreads,
                                      0L, TimeUnit.MILLISECONDS,
                                      new LinkedBlockingQueue&amp;lt;Runnable&amp;gt;());&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;参数含义&quot;&gt;2.3 参数含义&lt;/h4&gt;
&lt;p&gt;一共有 7 个参数：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（1）corePoolSize&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;核心线程数，当有任务进来的时候，如果当前线程数还未达到 corePoolSize 个数，则创建核心线程，核心线程有几个特点：&lt;/p&gt;
&lt;p&gt;1、当线程数未达到核心线程最大值的时候，新任务进来，即使有空闲线程，也不会复用，仍然新建核心线程；2、核心线程一般不会被销毁，即使是空闲的状态，但是如果通过方法 allowCoreThreadTimeOut(boolean value) 设置为 true 时，超时也同样会被销毁；3、生产环境首次初始化的时候，可以调用 prestartCoreThread() 方法来预先创建所有核心线程，避免第一次调用缓慢；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（2）maximumPoolSize&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;除了有核心线程外，有些策略是当核心线程完全无空闲的时候，还会创建一些临时的线程来处理任务，maximumPoolSize 就是核心线程 + 临时线程的最大上限。临时线程有一个超时机制，超过了设置的空闲时间没有事儿干，就会被销毁。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（3）keepAliveTime&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个就是上面两个参数里所提到的超时时间，也就是线程的最大空闲时间，默认用于非核心线程，通过 allowCoreThreadTimeOut(boolean value) 方法设置后，也会用于核心线程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（4）unit&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个参数配合上面的 keepAliveTime ，指定超时的时间单位，秒、分、时等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（5）workQueue&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;等待执行的任务队列，如果核心线程没有空闲的了，新来的任务就会被放到这个等待队列中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（6）threadFactory&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;它是一个接口，用于实现生成线程的方式、定义线程名格式、是否后台执行等等，可以用 Executors.defaultThreadFactory() 默认的实现即可，也可以用 Guava 等三方库提供的方法实现，如果有特殊要求的话可以自己定义。它最重要的地方应该就是定义线程名称的格式，便于排查问题了吧。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（7）handler&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当没有空闲的线程处理任务，并且等待队列已满（当然这只对有界队列有效），再有新任务进来的话，就要做一些取舍了，而这个参数就是指定取舍策略的，有下面四种策略可以选择：&lt;/p&gt;
&lt;p&gt;ThreadPoolExecutor.AbortPolicy：直接抛出异常，这是默认策略；&lt;br/&gt;ThreadPoolExecutor.DiscardPolicy：直接丢弃任务，但是不抛出异常。&lt;br/&gt;ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后将新来的任务加入等待队列&lt;br/&gt;ThreadPoolExecutor.CallerRunsPolicy：由线程池所在的线程处理该任务，比如在 main 函数中创建线程池，如果执行此策略，将有 main 线程来执行该任务&lt;/p&gt;
&lt;h4 id=&quot;测试验证&quot;&gt;2.4 测试验证&lt;/h4&gt;
&lt;h5 id=&quot;测试线程&quot;&gt;2.4.1 测试线程&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;package com.yutong.laowang.test;

public class ThreadTest extends Thread{
    @Override
    public void run() {
        System.out.println(&quot;软件老王：&quot; +Thread.currentThread().getName());
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;executors创建&quot;&gt;2.4.2 Executors创建&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;  private static void test4() {
        Executor mExecutor = Executors.newFixedThreadPool(3);
        for (int i = 0; i &amp;lt; 10; i++) {
            Thread thread = new ThreadTest();
            mExecutor.execute(thread);
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;软件老王：pool-2-thread-2
软件老王：pool-2-thread-3
软件老王：pool-2-thread-1
软件老王：pool-2-thread-3
软件老王：pool-2-thread-2
软件老王：pool-2-thread-1
软件老王：pool-2-thread-3
软件老王：pool-2-thread-2
软件老王：pool-2-thread-3
软件老王：pool-2-thread-1&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;threadpoolexecutor创建&quot;&gt;2.4.3 ThreadPoolExecutor创建&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt; private static void test3() {
        int poolSize = 5;
        int queueSize = 100;
        ExecutorService executorService = new ThreadPoolExecutor(poolSize, poolSize, 0L, TimeUnit.SECONDS,
                new ArrayBlockingQueue&amp;lt;Runnable&amp;gt;(queueSize), new ThreadPoolExecutor.AbortPolicy());
                
        for (int i=0;i&amp;lt;10;i++) {
            executorService.submit(new ThreadTest());
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;软件老王：pool-2-thread-1
软件老王：pool-2-thread-3
软件老王：pool-2-thread-4
软件老王：pool-2-thread-2
软件老王：pool-2-thread-5
软件老王：pool-2-thread-5
软件老王：pool-2-thread-1
软件老王：pool-2-thread-2
软件老王：pool-2-thread-2
软件老王：pool-2-thread-1&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;线程停用&quot;&gt;2.4.4 线程停用&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;thread.interrupt();
---有时候不一定能执行成功，一般会结合判断使用,软件老王，例如：
在ThreadTest类中进行判断，默认为false，当满足条件下为true，停用线程。
 public volatile boolean exit = false;
&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;p&gt;I’m 「软件老王」，如果觉得还可以的话，关注下呗，后续更新秒知！欢迎讨论区、同名公众号留言交流！&lt;/p&gt;
</description>
<pubDate>Tue, 10 Dec 2019 00:18:00 +0000</pubDate>
<dc:creator>软件老王</dc:creator>
<og:description>以前多线程也常用，这次因需再页面上用到多线程，如下图，总结下，有需要的朋友可以参考下。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ruanjianlaowang/p/12014490.html</dc:identifier>
</item>
<item>
<title>你的SpringBoot应用真的部署更新成功了吗 - throwable</title>
<link>http://www.cnblogs.com/throwable/p/12014491.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/throwable/p/12014491.html</guid>
<description>&lt;h2 id=&quot;前提&quot;&gt;前提&lt;/h2&gt;
&lt;p&gt;当我们在生产环境部署了&lt;code&gt;SpringBoot&lt;/code&gt;应用的时候，虽然可以通过&lt;code&gt;Jenkins&lt;/code&gt;的构建状态和&lt;code&gt;Linux&lt;/code&gt;的&lt;code&gt;ps&lt;/code&gt;命令去感知应用是否在新的一次发布中部署和启动成功，但是这种监控手段是运维层面的。那么，可以提供一种手段能够在应用层面感知服务在新的一次发布中的构建部署和启动是否成功吗？这个问题笔者花了一点时间想通了这个问题，通过这篇文章提供一个简单的实现思路。&lt;/p&gt;
&lt;h2 id=&quot;基本思路&quot;&gt;基本思路&lt;/h2&gt;
&lt;p&gt;其实基本思路很简单，一般&lt;code&gt;SpringBoot&lt;/code&gt;应用会使用&lt;code&gt;Maven&lt;/code&gt;插件打包（笔者不熟悉&lt;code&gt;Gradle&lt;/code&gt;，所以暂时不对&lt;code&gt;Gradle&lt;/code&gt;做分析），所以可以这样考虑：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;Maven&lt;/code&gt;插件打包的时候，把&lt;strong&gt;构建时间&lt;/strong&gt;和&lt;code&gt;pom&lt;/code&gt;文件中的版本号都写到&lt;code&gt;jar&lt;/code&gt;包的描述文件中，正确来说就是&lt;code&gt;MANIFEST.MF&lt;/code&gt;文件中。&lt;/li&gt;
&lt;li&gt;引入&lt;code&gt;spring-boot-starter-actuator&lt;/code&gt;，通过&lt;code&gt;/actuator/info&lt;/code&gt;端点去暴露应用的信息（最好控制网络访问权限为只允许内网访问）。&lt;/li&gt;
&lt;li&gt;把第1步中打包到&lt;code&gt;jar&lt;/code&gt;包中的&lt;code&gt;MANIFEST.MF&lt;/code&gt;文件的内容读取并且加载到&lt;code&gt;SpringBoot&lt;/code&gt;环境属性中的&lt;code&gt;info.*&lt;/code&gt;属性中，以便可以通过&lt;code&gt;/actuator/info&lt;/code&gt;访问。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;思路定好了，那么下面开始实施编码。&lt;/p&gt;
&lt;h2 id=&quot;编码实现&quot;&gt;编码实现&lt;/h2&gt;
&lt;p&gt;最近刚好在调研蚂蚁金服的&lt;code&gt;SofaStack&lt;/code&gt;体系，这里引入&lt;code&gt;SofaBoot&lt;/code&gt;编写示例。&lt;code&gt;pom&lt;/code&gt;文件如下：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;
    &amp;lt;groupId&amp;gt;club.throwable&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;sofa-boot-sample&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;
    &amp;lt;packaging&amp;gt;jar&amp;lt;/packaging&amp;gt;
    &amp;lt;name&amp;gt;sofa-boot-sample&amp;lt;/name&amp;gt;
    &amp;lt;properties&amp;gt;
        &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt;
        &amp;lt;maven.compiler.source&amp;gt;1.8&amp;lt;/maven.compiler.source&amp;gt;
        &amp;lt;maven.compiler.target&amp;gt;1.8&amp;lt;/maven.compiler.target&amp;gt;
        &amp;lt;sofa.boot.version&amp;gt;3.2.0&amp;lt;/sofa.boot.version&amp;gt;
        &amp;lt;spring.boot.version&amp;gt;2.1.0.RELEASE&amp;lt;/spring.boot.version&amp;gt;
        &amp;lt;maven.build.timestamp.format&amp;gt;yyyy-MM-dd HH:mm:ss.SSS&amp;lt;/maven.build.timestamp.format&amp;gt;
    &amp;lt;/properties&amp;gt;
    &amp;lt;dependencyManagement&amp;gt;
        &amp;lt;dependencies&amp;gt;
            &amp;lt;dependency&amp;gt;
                &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;spring-boot-dependencies&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;${spring.boot.version}&amp;lt;/version&amp;gt;
                &amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt;
                &amp;lt;scope&amp;gt;import&amp;lt;/scope&amp;gt;
            &amp;lt;/dependency&amp;gt;
            &amp;lt;dependency&amp;gt;
                &amp;lt;groupId&amp;gt;com.alipay.sofa&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;sofaboot-dependencies&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;${sofa.boot.version}&amp;lt;/version&amp;gt;
                &amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt;
                &amp;lt;scope&amp;gt;import&amp;lt;/scope&amp;gt;
            &amp;lt;/dependency&amp;gt;
        &amp;lt;/dependencies&amp;gt;
    &amp;lt;/dependencyManagement&amp;gt;

    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;4.12&amp;lt;/version&amp;gt;
            &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.alipay.sofa&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;healthcheck-sofa-boot-starter&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;

    &amp;lt;build&amp;gt;
        &amp;lt;finalName&amp;gt;sofa-boot-sample&amp;lt;/finalName&amp;gt;
        &amp;lt;plugins&amp;gt;
            &amp;lt;plugin&amp;gt;
                &amp;lt;artifactId&amp;gt;maven-compiler-plugin&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;3.8.1&amp;lt;/version&amp;gt;
                &amp;lt;configuration&amp;gt;
                    &amp;lt;source&amp;gt;${maven.compiler.source}&amp;lt;/source&amp;gt;
                    &amp;lt;target&amp;gt;${maven.compiler.target}&amp;lt;/target&amp;gt;
                    &amp;lt;encoding&amp;gt;${project.build.sourceEncoding}&amp;lt;/encoding&amp;gt;
                &amp;lt;/configuration&amp;gt;
            &amp;lt;/plugin&amp;gt;
            &amp;lt;plugin&amp;gt;
                &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;${spring.boot.version}&amp;lt;/version&amp;gt;
                &amp;lt;executions&amp;gt;
                    &amp;lt;execution&amp;gt;
                        &amp;lt;goals&amp;gt;
                            &amp;lt;goal&amp;gt;repackage&amp;lt;/goal&amp;gt;
                        &amp;lt;/goals&amp;gt;
                    &amp;lt;/execution&amp;gt;
                &amp;lt;/executions&amp;gt;
            &amp;lt;/plugin&amp;gt;
            &amp;lt;plugin&amp;gt;
                &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;maven-jar-plugin&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;3.2.0&amp;lt;/version&amp;gt;
                &amp;lt;configuration&amp;gt;
                    &amp;lt;archive&amp;gt;
                        &amp;lt;manifest&amp;gt;
                            &amp;lt;addBuildEnvironmentEntries&amp;gt;true&amp;lt;/addBuildEnvironmentEntries&amp;gt;
                        &amp;lt;/manifest&amp;gt;
                        &amp;lt;manifestEntries&amp;gt;
                            &amp;lt;Application-Name&amp;gt;${project.groupId}:${project.artifactId}:${project.version}&amp;lt;/Application-Name&amp;gt;
                            &amp;lt;Build-Timestamp&amp;gt;${maven.build.timestamp}&amp;lt;/Build-Timestamp&amp;gt;
                        &amp;lt;/manifestEntries&amp;gt;
                    &amp;lt;/archive&amp;gt;
                &amp;lt;/configuration&amp;gt;
            &amp;lt;/plugin&amp;gt;
        &amp;lt;/plugins&amp;gt;
    &amp;lt;/build&amp;gt;
&amp;lt;/project&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;pom&lt;/code&gt;文件中一些属性和占位符的设置，可以参考一下这两个链接：&lt;a href=&quot;http://maven.apache.org/shared/maven-archiver/index.html&quot;&gt;Maven-Archiver&lt;/a&gt;和&lt;a href=&quot;http://maven.apache.org/guides/introduction/introduction-to-the-pom.html#Available_Variables&quot;&gt;Available Variables&lt;/a&gt;。&lt;code&gt;SpringBoot&lt;/code&gt;的配置文件&lt;code&gt;application.yaml&lt;/code&gt;如下：&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;server:
  port: 9091
management:
  server:
    port: 10091
  endpoints:
    enabled-by-default: false
    web:
      exposure:
        include: info
  endpoint:
    info:
      enabled: true
spring:
  application:
    name: sofa-boot-sample&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;这里要注意一点&lt;/strong&gt;：&lt;code&gt;SpringBoot&lt;/code&gt;应用通过其&lt;code&gt;Maven&lt;/code&gt;插件打出来的&lt;code&gt;jar&lt;/code&gt;包解压后的目录如下：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;sofa-boot-sample.jar
  - META-INF
    - MANIFEST.MF
    - maven ...
  - org
    - springframework 
      - boot ...
  - BOOT-INF
    - classes ...
    - lib ...    &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;了解此解压目录是我们编写&lt;code&gt;MANIFEST.MF&lt;/code&gt;文件的解析实现过程的前提。编写&lt;code&gt;MANIFEST.MF&lt;/code&gt;文件的解析类：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@SuppressWarnings(&quot;ConstantConditions&quot;)
public enum ManiFestFileExtractUtils {


    /**
     * 单例
     */
    X;

    private static Map&amp;lt;String, String&amp;gt; RESULT = new HashMap&amp;lt;&amp;gt;(16);
    private static final Logger LOGGER = LoggerFactory.getLogger(ManiFestFileExtractUtils.class);

    static {
        String jarFilePath = ClassUtils.getDefaultClassLoader().getResource(&quot;&quot;).getPath().replace(&quot;!/BOOT-INF/classes!/&quot;, &quot;&quot;);
        if (jarFilePath.startsWith(&quot;file&quot;)) {
            jarFilePath = jarFilePath.substring(5);
        }
        LOGGER.info(&quot;读取的Jar路径为:{}&quot;, jarFilePath);
        try (JarFile jarFile = new JarFile(jarFilePath)) {
            JarEntry entry = jarFile.getJarEntry(&quot;META-INF/MANIFEST.MF&quot;);
            if (null != entry) {
                BufferedReader reader = new BufferedReader(new InputStreamReader(jarFile.getInputStream(entry), StandardCharsets.UTF_8));
                String line;
                while (null != (line = reader.readLine())) {
                    LOGGER.info(&quot;读取到行:{}&quot;, line);
                    int i = line.indexOf(&quot;:&quot;);
                    if (i &amp;gt; -1) {
                        String key = line.substring(0, i).trim();
                        String value = line.substring(i + 1).trim();
                        RESULT.put(key, value);
                    }
                }
            }

        } catch (Exception e) {
            LOGGER.warn(&quot;解析MANIFEST.MF文件异常&quot;, e);
        }
    }

    public Map&amp;lt;String, String&amp;gt; extract() {
        return RESULT;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以通过一个&lt;code&gt;CommandLineRunner&lt;/code&gt;的实现把&lt;code&gt;MANIFEST.MF&lt;/code&gt;文件的内容写到&lt;code&gt;Environment&lt;/code&gt;实例中：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Component
public class SofaBootSampleRunner implements CommandLineRunner {

    @Autowired
    private ConfigurableEnvironment configurableEnvironment;

    @Override
    public void run(String... args) throws Exception {
        MutablePropertySources propertySources = configurableEnvironment.getPropertySources();
        Map&amp;lt;String, String&amp;gt; result = ManiFestFileExtractUtils.X.extract();
        Properties properties = new Properties();
        for (Map.Entry&amp;lt;String, String&amp;gt; entry : result.entrySet()) {
            String key = &quot;info.&quot; + entry.getKey();
            properties.setProperty(key, entry.getValue());
        }
        if (!properties.isEmpty()) {
            propertySources.addFirst(new PropertiesPropertySource(&quot;infoProperties&quot;, properties));
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动类如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@SpringBootApplication
public class SofaBootSampleApplication {

    public static void main(String[] args) {
        SpringApplication.run(SofaBootSampleApplication.class, args);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;最终效果&quot;&gt;最终效果&lt;/h2&gt;
&lt;p&gt;在项目的根目录使用命令&lt;code&gt;mvn package&lt;/code&gt;，打出&lt;code&gt;jar&lt;/code&gt;包后直接启动：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;cd Jar包的目录
java -jar sofa-boot-sample.jar&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;调用&lt;code&gt;http://localhost:10091/actuator/info&lt;/code&gt;接口输出如下：&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
    &quot;Spring-Boot-Version&quot;: &quot;2.1.0.RELEASE&quot;,
    &quot;Start-Class&quot;: &quot;club.throwable.sofa.SofaBootSampleApplication&quot;,
    &quot;Main-Class&quot;: &quot;org.springframework.boot.loader.JarLauncher&quot;,
    &quot;Manifest-Version&quot;: &quot;1.0&quot;,
    &quot;Build-Jdk-Spec&quot;: &quot;1.8&quot;,
    &quot;Spring-Boot-Classes&quot;: &quot;BOOT-INF/classes/&quot;,
    &quot;Created-By&quot;: &quot;Maven Jar Plugin 3.2.0&quot;,
    &quot;Build-Timestamp&quot;: &quot;2019-12-08 17:41:21.844&quot;,
    &quot;Spring-Boot-Lib&quot;: &quot;BOOT-INF/lib/&quot;,
    &quot;Application-Name&quot;: &quot;club.throwable:sofa-boot-sample:1.0-SNAPSHOT&quot;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;改变&lt;code&gt;pom&lt;/code&gt;文件中的版本标签&lt;code&gt;&amp;lt;version&amp;gt;&lt;/code&gt;为&lt;code&gt;1.0.0&lt;/code&gt;，再次打包并且启动成功后调用&lt;code&gt;http://localhost:10091/actuator/info&lt;/code&gt;接口输出如下：&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
    &quot;Spring-Boot-Version&quot;: &quot;2.1.0.RELEASE&quot;,
    &quot;Start-Class&quot;: &quot;club.throwable.sofa.SofaBootSampleApplication&quot;,
    &quot;Main-Class&quot;: &quot;org.springframework.boot.loader.JarLauncher&quot;,
    &quot;Manifest-Version&quot;: &quot;1.0&quot;,
    &quot;Build-Jdk-Spec&quot;: &quot;1.8&quot;,
    &quot;Spring-Boot-Classes&quot;: &quot;BOOT-INF/classes/&quot;,
    &quot;Created-By&quot;: &quot;Maven Jar Plugin 3.2.0&quot;,
    &quot;Build-Timestamp&quot;: &quot;2019-12-08 17:42:07.273&quot;,
    &quot;Spring-Boot-Lib&quot;: &quot;BOOT-INF/lib/&quot;,
    &quot;Application-Name&quot;: &quot;club.throwable:sofa-boot-sample:1.0.0&quot;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可见构建时间戳&lt;code&gt;Build-Timestamp&lt;/code&gt;和服务名&lt;code&gt;Application-Name&lt;/code&gt;都发生了变化，达到了监控服务是否正常部署和启动的目的。如果有多个服务节点，可以添加一个&lt;code&gt;ip&lt;/code&gt;属性加以区分。&lt;/p&gt;
&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;这篇文章通过&lt;code&gt;SpringBoot&lt;/code&gt;一些实用技巧实现了应用层面监控应用是否正常打包部署更新和启动成功的问题。&lt;/p&gt;
&lt;h2 id=&quot;原文链接&quot;&gt;原文链接&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;Github Page：http://throwable.club/2019/12/09/spring-boot-server-deploy-monitor&lt;/li&gt;
&lt;li&gt;Coding Page：http://throwable.coding.me/2019/12/09/spring-boot-server-deploy-monitor&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;（本文完 e-a-20191209:1:39 c-1-d）&lt;/p&gt;
</description>
<pubDate>Tue, 10 Dec 2019 00:18:00 +0000</pubDate>
<dc:creator>throwable</dc:creator>
<og:description>前提 当我们在生产环境部署了 应用的时候，虽然可以通过 的构建状态和 的`ps`命令去感知应用是否在新的一次发布中部署和启动成功，但是这种监控手段是运维层面的。那么，可以提供一种手段能够在应用层面感知</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/throwable/p/12014491.html</dc:identifier>
</item>
<item>
<title>[UWP]使用CompositionGeometricClip裁剪复杂图形及进行动画 - dino.c</title>
<link>http://www.cnblogs.com/dino623/p/using_compositiongeometricclip_to_cut_and_animate_complex_graphics.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dino623/p/using_compositiongeometricclip_to_cut_and_animate_complex_graphics.html</guid>
<description>&lt;h2 id=&quot;uwp中的其它裁剪方案&quot;&gt;1. UWP中的其它裁剪方案&lt;/h2&gt;
&lt;p&gt;之前在 &lt;a href=&quot;https://www.cnblogs.com/dino623/p/UWP_UIElement_Clip.html&quot;&gt;这篇文章&lt;/a&gt; 里，我介绍了如何使用&lt;a href=&quot;https://docs.microsoft.com/en-us/uwp/api/windows.ui.xaml.uielement.clip&quot;&gt;UIElement.Clip&lt;/a&gt;裁剪UIElement的内容，使用代码如下：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;Canvas&amp;gt;
    &amp;lt;Image Source=&quot;Images/Water_lilies.jpg&quot; Width=&quot;200&quot; Height=&quot;150&quot;&amp;gt;
        &amp;lt;Image.Clip&amp;gt;
            &amp;lt;RectangleGeometry Rect=&quot;100 75 50 50&quot;/&amp;gt;
        &amp;lt;/Image.Clip&amp;gt;
    &amp;lt;/Image&amp;gt;
&amp;lt;/Canvas&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 &lt;a href=&quot;https://www.cnblogs.com/dino623/p/using_win2d_and_composition_API_to_implement_the_glow_effect_of_text_and_make_animation.html&quot;&gt;另一篇文章里&lt;/a&gt; 我介绍了如何使用 &lt;a href=&quot;http://microsoft.github.io/Win2D/html/T_Microsoft_Graphics_Canvas_CanvasActiveLayer.htm&quot;&gt;CanvasActiveLayer&lt;/a&gt; 裁剪Win2D内容，使用代码如下：&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;var fullSizeGeometry = CanvasGeometry.CreateRectangle(session, 0, 0, width, height);
var textGeometry = CanvasGeometry.CreateText(textLayout);
var finalGeometry = fullSizeGeometry.CombineWith(textGeometry, Matrix3x2.Identity, CanvasGeometryCombine.Exclude);

using (var layer = session.CreateLayer(1, finalGeometry))
{
    //DrawSth
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这两种方式都有他们的局限：CanvasActiveLayer虽然很灵活，但只能裁剪Win2D的内容，而且代码量不少；而UIElement.Clip虽然使用简单，但只能裁剪矩形区域。而介于他们之间的是使用&lt;code&gt;Visual.Clip&lt;/code&gt;的裁剪方案。&lt;/p&gt;
&lt;h2 id=&quot;visual.clip和insetclipcompositiongeometricclip&quot;&gt;2. Visual.Clip和InsetClip、CompositionGeometricClip&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/uwp/api/windows.ui.composition.visual.clip#Windows_UI_Composition_Visual_Clip&quot;&gt;Visual.Clip&lt;/a&gt;允许用户使用&lt;a href=&quot;https://docs.microsoft.com/en-us/uwp/api/windows.ui.composition.compositionclip&quot;&gt;CompositionClip&lt;/a&gt;。刚开始继承CompositionClip类的只有 &lt;a href=&quot;https://docs.microsoft.com/en-us/uwp/api/windows.ui.composition.insetclip&quot;&gt;InsetClip&lt;/a&gt;，它只能裁剪矩形区域，不能否定某些情况下它还是挺有用的，何况还能进行动画，但比&lt;code&gt;UIElement.Clip&lt;/code&gt;还是好不了多少。使用方法如下：&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;var compositor = Window.Current.Compositor;
var visual = ElementCompositionPreview.GetElementVisual(uElement);
var clip = compositor.CreateInsetClip(leftInset, topInset, rightInset, bottomInset);
visual.Clip = clip;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;到了1809，&lt;code&gt;Compositor&lt;/code&gt;提供了一个新的函数&lt;a href=&quot;https://docs.microsoft.com/en-us/uwp/api/windows.ui.composition.compositor.creategeometricclip&quot;&gt;CreateGeometricClip&lt;/a&gt;，它可以以&lt;a href=&quot;https://docs.microsoft.com/en-us/uwp/api/windows.ui.composition.compositiongeometry&quot;&gt;CompositionGeometry&lt;/a&gt; 为参数创建一个&lt;a href=&quot;https://docs.microsoft.com/en-us/uwp/api/windows.ui.composition.compositiongeometricclip&quot;&gt;CompositionGeometricClip&lt;/a&gt;，这样就可以根据&lt;code&gt;CompositionGeometry&lt;/code&gt;裁剪复杂的区域。&lt;code&gt;Compositor&lt;/code&gt;提供了CreateEllipseGeometry、CreateLineGeometry、CreatePathGeometry、CreatePathGeometry(CompositionPath)、CreateRectangleGeometry、CreateRoundedRectangleGeometry等一些列创建Geometry的函数，具体使用方法如下：&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;var compositor = Window.Current.Compositor;
var visual = ElementCompositionPreview.GetElementVisual(uElement);

var geometry  = compositor.CreateEllipseGeometry();
geometry.Center = new System.Numerics.Vector2(192, 525);
geometry.Radius = Vector2.Zero;
var clip = compositor.CreateGeometricClip(geometry);

visual.Clip = clip;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的代码使用&lt;code&gt;CreateEllipseGeometry&lt;/code&gt;创建了一个圆形的Geometry，设置好这个Geometry的中心点和半径，然后用这个圆形裁剪Visual。&lt;/p&gt;
&lt;h2 id=&quot;创建动画&quot;&gt;3. 创建动画&lt;/h2&gt;
&lt;p&gt;CompositionApi的一个最大的好处是灵活的动画，例如下面这个用EllipseGeometry制作的动画：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/38937/201912/38937-20191208205622087-437862815.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;它只是很简单地对&lt;code&gt;Radius&lt;/code&gt;进行KeyFrame动画，代码如下：&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;var compositor = Window.Current.Compositor;
var animation = compositor.CreateVector2KeyFrameAnimation();

animation.DelayTime = delayTime;
animation.Duration = TimeSpan.FromSeconds(0.7);
animation.InsertKeyFrame(1, new Vector2(600, 600));
ellipseGeometry.StartAnimation(nameof(CompositionEllipseGeometry.Radius), animation);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有趣的是Radius居然是个Vector2属性，所以&lt;code&gt;CompositionEllipseGeometry&lt;/code&gt;其实可以创建为椭圆形。&lt;/p&gt;
&lt;h2 id=&quot;结语&quot;&gt;4. 结语&lt;/h2&gt;
&lt;p&gt;有了CompositionGeometricClip可以在UWP裁剪复杂区域，但只能在1809以后使用。只是裁剪的话，目前看起来没比WPF有多少优势，但加上Composition动画可玩性就强太多了。使用WPF的时候我几乎不敢使用动画，总是需要照顾低端配置，又担心WPF的性能。10年过去了，UWP的性能以及现代化的电脑配置终于可以让我放飞自我了。&lt;/p&gt;
&lt;h2 id=&quot;参考&quot;&gt;5. 参考&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/uwp/api/windows.ui.composition.compositor&quot;&gt;Compositor Class (Windows.UI.Composition) - Windows UWP applications _ Microsoft Docs&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/uwp/api/windows.ui.composition.visual.clip#Windows_UI_Composition_Visual_Clip&quot;&gt;Visual.Clip Property (Windows.UI.Composition) - Windows UWP applications _ Microsoft Docs&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/uwp/api/windows.ui.composition.compositionclip&quot;&gt;CompositionClip Class (Windows.UI.Composition) - Windows UWP applications _ Microsoft Docs&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/uwp/api/windows.ui.composition.compositor.createinsetclip#Windows_UI_Composition_Compositor_CreateInsetClip&quot;&gt;Compositor.CreateInsetClip Method (Windows.UI.Composition) - Windows UWP applications _ Microsoft Docs&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/uwp/api/windows.ui.composition.insetclip&quot;&gt;InsetClip Class (Windows.UI.Composition) - Windows UWP applications _ Microsoft Docs&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/uwp/api/windows.ui.composition.compositor.creategeometricclip#Windows_UI_Composition_Compositor_CreateGeometricClip&quot;&gt;Compositor.CreateGeometricClip Method (Windows.UI.Composition) - Windows UWP applications _ Microsoft Docs&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/uwp/api/windows.ui.composition.compositiongeometry&quot;&gt;CompositionGeometry Class (Windows.UI.Composition) - Windows UWP applications _ Microsoft Docs&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/uwp/api/windows.ui.composition.compositiongeometricclip&quot;&gt;CompositionGeometricClip Class (Windows.UI.Composition) - Windows UWP applications _ Microsoft Docs&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/uwp/api/windows.ui.composition.compositionellipsegeometry&quot;&gt;CompositionEllipseGeometry Class (Windows.UI.Composition) - Windows UWP applications _ Microsoft Docs&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 10 Dec 2019 00:16:00 +0000</pubDate>
<dc:creator>dino.c</dc:creator>
<og:description>1. UWP中的其它裁剪方案 之前在 '这篇文章' 里，我介绍了如何使用 'UIElement.Clip' 裁剪UIElement的内容，使用代码如下： 在 '另一篇文章里' 我介绍了如何使用 'Ca</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/dino623/p/using_compositiongeometricclip_to_cut_and_animate_complex_graphics.html</dc:identifier>
</item>
<item>
<title>不一样的角度一窥多线程 - 码农阿宇</title>
<link>http://www.cnblogs.com/CoderAyu/p/12014480.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CoderAyu/p/12014480.html</guid>
<description>&lt;p&gt;最近在性能调试时,发现了一个有趣的现象,我把代码简化后如下.&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine(&quot;Start...&quot;);
            DoSomething();
            Console.WriteLine(&quot;Ending...&quot;);
            Console.ReadLine();
        }

        static void DoSomething()
        {
            var sum=&quot;&quot;;
            for (int i = 2; i &amp;lt; int.MaxValue; i++)
            {
                sum += &quot;s&quot;;
            }
            Console.WriteLine(sum.Length);
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到,非常简单的一段代码,当我用Windows的性能监测工具来监测每个处理器的使用率时,发现了一个有趣的现象.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://disk.iblogs.site/pic/ThreadInDotnet/PerformaceMonitor.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我电脑是四核的I7处理器,执行以上代码后,却只有处理器2一直处理一个比较高的占用率,而其他的三个则处于一个&quot;摸鱼混日子&quot;的状态,处理器1则更过分,你是睡着了吗?&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://disk.iblogs.site/pic/ThreadInDotnet/moyu.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;同一台电脑上的处理器,难道大家不是有福同享,有难同当的吗? 为什么其他几个处理器就忍心看着处理器2水深火热呢?&lt;/p&gt;
&lt;p&gt;然后,我就和这个问题死磕上了,恶补了一些操作系统与多线程的知识,现在把一写知识点串起来,分享给大家.&lt;/p&gt;
&lt;h2 id=&quot;分级保护域&quot;&gt;分级保护域&lt;/h2&gt;
&lt;p&gt;电脑操作系统提供不同的资源访问级别。在计算机体系结构中，Rings是由两个或更多的特权态组成。在一些硬件或者微代码级别上提供不同特权态模式的CPU架构上，保护环通常都是硬件强制的。Rings是从最高特权级（通常被叫作0级）到最低特权级（通常对应最大的数字）排列的。在大多数操作系统中，Ring 0拥有最高特权，并且可以和最多的硬件直接交互（比如CPU，内存）。在Windows中, User Space,也就是我们自己安装的那些应用程序处理Ring 3,而系统内核就在Ring 0.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://disk.iblogs.site/pic/ThreadInDotnet/Priv_rings.svg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对于这个问题,举个例子,大家就好理解了.&lt;br/&gt;钱不是万能的,但没钱是万万不能的,所以钱是一个家庭的重中之重,家里老婆呢为了这个家的长治久安,掌握家里的财政大权,把家里的小金库守得死死的,但这就意味着我没钱花了吗?当然不是,和老婆大人用正当理由申请不就完事了?😂&lt;br/&gt;申请通过之后,老婆大人是允许我直接伸手去家里小金库拿钱吗? 那当然不是,如果我一抓一大把就危险了,所以还得经过她的手从小金库拿钱给我.&lt;br/&gt;这个现象,我觉得也是一种分级保护域,所以呢,也一直对老婆大人的这种万恶行径表示理解.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://disk.iblogs.site/pic/ThreadInDotnet/%E6%B5%81%E4%B8%8B%E7%9C%BC%E6%B3%AA.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;操作系统也是这样,CPU,内存这些硬件是电脑安全的根本,所以不能给第三方软件操作权限,想操作硬件,就通过由Ring 0中内核(Kernel)暴露的严格Api进行.&lt;/p&gt;
&lt;h2 id=&quot;用户级线程与内核级线程&quot;&gt;用户级线程与内核级线程&lt;/h2&gt;
&lt;p&gt;线程主要有以下两种实现方式-&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;用户级线程 -用户托管线程。&lt;/li&gt;
&lt;li&gt;内核级线程 -作用在内核（操作系统核心）上的操作系统管理的线程。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://disk.iblogs.site/pic/ThreadInDotnet/many_to_one.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在上图中,User Space就可以理解为我上个章节中的Ring 3,而Kernel Space就是Ring 0, 在Ring 0中,是可以直接操作CPU,内存等硬件的,而Ring 3不行.&lt;/p&gt;
&lt;p&gt;以下是用户级线程与内核级线程的对比.&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;13&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;用户线程由用户实现。&lt;/td&gt;
&lt;td&gt;内核线程由OS实现。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;操作系统无法识别用户级线程。&lt;/td&gt;
&lt;td&gt;内核线程被操作系统识别。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;用户线程的实现很容易。&lt;/td&gt;
&lt;td&gt;内核线程的实现很复杂。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;上下文切换时间更少。&lt;/td&gt;
&lt;td&gt;上下文切换时间更长。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;上下文切换不需要硬件支持。&lt;/td&gt;
&lt;td&gt;需要硬件支持。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;如果一个用户级别的线程执行阻止操作，则整个过程将被阻止。&lt;/td&gt;
&lt;td&gt;如果一个内核线程执行阻止操作，则另一线程可以继续执行。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;无法直接发挥多核处理器的优势&lt;/td&gt;
&lt;td&gt;可以享受多处理起带来的好处&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;其中,非常重要的一点,用户级线程无法直接发挥多核处理器的优势,难道我们编写出来的代码只能在一个处理器上运行了吗?这就要讲讲用户级线程模型.&lt;/p&gt;
&lt;h2 id=&quot;用户级线程模型&quot;&gt;用户级线程模型&lt;/h2&gt;
&lt;p&gt;通常，内核级线程可以使用三个模型之一来执行用户级线程。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Many-to-one&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;One-to-one&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;Many-to-many&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所有模型都将用户级线程映射到内核级线程,一个内核线程就像一个处理器,它是系统编排任务的基本单位。&lt;/p&gt;
&lt;h2 id=&quot;many-to-one&quot;&gt;Many-to-one&lt;/h2&gt;
&lt;p&gt;多对一模型将许多用户级线程映射到一个内核级线程。线程管理是通过线程库在用户空间中完成的。当线程进行阻塞的系统调用时，整个过程将被阻塞。一次只能有一个线程访问内核，因此多个线程无法在多处理器上并行运行。&lt;br/&gt;如果用户级线程库是以操作系统不支持的方式实现的，则内核线程将使用多对一关系模型。&lt;br/&gt;&lt;img src=&quot;https://disk.iblogs.site/pic/ThreadInDotnet/many-to-one.png&quot;/&gt;&lt;br/&gt;内核对用户级线程不可见,在它眼里只有内核线程,而在内核线程的眼里,一个进程无非就是一个偶尔被被它翻牌的黑盒子,进程负责用户线程的调度与执行.&lt;/p&gt;
&lt;h2 id=&quot;one-to-one&quot;&gt;One-to-one&lt;/h2&gt;
&lt;p&gt;在这种模型下用户级线程与内核级线程之间存在一对一的关系。该模型比多对一模型并发性好,当一个线程进行阻塞系统调用时，它还允许另一个线程运行,所以它支持多个线程以在处理器上并行执行。&lt;br/&gt;该模型的缺点是创建用户线程需要相应的内核线程,而创建内核线程开销是很大的.&lt;br/&gt;&lt;img src=&quot;https://disk.iblogs.site/pic/ThreadInDotnet/one-to-one.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;many-to-many&quot;&gt;Many-to-many&lt;/h2&gt;
&lt;p&gt;在多对多模型中，m个内核线程处理n个用户线程,其中m &amp;lt; n. 该模型并发性最好,并且不用创建过多的内核线程,涉及到的线程切换同步的开销也更小.&lt;br/&gt;&lt;img src=&quot;https://disk.iblogs.site/pic/ThreadInDotnet/many-to-many.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;真相浮出水面&quot;&gt;真相浮出水面&lt;/h2&gt;
&lt;p&gt;.Net的代码作为托管代码在“托管线程”上执行，而托管线程是在CLR虚拟机上执行的虚拟线程,也是属于用户级线程.&lt;/p&gt;
&lt;p&gt;正如JIT编译器将“虚拟” IL指令映射到在物理计算机上执行的本机指令一样，CLR的线程基础结构也将“虚拟”托管线程映射到操作系统提供的内核线程。&lt;/p&gt;
&lt;p&gt;说到这里,我们也差不多有了前面我说的那个现象的答案了,并非其他处理器不想与那个水深火热的处理器有难同享,而是我没有使用多线程,所以执行的程序只有一个主线程,也就是说用户线程数为1.只能是one to one 模型,所以只有一个处理器能参与工作.&lt;/p&gt;
&lt;p&gt;既然知道了里面的原理,那我们就对前文中的程序进行改造,创建四个线程来执行任务,会不会所有处理器都忙起来呢?&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine(&quot;Start...&quot;);
            for (var i = 0; i &amp;lt; 4; i++)
            {
                var td=new Thread(DoSomething);
                td.Start();
            }
            Console.WriteLine(&quot;Ending...&quot;);
            Console.ReadLine();
        }

        static void DoSomething()
        {
            var sum=&quot;&quot;;
            for (int i = 2; i &amp;lt; int.MaxValue; i++)
            {
                sum += &quot;s&quot;;
            }
            Console.WriteLine(sum.Length);
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到,这次大家的步伐都做到了惊人的一致,四个处理器都被调用起来,加上主线程,这里至少有五个用户线程,所以这里应该是many to many的模型了.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://disk.iblogs.site/pic/ThreadInDotnet/MutilThread.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;谢谢观赏!&lt;/p&gt;
&lt;p&gt;参考资料:&lt;br/&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Protection_ring&quot; class=&quot;uri&quot;&gt;https://en.wikipedia.org/wiki/Protection_ring&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://stackoverflow.com/questions/15093510/whats-c-sharp-threading-type&quot; class=&quot;uri&quot;&gt;https://stackoverflow.com/questions/15093510/whats-c-sharp-threading-type&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://github.com/dotnet/coreclr/blob/master/Documentation/botr/&quot; class=&quot;uri&quot;&gt;https://github.com/dotnet/coreclr/blob/master/Documentation/botr/&lt;/a&gt; threading.md#clr-threading-overview&lt;/p&gt;
</description>
<pubDate>Tue, 10 Dec 2019 00:06:00 +0000</pubDate>
<dc:creator>码农阿宇</dc:creator>
<og:description>不一样的角度一窥多线程 最近在性能调试时,发现了一个有趣的现象,我把代码简化后如下. 可以看到,非常简单的一段代码,当我用Windows的性能监测工具来监测每个处理器的使用率时,发现了一个有趣的现象.</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/CoderAyu/p/12014480.html</dc:identifier>
</item>
<item>
<title>[ASP.NET Core 3框架揭秘] 配置[3]：配置模型总体设计 - Artech</title>
<link>http://www.cnblogs.com/artech/p/inside-asp-net-core-05-03.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/artech/p/inside-asp-net-core-05-03.html</guid>
<description>&lt;p&gt;在《读取配置数据》（[&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-05-01.html&quot;&gt;上篇&lt;/a&gt;]，[&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-05-02.html&quot;&gt;下篇&lt;/a&gt;]）上面一节中，我们通过实例的方式演示了几种典型的配置读取方式，接下来我们从设计的维度来重写认识配置模型。配置的编程模型涉及到三个核心对象，分别通过三个对应的接口（IConfiguration、IConfigurationSource和IConfigurationBuilder）来表示。如果从设计层面来审视背后的配置模型，还缺少另一个名通过IConfigurationProvider接口表示的核心对象。总的来说，配置模型由这四个核心对象组成，但是要彻底了解这四个核心对象之间的关系，我们先得来聊聊配置的几种数据结构。&lt;/p&gt;

&lt;p&gt;相同的数据具有不同的表现形式和承载方式，同时体现出不同的数据结构。对于配置来说，它在被应用程序消费过程中是以IConfiguration对象的形式来体现的，该对象在逻辑上具有一个树形化层次结构，所以将它称之为&lt;span&gt;配置树&lt;/span&gt;，并将这棵树视为配置的“逻辑结构”。配置具有多种原始来源，可以是内存对象、物理文件、数据库或者其他自定义的存储介质。如果采用物理文件来存储配置数据，我们还可以选择不同的文件格式，常见的文件类型包括XML、JSON和INI三种，所以配置的原始数据结构是多种多样的。配置模型的最终目的在于提取原始的配置数据并将其转换成一个IConfiguration对象。话句话说，配置模型的使命就在于按照下图所示的方式将配置数据从原始的结构转换成树形层次结构。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/19327/201912/19327-20191210080250987-659514768.png&quot;&gt;&lt;img width=&quot;240&quot; height=&quot;95&quot; title=&quot;6-8&quot; alt=&quot;6-8&quot; src=&quot;https://img2018.cnblogs.com/blog/19327/201912/19327-20191210080251401-1234828627.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;配置从原始结构向逻辑结构的转换不是一蹴而就的，在它们之间具有一种“中间结构”。原始的配置数据被读取出来之后会先统一转换成这种中间结构的数据，那么这种中间结构到底是一种怎样的数据结构呢？一棵配置树通过其叶子结点承载所有的原子配置数据， 这棵树的结构和承载的数据完全可以利用一个简单的数据字典来表达。具体来说，我们只需要将所有叶子节点在配置树中的路径作为Key，将叶子结点承载的配置数据作为Value即可。所谓的“中间结构”指的就是这样的数据字典，我们不妨将其称为“&lt;span&gt;配置字典&lt;/span&gt;”。所以配置模型会按照图6-9所示的方式将具有不同原始结构的配置数据统一转换成基于字典的配置字典，最终再完成针对逻辑结构的转换。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/19327/201912/19327-20191210080251615-1461434207.png&quot;&gt;&lt;img width=&quot;325&quot; height=&quot;99&quot; title=&quot;6-9&quot; alt=&quot;6-9&quot; src=&quot;https://img2018.cnblogs.com/blog/19327/201912/19327-20191210080252537-1247320552.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;对于配置模型的四个核心对象来说，IConfiguration对象是对配置树的体现，其他三个核心对象（IConfigurationSource、IConfigurationBuilder和IConfigurationProvider）在配置的结构转换过程中扮演着不同的角色，至于它们究竟起到怎样的作用，我们将在接下来的内容中对它们作专门的介绍。&lt;/p&gt;

&lt;p&gt;配置在应用程序中总是以一个IConfiguration对象的形式供我们使用。一个IConfiguration对象具有树形层次化结构的意思并不是说对应的类型具有对应的数据成员定义，而是说它提供的API在逻辑上体现出树形化层次结构，所以我们才说配置树是一种逻辑结构。如下所示的是IConfiguration接口的完整定义，所谓的层次化逻辑结构就体现在它的成员定义上。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IConfiguration
{
    IEnumerable&lt;/span&gt;&amp;lt;IConfigurationSection&amp;gt;&lt;span&gt;     GetChildren();
    IConfigurationSection GetSection(&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt; key);
    IChangeToken GetReloadToken();
   
    &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;[&lt;span&gt;string&lt;/span&gt; key] { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;一个IConfiguration对象表示配置树的某个配置节点。对于组成整棵树的所有配置节点来说，表示根节点的IConfiguration对象与表示其它配置节点的IConfiguration对象是不同的，所以配置模型采用不同的接口来表示它们。根节点所在的IConfiguration对象体现为一个&lt;span&gt;IConfigurationRoot&lt;/span&gt;对象，除此之外的其他节点对象则被通过一个&lt;span&gt;IConfigurationSection&lt;/span&gt;对象表示，IConfigurationRoot和IConfigurationSection接口都是IConfiguration的继承者。下图为我们展示了由一个IConfigurationRoot对象和一组 IConfigurationSection对象构成的配置树。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/19327/201912/19327-20191210080252744-1437168042.png&quot;&gt;&lt;img width=&quot;240&quot; height=&quot;109&quot; title=&quot;6-10&quot; alt=&quot;6-10&quot; src=&quot;https://img2018.cnblogs.com/blog/19327/201912/19327-20191210080252945-1194370927.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如下所示的是接口IConfigurationRoot的定义，它具有的唯一方法Reload实现对配置数据的重新加载。IConfigurationRoot对象表示的配置树的根，所以也代表了整棵配置树，如果它被重新加载了，意味着整棵配置树承载的所有配置数据均被重新加载了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IConfigurationRoot : IConfiguration
{
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; Reload();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;表示非根配置节点的IConfigurationSection接口具有如下三个属性，只读属性Key用来唯一标识多个具有相同父节点的ConfigurationSection对象，而Path则表示当前配置节点在配置树中的路径，它后组成当前路径的所有IConfigurationSection对象的Key组成，并采用冒号（“：”）作为分隔符。Path和Key的组合体现了当前配置节在整个配置树中的位置。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IConfigurationSection : IConfiguration
{    
    &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; Path { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; Key { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; Value { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;IConfigurationSection的Value属性表示配置节点承载的配置数据。在大部分情况下，只有配置树的叶子结点对应的IConfigurationSection对象才具有值，非叶子节点对应的IConfigurationSection对象实际上仅仅表示存放所有子配置节点的逻辑容器，它们的Value一般返回Null。值得一体的是，这个Value属性并不是只读的，而是可读可写的，但我们写入的值一般不会被持久化，一旦配置树被重新加载，该值将会丢失。&lt;/p&gt;
&lt;p&gt;在对IConfigurationRoot和IConfigurationSection具有基本了解情况下我们回过头来看看定义在接口IConfiguration中的成员。它的GetChildren方法返回的IConfigurationSection集合表示它的所有子配置节，另一个方法GetSection则根据指定的Key得到一个具体的子配置节。当GetSection方法执行的时候，指定的参数将会与当前IConfigurationSection的Path进行组合以确定目标配置节点所在的路径，所以如果在调用该方法的时候指定一个相对于当前配置节的路径，我们是可以得到子节点以下的某个配置节。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; source = &lt;span&gt;new&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;
{
    [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;A:B:C&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ABC&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
};
            
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; root = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConfigurationBuilder()
    .AddInMemoryCollection(source)  
    .Build();

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; section1 = root.GetSection(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;A:B:C&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;A:B:C&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; section2 = root.GetSection(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;A:B&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).GetSection(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;A:C-&amp;gt;C&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; section3 = root.GetSection(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).GetSection(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;B:C&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;A-&amp;gt;B:C&lt;/span&gt;
&lt;span&gt;
Debug.Assert(section1.Value &lt;/span&gt;== &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ABC&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
Debug.Assert(section2.Value &lt;/span&gt;== &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ABC&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
Debug.Assert(section3.Value &lt;/span&gt;== &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ABC&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

Debug.Assert(&lt;/span&gt;!&lt;span&gt;ReferenceEquals(section1, section2));
Debug.Assert(&lt;/span&gt;!&lt;span&gt;ReferenceEquals(section1, section3));
Debug.Assert(&lt;/span&gt;&lt;span&gt;null&lt;/span&gt; != root.GetSection(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;D&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上面的代码片段所示，我们以不同的方式调用GetSection方法得到的都是路径为“&lt;span&gt;A:B:C&lt;/span&gt;”的IConfigurationSection对象。上面这段代码还体现了另一个有趣的现象，虽然这三个IConfigurationSection对象均指向配置树的同一个节点，但是它们却&lt;span&gt;并非同一个对象&lt;/span&gt;。换句话说，当我们调用GetSection方法的时候，不论配置树中是否存在一个与指定路径匹配的配置节，它总是会创建新的IConfigurationSection对象。&lt;/p&gt;
&lt;p&gt;IConfiguration还具有一个索引，我们可以指定子配置节的Key或者相对当前配置节点的路径得到对应IConfigurationSection的值。当这个索引执行的时候，它会按照与GetSection方法完全一致的逻辑得到一个IConfigurationSection对象，并返回其Value属性。如果配置树中不具有匹配的配置节，该索引会返回Null而不会抛出异常。&lt;/p&gt;

&lt;p&gt;在《&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-05-02.html&quot;&gt;读取配置数据[上篇]&lt;/a&gt;》介绍IConfigurationSource对象时，我们说它对原始配置源的体现。虽然每种不同类型的配置源都具有一个对应的IConfigurationSource实现，但是针对原始数据的读取并不由它来提供，而是委托一个与之对应的IConfigurationProvider对象来完成。在上面介绍的配置结构转换过程中，针对不同配置源类型的IConfigurationProvider按照如下图所示的方式实现配置从原始结构向物理结构的转换。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/19327/201912/19327-20191210080253159-1215325892.png&quot;&gt;&lt;img width=&quot;240&quot; height=&quot;182&quot; title=&quot;6-11&quot; alt=&quot;6-11&quot; src=&quot;https://img2018.cnblogs.com/blog/19327/201912/19327-20191210080253387-1545451892.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;由于IConfigurationProvider对象的目的在于将配置从原始结构转换成配置字典，所以我们会发现定义在IConfigurationProvider接口中的方法大都体现为针对&lt;span&gt;字典对象&lt;/span&gt;的相关操作。配置数据的加载通过调用IConfigurationProvider的Load方法来完成。我们可以调用TryGet方法获取由指定的Key所标识的配置项的值。从数据持久化的角度来讲，IConfigurationProvider基本上都是只读的，也就是说它只负责从持久化资源中读取配置数据，而不负责持久化更新后的配置数据，所以它提供的Set方法设置的配置数据一般只会保存在内存中，不过通过实现该方法时对提供的值进行持久化也未尝不可。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IConfigurationProvider
{    
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; Load();
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; Set(&lt;span&gt;string&lt;/span&gt; key, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; value);
    &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; TryGet(&lt;span&gt;string&lt;/span&gt; key, &lt;span&gt;out&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; value);

    IEnumerable&lt;/span&gt;&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; GetChildKeys(IEnumerable&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; earlierKeys, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; parentPath); 
    IChangeToken GetReloadToken();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;IConfigurationProvider的GetChildKeys方法用于获取某个指定配置节点（对应于parentPath参数）的所有子节点的Key。当IConfiguration的GetChildren方法被调用时，注册的所有IConfigurationSource对应的IConfigurationProvider的GetChildKeys方法会被调用。这个方法的第一个参数earlierKeys代表的Key来源于其他IConfigurationProvider，当解析出当前IConfigurationProvider提供的Key后，该方法需要对它们合并到earlierKeys集合中，合并后结果将作为方法的返回值。值得一提的是，返回的Key的集合是&lt;span&gt;经过排序&lt;/span&gt;的。&lt;/p&gt;
&lt;p&gt;每种类型的配置源都具有对应的IConfigurationProvider实现，它们一般不会直接实现接口IConfigurationProvider，而会选择继承另一个名为&lt;span&gt;ConfigurationProvider&lt;/span&gt;的抽象类。这个抽象类的定义其实很简单，从如下的代码片段可以看出它仅仅是对一个IDictionary&amp;lt;string, string&amp;gt;对象（&lt;span&gt;Key不区分大小写&lt;/span&gt;）的封装，其Set和TryGetValue方法最终操作的都是这个字典对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ConfigurationProvider : IConfigurationProvider
{
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; IDictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt; Data { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; ConfigurationProvider()=&amp;gt; Data =  &lt;span&gt;new&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;(StringComparer.OrdinalIgnoreCase);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IEnumerable&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; GetChildKeys(IEnumerable&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; earlierKeys, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; parentPath)
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; prefix = parentPath == &lt;span&gt;null&lt;/span&gt; ? &lt;span&gt;string&lt;/span&gt;.Empty : $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{parentPath}:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; ;      
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Data
            .Where(it &lt;/span&gt;=&amp;gt;&lt;span&gt; it.Key.StartsWith(prefix, StringComparison.OrdinalIgnoreCase))
            .Select(it &lt;/span&gt;=&amp;gt;&lt;span&gt; Segment(it.Key, prefix.Length))
            .Concat(earlierKeys)
            .OrderBy(it &lt;/span&gt;=&amp;gt;&lt;span&gt; it);
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Load() {}
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Set(&lt;span&gt;string&lt;/span&gt; key, &lt;span&gt;string&lt;/span&gt; value) =&amp;gt; Data[key] =&lt;span&gt; value;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; TryGet(&lt;span&gt;string&lt;/span&gt; key, &lt;span&gt;out&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; value) =&amp;gt; Data.TryGetValue(key, &lt;span&gt;out&lt;/span&gt;&lt;span&gt; value);

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Segment(&lt;span&gt;string&lt;/span&gt; key, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; prefixLength)
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; indexOf = key.IndexOf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, prefixLength, StringComparison.OrdinalIgnoreCase);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; indexOf &amp;lt; &lt;span&gt;0&lt;/span&gt; 
            ?&lt;span&gt; key.Substring(prefixLength) 
            : key.Substring(prefixLength, indexOf &lt;/span&gt;-&lt;span&gt; prefixLength);
    }
    ...
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;抽象类ConfigurationProvider实现了Load方法并将其定义成虚方法，这个方法并没有提供具体的实现，所以它的派生类可以通过重写这个方法从相应的数据源中读取配置数据，并对通过Data属性的设置完成对配置字典的初始化。&lt;/p&gt;

&lt;p&gt;IConfiurationSource在配置模型中代表配置源，它被注册到IConfigurationBuilder上为后者创建的IConfiguration提供原始的配置数据。由于针对原始配置数据的读取实现在相应的IConfigurationProvider中，所以IConfigurationSource所起的作用在于提供相应的IConfigurationProvider。如下面的代码片段所示，IConfigurationProvider接口具有一个唯一的Build方法根据指定的IConfigurationBuilder对象提供对应的IConfigurationProvider。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IConfigurationSource
{
    IConfigurationProvider Build(IConfigurationBuilder builder);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;IConfigurationBulder在整个配置模型中处于一个核心地位，代表原始配置源的IConfigurationSource也注册到它上面，它的作用就在于利用后者提供的原始数据创建出供应用程序使用的IConfiguration对象。如下面的代码片段所示，IConfigurationBulder接口定义了两个方法，其中Add方法用于注册IConfigurationSource对象，最终的IConfiguration对象则通过Build方法创建，后者返回一个代表整棵配置树的IConfigurationRoot对象。注册的IConfigurationSource被保存在通过Sources属性表示的集合中，而另一个属性Properties则以字典的形式存放任意的自定义属性。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IConfigurationBuilder
{
    IEnumerable&lt;/span&gt;&amp;lt;IConfigurationSource&amp;gt; Sources { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    Dictionary&lt;/span&gt;&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;object&lt;/span&gt;&amp;gt; Properties { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }

    IConfigurationBuilder Add(IConfigurationSource source);
    IConfigurationRoot Build();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;配置系统提供了一个名为&lt;span&gt;ConfigurationBulder&lt;/span&gt;的类作为IConfigurationBulder接口的默认实现。定义在它上面的Build方法体现了配置系统读取原始配置数据并生成配置树的默认机制。ConfigurationBulder类的Build方法返回一个类型为ConfigurationRoot的对象，对于通过该对象表示配置树来说，每个非根配置节点均是一个类型为ConfigurationSection的对象。&lt;/p&gt;
&lt;p&gt;本篇文章从设计和实现原理的角度对配置模型进行了详细的介绍。总的来说，配置模型涉及到四个核心对象，包括承载配置逻辑结构的&lt;span&gt;IConfiguration&lt;/span&gt;对象和它的创建者&lt;span&gt;IConfigurationBuilder&lt;/span&gt;，以及与配置源相关的&lt;span&gt;IConfigurationSource&lt;/span&gt;和&lt;span&gt;IConfigurationProvider&lt;/span&gt;。这四个核心对象之间的关系简单而清晰，完全可以通过一句话来概括：&lt;span&gt;IConfigurationBuilder利用注册在它上面的所有IConfigurationSource提供的IConfigurationProvider读取原始配置数据并创建出相应的IConfiguration对象&lt;/span&gt;。下图所示的UML展示了配置模型涉及的主要接口/类型以及它们之间的关系。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/19327/201912/19327-20191210080253601-199247939.png&quot;&gt;&lt;img width=&quot;430&quot; height=&quot;208&quot; title=&quot;6-12&quot; alt=&quot;6-12&quot; src=&quot;https://img2018.cnblogs.com/blog/19327/201912/19327-20191210080253822-1064417967.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-05-02.html&quot;&gt;[ASP.NET Core 3框架揭秘] 配置[1]：读取配置数据[上篇]&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-05-02.html&quot;&gt;[ASP.NET Core 3框架揭秘] 配置[2]：读取配置数据[下篇]&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-05-03.html&quot;&gt;[ASP.NET Core 3框架揭秘] 配置[3]：配置模型总体设计&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-05-04.html&quot;&gt;[ASP.NET Core 3框架揭秘] 配置[4]：将配置绑定为对象&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-05-05.html&quot;&gt;[ASP.NET Core 3框架揭秘] 配置[5]：配置数据与数据源的实时同步&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-05-06.html&quot;&gt;[ASP.NET Core 3框架揭秘] 配置[6]：多样化的配置源[上篇]&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-05-07.html&quot;&gt;[ASP.NET Core 3框架揭秘] 配置[7]：多样化的配置源[中篇]&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-05-08.html&quot;&gt;[ASP.NET Core 3框架揭秘] 配置[8]：多样化的配置源[下篇]&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-05-09.html&quot;&gt;[ASP.NET Core 3框架揭秘] 配置[9]：自定义配置源&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 10 Dec 2019 00:03:00 +0000</pubDate>
<dc:creator>Artech</dc:creator>
<og:description>在《读取配置数据》（[上篇]，[下篇]）上面一节中，我们通过实例的方式演示了几种典型的配置读取方式，接下来我们从设计的维度来重写认识配置模型。配置的编程模型涉及到三个核心对象，分别通过三个对应的接口（</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/artech/p/inside-asp-net-core-05-03.html</dc:identifier>
</item>
<item>
<title>这货到底还是不是垃圾？【垃圾回收GC算法JVM篇四】 - 宜春</title>
<link>http://www.cnblogs.com/yichunguo/p/12012841.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yichunguo/p/12012841.html</guid>
<description>&lt;p&gt;垃圾收集 Garbage Collection 通常被称为“GC”， 在jvm 中，&lt;span&gt;&lt;strong&gt;程序计数器、虚拟机栈、本地方法栈都是随线程而生随线程而灭，栈帧随着方法的进入和退出做入栈和出栈操作，实现了自动的内存清理，因此，我们的内存垃圾回收主要集中于 java 堆和方法区中&lt;/strong&gt;&lt;/span&gt;，在程序运行期间，这部分内存的分配和使用都是&lt;strong&gt;动态&lt;/strong&gt;的！&lt;/p&gt;
&lt;p&gt;@&lt;/p&gt;
&lt;p&gt;既然是垃圾回收，那肯定要知道什么是垃圾了是吧，我相信哪一天落魄java开发宜春小哥哥去捡垃圾维持生活，哈气、一juo、弯腰、开盖、倒水，一气呵成我闭着眼，把广东靓仔没喝完的快乐肥宅水错当垃圾捡了，这广东靓仔还不得打人？是的，而JVM的垃圾收集的前提就是明确啥是垃圾！JVM首先会进行一系列计数算法判断是不是垃圾。在JVM认为是否是垃圾的评判标准为对象是否存活，对象存活就不是垃圾，不能进行回收，反之进行回收。&lt;/p&gt;
&lt;h2 id=&quot;判断对象是否存活的jvm两种计数算法&quot;&gt;1、判断对象是否存活的JVM两种计数算法&lt;/h2&gt;
&lt;p&gt;判断对象是否存活的JVM两种计数算法主要有两种，分别是：引用计数、可达性分析计数算法。&lt;/p&gt;
&lt;p&gt;一听到计数算法中有“ 算法 ”二字，小白童鞋发愣了：妈呀，数学不好，完了，不学了...咳咳咳，咋们不提算法，从咋们的日常生活开始着手，在我们平时一个东西经常没被使用，而且也用不上什么地方，那么这个东西可以说就是垃圾。其实在 Java 中也是如此，如果一个对象不可能再被引用，那么这个对象就是垃圾，应该被回收。就是这么简单粗暴，JVM两种计数算法就是这样子的，真的不复杂。&lt;/p&gt;
&lt;h4 id=&quot;引用计数算法&quot;&gt;1.1、引用计数算法&lt;/h4&gt;
&lt;p&gt;根据我们生活上的思想，我们很容易想到使用引用计数的方法来判断垃圾。在一个对象被引用时加一，被去除引用时减一，这样我们就可以通过判断引用计数是否为0来判断一个对象是否为垃圾。这种方法我们一般称之为「引用计数法」。确实贼简单的一个思路也正是以为它的简单，从而存在缺陷，因此引用计数算法是这样定义的&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;1、引用计数：每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。&lt;br/&gt;2、正因方法简单，&lt;span&gt;&lt;strong&gt;从而引用计数算法无法解决对象相互循环引用的问题&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;小白童鞋可能不知道啥是对象循环引用，熊dei看图&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191209083858254.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;可达性分析计数算法&quot;&gt;1.2、可达性分析计数算法&lt;/h4&gt;
&lt;p&gt;首先声明一点：在实际开发语言比如java、C#等都是采用可达性分析计数算法判断对象是否存活！&lt;/p&gt;
&lt;p&gt;可达性分析算法的定义如下：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;可达性分析（Reachability Analysis）：从&lt;code&gt;GC Roots&lt;/code&gt;开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。不可达对象。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;相信很容易看出，其实都很好理解，唯独GC Roots有点抽象，那啥是GC Roots呢？在Java语言中，&lt;span&gt;&lt;strong&gt;GC Roots&lt;/strong&gt;&lt;/span&gt;主要包括：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;1、对象的引用，位于虚拟机栈中。&lt;br/&gt;2、方法区中的静态引用。&lt;br/&gt;3、本地方法栈中JNI的引用。【JNI一般指的是Native方法】&lt;/strong&gt;&lt;br/&gt;简单地说，GC Root 就是经过精心挑选的一些引用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191209090616696.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;像上面的循环引用的这种情况引用计数算法是无法进行GC掉的，而根搜索算法可以做到，因此引用计数算法存在缺陷！根搜索算法更好！&lt;/p&gt;
&lt;h2 id=&quot;垃圾收集算法&quot;&gt;2、垃圾收集算法&lt;/h2&gt;
&lt;p&gt;以上内容概述了啥垃圾，接下来就要讲讲如何进行回收垃圾！在生活中我们收集垃圾，可以一边走一边扫，也可以把垃圾全都扫到一起再一次清理。在JVM中，类似生活，提供了一系列的垃圾收集算法。&lt;/p&gt;
&lt;p&gt;而且我们还经常能看到垃圾分类，分成可回收垃圾，和不可回收垃圾，但是从某一意义上来讲，还都是垃圾，如果人人都遵守垃圾分类规则，我估计以后收破烂的大叔大妈都天天从可回收垃圾桶下手了，其实在JVM中也类似如此，JVM采取了分区、分代收集的思想。&lt;/p&gt;
&lt;p&gt;常见的垃圾回算法：标记清除算法、复制算法、标记整理算法、分代收集算法。&lt;/p&gt;
&lt;h4 id=&quot;标记清除算法复制算法&quot;&gt;2.1、标记清除算法复制算法&lt;/h4&gt;
&lt;p&gt;标记清除算法。从名字可以看到其分为两个阶段：&lt;span&gt;&lt;strong&gt;标记&lt;/strong&gt;&lt;/span&gt;阶段和&lt;span&gt;&lt;strong&gt;清除&lt;/strong&gt;&lt;/span&gt;阶段。一种可行的实现方式是，在标记阶段，标记所有由 GC Root 触发的可达对象。此时，所有未被标记的对象就是垃圾对象。之后在清除阶段，清除所有未被标记的对象。&lt;span&gt;&lt;strong&gt;标记清除算法最大的问题就是空间碎片问题&lt;/strong&gt;&lt;/span&gt;。如果空间碎片过多，则会导致内存空间的不连续。虽说大对象也可以分配在不连续的空间中，但是效率要低于连续的内存空间。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191209094355393.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;复制算法copying&quot;&gt;2.2、复制算法（Copying）&lt;/h4&gt;
&lt;p&gt;复制（Copying）算法。复制算法的核心思想是将原有的内存空间划分为大小相等的两块，每次只使用一块，在垃圾回收时，将正在使用的内存中的存活对象复制到未使用的内存块中。之后清除正在使用的内存块中的所有对象，之后交换两个内存块的角色，完成垃圾回收。&lt;span&gt;&lt;strong&gt;复制算法的缺点是要将内存空间折半，极大地浪费了一半内存空间。&lt;/strong&gt;&lt;/span&gt;因此现在的商业虚拟机都使用这种复制算法来进行&lt;span&gt;&lt;strong&gt;新生代&lt;/strong&gt;&lt;/span&gt;的垃圾收集！因为在&lt;strong&gt;对象存活率高的时候，复制算法就显得效率低下&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191209095425314.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191209095440707.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;标记-整理算法mark-compact&quot;&gt;2.3、标记-整理算法（Mark-Compact）&lt;/h4&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;关于标记-整理算法还有一种叫法是标记压缩算法，知道其说的同一者就好了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;标记整理算法。标记整理算法可以说是标记清除算法的优化版，其同样需要经历两个阶段，分别是：标记阶段、整理阶段。在标记阶段，从 GC Root 引用集合触发去标记所有对象，和标记清除算法中的标记阶段是一样一样的。在整理阶段，其则是将所有存活的对象整理在内存的一边，之后清理边界外的所有空间。因此，&lt;span&gt;&lt;strong&gt;标记-整理算法（Mark-Compact）不会产生内存碎片，但是会多花点时间用在整理（Compact）上面！&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191209101244295.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;分代收集算法generational-collection&quot;&gt;2.4、分代收集算法（Generational Collection）&lt;/h4&gt;
&lt;p&gt;“分代收集”（Generational Collection）算法，把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，&lt;span&gt;&lt;strong&gt;那新生代选用复制算法&lt;/strong&gt;&lt;/span&gt;，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，&lt;span&gt;&lt;strong&gt;老年代就使用“标记-清理”或“标记-整理”算法来进行回收。&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191209101924262.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;四种回收算法总结&quot;&gt;2.5、四种回收算法总结&lt;/h4&gt;
&lt;p&gt;标记清除算法&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;分为&lt;span&gt;&lt;strong&gt;标记&lt;/strong&gt;&lt;/span&gt;阶段和&lt;span&gt;&lt;strong&gt;清除&lt;/strong&gt;&lt;/span&gt;两阶段。&lt;span&gt;&lt;strong&gt;标记清除算法最大的问题就是空间碎片问题&lt;/strong&gt;&lt;/span&gt;。比较适合在存活对象比较多的情况。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;复制算法（Copying）&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;复制算法的缺点是浪费了一半内存空间。&lt;/strong&gt;&lt;/span&gt;现在的商业虚拟机都使用这种复制算法来进行&lt;span&gt;&lt;strong&gt;新生代&lt;/strong&gt;&lt;/span&gt;的垃圾收集！因为在&lt;strong&gt;对象存活率高的时候，复制算法就显得效率低下&lt;/strong&gt;比较适合存活对象比较少的情况。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;标记整理算法（Mark-Compact）&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;标记整理算法是标记清除算法的优化版，&lt;span&gt;&lt;strong&gt;标记-整理算法（Mark-Compact）不会产生内存碎片，但是会多花点时间用在整理（Compact）上面！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;分代收集算法（Generational Collection）&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;新生代选用复制算法&lt;/strong&gt;&lt;/span&gt;，&lt;span&gt;&lt;strong&gt;老年代使用“标记-清理”或“标记-整理”算法来进行回收。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;垃圾回收算法小结&quot;&gt;3、垃圾回收算法小结&lt;/h2&gt;
&lt;p&gt;借用大佬整理的一张图：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191209104051177.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果本文对你有一点点帮助，那么请点个赞呗，谢谢~&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;最后，若有不足或者不正之处，欢迎指正批评，感激不尽！如果有疑问欢迎留言，绝对第一时间回复！&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;欢迎各位关注我的公众号，里面有一些java学习资料和一大波java电子书籍，比如说周志明老师的深入java虚拟机、java编程思想、核心技术卷、大话设计模式、java并发编程实战.....都是java的圣经，不说了快上Tomcat车，咋们走！最主要的是一起探讨技术，向往技术，追求技术，说好了来了就是盆友喔...&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2019112519430061.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 10 Dec 2019 00:02:00 +0000</pubDate>
<dc:creator>宜春</dc:creator>
<og:description>垃圾收集 Garbage Collection 通常被称为“GC”， 在jvm 中， 程序计数器、虚拟机栈、本地方法栈都是随线程而生随线程而灭，栈帧随着方法的进入和退出做入栈和出栈操作，实现了自动的内</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yichunguo/p/12012841.html</dc:identifier>
</item>
<item>
<title>.Neter所应该彻底了解的委托 - RyzenAdorer</title>
<link>http://www.cnblogs.com/ryzen/p/12009602.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ryzen/p/12009602.html</guid>
<description>
&lt;p&gt;本文将通过引出几个问题来,并且通过例子来剖析C#中的委托以及用法，做抛砖引玉的作用&lt;/p&gt;
&lt;p&gt;对于委托我发现大部分人都有以下问题，或者可能在面试中遇过这样的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;委托是不是相当于C/C++的函数指针?&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;委托究竟是什么？&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;委托究竟是用来干嘛的？&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;委托跟匿名函数的区别？&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;委托与事件的关系?&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;我们先来声明和使用C++的函数指针：&lt;br/&gt;代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#include &amp;lt;iostream&amp;gt;
&lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;

typedef &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; (*Foohandle)(&lt;span&gt;int&lt;/span&gt; a,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; b);

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; fooMenthod(&lt;span&gt;int&lt;/span&gt; a, &lt;span&gt;int&lt;/span&gt; (*foohandle1)(&lt;span&gt;int&lt;/span&gt; a,&lt;span&gt;int&lt;/span&gt; b)) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;回调函数&lt;/span&gt;
&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;  return&lt;/span&gt; a + (*foohandle1)(&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;也可以写成foohandle1(2,3)&lt;/span&gt;
&lt;span&gt;}

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; add(&lt;span&gt;int&lt;/span&gt; a,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; b) {
&lt;/span&gt;&lt;span&gt;  return&lt;/span&gt; a +&lt;span&gt; b;
}

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; multiply(&lt;span&gt;int&lt;/span&gt; a, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; b) {
&lt;/span&gt;&lt;span&gt;  return&lt;/span&gt; a *&lt;span&gt; b;
}

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{
 Foohandle foohandle &lt;/span&gt;=&lt;span&gt; add;
&lt;/span&gt;&lt;span&gt; int&lt;/span&gt; (*foohandle1)(&lt;span&gt;int&lt;/span&gt; a, &lt;span&gt;int&lt;/span&gt; b) = &amp;amp;&lt;span&gt;add;
 cout &lt;/span&gt;&amp;lt;&amp;lt; foohandle(&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;)&amp;lt;&amp;lt;&lt;span&gt;endl;
 cout &lt;/span&gt;&amp;lt;&amp;lt; foohandle1(&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;) &amp;lt;&amp;lt;&lt;span&gt; endl;
 cout &lt;/span&gt;&amp;lt;&amp;lt; typeid(Foohandle).name() &amp;lt;&amp;lt;&lt;span&gt; endl;
 cout &lt;/span&gt;&amp;lt;&amp;lt; typeid(foohandle).name()&amp;lt;&amp;lt;&lt;span&gt;endl;
 cout &lt;/span&gt;&amp;lt;&amp;lt; typeid(foohandle1).name() &amp;lt;&amp;lt;&lt;span&gt; endl;
 cout &lt;/span&gt;&amp;lt;&amp;lt; fooMenthod(&lt;span&gt;2&lt;/span&gt;, add)&amp;lt;&amp;lt;&lt;span&gt;endl;
 cout &lt;/span&gt;&amp;lt;&amp;lt; fooMenthod(&lt;span&gt;2&lt;/span&gt;&lt;span&gt;, multiply);
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1294271/201912/1294271-20191209094304445-834600278.jpg&quot; alt=&quot;&quot; width=&quot;250&quot; height=&quot;150&quot;/&gt;&lt;/p&gt;





&lt;p&gt;    在代码中，我声明定义了两个函数add和multiply，然后用typedef方式声明了函数指针，接着我分别将add赋值给&lt;strong&gt;Foohandle&lt;/strong&gt;这种&lt;strong&gt;函数指针类型&lt;/strong&gt;的&lt;strong&gt;foohandle&lt;/strong&gt;变量，然后用&amp;amp;add这种解地址的方式赋值给一个返回值为int，且带有两个参数的函数指针&lt;strong&gt;foohandle1&lt;/strong&gt;，其中&lt;strong&gt;(*foohandle1)&lt;/strong&gt;是函数名，最后我输出发现它们类型和输出都是一致的，再后面，我们定义了一个fooMenthod函数，返回值是int，且其中一个参数是函数指针，那么我再最后调用两次，分别将add和multiply函数，赋值给它，这时候add和multiply就是fooMenthod函数的回调函数，且此时输出结果会被两个函数内部不同实现所影响&lt;br/&gt;那么我们可以做个总结：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先函数指针就是一个内存地址，指向函数的入口内存地址&lt;/li&gt;
&lt;li&gt;当函数指针做一个函数的参数时，确实会起到一定解耦作用&lt;/li&gt;
&lt;li&gt;函数指针很明显是类型不安全的&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们再来声明和使用委托：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;delegate&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Foohandle(&lt;span&gt;int&lt;/span&gt; a, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; b);
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
{
&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
{
 Foohandle foohandle &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Foohandle(add);
 Console.WriteLine(foohandle(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;&lt;span&gt;));
 Console.WriteLine(foohandle.GetType().Name);
 Console.WriteLine(fooMenthod(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;, add));
 Console.WriteLine(fooMenthod(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;, multiply));
 Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;foohandle所调用函数函数名:{foohandle.Method.Name}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
 Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;foohandle所调用函数的返回值类型{foohandle.Method.ReturnType.ToString()}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
 Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;foohandle所调用函数参数类型以及参数名分别为:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
 Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Type:{foohandle.Method.GetParameters()[0].ParameterType},Name:{foohandle.Method.GetParameters()[0].Name}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
 Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Type:{foohandle.Method.GetParameters()[1].ParameterType},Name:{foohandle.Method.GetParameters()[1].Name}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
 Console.Read();
}

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; fooMenthod(&lt;span&gt;int&lt;/span&gt; a, Foohandle foohandle) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;传给参数函数的就是回调函数&lt;/span&gt;
&lt;span&gt;{
&lt;/span&gt;&lt;span&gt; return&lt;/span&gt; a + foohandle(&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;&lt;span&gt;);
}

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; add(&lt;span&gt;int&lt;/span&gt; a, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; b)
{
&lt;/span&gt;&lt;span&gt; return&lt;/span&gt; a +&lt;span&gt; b;
}

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; multiply(&lt;span&gt;int&lt;/span&gt; a, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; b)
{
&lt;/span&gt;&lt;span&gt; return&lt;/span&gt; a *&lt;span&gt; b;
}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1294271/201912/1294271-20191209094656250-395201030.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;






&lt;p&gt;    很明显，不管是声明和使用方式，都和c++那边一样，就连输出结果也差不多，但是很有意思的是，foohandle的类型是Foohandle，且我居然能从foohandle输出所调函数的一切信息，包括函数名，返回值，参数类型和参数名，而且和c++那边不同的是，我们没有直接操作内存地址，好像看起来是安全的？那么Foohandle类型又是什么？&lt;/p&gt;
&lt;h2&gt;委托是啥？&lt;/h2&gt;
&lt;p&gt;先来个例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; DelegateSample
{

&lt;/span&gt;&lt;span&gt;  public&lt;/span&gt; &lt;span&gt;delegate&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; FooHandle(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; value);&lt;br/&gt;&lt;/span&gt;&lt;span&gt;  class&lt;/span&gt;&lt;span&gt; Program
  {
&lt;/span&gt;&lt;span&gt;     static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
     {
        FooHandle fooHandle &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FooHandle(multiply);
        fooHandle(&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;);
        Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fooHandle.Target:{fooHandle.Target},fooHandle.Method:{fooHandle.Method},fooHandle.InvocationListCount:{fooHandle.GetInvocationList().Count()}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-----------------------------------------------------------------------------------------------------------------------------------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        FooHandle fooHandle1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; FooHandle(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Foo().Add);
        fooHandle1.Invoke(&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;);
        Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fooHandle1.Target:{fooHandle1.Target},fooHandle1.Method:{fooHandle1.Method},fooHandle1.InvocationListCount:{fooHandle1.GetInvocationList().Count()}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        Console.Read();
     }

&lt;/span&gt;&lt;span&gt;     static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; multiply(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; a)
     {
        Console.WriteLine(a&lt;/span&gt;*&lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
     }
    }

&lt;/span&gt;&lt;span&gt;   public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foo
   {
&lt;/span&gt;&lt;span&gt;      public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Add(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; value)
      {  
        Console.WriteLine(value &lt;/span&gt;+ &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
      }
   }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们看看输出的结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1294271/201912/1294271-20191209095215675-690390457.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;     很明显，这里是一个最简单的委托声明，实例化初始化一个委托对象，然后调用的最简单的场景&lt;br/&gt;     我们不关注输出的第一行，很明显，对象实例化后，可以访问其中的三个公开public的函数成员，&lt;br/&gt;分别是Target(object类型),Method(MethodInfo类型)，而GetInvocationList函数是一个返回值为一个Delegate[]的无参函数&lt;br/&gt;     在上面代码，其实我还特地将委托FooHandle声明在Program类外面，其实在这里我们已经知道委托是什么了，实例化对象，且能够声明在类外面，其实它本质就是一个类，我们通过反编译来验证：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1294271/201912/1294271-20191209095610376-1346859375.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;






&lt;p&gt;大概是这样，伪代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FooHandle: MulticastDelegate
{
&lt;/span&gt;&lt;span&gt;  public&lt;/span&gt; FooHandle(&lt;span&gt;object&lt;/span&gt; @object,IntPtr menthod);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;构造方法&lt;/span&gt;

&lt;span&gt;  void&lt;/span&gt; Invoke(&lt;span&gt;int&lt;/span&gt; value)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用委托，编译后公共语言运行时给delegate提供的特殊方法&lt;/span&gt;

&lt;span&gt;  void&lt;/span&gt; EndInvoke(System.IAsyncResult asyncResult)&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 编译后公共语言运行时给MulticastDelegate提供的特殊方法

&lt;/span&gt;&lt;span&gt;  //&lt;/span&gt;&lt;span&gt; 编译后公共语言运行时给MulticastDelegate提供的特殊方法&lt;/span&gt;
&lt;span&gt;  void&lt;/span&gt; BeginInvoke(&lt;span&gt;int&lt;/span&gt; value,System.AsyncCallback callback, &lt;span&gt;object&lt;/span&gt;&lt;span&gt; obj) 
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;我们可以看编译后FooHandle就是一个类，且继承MulticastDelegate，且继承链关系在msdn是这样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1294271/201912/1294271-20191209095723495-1028819598.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;    且我们发现上面公开的三个函数成员都来自于Delegate类，且编译后生成了几个公共运行时提供的特殊方法，Invoke方法我们很清楚，是来调用委托的，我们先来看看委托初始化后的情况，通过查看Delegate的源码，我们发现Delegate有两个构造函数：&lt;/p&gt;
&lt;p&gt;1.委托对象初始化构造函数是实例函数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;[SecuritySafeCritical]
&lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; Delegate(&lt;span&gt;object&lt;/span&gt; target, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; method)
{
&lt;/span&gt;&lt;span&gt;  if&lt;/span&gt; (target == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
  {
&lt;/span&gt;&lt;span&gt;    throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ArgumentNullException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;target&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
  }
&lt;/span&gt;&lt;span&gt;  if&lt;/span&gt; (method == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
  {
&lt;/span&gt;&lt;span&gt;    throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ArgumentNullException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;method&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
  }
&lt;/span&gt;&lt;span&gt;  if&lt;/span&gt; (!BindToMethodName(target, (RuntimeType)target.GetType(), method, (DelegateBindingFlags)&lt;span&gt;10&lt;/span&gt;&lt;span&gt;))
  {
&lt;/span&gt;&lt;span&gt;    throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ArgumentException(Environment.GetResourceString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Arg_DlgtTargMeth&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;));
  }
}&lt;/span&gt; &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;2.委托对象初始化构造函数是静态函数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;[SecuritySafeCritical]
&lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; Delegate(Type target, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; method)
{
&lt;/span&gt;&lt;span&gt;  if&lt;/span&gt; (target == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
  {
&lt;/span&gt;&lt;span&gt;    throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ArgumentNullException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;target&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
  }
&lt;/span&gt;&lt;span&gt;  if&lt;/span&gt; (target.IsGenericType &amp;amp;&amp;amp;&lt;span&gt; target.ContainsGenericParameters)
  {
&lt;/span&gt;&lt;span&gt;    throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ArgumentException(Environment.GetResourceString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Arg_UnboundGenParam&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;), &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;target&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
  }
&lt;/span&gt;&lt;span&gt;  if&lt;/span&gt; (method == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
  {
&lt;/span&gt;&lt;span&gt;    throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ArgumentNullException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;method&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
  }
  RuntimeType runtimeType &lt;/span&gt;= target &lt;span&gt;as&lt;/span&gt;&lt;span&gt; RuntimeType;
&lt;/span&gt;&lt;span&gt;  if&lt;/span&gt; (runtimeType == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
  {
&lt;/span&gt;&lt;span&gt;    throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ArgumentException(Environment.GetResourceString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Argument_MustBeRuntimeType&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;), &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;target&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
  }
  BindToMethodName(&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;, runtimeType, method, (DelegateBindingFlags)&lt;span&gt;37&lt;/span&gt;&lt;span&gt;);
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后共同调用的方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用CLR的内部代码&lt;/span&gt;
&lt;span&gt;[MethodImpl(MethodImplOptions.InternalCall)]
[SecurityCritical]
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;extern&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; BindToMethodName(&lt;span&gt;object&lt;/span&gt; target, RuntimeType methodType, &lt;span&gt;string&lt;/span&gt; method, DelegateBindingFlags flags);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    虽然我们看不到BindToMethodName方法的实现，已经很明显了，委托对象初始化构造函数是静态函数传参进去BindToMethodName的第一个object的target参数为null，那我们大概把之前的伪代码的构造函数这么实现了：&lt;/p&gt;
&lt;p&gt;伪代码部分：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;internal&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; _target&lt;span&gt;//&lt;/span&gt;&lt;span&gt;目标对象;&lt;/span&gt;
&lt;span&gt;internal&lt;/span&gt; IntPtr _methodPtr&lt;span&gt;//&lt;/span&gt;&lt;span&gt;目标方法;&lt;/span&gt;
&lt;span&gt;internal&lt;/span&gt; IntPtr _methodPtrAux&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用来判断Target是否为空;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;foolHandle的构造方法实现：&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; FooHandle(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; @object,IntPtr menthod)
{
  _methodPtr&lt;/span&gt;=menthod;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;multiply&lt;/span&gt;
  _methodPtrAux=&lt;span&gt;1&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;只要不等于nul&lt;/span&gt;
&lt;span&gt;
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;foolHandle1的构造方法实现：&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; FooHandle(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; @object,IntPtr menthod)
{
  _methodPtr&lt;/span&gt;=menthod&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Add&lt;/span&gt;
  _methodPtrAux=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;为null&lt;/span&gt;
  _target=&lt;span&gt;foo;

}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Delegate Target属性源代码部分：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;[__DynamicallyInvokable]
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt; Target
{
  [__DynamicallyInvokable]
&lt;/span&gt;&lt;span&gt;  get&lt;/span&gt;&lt;span&gt;
  {
&lt;/span&gt;&lt;span&gt;    return&lt;/span&gt;&lt;span&gt; GetTarget();
  }
}

[SecuritySafeCritical]
&lt;/span&gt;&lt;span&gt;internal&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt; GetTarget()
{
&lt;/span&gt;&lt;span&gt;  if&lt;/span&gt; (!&lt;span&gt;_methodPtrAux.IsNull())
  {
&lt;/span&gt;&lt;span&gt;    return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
  }
&lt;/span&gt;&lt;span&gt;  return&lt;/span&gt;&lt;span&gt; _target;
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    而获取Method的方法就不展开了，就是通过反射来获取，那我们已经知道Target和Method属性究竟是怎么回事了，我们还发现没讲到GetInvocationList方法是怎么回事？我们知道委托是支持多播委托的，也就是大概这样，修改上述代码为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; DelegateSample
{
&lt;/span&gt;&lt;span&gt;   public&lt;/span&gt; &lt;span&gt;delegate&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; FooHandle(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; value);&lt;br/&gt;&lt;/span&gt;&lt;span&gt;   class&lt;/span&gt;&lt;span&gt; Program
   {
&lt;/span&gt;&lt;span&gt;      static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
      {
        FooHandle fooHandle &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FooHandle(multiply);
        fooHandle(&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;);
        Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fooHandle.Target:{fooHandle.Target},fooHandle.Method:{fooHandle.Method},fooHandle.InvocationListCount:{fooHandle.GetInvocationList().Count()}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;----------------------------------------------------------------------------------------------------------------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        FooHandle fooHandle1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; FooHandle(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Foo().Add);
        fooHandle1.Invoke(&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;);
        Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fooHandle1.Target:{fooHandle1.Target},fooHandle1.Method:{fooHandle1.Method},fooHandle1.InvocationListCount:{fooHandle1.GetInvocationList().Count()}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        Console.WriteLine();

&lt;/span&gt;
    &lt;span&gt;    &lt;strong&gt;Console.WriteLine(&quot;--------------------------------------------------新增代码------------------------------------------------------&quot;);
        FooHandle fooHandle2 = new FooHandle(new Program().Minus);
        Console.WriteLine($&quot;fooHandle2.Target:{fooHandle2.Target},fooHandle1.Method:{fooHandle2.Method},fooHandle1.InvocationListCount:{fooHandle2.GetInvocationList().Count()}&quot;);
        fooHandle2(2);
        Console.WriteLine(&quot;----------------------------------------------------------------------------------------------------------------&quot;);
        FooHandle fooHandle3 = null;
        fooHandle3 += fooHandle;
        fooHandle3 =(FooHandle)Delegate.Combine(fooHandle3,fooHandle1);//相当于fooHandle3+=fooHandle1；
        fooHandle3 += new Program().Minus;
        Console.WriteLine($&quot;fooHandle3.Target:{fooHandle3.Target},fooHandle3.Method:{fooHandle3.Method},fooHandle3.InvocationListCount:{fooHandle3.GetInvocationList().Count()}&quot;);
        fooHandle3(2);
        foreach (var result in fooHandle3.GetInvocationList())
        {
           Console.WriteLine($&quot;result.Target:{result.Target},result.Method:{result.Method},result.InvocationListCount:{result.GetInvocationList().Count()}&quot;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;);
        } 
        Console.Read();&lt;/strong&gt;&lt;/span&gt;
    }

&lt;/span&gt;
&lt;strong&gt;&lt;span&gt;   private void Minus(int a)
   {
     Console.WriteLine(a-1);
   }

&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;   static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; multiply(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; a)
   {
     Console.WriteLine(a &lt;/span&gt;* &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
   }
 }

&lt;/span&gt;&lt;span&gt; public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foo
 {
&lt;/span&gt;&lt;span&gt;    public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Add(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; value)
    {
       Console.WriteLine(value &lt;/span&gt;+ &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
    }
 }
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出结果是：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1294271/201912/1294271-20191209100840513-1817544618.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    上面新增的代码，我声明了一个新的委托变量fooHandle3初始化为null，接着分别用三种不同的方式将委托或者函数加给fooHandle，之后输出后相当于分别按序调用输出了三个方法，而我们遍历其中的fooHandle3.GetInvocationList()委托数组，输出的也确实三个方法，但是注意到了没，我在&lt;strong&gt;fooHandle3 += new Program().Minus&lt;/strong&gt;这段确实没有声明一个委托变量，我们可以注意到其中的&lt;strong&gt;(FooHandle)Delegate.Combine(fooHandle3,fooHandle1)&lt;/strong&gt;这句，Combine很明显是需要两个委托变量的，查看编译后的代码我们可以得知到底发生了啥？&lt;br/&gt;Il关键代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;fooHandle3 += fooHandle&lt;/span&gt;
IL_00f7: call &lt;span&gt;class&lt;/span&gt; [mscorlib]System.Delegate [mscorlib]System.Delegate::Combine(&lt;span&gt;class&lt;/span&gt;&lt;span&gt; [mscorlib]System.Delegate,
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; [mscorlib]System.Delegate)
IL_00fc: castclass DelegateSample.FooHandle
IL_0101: stloc.&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;
IL_0102: ldloc.&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;
IL_0103: ldloc.&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;fooHandle3 =(FooHandle)Delegate.Combine(fooHandle3,fooHandle1)&lt;/span&gt;
IL_0104: call &lt;span&gt;class&lt;/span&gt; [mscorlib]System.Delegate [mscorlib]System.Delegate::Combine(&lt;span&gt;class&lt;/span&gt;&lt;span&gt; [mscorlib]System.Delegate,
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; [mscorlib]System.Delegate)
IL_0109: castclass DelegateSample.FooHandle
IL_010e: stloc.&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;
IL_010f: ldloc.&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;new Program()&lt;/span&gt;
IL_0110: newobj instance &lt;span&gt;void&lt;/span&gt;&lt;span&gt; DelegateSample.Program::.ctor()
IL_0115: ldftn instance &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; DelegateSample.Program::Minus(int32)
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;new FooHandle()新增了一个FooHandle委托变量&lt;/span&gt;
IL_011b: newobj instance &lt;span&gt;void&lt;/span&gt; DelegateSample.FooHandle::.ctor(&lt;span&gt;object&lt;/span&gt;&lt;span&gt;,
native &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;fooHandle3 += new Program().Minus &lt;/span&gt;
IL_0120: call &lt;span&gt;class&lt;/span&gt; [mscorlib]System.Delegate [mscorlib]System.Delegate::Combine(&lt;span&gt;class&lt;/span&gt;&lt;span&gt; [mscorlib]System.Delegate,
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; [mscorlib]System.Delegate)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;     也就是三种不同方式都会被翻译为Combine方法，如果是直接&amp;lt;b&amp;gt;+=函数&amp;lt;/b&amp;gt;这种情况,后台也会new一个委托变量，将方法赋值给该变量再加到fooHandle3，那么我们可以知道，最关键的核心代码就应该是Delegate.combine这个静态方法了，我们来看看源码是怎么回事：&lt;br/&gt;Delegate类的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;[__DynamicallyInvokable]
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Delegate Combine(Delegate a, Delegate b)
{
&lt;/span&gt;&lt;span&gt;   if&lt;/span&gt; ((&lt;span&gt;object&lt;/span&gt;)a == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
   {
&lt;/span&gt;&lt;span&gt;     return&lt;/span&gt;&lt;span&gt; b;
   }
&lt;/span&gt;&lt;span&gt;   return&lt;/span&gt;&lt;span&gt; a.CombineImpl(b);
}

&lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt;&lt;span&gt; Delegate CombineImpl(Delegate d)
{
&lt;/span&gt;&lt;span&gt;   throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; MulticastNotSupportedException(Environment.GetResourceString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Multicast_Combine&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;MulticastDelegate类的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;[SecurityCritical]
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; _invocationList;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;委托链表&lt;/span&gt;
&lt;span&gt;
[SecurityCritical]
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; IntPtr _invocationCount;

[SecuritySafeCritical]
&lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;sealed&lt;/span&gt; &lt;span&gt;override&lt;/span&gt;&lt;span&gt; Delegate CombineImpl(Delegate follow)
{
&lt;/span&gt;&lt;span&gt;   if&lt;/span&gt; ((&lt;span&gt;object&lt;/span&gt;)follow == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
   {
&lt;/span&gt;&lt;span&gt;      return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
   }
&lt;/span&gt;&lt;span&gt;   if&lt;/span&gt; (!Delegate.InternalEqualTypes(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, follow))
   {
&lt;/span&gt;&lt;span&gt;     throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ArgumentException(Environment.GetResourceString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Arg_DlgtTypeMis&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
   }
   MulticastDelegate multicastDelegate &lt;/span&gt;=&lt;span&gt; (MulticastDelegate)follow;
&lt;/span&gt;&lt;span&gt;   int&lt;/span&gt; num = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;   object&lt;/span&gt;[] array = multicastDelegate._invocationList &lt;span&gt;as&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt;[];
&lt;/span&gt;&lt;span&gt;   if&lt;/span&gt; (array != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
   {
       num &lt;/span&gt;= (&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)multicastDelegate._invocationCount;
   }
&lt;/span&gt;&lt;span&gt;   object&lt;/span&gt;[] array2 = _invocationList &lt;span&gt;as&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt;[];
&lt;/span&gt;&lt;span&gt;   int&lt;/span&gt;&lt;span&gt; num2;
&lt;/span&gt;&lt;span&gt;   object&lt;/span&gt;&lt;span&gt;[] array3;
&lt;/span&gt;&lt;span&gt;   if&lt;/span&gt; (array2 == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
   {
     num2 &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt; +&lt;span&gt; num;
     array3 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt;[num2];
     array3[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;] = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;     if&lt;/span&gt; (array == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
     {
        array3[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;] =&lt;span&gt; multicastDelegate;
     }
&lt;/span&gt;&lt;span&gt;     else&lt;/span&gt;&lt;span&gt;
     {
&lt;/span&gt;&lt;span&gt;       for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; num; i++&lt;span&gt;)
       {
         array3[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt; + i] =&lt;span&gt; array[i];
       }
     }
&lt;/span&gt;&lt;span&gt;     return&lt;/span&gt;&lt;span&gt; NewMulticastDelegate(array3, num2);
    }
&lt;/span&gt;&lt;span&gt;    int&lt;/span&gt; num3 = (&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)_invocationCount;
    num2 &lt;/span&gt;= num3 +&lt;span&gt; num;
    array3 &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;    if&lt;/span&gt; (num2 &amp;lt;=&lt;span&gt; array2.Length)
    {
       array3 &lt;/span&gt;=&lt;span&gt; array2;
&lt;/span&gt;&lt;span&gt;       if&lt;/span&gt; (array == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
       {
&lt;/span&gt;&lt;span&gt;           if&lt;/span&gt; (!&lt;span&gt;TrySetSlot(array3, num3, multicastDelegate))
           {
             array3 &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
           }
       }
&lt;/span&gt;&lt;span&gt;       else&lt;/span&gt;&lt;span&gt;
       {
&lt;/span&gt;&lt;span&gt;         for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; num; j++&lt;span&gt;)
         {
&lt;/span&gt;&lt;span&gt;            if&lt;/span&gt; (!TrySetSlot(array3, num3 +&lt;span&gt; j, array[j]))
            {
               array3 &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;               break&lt;/span&gt;&lt;span&gt;;
            }
         }
       }
    }
&lt;/span&gt;&lt;span&gt;    if&lt;/span&gt; (array3 == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
    {
&lt;/span&gt;&lt;span&gt;       int&lt;/span&gt;&lt;span&gt; num4;
&lt;/span&gt;&lt;span&gt;       for&lt;/span&gt; (num4 = array2.Length; num4 &amp;lt; num2; num4 *= &lt;span&gt;2&lt;/span&gt;&lt;span&gt;)
       {
       }
       array3 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt;[num4];
&lt;/span&gt;&lt;span&gt;       for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; k = &lt;span&gt;0&lt;/span&gt;; k &amp;lt; num3; k++&lt;span&gt;)
       {
          array3[k] &lt;/span&gt;=&lt;span&gt; array2[k];
       }
&lt;/span&gt;&lt;span&gt;       if&lt;/span&gt; (array == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
       {
          array3[num3] &lt;/span&gt;=&lt;span&gt; multicastDelegate;
       }
&lt;/span&gt;&lt;span&gt;       else&lt;/span&gt;&lt;span&gt;
       {
&lt;/span&gt;&lt;span&gt;          for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; l = &lt;span&gt;0&lt;/span&gt;; l &amp;lt; num; l++&lt;span&gt;)
          {
             array3[num3 &lt;/span&gt;+ l] =&lt;span&gt; array[l];
          }
       }
     }
&lt;/span&gt;&lt;span&gt;     return&lt;/span&gt; NewMulticastDelegate(array3, num2, thisIsMultiCastAlready: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
   }&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;GetInvocationList方法的实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Delgate类的&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt;&lt;span&gt; Delegate[] GetInvocationList()
{
&lt;/span&gt;&lt;span&gt;   return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Delegate[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]
   {
&lt;/span&gt;&lt;span&gt;     this&lt;/span&gt;&lt;span&gt;
   };
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;MulticastDelegate类的&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;sealed&lt;/span&gt; &lt;span&gt;override&lt;/span&gt;&lt;span&gt; Delegate[] GetInvocationList()
{
&lt;/span&gt;&lt;span&gt;   object&lt;/span&gt;[] array = _invocationList &lt;span&gt;as&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt;[];
   Delegate[] array2;
&lt;/span&gt;&lt;span&gt;   if&lt;/span&gt; (array == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
   {
     array2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Delegate[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]
     {
&lt;/span&gt;&lt;span&gt;       this&lt;/span&gt;&lt;span&gt;
     };
   }
&lt;/span&gt;&lt;span&gt;   else&lt;/span&gt;&lt;span&gt;
   {
&lt;/span&gt;&lt;span&gt;     int&lt;/span&gt; num = (&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)_invocationCount;
     array2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Delegate[num];
&lt;/span&gt;&lt;span&gt;     for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; num; i++&lt;span&gt;)
     {
        array2[i] &lt;/span&gt;=&lt;span&gt; (Delegate)array[i];
     }
   }
&lt;/span&gt;&lt;span&gt;   return&lt;/span&gt;&lt;span&gt; array2;
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;    其实我们看到这里，就可以知道其中的一个最主要就是&lt;strong&gt;_invocationList&lt;/strong&gt;变量，也就是当调用&lt;strong&gt;Combine&lt;/strong&gt;的时候，会判断左边委托变量是否为空，如果为空，会返回右边的委托变量，不为空就会调用&lt;strong&gt;CombineImpl&lt;/strong&gt;方法，以上面那个例子来说&lt;strong&gt;fooHandle3&lt;/strong&gt;的&lt;strong&gt;_invocationList&lt;/strong&gt;存储着所有附加到委托变量，包含对象本身，也就是为啥遍历&lt;strong&gt;fooHandle3.GetInvocationList&lt;/strong&gt;，输出了三个附加到&lt;strong&gt;fooHandle3&lt;/strong&gt;变量的委托变量，这里例子&lt;strong&gt;fooHandle3&lt;/strong&gt;初始化为null，还有意思的是fooHandle3的Targt和Menthod属性是最后附加的那个委托变量的Target和Menthod，而当委托由返回值，也同理返回最后一个函数的返回值，那么&lt;strong&gt;fooHandle3&lt;/strong&gt;大概的结构如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1294271/201912/1294271-20191209102651292-185920248.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;     我们到现在只用到+=，其实-=就是调用其Delegate.Remove方法，跟Combine方法作用相反，具体就不多概述&lt;br/&gt;看到这里我们终于可以回答一开头抛出的几个问题？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;委托是不是相当于C/C++的函数指针?&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;          很明显，不是的，从数据结构来说，c++函数指针表示一块指向函数的内存地址，它其实和直接写函数名没啥区别，因为我们调用函数时的函数名，也是函数入口地址，而委托却是个类，是一块托管内存，使用Invoke后它就会被clr释放了，它的函数成员能够存储所调函数的所有信息，这是函数指针没做到的,但是在某些特殊情况下，C++的函数指针就和委托一样，有兴趣的朋友可以去看下p/invoke方面知识&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;委托是什么？&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;          委托本质是类，且支持多播委托的本质是维护一个私有的_invocationList委托链对象,+=和-=都是调用其静态方法Combine和Remove&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;委托是用来做啥的？&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;          委托和c++函数指针一样，都可以作为函数中转器，在调用者和被调用者中起解耦作用，可作为函数的参数，当回调函数&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;委托跟匿名函数的区别？&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;         我们先来声明和使用匿名函数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;delegate&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Foohandle(&lt;span&gt;int&lt;/span&gt; a, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; b);

Foohandle foohandle &lt;/span&gt;= &lt;span&gt;delegate&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; a, &lt;span&gt;int&lt;/span&gt; b) { &lt;span&gt;return&lt;/span&gt; a + b; };&lt;span&gt;//&lt;/span&gt;&lt;span&gt;匿名方法方式&lt;/span&gt;
Foohandle foohandle1= (a, b)=&amp;gt; a + b;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Lambda 表达式方式&lt;/span&gt;
&lt;span&gt;
foohandle.Invoke(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出4&lt;/span&gt;
foohandle1.Invoke(&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出4&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;我们来看下msdn是怎么定义匿名函数的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1294271/201912/1294271-20191209102926452-1511905515.jpg&quot; alt=&quot;&quot; width=&quot;854&quot; height=&quot;120&quot;/&gt;&lt;/p&gt;

&lt;p&gt;很明显，匿名函数只是个表达式，可以用来初始化委托的，而委托是个类，其实通过查看IL，后台都会实例化一个新的委托对象，并把该表达式作为函数赋给它&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;委托与事件的关系？&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; 同样的我们来声明和使用事件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foo
{
&lt;/span&gt;&lt;span&gt;   public&lt;/span&gt; &lt;span&gt;delegate&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Foohandel(&lt;span&gt;int&lt;/span&gt; a, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; b);

&lt;/span&gt;&lt;span&gt;   public&lt;/span&gt; &lt;span&gt;event&lt;/span&gt;&lt;span&gt; Foohandel foohandle;

&lt;/span&gt;&lt;span&gt;   public&lt;/span&gt;&lt;span&gt; Foo()
   {
      foohandle &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Foohandel(add);
      foohandle(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在Foo里面可以直接调用事件&lt;/span&gt;
      Console.WriteLine($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{foohandle.Target},{foohandle.Method}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
   }

&lt;/span&gt;&lt;span&gt;   public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; excute(&lt;span&gt;int&lt;/span&gt; a,&lt;span&gt;int&lt;/span&gt; b)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;公开给外部类调用事件的函数&lt;/span&gt;
&lt;span&gt;   {
      foohandle&lt;/span&gt;?&lt;span&gt;.Invoke(a,b);
   }

&lt;/span&gt;&lt;span&gt;   private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; add(&lt;span&gt;int&lt;/span&gt; a, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; b)
   {
      Console.WriteLine(a &lt;/span&gt;+&lt;span&gt; b); 
   }
}

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
{
&lt;/span&gt;&lt;span&gt;   static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
   {
      Foo foo &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Foo();
&lt;/span&gt;&lt;span&gt;      //&lt;/span&gt;&lt;span&gt;foo.foohandle = new Foo.Foohandel(multiply);编译不过，提示foo.foohandle只能出现再+=和-=左边&lt;/span&gt;
      foo.foohandle +=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Foo.Foohandel(multiply);
      foo.excute(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;); 
      Console.Read();
   }

&lt;/span&gt;&lt;span&gt;   static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; multiply(&lt;span&gt;int&lt;/span&gt; a,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; b)
   {
      Console.WriteLine(a &lt;/span&gt;*&lt;span&gt; b); 
   }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;输出结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;4&lt;/span&gt;&lt;span&gt;
EventSample.Foo,Void add(Int32, Int32)
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;     我们发现，在Foo类里面，事件foohandle就是相当于委托，但是在外部，我们再program的main函数访问它时候，我们发现foohandle只能做+=或者-=，也不能访问其函数成员Target和Menthod，而我们只能通过调用excute函数去调用，这时候我们可以知道，Event其实是基于委托的，在内部类相当于委托，在外部就只能有委托的多播功能，其余都不能访问，其实我们想到，属性是不是这样。。。有兴趣的朋友可以去了解事件的原理，也是很有趣&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;最后的最后，我们还要谈下委托的一个功能：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;委托的参数逆变和返回值的协变&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于委托也支持泛型委托，因此我们可以看看微软定义好的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;delegate&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Action&amp;lt;&lt;span&gt;in&lt;/span&gt; T&amp;gt;(T obj);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;其中in表示逆变&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;delegate&lt;/span&gt; TResult Func&amp;lt;&lt;span&gt;out&lt;/span&gt; TResult&amp;gt;();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;其中out表示协变&lt;/span&gt;

&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
{
&lt;/span&gt;&lt;span&gt;    static&lt;/span&gt; Action&amp;lt;&lt;span&gt;object&lt;/span&gt;&amp;gt;&lt;span&gt; action;
&lt;/span&gt;&lt;span&gt;    static&lt;/span&gt; Func&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt; func;
&lt;/span&gt;&lt;span&gt;    static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
    {
       action &lt;/span&gt;= (&lt;span&gt;object&lt;/span&gt; a) =&amp;gt;&lt;span&gt; { Console.WriteLine(a.ToString()); };
       Action&lt;/span&gt;&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; action1 = action;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;参数逆变&lt;/span&gt;
       action(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hello!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);


       func &lt;/span&gt;= () =&amp;gt; { &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;I am Func&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;; };
       Func&lt;/span&gt;&amp;lt;&lt;span&gt;object&lt;/span&gt;&amp;gt; func1 = func;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回值协变&lt;/span&gt;
&lt;span&gt;       Console.WriteLine(func1()); 
       Console.ReadLine();
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;输出结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
Hello!&lt;span&gt;
I am Func&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;想要了解更深的朋友可以去了解泛型的协变和逆变，在这里就不深入探讨了&lt;/p&gt;

&lt;div id=&quot;translate-man-app&quot; class=&quot;content-27EWd_0&quot;&gt;
&lt;div class=&quot;outputBox-mGAYH_0&quot; data-v-14be448c=&quot;&quot;&gt;

&lt;div class=&quot;outputBox-23yoE_0&quot; data-v-14be448c=&quot;&quot;&gt;
&lt;div class=&quot;outputBox-mOJr9_0&quot; data-v-14be448c=&quot;&quot;&gt;&lt;img class=&quot;icon-2A0TR_0&quot; src=&quot;chrome-extension://fnjoonbenhhijnoegpfkpagjamomgjjm/static/sound.svg&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;


&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;translate-man-app&quot; class=&quot;content-27EWd_0&quot;&gt;
&lt;div class=&quot;outputBox-mGAYH_0&quot; data-v-14be448c=&quot;&quot;&gt;

&lt;div class=&quot;outputBox-23yoE_0&quot; data-v-14be448c=&quot;&quot;&gt;
&lt;div class=&quot;outputBox-mOJr9_0&quot; data-v-14be448c=&quot;&quot;&gt;&lt;img class=&quot;icon-2A0TR_0&quot; src=&quot;chrome-extension://fnjoonbenhhijnoegpfkpagjamomgjjm/static/sound.svg&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;


&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;translate-man-app&quot; class=&quot;content-27EWd_0&quot;&gt;
&lt;div class=&quot;outputBox-mGAYH_0&quot; data-v-14be448c=&quot;&quot;&gt;

&lt;div class=&quot;outputBox-23yoE_0&quot; data-v-14be448c=&quot;&quot;&gt;
&lt;div class=&quot;outputBox-mOJr9_0&quot; data-v-14be448c=&quot;&quot;&gt;&lt;img class=&quot;icon-2A0TR_0&quot; src=&quot;chrome-extension://fnjoonbenhhijnoegpfkpagjamomgjjm/static/sound.svg&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;


&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;translate-man-app&quot; class=&quot;content-27EWd_0&quot;&gt;
&lt;div class=&quot;outputBox-mGAYH_0&quot; data-v-14be448c=&quot;&quot;&gt;

&lt;div class=&quot;outputBox-23yoE_0&quot; data-v-14be448c=&quot;&quot;&gt;
&lt;div class=&quot;outputBox-mOJr9_0&quot; data-v-14be448c=&quot;&quot;&gt;&lt;img class=&quot;icon-2A0TR_0&quot; src=&quot;chrome-extension://fnjoonbenhhijnoegpfkpagjamomgjjm/static/sound.svg&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;


&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;translate-man-app&quot; class=&quot;content-27EWd_0&quot;&gt;
&lt;div class=&quot;outputBox-mGAYH_0&quot; data-v-14be448c=&quot;&quot;&gt;

&lt;div class=&quot;outputBox-23yoE_0&quot; data-v-14be448c=&quot;&quot;&gt;
&lt;div class=&quot;outputBox-mOJr9_0&quot; data-v-14be448c=&quot;&quot;&gt;&lt;img class=&quot;icon-2A0TR_0&quot; src=&quot;chrome-extension://fnjoonbenhhijnoegpfkpagjamomgjjm/static/sound.svg&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;


&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;translate-man-app&quot; class=&quot;content-27EWd_0&quot;&gt;
&lt;div class=&quot;outputBox-mGAYH_0&quot; data-v-14be448c=&quot;&quot;&gt;

&lt;div class=&quot;outputBox-23yoE_0&quot; data-v-14be448c=&quot;&quot;&gt;
&lt;div class=&quot;outputBox-mOJr9_0&quot; data-v-14be448c=&quot;&quot;&gt;&lt;img class=&quot;icon-2A0TR_0&quot; src=&quot;chrome-extension://fnjoonbenhhijnoegpfkpagjamomgjjm/static/sound.svg&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;


&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;translate-man-app&quot; class=&quot;content-27EWd_0&quot;&gt;
&lt;div class=&quot;outputBox-mGAYH_0&quot; data-v-14be448c=&quot;&quot;&gt;

&lt;div class=&quot;outputBox-23yoE_0&quot; data-v-14be448c=&quot;&quot;&gt;
&lt;div class=&quot;outputBox-mOJr9_0&quot; data-v-14be448c=&quot;&quot;&gt;&lt;img class=&quot;icon-2A0TR_0&quot; src=&quot;chrome-extension://fnjoonbenhhijnoegpfkpagjamomgjjm/static/sound.svg&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;


&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;translate-man-app&quot; class=&quot;content-27EWd_0&quot;&gt;
&lt;div class=&quot;outputBox-mGAYH_0&quot; data-v-14be448c=&quot;&quot;&gt;

&lt;div class=&quot;outputBox-23yoE_0&quot; data-v-14be448c=&quot;&quot;&gt;
&lt;div class=&quot;outputBox-mOJr9_0&quot; data-v-14be448c=&quot;&quot;&gt;&lt;img class=&quot;icon-2A0TR_0&quot; src=&quot;chrome-extension://fnjoonbenhhijnoegpfkpagjamomgjjm/static/sound.svg&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;


&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;translate-man-app&quot; class=&quot;content-27EWd_0&quot;&gt;
&lt;div class=&quot;outputBox-mGAYH_0&quot; data-v-14be448c=&quot;&quot;&gt;

&lt;div class=&quot;outputBox-23yoE_0&quot; data-v-14be448c=&quot;&quot;&gt;
&lt;div class=&quot;outputBox-mOJr9_0&quot; data-v-14be448c=&quot;&quot;&gt;&lt;img class=&quot;icon-2A0TR_0&quot; src=&quot;chrome-extension://fnjoonbenhhijnoegpfkpagjamomgjjm/static/sound.svg&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;


&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;translate-man-app&quot; class=&quot;content-27EWd_0&quot;&gt;
&lt;div class=&quot;outputBox-mGAYH_0&quot; data-v-14be448c=&quot;&quot;&gt;

&lt;div class=&quot;outputBox-23yoE_0&quot; data-v-14be448c=&quot;&quot;&gt;
&lt;div class=&quot;outputBox-mOJr9_0&quot; data-v-14be448c=&quot;&quot;&gt;&lt;img class=&quot;icon-2A0TR_0&quot; src=&quot;chrome-extension://fnjoonbenhhijnoegpfkpagjamomgjjm/static/sound.svg&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;


&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;translate-man-app&quot; class=&quot;content-27EWd_0&quot;&gt;
&lt;div class=&quot;outputBox-mGAYH_0&quot; data-v-14be448c=&quot;&quot;&gt;

&lt;div class=&quot;outputBox-23yoE_0&quot; data-v-14be448c=&quot;&quot;&gt;
&lt;div class=&quot;outputBox-mOJr9_0&quot; data-v-14be448c=&quot;&quot;&gt;&lt;img class=&quot;icon-2A0TR_0&quot; src=&quot;chrome-extension://fnjoonbenhhijnoegpfkpagjamomgjjm/static/sound.svg&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;


&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;translate-man-app&quot; class=&quot;content-27EWd_0&quot;&gt;
&lt;div class=&quot;outputBox-mGAYH_0&quot; data-v-14be448c=&quot;&quot;&gt;

&lt;div class=&quot;outputBox-23yoE_0&quot; data-v-14be448c=&quot;&quot;&gt;
&lt;div class=&quot;outputBox-mOJr9_0&quot; data-v-14be448c=&quot;&quot;&gt;&lt;img class=&quot;icon-2A0TR_0&quot; src=&quot;chrome-extension://fnjoonbenhhijnoegpfkpagjamomgjjm/static/sound.svg&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;


&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;translate-man-app&quot; class=&quot;content-27EWd_0&quot;&gt;
&lt;div class=&quot;outputBox-mGAYH_0&quot; data-v-14be448c=&quot;&quot;&gt;

&lt;div class=&quot;outputBox-23yoE_0&quot; data-v-14be448c=&quot;&quot;&gt;
&lt;div class=&quot;outputBox-mOJr9_0&quot; data-v-14be448c=&quot;&quot;&gt;&lt;img class=&quot;icon-2A0TR_0&quot; src=&quot;chrome-extension://fnjoonbenhhijnoegpfkpagjamomgjjm/static/sound.svg&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;


&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Mon, 09 Dec 2019 23:18:00 +0000</pubDate>
<dc:creator>RyzenAdorer</dc:creator>
<og:description>本文将通过引出几个问题来,并且通过例子来剖析C#中的委托以及用法，做抛砖引玉的作用 对于委托我发现大部分人都有以下问题，或者可能在面试中遇过这样的： 委托是不是相当于C/C++的函数指针? 委托究竟是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ryzen/p/12009602.html</dc:identifier>
</item>
<item>
<title>Spring Security OAuth2 Demo —— 授权码模式 - 东北小狐狸</title>
<link>http://www.cnblogs.com/hellxz/p/oauth2_oauthcode_pattern.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hellxz/p/oauth2_oauthcode_pattern.html</guid>
<description>&lt;p&gt;本文可以转载，但请注明出处https://www.cnblogs.com/hellxz/p/oauth2_oauthcode_pattern.html&lt;/p&gt;
&lt;h2 id=&quot;写在前边&quot;&gt;写在前边&lt;/h2&gt;
&lt;p&gt;在文章&lt;a href=&quot;https://www.cnblogs.com/hellxz/p/oauth2_process.html&quot;&gt;OAuth 2.0 概念及授权流程梳理&lt;/a&gt; 中我们谈到OAuth 2.0的概念与流程，这里我准备分别记一记这几种授权模式的demo，一方面为自己的最近的学习做个总结，另一方面做下知识输出，如果文中有错误的地方，请评论指正，在此不胜感激&lt;/p&gt;
&lt;h2 id=&quot;受众前提&quot;&gt;受众前提&lt;/h2&gt;
&lt;p&gt;阅读本文，默认读者已经过Spring Security有一定的了解，对OAuth2流程有一定了解&lt;/p&gt;
&lt;h2 id=&quot;本文目标&quot;&gt;本文目标&lt;/h2&gt;
&lt;p&gt;带领读者对Spring Security OAuth2框架的授权码模式有一个比较直观的概念，能使用框架搭建授权码模式授权服务器与资源服务器（分离版本）&lt;/p&gt;
&lt;h2 id=&quot;授权码模式流程回顾&quot;&gt;授权码模式流程回顾&lt;/h2&gt;
&lt;p&gt;授权码模式要求：用户登录并对第三方应用（客户端）进行授权，出示授权码交给客户端，客户端凭授权码换取access_token（访问凭证）&lt;/p&gt;
&lt;p&gt;此模式要求授权服务器与用户直接交互，在此过程中，第三方应用是无法获取到用户输入的密码等信息的，这个模式也是OAuth 2.0中最安全的一个&lt;/p&gt;
&lt;h2 id=&quot;demo基本结构&quot;&gt;Demo基本结构&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1149398/201912/1149398-20191210000208462-1452434943.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里主要关注&lt;code&gt;authorization-code-authorization-server&lt;/code&gt;与&lt;code&gt;authorization-code-resource-server&lt;/code&gt;这两个模块&lt;/p&gt;
&lt;p&gt;本文以及后续文章的demo均放在GitHub上，欢迎大家Star &amp;amp; Fork，源码地址：https://github.com/hellxz/spring-security-oauth2-learn&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;code&gt;authorization-code-client-resttemplate-jdbc&lt;/code&gt;这个项目是用来测试非OAuth2服务使用RestTemplate与JdbcTemplate对接OAuth2授权服务的，流程这里不讲，有兴趣可以debug看看，可能会让您对整个流程会有更清晰的感受&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;搭建授权服务器authorization-server&quot;&gt;搭建授权服务器（Authorization Server）&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;文中服务器均使用demo级别配置，请勿直接使用到生产环境&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;授权服务器结构主体如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1149398/201912/1149398-20191210001707757-1465565588.png&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;启动类自不多说，先说下SecurityConfig&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.github.hellxz.oauth2.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;

import java.util.Collections;

@Configuration
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    @Bean
    public PasswordEncoder passwordEncoder(){
        return new BCryptPasswordEncoder();
    }

    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        // @formatter: off
        auth.inMemoryAuthentication()
                .withUser(&quot;hellxz&quot;)
                .password(passwordEncoder().encode(&quot;xyz&quot;))
                .authorities(Collections.emptyList());
        // @formatter: on
    }

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.authorizeRequests()
                .anyRequest().authenticated() //所有请求都需要通过认证
                .and()
                .httpBasic() //Basic登录
                .and()
                .csrf().disable(); //关跨域保护
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过&lt;code&gt;@Configuration&lt;/code&gt; 和&lt;code&gt;@EnableWebSecurity&lt;/code&gt;开启Spring Security配置，继承&lt;code&gt;WebSecurityConfigurerAdapter&lt;/code&gt;的方法，实现个性化配置，这里我们使用内存保存一个名为&lt;code&gt;hellxz&lt;/code&gt;、密码为&lt;code&gt;xyz&lt;/code&gt;的用户，与授权服务器交互的用户就是他了&lt;/p&gt;
&lt;p&gt;除了配置用户，我们需要对服务的资源进行保护，这里将所有的请求都要求通过认证才可以访问，用户登录需要使用httpBasic形式（就是那种网页弹个窗要求登录的那种😄）&lt;/p&gt;
&lt;p&gt;Spring Security 5.x版本后，要求显示声明使用的密码器，就是&lt;code&gt;PasswordEncoder&lt;/code&gt;了，常用&lt;code&gt;BCryptPasswordEncoder&lt;/code&gt;，简单的可以认为它是使用时间戳和盐进行加密的一种算法，同一个密码被加密后也不会相同&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;接着看看&lt;code&gt;授权服务器的配置&lt;/code&gt;，&lt;strong&gt;画重点&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.github.hellxz.oauth2.config;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.oauth2.config.annotation.configurers.ClientDetailsServiceConfigurer;
import org.springframework.security.oauth2.config.annotation.web.configuration.AuthorizationServerConfigurerAdapter;
import org.springframework.security.oauth2.config.annotation.web.configuration.EnableAuthorizationServer;
import org.springframework.security.oauth2.config.annotation.web.configurers.AuthorizationServerSecurityConfigurer;

//授权服务器配置
@Configuration
@EnableAuthorizationServer //开启授权服务
public class AuthorizationConfig extends AuthorizationServerConfigurerAdapter {

    @Autowired
    private PasswordEncoder passwordEncoder;

    @Override
    public void configure(AuthorizationServerSecurityConfigurer security) throws Exception {
        //允许表单提交
        security.allowFormAuthenticationForClients()
                .checkTokenAccess(&quot;isAuthenticated()&quot;);
    }

    @Override
    public void configure(ClientDetailsServiceConfigurer clients) throws Exception {
        // @formatter: off
        clients.inMemory()
                .withClient(&quot;client-a&quot;) //client端唯一标识
                    .secret(passwordEncoder.encode(&quot;client-a-secret&quot;)) //客户端的密码，这里的密码应该是加密后的
                    .authorizedGrantTypes(&quot;authorization_code&quot;) //授权模式标识
                    .scopes(&quot;read_user_info&quot;) //作用域
                    .resourceIds(&quot;resource1&quot;) //资源id
                    .redirectUris(&quot;http://localhost:9001/callback&quot;); //回调地址
        // @formatter: on
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;1.通过&lt;code&gt;@Configuration&lt;/code&gt; 和&lt;code&gt;EnableAuthorizationServer&lt;/code&gt;开启授权服务器配置，通过重写&lt;code&gt;AuthorizationServerConfigurerAdapter&lt;/code&gt;的方法来完成自定义授权服务器&lt;/p&gt;
&lt;p&gt;2.OAuth2授权码模式中，要求不仅仅用户需要登录，还要求客户端也需要登录，这里就需要在&lt;code&gt;configure(ClientDetailsServiceConfigurer clients)&lt;/code&gt;这个方法中配置客户端（第三方应用）的登录信息，&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;withClient&lt;/code&gt;中配置的是客户端id（client_id）&lt;/li&gt;
&lt;li&gt;secret为客户端的密码，要求使用加密器进行加密&lt;/li&gt;
&lt;li&gt;授权码的authorizedGrantTypes必须配置有&lt;code&gt;&quot;authorization_code&quot;&lt;/code&gt;（授权码模式），这里是可以同时支持多种授权模式的，为了简单只写一个&lt;/li&gt;
&lt;li&gt;scopes，请求资源作用域，用于限制客户端与用户无法访问没有作用域的资源&lt;/li&gt;
&lt;li&gt;resourceIds，可选，资源id，可以对应一个资源服务器，个人理解为某个资源服务器的所有资源标识&lt;/li&gt;
&lt;li&gt;redirectUris，回调地址，有两个作用：1.回调客户端地址，返回授权码； 2.校验是否是同一个客户端&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;redirectUris校验是否同一个客户端这个，可能说的不是很准确，说下大体流程，我们在授权服务器上配置了这个回调地址，授权服务器在用户授权成功后，返回授权码的地址就是它，另外我们后续申请token时，也需要传递这个回调地址，所以我的理解是校验是否是同一客户端发来的第二次请求（换token时）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;3.&lt;code&gt;configure(AuthorizationServerSecurityConfigurer security)&lt;/code&gt;这里配置资源客户端（第三方应用）的表单提交权限，类似Spring Security配置的&lt;code&gt;permitAll()&lt;/code&gt;等权限控制标识，如果不配置，客户端将无法换取token&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;4.&lt;code&gt;application.properties&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这里我只配置了server.port=8080&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;这样我们就配置了相当简易的授权服务器，&lt;strong&gt;启动测试&lt;/strong&gt;下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1149398/201912/1149398-20191210004929547-1940346821.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;获取授权码的流程&lt;/strong&gt;，&lt;strong&gt;一般是由客户端使用自己的client_id与密码+response_type=code拼接url，让浏览器跳转完成的，用户的登录与授权过程都需要在浏览器中完成&lt;/strong&gt;，启动项目后访问下列url&lt;/p&gt;
&lt;p&gt;http://localhost:8080/oauth/authorize?client_id=client-a&amp;amp;client_secret=client-a-secret&amp;amp;response_type=code&lt;/p&gt;
&lt;p&gt;登录用户/密码： hellxz/xyz ，选择Approve表示接受授权，Deny反之，如下动图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1149398/201912/1149398-20191210005428567-362114296.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后我们得到了回调地址http://localhost:9001/callback?code=2e6450&lt;/p&gt;
&lt;p&gt;这里的&lt;strong&gt;code就是授权码&lt;/strong&gt;，接下来我们&lt;strong&gt;使用授权码进行换取token&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;POST请求，http://localhost:8080/oauth/token，参数如图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1149398/201912/1149398-20191210010038481-1142111364.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;BasicAuth：这里填的是客户端配置的client_id和client_secret的值，相当于&lt;code&gt;curl --user client_id:client_secret&lt;/code&gt;，配置后会在Header中添加&lt;code&gt;Authorization:Basic Y2xpZW50LWE6Y2xpZW50LWEtc2VjcmV0&lt;/code&gt;，&lt;code&gt;Basic空格&lt;/code&gt;后的是&lt;code&gt;client_id:client_secret&lt;/code&gt;具体值被Base64后得到的值&lt;/p&gt;
&lt;p&gt;请求参数列表：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;code=授权码&lt;/li&gt;
&lt;li&gt;grant_type=authorization_code&lt;/li&gt;
&lt;li&gt;redirect_uri=回调url ，要与配置处和获取授权码处相同&lt;/li&gt;
&lt;li&gt;scope=作用域&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;最后我们获得了授权服务的响应，包含token的json&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
    &quot;access_token&quot;: &quot;99435e13-f9fe-438a-a94e-3b00d549b329&quot;, //访问token
    &quot;token_type&quot;: &quot;bearer&quot;, //token类型，使用时需要拼接在token前并在token前加空格
    &quot;expires_in&quot;: 43199, //过期时间
    &quot;scope&quot;: &quot;read_user_info&quot; //作用域
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在access_token未过期之前，同一个用户名使用同一个客户端访问都会是同一个access_token&lt;/p&gt;
&lt;p&gt;授权服务器先放在这里，不要关服，接下来搭建资源服务器&lt;/p&gt;
&lt;h2 id=&quot;搭建资源服务器resource-server&quot;&gt;搭建资源服务器（Resource Server）&lt;/h2&gt;
&lt;p&gt;资源服务器结构&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1149398/201912/1149398-20191210011312530-1739016675.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;入口类不多说，先搭建资源服务器主要配置，这里直接使用&lt;code&gt;ResourceConfig&lt;/code&gt;进行配置&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.github.hellxz.oauth2.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.oauth2.config.annotation.web.configuration.EnableResourceServer;
import org.springframework.security.oauth2.config.annotation.web.configuration.ResourceServerConfigurerAdapter;
import org.springframework.security.oauth2.config.annotation.web.configurers.ResourceServerSecurityConfigurer;
import org.springframework.security.oauth2.provider.token.RemoteTokenServices;

@Configuration
@EnableResourceServer
public class ResourceConfig extends ResourceServerConfigurerAdapter {

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Primary
    @Bean
    public RemoteTokenServices remoteTokenServices() {
        final RemoteTokenServices tokenServices = new RemoteTokenServices();
        //设置授权服务器check_token端点完整地址
        tokenServices.setCheckTokenEndpointUrl(&quot;http://localhost:8080/oauth/check_token&quot;);
        //设置客户端id与secret，注意：client_secret值不能使用passwordEncoder加密！
        tokenServices.setClientId(&quot;client-a&quot;);
        tokenServices.setClientSecret(&quot;client-a-secret&quot;);
        return tokenServices;
    }

    @Override
    public void configure(HttpSecurity http) throws Exception {
        //设置创建session策略
        http.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.IF_REQUIRED);
        //@formatter:off
        //所有请求必须授权
        http.authorizeRequests()
                .anyRequest().authenticated();
        //@formatter:on
    }

    @Override
    public void configure(ResourceServerSecurityConfigurer resources) {
        resources.resourceId(&quot;resource1&quot;).stateless(true);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;1.通过&lt;code&gt;@Configuration&lt;/code&gt; 和&lt;code&gt;@EnableResourceServer&lt;/code&gt;这两个注解标识服务是一个资源服务器，重写&lt;code&gt;ResourceServerConfigurerAdapter&lt;/code&gt;来实现自定义授权服务器&lt;/p&gt;
&lt;p&gt;2.配置&lt;code&gt;configure(HttpSecurity http)&lt;/code&gt;方法，这里可以代替Spring Security同名方法配置，开启所有请求需要授权才可访问&lt;/p&gt;
&lt;p&gt;3.配置资源相关设置&lt;code&gt;configure(ResourceServerSecurityConfigurer resources)&lt;/code&gt;，这里只设置&lt;code&gt;resourceId&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;后续的使用redis校验token也在这里设置&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;4.校验token的配置，这里使用了远程调用授权服务器帮忙校验token的方式，只需要显示注入&lt;code&gt;RemoteTokenServices remoteTokenServices()&lt;/code&gt;的Bean，就可以调用授权服务器的/oauth/check_token端点，设置客户端配置的值，详见注释&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;这样一来我们就配置好了资源服务器，当然光有配置是不够的，我们搞一个资源接口做测试用&lt;/p&gt;
&lt;p&gt;上边的&lt;code&gt;ResourceController&lt;/code&gt;与&lt;code&gt;UserVO&lt;/code&gt;都比较简单，传入一个名称，返回用户对象，包含用户名和邮箱信息&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.github.hellxz.oauth2.web.controller;

import com.github.hellxz.oauth2.web.vo.UserVO;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class ResourceController {

    @GetMapping(&quot;/user/{username}&quot;)
    public UserVO user(@PathVariable String username){
        return new UserVO(username, username + &quot;@foxmail.com&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.github.hellxz.oauth2.web.vo;

public class UserVO {
    private String username;
    private String email;

    public UserVO(String username, String email) {
        this.username = username;
        this.email = email;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;p&gt;application.properties中配置了与授权服务器不同的端口：8081&lt;/p&gt;
&lt;p&gt;&lt;code&gt;server.port=8081&lt;/code&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;启动资源服务测试&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;什么也不传，直接访问接口，提示资源需要授权&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1149398/201912/1149398-20191210014057951-148574571.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;复制之前获取到的token，添加token访问接口http://localhost:8081/user/hellxz001&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1149398/201912/1149398-20191210014620492-1965215545.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Bearer Token相当于在Headers中添加&lt;code&gt;Authorization：Bearer空格access_token&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;至此我们成功的搭建并测试了授权码模式下的最简单的授权服务与资源服务分离的demo&lt;/p&gt;
&lt;h2 id=&quot;尾声&quot;&gt;尾声&lt;/h2&gt;
&lt;p&gt;授权码模式就先在这里告一段落，写的比较基础，自认为该说到的点都说到了，后续还会写其它模式的文章，如文中有何遗漏，请不吝评论反馈，本人会尽快改正，谢谢&lt;/p&gt;
&lt;p&gt;本文以及后续文章的demo均放在GitHub上，欢迎大家Star &amp;amp; Fork，源码地址：https://github.com/hellxz/spring-security-oauth2-learn ，Demo中的README文档写得比较详细，也可堪一看&lt;/p&gt;
&lt;p&gt;本文可以转载，但请注明出处https://www.cnblogs.com/hellxz/p/oauth2_oauthcode_pattern.html&lt;/p&gt;
</description>
<pubDate>Mon, 09 Dec 2019 18:01:00 +0000</pubDate>
<dc:creator>东北小狐狸</dc:creator>
<og:description>本文可以转载，但请注明出处https://www.cnblogs.com/hellxz/p/oauth2_oauthcode_pattern.html 写在前边 在文章 'OAuth 2.0 概念及授</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/hellxz/p/oauth2_oauthcode_pattern.html</dc:identifier>
</item>
<item>
<title>小白的springboot之路（八）、继承Redis以及@Cacheable注解实现Redis缓存 - 烧麦</title>
<link>http://www.cnblogs.com/yanghj/p/12014409.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yanghj/p/12014409.html</guid>
<description>&lt;h2&gt;0、前言&lt;/h2&gt;
&lt;p&gt;　　在项目中，缓存作为一种高效的提升性能的手段，几乎必不可少，Redis作为其中的佼佼者被广泛应用；&lt;/p&gt;

&lt;h3&gt;1、添加依赖&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-data-redis&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2、配置文件增加Redis配置&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;####### Redis ################
#第几个数据库，由于redis中数据库不止一个（默认会开启15个）
spring.redis.database&lt;/span&gt;=1&lt;span&gt;
# 也可指定为127.&lt;/span&gt;0.0.1&lt;span&gt;
spring.redis.host&lt;/span&gt;=&lt;span&gt;localhost
spring.redis.port&lt;/span&gt;=6379&lt;span&gt;
spring.redis.password&lt;/span&gt;=88888888&lt;span&gt;

# springboot2.x以上如此配置，由于2.x的客户端是lettuce
# 单位要带上
spring.redis.lettuce.pool.max&lt;/span&gt;-active=8&lt;span&gt;
spring.redis.lettuce.pool.min&lt;/span&gt;-idle=0&lt;span&gt;
spring.redis.lettuce.pool.max&lt;/span&gt;-idle=8&lt;span&gt;
spring.redis.lettuce.pool.max&lt;/span&gt;-wait=&lt;span&gt;10000ms
spring.redis.lettuce.shutdown&lt;/span&gt;-timeout=&lt;span&gt;100ms

# springboot1.x如此配置，由于1.x的客户端是jedis
#spring.redis.jedis.pool.max&lt;/span&gt;-active=8&lt;span&gt;
#spring.redis.jedis.pool.min&lt;/span&gt;-idle=0&lt;span&gt;
#spring.redis.jedis.pool.max&lt;/span&gt;-idle=8&lt;span&gt;
#spring.redis.jedis.pool.max&lt;/span&gt;-wait=-1&lt;span&gt;
#spring.redis.timeout&lt;/span&gt;=500
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3、使用&lt;/h3&gt;
&lt;p&gt;　　这样就集成进来了，就可以使用了，&lt;strong&gt;有两种template可以直接使用，RedisTemplate和StringRedisTemplate&lt;/strong&gt;，&lt;strong&gt;有opsForValue、opsForList、opsForSet、opsForZset、opsForHash&lt;/strong&gt;几种访问方法，简单示例如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;   @Resource
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; RedisTemplate redisTemplate; 

   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 写入缓存&lt;/span&gt;
   redisTemplate.opsForValue().set(&quot;111&quot;,&quot;anson&quot;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;读取缓存&lt;/span&gt;
   String str = redisTemplate.opsForValue().get(&quot;111&quot;).toString();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行后可以查看到缓存中已经写入，读取也正常读取出来&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/118906/201912/118906-20191210001021692-1760491000.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/118906/201912/118906-20191210001127865-895676474.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h2&gt;4、总结：&lt;/h2&gt;
&lt;h3&gt;　　可以看到，写入Redis的是经过转码的，不方便查看，一般我们在使用的时候，会替换掉它默认的解析器，并且将相关操作封装成工具类方便使用；通常Redis我们是作为缓存服务器来使用，实际项目中，缓存有两种方式，一种是手动的方式：就是像上面的方式，将Redis的解析器替换，然后封装工具类；在使用的地方，先判断缓存中时候有需要的数据，没有的换就从数据库中去取，然后写入Redis缓存，有的话就直接从Redis缓存取；手动的方式虽然有时候更灵活，但是每个方法都需要写一堆代码，很累赘，基本上我们是不会用这种方式的，所以上面的方式只是简单介绍，什么封装工具类啊那些都没贴代码出来，想用这种方式的自己去百度，一大堆；&lt;/h3&gt;
&lt;h3&gt;　　缓存的第二种方式就是配合注解实现缓存，方便，只需要在需要缓存的方法上加上注解即可，实际项目中，基本都是使用这种方式，下面介绍&lt;/h3&gt;

&lt;h2&gt;1、添加依赖&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;!--4、集成redis --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.apache.commons&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;commons-pool2&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;2.4.2&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;!-- redis依赖，2.0以上使用这个依赖 --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-data-redis&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;!-- 缓存依赖 --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-cache&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;2、配置文件中增加配置&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;####### Redis ################
#第几个数据库，由于redis中数据库不止一个
spring.redis.database&lt;/span&gt;=1&lt;span&gt;
# 也可指定为127.&lt;/span&gt;0.0.1&lt;span&gt;
spring.redis.host&lt;/span&gt;=&lt;span&gt;localhost
spring.redis.port&lt;/span&gt;=6379&lt;span&gt;
spring.redis.password&lt;/span&gt;=88888888&lt;span&gt;

# springboot2.x以上如此配置，由于2.x的客户端是lettuce
# 单位要带上
spring.redis.lettuce.pool.max&lt;/span&gt;-active=8&lt;span&gt;
spring.redis.lettuce.pool.min&lt;/span&gt;-idle=0&lt;span&gt;
spring.redis.lettuce.pool.max&lt;/span&gt;-idle=8&lt;span&gt;
spring.redis.lettuce.pool.max&lt;/span&gt;-wait=&lt;span&gt;10000ms
spring.redis.lettuce.shutdown&lt;/span&gt;-timeout=&lt;span&gt;100ms

# springboot1.x如此配置，由于1.x的客户端是jedis
#spring.redis.jedis.pool.max&lt;/span&gt;-active=8&lt;span&gt;
#spring.redis.jedis.pool.min&lt;/span&gt;-idle=0&lt;span&gt;
#spring.redis.jedis.pool.max&lt;/span&gt;-idle=8&lt;span&gt;
#spring.redis.jedis.pool.max&lt;/span&gt;-wait=-1&lt;span&gt;
#spring.redis.timeout&lt;/span&gt;=500
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;3、实现自定义缓存管理器&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.anson.config;


&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.slf4j.Logger;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.slf4j.LoggerFactory;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cache.annotation.CachingConfigurerSupport;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cache.annotation.EnableCaching;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cache.interceptor.KeyGenerator;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.Bean;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.Configuration;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.data.redis.cache.RedisCacheConfiguration;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.data.redis.cache.RedisCacheManager;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.data.redis.connection.RedisConnectionFactory;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt; org.springframework.data.redis.serializer.*&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.time.Duration;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * @description: redis缓存配置类
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt;: anson
 * @Date: 2019/12/8 21:34
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

@Configuration
@EnableCaching
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; RedisCacheConfig &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; CachingConfigurerSupport {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Logger logger = LoggerFactory.getLogger(RedisCacheConfig.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 自定义key生成器&lt;/span&gt;
&lt;span&gt;    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; KeyGenerator keyGenerator(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (o, method, params) -&amp;gt;&lt;span&gt;{
            StringBuilder sb &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringBuilder();
            sb.append(o.getClass().getName()); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 类目&lt;/span&gt;
            sb.append(method.getName()); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 方法名&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt;&lt;span&gt;(Object param: params){
                sb.append(param.toString()); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 参数名&lt;/span&gt;
&lt;span&gt;            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; sb.toString();
        };
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 配置缓存管理器&lt;/span&gt;
&lt;span&gt;    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; RedisCacheManager cacheManager(RedisConnectionFactory connectionFactory) {
        RedisCacheConfiguration config &lt;/span&gt;=&lt;span&gt; RedisCacheConfiguration.defaultCacheConfig()
                .entryTtl(Duration.ofSeconds(&lt;/span&gt;60000000)) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 60s缓存失效
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置key的序列化方式&lt;/span&gt;
&lt;span&gt;                .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(keySerializer()))
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置value的序列化方式&lt;/span&gt;
&lt;span&gt;                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(valueSerializer()))
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 不缓存null值&lt;/span&gt;
&lt;span&gt;                .disableCachingNullValues();

        RedisCacheManager redisCacheManager &lt;/span&gt;=&lt;span&gt; RedisCacheManager.builder(connectionFactory)
                .cacheDefaults(config)
                .transactionAware()
                .build();

        logger.info(&lt;/span&gt;&quot;自定义RedisCacheManager加载完成&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; redisCacheManager;
    }


    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; key键序列化方式&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; RedisSerializer&amp;lt;String&amp;gt;&lt;span&gt; keySerializer() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringRedisSerializer();
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; value值序列化方式&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; GenericJackson2JsonRedisSerializer valueSerializer(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; GenericJackson2JsonRedisSerializer();
       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; return  new GenericFastJsonRedisSerializer();&lt;/span&gt;
&lt;span&gt;    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;4、使用：可以直接使用了，在UserServiceImpl中&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @Override
    @Cacheable(cacheNames &lt;/span&gt;= &quot;user&quot; ,key=&quot;#id&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; User selectByPrimaryKey(Integer id)
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;  usermapper.selectByPrimaryKey(id);
    }

    @Override
    @Cacheable(cacheNames &lt;/span&gt;= &quot;users&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;User&amp;gt;&lt;span&gt; getAll()
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; usermapper.getAll();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　其中，key如果不设置，会根据我们设置的生成器生成KEY，如果自己设置的话，有几种方式，下面介绍一下：&lt;/h3&gt;
&lt;div readability=&quot;15.5&quot;&gt;
&lt;div readability=&quot;26&quot;&gt;
&lt;h3&gt;A、基本形式&lt;/h3&gt;
&lt;p&gt;@Cacheable(value=&quot;cacheName&quot;, key&quot;#id&quot;)&lt;/p&gt;
&lt;p&gt;public User method(int id);&lt;/p&gt;
&lt;h3&gt;B、组合形式&lt;/h3&gt;
&lt;p&gt;@Cacheable(value=&quot;cacheName&quot;, key&quot;T(String).valueOf(#name).concat('-').concat(#password))&lt;/p&gt;
&lt;p&gt;public User method(int name, String password);&lt;/p&gt;
&lt;h3&gt;C、对象形式&lt;/h3&gt;
&lt;p&gt;@Cacheable(value=&quot;cacheName&quot;, key&quot;#user.id)&lt;/p&gt;
&lt;p&gt;public User method(User user);&lt;/p&gt;
&lt;h3&gt;D、自定义Key生成器&lt;/h3&gt;
&lt;p&gt;@Cacheable(value=&quot;gomeo2oCache&quot;, keyGenerator = &quot;keyGenerator&quot;)&lt;/p&gt;
&lt;p&gt;public User method(User user);&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h2&gt; 5、测试&lt;/h2&gt;
&lt;p&gt;　　 我们 打开druid的SQL监控，然后在swagger中进行操作，在Redis desktop manager中查看Redis，就可以看到第一次查询执行了数据库查询，并把结果存进了Redis中，以后执行同样的查询，在缓存没过期之前，都直接从Redis获取，不再执行数据库查询，可见Redis缓存成功运行和释放了数据库的压力了；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/118906/201912/118906-20191210004356215-701787058.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/118906/201912/118906-20191210004308313-1391179668.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/118906/201912/118906-20191210004815887-340270646.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h2&gt;附：Redis Windows下简单实用以及Redis GUI工具Redis desktop manager的使用，也简单介绍下：&lt;/h2&gt;
&lt;h3&gt;1、Redis Windows版的简单使用：&lt;/h3&gt;
&lt;p&gt;下载Redis Windows版，解压后看到&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/118906/201912/118906-20191210005708565-478941166.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 先点击打开Redis-server.exe，再打开Redis-cli.exe，Redis已经以默认的方式启动起来了，其中Redis-server.exe就是Redis服务，Redis-cli.exe是客户端工具，用来以命令操作Redis的；&lt;/p&gt;
&lt;p&gt;这时候就可以使用Redis，默认密码是空的，端口是6379；我们设置一下密码：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;config set requirepass “你的密码”       //设置密码&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;auth “你的密码”                                   //验证密码是否成功设置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/118906/201912/118906-20191210010034160-983276210.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt; flushall ，是清除所有缓存的命令，用来清除重新测试的，&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;其他命令就不多介绍了，需要用到自行百度&lt;/p&gt;
&lt;h3&gt;2、Redis desktop manager的使用&lt;/h3&gt;
&lt;p&gt;下载安装包，安装，然后填入密码连接即可&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/118906/201912/118906-20191210010516454-1515645504.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/118906/201912/118906-20191210010548420-980269085.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;h2&gt;　　第二种方式中注解实现Redis缓存的方式有个缺点，就是失效时间都统一配置了，更多时候，我们希望失效时间可以每个方法单独配置，所以二的方法还需要改造，实现失效时间单独配置的功能；还有Redis一般我们都会搭建集群实现高可用，关于Linux、docker搭建Redis集群的方式，这些项目实战干货我们以后再来详细聊；&lt;/h2&gt;

&lt;h3&gt;附demoGIT地址：&lt;a href=&quot;https://github.com/anson-yang/cloverDemo.git&quot; target=&quot;_blank&quot;&gt;https://github.com/anson-yang/cloverDemo.git&lt;/a&gt;&lt;/h3&gt;
</description>
<pubDate>Mon, 09 Dec 2019 17:21:00 +0000</pubDate>
<dc:creator>烧麦</dc:creator>
<og:description>0、前言 在项目中，缓存作为一种高效的提升性能的手段，几乎必不可少，Redis作为其中的佼佼者被广泛应用； 一、spring boot集成Redis 1、添加依赖 2、配置文件增加Redis配置 3、</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yanghj/p/12014409.html</dc:identifier>
</item>
</channel>
</rss>