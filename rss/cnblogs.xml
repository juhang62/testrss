<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>C#并发实战Parallel.ForEach使用 - </title>
<link>http://www.cnblogs.com/heweijian/p/11330282.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/heweijian/p/11330282.html</guid>
<description>&lt;p&gt;     前言：最近给客户开发一个伙食费计算系统，大概需要计算2000个人的伙食。需求是按照员工的预定报餐计划对消费记录进行检查，如有未报餐有刷卡或者有报餐没刷卡的要进行一定的金额扣减等一系列规则。一开始我的想法比较简单，直接用一个for循环搞定，统计结果倒是没问题，但是计算出来太慢了需要7，8分钟。这样系统服务是报超时错误的，让人觉得有点不太爽。由于时间也不多就就先提交给用户使用了，后面逻辑又增加了，计算时间变长，整个计算一遍居然要将近10分钟了。这个对用户来说是能接收的（原来自己手算需要好几天呢），但是我自己接受不了，于是就开始优化了，怎么优化呢，用多线程呗。&lt;/p&gt;
&lt;p&gt;     一提到多线程，最先想到的是Task了，毕竟.net4.0以上Task封装了很多好用的方法。但是Task毕竟是多开一些线程去执行任务，最后整合结果，这样可以快一些，但我想更加快速一些，于是想到了另外一个对象：Parallel。之前在维护代码是确实有遇到过别人写的Parallel.Invoke，只是指定这个函数的作用是并发执行多项任务，如果遇到多个耗时的操作，他们之间又不贡献变量这个方法不错。我的情况是要并发执行一个集合，于是就用了List.ForAll 这个方法其实是拓展方法，完整的调用为：List.AsParallel().ForAll，需要先转换成支持并发的集合，等同于Parallel.ForEach，目的是对集合里面的元素并发执行一系列操作。&lt;/p&gt;
&lt;p&gt;     于是乎，把原来的foreach换成了List.AsParallel().ForAll，运行起来，果然速度惊人，不到两分钟就插入结果了，但最后却是报主键重复的错误，这个错误的原因是，由于使用了并发，这个时候变量自增，其实是在强着自增，当多个线程同时获取到了id值，都去自增然后就重复了，举个例子如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;int&lt;/span&gt; num = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
            List&lt;/span&gt;&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt; list = &lt;span&gt;new&lt;/span&gt; List&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&lt;span&gt;();
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt;= &lt;span&gt;2000&lt;/span&gt;; i++&lt;span&gt;)
            {
                list.Add(i);
            }
            Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;num初始值为：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; num.ToString());
            list.AsParallel().ForAll(n &lt;/span&gt;=&amp;gt;&lt;span&gt;
            {
                num&lt;/span&gt;++&lt;span&gt;;
            });
            Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;不加锁，并发{list.Count}次后为：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; num.ToString());
            Console.ReadKey();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这段代码是让一个变量执行2000次自增，正常结果应该是2001，但实际结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/659798/201908/659798-20190809234815698-412249266.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;有经验的同学，立马能想到需要加锁了，C#内置了很多锁对象，如lock 互斥锁，Interlocked 内部锁，&lt;span class=&quot;lang-csharp&quot;&gt;Monitor 这几个比较常见，lock内部实现其实就是使用了Monitor对象。对变量自增，Interlocked对象提供了，变量自增，自减、或者相加等方法,我们使用自增方法Interlocked.Increment，函数定义为：int Increment(ref int num),该对象提供原子性的变量自增操作，传入目标数值，返回或者ref num都是自增后的结果。 在之前的基础上我们增加一些代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
           num = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
            Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;num初始值为：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; num.ToString());
            list.AsParallel().ForAll(n &lt;/span&gt;=&amp;gt;&lt;span&gt;
            {
                Interlocked.Increment(&lt;/span&gt;&lt;span&gt;ref&lt;/span&gt;&lt;span&gt; num);
            });
            Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;使用内部锁，并发{list.Count}次后为：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; num.ToString());
            Console.ReadKey();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们来看运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/659798/201908/659798-20190810000436605-457717742.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;加了锁之后ID重复算是解决了，其实别高兴太早，由于正常的环境有了ID我们还有用这些ID来构建对象呢，于是又写了写代码，用集合来添加这些ID，为了更真实的模拟生产环境，我在forAll里面又加了一层循环代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
            num = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
            Random random &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Random();
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; total = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; m = &lt;span&gt;new&lt;/span&gt; ConcurrentBag&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&lt;span&gt;();
            list.AsParallel().ForAll(n &lt;/span&gt;=&amp;gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; c = random.Next(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;50&lt;/span&gt;&lt;span&gt;);
                Interlocked.Add(&lt;/span&gt;&lt;span&gt;ref&lt;/span&gt;&lt;span&gt; total, c);
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; c; i++&lt;span&gt;)
                {
                    Interlocked.Increment(&lt;/span&gt;&lt;span&gt;ref&lt;/span&gt;&lt;span&gt; num);
                    m.Add(num);
                }
            });
            Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;使用内部锁，并发+内部循环{list.Count}次后为：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; num.ToString());
            Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;实际值为：{total + 1}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; l = m.GroupBy(n =&amp;gt; n).Where(o =&amp;gt; o.Count() &amp;gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
            Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;并发里面使用安全集合ConcurrentBag添加num，集合重复值：{l.Count()}个&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            Console.ReadKey();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/659798/201908/659798-20190810001224310-502769036.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面的代码里面我用到了线程安全集合ConcurrentBag&amp;lt;T&amp;gt;它的命名空间是：using System.Collections.Concurrent，尽管使用了线程安全集合，但是在并发面前仍然是不安全的，到了这里其实比较郁闷了，自增加锁，安全集合内部应该也使用了锁，但还是重复了。有点说不过去了，想想多线程执行时有个上下文对象，即当多个线程同时执行任务，共享了变量他们一开始传进去的对象数值应该是相同的，由于变量自增时加了锁，所以ID是不会重复了。我猜测问题应该出在Add方法了，就是说当num值自增后还没有来得及传出去就已经执行了Add方法，故添加了重复变量。于是乎，我重新写了段代码，让ID自增和集合添加都放到锁里面：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
            num = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
            total &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; q = &lt;span&gt;new&lt;/span&gt; BlockingCollection&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&lt;span&gt;())
            {
                list.AsParallel().ForAll(n &lt;/span&gt;=&amp;gt;&lt;span&gt;
                {
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; c = random.Next(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;50&lt;/span&gt;&lt;span&gt;);
                    Interlocked.Add(&lt;/span&gt;&lt;span&gt;ref&lt;/span&gt;&lt;span&gt; total, c);
                    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; c; i++&lt;span&gt;)
                    {
                        
                       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Task.Delay(100);&lt;/span&gt;
                        &lt;span&gt;q.Add(Interlocked.Increment(ref num));
                        
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;可控
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;lock (objLock)
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;{
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    num++;
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    q.Add(num);
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;
&lt;span&gt;                    }

                });
                q.CompleteAdding();
                Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;num累计值为：{total},并发之后值为：{num}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; x = q.GroupBy(n =&amp;gt; n).Where(o =&amp;gt; o.Count() &amp;gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
                Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;并发使用安全集合BlockingCollection+Interlocked添加num，集合重复值：{x.Count()}个&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                Console.ReadKey();
            }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里我测试了另外一个线程安全的集合BlockingCollection，关于这个集合的使用请自行查找MSDN文档，上面的关键代码直接添加安全集合的返回值，可以保证集合不会重复，但其实下面的lock使用正式环境，因为我们添加的一般都是对象不会是基础类型数值，运行结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/659798/201908/659798-20190810004313651-1259210139.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至此，我们的问题解决了。&lt;/p&gt;
&lt;p&gt;      总结：C#安全集合在并发的情况下其实不一定是安全的，还是需要结合实际应用场景和验证结果为准。Parallel.ForEach在对循环数量可观的情况下是可以去使用的，如果有共享变量，一定要配合锁做同步处理。还是得慎用这个方法，如果方法内部有访问数据库的记得增加事务处理，否则就呵呵了。&lt;/p&gt;
</description>
<pubDate>Sat, 10 Aug 2019 00:15:00 +0000</pubDate>
<dc:creator>&amp;lt;渔人&amp;gt;</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/heweijian/p/11330282.html</dc:identifier>
</item>
<item>
<title>Spark 系列（七）—— 基于 ZooKeeper 搭建 Spark 高可用集群 - 黑白影</title>
<link>http://www.cnblogs.com/heibaiying/p/11330385.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/heibaiying/p/11330385.html</guid>
<description>&lt;h2 id=&quot;一集群规划&quot;&gt;一、集群规划&lt;/h2&gt;
&lt;p&gt;这里搭建一个 3 节点的 Spark 集群，其中三台主机上均部署 &lt;code&gt;Worker&lt;/code&gt; 服务。同时为了保证高可用，除了在 hadoop001 上部署主 &lt;code&gt;Master&lt;/code&gt; 服务外，还在 hadoop002 和 hadoop003 上分别部署备用的 &lt;code&gt;Master&lt;/code&gt; 服务，Master 服务由 Zookeeper 集群进行协调管理，如果主 &lt;code&gt;Master&lt;/code&gt; 不可用，则备用 &lt;code&gt;Master&lt;/code&gt; 会成为新的主 &lt;code&gt;Master&lt;/code&gt;。&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/heibaiying/BigData-Notes/master/pictures/spark%E9%9B%86%E7%BE%A4%E8%A7%84%E5%88%92.png&quot;/&gt;&lt;/div&gt;
&lt;h2 id=&quot;二前置条件&quot;&gt;二、前置条件&lt;/h2&gt;
&lt;p&gt;搭建 Spark 集群前，需要保证 JDK 环境、Zookeeper 集群和 Hadoop 集群已经搭建，相关步骤可以参阅：&lt;/p&gt;
&lt;h2 id=&quot;三spark集群搭建&quot;&gt;三、Spark集群搭建&lt;/h2&gt;
&lt;h3 id=&quot;下载解压&quot;&gt;3.1 下载解压&lt;/h3&gt;
&lt;p&gt;下载所需版本的 Spark，官网下载地址：&lt;a href=&quot;http://spark.apache.org/downloads.html&quot; class=&quot;uri&quot;&gt;http://spark.apache.org/downloads.html&lt;/a&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img width=&quot;600px&quot; src=&quot;https://raw.githubusercontent.com/heibaiying/BigData-Notes/master/pictures/spark-download.png&quot;/&gt;&lt;/div&gt;
&lt;p&gt;下载后进行解压：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;# tar -zxvf  spark-2.2.3-bin-hadoop2.6.tgz&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;配置环境变量&quot;&gt;3.2 配置环境变量&lt;/h3&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;# vim /etc/profile&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;添加环境变量：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;export SPARK_HOME=/usr/app/spark-2.2.3-bin-hadoop2.6
export  PATH=${SPARK_HOME}/bin:$PATH&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使得配置的环境变量立即生效：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;# source /etc/profile&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;集群配置&quot;&gt;3.3 集群配置&lt;/h3&gt;
&lt;p&gt;进入 &lt;code&gt;${SPARK_HOME}/conf&lt;/code&gt; 目录，拷贝配置样本进行修改：&lt;/p&gt;
&lt;h4 id=&quot;spark-env.sh&quot;&gt;1. spark-env.sh&lt;/h4&gt;
&lt;pre class=&quot;she&quot;&gt;
&lt;code&gt; cp spark-env.sh.template spark-env.sh&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;# 配置JDK安装位置
JAVA_HOME=/usr/java/jdk1.8.0_201
# 配置hadoop配置文件的位置
HADOOP_CONF_DIR=/usr/app/hadoop-2.6.0-cdh5.15.2/etc/hadoop
# 配置zookeeper地址
SPARK_DAEMON_JAVA_OPTS=&quot;-Dspark.deploy.recoveryMode=ZOOKEEPER -Dspark.deploy.zookeeper.url=hadoop001:2181,hadoop002:2181,hadoop003:2181 -Dspark.deploy.zookeeper.dir=/spark&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;slaves&quot;&gt;2. slaves&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;cp slaves.template slaves&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配置所有 Woker 节点的位置：&lt;/p&gt;
&lt;pre class=&quot;properties&quot;&gt;
&lt;code&gt;hadoop001
hadoop002
hadoop003&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;安装包分发&quot;&gt;3.4 安装包分发&lt;/h3&gt;
&lt;p&gt;将 Spark 的安装包分发到其他服务器，分发后建议在这两台服务器上也配置一下 Spark 的环境变量。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;scp -r /usr/app/spark-2.4.0-bin-hadoop2.6/   hadoop002:usr/app/
scp -r /usr/app/spark-2.4.0-bin-hadoop2.6/   hadoop003:usr/app/&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;四启动集群&quot;&gt;四、启动集群&lt;/h2&gt;
&lt;h3 id=&quot;启动zookeeper集群&quot;&gt;4.1 启动ZooKeeper集群&lt;/h3&gt;
&lt;p&gt;分别到三台服务器上启动 ZooKeeper 服务：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt; zkServer.sh start&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;启动hadoop集群&quot;&gt;4.2 启动Hadoop集群&lt;/h3&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;# 启动dfs服务
start-dfs.sh
# 启动yarn服务
start-yarn.sh&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;启动spark集群&quot;&gt;4.3 启动Spark集群&lt;/h3&gt;
&lt;p&gt;进入 hadoop001 的 &lt;code&gt;${SPARK_HOME}/sbin&lt;/code&gt; 目录下，执行下面命令启动集群。执行命令后，会在 hadoop001 上启动 &lt;code&gt;Maser&lt;/code&gt; 服务，会在 &lt;code&gt;slaves&lt;/code&gt; 配置文件中配置的所有节点上启动 &lt;code&gt;Worker&lt;/code&gt; 服务。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;start-all.sh&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;分别在 hadoop002 和 hadoop003 上执行下面的命令，启动备用的 &lt;code&gt;Master&lt;/code&gt; 服务：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;# ${SPARK_HOME}/sbin 下执行
start-master.sh&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;查看服务&quot;&gt;4.4 查看服务&lt;/h3&gt;
&lt;p&gt;查看 Spark 的 Web-UI 页面，端口为 &lt;code&gt;8080&lt;/code&gt;。此时可以看到 hadoop001 上的 Master 节点处于 &lt;code&gt;ALIVE&lt;/code&gt; 状态，并有 3 个可用的 &lt;code&gt;Worker&lt;/code&gt; 节点。&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/heibaiying/BigData-Notes/master/pictures/spark-%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA1.png&quot;/&gt;&lt;/div&gt;
&lt;p&gt;而 hadoop002 和 hadoop003 上的 Master 节点均处于 &lt;code&gt;STANDBY&lt;/code&gt; 状态，没有可用的 &lt;code&gt;Worker&lt;/code&gt; 节点。&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/heibaiying/BigData-Notes/master/pictures/spark-%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA2.png&quot;/&gt;&lt;/div&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/heibaiying/BigData-Notes/master/pictures/spark-%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA3.png&quot;/&gt;&lt;/div&gt;
&lt;h2 id=&quot;五验证集群高可用&quot;&gt;五、验证集群高可用&lt;/h2&gt;
&lt;p&gt;此时可以使用 &lt;code&gt;kill&lt;/code&gt; 命令杀死 hadoop001 上的 &lt;code&gt;Master&lt;/code&gt; 进程，此时备用 &lt;code&gt;Master&lt;/code&gt; 会中会有一个再次成为 &lt;code&gt;主 Master&lt;/code&gt;，我这里是 hadoop002，可以看到 hadoop2 上的 &lt;code&gt;Master&lt;/code&gt; 经过 &lt;code&gt;RECOVERING&lt;/code&gt; 后成为了新的主 &lt;code&gt;Master&lt;/code&gt;，并且获得了全部可以用的 &lt;code&gt;Workers&lt;/code&gt;。&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/heibaiying/BigData-Notes/master/pictures/spark-%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA4.png&quot;/&gt;&lt;/div&gt;
&lt;p&gt;Hadoop002 上的 &lt;code&gt;Master&lt;/code&gt; 成为主 &lt;code&gt;Master&lt;/code&gt;，并获得了全部可以用的 &lt;code&gt;Workers&lt;/code&gt;。&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/heibaiying/BigData-Notes/master/pictures/spark-%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA5.png&quot;/&gt;&lt;/div&gt;
&lt;p&gt;此时如果你再在 hadoop001 上使用 &lt;code&gt;start-master.sh&lt;/code&gt; 启动 Master 服务，那么其会作为备用 &lt;code&gt;Master&lt;/code&gt; 存在。&lt;/p&gt;
&lt;h2 id=&quot;六提交作业&quot;&gt;六、提交作业&lt;/h2&gt;
&lt;p&gt;和单机环境下的提交到 Yarn 上的命令完全一致，这里以 Spark 内置的计算 Pi 的样例程序为例，提交命令如下：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;spark-submit \
--class org.apache.spark.examples.SparkPi \
--master yarn \
--deploy-mode client \
--executor-memory 1G \
--num-executors 10 \
/usr/app/spark-2.4.0-bin-hadoop2.6/examples/jars/spark-examples_2.11-2.4.0.jar \
100&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;3.75&quot;&gt;
&lt;p&gt;&lt;strong&gt;更多大数据系列文章可以参见 GitHub 开源项目&lt;/strong&gt;： &lt;a href=&quot;https://github.com/heibaiying/BigData-Notes&quot;&gt;&lt;strong&gt;大数据入门指南&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Fri, 09 Aug 2019 22:49:00 +0000</pubDate>
<dc:creator>黑白影</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/heibaiying/p/11330385.html</dc:identifier>
</item>
<item>
<title>统一流控服务开源：基于.Net Core的流控服务 - Eric zhou</title>
<link>http://www.cnblogs.com/tianqing/p/11328969.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tianqing/p/11328969.html</guid>
<description>&lt;p&gt;先前有一篇博文，梳理了流控服务的场景、业界做法和常用算法&lt;/p&gt;
&lt;p&gt;&lt;a class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/tianqing/p/9044155.html&quot;&gt;统一流控服务开源-1：场景&amp;amp;业界做法&amp;amp;算法篇&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近完成了流控服务的开发，并在生产系统进行了大半年的验证，稳定可靠。今天整理一下核心设计和实现思路，开源到Github上，分享给大家&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/23525/201908/23525-20190809234952134-1303031823.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;     &lt;a href=&quot;https://github.com/zhouguoqing/FlowControl&quot;&gt;https://github.com/zhouguoqing/FlowControl&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/23525/201908/23525-20190809182053537-1317524168.png&quot; alt=&quot;&quot; width=&quot;576&quot; height=&quot;518&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; 一、令牌桶算法实现&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  先回顾一下令牌桶算法示意图&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  &lt;img src=&quot;https://img2018.cnblogs.com/blog/23525/201908/23525-20190809224350329-683331452.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;  随着时间流逝,系统会按恒定1/QPS时间间隔(如果QPS=100,则间隔是10ms) 往桶里加入Token(想象和漏洞漏水相反,有个水龙头在不断的加水),&lt;/p&gt;

&lt;p&gt;  如果桶已经满了就不再加了. 新请求来临时, 会各自拿走一个Token,如果没有Token可拿了就阻塞或者拒绝服务.&lt;/p&gt;

&lt;p&gt;  令牌添加速度支持动态变化，实时控制处理的速率.&lt;/p&gt;
&lt;p&gt;  令牌桶有两个关键的属性：&lt;strong&gt;令牌桶容量（大小）和时间间隔，&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  有两个关键操作，&lt;strong&gt;从令牌桶中取Token；令牌桶定时的Reset重置。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;  我们看TokenBucket类：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; CZ.FlowControl.Service
{
    &lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; CZ.FlowControl.Spi;
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 令牌桶
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TokenBucket : IThrottleStrategy
    {
        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; bucketTokenCapacity;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; syncRoot = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; ticksRefillInterval;
        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; nextRefillTime;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;number of tokens in the bucket&lt;/span&gt;
        &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; tokens;

        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; TokenBucket(&lt;span&gt;long&lt;/span&gt; bucketTokenCapacity, &lt;span&gt;long&lt;/span&gt; refillInterval, &lt;span&gt;long&lt;/span&gt;&lt;span&gt; refillIntervalInMilliSeconds)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (bucketTokenCapacity &amp;lt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ArgumentOutOfRangeException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bucketTokenCapacity&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bucket token capacity can not be negative&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (refillInterval &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ArgumentOutOfRangeException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;refillInterval&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Refill interval cannot be negative&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (refillIntervalInMilliSeconds &amp;lt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ArgumentOutOfRangeException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;refillIntervalInMilliSeconds&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Refill interval in milliseconds cannot be negative&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.bucketTokenCapacity =&lt;span&gt; bucketTokenCapacity;
            ticksRefillInterval &lt;/span&gt;= TimeSpan.FromMilliseconds(refillInterval *&lt;span&gt; refillIntervalInMilliSeconds).Ticks;
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 是否流控
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;n&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; ShouldThrottle(&lt;span&gt;long&lt;/span&gt; n = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
        {
            TimeSpan waitTime;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; ShouldThrottle(n, &lt;span&gt;out&lt;/span&gt;&lt;span&gt; waitTime);
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; &lt;strong&gt;ShouldThrottle&lt;/strong&gt;(&lt;span&gt;long&lt;/span&gt; n, &lt;span&gt;out&lt;/span&gt;&lt;span&gt; TimeSpan waitTime)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (n &amp;lt;= &lt;span&gt;0&lt;/span&gt;) &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ArgumentOutOfRangeException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Should be positive integer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;lock&lt;/span&gt;&lt;span&gt; (syncRoot)
            {
                UpdateTokens();
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (tokens &amp;lt;&lt;span&gt; n)
                {
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; timeToIntervalEnd = nextRefillTime -&lt;span&gt; SystemTime.UtcNow.Ticks;
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (timeToIntervalEnd &amp;lt; &lt;span&gt;0&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; ShouldThrottle(n, &lt;span&gt;out&lt;/span&gt;&lt;span&gt; waitTime);

                    waitTime &lt;/span&gt;=&lt;span&gt; TimeSpan.FromTicks(timeToIntervalEnd);
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                }
               &lt;strong&gt; tokens &lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;-=&lt;/strong&gt;&lt;span&gt;&lt;strong&gt; n;&lt;/strong&gt;

                waitTime &lt;/span&gt;=&lt;span&gt; TimeSpan.Zero;
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            }
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 更新令牌
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; UpdateTokens();

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; ShouldThrottle(&lt;span&gt;out&lt;/span&gt;&lt;span&gt; TimeSpan waitTime)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; ShouldThrottle(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;out&lt;/span&gt;&lt;span&gt; waitTime);
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; CurrentTokenCount
        {
            &lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;lock&lt;/span&gt;&lt;span&gt; (syncRoot)
                {
                    UpdateTokens();
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; tokens;
                }
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 这个抽象类中，将UpdateToken作为抽象方法暴露出来，给实现类更多的灵活去控制令牌桶重置操作。基于此实现了“固定令牌桶”&lt;strong&gt;FixedTokenBucket&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    ///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 固定令牌桶
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FixedTokenBucket : TokenBucket
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; FixedTokenBucket(&lt;span&gt;long&lt;/span&gt; maxTokens, &lt;span&gt;long&lt;/span&gt; refillInterval, &lt;span&gt;long&lt;/span&gt;&lt;span&gt; refillIntervalInMilliSeconds)
            : &lt;/span&gt;&lt;span&gt;base&lt;/span&gt;&lt;span&gt;(maxTokens, refillInterval, refillIntervalInMilliSeconds)
        {
        }

        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; UpdateTokens()
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; currentTime =&lt;span&gt; SystemTime.UtcNow.Ticks;

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (currentTime &amp;lt;&lt;span&gt; nextRefillTime)
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;

            tokens &lt;/span&gt;=&lt;span&gt; bucketTokenCapacity;
            nextRefillTime &lt;/span&gt;= currentTime +&lt;span&gt; ticksRefillInterval;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;   固定令牌桶在每次取Token时，都要执行方法ShouldThrottle。这个方法中：&lt;/p&gt;
&lt;p&gt;   并发取Token是线程安全的，这个地方用了Lock控制，损失了一部分性能。同时每次获取可用Token的时候，都会实时Check一下是否需要到达Reset令牌桶的时间。&lt;/p&gt;
&lt;p&gt;   获取到可用令牌后，令牌桶中令牌的数量-1。如果没有足够的可用令牌，则返回等待到下次Reset令牌桶的时间。如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; ShouldThrottle(&lt;span&gt;long&lt;/span&gt; n, &lt;span&gt;out&lt;/span&gt;&lt;span&gt; TimeSpan waitTime)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (n &amp;lt;= &lt;span&gt;0&lt;/span&gt;) &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ArgumentOutOfRangeException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Should be positive integer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;strong&gt;&lt;span&gt;lock&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; (syncRoot)
            {
                &lt;strong&gt;UpdateTokens&lt;/strong&gt;();
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (tokens &amp;lt;&lt;span&gt; n)
                {
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; timeToIntervalEnd = nextRefillTime -&lt;span&gt; SystemTime.UtcNow.Ticks;
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (timeToIntervalEnd &amp;lt; &lt;span&gt;0&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; ShouldThrottle(n, &lt;span&gt;out&lt;/span&gt;&lt;span&gt; waitTime);

                    waitTime &lt;/span&gt;=&lt;span&gt; TimeSpan.FromTicks(timeToIntervalEnd);
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                }
                &lt;strong&gt;tokens &lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;-=&lt;/strong&gt;&lt;span&gt;&lt;strong&gt; n;&lt;/strong&gt;

                waitTime &lt;/span&gt;=&lt;span&gt; TimeSpan.Zero;
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;   以上就是令牌桶算法的实现。我们继续看漏桶算法。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; 二、漏桶算法实现&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  首先回顾一下漏桶算法的原理：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  &lt;img src=&quot;https://img2018.cnblogs.com/blog/23525/201908/23525-20190809230914990-2053194618.png&quot; alt=&quot;&quot;/&gt;‘&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;  水(请求)先进入到漏桶里，漏桶以一定的速度出水(接口有响应速率),&lt;/p&gt;

&lt;p&gt;  当水流入速度过大会直接溢出(访问频率超过接口响应速率), 然后就拒绝请求,&lt;/p&gt;

&lt;p&gt;  可以看出漏桶算法能强行限制数据的传输速率.&lt;/p&gt;

&lt;p&gt;  有两个变量：&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;一个是桶的大小,支持流量突发增多时可以存多少的水(burst),&lt;/li&gt;
&lt;li&gt;另一个是水桶漏洞的大小(rate)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;   漏桶抽象类：&lt;strong&gt;LeakTokenBucket，继承与令牌桶抽象父类 TokenBucket，说明了获取令牌(漏出令牌)在底层的方式是一致的，不一样的是重置令牌的方式（务必理解这一点）&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; CZ.FlowControl.Service
{
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 漏桶
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LeakyTokenBucket : TokenBucket
    {
        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; stepTokens;
        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; ticksStepInterval;

        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; LeakyTokenBucket(&lt;span&gt;long&lt;/span&gt; maxTokens, &lt;span&gt;long&lt;/span&gt; refillInterval, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; refillIntervalInMilliSeconds, 
            &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; stepTokens, &lt;span&gt;long&lt;/span&gt; stepInterval, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; stepIntervalInMilliseconds)
            : &lt;/span&gt;&lt;span&gt;base&lt;/span&gt;&lt;span&gt;(maxTokens, refillInterval, refillIntervalInMilliSeconds)
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.stepTokens =&lt;span&gt; stepTokens;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (stepInterval &amp;lt; &lt;span&gt;0&lt;/span&gt;) &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ArgumentOutOfRangeException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;stepInterval&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Step interval cannot be negative&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (stepTokens &amp;lt; &lt;span&gt;0&lt;/span&gt;) &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ArgumentOutOfRangeException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;stepTokens&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Step tokens cannot be negative&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (stepIntervalInMilliseconds &amp;lt;= &lt;span&gt;0&lt;/span&gt;) &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ArgumentOutOfRangeException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;stepIntervalInMilliseconds&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Step interval in milliseconds cannot be negative&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            ticksStepInterval &lt;/span&gt;= TimeSpan.FromMilliseconds(stepInterval *&lt;span&gt; stepIntervalInMilliseconds).Ticks;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    可以看出，漏桶是在令牌桶的基础上增加了二个重要的属性：&lt;strong&gt;这两个属性决定了重置令牌桶的方式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    stepTokens：每间隔时间内漏的数量&lt;/p&gt;
&lt;p&gt;    ticksStepInterval：漏的间隔时间&lt;/p&gt;
&lt;p&gt;    举个例子：TPS 100，即每秒漏出100个Token，stepTokens =100， ticksStepInterval=1000ms&lt;/p&gt;
&lt;p&gt;    漏桶的具体实现有两种：空桶和满桶&lt;/p&gt;
&lt;p&gt;    StepDownTokenBucket 满桶：即一把将令牌桶填充满&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('d206443c-f7ac-47ec-9bef-a616a25b326d')&quot; readability=&quot;37.5&quot;&gt;&lt;img id=&quot;code_img_closed_d206443c-f7ac-47ec-9bef-a616a25b326d&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_d206443c-f7ac-47ec-9bef-a616a25b326d&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('d206443c-f7ac-47ec-9bef-a616a25b326d',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_d206443c-f7ac-47ec-9bef-a616a25b326d&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;70&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; CZ.FlowControl.Service
{
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 漏桶(满桶)
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;remarks&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; StepDownLeakyTokenBucketStrategy resembles a bucket which has been filled with tokens at the beginning but subsequently leaks tokens at a fixed interval
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/remarks&amp;gt;&lt;/span&gt;
    &lt;span&gt;class&lt;/span&gt;&lt;span&gt; StepDownTokenBucket : LeakyTokenBucket
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; StepDownTokenBucket(&lt;span&gt;long&lt;/span&gt; maxTokens, &lt;span&gt;long&lt;/span&gt; refillInterval, &lt;span&gt;int&lt;/span&gt; refillIntervalInMilliSeconds, &lt;span&gt;long&lt;/span&gt; stepTokens, &lt;span&gt;long&lt;/span&gt; stepInterval, &lt;span&gt;int&lt;/span&gt; stepIntervalInMilliseconds) : &lt;span&gt;base&lt;/span&gt;&lt;span&gt;(maxTokens, refillInterval, refillIntervalInMilliSeconds, stepTokens, stepInterval, stepIntervalInMilliseconds)
        {
        }

        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; UpdateTokens()
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; currentTime =&lt;span&gt; SystemTime.UtcNow.Ticks;

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (currentTime &amp;gt;=&lt;span&gt; nextRefillTime)
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;set tokens to max&lt;/span&gt;
                tokens =&lt;span&gt; bucketTokenCapacity;

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;compute next refill time&lt;/span&gt;
                nextRefillTime = currentTime +&lt;span&gt; ticksRefillInterval;
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;calculate max tokens possible till the end&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; timeToNextRefill = nextRefillTime -&lt;span&gt; currentTime;
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; stepsToNextRefill = timeToNextRefill/&lt;span&gt;ticksStepInterval;

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; maxPossibleTokens = stepsToNextRefill*&lt;span&gt;stepTokens;

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((timeToNextRefill%ticksStepInterval) &amp;gt; &lt;span&gt;0&lt;/span&gt;) maxPossibleTokens +=&lt;span&gt; stepTokens;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (maxPossibleTokens &amp;lt; tokens) tokens =&lt;span&gt; maxPossibleTokens;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;   StepUpLeakyTokenBucket 空桶：即每次只将stepTokens个数的令牌放到桶中   &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('be9348b0-a307-4616-ad94-93d13f27c877')&quot; readability=&quot;37.5&quot;&gt;&lt;img id=&quot;code_img_closed_be9348b0-a307-4616-ad94-93d13f27c877&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_be9348b0-a307-4616-ad94-93d13f27c877&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('be9348b0-a307-4616-ad94-93d13f27c877',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_be9348b0-a307-4616-ad94-93d13f27c877&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;70&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; CZ.FlowControl.Service
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 漏桶(空桶)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;remarks&amp;gt;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt;  StepUpLeakyTokenBucketStrategy resemembles an empty bucket at the beginning but get filled will tokens over a fixed interval.
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/remarks&amp;gt;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;class&lt;/span&gt;&lt;span&gt; StepUpLeakyTokenBucket : LeakyTokenBucket
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; lastActivityTime;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; StepUpLeakyTokenBucket(&lt;span&gt;long&lt;/span&gt; maxTokens, &lt;span&gt;long&lt;/span&gt; refillInterval, &lt;span&gt;int&lt;/span&gt; refillIntervalInMilliSeconds, &lt;span&gt;long&lt;/span&gt; stepTokens, &lt;span&gt;long&lt;/span&gt; stepInterval, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; stepIntervalInMilliseconds) 
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             : &lt;span&gt;base&lt;/span&gt;&lt;span&gt;(maxTokens, refillInterval, refillIntervalInMilliSeconds, stepTokens, stepInterval, stepIntervalInMilliseconds)
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; UpdateTokens()
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; currentTime =&lt;span&gt; SystemTime.UtcNow.Ticks;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (currentTime &amp;gt;=&lt;span&gt; nextRefillTime)
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;                 tokens =&lt;span&gt; stepTokens;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt;                 lastActivityTime =&lt;span&gt; currentTime;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;                 nextRefillTime = currentTime +&lt;span&gt; ticksRefillInterval;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; 
&lt;span&gt;34&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;calculate tokens at current step&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt;             &lt;span&gt;long&lt;/span&gt; elapsedTimeSinceLastActivity = currentTime -&lt;span&gt; lastActivityTime;
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;             &lt;span&gt;long&lt;/span&gt; elapsedStepsSinceLastActivity = elapsedTimeSinceLastActivity /&lt;span&gt; ticksStepInterval;
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; 
&lt;span&gt;39&lt;/span&gt;             tokens += (elapsedStepsSinceLastActivity*&lt;span&gt;stepTokens);
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; 
&lt;span&gt;41&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (tokens &amp;gt; bucketTokenCapacity) tokens =&lt;span&gt; bucketTokenCapacity;
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;             lastActivityTime =&lt;span&gt; currentTime;
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt; &lt;strong&gt;三、流控服务封装&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  第二章节，详细介绍了令牌桶和漏桶的具体实现。基于以上，要重点介绍接口：IThrottleStrategy：流控的具体方式&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; CZ.FlowControl.Spi
{
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 流量控制算法策略
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IThrottleStrategy
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 是否流控
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;n&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;bool&lt;/span&gt; ShouldThrottle(&lt;span&gt;long&lt;/span&gt; n = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 是否流控
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;n&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;waitTime&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;bool&lt;/span&gt; ShouldThrottle(&lt;span&gt;long&lt;/span&gt; n, &lt;span&gt;out&lt;/span&gt;&lt;span&gt; TimeSpan waitTime);

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 是否流控
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;waitTime&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;bool&lt;/span&gt; ShouldThrottle(&lt;span&gt;out&lt;/span&gt;&lt;span&gt; TimeSpan waitTime);

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 当前令牌个数
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;long&lt;/span&gt; CurrentTokenCount { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    有了这个流控方式接口后，我们还需要一个流控策略定义类：FlowControlStrategy&lt;/p&gt;
&lt;p&gt;    即定义具体的流控策略：以下是这个类的详细属性和成员：  不仅定义了流控策略类型，还定义了流控的维度信息和流控阈值，这样流控就做成依赖注入的方式了！ &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; CZ.FlowControl.Spi
{
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 流控策略
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FlowControlStrategy
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 标识
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; ID { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 名称
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Name { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 流控策略类型
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; FlowControlStrategyType StrategyType { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 流控阈值-Int
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; IntThreshold { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 流控阈值-Double
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;decimal&lt;/span&gt; DoubleThreshold { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 时间区间跨度
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; FlowControlTimespan TimeSpan { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt; flowControlConfigs;

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 流控维度信息
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt; FlowControlConfigs
        {
            &lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (flowControlConfigs == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                    flowControlConfigs &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;();

                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; flowControlConfigs;
            }
            &lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;
            {
                flowControlConfigs &lt;/span&gt;=&lt;span&gt; value;
            }
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 描述
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Descriptions { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 触发流控后是否直接拒绝请求
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;        
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; IsRefusedRequest { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 创建时间
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; DateTime CreateTime { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 创建人
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Creator { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 最后修改时间
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; DateTime LastModifyTime { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 最后修改人
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; LastModifier { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;   同时，流控策略类型，我们抽象了一个枚举：FlowControlStrategyType&lt;/p&gt;
&lt;p&gt;   支持3种流控策略：TPS、Sum(指定时间段内请求的次数)，Delay延迟&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; CZ.FlowControl.Spi
{
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 流控策略类型枚举
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt;&lt;span&gt; FlowControlStrategyType
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; TPS控制策略
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;        TPS,
     &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 总数控制策略
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;        Sum,

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 延迟控制策略
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;        Delay
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;  面向每种流控策略类型，提供了一个对应的流控器，比如说TPS的流控器&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;TPSFlowController&lt;/span&gt;，内部使用了固定令牌桶算法
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; CZ.FlowControl.Service
{
    &lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; CZ.FlowControl.Spi;

    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; TPS流量控制器
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TPSFlowController : IFlowController
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; IThrottleStrategy InnerThrottleStrategy
        {
            &lt;/span&gt;&lt;span&gt;get&lt;/span&gt;; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; FlowControlStrategy FlowControlStrategy { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; ShouldThrottle(&lt;span&gt;long&lt;/span&gt; n, &lt;span&gt;out&lt;/span&gt;&lt;span&gt; TimeSpan waitTime)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; InnerThrottleStrategy.ShouldThrottle(n, &lt;span&gt;out&lt;/span&gt;&lt;span&gt; waitTime);
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; TPSFlowController(FlowControlStrategy strategy)
        {
            FlowControlStrategy &lt;/span&gt;=&lt;span&gt; strategy;

            InnerThrottleStrategy &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; &lt;strong&gt;FixedTokenBucket&lt;/strong&gt;(strategy.IntThreshold, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1000&lt;/span&gt;&lt;span&gt;);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;  Sum(指定时间段内请求的次数)流控器：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.IO;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; CZ.FlowControl.Service
{
    &lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; CZ.FlowControl.Spi;

    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 一段时间内合计值流量控制器
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SumFlowController : IFlowController
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; IThrottleStrategy InnerThrottleStrategy
        {
            &lt;/span&gt;&lt;span&gt;get&lt;/span&gt;; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; FlowControlStrategy FlowControlStrategy { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; ShouldThrottle(&lt;span&gt;long&lt;/span&gt; n, &lt;span&gt;out&lt;/span&gt;&lt;span&gt; TimeSpan waitTime)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; InnerThrottleStrategy.ShouldThrottle(n, &lt;span&gt;out&lt;/span&gt;&lt;span&gt; waitTime);
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; SumFlowController(FlowControlStrategy strategy)
        {
            FlowControlStrategy &lt;/span&gt;=&lt;span&gt; strategy;

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; refillInterval =&lt;span&gt; GetTokenBucketRefillInterval(strategy);

            InnerThrottleStrategy &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; &lt;strong&gt;FixedTokenBucket&lt;/strong&gt;(strategy.IntThreshold, refillInterval, &lt;span&gt;1000&lt;/span&gt;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; GetTokenBucketRefillInterval(FlowControlStrategy strategy)
        {
            &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; refillInterval = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (strategy.TimeSpan)
            {
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; FlowControlTimespan.Second:
                    refillInterval &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; FlowControlTimespan.Minute:
                    refillInterval &lt;/span&gt;= &lt;span&gt;60&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; FlowControlTimespan.Hour:
                    refillInterval &lt;/span&gt;= &lt;span&gt;60&lt;/span&gt; * &lt;span&gt;60&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; FlowControlTimespan.Day:
                    refillInterval &lt;/span&gt;= &lt;span&gt;24&lt;/span&gt; * &lt;span&gt;60&lt;/span&gt; * &lt;span&gt;60&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            }

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; refillInterval;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;  同时，通过一个创建者工厂，根据不同的流控策略，创建对应的流控器（做了一层缓存，性能更好）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; CZ.FlowControl.Service
{
    &lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; CZ.FlowControl.Spi;

    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 流控策略工厂
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FlowControllerFactory
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, IFlowController&amp;gt;&lt;span&gt; fcControllers;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; syncObj = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt;();

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; FlowControllerFactory instance;

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; FlowControllerFactory()
        {
            fcControllers &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, IFlowController&amp;gt;&lt;span&gt;();
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; FlowControllerFactory GetInstance()
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (instance == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;lock&lt;/span&gt;&lt;span&gt; (syncObj)
                {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (instance == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                    {
                        instance &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FlowControllerFactory();
                    }
                }
            }

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; instance;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; IFlowController GetOrCreateFlowController(FlowControlStrategy strategy)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (strategy == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ArgumentNullException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;FlowControllerFactory.GetOrCreateFlowController.strategy&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;fcControllers.ContainsKey(strategy.ID))
            {
                &lt;/span&gt;&lt;span&gt;lock&lt;/span&gt;&lt;span&gt; (syncObj)
                {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;fcControllers.ContainsKey(strategy.ID))
                    {
                        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; fcController =&lt;span&gt; CreateFlowController(strategy);
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (fcController != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                            fcControllers.Add(strategy.ID, fcController);
                    }
                }
            }

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (fcControllers.ContainsKey(strategy.ID))
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; controller =&lt;span&gt; fcControllers[strategy.ID];
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; controller;
            }

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; IFlowController CreateFlowController(FlowControlStrategy strategy)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (strategy == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ArgumentNullException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;FlowControllerFactory.CreateFlowController.strategy&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            IFlowController controller &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (strategy.StrategyType)
            {
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; FlowControlStrategyType.TPS:
                    controller &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TPSFlowController(strategy);
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; FlowControlStrategyType.Delay:
                    controller &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DelayFlowController(strategy);
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; FlowControlStrategyType.Sum:
                    controller &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SumFlowController(strategy);
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            }

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; controller;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;   有了流控策略定义、我们更进一步，继续封装了流控Facede服务，这样把流控的变化封装到内部。对外只提供流控服务接口，流控时动态传入流控策略和流控个数：FlowControlService&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; CZ.FlowControl.Service
{
    &lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; CZ.FlowControl.Spi;
    &lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading;

    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 统一流控服务
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FlowControlService
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 流控
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;strategy&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;流控策略&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;count&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;请求次数&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; FlowControl(FlowControlStrategy strategy, &lt;span&gt;int&lt;/span&gt; count = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; controller =&lt;span&gt; FlowControllerFactory.GetInstance().GetOrCreateFlowController(strategy);

            TimeSpan waitTimespan &lt;/span&gt;=&lt;span&gt; TimeSpan.Zero;

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; result = controller.ShouldThrottle(count, &lt;span&gt;out&lt;/span&gt;&lt;span&gt; waitTimespan);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (result)
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (strategy.IsRefusedRequest == &lt;span&gt;false&lt;/span&gt; &amp;amp;&amp;amp; waitTimespan !=&lt;span&gt; TimeSpan.Zero)
                {
                    WaitForAvailable(strategy, controller, waitTimespan, count);
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (strategy.IsRefusedRequest)
                {
                    &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Exception(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;触发流控！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                }
            }
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 等待可用
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;strategy&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;流控策略&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;controller&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;流控器&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;waitTimespan&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;等待时间&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;count&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;请求次数&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; WaitForAvailable(FlowControlStrategy strategy, IFlowController controller, TimeSpan waitTimespan, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; count)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; timespan =&lt;span&gt; waitTimespan;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (strategy.StrategyType ==&lt;span&gt; FlowControlStrategyType.Delay)
            {
                Thread.Sleep(timespan);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }

            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (controller.ShouldThrottle(count, &lt;span&gt;out&lt;/span&gt;&lt;span&gt; timespan))
            {
                Thread.Sleep(timespan);
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;  以上，统一流控服务完成了第一个版本的封装。接下来我们看示例代码&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; 四、示例代码&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;    &lt;img src=&quot;https://img2018.cnblogs.com/blog/23525/201908/23525-20190809234421804-82051343.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;   &lt;img src=&quot;https://img2018.cnblogs.com/blog/23525/201908/23525-20190809234430065-143778995.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    是不是很简单。&lt;/p&gt;
&lt;p&gt;    大家如果希望了解详细的代码，请参考这个项目的GitHub地址：&lt;/p&gt;
&lt;p&gt;    &lt;a href=&quot;https://github.com/zhouguoqing/FlowControl&quot;&gt;https://github.com/zhouguoqing/FlowControl&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;    同时也欢迎大家一起改进完善。&lt;/p&gt;
&lt;p&gt;    谢谢大家。同时，最近在搞.Net Core的技术公众号，定期整理收集最新的.Net Core技术文章，欢迎大家关注。&lt;/p&gt;
&lt;p&gt;    &lt;img src=&quot;https://img2018.cnblogs.com/blog/23525/201908/23525-20190809234823375-2028843784.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;周国庆&lt;/p&gt;
&lt;p&gt;2019/8/9&lt;/p&gt;

</description>
<pubDate>Fri, 09 Aug 2019 15:51:00 +0000</pubDate>
<dc:creator>Eric zhou</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tianqing/p/11328969.html</dc:identifier>
</item>
<item>
<title>如何为 caddy 添写自定义插件 - abser</title>
<link>http://www.cnblogs.com/abser/p/11330130.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/abser/p/11330130.html</guid>
<description>&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/yhyddr/quicksilver/tree/master/gosample/caddy-plugin&quot; class=&quot;uri&quot;&gt;https://github.com/yhyddr/quicksilver/tree/master/gosample/caddy-plugin&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;Caddy附带一个HTTP服务器，但是你可以实现其他服务器类型并将它们插入Caddy中。其他类型的服务器可以是SSH、SFTP、TCP、内部使用的其他东西等等。&lt;/p&gt;&lt;p&gt;对于Caddy来说，服务器的概念是任何可以&lt;code&gt;Listen()&lt;/code&gt;和&lt;code&gt;Serve()&lt;/code&gt;的东西。这意味着什么、如何运作都取决于你。你可以自由地发挥你的创造力去使用它。&lt;/p&gt;&lt;p&gt;那么怎样去扩展 Caddy 呢？&lt;br/&gt;不同的服务器类型，可以根据自己的需要定制不同的插件。我们在这里，通过添加最简单的不做任何事的插件，来熟悉如何扩展 Caddy 服务器。&lt;br/&gt;&lt;/p&gt;

&lt;h2 id=&quot;plugin-for-http&quot;&gt;Plugin for HTTP&lt;/h2&gt;
&lt;p&gt;我们会一步一步构建出一个 HTTP Plugin 的框架，到时候你只需要填充自己处理逻辑即可！那还等什么，让我们开始吧。&lt;/p&gt;&lt;p&gt;构建一个 HTTP Plugin ，代码部分仅需要两步，注意事项也有两个。&lt;br/&gt;&lt;/p&gt;

&lt;h3 id=&quot;创建一个-go-package&quot;&gt;创建一个 Go Package&lt;/h3&gt;
&lt;p&gt;首先为 caddy 创建一个 插件的 Go Package ，你可以新建一个文件夹达到这个效果。比如&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;├── caddy-plugin
│   ├── gizmo.go
│   └── setup.go&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里分为了两个 Go 文件，接下来详细讲每一个 Go 文件的作用。&lt;/p&gt;

&lt;h3 id=&quot;代码注册-caddy-plugin&quot;&gt;代码🀙：注册 caddy plugin&lt;/h3&gt;
&lt;p&gt;首先我们看到 setup.go&lt;/p&gt;

&lt;h4 id=&quot;setup.go&quot;&gt;setup.go&lt;/h4&gt;
&lt;p&gt;创建 setup.go 文件并写入以下信息&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;import &quot;github.com/mholt/caddy&quot;

func init() {
    caddy.RegisterPlugin(&quot;gizmo&quot;, caddy.Plugin{
        ServerType: &quot;http&quot;,
        Action:     setup,
    })
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里是 建立了一个新插件，caddy 包来做到插件的注册。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;注意到 “gizmo” 这是 插件的名字，同时也是指令的名字，请为你的插件取一个独一无二的名字吧。（注意：名字需要是单词小写哦。）&lt;/li&gt;
&lt;li&gt;因为是针对 HTTP 服务器的插件，所以 ServerType 字段值是 “http”&lt;/li&gt;
&lt;li&gt;另一个设置的字段是 setup ，实际上，我们接下来会填充这个函数的逻辑。它的作用就是将我们插件的处理逻辑安装到 Caddy 中。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;setup&quot;&gt;setup&lt;/h4&gt;
&lt;p&gt;现在我们来实现 setup 函数 &lt;/p&gt;&lt;p&gt;假如我们希望在Caddyfile中有一行这样的行：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;gizmo foobar&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;br/&gt;我们可以得到刚才所说的 &lt;code&gt;c.Next()&lt;/code&gt; 第一个参数(“foobar”)的值，如下所示：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;for c.Next() {              // skip the directive name
    if !c.NextArg() {       // expect at least one value
        return c.ArgErr()   // otherwise it's an error
    }
    value := c.Val()        // use the value
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们首先注意到， c.Next() 是真正我们读取 caddyfile 逻辑的地方，caddyfile 就是配置服务器的配置文件的名字。我们注意到，这里的操作实际上是使用 caddy.Controller 来实现的。它的存在 让编写插件的开发者只需要关注如何使用它来执行你的命令，这是一项优秀的设计，有兴趣可以看我的源码阅读部分关于 Plugin 的具体实现。&lt;/p&gt;
&lt;p&gt;在 Caddy 解析了Caddyfile之后，它将迭代每个指令名(按照服务器类型规定的顺序)，并在每次遇到指令名时调用指令的setup函数。setup函数的职责是解析指令的标识并配置自己。&lt;/p&gt;&lt;p&gt;您可以通过遍历&lt;code&gt;c.Next()&lt;/code&gt;来解析为指令提供的标识，只要有更多的标识需要解析，那么&lt;code&gt;c.Next()&lt;/code&gt;就会返回&lt;code&gt;true&lt;/code&gt;。由于一个指令可能出现多次，你必须遍历&lt;code&gt;c.Next()&lt;/code&gt;以获得所有出现的指令并使用第一个标识(即指令名)。&lt;br/&gt;有关caddyfile包，请参阅&lt;a href=&quot;https://godoc.org/github.com/mholt/caddy/caddyfile&quot;&gt;godoc&lt;/a&gt;以了解如何更充分地使用分发器，并查看任何其他现有插件。&lt;/p&gt;

&lt;h3 id=&quot;代码-handler-实现&quot;&gt;代码 🀚：Handler 实现&lt;/h3&gt;

&lt;h4 id=&quot;gizmo.go&quot;&gt;gizmo.go：&lt;/h4&gt;
&lt;p&gt;查看&lt;a href=&quot;http://godoc.org/github.com/mholt/caddy/caddyhttp/httpserver&quot;&gt;httpserver包的godoc&lt;/a&gt;。最重要的两种类型是&lt;a href=&quot;https://godoc.org/github.com/mholt/caddy/caddyhttp/httpserver#Handler&quot;&gt;httpserver.Handler&lt;/a&gt;和&lt;a href=&quot;https://godoc.org/github.com/mholt/caddy/caddyhttp/httpserver#Middleware&quot;&gt;httpserver.Middleware&lt;/a&gt;。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;Handler&lt;/code&gt;是一个处理HTTP请求的函数。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Middleware&lt;/code&gt;是一种连接&lt;code&gt;Handler&lt;/code&gt;的方式。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Caddy将负责为你设置HTTP服务器的所有簿记(bookkeeping)工作，但是你需要实现这两种类型。&lt;br/&gt;&lt;/p&gt;

&lt;h4 id=&quot;struct&quot;&gt;Struct&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;httpserver.Handler&lt;/code&gt;是一个几乎和&lt;code&gt;http.Handler&lt;/code&gt;完全一样的接口，除了&lt;code&gt;ServeHTTP&lt;/code&gt;方法返回&lt;code&gt;(int, error)&lt;/code&gt;。&lt;br/&gt;这个方法签名遵循Go语言博客中&lt;a href=&quot;http://blog.golang.org/error-handling-and-go&quot;&gt;关于与中间件相关的错误处理的建议&lt;/a&gt;。&lt;br/&gt;&lt;code&gt;int&lt;/code&gt;是HTTP状态码，&lt;code&gt;error&lt;/code&gt;应该被处理和/或记录。有关这些返回值的详细信息，请参阅godoc。&lt;/p&gt;&lt;p&gt;&lt;code&gt;Handler&lt;/code&gt;通常是一个结构体，至少包含一个&lt;code&gt;Next&lt;/code&gt;字段，用来链接下一个&lt;code&gt;Handler&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;type gizmoHandler struct {
    next httpserver.Handler
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;br/&gt;除了这些之外，可以添加一些自己使用的参数，考虑 grpc 的 plugin 实现，解释放在代码块中的注释中&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;type server struct {
    backendAddr       string // 监听地址
    next              httpserver.Handler // 作为中间件必须有的字段
    backendIsInsecure bool // 是否启用 Insecure() 选项，是 grpc 的一项配置
    backendTLS        *tls.Config // 关于 TLS 的使用的证书文件
    wrappedGrpc       *grpcweb.WrappedGrpcServer // 通过 grpcweb 的 协议实现 HTTP 请求等
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这就是参考的一个 字段的使用。可以根据自己的需要，调整在 caddyfile 中读取的指令应该如何配置。&lt;/p&gt;

&lt;h4 id=&quot;httpserver.handler&quot;&gt;httpserver.Handler&lt;/h4&gt;
&lt;p&gt;为了实现&lt;code&gt;httpserver.Handler&lt;/code&gt;接口，我们需要编写一个名为&lt;code&gt;ServeHTTP&lt;/code&gt;的方法。这个方法是实际的处理程序函数，除非它自己处理完毕请求，否则它应该调用链中的下一个&lt;code&gt;Handler&lt;/code&gt;：即使用 &lt;code&gt;g.next.ServeHTTP(w, r)&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func (g gizmoHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) (int, error) {
    return g.next.ServeHTTP(w, r)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里只是框架，具体逻辑可以自行填充，可以参照已有的 Plugin 实现。&lt;br/&gt;&lt;/p&gt;

&lt;h4 id=&quot;第二步注册-middleware&quot;&gt;第二步，注册 Middleware&lt;/h4&gt;
&lt;p&gt;然后我们可以进行第二步，将这个 handler 注册到整个 caddy 的 http 调用链上。&lt;/p&gt;
&lt;p&gt;我们需要回到 刚才的 setup.go 文件中，&lt;br/&gt;回到设置函数。你刚刚解析了标识并使用所有适当的配置设置了中间件处理程序：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func setup(c *caddy.Controller) error {
    g := gizmoHandler{} // 用来实现 HTTPHandler 的 next 的结构，用来构建 中间件。也可以加入一些自己的字段

    for c.Next() {
        // 获取配置文件，并处理
    }
    // 现在开始注册中间件
    httpserver.GetConfig(c).AddMiddleware(func(next httpserver.Handler) httpserver.Handler {
        g.next = next
        return g
    })
    
    return nil
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样，代码部分就全部完成了。&lt;/p&gt;
&lt;p&gt;下面我们查看需要注意的事项。实际上是关乎于怎样将写好的插件集成在 caddy 中。&lt;/p&gt;

&lt;h3 id=&quot;排序&quot;&gt;排序&lt;/h3&gt;
&lt;p&gt;要做的事情是告诉服务器类型在进程的什么地方执行你的指令。这一点很重要，因为其他指令可能会设置你所依赖的更原始的配置，因此执行指令的顺序不能是随意的。&lt;/p&gt;&lt;p&gt;每个服务器类型都有一个字符串列表，其中每个项都是一个指令的名称。例如，查看&lt;a href=&quot;https://github.com/mholt/caddy/blob/d3860f95f59b5f18e14ddf3d67b4c44dbbfdb847/caddyhttp/httpserver/plugin.go#L314-L355&quot;&gt;HTTP服务器支持的指令列表&lt;/a&gt;。将指令添加到适当的位置。&lt;br/&gt;&lt;/p&gt;

&lt;h2 id=&quot;插入你的插件&quot;&gt;插入你的插件&lt;/h2&gt;
&lt;p&gt;最后，不要忘记导入你的插件包！Caddy必须导入插件来注册并执行它。这通常是在&lt;a href=&quot;https://github.com/mholt/caddy/blob/master/caddy/caddymain/run.go&quot;&gt;run.go&lt;/a&gt;的&lt;code&gt;import&lt;/code&gt;部分的尾部完成的：&lt;br/&gt;&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;_ &quot;your/plugin/package/here&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;请注意：包名前的&lt;code&gt;_&lt;/code&gt;是必需的。&lt;/p&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;就是这样！可以用你的插件来构建caddy，然后用你的新指令写一个Caddyfile来查看它的运行情况。&lt;br/&gt;虽然还没完善的她只是一个框架，还不能做任何事情，但是她很简单，很美不是吗？她能帮你做任何事情。因为记住 caddy 的服务器是设置的非常抽象的。她就想 net 包中 conn 一样完美的 接口设计，能够兼容和扩展任何 需要 listen()  和 serve() 的东西，只要你的创造力足够。&lt;/p&gt;&lt;p&gt;现在，发挥你的想象力，填充这个框架吧，可以参考我的简单项目地址。&lt;br/&gt;项目地址：&lt;a href=&quot;https://github.com/yhyddr/quicksilver/tree/master/gosample/caddy-plugin&quot; class=&quot;uri&quot;&gt;https://github.com/yhyddr/quicksilver/tree/master/gosample/caddy-plugin&lt;/a&gt;&lt;/p&gt;&lt;p&gt;同时记得多多寻找别人的插件实现方式，你会找到让你耳目一新的实现。&lt;a href=&quot;https://www.yuque.com/fengyfei/idznuk/sumapn&quot; class=&quot;uri&quot;&gt;https://www.yuque.com/fengyfei/idznuk/sumapn&lt;/a&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2019/png/176280/1565363529670-bb10335a-9c42-41b6-9098-8230757271df.png#align=left&amp;amp;display=inline&amp;amp;height=103&amp;amp;name=image.png&amp;amp;originHeight=103&amp;amp;originWidth=508&amp;amp;size=17436&amp;amp;status=done&amp;amp;width=508&quot; alt=&quot;image.png&quot;/&gt;&lt;br/&gt;我刚编辑过哦&lt;br/&gt;&lt;a href=&quot;https://github.com/caddyserver/caddy/wiki/Writing-a-Plugin:-Directives&quot; class=&quot;uri&quot;&gt;https://github.com/caddyserver/caddy/wiki/Writing-a-Plugin:-Directives&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://github.com/caddyserver/caddy/wiki/Writing-a-Plugin:-Server-Type&quot; class=&quot;uri&quot;&gt;https://github.com/caddyserver/caddy/wiki/Writing-a-Plugin:-Server-Type&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://github.com/caddyserver/caddy/wiki/Writing-a-Plugin:-HTTP-Middleware&quot; class=&quot;uri&quot;&gt;https://github.com/caddyserver/caddy/wiki/Writing-a-Plugin:-HTTP-Middleware&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 09 Aug 2019 15:47:00 +0000</pubDate>
<dc:creator>abser</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/abser/p/11330130.html</dc:identifier>
</item>
<item>
<title>暴风雨中的 online ：.net core 版博客站点遭遇的高并发问题进展 - 博客园团队</title>
<link>http://www.cnblogs.com/cmt/p/11328141.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cmt/p/11328141.html</guid>
<description>&lt;p&gt;今天暴风雨袭击了杭州，而昨天暴风雨（高并发问题）席卷了园子，留下一片狼藉。&lt;/p&gt;
&lt;p&gt;在前天傍晚，我们进行了 .net core 版博客站点的&lt;a href=&quot;https://www.cnblogs.com/cmt/p/11316324.html&quot; target=&quot;_blank&quot;&gt;第二次发布尝试&lt;/a&gt;，在发布后通过 kestrel 直接监听取代 nginx 转发解决了高并发下的1秒延迟问题，成功地顶住了下班前的访问小高峰，但这只是一场大雨，第二天的上午和下午的暴风雨（访问高峰中的高并发）才是真正的考验。&lt;/p&gt;
&lt;p&gt;昨天，面对暴风雨，我们哼都不敢哼一声“让暴风雨来得更猛烈些吧”，只是一直不停地默念“让暴风雨快点过去吧”，尤其在下午的暴风雨袭击下，跑在 docker swarm 上 .net core 版博客系统溃不成军，大量请求响应速度极不稳定，时而快如闪电（10ms左右），时而慢如蜗牛（10s, 30s 甚至超时）。与&lt;a href=&quot;https://www.cnblogs.com/cmt/p/11302666.html&quot; target=&quot;_blank&quot;&gt;第一次发布&lt;/a&gt;时不一样，不仅博客应用容器外是暴风雨，容器内也是暴风雨，在容器内用 curl 命令访问与外部用浏览器访问问题一样（难不成真的是 docker swarm 网络的问题？kestrel 监听取代 nginx 转发只是将网络并发负载从 nginx 容器转到了 kestrel 所在的博客应用容器。。。有待验证。）&lt;/p&gt;
&lt;p&gt;昨天 17:30 左右并发量回落到一定程度之后，暴风雨飘然而去，园中立刻风平浪静，晴空万里，下午的那场暴风雨宛如梦中。&lt;/p&gt;
&lt;p&gt;在暴风雨过后，我们查看了服务器的 linux 系统日志，发现很多下面的日志，而且都发生在暴风雨期间。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
Aug  8 15:57:12 blog-swarm-n3 kernel: nf_conntrack: table full, dropping packet
Aug  8 15:57:12 blog-swarm-n3 kernel: nf_conntrack: table full, dropping packet
Aug  8 15:57:12 blog-swarm-n3 kernel: nf_conntrack: table full, dropping packet
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当时 docker swarm 集群中一共5台 worker 节点服务器，统计了一下每台服务器出现 &quot;table full&quot; 日志的数量。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
blog-swarm-n3: 2149
blog-swarm-n4: 1964
blog-swarm-n5: 2451
blog-swarm-n6: 2095
blog-swarm-n7: 0
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;咦，怎么有1台服务器为0？哦，原来是这台没有挂上所有负载均衡，只承受了 2/3 左右的流量，虽然下的暴风雨，但对这台服务器来说只是一场大雨。&lt;/p&gt;
&lt;p&gt;针对上面的日志，昨天我们晚上我们调整了 linux 内核的 2 个设置置（&lt;a href=&quot;https://help.aliyun.com/knowledge_detail/41334.html&quot; target=&quot;_blank&quot;&gt;参考文档&lt;/a&gt;），在 /etc/sysctl.conf 中添加&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
net.netfilter.nf_conntrack_max = 655350
net.netfilter.nf_conntrack_tcp_timeout_established = 1200
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个调整成为我们今天唯一的希望，但早上访问高峰来临的时候，迎接我们的不是喜出望外，而是昔日重来。。。&lt;/p&gt;
&lt;p&gt;在熟悉的暴风雨面前，我们面临着艰难的选择，放弃-退回 windows 上的 .net framework 版博客系统，还是坚持-至少要找到一种能抵挡一定程度暴风雨的临时解决方法？&lt;/p&gt;
&lt;p&gt;那台没有 &quot;table full&quot; 日志的服务器给了我们启发——分而治之，将暴风雨变成每一台服务器的大雨，拆分流量到不同的服务器，减少每台服器的并发连接数，今天就是通过这个临时的笨方法扛住了暴风雨，大量减少了响应速度慢的情况，所以到现在 .net core 版博客站点依然在线。&lt;/p&gt;
&lt;p&gt;在抗过了今天上下午访问高峰的暴风雨后，杭州也被暴风雨袭击了，因为有了房子，任凭外面风吹雨打，我们可以坐在房间里一边敲着代码，一边凝听窗外的风声雨声。对于这次遇到的高并发问题，我们相信总有一天会为我们的博客系统建造好房子，在暴风雨的风吹雨打中潇洒地在日志中写着“让暴风雨来得更猛烈些吧”。&lt;/p&gt;
</description>
<pubDate>Fri, 09 Aug 2019 15:09:00 +0000</pubDate>
<dc:creator>博客园团队</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cmt/p/11328141.html</dc:identifier>
</item>
<item>
<title>[Spring cloud 一步步实现广告系统] 15. 使用开源组件监听Binlog 实现增量索引准备 - IsaacZhang</title>
<link>http://www.cnblogs.com/zhangpan1244/p/11329817.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangpan1244/p/11329817.html</guid>
<description>&lt;h6 id=&quot;mysql-binlog简介&quot;&gt;MySQL Binlog简介&lt;/h6&gt;
&lt;ul&gt;&lt;li&gt;什么是binlog?&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;一个二进制日志，用来记录对数据发生或潜在发生更改的SQL语句，并以而进行的形式保存在磁盘中。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;binlog 的作用？&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;最主要有3个用途：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;数据复制（主从同步）&lt;br/&gt;Mysql 的Master-Slave协议，让Slave可以通过监听binlog实现数据复制，达到数据一致性目的&lt;/li&gt;
&lt;li&gt;数据恢复&lt;br/&gt;通过mysqlbinlog工具恢复数据&lt;/li&gt;
&lt;li&gt;增量备份&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;Binlog 变量
&lt;ul&gt;&lt;li&gt;log_bin (Binlog 开关，使用&lt;code&gt;show variables like 'log_bin';&lt;/code&gt;查看)&lt;/li&gt;
&lt;li&gt;binlog_format (Binlog 日志格式，使用&lt;code&gt;show variables like 'binlog_format';&lt;/code&gt;查看)&lt;br/&gt;日志格式总共有三种：
&lt;ul&gt;&lt;li&gt;ROW， 仅保存记录被修改的细节，不记录SQL语句上下文相关信息。（能清晰的记录下每行数据的修改细节，不需要记录上下文相关信息，因此不会发生某些特定情况下的procedure、function以及trigger 的调用无法被准确复制的问题，任何情况下都可以被复制，且能加快从库重放日志的效率，保证从库数据的一致性）&lt;/li&gt;
&lt;li&gt;STATEMENT，每一条修改数据的SQL都会被记录。（只记录执行语句的细节和上下文环境，避免了记录每一行的变化，在一些修改记录较多的情况下，相比ROW类型能大大减少binlog的日志量，节约IO,提高性能。还可以用于实时的还原，同时主从版本可以不一样，从服务器版本可以比主服务器版本高）&lt;/li&gt;
&lt;li&gt;MIXED， 上述2种的混合使用&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Binlog 管理
&lt;ul&gt;&lt;li&gt;show master logs; 查看所有binlog的日志列表&lt;/li&gt;
&lt;li&gt;show master status; 查看最后一个binlog日志编号名称，以及最后一个事件技术的位置（position）&lt;/li&gt;
&lt;li&gt;Flush logs; 刷新binlog,此刻开始产生一个新编号的binlog日志文件&lt;/li&gt;
&lt;li&gt;reset master; 清空所有的binlog日志&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Binlog 相关SQL &lt;code&gt;show binlog events[in 'log_name'][from position][limit [offset,]row_count]&lt;/code&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/48397/201908/48397-20190809220215062-544245512.png&quot; alt=&quot;UTOOLS1565224352749.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/48397/201908/48397-20190809220217515-1161611660.png&quot; alt=&quot;UTOOLS1565224799877.png&quot;/&gt;&lt;/li&gt;
&lt;li&gt;常用的Binlog event
&lt;ul&gt;&lt;li&gt;QUERY - 与数据无关的操作，begin、drop table、truncate table等等&lt;/li&gt;
&lt;li&gt;&lt;em&gt;TABLE_MAP&lt;/em&gt; - 记录下一个操作所对应的表信息，存储了数据库名称和表名称&lt;/li&gt;
&lt;li&gt;XID - 标记事务提交&lt;/li&gt;
&lt;li&gt;WRITE_ROWS 插入数据，即insert操作&lt;/li&gt;
&lt;li&gt;UPDATE_ROWS 更新数据，即update操作&lt;/li&gt;
&lt;li&gt;DELETE_ROWS 删除数据，即delete操作&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;Event包含header和data两部分，header提供了event的创建时间，哪个服务器等信息，data部分提供的是针对该event的具体信息，如具体数据的修改。&lt;br/&gt;&lt;em&gt;Tip: binlog不会记录数据表的列名&lt;/em&gt;&lt;br/&gt;在接下来的实现中，我们会将自己的系统包装成一个假的Mysql Slave，通过开源工具&lt;code&gt;mysql-binlog-connector-java&lt;/code&gt;来实现监听binlog。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h6 id=&quot;开源工具mysql-binlog-connector-java&quot;&gt;开源工具&lt;code&gt;mysql-binlog-connector-java&lt;/code&gt;&lt;/h6&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;!-- binlog 日志监听,解析开源工具类库 --&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;com.github.shyiko&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;mysql-binlog-connector-java&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;0.18.1&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.创建一个测试接口&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.sxzhongf.ad.service;

import com.github.shyiko.mysql.binlog.BinaryLogClient;
import com.github.shyiko.mysql.binlog.event.DeleteRowsEventData;
import com.github.shyiko.mysql.binlog.event.EventData;
import com.github.shyiko.mysql.binlog.event.UpdateRowsEventData;
import com.github.shyiko.mysql.binlog.event.WriteRowsEventData;

import java.io.IOException;

/**
 * BinlogServiceTest for 测试Mysql binlog 监控
 * {@code
 * Mysql8 连接提示 Client does not support authentication protocol requested by server; consider upgrading MySQL client 解决方法
 * USE mysql;
 * ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY 'password';
 * FLUSH PRIVILEGES;
 * }
 *
 * @author &amp;lt;a href=&quot;mailto:magicianisaac@gmail.com&quot;&amp;gt;Isaac.Zhang | 若初&amp;lt;/a&amp;gt;
 */
public class BinlogServiceTest {

    /**
     * --------Update-----------
     * UpdateRowsEventData{tableId=90, includedColumnsBeforeUpdate={0, 1, 2, 3, 4, 5, 6, 7}, includedColumns={0, 1, 2, 3, 4, 5, 6, 7}, rows=[
     *     {before=[11, 10, Test Bin Log, 1, Tue Jun 25 08:00:00 CST 2019, Tue Jun 25 08:00:00 CST 2019, Tue Jun 25 08:00:00 CST 2019, Tue Jun 25 08:00:00 CST 2019], after=[11, 10, zhangpan test Binlog, 1, Tue Jun 25 08:00:00 CST 2019, Tue Jun 25 08:00:00 CST 2019, Tue Jun 25 08:00:00 CST 2019, Tue Jun 25 08:00:00 CST 2019]}
     * ]}
     *
     * --------Insert-----------
     * WriteRowsEventData{tableId=91, includedColumns={0, 1, 2, 3, 4, 5, 6, 7}, rows=[
     *     [10, 11, ad unit test binlog, 1, 0, 1236.7655, Thu Jun 27 08:00:00 CST 2019, Thu Jun 27 08:00:00 CST 2019]
     * ]}
     */

    public static void main(String[] args) throws IOException {

//        //构造BinaryLogClient，填充mysql链接信息
        BinaryLogClient client = new BinaryLogClient(&quot;127.0.0.1&quot;, 3306,
                &quot;root&quot;, &quot;12345678&quot;
        );

        //设置需要读取的Binlog的文件以及位置，否则，client会从&quot;头&quot;开始读取Binlog并监听
//        client.setBinlogFilename(&quot;binlog.000035&quot;);
//        client.setBinlogPosition();

        //给客户端注册监听器，实现对Binlog的监听和解析
        //event 就是监听到的Binlog变化信息，event包含header &amp;amp; data 两部分
        client.registerEventListener(event -&amp;gt; {
            EventData data = event.getData();
            if (data instanceof UpdateRowsEventData) {
                System.out.println(&quot;--------Update-----------&quot;);
                System.out.println(data.toString());
            } else if (data instanceof WriteRowsEventData) {
                System.out.println(&quot;--------Insert-----------&quot;);
                System.out.println(data.toString());
            } else if (data instanceof DeleteRowsEventData) {
                System.out.println(&quot;--------Delete-----------&quot;);
                System.out.println(data.toString());
            }
        });

        client.connect();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;八月 08, 2019 9:13:32 上午 com.github.shyiko.mysql.binlog.BinaryLogClient connect
信息: Connected to 127.0.0.1:3306 at binlog.000038/951 (sid:65535, cid:336)
...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行sql &lt;code&gt;update ad_user set user_status=1 where user_id=10;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/48397/201908/48397-20190809220218302-1685596787.png&quot; alt=&quot;UTOOLS1565227012106.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们需要知道的是，我们的目的是实现对Mysql数据表的变更实现监听，并解析成我们想要的格式，也就是我们的java对象。根据上面我们看到的监听结果，我们知道了返回信息的大概内容，既然我们已经学会了简单的使用BinaryLogClient 来监听binlog，接下来，我们需要定义一个监听器，来实现我们自己的业务内容。&lt;/p&gt;
&lt;p&gt;因为我们只需要Event中的内容，那么我们也就只需要通过实现&lt;code&gt;com.github.shyiko.mysql.binlog.BinaryLogClient.EventListener&lt;/code&gt;接口，来自定义一个监听器实现我们的业务即可。通过Event的内容，来判定是否需要处理当前event以及如何处理。&lt;/p&gt;
&lt;h6 id=&quot;构造解析binlog的模版文件&quot;&gt;构造解析binlog的模版文件&lt;/h6&gt;
&lt;p&gt;我们监听binlog来构造增量数据的根本原因，是为了将我们的&lt;code&gt;广告投放系统&lt;/code&gt;和&lt;code&gt;广告检索系统&lt;/code&gt; 业务解耦，由于我们的检索系统中没有定义数据库以及数据表的相关，所以，我们通过定义一份模版文件，通过解析模版文件来得到我们需要的数据库和表信息，因为binlog的监听是不区分是哪个数据库和哪个数据表信息的，我们可以通过模版来指定我们想要监听的部分。&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
  &quot;database&quot;: &quot;advertisement&quot;,
  &quot;tableList&quot;: [
    {
      &quot;tableName&quot;: &quot;ad_plan&quot;,
      &quot;level&quot;: 2,
      &quot;insert&quot;: [
        {
          &quot;column&quot;: &quot;plan_id&quot;
        },
        {
          &quot;column&quot;: &quot;user_id&quot;
        },
        {
          &quot;column&quot;: &quot;plan_status&quot;
        },
        {
          &quot;column&quot;: &quot;start_date&quot;
        },
        {
          &quot;column&quot;: &quot;end_date&quot;
        }
      ],
      &quot;update&quot;: [
        {
          &quot;column&quot;: &quot;plan_id&quot;
        },
        {
          &quot;column&quot;: &quot;user_id&quot;
        },
        {
          &quot;column&quot;: &quot;plan_status&quot;
        },
        {
          &quot;column&quot;: &quot;start_date&quot;
        },
        {
          &quot;column&quot;: &quot;end_date&quot;
        }
      ],
      &quot;delete&quot;: [
        {
          &quot;column&quot;: &quot;plan_id&quot;
        }
      ]
    },
    {
      &quot;tableName&quot;: &quot;ad_unit&quot;,
      &quot;level&quot;: 3,
      &quot;insert&quot;: [
        {
          &quot;column&quot;: &quot;unit_id&quot;
        },
        {
          &quot;column&quot;: &quot;unit_status&quot;
        },
        {
          &quot;column&quot;: &quot;position_type&quot;
        },
        {
          &quot;column&quot;: &quot;plan_id&quot;
        }
      ],
      &quot;update&quot;: [
        {
          &quot;column&quot;: &quot;unit_id&quot;
        },
        {
          &quot;column&quot;: &quot;unit_status&quot;
        },
        {
          &quot;column&quot;: &quot;position_type&quot;
        },
        {
          &quot;column&quot;: &quot;plan_id&quot;
        }
      ],
      &quot;delete&quot;: [
        {
          &quot;column&quot;: &quot;unit_id&quot;
        }
      ]
    },
    {
      &quot;tableName&quot;: &quot;ad_creative&quot;,
      &quot;level&quot;: 2,
      &quot;insert&quot;: [
        {
          &quot;column&quot;: &quot;creative_id&quot;
        },
        {
          &quot;column&quot;: &quot;type&quot;
        },
        {
          &quot;column&quot;: &quot;material_type&quot;
        },
        {
          &quot;column&quot;: &quot;height&quot;
        },
        {
          &quot;column&quot;: &quot;width&quot;
        },
        {
          &quot;column&quot;: &quot;audit_status&quot;
        },
        {
          &quot;column&quot;: &quot;url&quot;
        }
      ],
      &quot;update&quot;: [
        {
          &quot;column&quot;: &quot;creative_id&quot;
        },
        {
          &quot;column&quot;: &quot;type&quot;
        },
        {
          &quot;column&quot;: &quot;material_type&quot;
        },
        {
          &quot;column&quot;: &quot;height&quot;
        },
        {
          &quot;column&quot;: &quot;width&quot;
        },
        {
          &quot;column&quot;: &quot;audit_status&quot;
        },
        {
          &quot;column&quot;: &quot;url&quot;
        }
      ],
      &quot;delete&quot;: [
        {
          &quot;column&quot;: &quot;creative_id&quot;
        }
      ]
    },
    {
      &quot;tableName&quot;: &quot;relationship_creative_unit&quot;,
      &quot;level&quot;: 3,
      &quot;insert&quot;: [
        {
          &quot;column&quot;: &quot;creative_id&quot;
        },
        {
          &quot;column&quot;: &quot;unit_id&quot;
        }
      ],
      &quot;update&quot;: [
      ],
      &quot;delete&quot;: [
        {
          &quot;column&quot;: &quot;creative_id&quot;
        },
        {
          &quot;column&quot;: &quot;unit_id&quot;
        }
      ]
    },
    {
      &quot;tableName&quot;: &quot;ad_unit_district&quot;,
      &quot;level&quot;: 4,
      &quot;insert&quot;: [
        {
          &quot;column&quot;: &quot;unit_id&quot;
        },
        {
          &quot;column&quot;: &quot;province&quot;
        },
        {
          &quot;column&quot;: &quot;city&quot;
        }
      ],
      &quot;update&quot;: [
      ],
      &quot;delete&quot;: [
        {
          &quot;column&quot;: &quot;unit_id&quot;
        },
        {
          &quot;column&quot;: &quot;province&quot;
        },
        {
          &quot;column&quot;: &quot;city&quot;
        }
      ]
    },
    {
      &quot;tableName&quot;: &quot;ad_unit_hobby&quot;,
      &quot;level&quot;: 4,
      &quot;insert&quot;: [
        {
          &quot;column&quot;: &quot;unit_id&quot;
        },
        {
          &quot;column&quot;: &quot;hobby_tag&quot;
        }
      ],
      &quot;update&quot;: [
      ],
      &quot;delete&quot;: [
        {
          &quot;column&quot;: &quot;unit_id&quot;
        },
        {
          &quot;column&quot;: &quot;hobby_tag&quot;
        }
      ]
    },
    {
      &quot;tableName&quot;: &quot;ad_unit_keyword&quot;,
      &quot;level&quot;: 4,
      &quot;insert&quot;: [
        {
          &quot;column&quot;: &quot;unit_id&quot;
        },
        {
          &quot;column&quot;: &quot;keyword&quot;
        }
      ],
      &quot;update&quot;: [
      ],
      &quot;delete&quot;: [
        {
          &quot;column&quot;: &quot;unit_id&quot;
        },
        {
          &quot;column&quot;: &quot;keyword&quot;
        }
      ]
    }
  ]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的模版文件中，指定了一个数据库为&lt;code&gt;advertisement&lt;/code&gt;，大家可以方便添加多个监听库。在数据库下面，我们监听了几个表的CUD操作以及每个操作所需要的字段信息。&lt;/p&gt;
&lt;ul readability=&quot;55.5&quot;&gt;&lt;li readability=&quot;114&quot;&gt;实现模版 —&amp;gt; Java Entity
&lt;ul&gt;&lt;li&gt;定义模版文件对应的实体&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Data
@AllArgsConstructor
@NoArgsConstructor
public class BinlogTemplate {
      //单数据库对应
    private String database;
      //多表
    private List&amp;lt;JsonTable&amp;gt; tableList;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;对应的json 中 table信息&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * JsonTable for 用于表示template.json中对应的表信息
 *
 * @author &amp;lt;a href=&quot;mailto:magicianisaac@gmail.com&quot;&amp;gt;Isaac.Zhang | 若初&amp;lt;/a&amp;gt;
 */
@Data
@AllArgsConstructor
@NoArgsConstructor
public class JsonTable {
    private String tableName;
    private Integer level;

    private List&amp;lt;Column&amp;gt; insert;
    private List&amp;lt;Column&amp;gt; update;
    private List&amp;lt;Column&amp;gt; delete;

    @Data
    @AllArgsConstructor
    @NoArgsConstructor
    public static class Column {
        private String columnName;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;读取的对应表信息对象（最主要目的就是为了能将&lt;code&gt;字段索引&lt;/code&gt; 映射到 &lt;code&gt;字段名称&lt;/code&gt;）&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Data
@AllArgsConstructor
@NoArgsConstructor
public class TableTemplate {
    private String tableName;
    private String level;

      //操作类型 -&amp;gt; 多列
    private Map&amp;lt;OperationTypeEnum, List&amp;lt;String&amp;gt;&amp;gt; opTypeFieldSetMap = new HashMap&amp;lt;&amp;gt;();

    /**
     * Binlog日志中 字段索引 -&amp;gt; 字段名称 的一个转换映射
     * 因为binlog中不会显示更新的列名是什么，它只会展示字段的索引，因此我们需要实现一次转换
     */
    private Map&amp;lt;Integer, String&amp;gt; posMap = new HashMap&amp;lt;&amp;gt;();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;解析模版文件到java对象&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Data
public class ParseCustomTemplate {

    private String database;

    /**
     * key -&amp;gt; TableName
     * value -&amp;gt; {@link TableTemplate}
     */
    private Map&amp;lt;String, TableTemplate&amp;gt; tableTemplateMap;

    public static ParseCustomTemplate parse(BinlogTemplate _template) {
        ParseCustomTemplate template = new ParseCustomTemplate();
        template.setDatabase(_template.getDatabase());

        for (JsonTable jsonTable : _template.getTableList()) {
            String name = jsonTable.getTableName();
            Integer level = jsonTable.getLevel();

            TableTemplate tableTemplate = new TableTemplate();
            tableTemplate.setTableName(name);
            tableTemplate.setLevel(level.toString());
            template.tableTemplateMap.put(name, tableTemplate);

            //遍历操作类型对应的列信息
            Map&amp;lt;OperationTypeEnum, List&amp;lt;String&amp;gt;&amp;gt; operationTypeListMap = tableTemplate.getOpTypeFieldSetMap();

            for (JsonTable.Column column : jsonTable.getInsert()) {
                getAndCreateIfNeed(
                        OperationTypeEnum.ADD,
                        operationTypeListMap,
                        ArrayList::new
                ).add(column.getColumnName());
            }

            for (JsonTable.Column column : jsonTable.getUpdate()) {
                getAndCreateIfNeed(
                        OperationTypeEnum.UPDATE,
                        operationTypeListMap,
                        ArrayList::new
                ).add(column.getColumnName());
            }

            for (JsonTable.Column column : jsonTable.getDelete()) {
                getAndCreateIfNeed(
                        OperationTypeEnum.DELETE,
                        operationTypeListMap,
                        ArrayList::new
                ).add(column.getColumnName());
            }
        }

        return template;
    }

    /**
     * 从Map中获取对象，如果不存在，创建一个
     */
    private static &amp;lt;T, R&amp;gt; R getAndCreateIfNeed(T key, Map&amp;lt;T, R&amp;gt; map, Supplier&amp;lt;R&amp;gt; factory) {
        return map.computeIfAbsent(key, k -&amp;gt; factory.get());
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;解析 字段索引 -&amp;gt; 字段名称 的一个转换映射&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;首先，我们来看一下binlog的具体日志信息：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;--------Insert-----------
WriteRowsEventData{tableId=91, includedColumns={0, 1, 2, 3, 4, 5, 6, 7}, rows=[
[10, 11, ad unit test binlog, 1, 0, 1236.7655, Thu Jun 27 08:00:00 CST 2019, Thu Jun 27 08:00:00 CST 2019]
--------Update-----------
UpdateRowsEventData{tableId=81, includedColumnsBeforeUpdate={0, 1, 2, 3, 4, 5}, includedColumns={0, 1, 2, 3, 4, 5}, rows=[
    {before=[10, Isaac Zhang, 2D3ABB6F2434109A105170FB21D00453, 0, Fri Jun 21 15:07:53 CST 2019, Fri Jun 21 15:07:53 CST 2019], after=[10, Isaac Zhang, 2D3ABB6F2434109A105170FB21D00453, 1, Fri Jun 21 15:07:53 CST 2019, Fri Jun 21 15:07:53 CST 2019]}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，在日志中&lt;code&gt;includedColumns&lt;/code&gt;只包含了&lt;code&gt;{0, 1, 2, 3, 4, 5}&lt;/code&gt;位置信息，那么我们怎么能知道它具体代表的是哪个字段呢，接下来我们来实现这步映射关系，在实现之前，我们先来查询一下数据库中我们的表中字段所处的具体位置：&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;sql&amp;gt; SELECT table_schema,table_name,column_name,ordinal_position FROM information_schema.COLUMNS
WHERE TABLE_SCHEMA = 'advertisement' AND TABLE_NAME='ad_user'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/48397/201908/48397-20190809220218853-487195296.png&quot; alt=&quot;UTOOLS1565311337937.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以看到&lt;code&gt;ordinal_position&lt;/code&gt;对应的是1-6，可是上面监听到的binlog日志索引是0-5，所以我们就可以看出来之间的对应关系。&lt;/p&gt;
&lt;p&gt;我们开始编码实现，我们使用&lt;code&gt;JdbcTemplate&lt;/code&gt;进行查询数据库信息：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Slf4j
@Component
public class TemplateHolder {
    private ParseCustomTemplate template;

    private final JdbcTemplate jdbcTemplate;

    private String SQL_SCHEMA = &quot;SELECT TABLE_SCHEMA,TABLE_NAME,COLUMN_NAME,ORDINAL_POSITION FROM information_schema.COLUMNS &quot; +
            &quot;WHERE TABLE_SCHEMA = ? AND TABLE_NAME = ?&quot;;

    @Autowired
    public TemplateHolder(JdbcTemplate jdbcTemplate) {
        this.jdbcTemplate = jdbcTemplate;
    }

    /**
     * 需要在容器加载的时候，就载入数据信息
     */
    @PostConstruct
    private void init() {
        loadJSON(&quot;template.json&quot;);
    }

    /**
     * 对外提供加载服务
     */
    public TableTemplate getTable(String tableName) {
        return template.getTableTemplateMap().get(tableName);
    }

    /**
     * 加载需要监听的binlog json文件
     */
    private void loadJSON(String path) {
        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
        InputStream inputStream = classLoader.getResourceAsStream(path);

        try {
            BinlogTemplate binlogTemplate = JSON.parseObject(
                    inputStream,
                    Charset.defaultCharset(),
                    BinlogTemplate.class
            );

            this.template = ParseCustomTemplate.parse(binlogTemplate);
            loadMeta();
        } catch (IOException ex) {
            log.error((ex.getMessage()));
            throw new RuntimeException(&quot;fail to parse json file&quot;);
        }
    }

    /**
     * 加载元信息
     * 使用表索引到列名称的映射关系
     */
    private void loadMeta() {
        for (Map.Entry&amp;lt;String, TableTemplate&amp;gt; entry : template.getTableTemplateMap().entrySet()) {
            TableTemplate table = entry.getValue();

            List&amp;lt;String&amp;gt; updateFields = table.getOpTypeFieldSetMap().get(
                    OperationTypeEnum.UPDATE
            );
            List&amp;lt;String&amp;gt; insertFields = table.getOpTypeFieldSetMap().get(
                    OperationTypeEnum.ADD
            );
            List&amp;lt;String&amp;gt; deleteFields = table.getOpTypeFieldSetMap().get(
                    OperationTypeEnum.DELETE
            );

            jdbcTemplate.query(SQL_SCHEMA, new Object[]{
                            template.getDatabase(), table.getTableName()
                    }, (rs, i) -&amp;gt; {
                        int pos = rs.getInt(&quot;ORDINAL_POSITION&quot;);
                        String colName = rs.getString(&quot;COLUMN_NAME&quot;);

                        if ((null != updateFields &amp;amp;&amp;amp; updateFields.contains(colName))
                            || (null != insertFields &amp;amp;&amp;amp; insertFields.contains(colName))
                            || (null != deleteFields &amp;amp;&amp;amp; deleteFields.contains(colName))) {
                                     table.getPosMap().put(pos - 1, colName);
                        }
                        return null;
                    }
            );
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;33&quot;&gt;&lt;li readability=&quot;69&quot;&gt;监听binlog实现
&lt;ul&gt;&lt;li&gt;定义Event 解析所需要转换的java对象&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Data
public class BinlogRowData {

    private TableTemplate tableTemplate;

    private EventType eventType;

    private List&amp;lt;Map&amp;lt;String, String&amp;gt;&amp;gt; before;

    private List&amp;lt;Map&amp;lt;String, String&amp;gt;&amp;gt; after;

}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;定义binlog client &lt;code&gt;BinaryLogClient&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * CustomBinlogClient for 自定义Binlog Client
 *
 * @author &amp;lt;a href=&quot;mailto:magicianisaac@gmail.com&quot;&amp;gt;Isaac.Zhang | 若初&amp;lt;/a&amp;gt;
 * @since 2019/6/27
 */
@Slf4j
@Component
public class CustomBinlogClient {

    private BinaryLogClient client;

    private final BinlogConfig config;
    private final AggregationListener listener;

    @Autowired
    public CustomBinlogClient(BinlogConfig config, AggregationListener listener) {
        this.config = config;
        this.listener = listener;
    }

    public void connect() {
        new Thread(() -&amp;gt; {
            client = new BinaryLogClient(
                    config.getHost(),
                    config.getPort(),
                    config.getUsername(),
                    config.getPassword()
            );

            if (!StringUtils.isEmpty(config.getBinlogName()) &amp;amp;&amp;amp; !config.getPosition().equals(-1L)) {
                client.setBinlogFilename(config.getBinlogName());
                client.setBinlogPosition(config.getPosition());
            }

            try {
                log.info(&quot;connecting to mysql start...&quot;);
                client.connect();
                log.info(&quot;connecting to mysql done!&quot;);
            } catch (IOException e) {
                e.printStackTrace();
            }
        }).start();
    }

    public void disconnect() {
        try {
            log.info(&quot;disconnect to mysql start...&quot;);
            client.disconnect();
            log.info(&quot;disconnect to mysql done!&quot;);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;使用client注册事件监听器&lt;code&gt;com.github.shyiko.mysql.binlog.BinaryLogClient.EventListener&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * Ilistener for 为了后续扩展不同的实现
 *
 * @author &amp;lt;a href=&quot;mailto:magicianisaac@gmail.com&quot;&amp;gt;Isaac.Zhang | 若初&amp;lt;/a&amp;gt;
 */
public interface Ilistener {

    void register();

    void onEvent(BinlogRowData eventData);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;em&gt;监听Binlog, 收集mysql binlog datas&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Slf4j
@Component
public class AggregationListener implements BinaryLogClient.EventListener {

    private String dbName;
    private String tbName;

    private Map&amp;lt;String, Ilistener&amp;gt; listenerMap = new HashMap&amp;lt;&amp;gt;();

    @Autowired
    private TemplateHolder templateHolder;

    private String genKey(String dbName, String tbName) {
        return dbName + &quot;:&quot; + tbName;
    }

    /**
     * 根据表实现注册信息
     */
    public void register(String dbName, String tbName, Ilistener listener) {
        log.info(&quot;register : {}-{}&quot;, dbName, tbName);
        this.listenerMap.put(genKey(dbName, tbName), listener);
    }

    @Override
    public void onEvent(Event event) {

        EventType type = event.getHeader().getEventType();
        log.info(&quot;Event type: {}&quot;, type);

        //数据库增删改之前，肯定有一个table_map event 的binlog
        if (type == EventType.TABLE_MAP) {
            TableMapEventData data = event.getData();
            this.tbName = data.getTable();
            this.dbName = data.getDatabase();
            return;
        }

        //EXT_UPDATE_ROWS 是Mysql 8以上的type
        if (type != EventType.EXT_UPDATE_ROWS
                &amp;amp;&amp;amp; type != EventType.EXT_WRITE_ROWS
                &amp;amp;&amp;amp; type != EventType.EXT_DELETE_ROWS
                ) {
            return;
        }

        // 检查表名和数据库名是否已经正确填充
        if (StringUtils.isEmpty(dbName) || StringUtils.isEmpty(tbName)) {
            log.error(&quot;Meta data got error. tablename:{},database:{}&quot;, tbName, dbName);
            return;
        }

        //找出对应数据表敏感的监听器
        String key = genKey(this.dbName, this.tbName);
        Ilistener ilistener = this.listenerMap.get(key);
        if (null == ilistener) {
            log.debug(&quot;skip {}&quot;, key);
        }

        log.info(&quot;trigger event:{}&quot;, type.name());

        try {
            BinlogRowData rowData = convertEventData2BinlogRowData(event.getData());
            if (null == rowData) {
                return;
            }
            rowData.setEventType(type);
            ilistener.onEvent(rowData);

        } catch (Exception e) {
            e.printStackTrace();
            log.error(e.getMessage());
        } finally {
            this.dbName = &quot;&quot;;
            this.tbName = &quot;&quot;;
        }
    }

    /**
     * 解析Binlog数据到Java实体对象的映射
     *
     * @param data binlog
     * @return java 对象
     */
    private BinlogRowData convertEventData2BinlogRowData(EventData data) {
        TableTemplate tableTemplate = templateHolder.getTable(tbName);
        if (null == tableTemplate) {
            log.warn(&quot;table {} not found.&quot;, tbName);
            return null;
        }

        List&amp;lt;Map&amp;lt;String, String&amp;gt;&amp;gt; afterMapList = new ArrayList&amp;lt;&amp;gt;();

        for (Serializable[] after : getAfterValues(data)) {
            Map&amp;lt;String, String&amp;gt; afterMap = new HashMap&amp;lt;&amp;gt;();

            int columnLength = after.length;
            for (int i = 0; i &amp;lt; columnLength; ++i) {
                //取出当前位置对应的列名
                String colName = tableTemplate.getPosMap().get(i);
                //如果没有，则说明不需要该列
                if (null == colName) {
                    log.debug(&quot;ignore position: {}&quot;, i);
                    continue;
                }

                String colValue = after[i].toString();
                afterMap.put(colName, colValue);
            }

            afterMapList.add(afterMap);
        }

        BinlogRowData binlogRowData = new BinlogRowData();
        binlogRowData.setAfter(afterMapList);
        binlogRowData.setTableTemplate(tableTemplate);

        return binlogRowData;
    }

    /**
     * 获取不同事件的变更后数据
     * Add &amp;amp; Delete变更前数据假定为空
     */
    private List&amp;lt;Serializable[]&amp;gt; getAfterValues(EventData eventData) {

        if (eventData instanceof WriteRowsEventData) {
            return ((WriteRowsEventData) eventData).getRows();
        }

        if (eventData instanceof UpdateRowsEventData) {
            return ((UpdateRowsEventData) eventData).getRows()
                                                    .stream()
                                                    .map(Map.Entry::getValue)
                                                    .collect(Collectors.toList()
                                                    );
        }

        if (eventData instanceof DeleteRowsEventData) {
            return ((DeleteRowsEventData) eventData).getRows();
        }

        return Collections.emptyList();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;解析binlog 数据对象&lt;code&gt;BinlogRowData&lt;/code&gt; ,用于增量索引的后续处理&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * MysqlRowData for 简化{@link BinlogRowData} 以方便实现增量索引的实现
 *
 * @author &amp;lt;a href=&quot;mailto:magicianisaac@gmail.com&quot;&amp;gt;Isaac.Zhang | 若初&amp;lt;/a&amp;gt;
 */
@Data
@AllArgsConstructor
@NoArgsConstructor
public class MysqlRowData {

    //实现多数据的时候，需要传递数据库名称
    //private String database;
    private String tableName;
    private String level;
    private OperationTypeEnum operationTypeEnum;
    private List&amp;lt;Map&amp;lt;String, String&amp;gt;&amp;gt; fieldValueMap = new ArrayList&amp;lt;&amp;gt;();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为我们需要将Binlog &lt;code&gt;EventType&lt;/code&gt;转换为我们的操作类型&lt;code&gt;OperationTypeEnum&lt;/code&gt;，所以，我们在&lt;code&gt;OperationTypeEnum&lt;/code&gt;中添加一个转换方法：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public enum OperationTypeEnum {
...
    public static OperationTypeEnum convert(EventType type) {
        switch (type) {
            case EXT_WRITE_ROWS:
                return ADD;
            case EXT_UPDATE_ROWS:
                return UPDATE;
            case EXT_DELETE_ROWS:
                return DELETE;
            default:
                return OTHER;
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们还需要定义一个表包含的各个列名称的java类，方便我们后期对数据表的CUD操作：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.sxzhongf.ad.mysql.constant;

import java.util.HashMap;
import java.util.Map;

/**
 * Constant for 各个列名称的java类，方便我们后期对数据表的CUD操作
 *
 * @author &amp;lt;a href=&quot;mailto:magicianisaac@gmail.com&quot;&amp;gt;Isaac.Zhang | 若初&amp;lt;/a&amp;gt;
 */
public class Constant {

    private static final String DATABASE_NAME = &quot;advertisement&quot;;

    public static class AD_PLAN_TABLE_INFO {

        public static final String TABLE_NAME = &quot;ad_plan&quot;;

        public static final String COLUMN_PLAN_ID = &quot;plan_id&quot;;
        public static final String COLUMN_USER_ID = &quot;user_id&quot;;
        public static final String COLUMN_PLAN_STATUS = &quot;plan_status&quot;;
        public static final String COLUMN_START_DATE = &quot;start_date&quot;;
        public static final String COLUMN_END_DATE = &quot;end_date&quot;;
    }

    public static class AD_CREATIVE_TABLE_INFO {

        public static final String TABLE_NAME = &quot;ad_creative&quot;;

        public static final String COLUMN_CREATIVE_ID = &quot;creative_id&quot;;
        public static final String COLUMN_TYPE = &quot;type&quot;;
        public static final String COLUMN_MATERIAL_TYPE = &quot;material_type&quot;;
        public static final String COLUMN_HEIGHT = &quot;height&quot;;
        public static final String COLUMN_WIDTH = &quot;width&quot;;
        public static final String COLUMN_AUDIT_STATUS = &quot;audit_status&quot;;
        public static final String COLUMN_URL = &quot;url&quot;;
    }

    public static class AD_UNIT_TABLE_INFO {

        public static final String TABLE_NAME = &quot;ad_unit&quot;;

        public static final String COLUMN_UNIT_ID = &quot;unit_id&quot;;
        public static final String COLUMN_UNIT_STATUS = &quot;unit_status&quot;;
        public static final String COLUNN_POSITION_TYPE = &quot;position_type&quot;;
        public static final String COLUNN_PLAN_ID = &quot;plan_id&quot;;
    }

    public static class RELATIONSHIP_CREATIVE_UNIT_TABLE_INFO {

        public static final String TABLE_NAME = &quot;relationship_creative_unit&quot;;

        public static final String COLUMN_CREATIVE_ID = &quot;creative_id&quot;;
        public static final String COLUMN_UNIT_ID = &quot;unit_id&quot;;
    }

    public static class AD_UNIT_DISTRICT_TABLE_INFO {

        public static final String TABLE_NAME = &quot;ad_unit_district&quot;;

        public static final String COLUMN_UNIT_ID = &quot;unit_id&quot;;
        public static final String COLUMN_PROVINCE = &quot;province&quot;;
        public static final String COLUMN_CITY = &quot;city&quot;;
    }

    public static class AD_UNIT_KEYWORD_TABLE_INFO {

        public static final String TABLE_NAME = &quot;ad_unit_keyword&quot;;

        public static final String COLUMN_UNIT_ID = &quot;unit_id&quot;;
        public static final String COLUMN_KEYWORD = &quot;keyword&quot;;
    }

    public static class AD_UNIT_HOBBY_TABLE_INFO {

        public static final String TABLE_NAME = &quot;ad_unit_hobby&quot;;

        public static final String COLUMN_UNIT_ID = &quot;unit_id&quot;;
        public static final String COLUMN_HOBBY_TAG = &quot;hobby_tag&quot;;
    }

    //key -&amp;gt; 表名
    //value -&amp;gt; 数据库名
    public static Map&amp;lt;String, String&amp;gt; table2db;

    static {
        table2db = new HashMap&amp;lt;&amp;gt;();
        table2db.put(AD_PLAN_TABLE_INFO.TABLE_NAME, DATABASE_NAME);
        table2db.put(AD_CREATIVE_TABLE_INFO.TABLE_NAME, DATABASE_NAME);
        table2db.put(AD_UNIT_TABLE_INFO.TABLE_NAME, DATABASE_NAME);
        table2db.put(RELATIONSHIP_CREATIVE_UNIT_TABLE_INFO.TABLE_NAME, DATABASE_NAME);
        table2db.put(AD_UNIT_DISTRICT_TABLE_INFO.TABLE_NAME, DATABASE_NAME);
        table2db.put(AD_UNIT_HOBBY_TABLE_INFO.TABLE_NAME, DATABASE_NAME);
        table2db.put(AD_UNIT_KEYWORD_TABLE_INFO.TABLE_NAME, DATABASE_NAME);
    }
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Fri, 09 Aug 2019 14:02:00 +0000</pubDate>
<dc:creator>IsaacZhang</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhangpan1244/p/11329817.html</dc:identifier>
</item>
<item>
<title>ASP.NET Core MVC 之视图组件（View Component） - 卡西莫多_Ruby</title>
<link>http://www.cnblogs.com/afei-24/p/11317885.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/afei-24/p/11317885.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.视图组件介绍&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　视图组件是 ASP.NET Core MVC 的新特性，类似于局部视图，但它更强大。视图组件不使用模型绑定，并且仅依赖于调用它时所提供的数据。&lt;/p&gt;
&lt;p&gt;　　视图组件特点：&lt;/p&gt;
&lt;p&gt;　　　　呈块状，而不是整个响应&lt;/p&gt;
&lt;p&gt;　　　　包括在控制器和视图之间发现的相同的关注点和可测试性优点&lt;/p&gt;
&lt;p&gt;　　　　可以拥有参数和业务逻辑&lt;/p&gt;
&lt;p&gt;　　　　通常从布局页面调用&lt;/p&gt;

&lt;p&gt;　　视图组件可以用在任何需要重复逻辑且对局部视图来说过于复杂的情况，例如：&lt;/p&gt;
&lt;p&gt;　　　　动态导航菜单&lt;/p&gt;
&lt;p&gt;　　　　标签云（需要查询数据库）&lt;/p&gt;
&lt;p&gt;　　　　登录面板&lt;/p&gt;
&lt;p&gt;　　　　购物车&lt;/p&gt;
&lt;p&gt;　　　　最近发表的文章&lt;/p&gt;
&lt;p&gt;　　　　典型博客上的侧边栏内容&lt;/p&gt;
&lt;p&gt;　　　　将在每个页面上呈现的登录面板，根据用户的登录状态显示注销或者登录的链接&lt;/p&gt;

&lt;p&gt;　　视图组件有两部分组成，类（通常派生自 ViewComponent）和它返回的结果（通常是一个视图）。与控制器一样，视图组件可以是POCO，但大多数是利用 ViewComponent 派生的方法和属性。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.创建视图组件&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;(1)视图组件类&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　一个视图组件类通常可以通过以下任一方式创建：&lt;/p&gt;
&lt;p&gt;　　　　派生自ViewComponent&lt;/p&gt;
&lt;p&gt;　　　　使用 [ViewComponent] 属性装饰类，或从具有 [ViewComponent] 属性的类派生&lt;/p&gt;
&lt;p&gt;　　　　创建一个名称后缀为 ViewComponent 结尾的类&lt;/p&gt;
&lt;p&gt;　　像控制器一样，视图组件必须是 public ，非嵌套和非抽象类。视图组件名称是删除了 ViewComponent 后缀的类名，可以使用 ViewComponentAttribute.Name 属性显示指定。&lt;/p&gt;

&lt;p&gt;　　视图组件类优点：&lt;/p&gt;
&lt;p&gt;　　　　完全支持构造函数依赖注入&lt;/p&gt;
&lt;p&gt;　　　　不参与控制器生命周期，这意味着不能在视图组件中使用过滤器&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　(2) 视图组件方法&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　视图组件在 InvokeAsync 方法中定义其逻辑，并返回 IViewComponentResult 。参数直接来自视图组件的调用，而不是来自模型绑定。视图组件从不直接处理请求。通常，视图组件通过调用 View 方法初始化模型并将其传递给视图。总之，视图组件有以下特点：&lt;/p&gt;
&lt;p&gt;　　　　定义一个 InvokeAsync 方法并返回 IViewComponentResult。&lt;/p&gt;
&lt;p&gt;　　　　通常通过调用  ViewComponent View 方法初始化模型并将其传递给视图。&lt;/p&gt;
&lt;p&gt;　　　　参数来自调用方法，而不是 HTTP，没有模型绑定。&lt;/p&gt;
&lt;p&gt;　　　　不能直接作为 HTTP 端点访问，它是从你的代码（通常在视图中）调用的。视图组件不处理请求。&lt;/p&gt;
&lt;p&gt;　　　　在签名上重载，而不是当前 HTTP 请求的任何细节。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　(3) 视图搜索路径&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　运行时在以下路径搜索视图：&lt;/p&gt;
&lt;p&gt;　　Views/&amp;lt;controller_name&amp;gt;/Components/&amp;lt;view_component_name&amp;gt;/&amp;lt;view_name&amp;gt;&lt;/p&gt;
&lt;p&gt;　　Views/Shared/Components/&amp;lt;view_component_name&amp;gt;/&amp;lt;view_name&amp;gt;&lt;/p&gt;
&lt;p&gt;　　视图组件的默认视图名称是 Default，这意味着你的视图文件通常名为 Default.cshtml。你可以在创建视图组件结果或调用 View 方法时指定其他的视图名称。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.调用视图组件&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 　　 要使用视图组件，请从视图中调用  @Component.InvokeAsync(&quot;视图组件名称&quot;,&amp;lt;匿名参数&amp;gt;)。参数将传递到 InvokeAsync 方法。如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
@await Component.InvokeAsync(&quot;TopicRankList&quot;,new { days=5})
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　视图组件通常从视图中调用，但也可以从控制器方法中直接调用，虽然视图组件不像控制器那样定义终结点。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ActionResult Index()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; ViewComponent(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;TopicRankList&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt; { days = &lt;span&gt;5&lt;/span&gt;&lt;span&gt; });
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.实战视图组件&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　添加一个 ViewCompoents 文件夹，然后添加 UserRankList类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserRankList : ViewComponent
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; DataContext _db;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; IMemoryCache _memoryCache;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; cacheKey = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;topicrank&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; UserRankList(DataContext db, IMemoryCache memoryCache)
        {
            _db &lt;/span&gt;=&lt;span&gt; db;
            _memoryCache &lt;/span&gt;=&lt;span&gt; memoryCache;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IViewComponentResult Invoke(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; days)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; items = &lt;span&gt;new&lt;/span&gt; List&amp;lt;User&amp;gt;&lt;span&gt;();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!_memoryCache.TryGetValue(cacheKey, &lt;span&gt;out&lt;/span&gt;&lt;span&gt; items))
            {
                items &lt;/span&gt;= GetRankUsers(&lt;span&gt;10&lt;/span&gt;&lt;span&gt;, days);
            }
            _memoryCache.Set(cacheKey,items,TimeSpan.FromMinutes(&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;));
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; View(items);
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; List&amp;lt;User&amp;gt; GetRankUsers(&lt;span&gt;int&lt;/span&gt; top, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; days)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; _db.User.OrderBy(o =&amp;gt;&lt;span&gt; o.Id).Take(top).ToList();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　视图组件类可以在项目的任何文件夹中。 [ViewComponent] 特性可以更改用于引用视图组件的名称，例如，可以命名类为 XYZ，并应用 [ViewComponent] 特性：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[ViewComponent(Name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UserRankTop&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; calss XYZ:ViewComponent
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　Invoke 方法返回列表，然后创建视图组件视图。&lt;/p&gt;
&lt;p&gt;　　创建 View/Shared/Components 文件夹。这个文件夹必须名为 Components。然后在里面创建 UserRankList 文件夹，添加 Default.cshtml 视图：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
@model List&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;MVCTest&lt;/span&gt;&lt;span&gt;.Models.User&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h2&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;user&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h2&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;list-group&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    @foreach (var item in Model)
    {
        &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;@item.Name&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    }
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　最后在视图中调用：@await Component.InvokeAsync(&quot;UserRankList&quot;, new { days=5})&lt;/p&gt;

</description>
<pubDate>Fri, 09 Aug 2019 13:20:00 +0000</pubDate>
<dc:creator>卡西莫多_Ruby</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/afei-24/p/11317885.html</dc:identifier>
</item>
<item>
<title>.lib .dll 区别介绍、使用（dll的两种引入方式） - skytcat</title>
<link>http://www.cnblogs.com/skytcat/p/11329648.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/skytcat/p/11329648.html</guid>
<description>&lt;p&gt;.lib .dll文件都是程序可直接引用的文件，前者就是所谓的库文件，后者是动态链接库（Dynamic Link Library)也是一个库文件。而.pdb则可以理解为符号表文件。DLL(Dynamic Link Library)文件为动态链接库文件，又称为“应用程序扩展”，是一种软件文件类型。在Windows中，许多应用程序并不是一个完整的可执行文件，它们被分割成一些相对独立的动态链接库，即dll文件，放置于系统中。&lt;/p&gt;
&lt;h2&gt;关于lib和dll的区别&lt;/h2&gt;
&lt;p&gt;（1）lib是编译时用到的，dll是运行时用到的。如果要完成源代码的编译，只需要lib；如果要使动态链接的程序运行起来，只需要dll。&lt;br/&gt;（2）如果有dll文件，那么lib一般是一些索引信息，记录了dll中函数的入口和位置，dll中是函数的具体内容；如果只有lib文件，那么这个lib文件是静态编译出来的，索引和实现都在其中。使用静态编译的lib文件，在运行程序时不需要再挂动态库，缺点是导致应用程序比较大，而且失去了动态库的灵活性，发布新版本时要发布新的应用程序才行。&lt;br/&gt;（3）动态链接的情况下，有两个文件：一个是LIB文件，一个是DLL文件。LIB包含被DLL导出的函数名称和位置，DLL包含实际的函数和数据，应用程序使用LIB文件链接到DLL文件。在应用程序的可执行文件中，存放的不是被调用的函数代码，而是DLL中相应函数代码的地址，从而节省了内存资源。如果不想用lib文件或者没有lib文件，可以用WIN32 API函数LoadLibrary、GetProcAddress装载。&lt;/p&gt;
&lt;h2&gt;需要的文件&lt;/h2&gt;
&lt;p&gt;静态链接库（Static Link Library）使用lib需注意两个文件：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;h头文件，包含lib中说明输出的类或符号原型或数据结构。应用程序调用lib时，需要将该文件包含入应用程序的源文件中。&lt;/li&gt;
&lt;li&gt;LIB文件，这种 lib 中有函数的实现代码，它是将 lib 中的代码加入目标模块(.exe 或者 .dll)文件中，所以链接好了之后，lib 文件就没有用了。这种 lib文件实际上是任意个 obj 文件的集合。obj 文件则是 cpp 文件编译生成的，如果有多个cpp 文件则会编译生成多个 obj 文件，从而生成的 lib 文件中也包含了多个 obj。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;动态链接库（Dynamic Link Library）的导入库（Import Library）使用dll需注意三个文件：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;h头文件，包含dll中说明输出的类或符号原型或数据结构的.h文件。应用程序调用dll时，需要将该文件包含入应用程序的源文件中。&lt;/li&gt;
&lt;li&gt;LIB文件，是dll在编译、链接成功之后生成的文件，作用是当其他应用程序调用dll时，需要将该文件引入应用 程序，否则产生错误。如果不想用lib文件或者没有lib文件，可以用WIN32 API函数LoadLibrary、GetProcAddress装载。&lt;/li&gt;
&lt;li&gt;dll文件，真正的可执行文件，开发成功后的应用程序在发布时，只需要有.exe文件和.dll文件，并不需要.lib文件和.h头文件。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这种 lib 是和 dll 配合使用的，里面没有代码，代码在 dll 中，这种 lib 是用在静态调用 dll 上的，所以起的作用也是链接作用，链接完成了， lib 也没用了。至于动态调用 dll 的话，根本用不上 lib 文件。目标模块（exe 或者 dll）文件生成之后，就用不着 lib 文件了。&lt;/p&gt;
&lt;h2&gt;引入加载文件&lt;/h2&gt;
&lt;h3&gt;加载lib/头文件（若不添加，连接报错：无法解析的外部符号）&lt;/h3&gt;
&lt;p&gt;静态链接只需要lib文件，当然头文件也是需要的。这种方式时候lib文件中有两个部分，可以将文件后缀改为rar解压可以看到。第一部分就是和第一种方式中的key，第二部分是.obj文件存储在obj文件夹下，他相当与dll中的机器码，只不过这个机器码是在链接的时候放入程序的，而不是在程序运行时拿进来的。如果这时候我们也有源代码，并且希望IED可以调试源码，这很容易因为如果lib文件生成的时候模式是NDEBUG（好像不是也可以）,obj文件夹下是有一个xx.pdb这个pdb文件中的东西会被IED放入程序的pdb中，所以直接指定源代码位置使用就可以了。&lt;br/&gt;1 第一步：项目-&amp;gt;属性-&amp;gt;C/C++-&amp;gt;常规-&amp;gt;附加包含目录(浏览.h文件的路径) 　　添加包含文件&lt;br/&gt;2 第二步：项目-&amp;gt;属性-&amp;gt;C/C++-&amp;gt;链接器-&amp;gt;输入-&amp;gt;附加依赖项(写入lib的名称) 添加用到的lib （这一步也可以在代码中显示调用 #pragma comment(lib, “***.lib”) ）&lt;br/&gt;　　　　项目-&amp;gt;属性-&amp;gt;C/C++-&amp;gt;链接器-&amp;gt;常规-&amp;gt;附加库目录 　　　　　　　添加库文件路径&lt;br/&gt;4 第三步：在要使用cpp文件前加入 #include &amp;lt;gtest/gtest.h&amp;gt;(注意文件的路径)&lt;br/&gt;上述方法，在每次创建工程时都要重新进行设置，而且debug和release都要进行设置，同时注意win32和win64平台。&lt;/p&gt;
&lt;h3&gt;加载dll（如果不添加，编译链接不报错，运行报错：无法找到***.dll）&lt;/h3&gt;
&lt;p&gt;这种方式的基本原理是lib文件中包扩了某一段程序（函数）的入口或者说是地址，而他真正的机器码是在dll文件中，IDE链接的时候将.lib文件（程序地址）链接到源代码中，程序运行时到相应位置（环境变量path，当前目录等）寻找dll文件并执行其中的机器码。所以这种引用方式一般需要的文件一般有三个：.h,.lib,.dll，生成的源程序也会比较小，因为他只保存了函数地址，但是这种方式总是会出现找不到xxx.dll这种问题。如果这时候我们还有dll的源代码，并且希望IED可以调试源码，那么就需要.pdb文件了，pdb文件中保存了dll的符号表，所谓符号表可以理解为机器码（这里是dll中的）中插入的key与源代码文件的映射，这样只要指定源码存放的路径，IDE就会自动去找源码。需要注意的是，pdb文件和dll文件是配套的，也就是说一旦dll文件有改动（比如说重新生成）pdb文件就必须做相应改变。pdb文件也比较大，程序运行时也会因为要完成映射而比较慢，这也是release版与debug的区别。&lt;/p&gt;
&lt;p&gt;对于dll文件的使用，将dll文件拷贝到工程debug文件下，或者在系统环境变量中加入dll文件的路径（...\bin）。&lt;/p&gt;
&lt;h4&gt;（1）附加依赖项配置&lt;/h4&gt;
&lt;p&gt;类似静态库的使用，直接在vs中进行配置。（其实本质还是隐式链接，只是配置方式不同）&lt;/p&gt;
&lt;h4&gt;（2）隐式链接&lt;/h4&gt;
&lt;p&gt;第一种方法是：通过project-&amp;gt;link-&amp;gt;Object/LibraryModule中加入.lib文件（或者在源代码中加入指令#pragma comment(lib, “Lib.lib”)），并将.dll文件置入工程所在目录，然后添加对应的.h头文件。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;stdafx.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DLLSample.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;#pragma&lt;/span&gt; comment(lib, &quot;DLLSample.lib&quot;) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;你也可以在项目属性中设置库的链接&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     TestDLL(&lt;span&gt;123&lt;/span&gt;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;dll中的函数，在DllSample.h中声明&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;（3）显式链接&lt;/h4&gt;
&lt;p&gt;还有一种方式是调用windows的api LoadLibrary来加载dll，并根据头文件调用GetProcAddress 加载dll中的函数，最后使用FreeLibrary释放,这种方式显然不可以调试。需要函数指针和WIN32 API函数LoadLibrary、GetProcAddress装载，使用这种载入方法，不需要.lib文件和.h头文件，只需要.dll文件即可（将.dll文件置入工程目录中）。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; #include &amp;lt;iostream&amp;gt;
&lt;span&gt; 2&lt;/span&gt; #include &amp;lt;windows.h&amp;gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用函数和某些特殊变量&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; typedef &lt;span&gt;void&lt;/span&gt; (*DLLFunc)(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    DLLFunc dllFunc;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     HINSTANCE hInstLibrary = LoadLibrary(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DLLSample.dll&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (hInstLibrary ==&lt;span&gt; NULL)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        FreeLibrary(hInstLibrary);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     dllFunc = (DLLFunc)GetProcAddress(hInstLibrary, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;TestDLL&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (dllFunc ==&lt;span&gt; NULL)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        FreeLibrary(hInstLibrary);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     dllFunc(&lt;span&gt;123&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     std::cin.&lt;span&gt;get&lt;/span&gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    FreeLibrary(hInstLibrary);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;LoadLibrary函数利用一个名称作为参数，获得DLL的实例（HINSTANCE类型是实例的句柄），通常调用该函数后需要查看一下函数返回是否成功，如果不成功则返回NULL（句柄无效），此时调用函数FreeLibrary释放DLL获得的内存。&lt;br/&gt;GetProcAddress函数利用DLL的句柄和函数的名称作为参数，返回相应的函数指针，同时必须使用强转；判断函数指针是否为NULL，如果是则调用函数FreeLibrary释放DLL获得的内存。此后，可以使用函数指针来调用实际的函数。&lt;br/&gt;最后要记得使用FreeLibrary函数释放内存。&lt;/p&gt;
&lt;h3&gt;注意：应用程序如何找到DLL文件？&lt;/h3&gt;
&lt;p&gt;使用LoadLibrary显式链接，那么在函数的参数中可以指定DLL文件的完整路径；如果不指定路径，或者进行隐式链接，Windows将遵循下面的搜索顺序来定位DLL：&lt;br/&gt;（1）包含EXE文件的目录&lt;br/&gt;（2）工程目录&lt;br/&gt;（3）Windows系统目录&lt;br/&gt;（4）Windows目录&lt;br/&gt;（5）列在Path环境变量中的一系列目录&lt;/p&gt;
</description>
<pubDate>Fri, 09 Aug 2019 13:19:00 +0000</pubDate>
<dc:creator>skytcat</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/skytcat/p/11329648.html</dc:identifier>
</item>
<item>
<title>分布式系统：向量时钟 - 让我思考一下</title>
<link>http://www.cnblogs.com/s-lisheng/p/11329601.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/s-lisheng/p/11329601.html</guid>
<description>&lt;h3 id=&quot;lamport时钟存在的问题&quot;&gt;Lamport时钟存在的问题&lt;/h3&gt;
&lt;p&gt;使用Lamport时间戳，只是比较事件&lt;span class=&quot;math inline&quot;&gt;\(a\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(b\)&lt;/span&gt;各自的时钟值&lt;span class=&quot;math inline&quot;&gt;\(C\{a\}\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(C\{b\}\)&lt;/span&gt;，无法说明它们之间的关系。也就是说，&lt;span class=&quot;math inline&quot;&gt;\(C\{a\}&amp;lt;C\{b\}\)&lt;/span&gt;不能说明事件&lt;span class=&quot;math inline&quot;&gt;\(a\)&lt;/span&gt;在事件&lt;span class=&quot;math inline&quot;&gt;\(b\)&lt;/span&gt;之前发生。比如下面的事件&lt;span class=&quot;math inline&quot;&gt;\(C4\)&lt;/span&gt;与&lt;span class=&quot;math inline&quot;&gt;\(A3\)&lt;/span&gt;，&lt;span class=&quot;math inline&quot;&gt;\(C\{A3\}&amp;lt;C\{C4\}\)&lt;/span&gt;，但是在时间上事件&lt;span class=&quot;math inline&quot;&gt;\(A3\)&lt;/span&gt;在&lt;span class=&quot;math inline&quot;&gt;\(C4\)&lt;/span&gt;之后发生。&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/7/3/16bb77960d08ed89?w=640&amp;amp;h=377&amp;amp;f=jpeg&amp;amp;s=53414&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以，Lamport时间戳的问题在于它不能捕获事件的因果关系，为了解决这个问题，有大神提出了向量时钟。&lt;/p&gt;
&lt;h3 id=&quot;向量时钟&quot;&gt;向量时钟&lt;/h3&gt;
&lt;p&gt;Vector clock是在Lamport时间戳基础上演进的另一种逻辑时钟方法，它通过vector结构不但记录本节点的Lamport时间戳，同时也记录了其他节点的Lamport时间戳。即，当系统有&lt;span class=&quot;math inline&quot;&gt;\(N\)&lt;/span&gt;个进程时，则存在&lt;span class=&quot;math inline&quot;&gt;\(N\)&lt;/span&gt;个逻辑时钟向量，一个进程对应一个时钟。具体如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;初始时所有时钟都为0；&lt;/li&gt;
&lt;li&gt;每一次处理内完内部事件，将本进程对应的逻辑时钟+1；&lt;/li&gt;
&lt;li&gt;每一次发送一个消息的时候，需要将自己的向量时钟和消息一起发送；&lt;/li&gt;
&lt;li&gt;每一次接收到一个消息，需要将自己的逻辑时钟+1，同时更新每一个逻辑时钟，更新规则为取本地逻辑时钟和收到的逻辑时钟的最大值。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/7/30/16c4155dfd53c647?w=500&amp;amp;h=283&amp;amp;f=png&amp;amp;s=46115&quot;/&gt;&lt;/p&gt;
&lt;p&gt;假设分布式系统有A、B和C这3个进程，根据上述规则其各自对应的逻辑时钟随着时间演化情况如图所示，其数值变化规则遵循上述规则，时间线之间的边代表进程间发送的消息。标为cause的阴影部分代表导致［A:2,B:4,C:1]事件的原因，标为effect的阴影部分则代表［A:2,B:4,C:1]事件影响到的后续事件，而无阴影部分覆盖的事件则是和［ A:2,B:4,C:1]事件无逻辑上因果关系的事件。&lt;/p&gt;
&lt;p&gt;事件关系判断方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;正常情况下，向量时钟V1上的各个时间分量如果全部都小于等于V2上各个时间分量，则认为V1比V2早。举个例子说明，比如事件［A:1,B:2,C:1］以及［A:4,B:5,C5]，通过和［A:2,B:4,C:1］对应位置比较可知其因果关系为：[A:1,B:2,C:1]为［A:2,B:4,C:1]之因，[A:4,B:5,C5］ 为[A:2,B:4,C:1］之果。&lt;/li&gt;
&lt;li&gt;向量时钟V1上的各个时间分量有的比V2上的时间分量大，有的比其小，则认为是同时发生。比如事件[A:2,B:4,C:1]与事件[ ,B:3,C:3]。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;向量时钟的应用冲突检测&quot;&gt;向量时钟的应用——冲突检测&lt;/h3&gt;
&lt;p&gt;可能有人会有疑问：向量时钟到底有什么用呢？举一个常见的工程应用：数据冲突检测。分布式系统中数据一般存在多个副本，多个副本可能被同时更新，这会引起副本间数据不一致，此时冲突检测就非常重要。&lt;u&gt;基于向量时钟我们可以获得任意两个事件的顺序关系，结果要么是有因果关系（先后顺序），要么是没有因果关系（同时发生）。&lt;/u&gt;通过向量时钟，我们能够识别到如果两个数据更新操作是同时发生的关系，那么说明出现了数据冲突。注意是检测（发现问题），它并不能解决数据冲突。&lt;/p&gt;
&lt;p&gt;下面我们举个向量时钟应用的例子，以一个例子来说明如何使用时钟向量，来维护一个分布式系统的一致性。&lt;/p&gt;
&lt;p&gt;Alice, Ben, Cathy, Dave四个人准备下周聚餐，在时间安排上协调出现了问题。首先，Alice提出Wednesday聚餐，那么对提出这个提议的Alice来说，此时她的时钟向量就是这样的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;date = Wednesday
vclock = Alice:1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;她将这个消息广播给其他三个人：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/7/3/16bb77964363ae61?w=471&amp;amp;h=357&amp;amp;f=png&amp;amp;s=16106&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Ben在收到提议之后，提出自己的提议Tuesday，此时ben的时钟向量就是：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;date = Tuesday
vclock = Alice:1, Ben:1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后将消息发送给Dave:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/7/3/16bb779642c1bb04?w=471&amp;amp;h=357&amp;amp;f=png&amp;amp;s=18328&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Dave收到之后，回复Ben表示同意Tuesday，此时Dave的时钟向量是：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;date = Tuesday
vclock = Alice:1, Ben:1, Dave:1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在Cathy参与进来，建议Thursday，此时Cathy的时钟向量是：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;date = Thursday
vclock = Alice:1, Cathy:1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后将提议发送给了Dave：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/7/3/16bb779643827dfe?w=471&amp;amp;h=357&amp;amp;f=png&amp;amp;s=22319&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Dave此时就有了两份有冲突的数据（冲突的原因是Ben和Cathy“同时”修改了最初Alice的数据）：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;date = Tuesday
vclock = Alice:1, Ben:1, Dave:1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;和&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;date = Thursday
vclock = Alice:1, Cathy:1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;根据时钟向量的关系判断规则，Dave发现了冲突，因为当前的向量时钟和新接收到的向量时钟上的各个逻辑时钟并不是全部小于或大于。幸运的是，Dave是个有理性的人，选择了Thursday（前面是发现冲突，这里相当于解决冲突，实际系统中解决冲突的方法不同，解决冲突不是向量时钟的内容）。Dave解决冲突并回复给Cathy，此时Dave的向量时钟为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;date = Thursday
vclock = Alice:1, Ben:1, Cathy:1, Dave:2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/7/3/16bb77964373e717?w=471&amp;amp;h=357&amp;amp;f=png&amp;amp;s=23728&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至此，当Alice问Ben和Cathy最新的决定，会收到来自Ben的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;date = Tuesday
vclock = Alice:1, Ben:1, Dave:1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;和来自Cathy的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;date = Thursday
vclock = Alice:1, Ben:1, Cathy:1, Dave:2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/7/3/16bb77964be3a4d7?w=471&amp;amp;h=357&amp;amp;f=png&amp;amp;s=26171&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样，Alice她可以说Dava与Cathy一致修改了自己和Ben的提议，并将Cathy的消息给Ben，Ben就知道它的提议已经被修改。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/7/3/16bb77969945ef73?w=471&amp;amp;h=357&amp;amp;f=png&amp;amp;s=31657&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在，它们愉快的达成了一致。对于整个协商的过程，可以看到冲突的根源在于Ben和Cathy都“同时”修改了Alice的数据，Dave解决了数据冲突（不同问题，解决数据冲突的方法不同），最后它们达成一致。&lt;/p&gt;
&lt;blockquote readability=&quot;0.3921568627451&quot;&gt;
&lt;p&gt;参考文档：&lt;br/&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Vector_clock&quot;&gt;Vector clock&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://s3.amazonaws.com/AllThingsDistributed/sosp/amazon-dynamo-sosp2007.pdf&quot;&gt;Dynamo: Amazon’s Highly Available Key-value Store&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/56886156&quot;&gt;分布式系统：向量时钟(部分内容翻译自上文)&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://riak.com/posts/technical/why-vector-clocks-are-hard/&quot;&gt;Why Vector Clocks Are Hard&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://www.10tiao.com/html/616/201605/2652227233/1.html&quot;&gt;时钟向量在一致性问题中的应用(部分内容翻译自上文)&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://zoo.cs.yale.edu/classes/cs426/2012/lab/bib/fidge88timestamps.pdf&quot;&gt;Timestamps in Message-Passing Systems That Preserve the Partial Ordering&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;公众号：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/7/30/16c416b462d6b455?w=173&amp;amp;h=171&amp;amp;f=jpeg&amp;amp;s=31832&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Fri, 09 Aug 2019 13:08:00 +0000</pubDate>
<dc:creator>让我思考一下</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/s-lisheng/p/11329601.html</dc:identifier>
</item>
<item>
<title>jdk1.8 HashMap底层数据结构：深入解析为什么jdk1.8 HashMap的容量一定要是2的n次幂 - 赖皮梅</title>
<link>http://www.cnblogs.com/laipimei/p/11316140.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/laipimei/p/11316140.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　1.本文根据jdk1.8源码来分析HashMap的容量取值问题；&lt;/p&gt;
&lt;p&gt;　　2.本文有做 jdk1.8 HashMap.resize()扩容方法的源码解析：见下文“一、3.扩容：同样需要保证扩容后的容量是2的n次幂”；&lt;/p&gt;
&lt;p&gt;　　3.目录：&lt;/p&gt;
&lt;p&gt;　　　　一、jdk1.8中，对“HashMap的容量一定是2的n次幂”做了严格控制&lt;/p&gt;
&lt;p&gt;　　　　　　1.默认初始容量&lt;/p&gt;
&lt;p&gt;　　　　　　2.使用HashMap的有参构造函数来自定义容量的大小（保证容量是2的n次幂）&lt;/p&gt;
&lt;p&gt;　　　　　　3.扩容：同样需要保证扩容后的容量是2的n次幂（ jdk1.8 HashMap.resize()扩容方法的源码解析）&lt;/p&gt;
&lt;p&gt;　　　　二、为什么HashMap的容量一定要是2的n次幂？或者说，保证“HashMap的容量一定是2的n次幂”有什么好处？&lt;/p&gt;
&lt;p&gt;　　　　　　1.关系到元素在桶中的位置计算问题&lt;/p&gt;
&lt;p&gt; 　　　　　　2.关系到扩容后元素在newCap中的放置问题&lt;/p&gt;
&lt;p&gt;　　　　　　　　2.1 源码解析&lt;/p&gt;
&lt;p&gt;　　　　　　　　2.2 深入分析（含图解）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;一、jdk1.8中，对“HashMap的容量一定要是2的n次幂”做了严格控制&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;1.默认初始容量：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * The default initial capacity - MUST be a power of two.（默认初始容量——必须是2的n次幂。）
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; DEFAULT_INITIAL_CAPACITY = 1 &amp;lt;&amp;lt; 4; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; aka 16（16 = 2^4）&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;2.使用HashMap的有参构造函数来自定义容量的大小（保证容量是2的n次幂）：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　HashMap总共有4个构造函数，其中有2个构造函数可以自定义容量的大小：&lt;/p&gt;
&lt;p&gt;　　①HashMap(int initialCapacity)：底层调用的是②HashMap(int initialCapacity, float loadFactor)构造函数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; HashMap(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; initialCapacity) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;(initialCapacity, DEFAULT_LOAD_FACTOR);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　②HashMap(int initialCapacity, float loadFactor)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; HashMap(&lt;span&gt;int&lt;/span&gt; initialCapacity, &lt;span&gt;float&lt;/span&gt;&lt;span&gt; loadFactor) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (initialCapacity &amp;lt; 0&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException(&quot;Illegal initial capacity: &quot; +&lt;span&gt;  initialCapacity);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (initialCapacity &amp;gt;&lt;span&gt; MAXIMUM_CAPACITY)
            initialCapacity &lt;/span&gt;=&lt;span&gt; MAXIMUM_CAPACITY;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (loadFactor &amp;lt;= 0 ||&lt;span&gt; Float.isNaN(loadFactor))
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException(&quot;Illegal load factor: &quot; +&lt;span&gt;  loadFactor);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.loadFactor =&lt;span&gt; loadFactor;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.threshold =&lt;span&gt; tableSizeFor(initialCapacity);//&lt;/span&gt;&lt;strong&gt;&lt;span&gt;tableSizeFor(initialCapacity)方法&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;是重点！！！&lt;/span&gt;&lt;/strong&gt; &lt;br/&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这里有个问题：使用①或②构造函数来自定义容量时，怎么能够保证传入的容量一定是2的n次幂呢？&lt;/p&gt;
&lt;p&gt;　　答案就在标记出来的&lt;span&gt;&lt;strong&gt;tableSizeFor(initialCapacity)&lt;/strong&gt;&lt;span&gt;方法中：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Returns a power of two size for the given target capacity.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; tableSizeFor(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; cap) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; n = cap - 1&lt;span&gt;;
        n &lt;/span&gt;|= n &amp;gt;&amp;gt;&amp;gt; 1&lt;span&gt;;
        n &lt;/span&gt;|= n &amp;gt;&amp;gt;&amp;gt; 2&lt;span&gt;;
        n &lt;/span&gt;|= n &amp;gt;&amp;gt;&amp;gt; 4&lt;span&gt;;
        n &lt;/span&gt;|= n &amp;gt;&amp;gt;&amp;gt; 8&lt;span&gt;;
        n &lt;/span&gt;|= n &amp;gt;&amp;gt;&amp;gt; 16&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (n &amp;lt; 0) ? 1 : (n &amp;gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面这段代码的作用：&lt;/p&gt;
&lt;p&gt;　　　　假如你传的cap是5，那么最终的初始容量为8；假如你传的cap是24，那么最终的初始容量为32。&lt;/p&gt;
&lt;p&gt;　　　　这是因为5并非是2的n次幂，而大于等于5且距离5最近的2的n次幂是8（8 = 2^3）；同样的，24也并非2的n次幂，大于等于24且距离24最近的2的n次幂是32（32 = 2^5）。&lt;/p&gt;
&lt;p&gt;　　　　假如你传的cap是64，那么最终的初始容量就是64，因为64是2^6，它就是等于cap的最小2的n次幂。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　　　总结起来就一句话：通过位移运算，&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;找到大于或等于 cap 的 最小2的n次幂&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;　　 jdk1.7的初始容量处理机制和上面jdk1.8具有相同的作用，但1.7的代码好懂很多：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; HashMap(&lt;span&gt;int&lt;/span&gt; initialCapacity, &lt;span&gt;float&lt;/span&gt;&lt;span&gt; loadFactor) {  
   ……
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; capacity = 1&lt;span&gt;;  
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (capacity &amp;lt;&lt;span&gt; initialCapacity)  { 
        capacity &lt;/span&gt;&amp;lt;&amp;lt;= 1&lt;span&gt;; 
    }
    ……
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;span&gt;3.扩容：同样需要保证扩容后的容量是2的n次幂（ jdk1.8 HashMap.resize()扩容方法的源码解析）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　resize()&lt;/span&gt;扩容方法主要做了三件事（这里这里重点讲前两件事，第三件事在下文的“三、2.”中讲）：&lt;/p&gt;
&lt;p&gt;　　　　①计算新容量（新桶） newCap 和新阈值 newThr；&lt;/p&gt;
&lt;p&gt;　　　　②根据计算出的 newCap 创建新的桶数组table，并对table做初始化；&lt;/p&gt;
&lt;p&gt;　　　　③将键值对节点重新放到新的桶数组里；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;final&lt;/span&gt; Node&amp;lt;K,V&amp;gt;[] &lt;span&gt;&lt;strong&gt;&lt;span&gt;resize&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;() { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;扩容
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;---------------- -------------------------- 1.计算新容量（新桶） newCap 和新阈值 newThr。 ---------------------------------&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;  
&lt;span&gt; 5&lt;/span&gt;         Node&amp;lt;K,V&amp;gt;[] oldTab =&lt;span&gt; table;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; oldCap = (oldTab == &lt;span&gt;null&lt;/span&gt;) ? 0 : oldTab.length;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;看容量是否已初始化&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; oldThr = threshold;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;下次扩容要达到的阈值。threshold(阈值) = capacity * loadFactor。&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; newCap, newThr = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (oldCap &amp;gt; 0) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;容量已初始化过了：检查容量和阈值是否达到上限《==========&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (oldCap &amp;gt;= MAXIMUM_CAPACITY) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;oldCap &amp;gt;= 2^30，已达到扩容上限，停止扩容&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;                 threshold =&lt;span&gt; Integer.MAX_VALUE;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; oldTab;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;            }&lt;br/&gt;　　　　　　　　　&lt;span&gt;&lt;strong&gt;// newCap &amp;lt; 2^30 &amp;amp;&amp;amp; oldCap &amp;gt; 16，还能再扩容：2倍扩容
&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&lt;strong&gt;&lt;span&gt;(newCap = oldCap &amp;lt;&amp;lt; 1)&lt;/span&gt;&lt;/strong&gt; &amp;lt; MAXIMUM_CAPACITY &amp;amp;&amp;amp; oldCap &amp;gt;= DEFAULT_INITIAL_CAPACITY)
&lt;span&gt;15&lt;/span&gt;                &lt;span&gt; &lt;strong&gt;newThr = oldThr &amp;lt;&amp;lt; 1; // 扩容：阈值*2。（注意：阈值是有可能越界的）&lt;/strong&gt;&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;容量未初始化 &amp;amp;&amp;amp; 阈值 &amp;gt; 0。
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;【啥时会满足层判断：使用HashMap(int initialCapacity, float loadFactor)或 HashMap(int initialCapacity)构造函数实例化HashMap时，threshold才会有值。】&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (oldThr &amp;gt; 0&lt;span&gt;) 
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             newCap = oldThr;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始容量设为阈值&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt; { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;容量未初始化 &amp;amp;&amp;amp; 阈值 &amp;lt;= 0 ： 
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;【啥时会满足这层判断：①使用无参构造函数实例化HashMap时；②在“if (oldCap &amp;gt; 0)”判断层newThr溢出了。】&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;             newCap =&lt;span&gt; DEFAULT_INITIAL_CAPACITY;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             newThr = (&lt;span&gt;int&lt;/span&gt;)(DEFAULT_LOAD_FACTOR *&lt;span&gt; DEFAULT_INITIAL_CAPACITY);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (newThr == 0) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;什么情况下才会进入这个判断框:前面执行了else if (oldThr &amp;gt; 0)，并没有为newThr赋值，就会进入这个判断框。&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;             &lt;span&gt;float&lt;/span&gt; ft = (&lt;span&gt;float&lt;/span&gt;)newCap *&lt;span&gt; loadFactor;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;             newThr = (newCap &amp;lt; MAXIMUM_CAPACITY &amp;amp;&amp;amp; ft &amp;lt; (&lt;span&gt;float&lt;/span&gt;)MAXIMUM_CAPACITY ? (&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)ft : Integer.MAX_VALUE);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         threshold =&lt;span&gt; newThr;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         
&lt;span&gt;32&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;------------------------------------------------------2.扩容：------------------------------------------------------------------&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt;         
&lt;span&gt;34&lt;/span&gt;         @SuppressWarnings({&quot;rawtypes&quot;,&quot;unchecked&quot;&lt;span&gt;})
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;             &lt;strong&gt;&lt;span&gt;Node&amp;lt;K,V&amp;gt;[] newTab = (Node&amp;lt;K,V&amp;gt;[])new Node[newCap];&lt;/span&gt;&lt;span&gt;//扩容&lt;/span&gt;&lt;/strong&gt;
&lt;span&gt;36&lt;/span&gt;         &lt;strong&gt;&lt;span&gt;table = newTab;
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;37&lt;/span&gt;         
&lt;span&gt;38&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;--------------------------------------------- 3.将键值对节点重新放到新的桶数组里。------------------------------------------------&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt;         
&lt;span&gt;40&lt;/span&gt; &lt;span&gt;        ……//此处源码见下文“二、2.”
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; 
&lt;span&gt;42&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; newTab;
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　通过resize()扩容方法的源码可以知道：&lt;strong&gt;&lt;span&gt;每次扩容，都是将&lt;/span&gt;&lt;span&gt;容量扩大一倍，所以新容量依旧是2的n次幂&lt;/span&gt;。如oldCap是16的话，那么newCap则为32。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　通过上面三点可以确定，不论是默认初始容量，还是自定义容量大小，又或者是扩容后的容量，都必须保证一定是2的n次幂。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;二、为什么HashMap的容量一定要是2的n次幂？或者说，保证“HashMap的容量一定是2的n次幂”有什么好处？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　原因有两个：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;　　1.关系到元素在桶中的位置计算问题：&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　简单来讲，一个元素放到哪个桶中，是通过 “hash % capacity” 取模运算得到的余数来确定的（注：“元素的key的哈希值”在本文统一简称为“hash”）。&lt;/p&gt;
&lt;p&gt;　　hashMap用另一种方式来替代取模运算——位运算：(capacity - 1) &amp;amp; hash。这种运算方式为什么可以得到跟取模一样的结果呢？ 答案是capacity是2的N次幂。（计算机做位运算的效率远高于做取模运算的效率，测试见：&lt;a href=&quot;https://www.cnblogs.com/laipimei/p/11316812.html&quot;&gt;https://www.cnblogs.com/laipimei/p/11316812.html&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;证明取模和位运算结果的一致性：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1439473/201908/1439473-20190809194123955-486329500.png&quot; alt=&quot;&quot; width=&quot;461&quot; height=&quot;277&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　2.关系到扩容后元素在newCap中的放置问题：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　扩容后，如何实现将oldCap中的元素重新放到newCap中？&lt;/p&gt;
&lt;p&gt;　　我们不难想到的实现方式是：&lt;strong&gt;遍历所有Node，然后重新put到新的table中， 中间会涉及计算新桶位置、处理hash碰撞等处理。&lt;/strong&gt;这里有个不容忽视的问题——哈希碰撞。在元素put进桶中时，就已经处理过了哈希碰撞问题：哈希值一样但通过equals()比较确定内容不同的元素，会在同一个桶中形成链表，链表长度 &amp;gt;=8 时将链表转为红黑树；&lt;strong&gt;扩容时，需要重新处理这些元素的哈希碰撞问题，如果数据量一大.......要完……&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　jdk1.8用了优雅又高效的方式来处理扩容后元素的放置问题，下面我们一起来看看jdk1.8到底是怎么做的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　2.1 先看jdk1.8源码实现：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre readability=&quot;4&quot;&gt;
 1 &lt;span&gt;final&lt;/span&gt; Node&amp;lt;K,V&amp;gt;[] &lt;span&gt;&lt;strong&gt;&lt;span&gt;resize&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;() { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;&lt;strong&gt;扩容方法&lt;/strong&gt;&lt;/span&gt;
 2     
 3 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;---------------- -------------------------- 1.计算新容量（新桶） newCap 和新阈值 newThr： -------------------------------------------&lt;/span&gt;
 4  
 5         …… &lt;span&gt;//&lt;/span&gt;&lt;span&gt;此处源码见前文“一、3.”&lt;/span&gt;
 6         
 7 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;---------------------------------------------------------2.扩容：------------------------------------------------------------------&lt;/span&gt;
 8         
 9         …… &lt;span&gt;//&lt;/span&gt;&lt;span&gt;此处源码见前文“一、3.”&lt;/span&gt;
10         
11 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;--------------------------------------------- &lt;span&gt;&lt;strong&gt;&lt;span&gt;3.将键值对节点重新放到新的桶数组里：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;------------------------------------------------&lt;/span&gt;
12         
13         &lt;span&gt;if&lt;/span&gt; (oldTab != &lt;span&gt;null&lt;/span&gt;) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;容量已经初始化过了：&lt;/span&gt;
14             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = 0; j &amp;lt; oldCap; ++j) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;一个桶一个桶去遍历，&lt;span&gt;&lt;strong&gt;&lt;span&gt;j 用于记录oldCap中当前桶的位置&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;
15                 Node&amp;lt;K,V&amp;gt;&lt;span&gt; e;
&lt;/span&gt;16                 &lt;span&gt;if&lt;/span&gt; ((e = oldTab[j]) != &lt;span&gt;null&lt;/span&gt;) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前桶上有节点，就赋值给e节点&lt;/span&gt;
17                     oldTab[j] = &lt;span&gt;null&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;把该节点置为null（现在这个桶上什么都没有了）&lt;/span&gt;
18                     &lt;span&gt;if&lt;/span&gt; (e.next == &lt;span&gt;null&lt;/span&gt;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;e节点后没有节点了：在新容器上重新计算e节点的放置位置《===== &lt;span&gt;&lt;strong&gt;&lt;span&gt;①桶上只有一个节点&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;
19                         newTab[e.hash &amp;amp; (newCap - 1)] =&lt;span&gt; e;
&lt;/span&gt;20                     &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (e &lt;span&gt;instanceof&lt;/span&gt; TreeNode)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;e节点后面是红黑树：先将红黑树拆成2个子链表，再将子链表的头节点放到新容器中《===== &lt;strong&gt;&lt;span&gt;②桶上是红黑树&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;
21                         ((TreeNode&amp;lt;K,V&amp;gt;)e).split(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, newTab, j, oldCap);
&lt;/span&gt;22                     &lt;span&gt;else&lt;/span&gt; { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; preserve order&lt;/span&gt;
23                         Node&amp;lt;K,V&amp;gt; loHead = &lt;span&gt;null&lt;/span&gt;, loTail = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;24                         Node&amp;lt;K,V&amp;gt; hiHead = &lt;span&gt;null&lt;/span&gt;, hiTail = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;25                         Node&amp;lt;K,V&amp;gt;&lt;span&gt; next;
&lt;/span&gt;26                         &lt;span&gt;do&lt;/span&gt; {  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;遍历链表，并将链表节点按原顺序进行分组《===== &lt;strong&gt;&lt;span&gt;③桶上是链表&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;
27                             next =&lt;span&gt; e.next;
&lt;/span&gt;28                             &lt;span&gt;if&lt;/span&gt; ((&lt;span&gt;&lt;strong&gt;e.hash &amp;amp; oldCap) == 0&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;) {//“定位值等于0”的为一组：
&lt;/span&gt;29                                 &lt;span&gt;if&lt;/span&gt; (loTail == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;30                                     loHead =&lt;span&gt; e;
&lt;/span&gt;31                                 &lt;span&gt;else&lt;/span&gt;
32                                     loTail.next =&lt;span&gt; e;
&lt;/span&gt;33                                 loTail =&lt;span&gt; e;
&lt;/span&gt;34&lt;span&gt;                             }
&lt;/span&gt;35                             &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {//“定位值不等于0”的为一组：
&lt;/span&gt;36                                 &lt;span&gt;if&lt;/span&gt; (hiTail == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;37                                     hiHead =&lt;span&gt; e;
&lt;/span&gt;38                                 &lt;span&gt;else&lt;/span&gt;
39                                     hiTail.next =&lt;span&gt; e;
&lt;/span&gt;40                                 hiTail =&lt;span&gt; e;
&lt;/span&gt;41&lt;span&gt;                             }
&lt;/span&gt;42                         } &lt;span&gt;while&lt;/span&gt; ((e = next) != &lt;span&gt;null&lt;/span&gt;&lt;span readability=&quot;2&quot;&gt;);&lt;p&gt;　　　　　　　　　　　　　　　　&lt;strong&gt;&lt;span&gt;//将分好的子链表放到newCap中：
&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/span&gt;43                         &lt;span&gt;if&lt;/span&gt; (loTail != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;44                             loTail.next = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;45                             newTab[j] =&lt;span&gt; loHead;//&lt;strong&gt;&lt;span&gt;原链表在oldCap的什么位置，“定位值等于0”的子链表的头节点就放到newCap的什么位置
&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;46&lt;span&gt;                         }
&lt;/span&gt;47                         &lt;span&gt;if&lt;/span&gt; (hiTail != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;48                             hiTail.next = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;49                             newTab[j + oldCap] =&lt;span&gt; hiHead; //&lt;strong&gt;&lt;span&gt;“定位值不等于0”的子节点的头节点在newCap的位置 = 原链表在oldCap中的位置 + oldCap
&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;50&lt;span&gt;                         }
&lt;/span&gt;51&lt;span&gt;                     }
&lt;/span&gt;52&lt;span&gt;                 }
&lt;/span&gt;53&lt;span&gt;             }
&lt;/span&gt;54&lt;span&gt;         }
&lt;/span&gt;55         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; newTab;
&lt;/span&gt;56     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;　　2.2 深入分析（含图解）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　① 如果桶上只有一个节点（后面即没链表也没树）&lt;/strong&gt;：元素直接做 “hash &amp;amp; (newCap - 1)” 运算，根据结果将元素节点放到newCap的相应位置；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　②如果桶上是链表：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　将链表上的所有节点做 &lt;span&gt;“hash &amp;amp; oldCap” 运算（注意，这里oldCap没有-1），会得到一个&lt;/span&gt;&lt;strong&gt;&lt;span&gt;定位值&lt;/span&gt;&lt;/strong&gt;（“定位值”这个名字是我自己取的，为了更好理解该值的意义）。&lt;span&gt;定位值要么是“0”，要么是“小于capacity的正整数”&lt;/span&gt;&lt;span&gt;！这是个规律，之所以能得此规律和capacity取值一定是2的n次幂有直接关系&lt;/span&gt;，如果容量不是2的n次幂，那么定位值就不再要么是“0”，要么是“小于capacity的正整数”，它还有可能是其他的数；&lt;/p&gt;
&lt;p&gt;　　根据定位值的不同，会将链表一分为二得到两个子链表，这两个子链表根据各自的定位值直接放到newCap中：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　　　子链表的定位值 == 0: 则链表在oldCap中是什么位置，就将子链表的头节点直接放到newCap的什么位置；&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　　　子链表的定位值 == 小于capacity的正整数：则将子链表的头节点放到newCap的“oldCap + 定位值”的位置；&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　这么做的好处：&lt;/strong&gt;&lt;/span&gt;链表在被拆分成两个子链表前就已经处理过了元素的哈希碰撞问题，子链表不用重新处理哈希碰撞问题，可以直接将头节点直接放到newCap的合适的位置上，完成 “扩容后将元素放到newCap”这一工作。正因为如此，大大提高了jdk1.8的HashMap的扩容效率。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　下面将通过画图的形式，进一步理解HashMap到底是怎么将元素放到newCap中的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　前面我们说了jdk1.8的HashMap元素放到哪个桶中哪个位置，是通过计算 “(capacity - 1) &amp;amp; hash” 得到的余数来确定的。现在有四个元素，哈希值分别为35、27、19、43，当“容量 = 8”时，计算所得余数都等于3，所以这4个元素会被放到 table[3] 的位置，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1439473/201908/1439473-20190809194246795-921424083.png&quot; alt=&quot;&quot; width=&quot;596&quot; height=&quot;383&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;进行一次扩容后，现在容量 = 16，再次计算“(capacity - 1) &amp;amp; hash”后，这四个元素在newCap中的位置会有所变化：要么在原位置，要么在“oldCap + 原位置”；也就是说这四个元素被分成了两组。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1439473/201908/1439473-20190809194322191-1166186773.png&quot; alt=&quot;&quot; width=&quot;560&quot; height=&quot;443&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;下面我们不用 “(capacity - 1) &amp;amp; hash” 的方式来放置元素，而是根据jdk1.8中HashMap.resize()扩容方法来放置元素：先通过 “hash &amp;amp; oldCap” 得到定位值，再根据定位值同样能将链表一分为二&lt;span&gt;&lt;strong&gt;（&lt;/strong&gt;&lt;strong&gt;见证奇迹的时候到了&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;）&lt;/span&gt;&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;　　　　“定位值 = 0”的为一组，这组元素就是前面将容量从8扩到16后，通过“(newCap - 1) &amp;amp; hash” 计算确定 “放回原位置” 的那些元素；&lt;/p&gt;
&lt;p&gt;　　　　“定位值 != 0”的为一组，这组元素就是扩容后，确定 “oldCap + 原位置”的那些元素。 如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1439473/201908/1439473-20190809194404338-967075311.png&quot; alt=&quot;&quot; width=&quot;589&quot; height=&quot;254&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;再将这两组元素节点分别连接成子链表：loHead是 “定位值 == 0” 的子链表的头节点；hiHead是 “定位值 != 0” 的子链表的头节点。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1439473/201908/1439473-20190809143952959-1646703361.png&quot; alt=&quot;&quot; width=&quot;477&quot; height=&quot;111&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;最后，将子链表的头节点loHead放到newCap中，位置和在oldCap中的原位置一致；将另一个子链表的头节点hiHead放到newCap的“oldCap + 原位置”上。&lt;strong&gt;&lt;span&gt;到这里HashMap就完成了扩容后将元素重新放到newCap中的工作了。&lt;/span&gt;&lt;/strong&gt;如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1439473/201908/1439473-20190809194447338-124662685.png&quot; alt=&quot;&quot; width=&quot;456&quot; height=&quot;305&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;到这里其实我们已经把 “容量一定是2的n次幂是 提高扩容后将元素重新放到newCap中的效率 的前提”解释完了，现在还有一个小小的问题——通过定位值将链表一分为二，会分得均匀吗？如果分得很不均匀会怎么样？&lt;/p&gt;
&lt;p&gt;　　众所周知，要想HashMap的查询速度快，那就得尽量做到让元素均匀地散落到每个桶里。将链表平均分成两个子链表，就意味着让元素更均匀地放到桶中了，增加了元素散列性，从而提高了元素的查找效率。那jdk1.8又是如何将链表分得更平均的呢？这关系到两点：①元素的哈希值更随机、散列；②通过“hash &amp;amp; oldCap”中的oldCap再次增加元素放置位置的随机性。第①点和哈希算法的实现直接相关，这里不细说；第②点的意思如下：&lt;/p&gt;
&lt;p&gt;　　以 “capacity = 8” 为例，下面这些都是当 “容量 = 8” 时放在table[3]位置上的元素的hash值。扩容时做“hash &amp;amp; oldCap” 运算，通过下图我们可以发现，oldCap所在的位上(即倒数第4位)，元素的hash值在这个位是0还是1具有随机性。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1439473/201908/1439473-20190809195637421-1940834120.png&quot; alt=&quot;&quot; width=&quot;311&quot; height=&quot;241&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;span&gt;也就是说，jdk1.8在元素通过哈希算法使hash值已经具有随机性的前提下，再做了一个增加元素放置位置随机性的运算。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　③如果桶上是红黑树：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　将红黑树重新放到newCap中的逻辑和将链表重新放到newCap的的逻辑差不多。不同之处在于，重新放后，会将红黑树拆分成两条由 TreeNode 组成的子链表：&lt;/p&gt;
&lt;p&gt;　　　　此时，如果子链表长度 &amp;lt;= UNTREEIFY_THRESHOLD（即 &amp;lt;= 6 ），则将由 TreeNode组成的子链表 转换成 由Node组成的普通子链表，然后再根据定位值将子链表的头节点放到newCap中；&lt;/p&gt;
&lt;p&gt;　　　　否则，根据条件重新将“由 TreeNode 组成的子链表”重新树化，然后再根据定位值将树的头节点放到newCap中。&lt;/p&gt;
&lt;p&gt;　　本文不对“HashMap扩容时红黑树在newCap中的重新放置”做详细解释，后面我会再写一篇有关《红黑树转回链表的具体时机》的博文，在这篇博文中会做详细的源码解析。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;一言蔽之：jdk1.8 HashMap的容量一定要是2的n次幂，是为了提高“计算元素放哪个桶”的效率，也是为了提高扩容效率（避免了扩容后再重复处理哈希碰撞问题）。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　【第一次写这么多字的博文，如有笔误之处，还望在评论中帮忙指出，谢谢~】 　　&lt;/p&gt;

</description>
<pubDate>Fri, 09 Aug 2019 12:29:00 +0000</pubDate>
<dc:creator>赖皮梅</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/laipimei/p/11316140.html</dc:identifier>
</item>
</channel>
</rss>