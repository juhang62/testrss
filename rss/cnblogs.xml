<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>高等数学——微积分中的不定积分 - TechFlow2019</title>
<link>http://www.cnblogs.com/techflow/p/12529498.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/techflow/p/12529498.html</guid>
<description>&lt;p&gt;本文始发于个人公众号：&lt;strong&gt;TechFlow&lt;/strong&gt;，原创不易，求个关注&lt;/p&gt;

&lt;section id=&quot;nice&quot; data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; readability=&quot;70&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天是&lt;strong&gt;高等数学专题的第8篇&lt;/strong&gt;文章，今天的内容是不定积分。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我之前的高数老师曾经说过，高等数学就是大半本的微积分加上一些数列和极限的知识。而微积分当中，积分相关又占据了大半江山。微积分之所以重要并不是因为它的比重大、容量多，而是因为它&lt;strong&gt;常用&lt;/strong&gt;。几乎所有理工科的课本上都有微积分的公式，原因也很简单，当年这些科学家在研究未知事物或者是进行计算的时候，大量使用了微积分作为工具。这也是我们必须学它的原因。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;原函数&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我一直都觉得微积分这个名字起得很好，&lt;strong&gt;微积分是微分和积分的合称&lt;/strong&gt;。微分是通过宏观研究微观，而积分恰恰相反则是通过微观获取宏观。因此从某种意义上来说，我们可以将积分看成是微分的反面。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;微分对应的是极限，在函数当中，我们通过让&lt;span class=&quot;span-inline-equation&quot;&gt;&lt;span&gt;&lt;img class=&quot;equation&quot; src=&quot;https://juejin.im/equation?tex=/Delta%20x&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;趋近于0研究函数的变化情况。当&lt;span class=&quot;span-inline-equation&quot;&gt;&lt;span&gt;&lt;img class=&quot;equation&quot; src=&quot;https://juejin.im/equation?tex=/Delta%20x&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;趋向于0时，我们获得的函数变化率就是函数的导数，这也是导数公式的由来：&lt;/p&gt;
&lt;span class=&quot;span-block-equation&quot; data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;equation&quot; src=&quot;https://juejin.im/equation?tex=/displaystyle%20f'(x_0)=/lim_{/Delta%20x%20/to%200}/frac{f(x_0+/Delta%20x)%20-%20f(x_0)}{/Delta%20x}&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们从微分的角度来看积分，也就是说我们来逆向思考这个过程。如果说我们获得的导数是&lt;span class=&quot;span-inline-equation&quot;&gt;&lt;span&gt;&lt;img class=&quot;equation&quot; src=&quot;https://juejin.im/equation?tex=f'(x)&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;，那么求导之前的函数f(x)会是什么呢？在这个问题当中，求导之前的函数称为&lt;strong&gt;原函数&lt;/strong&gt;，我们写成F(x)，如果F(x)是f(x)的原函数，那么它应该满足对于任意的&lt;span class=&quot;span-inline-equation&quot;&gt;&lt;span&gt;&lt;img class=&quot;equation&quot; src=&quot;https://juejin.im/equation?tex=x%20/in%20I&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;，都有&lt;span class=&quot;span-inline-equation&quot;&gt;&lt;span&gt;&lt;img class=&quot;equation&quot; src=&quot;https://juejin.im/equation?tex=F'(x)%20=%20f(x)&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如说因为&lt;span class=&quot;span-inline-equation&quot;&gt;&lt;span&gt;&lt;img class=&quot;equation&quot; src=&quot;https://juejin.im/equation?tex=F(x)%20=%20x^2&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;的导数是2x，所以&lt;span class=&quot;span-inline-equation&quot;&gt;&lt;span&gt;&lt;img class=&quot;equation&quot; src=&quot;https://juejin.im/equation?tex=x^2&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;是2x的原函数。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;函数和原函数的关系我们清楚，但是为了严谨，我们还需要思考一个问题，&lt;strong&gt;原函数一定存在吗&lt;/strong&gt;？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个问题看起来很绕，其实很容易想通，&lt;strong&gt;如果函数连续，那么原函数一定存在&lt;/strong&gt;。高数书上说这个是原函数存在定理，但是连一句话证明也没有，可想而知它基本上已经被当成是公理了。我们来简单分析一下，如函数f(x)连续，也就是说原函数的导数存在并且连续。我们知道连续不一定可导，但可导一定连续。现在导函数存在并且连续了，那么说明原函数一定连续。如果函数不存在怎么连续呢？所以当前函数f(x)连续，说明它的原函数F(x)一定存在。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;不定积分&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们搞明白了原函数之后，就可以开始不定积分的内容了。其实不定积分没什么计算内容，我倒觉得更像是映射。将当前函数映射成原函数。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也就是说，我们通过当前函数f(x)去寻找一个原函数F(x)，使得：&lt;span class=&quot;span-inline-equation&quot;&gt;&lt;span&gt;&lt;img class=&quot;equation&quot; src=&quot;https://juejin.im/equation?tex=F'(x)%20=%20f(x)&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;，我们把这个过程倒过来写，即：&lt;/p&gt;
&lt;span class=&quot;span-block-equation&quot; data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;equation&quot; src=&quot;https://juejin.im/equation?tex=F(x)%20=%20/int%20f(x)dx&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个式子其实就是&lt;strong&gt;求导的逆运算&lt;/strong&gt;，完全没有技术含量，应该都能看明白。这个时候，我们来问一个问题，对于一个确定的函数f(x)而言，它的原函数是确定的吗？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如我们刚刚那个例子&lt;span class=&quot;span-inline-equation&quot;&gt;&lt;span&gt;&lt;img class=&quot;equation&quot; src=&quot;https://juejin.im/equation?tex=f(x)%20=%202x&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;，那么它的原函数只有&lt;span class=&quot;span-inline-equation&quot;&gt;&lt;span&gt;&lt;img class=&quot;equation&quot; src=&quot;https://juejin.im/equation?tex=F(x)%20=%20x^2&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;吗？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案是明显的，&lt;strong&gt;不是&lt;/strong&gt;。我们随便就可以举出另一个原函数来：&lt;span class=&quot;span-inline-equation&quot;&gt;&lt;span&gt;&lt;img class=&quot;equation&quot; src=&quot;https://juejin.im/equation?tex=F(x)%20=%20x^2%20+%203&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;，同样，我们把后面的常数换成其他的值一样是合法的原函数。所以我们可以知道，原函数是无穷的，差别只在于最后跟的常数不同。也就是说原函数因为这个常数的存在是不确定的，这也是不定积分当中”&lt;strong&gt;不定&lt;/strong&gt;“两个字的由来。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;简单性质&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据不定积分的定义，我们可以推导出一些简单的性质。我们先来看第一个性质，也是最简单的性质：&lt;/p&gt;
&lt;span class=&quot;span-block-equation&quot; data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;equation&quot; src=&quot;https://juejin.im/equation?tex=/int%20k%20f(x)dx%20=%20k/int%20f(x)dx&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个证明非常简单，我们直接对原式求导即可：&lt;/p&gt;
&lt;span class=&quot;span-block-equation&quot; data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;equation&quot; src=&quot;https://juejin.im/equation?tex=[/int%20k%20f(x)dx]'%20=%20k/cdot%20f(x)%20=%20[k/int%20f(x)dx]'&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样简单的还有另一个性质：&lt;/p&gt;
&lt;span class=&quot;span-block-equation&quot; data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;equation&quot; src=&quot;https://juejin.im/equation?tex=/int%20[f(x)dx%20+%20g(x)dx]%20=%20/int%20f(x)dx%20+%20/int%20g(x)dx&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;证明方法和刚才一样，&lt;strong&gt;直接求导&lt;/strong&gt;即可。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，以上就是不定积分的全部性质了。你可能会问为什么性质里面没有乘法和除法的性质？我也曾经好奇过这个问题，因为在我查过得所有资料当中都没有相关的公式。我自己也试着推导过，但是没有什么结果。这当然不是数学家们偷懒或者是算不出来，估计可能是太过复杂，所以不太实用吧。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;基本积分表&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，我们来看一下不定积分的基本积分表，方便我们计算的时候查询。&lt;/p&gt;
$$ \begin{aligned} \int kdx &amp;amp;= kx+C \\ \int x^{\mu}dx &amp;amp;= \frac{x^{\mu+1}}{\mu+1}+C \\ \int \frac{dx}{x} &amp;amp;= \ln|x| + C \\ \int \frac{dx}{1+x^2} &amp;amp;= \arctan x + C\\ \int \frac{dx}{1-x^2} &amp;amp;= \arcsin x + C\\ \int \cos x dx &amp;amp;= \sin x + C\\ \int \sin x dx &amp;amp;= -\cos x + C\\ \int \frac{dx}{\cos^2x}&amp;amp;=\int \sec^2x dx = \tan x + C \\ \int \frac{dx}{\sin^2 x} &amp;amp;= \int \csc^2 x dx = -\cot x + C\\ \int \sec x \tan x dx &amp;amp;= \sec x + C\\ \int \csc x \cot x dx &amp;amp;= -\csc x + C\\ \int e^xdx &amp;amp;= e^x + C\\ \int a^x dx &amp;amp;= \frac{a^x}{\ln a} + C \end{aligned} $$
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不定积分本身的内容就是这么多，理解起来并不困难。不过在实际解决问题的过程当中，还存在一些解题的技巧，由于篇幅问题，我们放到下一篇文章当中和大家一起分享。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天的文章就是这些，如果觉得有所收获，请顺手点个&lt;strong&gt;关注或者转发&lt;/strong&gt;吧，你们的举手之劳对我来说很重要。&lt;/p&gt;
&lt;/section&gt;&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/3/20/170f5626d00b1c78?w=258&amp;amp;h=258&amp;amp;f=png&amp;amp;s=23988&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 20 Mar 2020 00:45:00 +0000</pubDate>
<dc:creator>TechFlow2019</dc:creator>
<og:description>本文始发于个人公众号： TechFlow ，原创不易，求个关注 今天是高等数学专题的第8篇文章，今天的内容是不定积分。 我之前的高数老师曾经说过，高等数学就是大半本的微积分加上一些数列和极限的知识。而</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/techflow/p/12529498.html</dc:identifier>
</item>
<item>
<title>2020软件工程作业03 - 波兰杜兰特</title>
<link>http://www.cnblogs.com/RCJames/p/12529492.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/RCJames/p/12529492.html</guid>
<description>&lt;h3 id=&quot;github项目地址-httpsgithub.comzxw0621demotreemaster20177596src&quot;&gt;&lt;strong&gt;Github项目地址：&lt;/strong&gt; &lt;a href=&quot;https://github.com/zxw0621/demo/tree/master/20177596/src&quot; class=&quot;uri&quot;&gt;https://github.com/zxw0621/demo/tree/master/20177596/src&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;psp表格&quot;&gt;PSP表格&lt;/h3&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;6.5&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Planning&lt;/td&gt;
&lt;td&gt;计划&lt;/td&gt;
&lt;td&gt;30&lt;/td&gt;
&lt;td&gt;20&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Estimate&lt;/td&gt;
&lt;td&gt;估计这个任务需要多少时间&lt;/td&gt;
&lt;td&gt;600&lt;/td&gt;
&lt;td&gt;700&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Development&lt;/td&gt;
&lt;td&gt;开发&lt;/td&gt;
&lt;td&gt;300&lt;/td&gt;
&lt;td&gt;200&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Analysis&lt;/td&gt;
&lt;td&gt;需求分析 (包括学习新技术)&lt;/td&gt;
&lt;td&gt;30&lt;/td&gt;
&lt;td&gt;20&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Design Spec&lt;/td&gt;
&lt;td&gt;生成设计文档&lt;/td&gt;
&lt;td&gt;30&lt;/td&gt;
&lt;td&gt;30&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;Design Review&lt;/td&gt;
&lt;td&gt;设计复审&lt;/td&gt;
&lt;td&gt;60&lt;/td&gt;
&lt;td&gt;30&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Coding Standard&lt;/td&gt;
&lt;td&gt;代码规范 (为目前的开发制定合适的规范)&lt;/td&gt;
&lt;td&gt;30&lt;/td&gt;
&lt;td&gt;20&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;Design&lt;/td&gt;
&lt;td&gt;具体设计&lt;/td&gt;
&lt;td&gt;30&lt;/td&gt;
&lt;td&gt;30&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Coding&lt;/td&gt;
&lt;td&gt;具体编码&lt;/td&gt;
&lt;td&gt;60&lt;/td&gt;
&lt;td&gt;60&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;Code Review&lt;/td&gt;
&lt;td&gt;代码复审&lt;/td&gt;
&lt;td&gt;60&lt;/td&gt;
&lt;td&gt;20&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Test&lt;/td&gt;
&lt;td&gt;测试（自我测试，修改代码，提交修改）&lt;/td&gt;
&lt;td&gt;30&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;Reporting&lt;/td&gt;
&lt;td&gt;报告&lt;/td&gt;
&lt;td&gt;20&lt;/td&gt;
&lt;td&gt;20&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Test Repor&lt;/td&gt;
&lt;td&gt;测试报告&lt;/td&gt;
&lt;td&gt;20&lt;/td&gt;
&lt;td&gt;20&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;Size Measurement&lt;/td&gt;
&lt;td&gt;计算工作量&lt;/td&gt;
&lt;td&gt;20&lt;/td&gt;
&lt;td&gt;20&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;5&quot;&gt;&lt;td&gt;Postmortem &amp;amp; Process Improvement Plan&lt;/td&gt;
&lt;td&gt;事后总结, 并提出过程改进计划&lt;/td&gt;
&lt;td&gt;30&lt;/td&gt;
&lt;td&gt;30&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;合计&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;1350&lt;/td&gt;
&lt;td&gt;1230&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;思路描述&quot;&gt;思路描述&lt;/h3&gt;
&lt;hr/&gt;&lt;h4 id=&quot;审题&quot;&gt;审题&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;按照数独游戏的规定，给一张含有若干的数字随机分布在网格的图，在每个位置上的数在列和行上不能重复出现，在4、6、8、9阶的数独表中，每个小宫格内不能有重复的数出现。&lt;/li&gt;
&lt;li&gt;用cmd命令行的形式读出写入文件，并传入参数。&lt;/li&gt;
&lt;li&gt;要实现多个九宫格一起处理。&lt;/li&gt;
&lt;li&gt;要求用java和c++，这里顺便学习下python（从大一刚学那会就学习过一点点，后来忙于学习学校安排的课程后没怎么学了，以后还想接触些脍炙人口的新鲜事物，比如某些大佬开口就是什么大数据，云计算，人工智能的）&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;
&lt;h5 id=&quot;功能模块设计&quot;&gt;功能模块设计&lt;/h5&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def new_locate(_x_, _y_, _a_, _b_):  #上面的版本是学习小邓同学的定位
    '''
    新版定位
    :param _x_:
    :param _y_:
    :return:
    '''
    if M % 3 == 0:   #通过向下取整计算出 大的九宫格能分成几行几列的小九宫格
        _c_ = 3
        _r_ = int(M / 3)
    elif M % 2 == 0:
        _c_ = 2
        _r_ = int(M / 2)
    _a_ = int(_x_ // _c_ * _c_)
    _b_ = int(_y_ // _r_ * _r_)c_:_r_
    return _a_, _b_, _c_, _r_   #这里返回 _a_: 当前元素所在的小九宫格 左上角的横坐标
                               #         _b_: 当前元素所在的小九宫格 左上角的纵坐标
                               #         _c_: 大九宫格被分成了 c行 r列的小九宫格
                               #         _r_:


# def locate(_x_, _y_, _a_, _b_):     #莽夫判断  respect阿传
#     '''
#     确定当前元素所在九宫格位置
#     :param _x_:
#     :param _y_:
#     :param a:
#     :param b:
#     :return:
#     '''
#     if 0 &amp;lt;= _x_ &amp;lt; 3 and 0 &amp;lt;= _y_ &amp;lt; 3:
#         _a_ = 0
#         _b_ = 0
#
#     if 3 &amp;lt;= _x_ &amp;lt; 6 and 0 &amp;lt;= _y_ &amp;lt; 3:
#         _a_ = 3
#         _b_ = 0
#
#     if 6 &amp;lt;= _x_ &amp;lt; 9 and 0 &amp;lt;= _y_ &amp;lt; 3:
#         _a_ = 6
#         _b_ = 0
#
#     if 0 &amp;lt;= _x_ &amp;lt; 3 and 3 &amp;lt;= _y_ &amp;lt; 6:
#         _a_ = 0
#         _b_ = 3
#
#     if 0 &amp;lt;= _x_ &amp;lt; 3 and 6 &amp;lt;= _y_ &amp;lt; 9:
#         _a_ = 0
#         _b_ = 6
#
#     if 3 &amp;lt;= _x_ &amp;lt; 6 and 3 &amp;lt;= _y_ &amp;lt; 6:
#         _a_ = 3
#         _b_ = 3
#
#     if 3 &amp;lt;= _x_ &amp;lt; 6 and 6 &amp;lt;= _y_ &amp;lt; 9:
#         _a_ = 3
#         _b_ = 6
#
#     if 6 &amp;lt;= _x_ &amp;lt; 9 and 3 &amp;lt;= _y_ &amp;lt; 6:
#         _a_ = 6
#         _b_ = 3
#
#     if 6 &amp;lt;= _x_ &amp;lt; 9 and 6 &amp;lt;= _y_ &amp;lt; 9:
#         _a_ = 6
#         _b_ = 6
#     return _a_, _b_&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h5 id=&quot;行列无重复判断模块&quot;&gt;行列无重复判断模块&lt;/h5&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def fun(_x_, _y_):
    '''
    确定行列上不重复
    :param inde__x_:
    :param _y_:
    :param num:
    :return:
    '''

    for _i_ in range(M):
        if _i_ != _x_ and DATA[_i_][_y_] == DATA[_x_][_y_]:#遍历行
            return 0
    for j in range(M):
        if j != _y_ and DATA[_x_][j] == DATA[_x_][_y_]:#遍历列
            return 0
    _a_ = 0
    _b_ = 0
    _a_, _b_, _c_, _r_ = new_locate(_x_, _y_, _a_, _b_) 
    for _i_ in range(_a_, _a_ + _c_):
        for j in range(_b_, _b_ + _r_):
            if _i_ != _x_ and j != _y_ and DATA[_i_][j] == DATA[_x_][_y_]:#遍历小九宫格
                return 0
    return 1&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h5 id=&quot;深度优先搜索模块&quot;&gt;深度优先搜索模块&lt;/h5&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def dfs(_x_, _y_):
    '''
    深搜
    :param _x_:
    :param _y_:
    :return:
    '''
#这里就相当于给没填数字的格子 尝试可能填的数
    if _x_ &amp;gt; M - 1:
        disp()
    elif DATA[_x_][_y_] != 0:
        if _y_ == M - 1:
            dfs(_x_ + 1, 0)
        else:
            dfs(_x_, _y_ + 1)
    else:
        for _i_ in range(1, M + 1):
            DATA[_x_][_y_] = _i_  #从1到M 赋值尝试
            if fun(_x_, _y_) == 1:
                if _y_ == M - 1:
                    dfs(_x_ + 1, 0)
                else:
                    dfs(_x_, _y_ + 1)
        DATA[_x_][_y_] = 0  #回溯&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h5 id=&quot;文件的写入读出&quot;&gt;文件的写入读出&lt;/h5&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;for line in FP.readlines(): #读出
    arr = line.strip().split(&quot; &quot;)
    if arr[0] &amp;gt;= '0':
        int_arr = list(map(int, arr))
        DATA.append(int_arr)
#分行读出 每隔一个空格读一个数  map函数用于将读取到的内容转int整型 保存成列表数组List
写入有个write函数就完事了&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h5 id=&quot;命令行输入&quot;&gt;命令行输入&lt;/h5&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;python命令行输入用 import sys
 然后用sys.argv[x]数组输入
sys.argv[0]表示的是你的py文件名   用sys.argv[1......]  按你输入的顺序赋值给你要的参数变量&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1952656/202003/1952656-20200319175159392-1380374918.png&quot; alt=&quot;命令行输入图片&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;性能改进&quot;&gt;性能改进&lt;/h3&gt;
&lt;hr/&gt;&lt;p&gt;改进了定位模块 上文有提到 实现3-9阶九宫格都可以定位&lt;/p&gt;
&lt;h3 id=&quot;心路历程&quot;&gt;心路历程&lt;/h3&gt;
&lt;hr/&gt;&lt;p&gt;一拿到题目的时候，我是拒绝的。彭琛老师发布的作业也太快了，妈妈再也不用担心我手指不灵活了，妈妈再也不用担心我会出门花钱了，妈妈再也不用担心洗发水用的完了，这算法 题，我裂开，这怎么做，算法我学了啥。大一：彭琛老师教给我们冒泡排序法。大二：数据结构课上，冒泡排序法，我一气呵成，老师说我这发量还不行。大三：算法课上，各种指针嵌套递归回溯，一到实验课，冒泡排序法信手捏来。预测大四：《论冒泡排序法的基本思想》朱旭炜20177596.doc。其实没有老师发布的作业，我真不会接触算法这些东西，既然发布了，还是先端正下态度哈。完成代码编写的过程也是十分艰辛，在CSDN上也看了一些其他大佬的实现思路，结合作业的要求完成。&lt;/p&gt;
&lt;p&gt;​ 关于《构建之法》：&lt;/p&gt;
&lt;p&gt;​ &lt;strong&gt;下次我一定看!&lt;/strong&gt; &lt;img src=&quot;http://ww4.sinaimg.cn/bmiddle/9150e4e5gw1f9hjjuo3bzg201s01swed.gif&quot; alt=&quot;滑稽&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;单元测试&quot;&gt;单元测试&lt;/h3&gt;
&lt;hr/&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import unittest

from sudoku import new_locate

class MyTestCase(unittest.TestCase):
    def test_fun(self):
        test_num=new_locate(5,8,0,0)
        self.assertEqual(test_num,(3,6,3,3))


if __name__ == '__main__':
    unittest.main()
#计算新定位模块是否能正常计算出_a_,_b_,_c_,_r_&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;静态检测工具pylint&quot;&gt;静态检测（工具：PyLint）&lt;/h3&gt;
&lt;hr/&gt;&lt;p&gt;​ 刚完成的代码那会，点pylint，出来好多啊，结合上次作业出现的问题总结下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;写完代码前，点击Code - &amp;gt; Reformat Code, 在pycharm最上面那条找得到，这个效果是整理代码，点完这个都能消除很多提醒和警告&lt;/li&gt;
&lt;li&gt;变量命名的方法，提醒你大写你就全大写，提醒snake命名就写成_name_ 像这样的，当然我也不知道这样规范不，请大佬教育下我&lt;/li&gt;
&lt;li&gt;def函数块里面要写注释，这个提醒也太人性化了，怕别人看你的代码时候看不懂，不然就&lt;strong&gt;C0116&lt;/strong&gt;提醒了，这个搞了我好久，专门折磨我这种强迫症，类似的不写注释还有&lt;strong&gt;C0114&lt;/strong&gt;，写在最上面就好了，告诉别人你这整个代码干嘛用的&lt;/li&gt;
&lt;li&gt;还有就是要简化 &lt;strong&gt;i f&lt;/strong&gt; 判断，特别是多个并列条件的判断&lt;/li&gt;
&lt;li&gt;还有减少else后面不必要的return ，不要写else： 这样的，第一个判断里面有return的话，程序都出去了，没必要再else：return return x&lt;/li&gt;
&lt;li&gt;暂无其他问题了，以后碰到会继续补充，也请大佬们指指点点下&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;hr/&gt;&lt;p&gt;​ 虽然没做过算法题，通过自己查资料，咨询大佬后还是对问题的解答有所思路的，python挺好用的。希望彭琛老师发布作业的速度可以慢点，顶不住，早点开学吧，我太难了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://wx3.sinaimg.cn/large/006APoFYly1g5f23gg0iag308v08vqrq.gif&quot; alt=&quot;giao&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;section&quot;/&gt;
</description>
<pubDate>Fri, 20 Mar 2020 00:44:00 +0000</pubDate>
<dc:creator>波兰杜兰特</dc:creator>
<og:description>| 软件工程 | &amp;quot;2020软件工程作业&amp;quot; | | : : | : : | | 作业要求 | https://edu.cnblogs.com/campus/zswxy/softwa</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/RCJames/p/12529492.html</dc:identifier>
</item>
<item>
<title>Flask 蓝图 - Jeff的技术栈</title>
<link>http://www.cnblogs.com/guyouyin123/p/12529485.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/guyouyin123/p/12529485.html</guid>
<description>&lt;pre&gt;
&lt;code&gt;利用蓝图对程序的目录进行划分，方便管理&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1736414/202003/1736414-20200319202726962-871019244.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;init.py文件&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from flask import Flask

app = Flask(__name__)

# 导入其他的文件
# app = Flask(__name__,template_folder='templates',static_folder='statics',static_url_path='/static')

from app01 import user  # 导入页面
app.register_blueprint(user.us)  # 注册页面

from app01 import order  # 导入页面
app.register_blueprint(order.ord)  # 注册页面
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;order.py文件&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from  flask import Blueprint  # 导入蓝图
ord = Blueprint(&quot;order&quot;,__name__)  # 生成专属order页面的app对象

# 使用
@ord.route(&quot;/order&quot;)
def order():
    return &quot;order&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;user.py文件&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from flask import Blueprint  # 导入蓝图

us = Blueprint(&quot;user&quot;,__name__)  # 生成专属user页面的app对象

# 使用
@us.route(&quot;/user&quot;)
def user():
    return &quot;user&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;manage.py启动文件&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from app01 import app


if __name__ == '__main__':
    app.run()&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 20 Mar 2020 00:43:00 +0000</pubDate>
<dc:creator>Jeff的技术栈</dc:creator>
<og:description>[TOC] 蓝图的作用 使用 init.py文件 order.py文件 user.py文件 manage.py启动文件</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/guyouyin123/p/12529485.html</dc:identifier>
</item>
<item>
<title>Linux内核文档：如何写符合 kernel-doc 规范的注释 - 广漠飘羽</title>
<link>http://www.cnblogs.com/gmpy/p/12529456.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/gmpy/p/12529456.html</guid>
<description>&lt;p&gt;Linux内核强大的文档功能，除了直接转换 ```.rst```文档之外，还能从源码中汲取API说明，结构体说明等信息。当然要做到这样，源码的注释是有一定要求的。而这篇文档，就是介绍如何写符合 *kernel-doc* 格式要求的注释。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;220.1159044221&quot;&gt;
&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;Linux内核使用 &lt;a href=&quot;http://www.sphinx-doc.org/&quot;&gt;Sphinx&lt;/a&gt; 实现把 &lt;em&gt;Documentation&lt;/em&gt; 目录下的 &lt;a href=&quot;http://docutils.sourceforge.net/rst.html&quot;&gt;reStructuredText&lt;/a&gt; 文件转换为非常漂亮的文档。文档既可以通过 &lt;strong&gt;make htmldocs&lt;/strong&gt; 转换成 &lt;em&gt;HTML&lt;/em&gt; 格式，也可以通过 &lt;strong&gt;make pdfdocs&lt;/strong&gt; 转换为 &lt;em&gt;PDF&lt;/em&gt; 格式。 转换生成的文档存放于 &lt;em&gt;Documentation/output&lt;/em&gt; 目录下。&lt;/p&gt;
&lt;p&gt;Linux内核强大的文档功能，除了直接转换 &lt;code&gt;.rst&lt;/code&gt;文档之外，还能从源码中汲取API说明，结构体说明等信息。当然要做到这样，源码的注释是有一定要求的。而这篇文档，就是介绍如何写符合 &lt;em&gt;kernel-doc&lt;/em&gt; 格式要求的注释。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.kernel.org/doc/html/latest/doc-guide/kernel-doc.html&quot;&gt;英文版原文&lt;/a&gt;，根据个人理解做的翻译，如果有翻译错误的地方，请告知。&lt;/p&gt;
&lt;h2 id=&quot;注释概述&quot;&gt;注释概述&lt;/h2&gt;
&lt;p&gt;符合 &lt;em&gt;kernel-doc&lt;/em&gt; 的注释，都需要从 &lt;code&gt;/**&lt;/code&gt; 开始，其后每一行内容都以 &lt;code&gt;*&lt;/code&gt;开头，最后是 &lt;code&gt;*/&lt;/code&gt; 表示结束。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * This is a sample of comment
 */&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于函数和类型的注释，必须放在函数和类型之前，以便于别人在修改代码的时候，可以顺手把注释也改了。对概述类型的注释，可以放到文件顶部的位置。&lt;/p&gt;
&lt;p&gt;Linux内核有提供一个工具用于对 &lt;em&gt;kernel-doc&lt;/em&gt; 的格式进行检查，例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ scripts/kernel-doc -v -none drivers/foo/bar.c&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然，在编译的时候，如果添加以下的选项，也会检查文档的格式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;make W=n&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;函数文档&quot;&gt;函数文档&lt;/h2&gt;
&lt;p&gt;规范的格式示例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * function_name() - Brief description of function.
 * @arg1: Describe the first argument.
 * @arg2: Describe the second argument.
 *        One can provide multiple line descriptions
 *        for arguments.
 *
 * A longer description, with more discussion of the function function_name()
 * that might be useful to those using or modifying it. Begins with an
 * empty comment line, and may include additional embedded empty
 * comment lines.
 *
 * The longer description may have multiple paragraphs.
 *
 * Context: Describes whether the function can sleep, what locks it takes,
 *          releases, or expects to be held. It can extend over multiple
 *          lines.
 * Return: Describe the return value of function_name.
 *
 * The return value description can also have multiple paragraphs, and should
 * be placed at the end of the comment block.
 */&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;函数名后的函数功能简介可以跨越多行，以函数参数描述、返回值描述或其他描述结束。&lt;/p&gt;
&lt;h3 id=&quot;函数参数&quot;&gt;函数参数&lt;/h3&gt;
&lt;p&gt;函数参数的描述，必须直接且按顺序放在函数简介之后。需要注意的是，函数参数与函数简介、函数参数与函数参数之间不能有任何空行。&lt;/p&gt;
&lt;p&gt;每个函数参数的描述可以跨行，但要注意的是，必须保持缩进对齐，例如&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;* @argument: some long description
*            that continues on next lines   # that 必须与 some对齐（避免排版乱套，补充说明）&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或者&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;* @argument:
*         some long description
*         that continues on next lines&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;函数参数-1&quot;&gt;函数参数&lt;/h3&gt;
&lt;p&gt;如果出现不定数量个参数，可以这么表示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;* @...: description&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;函数上下文&quot;&gt;函数上下文&lt;/h3&gt;
&lt;p&gt;描述这个函数会在什么场景下调用，就是函数上下文字段所要做的。函数上下文字段用&lt;code&gt;Context:&lt;/code&gt;表示，应该包含函数是否会休眠，是否会在中断中调用，以及它会持有、释放什么锁，和其他所有调用这个函数需要注意的东西。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;* Context: Any context.
* Context: Any context. Takes and releases the RCU lock.
* Context: Any context. Expects &amp;lt;lock&amp;gt; to be held by caller.
* Context: Process context. May sleep if @gfp flags permit.
* Context: Process context. Takes and releases &amp;lt;mutex&amp;gt;.
* Context: Softirq or process context. Takes and releases &amp;lt;lock&amp;gt;, BH-safe.
* Context: Interrupt context.&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;函数返回值&quot;&gt;函数返回值&lt;/h3&gt;
&lt;p&gt;函数返回值相关的描述应该放在&lt;code&gt;Return:&lt;/code&gt;字段。&lt;/p&gt;
&lt;p&gt;由于不能识别换行，因此如果你这样写：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;* Return:
* 0 - OK
* -EINVAL - invalid argument
* -ENOMEM - out of memory&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果只会是：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Return: 0 - OK -EINVAL - invalid argument -ENOMEM - out of memory&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以呢，如果你要换行，你需要使用 &lt;em&gt;ReST List&lt;/em&gt;，例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;* Return:
* * 0             - OK to runtime suspend the device
* * -EBUSY        - Device should not be runtime suspended&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;另外，如果字段出现类似&lt;code&gt;key:&lt;/code&gt;这样短语加冒号的形式，会被识别为其他的字段。这点需要注意。&lt;/p&gt;
&lt;h2 id=&quot;struct-和-union-和-enum-类型的注释&quot;&gt;struct 和 union 和 enum 类型的注释&lt;/h2&gt;
&lt;p&gt;通常 &lt;em&gt;struct&lt;/em&gt; ，&lt;em&gt;union&lt;/em&gt; 和 &lt;em&gt;enum&lt;/em&gt; 类型的注释说明是这样的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * struct struct_name - Brief description.
 * @member1: Description of member1.
 * @member2: Description of member2.
 *           One can provide multiple line descriptions
 *           for members.
 *
 * Description of the structure.
 */&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;紧随名字后面的 &lt;em&gt;Brief description&lt;/em&gt; 可以跨度几行，它以 &lt;em&gt;@member&lt;/em&gt; 字段、空行或者&lt;code&gt;*/&lt;/code&gt;表示结束。&lt;/p&gt;
&lt;h3 id=&quot;成员&quot;&gt;成员&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;struct&lt;/em&gt;，&lt;em&gt;union&lt;/em&gt; 和 &lt;em&gt;enum&lt;/em&gt; 的成员注释格式与函数参数的格式一致，他们都需要简短的描述且支持换行。&lt;/p&gt;
&lt;p&gt;在 &lt;em&gt;struct&lt;/em&gt; 和 &lt;em&gt;union&lt;/em&gt; 里面也支持注释。支持 &lt;code&gt;private&lt;/code&gt; 和 &lt;code&gt;public&lt;/code&gt; 两种标签。&lt;code&gt;private&lt;/code&gt; 标签的成员不会呈现到编译出来的文档上，类似与 &lt;em&gt;C++&lt;/em&gt; 上的 private 成员。&lt;/p&gt;
&lt;p&gt;需要注意的是，&lt;code&gt;private&lt;/code&gt; 和 &lt;code&gt;public&lt;/code&gt; 标签必须以&lt;code&gt;\*&lt;/code&gt;标识开始且不能有缩进，以&lt;code&gt;*/&lt;/code&gt;标识结束。如果有简介，可以写在&lt;code&gt;:&lt;/code&gt;与结束标识&lt;code&gt;*/&lt;/code&gt;之间，例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * struct my_struct - short description
 * @a: first member
 * @b: second member
 * @d: fourth member
 *
 * Longer description
 */
struct my_struct {
    int a;
    int b;
/* private: internal use only */
    int c;
/* public: the next one is public */
    int d;
};&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;嵌套struct和union&quot;&gt;嵌套struct和union&lt;/h3&gt;
&lt;p&gt;如果出现嵌套定义 &lt;code&gt;struct&lt;/code&gt;和&lt;code&gt;union&lt;/code&gt;，可以参考下面的做法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * struct nested_foobar - a struct with nested unions and structs
 * @memb1: first member of anonymous union/anonymous struct
 * @memb2: second member of anonymous union/anonymous struct
 * @memb3: third member of anonymous union/anonymous struct
 * @memb4: fourth member of anonymous union/anonymous struct
 * @bar: non-anonymous union
 * @bar.st1: struct st1 inside @bar
 * @bar.st2: struct st2 inside @bar
 * @bar.st1.memb1: first member of struct st1 on union bar
 * @bar.st1.memb2: second member of struct st1 on union bar
 * @bar.st2.memb1: first member of struct st2 on union bar
 * @bar.st2.memb2: second member of struct st2 on union bar
 */
struct nested_foobar {
  /* Anonymous union/struct*/
  union {
    struct {
      int memb1;
      int memb2;
    }
    struct {
      void *memb3;
      int memb4;
    }
  }
  union {
    struct {
      int memb1;
      int memb2;
    } st1;
    struct {
      void *memb1;
      int memb2;
    } st2;
  } bar;
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有两点要注意的：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;如果嵌套的&lt;code&gt;struct&lt;/code&gt;或者&lt;code&gt;union&lt;/code&gt;有命名，那么应该使用&lt;code&gt;@foo.bar&lt;/code&gt;的形式，例如上例的&lt;code&gt;@bar.st1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果是匿名的，那么需要直接使用&lt;code&gt;@bar&lt;/code&gt;的形式，例如上例的&lt;code&gt;@memb1&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;细心的小伙伴可能发现，这与C语言上结构体的调用方式非常相似。&lt;/p&gt;
&lt;h3 id=&quot;内联的成员描述&quot;&gt;内联的成员描述&lt;/h3&gt;
&lt;p&gt;成员的描述除了放在开头，还可以放在 &lt;em&gt;struct&lt;/em&gt; 和 &lt;em&gt;union&lt;/em&gt; 里面。支持单行或者多行，以&lt;code&gt;/**&lt;/code&gt;开头，以&lt;code&gt;*/&lt;/code&gt;结束。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/*
 * struct foo - Brief description.
 * @foo: The Foo member.
 */
struct foo {
      int foo;
      /**
       * @bar: The Bar member.
       */
      int bar;
      /**
       * @baz: The Baz member.
       *
       * Here, the member description may contain several paragraphs.
       */
      int baz;
      union {
              /** @foobar: Single line description. */
              int foobar;
      };
      /** @bar2: Description for struct @bar2 inside @foo */
      struct {
              /**
               * @bar2.barbar: Description for @barbar inside @foo.bar2
               */
              int barbar;
      } bar2;
};&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;typedef注释&quot;&gt;typedef注释&lt;/h2&gt;
&lt;p&gt;通常格式如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * typedef type_name - Brief description.
 *
 * Description of the type.
 */&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果是函数的类型定义，也可以这样：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * typedef type_name - Brief description.
 * @arg1: description of arg1
 * @arg2: description of arg2
 *
 * Description of the type.
 *
 * Context: Locking context.
 * Return: Meaning of the return value.
 */
 typedef void (*type_name)(struct v4l2_ctrl *arg1, void *arg2);&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;高亮和交叉索引&quot;&gt;高亮和交叉索引&lt;/h2&gt;
&lt;p&gt;在各种说明字段中，可以用以下的形式做成索引。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;funcname()&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;索引到函数&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;@parameter&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;索引到函数参数(只在本函数内索引，不会交叉到其他函数)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;%CONST&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;索引到指定名字的上下文段说明(只在本函数内索引，不会交叉到其他函数)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;``literal``&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;字面意义，让 kernel-doc 不解析，做纯字符串处理。常用于出现与 kernel-doc 或者 reStructuredText 关键字冲突的情况&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;$ENVVAR&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;环境变量(只在本函数内索引，不会交叉到其他函数)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;&amp;amp;struct name&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;索引到其他结构体&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;&amp;amp;enum name&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;索引到其他的枚举型&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;&amp;amp;typedef name&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;索引到typedef定义的类型&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;&amp;amp;struct_name-&amp;gt;member or &amp;amp;struct_name.member&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;索引到制定结构体成员&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;&amp;amp;name&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;泛型类型引用。不建议使用，请使用其他方法&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;概述说明&quot;&gt;概述说明&lt;/h2&gt;
&lt;p&gt;为了便于将源代码和注释紧密结合在一起，可以包含自由格式注释的内核文档块，而不是函数、结构、联合、枚举或typedef的内核文档块。例如，这可以用于驱动程序或库代码的操作理论。&lt;/p&gt;
&lt;p&gt;这是通过使用带有节标题的DOC:section关键字来完成的。&lt;/p&gt;
&lt;p&gt;通用的格式如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * DOC: Theory of Operation
 *
 * The whizbang foobar is a dilly of a gizmo. It can do whatever you
 * want it to do, at any time. It reads your mind. Here's how it works.
 *
 * foo bar splat
 *
 * The only drawback to this gizmo is that is can sometimes damage
 * hardware, software, or its subject(s).
 */&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;DOC:后面的标题用作源文件中的标题，也用作提取文档注释的标识符。因此，标题在文件中必须是唯一的。&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Fri, 20 Mar 2020 00:39:00 +0000</pubDate>
<dc:creator>广漠飘羽</dc:creator>
<og:description>Linux内核强大的文档功能，除了直接转换 ```.rst```文档之外，还能从源码中汲取API说明，结构体说明等信息。当然要做到这样，源码的注释是有一定要求的。而这篇文档，就是介绍如何写符合 *ke</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/gmpy/p/12529456.html</dc:identifier>
</item>
<item>
<title>Java 基础（六）：循环 - Vi的技术博客</title>
<link>http://www.cnblogs.com/viyoung/p/12529440.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/viyoung/p/12529440.html</guid>
<description>&lt;h3 id=&quot;循环&quot;&gt;循环&lt;/h3&gt;
&lt;p&gt;老生常谈的一个控制流程了，我们在是使用数组和集合的时候，遍历元素的时候经常会用到循环的结构，Java具有非常灵活的三种循环机制：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://viyoungblog.oss-cn-beijing.aliyuncs.com/2019-08-27-142828.png&quot; alt=&quot;image-20190827222828453&quot;/&gt;&lt;/p&gt;
&lt;p&gt;根据是否知道循环的次数可以为分为while循环，do...while循环和for循环，下面我们单独来了解一下：&lt;/p&gt;
&lt;h3 id=&quot;while循环&quot;&gt;while循环&lt;/h3&gt;
&lt;p&gt;当我们不知道循环的具体次数时，可以使用while循环进行操作，下面是while循环的伪代码&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;定义初始变量  
while (控制条件) {
    循环体
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://viyoungblog.oss-cn-beijing.aliyuncs.com/2019-08-27-142337.png&quot; alt=&quot;image-20190827222337726&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代码示例：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;        //    定义控制循环变量
       int start = 0;
    //    循环条件
       while (start &amp;lt; 2) {
        //    循环体
        System.out.println(&quot;1&quot;);
        //  改变控制循环变量
        start++;
       }
   }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;do...while循环&quot;&gt;do...while循环&lt;/h3&gt;
&lt;p&gt;和while循环类似，do...while循环同样适用于不知道循环具体的次数时，但是和while循环不太一样的是，如果控制循环的变量初始时就不符合循环条件，那么循环体一次也不会执行，而do...while循环至少会把循环体执行一次。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;定义初始变量
do {
   循环体
} while (循环条件);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://viyoungblog.oss-cn-beijing.aliyuncs.com/2019-08-27-143155.png&quot; alt=&quot;image-20190827223154870&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代码示例：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;        //    定义控制循环变量
       int start = 0;
    do {
        // 循环体
        System.out.println(&quot;1&quot;);
        // 控制循环变量
        start++;
        // 循环条件
    } while(start &amp;lt; 0);&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;for循环&quot;&gt;for循环&lt;/h3&gt;
&lt;p&gt;下面进入了我们的重头戏，日常中使用的最多的for循环，由于普通for循环可以准确的控制循环的次数，所以一般当我们在需要手动控制循环次数的时候，我们会使用普通for循环&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;for(定义初始变量;判断条件;变量变化){
  循环体
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的流程图和while是类似的，下面我们来看一下如何遍历一个数组：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;int[] a = {1,2,3,4};
for (int i = 0; i &amp;lt; a.length; i++) {
  System.out.println(a[i]);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同样的遍历一个集合也可以使用普通for循环：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
list.add(1);
list.add(2);
list.add(3);
list.add(4);
for (int i = 0; i &amp;lt; list.size(); i++) {
  System.out.println(list.get(i));
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里细心的同学可能已经注意到了，我们这里描述的时候一直使用的是普通for循环，那么既然有普通的for循环，就一定有不普通的for循环，下面我们来看一下两种不太普通的for循环&lt;/p&gt;
&lt;h4 id=&quot;增强for循环&quot;&gt;增强for循环&lt;/h4&gt;
&lt;p&gt;在JDK 5之后，出现了一种语法糖--forEach循环，也称之为增强for循环，循环语法如下&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;for(数据类型 定义元素名：循环列表) {
  循环体
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;foreach语句是for语句的特殊简化版本，但是foreach语句并不能完全取代for语句，然而，任何的foreach语句都可以改写为for语句版本。 foreach并不是一个关键字，习惯上将这种特殊的for语句格式称之为“foreach”语句。&lt;/p&gt;
&lt;h4 id=&quot;关于增强for循环和普通for循环的效率问题&quot;&gt;关于增强for循环和普通for循环的效率问题&lt;/h4&gt;
&lt;p&gt;数组遍历：增强型for循环和普通循环遍历原理相同，效率相同。&lt;/p&gt;
&lt;p&gt;集合遍历：增强型for循环的遍历其本质就是迭代器 iterator的遍历,和普通循环遍历相比，各自有自己适用的场景，比如说普通for循环比较适合List类（数组类）遍历通过下标查找数据的，而增强型for循环则比较适合&lt;strong&gt;链表&lt;/strong&gt;结构的集合的遍历。&lt;/p&gt;
&lt;p&gt;在&lt;strong&gt;数据量较大&lt;/strong&gt;的情况下，如果是集合使用增强for循环的效率会低于使用普通for循环。&lt;/p&gt;
&lt;h3 id=&quot;跳出循环的两个关键字&quot;&gt;跳出循环的两个关键字&lt;/h3&gt;
&lt;p&gt;我们在使用的过程中，如果遇到需要中断一个流程的情况，通常会使用到以下两个关键字：&lt;code&gt;break&lt;/code&gt;和&lt;code&gt;continue&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;break&lt;/code&gt; 主要用在循环语句或者 switch 语句中，用来跳出整个语句块。break 跳出最里层的循环，并且继续执行该循环下面的语句。当然我们也可以使用标签的方式来跳出某个指定的循环。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;read_data:
while(...) {
    for(...) {
        break read_data;    //这里就是直接跳出了while循环
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;continue&lt;/code&gt; 适用于&lt;strong&gt;任何循环控制结构&lt;/strong&gt;中。作用是让程序立刻&lt;strong&gt;跳转到下一次循环&lt;/strong&gt;的迭代。在 for 循环中，&lt;code&gt;continue&lt;/code&gt; 语句使程序立即跳转到更新语句。在 while 或者 do…while 循环中，程序立即跳转到布尔表达式的判断语句。当然，&lt;code&gt;continue&lt;/code&gt;也有一种带标签的形式，将跳到与标签匹配的循环首部。用法和break一样，这里就不再举例说明。&lt;/p&gt;
&lt;h3 id=&quot;公众号&quot;&gt;公众号&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://viyoungblog.oss-cn-beijing.aliyuncs.com/viyoung/2020-03-15-qrcode_for_gh_a65beceb0947_258.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 20 Mar 2020 00:22:00 +0000</pubDate>
<dc:creator>Vi的技术博客</dc:creator>
<og:description>循环 老生常谈的一个控制流程了，我们在是使用数组和集合的时候，遍历元素的时候经常会用到循环的结构，Java具有非常灵活的三种循环机制： 根据是否知道循环的次数可以为分为while循环，do...whi</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/viyoung/p/12529440.html</dc:identifier>
</item>
<item>
<title>免费开源的 HelloDjango 系列教程，结束还是开始？ - 削微寒</title>
<link>http://www.cnblogs.com/xueweihan/p/12526557.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xueweihan/p/12526557.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202003/759200-20200319190415171-440632573.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;作者：&lt;a href=&quot;https://www.zmrenwu.com&quot;&gt;HelloGitHub-追梦人物&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我们已经成功地开发了一个功能比较完备的个人博客，是时候来总结一下我们的工作了。博客系列完整的源代码地址：&lt;/p&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/HelloGitHub-Team/HelloDjango-blog-tutorial&quot; class=&quot;uri&quot;&gt;https://github.com/HelloGitHub-Team/HelloDjango-blog-tutorial&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul readability=&quot;25.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;在教程的前两篇，我们介绍了如何搭建 django 开发环境，如何创建 django 项目以及 django 应用，这是我们进行 django 项目开发的基础。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;第 3、4 篇：讲了 django ORM 的基础操作。ORM 是 django 核心中的核心，不仅 django 自带的应用底层全都依赖于 ORM，大部分使用 django 构建的应用基本也离不开 django ORM 的操作，所以能否熟练掌握 django 的 ORM API 决定了能否写出高质量、高性能的 django 应用。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;第 5、6 篇：讲解了 django 基本的视图函数，视图函数的作用是接收一个 HTTP 请求，根据这个请求的意图返回相应的 HTTP 响应。在这个请求处理的过程中，通常都会涉及到使用 ORM 进行数据库的增删改查操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;第 7 篇：介绍了 django 的杀手锏应用，开箱即用的 Admin 管理台。我们可以通过这个管理台直接对数据库中的数据进行增删改查操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;第 9、10 篇：介绍了 Markdown 的使用，对于博客、技术论坛之类的应用，使用 Markdown 来撰写内容是一个常见的需求。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;第 12、13 篇：介绍了如何自定义模板标签并使用它们。模板标签用于 django 的模板系统中，用来生成 HTML 页面。django 的模板系统自带了大量的模板标签。但如果自带的标签不满足需求，我们就可以拓展 django 模板系统的 API 来自定义模板标签。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;第 14 篇：我们利用上述学习到的知识开发了一个独立的 django 评论应用。这里面我们还初步接触了表单的使用。django 的表单是对 HTML 表单的封装，它在后台完成数据校验、清理等功能，并对非法的表单输入返回给客户端友好的错误提示。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;第 16、17、18、19：向大家介绍了运维方面的知识，包括如何在服务器上部署 django 应用，如何编写自动化脚本来全自动部署，如何给网站开启 HTTPS 以提高安全性。特别是使用 Docker 进行部署后，我们把整个 django 部署的过程缩减到只需线上执行几条命令就能完成，Docker 帮助我们极大简化了部署流程。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;第 21 篇：我们介绍了基于类的视图和通用类视图。之前说了，django 的视图本质上是一个函数，它接收一个 HTTP 请求，返回一个 HTTP 响应。类视图虽然是一个类，但这只是针对开发者而言，django 通过 Python 魔法将类转化为一个可被调用的函数。使用类的好处是，它允许被继承，因此在某些情况下可以提高代码的复用性。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;第 22 篇：演示了如何在 Python 脚本里面独立地使用 django 的 ORM。一般要使用 django 的 ORM 必须启动整个 django 项目，而如果要在独立的脚本中使用的话，就必须进行一些额外的设置。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;第 23 篇：我们介绍了如何使用 django 第三方库，django 的强大不仅在于它自身功能的完备程度，更在于其繁荣的社区。大量开发者在开源平台发布了很多优质的 django 拓展应用，涵盖了 web 开发的方方面面。这里我们只介绍了一个分页应用，更多应用大家可以在 GitHub 通过搜索关键词 django 进行探索。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;第 27、28 篇：我们介绍了搜索功能的实现。一开始使用的是比较简单的搜索方式，利用之前所学的 django 知识就能完成。不过为了更好的搜索体验，我们进一步引入了 elasticsearch 这个专业的搜索服务来提供搜索功能，同时使用了一个 django 第三方库 django-haystack 来将 elasticsearch 和 django 无缝对接。同时可以看到，有了 Docker 容器技术，引入一个外部服务变得非常简单。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;第 29、30、31 篇：我们对博客补充了完善的单元测试，测试过程中我们发现了一些隐藏的 bug 并进行了修复，由此测试的重要性可见一斑。此外，为了衡量测试的质量，我们使用 coverage.py 对代码测试覆盖率进行了统计，越高的测试覆盖率说明测试越充分，程序出现 bug 的几率也就越小。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;现在，我们已经有了一个功能比较完备的个人博客应用。而且，在测试的保障护航下，我们可以在不破坏现用功能的情况下，轻松加入新的功能。&lt;/p&gt;
&lt;p&gt;教程进行到这里，HelloDjango 博客教程就要准备告一段落了，大部分 web 开发中的需求，你都可以通过教程中讲到的知识点，结合 django 的官方文档来实现。&lt;/p&gt;
&lt;h2 id=&quot;不过真的要结束了吗我的回答是没有也不想结束&quot;&gt;不过，真的要结束了吗？我的回答是没有也不想结束！&lt;/h2&gt;
&lt;p&gt;Django 中还有很多值得介绍的地方，就拿博客来说，我们还可以做这些很酷的功能：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;支持用户登录，甚至使用 GitHub、新浪微博等第三方应用登录&lt;/li&gt;
&lt;li&gt;支持多级评论&lt;/li&gt;
&lt;li&gt;国际化&lt;/li&gt;
&lt;li&gt;使用缓存进行性能优化&lt;/li&gt;
&lt;li&gt;支持邮件订阅，有新的博客就发送邮件提醒订阅者&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;等等，这些对于其他 Web 系统来说，基本也都是必不可少的。&lt;/p&gt;
&lt;p&gt;所以，HelloDjango 博客项目会继续以这样的形式继续下去：&lt;/p&gt;
&lt;p&gt;围绕着某一个功能进行开发，功能开发完成之后附带输出一篇详细介绍功能实现原理和过程的教程。我希望 HelloDjango 博客项目不仅仅是一个教学演示项目，也不仅仅是一个高质量、功能完备的 django 第三方博客应用，而是两者都是！&lt;/p&gt;
&lt;p&gt;这些教程会及时通过 HelloGitHub 微信公众号和 &lt;a href=&quot;https://www.zmrenwu.com/&quot;&gt;追梦人物的博客&lt;/a&gt; 进行更新，敬请关注！&lt;/p&gt;
&lt;h2 id=&quot;号外&quot;&gt;号外&lt;/h2&gt;
&lt;p&gt;此外，虽然 HelloDjango 博客项目教程定期更新已经结束，但接下来我会开始以定期更新的方式向大家介绍如何 django-restframework + Vue 或者 React 这种更加现代化的前后端分离开发方式，大量公司都采用这种开发方式，如果你以找工作为目的而学习 django 的话，怎么能不学习这种开发模式呢？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HelloDjango-blogs 的教程暂时告一段落，全新的 HelloDjango-django-restframework 系列教程就要要重新扬帆起航了，大家敬请期待！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所以还是那句话，敬请关注 HelloGitHub 微信公众号以及 &lt;a href=&quot;https://www.zmrenwu.com/&quot;&gt;追梦人物的博客&lt;/a&gt;，免费学习 Django 全栈开发。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202003/759200-20200319190805283-1169828458.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 20 Mar 2020 00:21:00 +0000</pubDate>
<dc:creator>削微寒</dc:creator>
<og:description>作者： &amp;quot;HelloGitHub 追梦人物&amp;quot; 我们已经成功地开发了一个功能比较完备的个人博客，是时候来总结一下我们的工作了。博客系列完整的源代码地址： https://github</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xueweihan/p/12526557.html</dc:identifier>
</item>
<item>
<title>《痞子衡嵌入式半月刊》 第 4 期 - 痞子衡</title>
<link>http://www.cnblogs.com/henjay724/p/12529381.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/henjay724/p/12529381.html</guid>
<description>&lt;p&gt;这里分享嵌入式领域有用有趣的项目/工具以及一些热点新闻，农历年分二十四节气，希望在每个交节之日准时发布一期。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;241.75500785546&quot;&gt;

&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/cnblogs/pzh_mcu_bi_weekly.PNG&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里分享嵌入式领域有用有趣的项目/工具以及一些热点新闻，农历年分二十四节气，希望在每个交节之日准时发布一期。&lt;/p&gt;
&lt;p&gt;本期刊是开源项目（GitHub: &lt;a href=&quot;https://github.com/JayHeng/pzh-mcu-bi-weekly&quot;&gt;JayHeng/pzh-mcu-bi-weekly&lt;/a&gt;），欢迎提交 issue，投稿或推荐你知道的嵌入式那些事儿。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;上期回顾&lt;/strong&gt; ：&lt;a href=&quot;https://www.cnblogs.com/henjay724/p/12418233.html&quot;&gt;《痞子衡嵌入式半月刊： 第 3 期》&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;唠两句&quot;&gt;唠两句&lt;/h2&gt;
&lt;p&gt;今天是惊蛰与春分交节之时，“春分者，阴阳相半也。故昼夜均而寒暑平”。一个“分”字道出了昼夜、寒暑的界限。&lt;/p&gt;
&lt;p&gt;新型肺炎在国内已被完全控制住了，可是中国为全世界省下来的宝贵 2 个月，老外根本没珍惜啊，唉...&lt;/p&gt;
&lt;p&gt;痞子衡这两周一半时间在公司，另一半还是 work at home，公司预计 4 月中旬才会全面复工。本周跟同事玩了玩投篮比赛，手感不错，赚了红包，在技术群里发给大家同乐了。&lt;/p&gt;
&lt;p&gt;本期共收录 2条资讯、3个项目、2个工具、2个RT产品，希望对你有帮助！&lt;/p&gt;
&lt;h2 id=&quot;资讯类&quot;&gt;资讯类&lt;/h2&gt;
&lt;h3 id=&quot;格芯推出业界首款基于-22fdx-平台的量产-emram-助力-iot-及汽车等应用&quot;&gt;&lt;span&gt;1、 格芯推出业界首款基于 22FDX 平台的量产 eMRAM 助力 IoT 及汽车等应用&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;近日，格芯宣布其基于 22nm FD-SOI (22FDX) 平台的嵌入式、磁阻型非易失性存储器(eMRAM)已投入生产。此次公告表明 eMRAM 可在 IoT、MCU、汽车等低功耗应用中作为先进工艺节点的高性价比选择。&lt;/p&gt;
&lt;blockquote readability=&quot;1.6304347826087&quot;&gt;
&lt;p&gt;格芯官网：&lt;a href=&quot;https://www.globalfoundries.com&quot; class=&quot;uri&quot;&gt;https://www.globalfoundries.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;格芯的 eMRAM 产品旨在替代高容量嵌入式 NOR 闪存，帮助设计人员扩展现有的物联网和微控制器单元架构，以实现 28nm 以下技术节点的功率和密度优势。 格芯的 eMRAM 是一款可靠的多功能嵌入式非易失性存储器(eNVM)，已通过了 5 次严格的回流焊实测，在 -40℃ 至 125℃ 温度范围内具有 100,000 次使用寿命和 10 年数据保存期限。FDX eMRAM 解决方案支持 AEC-Q100 2 级设计，且还在开发工艺，预计明年将支持 AEC-Q100 1 级解决方案。&lt;/p&gt;
&lt;p&gt;通过此前的 IEDM 大会的演示中我们可以了解到一些 MRAM 相较于传统嵌入式 NOR 闪存(eFlash)的优点，虽然 MRAM 技术仍然面临一些挑战，但与 eFlash 相比，它的速度更快，功耗更低。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/biweekly/eMRAM-F_VS_eFLASH.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由于还未正式面世，具体的技术细节还无法一窥究竟。读者可以从格芯官网的 22FDX 平台介绍上先行了解一下此次格芯推出的eMRAM的相关信息。&lt;/p&gt;
&lt;h3 id=&quot;意法半导体推出面向智能物联网设备的微控制器-stm32l4&quot;&gt;&lt;span&gt;2、意法半导体推出面向智能物联网设备的微控制器 STM32L4+&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;意法半导体最新推出的适用于成本敏感且注重功耗的智能物联网设备的微控制器 STM32L4+，主打能源表、工业传感器、医疗传感器、健身跟踪器、智能家居设备等设备，其系列产品的硬件资源如下。&lt;/p&gt;
&lt;blockquote readability=&quot;0.87378640776699&quot;&gt;
&lt;p&gt;芯片主页：&lt;a href=&quot;https://www.st.com/en/microcontrollers-microprocessors/stm32l4-plus-series.html#overview&quot; class=&quot;uri&quot;&gt;https://www.st.com/en/microcontrollers-microprocessors/stm32l4-plus-series.html#overview&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/biweekly/STM32L4+.PNG&quot;/&gt;&lt;/p&gt;
&lt;p&gt;STM32L4+ 系列打破了超低功耗芯片中处理能力的限制，内嵌 2MB 的 Flash 和 640KB 的 SRAM，利用 ST 的 2D 硬件图形加速器Chrom-ART Accelerator™ 能够提供更高级的图形操作，从而释放 CPU 的性能；另外在超低功率下，保证了在同类产品中具有最佳的性能。&lt;/p&gt;
&lt;h2 id=&quot;项目类&quot;&gt;项目类&lt;/h2&gt;
&lt;h3 id=&quot;murphyzhaoflexiblebutton---一个基于标准-c-语言的小巧灵活的按键处理库&quot;&gt;&lt;span&gt;1、 murphyzhao/FlexibleButton - 一个基于标准 C 语言的小巧灵活的按键处理库&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;FlexibleButton 是网友 murphyzhao 维护的一个基于标准 C 语言的小巧灵活的按键处理库，支持单击、连击、短按、长按、自动消抖，可以自由设置组合按键，可用于中断和低功耗场景。&lt;/p&gt;
&lt;blockquote readability=&quot;1.271186440678&quot;&gt;
&lt;p&gt;项目主页：&lt;a href=&quot;https://github.com/murphyzhao/FlexibleButton&quot; class=&quot;uri&quot;&gt;https://github.com/murphyzhao/FlexibleButton&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;该按键库解耦了具体的按键硬件结构，理论上支持轻触按键与自锁按键，并可以无限扩展按键数量。另外，FlexibleButton 使用扫描的方式一次性读取所有所有的按键状态，然后通过事件回调机制上报按键事件。核心的按键扫描代码仅有三行，没错，就是经典的 &lt;strong&gt;三行按键扫描算法&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;FlexibleButton 中按键事件的定义并没有使用 Windows 驱动上的定义，主要是方便嵌入式设备中的应用场景，下面是支持的所有按键事件的定义：&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;typedef enum
{
    FLEX_BTN_PRESS_DOWN = 0,        // 按下事件
    FLEX_BTN_PRESS_CLICK,           // 单击事件
    FLEX_BTN_PRESS_DOUBLE_CLICK,    // 双击事件
    FLEX_BTN_PRESS_REPEAT_CLICK,    // 连击事件
    FLEX_BTN_PRESS_SHORT_START,     // 短按开始事件
    FLEX_BTN_PRESS_SHORT_UP,        // 短按抬起事件
    FLEX_BTN_PRESS_LONG_START,      // 长按开始事件
    FLEX_BTN_PRESS_LONG_UP,         // 长按抬起事件
    FLEX_BTN_PRESS_LONG_HOLD,       // 长按保持事件
    FLEX_BTN_PRESS_LONG_HOLD_UP,    // 长按保持的抬起事件
    FLEX_BTN_PRESS_MAX,
    FLEX_BTN_PRESS_NONE,
} flex_button_event_t;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;FlexibleButton 使用 C 语言标准库 API 编写，也使得该按键库可以无缝兼容任意的处理器平台，并且支持任意 OS 和 non-OS（裸机编程）。&lt;/p&gt;
&lt;h3 id=&quot;tinyusb---适用于嵌入式系统的开源跨平台-usb-协议栈&quot;&gt;&lt;span&gt;2、TinyUSB - 适用于嵌入式系统的开源跨平台 USB 协议栈&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;TinyUSB 是由网友 hathach 管理维护的一个开源跨平台 USB 协议栈，协议栈中包含了主机端及设备端的协议栈，由于不使用动态内存分配以及采用阻塞所有中断事件，在非 ISR 任务功能中处理中断事件的设计方式，所以此协议栈的内存安全性及线程安全性极高。&lt;/p&gt;
&lt;blockquote readability=&quot;1.530612244898&quot;&gt;
&lt;p&gt;项目主页：&lt;a href=&quot;https://github.com/hathach/tinyusb&quot; class=&quot;uri&quot;&gt;https://github.com/hathach/tinyusb&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;此协议栈使用信号量/互斥量来访问共享资源，因此需要使用到 OS 的一些 API。目前 TinyUSB 支持 FreeRTOS 及 Mynewt 两种 OS。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/biweekly/TinyUSB_Structure.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;目前该协议栈支持的 MCU 有：&lt;/p&gt;
&lt;pre class=&quot;text&quot;&gt;
&lt;code&gt;- MicroChip: SAMD21, SAMD51 (device only)
- Nordic: nRF52840, nRF52833
- Nuvoton: NUC120, NUC121/NUC125, NUC126, NUC505
- NXP: LPC Series: 11Uxx, 13xx, 175x_6x, 177x_8x, 18xx, 40xx, 43xx, 51Uxx, 54xxx, 55xx
       iMX RT Series: RT1011, RT1015, RT1021, RT1052, RT1062, RT1064
- Sony: CXD56
- ST: STM32 series: L0, F0, F1, F2, F3, F4, F7, H7 (device only)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果读者想要在列表以外的 MCU 上使用 TinyUSB，项目主页中有详细的移植过程以供参考。&lt;/p&gt;
&lt;h3 id=&quot;cpu-stress-detector---基于-bolt-iot-无线模组及其云服务的-cpu-负荷检测器&quot;&gt;&lt;span&gt;3、CPU Stress Detector - 基于 Bolt IoT 无线模组及其云服务的 CPU 负荷检测器&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;这是来自 Hackaday 上的一个作品，基于 &lt;a href=&quot;https://www.boltiot.com/&quot;&gt;Bolt IoT&lt;/a&gt; WiFi 模组及其配套云服务和 App 的计算机 CPU 负荷检测器。&lt;/p&gt;
&lt;blockquote readability=&quot;0.90361445783133&quot;&gt;
&lt;p&gt;项目主页：&lt;a href=&quot;https://www.hackster.io/lahariimmanni2397/cpu-stress-detector-7b8e8b&quot; class=&quot;uri&quot;&gt;https://www.hackster.io/lahariimmanni2397/cpu-stress-detector-7b8e8b&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;有时计算机 CPU 会超载发热，CPU 负荷检测器可以检测到这个情况，并通过不同颜色 LED 进行指示。如果 CPU 过载，则红色 LED 点亮并发出警报; 如果 CPU 负荷较低，则绿色 LED 点亮。通过这些指示，我们可以了解 CPU 的压力等级。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/biweekly/CPU-Stress-Detector_circuit.PNG&quot;/&gt;&lt;/p&gt;
&lt;p&gt;PC 端代码采用 Python 编写，直接调用封装好的 &lt;a href=&quot;https://pypi.org/project/boltiot/&quot;&gt;boltiot&lt;/a&gt; 库来访问 Bolt IoT 云。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import psutil
from boltiot import Bolt

api_key   = &quot;YOUR_API_KEY&quot;
device_id = &quot;YOUR_DEVICE_ID&quot;

cpu_red_threshold = 0.4
client= Bolt(api_key, device_id)

def control_green_led(pin, value):
    response = client.digitalWrite(pin, value)

def control_red_led(pin, value):
    response = client.digitalWrite(pin, value)

while True:
    cpu_usage = psutil.cpu_percent(interval = 5) #检测间隔(s)
    if cpu_usage &amp;amp;gt; cpu_red_threshold:
        control_green_led('0','LOW')
        control_red_led('1', 'HIGH')
        control_red_led('2', 'LOW')
    else:
        control_green_led('0', 'HIGH')
        control_red_led('1', 'LOW')&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;工具类&quot;&gt;工具类&lt;/h2&gt;
&lt;h3 id=&quot;proteus-vsm---可用于-mcu-在线仿真调试的-eda-软件&quot;&gt;&lt;span&gt;1、Proteus VSM - 可用于 MCU 在线仿真调试的 EDA 软件&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;Proteus 是英国 Lab Center Electronics 公司推出的 EDA 软件，VSM 是 Proteus 三大组件之一（另外两个是 PCB Layout、Visual Designer），VSM 主要用于电路和 MCU 仿真调试。&lt;/p&gt;
&lt;blockquote readability=&quot;1.4423076923077&quot;&gt;
&lt;p&gt;工具主页：&lt;a href=&quot;https://www.labcenter.com/simulation/&quot; class=&quot;uri&quot;&gt;https://www.labcenter.com/simulation/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;笔者读大学时初学单片机便对 Proteus VSM 一见钟情，在手头没有合适的硬件开发板情况下，快速在 Proteus VSM 上搭一个电路，选好 MCU 模型，然后将编译生成的工程 .hex 文件下载进去就可以直接看运行效果了。如果运行结果不对，还可以单步调试程序来解 Bug。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/biweekly/Proteus_VSM_working.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Proteus VSM 目前支持的 MCU 系列非常多，主流 MCU 厂商的产品型号基本都在内，此外 Proteus VSM 也支持所有主流的编译器（IAR/Keil/GCC等）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/biweekly/Proteus_supported_VSM_family_v2.PNG&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;clang-format---最流行的-cc-代码格式化插件&quot;&gt;&lt;span&gt;2、clang-format - 最流行的 C/C++ 代码格式化插件&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;clang-format，它是基于 Clang 的一个命令行工具，能够自动化格式化 C/C++/Obj-C 代码，支持多种代码风格：Google, Chromium, LLVM, Mozilla, WebKit，也支持自定义风格（通过编写 .clang-format 文件）。&lt;/p&gt;
&lt;blockquote readability=&quot;1.2931034482759&quot;&gt;
&lt;p&gt;工具主页：&lt;a href=&quot;http://clang.llvm.org/docs/ClangFormat.html&quot; class=&quot;uri&quot;&gt;http://clang.llvm.org/docs/ClangFormat.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;clang-format 的使用特别简单，安装好之后（在 /clang/tools/clang-format/ 路径下），使用如下命令即可将指定源文件格式化：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;# 使用LLVM风格格式化
clang-format -i main.c -style=llvm

# 使用.clang-format自定义风格格式化
clang-format -i main.c -style=.clang-format&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此外 clang-format 还可以以插件形式集成在 Vim、Emacs、VS Code 等工具中使用。如果你是 Git 用户，clang-format 还提供了脚本用于格式化 patch。&lt;/p&gt;
&lt;h2 id=&quot;i.mxrt出品&quot;&gt;i.MXRT出品&lt;/h2&gt;
&lt;h3 id=&quot;蛙声科技---便携式视频会议拾音器nuroum&quot;&gt;&lt;span&gt;1、蛙声科技 - 便携式视频会议拾音器(Nuroum)&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;Nuroum 诞生于这样一个理念：高品质、易用的会议产品不应该太贵。Nuroum 采用了专利的麦克风阵列(6个)算法，能够智能地拾取室内覆盖范围内经过噪声过滤、回声消除的声音，因此每个人的声音都非常清晰。Nuroum 配备了 3600mAh 的大容量电池，可以连续 30 小时为会议通话供电。&lt;/p&gt;
&lt;blockquote readability=&quot;3.9325842696629&quot;&gt;
&lt;p&gt;RT芯片：i.MXRT1021&lt;br/&gt;产品主页： &lt;a href=&quot;https://nuroum.com/&quot; class=&quot;uri&quot;&gt;https://nuroum.com/&lt;/a&gt;&lt;br/&gt;官网定价： 99.98 美元起&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/biweekly/Nuroum.PNG&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;蛙声科技---视频会议模块化产品套件hamedal&quot;&gt;&lt;span&gt;2、蛙声科技 - 视频会议模块化产品套件(Hamedal)&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;Hamedal 耳目达，市场定位是，“告别喂喂喂，不用喊的视频会议”，主要针对的场景是企业会议室。套件包括：可以最多支持 5 个集联（Daisy-Chain）的麦克风阵列 SpeakerMic，支持说话人追踪的 AI 摄像头，可以控制会议的触屏。这套产品配备了标准 PC 的 USB 接口，不需要专业人士即可安装。&lt;/p&gt;
&lt;blockquote readability=&quot;3.8372093023256&quot;&gt;
&lt;p&gt;RT芯片：i.MXRT1061&lt;br/&gt;产品主页： &lt;a href=&quot;https://hamedal.com/&quot; class=&quot;uri&quot;&gt;https://hamedal.com/&lt;/a&gt;&lt;br/&gt;官网定价： 2999 元起&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/biweekly/Hamedal.PNG&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;欢迎订阅&quot;&gt;欢迎订阅&lt;/h3&gt;
&lt;p&gt;文章会同时发布到我的 &lt;a href=&quot;https://www.cnblogs.com/henjay724/&quot;&gt;博客园主页&lt;/a&gt;、&lt;a href=&quot;https://blog.csdn.net/Henjay724&quot;&gt;CSDN主页&lt;/a&gt;、&lt;a href=&quot;http://weixin.sogou.com/weixin?type=1&amp;amp;query=%E7%97%9E%E5%AD%90%E8%A1%A1%E5%B5%8C%E5%85%A5%E5%BC%8F&quot;&gt;微信公众号&lt;/a&gt; 平台上。&lt;/p&gt;
&lt;p&gt;微信搜索&quot;&lt;strong&gt;痞子衡嵌入式&lt;/strong&gt;&quot;或者扫描下面二维码，就可以在手机上第一时间看了哦。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/github/pzhMcu_qrcode_258x258.jpg&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Thu, 19 Mar 2020 23:52:00 +0000</pubDate>
<dc:creator>痞子衡</dc:creator>
<og:description>这里分享嵌入式领域有用有趣的项目/工具以及一些热点新闻，农历年分二十四节气，希望在每个交节之日准时发布一期。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/henjay724/p/12529381.html</dc:identifier>
</item>
<item>
<title>Cinemachine中噪音的应用 - blueberryzzz</title>
<link>http://www.cnblogs.com/blueberryzzz/p/12528998.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/blueberryzzz/p/12528998.html</guid>
<description>&lt;h2 id=&quot;nosie阶段的component&quot;&gt;Nosie阶段的Component&lt;/h2&gt;
&lt;p&gt;  Component在流水线中主要通过MuteCameraState来处理对State的计算。&lt;br/&gt;  对于Noise类型的Component来说，就是在MuteCameraState中，通过将噪音数据应用到State中的PositionCorrection和OrientationCorrection两个字段上，来提供相机的抖动功能（比如Cinemachine提供的BasicMultiChannelPerlin）。&lt;br/&gt;  没有开始和停止的概念。有Nosie文件的时候就会产生噪音，没有就停止。&lt;/p&gt;
&lt;h2 id=&quot;监听impulsemanager的extension&quot;&gt;监听ImpulseManager的Extension&lt;/h2&gt;
&lt;p&gt;  通过对Impulse Sourse发出的震动事件（这个事件十分完善，有位置、半径、持续时间等参数，模拟一个真实的震动）监听的处理来产生震动。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1362861/202003/1362861-20200320012757397-716609519.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;噪音类&quot;&gt;噪音类&lt;/h2&gt;
&lt;h3 id=&quot;isignalsource6d&quot;&gt;ISignalSource6D&lt;/h3&gt;
&lt;p&gt;  ISignalSource6D就是Cinemachine提供的用来描述噪音数据的接口，主要提供三个能力：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;保存噪音的数据。&lt;/li&gt;
&lt;li&gt;获取噪音的总时长，用来判断噪音是否结束。&lt;/li&gt;
&lt;li&gt;获取某一时间点的噪音数据。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;noisesettings&quot;&gt;NoiseSettings&lt;/h3&gt;
&lt;p&gt;  可作为ImpulseDefinition和BasicMultiChannelPerlin的噪音数据使用。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1362861/202003/1362861-20200320012814676-1716894904.png&quot;/&gt;&lt;br/&gt;  最上面两行是NoiseSettings在Inspector面板中预览的参数，分别是预览的时间长度、图像高度、是否动画。&lt;br/&gt;  NoiseSetting中对旋转、位置的每一个轴的震动都分别描述。&lt;br/&gt;  每个震动都可以由多个波叠加而成。&lt;br/&gt;  每个波由频率和振幅描述，后面那个Toggle勾选上代表这个波是非随机波(实际上就是使用Mathf.Cos函数计算)，不勾选就是随机的(Mathf.PerlinNoise函数)。&lt;/p&gt;
&lt;h3 id=&quot;cinemachinefixedsignal&quot;&gt;CinemachineFixedSignal&lt;/h3&gt;
&lt;p&gt;  只能用于ImpulseDefinition的噪声文件。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1362861/202003/1362861-20200320012832005-759733421.png&quot;/&gt;&lt;br/&gt;  这个是可以用在冲击(Impulse Source)中使用的噪音。只能对位置产生影响。&lt;br/&gt;  三个参数分别代表x、y、z轴的噪音曲线。&lt;/p&gt;
&lt;h2 id=&quot;tips&quot;&gt;Tips&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;BasicMultiChannelPerlin所产生噪声在开始生效的时候会通过ReSeed对x、y、z轴初始数据做随机偏移，导致每次开始震动的时机都不一样。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;ImpulseListener产生的冲击是可以选择是否做随机偏移的。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;  Cinemachine自带的两种产生噪声的方式比较单一，可能会不满足复杂的噪音需求。&lt;br/&gt;  比如项目组之前已经有一套成熟的通过表格配置来描述一个噪音的方案。我们希望可以直接把这个表格的配置直接用在Cinemachine中怎么办。&lt;br/&gt;  &lt;strong&gt;这里提供两个思路：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;写一个可以使用表格数据的Component。&lt;/li&gt;
&lt;li&gt;通过ImpulseManager和Extension来产生和处理这种表格所描述的噪音。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;  这里的例子是实现一个简单的相机震屏效果，相机的震动是在相机空间内的，和相机当前的世界坐标和旋转都无关。&lt;br/&gt;  &lt;strong&gt;首先我们需要一个可以描述表格数据的噪音类&lt;/strong&gt;&lt;br/&gt;  假如我们的噪音在表格中是这么描述的：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;delay&lt;/td&gt;
&lt;td&gt;strength&lt;/td&gt;
&lt;td&gt;cycleTime&lt;/td&gt;
&lt;td&gt;duration&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;  我们这个噪音类只是用来对表格中的噪音数据做一次转换，来供ImpulseManager或Component来使用，并不是用来存储噪音数据的，所以我们直接继承ISignalSource6D就可以，不用继承SignalSourceAsset。&lt;br/&gt;  因为功能很简单，所以就直接贴一下代码：&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;public class GameShakeSource : ISignalSource6D
{
    public float Delay;
    public Vector3 Strength;
    public float CycleTime;
    public float Duration;
    
    public GameShakeSource(float delay, Vector3 strength, float cycleTime, float duration)
    {
        Delay = delay;
        Strength = strength;
        CycleTime = cycleTime;
        Duration = duration;
    }

    //噪音持续的总时间，用于判断这个噪音是否结束
    public float SignalDuration
    {
        get
        {
            return Delay + Duration;
        }
    }

    //根据当前噪音经过的时间，获取噪音产生的位置和旋转偏移量。
    //因为表格中没有旋转相关的数据，所以直接返回identity值。
    public void GetSignal(float timeSinceSignalStart, out Vector3 pos, out Quaternion rot)
    {
        if(timeSinceSignalStart &amp;lt;= Delay)
        {
            pos = Vector3.zero;
        }
        else
        {
            float times = timeSinceSignalStart / (CycleTime / 4);
            int cycle25Count = Mathf.FloorToInt(times);
            float inCycle25Time = times - cycle25Count;
            if(cycle25Count % 4 == 0)
            {
                pos = Vector3.Lerp(Vector3.zero, Strength, inCycle25Time);
            }
            else if(cycle25Count % 4 == 1)
            {
                pos = Vector3.Lerp(Strength, Vector3.zero, inCycle25Time);
            }
            else if (cycle25Count % 4 == 2)
            {
                pos = Vector3.Lerp(Vector3.zero, -Strength, inCycle25Time);
            }
            else
            {
                pos = Vector3.Lerp(-Strength, Vector3.zero, inCycle25Time);
            }
        }
        rot = Quaternion.identity;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  &lt;strong&gt;使用这个噪音文件的Component：&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;public class CinemachineShake : CinemachineComponentBase
{
    public ISignalSource6D ShakeSetting;

    public override bool IsValid { get { return enabled; } }

    public override CinemachineCore.Stage Stage { get { return CinemachineCore.Stage.Noise; } }

    private float mNoiseTime;
    private Matrix4x4 shakeMatrix = new Matrix4x4();
    
    //VirtualCamera用来在流水线中计算State的接口
    public override void MutateCameraState(ref CameraState curState, float deltaTime)
    {
        if (!IsValid || deltaTime &amp;lt; 0)
            return;
        if (ShakeSetting == null || mNoiseTime &amp;gt; ShakeSetting.SignalDuration)
            return;
        mNoiseTime += deltaTime;
        ShakeSetting.GetSignal(mNoiseTime, out Vector3 pos, out Quaternion rot);
        //因为这里是希望实现的是震屏功能，所以需要将ShakeSetting计算出的相机空间中的偏移量，转化为世界坐标中的偏移量。
        //直接用相机的旋转生成的矩阵乘一下就可以了
        shakeMatrix.SetTRS(Vector3.zero, curState.FinalOrientation, Vector3.one);
        //把位置偏移量应用到State上
        curState.PositionCorrection += shakeMatrix.MultiplyPoint(-pos);
        rot = Quaternion.SlerpUnclamped(Quaternion.identity, rot, -1);
        //把旋转偏移量应用到State上
        curState.OrientationCorrection = curState.OrientationCorrection * rot;
    }

    public void Shake(ISignalSource6D shakeSetting)
    {
        ShakeSetting = shakeSetting;
        mNoiseTime = 0;
    }

    public void Shake(float delay, Vector3 strength, float cycleTime, float duration)
    {
        Shake(new GameShakeSource(delay, strength, cycleTime, duration));
    }

    public void Shake()
    {
        mNoiseTime = 0;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  使用的时候调这个Component的Shake接口即可。&lt;/p&gt;

&lt;p&gt;  噪音类就直接用上面的那个。&lt;br/&gt;  &lt;strong&gt;先提供一个新的Chanel用于这个震屏，用来和普通冲击产生的震动做区分。&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1362861/202003/1362861-20200320012900099-1943490235.png&quot;/&gt;&lt;br/&gt;  &lt;strong&gt;写一个ShakeManager代替ImpulseSource产生Impulse事件，直接生成事件加到ImpulseManager中。&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;public class ShakeManager
{
    public static void Test()
    {
        AddShake(0, new Vector3(0.3f, 0.3f, 0), 0.2f, 0.1f);
    }

    public static void AddShake(float delay, Vector3 strength, float cycleTime, float duration)
    {
        CinemachineImpulseManager.ImpulseEvent e
                = CinemachineImpulseManager.Instance.NewImpulseEvent();
        e.m_Envelope = new CinemachineImpulseManager.EnvelopeDefinition();
        //开始和衰减阶段的时间都填0，只留下中间一段时间
        e.m_Envelope.m_AttackTime = 0;
        e.m_Envelope.m_DecayTime = 0;
        e.m_Envelope.m_SustainTime = delay + duration;

        e.m_SignalSource = new GameShakeSource(delay, strength, cycleTime, duration);
        //产生冲击的位置和影响半径，这里填Vector3.zero和float.MaxValue，
        //获取的震动数据的时候从Vector3.zero这个位置获取就可以获取全量没有衰减的数据。
        e.m_Position = Vector3.zero;
        e.m_Radius = float.MaxValue;
        //2就是刚定义的gameShakeChannel
        e.m_Channel = 2;
        //选Fixed，不希望震动的方向对相机产生额外影响
        e.m_DirectionMode = CinemachineImpulseManager.ImpulseEvent.DirectionMode.Fixed;
        //衰减方式随便填，这里用不到
        e.m_DissipationMode = CinemachineImpulseManager.ImpulseEvent.DissipationMode.LinearDecay;
        //这个也用不到
        e.m_DissipationDistance = 0;
        CinemachineImpulseManager.Instance.AddImpulseEvent(e);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  &lt;strong&gt;写一个处理这类震动数据的Extension。&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;public class CinemachineShakeListener : CinemachineExtension
{
    [Tooltip(&quot;Impulse events on channels not included in the mask will be ignored.&quot;)]
    [CinemachineImpulseChannelProperty]
    public int m_ChannelMask = 1;

    [Tooltip(&quot;Gain to apply to the Impulse signal.  1 is normal strength.  Setting this to 0 completely mutes the signal.&quot;)]
    public float m_Gain = 1;

    [Tooltip(&quot;Enable this to perform distance calculation in 2D (ignore Z)&quot;)]
    public bool m_Use2DDistance = false;

    private Matrix4x4 shakeMatrix = new Matrix4x4();

    //VirtualCamera用来在流水线中计算State的接口
    protected override void PostPipelineStageCallback(
        CinemachineVirtualCameraBase vcam,
        CinemachineCore.Stage stage, ref CameraState state, float deltaTime)
    {
        //由于这个接口在么个阶段后都会调用，所以要加这个判断。
        //保证只在Aim结束后指调用一次
        if (stage == CinemachineCore.Stage.Aim)
        {
            Vector3 impulsePos = Vector3.zero;
            Quaternion impulseRot = Quaternion.identity;
            //直接调ImpulseManager的接口获取gameShakeChannel产生的震动数据,
            //位置填zero,保证噪音不会衰减
            if (CinemachineImpulseManager.Instance.GetImpulseAt(
                Vector3.zero, m_Use2DDistance, m_ChannelMask, out impulsePos, out impulseRot))
            {        
                //转换到世界坐标                
                shakeMatrix.SetTRS(Vector3.zero, state.FinalOrientation, Vector3.one);
                //增加强度参数的影响后，应用到当前State上
                state.PositionCorrection += shakeMatrix.MultiplyPoint(impulsePos * -m_Gain);
                impulseRot = Quaternion.SlerpUnclamped(Quaternion.identity, impulseRot, -m_Gain);
                state.OrientationCorrection = state.OrientationCorrection * impulseRot;
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;其他方案&quot;&gt;其他方案&lt;/h2&gt;
&lt;p&gt;  也可以选择不通过将自己组装的ImpulseEvent传给ImpulseManager来产生震动。&lt;br/&gt;  直接单独写一个Manager来专门管理这一类震动。通过Extension直接从这个Manager中获取震动数据。就可以避免ImpulseManager中的一些比如范围判断、强度衰减等无效计算。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1362861/202003/1362861-20200320012929041-307892631.gif&quot;/&gt;&lt;/p&gt;

&lt;p&gt;  Cinemachine中的噪音的核心思路其实就是在相机的基本位置旋转（也就是流水线中的Aim阶段之后）确定后，为相机添加一个额外的偏移量（OrientationCorrection，PositionCorrection参数）。&lt;br/&gt;  不管是通过Compoent、Extension或者其他什么奇妙的操作来添加这个偏移量都可以。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;项目链接：&lt;/strong&gt;&lt;a href=&quot;https://github.com/blueberryzzz/Cinemachine-Shake&quot; class=&quot;uri&quot;&gt;https://github.com/blueberryzzz/Cinemachine-Shake&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 19 Mar 2020 17:30:00 +0000</pubDate>
<dc:creator>blueberryzzz</dc:creator>
<og:description>两种默认产生噪音的方式 Nosie阶段的Component Component在流水线中主要通过MuteCameraState来处理对State的计算。 对于Noise类型的Component来说，就</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/blueberryzzz/p/12528998.html</dc:identifier>
</item>
<item>
<title>SpringCloud之Hystrix服务降级入门全攻略 - 小鱼吃猫</title>
<link>http://www.cnblogs.com/Lyn4ever/p/12528913.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Lyn4ever/p/12528913.html</guid>
<description>&lt;p&gt;SpringCloud是通过HTTP Rest的方式在“微服务”之间进行调用的，所以每一个“微服务”都是一个web项目。既然它是一个web项目，它就就有可能会发生错误，这个错误有可能是服务器内存不足、客户端传参错误、网络问题等，也有可能是人为的（这个就是**服务熔断**）。也就是说，会因为一些原因从而不能给调用者返回正确的信息。 ​ 对于我们目前的单个SpringBoot项目来说，我们使用Ajax等一些方式调用接口时，如果服务器发生错误，我们在前端就会对这个错误进行处理。有可能是重试调用接口，或者给用户一个友好的提示，比如“服务繁忙，稍后再试”啥的。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;150.0089292801&quot;&gt;
&lt;h2 id=&quot;1&quot;&gt;理论知识&lt;/h2&gt;
&lt;ul readability=&quot;24.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;h3 id=&quot;1.2&quot;&gt;Hystrix是什么？&lt;/h3&gt;
&lt;p&gt;Hystrix是由Netflix开源的一个服务隔离组件，通过服务隔离来避免由于依赖延迟、异常，引起资源耗尽导致系统不可用的解决方案。这说的有点儿太官方了，它的功能主要有以下三个：&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;15&quot;&gt;
&lt;h4 id=&quot;1.2.1&quot;&gt;服务降级&lt;/h4&gt;
&lt;p&gt;​ SpringCloud是通过HTTP Rest的方式在“微服务”之间进行调用的，所以每一个“微服务”都是一个web项目。既然它是一个web项目，它就就有可能会发生错误，这个错误有可能是服务器内存不足、客户端传参错误、网络问题等，也有可能是人为的（这个就是&lt;strong&gt;服务熔断&lt;/strong&gt;）。也就是说，会因为一些原因从而不能给调用者返回正确的信息。&lt;/p&gt;
&lt;p&gt;​ 对于我们目前的单个SpringBoot项目来说，我们使用Ajax等一些方式调用接口时，如果服务器发生错误，我们在前端就会对这个错误进行处理。有可能是重试调用接口，或者给用户一个友好的提示，比如“服务繁忙，稍后再试”啥的。&lt;/p&gt;
&lt;p&gt;​ 但是在分布式系统中，同样也会发生一些“错误”，而且在多个服务之间调用时，如果不能对这些“错误”进行友好的处理，就会导致我们整个项目瘫痪，这是万万不能发生的。所以&lt;strong&gt;Hystrix&lt;/strong&gt;利用&lt;strong&gt;服务降级&lt;/strong&gt;来很好的解决了这个问题。这个其实就类似于我们的&lt;strong&gt;&lt;em&gt;try-catch&lt;/em&gt;&lt;/strong&gt;这样的机制，发生错误了，我就执行catch中的代码。&lt;/p&gt;
&lt;p&gt;​ 通过服务降级，能保证在某个或某些服务出问题的时间，不会导致整个项目出现问题，避免级联故障，从而来提高分布式系统的弹性。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;30&quot;&gt;
&lt;h4 id=&quot;1.2.2&quot;&gt;服务熔断&lt;/h4&gt;
&lt;p&gt;​ 建设先看下边的服务降级代码，将整个服务降级的代码部分全部看完，再来看下边这段理论，你一定会茅塞顿开的。&lt;/p&gt;
&lt;p&gt;​ Hystrix意为“断路器”，就和我们生活中的保险丝，开关一个道理。&lt;/p&gt;
&lt;p&gt;​ 当我们给整个服务配置了服务降级后，如果服务提供者发生了错误后，就会调用降级后的方法来保证程序的运行。但是呢？有一个问题，调用者并不知道它调用的这个服务出错了，就会在业务发生的时候一直调用，然后服务会一直报错，然后去调用降级方法。好比下图中：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/lyn4ever/picgo-img/raw/master/img/20200320003601.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;​ 它们的对话如下：&lt;/p&gt;
&lt;p&gt;​ &lt;strong&gt;Client:&lt;/strong&gt;我要调用你的方法A&lt;/p&gt;
&lt;p&gt;​ &lt;strong&gt;Server:&lt;/strong&gt;不行，我报错了。你调用降级方法吧，你的我的都行！&lt;/p&gt;
&lt;p&gt;​ &lt;strong&gt;Client&lt;/strong&gt;:哎呀，服务器报错了，那我就调用一下降级方法吧。&lt;/p&gt;
&lt;p&gt;​ 过了一会儿。。。。。。&lt;/p&gt;
&lt;p&gt;​ &lt;strong&gt;Client:&lt;/strong&gt;我要调用你的方法A&lt;/p&gt;
&lt;p&gt;​ &lt;strong&gt;Server:&lt;/strong&gt;刚才不是说了吗？我报错了。你调用降级方法吧，你的我的都行！&lt;/p&gt;
&lt;p&gt;​ &lt;strong&gt;Client&lt;/strong&gt;:哎呀，服务器报错了，那我就调用一下降级方法吧。&lt;/p&gt;
&lt;p&gt;​ 又过了一会儿。。。。。。&lt;/p&gt;
&lt;p&gt;​ &lt;strong&gt;Client:&lt;/strong&gt;我要调用你的方法A&lt;/p&gt;
&lt;p&gt;​ &lt;strong&gt;Server:&lt;/strong&gt;没完了是吧？我说过我报错了，你去调用这个降级方法啊。非要让我的代码又运行一次？&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以上的对话说明了一个问题，当服务端发生了错误后，客户端会调用降级方法。但是，当有一个新的访问时，客户端会一直调用服务端，让服务端运行一些明知会报错的代码。这能不能避免啊，我知道我错了，你访问我的时候，就直接去访问降级方法，不要再让我执行错的代码。&lt;/p&gt;
&lt;p&gt;​ 这就是服务熔断，就好比我们家中的保险丝。当检测到家中的用电负荷过大时，就断开一些用电器，来保证其他的可用。在分布式系统中，就是调用一个系统时，在一定时间内，这个服务发生的错误次数达到一定的值时， 我们就打开这个断路器，不让调用过去，而是让他直接去调用降级方法。再过一段时间后，当一次调用时，发现这个服务通了，就将这个断路器改为“半开”状态，让调用一个一个的慢慢过去，如果一直没有发生错误，就将这个断路器关闭，让所有的服务全部通过。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h4 id=&quot;1.2.3&quot;&gt;服务限流&lt;/h4&gt;
​ 服务限流就容易理解多了，顾名思义，这是对访问的流量进行限制，就比如上边的场景，我们还可能通过服务限流的方法来解决高并发以及秒杀等问题。主流的限流算法主要有：&lt;strong&gt;漏桶算法&lt;/strong&gt;和&lt;strong&gt;令牌算法&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;2&quot;&gt;开始码代码吧&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;​ 不贴代码，说这么多有什么用？这不是耍流氓吗？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li readability=&quot;-1.9019073569482&quot;&gt;
&lt;h4 id=&quot;先创建一个我们需要的几个项目&quot;&gt;先创建一个我们需要的几个项目：&lt;/h4&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;4.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;Eureka注册中心&lt;/td&gt;
&lt;td&gt;eureka-alone-7000&lt;/td&gt;
&lt;td&gt;测试期间,使用一个注册中心而不是集群&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;客户端（消费者，服务调用者）&lt;/td&gt;
&lt;td&gt;hystrix-consumer-80&lt;/td&gt;
&lt;td&gt;使用Feign或OpenFeign进行服务调用&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;服务端（提供者，服务提供者）&lt;/td&gt;
&lt;td&gt;hystrix-provider-8001&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;blockquote readability=&quot;3.5245901639344&quot;&gt;
&lt;p&gt;​ 这三个项目的创建代码略（&lt;a href=&quot;https://github.com/Lyn4ever29/spingcloudlearn&quot;&gt;项目代码地址&lt;/a&gt;）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;在客户端和服务端都加入Hystrix的依赖（当然是在哪端进行服务降级就在哪端使用）&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-cloud-starter-hystrix&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h3 id=&quot;1.2.1&quot;&gt;服务降级&lt;/h3&gt;
服务降级有两种解决思路：可以分别从服务调用者和服务提供者进行服务降级，也就是进行错误的“兜底”&lt;/li&gt;
&lt;/ul&gt;&lt;h6 id=&quot;从服务提供者方进行服务降级&quot;&gt;1. 从服务提供者方进行服务降级&lt;/h6&gt;
&lt;p&gt;我们先在提供者方的下列方法模拟一个“响应超时错误”。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;  /**
     * 这个方法会造成服务调用超时的错误
     * 其实本身体不是错误，而是服务响应时间超过了我们要求的时间，就认为它错了
     * @param id
     * @return
     */
    public String timeOutError(Integer id){
        return &quot;服务调用超时&quot;;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们就给它定义一个错误回调方法，加上如下注解：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
* 这个方法会造成服务调用超时的错误
* 其实本身体不是错误，而是服务响应时间超过了我们要求的时间，就认为它错了
* @param id
* @return
*/
@HystrixCommand(fallbackMethod = &quot;TimeOutErrorHandler&quot;,commandProperties = {
    @HystrixProperty(name=&quot;execution.isolation.thread.timeoutInMilliseconds&quot;,value = &quot;3000&quot;)
})
public String timeOutError(Integer id){
    try {
        //我们让这个方法休眠5秒，所以一定会发生错误，也就会调用下边的fallbakcMethod方法
        TimeUnit.SECONDS.sleep(5);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    return &quot;服务正常调用&quot;+id;
}

/**
*   这个就是当上边方法的“兜底”方法
*/
public String TimeOutErrorHandler(Integer id) {
    return &quot;对不起，系统处理超时&quot;+id;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上边这个注解要注意三点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;fallCallbackMethod中的这个参数就是“兜底”方法&lt;/li&gt;
&lt;li&gt;fallCallbackMethod中的这个方法的声明要和本方法一致&lt;/li&gt;
&lt;li&gt;commandProperties属性中可以写多个@HystrixProperty注解，其中的name和value就是配置对应的属性，上例中的这个就是配置响应超时&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;最后在主启动类上加上这个注解&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@SpringBootApplication
@EnableEurekaClient //本服务启动后会自动注册进eureka服务中
@EnableCircuitBreaker
public class ProviderAppication_8001 {
    public static void main(String[] args) {
        SpringApplication.run(ProviderAppication_8001.class, args);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个我们是在服务提供者方面进行的错误处理，所以对服务调用者不做任何处理，启动三个项目（consumer,provder,eureka）。然后访问&lt;code&gt;http://localhost/consumer/hello/999&lt;/code&gt;，理论上是要返回&lt;em&gt;服务调用正常999&lt;/em&gt;，但是呢，由于我们人为造成了超时错误，所以就一定会返回fallback中的&lt;em&gt;对不起，系统处理超时999&lt;/em&gt;，而且这个返回是会在3秒后。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/lyn4ever/picgo-img/raw/master/img/20200319222751.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6.8254847645429&quot;&gt;
&lt;p&gt;​ 如果你觉得上边这个超时的错误演示很麻烦，可以直接在方法中写一个运行时错误，比如:&lt;code&gt;int i = 10/0;&lt;/code&gt;也会进行fallbackMethod的调用。之所以要用这个超时配置，就是为了让你知道Hystrix可以对什么样的错误进行fallback，它的更多配置参考&lt;a href=&quot;https://github.com/Netflix/Hystrix/wiki/Configuration&quot; class=&quot;uri&quot;&gt;https://github.com/Netflix/Hystrix/wiki/Configuration&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h6 id=&quot;从服务提供者方进行服务降级-1&quot;&gt;2.从服务提供者方进行服务降级&lt;/h6&gt;
&lt;p&gt;和在服务提供方进行服务降级相比，在服务调用方（客户端、消费者）进行服务降级是更常用的方法。这两者相比，前者是要让服务提供者对自己可发生的错误进行“预处理”，这样，一定要保证调用者访问到我才会调用这个“兜底”方法。但是，大家想一下，如果我这个服务宕机了呢？客户端根本就调用不到我，它怎么可能接收到我的“兜底”方法呢？所以，在客户端进行服务降级是更常用的方法。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;一个小疑问，如果我在客户端和服务端都进行了服务降级，是都会调用？还是先调用哪个？自己想喽，稍微动动你聪明的小脑袋。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;为了不和上一个项目的代码冲突，我将上边这个@Service给注掉（也就是让Spring来管理它），从而用另外一个接口的实现，下边是我们新的serive类&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Service
public class OrignService implements IExampleService {
    /**
     * 不用这个做演示，就空实现
     */
    @Override
    public String timeOutError(Integer id) {
        try {
            TimeUnit.SECONDS.sleep(3);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        return &quot;服务正常调用&quot;+id;
    }
    /**
     * 不发生错误的正确方法
     */
    @Override
    public String correct(Integer id) {
        return &quot;访问正常，服务端没有进行任何错误&quot;+id;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;在主启动类上添加如下注解：&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@EnableHystrix //注意这个和服务端的注解是不一样的&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;在application.yml中开户feign对Hystrix的支持&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;feign:
    hystrix:
        enabled:true&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;将之前在provider项目中的@HystrixCommond放在feign的接口中&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/lyn4ever/picgo-img/raw/master/img/20200319231554.png&quot;/&gt;&lt;/p&gt;
&lt;h6 id=&quot;改进下解决方案&quot;&gt;3.改进下解决方案&lt;/h6&gt;
&lt;ul&gt;&lt;li&gt;以上的两种方案看似可行， 但是，实际呢？心想，这是一个合格程序员应该做的事吗？每个接口我们都要写一个fallback方法？然后和我们的业务代码要写在一起？就好的“低耦合，高内聚”呢？&lt;/li&gt;
&lt;li&gt;第一种解决方案，就是使用@DefaultProperties在整个Controller类上，顾名思义，就是给它一个默认的“兜底”方法，就不用每一个需要降级的方法进行设置fallbackMethod了，我们只需要加上@HystrixCommand好了。这个方法太过简单，不做代码演示，在文末的代码中专门写了注释&lt;/li&gt;
&lt;li&gt;第二种解决方法：我们在客户端不是通过Feign调用的吗？是有一个Feign的本地接口类，我们直接对这个类进行设置就好了。直接上代码。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Component
//@FeignClient(value = &quot;hystrix-provider&quot;) //这是之前的调用
@FeignClient(value = &quot;hystrix-provider&quot;,fallback = ProviderServiceImpl.class) //这回使用了Hystrix的服务降级
public interface IProviderService {
    @GetMapping(&quot;provider/hello/{id}&quot;)
    public String hello(@PathVariable(&quot;id&quot;) Integer id);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Component
public class ProviderServiceImpl implements IProviderService {
    @Override
    public String hello(Integer id) {
        return &quot;调用远程服务错误了&quot;;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;以上两种方法的对比：
&lt;ul&gt;&lt;li&gt;第一种和我们的业务类进行了耦合，而且如果要对每个方法进行fallback，就要多写一个方法，代码太过臃肿。但是，它提供了一个DefaultProperties注解，可以提供默认的方法，这个后者是没有的。这种方法适合直接使用Ribbon结合RestTemplate进行调用的方法&lt;/li&gt;
&lt;li&gt;第二种提供了一个Feign接口的实现类来处理服务降级问题，将所有的fallback方法写到了一起，和我们的业务代码完全解耦了。对比第一个，我们可以定义一个统一的方法来实现DefalutPropeties。这种方法适合Feign作为客户端的调用，比较推荐这种。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;1.2.2&quot;&gt;服务熔断&lt;/h3&gt;
&lt;p&gt;​ 请再回去看一下上边的关于服务熔断的理论知识，我相信你一定能看懂。当启用服务降级时，会默认启用服务熔断机制，我们只需要对一些参数进行配置就可以了，就是在上边的@HystrixCommand中的一些属性，比如：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@HystrixCommand(fallbackMethod = &quot;TimeOutErrorHandler&quot;,commandProperties = {
    @HystrixProperty(name=&quot;execution.isolation.thread.timeoutInMilliseconds&quot;,value = &quot;3000&quot;),
    @HystrixProperty(name=&quot;circuitBreaker.enabled&quot;,value=&quot;true&quot;),//开户断路器
    @HystrixProperty(name=&quot;circuitBreaker.requestVolumeThreshold&quot;,value=&quot;20&quot;),//请求次数的峰值
    @HystrixProperty(name=&quot;circuitBreaker.sleepWindowInMilliseconds&quot;,value=&quot;10000&quot;),//检测错误次数的时间范围
    @HystrixProperty(name=&quot;circuitBreaker.errorThresholdPercentage&quot;,value=&quot;60&quot;)//请求失败率达到多少比例后会打开断路器
})&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;4.3857868020305&quot;&gt;
&lt;p&gt;这些配置可以在&lt;a href=&quot;https://github.com/Netflix/Hystrix/wiki/Configuration&quot; class=&quot;uri&quot;&gt;https://github.com/Netflix/Hystrix/wiki/Configuration&lt;/a&gt;了解，也可以打开查看HystrixCommandProperties类中的属性(使用idea一搜索就有)，全部都有默认配置&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;服务限流&quot;&gt;服务限流&lt;/h3&gt;
&lt;p&gt;东西太多，关注我期待后续。&lt;/p&gt;
&lt;h3 id=&quot;项目代码和更多的学习地址&quot;&gt;项目代码和更多的学习地址&lt;/h3&gt;
&lt;p&gt;关注微信公从号“小鱼与Java”，回复“SpringCloud”获取&lt;br/&gt;&lt;img src=&quot;https://lyn4ever.gitee.io/img/wx/gzh2.png&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Thu, 19 Mar 2020 17:14:00 +0000</pubDate>
<dc:creator>小鱼吃猫</dc:creator>
<og:description>SpringCloud是通过HTTP Rest的方式在“微服务”之间进行调用的，所以每一个“微服务”都是一个web项目。既然它是一个web项目，它就就有可能会发生错误，这个错误有可能是服务器内存不足、</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Lyn4ever/p/12528913.html</dc:identifier>
</item>
<item>
<title>使用Github Packages功能上传nuget包到Github - Agile.Zhou</title>
<link>http://www.cnblogs.com/kklldog/p/upload-nupkg-2-github.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kklldog/p/upload-nupkg-2-github.html</guid>
<description>&lt;p&gt;前几天微软收购npm的新闻对于软粉来收很是振奋。微软收购npm很可能是为了加强Github Packages。目前Github，Typescript，VSCode，npm这些开源社区的重磅工具全部都在微软旗下，显示出了微软对开源的态度，微软已经不是以前那个封闭的微软。Github推出Github Packages功能有一段时间了，一直没使用过，今天有空打算折腾一下，体验一下。&lt;/p&gt;
&lt;h2 id=&quot;什么是github-packages&quot;&gt;什么是Github Packages&lt;/h2&gt;
&lt;p&gt;Github Packages是一个包承载服务，它完全跟Github集成。Github Packages使你的源码和包在同一个地方进行统一的管理，使你可以集中的在Github上开发跟发布。你可以发布公共包（public packages）跟所有人分享，也可以发布私有包（private packages）提供给个人或者组织使用。以上是对官方文档的简单翻译。说简单点就是以前你代码是在Github，但是包可能是在npm，maven或者nuget上，现在你在Github上传代码后还可以直接把包也上传到Github，方便统一管理，发布。&lt;/p&gt;
&lt;h2 id=&quot;在github-packages上发布包&quot;&gt;在Github Packages上发布包&lt;/h2&gt;
&lt;p&gt;下面让我们开始尝试使用Github Packages发布一个包吧。&lt;/p&gt;
&lt;h3 id=&quot;在github上新建一个仓库higithubpackage&quot;&gt;在Github上新建一个仓库HiGithubPackage&lt;/h3&gt;
&lt;p&gt;新建一个公共的仓库命名HiGithubPackage&lt;br/&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/03/20/86QtBD.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;在github上申请access-token&quot;&gt;在Github上申请Access Token&lt;/h3&gt;
&lt;p&gt;在Github上申请一个新的Access Token。这个Token是用来上传Package的凭证，后面需要配置。登录Github后点击个人头像-Settings-Developer settings-Personal access tokens-Generate new token，然后勾选packages的权限后点Generate token按钮生成token。复制好这个token，不要丢了，因为你关闭这个页面后，后面就再也找不回这个token了。&lt;br/&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/03/20/86QB9I.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;新建一个.net-core项目higithubpackage&quot;&gt;新建一个.net Core项目HiGithubPackage&lt;/h3&gt;
&lt;p&gt;使用Visual studio新建一个core标准库项目。新建一个类，这个类里只有一个静态方法Hi，调用的话会输出一行Hi GithubPackage ~。我打算把这个库上传到Github Packages上去。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;   public class GithubPackage
    {
        public static void Hi ()
        {
            Console.WriteLine(&quot;Hi GithubPackage ~&quot;);
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;顺手把代码也push到github上去吧。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;git push -u origin master&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;新建一个nuget.config文件&quot;&gt;新建一个nuget.config文件&lt;/h3&gt;
&lt;p&gt;在项目文件夹下新建一个nuget.config文件，并且配置它。&lt;br/&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/03/20/86lA5d.png&quot;/&gt;&lt;br/&gt;OWNER填写你Github的用户名&lt;br/&gt;UserName填写你Github的用户名&lt;br/&gt;Token填写上面申请的access token&lt;br/&gt;以下是我的配置&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
&amp;lt;configuration&amp;gt;
    &amp;lt;packageSources&amp;gt;
        &amp;lt;clear /&amp;gt;
        &amp;lt;add key=&quot;github&quot; value=&quot;https://nuget.pkg.github.com/kklldog/index.json&quot; /&amp;gt;
    &amp;lt;/packageSources&amp;gt;
    &amp;lt;packageSourceCredentials&amp;gt;
        &amp;lt;github&amp;gt;
            &amp;lt;add key=&quot;Username&quot; value=&quot;kklldog&quot; /&amp;gt;
            &amp;lt;add key=&quot;ClearTextPassword&quot; value=&quot;xxx&quot; /&amp;gt;
        &amp;lt;/github&amp;gt;
    &amp;lt;/packageSourceCredentials&amp;gt;
&amp;lt;/configuration&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;修改包信息并打包&quot;&gt;修改包信息并打包&lt;/h3&gt;
&lt;p&gt;在Visual studio上右键项目，选择编辑项目文件。我们在csproj文件下编辑包信息。其中包含包的id，版本，授权等，比较简单一看就明白了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&amp;gt;

  &amp;lt;PropertyGroup&amp;gt;
    &amp;lt;TargetFramework&amp;gt;netstandard2.0&amp;lt;/TargetFramework&amp;gt;
    &amp;lt;PackageId&amp;gt;HiGithubPackage&amp;lt;/PackageId&amp;gt;
    &amp;lt;Version&amp;gt;1.0.0&amp;lt;/Version&amp;gt;
    &amp;lt;Authors&amp;gt;minjie.zhou&amp;lt;/Authors&amp;gt;
    &amp;lt;Description&amp;gt;Test upload to github packages&amp;lt;/Description&amp;gt;
    &amp;lt;PackageLicenseExpression&amp;gt;MIT&amp;lt;/PackageLicenseExpression&amp;gt;
    &amp;lt;RepositoryUrl&amp;gt;https://github.com/kklldog/HiGithubPackage&amp;lt;/RepositoryUrl&amp;gt;
    &amp;lt;GeneratePackageOnBuild&amp;gt;true&amp;lt;/GeneratePackageOnBuild&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;

&amp;lt;/Project&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改完后&lt;strong&gt;ctrl-b&lt;/strong&gt;一下进行一次编译。编译完后在bin\debug下会生成一个.nupkg的包文件。&lt;br/&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/03/20/861kLT.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;上传包到github-packages&quot;&gt;上传包到Github packages&lt;/h3&gt;
&lt;p&gt;使用dotnet cli进行上传&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;dotnet nuget push &quot;bin/debug/HiGithubPackage1.0.0.nupkg&quot; --source &quot;github&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/03/20/86QGjK.png&quot;/&gt;&lt;br/&gt;这里可能要多试几次，有的时候会提示401的错误。&lt;br/&gt;上传成功后回到Github网站刷新下看看HiGithubPackage仓库。可以看到我们的包已经出现在上面。&lt;/p&gt;
&lt;h3 id=&quot;新建一个.net-core控制台项目higithubpackagetest&quot;&gt;新建一个.net Core控制台项目HiGithubPackageTest&lt;/h3&gt;
&lt;p&gt;新建另外一个core项目，这个项目要引用我们上传成功的包并使用它。&lt;br/&gt;使用dotnet cli来安装这个包&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;dotnet add HiGithubPackageTest package HiGithubPackage --version 1.0.0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里也要多试几次，同样会出现401的问题。最后我挂上FQ工具才安装成功。&lt;br/&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/03/20/86QYnO.png&quot;/&gt;&lt;br/&gt;修改Program类来使用这个包。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  class Program
    {
        static void Main(string[] args)
        {
            HiGithubPackage.GithubPackage.Hi();

            Console.ReadLine();
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行一下成功的输入了“Hi GithubPackage ~”，说明成功的引用了HiGithubPackage这个包。&lt;br/&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/03/20/86QQhR.md.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;一些小问题&quot;&gt;一些小问题&lt;/h3&gt;
&lt;p&gt;通过以上一些了操作我们演示了如果上传一个包到Github Packages服务。演示了如果下载一个包到项目并使用它。总体体验其实一般般，但是个人觉得有几个小问题：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;上传的包并不会出现在nuget.org官方源里面。不出现在官方源里面的话其他项目要使用这个包就会相当麻烦。毕竟大家都喜欢使用nuget管理程序来安装包，使用cli的话会比较麻烦。&lt;/li&gt;
&lt;li&gt;不知道是不是墙的问题，上传包跟安装包都碰到了比较严重的网络问题，如果没有FQ工具的话会很麻烦，当然这不是Github的锅。&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Thu, 19 Mar 2020 16:45:00 +0000</pubDate>
<dc:creator>Agile.Zhou</dc:creator>
<og:description>前几天微软收购npm的新闻对于软粉来收很是振奋。微软收购npm很可能是为了加强Github Packages。目前Github，Typescript，VSCode，npm这些开源社区的重磅工具全部都在</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/kklldog/p/upload-nupkg-2-github.html</dc:identifier>
</item>
</channel>
</rss>