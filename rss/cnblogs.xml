<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>2021年把公众号做成自己喜欢的样子 - dongfanger</title>
<link>http://www.cnblogs.com/df888/p/14219339.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/df888/p/14219339.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;点击播放音乐体验更佳。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;2020年11月26日我发表了一篇关于公众号转型的说明文章：&lt;/p&gt;
&lt;p&gt;关于公众号转型的两千字说明&lt;/p&gt;
&lt;p&gt;从那时以来，公众号写作已经慢慢调整为了，以Python技术栈为主的垂直创作模式，专注了许多，清爽了许多。简介，&lt;code&gt;Learn Python step by step&lt;/code&gt;，一步一步学Python，匹配公众号内容：记录Python学习笔记，分享Python使用经验，研究Python技术原理。名字，&lt;code&gt;PythonMind&lt;/code&gt;，标识了测试行业生态较好的&lt;code&gt;Python&lt;/code&gt;技术栈，就像用&lt;code&gt;XMind&lt;/code&gt;写测试用例，&lt;code&gt;PythonMind&lt;/code&gt;目标是帮助提升&lt;code&gt;Python&lt;/code&gt;编程思维。头像，没有改，是一种情怀，向上延伸展开的珊瑚枝丫，也正好符合&lt;code&gt;Mind&lt;/code&gt;思维发散的意思：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202101/1629545-20210101075841864-1465362185.png&quot;/&gt;&lt;/center&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202101/1629545-20210101075842155-1622665653.png&quot;/&gt;&lt;/center&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;code&gt;Mind&lt;/code&gt;是从地铁那句“Please be careful and mind your step”想到的，&lt;code&gt;Mind&lt;/code&gt;谐音“慢的”，慢慢学。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;转型说明提到的系列有两个调整。一是去掉了“算法”系列，每周末和小伙伴们一起刷题，实际敲代码，相互交流，提升效果比写文章更好。二是“测试成长小说”系列最近停更了，因为我准备把内容从“测试成长小说”扩大到“成长小说”，既包括测试成长，也包括所见所闻、职场经验、价值观点等。创作方式不变，风格依旧，每篇800字左右，根据个人真实经历改编，参考古龙武侠，以小说形式讲一个成长话题。如果某天看到我推了一篇非技术文，标题有点像吐槽，那么大概率是这个系列了。故事主线参考以下测试能力模型展开：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202101/1629545-20210101075839674-1815938129.png&quot; alt=&quot;测试能力模型&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;经过了一番清理后，公众号内容分类如下：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202101/1629545-20210101084519239-1567782381.png&quot;/&gt;&lt;/center&gt;
&lt;p&gt;在2020年最后几天，没想到tep这篇文章被社区加精了，&lt;code&gt;tep&lt;/code&gt;测试工具被更多人知道后，交流碰撞产生出新想法，比如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;变量、接口、用例3个级别复用&lt;/li&gt;
&lt;li&gt;提取预置&lt;code&gt;fixture&lt;/code&gt;到&lt;code&gt;tep.fixture&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;conftest.py&lt;/code&gt;自动注册&lt;code&gt;fixtures&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;自动生成接口测试用例&lt;/li&gt;
&lt;li&gt;支持UI自动化&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我会逐一实践，验证，分享，谢谢大家支持，容忍不稳定Bug，期待更多火花：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://testerhome.com/topics/27284&quot; target=&quot;_blank&quot;&gt;tep用户手册帮你从unittest过渡到pytest&lt;/a&gt;&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202101/1629545-20210101075842461-1258228145.png&quot;/&gt;&lt;/center&gt;
&lt;p&gt;还有没想到的是，我竟然对封面越来越挑了！为了选个合适的图片，有时会花半个小时，预览七八张才确定。除了自己看着舒服，也希望有人翻开公众号，觉得“虽然内容不咋地，封面看着倒还不错”，那也是极好的。&lt;/p&gt;
&lt;p&gt;我数了一下从12月1号到12月25号，我一共更新了21篇文章，连续日更分别有5天、6天、9天，累且充实：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202101/1629545-20210101075842775-659833296.png&quot;/&gt;&lt;/center&gt;
&lt;p&gt;我写文章第一遍很快，但是发公众号的话会反复修改很多遍，调整文章结构、措辞、语句通顺、错别字、语感、排版，几乎所有时间、精力、身体都耗在这件事上。综合考量了工作、学习、生活平衡后，我决定仍然保持学习劲头，做好笔记，但是按周更的节奏来分享，每周五发1篇，一个月4、5篇的样子。慢慢更新，徐徐道来。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;固定周五推送，忙的话延一周，坚持原创输出，只做精品文章。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;目前我的文章全部原创，接下来也会坚持原创，暂不转载。2021年的重心是完成整个Python进阶系列。我将参考《流畅的Python》这本书来写，全书共600页，分成了21个章节：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202101/1629545-20210101075840500-377960415.png&quot; alt=&quot;image-20201216205446264&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是我上次阅读写的读书笔记，记录了每章的知识要点，手打了一万多字。我想了两个方案来完成这次重写：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;内容拆细，按每篇文章800字左右来写。好处是便于快速了解某些特性，碎片化阅读，缺点是不够系统，知识比较零散。&lt;/li&gt;
&lt;li&gt;系统编排，不考虑字数，注意内容结构。好处是能形成知识体系，有条有理，缺点是水平有限，怕写不好，写的慢。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;如果按第1个方案来写，最终成果很可能没有亮点，无法形成个人特色，容易烂大街。经过深思熟虑后，我选择了第2个方案，把这件事作为2021年的挑战，写成一本电子书，作为个人代表作。俗话说：“外行看热闹，内行看门道”，Python进阶我的目标是构建Pythonic的编程思维，知其然，知其所以然。因为我是做测试的，所以会选择一些测试框架或工具的代码片段，理论结合实践来写。不知道会遇到什么困难，最后会写成什么样，尽力而为吧。&lt;/p&gt;
&lt;p&gt;公众号无法留言，如果想和我们一起交流，欢迎加入【Python晨岛云野】，公众号后台回复【加群】即可，以下是群公告：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202101/1629545-20210101075843353-676339291.png&quot;/&gt;&lt;/center&gt;
&lt;p&gt;基于以下3个原因：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;提高PC端阅读体验，尤其是代码部分&lt;/li&gt;
&lt;li&gt;方便系统浏览，提供左侧导航树索引&lt;/li&gt;
&lt;li&gt;为同名电子书PythonMind做准备&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我部署了一个在线文档网站，后台回复【在线】可获取网址：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202101/1629545-20210101075841389-816002459.png&quot; alt=&quot;image-20201228212054743&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最新文章还是请在公众号看啦，网站相当于归档，我会不定期地整理文章放上去。&lt;/p&gt;
&lt;p&gt;2021年，希望能保持心情开朗，当感到自卑时和自己纵向比较，找信心，当感到膨胀时和别人横向比较，多冷静，坐看四季变换，乐享云淡风轻，忠于写公众号学习分享的初心，把公众号做成自己喜欢的样子。&lt;/p&gt;
</description>
<pubDate>Fri, 01 Jan 2021 00:50:00 +0000</pubDate>
<dc:creator>dongfanger</dc:creator>
<og:description>点击播放音乐体验更佳。 2020年11月26日我发表了一篇关于公众号转型的说明文章： 关于公众号转型的两千字说明 从那时以来，公众号写作已经慢慢调整为了，以Python技术栈为主的垂直创作模式，专注了</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/df888/p/14219339.html</dc:identifier>
</item>
<item>
<title>「每日一题」与面试官手撕代码：如何科学高效的寻找重复元素？ - saucxs</title>
<link>http://www.cnblogs.com/chengxs/p/14219279.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chengxs/p/14219279.html</guid>
<description>&lt;p&gt;关注公众号「松宝写代码」，精选好文，每日一题&lt;/p&gt;
&lt;p&gt;加入我们一起学习，day day up&lt;/p&gt;
&lt;p&gt;经过三天时间，已经有小伙伴（xpf666）给我们贡献文章了，超级开心和激动，因为我们不是一个人在战斗，&lt;br/&gt;不是一个人在努力提高自己，加入我们，&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如何加入我们？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第一步：文章下面留言，留言内容：想写什么文章。&lt;/p&gt;
&lt;p&gt;第二步：我们就会找到你&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;作者：xpf666&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;来源：原创&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一、前言&quot;&gt;一、前言&lt;/h2&gt;
&lt;p&gt;2020.12.23 日刚立的 flag，每日一题，题目类型不限制，可以是：算法题，面试题，阐述题等等。&lt;/p&gt;
&lt;p&gt;本文是「每日一题」第 4 题，由 xpf666 带来的文章：如何科学高效的寻找重复元素？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/saucxs/full_stack_knowledge_list/master/daily-question/daily_question.png&quot; alt=&quot;每日一题&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;往期「每日一题」：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/QuuPd2KCp50snN7F2o3oYg&quot; target=&quot;_blank&quot;&gt;https://mp.weixin.qq.com/s/QuuPd2KCp50snN7F2o3oYg&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/omeVJdtabo5MeN3DItDfWg&quot; target=&quot;_blank&quot;&gt;https://mp.weixin.qq.com/s/omeVJdtabo5MeN3DItDfWg&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/O8j9gM5tD5rjLz1kdda3LA&quot; target=&quot;_blank&quot;&gt;https://mp.weixin.qq.com/s/O8j9gM5tD5rjLz1kdda3LA&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;二、寻找重复元素&quot;&gt;二、寻找重复元素&lt;/h2&gt;
&lt;h3 id=&quot;1-找出任意一个重复数字&quot;&gt;1. &lt;strong&gt;找出任意一个重复数字&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;给定一个长度为 n 的数组 nums，判断是否有重复值。&lt;/p&gt;
&lt;p&gt;示例：输入[1,2,3,2,1,4,5] 输出 1 或 2&lt;/p&gt;
&lt;p&gt;思路：根据经验，基本上所有判断重复的需求，都可以通过 Set 或者 Map 解决，Set 解决方式就是判断 add 方法的返回是 true 还是 false，false 就证明之前已存在，也就是数据重复。Map 是通过 containsKey，true 就说明之前存在 key。&lt;/p&gt;
&lt;p&gt;题解：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public int getResult(int[] nums) {
    Set&amp;lt;Integer&amp;gt; set = new HashSet&amp;lt;Integer&amp;gt;();
    int result = -1;
    for (int num : nums) {
        if (!set.add(num)) {
            result = num;
            break;
        }
    }
    return result;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果上面代码格式出现问题，可以查看下面代码图片&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/saucxs/full_stack_knowledge_list/master/daily-question/algorithm/carbon_0.png&quot; alt=&quot;找出任意一个重复数字&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;遍历 n 次并且 Set 内容最多是 n 个字符，复杂度都是 O(n)&lt;/p&gt;
&lt;h3 id=&quot;2-找出任意一个重复数字&quot;&gt;2. &lt;strong&gt;找出任意一个重复数字&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;给定一个长度为 n 的数组 nums，判断是否有重复值,并且两个重复值距离不超过 k。&lt;/p&gt;
&lt;p&gt;示例：输入[1,2,3,2,1,4,5] ，k = 2 输出 true(两个 2)&lt;/p&gt;
&lt;p&gt;思路：同问题一，只要多判断一次 Set 长度即可。&lt;/p&gt;
&lt;p&gt;题解：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public boolean containsNearbyDuplicate(int[] nums, int k) {
    Set&amp;lt;Integer&amp;gt; set = new HashSet&amp;lt;Integer&amp;gt;();
    boolean result = false;
    for (int i = 0; i &amp;lt; nums.length; i++) {
        if (!set.add(nums[i])) {
            result = true;
            break;
        }

        if (set.size() &amp;gt; k) { // 超过长度就删除最远的一个数
            set.remove(nums[i-k]);
        }
    }
    return result;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果上面代码格式出现问题，可以查看下面代码图片&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/saucxs/full_stack_knowledge_list/master/daily-question/algorithm/carbon_1.png&quot; alt=&quot;找出任意一个重复数字&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;遍历 n 次并且 k 最多 n 个字符，复杂度都是 O(n)&lt;/p&gt;
&lt;h3 id=&quot;3-寻找重复数&quot;&gt;3. &lt;strong&gt;寻找重复数&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和&lt;br/&gt;n），只有一个重复的整数，找出这个重复的数字。&lt;/p&gt;
&lt;p&gt;示例：输入[1,3,4,2,2] 输出 2&lt;/p&gt;
&lt;p&gt;思路：可通过问题 1 方式解决。还可以通过快慢指针法解决：将数组看成一个链表，下标为当前指针（node），值指向下一指针(nextNode)，数组出现重复的数字意味着有两个指针的 nextNode 相同。然后通过快慢指针法解决。&lt;/p&gt;
&lt;p&gt;题解：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public int getResult(int[] nums) {
    int result = 0;
    int slow = 0, fast = 0;
    do  {
        slow = nums[slow];
        fast = nums[nums[fast]];
    } while (slow != fast);

    do {
        slow = nums[slow];
        result = nums[result];
    } while (result != slow);
    return result;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果上面代码格式出现问题，可以查看下面代码图片&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/saucxs/full_stack_knowledge_list/master/daily-question/algorithm/carbon_2.png&quot; alt=&quot;找出任意一个重复数字&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;遍历 2n 次时间复杂的是 O(n)，只用了常量个字符，空间复杂度是 O(1)&lt;/p&gt;
&lt;h3 id=&quot;4-只出现一次的数&quot;&gt;4. &lt;strong&gt;只出现一次的数&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;给定一个数组&lt;br/&gt;nums，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。&lt;/p&gt;
&lt;p&gt;示例：输入[1,1,4,2,2] 输出 4&lt;/p&gt;
&lt;p&gt;思路：可通过问题 1 方式解决。还可以通过位运算解决，两个相同数异或后为 0，数组所有元素执行一次异或操作，剩下就是出现一次的数。&lt;/p&gt;
&lt;p&gt;题解：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public int getResult(int[] nums) {
    int result = 0;
    for (int num : nums) {
        result = result ^ num;
    }
    return result;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果上面代码格式出现问题，可以查看下面代码图片&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/saucxs/full_stack_knowledge_list/master/daily-question/algorithm/carbon_3.png&quot; alt=&quot;找出任意一个重复数字&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;遍历 n 次时间复杂的是 O(n)，只用了常量个字符，空间复杂度是 O(1)&lt;/p&gt;
&lt;h3 id=&quot;5-只出现一次的数&quot;&gt;5. &lt;strong&gt;只出现一次的数&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;给定一个数组&lt;br/&gt;nums，除了两个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。&lt;/p&gt;
&lt;p&gt;示例：输入[1,1,3,4,2,2] 输出[3,4]&lt;/p&gt;
&lt;p&gt;思路：可通过问题 1 方式解决。还可以通过位运算解决，和题 4 区别是存在 2 个只出现一次的数，所以要想办法把这两个数区分出来。先将数组所有元素异或，得出的值是两个只出现一次元素 a,b 的异或值 numsXOR（如 10010）。numsXOR 二进制中 1 的位就是 a 和 b 差异位（因为不同的值异或才是 1），现在只需要找 lowbit(最右一位差异值，10)，然后通过 lowbit 和 a&lt;br/&gt;, b&lt;br/&gt;进行与运算（&amp;amp;），得出的值就一定不同，这样可以分出 a 和 b，最后按照异或运算就能得出结果（其他重复的不用管，不管分到哪一组，重复的数异或都是 0）&lt;/p&gt;
&lt;p&gt;题解：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public int[] singleNumber(int[] nums) {
    int[] results = new int[]{0,0};
    int numsXOR = 0; // 两个数异或值
    for (int num : nums) {
        numsXOR = numsXOR ^ num;
    }

    int lowBit = numsXOR &amp;amp; (-numsXOR); // lowbit值，用于区分a和b

    for (int num : nums) {
        if ((lowBit &amp;amp; num) == 0) {
            results[0] = results[0] ^ num;
        } else {
            results[1] = results[1] ^ num;
        }
    }

    return results;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果上面代码格式出现问题，可以查看下面代码图片&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/saucxs/full_stack_knowledge_list/master/daily-question/algorithm/carbon_4.png&quot; alt=&quot;找出任意一个重复数字&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;遍历 2n 次时间复杂的是 O(n)，只用了常量个字符，空间复杂度是 O(1)&lt;/p&gt;
&lt;h2 id=&quot;各种福利&quot;&gt;各种福利&lt;/h2&gt;
&lt;p&gt;关注「松宝写代码」，后台回复&lt;/p&gt;
&lt;h3 id=&quot;1、字节内推福利&quot;&gt;1、字节内推福利&lt;/h3&gt;
&lt;p&gt;回复「校招」获取内推码&lt;/p&gt;
&lt;p&gt;回复「社招」获取内推&lt;/p&gt;
&lt;p&gt;回复「实习生」获取内推&lt;/p&gt;
&lt;p&gt;后续会有更多福利&lt;/p&gt;
&lt;h3 id=&quot;2、学习资料福利&quot;&gt;2、学习资料福利&lt;/h3&gt;
&lt;p&gt;回复「算法」获取算法学习资料&lt;/p&gt;
&lt;h3 id=&quot;3、每日一题&quot;&gt;3、每日一题&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/QuuPd2KCp50snN7F2o3oYg&quot; target=&quot;_blank&quot;&gt;https://mp.weixin.qq.com/s/QuuPd2KCp50snN7F2o3oYg&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/omeVJdtabo5MeN3DItDfWg&quot; target=&quot;_blank&quot;&gt;https://mp.weixin.qq.com/s/omeVJdtabo5MeN3DItDfWg&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/O8j9gM5tD5rjLz1kdda3LA&quot; target=&quot;_blank&quot;&gt;https://mp.weixin.qq.com/s/O8j9gM5tD5rjLz1kdda3LA&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;谢谢支持&quot;&gt;谢谢支持&lt;/h2&gt;
&lt;p&gt;1、喜欢的话可以「分享，点赞，评论」三连哦。&lt;/p&gt;
&lt;p&gt;2、作者昵称：saucxs，songEagle，松宝写代码。字节跳动的一枚前端工程师，一个正在努力成长的作者，星辰大海，未来可期，&lt;strong&gt;内推字节跳动各个部门各个岗位。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;3、长按下面图片，关注「松宝写代码」，是获取开发知识体系构建，精选文章，项目实战，实验室，每日一道面试题，进阶学习，思考职业发展，涉及到JavaScript，Node，Vue，React，浏览器，http等领域，希望可以帮助到你，我们一起成长～&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/saucxs/full_stack_knowledge_list/master/daily-question/dongtai.gif&quot; alt=&quot;松宝写代码&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 31 Dec 2020 18:00:00 +0000</pubDate>
<dc:creator>saucxs</dc:creator>
<og:description>「每日一题」与面试官手撕代码：如何科学高效的寻找重复元素？ 关注公众号「松宝写代码」，精选好文，每日一题 加入我们一起学习，day day up 经过三天时间，已经有小伙伴（xpf666）给我们贡献文</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/chengxs/p/14219279.html</dc:identifier>
</item>
<item>
<title>给2021年的我立几个FLAG - 阡陌夕殇</title>
<link>http://www.cnblogs.com/mengxudong/p/14219258.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mengxudong/p/14219258.html</guid>
<description>&lt;p&gt;看多了大牛的年终总结，我也懒得写了，反正写出来也没人看。&lt;/p&gt;
&lt;p&gt;其实上面都是借口，我只是完全没有写年终总结的习惯。&lt;/p&gt;
&lt;p&gt;为啥呢？因为这些年过的平平无奇，并没有什么特别出彩的事情。&lt;/p&gt;
&lt;p&gt;如果有，嗯，2020年，我结婚了，娶了一位漂亮的老婆。&lt;/p&gt;
&lt;p&gt;但是在各位大牛的高光之下，这仿佛只是一个小小的成就。&lt;/p&gt;
&lt;p&gt;然后，公司里，我还是继续在摸鱼，持续的摸鱼。&lt;/p&gt;
&lt;p&gt;每天沉浸在业务的海洋中，技术已经放下很久了。&lt;/p&gt;
&lt;p&gt;等到想重新拿起来的时候，才发现自己的技术博客已经几年没有更新了。&lt;/p&gt;
&lt;p&gt;嗯，我决定做一点点改变，只改变一点点。&lt;/p&gt;
&lt;p&gt;这是我的初心，也是我想追求的目标。&lt;/p&gt;
&lt;p&gt;虽然我总是在摸鱼，但我还是不甘心只当一条咸鱼。&lt;/p&gt;
&lt;p&gt;所以，我决定给自己几个 flag，至少能让2021年的我升级成稍微不那么咸的鱼。&lt;/p&gt;
&lt;p&gt;并且，我的 flag 必须是一个可量化的目标，不然做没做到还不是我说了算？&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;写100篇技术博客，积累学到的东西，写出来才是自己的。&lt;/li&gt;
&lt;li&gt;每月看一本书，内容不限，扩大自己的视野。&lt;/li&gt;
&lt;li&gt;每周运动3-4次，保持一个健康的身体，身体是革命的本钱&lt;/li&gt;
&lt;li&gt;工资达到20k，虽然对于大神们来说很简单😄&lt;/li&gt;
&lt;li&gt;每周给老婆端至少三盆洗脚水，这个好像我已经做到了，值得庆贺&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;先想到的就这么多，flag也不能立太多，容易坑自己。至于能不能做到，请各位博友监督我。如果没做到，&lt;strong&gt;年底喝老婆洗脚水&lt;/strong&gt;。&lt;/p&gt;
</description>
<pubDate>Thu, 31 Dec 2020 17:03:00 +0000</pubDate>
<dc:creator>阡陌夕殇</dc:creator>
<og:description>看多了大牛的年终总结，我也懒得写了，反正写出来也没人看。 其实上面都是借口，我只是完全没有写年终总结的习惯。 为啥呢？因为这些年过的平平无奇，并没有什么特别出彩的事情。 如果有，嗯，2020年，我结婚</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mengxudong/p/14219258.html</dc:identifier>
</item>
<item>
<title>KafkaProducer 简析 - buttercup</title>
<link>http://www.cnblogs.com/buttercup/p/14201153.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/buttercup/p/14201153.html</guid>
<description>&lt;p&gt;KafkaProducer 发送消息主要有以下 3 种方式：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    Properties properties = new Properties();
    properties.setProperty(&quot;bootstrap.servers&quot;, &quot;localhost:9092&quot;);
    properties.setProperty(&quot;key.serializer&quot;, &quot;org.apache.kafka.common.serialization.StringSerializer&quot;);
    properties.setProperty(&quot;value.serializer&quot;, &quot;org.apache.kafka.common.serialization.StringSerializer&quot;);

    KafkaProducer&amp;lt;String, String&amp;gt; producer = new KafkaProducer&amp;lt;&amp;gt;(properties);
    ProducerRecord&amp;lt;String, String&amp;gt; record = new ProducerRecord&amp;lt;&amp;gt;(&quot;topic&quot;, &quot;key&quot;, &quot;value&quot;);
    
    // 发送并忘记（fire-and-forget）
    producer.send(record);

    // 同步发送
    Future&amp;lt;RecordMetadata&amp;gt; future = producer.send(record);
    RecordMetadata metadata = future.get();

    // 异步发送
    producer.send(record, new Callback() {
        @Override
        public void onCompletion(RecordMetadata metadata, Exception exception) {
            
        }
    });

    producer.close();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;具体的发送流程可以参考 &lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/buttercup/p/14130406.html#producer-%E5%8F%91%E9%80%81%E9%93%BE%E8%B7%AF&quot; target=&quot;_blank&quot;&gt;KafkaProducer发送流程简析&lt;/a&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;KafkaProducer 是线程安全的，多个线程可以共享同一个 KafkaProducer 对象。&lt;/p&gt;

&lt;h4 id=&quot;clientid&quot;&gt;&lt;strong&gt;client.id&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;　该参数可以是任意的字符串，broker 会用它来识别消息的来源，会在日志和监控指标里展示。&lt;/p&gt;
&lt;h4 id=&quot;bootstrapservers&quot;&gt;&lt;strong&gt;bootstrap.servers&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;　该属性指定 broker 的地址列表。&lt;br/&gt;　清单里不需要包含所有的 broker 地址，生产者会从给定的 broker 里查找到其他 broker 的信息。&lt;br/&gt;　不过建议至少要提供两个 broker 的信息，一旦其中一个宕机，生产者仍然能够连接到集群上。&lt;/p&gt;
&lt;h4 id=&quot;keyserializer--valueserializer&quot;&gt;&lt;strong&gt;key.serializer &amp;amp; value.serializer&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;　这两个属性必须被设置为一个实现了&lt;code&gt;org.apache.kafka.common.serialization.Serializer&lt;/code&gt;接口的类。&lt;br/&gt;　生产者会使用这个类把键值对象序列化成字节数组。&lt;/p&gt;
&lt;h4 id=&quot;receivebufferbytes--sendbufferbytes&quot;&gt;&lt;strong&gt;receive.buffer.bytes &amp;amp; send.buffer.bytes&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;　设置 socket 读写数据时用到的 TCP 缓冲区大小。如果它们被设为 -1，就使用操作系统的默认值。&lt;br/&gt;　当生产者或消费者与 broker 处于不同的机房时，可以适当&lt;a href=&quot;https://www.cnblogs.com/buttercup/p/13812221.html#%E9%95%BF%E8%82%A5%E7%AE%A1%E9%81%93-lfn&quot; target=&quot;_blank&quot;&gt;增大这些值&lt;/a&gt;。&lt;/p&gt;
&lt;h4 id=&quot;buffermemory&quot;&gt;&lt;strong&gt;buffer.memory&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;　设置生产者内存缓冲区的大小，生产者用它缓冲要发送到服务器的消息。&lt;br/&gt;　如果应用程序发送消息的速度超过发送到服务器的速度，会导致生产者空间不足。&lt;br/&gt;　此时&lt;code&gt;KafkaProducer.send()&lt;/code&gt;会阻塞等待内存释放，等待时间超过 max.block.ms 后会抛出超时异常。&lt;/p&gt;
&lt;h4 id=&quot;compressiontype&quot;&gt;&lt;strong&gt;compression.type&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;　该参数指定了消息被发送给 broker 之前，使用哪一种压缩算法（&lt;code&gt;snappy&lt;/code&gt;，&lt;code&gt;gzip&lt;/code&gt;或&lt;code&gt;lz4&lt;/code&gt;）进行压缩。&lt;br/&gt;　使用压缩可以降低网络传输开销和存储开销，而这往往是向 Kafka 发送消息的瓶颈所在。&lt;/p&gt;
&lt;h4 id=&quot;batchsize&quot;&gt;&lt;strong&gt;batch.size&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;　该参数指定了一个批次可以使用的内存字节数（而不是消息个数）。&lt;br/&gt;　消息批次&lt;code&gt;ProducerBatch&lt;/code&gt;包含了一组将要发送至同个分区的消息，当批次被填满，批次里的所有消息会被立即发送出去。&lt;/p&gt;
&lt;p&gt;　不过生产者并不一定都会等到批次被填满才发送，半满甚至只包含一个消息的批次也可能被发送。&lt;br/&gt;　所以就算把批次大小设置得很大，也不会造成延迟，只是会占用更多的内存而已。&lt;br/&gt;　但如果设置得太小，生产者会频繁地发送消息，会增加一些额外的网络开销。&lt;/p&gt;
&lt;h4 id=&quot;lingerms&quot;&gt;&lt;strong&gt;linger.ms&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;　该参数指定了生产者在发送批次之前等待的时间。&lt;br/&gt;　生产者会在批次填满或等待时间达到 linger.ms 时把批次发送出去。&lt;br/&gt;　设置&lt;code&gt;linger.ms&amp;gt;0&lt;/code&gt;会增加延迟，但也会提升吞吐量（一次性发送更多的消息，每个消息的开销就变小了）。&lt;/p&gt;
&lt;h4 id=&quot;acks&quot;&gt;&lt;strong&gt;acks&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;　参数指定了必须要有多少个分区副本收到消息，生产者才会认为消息写入是成功的。&lt;br/&gt;　这个参数决定令消息丢失的可能性：&lt;/p&gt;
&lt;ul readability=&quot;5.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;code&gt;acks=0&lt;/code&gt; &lt;strong&gt;生产者发出消息后不等待来自服务器的响应&lt;/strong&gt;&lt;br/&gt;如果当中出现了问题，导致服务器没有收到消息，那么生产者就无从得知，消息也就丢失了。&lt;br/&gt;不过，因为生产者不需要等待服务器的响应，所以它可以以网络能够支持的最大速度发送消息，从而达到很高的吞吐量。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;&lt;code&gt;acks=1&lt;/code&gt; &lt;strong&gt;只要集群的 leader 节点收到消息，生产者就会收到一个来自服务器的成功响应&lt;/strong&gt;&lt;br/&gt;如果消息无法到达 leader 节点（比如：leader节点崩溃，新的 leader 还没有被选举出来），生产者会收到一个错误响应。&lt;br/&gt;为了避免数据丢失，生产者会重发消息。不过，如果一个没有收到消息的节点成为新 leader，消息还是会丢失。&lt;/p&gt;
&lt;p&gt;这个时候的吞吐量取决于使用的是同步发送还是异步发送：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;发送端阻塞等待服务器的响应（通过调用 &lt;code&gt;Future.get()&lt;/code&gt; 方法），显然会增加延迟（在网络上传输一个来回的延迟）&lt;/li&gt;
&lt;li&gt;发送端使用回调可以缓解延迟问题，不过吞吐量仍受在途消息数量的限制（比如：生产者在收到服务器响应之前可以发送多少个消息）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;code&gt;acks=all&lt;/code&gt; &lt;strong&gt;只有当所有参与复制的节点全部收到消息时，生产者才会收到一个来自服务器的成功响应&lt;/strong&gt;&lt;br/&gt;这种模式是最安全的，就算有服务器发生崩溃，数据也不会丢失。&lt;br/&gt;不过，它的延迟比 &lt;code&gt;acks=1&lt;/code&gt; 时更高，因为我们要等待不只一个服务器节点接收消息。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;retries&quot;&gt;&lt;strong&gt;retries&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;　该参数决定了生产者可以重发消息的次数（每次重试之间等待 &lt;code&gt;retry.backoff.ms&lt;/code&gt;）。&lt;br/&gt;　服务器返回临时性的错误（比如：分区找不到 leader）时，生产者会自动重试，没必要在代码逻辑里处理可重试的错误。&lt;br/&gt;　作为开发者，只需要处理那些不可重试的错误（比如：消息字节数超过单个发送批次上限）或重试次数超出上限的情况即可。&lt;/p&gt;
&lt;h4 id=&quot;maxinflightrequestsperconnection&quot;&gt;&lt;strong&gt;max.in.flight.requests.per.connection&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;　该参数指定生产者，最多可以发送未响应在途消息批次数量。&lt;br/&gt;　在途消息批次越多，会占用更多的内存，不过也会提升吞吐量。&lt;/p&gt;
&lt;p&gt;　当&lt;code&gt;retries &amp;gt; 0&lt;/code&gt;且&lt;code&gt;max.in.flight.requests.per.connection &amp;gt; 1&lt;/code&gt;时，可能出现消息乱序。&lt;br/&gt;　如果第一个批次消息写入失败，而第二个批次写入成功，broker 会重试写入第一个批次。&lt;br/&gt;　如果此时第一个批次也写入成功，那么两个批次的顺序就反过来了。&lt;/p&gt;
&lt;p&gt;　一般不建议设置&lt;code&gt;retries=0&lt;/code&gt;，而是令&lt;code&gt;max.in.flight.requests.per.connection = 1&lt;/code&gt;来保证消息顺序。&lt;br/&gt;　在生产者尝试发送第一批消息时，就不会有其他的消息发送给 broker，即使发生重试消息也不会乱序。&lt;br/&gt;　不过这样会严重影响生产者的吞吐量，所以只有在对消息的顺序有严格要求的情况下才能这么做。&lt;/p&gt;

&lt;h2 id=&quot;幂等&quot;&gt;幂等&lt;/h2&gt;
&lt;p&gt;当 broker 失效时生产者可能会自动重试，导致一条消息被重复写入多次。&lt;br/&gt;为了避免这种情况，Kafka 在生产者端提供来幂等保证：&lt;strong&gt;同一条消息被生产者发送多次，但在 broker端这条消息只会被写入日志一次&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在发送端设置 &lt;code&gt;enable.idempotence = true&lt;/code&gt; 可以开启幂等性，此时配置同时满足以下条件：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;max.in.flight.requests.per.connection ≤ 5&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;retries &amp;gt; 0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;acks = all&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其工作机制如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;producer 在初始化时必须分配一个 &lt;strong&gt;PID&lt;/strong&gt;&lt;code&gt;producer id&lt;/code&gt;该过程对用户来说是完全透明的）&lt;/li&gt;
&lt;li&gt;发送到 broker 端的每批消息都会被赋予一个单调递增的 &lt;strong&gt;SN&lt;/strong&gt;&lt;code&gt;sequence number&lt;/code&gt;用于消息去重（每个分区都有独立的序列号）&lt;/li&gt;
&lt;li&gt;接收到消息的 broker 会将批次的&lt;code&gt;(PID, SN)&lt;/code&gt;信息一同持久化到对应的分区日志中（保证 leader 切换后去重仍然生效）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;若重试导致 broker 接收到小于或等于已知最大序列号的消息，broker 会拒绝写入这些消息，从而保证每条消息也只会被保存在日志中一次。&lt;br/&gt;由于每个 producer 实例都会被分配不同的 PID，该机制只能保证单个 producer 实例的幂等性，无法实现协同多个 producer 实现幂等。&lt;/p&gt;
&lt;h2 id=&quot;事务&quot;&gt;事务&lt;/h2&gt;
&lt;p&gt;Kafka 事务可以实现 producer 对多个主题和分区的原子写入，并且保证 consumer 不会读取到未提交的数据。&lt;/p&gt;
&lt;p&gt;Kafka 要求应用程序必须提供一个全局唯一的 &lt;strong&gt;TID&lt;/strong&gt;&lt;code&gt;transactional id&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&quot;paper&quot; readability=&quot;11&quot;&gt;初始化时，producer 首先要向 broker 集群注册其 TID，broker 会根据给定的 TID 检查是否存在未完成的事务。
&lt;p&gt;如果某个 producer 实例失效，该机制能够保证下一个拥有相同 TID 的实例首先完成之前未完成的事务。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;此外，broker 还会为自动每个 producer 分配一个&lt;code&gt;epoch&lt;/code&gt;用于隔离&lt;code&gt;fencing out&lt;/code&gt;失效但仍存活的 producer：&lt;/p&gt;
&lt;div class=&quot;paper&quot; readability=&quot;11&quot;&gt;当 producer 参与事务时，broker 会检查是否存在相同的 TID 且 epoch 更大的活跃 producer。
&lt;p&gt;如果存在，则认为当前 producer 是一个僵尸实例&lt;code&gt;zombie instance&lt;/code&gt;并拒绝为其提供服务，防止其破坏事务的完整性。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;下面是两个常见的应用场景：&lt;/p&gt;
&lt;h3 id=&quot;实现跨主题原子写入&quot;&gt;实现跨主题原子写入&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    Properties properties = new Properties();
    properties.setProperty(&quot;bootstrap.servers&quot;, &quot;localhost:9092&quot;);
    properties.setProperty(&quot;key.serializer&quot;, &quot;org.apache.kafka.common.serialization.StringSerializer&quot;);
    properties.setProperty(&quot;value.serializer&quot;, &quot;org.apache.kafka.common.serialization.StringSerializer&quot;);
    properties.setProperty(&quot;enable.idempotence&quot;, &quot;true&quot;); // 开启幂等
    properties.setProperty(&quot;transactional.id&quot;, &quot;my-transaction-id&quot;); // 设置事务ID

    KafkaProducer&amp;lt;String, String&amp;gt; producer = new KafkaProducer&amp;lt;&amp;gt;(properties);

    ProducerRecord&amp;lt;String, String&amp;gt; record1 = new ProducerRecord&amp;lt;&amp;gt;(&quot;topic1&quot;, &quot;key1&quot;, &quot;value1&quot;);
    ProducerRecord&amp;lt;String, String&amp;gt; record2 = new ProducerRecord&amp;lt;&amp;gt;(&quot;topic2&quot;, &quot;key2&quot;, &quot;value2&quot;);
    ProducerRecord&amp;lt;String, String&amp;gt; record3 = new ProducerRecord&amp;lt;&amp;gt;(&quot;topic3&quot;, &quot;key3&quot;, &quot;value3&quot;);

    producer.initTransactions(); // 初始化事务（只需执行一次）
    try {
        producer.beginTransaction(); // 开始事务

        // 向多个不同的 topic 写入消息
        producer.send(record1);
        producer.send(record2);
        producer.send(record3);

        producer.commitTransaction(); // 提交事务
    } catch (ProducerFencedException e) {
        producer.close(); // 事务ID 已被占用
    } catch (KafkaException e) {
        producer.abortTransaction();
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;实现-read-process-write-模式&quot;&gt;实现 read-process-write 模式&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    final String groupID = &quot;my-group-id&quot;;

    Properties producerProps = new Properties();
    producerProps.setProperty(&quot;bootstrap.servers&quot;, &quot;localhost:9092&quot;);
    producerProps.setProperty(&quot;key.serializer&quot;, &quot;org.apache.kafka.common.serialization.StringSerializer&quot;);
    producerProps.setProperty(&quot;value.serializer&quot;, &quot;org.apache.kafka.common.serialization.StringSerializer&quot;);
    producerProps.setProperty(&quot;enable.idempotence&quot;, &quot;true&quot;); // 开启幂等
    producerProps.setProperty(&quot;transactional.id&quot;, &quot;my-transaction-id&quot;); // 设置事务ID

    Properties consumerProps = new Properties();
    consumerProps.setProperty(&quot;bootstrap.servers&quot;, &quot;localhost:9092&quot;);
    consumerProps.setProperty(&quot;key.deserializer&quot;, &quot;org.apache.kafka.common.serialization.StringDeserializer&quot;);
    consumerProps.setProperty(&quot;value.deserializer&quot;, &quot;org.apache.kafka.common.serialization.StringDeserializer&quot;);
    consumerProps.setProperty(&quot;isolation.level&quot;,&quot;read_committed&quot;); // 设置隔离级别
    consumerProps.setProperty(&quot;group.id&quot;, groupID); // 设置消费者组群ID

    KafkaProducer&amp;lt;String, String&amp;gt; producer = new KafkaProducer&amp;lt;&amp;gt;(producerProps);
    KafkaConsumer&amp;lt;String, String&amp;gt; consumer = new KafkaConsumer&amp;lt;&amp;gt;(consumerProps);

    producer.initTransactions();
    consumer.subscribe(Collections.singletonList(&quot;ping&quot;));

    while (true) {
        
        ConsumerRecords&amp;lt;String, String&amp;gt; records = consumer.poll(Long.MAX_VALUE); // 读取消息
        
        try {
            producer.beginTransaction(); // 开启事务

            // 处理消息（可以是任意业务场景）
            Map&amp;lt;TopicPartition, OffsetAndMetadata&amp;gt; offsets = new HashMap&amp;lt;&amp;gt;();
            for(ConsumerRecord&amp;lt;String, String&amp;gt; record : records){
                offsets.put(new TopicPartition(record.topic(), record.partition()), new OffsetAndMetadata(record.offset())); // 记录消费偏移量
                producer.send(new ProducerRecord&amp;lt;&amp;gt;(&quot;pong&quot;, record.value())); // 发送消息
            }

            producer.sendOffsetsToTransaction(offsets, groupID); // 提交消费偏移量
            producer.commitTransaction(); // 事务提交
        } catch (ProducerFencedException e) {
            producer.close(); // 事务ID 已被占用
        } catch (Exception e){
            producer.abortTransaction(); // 回滚事务
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;br/&gt;&lt;h3 id=&quot;参考资料&quot;&gt;参考资料&lt;/h3&gt;
</description>
<pubDate>Thu, 31 Dec 2020 16:24:00 +0000</pubDate>
<dc:creator>buttercup</dc:creator>
<og:description>使用方式 KafkaProducer 发送消息主要有以下 3 种方式： Properties properties = new Properties(); properties.setProperty</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/buttercup/p/14201153.html</dc:identifier>
</item>
<item>
<title>容器编排系统K8s之访问控制--RBAC授权 - Linux-1874</title>
<link>http://www.cnblogs.com/qiuhom-1874/p/14216634.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qiuhom-1874/p/14216634.html</guid>
<description>&lt;p&gt;　　前文我们了解了k8s上的访问控制机制，主要对访问控制中的第一关用户认证做了相关说明以及常规用户的配置文件的制作，回顾请参考：&lt;a href=&quot;https://www.cnblogs.com/qiuhom-1874/p/14207381.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/qiuhom-1874/p/14207381.html&lt;/a&gt;；今天我们来了解下k8s上的访问控制第二关RBAC授权相关话题；&lt;/p&gt;
&lt;p&gt;　　在k8s上授权的机制有很多，最常用的有ABAC和RBAC；ABAC（attribute based access control）这种是基于属性做访问控制；RBAC（role based access control）这种是基于角色做访问控制；所谓基于属性做访问控制是指，对k8s上的资源的某种属性做授权，授权给相关用户对该资源的某个属性有什么权限；同样的逻辑基于角色做访问控制就是指把k8s上的资源，授权给对应角色有什么权限；那角色和用户有什么关系呢？对于RBAC授权模型来说，在k8s上用户是没法直接关联资源；它是通过角色对象来实现对资源的授权；用户授权是通过角色绑定对象来关联到对应角色；只要用户绑定到对应角色，那么该用户就拥有绑定角色上的所有权限；比如，在k8s上有一个角色名为pod-reader，这个角色能够对default名称空间下的pod资源有只读权限；对其他名称空间任何资源没有任何权限；如果一个用户绑定到该角色上，对应用户就有对default名称空间下的pod资源拥有只读权限，对其他名称空间任何资源没有任何权限；对于k8s上的资源来说，资源有两个级别，一个是名称空间级别的资源，一个是集群级别的资源；比如pod，svc，pvc等等这些资源都是名称空间级别资源，它们的存在必须是在某个名称空间下；对于类似像pv，node，ns这些资源就是集群级别资源，它们的存在不依赖任何名称空间；这样一来对于角色而言就有名称空间级别的角色，也有集群级别角色；名称空间级别的角色就是用来定义特定名称空间下的资源权限，集群级别角色就是用来定义整个集群上的资源权限；在k8s上这两种角色分别叫role和clusterrole；role和clusterrole都是k8s上的资源，我们要给某个用户授权，首先把对应角色资源实例化为一个角色对象，然后把用户和角色对象绑定起来即可；用户怎么绑定到角色上呢？在k8s上绑定这个操作也是通过资源对象实现的；绑定也有两种，一种是rolebinding，一种是clusterrolebinding；rolebinding是名称空间级别资源，它主要用来把对应用户和对应名称空间上的角色（role）做绑定；对应用户就能拥有对应角色在对应名称空间下对应资源的权限；clusterrolebinding主要用来把用户绑定到集群级别角色（clusterrole）上，对应用户就能拥有对整个集群上的对应角色拥有的对应资源的权限；简单讲角色(role/clusterrole)就是用来定义资源的权限，rolebinding和clusterrolebinding是用来关联用户和角色的关系；如下图所示；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202012/1503305-20201231184927478-1677316515.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：这里需要注意一点，clusterrole是包含名称空间级别的role；也就是说clusterrole既可以用clusterrolebinding来绑定，也可以用rolebinding来绑定，如果rolebinding绑定的是一个集群级别的角色（clusterrole）那么对应绑定至clusterrole的用户的权限就会缩小到对应名称空间下，而非整个集群，原因是rolebinding是名称空间级别资源；&lt;/p&gt;
&lt;p&gt; 　　查看apiserver启用授权插件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202012/1503305-20201231190823112-2051955047.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：apiserver配置启用RBAC插件需要用--authorization-mode选项来指定对应启用的授权插件，在k8s1.6以后的版本，默认apiserver会启用Node和RBAC授权插件；&lt;/p&gt;
&lt;p&gt;　　创建角色&lt;/p&gt;
&lt;p&gt;　　使用陈述时命令create，创建角色的语法格式&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
Usage:
  kubectl create role NAME --verb=verb --resource=resource.group/subresource
[--resource-name=resourcename] [--dry-run=server|client|none] [options]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：以上create role表示创建的是名称空间级别的角色，如果没有指定其名称空间表示默认名称空间；--verb是用来指定对应的权限，比如get，list，watch等等；--resource使用来指定资源资源类型，比如pods，services，daemonsets，replicasets等等；--resource-name用来指定对应具体的资源的名称；如果要指定名称空间使用-n选项指定即可；默认不指定表示default名称空间；&lt;/p&gt;
&lt;p&gt;　　示例：使用陈述时命令创建名为pod-reader的角色，该角色拥有对default名称空间下的pod资源有list，get和watch权限；&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl create role pod-reader --verb=list --verb=get --verb=watch --resource=pods 
role.rbac.authorization.k8s.io/pod-reader created
[root@master01 ~]# kubectl get role
NAME         CREATED AT
pod-reader   2020-12-31T11:27:39Z
[root@master01 ~]# kubectl describe role pod-reader
Name:         pod-reader
Labels:       &amp;lt;none&amp;gt;
Annotations:  &amp;lt;none&amp;gt;
PolicyRule:
  Resources  Non-Resource URLs  Resource Names  Verbs
  ---------  -----------------  --------------  -----
  pods       []                 []              [list get watch]
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：可以看到pod-reader角色对pods资源有list,get，watch权限；&lt;/p&gt;
&lt;p&gt;　　使用陈述式命令创建clusterrole&lt;/p&gt;
&lt;p&gt;　　命令使用语法格式&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
Usage:
  kubectl create clusterrole NAME --verb=verb --resource=resource.group
[--resource-name=resourcename] [--dry-run=server|client|none] [options]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：使用语法和创建名称空间级别的角色一样，不同的是指定创建的是clusterrole；&lt;/p&gt;
&lt;p&gt;　　示例：创建一个名为cluster-pods-reader角色，拥有对集群所有名称空间下的pods和servers资源有get，list，watch权限；&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl create clusterrole cluster-pods-reader --verb=get --verb=list --verb=watch --resource=pods --resource=services
clusterrole.rbac.authorization.k8s.io/cluster-pods-reader created
[root@master01 ~]# kubectl get clusterrole cluster-pods-reader
NAME                  CREATED AT
cluster-pods-reader   2020-12-31T11:35:03Z
[root@master01 ~]# kubectl describe clusterrole cluster-pods-reader
Name:         cluster-pods-reader
Labels:       &amp;lt;none&amp;gt;
Annotations:  &amp;lt;none&amp;gt;
PolicyRule:
  Resources  Non-Resource URLs  Resource Names  Verbs
  ---------  -----------------  --------------  -----
  pods       []                 []              [get list watch]
  services   []                 []              [get list watch]
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：可以看到cluster-pods-reader角色有对pods资源和services资源有get,list,watch权限；&lt;/p&gt;
&lt;p&gt;　　创建rolebinding&lt;/p&gt;
&lt;p&gt;　　命令语法格式&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
Usage:
  kubectl create rolebinding NAME --clusterrole=NAME|--role=NAME [--user=username]
[--group=groupname] [--serviceaccount=namespace:serviceaccountname] [--dry-run=server|client|none]
[options]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：创建rolebinding需要指定对应的名称，指定clusterrole或者role角色的名称，指定对应的用户名称，或者对应的组名；如果对应用户是sa账号，需要用--serviceaccount选项来指定对应sa的名称；sa的名称由名称空间：sa名称；如果要指定名称空间使用-n选项指定即可；默认不指定表示default名称空间；&lt;/p&gt;
&lt;p&gt;　　示例：创建名为tom-pods-reader的rolebinding，其中指定对应tom用户绑定至pod-reader角色&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl create rolebinding  tom-pods-reader --role=pod-reader --user=tom 
rolebinding.rbac.authorization.k8s.io/tom-pods-reader created
[root@master01 ~]# kubectl get rolebinding
NAME              ROLE              AGE
tom-pods-reader   Role/pod-reader   5s
[root@master01 ~]# kubectl describe rolebinding tom-pods-reader
Name:         tom-pods-reader
Labels:       &amp;lt;none&amp;gt;
Annotations:  &amp;lt;none&amp;gt;
Role:
  Kind:  Role
  Name:  pod-reader
Subjects:
  Kind  Name  Namespace
  ----  ----  ---------
  User  tom   
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示；这里没有显示名称空间是那个名称空间；默认没有显示就是default名称空间；&lt;/p&gt;
&lt;p&gt;　　验证：使用tom用户的配置文件，看看是否可以列出default名称空间下的pod列表呢？&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl config view --kubeconfig=/tmp/myk8s.config
apiVersion: v1
clusters:
- cluster:
    certificate-authority-data: DATA+OMITTED
    server: https://192.168.0.41:6443
  name: myk8s
contexts:
- context:
    cluster: myk8s
    user: tom
  name: tom@myk8s
current-context: tom@myk8s
kind: Config
preferences: {}
users:
- name: tom
  user:
    client-certificate-data: REDACTED
    client-key-data: REDACTED
    username: tom
[root@master01 ~]# kubectl get pod --kubeconfig=/tmp/myk8s.config    
NAME             READY   STATUS    RESTARTS   AGE
nginx-pod-demo   1/1     Running   1          44h
web-0            1/1     Running   2          2d21h
web-1            1/1     Running   2          2d21h
web-2            1/1     Running   2          2d21h
web-3            1/1     Running   3          2d21h
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：可以看到使用tom用户的配置文件，使用kubectl工具加载对应配置文件，在default名称空间下是可以正常列出pod列表；&lt;/p&gt;
&lt;p&gt;　　验证：使用tom用户的配置文件看看是否列出kube-system名称空间下的pod列表呢？&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl get pod -n kube-system --kubeconfig=/tmp/myk8s.config 
Error from server (Forbidden): pods is forbidden: User &quot;tom&quot; cannot list resource &quot;pods&quot; in API group &quot;&quot; in the namespace &quot;kube-system&quot;
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：可以看到对应tom用户是没有权限列出kube-system名称空间下的pod资源；&lt;/p&gt;
&lt;p&gt;　　创建clusterrolebinding&lt;/p&gt;
&lt;p&gt;　　命令使用语法格式&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
Usage:
  kubectl create clusterrolebinding NAME --clusterrole=NAME [--user=username] [--group=groupname]
[--serviceaccount=namespace:serviceaccountname] [--dry-run=server|client|none] [options]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：使用方式和创建rolebinding一样，不同的是clusterrolebinding不能关联role角色；&lt;/p&gt;
&lt;p&gt;　　示例：创建名为tom-all-pod-reader的clusterrolebinding，并关联cluster-pods-reader角色和tom用户；&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl create clusterrolebinding tom-all-pod-reader --clusterrole=cluster-pods-reader --user=tom
clusterrolebinding.rbac.authorization.k8s.io/tom-all-pod-reader created
[root@master01 ~]# kubectl get clusterrolebinding tom-all-pod-reader
NAME                 ROLE                              AGE
tom-all-pod-reader   ClusterRole/cluster-pods-reader   20s
[root@master01 ~]# kubectl describe clusterrolebinding tom-all-pod-reader
Name:         tom-all-pod-reader
Labels:       &amp;lt;none&amp;gt;
Annotations:  &amp;lt;none&amp;gt;
Role:
  Kind:  ClusterRole
  Name:  cluster-pods-reader
Subjects:
  Kind  Name  Namespace
  ----  ----  ---------
  User  tom   
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　验证：使用tom用户的配置文件查看kube-system名称空间下的pod资源列表&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl get pod -n kube-system --kubeconfig=/tmp/myk8s.config 
NAME                                       READY   STATUS    RESTARTS   AGE
coredns-7f89b7bc75-k9gdt                   1/1     Running   18         23d
coredns-7f89b7bc75-kp855                   1/1     Running   16         23d
etcd-master01.k8s.org                      1/1     Running   22         23d
kube-apiserver-master01.k8s.org            1/1     Running   17         23d
kube-controller-manager-master01.k8s.org   1/1     Running   19         23d
kube-flannel-ds-cx8d5                      1/1     Running   20         23d
kube-flannel-ds-jz6r4                      1/1     Running   11         12d
kube-flannel-ds-ndzl6                      1/1     Running   21         23d
kube-flannel-ds-rjtn9                      1/1     Running   23         23d
kube-flannel-ds-zgq92                      1/1     Running   20         23d
kube-proxy-cr8j8                           1/1     Running   13         11d
kube-proxy-h8fzw                           1/1     Running   8          11d
kube-proxy-jfzfh                           1/1     Running   9          11d
kube-proxy-rq8wl                           1/1     Running   8          11d
kube-proxy-sj72v                           1/1     Running   8          11d
kube-scheduler-master01.k8s.org            1/1     Running   19         23d
[root@master01 ~]# kubectl get pod  --kubeconfig=/tmp/myk8s.config               
NAME             READY   STATUS    RESTARTS   AGE
nginx-pod-demo   1/1     Running   1          44h
web-0            1/1     Running   2          2d21h
web-1            1/1     Running   2          2d21h
web-2            1/1     Running   2          2d21h
web-3            1/1     Running   3          2d22h
[root@master01 ~]# kubectl get svc --kubeconfig=/tmp/myk8s.config
NAME         TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE
kubernetes   ClusterIP   10.96.0.1    &amp;lt;none&amp;gt;        443/TCP   3d1h
nginx        ClusterIP   None         &amp;lt;none&amp;gt;        80/TCP    3d
[root@master01 ~]# kubectl get svc -n kube-system --kubeconfig=/tmp/myk8s.config
NAME       TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)                  AGE
kube-dns   ClusterIP   10.96.0.10   &amp;lt;none&amp;gt;        53/UDP,53/TCP,9153/TCP   23d
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：可以看到把tom用户用clusterrolebinding关联到对应clusterrole角色上，就拥有对应角色上的权限；&lt;/p&gt;
&lt;p&gt;　　验证：使用tom用户的配置文件查看pv或node集群级别资源，看看是否可以正常列出？&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl get pv --kubeconfig=/tmp/myk8s.config
Error from server (Forbidden): persistentvolumes is forbidden: User &quot;tom&quot; cannot list resource &quot;persistentvolumes&quot; in API group &quot;&quot; at the cluster scope
[root@master01 ~]# kubectl get node --kubeconfig=/tmp/myk8s.config
Error from server (Forbidden): nodes is forbidden: User &quot;tom&quot; cannot list resource &quot;nodes&quot; in API group &quot;&quot; at the cluster scope
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：使用tom用户的配置文件查看pv和node资源，apiserver直接拒绝了；原因是对应的clusterrole角色上没有查看pv和node的权限；所以对应用户也就没有相应的查看权限；&lt;/p&gt;
&lt;p&gt;　　示例：创建rolebinding，把tom用户关联到clusterrole类型角色cluster-pods-reader&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl create rolebinding tom-rolebinding-clusterrole --clusterrole=cluster-pods-reader --user=tom 
rolebinding.rbac.authorization.k8s.io/tom-rolebinding-clusterrole created
[root@master01 ~]# kubectl get rolebinding
NAME                          ROLE                              AGE
tom-pods-reader               Role/pod-reader                   20m
tom-rolebinding-clusterrole   ClusterRole/cluster-pods-reader   12s
[root@master01 ~]# kubectl describe rolebinding tom-rolebinding-clusterrole
Name:         tom-rolebinding-clusterrole
Labels:       &amp;lt;none&amp;gt;
Annotations:  &amp;lt;none&amp;gt;
Role:
  Kind:  ClusterRole
  Name:  cluster-pods-reader
Subjects:
  Kind  Name  Namespace
  ----  ----  ---------
  User  tom   
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　验证：使用tom用户的配置文件，看看现在tom用户是否还有对应kube-system中的pod资源有列出权限呢？&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl get pods -n kube-system --kubeconfig=/tmp/myk8s.config
NAME                                       READY   STATUS    RESTARTS   AGE
coredns-7f89b7bc75-k9gdt                   1/1     Running   18         23d
coredns-7f89b7bc75-kp855                   1/1     Running   16         23d
etcd-master01.k8s.org                      1/1     Running   22         23d
kube-apiserver-master01.k8s.org            1/1     Running   17         23d
kube-controller-manager-master01.k8s.org   1/1     Running   19         23d
kube-flannel-ds-cx8d5                      1/1     Running   20         23d
kube-flannel-ds-jz6r4                      1/1     Running   11         12d
kube-flannel-ds-ndzl6                      1/1     Running   21         23d
kube-flannel-ds-rjtn9                      1/1     Running   23         23d
kube-flannel-ds-zgq92                      1/1     Running   20         23d
kube-proxy-cr8j8                           1/1     Running   13         11d
kube-proxy-h8fzw                           1/1     Running   8          11d
kube-proxy-jfzfh                           1/1     Running   9          11d
kube-proxy-rq8wl                           1/1     Running   8          11d
kube-proxy-sj72v                           1/1     Running   8          11d
kube-scheduler-master01.k8s.org            1/1     Running   19         23d
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：这里还是能够列出kube-system名称空间下的pod，其原因是我们没有删除之前的clusterrolebinding，所以对应tom用户还有对kube-system的权限；&lt;/p&gt;
&lt;p&gt;　　验证：删除clusterrolebinding tom-all-pod-reader 看看tom用户是否还有对kube-system中的pod列出权限呢？&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl get clusterrolebinding tom-all-pod-reader
NAME                 ROLE                              AGE
tom-all-pod-reader   ClusterRole/cluster-pods-reader   14m
[root@master01 ~]# kubectl delete clusterrolebinding tom-all-pod-reader
clusterrolebinding.rbac.authorization.k8s.io &quot;tom-all-pod-reader&quot; deleted
[root@master01 ~]# kubectl get rolebinding
NAME                          ROLE                              AGE
tom-pods-reader               Role/pod-reader                   27m
tom-rolebinding-clusterrole   ClusterRole/cluster-pods-reader   7m7s
[root@master01 ~]# kubectl get pods -n kube-system --kubeconfig=/tmp/myk8s.config
Error from server (Forbidden): pods is forbidden: User &quot;tom&quot; cannot list resource &quot;pods&quot; in API group &quot;&quot; in the namespace &quot;kube-system&quot;
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：可以看到此时tom用户就没有对kube-system名称空间下的pod有列出权限了；&lt;/p&gt;
&lt;p&gt;　　验证：使用tom用户的配置文件，查看default名称空间下的pods和service资源，看看是否有权限？&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl get pods  --kubeconfig=/tmp/myk8s.config              
NAME             READY   STATUS    RESTARTS   AGE
nginx-pod-demo   1/1     Running   1          45h
web-0            1/1     Running   2          2d22h
web-1            1/1     Running   2          2d22h
web-2            1/1     Running   2          2d22h
web-3            1/1     Running   3          2d22h
[root@master01 ~]# kubectl get svc  --kubeconfig=/tmp/myk8s.config    
NAME         TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE
kubernetes   ClusterIP   10.96.0.1    &amp;lt;none&amp;gt;        443/TCP   3d1h
nginx        ClusterIP   None         &amp;lt;none&amp;gt;        80/TCP    3d
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：可以看到tom用户在default名称空间下能够正常列出pod和service资源；从上面的示例可以看到当rolebinding绑定的是一个clusterrole，对应clusterrole的权限就会降低至对应rolebinding的名称空间；&lt;/p&gt;
&lt;p&gt;　　使用资源清单创建角色&lt;/p&gt;
&lt;p&gt;　　示例：使用资源清单创建role-demo角色&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# cat role-demo.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: role-demo
  namespace: testing
rules:
- apiGroups: [&quot;&quot;]
  resources: [&quot;pods&quot;,&quot;pods/log&quot;,&quot;services&quot;]
  verbs: [&quot;get&quot;,&quot;list&quot;,&quot;watch&quot;]
  
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：role资源没有spec字段，它的群组是rbac.authorization.k8s.io/v1，对应类型为Role；metadata字段中的name用于指定对应role的名称；namespace用户指定对应的名称空间；roles字段用来描述对资源和权限，该字段为一个列表对象，一个对象必须有apiGroup，resources和verbs字段；其中apiGroup字段用来描述对应资源所属群组，默认不写任何群组表示核心群组v1；如果是匹配所有群组可以写成“*”;该字段是一个列表类型数据，所以必须用中括号将其括起来，即便没有值；resources字段用来描述对应的资源，这里的资源如果可以使用复数形式的必须使用复数形式；所谓复数是指对应资源名称单词的复数形式；该字段也是一个列表，可以使用中括号，也可以直接使用-开头写对应的值；verbs字段用来描述对应的权限，该字段也是一个列表，可以使用中括号或者“-”开头从下一行直接写值的方式；上述资源清单表示创建一个名为role-demo的角色在testing名称空间；对应角色拥有对该名称空间下的pod，pods/log和services资源有get,list,watch权限；&lt;/p&gt;
&lt;p&gt;　　创建名称空间并应用配置清单&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl get ns
NAME              STATUS   AGE
default           Active   23d
ingress-nginx     Active   9d
kube-node-lease   Active   23d
kube-public       Active   23d
kube-system       Active   23d
[root@master01 ~]# kubectl create ns testing
namespace/testing created
[root@master01 ~]# kubectl apply -f role-demo.yaml
role.rbac.authorization.k8s.io/role-demo created
[root@master01 ~]# kubectl get role -n testing
NAME        CREATED AT
role-demo   2020-12-31T12:46:53Z
[root@master01 ~]# kubectl describe role role-demo -n testing
Name:         role-demo
Labels:       &amp;lt;none&amp;gt;
Annotations:  &amp;lt;none&amp;gt;
PolicyRule:
  Resources  Non-Resource URLs  Resource Names  Verbs
  ---------  -----------------  --------------  -----
  pods/log   []                 []              [get list watch]
  pods       []                 []              [get list watch]
  services   []                 []              [get list watch]
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　示例：使用资源清单创建rolebinding&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# cat rolebinding-demo.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: rolebinding-demo
  namespace: testing
roleRef:
  kind: Role
  name: role-demo
  apiGroup: rbac.authorization.k8s.io
subjects:
- kind: User
  apiGroup: rbac.authorization.k8s.io
  name: tom
  
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：使用资源清单创建rolebinding，需要用roleRef字段来指定引用的role或clusterrole，该字段为一个对象，其中kind指定对应角色的类型，Role表示引用名称空间级别的role；ClusterRole表示引用集群级别角色clusterrole；apiGroup是用来描述对应角色的不带版本api群组；subjects字段用来描述对应用户或组，该字段为一个列表对象；其中kind字段用来表示对应的是用户还是用户组；User表示用户，Group表示用户组；ServiceAccount表示是一个sa用户；apiGroup用来指定对应不带版本的api群组；name用来指定用户名或组名或sa名；上述资源清单表示把tom用户和role-demo角色做关联，即授权tom用户拥有role-demo角色的权限；&lt;/p&gt;
&lt;p&gt;　　验证：在未应用资源清单前使用tom用户的配置文件查看testing名称空间下的pod资源&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl get pods -n testing --kubeconfig=/tmp/myk8s.config
Error from server (Forbidden): pods is forbidden: User &quot;tom&quot; cannot list resource &quot;pods&quot; in API group &quot;&quot; in the namespace &quot;testing&quot;
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：在未应用上述资源清单，tom用户对testing名称空间的资源没有任何权限；&lt;/p&gt;
&lt;p&gt;　　应用资源清单&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl apply -f rolebinding-demo.yaml         
rolebinding.rbac.authorization.k8s.io/rolebinding-demo created
[root@master01 ~]# kubectl get rolebinding -n testing
NAME               ROLE             AGE
rolebinding-demo   Role/role-demo   31s
[root@master01 ~]# kubectl describe rolebinding rolebinding-demo -n testing
Name:         rolebinding-demo
Labels:       &amp;lt;none&amp;gt;
Annotations:  &amp;lt;none&amp;gt;
Role:
  Kind:  Role
  Name:  role-demo
Subjects:
  Kind  Name  Namespace
  ----  ----  ---------
  User  tom   
[root@master01 ~]# kubectl get pods -n testing --kubeconfig=/tmp/myk8s.config
No resources found in testing namespace.
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：可以看到应用资源清单以后，再次使用tom用户的配置文件查看testing名称空间下的pod资源，就没有提示没有权限拒绝，只是告诉我们对应名称空间下没有pod资源；&lt;/p&gt;
&lt;p&gt;　　示例：使用资源清单创建clusterrole&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# cat clusterrole-demo.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: clusterrole-demo
rules:
- apiGroups: [&quot;&quot;]
  resources: [&quot;pods&quot;,&quot;nodes&quot;,&quot;PersistentVolume&quot;]
  verbs: [&quot;get&quot;,&quot;list&quot;,&quot;watch&quot;,&quot;create&quot;,&quot;delete&quot;]
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：使用资源清单创建clusterrole和创建role是一样的格式，不同的是对应kind的值不同，不需要指定名称空间；其他的都一样；&lt;/p&gt;
&lt;p&gt;　　应用资源清单&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl apply -f clusterrole-demo.yaml
clusterrole.rbac.authorization.k8s.io/clusterrole-demo created
[root@master01 ~]# kubectl get clusterrole clusterrole-demo
NAME               CREATED AT
clusterrole-demo   2020-12-31T13:23:48Z
[root@master01 ~]# kubectl describe clusterrole clusterrole-demo
Name:         clusterrole-demo
Labels:       &amp;lt;none&amp;gt;
Annotations:  &amp;lt;none&amp;gt;
PolicyRule:
  Resources         Non-Resource URLs  Resource Names  Verbs
  ---------         -----------------  --------------  -----
  PersistentVolume  []                 []              [get list watch create delete]
  nodes             []                 []              [get list watch create delete]
  pods              []                 []              [get list watch create delete]
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　示例：使用资源清单创建clusterrolebinding&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# cat clusterrolebinding.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: clusterrolebinding-demo
roleRef:
  kind: ClusterRole
  name: clusterrole-demo
  apiGroup: rbac.authorization.k8s.io
subjects:
- kind: User
  apiGroup: rbac.authorization.k8s.io
  name: tom
  
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：使用资源清单创建clusterrolebinding和创建rolebinding的格式一样，不同的是创建clusterrolebinding不需要指定名称空间，对应kind值为ClusterRoleBinding；其他字段的使用方式和role一样；上述资源清单表示把tom用户和clusterrole-demo角色做关联；&lt;/p&gt;
&lt;p&gt;　　验证：在没有应用资源清单前使用tom用户的配置文件查看kube-system名称空间下的pod资源&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl get pods -n kube-system --kubeconfig=/tmp/myk8s.config
Error from server (Forbidden): pods is forbidden: User &quot;tom&quot; cannot list resource &quot;pods&quot; in API group &quot;&quot; in the namespace &quot;kube-system&quot;
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：没有应用资源清单前使用tom用户的配置文件查看kube-system名称空间下的pod资源，是被apiserver拒绝的；&lt;/p&gt;
&lt;p&gt;　　应用配置清单&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl apply -f clusterrolebinding.yaml
clusterrolebinding.rbac.authorization.k8s.io/clusterrolebinding-demo created
[root@master01 ~]# kubectl get clusterrolebinding clusterrolebinding-demo
NAME                      ROLE                           AGE
clusterrolebinding-demo   ClusterRole/clusterrole-demo   15s
[root@master01 ~]# kubectl describe clusterrolebinding clusterrolebinding-demo
Name:         clusterrolebinding-demo
Labels:       &amp;lt;none&amp;gt;
Annotations:  &amp;lt;none&amp;gt;
Role:
  Kind:  ClusterRole
  Name:  clusterrole-demo
Subjects:
  Kind  Name  Namespace
  ----  ----  ---------
  User  tom   
[root@master01 ~]# kubectl get pods -n kube-system --kubeconfig=/tmp/myk8s.config           
NAME                                       READY   STATUS    RESTARTS   AGE
coredns-7f89b7bc75-k9gdt                   1/1     Running   18         23d
coredns-7f89b7bc75-kp855                   1/1     Running   16         23d
etcd-master01.k8s.org                      1/1     Running   22         23d
kube-apiserver-master01.k8s.org            1/1     Running   17         23d
kube-controller-manager-master01.k8s.org   1/1     Running   19         23d
kube-flannel-ds-cx8d5                      1/1     Running   20         23d
kube-flannel-ds-jz6r4                      1/1     Running   11         13d
kube-flannel-ds-ndzl6                      1/1     Running   21         23d
kube-flannel-ds-rjtn9                      1/1     Running   23         23d
kube-flannel-ds-zgq92                      1/1     Running   20         23d
kube-proxy-cr8j8                           1/1     Running   13         11d
kube-proxy-h8fzw                           1/1     Running   8          11d
kube-proxy-jfzfh                           1/1     Running   9          11d
kube-proxy-rq8wl                           1/1     Running   8          11d
kube-proxy-sj72v                           1/1     Running   8          11d
kube-scheduler-master01.k8s.org            1/1     Running   19         23d
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：可以看到应用资源清单以后，再使用tom用户的配置文件查看kube-system名称空间下的pod就可以正常列出了，说明对应tom用户授权成功；&lt;/p&gt;
&lt;p&gt;　　查看系统默认的clusterrole&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl get clusterrole
NAME                                                                   CREATED AT
admin                                                                  2020-12-08T06:39:13Z
cluster-admin                                                          2020-12-08T06:39:13Z
cluster-pods-reader                                                    2020-12-31T11:35:03Z
clusterrole-demo                                                       2020-12-31T13:23:48Z
edit                                                                   2020-12-08T06:39:13Z
flannel                                                                2020-12-08T06:59:56Z
kubeadm:get-nodes                                                      2020-12-08T06:39:15Z
nginx-ingress-clusterrole                                              2020-12-21T15:16:13Z
system:aggregate-to-admin                                              2020-12-08T06:39:13Z
system:aggregate-to-edit                                               2020-12-08T06:39:13Z
system:aggregate-to-view                                               2020-12-08T06:39:13Z
system:auth-delegator                                                  2020-12-08T06:39:13Z
system:basic-user                                                      2020-12-08T06:39:13Z
system:certificates.k8s.io:certificatesigningrequests:nodeclient       2020-12-08T06:39:13Z
system:certificates.k8s.io:certificatesigningrequests:selfnodeclient   2020-12-08T06:39:13Z
system:certificates.k8s.io:kube-apiserver-client-approver              2020-12-08T06:39:13Z
system:certificates.k8s.io:kube-apiserver-client-kubelet-approver      2020-12-08T06:39:13Z
system:certificates.k8s.io:kubelet-serving-approver                    2020-12-08T06:39:13Z
system:certificates.k8s.io:legacy-unknown-approver                     2020-12-08T06:39:13Z
system:controller:attachdetach-controller                              2020-12-08T06:39:13Z
system:controller:certificate-controller                               2020-12-08T06:39:13Z
system:controller:clusterrole-aggregation-controller                   2020-12-08T06:39:13Z
system:controller:cronjob-controller                                   2020-12-08T06:39:13Z
system:controller:daemon-set-controller                                2020-12-08T06:39:13Z
system:controller:deployment-controller                                2020-12-08T06:39:13Z
system:controller:disruption-controller                                2020-12-08T06:39:13Z
system:controller:endpoint-controller                                  2020-12-08T06:39:13Z
system:controller:endpointslice-controller                             2020-12-08T06:39:13Z
system:controller:endpointslicemirroring-controller                    2020-12-08T06:39:13Z
system:controller:expand-controller                                    2020-12-08T06:39:13Z
system:controller:generic-garbage-collector                            2020-12-08T06:39:13Z
system:controller:horizontal-pod-autoscaler                            2020-12-08T06:39:13Z
system:controller:job-controller                                       2020-12-08T06:39:13Z
system:controller:namespace-controller                                 2020-12-08T06:39:13Z
system:controller:node-controller                                      2020-12-08T06:39:13Z
system:controller:persistent-volume-binder                             2020-12-08T06:39:13Z
system:controller:pod-garbage-collector                                2020-12-08T06:39:13Z
system:controller:pv-protection-controller                             2020-12-08T06:39:13Z
system:controller:pvc-protection-controller                            2020-12-08T06:39:13Z
system:controller:replicaset-controller                                2020-12-08T06:39:13Z
system:controller:replication-controller                               2020-12-08T06:39:13Z
system:controller:resourcequota-controller                             2020-12-08T06:39:13Z
system:controller:root-ca-cert-publisher                               2020-12-08T06:39:13Z
system:controller:route-controller                                     2020-12-08T06:39:13Z
system:controller:service-account-controller                           2020-12-08T06:39:13Z
system:controller:service-controller                                   2020-12-08T06:39:13Z
system:controller:statefulset-controller                               2020-12-08T06:39:13Z
system:controller:ttl-controller                                       2020-12-08T06:39:13Z
system:coredns                                                         2020-12-08T06:39:15Z
system:discovery                                                       2020-12-08T06:39:13Z
system:heapster                                                        2020-12-08T06:39:13Z
system:kube-aggregator                                                 2020-12-08T06:39:13Z
system:kube-controller-manager                                         2020-12-08T06:39:13Z
system:kube-dns                                                        2020-12-08T06:39:13Z
system:kube-scheduler                                                  2020-12-08T06:39:13Z
system:kubelet-api-admin                                               2020-12-08T06:39:13Z
system:monitoring                                                      2020-12-08T06:39:13Z
system:node                                                            2020-12-08T06:39:13Z
system:node-bootstrapper                                               2020-12-08T06:39:13Z
system:node-problem-detector                                           2020-12-08T06:39:13Z
system:node-proxier                                                    2020-12-08T06:39:13Z
system:persistent-volume-provisioner                                   2020-12-08T06:39:13Z
system:public-info-viewer                                              2020-12-08T06:39:13Z
system:service-account-issuer-discovery                                2020-12-08T06:39:13Z
system:volume-scheduler                                                2020-12-08T06:39:13Z
view                                                                   2020-12-08T06:39:13Z
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：以system开头的都是系统默认创建的clusterrole角色；这些角色都是用来给对应组件授权用的，比如，system:kube-dns就是用来给kube-dns这个pod在apiserver上验证授权需要使用的角色；system:kube-controller-manager这个角色就是用来kube-controller-manager这个pod在apiserver上拥有的权限；kube-controller-manager这个pod向apiserver验证时，首先把对应的证书发送给apiserver，apiserver通过识别对应证书中CN的名字来确定对应的用户名；如果对应用户名是system:kube-controller-manager，那么对应kube-controller-manager这个pod就拥有对应该角色的所有权限；如果我们手动部署的k8s集群，对应controller-manager的证书中CN名称不是system:kube-controller-manager，那么我们手动部署的k8s集群将不能正常工作，对于其他组件也是类似的逻辑；除了内置了以system开头的很多clusterrole，k8s为了方便我们授权，它还内置了4个特殊的clusterrole，分别是cluster-admin，admin,edit和view；其中cluster-admin是拥有对整个集群的所有资源拥有所有权限，默认这个角色被clusterrolebinding绑定在system:master这个组上；对应kuberctl使用的证书文件中O的信息就是system:master，所以我们使用kubectl加载默认的配置文件可以操作整个集群上的所有资源；admin角色也是一个管理员权限，不同于cluster-admin，admin角色一般用于通过rolebinding来实现对特有名称空间的管理员授权；edit和view也是类似的逻辑，主要用于通过rolebinding来实现特有名称空间下的特定管理员；比如快速授权某个用户在某个名称空间下拥有只读权限，那么我们就可以把对应用户通过rolebinding将其绑定至view这个clusterrole角色上；如果只允许某个用户拥有对应名称空间下的所有资源的修改权限，就可以把对应用户通过rolebinding绑定到edit这个clusterrole角色上；当然以上几个角色也可以通过clusterrolebinding来绑定，用clusterrolebinding来绑定，对应用户就是对应整个集群的所有资源；有了上述4个内置的clusterrole，我们就可以快速的将某个用户授权为特定的角色：&lt;/p&gt;
&lt;p&gt;　　查看kubectl默认证书中的信息&lt;/p&gt;
&lt;p&gt;　　复制配置文件中的client-certificate-data 对应的被base64编码处理过的信息，然后通过base64 -d将其解密，然后使用openssl x509  -text -noout 来查看对应证书中的信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202012/1503305-20201231233818512-767748455.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：可以看到当前kubectl的证书中O=system:master CN=kubernetes-admin；之所以kubectl能够管理集群资源是因为对应证书中的O=system:master，该信息直接对应k8s上的集群角色cluster-admin；对应集群角色就是通过clusterrolebinding绑定到system:master组；所以kubectl就拥有对k8s整个集群资源的管控；&lt;/p&gt;
&lt;p&gt;　　示例：授权tom用户为集群管理员&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# cat tom-clusterrolebinding-cluster-admin.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: tom-cluster-admin
roleRef:
  kind: ClusterRole
  name: cluster-admin
  apiGroup: rbac.authorization.k8s.io
subjects:
- kind: User
  apiGroup: rbac.authorization.k8s.io
  name: tom
  
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：上述资源表示通过clusterrolebinding授权tom用户拥有cluster-admin角色的所有权限，即集群管理员；&lt;/p&gt;
&lt;p&gt;　　应用资源清单&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl apply -f tom-clusterrolebinding-cluster-admin.yaml
clusterrolebinding.rbac.authorization.k8s.io/tom-cluster-admin created
[root@master01 ~]# kubectl get clusterrolebinding tom-cluster-admin
NAME                ROLE                        AGE
tom-cluster-admin   ClusterRole/cluster-admin   21s
[root@master01 ~]# kubectl describe clusterrolebinding tom-cluster-admin
Name:         tom-cluster-admin
Labels:       &amp;lt;none&amp;gt;
Annotations:  &amp;lt;none&amp;gt;
Role:
  Kind:  ClusterRole
  Name:  cluster-admin
Subjects:
  Kind  Name  Namespace
  ----  ----  ---------
  User  tom   
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　验证：使用tom用户的配置文件，管理集群资源&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl get all --kubeconfig=/tmp/myk8s.config
NAME                 READY   STATUS    RESTARTS   AGE
pod/nginx-pod-demo   1/1     Running   1          47h
pod/web-0            1/1     Running   2          3d
pod/web-1            1/1     Running   2          3d
pod/web-2            1/1     Running   2          3d
pod/web-3            1/1     Running   3          3d

NAME                 TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE
service/kubernetes   ClusterIP   10.96.0.1    &amp;lt;none&amp;gt;        443/TCP   3d3h
service/nginx        ClusterIP   None         &amp;lt;none&amp;gt;        80/TCP    3d3h

NAME                   READY   AGE
statefulset.apps/web   4/4     3d3h
[root@master01 ~]# kubectl delete all --all  --kubeconfig=/tmp/myk8s.config
pod &quot;nginx-pod-demo&quot; deleted
pod &quot;web-0&quot; deleted
pod &quot;web-1&quot; deleted
pod &quot;web-2&quot; deleted
pod &quot;web-3&quot; deleted
service &quot;kubernetes&quot; deleted
service &quot;nginx&quot; deleted
statefulset.apps &quot;web&quot; deleted
[root@master01 ~]# kubectl apply -f statefulset-demo.yaml 
service/nginx created
statefulset.apps/web created
[root@master01 ~]# kubectl get all --kubeconfig=/tmp/myk8s.config          
NAME        READY   STATUS    RESTARTS   AGE
pod/web-0   1/1     Running   0          9s
pod/web-1   1/1     Running   0          6s
pod/web-2   1/1     Running   0          4s

NAME                 TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE
service/kubernetes   ClusterIP   10.96.0.1    &amp;lt;none&amp;gt;        443/TCP   85s
service/nginx        ClusterIP   None         &amp;lt;none&amp;gt;        80/TCP    9s

NAME                   READY   AGE
statefulset.apps/web   3/3     9s
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：可以看到我们使用tom用户的配置文件和默认配置文件是一样的效果，瞬间tom用户就变成了集群管理；&lt;/p&gt;
&lt;p&gt;　　删除tom-cluster-admin这个clusterrolebinding&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl delete -f tom-clusterrolebinding-cluster-admin.yaml 
clusterrolebinding.rbac.authorization.k8s.io &quot;tom-cluster-admin&quot; deleted
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　授权tom用户只读ingress-nginx名称空间下的所有资源&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# cat tom-ingress-nginx-view.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: tom-ingress-nginx-view
  namespace: ingress-nginx
roleRef:
  kind: ClusterRole
  name: view
  apiGroup: rbac.authorization.k8s.io
subjects:
- kind: User
  apiGroup: rbac.authorization.k8s.io
  name: tom
  
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：上述配置表示通过ingress-nginx名称 空间下的rolebinding把tom用户绑定至view这个clusterrole上；即对应tom用户对ingress-nginx名称空间下的所有资源只有只读权限；&lt;/p&gt;
&lt;p&gt;　　应用资源配置清单&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl apply -f tom-ingress-nginx-view.yaml
rolebinding.rbac.authorization.k8s.io/tom-ingress-nginx-view created
[root@master01 ~]# kubectl get rolebinding -n ingress-nginx
NAME                              ROLE                      AGE
nginx-ingress-role-nisa-binding   Role/nginx-ingress-role   9d
tom-ingress-nginx-view            ClusterRole/view          22s
[root@master01 ~]# kubectl describe rolebinding tom-ingress-nginx-view -n ingress-nginx
Name:         tom-ingress-nginx-view
Labels:       &amp;lt;none&amp;gt;
Annotations:  &amp;lt;none&amp;gt;
Role:
  Kind:  ClusterRole
  Name:  view
Subjects:
  Kind  Name  Namespace
  ----  ----  ---------
  User  tom   
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　验证：使用tom用户的配置文件管理ingress-nginx名称空间下的资源&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl get pods -n ingress-nginx --kubeconfig=/tmp/myk8s.config             
NAME                                        READY   STATUS    RESTARTS   AGE
nginx-ingress-controller-5466cb8999-dzn5d   1/1     Running   0          33s
[root@master01 ~]# kubectl get pods --kubeconfig=/tmp/myk8s.config
Error from server (Forbidden): pods is forbidden: User &quot;tom&quot; cannot list resource &quot;pods&quot; in API group &quot;&quot; in the namespace &quot;default&quot;
[root@master01 ~]# kubectl delete pod nginx-ingress-controller-5466cb8999-dzn5d -n ingress-nginx --kubeconfig=/tmp/myk8s.config
Error from server (Forbidden): pods &quot;nginx-ingress-controller-5466cb8999-dzn5d&quot; is forbidden: User &quot;tom&quot; cannot delete resource &quot;pods&quot; in API group &quot;&quot; in the namespace &quot;ingress-nginx&quot;
[root@master01 ~]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：可以看到现在tom用户只能查看ingress-nginx名称空间下的资源，不能查看default名称空间下的资源，其次对ingress-nginx名称空间下的pod资源没有删除权限；&lt;/p&gt;
</description>
<pubDate>Thu, 31 Dec 2020 15:50:00 +0000</pubDate>
<dc:creator>Linux-1874</dc:creator>
<og:description>前文我们了解了k8s上的访问控制机制，主要对访问控制中的第一关用户认证做了相关说明以及常规用户的配置文件的制作，回顾请参考：https://www.cnblogs.com/qiuhom-1874/p/</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qiuhom-1874/p/14216634.html</dc:identifier>
</item>
<item>
<title>【wp】2020XCTF_逆向 - c10udlnk</title>
<link>http://www.cnblogs.com/c10udlnk/p/14214080.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/c10udlnk/p/14214080.html</guid>
<description>&lt;p&gt;前几天的XCTF最后一场终于打完了，三场比赛下来对逆向部分的大概感觉是从第一场的啥都不会做（一道lua+一道apk）到后来的终于能有参与度，至少后两场的题目都是pc逆向，虽然特殊架构但好歹能做（tcl。本文是三场XCTF所有逆向题目的wp（目标）+复现整理。赛中拿到了7/10的flag，很多是跟着队里的大佬做出来的（tqltql），这边就试着独立复现一下，至少打完应该长长记性（&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;1424.0020671167&quot;&gt;
&lt;p&gt;前几天的XCTF最后一场终于打完了，三场比赛下来对逆向部分的大概感觉是从第一场的啥都不会做（一道lua+一道apk）到后来的终于能有参与度，至少后两场的题目都是pc逆向，虽然特殊架构但好歹能做（tcl。&lt;/p&gt;
&lt;p&gt;本文是三场XCTF所有逆向题目的wp+复现整理。赛中拿到了7/10的flag，很多是跟着队里的大佬做出来的（tqltql），这边就试着独立复现一下，至少打完应该长长记性（&lt;/p&gt;
&lt;p&gt;P.S. 不会的题暂时标了【TODO】，等wp出了回来填坑= =&lt;/p&gt;
&lt;p&gt;比赛官网：&lt;a href=&quot;https://huaweictf2020.xctf.org.cn/&quot; target=&quot;_blank&quot;&gt;XCTF高校网络安全专题挑战赛&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;h2 id=&quot;weird_lua【todo】&quot;&gt;Weird_lua【TODO】&lt;/h2&gt;
&lt;p&gt;【TODO】&lt;/p&gt;
&lt;p&gt;lua是第一次接触，.lua文件没法反编译，估计虚拟机被魔改了&lt;/p&gt;
&lt;h2 id=&quot;divination【todo】&quot;&gt;divination【TODO】&lt;/h2&gt;
&lt;p&gt;【TODO】&lt;/p&gt;
&lt;p&gt;apk逻辑没看出来，废了废了&lt;/p&gt;
&lt;hr/&gt;
&lt;h2 id=&quot;mips&quot;&gt;mips&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;真·送分题，可惜当时要上课没来得及抢一血（下午2点放题绝了&lt;/p&gt;
&lt;p&gt;老传统走迷宫&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;mips架构。&lt;/p&gt;
&lt;p&gt;ida反编译以后可以看到&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2183122/202012/2183122-20201230231124279-1769352282.png&quot; alt=&quot;image-20201229125551113&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;v4是我们输入的字符串，很明显是迷宫逻辑，上下左右用wasd走，迷宫存在dword_100111F0里。&lt;/p&gt;
&lt;p&gt;sub_10000744()这个初始函数是用来找起点用的（就是迷宫中3所在的地方，在后面可以看到3其实表示的是当前位置）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2183122/202012/2183122-20201230231124504-254962327.png&quot; alt=&quot;image-20201229125822518&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里也可以看到应该有多个迷宫（dword_10011D10是用来表示第几个迷宫的，且&amp;lt;=2，一个迷宫有225个数）+一个迷宫宽为15=三个迷宫，每个迷宫为15*15。&lt;/p&gt;
&lt;p&gt;然后就是下面的四个函数，随便挑一个出来（比如sub_10000D28()）可以看到&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2183122/202012/2183122-20201230231124727-1266835248.png&quot; alt=&quot;image-20201229130146475&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;很明显是个往右走的函数，3表示当前位置，并把上一个当前位置标为1（可走路径）。并且可以看到终点是4，就是说我们要把每个迷宫从3走到4。&lt;/p&gt;
&lt;p&gt;dump迷宫数组，写脚本打印迷宫：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;aMap=[1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 3, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 3, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0]
for i in range(45):
    for j in range(15):
        if aMap[i*15+j]==0:
            tmp='*'
        elif aMap[i*15+j]==1:
            tmp='.'
        elif aMap[i*15+j]==3:
            tmp='@'
        else:
            tmp='#'
        print(tmp,end='')
    print()
    if i==14 or i==29:
        print()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到打印出了三个迷宫，为了看得清楚所以选用几个特定字符打印。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;.....**********
.....*@*.******
.....*.*.******
.....*.*.******
.....*.*.....**
.....*.*****.**
.....*.*****.**
.....*.*****..*
.....*........*
.....********#*
...............
...............
...............
...............
...............
#sssssssddddddds

..*************
..*@*....******
..*.****.******
..*.****.******
..*..***.....**
..*..*******.**
..*..*******.**
..*..*****....*
..*..*****.**.*
..*..*****.****
..*......*.*..*
..*...........*
..***********#*
...............
...............
#ssssssssssdddddddddds

***************
*@..***********
***.*...*******
***...*.*******
****.**.*******
*..*.**.*******
**...**.*******
*******.*******
*******....****
**********.****
**********.****
**********.****
**********....*
*************.*
*************#*
#ddssddwddssssssdddssssdddss
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;走迷宫，然后把路径拼起来，根据提示转md5，get flag。&lt;/p&gt;
&lt;p&gt;（有个疑惑哈，第二个迷宫理论上说就算是最短路也有多解？是题目出锅了还是我哪里看漏了= =&lt;/p&gt;
&lt;p&gt;（再补一句，题目似乎甚至没要求最短路？？？神奇.jpg&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2183122/202012/2183122-20201230231124929-759532959.png&quot; alt=&quot;image-20201229163439245&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;import hashlib
s=b&quot;sssssssdddddddsssssssssssddddddddddsddssddwddssssssdddssssdddss&quot;
print(&quot;flag{%s}&quot;%hashlib.md5(s).hexdigest())
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;flag{999ea6aa6c365ab43eec2a0f0e5968d5}&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;pypy&quot;&gt;pypy&lt;/h2&gt;
&lt;p&gt;把题目文件拖进ida，搜索字符串能看到&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2183122/202012/2183122-20201230231125153-1161425124.png&quot; alt=&quot;image-20201229164109092&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;猜测是pyinstaller打包的文件。&lt;/p&gt;
&lt;blockquote readability=&quot;4.8666666666667&quot;&gt;
&lt;p&gt;也就是这个题让我突然发现pyinstaller还能打包成elf的，于是比赛结束以后赶紧把之前总结的解包指南更新了：&lt;a href=&quot;https://c10udlnk.top/2020/12/04/reSkillsOn-Pyinstaller-extracted-to-python/&quot; target=&quot;_blank&quot;&gt;RE套路 - 关于pyinstaller打包文件的复原 | c10udlnk_Log&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;走流程解包，得到python源码。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2183122/202012/2183122-20201230231125456-429734910.png&quot; alt=&quot;image-20201229165610468&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看到这种混淆变量名，果断替换成ida style变量名（。&lt;/p&gt;
&lt;p&gt;放一下源码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# uncompyle6 version 3.7.4
# Python bytecode 3.8 (3413)
# Decompiled from: Python 2.7.18 (v2.7.18:8d21aa21f2, Apr 20 2020, 13:25:05) [MSC v.1500 64 bit (AMD64)]
# Warning: this version of Python has problems handling the Python 3 &quot;byte&quot; type in constants properly.

# Embedded file name: main.py
# Compiled at: 1995-09-28 00:18:56
# Size of source mod 2**32: 257 bytes
import random, codecs, sys, time, pygame
from pygame.locals import *
from collections import deque
SCREEN_WIDTH = 600
SCREEN_HEIGHT = 480
SIZE = 20
LINE_WIDTH = 1
flag = 'flag{this is a fake flag}'
SCOPE_X = (0, SCREEN_WIDTH // SIZE - 1)
SCOPE_Y = (2, SCREEN_HEIGHT // SIZE - 1)
FOOD_STYLE_LIST = [(10, (255, 100, 100)), (20, (100, 255, 100)), (30, (100, 100, 255))]
LIGHT = (100, 100, 100)
DARK = (200, 200, 200)
BLACK = (0, 0, 0)
RED = (200, 30, 30)
BGCOLOR = (40, 40, 60)

def print_text(v1, v2, v3, v4, v5, fcolor=(255, 255, 255)):
    v6 = v2.render(v5, True, fcolor)
    v1.blit(v6, (v3, v4))


def init_snake():
    v7 = deque()
    v7.append((2, SCOPE_Y[0]))
    v7.append((1, SCOPE_Y[0]))
    v7.append((0, SCOPE_Y[0]))
    return v7


def create_food(v8):
    v9 = random.randint(SCOPE_X[0], SCOPE_X[1])
    v10 = random.randint(SCOPE_Y[0], SCOPE_Y[1])
    while (v9, v10) in v8:
        v9 = random.randint(SCOPE_X[0], SCOPE_X[1])
        v10 = random.randint(SCOPE_Y[0], SCOPE_Y[1])

    return (
     v9, v10)


def get_food_style():
    return FOOD_STYLE_LIST[random.randint(0, 2)]


DEFAULT_KEY = u'Y\xf3\x02\xc3%\x9a\x820\x0b\xbb%\x7f~;\xd2\xdc'

def rc4(v11, key=DEFAULT_KEY, skip=1024):
    v12 = 0
    v13 = bytearray([v14 for v14 in range(256)])
    v12 = 0
    for v15 in range(256):
        v12 = (v12 + v13[v15] + ord(key[(v15 % len(key))])) % 256
        v16 = v13[v15]
        v17 = v13[v12]
        v13[v15] = v13[v12]
        v13[v12] = v16
    else:
        v12 = 0
        v18 = 0
        v19 = []
        if skip &amp;gt; 0:
            for v15 in range(skip):
                v12 = (v12 + 1) % 256
                v18 = (v18 + v13[v12]) % 256
                v13[v12], v13[v18] = v13[v18], v13[v12]

        for v20 in v11:
            v12 = (v12 + 1) % 256
            v18 = (v18 + v13[v12]) % 256
            v13[v12], v13[v18] = v13[v18], v13[v12]
            v21 = v13[((v13[v12] + v13[v18]) % 256)]
            v19.append(chr(ord(v20) ^ v21))
        else:
            return ''.join(v19)


def func(v22):
    v23 = rc4(v22)
    if v23.encode('utf-8').hex() == '275b39c381c28b701ac3972338456022c2ba06c3b04f5501471c47c38ac380c29b72c3b5c38a7ec2a5c2a0':
        return 'YOU WIN'
    return 'YOU LOSE'


def main():
    pygame.init()
    v24 = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
    pygame.display.set_caption(u'\u8d2a\u5403\u86c7')
    v25 = pygame.font.SysFont('SimHei', 24)
    v26 = pygame.font.Font(None, 72)
    v27, v28 = v26.size('GAME OVER')
    v29 = True
    v30 = init_snake()
    v31 = create_food(v30)
    v32 = get_food_style()
    v33 = (1, 0)
    v34 = True
    v35 = False
    v36 = 0
    v37 = 0.5
    v38 = v37
    v39 = None
    v41 = False
    for v40 in pygame.event.get():
        if v40.type == QUIT:
            sys.exit()
        elif v40.type == KEYDOWN:
            if v40.key == K_RETURN:
                if v34:
                    v35 = True
                    v34 = False
                    v29 = True
                    v30 = init_snake()
                    v31 = create_food(v30)
                    v32 = get_food_style()
                    v33 = (1, 0)
                    v36 = 0
                    v39 = time.time()
            elif v40.key == K_SPACE:
                if not v34:
                    v41 = not v41
            elif v40.key in (K_w, K_UP):
                if v29:
                    v33 = v33[1] or (0, -1)
                    v29 = False
            elif v40.key in (K_s, K_DOWN):
                if v29:
                    v33 = v33[1] or (0, 1)
                    v29 = False
            elif v40.key in (K_a, K_LEFT):
                if v29:
                    if not v33[0]:
                        v33 = (-1, 0)
                        v29 = False
                    elif v40.key in (K_d, K_RIGHT):
                        if v29:
                            if not v33[0]:
                                v33 = (1, 0)
                                v29 = False
        else:
            v24.fill(BGCOLOR)
            for v42 in range(SIZE, SCREEN_WIDTH, SIZE):
                pygame.draw.line(v24, BLACK, (v42, SCOPE_Y[0] * SIZE), (v42, SCREEN_HEIGHT), LINE_WIDTH)
            else:
                for v43 in range(SCOPE_Y[0] * SIZE, SCREEN_HEIGHT, SIZE):
                    pygame.draw.line(v24, BLACK, (0, v43), (SCREEN_WIDTH, v43), LINE_WIDTH)
                else:
                    v44 = v34 or time.time()

            if v44 - v39 &amp;gt; v38 and not v41:
                v29 = True
                v39 = v44
                v45 = (v30[0][0] + v33[0], v30[0][1] + v33[1])
                if v45 == v31:
                    v30.appendleft(v45)
                    v36 += v32[0]
                    v38 = v37 - 0.03 * (v36 // 100)
                    v31 = create_food(v30)
                    v32 = get_food_style()
                else:
                    if SCOPE_X[0] &amp;lt;= v45[0] &amp;lt;= SCOPE_X[1]:
                        if SCOPE_Y[0] &amp;lt;= v45[1] &amp;lt;= SCOPE_Y[1]:
                            if v45 not in v30:
                                v30.appendleft(v45)
                                v30.pop()
                            else:
                                v34 = True
                    if not v34:
                        pygame.draw.rect(v24, v32[1], (v31[0] * SIZE, v31[1] * SIZE, SIZE, SIZE), 0)
                for v46 in v30:
                    pygame.draw.rect(v24, DARK, (v46[0] * SIZE + LINE_WIDTH, v46[1] * SIZE + LINE_WIDTH, SIZE - LINE_WIDTH * 2, SIZE - LINE_WIDTH * 2), 0)
                else:
                    print_text(v24, v25, 30, 7, f&quot;speed: {v36 // 100}&quot;)
                    print_text(v24, v25, 450, 7, f&quot;score: {v36}&quot;)
                    if v36 &amp;gt;= 5192296858534827628530496329220096:
                        v47 = flag
                        print_text(v24, v26, (SCREEN_WIDTH - v27) // 2, (SCREEN_HEIGHT - v28) // 2, func(v47), RED)
                    if v34:
                        if v35:
                            print_text(v24, v26, (SCREEN_WIDTH - v27) // 2, (SCREEN_HEIGHT - v28) // 2, 'GAME OVER', RED)
                    pygame.display.update()


if __name__ == '__main__':
    main()
# okay decompiling main.pyc
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到最后getflag这里（func()）的程序逻辑就一个rc4加密，由rc4的特性可知加密和解密流程相同，故复用程序中的rc4()来得到flag。&lt;/p&gt;
&lt;p&gt;uncompyle反编译出来的源码是python3，但是题目本身的源码是python2，注意编码问题。&lt;/p&gt;
&lt;blockquote readability=&quot;1.9207317073171&quot;&gt;
&lt;p&gt;关于编码问题，可以看：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://pycoders-weekly-chinese.readthedocs.io/en/latest/issue5/unipain.html&quot; target=&quot;_blank&quot;&gt;Unicode之痛 — PyCoder's Weelky CN&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/yangmingxianshen/p/7990102.html&quot; target=&quot;_blank&quot;&gt;关于python2中的unicode和str以及python3中的str和bytes - 明王不动心 - 博客园&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里因为反编译做了转换成python3的处理，所以脚本用python3写。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;DEFAULT_KEY = u'Y\xf3\x02\xc3%\x9a\x820\x0b\xbb%\x7f~;\xd2\xdc'
def rc4(v11, key=DEFAULT_KEY, skip=1024):
    v12 = 0
    v13 = bytearray([v14 for v14 in range(256)])
    v12 = 0
    for v15 in range(256):
        v12 = (v12 + v13[v15] + ord(key[(v15 % len(key))])) % 256
        v16 = v13[v15]
        v17 = v13[v12]
        v13[v15] = v13[v12]
        v13[v12] = v16
    else:
        v12 = 0
        v18 = 0
        v19 = []
        if skip &amp;gt; 0:
            for v15 in range(skip):
                v12 = (v12 + 1) % 256
                v18 = (v18 + v13[v12]) % 256
                v13[v12], v13[v18] = v13[v18], v13[v12]

        for v20 in v11:
            v12 = (v12 + 1) % 256
            v18 = (v18 + v13[v12]) % 256
            v13[v12], v13[v18] = v13[v18], v13[v12]
            v21 = v13[((v13[v12] + v13[v18]) % 256)]
            v19.append(chr(ord(v20) ^ v21))
        else:
            return ''.join(v19)
# def func(v22):
#     v23 = rc4(v22)
#     if v23.encode('utf-8').hex() == '275b39c381c28b701ac3972338456022c2ba06c3b04f5501471c47c38ac380c29b72c3b5c38a7ec2a5c2a0':
#         return 'YOU WIN'
#     return 'YOU LOSE'

# -=-=-=以上所有为源码中原函数-=-=-=

cipher='275b39c381c28b701ac3972338456022c2ba06c3b04f5501471c47c38ac380c29b72c3b5c38a7ec2a5c2a0'
flag=bytes.fromhex(cipher).decode('utf-8')
print(rc4(flag))
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2183122/202012/2183122-20201230231125746-1136159797.png&quot; alt=&quot;image-20201229190337791&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;flag{snake_bao_is_really_lucky}&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;print【todo】&quot;&gt;print【TODO】&lt;/h2&gt;
&lt;p&gt;【TODO】&lt;/p&gt;
&lt;p&gt;这个题感觉大概知道怎么做，但就是不会啊（等wp...&lt;/p&gt;
&lt;p&gt;贴一下当时的想法，看了看逻辑只有sprintf这种函数，除此以外没有别的可以改写内存数据的操作了。&lt;/p&gt;
&lt;p&gt;动态调试跟了一下，猜测是sprintf格式化字符串漏洞写入？&lt;/p&gt;
&lt;blockquote readability=&quot;0.093333333333333&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://codearcana.com/posts/2013/05/02/introduction-to-format-string-exploits.html&quot; target=&quot;_blank&quot;&gt;Introduction to format string exploits&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/liufang/p/3741943.html&quot; target=&quot;_blank&quot;&gt;sprintf - stm32学习中 - 博客园&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;pwn太菜了还没搞懂要怎么往output那里写（虽然这是逆向题orz&lt;/p&gt;
&lt;p&gt;setup函数那里有一些format的初始化，主要是loop()那里，控制input（输入的字符串，全部为可见字符且长度&amp;gt;11），来改变使得output!=原来的output且output-1==48('0')。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2183122/202012/2183122-20201230231125990-1063553916.png&quot; alt=&quot;img&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;难得有一场ak逆向了！（虽然有大佬带着&lt;/p&gt;
&lt;p&gt;有三道题都是卡着四血交，实惨TAT&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;re123&quot;&gt;re123&lt;/h2&gt;
&lt;p&gt;用file命令可以看到是MS Windows HtmlHelp Data文件（即.chm），查看文件头也可以知道。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2183122/202012/2183122-20201230231126206-279751838.png&quot; alt=&quot;image-20201229191137544&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2183122/202012/2183122-20201230231126412-1040493664.png&quot; alt=&quot;image-20201229191253926&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以添加后缀名.chm。&lt;/p&gt;
&lt;p&gt;关于chm文件有一个常用的反编译器ChmDecompiler，可以释放CHM里面的全部源文件（包括网页、文本、图片、CHM、ZIP、EXE等全部源文件），并且完美地恢复源文件的全部目录结构 &lt;s&gt;（摘抄的简介&lt;/s&gt;。&lt;/p&gt;
&lt;p&gt;所以用ChmDecompiler打开re.chm，解压缩，可以看到目录下出现一个包含四个文件的文件夹（其实源文件只有三个，.hhp是ChmDecompiler自动生成的）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2183122/202012/2183122-20201230231126694-1687417192.png&quot; alt=&quot;image-20201229191554582&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一个一个翻可以看到doc.htm里有一段奇怪的Item1。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2183122/202012/2183122-20201230231127053-779771947.png&quot; alt=&quot;image-20201229192220277&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;大概可以看到是powershell的语法？（感觉像win后门，这么多no的参数&lt;/p&gt;
&lt;p&gt;查了一下其实就是把后面那大段进行base64解码而已，用wsl解一下base64有&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2183122/202012/2183122-20201230231127407-393101395.png&quot; alt=&quot;img&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后得到了一段.NET代码（白字）。&lt;/p&gt;
&lt;p&gt;通过查微软文档可以知道，这里是把base64解码以后的字符进行Deflate解压的过程，所以用脚本把中间那段base64解码，并整理输出。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;import base64
import zlib
 
def deflate(data):
    try:
        return zlib.decompress(data, -zlib.MAX_WBITS)
    except zlib.error:
        return zlib.decompress(data)

code='TY5BC4IwGIbvgv9hjB2McJhEhNChJMGTkN2qg7qvFHQT/bL575vpoV2/53n2skJJBInkQG5xwqOqhkcQXCATx7q+gkaHsvYj7kIVvCgburItVgm9MTxbVB5LATp5OlQvb6IMV0LdQvdPpu+8x66SL2eOrMl+Ck7naUA69ggND5UcoEOzI+pUc8p62G3TRZubv34K6IbLespADoGR27vv+R7HpqXzt8Q9y0IJI5N8RLCtLw=='
de_code=deflate(base64.b64decode(code)).decode()
for x in de_code.split('\r\n'):
    print(x)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2183122/202012/2183122-20201230231127604-1211487554.png&quot; alt=&quot;image-20201229193302890&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;很明显的逻辑了，把doc.chm（应该是原来的re.chm）中&quot;xxxxxxxx&quot;后面的部分提取出来，还是用base64解码得到文件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2183122/202012/2183122-20201230231127829-418802557.png&quot; alt=&quot;img&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;把这后面的内容手动复制出来到cont.txt里，进行base64解码，最后存在theFile中。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;base64 -d cont.txt &amp;gt; theFile
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查看theFile可以猜测是exe（毕竟最开始给的就是有powershell指令的base64），把文件头补上，并改后缀名（即theFile.exe）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2183122/202012/2183122-20201230231128048-51121876.png&quot; alt=&quot;img&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;用ida打开，通过FindCrypt插件可以看到AES，跟过去能看到AES加密时的S盒（其实这里前两个都是S盒，第三个是逆S盒），猜测用到了AES加密。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2183122/202012/2183122-20201230231128284-246093210.png&quot; alt=&quot;image-20201229195213434&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2183122/202012/2183122-20201230231128523-1894502838.png&quot; alt=&quot;image-20201229195456197&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;往上回溯找到主函数&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2183122/202012/2183122-20201230231128761-1669542994.png&quot; alt=&quot;image-20201229195646671&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;显然，这里是AES加密过程，sub_180001100()是密钥拓展过程，sub_1800015B0()是AES加密。&lt;/p&gt;
&lt;blockquote readability=&quot;3.0857142857143&quot;&gt;
&lt;p&gt;关于逆向中各种常见密码的记录，指路：&lt;a href=&quot;https://yfli.top/2020/02/18/encrypt_document/#more&quot; target=&quot;_blank&quot;&gt;对称加密算法&amp;amp;&amp;amp;Hash算法 文档 | feng's blog&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;看了一下感觉是原装无魔改的AES，密文密钥都给了，那就直接写脚本解密。&lt;/p&gt;
&lt;p&gt;注意这里是以整数形式给出的，别忘了小端序。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from Crypto.Cipher import AES
from binascii import *

arr=[0x16157E2B,0xA6D2AE28,0x8815F7AB,0x3C4FCF09]
key=&quot;&quot;
for i in range(4):
    key=hex(arr[i])[2:]+key
key=unhexlify(key)[::-1] #注意小端序的问题
tmp=0x46C42084AA2A1B56E799D643453FF4B5
cipher=unhexlify(hex(tmp)[2:])[::-1]
enc=AES.new(key,AES.MODE_ECB)
print(enc.decrypt(cipher))
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2183122/202012/2183122-20201230231128971-29831972.png&quot; alt=&quot;image-20201229202801230&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;flag{youcangues}&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;puzzle&quot;&gt;puzzle&lt;/h2&gt;
&lt;p&gt;mips架构。&lt;/p&gt;
&lt;p&gt;加载进ida以后，通过字符串回溯找到主函数。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2183122/202012/2183122-20201230231129252-305638873.png&quot; alt=&quot;image-20201229203258179&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2183122/202012/2183122-20201230231129478-891715450.png&quot; alt=&quot;image-20201229203319240&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到很明显的sub_401134()这个check，先往这里面看。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2183122/202012/2183122-20201230231129702-143839534.png&quot; alt=&quot;image-20201229203405086&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看到是一个疑似maze的逻辑（&lt;/p&gt;
&lt;p&gt;不过sub_400FA8()点进去以后可以看到是swap的功能&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2183122/202012/2183122-20201230231129908-653041770.png&quot; alt=&quot;image-20201229203651570&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以应该不是maze，是一个以交换为主的逻辑。&lt;/p&gt;
&lt;p&gt;至于dword_4A0010，可以看到是一个九个数的数组。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2183122/202012/2183122-20201230231130147-780275031.png&quot; alt=&quot;image-20201229203733240&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;v4和v5的出处在switch逻辑上面一点&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2183122/202012/2183122-20201230231130359-9491212.png&quot; alt=&quot;image-20201229204029832&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到最后(v4,v5)其实表示了数组里0的位置，且数组实际可以看成是3*3。&lt;/p&gt;
&lt;p&gt;即：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;4 0 3
7 2 6
8 1 5
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后sub_400FFC()的检查逻辑：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2183122/202012/2183122-20201230231130593-1901948782.png&quot; alt=&quot;image-20201229204442580&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;实际上就是要让这个3*3等于&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1 2 3
4 5 6
7 8 0
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;把0看成空位的话，很容易就想到3*3的华容道了。&lt;/p&gt;
&lt;p&gt;（或者玩算法的小伙伴可能对八数码问题这个名字更熟悉？&lt;/p&gt;
&lt;p&gt;&lt;s&gt;有本事下次出数织啊！20*20我都给你火速解出来（来自数织爱好者的吐槽）&lt;/s&gt;&lt;/p&gt;
&lt;p&gt;这里实际上是求最短能得到的路径（15步），懒得想了，直接去网上抓了个现成代码下来改了改。&lt;/p&gt;
&lt;blockquote readability=&quot;1.6304347826087&quot;&gt;
&lt;p&gt;八数码问题的代码见：&lt;a href=&quot;https://blog.csdn.net/lishang6257/article/details/79732420&quot; target=&quot;_blank&quot;&gt;八数码问题-A*(AStar)算法实现_Broken Geeker-CSDN博客&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;ctime&amp;gt;
#include &amp;lt;cstdlib&amp;gt;
#define maxState 10000
#define N 3
using namespace std;

bool isEqual(int a[N][N][maxState],int b[N][N],int n){
    for(int i = 0;i &amp;lt; N;i ++){
        for(int j = 0;j &amp;lt; N;j ++){
            if(a[i][j][n] != b[i][j]) return false;
        }
    }
    return true;
}
bool isEqual(int a[N][N],int b[N][N]){
    for(int i = 0;i &amp;lt; N;i ++){
        for(int j = 0;j &amp;lt; N;j ++){
            if(a[i][j] != b[i][j]) return false;
        }
    }
    return true;
}
int evalute(int state[N][N],int target[N][N]){
    int num = 0;
    for(int i = 0;i &amp;lt; N;i ++){
        for(int j = 0;j &amp;lt; N;j ++)
            if(state[i][j] != target[i][j]) num ++;
    }
    return num;
}
void findBrack(int a[N][N],int x,int y){
    for(int i = 0;i &amp;lt; N;i ++){
        for(int j = 0;j &amp;lt; N;j ++){
            if(a[i][j] == 0) {
                x = i;y = j;return;
            }
        }
    }
}
bool move(int a[N][N],int b[N][N],int dir){
    //1 up 2 down 3 left 4 right
    int x = 0,y = 0;
    for(int i = 0;i &amp;lt; N;i ++){
        for(int j = 0;j &amp;lt; N;j ++){
            b[i][j] = a[i][j];
            if(a[i][j] == 0) {
                x = i;y = j;
            }
        }
    }
    if(x == 0 &amp;amp;&amp;amp; dir == 1) return false;
    if(x == N-1 &amp;amp;&amp;amp; dir == 2) return false;
    if(y == 0 &amp;amp;&amp;amp; dir == 3) return false;
    if(y == N-1 &amp;amp;&amp;amp; dir == 4) return false;
    if(dir == 1){b[x-1][y] = 0;b[x][y] = a[x-1][y];}
    else if(dir == 2){b[x+1][y] = 0;b[x][y] = a[x+1][y];}
    else if(dir == 3){b[x][y-1] = 0;b[x][y] = a[x][y-1];}
    else if(dir == 4){b[x][y+1] = 0;b[x][y] = a[x][y+1];}
    else return false;
    return true;
}
void statecpy(int a[N][N][maxState],int b[N][N],int n){
    for(int i = 0;i &amp;lt; N;i ++){
        for(int j = 0;j &amp;lt; N;j ++){
            a[i][j][n] = b[i][j];
        }
    }
}
void getState(int a[N][N][maxState],int b[N][N],int n){
    for(int i = 0;i &amp;lt; N;i ++){
        for(int j = 0;j &amp;lt; N;j ++){
            b[i][j] = a[i][j][n];
        }
    }
}
void statecpy(int a[N][N],int b[N][N]){
    for(int i = 0;i &amp;lt; N;i++){
        for(int j = 0;j &amp;lt; N;j++)
            a[i][j] = b[i][j];
    }
}
int checkAdd(int a[N][N][maxState],int b[N][N],int n){
    for(int i = 0;i &amp;lt; n;i ++){
        if(isEqual(a,b,i)) return i;
    }
    return -1;
}
int Astar(int a[N][N][maxState],int start[N][N],int target[N][N],int path[maxState]){
    bool visited[maxState] = {false};
    int fitness[maxState] = {0};
    int passLen[maxState] = {0};
    int curpos[N][N];
    statecpy(curpos,start);
    int id = 0,Curid = 0;
    fitness[id] = evalute(curpos,target);
    statecpy(a,start,id++);
    while(!isEqual(curpos,target)){
        for(int i = 1;i &amp;lt; 5;i ++){//向四周找方向
            int tmp[N][N] = {0};
            if(move(curpos,tmp,i)){
                int state = checkAdd(a,tmp,id);
                if(state == -1){//not add
                    path[id] = Curid;
                    passLen[id] = passLen[Curid] + 1;
                    fitness[id] = evalute(tmp,target) + passLen[id];
                    statecpy(a,tmp,id++);
                }else{//add
                    int len = passLen[Curid] + 1,fit = evalute(tmp,target) + len;
                    if(fit &amp;lt; fitness[state]){
                        path[state] = Curid;
                        passLen[state] = len;
                        fitness[state] = fit;
                        visited[state] = false;
                    }
                }
            }
        }
        visited[Curid] = true;
        //找到适应度最小的最为下一个带搜索节点
        int minCur = -1;
        for(int i = 0;i &amp;lt; id;i ++)
            if(!visited[i] &amp;amp;&amp;amp; (minCur == -1 || fitness[i] &amp;lt; fitness[minCur])) minCur = i;
        Curid = minCur;
        getState(a,curpos,Curid);
        if(id == maxState) return -1;
    }
    return Curid;
}
void show(int a[N][N][maxState],int n){
    cout &amp;lt;&amp;lt; &quot;-------------------------------\n&quot;;
    for(int i = 0;i &amp;lt; N;i ++){
        for(int j =0;j &amp;lt; N;j ++){
            cout &amp;lt;&amp;lt; a[i][j][n] &amp;lt;&amp;lt; &quot; &quot;;
        }
        cout &amp;lt;&amp;lt; endl;
    }
    cout &amp;lt;&amp;lt; &quot;-------------------------------\n&quot;;
}
int calDe(int a[N][N]){
    int sum = 0;
    for(int i = 0;i &amp;lt; N*N;i ++){
        for(int j = i+1;j &amp;lt; N*N;j ++){
            int m,n,c,d;
            m = i/N;n = i%N;
            c = j/N;d = j%N;
            if(a[c][d] == 0) continue;
            if(a[m][n] &amp;gt; a[c][d]) sum ++;
        }
    }
    return sum;
}
void autoGenerate(int a[N][N]){
    int maxMove = 50;
    srand((unsigned)time(NULL));
    int tmp[N][N];
    while(maxMove --){
        int dir = rand()%4 + 1;
        if(move(a,tmp,dir)) statecpy(a,tmp);
    }
}
int main(){
    int a[N][N][maxState] = {0};
    // int start[N][N] = {1,2,3,4,5,6,7,8,0};
    // autoGenerate(start);
    // cout &amp;lt;&amp;lt; start[0][0] &amp;lt;&amp;lt; start[1][1];
    int start[N][N] = {4,0,3,7,2,6,8,1,5};
    int target[N][N] = {1,2,3,4,5,6,7,8,0};
    if(!(calDe(start)%2 == calDe(target)%2)){
        cout &amp;lt;&amp;lt; &quot;无解\n&quot;;
        return 0;
    }
    int path[maxState] = {0};
    int res =  Astar(a,start,target,path);
    if(res == -1){
        cout &amp;lt;&amp;lt; &quot;达到最大搜索能力\n&quot;;
        return 0;
    }
    int shortest[maxState] = {0},j = 0;
    while(res != 0){
        shortest[j++] = res;
        res = path[res];
    }
    cout &amp;lt;&amp;lt; &quot;第 0 步\n&quot;;
    show(a,0);
    for(int i = j - 1;i &amp;gt;= 0;i --){
        cout &amp;lt;&amp;lt; &quot;第 &quot; &amp;lt;&amp;lt; j-i &amp;lt;&amp;lt; &quot; 步\n&quot;;
        show(a,shortest[i]);
    }
    return 0;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;得到每一步的情况，进而根据switch写出路径。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;第 0 步
-------------------------------
4 0 3
7 2 6
8 1 5
-------------------------------
第 1 步
-------------------------------
4 2 3
7 0 6
8 1 5
-------------------------------
第 2 步
-------------------------------
4 2 3
7 1 6
8 0 5
-------------------------------
第 3 步
-------------------------------
4 2 3
7 1 6
8 5 0
-------------------------------
第 4 步
-------------------------------
4 2 3
7 1 0
8 5 6
-------------------------------
第 5 步
-------------------------------
4 2 0
7 1 3
8 5 6
-------------------------------
第 6 步
-------------------------------
4 0 2
7 1 3
8 5 6
-------------------------------
第 7 步
-------------------------------
4 1 2
7 0 3
8 5 6
-------------------------------
第 8 步
-------------------------------
4 1 2
7 5 3
8 0 6
-------------------------------
第 9 步
-------------------------------
4 1 2
7 5 3
0 8 6
-------------------------------
第 10 步
-------------------------------
4 1 2
0 5 3
7 8 6
-------------------------------
第 11 步
-------------------------------
0 1 2
4 5 3
7 8 6
-------------------------------
第 12 步
-------------------------------
1 0 2
4 5 3
7 8 6
-------------------------------
第 13 步
-------------------------------
1 2 0
4 5 3
7 8 6
-------------------------------
第 14 步
-------------------------------
1 2 3
4 5 0
7 8 6
-------------------------------
第 15 步
-------------------------------
1 2 3
4 5 6
7 8 0
-------------------------------

6 左
2 上
4 右
8 下
// 884226886224488
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;路径为“884226886224488”。&lt;/p&gt;
&lt;p&gt;接下来看主函数里check上面的部分，看到sub_409070()实际上是一个scanf，而dword_4A1B60是我们的输入，也就是最后的flag，中间对输入进行处理以后才得到“884226886224488”这个字符串。&lt;/p&gt;
&lt;p&gt;在里面翻可以翻到一个sub_400B58()，猜测是base64换表编码。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2183122/202012/2183122-20201230231130873-781443123.png&quot; alt=&quot;image-20201229205535378&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;于是尝试写脚本编码。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;import base64
b64table=&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;
mytable=&quot;&quot;
offset=-18
for i in range(len(b64table)):
    mytable+=b64table[(i+offset)%len(b64table)]
text=&quot;884226886224488&quot;.encode()
cipher=base64.b64encode(text).decode().translate(str.maketrans(b64table,mytable))
print(cipher)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2183122/202012/2183122-20201230231131271-1156274033.png&quot; alt=&quot;image-20201229210535246&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;试试能不能过check。&lt;/p&gt;
&lt;p&gt;wsl运行：（要装qemu才能执行，毕竟特殊架构。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;cp $(which qemu-mips) .
./qemu-mips -L . ./puzzle
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行mips程序，输入脚本中解出的字符串，发现成功了，get flag。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2183122/202012/2183122-20201230231131488-1607244702.png&quot; alt=&quot;image-20201229210455631&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;flag{8xOi6R2k8xOk6R2i7xOm}&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;arm&quot;&gt;aRm&lt;/h2&gt;
&lt;p&gt;arm架构。&lt;/p&gt;
&lt;p&gt;照例通过字符串回溯找到主函数。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2183122/202012/2183122-20201230231131753-1021300930.png&quot; alt=&quot;image-20201229220910936&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2183122/202012/2183122-20201230231131984-1401341208.png&quot; alt=&quot;image-20201229222635806&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;v1是key，v9是输入的flag，对输入的限制就是长度为42且头尾是“flag{”和“}”。&lt;/p&gt;
&lt;p&gt;动态调一下可以发现，sub_27770()这个函数实际上是把unk_723A0数组里的42个数据复制到v8里。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;./qemu-arm -L ./ -g 12345 ./aRm
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（Debugger选Remote GDB debugger，把端口号填上就好，其余配置具体见&lt;a href=&quot;https://c10udlnk.top/2020/12/14/reSkillsOn-Debugging/&quot; target=&quot;_blank&quot;&gt;RE套路 - 关于使用IDA 7.0前端进行的动态调试 | c10udlnk_Log&lt;/a&gt;中调试elf部分。&lt;/p&gt;
&lt;p&gt;现在我们未知的数就剩v5和v6了，v5要看sub_1714C()的输出，v6这里相当于是42条42元一次方程组（输入未知的情况下）。&lt;/p&gt;
&lt;p&gt;而sub_105B4()是输出42个结果，于是可以知道只要输出了output.txt里的42个数就是正确的flag了。&lt;/p&gt;
&lt;p&gt;由于前面有一个sub_169AC(key)，这边又是一个无参的sub_1714C()+1，于是猜测是srand(seed)和rand()。&lt;/p&gt;
&lt;p&gt;为了证明猜测，多次运行程序输入同一个key和相同/不同的flag，发现每一次的v5是一样的，结合rand()的伪随机性，确定这就是随机函数。&lt;/p&gt;
&lt;p&gt;由于key只有一字节（0~255），干脆直接爆破。把output.txt的数据读入，用sympy库解方程，只要第一个解x0等于&lt;code&gt;ord('f')^v8[0]=102^0xA0=198&lt;/code&gt;，就说明这个key有极大可能性是正确的key。&lt;/p&gt;
&lt;p&gt;当然，在此之前，我们得先知道每一次的v5（即方程的系数）是多少。&lt;/p&gt;
&lt;p&gt;于是hook函数，在v5生成之后复用程序原来就有的print函数及格式符，把每次生成的v5都打印出来。&lt;/p&gt;
&lt;p&gt;还记得有个函数是可以输出八位十六进制数的吧，就是那个sub_105B4()，我们可以用这里面的printf，然后把调用这个函数的地方nop掉（目标要明确，现在是为了爆破key，没必要管程序的正常性hahah）。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;本来是想自己堆个调用printf出来的，不知道为什么keypatch对&lt;code&gt;LDR R0, =a08x&lt;/code&gt;解释不了，于是只好绕个小路了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2183122/202012/2183122-20201230231132274-1923711696.png&quot; alt=&quot;image-20201230134100558&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;转到汇编窗口，记一下这里的loc，等会要跳过来的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2183122/202012/2183122-20201230231132494-877047308.png&quot; alt=&quot;image-20201230134235154&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看回去原来二重循环里出v5那个地方&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2183122/202012/2183122-20201230231132734-938607639.png&quot; alt=&quot;image-20201230134326684&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这几条语句的意思就是f5里面的那行&lt;code&gt;v5 = (unsigned __int8)(sub_1714C() + 1);&lt;/code&gt;，我们从再下一行开始改。&lt;/p&gt;
&lt;p&gt;注意可以改的范围在蓝框这里，这是我们不需要的&lt;code&gt;v6[j] += (unsigned __int8)v9[k] * v5;&lt;/code&gt;，在这个范围里可以尽情修改，剩下的nop掉。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2183122/202012/2183122-20201230231132983-1952569576.png&quot; alt=&quot;image-20201230134904926&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;用keypatch直接输入汇编，patch后面的语句为&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2183122/202012/2183122-20201230231133216-2013697483.png&quot; alt=&quot;image-20201230135257443&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（其实就是改了一行&lt;code&gt;B loc_105D4&lt;/code&gt;，剩下的直接Fill with NOPs就好）&lt;/p&gt;
&lt;p&gt;接下来去往loc_105D4，改造一下。&lt;/p&gt;
&lt;p&gt;我们知道，现在R3寄存器里实际上存的是v5的值，我们调用printf直接输出R3的值就能达成目标。&lt;/p&gt;
&lt;p&gt;在ARM汇编里，函数传参用R0、R1……所以我们这里给R1一个R3的值就好。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2183122/202012/2183122-20201230231133413-398089151.png&quot; alt=&quot;image-20201230135756039&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里本来就是&lt;code&gt;MOV R1, R3&lt;/code&gt;不用改，所以直接把前面nop掉。&lt;/p&gt;
&lt;p&gt;因为v5那里是取(unsigned __int8)，所以把这里改一下，把&quot;%08x&quot;改成&quot;%02x&quot;，就是出来的v5。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2183122/202012/2183122-20201230231133641-1175617951.png&quot; alt=&quot;image-20201230141148584&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;别忘了后面还要跳回去，找到地址：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2183122/202012/2183122-20201230231134012-1354607358.png&quot; alt=&quot;image-20201230140112007&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;patch：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2183122/202012/2183122-20201230231134364-1510036830.png&quot; alt=&quot;image-20201230140621270&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;记得把调用sub_105B4()的地方也nop掉。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2183122/202012/2183122-20201230231134607-791664511.png&quot; alt=&quot;image-20201230140838366&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后把patch的字节保存一下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2183122/202012/2183122-20201230231134822-1627344499.png&quot; alt=&quot;image-20201230140754908&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;运行测试一下，有：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2183122/202012/2183122-20201230231135025-755564000.png&quot; alt=&quot;image-20201230142921253&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;ok，hook成功，开始爆破。&lt;/p&gt;
&lt;blockquote readability=&quot;5.2181818181818&quot;&gt;
&lt;p&gt;用pexpect进行批量的自动化交互见：&lt;a href=&quot;https://c10udlnk.top/2020/12/28/wpFor-2020chamd5XMAS/&quot; target=&quot;_blank&quot;&gt;【wp】2020ChaMd5圣诞题 | c10udlnk_Log&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;多亏了周五做的那个题，才有了这个题的爆破脚本（Doge。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;import pexpect
from sympy import *

data=[]
with open('output.txt','r') as f:
    tmp=f.read().split('\r\n')
    data=[int(x,16) for x in tmp]
src=[0xA0, 0xE4, 0xBA, 0xFB, 0x10, 0xDD, 0xAC, 0x65, 0x8D, 0x0B, 0x57, 0x1A, 0xE4, 0x28, 0x96, 0xB3, 0x0C, 0x79, 0x4D, 0x80, 0x90, 0x99, 0x58, 0xFE, 0x50, 0xD3, 0xF9, 0x3C, 0x0F, 0xC1, 0xE3, 0xA6, 0x39, 0xC3, 0x28, 0x75, 0xF8, 0xC9, 0xC8, 0xCD, 0x78, 0x26]
flag='flag{000000000000000000000000000000000000}'

var=[]
for num in range(42):
    exec(&quot;x&quot;+str(num)+&quot;=Symbol('x'+str(num))&quot;)
    var.append(&quot;x&quot;+str(num)) #创建42个变量x0~x41
for i in range(256):
    r=pexpect.spawn('./qemu-arm -L ./ ./aRm_getRand')
    r.sendline(str(i))
    r.sendline(flag)
    r.readline()
    r.readline()
    rand=[]
    for j in range(42*42):
        s=r.readline()
        rand.append(int(str(s)[2:-5],16))
    r.wait()
    exper=[]
    for j in range(42):
        anEx=&quot;&quot;
        for k in range(42):
            anEx+=str(rand[j*42+k])+&quot;*&quot;+var[k]+&quot;+&quot;
        anEx=anEx[:-1]+&quot;-&quot;+str(data[j])
        exper.append(anEx)
    res=solve(exper,var)
    print(str(i)+&quot;: &quot;)
    print(res.values())
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;爆破得到：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2183122/202012/2183122-20201230231135267-1176964483.png&quot; alt=&quot;image-20201228135416441&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可知key是82，而v9在xor以后的数组也爆出来了，简单xor得flag：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;arr=[0xA0, 0xE4, 0xBA, 0xFB, 0x10, 0xDD, 0xAC, 0x65, 0x8D, 0x0B, 0x57, 0x1A, 0xE4, 0x28, 0x96, 0xB3, 0x0C, 0x79, 0x4D, 0x80, 0x90, 0x99, 0x58, 0xFE, 0x50, 0xD3, 0xF9, 0x3C, 0x0F, 0xC1, 0xE3, 0xA6, 0x39, 0xC3, 0x28, 0x75, 0xF8, 0xC9, 0xC8, 0xCD, 0x78, 0x26]
x=[198, 136, 219, 156, 107, 228, 152, 7, 239, 63, 97, 127, 134, 5, 247, 131, 109, 75, 96, 180, 241, 173, 57, 211, 49, 224, 157, 9, 34, 243, 129, 199, 1, 244, 31, 17, 157, 171, 252, 249, 64, 91]
flag=&quot;&quot;
for i in range(42):
    flag+=chr(x[i]^arr[i])
print(flag)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2183122/202012/2183122-20201230231135506-1315518990.png&quot; alt=&quot;image-20201230002706300&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;flag{94bb46eb-a0a2-4a4a-a3d5-2ba877deb448}&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;pe&quot;&gt;pe&lt;/h2&gt;
&lt;p&gt;arm架构，没环境调不动，只能硬看了XD。这题有好多奇怪的函数，而且通过伪代码跟的话就能看到函数套函数套函数……所以基本靠猜出来的（&lt;/p&gt;
&lt;p&gt;继续通过字符串回溯找主函数。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2183122/202012/2183122-20201230231135729-917943359.png&quot; alt=&quot;image-20201230004038936&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2183122/202012/2183122-20201230231135969-340384244.png&quot; alt=&quot;image-20201230004436275&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;根据参数猜测，sub_1400023C8()是strcmp()的作用，我们需要让v9=&quot;KIMLXDWRZXTHXTHQTXTXHZWC&quot;。&lt;/p&gt;
&lt;p&gt;再往上走，sub_1400015B0这个函数调用了v9，于是跟进去看功能。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2183122/202012/2183122-20201230231136345-1780338312.png&quot; alt=&quot;image-20201230085247002&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;感觉是某种加密，以相邻的两字符为一组，对这两个字符做相同的操作，再做后续处理。&lt;/p&gt;
&lt;p&gt;跟进sub_1400012B8()里看，可以看到大概是一个搜索的过程&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2183122/202101/2183122-20210101011122099-1501303818.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果不等于-1就说明在表中找到了这个元素，然后返回一个索引（？&lt;/p&gt;
&lt;p&gt;再往下看好像就看不太懂了，然后就是玄学的猜猜猜= =&lt;/p&gt;
&lt;p&gt;回去看string可以看到一个这个，猜测是密钥表之类的？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2183122/202101/2183122-20210101011140817-1334478957.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;往上回溯也看不到什么线索，不过可以发现这25个数字刚好没有相同的。&lt;/p&gt;
&lt;p&gt;现在总结一下这个古典加密算法的特点，大概是两个为一组处理+已定义的密钥表（即不是通过输入生成的）5*5+处理时用到索引。&lt;/p&gt;
&lt;p&gt;&lt;s&gt;很久很久以前想写某对cp的AU同人时想把ctf元素混进去，就看了很多简单又奇奇怪怪的编码/古典密码（现代密码太学术了XD），没想到现在有用武之地了（手动狗头。&lt;/s&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;2.3669724770642&quot;&gt;
&lt;p&gt;安利一个编码/古典密码的集合：&lt;a href=&quot;https://www.cnblogs.com/mq0036/p/6544055.html&quot; target=&quot;_blank&quot;&gt;CTF中那些脑洞大开的编码和加密 - jack_Meng - 博客园&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;然后翻到了一个符合这个特点的密码，Playfair Cipher：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2183122/202101/2183122-20210101011208375-1969638470.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不同的是密码表是直接给出的，不过加密流程再对回ida里的反编译感觉挺像的，于是果断试试。&lt;/p&gt;
&lt;p&gt;按照Playfair Cipher的加解密流程写出脚本：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;def getIndex(c):
    for i in range(len(key)):
        if key[i].find(c)!=-1:
            return i,key[i].find(c)
letter_list=&quot;ABCDEFGHJKLMNOPQRSTUVWXYZ&quot;
key=[&quot;CREIH&quot;,&quot;TQGNU&quot;,&quot;AOVXL&quot;,&quot;DZKYM&quot;,&quot;PBWFS&quot;]
cipher=&quot;KIMLXDWRZXTHXTHQTXTXHZWC&quot;
text=&quot;&quot;
for i in range(0,len(cipher),2):
    j=i+1
    x1,y1=getIndex(cipher[i])
    x2,y2=getIndex(cipher[j])
    if x1==x2:
        text+=key[x1][(y1+1)%5]+key[x2][(y2+1)%5]
    elif y1==y2:
        text+=key[(x1+1)%5][y1]+key[(x2+1)%5][y2]
    else:
        text+=key[x1][y2]+key[x2][y1]
    i+=2
print(text)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;走一遍脚本解密可以得到：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2183122/202101/2183122-20210101011230028-902871151.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;YES MAYBE YOU CAN RUN AN ARM PE&lt;/p&gt;
&lt;p&gt;&lt;s&gt;No, I can't 😦&lt;/s&gt;&lt;/p&gt;
&lt;p&gt;看起来能读的通，成功get flag。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;flag{YESMAYBEYOUCANRUNANARMPE}&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;crash&quot;&gt;crash&lt;/h2&gt;
&lt;p&gt;&lt;s&gt;先去肝ddl回来再补，反正就是个查md5的题（&lt;/s&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Thu, 31 Dec 2020 15:42:00 +0000</pubDate>
<dc:creator>c10udlnk</dc:creator>
<og:description>前几天的XCTF最后一场终于打完了，三场比赛下来对逆向部分的大概感觉是从第一场的啥都不会做（一道lua+一道apk）到后来的终于能有参与度，至少后两场的题目都是pc逆向，虽然特殊架构但好歹能做（tcl</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/c10udlnk/p/14214080.html</dc:identifier>
</item>
<item>
<title>手写系列：call、apply、bind、函数柯里化 - wangmeijian</title>
<link>http://www.cnblogs.com/wangmeijian/p/14219155.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wangmeijian/p/14219155.html</guid>
<description>&lt;p&gt;少废话，show my code&lt;/p&gt;
&lt;h2 id=&quot;call&quot;&gt;call&lt;/h2&gt;
&lt;p&gt;原理都在注释里了&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;// 不覆盖原生call方法，起个别名叫myCall，接收this上下文context和参数params
Function.prototype.myCall = function (context, ...params) {
  // context必须是个对象并且不能为null，默认为window
  const _this = typeof context === &quot;object&quot; ? context || window : window;
  // 为了避免和原有属性冲突，定义一个Symbol类型的属性
  const key = Symbol();
  // call方法的目的是改变函数的this指向，函数的this指向它的调用者，也就是说我们的目标是改变函数的调用者。
  // 下面的this就是函数本身，给context增加一个名为[key]的方法指向this，就能用context来调用this了
  context[key] = this;
  const result = _this[key](...params);
  // 获取函数执行结果后，删除以上添加的属性
  delete context[key];
  return result;
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;apply&quot;&gt;apply&lt;/h2&gt;
&lt;p&gt;和call的区别在于第二个参数&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;Function.prototype.myApply = function (context, params) {
  return this.myCall(context, ...params);
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;bind&quot;&gt;bind&lt;/h2&gt;
&lt;p&gt;和call的区别在于不立即执行，返回一个函数即可&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;Function.prototype.myBind = function (context, ...params) {
  const _this = this;
  // 返回的函数也能接收参数，但是是放在params后面
  return function (...args) {
    return _this.myCall(context, ...[...params, ...args]);
  };
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;函数柯里化&quot;&gt;函数柯里化&lt;/h2&gt;
&lt;p&gt;函数柯里化，举例，有如下函数&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;function test(a, b, c, d, e) {
  console.log(a + b + c + d + e);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有一个curry转换函数对test函数进行一些转换&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;function curry(){
  // todo
}
const transformTest = curry(test, ...args)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;转换之后，原本一次性传过去的参数现在可以分步传参&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;// 使得
test(1,2,3,4,5)
// 等同于
transformTest(1)(2)(3)(4)(5)
// 或者
transformTest(1, 2)(3)(4, 5)
// 又或者
transformTest(1, 2, 3, 4)(5)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;curry函数应该怎么写？&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;function curry(fn, ...args) {
  // 判断参数个数是不是等于原函数参数个数
  // 如果是，直接返回调用结果
  if ([...args].length === fn.length) {
    return fn(...args);
  } else {
    // 如果不是，则返回一个函数
    return (...params) =&amp;gt; {
      // 将前面传的全部参数传给curry，回到第一步的if判断，直到参数个数满足要求
      return curry(fn, ...args, ...params);
    };
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;本文GitHub链接：&lt;a href=&quot;https://github.com/wangmeijian/blog/issues/3&quot; target=&quot;_blank&quot;&gt;手写系列：call、apply、bind、函数柯里化&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 31 Dec 2020 15:40:00 +0000</pubDate>
<dc:creator>wangmeijian</dc:creator>
<og:description>少废话，show my code</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wangmeijian/p/14219155.html</dc:identifier>
</item>
<item>
<title>算法系列-动态规划(4)：买卖股票的最佳时机 - lillcol</title>
<link>http://www.cnblogs.com/lillcol/p/14218940.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lillcol/p/14218940.html</guid>
<description>&lt;p&gt;此系列为动态规划相关文章。&lt;/p&gt;
&lt;p&gt;系列历史文章：&lt;br/&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/YhbOi2_LInQ7EXP3WDgodA&quot; target=&quot;_blank&quot;&gt;算法系列-动态规划(1)：初识动态规划&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/TsX5dkKEmJn9Qup0__4AAg&quot; target=&quot;_blank&quot;&gt;算法系列-动态规划(2)：切割钢材问题&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/fKqp5icO5CfwoUfZ5jQmeg&quot; target=&quot;_blank&quot;&gt;算法系列-动态规划(3)：找零钱、走方格问题&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/ubDMTzaSVw3Ks0F9YIXFeg&quot; target=&quot;_blank&quot;&gt;算法系列-动态规划(4)：买卖股票的最佳时机&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;新生韭菜罗拉&quot;&gt;新生韭菜罗拉&lt;/h3&gt;
&lt;p&gt;自从上次看到八哥收藏旧币，罗拉也想给自己捣鼓个副业，赚点零花钱。&lt;/p&gt;
&lt;p&gt;于是她瞄上了股票，作为股场新人，罗拉可是满怀信心的。&lt;br/&gt;觉得自己只要顺应潮流，识大体，懂进退，不贪心，即使不赚大钱，也不至于亏钱。 所以她想拿个一千八百试试水。&lt;/p&gt;
&lt;p&gt;八哥作为过来人，股票玩得稀碎，当年也是这么过来的，狠狠的当了一波韭菜。&lt;br/&gt;但是看罗拉的劲头，不被收割一次是劝不住她的富婆梦的。&lt;br/&gt;就看看她怎么捣鼓吧。&lt;/p&gt;
&lt;p&gt;罗拉这几天一直盯着手机看股票行情。&lt;br/&gt;时而欣喜，时而叹气。&lt;/p&gt;
&lt;p&gt;看来时机差不多了，八哥准备落井...关心一下罗拉。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;对话记录&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;15.5&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;八哥&lt;/strong&gt;&lt;/p&gt;
罗拉，炒股也有几天了，你的富婆梦是否近了一步？&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td readability=&quot;6&quot;&gt;
&lt;p align=&quot;right&quot;&gt;&lt;strong&gt;罗拉&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;right&quot;&gt;哎，别提了，这几天天天盯着价格，眼睛都花了。&lt;br/&gt;我买股票好像就跟我做对一样，在我手上狂跌，我一卖就涨&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td/&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td/&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;八哥&lt;/strong&gt;&lt;/p&gt;
是不是有一种，这些股票专门割你韭菜的赶脚。&lt;br/&gt;只要持有就跌，卖出后就涨。&lt;br/&gt;全世界都盯着你的一千八百&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7.5&quot;&gt;&lt;td readability=&quot;8&quot;&gt;
&lt;p align=&quot;right&quot;&gt;&lt;strong&gt;罗拉&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;right&quot;&gt;对啊，这几天我只关注一支股票，也一直在买卖这个。&lt;br/&gt;虽然不至于像你说的这么夸张，但是确实现在小亏吧。&lt;br/&gt;要么因为下跌急急忙忙卖了，但是我一卖它马上又涨回来了&lt;br/&gt;要么因为上涨态势好，我持有了，但是转眼它又跌了&lt;br/&gt;总之，时机把握的不好&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td/&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td/&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;八哥&lt;/strong&gt;&lt;/p&gt;
这么看来你的富婆梦不怎么顺利呀&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td readability=&quot;6&quot;&gt;
&lt;p align=&quot;right&quot;&gt;&lt;strong&gt;罗拉&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;right&quot;&gt;确实，果然小丑是我自己吗？&lt;br/&gt;也对，要是这么容易，谁还老老实实干活啊，都去炒股的了&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td/&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td/&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;八哥&lt;/strong&gt;&lt;/p&gt;
是的&lt;br/&gt;所以我一开始也不劝你，毕竟大家开始的心态和你都差不多。&lt;br/&gt;只有被割过韭菜，才会知道炒股高风险，高回报。不是一般人能玩的。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td readability=&quot;6&quot;&gt;
&lt;p align=&quot;right&quot;&gt;&lt;strong&gt;罗拉&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;right&quot;&gt;哎，白白浪费了几天时间，&lt;br/&gt;看来我还是适合去玩鸡，找个靠谱鸡放着都比这个强&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td/&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td/&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;八哥&lt;/strong&gt;&lt;/p&gt;
富婆梦可能毫无收获，但是这个经历到时可以用来提升一下自己，&lt;br/&gt;买卖股票可是一个很经典的算法题哦。&lt;br/&gt;当然这个事后诸葛亮的题目。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td readability=&quot;5&quot;&gt;
&lt;p align=&quot;right&quot;&gt;&lt;strong&gt;罗拉&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;right&quot;&gt;算法？有点意思，说来瞅瞅&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td/&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td/&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;八哥&lt;/strong&gt;&lt;/p&gt;
行，我把几个经典的案例说一下吧&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;说到炒股，&lt;br/&gt;想当年八哥的神操作...，泪流满面&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1293390/202012/1293390-20201231224506039-496227391.png&quot; alt=&quot;八哥韭菜曲线&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;买卖股票的最佳时机交易一次&quot;&gt;买卖股票的最佳时机(交易一次)&lt;/h3&gt;
&lt;p&gt;“先来第一个题目，”&lt;br/&gt;“罗拉，你把你最近的股票七八天的股价给我列一下”&lt;/p&gt;
&lt;p&gt;“好，最近七八天的价格是这样的：&lt;code&gt;{9,11,7,5,7,10,18,3}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;“嗯，我们现在先来最简单的，题目如下：”&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。&lt;br/&gt;如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），&lt;br/&gt;设计一个算法来计算你所能获取的最大利润。&lt;br/&gt;注意：你不能在买入股票前卖出股票。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;“你试着分析看看。”&lt;/p&gt;
&lt;p&gt;“行我试试”&lt;/p&gt;
&lt;p&gt;“要想一次交易收益最大”，&lt;br/&gt;“那么必须保证我是在最低点买入最高点卖出。这个样就可以保证我的收益最大”。&lt;br/&gt;“在这里我们的最低点是&lt;code&gt;3&lt;/code&gt;，最高点是&lt;code&gt;18&lt;/code&gt;,这样算的话最大收益是&lt;code&gt;15&lt;/code&gt;”。&lt;/p&gt;
&lt;p&gt;“嗯，不对，&lt;code&gt;3&lt;/code&gt;是在&lt;code&gt;18&lt;/code&gt;后面，这样不符合逻辑”。&lt;br/&gt;“应该是要保证最低价格在最高价格前面，要先买了才能买”。&lt;/p&gt;
&lt;p&gt;“所以，假设今天是第&lt;code&gt;i&lt;/code&gt;天，我只要记录&lt;code&gt;i-1&lt;/code&gt;天之前的最低价格”，&lt;br/&gt;“用今天的价格减去最低价格得到利润，然后选取最大的利润即可”。&lt;br/&gt;“嗯，典型动态规划特征”。&lt;br/&gt;“我用&lt;code&gt;dp[i]&lt;/code&gt;记录前&lt;code&gt;i-1&lt;/code&gt;天的最低价格，”&lt;br/&gt;“边界值为第&lt;code&gt;0&lt;/code&gt;天股价设置为最大，保证&lt;code&gt;dp[1]&lt;/code&gt;以后最小值”。&lt;br/&gt;“哈哈，姐姐明白了”。&lt;/p&gt;
&lt;p&gt;罗拉自信道，然后开始编码。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class StockTrading {
    public static void main(String[] args) {
        int[] prices = {9, 11, 7, 5, 7, 10, 18, 3};
        int[] pricesUp = {2,3,4,5,6,7,8,9};
        int[] pricesDown = {9,8,7,6,5,4,3,2};
        System.out.println(&quot;prices 一次交易最大利润为: &quot;+stockTrading1(prices));
        System.out.println(&quot;pricesUp 一次交易最大利润为: &quot;+stockTrading1(pricesUp));
        System.out.println(&quot;pricesDown 一次交易最大利润为: &quot;+stockTrading1(pricesDown));
    }

    public static int stockTrading1(int[] prices) {
        if(prices==null || prices.length&amp;lt;2) return 0;

        int[] dp = new int[prices.length + 1];
        //设定边界
        dp[0] = Integer.MAX_VALUE;//为了后面能取到最小值，dp[0]设置为Integer.MAX_VALUE
        int max = Integer.MIN_VALUE;//一开始利润为Integer.MIN_VALUE
        for (int i = 1; i &amp;lt;= prices.length; i++) {
            max = Math.max(max,prices[i-1] - dp[i-1]);
            dp[i] = Math.min(dp[i - 1], prices[i-1]);
        }
        return max&amp;gt;=0?max:0;//利润不能为负数，毕竟没有傻子
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;//输出结果
prices 一次交易最大利润为: 13
pricesUp 一次交易最大利润为: 7
pricesDown 一次交易最大利润为: 0
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;“不错，结果也没错，可是你没必要万事皆动态吧”。&lt;br/&gt;“吹毛求疵，如果我要用&lt;code&gt;O(1)&lt;/code&gt;的时间复杂度，咋整？” 八哥有气无力道。&lt;br/&gt;“明明有简单点、更高效的写法，比如这样: ”&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class StockTrading {
    public static void main(String[] args) {
        int[] prices = {9, 11, 7, 5, 7, 10, 18, 3};
        int[] pricesUp = {2, 3, 4, 5, 6, 7, 8, 9};
        int[] pricesDown = {9, 8, 7, 6, 5, 4, 3, 2};
        System.out.println(&quot;prices 一次交易最大利润为: &quot; + stockTrading1(prices));
        System.out.println(&quot;pricesUp 一次交易最大利润为: &quot; + stockTrading1(pricesUp));
        System.out.println(&quot;pricesDown 一次交易最大利润为: &quot; + stockTrading1(pricesDown));
    }

    public static int stockTrading1(int[] prices) {
        if (prices == null || prices.length &amp;lt; 2) return 0;

        //设定边界
        int min = Math.min(prices[0], prices[1]);//记录前两天的最低价格
        int max = prices[1] - prices[0];//记录前两天利润
        for (int i = 2; i &amp;lt; prices.length; i++) {
            max = Math.max(max, prices[i] - min);
            min = Math.min(min, prices[i]);
        }
        return max &amp;gt;= 0 ? max : 0; //利润不能为负数，毕竟没有傻子
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;//输出结果
prices 一次交易最大利润为: 13
pricesUp 一次交易最大利润为: 7
pricesDown 一次交易最大利润为: 0
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;“不过这个一般问题不大，我只是想说你不要陷入一个误区就是啥都钻到动态里面去”。&lt;br/&gt;“而忽视其他的方法”。&lt;/p&gt;
&lt;p&gt;“哦，自从学了动态，好像确实有点凡事只想动态了，不过你这个本质还是动态吧”，罗拉尴尬道。&lt;/p&gt;
&lt;p&gt;“嗯，这么说也没错，就是压缩一下空间而已，能想到动态不是坏事，只要不钻牛角尖就好了”。&lt;br/&gt;“这是最简单的，接下来我们看看下一个问题”。&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;买卖股票的最佳时机交易多次&quot;&gt;买卖股票的最佳时机(交易多次)&lt;/h3&gt;
&lt;p&gt;“第二个问题如下：”&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。&lt;br/&gt;设计一个算法来计算你所能获取的最大利润。&lt;br/&gt;你可以尽可能地完成更多的交易（多次买卖一支股票）。&lt;br/&gt;注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;“这是股票问题的第二类，你看看这个要怎么处理”。&lt;/p&gt;
&lt;p&gt;“嗯，我先看看”，&lt;br/&gt;“如果我要算最大的，利润，肯定是得逢低买入，逢高卖出”。&lt;br/&gt;“不过有个限制条件，每天只能进行一次交易，只能买卖二选一”。&lt;br/&gt;“我可以比较两天的价格，如果第&lt;code&gt;i&lt;/code&gt;天的价格&lt;code&gt;prices[i]&lt;/code&gt;大于第&lt;code&gt;i-1&lt;/code&gt;天的价格&lt;code&gt;prices[i-1]&lt;/code&gt;，那么我就在第&lt;code&gt;i-1&lt;/code&gt;天买入，第&lt;code&gt;i&lt;/code&gt;天卖出”。&lt;br/&gt;“但是这会存在一个问题，如果我连续两天都是上涨的，这样算会出问题”。&lt;br/&gt;“比如&lt;code&gt;prices[i-2]&amp;lt;prices[i-1]&amp;lt;prices[i]&lt;/code&gt;,此时我按照上面的做法，&lt;code&gt;prices[i-2]&lt;/code&gt;买入，&lt;code&gt;prices[i-1]&lt;/code&gt;是卖出的,那&lt;code&gt;prices[i]&lt;/code&gt;这一块最多只能是买入了，显然不合逻辑”。&lt;br/&gt;“那我修正一下逻辑”。&lt;br/&gt;“我找每一个上升区间&lt;code&gt;[p1,p2]&lt;/code&gt;,在&lt;code&gt;p1&lt;/code&gt;买入，在&lt;code&gt;p2&lt;/code&gt;卖出即可，就像这张图里面绿色部分”。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1293390/202012/1293390-20201231224637599-1893454251.png&quot; alt=&quot;递增区间&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;“然后只要把每一段的利润加起来就可以了，so easy” 罗拉得意道。&lt;/p&gt;
&lt;p&gt;“不错，思路可以，show me your code”。八哥点点头。&lt;/p&gt;
&lt;p&gt;“行，稍后”&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class StockTrading {
    public static void main(String[] args) {
        int[] prices = {7, 2, 5, 3, 6, 4, 7, 8, 2};
        int[] pricesUp = {2, 3, 4, 5, 6, 7, 8, 9};
        int[] pricesDown = {9, 8, 7, 6, 5, 4, 3, 2};
        System.out.println(&quot;prices 不限次交易最大利润为: &quot; + stockTrading2(prices));
        System.out.println(&quot;pricesUp 不限次交易最大利润为: &quot; + stockTrading2(pricesUp));
        System.out.println(&quot;pricesDown 不限次交易最大利润为: &quot; + stockTrading2(pricesDown));
    }

    public static int stockTrading2(int[] prices) {
        if (prices == null || prices.length &amp;lt; 2) return 0;
        int profit = 0;
        for (int i = 1; i &amp;lt; prices.length; i++) {
            //转换成求解上升区间的问题
            if (prices[i] &amp;gt; prices[i - 1]) profit += (prices[i] - prices[i - 1]);
        }
        return profit;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;//输出结果
prices 不限次交易最大利润为: 10
pricesUp 不限次交易最大利润为: 7
pricesDown 不限次交易最大利润为: 0
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;“不错，很简单了，不过既然这是动态规划的经典案例，你再试试动态呗”。八哥笑道&lt;/p&gt;
&lt;p&gt;“有必要吗？这不都做出来了吗，而且这个时间复杂度&lt;code&gt;O(n)&lt;/code&gt;已经比动态好了吧”。罗拉不解&lt;/p&gt;
&lt;p&gt;“话是这么说没错，不过这个虽然动态不是最优解，但是这个思路可以借鉴。这是思想”。&lt;/p&gt;
&lt;p&gt;“行吧，我试试”。&lt;/p&gt;
&lt;p&gt;“我第&lt;code&gt;i&lt;/code&gt;天的收益受到第&lt;code&gt;i-1&lt;/code&gt;天利润的影响”&lt;br/&gt;“但是每天其实就只有两个状态，是否持有股票”&lt;/p&gt;
&lt;p&gt;“我可以用一个二维数组&lt;code&gt;dp[prices.length+1][2]&lt;/code&gt;的数组来记录每天不同状态的最大利润”&lt;/p&gt;
&lt;p&gt;“其中&lt;code&gt;dp[i][0]&lt;/code&gt;表示第&lt;code&gt;i&lt;/code&gt;天不持有股票”。&lt;br/&gt;“会存在两种情况：”&lt;br/&gt;“1. 前一天不持有，即：&lt;code&gt;dp[i-1][0]&lt;/code&gt;”&lt;br/&gt;“2. 前一天持有，今天卖出,即：&lt;code&gt;dp[i-1][1]+prices[i]&lt;/code&gt;”&lt;/p&gt;
&lt;p&gt;“其中&lt;code&gt;dp[i][1]&lt;/code&gt;表示第&lt;code&gt;i&lt;/code&gt;天持有股票”。&lt;br/&gt;“也会存在两种情况：”&lt;br/&gt;“1. 前一天持有，今天不卖出继续持有，即：&lt;code&gt;dp[i-1][1]&lt;/code&gt;”&lt;br/&gt;“2. 前一天不持有，今天买入，即：&lt;code&gt;dp[i-1][0]-prices[i]&lt;/code&gt;”&lt;/p&gt;
&lt;p&gt;“对于边界值：”&lt;br/&gt;“第一天的两种情况为：”&lt;br/&gt;“&lt;code&gt;dp[1][0] = 0&lt;/code&gt;”&lt;br/&gt;“&lt;code&gt;dp[1][1] = -prices[0]&lt;/code&gt;”&lt;/p&gt;
&lt;p&gt;“所以代码实现为：”&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
public class StockTrading {
    public static void main(String[] args) {
        int[] prices = {7, 2, 5, 3, 6, 4, 7, 8, 2};
        int[] pricesUp = {2, 3, 4, 5, 6, 7, 8, 9};
        int[] pricesDown = {9, 8, 7, 6, 5, 4, 3, 2};
        System.out.println(&quot;prices 不限次交易最大利润为: &quot; + stockTrading2(prices));
        System.out.println(&quot;pricesUp 不限次交易最大利润为: &quot; + stockTrading2(pricesUp));
        System.out.println(&quot;pricesDown 不限次交易最大利润为: &quot; + stockTrading2(pricesDown));
    }

    public static int stockTrading2(int[] prices) {
        if (prices == null || prices.length &amp;lt; 2) return 0;
        int[][] dp = new int[prices.length + 1][2];//此处prices.length + 1是为了计算方便，所以后面的prices[i - 1]是相应调整的
        //初始化边界值
        //第一天不持有，利润为0，持有的即买入，此时利润为-prices[0]        
        dp[1][0] = 0;
        dp[1][1] = -prices[0];
        for (int i = 2; i &amp;lt; dp.length; i++) {
            //今天不持有有股票的情况为：
            //1. 前一天不持有，即：dp[i-1][0]
            //2. 前一天持有，今天卖出,即：dp[i-1][1]+prices[i-1]
            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i - 1]);
            //今天持有股票的情况为
            //1. 前一天持有，今天继续持有，即：dp[i-1][1]
            //2. 前一天不持有，今天买入，即：dp[i-1][0]-prices[i-1]
            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i - 1]);
        }
        //最后一天不持有应该是收益最大的，所以没必要再比较dp[prices.length][0]，dp[prices.length][1]了
        return dp[prices.length][0];
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;//输出结果
prices 不限次交易最大利润为: 10
pricesUp 不限次交易最大利润为: 7
pricesDown 不限次交易最大利润为: 0
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;“嗯，不错，那有没有可以优化的方法呢？比如空间复杂度我要&lt;code&gt;O(1)&lt;/code&gt;。”八哥继续追问&lt;/p&gt;
&lt;p&gt;“嗯，我想想。”&lt;br/&gt;“有了，因为他其实只和前一天的状态有关那么我只需要记录前一天的两个状态就可以了。”&lt;br/&gt;“可以这样实现。”罗拉兴奋道&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class StockTrading {
    public static void main(String[] args) {
        int[] prices = {7, 2, 5, 3, 6, 4, 7, 8, 2};
        int[] pricesUp = {2, 3, 4, 5, 6, 7, 8, 9};
        int[] pricesDown = {9, 8, 7, 6, 5, 4, 3, 2};
        System.out.println(&quot;prices 不限次交易最大利润为: &quot; + stockTrading2(prices));
        System.out.println(&quot;pricesUp 不限次交易最大利润为: &quot; + stockTrading2(pricesUp));
        System.out.println(&quot;pricesDown 不限次交易最大利润为: &quot; + stockTrading2(pricesDown));
    }

    public static int stockTrading2(int[] prices) {
        if (prices == null || prices.length &amp;lt; 2) return 0;
        //sell表示当天不持有股票，buy表示当天持有股票，其中第一天的状态如下
        int sell = 0,buy = -prices[0],tmp=0;
        for (int i = 1; i &amp;lt; prices.length; i++) {
            //今天不持有有股票的情况为：
            //1. 前一天不持有，即：sell
            //2. 前一天持有，今天卖出,即：buy+prices[i]
            tmp = sell;
            sell = Math.max(sell, buy + prices[i]);
            //今天持有股票的情况为
            //1. 前一天持有，今天继续持有，即：buy
            //2. 前一天不持有，今天买入，即：tmp-prices[i]
            buy = Math.max(buy, tmp - prices[i]);
        }
        //最后一天不持有应该是收益最大的，所以没必要再比较sell,buy
        return sell;
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;//输出结果
prices 不限次交易最大利润为: 10
pricesUp 不限次交易最大利润为: 7
pricesDown 不限次交易最大利润为: 0
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;“我可以通过两个标签记录该状态，达到降低空间复杂度的目的。”罗拉很得意自己想到办法了。&lt;/p&gt;
&lt;p&gt;“是的，其实很多动态都可以通过类似方式优化，本质上还是动态规划。”&lt;br/&gt;“看来第二种类型你也掌握的差不多了，是时候看看第三种了。”&lt;/p&gt;
&lt;p&gt;“还有？快说。”罗拉可是自信满满的&lt;/p&gt;
&lt;p&gt;“还有好几种呢，别急”&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;买卖股票的最佳时机含手续费&quot;&gt;买卖股票的最佳时机含手续费&lt;/h3&gt;
&lt;p&gt;“第三种的题目如下：”&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。&lt;br/&gt;你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。&lt;br/&gt;返回获得利润的最大值。&lt;br/&gt;注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;“其中一笔交易过程为：”&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1293390/202012/1293390-20201231224808400-852801899.png&quot; alt=&quot;交易过程&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;“这个不难吧，只要在前一个案例中出售股票的位置减掉手续费即可”&lt;br/&gt;“代码如下：”&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class StockTrading {
    public static void main(String[] args) {
        int[] prices = {1, 3, 2, 8, 4, 9};
        int[] pricesUp = {2, 3, 4, 5, 6, 7, 8, 9};
        int[] pricesDown = {9, 8, 7, 6, 5, 4, 3, 2};
        System.out.println(&quot;prices 不限次交易最大利润为: &quot; + stockTrading3(prices,2));
        System.out.println(&quot;pricesUp 不限次交易最大利润为: &quot; + stockTrading3(pricesUp,2));
        System.out.println(&quot;pricesDown 不限次交易最大利润为: &quot; + stockTrading3(pricesDown,2));
    }

    public static int stockTrading3(int[] prices,int fee) {
        if (prices == null || prices.length &amp;lt; 2) return 0;
        //sell表示当天不持有股票，buy表示当天持有股票，其中第一天的状态如下
        int sell = 0,buy = -prices[0],tmp=0;
        for (int i = 1; i &amp;lt; prices.length; i++) {
            //今天不持有有股票的情况为：
            //1. 前一天不持有，即：sell
            //2. 前一天持有，今天卖出,此时需要支付手续费,即：buy+prices[i]-fee
            tmp = sell;
            sell = Math.max(sell, buy + prices[i]-fee);
            //今天持有股票的情况为
            //1. 前一天持有，今天继续持有，即：buy
            //2. 前一天不持有，今天买入，即：tmp-prices[i]
            buy = Math.max(buy, tmp - prices[i]);
        }
        //最后一天不持有应该是收益最大的，所以没必要再比较sell,buy
        return sell;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;//输出结果
prices 不限次交易最大利润为: 8
pricesUp 不限次交易最大利润为: 5
pricesDown 不限次交易最大利润为: 0
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;“其他版本大同小异，我就不写了，赶紧来点有难度的。”罗拉不屑道&lt;/p&gt;
&lt;p&gt;“哎，年轻人，别毛毛躁躁，请看下一题”&lt;/p&gt;
&lt;hr/&gt;&lt;h4 id=&quot;买卖股票的最佳时机含冷冻期&quot;&gt;买卖股票的最佳时机含冷冻期&lt;/h4&gt;
&lt;p&gt;“下面是第四种类型，题目如下：”&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。&lt;br/&gt;设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）。&lt;br/&gt;你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。&lt;br/&gt;卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;“完整交易周期为：”&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1293390/202012/1293390-20201231224903321-584912901.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;“你看看此时要怎么做？”&lt;/p&gt;
&lt;p&gt;“我看看，还想比之前复杂，不过应该也是一脉相传，”罗拉自语&lt;/p&gt;
&lt;p&gt;“首先现在是有三个状态，卖出，买入、冷冻期。”&lt;br/&gt;“那我可以定义三个状态&lt;code&gt;0，1，2&lt;/code&gt;分别表示三个状态。”&lt;br/&gt;“定义动态数据&lt;code&gt;dp[i][j]&lt;/code&gt;,表示第&lt;code&gt;i&lt;/code&gt;天，状态&lt;code&gt;j&lt;/code&gt;的最大利润，其中&lt;code&gt;j&lt;/code&gt;的取值为&lt;code&gt;{0，1，2}&lt;/code&gt;”&lt;/p&gt;
&lt;p&gt;“那么此时的状态转移可以总结如下：”&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;状态&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;th&gt;转换&lt;/th&gt;
&lt;th&gt;注释&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;6&quot;&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;&lt;code&gt;dp[i][0]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;此时为卖出状态&lt;/td&gt;
&lt;td&gt;&lt;code&gt;max(dp[i - 1][0], dp[i - 1][1] + prices[i])&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;此时存在两种情况&lt;br/&gt;1. 前一天是已经卖出了&lt;br/&gt;2. 前一天处于买入状态今天卖出&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;&lt;code&gt;dp[i][1]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;此时为买入状态&lt;/td&gt;
&lt;td&gt;&lt;code&gt;max(dp[i - 1][1], dp[i - 1][2] - prices[i])&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;此时存在两种情况&lt;br/&gt;1. 前一天为买入状态&lt;br/&gt;2. 前一天为冷冻期，今天买入&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;dp[i][2]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;此时为冷冻期&lt;/td&gt;
&lt;td&gt;&lt;code&gt;dp[i - 1][0]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;此时存在一种情况&lt;br/&gt;1. 前一天为卖出状态&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;“此时代码实现如下”&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class StockTrading {
    public static void main(String[] args) {
        int[] prices = {1, 3, 2, 8, 4, 9};
        int[] pricesUp = {2, 3, 4, 5, 6, 7, 8, 9};
        int[] pricesDown = {9, 8, 7, 6, 5, 4, 3, 2};
        System.out.println(&quot;prices 不限次交易最大利润为: &quot; + stockTrading4(prices));
        System.out.println(&quot;pricesUp 不限次交易最大利润为: &quot; + stockTrading4(pricesUp));
        System.out.println(&quot;pricesDown 不限次交易最大利润为: &quot; + stockTrading4(pricesDown));
    }

    public static int stockTrading4(int[] prices) {
        if (prices == null || prices.length &amp;lt; 2) return 0;
        int n = prices.length;
        int[][] dp = new int[n][3];
        //初始化边界(卖出，买入)
        dp[0][0] = 0;
        dp[0][1] = -prices[0];
        dp[1][2] = 0;
        for (int i = 1; i &amp;lt; n; i++) {
            //此时为卖出状态，要么前一天是已经卖出了dp[i-1][0]，要么就是昨天处于买入状态今天卖出获得收益dp[i-1][1]+prices[i]
            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
            //此时为买入状态，只能是前一天为买入状态dp[i-1][1]或者前一天为冷冻期，今天买入,花费金钱dp[i-1][2]-prices[i]
            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][2] - prices[i]);
            //此时为冷冻期，此时只有前一天为卖出状态``dp[i-1][0]``，今天不操作
            dp[i][2] = dp[i - 1][0];
        }
        return Math.max(dp[n-1][0], dp[n - 1][2]);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;//输出结果
prices 不限次交易最大利润为: 8
pricesUp 不限次交易最大利润为: 7
pricesDown 不限次交易最大利润为: 0
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;“不错，这个动态比较好理解，那你接下来可以在这基础上做一下空间压缩吗？”八哥继续追问。&lt;/p&gt;
&lt;p&gt;“应该问题不大，我试试。”&lt;br/&gt;“根据上边的推到公式，我们可以知道动态状态转移为：”&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][2] - prices[i]);
dp[i][2] = dp[i - 1][0];
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;“而最终的结果为：”&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Math.max(dp[n - 1][0], dp[n - 1][2])
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;“根据这两个&lt;code&gt;dp[n - 1][0], dp[n - 1][2]&lt;/code&gt;可知：”&lt;br/&gt;“我们计算当日的最大利润只跟&lt;code&gt;dp[i - 1][0],dp[i - 1][1],dp[i - 1][2]&lt;/code&gt;有关”&lt;br/&gt;“即之和前一天的卖出、买入、冷冻期的最大利润有关”&lt;br/&gt;“所以我们只需要记录最新的三个状态即可，无需记录所有的状态。”&lt;br/&gt;“实现如下：”&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class StockTrading {
    public static void main(String[] args) {
        int[] prices = {1, 3, 2, 8, 4, 9};
        int[] pricesUp = {2, 3, 4, 5, 6, 7, 8, 9};
        int[] pricesDown = {9, 8, 7, 6, 5, 4, 3, 2};
        System.out.println(&quot;prices 不限次交易最大利润为: &quot; + stockTrading4(prices));
        System.out.println(&quot;pricesUp 不限次交易最大利润为: &quot; + stockTrading4(pricesUp));
        System.out.println(&quot;pricesDown 不限次交易最大利润为: &quot; + stockTrading4(pricesDown));
    }

    public static int stockTrading4(int[] prices) {
        if (prices == null || prices.length &amp;lt; 2) return 0;
        int n = prices.length;
        //初始化边界(卖出，买入)
        int dp0 = 0,dp1 = -prices[0],dp2= 0,tmp;
        for (int i = 1; i &amp;lt; n; i++) {
            tmp=dp0;
            //此时为卖出状态，要么前一天是已经卖出了dp0，要么就是昨天处于买入状态今天卖出获得收益dp1+prices[i]
            dp0 = Math.max(dp0, dp1 + prices[i]);
            //此时为买入状态，只能是前一天为买入状态dp1或者前一天为冷冻期，今天买入,花费金钱dp2 -prices[i]
            dp1 = Math.max(dp1, dp2 - prices[i]);
            //此时为冷冻期，此时只有前一天为卖出状态``dp0``，今天不操作
            dp2 = tmp;
        }
        return Math.max(dp0, dp2);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;//输出结果
prices 不限次交易最大利润为: 8
pricesUp 不限次交易最大利润为: 7
pricesDown 不限次交易最大利润为: 0
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;“这样的话空间复杂度就可以下降到&lt;code&gt;O(1)&lt;/code&gt;和之前的方法类似”&lt;/p&gt;
&lt;p&gt;“是的，压缩空间是动态规划常用的优化方法，一般只要是依赖的状态只是前一个或几个状态，我们就可以通过类似的方法优化。”&lt;/p&gt;
&lt;p&gt;“第四种你也做出来了，要不要来第五个？”八哥笑道&lt;/p&gt;
&lt;p&gt;“还有？还有几个？”罗拉显然有点吃惊&lt;/p&gt;
&lt;p&gt;“还有两个，前面的相对简单的，后面这两个有点难度，要试试不？”&lt;/p&gt;
&lt;p&gt;“试试吧，都这个时候，放弃有点不甘心。” 罗拉一咬牙有了决断&lt;/p&gt;
&lt;p&gt;“有志气，请听题”&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;买卖股票的最佳时机最多交易两次&quot;&gt;买卖股票的最佳时机(最多交易两次)&lt;/h3&gt;
&lt;p&gt;“题目是：”&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。&lt;br/&gt;设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。&lt;br/&gt;注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;完整的两次交易为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1293390/202012/1293390-20201231225006175-683826811.png&quot; alt=&quot;完整的两次交易&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;“你看看这个要怎么分析？有点难度哦”&lt;/p&gt;
&lt;p&gt;“嗯，我试试”&lt;br/&gt;“这个其实类似第二个场景吧，就是：买卖股票的最佳时机(交易多次)”&lt;br/&gt;“这不过这里限制了两次，当时只考虑当天的状态为：持有或者卖出，此时控制考虑了一个维度”&lt;br/&gt;“但是我们除了考虑当天是持有，还是卖出外，还得考虑是第几次交易，我们最多只能进行两次交易，也就是我们还缺一个状态”&lt;/p&gt;
&lt;p&gt;“既然这样我们可以增加一个状态，记录已经交易了几次，即已经卖出多少次”&lt;br/&gt;“这样我们的状态数据就可以变成&lt;code&gt;dp[天数][当前是否持股][卖出的次数]=&amp;gt;dp[i][j][k]&lt;/code&gt;”&lt;br/&gt;“这样每天会有六个状态，分别为：”&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;编号&lt;/th&gt;
&lt;th&gt;状态&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;th&gt;状态转换&lt;/th&gt;
&lt;th&gt;备注&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;21.5&quot;&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;&lt;code&gt;dp[i][0][0]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;第&lt;code&gt;i&lt;/code&gt;天不持有股票&lt;br/&gt;交易&lt;code&gt;0&lt;/code&gt;次&lt;/td&gt;
&lt;td&gt;&lt;code&gt;0 或 dp[i-1][0][0]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;即从头到尾都没有交易过,利润为0&lt;br/&gt;没有进行过交易&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;8&quot;&gt;&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;&lt;code&gt;dp[i][0][1]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;第&lt;code&gt;i&lt;/code&gt;天不持有股票&lt;br/&gt;交易&lt;code&gt;1&lt;/code&gt;次&lt;/td&gt;
&lt;td&gt;&lt;code&gt;max(dp[i-1][1][0] + prices[i], dp[i-1][0][1])&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;此时可能情况为：&lt;br/&gt;1. 前一天持有，在今天卖出&lt;br/&gt;2. 前一天不持有，很早以前就卖了一次&lt;br/&gt;ps：已经完成了第一轮交易&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;9&quot;&gt;&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;&lt;code&gt;dp[i][0][2]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;第&lt;code&gt;i&lt;/code&gt;天不持有股票&lt;br/&gt;交易&lt;code&gt;2&lt;/code&gt;次&lt;/td&gt;
&lt;td&gt;&lt;code&gt;max(dp[i-1][1][1] + prices[i], dp[i-1][0][2])&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;此时可能情况为：&lt;br/&gt;1. 前一天持有,今天卖出&lt;br/&gt;2. 前一天不持有，很早以前卖出&lt;br/&gt;ps：已经完成了第二轮交易&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;9&quot;&gt;&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;&lt;code&gt;dp[i][1][0]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;第&lt;code&gt;i&lt;/code&gt;天持有股票&lt;br/&gt;交易&lt;code&gt;0&lt;/code&gt;次&lt;/td&gt;
&lt;td&gt;&lt;code&gt;max(dp[i-1][1][0], dp[i-1][0][0] - prices[i])&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;此时可能情况为：&lt;br/&gt;1. 前一天就持有股票,今天继续持有&lt;br/&gt;2. 前一天未持今天买入&lt;br/&gt;ps：进行第一轮交易的持有操作&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;8&quot;&gt;&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;&lt;code&gt;dp[i][1][1]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;第&lt;code&gt;i&lt;/code&gt;天持有股票&lt;br/&gt;交易&lt;code&gt;1&lt;/code&gt;次&lt;/td&gt;
&lt;td&gt;&lt;code&gt;max(dp[i-1][1][1], dp[i-1][0][1] - prices[i])&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;此时可能情况为：&lt;br/&gt;1. 前一天就持有股票，今天继续持有&lt;br/&gt;2. 前一天未持有今天买入&lt;br/&gt;ps：进行第二轮交易的持有操作&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;&lt;code&gt;dp[i][1][2]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;第&lt;code&gt;i&lt;/code&gt;天持有股票&lt;br/&gt;交易&lt;code&gt;2&lt;/code&gt;次&lt;/td&gt;
&lt;td&gt;&lt;code&gt;0&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;此时超出我们交易次数限制&lt;br/&gt;直接返回0即可&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;“关于最终结果”&lt;br/&gt;“我可以是交易一次，也可以是交易两次，也可以不交易，只要保证利润最大即可”&lt;/p&gt;
&lt;p&gt;“至于初始值”&lt;br/&gt;“第一天只有第一次买入和不操作才是正常，其他四种情况都是非法，直接给个最小值就可以了”&lt;/p&gt;
&lt;p&gt;“你看我分析的对吗？”&lt;/p&gt;
&lt;p&gt;“可以啊，罗拉，你这思路很正确啊”八哥看了罗拉分析，有点惊讶罗拉居然一次就分析出来了。&lt;/p&gt;
&lt;p&gt;“毕竟也做了这么多动态了，还有前面几个案例打底，应该的，应该的。”&lt;br/&gt;罗拉也是小小骄傲一下，当然还是得低调。&lt;/p&gt;
&lt;p&gt;“既然分析出来了，show me your code”&lt;/p&gt;
&lt;p&gt;“行，既然都写出状态转换了，代码还不容易？等着”&lt;/p&gt;
&lt;p&gt;几分钟后&lt;/p&gt;
&lt;p&gt;“诺，实现了，你看看”&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class StockTrading {
    public static void main(String[] args) {
        int[] prices = {3, 3, 5, 0, 0, 3, 1, 4};
        int[] pricesUp = {2, 3, 4, 5, 6, 7, 8, 9};
        int[] pricesDown = {9, 8, 7, 6, 5, 4, 3, 2};
        System.out.println(&quot;prices 不限次交易最大利润为: &quot; + stockTrading5(prices));
        System.out.println(&quot;pricesUp 不限次交易最大利润为: &quot; + stockTrading5(pricesUp));
        System.out.println(&quot;pricesDown 不限次交易最大利润为: &quot; + stockTrading5(pricesDown));
    }

    public static int stockTrading5(int[] prices) {
        //对于任意一天，我可能得状态为持股，或者不持股，并且可能已经交易了多次了。
        //所以我可以记录第i天的两个维度的状态：dp[天数][当前是否持股][卖出的次数]=&amp;gt;dp[i][j][k]
        //所以每一天就有六种情况,分别为
        //1. 第i天不持有股票，交易0次，即从头到尾都没有交易过,，利润为0，(没有进行过交易)
        //dp[i][0][0] = 0;（也可以写成 dp[i][0][0] = dp[i - 1][0][0]，因为前一天也一定是一样的状态）
        //2. 第i天不持有股票，交易1次，此时可能是昨天持有，未卖出过，在今天卖出（今天才卖）；或是昨天不持有，但是已经买出一次（很早以前就卖了）(已经完成了一轮轮交易)
        //dp[i][0][1] = Math.max(dp[i - 1][1][0] + prices[i], dp[i - 1][0][1]);
        //3. 第i天不持有股票，交易2次，此时可能是此时可能是昨天持有并且已经卖出一次，第二次持有未卖出过，在今天卖出（今天才卖）；或是昨天不持有，但是已经买出两次(此时为第一轮买入)(已经完成了两轮交易)
        //dp[i][0][2] = Math.max(dp[i - 1][1][1] + prices[i], dp[i - 1][0][2]);
        //4. 第i天持有股票,交易0次，此时可能是前一天就持有股票，今天继续持有；或者昨天未持今天买入(此时为第一轮买入)
        //dp[i][1][0] = Math.max(dp[i - 1][1][0], dp[i - 1][0][0] - prices[i]);
        //5. 第i天持有股票,交易1次，此时可能是前一天就持有股票，今天继续持有；或者昨天未持今天买入(此时为第二轮买入)
        // dp[i][1][1] = Math.max(dp[i - 1][1][1], dp[i - 1][0][1] - prices[i]);
        //6. 第i天持有股票,交易2次，此时超出我们交易次数限制，直接返回0即可
        //dp[i][1][2] = 0;
        int[][][] dp = new int[prices.length + 1][2][3];
        //不操作，所以利润为0
        dp[0][0][0] = 0;
        //买入股票，所以为支出
        dp[0][1][0] = -prices[0];
        //不可能情况
        int MIN_VALUE = Integer.MIN_VALUE &amp;gt;&amp;gt; 1;//因为最小值再减去1就是最大值Integer.MIN_VALUE-1=Integer.MAX_VALUE,所以不能直接用最小值，可以极限设置为int MIN_VALUE = - prices[0] - 1；
        dp[0][0][1] = MIN_VALUE;
        dp[0][0][2] = MIN_VALUE;
        dp[0][1][1] = MIN_VALUE;
        dp[0][1][2] = MIN_VALUE;

        for (int i = 1; i &amp;lt; prices.length; i++) {
            dp[i][0][0] = 0;
            dp[i][0][1] = Math.max(dp[i - 1][1][0] + prices[i], dp[i - 1][0][1]);
            dp[i][0][2] = Math.max(dp[i - 1][1][1] + prices[i], dp[i - 1][0][2]);
            dp[i][1][0] = Math.max(dp[i - 1][1][0], dp[i - 1][0][0] - prices[i]);
            dp[i][1][1] = Math.max(dp[i - 1][1][1], dp[i - 1][0][1] - prices[i]);
            dp[i][1][2] = 0;

        }
        //最终的结果我可以是交易一次，也可以是交易两次，也可以不交易，但是不管怎样，最终的状态都是不持有股票
        return Math.max(dp[prices.length - 1][0][1], dp[prices.length - 1][0][2] &amp;gt; 0 ? dp[prices.length - 1][0][2] : 0);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;//输出结果
prices 不限次交易最大利润为: 6
pricesUp 不限次交易最大利润为: 7
pricesDown 不限次交易最大利润为: 0
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意：这里MIN_VALUE一定要设置为比&lt;code&gt;(-prices[0])&lt;/code&gt;小，具体原因，看看转换关系就知道了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;“不错，现在问题来了，你能压缩一下空间吗？毕竟三维数据是需要占据一定空间的。”八哥进一步问道&lt;/p&gt;
&lt;p&gt;“我觉得我可以试试，按照前面思路应该有迹可循”&lt;br/&gt;罗拉想了一下&lt;br/&gt;“根据之前的状态转换可知”&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;dp[i][0][0] = 0;
dp[i][0][1] = Math.max(dp[i - 1][1][0] + prices[i], dp[i - 1][0][1]);
dp[i][0][2] = Math.max(dp[i - 1][1][1] + prices[i], dp[i - 1][0][2]);
dp[i][1][0] = Math.max(dp[i - 1][1][0], dp[i - 1][0][0] - prices[i]);
dp[i][1][1] = Math.max(dp[i - 1][1][1], dp[i - 1][0][1] - prices[i]);
dp[i][1][2] = 0;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;“虽然有六个状态，真正决定最后利润的只有四个状态”&lt;br/&gt;“分别为&lt;code&gt;dp[i][0][1]、dp[i][0][2]，dp[i][1][0]，dp[i][1][1]&lt;/code&gt;”&lt;br/&gt;“我们可以把这个四个状态用一个变量表示当前状态的最大利润，如下：”&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;状态&lt;/th&gt;
&lt;th&gt;变量&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;th&gt;状态转换&lt;/th&gt;
&lt;th&gt;备注&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;8.5&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;dp[i][1][0]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;fstBuy&lt;/td&gt;
&lt;td&gt;第一次买&lt;/td&gt;
&lt;td&gt;&lt;code&gt;max(fstBuy, -price)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;此时可能情况为：&lt;br/&gt;1. 之前买了第一次&lt;br/&gt;2. 现在买第一次&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;&lt;code&gt;dp[i][0][1]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;fstSell&lt;/td&gt;
&lt;td&gt;第一次卖&lt;/td&gt;
&lt;td&gt;&lt;code&gt;max(fstSell, fstBuy + price)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;此时可能情况为：&lt;br/&gt;1. 之前就卖了第一次&lt;br/&gt;2. 现在第一次卖&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;&lt;code&gt;dp[i][1][1]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;secBuy&lt;/td&gt;
&lt;td&gt;第二次买&lt;/td&gt;
&lt;td&gt;&lt;code&gt;max(secBuy, fstSell - price)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;此时可能情况为：&lt;br/&gt;1. 之前买了第二次&lt;br/&gt;2. 现在第二次买&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;&lt;code&gt;dp[i][0][2]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;secSell&lt;/td&gt;
&lt;td&gt;第二次卖&lt;/td&gt;
&lt;td&gt;&lt;code&gt;max(secSell, secBuy + price)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;此时可能情况为：&lt;br/&gt;1. 之前已经卖了第二次&lt;br/&gt;2. 现在才第二次卖&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;“此时的代码实现如下：”&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class StockTrading {
    public static void main(String[] args) {
        int[] prices = {3, 3, 5, 0, 0, 3, 1, 4};
        int[] pricesUp = {2, 3, 4, 5, 6, 7, 8, 9};
        int[] pricesDown = {9, 8, 7, 6, 5, 4, 3, 2};
        System.out.println(&quot;prices 不限次交易最大利润为: &quot; + stockTrading5(prices));
        System.out.println(&quot;pricesUp 不限次交易最大利润为: &quot; + stockTrading5(pricesUp));
        System.out.println(&quot;pricesDown 不限次交易最大利润为: &quot; + stockTrading5(pricesDown));
    }

    public static int stockTrading5(int[] prices) {
        //注意第一次卖和第二次卖的初始值，一定要比prices[0]小
        int fstBuy = Integer.MIN_VALUE, fstSell = 0;
        int secBuy = Integer.MIN_VALUE, secSell = 0;
        for (int price : prices) {
            //第一次买：要么之前买过，要么现在买
            fstBuy = Math.max(fstBuy, -price);
            //第一次卖，要么之前就卖了，要么现在第一次卖
            fstSell = Math.max(fstSell, fstBuy + price);
            //第二次买:要么之前买了，要么现在第二次买
            secBuy = Math.max(secBuy, fstSell - price);
            //第二次卖：要么之前已经卖了，要么现在才第二次卖
            secSell = Math.max(secSell, secBuy + price);
        }
        return secSell;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;//输出结果
prices 不限次交易最大利润为: 6
pricesUp 不限次交易最大利润为: 7
pricesDown 不限次交易最大利润为: 0
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;“你看看”&lt;/p&gt;
&lt;p&gt;“嗯，不错，看来循序渐进还是很不错的，如果一开始直接给你这个估计你就蒙逼了”&lt;/p&gt;
&lt;p&gt;“确实，有前面的打底，思路比较清晰，如果直接上来就是这个，老实说毫无思路。”罗拉爽快承认&lt;br/&gt;“话说还有一个吧，看看最后一个能不能做出来。”罗拉做了几个，热情上来了，有点难以阻挡&lt;/p&gt;
&lt;p&gt;“好，还有最后一个，请看题”&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;买卖股票的最佳时机k次交易&quot;&gt;买卖股票的最佳时机(k次交易)&lt;/h3&gt;
&lt;p&gt;“第六个题目是：”&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。&lt;br/&gt;设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。&lt;br/&gt;注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;“完整的k次交易为：”&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1293390/202012/1293390-20201231225109909-385257873.png&quot; alt=&quot;完整的k次交易为&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;“请问现在要如何做？”&lt;/p&gt;
&lt;p&gt;“这...,字面意义告诉我，这个是第五个拓展，可以在第五个的基础上想想。” 罗拉想了一会道&lt;/p&gt;
&lt;p&gt;“确实，不过能不能想出来就是另一个问题了”&lt;/p&gt;
&lt;p&gt;“我试试”&lt;br/&gt;“对于每一天来说，我只有两个状态，持有或者不持有”&lt;br/&gt;“但是我们现在因为交易次数k的限制，我们必须要考虑每一次交易的状态”&lt;br/&gt;“所以我们可以增加一个唯独来描述现在是第几次交易”&lt;br/&gt;“对此可以通过&lt;code&gt;dp[卖出的次数][当前是否持股]=dp[k][i]&lt;/code&gt;来记录状态”&lt;br/&gt;“其中&lt;code&gt;i={0，1}；0表示卖出,1表示持有&lt;/code&gt;”&lt;br/&gt;“相应的状态转换也可以列出来，如下表”&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;状态&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;th&gt;状态转换&lt;/th&gt;
&lt;th&gt;备注&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;dp[i][0]&lt;/td&gt;
&lt;td&gt;第i次不持有&lt;/td&gt;
&lt;td&gt;&lt;code&gt;max(dp[i][0],dp[i][1]+price)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;此时可能情况为：&lt;br/&gt;1. 本来不持有，这次不操作&lt;br/&gt;2. 第i次持有现在卖出&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;dp[i][1]&lt;/td&gt;
&lt;td&gt;第i次持有&lt;/td&gt;
&lt;td&gt;&lt;code&gt;max(dp[i][1],dp[i-1][0]-price)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;此时可能情况为：&lt;br/&gt;1. 本来持有，这次不操作&lt;br/&gt;2. 前一次不持有，现在买入&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;“那先在就可以写出相应的代码了”&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class StockTrading {
    public static void main(String[] args) {
        int[] prices = {3, 3, 5, 0, 0, 3, 1, 4};
        int[] pricesUp = {2, 3, 4, 5, 6, 7, 8, 9};
        int[] pricesDown = {9, 8, 7, 6, 5, 4, 3, 2};
        System.out.println(&quot;prices 不限次交易最大利润为: &quot; + stockTrading6(prices, 2));
        System.out.println(&quot;pricesUp 不限次交易最大利润为: &quot; + stockTrading6(pricesUp, 7));
        System.out.println(&quot;pricesDown 不限次交易最大利润为: &quot; + stockTrading6(pricesDown, 7));
    }

    public static int stockTrading6(int[] prices, int k) {
        //如果交易次数小于1，返回0
        if (k &amp;lt; 1) return 0;
        //如果交易次数大于等于数组长度，此时就是第二种情况
        if (k &amp;gt;= prices.length / 2) return stockTrading2(prices);
        //每一天只有两个状态：买入和卖出
        //但是我们需要考虑次数k限制，所以我们可以增加一个维度描述第几次交易
        //dp[卖出的次数][当前是否持股]=dp[k][i],其中1={0，1}；0表示卖出,1表示持有
        //此时只有两种状态：
        //1.第i次不持有：此时情况为：本来不持有，这次不操作；要么第i次持有现在卖出
        //dp[i][0] = (dp[i][0],dp[i][1]+price)
        //2.第i次持有：此时情况为：本来持有，这次不操作；要么前一次不持有持有现在买入
        //dp[i][1] = (dp[i][1],dp[i-1][0]-price)
        int[][] dp = new int[k][2];
        //边界值：初始持有的最小值一定要小于prices的最小值
        for (int i = 0; i &amp;lt; k; i++) dp[i][1] = Integer.MIN_VALUE;
        for (int price : prices) {
            //注意要重设第一次交易的初始值，否则存在某一天多次交易问题
            //第一次不持有：要么之前就不持有，此时不操作；要么之前持有，现在第一次卖出入
            dp[0][0] = Math.max(dp[0][0], dp[0][1] + price);
            //第一次持有: 要么之前就是第一次持有，此时不操作；要么之前不持有，现在第一次买入
            dp[0][1] = Math.max(dp[0][1], -price);
            for (int i = 1; i &amp;lt; k; i++) {
                dp[i][0] = Math.max(dp[i][0], dp[i][1] + price);
                dp[i][1] = Math.max(dp[i][1], dp[i - 1][0] - price);
            }
        }
        return dp[k - 1][0];
    }

    public static int stockTrading2(int[] prices) {
        if (prices == null || prices.length &amp;lt; 2) return 0;
        int sell = 0, buy = -prices[0], tmp = 0;
        for (int i = 1; i &amp;lt; prices.length; i++) {
            tmp = sell;
            sell = Math.max(sell, buy + prices[i]);
            buy = Math.max(buy, tmp - prices[i]);
        }
        return sell;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;//输出结果：
prices 不限次交易最大利润为: 6
pricesUp 不限次交易最大利润为: 7
pricesDown 不限次交易最大利润为: 0
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;此处需要注意去掉一天多次交易的问题，&lt;br/&gt;这个可以通过逆序内循环解决，也可以通过每次重复初始化第一天状态解决。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;“怎样，结果没错吧”罗拉得意道&lt;/p&gt;
&lt;p&gt;“确实，很不错了，我还以为你会用三个dp[天数][是否持有股票][第k次交易]的方式来做，比我预想的好。”八哥感慨。&lt;/p&gt;
&lt;p&gt;“一开始确实这么想，但是毕竟前面也有过有过优化方案，就想着直接优化后的方案看看能不能写出来，看来还挺顺利的。”&lt;br/&gt;“这个还能优化嘛？”罗拉疑惑道。&lt;/p&gt;
&lt;p&gt;“学无止境，应该还有优化的空间吧，不过我目前也没想到比你现在更好的方法吧”&lt;/p&gt;
&lt;p&gt;“哎，要是我炒股也能这样，富婆梦早就实现了”&lt;/p&gt;
&lt;p&gt;“得了吧，把股票价格都列出来来给你，谁还炒股...”八哥无限鄙视罗拉。&lt;/p&gt;
&lt;p&gt;“先打住，出去吃饭吧，今晚跨年呢”&lt;/p&gt;
&lt;p&gt;“行，走吧，去送别2020”&lt;/p&gt;
&lt;p&gt;现在是20201231号，提前祝大家元旦快乐。&lt;/p&gt;
&lt;p&gt;本文为原创文章，转载请注明出处！！！&lt;/p&gt;
&lt;p&gt;欢迎关注【兔八哥杂谈】&lt;/p&gt;
</description>
<pubDate>Thu, 31 Dec 2020 15:01:00 +0000</pubDate>
<dc:creator>lillcol</dc:creator>
<og:description>此系列为动态规划相关文章。 系列历史文章： 算法系列-动态规划(1)：初识动态规划 算法系列-动态规划(2)：切割钢材问题 算法系列-动态规划(3)：找零钱、走方格问题 算法系列-动态规划(4)：买卖</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lillcol/p/14218940.html</dc:identifier>
</item>
<item>
<title>CMS、G1收集器 - _热风</title>
<link>http://www.cnblogs.com/refeng/p/14218952.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/refeng/p/14218952.html</guid>
<description>&lt;h2 id=&quot;1、cms收集器&quot;&gt;1、CMS收集器&lt;/h2&gt;
&lt;p&gt;CMS(Concurrent Mark Sweep) 收集器是一种以&lt;strong&gt;获取最短回收停顿时间&lt;/strong&gt;为目标的收集器。优点是&lt;strong&gt;并发收集、低停顿&lt;/strong&gt;。目前很大一部分的Java 应用集中在互联网站或者B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。CMS收集器就非常符合这类应用的需求。&lt;/p&gt;
&lt;h3 id=&quot;11、原理&quot;&gt;1.1、原理&lt;/h3&gt;
&lt;p&gt;CMS收集器基于“&lt;strong&gt;标记—清除&lt;/strong&gt;”算法实现，整个过程分为四个步骤：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;初始标记&lt;/strong&gt;（initial mark）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;并发标记&lt;/strong&gt;（concurrent mark）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;重新标记&lt;/strong&gt;（remark）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;并发清除&lt;/strong&gt;（concurrent sweep）&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/refeng/1909700/o_201231145708u=2304504768,1053283755&amp;amp;fm=26&amp;amp;gp=0.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中，初始标记、重新标记这两个步骤仍然需要Stop-The-World。初始标记仅仅只是标记一下GC Roots 能直接关联到的对象，速度很快，并发标记阶段就是进行Gc Roots Tracing的过程。而重新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录。由于整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作，所以，从总体上来说，CMS 收集器的内存回收过程是与用户线程一起并发执行的。&lt;/p&gt;
&lt;h3 id=&quot;12、不足&quot;&gt;1.2、不足&lt;/h3&gt;
&lt;p&gt;（1）对CPU 资源非常敏感。&lt;/p&gt;
&lt;p&gt;其实， 面向并发设计的程序都对 CPU 资源比较敏感。在并发阶段，它虽然不会导致用户线程停顿， 但是会因为占用了一部分线程（或者说 CPU 资源）而导致应用程序变慢，总吞吐量会降低。CMS 默认启动的回收线程数是 (CPU 数量+3) /4, 也就是当 CPU 在 4 个以上时， 并发回收时垃圾收集线程不少于25% 的CPU资源，并且随着 CPU 数量的增加而下降。但是当 CPU 不足4个（比如 2 个）时，CMS 对用户程序的影响就可能变得很大，如果本来CPU负载就比较大，还分出一半的运算能力去执行收集器线程，就可能导致用户程序的执行速度忽然降低了 50%，让人无法接受。&lt;/p&gt;
&lt;p&gt;（2）无法处理浮动垃圾（Floating Garbage），可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。&lt;/p&gt;
&lt;p&gt;由于CMS并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法在当次收集中处理掉它们，只好留待下一次GC时再清理掉。这一部分垃圾就称为“&lt;strong&gt;浮动垃圾&lt;/strong&gt;”。也是由于在垃圾收集阶段用户线程还需要运行，那也就还需要预留有足够的内存空间给用户线程使用，因此CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，需要预留一部分空间提供并发收集时的程序运作使用。&lt;/p&gt;
&lt;p&gt;在JDK1.5的默认设置下，CMS收集器当老年代使用了68%的空间后就会被激活，这是一个偏保守的设置，如果在应用中老年代增长不是太快， 可以适当调高参数-XX:CMSInitiatingOccupancyFraction的值来提高触发百分比，以便降低内存回收次数从而获取更好的性能，在JDK1.6中，CMS收集器的启动阈值已经提升至92%。要是CMS运行期间预留的内存无法满足程序需要，就会出现一次 &quot;Concurrent Mode Failure&quot;失败，这时虚拟机将启动后备预案：临时启用SerialOld 收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。所以说参数-XX:CMSlnitiatingOccupancyFraction设置得太高很容易导致大量&quot;Concurrent Mode Failure&quot; 失败，性能反而降低。&lt;/p&gt;
&lt;p&gt;（3）空间碎片的产生。&lt;/p&gt;
&lt;p&gt;因为是采用”标记—清除”算法，意味着收集结束时会有大量空间碎片产生。空间碎片过多时，将会给大对象分配带来很大麻烦，往往会出现老年代还有很大空间剩余，但是无法找到足够大的连续空间来分配当前对象，不得不提前触发一次Full GC。&lt;/p&gt;
&lt;p&gt;为了解决这个问题，CMS收集器提供了一个-XX:+UseCMSCompactAtFullCollection开关参数（默认就是开启的），用于在CMS收集器顶不住要进行Full GC时开启内存碎片的合并整理过程，内存整理的过程是无法并发 的，空间碎片问题没有了，但停顿时间不得不变长。虚拟机设计者还提供了另外一个参数-XX:CMSFullGCsBeforeCompaction,这个参数是用于设置执行多少次不压缩的 Full GC后，跟着来一次带压缩的（默认值为0，表示每次进人Full GC时都进行碎片整理）。&lt;/p&gt;
&lt;h2 id=&quot;2、g1收集器&quot;&gt;2、G1收集器&lt;/h2&gt;
&lt;h3 id=&quot;21、特点&quot;&gt;2.1、特点&lt;/h3&gt;
&lt;p&gt;G1（Garbage-Firsts，&lt;strong&gt;优先处理价值大的内存块&lt;/strong&gt;）收集器是当今收集器技术发展的最前沿成果之一，并且还在不断发展、完善，与其他GC收集器相比G1具备如下特点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;并行与并发：G1能充分利用多CPU、多核环境下的硬件优势，使用多个CPU（CPU 或者CPU核心）来缩短Stop-The-World停顿的时问，部分其他收集器原本需要停顿 Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让JAVA程序继续执行&lt;/li&gt;
&lt;li&gt;分代收集：与其他收集器一样，分代概念在G1中依然得以保留。虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但它能够采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次GC的旧对象以获取更好的收集效果。&lt;/li&gt;
&lt;li&gt;空间整合：与CMS的“标记一清理”算法不同，G1从整体来看是基于“标记—整理”算法实现的收集器，从局部（两个Region之间）上来看是基于“复制”算法实现的，但无论如何，这两种算法都意味着G1运作期间不会产生内存空间碎片，收集后能提供规整的可用内存。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。&lt;/li&gt;
&lt;li&gt;可预测的停顿：这是G1相对于CMS的另一大优势，降低停顿时间是G1和CMS共同的关注点，但G1除了追求低停顿外，还能建立&lt;strong&gt;可预测的停顿时间模型&lt;/strong&gt;，能让使用者明确指定在一个长度为M亳秒的时间片段内，消耗在垃圾收集上的时间不得超过N亳秒，这几乎已经是实时Java(RTSJ)的垃圾收集器的特征了。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在G1之前的其他收集器进行收集的范围都是整个新生代或者老年代，而G1不再是这样。使用G1收集器时，Java堆的内存布局就与其他收集器有很大差别，它将整个Java堆划分为&lt;strong&gt;多个大小相等的独立区域(Region)&lt;/strong&gt;，虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region(不需要连续）的集合。&lt;/p&gt;
&lt;p&gt;G1收集器之所以能建立可预测的停顿时间模型，是因为它可以有计划地避免在整个Java堆中进行全区域的垃圾收集。G1 跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region (这也就是 Garbage-First 名称的来由）。这种使用Region划分内存空间以及有优先级的区域回收方式，使得G1收集器在有限的时间内可以获取尽可能高的收集效率。&lt;/p&gt;
&lt;h3 id=&quot;22、执行过程&quot;&gt;2.2、执行过程&lt;/h3&gt;
&lt;p&gt;G1收集器的运作大致可划分为以下几个步骤：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;初始标记 (Initial Marking)&lt;/li&gt;
&lt;li&gt;并发标记 (Concurrent Marking)&lt;/li&gt;
&lt;li&gt;最终标记 (Final Marking)&lt;/li&gt;
&lt;li&gt;筛选回收 (Live Data Counting and Evacuation)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/refeng/1909700/o_201231142817u=2915340601,3458053987&amp;amp;fm=26&amp;amp;gp=0.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;初始标记阶段仅仅只是标记一下GC Roots能直接关联到的对象，并且修改NTAMS（Next Top at Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可用的Region中创建新对象，这一阶段需要停顿线程，但耗时很短。并发标记阶段是从GC Roots开始对堆中的对象进行可达性分析，找出存活的对象，这一阶段耗时较长，但可与用户程序并发执行。而最终标记阶段是为了修正在并发标记期间因用户程序继续运行而导致标记产生变动的那一部分标记记录，这一阶段需要停顿线程，但是可并行执行。最后在筛选回收阶段首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;如果有学到东西，请&lt;strong&gt;点赞&lt;/strong&gt;给予鼓励，谢谢。&lt;/p&gt;
</description>
<pubDate>Thu, 31 Dec 2020 14:58:00 +0000</pubDate>
<dc:creator>_热风</dc:creator>
<og:description>CMS、G1收集器 1、CMS收集器 CMS(Concurrent Mark Sweep) 收集器是一种以获取最短回收停顿时间为目标的收集器。优点是并发收集、低停顿。目前很大一部分的Java 应用集中</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/refeng/p/14218952.html</dc:identifier>
</item>
<item>
<title>.NET 云原生架构师训练营（模块二 基础巩固 EF Core 更新和迁移）--学习笔记 - MingsonZheng</title>
<link>http://www.cnblogs.com/MingsonZheng/p/14218950.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/MingsonZheng/p/14218950.html</guid>
<description>&lt;ul&gt;&lt;li&gt;状态&lt;/li&gt;
&lt;li&gt;自动变更检测&lt;/li&gt;
&lt;li&gt;不查询删除和更新&lt;/li&gt;
&lt;li&gt;并发&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;状态&quot;&gt;状态&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;Entity State&lt;/li&gt;
&lt;li&gt;Property State&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;entity-state&quot;&gt;Entity State&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;Added 添加&lt;/li&gt;
&lt;li&gt;Unchanged 没有变化&lt;/li&gt;
&lt;li&gt;Modified 已修改&lt;/li&gt;
&lt;li&gt;Deleted 已删除&lt;/li&gt;
&lt;li&gt;Detached 未跟踪&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1412316/202012/1412316-20201231225658857-1082455360.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;property-state&quot;&gt;Property State&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;IsModified&lt;/li&gt;
&lt;li&gt;CurrentValue&lt;/li&gt;
&lt;li&gt;OriginValue&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;自动变更检测&quot;&gt;自动变更检测&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;使用自动变更检测完成确定字段的更新&lt;/li&gt;
&lt;li&gt;使用自动变更检测完成任意字段的更新&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;使用自动变更检测完成确定字段的更新&quot;&gt;使用自动变更检测完成确定字段的更新&lt;/h3&gt;
&lt;p&gt;ProjectController&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[HttpPatch]
[Route(&quot;{id}&quot;)]
public async Task&amp;lt;ActionResult&amp;lt;Project&amp;gt;&amp;gt; SetTitleAsync(string id, [FromQuery] string title, CancellationToken cancellationToken)
{
    // 查询实体信息
    var origin = await _lighterDbContext.Projects.FirstOrDefaultAsync(p =&amp;gt; p.Id == id, cancellationToken);

    // 修改实体属性
    origin.Title = title;

    // 数据提交保存
    await _lighterDbContext.SaveChangesAsync();

    return origin;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改分组信息&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 查询实体信息
var originGroup = await _lighterDbContext.ProjectGroups.Where(g =&amp;gt; g.ProjectId == id).ToListAsync(cancellationToken: cancellationToken);

// 修改实体属性
foreach (var group in originGroup)
{
    group.Name = $&quot;{title} - {group.Name}&quot;;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查询项目信息时带出分组信息&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[HttpGet]
public async Task&amp;lt;IEnumerable&amp;lt;Project&amp;gt;&amp;gt; GetListAsync(CancellationToken cancellationToken)
{
    return await _lighterDbContext.Projects.Include(p =&amp;gt; p.Groups).ToListAsync(cancellationToken);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;使用自动变更检测完成任意字段的更新&quot;&gt;使用自动变更检测完成任意字段的更新&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;[HttpPatch]
[Route(&quot;{id}&quot;)]
public async Task&amp;lt;ActionResult&amp;lt;Project&amp;gt;&amp;gt; SetAsync(string id, CancellationToken cancellationToken)
{
    // 查询实体信息
    var origin = await _lighterDbContext.Projects.FirstOrDefaultAsync(p =&amp;gt; p.Id == id, cancellationToken);
    var properties = _lighterDbContext.Entry(origin).Properties.ToList();

    // 修改实体属性
    foreach (var query in HttpContext.Request.Query)
    {
        var property = properties.FirstOrDefault(p =&amp;gt; p.Metadata.Name == query.Key);
        if (property == null)
            continue;

        var currentValue = Convert.ChangeType(query.Value.First(), property.Metadata.ClrType);

        _lighterDbContext.Entry(origin).Property(query.Key).CurrentValue = currentValue;
        _lighterDbContext.Entry(origin).Property(query.Key).IsModified = true;
    }

    // 数据提交保存
    await _lighterDbContext.SaveChangesAsync(cancellationToken);

    return origin;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;不查询删除和更新&quot;&gt;不查询删除和更新&lt;/h2&gt;
&lt;p&gt;删除之前先查询&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var id = 1;
using(var db = new entityContext())
{
    var entity = db.dbset.FirstOrDefault(e=&amp;gt;e.ID == id);
    if(entity != null)
    {
        db.dbset.Remove(entity);
        db.SaveChanges();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不查询删除&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var id = 1；
using(var db = new entityContext())
{
    var entity = new Entity{ID = id};
    
    db.dbset.Attach(entity);
    db.dbset.Remove(entity);
    db.SaveChanges();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不查询更新&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;try
{
    using(var db = new dbContext())
    {
        var entity = new myEntity{PageID = pageid};
        db.Pages.Attach(entity);// added
        
        entity.Title = &quot;new title&quot;;// modified, isModified=true
        entity.Url = &quot;new-url&quot;;
        
        db.SaveChanges();
    }
}
catch(DataException)
{
    
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;并发&quot;&gt;并发&lt;/h2&gt;
&lt;p&gt;乐观处理：系统认为数据的更新在大多数情况下是不会产生冲突的，只在数据库更新操作提交的时候才对数据作冲突检测（推荐）&lt;/p&gt;
&lt;p&gt;悲观处理：根据命名即对数据库进行操作更新时，对操作持悲观保守的态度，认为产生数据冲突的可能性很大，需要先对请求的数据加锁再进行相关操作&lt;/p&gt;
&lt;p&gt;在 Entity 中添加行版本号字段&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// 行版本号
/// &amp;lt;/summary&amp;gt;
[Timestamp]
public byte[] RowVersion { get; set; }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;每次对数据进行更新的时候，都会产生最新的版本号，如果更新的时候查询的版本号与之前的版本号不一致，就会报错&lt;/p&gt;
&lt;p&gt;在 UpdateAsync 方法中的查询和更新中间如果数据库的行版本号发生了修改，就会报错&lt;/p&gt;
&lt;p&gt;ProjectController&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[HttpPut]
[Route(&quot;{id&quot;)]
public async Task&amp;lt;ActionResult&amp;lt;Project&amp;gt;&amp;gt; UpdateAsync(string id, [FromBody] Project project, CancellationToken cancellationToken)
{
    var origin = await _lighterDbContext.Projects.FirstOrDefaultAsync(p =&amp;gt; p.Id == id, cancellationToken);

    if (origin == null)
        return NotFound();

    _lighterDbContext.Entry(origin).CurrentValues.SetValues(project);

    await _lighterDbContext.SaveChangesAsync(cancellationToken);
    return origin;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过客户端传入行版本号，解决前端浏览器数据覆盖问题&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;_lighterDbContext.Entry(origin).Property(p =&amp;gt; p.RowVersion).OriginalValue = project.RowVersion;
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;生成 SQL 脚本&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;从空白开始生成sql脚本  
dotnet ef migrations script


生成指定版本到最新版本的sql 
dotnet ef migrations script AddNewTables


从A-B版本生成迁移SQL脚本 
dotnet ef migrations script AddNewTables AddAuditTable
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;database-first&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;dotnet ef dbcontext scaffold &quot;server=172.0.0.1;port=7306;user=root;password=root123456@;database=lighter&quot; Pomelo.EntityFrameworkCore.MySql -o Models
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;github源码链接：&quot;&gt;GitHub源码链接：&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/MINGSON666/Personal-Learning-Library/tree/main/ArchitectTrainingCamp/LighterApi&quot; target=&quot;_blank&quot;&gt;https://github.com/MINGSON666/Personal-Learning-Library/tree/main/ArchitectTrainingCamp/LighterApi&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a rel=&quot;license&quot; href=&quot;http://creativecommons.org/licenses/by-nc-sa/4.0/&quot;&gt;&lt;img alt=&quot;知识共享许可协议&quot; src=&quot;https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本作品采用&lt;a rel=&quot;license&quot; href=&quot;http://creativecommons.org/licenses/by-nc-sa/4.0/&quot;&gt;知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议&lt;/a&gt;进行许可。&lt;/p&gt;
&lt;p&gt;欢迎转载、使用、重新发布，但务必保留文章署名 郑子铭 （包含链接： &lt;a href=&quot;http://www.cnblogs.com/MingsonZheng/&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/MingsonZheng/&lt;/a&gt; ），不得用于商业目的，基于本文修改后的作品务必以相同的许可发布。&lt;/p&gt;
&lt;p&gt;如有任何疑问，请与我联系 (MingsonZheng@outlook.com) 。&lt;/p&gt;
</description>
<pubDate>Thu, 31 Dec 2020 14:57:00 +0000</pubDate>
<dc:creator>MingsonZheng</dc:creator>
<og:description>2.4.6 EF Core -- 更新 状态 自动变更检测 不查询删除和更新 并发 状态 Entity State Property State Entity State Added 添加 Uncha</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/MingsonZheng/p/14218950.html</dc:identifier>
</item>
</channel>
</rss>