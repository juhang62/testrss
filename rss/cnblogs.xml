<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>简易数据分析 09 | Web Scraper 自动控制抓取数量 &amp; Web Scraper 父子选择器 - 卤代烃实验室</title>
<link>http://www.cnblogs.com/web-scraper/p/web_scraper_jiqiao.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/web-scraper/p/web_scraper_jiqiao.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://image-1255652541.cos.ap-shanghai.myqcloud.com/images/20190807082336.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是简易数据分析系列的&lt;strong&gt;第 9 篇&lt;/strong&gt;文章。&lt;/p&gt;
&lt;p&gt;今天我们说说 Web Scraper 的一些小功能：自动控制 Web Scraper 抓取数量和 Web Scraper 的父子选择器。&lt;/p&gt;
&lt;h2 id=&quot;如何只抓取前-100-条数据&quot;&gt;如何只抓取前 100 条数据？&lt;/h2&gt;
&lt;p&gt;如果跟着&lt;a href=&quot;https://www.cnblogs.com/web-scraper/p/web_scraper_start_element_click.html&quot;&gt;上篇教程&lt;/a&gt;一步一步做下来，你会发现这个爬虫会一直运作，根本停不下来。网页有 1000 条数据，他就会抓取 1000 条，有 10W 条，就会抓取 10W 条。如果我们的需求很小，只想抓取前 200 条怎么办？&lt;/p&gt;
&lt;p&gt;如果你&lt;strong&gt;手动关闭&lt;/strong&gt;抓取数据的网页，就会发现数据&lt;strong&gt;全部丢失&lt;/strong&gt;，一条都没有保存下来，所以说这种暴力的方式不可取。我们目前有两种方式停止 Web Scraper 的抓取。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.断网大法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当你觉得数据抓的差不多了，直接把电脑的网络断了。网络一断浏览器就加载不了数据，Web Scraper 就会误以为数据抓取完了，然后它会自动停止自动保存。&lt;/p&gt;
&lt;p&gt;断网大法简单粗暴，虽不优雅，但是有效。缺点就是你得在旁边盯着，关键点手动操作，不是很智能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.通过数据编号控制条数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;比如说&lt;a href=&quot;https://www.cnblogs.com/web-scraper/p/web_scraper_start_element_click.html&quot;&gt;上篇文章&lt;/a&gt;的少数派热门文章爬虫，container 的 Selector 为 &lt;code&gt;dl.article-card&lt;/code&gt;，他会抓取网页里所有编号为 &lt;code&gt;dl.article-card&lt;/code&gt; 的数据。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://image-1255652541.cos.ap-shanghai.myqcloud.com/images/20190707150306.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以在这个 Selector 后加一个 &lt;code&gt;:nth-of-type(-n+100)&lt;/code&gt;，表示抓取前 100 条数据，前 200 条就为 &lt;code&gt;:nth-of-type(-n+200)&lt;/code&gt;，1000 条为 &lt;code&gt;:nth-of-type(-n+1000)&lt;/code&gt;，以此类推。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://image-1255652541.cos.ap-shanghai.myqcloud.com/images/20190707150606.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样，我们就可以通过控制数据的编号来控制需要抓取的数据。&lt;/p&gt;
&lt;h2 id=&quot;抓取链接数据时页面跳转怎么办&quot;&gt;抓取链接数据时，页面跳转怎么办？&lt;/h2&gt;
&lt;p&gt;在&lt;a href=&quot;https://www.cnblogs.com/web-scraper/p/web_scraper_start_element_click.html&quot;&gt;上文&lt;/a&gt;抓取数据时，可能会遇到一些问题，比如说抓取标题时，标题本身就是个超链接，点击圈选内容后打开了新的网页，干扰我们确定圈选的内容，体验不是很好。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://image-1255652541.cos.ap-shanghai.myqcloud.com/images/20190707142842.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其实 Web scraper 提供了对应的解决方案，那就是通过键盘来选择元素，这样就不会触发点击打开新的网页的问题了。具体的操作面板如下所示，就是我们点击 &lt;code&gt;Done Selecting&lt;/code&gt; 的那个控制条。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://image-1255652541.cos.ap-shanghai.myqcloud.com/images/20190707143400.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们把单选按钮选择后，会出现 &lt;strong&gt;S&lt;/strong&gt; ，&lt;strong&gt;P&lt;/strong&gt;， &lt;strong&gt;C&lt;/strong&gt; 三个字符，意思分别如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://image-1255652541.cos.ap-shanghai.myqcloud.com/images/20190707175717.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;S&lt;/strong&gt;：Select，按下键盘的 S 键，选择选中的元素&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;P&lt;/strong&gt;：Parent，按下键盘的 P 键，选择选中元素的父节点&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;C&lt;/strong&gt;：Child，按下键盘的 C 键，选择选中元素的子节点&lt;/p&gt;
&lt;p&gt;我们分别演示一下，首先是通过 &lt;strong&gt;S&lt;/strong&gt; 键选择标题节点：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://image-1255652541.cos.ap-shanghai.myqcloud.com/images/20190707143916.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们对比上个动图，会发现节点选中变红的同时，并没有打开新的网页。&lt;/p&gt;
&lt;h2 id=&quot;如何抓取选中元素的父节点-or-子节点&quot;&gt;如何抓取选中元素的父节点 or 子节点？&lt;/h2&gt;
&lt;p&gt;通过 &lt;strong&gt;P&lt;/strong&gt; 键和 &lt;strong&gt;C&lt;/strong&gt; 键选择父节点和子节点：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://image-1255652541.cos.ap-shanghai.myqcloud.com/images/20190707144046.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;按压 &lt;strong&gt;P&lt;/strong&gt; 键后，我们可以明显看到我们选择的区域大了一圈，再按 &lt;strong&gt;C&lt;/strong&gt; 键后，选择区域又小了一圈，这个就是父子选择器的功能。&lt;/p&gt;
&lt;p&gt;这期介绍了 Web Scraper 的两个使用小技巧，下期我们说说 Web Scraper 如何抓取无限滚动的网页。&lt;/p&gt;
&lt;h2 id=&quot;推荐阅读&quot;&gt;推荐阅读：&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/web-scraper/p/web_scraper_start_element_click.html&quot;&gt;简易数据分析 08 | Web Scraper 翻页——点击「更多按钮」翻页&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 07 Aug 2019 00:40:00 +0000</pubDate>
<dc:creator>卤代烃实验室</dc:creator>
<og:description>这是简易数据分析系列的 第 9 篇 文章。 今天我们说说 Web Scraper 的一些小功能：自动控制 Web Scraper 抓取数量和 Web Scraper 的父子选择器。 如何只抓取前 10</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/web-scraper/p/web_scraper_jiqiao.html</dc:identifier>
</item>
<item>
<title>程序员的迷茫,迷茫的程序员 - tuohaibei</title>
<link>http://www.cnblogs.com/cby-love/p/11312844.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cby-love/p/11312844.html</guid>
<description>&lt;p&gt; &lt;span&gt; 程序员的迷茫来自于多种因素吧，层出不穷的技术，层出不穷的各种大牛的的培训课，感觉不去学习，好像就要被这个时代抛弃，想学习，又眉毛胡子一把抓，今天看两眼这个，明天看两眼那个。最后把自己折腾的很累。感觉一直很忙，却收效甚微。身边的朋友充斥着各种年龄大了,然后就想转管理…每个人的迷茫不同,或许以下几点能让你的迷茫减轻一些.&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;目标感&lt;/strong&gt;&lt;/span&gt;:&lt;/span&gt;&lt;span&gt;没有对自己的职业规划设置目标也很容易迷失自己，造成眉毛胡子一把抓的情况。排除这种困惑也很简单。如果你想成为一个web开发工程师，可以在本子上列出来需要具备的技能，然后分清重点主次，然后各个击破.比如可能web开发工程师可能基础的有ES6,Typescript,html5,css3等，熟练这些技能以后可以掌握一些前端框架，辟如angular、react.js、vue.js;如果你想成为一名后端架构师，可能要求掌握的很多,如下图:然后我们可以根据权重标识出当下首先要掌握的模块.这样可以有一个循序渐进的过程. 掌握的知识点就会更系统,更扎实.&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;           &lt;img src=&quot;https://img2018.cnblogs.com/blog/436862/201908/436862-20190807021151657-1472288060.jpg&quot; alt=&quot;&quot; width=&quot;534&quot; height=&quot;1150&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;掌握原生,学原理&lt;/strong&gt;:&lt;/span&gt;&lt;span&gt;辟如前端框架层出不穷，技术圈出现过&quot;求求你别更新了，学不动了&quot;让人哭笑不得.确实也是.刚熟练一门框架，又出一门框架.那怎么办?万层高楼拔地起，前端框架无非就是js，所以掌握好了基础.任凭你怎么变.还是会很快上手，实在不行就用原生的写好了.可以掌握的比如ES6，以及现在或者将来更火的Typescript.&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;不是每个人都适合做管理&lt;/strong&gt;:&lt;/span&gt;&lt;span&gt;如果因为年龄大了就去转管理，而不去衡量自己是否合适.其实写代码远比做管理简单,代码是由你主宰。而管理需要懂人心,人心是捉摸不透的。 如果是因为年龄大了，觉着精力更不上，那就去锻炼身体。如果因为年龄大了，技术上没有提升，是不是多年来一直在写一样类型的代码，可以理解为重复。那确实十年和一年没什么区别。我们就从现在去转变自己，去转变自己.否则能怎么办，如果有更好的办法也行。没有最好的办法的时候，这就是最好的办法。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;碎片化时间的利用:&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;每天早晨在交通工具上也要充分利用.因为这时候我们的精神相对一天来说算是比较好的.但是每个人的状态不一样.我每天早晨在交通工具上学习过极客时间上的课程,背过英语单词。但是效果不明显.因为在交通工具上自己的注意力不一定能那么集中，看过或记过的东西很快就忘记了.后来我就转变了策略，看技术公众号的技术文章，如果看标题自己比较感兴趣的，就收藏。然后腾出个固定且连续的时间，比如晚上下班以后，或者周末找个时间块从头到尾看一遍.这样效果反而更好.当然可能还有更好的策略，我们也要不断去矫正自己的一些碎片化时间利用效率.&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;抓住人生的每个机会:&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;人生的每一份工作都是下一份工作的资本.当一份好的工作机会来临时,要好好抓住.有些机会不能看当下,要长远来看.可能当下这份工作薪水不高.但是要胸怀远方.或许等你翅膀硬了。想飞反而可以飞的更高。否则翅膀永远长不硬。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;       &lt;img src=&quot;https://img2018.cnblogs.com/blog/436862/201908/436862-20190807022128905-1348957550.jpg&quot; alt=&quot;&quot; width=&quot;700&quot; height=&quot;980&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 07 Aug 2019 00:40:00 +0000</pubDate>
<dc:creator>tuohaibei</dc:creator>
<og:description>程序员的迷茫来自于多种因素吧，层出不穷的技术，层出不穷的各种大牛的的培训课，感觉不去学习，好像就要被这个时代抛弃，想学习，又眉毛胡子一把抓，今天看两眼这个，明天看两眼那个。最后把自己折腾的很累。感觉一</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cby-love/p/11312844.html</dc:identifier>
</item>
<item>
<title>重温面向对象核心 下 : 你一定能看懂的委托和事件 - 编程小纸条</title>
<link>http://www.cnblogs.com/miro/p/11312992.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/miro/p/11312992.html</guid>
<description>
&lt;p&gt;实例解读面向对象核心，所有例子基于 C#，涉及我们实务中最常关心的问题：&lt;/p&gt;
&lt;p&gt;1、封装、继承、多态；&lt;/p&gt;
&lt;p&gt;2、抽象类、接口；&lt;/p&gt;
&lt;p&gt;3、委托、事件。    &lt;/p&gt;

&lt;p&gt;通俗的说，我们使用委托的目的是“实现将方法作为参数传递的效果”，直接结合例子说明。&lt;/p&gt;
&lt;p&gt;我们还是用基于上次的示例往下更改。&lt;/p&gt;
&lt;p&gt;场景设定：根据图形的不同，返回不同的面积算法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 参数为图形形状, 返回该图形的面积计算公式&lt;/span&gt;

        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; GetAreaAlg(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; shapeName)

        {

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (shapeName==&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;矩形&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

            {

                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;长 × 宽&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

            }

            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (shapeName == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;圆形&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

            {

                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pi * r * r&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

            }

            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;

            {

                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;该图形面积算法未定义&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

            }

        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;当图形越来越多时，方法体中的分支就会膨胀。&lt;/p&gt;
&lt;p&gt;这时候我们很自然的想到，如果我们可以直接将方法作为参数传进来，那么就可以不需要这些分支了。&lt;/p&gt;
&lt;p&gt;类似如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; GetAreaAlg(某种类型 计算面积公式的方法)

        {

            执行此 计算面积公式的方法；

        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;好了，我们顺着这个思路改造一下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;#region&lt;/span&gt; delegate相关演示

        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;声明一个委托&lt;/span&gt;

        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;delegate&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; GetAreaAlgDelegate();

 

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 矩形的面积算法&lt;/span&gt;

        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; GetRectangleAreaAlgorithm()

        {

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;矩形的面积算法：长 × 宽&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 圆形的面积算法&lt;/span&gt;

        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; GetRCircleAreaAlgorithm()

        {

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;圆形面积公式：pi * r * r&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

        }

 

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; GetAreaAlg(GetAreaAlgDelegate GetAlgorithm)

        {

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; GetAlgorithm();

        }

 

        &lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这个时候，在Home/Index中直接调用即可：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;string&lt;/span&gt; strAlgorith = GetAreaAlg(GetRectangleAreaAlgorithm);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;加个断点调试一下，可以看到返回了 矩形的面积算法：长 × 宽&lt;/p&gt;
&lt;p&gt;理解了吗？我们来小结一下。&lt;/p&gt;
&lt;p&gt;委托是对函数的封装，可以当作给方法的特征指定一个名称，我们可以和普通的参数做类比来理解。&lt;/p&gt;
&lt;p&gt;委托是一个类，它定义了方法的类型，使得可以将方法当作另一个方法的参数来进行传递，这种将方法动态地赋给参数的做法，可以避免在程序中大量使用分支语句，同时使得程序具有更好的可扩展性。&lt;/p&gt;


&lt;p&gt;事件是委托的一种特殊形式，当事件发生时，事件对象通知处理过程。&lt;/p&gt;
&lt;p&gt;我们改造下我们的例子，加一句就行，紧接着声明委托下面声明事件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;声明一个委托&lt;/span&gt;

        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;delegate&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; GetAreaAlgDelegate();

 

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 声明一个事件&lt;/span&gt;

        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;event&lt;/span&gt; GetAreaAlgDelegate GetArea;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;同样在Home/Index中，调用时先登记事件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
            GetArea += &lt;span&gt;new&lt;/span&gt;&lt;span&gt; GetAreaAlgDelegate(GetRCircleAreaAlgorithm);

            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; res= GetArea();
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;加个断点调试一下，可以看见返回了 圆形面积公式：pi * r * r&lt;/p&gt;
&lt;p&gt;我们通过实例化委托，将GetRCircleAreaAlgorithm方法登记到事件 GetArea 中，理解了吗？&lt;/p&gt;

&lt;p&gt;我们按一下鼠标按钮，触发某个操作，执行某个方法就是典型的应用。&lt;/p&gt;

&lt;p&gt;委托和事件实际上是观察者模式的应用。&lt;/p&gt;
&lt;p&gt;具体的应用场景我就不展开了，大家可以思考。&lt;/p&gt;
&lt;p&gt;仅以两张图片说明一个例子，启发大家思考。&lt;/p&gt;
&lt;p&gt;观察者模式结构：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/101211/201908/101211-20190807082933089-2049452541.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;观察者模式例子：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/101211/201908/101211-20190807082940985-1418414888.png&quot; alt=&quot;&quot; width=&quot;659&quot; height=&quot;566&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 祝学习进步。&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/101211/201908/101211-20190807082959073-943181386.png&quot; alt=&quot;&quot; width=&quot;702&quot; height=&quot;438&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 07 Aug 2019 00:33:00 +0000</pubDate>
<dc:creator>编程小纸条</dc:creator>
<og:description>实例解读面向对象核心，所有例子基于 C#，涉及我们实务中最常关心的问题： 1、封装、继承、多态； 2、抽象类、接口； 3、委托、事件。 三、委托和事件 通俗的说，我们使用委托的目的是“实现将方法作为参</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/miro/p/11312992.html</dc:identifier>
</item>
<item>
<title>Java虚拟机详解（四）------垃圾收集器 - YSOcean</title>
<link>http://www.cnblogs.com/ysocean/p/11117365.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ysocean/p/11117365.html</guid>
<description>&lt;p&gt;　　上一篇博客我们介绍了&lt;a href=&quot;https://www.cnblogs.com/ysocean/p/11108933.html&quot; target=&quot;_blank&quot;&gt;Java虚拟机垃圾回收&lt;/a&gt;，介绍了几种常用的垃圾回收算法，包括标记-清除，标记整理，复制等，这些算法我们可以看做是内存回收的理论方法，那么在Java虚拟机中，由谁来具体实现这些方法呢？&lt;/p&gt;
&lt;p&gt;　　没错，就是本篇博客介绍的内容——垃圾收集器。&lt;/p&gt;
&lt;h3&gt;1、垃圾收集器种类&lt;/h3&gt;
&lt;p&gt;　　事实上Java虚拟机规范对垃圾收集器应该如何实现，并没有任何的规定，所以不同的厂商、不同版本的虚拟机所提供的垃圾收集器都会有所不同，并且一般都会提供参数供用户根据自己的应用特点和要求组合出各个年代所使用的收集器。&lt;/p&gt;
&lt;p&gt;　　下图是基于 Sun HotSpot 虚拟机1.6版 Update 22的虚拟机种类：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1120165/201908/1120165-20190806231839133-894902320.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　由上图我们可以总结出几个结论：&lt;/p&gt;
&lt;p&gt;　　①、新生代垃圾收集器：Serial、ParNew、Parallel Scavenge；&lt;/p&gt;
&lt;p&gt;　　　　老年代垃圾收集器：Serial Old（MSC）、Parallel Old、CMS；&lt;/p&gt;
&lt;p&gt;　　　　整堆垃圾收集器：G1&lt;/p&gt;
&lt;p&gt;　　②、垃圾收集器之间的连线表示可以搭配使用，有如下几种组合：&lt;/p&gt;
&lt;p&gt;　　　　Serial/Serial Old、Serial/CMS、ParNew/Serial Old、ParNew/CMS、Parallel Scavenge/Serial Old、Parallel Scavenge/Parallel Old、G1；&lt;/p&gt;
&lt;p&gt;　　③、串行收集器Serial：Serial、Serial Old&lt;/p&gt;
&lt;p&gt;　　　　并行收集器 Parallel：Parallel Scavenge、Parallel Old&lt;/p&gt;
&lt;p&gt;　　　　并发收集器：CMS、G1&lt;/p&gt;
&lt;p&gt;　　ps:对于文章中有一些名词不理解的，可以先看本篇博客&lt;a href=&quot;https://www.cnblogs.com/ysocean/p/11117365.html#_label9&quot; target=&quot;_blank&quot;&gt;最后一个小节&lt;/a&gt;。&lt;/p&gt;
&lt;h3&gt;2、Serial收集器&lt;/h3&gt;
&lt;p&gt;　　这是一个最基本，历史最悠久的垃圾收集器，是JDK1.3之前新生代唯一的垃圾收集器。&lt;/p&gt;
&lt;p&gt;　　该收集器有如下特点：&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;①、作用于新生代&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　由上图也可看出，这是一个新生代垃圾收集器，采用的垃圾回收算法是复制算法。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;②、单线程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　工作时只会使用一个CPU或者一条收集线程去完成工作。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;③、进行垃圾收集时，必须暂停所有工作线程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　也就是说使用Serial收集器进行垃圾回收时，别的工作线程都暂停，系统这时候会有卡顿现象产生。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;④、适用场景&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　Serial 收集器由于没有线程交互的开销，对于限定单个CPU的环境，可以获得最高的单线程收集效率。&lt;/p&gt;
&lt;p&gt;　　一般在用户的桌面场景中，分配给虚拟机管理的内存一般来说不会很大，收集几十兆或一两百兆的新生代，定顿时间可以控制在几十毫秒，只要不是频繁发生的，这点停顿是可以接受的。&lt;/p&gt;
&lt;p&gt;　　所以 Serial 收集器对于运行在 Client 模式下的虚拟机是一种很好的选择。&lt;/p&gt;
&lt;h3&gt;3、ParNew收集器&lt;/h3&gt;
&lt;p&gt;　　这个收集器其实就是Serial收集器的多线程版本。&lt;/p&gt;
&lt;p&gt;　　也就是说其特点除了多线程，其余和Serial收集器一样，事实上，这两个收集器实现上也共用了很多代码。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　①、作用于新生代&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　一个新生代垃圾收集器，采用的垃圾回收算法是复制算法。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;②、多线程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;弥补了Serial收集器单线程的缺陷。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;③、适用场景&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　由于其多线程的特性，是大多数运行在 Server 模式下的虚拟机首选新生代垃圾收集器。&lt;/p&gt;
&lt;p&gt;　　另外需要说明的是，能够与下面将要介绍的划时代垃圾收集器CMS（Concurrent Mark Sweep）配合使用，也是一个重要原因。&lt;/p&gt;
&lt;h3&gt;4、Parallel Scavenge收集器&lt;/h3&gt;
&lt;p&gt;　　前面介绍的垃圾收集器关注点是尽可能缩小垃圾收集时的用户线程停顿时间。而 Parallel Scanvenge 收集器是为了达到一个可控制的吞吐量。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;吞吐量 = 运行用户代码的时间 / （运行用户代码的时间+垃圾收集时间）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　可以用下面两个参数进行精确控制：&lt;/p&gt;
&lt;p&gt;　　-XX:MaxGCPauseMills  设置最大垃圾收集停顿时间&lt;/p&gt;
&lt;p&gt;　　-XX:GCTimeRatio 设置吞吐量大小&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　①、作用于新生代&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　一个新生代垃圾收集器，采用的垃圾回收算法是复制算法。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;②、多线程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;并行的多线程垃圾收集器。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;③、吞吐量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　这个收集器可以精确控制吞吐量。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;④、适用场景&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;设置垃圾收集停顿时间短适合需要与用户快速交互的程序；&lt;/p&gt;
&lt;p&gt;　　而设置高吞吐量可以最高效的利用CPU效率，尽快的完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。&lt;/p&gt;
&lt;h3&gt;5、Serial Old收集器&lt;/h3&gt;
&lt;p&gt;　　Serial Old 收集器是 Serial 收集器的老年代版本，特点如下：&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;①、作用于老年代&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;②、单线程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;③、使用标记-整理算法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;④、进行垃圾收集时，必须暂停所有工作线程&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;6、Parallel Old收集器&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;Parallel Old 是 Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;①、作用于老年代&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;②、多线程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;③、使用标记-整理算法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;除了具有以上几个特点，比较关键的是能和新生代收集器 Parallel Scavenge 配置使用，获得吞吐量最大化的效果。&lt;/p&gt;
&lt;h3&gt;7、CMS收集器&lt;/h3&gt;
&lt;p&gt;　　CMS，全称为 Concurrent Mark Sweep ，顾名思义并发的，采用标记-清除算法。另外也将这个收集器称为并发低延迟收集器（Concurrent Low Pause Collector）&lt;/p&gt;
&lt;p&gt;　　这是一款跨时代的垃圾收集器，真正做到了垃圾收集线程与用户线程（基本上）同时工作。和 Serial 收集器的 Stop The World（妈妈打扫房间的时候，你不能再将垃圾丢到地上） 相比，真正做到了妈妈一边打扫房间，你一边丢垃圾。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;①、作用于老年代&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;②、多线程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;③、使用标记-清除算法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　整个算法过程分为如下 4 步：&lt;/p&gt;
&lt;p&gt;　　一、初始标记（CMS initial mark）：只是仅仅标记GC Root 能够直接关联的对象，速度很快，但是需要“Stop The World”　　&lt;/p&gt;
&lt;p&gt;　　二、并发标记（CMS concurrent mark）：进行GC Root Tracing的过程，简单来说就是遍历Initial Marking阶段标记出来的存活对象，然后继续递归标记这些对象可达的对象。&lt;/p&gt;
&lt;p&gt;　　三、重新标记（CMS Remark）：修正并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，需要“Stop The World”。这个时间一般比初始标记长，但是远比并发标记时间短。&lt;/p&gt;
&lt;p&gt;　　四、并发清除（CMS concurrent sweep）：对上一步标记的对象进行清除操作。&lt;/p&gt;
&lt;p&gt;　　由于整个过程最耗时的操作是第二（并发标记）、四步（并发清除），而这两步垃圾收集器线程是可以和用户线程一起工作的。所以整体来说，CMS垃圾收集和用户线程是一起并发的执行的。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　①、对CPU资源敏感&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;因为在并发阶段，会占用一部分CPU资源，从而导致应用程序变慢，总吞吐量会降低。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;②、产生浮动垃圾&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　由于CMS并发清理阶段用户线程还在工作，这个时候产生的垃圾，CMS无法在本次收集中处理掉它们，只能留在下一次GC时再将其处理掉，这部分垃圾称为“浮动垃圾”。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;③、产生内存垃圾碎片&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　因为采用的算法是标记-清除，很明显，会有空间碎片产生。&lt;/p&gt;
&lt;h3&gt;8、G1收集器&lt;/h3&gt;
&lt;p&gt;　　这是当前收集器技术发展的最前沿的成果。可以实现在基本不牺牲吞吐量的前提下完成低停顿的内存回收。&lt;/p&gt;
&lt;p&gt;　　这是因为它并不像前面介绍的所有垃圾收集器是区分新生代，老年代的，它作用于全区域。将整个Java堆划分为多个大小固定的独立区域（Regin），并且跟踪这些区域的垃圾堆积面积，在后台维护一个优先级列表，每次根据允许的收集时间，优先回收垃圾最多的区域，这样保证了G1收集器在有限的时间内可以获得最高的收集效率。&lt;/p&gt;
&lt;p&gt;　　它与前面讲的 CMS 垃圾收集器相比，有两个显著的改进：&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;①、采用 标记-整理 的回收算法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　这样不会产生空间碎片&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;②、可以精确的控制停顿时间&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　能让使用者明确指定一个长度为M毫秒的时间片内，消耗在垃圾回收上的时间不超过 N 毫秒。&lt;/p&gt;
&lt;p&gt;　　③、作用于整个Java堆&lt;/p&gt;
&lt;p&gt;　　G1收集器不区分年轻代和老年代，是整堆垃圾收集器。&lt;/p&gt;
&lt;h3&gt;9、如何选择垃圾收集器　　&lt;/h3&gt;
&lt;p&gt;　　详细文档可以查看官方介绍，如下&lt;/p&gt;
&lt;p&gt;　　&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/collectors.html&quot; target=&quot;_blank&quot;&gt;https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/collectors.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　这里我们翻译一下结论：&lt;/p&gt;
&lt;p&gt;　　除非应用程序有相当严格的暂停时间要求，否则就让JVM自己选择垃圾收集器。并且可以适当优先调整堆的大小来提高性能。如果还不满足要求，则以下面四点作为指导：&lt;/p&gt;
&lt;p&gt;　　1. 如果应用程序内存小于100M，那么使用选项选择串行收集器&lt;code dir=&quot;ltr&quot;&gt;-XX:+UseSerialGC&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;　　2. 如果应用程序将在单核处理器上运行，并且没有停顿时间的要求，选择串行&lt;code dir=&quot;ltr&quot;&gt;-XX:+UseSerialGC&lt;/code&gt;或者 JVM 自己选&lt;/p&gt;
&lt;p&gt;　　3. 如果允许停顿时间超过1秒，选择并行或 JVM 自己选&lt;/p&gt;
&lt;p&gt;　　4. 如果响应时间比总吞吐量更重要，并且垃圾收集暂停必须保持短于大约1秒，则使用&lt;code dir=&quot;ltr&quot;&gt;-XX:+UseConcMarkSweepGC&lt;/code&gt;或选择并发收集器&lt;code dir=&quot;ltr&quot;&gt;-XX:+UseG1GC&lt;/code&gt;。&lt;/p&gt;
&lt;h3&gt;10、几个名词解释&lt;/h3&gt;
&lt;p&gt;　　&lt;strong&gt;①、并行&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。&lt;/p&gt;
&lt;p&gt;　　适合科学计算、后台处理等弱交互场景。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;②、并发&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　指用户线程与垃圾收集器线程同时执行（但不一定是并行的，可能会交替执行），用户线程继续执行，而垃圾收集线程运行在另一块CPU上。&lt;/p&gt;
&lt;p&gt;　　适合对响应快速的场景，比如Web。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;③、停顿时间&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　垃圾收集器做垃圾回收中断应用执行的时间。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;④、吞吐量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　 吞吐量 = 运行用户代码的时间 / （运行用户代码的时间+垃圾收集时间）&lt;/p&gt;
</description>
<pubDate>Wed, 07 Aug 2019 00:21:00 +0000</pubDate>
<dc:creator>YSOcean</dc:creator>
<og:description>Java虚拟机详解（四）------常见的垃圾收集器</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ysocean/p/11117365.html</dc:identifier>
</item>
<item>
<title>.net持续集成测试篇之Nunit参数化测试 - 周国通</title>
<link>http://www.cnblogs.com/tylerzhou/p/11312957.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tylerzhou/p/11312957.html</guid>
<description>&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/tylerzhou/p/11204826.html&quot;&gt;系列目录&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在进行单元测试的时候,很多时候,很多时候我们都是在单元测试方法内部提供特定的值,但是这样测试往往造成样本数不足从而导致覆盖的结果不够全面,很多时候我们更想提供来自外部的,满足条件的一组值来进行测试.其实Nunit框架本身提供了为测试用例提供值的能力.我们可以对它进行扩展来实现导入外部的值来填充到测试方法内部.很多朋友也自己写了不少按照一定规则生成值的方法.但是往往都是在方法内部直接调用,这样就会和单元测试的逻辑混杂在一块,导致测试方法本身不够简洁.其实可以根本测试框架本身的能力改造成为注解的方式,这样参数生成逻辑和测试逻辑一目了然.后面我们还会讲解基于Autofixture框架来生成填充数据,autofixture相比我们自己写的值填充方法,往往功能更加强大.后面我们将见证其强大之处.&lt;/p&gt;
&lt;h2 id=&quot;提供普通参数&quot;&gt;提供普通参数&lt;/h2&gt;
&lt;p&gt;很容易发现,单元测试的方法都是不带参数的,有些时候我们需要为一个要测试的方法(并非单元测试方法)提供多个参数进行测试,这就会导致一个问题:我们需要写很多类似的测试方法,只是参数不一样,这样维护起来不方便,同时大量重复的工作也很烦.下面介绍Nunit里如何为测试提供参数&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;
        int  Add(int x, int y)
        {
            return x + y;
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上是我们要测试的方法.&lt;/p&gt;
&lt;p&gt;虽然Nunit测试方法正常情况下是不支持参数的,但是如果对参数添加的values注解,Nunit便会把这些参数应用到测试.&lt;br/&gt;我们看一下编写的测试方法&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;        [Test]
        public void DemoTest([Values(3,4,5)]int a,[Values(6,7,8)]int b)
        {
            var result = Add(a, b);
            Assert.AreEqual(a + b, result);
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们运行以上方法,可以看到测试结果通过,但是我们看一下测试面板(Test Explorer)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811801/201908/811801-20190807080303870-263144460.png&quot; alt=&quot;avatar&quot;/&gt;&lt;br/&gt;通过截图我们很容易发现,这个测试方法一共运行的九次!再仔细看看方法对应的参数,可以看到它是使用组合的方式把所有的可能都组合一遍.&lt;/p&gt;
&lt;p&gt;但是有些时候我们想要的不是这样的组合,我们想要的更多时候是(3,6),(4,7),(5,8)这样的组合,如何做到呢,仍然看一段示例代码&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;        [Test]
        [Sequential]
        public void DemoTest([Values(3,4,5)]int a,[Values(6,7,8)]int b)
        {
            var result = Add(a, b);
            Assert.AreEqual(a + b, result);
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们看看运行结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811801/201908/811801-20190807080255665-2050198198.png&quot; alt=&quot;avatar&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这次只运行了三次,并且参数的组合正如我们期待的.&lt;br/&gt;这个方法和上面的一样,只是多了一个&lt;code&gt;[Sequential]&lt;/code&gt;注解&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;注意Values注解里的参数都是Object类型,运行时候转换为参数的真正类型,如果无法转换则会抛出异常.比如&lt;code&gt;[Values(&quot;a&quot;)]int x&lt;/code&gt;由于a是字符串类型,通过内置方法无法转换为int,因些会抛出异常.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;提供基于范围的参数&quot;&gt;提供基于范围的参数&lt;/h2&gt;
&lt;p&gt;上面的测试Values(3,4,5)和Values(6,7,8)都是连续的数字,如果连接的参数更多,我们可以使用基于范围的参数.&lt;/p&gt;
&lt;p&gt;看以下示例代码&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;        [Test]
        [Sequential]
        public void DemoTest([Range(3,5)]int a,[Range(6,8)]int b)
        {
            var result = Add(a, b);
            Assert.AreEqual(a + b, result);
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们把Values注解改为Range注解,就ok了&lt;/p&gt;
&lt;h2 id=&quot;提供随机参数&quot;&gt;提供随机参数&lt;/h2&gt;
&lt;p&gt;我们还可以为测试提供一些随机数,以使测试变得更随机,覆盖范围更大&lt;/p&gt;
&lt;p&gt;这里要使用Random注解&lt;br/&gt;请看下面示例&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;       [Test]
       [Sequential]
        public void DemoTest([Random(3)]int a, [Random(3)]int b)
        {
            var result = Add(a, b);
            Assert.AreEqual(a + b, result);
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Random的参数为要生成随机数的个数.&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Random还有一重载以支持生成随机数的最大值和最小值&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;       [Test]
       [Sequential]
        public void DemoTest([Random(3,10,2)]int a, [Random(5,9,3)]int b)
        {
            var result = Add(a, b);
            Assert.AreEqual(a + b, result);
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;示例中Random的三个参数分别是&lt;code&gt;最小值,最大值和个数&lt;/code&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;[info]&lt;/strong&gt;Random的最大值和最小值不仅可以是整数,也可以是小数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;提供计算参数&quot;&gt;提供计算参数&lt;/h2&gt;
&lt;p&gt;先看一个示例&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;       [Test]
       [Sequential]
        public void DemoTest(DateTime dt1)
       {
           DateTime dt2 = default(DateTime);
           Assert.Greater(dt1, dt2);
       }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里测试方法的参数是Datetime类型,我们如何给给它提供值呢,很多人可能会想使用Values[DateTime.Now] 来注解dt1参数,然而不幸的是Values注解只接受&lt;code&gt;const&lt;/code&gt;类型的值,这里介绍&lt;code&gt;ValueSource&lt;/code&gt;注解来解决这个问题.&lt;/p&gt;
&lt;p&gt;ValueSource的机制是使用一个方法来获取值,然后提供给测试方法参数,它接受一个字符串类型的参数,用于指定提供值的方法名.&lt;/p&gt;
&lt;p&gt;我们用以下方法生成一些DateTime值&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;static IEnumerable&amp;lt;DateTime&amp;gt; GetPeople()
        {
            yield return DateTime.Now;
            yield return DateTime.Now.AddDays(2);
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上方法生成了一个包含两个DateTime值的集合.下面我们看如何使用它&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;       [Test]
        public void DemoTest([ValueSource(nameof(FirstUnitTest.GetPeople))]DateTime dt1)
       {
           DateTime dt2 = default(DateTime);
           Assert.Greater(dt1, dt2);
       }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们使用nameof获取刚才生成的用于提供值的方法,作为ValueSource的参数.&lt;/p&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;使用nameof而不是使用手写字符串的好处在于nameof可以有智能提示,防止手写出现错误,另外就是如果方法名更改,这里将会抛出了一个错误,静态字符串不会提示错误,如果在运行时找不到这个方法则会抛出运行时错误&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;用于为ValueSource提供值的方法必须是&lt;code&gt;静态的&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以上代码,我们把提供值的方法直接写在测试类里,这并不是一种很好的实践,一种好的做法是把所有的用于提供值的方法放在一个外部的类中.&lt;/p&gt;
&lt;p&gt;我们把这个类移动到一个叫作&lt;code&gt;MyValueProvider&lt;/code&gt;的类中&lt;br/&gt;代码如下&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;public class MyValueProvider
    {
        public static IEnumerable&amp;lt;DateTime&amp;gt; GetPeople()
        {
            yield return DateTime.Now;
            yield return DateTime.Now.AddDays(2);
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;单元测试方法改成如下:&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;       [Test]
        public void DemoTest([ValueSource(typeof(MyValueProvider),nameof(MyValueProvider.GetPeople))]DateTime dt1)
       {
           DateTime dt2 = default(DateTime);
           Assert.Greater(dt1, dt2);
       }&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;如果把值提供方法不在本类中(当前测试方法所在的类),提供一个Type类型(提供值的方法所在的类的类型)作为第一个参数,方法名作为第二个参数.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上面讲的都是基于参数注解的值提供方法,这里基于方法的注解的值提供方法.当然,它完成的功能基于参数注解的方法也同样能完成.&lt;/p&gt;
&lt;h2 id=&quot;testcaseattribute注解&quot;&gt;TestCaseAttribute注解&lt;/h2&gt;
&lt;p&gt;看以下代码片段&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;       [TestCase(3,4)]
        public void DemoTest(int x,int y)
       {
           var val = Add(x, y);
           Assert.AreEqual(x + y, val);
       }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中用到的Add方法代码如下&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt; int  Add(int x, int y)
        {
            return x + y;
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;TestCase的工作原理是这样的,它提供的值是基于位置的,每一个位置处的值赋值给第一个参数,第二个位置处的值提供给第二个参数...&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;有了TestCase注解之后,Test注解不再是必要的.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;testcasesourceattribute注解&quot;&gt;TestCaseSourceAttribute注解&lt;/h2&gt;
&lt;p&gt;从上ValueSource我们很容易想到可能会有TestCaseSource,实际上也确实是这样的,TestCaseSource功能也同ValueSource一样,用于提供基于计算的结果.&lt;/p&gt;
&lt;p&gt;用于提供值的类如下&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt; public class MyValueProvider
   {
       public static ArrayList ar = new ArrayList
       {
           new int[] {3, 4},
           new int[] {5, 9},
           new int[] {9, 22}
       };
   }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试方法如下&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;       [TestCaseSource(typeof(MyValueProvider),nameof(MyValueProvider.ar))]     
        public void DemoTest(int x,int y)
       {
           var val = Add(x, y);
           Assert.AreEqual(x + y, val);
       }&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;从这个例子我们可看到,不仅方法可以提供值,属性,普通字段也可以提供值&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;为TestCaseSource提供值的字段,方法,属性也&lt;code&gt;必须是静态的&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;TestCase和TestCaseSource都支持多重注解,有几个注解,测试方法就会运行几次.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Wed, 07 Aug 2019 00:19:00 +0000</pubDate>
<dc:creator>周国通</dc:creator>
<og:description>'系列目录' 在进行单元测试的时候,很多时候,很多时候我们都是在单元测试方法内部提供特定的值,但是这样测试往往造成样本数不足从而导致覆盖的结果不够全面,很多时候我们更想提供来自外部的,满足条件的一组值</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tylerzhou/p/11312957.html</dc:identifier>
</item>
<item>
<title>[Abp vNext 源码分析] - 7. 权限与验证 - myzony</title>
<link>http://www.cnblogs.com/myzony/p/11312928.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/myzony/p/11312928.html</guid>
<description>&lt;h2 id=&quot;一简要说明&quot;&gt;一、简要说明&lt;/h2&gt;
&lt;p&gt;在上篇文章里面，我们在 &lt;code&gt;ApplicationService&lt;/code&gt; 当中看到了权限检测代码，通过注入 &lt;code&gt;IAuthorizationService&lt;/code&gt; 就可以实现权限检测。不过跳转到源码才发现，这个接口是 ASP.NET Core 原生提供的 “基于策略” 的权限验证接口，这就说明 ABP vNext 基于原生的授权验证框架进行了自定义扩展。&lt;/p&gt;
&lt;p&gt;让我们来看一下 &lt;strong&gt;Volo.Abp.Ddd.Application&lt;/strong&gt; 项目的依赖结构(权限相关)。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1203160/201908/1203160-20190807080531958-1718436177.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;本篇文章下面的内容基本就会围绕上述框架模块展开，本篇文章通篇较长，因为还涉及到 &lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/savorboard/p/aspnetcore-identity.html&quot;&gt;.NET Core Identity&lt;/a&gt;&lt;/strong&gt; 与 &lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/stulzq/p/8119928.html&quot;&gt;IdentityServer4&lt;/a&gt;&lt;/strong&gt; 这两部分。关于这两部分的内容，我会在本篇文章大概讲述 ABP vNext 的实现，关于更加详细的内容，请查阅官方文档或其他博主的博客。&lt;/p&gt;
&lt;h2 id=&quot;二源码分析&quot;&gt;二、源码分析&lt;/h2&gt;
&lt;p&gt;ABP vNext 关于权限验证和权限定义的部分，都存放在 &lt;strong&gt;Volo.Abp.Authorization&lt;/strong&gt; 和 &lt;strong&gt;Volo.Abp.Security&lt;/strong&gt; 模块内部。源码分析我都比较喜欢倒推，即通过实际的使用场景，&lt;strong&gt;反向推导&lt;/strong&gt; 基础实现，所以后面文章编写的顺序也将会以这种方式进行。&lt;/p&gt;
&lt;h3 id=&quot;security-基础组件库&quot;&gt;2.1 Security 基础组件库&lt;/h3&gt;
&lt;p&gt;这里我们先来到 &lt;strong&gt;Volo.Abp.Security&lt;/strong&gt;，因为这个模块代码和类型都是最少的。这个项目都没有模块定义，说明里面的东西都是定义的一些基础组件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1203160/201908/1203160-20190807080551771-917128214.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;claims-与-identity-的快捷访问&quot;&gt;2.1.1 Claims 与 Identity 的快捷访问&lt;/h4&gt;
&lt;p&gt;先从第一个扩展方法开始，这个扩展方法里面比较简单，它主要是提供对 &lt;code&gt;ClaimsPrincipal&lt;/code&gt; 和 &lt;code&gt;IIdentity&lt;/code&gt; 的快捷访问方法。比如我要从 &lt;code&gt;ClaimsPrincipal&lt;/code&gt; / &lt;code&gt;IIdentity&lt;/code&gt; 获取租户 Id、用户 Id 等。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public static class AbpClaimsIdentityExtensions
{
    public static Guid? FindUserId([NotNull] this ClaimsPrincipal principal)
    {
        Check.NotNull(principal, nameof(principal));

        // 根据 AbpClaimTypes.UserId 查找对应的值。
        var userIdOrNull = principal.Claims?.FirstOrDefault(c =&amp;gt; c.Type == AbpClaimTypes.UserId);
        if (userIdOrNull == null || userIdOrNull.Value.IsNullOrWhiteSpace())
        {
            return null;
        }

        // 返回 Guid 对象。
        return Guid.Parse(userIdOrNull.Value);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;未授权异常的定义&quot;&gt;2.1.2 未授权异常的定义&lt;/h4&gt;
&lt;p&gt;这个异常我们在老版本 ABP 里面也见到过，它就是 &lt;code&gt;AbpAuthorizationException&lt;/code&gt; 。只要有任何未授权的操作，都会导致该异常被抛出。后面我们在讲解 ASP.NET Core MVC 的时候就会知道，在默认的错误码处理中，针对于程序抛出的 &lt;code&gt;AbpAuthorizationException&lt;/code&gt; ，都会视为 403 或者 401 错误。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class DefaultHttpExceptionStatusCodeFinder : IHttpExceptionStatusCodeFinder, ITransientDependency
{
    // ... 其他代码
    
    public virtual HttpStatusCode GetStatusCode(HttpContext httpContext, Exception exception)
    {
        // ... 其他代码
        
        // 根据 HTTP 协议对于状态码的定义，401 表示的是没有登录的用于尝试访问受保护的资源。而 403 则表示用户已经登录，但他没有目标资源的访问权限。
        if (exception is AbpAuthorizationException)
        {
            return httpContext.User.Identity.IsAuthenticated
                ? HttpStatusCode.Forbidden
                : HttpStatusCode.Unauthorized;
        }
        
        // ... 其他代码
    }
    
    // ... 其他代码
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;就 &lt;code&gt;AbpAuthorizationException&lt;/code&gt; 异常来说，它本身并不复杂，只是一个简单的异常而已。只是因为它的特殊含义，在 ABP vNext 处理异常时都会进行特殊处理。&lt;/p&gt;
&lt;p&gt;只是在这里我说明一下，ABP vNext 将它所有的异常都设置为可序列化的，这里的可序列化不仅仅是将 &lt;code&gt;Serialzable&lt;/code&gt; 标签打在类上就行了。ABP vNext 还创建了基于 &lt;code&gt;StreamingContext&lt;/code&gt; 的构造函数，方便我们后续对序列化操作进行定制化处理。&lt;/p&gt;
&lt;p&gt;关于运行时序列化的相关文章，可以参考 《CLR Via C#》第 24 章，我也编写了相应的 &lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/myzony/p/9905717.html&quot;&gt;读书笔记&lt;/a&gt;&lt;/strong&gt; 。&lt;/p&gt;
&lt;h4 id=&quot;当前用户与客户端&quot;&gt;2.1.3 当前用户与客户端&lt;/h4&gt;
&lt;p&gt;开发人员经常会在各种地方需要获取当前的用户信息，ABP vNext 将当前用户封装到 &lt;code&gt;ICurrentUser&lt;/code&gt; 与其实现 &lt;code&gt;CurrentUser&lt;/code&gt; 当中，使用时只需要注入 &lt;code&gt;ICurrentUser&lt;/code&gt; 接口即可。&lt;/p&gt;
&lt;p&gt;我们首先康康 &lt;code&gt;ICurrentUser&lt;/code&gt; 接口的定义：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public interface ICurrentUser
{
    bool IsAuthenticated { get; }

    [CanBeNull]
    Guid? Id { get; }

    [CanBeNull]
    string UserName { get; }

    [CanBeNull]
    string PhoneNumber { get; }
    
    bool PhoneNumberVerified { get; }

    [CanBeNull]
    string Email { get; }

    bool EmailVerified { get; }

    Guid? TenantId { get; }

    [NotNull]
    string[] Roles { get; }

    [CanBeNull]
    Claim FindClaim(string claimType);

    [NotNull]
    Claim[] FindClaims(string claimType);

    [NotNull]
    Claim[] GetAllClaims();

    bool IsInRole(string roleName);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么这些值是从哪儿来的呢？从带有 &lt;code&gt;Claim&lt;/code&gt; 返回值的方法来看，肯定就是从 &lt;code&gt;HttpContext.User&lt;/code&gt; 或者 &lt;code&gt;Thread.CurrentPrincipal&lt;/code&gt; 里面拿到的。&lt;/p&gt;
&lt;p&gt;那么它的实现就非常简单了，只需要注入 ABP vNext 为我们提供的 &lt;code&gt;ICurrentPrincipalAccessor&lt;/code&gt; 访问器，我们就能够拿到这个身份容器(&lt;code&gt;ClaimsPrincipal&lt;/code&gt;)。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class CurrentUser : ICurrentUser, ITransientDependency
{
    // ... 其他代码

    public virtual string[] Roles =&amp;gt; FindClaims(AbpClaimTypes.Role).Select(c =&amp;gt; c.Value).ToArray();

    private readonly ICurrentPrincipalAccessor _principalAccessor;
    
    public CurrentUser(ICurrentPrincipalAccessor principalAccessor)
    {
        _principalAccessor = principalAccessor;
    }
    
    // ... 其他代码
    
    public virtual Claim[] FindClaims(string claimType)
    {
        // 直接使用 LINQ 查询对应的 Type 就能拿到上述信息。
        return _principalAccessor.Principal?.Claims.Where(c =&amp;gt; c.Type == claimType).ToArray() ?? EmptyClaimsArray;
    }
    
    // ... 其他代码
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;至于 &lt;code&gt;CurrentUserExtensions&lt;/code&gt; 扩展类，里面只是对 &lt;code&gt;ClaimsPrincipal&lt;/code&gt; 的搜索方法进行了多种封装而已。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;PS：&lt;/p&gt;
&lt;p&gt;除了 &lt;code&gt;ICurrentUser&lt;/code&gt; 与 &lt;code&gt;ICurrentClient&lt;/code&gt; 之外，在 ABP vNext 里面还有 &lt;code&gt;ICurrentTenant&lt;/code&gt; 来获取当前租户信息。通过这三个组件，取代了老 ABP 框架的 &lt;code&gt;IAbpSession&lt;/code&gt; 组件，三个组件都没有 &lt;code&gt;IAbpSession.Use()&lt;/code&gt; 扩展方法帮助我们临时更改当前用户/租户。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;claimsprincipal-访问器&quot;&gt;2.1.4 ClaimsPrincipal 访问器&lt;/h4&gt;
&lt;p&gt;关于 ClaimsPrincipal 的内容，可以参考杨总的 &lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/savorboard/p/aspnetcore-identity.html&quot;&gt;《ASP.NET Core 之 Identity 入门》&lt;/a&gt;&lt;/strong&gt; 进行了解，大致来说就是存有 &lt;code&gt;Claim&lt;/code&gt; 信息的聚合对象。&lt;/p&gt;
&lt;p&gt;关于 ABP vNext 框架预定义的 Claim Type 都存放在 &lt;code&gt;AbpClaimTypes&lt;/code&gt; 类型里面的，包括租户 Id、用户 Id 等数据，这些玩意儿最终会被放在 JWT(JSON Web Token) 里面去。&lt;/p&gt;
&lt;p&gt;一般来说 &lt;code&gt;ClaimsPrincipal&lt;/code&gt; 里面都是从 &lt;code&gt;HttpContext.User&lt;/code&gt; 或者 &lt;code&gt;Thread.CurrentPrincipal&lt;/code&gt; 得到的，ABP vNext 为我们抽象出了一个快速访问接口 &lt;code&gt;ICurrentPrincipalAccessor&lt;/code&gt;。开发人员注入之后，就可以获得当前用户的 &lt;code&gt;ClaimsPrincipal&lt;/code&gt; 对象。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public interface ICurrentPrincipalAccessor
{
    ClaimsPrincipal Principal { get; }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于 &lt;code&gt;Thread.CurrentPrincipal&lt;/code&gt; 的实现：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class ThreadCurrentPrincipalAccessor : ICurrentPrincipalAccessor, ISingletonDependency
{
    public virtual ClaimsPrincipal Principal =&amp;gt; Thread.CurrentPrincipal as ClaimsPrincipal;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而针对于 Http 上下文的实现，则是放在 &lt;strong&gt;Volo.Abp.AspNetCore&lt;/strong&gt; 模块里面的。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class HttpContextCurrentPrincipalAccessor : ThreadCurrentPrincipalAccessor
{
    // 如果没有获取到数据，则使用 Thread.CurrentPrincipal。
    public override ClaimsPrincipal Principal =&amp;gt; _httpContextAccessor.HttpContext?.User ?? base.Principal;

    private readonly IHttpContextAccessor _httpContextAccessor;

    public HttpContextCurrentPrincipalAccessor(IHttpContextAccessor httpContextAccessor)
    {
        _httpContextAccessor = httpContextAccessor;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;扩展知识两者的区别&quot;&gt;扩展知识：两者的区别？&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;Thread.CurrentPrincipal&lt;/code&gt; 可以设置/获得当前线程的 &lt;code&gt;ClaimsPrincipal&lt;/code&gt; 数据，而 &lt;code&gt;HttpContext?.User&lt;/code&gt; 一般都是被 ASP.NET Core 中间件所填充的。&lt;/p&gt;
&lt;p&gt;最新的 ASP.NET Core 开发建议是不要使用 &lt;code&gt;Thread.CurrentPrincipal&lt;/code&gt; 和 &lt;code&gt;ClaimsPrincipal.Current&lt;/code&gt; (内部实现还是使用的前者)。这是因为 &lt;code&gt;Thread.CurrentPrincipal&lt;/code&gt; 是一个静态成员...而这个静态成员在异步代码中会出现各种问题，例如有以下代码：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;// Create a ClaimsPrincipal and set Thread.CurrentPrincipal
var identity = new ClaimsIdentity();
identity.AddClaim(new Claim(ClaimTypes.Name, &quot;User1&quot;));
Thread.CurrentPrincipal = new ClaimsPrincipal(identity);

// Check the current user
Console.WriteLine($&quot;Current user: {Thread.CurrentPrincipal?.Identity.Name}&quot;);

// For the method to complete asynchronously
await Task.Yield();

// Check the current user after
Console.WriteLine($&quot;Current user: {Thread.CurrentPrincipal?.Identity.Name}&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当 &lt;code&gt;await&lt;/code&gt; 执行完成之后会产生线程切换，这个时候 Thread.CurrentPrincipal 的值就是 null 了，这就会产生不可预料的后果。&lt;/p&gt;
&lt;p&gt;如果你还想了解更多信息，可以参考以下两篇博文：&lt;/p&gt;
&lt;h4 id=&quot;字符串加密工具&quot;&gt;2.1.5 字符串加密工具&lt;/h4&gt;
&lt;p&gt;这一套东西就比较简单了，是 ABP vNext 为我们提供的一套开箱即用组件。开发人员可以使用 &lt;code&gt;IStringEncryptionService&lt;/code&gt; 来加密/解密你的字符串，默认实现是基于 &lt;code&gt;Rfc2898DeriveBytes&lt;/code&gt; 的。关于详细信息，你可以阅读具体的代码，这里不再赘述。&lt;/p&gt;
&lt;h3 id=&quot;权限与校验&quot;&gt;2.2 权限与校验&lt;/h3&gt;
&lt;p&gt;在 &lt;strong&gt;Volo.Abp.Authorization&lt;/strong&gt; 模块里面就对权限进行了具体定义，并且基于 ASP.NET Core Authentication 进行无缝集成。如果读者对于 ASP.NET Core 认证和授权不太了解，可以去学习一下 &lt;strong&gt;雨夜朦胧&lt;/strong&gt; 大神的&lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/RainingNight/p/introduce-basic-authentication-in-asp-net-core.html&quot;&gt;《ASP.NET Core 认证于授权》&lt;/a&gt;&lt;/strong&gt;系列文章，这里就不再赘述。&lt;/p&gt;
&lt;h4 id=&quot;权限的注册&quot;&gt;2.2.1 权限的注册&lt;/h4&gt;
&lt;p&gt;在 ABP vNext 框架里面，所有用户定义的权限都是通过继承 &lt;code&gt;PermissionDefinitionProvider&lt;/code&gt;，在其内部进行注册的。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public abstract class PermissionDefinitionProvider : IPermissionDefinitionProvider, ITransientDependency
{
    public abstract void Define(IPermissionDefinitionContext context);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;开发人员继承了这个 Provider 之后，在 &lt;code&gt;Define()&lt;/code&gt; 方法里面就可以注册自己的权限了，这里我以 Blog 模块的简化 Provider 为例。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class BloggingPermissionDefinitionProvider : PermissionDefinitionProvider
{
    public override void Define(IPermissionDefinitionContext context)
    {
        var bloggingGroup = context.AddGroup(BloggingPermissions.GroupName, L(&quot;Permission:Blogging&quot;));

                // ... 其他代码。
                
        var tags = bloggingGroup.AddPermission(BloggingPermissions.Tags.Default, L(&quot;Permission:Tags&quot;));
        tags.AddChild(BloggingPermissions.Tags.Update, L(&quot;Permission:Edit&quot;));
        tags.AddChild(BloggingPermissions.Tags.Delete, L(&quot;Permission:Delete&quot;));
        tags.AddChild(BloggingPermissions.Tags.Create, L(&quot;Permission:Create&quot;));

        var comments = bloggingGroup.AddPermission(BloggingPermissions.Comments.Default, L(&quot;Permission:Comments&quot;));
        comments.AddChild(BloggingPermissions.Comments.Update, L(&quot;Permission:Edit&quot;));
        comments.AddChild(BloggingPermissions.Comments.Delete, L(&quot;Permission:Delete&quot;));
        comments.AddChild(BloggingPermissions.Comments.Create, L(&quot;Permission:Create&quot;));
    }

        // 使用本地化字符串进行文本显示。
    private static LocalizableString L(string name)
    {
        return LocalizableString.Create&amp;lt;BloggingResource&amp;gt;(name);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上面的代码就可以看出来，权限被 ABP vNext 分成了 &lt;strong&gt;权限组定义&lt;/strong&gt; 和 &lt;strong&gt;权限定义&lt;/strong&gt;，这两个东西我们后面进行重点讲述。那么这些 Provider 在什么时候被执行呢？找到权限模块的定义，可以看到如下代码：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;[DependsOn(
    typeof(AbpSecurityModule),
    typeof(AbpLocalizationAbstractionsModule),
    typeof(AbpMultiTenancyModule)
    )]
public class AbpAuthorizationModule : AbpModule
{
    public override void PreConfigureServices(ServiceConfigurationContext context)
    {
        // 在 AutoFac 进行组件注册的时候，根据组件的类型定义视情况绑定拦截器。
        context.Services.OnRegistred(AuthorizationInterceptorRegistrar.RegisterIfNeeded);

        // 在 AutoFac 进行组件注册的时候，根据组件的类型，判断是否是 Provider。
        AutoAddDefinitionProviders(context.Services);
    }

    public override void ConfigureServices(ServiceConfigurationContext context)
    {
        // 注册认证授权服务。
        context.Services.AddAuthorization();

        // 替换掉 ASP.NET Core 提供的权限处理器，转而使用 ABP vNext 提供的权限处理器。
        context.Services.AddSingleton&amp;lt;IAuthorizationHandler, PermissionRequirementHandler&amp;gt;();

        // 这一部分是添加内置的一些权限值检查，后面我们在将 PermissionChecker 的时候会提到。
        Configure&amp;lt;PermissionOptions&amp;gt;(options =&amp;gt;
        {
            options.ValueProviders.Add&amp;lt;UserPermissionValueProvider&amp;gt;();
            options.ValueProviders.Add&amp;lt;RolePermissionValueProvider&amp;gt;();
            options.ValueProviders.Add&amp;lt;ClientPermissionValueProvider&amp;gt;();
        });
    }

    private static void AutoAddDefinitionProviders(IServiceCollection services)
    {
        var definitionProviders = new List&amp;lt;Type&amp;gt;();

        services.OnRegistred(context =&amp;gt;
        {
            if (typeof(IPermissionDefinitionProvider).IsAssignableFrom(context.ImplementationType))
            {
                definitionProviders.Add(context.ImplementationType);
            }
        });

        // 将获取到的 Provider 传递给 PermissionOptions 。
        services.Configure&amp;lt;PermissionOptions&amp;gt;(options =&amp;gt;
        {
            options.DefinitionProviders.AddIfNotContains(definitionProviders);
        });
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到在注册组件的时候，ABP vNext 就会将这些 Provider 传递给 &lt;code&gt;PermissionOptions&lt;/code&gt; ，我们根据 &lt;code&gt;DefinitionProviders&lt;/code&gt; 字段找到有一个地方会使用到它，就是 &lt;code&gt;PermissionDefinitionManager&lt;/code&gt; 类型的 &lt;code&gt;CreatePermissionGroupDefinitions()&lt;/code&gt; 方法。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;protected virtual Dictionary&amp;lt;string, PermissionGroupDefinition&amp;gt; CreatePermissionGroupDefinitions()
{
    //  创建一个权限定义上下文。
    var context = new PermissionDefinitionContext();

    // 创建一个临时范围用于解析 Provider，Provider 解析完成之后即被释放。
    using (var scope = _serviceProvider.CreateScope())
    {
        // 根据之前的类型，通过 IoC 进行解析出实例，指定各个 Provider 的 Define() 方法，会向权限上下文填充权限。
        var providers = Options
            .DefinitionProviders
            .Select(p =&amp;gt; scope.ServiceProvider.GetRequiredService(p) as IPermissionDefinitionProvider)
            .ToList();

        foreach (var provider in providers)
        {
            provider.Define(context);
        }
    }

    // 返回权限组名称 - 权限组定义的字典。
    return context.Groups;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你可能会奇怪，为什么返回的是一个权限组名字和定义的键值对，而不是返回的权限数据，我们之前添加的权限去哪儿了呢？&lt;/p&gt;
&lt;h4 id=&quot;权限和权限组的定义&quot;&gt;2.2.2 权限和权限组的定义&lt;/h4&gt;
&lt;p&gt;要搞清楚这个问题，我们首先要知道权限与权限组之间的关系是怎样的。回想我们之前在 Provider 里面添加权限的代码，首先我们是构建了一个权限组，然后往权限组里面添加的权限。权限组的作用就是将权限按照组的形式进行划分，方便代码进行访问于管理。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class PermissionGroupDefinition
{
    /// &amp;lt;summary&amp;gt;
    /// 唯一的权限组标识名称。
    /// &amp;lt;/summary&amp;gt;
    public string Name { get; }

    // 开发人员针对权限组的一些自定义属性。
    public Dictionary&amp;lt;string, object&amp;gt; Properties { get; }

    // 权限所对应的本地化名称。
    public ILocalizableString DisplayName
    {
        get =&amp;gt; _displayName;
        set =&amp;gt; _displayName = Check.NotNull(value, nameof(value));
    }
    private ILocalizableString _displayName;

    /// &amp;lt;summary&amp;gt;
    /// 权限的适用范围，默认是租户/租主都适用。
    /// 默认值: &amp;lt;see cref=&quot;MultiTenancySides.Both&quot;/&amp;gt;
    /// &amp;lt;/summary&amp;gt;
    public MultiTenancySides MultiTenancySide { get; set; }

    // 权限组下面的所属权限。
    public IReadOnlyList&amp;lt;PermissionDefinition&amp;gt; Permissions =&amp;gt; _permissions.ToImmutableList();
    private readonly List&amp;lt;PermissionDefinition&amp;gt; _permissions;

    // 针对于自定义属性的快捷索引器。
    public object this[string name]
    {
        get =&amp;gt; Properties.GetOrDefault(name);
        set =&amp;gt; Properties[name] = value;
    }

    protected internal PermissionGroupDefinition(
        string name, 
        ILocalizableString displayName = null,
        MultiTenancySides multiTenancySide = MultiTenancySides.Both)
    {
        Name = name;
        // 没有传递多语言串，则使用权限组的唯一标识作为显示内容。
        DisplayName = displayName ?? new FixedLocalizableString(Name);
        MultiTenancySide = multiTenancySide;

        Properties = new Dictionary&amp;lt;string, object&amp;gt;();
        _permissions = new List&amp;lt;PermissionDefinition&amp;gt;();
    }

    // 像权限组添加属于它的权限。
    public virtual PermissionDefinition AddPermission(
        string name, 
        ILocalizableString displayName = null,
        MultiTenancySides multiTenancySide = MultiTenancySides.Both)
    {
        var permission = new PermissionDefinition(name, displayName, multiTenancySide);

        _permissions.Add(permission);

        return permission;
    }

    // 递归构建权限集合，因为定义的某个权限内部还拥有子权限。
    public virtual List&amp;lt;PermissionDefinition&amp;gt; GetPermissionsWithChildren()
    {
        var permissions = new List&amp;lt;PermissionDefinition&amp;gt;();

        foreach (var permission in _permissions)
        {
            AddPermissionToListRecursively(permissions, permission);
        }

        return permissions;
    }

    // 递归构建方法。
    private void AddPermissionToListRecursively(List&amp;lt;PermissionDefinition&amp;gt; permissions, PermissionDefinition permission)
    {
        permissions.Add(permission);

        foreach (var child in permission.Children)
        {
            AddPermissionToListRecursively(permissions, child);
        }
    }

    public override string ToString()
    {
        return $&quot;[{nameof(PermissionGroupDefinition)} {Name}]&quot;;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过权限组的定义代码你就会知道，现在我们的所有权限都会归属于某个权限组，这一点从之前 Provider 的 &lt;code&gt;IPermissionDefinitionContext&lt;/code&gt; 就可以看出来。在权限上下文内部只允许我们通过 &lt;code&gt;AddGroup()&lt;/code&gt; 来添加一个权限组，之后再通过权限组的 &lt;code&gt;AddPermission()&lt;/code&gt; 方法添加它里面的权限。&lt;/p&gt;
&lt;p&gt;权限的定义类叫做 &lt;code&gt;PermissionDefinition&lt;/code&gt;，这个类型的构造与权限组定义类似，没有什么好说的。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class PermissionDefinition
{
    /// &amp;lt;summary&amp;gt;
    /// 唯一的权限标识名称。
    /// &amp;lt;/summary&amp;gt;
    public string Name { get; }

    /// &amp;lt;summary&amp;gt;
    /// 当前权限的父级权限，这个属性的值只可以通过 AddChild() 方法进行设置。
    /// &amp;lt;/summary&amp;gt;
    public PermissionDefinition Parent { get; private set; }

    /// &amp;lt;summary&amp;gt;
    /// 权限的适用范围，默认是租户/租主都适用。
    /// 默认值: &amp;lt;see cref=&quot;MultiTenancySides.Both&quot;/&amp;gt;
    /// &amp;lt;/summary&amp;gt;
    public MultiTenancySides MultiTenancySide { get; set; }

    /// &amp;lt;summary&amp;gt;
    /// 适用的权限值提供者，这块我们会在后面进行讲解，为空的时候则使用所有的提供者进行校验。
    /// &amp;lt;/summary&amp;gt;
    public List&amp;lt;string&amp;gt; Providers { get; } //TODO: Rename to AllowedProviders?

    // 权限的多语言名称。
    public ILocalizableString DisplayName
    {
        get =&amp;gt; _displayName;
        set =&amp;gt; _displayName = Check.NotNull(value, nameof(value));
    }
    private ILocalizableString _displayName;

    // 获取权限的子级权限。
    public IReadOnlyList&amp;lt;PermissionDefinition&amp;gt; Children =&amp;gt; _children.ToImmutableList();
    private readonly List&amp;lt;PermissionDefinition&amp;gt; _children;

    /// &amp;lt;summary&amp;gt;
    /// 开发人员针对权限的一些自定义属性。
    /// &amp;lt;/summary&amp;gt;
    public Dictionary&amp;lt;string, object&amp;gt; Properties { get; }

    // 针对于自定义属性的快捷索引器。
    public object this[string name]
    {
        get =&amp;gt; Properties.GetOrDefault(name);
        set =&amp;gt; Properties[name] = value;
    }

    protected internal PermissionDefinition(
        [NotNull] string name, 
        ILocalizableString displayName = null,
        MultiTenancySides multiTenancySide = MultiTenancySides.Both)
    {
        Name = Check.NotNull(name, nameof(name));
        DisplayName = displayName ?? new FixedLocalizableString(name);
        MultiTenancySide = multiTenancySide;

        Properties = new Dictionary&amp;lt;string, object&amp;gt;();
        Providers = new List&amp;lt;string&amp;gt;();
        _children = new List&amp;lt;PermissionDefinition&amp;gt;();
    }

    public virtual PermissionDefinition AddChild(
        [NotNull] string name, 
        ILocalizableString displayName = null,
        MultiTenancySides multiTenancySide = MultiTenancySides.Both)
    {
        var child = new PermissionDefinition(
            name, 
            displayName, 
            multiTenancySide)
        {
            Parent = this
        };

        _children.Add(child);

        return child;
    }

    /// &amp;lt;summary&amp;gt;
    /// 设置指定的自定义属性。
    /// &amp;lt;/summary&amp;gt;
    public virtual PermissionDefinition WithProperty(string key, object value)
    {
        Properties[key] = value;
        return this;
    }

    /// &amp;lt;summary&amp;gt;
    /// 添加一组权限值提供者集合。
    /// &amp;lt;/summary&amp;gt;
    public virtual PermissionDefinition WithProviders(params string[] providers)
    {
        if (!providers.IsNullOrEmpty())
        {
            Providers.AddRange(providers);
        }

        return this;
    }

    public override string ToString()
    {
        return $&quot;[{nameof(PermissionDefinition)} {Name}]&quot;;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;权限管理器&quot;&gt;2.2.3 权限管理器&lt;/h4&gt;
&lt;p&gt;继续回到权限管理器，权限管理器的接口定义是 &lt;code&gt;IPermissionDefinitionManager&lt;/code&gt; ，从接口的方法定义来看，都是获取权限的方法，说明权限管理器主要提供给其他组件进行权限校验操作。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public interface IPermissionDefinitionManager
{
    // 根据权限定义的唯一标识获取权限，一旦不存在就会抛出 AbpException 异常。
    [NotNull]
    PermissionDefinition Get([NotNull] string name);

    // 根据权限定义的唯一标识获取权限，如果权限不存在，则返回 null。
    [CanBeNull]
    PermissionDefinition GetOrNull([NotNull] string name);

    // 获取所有的权限。
    IReadOnlyList&amp;lt;PermissionDefinition&amp;gt; GetPermissions();
    
    // 获取所有的权限组。
    IReadOnlyList&amp;lt;PermissionGroupDefinition&amp;gt; GetGroups();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接着我们来回答 2.2.1 末尾提出的问题，权限组是根据 Provider 自动创建了，那么权限呢？其实我们在权限管理器里面拿到了权限组，权限定义就很好构建了，直接遍历所有权限组拿它们的 &lt;code&gt;Permissions&lt;/code&gt; 属性构建即可。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;protected virtual Dictionary&amp;lt;string, PermissionDefinition&amp;gt; CreatePermissionDefinitions()
{
    var permissions = new Dictionary&amp;lt;string, PermissionDefinition&amp;gt;();

    // 遍历权限定义组，这个东西在之前就已经构建好了。
    foreach (var groupDefinition in PermissionGroupDefinitions.Values)
    {
        // 递归子级权限。
        foreach (var permission in groupDefinition.Permissions)
        {
            AddPermissionToDictionaryRecursively(permissions, permission);
        }
    }

    // 返回权限唯一标识 - 权限定义 的字典。
    return permissions;
}

protected virtual void AddPermissionToDictionaryRecursively(
    Dictionary&amp;lt;string, PermissionDefinition&amp;gt; permissions, 
    PermissionDefinition permission)
{
    if (permissions.ContainsKey(permission.Name))
    {
        throw new AbpException(&quot;Duplicate permission name: &quot; + permission.Name);
    }

    permissions[permission.Name] = permission;

    foreach (var child in permission.Children)
    {
        AddPermissionToDictionaryRecursively(permissions, child);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;授权策略提供者的实现&quot;&gt;2.2.4 授权策略提供者的实现&lt;/h4&gt;
&lt;p&gt;我们发现 ABP vNext 自己实现了 &lt;code&gt;IAbpAuthorizationPolicyProvider&lt;/code&gt; 接口，实现的类型就是 &lt;code&gt;AbpAuthorizationPolicyProvider&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;这个类型它是继承的 &lt;code&gt;DefaultAuthorizationPolicyProvider&lt;/code&gt; ，重写了 &lt;code&gt;GetPolicyAsync()&lt;/code&gt; 方法，目的就是将 &lt;code&gt;PermissionDefinition&lt;/code&gt; 转换为 &lt;code&gt;AuthorizationPolicy&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;如果去看了 &lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/RainingNight/p/authorization-in-asp-net-core.html&quot;&gt;雨夜朦胧&lt;/a&gt;&lt;/strong&gt; 大神的博客，就知道我们一个授权策略可以由多个条件构成。也就是说某一个 &lt;code&gt;AuthorizationPolicy&lt;/code&gt; 可以拥有多个限定条件，当所有限定条件被满足之后，才能算是通过权限验证，例如以下代码。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public void ConfigureService(IServiceCollection services)
{
    services.AddAuthorization(options =&amp;gt;
    {
        options.AddPolicy(&quot;User&quot;, policy =&amp;gt; policy
            .RequireAssertion(context =&amp;gt; context.User.HasClaim(c =&amp;gt; (c.Type == &quot;EmployeeNumber&quot; || c.Type == &quot;Role&quot;)))
        );

        // 这里的意思是，用户角色必须是 Admin，并且他的用户名是 Alice，并且必须要有类型为 EmployeeNumber 的 Claim。
        options.AddPolicy(&quot;Employee&quot;, policy =&amp;gt; policy
            .RequireRole(&quot;Admin&quot;)
            .RequireUserName(&quot;Alice&quot;)
            .RequireClaim(&quot;EmployeeNumber&quot;)
            .Combine(commonPolicy));
    });
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的 &lt;code&gt;RequireRole()&lt;/code&gt; 、&lt;code&gt;RequireUserName()&lt;/code&gt;、&lt;code&gt;RequireClaim()&lt;/code&gt; 都会生成一个 &lt;code&gt;IAuthorizationRequirement&lt;/code&gt; 对象，它们在内部有不同的实现规则。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public AuthorizationPolicyBuilder RequireClaim(string claimType)
{
    if (claimType == null)
    {
        throw new ArgumentNullException(nameof(claimType));
    }

    // 构建了一个 ClaimsAuthorizationRequirement 对象，并添加到策略的 Requirements 组。
    Requirements.Add(new ClaimsAuthorizationRequirement(claimType, allowedValues: null));
    return this;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里我们 ABP vNext 则是使用的 &lt;code&gt;PermissionRequirement&lt;/code&gt; 作为一个限定条件。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public override async Task&amp;lt;AuthorizationPolicy&amp;gt; GetPolicyAsync(string policyName)
{
    var policy = await base.GetPolicyAsync(policyName);
    if (policy != null)
    {
        return policy;
    }

    var permission = _permissionDefinitionManager.GetOrNull(policyName);
    if (permission != null)
    {
        // TODO: 可以使用缓存进行优化。
        // 通过 Builder 构建一个策略。
        var policyBuilder = new AuthorizationPolicyBuilder(Array.Empty&amp;lt;string&amp;gt;());
        // 创建一个 PermissionRequirement 对象添加到限定条件组中。
        policyBuilder.Requirements.Add(new PermissionRequirement(policyName));
        return policyBuilder.Build();
    }

    return null;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;与 &lt;code&gt;ClaimsAuthorizationRequirement&lt;/code&gt; 不同的是，ABP vNext 并没有将限定条件处理器和限定条件定义放在一起实现，而是分开的，分别构成了 &lt;code&gt;PermissionRequirement&lt;/code&gt; 和 &lt;code&gt;PermissionRequirementHandler&lt;/code&gt; ，后者在模块配置的时候被注入到 IoC 里面。&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;PS：&lt;/p&gt;
&lt;p&gt;对于 Handler 来说，我们可以编写多个 Handler 注入到 IoC 容器内部，如下代码：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;services.AddSingleton&amp;lt;IAuthorizationHandler, BadgeEntryHandler&amp;gt;();
services.AddSingleton&amp;lt;IAuthorizationHandler, HasTemporaryStickerHandler&amp;gt;();&lt;/code&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt;首先看限定条件 &lt;code&gt;PermissionRequirement&lt;/code&gt; 的定义，非常简单。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class PermissionRequirement : IAuthorizationRequirement
{
    public string PermissionName { get; }

    public PermissionRequirement([NotNull]string permissionName)
    {
        Check.NotNull(permissionName, nameof(permissionName));

        PermissionName = permissionName;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在限定条件内部，我们只用了权限的唯一标识来进行处理，接下来看一下权限处理器。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class PermissionRequirementHandler : AuthorizationHandler&amp;lt;PermissionRequirement&amp;gt;
{
        // 这里通过权限检查器来确定当前用户是否拥有某个权限。
    private readonly IPermissionChecker _permissionChecker;

    public PermissionRequirementHandler(IPermissionChecker permissionChecker)
    {
        _permissionChecker = permissionChecker;
    }

    protected override async Task HandleRequirementAsync(
        AuthorizationHandlerContext context,
        PermissionRequirement requirement)
    {
            // 如果当前用户拥有某个权限，则通过 Contxt.Succeed() 通过授权验证。
        if (await _permissionChecker.IsGrantedAsync(context.User, requirement.PermissionName))
        {
            context.Succeed(requirement);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;权限检查器&quot;&gt;2.2.5 权限检查器&lt;/h4&gt;
&lt;p&gt;在上面的处理器我们看到了，ABP vNext 是通过权限检查器来校验某个用户是否满足某个授权策略，先看一下 &lt;code&gt;IPermissionChecker&lt;/code&gt; 接口的定义，基本都是传入身份证(&lt;code&gt;ClaimsPrincipal&lt;/code&gt;)和需要校验的权限进行处理。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public interface IPermissionChecker
{
    Task&amp;lt;bool&amp;gt; IsGrantedAsync([NotNull]string name);

    Task&amp;lt;bool&amp;gt; IsGrantedAsync([CanBeNull] ClaimsPrincipal claimsPrincipal, [NotNull]string name);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第一个方法内部就是调用的第二个方法，只不过传递的身份证是通过 &lt;code&gt;ICurrentPrincipalAccessor&lt;/code&gt; 拿到的，所以我们的核心还是看第二个方法的实现。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public virtual async Task&amp;lt;bool&amp;gt; IsGrantedAsync(ClaimsPrincipal claimsPrincipal, string name)
{
    Check.NotNull(name, nameof(name));

    var permission = PermissionDefinitionManager.Get(name);

    var multiTenancySide = claimsPrincipal?.GetMultiTenancySide()
                            ?? CurrentTenant.GetMultiTenancySide();

    // 检查传入的权限是否允许当前的用户模式（租户/租主）进行访问。
    if (!permission.MultiTenancySide.HasFlag(multiTenancySide))
    {
        return false;
    }

    var isGranted = false;
    // 这里是重点哦，这个权限值检测上下文是之前没有说过的东西，说白了就是针对不同维度的权限检测。
    // 之前这部分东西是通过权限策略下面的 Requirement 提供的，这里 ABP vNext 将其抽象为 PermissionValueProvider。
    var context = new PermissionValueCheckContext(permission, claimsPrincipal);
    foreach (var provider in PermissionValueProviderManager.ValueProviders)
    {
        // 如果指定的权限允许的权限值提供者集合不包含当前的 Provider，则跳过处理。
        if (context.Permission.Providers.Any() &amp;amp;&amp;amp;
            !context.Permission.Providers.Contains(provider.Name))
        {
            continue;
        }

        // 调用 Provider 的检测方法，传入身份证明和权限定义进行具体校验。
        var result = await provider.CheckAsync(context);

        // 根据返回的结果，判断是否通过了权限校验。
        if (result == PermissionGrantResult.Granted)
        {
            isGranted = true;
        }
        else if (result == PermissionGrantResult.Prohibited)
        {
            return false;
        }
    }

    // 返回 true 说明已经授权，返回 false 说明是没有授权的。
    return isGranted;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;permissionvalueprovider&quot;&gt;2.2.6 PermissionValueProvider&lt;/h4&gt;
&lt;p&gt;在模块配置方法内部，可以看到通过 &lt;code&gt;Configure&amp;lt;PermissionOptions&amp;gt;()&lt;/code&gt; 方法添加了三个 &lt;code&gt;PermissionValueProvider&lt;/code&gt; ，即 &lt;code&gt;UserPermissionValueProvider&lt;/code&gt;、&lt;code&gt;RolePermissionValueProvider&lt;/code&gt;、&lt;code&gt;ClientPermissionValueProvider&lt;/code&gt; 。在它们的内部实现，都是通过 &lt;code&gt;IPermissionStore&lt;/code&gt; 从持久化存储 &lt;strong&gt;检查传入的用户是否拥有某个权限&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这里我们以 &lt;code&gt;UserPermissionValueProvider&lt;/code&gt; 为例，来看看它的实现方法。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class UserPermissionValueProvider : PermissionValueProvider
{
    // 提供者的名称。
    public const string ProviderName = &quot;User&quot;;

    public override string Name =&amp;gt; ProviderName;

    public UserPermissionValueProvider(IPermissionStore permissionStore)
        : base(permissionStore)
    {

    }

    public override async Task&amp;lt;PermissionGrantResult&amp;gt; CheckAsync(PermissionValueCheckContext context)
    {
        // 从传入的 Principal 中查找 UserId，不存在则说明没有定义，视为未授权。
        var userId = context.Principal?.FindFirst(AbpClaimTypes.UserId)?.Value;

        if (userId == null)
        {
            return PermissionGrantResult.Undefined;
        }

        // 调用 IPermissionStore 从持久化存储中，检测指定权限在某个提供者下面是否已经被授予了权限。
        // 如果被授予了权限， 则返回 true，没有则返回 false。
        return await PermissionStore.IsGrantedAsync(context.Permission.Name, Name, userId)
            ? PermissionGrantResult.Granted
            : PermissionGrantResult.Undefined;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里我们先不讲 &lt;code&gt;IPermissionStore&lt;/code&gt; 的具体实现，就上述代码来看，ABP vNext 是将权限定义放在了一个管理容器(&lt;code&gt;IPermissionDeftiionManager&lt;/code&gt;)。然后又实现了自定义的策略处理器和策略，在处理器的内部又通过 &lt;code&gt;IPermissionChecker&lt;/code&gt; 根据不同的 &lt;code&gt;PermissionValueProvider&lt;/code&gt; 结合 &lt;code&gt;IPermissionStore&lt;/code&gt; 实现了指定用户标识到权限的检测功能。&lt;/p&gt;
&lt;h4 id=&quot;权限验证拦截器&quot;&gt;2.2.7 权限验证拦截器&lt;/h4&gt;
&lt;p&gt;权限验证拦截器的注册都是在 &lt;code&gt;AuthorizationInterceptorRegistrar&lt;/code&gt; 的 &lt;code&gt;RegisterIfNeeded()&lt;/code&gt; 方法内实现的，只要类型的任何一个方法标注了 &lt;code&gt;AuthorizeAttribute&lt;/code&gt; 特性，就会被关联拦截器。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;private static bool AnyMethodHasAuthorizeAttribute(Type implementationType)
{
    return implementationType
        .GetMethods(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic)
        .Any(HasAuthorizeAttribute);
}

private static bool HasAuthorizeAttribute(MemberInfo methodInfo)
{
    return methodInfo.IsDefined(typeof(AuthorizeAttribute), true);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;拦截器和类型关联之后，会通过 &lt;code&gt;IMethodInvocationAuthorizationService&lt;/code&gt; 的 &lt;code&gt;CheckAsync()&lt;/code&gt; 方法校验调用者是否拥有指定权限。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public override async Task InterceptAsync(IAbpMethodInvocation invocation)
{
    // 防止重复检测。
    if (AbpCrossCuttingConcerns.IsApplied(invocation.TargetObject, AbpCrossCuttingConcerns.Authorization))
    {
        await invocation.ProceedAsync();
        return;
    }

    // 将被调用的方法传入，验证是否允许访问。
    await AuthorizeAsync(invocation);
    await invocation.ProceedAsync();
}

protected virtual async Task AuthorizeAsync(IAbpMethodInvocation invocation)
{
    await _methodInvocationAuthorizationService.CheckAsync(
        new MethodInvocationAuthorizationContext(
            invocation.Method
        )
    );
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在具体的实现当中，首先检测方法是否标注了 &lt;code&gt;IAllowAnonymous&lt;/code&gt; 特性，标注了则说明允许匿名访问，直接返回不做任何处理。否则就会从方法获取实现了 &lt;code&gt;IAuthorizeData&lt;/code&gt; 接口的特性，从里面拿到 &lt;code&gt;Policy&lt;/code&gt; 值，并通过 &lt;code&gt;IAuthorizationService&lt;/code&gt; 进行验证。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;protected async Task CheckAsync(IAuthorizeData authorizationAttribute)
{
    if (authorizationAttribute.Policy == null)
    {
        // 如果当前调用者没有进行认证，则抛出未登录的异常。
        if (!_currentUser.IsAuthenticated &amp;amp;&amp;amp; !_currentClient.IsAuthenticated)
        {
            throw new AbpAuthorizationException(&quot;Authorization failed! User has not logged in.&quot;);
        }
    }
    else
    {
        // 通过 IAuthorizationService 校验当前用户是否拥有 authorizationAttribute.Policy 权限。
        await _authorizationService.CheckAsync(authorizationAttribute.Policy);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;针对于 &lt;code&gt;IAuthorizationService&lt;/code&gt; ，ABP vNext 还是提供了自己的实现 &lt;code&gt;AbpAuthorizationService&lt;/code&gt;，里面没有重写什么方法，而是提供了两个新的属性，这两个属性是为了方便实现 &lt;code&gt;AbpAuthorizationServiceExtensions&lt;/code&gt; 提供的扩展方法，这里不再赘述。&lt;/p&gt;
&lt;h2 id=&quot;三总结&quot;&gt;三、总结&lt;/h2&gt;
&lt;p&gt;关于权限与验证部分我就先讲到这儿，后续文章我会更加详细地为大家分析 ABP vNext 是如何进行权限管理，又是如何将 ABP vNext 和 ASP.NET Identity 、IdentityServer4 进行集成的。&lt;/p&gt;
</description>
<pubDate>Wed, 07 Aug 2019 00:08:00 +0000</pubDate>
<dc:creator>myzony</dc:creator>
<og:description>一、简要说明 在上篇文章里面，我们在 当中看到了权限检测代码，通过注入 就可以实现权限检测。不过跳转到源码才发现，这个接口是 ASP.NET Core 原生提供的 “基于策略” 的权限验证接口，这就说</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/myzony/p/11312928.html</dc:identifier>
</item>
<item>
<title>Docker系列开篇之Virtual Machine VS Container（一） - Jeffcky</title>
<link>http://www.cnblogs.com/CreateMyself/p/10702559.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CreateMyself/p/10702559.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;本节开始我们正式进入Docker系列，网上关于Docker相关文章如数家珍，写博客至今，我也一直在朝着如何写出通俗易懂且不枯燥的文章这个目标前进，喃喃自语的同时也希望看到文章的童鞋能明白我在讲什么，将知识点叙述清楚没有，讲解的效果如何，是否有启发或收获，能够得到及时的反馈当然也能让我理解的更透彻，好了，我们开始吧。&lt;/p&gt;

&lt;h2&gt;Virtual Machine VS Container&lt;/h2&gt;
&lt;p&gt;开篇我不打算直接讲解各个概念，将虚拟机和容器作比较至关重要，这都是基本概念。既然是系列文章也要适合如我一样作为初学者的入门指南，希望本系列文章能帮助到大家。容器和虚拟机的问世是解决什么问题呢？换句话说它两的作用是什么呢？&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;容器和虚拟机的作用相似：都是将应用程序及其依赖隔离到可以在任何地方运行的独立单元，同时二者都消除了对物理硬件的需求，能更有效的使用计算机资源&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;讨论完相似，当然我也得说说二者的不同之处在哪里？区别在于二者的架构处理。下面我们来分别讲讲虚拟机和容器。&lt;/p&gt;
&lt;h3&gt;Virtual Machine&lt;/h3&gt;
&lt;p&gt;虚拟机的本质上对真实计算机的仿真，就好比玩具枪对真实枪支的仿真或模拟一样，功能类似，虚拟机借用Hypervisor（管理程序）在物理机器上运行，既然虚拟机可以在Hypervisor上运行，反之，Hypervisor可以在主机上运行，也可以直接在裸机上运行。说到这里，我们又得讲讲Hypervisor是啥玩意，刚才我们讲了Hypervisor（下面我们用管理程序代替）是虚拟机运行的软件，管理程序本身是运行在物理计算机上，这里的物理计算机我们称为【主机】，主机可以为虚拟机提供RAM和CPU，通俗一点讲则是为虚拟机提供内存存储和计算资源，主机为虚拟机提供了RAM和CPU，那么在一台主机上若有多台虚拟机，我们根据需要为多台虚拟机来划分或分发这些资源，因此，如果一台虚拟机运行着更多的应用程序，那么我们可能需要为其分配更多的资源，而不是为在一台主机上运行其他的虚拟机分配更多的资源。&lt;/p&gt;

&lt;p&gt;在主机上使用管理程序运行的虚拟机，我们称为【客户机】，该客户机包含运行的应用程序以及应用程序所需要的任何内容，比如依赖的库等等，同时客户机还拥有自己的整个虚拟化硬件堆栈，比如包括虚拟化网络适配器、存储、CPU等等，通过这样描述，我们知道客户机拥有属于自己的一套完整的客户机操作系统，从内部来看，客户机有自己的专属资源，从外部来看，客户机共享主机资源。&lt;/p&gt;

&lt;p&gt;综上所述，客户机可以托管虚拟机管理程序或裸机虚拟机管理程序而运行，那么这二者又有什么差异呢？&lt;/p&gt;

&lt;p&gt;托管虚拟机管理程序运行在主机的操作系统上，比如运行OSX（苹果操作系统）的计算机可以在该OS（操作系统）之上运行Virual Box或Virtual Machine，同时最重要的一点是，因为虚拟机共享主机资源，所以虚拟机无法直接访问硬件，必须借助主机操作系统来进行访问。想必到了这里我们知道了托管虚拟机管理程序的好处是它并不需要关心底层硬件，也就是说底层硬件对虚拟机管理程序来说并不重要，就好比我们直奔菜市场，我们的任务或者重心放在买当天所需要的菜，而并不是关心菜是怎么种出来的一样，这个例子也恰巧说明了面向对象和面向过程的概念。而主机的操作系统负责硬件驱动程序而不是虚拟机管理程序本身，因为虚拟机管理程序和硬件之间多了夹带了附加层，所以带来了更多了资源开销，从而降低了虚拟机的性能。&lt;/p&gt;

&lt;p&gt;裸机虚拟机管理程序通过在主机的硬件上安装和运行，因为它直接与底层硬件连接或打交道，所以解决了性能问题，它完全不需要运行主机操作系统，作为安装在主机上的操作系统当然主要就是为了管理程序，裸机虚拟机管理程序与托管虚拟机管理程序不同的是，裸机虚拟机管理程序拥有属于自己的设备驱动程序，可以直接与底层每个组件进行交互，以执行任何I/O或处理操作系统上特定的任务，如此可以在可伸缩性或稳定上而获得更好的性能。好了，到了这里我们讨论完了虚拟机管理程序和裸机虚拟机管理程序的区别，可能有一个大大的疑问，为何在虚拟机和主机之间要附带额外的这一层呢？因为虚拟机有属于自己一套虚拟化操作系统，而主机也有一套真实的操作系统，所以虚拟机管理程序为虚拟机提供管理和在执行虚拟机操作系统的平台上发挥着重要的作用，它允许主机在作为客户端运行的虚拟机共享其资源。&lt;/p&gt;

&lt;p&gt;如下图（图片来源于园友：纯洁的微笑），虚拟机包含虚拟硬件、内核（即操作系统）、用户空间。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/589642/201908/589642-20190806223601494-572777195.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;Container&lt;/h3&gt;
&lt;p&gt;我们来揭开容器的面纱，与虚拟化硬件的虚拟机不同的是，容器通过抽象用户空间来提供操作系统级虚拟化，如下图（图片来源于网络）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/589642/201908/589642-20190806223502428-694826565.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图仅仅只打包用户空间而不包含内核和虚拟硬件，每个容器都有属于自己的独立用户空间，以此来允许多个容器运行在单个主机上，也就是网上很多资料所提及的容器进一步封装了linux，占用资源少。同时我们也可以看到所有操作系统级的体系结构都在容器之间共享，这也就是网上很多资料所提及的容器轻巧的原因。&lt;/p&gt;

&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;本节内容我们就到这里，内容太多也容易引起视觉疲劳，不出意外的话，关于Docker系列，应该会坚持每日一更，感谢阅读，下节再会。&lt;/p&gt;
</description>
<pubDate>Tue, 06 Aug 2019 23:39:00 +0000</pubDate>
<dc:creator>Jeffcky</dc:creator>
<og:description>前言 本节开始我们正式进入Docker系列，网上关于Docker相关文章如数家珍，写博客至今，我也一直在朝着如何写出通俗易懂且不枯燥的文章这个目标前进，喃喃自语的同时也希望看到文章的童鞋能明白我在讲什</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/CreateMyself/p/10702559.html</dc:identifier>
</item>
<item>
<title>旁友数独会伐啦？python秒解数独了解下伐啦？ - 上海小胖</title>
<link>http://www.cnblogs.com/moonhmily/p/11312887.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/moonhmily/p/11312887.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/649191/201908/649191-20190807063452900-317043873.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;前几天和隔壁邻居玩斗地主被发现了，牌被没收了，斗地主是斗不了了，但我还想和邻居玩耍。如果你还想斗斗地主，戳：&lt;a href=&quot;https://www.cnblogs.com/moonhmily/p/11306668.html&quot;&gt;趁老王不在，和隔壁邻居斗斗地主，比比大小&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;想破脑袋终于让我想到一个游戏，数独！什么叫数独？数独就是可以让我趁老王不在的时候和隔壁邻居一起玩耍的游戏！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/649191/201908/649191-20190807063433731-633425848.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;1、数字 1-9 在每一行只能出现一次。&lt;/p&gt;
&lt;p&gt;2、数字 1-9 在每一列只能出现一次。&lt;/p&gt;
&lt;p&gt;3、数字 1-9 在每一个 3x3 宫内只能出现一次。3x3 的宫内为A1-C3,A4-C6,A7-C9,D1-F3,D4-F6,D7-F9...&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/649191/201908/649191-20190807063504349-266313666.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;1、数独我们使用一个二维列表存储,没有值的位置我们使用''空字符窜占位。（二维数组）&lt;/p&gt;
&lt;p&gt;2、得到每一个3*3的宫内,每一行，每一列已有的数据，然后存放起来。3、得到所有的空缺位置，再遍历空缺位置，尝试放置数据，然后进行判断，如果满足条件安继续放置下一个。以此类推，在途中有不满足条件的情况，就进行回溯，返回上一次满足条件的情况，在进行另一次尝试。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190807063014685.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;操作系统：windows10&lt;/li&gt;
&lt;li&gt;python版本：python 3.7&lt;/li&gt;
&lt;li&gt;代码编辑器：pycharm 2018.2&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;1、首选我们创建一个类&lt;code&gt;SudoKu&lt;/code&gt;。编写构造函数。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class SudoKu():
    def __init__(self,sudo_ku_data):
        # 判断传入的数独是否满足格式
        if not isinstance(sudo_ku_data,list):
            raise TypeError(f'sudo_ku_data params must a list, but {sudo_ku_data} is a {type(sudo_ku_data)}')

        if len(sudo_ku_data) != 9 or len(sudo_ku_data[0]) != 9:
            raise TypeError(f'sudo_ku_data params must a 9*9 list, but {sudo_ku_data} is a {len(sudo_ku_data)}*{len(sudo_ku_data[0])} list')

        self.sudo_ku = sudo_ku_data
        # 存放每一行已有的数据
        self.every_row_data = {}
        # 每一列已有的数字
        self.every_column_data = {}
        # 每一个3*3宫内有的数字
        self.every_three_to_three_data = {}
        # 每一个空缺的位置
        self.vacant_position = []
        # 每一个空缺位置尝试了的数字
        self.every_vacant_position_tried_values = {}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2、编写添加每一行，每一列，每一宫方法，方便我们后面调用&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def _add_row_data(self,row,value):
    '''
    添加数据到self.every_row_data中,即对每一行已有的数据进行添加
    :param row:
    :param value:
    :return:
    '''
    # 如果当前行不存在，就以当前行为key，初始化值为set()（空的集合）
    if row not in self.every_row_data:
        self.every_row_data[row] = set()

    # 如果这个值已经出现过在这一行了，说明传入的不是一个正确的数独
    if value in self.every_row_data[row]:
        raise TypeError(f'params {self.sudo_ku} is a invalid SudoKu')

    self.every_row_data[row].add(value)

def _add_column_data(self,column,value):
    '''
    添加数据到self.every_column_data中,上面的函数思路一样
    :param column:
    :param value:
    :return:
    '''
    if column not in self.every_column_data:
        self.every_column_data[column] = set()

    if value in self.every_column_data[column]:
        raise TypeError(f'params {self.sudo_ku} is a invalid SudoKu')

    self.every_column_data[column].add(value)

def _get_three_to_three_key(self,row,column):
    '''
    得到该位置在哪一个3*3的宫内
    :param row:
    :param column:
    :return:
    '''
    if row in [0,1,2]:
        if column in [0,1,2]:
            key = 1
        elif column in [3,4,5]:
            key = 2
        else:
            key = 3
    elif row in [3,4,5]:
        if column in [0,1,2]:
            key = 4
        elif column in [3,4,5]:
            key = 5
        else:
            key = 6
    else:
        if column in [0,1,2]:
            key = 7
        elif column in [3,4,5]:
            key = 8
        else:
            key = 9

    return key

def _add_three_to_three_data(self,row,column,value):
    '''
    添加数据到self.every_three_to_three_data中
    :param row:
    :param column:
    :param value:
    :return:
    '''
    # 首先得到在哪一个3*3的宫内
    key = self._get_three_to_three_key(row,column)

    # 然后也和上面添加行，列的思路一样
    if key not in self.every_three_to_three_data:
        self.every_three_to_three_data[key] = set()

    if value in self.every_three_to_three_data[key]:
        raise TypeError(f'params {self.sudo_ku} is a invalid SudoKu')

    self.every_three_to_three_data[key].add(value)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3、遍历数独，对每种数据进行初始化&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def _init(self):
    '''
    根据传入的数独，初始化数据
    :return:
    '''
    for row,row_datas in enumerate(self.sudo_ku):
        for column,value in enumerate(row_datas):
            if value == '':
                # 添加空缺位置
                self.vacant_position.append( (row,column) )
            else:
                # 添加行数据
                self._add_row_data(row,value)
                # 添加列数据
                self._add_column_data(column,value)
                # 添加宫数据
                self._add_three_to_three_data(row,column,value)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;4、编写判断某一个位置的值是否合法的函数&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def _judge_value_is_legal(self,row,column,value):
    '''
    判断方放置的数据是否合法
    :param row:
    :param column:
    :param value:
    :return:
    '''

    # value是否存在这一行数据中
    if value in self.every_row_data[row]:
        return False
    # value是否存在这一列数据中
    if value in self.every_column_data[column]:
        return False

    # value是否存在这个3*3的宫内
    key = self._get_three_to_three_key(row,column)
    if value in self.every_three_to_three_data[key]:
        return False

    return True&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;5、编写计算的函数，在当前位置循环 可以使用的额数据，确定可以是否可以放置这个值&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def _calculate(self, vacant_position):
    '''
    计算，开始对数独进行放置值
    :param vacant_position:
    :return:
    '''
    # 得到当前位置
    row,column = vacant_position
    values = set(range(1,10))

    # 对当前为位置创建一个唯一key,用来存放当前位置已经尝试了的数据
    key = str(row) + str(column)
    # 如果这个key存在，就对values进行取差集，因为两个都是集合（set），直接使用-就行了
    if key in self.every_vacant_position_tried_values:
        values = values - self.every_vacant_position_tried_values[key]
    # 如果这个key不存在，就创建一个空的集合
    else:
        self.every_vacant_position_tried_values[key] = set()

    for value in values:
        # 对当前数据添加到当前位置尝试过的的数据中
        self.every_vacant_position_tried_values[key].add(value)
        # 如果当前value合法，可以放置
        if self._judge_value_is_legal(row,column,value):
            print(f'set {vacant_position} value is {value}')
            # 更新 判断数据合法时 需要使用到的数据
            self.every_column_data[column].add(value)
            self.every_row_data[row].add(value)
            key = self._get_three_to_three_key(row,column)
            self.every_three_to_three_data[key].add(value)

            # 修改这个位置的值为value
            self.sudo_ku[row][column] = value
            # 返回True 和填充的 value
            return True,value

    return False,None&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;6、如果当前位置没有任何一个值可以放置，那么就回溯，返回上一次成功的位置，重新取值,所以我们编写一个回溯函数&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def _backtrack(self,current_vacant_position,previous_vacant_position,previous_value):
    '''
    回溯
    :param current_vacant_position: 当前尝试失败的位置
    :param previous_vacant_position: 上一次成功的位置
    :param previous_value:上一次成功的值
    :return:
    '''
    print(f&quot;run backtracking... value is {previous_value},vacant position is {previous_vacant_position}&quot;)
    row,column = previous_vacant_position
    # 对上一次成功的值从需要用到的判断的数据中移除
    self.every_column_data[column].remove(previous_value)
    self.every_row_data[row].remove(previous_value)

    key = self._get_three_to_three_key(row,column)
    self.every_three_to_three_data[key].remove(previous_value)

    # 并且上一次改变的的值变回去
    self.sudo_ku[row][column] = ''

    # 对当前尝试失败的位置已经城市失败的的值进行删除，因为回溯了，所以下一次进来需要重新判断值
    current_row,current_column = current_vacant_position
    key = str(current_row) + str(current_column)
    self.every_vacant_position_tried_values.pop(key)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;7、到这里为止，我们所有的功能函数都写完了，然后我们编写一个函数，开始循环所有的空缺位置。然后进行计算。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def get_result(self):
    '''
    得到计算之后的数独
    :return:
    '''

    # 首先初始化一下数据
    self._init()

    # 空缺位置的长度
    length = len(self.vacant_position)
    # 空缺位置的下标
    index = 0

    # 存放已经尝试了的数据
    tried_values = []
    # 如果index小于length,说明还没有计算完
    while index &amp;lt; length:
        # 得到一个空缺位置
        vacant_position = self.vacant_position[index]

        # 计入计算函数，返回是否成功，如果成功，value为成功 的值，如果失败，value为None
        is_success,value = self._calculate(vacant_position)
        # 如果成功，将value放在tried_values列表里面，因为列表是有序的.
        # index+1 对下一个位置进行尝试
        if is_success:
            tried_values.append(value)
            index += 1
        # 失败，进行回溯,并且index-1，返回上一次的空缺位置，我们需要传入当前失败的位置 和 上一次成功的位置和值
        else:
            self._backtrack(vacant_position,self.vacant_position[index-1],tried_values.pop())
            index -= 1

        # 如果index&amp;lt;0 了 说明这个数独是无效的
        if index &amp;lt; 0:
            raise ValueError(f'{self.sudo_ku} is a invalid sudo ku')

    # 返回计算之后的数独
    return self.sudo_ku&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;呼。。。终于干完代码，接下来我们呢可以&quot;开始收获&quot;了&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;if __name__ == '__main__':
    sudo_ku_data = [
        [5,3,'','',7,'','','',''],
        [6,'','',1,9,5,'','',''],
        ['',9,8,'','','','',6,''],
        [8,'','','',6,'','','',3],
        [4,'','',8,'',3,'','',1],
        [7,'','','',2,'','','',6],
        ['',6,'','','','',2,8,''],
        ['','','',4,1,9,'','',5],
        ['','','','',8,'','',7,9],
    ]

    # 得到计算好的数独
    sudo_ku = SudoKu(sudo_ku_data).get_result()
    print(sudo_ku)

################
#   结果显示    #
################
[5, 3, 4, 6, 7, 8, 9, 1, 2]
[6, 7, 2, 1, 9, 5, 3, 4, 8]
[1, 9, 8, 3, 4, 2, 5, 6, 7]
[8, 5, 9, 7, 6, 1, 4, 2, 3]
[4, 2, 6, 8, 5, 3, 7, 9, 1]
[7, 1, 3, 9, 2, 4, 8, 5, 6]
[9, 6, 1, 5, 3, 7, 2, 8, 4]
[2, 8, 7, 4, 1, 9, 6, 3, 5]
[3, 4, 5, 2, 8, 6, 1, 7, 9]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这效果就很完美啊，我们在来测试一个比较难得数独。&lt;/p&gt;
&lt;p&gt;输入数独为：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;[
    [8, '', '', '', '', '', '', '', 4],
    ['', 2, '', '', '', '', '', 7, ''],
    ['', '', 9, 1, '', 6, 5, '', ''],
    ['', '', 6, 2, '', 8, 9, '', ''],
    ['', 9, '', '', 3, '', '', 4, ''],
    ['', '', 2, 4, '', 7, 8, '', ''],
    ['', '', 7, 9, '', 5, 6, '', ''],
    ['', 8, '', '', '', '', '', 2, ''],
    [6, '', '', '', '', '', '', '', 9],
]

################
#   结果显示    #
################
[8, 6, 1, 5, 7, 2, 3, 9, 4]
[5, 2, 4, 3, 8, 9, 1, 7, 6]
[3, 7, 9, 1, 4, 6, 5, 8, 2]
[4, 3, 6, 2, 5, 8, 9, 1, 7]
[7, 9, 8, 6, 3, 1, 2, 4, 5]
[1, 5, 2, 4, 9, 7, 8, 6, 3]
[2, 4, 7, 9, 1, 5, 6, 3, 8]
[9, 8, 5, 7, 6, 3, 4, 2, 1]
[6, 1, 3, 8, 2, 4, 7, 5, 9]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;哈哈哈哈哈，以后还有谁能够和我比解数独。膨胀.jpg&lt;/p&gt;
&lt;p&gt;代码已全部上传至Github：&lt;a href=&quot;https://github.com/MiracleYoung/You-are-Pythonista/tree/master/PythonExercise/App/solveSudoku/xujin&quot; class=&quot;uri&quot;&gt;https://github.com/MiracleYoung/You-are-Pythonista/tree/master/PythonExercise/App/solveSudoku/xujin&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;更多好玩有趣的Python尽请关注「&lt;strong&gt;Python专栏&lt;/strong&gt;」&lt;/p&gt;
</description>
<pubDate>Tue, 06 Aug 2019 22:46:00 +0000</pubDate>
<dc:creator>上海小胖</dc:creator>
<og:description>前几天和隔壁邻居玩斗地主被发现了，牌被没收了，斗地主是斗不了了，但我还想和邻居玩耍。 想破脑袋终于让我想到一个游戏，数独！什么叫数独？数独就是可以让我趁老王不在的时候和隔壁邻居一起玩耍的游戏！</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/moonhmily/p/11312887.html</dc:identifier>
</item>
<item>
<title>RocketMQ中Broker的刷盘源码分析 - 松饼人</title>
<link>http://www.cnblogs.com/a526583280/p/11312750.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/a526583280/p/11312750.html</guid>
<description>&lt;p&gt;上一篇博客的最后简单提了下CommitLog的刷盘  &lt;a href=&quot;https://www.cnblogs.com/a526583280/p/11306645.html&quot; target=&quot;_blank&quot;&gt;【RocketMQ中Broker的消息存储源码分析】&lt;/a&gt; （这篇博客和上一篇有很大的联系）&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;Broker的CommitLog刷盘会启动一个线程，不停地将缓冲区的内容写入磁盘（CommitLog文件）中，主要分为异步刷盘和同步刷盘&lt;/p&gt;
&lt;p&gt;异步刷盘又可以分为两种方式：&lt;br/&gt;①缓存到mappedByteBuffer -&amp;gt; 写入磁盘（包括同步刷盘）&lt;br/&gt;②缓存到writeBuffer -&amp;gt; 缓存到fileChannel -&amp;gt; 写入磁盘 （前面说过的开启内存字节缓冲区情况下）&lt;/p&gt;

&lt;p&gt;CommitLog的两种刷盘模式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt;&lt;span&gt; FlushDiskType {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;    SYNC_FLUSH,
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;    ASYNC_FLUSH
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;同步和异步，同步刷盘由GroupCommitService实现，异步刷盘由FlushRealTimeService实现，默认采用异步刷盘&lt;/p&gt;
&lt;p&gt;在采用异步刷盘的模式下，若是开启内存字节缓冲区，那么会在FlushRealTimeService的基础上开启CommitRealTimeService&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;同步刷盘：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;启动GroupCommitService线程：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     CommitLog.log.info(&lt;span&gt;this&lt;/span&gt;.getServiceName() + &quot; service started&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt; (!&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.isStopped()) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.waitForRunning(10&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.doCommit();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             CommitLog.log.warn(&lt;span&gt;this&lt;/span&gt;.getServiceName() + &quot; service has exception. &quot;&lt;span&gt;, e);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Under normal circumstances shutdown, wait for the arrival of the
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; request, and then flush&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         Thread.sleep(10&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         CommitLog.log.warn(&quot;GroupCommitService Exception, &quot;&lt;span&gt;, e);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;synchronized&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.swapRequests();
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.doCommit();
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt;     CommitLog.log.info(&lt;span&gt;this&lt;/span&gt;.getServiceName() + &quot; service end&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过循环中的doCommit不断地进行刷盘&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;doCommit方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; doCommit() {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;synchronized&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.requestsRead) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.requestsRead.isEmpty()) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (GroupCommitRequest req : &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.requestsRead) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; There may be a message in the next file, so a maximum of
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; two times the flush&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;                 &lt;span&gt;boolean&lt;/span&gt; flushOK = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 2 &amp;amp;&amp;amp; !flushOK; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                     flushOK = CommitLog.&lt;span&gt;this&lt;/span&gt;.mappedFileQueue.getFlushedWhere() &amp;gt;=&lt;span&gt; req.getNextOffset();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;flushOK) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                         CommitLog.&lt;span&gt;this&lt;/span&gt;.mappedFileQueue.flush(0&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;                req.wakeupCustomer(flushOK);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;long&lt;/span&gt; storeTimestamp = CommitLog.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.mappedFileQueue.getStoreTimestamp();
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (storeTimestamp &amp;gt; 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                 CommitLog.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.defaultMessageStore.getStoreCheckpoint().setPhysicMsgTimestamp(storeTimestamp);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.requestsRead.clear();
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Because of individual messages is set to not sync flush, it
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; will come to this process&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;             CommitLog.&lt;span&gt;this&lt;/span&gt;.mappedFileQueue.flush(0&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中在GroupCommitService中管理着两张List：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; List&amp;lt;GroupCommitRequest&amp;gt; requestsWrite = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;GroupCommitRequest&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; List&amp;lt;GroupCommitRequest&amp;gt; requestsRead = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;GroupCommitRequest&amp;gt;();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;GroupCommitRequest中封装了一个Offset&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; nextOffset;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;br/&gt;这里就需要看到上一篇博客结尾提到的handleDiskFlush方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; handleDiskFlush(AppendMessageResult result, PutMessageResult putMessageResult, MessageExt messageExt) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Synchronization flush&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (FlushDiskType.SYNC_FLUSH == &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.defaultMessageStore.getMessageStoreConfig().getFlushDiskType()) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;final&lt;/span&gt; GroupCommitService service = (GroupCommitService) &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.flushCommitLogService;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (messageExt.isWaitStoreMsgOK()) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             GroupCommitRequest request = &lt;span&gt;new&lt;/span&gt; GroupCommitRequest(result.getWroteOffset() +&lt;span&gt; result.getWroteBytes());
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;            service.putRequest(request);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;boolean&lt;/span&gt; flushOK = request.waitForFlush(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.defaultMessageStore.getMessageStoreConfig().getSyncFlushTimeout());
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;flushOK) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                 log.error(&quot;do groupcommit, wait for flush failed, topic: &quot; + messageExt.getTopic() + &quot; tags: &quot; +&lt;span&gt; messageExt.getTags()
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                     + &quot; client address: &quot; +&lt;span&gt; messageExt.getBornHostString());
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;                putMessageResult.setPutMessageStatus(PutMessageStatus.FLUSH_DISK_TIMEOUT);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;            service.wakeup();
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Asynchronous flush&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.defaultMessageStore.getMessageStoreConfig().isTransientStorePoolEnable()) {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;            flushCommitLogService.wakeup();
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;            commitLogService.wakeup();
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个方法的调用发生在Broker接收到来自Producer的消息，并且完成了向ByteBuffer的写入&lt;/p&gt;
&lt;p&gt;可以看到，在同步刷盘SYNC_FLUSH模式下，会从AppendMessageResult 中取出WroteOffset以及WroteBytes从而计算出nextOffset，把这个nextOffset封装到GroupCommitRequest中，然后通过GroupCommitService 的putRequest方法，将GroupCommitRequest添加到requestsWrite这个List中&lt;br/&gt;putRequest方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; putRequest(&lt;span&gt;final&lt;/span&gt;&lt;span&gt; GroupCommitRequest request) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;synchronized&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.requestsWrite) {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.requestsWrite.add(request);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (hasNotified.compareAndSet(&lt;span&gt;false&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;)) {
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;         waitPoint.countDown(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; notify&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在完成List的add操作后，会通过CAS操作修改hasNotified这个原子化的Boolean值，同时通过waitPoint的countDown进行唤醒操作，在后面会有用&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;由于这里这里是同步刷盘，所以需要通过GroupCommitRequest的waitForFlush方法，在超时时间内等待该记录对应的刷盘完成&lt;br/&gt;而异步刷盘会通过wakeup方法唤醒刷盘任务，并没有进行等待，这就是二者区别&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;回到doCommit方法中，这时会发现这里是对requestsRead这条List进行的操作，而刚才是将记录存放在requestsWrite这条List中的&lt;br/&gt;这就和在run方法中的waitForRunning方法有关了：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; waitForRunning(&lt;span&gt;long&lt;/span&gt;&lt;span&gt; interval) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;    &lt;span&gt;if&lt;/span&gt; (hasNotified.compareAndSet(&lt;span&gt;true&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.onWaitEnd();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;entry to wait&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    waitPoint.reset();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        waitPoint.await(interval, TimeUnit.MILLISECONDS);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         log.error(&quot;Interrupted&quot;&lt;span&gt;, e);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     } &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         hasNotified.set(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.onWaitEnd();
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里通过CAS操作修改hasNotified值，从而调用onWaitEnd方法；如果修改失败，则因为await进入阻塞，等待上面所说的putRequest方法将其唤醒，也就是说当Producer发送的消息被缓存成功后，调用handleDiskFlush方法后，唤醒刷盘线工作，当然刷盘线程在达到超时时间interval后也会唤醒&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;再来看看onWaitEnd方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onWaitEnd() {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.swapRequests();
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; 
&lt;span&gt;5&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; swapRequests() {
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     List&amp;lt;GroupCommitRequest&amp;gt; tmp = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.requestsWrite;
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.requestsWrite = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.requestsRead;
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.requestsRead =&lt;span&gt; tmp;
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到，这里是将两个List进行了交换&lt;/p&gt;
&lt;p&gt;这是一个非常有趣的做法，如果熟悉JVM的话，有没有觉得这其实很像新生代的标记-清除算法！&lt;br/&gt;当刷盘线程阻塞的时候，requestsWrite中会填充记录，当刷盘线程被唤醒工作的时候，首先会将requestsWrite和requestsRead进行交换，那么此时的记录就是从requestsRead中读取的了，而同时requestsWrite会变为空的List，消息记录就会往这个空的List中填充，如此往复&lt;/p&gt;
&lt;p&gt;可以看到doCommit方法中，当requestsRead不为空的时候，在最后会调用requestsRead的clear方法，由此证明了我上面的说法&lt;/p&gt;

&lt;p&gt;仔细来看看是如何进行刷盘的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; (GroupCommitRequest req : &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.requestsRead) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; There may be a message in the next file, so a maximum of
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; two times the flush&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;boolean&lt;/span&gt; flushOK = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 2 &amp;amp;&amp;amp; !flushOK; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         flushOK = CommitLog.&lt;span&gt;this&lt;/span&gt;.mappedFileQueue.getFlushedWhere() &amp;gt;=&lt;span&gt; req.getNextOffset();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;flushOK) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             CommitLog.&lt;span&gt;this&lt;/span&gt;.mappedFileQueue.flush(0&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    req.wakeupCustomer(flushOK);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过遍历requestsRead，可以到得到GroupCommitRequest封装的NextOffset&lt;/p&gt;
&lt;p&gt;其中flushedWhere是用来记录上一次刷盘完成后的offset，若是上一次的刷盘位置大于等于NextOffset，就说明从NextOffset位置起始已经被刷新过了，不需要刷新，否则调用mappedFileQueue的flush方法进行刷盘&lt;/p&gt;
&lt;p&gt;MappedFileQueue的flush方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; flush(&lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; flushLeastPages) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;boolean&lt;/span&gt; result = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     MappedFile mappedFile = &lt;span&gt;this&lt;/span&gt;.findMappedFileByOffset(&lt;span&gt;this&lt;/span&gt;.flushedWhere, &lt;span&gt;this&lt;/span&gt;.flushedWhere == 0&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (mappedFile != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;long&lt;/span&gt; tmpTimeStamp =&lt;span&gt; mappedFile.getStoreTimestamp();
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; offset =&lt;span&gt; mappedFile.flush(flushLeastPages);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;long&lt;/span&gt; where = mappedFile.getFileFromOffset() +&lt;span&gt; offset;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         result = where == &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.flushedWhere;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.flushedWhere =&lt;span&gt; where;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (0 ==&lt;span&gt; flushLeastPages) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.storeTimestamp =&lt;span&gt; tmpTimeStamp;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里首先根据flushedWhere上一次刷盘完成后的offset，通过findMappedFileByOffset方法，找到CommitLog文件的映射MappedFile&lt;br/&gt;有关MappedFile及其相关操作在我之前的博客中介绍过很多次，就不再累赘&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;再找到MappedFile后，调用其flush方法：&lt;/p&gt;
&lt;p&gt;MappedFile的flush方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; flush(&lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; flushLeastPages) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.isAbleToFlush(flushLeastPages)) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.hold()) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; value =&lt;span&gt; getReadPosition();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;We only append data to fileChannel or mappedByteBuffer, never both.&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (writeBuffer != &lt;span&gt;null&lt;/span&gt; || &lt;span&gt;this&lt;/span&gt;.fileChannel.position() != 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                     &lt;span&gt;this&lt;/span&gt;.fileChannel.force(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                 } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                     &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.mappedByteBuffer.force();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable e) {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                 log.error(&quot;Error occurred when force data to disk.&quot;&lt;span&gt;, e);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.flushedPosition.set(value);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.release();
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             log.warn(&quot;in flush, hold failed, flush offset = &quot; + &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.flushedPosition.get());
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.flushedPosition.set(getReadPosition());
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getFlushedPosition();
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;首先isAbleToFlush方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; isAbleToFlush(&lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; flushLeastPages) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; flush = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.flushedPosition.get();
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; write =&lt;span&gt; getReadPosition();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.isFull()) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (flushLeastPages &amp;gt; 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; ((write / OS_PAGE_SIZE) - (flush / OS_PAGE_SIZE)) &amp;gt;=&lt;span&gt; flushLeastPages;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; write &amp;gt;&lt;span&gt; flush;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中flush记录的是上一次完成刷新后的位置，write记录的是当前消息内容写入后的位置&lt;br/&gt;当flushLeastPages 大于0的时候，通过：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;return&lt;/span&gt; ((write / OS_PAGE_SIZE) - (flush / OS_PAGE_SIZE)) &amp;gt;= flushLeastPages;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以计算出是否满足page的要求，其中OS_PAGE_SIZE是4K，也就是说1个page大小是4k&lt;/p&gt;
&lt;p&gt;由于这里是同步刷盘，flushLeastPages是0，不对page要求，只要有缓存有内容就会刷盘；但是在异步刷盘中，flushLeastPages是4，也就是说，只有当缓存的消息至少是4（page个数）*4K（page大小）= 16K时，异步刷盘才会将缓存写入文件&lt;/p&gt;

&lt;p&gt;回到MappedFile的flush方法，在通过isAbleToFlush检查完写入要求后&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; value =&lt;span&gt; getReadPosition();
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;We only append data to fileChannel or mappedByteBuffer, never both.&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (writeBuffer != &lt;span&gt;null&lt;/span&gt; || &lt;span&gt;this&lt;/span&gt;.fileChannel.position() != 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.fileChannel.force(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.mappedByteBuffer.force();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable e) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     log.error(&quot;Error occurred when force data to disk.&quot;&lt;span&gt;, e);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.flushedPosition.set(value);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;首先通过getReadPosition获取当前消息内容写入后的位置，由于是同步刷盘，所以这里调用mappedByteBuffer的force方法，通过JDK的NIO操作，将mappedByteBuffer缓存中的数据写入CommitLog文件中&lt;br/&gt;最后更新flushedPosition的值&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;再回到MappedFileQueue的flush方法，在完成MappedFile的flush后，还需要更新flushedWhere的值&lt;/p&gt;
&lt;p&gt;此时缓存中的数据完成了持久化，同步刷盘结束&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;异步刷盘：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;①FlushCommitLogService：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     CommitLog.log.info(&lt;span&gt;this&lt;/span&gt;.getServiceName() + &quot; service started&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt; (!&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.isStopped()) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;boolean&lt;/span&gt; flushCommitLogTimed = CommitLog.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.defaultMessageStore.getMessageStoreConfig().isFlushCommitLogTimed();
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; interval = CommitLog.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.defaultMessageStore.getMessageStoreConfig().getFlushIntervalCommitLog();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; flushPhysicQueueLeastPages = CommitLog.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.defaultMessageStore.getMessageStoreConfig().getFlushCommitLogLeastPages();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; flushPhysicQueueThoroughInterval =
&lt;span&gt;11&lt;/span&gt;             CommitLog.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.defaultMessageStore.getMessageStoreConfig().getFlushCommitLogThoroughInterval();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;boolean&lt;/span&gt; printFlushProgress = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Print flush progress&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;long&lt;/span&gt; currentTimeMillis =&lt;span&gt; System.currentTimeMillis();
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (currentTimeMillis &amp;gt;= (&lt;span&gt;this&lt;/span&gt;.lastFlushTimestamp +&lt;span&gt; flushPhysicQueueThoroughInterval)) {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.lastFlushTimestamp =&lt;span&gt; currentTimeMillis;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             flushPhysicQueueLeastPages = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             printFlushProgress = (printTimes++ % 10) == 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (flushCommitLogTimed) {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;                Thread.sleep(interval);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;             } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;                 &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.waitForRunning(interval);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (printFlushProgress) {
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;                 &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.printFlushProgress();
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; 
&lt;span&gt;34&lt;/span&gt;             &lt;span&gt;long&lt;/span&gt; begin =&lt;span&gt; System.currentTimeMillis();
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;             CommitLog.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.mappedFileQueue.flush(flushPhysicQueueLeastPages);
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;             &lt;span&gt;long&lt;/span&gt; storeTimestamp = CommitLog.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.mappedFileQueue.getStoreTimestamp();
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (storeTimestamp &amp;gt; 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;                 CommitLog.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.defaultMessageStore.getStoreCheckpoint().setPhysicMsgTimestamp(storeTimestamp);
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;             &lt;span&gt;long&lt;/span&gt; past = System.currentTimeMillis() -&lt;span&gt; begin;
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (past &amp;gt; 500&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;                 log.info(&quot;Flush data to disk costs {} ms&quot;&lt;span&gt;, past);
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable e) {
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;             CommitLog.log.warn(&lt;span&gt;this&lt;/span&gt;.getServiceName() + &quot; service has exception. &quot;&lt;span&gt;, e);
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.printFlushProgress();
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; 
&lt;span&gt;50&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Normal shutdown, to ensure that all the flush before exit&lt;/span&gt;
&lt;span&gt;51&lt;/span&gt;     &lt;span&gt;boolean&lt;/span&gt; result = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; RETRY_TIMES_OVER &amp;amp;&amp;amp; !result; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;         result = CommitLog.&lt;span&gt;this&lt;/span&gt;.mappedFileQueue.flush(0&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;         CommitLog.log.info(&lt;span&gt;this&lt;/span&gt;.getServiceName() + &quot; service shutdown, retry &quot; + (i + 1) + &quot; times &quot; + (result ? &quot;OK&quot; : &quot;Not OK&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; 
&lt;span&gt;57&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.printFlushProgress();
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; 
&lt;span&gt;59&lt;/span&gt;     CommitLog.log.info(&lt;span&gt;this&lt;/span&gt;.getServiceName() + &quot; service end&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;flushCommitLogTimed：是否使用定时刷盘&lt;br/&gt;interval：刷盘时间间隔，默认500ms&lt;br/&gt;flushPhysicQueueLeastPages：page大小，默认4个&lt;br/&gt;flushPhysicQueueThoroughInterval：彻底刷盘时间间隔，默认10s&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;首先根据lastFlushTimestamp（上一次刷盘时间）+ flushPhysicQueueThoroughInterval和当前时间比较，判断是否需要进行一次彻底刷盘，若达到了需要则将flushPhysicQueueLeastPages置为0&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;接着根据flushCommitLogTimed判断&lt;br/&gt;当flushCommitLogTimed为true，使用sleep等待500ms&lt;br/&gt;当flushCommitLogTimed为false，调用waitForRunning在超时时间为500ms下阻塞，其唤醒条件也就是在handleDiskFlush中的wakeup唤醒&lt;/p&gt;
&lt;p&gt;最后，和同步刷盘一样，调用mappedFileQueue的flush方法&lt;br/&gt;只不过，这里的flushPhysicQueueLeastPages决定了其是进行彻底刷新，还是按4page（16K）的标准刷新&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;②CommitRealTimeService&lt;br/&gt;这种刷盘方式需要和FlushCommitLogService配合&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;CommitRealTimeService的run方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;    CommitLog.log.info(&lt;span&gt;this&lt;/span&gt;.getServiceName() + &quot; service started&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt; (!&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.isStopped()) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; interval = CommitLog.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.defaultMessageStore.getMessageStoreConfig().getCommitIntervalCommitLog();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; commitDataLeastPages = CommitLog.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.defaultMessageStore.getMessageStoreConfig().getCommitCommitLogLeastPages();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; commitDataThoroughInterval =
&lt;span&gt; 9&lt;/span&gt;             CommitLog.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.defaultMessageStore.getMessageStoreConfig().getCommitCommitLogThoroughInterval();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;long&lt;/span&gt; begin =&lt;span&gt; System.currentTimeMillis();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (begin &amp;gt;= (&lt;span&gt;this&lt;/span&gt;.lastCommitTimestamp +&lt;span&gt; commitDataThoroughInterval)) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.lastCommitTimestamp =&lt;span&gt; begin;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             commitDataLeastPages = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;boolean&lt;/span&gt; result = CommitLog.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.mappedFileQueue.commit(commitDataLeastPages);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;long&lt;/span&gt; end =&lt;span&gt; System.currentTimeMillis();
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;result) {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                 &lt;span&gt;this&lt;/span&gt;.lastCommitTimestamp = end; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; result = false means some data committed.
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;now wake up flush thread.&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;                flushCommitLogService.wakeup();
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (end - begin &amp;gt; 500&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;                 log.info(&quot;Commit data to file costs {} ms&quot;, end -&lt;span&gt; begin);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.waitForRunning(interval);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable e) {
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;             CommitLog.log.error(&lt;span&gt;this&lt;/span&gt;.getServiceName() + &quot; service has exception. &quot;&lt;span&gt;, e);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; 
&lt;span&gt;35&lt;/span&gt;     &lt;span&gt;boolean&lt;/span&gt; result = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; RETRY_TIMES_OVER &amp;amp;&amp;amp; !result; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;         result = CommitLog.&lt;span&gt;this&lt;/span&gt;.mappedFileQueue.commit(0&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;         CommitLog.log.info(&lt;span&gt;this&lt;/span&gt;.getServiceName() + &quot; service shutdown, retry &quot; + (i + 1) + &quot; times &quot; + (result ? &quot;OK&quot; : &quot;Not OK&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;     CommitLog.log.info(&lt;span&gt;this&lt;/span&gt;.getServiceName() + &quot; service end&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里的逻辑和FlushCommitLogService中相似，之不过参数略有不同&lt;/p&gt;
&lt;p&gt;interval：提交时间间隔，默认200ms&lt;br/&gt;commitDataLeastPages：page大小，默认4个&lt;br/&gt;commitDataThoroughInterval：提交完成时间间隔，默认200ms&lt;/p&gt;
&lt;p&gt;基本和FlushCommitLogService相似，只不过调用了mappedFileQueue的commit方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; commit(&lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; commitLeastPages) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;boolean&lt;/span&gt; result = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     MappedFile mappedFile = &lt;span&gt;this&lt;/span&gt;.findMappedFileByOffset(&lt;span&gt;this&lt;/span&gt;.committedWhere, &lt;span&gt;this&lt;/span&gt;.committedWhere == 0&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (mappedFile != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; offset =&lt;span&gt; mappedFile.commit(commitLeastPages);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;long&lt;/span&gt; where = mappedFile.getFileFromOffset() +&lt;span&gt; offset;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         result = where == &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.committedWhere;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.committedWhere =&lt;span&gt; where;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里和mappedFileQueue的flush方法很相似，通过committedWhere寻找MappedFile&lt;/p&gt;
&lt;p&gt;然后调用MappedFile的commit方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; commit(&lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; commitLeastPages) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (writeBuffer == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;no need to commit data to file channel, so just regard wrotePosition as committedPosition.&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.wrotePosition.get();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.isAbleToCommit(commitLeastPages)) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.hold()) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;            commit0(commitLeastPages);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.release();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             log.warn(&quot;in commit, hold failed, commit offset = &quot; + &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.committedPosition.get());
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; All dirty data has been committed to FileChannel.&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (writeBuffer != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; &lt;span&gt;this&lt;/span&gt;.transientStorePool != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; &lt;span&gt;this&lt;/span&gt;.fileSize == &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.committedPosition.get()) {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.transientStorePool.returnBuffer(writeBuffer);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.writeBuffer = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.committedPosition.get();
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;依旧和MappedFile的flush方法很相似，在isAbleToCommit检查完page后调用commit0方法&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;MappedFile的commit0方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; commit0(&lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; commitLeastPages) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; writePos = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.wrotePosition.get();
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; lastCommittedPosition = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.committedPosition.get();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (writePos - &lt;span&gt;this&lt;/span&gt;.committedPosition.get() &amp;gt; 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             ByteBuffer byteBuffer =&lt;span&gt; writeBuffer.slice();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;            byteBuffer.position(lastCommittedPosition);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;            byteBuffer.limit(writePos);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.fileChannel.position(lastCommittedPosition);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.fileChannel.write(byteBuffer);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.committedPosition.set(writePos);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable e) {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             log.error(&quot;Error occurred when commit data to FileChannel.&quot;&lt;span&gt;, e);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在&lt;a href=&quot;https://www.cnblogs.com/a526583280/p/11306645.html&quot; target=&quot;_blank&quot;&gt; 【RocketMQ中Broker的消息存储源码分析】 &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;中说过，当使用这种方式时，会先将消息缓存在writeBuffer中而不是之前的mappedByteBuffer&lt;br/&gt;这里就可以清楚地看到将writeBuffer中从lastCommittedPosition（上次提交位置）开始到writePos（缓存消息结束位置）的内容缓存到了fileChannel中相同的位置，并没有写入磁盘&lt;br/&gt;在缓存到fileChannel后，会更新committedPosition值&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;回到commit方法，在向fileCfihannel缓存完毕后，会检查committedPosition是否达到了fileSize，也就是判断writeBuffer中的内容是不是去全部提交完毕&lt;/p&gt;
&lt;p&gt;若是全部提交，需要通过transientStorePool的returnBuffer方法来回收利用writeBuffer&lt;br/&gt;transientStorePool其实是一个双向队列，由CommitLog来管理&lt;br/&gt;TransientStorePool：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TransientStorePool {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; InternalLogger log =&lt;span&gt; InternalLoggerFactory.getLogger(LoggerName.STORE_LOGGER_NAME);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; poolSize;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; fileSize;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Deque&amp;lt;ByteBuffer&amp;gt;&lt;span&gt; availableBuffers;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; MessageStoreConfig storeConfig;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; TransientStorePool(&lt;span&gt;final&lt;/span&gt;&lt;span&gt; MessageStoreConfig storeConfig) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.storeConfig =&lt;span&gt; storeConfig;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.poolSize =&lt;span&gt; storeConfig.getTransientStorePoolSize();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.fileSize =&lt;span&gt; storeConfig.getMapedFileSizeCommitLog();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.availableBuffers = &lt;span&gt;new&lt;/span&gt; ConcurrentLinkedDeque&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    ......
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;returnBuffer方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; returnBuffer(ByteBuffer byteBuffer) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     byteBuffer.position(0&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;    byteBuffer.limit(fileSize);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.availableBuffers.offerFirst(byteBuffer);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里就可以清楚地看到byteBuffer确实被回收了&lt;/p&gt;

&lt;p&gt;回到MappedFileQueue的commit方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; commit(&lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; commitLeastPages) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;boolean&lt;/span&gt; result = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     MappedFile mappedFile = &lt;span&gt;this&lt;/span&gt;.findMappedFileByOffset(&lt;span&gt;this&lt;/span&gt;.committedWhere, &lt;span&gt;this&lt;/span&gt;.committedWhere == 0&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (mappedFile != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; offset =&lt;span&gt; mappedFile.commit(commitLeastPages);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;long&lt;/span&gt; where = mappedFile.getFileFromOffset() +&lt;span&gt; offset;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         result = where == &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.committedWhere;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.committedWhere =&lt;span&gt; where;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在完成mappedFile的commit后，通过where和committedWhere来判断是否真的向fileCfihannel缓存了 ，只有确实缓存了result才是false！&lt;br/&gt;之后会更新committedWhere，并返回result&lt;/p&gt;

&lt;p&gt;那么回到CommitRealTimeService的run方法，在完成commit之后，会判断result&lt;br/&gt;只有真的向fileCfihannel缓存后，才会调用flushCommitLogService的wakeup方法，也就是唤醒了FlushCommitLogService的刷盘线程&lt;/p&gt;
&lt;p&gt;唯一和之前分析的FlushCommitLogService不同的地方是在MappedFile的flush方法中：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (writeBuffer != &lt;span&gt;null&lt;/span&gt; || &lt;span&gt;this&lt;/span&gt;.fileChannel.position() != 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.fileChannel.force(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.mappedByteBuffer.force();
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;之前在没有开启内存字节缓冲区的情况下，是将mappedByteBuffer中的内容写入磁盘&lt;br/&gt;而这时，终于轮到fileChannel了&lt;/p&gt;
&lt;p&gt;可以看到这里的条件判断，当writeBuffer不等与null，或者fileChannel的position不等与0&lt;br/&gt;writeBuffer等于null的情况会在TransientStorePool对其回收之后&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;到这里就可以明白开启内存字节缓冲区的情况下，其实是进行了两次缓存才写入磁盘&lt;/p&gt;

&lt;p&gt;至此，Broker的消息持久化以及刷盘的整个过程完毕&lt;/p&gt;
</description>
<pubDate>Tue, 06 Aug 2019 16:35:00 +0000</pubDate>
<dc:creator>松饼人</dc:creator>
<og:description>上一篇博客的最后简单提了下CommitLog的刷盘 【RocketMQ中Broker的消息存储源码分析】 （这篇博客和上一篇有很大的联系） Broker的CommitLog刷盘会启动一个线程</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/a526583280/p/11312750.html</dc:identifier>
</item>
<item>
<title>Qt实现表格树控件-自绘树节点虚线 - 朝十晚八</title>
<link>http://www.cnblogs.com/swarmbees/p/11312691.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/swarmbees/p/11312691.html</guid>
<description>&lt;p&gt;&lt;strong&gt;原文链接：&lt;/strong&gt;&lt;a href=&quot;https://www.cnblogs.com/swarmbees/p/11312691.html&quot;&gt;Qt实现表格树控件-自绘树节点虚线&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;一开心一刻&quot;&gt;一、开心一刻&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;一程序员第一次上女朋友家她妈板着脸问 ：你想娶我女儿，有多少存款？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;程序员低了下头：五百！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;她妈更鄙视了：才五百块，买个厕所都不够！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;程序员忙说：不是人民币！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;她妈：就算是美元，还是不够买厕所！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;程序员：其实是比特币！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;她妈：哇，贤婿，我给你买只大龙虾去&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;二自绘树节点&quot;&gt;二、自绘树节点？&lt;/h2&gt;
&lt;p&gt;自绘树节点？听起来都挺复杂的，可是为什么还要自绘树节点呢？这充分说明产品的脑子是什么东西都能想出来的。&lt;/p&gt;
&lt;p&gt;有一天产品说我们的软件里缺少一个美丽的树控件，然后就要求开发去实现这个功能。&lt;/p&gt;
&lt;p&gt;对于有一定开发经验的同学可能直接会去百度，或者上Qt帮助文档上查找资料，然后发现直接设置qss就能达到我们需要的效果，于是一顿操作后，发现效果还是不错滴。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;setStyleSheet(&quot;&quot;
    &quot;QTreeView {outline:none;show-decoration-selected: 1;}&quot;
    &quot;QTreeView {outline:none;border:0px;}&quot;
    &quot;QTreeView::branch{     background-color: transparent;  }&quot;
    &quot;QTreeView::item:hover, QTreeView::branch:hover { background-color: transparent;border-color: rgb(255, 0, 0);}&quot;
    &quot;QTreeView::item:selected, QTreeView::branch:selected { background-color: #C5E0F7;}&quot;
    &quot;QTreeView::branch:open:has-children{image: url(:/branch-expand.png);}&quot;
    &quot;QTreeView::branch:closed:has-children{image: url(:/branch-collapse.png);}&quot;
    &quot;QTreeView::branch:has-siblings:!adjoins-item{border-image:url(:/branch-line.png) 0;}&quot;
    &quot;QTreeView::branch:has-siblings:adjoins-item{border-image:url(:/branch-more.png) 0;}&quot;
    &quot;QTreeView::branch:!has-children:!has-siblings:adjoins-item{border-image:url(:/branch-end.png) 0;   }&quot;
    &quot;QTreeView::branch:has-children:!has-siblings:closed,QTreeView::branch:closed:has-children:has-siblings{border-image:none;image: url(:/branch-collapse.png);    }&quot;
    &quot;QTreeView::branch:open:has-children:!has-siblings,QTreeView::branch:open:has-children:has-siblings{border-image:none;image: url(:/branch-expand.png);  }&quot;
    );&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;遂找来产品验证，当产品看到这个效果后，脸直接都绿了。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;产品：我不是说要一个树形控件吗？行高需要能动态调整那种！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;开发：。。。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;开发：行高调整了，那branch上贴的图拉伸后不是模糊了么。。。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;产品：。。。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;产品：我不管，这个行高可拖拽功能很重要，怎么实现我不管，但是功能必须要有。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;开发：卧槽，看来只有出终极大法了，直接自绘吧&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;三效果展示&quot;&gt;三、效果展示&lt;/h2&gt;
&lt;p&gt;如下图所示，是一个简单的树branch自绘效果。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;此处主要是展示一个demo效果，如果需要美化需要专业设计师出图来做。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;center&gt;
&lt;div&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/swarmbees/1505948/o_tree_branch.gif&quot;/&gt;&lt;/div&gt;
&lt;/center&gt;
&lt;h2 id=&quot;四实现思路&quot;&gt;四、实现思路&lt;/h2&gt;
&lt;p&gt;既然要自己绘制树形节点，那必然要去研究Qt的源码。&lt;/p&gt;
&lt;h3 id=&quot;可扩展接口&quot;&gt;1、可扩展接口&lt;/h3&gt;
&lt;p&gt;首先我们打开QTreeView类的帮助文档，查找这个类都有哪些可供重写的接口，然后就发现了这么几个函数&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/swarmbees/1505948/o_tree_draw.png&quot;/&gt;&lt;/center&gt;
&lt;p&gt;看名字大概都知道是什么意思，不过这里还是做简要说明&lt;/p&gt;
&lt;center&gt;函数名 | 含义 --- | --- drawBranches| 绘制branch drawRow | 绘制行 drawTree | 绘制树 indexRowSizeHint | 默认行高 rowHeight| 获取行高&lt;/center&gt;
&lt;p&gt;&lt;strong&gt;前边提到我们要自己绘制branch线条，但是其余的东西还是要走Qt默认的绘制风格，因此在重写绘制函数时，千万不要忘记了调用原有的绘制方法。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;表格中前3个函数就是绘制树控件的具体方法，这3个函数搭配起来完成了树控件内容格子的绘制。下面我们来重写这3个函数，分别完成我们的需求&lt;/p&gt;
&lt;h3 id=&quot;函数重写&quot;&gt;2、函数重写&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;a、绘制行drawRow&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;drawRow顾名思义就是绘制一行的意思，这里也确实如此。为什么要重写这个函数呢？答案也很简单。&lt;/p&gt;
&lt;p&gt;树控件本身是不具有垂直分割线的，既然我们要模拟表格的样式，那么垂直分割线必然是需要的。&lt;/p&gt;
&lt;p&gt;实现代码可能像下面这样，是不是很简单。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void FrozenTreeView::drawRow(QPainter * painter, const QStyleOptionViewItem &amp;amp; options, const QModelIndex &amp;amp; index) const
{
    QTreeView::drawRow(painter, options, index);

    //绘制网格线
    QPen pen;
    pen.setWidth(m_iWidth);
    pen.setColor(m_gridLineColor);

    painter-&amp;gt;save();
    painter-&amp;gt;setPen(pen);
    painter-&amp;gt;drawRect(options.rect);
    painter-&amp;gt;restore();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;b、绘制branch&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;绘制行函数主要是添加了单元格边框绘制，接下来就是第一列的branch绘制。&lt;/p&gt;
&lt;p&gt;绘制branch时一定不要忘记调用原有的绘制函数，否则界面显示会异常。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
    painter-&amp;gt;save();
    QTreeView::drawBranches(painter, rect, index);
    painter-&amp;gt;restore();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;绘制branch时主要是根据当前节点是否展开、是否有孩子节点、是否有兄弟节点等状态来联合判断并进行绘制&lt;/p&gt;
&lt;p&gt;如下是绘制代码，可能有些长，但是应该比较好理解。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;需要注意的点&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;除根节点外，每个节点都需要绘制文字前边的水平线&lt;/li&gt;
&lt;li&gt;有父亲的节点需要绘制垂直线。绘制的竖线是否绘制到底，取决于是否有向下的兄弟&lt;/li&gt;
&lt;li&gt;有爷爷的节点可能需要额外绘制向下的竖线。是否绘制取决于自己的父亲是否有向下的兄弟&lt;/li&gt;
&lt;li&gt;规则3其实是一个循环的处理，也就是说爷爷如果有爸爸，也就是说节点如果有祖爷爷，那么可能还需要绘制更多的向下竖线。是否绘制取决于节点的爷爷是否有向下的兄弟&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;代码这里就不细说了，有兴趣的可以自己研究研究。绘制规则就是上述4点&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//绘制branch
{
    DataNode * node = static_cast&amp;lt;DataNode *&amp;gt;(index.internalPointer());
    bool hasChild = node-&amp;gt;children().size() != 0;//是否有孩子

    QList&amp;lt;DataNode *&amp;gt; &amp;amp; children = node-&amp;gt;parent()-&amp;gt;children();
    bool has_next_siblings = children.indexOf(node) != (children.size() - 1);//是否有向后的兄弟
    bool has_pre_siblings = children.indexOf(node) != 0;//是否有向前的兄弟

    int level = node-&amp;gt;level();
    int indentaion = indentation();//缩进
    int indentaions = indentaion * (level - 1);//缩进距离

    QRect r = rect;
    r.setLeft(r.left() + indentaions);//图标绘制位置

    painter-&amp;gt;save();
    painter-&amp;gt;setPen(m_branchLine);

    bool expaned = isExpanded(index);//节点是否展开

    QLine line(r.center() + QPoint(0, r.top() - r.center().y()), r.center() + QPoint(0, r.bottom() - r.center().y()));
    line.translate(-indentaion, 0);
    //QLine line(r.topLeft(), r.bottomLeft());
    //循环绘制(具有兄弟节点的)父节点向下的竖线
    DataNode * parent_node = node-&amp;gt;parent();
    DataNode * sub_node = node;
    bool isNeed = node-&amp;gt;children().size() == 0;
    for (int i = level - 1; i &amp;gt;= 0; --i)
    {
        QList&amp;lt;DataNode *&amp;gt; &amp;amp; children = parent_node-&amp;gt;children();
        bool has_next_siblings = children.indexOf(sub_node) != (children.size() - 1);//父节点是否有(向后的)兄弟

        if (has_next_siblings)
        {
            painter-&amp;gt;drawLine(line);
        }
        

        if (level - 1 == i)
        {
            QPoint pos = (line.p1() + line.p2()) / 2;
            QPoint pos2 = pos + QPoint(indentaion / 2, 0);

            painter-&amp;gt;drawLine(pos, pos2);

            if (!has_next_siblings)
            {
                painter-&amp;gt;drawLine(line.p1(), (line.p1() + line.p2()) / 2);
            }
        }

        sub_node = parent_node;
        parent_node = parent_node-&amp;gt;parent();
        line.translate(-indentaion, 0);
    }

    QPixmap pix;
    if (expaned)
    {
        if (hasChild)
        {
            pix = QPixmap(&quot;:/branch-expand.png&quot;);
        }
    }
    else
    {
        if (hasChild)
        {
            pix = QPixmap(&quot;:/branch-collapse.png&quot;);
        }
    }
    if (pix.isNull() == false)
    {
        QRect pixRect = QRect(QPoint(0, 0), pix.size());
        pixRect.moveCenter(r.center());

        if (expaned)
        {
            QLine line(r.center(), r.center() + QPoint(0, r.bottom() - r.center().y()));
            painter-&amp;gt;drawLine(line);
        }

        painter-&amp;gt;drawPixmap(pixRect, pix);
    }

    painter-&amp;gt;restore();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;同步左侧表头&quot;&gt;3、同步左侧表头&lt;/h3&gt;
&lt;p&gt;上一篇文章&lt;a href=&quot;https://www.cnblogs.com/swarmbees/p/11167659.html&quot;&gt;Qt实现表格树控件-支持多级表头&lt;/a&gt; 中已经说了，我们的表格控件是使用QTableView+QTreeView来实现的，那么我们操作树控件时必然要对表格中的表头进行同步操作了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;树控件折叠时隐藏垂直表头指定行&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void collapsed_p(DataNode * node)
{
    QList&amp;lt;DataNode *&amp;gt; childNodeList = node-&amp;gt;children();
    //DataManager::getInstance()-&amp;gt;allChildNode(node, childNodeList);

    int size = childNodeList.size();
    for (int i = 0; i &amp;lt; size; ++i)
    {
        int serial = DataManager::getInstance()-&amp;gt;serialNoOfNode(childNodeList.at(i));
        VHeaderView::instance-&amp;gt;SetRowHide(serial, true);

        QModelIndex subIndex = FrozenTreeView::instance-&amp;gt;rowIndex(serial);

        collapsed_p(childNodeList.at(i));
    }
}

void FrozenTreeView::onCollapsed(const QModelIndex &amp;amp; index)
{
    if (!index.isValid())
        return;

    DataNode * node = static_cast&amp;lt;DataNode*&amp;gt;(index.internalPointer());
    if (nullptr == node)
        return;

    collapsed_p(node);
    VHeaderView::instance-&amp;gt;UpdateCache();

    //要对水平头的最后一列进行重设大小，引起水平头自己的更新操作，从而使整个界面显示正确
    HHeaderView::instance-&amp;gt;resizeLastSection(true);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;树控件展开时显示垂直表头指定行&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void expanded_p(DataNode * node)
{
    QList&amp;lt;DataNode *&amp;gt; childNodeList = node-&amp;gt;children();

    int size = childNodeList.size();
    for (int i = 0; i &amp;lt; size; ++i)
    {
        int serial = DataManager::getInstance()-&amp;gt;serialNoOfNode(childNodeList.at(i));
        VHeaderView::instance-&amp;gt;SetRowHide(serial, false);

        QModelIndex subIndex = FrozenTreeView::instance-&amp;gt;rowIndex(serial);

        if (FrozenTreeView::instance-&amp;gt;isExpanded(subIndex))
        {
            expanded_p(childNodeList.at(i));
        }
    }
}

void FrozenTreeView::onExpanded(const QModelIndex &amp;amp; index)
{
    DataNode * node = static_cast&amp;lt;DataNode *&amp;gt;(index.internalPointer());
    if (nullptr == node)
        return;

    VHeaderView::instance-&amp;gt;blockSignals(true);
    expanded_p(node);
    VHeaderView::instance-&amp;gt;UpdateCache();
    VHeaderView::instance-&amp;gt;blockSignals(false);

    //要对水平头的最后一列进行重设大小，引起水平头自己的更新操作，从而使整个界面显示正确
    HHeaderView::instance-&amp;gt;resizeLastSection(false);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;五相关文章&quot;&gt;五、相关文章&lt;/h2&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;值得一看的优秀文章：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/swarmbees/p/6707798.html&quot;&gt;财联社-产品展示&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/swarmbees/p/10836505.html&quot;&gt;广联达-产品展示&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https://blog.csdn.net/qq_30392343/article/details/95527107&quot;&gt;Qt定制控件列表&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https://blog.csdn.net/qq_30392343/article/details/95526527&quot;&gt;牛逼哄哄的Qt库&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;hr/&gt;&lt;ol readability=&quot;0.066666666666667&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/swarmbees/p/11167664.html&quot;&gt;Qt实现表格控件-支持多级列表头、多级行表头、单元格合并、字体设置等&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/swarmbees/p/11155074.html&quot;&gt;Qt高仿Excel表格组件-支持冻结列、冻结行、内容自适应和合并单元格&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/swarmbees/p/11129274.html&quot;&gt;属性浏览器控件QtTreePropertyBrowser编译成动态库(设计师插件)&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/swarmbees/p/11117259.html&quot;&gt;超级实用的属性浏览器控件--QtTreePropertyBrowser&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/swarmbees/p/9288902.html&quot;&gt;Qt之表格控件蚂蚁线&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/swarmbees/p/11185435.html&quot;&gt;QRowTable表格控件-支持hover整行、checked整行、指定列排序等&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/swarmbees/p/11167659.html&quot;&gt;Qt实现表格树控件-支持多级表头&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/swarmbees/p/11280122.html&quot;&gt;QTableView表格控件区域选择-自绘选择区域&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br/&gt;如果您觉得文章不错，不妨给个&lt;span&gt;打赏&lt;/span&gt;，写作不易，感谢各位的支持。您的支持是我最大的动力，谢谢！！！&lt;br/&gt;&lt;/p&gt;
&lt;br/&gt;&lt;center&gt;&lt;br/&gt;&lt;div&gt;&lt;table&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/swarmbees/1497876/o_weixin_reward.png&quot; border=&quot;0&quot;/&gt;&lt;/td&gt;
&lt;td&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/swarmbees/1497876/o_zhifubao_reward.png&quot; border=&quot;0&quot;/&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;&lt;br/&gt;&lt;/div&gt;
&lt;br/&gt;&lt;/center&gt;
&lt;br/&gt;&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;很重要--转载声明&lt;/strong&gt;&lt;/p&gt;
&lt;ol readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;本站文章无特别说明，皆为原创，版权所有，转载时请用链接的方式，给出原文出处。同时写上原作者：&lt;a href=&quot;https://www.cnblogs.com/swarmbees/&quot;&gt;朝十晚八&lt;/a&gt; or &lt;a href=&quot;https://www.jianshu.com/u/7673f8cfb4e6&quot;&gt;Twowords&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如要转载，请原文转载，如在转载时修改本文，请事先告知，谢绝在转载时通过修改本文达到有利于转载者的目的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;hr/&gt;</description>
<pubDate>Tue, 06 Aug 2019 16:16:00 +0000</pubDate>
<dc:creator>朝十晚八</dc:creator>
<og:description>[TOC] 原文链接： 'Qt实现表格树控件 自绘树节点虚线' 一、开心一刻 一程序员第一次上女朋友家她妈板着脸问 ：你想娶我女儿，有多少存款？ 程序员低了下头：五百！ 她妈更鄙视了：才五百块，买个厕</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/swarmbees/p/11312691.html</dc:identifier>
</item>
</channel>
</rss>