<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Protocol buffers编写风格指南 - Moon_Light_Dream</title>
<link>http://www.cnblogs.com/Moon-Light-Dream/p/10264616.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Moon-Light-Dream/p/10264616.html</guid>
<description>&lt;p&gt;　　原文链接：&lt;a href=&quot;https://developers.google.com/protocol-buffers/docs/style&quot; target=&quot;_blank&quot;&gt;https://developers.google.com/protocol-buffers/docs/style&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;　　本文说明了.proto文件的编写风格指南。遵循这些约定，将使protocol buffer message的定义及其相应的类保持一致且易于阅读。&lt;/p&gt;
&lt;h2&gt;Message And Field Names&lt;/h2&gt;
&lt;p&gt;　　对于message的命名，采用驼峰命名法（第一个字母大写），例如SongServerRequest。对于message中的字段，采用下划线分隔的方式命名，如song_name。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
message SongServerRequest {
  required string song_name = 1;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　使用这样的命名规则可以为message中的字段提供get,set方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
C++:
  const string&amp;amp; song_name() { ... }
  void set_song_name(const string&amp;amp; x) { ... }
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
Java:
  public String getSongName() { ... }
  public Builder setSongName(String v) { ... }
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Enums&lt;/h2&gt;
&lt;p&gt;　　对于枚举类型的命名采用驼峰命名法（CamelCase），枚举类型中值的命名采用全大写和下划线（CAPITALS_WITH_UNDERSCORES）结合的命名。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
enum Foo {
  FIRST_VALUE = 0;
  SECOND_VALUE = 1;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　每个枚举值应以分号结束，而不是逗号。&lt;/p&gt;
&lt;h2&gt;Services&lt;/h2&gt;
&lt;p&gt;　　如果.proto定义了RPC服务，对服务名和RPC方法使用驼峰命名法（CamelCase）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
service FooService {
  rpc GetSomething(FooRequest) returns (FooResponse);
}
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Sun, 13 Jan 2019 15:26:00 +0000</pubDate>
<dc:creator>Moon_Light_Dream</dc:creator>
<og:description>原文链接：https://developers.google.com/protocol-buffers/docs/style Style Guide 本文说明了.proto文件的编写风格指南。遵循这些</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Moon-Light-Dream/p/10264616.html</dc:identifier>
</item>
<item>
<title>微信公众号03 微信网页授权 - 寻渝记</title>
<link>http://www.cnblogs.com/NeverCtrl-C/p/10264538.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/NeverCtrl-C/p/10264538.html</guid>
<description>&lt;h3 id=&quot;h&quot;&gt;前提准备&lt;/h3&gt;
&lt;h4 id=&quot;h-2&quot;&gt;域名&lt;/h4&gt;
&lt;p&gt;开发微信网页授权时需要一个外网可以访问的域名，因为用户确认进行微信网页授权后微信服务器会通过一个回调URL向开发服务器发送一个回调请求。&lt;br/&gt;开发阶段可以使用一些内网穿透工具来实现，例如：natapp、花生壳等等。&lt;br/&gt;福利：natapp和花生壳都会免费赠送一些隧道。&lt;br/&gt;注意：natapp提供的免费隧道每次启动客户端时产生的域名时随机的。&lt;br/&gt;填坑：利用花生壳提供的域名进行内网穿透时可能会被微信拦截，所以推荐使用natapp(PS: 请测有效)。&lt;/p&gt;
&lt;h4 id=&quot;h-3&quot;&gt;个人订阅号&lt;/h4&gt;
&lt;p&gt;由于是进行微信网页授权，所以需要一个个人微信订阅号作为开发基础。&lt;br/&gt;福利：由于微信个人订阅号没有提供微信网页授权功能，但是可以利用微信提供的测试号进行开发。&lt;br/&gt;测试号在哪里：登录个人订阅号 -&amp;gt; 开发 -&amp;gt; 开发者工具 -&amp;gt; 公众平台测试账号&lt;br/&gt;注意：整个开发过程中都是使用测试号的appID和appsecret&lt;/p&gt;
&lt;h4 id=&quot;h-4&quot;&gt;开发环境&lt;/h4&gt;
&lt;p&gt;JDK: 1.8&lt;br/&gt;MAVEN: 3.x&lt;br/&gt;SpringBoot: 2.x&lt;br/&gt;IDEA: 2017专业版&lt;/p&gt;
&lt;h3 id=&quot;h-5&quot;&gt;微信网页授权官方文档&lt;/h3&gt;
&lt;h4 id=&quot;h-6&quot;&gt;文档路径&lt;/h4&gt;
&lt;p&gt;文档在哪里：登录微信订阅号 -&amp;gt; 开发 -&amp;gt; 开发者工具 -&amp;gt; 开发文档 -&amp;gt; 微信网页开发 -&amp;gt; 微信网页授权&lt;/p&gt;
&lt;h4 id=&quot;h-7&quot;&gt;回调域名配置&lt;/h4&gt;
&lt;p&gt;在哪里配置：登录个人订阅号 -&amp;gt; 开发 -&amp;gt; 开发者工具 -&amp;gt; 公众平台测试账号 -&amp;gt; 网页服务 -&amp;gt; 网页账号 -&amp;gt; 修改 -&amp;gt; 填入授权回调页面域名即可（推荐使用natapp）&lt;/p&gt;
&lt;h4 id=&quot;h-8&quot;&gt;开发步骤&lt;/h4&gt;
&lt;p&gt;1 第一步：用户同意授权，获取code&lt;br/&gt;2 第二步：通过code换取网页授权access_token&lt;br/&gt;3 第三步：刷新access_token（如果需要）&lt;br/&gt;4 第四步：拉取用户信息(需scope为 snsapi_userinfo)&lt;br/&gt;5 附：检验授权凭证（access_token）是否有效&lt;/p&gt;
&lt;h3 id=&quot;hjava&quot;&gt;Java代码实现&lt;/h3&gt;
&lt;h4 id=&quot;h-9&quot;&gt;进入微信授权页面&lt;/h4&gt;
&lt;p&gt;只需要通过微信浏览器访问到微信授权的页面即可。&lt;br/&gt;&lt;strong&gt;思路&lt;/strong&gt;&lt;br/&gt;01 用户通过微信浏览器进入一个页面&lt;br/&gt;02 点击一个按钮向开发者后台发送一个GET请求&lt;br/&gt;03 开发这个后台封装一个URL并重定向到这个URL&lt;br/&gt;&lt;strong&gt;代码片段&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 微信网页授权逻辑入口
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; map
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @GetMapping(value &lt;/span&gt;= &quot;/auth&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; toAuth(ModelMap map, HttpServletRequest request, HttpServletResponse response) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
        log.info(&lt;/span&gt;&quot;进入微信授权逻辑......&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        微信网页授权第一步 - 用户同意授权，获取code - start&lt;/span&gt;
        String getCodeUrl =&lt;span&gt; weixinBaseInfoProperties.getAuth().getGetCodeUrl();
        String appid &lt;/span&gt;=&lt;span&gt; weixinBaseInfoProperties.getAppid();
        String appsecret &lt;/span&gt;=&lt;span&gt; weixinBaseInfoProperties.getAppsecret();
        String redirectUri &lt;/span&gt;=&lt;span&gt; weixinBaseInfoProperties.getAuth().getRedirectUri();
        String scope &lt;/span&gt;=&lt;span&gt; weixinBaseInfoProperties.getAuth().getScope();
        getCodeUrl &lt;/span&gt;= getCodeUrl.replace(&quot;APPID&quot;&lt;span&gt;, appid)
                .replace(&lt;/span&gt;&quot;REDIRECT_URI&quot;&lt;span&gt;, redirectUri)
                .replace(&lt;/span&gt;&quot;SCOPE&quot;&lt;span&gt;, scope);
        log.info(&lt;/span&gt;&quot;封装好的getCodeUrl为：&quot; +&lt;span&gt; getCodeUrl);
        response.sendRedirect(getCodeUrl);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        微信网页授权第一步 - 用户同意授权，获取code - end&lt;/span&gt;
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;hcodeaccesstokenopenid&quot;&gt;获取CODE和AccessToken、用户openid、用户信息&lt;/h4&gt;
&lt;p&gt;微信用户通过微信浏览器确认授权后，微信服务器会通过之前设定的回调URL向开发者后台发送一个GET请求，这个请求中携带了CODE信息。&lt;br/&gt;&lt;strong&gt;思路&lt;/strong&gt;&lt;br/&gt;01 用户确认授权&lt;br/&gt;02 微信服务器发送回调请求&lt;br/&gt;03 开发服务器接收到回调请求&lt;br/&gt;04 获取CODE&lt;br/&gt;05 通过CODE在拼装一个url去请求微信服务器来获取access_token、openid&lt;br/&gt;06 通过access_token、openid封装一个url去请求微信服务器来获取用户信息&lt;/p&gt;
&lt;h3 id=&quot;h-10&quot;&gt;微信网页授权的使用场景&lt;/h3&gt;
&lt;h4 id=&quot;h-11&quot;&gt;直接利用微信账号作为网页账号&lt;/h4&gt;
&lt;p&gt;获取用户信息成功后直接跳转到目标页面即可&lt;/p&gt;
&lt;h4 id=&quot;h-12&quot;&gt;微信账号和网站账号进行绑定&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;思路：&lt;/strong&gt;&lt;br/&gt;01 获取用户信息成功&lt;br/&gt;02 根据用户openid到数据库中去查找网页账号信息&lt;br/&gt;03 如果查找到信息就说明已经绑定，直接跳转拿到目标页面即可&lt;br/&gt;04 如果没有获取到就跳转到登录绑定页面&lt;br/&gt;05 用户输入账号和密码并提交到开发者后台&lt;br/&gt;06 后台需对网站账号合法性进行校验&lt;br/&gt;07 校验通过后进行绑定操作&lt;br/&gt;08 跳转到目标页面&lt;br/&gt;&lt;strong&gt;代码片段一&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 回调页面
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; map
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @GetMapping(value &lt;/span&gt;= &quot;/callback&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String callback(ModelMap map, HttpServletRequest request, HttpServletResponse response) {
        log.info(&lt;/span&gt;&quot;进入回调处理逻辑......&quot;&lt;span&gt;);
        String appid &lt;/span&gt;=&lt;span&gt; weixinBaseInfoProperties.getAppid();
        String appsecret &lt;/span&gt;=&lt;span&gt; weixinBaseInfoProperties.getAppsecret();

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        微信网页授权第二步 - 通过code换取网页授权access_token - start&lt;/span&gt;
        StringBuffer requestURL =&lt;span&gt; request.getRequestURL();
        log.info(&lt;/span&gt;&quot;进入回调处理逻辑的请求url为：&quot; +&lt;span&gt; requestURL);
        String code &lt;/span&gt;= request.getParameter(&quot;code&quot;&lt;span&gt;);
        log.info(&lt;/span&gt;&quot;获取到的用于换取access_token的票据的code值为：&quot; +&lt;span&gt; code);

        String getAccessTokenUrl &lt;/span&gt;=&lt;span&gt; weixinBaseInfoProperties.getAuth().getGetAccessTokenUrl();
        getAccessTokenUrl &lt;/span&gt;= getAccessTokenUrl.replace(&quot;APPID&quot;&lt;span&gt;, appid)
                .replace(&lt;/span&gt;&quot;SECRET&quot;&lt;span&gt;, appsecret)
                .replace(&lt;/span&gt;&quot;CODE&quot;&lt;span&gt;, code);
        log.info(&lt;/span&gt;&quot;封装好的用于获取accessToke的url为：&quot; +&lt;span&gt; getAccessTokenUrl);
        String getAccessTokenResponseStr &lt;/span&gt;=&lt;span&gt; httpUtils.doGetStrByRestTemplate(getAccessTokenUrl);
        log.info(&lt;/span&gt;&quot;发送获取access_token请求后的响应为STR：&quot; +&lt;span&gt; getAccessTokenResponseStr);
        GetAuthAccessTokenResponse getAuthAccessTokenResponse &lt;/span&gt;= transformerUtils.String2Object(getAccessTokenResponseStr, GetAuthAccessTokenResponse.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        log.info(&lt;/span&gt;&quot;发送获取access_token请求后的响应为：&quot; +&lt;span&gt; getAuthAccessTokenResponse);
        String access_token &lt;/span&gt;=&lt;span&gt; getAuthAccessTokenResponse.getAccess_token();
        String open_id &lt;/span&gt;=&lt;span&gt; getAuthAccessTokenResponse.getOpenid();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        微信网页授权第二步 - 通过code换取网页授权access_token - end

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        微信网页授权第四步 - 拉取用户信息(需scope为 snsapi_userinfo) - start&lt;/span&gt;
        String getUserInfoUrl =&lt;span&gt; weixinBaseInfoProperties.getAuth().getGetUserInfoUrl();
        getUserInfoUrl &lt;/span&gt;= getUserInfoUrl.replace(&quot;ACCESS_TOKEN&quot;&lt;span&gt;, access_token)
                .replace(&lt;/span&gt;&quot;OPENID&quot;&lt;span&gt;, open_id);
        log.info(&lt;/span&gt;&quot;封装好的用于获取userInfo的url为：&quot; +&lt;span&gt; getUserInfoUrl);
        String getUserInfoResponseStr &lt;/span&gt;=&lt;span&gt; httpUtils.doGetStrByRestTemplate(getUserInfoUrl);
        log.info(&lt;/span&gt;&quot;发送获取userInfo请求后的响应为STR：&quot; +&lt;span&gt; getUserInfoResponseStr);
        GetUserInfoResponse getUserInfoResponse &lt;/span&gt;= transformerUtils.String2Object(getUserInfoResponseStr, GetUserInfoResponse.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        log.info(&lt;/span&gt;&quot;发送获取userInfo请求后的响应为：&quot; +&lt;span&gt; getUserInfoResponse);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        微信网页授权第四步 - 拉取用户信息(需scope为 snsapi_userinfo) - end

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        第一种使用：直接使用微信的用户用户体系
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        map.addAttribute(&quot;userinfo&quot;, getUserInfoResponse);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        return &quot;index2&quot;;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        第二种：微信用户和网站用户进行绑定
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        根据openid查询网站的账户信息&lt;/span&gt;
        UserBindDO userBindDOByOpenid =&lt;span&gt; userBindRepository.findByOpenid(getUserInfoResponse.getOpenid());
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (userBindDOByOpenid != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;            已经绑定过的情况&lt;/span&gt;
            log.info(&quot;已经绑定过啦&quot;&lt;span&gt;);
            map.addAttribute(&lt;/span&gt;&quot;userinfo&quot;&lt;span&gt;, userBindDOByOpenid);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;index3&quot;&lt;span&gt;;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;            没有绑定过的情况&lt;/span&gt;
            log.info(&quot;还未进行绑定操作&quot;&lt;span&gt;);
            map.addAttribute(&lt;/span&gt;&quot;openid&quot;&lt;span&gt;, getUserInfoResponse.getOpenid());
            map.addAttribute(&lt;/span&gt;&quot;nickname&quot;&lt;span&gt;, getUserInfoResponse.getNickname());
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;login&quot;&lt;span&gt;;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;代码片段二&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
    @PostMapping(value = &quot;/login&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String login(UserBindDO userBindDO, ModelMap map) {
        log.info(&lt;/span&gt;&quot;获取到的参数信息为：&quot; +&lt;span&gt; userBindDO);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        TODO: 对账户信息进行格式校验，如果格式不正确直接返回登录绑定页面
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        TODO: 验证账户是否存在, 如果不存在直接跳转到注册页面（微信用户信息同时返回），在注册逻辑中直接进行绑定
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        TODO: 验证账户密码是否正确，如果部正确直接返回登录绑定页面&lt;/span&gt;
        UserBindDO save =&lt;span&gt; userBindRepository.save(userBindDO);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (save != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            log.info(&lt;/span&gt;&quot;bind - 绑定成功&quot;&lt;span&gt;);
            log.info(&lt;/span&gt;&quot;绑定后的结果信息为：&quot; +&lt;span&gt; save);
            map.addAttribute(&lt;/span&gt;&quot;userinfo&quot;&lt;span&gt;, save);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;index3&quot;&lt;span&gt;;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            log.info(&lt;/span&gt;&quot;bind - 绑定失败&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;login&quot;&lt;span&gt;;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;h-13&quot;&gt;源代码&lt;/h3&gt;
&lt;p&gt;　　扫码获取&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1057762/201901/1057762-20190113232004428-255526325.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 13 Jan 2019 15:20:00 +0000</pubDate>
<dc:creator>寻渝记</dc:creator>
<og:description>前提准备 域名 开发微信网页授权时需要一个外网可以访问的域名，因为用户确认进行微信网页授权后微信服务器会通过一个回调URL向开发服务器发送一个回调请求。开发阶段可以使用一些内网穿透工具来实现，例如：n</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/NeverCtrl-C/p/10264538.html</dc:identifier>
</item>
<item>
<title>DirectX11--深入理解与使用2D纹理资源 - X_Jun</title>
<link>http://www.cnblogs.com/X-Jun/p/10262524.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/X-Jun/p/10262524.html</guid>
<description>&lt;p&gt;写教程到现在，我发现有关纹理资源的一些解说和应用都写的太过分散，导致连我自己找起来都不方便。现在决定把这部分的内容整合起来，尽可能做到一篇搞定所有2D纹理相关的内容，其中包括：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;2D纹理的一般创建方法&lt;/li&gt;
&lt;li&gt;DDSTextureLoader和WICTextureLoader&lt;/li&gt;
&lt;li&gt;2D纹理数组的一般创建方法&lt;/li&gt;
&lt;li&gt;2D纹理立方体的一般创建方法(未完工)&lt;/li&gt;
&lt;li&gt;纹理子资源&lt;/li&gt;
&lt;li&gt;纹理资源的完整复制(未完工)&lt;/li&gt;
&lt;li&gt;纹理子资源指定区域的复制(未完工)&lt;/li&gt;
&lt;li&gt;纹理从GPU映射回CPU进行修改&lt;/li&gt;
&lt;li&gt;使用内存初始化纹理&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;你必须要先了解纹理映射，然后再来看这部分内容。&lt;/p&gt;
&lt;p&gt;由于这篇的工作量实在是太大了，目前下面这些代码我还没有提交到项目，而且这篇博客还在施工中，等我全部写完再提交一遍。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/X-Jun/p/9028764.html&quot;&gt;DirectX11 With Windows SDK完整目录&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://github.com/MKXJun/DirectX11-With-Windows-SDK&quot;&gt;Github项目源码&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;欢迎加入QQ群: 727623616 可以一起探讨DX11，以及有什么问题也可以在这里汇报。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Direct3D 11允许我们创建1D纹理、2D纹理、3D纹理，分别对应的接口为&lt;code&gt;ID3D11Texture1D&lt;/code&gt;, &lt;code&gt;ID3D11Texture2D&lt;/code&gt;和&lt;code&gt;ID3D11Texture3D&lt;/code&gt;。创建出来的对象理论上不仅在内存中占用了它的实现类所需空间，还在显存中占用了一定空间以存放纹理的实际数据。&lt;/p&gt;
&lt;p&gt;由于实际上我们最常用到的就是2D纹理，因此这里不会讨论1D纹理和3D纹理的内容。&lt;/p&gt;
&lt;p&gt;首先让我们看看D3D11对一个2D纹理的描述：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;typedef struct D3D11_TEXTURE2D_DESC
{
    UINT Width;                     // 纹理宽度
    UINT Height;                    // 纹理高度
    UINT MipLevels;                 // 允许的Mip等级数
    UINT ArraySize;                 // 可以用于创建纹理数组，这里指定纹理的数目，单个纹理使用1
    DXGI_FORMAT Format;             // DXGI支持的数据格式，默认DXGI_FORMAT_R8G8B8A8_UNORM
    DXGI_SAMPLE_DESC SampleDesc;    // MSAA描述
    D3D11_USAGE Usage;              // 使用D3D11_USAGE枚举值指定数据的CPU/GPU访问权限
    UINT BindFlags;                 // 使用D3D11_BIND_FLAG枚举来决定该数据的使用类型
    UINT CPUAccessFlags;            // 使用D3D11_CPU_ACCESS_FLAG枚举来决定CPU访问权限
    UINT MiscFlags;                 // 使用D3D11_RESOURCE_MISC_FLAG枚举
}   D3D11_TEXTURE2D_DESC;

typedef struct DXGI_SAMPLE_DESC
{
    UINT Count;                     // MSAA采样数
    UINT Quality;                   // MSAA质量等级
} DXGI_SAMPLE_DESC;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;这里特别要讲一下&lt;code&gt;MipLevels&lt;/code&gt;：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;如果你希望它不产生mipmap，则应当指定为1(只包含最大的位图本身)&lt;/li&gt;
&lt;li&gt;如果你希望它能够产生完整的mipmap，可以指定为0，这样你就不需要手工去算这个纹理最大支持的mipmap等级数了，在创建好纹理后，可以再调用&lt;code&gt;ID3D11Texture2D::GetDesc&lt;/code&gt;来查看实际的&lt;code&gt;MipLevels&lt;/code&gt;值是多少&lt;/li&gt;
&lt;li&gt;如果你指定的是其它的值，这里举个例子，该纹理的宽高为&lt;code&gt;400x400&lt;/code&gt;，mip等级为3时，该纹理会产生&lt;code&gt;400x400&lt;/code&gt;，&lt;code&gt;200x200&lt;/code&gt;和&lt;code&gt;100x100&lt;/code&gt;的mipmap&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;对于经常作为着色器资源的纹理，通常是不能对其开启MSAA的，应当把&lt;code&gt;Count&lt;/code&gt;设为1，&lt;code&gt;Quality&lt;/code&gt;设为0&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;紧接着是&lt;code&gt;DXGI_FORMAT&lt;/code&gt;：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;它用于指定纹理存储的数据格式，最常用的就是&lt;code&gt;DXGI_FORMAT_R8G8B8A8_UNORM&lt;/code&gt;了。这种格式在内存的排布可以用下面的结构体表示：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;struct {
    uint8_t a;
    uint8_t b;
    uint8_t g;
    uint8_t r;
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;了解这个对我们后期通过内存填充纹理十分重要。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;然后是&lt;code&gt;Usage&lt;/code&gt;：&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;D3D11_USAGE_DEFAULT&lt;/td&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;D3D11_USAGE_IMMUTABLE&lt;/td&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;D3D11_USAGE_DYNAMIC&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;D3D11_USAGE_STAGING&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;如果一个纹理以&lt;code&gt;D3D11_USAGE_DEFAULT&lt;/code&gt;的方式创建，那么它可以使用下面的这些方法来更新纹理：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;ID3D11DeviceContext::UpdateSubresource&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ID3D11DeviceContext::CopyResource&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ID3D11DeviceContext::CopySubresourceRegion&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;通过&lt;code&gt;DDSTextureLoader&lt;/code&gt;或&lt;code&gt;WICTextureLoader&lt;/code&gt;创建出来的纹理默认都是这种类型&lt;/p&gt;
&lt;p&gt;而如果一个纹理以&lt;code&gt;D3D11_USAGE_IMMUTABLE&lt;/code&gt;的方式创建，则必须在创建阶段就完成纹理资源的初始化。此后GPU只能读取，也无法对纹理再进行修改&lt;/p&gt;
&lt;p&gt;&lt;code&gt;D3D11_USAGE_DYNAMIC&lt;/code&gt;创建的纹理通常需要频繁从CPU写入，使用&lt;code&gt;ID3D11DeviceContext::Map&lt;/code&gt;方法将显存映射回内存，经过修改后再调用&lt;code&gt;ID3D11DeviceContext::UnMap&lt;/code&gt;方法应用更改。而且它对纹理有诸多的要求，直接从下面的ERROR可以看到：&lt;br/&gt;&lt;code&gt;D3D11 ERROR: ID3D11Device::CreateTexture2D: A D3D11_USAGE_DYNAMIC Resource must have ArraySize equal to 1. [ STATE_CREATION ERROR #101: CREATETEXTURE2D_INVALIDDIMENSIONS]&lt;/code&gt;&lt;br/&gt;&lt;code&gt;D3D11 ERROR: ID3D11Device::CreateTexture2D: A D3D11_USAGE_DYNAMIC Resource must have MipLevels equal to 1. [ STATE_CREATION ERROR #102: CREATETEXTURE2D_INVALIDMIPLEVELS]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;上面说到，纹理只能是单个，不能是数组，且mip等级只能是1，即不能有mipmaps&lt;/p&gt;
&lt;p&gt;而&lt;code&gt;D3D11_USAGE_STAGING&lt;/code&gt;则完全允许在CPU和GPU之间的数据传输，但它只能作为一个类似中转站的资源，而不能绑定到渲染管线上，即你也不能用该纹理生成mipmaps。比如说有一个&lt;code&gt;D3D11_USAGE_DEFAULT&lt;/code&gt;你想要从显存拿到内存，只能通过它以&lt;code&gt;ID3D11DeviceContext::CopyResource&lt;/code&gt;或者&lt;code&gt;ID3D11DeviceContext::CopySubresourceRegion&lt;/code&gt;方法来复制一份到本纹理，然后再通过&lt;code&gt;ID3D11DeviceContext::Map&lt;/code&gt;方法取出到内存。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;现在来到&lt;code&gt;BindFlags&lt;/code&gt;：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以下是和纹理有关的&lt;code&gt;D3D11_BIND_FLAG&lt;/code&gt;枚举成员：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;7&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;D3D11_BIND_SHADER_RESOURCE&lt;/td&gt;
&lt;td&gt;纹理可以作为着色器资源绑定到渲染管线&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;D3D11_BIND_STREAM_OUTPUT&lt;/td&gt;
&lt;td&gt;纹理可以作为流输出阶段的输出点&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;D3D11_BIND_RENDER_TARGET&lt;/td&gt;
&lt;td&gt;纹理可以作为渲染目标的输出点，并且指定它可以用于生成mipmaps&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;D3D11_BIND_DEPTH_STENCIL&lt;/td&gt;
&lt;td&gt;纹理可以作为深度/模板缓冲区&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;D3D11_BIND_UNORDERED_ACCESS&lt;/td&gt;
&lt;td&gt;纹理可以绑定到无序访问视图作为输出&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;再看看&lt;code&gt;CPUAccessFlags&lt;/code&gt;：&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;D3D11_CPU_ACCESS_WRITE&lt;/td&gt;
&lt;td&gt;允许通过映射方式从CPU写入，它不能作为管线的输出，且只能用于&lt;code&gt;D3D11_USAGE_DYNAMIC&lt;/code&gt;和&lt;code&gt;D3D11_USAGE_STAGING&lt;/code&gt;绑定的资源&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;D3D11_CPU_ACCESS_READ&lt;/td&gt;
&lt;td&gt;允许通过映射方式给CPU读取，它不能作为管线的输出，且只能用于&lt;code&gt;D3D11_USAGE_STAGING&lt;/code&gt;绑定的资源&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;可以用按位或的方式同时指定上述枚举值，如果该flag设为0可以获得更好的资源优化操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最后是和纹理相关的&lt;code&gt;MiscFlags&lt;/code&gt;：&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;D3D11_RESOURCE_MISC_GENERATE_MIPS&lt;/td&gt;
&lt;td&gt;允许通过&lt;code&gt;ID3D11DeviceContext::GenerateMips&lt;/code&gt;方法生成mipmaps&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;D3D11_RESOURCE_MISC_TEXTURECUBE&lt;/td&gt;
&lt;td&gt;允许该纹理作为纹理立方体舒勇，要求必须是至少包含6个纹理的&lt;code&gt;Texture2DArray&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;id3d11devicecreatetexture2d--创建一个2d纹理&quot;&gt;ID3D11Device::CreateTexture2D--创建一个2D纹理&lt;/h2&gt;
&lt;p&gt;填充好&lt;code&gt;D3D11_TEXTURE2D_DESC&lt;/code&gt;后，你才可以用它创建一个2D纹理：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;HRESULT ID3D11Device::CreateTexture2D( 
    const D3D11_TEXTURE2D_DESC *pDesc,          // [In] 2D纹理描述信息
    const D3D11_SUBRESOURCE_DATA *pInitialData, // [In] 用于初始化的资源
    ID3D11Texture2D **ppTexture2D);             // [Out] 获取到的2D纹理&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;过程我就不演示了。&lt;/p&gt;
&lt;h2 id=&quot;d纹理的资源视图以着色器资源视图为例&quot;&gt;2D纹理的资源视图(以着色器资源视图为例)&lt;/h2&gt;
&lt;p&gt;创建好纹理后，我们还需要让它绑定到资源视图，然后再让该资源视图绑定到渲染管线的指定阶段。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;D3D11_SHADER_RESOURCE_VIEW_DESC&lt;/code&gt;的定义如下：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;typedef struct D3D11_SHADER_RESOURCE_VIEW_DESC
    {
    DXGI_FORMAT Format;
    D3D11_SRV_DIMENSION ViewDimension;
    union 
        {
        D3D11_BUFFER_SRV Buffer;
        D3D11_TEX1D_SRV Texture1D;
        D3D11_TEX1D_ARRAY_SRV Texture1DArray;
        D3D11_TEX2D_SRV Texture2D;
        D3D11_TEX2D_ARRAY_SRV Texture2DArray;
        D3D11_TEX2DMS_SRV Texture2DMS;
        D3D11_TEX2DMS_ARRAY_SRV Texture2DMSArray;
        D3D11_TEX3D_SRV Texture3D;
        D3D11_TEXCUBE_SRV TextureCube;
        D3D11_TEXCUBE_ARRAY_SRV TextureCubeArray;
        D3D11_BUFFEREX_SRV BufferEx;
        }   ;
    }   D3D11_SHADER_RESOURCE_VIEW_DESC;
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中&lt;code&gt;Format&lt;/code&gt;要和纹理创建时的&lt;code&gt;Format&lt;/code&gt;一致，对于2D纹理来说，应当指定&lt;code&gt;D3D11_SRV_DIMENSION&lt;/code&gt;为&lt;code&gt;D3D11_SRV_DIMENSION_TEXTURE2D&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;然后&lt;code&gt;D3D11_TEX2D_SRV&lt;/code&gt;结构体定义如下：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;typedef struct D3D11_TEX2D_SRV
{
    UINT MostDetailedMip;
    UINT MipLevels;
}   D3D11_TEX2D_SRV;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过&lt;code&gt;MostDetailedMap&lt;/code&gt;我们可以指定开始使用的纹理子资源，&lt;code&gt;MipLevels&lt;/code&gt;则指定使用的子资源数目。如果要使用完整mipmaps，则需要指定&lt;code&gt;MostDetailedMap&lt;/code&gt;为0， &lt;code&gt;MipLevels&lt;/code&gt;为-1.&lt;/p&gt;
&lt;p&gt;例如我想像下图那样使用mip等级为1到2的纹理子资源，可以指定&lt;code&gt;MostDetailedMip&lt;/code&gt;为1，&lt;code&gt;MipLevels&lt;/code&gt;为2.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1172605/201901/1172605-20190113225112404-674178987.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;创建着色器资源视图的演示如下：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;D3D11_SHADER_RESOURCE_VIEW_DESC srvDesc;
srvDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
srvDesc.ViewDimension = D3D11_SRV_DIMENSION_TEXTURE2D;
srvDesc.Texture2D.MipLevels = 1;
srvDesc.Texture2D.MostDetailedMip = 0;
HR(md3dDevice-&amp;gt;CreateShaderResourceView(tex.Get(), &amp;amp;srvDesc, texSRV.GetAddressOf()));&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;作为一个纹理相关的综合教程，我可能会重复之前我讲过的内容。&lt;/p&gt;
&lt;h2 id=&quot;dds位图和wic位图&quot;&gt;DDS位图和WIC位图&lt;/h2&gt;
&lt;p&gt;DDS是一种图片格式，是DirectDraw Surface的缩写，它是DirectX纹理压缩（DirectX Texture Compression，简称DXTC）的产物。由NVIDIA公司开发。大部分3D游戏引擎都可以使用DDS格式的图片用作贴图，也可以制作法线贴图。&lt;/p&gt;
&lt;p&gt;WIC（Windows Imaging Component）是一个可以扩展的平台，为数字图像提供底层API，它可以支持bmp、dng、ico、jpeg、png、tiff等格式的位图。&lt;/p&gt;
&lt;h2 id=&quot;如何添加进你的项目&quot;&gt;如何添加进你的项目&lt;/h2&gt;
&lt;p&gt;在&lt;a href=&quot;https://github.com/Microsoft/DirectXTex&quot;&gt;DirectXTex&lt;/a&gt;中找到&lt;code&gt;DDSTextureLoader&lt;/code&gt;文件夹和&lt;code&gt;WICTextureLoader&lt;/code&gt;文件夹中分别找到对应的头文件和源文件(不带12的)，并加入到你的项目中&lt;/p&gt;
&lt;h2 id=&quot;ddstextureloader&quot;&gt;DDSTextureLoader&lt;/h2&gt;
&lt;h3 id=&quot;createddstexturefromfile函数--从文件读取dds纹理&quot;&gt;CreateDDSTextureFromFile函数--从文件读取DDS纹理&lt;/h3&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;HRESULT CreateDDSTextureFromFile(
    ID3D11Device* d3dDevice,                // [In]D3D设备
    const wchar_t* szFileName,              // [In]dds图片文件名
    ID3D11Resource** texture,               // [Out]输出一个指向资源接口类的指针，也可以填nullptr
    ID3D11ShaderResourceView** textureView, // [Out]输出一个指向着色器资源视图的指针，也可以填nullptr
    size_t maxsize = 0,                     // [In]限制纹理最大宽高，若超过则内部会缩放，默认0不限制
    DDS_ALPHA_MODE* alphaMode = nullptr);   // [In]忽略
    
HRESULT CreateDDSTextureFromFile(
    ID3D11Device* d3dDevice,                // [In]D3D设备
    ID3D11DeviceContext* d3dContext,        // [In]D3D设备上下文
    const wchar_t* szFileName,              // [In]dds图片文件名
    ID3D11Resource** texture,               // [Out]输出一个指向资源接口类的指针，也可以填nullptr
    ID3D11ShaderResourceView** textureView, // [Out]输出一个指向着色器资源视图的指针，也可以填nullptr
    size_t maxsize = 0,                     // [In]限制纹理最大宽高，若超过则内部会缩放，默认0不限制
    DDS_ALPHA_MODE* alphaMode = nullptr);   // [In]忽略&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第二个重载版本用于为DDS位图生成mipmaps，但大多数情况下你能载入的DDS位图本身都自带mipmaps了，与其运行时生成，不如提前为它制作mipmaps。&lt;/p&gt;
&lt;h3 id=&quot;createddstexturefromfileex函数--从文件读取dds纹理的增强版&quot;&gt;CreateDDSTextureFromFileEx函数--从文件读取DDS纹理的增强版&lt;/h3&gt;
&lt;p&gt;上面两个函数都使用了这个函数，而且如果你想要更强的扩展性，就可以了解一下：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;HRESULT CreateDDSTextureFromFileEx(
    ID3D11Device* d3dDevice,                // [In]D3D设备
    const wchar_t* szFileName,              // [In].dds文件名
    size_t maxsize,                         // [In]限制纹理最大宽高，若超过则内部会缩放，默认0不限制
    D3D11_USAGE usage,                      // [In]使用D3D11_USAGE枚举值指定数据的CPU/GPU访问权限
    unsigned int bindFlags,                 // [In]使用D3D11_BIND_FLAG枚举来决定该数据的使用类型
    unsigned int cpuAccessFlags,            // [In]D3D11_CPU_ACCESS_FLAG枚举值
    unsigned int miscFlags,                 // [In]D3D11_RESOURCE_MISC_FLAG枚举值
    bool forceSRGB,                         // [In]强制使用SRGB，默认false
    ID3D11Resource** texture,               // [Out]获取创建好的纹理(可选)
    ID3D11ShaderResourceView** textureView, // [Out]获取创建好的纹理资源视图(可选)
    DDS_ALPHA_MODE* alphaMode = nullptr);   // [Out]忽略(可选)
    
HRESULT CreateDDSTextureFromFileEx(
    ID3D11Device* d3dDevice,                // [In]D3D设备
    ID3D11DeviceContext* d3dContext,        // [In]D3D设备上下文
    const wchar_t* szFileName,              // [In].dds文件名
    size_t maxsize,                         // [In]限制纹理最大宽高，若超过则内部会缩放，默认0不限制
    D3D11_USAGE usage,                      // [In]使用D3D11_USAGE枚举值指定数据的CPU/GPU访问权限
    unsigned int bindFlags,                 // [In]使用D3D11_BIND_FLAG枚举来决定该数据的使用类型
    unsigned int cpuAccessFlags,            // [In]D3D11_CPU_ACCESS_FLAG枚举值
    unsigned int miscFlags,                 // [In]D3D11_RESOURCE_MISC_FLAG枚举值
    bool forceSRGB,                         // [In]强制使用SRGB，默认false
    ID3D11Resource** texture,               // [Out]获取创建好的纹理(可选)
    ID3D11ShaderResourceView** textureView, // [Out]获取创建好的纹理资源视图(可选)
    DDS_ALPHA_MODE* alphaMode = nullptr);   // [Out]忽略(可选)&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;createddstexturefrommemory函数--从内存创建dds纹理&quot;&gt;CreateDDSTextureFromMemory函数--从内存创建DDS纹理&lt;/h3&gt;
&lt;p&gt;这里我只介绍简易版本的，因为跟上面提到的函数差别只是读取来源不一样，其余参数我就不再赘述：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;HRESULT CreateDDSTextureFromMemory(
    ID3D11Device* d3dDevice,                // [In]D3D设备
    const uint8_t* ddsData,                 // [In]原dds文件读取到的完整二进制流
    size_t ddsDataSize,                     // [In]原dds文件的大小
    ID3D11Resource** texture,               // [Out]获取创建好的纹理(可选)
    ID3D11ShaderResourceView** textureView, // [Out]获取创建好的纹理资源视图(可选)
    size_t maxsize = 0,                     // [In]限制纹理最大宽高，若超过则内部会缩放，默认0不限制
    DDS_ALPHA_MODE* alphaMode = nullptr);   // [Out]忽略(可选)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果你需要生成mipmaps，就使用带D3D设备上下文的重载版本。&lt;/p&gt;
&lt;h2 id=&quot;wictextureloader&quot;&gt;WICTextureLoader&lt;/h2&gt;
&lt;h3 id=&quot;createwictexturefromfileex&quot;&gt;CreateWICTextureFromFileEx&lt;/h3&gt;
&lt;p&gt;由于用法上和&lt;code&gt;DDSTextureLoader&lt;/code&gt;大同小异，我这里也只提&lt;code&gt;CreateWICTextureFromFileEx&lt;/code&gt;函数：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;HRESULT CreateWICTextureFromFileEx(
    ID3D11Device* d3dDevice,                // [In]D3D设备
    const wchar_t* szFileName,              // [In]位图文件名
    size_t maxsize,                         // [In]限制纹理最大宽高，若超过则内部会缩放，默认0不限制
    D3D11_USAGE usage,                      // [In]使用D3D11_USAGE枚举值指定数据的CPU/GPU访问权限
    unsigned int bindFlags,                 // [In]使用D3D11_BIND_FLAG枚举来决定该数据的使用类型
    unsigned int cpuAccessFlags,            // [In]D3D11_CPU_ACCESS_FLAG枚举值
    unsigned int miscFlags,                 // [In]D3D11_RESOURCE_MISC_FLAG枚举值
    unsigned int loadFlags,                 // [In]默认WIC_LOADER_DEAULT
    ID3D11Resource** texture,               // [Out]获取创建好的纹理(可选)
    ID3D11ShaderResourceView** textureView);// [Out]获取创建好的纹理资源视图(可选)&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;通常我们将包含mipmaps的纹理称作&lt;strong&gt;纹理&lt;/strong&gt;，那么&lt;strong&gt;纹理子资源&lt;/strong&gt;实际上指的就是其中的一个mip等级对应的2维数组(针对2维纹理来说)。比如512x512的纹理加载进来包含的mipmap等级数(Mipmap Levels)为10，包含了从512x512, 256x256, 128x128...到1x1的10个二维数组颜色数据，这十个纹理子资源在纹理中的内存是紧凑的，没有内存填充。&lt;/p&gt;
&lt;p&gt;例如：上述纹理(R8G8B8A8格式) mip等级为1的纹理子资源首元素地址 为 从mip等级为0的纹理子资源首元素地址再偏移512x512x4字节的地址。&lt;/p&gt;
&lt;p&gt;Direct3D API使用Mip切片(Mip slice)来指定某一mip等级的纹理子资源，也有点像索引。比如mip slice值为0时，对应的是512x512的纹理，而mip slice值1对应的是256x256，以此类推。&lt;/p&gt;
&lt;h2 id=&quot;描述一个纹理子资源的两种结构体&quot;&gt;描述一个纹理子资源的两种结构体&lt;/h2&gt;
&lt;p&gt;如果你想要为2D纹理进行初始化，那么你要接触到的结构体类型为&lt;code&gt;D3D11_SUBRESOURCE_DATA&lt;/code&gt;。定义如下：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;typedef struct D3D11_SUBRESOURCE_DATA
{
    const void *pSysMem;    // 用于初始化的数据
    UINT SysMemPitch;       // 当前子资源一行所占的字节数(2D/3D纹理使用)
    UINT SysMemSlicePitch;  // 当前子资源一个完整切片所占的字节数(仅3D纹理使用)
}   D3D11_SUBRESOURCE_DATA;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1172605/201901/1172605-20190113224536378-741138620.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而如果你使用的是&lt;code&gt;ID3D11DeviceContext::Map&lt;/code&gt;方法来获取一个纹理子资源，那么获取到的是&lt;code&gt;D3D11_SUBRESOURCE_DATA结构体&lt;/code&gt;，其定义如下：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;typedef struct D3D11_MAPPED_SUBRESOURCE {
    void *pData;        // 映射到内存的数据or需要提交的地址范围
    UINT RowPitch;      // 当前子资源一行所占的字节数(2D/3D纹理有意义)
    UINT DepthPitch;    // 当前子资源一个完整切片所占的字节数(仅3D纹理有意义)
} D3D11_MAPPED_SUBRESOURCE;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;若一张512x512的纹理(R8G8B8A8)，那么它的&lt;code&gt;RowPitch&lt;/code&gt;为512&lt;em&gt;4=2048字节，同理在初始化一个512x512的纹理(R8G8B8A8)，它的&lt;code&gt;SysMemPitch&lt;/code&gt;为512&lt;/em&gt;4=2048字节。&lt;/p&gt;

&lt;p&gt;现在我们尝试通过代码的形式来创建一个纹理(以项目09作为修改)，代码如下：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;uint32_t ColorRGBA(uint8_t r, uint8_t g, uint8_t b, uint8_t a)
{
    return (r | (g &amp;lt;&amp;lt; 8) | (b &amp;lt;&amp;lt; 16) | (a &amp;lt;&amp;lt; 24));
}


bool GameApp::InitResource()
{
    uint32_t black = ColorRGBA(0, 0, 0, 255), orange = ColorRGBA(255, 108, 0, 255);

    // 纹理内存映射，用黑色初始化
    std::vector&amp;lt;uint32_t&amp;gt; textureArrayMap(128 * 128, black);
    uint32_t(*textureMap)[128] = reinterpret_cast&amp;lt;uint32_t(*)[128]&amp;gt;(textureArrayMap.data());

    for (int y = 7; y &amp;lt;= 17; ++y)
        for (int x = 25 - y; x &amp;lt;= 102 + y; ++x)
            textureMap[y][x] = textureMap[127 - y][x] = orange;

    for (int y = 18; y &amp;lt;= 109; ++y)
        for (int x = 7; x &amp;lt;= 120; ++x)
            textureMap[y][x] = orange;

    // 创建纹理数组
    D3D11_TEXTURE2D_DESC texArrayDesc;
    texArrayDesc.Width = 128;
    texArrayDesc.Height = 128;
    texArrayDesc.MipLevels = 1;
    texArrayDesc.ArraySize = 1;
    texArrayDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
    texArrayDesc.SampleDesc.Count = 1;      // 不使用多重采样
    texArrayDesc.SampleDesc.Quality = 0;
    texArrayDesc.Usage = D3D11_USAGE_DEFAULT;
    texArrayDesc.BindFlags = D3D11_BIND_SHADER_RESOURCE;
    texArrayDesc.CPUAccessFlags = 0;
    texArrayDesc.MiscFlags = 0; // 指定需要生成mipmap

    D3D11_SUBRESOURCE_DATA sd;
    uint32_t * pData = textureArrayMap.data();
    sd.pSysMem = pData;
    sd.SysMemPitch = 128 * sizeof(uint32_t);
    sd.SysMemSlicePitch = 128 * 128 * sizeof(uint32_t);


    ComPtr&amp;lt;ID3D11Texture2D&amp;gt; tex;
    HR(md3dDevice-&amp;gt;CreateTexture2D(&amp;amp;texArrayDesc, &amp;amp;sd, tex.GetAddressOf()));

    D3D11_SHADER_RESOURCE_VIEW_DESC srvDesc;
    srvDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
    srvDesc.ViewDimension = D3D11_SRV_DIMENSION_TEXTURE2D;
    srvDesc.Texture2D.MipLevels = 1;
    srvDesc.Texture2D.MostDetailedMip = 0;
    HR(md3dDevice-&amp;gt;CreateShaderResourceView(tex.Get(), &amp;amp;srvDesc, mTexSRV.GetAddressOf()));
    
    // ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其它部分的代码修改就不讲了，最终效果如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1172605/201901/1172605-20190113224412505-748425660.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是如果你想要以初始化的方式来创建带mipmap的&lt;code&gt;Texture2D&lt;/code&gt;纹理，则在初始化的时候需要提供&lt;code&gt;D3D11_SUBRESOURCE_DATA&lt;/code&gt;数组，元素数目为&lt;code&gt;MipLevels&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;之前提到，&lt;code&gt;D3D11_TEXTURE2D_DESC&lt;/code&gt;中可以通过指定&lt;code&gt;ArraySize&lt;/code&gt;的值来将其创建为纹理数组。&lt;/p&gt;
&lt;h2 id=&quot;hlsl中的2d纹理数组&quot;&gt;HLSL中的2D纹理数组&lt;/h2&gt;
&lt;p&gt;首先来到HLSL代码，我们之所以不使用下面的这种形式创建纹理数组：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;Texture2D gTexArray[7] : register(t0);

// 像素着色器
float4 PS(VertexPosHTex pIn) : SV_Target
{
    float4 texColor = gTexArray[gTexIndex].Sample(gSam, float2(pIn.Tex));
    return texColor;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;是因为这样做的话HLSL编译器会报错：sampler array index must be a literal experssion，即pin.PrimID的值也必须是个字面值，而不是变量。但我们还是想要能够根据变量取对应纹理的能力。&lt;/p&gt;
&lt;p&gt;正确的做法应当是声明一个&lt;code&gt;Texture2DArray&lt;/code&gt;的数组：&lt;/p&gt;
&lt;p&gt;Texture2DArray gTexArray : register(t0);&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Texture2DArray&lt;/code&gt;同样也具有&lt;code&gt;Sample&lt;/code&gt;方法，用法示例如下：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// 像素着色器
float4 PS(VertexPosHTex pIn) : SV_Target
{
    float4 texColor = gTexArray.Sample(gSam, float3(pIn.Tex, gTexIndex));
    return texColor;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Sample方法的第一个参数依然是采样器&lt;/p&gt;
&lt;p&gt;而第二个参数则是一个3D向量，其中x与y的值对应的还是纹理坐标，而z分量即便是个&lt;code&gt;float&lt;/code&gt;，主要是用于作为索引值选取纹理数组中的某一个具体纹理。同理索引值0对应纹理数组的第一张纹理，1对应的是第二张纹理等等...&lt;/p&gt;
&lt;p&gt;使用纹理数组的优势是，我们可以一次性预先创建好所有需要用到的纹理，并绑定到HLSL的纹理数组中，而不需要每次都重新绑定一个纹理。然后我们再使用索引值来访问纹理数组中的某一纹理。&lt;/p&gt;
&lt;h2 id=&quot;d3d11calcsubresource函数--计算子资源的索引值&quot;&gt;D3D11CalcSubresource函数--计算子资源的索引值&lt;/h2&gt;
&lt;p&gt;对于纹理数组，每个元素都会包含同样的mip等级数。Direct3D API使用数组切片(array slice)来访问不同纹理，也是相当于索引。这样我们就可以把所有的纹理资源用下面的图来表示，假定下图有4个纹理，每个纹理包含3个子资源，则当前指定的是Array Slice为2，Mip Slice为1的子资源。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1172605/201808/1172605-20180818164554848-1396823168.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后给定当前纹理数组每个纹理的mipmap等级数(Mipmap Levels)，数组切片(Array Slice)和Mip切片(Mip Slice)，我们就可以用下面的函数来求得指定子资源的索引值：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;inline UINT D3D11CalcSubresource(UINT MipSlice, UINT ArraySlice, UINT MipLevels )
{ return MipSlice + ArraySlice * MipLevels; }&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;创建一个纹理数组&quot;&gt;创建一个纹理数组&lt;/h2&gt;
&lt;p&gt;现在我们手头上仅有的就是&lt;code&gt;DDSTextureLoader.h&lt;/code&gt;和&lt;code&gt;WICTextureLoader.h&lt;/code&gt;中的函数，但这里面的函数每次都只能加载一张纹理。我们还需要修改龙书样例中读取纹理的函数，具体的操作顺序如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;一个个读取存有纹理的文件，创建出一系列&lt;code&gt;ID3D11Texture2D&lt;/code&gt;对象，这里的每个对象单独包含一张纹理；&lt;/li&gt;
&lt;li&gt;创建一个&lt;code&gt;ID3D11Texture2D&lt;/code&gt;对象，它同时也是一个纹理数组；&lt;/li&gt;
&lt;li&gt;将之前读取的所有纹理有条理地复制到刚创建的纹理数组对象中；&lt;/li&gt;
&lt;li&gt;为该纹理数组对象创建创建一个纹理资源视图（Shader Resource View）。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;为了避免出现一些问题，这里实现的纹理数组加载的函数只考虑宽度和高度、数据格式、mip等级都一致的情况。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;d3dUtil.h&lt;/code&gt;中实现了这样两个函数：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// ------------------------------
// CreateDDSTexture2DArrayFromFile函数
// ------------------------------
// 该函数要求所有的dds纹理的宽高、数据格式、mip等级一致
// [In]d3dDevice            D3D设备
// [InOpt]d3dDeviceContext  D3D设备上下文
// [In]fileNames            dds文件名数组
// [OutOpt]textureArray     输出的纹理数组资源
// [OutOpt]textureArrayView 输出的纹理数组资源视图
// [In]generateMips         是否生成mipmaps
HRESULT CreateDDSTexture2DArrayFromFile(
    ID3D11Device * d3dDevice,
    ID3D11DeviceContext * d3dDeviceContext,
    const std::vector&amp;lt;std::wstring&amp;gt;&amp;amp; fileNames,
    ID3D11Texture2D** textureArray,
    ID3D11ShaderResourceView** textureArrayView,
    bool generateMips = false);

// ------------------------------
// CreateWICTexture2DArrayFromFile函数
// ------------------------------
// 该函数要求所有的dds纹理的宽高、数据格式、mip等级一致
// [In]d3dDevice            D3D设备
// [InOpt]d3dDeviceContext  D3D设备上下文
// [In]fileNames            dds文件名数组
// [OutOpt]textureArray     输出的纹理数组资源
// [OutOpt]textureArrayView 输出的纹理数组资源视图
// [In]generateMips         是否生成mipmaps
HRESULT CreateWICTexture2DArrayFromFile(
    ID3D11Device * d3dDevice,
    ID3D11DeviceContext * d3dDeviceContext,
    const std::vector&amp;lt;std::wstring&amp;gt;&amp;amp; fileNames,
    ID3D11Texture2D** textureArray,
    ID3D11ShaderResourceView** textureArrayView,
    bool generateMips = false);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;还有就是&lt;code&gt;d3dUtil.cpp&lt;/code&gt;用到的函数&lt;code&gt;CreateTexture2DArray&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;第一步先讨论纹理的加载，这里`CreateDDSTexture2DArrayFromFile函数的实现如下：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;HRESULT CreateDDSTexture2DArrayFromFile(
    ID3D11Device * d3dDevice,
    ID3D11DeviceContext * d3dDeviceContext,
    const std::vector&amp;lt;std::wstring&amp;gt;&amp;amp; fileNames,
    ID3D11Texture2D** textureArray,
    ID3D11ShaderResourceView** textureArrayView,
    bool generateMips)
{
    // 检查设备、着色器资源视图、文件名数组是否非空
    if (!d3dDevice || !textureArrayView || fileNames.empty())
        return E_INVALIDARG;

    HRESULT hResult;
    // ******************
    // 读取所有纹理
    //

    UINT arraySize = (UINT)fileNames.size();
    std::vector&amp;lt;ID3D11Texture2D*&amp;gt; srcTex(arraySize, nullptr);
    for (size_t i = 0; i &amp;lt; arraySize; ++i)
    {
        // 由于这些纹理并不会被GPU使用，我们使用D3D11_USAGE_STAGING枚举值
        // 使得CPU可以读取资源
        hResult = CreateDDSTextureFromFileEx(d3dDevice, d3dDeviceContext,
            fileNames[i].c_str(), 0, D3D11_USAGE_STAGING, 0,
            D3D11_CPU_ACCESS_WRITE | D3D11_CPU_ACCESS_READ, 
            0, false, (ID3D11Resource**)&amp;amp;srcTex[i], nullptr);

        if (FAILED(hResult))
            break;
    }

    if (hResult == S_OK)
    {
        hResult = CreateTexture2DArray(d3dDevice, d3dDeviceContext, srcTex,
            D3D11_USAGE_DEFAULT,
            D3D11_BIND_SHADER_RESOURCE | (generateMips ? D3D11_BIND_RENDER_TARGET : 0),
            0,
            (generateMips ? D3D11_RESOURCE_MISC_GENERATE_MIPS : 0),
            textureArray,
            textureArrayView);
    }
    

    for (size_t i = 0; i &amp;lt; arraySize; ++i)
        if (srcTex[i])
            srcTex[i]-&amp;gt;Release();

    return hResult;

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而WIC版的区别仅在于把&lt;code&gt;CreateDDSTextureFromFileEx&lt;/code&gt;替换为&lt;code&gt;CreateWICTextureFromFileEx&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;hResult = CreateWICTextureFromFileEx(d3dDevice, d3dDeviceContext,
    fileNames[i].c_str(), 0, D3D11_USAGE_STAGING, 0,
    D3D11_CPU_ACCESS_WRITE | D3D11_CPU_ACCESS_READ,
    0, WIC_LOADER_DEFAULT, (ID3D11Resource**)&amp;amp;srcTex[i], nullptr);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在了解&lt;code&gt;CreateTexture2DArray&lt;/code&gt;函数的实现前，你需要下面这些内容：&lt;/p&gt;
&lt;h3 id=&quot;id3d11devicecontextmap函数--获取指向子资源中数据的指针并拒绝gpu对该子资源的访问&quot;&gt;ID3D11DeviceContext::Map函数--获取指向子资源中数据的指针并拒绝GPU对该子资源的访问&lt;/h3&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;HRESULT ID3D11DeviceContext::Map(
    ID3D11Resource           *pResource,          // [In]包含ID3D11Resource接口的资源对象
    UINT                     Subresource,         // [In]子资源索引
    D3D11_MAP                MapType,             // [In]D3D11_MAP枚举值，指定读写相关操作
    UINT                     MapFlags,            // [In]填0，忽略
    D3D11_MAPPED_SUBRESOURCE *pMappedResource     // [Out]获取到的已经映射到内存的子资源
);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;D3D11_MAP枚举值类型的成员如下：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;9.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;D3D11_MAP_READ&lt;/td&gt;
&lt;td&gt;映射到内存的资源用于读取。该资源在创建的时候必须绑定了&lt;br/&gt;D3D11_CPU_ACCESS_READ标签&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;D3D11_MAP_WRITE&lt;/td&gt;
&lt;td&gt;映射到内存的资源用于写入。该资源在创建的时候必须绑定了&lt;br/&gt;D3D11_CPU_ACCESS_WRITE标签&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;D3D11_MAP_READ_WRITE&lt;/td&gt;
&lt;td&gt;映射到内存的资源用于读写。该资源在创建的时候必须绑定了&lt;br/&gt;D3D11_CPU_ACCESS_READ和D3D11_CPU_ACCESS_WRITE标签&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;D3D11_MAP_WRITE_DISCARD&lt;/td&gt;
&lt;td&gt;映射到内存的资源用于写入，之前的资源数据将会被抛弃。该&lt;br/&gt;资源在创建的时候必须绑定了D3D11_CPU_ACCESS_WRITE和&lt;br/&gt;D3D11_USAGE_DYNAMIC标签&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;7&quot;&gt;&lt;td&gt;D3D11_MAP_WRITE_NO_OVERWRITE&lt;/td&gt;
&lt;td&gt;映射到内存的资源用于写入，但不能复写已经存在的资源。&lt;br/&gt;该枚举值只能用于顶点/索引缓冲区。该资源在创建的时候需要&lt;br/&gt;有D3D11_CPU_ACCESS_WRITE标签，在Direct3D 11不能用于&lt;br/&gt;设置了D3D11_BIND_CONSTANT_BUFFER标签的资源，但在&lt;br/&gt;11.1后可以。具体可以查阅MSDN文档&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;id3d11devicecontextupdatesubresource函数2--将内存数据拷贝到不可进行映射的子资源中&quot;&gt;ID3D11DeviceContext::UpdateSubresource函数[2]--将内存数据拷贝到不可进行映射的子资源中&lt;/h3&gt;
&lt;p&gt;这个函数在之前我们主要是用来将内存数据拷贝到常量缓冲区中，现在我们也可以用它将内存数据拷贝到纹理的子资源当中：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void ID3D11DeviceContext::UpdateSubresource(
  ID3D11Resource  *pDstResource,    // [In]目标资源对象
  UINT            DstSubresource,   // [In]对于2D纹理来说，该参数为指定Mip等级的子资源
  const D3D11_BOX *pDstBox,         // [In]这里通常填nullptr，或者拷贝的数据宽高比当前子资源小时可以指定范围 
  const void      *pSrcData,        // [In]用于拷贝的内存数据
  UINT            SrcRowPitch,      // [In]该2D纹理的 宽度*数据格式的位数
  UINT            SrcDepthPitch     // [In]对于2D纹理来说并不需要用到该参数，因此可以任意设置
);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;id3d11devicecontextunmap函数--让指向资源的指针无效并重新启用gpu对该资源的访问权限&quot;&gt;ID3D11DeviceContext::UnMap函数--让指向资源的指针无效并重新启用GPU对该资源的访问权限&lt;/h3&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void ID3D11DeviceContext::Unmap(
    ID3D11Resource *pResource,      // [In]包含ID3D11Resource接口的资源对象
    UINT           Subresource      // [In]需要取消的子资源索引
);&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;d3d11_tex2d_array_srv结构体&quot;&gt;D3D11_TEX2D_ARRAY_SRV结构体&lt;/h3&gt;
&lt;p&gt;在创建着色器目标视图时，你还需要填充共用体中的&lt;code&gt;D3D11_TEX2D_ARRAY_SRV&lt;/code&gt;结构体：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;typedef struct D3D11_TEX2D_ARRAY_SRV
{
    UINT MostDetailedMip;       
    UINT MipLevels;
    UINT FirstArraySlice;
    UINT ArraySize;
}   D3D11_TEX2D_ARRAY_SRV;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过&lt;code&gt;FirstArraySlice&lt;/code&gt;我们可以指定开始使用的纹理，&lt;code&gt;ArraySize&lt;/code&gt;则指定使用的纹理数目。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1172605/201901/1172605-20190113225248482-1512207708.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;例如我想指定像上面那样的范围，可以指定&lt;code&gt;FirstArraySlice&lt;/code&gt;为1，&lt;code&gt;ArraySize&lt;/code&gt;为2，&lt;code&gt;MostDetailedMip&lt;/code&gt;为1，&lt;code&gt;MipLevels&lt;/code&gt;为2.&lt;/p&gt;
&lt;p&gt;最终&lt;code&gt;CreateTexture2DArray&lt;/code&gt;的实现如下：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;static HRESULT CreateTexture2DArray(
    ID3D11Device * d3dDevice,
    ID3D11DeviceContext * d3dDeviceContext,
    std::vector&amp;lt;ID3D11Texture2D*&amp;gt;&amp;amp; srcTex,
    D3D11_USAGE usage,
    UINT bindFlags,
    UINT cpuAccessFlags,
    UINT miscFlags,
    ID3D11Texture2D** textureArray,
    ID3D11ShaderResourceView** textureArrayView)
{

    if (!textureArray &amp;amp;&amp;amp; !textureArrayView || !d3dDevice || !d3dDeviceContext || srcTex.empty())
        return E_INVALIDARG;

    // 需要检验所有纹理的mipLevels，宽度和高度，数据格式是否一致，
    // 若存在数据格式不一致的情况，请使用dxtex.exe(DirectX Texture Tool)
    // 将所有的图片转成一致的数据格式
    UINT arraySize = (UINT)srcTex.size();
    std::vector&amp;lt;D3D11_TEXTURE2D_DESC&amp;gt; texDesc(arraySize);
    for (int i = 0; i &amp;lt; arraySize; ++i)
    {
        if (texDesc[i].MipLevels != texDesc[0].MipLevels || texDesc[i].Width != texDesc[0].Width ||
            texDesc[i].Height != texDesc[0].Height || texDesc[i].Format != texDesc[0].Format)
        {
            return E_FAIL;
        }
    }
    
    HRESULT hResult;
    bool generateMips = (bindFlags &amp;amp; D3D11_BIND_RENDER_TARGET) &amp;amp;&amp;amp;
        (miscFlags &amp;amp; D3D11_RESOURCE_MISC_GENERATE_MIPS);
    // ******************
    // 创建纹理数组
    //

    D3D11_TEXTURE2D_DESC texArrayDesc;
    texArrayDesc.Width = texDesc[0].Width;
    texArrayDesc.Height = texDesc[0].Height;
    texArrayDesc.MipLevels = generateMips ? 0 : texDesc[0].MipLevels;
    texArrayDesc.ArraySize = arraySize;
    texArrayDesc.Format = texDesc[0].Format;
    texArrayDesc.SampleDesc.Count = 1;      // 不能使用多重采样
    texArrayDesc.SampleDesc.Quality = 0;
    texArrayDesc.Usage = usage;
    texArrayDesc.BindFlags = bindFlags;
    texArrayDesc.CPUAccessFlags = cpuAccessFlags;
    texArrayDesc.MiscFlags = miscFlags;

    ID3D11Texture2D* texArray;
    hResult = d3dDevice-&amp;gt;CreateTexture2D(&amp;amp;texArrayDesc, nullptr, &amp;amp;texArray);
    if (FAILED(hResult))
    {
        for (size_t i = 0; i &amp;lt; arraySize; ++i)
            srcTex[i]-&amp;gt;Release();
        return E_FAIL;
    }

    texArray-&amp;gt;GetDesc(&amp;amp;texArrayDesc);
    // ******************
    // 将所有的纹理子资源赋值到纹理数组中
    //

    UINT minMipLevels = (generateMips ? 1 : texArrayDesc.MipLevels);
    // 每个纹理元素
    for (UINT i = 0; i &amp;lt; texArrayDesc.ArraySize; ++i)
    {
        // 纹理中的每个mipmap等级
        for (UINT j = 0; j &amp;lt; minMipLevels; ++j)
        {
            D3D11_MAPPED_SUBRESOURCE mappedTex2D;
            // 允许映射索引i纹理中，索引j的mipmap等级的2D纹理
            d3dDeviceContext-&amp;gt;Map(srcTex[i],
                j, D3D11_MAP_READ, 0, &amp;amp;mappedTex2D);

            d3dDeviceContext-&amp;gt;UpdateSubresource(
                texArray,
                D3D11CalcSubresource(j, i, texArrayDesc.MipLevels), // i * mipLevel + j
                nullptr,
                mappedTex2D.pData,
                mappedTex2D.RowPitch,
                mappedTex2D.DepthPitch);
            // 停止映射
            d3dDeviceContext-&amp;gt;Unmap(srcTex[i], j);
        }
    }

    // ******************
    // 创建纹理数组的SRV
    //
    if (textureArrayView)
    {
        D3D11_SHADER_RESOURCE_VIEW_DESC viewDesc;
        viewDesc.Format = texArrayDesc.Format;
        viewDesc.ViewDimension = D3D11_SRV_DIMENSION_TEXTURE2DARRAY;
        viewDesc.Texture2DArray.MostDetailedMip = 0;
        viewDesc.Texture2DArray.MipLevels = texArrayDesc.MipLevels;
        viewDesc.Texture2DArray.FirstArraySlice = 0;
        viewDesc.Texture2DArray.ArraySize = arraySize;

        hResult = d3dDevice-&amp;gt;CreateShaderResourceView(texArray, &amp;amp;viewDesc, textureArrayView);

        // 生成mipmaps
        if (hResult == S_OK &amp;amp;&amp;amp; generateMips)
        {
            d3dDeviceContext-&amp;gt;GenerateMips(*textureArrayView);
        }
    }

    // 检查是否需要纹理数组
    if (textureArray)
    {
        *textureArray = texArray;
    }
    else
    {
        texArray-&amp;gt;Release();
    }

    return hResult;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;(未完待续)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/X-Jun/p/9028764.html&quot;&gt;DirectX11 With Windows SDK完整目录&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://github.com/MKXJun/DirectX11-With-Windows-SDK&quot;&gt;Github项目源码&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;欢迎加入QQ群: 727623616 可以一起探讨DX11，以及有什么问题也可以在这里汇报。&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 13 Jan 2019 14:59:00 +0000</pubDate>
<dc:creator>X_Jun</dc:creator>
<og:description>前言 写教程到现在，我发现有关纹理资源的一些解说和应用都写的太过分散，导致连我自己找起来都不方便。现在决定把这部分的内容整合起来，尽可能做到一篇搞定所有2D纹理相关的内容，其中包括： 1. 2D纹理的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/X-Jun/p/10262524.html</dc:identifier>
</item>
<item>
<title>晚来的2018年总结 - ZepheryWen</title>
<link>http://www.cnblogs.com/w1570631036/p/10263109.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/w1570631036/p/10263109.html</guid>
<description>&lt;h3 id=&quot;点点我的网站呗好久没访问量了httpwww.wenzhihuai.com&quot;&gt;点点我的网站呗，好久没访问量了，&lt;a href=&quot;http://www.wenzhihuai.com&quot; class=&quot;uri&quot;&gt;http://www.wenzhihuai.com&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;年底老姐结婚，跑回家去了，忙着一直没写，本来想回深圳的时候空余的时候写写，没想到一直加班，嗯，9点半下班那种，偶尔也趁着间隙的时间，一段一段的凑着吧。&lt;/p&gt;
&lt;p&gt;想着17年12月31号写的那篇文章&lt;a href=&quot;https://www.cnblogs.com/w1570631036/p/8158284.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/w1570631036/p/8158284.html&lt;/a&gt;，感叹18年还算恢复了点。&lt;/p&gt;
&lt;h2 id=&quot;心惊胆战的裸辞经历&quot;&gt;心惊胆战的裸辞经历&lt;/h2&gt;
&lt;p&gt;其实校招过去的那家公司，真的不是很喜欢，996、技术差、产品差，实在受不了，春节前提出了离职，老大也挽留了下，以“来了个阿里的带我们重构，能学不了东西”来挽留，虽然我对技术比较痴迷，但离职去深圳的决心还是没有动摇，嗯，就这么开始了自己的裸辞过程。3月8号拿到离职，回公司的时候跟跟同事吹吹水，吃个饭，某同事还喊：“周末来公司玩玩么，我给你开门”，哈哈哈，泼出去的水，回不去了，偶尔有点伤感。&lt;br/&gt;去深圳面试，第一家随手记，之前超级想去这家公司的，金融这一块，有钱，只可惜，没过，一面面试官一直夸我，我觉得稳了，二面没转过来，就这么挂了，有点不甘心吧，在这，感谢那个内推我的人吧，&lt;a href=&quot;https://www.cnblogs.com/w1570631036/p/8549333.html&quot;&gt;面经在这&lt;/a&gt;，之后就是大大小小的面试，联想、恒大、期待金融什么的，都没拿到offer，裸辞真的慌得一比，一天没工作，感觉一年没有工作没人要的样子。。。。没面试就跑去广州图书馆，复习，反思，一天一天的过着，回家就去楼下吃烧烤，打游戏，2点3点才睡觉，boss直聘、拉勾网见一个问一个，迷迷糊糊慌慌张张，那段期间真的想有点把所有书卖掉回家啃老的想法，好在最后联系了一家公司，电商、大小周，知乎上全是差评，不过评价的都不是技术的，更重要的是，岗位是中间件的，嗯，去吧。&lt;/p&gt;
&lt;p&gt;and ... 广州拜拜，晚上人少的时候，跟妹纸去珠江新城真的很美好&lt;br/&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;http://image.wenzhihuai.com/images/2019011011294921712062.png&quot;/&gt;&lt;/div&gt;
&lt;h2 id=&quot;工作工作&quot;&gt;工作工作&lt;/h2&gt;
&lt;p&gt;入职的时候是做日志收集的，就是flume+kafka+es这一套，遇到了不少大佬，嗯，感觉挺好的，打算好好干，一个半月后不知怎么滴，被拉去做容器云了，然后就开始了天天调jenkins、gitlab这些没什么用的api，开始了增删改查的历程，很烦，研究jenkins、gitlab对于自己的技术没什么提升，又不得不做，而且大小周+加班这么做，回到家自己看java、netty、golang的书籍，可是没项目做没实践，过几个月就忘光了，有段时间真的很烦很烦，根本不想工作，天天调api，而且是jenkins、gitlab这些没什么卵用的api，至今也没找到什么办法。。。。&lt;br/&gt;公司发展太快，也实在让人不知所措，一不小心部门被架空了，什么预兆都没有，被分到其他部门，然后发现这个部门领导内斗真的是，“三国争霸”吧，无奈成为炮灰，不同的领导不同的要求，安安静静敲个代码怎么这么难。。。。&lt;br/&gt;去年的学习拉下了不少，文章也写的少了，总写那些入门的文章确实没有什么意思，买的书虽然没有17年的多吧，不过也不少了，也看了挺多本书的，虽然我还是不满意自己的阅读量。&lt;br/&gt;这几年要开始抓准一个框架了，好好专研一下，也要开始学习一下go了，希望能参与一些github的项目，好好努力吧。&lt;br/&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;http://image.wenzhihuai.com/images/201901130418261145369442.png&quot;/&gt;&lt;/div&gt;
&lt;h2 id=&quot;跑步跑步&quot;&gt;跑步跑步&lt;/h2&gt;
&lt;p&gt;平时没事总是宅在家里打游戏，差不多持续到下半年吧，那会打游戏去楼下吃东西的时候老是觉得眼神恍惚，盯着电子产品太多了，然后就跟别人跑步去了，每周去一次人才公园，跑步健身，人才公园真的是深圳跑步最好的一个地方了，桥上总有一群摄影师，好想在深圳湾买一套房子，看了看房价，算了算了，深圳的房，真的贵的离谱。19年也要多多运动，健康第一健康第一。&lt;br/&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://upyuncdn.wenzhihuai.com/201901130414532037038633.png&quot;/&gt;&lt;/div&gt;
&lt;h2 id=&quot;others&quot;&gt;Others&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;拿到了深圳户口，全程只花了15天，感谢学妹and家人&lt;/li&gt;
&lt;li&gt;买了第一台MacBook Pro，对于Java的我真心不好用&lt;/li&gt;
&lt;li&gt;盼了好几年的老姐结婚，18年终于了解了这心事&lt;/li&gt;
&lt;li&gt;养了只猫，在经历了好几个月的早起之后，晚上睡觉锁厨房，终于安分了，对不起了哈哈哈&lt;br/&gt;&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://upyuncdn.wenzhihuai.com/20190113103109865107434.png&quot;/&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;section&quot;&gt;2019&lt;/h2&gt;
&lt;p&gt;想不起来还有什么要说的了，毕竟程序员，好像每天的生活都一样，就展望一下19年吧。今年，最最重要的是家里人以及身边还有所有人都健健康康的，哈哈哈。然后是安安静静的敲代码~~就酱&lt;/p&gt;
</description>
<pubDate>Sun, 13 Jan 2019 14:49:00 +0000</pubDate>
<dc:creator>ZepheryWen</dc:creator>
<og:description>点点我的网站呗，好久没访问量了， 'http://www.wenzhihuai.com' 年底老姐结婚，跑回家去了，忙着一直没写，本来想回深圳的时候空余的时候写写，没想到一直加班，嗯，9点半下班那种，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/w1570631036/p/10263109.html</dc:identifier>
</item>
<item>
<title>Java运行时环境---内存划分 - 涛姐涛哥</title>
<link>http://www.cnblogs.com/taojietaoge/p/10264416.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/taojietaoge/p/10264416.html</guid>
<description>&lt;p&gt;&lt;strong&gt;背景&lt;/strong&gt;：听说Java运行时环境的内存划分是挺进BAT的必经之路。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;内存划分&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;  Java程序内存的划分是交由JVM执行的，而不像C语言那样需要程序员自己买单(C语言需要程序员为每一个new操作去配对delete/free代码)，放权给JVM虚拟机处理有利也有弊，好处是不容易出现内存泄漏和内存溢出问题，坏处就是自己的屁股不能自己擦，万一有一天JVM罢工不释放了，还是自个忘了释放，So了解虚拟机容易引起内存泄漏和溢出的场景对Java程序员来说还是必不可少的。【内存泄漏：Out Of Memmory，系统已经不能再分配空间了，好比你需要50M的空间，系统就只剩下40M；内存溢出：Memmory Leak，开辟了资源空间但用完后忘记释放，内存还在被占用，多次内存泄漏就会导致内存溢出；】了解JVM内存划分要端到端，先从Java程序执行的具体过程来看：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1580332/201901/1580332-20190113163519672-1217241998.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从图1中可以清楚看到Java程序的执行过程，大致就是Java源代码(后缀为.java)首先被Java编译器编译成字节码文件(后缀为.class)，然后交由JVM中的类加载器加载各个类的字节码文件，加载好字节码文件后再交由JVM引擎执行。在整个程序执行过程中，上图中运行时区域会用一段空间来存储程序执行期间需要用到的数据和相关信息，也就是我们弄懂内存划分要深度研究的区域，即JVM。&lt;/p&gt;
&lt;p&gt;运行时数据(内存)区：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1580332/201901/1580332-20190113163013389-2129282791.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图2中，梯形形状的部分是所有线程之间共享的区域，长方形形状的部分则是线程运行时独有的数据区域；《Java虚拟机规范》规定了运行时区域包括：程序计数器、Java栈(虚拟机线)、本地方法栈、方法区和堆五大部分。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1、程序计算器(Program Counter Register)&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;程序计算器又称为PC寄存器，这块内存区域相当小，它是当前线程所执行的字节码的行号指示器，字节码解释器通过改变这个计算器的值来选取下一条需要执行的字节码命令；在JVM中多线程是通过线程轮流切换来获得CPU执行时间的，So无论何种情况下一个CPU的内核只会执行一条线程中的指令，而为了保证每个线程都在线程切换后能够恢复到切换之前的程序执行位置，每个线程就必须要有自己独立的程序计数器，因此程序计数器是每个线程私有的；在JVM中，如果线程执行的是非native方法，则程序计数器中保存的是当前需要执行的指令的地址，而线程若是执行native方法则程序计数器中的值是undifined；因为程序计数器中存储的数据所占内存空间的多少不会随这程序的执行而改变，于是程序计数器不可能发生内存溢出OOM现象；&lt;/p&gt;
&lt;p&gt;特性：&lt;/p&gt;
&lt;p&gt;a. 是当前线程所执行的字节码的行号指示器；&lt;/p&gt;
&lt;p&gt;&lt;span&gt;b. 是当前线程私有的；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;c. 不会发生OOMError的错误；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、Java栈（虚拟机线Java stack）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;简单的说Java栈就是Java方法执行的内存模型。其内部存放的是一个个的栈帧，每个栈帧对应着一个被调用的方法；栈帧中包括局部变量表(Local Variables)、操作数栈(Operation Stack)、志向当前方法所属的类的运行时常量池的引用(Reference to runtime constant pool)、方法返回地址(Return Address)和一些额外的附加信息；由于每个线程正在执行的方法可能不同，因此每个线程都会有一个自己的互不干扰的Java栈；当当前线程执行了一个方法，随之就会创建一个与之对应的栈帧，并将建立的栈帧进行压栈操作，当方法执行完毕后便会将栈帧出栈；So线程当前执行的方法所对应的栈帧必定位于Java栈的顶部，即如队列的先进后出。&lt;span&gt;&lt;span&gt;&lt;span&gt;下图表示了一个Java栈的模型：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1580332/201901/1580332-20190113184759503-1636548031.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;局部变量：&lt;/p&gt;
&lt;p&gt;局部变量表就是用来存储方法中的局部变量(包括在方法中声明的非静态变量以及函数形参)；若变量是基本数据类型则直接存储它的值，若变量是引用类型则存储的是指向对象的引用；而局部变量表的大小在编译的时候就已经确定了，So程序执行期间其大小亦是不会改变的。&lt;/p&gt;
&lt;p&gt;操作数栈：&lt;/p&gt;
&lt;p&gt;操作数栈就是用于对表达式求值计算的，当个线程执行过程实际上就是不断执行语句的过程，也就是不断计算的过程，So程序中的所有计算过程都是通过操作数栈来完成的。&lt;/p&gt;
&lt;p&gt;指向运行时常量池的引用：&lt;/p&gt;
&lt;p&gt;指向运行时常量池的引用是由于在方法的执行过程中有可能需要用到类中的常量，因此必须要有一个引用指向运行时常量。&lt;/p&gt;
&lt;p&gt;方法返回地址：&lt;/p&gt;
&lt;p&gt;一个方法执行完毕后，要返回之前调用它的位置，于是在栈中就必须保存一个方法返回的地址。&lt;/p&gt;
&lt;p&gt;Java栈的生命周期和线程相似；在每个方法执行的同时都会创建一个栈帧，用于存储局部变量表、操作数栈、指向运行时常量池的引用和返回地址(方法出口)等信息，每个方法从调用到执行完毕的过程都对应着一个栈帧JVM中入栈到出栈到过程。(栈的大小与具体虚拟机的实现有关，一般在256～756之间)&lt;/p&gt;
&lt;p&gt;特性：&lt;/p&gt;
&lt;p&gt;a. 生命周期与线程相似且线程属于私有；&lt;/p&gt;
&lt;p&gt;b. 当线程请求的栈深度超过了JVM所允许的最大深度就会发生StackOverflowError异常；&lt;/p&gt;
&lt;p&gt;c. 若是栈的扩展无法申请到足够的内存则会产生OutOfMemmoryError异常；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、本地方法栈（Native Method Stack）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本地方法栈的原理和作用与Java栈类似，不同的是Java栈是为执行Java方法服务的，而本地方法栈是为执行本地方法服务的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4、堆(Heap)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Java中的堆事要来存储对象本身以及数组(数组引用存储在Java栈中)，Heap事JVM所管理的内存中最大的一块，它在虚拟机启动事创建且在JVM中只有一个堆；由于JVM垃圾收集器采用的基本都是分代收集算法，So堆还可以划分为Young Generation(年轻代)、Old Generation(年老代)以及Perm Generation(永久代)【JDK7之后，Hotspot虚拟机便将永久代这个概念移除了】，其中的Young Generation又分为Eden、From和To，而From和To又统称为Survivor Spaces(幸存区)；正常情况下，一个对象从创建到销毁，应该是从Eden开始，然后到Survivor Spaces，再到Old Generation，最后在某次GC下消失。&lt;/p&gt;
&lt;p&gt;特性：&lt;/p&gt;
&lt;p&gt;a. 堆是被所有线程共享的，且JVM中只有一个堆；&lt;/p&gt;
&lt;p&gt;b. 存储对象实例；&lt;/p&gt;
&lt;p&gt;c. 当在堆中没有完成实例的分配且无法再扩展内存则会有OutOfMemory异常；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5、方法区(Method Area)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;方法区主要用于存储每个类的信息(类的名称、方法信息、字段信息)、静态变量、常量和编译器编译后的代码等；此外，在Class文件中除了类的字段、方法和接口等描述外，还有常量池，用来存储编译期间生成的字面量和符号引用；在方法区中还有一个非常重要的部分就是运行时常量池，它是每一个类或接口的常量池的运行时表示形式，在类和接口被加载到JVM后对应的运行时常量池就被创建出来，非Class文件常量池的内容也可以将新的常量放入运行事常量池中，如String的intern方法(如果常量池中存在当前字符串就会直接返回当前字符串，若是常量池中无此字符串则会将其放入常量池中再返回)。&lt;/p&gt;
&lt;p&gt;在大概了解了Java运行时环境JVM内存的划分后，个人感觉要进入BAT还有必要了解下对象的创建和定位，这应该对自己写代码也有莫大的助力。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对象的创建&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;1、JVM接收到一条new指令后，首先会去检查这个指令的参数能否再常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化，如若没有，则会先执行类的初始化；&lt;/p&gt;
&lt;p&gt;2、类加载检查通过后，JVM会为新生对象分配内存，而对象所需内存大小在类加载完成后便可完全确定，随后就在Java堆中划分出一块确定大小的内存为对象分配空间；&lt;/p&gt;
&lt;p&gt;case1: 若内存是规整的，则JVM将采用指针碰撞发来为对象分配内存；指针碰撞发会将所有用过的内存放在一边，空闲的内存放置于另一边，中间放着一个指针作为分界点的指示器，分配内存的时候只需把指针向空闲内存的那边挪动一段与对象大小相等的距离；如果垃圾收集器选择的是Serial、ParNew这种基于压缩算法的机制，则虚拟机采用指针碰撞发分配内存；&lt;/p&gt;
&lt;p&gt;case2: 弱内存时不规整的，已使用的内存和未使用的内存相互交错，那么JVM采用的是空闲列表发来为对象分配内存；就是虚拟机维护了一个列表，记录下那些内存块是可用的，然后在分配内存的时候就从列表中找到一块足够大的空间划分给对象实例，并更新列表上维护的内容；若是垃圾回收器选择CMS这种基于标记-清除算法的机制，则JVM采用这种方式分配内存；&lt;/p&gt;
&lt;p&gt;case3: 在JVM中可能会出现虚拟机正在给对象A分配内存，但指针还没有来得及修改，此时对象B又同时使用了原来的指针来分配内存的情况；为了及时保证new对象时候线程的安全性，JVM采用了CAS配上失败重试的方式保证更新更新操作的原子性和TLAB两种方式来解决这个问题；&lt;/p&gt;
&lt;p&gt;3、分配内存结束后，JVM将分配到的内存空间都初始化为零值(不包括对象头【Object Header第一部是Mark Word用，于存储对象自身的运行时数据，第二部分是类型指针，用于确定这个对象是哪个类的实例】)；这一步保证了对象的实例字段在Java代码中可以不用赋值就能够直接使用，且程序能访问到这些字段的数据类型所对应的零值；&lt;/p&gt;
&lt;p&gt;4、对Object进行必要的设置，如该对象属于哪个类的实例、任何才能访问到类的元数据信息、对象的哈希值、对象的GC分代年龄等信息，这些信息存放在Object的对象头中；&lt;/p&gt;
&lt;p&gt;5、执行&amp;lt;int&amp;gt;方法，把对象按照程序猿的意愿进行初始化，这样一个真正可用的对象就完完全全的产生了。 &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对象的访问定位&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;在Java中需要通过栈上的reference(引用)数据来操作堆上具体对象；比如创建一个对象 String name = new String(); ，其中new String()其实有两部分，一部分是类数据(如代表类的Class对象)，另一部分则是实例数据；由于reference在JVM中只是一个指向对象new String()的引用name，并没有规定name应该通过何种方式去定位及访问Heap中对象的具体位置，So对象访问的最终方式还是由虚拟机决定的，目前主流方式有两种：&lt;/p&gt;
&lt;p&gt;case1: 指针访问，java堆对象的布局中必须考虑如何放置访问类型数据的相关信息，该访问方式下reference中存储的就是对象地址；&lt;/p&gt;
&lt;p&gt;case2: 句柄访问，java堆中将会划分出一块内存作为句柄池，此访问方式reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息；&lt;/p&gt;

</description>
<pubDate>Sun, 13 Jan 2019 14:46:00 +0000</pubDate>
<dc:creator>涛姐涛哥</dc:creator>
<og:description>背景：听说Java运行时环境的内存划分是挺进BAT的必经之路。 内存划分： Java程序内存的划分是交由JVM执行的，而不像C语言那样需要程序员自己买单(C语言需要程序员为每一个new操作去配对del</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/taojietaoge/p/10264416.html</dc:identifier>
</item>
<item>
<title>再见VB6！再见程序生涯！ - rayrain</title>
<link>http://www.cnblogs.com/rayrain/p/10264361.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/rayrain/p/10264361.html</guid>
<description>&lt;p&gt;今天写一篇博文告别使用了15年的VB6，从此终结程序生涯。记得读大学的时候第一学习编程，用VB6嵌入MediaPlayer控件写了一个简易视频播放器，看着视频的画面激动人心，从此就爱上了编程，从此也和VB6接下了不解之缘，大学毕业后进入国内某软件公司，直到去年离职一直在用VB6开发和维护大型ERP，在业界看来VB6太老了，廉颇老矣尚能饭否？然而真要尘封却有不舍。&lt;/p&gt;
&lt;p&gt;VB6是微软COM（组件对象模型）的成功典范，可以说VB6的成功代表了微软COM的胜利，然而自微软.NET战略推行以后，VB6却被无情地抛弃，意味着其推行的COM将逐步退出历史舞台，.NET平台中虽然保留了VB语言，但在国内大部分VB程序员看来其已成了鸡肋，在实际工作中不得不换成语言更接近C++的C#。随着.NET的更新换代，基于COM模型的各种组件仍然存在，然而由于VB6被彻底抛弃，用VC+ATL/MFC开发的OCX等COM组件似乎已无容身之处，放在.NET上去使用已非明智之举。虽然我的工作IDE已经换成了VS2017，然而仍然喜欢开个装有XP系统的虚拟机，里面装着简洁高效的VC6+VB6开发需要的东西，用VC6+ATL做底层，VB6做应用，已成为习惯。&lt;/p&gt;
&lt;p&gt;VB6是面向应用层面的，在桌面应用普及的时代，用其开发各种应用软件，包括各种大型的ERP系统，虽然其有许多的缺点被一些程序员所诟病，然而瑕不掩瑜，不足之处可以用VC来弥补，因此，在ERP系统中，涉及底层的东西我们就用高效的VC6+ATL来实现，应用层面的我们就用VB6来呈现，这样一个健壮的桌面应用系统就应运而生，只要Windows操作系统支持，用上30年也不会出问题，架构的牢固程序员日常也就只关心用户需求的业务转化。&lt;/p&gt;
&lt;p&gt;下面是日常工作中的一些模块测试程序，采用VC6+ATL做底层，采用VB6做界面，在Win10上工作得很好，运行效率很高，作为纪念张贴出来。希望某一天微软能把VB6开源吧，优秀的语言不应让其沉没！&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/46249/201901/46249-20190113221835497-350198815.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一个Skin模块测试，支持阴影透明调色，效果比GDI+做的DirectUI好，可运行在微软XP-Win10操作系统上，开发工具：VC6+ATL+VB6。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/46249/201901/46249-20190113222218360-1955826618.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/46249/201901/46249-20190113222235428-773951542.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一个音频播放器模块测试，底层采用VC6+ATL，频谱可调，频谱的呈现在底层实现，VB6传递一个窗口句柄即可。开发工具：VC6+ATL+VB6。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/46249/201901/46249-20190113222524741-1133425697.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一个Sqlite模块测试，查询速度很快，采用ADO方式封装，BUG可控，最近空闲将其更新为sqlite3.26.0最新版本。开发工具：VC6+ATL+VB6。&lt;/p&gt;
&lt;p&gt;... ...&lt;/p&gt;
&lt;p&gt; VB好吗？好。遗憾，这一切随着程序生涯的结束，已成为历史，再见！&lt;/p&gt;

</description>
<pubDate>Sun, 13 Jan 2019 14:32:00 +0000</pubDate>
<dc:creator>rayrain</dc:creator>
<og:description>今天写一篇博文告别使用了15年的VB6，从此终结程序生涯。记得读大学的时候第一学习编程，用VB6嵌入MediaPlayer控件写了一个简易视频播放器，看着视频的画面激动人心，从此就爱上了编程，从此也和</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/rayrain/p/10264361.html</dc:identifier>
</item>
<item>
<title>Spring Cloud实战之初级入门（四）— 利用Hystrix实现服务熔断与服务监控 - 隔壁老易</title>
<link>http://www.cnblogs.com/yb2020/p/10264331.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yb2020/p/10264331.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;

&lt;p&gt;本篇文章涉及到前面文章的工程，&lt;strong&gt;mirco-service-provider&lt;/strong&gt;、&lt;strong&gt;mirco-service-consumer&lt;/strong&gt;以及需要另外新建一个工程&lt;strong&gt;mirco-service-turbine-hystrix-dashbord&lt;/strong&gt;。&lt;/p&gt;

&lt;h2 id=&quot;加入依赖&quot;&gt;2.1 加入依赖&lt;/h2&gt;
&lt;p&gt;为“mirco-service-provider”工程的pom文件中加入&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-hystrix&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-hystrix-dashboard&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;修改配置文件&quot;&gt;2.2 修改配置文件&lt;/h2&gt;
&lt;p&gt;这里有点东西需要跟小伙伴们说明，因为上一篇文章&lt;a href=&quot;https://www.cnblogs.com/yb2020/p/10258687.html&quot;&gt;SpringCloud实战之初级入门（三）— spring cloud config搭建git配置中心&lt;/a&gt;中，我们将服务提供的工程配置文件上传到了github上，那么我们需要修改github上provider.yml，这是第一种方法。第二种方法是直接在bootstrap.yml中加入我们想要的配置，也是一样的生效，如果不明白我这里写了什么，可以看我的视频。我们这里介绍第一种方法：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;在工程目录打开命令行&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190111113352413.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3liMjAyMA==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/li&gt;
&lt;li&gt;使用vi provider.yml编辑配置文件&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2019011111371888.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3liMjAyMA==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/li&gt;
&lt;li&gt;保存配置文件&lt;/li&gt;
&lt;li&gt;使用&quot;git status&quot;查看我们工程中哪些文件进行了修改&lt;/li&gt;
&lt;li&gt;使用&quot;git add provider-test.yml&quot;加入本地仓库的提交列表&lt;/li&gt;
&lt;li&gt;使用&quot;git commit -m '提交说明'&quot;将要提交的文件提交到本地仓库&lt;/li&gt;
&lt;li&gt;使用&quot;git push origin master&quot;已经提交到本地仓库的文件上传至远程仓库。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;修改启动文件&quot;&gt;2.3 修改启动文件&lt;/h2&gt;
&lt;ol readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;在启动文件中加上&quot;@EnableHystrixDashboard 、@EnableCircuitBreaker&quot;注解，然后启动工程。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;打开浏览器访问http://localhost:7001/hystrix，可以看到如下图内容，说明服务调用的监控就搭建完成了。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190111114236493.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3liMjAyMA==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;监控服务&quot;&gt;2.4 监控服务&lt;/h2&gt;
&lt;p&gt;我在网络上看了一下，很多教程让你在输入框中输入http://localhost:8001/hystrix.stream然后点击下面的&quot;monitor stream&quot; 按钮基本上就完了，但是在我的环境里面是不行的，可能是spring cloud和spring boot的版本不一样。下面用步骤讲一下怎么做监控：&lt;/p&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;在浏览器的地址栏中输入http://localhost:8001/hystrix.stream是无法访问的，因为我们没有将“/hystrix.stream”这目录加入工程的访问目录。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;修改启动文件如下：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@EnableHystrixDashboard
@EnableCircuitBreaker
@EnableDiscoveryClient
@SpringBootApplication
public class MircoServiceProviderApplication {

    public static void main(String[] args) {
        SpringApplication.run(MircoServiceProviderApplication.class, args);
    }

    @Bean
    public ServletRegistrationBean&amp;lt;HystrixMetricsStreamServlet&amp;gt; getServlet() {
        HystrixMetricsStreamServlet hystrixMetricsStreamServlet = new HystrixMetricsStreamServlet() ;
        ServletRegistrationBean&amp;lt;HystrixMetricsStreamServlet&amp;gt; servletRegistrationBean = new ServletRegistrationBean&amp;lt;HystrixMetricsStreamServlet&amp;gt;() ;
        servletRegistrationBean.setServlet(hystrixMetricsStreamServlet);
        servletRegistrationBean.setLoadOnStartup(10);
        servletRegistrationBean.addUrlMappings(&quot;/hystrix.stream&quot;);
        servletRegistrationBean.setName(&quot;HystrixMetricsStreamServlet&quot;);
        return servletRegistrationBean ;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;4&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;重复第一个步骤，你会看到有一个ping一直在ping，其实就是在ping我们工程中hystrix默认给我们埋下的监控点，这也是为什么我们要用spring全家桶的原因之一，在其他的框架中像这样的事情，是需要我们自己去设计，开发的。而spring直接帮我们集成进来了，配置、配置就可以用了。效果如下：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190111115818569.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3liMjAyMA==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;我们再次访问http://localhost:8001/hystrix，监控http://localhost:8001/hystrix.stream这个地址，你会发现如图下界面，但是很不幸的告诉你，我们仍然看不到效果，为什么？卖个关子，请接着往下看。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190111122337699.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3liMjAyMA==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;请使用同样的方法将&quot;mrico-service-consumer&quot;工程改造，改造完后，我们访问http://localhost:8002/hystrix，输入http://localhost:8002/hystrix.stream这个地址进行监控，你会发现奇迹，但是一样看不到东西，这时候我们访问一下消费服务的接口http://localhost:8002/consumerHelloWorld?name=rose，然后再返回看一下监控页面，如果页面没有自动刷新，就手动刷一下页面，你就会看到效果了。这里面的英文是什么意思，请自行搜索，效果如下：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190111122735898.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3liMjAyMA==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;小结&quot;&gt;2.5 小结&lt;/h2&gt;
&lt;p&gt;经过上面的步骤，我们大致明白了一些问题：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;服务的整个监控是由spring cloud帮我们集成的，而且不需要我们写任何代码。&lt;/li&gt;
&lt;li&gt;对于服务监控，监控的是调用方，而不是服务提供方，我个人认为这也是一种思想，不用过度设计，比如你服务方和消费方都去监控。我相信在spring cloud没有出来之前应该有人这么做，但我尝试这种思想后过后觉得意义并不大。那么刚才我们讲的监控埋点，也是埋在了消费方的接口。对此有兴趣的小伙伴如果想知道更详细的内容，可以去百度一下。&lt;/li&gt;
&lt;li&gt;为什么我第二个视频&lt;a href=&quot;http://www.iqiyi.com/w_19s6cunjf1.html&quot;&gt;SpringCloud实战之初级入门（二）— 服务注册与服务调用&lt;/a&gt;会讲到说，在真实环境中像这种一个提供服务，一个提供调用的单向调用基本不存在，今天两个工程都加入了服务监控，大家也都看到了，第一个工程根本看不到任何东西，因为它没有调用其他的服务。&lt;/li&gt;
&lt;li&gt;为什么先讲服务的监控后讲熔断？因为你只有明白了监控是怎么一过程，你才能更好的了解熔断，因为熔断也是在消费方实现的。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;加入服务熔断&quot;&gt;3.1 加入服务熔断&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190111123440991.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3liMjAyMA==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;其实如果你在spring全家桶里面做集成，做这个熔断非常简单，接下来我们写MyFristConsumerHystrix这个类，如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Component
public class MyFristConsumerHystrix implements MyFristConsumer{
    @Override
    public String helloWorld(String name) {
        return &quot;server is closed , your send failed&quot;;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;测试服务熔断&quot;&gt;3.2 测试服务熔断&lt;/h2&gt;
&lt;ol readability=&quot;0&quot;&gt;&lt;li&gt;关掉服务提供工程&lt;/li&gt;
&lt;li&gt;访问调用接口，你会看如下结果：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190111123843965.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3liMjAyMA==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;查看监控，你就会发现图标变红了。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190111124124622.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3liMjAyMA==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;小结-1&quot;&gt;3.3 小结&lt;/h2&gt;
&lt;/li&gt;
&lt;li&gt;关于服务熔断，在真实使用中也不是说所有的服务都需要熔断，这个要根据实际情况来。&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;服务熔断的目的是为了避免微服务环境下，应用因为网络抖动或者服务异常的解决方案。如果应用长时间的服务异常，并且服务与服务之间依赖过多，就会引起“级联”效果，造成服务雪崩。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;创建工程&quot;&gt;4.1 创建工程&lt;/h2&gt;
&lt;p&gt;创建一个名称&quot;mirco-service-turbine-hystrix-dashboard&quot;的工程，在pom文件中要有以下依赖：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-eureka-client&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-hystrix-dashboard&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-hystrix&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-turbine&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为我们的服务都已经注册到了eureka上，所以只需要连上eureka，从eureka上找到需要监控的服务就可以了。&lt;/p&gt;
&lt;h2 id=&quot;修改配置文件-1&quot;&gt;4.2 修改配置文件&lt;/h2&gt;
&lt;p&gt;在application.yml文件中另入以下配置&lt;/p&gt;
&lt;pre class=&quot;yml&quot;&gt;
&lt;code&gt;spring.application.name: turbine-hystrix-dashboard
server.port: 6001

turbine:
  appConfig: service-provider,service-consumer
  clusterNameExpression: new String(&quot;default&quot;)
  instanceUrlSuffix: hystrix.stream
  aggregator:
    clusterConfig: default

eureka:
  client: 
    serviceUrl:
      defaultZone: http://localhost:9001/eureka/&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;修改启动文件-1&quot;&gt;4.3 修改启动文件&lt;/h2&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@EnableDiscoveryClient
@EnableTurbine
@EnableHystrixDashboard
@SpringBootApplication
public class MircoServiceTurbineHystrixDashboardApplication {

    public static void main(String[] args) {
        SpringApplication.run(MircoServiceTurbineHystrixDashboardApplication.class, args);
    }

    @Bean
    public ServletRegistrationBean&amp;lt;TurbineStreamServlet&amp;gt; getServlet() {
        TurbineStreamServlet streamServlet = new TurbineStreamServlet();
        ServletRegistrationBean&amp;lt;TurbineStreamServlet&amp;gt; registrationBean = new ServletRegistrationBean&amp;lt;TurbineStreamServlet&amp;gt;(streamServlet);
        registrationBean.setLoadOnStartup(1);
        registrationBean.addUrlMappings(&quot;/turbine.stream&quot;);
        registrationBean.setName(&quot;TurbineStreamServlet&quot;);
        return registrationBean;
    }     
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;启动&quot;&gt;4.4 启动&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;依次启动“mirco-service-config”、“mirco-service-eureka”、&quot;mirco-service-provider&quot;、&quot;mirco-service-consumer&quot;、“mirco-service-turbine-hystrix-dashboard”这五个工程&lt;/li&gt;
&lt;li&gt;访问http://localhost:8002/consumerHelloWorld?name=rose&lt;/li&gt;
&lt;li&gt;访问http://localhost:6001/hystrix，监控http://localhost:6001/turbine.stream，就可以看到刚才在&quot;mirco-service-consumer&quot;监控里面看到的内容了，如果你想看到多个服务，那么你写多几个服务，只要被调用过都可以看到，亲测可用。&lt;/li&gt;
&lt;/ol&gt;
</description>
<pubDate>Sun, 13 Jan 2019 14:30:00 +0000</pubDate>
<dc:creator>隔壁老易</dc:creator>
<og:description>[toc] 1.环境介绍 本篇文章涉及到前面文章的工程，mirco service provider、mirco service consumer以及需要另外新建一个工程mirco service t</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yb2020/p/10264331.html</dc:identifier>
</item>
<item>
<title>简简单单的Vue1（MVVM与Vue的双向绑定原理） - HANS许</title>
<link>http://www.cnblogs.com/xuhuale/p/10264259.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xuhuale/p/10264259.html</guid>
<description>&lt;li readability=&quot;3.5&quot;&gt;
&lt;p class=&quot;xsj_paragraph_level_4&quot;&gt;MVC&lt;br/&gt;要解决这个问题，我们就要先了解MVC，MVC 即 Model-View-Controller 的缩写，就是 模型-视图-控制器 , 也就是说一个标准的Web 应用程序是由这三部分组成的。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p class=&quot;xsj_paragraph_level_5&quot;&gt;View 用来把数据以某种方式呈现给用户。&lt;br/&gt;Model 其实就是数据。&lt;br/&gt;Controller 接收并处理来自用户的请求，并将 Model 返回给用户。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;&lt;li readability=&quot;11.5&quot;&gt;
&lt;p class=&quot;xsj_paragraph_level_4&quot;&gt;前端的工程化，MVC&lt;br/&gt;随着HTML5的流行，使得前后端分离成为了趋势。相对 HTML4 , HTML5 最大的亮点是它为移动设备提供了一些非常有用的功能，使得 HTML5 具备了开发App的能力, HTML5开发App 最大的好处就是&lt;strong&gt;跨平台、快速迭代和上线&lt;/strong&gt;，节省人力成本和提高效率。&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph_level_4&quot;&gt;既然要用H5 来构建 App, 那View 层所做的事，就不仅仅是简单的数据展示了，它不仅要管理复杂的数据状态，还要处理移动设备上各种操作行为等等。因此，&lt;strong&gt;前端也需要工程化&lt;/strong&gt;，也需要一个类似于MVC 的框架来管理这些复杂的逻辑，使开发更加高效。 但这里的 MVC 又稍微发了点变化：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p class=&quot;xsj_paragraph_level_5&quot;&gt;View UI布局，展示数据。&lt;br/&gt;Model 管理数据。&lt;br/&gt;Controller 响应用户操作，并将 Model 更新到 View 上。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p class=&quot;xsj_paragraph_level_4&quot;&gt;简单的前端工程化，出现问题？&lt;br/&gt;上面 MVC 架构模式对于简单的应用来看起是OK 的，也符合软件架构的分层思想。 但实际上，随着H5 的不断发展，人们更希望使用H5 开发的应用能和Native（原生程序编写的第三方应用） 媲美，或者接近于原生App 的体验效果，于是前端应用的复杂程度已不同往日，今非昔比。这时前端开发就暴露出了三个痛点问题：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;开发者在代码中大量调用相同的 DOM API, 处理繁琐 ，操作冗余，使得代码难以维护。&lt;/li&gt;
&lt;li&gt;大量的DOM 操作使页面渲染性能降低，加载速度变慢，影响用户体验。&lt;/li&gt;
&lt;li&gt;当 Model 频繁发生变化，开发者需要主动更新到View ；当用户的操作导致 Model 发生变化，开发者同样需要将变化的数据同步到Model 中，这样的工作不仅繁琐，而且很难维护复杂多变的数据状态。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li readability=&quot;13&quot;&gt;
&lt;p class=&quot;xsj_paragraph_level_4&quot;&gt;MVVM的解决&lt;br/&gt;MVVM 由 Model,View,ViewModel 三部分构成，Model 层代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑；View 代表UI 组件，它负责将数据模型转化成UI 展现出来，ViewModel 是一个同步View 和 Model的对象。&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph_level_4&quot;&gt;在MVVM架构下，View 和 Model 之间并没有直接的联系，而是通过ViewModel进行交互，Model 和 ViewModel 之间的交互是双向的， 因此View 数据的变化会同步到Model中，而Model 数据的变化也会立即反应到View 上。&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph_level_4&quot;&gt;ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。&lt;/p&gt;
&lt;/li&gt;
</description>
<pubDate>Sun, 13 Jan 2019 14:07:00 +0000</pubDate>
<dc:creator>HANS许</dc:creator>
<og:description>既然选择了远方，便只顾风雨兼程 __ HANS许 系列：零基础搭建前后端分离项目 系列：零基础搭建前后端分离项目 Vue 在此之前的文章我们讲述了前端开发的工具，语言的知识，接下来我们从头开始学习一个</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xuhuale/p/10264259.html</dc:identifier>
</item>
<item>
<title>《TCP IP 详解卷1：协议》阅读笔记 - 第一章 - 野兽'</title>
<link>http://www.cnblogs.com/ys-ys/p/10260357.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ys-ys/p/10260357.html</guid>
<description>&lt;p&gt;阅读须知：笔记为阅读《TCP IP 详解卷1：协议》后摘抄的一些知识点，其间也有加入一些根据英文原版的自己翻译和结合网上知识后的理解，所以有些段落之间并不能够串联上或者知识点与书上略有差别(基本差别不大，参考的资料属&lt;a href=&quot;https://www.ietf.org/standards/rfcs/&quot; target=&quot;_blank&quot;&gt;RFC官方文档&lt;/a&gt;)。&lt;/p&gt;

&lt;p&gt;第一章：概述&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Effective communication depends on the use of a common language.&lt;br/&gt;有效沟通取决于使用共同的语言 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;TCP/IP协议族&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;一系列相关协议的集合被称为一个协议族。指定一个协议族中的各种协议之间的相互关系并划分需要完成的任务的设计，称为协议族的体系结构或参考模型。而TCP/IP则是一个实现Internet体系结构的协议族，它来源于ARPANET参考模型。标准的TCP/IP实现来自加州大学伯克利分校计算机系统研究组(CSRG)，它们通过4.xBSD系统发布，直到20世纪90年代中期才出现BSD网络发布版。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;体系结构原则&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Internet体系结构在以下几个目标的指导下建立：&lt;/p&gt;
&lt;p&gt;　　· 发展一种重复利用已有的互联网络的技术(首要目标)；&lt;/p&gt;
&lt;p&gt;　　· Internet通信在网络或网关失效时必须能持续(二级目标)；&lt;/p&gt;
&lt;p&gt;　　· Internet必须支持多种类型的通信服务(二级目标)；&lt;/p&gt;
&lt;p&gt;　　· Internet体系结构必须兼容多种网络(二级目标);&lt;/p&gt;
&lt;p&gt;　　 · Internet体系结构必须允许对其资源的分布式管理(二级目标)；&lt;/p&gt;
&lt;p&gt;　　 · Internet体系结构必须是经济有效的(二级目标) ;&lt;/p&gt;
&lt;p&gt;　　· Internet体系结构必须允许低能力主机的连接(二级目标); &lt;/p&gt;
&lt;p&gt;　　· Internet中使用的资源必须是可统计的(二级目标)。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;简单的通信模型&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;早期的网络(电话网络)，针对一次通信中连接双方而设计，比如A和B通信，则A和B之间会建立一条线路(最初的物理电路)；且这条连接中会提供一定数量的带宽和容量用以传输信息。&lt;/p&gt;
&lt;p&gt;以传统问候语为例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/702891/201901/702891-20190112165148348-806137343.png&quot; alt=&quot;&quot; width=&quot;401&quot; height=&quot;66&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;分组交换思想&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;通信过程中以`分组`为单位来传输，使用存储-转发机制实现数据交互，这是分组交换。来自不同源的数据块组合成一个数据分组，在`处理设备`(交换机/路由器)接收到数组分组之后又可将其分解，称为多路复用。分组在到达目的地的过程中需要在交换设备之间传输，并且路径可以改变。&lt;/p&gt;
&lt;p&gt;这样做的好处是：&lt;/p&gt;
&lt;p&gt;　　1. 网络更具有弹性；&lt;/p&gt;
&lt;p&gt;　　2. 高效利用网络链路和交换设备提高传输效率。&lt;/p&gt;
&lt;p&gt;对于`处理设备`而言，最简单的分组处理调度方式符合`先到达先服务`规则，称为先进先出(FIFO)，这玩意也是Internet中用来处理不同来源的混合流量的主要方法。&lt;/p&gt;
&lt;p&gt;如图(摘自百度百科)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/702891/201901/702891-20190112165437216-804650806.jpg&quot; alt=&quot;&quot; width=&quot;507&quot; height=&quot;254&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;数据报&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;数据报是一个特定类型的分组，有关来源和最终目的地的所有识别信息都位于分组中。可用于建立一个无连接的网络，并且没必要使用复杂的信令协议。在数据报协议中存在消息边界，而在底层协议中并不保留消息边界，如果应用程序有需要它的情况，则须自行提供对应功能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;端到端论点和命运共享&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;端到端论点是影响TCP/IP协议族设计的重要原则之一，该原则认为重要功能(例如差错控制、加密、交付确认)通常不会在大型系统的低层实现。但是，低层可以提供方便端系统工作的功能，并最终可能改善性能。而选择哪些功能在同一计算机、网络或软件栈中实现，这是另一个称为命运共享的相关原则。&lt;/p&gt;
&lt;p&gt;命运共享是一种通过虚拟连接(例如,由TCP实现)维持活动的设计理念，它建议将所有必要的状态放在通信端点，这些状态用于维护一个活动的通信关联。&lt;/p&gt;
&lt;p&gt;上述两点均可理解为着重保证网络通信能力的健全。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;差错控制和流量控制&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;差错控制是指对网络中存在数据损坏或丢失的情况进行的处理措施；流量控制是指对网络数据流量进行控制的处理措施。它们与端到端论点一致(如TCP在端主机中实现速率控制)，也与命运共享一致(在网络基础设施中有些单元失效的情况下，不会影响网络设备的通信能力)。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;设计和实现&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;实现体系结构定义了协议体系结构中的概念如何用于软件形式的实现。通俗的理解，实现体系结构也就是：将软件的实现分为几个阶段(层次)，各个协议分别需要在软件的哪些地方(哪个阶段/层次)被使用。采用分层是有益的，它允许开发人员分别实现系统的不同部分，它们通常由在不同领域的专业人员完成。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;OSI模型(Open System Interconnection)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;比较基础也比较有名的OSI七层模型：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/702891/201901/702891-20190112170208468-2094594579.png&quot; alt=&quot;&quot; width=&quot;671&quot; height=&quot;342&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;基于OSI分层实现的数据封装&lt;/span&gt;&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/702891/201901/702891-20190112170242474-529449031.png&quot; alt=&quot;&quot; width=&quot;480&quot; height=&quot;322&quot;/&gt;&lt;/p&gt;
&lt;p&gt;每一层都有自己的消息对象概念(协议数据单元，PDU)，并且对于上一层(或下一层)的PDU不做解释(即图中被当做不透明数据)只管封装(或拆解)。在每一层，最常见的处理是在获得的PDU外增加自已的标识符信息，有些是增加在头部，有些协议是增加在尾部。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;TCP/IP协议族结构&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;TCP/IP协议分层&lt;/span&gt;&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/702891/201901/702891-20190112170341795-1318264874.png&quot; alt=&quot;&quot; width=&quot;580&quot; height=&quot;177&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;基于TCP/IP协议分层的数据封装&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/702891/201901/702891-20190112170441282-1156212973.png&quot; alt=&quot;&quot; width=&quot;573&quot; height=&quot;381&quot;/&gt;&lt;/p&gt;
&lt;p&gt;传入的数据经过一层层的剥离，每层分别除去自己层所需的数据报头部以决定数据报下一步该派发给哪个协议处理、或者做数据报错误检测等，最终成功后剩下数据给应用处理后反馈到用户。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;端口号&lt;/span&gt;&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;端口号是16位非负整数(0~65535)。每个IP地址有65536个可用的端口号，每个传输协议可使用这些端口号 (在大多数情况下)，它们被用于确定正确的接收数据的具体服务。标准的端口号由Internet号码分配机构(IANA)分配：包括熟知端口号(0~1023)；注册端口号(1024~49151)；动态/私有端口号(49152~65535)。&lt;/p&gt;
&lt;p&gt;熟知端口如安全外壳协议(SSH，端口22)、FTP (端口20和21)、Telnet远程终端协议(端口23)、电子邮件/简单邮件传输协议(SMTP，端口25)、域名系统(DNS，端口53)、超文本传输协议或Web(HTTP和HTTPS，端口80和443)、交互式邮件访问协议(IMAP和IMAPS，端口143和993)、简单网络管理协议 (SNMP，端口161和162)、轻量级目录访问协议(LDAP，端口389)。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;内联网、外联网&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Internet (因特网)已发展成为由很多网络互联起来的网络集合。小写字母开头的Internet表示使用常见协议族互联的多个网络；大写字母开头的Internet表示可使用 TCP/IP通信的世界范围的主机集合。&lt;/p&gt;
&lt;p&gt;内联网(内网)：通常由一个商业机构或其他企业来运行。大多数情况下，内联网提供的访问资源只供特定企业的成员使用，用户可使用虚拟专用网(VPN)连接到(例如企业)内联网，VPN有助于保证内联网中潜在的敏感资源只供授权用户访问，它通常使用隧道概念。&lt;/p&gt;
&lt;p&gt;外联网(外网)：一个企业或商业机构可能希望建立一个网络，其中包含可供合作伙伴或其他相关公司通过Internet访问的服务器，这种涉及VPN的网络通常被称为外联网，由连接在提供服务的企业防火墙之外的计算机组成 。&lt;/p&gt;
&lt;p&gt;内网外网的简单理解：由路由器区分，路由器以内是内网，路由器以外是外网；内网IP是内部自行分配的'身份认证'，外网是Internet网中对你的'身份认证'。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;设计应用&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;本文所述的网络概念提供了一个简单的服务模型：在运行于不同(或相同)计算机上的程序之间传输数据。然而提供该服务还需使用网络应用(服务的提供者)。 网络应用最常见的 模式是客户机/服务器模式和对等模式。&lt;/p&gt;
&lt;p&gt;客户机/服务器模式被设计为一端是客户机，而另一端是服务器。且服务器分为两类：迭代和并发。&lt;/p&gt;
&lt;p&gt;对等模式下没有专门的服务器。每个应用既是服务器又是客户端，有时又同时是两者。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;标准化进程&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;有了这些协议，也总得了解下是谁来负责各协议的制定和标准，以及它们如何运作。&lt;/p&gt;
&lt;p&gt;Internet工程任务组(IETF)：据说(书上说的，没参加过，2333)每年在世界不同地点举行3次会议，以便开发、讨论和通过Internet 的“核心”协议标准。&lt;/p&gt;
&lt;p&gt;Internet研究任务组(IRTF)：讨论那些没有成熟到足以形成标准的协议、体系结构和程序。&lt;/p&gt;
&lt;p&gt;RFC：Internet社会中的每个官方标准都以一个RFC (征求意见)的形式发布。不是所有RFC都是标准，只有标准跟踪类别的RFC被认为是官方标准。其他类别包括当前最佳实践(BCP)、信息、实验和历史。重要的是，一个文件成为一个RFC并不意味着IETF已采纳它作为标准。许多RFC具有特殊意义：它们总结、澄清或解释其他一些特殊标准。&lt;/p&gt;
&lt;p&gt;其他标准：一些重要的组织包括电气和电子工程师学会(IEEE)、万维网联盟(W3C) 以及国际电信联盟(ITU) 定义的协议同样值得注意。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;小结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在TCP/IP中,网络层和传输层之间的区别至关重要：网络层(IP)提供了一个不可靠的数据报服务，必须由Internet中所有可寻址的系统来实现，而传输层(TCP和UDP)为端主机上运行的应用程序提供了端到端服务。主要的传输层协议有根本性的差异：TCP提供了带流量控制和拥塞控制的有序、可靠的流交付；除了用于多路分解的端口号和错误检测机制之外，UDP提供的功能基本没有超越IP，但是与TCP不同，UDP支持组播交付。&lt;/p&gt;
&lt;p&gt;互联网络( intenret)是一个网络集合，其中最常见的基本设备是路由器，它被用于在IP层连接多个网络。&lt;/p&gt;

</description>
<pubDate>Sun, 13 Jan 2019 13:54:00 +0000</pubDate>
<dc:creator>野兽&amp;#39;</dc:creator>
<og:description>阅读须知：笔记为阅读《TCP IP 详解卷1：协议》后摘抄的一些知识点，其间也有加入一些根据英文原版的自己翻译和结合网上知识后的理解，所以有些段落之间并不能够串联上或者知识点与书上略有差别(基本差别不</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ys-ys/p/10260357.html</dc:identifier>
</item>
<item>
<title>【Go】深入剖析slice和array - 戚银</title>
<link>http://www.cnblogs.com/thinkeridea/p/10264195.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/thinkeridea/p/10264195.html</guid>
<description>&lt;p&gt;&lt;code&gt;array&lt;/code&gt; 和 &lt;code&gt;slice&lt;/code&gt; 看似相似，却有着极大的不同，但他们之间还有着千次万缕的联系 &lt;code&gt;slice&lt;/code&gt; 是引用类型、是 &lt;code&gt;array&lt;/code&gt; 的引用，相当于动态数组，&lt;br/&gt;这些都是 &lt;code&gt;slice&lt;/code&gt; 的特性，但是 &lt;code&gt;slice&lt;/code&gt; 底层如何表现，内存中是如何分配的，特别是在程序中大量使用 &lt;code&gt;slice&lt;/code&gt; 的情况下，怎样可以高效使用 &lt;code&gt;slice&lt;/code&gt;？&lt;br/&gt;今天借助 &lt;code&gt;Go&lt;/code&gt; 的 &lt;code&gt;unsafe&lt;/code&gt; 包来探索 &lt;code&gt;array&lt;/code&gt; 和 &lt;code&gt;slice&lt;/code&gt; 的各种奥妙。&lt;/p&gt;
&lt;h2 id=&quot;数组&quot;&gt;数组&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;slice&lt;/code&gt; 是在 &lt;code&gt;array&lt;/code&gt; 的基础上实现的，需要先详细了解一下数组。&lt;/p&gt;
&lt;p&gt;** 维基上如此介绍数组：**&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;在计算机科学中，数组数据结构（英语：array data structure），简称数组（英语：Array），是由相同类型的元素（element）的集合所组成的数据结构，分配一块连续的内存来存储，利用元素的索引（index）可以计算出该元素对应的存储地址。&lt;br/&gt;** 数组设计之初是在形式上依赖内存分配而成的，所以必须在使用前预先请求空间。这使得数组有以下特性：**&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;请求空间以后大小固定，不能再改变（数据溢出问题）；&lt;/li&gt;
&lt;li&gt;在内存中有空间连续性的表现，中间不会存在其他程序需要调用的数据，为此数组的专用内存空间；&lt;/li&gt;
&lt;li&gt;在旧式编程语言中（如有中阶语言之称的C），程序不会对数组的操作做下界判断，也就有潜在的越界操作的风险（比如会把数据写在运行中程序需要调用的核心部分的内存上）。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;根据维基的介绍，了解到数组是存储在一段连续的内存中，每个元素的类型相同，即是每个元素的宽度相同，可以根据元素的宽度计算元素存储的位置。&lt;br/&gt;通过这段介绍总结一下数组有一下特性：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;分配在连续的内存地址上&lt;/li&gt;
&lt;li&gt;元素类型一致，元素存储宽度一致&lt;/li&gt;
&lt;li&gt;空间大小固定，不能修改&lt;/li&gt;
&lt;li&gt;可以通过索引计算出元素对应存储的位置（只需要知道数组内存的起始位置和数据元素宽度即可）&lt;/li&gt;
&lt;li&gt;会出现数据溢出的问题（下标越界）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;Go&lt;/code&gt; 中的数组如何实现的呢，恰恰就是这么实现的，实际上几乎所有计算机语言，数组的实现都是相似的，也拥有上面总结的特性。&lt;br/&gt;&lt;code&gt;Go&lt;/code&gt; 语言的数组不同于 &lt;code&gt;C&lt;/code&gt; 语言或者其他语言的数组，&lt;code&gt;C&lt;/code&gt; 语言的数组变量是指向数组第一个元素的指针；&lt;br/&gt;而 &lt;code&gt;Go&lt;/code&gt; 语言的数组是一个值，&lt;code&gt;Go&lt;/code&gt; 语言中的数组是值类型，一个数组变量就表示着整个数组，意味着 &lt;code&gt;Go&lt;/code&gt; 语言的数组在传递的时候，传递的是原数组的拷贝。&lt;/p&gt;
&lt;p&gt;在程序中数组的初始化有两种方法 &lt;code&gt;arr := [10]int{}&lt;/code&gt; 或 &lt;code&gt;var arr [10]int&lt;/code&gt;，但是不能使用 &lt;code&gt;make&lt;/code&gt; 来创建，数组这节结束时再探讨一下这个问题。&lt;br/&gt;使用 &lt;code&gt;unsafe&lt;/code&gt;来看一下在内存中都是如何存储的吧：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;package main

import (
    &quot;fmt&quot;
    &quot;unsafe&quot;
)

func main() {
    var arr = [3]int{1, 2, 3}

    fmt.Println(unsafe.Sizeof(arr))
    size := unsafe.Sizeof(arr[0])

    // 获取数组指定索引元素的值
    fmt.Println(*(*int)(unsafe.Pointer(uintptr(unsafe.Pointer(&amp;amp;arr[0])) + 1*size)))

    // 设置数组指定索引元素的值
    *(*int)(unsafe.Pointer(uintptr(unsafe.Pointer(&amp;amp;arr[0])) + 1*size)) = 10

    fmt.Println(arr[1])
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段代码的输出如下 (&lt;a href=&quot;https://play.golang.org/p/3v-rAQZG-E6&quot;&gt;Go Playground&lt;/a&gt;)：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;12&lt;br/&gt;2&lt;br/&gt;10&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;首先说 &lt;code&gt;12&lt;/code&gt; 是 &lt;code&gt;fmt.Println(unsafe.Sizeof(arr))&lt;/code&gt; 输出的，&lt;code&gt;unsafe.Sizeof&lt;/code&gt; 用来计算当前变量的值在内存中的大小，&lt;code&gt;12&lt;/code&gt; 这个代表一个 &lt;code&gt;int&lt;/code&gt; 有4个字节，&lt;code&gt;3 * 4&lt;/code&gt; 就是 &lt;code&gt;12&lt;/code&gt;。&lt;br/&gt;这是在32位平台上运行得出的结果， 如果在64位平台上运行数组的大小是 &lt;code&gt;24&lt;/code&gt;。从这里可以看出 &lt;code&gt;[3]int&lt;/code&gt; 在内存中由3个连续的 &lt;code&gt;int&lt;/code&gt; 类型组成，且有 &lt;code&gt;12&lt;/code&gt; 个字节那么长，这就说明了数组在内存中没有存储多余的数据，只存储元素本身。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;size := unsafe.Sizeof(arr[0])&lt;/code&gt; 用来计算单个元素的宽度，&lt;code&gt;int&lt;/code&gt;在32位平台上就是4个字节，&lt;code&gt;uintptr(unsafe.Pointer(&amp;amp;arr[0]))&lt;/code&gt; 用来计算数组起始位置的指针，&lt;code&gt;1*size&lt;/code&gt; 用来获取索引为1的元素相对数组起始位置的偏移，&lt;code&gt;unsafe.Pointer(uintptr(unsafe.Pointer(&amp;amp;arr[0])) + 1*size))&lt;/code&gt; 获取索引为1的元素指针，&lt;code&gt;*(*int)&lt;/code&gt; 用来转换指针位置的数据类型， 因为 &lt;code&gt;int&lt;/code&gt; 是4个字节，所以只会读取4个字节的数据，由元素类型限制数据宽度，来确定元素的结束位置，因此得到的结果是 &lt;code&gt;2&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;上一个步骤获取元素的值，其中先获取了元素的指针，赋值的时候只需要对这个指针位置设置值就可以了， &lt;code&gt;*(*int)(unsafe.Pointer(uintptr(unsafe.Pointer(&amp;amp;arr[0])) + 1*size)) = 10&lt;/code&gt; 就是用来给指定下标元素赋值。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1572234/201901/1572234-20190113214719442-2111027594.jpg&quot; alt=&quot;数组在内存中的结构&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;package main

import (
    &quot;fmt&quot;
    &quot;unsafe&quot;
)

func main() {
    n:= 10
    var arr = [n]int{}
    fmt.Println(arr)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如上代码，动态的给数组设定长度，会导致编译错误 &lt;code&gt;non-constant array bound n&lt;/code&gt;， 由此推导数组的所有操作都是编译时完成的，会转成对应的指令，通过这个特性知道数组的长度是数组类型不可或缺的一部分，并且必须在编写程序时确定。&lt;br/&gt;可以通过 &lt;code&gt;GOOS=linux GOARCH=amd64 go tool compile -S array.go&lt;/code&gt; 来获取对应的汇编代码，在 &lt;code&gt;array.go&lt;/code&gt; 中做一些数组相关的操作，查看转换对应的指令。&lt;/p&gt;
&lt;p&gt;之前的疑问，为什么数组不能用 &lt;code&gt;make&lt;/code&gt; 创建？ 上面分析了解到数组操作是在编译时转换成对应指令的，而 &lt;code&gt;make&lt;/code&gt; 是在运行时处理（特殊状态下会做编译器优化，make可以被优化，下面 &lt;code&gt;slice&lt;/code&gt; 分析时来讲）。&lt;/p&gt;
&lt;h2 id=&quot;slice&quot;&gt;slice&lt;/h2&gt;
&lt;p&gt;因为数组是固定长度且是值传递，很不灵活，所以在 &lt;code&gt;Go&lt;/code&gt; 程序中很少看到数组的影子。然而 &lt;code&gt;slice&lt;/code&gt; 无处不在，&lt;code&gt;slice&lt;/code&gt; 以数组为基础，提供强大的功能和遍历性。&lt;br/&gt;&lt;code&gt;slice&lt;/code&gt; 的类型规范是[]T，&lt;code&gt;slice&lt;/code&gt; T元素的类型。与数组类型不同，&lt;code&gt;slice&lt;/code&gt; 类型没有指定的长度。&lt;/p&gt;
&lt;p&gt;** &lt;code&gt;slice&lt;/code&gt; 申明的几种方法：**&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;code&gt;s := []int{1, 2, 3}&lt;/code&gt; 简短的赋值语句&lt;br/&gt;&lt;code&gt;var s []int&lt;/code&gt; &lt;code&gt;var&lt;/code&gt; 申明&lt;br/&gt;&lt;code&gt;make([]int, 3, 8)&lt;/code&gt; 或 &lt;code&gt;make([]int, 3)&lt;/code&gt; &lt;code&gt;make&lt;/code&gt; 内置方法创建&lt;br/&gt;&lt;code&gt;s := ss[:5]&lt;/code&gt; 从切片或者数组创建&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;** &lt;code&gt;slice&lt;/code&gt; 有两个内置函数来获取其属性：**&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code&gt;len&lt;/code&gt; 获取 &lt;code&gt;slice&lt;/code&gt; 的长度&lt;br/&gt;&lt;code&gt;cap&lt;/code&gt; 获取 &lt;code&gt;slice&lt;/code&gt; 的容量&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;slice&lt;/code&gt; 的属性，这东西是什么，还需借助 &lt;code&gt;unsafe&lt;/code&gt; 来探究一下。&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;package main

import (
    &quot;fmt&quot;
    &quot;unsafe&quot;
)

func main() {
    s := make([]int, 10, 20)

    s[2] = 100
    s[9] = 200

    size := unsafe.Sizeof(0)
    fmt.Printf(&quot;%x\n&quot;, *(*uintptr)(unsafe.Pointer(&amp;amp;s)))
    fmt.Println(*(*int)(unsafe.Pointer(uintptr(unsafe.Pointer(&amp;amp;s)) + size)))
    fmt.Println(*(*int)(unsafe.Pointer(uintptr(unsafe.Pointer(&amp;amp;s)) + size*2)))

    fmt.Println(*(*[20]int)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(&amp;amp;s)))))
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段代码的输出如下 (&lt;a href=&quot;https://play.golang.org/p/Z_TMWD53syD&quot;&gt;Go Playground&lt;/a&gt;)：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;c00007ce90&lt;br/&gt;10&lt;br/&gt;20&lt;br/&gt;[0 0 100 0 0 0 0 0 0 200 0 0 0 0 0 0 0 0 0 0]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这段输出除了第一个，剩余三个好像都能看出点什么， &lt;code&gt;10&lt;/code&gt; 不是创建 &lt;code&gt;slice&lt;/code&gt; 的长度吗，&lt;code&gt;20&lt;/code&gt; 不就是指定的容量吗， 最后这个看起来有点像 &lt;code&gt;slice&lt;/code&gt; 里面的数据，但是数量貌似有点多，从第三个元素和第十个元素来看，正好是给 &lt;code&gt;slice&lt;/code&gt; 索引 &lt;code&gt;2&lt;/code&gt; 和 &lt;code&gt;10&lt;/code&gt; 指定的值，但是切片不是长度是 &lt;code&gt;10&lt;/code&gt; 个吗，难道这个是容量，容量刚好是 &lt;code&gt;20&lt;/code&gt;个。&lt;/p&gt;
&lt;p&gt;第二和第三个输出很好弄明白，就是 &lt;code&gt;slice&lt;/code&gt; 的长度和容量， 最后一个其实是 &lt;code&gt;slice&lt;/code&gt; 引用底层数组的数据，因为创建容量为 &lt;code&gt;20&lt;/code&gt;，所以底层数组的长度就是 &lt;code&gt;20&lt;/code&gt;，从这里了解到切片是引用底层数组上的一段数据，底层数组的长度就是 &lt;code&gt;slice&lt;/code&gt; 的容量，由于数组长度不可变的特性，当 &lt;code&gt;slice&lt;/code&gt; 的长度达到容量大小之后就需要考虑扩容，不是说数组长度不能变吗，那 &lt;code&gt;slice&lt;/code&gt; 怎么实现扩容呢， 其实就是在内存上分配一个更大的数组，把当前数组上的内容拷贝到新的数组上， &lt;code&gt;slice&lt;/code&gt; 来引用新的数组，这样就实现扩容了。&lt;/p&gt;
&lt;p&gt;说了这么多，还是没有看出来 &lt;code&gt;slice&lt;/code&gt; 是如何引用数组的，额…… 之前的程序还有一个输出没有搞懂是什么，难道这个就是底层数组的引用。&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;package main

import (
    &quot;fmt&quot;
    &quot;unsafe&quot;
)

func main() {
    arr := [10]int{1, 2, 3}
    arr[7] = 100
    arr[9] = 200

    fmt.Println(arr)

    s1 := arr[:]
    s2 := arr[2:8]

    size := unsafe.Sizeof(0)
    fmt.Println(&quot;----------s1---------&quot;)
    fmt.Printf(&quot;%x\n&quot;, *(*uintptr)(unsafe.Pointer(&amp;amp;s1)))
    fmt.Printf(&quot;%x\n&quot;, uintptr(unsafe.Pointer(&amp;amp;arr[0])))

    fmt.Println(*(*int)(unsafe.Pointer(uintptr(unsafe.Pointer(&amp;amp;s1)) + size)))
    fmt.Println(*(*int)(unsafe.Pointer(uintptr(unsafe.Pointer(&amp;amp;s1)) + size*2)))

    fmt.Println(s1)
    fmt.Println(*(*[10]int)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(&amp;amp;s1)))))

    fmt.Println(&quot;----------s2---------&quot;)
    fmt.Printf(&quot;%x\n&quot;, *(*uintptr)(unsafe.Pointer(&amp;amp;s2)))
    fmt.Printf(&quot;%x\n&quot;, uintptr(unsafe.Pointer(&amp;amp;arr[0]))+size*2)

    fmt.Println(*(*int)(unsafe.Pointer(uintptr(unsafe.Pointer(&amp;amp;s2)) + size)))
    fmt.Println(*(*int)(unsafe.Pointer(uintptr(unsafe.Pointer(&amp;amp;s2)) + size*2)))

    fmt.Println(s2)
    fmt.Println(*(*[8]int)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(&amp;amp;s2)))))
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上代码输出如下(&lt;a href=&quot;https://play.golang.org/p/4KgHvKClbzZ&quot;&gt;Go Playground&lt;/a&gt;)：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;[1 2 3 0 0 0 0 100 0 200]&lt;br/&gt;----------s1---------&lt;br/&gt;c00001c0a0&lt;br/&gt;c00001c0a0&lt;br/&gt;10&lt;br/&gt;10&lt;br/&gt;[1 2 3 0 0 0 0 100 0 200]&lt;br/&gt;[1 2 3 0 0 0 0 100 0 200]&lt;br/&gt;----------s2---------&lt;br/&gt;c00001c0b0&lt;br/&gt;c00001c0b0&lt;br/&gt;6&lt;br/&gt;8&lt;br/&gt;[3 0 0 0 0 100]&lt;br/&gt;[3 0 0 0 0 100 0 200]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这段输出看起来有点小复杂，第一行输出就不用说了吧，这个是打印整个数组的数据。先分析一下 &lt;code&gt;s1&lt;/code&gt; 变量的下面的输出吧，&lt;code&gt;s1 := arr[:]&lt;/code&gt; 引用了整个数组，所以在第5、6行输出都是10，因为数组长度为10，所有 &lt;code&gt;s1&lt;/code&gt; 的长度和容量都为10，那第3、4行输出是什么呢，他们怎么都一样呢，之前分析数组的时候 通过 &lt;code&gt;uintptr(unsafe.Pointer(&amp;amp;arr[0]))&lt;/code&gt; 来获取数组起始位置的指针的，那么第4行打印的就是数组的指针，这么就了解了第三行输出的是上面了吧，就是数组起始位置的指针，所以 &lt;code&gt;*(*uintptr)(unsafe.Pointer(&amp;amp;s1))&lt;/code&gt; 获取的就是引用数组的指针，但是这个并不是数组起始位置的指针，而是 &lt;code&gt;slice&lt;/code&gt; 引用数组元素的指针，为什么这么说呢？&lt;/p&gt;
&lt;p&gt;接着看 &lt;code&gt;s2&lt;/code&gt; 变量下面的输出吧，&lt;code&gt;s2 := arr[2:8]&lt;/code&gt; 引用数组第3~8的元素，那么 &lt;code&gt;s2&lt;/code&gt; 的长度就是 6。 根据经验可以知道 &lt;code&gt;s2&lt;/code&gt; 变量输出下面第3行就是 &lt;code&gt;slice&lt;/code&gt; 的长度，但是为啥第4行是 &lt;code&gt;8&lt;/code&gt; 呢，&lt;code&gt;slice&lt;/code&gt; 应用数组的指定索引起始位置到数组结尾就是 &lt;code&gt;slice&lt;/code&gt; 的容量， 所以 所以从第3个位置到末尾，就是8个容量。在看第1行和第2行的输出，之前分析数组的时候通过 &lt;code&gt;uintptr(unsafe.Pointer(&amp;amp;arr[0]))+size*2&lt;/code&gt; 来获取数组指定索引位置的指针，那么这段第2行就是数组索引为2的元素指针，&lt;code&gt;*(*uintptr)(unsafe.Pointer(&amp;amp;s2))&lt;/code&gt; 是获取切片的指针，第1行和第2行输出一致，所以 &lt;code&gt;slice&lt;/code&gt; 实际是引用数组元素位置的指针，并不是数组起始位置的指针。&lt;/p&gt;
&lt;p&gt;** 总结：**&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;slice&lt;/code&gt; 是的起始位置是引用数组元素位置的指针。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;slice&lt;/code&gt; 的长度是引用数组元素起始位置到结束位置的长度。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;slice&lt;/code&gt; 的容量是引用数组元素起始位置到数组末尾的长度。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;经过上面一轮分析了解到 &lt;code&gt;slice&lt;/code&gt; 有三个属性，引用数组元素位置指针、长度和容量。实际上 &lt;code&gt;slice&lt;/code&gt; 的结构像下图一样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1572234/201901/1572234-20190113214746768-1924486876.jpg&quot; alt=&quot;slice&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;slice-增长&quot;&gt;slice 增长&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;slice&lt;/code&gt; 是如何增长的，用 &lt;code&gt;unsafe&lt;/code&gt; 分析一下看看：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;package main

import (
    &quot;fmt&quot;
    &quot;unsafe&quot;
)

func main() {
    s := make([]int, 9, 10)

    // 引用底层的数组地址
    fmt.Printf(&quot;%x\n&quot;, *(*uintptr)(unsafe.Pointer(&amp;amp;s)))

    s = append(s, 1)

    // 引用底层的数组地址
    fmt.Printf(&quot;%x\n&quot;, *(*uintptr)(unsafe.Pointer(&amp;amp;s)))

    s = append(s, 1)

    // 引用底层的数组地址
    fmt.Printf(&quot;%x\n&quot;, *(*uintptr)(unsafe.Pointer(&amp;amp;s)))
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上代码的输出(&lt;a href=&quot;https://play.golang.org/p/3c4ek4-0ft5&quot;&gt;Go Playground&lt;/a&gt;):&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;c000082e90&lt;br/&gt;9 10&lt;br/&gt;c000082e90&lt;br/&gt;10 10&lt;br/&gt;c00009a000&lt;br/&gt;11 20&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;从结果上看前两次地址是一样的，初始化一个长度为9，容量为10的 &lt;code&gt;slice&lt;/code&gt;，当第一次 &lt;code&gt;append&lt;/code&gt; 的时候容量是足够的，所以底层引用数组地址未发生变化，此时 &lt;code&gt;slice&lt;/code&gt; 的长度和容量都为10，之后再次 &lt;code&gt;append&lt;/code&gt; 的时候发现底层数组的地址不一样了，因为 &lt;code&gt;slice&lt;/code&gt; 的长度超过了容量，但是新的 &lt;code&gt;slice&lt;/code&gt; 容量并不是11而是20，这要说 &lt;code&gt;slice&lt;/code&gt; 的机制了，因为数组长度不可变，想扩容 &lt;code&gt;slice&lt;/code&gt;就必须分配一个更大的数组，并把之前的数据拷贝到新数组，如果一次只增加1个长度，那就会那发生大量的内存分配和数据拷贝，这个成本是很大的，所以 &lt;code&gt;slice&lt;/code&gt; 是有一个增长策略的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Go&lt;/code&gt; 标准库 &lt;code&gt;runtime/slice.go&lt;/code&gt; 当中有详细的 &lt;code&gt;slice&lt;/code&gt; 增长策略的逻辑：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func growslice(et *_type, old slice, cap int) slice {
    .....
    
    // 计算新的容量，核心算法用来决定slice容量增长
    newcap := old.cap
    doublecap := newcap + newcap
    if cap &amp;gt; doublecap {
        newcap = cap
    } else {
        if old.len &amp;lt; 1024 {
            newcap = doublecap
        } else {
            for 0 &amp;lt; newcap &amp;amp;&amp;amp; newcap &amp;lt; cap {
                newcap += newcap / 4
            }
            if newcap &amp;lt;= 0 {
                newcap = cap
            }
        }
    }

    // 根据et.size调整新的容量
    var overflow bool
    var lenmem, newlenmem, capmem uintptr
    switch {
    case et.size == 1:
        lenmem = uintptr(old.len)
        newlenmem = uintptr(cap)
        capmem = roundupsize(uintptr(newcap))
        overflow = uintptr(newcap) &amp;gt; maxAlloc
        newcap = int(capmem)
    case et.size == sys.PtrSize:
        lenmem = uintptr(old.len) * sys.PtrSize
        newlenmem = uintptr(cap) * sys.PtrSize
        capmem = roundupsize(uintptr(newcap) * sys.PtrSize)
        overflow = uintptr(newcap) &amp;gt; maxAlloc/sys.PtrSize
        newcap = int(capmem / sys.PtrSize)
    case isPowerOfTwo(et.size):
        var shift uintptr
        if sys.PtrSize == 8 {
            // Mask shift for better code generation.
            shift = uintptr(sys.Ctz64(uint64(et.size))) &amp;amp; 63
        } else {
            shift = uintptr(sys.Ctz32(uint32(et.size))) &amp;amp; 31
        }
        lenmem = uintptr(old.len) &amp;lt;&amp;lt; shift
        newlenmem = uintptr(cap) &amp;lt;&amp;lt; shift
        capmem = roundupsize(uintptr(newcap) &amp;lt;&amp;lt; shift)
        overflow = uintptr(newcap) &amp;gt; (maxAlloc &amp;gt;&amp;gt; shift)
        newcap = int(capmem &amp;gt;&amp;gt; shift)
    default:
        lenmem = uintptr(old.len) * et.size
        newlenmem = uintptr(cap) * et.size
        capmem = roundupsize(uintptr(newcap) * et.size)
        overflow = uintptr(newcap) &amp;gt; maxSliceCap(et.size)
        newcap = int(capmem / et.size)
    }

    ......
    
    var p unsafe.Pointer
    if et.kind&amp;amp;kindNoPointers != 0 {
        p = mallocgc(capmem, nil, false)  // 分配新的内存
        memmove(p, old.array, lenmem) // 拷贝数据
        memclrNoHeapPointers(add(p, newlenmem), capmem-newlenmem)
    } else {
        p = mallocgc(capmem, et, true) // 分配新的内存
        if !writeBarrier.enabled {
            memmove(p, old.array, lenmem)
        } else {
            for i := uintptr(0); i &amp;lt; lenmem; i += et.size {
                typedmemmove(et, add(p, i), add(old.array, i)) // 拷贝数据
            }
        }
    }

    return slice{p, old.len, newcap} // 新slice引用新的数组，长度为旧数组的长度，容量为新数组的容量
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;基本呢就三个步骤，计算新的容量、分配新的数组、拷贝数据到新数组，社区很多人分享 &lt;code&gt;slice&lt;/code&gt; 的增长方法，实际都不是很精确，因为大家只分析了计算 &lt;code&gt;newcap&lt;/code&gt; 的那一段，也就是上面注释的第一部分，下面的 &lt;code&gt;switch&lt;/code&gt; 根据 &lt;code&gt;et.size&lt;/code&gt; 来调整 &lt;code&gt;newcap&lt;/code&gt; 一段被直接忽略，社区的结论是：&quot;如果 &lt;code&gt;selic&lt;/code&gt; 的容量小于1024个元素，那么扩容的时候 &lt;code&gt;slice&lt;/code&gt; 的 &lt;code&gt;cap&lt;/code&gt; 就翻番，乘以2；一旦元素个数超过1024个元素，增长因子就变成1.25，即每次增加原来容量的四分之一&quot; 大多数情况也确实如此，但是根据 &lt;code&gt;newcap&lt;/code&gt; 的计算规则，如果新的容量超过旧的容量2倍时会直接按新的容量分配，真的是这样吗?&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;package main

import (
    &quot;fmt&quot;
)

func main() {
    s := make([]int, 10, 10)
    fmt.Println(len(s), cap(s))
    s2 := make([]int, 40)

    s = append(s, s2...)
    fmt.Println(len(s), cap(s))

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上代码的输出(&lt;a href=&quot;https://play.golang.org/p/x8kN4V5R7YW&quot;&gt;Go Playground&lt;/a&gt;):&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;10 10&lt;br/&gt;50 52&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个结果有点出人意料， 如果是2倍增长应该是 &lt;code&gt;10 * 2 * 2 * 2&lt;/code&gt; 结果应该是80， 如果说新的容量高于旧容量的两倍但结果也不是50，实际上 &lt;code&gt;newcap&lt;/code&gt; 的结果就是50，那段逻辑很好理解，但是&lt;code&gt;switch&lt;/code&gt; 根据 &lt;code&gt;et.size&lt;/code&gt; 来调整 &lt;code&gt;newcap&lt;/code&gt; 后就是52了，这段逻辑走到了 &lt;code&gt;case et.size == sys.PtrSize&lt;/code&gt; 这段，详细的以后做源码分析再说。&lt;/p&gt;
&lt;p&gt;** 总结 **&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当 &lt;code&gt;slice&lt;/code&gt; 的长度超过其容量，会分配新的数组，并把旧数组上的值拷贝到新的数组&lt;/li&gt;
&lt;li&gt;逐个元素添加到 &lt;code&gt;slice&lt;/code&gt; 并操过其容量， 如果 &lt;code&gt;selic&lt;/code&gt; 的容量小于1024个元素，那么扩容的时候 &lt;code&gt;slice&lt;/code&gt; 的 &lt;code&gt;cap&lt;/code&gt; 就翻番，乘以2；一旦元素个数超过1024个元素，增长因子就变成1.25，即每次增加原来容量的四分之一。&lt;/li&gt;
&lt;li&gt;批量添加元素，当新的容量高于旧容量的两倍，就会分配比新容量稍大一些，并不会按上面第二条的规则扩容。&lt;/li&gt;
&lt;li&gt;当 &lt;code&gt;slice&lt;/code&gt; 发生扩容，引用新数组后，&lt;code&gt;slice&lt;/code&gt; 操作不会再影响旧的数组，而是新的数组（社区经常讨论的传递 &lt;code&gt;slice&lt;/code&gt; 容量超出后，修改数据不会作用到旧的数据上），所以往往设计函数如果会对长度调整都会返回新的 &lt;code&gt;slice&lt;/code&gt;，例如 &lt;code&gt;append&lt;/code&gt; 方法。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;slice-是引用类型&quot;&gt;slice 是引用类型？&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;slice&lt;/code&gt; 不发生扩容，所有的修改都会作用在原数组上，那如果把 &lt;code&gt;slice&lt;/code&gt; 传递给一个函数或者赋值给另一个变量会发生什么呢，&lt;code&gt;slice&lt;/code&gt; 是引用类型，会有新的内存被分配吗。&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;package main

import (
    &quot;fmt&quot;
    &quot;strings&quot;
    &quot;unsafe&quot;
)

func main() {
    s := make([]int, 10, 20)

    size := unsafe.Sizeof(0)
    fmt.Printf(&quot;%p\n&quot;, &amp;amp;s)
    fmt.Printf(&quot;%x\n&quot;, *(*uintptr)(unsafe.Pointer(&amp;amp;s)))
    fmt.Println(*(*int)(unsafe.Pointer(uintptr(unsafe.Pointer(&amp;amp;s)) + size)))
    fmt.Println(*(*int)(unsafe.Pointer(uintptr(unsafe.Pointer(&amp;amp;s)) + size*2)))

    slice(s)

    s1 := s
    fmt.Printf(&quot;%p\n&quot;, &amp;amp;s1)
    fmt.Printf(&quot;%x\n&quot;, *(*uintptr)(unsafe.Pointer(&amp;amp;s1)))
    fmt.Println(*(*int)(unsafe.Pointer(uintptr(unsafe.Pointer(&amp;amp;s1)) + size)))
    fmt.Println(*(*int)(unsafe.Pointer(uintptr(unsafe.Pointer(&amp;amp;s1)) + size*2)))

    fmt.Println(strings.Repeat(&quot;-&quot;, 50))

    *(*int)(unsafe.Pointer(uintptr(unsafe.Pointer(&amp;amp;s1)) + size)) = 20

    fmt.Printf(&quot;%x\n&quot;, *(*uintptr)(unsafe.Pointer(&amp;amp;s)))
    fmt.Println(*(*int)(unsafe.Pointer(uintptr(unsafe.Pointer(&amp;amp;s)) + size)))
    fmt.Println(*(*int)(unsafe.Pointer(uintptr(unsafe.Pointer(&amp;amp;s)) + size*2)))

    fmt.Printf(&quot;%x\n&quot;, *(*uintptr)(unsafe.Pointer(&amp;amp;s1)))
    fmt.Println(*(*int)(unsafe.Pointer(uintptr(unsafe.Pointer(&amp;amp;s1)) + size)))
    fmt.Println(*(*int)(unsafe.Pointer(uintptr(unsafe.Pointer(&amp;amp;s1)) + size*2)))

    fmt.Println(s)
    fmt.Println(s1)
    fmt.Println(strings.Repeat(&quot;-&quot;, 50))

    s2 := s
    s2 = append(s2, 1)

    fmt.Println(len(s), cap(s), s)
    fmt.Println(len(s1), cap(s1), s1)
    fmt.Println(len(s2), cap(s2), s2)

}

func slice(s []int) {
    size := unsafe.Sizeof(0)
    fmt.Printf(&quot;%p\n&quot;, &amp;amp;s)
    fmt.Printf(&quot;%x\n&quot;, *(*uintptr)(unsafe.Pointer(&amp;amp;s)))
    fmt.Println(*(*int)(unsafe.Pointer(uintptr(unsafe.Pointer(&amp;amp;s)) + size)))
    fmt.Println(*(*int)(unsafe.Pointer(uintptr(unsafe.Pointer(&amp;amp;s)) + size*2)))
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个例子(&lt;a href=&quot;https://play.golang.org/p/98NZEDdh0Mm&quot;&gt;Go Playground&lt;/a&gt;)比较长就不逐一分析了，在这个例子里面调用函数传递 &lt;code&gt;slice&lt;/code&gt; 其变量的地址发生了变化， 但是引用数组的地址，&lt;code&gt;slice&lt;/code&gt; 的长度和容量都没有变化， 这说明是对 &lt;code&gt;slice&lt;/code&gt; 的浅拷贝，拷贝 &lt;code&gt;slice&lt;/code&gt; 的三个属性创建一个新的变量，虽然引用底层数组还是一个，但是变量并不是一个。&lt;/p&gt;
&lt;p&gt;第二个创建 &lt;code&gt;s1&lt;/code&gt; 变量，使用 &lt;code&gt;s&lt;/code&gt; 为其赋值，发现 &lt;code&gt;s1&lt;/code&gt; 和函数调用一样也是 &lt;code&gt;s&lt;/code&gt; 的浅拷贝，之后修改 &lt;code&gt;s1&lt;/code&gt; 的长度发现 &lt;code&gt;s1&lt;/code&gt; 的长度发生变化，但是 &lt;code&gt;s&lt;/code&gt; 的长度保持不变， 这也说明 &lt;code&gt;s1&lt;/code&gt; 就是 &lt;code&gt;s&lt;/code&gt; 的浅拷贝。&lt;/p&gt;
&lt;p&gt;这样设计有什么优势呢，第三步创建 &lt;code&gt;s2&lt;/code&gt; 变量， 并且 &lt;code&gt;append&lt;/code&gt; 一个元素， 发现 &lt;code&gt;s2&lt;/code&gt; 的长度发生变化了， &lt;code&gt;s&lt;/code&gt; 并没有，虽然这个数据就在底层数组上，但是用常规的方法 &lt;code&gt;s&lt;/code&gt; 是看不到第11个位置上的数据的， &lt;code&gt;s1&lt;/code&gt; 因为长度覆盖到第11个元素，所有能够看到这个数据的变化。这里能看到采用浅拷贝的方式可以使得切片的属性各自独立，而不会相互影响，这样可以有一定的隔离性，缺点也很明显，如果两个变量都引用同一个数组，同时 &lt;code&gt;append&lt;/code&gt;， 在不发生扩容的情况下，总是最后一个 &lt;code&gt;append&lt;/code&gt; 的结果被保留，可能引起一些编程上疑惑。&lt;/p&gt;
&lt;p&gt;** 总结 **&lt;/p&gt;
&lt;p&gt;&lt;code&gt;slice&lt;/code&gt; 是引用类型，但是和 &lt;code&gt;C&lt;/code&gt; 传引用是有区别的， &lt;code&gt;C&lt;/code&gt; 里面的传引用是在编译器对原变量数据引用， 并不会发生内存分配，而 &lt;code&gt;Go&lt;/code&gt; 里面的引用类型传递和赋值会进行浅拷贝，在32位平台上有12个字节的内存分配， 在64位上有24字节的内存分配。&lt;/p&gt;
&lt;p&gt;*** 传引用和引用类型是有区别的， &lt;code&gt;slice&lt;/code&gt; 是引用类型。***&lt;/p&gt;
&lt;h2 id=&quot;slice-的三种状态&quot;&gt;slice 的三种状态&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;slice&lt;/code&gt; 有三种状态：零切片、空切片、nil切片。&lt;/p&gt;
&lt;h4 id=&quot;零切片&quot;&gt;零切片&lt;/h4&gt;
&lt;p&gt;所有的类型都有零值，如果 &lt;code&gt;slice&lt;/code&gt; 所引用数组元素都没有赋值，就是所有元素都是类型零值，那这就是零切片。&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;package main

import &quot;fmt&quot;

func main() {
    var s = make([]int, 10)
    fmt.Println(s)

    var s1 = make([]*int, 10)
    fmt.Println(s1)

    var s2 = make([]string, 10)
    fmt.Println(s2)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上代码输出(&lt;a href=&quot;https://play.golang.org/p/RWJv8t6goas&quot;&gt;Go Playground&lt;/a&gt;):&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[0 0 0 0 0 0 0 0 0 0]&lt;br/&gt;[&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;零切片很好理解，数组元素都为类型零值即为零切片，这种状态下的 &lt;code&gt;slice&lt;/code&gt; 和正常的 &lt;code&gt;slice&lt;/code&gt; 操作没有任何区别。&lt;/p&gt;
&lt;h4 id=&quot;空切片&quot;&gt;空切片&lt;/h4&gt;
&lt;p&gt;空切片可以理解就是切片的长度为0，就是说 &lt;code&gt;slice&lt;/code&gt; 没有元素。 社区大多数解释空切片为引用底层数组为 &lt;code&gt;zerobase&lt;/code&gt; 这个特殊的指针。但是从操作上看空切片所有的表现就是切片长度为0，如果容量也为零底层数组就会指向 &lt;code&gt;zerobase&lt;/code&gt; ，这样就不会发生内存分配， 如果容量不会零就会指向底层数据，会有内存分配。&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;package main

import (
    &quot;fmt&quot;
    &quot;reflect&quot;
    &quot;strings&quot;
    &quot;unsafe&quot;
)

func main() {
    var s []int
    s1 := make([]int, 0)
    s2 := make([]int, 0, 0)
    s3 := make([]int, 0, 100)

    arr := [10]int{}
    s4 := arr[:0]

    fmt.Println(strings.Repeat(&quot;--s--&quot;, 10))
    fmt.Println(*(*reflect.SliceHeader)(unsafe.Pointer(&amp;amp;s)))
    fmt.Println(s)
    fmt.Println(s == nil)

    fmt.Println(strings.Repeat(&quot;--s1--&quot;, 10))
    fmt.Println(*(*reflect.SliceHeader)(unsafe.Pointer(&amp;amp;s1)))
    fmt.Println(s1)
    fmt.Println(s1 == nil)

    fmt.Println(strings.Repeat(&quot;--s2--&quot;, 10))
    fmt.Println(*(*reflect.SliceHeader)(unsafe.Pointer(&amp;amp;s2)))
    fmt.Println(s2)
    fmt.Println(s2 == nil)

    fmt.Println(strings.Repeat(&quot;--s3--&quot;, 10))
    fmt.Println(*(*reflect.SliceHeader)(unsafe.Pointer(&amp;amp;s3)))
    fmt.Println(s3)
    fmt.Println(s3 == nil)

    fmt.Println(strings.Repeat(&quot;--s4--&quot;, 10))
    fmt.Println(*(*reflect.SliceHeader)(unsafe.Pointer(&amp;amp;s4)))
    fmt.Println(s4)
    fmt.Println(s4 == nil)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上代码输出(&lt;a href=&quot;https://play.golang.org/p/I145ObQ32yG&quot;&gt;Go Playground&lt;/a&gt;):&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;--s----s----s----s----s----s----s----s----s----s--&lt;br/&gt;{0 0 0}&lt;br/&gt;[]&lt;br/&gt;--s1----s1----s1----s1----s1----s1----s1----s1----s1----s1--&lt;br/&gt;{18349960 0 0}&lt;br/&gt;[]&lt;br/&gt;--s2----s2----s2----s2----s2----s2----s2----s2----s2----s2--&lt;br/&gt;{18349960 0 0}&lt;br/&gt;[]&lt;br/&gt;--s3----s3----s3----s3----s3----s3----s3----s3----s3----s3--&lt;br/&gt;{824634269696 0 100}&lt;br/&gt;[]&lt;br/&gt;--s4----s4----s4----s4----s4----s4----s4----s4----s4----s4--&lt;br/&gt;{824633835680 0 10}&lt;br/&gt;[]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以上示例中除了 &lt;code&gt;s&lt;/code&gt; 其它的 &lt;code&gt;slice&lt;/code&gt; 都是空切片，打印出来全部都是 &lt;code&gt;[]&lt;/code&gt;，&lt;code&gt;s&lt;/code&gt; 是nil切片下一小节说。要注意 &lt;code&gt;s1&lt;/code&gt; 和 &lt;code&gt;s2&lt;/code&gt; 的长度和容量都为0，且引用数组指针都是 &lt;code&gt;18349960&lt;/code&gt;， 这点太重要了，因为他们都指向 &lt;code&gt;zerobase&lt;/code&gt; 这个特殊的指针，是没有内存分配的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1572234/201901/1572234-20190113214829671-1386599738.jpg&quot; alt=&quot;slice&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;nil切片&quot;&gt;nil切片&lt;/h4&gt;
&lt;p&gt;什么是nil切片，这个名字说明nil切片没有引用任何底层数组，底层数组的地址为nil就是nil切片。上一小节中的 &lt;code&gt;s&lt;/code&gt; 就是一个nil切片，它的底层数组指针为0，代表是一个 &lt;code&gt;nil&lt;/code&gt; 指针。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1572234/201901/1572234-20190113214842651-1834459371.jpg&quot; alt=&quot;slice&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;总结&quot;&gt;总结&lt;/h4&gt;
&lt;p&gt;零切片就是其元素值都是元素类型的零值的切片。&lt;br/&gt;空切片就是数组指针不为nil，且 &lt;code&gt;slice&lt;/code&gt; 的长度为0。&lt;br/&gt;nil切片就是引用底层数组指针为 &lt;code&gt;nil&lt;/code&gt; 的 &lt;code&gt;slice&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;操作上零切片、空切片和正常的切片都没有任何区别，但是nil切片会多两个特性，一个nil切片等于 &lt;code&gt;nil&lt;/code&gt; 值，且进行 &lt;code&gt;json&lt;/code&gt; 序列化时其值为 &lt;code&gt;null&lt;/code&gt;，nil切片还可以通过赋值为 &lt;code&gt;nil&lt;/code&gt; 获得。&lt;/p&gt;
&lt;h2 id=&quot;数组与-slice-大比拼&quot;&gt;数组与 slice 大比拼&lt;/h2&gt;
&lt;p&gt;对数组和 &lt;code&gt;slice&lt;/code&gt; 做了性能测试，源码在 &lt;a href=&quot;https://github.com/thinkeridea/example/blob/master/array_slice/test/branch_test.go&quot;&gt;GitHub&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;对不同容量和数组和切片做性能测试，代码如下，分为：100、1000、10000、100000、1000000、10000000&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func BenchmarkSlice100(b *testing.B) {
    for i := 0; i &amp;lt; b.N; i++ {
        s := make([]int, 100)
        for i, v := range s {
            s[i] = 1 + i
            _ = v
        }
    }
}

func BenchmarkArray100(b *testing.B) {
    for i := 0; i &amp;lt; b.N; i++ {
        a := [100]int{}
        for i, v := range a {
            a[i] = 1 + i
            _ = v
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试结果如下：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;goos: darwin&lt;br/&gt;goarch: amd64&lt;br/&gt;pkg: github.com/thinkeridea/example/array_slice/test&lt;br/&gt;BenchmarkSlice100-8 20000000 69.8 ns/op 0 B/op 0 allocs/op&lt;br/&gt;BenchmarkArray100-8 20000000 69.0 ns/op 0 B/op 0 allocs/op&lt;br/&gt;BenchmarkSlice1000-8 5000000 318 ns/op 0 B/op 0 allocs/op&lt;br/&gt;BenchmarkArray1000-8 5000000 316 ns/op 0 B/op 0 allocs/op&lt;br/&gt;BenchmarkSlice10000-8 200000 9024 ns/op 81920 B/op 1 allocs/op&lt;br/&gt;BenchmarkArray10000-8 500000 3143 ns/op 0 B/op 0 allocs/op&lt;br/&gt;BenchmarkSlice100000-8 10000 114398 ns/op 802816 B/op 1 allocs/op&lt;br/&gt;BenchmarkArray100000-8 20000 61856 ns/op 0 B/op 0 allocs/op&lt;br/&gt;BenchmarkSlice1000000-8 2000 927946 ns/op 8003584 B/op 1 allocs/op&lt;br/&gt;BenchmarkArray1000000-8 5000 342442 ns/op 0 B/op 0 allocs/op&lt;br/&gt;BenchmarkSlice10000000-8 100 10555770 ns/op 80003072 B/op 1 allocs/op&lt;br/&gt;BenchmarkArray10000000-8 50 22918998 ns/op 80003072 B/op 1 allocs/op&lt;br/&gt;PASS&lt;br/&gt;ok github.com/thinkeridea/example/array_slice/test 23.333s&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;从上面的结果可以发现数组和 &lt;code&gt;slice&lt;/code&gt; 在1000以内的容量上时性能机会一致，而且都没有内存分配，这应该是编译器对 &lt;code&gt;slice&lt;/code&gt; 的特殊优化。&lt;br/&gt;从10000~1000000容量时数组的效率就比&lt;code&gt;slice&lt;/code&gt;好了一倍有余，主要原因是数组在没有内存分配做了编译优化，而 &lt;code&gt;slice&lt;/code&gt; 有内存分配。&lt;br/&gt;但是10000000容量往后数组性能大幅度下降，&lt;code&gt;slice&lt;/code&gt; 是数组性能的两倍，两个都在运行时做了内存分配，其实这么大的数组还真是不常见，也没有比较做编译器优化了。&lt;/p&gt;
&lt;h2 id=&quot;slice-与数组的应用场景总结&quot;&gt;slice 与数组的应用场景总结&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;slice&lt;/code&gt; 和数组有些差别，特别是应用层上，特性差别很大，那什么时间使用数组，什么时间使用切片呢。&lt;br/&gt;之前做了性能测试，在1000以内性能几乎一致，只有10000~1000000时才会出现数组性能好于 &lt;code&gt;slice&lt;/code&gt;，由于数组在编译时确定长度，也就是再编写程序时必须确认长度，所有往常不会用到更大的数组，大多数都在1000以内的长度。我认为如果在编写程序是就已经确定数据长度，建议用数组，而且竟可能是局部使用的位置建议用数组（避免传递产生值拷贝），比如一天24小时，一小时60分钟，ip是4个 &lt;code&gt;byte&lt;/code&gt;这种情况是可以用时数组的。&lt;/p&gt;
&lt;p&gt;为什么推荐用数组，只要能在编写程序是确定数据长度我都会用数组，因为其类型会帮助阅读理解程序，&lt;code&gt;dayHour := [24]Data&lt;/code&gt; 一眼就知道是按小时切分数据存储的，如要传递数组时可以考虑传递数组的指针，当然会带来一些操作不方便，往常我使用数组都是不需要传递给其它函数的，可能会在 &lt;code&gt;struct&lt;/code&gt; 里面保存数组，然后传递 &lt;code&gt;struct&lt;/code&gt; 的指针，或者用 &lt;code&gt;unsafe&lt;/code&gt; 来反解析数组指针到新的数组，也不会产生数据拷贝，并且只增加一句转换语句。&lt;code&gt;slice&lt;/code&gt; 会比数组多存储三个 &lt;code&gt;int&lt;/code&gt; 的属性，而且指针引用会增加 &lt;code&gt;GC&lt;/code&gt; 扫描的成本，每次传递都会对这三个属性进行拷贝，如果可以也可以考虑传递 &lt;code&gt;slice&lt;/code&gt; 的指针，指针只有一个 &lt;code&gt;int&lt;/code&gt; 的大小。&lt;/p&gt;
&lt;p&gt;** 对于不确定大小的数据只能用 &lt;code&gt;slice&lt;/code&gt;，否则就要自己做扩容很麻烦， 对于确定大小的集合建议使用数组。**&lt;/p&gt;
&lt;h2 id=&quot;转载&quot;&gt;转载：&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;本文作者： 戚银（thinkeridea）&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;本文链接： &lt;a href=&quot;https://blog.thinkeridea.com/201901/go/shen_ru_pou_xi_slice_he_array.html&quot; class=&quot;uri&quot;&gt;https://blog.thinkeridea.com/201901/go/shen_ru_pou_xi_slice_he_array.html&lt;/a&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;版权声明： 本博客所有文章除特别声明外，均采用 CC BY 4.0 CN协议 许可协议。转载请注明出处！&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 13 Jan 2019 13:51:00 +0000</pubDate>
<dc:creator>戚银</dc:creator>
<og:description>`array slice slice array` 的引用，相当于动态数组， 这些都是 的特性，但是 底层如何表现，内存中是如何分配的，特别是在程序中大量使用 的情况下，怎样可以高效使用 ？ 今天借助</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/thinkeridea/p/10264195.html</dc:identifier>
</item>
</channel>
</rss>