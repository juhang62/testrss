<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Web API  处理机制剖析 --- 拨开迷雾看本质 - 源之缘</title>
<link>http://www.cnblogs.com/yuanchenhui/p/web_api_inside.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuanchenhui/p/web_api_inside.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; 前言&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;span&gt;最近开发了几个项目，用到了web api，也通过项目加深了对web api的理解。本文试图从内部原理讲解web api的本质。透过重重迷雾，看清本质，就能更好的把握和利用好web api。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1&lt;/strong&gt; &lt;/span&gt;Web API 的本质&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt; 1.1 交互说明&lt;/span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Web API 是基于http传输协议的函数调用。http是应用最广泛的传输协议，web服务端就实现了http服务器。由于web的流行，也带动了web服务器的完善和优化。web服务器的功能也不仅限于传输html文本，任何数据都可以通过文本传输（其实，图片，视频也可以通过变通的方式实现传输）。函数的调用就是发送数据和接收数据的过程；既然http也能发送和接收数据，当然也可以通过http实现函数调用，这就是web api。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/245753/201904/245753-20190419213613424-839691838.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;http是传输协议，并不解释传输的内容。http协议同时也定义了一些标准的术语，方便客户端和服务端交互。一个典型的http发送和响应数据如下：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;----&amp;gt;request&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
Request URL: https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.baidu.com/&lt;/span&gt;
&lt;span&gt;Request Method: GET
Accept: text&lt;/span&gt;/html,application/xhtml+xml,application/xml;q=&lt;span&gt;0.9&lt;/span&gt;,image/webp,image/apng,*&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;;q=0.8
&lt;span&gt;Accept-Encoding: gzip, deflate, br
Accept-Language: zh-CN,zh;q=0.9,en;q=0.8
Connection: keep-alive
Cookie: BAIDUID=43E2CBB543131B011BC1861E7CDD83DB:FG=1
Host: www.baidu.com
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36

&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;body data&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&amp;lt;----reponse&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Status Code: 200 OK
Remote Address: 111.13.100.91:443
Referrer Policy: no-referrer-when-downgrade
Bdpagetype: 1
Bdqid: 0xecff8dba0009a0bc
Cache-Control: private
Connection: Keep-Alive
Content-Type: text/html
Cxy_all: baidu+5bd9cbe0adf9080de3f7682cf8f45af1
Date: Fri, 19 Apr 2019 13:44:36 GMT
Expires: Fri, 19 Apr 2019 13:44:05 GMT
Server: BWS/1.1
Set-Cookie: BIDUPSID=43E2CBB543131B011BC1861E7CDD83DB; expires=Thu, 31-Dec-37 23:55:55 GMT; max-age=2147483647; path=/; domain=.baidu.com
Set-Cookie: PSTM=1555681476; expires=Thu, 31-Dec-37 23:55:55 GMT; max-age=2147483647; path=/; domain=.baidu.com
&lt;p&gt;&lt;span&gt;body data&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;http分为包头和包体，包头包含一些关键字段，如Accept，Cookie，这些是http的保留字。你也可以通过包头传输数据，只要不使用保留字就行。如：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;myguid： 6F9619FF-8B86-D011-B42D-00C04FC964FF&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通常包头传输一组函数公用的数据，比如有10个函数，这些函数都用到guid，可以把guid放入包头。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.2 包体数据说明&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;http请求（request）数据：&lt;/p&gt;
&lt;p&gt;a）对于浏览器的表单，包体数据格式如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;key1=value1&amp;amp;key2=value2&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;就是key，value对，通过&amp;amp;号分割。key，value也可以是汉字，会做转义处理。这些细节不需要我们处理。只需要知道key、value可以是任何字符就行。&lt;/p&gt;
&lt;p&gt;b）json和其他数据格式&lt;/p&gt;
&lt;p&gt;对于web api，包体数据可以是json格式。当然不限于json，可以是任意形式的数据，只要双方对处理协议达成一致就行。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sites&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: [
    { &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;菜鸟教程&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; , &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;url&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;www.runoob.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; }, 
    { &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;google&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; , &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;url&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;www.google.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; }, 
    { &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;微博&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; , &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;url&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;www.weibo.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; }
    ]
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;传输复杂的数据建议使用json，json函数可以把复杂的类变量序列化；对方反序列化，就可以得到一个类变量。这样，远程函数调用与本地调用区别就很小；仅仅多一层json序列化。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2 asp.net 对web API的实现&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;常言：巧妇难为无米之炊。对于web api，http承载的数据就是米，asp.net框架就是巧妇。web api的本质就是数据的发送和接收，asp.net 能做的的就是方便你的接收和返回。asp.net这里是好心帮程序员减轻负担，但这种好心也有副作用：很难探究web api的本质，遇到问题难以从本质上去分析解决。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;2.1 数据如何变成函数参数&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们一般不处理http原始数据，这些数据一般会映射为函数参数。这种映射关系多种多样，见下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/245753/201904/245753-20190419232209230-231964879.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;asp.net做这种映射处理就是为了减轻开发人员的负担，但是开发人员必须了解这些映射关系。不同框架处理这种映射逻辑也是不一样的，其实，开发人员可以定制自己的映射逻辑；但是好像没必要这样做，直接处理http数据，就是从asp.net request变量抽取http数据再处理，也增加不了多少工作量；这样反而使开发人员对底层数据了解更加透彻。&lt;/p&gt;
&lt;p&gt; 2.2 asp.net 客户端调用举例&lt;/p&gt;
&lt;p&gt;使用类WebClient做为示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;客户端调用&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; clientPost()
    {
        &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; client = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; System.Net.WebClient())
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; postParam = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NameValueCollection();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;传递参数&lt;/span&gt;
            postParam.Add(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;code&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            postParam.Add(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tom);&lt;/span&gt;
           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;http body部分就变为 code=123&amp;amp;name=tom&lt;/span&gt;

            &lt;span&gt;var&lt;/span&gt; responsebytes =&lt;span&gt; client.UploadValues(uri, postParam);

            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; strResult =&lt;span&gt; System.Text.Encoding.UTF8.GetString(responsebytes);
        }
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;服务端:&lt;/span&gt;
    &lt;span&gt;string&lt;/span&gt; ServerDeal(&lt;span&gt;string&lt;/span&gt; code, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; name)
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;http body数据部分映射为参数：code为123,name为tom&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ok&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;NameValueCollection类将数据组成key、value对，并处理字符转义。通过上面的代码可以看出，web api调用其实很简单，框架帮我们做了数据映射，字符转义等常规操作，让我从繁杂的琐事中脱身，专注处理业务逻辑。&lt;br/&gt;&lt;span&gt;&lt;strong&gt;后记&lt;/strong&gt;：&lt;/span&gt;对事物的了解要抓住本质，只要了解了本质，就一通百通。web api原理并不繁杂，但是由于上层的封装，使我们很难了解到底层处理原理，导致很难抓住事物的本质。本文通过自身的领悟，试图剖析其本质，希望对读者有所裨益！&lt;/span&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 19 Apr 2019 15:24:00 +0000</pubDate>
<dc:creator>源之缘</dc:creator>
<og:description>前言 最近开发了几个项目，用到了web api，也通过项目加深了对web api的理解。本文试图从内部原理讲解web api的本质。透过重重迷雾，看清本质，就能更好的把握和利用好web ap</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yuanchenhui/p/web_api_inside.html</dc:identifier>
</item>
<item>
<title>LearnOpenGL学习笔记（六）——纹理单元 - zobol</title>
<link>http://www.cnblogs.com/zobol/p/10739458.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zobol/p/10739458.html</guid>
<description>&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;span&gt;#version 330 core
out vec4 FragColor;
in vec3 ourColor;
in vec2 TexCoord;

uniform sampler2D ourTexture;
void main()
{
FragColor = texture(ourTexture, TexCoord);
}&lt;/span&gt;&lt;/strong&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;      在刚才的程序中，关于片段着色器的中我们声明了一个采样器(Sampler），一般来讲我们需要用glUniform1i（）函数进行将纹理对象（数据），从CPU中传入显存中的着色器这样一个过程。但是现实是我们没有这么做，我们只是在主函数里绑定了目标，就自动传入到片段着色器里面了。这就是我们忽视的一个概念——纹理单元。&lt;/p&gt;
&lt;p&gt;    &lt;span&gt;一个纹理的位置值通常称为一个纹理单元(Texture Unit)。&lt;/span&gt;之所以我们没有去用glUniform1i（）函数，是因为一个纹理的默认纹理单元是0，它是默认的激活纹理单元。&lt;/p&gt;
&lt;p&gt;如果我们只传入一个纹理对象，那么倒是不用担心纹理单元的问题，反正自动传入，你绑定就好了。但是当有多个纹理对象要传入的时候，我们必须指定纹理对象，然后再主函数用glUniform1i（）函数一个一个对接到着色器内部完毕，否则一切就乱套了。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      纹理单元的主要目的是让我们在着色器中可以使用多于一个的纹理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;使用glUniform1i设置采样器:&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;       使用glUniform1i（）函数作为着色器内部和程序沟通的桥梁需要知道两件事情，一个是在着色器内部接受信息的对象为位置
（layout）。一个是外界的数据对象。严格来讲传入数据本身也不是这个函数做的，这个函数是告诉着色器那个纹理对象对应哪个采样
器对象。至于传入这个是没有函数对应的，就是激活纹理对象，绑定纹理对象，激活下一个纹理对象，绑定下一个对象。就可以告诉计算
机全部了。
&lt;strong&gt;&lt;span&gt;glActiveTexture(GL_TEXTURE0); &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;// 在绑定纹理之前先激活纹理单元 
g&lt;/span&gt;&lt;span&gt;&lt;strong&gt;lB&lt;/strong&gt;indTexture(GL_TEXTURE_2D, texture);&lt;/span&gt;&lt;/strong&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;渲染之前设置：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;span&gt;ourShader.use();&lt;/span&gt;&lt;/strong&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 别忘记在激活着色器前先设置uniform！&lt;/span&gt;
&lt;strong&gt;&lt;span&gt;glUniform1i(glGetUniformLocation(ourShader.ID, &quot;texture1&quot;), 0);&lt;/span&gt;&lt;/strong&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 手动设置&lt;/span&gt;
&lt;strong&gt;&lt;span&gt;ourShader.setInt(&quot;texture2&quot;, 1);&lt;/span&gt;&lt;/strong&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 或者使用着色器类设置&lt;/span&gt;

&lt;strong&gt;&lt;span&gt;while(...) 
{
    [...]
}&lt;/span&gt;&lt;/strong&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;渲染过程中：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;span&gt;glActiveTexture(GL_TEXTURE0);
glBindTexture(GL_TEXTURE_2D, texture1);
glActiveTexture(GL_TEXTURE1);
glBindTexture(GL_TEXTURE_2D, texture2);

glBindVertexArray(VAO);
glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;glBindTexture函数调用会绑定这个纹理到当前激活的纹理单元，纹理单元GL_TEXTURE0默认总是被激活，所以我们在前面的例子&lt;/span&gt;
里当我们使用glBindTexture的时候，无需激活任何纹理单元。
&lt;/pre&gt;&lt;/div&gt;


</description>
<pubDate>Fri, 19 Apr 2019 15:24:00 +0000</pubDate>
<dc:creator>zobol</dc:creator>
<og:description>在刚才的程序中，关于片段着色器的中我们声明了一个采样器(Sampler），一般来讲我们需要用glUniform1i（）函数进行将纹理对象（数据），从CPU中传入显存中的着色器这样一个过程。但是现实是我</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zobol/p/10739458.html</dc:identifier>
</item>
<item>
<title>深度学习之卷积神经网络(CNN)详解与代码实现（二） - w_x_w1985</title>
<link>http://www.cnblogs.com/further-further-further/p/10737065.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/further-further-further/p/10737065.html</guid>
<description>

&lt;p&gt;&lt;span&gt;            本文系作者原创，转载请注明出处&lt;a id=&quot;Editor_Edit_hlEntryLink&quot; title=&quot;view: 深度学习之卷积神经网络(CNN)详解与代码实现（二）&quot; href=&quot;https://www.cnblogs.com/further-further-further/p/10737065.html&quot; target=&quot;_blank&quot;&gt;:https://www.cnblogs.com/further-further-further/p/10737065.html&lt;/a&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;目录&lt;/span&gt;&lt;/h2&gt;
&lt;h2&gt;&lt;span&gt;1.踩过的坑(tensorflow)&lt;/span&gt;&lt;/h2&gt;
&lt;h2&gt;&lt;span&gt;2.tensorboard&lt;/span&gt;&lt;/h2&gt;
&lt;h2&gt;&lt;span&gt;3.代码实现（python3.6）&lt;/span&gt;&lt;/h2&gt;
&lt;h2&gt;&lt;span&gt;4.运行结果以及分析&lt;/span&gt;&lt;/h2&gt;

&lt;h2&gt;&lt;span&gt;1.踩过的坑(tensorflow)&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;上一章CNN中各个算法都是纯手工实现的，可能存在一些难以发现的问题，这也是准确率不高的一个原因，这章主要利用tensorflow框架&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;来实现卷积神经网络，数据源还是cifar（具体下载见上一章）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;在利用tensorflow框架实现CNN时，需要注意以下几点：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;1.输入数据定义时，x只是起到占位符的作用（看不到真实值，只是为了能够运行代码，获取相应的tensor节点，这一点跟我们之前代码流程完全相反， 真正数据流的执行在session会话里）&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;x：输入数据，y_： 标签数据，keep_prob: 概率因子，防止过拟合。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;定义，且是全局变量。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
x = tf.placeholder(tf.float32, [None, 3072], name='x') 
&lt;/pre&gt;
&lt;pre&gt;
y_ = tf.placeholder(tf.float32, [None, 10], name='y_')
&lt;/pre&gt;
&lt;pre&gt;
keep_prob = tf.placeholder(tf.float32)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;后面在session里必须要初始化&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
sess.run(tf.global_variables_initializer())
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;在session run时必须要传得到该tensor节点含有参数值（x, y_, keep_prob）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
train_accuracy = accuracy.eval(feed_dict=&lt;span&gt;{
                    x: batch[0], y_: batch[&lt;/span&gt;1], keep_prob: 1.0})
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;2.原始数据集标签要向量化；&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;例如cifar有10个类别，如果类别标签是 6 对应向量[0,0,0,0,0,1,0,0,0,0]&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;3.知道每一步操作的数据大小的变化，不然，报错的时候很难定位（个人认为这也是tensorflow的弊端，无法实时追踪定位）；&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;  注意padding = 'SAME'和'VALID'的区别&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;  padding = 'SAME' =&amp;gt; Height_后 = Height_前/Strides 跟padding无关  向上取整&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;  padding = 'VALID'=&amp;gt;  Height_后 = (Height_前 - Filter + 1)/Strides  向上取整&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;4.打印tensorboard流程图，可以直观看到每步操作数据大小的变化；&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;2. tensorboard&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;tensorboard就是一个数据结构流程图的可视化工具，通过tensorboard流程图，可以直观看到神经网络的每一步操作以及数据流的变化。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;操作步骤：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. 在session会话里加入如下代码，打印结果会在当前代码文件相同路径的tensorboard文件下，默认是&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
tf.summary.FileWriter(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tensorboard/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, sess.graph)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2. 在运行里输入cmd，然后输入（前提是安装好了tensorboard =&amp;gt; pip install  tensorboard）&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
tensorboard --logdir=D:\Project\python\myProject\CNN\tensorflow\captchaIdentify\tensorboard --host=127.0.0.1
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;'D:\Project\python\myProject\CNN\tensorflow\captchaIdentify\tensorboard' 是我生成的tensorboard文件的绝对路径，你替换成你自己的就可以了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;正确运行后会显示 ‘Tensorboard at http://127.0.0.1:6006’，说明tensorboard服务已经起来了，在浏览器页面输入&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;http://127.0.0.1:6006即可显示流程图。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;3.代码实现（python3.6）&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;MathJax_Preview&quot;&gt;代码逻辑实现相对比较简单，在一些重要逻辑实现上，我已做了注释，如果大家有什么疑义，可以留言给我，我们一起交流。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;MathJax_Preview&quot;&gt;因为原始图片数据集太大，不好上传，大家可以直接在&lt;a href=&quot;http://www.cs.toronto.edu/~kriz/cifar.html&quot; target=&quot;_blank&quot;&gt;http://www.cs.toronto.edu/~kriz/cifar.html&lt;/a&gt;下载CIFAR-10 python version，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;MathJax_Preview&quot;&gt;有163M，放在代码文件同路径下即可。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;MathJax_Preview&quot;&gt;cifar放置路径&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/797382/201904/797382-20190419230527066-1727239284.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;MathJax_Preview&quot;&gt;start.py&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('c3070b67-dd58-4c2d-8c45-97c51c6ccec9')&quot; readability=&quot;69.5&quot;&gt;&lt;img id=&quot;code_img_closed_c3070b67-dd58-4c2d-8c45-97c51c6ccec9&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_c3070b67-dd58-4c2d-8c45-97c51c6ccec9&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('c3070b67-dd58-4c2d-8c45-97c51c6ccec9',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_c3070b67-dd58-4c2d-8c45-97c51c6ccec9&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;134&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; coding=utf-8&lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Disable linter warnings to maintain consistency with tutorial.&lt;/span&gt;
&lt;span&gt;  3&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; pylint: disable=invalid-name&lt;/span&gt;
&lt;span&gt;  4&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; pylint: disable=g-bad-import-order&lt;/span&gt;
&lt;span&gt;  5&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; &lt;span&gt;__future__&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; absolute_import
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; &lt;span&gt;__future__&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; division
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; &lt;span&gt;__future__&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; print_function
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; argparse
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; sys
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; tempfile
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;from tensorflow.examples.tutorials.mnist import input_data&lt;/span&gt;
&lt;span&gt; 12&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; tensorflow as tf
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt; &lt;span&gt;'''&lt;/span&gt;
&lt;span&gt; 14&lt;/span&gt; &lt;span&gt; 卷积神经网络实现10类(airplane, automobile, bird, cat, deer, dog, frog, horse, ship, truck) 
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt; &lt;span&gt; 60000张图片的识别
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt; &lt;span&gt; 5000次，准确率有 58%；
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt; &lt;span&gt; 20000次，准确率有 68.89%；
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt; &lt;span&gt; 相比mnist数字图片识别准确度低，原因有：
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt; &lt;span&gt; mnist训练图片是灰度图片，纹理简单，数字的可变性小，而cifar是彩色图片，纹理复杂，动物可变性大；
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt; &lt;span&gt;'''&lt;/span&gt;
&lt;span&gt; 21&lt;/span&gt; &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt;     &lt;span&gt;from&lt;/span&gt; . &lt;span&gt;import&lt;/span&gt;&lt;span&gt; datesets
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt; &lt;span&gt;except&lt;/span&gt;&lt;span&gt; Exception:
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt;     &lt;span&gt;import&lt;/span&gt;&lt;span&gt; datesets
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt; 
&lt;span&gt; 26&lt;/span&gt; FLAGS =&lt;span&gt; None
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt; 
&lt;span&gt; 28&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; deepnn(x):
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt;     with tf.name_scope(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;reshape&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;):
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt;         x_image = tf.reshape(x, [-1, 32, 32, 3&lt;span&gt;])
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;# 第一层卷积操作 ##&lt;/span&gt;
&lt;span&gt; 32&lt;/span&gt;     with tf.name_scope(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;conv1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;):
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt;         W_conv1 = weight_variable([5, 5, 3, 32&lt;span&gt;])
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt;         b_conv1 = bias_variable([32&lt;span&gt;])
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt;         h_conv1 = tf.nn.relu(conv2d(x_image, W_conv1) +&lt;span&gt; b_conv1)
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt; 
&lt;span&gt; 37&lt;/span&gt;     with tf.name_scope(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;pool1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;):
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt;         h_pool1 =&lt;span&gt; max_pool_2x2(h_conv1)
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt; 
&lt;span&gt; 40&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Second convolutional layer -- maps 32 feature maps to 64.&lt;/span&gt;
&lt;span&gt; 41&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;# 第二层卷积操作 ##&lt;/span&gt;
&lt;span&gt; 42&lt;/span&gt;     with tf.name_scope(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;conv2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;):
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt;         W_conv2 = weight_variable([5, 5, 32, 64&lt;span&gt;])
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt;         b_conv2 = bias_variable([64&lt;span&gt;])
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt;         h_conv2 = tf.nn.relu(conv2d(h_pool1, W_conv2) +&lt;span&gt; b_conv2)
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt; 
&lt;span&gt; 47&lt;/span&gt;     with tf.name_scope(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;pool2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;):
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt;         h_pool2 =&lt;span&gt; max_pool_2x2(h_conv2)
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt; 
&lt;span&gt; 50&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;# 第三层全连接操作 ##&lt;/span&gt;
&lt;span&gt; 51&lt;/span&gt;     with tf.name_scope(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;fc1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;):
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt;         W_fc1 = weight_variable([8 * 8 * 64, 1024&lt;span&gt;])
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt;         b_fc1 = bias_variable([1024&lt;span&gt;])
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt;         h_pool2_flat = tf.reshape(h_pool2, [-1, 8 * 8 * 64&lt;span&gt;])
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt;         h_fc1 = tf.nn.relu(tf.matmul(h_pool2_flat, W_fc1) +&lt;span&gt; b_fc1)
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt; 
&lt;span&gt; 57&lt;/span&gt;     with tf.name_scope(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;dropout&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;):
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt;         keep_prob =&lt;span&gt; tf.placeholder(tf.float32)
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt;         h_fc1_drop =&lt;span&gt; tf.nn.dropout(h_fc1, keep_prob)
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt; 
&lt;span&gt; 61&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;# 第四层输出操作 ##&lt;/span&gt;
&lt;span&gt; 62&lt;/span&gt;     with tf.name_scope(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;fc2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;):
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt;         W_fc2 = weight_variable([1024, 10&lt;span&gt;])
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt;         b_fc2 = bias_variable([10&lt;span&gt;])
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt;         y_conv = tf.matmul(h_fc1_drop, W_fc2) +&lt;span&gt; b_fc2
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; y_conv, keep_prob
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt; 
&lt;span&gt; 68&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; conv2d(x, W):
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; tf.nn.conv2d(x, W, strides=[1, 1, 1, 1], padding=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;SAME&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt; 
&lt;span&gt; 71&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; max_pool_2x2(x):
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; tf.nn.max_pool(x, ksize=[1, 2, 2, 1&lt;span&gt;],
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt;                           strides=[1, 2, 2, 1], padding=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;SAME&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt; 
&lt;span&gt; 75&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; weight_variable(shape):
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt;     initial = tf.truncated_normal(shape, stddev=0.1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; tf.Variable(initial)
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt; 
&lt;span&gt; 79&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; bias_variable(shape):
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt;     initial = tf.constant(0.1, shape=&lt;span&gt;shape)
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; tf.Variable(initial)
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt; 
&lt;span&gt; 83&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; main(_):
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Import data&lt;/span&gt;
&lt;span&gt; 85&lt;/span&gt;     mnist = datesets.read_data_sets(train_dir = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;.\\cifar-10-batches-py\\&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, one_hot=&lt;span&gt;True)
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt; 
&lt;span&gt; 87&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Create the model&lt;/span&gt;
&lt;span&gt; 88&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 声明一个占位符，None表示输入图片的数量不定，28*28图片分辨率&lt;/span&gt;
&lt;span&gt; 89&lt;/span&gt;     x = tf.placeholder(tf.float32, [None, 3072], name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;x&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt; 
&lt;span&gt; 91&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 类别是0-9总共10个类别，对应输出分类结果&lt;/span&gt;
&lt;span&gt; 92&lt;/span&gt;     y_ = tf.placeholder(tf.float32, [None, 10], name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;y_&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt;     y_conv, keep_prob =&lt;span&gt; deepnn(x)
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 通过softmax-loss求交叉熵&lt;/span&gt;
&lt;span&gt; 95&lt;/span&gt;     with tf.name_scope(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;loss&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;):
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt;         cross_entropy = tf.nn.softmax_cross_entropy_with_logits(labels=y_, logits=&lt;span&gt;y_conv)
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 求均值&lt;/span&gt;
&lt;span&gt; 98&lt;/span&gt;     cross_entropy =&lt;span&gt; tf.reduce_mean(cross_entropy)
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 计算梯度，更新参数值&lt;/span&gt;
&lt;span&gt;100&lt;/span&gt;     with tf.name_scope(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;adam_optimizer&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt;         train_step = tf.train.AdamOptimizer(1e-4&lt;span&gt;).minimize(cross_entropy)
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt; 
&lt;span&gt;103&lt;/span&gt;     with tf.name_scope(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;accuracy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt;         correct_prediction = tf.equal(tf.argmax(y_conv, 1), tf.argmax(y_, 1&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt;         correct_prediction =&lt;span&gt; tf.cast(correct_prediction, tf.float32)
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt;     accuracy =&lt;span&gt; tf.reduce_mean(correct_prediction)
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt; 
&lt;span&gt;108&lt;/span&gt;    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; graph_location = tempfile.mkdtemp()&lt;/span&gt;
&lt;span&gt;109&lt;/span&gt;    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; print('Saving graph to: %s' % graph_location)&lt;/span&gt;
&lt;span&gt;110&lt;/span&gt;    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; train_writer.add_graph(tf.get_default_graph())&lt;/span&gt;
&lt;span&gt;111&lt;/span&gt; 
&lt;span&gt;112&lt;/span&gt; &lt;span&gt;    with tf.Session() as sess:
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 打印流程图&lt;/span&gt;
&lt;span&gt;114&lt;/span&gt;         writer = tf.summary.FileWriter(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tensorboard/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, sess.graph)
&lt;/span&gt;&lt;span&gt;115&lt;/span&gt; &lt;span&gt;        sess.run(tf.global_variables_initializer())
&lt;/span&gt;&lt;span&gt;116&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(20000&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;117&lt;/span&gt;             batch = mnist.train.next_batch(50&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;118&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; i % 1000 ==&lt;span&gt; 0:
&lt;/span&gt;&lt;span&gt;119&lt;/span&gt;                 train_accuracy = accuracy.eval(feed_dict=&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;120&lt;/span&gt;                     x: batch[0], y_: batch[1], keep_prob: 1.0&lt;span&gt;})
&lt;/span&gt;&lt;span&gt;121&lt;/span&gt;                 &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;step %d, training accuracy %g&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; (i, train_accuracy))
&lt;/span&gt;&lt;span&gt;122&lt;/span&gt;             train_step.run(feed_dict={x: batch[0], y_: batch[1], keep_prob: 0.5&lt;span&gt;})
&lt;/span&gt;&lt;span&gt;123&lt;/span&gt; 
&lt;span&gt;124&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test accuracy %g&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; % accuracy.eval(feed_dict=&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;125&lt;/span&gt;             x: mnist.test.images, y_: mnist.test.labels, keep_prob: 1.0&lt;span&gt;}))
&lt;/span&gt;&lt;span&gt;126&lt;/span&gt; 
&lt;span&gt;127&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;128&lt;/span&gt;     parser =&lt;span&gt; argparse.ArgumentParser()
&lt;/span&gt;&lt;span&gt;129&lt;/span&gt;     parser.add_argument(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;--data_dir&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, type=&lt;span&gt;str,
&lt;/span&gt;&lt;span&gt;130&lt;/span&gt;                         default=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/tmp/tensorflow/mnist/input_data&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;131&lt;/span&gt;                         help=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Directory for storing input data&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;132&lt;/span&gt;     FLAGS, unparsed =&lt;span&gt; parser.parse_known_args()
&lt;/span&gt;&lt;span&gt;133&lt;/span&gt;     tf.app.run(main=main, argv=[sys.argv[0]] + unparsed)
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;datasets.py&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('e806553f-2eac-49c9-babe-15a5aa419c8c')&quot; readability=&quot;71&quot;&gt;&lt;img id=&quot;code_img_closed_e806553f-2eac-49c9-babe-15a5aa419c8c&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_e806553f-2eac-49c9-babe-15a5aa419c8c&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('e806553f-2eac-49c9-babe-15a5aa419c8c',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_e806553f-2eac-49c9-babe-15a5aa419c8c&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;137&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy
&lt;/span&gt;&lt;span&gt;  2&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; tensorflow.python.framework &lt;span&gt;import&lt;/span&gt;&lt;span&gt; dtypes
&lt;/span&gt;&lt;span&gt;  3&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; tensorflow.python.framework &lt;span&gt;import&lt;/span&gt;&lt;span&gt; random_seed
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; six.moves &lt;span&gt;import&lt;/span&gt;&lt;span&gt; xrange
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; tensorflow.contrib.learn.python.learn.datasets &lt;span&gt;import&lt;/span&gt;&lt;span&gt; base
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; pickle
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; os
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt; 
&lt;span&gt;  9&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DataSet(object):
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;Container class for a dataset (deprecated).
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt; 
&lt;span&gt; 12&lt;/span&gt; &lt;span&gt;    THIS CLASS IS DEPRECATED. See
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt; &lt;span&gt;    [contrib/learn/README.md](https://www.tensorflow.org/code/tensorflow/contrib/learn/README.md)
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt; &lt;span&gt;    for general migration instructions.
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 16&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self,
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt; &lt;span&gt;                 images,
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt; &lt;span&gt;                 labels,
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt;                  fake_data=&lt;span&gt;False,
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt;                  one_hot=&lt;span&gt;False,
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt;                  dtype=&lt;span&gt;dtypes.float32,
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt;                  reshape=&lt;span&gt;True,
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt;                  seed=&lt;span&gt;None):
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;Construct a DataSet.
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt; &lt;span&gt;        one_hot arg is used only if fake_data is true.  `dtype` can be either
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt; &lt;span&gt;        `uint8` to leave the input as `[0, 255]`, or `float32` to rescale into
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt; &lt;span&gt;        `[0, 1]`.  Seed arg provides for convenient deterministic testing.
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 29&lt;/span&gt;         seed1, seed2 =&lt;span&gt; random_seed.get_seed(seed)
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; If op level seed is not set, use whatever graph level seed is returned&lt;/span&gt;
&lt;span&gt; 31&lt;/span&gt;         numpy.random.seed(seed1 &lt;span&gt;if&lt;/span&gt; seed &lt;span&gt;is&lt;/span&gt; None &lt;span&gt;else&lt;/span&gt;&lt;span&gt; seed2)
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt;         dtype =&lt;span&gt; dtypes.as_dtype(dtype).base_dtype
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; dtype &lt;span&gt;not&lt;/span&gt; &lt;span&gt;in&lt;/span&gt;&lt;span&gt; (dtypes.uint8, dtypes.float32):
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt;             &lt;span&gt;raise&lt;/span&gt;&lt;span&gt; TypeError(
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt;                 &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Invalid image dtype %r, expected uint8 or float32&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; dtype)
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; fake_data:
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt;             self._num_examples = 10000
&lt;span&gt; 38&lt;/span&gt;             self.one_hot =&lt;span&gt; one_hot
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt;             &lt;span&gt;assert&lt;/span&gt; images.shape[0] ==&lt;span&gt; labels.shape[0], (
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt;                 &lt;span&gt;'&lt;/span&gt;&lt;span&gt;images.shape: %s labels.shape: %s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; (images.shape, labels.shape))
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt;             self._num_examples =&lt;span&gt; images.shape[0]
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt; 
&lt;span&gt; 44&lt;/span&gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Convert shape from [num examples, rows, columns, depth]&lt;/span&gt;
&lt;span&gt; 45&lt;/span&gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; to [num examples, rows*columns] (assuming depth == 1)&lt;/span&gt;
&lt;span&gt; 46&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; reshape:
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt;                 &lt;span&gt;assert&lt;/span&gt; images.shape[3] == 3
&lt;span&gt; 48&lt;/span&gt;                 images =&lt;span&gt; images.reshape(images.shape[0],
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt;                                         images.shape[1] * images.shape[2] * images.shape[3&lt;span&gt;])
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; dtype ==&lt;span&gt; dtypes.float32:
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt;                 &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Convert from [0, 255] -&amp;gt; [0.0, 1.0].&lt;/span&gt;
&lt;span&gt; 52&lt;/span&gt;                 images =&lt;span&gt; images.astype(numpy.float32)
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt;                 images = numpy.multiply(images, 1.0 / 255.0&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt;         self._images =&lt;span&gt; images
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt;         self._labels =&lt;span&gt; labels
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt;         self._epochs_completed =&lt;span&gt; 0
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt;         self._index_in_epoch =&lt;span&gt; 0
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt; 
&lt;span&gt; 59&lt;/span&gt; &lt;span&gt;    @property
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; images(self):
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; self._images
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt; 
&lt;span&gt; 63&lt;/span&gt; &lt;span&gt;    @property
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; labels(self):
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; self._labels
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt; 
&lt;span&gt; 67&lt;/span&gt; &lt;span&gt;    @property
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; num_examples(self):
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; self._num_examples
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt; 
&lt;span&gt; 71&lt;/span&gt; &lt;span&gt;    @property
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; epochs_completed(self):
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; self._epochs_completed
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt; 
&lt;span&gt; 75&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; next_batch(self, batch_size, fake_data=False, shuffle=&lt;span&gt;True):
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;Return the next `batch_size` examples from this data set.&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 77&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; fake_data:
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt;             fake_image = [1] * 784
&lt;span&gt; 79&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; self.one_hot:
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt;                 fake_label = [1] + [0] * 9
&lt;span&gt; 81&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt;                 fake_label =&lt;span&gt; 0
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; [fake_image &lt;span&gt;for&lt;/span&gt; _ &lt;span&gt;in&lt;/span&gt;&lt;span&gt; xrange(batch_size)], [
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt;                 fake_label &lt;span&gt;for&lt;/span&gt; _ &lt;span&gt;in&lt;/span&gt;&lt;span&gt; xrange(batch_size)
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt; &lt;span&gt;            ]
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt;         start =&lt;span&gt; self._index_in_epoch
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Shuffle for the first epoch&lt;/span&gt;
&lt;span&gt; 88&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; self._epochs_completed == 0 &lt;span&gt;and&lt;/span&gt; start == 0 &lt;span&gt;and&lt;/span&gt;&lt;span&gt; shuffle:
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt;             perm0 =&lt;span&gt; numpy.arange(self._num_examples)
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt; &lt;span&gt;            numpy.random.shuffle(perm0)
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt;             self._images =&lt;span&gt; self.images[perm0]
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt;             self._labels =&lt;span&gt; self.labels[perm0]
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Go to the next epoch&lt;/span&gt;
&lt;span&gt; 94&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; start + batch_size &amp;gt;&lt;span&gt; self._num_examples:
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Finished epoch&lt;/span&gt;
&lt;span&gt; 96&lt;/span&gt;             self._epochs_completed += 1
&lt;span&gt; 97&lt;/span&gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Get the rest examples in this epoch&lt;/span&gt;
&lt;span&gt; 98&lt;/span&gt;             rest_num_examples = self._num_examples -&lt;span&gt; start
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt;             images_rest_part =&lt;span&gt; self._images[start:self._num_examples]
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;             labels_rest_part =&lt;span&gt; self._labels[start:self._num_examples]
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Shuffle the data&lt;/span&gt;
&lt;span&gt;102&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; shuffle:
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt;                 perm =&lt;span&gt; numpy.arange(self._num_examples)
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt; &lt;span&gt;                numpy.random.shuffle(perm)
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt;                 self._images =&lt;span&gt; self.images[perm]
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt;                 self._labels =&lt;span&gt; self.labels[perm]
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Start next epoch&lt;/span&gt;
&lt;span&gt;108&lt;/span&gt;             start =&lt;span&gt; 0
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt;             self._index_in_epoch = batch_size -&lt;span&gt; rest_num_examples
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt;             end =&lt;span&gt; self._index_in_epoch
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt;             images_new_part =&lt;span&gt; self._images[start:end]
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt;             labels_new_part =&lt;span&gt; self._labels[start:end]
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; numpy.concatenate(
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt;                 (images_rest_part, images_new_part), axis=&lt;span&gt;0), numpy.concatenate(
&lt;/span&gt;&lt;span&gt;115&lt;/span&gt;                 (labels_rest_part, labels_new_part), axis=&lt;span&gt;0)
&lt;/span&gt;&lt;span&gt;116&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;117&lt;/span&gt;             self._index_in_epoch +=&lt;span&gt; batch_size
&lt;/span&gt;&lt;span&gt;118&lt;/span&gt;             end =&lt;span&gt; self._index_in_epoch
&lt;/span&gt;&lt;span&gt;119&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; self._images[start:end], self._labels[start:end]
&lt;/span&gt;&lt;span&gt;120&lt;/span&gt; 
&lt;span&gt;121&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; read_data_sets(train_dir,
&lt;/span&gt;&lt;span&gt;122&lt;/span&gt;                    one_hot=&lt;span&gt;False,
&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;                    dtype=&lt;span&gt;dtypes.float32,
&lt;/span&gt;&lt;span&gt;124&lt;/span&gt;                    reshape=&lt;span&gt;True,
&lt;/span&gt;&lt;span&gt;125&lt;/span&gt;                    validation_size=5000&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;126&lt;/span&gt;                    seed=&lt;span&gt;None):
&lt;/span&gt;&lt;span&gt;127&lt;/span&gt; 
&lt;span&gt;128&lt;/span&gt; 
&lt;span&gt;129&lt;/span&gt; 
&lt;span&gt;130&lt;/span&gt; 
&lt;span&gt;131&lt;/span&gt;     train_images,train_labels,test_images,test_labels =&lt;span&gt; load_CIFAR10(train_dir)
&lt;/span&gt;&lt;span&gt;132&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; 0 &amp;lt;= validation_size &amp;lt;=&lt;span&gt; len(train_images):
&lt;/span&gt;&lt;span&gt;133&lt;/span&gt;         &lt;span&gt;raise&lt;/span&gt; ValueError(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Validation size should be between 0 and {}. Received: {}.&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;134&lt;/span&gt; &lt;span&gt;                         .format(len(train_images), validation_size))
&lt;/span&gt;&lt;span&gt;135&lt;/span&gt; 
&lt;span&gt;136&lt;/span&gt;     validation_images =&lt;span&gt; train_images[:validation_size]
&lt;/span&gt;&lt;span&gt;137&lt;/span&gt;     validation_labels =&lt;span&gt; train_labels[:validation_size]
&lt;/span&gt;&lt;span&gt;138&lt;/span&gt;     validation_labels = dense_to_one_hot(validation_labels, 10&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;139&lt;/span&gt;     train_images =&lt;span&gt; train_images[validation_size:]
&lt;/span&gt;&lt;span&gt;140&lt;/span&gt;     train_labels =&lt;span&gt; train_labels[validation_size:]
&lt;/span&gt;&lt;span&gt;141&lt;/span&gt;     train_labels = dense_to_one_hot(train_labels, 10&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;142&lt;/span&gt; 
&lt;span&gt;143&lt;/span&gt;     test_labels = dense_to_one_hot(test_labels, 10&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;144&lt;/span&gt; 
&lt;span&gt;145&lt;/span&gt;     options = dict(dtype=dtype, reshape=reshape, seed=&lt;span&gt;seed)
&lt;/span&gt;&lt;span&gt;146&lt;/span&gt;     train = DataSet(train_images, train_labels, **&lt;span&gt;options)
&lt;/span&gt;&lt;span&gt;147&lt;/span&gt;     validation = DataSet(validation_images, validation_labels, **&lt;span&gt;options)
&lt;/span&gt;&lt;span&gt;148&lt;/span&gt;     test = DataSet(test_images, test_labels, **&lt;span&gt;options)
&lt;/span&gt;&lt;span&gt;149&lt;/span&gt; 
&lt;span&gt;150&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; base.Datasets(train=train, validation=validation, test=&lt;span&gt;test)
&lt;/span&gt;&lt;span&gt;151&lt;/span&gt; 
&lt;span&gt;152&lt;/span&gt; 
&lt;span&gt;153&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; load_CIFAR_batch(filename):
&lt;/span&gt;&lt;span&gt;154&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt; load single batch of cifar &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;155&lt;/span&gt;     with open(filename, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;rb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) as f:
&lt;/span&gt;&lt;span&gt;156&lt;/span&gt;         datadict = pickle.load(f, encoding=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;bytes&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;157&lt;/span&gt;         X = datadict[b&lt;span&gt;'&lt;/span&gt;&lt;span&gt;data&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;158&lt;/span&gt;         Y = datadict[b&lt;span&gt;'&lt;/span&gt;&lt;span&gt;labels&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;159&lt;/span&gt;         X = X.reshape(10000, 3, 32, 32).transpose(0,2,3,1).astype(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;float&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;160&lt;/span&gt;         Y =&lt;span&gt; numpy.array(Y)
&lt;/span&gt;&lt;span&gt;161&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; X, Y
&lt;/span&gt;&lt;span&gt;162&lt;/span&gt; 
&lt;span&gt;163&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; load_CIFAR10(ROOT):
&lt;/span&gt;&lt;span&gt;164&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt; load all of cifar &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;165&lt;/span&gt;     xs =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt;166&lt;/span&gt;     ys =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt;167&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; b &lt;span&gt;in&lt;/span&gt; range(1,6&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;168&lt;/span&gt;         f = os.path.join(ROOT, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;data_batch_%d&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; (b, ))
&lt;/span&gt;&lt;span&gt;169&lt;/span&gt;         X, Y =&lt;span&gt; load_CIFAR_batch(f)
&lt;/span&gt;&lt;span&gt;170&lt;/span&gt; &lt;span&gt;        xs.append(X)
&lt;/span&gt;&lt;span&gt;171&lt;/span&gt; &lt;span&gt;        ys.append(Y)
&lt;/span&gt;&lt;span&gt;172&lt;/span&gt;     Xtr =&lt;span&gt; numpy.concatenate(xs)
&lt;/span&gt;&lt;span&gt;173&lt;/span&gt;     Ytr =&lt;span&gt; numpy.concatenate(ys)
&lt;/span&gt;&lt;span&gt;174&lt;/span&gt;     &lt;span&gt;del&lt;/span&gt;&lt;span&gt; X, Y
&lt;/span&gt;&lt;span&gt;175&lt;/span&gt;     Xte, Yte = load_CIFAR_batch(os.path.join(ROOT, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;test_batch&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;176&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Xtr, Ytr, Xte, Yte
&lt;/span&gt;&lt;span&gt;177&lt;/span&gt; 
&lt;span&gt;178&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; dense_to_one_hot(labels_dense, num_classes):
&lt;/span&gt;&lt;span&gt;179&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;Convert class labels from scalars to one-hot vectors.&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;180&lt;/span&gt;     num_labels =&lt;span&gt; labels_dense.shape[0]
&lt;/span&gt;&lt;span&gt;181&lt;/span&gt;     index_offset = numpy.arange(num_labels) *&lt;span&gt; num_classes
&lt;/span&gt;&lt;span&gt;182&lt;/span&gt;     labels_one_hot =&lt;span&gt; numpy.zeros((num_labels, num_classes))
&lt;/span&gt;&lt;span&gt;183&lt;/span&gt;     labels_one_hot.flat[index_offset + labels_dense.ravel()] = 1
&lt;span&gt;184&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; labels_one_hot
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;h2&gt;&lt;span&gt;4.运行结果以及分析&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;这里选取55000张图片作为训练样本，测试样本选取5000张。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;tensorboard可视流程图&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/797382/201904/797382-20190419231134645-816503701.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;运行5000次，准确率：58%&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/797382/201904/797382-20190419230713937-1125268045.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;运行20000次，准确率：68.89%&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/797382/201904/797382-20190419231032201-1623033410.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;运行40000次，准确率：100%&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/797382/201904/797382-20190419231043549-152289779.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不要让懒惰占据你的大脑，不要让妥协拖垮了你的人生。青春就是一张票，能不能赶上时代的快车，你的步伐就掌握在你的脚下。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 19 Apr 2019 15:16:00 +0000</pubDate>
<dc:creator>w_x_w1985</dc:creator>
<og:description>用Tensorflow实现卷积神经网络(CNN) 本文系作者原创，转载请注明出处:https://www.cnblogs.com/further-further-further/p/10737065.</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/further-further-further/p/10737065.html</dc:identifier>
</item>
<item>
<title>关于 iOS 性能优化方面的面试题， - 原来是泽镜啊</title>
<link>http://www.cnblogs.com/Mcci7/p/10739293.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Mcci7/p/10739293.html</guid>
<description>&lt;p&gt;&lt;strong&gt;这是我前面几天碰到的面试题：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如何对定位和分析项目中影响性能的地方？以及如何进行性能优化？&lt;/p&gt;
&lt;p&gt;我的答案：&lt;/p&gt;
&lt;p&gt;定位方法：&lt;/p&gt;
&lt;p&gt;instruments&lt;/p&gt;
&lt;p&gt;  在iOS上进行性能分析的时候，首先考虑借助instruments这个利器分析出问题出在哪，不要凭空想象，不然你可能把精力花在了1%的问题上，最后发现其实啥都没优化，比如要查看程序哪些部分最耗时，可以使用Time Profiler，要查看内存是否泄漏了，可以使用Leaks等。关于instruments网上有很多资料，作为一个合格iOS开发者，熟悉这个工具还是很有必要的。&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;作为一个开发者，有一个学习的氛围跟一个交流圈子特别重要，这是一个我的iOS交流群：638302184，不管你是小白还是大牛欢迎入驻 ，分享BAT,阿里面试题、面试经验，讨论技术， 大家一起交流学习成长！希望帮助开发者少走弯路。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;优化建议：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.用ARC管理内存&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;* ARC(Automatic Reference Counting, 自动引用计数)和iOS5一起发布，它避免了最常见的也就是经常是由于我们忘记释放内存所造成的内存泄露。它自动为你管理retain和release的过程，所以你就不必去手动干预了。下面是你会经常用来去创建一个View的代码段:  UIView *view = [[UIView alloc] init];&lt;/p&gt;
&lt;p&gt;*    // ...&lt;/p&gt;
&lt;p&gt;*   [self.view addSubview:view];&lt;/p&gt;
&lt;p&gt;*    [view release];&lt;/p&gt;
&lt;p&gt;* 忘掉代码段结尾的release简直像记得吃饭一样简单。而ARC会自动在底层为你做这些工作。除了帮你避免内存泄露，ARC还可以帮你提高性能，它能保证释放掉不再需要的对象的内存。这都啥年代了，你应该在你的所有项目里使用ARC!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.在正确的地方使用 reuseIdentifier&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;* 一个开发中常见的错误就是没有给UITableViewCells， UICollectionViewCells，甚至是UITableViewHeaderFooterViews设置正确的reuseIdentifier。&lt;/p&gt;
&lt;p&gt;* 为了性能最优化，table view用 tableView:cellForRowAtIndexPath: 为rows分配cells的时候，它的数据应该重用自UITableViewCell。 一个table view维持一个队列的数据可重用的UITableViewCell对象。不使用reuseIdentifier的话，每显示一行table view就不得不设置全新的cell。这对性能的影响可是相当大的，尤其会使app的滚动体验大打折扣。&lt;/p&gt;
&lt;p&gt;* 自iOS6起，除了UICollectionView的cells和补充views，你也应该在header和footer views中使用reuseIdentifiers&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.尽量把views设置为完全不透明&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;* 如果你有透明的Views你应该设置它们的opaque(不透明)属性为YES。例如一个黑色半透明的可以设置为一个灰色不透明的View替代.原因是这会使系统用一个最优的方式渲染这些views。这个简单的属性在IB或者代码里都可以设定。&lt;/p&gt;
&lt;p&gt;* Apple的文档对于为图片设置透明属性的描述是：&lt;/p&gt;
&lt;p&gt;* (opaque)这个属性给渲染系统提供了一个如何处理这个view的提示。如果设为YES， 渲染系统就认为这个view是完全不透明的，这使得渲染系统优化一些渲染过程和提高性能。如果设置为NO，渲染系统正常地和其它内容组成这个View。默认值是YES。&lt;/p&gt;
&lt;p&gt;* 在相对比较静止的画面中，设置这个属性不会有太大影响。然而当这个view嵌在scroll view里边，或者是一个复杂动画的一部分，不设置这个属性的话会在很大程度上影响app的性能。&lt;/p&gt;
&lt;p&gt;* 换种说法，大家可能更好理解：只要一个视图的不透明度小于1,就会导致blending.blending操作在iOS的图形处理器（GPU）中完成的,blending主要指的是混合像素颜色的计算。举个例子,我们把两个图层叠加在一起,如果第一个图层的有透明效果,则最终像素的颜色计算需要将第二个图层也考虑进来。这一过程即为Blending。为什么Blending会导致性能的损失？原因是很直观的,如果一个图层是完全不透明的,则系统直接显示该图层的颜色即可。而如果图层是带透明效果的,则会引入更多的计算,因为需要把下面的图层也包括进来,进行混合后颜色的计算。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4. 避免过于庞大的XIB&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;* iOS5中加入的Storyboards(分镜)正在快速取代XIB。然而XIB在一些场景中仍然很有用。比如你的app需要适应iOS5之前的设备，或者你有一个自定义的可重用的view,你就不可避免地要用到他们。&lt;/p&gt;
&lt;p&gt;* 如果你不得不XIB的话，使他们尽量简单。尝试为每个Controller配置一个单独的XIB，尽可能把一个View Controller的view层次结构分散到单独的XIB中去。&lt;/p&gt;
&lt;p&gt;* 需要注意的是，当你加载一个XIB的时候所有内容都被放在了内存里，包括任何图片。如果有一个不会即刻用到的view，你这就是在浪费宝贵的内存资源了。Storyboards就是另一码事儿了，storyboard仅在需要时实例化一个view controller.&lt;/p&gt;
&lt;p&gt;* 当你加载一个引用了图片或者声音资源的nib时，nib加载代码会把图片和声音文件写进内存。在OS X中，图片和声音资源被缓存在named cache中以便将来用到时获取。在iOS中，仅图片资源会被存进named caches。取决于你所在的平台，使用NSImage 或UIImage 的imageNamed:方法来获取图片资源。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5. 不要阻塞主线程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;* 永远不要使主线程承担过多。因为UIKit在主线程上做所有工作，渲染，管理触摸反应，回应输入等都需要在它上面完成。一直使用主线程的风险就是如果你的代码真的block了主线程，你的app会失去反应&lt;/p&gt;
&lt;p&gt;* 大部分阻碍主进程的情形是你的app在做一些牵涉到读写外部资源的I/O操作，比如存储或者网络。或者使用像 AFNetworking这样的框架来异步地做这些操作。如果你需要做其它类型的需要耗费巨大资源的操作(比如时间敏感的计算或者存储读写)那就用 Grand Central Dispatch，或者 NSOperation 和 NSOperationQueues.你可以使用NSURLConnection异步地做网络操作:  + (void)sendAsynchronousRequest:(NSURLRequest *)request queue:(NSOperationQueue *)queue completionHandler:(void (^)(NSURLResponse*, NSData*, NSError*))handler&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6. 在Image Views中调整图片大小&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;* 如果要在UIImageView中显示一个来自bundle的图片，你应保证图片的大小和UIImageView的大小相同。在运行中缩放图片是很耗费资源的，特别是UIImageView嵌套在UIScrollView中的情况下。&lt;/p&gt;
&lt;p&gt;* 如果图片是从远端服务加载的你不能控制图片大小，比如在下载前调整到合适大小的话，你可以在下载完成后，最好是用background thread，缩放一次，然后在UIImageView中使用缩放后的图片。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;7. 选择正确的Collection&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;学会选择对业务场景最合适的类或者对象是写出能效高的代码的基础。当处理collections时这句话尤其正确。&lt;/p&gt;
&lt;p&gt;Apple有一个 Collections Programming Topics 的文档详尽介绍了可用的classes间的差别和你该在哪些场景中使用它们。这对于任何使用collections的人来说是一个必读的文档。&lt;/p&gt;
&lt;p&gt;呵呵，我就知道你因为太长没看…这是一些常见collection的总结：&lt;/p&gt;
&lt;p&gt;* Arrays: 有序的一组值。使用index来lookup很快，使用value lookup很慢， 插入/删除很慢。&lt;/p&gt;
&lt;p&gt;* Dictionaries: 存储键值对。 用键来查找比较快。&lt;/p&gt;
&lt;p&gt;* Sets: 无序的一组值。用值来查找很快，插入/删除很快。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;8. 打开gzip压缩&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;* 大量app依赖于远端资源和第三方API，你可能会开发一个需要从远端下载XML, JSON, HTML或者其它格式的app。&lt;/p&gt;
&lt;p&gt;* 问题是我们的目标是移动设备，因此你就不能指望网络状况有多好。一个用户现在还在edge网络，下一分钟可能就切换到了3G。不论什么场景，你肯定不想让你的用户等太长时间。&lt;/p&gt;
&lt;p&gt;* 减小文档的一个方式就是在服务端和你的app中打开gzip。这对于文字这种能有更高压缩率的数据来说会有更显著的效用。好消息是，iOS已经在NSURLConnection中默认支持了gzip压缩，当然AFNetworking这些基于它的框架亦然。像Google App Engine这些云服务提供者也已经支持了压缩输出。&lt;/p&gt;
</description>
<pubDate>Fri, 19 Apr 2019 14:41:00 +0000</pubDate>
<dc:creator>原来是泽镜啊</dc:creator>
<og:description>这是我前面几天碰到的面试题： 如何对定位和分析项目中影响性能的地方？以及如何进行性能优化？ 我的答案： 定位方法： instruments 在iOS上进行性能分析的时候，首先考虑借助instrumen</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Mcci7/p/10739293.html</dc:identifier>
</item>
<item>
<title>final,finally,finalize有什么区别？String, StringBuffer, StringBuilder有什么区别？Exception和Error有什么区别？ - 程序员姜小白</title>
<link>http://www.cnblogs.com/jpcflyer/p/10739217.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jpcflyer/p/10739217.html</guid>
<description>&lt;p&gt;&lt;span&gt;继上篇JVM学习之后，后面将分三期深入介绍剩余JAVA基础面试题，每期3题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;题目一、final,finally,finalize有什么区别？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;/*请尊重作者劳动成果，转载请标明原文链接：*/&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/jpcflyer/p/10739217.html&quot;&gt;/* https://www.cnblogs.com/jpcflyer/p/10739217.html* /&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;大家一般都这么回答：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;final 可以用来修饰类、方法、变量，分别有不同的意义，final 修饰的 class 代表不可以继承扩展，final 的变量是不可以修改的，而 final 的方法也是不可以重写的（override）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;finally 则是 Java 保证重点代码一定要被执行的一种机制。我们可以使用 try-finally 或者 try-catch-finally 来进行类似关闭 JDBC 连接、保证 unlock 锁等动作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;finalize 是基础类 java.lang.Object 的一个方法，它的设计目的是保证对象在被垃圾收集前完成特定资源的回收。finalize 机制现在已经不推荐使用，并且在 JDK 9 开始被标记为 deprecated。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;从语法层次，这样说完是没有问题的，但让我们深入一下，什么时候会用到final?&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果你关注过 Java 核心类库的定义或源码， 有没有发现 java.lang 包下面的很多类，相当一部分都被声明成为 final class？在第三方类库的一些基础类中同样如此，这可以有效避免 API 使用者更改基础功能，某种程度上，这是保证平台安全的必要手段。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用 final 修饰参数或者变量，也可以清楚地避免意外赋值导致的编程错误，甚至，有人明确推荐将所有方法参数、本地变量、成员变量声明成 final。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;final 变量产生了某种程度的不可变（immutable）的效果，所以，可以用于保护只读数据，尤其是在并发编程中，因为明确地不能再赋值 final 变量，有利于减少额外的同步开销，也可以省去一些防御性拷贝的必要。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;另外，有一些常被考到的 finally 问题（也比较偏门），至少需要了解一下。比如，下面代码会输出什么？&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;8.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;1&lt;/span&gt; &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; do something&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;   System.exit(1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; } &lt;span&gt;finally&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;   System.out.println(“Print from &lt;span&gt;finally&lt;/span&gt;&lt;span&gt;”);
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;上面 finally 里面的代码可不会被执行的哦，这是一个特例。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;如果需要关闭连接等资源，推荐使用 Java 7 中添加的 try-with-resources 语句，因为通常 Java 平台能够更好地处理异常情况，编码量也要少很多，何乐而不为呢。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于 finalize，我们要明确它是不推荐使用的，业界实践一再证明它不是个好的办法，在 Java 9 中，甚至明确将 Object.finalize() 标记为 deprecated！如果没有特别的原因，不要实现 finalize 方法，也不要指望利用它来进行资源回收。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为什么呢？简单说，你无法保证 finalize 什么时候执行，执行的是否符合预期。使用不当会影响性能，导致程序死锁、挂起等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;题目二、String, StringBuffer, StringBuilder有什么区别？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div readability=&quot;52.589743589744&quot;&gt;
&lt;p&gt;&lt;span&gt;接下来聊一聊日常使用的字符串，别看它似乎简单，但实际上字符串涉及到的知识点特别多，在编程的大部分时候也都是在和字符串打交道。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一般回答：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; String 是 Java 语言非常基础和重要的类，提供了构造和管理字符串的各种基本逻辑。它是典型的 Immutable 类，被声明成为 final class，所有属性也都是 final 的。也由于它的不可变性，类似拼接、裁剪字符串等动作，都会产生新的 String 对象。由于字符串操作的普遍性，所以相关操作的效率往往对应用性能有明显影响。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;StringBuffer 是为解决上面提到拼接产生太多中间对象的问题而提供的一个类，我们可以用 append 或者 add 方法，把字符串添加到已有序列的末尾或者指定位置。StringBuffer 本质是一个线程安全的可修改字符序列，它保证了线程安全，也随之带来了额外的性能开销，所以除非有线程安全的需要，不然还是推荐使用它的后继者，也就是 StringBuilder。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;StringBuilder 是 Java 1.5 中新增的，在能力上和 StringBuffer 没有本质区别，但是它去掉了线程安全的部分，有效减小了开销，是绝大部分情况下进行字符串拼接的首选。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;再继续扩展一下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先看看 StringBuffer 实现的一些细节，它的 线程安全是通过把各种修改数据的方法都加上 synchronized 关键字实现的，非常直白。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为了实现修改字符序列的目的，StringBuffer 和 StringBuilder 底层都是利用可修改的（char，JDK 9 以后是 byte）数组，二者都继承了 AbstractStringBuilder，里面包含了基本操作，区别仅在于最终的方法是否加了 synchronized。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;另外，这个内部数组应该创建成多大的呢？如果太小，拼接的时候可能要重新创建足够大的数组；如果太大，又会浪费空间。目前的实现是，构建时初始字符串长度加 16（这意味着，如果没有构建对象时输入最初的字符串，那么初始值就是 16）。我们如果确定拼接会发生非常多次，而且大概是可预计的，那么就可以指定合适的大小，避免很多次扩容的开销。扩容会产生多重开销，因为要抛弃原有数组，创建新的（可以简单认为是倍数）数组，还要进行 arraycopy。&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;&lt;span&gt;题目三、Exception和Error有什么区别？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;直接看JAVA异常结构吧，JAVA异常的继承结构：Throwable为基类，Error和Exception继承Throwable，RuntimeException和IOException等继承Exception。Error和RuntimeException及其子类成为未检查异常（unchecked），其它异常成为已检查异常（checked）。 &lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/364723/201904/364723-20190419222906819-1750079486.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;file:///C:/Users/jiang/AppData/Local/Temp/enhtmlclip/Image.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;Error异常&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;Error表示程序在运行期间出现了十分严重、不可恢复的错误，在这种情况下应用程序只能中止运行，例如JAVA 虚拟机出现错误。Error是一种unchecked Exception，编译器不会检查Error是否被处理，在程序中不用捕获Error类型的异常。一般情况下，在程序中也不应该抛出Error类型的异常。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;RuntimeException异常&lt;/span&gt;&lt;/h3&gt;
&lt;div readability=&quot;12&quot;&gt;
&lt;p&gt;&lt;span&gt;Exception异常包括RuntimeException异常和其他非RuntimeException的异常。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RuntimeException 是一种Unchecked Exception，即表示编译器不会检查程序是否对RuntimeException作了处理，在程序中不必捕获RuntimException类型的异常，也不必在方法体声明抛出RuntimeException类。RuntimeException发生的时候，表示程序中出现了编程错误，所以应该找出错误修改程序，而不是去捕获RuntimeException。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;Checked Exception异常&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;Checked Exception异常，这也是在编程中使用最多的Exception，所有继承自Exception并且不是RuntimeException的异常都是checked Exception，上图中的IOException和ClassNotFoundException。JAVA 语言规定必须对checked Exception作处理，编译器会对此作检查，要么在方法体中声明抛出checked Exception，要么使用catch语句捕获checked Exception进行处理，不然不能通过编译。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Fri, 19 Apr 2019 14:35:00 +0000</pubDate>
<dc:creator>程序员姜小白</dc:creator>
<og:description>继上篇JVM学习之后，后面将分三期深入介绍剩余JAVA基础面试题，每期3题。 题目一、final,finally,finalize有什么区别？ /*请尊重作者劳动成果，转载请标明原文链接：*/ /*</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jpcflyer/p/10739217.html</dc:identifier>
</item>
<item>
<title>[深度应用]·使用一维卷积神经网络处理时间序列数据 - 小宋是呢</title>
<link>http://www.cnblogs.com/xiaosongshine/p/10739257.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaosongshine/p/10739257.html</guid>
<description>&lt;h3&gt;概述&lt;/h3&gt;
&lt;p&gt;许多技术文章a都关注于二维卷积神经网络（2D CNN）的使用，特别是在图像识别中的应用。而一维卷积神经网络（1D CNNs）只在一定程度上有所涉及，比如在自然语言处理（NLP）中的应用。目前很少有文章能够提供关于如何构造一维卷积神经网络来解决你可能正面临的一些机器学习问题。本文试图补上这样一个短板。&lt;/p&gt;


&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;11&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://user-gold-cdn.xitu.io/2018/11/14/1670fbdb627a3924?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt=&quot;&quot; data-cke-saved-src=&quot;https://user-gold-cdn.xitu.io/2018/11/14/1670fbdb627a3924?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://user-gold-cdn.xitu.io/2018/11/14/1670fbdb627a3924?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;



&lt;h3&gt;何时应用 1D CNN？&lt;/h3&gt;
&lt;p&gt;CNN 可以很好地识别出数据中的简单模式，然后使用这些简单模式在更高级的层中生成更复杂的模式。当你希望从整体数据集中较短的（固定长度）片段中获得感兴趣特征，并且该特性在该数据片段中的位置不具有高度相关性时，1D CNN 是非常有效的。&lt;/p&gt;
&lt;p&gt;1D CNN 可以很好地应用于传感器数据的时间序列分析（比如陀螺仪或加速度计数据）；同样也可以很好地用于分析具有固定长度周期的信号数据（比如音频信号）。此外，它还能应用于自然语言处理的任务（由于单词的接近性可能并不总是一个可训练模式的好指标，因此 LSTM 网络在 NLP 中的应用更有前途）。&lt;/p&gt;
&lt;h3&gt;1D CNN 和 2D CNN 之间有什么区别？&lt;/h3&gt;
&lt;p&gt;无论是一维、二维还是三维，卷积神经网络（CNNs）都具有相同的特点和相同的处理方法。关键区别在于输入数据的维数以及特征检测器（或滤波器）如何在数据之间滑动：&lt;/p&gt;


&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;10&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://user-gold-cdn.xitu.io/2018/11/14/1670fbdb71a2407a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt=&quot;&quot; data-cke-saved-src=&quot;https://user-gold-cdn.xitu.io/2018/11/14/1670fbdb71a2407a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://user-gold-cdn.xitu.io/2018/11/14/1670fbdb71a2407a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;



&lt;p&gt;“一维和二维卷积神经网络” 由 Nils Ackermann 在知识共享许可 &lt;a href=&quot;https://link.juejin.im/?target=https%3A%2F%2Fcreativecommons.org%2Flicenses%2Fby-nd%2F4.0%2F&quot; data-cke-saved-href=&quot;https://link.juejin.im/?target=https%3A%2F%2Fcreativecommons.org%2Flicenses%2Fby-nd%2F4.0%2F&quot;&gt;CC BY-ND 4.0&lt;/a&gt; 下授权。&lt;/p&gt;
&lt;h3&gt;问题描述&lt;/h3&gt;
&lt;p&gt;在本文中，我们将专注于基于时间片的加速度传感器数据的处理，这些数据来自于用户的腰带式智能手机设备。基于 x、y 和 z 轴的加速度计数据，1D CNN 用来预测用户正在进行的活动类型（比如“步行”、“慢跑”或“站立”）。你可以在我的另外两篇文章中找到更多的信息 &lt;a href=&quot;https://link.juejin.im/?target=https%3A%2F%2Fmedium.com%2F%40nils.ackermann%2Fhuman-activity-recognition-har-tutorial-with-keras-and-core-ml-part-1-8c05e365dfa0&quot; data-cke-saved-href=&quot;https://link.juejin.im/?target=https%3A%2F%2Fmedium.com%2F%40nils.ackermann%2Fhuman-activity-recognition-har-tutorial-with-keras-and-core-ml-part-1-8c05e365dfa0&quot;&gt;这里&lt;/a&gt; 和 &lt;a href=&quot;https://link.juejin.im/?target=https%3A%2F%2Fmedium.com%2F%40nils.ackermann%2Fhuman-activity-recognition-har-tutorial-with-keras-and-core-ml-part-2-857104583d94&quot; data-cke-saved-href=&quot;https://link.juejin.im/?target=https%3A%2F%2Fmedium.com%2F%40nils.ackermann%2Fhuman-activity-recognition-har-tutorial-with-keras-and-core-ml-part-2-857104583d94&quot;&gt;这里&lt;/a&gt;。对于各种活动，在每个时间间隔上的数据看起来都与此类似。&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;9&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://user-gold-cdn.xitu.io/2018/11/14/1670fbdb764ba724?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt=&quot;&quot; data-cke-saved-src=&quot;https://user-gold-cdn.xitu.io/2018/11/14/1670fbdb764ba724?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://user-gold-cdn.xitu.io/2018/11/14/1670fbdb764ba724?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;来自加速度计数据的时间序列样例&lt;/p&gt;
&lt;h3&gt;如何在 PYTHON 中构造一个 1D CNN？&lt;/h3&gt;
&lt;p&gt;目前已经有许多得标准 CNN 模型可用。我选择了 &lt;a href=&quot;https://link.juejin.im/?target=https%3A%2F%2Fkeras.io%2Fgetting-started%2Fsequential-model-guide%2F&quot; data-cke-saved-href=&quot;https://link.juejin.im/?target=https%3A%2F%2Fkeras.io%2Fgetting-started%2Fsequential-model-guide%2F&quot;&gt;Keras 网站&lt;/a&gt; 上描述的一个模型，并对它进行了微调，以适应前面描述的问题。下面的图片对构建的模型进行一个高级概述。其中每一层都将会进一步加以解释。&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;8&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://user-gold-cdn.xitu.io/2018/11/14/1670fbdb89079cc9?imageslim&quot; alt=&quot;&quot; data-cke-saved-src=&quot;https://user-gold-cdn.xitu.io/2018/11/14/1670fbdb89079cc9?imageslim&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://user-gold-cdn.xitu.io/2018/11/14/1670fbdb89079cc9?imageslim&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;“一维卷积神经网络示例”由 Nils Ackermann 在知识共享许可 &lt;a href=&quot;https://link.juejin.im/?target=https%3A%2F%2Fcreativecommons.org%2Flicenses%2Fby-nd%2F4.0%2F&quot; data-cke-saved-href=&quot;https://link.juejin.im/?target=https%3A%2F%2Fcreativecommons.org%2Flicenses%2Fby-nd%2F4.0%2F&quot;&gt;CC BY-ND 4.0&lt;/a&gt; 下授权。&lt;/p&gt;
&lt;p&gt;让我们先来看一下对应的 Python 代码，以便构建这个模型：&lt;/p&gt;

&lt;p&gt;运行这段代码将得到如下的深层神经网络：&lt;/p&gt;

&lt;p&gt;让我们深入到每一层中，看看到底发生了什么：&lt;/p&gt;
&lt;ul readability=&quot;14.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;输入数据：&lt;/strong&gt; 数据经过预处理后，每条数据记录中包含有 80 个时间片（数据是以 20Hz 的采样频率进行记录的，因此每个时间间隔中就包含有 4 秒的加速度计数据）。在每个时间间隔内，存储加速度计的 x 轴、 y 轴和 z 轴的三个数据。这样就得到了一个 80 x 3 的矩阵。由于我通常是在 iOS 系统中使用神经网络的，所以数据必须平展成长度为 240 的向量后传入神经网络中。网络的第一层必须再将其变形为原始的 80 x 3 的形状。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;第一个 1D CNN 层：&lt;/strong&gt; 第一层定义了高度为 10（也称为卷积核大小）的滤波器（也称为特征检测器）。只有定义了一个滤波器，神经网络才能够在第一层中学习到一个单一的特征。这可能还不够，因此我们会定义 100 个滤波器。这样我们就在网络的第一层中训练得到 100 个不同的特性。第一个神经网络层的输出是一个 71 x 100 的矩阵。输出矩阵的每一列都包含一个滤波器的权值。在定义内核大小并考虑输入矩阵长度的情况下，每个过滤器将包含 71 个权重值。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;第二个 1D CNN 层：&lt;/strong&gt; 第一个 CNN 的输出结果将被输入到第二个 CNN 层中。我们将在这个网络层上再次定义 100 个不同的滤波器进行训练。按照与第一层相同的逻辑，输出矩阵的大小为 62 x 100。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;最大值池化层：&lt;/strong&gt; 为了减少输出的复杂度和防止数据的过拟合，在 CNN 层之后经常会使用池化层。在我们的示例中，我们选择了大小为 3 的池化层。这意味着这个层的输出矩阵的大小只有输入矩阵的三分之一。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;第三和第四个 1D CNN 层：&lt;/strong&gt; 为了学习更高层次的特征，这里又使用了另外两个 1D CNN 层。这两层之后的输出矩阵是一个 2 x 160 的矩阵。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;平均值池化层：&lt;/strong&gt; 多添加一个池化层，以进一步避免过拟合的发生。这次的池化不是取最大值，而是取神经网络中两个权重的平均值。输出矩阵的大小为 1 x 160 。每个特征检测器在神经网络的这一层中只剩下一个权重。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;Dropout 层：&lt;/strong&gt; Dropout 层会随机地为网络中的神经元赋值零权重。由于我们选择了 0.5 的比率，则 50% 的神经元将会是零权重的。通过这种操作，网络对数据的微小变化的响应就不那么敏感了。因此，它能够进一步提高对不可见数据处理的准确性。这个层的输出仍然是一个 1 x 160 的矩阵。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;使用 Softmax 激活的全连接层：&lt;/strong&gt; 最后一层将会把长度为 160 的向量降为长度为 6 的向量，因为我们有 6 个类别要进行预测（即 “慢跑”、“坐下”、“走路”、“站立”、“上楼”、“下楼”）。这里的维度下降是通过另一个矩阵乘法来完成的。Softmax 被用作激活函数。它强制神经网络的所有六个输出值的加和为一。因此，输出值将表示这六个类别中的每个类别出现的概率。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;训练和测试该神经网络&lt;/h3&gt;
&lt;p&gt;下面是一段用以训练模型的 Python 代码，批大小为 400，其中训练集和验证集的分割比例是 80 比 20。&lt;/p&gt;

&lt;p&gt;该模型在训练数据上的准确率可达 97%。&lt;/p&gt;

&lt;p&gt;根据测试集数据进行测试，其准确率为 92%。&lt;/p&gt;

&lt;p&gt;考虑到我们使用的是标准的 1D CNN 模型，得到这样的结果已经很好了。我们的模型在精度（precision）、召回率（recall）和 f1 值（f1-score）上的得分也很高。&lt;/p&gt;

&lt;p&gt;下面对这些分数的含义做一个简要回顾：&lt;/p&gt;


&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;1&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://user-gold-cdn.xitu.io/2018/11/14/1670fbdb6f6c5c5b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt=&quot;&quot; data-cke-saved-src=&quot;https://user-gold-cdn.xitu.io/2018/11/14/1670fbdb6f6c5c5b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://user-gold-cdn.xitu.io/2018/11/14/1670fbdb6f6c5c5b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;



&lt;p&gt;“预测和结果矩阵”由 Nils Ackermann 在知识共享 &lt;a href=&quot;https://link.juejin.im/?target=https%3A%2F%2Fcreativecommons.org%2Flicenses%2Fby-nd%2F4.0%2F&quot; data-cke-saved-href=&quot;https://link.juejin.im/?target=https%3A%2F%2Fcreativecommons.org%2Flicenses%2Fby-nd%2F4.0%2F&quot;&gt;CC BY-ND 4.0&lt;/a&gt; 许可下授权。&lt;/p&gt;
&lt;ul readability=&quot;3&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;精确度（Accuracy）：&lt;/strong&gt; 正确预测的结果与所有预测的结果总和之比。即 ((TP + TN) / (TP + TN + FP + FN))&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;精度（Precision）：&lt;/strong&gt; 当模型预测为正样本时，它是对的吗？所有的正确预测的正样本除以所有的正样本预测。即 (TP / (TP + FP))&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;召回率（Recall）：&lt;/strong&gt; 为模型识别出的所有正样本中有多少是正确预测的正样本？正确预测的正样本除以所有的正样本预测。即 (TP / (TP + FN))&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;F1值（F1-score）：&lt;/strong&gt; 是精度和召回率的加权平均值。即 (2 x recall x precision / (recall + precision))&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;测试数据上对应的混淆矩阵如下所示。&lt;/p&gt;


&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;0&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://user-gold-cdn.xitu.io/2018/11/14/1670fbdb673e350f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt=&quot;&quot; data-cke-saved-src=&quot;https://user-gold-cdn.xitu.io/2018/11/14/1670fbdb673e350f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://user-gold-cdn.xitu.io/2018/11/14/1670fbdb673e350f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;



&lt;h3&gt;总结&lt;/h3&gt;
&lt;p&gt;本文通过以智能手机的加速度计数据来预测用户的行为为例，绍了如何使用 1D CNN 来训练网络。完整的 Python 代码可以在 &lt;a href=&quot;https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fni79ls%2Fhar-keras-cnn&quot; data-cke-saved-href=&quot;https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fni79ls%2Fhar-keras-cnn&quot;&gt;github&lt;/a&gt; 上找到。&lt;/p&gt;
&lt;h3&gt;链接与引用&lt;/h3&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-0.88235294117647&quot;&gt;
&lt;p&gt;Keras &lt;a href=&quot;https://link.juejin.im/?target=https%3A%2F%2Fkeras.io%2Flayers%2Fconvolutional%2F%23conv1d&quot; data-cke-saved-href=&quot;https://link.juejin.im/?target=https%3A%2F%2Fkeras.io%2Flayers%2Fconvolutional%2F%23conv1d&quot;&gt;文档&lt;/a&gt; 关于一维卷积神经网络部分&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-0.88235294117647&quot;&gt;
&lt;p&gt;Keras &lt;a href=&quot;https://link.juejin.im/?target=https%3A%2F%2Fkeras.io%2Fgetting-started%2Fsequential-model-guide%2F&quot; data-cke-saved-href=&quot;https://link.juejin.im/?target=https%3A%2F%2Fkeras.io%2Fgetting-started%2Fsequential-model-guide%2F&quot;&gt;用例&lt;/a&gt; 关于一维卷积神经网络部分&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-0.925&quot;&gt;
&lt;p&gt;一篇关于使用一维卷积神经网络进行自然语言处理的好 &lt;a href=&quot;https://link.juejin.im/?target=http%3A%2F%2Fwww.wildml.com%2F2015%2F11%2Funderstanding-convolutional-neural-networks-for-nlp%2F&quot; data-cke-saved-href=&quot;https://link.juejin.im/?target=http%3A%2F%2Fwww.wildml.com%2F2015%2F11%2Funderstanding-convolutional-neural-networks-for-nlp%2F&quot;&gt;文章&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Fri, 19 Apr 2019 14:33:00 +0000</pubDate>
<dc:creator>小宋是呢</dc:creator>
<og:description>概述 许多技术文章a都关注于二维卷积神经网络（2D CNN）的使用，特别是在图像识别中的应用。而一维卷积神经网络（1D CNNs）只在一定程度上有所涉及，比如在自然语言处理（NLP）中的应用。目前很少</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiaosongshine/p/10739257.html</dc:identifier>
</item>
<item>
<title>poium测试库介绍 - 虫师</title>
<link>http://www.cnblogs.com/fnng/p/10739141.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fnng/p/10739141.html</guid>
<description>&lt;p&gt;poium测试库前身为selenium-page-objects测试库，我在以前的文章中也有介绍过:&lt;a href=&quot;https://www.cnblogs.com/fnng/p/9879882.html&quot;&gt;这可能是最简单的Page Object库&lt;/a&gt;，项目的核心是基于Page Objects实现元素定位的封装。该项目由我个人在维护，目前在公司项目中已经得到的应用。&lt;/p&gt;

&lt;h3 id=&quot;poium的优势&quot;&gt;poium的优势&lt;/h3&gt;
&lt;p&gt;Page Objects设计模式大家都懂，以往我们对Page层的封装大概是这样的。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class BasePage():

   def __init__(self, driver):
       self.dr =driver    

   def by_id(self, elem):
       returnself.dr.find_element_by_id(elem)

class BaiduIndexPage(BasePage):

   # 搜索框
   @property   
   def search_input(self):
       returnself.by_id(&quot;kw&quot;)

   # 搜索按钮
   @property
   def search_button(self):
       returnself.by_id(&quot;su&quot;)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;大体上是每个操作元素封装为一个方法，这样并没什么不好的，只是不够简洁。而poium可以极大的简化元素的定义，甚至接近，配置文件。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from poium import Page, PageElement

class BaiduIndexPage(Page):
    search_input= PageElement(css=&quot;#kw&quot;, describe=&quot;搜索框&quot;)
    search_button= PageElement(css=&quot;#su&quot;, describe=&quot;搜索按钮&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;几百个元素的也只不过几百行代码，使用也远比配置文件简单。将元素写到配置文件里，你还要考虑如何读取。&lt;/p&gt;
&lt;p&gt;不管是前一种page层封装，还是使用poium封装在测试用例中的使用并无太大的差别。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from selenium import webdriver
import unittest

defbaiduTest(unittest.TestCase):
 
    defsetUp(self):
        self.driver =webdriver.Chrome()
        self.base_url =&quot;https://www.baidu.com&quot;
    
deftearDown(self):
        self.driver.quit()
    
    deftest_search(self):
        page= BaiduIndexPage(driver)
        page.get(self.base_url)
        page.search_input.send_keys(&quot;poium&quot;)
        page.search_button.click()
        # .....
 &lt;/code&gt;
&lt;/pre&gt;

&lt;h3 id=&quot;javascript-api&quot;&gt;JavaScript API&lt;/h3&gt;
&lt;p&gt;在我们项目中，时常要用到JavaScript操作，比如日期控件不好操作，那会通过JS的removeAttribute() 删除掉元素的某些属性，使他可以通过输入完成日期的“选择”。比如，有些元素用Selenium点击不了，但JS的click()却可以，再比如有些弹窗不是必现的，就必须使用异常捕捉，但JS可以更轻松的处理弹窗。&lt;/p&gt;
&lt;p&gt;于是，我封装了一组由JS实现的API。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from poium import Page

class BaiduPage(Page):
    # 元素定位只支持CSS语法
    search_input =&quot;#kw&quot;
    search_button =&quot;#su&quot;

deftest_attribute(self):
    &quot;&quot;&quot;
    元素属性修改/获取/删除
    :param browser: 浏览器驱动
    &quot;&quot;&quot;
    driver= webdriver.Chrome()
    page =BaiduPage(browser)
    page.get(&quot;https://www.baidu.com&quot;)
    page.remove_attribute(page.search_input,&quot;name&quot;)
    page.set_attribute(page.search_input, &quot;type&quot;, &quot;password&quot;)
    value =page.get_attribute(page.search_input, &quot;type&quot;)
    assert value ==&quot;password&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不过，JS实现的API中的只支持CSS定位。&lt;/p&gt;
&lt;p&gt;强列推荐使用CSS定位，因为poium还可以将操作过的元素在自动化的运行过程中给你标记出来。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/311516/201904/311516-20190419221512738-1550952465.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样当程序运行失败需要截图时就比较清晰了，但是，这个功能还不完善。&lt;/p&gt;

&lt;h3 id=&quot;appium-支持&quot;&gt;appium 支持&lt;/h3&gt;
&lt;p&gt;为什么不是不叫selenium-page-objects了？因为poium也支持appium了呀，使用之前的名字如何表达对appium的支持呢？&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from appium import webdriver
from poium import Page,PageElement
 
class CalculatorPage(Page):
    number_1 = PageElement(id_=&quot;com.android.calculator2:id/digit_1&quot;)
    number_2 = PageElement(id_=&quot;com.android.calculator2:id/digit_2&quot;)
    add = PageElement(id_=&quot;com.android.calculator2:id/op_add&quot;)
    eq = PageElement(id_=&quot;com.android.calculator2:id/eq&quot;)

# APP定义运行环境
desired_caps = {
    'deviceName': 'AndroidEmulator',
    'automationName': 'appium',
    'platformName': 'Android',
    'platformVersion': '7.0',
    'appPackage': 'com.android.calculator2',
    'appActivity': '.Calculator',
}
driver =webdriver.Remote('http://localhost:4723/wd/hub', desired_caps)
page =CalculatorPage(driver)
page.number_1.click()
page.add.click()
page.number_2.click()
page.eq.click()
 
driver.quit()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在appium中的使用与selenium是一致的！当然，appium扩展了更多的定位方法。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ios_uiautomation&lt;/li&gt;
&lt;li&gt;ios_predicate&lt;/li&gt;
&lt;li&gt;ios_class_chain&lt;/li&gt;
&lt;li&gt;android_uiautomator&lt;/li&gt;
&lt;li&gt;android_viewtag&lt;/li&gt;
&lt;li&gt;android_datamatcher&lt;/li&gt;
&lt;li&gt;accessibility_id&lt;/li&gt;
&lt;li&gt;image&lt;/li&gt;
&lt;li&gt;custom&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;poium同样支持这些定位，在appium中如何使用，那么这里也是一样的。&lt;/p&gt;
&lt;p&gt;最后，poium并不会对你的现有自动化产生太多的影响，它只是对元素操作的封装，你可以在项目当中随意的选择是否要用它。&lt;/p&gt;
&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/defnngj/poium&quot;&gt;poium&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;支持pip安装：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;pip install poium&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 19 Apr 2019 14:17:00 +0000</pubDate>
<dc:creator>虫师</dc:creator>
<og:description>基于 selenium/appium 的 Page Objects 设计模式测试库。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fnng/p/10739141.html</dc:identifier>
</item>
<item>
<title>六大设计原则（二）LSP里氏替换原则 - 星空蓝</title>
<link>http://www.cnblogs.com/quinntian/p/10739178.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/quinntian/p/10739178.html</guid>
<description>&lt;p&gt;&lt;strong&gt;里氏替换原则LSP&lt;/strong&gt;(Liskov Subsituation Principle)&lt;/p&gt;
&lt;h2 id=&quot;里氏替换原则定义&quot;&gt;里氏替换原则定义&lt;/h2&gt;
&lt;p&gt;所有&lt;strong&gt;父类出现&lt;/strong&gt;的地方可以使用&lt;strong&gt;子类替换&lt;/strong&gt;并不会出现错误或异常，但是反之子类出现的地方不一定能用父类替换。&lt;/p&gt;
&lt;h2 id=&quot;lsp的四层含义&quot;&gt;LSP的四层含义&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;子类必须完全实现父类的方法&lt;/li&gt;
&lt;li&gt;子类可以自己的个性（属性和方法）&lt;/li&gt;
&lt;li&gt;覆盖或实现父类的方法时输入参数可以被放大&lt;/li&gt;
&lt;li&gt;覆盖或实现父类的方法时输出结果可以被缩小&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;lsp的定义含义1子类必须完全实现父类的方法&quot;&gt;LSP的定义含义1——子类必须完全实现父类的方法&lt;/h2&gt;
&lt;p&gt;假设如下场景：定义一个枪支抽象类，一个场景类，三个枪支实现类，一个士兵类。此处，三个枪支&lt;strong&gt;完全实现&lt;/strong&gt;了父类的方法。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;关联关系：实线箭头&lt;br/&gt;泛化关系：实线空心箭头（继承关系）&lt;br/&gt;依赖关系：虚线箭头（使用关系）一个类需要另一个类的协助&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://res-qiniu.quinntian.com/956f3daf9007c7b3add0701941603201&quot; alt=&quot;file&quot;/&gt;&lt;br/&gt;&lt;strong&gt;抽象枪支类&lt;/strong&gt;：射击功能&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package des.lsp;

/**
 * 抽象类 枪支
 */
abstract class AbstractGun {
    //射击功能
  public abstract void shoot();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;子类实现&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package des.lsp;

/**
 * 手枪
 */
public class HandGun extends AbstractGun {
    @Override
    public void shoot() {
        System.out.print(&quot;手枪可以射击&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package des.lsp;

/**
 * 手枪
 */
public class MachineGun extends AbstractGun {
    @Override
    public void shoot() {
        System.out.print(&quot;步枪可以射击&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package des.lsp;

/**
 * 步枪
 */
public class Rifle extends AbstractGun {
    @Override
    public void shoot() {
        System.out.print(&quot;步枪可以射击&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;士兵类&lt;/strong&gt;：士兵类使用的是&lt;strong&gt;抽象枪支类&lt;/strong&gt;，具体的需要在&lt;strong&gt;场景类&lt;/strong&gt;中指定。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;类中调用其他类必须使用父类或接口，若不能使用则其实已经违背了LSP原则。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package des.lsp;

public class Soldier {
    private AbstractGun gun;
    public void setGun(AbstractGun _gun){
        this.gun = _gun;
    };
    public void killEnemy(){
        System.out.print(&quot;士兵开始杀人...&quot;);
        gun.shoot();
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;场景类&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package des.lsp;

public class Client {
    public static void main(String[] args) {
        // write your code here
        Soldier s = new Soldier();
        s.setGun(new Rifle());
        s.killEnemy();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果加入一个玩具枪类，即玩具枪类同样继承抽象枪支类，此时就会存在子类&lt;strong&gt;不能实现枪支类方法&lt;/strong&gt;的情况，因为玩具枪和枪最本质的区别是玩具枪不能射击的，是无法杀死人的。&lt;strong&gt;但是，玩具枪的其他属性&lt;/strong&gt;，比如颜色等一些属性可以&lt;strong&gt;委托&lt;/strong&gt;抽象枪支类进行处理。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;如果子类不能完整的实现父类的方法或者父类某些方法在子类中发生了畸变，则应该断开父子关系采用依赖、组合、聚集等关系来代替原有的继承。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;玩具枪继承枪支抽象类的情况：射击方法不能被实现，如果实现里面具体逻辑为空则毫无意义，即正常情况下不能实现父类的shoot方法，shoot方法必须去掉，从LSP来看如果去掉，则&lt;strong&gt;违背了LSP的第一个原则：子类必须实现父类方法&lt;/strong&gt;。（代码层面来看如果去掉则会报错）&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package des.lsp;

public class ToyGun extends  AbstractGun {
    @Override
    public void shoot() {
        //此方法不能实现，玩具枪不能射击
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;解决方法：&lt;/strong&gt;单独建立一个&lt;strong&gt;抽象类玩具类&lt;/strong&gt;，把与枪支共有的如声音、颜色交给抽象枪支类处理，而玩具枪所特有的玩具类的属性交给抽象玩具类处理，&lt;strong&gt;玩具枪类实现玩具抽象类&lt;/strong&gt;。&lt;br/&gt;&lt;img src=&quot;https://res-qiniu.quinntian.com/29624c19293f64ed3ef0fc712cefff38&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;lsp的定义含义2子类可以含有自己的特性&quot;&gt;LSP的定义含义2——子类可以含有自己的特性&lt;/h2&gt;
&lt;p&gt;如图引入，步枪的实现类即&lt;strong&gt;步枪由不同的型号&lt;/strong&gt;。AUG：狙击枪可以由望远镜功能zoomOut方法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://res-qiniu.quinntian.com/74b6f29ca0a76fe525a8ba5b538ed96f&quot; alt=&quot;file&quot;/&gt;&lt;br/&gt;此处&lt;strong&gt;Snipper是狙击手类&lt;/strong&gt;，狙击手与狙击枪是密不可分，属于&lt;strong&gt;组合关系&lt;/strong&gt;，所以狙击手类直接使用子类AUG。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package des.lsp;
//狙击枪
public class AUG extends Rifle {
    //狙击枪特有功能
    public void zoomOut(){
        System.out.print(&quot;通过望远镜观察敌人...&quot;);
    }

    @Override
    public void shoot() {
        System.out.print(&quot;AUG射击敌人...&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package des.lsp;
//狙击手
public class Snipper {
    //此处传入参数为子类，组合关系
    public void killEnemy(AUG aug){
        //观察
        aug.zoomOut();
        //射击
        aug.shoot();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package des.lsp;

public class Client {
    public static void main(String[] args) {
        
        Snipper s = new Snipper();
        s.killEnemy(new AUG());
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;LSP原则：父类不一定能替换子类&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package des.lsp;

public class Client {
    public static void main(String[] args) {
        // write your code here
//        Soldier s = new Soldier();
//        s.setGun(new Rifle());
//        s.killEnemy();

        Snipper s = new Snipper();
        s.killEnemy((AUG) new Rifle());//此处用父类代替了子类
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;报错代码&lt;br/&gt;&lt;img src=&quot;https://res-qiniu.quinntian.com/f19db1f30cbc61724d26917600b6b189&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;lsp的定义含义3覆盖或实现父类方法时输入参数可以被放大&quot;&gt;LSP的定义含义3——覆盖或实现父类方法时输入参数可以被放大&lt;/h2&gt;
&lt;p&gt;假设有如下场景&lt;br/&gt;父类：&lt;strong&gt;方法入参＜子类方法入参&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://res-qiniu.quinntian.com/873b2d3251f8fdab4e573bdd9ec3bfef&quot; alt=&quot;file&quot;/&gt;&lt;br/&gt;场景类调用：父类调用自己方法。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package des.lsp;

import java.util.HashMap;

public class Client {
    public static void invoker(){
        Father f = new Father();
        HashMap map = new HashMap();
        f.doSomething(map);
        
    }
    public static void main(String[] args) {

        invoker();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果&lt;br/&gt;&lt;img src=&quot;https://res-qiniu.quinntian.com/b89feebfb14fce134437734cc4eb8f9f&quot; alt=&quot;file&quot;/&gt;&lt;br/&gt;使用里氏替换原则：把所有父类出现的地方替换为子类&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package des.lsp;

import java.util.HashMap;

public class Client {
    public static void invoker(){
        Son f = new Son();
        HashMap map = new HashMap();
        f.doSomething(map);

    }
    public static void main(String[] args) {
emy((AUG) new Rifle());

        invoker();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果&lt;br/&gt;&lt;img src=&quot;https://res-qiniu.quinntian.com/d384c271f1079e7e70474862c45c22ea&quot; alt=&quot;file&quot;/&gt;&lt;br/&gt;我们的本意是调用子类重载的方法，入参为Map的方法，但实际程序执行是调用的从父类继承的方法。&lt;strong&gt;&lt;em&gt;如果子类的方法中入参的范围大于父类入参的范围，则子类代替父类的时候，子类的方法永远不会执行。&lt;/em&gt;&lt;/strong&gt;&lt;br/&gt;从另外角度来看，假如父类入参的范围大于子类的入参的范围，则父类替换子类就未必能存在，这时候很可能会调用子类的方法执行。此句话较为抽象，实际情况如下。&lt;br/&gt;&lt;img src=&quot;https://res-qiniu.quinntian.com/997cd0138882715d9309d10f4002ae1c&quot; alt=&quot;file&quot;/&gt;&lt;br/&gt;父类和子类的代码如下&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Father {
    public Collection doSomething(Map map){
        System.out.print(&quot;父类被执行...&quot;);
        return map.values();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Son extends Father {
    public Collection doSomething(HashMap map) {
       System.out.print(&quot;子类执行...&quot;);
        return map.values();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;场景类：调用父类&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package des.lsp;

import java.util.HashMap;

public class Client {
    public static void invoker(){
        Father f = new Father();
        HashMap map = new HashMap();
        f.doSomething(map);

    }
    public static void main(String[] args) {
 
        invoker();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：不言而喻，是父类被执行&lt;br/&gt;&lt;img src=&quot;https://res-qiniu.quinntian.com/5132f221627b6dee52cacc42cdb0c3cd&quot; alt=&quot;file&quot;/&gt;&lt;br/&gt;采用LSP后&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package des.lsp;

import java.util.HashMap;

public class Client {
    public static void invoker(){
        Son f = new Son();
        HashMap map = new HashMap();
        f.doSomething(map);

    }
    public static void main(String[] args) {

        invoker();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://res-qiniu.quinntian.com/770d08c80658624b64ae18158c0ecaf6&quot; alt=&quot;file&quot;/&gt;&lt;br/&gt;此时一般人会想，难道不是子类执行吗？因为子类的入参就是HashMap,肯定要调用这个。&lt;br/&gt;但是此时要考虑一个问题，假如我们的本来意思是就是调用从父类继承的入参为Map的方法，但是程序执行的时候却自动为我们执行了子类的方法，此时就会导致混乱。&lt;br/&gt;&lt;strong&gt;结论：子类中的方法的输入参数（前置条件或称形式参数）必须与父类中的输入参数一致或者更宽松（范围更大）。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;lsp的定义含义4覆盖或实现父类的方法时输出结果可以被缩小&quot;&gt;LSP的定义含义4——覆盖或实现父类的方法时输出结果可以被缩小&lt;/h2&gt;
&lt;p&gt;理解：父类的返回类型为T，子类的返回类型为S，即LSP要求&lt;strong&gt;S&amp;lt;= T&lt;/strong&gt;。&lt;br/&gt;此时分为两种情况&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果时覆写，子类继承父类，继承的方法的入参必然相同，此时传入参数必须时相同或小于，返回的值必然不能大于父类返回值，这是覆写的要求。&lt;/li&gt;
&lt;li&gt;如果时重载，这时候要求子类重载方法的参数类型或数量不相同，其实就是保证输入参数宽于或等于父类输入参数，这时候就保证了子类的方法永远不会被执行，其实就是含义3。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;lsp的目的及理解&quot;&gt;LSP的目的及理解&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;增强程序的健壮性&lt;/li&gt;
&lt;li&gt;保证即使增加子类，原有的子类仍然可以继续运行。&lt;/li&gt;
&lt;li&gt;从一方面来说，在程序中尽量避免直接使用子类的个性，而是通过父类一步一步的使用子类，否则直接使用子类其实就相当于直接把子类当作父类，这就直接导致父类毫无用途，父类和子类的关系也会显得没有必要存在了。&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Fri, 19 Apr 2019 14:15:00 +0000</pubDate>
<dc:creator>星空蓝</dc:creator>
<og:description>里氏替换原则LSP (Liskov Subsituation Principle) 里氏替换原则定义 所有 父类出现 的地方可以使用 子类替换 并不会出现错误或异常，但是反之子类出现的地方不一定能用父</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/quinntian/p/10739178.html</dc:identifier>
</item>
<item>
<title>Python3+unitest自动化测试初探（下篇） - 秦无殇</title>
<link>http://www.cnblogs.com/webDepOfQWS/p/10732345.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/webDepOfQWS/p/10732345.html</guid>
<description>&lt;hr/&gt;&lt;p&gt;&lt;a href=&quot;https://docs.python.org/zh-cn/3/library/unittest.html&quot; target=&quot;_blank&quot;&gt;unittest官方文档&lt;/a&gt;&lt;br/&gt;本篇随笔承接：&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/webDepOfQWS/p/10707299.html&quot; target=&quot;_blank&quot;&gt;Python3+unitest自动化测试初探（中篇）&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/webDepOfQWS/p/10707299.html&quot; target=&quot;_blank&quot;&gt;Python3+unitest自动化测试初探（上篇）&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;用例结果校验&quot;&gt;9、用例结果校验&lt;/h3&gt;
&lt;p&gt;用unittest来完成自动化测试时，结果校验无疑是非常重要的。用例校验不完整或者校验过于简单，是无法发现产品的缺陷或Bug的。就自动化测试来而言，其目的是代替部分手动测试，将测试人员从繁重重复的功能测试中解放出来。试想一下，一些缺少校验或简单校验的用例运行完后通过率即使达到100%，这能说明产品或版本没有任何问题吗？能够增强版本发布的信心吗?unittest提供了很多断言方法用于测试结果的校验。常用的断言方法如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/631850/201904/631850-20190419155911186-305652551.png&quot;/&gt;&lt;br/&gt;所有的断言方法都提供一个可选参数msg，用于在测试失败时显示。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;assertEqual(a, b,msg=None)：校验a是否等于b，如果相等，测试通过，反之则测试失败。msg为可选参数，如果传入了该参数，在测试失败时会打印。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; class assertTest(unittest.TestCase):
...     pass
... 
&amp;gt;&amp;gt;&amp;gt; ast1 = assertTest() 

&amp;gt;&amp;gt;&amp;gt; ast1.assertEqual(1,2,msg=&quot;1 is not equal to 2&quot;)
Traceback (most recent call last):
  File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt;
  File &quot;/usr/local/lib/python3.7/unittest/case.py&quot;, line 839, in assertEqual
    assertion_func(first, second, msg=msg)
  File &quot;/usr/local/lib/python3.7/unittest/case.py&quot;, line 832, in _baseAssertEqual
    raise self.failureException(msg)
AssertionError: 1 != 2 : 1 is not equal to 2&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;assertNotEqual(a, b, msg=None)：校验a是否不等于b，如果不相等，测试通过。反之则测试失败。&lt;/li&gt;
&lt;li&gt;assertTrue(x,msg=None)：验证x是否为True，x可以为值或表达式，x为True则测试通过。反之，则测试失败，msg为可选参数，如果传入了该参数，在测试失败时会打印。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; ast1.assertTrue(1=2,msg=&quot;1=2,False&quot;)
  File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1
SyntaxError: keyword can't be an expression
&amp;gt;&amp;gt;&amp;gt; ast1.assertTrue(1==2,msg=&quot;1=2,False&quot;)
Traceback (most recent call last):
  File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt;
  File &quot;/usr/local/lib/python3.7/unittest/case.py&quot;, line 692, in assertTrue
    raise self.failureException(msg)
AssertionError: False is not true : 1=2,False
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;assertIs(a, b)：判断a is b是是否成立。等价于判断id(a) == id(b)是否成立，如果成立，则测试通过。反之，测试失败。&lt;/li&gt;
&lt;li&gt;assertIsNone(x)：判断x是否为None。如果为None则测试通过，反之，测试失败。&lt;/li&gt;
&lt;li&gt;assertIn(a, b)：判断a是否在b中。如果在，则测试通过，反之，测试失败。&lt;/li&gt;
&lt;li&gt;assertIsInstance(a, b)：判断a是否为b的实例。如果是，则测试通过，反之，测试失败。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;unittest还提供了如下方法用于检查异常，警告，日志信息。图片来自unittest官方文档。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/631850/201904/631850-20190419183446702-1332107654.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;检查异常，警告，日志的使用方法大同小异。在此不一一说明了，下面举例说明assertRaises(exc, fun, *args, **kwds)和assertRaises(exc, fun, *args, **kwds)的用法。&lt;br/&gt; [ 示例1 ] assertRaises()的用法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#coding:utf-8
'''
定义一个除法的函数
当y==0时，会抛出错误ZeroDivisionError
'''
import unittest
def div(x,y):
        return  x/y

#定义一个测试类assertTest，继承于unittest.TestCase
class assertTest(unittest.TestCase):
    #pass表示什么也不做
    pass
ast2 = assertTest()
'''
第一个参数为异常的类型
第二个为方法名称
后面为方法的参数
'''
ast2.assertRaises(ZeroDivisionError,div,1,0)
print(&quot;---------------------------------------&quot;)
ast2.assertRaises(ZeroDivisionError,div,1,1)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;调用div(1,1)不会抛出异常ZeroDivisionError，所以assertRaises()测试失败，上述代码运行结果如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/631850/201904/631850-20190419184605136-538110286.png&quot;/&gt;&lt;br/&gt;如果只传入了expetion或msg参数，就可以在with上下文管理器中测试一段代码而不仅仅是测试函数，就像下面这样。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/631850/201904/631850-20190419185425692-174069514.png&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;with ast2.assertRaises(ZeroDivisionError):
     div(1,1)

with ast2.assertRaises(ZeroDivisionError):
    div(1,0)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/631850/201904/631850-20190419185618270-482436191.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt; [ 示例2 ] assertRaises()的用法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#导入warnings模块
import warnings
#定义一个简单的函数，打印级别为UserWarning的告警
def warnTest():
     warnings.warn(&quot;This is warning test&quot;)

ast2.assertWarns(UserWarning,warnTest)
print(&quot;--------------------------------&quot;)
with ast2.assertWarns(UnicodeWarning):
    warnTest()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;warnTest()函数不会打印UnicodeWarning级别的告警，所以第二个告警校验会失败，运行结果如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/631850/201904/631850-20190419185933761-898110055.png&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/webDepOfQWS/p/10732345.html#jump&quot;&gt;&lt;em&gt;点击这里返回本篇目录&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;跳过用例&quot;&gt;10、跳过用例&lt;/h3&gt;
&lt;p&gt;在一些场景下并不会执行所有的用例，而是选择性跳过一部分用例。unittest支持跳过单个用例或整个测试类。跳过用例需要用到unittest.skip()装饰器。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;@unittest.skip(reason)：无条件跳过单个用例或测试类，reason是跳过的原因。&lt;/li&gt;
&lt;li&gt;@unittest.skipIf(condition, reason)：if条件成立则跳过单个用例或测试类，reason是跳过的原因。&lt;/li&gt;
&lt;li&gt;@unittest.skipUnless(condition, reason)：条件为False则跳过单个用例或测试类，reason是跳过的原因。&lt;/li&gt;
&lt;li&gt;@unittest.expectedFailure：标记测试用例为失败，不会出现在统计结果中。&lt;/li&gt;
&lt;li&gt;exception unittest.SkipTest(reason)：跳过用例并抛出异常。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;[ 示例3 ]：直接跳过注册功能的用例&lt;br/&gt;对userRegTest.py做如下修改，并执行userRegTest.py：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    @unittest.skip(&quot;skip test case of user reg&quot;)
    def test_pwdlenerr_L1(self):
        print(&quot;test case:test_pwdlenerr_L1&quot;)
        res = self.user1.userReg()
        self.assertEqual(res,&quot;passwordLenError&quot;)

    #测试场景：正常注册
    @unittest.skipIf(2&amp;gt;1,&quot;skip if condiction&quot;)
    def test_regsucess_L0(self):
        print(&quot;test case:test_regsucess_L0&quot;)
        res = self.user2.userReg()
        self.assertEqual(res,&quot;regSucess&quot;)

    #测试场景：用户名重名
    @unittest.skipUnless(1&amp;lt;0,&quot;skip unless.&quot;)
    def test_regagain_L1(self):
        print(&quot;test case:test_regagain_L1&quot;)
        res = self.user3.userReg()
        self.assertEqual(res,&quot;SameNameError&quot;)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/631850/201904/631850-20190419203055052-996328385.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;test-discovery&quot;&gt;11、Test Discovery&lt;/h3&gt;
&lt;p&gt;unittest支持用例发现功能，在unittest.defaultTestLoader中实现。使用的时候需要传入两个参数：寻找的起始目录，匹配的测试文件的格式（默认test*.py）。用例发现也支持命令行模式。&lt;/p&gt;
&lt;p&gt;[ 示例4 ]：testDiscover&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    startPath = './testCases'
    discover = unittest.defaultTestLoader.discover(start_dir=startPath,pattern='*Test.py')
    print(discover)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/631850/201904/631850-20190419210158827-2110356272.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;加载用例&quot;&gt;12、加载用例&lt;/h3&gt;
&lt;p&gt;unittest支持从模块和测试类中提取测试用例创建测试套。在class unittest.TestLoader中实现。TestLoader常见的加载方法如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;loadTestsFromTestCase(testCaseClass)：从unittest.TestCase的子类即测试类中加载用例并返回测试套。&lt;/li&gt;
&lt;li&gt;loadTestsFromName(name,module=None)：从特定的字符串说明符中加载用例并返回测试套。&lt;/li&gt;
&lt;li&gt;loadTestsFromNames(names,module=None)：用法和 loadTestsFromName(name,module=None)类似，不同的是它可以接受字符串说明符列表，而不是一个。&lt;/li&gt;
&lt;li&gt;loadTestsFromModule(module, pattern=None)：从模块中加载所有测试用例，返回一个测试套件。&lt;/li&gt;
&lt;li&gt;getTestCaseName(testCaseClass)：返回一个有序的包含在testCaseClass中的方法名列表。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;[示例5 ] ：TestLoader用法举例&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
#coding:utf-8

import unittest
import testCases.userLoginTest,testCases.userRegTest
from testCases.userRegTest import regTest
from testCases.userLoginTest import loginTest

loader = unittest.TestLoader()

print(&quot;从测试类loginTest加载所有的用例：&quot;)
caseInLoginTest = loader.getTestCaseNames(loginTest)
print(caseInLoginTest)

print(&quot;从测试模块中加载用例：&quot;)
loadByModule = loader.loadTestsFromModule(testCases.userLoginTest)
print(loadByModule)

print(&quot;从测试类中加载用例：&quot;)
loadByTestClass = loader.loadTestsFromTestCase(regTest)
print(loadByTestClass)
print(&quot;从特定的字符串标识符中加载用例&quot;)

loadBySpecifier = loader.loadTestsFromName(&quot;regTest.test_regagain_L1&quot;)
print(loadBySpecifier)

print(&quot;从字符符标识符列表中加载用例&quot;)
specStrs = [&quot;regTest.test_regagain_L1&quot;,&quot;test_regsucess_L0&quot;]
loadBySpecifiers = loader.loadTestsFromNames(specStrs)
print(loadBySpecifiers)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/631850/201904/631850-20190419214407325-1805125467.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在发布时间紧张，产品迭代频繁的情况下，很多时候上线一个新特性，对已发布的老特性采用的回归策略是：只执行L0即（Level 0）级别的测试用例。这个在unittest里面怎么实现呢？解决方案是：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;规范特性L0用例的格式，比如：test_xxx_L0.&lt;/li&gt;
&lt;li&gt;加载用例&lt;/li&gt;
&lt;li&gt;通过正则表达式匹配出L0级别的用例集合，然后交给test runner执行。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;（完）&lt;br/&gt;&lt;a href=&quot;http://www.cnblogs.com/webDepOfQWS/p/10732345.html#jump&quot;&gt;&lt;em&gt;点击这里返回本篇目录&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 19 Apr 2019 14:14:00 +0000</pubDate>
<dc:creator>秦无殇</dc:creator>
<og:description>用unittest来完成自动化测试时，结果校验无疑是非常重要的。用例校验不完整或者校验过于简单，是无法发现产品的缺陷或Bug的。就自动化测试来而言，其目的是代替部分手动测试，将测试人员从繁重重复的功能</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/webDepOfQWS/p/10732345.html</dc:identifier>
</item>
<item>
<title>最详细版图解优先队列（堆） - 9龙</title>
<link>http://www.cnblogs.com/9dragon/p/10739121.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/9dragon/p/10739121.html</guid>
<description>&lt;div class=&quot;output_wrapper&quot; id=&quot;output_wrapper_id&quot; readability=&quot;70&quot;&gt;
&lt;h3 id=&quot;h&quot;&gt;&lt;span&gt;一、队列与优先队列的区别&lt;/span&gt;&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;队列&lt;/strong&gt;是一种&lt;strong&gt;FIFO&lt;/strong&gt;（First-In-First-Out）先进先出的数据结构，对应于生活中的排队的场景，排在前面的人总是先通过，&lt;strong&gt;依次进行&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;优先队列&lt;/strong&gt;是特殊的队列，从“优先”一词，可看出&lt;strong&gt;有“插队现象”&lt;/strong&gt;。比如在火车站排队进站时，就会有些比较急的人来插队，他们就在前面先通过验票。优先队列&lt;strong&gt;至少含有两种操作&lt;/strong&gt;的数据结构：&lt;strong&gt;insert（插入）&lt;/strong&gt;，即将元素插入到优先队列中（入队）；以及&lt;strong&gt;deleteMin（删除最小者）&lt;/strong&gt;，它的作用是找出、删除优先队列中的最小的元素（出队）。&lt;/li&gt;
&lt;/ol&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1603499/201904/1603499-20190419215308788-235869534.jpg&quot; alt=&quot;优先队列&quot; title=&quot;优先队列&quot;/&gt;优先队列
&lt;h3 id=&quot;h-1&quot;&gt;&lt;span&gt;二、优先队列（堆）的特性&lt;/span&gt;&lt;/h3&gt;
&lt;ol readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;结构性&lt;/strong&gt;：&lt;strong&gt;堆是一颗除底层外被完全填满的二叉树，底层的节点从左到右填入，&lt;/strong&gt;这样的树叫做&lt;strong&gt;完全二叉树。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;堆序性：&lt;/strong&gt;由于我们想很快找出最小元，则最小元应该在根上，&lt;strong&gt;任意节点都小于它的后裔&lt;/strong&gt;，这就是&lt;strong&gt;小顶堆（Min-Heap）&lt;/strong&gt;；如果是查找最大元，则最大元应该在根上，&lt;strong&gt;任意节点都要大于它的后裔&lt;/strong&gt;，这就是&lt;strong&gt;大顶堆(Max-heap)。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;h-5&quot;&gt;&lt;span&gt;结构性：&lt;/span&gt;&lt;/h4&gt;
&lt;img src=&quot;https://img2018.cnblogs.com/blog/1603499/201904/1603499-20190419215415868-572589691.jpg&quot; alt=&quot;完成二叉树&quot; title=&quot;完成二叉树&quot;/&gt;完成二叉树&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;通过观察发现，&lt;strong&gt;完全二叉树可以直接使用一个数组表示&lt;/strong&gt;而不需要使用其他数据结构。所以我们只需要传入一个size就可以构建优先队列的结构（元素之间使用compareTo方法进行比较）。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;PriorityQueue&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Comparable&lt;/span&gt;&amp;lt;? &lt;span class=&quot;hljs-title&quot;&gt;super&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;T&lt;/span&gt;&amp;gt;&amp;gt; &lt;/span&gt;{ &lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;PriorityQueue&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; capacity)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;currentSize = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;&lt;br/&gt;array = (T[]) &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Comparable[capacity + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;];&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;img src=&quot;https://img2018.cnblogs.com/blog/1603499/201904/1603499-20190419215512369-795895153.jpg&quot; alt=&quot;完全二叉树的数组实现&quot; title=&quot;完全二叉树的数组实现&quot;/&gt;完全二叉树的数组实现
&lt;p&gt;对于数组中的任意位置 i 的元素，其&lt;strong&gt;左儿子&lt;/strong&gt;在位置 &lt;strong&gt;2i&lt;/strong&gt; 上，则&lt;strong&gt;右儿子&lt;/strong&gt;在 &lt;strong&gt;2i+1&lt;/strong&gt; 上，&lt;strong&gt;父节点&lt;/strong&gt;在 在 &lt;strong&gt;i/2&lt;/strong&gt;（向下取整）上。通常从数组下标1开始存储，这样的好处在于很方便找到左右、及父节点。如果从0开始，左儿子在2i+1,右儿子在2i+2,父节点在(i-1)/2（向下取整）。&lt;/p&gt;
&lt;h4 id=&quot;h-2&quot;&gt;&lt;span&gt;堆序性：&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;我们这建立&lt;strong&gt;最小堆，即对于每一个元素X，X的父亲中的关键字小于（或等于）X中的关键字，根节点除外（它没有父节点）。&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&quot;https://img2018.cnblogs.com/blog/1603499/201904/1603499-20190419215616555-1584046224.jpg&quot; alt=&quot;堆&quot; title=&quot;堆&quot;/&gt;堆
&lt;p&gt;如图所示，只有左边是堆，右边红色节点违反堆序性。根据堆序性，只需要常O(1)找到最小元。&lt;/p&gt;
&lt;h3 id=&quot;h-3&quot;&gt;&lt;span&gt;三、基本的堆操作&lt;/span&gt;&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;insert（插入）&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;上滤&lt;/strong&gt;：&lt;strong&gt;为了插入元素X，我们在下一个可用的位置建立空穴&lt;/strong&gt;（否则会破坏结构性，不是完全二叉树）。&lt;strong&gt;如果此元素放入空穴不破坏堆序性，则插入完成；否则，将父节点下移到空穴，即空穴向根的方向上冒一步。&lt;/strong&gt;继续该过程，直到X插入空穴为止。这样的过程称为上滤。&lt;/li&gt;
&lt;/ul&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1603499/201904/1603499-20190419215751673-1350396690.jpg&quot; alt=&quot;建立空穴&quot; title=&quot;建立空穴&quot;/&gt;建立空穴 &lt;img src=&quot;https://img2018.cnblogs.com/blog/1603499/201904/1603499-20190419215817341-1192872328.jpg&quot; alt=&quot;完成插入&quot; title=&quot;完成插入&quot;/&gt;完成插入
&lt;p&gt;图中演示了18插入的过程，&lt;strong&gt;在下一个可用的位置建立空穴（满足结构性），发现不能直接插入，将父节点移下来，空穴上冒。继续这个过程，直到满足堆序性。&lt;/strong&gt;这样就实现了元素插入到优先队列（堆）中。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;java实现上滤&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre readability=&quot;6.5&quot;&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;7&quot;&gt;     &lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;insert&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(T x)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt; == x) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (currentSize == array.length - &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;) {&lt;br/&gt;enlargeArray(array.length * &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; hole = ++currentSize;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (array[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;] = x; x.compareTo(array[hole / &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;]) &amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; hole /= &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;) {&lt;br/&gt;array[hole] = array[hole / &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;];&lt;br/&gt;}&lt;br/&gt;array[hole] = x;&lt;br/&gt;}&lt;p&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;enlargeArray&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; newSize)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;T[] old = array;&lt;br/&gt;array = (T[]) &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Comparable[newSize];&lt;br/&gt;System.arraycopy(old, &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, array, &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, old.length);&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以反复使用交换操作来进行上滤过程，但如果插入X上滤d层，则需要3d次赋值；我们这种方式只需要d+1次赋值。&lt;/p&gt;
&lt;p&gt;如果插入的元素是新的最小元从而一直上滤到根处，那么这种插入的时间长达O(logN)。但平均来看，上滤终止得要早。&lt;strong&gt;业已证明，执行依次插入平均需要2.607次比较，因此平均insert操作上移元素1.607层。&lt;/strong&gt;上滤次数只比插入次数少一次。&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;&lt;span&gt;deleteMin（删除最小元）&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;下滤&lt;/strong&gt;：类似于上滤操作。因为我们建立的是最小堆，所以删除最小元，就是将根节点删掉，这样就破坏了结构性。所以&lt;strong&gt;我们在根节点处建立空穴，为了满足结构性，堆中最后一个元素X必须移动到合适的位置，如果可以直接放到空穴，则删除完成（一般不可能）；否则，将空穴的左右儿子中较小者移到空穴，即空穴下移了一层。继续这样的操作，直到X可以放入到空穴中。&lt;/strong&gt;这样就可以满足结构性与堆序性。这个过程称为下滤。&lt;/li&gt;
&lt;/ul&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1603499/201904/1603499-20190419215925510-186459752.jpg&quot; alt=&quot;删除最小元&quot; title=&quot;删除最小元&quot;/&gt;删除最小元 &lt;img src=&quot;https://img2018.cnblogs.com/blog/1603499/201904/1603499-20190419215955136-723322432.jpg&quot; alt=&quot;完成删除最小元&quot; title=&quot;完成删除最小元&quot;/&gt;完成删除最小元
&lt;p&gt;如图所示：&lt;strong&gt;在根处建立空穴，将最后一个元素放到空穴，已满足结构性；为满足堆序性，需要将空穴下移到合适的位置。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：堆&lt;/strong&gt;的实现中，经常发生的错误是&lt;strong&gt;只有偶数个元素&lt;/strong&gt;，&lt;strong&gt;即有一个节点只有一个儿子。&lt;/strong&gt;所以&lt;strong&gt;需要测试右儿子的存在性。&lt;/strong&gt;&lt;/p&gt;
&lt;pre readability=&quot;7&quot;&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;8&quot;&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; T &lt;span class=&quot;hljs-title&quot;&gt;deleteMin&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (isEmpty()) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; UnderflowException();&lt;br/&gt;}&lt;p&gt;T minItem = findMin();&lt;br/&gt;array[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;] = array[currentSize--];&lt;br/&gt;percolateDown(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;);&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; minItem;&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;percolateDown&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; hole)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; child;&lt;br/&gt;T tmp = array[hole];&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (; hole * &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; &amp;lt;= currentSize; hole = child) {&lt;br/&gt;child = hole * &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (child != currentSize &amp;amp;&amp;amp;&lt;br/&gt;array[child + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;].compareTo(array[child]) &amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;) {&lt;br/&gt;child++;&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (array[child].compareTo(tmp) &amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;) {&lt;br/&gt;array[hole] = array[child];&lt;br/&gt;} &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;break&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;array[hole] = tmp;&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;这种操作最坏时间复杂度是O(logN)。平均而言，被放到根处的元素几乎下滤到底层（即来自的那层），所以平均时间复杂度是O(logN)。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;h-4&quot;&gt;&lt;span&gt;四、总结&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;优先队列常使用二叉堆实现，本篇图解了二叉堆最基本的两个操作：插入及删除最小元。insert以O(1)常数时间执行，deleteMin以O(logN)执行。&lt;/strong&gt;相信大家看了之后就可以去看java的PriorityQueue源码了。今天只说了二叉堆最基本的操作，还有一些额外操作及分析下次再说。比如，如何证明buildHeap是线性的？以及优先队列的应用等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;声明：图文皆原创，如有转载，请注明出处。如有错误，请帮忙指出，欢迎讨论；若觉得可以，点下推荐支持支持。&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Fri, 19 Apr 2019 14:02:00 +0000</pubDate>
<dc:creator>9龙</dc:creator>
<og:description>一、队列与优先队列的区别 队列是一种FIFO（First In First Out）先进先出的数据结构，对应于生活中的排队的场景，排在前面的人总是先通过，依次进行。 优先队列是特殊的队列，从“优先”一</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/9dragon/p/10739121.html</dc:identifier>
</item>
</channel>
</rss>