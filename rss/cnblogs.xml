<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>.net持续集成cake篇之使用vs或者vscode来辅助开发cake脚本 - 周国通</title>
<link>http://www.cnblogs.com/tylerzhou/p/11223736.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tylerzhou/p/11223736.html</guid>
<description>&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://i.cnblogs.com/EditPosts.aspx?postid=11204826&quot;&gt;系列目录&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;使用visual-studio来开发工具&quot;&gt;使用Visual Studio来开发工具&lt;/h2&gt;
&lt;p&gt;前面我们都是通过手写或者复制的方法来编写Cake文件,Cake使用的是C#语言,如果仅使用简单的文本编辑器来编写显然效率是非常低下的,本节我们讲解如何使用cake Visual Studio插件来通过模板创建cake文件,以及如何使得Visual Studio来调试Cake文件&lt;/p&gt;
&lt;h3 id=&quot;安装cake-visual-studio插件&quot;&gt;安装Cake Visual Studio插件&lt;/h3&gt;
&lt;p&gt;我们在Visual Studio插件管理器里搜索&lt;code&gt;Cake&lt;/code&gt;就可以搜索到&lt;code&gt;Cake for visual studio&lt;/code&gt;插件,然后我们安装它.&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;关于Visual插件搜索和安装我们这里不再赘述,假定看的童鞋都有一定.net编程基础.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;插件安装完成后,我们再通过Vs添加内容的时候,就可以看到Cake模板&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811801/201907/811801-20190722080318058-305958597.png&quot; alt=&quot;avatar&quot;/&gt;&lt;/p&gt;
&lt;p&gt;创建的时候我们把它的名称修改为&lt;code&gt;build.cake&lt;/code&gt;(这里仍然是惯例,其实也可以是其它名称,但是需要做相应修改,这里先不介绍)&lt;/p&gt;
&lt;p&gt;我们使用Vs打开Cake文件,可以看到虽然没有智能提示,但是有一些基本的代码着色&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811801/201907/811801-20190722080311758-258351036.png&quot; alt=&quot;avatar&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果关键字有错误,则代码不会高亮着色显示.&lt;/p&gt;
&lt;h2 id=&quot;使用visual-studio对cake脚本进行调试&quot;&gt;使用Visual Studio对Cake脚本进行调试&lt;/h2&gt;
&lt;p&gt;对于复杂的构建脚本,我们可能需要通过调试来发现排除一些bug,下面介绍如何使用Visual Studio 对Cake脚本进行调试.&lt;/p&gt;
&lt;p&gt;我们修改&lt;code&gt;build.ps1&lt;/code&gt;把最后面三段的内容修改为如下:&lt;/p&gt;
&lt;pre class=&quot;ps1&quot;&gt;
&lt;code&gt;#&amp;amp;$CAKE_EXE $cakeArguments
Invoke-Expression &quot;&amp;amp; `&quot;$CAKE_EXE`&quot; `&quot;$Script`&quot; -target=`&quot;$Target`&quot; -configuration=`&quot;$Configuration`&quot; -verbosity=`&quot;Diagnostic`&quot; $UseMono $UseDryRun $UseExperimental $ScriptArgs --debug&quot;
exit $LASTEXITCODE&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实际上做的改动是把&lt;code&gt;&amp;amp;$CAKE_EXE $cakeArguments&lt;/code&gt;这一行注释掉了,添加了下面&lt;code&gt;Invoke-Expressions&lt;/code&gt;这一行,其实中--debug是必要的,指明是以debug方式启动脚本,这样脚本在启动后会处于暂停状态,让我们有机会通过Vs来附加这个进程&lt;/p&gt;
&lt;p&gt;我们首先运行修改后的ps1文件,出现如下信息&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Preparing to run build script...
Running build script...
Module directory does not exist.
NuGet.config not found.
Performing debug...
Attach debugger to process 21244 to continue&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其实中process id每一次都是不一样的,因此读者看到的和上面的可能是不一样的.&lt;/p&gt;
&lt;p&gt;我们在Vs里打开要调试的cake文件,设置断点,然后执行&lt;code&gt;调试-&amp;gt;附加到进程&lt;/code&gt;在出现的对话框中找到脚本提示的进程(实际上为cake.exe进程),然后点击这样就附加进程就成功了.&lt;/p&gt;
&lt;p&gt;我们可以看到,断点被击中了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811801/201907/811801-20190722080303787-731554411.png&quot; alt=&quot;avatar&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以像调试普通C#脚本一样调试cake文件.&lt;/p&gt;
&lt;h2 id=&quot;使用visual-studio-code开发工具&quot;&gt;使用Visual Studio Code开发工具&lt;/h2&gt;
&lt;p&gt;虽然Cake提供了vs插件,但是不论是开发和调试体验都不是很好,而cake vs code插件则支持cake文件生成,启动文件build.ps1下载,代码智能提示和调试功能.本节将详细介绍这些功能.&lt;/p&gt;
&lt;h3 id=&quot;一.安装cake-vscode插件&quot;&gt;一.安装cake vscode插件&lt;/h3&gt;
&lt;p&gt;这里我们删除build.cake和build.ps1文件,使用vscode来生成它们.&lt;/p&gt;
&lt;p&gt;使用vscode 打开项目(文件-&amp;gt;打开文件夹)或者在项目所在目录点击右键,在右键菜单中选择在此处打开vscode选项.&lt;/p&gt;
&lt;p&gt;打开后我们在&lt;code&gt;插件&lt;/code&gt;标签里搜索&lt;code&gt;cake&lt;/code&gt;这样就打开了搜索搜索界面&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811801/201907/811801-20190722080414300-760990824.png&quot; alt=&quot;avatar&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由于我已经安装过了,因此后面变成了齿轮图标,如果没有安装则会出现安装按钮,安装完成后重新加载或者重启vscode方可生效.&lt;/p&gt;
&lt;p&gt;然后,我们按下&lt;code&gt;ctrl+shift+p&lt;/code&gt;在出现的命令行里面输入&lt;code&gt;cake&lt;/code&gt;会出现以下命令&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811801/201907/811801-20190722080407873-1315956715.png&quot; alt=&quot;avatar&quot;/&gt;&lt;br/&gt;我们选择&lt;code&gt;Install to workspace&lt;/code&gt;下面会让你确认文件名,点击驾车即可,然后还有有一些提示,只需要一路选择&lt;code&gt;yes&lt;/code&gt;就行了.&lt;/p&gt;
&lt;p&gt;完成后会在当前工作区添加build.cake和build.ps1文件&lt;/p&gt;
&lt;h3 id=&quot;二.添加智能提示&quot;&gt;二.添加智能提示&lt;/h3&gt;
&lt;p&gt;cake Vscode插件一个非常酷的功能就是智能提示,有了智能提示我们编码的效率和质量将大大提高.&lt;/p&gt;
&lt;p&gt;仍然像上面一个按下&lt;code&gt;ctrl+shift+p&lt;/code&gt;在出现的命令框中输入cake,在出现的下拉中选择&lt;code&gt;Install intellisense support&lt;/code&gt; 过一会后会后vscode右下角会出现安装成功提示.如果不确定是否安装成功可以再执行一次安装,如果已成功安装则提示已经安装.&lt;/p&gt;
&lt;p&gt;有了智能提示以后,我们输入task,就会出现提示列表&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811801/201907/811801-20190722080401006-754136.png&quot; alt=&quot;avatar&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;需要注意的是智能提示是针对项目环境的,如果是新的项目,仍然需要再次在工作区执行安装.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;三.在vscode里调试cake文件&quot;&gt;三.在vscode里调试cake文件&lt;/h3&gt;
&lt;p&gt;我们在vscode里点击虫子图标,然后点击右向绿色箭头,这时候中间会出现输入框,我们输入cake便会出现与cake相关的调试配置选项&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811801/201907/811801-20190722080353874-1670855429.png&quot; alt=&quot;avatar&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果没有反应,再次执行一次.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811801/201907/811801-20190722080347414-1343506885.png&quot; alt=&quot;avatar&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果执行成功,这里的文字会变成如图示,如果没有成功,则显示的是&lt;code&gt;No configuration&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;成功后,再点击绿色右向箭头,如果脚本没有错误,断点会被击中&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811801/201907/811801-20190722080340470-1730879575.png&quot; alt=&quot;avatar&quot;/&gt;&lt;/p&gt;
&lt;p&gt;有了这些贴心的工具,相信大家不会再对cake心有恐惧了.&lt;/p&gt;
&lt;h3 id=&quot;四.vscode调试cake文件之高级技巧&quot;&gt;四.vscode调试cake文件之高级技巧&lt;/h3&gt;
&lt;p&gt;我们知道,正常运行cake是通过build.ps1脚本启动的,通过ps1脚本启动可以传入一些自定义的参数,而在vscode里则是直接点击调试按钮进行调试的,这样我们就无法通过ps1文件传入参数了,当然我们可以通过修改cake脚本参数或者通过debug指令来调试,然而这些都不是最好的选择,修改cake文件里的变量后如果忘记修改回原来值则上线后可能出现问题.增加debug对于一些简单的脚本文件来说显示是小题大作了.其实我们可以通过修改&lt;code&gt;launch.json&lt;/code&gt;来实现模拟外部传入参数&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;在vscode里搜索文件快捷方法如下:按下&lt;code&gt;ctrl+p&lt;/code&gt;然后输入要搜索的文件名称&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;默认生成的launch.json文件如下&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
    // Use IntelliSense to learn about possible attributes.
    // Hover to view descriptions of existing attributes.
    // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387
    &quot;version&quot;: &quot;0.2.0&quot;,
    &quot;configurations&quot;: [
        {
            &quot;name&quot;: &quot;Cake: Debug Script (CoreCLR)&quot;,
            &quot;type&quot;: &quot;coreclr&quot;,
            &quot;request&quot;: &quot;launch&quot;,
            &quot;program&quot;: &quot;${workspaceRoot}/tools/Cake.CoreCLR/Cake.dll&quot;,
            &quot;args&quot;: [
                &quot;${workspaceRoot}/build.cake&quot;,
                &quot;--debug&quot;,
                &quot;--verbosity=diagnostic&quot;
            ],
            &quot;cwd&quot;: &quot;${workspaceRoot}&quot;,
            &quot;stopAtEntry&quot;: true,
            &quot;externalConsole&quot;: false
        }
    ]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们在args里加入一个configuration参数&lt;/p&gt;
&lt;p&gt;修改后如下&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;{
    // Use IntelliSense to learn about possible attributes.
    // Hover to view descriptions of existing attributes.
    // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387
    &quot;version&quot;: &quot;0.2.0&quot;,
    &quot;configurations&quot;: [
        {
            &quot;name&quot;: &quot;Cake: Debug Script (CoreCLR)&quot;,
            &quot;type&quot;: &quot;coreclr&quot;,
            &quot;request&quot;: &quot;launch&quot;,
            &quot;program&quot;: &quot;${workspaceRoot}/tools/Cake.CoreCLR/Cake.dll&quot;,
            &quot;args&quot;: [
                &quot;${workspaceRoot}/build.cake&quot;,
                &quot;--debug&quot;,
                &quot;--verbosity=diagnostic&quot;,
                &quot;--configuration=debug&quot;
            ],
            &quot;cwd&quot;: &quot;${workspaceRoot}&quot;,
            &quot;stopAtEntry&quot;: true,
            &quot;externalConsole&quot;: false
        }
    ]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们通过单步调试或者通过控制台输入的方式可以看到,configuration参数的值传入了.&lt;/p&gt;
</description>
<pubDate>Mon, 22 Jul 2019 00:07:00 +0000</pubDate>
<dc:creator>周国通</dc:creator>
<og:description>'系列目录' 使用Visual Studio来开发工具 前面我们都是通过手写或者复制的方法来编写Cake文件,Cake使用的是C 语言,如果仅使用简单的文本编辑器来编写显然效率是非常低下的,本节我们讲</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tylerzhou/p/11223736.html</dc:identifier>
</item>
<item>
<title>动手造轮子：实现一个简单的 EventBus - WeihanLi</title>
<link>http://www.cnblogs.com/weihanli/p/implement-a-simple-event-bus.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/weihanli/p/implement-a-simple-event-bus.html</guid>
<description>&lt;h2 id=&quot;intro&quot;&gt;Intro&lt;/h2&gt;
&lt;p&gt;EventBus 是一种事件发布订阅模式，通过 EventBus 我们可以很方便的实现解耦，将事件的发起和事件的处理的很好的分隔开来，很好的实现解耦。 微软官方的示例项目 &lt;a href=&quot;https://github.com/dotnet-architecture/eShopOnContainers&quot;&gt;EShopOnContainers&lt;/a&gt; 也有在使用 EventBus 。&lt;/p&gt;
&lt;p&gt;这里的 EventBus 实现也是参考借鉴了微软 eShopOnContainers 项目。&lt;/p&gt;
&lt;p&gt;EventBus 处理流程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/489462/201907/489462-20190722075616352-730970754.png&quot; alt=&quot;event bus flow&quot;/&gt;&lt;/p&gt;
&lt;p&gt;微服务间使用 EventBus 实现系统间解耦：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/489462/201907/489462-20190722075549405-993992564.png&quot; alt=&quot;event bus in microservice&quot;/&gt;&lt;/p&gt;
&lt;p&gt;借助 EventBus 我们可以很好的实现组件之间，服务之间，系统之间的解耦以及相互通信的问题。&lt;/p&gt;
&lt;p&gt;起初觉得 EventBus 和 MQ 其实差不多嘛，都是通过异步处理来实现解耦合，高性能。后来看到了下面这张图才算明白为什么要用 EventBus 以及 EventBus 和 MQ 之间的关系，EventBus 是抽象的，可以用MQ来实现 EventBus.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/489462/201907/489462-20190722075507743-761237444.png&quot; alt=&quot;eventbus implement&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;为什么要使用-eventbus&quot;&gt;为什么要使用 EventBus&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;解耦合(轻松的实现系统间解耦)&lt;/li&gt;
&lt;li&gt;高性能可扩展（每一个事件都是简单独立且不可更改的对象，只需要保存新增的事件，不涉及其他的变更删除操作）&lt;/li&gt;
&lt;li&gt;系统审计（每一个事件都是不可变更的，每一个事件都是可追溯的）&lt;/li&gt;
&lt;li&gt;...&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;eventbus-整体架构&quot;&gt;EventBus 整体架构：&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;IEventBase&lt;/code&gt; :所有的事件应该实现这个接口，这个接口定义了事件的唯一id &lt;code&gt;EventId&lt;/code&gt; 和事件发生的事件 &lt;code&gt;EventAt&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/489462/201907/489462-20190722075132601-1873945788.png&quot; alt=&quot;IEventBase&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;IEventHandler&lt;/code&gt;：定义了一个 &lt;code&gt;Handle&lt;/code&gt; 方法来处理相应的事件&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/489462/201907/489462-20190722075102235-7801580.png&quot; alt=&quot;IEventHandler&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;IEventStore&lt;/code&gt;：所有的事件的处理存储，保存事件的&lt;code&gt;IEventHandler&lt;/code&gt;，一般不会直接操作，通过 EventBus 的订阅和取消订阅来操作 &lt;code&gt;EventStore&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/489462/201907/489462-20190722075039581-119440088.png&quot; alt=&quot;IEventStore&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;IEventBus&lt;/code&gt;：用来发布/订阅/取消订阅事件，并将事件的某一个 &lt;code&gt;IEventHandler&lt;/code&gt; 保存到 EventStore 或从 EventStore 中移除&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/489462/201907/489462-20190722075010593-1805109706.png&quot; alt=&quot;IEventBus&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;使用示例&quot;&gt;使用示例&lt;/h2&gt;
&lt;p&gt;来看一个使用示例，&lt;a href=&quot;https://github.com/WeihanLi/WeihanLi.Common/blob/b11ba3dc36eb1cea18716b844c40a6bed02a05aa/samples/DotNetCoreSample/EventTest.cs&quot;&gt;完整代码示例&lt;/a&gt;：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;internal class EventTest
{
    public static void MainTest()
    {
        var eventBus = DependencyResolver.Current.ResolveService&amp;lt;IEventBus&amp;gt;();
        eventBus.Subscribe&amp;lt;CounterEvent, CounterEventHandler1&amp;gt;();
        eventBus.Subscribe&amp;lt;CounterEvent, CounterEventHandler2&amp;gt;();
        eventBus.Subscribe&amp;lt;CounterEvent, DelegateEventHandler&amp;lt;CounterEvent&amp;gt;&amp;gt;();
        eventBus.Publish(new CounterEvent { Counter = 1 });

        eventBus.Unsubscribe&amp;lt;CounterEvent, CounterEventHandler1&amp;gt;();
        eventBus.Unsubscribe&amp;lt;CounterEvent, DelegateEventHandler&amp;lt;CounterEvent&amp;gt;&amp;gt;();
        eventBus.Publish(new CounterEvent { Counter = 2 });
    }
}

internal class CounterEvent : EventBase
{
    public int Counter { get; set; }
}

internal class CounterEventHandler1 : IEventHandler&amp;lt;CounterEvent&amp;gt;
{
    public Task Handle(CounterEvent @event)
    {
        LogHelper.GetLogger&amp;lt;CounterEventHandler1&amp;gt;().Info($&quot;Event Info: {@event.ToJson()}, Handler Type:{GetType().FullName}&quot;);
        return Task.CompletedTask;
    }
}

internal class CounterEventHandler2 : IEventHandler&amp;lt;CounterEvent&amp;gt;
{
    public Task Handle(CounterEvent @event)
    {
        LogHelper.GetLogger&amp;lt;CounterEventHandler2&amp;gt;().Info($&quot;Event Info: {@event.ToJson()}, Handler Type:{GetType().FullName}&quot;);
        return Task.CompletedTask;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;具体实现&quot;&gt;具体实现&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/WeihanLi/WeihanLi.Common/blob/b11ba3dc36eb1cea18716b844c40a6bed02a05aa/src/WeihanLi.Common/Event/EventStoreInMemory.cs&quot;&gt;EventStoreInMemory&lt;/a&gt; 实现：&lt;/p&gt;
&lt;p&gt;EventStoreInMemory 是 &lt;code&gt;IEventStore&lt;/code&gt; 将数据放在内存中的实现，使用了 ConcurrentDictionary 以及 HashSet 来尽可能的保证高效，具体实现代码如下：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class EventStoreInMemory : IEventStore
{
    private readonly ConcurrentDictionary&amp;lt;string, HashSet&amp;lt;Type&amp;gt;&amp;gt; _eventHandlers = new ConcurrentDictionary&amp;lt;string, HashSet&amp;lt;Type&amp;gt;&amp;gt;();

    public bool AddSubscription&amp;lt;TEvent, TEventHandler&amp;gt;()
        where TEvent : IEventBase
        where TEventHandler : IEventHandler&amp;lt;TEvent&amp;gt;
    {
        var eventKey = GetEventKey&amp;lt;TEvent&amp;gt;();
        if (_eventHandlers.ContainsKey(eventKey))
        {
            return _eventHandlers[eventKey].Add(typeof(TEventHandler));
        }
        else
        {
            return _eventHandlers.TryAdd(eventKey, new HashSet&amp;lt;Type&amp;gt;()
            {
                typeof(TEventHandler)
            });
        }
    }

    public bool Clear()
    {
        _eventHandlers.Clear();
        return true;
    }

    public ICollection&amp;lt;Type&amp;gt; GetEventHandlerTypes&amp;lt;TEvent&amp;gt;() where TEvent : IEventBase
    {
        if(_eventHandlers.Count == 0)
            return  new Type[0];
        var eventKey = GetEventKey&amp;lt;TEvent&amp;gt;();
        if (_eventHandlers.TryGetValue(eventKey, out var handlers))
        {
            return handlers;
        }
        return new Type[0];
    }

    public string GetEventKey&amp;lt;TEvent&amp;gt;()
    {
        return typeof(TEvent).FullName;
    }

    public bool HasSubscriptionsForEvent&amp;lt;TEvent&amp;gt;() where TEvent : IEventBase
    {
        if(_eventHandlers.Count == 0)
            return false;

        var eventKey = GetEventKey&amp;lt;TEvent&amp;gt;();
        return _eventHandlers.ContainsKey(eventKey);
    }

    public bool RemoveSubscription&amp;lt;TEvent, TEventHandler&amp;gt;()
        where TEvent : IEventBase
        where TEventHandler : IEventHandler&amp;lt;TEvent&amp;gt;
    {
        if(_eventHandlers.Count == 0)
            return false;

        var eventKey = GetEventKey&amp;lt;TEvent&amp;gt;();
        if (_eventHandlers.ContainsKey(eventKey))
        {
            return _eventHandlers[eventKey].Remove(typeof(TEventHandler));
        }
        return false;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/WeihanLi/WeihanLi.Common/blob/b11ba3dc36eb1cea18716b844c40a6bed02a05aa/src/WeihanLi.Common/Event/EventBus.cs&quot;&gt;EventBus&lt;/a&gt; 的实现，从上面可以看到 EventStore 保存的是 &lt;code&gt;IEventHandler&lt;/code&gt; 对应的 Type，在 Publish 的时候根据 Type 从 IoC 容器中取得相应的 Handler 即可，如果没有在 IoC 容器中找到对应的类型，则会尝试创建一个类型实例，然后调用 &lt;code&gt;IEventHandler&lt;/code&gt; 的 &lt;code&gt;Handle&lt;/code&gt; 方法，代码如下：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// EventBus in process
/// &amp;lt;/summary&amp;gt;
public class EventBus : IEventBus
{
    private static readonly ILogHelperLogger Logger = Helpers.LogHelper.GetLogger&amp;lt;EventBus&amp;gt;();

    private readonly IEventStore _eventStore;
    private readonly IServiceProvider _serviceProvider;

    public EventBus(IEventStore eventStore, IServiceProvider serviceProvider = null)
    {
        _eventStore = eventStore;
        _serviceProvider = serviceProvider ?? DependencyResolver.Current;
    }

    public bool Publish&amp;lt;TEvent&amp;gt;(TEvent @event) where TEvent : IEventBase
    {
        if (!_eventStore.HasSubscriptionsForEvent&amp;lt;TEvent&amp;gt;())
        {
            return false;
        }
        var handlers = _eventStore.GetEventHandlerTypes&amp;lt;TEvent&amp;gt;();
        if (handlers.Count &amp;gt; 0)
        {
            var handlerTasks = new List&amp;lt;Task&amp;gt;();
            foreach (var handlerType in handlers)
            {
                try
                {
                    if (_serviceProvider.GetServiceOrCreateInstance(handlerType) is IEventHandler&amp;lt;TEvent&amp;gt; handler)
                    {
                        handlerTasks.Add(handler.Handle(@event));
                    }
                }
                catch (Exception ex)
                {
                    Logger.Error(ex, $&quot;handle event [{_eventStore.GetEventKey&amp;lt;TEvent&amp;gt;()}] error, eventHandlerType:{handlerType.FullName}&quot;);
                }
            }
            handlerTasks.WhenAll().ConfigureAwait(false);

            return true;
        }
        return false;
    }

    public bool Subscribe&amp;lt;TEvent, TEventHandler&amp;gt;()
        where TEvent : IEventBase
        where TEventHandler : IEventHandler&amp;lt;TEvent&amp;gt;
    {
        return _eventStore.AddSubscription&amp;lt;TEvent, TEventHandler&amp;gt;();
    }

    public bool Unsubscribe&amp;lt;TEvent, TEventHandler&amp;gt;()
        where TEvent : IEventBase
        where TEventHandler : IEventHandler&amp;lt;TEvent&amp;gt;
    {
        return _eventStore.RemoveSubscription&amp;lt;TEvent, TEventHandler&amp;gt;();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;项目实例&quot;&gt;项目实例&lt;/h2&gt;
&lt;p&gt;来看一个实际的项目中的使用，在我的活动室预约项目中有一个公告的模块，访问公告详情页面，这个公告的访问次数加1，把这个访问次数加1改成了用 EventBus 来实现，实际项目代码：&lt;a href=&quot;https://github.com/WeihanLi/ActivityReservation/blob/67e2cb8e92876629a7af6dc051745dd8c7e9faeb/ActivityReservation/Startup.cs&quot; class=&quot;uri&quot;&gt;https://github.com/WeihanLi/ActivityReservation/blob/67e2cb8e92876629a7af6dc051745dd8c7e9faeb/ActivityReservation/Startup.cs&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;定义 Event 以及 EventHandler&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class NoticeViewEvent : EventBase
{
    public Guid NoticeId { get; set; }

    // UserId
    // IP
    // ...
}

public class NoticeViewEventHandler : IEventHandler&amp;lt;NoticeViewEvent&amp;gt;
{
    public async Task Handle(NoticeViewEvent @event)
    {
        await DependencyResolver.Current.TryInvokeServiceAsync&amp;lt;ReservationDbContext&amp;gt;(async dbContext =&amp;gt;
        {
            var notice = await dbContext.Notices.FindAsync(@event.NoticeId);
            notice.NoticeVisitCount += 1;
            await dbContext.SaveChangesAsync();
        });
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的 Event 只定义了一个 NoticeId ，其实也可以把请求信息如IP/UA等信息加进去，在 EventHandler里处理以便日后数据分析。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;注册 EventBus 相关服务以及 EventHandlers&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;services.AddSingleton&amp;lt;IEventBus, EventBus&amp;gt;();
services.AddSingleton&amp;lt;IEventStore, EventStoreInMemory&amp;gt;();
//register EventHandlers
services.AddSingleton&amp;lt;NoticeViewEventHandler&amp;gt;();&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;订阅事件&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public void Configure(IApplicationBuilder app, IHostingEnvironment env, ILoggerFactory loggerFactory, IEventBus eventBus)
{
    eventBus.Subscribe&amp;lt;NoticeViewEvent, NoticeViewEventHandler&amp;gt;(); 
    // ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;发布事件&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;eventBus.Publish(new NoticeViewEvent { NoticeId = notice.NoticeId });&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
</description>
<pubDate>Sun, 21 Jul 2019 23:58:00 +0000</pubDate>
<dc:creator>WeihanLi</dc:creator>
<og:description>动手造轮子：实现一个简单的 EventBus Intro EventBus 是一种事件发布订阅模式，通过 EventBus 我们可以很方便的实现解耦，将事件的发起和事件的处理的很好的分隔开来，很好的实</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/weihanli/p/implement-a-simple-event-bus.html</dc:identifier>
</item>
<item>
<title>Windows下ElasticSearch的Head安装及基本使用 - 温一壶清酒</title>
<link>http://www.cnblogs.com/hong-fithing/p/11221020.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hong-fithing/p/11221020.html</guid>
<description>&lt;p&gt;前段时间，有一朋友咨询我，说es的head插件一直安装失败，为了给朋友解惑，自己百度博文并实践了一番，也的确踩了些坑，但我给爬了起来。今天就来分享下实践心得并跳过的坑。&lt;/p&gt;
&lt;p&gt;ElasticSearch 是一个分布式、高扩展、高实时的搜索与数据分析引擎，它能很方便的使大量数据具有搜索、分析和探索的能力，简称es。本文分五部分描述，es的安装，head插件安装，es的基本概念，es的基本使用，问题总结。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/hong-fithing/p/11221020.html#es_install&quot;&gt;es安装&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/hong-fithing/p/11221020.html#es_head_install&quot;&gt;head插件安装&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/hong-fithing/p/11221020.html#es_basic_notion&quot;&gt;es基本概念&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/hong-fithing/p/11221020.html#es_basic_use&quot;&gt;es基本使用&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/hong-fithing/p/11221020.html#problem_list&quot;&gt;问题总结&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;一、es安装&lt;/h2&gt;
&lt;p&gt;安装方式网络上有很多，这里简单说下步骤，具体实践是很简单的&lt;/p&gt;
&lt;h3&gt;①配置java环境&lt;/h3&gt;
&lt;p&gt;需要java环境，最好是较新的java环境，java环境的配置就略过了&lt;/p&gt;
&lt;h3&gt;②安装elasticsearch&lt;/h3&gt;
&lt;p&gt;下载地址：&lt;a href=&quot;https://www.elastic.co/cn/downloads/elasticsearch&quot;&gt;https://www.elastic.co/cn/downloads/elasticsearch&lt;/a&gt;，最新版本已是7.2.0。下载后，解压到任意目录，我的路径是：D:\elasticsearch-7.2.0&lt;/p&gt;
&lt;h3&gt;③启动elasticsearch&lt;/h3&gt;
&lt;p&gt;es的配置文件在config目录下，常用配置在elasticsearch.yml文件。我这里只是做学习目的，所以不修改此文件而直接启动es。在windows环境下启动es方法为命令行进入到bin\目录下，执行elasticsearch.bat，或者双击此文件以启动es。&lt;/p&gt;
&lt;p&gt;启动日志如下：&lt;/p&gt;
&lt;div readability=&quot;76.284686844471&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1242227/201907/1242227-20190721112710525-1781224165.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;es的默认端口是9200，在浏览器打开网址：localhost:9200，出现如下截图，则说明es已经安装成功了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1242227/201907/1242227-20190721112851618-53025545.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;es的安装是不是很简单？接下来来安装head插件&lt;/p&gt;
&lt;h2&gt;二、head插件安装&lt;/h2&gt;
&lt;h3&gt;1.安装node&lt;/h3&gt;
&lt;p&gt;es5以上就需要安装node和grunt，所以安装head插件的前提，是需要把该两项配置好。&lt;/p&gt;
&lt;p&gt;node下载地址：&lt;a href=&quot;https://nodejs.org/en/download/&quot;&gt;https://nodejs.org/en/download/&lt;/a&gt;，下载对应环境的node版本安装即可，安装步骤略过了。&lt;/p&gt;
&lt;p&gt;安装过程结束后，在dos窗口查看是否安装成功，使用命令：node -v，出现如下截图，则说明安装成功。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1242227/201907/1242227-20190721113440278-2101002948.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;2.安装grunt&lt;/h3&gt;
&lt;p&gt;在node安装路径下，使用命令安装：npm install -g grunt-cli 安装grunt。&lt;/p&gt;
&lt;p&gt;安装结束后，使用命令grunt -version查看是否安装成功，出现如下截图，说明安装成功。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1242227/201907/1242227-20190721113716222-1529499018.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;3.安装head插件&lt;/h3&gt;
&lt;h4&gt;①下载head插件&lt;/h4&gt;
&lt;p&gt;下载地址：https://github.com/mobz/elasticsearch-head，下载zip包&lt;/p&gt;
&lt;h4&gt;②解压zip包&lt;/h4&gt;
&lt;p&gt;我的解压路径：D:\elasticsearch-7.2.0\elasticsearch-head-master&lt;/p&gt;
&lt;h4&gt;③安装pathomjs&lt;/h4&gt;
&lt;p&gt;在dos窗口进入到head路径下，使用命令npm install安装pathomjs&lt;/p&gt;
&lt;h4&gt;④启用服务&lt;/h4&gt;
&lt;p&gt;使用命令npm start启用服务，出现如下截图，则说明服务启动成功&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1242227/201907/1242227-20190721114853610-1468354254.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;4.浏览器中访问&lt;/h3&gt;
&lt;p&gt;使用地址：localhost:9100访问，出现如下截图，则说明head安装成功，默认端口是9100&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1242227/201907/1242227-20190721115109557-1145550584.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;es和head插件都已安装成功，接下来介绍下es的基本概念及基本使用。&lt;/p&gt;
&lt;h2&gt;三、es的基本概念&lt;/h2&gt;
&lt;h3&gt;①集群和节点&lt;/h3&gt;
&lt;p&gt;一个es集群是由一个或多和es节点组成的集合，每一个集群都有一个名字，每个节点都有自己的名字，节点是可以存储数据， 参与索引数据的独立服务。&lt;/p&gt;
&lt;h3&gt;②索引(类似于数据库里面的database)&lt;/h3&gt;
&lt;p&gt;索引是含有相同属性的文档集合，索引在es中是通过一个名字来识别的，必须是英文字母小写，且不含中划线。&lt;/p&gt;
&lt;h3&gt;③类型(相当于sql中的table)&lt;/h3&gt;
&lt;p&gt;一个索引可以定义一个或多个类型，文档必须属于一个类型&lt;/p&gt;
&lt;h3&gt;④文档(相当于sql中的一行记录)&lt;/h3&gt;
&lt;p&gt;文档是可以被索引的基本数据单位&lt;/p&gt;
&lt;h3&gt;⑤分片&lt;/h3&gt;
&lt;p&gt;每个索引都有多个分片，每个分片都是一个luncene索引，分片的好处：分摊索引的搜索压力，分片还支持水平的拓展和拆分以及分布式的操作，可以提高搜索和其他处理的效率。&lt;/p&gt;
&lt;h3&gt;⑥备份&lt;/h3&gt;
&lt;p&gt;拷贝一个分片就完成了分片的备份，备份的好处：当主分片失败或者挂掉，备份就可以代替分片进行操作，进而提高了es的可用性，备份的分片还可以进行搜索操作，以分摊搜索的压力。es在创建索引时，默认创建5个分片，一份备份，可以修改，分片的数量只能在创建索引的时候指定，索引创建后就不能修改分片的数量了，而备份是可以动态修改的。&lt;/p&gt;
&lt;h3&gt;⑦数据类型&lt;/h3&gt;
&lt;p&gt;核心类型 字符串类型 string，text，keyword &lt;/p&gt;
&lt;p&gt;整数类型 integer，long，short，byte &lt;/p&gt;
&lt;p&gt;浮点类型 double，float，half_float，scaled_float &lt;/p&gt;
&lt;p&gt;逻辑类型 boolean &lt;/p&gt;
&lt;p&gt;日期类型 date &lt;/p&gt;
&lt;p&gt;范围类型 range &lt;/p&gt;
&lt;p&gt;二进制类型 binary &lt;/p&gt;
&lt;p&gt;复合类型 数组类型 array &lt;/p&gt;
&lt;p&gt;对象类型 object &lt;/p&gt;
&lt;p&gt;嵌套类型 nested &lt;/p&gt;
&lt;p&gt;地理类型 地理坐标类型 geo_point &lt;/p&gt;
&lt;p&gt;地理地图 geo_shape &lt;/p&gt;
&lt;p&gt;特殊类型 IP类型 ip &lt;/p&gt;
&lt;p&gt;范围类型 completion &lt;/p&gt;
&lt;p&gt;令牌计数类型 token_count &lt;/p&gt;
&lt;p&gt;附件类型 attachment &lt;/p&gt;
&lt;p&gt;抽取类型 percolator &lt;/p&gt;
&lt;h2&gt;四、es基本使用&lt;/h2&gt;
&lt;/div&gt;
&lt;h3&gt;1.es基本格式&lt;/h3&gt;
&lt;p&gt;es是以RESTFul风格来命名API的，其API的基本格式如下：&lt;/p&gt;
&lt;p&gt;http://&amp;lt;ip&amp;gt;:&amp;lt;port&amp;gt;/&amp;lt;索引&amp;gt;/&amp;lt;类型&amp;gt;/&amp;lt;文档id&amp;gt;&lt;/p&gt;
&lt;div readability=&quot;143.0496791934&quot;&gt;这里需要注意的是，该格式从es7.0.0开始，移除Type（类型）这个概念，新的基本格式如下：
&lt;p&gt;&lt;span&gt;http://&amp;lt;ip&amp;gt;:&amp;lt;port&amp;gt;/&amp;lt;索引&amp;gt;/_doc/&amp;lt;文档id&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Type（类型）字段那里变为固定值 _doc&lt;/p&gt;
&lt;p&gt;es的动作是以http方法来决定的: 常用的http方法: GET/PUT/POST/DELETE&lt;/p&gt;
&lt;h3&gt;2.创建索引&lt;/h3&gt;
&lt;p&gt;在head插件中创建，操作如下：&lt;/p&gt;
&lt;p&gt;点击索引&amp;gt;新建索引&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1242227/201907/1242227-20190721120619269-1451277249.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;弹出该提示，则说明创建成功&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1242227/201907/1242227-20190721120712809-679437125.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;3.查看索引信息&lt;/h3&gt;
&lt;p&gt;点击概览查看创建情况&lt;/p&gt;
&lt;p&gt;创建索引分为: &lt;strong&gt;结构化创建与非结构化创建&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;查看索引是否是结构化的方法：点击刚创建的索引信息，可查看到如下所示信息：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1242227/201907/1242227-20190721120826548-1187131516.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Mappings&lt;/strong&gt;是结构化的一个关键词，其后内容是空的，说明这个索引是一个非结构化的索引。&lt;/p&gt;
&lt;h3&gt;4.创建结构化索引&lt;/h3&gt;
&lt;p&gt;点击head插件的“复合查询”，输入内容如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1242227/201907/1242227-20190721122624971-176219321.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;勾选易读，点击验证json，可以检测json格式是否正确&lt;/p&gt;
&lt;p&gt;请求方式选择post，点击提交请求，返回如下截图数据，则表示创建成功&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1242227/201907/1242227-20190721122920073-137935740.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;创建成功后，可以返回到概览中查看索引信息，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1242227/201907/1242227-20190721123224362-996727299.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;也可以直接在复合查询中，改成get请求方式，提交请求，查看数据：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1242227/201907/1242227-20190721123317947-1700447610.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;5.数据插入&lt;/h3&gt;
&lt;p&gt;文档id, 唯一索引值, 指向文档数据&lt;/p&gt;
&lt;h4&gt;①指定文档id插入&lt;/h4&gt;
&lt;p&gt; 使用http中的&lt;strong&gt;put&lt;/strong&gt;方法，插入时输入的ip地址，http://localhost:9200/test/_doc/1&lt;/p&gt;
&lt;p&gt;请求参数依次为：索引名称/类型名称/文档id&lt;/p&gt;
&lt;p&gt;请求参数&lt;/p&gt;
&lt;p&gt;{&lt;br/&gt;&quot;duty&quot;: &quot;技术&quot;,&lt;br/&gt;&quot;age&quot;: 22,&lt;br/&gt;&quot;name&quot;: &quot;一壶清酒&quot;,&lt;br/&gt;&quot;date&quot;: &quot;2019-07-21 11:00:00&quot;&lt;br/&gt;}&lt;/p&gt;
&lt;p&gt;如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1242227/201907/1242227-20190721124029408-566434159.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在数据浏览中可查看到该条数据，如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1242227/201907/1242227-20190721124416412-1785254925.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;②自动产生文档id插入&lt;/h4&gt;
&lt;p&gt;使用http中的&lt;strong&gt;post&lt;/strong&gt;方法，插入时输入的ip地址：http://localhost:9200/test/_doc&lt;/p&gt;
&lt;p&gt;请求参数&lt;/p&gt;
&lt;p&gt;{&lt;br/&gt;&quot;duty&quot;: &quot;测试&quot;,&lt;br/&gt;&quot;age&quot;: 25,&lt;br/&gt;&quot;name&quot;: &quot;温一壶清酒&quot;,&lt;br/&gt;&quot;date&quot;: &quot;2019-07-21 11:05:00&quot;&lt;br/&gt;}&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1242227/201907/1242227-20190721124619939-256714241.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;依然到数据浏览中查看数据，如下所示，id为自动生成：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1242227/201907/1242227-20190721124813835-174222019.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;③postman插入数据&lt;/h4&gt;
&lt;p&gt;操作方式一样，只是改成了postman而已，入参如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1242227/201907/1242227-20190721130117535-2111272924.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;到数据浏览处查看数据，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1242227/201907/1242227-20190721130205323-174393855.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; postman的操作，就只引用了这一个例子，其他操作都一样，所以就不再赘述。&lt;/p&gt;
&lt;h3&gt;6.修改文档数据&lt;/h3&gt;
&lt;h4&gt;①直接修改文档&lt;/h4&gt;
&lt;p&gt;http方法: &lt;strong&gt;post&lt;/strong&gt;方法&lt;/p&gt;
&lt;p&gt;请求地址:  &lt;/p&gt;
&lt;p&gt;http://localhost:9200/test/_doc/1/_update&lt;/p&gt;
&lt;p&gt;请求参数&lt;/p&gt;
&lt;p&gt;{&lt;br/&gt;&quot;doc&quot;: {&lt;br/&gt;&quot;duty&quot;: &quot;技术&quot;,&lt;br/&gt;&quot;age&quot;: 22,&lt;br/&gt;&quot;name&quot;: &quot;我是一壶清酒&quot;,&lt;br/&gt;&quot;date&quot;: &quot;2019-07-21 11:06:00&quot;&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;
&lt;p&gt;关键词: _update，doc&lt;/p&gt;
&lt;p&gt;“doc”为关键字，要修改的文档放在doc中, 实例修改了type为test索引下_doc中id为1 的name和date属性&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1242227/201907/1242227-20190721124953870-682229450.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;到数据浏览处查看修改后的数据，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1242227/201907/1242227-20190721125329118-1565403016.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;②脚本修改文档&lt;/h4&gt;
&lt;p&gt;通过脚本修改的api格式与直接修改的是一致的&lt;/p&gt;
&lt;p&gt;http方法: &lt;strong&gt;post&lt;/strong&gt;方法&lt;/p&gt;
&lt;p&gt;请求地址：&lt;/p&gt;
&lt;p&gt;http://localhost:9200/test/_doc/1/_update&lt;/p&gt;
&lt;p&gt;请求参数&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;  &quot;script&quot;: {&lt;/p&gt;
&lt;p&gt;    &quot;lang&quot;: &quot;painless&quot;,&lt;/p&gt;
&lt;p&gt;    &quot;inline&quot;: &quot;ctx._source.age += 30&quot;&lt;/p&gt;
&lt;p&gt;  }&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;关键字”script”: 标志以脚本的方式修改文档&lt;/p&gt;
&lt;p&gt;“lang”：表示以何种脚本语言进行修改，“painless”表示以es内置的脚本语言进行修改。此外es还支持多种脚本语言，如Python，js等等&lt;/p&gt;
&lt;p&gt;“inline”：指定脚本内容 “ctx”代表es上下文，_source 代表文档&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1242227/201907/1242227-20190721125758489-2017371828.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;查看数据，age增加了5，如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1242227/201907/1242227-20190721125851452-1214999982.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt; 7.删除文档&lt;/h3&gt;
&lt;p&gt;http方法: &lt;strong&gt;delete&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;请求地址：&lt;/p&gt;
&lt;p&gt;http://localhost:9200/test/_doc/1&lt;/p&gt;
&lt;p&gt; 操作如下：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1242227/201907/1242227-20190721130340522-1059714815.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;到数据浏览处查看数据，已没用id为1的文档了，如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1242227/201907/1242227-20190721130439126-467800786.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;8.删除索引&lt;/h3&gt;
&lt;h4&gt;①索引概览中删除&lt;/h4&gt;
&lt;p&gt;点击已有索引的动作，会有个删除操作，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1242227/201907/1242227-20190721130628101-1430784619.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;输入删除，点击确定，该索引就被删除了，会返回一个true的提示框&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1242227/201907/1242227-20190721130713478-196555949.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再次查看，就只有一个索引了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1242227/201907/1242227-20190721130739147-2126163210.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;②通过api删除&lt;/h4&gt;
&lt;p&gt;http方法: &lt;strong&gt;delete&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;请求地址：&lt;/p&gt;
&lt;p&gt;http://localhost:9200/demo&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1242227/201907/1242227-20190721130854339-1801323892.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;五、问题总结&lt;/h2&gt;
&lt;h3&gt;1.grunt不是内部或外部命令&lt;/h3&gt;
&lt;p&gt;使用命令npm start启用服务时，报grunt不是内部或外部命令，如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1242227/201907/1242227-20190721131105073-1183956584.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;解决办法：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;将node安装路径，加到环境变量path路径下，重启dos窗口即可。&lt;/p&gt;
&lt;h3&gt;2.head服务启用失败&lt;/h3&gt;
&lt;p&gt;使用npm start命令启用服务，报错如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1242227/201907/1242227-20190721131428499-525157305.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;解决办法：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在es路径下执行命令 npm install，因为没有安装pathomjs，所以导致报错&lt;/p&gt;
&lt;h3&gt;3.提示未连接&lt;/h3&gt;
&lt;p&gt;head服务启用成功，通过localhost:9100访问，提示集群健康值：未连接&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1242227/201907/1242227-20190721131607277-1583790814.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;解决办法：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;需要在elasticsearch.yml文件中增加以下配置：&lt;/p&gt;
&lt;p&gt;http.cors.enabled: true&lt;/p&gt;
&lt;p&gt;http.cors.allow-origin: &quot;*&quot;&lt;/p&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;p&gt;http.cors.enabled:true 如果启用了 HTTP 端口，那么此属性会指定是否允许跨源 REST 请求。&lt;/p&gt;
&lt;p&gt;http.cors.allowed.origin:&quot;*&quot; 如果 http.cors.enabled 的值为 true，那么该属性会指定允许 REST 请求来自何处。&lt;/p&gt;
&lt;p&gt;重启服务，再次访问，则恢复正常&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1242227/201907/1242227-20190721131927552-1291467256.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;小结&lt;/h2&gt;
&lt;p&gt;全文通读到此，发现ElasticSearch的安装、head插件的安装其实很简单，并不是那么难。es的使用，就需要学习些基本的概念，知识的海洋是渊博的，此次介绍的es的使用，也只是简单的增删改查，属于很浅薄的知识。自己在摸索的时候，也是一点一点学习，百度以前前辈们的博文学习、摸索。只要努力，遇到问题，积极去解决，我相信一定会成功。文中观点，有误之处，欢迎批评指正&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;29.483394833948&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;strong&gt;本文仅代表作者观点，系作者@温一壶清酒发表。&lt;br/&gt;欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。&lt;br/&gt;文章出处：&lt;a href=&quot;http://www.cnblogs.com/hong-fithing/&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/hong-fithing/&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Sun, 21 Jul 2019 23:52:00 +0000</pubDate>
<dc:creator>温一壶清酒</dc:creator>
<og:description>前段时间，有一朋友咨询我，说es的head插件一直安装失败，为了给朋友解惑，自己百度博文并实践了一番，也的确踩了些坑，但我给爬了起来。今天就来分享下实践心得并跳过的坑。 ElasticSearch 是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/hong-fithing/p/11221020.html</dc:identifier>
</item>
<item>
<title>荐读|属性与可直接访问的数据成员之间应该如何选 - 依乐祝</title>
<link>http://www.cnblogs.com/yilezhu/p/11221447.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yilezhu/p/11221447.html</guid>
<description>&lt;h2 id=&quot;写在前面&quot;&gt;写在前面&lt;/h2&gt;
&lt;p&gt;在书写C#代码的时候你是否有过这样的经历：经常混用属性以及公有的数据成员。毕竟他们的用法基本一致，对于使用来说好像没什么区别啊。其实我也经常使用类的公有的数据成员来定义一些常量，为了简单，在一些仅仅需要对外暴露一些常量的类中（如定义一些全局使用的常量），也都是通过定义公有数据成员实现的。直到看到世界世界知名专家&lt;code&gt;Bill Wagner&lt;/code&gt;的那本《More Effective C#》之后才意识到应该尽量“使用属性而不是可直接访问的数据成员”。因为属性具有修改的便捷性，多线程的支持等等。&lt;/p&gt;
&lt;blockquote readability=&quot;2.0987654320988&quot;&gt;
&lt;p&gt;作者：依乐祝&lt;br/&gt;原文地址：&lt;a href=&quot;https://www.cnblogs.com/yilezhu/p/11221447.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/yilezhu/p/11221447.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;为什么应该尽量使用属性&quot;&gt;为什么应该尽量使用属性&lt;/h2&gt;
&lt;p&gt;属性一直是C#语言的特色，目前的属性机制比C#刚引人它的时候更为完备，这使得开发者能够通过属性实现很多功能，例如，可以给&lt;code&gt;getter&lt;/code&gt;与&lt;code&gt;setter&lt;/code&gt; 设定不同的访问权限。与直接通过数据成员来编程的方式相比，自动属性可以省去大量的编程工作，而且开发者可以通过该机制轻松地定义出只读的属性。此外还可以结合以表达式为主体的 （ expression-bodied） 写法将代码变得更紧凑。 有了这些机制就不应该继续在类型中创建公有 （ publish） 字段， 也不应该继续手工编写&lt;code&gt;get&lt;/code&gt;与&lt;code&gt;set&lt;/code&gt;方法。 属性既可以令调用者通过公有接口访问相关的数据成员 ， 又可以确保这些成员得到面向对象式的封装。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注：在C#语言中， 属性这种元素可以像数据成员一样被访问， 但它们其实是通过方法来实现的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;方便修改&quot;&gt;方便修改&lt;/h3&gt;
&lt;p&gt;在所有的类与结构中，应该多使用属性，这样可以让你在发现新的需求时，更为方便的修改代码。比如说，如果你现在决定&lt;code&gt;Customer&lt;/code&gt;类型的&lt;code&gt;name(名字)&lt;/code&gt;数据不应该出现空白值，那么只需要修改&lt;code&gt;Name&lt;/code&gt;属性的代码即可：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class Customer
{
    private string name;
    public string name
    {
        get=&amp;gt;name;
        set
        {
            if(string.IsNullOrWhiteSpace(value))
            {
                throw new ArgumentException(
                    &quot;Name connot be blank&quot;,
                    nameof(Name)
                );
            }
            name=value;
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;假如当初没有通过公有属性来实现&lt;code&gt;Name&lt;/code&gt;，而是采用了公有数据成员，那么现在我们就必须在代码库里找到设置过该成员的每行代码，并逐个修改，这会浪费很多时间。&lt;/p&gt;
&lt;h3 id=&quot;多线程支持&quot;&gt;多线程支持&lt;/h3&gt;
&lt;p&gt;由于属性是通过方法实现的，因此，开发者很容易就能给它添加多线程的支持。例如可以像下面这样实现&lt;code&gt;get&lt;/code&gt;与·&lt;code&gt;set&lt;/code&gt;访问器，使外界对&lt;code&gt;Name&lt;/code&gt;数据的访问得以同步：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class Customer
{
    private object syncHandle = new object();

    private string name;
    public string name
    {
        get
        {
            lock (syncHandle)
            {
                return name;
            }
        }
        set
        {
            if (string.IsNullOrWhiteSpace(value))
            {
                throw new ArgumentException(
                    &quot;Name connot be blank&quot;,
                    nameof(Name)
                );
            }

            lock (syncHandle)
            {
                name = value;
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;方法具备的好处属性全有&quot;&gt;方法具备的好处，属性全有&lt;/h3&gt;
&lt;p&gt;C# 方法所具备的一些特性同样可以体现在属性身上，其中很明显的一条就是属性也可以声明为&lt;code&gt;virtual&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class Customer
{
    public virtual string Name
    {
        get;
        set;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;Note：刚才几个例子涉及属性的地方用的都是隐式写法。采用隐式写法时，开发者不用自己在属性的&lt;code&gt;getter&lt;/code&gt;与&lt;code&gt;setter&lt;/code&gt;中编写过多逻辑。也就是说，我们在用属性来表示比较简单的字段时，无需通过大量的模板代码来构建这个属性，编译器会为我们自动创建私有字段（该字段通常称为后援字段，并实现&lt;code&gt;get&lt;/code&gt;，&lt;code&gt;set&lt;/code&gt;这两个访问器所需的简单逻辑）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;可以是抽象的并成为接口的一部分&quot;&gt;可以是抽象的，并成为接口的一部分&lt;/h3&gt;
&lt;p&gt;属性也可以是抽象的，从而成为接口定义的一部分，这种属性写起来与隐士属性相似。下面这段代码，就演示了怎样在泛型接口中定义属性。虽然与隐士属性的写法相似，但这种属性没有对应的实现物，定义该属性的接口只是要求实现本接口的类型都必须满足接口所订立的契约，也就是必须正确的提供&lt;code&gt;Name&lt;/code&gt;及&lt;code&gt;Value&lt;/code&gt;这两个属性：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public interface INameValuePair&amp;lt;T&amp;gt;
{
    string Name { get; }
    T Value { get; set; }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;很方便的控制获取及设置权限&quot;&gt;很方便的控制获取及设置权限&lt;/h3&gt;
&lt;p&gt;对于类型中的属性来说，它的访问器分成&lt;code&gt;getter(获取器)&lt;/code&gt;与&lt;code&gt;setter(设置器)&lt;/code&gt;这两个单独的方法，这使得我们能够对二者施加不同的修饰符，以便分别控制外界对该属性的获取权限以及设置权限。由于这两种权限可以分开调整，因此我们能够通过属性更为灵活的封装数据元素：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class Customer
{
    public virtual string Name
    {
        get;
        protected set;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;带参数的属性&quot;&gt;带参数的属性&lt;/h3&gt;
&lt;p&gt;属性不只适用于简单的数字字段。如果某个类型要在其接口中发布能够用索引来访问的内容，那么就可以创建索引器。这相当于带有参数的属性，或者说参数化的属性。下面这种写法很有用，用它创建出的属性能够返回序列中的某个元素：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class Customer
{
    public virtual string Name
    {
        get;
        protected set;
    }

    public int this[int index]
    {
        get =&amp;gt; theValues[index];
        set =&amp;gt; theValues[index] = value;
    }

    private int[] theValues = new int[100];
}
//Accessing an indexer;
int val=someCustomer[i];&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此外，若参数是整数的一维索引器，则可以参与数据绑定，若参数不是整数的一维索引器，则可以用来定义映射关系：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;private Dictionary&amp;lt;string, Address&amp;gt; addressValues;
    public Address this[string name]
    {
        get =&amp;gt; addressValues[name];
        set =&amp;gt; addressValues[name] = value;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;注意：索引器一律要用this关键字来声明。由于C#不允许给索引器起名字，因此同一个类型的索引器必须在参数列表上有所区别，否则就会产生歧义。&lt;br/&gt;另外，索引器必须明确的实现出来，而不能像简单属性那样由系统默认生成。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;其他说明&quot;&gt;其他说明&lt;/h2&gt;
&lt;h3 id=&quot;后期再把数据成员改成属性&quot;&gt;后期再把数据成员改成属性&lt;/h3&gt;
&lt;p&gt;尽管属性是个相当好的机制，可是还有人想先创建普通的数据成员，然后在确实有必要的情况下再将其替换成属性，以便使用属性所具备的优势。这种想法听上去很有道理，但实际并不合适。例如，如下定义一个普通数据成员的代码：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class Customer
{
    public string Name;
}
string name = customerOne.Name;
customerOne.Name = &quot;yilezhu&quot;;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其实我也经常这样用，不过都是定义一些静态的全局常量。&lt;br/&gt;虽然在使用上属性可以像数据成员那样来访问，但是从MSIL的角度来看，却不是这样，因为访问属性时所使用的指令与访问数据成员所使用的指令是有区别的。因此如果把数据成员改成属性，则会破坏二进制层面的兼容机制，使得很难单独更新某一个程序集，需要全部更新。&lt;/p&gt;
&lt;h3 id=&quot;属性的性能损耗&quot;&gt;属性的性能损耗&lt;/h3&gt;
&lt;p&gt;你可能要问了，是以属性的形式访问数据比较快，还是以数据成员的形式访问比较快？其实前者的效率虽然不会超过后者，但也未必落后于它。因为JIT编译器会对某些方法调用进行内联处理，其中也包括属性。如果编译器对属性进行内联处理的话，那么它的效率就会与数据成员相同。即便没有内联，两者的差别也可以忽略不计。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;今天给大家介绍了使用属性来访问数据成员的诸多优势，因此建议如果要在类型的公有或受保护的接口中发布数据，那么应该以属性的形式来发布，对于序列或字典来说，应该以索引器的形式发布。在日常的开发中虽然用属性的形式来封装变量会占用你一到两分钟的时间，但是如果你一开始没有使用属性，后来想用属性来设计，那么可能就得用好几个小时去修正了。现在多花点时间，将来会省很多功夫。&lt;br/&gt;文章大多内容来自观看《More Effective C#》第一小节的内容所做的笔记，当然后续我还会对剩下的提升C#代码的50个方法进行总结记录，敬请期待吧。如果你有兴趣可以加DotNetCore实战项目交流群637326624跟大伙进行交流。&lt;/p&gt;
</description>
<pubDate>Sun, 21 Jul 2019 23:37:00 +0000</pubDate>
<dc:creator>依乐祝</dc:creator>
<og:description>写在前面 在书写C 代码的时候你是否有过这样的经历：经常混用属性以及公有的数据成员。毕竟他们的用法基本一致，对于使用来说好像没什么区别啊。其实我也经常使用类的公有的数据成员来定义一些常量，为了简单，在</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yilezhu/p/11221447.html</dc:identifier>
</item>
<item>
<title>JAVA面试题 StringBuffer和StringBuilder的区别，从源码角度分析? - Java蚂蚁</title>
<link>http://www.cnblogs.com/marsitman/p/11204313.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/marsitman/p/11204313.html</guid>
<description>&lt;p&gt;&lt;strong&gt;面试官Q1：请问StringBuffer和StringBuilder有什么区别？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这是一个老生常谈的话题，笔者前几年每次面试都会被问到，作为基础面试题，被问到的概率百分之八九十。下面我们从面试需要答到的几个知识点来总结一下两者的区别有哪些？&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;
&lt;p&gt;继承关系？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如何实现的扩容？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;线程安全性？&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;继承关系&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从源码上看看类StringBuffer和StringBuilder的继承结构：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1223046/201907/1223046-20190719215316025-48027996.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从结构图上可以直到，StringBuffer和StringBuiler都继承自AbstractStringBuilder类&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;如何实现扩容&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;StringBuffer和StringBuiler的扩容的机制在抽象类AbstractStringBuilder中实现，当发现长度不够的时候(默认长度是16)，会自动进行扩容工作，扩展为原数组长度的2倍加2，创建一个新的数组，并将数组的数据复制到新数组。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;42&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public void ensureCapacity(int minimumCapacity) {
    if (minimumCapacity &amp;gt; 0)
        ensureCapacityInternal(minimumCapacity);
}

/**
* 确保value字符数组不会越界.重新new一个数组,引用指向value
*/    
private void ensureCapacityInternal(int minimumCapacity) {
    // overflow-conscious code
    if (minimumCapacity - value.length &amp;gt; 0) {
        value = Arrays.copyOf(value,
                newCapacity(minimumCapacity));
    }
}

/**
* 扩容:将长度扩展到之前大小的2倍+2
*/    
private int newCapacity(int minCapacity) {
    // overflow-conscious code   扩大2倍+2
    //这里可能会溢出,溢出后是负数哈,注意
    int newCapacity = (value.length &amp;lt;&amp;lt; 1) + 2;
    if (newCapacity - minCapacity &amp;lt; 0) {
        newCapacity = minCapacity;
    }
    //MAX_ARRAY_SIZE的值是Integer.MAX_VALUE - 8,先判断一下预期容量(newCapacity)是否在0&amp;lt;x&amp;lt;MAX_ARRAY_SIZE之间,在这区间内就直接将数值返回,不在这区间就去判断一下是否溢出
    return (newCapacity &amp;lt;= 0 || MAX_ARRAY_SIZE - newCapacity &amp;lt; 0)
        ? hugeCapacity(minCapacity)
        : newCapacity;
}

/**
* 判断大小，是否溢出
*/
private int hugeCapacity(int minCapacity) {
    if (Integer.MAX_VALUE - minCapacity &amp;lt; 0) { // overflow
        throw new OutOfMemoryError();
    }
    return (minCapacity &amp;gt; MAX_ARRAY_SIZE)
        ? minCapacity : MAX_ARRAY_SIZE;
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;线程安全性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们先来看看StringBuffer的相关方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;43&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
@Override
public synchronized StringBuffer append(long lng) {
    toStringCache = null;
    super.append(lng);
    return this;
}

/**
 * @throws StringIndexOutOfBoundsException {@inheritDoc}
 * @since      1.2
 */
@Override
public synchronized StringBuffer replace(int start, int end, String str) {
    toStringCache = null;
    super.replace(start, end, str);
    return this;
}

/**
 * @throws StringIndexOutOfBoundsException {@inheritDoc}
 * @since      1.2
 */
@Override
public synchronized String substring(int start) {
    return substring(start, count);
}

@Override
public synchronized String toString() {
    if (toStringCache == null) {
        toStringCache = Arrays.copyOfRange(value, 0, count);
    }
    return new String(toStringCache, true);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从上面的源码中我们看到几乎都是所有方法都加了synchronized,几乎都是调用的父类的方法.，用synchronized关键字修饰意味着什么？加锁，资源同步串行化处理，所以是线程安全的。&lt;/p&gt;

&lt;p&gt;我们再来看看StringBuilder的相关源码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
@Override
public StringBuilder append(double d) {
    super.append(d);
    return this;
}

/**
 * @since 1.5
 */
@Override
public StringBuilder appendCodePoint(int codePoint) {
    super.appendCodePoint(codePoint);
    return this;
}

/**
 * @throws StringIndexOutOfBoundsException {@inheritDoc}
 */
@Override
public StringBuilder delete(int start, int end) {
    super.delete(start, end);
    return this;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;StringBuilder的源码里面，基本上所有方法都没有用synchronized关键字修饰，当多线程访问时，就会出现线程安全性问题。&lt;/p&gt;

&lt;p&gt;为了证明StringBuffer线程安全，StringBuilder线程不安全，我们通过一段代码进行验证：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;测试思想&lt;/strong&gt;&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;分别用1000个线程写StringBuffer和StringBuilder，&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;使用CountDownLatch保证在各自1000个线程执行完之后才打印StringBuffer和StringBuilder长度，&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;观察结果。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;测试代码&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
import java.util.concurrent.CountDownLatch;

public class TestStringBuilderAndStringBuffer {
    public static void main(String[] args) {
        //证明StringBuffer线程安全，StringBuilder线程不安全
        StringBuffer stringBuffer = new StringBuffer();
        StringBuilder stringBuilder = new StringBuilder();
        CountDownLatch latch1 = new CountDownLatch(1000);
        CountDownLatch latch2 = new CountDownLatch(1000);
        for (int i = 0; i &amp;lt; 1000; i++) {
            new Thread(new Runnable() {
                @Override
                public void run() {
                    try {
                        stringBuilder.append(1);
                    } catch (Exception e) {
                        e.printStackTrace();
                    } finally {
                        latch1.countDown();
                    }
                }
            }).start();
        }
        for (int i = 0; i &amp;lt; 1000; i++) {
            new Thread(new Runnable() {
                @Override
                public void run() {
                    try {
                        stringBuffer.append(1);
                    } catch (Exception e) {
                        e.printStackTrace();
                    } finally {
                        latch2.countDown();
                    }

                }
            }).start();
        }
        try {
            latch1.await();
            System.out.println(stringBuilder.length());
            latch2.await();
            System.out.println(stringBuffer.length());
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;测试结果&lt;/strong&gt;&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;StringBuffer不论运行多少次都是1000长度。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;StringBuilder绝大多数情况长度都会小于1000。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;StringBuffer线程安全，StringBuilder线程不安全得到证明。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;总结一下&lt;/strong&gt;&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;StringBuffer和StringBuilder都继承自抽象类AbstractStringBuilder。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;存储数据的字符数组也没有被final修饰，说明值可以改变，且构造出来的字符串还有空余位置拼接字符串，但是拼接下去肯定也有不够用的时候，这时候它们内部都提供了一个自动扩容机制，当发现长度不够的时候(默认长度是16)，会自动进行扩容工作，扩展为原数组长度的2倍加2，创建一个新的数组，并将数组的数据复制到新数组，所以对于拼接字符串效率要比String要高。自动扩容机制是在抽象类中实现的。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;线程安全性：StringBuffer效率低，线程安全，因为StringBuffer中很多方法都被 synchronized 修饰了，多线程访问时，线程安全，但是效率低下，因为它有加锁和释放锁的过程。StringBuilder效率高，但是线程是不安全的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;各位老铁如果还有别的答案，可以评论留言哈！&lt;/p&gt;

</description>
<pubDate>Sun, 21 Jul 2019 23:01:00 +0000</pubDate>
<dc:creator>Java蚂蚁</dc:creator>
<og:description>Java面试题经常会问的问题 面试官Q1：请问StringBuffer和StringBuilder有什么区别？ 这是一个老生常谈的话题，笔者前几年每次面试都会被问到，作为基础面试题，被问到的概率百</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/marsitman/p/11204313.html</dc:identifier>
</item>
<item>
<title>简单的量子算法(二)：Simon's Algorithm - 夏天喵</title>
<link>http://www.cnblogs.com/zmzzzz/p/11223622.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zmzzzz/p/11223622.html</guid>
<description>&lt;p&gt;前情回顾：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/zmzzzz/p/11217776.html&quot;&gt;简单的量子算法(一)：Hadamard 变换、Parity Problem&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;好的，现在开始正版的故事，Simon’s Algorithm&lt;/p&gt;
&lt;h3 id=&quot;问题&quot;&gt;问题：&lt;/h3&gt;
&lt;p&gt;有一个secret string，是n位的0，1串 &lt;span class=&quot;math inline&quot;&gt;\(s \in \{0,1 \} ^n\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;现在有一个黑盒子，f(x)，我们对他唯一的了解就是 &lt;span class=&quot;math inline&quot;&gt;\(f(x)=f(x \oplus s)\)&lt;/span&gt; ，输入的x也是n位的0，1串 &lt;span class=&quot;math inline&quot;&gt;\(x \in \{0,1 \} ^n\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;请问，要多少次，我们可以找到这个secret string?&lt;/p&gt;
&lt;h3 id=&quot;经典解法&quot;&gt;经典解法：&lt;/h3&gt;
&lt;p&gt;如果我们能找到 &lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\(x \oplus s\)&lt;/span&gt; ，那么非常容易，就可以得到s，只要 &lt;span class=&quot;math inline&quot;&gt;\(x\oplus x\oplus s\)&lt;/span&gt; 。&lt;/p&gt;
&lt;p&gt;那么如果找到两个输入拥有相同的输出呢？&lt;/p&gt;
&lt;p&gt;这个问题其实是另一个大家都很熟悉的问题的变形，一群人中，要多少人就有两个人的生日是相同的，印象中，23人两个人的生日是相同的概率就大于50%了，如果有60个人，那么两个人生日相同的概率就超过99%了。&lt;/p&gt;
&lt;p&gt;这个问题和生日问题的解法是一样的，就不再累述了，想要知道的请搜索生日问题，在这里，我们给出一个大概的答案，是 &lt;span class=&quot;math inline&quot;&gt;\(2^{n/2}\)&lt;/span&gt; c次。&lt;/p&gt;
&lt;h3 id=&quot;量子解法&quot;&gt;量子解法：&lt;/h3&gt;
&lt;p&gt;量子解法一共有三步：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;set up random superposition $ \frac{1}{\sqrt2} |r\rangle +\frac{1}{\sqrt2} |r \oplus s \rangle$&lt;/li&gt;
&lt;li&gt;Fourier Sample to get a random y: &lt;span class=&quot;math inline&quot;&gt;\(y·s=0 (\mod 2)\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;repeat step n-1 times to generate n-1 linear equation.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;接下来，我们来一步一步的看每个步骤在做什么，以及怎么做：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1654058/201907/1654058-20190722014810547-61526007.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一步&lt;/strong&gt;，制造叠加态 $ \frac{1}{\sqrt2} |r\rangle +\frac{1}{\sqrt2} |r \oplus s \rangle$ ，这个可以通过图a实现。&lt;/p&gt;
&lt;p&gt;首先通过第一个&lt;span class=&quot;math inline&quot;&gt;\(H ^{\otimes n}\)&lt;/span&gt; 门，我们n比特的 &lt;span class=&quot;math inline&quot;&gt;\(|0\rangle\)&lt;/span&gt; 就成功的变成了叠加态 $\frac{1}{2^{\frac{n}{2}}} \sum_x |x\rangle $&lt;/p&gt;
&lt;p&gt;和 &lt;span class=&quot;math inline&quot;&gt;\(|b\rangle\)&lt;/span&gt; 一起通过 &lt;span class=&quot;math inline&quot;&gt;\(U_f\)&lt;/span&gt; ，得到的结果是 $\frac{1}{2^{\frac{n}{2}}} \sum_x |x\rangle|b\oplus f(x) \rangle $&lt;/p&gt;
&lt;p&gt;测量 &lt;span class=&quot;math inline&quot;&gt;\(|b\oplus f(x) \rangle\)&lt;/span&gt; ，只有结果是测量结果的 &lt;span class=&quot;math inline&quot;&gt;\(|x\rangle\)&lt;/span&gt;还在，其他的 &lt;span class=&quot;math inline&quot;&gt;\(|x\rangle\)&lt;/span&gt; 都会坍缩，基于这个黑盒子的特性，那么只有 $|r\rangle $ 和 &lt;span class=&quot;math inline&quot;&gt;\(|r \oplus s \rangle\)&lt;/span&gt; 会留下来，因为他们的f(x)是一样的，r是任意的一个序列，测量的结果对应哪个r就是哪个r。&lt;/p&gt;
&lt;p&gt;至此我们得到了想要的叠加态 $ \frac{1}{\sqrt2} |r\rangle +\frac{1}{\sqrt2} |r \oplus s \rangle$&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二步&lt;/strong&gt;，Fourier Sampling&lt;/p&gt;
&lt;p&gt;对我们得到的叠加态 $ \frac{1}{\sqrt2} |r\rangle +\frac{1}{\sqrt2} |r \oplus s \rangle$ Fourier Sampling&lt;/p&gt;
&lt;p&gt;再次通过&lt;span class=&quot;math inline&quot;&gt;\(H ^{\otimes n}\)&lt;/span&gt; 我们能得到什么？&lt;/p&gt;
&lt;p&gt;依照我们在&lt;a href=&quot;https://www.cnblogs.com/zmzzzz/p/11217776.html&quot;&gt;简单的量子算法(一)&lt;/a&gt;中的结论，我们知道 &lt;span class=&quot;math inline&quot;&gt;\(H^{\otimes n} |u\rangle = \sum_x \frac{-1^{u·x}}{2^{\frac{n}{2}}} |x\rangle\)&lt;/span&gt; 。&lt;/p&gt;
&lt;p&gt;那么&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\begin{align} H^{\otimes n} ( \frac{1}{\sqrt2} |r\rangle +\frac{1}{\sqrt2} |r \oplus s \rangle) &amp;amp;= \frac{1}{\sqrt2}\sum_x \frac{-1^{r·x}}{2^{n/2}} |x\rangle+\frac{1}{\sqrt2}\sum_x \frac{-1^{(r\oplus s)·x}}{2^{n/2}} |x\rangle \\ &amp;amp;=\sum_x (\frac{-1^{r·x}}{2^{(n+1)/2}}+\frac{-1^{(r\oplus s)·x}}{2^{(n+1)/2}}) |x\rangle \\ &amp;amp;= \sum_x\frac{1^{r·x}+(-1)^{(r\oplus s)·x}}{2^{(n+1)/2}}|x\rangle \end{align}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;此时，我们的问题已经集中在了 &lt;span class=&quot;math inline&quot;&gt;\(1^{r·x}+(-1)^{(r\oplus s)·x}\)&lt;/span&gt; 上。&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\((-1)^{(r\oplus s)·x}\)&lt;/span&gt; 可以写成&lt;span class=&quot;math inline&quot;&gt;\((-1)^{s·x}*(-1)^{r·x}\)&lt;/span&gt; （至于为什么可以，大家可以试一下都是按位操作，一共也就4种可能&lt;/p&gt;
&lt;p&gt;那么每种可能的概率的公式就可以写成&lt;span class=&quot;math inline&quot;&gt;\(\frac{（(-1)^{s·x}+1）*(-1)^{r·x}}{2^{(n+1/2)}}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;如果 &lt;span class=&quot;math inline&quot;&gt;\(s·x=0\)&lt;/span&gt; 那么，这个概率正好为 &lt;span class=&quot;math inline&quot;&gt;\(\frac{(-1)^{r·z}}{2^{(n-1)/2}}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;如果 &lt;span class=&quot;math inline&quot;&gt;\(s·x=-1\)&lt;/span&gt; 那么，这个概率正好为0&lt;/p&gt;
&lt;p&gt;那么这又说明了什么呢？&lt;/p&gt;
&lt;p&gt;这个说明只要我们测量 &lt;span class=&quot;math inline&quot;&gt;\(|x\rangle\)&lt;/span&gt; ，那么我们得到的x一定是 &lt;span class=&quot;math inline&quot;&gt;\(s·x=0\)&lt;/span&gt; 的，因为不为0的都被抵消了。&lt;/p&gt;
&lt;p&gt;那么得到了x，又意味着什么呢？&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(s·x=0\)&lt;/span&gt; 事实上我们是得到了一个等式 $s_1x_1+s_2x_2+……+s_nx_n =0 \mod 2 $&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第三步：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果我们把第一次测量得到的x编号为 &lt;span class=&quot;math inline&quot;&gt;\(x^1\)&lt;/span&gt; ，那么我们得到了等式 $s_1x_1^1+s_2x_2^1+……+s_nx_n^1 =0 \mod 2 $&lt;/p&gt;
&lt;p&gt;第二次测量，得到等式 $s_1x_1^1+s_2x_2^1+……+s_nx_n^1 =0 \mod 2 $&lt;/p&gt;
&lt;p&gt;以此类推，测量n-1次，得到了n-1个等式的方程式组。&lt;/p&gt;
&lt;p&gt;$s_1x_1^1+s_2x_2^1+……+s_nx_n^1 =0 \mod 2 $&lt;/p&gt;
&lt;p&gt;$s_1x_1^1+s_2x_2^1+……+s_nx_n^1 =0 \mod 2 $&lt;/p&gt;
&lt;p&gt;……&lt;/p&gt;
&lt;p&gt;$s_1x_1^{n-1}+s_2x_2^{n-1}+……+s_nx_n^{n-1} =0 \mod 2 $&lt;/p&gt;
&lt;p&gt;n-1个等式，n个未知数( &lt;span class=&quot;math inline&quot;&gt;\(s_1,s_2,……,s_n\)&lt;/span&gt; )，一般来说会有两组解，一组是全零的平凡解，这个是我们不要的，而另一组解就是我们的答案 &lt;span class=&quot;math inline&quot;&gt;\(s\)&lt;/span&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;成功的概率：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;上述的解方程有一个前提，那就是这是一个线性方程组，如果这个不是线性的，那么测量n-1次是不可能得答案的。&lt;/p&gt;
&lt;p&gt;那么我测量得到的x组成的方程是线性方程的概率是多少呢？&lt;/p&gt;
&lt;p&gt;我们可以列一个表格来看看：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(x^1\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(\frac{1}{2^{n-1}}\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(1-\frac{1}{2^{n-1}}\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(x^2\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;0、 &lt;span class=&quot;math inline&quot;&gt;\(x^1\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(\frac{2}{2^{n-1}}\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(1-\frac{1}{2^{n-2}}\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(x^3\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;0 、 &lt;span class=&quot;math inline&quot;&gt;\(x^1\)&lt;/span&gt; 、&lt;span class=&quot;math inline&quot;&gt;\(x^2\)&lt;/span&gt; 、&lt;span class=&quot;math inline&quot;&gt;\(x^1+x^2\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(\frac{4}{2^{n-1}}\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(1-\frac{1}{2^{n-3}}\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;……&lt;/td&gt;
&lt;td&gt;……&lt;/td&gt;
&lt;td&gt;…………&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(1-\frac{1}{2^{n-1}}\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(x^{n-1}\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;0 、 &lt;span class=&quot;math inline&quot;&gt;\(x^1\)&lt;/span&gt; ……&lt;span class=&quot;math inline&quot;&gt;\(x^1+x^2\)&lt;/span&gt;……&lt;span class=&quot;math inline&quot;&gt;\(x^1+x^2+……+x^n-2\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(\frac{2^{n-2}}{2^{n-1}}\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(1-\frac{1}{2}\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;每次的测量失败的情况分为以下三种情况：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;测量出来全是0&lt;/li&gt;
&lt;li&gt;测量出来结果和前面的是一样的&lt;/li&gt;
&lt;li&gt;测量出来的结果是前面测量结果的线性组合&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;因为这里算的成功概率都是独立的成功概率，所以要算整体的成功概率是他们的乘积&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(\frac{1}{2}*\frac{3}{4}*\frac{7}{8}*……*\frac{2^{n-1}-1}{2^{n-1}}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;上面这个式子求极限是一个q series的问题，感兴趣的朋友可以去查一下怎么求解，这里直接给出概率，约等于0.28878&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;大家是不是以为这样子就万事大吉了？&lt;/p&gt;
&lt;p&gt;No，这里还有一个需要注意的地方，可能很多朋友已经意识到了，量子态不是测量完就坍塌吗？为什么可以测量n-1次？&lt;/p&gt;
&lt;p&gt;事实上，这是把第一部分给做了n-1次，这样你才可以有n-1个 &lt;span class=&quot;math inline&quot;&gt;\(|x\rangle\)&lt;/span&gt; 给你测量找出满足线性条件的x。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参考资料：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=A2WP6Wvjrks&amp;amp;list=PLQ_YPCU361tJahfHW5k-bvPNrldp0tswl&amp;amp;index=3&quot;&gt;Quantume Mechanics &amp;amp; Quantume Computation Lecture 8&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 21 Jul 2019 17:52:00 +0000</pubDate>
<dc:creator>夏天喵</dc:creator>
<og:description>前情回顾： '简单的量子算法(一)：Hadamard 变换、Parity Problem' 好的，现在开始正版的故事，Simon’s Algorithm 问题： 有一个secret string，是n</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zmzzzz/p/11223622.html</dc:identifier>
</item>
<item>
<title>GeoPackage - 一个简便轻量的本地地理数据库 - 秋意正寒</title>
<link>http://www.cnblogs.com/onsummer/p/11223618.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/onsummer/p/11223618.html</guid>
<description>&lt;blockquote readability=&quot;9.448275862069&quot;&gt;
&lt;p&gt;GeoPackage（以下简称gpkg），内部使用SQLite实现的一种单文件、与操作系统无关的地理数据库。&lt;/p&gt;
&lt;p&gt;当前标准是1.2.1，该版本的html版说明书：&lt;a href=&quot;https://www.geopackage.org/spec121/index.html&quot;&gt;https://www.geopackage.org/spec121/index.html&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;本文简单介绍一些最需要关注的特点，因为笔者也是菜鸡（刚开始学）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2&gt;1.1 扩展名与数据库识别方法&lt;/h2&gt;
&lt;p&gt;它在非编辑、非连接状态时，扩展名是*.gpkg；在数据连接或编辑状态时，会多出来两个同名不同拓展名的文件：*.gpkg-wal、*.gpkg-shm。&lt;/p&gt;
&lt;p&gt;如果不确定获得的gpkg文件是否是SQLite数据库，可以用二进制查看器看最开始的字节信息，前16个字节应为以null结尾的ASCII字符串“SQLite format 3”。有关更多二进制信息，请到OGC官网上查看说明书。&lt;/p&gt;
&lt;h2&gt;1.2 数据存储上限与支持的数据&lt;/h2&gt;
&lt;p&gt;gpkg最大数据量为140TB（应该没多少项目用得到吧...）&lt;/p&gt;
&lt;p&gt;它能存储的数据有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;矢量数据&lt;/li&gt;
&lt;li&gt;栅格数据&lt;/li&gt;
&lt;li&gt;属性数据（非空间数据）&lt;/li&gt;
&lt;li&gt;其他&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;“其他”意味着可以扩展gpkg数据库，但是目前笔者没有这个能力。&lt;/p&gt;
&lt;h2&gt;1.3 与其他类似的本地数据库比较&lt;/h2&gt;
&lt;p&gt;因为单文件的特点，与ArcGIS家族中的Geodatabase模型的实现——mdb和gdb很像。它们同为本地数据库。&lt;/p&gt;
&lt;p&gt;gpkg没有类似ArcGIS中要素数据集的概念，也没有PostGIS中模式的概念（可能我没发现，暂时做狗头处理）&lt;/p&gt;
&lt;h2&gt;1.4 创建gpkg和打开gpkg的方法&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;如果想直接用SQL访问gpkg，请使用&lt;a href=&quot;http://sqlitebrowser.org/&quot;&gt;DB Browser for SQLite&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;如果要在网络端访问gpkg，推荐用&lt;a href=&quot;http://ngageoint.github.io/geopackage-js/&quot;&gt;NGA’s application&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;如果想在桌面端访问，那么可以用的工具有很多，比如GDAL、QGIS、ArcGIS等。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;gpkg可以直接被ArcGIS识别并增删改查数据（即ArcGIS内置了支持）&lt;/p&gt;
&lt;p&gt;gpkg也可以被QGIS识别并增删改查数据。&lt;/p&gt;
&lt;h2&gt;1.5 什么时候用gpkg&lt;/h2&gt;
&lt;p&gt;因为SQLite“单文件”、“轻量化”的特点，所以gpkg特别适用于小规模的场景和移动场景。比如学生练习、手机等。&lt;/p&gt;
&lt;p&gt;如果想多种途径创建gpkg，请阅读此文：&lt;a href=&quot;http://www.geopackage.org/guidance/getting-started.html#creating-a-geopackage&quot; target=&quot;_blank&quot;&gt;点我&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;但是，通常使用GIS桌面客户端就可以了。&lt;/p&gt;
&lt;h2&gt;1.6 支持gpkg的GIS客户端、服务器、开发工具&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;客户端：QGIS、ArcGIS（10.2.2及更高版本支持读写，总之用新版本就好了）、GeoTools、FME、Skyline、MapInfo等&lt;/li&gt;
&lt;li&gt;服务器：GeoServer&lt;/li&gt;
&lt;li&gt;开发工具：GDAL&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;此外，SpatialLite 4.2.0以上也支持gpkg。&lt;/p&gt;
&lt;h2&gt;1.7 OGC中GeoPackage官网的常见问题&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;gpkg会代替shp吗？&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;看你怎么想。可以替代，但是没必要。像简单的交换数据和显示简单的数据，GeoJson就可以完成。（详细的看第二节）&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;gpkg安全吗？&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;gpkg只是SQLite的一种编码、规定，没有像其他DBMS一样的安全管理。不过，已经有人实践了SQLite的安全扩展模块，可以考虑一下或者换更安全的数据库管理系统，例如PostgreSQL。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;为什么gpkg用的WKB编码与PostGIS、SpatialLite的WKB不同？&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;因为原始的WKB标准不能满足gpkg，所以要扩展。PostGIS和SpatialLite都这么做了。&lt;/p&gt;

&lt;p&gt;QGIS 3.X默认从shp文件切换到gpkg，因此，渲染变得非常快。使用gpkg比使用shp文件在加载，平移和缩放时更快。&lt;/p&gt;
&lt;h2&gt;2.1 gpkg的优缺点&lt;/h2&gt;
&lt;p&gt;优点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;开源&lt;/li&gt;
&lt;li&gt;OGC标准之一&lt;/li&gt;
&lt;li&gt;软件支持广泛，有GDAL、QGIS、R、Python、Esri家族...&lt;/li&gt;
&lt;li&gt;比传统意义上的地理数据库轻量化，但是和地理数据库速度相差无几&lt;/li&gt;
&lt;li&gt;单文件，比shp文件好管理&lt;/li&gt;
&lt;li&gt;在工作流上比shp快速&lt;/li&gt;
&lt;li&gt;几乎没有限制（指的是体积）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;缺点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;还不成熟（现在版本才1.2.1，原文写的时候才是1.0）不过，这个只是时间问题&lt;/li&gt;
&lt;li&gt;个人体验中栅格数据的支持比较受限制&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;2.2 shp文件的优缺点&lt;/h2&gt;
&lt;p&gt;优点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;通用标准！（2020年就是shp文件的30岁）&lt;/li&gt;
&lt;li&gt;它就是个矢量数据的标志（GIS矢量数据几乎会问有没有shp文件？）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;缺点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Esri维护&lt;/li&gt;
&lt;li&gt;数据访问上有些迟钝&lt;/li&gt;
&lt;li&gt;是一个多文件格式（有很多GIS菜鸟不知道要发送多个同名文件，只发送了几何数据的shp文件）&lt;/li&gt;
&lt;li&gt;不能拓扑&lt;/li&gt;
&lt;li&gt;属性名限制为10字符&lt;/li&gt;
&lt;li&gt;它使用的是Esri定制的WKT，切换平台时可能会导致不一致&lt;/li&gt;
&lt;li&gt;每个shp文件只支持最大2GB&lt;/li&gt;
&lt;li&gt;每个shp文件只能是一种几何类型&lt;/li&gt;
&lt;li&gt;没有真正的3D支持（gpkg已经根据社区的贡献拓展出了3d支持）&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;2.3 建议&lt;/h2&gt;
&lt;p&gt;原作者希望更多人使用gpkg而不要再继续使用shp了（&lt;span&gt;笔者注：旧事物还有利用的余地时，新事物的推动就会非常困难；除非使用政治或者垄断手段强行更改（比如当年Esri的Coverage格式被Esri自己干掉了）——不太可能，这些都非常符合马克思主义；而且，是否使用gpkg或者shp或者其他数据库，都要具体问题具体分析&lt;/span&gt;）&lt;/p&gt;
&lt;p&gt;如果你有庞大的数据需要存储、管理，原作者建议使用PostGIS。如果您喜欢GeoPackage，请与您的同事和合作者分享这些信息！&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1097074/201907/1097074-20190722010850724-1748062838.png&quot; alt=&quot;&quot; width=&quot;192&quot; height=&quot;228&quot;/&gt;&lt;/p&gt;
&lt;p&gt;似乎有一小撮人，正在鼓吹shp必死论（可能是受够了shp的缺点了吧！），我就简单翻译一下。&lt;/p&gt;
&lt;p&gt;shp文件具体是什么我就不过多介绍了，它诞生于1990年，马上就是它的30大寿了。&lt;/p&gt;
&lt;p&gt;尽管shp文件是Esri维护的，但是它的规范是开放的，也就是说，如果你懂了shp文件的几大数据结构构成，会编程，你也可以手搓一个shp文件读写程序，不需要依赖任何第三方库。&lt;/p&gt;
&lt;h2&gt;3.1 shp文件的缺陷&lt;/h2&gt;
&lt;p&gt;但是，&lt;span&gt;下面原文开始重点驳斥shp文件的坏处&lt;/span&gt;：&lt;/p&gt;
&lt;p&gt;为什么Shapefile这么糟糕？以下是Shapefile格式错误的几个原因，您应该避免使用它：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;要额外使用prj文件定义坐标系统（shp文件规范不包括prj文件来定义坐标系统，这是额外的）&lt;/li&gt;
&lt;li&gt;多文件格式（至少要3个文件，其他软件还会自己扩充更多同名扩展文件，这就使得数据共享非常麻烦，这也是一个非常致命的弱点）&lt;/li&gt;
&lt;li&gt;属性名最多为10字符&lt;/li&gt;
&lt;li&gt;dbf属性表最多255个字段&lt;/li&gt;
&lt;li&gt;数据类型有限，只支持浮点数、整数、日期、文本，一个值最多254字符&lt;/li&gt;
&lt;li&gt;文字编码有大问题，在ArcGIS中打开shp文件中文乱码的问题大家肯定遇到过&lt;/li&gt;
&lt;li&gt;shp文件和dbf文件最大2GB（虽然GDAL改进了但是毫无卵用）&lt;/li&gt;
&lt;li&gt;不能拓扑&lt;/li&gt;
&lt;li&gt;每个shp只能是一种几何类型&lt;/li&gt;
&lt;li&gt;更复杂的数据结构无法实现，例如不规则三角网等&lt;/li&gt;
&lt;li&gt;不能用纹理或材质存储3d数据&lt;/li&gt;
&lt;li&gt;...&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;不展开了，有兴趣的朋友到他们官网看即可&lt;/p&gt;
&lt;h2&gt;3.1 备选方案&lt;/h2&gt;
&lt;p&gt;讲道理，现在没有任何一种矢量格式能完全替代shp，但是不得不说其他的格式正在慢慢崛起，有他们的用户。&lt;/p&gt;
&lt;p&gt;例如，kml、gml、geojson等&lt;/p&gt;
&lt;p&gt;一些Shapefile替代品：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;OGC GeoPackage&lt;/li&gt;
&lt;li&gt;GeoJSON&lt;/li&gt;
&lt;li&gt;OGC GML&lt;/li&gt;
&lt;li&gt;SpatiaLite&lt;/li&gt;
&lt;li&gt;CSV&lt;/li&gt;
&lt;li&gt;OGC KML&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其中，第一位列的就是gpkg，而且经过近几年的迭代升级、修订，再加上它可以扩展的特性，使得gpkg更强大。&lt;/p&gt;
&lt;p&gt;GeoPackage的一个缺点是，它底层SQLite数据库是一种复杂的二进制格式，不适合流式传输。它必须写入本地文件系统或通过中间服务访问。所以，在本地应用中，gpkg是shp文件的一个不错替代品（如果你有需要）&lt;/p&gt;
&lt;p&gt;GeoJson并不是shp文件的代替品，只是地理数据的一种json实现。它的一个特点就是支持流传输；存在的问题是，不是所有的几何都可以表示，高级的坐标系统支持也不算好。&lt;/p&gt;
&lt;p&gt;所以，基于XML的GML格式（仅支持矢量数据）就有了用武之地。但是GML也有其缺点，就是数据结构定义标准复杂，较少软件愿意支持它，ArcGIS把它的支持丢进了数据互操作模块。如果GeoJson不能解决问题，可以试试GML。&lt;/p&gt;
&lt;p&gt;SpatialLite和gpkg类似，也是一个开源数据库，也是基于SQLite，也是单文件，也支持SQL，但是不如gpkg广泛。究其原因，是因为sl缺乏扩展能力（好比世界之窗vsChrome），也不支持栅格数据。同样的，它也不支持流传输。&lt;/p&gt;
&lt;p&gt;csv文件，估计有的同学用过，最大的特点就是简单了。它就是个文本格式的二维数据表格。在非GIS行业中，csv非常受欢迎。作为属性表可能合适，但是它并不具备几何等复杂空间信息的存储能力，而且它没有一个标准。&lt;/p&gt;
&lt;p&gt;kml是谷歌在谷歌地球中推荐的格式，基于XML，单文件。它有个特点就是，数据和样式同存在于一个kml文件中。缺点也有，仅支持wgs84坐标。由于它基于XML，所以数据量一大就不好用了。数据和样式存在耦合，这也是个缺点。&lt;/p&gt;
&lt;p&gt;当然，除了以上开源格式外，还可以使用更复杂的DBMS或者ArcGIS家使用的面向对象的地理数据库。&lt;/p&gt;
&lt;p&gt;笔者的建议是，还是具体问题具体分析。如果你要做真正的GIS项目，通用、标准化、性能高才是不二之选；所以，像kml等非主流但是又有其价值的数据，除了在它本身的平台用外，最好转换到更通用的格式上，例如，就GeoPackage——不然还是老实点用shp文件吧~&lt;/p&gt;
&lt;p&gt;项目大的，有高并发、安全要求的，不妨试试PostgreSQL的PostGIS拓展。或者用MySQL、其他商业数据库，那些就不在本文的讨论范围了。&lt;/p&gt;


&lt;p&gt;[1]. OGC的GeoPackage官网：&lt;a href=&quot;https://www.geopackage.org/&quot;&gt;https://www.geopackage.org/&lt;/a&gt;&lt;a href=&quot;http://www.geopackage.org/guidance/getting-started.html&quot;&gt;&lt;br/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[2]. OGC的GeoPackage起步文档：&lt;a href=&quot;http://www.geopackage.org/guidance/getting-started.html&quot;&gt;http://www.geopackage.org/guidance/getting-started.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[3]. OGC的GeoPackage标准（类似于白皮书）&lt;a href=&quot;http://www.geopackage.org/spec120&quot;&gt;http://www.geopackage.org/spec120&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[4]. 实现了GeoPackage的有关软件：&lt;a href=&quot;https://www.geopackage.org/implementations.html&quot;&gt;https://www.geopackage.org/implementations.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[5]. GeoPackage vs Shapefiles：&lt;a href=&quot;https://www.gis-blog.com/geopackage-vs-shapefile/&quot;&gt;https://www.gis-blog.com/geopackage-vs-shapefile/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[6]. Shp文件必须死！（这个网站有点偏激）：&lt;a href=&quot;http://switchfromshapefile.org/&quot;&gt;http://switchfromshapefile.org/&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 21 Jul 2019 17:45:00 +0000</pubDate>
<dc:creator>秋意正寒</dc:creator>
<og:description>GeoPackage（以下简称gpkg），内部使用SQLite实现的一种单文件、与操作系统无关的地理数据库。 当前标准是1.2.1，该版本的html版说明书：https://www.geopackag</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/onsummer/p/11223618.html</dc:identifier>
</item>
<item>
<title>微服务高可用方案 - 遗失的拂晓</title>
<link>http://www.cnblogs.com/lossingdawn/p/11223577.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lossingdawn/p/11223577.html</guid>
<description>&lt;p&gt;微服务高可用方案&lt;/p&gt;
&lt;h4 id=&quot;一微服务的高可用&quot;&gt;一、微服务的高可用&lt;/h4&gt;
&lt;p&gt;在注册中心、配置中心高可用方案之前，了解一下注册中心的工作原理，下面分为两个部分来解释，一是注册中心和各个微服务的注册表的获取与同步，二是注册中心如何去维护注册表。&lt;/p&gt;
&lt;h4 id=&quot;注册表的获取与同步&quot;&gt;1.1、注册表的获取与同步&lt;/h4&gt;
&lt;p&gt;Eureka Server和Eureka Client之间的关系，通过注册表来维护，而注册表的通过Eureka Server集中化管理，每个Client在本地进行注册表的缓存，通过周期性的任务拉取最新的注册表信息。简单的示例图如下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blog-lossingdawn.oss-cn-shanghai.aliyuncs.com/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%AB%98%E5%8F%AF%E7%94%A8%E6%96%B9%E6%A1%88/1.jpeg&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;根据上图所展示的流程，可以了解到注册中心与微服务之间的基本联系的流程：&lt;/p&gt;
&lt;p&gt;1．服务A启动时，向Eureka Server注册自己的相关信息&lt;/p&gt;
&lt;p&gt;2．当服务B向Eureka Server拉取最新的注册表时，就可以拿到服务A的一台机器注册信息&lt;/p&gt;
&lt;p&gt;3．服务A的另外两台机器再去注册，服务B 30s后再次去拉取时，就会得到服务A的三台机器的注册信息&lt;/p&gt;
&lt;p&gt;4．服务A、每30s向Eureka Server发送一次心跳信息，表明自己的注册信息还是有效的&lt;/p&gt;
&lt;p&gt;以上是注册中心与微服务之间交互的大体流程，在具体的实践中，Eureka Server会提供多级缓存，其中的注册表的信息的获取与同步，又会有细微的差别。&lt;/p&gt;
&lt;p&gt;1．Eureka Server的注册表直接基于纯内存，即在内存里维护了一个数据结构。&lt;/p&gt;
&lt;p&gt;2．各个服务的注册、服务下线、服务故障，全部会在内存里维护和更新这个注册表。&lt;/p&gt;
&lt;p&gt;3．各个服务每隔30秒拉取注册表的时候，Eureka Server就是直接提供内存里存储的有变化的注册表数据给他们就可以了。&lt;/p&gt;
&lt;p&gt;4．同样，每隔30秒发起心跳时，也是在这个纯内存的Map数据结构里更新心跳时间。&lt;/p&gt;
&lt;p&gt;Eureka Server的注册表是纯内存处理的，因此处理速度会很快，同时提供 readWriteCacheMap 和 readOnlyCacheMap 做缓存，保障了频繁读写不会冲突。示意图如下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blog-lossingdawn.oss-cn-shanghai.aliyuncs.com/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%AB%98%E5%8F%AF%E7%94%A8%E6%96%B9%E6%A1%88/2.jpeg&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图介绍了Eureka Server多级缓存的工作原理：&lt;/p&gt;
&lt;p&gt;1．当第一台服务A注册时，它的注册信息会更新到内存的注册表中，如果 readWriteCacheMap 中有相应的信息，则过期掉，如果没有则不做操作&lt;/p&gt;
&lt;p&gt;2．当服务B去拉取注册表信息时，先找 readOnlyCacheMap ，没有再找 readWriteCacheMap ，再没有就去内存的注册表查找注册信息，查到就更新到 readWriteCacheMap 中，返回给服务B，服务B的注册表中，就会有一台服务A的机器注册信息&lt;/p&gt;
&lt;p&gt;3．readOnlyCacheMap 和 readWriteCacheMap 之间的同步是有一个后台的定时任务，每隔30s去同步一次，缓存同步任务&lt;/p&gt;
&lt;p&gt;4．第二台服务A注册时，更新内存的注册表，同时把 readWriteCacheMap 过期掉&lt;/p&gt;
&lt;p&gt;5．在缓存同步任务执行之前服务B去拉取注册表时，都是从 readOnlyCacheMap 中拿到数据，新的注册表的信息，不会被服务B拿到&lt;/p&gt;
&lt;p&gt;6．30s后，缓存同步任务会同步 readWriteCacheMap 和 readOnlyCacheMap 中的数据，把readOnlyCacheMap 中的注册表过期掉，这时服务B就会找 readWriteCacheMap 拿数据，readWriteCacheMap 从内存中拿到数据后缓存，返回给服务B，服务B的注册表中，就会有两台服务A的机器注册信息&lt;/p&gt;
&lt;p&gt;7．在下一个30s，缓存同步任务把 readWriteCacheMap 同步到 readOnlyCacheMap 之前， readOnlyCacheMap 没有第二台服务A的注册缓存，因此都是从 readWriteCacheMap 中取到最新数据&lt;/p&gt;
&lt;p&gt;注：&lt;/p&gt;
&lt;p&gt;readOnlyCacheMap 缓存更新的定时器时间间隔，默认为30秒&lt;/p&gt;
&lt;p&gt;readWriteCacheMap 缓存过期时间，默认为 180 秒&lt;/p&gt;
&lt;p&gt;由以上流程说明可知，Eureka Server采取了多级缓存策略，同时最新的注册表生效有30s的时延。多级缓存机制的优点是什么：&lt;/p&gt;
&lt;p&gt;1．尽可能保证了内存注册表数据不会出现频繁的读写冲突问题。&lt;/p&gt;
&lt;p&gt;2．并且进一步保证对Eureka Server的大量请求，都是快速从纯内存走，性能极高。&lt;/p&gt;
&lt;h4 id=&quot;注册中心维护微服务的注册表&quot;&gt;1.2、注册中心维护微服务的注册表&lt;/h4&gt;
&lt;p&gt;Eureka Client与注册表相关的行为如下所示：&lt;/p&gt;
&lt;p&gt;1．服务注册(Registry)——初始化时执行一次，向服务端注册自己服务实例节点信息包括ip、端口、实例名等，基于POST请求。&lt;/p&gt;
&lt;p&gt;2．服务续约(renew)——默认每隔30s向服务端PUT一次，保证当前服务节点状态信息实时更新，不被服务端失效剔除。&lt;/p&gt;
&lt;p&gt;3．更新已经注册服务列表(fetchRegistry)——默认每隔30s从服务端GET一次增量版本信息，然后和本地比较并合并，保证本地能获取到其他节点最新注册信息。&lt;/p&gt;
&lt;p&gt;4．服务下线(cancel)——在服务shutdown的时候，需要及时通知服务端把自己剔除，以避免客户端调用已经下线的服务。&lt;/p&gt;
&lt;p&gt;Eureka Client是通过Jersey Client基于Http协议与Eureka Server交互来注册服务、续约服务、取消服务、服务查询等。同时，Server端还会维护一份服务实例清单，并每隔90s对未续约的实例进行失效剔除。&lt;/p&gt;
&lt;p&gt;Eureka Server有一个自我保护机制，当网络发生故障时，客户端与服务端不通，这是需要启动Eureka Server的自我保护机制，这样不会剔除服务，当网络恢复时，退出自我保护。自我保护有两个参数，最后一分钟收到的心跳数（Renews (last min)）、期望收到的心跳数（Renews threshold），当Renews threshold &amp;gt; Renews (last min) 时，进入自我保护模式。&lt;/p&gt;
&lt;p&gt;Renews (last min) = 实例数 * 2 #实例数算上Eureka Server自注册服务&lt;/p&gt;
&lt;p&gt;Renews threshold = Renews (last min) * 0.85 # 0.85可配置&lt;/p&gt;
&lt;p&gt;下图的注册中有10个实例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blog-lossingdawn.oss-cn-shanghai.aliyuncs.com/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%AB%98%E5%8F%AF%E7%94%A8%E6%96%B9%E6%A1%88/3.jpeg&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;推荐多个Eureka Server部署时，开启自我保护&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;eureka.client.register-with-eureka = true&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;分布式注册中心&quot;&gt;1.3、分布式注册中心&lt;/h4&gt;
&lt;p&gt;了解了注册中心的工作原理，下面开始研究分布式服务，多注册中心、多服务实例的情况。&lt;/p&gt;
&lt;p&gt;当微服务仅向一台注册中心注册时，当这个注册中心发生故障时，新服务无法继续注册上去，旧服务的注册信息，缓存在其他注册中心和客户端中，依旧可以使用，当重启之后，无法向注册中心注册，也是无法使用的。&lt;/p&gt;
&lt;p&gt;因此构建高可用的注册中心时，需要交叉注册，每个注册中心既当服务端，又当客户端，向其他注册中心注册自己，同时微服务需要向每个注册中心进行注册，由注册中心自己过滤互备，防止单个注册中心故障而导致只往它上面注册微服务重启后不可用。示意图如下所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blog-lossingdawn.oss-cn-shanghai.aliyuncs.com/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%AB%98%E5%8F%AF%E7%94%A8%E6%96%B9%E6%A1%88/4.jpeg&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;目前注册中心与配置中心集中在一起，可拆可不拆，对整体影响不大，拆分是为了注册中心和配置中心相互间不影响。gitlab部署在某一台机器上，所有config共用，由于gitlab的原因，导致config的分布式存在单点故障的隐患。每个config分别用独立的gitlab，又给运维带来极大的不便。后期采用apollo，用数据库存储配置，利用数据库的分布式优势替代gitlab，来解决单点故障的问题。&lt;/p&gt;
&lt;h4 id=&quot;注册中心压测&quot;&gt;1.4、注册中心压测&lt;/h4&gt;
&lt;p&gt;根据压测调研，8核4G的Eureka Server在处理1000个服务实例时，没有任何压力，在默认情况下，可以处理7000个实例，超出的会超时报错，在修改tomcat的配置之后，最多可以承载8000实例，此时CPU基本满载。&lt;/p&gt;
&lt;p&gt;升级注意事项：&lt;/p&gt;
&lt;p&gt;1、Eureka Server之间相互注册，Eureka Client需要在每个Server上都注册一边&lt;/p&gt;
&lt;p&gt;2、Eureka Server开启自我保护&lt;/p&gt;
&lt;p&gt;3、Eureka Client的实例数不超过1000个&lt;/p&gt;
&lt;h4 id=&quot;参考&quot;&gt;参考：&lt;/h4&gt;
&lt;p&gt;[1] &lt;a href=&quot;https://www.jianshu.com/p/ae4f0c8b8135&quot; class=&quot;uri&quot;&gt;https://www.jianshu.com/p/ae4f0c8b8135&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[2] &lt;a href=&quot;https://www.cnblogs.com/xishuai/p/spring-cloud-eureka-safe.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/xishuai/p/spring-cloud-eureka-safe.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[3] &lt;a href=&quot;http://springcloud.cn/view/31&quot; class=&quot;uri&quot;&gt;http://springcloud.cn/view/31&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 21 Jul 2019 16:54:00 +0000</pubDate>
<dc:creator>遗失的拂晓</dc:creator>
<og:description>微服务高可用方案 一、微服务的高可用 在注册中心、配置中心高可用方案之前，了解一下注册中心的工作原理，下面分为两个部分来解释，一是注册中心和各个微服务的注册表的获取与同步，二是注册中心如何去维护注册表</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lossingdawn/p/11223577.html</dc:identifier>
</item>
<item>
<title>渐进式web应用开发---promise式数据库(五) - 龙恩0707</title>
<link>http://www.cnblogs.com/tugenhua0707/p/11223556.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tugenhua0707/p/11223556.html</guid>
<description>&lt;p&gt;在前面的一篇文章中，我们已经实现了使用indexedDB实现ajax本地数据存储的功能，详情，请看&lt;a href=&quot;https://www.cnblogs.com/tugenhua0707/p/11222017.html&quot; target=&quot;_blank&quot;&gt;这篇文章&lt;/a&gt;。现在我们需要把上面的一篇文章中的代码使用promise结构来重构下。我们为什么需要使用promise来重构呢？我们之前一直使用 indexedDB中的代码，但是在indexedDB中，我们代码很大程度上依赖于回调，如果我们的代码越来越多，我们需要的回调嵌套就越来越多，这对于后期代码维护不是很好。&lt;/p&gt;
&lt;p&gt;比如我们可以看看我们之前的代码如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 打开或创建 store-data 数据库&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; result = window.indexedDB.open('store-data', 3&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 监听error函数触发&lt;/span&gt;
result.onerror = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(event) {
  console.log(&lt;/span&gt;&quot;DataBase error:&quot;&lt;span&gt;, event.target.error);
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 监听当前版本号被升级的时候触发该函数&lt;/span&gt;
result.onupgradeneeded = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(event) {
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; db =&lt;span&gt; event.target.result;
  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
   是否包含该对象仓库名(或叫表名)。如果不包含就创建一个。
   该对象中的 keyPath属性id为主键
  &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
  &lt;span&gt;if&lt;/span&gt; (!db.objectStoreNames.contains('store'&lt;span&gt;)) {
    db.createObjectStore(&lt;/span&gt;&quot;store&quot;, { keyPath: &quot;id&quot;, autoIncrement: &lt;span&gt;true&lt;/span&gt;&lt;span&gt; });
  }
}

result.onsuccess &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(event) {
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; targetValue =&lt;span&gt; event.target.result;
  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 
   1. 使用 targetValue.transaction(storeName, transactionMode) 来创建事务
   2. 创建事务之后，我们使用 targetValue.transaction(storeName, transactionMode).objectStore(storeName)
   这个方法，拿到 IDBObjectStore对象。
  &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
  &lt;span&gt;var&lt;/span&gt; objectStore =&lt;span&gt; targetValue.transaction(storeName, transactionMode).objectStore(storeName);
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; request = objectStore.add({id: 3, name: 'kongzhi12', age: 31&lt;span&gt;});
  request.onsuccess &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(event) {
    console.log(&lt;/span&gt;'回调函数成功'&lt;span&gt;);
  }
  request.onerror &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(event) {
    console.log(&lt;/span&gt;&quot;DataBase error:&quot;&lt;span&gt;, event.target.error);
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上代码，我们打开了或创建了一个 store-data 数据库，然后把onsuccess回调附加到该请求上，在该onsuccess请求上，我们又有请求事件，接着有 onsuccess 回调函数，依次类推，如果以后代码越来越复杂的时候，我们以后代码就一直变成回调嵌套中，因此我们现在想使用promise方法来重构上面的代码，我们想要让上面的代码变成如下所示这样的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
openDatabase('store-data', 3).then(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(db) {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; openObjectStore(db, &quot;store&quot;, &quot;readwrite&quot;&lt;span&gt;);
}).then(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(objectStore){
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; addObject(objectStore, {&quot;id&quot;: 3, &quot;name&quot;: 'kongzhi123', 'age': 31&lt;span&gt;});
}).then(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
  console.log(&lt;/span&gt;'回调成功'&lt;span&gt;);
}).&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(error) {
  console.log(&lt;/span&gt;'DataBase error'&lt;span&gt;, error);
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们希望变成如上的promise代码，我们希望将javascript异步回调的代码变成我们的promise代码。在重构我们的代码之前，我们先来看看我们的 XMLHttpRequest 代码，我们希望使用promise来重构该代码，在重构之前，我们先来看看XMLHttpRequest代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; xhr = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; XMLHttpRequest();
xhr.onload &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 处理响应&lt;/span&gt;
&lt;span&gt;};
xhr.onerror &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 处理错误&lt;/span&gt;
&lt;span&gt;};
xhr.open(&lt;/span&gt;&quot;get&quot;, '/xxx.json', &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
xhr.send();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上这样的代码，是我们之前的xmlHttpRequest代码，现在我们可以使用我们的promise来重构我们上面的代码，因此重构后的代码变成如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; promise_XHR = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(url, method) {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Promise(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(resolve, reject) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; xhr = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; XMLHttpRequest();
    xhr.onload &lt;/span&gt;=&lt;span&gt; resolve;
    xhr.onerror &lt;/span&gt;=&lt;span&gt; reject;
    xhr.open(method, url, &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
    xhr.send();
  });
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上 promise_XHR 函数，该函数接收一个url 和 method参数，并返回了一个promise对象，该promise传入了一个函数，该函数有两个参数，代表成功和失败的回调，然后内部代码，我们创建了一个XMLHttpRequest对象，然后该对象 onload 函数的时候 把resolve 成功回调赋值给他，然后 xhr.onerror 函数的时候，把 reject 拒绝函数传递给他，我们调用方式如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
promise_XHR('/xxx.json', 'get').then(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 处理成功的回调函数&lt;/span&gt;
}).&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(error) {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 处理我们异常的回调函数&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在我们想把该方式使用到我们的 store.js 代码内部来。重构后的代码就变成了如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
import axios from 'axios'&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; DB_VERSION = 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; DB_NAME = 'store-data2'&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; openDataBase = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Promise(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(resolve, reject) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;window.indexedDB) {
      reject(&lt;/span&gt;&quot;indexedDB not supported&quot;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 打开或创建 store-data 数据库&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; result =&lt;span&gt; window.indexedDB.open(DB_NAME, DB_VERSION);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 监听error函数触发&lt;/span&gt;
    result.onerror = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(event) {
      console.log(&lt;/span&gt;&quot;DataBase error:&quot;&lt;span&gt;, event.target.error);
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 监听当前版本号被升级的时候触发该函数&lt;/span&gt;
    result.onupgradeneeded = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(event) {
      &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; db =&lt;span&gt; event.target.result;
      &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
       是否包含该对象仓库名(或叫表名)。如果不包含就创建一个。
       该对象中的 keyPath属性id为主键
      &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
      &lt;span&gt;if&lt;/span&gt; (!db.objectStoreNames.contains('store'&lt;span&gt;)) {
        db.createObjectStore(&lt;/span&gt;&quot;store&quot;, { keyPath: &quot;id&quot;, autoIncrement: &lt;span&gt;true&lt;/span&gt;&lt;span&gt; });
      }
    }
    result.onsuccess &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(event) {
      resolve(event.target.result);
    }
  });
};
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
 @param {storeName} 仓库名或表名
 @param {transactionMode} 事务模式 readOnly 只读，readwrite 可读可写
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; openObjectStore = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(db, storeName, transactionMode) {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; db.transaction(storeName, transactionMode).objectStore(storeName);
};

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; getStore = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (successCallback) {

  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Promise(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(resolve, reject) {
    openDataBase().then(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(db) {
      &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; objectStore = openObjectStore(db, 'store'&lt;span&gt;);
      &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; datas =&lt;span&gt; [];
      objectStore.openCursor().onsuccess &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(event) {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; cursor =&lt;span&gt; event.target.result;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (cursor) {
          datas.push(cursor.value);
          cursor.&lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;();
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
          &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (datas.length &amp;gt; 0&lt;span&gt;) {
            resolve(datas);
          } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            getDataFromServer().then(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(d) {
              openDataBase().then(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(db) {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; objectStore = openObjectStore(db, &quot;store&quot;, &quot;readwrite&quot;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (let i = 0; i &amp;lt; datas.length; i++&lt;span&gt;) {
                  objectStore.add(datas[i]);
                }
                resolve(datas);
              });
            });
          }
        }
      }
    }).&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
      getDataFromServer().then(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(datas) {
        resolve(datas);
      });
    });
  });
};

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; getDataFromServer() {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Promise(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(resolve, reject) {
    axios.get(&lt;/span&gt;&quot;http://localhost:8081/public/json/index.json&quot;&lt;span&gt;, resolve);
  });
}

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; addToObjectStore = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(storeName, object) {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Promise(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(resolve, reject) {
    openDataBase().then(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(db) {
      openObjectStore(db, storeName, &lt;/span&gt;'readwrite').add(object).onsuccess =&lt;span&gt; resolve;
    }).&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(error) {
      reject(error);
    })
  });
};

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; updateInObjectStore = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(storeName, id, object) {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Promise(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(resolve, reject) {
    openDataBase().then(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(db) {
      openObjectStore(db, storeName, &lt;/span&gt;&quot;readwrite&quot;).openCursor().onsuccess = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(event) {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; cursor =&lt;span&gt; event.target.result;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;cursor) {
          reject(&lt;/span&gt;&quot;store-data not found&quot;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (cursor.value.id ===&lt;span&gt; id) {
          cursor.put(object).onsuccess &lt;/span&gt;=&lt;span&gt; resolve;
          &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }
        cursor.&lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;();
      }
    }).&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
      reject(error);
    })
  });
}

window.openDataBase &lt;/span&gt;=&lt;span&gt; openDataBase;
window.openObjectStore &lt;/span&gt;=&lt;span&gt; openObjectStore;

window.addToObjectStore &lt;/span&gt;=&lt;span&gt; addToObjectStore;
window.updateInObjectStore &lt;/span&gt;=&lt;span&gt; updateInObjectStore;

window.getStore &lt;/span&gt;= getStore;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后我们需要在我们的 myAccount.js 代码改成如下初始化所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
import $ from 'jquery'&lt;span&gt;;

$(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
  openDataBase(&lt;/span&gt;&quot;store-data2&quot;, 2).then(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(db) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; openObjectStore(db, &quot;store&quot;, &quot;readwrite&quot;&lt;span&gt;);
  }).then(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(objectStore) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; addToObjectStore(&quot;store&quot;, {id: 1, name: 'kongzhi111', age: 11&lt;span&gt;});
  }).then(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    console.log(&lt;/span&gt;'添加成功'&lt;span&gt;);
  }).&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(error) {
    console.log(&lt;/span&gt;&quot;数据库加载失败&quot;&lt;span&gt;, error);
  });
  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
  var addStore = function(id, name, age) {
    var obj = {
      id: id,
      name: name,
      age: age
    };
    addToObjectStore(&quot;store&quot;, obj);
    renderHTMLFunc(obj);
    $.getJSON(&quot;http://localhost:8081/public/json/index.json&quot;, obj, function(data) {
      updateDisplay(data);
    });
  };
  $(&quot;#submit&quot;).click(function(e) {
    addStore(3, 'longen1', '111');
  });
  $(&quot;#update&quot;).click(function(e) {
    $.getJSON(&quot;http://localhost:8081/public/json/index.json&quot;, {id: 1}, function(data) {
      updateInObjectStore(&quot;store&quot;, 1, data);
      updateDisplay(data);
    });
  });
  &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后会向我们的数据库中插入一条数据，我们刷新页面后查看我们的本地数据库如下所示：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201907/561794-20190722003733243-328048863.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/tugenhua0707/service-worker-demo/tree/master/service-worker-demo5&quot; target=&quot;_blank&quot;&gt;github源码demo查看&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 21 Jul 2019 16:40:00 +0000</pubDate>
<dc:creator>龙恩0707</dc:creator>
<og:description>渐进式web应用开发---promise式数据库(五)</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tugenhua0707/p/11223556.html</dc:identifier>
</item>
<item>
<title>Java中的Enumeration、Iterable和Iterator接口详解 - ^_^果冻^_^</title>
<link>http://www.cnblogs.com/vipygd/p/11223468.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/vipygd/p/11223468.html</guid>
<description>&lt;p&gt;在看各类Java书籍或者博文的时候，总是会遇到&lt;code&gt;Enumeration&lt;/code&gt;、&lt;code&gt;Iterable&lt;/code&gt;和&lt;code&gt;Iterator&lt;/code&gt;这三个接口，如果对这几个接口不是很明白的话，总会让自己看着看着就迷惑了，正好这周末，抽空把这三个接口总结一下，一扫之前的各种迷惑。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Enumeration&lt;/code&gt;(枚举)接口的作用和&lt;code&gt;Iterator&lt;/code&gt;类似，但只提供了遍历&lt;code&gt;Vector&lt;/code&gt;和&lt;code&gt;HashTable&lt;/code&gt;类型集合元素的功能，不支持元素的移除操作。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Enumeration&lt;/code&gt;接口声明的方法如下：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;boolean hasMoreElements()&lt;/td&gt;
&lt;td&gt;还有更多要提取的元素时返回true，在枚举所有元素后返回false&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;E nextElement()&lt;/td&gt;
&lt;td&gt;返回集合中的下一个元素&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;由于&lt;code&gt;Enumeration&lt;/code&gt;接口已由&lt;code&gt;Iterator&lt;/code&gt;取代，所有我这里就不做更详细的总结。这里提供一个简单的使用Demo：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;

public class EnumerationDemo {
    public static void main(String[] args) {
        Vector v = new Vector();
        v.addElement(&quot;Lisa&quot;);
        v.addElement(&quot;Billy&quot;);
        v.addElement(&quot;Mr Brown&quot;);

        Enumeration e = v.elements();

        while (e.hasMoreElements()) {
            String value = (String)e.nextElement();
            System.out.println(value);
        }

        Hashtable h = new Hashtable();
        h.put(&quot;name&quot;, &quot;Yanggd&quot;);
        h.put(&quot;age&quot;, &quot;25&quot;);
        h.put(&quot;location&quot;, &quot;内蒙古呼和浩特&quot;);

        e = h.keys();

        while (e.hasMoreElements()) {
            String key = (String) e.nextElement();
            String value = (String) h.get(key);
            System.out.println(&quot;KEY =&amp;gt;&quot; + key + &quot;; VALUE=&amp;gt;&quot; + value);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;迭代器是一种模式、可以使得序列类型的数据结构的遍历行为与被遍历的对象分离，即我们无需关心该序列的底层结构是什么样子的。只要拿到这个对象,使用迭代器就可以遍历这个对象的内部。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Iterable&lt;/code&gt;：实现这个接口的集合对象支持迭代，是可以迭代的；实现了这个可以配合&lt;code&gt;foreach&lt;/code&gt;使用；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Iterator&lt;/code&gt;：迭代器，提供迭代机制的对象，具体如何迭代是这个Iterator接口规范的。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;Iterable&lt;/code&gt;接口有以下三个方法：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Iterator iterator()&lt;/td&gt;
&lt;td&gt;返回一个Iterator对象&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;void forEach(Consumer&amp;lt;? super T&amp;gt; action)&lt;/td&gt;
&lt;td&gt;对集合中的每个元素执行action动作&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;Spliterator spliterator()&lt;/td&gt;
&lt;td&gt;返回一个Spliterator对象&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;code&gt;Iterator&lt;/code&gt;接口有以下三个方法：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;3.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;boolean hasNext()&lt;/td&gt;
&lt;td&gt;每次next之前，先调用此方法探测是否迭代到终点&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;E next()&lt;/td&gt;
&lt;td&gt;返回当前迭代元素，同时，迭代游标后移&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;void remove()&lt;/td&gt;
&lt;td&gt;删除最近一次已近迭代出出去的那个元素；只有当next执行完后，才能调用remove函数&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;Java容器中，所有的Collection子类会实现&lt;code&gt;Iteratable&lt;/code&gt;接口以实现&lt;code&gt;foreach&lt;/code&gt;功能，&lt;code&gt;Iteratable&lt;/code&gt;接口的实现又依赖于实现了&lt;code&gt;Iterator&lt;/code&gt;的内部类(参照LinkedList中listIterator()和descendingIterator()的JDK源码)。有的容器类会有多个实现&lt;code&gt;Iterator&lt;/code&gt;接口的内部类，通过返回不同的迭代器实现不同的迭代方式。&lt;/p&gt;
&lt;p&gt;下面通过一个简单的例子来说明&lt;code&gt;Iterable&lt;/code&gt;和&lt;code&gt;Iterator&lt;/code&gt;，看懂了下面的代码，也就看明白了&lt;code&gt;Iterable&lt;/code&gt;和&lt;code&gt;Iterator&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import java.util.*;

public class IterableDemo implements Iterable&amp;lt;String&amp;gt; {
    private String[] words = &quot;I love coding&quot;.split(&quot;&quot;);

    // 默认迭代器
    public Iterator&amp;lt;String&amp;gt; iterator() {
        // 匿名内部类
        return new Iterator&amp;lt;String&amp;gt;() {
            private int index = 0;

            @Override
            public boolean hasNext() {
                return index &amp;lt; words.length;
            }

            @Override
            public String next() {
                return words[index++];
            }

            @Override
            public void remove() {
                throw new UnsupportedOperationException();
            }
        };
    }

    // 反向迭代器
    public Iterable&amp;lt;String&amp;gt; reverseIterator() {
        return new Iterable&amp;lt;String&amp;gt;() {
            @Override
            public Iterator&amp;lt;String&amp;gt; iterator() {
                return new Iterator&amp;lt;String&amp;gt;() {
                    private int index = words.length - 1;

                    @Override
                    public boolean hasNext() {
                        return index &amp;gt; -1;
                    }

                    @Override
                    public String next() {
                        return words[index--];
                    }

                    @Override
                    public void remove() {
                        throw new UnsupportedOperationException();
                    }
                };
            }
        };
    }

    public static void main(String[] args) {
        IterableDemo iterableDemo = new IterableDemo();

        // 默认迭代器
        for (String value : iterableDemo) {
            System.out.print(value);
        }

        System.out.println();

        // 反向迭代器
        for (String value : iterableDemo.reverseIterator()) {
            System.out.print(value);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;又是一个小的知识点，再恶补一下。重温一下这些细节，让自己以后少掉点坑。&lt;/p&gt;
&lt;p&gt;2019年7月21日 于内蒙古呼和浩特。&lt;/p&gt;
</description>
<pubDate>Sun, 21 Jul 2019 15:51:00 +0000</pubDate>
<dc:creator>^_^果冻^_^</dc:creator>
<og:description>前言 在看各类Java书籍或者博文的时候，总是会遇到 、`Iterable Iterator`这三个接口，如果对这几个接口不是很明白的话，总会让自己看着看着就迷惑了，正好这周末，抽空把这三个接口总结一</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/vipygd/p/11223468.html</dc:identifier>
</item>
</channel>
</rss>