<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>连载《一个程序猿的生命周期》-《发展篇》- 27.从来没有996过，仍然需要人生的选择权 - 一个程序猿的生命周期</title>
<link>http://www.cnblogs.com/blog470130547/p/10720957.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/blog470130547/p/10720957.html</guid>
<description>&lt;p&gt;&lt;span&gt;       在项目现场，去其他团队人员的房间闲聊一个多小时，大致讲述了自己的工作经历和人生感悟的心灵鸡汤，确实不想让他们走弯路。我参加工作已经有12年的时间，小同志感慨到：&lt;strong&gt;想想要写10多年的代码...哎...&lt;/strong&gt;。我说：&lt;strong&gt;写代码只是进入社会的切入点，要以这个点向外扩充，可做的事情很多，产品经理、项目经理......；不要把程序员看作另类的职业，和其他职业没有什么区别，他们也在不断的学习，我们更应该保持一种好的心态......&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       自已从来没有996过，但是回忆过往，也算奋进和努力。传统行业和所谓“互联网”行业确实有很大区别，技术相对落后、思维相对保守、迭代相对缓慢，但是意味着可做的事情比较多。在工作方面，干过设备安装和维护、干过项目经理、一直开发软件、有自己的框架产品；业余时间做过社交网站、破解技术网站、干过绿色农业、有自己的产品网站......。一路走来，一直在探索和提高认知水平，历练了综合能力，&lt;strong&gt;人要补短板，往往是生于短处、死于长处&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       &lt;strong&gt;在互联网如火如荼的发展过程中，我确实想过一头钻进去，用时间换金钱，实现所谓的财务自由&lt;/strong&gt;。可能生活从来都没有给过我这样的机会，在第一家公司工作五六年的时候，我们有了小孩子，从此我们三个人相依为命，即要工作也要照顾家庭，所有事情都要协调和平衡，更何况现在又有了二宝。&lt;strong&gt;人生走到这个阶段，所谓的成熟可能是避免极端&lt;/strong&gt;。后来对进入“互联网”这件事越来越没有了兴趣，有时候在想这并不是我想要的生活，可能和出身于无拘无束的大山之中和第一家公司散养式的管理有关系。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       我没有996式的工作过，不代表我不思进取！在工作中一直认为很努力、很奋斗，组建团队、平台和产品开发、项目执行等等，关键是谁认可我的努力和奋斗？价值决定权在谁哪？在不同维度或高度看待这种努力和奋斗可能一文不值，可是我还一厢情愿的强调我付出的努力。&lt;strong&gt;不过我现在变聪明了，只是用工作的心态去工作，不会强调任何价值取向，任由任何人去评定好了，因为我不掌握价值决定权&lt;/strong&gt;。能避免现在各大厂的裁员嘛，我确实没有这样的把握；除了工作之外，我也一直认为很努力、很奋斗，干了一年多的绿色农业，结果没有再坚持下去。现在回到老本行，找了几个兼职人员开发产品，希望这次能够走的更长远（接受投资）。总之为了更美好的生活。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      有句话说：毁掉一个人的最好方式，是让他“忙”到没有其他时间。&lt;strong&gt;996工作没有时间去选择，没有996工作没有时间去努力，大部分人的焦虑貌似进入了死循环，这种焦虑的本质是缺少能够掌握内心的选择权，所谓的“忙”伪装成了没有时间的借口，&lt;/strong&gt;&lt;strong&gt;焦虑、努力（“忙”）、越焦虑......&lt;/strong&gt;。主动或被动跳槽解决了不本质问题，总是在重建价值决定权，总有跳不动的时候，我们往往缺少有效人生规划的路径选择，确实付出实践的坚持。&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;hr/&gt;&lt;div&gt;
&lt;div&gt;
&lt;div&gt;
&lt;div readability=&quot;6.241134751773&quot;&gt;
&lt;div readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一个程序猿的生命周期 微信平台&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;口   号：职业交流，职业规划；面对现实，用心去交流、感悟。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;公众号：iterlifetime&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;strong&gt;百木-ITer职业交流奋斗 群：141588103&lt;/strong&gt;   &lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;二维码：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/691334/201606/691334-20160618075950167-974887453.jpg&quot; alt=&quot;&quot; width=&quot;120&quot; height=&quot;120&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Tue, 16 Apr 2019 15:36:00 +0000</pubDate>
<dc:creator>一个程序猿的生命周期</dc:creator>
<og:description>在项目现场，去其他团队人员的房间闲聊一个多小时，大致讲述了自己的工作经历和人生感悟的心灵鸡汤，确实不想让他们走弯路。我参加工作已经有12年的时间，小同志感慨到：想想要写10多年的代码...哎...。我</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/blog470130547/p/10720957.html</dc:identifier>
</item>
<item>
<title>Where is the clone one and how to extract it? - Pieces0310</title>
<link>http://www.cnblogs.com/pieces0310/p/10720901.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pieces0310/p/10720901.html</guid>
<description>&lt;p&gt;&lt;span&gt;One cannot be in two places at once. Do you know what's &quot;Dual Apps&quot;? Manufactures like Xiaomi,Oppo,Huawei offer &quot;Dual Apps&quot; feature which allows users to run two different accounts of the same app on his/her phone. Let's take &quot;Facebook&quot; for example. The scenario is that a suspect's phone running Android 7 and we have to extract his/her &quot;Facebook&quot;, including the original one and the clone one.&lt;/span&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/706830/201904/706830-20190416224118360-1841809670.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Now there are two Facebook Apps on suspect's phone. What's the clone one looks like? You could take a look as below. On the left side is the  original one and the other side is the clone one.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/706830/201904/706830-20190416224456011-1215574555.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;Take a guess if you conduct &quot;Downgrade Extraction&quot; on suspect's phone to extract &quot;Facebook&quot;, could you got both of these two &quot;Facebook&quot; without fail? The answer is &quot;No&quot;. You only got the original one. So the question is: Where is the clone one and how to extract it? To achieve this, I borrow a rooted Xiaomi from a friend of mine and take a took. Very interesting there are two uid running the same app Facebook. u999? That's weird~&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/706830/201904/706830-20190416225604350-1280680686.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;I've looked everywhere to search for the clone one facebook. I want to  know exactly where it is. That's it. The path what I\m looking for is /data/user/999/ .&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/706830/201904/706830-20190416230432535-719814423.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;Of course the path may differ from brand to brand.  Now &quot;Downgrade Extraction&quot; could extract the original one, but not working on the clone one. &lt;span&gt;The challenge for Mobile forensic tools is to extract both &quot;Dual Apps&quot; on phones running Android 7 or above.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 16 Apr 2019 15:23:00 +0000</pubDate>
<dc:creator>Pieces0310</dc:creator>
<og:description>One cannot be in two places at once. Do you know what's &quot;Dual Apps&quot;? Manufactures like</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pieces0310/p/10720901.html</dc:identifier>
</item>
<item>
<title>利用MAT玩转JVM内存分析（一） - javaadu</title>
<link>http://www.cnblogs.com/javaadu/p/10720799.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/javaadu/p/10720799.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;本文首发于公众号：javaadu&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;尽管JVM提供了自动内存管理的机制，试图降低程序员的开发门槛，确实也实现了这一目标，在日常开发中，我们一般都不需要关心对象的内存释放。JVM大部分都是使用trace算法来判断一个对象是否该被回收，那么JVM只能回收那些从gc roots不可达的对象。&lt;/p&gt;
&lt;p&gt;如果我们在使用某些大的对象、集合对象或者一些三方包里的资源，忘记及时释放资源的话，还是会造成JVM的内存泄漏或内存浪费的问题。因此，如果想成为更高阶的Java开发工程师，我们需要了解常见的问题排查的办法和工具，这个系列的文章，准备介绍一个用来做JVM堆内存分析的工具——MAT（Memory Aanlysis Tool）。&lt;/p&gt;
&lt;p&gt;MAT的官网在：&lt;a href=&quot;https://www.eclipse.org/mat/%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%9C%8B%E4%B8%8B%E5%AE%83%E7%9A%84%E4%BB%8B%E7%BB%8D&quot; class=&quot;uri&quot;&gt;https://www.eclipse.org/mat/，可以看下它的介绍&lt;/a&gt;——MAT是一款高性能、具备丰富功能的Java堆内存分析工具，可以用来排查内存泄漏和内存浪费的问题。&lt;/p&gt;
&lt;h2 id=&quot;一安装和装设置&quot;&gt;一、安装和装设置&lt;/h2&gt;
&lt;h3 id=&quot;mac安装&quot;&gt;1.1 mac安装&lt;/h3&gt;
&lt;p&gt;MAT 支持两种安装方式，一种是&quot;单机版“的，也就是说用户不必安装 Eclipse IDE 环境，MAT 作为一个独立的 Eclipse RCP 应用运行；另一种是”集成版“的，也就是说 MAT 也可以作为 Eclipse IDE 的一部分，和现有的开发平台集成。&lt;/p&gt;
&lt;p&gt;这里我们考虑独立安装，在观望的下载页面，选择mac os版本的安装文件下载即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/44770-0fffa136e9c4db53.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;MAT的独立下载地址&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;安装遇到的坑&quot;&gt;安装遇到的坑&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;启动直接报错，针对这个问题，我找到了这个答案：&lt;a href=&quot;https://stackoverflow.com/questions/47909239/how-to-run-eclipse-memory-analyzer-on-mac-os&quot; class=&quot;uri&quot;&gt;https://stackoverflow.com/questions/47909239/how-to-run-eclipse-memory-analyzer-on-mac-os&lt;/a&gt;，这个帖子里给出了两个方案：
&lt;ul&gt;&lt;li&gt;系统默认的workspace是只读的，更换掉即可。怎么更换呢，在文件&lt;code&gt;/Applications/mat.app/Contents/Eclipse/MemoryAnalyzer.ini&lt;/code&gt;中进行修改。&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/44770-038dea9b2408b9d7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;在mat的安装目录下，我的机器是&lt;code&gt;/Applications/mat.app/Contents/MacOS&lt;/code&gt;，执行&lt;code&gt;./MemoryAnalyzer&lt;/code&gt;命令，这种只能通过命令启动，不能通过图表启动。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;关于方案1，这篇文章讲得更细致：&lt;a href=&quot;https://www.jianshu.com/p/9bbbe3c4cc8b&quot; class=&quot;uri&quot;&gt;https://www.jianshu.com/p/9bbbe3c4cc8b&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;启动后，UI界面没反应，参考：&lt;a href=&quot;https://www.eclipse.org/forums/index.php/t/1090889/%EF%BC%8C%E6%8D%A2%E4%B8%AA%E5%8C%85%E5%8D%B3%E5%8F%AF%E3%80%82%E8%BF%99%E4%B8%AA%E9%97%AE%E9%A2%98%E6%88%91%E9%81%87%E5%88%B0%E8%BF%87%E5%BE%88%E5%A4%9A%E6%AC%A1&quot; class=&quot;uri&quot;&gt;https://www.eclipse.org/forums/index.php/t/1090889/，换个包即可。这个问题我遇到过很多次&lt;/a&gt;。&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/44770-79873fd7a95a5e60.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;mat的设置&quot;&gt;1.2 mat的设置&lt;/h3&gt;
&lt;h4 id=&quot;配置mat的堆内存大小&quot;&gt;配置mat的堆内存大小&lt;/h4&gt;
&lt;p&gt;我的电脑是8C16G的，那理论上分析10G的堆文件没问题，但是MAT默认的配置没有这么大，需要在&lt;code&gt;/Applications/mat.app/Contents/Eclipse/MemoryAnalyzer.ini&lt;/code&gt;文件中进行修改。如下图所示，我将我的MAT自己的运行时堆内存配置成了6G。&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/44770-faf635c26afab7a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;配置mat的使用&quot;&gt;配置MAT的使用&lt;/h4&gt;
&lt;p&gt;MAT的配置页面可以从Window——&amp;gt;Preferences找到，如下图所示。 &lt;img src=&quot;https://upload-images.jianshu.io/upload_images/44770-637cdd6c843e6e61.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;MAT的一般配置有几个选项&lt;/p&gt;
&lt;ol readability=&quot;3&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Keep unreachable objects：如果勾选这个，则在分析的时候会包含dump文件中的不可达对象；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Hide the getting started wizard：隐藏分析完成后的首页，控制是否要展示一个对话框，用来展示内存泄漏分析、消耗最多内存的对象排序。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Hide popup query help：隐藏弹出查询帮助，除非用户通过F1或Help按钮查询帮助。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Hide Welcome screen on launch：隐藏启动时候的欢迎界面&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Bytes Display：设置分析结果中内存大小的展示单位&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;可以看出，MAT不仅支持HPROF文件的分析，还支持DTFJ文件的分析。一般sun公司系列的JVM生成的dump文件都是HPROF格式的，IBM的JVM生成的dump文件时DTFJ格式的。&lt;/p&gt;
&lt;h2 id=&quot;二基本概念&quot;&gt;二、基本概念&lt;/h2&gt;
&lt;h3 id=&quot;heap-dump&quot;&gt;Heap Dump&lt;/h3&gt;
&lt;p&gt;Heap Dump是Java进程在某个时刻的内存快照，不同JVM的实现的Heap Dump的文件格式可能不同，进而存储的数据也可能不同，但是一般来说。&lt;/p&gt;
&lt;p&gt;Heap Dump中主要包含当生成快照时堆中的java对象和类的信息，主要分为如下几类：&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;对象信息：类名、属性、基础类型和引用类型&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;类信息：类加载器、类名称、超类、静态属性&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;gc roots：JVM中的一个定义，进行垃圾收集时，要遍历可达对象的起点节点的集合&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;线程栈和局部变量：快照生成时候的线程调用栈，和每个栈上的局部变量&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Heap Dump中没有包含对象的分配信息，因此它不能用来分析这种问题：一个对象什么时候被创建、一个对象时被谁创建的。&lt;/p&gt;
&lt;h3 id=&quot;shallow-vs.-retained-heap&quot;&gt;Shallow vs. Retained Heap&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Shallow heap&lt;/strong&gt;是一个对象本身占用的堆内存大小。一个对象中，每个引用占用8或64位，Integer占用4字节，Long占用8字节等等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Retained set&lt;/strong&gt;，对于某个对象X来说，它的Retained set指的是——如果X被垃圾收集器回收了，那么这个集合中的对象都会被回收，同理，如果X没有被垃圾收集器回收，那么这个集合中的对象都不会被回收。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Retained heap&lt;/strong&gt;，对象X的Retained heap指的时候它的Retained set中的所有对象的Shallow si的和，换句话说，Retained heap指的是对象X的保留内存大小，即由于它的存活导致多大的内存也没有被回收。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;leading set&lt;/strong&gt;，对象X可能不止有一个，这些对象统一构成了leading set。如果leading set中的对象都不可达，那么这个leading set对应的retained set中的对象就会被回收。一般有以下几种情况：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;某个类的所有实例对象，这个类对象就是leading object&lt;/li&gt;
&lt;li&gt;某个类记载器加载的所有类，以及这些类的实例对象，这个类加载器对象就是leading object&lt;/li&gt;
&lt;li&gt;一组对象，要达到其他对象的必经路径上的对象，就是leading object&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;在下面这张图中，A和B是gc roots中的节点（方法参数、局部变量，或者调用了wait()、notify()或synchronized()的对象）等等。可以看出，E的存在，会导致G无法被回收，因此E的Retained set是E和G；C的存在，会导致E、D、F、G、H都无法被回收，因此C的Retined set是C、E、D、F、G、H；A和B的存在，会导致C、E、D、F、G、H都无法被回收，因此A和B的Retained set是A、B、C、E、D、F、G、H。&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/44770-1c25329c291f4498.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;dominator-tree&quot;&gt;Dominator Tree&lt;/h3&gt;
&lt;p&gt;MAT根据堆上的对象引用关系构建了支配树（Dominator Tree），通过支配树可以很方便得识别出哪些对象占用了大量的内存，并可以看到它们之间的依赖关系。&lt;/p&gt;
&lt;p&gt;如果在对象图中，从gc root或者x上游的一个节点开始遍历，x是y的必经节点，那么就可以说x支配了y（&lt;strong&gt;dominate&lt;/strong&gt;）。&lt;/p&gt;
&lt;p&gt;如果在对象图中，x支配的所有对象中，y的距离最近，那么就可以说x直接支配（&lt;strong&gt;immediate dominate&lt;/strong&gt;）y。&lt;/p&gt;
&lt;p&gt;支配树是基于对象的引用关系图建立的，在支配树中每个节点都是它的子节点的直接支配节点。基于支配树可以很清楚得看到对象之间的依赖关系。&lt;/p&gt;
&lt;p&gt;现在看个例子，在下面这张图中&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;x节点的子树就是所有被x支配的节点集合，也正式x的retained set；&lt;/li&gt;
&lt;li&gt;如果x是y的直接支配节点，那么x的支配节点也可以支配y&lt;/li&gt;
&lt;li&gt;支配树中的边跟对象引用图中的引用关系并不是一一对应的。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/44770-5be2b9e84ebe546c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;garbage-collection-roots&quot;&gt;Garbage Collection Roots&lt;/h3&gt;
&lt;p&gt;在MAT中，gc roots的概念跟研究垃圾收集算法时候的概念稍微有点不同。gc roots中的对象，是指那些可以从堆外访问到的对象的集合。如果一个对象符合下面这些场景中的一个，就可以被认为是gc roots中的节点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;System Class：由bootstrap classloader加载的类，例如rt.jar，里面的类的包名都是&lt;code&gt;java.util.*&lt;/code&gt;开头的。&lt;/li&gt;
&lt;li&gt;JNI Local：native代码中的局部变量，例如用户编写的JNI代码或JVM内部代码。&lt;/li&gt;
&lt;li&gt;JNI Global：native代码中的全局变量，例如用户编写的JNI代码或JVM内部代码。&lt;/li&gt;
&lt;li&gt;Thread Block：被当前活跃的线程锁引用的对象。&lt;/li&gt;
&lt;li&gt;Thread：正在存活的线程&lt;/li&gt;
&lt;li&gt;Busy Monitor：调用了wait()、notify()或synchronized关键字修饰的代码——例如&lt;code&gt;synchronized(object)&lt;/code&gt;或&lt;code&gt;synchronized&lt;/code&gt;方法。&lt;/li&gt;
&lt;li&gt;Java Local：局部变量。例如函数的输入参数、正在运行的线程栈里创建的对象。&lt;/li&gt;
&lt;li&gt;Native Stack：native代码的输入或输出参数，例如用户定义的JNI代码或JVM的内部代码。在文件/网络IO方法或反射方法的参数。&lt;/li&gt;
&lt;li&gt;Finalizable：在finalize队列中等待它的finalizer对象运行的对象。&lt;/li&gt;
&lt;li&gt;Unfinalized：重载了finalize方法，但是还没有进入finalize队列中的对象。&lt;/li&gt;
&lt;li&gt;Unreachable：从任何gc roots节点都不可达的对象，在MAT中将这些对象视为root节点，如果不这么做，就不能对这些对象进行分析。&lt;/li&gt;
&lt;li&gt;Java Stack Frame：Java栈帧，用于存放局部变量。只在dump文件被解析的时候会将java stack frame视为对象。&lt;/li&gt;
&lt;li&gt;Unknown：没有root类型的对象。有些dump文件（例如IBM的Portable Heap Dump）没有root信息。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;三获取dump文件&quot;&gt;三、获取Dump文件&lt;/h2&gt;
&lt;ol readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;通过MAT生成dump文件&lt;br/&gt;通过这个路径找到生成dump文件的对话框&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/44770-41395cd611310d7e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;br/&gt;选择一个进程，点击finish即可 &lt;img src=&quot;https://upload-images.jianshu.io/upload_images/44770-6f7a6e9103e934c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;通过jmap命令生成dump文件
&lt;ul&gt;&lt;li&gt;命令格式：&lt;code&gt;jmap -dump:live,format=b,file=heap.bin &amp;lt;pid&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;注意：如果要保留heapdump中的不可达对象，则需要把”:live“去掉，即使用命令”jmap -dump,format=b,file=heap.bin “&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;通过设置JVM参数自动生成&lt;br/&gt;使用&lt;code&gt;-XX:+HeapDumpOnOutOfMemoryError&lt;/code&gt;这个JVM参数，在Java进程运行过程中发生OOM的时候就会生成一个heapdump文件，并写入到指定目录，一般用&lt;code&gt;-XX:HeapDumpPath=${HOME}/logs/test&lt;/code&gt;来设置。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;hr/&gt;&lt;p&gt;本号专注于后端技术、JVM问题排查和优化、Java面试题、个人成长和自我管理等主题，为读者提供一线开发者的工作和成长经验，期待你能在这里有所收获。&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/44770-7daebe9e48739106.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;javaadu&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 16 Apr 2019 15:10:00 +0000</pubDate>
<dc:creator>javaadu</dc:creator>
<og:description>本文首发于公众号：javaadu 尽管JVM提供了自动内存管理的机制，试图降低程序员的开发门槛，确实也实现了这一目标，在日常开发中，我们一般都不需要关心对象的内存释放。JVM大部分都是使用trace算</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/javaadu/p/10720799.html</dc:identifier>
</item>
<item>
<title>JPA中自定义的插入、更新、删除方法为什么要添加@Modifying注解和@Transactional注解？ - 无恨之都</title>
<link>http://www.cnblogs.com/wuhenzhidu/p/jpa.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wuhenzhidu/p/jpa.html</guid>
<description>&lt;p&gt;　　前几天，有个同事在使用JPA的自定义SQL方法时，程序一直报异常，捣鼓了半天也没能解决，咨询我的时候，我看了一眼他的程序，差不多是这个样子的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;@Repository
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; UserRepository &lt;span&gt;extends&lt;/span&gt; JpaRepository&amp;lt;User,Long&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; 
&lt;span&gt;4&lt;/span&gt;     @Query(value = &quot;delete from pro_user where id = ?1&quot;,nativeQuery = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt;&lt;span&gt; deleteUserById(Long id);
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　我告诉他，你的deleteUserById方法缺少了@Modifying注解和@Transactional注解，他半信半疑地试了一下，然后果然就解决了。其实，如果他查一下官方资料或许很快也就能找到答案。基于这个背景，本文详细讲解一下为何我们自定义的插入、更新、删除操作需要加@Modifying注解和@Transactional注解。&lt;/p&gt;
&lt;h2&gt;一、@Modifying注解&lt;/h2&gt;
&lt;p&gt;　　在官方资料中，给出了这样几句说明：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre readability=&quot;6&quot;&gt;
&lt;span&gt;As the queries themselves are tied to the Java method that executes them, you can actually bind them directly by using the Spring Data JPA @Query annotation 
rather than annotating them to the domain &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span readability=&quot;6&quot;&gt;.&lt;br/&gt;You can modify queries that only need parameter binding by annotating the query method with @Modifying&lt;p&gt;The @Modifying annotation is only relevant in combination with the @Query annotation. Derived query methods or custom methods do not require this Annotation.&lt;/p&gt;&lt;p&gt;Doing so triggers the query annotated to the method as an updating query instead of a selecting one.&lt;/p&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Modifying
@Query(&lt;/span&gt;&quot;update User u set u.firstname = ?1 where u.lastname = ?2&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; setFixedFirstnameFor(String firstname, String lastname);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　第一句话的意思是可以用@Query注解来将自定义sql语句绑定到自定义方法上。&lt;/p&gt;
&lt;p&gt;　　第二句话的意思时，可以用@Modifying注解来标注只需要绑定参数的自定义的更新类语句（更新、插入、删除）。&lt;/p&gt;
&lt;p&gt;　　第三名话的意思是说@Modifying只与@Query联合使用，派生类的查询方法和自定义的方法不需要此注解，如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;@Repository
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; UserRepository &lt;span&gt;extends&lt;/span&gt; JpaRepository&amp;lt;User,Long&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 父类的保存方法&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    User save(User entity); 
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 按照JPA语法规则自定义的查询方法&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     List&amp;lt;User&amp;gt;&lt;span&gt; findFirst10ByLastname(String lastName, Pageable pageable);  
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　第四句话的意思是，当加上@Modifying注解时，JPA会以更新类语句来执行，而不再是以查询语句执行。　　&lt;/p&gt;
&lt;p&gt;　　也就是说，当我们要通过自已写的更新、插入、删除SQL语句来实现更新、插入、删除操作时，至少需要用两个步骤：&lt;/p&gt;
&lt;p&gt;　　1）@Query来注入我们自定义的sql；&lt;/p&gt;
&lt;p&gt;　　2）使用@Modifying来标注是一个更新类的自定义语句。&lt;/p&gt;
&lt;p&gt;　　按照这个规则，修改同事的那个方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt; @Repository
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; UserRepository &lt;span&gt;extends&lt;/span&gt; JpaRepository&amp;lt;User,Long&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;  
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;     @Modifying
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;      @Query(value = &quot;delete from pro_user where id = ?1&quot;,nativeQuery = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;      &lt;span&gt;void&lt;/span&gt;&lt;span&gt; deleteUserById(Long id);
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;  }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　但是，此时，该方法还不完整，执行时程序会报以下错误：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
org.springframework.dao.InvalidDataAccessApiUsageException: Executing an update/delete query; nested exception is javax.persistence.TransactionRequiredException: &lt;br/&gt;Executing an update/&lt;span&gt;delete query
    at org.springframework.orm.jpa.EntityManagerFactoryUtils.convertJpaAccessExceptionIfPossible(EntityManagerFactoryUtils.java:&lt;/span&gt;402&lt;span&gt;)
    at org.springframework.orm.jpa.vendor.HibernateJpaDialect.translateExceptionIfPossible(HibernateJpaDialect.java:&lt;/span&gt;255&lt;span&gt;)
    ......
    at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:&lt;/span&gt;70&lt;span&gt;)
Caused by: javax.persistence.TransactionRequiredException: Executing an update&lt;/span&gt;/&lt;span&gt;delete query
    at org.hibernate.internal.AbstractSharedSessionContract.checkTransactionNeededForUpdateOperation(AbstractSharedSessionContract.java:&lt;/span&gt;398&lt;span&gt;)
    at org.hibernate.query.internal.AbstractProducedQuery.executeUpdate(AbstractProducedQuery.java:&lt;/span&gt;1585&lt;span&gt;)
    .......&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;二、@Transactional注解&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;　　官方的说明：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-expand&quot;&gt;　　By default, CRUD methods on repository instances are transactional. For read operations, the transaction configuration&lt;/span&gt; &lt;span&gt;&lt;code&gt;readOnly&lt;/code&gt;&lt;/span&gt; &lt;span&gt;flag is set to&lt;/span&gt; &lt;span&gt;&lt;code&gt;true&lt;/code&gt;&lt;/span&gt;&lt;span&gt;. All others are configured with a plain&lt;/span&gt; &lt;span&gt;&lt;code&gt;@Transactional&lt;/code&gt;&lt;/span&gt; &lt;span&gt;so that default transaction configuration applies. For details, see JavaDoc of&lt;/span&gt; &lt;span&gt;&lt;a href=&quot;https://docs.spring.io/spring-data/data-jpa/docs/current/api/index.html?org/springframework/data/jpa/repository/support/SimpleJpaRepository.html&quot;&gt;&lt;span&gt;&lt;code&gt;SimpleJpaRepository&lt;/code&gt;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;span&gt;. If you need to tweak transaction configuration for one of the methods declared in a repository, redeclare the method in your repository interface, as follows:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;em&gt;&lt;span&gt;Example. Custom transaction configuration for CRUD&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; UserRepository &lt;span&gt;extends&lt;/span&gt; CrudRepository&amp;lt;User, Long&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; 
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;  @Override
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;   @Transactional(timeout = 10&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;   &lt;span&gt;public&lt;/span&gt; List&amp;lt;User&amp;gt;&lt;span&gt; findAll();
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; 
&lt;span&gt;7&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Further query method declarations&lt;/span&gt;
&lt;span&gt;8&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这句话的意思是，默认情况下，repository 接口中的CRUD方法都是被@Transactional注解修饰了的，对于读的操作方法，@Transactional注解的readOnly属性是被设置为true的，即只读；CRUD中的其他方法被@Transactional修饰，即非只读。如果你需要修改repository 接口中的某些方法的事务属性，可以在该方法上重新加上@Transactional注解，并设置需要的属性。&lt;/p&gt;
&lt;p&gt;　　我们先来看一下，@Transactional注解的源码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;@Target({ElementType.METHOD, ElementType.TYPE})
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;@Retention(RetentionPolicy.RUNTIME)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;@Inherited
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;@Documented
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; @&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Transactional {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;     Propagation propagation() &lt;span&gt;default&lt;/span&gt;&lt;span&gt; Propagation.REQUIRED;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     Isolation isolation() &lt;span&gt;default&lt;/span&gt;&lt;span&gt; Isolation.DEFAULT;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; timeout() &lt;span&gt;default&lt;/span&gt; -1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;boolean&lt;/span&gt; readOnly() &lt;span&gt;default&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;   
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 其他省略&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　由上可见@Transactional注解的readOnly默认的属性的false，即非只读，当一个事务是非只读事务的时候，我们可以进行任何操作。&lt;/p&gt;
&lt;p&gt;　　再看一下repository 接口的实现类SimpleJpaRepository的源码(只摘了部分源码)：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;@Repository
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;@Transactional(
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     readOnly = &lt;span&gt;true&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; SimpleJpaRepository&amp;lt;T, ID&amp;gt; &lt;span&gt;implements&lt;/span&gt; JpaRepositoryImplementation&amp;lt;T, ID&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;    
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    @Transactional
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; deleteById(ID id) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         Assert.notNull(id, &quot;The given id must not be null!&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.delete(&lt;span&gt;this&lt;/span&gt;.findById(id).orElseThrow(() -&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; EmptyResultDataAccessException(String.format(&quot;No %s entity with id %s exists!&quot;, &lt;span&gt;this&lt;/span&gt;.entityInformation.getJavaType(), id), 1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        }));
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    @Transactional
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; delete(T entity) {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         Assert.notNull(entity, &quot;The entity must not be null!&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.em.remove(&lt;span&gt;this&lt;/span&gt;.em.contains(entity) ? entity : &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.em.merge(entity));
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    @Transactional
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; deleteAll(Iterable&amp;lt;? &lt;span&gt;extends&lt;/span&gt; T&amp;gt;&lt;span&gt; entities) {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         Assert.notNull(entities, &quot;The given Iterable of entities not be null!&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         Iterator var2 =&lt;span&gt; entities.iterator();
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt;&lt;span&gt;(var2.hasNext()) {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;             T entity =&lt;span&gt; var2.next();
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.delete(entity);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; T getOne(ID id) {
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         Assert.notNull(id, &quot;The given id must not be null!&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.em.getReference(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getDomainClass(), id);
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; 
&lt;span&gt;37&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; List&amp;lt;T&amp;gt;&lt;span&gt; findAll() {
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.getQuery((Specification)&lt;span&gt;null&lt;/span&gt;&lt;span&gt;, (Sort)Sort.unsorted()).getResultList();
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; 
&lt;span&gt;41&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; List&amp;lt;T&amp;gt; findAll(@Nullable Specification&amp;lt;T&amp;gt;&lt;span&gt; spec) {
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getQuery(spec, Sort.unsorted()).getResultList();
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; 
&lt;span&gt;45&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; List&amp;lt;T&amp;gt; findAll(@Nullable Specification&amp;lt;T&amp;gt;&lt;span&gt; spec, Sort sort) {
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getQuery(spec, sort).getResultList();
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; 
&lt;span&gt;49&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &amp;lt;S &lt;span&gt;extends&lt;/span&gt; T&amp;gt; &lt;span&gt;long&lt;/span&gt; count(Example&amp;lt;S&amp;gt;&lt;span&gt; example) {
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; executeCountQuery(&lt;span&gt;this&lt;/span&gt;.getCountQuery(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; SimpleJpaRepository.ExampleSpecification(example), example.getProbeType()));
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; 
&lt;span&gt;53&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &amp;lt;S &lt;span&gt;extends&lt;/span&gt; T&amp;gt; &lt;span&gt;boolean&lt;/span&gt; exists(Example&amp;lt;S&amp;gt;&lt;span&gt; example) {
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; !&lt;span&gt;this&lt;/span&gt;.getQuery(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; SimpleJpaRepository.ExampleSpecification(example), example.getProbeType(), (Sort)Sort.unsorted()).getResultList().isEmpty();
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; 
&lt;span&gt;57&lt;/span&gt; &lt;span&gt;    @Transactional
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &amp;lt;S &lt;span&gt;extends&lt;/span&gt; T&amp;gt;&lt;span&gt; S save(S entity) {
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.entityInformation.isNew(entity)) {
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.em.persist(entity);
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; entity;
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;         } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.em.merge(entity);
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt; 
&lt;span&gt;67&lt;/span&gt; &lt;span&gt;    @Transactional
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &amp;lt;S &lt;span&gt;extends&lt;/span&gt; T&amp;gt;&lt;span&gt; S saveAndFlush(S entity) {
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt;         S result = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.save(entity);
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.flush();
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;73&lt;/span&gt; 
&lt;span&gt;74&lt;/span&gt; &lt;span&gt;    @Transactional
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; flush() {
&lt;/span&gt;&lt;span&gt;76&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.em.flush();
&lt;/span&gt;&lt;span&gt;77&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;78&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　从SimpleJpaRepository源码中可以看出：&lt;/p&gt;
&lt;p&gt;　   1）该类上注解了只读事务@Transactional(readOnly = true)；&lt;/p&gt;
&lt;p&gt;       2）该类的所有查询类操作方法都与类相同，都拥有只读事务；&lt;/p&gt;
&lt;p&gt;       3）该类的所有保存、更新、删除操作方法都用@Transactional重新注解了（默认readOnly=false）。&lt;/p&gt;
&lt;p&gt;　　说明JPA为我们提供的所有方法，包括JPA规则的自定义方法在其底层都为我们做好了事务处理，而我们自定义的方法需要自己来标注事务的类型是只读还是非只读。根据这个原理，再次修改开篇所列出的方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;@Repository
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; UserRepository &lt;span&gt;extends&lt;/span&gt; JpaRepository&amp;lt;User,Long&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; 
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;    @Transactional
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;    @Modifying
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     @Query(value = &quot;delete from pro_user where id = ?1&quot;,nativeQuery = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt;&lt;span&gt; deleteUserById(Long id);
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　至此，该方法按所期望的结果运行成功了。&lt;/p&gt;
&lt;h2&gt;三、@Modifying注解补充说明&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;@Retention(RetentionPolicy.RUNTIME)
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;@Target({ ElementType.METHOD, ElementType.ANNOTATION_TYPE })
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;@Documented
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; @&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Modifying {
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; 
&lt;span&gt;6&lt;/span&gt;     &lt;span&gt;boolean&lt;/span&gt; flushAutomatically() &lt;span&gt;default&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; 
&lt;span&gt;8&lt;/span&gt;     &lt;span&gt;boolean&lt;/span&gt; clearAutomatically() &lt;span&gt;default&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　该注解中有两个属性：flushAutomatically、clearAutomatically，从字面理解是自动刷新和自动清除。&lt;/p&gt;
&lt;p&gt;　　自动刷新，即执行完语句后立即将变化内容刷新到磁盘，如果是insert语句操作，则与JPA的&amp;lt;S extends T&amp;gt; S saveAndFlush(S entity);方法效果相同；&lt;/p&gt;
&lt;p&gt;　　自动清除，即执行完语句后自动清除掉已经过期的实体，比如，我们删除了一个实体，但是在还没有执行flush操作时，这个实体还存在于实体管理器EntityManager中，但这个实体已经过期没有任何用处，直到flush操作时才会被删除掉。如果希望在删除该实体时立即将该实体从实体管理器中删除，则可以将该属性设置为true，如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; @Modifying(clearAutomatically = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;    @Transactional
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     @Query(value = &quot;delete from pro_user where id = ?1&quot;,nativeQuery = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt; deleteUserById(Long id);
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Tue, 16 Apr 2019 14:44:00 +0000</pubDate>
<dc:creator>无恨之都</dc:creator>
<og:description>前几天，有个同事在使用JPA的自定义SQL方法时，程序一直报异常，捣鼓了半天也没能解决，咨询我的时候，我看了一眼他的程序，差不多是这个样子的： 我告诉他，你的deleteUserById方法缺少了@M</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wuhenzhidu/p/jpa.html</dc:identifier>
</item>
<item>
<title>面试必备的数据库悲观锁与乐观锁 - Coder编程</title>
<link>http://www.cnblogs.com/coder-programming/p/10720524.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/coder-programming/p/10720524.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/4/16/16a26835c73ea038?w=900&amp;amp;h=383&amp;amp;f=png&amp;amp;s=178029&quot; alt=&quot;悲观锁与乐观锁&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;在上一个章节&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIwMTg3NzYyOA==&amp;amp;mid=2247483728&amp;amp;idx=1&amp;amp;sn=cdc5dc4708e48051e56b8e7d2a9fe5a8&amp;amp;chksm=96e67043a191f955b93e7228b88572beb486e6fac3308a1b69f5ee83c9e9ced6957e30b12d58&amp;amp;token=1787261466&amp;amp;lang=zh_CN#rd&quot;&gt;5分钟带你读懂事务隔离性与隔离级别&lt;/a&gt;的最后，其实我们已经提到了锁的概念。本章节接下来将主要介绍以下数据库&lt;code&gt;悲观锁与乐观锁&lt;/code&gt;的相关知识。如有错误还请大家及时指出~&lt;/p&gt;
&lt;blockquote readability=&quot;4.320987654321&quot;&gt;
&lt;p&gt;本文已同步至 &lt;a href=&quot;https://github.com/CoderMerlin/coder-programming&quot;&gt;GitHub&lt;/a&gt;/&lt;a href=&quot;https://gitee.com/573059382/coder-programming&quot;&gt;Gitee&lt;/a&gt;/公众号，感兴趣的同学帮忙点波关注~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;为什么需要锁？&lt;/li&gt;
&lt;li&gt;什么是悲观锁？&lt;/li&gt;
&lt;li&gt;什么是乐观锁？&lt;/li&gt;
&lt;li&gt;悲观锁与乐观锁区别与联系？&lt;/li&gt;
&lt;li&gt;悲观锁与乐观锁的使用场景？&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;为什么需要锁&quot;&gt;为什么需要锁？&lt;/h2&gt;
&lt;p&gt;在并发环境下，如果多个客户端访问同一条数据，此时就会产生数据不一致的问题，如何解决，通过加锁的机制，常见的有两种锁，乐观锁和悲观锁，可以在一定程度上解决并发访问。&lt;/p&gt;
&lt;h2 id=&quot;悲观锁pessimistic-lock&quot;&gt;1. 悲观锁（Pessimistic Lock）&lt;/h2&gt;
&lt;h3 id=&quot;定义&quot;&gt;1.1 定义&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;百度百科：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;悲观锁，正如其名，具有强烈的独占和排他特性。它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;其他知识点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;悲观锁主要是&lt;code&gt;共享锁&lt;/code&gt;或&lt;code&gt;排他锁&lt;/code&gt;&lt;br/&gt;&lt;code&gt;共享锁&lt;/code&gt;又称为读锁，简称S锁，顾名思义，共享锁就是多个事务对于同一数据可以共享一把锁，都能访问到数据，但是只能读不能修改。&lt;br/&gt;&lt;code&gt;排他锁&lt;/code&gt;又称为写锁，简称X锁，顾名思义，排他锁就是不能与其他所并存，如一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁，包括共享锁和排他锁，但是获取排他锁的事务是可以对数据就行读取和修改。&lt;/p&gt;
&lt;h3 id=&quot;案例分析&quot;&gt;1.2 案例分析&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;使用场景举例：以MySQL InnoDB为例&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;作为演示，我们继续使用之前的数据库表：product表&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;小米&lt;/td&gt;
&lt;td&gt;1999&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;魅族&lt;/td&gt;
&lt;td&gt;1999&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;首先我们需要&lt;code&gt;set autocommit=0&lt;/code&gt;，即不允许自动提交&lt;/p&gt;
&lt;p&gt;有看过上一篇文章&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIwMTg3NzYyOA==&amp;amp;mid=2247483728&amp;amp;idx=1&amp;amp;sn=cdc5dc4708e48051e56b8e7d2a9fe5a8&amp;amp;chksm=96e67043a191f955b93e7228b88572beb486e6fac3308a1b69f5ee83c9e9ced6957e30b12d58&amp;amp;token=1787261466&amp;amp;lang=zh_CN#rd&quot;&gt;5分钟带你读懂事务隔离性与隔离级别&lt;/a&gt;的同学，可以看到最后我们使用事务隔离级别时，所引申出来的根本问题就是可以通过锁机制解决。&lt;/p&gt;
&lt;h4 id=&quot;问题&quot;&gt;问题&lt;/h4&gt;
&lt;p&gt;在并发情况下回导致数据一致性的问题：&lt;br/&gt;如果有A、B两个用户需要抢productId =1的小米手机，A、B用户都查询小米手机数量是100，A购买后修改商品的数量为99，B购买后修改数量为99。&lt;/p&gt;
&lt;h4 id=&quot;用法&quot;&gt;用法&lt;/h4&gt;
&lt;p&gt;每次获取小米手机时，对该商品加排他锁。也就是在用户A获取获取 id=1 的小米手机信息时对该行记录加锁，期间其他用户阻塞等待访问该记录。代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;start transaction；
 
select p.productCount from product p where p.productId = 1 for update;
 
update product p set p.productCount=p.productCount-1 where p.productId=1 ;
 
commit;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;操作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面同时打开两个窗口模拟2个用户并发访问数据库&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;T1&lt;/td&gt;
&lt;td&gt;start transaction;&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;T2&lt;/td&gt;
&lt;td&gt;select p.productCount from product p where p.productId = 1 for update;&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;T3&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;start transaction;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;T4&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;select p.productCount from product p where p.productId = 1 for update;(等待中...)&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;流程说明&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;用户A start transaction开启一个事物。前一步我们关闭了mysql的autocommit，所以需要手动控制事务的提交。&lt;/li&gt;
&lt;li&gt;在获得小米手机信息（productId = 1 ）时，进行数据加锁操作（for update）。与普通查询方式不同，我们使用了&lt;code&gt;select…for update&lt;/code&gt;的方式，这样就通过数据库实现了悲观锁。在这个update事务提交之前其他外界是不能修改这条数据的，但是这种处理方式效率比较低，一般不推荐使用。&lt;/li&gt;
&lt;li&gt;用户B start transaction开启一个事物。&lt;/li&gt;
&lt;li&gt;用户B 也进行查询操作，此时处于等待中（阻塞状态）。ps:需要等待用户A事务提交后，才会执行。&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;注意：在事务中，只有select…for update(排他锁) 或lock in share mode(共享锁) 操作同一个数据时才会等待其它事务结束后才执行，一般select... 则不受此影响。例如在 T3中执行select p.productCount from product p where p.productId = 1;则能正常查询出数据，不会受第一个事务的影响。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;乐观锁optimistic-lock&quot;&gt;2. 乐观锁（Optimistic Lock）&lt;/h2&gt;
&lt;h3 id=&quot;定义-1&quot;&gt;2.1 定义&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;百度百科：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;乐观锁机制采取了更加宽松的加锁机制。乐观锁是相对悲观锁而言，也是为了避免数据库幻读、业务处理时间过长等原因引起数据处理错误的一种机制，但乐观锁不会刻意使用数据库本身的锁机制，而是依据数据本身来保证数据的正确性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;其他知识点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;实现乐观锁一般来说有以下2种方式：&lt;/p&gt;
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;使用版本号&lt;br/&gt;使用数据版本（Version）记录机制实现，这是乐观锁最常用的一种实现方式。何谓数据版本？即为数据增加一个版本标识，一般是通过为数据库表增加一个数字类型的 “version” 字段来实现。当读取数据时，将version字段的值一同读出，数据每更新一次，对此version值加一。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的version值进行比对，如果数据库表当前版本号与第一次取出来的version值相等，则予以更新，否则认为是过期数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;使用时间戳&lt;br/&gt;乐观锁定的第二种实现方式和第一种差不多，同样是在需要乐观锁控制的table中增加一个字段，名称无所谓，字段类型使用时间戳（timestamp）, 和上面的version类似，也是在更新提交的时候检查当前数据库中数据的时间戳和自己更新前取到的时间戳进行对比，如果一致则OK，否则就是版本冲突。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;案例分析-1&quot;&gt;2.2 案例分析&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;使用场景举例：以MySQL InnoDB为例&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;作为演示，我们继续使用之前的数据库表：product表&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;小米&lt;/td&gt;
&lt;td&gt;1999&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;魅族&lt;/td&gt;
&lt;td&gt;1999&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;我们以&lt;code&gt;版本号&lt;/code&gt;实现的方式进行说明。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;操作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;查询当前事务隔离级别：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
SELECT @@tx_isolation;


结果：
REPEATABLE-READ
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面同时打开两个窗口模拟2个用户并发访问数据库&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一种测试&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;7&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;T1&lt;/td&gt;
&lt;td&gt;start transaction;&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;T2&lt;/td&gt;
&lt;td&gt;select * from product p where p.productId = 1;(productCount=100)&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;T3&lt;/td&gt;
&lt;td&gt;update product p set p.productCount = 99,version=version+1 where p.productId = 1 and version = 1;(受影响的行: 1)&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;T4&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;start transaction;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;T5&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;select * from product p where p.productId = 1;(productCount=100)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;T6&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;update product p set p.productCount = 99,version=version+1 where p.productId = 1 and version = 1;(等待中...)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;T7&lt;/td&gt;
&lt;td&gt;commit;&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;T8&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;T6执行(受影响的行: 0)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;T9&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;commit;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;流程说明&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;事务A开启事务。&lt;/li&gt;
&lt;li&gt;事务A查询当前小米手机数量为100。&lt;/li&gt;
&lt;li&gt;事务A购买小米手机，小米手机数量更新为99。(此时并未提交事务)。&lt;/li&gt;
&lt;li&gt;事务B开启事务。&lt;/li&gt;
&lt;li&gt;事务B查询当前小米手机数量为100。&lt;/li&gt;
&lt;li&gt;事务B购买小米手机，小米手机数量更新为99。注意：此时处于阻塞状态。&lt;/li&gt;
&lt;li&gt;事务A提交事务。&lt;/li&gt;
&lt;li&gt;此时第六步执行完毕，但并未成功(受影响的行: 0)。&lt;/li&gt;
&lt;li&gt;事务B提交事务。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;第二种测试&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;6&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;T1&lt;/td&gt;
&lt;td&gt;select * from product p where p.productId = 1;(productCount=100)&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;T2&lt;/td&gt;
&lt;td&gt;update product p set p.productCount = 99,version=version+1 where p.productId = 1 and version = 1;(受影响的行: 1)&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;T3&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;select * from product p where p.productId = 1;(productCount=100)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;T4&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;update product p set p.productCount = 99,version=version+1 where p.productId = 1 and version = 1;(受影响的行: 0)&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;乐观锁小结&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;用户B修改数据的时候，受影响行数为0，对业务来说，及更新失败。这时候我们只需要告诉用户购买失败，重新查询一遍即可。&lt;/li&gt;
&lt;li&gt;对比第一种和第二种测试，我们会发现第一种测试，将update语句放入事务中会出现阻塞的情况，而第二种测试不会出现阻塞情况。这是为什么呢？update其实在不在事务中都无所谓，在内部是这样的：update是单线程的，及如果一个线程对一条数据进行update操作，会获得锁，其他线程如果要对同一条数据操作会阻塞，直到这个线程update成功后释放锁。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;乐观锁不需要数据库底层的支持！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;适用场景&quot;&gt;3. 适用场景&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;悲观锁&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;比较适合写入操作比较频繁的场景，如果出现大量的读取操作，每次读取的时候都会进行加锁，这样会增加大量的锁的开销，降低了系统的吞吐量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;乐观锁&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;比较适合读取操作比较频繁的场景，如果出现大量的写入操作，数据发生冲突的可能性就会增大，为了保证数据的一致性，应用层需要不断的重新获取数据，这样会增加大量的查询操作，降低了系统的吞吐量。&lt;/p&gt;
&lt;h2 id=&quot;文末&quot;&gt;文末&lt;/h2&gt;
&lt;p&gt;本章节主要简单介绍了数据库中&lt;code&gt;乐观锁与悲观锁&lt;/code&gt;的相关知识，后续我们将会继续介绍数据库中的其他锁以及相关知识。例如行锁、表锁、死锁、&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;欢迎关注公众号：&lt;strong&gt;Coder编程&lt;/strong&gt;&lt;br/&gt;获取最新原创技术文章和相关免费学习资料，随时随地学习技术知识！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;参考文章：&lt;/p&gt;
&lt;p&gt;https://chenzhou123520.iteye.com/blog/1860954&lt;/p&gt;
&lt;p&gt;https://chenzhou123520.iteye.com/blog/1863407&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/4/16/16a26835c75c12fc?w=300&amp;amp;h=390&amp;amp;f=png&amp;amp;s=18217&quot; alt=&quot;微信公众号&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;推荐阅读&quot;&gt;推荐阅读&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIwMTg3NzYyOA==&amp;amp;mid=2247483713&amp;amp;idx=1&amp;amp;sn=d61ad0aed42dc36d64d17732db352288&amp;amp;chksm=96e67052a191f9445bbe3d5825ce547ad3171c3874b571a93b97977d0668413e37a164c3e0bc&amp;amp;token=1144933717&amp;amp;lang=zh_CN#rd&quot;&gt;带你了解数据库中JOIN的用法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIwMTg3NzYyOA==&amp;amp;mid=2247483722&amp;amp;idx=1&amp;amp;sn=e8bc8bd82c559e0cfe7f35cf46100af3&amp;amp;chksm=96e67059a191f94fe8948e5b5e4ef177b77fa7707d86d945b153f67e7f2e76b83ed0c768ef27&amp;amp;token=128531458&amp;amp;lang=zh_CN#rd&quot;&gt;带你了解数据库中事务的ACID特性&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIwMTg3NzYyOA==&amp;amp;mid=2247483728&amp;amp;idx=1&amp;amp;sn=cdc5dc4708e48051e56b8e7d2a9fe5a8&amp;amp;chksm=96e67043a191f955b93e7228b88572beb486e6fac3308a1b69f5ee83c9e9ced6957e30b12d58&amp;amp;token=1787261466&amp;amp;lang=zh_CN#rd&quot;&gt;5分钟带你读懂事务隔离性与隔离级别&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 16 Apr 2019 14:25:00 +0000</pubDate>
<dc:creator>Coder编程</dc:creator>
<og:description>前言 在上一个章节 '5分钟带你读懂事务隔离性与隔离级别 ' 的最后，其实我们已经提到了锁的概念。本章节接下来将主要介绍以下数据库 的相关知识。如有错误还请大家及时指出~ 本文已同步至 'GitHub</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/coder-programming/p/10720524.html</dc:identifier>
</item>
<item>
<title>Dynamics 365 CRM 开发架构简介 - 氢氦</title>
<link>http://www.cnblogs.com/hhelibeb/p/10718080.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hhelibeb/p/10718080.html</guid>
<description>&lt;p&gt;Dynamics 365 CRM提供了多种编程模型，你可以灵活地按需选用最佳模式。&lt;/p&gt;
&lt;p&gt;本文是对Dynamics 365 CRM编程模型的综述。&lt;/p&gt;
&lt;h2&gt;概览&lt;/h2&gt;
&lt;p&gt;下图表明了Dynamics 365 CRM的主要可编程场景。请根据整体解决方案选择合适的模型。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/994049/201904/994049-20190416164223320-1161450035.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从扩展的角度来看，你可以在Dynamics 365中实现以下附加功能：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span class=&quot;h2title&quot;&gt;应用于PC或移动设备的控制台应用程序或者WPF（Windows Presentation Foundation），即图中上方.Net下的绿框。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;h2title&quot;&gt;&lt;span class=&quot;h2title&quot;&gt;处理Dynamics的Web表单的扩展，即图中右侧&lt;span class=&quot;h2title&quot;&gt;web application部分。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;h2title&quot;&gt;&lt;span class=&quot;h2title&quot;&gt;处理Dynamics服务端的扩展&lt;span class=&quot;h2title&quot;&gt;，即图中左侧&lt;span class=&quot;h2title&quot;&gt;.NET plug-ins和workflows下方的绿色方框。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;其中1和2属于客户端扩展，3属于服务端扩展。&lt;/p&gt;
&lt;h3&gt;名词解释&lt;/h3&gt;
&lt;p&gt;上图中的部分名词的基本概念。&lt;/p&gt;
&lt;p id=&quot;web-resource-types&quot; class=&quot;heading-with-anchor&quot;&gt;&lt;strong&gt;Web resources&lt;/strong&gt;：存储在Dynamics 365 CRM数据库中的虚拟文件，比如图片，网页，XML等，可以通过URL访问。&lt;/p&gt;
&lt;p class=&quot;heading-with-anchor&quot;&gt;&lt;strong&gt;Forms scripts&lt;/strong&gt;：Dynamics 365 CRM中的一种常见的Javascript应用方式，使用场景是通过自定义代码对表单输入内容校验、或进行其它自动化处理。（参考：&lt;a href=&quot;https://crmbook.powerobjects.com/extending-crm/javascript/#why_and_when&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;Form Scripts&lt;/strong&gt;&lt;/a&gt;）&lt;/p&gt;
&lt;p class=&quot;heading-with-anchor&quot;&gt;&lt;span class=&quot;st&quot;&gt;&lt;strong&gt;Ribbon commands&lt;/strong&gt;：Ribbon的的定义见&lt;a href=&quot;https://docs.microsoft.com/en-us/windows/desktop/uxguide/cmd-ribbons&quot; target=&quot;_blank&quot;&gt;微软文档&lt;/a&gt;，&lt;span class=&quot;st&quot;&gt;Ribbon commands是定义&lt;span class=&quot;st&quot;&gt;&lt;span class=&quot;st&quot;&gt;Ribbon的一种方式。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;heading-with-anchor&quot;&gt;&lt;span class=&quot;st&quot;&gt;&lt;span class=&quot;st&quot;&gt;&lt;span class=&quot;st&quot;&gt;&lt;span class=&quot;st&quot;&gt;&lt;strong&gt;Workflow&lt;/strong&gt;：通过&lt;span class=&quot;st&quot;&gt;&lt;span class=&quot;st&quot;&gt;&lt;span class=&quot;st&quot;&gt;&lt;span class=&quot;st&quot;&gt;Workflow&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;可以创建和管理自动化的业务过程，它也提供了定制和扩展标准流程的机制。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;heading-with-anchor&quot;&gt;&lt;span class=&quot;st&quot;&gt;&lt;span class=&quot;st&quot;&gt;&lt;span class=&quot;st&quot;&gt;&lt;span class=&quot;st&quot;&gt;&lt;strong&gt;Plug-ins&lt;/strong&gt;：一种事件处理程序，通过它可以修改或扩充标准的业务流程。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;heading-with-anchor&quot;&gt;&lt;span class=&quot;st&quot;&gt;&lt;span class=&quot;st&quot;&gt;&lt;span class=&quot;st&quot;&gt;&lt;span class=&quot;st&quot;&gt;&lt;strong&gt;Organization service&lt;/strong&gt;：客户端连接服务端的一种方式，适用于.Net客户端。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;heading-with-anchor&quot;&gt;&lt;span class=&quot;st&quot;&gt;&lt;span class=&quot;st&quot;&gt;&lt;span class=&quot;st&quot;&gt;&lt;span class=&quot;st&quot;&gt;&lt;span class=&quot;st&quot;&gt;&lt;span class=&quot;st&quot;&gt;&lt;span class=&quot;st&quot;&gt;&lt;span class=&quot;st&quot;&gt;&lt;strong&gt;Web API&lt;/strong&gt;：客户端连接服务端的一种方式，拥有良好的平台兼容性，适用于各种客户端。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Service Contracts&lt;/strong&gt;：Dynamics中的一种单据类型，这里和主旨无关。&lt;/p&gt;
&lt;p&gt;本文链接：&lt;a id=&quot;Editor_Edit_hlEntryLink&quot; title=&quot;view: Dynamics 365 CRM 开发架构简介&quot; href=&quot;https://www.cnblogs.com/hhelibeb/p/10718080.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/hhelibeb/p/10718080.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;转载请注明&lt;/p&gt;

&lt;h2&gt;连接到Dynamics 365 CRM&lt;/h2&gt;
&lt;p&gt;客户端要访问Dynamics 365 CRM中的数据，有2种方案可以选择：使用Web API或者organization service。&lt;/p&gt;
&lt;h3&gt;Web API&lt;/h3&gt;
&lt;p&gt;Web API在2016年11月的更新中被引入，它提供了跨编程语言、跨平台和跨设备的开发体验。Web API实现了&lt;a href=&quot;http://odata.org&quot; data-linktype=&quot;external&quot;&gt;OData&lt;/a&gt; (Open Data Protocol) v4。OData是一个用于构建和消费RESTfulAPIs的&lt;a href=&quot;https://en.wikipedia.org/wiki/OASIS_(organization)&quot; target=&quot;_blank&quot;&gt;OASIS&lt;/a&gt;标准。&lt;/p&gt;
&lt;p&gt;使用Web API时，可以选择&lt;a href=&quot;http://www.odata.org/libraries/&quot; target=&quot;_blank&quot;&gt;由社区支持的支持OData V4标准的库&lt;/a&gt;。你也可以选择写代码直接使用HTTP。&lt;/p&gt;
&lt;p&gt;相关内容：&lt;a href=&quot;https://docs.microsoft.com/zh-cn/dynamics365/customer-engagement/developer/use-microsoft-dynamics-365-web-api&quot; data-linktype=&quot;relative-path&quot;&gt;使用Dynamics 365 CRM Web API&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;连接Dynamics 365 CRM时，可以使用&lt;a href=&quot;https://azure.microsoft.com/documentation/articles/active-directory-authentication-libraries/&quot; data-linktype=&quot;external&quot;&gt;Azure AD Authentication Libraries (ADAL)&lt;/a&gt;以启用支持多语言/多平台的认证。&lt;/p&gt;
&lt;p&gt;相关内容：&lt;a href=&quot;https://docs.microsoft.com/zh-cn/dynamics365/customer-engagement/developer/webapi/authenticate-web-api&quot; data-linktype=&quot;relative-path&quot;&gt;通过Web API进行身份认证&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;organization-service&quot; class=&quot;heading-with-anchor&quot;&gt;Organization service&lt;/h3&gt;
&lt;p&gt;如果你是位.Net开发者，那么你既可以使用Web API，也可以使用organization service。通过organization service可以使用组件和工具生成强类型类，包含已经被添加到Dynamics 365 CRM实例中的自定义实体和属性。&lt;/p&gt;

&lt;p&gt;通过SDK组件和工具， 你可以使用&lt;a class=&quot;xref&quot; href=&quot;https://docs.microsoft.com/en-us/dotnet/api/microsoft.xrm.sdk.client.organizationservicecontext&quot; data-linktype=&quot;absolute-path&quot;&gt;OrganizationServiceContext&lt;/a&gt;，通过这个类可以跟踪变更、管理身份和关系。它也提供了访问Dynamics 365 CRM中的LINQ的入口。当你使用代码生成工具的时候，会得到当前已定义的实体和属性的强类型类，它们被称为&lt;strong&gt;早绑定&lt;/strong&gt;类（early-bound classes）。&lt;/p&gt;
&lt;p&gt;更多信息：&lt;a href=&quot;https://docs.microsoft.com/zh-cn/dynamics365/customer-engagement/developer/org-service/use-early-bound-entity-classes-code&quot; data-linktype=&quot;relative-path&quot;&gt;在代码中使用早绑定实体类&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;当代码需要处理生成代码时尚不知道的实体和属性时，你可以在代码中使用允许指定实体和属性的实体类。这种&lt;strong&gt;晚绑定&lt;/strong&gt;（late-bound）的代码风格提供了更大的灵活性，但是不允许完整的编译期类型检查，因此不会出现隐式转换。在晚绑定下，只有在对象创建或者对类型执行操作的时候才会检查类型。需要显示指定实体类的类型，以避免隐式转换。&lt;/p&gt;
&lt;p&gt;相关内容：&lt;a href=&quot;https://docs.microsoft.com/zh-cn/dynamics365/customer-engagement/developer/org-service/use-late-bound-entity-class-code&quot; data-linktype=&quot;relative-path&quot;&gt;在代码中使用晚绑定&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;如果要创建Windows客户端或者使用Windows PoweShell，可以使用Xrm.Tolling。它提供了一套API，通过使用SDK组件来提供额外的功能和资源，用于Windows客户端的开发。&lt;/p&gt;
&lt;p&gt;相关内容：&lt;a href=&quot;https://docs.microsoft.com/zh-cn/dynamics365/customer-engagement/developer/build-windows-client-applications-xrm-tools&quot; data-linktype=&quot;relative-path&quot;&gt;使用XRM工具创建Windows客户端应用&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;选择 - Web API vs. Organization service&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/994049/201904/994049-20190416215527364-1282146190.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注：organization service目前使用的是过时的2011 SOAP Endpoint，未来它的内部实现会迁移到Web API。&lt;/p&gt;
&lt;h2&gt;扩展服务端&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;tlid-translation translation&quot; lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;&quot;&gt;可以编写监听事件的代码，并应用自定义业务逻辑来修改或扩充平台的标准行为。 &lt;span title=&quot;&quot;&gt;这种代码仅可使用.NET托管代码编写，开发人员的体验基于SDK组件中定义的相同对象。你可以使用organization service操作Dynamics 365 CRM中的数据。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;tlid-translation translation&quot; lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;&quot;&gt;&lt;span title=&quot;&quot;&gt;相关信息： &lt;a href=&quot;https://docs.microsoft.com/zh-cn/dynamics365/customer-engagement/developer/write-plugin-extend-business-processes&quot; data-linktype=&quot;relative-path&quot;&gt;写插件来扩展业务处理&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;tlid-translation translation&quot; lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;&quot;&gt;&lt;span title=&quot;&quot;&gt;可以基于&lt;a href=&quot;https://msdn.microsoft.com/netframework/aa663328.aspx&quot; data-linktype=&quot;external&quot;&gt;Windows Workflow Foundation&lt;/a&gt;编程模型创建自定义流程。可以创建多种不同的处理，多数时候通过使用workflow设计器来实现功能。但是设计器有一些做不到的事情，此时可以通过代码来定义。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;tlid-translation translation&quot; lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;&quot;&gt;&lt;span title=&quot;&quot;&gt;相关信息：&lt;a href=&quot;https://docs.microsoft.com/zh-cn/dynamics365/customer-engagement/developer/automate-business-processes-customer-engagement&quot; data-linktype=&quot;relative-path&quot;&gt;写Workflow来自动化业务处理&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;扩展应用端&lt;/h2&gt;
&lt;p&gt;Dynamics 365 CRM提供的每个客户端应用都具备定制和部署到不同类型客户端的能力。Web应用、Dynamics 365 for Outlook、Dynamics 365 for 平板、and Dynamics 365 for 电话——都提供了自定义导航和命令的能力，也提供了Xrm对象模型和Xrm.Utility功能，可以通过使用Javascript为客户端提供响应式体验。&lt;/p&gt;
&lt;p&gt;在客户端中，可以通过URL访问Web resource，比如Javascript库、HTML页面、图像，或其它文件。&lt;/p&gt;
&lt;p&gt;相关内容：&lt;a href=&quot;https://docs.microsoft.com/zh-cn/dynamics365/customer-engagement/developer/use-javascript&quot; target=&quot;_blank&quot;&gt;在CRM app中使用Javascript&lt;/a&gt;，&lt;a href=&quot;https://docs.microsoft.com/zh-cn/dynamics365/customer-engagement/developer/web-resources&quot; data-linktype=&quot;relative-path&quot;&gt;Dynamics 365  CRM中的Web Resource&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;当你需要访问在Javascript上下文中不可用的Dynamics 365 CRM数据时，可以调用服务器获取数据。可以使用organization service，但使用JSON格式的Web API会比基于XML的organization service更简单，因为JS在应用上下文中运行，会自动获得身份认证。&lt;/p&gt;
&lt;p&gt;相关内容：&lt;a href=&quot;https://docs.microsoft.com/zh-cn/dynamics365/customer-engagement/developer/webapi/get-started-web-api-client-side-javascript&quot; data-linktype=&quot;relative-path&quot;&gt;Dynamics 365 CRM Web API入门 (客户端JavaScript)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;参考：&lt;a href=&quot;https://docs.microsoft.com/zh-cn/dynamics365/customer-engagement/developer/programming-models&quot; target=&quot;_blank&quot;&gt;Programming models for Dynamics 365 for Customer Engagement apps&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;           &lt;a href=&quot;https://www.apriorit.com/dev-blog/448-microsoft-dynamics-365-custom-extensions-and-data-import&quot; target=&quot;_blank&quot;&gt;Microsoft Dynamics 365: Custom Extensions and Data Import&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;           &lt;a href=&quot;https://crmbook.powerobjects.com/extending-crm/javascript/#why_and_when&quot; target=&quot;_blank&quot;&gt;JavaScript and HTML Resources&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 16 Apr 2019 14:08:00 +0000</pubDate>
<dc:creator>氢氦</dc:creator>
<og:description>Dynamics 365 CRM提供了多种编程模型，你可以灵活地按需选用最佳模式。 本文是对Dynamics 365 CRM编程模型的综述。 概览 下图表明了Dynamics 365 CRM的主要可编</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hhelibeb/p/10718080.html</dc:identifier>
</item>
<item>
<title>面试的反杀-你有没有想要问我的 - stoneFang</title>
<link>http://www.cnblogs.com/stoneFang/p/10720160.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/stoneFang/p/10720160.html</guid>
<description>&lt;p&gt;前一段时候脉脉上有个段子&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;面试官问候选人什么时候红黑树，候选人答不太熟悉，不知道具体怎么实现的，最后面试官问候选人有什么想问他的。候选人问面试官什么是红黑树，面试官支支吾吾了半天，最后说太久了，都忘了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不知道是不是真的，但是面试结束的时候，面试官通常会问下候选人 &lt;code class=&quot;prettyprint code-in-text prettyprinted&quot;&gt;&lt;span class=&quot;pun&quot;&gt;你有没有想要问我的&lt;/span&gt;&lt;/code&gt;，今天结合我自己的面试和被面试的经历聊聊这个话题。&lt;/p&gt;

&lt;p&gt;我换个两份工作，社招过2次。我对我问的问题印象很深刻，为什么呢，因为问的都是自己之前公司缺少的，想在下家公司获得的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一家&lt;/strong&gt; 因为第一份工作团队人员流失率非常高，作为一个工作1年的人就得扛起大旗，每走一个人，意味着留给我的坑又多了许多。所以导致本来明明是一家养老公司，我却天天在加班。所以面试时我问的永远只有1条&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&lt;span class=&quot;pun&quot;&gt;   这个&lt;span class=&quot;pln&quot;&gt;hc&lt;span class=&quot;pun&quot;&gt;是什么原因空出来的，我将要入职的团队稳定吗?&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二家&lt;/strong&gt; 第二家公司团队真的很稳定，但是因为是美资世界五百强，做的事情没有什么挑战性，始终觉得技术没有得到施展，发挥应有的价值。所以面试时我的问题就是&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&lt;span class=&quot;pun&quot;&gt;   这个工作有没有挑战性？公司的发展空间有多大？&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;等我入职后我发现像我这么问有问题，因为把前公司好的一面都丢到了，来到新公司，难免会比较，如果新公司没有之前公司的优点，我想要的新的期望又不突出，那么在新公司待的就比较痛苦了。&lt;/p&gt;

&lt;p&gt;在&lt;a href=&quot;https://fangzhang.blog.csdn.net/article/details/88908060&quot;&gt;最近招聘java高级工程师的几点感想&lt;/a&gt;一文中提到过我们招聘的几点要求&lt;/p&gt;
&lt;ol class=&quot;linenums&quot;&gt;&lt;li class=&quot;L0&quot;&gt;&lt;code&gt;&lt;span class=&quot;lit&quot;&gt;1. &lt;span class=&quot;pln&quot;&gt;java &lt;span class=&quot;pun&quot;&gt;基础要好，有&lt;span class=&quot;pln&quot;&gt;OO&lt;span class=&quot;pun&quot;&gt;思想&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li class=&quot;L0&quot;&gt;&lt;code&gt;&lt;span class=&quot;lit&quot;&gt;&lt;span class=&quot;pln&quot;&gt; &lt;span class=&quot;pun&quot;&gt;分布式要有一定了解，能基本匹配公司技术栈&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li class=&quot;L0&quot;&gt;&lt;code&gt;&lt;span class=&quot;lit&quot;&gt;&lt;span class=&quot;pln&quot;&gt; &lt;span class=&quot;pun&quot;&gt;熟悉线上问题排查手段，了解稳定性保障常用方法&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li class=&quot;L0&quot;&gt;&lt;code&gt;&lt;span class=&quot;lit&quot;&gt;&lt;span class=&quot;pln&quot;&gt; &lt;span class=&quot;pun&quot;&gt;对技术有一定追求，有一定潜力&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;第四点听上去比较虚，不好考量。但其实作为技术面试官，还是会在交流过程中能够识别出来对技术是否有追求的，其中最后一问也可以考察到这个。&lt;/p&gt;
&lt;p&gt;总结一下我收到的常见的几类问题&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;无所谓型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;业务技术型&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;假如我进去后，负责的业务是什么&lt;/li&gt;
&lt;li&gt;公司目前技术栈是什么&lt;/li&gt;
&lt;li&gt;团队怎么样&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这种是务实型，个人比较喜欢的小伙伴，如果业务/技术/团队都问到了，并且在我回答过程中能够有更进一步的交流时，就更加分了。比如&lt;/p&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;我之前了解过你们这块业务，发现你们主要做的是XXX，我认为他很有价值，但是我个人觉得可以更近一步XXX。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;你们的技术栈和我们的有点区别，我可能在某某方面比较欠缺，不过根据我之前做XX的经验，我觉得我学习一段时间应该很快能上手。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;寻求反馈型&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;您对我这次的面试评价是什么&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;从面试过程中，您觉得我的优点是什么，不足在什么地方&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这种属于成熟机灵型，个人比较喜欢。这种候选人一般是面试经验丰富而且善于总结。另外比较机灵吧，因为面试结果一般是不允许现场给出的，需要和用人经理沟通综合考虑决定过不过的。所以这种问题算是巧妙的避开了直接反馈的。&lt;/p&gt;
&lt;p&gt;我的回答一般是还不错，然后客观点评，先说好的，再说不足。一般不轻易透露喜好，和结果。除非是觉得你非常的不错，我会毫不吝惜的说 &lt;code class=&quot;prettyprint code-in-text prettyprinted&quot;&gt;&lt;span class=&quot;pun&quot;&gt;我觉得你非常不错，&lt;span class=&quot;pln&quot;&gt;bla&lt;span class=&quot;pun&quot;&gt;,&lt;span class=&quot;pln&quot;&gt;bla&lt;span class=&quot;pun&quot;&gt;，从各个方面都很适合我们这个岗位。不过我这只是一/二面，后面还有几轮面试，希望你继续加油&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;或者如果我想争取你来，博得你的好感，我也会指出你的不足，然后提到我们团队有这方面经验，能够帮助你弥补这块的空缺。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;反杀型&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;你刚才问我的那道题答案是什么&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;不知道是不是因为脉脉那个段子带火了还是怎么回事，反杀型的问我的越来越多了。虽然只要候选人问了，我都会回答他，从我个人来说，从来没有问过我自己不知道答案的问题。&lt;/p&gt;
&lt;p&gt;但是从我个人角度来说不是很喜欢这种问题。为什么呢？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;问的时机不对，面试的过程不是你问我答，是交流的过程，如果当时问这个问题的时候，你不知道，我一般会提醒你从哪些角度思考，如果提醒还不知道，会再问相关的问题，如果都不知道，就会一个类型题目问，比如问了你数据库相关的，你基本都不知道，就会换着问java相关的。所以这个问题应该在面试过程中问，而不是结束的时候问&lt;/li&gt;
&lt;li&gt;一般面试java高级工程师的问题，都是比较系统化的，由点到面的。如果你不知道，说明在某方面缺失了，需要自己面试完去总结，查找资料。而不是直接去问到答案。&lt;/li&gt;
&lt;li&gt;跟风，抖机灵。面试是一个严肃的过程，是双方相互考察的机会，短短几十分钟的时间很珍贵，应当多呈现一些你自己独特的一面，经过思考的问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其实最后一问，并没有特别重要，属于锦上添花型。如果你前面面试的时候表现优秀，不会因为这个问题答的不好把你pass掉； 如果你前面表现不好，也不会因为这个问题答的好让你过。 但是你可以利用这个问题，问到你想要了解关于公司的问题。不妨假如自己已经成功入职了这家公司，你对这家公司，有什么期待，你对自己的未来规划有什么打算，这家公司具备什么样的条件能够满足你的期望。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190414123311685.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mYW5nemhhbmcuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 16 Apr 2019 13:29:00 +0000</pubDate>
<dc:creator>stoneFang</dc:creator>
<og:description>摘要 前一段时候脉脉上有个段子 面试官问候选人什么时候红黑树，候选人答不太熟悉，不知道具体怎么实现的，最后面试官问候选人有什么想问他的。候选人问面试官什么是红黑树，面试官支支吾吾了半天，最后说太久了，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/stoneFang/p/10720160.html</dc:identifier>
</item>
<item>
<title>你知道希尔排序为什么可以打破二次时间界吗？ - 9龙</title>
<link>http://www.cnblogs.com/9dragon/p/10720032.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/9dragon/p/10720032.html</guid>
<description>&lt;div class=&quot;output_wrapper&quot; id=&quot;output_wrapper_id&quot; readability=&quot;68.22905027933&quot;&gt;
&lt;h3 id=&quot;h&quot;&gt;&lt;span&gt;引言：&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;前面详解了&lt;a href=&quot;https://www.cnblogs.com/9dragon/p/10705097.html&quot;&gt;如何优化冒泡排序？&lt;/a&gt;，&lt;a href=&quot;https://www.cnblogs.com/9dragon/p/10710735.html&quot;&gt;图解选择排序与插入排序&lt;/a&gt;，这些简单排序算法平均时间复杂度都是O(n^2)。&lt;strong&gt;希尔排序是第一批打破二次时间屏障的算法之一&lt;/strong&gt;。下面我们来分析为什么希尔排序可以打破二次时间复杂度。&lt;/p&gt;
&lt;h3 id=&quot;h-1&quot;&gt;&lt;span&gt;一、分析简单排序算法的下界&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;逆序&lt;/strong&gt;：具有性质&lt;strong&gt;i &amp;lt; j&lt;/strong&gt;但 &lt;strong&gt;a[i] &amp;gt; a[j]&lt;/strong&gt;的序偶&lt;strong&gt;（a[i]，a[j]）&lt;/strong&gt;。如序列34，8，64，51，32，21有9个逆序，即（34，8）、（34，32）、（34，31）、（64，51）、（64，32）、（64，21）、（51，32）、（51，21）以及（32，21）。注意，这正好是需要（隐含）执行的交换次数。事实总是这样，因为&lt;strong&gt;交换两个不按顺序排序的相邻元素恰好消除一个逆序&lt;/strong&gt;，而一个排过序的数组没有逆序。由于算法中还有O(N)量的工作，假设 &lt;strong&gt;I&lt;/strong&gt; 是原数组中的逆序数，所以插入排序的运行时间是O(I + N)。所以，&lt;strong&gt;如果逆序数是O(N)，则插入排序以线性时间运行；冒泡排序通过加标志位也可以在有序的条件下达到最优O(N)。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所以我们可以&lt;strong&gt;通过计算原始序列中的平均逆序数得出简单排序的平均时间精确的界&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这里&lt;strong&gt;假设元素互异&lt;/strong&gt;（如果允许重复，那我们连重复的平均次数都无法知道）。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;定理1：N个互异数的数组的平均逆序数是N(N-1)/4。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;证明：N个互异数的序列L与逆序列Lr中，所有序偶为N(N-1)/2（很容易理解：相当于从N个互异数中选两个元素，这两个元素有顺序，即：&lt;strong&gt;A&lt;sup&gt;2&lt;/sup&gt;&lt;sub&gt;N&lt;/sub&gt;&lt;/strong&gt;= N(N-1)/2）。那平均的逆序表列该有一半：即 N(N-1)/4个逆序。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;定理2：通过交换相邻元素进行排序的任何算法平均都需要&lt;br/&gt;&lt;span class=&quot;katex-display&quot;&gt;&lt;span class=&quot;katex&quot;&gt;&lt;img src=&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAD8AAAAlCAYAAAD1EjEiAAAFLUlEQVRoQ+1XeSjefxx/Y45hIYyS0EjCJnIuxxIKyRybI+1i7Q9Li9xEKMlZrkRhja2VtrVFri0sltUicpUjWZPkKGeO9fr8ep6er+fwzPzM5vn89zzf9+f9fr/ex+v9/sgdHh4e0gU9cjLwssxfvAjIyv7i5fw/xLLMyzL/F0RgcXGRampqaGxsjOzt7enJkyd0+fLlE3v+15T9/v4+VVVVUXBwMGlqatKzZ8/I29ubgoKC/n3wKysr1NTUxLKtoKBAjY2NNDc3RxkZGf8++OXlZXr06BFlZWXRjRs3KDs7mzQ0NFgFnPT8L2WPjKiqqpKuru5J/RK6t7e3R62treTk5ES7u7uUnJxMOTk5ZGxszJc9ODigL1++kI2NjVRcIBL8xsYGK6vBwUEyNTUl/EbZRUVFkaOjI8nLy4sFBTL69OkTxcTE0KVLl4TkXr58yUhraGiI3N3dqa6ujrS0tJjc27dvKT8/n0ZHRxmAtLQ08vHx4ehAEIqLi8nX15esrKyE9P/48YNevHjB2kNNTU1i8IXAT01NUWxsLIWEhNCDBw/4ABYWFujp06fk7OzMSk0UsKWlJSotLaWEhAQ+IFHWh4eHqaCggDo6Olgfe3p68sUmJiZY8B4/fkxycnKc63iAvn//ngwMDMjW1lYssPb2dpqfn6eHDx8K6RC8xAG/s7PDoo3IP3/+nHR0dDgGWlpaWGCQPTc3NyHjvCwex8DQo66uTtXV1WRoaMgCoayszPR1dnaykr1586aQ/t7eXlpdXSUXFxdWjQMDA3Tnzh0hOVRpamoqJSUlcdriqCAHPHo1IiKCrK2tqaSkRKhvkDFeRaSkpHB0ra2tUWJiIutFExMTsVnhjaywsDBW5kVFRfT69WuytLRkd+rr6+nWrVtkZGTE0cFruw8fPvD/RxLu3r0r0hb8v3r1KkVGRor1hQP++/fvTNjc3FwkeEQasxVMe5RlEZiKigoqLCykK1euiDWIIKGqUNZopfDwcJY96Nva2mJcc+/ePakIS1JD9/T00Js3bxiHKCkpiRTlgAeLYm4CiKiyf/fuHSMSKHVwcOAolMYYLkA3eAXLCqoAgezv72egYf/jx490//59iUQlzcfx8XHWTqgAjERRR4jwvn79yow3NDSQnZ0d/w4cRWDgYF5eHr9HeQJg2Onp6WOXDpStvr4+XzeCgRbIzc1loxGTRFS/SwNYUAbEiZ2gvLyctLW1pQMPkBglYHPB0kZLgO3hpIWFhZAyacCDrUFy4A3eDgCSBVesr6+z8RYYGCjU778KHPK/DH5kZITQk9euXWMBAPPzSgZjaXZ2lhFiW1sbBQQEkKKiIt+vV69e0eTkpMTMC/a7YB92dXXR7du3GXmVlZWxBel3zy+DR3YBAgDBxFhCQH44yJirqysbNVhkoqOjOf6BDNEqCJq4l9a3b99YgI4yNJgcqyv0/866KuiQNP5wen5zc5Pi4uKotraW6enr62P9t729TfHx8VRZWcn+xxLh5eXFAY8xmZ6ezsAfXWuxcGA0gk9wQkNDWVWpqKjwdWBHMDMzE7k/nKQKkEQkU1IwT2235y1IGFtHJ8FJnP+dO7wp4u/vL9GXUwMPZz9//kzd3d1su8Kz80+dmZkZ9n7IzMyUuC+cKng8OtAaHh4edP369T+CHT6An/BeEDWVBJ06VfBQjC2tubmZ/Pz8SE9P70wDgFEKosYegafvcefUwR9n8Dx9l4E/T9k4S19kmT/LaJ8nW7LMn6dsnKUvssyfZbTPk62fXZ7csNWld5IAAAAASUVORK5CYII=&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;证明：因为初始的平均逆序数为N(N-1)/4，而每次交换只减少一个逆序数，因此需要&lt;br/&gt;&lt;span class=&quot;katex-display&quot;&gt;&lt;span class=&quot;katex&quot;&gt;&lt;img src=&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEUAAAAnCAYAAABZsYV4AAAFb0lEQVRoQ+1Yayiebxi/UE4tXxCW80Iyp/iwYUXziWhyDOOLciplNjbULDNixBcmWy1ETim+OoQYK7YPNKeSwxLKKZlDm3+/ux497/s87/s+eHzY/s/95a33vu/ruu7f/bt+13U/ehcXFxekDBUE9BRQhIxQQBHJEgUUBRRp4qkwRWGKwhRpCPxrTJmbm6OxsTFaW1sjDw8PiomJISMjo2uDwW38azVlc3OTvn79SpGRkXRyckKVlZXk5eVFUVFR/19Qvn//TnV1dfTu3TuysbGh/v5+wn8vXrwgY2PjGwFza0z59esX9fX1UXBwMFlZWd0oSLHNe3t79OXLFwoJCWEgNDU10fn5OWVkZJCBgcHlFrCot7eXAgMDyd7eXlIcGkH58+cPra+v08zMDCEAa2trlrd2dnakr6+v1fjv37+pra2NPD09ycfHR3TtxsYG1dbWEn6RCnFxcSoHwv/V1dU0OztLhoaGdO/ePcrNzSUnJyeBvZ8/f9L79+8pJydHdB7xf/78mVJSUsjc3FwnMKKgrKysUE1NDQskISGBLC0tWeDt7e1M1J49eybqnPOGG/zx4welpqaq3JpYNK2trTQ6Okr7+/tUVVVFDg4Ol8vwVm1ubqZHjx6Rs7Oz6GHAyI8fP1JYWBiLV9OYnp6mqakpSk9P1xmTABQAUlxcTA8ePKCsrCwVA2BAfX09TU5O0tu3b0WBQZC44fj4eHJxcdF6K8fHx9TR0UHu7u5UUlJCSUlJlJycTHp6emwfNw9bpqamAluIB6nh7+9Pjo6OtL29zZjATx9uE2xBjGNjYxnjtQ0VUODkw4cPTLRAx/v37wv2QszAlOjoaEH+YjHo3tXVRQUFBaIH4RtEeqKkPnnyhMrLy2lra4sJp4WFBVuG+fHxccZW9QEWDQ0NMRCQUjg0Uh2M4UBV39Pd3U24ND7wYuCogHJwcMAOs7u7K6Ayt3l1dZUpPFIKBzEzM1Ox29LSQqenp5SWlqYzd5FmGA8fPqTh4WEqLS2loqIievz4MfufP69ubH5+nvLy8ujo6Ohy6vnz5xQREaHRLy4U8b1584bu3LmjcZ0KKIeHh/Tq1Sva2dnRCQoEV9342dkZY5i3tzeFh4frBAVijKoAHYHv169fs2ALCwvJxMSEMS4oKIiVXDkGLhTxwb42m6Lp09PTwyoDmiH1AcFC+qhXC04DoDVILT8/P63nENML6ENjYyMLHMIKvdGkJ9cBCVWorKyMsrOztRYKgdAuLi7Sy5cvWWf49OlTgW/QD8GjUqirPZd+6BU0lWJ+GkIvEhMTL32gtObn51NAQABj2rdv32TpUDkHUuMTgAKxxcEBDqoQX/Vxu2CCq6srA0xd5aU61aQXnNBPTEwwbUD10sW4qzBGanyC9EFgyO+KigpW0/lldWlpidEbTILAAhQ+MBA96AJuX9thUDnQ86D/gDbxB6oXBNPW1pYJr1x6Ah/XSh8I7MjICHttDg4OsocWXzChNXfv3mU9DMobWnhUIW5IFVqAjqYNHaZ6FYBPpCaGHO8YPuDXElqkB/oUX19fZguNHNeV4l3x6dMncnNzY3O4UZRdVAn+0FaSQV90ygsLC6zRQtVBa8754+yg81xeXmbNnJwDJbmzs1MgC+o+VNIHtG5oaGCqjxEaGnp5W9wNDgwMsDlUhczMTEGjBMcopeg3xLpQOQ95VVtc8yZWQPi2ZH8lIzXQToNhutr8qx7qJuuRBXh+QO+0vZHgQ3ZQYBTdKT/1bnIYufbe6EEoRxBSPh3I4UeqDVk+HUh1pm3dbX9kkhqjrB+ZpDr9F9fdiqb87UApoIjcoAKKAoq0xFaYojBFYYo0BBSmSMNJ0RQRnP4DinVEuTwJvbcAAAAASUVORK5CYII=&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;结论：&lt;/strong&gt;这个&lt;strong&gt;下界&lt;/strong&gt;告诉我们，&lt;strong&gt;为了使一个排序算法以亚二次或O(N^2)时间运行，必须执行一些比较，特别是要对相距较远的元素进行交换。&lt;/strong&gt;一个排序算法通过删除逆序得以向前进行，而为了有效地进行它必须使每次交换删除不止一个逆序。下面我们来看希尔排序怎么打破二次时间界。&lt;/p&gt;
&lt;h3 id=&quot;hshellsort&quot;&gt;&lt;span&gt;二、希尔排序（ShellSort）&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;希尔排序按其设计者希尔（Donald Shell）的名字命名。&lt;strong&gt;希尔排序通过多次插入排序来实现。&lt;/strong&gt;它通过比较相距一定间隔的元素来工作；各趟比较所用的距离随着算法的进行而减小，直到只比较相邻元素的最后一趟排序为止。所以希尔排序也叫&lt;strong&gt;缩减增量排序。&lt;/strong&gt;&lt;/p&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;算法思想&lt;/strong&gt;：使用一个序列h&lt;sub&gt;1&lt;/sub&gt;,h&lt;sub&gt;2&lt;/sub&gt;,….h&lt;sub&gt;t&lt;/sub&gt;,叫&lt;strong&gt;做增量序列&lt;/strong&gt;。只要h&lt;sub&gt;1&lt;/sub&gt;=1,任何增量序列都是可行的。在使用增量h&lt;sub&gt;k&lt;/sub&gt;排序后，对于每一个i 我们都有a[i]&amp;lt;=a[i+h&lt;sub&gt;k&lt;/sub&gt;]；所有相隔h&lt;sub&gt;k&lt;/sub&gt;的元素都被排序，这称为h&lt;sub&gt;k&lt;/sub&gt;排序。&lt;strong&gt;只要最后h&lt;sub&gt;1&lt;/sub&gt;=1（这时就是最普通的插入排序）&lt;/strong&gt;,希尔排序都可完成工作。&lt;strong&gt;一趟h&lt;sub&gt;k&lt;/sub&gt;排序就是对h&lt;sub&gt;k&lt;/sub&gt;个子数组进行插入排序。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;排序过程&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;选择一个增量序列h&lt;sub&gt;1&lt;/sub&gt;,h&lt;sub&gt;2&lt;/sub&gt;,….h&lt;sub&gt;t&lt;/sub&gt;，h&lt;sub&gt;1&lt;/sub&gt;=1。&lt;/li&gt;
&lt;li&gt;根据增量序列个数，即循环t次进行排序，每次排序结束后更换为h&lt;sub&gt;t-1&lt;/sub&gt;的增量。&lt;/li&gt;
&lt;li&gt;把原数组分为h&lt;sub&gt;t&lt;/sub&gt;个子数组，对每个子数组进行插入排序。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;下面我们使用增量序列1、3、5对序列 {3, 7, 1, 13, 9, 11, 5, 8, 2, 4, 12, 6, 10}进行希尔排序的图解。&lt;/p&gt;
&lt;img src=&quot;https://img2018.cnblogs.com/blog/1603499/201904/1603499-20190416210517054-1749710125.jpg&quot; alt=&quot;希尔排序图解&quot; title=&quot;希尔排序图解&quot;/&gt;希尔排序图解
&lt;p&gt;每种颜色代表一个子数组，很直观看到每一趟排序过程及结果。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;java实现冒泡排序：&lt;/strong&gt;代码中我们使用希尔建议的增量序列（但效率不高）。h&lt;sub&gt;t&lt;/sub&gt;=N/2和h&lt;sub&gt;k&lt;/sub&gt;=h&lt;sub&gt;k+1&lt;/sub&gt;/2。理解了插入排序流程，代码实现很简单。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &amp;lt;T extends Comparable&amp;lt;? &lt;span class=&quot;hljs-keyword&quot;&gt;super&lt;/span&gt; T&amp;gt;&amp;gt; &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;shellsort&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(T[] a)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; j;&lt;br/&gt;T tmp = &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; gap = a.length / &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;; gap &amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; gap /= &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; i = gap; i &amp;lt; a.length; i++) {&lt;br/&gt;tmp = a[i];&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (j = i; j &amp;gt;= gap &amp;amp;&amp;amp;&lt;br/&gt;tmp.compareTo(a[j - gap]) &amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; j -= gap) {&lt;br/&gt;a[j] = a[j - gap];&lt;br/&gt;}&lt;br/&gt;a[j] = tmp;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;时间、空间复杂度及稳定性分析：&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;&lt;strong&gt;希尔排序的运行时间依赖于增量序列的选择&lt;/strong&gt;，而证明很复杂【有兴趣可查看其他资料】。&lt;/li&gt;
&lt;li&gt;使用&lt;strong&gt;希尔增量&lt;/strong&gt;时希尔排序&lt;strong&gt;最坏时间复杂度&lt;/strong&gt;是：&lt;strong&gt;O(n^2)。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;使用&lt;strong&gt;Hibbard增量&lt;/strong&gt;的希尔排序&lt;strong&gt;最坏时间复杂度&lt;/strong&gt;是：&lt;strong&gt;O(n&lt;sup&gt;3/2&lt;/sup&gt;)&lt;/strong&gt;；&lt;strong&gt;最优时间复杂度是O(n&lt;sup&gt;5/4&lt;/sup&gt;)&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;使用&lt;strong&gt;Sedgewick 增量&lt;/strong&gt;序列,排序&lt;strong&gt;最坏时间复杂度&lt;/strong&gt;是：&lt;strong&gt;O(n&lt;sup&gt;4/3&lt;/sup&gt;)&lt;/strong&gt;；&lt;strong&gt;平均时间复杂度是O(n&lt;sup&gt;7/6&lt;/sup&gt;)&lt;/strong&gt;。最好的序列是{1,5,19,41,109……}。该序列中的项或者是9 * 4&lt;sup&gt;i&lt;/sup&gt; - 9 * 2&lt;sup&gt;i&lt;/sup&gt; +1的形式，或者是4&lt;sup&gt;i&lt;/sup&gt; - 3* 2&lt;sup&gt;i&lt;/sup&gt;+1)的形式。&lt;/li&gt;
&lt;li&gt;空间复杂度：只用到一个临时变量，所以&lt;strong&gt;空间复杂度&lt;/strong&gt;为&lt;strong&gt;O(1)&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;稳定性：&lt;strong&gt;不稳定&lt;/strong&gt;排序。因为每一趟的步长不一样，所以步长长的插入排序可能会把后面的元素插入到前面。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;h-2&quot;&gt;&lt;span&gt;三、总结&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;​ &lt;strong&gt;本篇说明了想要打破二次时间界，必须比较相距较远的元素来进行交换，这样可以一次交换删除多个逆序，以达到突破二次时间界。希尔排序通过使用增量序列来将原始序列分为多个子序列，对每个子序列进行插入排序。只要最终增量序列h&lt;sub&gt;1&lt;/sub&gt;=1,希尔排序都可正常工作。希尔排序时间严重依赖于增量序列的选择，我们可以直接先将好的增量序列“打表”存在数组中，这样不用每次排序都去计算。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;声明&lt;/strong&gt;：&lt;strong&gt;画图码字都辛苦，如有转载，请注明出处。文中引用来自《数据结构与算法java语言描述（原书第三版）》&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Tue, 16 Apr 2019 13:06:00 +0000</pubDate>
<dc:creator>9龙</dc:creator>
<og:description>引言： 前面详解了如何优化冒泡排序？，图解选择排序与插入排序，这些简单排序算法平均时间复杂度都是O(n^2)。希尔排序是第一批打破二次时间屏障的算法之一。下面我们来分析为什么希尔排序可以打破二次时间复</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/9dragon/p/10720032.html</dc:identifier>
</item>
<item>
<title>【官网】性能篇（三）为电池寿命做优化——概述 - 宋者为王</title>
<link>http://www.cnblogs.com/andy-songwei/p/10719778.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/andy-songwei/p/10719778.html</guid>
<description>&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       本文是“为电池寿命做优化”系列文档所做的一篇概述。&lt;/p&gt;
&lt;p&gt;       中国版官网原文地址为：&lt;a href=&quot;https://developer.android.google.cn/topic/performance/power&quot; target=&quot;_blank&quot;&gt;https://developer.android.google.cn/topic/performance/power&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;       路径为：Android Developers &amp;gt; Docs &amp;gt; 指南 &amp;gt; Best practies &amp;gt; Optimize for battery life &amp;gt;Overview&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;正文&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       电池寿命是移动用户体验最重要的一个方面。设备没有电量就根本无法提供任何功能。所以，应用尽可能地重视电池寿命是非常重要的。&lt;/p&gt;
&lt;p&gt;       有3个要点需要考虑来保持您的应用是省电的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;让您的应用“懒惰第一”&lt;/li&gt;
&lt;li&gt;利用可以帮助管理您应用的电池消耗的平台特性。&lt;/li&gt;
&lt;li&gt;使用可以帮您识别耗尽电量的罪魁祸首的工具。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;懒惰第一&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       让您的应用“懒惰第一”意味着寻找方法来降低和优化操作，尤其是电池密集型的操作。支撑“懒惰第一”设计的核心问题为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;节省：您的应用有冗余的操作可以砍掉吗？例如，可以用缓存下载的数据而不是重复地唤醒无线网络以重新下载数据吗？&lt;/li&gt;
&lt;li&gt;延迟：应用需要立刻执行某个动作吗？例如，可以等到设备充电时再备份数据到云端吗？&lt;/li&gt;
&lt;li&gt;合并：可以批量工作，而不是多次把设备推向活跃状态吗？例如，几十个应用中的每一个都在不同的时间开启无线网络来发送消息，这真的有必要吗？这些消息可以替换为在无线网一次唤醒时发送吗？&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;       当遇到使用CPU、无线网和屏幕时，您应该问问这些问题。“懒惰第一”的设计常常是一种抑制电池杀手的好办法。&lt;/p&gt;
&lt;p&gt;       为了帮助您实现这些和其它功能，Android平台提供了很多特性来帮助最大化电池寿命。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;平台特征&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       一般来说，Android平台为您提供了两种帮助策略来优化您应用的电池使用。首先，它提供了几个可以在您应用中实现的API。您可以在【&lt;a href=&quot;https://developer.android.google.cn/guide/background&quot; target=&quot;_blank&quot;&gt;Intelligent Job Scheduling&lt;/a&gt;】中了解更多关于这些API的信息。&lt;/p&gt;
&lt;p&gt;       在平台中也有内部机制来版主保护电池寿命。但是它们不是您能通过编程实现的API，您仍然应该了解它们，从而让您的应用可以成功地利用它们。更多信息，请查看：&lt;/p&gt;
&lt;p&gt;       除此以外，Android 9（API 等级28）为省电模式做了很多改善工作。设备制造商决定了施加的精准限制。作为一个示例，在AOSP构建上，系统应用了如下限制：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;系统更积极地将应用置于应用待机模式，而不是等待应用空闲下来。&lt;/li&gt;
&lt;li&gt;无论它们的目标API是什么级别，后台执行限制对所有应用都适用。&lt;/li&gt;
&lt;li&gt;当屏幕熄灭后，本地服务可能会失效。&lt;/li&gt;
&lt;li&gt;后台应用没有网络访问权限.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;       请在【&lt;a href=&quot;https://developer.android.google.cn/topic/performance/power/power-details.html&quot; target=&quot;_blank&quot;&gt;电量管理限制&lt;/a&gt;】中查阅特定设备电量优化的完整详情。&lt;/p&gt;
&lt;p&gt;       和平常一样，在省电模式下测试您的应用是一个好主意。您可以通过设备的“设置&amp;gt;电池节省器”屏幕手动开启省电模式。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;工具&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       通过使用供平台使用的工具来发现您应用中消耗功率最大的部分，您可以从这些特性上获取更多的好处。找到目标是通往成功优化的一大步。&lt;/p&gt;
&lt;p&gt;       有很多为Android提供的工具，帮助您确定那些可以优化的区域，以提高电池寿命，包括【&lt;a href=&quot;https://developer.android.google.cn/studio/profile/inspect-gpu-rendering#profile_rendering&quot; target=&quot;_blank&quot;&gt;Profile GPU Rendering&lt;/a&gt;】和【&lt;a href=&quot;https://github.com/google/battery-historian&quot; target=&quot;_blank&quot;&gt;Battery Historian&lt;/a&gt;】。利用这些工具来瞄准那些可以使用“懒惰第一”原则的目标区域。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;结语&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       本文最大限度保持原文的意思，由于笔者水平有限，若有不准确或不妥当的地方，请指正，谢谢！&lt;/p&gt;
</description>
<pubDate>Tue, 16 Apr 2019 12:22:00 +0000</pubDate>
<dc:creator>宋者为王</dc:creator>
<og:description>电池寿命是移动用户体验最重要的一个方面。设备没有电量就根本无法提供任何功能。所以，应用尽可能地重视电池寿命是非常重要的。本文是“为电池寿命做优化”系列文档所做的一篇概述，从整体上来介绍电池优化需要注意</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/andy-songwei/p/10719778.html</dc:identifier>
</item>
<item>
<title>分布式系列十二: Redis高级主题 - 罪恶斯巴克</title>
<link>http://www.cnblogs.com/walkinhalo/p/10719688.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/walkinhalo/p/10719688.html</guid>
<description>&lt;h2 id=&quot;持久化&quot;&gt;持久化&lt;/h2&gt;
&lt;p&gt;Redis 支持持久化, 其持久化数据有两种方式. 两种可以同时使用. 如果同时使用, Reids 在重启时将使用 AOF 方式来还原数据.&lt;/p&gt;
&lt;h3 id=&quot;rdb&quot;&gt;RDB&lt;/h3&gt;
&lt;p&gt;按照一定策略定时同步内存的数据到磁盘.文件名 &lt;code&gt;dump.rdb&lt;/code&gt;&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;snapshot: 快照复制. Redis在指定情况下触发快照: (1) 按配置的规则;(2) save 或 bgsave 命令执行;(3) flushall 命令; (4)执行复制&lt;/p&gt;
&lt;ol readability=&quot;3&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;配置的规则: &lt;code&gt;save seconds exchange&lt;/code&gt; 当在 seconds 指定的时间内, key 的数量更改大于 exchange 时发生快照.&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;save 或 bgsave 命令: 执行快照同步操作, 注意&lt;code&gt;save&lt;/code&gt;这个操作会暂时阻塞客户端请求. &lt;code&gt;bgsave&lt;/code&gt;则不会阻塞&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;flushall: 清除内存所有数据, 只要规则不为空, redis就会执行快照&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;执行复制:&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;快照原理&lt;/p&gt;
&lt;p&gt;fork 复制一份当前进程的副本, 这个进程是子进程, 负责同步持久化到磁盘. 而父进程负责处理客户端请求.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;快照的优缺点:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;缺点: 可能会丢失数据, 在下一次快照前宕机&lt;/li&gt;
&lt;li&gt;优点: 最大化Redis的性能, 父子进程职责分离&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;aof&quot;&gt;AOF&lt;/h3&gt;
&lt;p&gt;保存命令到磁盘, 也就是持久化日志.&lt;/p&gt;
&lt;ul readability=&quot;9&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;配置: &lt;code&gt;appendonly yes&lt;/code&gt; 启动aof. 默认的文件名是 &lt;code&gt;appendonly.aof&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;配置 &lt;code&gt;auto-aof-rewrite-percentage 100&lt;/code&gt; 当 aof 文件与上一次文件的大小相比, 超过配置的百分比就进行重写&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;配置 &lt;code&gt;auto-aof-rewrite-min-size 64m&lt;/code&gt; 限制允许重写最小 aof 文件大小, 即小于64m时不重写&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;aof 重写原理: aof 重写是安全的. 相当于同时将命令追加到现有的aof文件, 同时写入新的 aof 临时文件, 临时文件最终将覆盖原 aof 文件.&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;7&quot;&gt;
&lt;p&gt;同步磁盘数据: aof机制会将命令记录到aof文件, 但实际是同步到操作系统的缓存区, 最终由操作系统同步到磁盘. 可以通过下面配置修改策略&lt;br/&gt;&lt;code&gt;appendsync always&lt;/code&gt; 每次执行写入就同步, 安全但影响性能&lt;br/&gt;&lt;code&gt;appendsync everysec&lt;/code&gt; 每一秒执行&lt;br/&gt;&lt;code&gt;appendsync no&lt;/code&gt; 不执行同步, 由操作系统去执行, 效率高但不安全&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;aof 文件损坏后的修复, 使用&lt;code&gt;redis-check-aof-fix&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;集群&quot;&gt;集群&lt;/h2&gt;
&lt;h3 id=&quot;masterslave-复制&quot;&gt;master/slave 复制&lt;/h3&gt;
&lt;p&gt;主从方式, 从是只读的, slave也可以有自己的slave.&lt;/p&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;slave节点上配置 &lt;code&gt;slaveof masterip masterport&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;配置 &lt;code&gt;slave-serve-stale-data no&lt;/code&gt; 可以用来保证数据同步后再做其他操作&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;命令&lt;code&gt;info replication&lt;/code&gt;可以查看信息.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;实现原理:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;slave 连接到 master 后, 会向 master 发送 &lt;code&gt;SYNC&lt;/code&gt; 命令.&lt;/li&gt;
&lt;li&gt;master 收到命令后, 会做两件事(1) 执行bgsave;(2)master 将收到的修改命令存入缓冲区, 再将命令传输给slave&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;复制方式:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;基于rdb文件复制&lt;/li&gt;
&lt;li&gt;无硬盘复制 配置&lt;code&gt;rpli-diskless-sync yes&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;增量复制 PSYNC master run id. offset&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;命令&lt;code&gt;replconf listening-port 6379&lt;/code&gt;可以用来查看复制过程&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;缺点: 无法做master选举&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;sentinale-哨兵模式&quot;&gt;sentinale 哨兵模式&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;监控&lt;/li&gt;
&lt;li&gt;master选举&lt;/li&gt;
&lt;/ol&gt;&lt;ul readability=&quot;1&quot;&gt;&lt;li&gt;配置文件为&lt;code&gt;sentinel.conf&lt;/code&gt;&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;配置节点: &lt;code&gt;sentinel monitor mymaster 192,168,11,111 6379 2&lt;/code&gt; 最后的2为投票数&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;是高可用方案, 但不是高性能方案&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;集群-1&quot;&gt;集群&lt;/h3&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;原理&lt;/p&gt;
&lt;p&gt;Reids有slot槽的概念: redis中有16384个. 根据key的 CRC16 算法, 取得的结果与槽数取模.落入的槽的索引是固定的. 然后根据节点数将槽的范围确定到每个节点上.&lt;/p&gt;
&lt;p&gt;当节点新增和删除时, 节点的槽范围发生变化, 数据迁移需要人工干预.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;三方方案&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;redis shardding : jedis支持&lt;/li&gt;
&lt;li&gt;codis : 代理, 分片和数据迁移自动化&lt;/li&gt;
&lt;li&gt;twemproxy :&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;缓存穿透问题&quot;&gt;缓存穿透问题&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;数据库中不存在的对象查询后也缓存.&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;if(objJson!=null){
    redisService.expire(&quot;key&quot;,timeout:3*60);
} else {
    redisService.expire(&quot;key&quot;,timeout:5); //5秒内不查询数据库
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;synchronized&lt;/code&gt; 方法, 不理想, 排队影响性能.&lt;/li&gt;
&lt;li&gt;同步块, 需要双重判定, 否则阻塞的线程均会查询数据库, 代码如下&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;String value = redisService.get(&quot;key&quot;);
if(value==null){
    synchronized(lock){
        value = redisService.get(&quot;key&quot;); //多线程再次查询,防止数据库多次查询
        if(value==null){
            value = dao.get();
            redisService.set(&quot;key&quot;,value);
            if(objJson!=null){
                redisService.expire(&quot;key&quot;,timeout:3*60);
            } else {
                redisService.expire(&quot;key&quot;,timeout:5); //5秒内不查询数据库
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;if(redisService.setNx(&quot;key&quot;)==true){
    //查询数据库
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;不设超时时间或设置一个较长的超时时间, 然后判断当前时间是否超过缓存时间, 结合分布式锁, 超过则刷新缓存. 此解决方法可能会发生少量数据不一致的情况.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;采用何种策略需要结合实际需求, 是保证可用, 还是保证一致性? 对于一致性要求不高的场景, 可能最后一种方案可以彻底解决击穿问题. 对于一致性要求较高的场景, 使用同步/锁的方式会更好.&lt;/p&gt;
</description>
<pubDate>Tue, 16 Apr 2019 12:09:00 +0000</pubDate>
<dc:creator>罪恶斯巴克</dc:creator>
<og:description>持久化 Redis 支持持久化, 其持久化数据有两种方式. 两种可以同时使用. 如果同时使用, Reids 在重启时将使用 AOF 方式来还原数据. RDB 按照一定策略定时同步内存的数据到磁盘.文件</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/walkinhalo/p/10719688.html</dc:identifier>
</item>
</channel>
</rss>