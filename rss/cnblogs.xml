<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>评估机器学习模型的几种方法（验证集的重要性） - 左手十字</title>
<link>http://www.cnblogs.com/zuoshoushizi/p/10111722.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zuoshoushizi/p/10111722.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;什么是评估机器学习模型    &lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　机器学习的目的是得到可以泛化（generalize）的模型，即在前所未见的数据上表现很好的模型，而过拟合则是核心难点。你只能控制可以观察的事情，所以能够可靠地衡量模型的泛化能力非常重要。　　&lt;/p&gt;
&lt;p&gt;如何衡量泛化能力，即如何评估机器学习模型。&lt;/p&gt;
&lt;p&gt;评估模型的重点是将数据划分为三个集合：训练集、验证集和测试集。在训练数据上训练模型，在验证数据上评估模型。一旦找到了最佳参数，就在测试数据上最后测试一次。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;为什么需要验证集&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　原因在于开发模型时总是需要调节模型配置，比如选择层数或每层大小［这叫作模型的超参数（hyperparameter），以便与模型参数（即权重）区分开］。这个调节过程需要使用模型在验证数据上的性能作为反馈信号。这个调节过程本质上就是一种学习：在某个参数空间中寻找良好的模型配置。因此，如果基于模型在验证集上的性能来调节模型配置，会很快导致模型在验证集上过拟合，即使你并没有在验证集上直接训练模型也会如此。&lt;br/&gt;　　造成这一现象的关键在于信息泄露（information leak）。每次基于模型在验证集上的性能来调节模型超参数，都会有一些关于验证数据的信息泄露到模型中。如果对每个参数只调节一次，那么泄露的信息很少，验证集仍然可以可靠地评估模型。但如果你多次重复这一过程（运行一次实验，在验证集上评估，然后据此修改模型），那么将会有越来越多的关于验证集的信息泄露到模型中。&lt;br/&gt;　　最后，你得到的模型在验证集上的性能非常好（人为造成的），因为这正是你优化的目的。你关心的是模型在全新数据上的性能，而不是在验证数据上的性能，因此你需要使用一个完全不同的、前所未见的数据集来评估模型，它就是测试集。你的模型一定不能读取与测试集有关的任何信息，既使间接读取也不行。如果基于测试集性能来调节模型，那么对泛化能力的衡量是不准确的。&lt;br/&gt;将数据划分为训练集、验证集和测试集可能看起来很简单，但如果可用数据很少，还有几种高级方法可以派上用场。&lt;/p&gt;
&lt;p&gt;我们先来介绍三种经典的评估方法：简单的留出验证、K 折验证，以及带有打乱数据的重复 K 折验证。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 简单的留出验证&lt;/strong&gt;&lt;br/&gt;留出一定比例的数据作为测试集。在剩余的数据上训练模型，然后在测试集上评估模型。&lt;br/&gt;如前所述，为了防止信息泄露，你不能基于测试集来调节模型，所以还应该保留一个验证集。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1224905/201812/1224905-20181212230212931-1190393639.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;留出验证的伪代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
1&lt;span&gt;、将原有数据集打乱顺序shuffle_data
&lt;/span&gt;2、将打乱的数据集的一部分（一般为10%-20%&lt;span&gt;）定义为验证集valify_data
&lt;/span&gt;3&lt;span&gt;、剩余的数据定义为训练数据train_data
&lt;/span&gt;4&lt;span&gt;、根据需求建模 model
&lt;/span&gt;5&lt;span&gt;、训练模型model.train(train_data)
&lt;/span&gt;6&lt;span&gt;、在验证集上评估模型model.evaluate(valify_data)
&lt;/span&gt;7&lt;span&gt;、调节模型
&lt;/span&gt;8、重复5、6&lt;span&gt;、7直到模型在验证集上表现良好
&lt;/span&gt;9、在测试集上测试模型
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这是最简单的评估方法，但有一个缺点：如果可用的数据很少，那么可能验证集和测试集包含的样本就太少，从而无法在统计学上代表数据。这个问题很容易发现：如果在划分数据前进行不同的随机打乱，最终得到的模型性能差别很大，那么就存在这个问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. K 折验证&lt;/strong&gt;&lt;br/&gt;　　K 折验证（K-fold validation）将数据划分为大小相同的 K 个分区。对于每个分区 i ，在剩余的 K-1 个分区上训练模型，然后在分区 i 上评估模型。最终分数等于 K 个分数的平均值。对于不同的训练集 - 测试集划分，如果模型性能的变化很大，那么这种方法很有用。与留出验证一样，这种方法也需要独立的验证集进行模型校正。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1224905/201812/1224905-20181212232128154-1976962001.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;伪代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;将原来的数据平均k份
根据需求建模 model
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(k)
    将第 i 份数据作为验证集，其他k&lt;/span&gt;-&lt;span&gt;1份数据作为训练集
    在训练集上训练模型
    在验证集上【】评估模型
在测试集上测试模型&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;数据量小的时候，k 可以设大一点，这样训练集占整体比例就比较大，不过同时训练的模型个数也增多。 &lt;br/&gt;数据量大的时候，k 可以设小一点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、带有打乱数据的重复 K 折验证&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　如果可用的数据相对较少，而你又需要尽可能精确地评估模型，那么可以选择带有打乱数据的重复 K 折验证（iterated K-fold validation with shuffling）。具体做法是多次使用 K 折验证，在每次将数据划分为 K 个分区之前都先将数据打乱。最终分数是多次 k 折交叉验证再求均值，例如：10 次 10 折交叉验证，以求更精确一点。注意，这种方法一共要训练和评估 P×K 个模型（P是重复次数），计算代价很大。&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;　　除此之外还有一种比较特殊的交叉验证方法，有人将其叫做&lt;strong&gt;Bootstrapping&lt;/strong&gt;。通过又放回的抽样，抽取与train_data相同数量的数据作为新的训练集。即在含有 m 个样本的数据集中，每次随机挑选一个样本，再放回到数据集中，再随机挑选一个样本，这样有放回地进行抽样 m 次，组成了新的数据集作为训练集。&lt;/p&gt;
&lt;p&gt;优点是训练集的样本总数和原数据集一样都是 m，并且仍有约 1/3 的数据不被训练而可以作为测试集。 &lt;br/&gt;缺点是这样产生的训练集的数据分布和原数据集的不一样了，会引入估计偏差。 &lt;/p&gt;

</description>
<pubDate>Wed, 12 Dec 2018 15:41:00 +0000</pubDate>
<dc:creator>左手十字</dc:creator>
<og:description>什么是评估机器学习模型 机器学习的目的是得到可以泛化（generalize）的模型，即在前所未见的数据上表现很好的模型，而过拟合则是核心难点。你只能控制可以观察的事情，所以能够可靠地衡量模型的泛化能力</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zuoshoushizi/p/10111722.html</dc:identifier>
</item>
<item>
<title>大数据学习-1   在阿里云上集成6台云服务器 - 蒙山一只鸽</title>
<link>http://www.cnblogs.com/SAM-CJM/p/10111653.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/SAM-CJM/p/10111653.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;一.为什么要大数据学习？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这是一个大数据的时代，一个企业只有掌握了大数据才能把握住市场的命脉，一个人掌握了大数据就可以比较轻松的向机器学习、人工智能等方向发展。所以我们有必要去掌握大数据的技术同时也关注大数据的发展趋势，不能裹足不前。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;二.关于本专题的学习&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 作为一个普通本科大学生，在校的大数据学习比较的“水”，普通大学嘛，大家都懂。在一个就是编程实战方向上的东西本来就该靠自学，而不是靠别人去教。我觉得大数据的学习是一个缓慢的过程，需要半年的时间去学习。我想在大二结束差不多就可以完成大数据最基本的学习了。（看看明年暑假能不能去个公司实习一下:-)）&lt;span&gt;&lt;strong&gt;因为这也是我也是第一次学习大数据，这一系列文章是我的学习笔记而不是我的工作经历总结，其中难免有部分错误，还望前辈们不啬赐教。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;三.在阿里云上安装hadoop，同时集成6台云主机&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 3.1&lt;/strong&gt;版本说明：1.Linux   centos7&lt;/p&gt;
&lt;p&gt;　　　　　       2.Java    jdk1.8&lt;/p&gt;
&lt;p&gt;　　　　           3.Hadoop  Hadoop2.7.3&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.2&lt;/strong&gt; 安装Java&lt;/p&gt;
&lt;p&gt;在这里我们使用的是Java 1.8，当然你也可以使用其他的版本，但是一定要是Linux版本的Java！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1433995/201812/1433995-20181212202748264-791030159.png&quot; alt=&quot;&quot;/&gt;我们下载的压缩包格式，下载到本地后通过winscp上传到阿里云上&lt;/p&gt;
&lt;p&gt;下载链接 &lt;a target=&quot;_blank&quot;&gt;https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html&lt;/a&gt; &lt;/p&gt;
&lt;p&gt; 我们在阿里云上的opt文件夹下创建Java文件夹和hadoop文件夹如图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1433995/201812/1433995-20181212203349413-190120302.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 我们将我们的Java压缩包放到Java文件夹中去。&lt;/p&gt;
&lt;p&gt; 然后进入该文件夹执行解压操作&lt;/p&gt;
&lt;p&gt; 进入该文件夹      &lt;strong&gt;cd /opt/java&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 解压操作   &lt;strong&gt;tar -zxvf jdk-8u 191-linux-x64.tar.gz&lt;/strong&gt;  (注意你自己的jdk版本号和你自己的文件名)&lt;/p&gt;
&lt;p&gt; 解压完成后会看见一个文件夹如下&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1433995/201812/1433995-20181212215945223-89239789.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来我们呢就要去配置文件了&lt;/p&gt;
&lt;p&gt;修改/etc/profile文件   使用命令符  &lt;strong&gt;vim  /etc/profile&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在文件的&lt;strong&gt;最后&lt;/strong&gt;加上&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;export JAVA_HOME=/opt/java/jdk1.8.0_191   （注意你自己的版本号）&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;export PATH=$JAVA_HOME/bin:$PATH&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;更改完后输入命令命令符 &lt;strong&gt;Java、&lt;/strong&gt; &lt;strong&gt;javac、java -version&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;出现下面的字符说明安装成功：&lt;/p&gt;
&lt;div readability=&quot;17&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1433995/201812/1433995-20181212221056589-850841451.png&quot; alt=&quot;&quot; width=&quot;416&quot; height=&quot;294&quot;/&gt;  &lt;img src=&quot;https://img2018.cnblogs.com/blog/1433995/201812/1433995-20181212221118669-1757228788.png&quot; alt=&quot;&quot; width=&quot;356&quot; height=&quot;297&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1433995/201812/1433995-20181212221144285-951813783.png&quot; alt=&quot;&quot; width=&quot;395&quot; height=&quot;81&quot;/&gt;&lt;p&gt;&lt;strong&gt;3.3&lt;/strong&gt;实现6个机子ssh免密码登录&lt;/p&gt;
&lt;p&gt;检查机器名称&lt;/p&gt;
输入命令符  &lt;strong&gt;hostname &lt;/strong&gt; 可以查看你们的机器名称，如图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1433995/201812/1433995-20181212221736274-662897986.png&quot; alt=&quot;&quot;/&gt;如果你没有改过你的hostname那么应该是一个乱码，那么我们使用命令来修改主机名称 &lt;strong&gt;hostname  hserver1&lt;/strong&gt;（1号一般为namenode）&lt;p&gt;其他的5台服务器也是分别为hserver2、hserver3、hserver4、hserver5、hserver6（这几个为datenode）&lt;/p&gt;
修改映射文件&lt;br/&gt;&lt;/div&gt;
&lt;p&gt; 输入命令符vim /etc/hosts 将所有的服务器的&lt;strong&gt;主机ip地址和他们的hostname相对应&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 如图：&lt;img src=&quot;https://img2018.cnblogs.com/blog/1433995/201812/1433995-20181212222547996-282631914.png&quot; alt=&quot;&quot; width=&quot;579&quot; height=&quot;185&quot;/&gt;&lt;/p&gt;
&lt;p&gt;修改完成后我们检查一下是否能够发送成功。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ping -c  3 hserver2 &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1433995/201812/1433995-20181212222921733-1203222914.png&quot; alt=&quot;&quot; width=&quot;497&quot; height=&quot;163&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样就说明成功了，当然剩下的5台服务器也测试后成功了。&lt;/p&gt;
&lt;p&gt;配置ssh文件&lt;/p&gt;
&lt;p&gt;输入命令  &lt;strong&gt;ssh-keygen  -t  rsa -P ''&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在过程中需要输入回车&lt;/p&gt;
&lt;p&gt;然后&lt;strong&gt;ls  /root/.ssh/ &lt;/strong&gt; 出现下图&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1433995/201812/1433995-20181212223502341-1819116277.png&quot; alt=&quot;&quot; width=&quot;445&quot; height=&quot;50&quot;/&gt;&lt;/p&gt;
&lt;p&gt;查看id_rsa.pub   &lt;strong&gt;vim  id_rsa.pub&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1433995/201812/1433995-20181212224403524-925069035.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们将所有主机中的id_rsa.pub 文件中的公匙复制到一个文件中&lt;span&gt;authorized_keys，然后将&lt;span&gt;authorized_keys&lt;/span&gt;放置到&lt;span&gt;/root/.ssh/&lt;/span&gt;文件夹下&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;查看&lt;span&gt;&lt;span&gt;authorized_keys   &lt;strong&gt;vim  &lt;span&gt;&lt;span&gt;authorized_keys&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt; 如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1433995/201812/1433995-20181212224311199-1898885327.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 测试是否ssh配置成功&lt;/p&gt;
&lt;p&gt; 依次检查&lt;strong&gt;ssh hserver2&lt;/strong&gt; 、3、4、5、6&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1433995/201812/1433995-20181212224611917-1424972583.png&quot; alt=&quot;&quot;/&gt;第一次输入一般会询问链接  输入yes&lt;/p&gt;
&lt;p&gt;测试完后一定要关闭链接否者你在本机上的命令会在那一台机子上执行，&lt;/p&gt;
&lt;p&gt;命令符 &lt;strong&gt;exit&lt;/strong&gt; 退出&lt;/p&gt;
&lt;p&gt; 3.4安装hadoop&lt;/p&gt;
&lt;p&gt;下载hadoop到本地然后上传到阿里云上，解压。资源网上都有可以去找 ，我这里使用的Hadoop版本为2.7.3下面解压后所有的路径你们根据你们的版本去修改。&lt;/p&gt;
&lt;p&gt;我们的将Hadoop的压缩包放到/opt/hadoop/文件夹下：&lt;/p&gt;
&lt;p&gt;然后我们进入该文件夹 &lt;strong&gt;cd  /opt/hadoop/&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;接着执行   &lt;strong&gt;tar -xvf hadoop-2.7.3.tar.gz&lt;/strong&gt; （注意你们的文件版本名）解压文件&lt;/p&gt;
&lt;p&gt;解压完成后你会的得到一个文件夹&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1433995/201812/1433995-20181212225517506-120794880.png&quot; alt=&quot;&quot; width=&quot;420&quot; height=&quot;128&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后创建如下几个文件夹&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;mkdir /root/hadoop&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;mkdir /root/hadoop/tmp&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;mkdir /root/hadoop/var&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;mkdir /root/hadoop/dfs&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;mkdir /root/hadoop/dfs/name&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;mkdir /root/hadoop/dfs/data&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;修改配置文件：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt; vim   /opt/hadoop/hadoop-&lt;span&gt;2.7.3&lt;/span&gt;/etc/hadoop/core-site.xml&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在&lt;span&gt;&amp;lt;configuration&amp;gt;节点中写入：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;property&amp;gt;&lt;/p&gt;&lt;p&gt;        &amp;lt;name&amp;gt;hadoop.tmp.dir&amp;lt;/name&amp;gt;&lt;/p&gt;&lt;p&gt;        &amp;lt;value&amp;gt;/root/hadoop/tmp&amp;lt;/value&amp;gt;&lt;/p&gt;&lt;p&gt;        &amp;lt;description&amp;gt;Abase for other temporary directories.&amp;lt;/description&amp;gt;&lt;/p&gt;&lt;p&gt;   &amp;lt;/property&amp;gt;&lt;/p&gt;&lt;p&gt;   &amp;lt;property&amp;gt;&lt;/p&gt;&lt;p&gt;        &amp;lt;name&amp;gt;fs.default.name&amp;lt;/name&amp;gt;&lt;/p&gt;&lt;p&gt;        &amp;lt;value&amp;gt;hdfs://&lt;strong&gt;&lt;span&gt;hserver1&lt;/span&gt;&lt;/strong&gt;:9000&amp;lt;/value&amp;gt;&lt;/p&gt;&lt;p&gt;   &amp;lt;/property&amp;gt;&lt;/p&gt;&lt;p&gt;&amp;lt;/configuration&amp;gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;注意如果你的namenode的hostname不为hserver1你要改成你的namenode的hostname&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;vim &lt;span&gt;/opt/hadoop/hadoop-&lt;span&gt;2.7.3&lt;/span&gt;/etc/hadoop/hadoop-env.sh&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt; 将export   JAVA_HOME=${JAVA_HOME}&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 修改为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; export   JAVA_HOME=/opt/java/jdk1.8.0_191   (注意你自己的Java版本号)&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;vim /opt/hadoop/hadoop-&lt;span&gt;2.7.3&lt;/span&gt;/etc/hadoop/hdfs-site.xml&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在&lt;span&gt;&amp;lt;configuration&amp;gt;节点中写入：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &amp;lt;property&amp;gt;&lt;/p&gt;&lt;p&gt;   &amp;lt;name&amp;gt;dfs.name.dir&amp;lt;/name&amp;gt;&lt;/p&gt;&lt;p&gt;   &amp;lt;value&amp;gt;/root/hadoop/dfs/name&amp;lt;/value&amp;gt;&lt;/p&gt;&lt;p&gt;   &amp;lt;description&amp;gt;Path on the local filesystem where theNameNode stores the namespace and transactions logs persistently.&amp;lt;/description&amp;gt;&lt;/p&gt;&lt;p&gt;&amp;lt;/property&amp;gt;&lt;/p&gt;&lt;p&gt;&amp;lt;property&amp;gt;&lt;/p&gt;&lt;p&gt;   &amp;lt;name&amp;gt;dfs.data.dir&amp;lt;/name&amp;gt;&lt;/p&gt;&lt;p&gt;   &amp;lt;value&amp;gt;/root/hadoop/dfs/data&amp;lt;/value&amp;gt;&lt;/p&gt;&lt;p&gt;   &amp;lt;description&amp;gt;Comma separated list of paths on the localfilesystem of a DataNode where it should store its blocks.&amp;lt;/description&amp;gt;&lt;/p&gt;&lt;p&gt;&amp;lt;/property&amp;gt;&lt;/p&gt;&lt;p&gt;&amp;lt;property&amp;gt;&lt;/p&gt;&lt;p&gt;   &amp;lt;name&amp;gt;dfs.replication&amp;lt;/name&amp;gt;&lt;/p&gt;&lt;p&gt;   &amp;lt;value&amp;gt;2&amp;lt;/value&amp;gt;&lt;/p&gt;&lt;p&gt;&amp;lt;/property&amp;gt;&lt;/p&gt;&lt;p&gt;&amp;lt;property&amp;gt;&lt;/p&gt;&lt;p&gt;      &amp;lt;name&amp;gt;dfs.permissions&amp;lt;/name&amp;gt;&lt;/p&gt;&lt;p&gt;      &amp;lt;value&amp;gt;false&amp;lt;/value&amp;gt;&lt;/p&gt;&lt;p&gt;      &amp;lt;description&amp;gt;need not permissions&amp;lt;/description&amp;gt;&lt;/p&gt;&lt;p&gt;&amp;lt;/property&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在该版本中，有一个名为mapred-site.xml.template的文件，复制该文件，然后改名为mapred-site.xml，命令是：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;code class=&quot;language-cpp&quot;&gt;cp /opt/hadoop/hadoop&lt;span class=&quot;hljs-number&quot;&gt;-2.8&lt;span class=&quot;hljs-number&quot;&gt;.0/etc/hadoop/mapred-site.xml.&lt;span class=&quot;hljs-keyword&quot;&gt;template /opt/hadoop/hadoop&lt;span class=&quot;hljs-number&quot;&gt;-2.7&lt;span class=&quot;hljs-number&quot;&gt;.3/etc/hadoop/mapred-site.xml&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;vim  &lt;span&gt;/opt/hadoop/hadoop-2.7.3/etc/hadoop/mapred-site.xml&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;在&amp;lt;configuration&amp;gt;节点内加入配置:&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &amp;lt;property&amp;gt;&lt;/p&gt;&lt;p&gt;   &amp;lt;name&amp;gt;mapred.job.tracker&amp;lt;/name&amp;gt;&lt;/p&gt;&lt;p&gt;   &amp;lt;value&amp;gt;&lt;strong&gt;&lt;span&gt;hserver1&lt;/span&gt;&lt;/strong&gt;:49001&amp;lt;/value&amp;gt;&lt;/p&gt;&lt;p&gt;&amp;lt;/property&amp;gt;&lt;/p&gt;&lt;p&gt;&amp;lt;property&amp;gt;&lt;/p&gt;&lt;p&gt;      &amp;lt;name&amp;gt;mapred.local.dir&amp;lt;/name&amp;gt;&lt;/p&gt;&lt;p&gt;       &amp;lt;value&amp;gt;/root/hadoop/var&amp;lt;/value&amp;gt;&lt;/p&gt;&lt;p&gt;&amp;lt;/property&amp;gt;&lt;/p&gt;&lt;p&gt;&amp;lt;property&amp;gt;&lt;/p&gt;&lt;p&gt;       &amp;lt;name&amp;gt;mapreduce.framework.name&amp;lt;/name&amp;gt;&lt;/p&gt;&lt;p&gt;       &amp;lt;value&amp;gt;yarn&amp;lt;/value&amp;gt;&lt;/p&gt;&lt;p&gt;&amp;lt;/property&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;vim /opt/hadoop/hadoop-2.7.3/etc/hadoop/slaves&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;加入你的datenode的hostname&lt;/p&gt;
&lt;p&gt;如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1433995/201812/1433995-20181212230928813-2002612534.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt; vim  &lt;span&gt;/opt/hadoop/hadoop-2.7.3/etc/hadoop/yarn-site.xml&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;在&amp;lt;configuration&amp;gt;节点内加入配置&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &amp;lt;property&amp;gt;&lt;/p&gt;&lt;p&gt;        &amp;lt;name&amp;gt;yarn.resourcemanager.hostname&amp;lt;/name&amp;gt;&lt;/p&gt;&lt;p&gt;        &amp;lt;value&amp;gt;&lt;strong&gt;&lt;span&gt;hserver1&lt;/span&gt;&lt;/strong&gt;&amp;lt;/value&amp;gt;&lt;/p&gt;&lt;p&gt;   &amp;lt;/property&amp;gt;&lt;/p&gt;&lt;p&gt;   &amp;lt;property&amp;gt;&lt;/p&gt;&lt;p&gt;        &amp;lt;description&amp;gt;The address of the applications manager interface in the RM.&amp;lt;/description&amp;gt;&lt;/p&gt;&lt;p&gt;        &amp;lt;name&amp;gt;yarn.resourcemanager.address&amp;lt;/name&amp;gt;&lt;/p&gt;&lt;p&gt;        &amp;lt;value&amp;gt;0.0.0.0:8032&amp;lt;/value&amp;gt;&lt;/p&gt;&lt;p&gt;   &amp;lt;/property&amp;gt;&lt;/p&gt;&lt;p&gt;   &amp;lt;property&amp;gt;&lt;/p&gt;&lt;p&gt;        &amp;lt;description&amp;gt;The address of the scheduler interface.&amp;lt;/description&amp;gt;&lt;/p&gt;&lt;p&gt;        &amp;lt;name&amp;gt;yarn.resourcemanager.scheduler.address&amp;lt;/name&amp;gt;&lt;/p&gt;&lt;p&gt;        &amp;lt;value&amp;gt;0.0.0.0:8030&amp;lt;/value&amp;gt;&lt;/p&gt;&lt;p&gt;   &amp;lt;/property&amp;gt;&lt;/p&gt;&lt;p&gt;   &amp;lt;property&amp;gt;&lt;/p&gt;&lt;p&gt;        &amp;lt;description&amp;gt;The http address of the RM web application.&amp;lt;/description&amp;gt;&lt;/p&gt;&lt;p&gt;        &amp;lt;name&amp;gt;yarn.resourcemanager.webapp.address&amp;lt;/name&amp;gt;&lt;/p&gt;&lt;p&gt;        &amp;lt;value&amp;gt;0.0.0.0:8088&amp;lt;/value&amp;gt;&lt;/p&gt;&lt;p&gt;   &amp;lt;/property&amp;gt;&lt;/p&gt;&lt;p&gt;   &amp;lt;property&amp;gt;&lt;/p&gt;&lt;p&gt;        &amp;lt;description&amp;gt;The https adddress of the RM web application.&amp;lt;/description&amp;gt;&lt;/p&gt;&lt;p&gt;        &amp;lt;name&amp;gt;yarn.resourcemanager.webapp.https.address&amp;lt;/name&amp;gt;&lt;/p&gt;&lt;p&gt;        &amp;lt;value&amp;gt;0.0.0.0:8090&amp;lt;/value&amp;gt;&lt;/p&gt;&lt;p&gt;   &amp;lt;/property&amp;gt;&lt;/p&gt;&lt;p&gt;   &amp;lt;property&amp;gt;&lt;/p&gt;&lt;p&gt;        &amp;lt;name&amp;gt;yarn.resourcemanager.resource-tracker.address&amp;lt;/name&amp;gt;&lt;/p&gt;&lt;p&gt;        &amp;lt;value&amp;gt;0.0.0.0:8031&amp;lt;/value&amp;gt;&lt;/p&gt;&lt;p&gt;   &amp;lt;/property&amp;gt;&lt;/p&gt;&lt;p&gt;   &amp;lt;property&amp;gt;&lt;/p&gt;&lt;p&gt;        &amp;lt;description&amp;gt;The address of the RM admin interface.&amp;lt;/description&amp;gt;&lt;/p&gt;&lt;p&gt;        &amp;lt;name&amp;gt;yarn.resourcemanager.admin.address&amp;lt;/name&amp;gt;&lt;/p&gt;&lt;p&gt;        &amp;lt;value&amp;gt;0.0.0.0:8033&amp;lt;/value&amp;gt;&lt;/p&gt;&lt;p&gt;   &amp;lt;/property&amp;gt;&lt;/p&gt;&lt;p&gt;   &amp;lt;property&amp;gt;&lt;/p&gt;&lt;p&gt;        &amp;lt;name&amp;gt;yarn.nodemanager.aux-services&amp;lt;/name&amp;gt;&lt;/p&gt;&lt;p&gt;        &amp;lt;value&amp;gt;mapreduce_shuffle&amp;lt;/value&amp;gt;&lt;/p&gt;&lt;p&gt;   &amp;lt;/property&amp;gt;&lt;/p&gt;&lt;p&gt;   &amp;lt;property&amp;gt;&lt;/p&gt;&lt;p&gt;        &amp;lt;name&amp;gt;yarn.scheduler.maximum-allocation-mb&amp;lt;/name&amp;gt;&lt;/p&gt;&lt;p&gt;        &amp;lt;value&amp;gt;2048&amp;lt;/value&amp;gt;&lt;/p&gt;&lt;p&gt;        &amp;lt;discription&amp;gt;每个节点可用内存,单位MB,默认8182MB&amp;lt;/discription&amp;gt;&lt;/p&gt;&lt;p&gt;   &amp;lt;/property&amp;gt;&lt;/p&gt;&lt;p&gt;   &amp;lt;property&amp;gt;&lt;/p&gt;&lt;p&gt;        &amp;lt;name&amp;gt;yarn.nodemanager.vmem-pmem-ratio&amp;lt;/name&amp;gt;&lt;/p&gt;&lt;p&gt;        &amp;lt;value&amp;gt;2.1&amp;lt;/value&amp;gt;&lt;/p&gt;&lt;p&gt;   &amp;lt;/property&amp;gt;&lt;/p&gt;&lt;p&gt;   &amp;lt;property&amp;gt;&lt;/p&gt;&lt;p&gt;        &amp;lt;name&amp;gt;yarn.nodemanager.resource.memory-mb&amp;lt;/name&amp;gt;&lt;/p&gt;&lt;p&gt;        &amp;lt;value&amp;gt;2048&amp;lt;/value&amp;gt;&lt;/p&gt;&lt;p&gt;&amp;lt;/property&amp;gt;&lt;/p&gt;&lt;p&gt;   &amp;lt;property&amp;gt;&lt;/p&gt;&lt;p&gt;        &amp;lt;name&amp;gt;yarn.nodemanager.vmem-check-enabled&amp;lt;/name&amp;gt;&lt;/p&gt;&lt;p&gt;        &amp;lt;value&amp;gt;false&amp;lt;/value&amp;gt;&lt;/p&gt;&lt;p&gt;&amp;lt;/property&amp;gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;四.初始化hadoop和执行hadoop&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;cd   /opt/hadoop/hadoop-2.7.3/bin&lt;/span&gt;&lt;/strong&gt;   进入文件夹&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; ./hadoop  namenode  -format       &lt;/span&gt;&lt;/strong&gt; &lt;span&gt;初始化脚本&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;格式化成功后，可以在看到在/root/hadoop/dfs/name/目录多了一个current目录，而且该目录内有一系列文件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在namenode上去执行启动命令&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;cd    /opt/hadoop/hadoop-2.8.0/sbin   （进入文件夹）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; ./start-all.sh    （执行命令）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;过程中所有询问输入yes&lt;/p&gt;
&lt;p&gt;五.测试hadoop是否成功&lt;/p&gt;
&lt;p&gt;namenode的地址为39.105.201.218&lt;/p&gt;
&lt;p&gt;关闭防火墙&lt;span&gt;      &lt;span&gt;&lt;strong&gt;    &lt;span&gt;systemctl   stop   firewalld.service 后&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;打开：&lt;/p&gt;
&lt;p&gt;http://39.105.201.218:50090/（HDFS管理界面）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1433995/201812/1433995-20181212231659616-451790671.png&quot; alt=&quot;&quot; width=&quot;746&quot; height=&quot;477&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;http://39.105.201.218:8088/   (cluster页面)&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1433995/201812/1433995-20181212231722247-2119338862.png&quot; alt=&quot;&quot; width=&quot;876&quot; height=&quot;332&quot;/&gt;&lt;/p&gt;
&lt;p&gt;参考文章    &lt;a href=&quot;https://blog.csdn.net/pucao_cug/article/details/71698903&quot; target=&quot;_blank&quot;&gt;https://blog.csdn.net/pucao_cug/article/details/71698903&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 12 Dec 2018 15:19:00 +0000</pubDate>
<dc:creator>蒙山一只鸽</dc:creator>
<og:description>一.为什么要大数据学习？ 这是一个大数据的时代，一个企业只有掌握了大数据才能把握住市场的命脉，一个人掌握了大数据就可以比较轻松的向机器学习、人工智能等方向发展。所以我们有必要去掌握大数据的技术同时也关</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/SAM-CJM/p/10111653.html</dc:identifier>
</item>
<item>
<title>python多任务-线程 - 张风闲</title>
<link>http://www.cnblogs.com/zhangfengxian/p/python-thread.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangfengxian/p/python-thread.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;
&lt;h2 id=&quot;多任务的概念&quot;&gt;多任务的概念&lt;/h2&gt;
&lt;p&gt;什么叫“多任务”呢？简单地说，就是操作系统可以同时运行多个任务。打个比方，你一边在用浏览器上网，一边在听MP3，一边在用Word赶作业，这就是多任务，至少同时有3个任务正在运行。还有很多任务悄悄地在后台同时运行着，只是桌面上没有显示而已。&lt;/p&gt;
&lt;p&gt;现在，多核CPU已经非常普及了，但是，即使过去的单核CPU，也可以执行多任务。由于CPU执行代码都是顺序执行的，那么，单核CPU是怎么执行多任务的呢？&lt;/p&gt;
&lt;p&gt;答案就是操作系统轮流让各个任务交替执行，任务1执行0.01秒，切换到任务2，任务2执行0.01秒，再切换到任务3，执行0.01秒……这样反复执行下去。表面上看，每个任务都是交替执行的，但是，由于CPU的执行速度实在是太快了，我们感觉就像所有任务都在同时执行一样。&lt;/p&gt;
&lt;p&gt;真正的并行执行多任务只能在多核CPU上实现，但是，由于任务数量远远多于CPU的核心数量，所以，操作系统也会自动把很多任务轮流调度到每个核心上执行。&lt;/p&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;并发：指的是任务数多余cpu核数，通过操作系统的各种任务调度算法，实现用多个任务“一起”执行（实际上总有一些任务不在执行，因为切换任务的速度相当快，看上去一起执行而已）&lt;/li&gt;
&lt;li&gt;并行：指的是任务数小于等于cpu核数，即任务真的是一起执行的&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;线程基础&quot;&gt;线程基础&lt;/h2&gt;
&lt;p&gt;python的thread模块是比较底层的模块，python的threading模块是对thread做了一些包装的，可以更加方便的被使用&lt;/p&gt;
&lt;h3 id=&quot;单线程执行&quot;&gt;单线程执行&lt;/h3&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import time


def test():
        print(&quot;test...&quot;)
        time.sleep(1)


if __name__ == '__main__':

        for i in range(5):
                test()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行效果：程序在控制台每隔一秒打印&lt;code&gt;test...&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;多线程执行&quot;&gt;多线程执行&lt;/h3&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import time
import threading

def test():
        print(&quot;test...&quot;)
        time.sleep(1)


if __name__ == '__main__':

        for i in range(5):
                t = threading.Thread(target=test)
                t.start() # 启动线程
    &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行效果：程序在控制台一下子输出五行&lt;code&gt;test...&lt;/code&gt;，等待1秒左右结束&lt;/p&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;可以明显看出使用了多线程并发的操作，花费时间要短很多&lt;/li&gt;
&lt;li&gt;当调用&lt;code&gt;start()&lt;/code&gt;时，才会真正的创建线程，并且开始执行&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;主线程会等待所有子线程结束后才结束&quot;&gt;主线程会等待所有子线程结束后才结束&lt;/h3&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import time
import threading


def playPhone():

        print('玩手机...')
        time.sleep(1)


def eat():

        print(&quot;吃东西...&quot;)
        time.sleep(1)


if __name__ == '__main__':

        print(&quot;--开始--&quot;)

        t1 = threading.Thread(target=playPhone)
        t1.start()

        t2 = threading.Thread(target=eat)
        t2.start()

        print('--执行结束')
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行效果：主线程阻塞1秒左右后程序结束，说明主线程在等待其他线程执行完毕。&lt;/p&gt;
&lt;h3 id=&quot;查看线程数量&quot;&gt;查看线程数量&lt;/h3&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;          print('玩手机...')
                time.sleep(1)


def eat():

        for i in range(10):
                print(&quot;吃东西...&quot;)
                time.sleep(1)


if __name__ == '__main__':

        print(&quot;--开始--&quot;)

        t1 = threading.Thread(target=playPhone)
        t1.start()

        t2 = threading.Thread(target=eat)
        t2.start()
    
        # 查看正在执行的线程数量
        while True:
                length = len(threading.enumerate())
                print(&quot;当前运行的线程数量：%d&quot; % length)
                print(&quot;这些线程是：%s&quot; % str(threading.enumerate()))
    
    
                if length == 1:
                        break
    
                time.sleep(0.5)    

        print('--执行结束')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在python中，调用&lt;code&gt;threading.enumerate()&lt;/code&gt;能获取当前正在运行的所有线程，返回值是一个list，调用&lt;code&gt;length()&lt;/code&gt;函数并传入该list对象就获取到当前运行线程的数量。&lt;/p&gt;
&lt;h2 id=&quot;线程-注意点&quot;&gt;线程-注意点&lt;/h2&gt;
&lt;h3 id=&quot;线程执行代码的封装&quot;&gt;线程执行代码的封装&lt;/h3&gt;
&lt;p&gt;通过上一篇，能够看出，通过使用threading模块能完成多任务的程序开发，为了让每个线程的封装性更完美，所以使用threading模块时，往往会定义一个新的子类class，只要继承&lt;code&gt;threading.Thread&lt;/code&gt;就可以了，然后重写&lt;code&gt;run&lt;/code&gt;方法。&lt;/p&gt;
&lt;p&gt;示例如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import time
import threading


class MyThread(threading.Thread):

        def run(self):
                for i in range(5):
                        time.sleep(1)
                        print(&quot;我是%s@%d&quot; % (self.name, i)) 


if __name__ == &quot;__main__&quot;:
        mt = MyThread()
        mt.start()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果如下：&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;我是Thread-1@0
我是Thread-1@1
我是Thread-1@2
我是Thread-1@3
我是Thread-1@4&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;python的threading.Thread类有一个run方法，用于定义线程的功能函数，可以在自己的线程类中覆盖该方法。而创建自己的线程实例后，通过Thread类的start方法，可以启动该线程，交给python虚拟机进行调度，当该线程获得执行的机会时，就会调用run方法执行线程。&lt;/p&gt;
&lt;h3 id=&quot;线程的执行顺序&quot;&gt;线程的执行顺序&lt;/h3&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;mport time
import threading


class MyThread(threading.Thread):

        def run(self):
                for i in range(5):
                        time.sleep(1)
                        print(&quot;我是%s@%d&quot; % (self.name, i)) 


if __name__ == &quot;__main__&quot;:
    
        for i in range(5):
                mt = MyThread()
                mt.start()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果(运行的结果可能不一样，但是大体是一致的)：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;我是Thread-5@0
我是Thread-2@0
我是Thread-3@0
我是Thread-4@0
我是Thread-1@0
我是Thread-3@1
我是Thread-4@1
我是Thread-2@1
我是Thread-5@1
我是Thread-1@1
我是Thread-3@2
我是Thread-4@2
我是Thread-2@2
我是Thread-5@2
我是Thread-1@2
我是Thread-3@3
我是Thread-4@3
我是Thread-2@3
我是Thread-5@3
我是Thread-1@3
我是Thread-3@4
我是Thread-4@4
我是Thread-5@4
我是Thread-2@4
我是Thread-1@4&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从代码和执行结果我们可以看出，多线程程序的执行顺序是不确定的。当执行到sleep语句时，线程将被阻塞（Blocked），到sleep结束后，线程进入就绪（Runnable）状态，等待调度。而线程调度将自行选择一个线程执行。上面的代码中只能保证每个线程都运行完整个run函数，但是线程的启动顺序、run函数中每次循环的执行顺序都不能确定。&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;每个线程默认有一个名字，尽管上面的例子中没有指定线程对象的name，但是python会自动为线程指定一个名字。&lt;/li&gt;
&lt;li&gt;当线程的run()方法结束时该线程完成。&lt;/li&gt;
&lt;li&gt;无法控制线程调度程序，但可以通过别的方式来影响线程调度的方式。&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Wed, 12 Dec 2018 14:31:00 +0000</pubDate>
<dc:creator>张风闲</dc:creator>
<og:description>[TOC] 多任务的概念 什么叫“多任务”呢？简单地说，就是操作系统可以同时运行多个任务。打个比方，你一边在用浏览器上网，一边在听MP3，一边在用Word赶作业，这就是多任务，至少同时有3个任务正在运</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhangfengxian/p/python-thread.html</dc:identifier>
</item>
<item>
<title>.net core i上 K8S(四).netcore程序的pod管理，重启策略与健康检查 - 老六代码</title>
<link>http://www.cnblogs.com/chenyishi/p/10111368.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenyishi/p/10111368.html</guid>
<description>&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/chenyishi/p/10094923.html&quot; target=&quot;_blank&quot;&gt;上一章&lt;/a&gt;我们已经通过yaml文件将.netcore程序跑起来了，但还有一下细节问题可以分享给大家。&lt;/p&gt;
&lt;h2&gt;1.pod管理&lt;/h2&gt;
&lt;h5&gt;1.1创建pod&lt;/h5&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
kubectl create -f netcore-pod.yaml
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;我们创建一个netcore-pod.yaml文件，内容如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;apiVersion: v1
kind: Pod　　　　　　　　　　#指明类型
metadata: 
  name: netcore&lt;/span&gt;-&lt;span&gt;pod
  labels:
    app: netcorepod
spec:
  containers:
  &lt;/span&gt;-&lt;span&gt; name: netcorepod
    image: chenyishi&lt;/span&gt;/&lt;span&gt;webdocker_s_provider
    ports:
    &lt;/span&gt;- containerPort: &lt;span&gt;1000&lt;/span&gt;
    &lt;span&gt;env&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;-&lt;span&gt; name: serverport
      value: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1000&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h5&gt;1.2查看pod是否创建成功&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1033233/201812/1033233-20181212213337402-1983745976.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h5&gt;1.3查看pod描述&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1033233/201812/1033233-20181212213651369-2063877634.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h5&gt;1.4替换pod&lt;/h5&gt;
&lt;p&gt;&lt;span&gt;先修改netcore-pod.yaml，name改成netcorepod1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1033233/201812/1033233-20181212213913039-1193118325.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;再执行替换命令&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
kubectl replace -f netcore-pod.yaml --force
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1033233/201812/1033233-20181212214014533-1842649875.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们可以看到，是先删除旧的，再替换的。&lt;/span&gt;&lt;/p&gt;
&lt;h5&gt;1.5删除pod&lt;/h5&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
 kubectl delete -f netcore-pod.yaml
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1033233/201812/1033233-20181212214220658-1832595545.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;2.重启策略&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;k8s有三种重启策略Always（总是重启，默认），OnFailue（错误时重启），Never（从不），下面我们来修改netcore-pod.yaml配置&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;apiVersion: v1
kind: Pod
metadata: 
  name: netcore&lt;/span&gt;-&lt;span&gt;pod
  labels:
    app: netcorepod
spec:
  containers:
  &lt;/span&gt;-&lt;span&gt; name: netcorepod
    image: chenyishi&lt;/span&gt;/&lt;span&gt;webdocker_s_provider
    ports:
    &lt;/span&gt;- containerPort: &lt;span&gt;1000&lt;/span&gt;
    &lt;span&gt;env&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;-&lt;span&gt; name: serverport
      value: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1000&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
  restartPolicy: OnFailure　　　　　　#策略&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;然后create&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
kubectl create -f netcore-pod.yaml  
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;我们手动制造一个异常，去Node节点查询并kill掉进程dotnet&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1033233/201812/1033233-20181212214909490-526897226.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;kill&lt;/span&gt; -&lt;span&gt;9&lt;/span&gt; &lt;span&gt;82043&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;然后回到master节点，查看pod信息&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1033233/201812/1033233-20181212215106952-316647707.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们可以看到重启次数已经从0变成1了，说明我门的重启策略发挥作用了，大家可以多kill几次，这个数字会递增。另外两种策略大家也可以试一下&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;3.健康检查&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;k8s为我们提供了对pod的健康检查，我们可以查看一下支持哪些&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1033233/201812/1033233-20181212220508184-714343569.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里我们使用httpGet测试一下，修改配置如下&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1033233/201812/1033233-20181212220645358-2142728816.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们使用一个存在的接口/api/values/1测试，创建pod，并查看信息&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1033233/201812/1033233-20181212220825919-721864546.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;策略已生效，我们重新修改一下，改成一个不存在的接口&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1033233/201812/1033233-20181212220950911-40047223.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后replace掉旧的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1033233/201812/1033233-20181212221047768-466582806.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后查看信息&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1033233/201812/1033233-20181212221140475-2136845809.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们发现已经出发了健康检查策略，在不停重启，restart count再增加，Events事件信息也在增加。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;4.进入容器&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
kubectl exec pod/netcore-pod -it bash
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;至此，我们.netcore程序的pod管理，重启策略与健康检查分享完了。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 12 Dec 2018 14:15:00 +0000</pubDate>
<dc:creator>老六代码</dc:creator>
<og:description>上一章我们已经通过yaml文件将.netcore程序跑起来了，但还有一下细节问题可以分享给大家。 1.pod管理 我们创建一个netcore-pod.yaml文件，内容如下： 先修改netcore-p</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenyishi/p/10111368.html</dc:identifier>
</item>
<item>
<title>ffmpeg滤波格式协商 - TaigaComplex</title>
<link>http://www.cnblogs.com/TaigaCon/p/10111326.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/TaigaCon/p/10111326.html</guid>
<description>&lt;p&gt;ffmpeg的中滤波器是以帧为原料来进行滤波的，那么自然地就会对帧的格式有所要求，可以说如果滤波器不知道帧的格式，就无法对帧进行处理。在进行视频滤波时，滤波格式指的是视频的像素格式；在进行音频滤波时，滤波格式包括音频采样格式，采样率以及通道数目。&lt;/p&gt;


&lt;p&gt;滤波器可能只支持某一种帧格式，也有可能对所有的帧格式都支持，因此在执行滤波操作之前，有必要对滤波过程中的各个滤波器所支持的格式进行协商。&lt;/p&gt;
&lt;p&gt;相邻的两个滤波实例之间是由AVFilterLink来连接的，因此AVFilterLink也承担了协商相邻两个滤波实例的滤波格式的任务。AVFilterLink的结构体中与滤波格式相关如下的变量如下：&lt;/p&gt;
&lt;pre class=&quot;brush: js; auto-links: true; collapse: false; first-line: 1; gutter: true; html-script: false; light: false; ruler: false; smart-tabs: true; tab-size: 4; toolbar: true;&quot;&gt;
struct AVFilterLink {
    /*format negotiation valuables*/
    uint64_t channel_layout;
    int sample_rate;
    int format;

    AVFilterFormats *in_formats;
    AVFilterFormats *out_formats;
    AVFilterFormats  *in_samplerates;
    AVFilterFormats *out_samplerates;
    struct AVFilterChannelLayouts  *in_channel_layouts;
    struct AVFilterChannelLayouts *out_channel_layouts;
}
&lt;/pre&gt;
&lt;p&gt;其中，in_formats/in_samplerates/in_channel_layouts、out_formats/out_samplerates/out_channel_layouts分别为当前Link输入端滤波器支持的输出滤波格式以及输出端滤波器支持的输入滤波格式，以Link的视点来说，分别就是可能的输入（所以变量被命名为in）格式以及可能的输出格式（所以变量被命名为out）。而format/sample_rate/channel_layout就是经过协商后得出唯一的格式。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/421096/201812/421096-20181212220653741-598601644.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/421096/201812/421096-20181212220654510-954875747.png&quot; alt=&quot;image&quot; width=&quot;350&quot; height=&quot;138&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;



&lt;p&gt;滤波格式的协商分为以下几个步骤：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;设置所有AVFilterLink上的格式列表&lt;/li&gt;
&lt;li&gt;如果AVFilterLink的输入输出格式列表中有相同的格式，则提取相同格式作为新的输入以及输出格式&lt;/li&gt;
&lt;li&gt;否则表明需要进行格式转换&lt;/li&gt;
&lt;li&gt;提取合并后的格式列表中的某个格式作为最终格式&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;设置格式列表&lt;/h4&gt;
&lt;p&gt;滤波格式的协商是在AVFilterLink上执行的，因此滤波器需要向AVFilterLink表明自己所支持的输入以及输出格式，即由AVFilter来设置它周围的AVFilterLink上的格式列表。这个设置的操作是由AVFilter内的query_formats函数来实现的。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/421096/201812/421096-20181212220654852-1683305644.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/421096/201812/421096-20181212220655242-1736492670.png&quot; alt=&quot;image&quot; width=&quot;400&quot; height=&quot;216&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;query_formats是AVFilter中的一个回调函数，如果某个滤波器对输入以及输出格式有要求或者限制，则需要通过query_formats来设置输入link的out_formats以及输出link的in_formats。如果滤波器不实现query_formats，则表明该滤波器的输入输出默认支持所有格式。&lt;/p&gt;
&lt;pre class=&quot;brush: js; auto-links: true; collapse: false; first-line: 1; gutter: true; html-script: false; light: false; ruler: false; smart-tabs: true; tab-size: 4; toolbar: true;&quot;&gt;
    for (i = 0; i &amp;lt; graph-&amp;gt;nb_filters; i++) {
        AVFilterContext *f = graph-&amp;gt;filters[i];
        if (formats_declared(f))
            continue;
        if (f-&amp;gt;filter-&amp;gt;query_formats)
            ret = filter_query_formats(f);
        else
            ret = ff_default_query_formats(f);
        if (ret &amp;lt; 0 &amp;amp;&amp;amp; ret != AVERROR(EAGAIN))
            return ret;
        /* note: EAGAIN could indicate a partial success, not counted yet */
        count_queried += ret &amp;gt;= 0;
    }
&lt;/pre&gt;

&lt;h4&gt;AVFilterLink的格式合并&lt;/h4&gt;
&lt;p&gt;在设置完graph上所有link的in_formats以及out_formats后，就需要提取每个link上in_formats与out_formats的共同formats，我们称这一步骤为合并（merge）。&lt;/p&gt;
&lt;p&gt;在讨论怎么merge formats之前，我们需要先了解AVFilterFormats这一结构体。AVFilterFormats就是我们前文所说的格式列表，定义如下：&lt;/p&gt;
&lt;pre class=&quot;brush: js; auto-links: true; collapse: false; first-line: 1; gutter: true; html-script: false; light: false; ruler: false; smart-tabs: true; tab-size: 4; toolbar: true;&quot;&gt;
struct AVFilterFormats {
    unsigned nb_formats;        ///&amp;lt; number of formats
    int *formats;               ///&amp;lt; list of media formats

    unsigned refcount;          ///&amp;lt; number of references to this list
    struct AVFilterFormats ***refs; ///&amp;lt; references to this list
};
&lt;/pre&gt;
&lt;p&gt;nb_formats是列表中format的数目；formats是指向format列表的指针；refcount代表本列表被引用的次数；refs指向一个列表，该列表中存放的是引用了本列表的地方的地址。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/421096/201812/421096-20181212220655566-1398332039.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/421096/201812/421096-20181212220655882-1190086376.png&quot; alt=&quot;image&quot; width=&quot;400&quot; height=&quot;175&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这里的合并，是要从AVFilterLink的in_formats以及out_formats中挑出相同的format，然后组合成新的一个AVFilterFormats。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/421096/201812/421096-20181212220656236-1014892298.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/421096/201812/421096-20181212220656854-1544582005.png&quot; alt=&quot;image&quot; width=&quot;600&quot; height=&quot;413&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在实际滤波过程中，我们需要通过名为buffersrc的滤波器输入帧，而buffersrc在进行初始化的时候需要指定唯一的帧格式，即位于整个滤波图头部的是一个format个数为1的AVFilterFormats。并且，对于很多滤波器来说，所支持的输入输出格式是一样的，因此位于滤波器输入端link的out_formats与输出端link的in_formats会指向同一个AVFilterFormats。出于这两个原因，在循环地对graph上的AVFilterLink进行merge的时候，很容易地就能使得整个graph上所有的link中的in_formats与out_formats都指向同一个AVFilterFormats，并且其中含有唯一一个format就是输入帧的format。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/421096/201812/421096-20181212220657362-1397731773.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/421096/201812/421096-20181212220657776-1580006482.png&quot; alt=&quot;image&quot; width=&quot;400&quot; height=&quot;367&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如上图就是filter的输入与输出端支持同样格式，因此会把输入link的out_formats以及输出link的in_formats指向同一AVFilterFormats。不过如果filter两端支持不同的格式，则表示该filter内可能对帧的格式进行了转换。&lt;/p&gt;

&lt;h4&gt;自动格式转换&lt;/h4&gt;
&lt;p&gt;如果AVFilterLink的in_formats与out_formats中不含有相同format，就表明需要进行格式转换。出现这种情况的时候ffmpeg会在该link上插入一个用于格式转换的滤波器，进行视频像素格式转换的滤波器名为scale，进行音频采样格式转换的滤波器名为aresample。&lt;/p&gt;
&lt;pre class=&quot;brush: js; auto-links: true; collapse: false; first-line: 1; gutter: true; html-script: false; light: false; ruler: false; smart-tabs: true; tab-size: 4; toolbar: true;&quot;&gt;
if (convert_needed) {
    switch (link-&amp;gt;type) {
    case AVMEDIA_TYPE_VIDEO:
        filter = avfilter_get_by_name(&quot;scale&quot;);
        avfilter_graph_create_filter(&amp;amp;convert, filter,
                                        inst_name, graph-&amp;gt;scale_sws_opts, NULL,
                                        graph);
        break;
    case AVMEDIA_TYPE_AUDIO:
        filter = avfilter_get_by_name(&quot;aresample&quot;);
        avfilter_graph_create_filter(&amp;amp;convert, filter,
                                            inst_name, graph-&amp;gt;aresample_swr_opts,
                                            NULL, graph);
        break;
    default:
        return AVERROR(EINVAL);
    }

    if ((ret = avfilter_insert_filter(link, convert, 0, 0)) &amp;lt; 0)
        return ret;

    if ((ret = filter_query_formats(convert)) &amp;lt; 0)
        return ret;
    if (!ff_merge_formats( inlink-&amp;gt;in_formats,  inlink-&amp;gt;out_formats,  inlink-&amp;gt;type) ||
        !ff_merge_formats(outlink-&amp;gt;in_formats, outlink-&amp;gt;out_formats, outlink-&amp;gt;type))
        ret = AVERROR(ENOSYS);
&lt;/pre&gt;
&lt;p&gt;插入格式转换滤波器包含以下步骤：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;插入格式转换滤波器的函数avfilter_insert_filter会把原来的link的出口连接到格式转换滤波器的入口上，然后用新的link连接格式转换滤波器的出口以及源link原来的目标端口。最后还会把源link的out_formats移给新link的out_formats。&lt;/li&gt;
&lt;li&gt;filter_query_formats则会调用格式转换滤波器的query_formats函数来设置其两端的out_formats以及in_formats，由于此时我们一般不会为其设置任何参数，因此此时格式转换滤波器两端的out_formats以及in_formats会支持所有格式。&lt;/li&gt;
&lt;li&gt;最后的ff_merge_formats把涉及到的这两个link上的格式进行merge，这样就使得格式转换滤波器两端的out_formats以及in_formats设定完毕。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/421096/201812/421096-20181212220658263-1549122583.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/421096/201812/421096-20181212220658827-1465176215.png&quot; alt=&quot;image&quot; width=&quot;600&quot; height=&quot;629&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;在得到格式转换滤波器两边的两个link的最终格式后，会通过调用格式转换滤波器的config_props函数来进行转换的初始化，初始化时的输入参数就是这两个link的最终格式。&lt;/p&gt;
&lt;pre class=&quot;brush: js; auto-links: true; collapse: false; first-line: 1; gutter: true; html-script: false; light: false; ruler: false; smart-tabs: true; tab-size: 4; toolbar: true;&quot;&gt;
static int config_output(AVFilterLink *outlink)
{
    AVFilterContext *ctx = outlink-&amp;gt;src;
    AVFilterLink *inlink = ctx-&amp;gt;inputs[0];

    aresample-&amp;gt;swr = swr_alloc_set_opts(aresample-&amp;gt;swr,
                                        outlink-&amp;gt;channel_layout, outlink-&amp;gt;format, outlink-&amp;gt;sample_rate,
                                        inlink-&amp;gt;channel_layout, inlink-&amp;gt;format, inlink-&amp;gt;sample_rate,
                                        0, ctx);
}
&lt;/pre&gt;


&lt;h4&gt;提取最终格式&lt;/h4&gt;
&lt;p&gt;经过前面的流程，已经能保证link上的in_formats与out_formats是merge过的了，下面处理同一个滤波器的输入以及输出link之间的格式问题。&lt;/p&gt;
&lt;p&gt;尽管我们前面说过，对于内部不会进行格式转换的滤波器，通常其输入输出会支持相同的格式，因此输入link的out_formats与输出link的in_formats一般来说都是指向同一个AVFilterFormats，不过滤波器多种多样，也有可能会出现明明可以不用格式转换，输入link的out_formats却与输出link的in_formats却指向不同AVFilterFormats。为了防止滤波器做不必要的格式转换，有以下处理方式：一旦发现输入link的out_formats当中只有唯一一个格式，并且输出link的in_formats当中包含该格式，则会把该格式移动到in_formats[0]，并把格式数目设置为1。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/421096/201812/421096-20181212220659258-554022812.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/421096/201812/421096-20181212220659634-324384534.png&quot; alt=&quot;image&quot; width=&quot;400&quot; height=&quot;247&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;在选取link的最终格式时，一般来说link的格式列表中只有一个格式，因此会直接选则这一个格式。&lt;/p&gt;
&lt;pre class=&quot;brush: js; auto-links: true; collapse: false; first-line: 1; gutter: true; html-script: false; light: false; ruler: false; smart-tabs: true; tab-size: 4; toolbar: true;&quot;&gt;
static int pick_format(AVFilterLink *link, AVFilterLink *ref)
{
    link-&amp;gt;in_formats-&amp;gt;nb_formats = 1;
    link-&amp;gt;format = link-&amp;gt;in_formats-&amp;gt;formats[0];
}
&lt;/pre&gt;

&lt;p&gt;不过也存在特殊情况：如果滤波器支持不同于源格式的多种输出格式，但是用户并没有指定具体的输出格式，那么应该根据源格式从当前列表中选择最优的输出格式。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/421096/201812/421096-20181212220659980-309464394.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/421096/201812/421096-20181212220700343-1333511776.png&quot; alt=&quot;image&quot; width=&quot;400&quot; height=&quot;230&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 12 Dec 2018 14:07:00 +0000</pubDate>
<dc:creator>TaigaComplex</dc:creator>
<og:description>ffmpeg的中滤波器是以帧为原料来进行滤波的，那么自然地就会对帧的格式有所要求，可以说如果滤波器不知道帧的格式，就无法对帧进行处理。在进行视频滤波时，滤波格式指的是视频的像素格式；在进行音频滤波时，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/TaigaCon/p/10111326.html</dc:identifier>
</item>
<item>
<title>将ijkplayer播放器移植到windows平台（附源码） - HarlanC</title>
<link>http://www.cnblogs.com/harlanc/p/10111290.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/harlanc/p/10111290.html</guid>
<description>&lt;p&gt;ijkplayer windows版本的移植工作终于有了一些进展，起初自己做这个项目是因为公司有可能会用到，于是用业余时间慢慢熟悉相关知识和ijkplayer的代码。现在应该是用不到了，到这里做一个总结吧，最终能够达到的效果是是能够在windows上用OpenGL ES渲染视频和用OpenAL播放声音，但是还有音画不同步的问题，以后有时间的话再去解决。各位如果有想学习音视频渲染的可以参考我的代码相互交流学习。&lt;/p&gt;
&lt;p&gt;下面是编译源码的说明文档，如果有任何问题可以通知我。&lt;/p&gt;
&lt;h2 id=&quot;编译环境&quot;&gt;编译环境&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;MinGW32&lt;/li&gt;
&lt;li&gt;WIN7&lt;/li&gt;
&lt;li&gt;Visual Studio 2017&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;MinGW32环境的搭建可以参考之前的&lt;a href=&quot;https://www.cnblogs.com/harlanc/p/9569960.html&quot;&gt;帖子&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;准备工作&quot;&gt;准备工作&lt;/h2&gt;
&lt;h3 id=&quot;编译ijkplayer-ffmpeg&quot;&gt;编译ijkplayer-ffmpeg&lt;/h3&gt;
&lt;p&gt;ijkplayer使用的ffmpeg直接拿来在windows上编译会出错，需要merge官方ffmpeg的最新代码，可以看之前的&lt;a href=&quot;https://www.cnblogs.com/harlanc/p/9794811.html&quot;&gt;帖子&lt;/a&gt;。merge后的代码push到了&lt;a href=&quot;https://github.com/harlanc/FFmpeg.git&quot;&gt;github&lt;/a&gt;上。&lt;/p&gt;
&lt;p&gt;将代码clone到MInGW_root_path/msys/1.0/home/Admistrator/下面&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;git clone https://github.com/harlanc/FFmpeg.git&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将ijkplayer branch checkout下来：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;git checkout origin/ijkplayer -b ijkplayer&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;configure&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ ./configure --disable-static --enable-shared --enable-gpl --enable-version3 --enable-sdl --enable-debug=3 --disable-optimizations --disable-mmx --disable-s tripping&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;make &amp;amp;&amp;amp; make install&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;make &amp;amp;&amp;amp; make install&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;编译angle库&quot;&gt;编译Angle库&lt;/h3&gt;
&lt;p&gt;clone到本地&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;git clone https://github.com/Microsoft/angle.git&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;调用批处理生成sln文件然后用Vistual Studio编译生成以下3个dll:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;d3dcompiler_47.dll&lt;/li&gt;
&lt;li&gt;libEGL.dll&lt;/li&gt;
&lt;li&gt;libGLESv2.dll&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;具体流程参考微软的&lt;a href=&quot;https://github.com/Microsoft/angle#quick-start-compiling-from-source&quot;&gt;官方文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;将上面三个dll拷贝到 MInGW_root_path/msys/1.0/local/bin下面&lt;/p&gt;
&lt;h2 id=&quot;编译ijkplayer-windows&quot;&gt;编译ijkplayer-windows&lt;/h2&gt;
&lt;p&gt;clone代码到本地&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;git clone https://github.com/harlanc/ijkplayer-windows.git&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将ijkplayer-windows branch checkout下来：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;git checkout origin/ijkplayer-windows -b ijkplayer-windows&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将Angle代码库下面的include文件夹拷贝到ijkplayer-windows/ijkmedia/ijksdl 下面。&lt;/p&gt;
&lt;p&gt;到ijkplayer-windows/ijkmedia目录下执行configure命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;./configure&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行make&amp;amp;&amp;amp; make install&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;make &amp;amp;&amp;amp; make install&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;执行&quot;&gt;执行&lt;/h2&gt;
&lt;p&gt;最后会在ijkplayer-windows/ijkmedia/ijkplayer/windows/.libs 下面生成winplayer.exe可执行文件。将视频文件拷贝到此目录下面，执行下面的命令播放：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; ./winplayer.exe test.mp4&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;附一个最终的效果图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://files-cdn.cnblogs.com/files/harlanc/ijkplayer_windows.bmp&quot; alt=&quot;avatar&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;已知问题&quot;&gt;已知问题&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;音画不同步&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Wed, 12 Dec 2018 14:01:00 +0000</pubDate>
<dc:creator>HarlanC</dc:creator>
<og:description>将ijkplayer移植到windows平台（附源码） ijkplayer windows版本的移植工作终于有了一些进展，起初自己做这个项目是因为公司有可能会用到，于是用业余时间慢慢熟悉相关知识和ij</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/harlanc/p/10111290.html</dc:identifier>
</item>
<item>
<title>CSS float的相关图文详解（一） - 公主666</title>
<link>http://www.cnblogs.com/xuln/p/10111169.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xuln/p/10111169.html</guid>
<description>&lt;p&gt;　　&lt;span&gt;大家好，作为一个刚入门的小前端，第一次写博客，很是鸡冻。由于涉猎较浅，有些知识可能说的不清楚，或者有什么错误，欢迎留言指正。我的第一篇博客写的关于css的浮动的。想必很多小伙伴特别是刚学的，对浮动有一定的迷惑，当然了，并不是所有初学者都像我一样迷迷糊糊。哈哈，废话不多说，现在谈谈&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我对浮动的理解，更应该说是总结吧，还是那句话，如果哪里不对，请留言指出，这也是帮助我进步。　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　历史：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　 浮动最开始是为了实现文字环绕的效果，也就是说浮动最开始是用来做一些文字混排效果&lt;/span&gt;&lt;span&gt;的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　浮动：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　元素的浮动是指设置了浮动属性的元素会脱离标准流的控制，移动到其父元素中指定位置的过程。如果元素设置了浮动，会使元素向左或向右移动，也就是说元素只能水平方向浮动，不能上下浮动，而元素设置了浮动后，周围的元素也会重新排列。一个浮动的元素会尽量向左或向右移动，直到它的外边缘碰到包含边框或另一个浮动框的边框为止。需要&lt;span&gt;&lt;strong&gt;&lt;span&gt;注意&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;的是：浮动元素之前的元素不会受到影响，而浮动元素之后的元素会围绕它。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;&lt;span&gt;图1：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1485647/201812/1485647-20181212195649464-1607322921.gif&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　图1解释：这是三个自上而下排列的块级元素，块级元素独占一行，当给框1设置向右浮动时，框1会脱离文档流，不占据原来的位置，并且向右移动，直到框1的右边缘碰到包含框的右边缘&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;：&lt;span&gt;浮动元素会脱离文档流，不占据原来的位置。浮动的元素总是找离它最近的父级元素对齐，但是不会超出内边距的范围。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;&lt;span&gt;图2：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1485647/201812/1485647-20181212200724561-1119751257.gif&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;图2解释：当给框1设置左浮动时，框1会脱离文档流并且向左移动，直到框1的左边缘碰到包含框的左边缘。前面说过浮动的元素会脱离文档流，不占据原来的位置，所以，现在，框1不再处于文档流中，也就意味着框1不占据空间了，而这时框2就跑到了框1原来的位置，因为框1现在漂浮着，实际上框1覆盖住了框2，使得框2从视图中消失了。&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;如果你将三个框都设置向左浮动，那么，框1向左浮动直到碰到包含框，框2向左浮动直到碰到框1，而框3向左浮动直到碰到框2。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;span&gt;&lt;strong&gt;&lt;span&gt;图3：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1485647/201812/1485647-20181212201834071-2011967750.gif&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　&lt;span&gt;图3解释：当包含框太窄，无法容纳水平排列的浮动元素时，那么其他浮动块向下移动，直到有足够的空间。如果浮动元素的高度不同，那么当它们向下移动时可能会被其他浮动元素&quot;卡住&quot;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　特性：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　(1).浮动的元素排列位置，跟上一个元素(块级)有关系。也就是说浮动对它下面的盒子有影响。例如：A元素和B元素是上下排列的，A元素在B元素的上面，如果A元素设置了浮动，那么B元素的顶部会和A元素的顶部对齐(可参看图2解释)；如果A元素是标准流，那么B元素的顶部会和A元素的底部对齐(即使B元素添加了浮动也会和A元素的底部对齐，因为B元素的浮动只对它的下面的盒子有影响)。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　举例：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　&lt;span&gt;&lt;strong&gt;&lt;span&gt;html代码　&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;　&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
&amp;lt;!Doctype html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;title&amp;gt;浮动&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
        &amp;lt;div class=&quot;ab&quot;&amp;gt;A&amp;lt;/div&amp;gt;
        &amp;lt;div class=&quot;ba&quot;&amp;gt;B&amp;lt;/div&amp;gt;     
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;&lt;span&gt;CSS代码&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:css;gutter:true;&quot;&gt;
&amp;lt;style&amp;gt;
        .ab{
                width:100px;
                height:100px;
                background-color:orange;
                font-size:50px;
                line-height:100px;
                text-align:center;
}

        .ba{
                width:100px;
                height:100px;
                background-color:pink;
                font-size:50px;
                line-height:100px;
                text-align:center;
}

&amp;lt;/style&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;显示效果&lt;/strong&gt;&lt;/span&gt;　　&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1485647/201812/1485647-20181212204129421-346798654.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;上面是A元素和B元素初始化默认的状态，这时，给A元素添加左浮动，代码如下：&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:css;gutter:true;&quot;&gt;
&amp;lt;style&amp;gt;
        .ab{
                width:100px;
                height:100px;
                background-color:orange;
                font-size:50px;
                line-height:100px;
                text-align:center;
               /*给A元素设置float属性，其值为left*/
               float：left；  
}

        .ba{
                /*width:100px;
                height:100px;*/&lt;br/&gt;　　　　　　　　　　/*为了能够更好的显示效果，将B元素的宽度高度都设置为200px*/&lt;br/&gt;　　　　　　　　　　width:200px;&lt;br/&gt;　　　　　　　　　　height:200px;
                background-color:pink;
                font-size:50px;
                line-height:100px;
                text-align:center;
}

&amp;lt;/style&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　&lt;span&gt;　给A元素添加左浮动显示效果如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1485647/201812/1485647-20181212204759753-585023196.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;从上图可以看出，A元素脱离了文档流，不占据原来的位置，而B元素就占据了A元素原来的位置，这时，A元素的顶部与B元素的顶部对齐。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　如果是给B元素设置了浮动，而A元素没有设置浮动，会有什么样的效果呢？代码如下：&lt;/span&gt;&lt;span&gt;　&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:css;gutter:true;&quot;&gt;
&amp;lt;style&amp;gt;
        .ab{
                width:100px;
                height:100px;
                background-color:orange;
                font-size:50px;
                line-height:100px;
                text-align:center;
                
}

        .ba{
                width:100px;
                height:100px;
                background-color:pink;
                font-size:50px;
                line-height:100px;
                text-align:center;
                /*给B元素设置浮动*/ 
                float:left;
}

&amp;lt;/style&amp;gt;    
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　&lt;span&gt;　显示效果如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1485647/201812/1485647-20181212205249783-940067851.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;虽然是给B元素设置了浮动，但是A元素和B元素的排列方式跟最开始没有设置时的排列方式一样。这说明添加浮动的元素只会对它下面的元素产生影响，而上面的元素不会产生影响。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;(2).&lt;span&gt;一个父盒子里面的子盒子，如果其中一个子级有浮动的，则其他子级都需要浮动。这样才能一行对齐显示。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;例子：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;&lt;strong&gt;&lt;span&gt;html代码&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
&amp;lt;!Doctype html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;title&amp;gt;浮动&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
        &amp;lt;div class=&quot;father&quot;&amp;gt;
                &amp;lt;div class=&quot;son1&quot;&amp;gt;son1&amp;lt;/div&amp;gt;
                &amp;lt;div class=&quot;son2&quot;&amp;gt;son2&amp;lt;/div&amp;gt;
                &amp;lt;div class=&quot;son3&quot;&amp;gt;son3&amp;lt;/div&amp;gt;        
        &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;&lt;span&gt;css代码&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;　&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
&amp;lt;style&amp;gt;
        .father{
                width:310px;
                height:310px;
                border:1px solid red;
}
        .son1{
                width:100px;
                height:100px;
                background-color:orange;
                font-size:20px;
                line-height:100px;
                text-align:center;
                float:left;
                
}

        .son2{
                width:100px;
                height:100px;
                background-color:pink;
                font-size:20px;
                line-height:100px;
                text-align:center;
                float:left;
}
        .son3{
                width:100px;
                height:100px;
                background-color:yellowgreen;
                font-size:20px;
                line-height:100px;
                text-align:center;
                float:left;
}

&amp;lt;/style&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　&lt;span&gt;显示效果如下图所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　&lt;/span&gt;&lt;span&gt;　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1485647/201812/1485647-20181212210309747-1502388088.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(3).&lt;/span&gt;&lt;span&gt;元素添加浮动后，元素会具有行内块元素的特性。元素的大小完全取决于定义的大小或者默认的内容多少浮动根据元素书写的位置来显示相应的浮动。浮动可以让元素默认转换为行内块元素。行内元素手动设置的宽高是不生效的，给个display:inline-block就生效了，现在不给display给个float也会生效。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　例子：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;&lt;strong&gt;&lt;span&gt;html代码&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;title&amp;gt;浮动&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
        &amp;lt;span class=&quot;cls&quot;&amp;gt;我是行内元素&amp;lt;/span&amp;gt;

&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;&lt;span&gt;css代码&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;　&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:css;gutter:true;&quot;&gt;
&amp;lt;style&amp;gt;
        .cls{
                width:100px;
                height:100px;
                background-color:red;
                /*添加浮动*/
               float:left;     
}

&amp;lt;/style&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　&lt;span&gt;显示效果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1485647/201812/1485647-20181212211055671-1966917227.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;本身span元素是行内元素，设置宽度高度是没有效果的，只有将span转为块级元素或者行内块元素才会生效，可以直接给span元素设置float属性就可以转化为块级元素或行内块元素。　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(4).浮动的元素不会压住padding　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;总结：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;关于浮动这里总结了个小口诀，大家感兴趣的话可以参考下。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;float 浮 漏 特&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　浮： 加了浮动的元素盒子是浮起来的，漂浮在其他的标准流盒子上面。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　漏： 加了浮动的盒子，不占位置的，它浮起来了，它原来的位置漏 给了标准流的盒子。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　特： 特别注意，首先浮动的盒子需要和标准流的父级搭配使用， 其次 特别的注意浮动可以使元素显示模式体现为行内块特性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　浮动是把双刃剑，在给我们的布局带来便利的同时有一些缺点需要我们去解决。例如最常见的父元素塌陷。下一节详细介绍如果清除浮动等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　如果您看到这里，文章中有哪些不对的欢迎留言指出，也可以提出更宝贵的意见。第一次写博客，如果字体或者排版给您带来不便，我深感抱歉。也希望自己的一点点小总结对您多少有点帮助。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 12 Dec 2018 13:33:00 +0000</pubDate>
<dc:creator>公主666</dc:creator>
<og:description>大家好，作为一个刚入门的小前端，第一次写博客，很是鸡冻。由于涉猎较浅，有些知识可能说的不清楚，或者有什么错误，欢迎留言指正。我的第一篇博客写的关于css的浮动的。想必很多小伙伴特别是刚学的，对浮动有一</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xuln/p/10111169.html</dc:identifier>
</item>
<item>
<title>Python with/as使用说明 - 骏马金龙</title>
<link>http://www.cnblogs.com/f-ck-need-u/p/10111121.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/f-ck-need-u/p/10111121.html</guid>
<description>&lt;h2 id=&quot;withas&quot;&gt;with/as&lt;/h2&gt;
&lt;p&gt;使用open打开过文件的对with/as都已经非常熟悉，其实with/as是对try/finally的一种替代方案。&lt;/p&gt;
&lt;p&gt;当某个对象支持一种称为&quot;环境管理协议&quot;的协议时，就会通过环境管理器来自动执行某些善后清理工作，就像finally一样：不管中途是否发生异常，最终都会执行某些清理操作。&lt;/p&gt;
&lt;p&gt;用法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;with expression [as var]:
    with_block_code&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当expression返回的对象是支持环境管理协议的时候，就可以使用with。as var是可选的，如果不使用as var，expression返回对象将被丢弃，如果使用as var，就会将expression的返回对象赋值给变量var。&lt;/p&gt;
&lt;p&gt;整个流程大致如下：先评估expression，如果支持环境管理协议，然后开始with/as语句块结构，当准备退出with语句块的时候，将执行对象中定义的善后操作。工作机制的细节见下文。&lt;/p&gt;
&lt;p&gt;例如，open()返回的文件对象是支持环境管理协议的，所以可以用with/as来安全地打开文件：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;with open(r'd:\a\b\c\a.log') as logfile:
    for line in logfile:
        print(line)
        ...more code here...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;整个过程是先open()，然后with/as，输出每一行后将要退出with语句块的时候，环境管理器根据文件对象中定义的操作关闭文件。&lt;/p&gt;
&lt;p&gt;它实际上等价于：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;myfile = open(r'd:\a\b\c\a.log')
try:
    for line in myfile:
        print(line)
        ...more code here...
finally:
    myfile.close()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;虽然在文件不被引用之后，垃圾回收器会自动回收这个文件对象，但是垃圾回收器的回收操作是有等待时间的。换句话说，如果不使用with/as打开文件，也不显示close()关闭文件，那么这个文件很可能会在用完之后保持空闲一段时间，然后才被垃圾回收器回收。&lt;/p&gt;
&lt;p&gt;with/as不仅用于文件打开/关闭，锁操作也支持环境管理协议，也就是说，在有需要的时候会自动释放锁资源。&lt;/p&gt;
&lt;h2 id=&quot;嵌套多个环境管理器&quot;&gt;嵌套多个环境管理器&lt;/h2&gt;
&lt;p&gt;在python 3.1之后，with as支持多个环境管理器，使用逗号隔开即可。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;with A() as a, B() as b:
    ...statements...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它等价于嵌套的with：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;with A() as a:
    with B() as b:
        ...statements...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;多环境管理器管理的多个对象会在with语句块中出现异常的时候，或者执行完with语句块的时候全部自动被清理(例如文件关闭操作)。&lt;/p&gt;
&lt;p&gt;例如，打开两个文件，将它们的内容通过zip()合并在一起，并且同时关闭它们：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;with open('a.file') as f1, open('b.file') as f2:
    for pair in zi[(f1, f2):
        print(pair)&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;自定义环境管理器&quot;&gt;自定义环境管理器&lt;/h2&gt;
&lt;p&gt;无论是文件还是锁，都是别人已经写好了环境管理器的对象。我们自己也可以写环境管理器，让它可以使用with/as，这实际上属于运算符重载的范畴。&lt;/p&gt;
&lt;p&gt;要写自己的环境管理器，先了解with/as的工作机制的细节：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;先评估expression，评估的返回结果是一个对象，这个对象要具有&lt;code&gt;__enter__&lt;/code&gt;和&lt;code&gt;__exit__&lt;/code&gt;方法，返回的对象称为&quot;环境管理器&quot;&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;然后调用环境管理器的&lt;code&gt;__enter__&lt;/code&gt;方法。&lt;code&gt;__enter__&lt;/code&gt;方法的返回值赋值给 as 指定的变量，或者直接丢弃(没有使用as)&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;然后执行with语句块中的内容&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;如果执行with语句块中的内容时抛出了异常，将调用&lt;code&gt;__exit__(type,value,traceback)&lt;/code&gt;方法，其中这3个和异常相关的参数来源于&lt;code&gt;sys.exc_info&lt;/code&gt;。如果&lt;code&gt;__exit__&lt;/code&gt;返回值为False，则会自动重新抛异常以便传播异常，否则异常被认为合理处理&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;如果with语句块中的内容没有抛异常，则直接调用&lt;code&gt;__exit__(None,None,None)&lt;/code&gt;，即这三个参数都传递为None值&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;看一个简单的示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class TraceBlock:
    def message(self, arg):
        print('running ' + arg)

    def __enter__(self):
        print('starting with block')
        return self

    def __exit__(self, exc_type, exc_value, exc_tb):
        if exc_type is None:
            print('exited normally\n')
        else:
            print('raise an exception! ' + str(exc_type))
            return False&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的&lt;code&gt;__enter__&lt;/code&gt;方法返回的对象会赋值给as关键字指定的变量，在这个示例中即将对象自身返回。如果有需求，可以返回其它对象。&lt;/p&gt;
&lt;p&gt;上面的&lt;code&gt;__exit__&lt;/code&gt;中，如果异常的类型为None，说明with语句块中的语句执行过程没有抛异常，正常结束即可。但是如果有异常，则要求返回False，实际上上面的&lt;code&gt;return False&lt;/code&gt;可以去掉，因为函数没有return时默认返回None，它的布尔值代表的就时False。&lt;/p&gt;
&lt;p&gt;测试下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;with TraceBlock() as action:
    action.message(&quot;test 1&quot;)
    print(&quot;reached&quot;)
    
print('-' * 20, &quot;\n&quot;)

with TraceBlock() as action:
    action.message(&quot;test 2&quot;)
    raise TypeError
    print(&quot;not reached&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;starting with block
running test 1
reached
exited normally

--------------------

starting with block
running test 2
raise an exception! &amp;lt;class 'TypeError'&amp;gt;
Traceback (most recent call last):
  File &quot;g:/pycode/list.py&quot;, line 23, in &amp;lt;module&amp;gt;
    raise TypeError
TypeError&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;定义环境管理器不是件简单的事。一般来说，如果不是很复杂的需求，直接使用try/finally来定义相关操作即可。&lt;/p&gt;
</description>
<pubDate>Wed, 12 Dec 2018 13:25:00 +0000</pubDate>
<dc:creator>骏马金龙</dc:creator>
<og:description>with/as 使用open打开过文件的对with/as都已经非常熟悉，其实with/as是对try/finally的一种替代方案。 当某个对象支持一种称为</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/f-ck-need-u/p/10111121.html</dc:identifier>
</item>
<item>
<title>JavaScript实现邮箱后缀提示功能 - JoeJoan</title>
<link>http://www.cnblogs.com/Joe-and-Joan/p/10111099.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Joe-and-Joan/p/10111099.html</guid>
<description>&lt;h3 id=&quot;-&quot;&gt;先来个基础的&lt;/h3&gt;
&lt;h4 id=&quot;-&quot;&gt;需求&lt;/h4&gt;
&lt;p&gt;根据下面需求实现如示意图所示的邮箱输入提示功能，注意，根据要求只需实现下面功能&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当用户没有任何输入时，提示框消失&lt;/li&gt;
&lt;li&gt;当用户输入字符后，显示提示框，并且把用户输入的内容自动拼上邮箱后缀进行显示&lt;/li&gt;
&lt;li&gt;暂时不用考虑示意图中的红色和蓝色背景色的逻辑&lt;/li&gt;
&lt;li&gt;注意用户输入中前后空格需要去除&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;-&quot;&gt;小优化编码&lt;/h3&gt;
&lt;h4 id=&quot;-&quot;&gt;需求&lt;/h4&gt;
&lt;p&gt;如果我们输入的是 abc@1，这个时候出现的提示框内容是&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;abc@1@163.com&lt;/li&gt;
&lt;li&gt;abc@1@gmail.com&lt;/li&gt;
&lt;li&gt;abc@1@126.com&lt;br/&gt;……&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;很明显，上面的提示框不是一个符合用户需求的提示，我们需要做一些优化：&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;当用户输入含有 @ 符号时，我们选取用户输入的@前面的字符来和后缀拼接&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;h4 id=&quot;-&quot;&gt;需求&lt;/h4&gt;
&lt;p&gt;这下出现的提示好多了，不过用户如果已经输入了@1，说明他大概率要输入163或者126，我们需要让我们的提示更加符合用户的期望。满足以下需求：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当用户输入了 @ 及部分后缀时，只从 postfixList 选取符合用户输入预期的后缀，我们以前缀匹配为要求。&lt;/li&gt;
&lt;li&gt;当用户输入不满足任何前缀匹配时，则显示全部提示&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;测试用例&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;输入a@1-&amp;gt;出现提示框，提示a@163.com, a@126.com&lt;/li&gt;
&lt;li&gt;输入a@g-&amp;gt;出现提示框，提示a@gmail.com&lt;/li&gt;
&lt;li&gt;输入a@2-&amp;gt;出现提示框，提示a@263.net&lt;/li&gt;
&lt;li&gt;输入a@qq-&amp;gt;出现提示框，提示a@qq.com&lt;/li&gt;
&lt;li&gt;输入a@163.-&amp;gt;出现提示框，提示a@163.com&lt;/li&gt;
&lt;li&gt;输入a@126.com-&amp;gt;出现提示框，提示a@126.com&lt;/li&gt;
&lt;li&gt;输入a@qq.com （两个空格）-&amp;gt;出现提示框，提示a@qq.com&lt;/li&gt;
&lt;li&gt;输入a@qq.comm-&amp;gt;出现提示框，出现全部提示&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;代码1&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &amp;lt;!DOCTYPE html&amp;gt;
&lt;span&gt;  2&lt;/span&gt; &amp;lt;html&amp;gt;
&lt;span&gt;  3&lt;/span&gt; 
&lt;span&gt;  4&lt;/span&gt; &amp;lt;head&amp;gt;
&lt;span&gt;  5&lt;/span&gt;     &amp;lt;meta charset=&quot;utf-8&quot; /&amp;gt;
&lt;span&gt;  6&lt;/span&gt;     &amp;lt;title&amp;gt;邮箱后缀提示1-完成基本提示&amp;lt;/title&amp;gt;
&lt;span&gt;  7&lt;/span&gt;     
&lt;span&gt;  8&lt;/span&gt; &amp;lt;/head&amp;gt;
&lt;span&gt;  9&lt;/span&gt; 
&lt;span&gt; 10&lt;/span&gt; &amp;lt;body&amp;gt;
&lt;span&gt; 11&lt;/span&gt;     &amp;lt;div class=&quot;wrapper&quot;&amp;gt;
&lt;span&gt; 12&lt;/span&gt;         &amp;lt;input type=&quot;text&quot; id=&quot;input-email&quot;&amp;gt;
&lt;span&gt; 13&lt;/span&gt;         &amp;lt;ul class=&quot;email-sug&quot; id=&quot;email-sug-wrapper&quot;&amp;gt;
&lt;span&gt; 14&lt;/span&gt; 
&lt;span&gt; 15&lt;/span&gt;         &amp;lt;/ul&amp;gt;
&lt;span&gt; 16&lt;/span&gt;     &amp;lt;/div&amp;gt;
&lt;span&gt; 17&lt;/span&gt;     &amp;lt;script&amp;gt;
&lt;span&gt; 18&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; postfixList = [&quot;163.com&quot;, &quot;gmail.com&quot;, &quot;126.com&quot;, &quot;qq.com&quot;, &quot;263.net&quot;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; txt = document.getElementById(&quot;input-email&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; sug = document.getElementById(&quot;email-sug-wrapper&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt;         
&lt;span&gt; 22&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; keys.addEventListener(&quot;keyup&quot;,function(){&lt;/span&gt;
&lt;span&gt; 23&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     console.log(&quot;event handle1&quot;);&lt;/span&gt;
&lt;span&gt; 24&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; })&lt;/span&gt;
&lt;span&gt; 25&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; keys.addEventListener(&quot;keypress&quot;,function(){&lt;/span&gt;
&lt;span&gt; 26&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     console.log(&quot;event handle2&quot;);&lt;/span&gt;
&lt;span&gt; 27&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; })&lt;/span&gt;
&lt;span&gt; 28&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; keys.addEventListener(&quot;keydown&quot;,function(){&lt;/span&gt;
&lt;span&gt; 29&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     console.log(&quot;event handle3&quot;);&lt;/span&gt;
&lt;span&gt; 30&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; })&lt;/span&gt;
&lt;span&gt; 31&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; keys.addEventListener(&quot;input&quot;,function(){&lt;/span&gt;
&lt;span&gt; 32&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     console.log(&quot;event handle4&quot;);&lt;/span&gt;
&lt;span&gt; 33&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; })&lt;/span&gt;
&lt;span&gt; 34&lt;/span&gt; 
&lt;span&gt; 35&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;经过查看各个效果，oninput效果最符合需求。&lt;/span&gt;
&lt;span&gt; 36&lt;/span&gt;         txt.oninput = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt;             console.log(&quot;event handle4&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt; &lt;span&gt;            judge();
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt; &lt;span&gt;            add();
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt; 
&lt;span&gt; 41&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt;         &lt;span&gt;function&lt;/span&gt;&lt;span&gt; getText() {
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; inputText =&lt;span&gt; txt.value.trim();
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; inputText;
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断是否生成新的数组&lt;/span&gt;
&lt;span&gt; 47&lt;/span&gt;         &lt;span&gt;function&lt;/span&gt;&lt;span&gt; postlist() {
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; userinput =&lt;span&gt; getText();
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; newpostlist = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Array();
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (userinput.search('@') != 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; len = userinput.search('@'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;用来拼接的用户输入内容 = 只使用@之后的字符串&lt;/span&gt;
&lt;span&gt; 53&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; x = userinput.substring(len + 1, userinput.length); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;取@之后的部分&lt;/span&gt;
&lt;span&gt; 54&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; postfixList.length; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (postfixList[i].search(x) == 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt; &lt;span&gt;                        newpostlist.push(postfixList[i]);
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;若@后面没有字符或者新数组newpostlist为空，就返回原来的postfixlist&lt;/span&gt;
&lt;span&gt; 60&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (x === '' || newpostlist == ''&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; postfixList;
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; newpostlist;
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt;             } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; postfixList;
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据输入内容和匹配来生成提示数组&lt;/span&gt;
&lt;span&gt; 69&lt;/span&gt;         &lt;span&gt;function&lt;/span&gt;&lt;span&gt; promptContent() {
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; x =&lt;span&gt; getText();
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; tips = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Array();
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (x.indexOf(&quot;@&quot;) != -1&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; p = x.slice(0, x.indexOf(&quot;@&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt; (i = 0; i &amp;lt; postlist().length; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt;                     tips[i] = p + &quot;@&quot; +&lt;span&gt; postlist()[i];
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt;             } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt; (i = 0; i &amp;lt; postfixList.length; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt;                     tips[i] = x + &quot;@&quot; +&lt;span&gt; postfixList[i];
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; tips;
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加提示数组进入li&lt;/span&gt;
&lt;span&gt; 85&lt;/span&gt;         &lt;span&gt;function&lt;/span&gt;&lt;span&gt; add() {
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; sug = document.getElementById(&quot;email-sug-wrapper&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; tips =&lt;span&gt; promptContent();
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt;             &lt;span&gt;while&lt;/span&gt;&lt;span&gt; (sug.hasChildNodes()) {
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt; &lt;span&gt;                sug.removeChild(sug.firstChild);
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将之前的列表清除掉，然后重新生成新的列表&lt;/span&gt;
&lt;span&gt; 92&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (i = 0; i &amp;lt; tips.length; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; tip_li = document.createElement(&quot;li&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt;                 tip_li.innerHTML =&lt;span&gt; tips[i];
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt; &lt;span&gt;                sug.appendChild(tip_li);
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt; 
&lt;span&gt; 99&lt;/span&gt;         &lt;span&gt;function&lt;/span&gt;&lt;span&gt; judge() {
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;判空，是“”没有内容，不能为“　”&lt;/span&gt;
&lt;span&gt;101&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (getText() == &quot;&quot;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt; &lt;span&gt;                hide();
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt;             } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt; &lt;span&gt;                display();
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt; 
&lt;span&gt;107&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt; 
&lt;span&gt;109&lt;/span&gt;         &lt;span&gt;function&lt;/span&gt;&lt;span&gt; hide() {
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt;             sug.style.display = &quot;none&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt; 
&lt;span&gt;113&lt;/span&gt;         &lt;span&gt;function&lt;/span&gt;&lt;span&gt; display() {
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt;             sug.style.display = &quot;block&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;115&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;116&lt;/span&gt;     &amp;lt;/script&amp;gt;
&lt;span&gt;117&lt;/span&gt; &amp;lt;/body&amp;gt;
&lt;span&gt;118&lt;/span&gt; 
&lt;span&gt;119&lt;/span&gt; &amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;-&quot;&gt;新的需求编码&lt;/h3&gt;
&lt;h4 id=&quot;-&quot;&gt;需求&lt;/h4&gt;
&lt;p&gt;上面我们只完成了提示，但提示还没有直接作用到选择中，我们现在完成以下需求：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用CSS实现：鼠标滑过提示框的某一个提示时，这个提示内容背景色变化，表示鼠标经过了这个DOM节点&lt;/li&gt;
&lt;li&gt;鼠标如果点击某个提示，则提示内容进入输入框，同时提示框消失&lt;/li&gt;
&lt;li&gt;在上个步骤结束后，在输入框中任意再输入字符或删除字符，则重新开始出现提示框&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;-&quot;&gt;需求&lt;/h3&gt;
&lt;p&gt;尝试在输入框中输入&amp;lt;b&amp;gt;，看看提示框发生了什么&lt;/p&gt;
&lt;h4 id=&quot;-&quot;&gt;阅读&lt;/h4&gt;
&lt;h4 id=&quot;-&quot;&gt;设计&lt;/h4&gt;
&lt;p&gt;我们需要在两个地方进行处理，一个是在生成提示内容那里，对于特殊字符进行转义编码，另一个是在把鼠标点击的提示框内容转回输入框时进行解码。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码2&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;

&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;utf-8&quot; /&amp;gt;
    &amp;lt;title&amp;gt;邮箱后缀提示2-添加样式和监听鼠标点击和转码内容&amp;lt;/title&amp;gt;
    &amp;lt;style&amp;gt;&lt;span&gt;
    #input&lt;/span&gt;-&lt;span&gt;email{
        width: 300px;
        height: 30px;
    }
    .email&lt;/span&gt;-&lt;span&gt;sug{
        width: 300px;
        list&lt;/span&gt;-&lt;span&gt;style: none;
        padding: 0px;
        margin: 0px;
        border: 2px solid rgba(&lt;/span&gt;134, 132, 132,0.3&lt;span&gt;);
        border&lt;/span&gt;-&lt;span&gt;top:none;
        display: none;
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 初始不显示，避免边框出现 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    }
    .email&lt;/span&gt;-&lt;span&gt;sug li{
        width: 300px;
        height: 30px;
        background&lt;/span&gt;-&lt;span&gt;color: #ffffff;
        color: darkgrey;
        line&lt;/span&gt;-&lt;span&gt;height: 30px;    
    }
    .email&lt;/span&gt;-&lt;span&gt;sug li:hover{
        background&lt;/span&gt;-&lt;span&gt;color:pink;
    }
    &lt;/span&gt;&amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;

&amp;lt;body&amp;gt;
    &amp;lt;div class=&quot;wrapper&quot;&amp;gt;
        &amp;lt;input type=&quot;text&quot; id=&quot;input-email&quot;&amp;gt;
        &amp;lt;ul class=&quot;email-sug&quot; id=&quot;email-sug-wrapper&quot;&amp;gt;

        &amp;lt;/ul&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;script&amp;gt;
        &lt;span&gt;var&lt;/span&gt; postfixList = [&quot;163.com&quot;, &quot;gmail.com&quot;, &quot;126.com&quot;, &quot;qq.com&quot;, &quot;263.net&quot;&lt;span&gt;];
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; txt = document.getElementById(&quot;input-email&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; sug = document.getElementById(&quot;email-sug-wrapper&quot;&lt;span&gt;);
        sug.addEventListener(&lt;/span&gt;&quot;click&quot;,&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(ev){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;采用事件代理，监听父级点击事件，通过target获取当前li&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; ev=ev||&lt;span&gt;window.event;
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; target=ev.target||&lt;span&gt;ev.srcElement;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(target.nodeName.toLowerCase()==&quot;li&quot;&lt;span&gt;){
                hide();
               &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; txt.value=htmlDecode( target.innerHTML); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;解码&lt;/span&gt;
               &lt;span&gt;//&lt;/span&gt;&lt;span&gt;return txt.value= target.innerHTML;              &lt;/span&gt;
&lt;span&gt;            }
            
        })
        txt.oninput &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
            console.log(&lt;/span&gt;&quot;event handle4&quot;&lt;span&gt;);
            judge();
            add();

        }

        &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; getText() {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; inputText =&lt;span&gt; txt.value.trim();
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; inputText;
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断是否生成新的数组&lt;/span&gt;
        &lt;span&gt;function&lt;/span&gt;&lt;span&gt; postlist() {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; userinput =&lt;span&gt; getText();
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; newpostlist = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Array();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (userinput.search('@') != 0&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; len = userinput.search('@'&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用来拼接的用户输入内容 = 只使用@之后的字符串&lt;/span&gt;
                &lt;span&gt;var&lt;/span&gt; x = userinput.substring(len + 1, userinput.length); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;取@之后的部分&lt;/span&gt;
                &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; postfixList.length; i++&lt;span&gt;) {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (postfixList[i].search(x) == 0&lt;span&gt;) {
                        newpostlist.push(postfixList[i]);
                    }
                }
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;若@后面没有字符或者新数组newpostlist为空，就返回原来的postfixlist&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (x === '' || newpostlist == ''&lt;span&gt;) {
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; postfixList;
                }
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; newpostlist;
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; postfixList;
            }
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据输入内容和匹配来生成提示数组&lt;/span&gt;
        &lt;span&gt;function&lt;/span&gt;&lt;span&gt; promptContent() {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; x = htmlEncode(getText()) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;转码;&lt;/span&gt;
           &lt;span&gt;//&lt;/span&gt;&lt;span&gt; var x=getText();&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; tips = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Array();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (x.indexOf(&quot;@&quot;) != -1&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; p = x.slice(0, x.indexOf(&quot;@&quot;&lt;span&gt;));
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (i = 0; i &amp;lt; postlist().length; i++&lt;span&gt;) {
                    tips[i] &lt;/span&gt;= p + &quot;@&quot; +&lt;span&gt; postlist()[i];
                }
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (i = 0; i &amp;lt; postfixList.length; i++&lt;span&gt;) {
                    tips[i] &lt;/span&gt;= x + &quot;@&quot; +&lt;span&gt; postfixList[i];
                }
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; tips;
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加提示数组进入li&lt;/span&gt;
        &lt;span&gt;function&lt;/span&gt;&lt;span&gt; add() {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; sug = document.getElementById(&quot;email-sug-wrapper&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; tips =&lt;span&gt; promptContent();
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (sug.hasChildNodes()) {
                sug.removeChild(sug.firstChild);
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将之前的列表清除掉，然后重新生成新的列表&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt; (i = 0; i &amp;lt; tips.length; i++&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; tip_li = document.createElement(&quot;li&quot;&lt;span&gt;);
                tip_li.innerHTML &lt;/span&gt;=&lt;span&gt; tips[i];
                sug.appendChild(tip_li);
            }
        }

        &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; judge() {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判空，是“”没有内容，不能为“　”&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (getText() == &quot;&quot;&lt;span&gt;) {
                hide();
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                display();
            }

        }

        &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; hide() {
            sug.style.display &lt;/span&gt;= &quot;none&quot;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; display() {
            sug.style.display &lt;/span&gt;= &quot;block&quot;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;1.用浏览器内部转换器实现html转码&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;function&lt;/span&gt;&lt;span&gt; htmlEncode(html){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1.首先动态创建一个容器标签元素，如DIV&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; temp = document.createElement (&quot;div&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2.然后将要转换的字符串设置为这个元素的innerText(ie支持)或者textContent(火狐，google支持)&lt;/span&gt;
            (temp.textContent != undefined ) ? (temp.textContent = html) : (temp.innerText =&lt;span&gt; html);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3.最后返回这个元素的innerHTML，即得到经过HTML编码转换的字符串了&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; output =&lt;span&gt; temp.innerHTML;
            temp &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; output;
        }
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;2.用浏览器内部转换器实现html解码&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;function&lt;/span&gt;&lt;span&gt; htmlDecode(text){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1.首先动态创建一个容器标签元素，如DIV&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; temp = document.createElement(&quot;div&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2.然后将要转换的字符串设置为这个元素的innerHTML(ie，火狐，google都支持)&lt;/span&gt;
            temp.innerHTML =&lt;span&gt; text;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3.最后返回这个元素的innerText(ie支持)或者textContent(火狐，google支持)，即得到经过HTML解码的字符串了。&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; output = temp.innerText ||&lt;span&gt; temp.textContent;
            temp &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; output;
        }
    &lt;/span&gt;&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;

&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;-&quot;&gt;加上键盘&lt;/h3&gt;
&lt;h4 id=&quot;-&quot;&gt;需求&lt;/h4&gt;
&lt;p&gt;我们给提示框加上3个按键的功能，分别是回车和上下键，使得可以通过键盘操作进行提示框的选择&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当有提示框的时候，默认第一个提示为被选择状态，用一个和鼠标滑过不一样的背景色来标识&lt;/li&gt;
&lt;li&gt;当有输入框的时候，按上键，可以向上移动选择状态，如果按键之前的被选择提示是第一个，则被选状态移到最下面一个&lt;/li&gt;
&lt;li&gt;当有输入框的时候，按下键，可以向下移动选择状态，如果按键之前的被选择提示是最后一个，则被选状态移到第一个&lt;/li&gt;
&lt;li&gt;当有输入框时，按回车键，则将当前被选中状态的提示内容，放到输入框中，并隐藏提示框&lt;/li&gt;
&lt;li&gt;当没有输入框的时候，这3个键盘按键无响应&lt;/li&gt;
&lt;li&gt;当用户输入发生改变的时候，选择状态都重新切回到第一个提示&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;-&quot;&gt;优化体验&lt;/h3&gt;
&lt;h4 id=&quot;-&quot;&gt;需求&lt;/h4&gt;
&lt;p&gt;当我们进入页面，或者当我们点击鼠标进行提示选择后，输入框的焦点就不在了，所以请你优化一下用户体验：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一进入页面就将焦点放在输入框中&lt;/li&gt;
&lt;li&gt;用户点击鼠标，进行提示选择后，焦点依然在输入框中&lt;/li&gt;
&lt;li&gt;用户按ESC键的时候，对用户输入进行全选&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;代码3&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &amp;lt;!DOCTYPE html&amp;gt;
&lt;span&gt;  2&lt;/span&gt; &amp;lt;html&amp;gt;
&lt;span&gt;  3&lt;/span&gt; 
&lt;span&gt;  4&lt;/span&gt; &amp;lt;head&amp;gt;
&lt;span&gt;  5&lt;/span&gt;     &amp;lt;meta charset=&quot;utf-8&quot; /&amp;gt;
&lt;span&gt;  6&lt;/span&gt;     &amp;lt;title&amp;gt;邮箱后缀提示3-添加键盘响应及输入框焦点优化&amp;lt;/title&amp;gt;
&lt;span&gt;  7&lt;/span&gt;     &amp;lt;style&amp;gt;
&lt;span&gt;  8&lt;/span&gt;         #input-&lt;span&gt;email{
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt; &lt;span&gt;        width: 300px;
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt; &lt;span&gt;        height: 30px;
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt;     .email-&lt;span&gt;sug{
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt; &lt;span&gt;        width: 300px;
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt;         list-&lt;span&gt;style: none;
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt; &lt;span&gt;        padding: 0px;
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt; &lt;span&gt;        margin: 0px;
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt;         border: 2px solid rgba(134, 132, 132,0.3&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt;         border-&lt;span&gt;top:none;
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt; &lt;span&gt;        display: none;
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt;         &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 初始不显示，避免边框出现 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 21&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt;     .email-&lt;span&gt;sug li{
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt; &lt;span&gt;        width: 300px;
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt; &lt;span&gt;        height: 30px;
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt;         background-&lt;span&gt;color: #ffffff;
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt; &lt;span&gt;        color: darkgrey;
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt;         line-&lt;span&gt;height: 30px;    
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt; &lt;span&gt;        overflow: hidden;
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt;         padding-&lt;span&gt;left: 10px;
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt;         box-sizing: border-&lt;span&gt;box;
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt;     .email-&lt;span&gt;sug li:hover{
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt;         background-&lt;span&gt;color:skyblue;
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt;     .email-&lt;span&gt;sug li.active{
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt;         background-&lt;span&gt;color:pink;
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt;     &amp;lt;/style&amp;gt;
&lt;span&gt; 39&lt;/span&gt; &amp;lt;/head&amp;gt;
&lt;span&gt; 40&lt;/span&gt; 
&lt;span&gt; 41&lt;/span&gt; &amp;lt;body&amp;gt;
&lt;span&gt; 42&lt;/span&gt;     &amp;lt;div class=&quot;wrapper&quot;&amp;gt;
&lt;span&gt; 43&lt;/span&gt;         &amp;lt;input type=&quot;text&quot; id=&quot;input-email&quot; autofocus=&quot;autofocus&quot;&amp;gt;
&lt;span&gt; 44&lt;/span&gt;         &amp;lt;ul class=&quot;email-sug&quot; id=&quot;email-sug-wrapper&quot;&amp;gt;
&lt;span&gt; 45&lt;/span&gt; 
&lt;span&gt; 46&lt;/span&gt;         &amp;lt;/ul&amp;gt;
&lt;span&gt; 47&lt;/span&gt;     &amp;lt;/div&amp;gt;
&lt;span&gt; 48&lt;/span&gt;     &amp;lt;script&amp;gt;
&lt;span&gt; 49&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; postfixList = [&quot;163.com&quot;, &quot;gmail.com&quot;, &quot;126.com&quot;, &quot;qq.com&quot;, &quot;263.net&quot;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; txt = document.getElementById(&quot;input-email&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; sug = document.getElementById(&quot;email-sug-wrapper&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; nowSelectTipIndex = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt; 
&lt;span&gt; 54&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取输入文本&lt;/span&gt;
&lt;span&gt; 55&lt;/span&gt;         txt.oninput = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (e) {
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt;             console.log(&quot;event handle4&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;按下的是内容，则重置选中状态，坐标清零，避免光标位置已经计算存入。&lt;/span&gt;
&lt;span&gt; 58&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (!(e.keyCode == 40 || e.keyCode == 38 || e.keyCode == 13&lt;span&gt;)) {
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt;                 nowSelectTipIndex = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt; &lt;span&gt;            judge();
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt; &lt;span&gt;            add();
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;点击事件响应&lt;/span&gt;
&lt;span&gt; 65&lt;/span&gt;         sug.addEventListener(&quot;click&quot;, &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (ev) {
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;采用事件代理，监听父级点击事件，通过target获取当前li&lt;/span&gt;
&lt;span&gt; 67&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; ev = ev ||&lt;span&gt; window.event;
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; target = ev.target ||&lt;span&gt; ev.srcElement;
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (target.nodeName.toLowerCase() == &quot;li&quot;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt; &lt;span&gt;                hide();
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt;                 txt.focus(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;写在return之前，不然无效&lt;/span&gt;
&lt;span&gt; 72&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; txt.value = htmlDecode(target.innerHTML); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;解码&lt;/span&gt;
&lt;span&gt; 73&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;return txt.value= target.innerHTML;      &lt;/span&gt;
&lt;span&gt; 74&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt; &lt;span&gt;        })
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;键盘事件响应&lt;/span&gt;
&lt;span&gt; 77&lt;/span&gt;         document.addEventListener(&quot;keydown&quot;, &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (e) {
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; e = e ||&lt;span&gt; window.event;
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; key = e.which ||&lt;span&gt; e.keyCode;
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; list = document.getElementsByTagName(&quot;li&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;向下键&lt;/span&gt;
&lt;span&gt; 82&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (key == 40&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt; (i = 0; i &amp;lt; list.length; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt;                     list[i].setAttribute(&quot;class&quot;, &quot;&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt;                 nowSelectTipIndex++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (nowSelectTipIndex + 1 &amp;gt;&lt;span&gt; list.length) {
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt;                     nowSelectTipIndex = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt;                 list[nowSelectTipIndex].setAttribute(&quot;class&quot;, &quot;active&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;向上键&lt;/span&gt;
&lt;span&gt; 93&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (key == 38&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt; (i = 0; i &amp;lt; list.length; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt;                     list[i].setAttribute(&quot;class&quot;, &quot;&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt;                 nowSelectTipIndex--&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (nowSelectTipIndex &amp;lt; 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt;                     nowSelectTipIndex = list.length - 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt;                 list[nowSelectTipIndex].setAttribute(&quot;class&quot;, &quot;active&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;回车键&lt;/span&gt;
&lt;span&gt;104&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (key == 13&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; x = document.getElementsByClassName(&quot;active&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt;                 txt.value = htmlDecode(x[0].innerHTML); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;用textcontent会去除html标签例如&amp;lt;b&amp;gt;。。&lt;/span&gt;
&lt;span&gt;107&lt;/span&gt; &lt;span&gt;                hide();
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (key == 27&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt;                 txt.setSelectionRange(0, -1); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;ESC全选上文本框内容&lt;/span&gt;
&lt;span&gt;111&lt;/span&gt; &lt;span&gt;                hide();
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt; 
&lt;span&gt;114&lt;/span&gt; &lt;span&gt;        })
&lt;/span&gt;&lt;span&gt;115&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取输入内容，并去除首尾空格&lt;/span&gt;
&lt;span&gt;116&lt;/span&gt;         &lt;span&gt;function&lt;/span&gt;&lt;span&gt; getText() {
&lt;/span&gt;&lt;span&gt;117&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; inputText =&lt;span&gt; txt.value.trim();
&lt;/span&gt;&lt;span&gt;118&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; inputText;
&lt;/span&gt;&lt;span&gt;119&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;120&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断是否生成新的数组&lt;/span&gt;
&lt;span&gt;121&lt;/span&gt;         &lt;span&gt;function&lt;/span&gt;&lt;span&gt; postlist() {
&lt;/span&gt;&lt;span&gt;122&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; userinput =&lt;span&gt; getText();
&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; newpostlist = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Array();
&lt;/span&gt;&lt;span&gt;124&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (userinput.search('@') != 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;125&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; len = userinput.search('@'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;126&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;用来拼接的用户输入内容 = 只使用@之后的字符串&lt;/span&gt;
&lt;span&gt;127&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; x = userinput.substring(len + 1, userinput.length); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;取@之后的部分&lt;/span&gt;
&lt;span&gt;128&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; postfixList.length; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;129&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (postfixList[i].search(x) == 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;130&lt;/span&gt; &lt;span&gt;                        newpostlist.push(postfixList[i]);
&lt;/span&gt;&lt;span&gt;131&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;132&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;133&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;若@后面没有字符或者新数组newpostlist为空，就返回原来的postfixlist&lt;/span&gt;
&lt;span&gt;134&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (x === '' || newpostlist == ''&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;135&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; postfixList;
&lt;/span&gt;&lt;span&gt;136&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;137&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; newpostlist;
&lt;/span&gt;&lt;span&gt;138&lt;/span&gt;             } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;139&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; postfixList;
&lt;/span&gt;&lt;span&gt;140&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;141&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;142&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据输入内容和匹配来生成提示数组&lt;/span&gt;
&lt;span&gt;143&lt;/span&gt;         &lt;span&gt;function&lt;/span&gt;&lt;span&gt; promptContent() {
&lt;/span&gt;&lt;span&gt;144&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; x = htmlEncode(getText()); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;转码;&lt;/span&gt;
&lt;span&gt;145&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; var x=getText();&lt;/span&gt;
&lt;span&gt;146&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; tips = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Array();
&lt;/span&gt;&lt;span&gt;147&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (x.indexOf(&quot;@&quot;) != -1&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;148&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; p = x.slice(0, x.indexOf(&quot;@&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;149&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt; (i = 0; i &amp;lt; postlist().length; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;150&lt;/span&gt;                     tips[i] = p + &quot;@&quot; +&lt;span&gt; postlist()[i];
&lt;/span&gt;&lt;span&gt;151&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;152&lt;/span&gt;             } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;153&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt; (i = 0; i &amp;lt; postfixList.length; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;154&lt;/span&gt;                     tips[i] = x + &quot;@&quot; +&lt;span&gt; postfixList[i];
&lt;/span&gt;&lt;span&gt;155&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;156&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;157&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; tips;
&lt;/span&gt;&lt;span&gt;158&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;159&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加提示数组进入li&lt;/span&gt;
&lt;span&gt;160&lt;/span&gt;         &lt;span&gt;function&lt;/span&gt;&lt;span&gt; add() {
&lt;/span&gt;&lt;span&gt;161&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; sug = document.getElementById(&quot;email-sug-wrapper&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;162&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; tips =&lt;span&gt; promptContent();
&lt;/span&gt;&lt;span&gt;163&lt;/span&gt;             &lt;span&gt;while&lt;/span&gt;&lt;span&gt; (sug.hasChildNodes()) {
&lt;/span&gt;&lt;span&gt;164&lt;/span&gt; &lt;span&gt;                sug.removeChild(sug.firstChild);
&lt;/span&gt;&lt;span&gt;165&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;166&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将之前的列表清除掉，然后重新生成新的列表&lt;/span&gt;
&lt;span&gt;167&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (i = 0; i &amp;lt; tips.length; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;168&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; tip_li = document.createElement(&quot;li&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;169&lt;/span&gt;                 tip_li.innerHTML =&lt;span&gt; tips[i];
&lt;/span&gt;&lt;span&gt;170&lt;/span&gt; &lt;span&gt;                sug.appendChild(tip_li);
&lt;/span&gt;&lt;span&gt;171&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;172&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始选择第一项为选中状态，加类名变粉色（需要生成li之后再调用）。&lt;/span&gt;
&lt;span&gt;173&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; list = document.getElementsByTagName(&quot;li&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;174&lt;/span&gt;             list[0].setAttribute(&quot;class&quot;, &quot;active&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;175&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;176&lt;/span&gt; 
&lt;span&gt;177&lt;/span&gt;         &lt;span&gt;function&lt;/span&gt;&lt;span&gt; judge() {
&lt;/span&gt;&lt;span&gt;178&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;判空，是“”没有内容，不能为“　”&lt;/span&gt;
&lt;span&gt;179&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (getText() == &quot;&quot;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;180&lt;/span&gt; &lt;span&gt;                hide();
&lt;/span&gt;&lt;span&gt;181&lt;/span&gt;             } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;182&lt;/span&gt; &lt;span&gt;                display();
&lt;/span&gt;&lt;span&gt;183&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;184&lt;/span&gt; 
&lt;span&gt;185&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;186&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;控制提示列表隐藏&lt;/span&gt;
&lt;span&gt;187&lt;/span&gt;         &lt;span&gt;function&lt;/span&gt;&lt;span&gt; hide() {
&lt;/span&gt;&lt;span&gt;188&lt;/span&gt;             sug.style.display = &quot;none&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;189&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;190&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;控制提示列表显示  &lt;/span&gt;
&lt;span&gt;191&lt;/span&gt;         &lt;span&gt;function&lt;/span&gt;&lt;span&gt; display() {
&lt;/span&gt;&lt;span&gt;192&lt;/span&gt;             sug.style.display = &quot;block&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;193&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;194&lt;/span&gt; 
&lt;span&gt;195&lt;/span&gt;         &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;1.用浏览器内部转换器实现html转码&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;196&lt;/span&gt;         &lt;span&gt;function&lt;/span&gt;&lt;span&gt; htmlEncode(html) {
&lt;/span&gt;&lt;span&gt;197&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;1.首先动态创建一个容器标签元素，如DIV&lt;/span&gt;
&lt;span&gt;198&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; temp = document.createElement(&quot;div&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;199&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;2.然后将要转换的字符串设置为这个元素的innerText(ie支持)或者textContent(火狐，google支持)&lt;/span&gt;
&lt;span&gt;200&lt;/span&gt;             (temp.textContent != undefined) ? (temp.textContent = html) : (temp.innerText =&lt;span&gt; html);
&lt;/span&gt;&lt;span&gt;201&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;3.最后返回这个元素的innerHTML，即得到经过HTML编码转换的字符串了&lt;/span&gt;
&lt;span&gt;202&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; output =&lt;span&gt; temp.innerHTML;
&lt;/span&gt;&lt;span&gt;203&lt;/span&gt;             temp = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;204&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; output;
&lt;/span&gt;&lt;span&gt;205&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;206&lt;/span&gt;         &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;2.用浏览器内部转换器实现html解码&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;207&lt;/span&gt;         &lt;span&gt;function&lt;/span&gt;&lt;span&gt; htmlDecode(text) {
&lt;/span&gt;&lt;span&gt;208&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;1.首先动态创建一个容器标签元素，如DIV&lt;/span&gt;
&lt;span&gt;209&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; temp = document.createElement(&quot;div&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;210&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;2.然后将要转换的字符串设置为这个元素的innerHTML(ie，火狐，google都支持)&lt;/span&gt;
&lt;span&gt;211&lt;/span&gt;             temp.innerHTML =&lt;span&gt; text;
&lt;/span&gt;&lt;span&gt;212&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;3.最后返回这个元素的innerText(ie支持)或者textContent(火狐，google支持)，即得到经过HTML解码的字符串了。&lt;/span&gt;
&lt;span&gt;213&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; output = temp.innerText ||&lt;span&gt; temp.textContent;
&lt;/span&gt;&lt;span&gt;214&lt;/span&gt;             temp = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;215&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; output;
&lt;/span&gt;&lt;span&gt;216&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;217&lt;/span&gt;     &amp;lt;/script&amp;gt;
&lt;span&gt;218&lt;/span&gt; &amp;lt;/body&amp;gt;
&lt;span&gt;219&lt;/span&gt; 
&lt;span&gt;220&lt;/span&gt; &amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最终效果如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1486391/201812/1486391-20181212211528955-1897880762.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1486391/201812/1486391-20181212211533899-763587219.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1486391/201812/1486391-20181212211623416-795121256.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 12 Dec 2018 13:17:00 +0000</pubDate>
<dc:creator>JoeJoan</dc:creator>
<og:description>先来个基础的 需求 根据下面需求实现如示意图所示的邮箱输入提示功能，注意，根据要求只需实现下面功能 当用户没有任何输入时，提示框消失 当用户输入字符后，显示提示框，并且把用户输入的内容自动拼上邮箱后缀</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Joe-and-Joan/p/10111099.html</dc:identifier>
</item>
<item>
<title>被标记为事务的方法互相调用的坑（下） - CodeBear</title>
<link>http://www.cnblogs.com/CodeBear/p/10111045.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CodeBear/p/10111045.html</guid>
<description>&lt;p&gt;参考：https://www.iteye.com/topic/1122740&lt;/p&gt;
&lt;p&gt;上一节，主要分析了 被标记为事务的方法互相调用，事务失效的原因，思考比较多，这一节主要说说解决方案，思考会少一些。&lt;/p&gt;
&lt;h4 id=&quot;解决方案的核心-通过代理对象去调用方法&quot;&gt;解决方案的核心： 通过代理对象去调用方法&lt;/h4&gt;
&lt;h5 id=&quot;把方法放到不同的类&quot;&gt;1.把方法放到不同的类：&lt;/h5&gt;
&lt;p&gt;我们需要新建一个接口：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public interface OtherService {
    void insertCodeMonkey();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再定义一个类去实现这个接口：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Service
public class OtherServiceImpl implements OtherService {

    @Autowired
    AccountMapper mapper;

    @Override
    @Transactional(propagation=Propagation.REQUIRES_NEW)
    public void insertCodeMonkey() {
        Account account = new Account();
        account.setAccount(&quot;CodeMonkey&quot;);
        account.setPassword(&quot;CodeMonkey&quot;);
        mapper.insert(account);
        int a = 1 / 0;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改原本的实现类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Service
public class AccountSerivceImpl implements AccountService {

    @Autowired
    AccountMapper mapper;

    @Autowired
    OtherService otherService;

    @Transactional
    @Override
    public void insertCodeBear() {

        try {
            otherService.insertCodeMonkey();
        } catch (Exception e) {
            e.printStackTrace();
        }

        Account account = new Account();
        account.setAccount(&quot;CodeBear&quot;);
        account.setPassword(&quot;CodeBear&quot;);
        mapper.insert(account);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行，查看数据库：&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/15100432-674a626cf0933cb4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;br/&gt;只有一条数据，insertCodeBear方法执行成功了，insertCodeMonkey执行失败，并且回滚了。&lt;/p&gt;
&lt;p&gt;让我们再看看控制台的日志：&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/15100432-7bb566e4aee92cbf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到是开了两个事务去执行的。&lt;/p&gt;
&lt;p&gt;这种解决方案最简单，不需要了解其他东西，但是这种方案需要修改代码结构，本来两个方法都是属于同一个类的，现在需要强行把它们拆开。&lt;/p&gt;
&lt;h5 id=&quot;aopcontext&quot;&gt;2. AopContext：&lt;/h5&gt;
&lt;p&gt;我们的目标是要在实现类中获取本类的代理对象，Spring提供了Aop上下文，即：AopContext，通过AopContext，可以很方便的获取到代理对象：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Service
public class AccountSerivceImpl implements AccountService {

    @Autowired
    AccountMapper mapper;

    @Transactional
    @Override
    public void insertCodeBear() {
        try {
            ((AccountService)AopContext.currentProxy()).insertCodeMonkey();
        } catch (Exception ex) {
            ex.printStackTrace();
        }
        Account account = new Account();
        account.setAccount(&quot;CodeBear&quot;);
        account.setPassword(&quot;CodeBear&quot;);
        mapper.insert(account);
    }

    @Transactional(propagation = Propagation.REQUIRES_NEW)
    @Override
    public void insertCodeMonkey() {
        Account account = new Account();
        account.setAccount(&quot;CodeMonkey&quot;);
        account.setPassword(&quot;CodeMonkey&quot;);
        mapper.insert(account);
        int a = 1 / 0;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当写好代码，很愉快的去测试，发现竟然报错了:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/15100432-a4756f156df70e3b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;br/&gt;翻译下：不能找到当前的代理，需要设置exposeProxy属性为 true使其可以。&lt;/p&gt;
&lt;p&gt;expose字面意思就是 暴露。也就是说 我们需要允许暴露代理。&lt;/p&gt;
&lt;p&gt;我们需要在Spring Boot启动类上+一个注解：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@EnableAspectJAutoProxy(exposeProxy = true)
@SpringBootApplication
@MapperScan(basePackages = &quot;com.codebear.Dao&quot;)
public class SpringbootApplication {
    public static void main(String[] args) throws Exception {
        SpringApplication.run(SpringbootApplication.class, args);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再次运行：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/15100432-437afa266957273f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;确实是开启了两个事务去执行的。&lt;/p&gt;
&lt;p&gt;再看看数据库，也没有问题。&lt;/p&gt;
&lt;h5 id=&quot;applicationcontext&quot;&gt;3. ApplicationContext：&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;@Service
public class AccountSerivceImpl implements AccountService {

    @Autowired
    AccountMapper mapper;

    @Autowired
    ApplicationContext context;

    AccountService service;

    @PostConstruct
    private void setSelf() {
        service = context.getBean(AccountService.class);
    }

    @Transactional
    @Override
    public void insertCodeBear() {
        try {
            service.insertCodeMonkey();
        } catch (Exception e) {
            e.printStackTrace();
        }
        Account account = new Account();
        account.setAccount(&quot;CodeBear&quot;);
        account.setPassword(&quot;CodeBear&quot;);
        mapper.insert(account);
    }

    @Transactional(propagation = Propagation.REQUIRES_NEW)
    @Override
    public void insertCodeMonkey() {
        Account account = new Account();
        account.setAccount(&quot;CodeMonkey&quot;);
        account.setPassword(&quot;CodeMonkey&quot;);
        mapper.insert(account);
        int a = 1 / 0;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;验证的图片就省略了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;此方法不适用于prototype&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在这里，我用了一个@PostConstruct注解，在初始化的时候，会调用被@PostConstruct标记的方法(注意，仅仅是初始化的时候，才会被调用。以后都不会被调用了，大家可以打个断点试一下)，这里这么做的目的就是为了提升一下效率，不用每次都getBean。所以如果这个类是prototype的，就不适用这个方法了。如果是prototype的话，就在insertCodeBear方法中使用getBean方法吧。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;上两种方法比较方便，没有新建其他的接口或者是类，但是没有很好的封装获得Aop代理对象的过程，也不是很符合 迪比特法则，也就是最少知识原则。&lt;/em&gt;&lt;/p&gt;
&lt;h5 id=&quot;重写beanpostprocessor接口&quot;&gt;4. 重写BeanPostProcessor接口：&lt;/h5&gt;
&lt;p&gt;关于这个接口是做什么的，这里就不详细阐述了，简单的来说这是Spring提供的接口，我们可以通过重写它，在初始化Bean之前或者之后，自定义一些额外的逻辑。&lt;br/&gt;首先，我们需要定义一个接口：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public interface WeavingSelfProxy {
    void setSelfProxy(Object bean);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;要获得代理对象的类，需要去实现它：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Service
public class AccountSerivceImpl implements AccountService, WeavingSelfProxy {

    @Autowired
    AccountMapper mapper;

    AccountService service;

    @Override
    public void setSelfProxy(Object bean) {
        System.out.println(&quot;进入到setSelfProxy方法&quot;);
        service = (AccountService) bean;
    }

    @Transactional
    @Override
    public void insertCodeBear() {
        try {
            service.insertCodeMonkey();
        } catch (Exception e) {
            e.printStackTrace();
        }
        Account account = new Account();
        account.setAccount(&quot;CodeBear&quot;);
        account.setPassword(&quot;CodeBear&quot;);
        mapper.insert(account);
    }

    @Transactional(propagation = Propagation.REQUIRES_NEW)
    @Override
    public void insertCodeMonkey() {
        Account account = new Account();
        account.setAccount(&quot;CodeMonkey&quot;);
        account.setPassword(&quot;CodeMonkey&quot;);
        mapper.insert(account);
        int a = 1 / 0;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;重写BeanPostProcessor接口：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Component
public class SetSelfProxyProcessor implements BeanPostProcessor {
    @Override
    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
        return bean;
    }

    @Override
    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
        if(bean instanceof WeavingSelfProxy){
            System.out.println(&quot;实现了WeavingSelfProxy接口&quot;);
            ((WeavingSelfProxy) bean).setSelfProxy(bean);
        }
        return bean;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样就可以了，验证的图片也省略了。&lt;/p&gt;
&lt;p&gt;以上就是四种解决方案，可以说 各有千秋，没有哪个好，哪个坏，只有适不适合。&lt;/p&gt;
</description>
<pubDate>Wed, 12 Dec 2018 13:07:00 +0000</pubDate>
<dc:creator>CodeBear</dc:creator>
<og:description>参考：https://www.iteye.com/topic/1122740 上一节，主要分析了 被标记为事务的方法互相调用，事务失效的原因，思考比较多，这一节主要说说解决方案，思考会少一些。 解决方</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CodeBear/p/10111045.html</dc:identifier>
</item>
</channel>
</rss>