<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>【小菜学网络】集线器 - fasionchan</title>
<link>http://www.cnblogs.com/fasionchan/p/hub.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fasionchan/p/hub.html</guid>
<description>&lt;p&gt;采用以太网进行通信的主机，需要通过网线之类的介质连接到一起。那么，如何将多根网线连接在一起呢？最简单的方式是将所有网线接到一个 集线器 ( hub )上。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;81.20233463035&quot;&gt;
&lt;p&gt;采用以太网进行通信的主机，需要通过网线之类的介质连接到一起。那么，如何将多根网线连接在一起呢？&lt;/p&gt;
&lt;p&gt;最简单的方式是将所有网线接到一个 &lt;strong&gt;集线器&lt;/strong&gt; ( &lt;em&gt;hub&lt;/em&gt; )上，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.fasionchan.com/p/28989ca0f42ef7355edf5b54dec42503531e951b.png#width=360px&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;集线器构造&quot;&gt;集线器构造&lt;/h2&gt;
&lt;p&gt;集线器内部构造很简单，可以理解成只是把所有网线连接起来而已。换句话讲，集线器充当了 &lt;strong&gt;共用导线&lt;/strong&gt; 的功能。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.fasionchan.com/p/3ae868f8fff11deeceda6c2b260a1826ff46b772.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样一来，从某个端口发送出去的电信号，将被传送到所有其他端口：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.fasionchan.com/p/6395d50d727f8ae6193f4f84dce2771c03671852.jpg#width=455px&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注释：这里 &lt;strong&gt;端口&lt;/strong&gt; ( &lt;em&gt;port&lt;/em&gt; )是指集线器的插口，或称为网口。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;换句话讲，从一台主机发送出来的数据，将被传送到所有其他主机上。 以 &lt;em&gt;A&lt;/em&gt; 往 &lt;em&gt;B&lt;/em&gt; 发送数据为例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.fasionchan.com/p/3ef5c77fc619a69bf5af282dcb9766eeacfc5591.png#width=340px&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看起来就像 &lt;em&gt;A&lt;/em&gt; 发起了 &lt;strong&gt;广播&lt;/strong&gt; ，其他所有主机都可以收到这个数据。 由于数据帧中包含 &lt;strong&gt;目的地址&lt;/strong&gt; ，最终只有 &lt;em&gt;B&lt;/em&gt; 接收并处理这个数据。 因此并无大碍，至少是可以正常工作的。&lt;/p&gt;
&lt;p&gt;尽管如此，集线器还是存在一些缺陷，主要体现在两方面：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;所有主机(端口)共享带宽；&lt;/li&gt;
&lt;li&gt;所有主机(端口)处于同一 &lt;strong&gt;冲突域&lt;/strong&gt; (一台主机发送，其他只能等待)；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这两方面缺陷严重制约着集线器的传输效率，在接入端口数较多的情况下更是如此。&lt;/p&gt;
&lt;p&gt;总结一下，集线器工作于物理层，主要特点如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;扩展终端数量；&lt;/li&gt;
&lt;li&gt;中继放大物理信号；&lt;/li&gt;
&lt;li&gt;延伸网络传输距离；&lt;/li&gt;
&lt;li&gt;所有端口同属一个冲突域；&lt;/li&gt;
&lt;li&gt;所有端口共享带宽；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;【&lt;a href=&quot;https://fasionchan.com/network/&quot; target=&quot;_blank&quot;&gt;小菜学网络&lt;/a&gt;】系列文章首发于公众号【小菜学编程】，敬请关注：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.fasionchan.com/coding-fan-wechat-soso.png?x-oss-process=image/resize,w_359&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Mon, 18 Jan 2021 00:45:00 +0000</pubDate>
<dc:creator>fasionchan</dc:creator>
<og:description>采用以太网进行通信的主机，需要通过网线之类的介质连接到一起。那么，如何将多根网线连接在一起呢？最简单的方式是将所有网线接到一个 集线器 ( hub )上。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/fasionchan/p/hub.html</dc:identifier>
</item>
<item>
<title>万字长文爆肝 DNS 协议！ - 程序员cxuan</title>
<link>http://www.cnblogs.com/cxuanBlog/p/14291088.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cxuanBlog/p/14291088.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2021/01/17/ssOqKK.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;试想一个问题，我们人类可以有多少种识别自己的方式？可以通过身份证来识别，可以通过社保卡号来识别，也可以通过驾驶证来识别，尽管我们有多种识别方式，但在特定的环境下，某种识别方法可能比另一种方法更为适合。因特网上的主机和人类一样，可以使用多种识别方式进行标识。互联网上主机的一种标识方法是使用它的 &lt;code&gt;主机名(hostname)&lt;/code&gt; ，如 www.facebook.com、 www.google.com 等。但是这是我们人类的记忆方式，路由器不会这么理解，路由器喜欢定长的、有层次结构的 &lt;code&gt;IP地址&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如果你还不理解 IP 的话，可以翻阅一下我的这篇文章&lt;a href=&quot;https://github.com/crisxuan/bestJavaer/blob/master/network/computer-internet.md&quot; target=&quot;_blank&quot;&gt;计算机网络层&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;IP 地址现在简单表述一下，就是一个由 4 字节组成，并有着严格的层次结构。例如 &lt;code&gt;121.7.106.83&lt;/code&gt; 这样一个 IP 地址，其中的每个字节都可以用 &lt;code&gt;.&lt;/code&gt; 进行分割，表示了 &lt;code&gt;0 - 255&lt;/code&gt; 的十进制数字。&lt;/p&gt;
&lt;p&gt;然而，路由器喜欢的是 IP 地址进行解析，我们人类却便于记忆的是网址，那么路由器如何把 IP 地址解析为我们熟悉的网址地址呢？这时候就需要 &lt;code&gt;DNS&lt;/code&gt; 出现了。&lt;/p&gt;
&lt;img src=&quot;https://s3.ax1x.com/2021/01/17/ssO7gx.png&quot;/&gt;&lt;p&gt;DNS 的全称是 &lt;code&gt;Domain Name System,DNS&lt;/code&gt; ，它是一个由分层的 &lt;code&gt;DNS 服务器（DNS server）&lt;/code&gt;实现的分布式数据库；它还是一个使得主机能够查询分布式数据库的应用层协议。DNS 服务器通常是运行 &lt;code&gt;BIND(Berkeley Internet Name Domain)&lt;/code&gt; 软件的 UNIX 机器。DNS 协议运行在 &lt;code&gt;UDP&lt;/code&gt; 之上，使用 53 端口。&lt;/p&gt;
&lt;h2 id=&quot;dns-基本概述&quot;&gt;DNS 基本概述&lt;/h2&gt;
&lt;p&gt;与 HTTP、FTP 和 SMTP 一样，DNS 协议也是应用层的协议，DNS 使用&lt;code&gt;客户-服务器&lt;/code&gt;模式运行在通信的端系统之间，在通信的端系统之间通过下面的端到端运输协议来传送 DNS 报文。但是 DNS 不是一个直接和用户打交道的应用。DNS 是为因特网上的用户应用程序以及其他软件提供一种核心功能。&lt;/p&gt;
&lt;p&gt;DNS 通常不是一门独立的协议，它通常为其他应用层协议所使用，这些协议包括 HTTP、SMTP 和 FTP，将用户提供的主机名解析为 IP 地址。&lt;/p&gt;
&lt;p&gt;下面根据一个示例来描述一下这个 DNS 解析过程，这个和你输入网址后，浏览器做了什么操作有异曲同工之处&lt;/p&gt;
&lt;p&gt;你在浏览器键入 www.someschool.edu/index.html 时会发生什么现象？为了使用户主机能够将一个 HTTP 请求报文发送到 Web 服务器 www.someschool.edu ，会经历如下操作&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;同一台用户主机上运行着 DNS 应用的客户端&lt;/li&gt;
&lt;li&gt;浏览器从上述 URL 中抽取出主机名 www.someschool.edu ，并将这台主机名传给 DNS 应用的客户端&lt;/li&gt;
&lt;li&gt;DNS 客户向 DNS 服务器发送一个包含主机名的请求。&lt;/li&gt;
&lt;li&gt;DNS 客户最终会收到一份回答报文，其中包含该目标主机的 IP 地址&lt;/li&gt;
&lt;li&gt;一旦浏览器收到目标主机的 IP 地址后，它就能够向位于该 IP 地址 80 端口的 HTTP 服务器进程发起一个 TCP 连接。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;除了提供 IP 地址到主机名的转换，DNS 还提供了下面几种重要的服务&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;主机别名(host aliasing)&lt;/code&gt;，有着复杂的主机名的主机能够拥有一个或多个其他别名，比如说一台名为 relay1.west-coast.enterprise.com 的主机，同时会拥有 enterprise.com 和 www.enterprise.com 的两个主机别名，在这种情况下，relay1.west-coast.enterprise.com 也称为 &lt;code&gt;规范主机名&lt;/code&gt;，而主机别名要比规范主机名更加容易记忆。应用程序可以调用 DNS 来获得主机别名对应的规范主机名以及主机的 IP地址。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;邮件服务器别名(mail server aliasing)&lt;/code&gt;，同样的，电子邮件的应用程序也可以调用 DNS 对提供的主机名进行解析。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;负载分配(load distribution)&lt;/code&gt;，DNS 也用于冗余的服务器之间进行负载分配。繁忙的站点例如 &lt;code&gt;cnn.com&lt;/code&gt; 被冗余分布在多台服务器上，每台服务器运行在不同的端系统之间，每个都有着不同的 IP 地址。由于这些冗余的 Web 服务器，一个 IP 地址集合因此与同一个规范主机名联系。DNS 数据库中存储着这些 IP 地址的集合。由于客户端每次都会发起 HTTP 请求，所以 DNS 就会在所有这些冗余的 Web 服务器之间循环分配了负载。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;dns-工作概述&quot;&gt;DNS 工作概述&lt;/h2&gt;
&lt;p&gt;假设运行在用户主机上的某些应用程序（如 Web 浏览器或邮件阅读器） 需要将主机名转换为 IP 地址。这些应用程序将调用 DNS 的客户端，并指明需要被转换的主机名。用户主机上的 DNS 收到后，会使用 UDP 通过 53 端口向网络上发送一个 DNS 查询报文，经过一段时间后，用户主机上的 DNS 会收到一个主机名对应的 DNS 回答报文。因此，从用户主机的角度来看，DNS 就像是一个黑盒子，其内部的操作你无法看到。但是实际上，实现 DNS 这个服务的黑盒子非常复杂，它由分布于全球的大量 DNS 服务器以及定义了 DNS 服务器与查询主机通信方式的应用层协议组成。&lt;/p&gt;
&lt;p&gt;DNS 最早的设计是只有一台 DNS 服务器。这台服务器会包含所有的 DNS 映射。这是一种&lt;code&gt;集中式&lt;/code&gt;的设计，这种设计并不适用于当今的互联网，因为互联网有着数量巨大并且持续增长的主机，这种集中式的设计会存在以下几个问题&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;单点故障(a single point of failure)&lt;/code&gt;，如果 DNS 服务器崩溃，那么整个网络随之瘫痪。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;通信容量(traaffic volume)&lt;/code&gt;，单个 DNS 服务器不得不处理所有的 DNS 查询，这种查询级别可能是上百万上千万级&lt;/li&gt;
&lt;li&gt;&lt;code&gt;远距离集中式数据库(distant centralized database)&lt;/code&gt;，单个 DNS 服务器不可能 &lt;code&gt;邻近&lt;/code&gt; 所有的用户，假设在美国的 DNS 服务器不可能临近让澳大利亚的查询使用，其中查询请求势必会经过低速和拥堵的链路，造成严重的时延。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;维护(maintenance)&lt;/code&gt;，维护成本巨大，而且还需要频繁更新。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所以 DNS 不可能集中式设计，它完全没有可扩展能力，因此采用&lt;code&gt;分布式设计&lt;/code&gt;，所以这种设计的特点如下&lt;/p&gt;
&lt;h3 id=&quot;分布式、层次数据库&quot;&gt;分布式、层次数据库&lt;/h3&gt;
&lt;p&gt;首先分布式设计首先解决的问题就是 DNS 服务器的扩展性问题，因此 DNS 使用了大量的 DNS 服务器，它们的组织模式一般是层次方式，并且分布在全世界范围内。&lt;strong&gt;没有一台 DNS 服务器能够拥有因特网上所有主机的映射&lt;/strong&gt;。相反，这些映射分布在所有的 DNS 服务器上。&lt;/p&gt;
&lt;p&gt;大致来说有三种 DNS 服务器：&lt;code&gt;根 DNS 服务器&lt;/code&gt;、 &lt;code&gt;顶级域(Top-Level Domain, TLD) DNS 服务器&lt;/code&gt; 和 &lt;code&gt;权威 DNS 服务器&lt;/code&gt; 。这些服务器的层次模型如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2021/01/17/ssOLDO.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;假设现在一个 DNS 客户端想要知道 www.amazon.com 的 IP 地址，那么上面的域名服务器是如何解析的呢？首先，客户端会先根服务器之一进行关联，它将返回顶级域名 &lt;code&gt;com&lt;/code&gt; 的 TLD 服务器的 IP 地址。该客户则与这些 TLD 服务器之一联系，它将为 amazon.com 返回权威服务器的 IP 地址。最后，该客户与 amazom.com 权威服务器之一联系，它为 www.amazom.com 返回其 IP 地址。&lt;/p&gt;
&lt;h3 id=&quot;dns-层次结构&quot;&gt;DNS 层次结构&lt;/h3&gt;
&lt;p&gt;我们现在来讨论一下上面域名服务器的层次系统&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;根 DNS 服务器&lt;/code&gt; ，有 400 多个根域名服务器遍及全世界，这些根域名服务器由 13 个不同的组织管理。根域名服务器的清单和组织机构可以在 &lt;a href=&quot;https://root-servers.org/&quot; target=&quot;_blank&quot;&gt;https://root-servers.org/&lt;/a&gt; 中找到，根域名服务器提供 TLD 服务器的 IP 地址。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;顶级域 DNS 服务器&lt;/code&gt;，对于每个顶级域名比如 com、org、net、edu 和 gov 和所有的国家级域名 uk、fr、ca 和 jp 都有 TLD 服务器或服务器集群。所有的顶级域列表参见 &lt;a href=&quot;https://tld-list.com/&quot; target=&quot;_blank&quot;&gt;https://tld-list.com/&lt;/a&gt; 。TDL 服务器提供了权威 DNS 服务器的 IP 地址。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;权威 DNS 服务器&lt;/code&gt;，在因特网上具有公共可访问的主机，如 Web 服务器和邮件服务器，这些主机的组织机构必须提供可供访问的 DNS 记录，这些记录将这些主机的名字映射为 IP 地址。一个组织机构的权威 DNS 服务器收藏了这些 DNS 记录。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;dns-查询步骤&quot;&gt;DNS 查询步骤&lt;/h2&gt;
&lt;p&gt;下面我们描述一下 DNS 的查询步骤，从 DNS 解析 IP 再到 DNS 返回的一系列流程。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意：通常情况下 DNS 会将查找的信息缓存在浏览器或者计算机本地中，如果有相同的请求到来时，就不再会进行 DNS 查找，而会直接返回结果。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;通常情况下，DNS 的查找会经历下面这些步骤&lt;/p&gt;
&lt;ol readability=&quot;6.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;用户在浏览器中输入网址 &lt;code&gt;www.example.com&lt;/code&gt; 并点击回车后，查询会进入网络，并且由 DNS 解析器进行接收。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;DNS 解析器会向根域名发起查询请求，要求返回顶级域名的地址。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;根 DNS 服务器会注意到请求地址的前缀并向 DNS 解析器返回 com 的&lt;code&gt;顶级域名服务器(TLD)&lt;/code&gt; 的 IP 地址列表。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;然后，DNS 解析器会向 TLD 服务器发送查询报文&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;TLD 服务器接收请求后，会根据域名的地址把&lt;code&gt;权威 DNS 服务器&lt;/code&gt;的 IP 地址返回给 DNS 解析器。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;最后，DNS 解析器将查询直接发送到权威 DNS 服务器&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;权威 DNS 服务器将 IP 地址返回给 DNS 解析器&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;DNS 解析器将会使用 IP 地址响应 Web 浏览器&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;一旦 DNS 查找的步骤返回了 example.com 的 IP 地址，浏览器就可以请求网页了。&lt;/p&gt;
&lt;p&gt;整个流程如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2021/01/17/ssOObD.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;dns-解析器&quot;&gt;DNS 解析器&lt;/h3&gt;
&lt;p&gt;进行 DNS 查询的主机和软件叫做 &lt;code&gt;DNS 解析器&lt;/code&gt;，用户所使用的工作站和个人电脑都属于解析器。一个解析器要至少注册一个以上域名服务器的 IP 地址。DNS 解析器是 DNS 查找的第一站，其&lt;strong&gt;负责与发出初始请求的客户端打交道&lt;/strong&gt;。解析器启动查询序列，最终使 URL 转换为必要的 IP 地址。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2021/01/17/ssOHv6.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;DNS 递归查询和 DNS 递归解析器不同，该查询是指向需要解析该查询的 DNS 解析器发出请求。DNS 递归解析器是一种计算机，其接受递归查询并通过发出必要的请求来处理响应。&lt;/p&gt;
&lt;h3 id=&quot;dns-查询类型&quot;&gt;DNS 查询类型&lt;/h3&gt;
&lt;p&gt;DNS 查找中会出现三种类型的查询。通过组合使用这些查询，&lt;strong&gt;优化的 DNS 解析过程可缩短传输距离&lt;/strong&gt;。在理想情况下，可以使用缓存的记录数据，从而使 DNS 域名服务器能够直接使用非递归查询。&lt;/p&gt;
&lt;ol readability=&quot;4&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;code&gt;递归查询&lt;/code&gt;：在递归查询中，DNS 客户端要求 DNS 服务器（一般为 DNS 递归解析器）将使用所请求的资源记录响应客户端，或者如果解析器无法找到该记录，则返回错误消息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2021/01/17/ssOjVe.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;code&gt;迭代查询&lt;/code&gt;：在迭代查询中，如果所查询的 DNS 服务器与查询名称不匹配，则其将返回对较低级别域名空间具有权威性的 DNS 服务器的引用。然后，DNS 客户端将对引用地址进行查询。此过程继续使用查询链中的其他 DNS 服务器，直至发生错误或超时为止。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2021/01/17/ssOvUH.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;code&gt;非递归查询&lt;/code&gt;：当 DNS 解析器客户端查询 DNS 服务器以获取其有权访问的记录时通常会进行此查询，因为其对该记录具有权威性，或者该记录存在于其缓存内。DNS 服务器通常会缓存 DNS 记录，查询到来后能够直接返回缓存结果，以防止更多带宽消耗和上游服务器上的负载。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;dns-缓存&quot;&gt;DNS 缓存&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;DNS 缓存(DNS caching)&lt;/code&gt; 有时也叫做 &lt;code&gt;DNS 解析器缓存&lt;/code&gt;，它是&lt;strong&gt;由操作系统维护的临时数据库&lt;/strong&gt;，它包含有&lt;strong&gt;最近的网站和其他 Internet 域的访问记录&lt;/strong&gt;。也就是说， DNS 缓存只是计算机为了满足快速的响应速度而把已加载过的资源缓存起来，再次访问时可以直接快速引用的一项技术和手段。那么 DNS 的缓存是如何工作的呢？&lt;/p&gt;
&lt;h3 id=&quot;dns-缓存的工作流程&quot;&gt;DNS 缓存的工作流程&lt;/h3&gt;
&lt;p&gt;在浏览器向外部发出请求之前，计算机会拦截每个请求并在 DNS 缓存数据库中查找域名，该数据库包含有最近的域名列表，以及 DNS 首次发出请求时 DNS 为它们计算的地址。&lt;/p&gt;
&lt;h3 id=&quot;dns-缓存方式&quot;&gt;DNS 缓存方式&lt;/h3&gt;
&lt;p&gt;DNS 数据可缓存到各种不同的位置上，每个位置均将存储 DNS 记录，它的生存时间由 TTL(DNS 字段) 来决定。&lt;/p&gt;
&lt;h4 id=&quot;浏览器缓存&quot;&gt;浏览器缓存&lt;/h4&gt;
&lt;p&gt;现如今的 Web 浏览器设计默认将 DNS 记录缓存一段时间。因为越靠近 Web 浏览器进行 DNS 缓存，为检查缓存并向 IP 地址发出请求的次数就越少。发出对 DNS 记录的请求时，浏览器缓存是针对所请求的记录而检查的第一个位置。&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;chrome&lt;/code&gt; 浏览器中，你可以使用 chrome://net-internals/#dns 查看 DNS 缓存的状态。这是基于 Windows 下查询的，我的 Mac 电脑输入上面 url 后无法查看 DNS ，只能 &lt;code&gt;clear host cache&lt;/code&gt;，我也不知道为啥，可能是哪里设置的原因？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2021/01/17/ssXSPA.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;操作系统内核缓存&quot;&gt;操作系统内核缓存&lt;/h4&gt;
&lt;p&gt;在浏览器缓存查询后，会进行操作系统级 DNS 解析器的查询，操作系统级 DNS 解析器是 DNS 查询离开你的计算机前的第二站，也是本地查询的最后一个步骤。&lt;/p&gt;
&lt;h2 id=&quot;dns-报文&quot;&gt;DNS 报文&lt;/h2&gt;
&lt;p&gt;共同实现 DNS 分布式数据库的所有 DNS 服务器存储了&lt;code&gt;资源记录(Resource Record, RR)&lt;/code&gt;，RR 提供了主机名到 IP 地址的映射。每个 DNS 回答报文中会包含一条或多条资源记录。RR 记录用于回复客户端查询。&lt;/p&gt;
&lt;p&gt;资源记录是一个包含了下列字段的 4 元组&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;(Name, Value, Type, TTL)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;RR 会有不同的类型，下面是不同类型的 RR 汇总表&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;DNS RR 类型&lt;/th&gt;
&lt;th&gt;解释&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;6&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;A 记录&lt;/td&gt;
&lt;td&gt;IPv4 主机记录，用于将域名映射到 IPv4 地址&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;AAAA 记录&lt;/td&gt;
&lt;td&gt;IPv6 主机记录，用于将域名映射到 IPv6 地址&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;CNAME 记录&lt;/td&gt;
&lt;td&gt;别名记录，用于映射 DNS 域名的别名&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;MX 记录&lt;/td&gt;
&lt;td&gt;邮件交换器，用于将 DNS 域名映射到邮件服务器&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;PTR 记录&lt;/td&gt;
&lt;td&gt;指针，用于反向查找（IP地址到域名解析）&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;SRV 记录&lt;/td&gt;
&lt;td&gt;SRV记录，用于映射可用服务。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;DNS 有两种报文，一种是查询报文，一种是响应报文，并且这两种报文有着相同的格式，下面是 DNS 的报文格式&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2021/01/17/ssOx5d.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图显示了 DNS 的报文格式，其中事务 ID、标志、问题数量、回答资源记录数、权威名称服务器计数、附加资源记录数这六个字段是 DNS 的报文段首部，报文段首部一共有 12 个字节。&lt;/p&gt;
&lt;h3 id=&quot;报文段首部&quot;&gt;报文段首部&lt;/h3&gt;
&lt;p&gt;报文段首部是 DNS 报文的基础结构部分，下面我们对报文段首部中的每个字节进行描述&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;事务 ID: 事务 ID 占用 2 个字节。它是 DNS 的标识，又叫做 &lt;code&gt;标识符&lt;/code&gt;，对于请求报文和响应报文来说，这个字段的值是一样的，通过标识符可以区分 DNS 应答报文是对哪个请求进行响应的。&lt;/li&gt;
&lt;li&gt;标志：标志字段占用 2 个字节。标志字段有很多，而且也比较重要，下面列出来了所有的标志字段。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2021/01/17/ssXp8I.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;每个字段的含义如下&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;QR(Response)&lt;/code&gt;: 1 bit 的 QR 标识报文是查询报文还是响应报文，查询报文时 QR = 0，响应报文时 QR = 1。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;OpCode&lt;/code&gt;: 4 bit 的 OpCode 表示操作码，其中，0 表示标准查询，1 表示反向查询，2 表示服务器状态请求。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AA(Authoritative)&lt;/code&gt;: 1 bit 的 AA 代表授权应答，这个 AA 只在响应报文中有效，值为 1 时，表示名称服务器是权威服务器；值为 0 时，表示不是权威服务器。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TC(Truncated)&lt;/code&gt;: 截断标志位，值为 1 时，表示响应已超过 512 字节并且已经被截断，只返回前 512 个字节。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RD(Recursion Desired)&lt;/code&gt;: 这个字段是期望递归字段，该字段在查询中设置，并在响应中返回。该标志告诉名称服务器必须处理这个查询，这种方式被称为一个递归查询。如果该位为 0，且被请求的名称服务器没有一个授权回答，它将返回一个能解答该查询的其他名称服务器列表。这种方式被称为迭代查询。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RA(Recursion Available)&lt;/code&gt;: 可用递归字段，这个字段只出现在响应报文中。当值为 1 时，表示服务器支持递归查询。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;zero&lt;/code&gt;: 保留字段，在所有的请求和应答报文中，它的值必须为 0。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AD&lt;/code&gt;: 这个字段表示信息是否是已授权。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CD&lt;/code&gt;: 这个字段表示是否禁用安全检查。&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;rcode（Reply code）&lt;/code&gt;：这个字段是返回码字段，表示响应的差错状态。当值为 0 时，表示没有错误；当值为 1 时，表示报文格式错误（Format error），服务器不能理解请求的报文；当值为 2 时，表示域名服务器失败（Server failure），因为服务器的原因导致没办法处理这个请求；当值为 3 时，表示名字错误（Name Error），只有对授权域名解析服务器有意义，指出解析的域名不存在；当值为 4 时，表示查询类型不支持（Not Implemented），即域名服务器不支持查询类型；当值为 5 时，表示拒绝（Refused），一般是服务器由于设置的策略拒绝给出应答，如服务器不希望对某些请求者给出应答。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;相信读者跟我一样，只看这些字段没什么意思，下面我们就通过抓包的方式，看一下具体的 DNS 报文。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2021/01/17/ssXCxP.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在我们可以看一下具体的 DNS 报文，通过 &lt;code&gt;query&lt;/code&gt; 可知这是一个请求报文，这个报文的标识符是 &lt;code&gt;0xcd28&lt;/code&gt;，它的标志如下&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;QR = 0 实锤了这就是一个请求。&lt;/li&gt;
&lt;li&gt;然后是四个字节的 OpCode，它的值是 0，表示这是一个标准查询。&lt;/li&gt;
&lt;li&gt;因为这是一个查询请求，所以没有 AA 字段出现。&lt;/li&gt;
&lt;li&gt;然后是截断标志位 Truncated，表示没有被截断。&lt;/li&gt;
&lt;li&gt;紧随其后的 RD = 1，表示希望得到递归回答。&lt;/li&gt;
&lt;li&gt;请求报文中没有 RA 字段出现。&lt;/li&gt;
&lt;li&gt;然后是保留字段 zero。&lt;/li&gt;
&lt;li&gt;紧随其后的 0 表示未经身份验证的数据是不可接受的。&lt;/li&gt;
&lt;li&gt;没有 rcode 字段的值&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;然后我们看一下响应报文&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2021/01/17/ssXiKf.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，标志位也是 &lt;code&gt;0xcd28&lt;/code&gt;，可以说明这就是上面查询请求的响应。&lt;/p&gt;
&lt;p&gt;查询请求已经解释过的报文我们这里就不再说明了，现在只解释一下请求报文中没有的内容&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;紧随在 OpCode 后面的 AA 字段已经出现了，它的值为 0 ，表示不是权威 DNS 服务器的响应&lt;/li&gt;
&lt;li&gt;最后是 rcode 字段的响应，值为 0 时，表示没有错误。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;问题区域&quot;&gt;问题区域&lt;/h3&gt;
&lt;p&gt;问题区域通常指报文格式中查询问题的区域部分。这部分用来显示 DNS 查询请求的问题，包括查询类型和查询类&lt;/p&gt;
&lt;img src=&quot;https://s3.ax1x.com/2021/01/17/ssX92t.png&quot;/&gt;&lt;p&gt;这部分中每个字段的含义如下&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;查询名：指定要查询的域名，有时候也是 IP 地址，用于反向查询。&lt;/li&gt;
&lt;li&gt;查询类型：DNS 查询请求的资源类型，通常查询类型为 A 类型，表示由域名获取对应的 IP 地址。&lt;/li&gt;
&lt;li&gt;查询类：地址类型，通常为互联网地址，值为 1 。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;同样的，我们再使用 wireshark 查看一下问题区域&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2021/01/17/ssXEVg.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，这是对 mobile-gtalk.l.google.com 发起的 DNS 查询请求，查询类型是 A，那么得到的响应类型应该也是 A&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2021/01/17/ssXkqS.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，响应类型是 A ，查询类的值通常是 1、254 和 255，分别表示互联网类、没有此类和所有类，这些是我们感兴趣的值，其他值通常不用于 TCP/IP 网络。&lt;/p&gt;
&lt;h3 id=&quot;资源记录部分&quot;&gt;资源记录部分&lt;/h3&gt;
&lt;p&gt;资源记录部分是 DNS 报文的最后三个字段，包括回答问题区域、权威名称服务器记录、附加信息区域，这三个字段均采用一种称为资源记录的格式，如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2021/01/17/ssXFr8.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;资源记录部分的字段含义如下&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;域名：DNS 请求的域名。&lt;/li&gt;
&lt;li&gt;类型：资源记录的类型，与问题部分中的查询类型值是一样的。&lt;/li&gt;
&lt;li&gt;类：地址类型、与问题中的查询类值一样的。&lt;/li&gt;
&lt;li&gt;生存时间：以秒为单位，表示资源记录的生命周期。&lt;/li&gt;
&lt;li&gt;资源数据长度：资源数据的长度。&lt;/li&gt;
&lt;li&gt;资源数据：表示按查询段要求返回的相关资源记录的数据。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;资源记录部分只有在 DNS 响应包中才会出现。下面我们就来通过响应报文看一下具体的字段示例&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2021/01/17/ssXVaQ.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中，域名的值是 mobile-gtalk.l.google.com ，类型是 A，类是 1，生存时间是 5 秒，数据长度是 4 字节，资源数据表示的地址是 63.233.189.188。&lt;/p&gt;
&lt;h3 id=&quot;soa-记录&quot;&gt;SOA 记录&lt;/h3&gt;
&lt;p&gt;如果是权威 DNS 服务器的响应的话，会显示记录存储有关区域的重要信息，这种信息就是 &lt;code&gt;SOA&lt;/code&gt; 记录。所有 的DNS 区域都需要一个 SOA 记录才能符合 IETF 标准。 SOA 记录对于区域传输也很重要。&lt;/p&gt;
&lt;p&gt;SOA 记录除具有 DNS 解析器响应的字段外，还具有一些额外的字段，如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2021/01/17/ssXmPs.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;具体字段含义&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;PNAME&lt;/code&gt;：即 Primary Name Server，这是区域的主要名称服务器的名称。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RNAME&lt;/code&gt;：即 Responsible authority's mailbox，RNAME 代表管理员的电子邮件地址，@ 用 . 来表示，也就是说 admin.example.com 等同于 admin@example.com。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;序列号&lt;/code&gt;： 即 Serial Number ，区域序列号是该区域的唯一标识符。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;刷新间隔&lt;/code&gt;：即 Refresh Interval，在请求主服务器提供 SOA 记录以查看其是否已更新之前，辅助服务器应等待的时间（以秒为单位）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;重试间隔&lt;/code&gt;：服务器应等待无响应的主要名称服务器再次请求更新的时间。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;过期限制&lt;/code&gt;：如果辅助服务器在这段时间内没有收到主服务器的响应，则应停止响应对该区域的查询。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;上面提到了主要名称服务器和服务名称服务器，他们之间的关系如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2021/01/17/ssXZ5j.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这块我们主要解释了 RR 类型为 A(IPv4) 和 SOA 的记录，除此之外还有很多类型，这篇文章就不再详细介绍了，读者朋友们可以阅读 《TCP/IP 卷一 协议》和 cloudflare 的官网 &lt;a href=&quot;https://www.cloudflare.com/learning/dns/dns-records/&quot; target=&quot;_blank&quot;&gt;https://www.cloudflare.com/learning/dns/dns-records/&lt;/a&gt; 查阅，值得一提的是，cloudflare 是一个学习网络协议非常好的网站。&lt;/p&gt;
&lt;h2 id=&quot;dns-安全&quot;&gt;DNS 安全&lt;/h2&gt;
&lt;p&gt;几乎所有的网络请求都会经过 DNS 查询，而且 DNS 和许多其他的 Internet 协议一样，系统设计时并未考虑到安全性，并且存在一些设计限制，这为 DNS 攻击创造了机会。&lt;/p&gt;
&lt;p&gt;DNS 攻击主要有下面这几种方式&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第一种是 &lt;code&gt;Dos 攻击&lt;/code&gt;，这种攻击的主要形式是使重要的 DNS 服务器比如 TLD 服务器或者根域名服务器过载，从而无法响应权威服务器的请求，使 DNS 查询不起作用。&lt;/li&gt;
&lt;li&gt;第二种攻击形式是 &lt;code&gt;DNS 欺骗&lt;/code&gt;，通过改变 DNS 资源内容，比如伪装一个官方的 DNS 服务器，回复假的资源记录，从而导致主机在尝试与另一台机器连接时，连接至错误的 IP 地址。&lt;/li&gt;
&lt;li&gt;第三种攻击形式是 &lt;code&gt;DNS 隧道&lt;/code&gt;，这种攻击使用其他网络协议通过 DNS 查询和响应建立隧道。攻击者可以使用 SSH、TCP 或者 HTTP 将恶意软件或者被盗信息传递到 DNS 查询中，这种方式使防火墙无法检测到，从而形成 DNS 攻击。&lt;/li&gt;
&lt;li&gt;第四种攻击形式是 &lt;code&gt;DNS 劫持&lt;/code&gt;，在 DNS 劫持中，攻击者将查询重定向到其他域名服务器。这可以通过恶意软件或未经授权的 DNS 服务器修改来完成。尽管结果类似于 DNS 欺骗，但这是完全不同的攻击，因为它的目标是名称服务器上网站的 DNS 记录，而不是解析程序的缓存。&lt;/li&gt;
&lt;li&gt;第五章攻击形式是 &lt;code&gt;DDoS 攻击&lt;/code&gt;，也叫做分布式拒绝服务带宽洪泛攻击，这种攻击形式相当于是 Dos 攻击的升级版&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;那么该如何防御 DNS 攻击呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;防御 DNS 威胁的最广为人知的方法之一就是采用 &lt;code&gt;DNSSEC 协议&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;dnssec&quot;&gt;DNSSEC&lt;/h3&gt;
&lt;p&gt;DNSSEC 又叫做 &lt;code&gt;DNS 安全扩展&lt;/code&gt;，DNSSEC 通过对数据进行&lt;code&gt;数字签名&lt;/code&gt;来保护其有效性，从而防止受到攻击。它是由 IETF 提供的一系列 DNS 安全认证的机制。DNSSEC 不会对数据进行加密，它只会验证你所访问的站点地址是否有效。&lt;/p&gt;
&lt;h3 id=&quot;dns-防火墙&quot;&gt;DNS 防火墙&lt;/h3&gt;
&lt;p&gt;有一些攻击是针对服务器进行的，这就需要 DNS 防火墙的登场了，&lt;code&gt;DNS 防火墙&lt;/code&gt;是一种可以为 DNS 服务器提供许多安全和性能服务的工具。DNS 防火墙位于用户的 DNS 解析器和他们尝试访问的网站或服务的权威名称服务器之间。防火墙提供 &lt;code&gt;限速访问&lt;/code&gt;，以关闭试图淹没服务器的攻击者。如果服务器确实由于攻击或任何其他原因而导致停机，则 DNS 防火墙可以通过提供来自缓存的 DNS 响应来使操作员的站点或服务正常运行。&lt;/p&gt;
&lt;p&gt;除了上述两种防御手段外，本身 DNS 区域的运营商就会采取进步一措施保护 DNS 服务器，比如配置 DNS 基础架构，来防止 DDoS 攻击。&lt;/p&gt;
&lt;p&gt;更多关于 DNS 的攻击和防御就是网络安全的主题，这篇文章就不再详细介绍了。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;这篇文章我用较多的字数为你介绍了 DNS 的基本概述，DNS 的工作机制，DNS 的查询方式，DNS 的缓存机制，我们还通过 WireShark 抓包带你认识了一下 DNS 的报文，最后我为你介绍了 DNS 的攻击手段和防御方式。&lt;/p&gt;
&lt;p&gt;这是一篇入门 DNS 较全的文章，花了我一周多的时间来写这篇文章，这篇文章了解清楚后，基本上 DNS 的大部分问题你应该都能够回答，面试我估计也稳了。&lt;/p&gt;
&lt;p&gt;如果这篇文章读者们觉得还不错，跪求点赞、留言，你的支持将是我继续肝文的动力！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;另外，添加我的微信 becomecxuan，加入每日一题群，每天一道面试题分享，更多内容请参见我的 Github，&lt;a href=&quot;https://github.com/crisxuan/bestJavaer/blob/master/network/computer-internet.md&quot; target=&quot;_blank&quot;&gt;成为最好的 bestJavaer&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我自己肝了六本 PDF，微信搜索「程序员cxuan」关注公众号后，在后台回复 cxuan ，领取全部 PDF，这些 PDF 如下&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://s3.ax1x.com/2020/11/30/DgOK6f.png&quot; target=&quot;_blank&quot;&gt;六本 PDF 链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202011/1515111-20201130090550310-1032998206.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 18 Jan 2021 00:42:00 +0000</pubDate>
<dc:creator>程序员cxuan</dc:creator>
<og:description>试想一个问题，我们人类可以有多少种识别自己的方式？可以通过身份证来识别，可以通过社保卡号来识别，也可以通过驾驶证来识别，尽管我们有多种识别方式，但在特定的环境下，某种识别方法可能比另一种方法更为适合。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cxuanBlog/p/14291088.html</dc:identifier>
</item>
<item>
<title>【项目实践】手把手带你搞定SSM - RudeCrab</title>
<link>http://www.cnblogs.com/RudeCrab/p/14291084.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/RudeCrab/p/14291084.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;以项目驱动学习，以实践检验真知&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;现在使用Java后端开发使用的技术栈基本上比较统一：Spring + SpringMVC + Mybatis，即大家常说的SSM。虽然现在流行的做法是使用SpringBoot来快速搭建、配置好SSM项目，但还是有必要知道如何不用SpringBoot来组合好这三者，因为SpringBoot也只是帮助我们做好了许多配置，并不是说舍弃掉了那些配置，所以知道原生的SSM如何整合可以更好帮助我们理解SSM也能更好的理解SpringBoot带来的好处！而且有的老项目就是没有用SpringBoot，如果你对原生SSM整合与配置一无所知那维护老项目起来会极其难受。&lt;/p&gt;
&lt;p&gt;SSM整合相比起SpringBoot的快速搭建自然是繁琐无比，但是不用担心，本文会一步一步演示如何整合这三者，并且会讲解每个配置的含义。老套路，文章最后还放上了思维导图和项目Github地址，&lt;strong&gt;clone下来即可直接运行，如果想自己做一个完整的SSM项目，直接用这套架子进行开发也是完全没问题的！&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;项目搭建&quot;&gt;项目搭建&lt;/h2&gt;
&lt;h3 id=&quot;创建项目&quot;&gt;创建项目&lt;/h3&gt;
&lt;p&gt;这里使用idea进行项目创建，maven来管理依赖包。首先我们在idea上新建一个project，选择Maven，然后选择web应用：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496775/202101/1496775-20210118083748176-1257745938.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击下一步后输入GroupId和ArtifactId后点击下一步直到完成。项目创建完毕后整个项目结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496775/202101/1496775-20210118083748564-854599442.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;配置web项目&quot;&gt;配置web项目&lt;/h3&gt;
&lt;p&gt;现在还先别着急配置SSM，我们先得配置一下这个idea下的web项目才行。大家也可以看到，项目建立起来后这个web.xml文件里写的是2.3版本，这个版本太老了，不行。&lt;/p&gt;
&lt;p&gt;我们按住&lt;code&gt;catl + shift + alt + S&lt;/code&gt;打开idea的Project Structure，然后点击左侧的Modules，再点击Web，然后点击右边的删除按钮，确定，最后点击APPLY先将这个默认的删除：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/news/1496775/202101/1496775-20210118083749120-846951733.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时我们会发现默认的web.xml文件已经被删除了。然后我们再点击右侧的添加按钮，点击web.xml进行添加：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496775/202101/1496775-20210118083749423-612198844.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里我们选择3.1版本，选择好后点击弹出框的OK，再点击下方的OK即可创建完毕：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496775/202101/1496775-20210118083749767-615731323.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;创建完毕后就会发现我们的web.xml内容已经变成了3.1了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/news/1496775/202101/1496775-20210118083750168-2110318472.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;建立项目结构&quot;&gt;建立项目结构&lt;/h3&gt;
&lt;p&gt;此时还先不要着急去配置SSM，我们现在项目连个基本的结构都没有呢，你核心代码写在哪，你测试在哪些，你资源放哪这些都是我们要去建立的。&lt;/p&gt;
&lt;p&gt;首先，我们在src路径下新建test文件夹，然后在src/main路径下新建java和resources文件夹。建立好文件夹后，右键点击文件夹，然后拖到下方，选择Mark Directory as，然后选择对应的目录结构。&lt;/p&gt;
&lt;p&gt;java文件夹对应SourcesRoot，代表标记为项目源代码路径，代码就写在这里。&lt;/p&gt;
&lt;p&gt;resources文件夹对应ResourcesRoot，代表标记为资源路径，所有资源比如配置文件就放在这。&lt;/p&gt;
&lt;p&gt;test文件夹对应TestSourcesRoot，代表标记为测试路径，测试代码都会放在这里。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496775/202101/1496775-20210118083750451-95754788.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;文件夹指定好后，我们就要在java文件夹下创建我们的代码包结构。包的话就分为最基本的controller、service、mapper、entity。包建好后目录结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496775/202101/1496775-20210118083750773-411266759.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;导入必备依赖包&quot;&gt;导入必备依赖包&lt;/h2&gt;
&lt;p&gt;基本的项目结构整理好后，接下来我们就要开始对SSM进行整合了。首先肯定要做的就是在pom.xml文件中导入必备的依赖包，直接复制粘贴就好了，各个地方都做了注释说明：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;properties&amp;gt;
    &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt;
    &amp;lt;maven.compiler.source&amp;gt;1.8&amp;lt;/maven.compiler.source&amp;gt;
    &amp;lt;maven.compiler.target&amp;gt;1.8&amp;lt;/maven.compiler.target&amp;gt;

    &amp;lt;!--统一配置jar包的版本--&amp;gt;
    &amp;lt;mysql.version&amp;gt;5.1.48&amp;lt;/mysql.version&amp;gt;
    &amp;lt;spring.version&amp;gt;5.2.0.RELEASE&amp;lt;/spring.version&amp;gt;
    &amp;lt;jackson.version&amp;gt;2.10.0&amp;lt;/jackson.version&amp;gt;
&amp;lt;/properties&amp;gt;

&amp;lt;dependencies&amp;gt;
    &amp;lt;!--单元测试，注意哦要4.12版本以上。scope为test代表只用来做测试，并不随版本打包发布此依赖包--&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;4.12&amp;lt;/version&amp;gt;
        &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;!--日志我们使用logback--&amp;gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;ch.qos.logback&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;logback-classic&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;1.2.3&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;!-- 简化Getter、Setter的工具lombok。非必需
    注意：使用lombok还要在idea上下载对应的插件--&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.projectlombok&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;lombok&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;1.18.10&amp;lt;/version&amp;gt;
        &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt;
    &amp;lt;/dependency&amp;gt;


    &amp;lt;!-- ***************数据库相关配置****************** --&amp;gt;
    &amp;lt;!-- mysql驱动依赖包，连接mysql必备--&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;${mysql.version}&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;!-- 数据源依赖包，能大幅提升性和便利性。这里我们用阿里的德鲁伊数据源--&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;com.alibaba&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;druid&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;1.1.12&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;!-- Mybatis必备依赖包 --&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.mybatis&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;mybatis&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;3.4.6&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;!-- ***************web相关配置****************** --&amp;gt;
    &amp;lt;!--配置JavaEE依赖包，包含了Servlet、Validation等功能--&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;javax&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;javaee-api&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;8.0&amp;lt;/version&amp;gt;
        &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;!-- JSTL依赖包，如果用将jstl标签用在jsp中就要此依赖包。非必需的 --&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;javax.servlet&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;jstl&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;1.2&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;!-- jackson依赖包,用来将java对象转换JSON格式，SpringMVC要用的 --&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;com.fasterxml.jackson.core&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;jackson-core&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;${jackson.version}&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;com.fasterxml.jackson.core&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;jackson-databind&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;${jackson.version}&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;com.fasterxml.jackson.core&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;jackson-annotations&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;${jackson.version}&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;!-- ***************Spring相关配置****************** --&amp;gt;
    &amp;lt;!--配置Spring JDBC容器所需的jar包--&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-jdbc&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;${spring.version}&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;!--配置Spring IOC容器所需的jar包--&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-context&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;${spring.version}&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;!--Spring mvc--&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-webmvc&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;${spring.version}&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;!-- AspectJ所需的jar包--&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.aspectj&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;aspectjweaver&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;1.9.4&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;!--Spring测试依赖--&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-test&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;${spring.version}&amp;lt;/version&amp;gt;
        &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;!--配置Spring整合mybatis的jar包--&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.mybatis&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;mybatis-spring&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;1.3.2&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;spring与mybatis整合&quot;&gt;Spring与Mybatis整合&lt;/h2&gt;
&lt;h3 id=&quot;数据库配置&quot;&gt;数据库配置&lt;/h3&gt;
&lt;p&gt;在进行整合之前我们来准备一下数据库，好接下来进行一个完整的演示。我这里用的是MySQL 5.7.25，咱们建立一个名为ssm_demo的数据库，执行语句新建一张user表并插入两条测试数据：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;CREATE TABLE `user` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键id',
  `name` varchar(255) COLLATE utf8mb4_bin NOT NULL COMMENT '账户名',
  `password` varchar(255) COLLATE utf8mb4_bin NOT NULL COMMENT '账户密码',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin;

INSERT INTO `user` VALUES (1, 'admin', '123456');
INSERT INTO `user` VALUES (2, 'rudecrab', '654321');
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们在entity包下建立和数据库表对应的实体类User：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Data // lombok注解，自动生成Getter、Setter、toString方法
public class User implements Serializable {
    private Long id;

    private String name;

    private String password;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们在resources文件夹下建立&lt;code&gt;database.properties&lt;/code&gt;文件来配置数据库连接的相关信息（这里根据自己的数据库信息配置哦），等下整合Mybatis要用到的：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-properties&quot;&gt;jdbc.driver=com.mysql.jdbc.Driver
jdbc.url=jdbc:mysql://127.0.0.1:3306/ssm_demo?characterEncoding=utf-8&amp;amp;useSSL=false&amp;amp;autoReconnect=true&amp;amp;rewriteBatchedStatements=true&amp;amp;serverTimezone=UTC
jdbc.username=root
jdbc.password=root
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;logback日志配置&quot;&gt;logback日志配置&lt;/h3&gt;
&lt;p&gt;真实项目中一般是要观察日志输出的，我们再配置一下日志。在resources目录下新建&lt;code&gt;logback.xml&lt;/code&gt;文件。&lt;strong&gt;注意啊，在尾部需要指定某个包，这个根据自己项目结构包名来设置&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&amp;gt;
&amp;lt;configuration&amp;gt;
    &amp;lt;!--定义日志文件输出地址--&amp;gt;
    &amp;lt;property name=&quot;LOG_ERROR_HOME&quot; value=&quot;error&quot;/&amp;gt;
    &amp;lt;property name=&quot;LOG_INFO_HOME&quot; value=&quot;info&quot;/&amp;gt;

    &amp;lt;!--通过appender标签指定日志的收集策略，我们会定义三个收集策略：控制台输出、普通信息文件输出、错误信息文件输出--&amp;gt;
    &amp;lt;!--name属性指定appender命名--&amp;gt;
    &amp;lt;!--class属性指定输出策略，通常有两种，控制台输出和文件输出，文件输出就是将日志进行一个持久化--&amp;gt;

    &amp;lt;!--控制台输出--&amp;gt;
    &amp;lt;appender name=&quot;CONSOLE_LOG&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&amp;gt;
        &amp;lt;!--使用该标签下的标签指定日志输出格式--&amp;gt;
        &amp;lt;encoder class=&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;&amp;gt;
            &amp;lt;!--
            %p:输出优先级，即DEBUG,INFO,WARN,ERROR,FATAL
            %r:输出自应用启动到输出该日志讯息所耗费的毫秒数
            %t:输出产生该日志事件的线程名
            %f:输出日志讯息所属的类别的类别名
            %c:输出日志讯息所属的类的全名
            %d:输出日志时间点的日期或时间，指定格式的方式： %d{yyyy-MM-dd HH:mm:ss}
            %l:输出日志事件的发生位置，即输出日志讯息的语句在他所在类别的第几行。
            %m:输出代码中指定的讯息，如log(message)中的message
            %n:输出一个换行符号
            --&amp;gt;
            &amp;lt;pattern&amp;gt;%red(%d{yyyy-MM-dd HH:mm:ss.SSS}) %yellow([%-5p]) %highlight([%t]) %boldMagenta([%C]) %green([%L]) %m%n&amp;lt;/pattern&amp;gt;
        &amp;lt;/encoder&amp;gt;
    &amp;lt;/appender&amp;gt;

    &amp;lt;!--普通信息文件输出--&amp;gt;
    &amp;lt;appender name=&quot;INFO_LOG&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&amp;gt;
        &amp;lt;!--通过使用该标签指定过滤策略--&amp;gt;
        &amp;lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&amp;gt;
            &amp;lt;!--标签指定过滤的类型--&amp;gt;
            &amp;lt;level&amp;gt;ERROR&amp;lt;/level&amp;gt;
            &amp;lt;onMatch&amp;gt;DENY&amp;lt;/onMatch&amp;gt;
            &amp;lt;onMismatch&amp;gt;ACCEPT&amp;lt;/onMismatch&amp;gt;
        &amp;lt;/filter&amp;gt;

        &amp;lt;encoder&amp;gt;
            &amp;lt;!--标签指定日志输出格式--&amp;gt;
            &amp;lt;pattern&amp;gt;[%d{yyyy-MM-dd' 'HH:mm:ss.SSS}] [%C] [%t] [%L] [%-5p] %m%n&amp;lt;/pattern&amp;gt;
        &amp;lt;/encoder&amp;gt;

        &amp;lt;!--标签指定收集策略，比如基于时间进行收集--&amp;gt;
        &amp;lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&amp;gt;
            &amp;lt;!--标签指定生成日志保存地址，通过这样配置已经实现了分类分天收集日志的目标了--&amp;gt;
            &amp;lt;fileNamePattern&amp;gt;${LOG_INFO_HOME}//%d.log&amp;lt;/fileNamePattern&amp;gt;
            &amp;lt;maxHistory&amp;gt;30&amp;lt;/maxHistory&amp;gt;
        &amp;lt;/rollingPolicy&amp;gt;
    &amp;lt;/appender&amp;gt;

    &amp;lt;!--错误信息文件输出--&amp;gt;
    &amp;lt;appender name=&quot;ERROR_LOG&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&amp;gt;
        &amp;lt;filter class=&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;&amp;gt;
            &amp;lt;level&amp;gt;ERROR&amp;lt;/level&amp;gt;
        &amp;lt;/filter&amp;gt;
        &amp;lt;encoder&amp;gt;
            &amp;lt;pattern&amp;gt;[%d{yyyy-MM-dd' 'HH:mm:ss.SSS}] [%C] [%t] [%L] [%-5p] %m%n&amp;lt;/pattern&amp;gt;
        &amp;lt;/encoder&amp;gt;

        &amp;lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&amp;gt;
            &amp;lt;fileNamePattern&amp;gt;${LOG_ERROR_HOME}//%d.log&amp;lt;/fileNamePattern&amp;gt;
            &amp;lt;maxHistory&amp;gt;30&amp;lt;/maxHistory&amp;gt;
        &amp;lt;/rollingPolicy&amp;gt;
    &amp;lt;/appender&amp;gt;

    &amp;lt;!--用来设置某一个包或具体的某一个类的日志打印级别--&amp;gt;
    &amp;lt;logger name=&quot;com.rudecrab.ssm.mapper&quot; level=&quot;DEBUG&quot;/&amp;gt;

    &amp;lt;!--必填标签，用来指定最基础的日志输出级别--&amp;gt;
    &amp;lt;root level=&quot;info&quot;&amp;gt;
        &amp;lt;!--添加append--&amp;gt;
        &amp;lt;appender-ref ref=&quot;CONSOLE_LOG&quot;/&amp;gt;
        &amp;lt;appender-ref ref=&quot;INFO_LOG&quot;/&amp;gt;
        &amp;lt;appender-ref ref=&quot;ERROR_LOG&quot;/&amp;gt;
    &amp;lt;/root&amp;gt;
&amp;lt;/configuration&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;mybatis全局设置&quot;&gt;Mybatis全局设置&lt;/h3&gt;
&lt;p&gt;现在我们开始终于可以进行Spring和Mybatis的整合了。我们先在resources文件夹下新建&lt;code&gt;mybatis-config.xml&lt;/code&gt;文件来对Mybatis进行全局配置，这里我习惯配置这些，根据自己的需求来就好：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
&amp;lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&amp;gt;
&amp;lt;configuration&amp;gt;
    &amp;lt;!--配置全局设置--&amp;gt;
    &amp;lt;settings&amp;gt;
        &amp;lt;!--启用日志，并指定日志实现方式--&amp;gt;
        &amp;lt;setting name=&quot;logImpl&quot; value=&quot;SLF4J&quot;/&amp;gt;

        &amp;lt;!--启用主键生成策略--&amp;gt;
        &amp;lt;setting name=&quot;useGeneratedKeys&quot; value=&quot;true&quot;/&amp;gt;

        &amp;lt;!--配置启用下划线转驼峰的映射--&amp;gt;
        &amp;lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&amp;gt;

        &amp;lt;!--启用二级缓存--&amp;gt;
        &amp;lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&amp;gt;
    &amp;lt;/settings&amp;gt;
&amp;lt;/configuration&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;spring-myabtis整合配置&quot;&gt;Spring-Myabtis整合配置&lt;/h3&gt;
&lt;p&gt;再来新建&lt;code&gt;spring-mybatis.xml&lt;/code&gt;文件，这个文件就是用来做整合的！&lt;strong&gt;注意啊，其中很多设置需要指定某个包，这个根据自己项目结构包名来设置&lt;/strong&gt;，注释写的很清楚了：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&amp;gt;

    &amp;lt;!--属性文件的读取，这里读取刚才我们的数据库连接相关配置--&amp;gt;
    &amp;lt;context:property-placeholder location=&quot;classpath:database.properties&quot; file-encoding=&quot;UTF-8&quot;/&amp;gt;

    &amp;lt;!--配置自动扫描，如果不配置这个那么就无法使用@Autowired加载bean--&amp;gt;
    &amp;lt;context:component-scan base-package=&quot;com.rudecrab.ssm&quot; use-default-filters=&quot;true&quot;&amp;gt;
        &amp;lt;!--这里要排除掉Controller的注解，Controller专门交给MVC去扫描，这样会就不会冲突--&amp;gt;
        &amp;lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&amp;gt;
    &amp;lt;/context:component-scan&amp;gt;

    &amp;lt;!--配置数据源--&amp;gt;
    &amp;lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&amp;gt;
        &amp;lt;!--配置JDBC基础属性，即数据库连接相关配置--&amp;gt;
        &amp;lt;property name=&quot;driverClassName&quot; value=&quot;${jdbc.driver}&quot;/&amp;gt;
        &amp;lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot;/&amp;gt;
        &amp;lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot;/&amp;gt;
        &amp;lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&amp;gt;

        &amp;lt;!--配置连接池的设置,这个是要根据真实项目情况来配置的，随着项目的发展会不断修改--&amp;gt;
        &amp;lt;property name=&quot;initialSize&quot; value=&quot;10&quot;/&amp;gt;
        &amp;lt;property name=&quot;maxActive&quot; value=&quot;100&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;

    &amp;lt;!--
    重点来了，这里配置是MyBatis的SqlSessionFactory，就是这一块配置将Spring和Mybatis整合到了一起
    如果不配置这里，你的mapper接口只能通过SqlSession来获取，十分麻烦。这里配置好后就可以通过Spring IoC来获取mapper接口了
    --&amp;gt;
    &amp;lt;bean class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot; id=&quot;sqlSessionFactory&quot;&amp;gt;
        &amp;lt;!--指定数据源--&amp;gt;
        &amp;lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&amp;gt;
        &amp;lt;!--加载mybatis全局设置，classpath即我们的资源路径resources--&amp;gt;
        &amp;lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&amp;gt;
        &amp;lt;!--配置Mybatis的映射xml文件路径--&amp;gt;
        &amp;lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:mapper/*.xml&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;

    &amp;lt;!--指定Mybatis的mapper接口扫描包--&amp;gt;
    &amp;lt;!--注意！！！如果用的是tk.mybatis自动生成的mapper接口，一定要将org.mybatis.改成tk.mybatis--&amp;gt;
    &amp;lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&amp;gt;
        &amp;lt;!--指定刚才我们配置好的sqlSessionFactory--&amp;gt;
        &amp;lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;/&amp;gt;
        &amp;lt;!--指定mapper接口扫描包--&amp;gt;
        &amp;lt;property name=&quot;basePackage&quot; value=&quot;com.rudecrab.ssm.mapper&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;

    &amp;lt;!--配置事务管理器，如果不配置这个，不启动事务扫描的话，那么发生了异常也不会触发回滚--&amp;gt;
    &amp;lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&amp;gt;
        &amp;lt;!--还得指定数据源--&amp;gt;
        &amp;lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;
    &amp;lt;!--启动事务的扫描--&amp;gt;
    &amp;lt;tx:annotation-driven/&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;junit测试&quot;&gt;JUnit测试&lt;/h3&gt;
&lt;p&gt;至此Spring和Myabtis已经整合配置好了，口说无凭，咱们还是得测试一下看下效果。在测试之前我们得先建立好mapper接口文件、myabtis映射xml文件、service接口和实现类：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/news/1496775/202101/1496775-20210118083751198-1324796407.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;UserMapper接口专门用来声明各种数据库操作方法，&lt;code&gt;@Repository&lt;/code&gt;注解将其定义为Spring所管理的Bean：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Repository
public interface UserMapper {
    /**
     * 从数据库中查询出所有的User对象
     * @return User对象集合
     */
    List&amp;lt;User&amp;gt; selectAll();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;UserMapper.xml映射文件用来写方法对应要执行的SQL语句：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&amp;gt;
&amp;lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &amp;gt;
&amp;lt;mapper namespace=&quot;com.rudecrab.ssm.mapper.UserMapper&quot;&amp;gt;
    &amp;lt;!--开启缓存--&amp;gt;
    &amp;lt;cache/&amp;gt;

    &amp;lt;!--从数据库中查询出所有的User对象--&amp;gt;
    &amp;lt;select id=&quot;selectAll&quot; resultType=&quot;com.rudecrab.ssm.entity.User&quot;&amp;gt;
        select * from user
    &amp;lt;/select&amp;gt;

&amp;lt;/mapper&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;UserService接口用来声明关于User的业务方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public interface UserService {
    /**
     * 从数据库中查询出所有的User对象
     * @return User对象集合
     */
    List&amp;lt;User&amp;gt; getAll();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;UserServiceImpl实体类用来实现关于User的业务逻辑，&lt;code&gt;@Service&lt;/code&gt;注解和&lt;code&gt;@Repository&lt;/code&gt;注解用处一样，将其定义为Bean。&lt;code&gt;@Transactional&lt;/code&gt;注解为声明式事务，如果该业务层的方法有异常抛出则会触发事务回滚。然后使用&lt;code&gt;@Autowired&lt;/code&gt;注解在私有属性上，自动加载Bean，无需我们手动创建UserMapper了：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Service
@Transactional(rollbackFor = Exception.class)
public class UserServiceImpl implements UserService {
    @Autowired
    private UserMapper userMapper;

    @Override
    public List&amp;lt;User&amp;gt; getAll() {
        return userMapper.selectAll();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;相关类和文件都建好了，现在我们在test文件夹下建立一个测试类UserServiceTest，&lt;strong&gt;一定要在测试类上加上那两个注解&lt;/strong&gt;，否则无法正常使用Spring相关功能：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = {&quot;classpath:spring-mybatis.xml&quot;})
public class UserServiceTest {
    @Autowired
    private UserService userService;

    @Test
    public void getAll() {
        System.out.println(userService.getAll());
        System.out.println(userService.getAll());
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行后我们就可以看到运行结果了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496775/202101/1496775-20210118083751463-1381176145.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到结果正常显示，并且日志也打印在了控制台上。&lt;strong&gt;这代表我们已经完成了Spring和Mybatis的整合！&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;思路&quot;&gt;思路&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496775/202101/1496775-20210118083751838-625943082.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;springmvc&quot;&gt;SpringMVC&lt;/h2&gt;
&lt;h3 id=&quot;spring-mvcxml&quot;&gt;spring-mvc.xml&lt;/h3&gt;
&lt;p&gt;我们接下来配置SpringMVC，在resources目录下新建&lt;code&gt;spring-mvc.xml&lt;/code&gt;文件进行配置。&lt;strong&gt;注意啊，其中设置需要指定某个包，这个根据自己项目结构包名来设置&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       https://www.springframework.org/schema/context/spring-context.xsd
       http://www.springframework.org/schema/mvc
       https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&amp;gt;

    &amp;lt;!--配置视图解析器，这样控制器里就直接返回文件名就好了--&amp;gt;
    &amp;lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&amp;gt;
        &amp;lt;!--前缀--&amp;gt;
        &amp;lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/views/&quot;/&amp;gt;
        &amp;lt;!--后缀--&amp;gt;
        &amp;lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;

    &amp;lt;!--配置静态资源过滤，不然静态资源比如css是访问不到的--&amp;gt;
    &amp;lt;mvc:default-servlet-handler/&amp;gt;

    &amp;lt;!--配置扫描的包--&amp;gt;
    &amp;lt;context:component-scan base-package=&quot;com.rudecrab.ssm.controller&quot; use-default-filters=&quot;false&quot;&amp;gt;
        &amp;lt;!--只扫描controller,实际开发中最好用这种方式来写，这边MVC就只扫描controller，就不会IOC那边冲突，否则事务会被覆盖，IOC那边就要排除这个controller--&amp;gt;
        &amp;lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&amp;gt;
    &amp;lt;/context:component-scan&amp;gt;

    &amp;lt;!--启用MVC的注解--&amp;gt;
    &amp;lt;mvc:annotation-driven/&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;webxml&quot;&gt;web.xml&lt;/h3&gt;
&lt;p&gt;最后一个配置自然就是在web.xml里进行整合了，主要配置三点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;配置Spring IOC容器，为了mybatis做准备&lt;/li&gt;
&lt;li&gt;配置SpringMVC的前端控制器&lt;/li&gt;
&lt;li&gt;配置字符编码过滤器&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot;
         version=&quot;3.1&quot;&amp;gt;

    &amp;lt;!--1.配置Spring IOC容器的创建，如果不配置这个，Mybatis就在web应用里无法使用--&amp;gt;
    &amp;lt;context-param&amp;gt;
        &amp;lt;param-name&amp;gt;contextConfigLocation&amp;lt;/param-name&amp;gt;
        &amp;lt;!--spring和mybatis整合配置文件路径--&amp;gt;
        &amp;lt;param-value&amp;gt;classpath:spring-mybatis.xml&amp;lt;/param-value&amp;gt;
    &amp;lt;/context-param&amp;gt;
    &amp;lt;listener&amp;gt;
        &amp;lt;listener-class&amp;gt;org.springframework.web.context.ContextLoaderListener&amp;lt;/listener-class&amp;gt;
    &amp;lt;/listener&amp;gt;

    &amp;lt;!--2.配置SpringMVC的前端控制器--&amp;gt;
    &amp;lt;servlet&amp;gt;
        &amp;lt;servlet-name&amp;gt;SpringMVC&amp;lt;/servlet-name&amp;gt;
        &amp;lt;servlet-class&amp;gt;org.springframework.web.servlet.DispatcherServlet&amp;lt;/servlet-class&amp;gt;
        &amp;lt;init-param&amp;gt;
            &amp;lt;param-name&amp;gt;contextConfigLocation&amp;lt;/param-name&amp;gt;
            &amp;lt;!--SpringMVC整合配置文件路径--&amp;gt;
            &amp;lt;param-value&amp;gt;classpath:spring-mvc.xml&amp;lt;/param-value&amp;gt;
        &amp;lt;/init-param&amp;gt;
        &amp;lt;load-on-startup&amp;gt;1&amp;lt;/load-on-startup&amp;gt;
    &amp;lt;/servlet&amp;gt;
    &amp;lt;servlet-mapping&amp;gt;
        &amp;lt;servlet-name&amp;gt;SpringMVC&amp;lt;/servlet-name&amp;gt;
        &amp;lt;url-pattern&amp;gt;/&amp;lt;/url-pattern&amp;gt;
    &amp;lt;/servlet-mapping&amp;gt;

    &amp;lt;!--3.配置字符编码过滤器--&amp;gt;
    &amp;lt;filter&amp;gt;
        &amp;lt;filter-name&amp;gt;encodingFilter&amp;lt;/filter-name&amp;gt;
        &amp;lt;filter-class&amp;gt;org.springframework.web.filter.CharacterEncodingFilter&amp;lt;/filter-class&amp;gt;
        &amp;lt;init-param&amp;gt;
            &amp;lt;param-name&amp;gt;encoding&amp;lt;/param-name&amp;gt;
            &amp;lt;param-value&amp;gt;UTF-8&amp;lt;/param-value&amp;gt;
        &amp;lt;/init-param&amp;gt;
        &amp;lt;init-param&amp;gt;
            &amp;lt;param-name&amp;gt;forceEncoding&amp;lt;/param-name&amp;gt;
            &amp;lt;param-value&amp;gt;true&amp;lt;/param-value&amp;gt;
        &amp;lt;/init-param&amp;gt;
    &amp;lt;/filter&amp;gt;
    &amp;lt;filter-mapping&amp;gt;
        &amp;lt;filter-name&amp;gt;encodingFilter&amp;lt;/filter-name&amp;gt;
        &amp;lt;url-pattern&amp;gt;/*&amp;lt;/url-pattern&amp;gt;
    &amp;lt;/filter-mapping&amp;gt;
&amp;lt;/web-app&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;最终测试&quot;&gt;最终测试&lt;/h3&gt;
&lt;p&gt;以上，所有的配置都弄好了，那么接下来咱们就跑一个最简单的web项目来看看是否整合成功！还记得我们在在&lt;code&gt;spring-mvc.xml&lt;/code&gt;文件中配置的视图解析前缀嘛，我们在&lt;strong&gt;/WEB-INF/views/&lt;/strong&gt;文件夹下新建一个index.jsp文件：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-jsp&quot;&gt;&amp;lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&amp;gt;
&amp;lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;首页-RudeCrab&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;%--循环提取userList中的元素--%&amp;gt;
&amp;lt;c:forEach var=&quot;user&quot; items=&quot;${userList}&quot;&amp;gt;
    &amp;lt;ul&amp;gt;
        &amp;lt;li&amp;gt;${user}&amp;lt;/li&amp;gt;
    &amp;lt;/ul&amp;gt;
&amp;lt;/c:forEach&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来再在controller包下新建一个控制器类来定义访问接口：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Controller
@RequestMapping(value = &quot;user&quot;)
public class UserController {
    @Autowired
    private UserService userService;

    @GetMapping(&quot;/getList&quot;)
    public String getList(Model model) {
        // 将数据存到model对象里，这样jsp就能访问数据
        model.addAttribute(&quot;userList&quot;, userService.getAll());
        // 返回jsp文件名
        return &quot;index&quot;;
    }

    @GetMapping(&quot;/getJson&quot;)
    @ResponseBody
    public List&amp;lt;User&amp;gt; getList() {
        // 如果想做前后端分离的话可以加上@ResponseBody注解，直接返回数据对象，这样前端就可以通过获取json来渲染数据了
        return userService.getAll();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们启动Tomcat，在浏览器中访问接口：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/news/1496775/202101/1496775-20210118083752357-194813007.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到我们成功的访问到了数据，至此SSM完全整合完毕！&lt;/p&gt;

&lt;h2 id=&quot;思维导图&quot;&gt;思维导图&lt;/h2&gt;
&lt;p&gt;整体的整合配置思路已经画好思维导图了，其中每个节点上都写好了比较详细的备注，可以下载文件后观看。文件放在末位的github地址中：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496775/202101/1496775-20210118083752607-547416551.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;github地址&quot;&gt;github地址&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/RudeCrab/rude-java&quot; target=&quot;_blank&quot;&gt;https://github.com/RudeCrab/rude-java&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;上面包含了整个项目，clone下来用idea打开即可运行！同时也放上了思维导图文件。如果对你有帮助麻烦点一个star，项目中还有其他的【项目实践】，将来我也会不断更新更多的项目实践！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496775/202101/1496775-20210108125800650-1747993399.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 18 Jan 2021 00:41:00 +0000</pubDate>
<dc:creator>RudeCrab</dc:creator>
<og:description>学习 Spring Boot 前先学习 SSM</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/RudeCrab/p/14291084.html</dc:identifier>
</item>
<item>
<title>《算法之美》总结 - 雪山飞猪</title>
<link>http://www.cnblogs.com/chenqionghe/p/14291083.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenqionghe/p/14291083.html</guid>
<description>&lt;p&gt;我们的生活会面临诸多选择，这就像苏格拉底让柏拉图去找麦穗，什么时机下手，才能摘到相对满意的？&lt;/p&gt;
&lt;p&gt;又比如说找房子。你的目标是把“看过的好房子被人挑走”和“还有好房子没来得及看”这两种遗憾的发生概率降到最低。&lt;/p&gt;
&lt;p&gt;大部分人都是靠直觉来做选择的，而直觉是最不靠谱的东西。&lt;br/&gt;用瑞·达利欧的《原则》来说，就是我们要有一个不管事情如何变化都可以参考的“原则”！&lt;br/&gt;yes，这东西叫“算法”。&lt;/p&gt;
&lt;p&gt;答案就是：37%法则。&lt;/p&gt;
&lt;p&gt;简单解释就是，你在看了37%的房子的时候，不要做出任何的决定。比如你准备花一个月的时间挑选房子，那么在前11天不要做出决定。这段时间你在为制定标准做准备，过了这个时间点，一旦你对某套房子的满意程度超过之前看过的所有房子，就立刻下手！！！&lt;/p&gt;
&lt;p&gt;这不是直觉，而是已经得到证实的最优解。数学上称之为：“最优停止”（optimal stopping）&lt;/p&gt;
&lt;p&gt;亮点来了，最优化停止理论是一夫一妻制催生的科学！！！&lt;br/&gt;我们可以用这个原则来指导选择对象的问题。&lt;/p&gt;
&lt;p&gt;比方说你想在5、6年内找到一个终生灵魂伴侣，近两年内就是你的观察期，这期间不要做任何选择。&lt;br/&gt;过了这个时期，一旦出现比之前更好更优秀的人，要毫不犹豫地选择ta。&lt;/p&gt;
&lt;p&gt;这一切的核心都是建立在，人们认为时间是有成本的，我们耗不起这种成本。&lt;/p&gt;
&lt;p&gt;柏拉图，就是算好这片麦田37%的距离，过了这个阶段，一旦出现比之前所有见过的麦穗好的，都要毫不犹豫地摘了，头也不回地冲出这片麦穗红尘。&lt;/p&gt;
&lt;p&gt;同样的问题，我们可以延伸到找工作、选择候选人、找车位、卖房子等等。&lt;/p&gt;
&lt;p&gt;这篇最优选择是个人觉得本书的最精华部分，除此之外的所有章节给内行人感觉原理讲的太过啰嗦。比如大排序、缓存、时间调度、贝叶斯、过拟合。。。&lt;br/&gt;站在外行人的角度看吧，可能有种高大上的感觉，但是他应该是看不大懂的？&lt;/p&gt;
&lt;p&gt;也有可能是翻译的原因，行文不够丝滑。&lt;/p&gt;
&lt;p&gt;老子曰：“大道至简”，如果不能简单地解释一个问题，那么你就没有完全理解它（所有搞技术的故弄玄虚扯一堆说不清楚的都是辣鸡，因为高手一定是化繁为简的，接地气的！）&lt;/p&gt;
&lt;p&gt;最后，用一句伏尔泰的话来结束吧：“完美是优秀的敌人”。&lt;br/&gt;太快出手会令你错失很多机会，始终坚持完美往往会一无所获，最好的期待是根据原则明智做选择，而不是完全感性无脑地去做选择，这样才能让人生的遗憾降至最低~&lt;/p&gt;
</description>
<pubDate>Mon, 18 Jan 2021 00:40:00 +0000</pubDate>
<dc:creator>雪山飞猪</dc:creator>
<og:description>我们的生活会面临诸多选择，这就像苏格拉底让柏拉图去找麦穗，什么时机下手，才能摘到相对满意的？ 又比如说找房子。你的目标是把“看过的好房子被人挑走”和“还有好房子没来得及看”这两种遗憾的发生概率降到最低</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/chenqionghe/p/14291083.html</dc:identifier>
</item>
<item>
<title>图像的加密与解密 - 不该相遇在秋天</title>
<link>http://www.cnblogs.com/fengyumeng/p/14290982.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fengyumeng/p/14290982.html</guid>
<description>&lt;h3&gt;图像加密与解密&lt;/h3&gt;
&lt;p&gt;图像加密解密使用的是按位异或的运算，一真一假方为真，全真全假皆为假。&lt;/p&gt;
&lt;p&gt;比方说，3和5进行按位异或，3的二进制为11，5的二进制为101，运算之后得到二进制110，换算成十进制也就是得到6，那么3、5、6这三个数字，任意两个进行按位异或运算都可以得出另一个。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; cv2
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;读取图像&lt;/span&gt;
img = cv2.imread(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;./lena.jpg&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;生成秘钥&lt;/span&gt;
key = np.random.randint(0,256,img.shape,dtype=&lt;span&gt;np.uint8)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;加密&lt;/span&gt;
secret =&lt;span&gt; cv2.bitwise_xor(img,key)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;解密&lt;/span&gt;
truth =&lt;span&gt; cv2.bitwise_xor(secret,key)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;显示图像&lt;/span&gt;
cv2.imshow(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;secret&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,secret)
cv2.imshow(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;truth&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,truth)
cv2.waitKey(0)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1181622/202101/1181622-20210118032241258-776618890.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;数字水印嵌入与提取&lt;/h3&gt;
&lt;p&gt;数字水印利用图像的位平面来实现，像素点最高为255，也就是8位二进制表示，每一位可以看成一个位面，高位代表的数字大，低位代表的数字小，整幅图像可以看成是由八个位平面堆叠而成，我们可以把水印图片嵌入到载体图片的最低层位平面。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; cv2
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;读取原始载体图像&lt;/span&gt;
lena=cv2.imread(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;./lena.jpg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;读取水印图像&lt;/span&gt;
watermark=cv2.imread(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;./watermark.png&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,0)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;将水印大于0的像素置为1&lt;/span&gt;
temp = watermark[:,:] &amp;gt;&lt;span&gt; 0
watermark[temp] &lt;/span&gt;= 1

&lt;span&gt;#&lt;/span&gt;&lt;span&gt;读取G通道 打算将水印嵌入本通道（想把水印藏到哪个通道都随意）&lt;/span&gt;
g_channel = lena[:,:,1&lt;span&gt;]

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;保留前7位 末位置为0&lt;/span&gt;
g_channel_1 = np.left_shift(np.right_shift(g_channel,1),1&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;嵌入载体图像&lt;/span&gt;
new_channel =&lt;span&gt; cv2.bitwise_or(g_channel_1,watermark)
lena[:,:,&lt;/span&gt;1] =&lt;span&gt; new_channel


&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;提取g通道&lt;/span&gt;
channel = lena[:,:,1&lt;span&gt;]

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;生成全1数组&lt;/span&gt;
temp1 = np.ones(channel.shape,dtype=&lt;span&gt;np.uint8)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;按位与运算，提取水印&lt;/span&gt;
water =&lt;span&gt; cv2.bitwise_and(temp1,channel)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;将1处理为255&lt;/span&gt;
w= water[:,:] &amp;gt;&lt;span&gt; 0
water[w] &lt;/span&gt;= 255

&lt;span&gt;#&lt;/span&gt;&lt;span&gt;显示嵌入水印的图像&lt;/span&gt;
cv2.imshow(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;img&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,lena)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;显示从图像中提取的水印&lt;/span&gt;
cv2.imshow(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;water&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,water)

cv2.waitKey()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1181622/202101/1181622-20210118032520783-2108810579.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;脸部打码与解码&lt;/h3&gt;
&lt;p&gt;脸部打码与解码是使用像素点进行按位运算的综合应用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;67&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; cv2
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;读取原始载体图像&lt;/span&gt;
lena = cv2.imread(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;./lena.jpg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

shape &lt;/span&gt;=&lt;span&gt; lena[:,:,0].shape

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;指定打码区域&lt;/span&gt;
mask = np.zeros(shape,dtype=&lt;span&gt;np.uint8)
mask[&lt;/span&gt;220:380,220:350] = 1

&lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取一个key,打码、解码所使用的密钥&lt;/span&gt;
key = np.random.randint(0,256,size=shape,dtype=&lt;span&gt;np.uint8)

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; encode(img):
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
    脸部打码
    :param img: 图像
    :return: 打码图
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
    key &lt;/span&gt;= globals()[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
    mask &lt;/span&gt;= globals()[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;mask&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 使用密钥key加密原始图像lena 整幅图被加密&lt;/span&gt;
    xor_img =&lt;span&gt; cv2.bitwise_xor(img, key)

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 打码区域的像素置为255 占满八位全1 按位与运算 使得打码区域保持原样 其他区域全黑&lt;/span&gt;
    and_face = cv2.bitwise_and(xor_img, mask * 255&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 通过反色后按位与运算 使脸部区域置为全0 其他区域保持原样&lt;/span&gt;
    no_face = cv2.bitwise_and(img, (1 - mask) * 255&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 两矩阵各像素相加 得到脸部打码图像&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; and_face +&lt;span&gt; no_face



&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; decode(img):
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
    脸部解码
    :param img: 图像
    :return: 解码图
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
    key &lt;/span&gt;= globals()[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
    mask &lt;/span&gt;= globals()[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;mask&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 与秘钥按位异或运算 解析出脸部打码区域&lt;/span&gt;
    xor_img =&lt;span&gt; cv2.bitwise_xor(img, key)

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 脸部区域保留 其他区域置为全黑&lt;/span&gt;
    and_face = cv2.bitwise_and(xor_img, mask * 255&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 打码图的脸部区域置为全黑 其他区域不变&lt;/span&gt;
    no_face = cv2.bitwise_and(img, (1 - mask) * 255&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 两矩阵各像素相加 得到脸部解码图像&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; and_face +&lt;span&gt; no_face


&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;脸部打码&lt;/span&gt;
b_channel =&lt;span&gt; encode(lena[:,:,0])
g_channel &lt;/span&gt;= encode(lena[:,:,1&lt;span&gt;])
r_channel &lt;/span&gt;= encode(lena[:,:,2&lt;span&gt;])
secret_img &lt;/span&gt;=&lt;span&gt; cv2.merge([b_channel,g_channel,r_channel])
cv2.imshow(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;secret_img&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,secret_img)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;脸部解码&lt;/span&gt;
b_channel =&lt;span&gt; decode(secret_img[:,:,0])
g_channel &lt;/span&gt;= decode(secret_img[:,:,1&lt;span&gt;])
r_channel &lt;/span&gt;= decode(secret_img[:,:,2&lt;span&gt;])
true_img &lt;/span&gt;=&lt;span&gt; cv2.merge([b_channel,g_channel,r_channel])
cv2.imshow(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;true_img&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,true_img)

cv2.waitKey()
cv2.destroyAllWindows()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1181622/202101/1181622-20210118032614186-1991153065.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 18 Jan 2021 00:29:00 +0000</pubDate>
<dc:creator>不该相遇在秋天</dc:creator>
<og:description>图像加密与解密 图像加密解密使用的是按位异或的运算，一真一假方为真，全真全假皆为假。 比方说，3和5进行按位异或，3的二进制为11，5的二进制为101，运算之后得到二进制110，换算成十进制也就是得到</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/fengyumeng/p/14290982.html</dc:identifier>
</item>
<item>
<title>你都用过SpringCloud的哪些组件，它们的原理是什么？ - 纪莫</title>
<link>http://www.cnblogs.com/jimoer/p/14289723.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jimoer/p/14289723.html</guid>
<description>&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;看到文章的题目了吗？就是这么抽象和笼统的一个问题，确实是我面试中真实被问到的，某共享货车平台的真实面试问题。&lt;br/&gt;SpringCloud确实是用过，但是那是三四年前了，那个时候SpringCloud刚开始流行没多久，我们技术总监让我们调研一下，然后算上我在内的三个同事就一人买了一本SpringCloud的书籍，开始看，开始研究，正好那个时候DDD也比较火，然后我们就一边研究的SpringCloud一边按照DDD的模型搭建自己的项目。&lt;br/&gt;但是这个项目最后做了三个月，才完成了一期。后面二期还没开始，我就撤了。所以SpringCloud总共的使用时间就两三个月，所以对这部分知识掌握的并不扎实，而且入职了新公司之后，都是使用公司自己封装的框架，也已经三年没有用过SpringCloud了，这次是要面试换工作了，所以决定将这方面的知识，总结一下。&lt;/p&gt;
&lt;h3 id=&quot;服务治理-spring-cloud-eureka&quot;&gt;服务治理 Spring Cloud Eureka&lt;/h3&gt;
&lt;p&gt;我们之前在使用服务之间相互调用的时候，一般是靠一些静态配置来完成的。比如服务A，要调用服务B来完成一个业务操作时，为了实现服务B的高可用，一般是通过手动配置来完成服务B的服务实例清单的维护。&lt;br/&gt;随着业务的发展，系统功能越来越复杂，相应的服务不断增加，而且服务的IP还一直在变化，静态配置来维护各服务，就会变得越来越困难。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210116165917948.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmlNb2Vy,size_30,color_c8cae6,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;这个时候就出现了服务治理框架，Spring Cloud Eureka。&lt;/p&gt;
&lt;p&gt;Spring Cloud Eureka 主要是围绕着服务注册与服务发现机制来完成对微服务的自动化管理的。&lt;/p&gt;
&lt;h4 id=&quot;服务注册&quot;&gt;服务注册&lt;/h4&gt;
&lt;p&gt;Eureka提供了服务端组件，我们也称为注册中心。每个服务都向Eureka的服务注册中心，登记自己提供服务的元数据，包括服务的ip地址、端口号、版本号、通信协议等。这样注册中心，就将各个服务维护在了一个服务清单中（双层Map，第一层key是服务名，第二层key是实例名，value是服务地址加端口）。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210116171848204.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmlNb2Vy,size_60,color_c8cae6,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;strong&gt;服务注册中心，还会以心跳的方式去监听清单中的服务是否可用（默认30秒），若不可用（服务续约时间默认90秒），需从清单中剔除，达到排除故障服务的效果。&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;Eureka注册中心提供了高可用方案，可以支持集群部署注册中心，然后多个注册中心实例之间又相互注册，这样每个实例中都有一样的服务清单了。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;服务发现&quot;&gt;服务发现&lt;/h4&gt;
&lt;p&gt;Eureka不但提供服务端，还提供了客户端，客户端是在各个服务中运行的。&lt;br/&gt;Eureka客户端主要有两个作用：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;向注册中心注册自身提供的服务，并周期性的发送心跳来更新它非服务租约&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;同时，也能从服务端查询当前注册的服务信息，并把他们缓存到本地，并周期性的刷新服务状态&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在Eureka Server中注册的服务，相互之间调用，不再是通过指定的具体实例地址，而是通过向服务名发请求实现调用，因为每个服务服务都是多实例，并且实例地址还有可能经常变。&lt;br/&gt;但是通过服务名称调用，并不知道具体的服务实例位置，因此需要向注册中心咨询，并获取所有服务实例清单，然后实现服务的请求访问。&lt;/p&gt;
&lt;h4 id=&quot;举例&quot;&gt;举例&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210116204128624.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmlNb2Vy,size_30,color_c8cae6,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;服务A的一个业务操作，需要调用服务B和服务C来完成。&lt;br/&gt;那么服务A和服务B和服务C都将自己注册到Eureka的注册中心，然后服务A通过咨询注册中心，将注册中心的服务列表清单缓存到自己本地。&lt;br/&gt;通过服务名称获取到服务B和服务C的服务实例地址，最后通过一种轮询策略取出一个具体的服务实例地址来进行调用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结一下&lt;/strong&gt;&lt;br/&gt;Eureka Client : &lt;strong&gt;主要是将服务本身注册到Eureka Server中，同时查询Eureka Server的注册服务列表缓存到本地&lt;/strong&gt;。&lt;br/&gt;Eureka Server：&lt;strong&gt;注册中心，保存了所有注册服务的元数据，包括ip地址，端口等信息。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;客户端负载均衡-spring-cloud-ribbon&quot;&gt;客户端负载均衡 Spring Cloud Ribbon&lt;/h3&gt;
&lt;p&gt;服务的调用方，在通过Eureka Client缓存到本地的注册表之后，通过服务名称，找到具体的服务对应的实例地址，但是被调用方的服务地址是有多个的，那么该用那个地址去进行调用呢？&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;服务A：
192.168.12.10:9001
192.168.12.11:9001
192.168.12.12:9001
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个时候&lt;strong&gt;Spring Cloud Ribbon&lt;/strong&gt;就出现了，它是专门解决这个问题的，它的作用就是做负载均衡，会均匀的把请求分发到每台机器上。&lt;/p&gt;
&lt;p&gt;Ribbon默认使用&lt;strong&gt;Round Ribbon&lt;/strong&gt;的策略进行负载均衡，具体就是采用轮询的方式进行请求。&lt;/p&gt;
&lt;p&gt;Ribbon除了有&lt;strong&gt;Round Ribbon&lt;/strong&gt;这种轮询策略，还有其他策略以及自定义策略。&lt;br/&gt;主要有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;RandomRole&lt;/strong&gt;： 从服务实例清单中随机选择一个服务实例。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;RoundRobinRule&lt;/strong&gt;： 按照线性轮询的方式依次选择每个服务实例。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;RetryRule&lt;/strong&gt;：根据轮询方式进行，且具备重试机制进行选择实例。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;WeightedResponseTimeRule&lt;/strong&gt;：对&lt;strong&gt;RoundRobinRule&lt;/strong&gt;的扩展，增加了根据实例的运行情况来计算权重，并根据权重来挑选实例。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ZoneAvoidanceRule&lt;/strong&gt;：根据服务方的zone区域和可用性来轮询选择。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Spring Cloud Ribbon具体的执行示例如下：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210116221537212.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmlNb2Vy,size_60,color_c8cae6,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;实例代码&quot;&gt;实例代码&lt;/h4&gt;
&lt;p&gt;下面的代码就是通过Ribbon调用服务的代码实例。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@RestController
public class ConsumerController {
    @Autowired
    RestTemplate restTemplate;
    @GetMapping(&quot;/ribbon-consumer&quot;)
    public String helloConsumer(){
        return restTemplate.getForEntity(&quot;http://example-service/index&quot;,String.class).getBody();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到Ribbon也是通过发起http请求，来进行的调用，只不过是通过调用服务名的地址来实现的。虽然说Ribbon不用去具体请求服务实例的ip地址或域名了，但是每调用一个接口都还要手动去发起Http请求，也是比较繁琐的，而且返回类型也比较抽象，所以Spring Cloud对调用方式进行了升级封装。&lt;/p&gt;
&lt;h3 id=&quot;声明式服务调用-spring-cloud-feign&quot;&gt;声明式服务调用 Spring Cloud Feign&lt;/h3&gt;
&lt;p&gt;Spring Cloud 为了简化服务间的调用，在Ribbon的基础上进行了进一步的封装。单独抽出了一个组件，就是Spring Cloud Feign。在引入Spring Cloud Feign后，我们只需要创建一个接口并用注解的方式来配置它，即可完成对服务提供方的接口绑定。&lt;/p&gt;
&lt;p&gt;Spring Cloud Feign具备可插拔的注解支持，并扩展了Spring MVC的注解支持。&lt;/p&gt;
&lt;p&gt;下面我们来看一个具体的例子：&lt;/p&gt;
&lt;p&gt;服务方具体的接口定义与实现代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;
import org.springframework.cloud.netflix.feign.FeignClient;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RequestParam;
/**
 * 接口定义
 */
@FeignClient(value=&quot;service-hi&quot;,fallback = TestFeignServiceImpl.class)
public interface TestFeignService {

    @RequestMapping(value=&quot;/hi&quot;,method = RequestMethod.GET)
    String sayHi(@RequestParam(&quot;name&quot;) String name);
}
/**
 * 具体的服务实现
 */
@Component
public class TestFeignServiceImpl implements TestFeignService {
    @Override
    public String sayHi(String name) {
        return &quot;你好,&quot;+name;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;调用方的使用代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@RestController
public class TestController
{
    @Resource
    private TestFeignService testFeignService;

    @RequestMapping(value=&quot;/hi&quot;,method = RequestMethod.GET)
    public String sayHi(@RequestParam String name)
    {
        // 调用远程服务
        return testFeignService.sayHi(name);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过上面的代码，我们可以看到，调用方通过Feign进程远程服务调用的时候，非常简单，就向是在调用本地服务一样。&lt;/p&gt;
&lt;p&gt;像之前的建立连接，构造请求，发起请求，获取响应，解析响应等等操作，对使用者来说都是透明化的，使用者不用关心服务是怎么实现调用的，直接使用即可。&lt;/p&gt;
&lt;h5 id=&quot;那么feign是如何实现这套封装逻辑的呢？&quot;&gt;那么Feign是如何实现这套封装逻辑的呢？&lt;/h5&gt;
&lt;p&gt;其实&lt;strong&gt;Feign底层主要是靠动态代理来实现这整个服务的调用过程的。&lt;/strong&gt;&lt;br/&gt;主要逻辑如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果一个接口上定义了@FeignClient注解，Feign就会根据这个接口生成一个动态代理类。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;如果调用方，在调用这个定义了@FeignClient注解的接口时，本质上是会调用Feign生成的代理类。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Feign生成的动态代理类，会根据具体接口方法中的@RequestMapping等注解，来动态构造出需要请求的服务地址。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;最后针对这个地址，再通过Ribbon发起服务调用，解析响应等操作。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210116231614564.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmlNb2Vy,size_60,color_c8cae6,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;因为Spring Cloud Feign的使用方式比Spring Cloud Ribbon更方便，所以一般项目中都是使用Feign，而且Feign还有继承特性，可以将远程服务接口继承过来然后再进行自己的个性化扩展。因此Feign的使用范围以及普及率更高一些。&lt;/p&gt;
&lt;h3 id=&quot;服务容错保护-spring-cloud-hystrix&quot;&gt;服务容错保护 Spring Cloud Hystrix&lt;/h3&gt;
&lt;p&gt;在微服务架构中，我们将系统拆分成多个服务单元，各个服务之间通过服务注册与订阅的方式互相依赖。&lt;/p&gt;
&lt;p&gt;我们以一个电商网站下单的过程来举例，在下单的业务操作过程中需要调用库存服务，支付服务，积分、物流等服务。&lt;strong&gt;假设订单服务最多同一时间只能处理50个请求，这个时候如果积分服务挂了，那么每次订单服务去调用积分服务的时候，都会卡这么一段时间，然后才返回超时异常&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在这种场景下会有什么问题呢？&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;如果目前电商网站正在搞活动，进行抢购活动，下单的人非常多，这种高并发的场景下，订单服务的已经同时在处理50个下单请求了，并且都卡在了请求积分服务的过程中。订单服务已经没有能力去处理其他请求了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;那么其他服务再来调用订单服务时，发订单服务无响应，这样就导致订单服务也不可用了。然后其他依赖订单服务的服务，也最终会导致不可用。&lt;strong&gt;这就是微服务架构中的服务雪崩。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210117111202652.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmlNb2Vy,size_60,color_c8cae6,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;就上图所示，如果多个服务之间相互调用，而不做任何保护措施的话，那么一个服务挂了，就会产生连锁反应，导致其他服务也挂了。&lt;/p&gt;
&lt;p&gt;其实就算是积分服务挂了，也并不应该导致订单服务也挂了，积分服务挂了，我们可以跳过积分服务，或者是放一个默认值，然后继续往下走，等着积分服务恢复了，可以手动恢复一下数据。&lt;/p&gt;
&lt;p&gt;那么Spring Cloud Hystrix就是解决这个问题的组件，他主要是起到熔断，隔离，降级的作用。&lt;/p&gt;
&lt;p&gt;Spring Cloud Hystrix其实是会为每一个服务开辟一个线程池，然后每个线程池中的线程用于对服务的调用请求。这样就算是积分服务挂了，那也只是调用积分服务的线程池出现问题了，而其他服务的线程池还正常工作。&lt;strong&gt;这就是服务的隔离。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这样订单服务在的调用积分服务的时候，如果发现有问题了，积分服务可以通过&lt;strong&gt;Hystrix返回一个默认值（默认是5秒内20次调用失败就熔断）&lt;/strong&gt;。这样订单服务就不用在这里卡住了，可以继续往下调用其他服务进行业务操作了。&lt;strong&gt;这就是服务的熔断。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;虽然说是积分服务挂了，并且也返回了默认值了，但是后续如果积分服务恢复了，想恢复数据怎么办呢？这个时候积分服务可以将姐收到的请求记录下来，或者是打到日志中，能为后面恢复数据提供依据就行。&lt;strong&gt;这就是服务的降级&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;整个过程大致如下图所示：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2021011715240055.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmlNb2Vy,size_60,color_c8cae6,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;api网关服务spring-cloud-zuul&quot;&gt;API网关服务Spring Cloud Zuul&lt;/h3&gt;
&lt;p&gt;通过上面几个组件的结合使用，已经能够完成一个基本的微服务架构了。但是当一个系统中微服务的数量逐渐增多时，一些通用的逻辑，例如：权限校验机制，请求过滤，请求路由，限流等等，这些每个服务对外提供能力的时候都要考虑到的逻辑，就会变得冗余。&lt;/p&gt;
&lt;p&gt;这个时候API网关的概念应运而生，它类似于面向对象设计模式中的Facade模式（门面模式/外观模式），所有的外部客户端访问都需要经过它来进行调度和过滤。主要实现请求路由、负载均衡、校验过滤、服务限流等功能。&lt;/p&gt;
&lt;p&gt;Spring Cloud Zuul就是Spring Cloud提供的API网关组件，它&lt;strong&gt;通过与Eureka进行整合，将自身注册为Eureka下的应用，从Eureka下获取所有服务的实例，来进行服务的路由。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Zuul还提供了一套过滤器机制，开发者可以自己指定哪些规则的请求需要执行校验逻辑，只有通过校验逻辑的请求才会被路由到具体服务实例上，否则返回错误提示。&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210117174135493.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmlNb2Vy,size_30,color_c8cae6,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Spring Cloud Zuul的依赖包&lt;code&gt;spring-cloud-starter-zuul&lt;/code&gt;本身就包含了对s&lt;code&gt;pring-cloud-starter-hystrix&lt;/code&gt;和&lt;code&gt;spring-cloud-starter-ribbon&lt;/code&gt;模块的依赖，所以Zuul天生就拥有线程隔离和断路器的自我保护功能，以及对服务调用的客户端负载功能。&lt;/p&gt;
&lt;p&gt;Zuul的路由实现是通过Path和serviceId还实现的，path是一个http请求去除ip和端口号后的方法路径，例如：&lt;code&gt;http://192.168.20.12:9001/api-zuul/123&lt;/code&gt;，那么path就是&lt;code&gt;/api-zuul/123&lt;/code&gt;，Zuul在配置时支持模糊匹配，若123是动态参数，可以将path配置成&lt;code&gt;/pai-zuul/**&lt;/code&gt;，serviceId就是服务在Eureka中注册的服务名称。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yaml&quot;&gt;zuul.routes.api-zuul.path= /api-zuul/**
zuul.routes.api-zuul.serviceId= service-jimoer
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有了统一的网关后，再做统一的鉴权、限流、认证授权、安全等方面的工作就会变的更加方便了。&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;上面总结了Spring Cloud的几个核心组件，其实Spring Cloud 除了这几个组件还有一些其他的组件，例如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;分布式配置中心&lt;/strong&gt;：&lt;code&gt;Spring Cloud Config&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;消息总线&lt;/strong&gt;：&lt;code&gt;Spring Cloud Bus&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;消息驱动&lt;/strong&gt;：&lt;code&gt;Spring Cloud Stream&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;分布式服务跟踪&lt;/strong&gt;：&lt;code&gt;Spring Cloud Sleuth&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;主要是后面这些组件我们平时用的不多，而且对于微服务来说有些是有替代品的，所以我暂时就没有总结。还有一点毕竟我这次总结是为了解决面试的问题，所以后面如果在实际的工作中用到了剩下的这些组件，我会继续总结的。&lt;/p&gt;
&lt;p&gt;好了，总结一下这次的几个组件的内容吧。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Spring Cloud Eureka&lt;/strong&gt; 各个微服务在启动时将自己注册到Eureka Server中，并且各个服务中的Eureka Client又能从注册中心获取各个服务的实例地址清单。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Spring Cloud Ribbon&lt;/strong&gt; 各个服务相互调用的时候，通过Ribbon来进行客户端的负载均衡，从多个实例中根据一定的策略选择一台进行请求。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Spring Cloud Feign&lt;/strong&gt; 基于动态代理机制，根据注解和参数拼接URL，选择具体的服务实例发起请求，简化了服务间相互调用的开发工作。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Spring Cloud Hystrix&lt;/strong&gt; 调用每个服务的时候都是通过线程池中的线程来发起的，不同的服务走不同的线程池，实现了服务的隔离，而且服务不可用时还提供了熔断机制以及支持降低措施。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Spring Cloud Zuul&lt;/strong&gt; 外部请求统一通过Zuul网关来进入，支持自定义路由规则，自定义过滤规则，可以实现同一的鉴权、限流、认证等功能。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;最后来一个整体的架构图，将各个组件串起来。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210117174734234.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmlNb2Vy,size_60,color_c8cae6,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 18 Jan 2021 00:24:00 +0000</pubDate>
<dc:creator>纪莫</dc:creator>
<og:description>前言 看到文章的题目了吗？就是这么抽象和笼统的一个问题，确实是我面试中真实被问到的，某共享货车平台的真实面试问题。 SpringCloud确实是用过，但是那是三四年前了，那个时候SpringCloud</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jimoer/p/14289723.html</dc:identifier>
</item>
<item>
<title>MyBatis初级实战之二：增删改查 - 程序员欣宸</title>
<link>http://www.cnblogs.com/bolingcavalry/p/14291067.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bolingcavalry/p/14291067.html</guid>
<description>&lt;h3 id=&quot;欢迎访问我的github&quot;&gt;欢迎访问我的GitHub&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot; target=&quot;_blank&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;内容：所有原创文章分类汇总及配套源码，涉及Java、Docker、Kubernetes、DevOPS等；&lt;/p&gt;
&lt;p&gt;本文是《MyBatis初级实战》系列的第二篇，通过前文我们知道了如何在SpringBoot中集成MyBatis，本篇就一起来练习基本功：增删改查；&lt;/p&gt;
&lt;h3 id=&quot;本篇概览&quot;&gt;本篇概览&lt;/h3&gt;
&lt;p&gt;本篇要练习的内容如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;单表的增删改查&lt;/li&gt;
&lt;li&gt;批量新增&lt;/li&gt;
&lt;li&gt;联表查询&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;全文由以下部分组成：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;新建工程&lt;/li&gt;
&lt;li&gt;增加启动类&lt;/li&gt;
&lt;li&gt;增加swagger的配置类，工程包含了swagger，以便稍后在浏览器上验证&lt;/li&gt;
&lt;li&gt;增加配置文件&lt;/li&gt;
&lt;li&gt;增加实体类&lt;/li&gt;
&lt;li&gt;增加mapper配置文件&lt;/li&gt;
&lt;li&gt;增加mapper接口&lt;/li&gt;
&lt;li&gt;增加service，调用mapper接口&lt;/li&gt;
&lt;li&gt;增加controller，调用service服务&lt;/li&gt;
&lt;li&gt;编写单元测试用例&lt;/li&gt;
&lt;li&gt;验证&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;源码下载&quot;&gt;源码下载&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;如果您不想编码，可以在GitHub下载所有源码，地址和链接信息如下表所示(&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot; target=&quot;_blank&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;)：&lt;/li&gt;
&lt;/ol&gt;&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;这个git项目中有多个文件夹，本章的应用在&lt;span&gt;mybatis&lt;/span&gt;文件夹下，如下图红框所示：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210118082315694-720718018.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;开发&quot;&gt;开发&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;本文的实战使用的数据库和表结构与前文&lt;a href=&quot;https://blog.csdn.net/boling_cavalry/article/details/107805840&quot; target=&quot;_blank&quot;&gt;《MyBatis初级实战之一：Spring Boot集成》&lt;/a&gt;一模一样；&lt;/li&gt;
&lt;li&gt;前文&lt;a href=&quot;https://blog.csdn.net/boling_cavalry/article/details/107805840&quot; target=&quot;_blank&quot;&gt;《MyBatis初级实战之一：Spring Boot集成》&lt;/a&gt;新建了父工程mybatis，本文继续在此工程中新增子工程，名为&lt;span&gt;curd&lt;/span&gt;，整个子工程文件结构如下：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210118082316311-1145483818.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;3. 修改父工程mybatis的&lt;span&gt;pom.xml&lt;/span&gt;，在&lt;span&gt;dependencyManagement&lt;/span&gt;节点下新增两个dependency节点，如下所示，这么做是为了统一管理依赖库的版本：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;!-- swagger-ui --&amp;gt;
&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;io.springfox&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;springfox-swagger-ui&amp;lt;/artifactId&amp;gt;
  &amp;lt;version&amp;gt;2.5.0&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;

&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;com.google.code.gson&amp;lt;/groupId&amp;gt;
   &amp;lt;artifactId&amp;gt;gson&amp;lt;/artifactId&amp;gt;
  &amp;lt;version&amp;gt;2.8.6&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;名为&lt;span&gt;curd&lt;/span&gt;子工程，其pom.xml内容如下：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;
    &amp;lt;parent&amp;gt;
        &amp;lt;groupId&amp;gt;com.bolingcavalry&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;mybatis&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;
        &amp;lt;relativePath&amp;gt;../pom.xml&amp;lt;/relativePath&amp;gt;
    &amp;lt;/parent&amp;gt;

    &amp;lt;groupId&amp;gt;com.bolingcavalry&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;curd&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt;
    &amp;lt;name&amp;gt;curd&amp;lt;/name&amp;gt;
    &amp;lt;description&amp;gt;Demo project for Mybatis CURD in Spring Boot&amp;lt;/description&amp;gt;

    &amp;lt;properties&amp;gt;
        &amp;lt;java.version&amp;gt;1.8&amp;lt;/java.version&amp;gt;
    &amp;lt;/properties&amp;gt;

    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.mybatis.spring.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;mybatis-spring-boot-starter&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;
            &amp;lt;scope&amp;gt;runtime&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
            &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
            &amp;lt;exclusions&amp;gt;
                &amp;lt;exclusion&amp;gt;
                    &amp;lt;groupId&amp;gt;org.junit.vintage&amp;lt;/groupId&amp;gt;
                    &amp;lt;artifactId&amp;gt;junit-vintage-engine&amp;lt;/artifactId&amp;gt;
                &amp;lt;/exclusion&amp;gt;
            &amp;lt;/exclusions&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;io.springfox&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;springfox-swagger2&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;!-- swagger-ui --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;io.springfox&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;springfox-swagger-ui&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt;
            &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.google.code.gson&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;gson&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;

    &amp;lt;build&amp;gt;
        &amp;lt;plugins&amp;gt;
            &amp;lt;plugin&amp;gt;
                &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;
            &amp;lt;/plugin&amp;gt;
        &amp;lt;/plugins&amp;gt;
    &amp;lt;/build&amp;gt;

&amp;lt;/project&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;5&quot;&gt;&lt;li&gt;增加启动类，注意要用MapperScan注释来指定mapper接口代码的包路径：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.bolingcavalry.curd;

import org.mybatis.spring.annotation.MapperScan;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
@MapperScan(&quot;com.bolingcavalry.curd.mapper&quot;)
public class CurdApplication {

    public static void main(String[] args) {
        SpringApplication.run(CurdApplication.class, args);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;6&quot;&gt;&lt;li&gt;本次实战用到了swagger，这样可以很方便的通过浏览器向各个controller接口发送请求，以下是配置类：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.bolingcavalry.curd;

import springfox.documentation.service.Contact;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import springfox.documentation.builders.ApiInfoBuilder;
import springfox.documentation.builders.PathSelectors;
import springfox.documentation.builders.RequestHandlerSelectors;
import springfox.documentation.service.ApiInfo;
import springfox.documentation.service.Tag;
import springfox.documentation.spi.DocumentationType;
import springfox.documentation.spring.web.plugins.Docket;
import springfox.documentation.swagger2.annotations.EnableSwagger2;

@Configuration
@EnableSwagger2
public class SwaggerConfig {

    @Bean
    public Docket createRestApi() {
        return new Docket(DocumentationType.SWAGGER_2)
                .apiInfo(apiInfo())
                .tags(new Tag(&quot;UserController&quot;, &quot;用户服务&quot;), new Tag(&quot;LogController&quot;, &quot;日志服务&quot;))
                .select()
                // 当前包路径
                .apis(RequestHandlerSelectors.basePackage(&quot;com.bolingcavalry.curd.controller&quot;))
                .paths(PathSelectors.any())
                .build();
    }

    //构建 api文档的详细信息函数,注意这里的注解引用的是哪个
    private ApiInfo apiInfo() {
        return new ApiInfoBuilder()
                //页面标题
                .title(&quot;MyBatis CURD操作&quot;)
                //创建人
                .contact(new Contact(&quot;程序员欣宸&quot;, &quot;https://github.com/zq2599/blog_demos&quot;, &quot;zq2599@gmail.com&quot;))
                //版本号
                .version(&quot;1.0&quot;)
                //描述
                .description(&quot;API 描述&quot;)
                .build();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;7&quot;&gt;&lt;li&gt;application.yml内容如下：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-yml&quot;&gt;server:
  port: 8080

spring:
  # 数据源
  datasource:
    username: root
    password: 123456
    url: jdbc:mysql://192.168.50.43:3306/mybatis?useUnicode=true&amp;amp;characterEncoding=utf-8&amp;amp;useSSL=true&amp;amp;serverTimezone=UTC
    driver-class-name: com.mysql.cj.jdbc.Driver

# mybatis配置
mybatis:
  # 配置文件所在位置
  config-location: classpath:mybatis-config.xml
  # 映射文件所在位置
  mapper-locations: classpath:mappers/*Mapper.xml

# 日志配置
logging:
  level:
    root: INFO
    com:
      bolingcavalry:
        curd:
          mapper: debug
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;6&quot;&gt;&lt;li&gt;增加user表的实体类User.java，里面带有swagger的注解，方便在swagger页面展示：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.bolingcavalry.curd.entity;

import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;

@ApiModel(description = &quot;用户实体类&quot;)
public class User {

    @ApiModelProperty(value = &quot;用户ID&quot;)
    private Integer id;

    @ApiModelProperty(value = &quot;用户名&quot;, required = true)
    private String name;

    @ApiModelProperty(value = &quot;用户地址&quot;, required = false)
    private Integer age;

    @Override
    public String toString() {
        return &quot;User{&quot; +
                &quot;id=&quot; + id +
                &quot;, name='&quot; + name + '\'' +
                &quot;, age=&quot; + age +
                '}';
    }
    
    // 省去get和set方法，请您自行补齐
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;8&quot;&gt;&lt;li&gt;增加log表的实体类Log.java，里面带有swagger的注解，方便在swagger页面展示：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.bolingcavalry.curd.entity;

import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;

import java.sql.Date;

/**
 * @Description: 实体类
 * @author: willzhao E-mail: zq2599@gmail.com
 * @date: 2020/8/4 8:24
 */
@ApiModel(description = &quot;日志实体类&quot;)
public class Log {
    @ApiModelProperty(value = &quot;日志ID&quot;)
    private Integer id;

    @ApiModelProperty(value = &quot;用户ID&quot;)
    private Integer userId;

    @ApiModelProperty(value = &quot;日志内容&quot;)
    private String action;

    @ApiModelProperty(value = &quot;创建时间&quot;)
    private Date createTime;

    @Override
    public String toString() {
        return &quot;Log{&quot; +
                &quot;id=&quot; + id +
                &quot;, userId=&quot; + userId +
                &quot;, action='&quot; + action + '\'' +
                &quot;, createTime=&quot; + createTime +
                '}';
    }
    // 省去get和set方法，请您自行补齐
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;9&quot;&gt;&lt;li&gt;为联表查询的结果准备一个bean，名为LogExtend.java，继承自Log.java，自己只有个userName字段，对应联表查询user表的name字段：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.bolingcavalry.curd.entity;

import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;

@ApiModel(description = &quot;日志实体类(含用户表的字段)&quot;)
public class LogExtend extends Log {


    public String getUserName() {
        return userName;
    }

    public void setUserName(String userName) {
        this.userName = userName;
    }

    @ApiModelProperty(value = &quot;用户名&quot;)
    private String userName;

    @Override
    public String toString() {
        return &quot;LogExtend{&quot; +
                &quot;id=&quot; + getId() +
                &quot;, userId=&quot; + getUserId() +
                &quot;, userName='&quot; + getUserName() + '\'' +
                &quot;, action='&quot; + getAction() + '\'' +
                &quot;, createTime=&quot; + getCreateTime() +
                '}';
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;10&quot;&gt;&lt;li&gt;增加user表的mapper映射文件，可见都是些很简单sql，要注意的是批量新增的节点，这里面用到了&lt;span&gt;foreach&lt;/span&gt;语法，可以通过集合动态生成sql：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&amp;gt;
&amp;lt;mapper namespace=&quot;com.bolingcavalry.curd.mapper.UserMapper&quot;&amp;gt;

    &amp;lt;select id=&quot;sel&quot; parameterType=&quot;int&quot; resultType=&quot;user&quot;&amp;gt;
        select * from user where id = #{id}
    &amp;lt;/select&amp;gt;

    &amp;lt;!--新增单条记录--&amp;gt;
    &amp;lt;insert id=&quot;insertWithFields&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&amp;gt;
        insert into user (id, name, age) values (#{id}, #{name}, #{age})
    &amp;lt;/insert&amp;gt;

    &amp;lt;!--批量新增--&amp;gt;
    &amp;lt;insert id=&quot;insertBatch&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&amp;gt;
        insert into user (id, name, age)
        values
        &amp;lt;foreach collection=&quot;users&quot; item=&quot;user&quot; separator=&quot;,&quot;&amp;gt;
            (#{user.id}, #{user.name}, #{user.age})
        &amp;lt;/foreach&amp;gt;
    &amp;lt;/insert&amp;gt;

    &amp;lt;!--按照名称查找--&amp;gt;
    &amp;lt;select id=&quot;findByName&quot; parameterType=&quot;String&quot; resultType=&quot;user&quot;&amp;gt;
        select id, name, age from user where name like concat('%', #{name}, '%')
    &amp;lt;/select&amp;gt;

    &amp;lt;!--删除指定数据--&amp;gt;
    &amp;lt;delete id=&quot;delete&quot;&amp;gt;
        delete from user where id= #{id}
    &amp;lt;/delete&amp;gt;

    &amp;lt;!--删除所有数据--&amp;gt;
    &amp;lt;delete id=&quot;clearAll&quot;&amp;gt;
        delete from user
    &amp;lt;/delete&amp;gt;

    &amp;lt;!--更新--&amp;gt;
    &amp;lt;update id=&quot;update&quot;&amp;gt;
        update user set name = #{name}, age = #{age} where id = #{id}
    &amp;lt;/update&amp;gt;

    &amp;lt;!--获取总数--&amp;gt;
    &amp;lt;select id=&quot;totalCount&quot; resultType=&quot;java.lang.Integer&quot;&amp;gt;
        select count(*) from user
    &amp;lt;/select&amp;gt;
&amp;lt;/mapper&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;11&quot;&gt;&lt;li&gt;增加log表的mapper映射文件，如下所示，请关注联表操作&lt;span&gt;selExtend&lt;/span&gt;，其结果是logExtendResultMap：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&amp;gt;
&amp;lt;mapper namespace=&quot;com.bolingcavalry.curd.mapper.LogMapper&quot;&amp;gt;

    &amp;lt;resultMap id=&quot;logExtendResultMap&quot; type=&quot;logExtend&quot;&amp;gt;
        &amp;lt;id property=&quot;id&quot; column=&quot;id&quot;/&amp;gt;
        &amp;lt;result column=&quot;user_id&quot; jdbcType=&quot;INTEGER&quot; property=&quot;userId&quot;/&amp;gt;
        &amp;lt;result column=&quot;action&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;action&quot;/&amp;gt;
        &amp;lt;result column=&quot;create_time&quot; jdbcType=&quot;TIMESTAMP&quot; property=&quot;createTime&quot;/&amp;gt;
        &amp;lt;result column=&quot;user_name&quot; jdbcType=&quot;TIMESTAMP&quot; property=&quot;userName&quot;/&amp;gt;
    &amp;lt;/resultMap&amp;gt;

    &amp;lt;!--新增单条记录--&amp;gt;
    &amp;lt;insert id=&quot;insertWithFields&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot; parameterType=&quot;log&quot;&amp;gt;
        insert into log (id, user_id, action, create_time) values (#{id}, #{userId}, #{action}, #{createTime})
    &amp;lt;/insert&amp;gt;

    &amp;lt;select id=&quot;selExtend&quot; parameterType=&quot;int&quot; resultMap=&quot;logExtendResultMap&quot;&amp;gt;
        select l.id as id,
               l.user_id as user_id,
               l.action as action,
               l.create_time as create_time,
               u.name as user_name
        from log as l
        left join user as u
        on l.user_id = u.id
        where l.id = #{id}
    &amp;lt;/select&amp;gt;

&amp;lt;/mapper&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;12&quot;&gt;&lt;li&gt;增加用户表的mapper接口类&lt;span&gt;UserMapper.java&lt;/span&gt; ，对应着映射文件中的sql节点的id：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.bolingcavalry.curd.mapper;

import com.bolingcavalry.curd.entity.LogExtend;
import com.bolingcavalry.curd.entity.User;
import org.springframework.stereotype.Repository;
import java.util.List;

@Repository
public interface UserMapper {

    User sel(int id);

    int insertWithFields(User user);

    int insertBatch(List&amp;lt;User&amp;gt; users);

    int clearAll();

    List&amp;lt;User&amp;gt; findByName(String name);

    int update(User user);

    int delete(int id);

    int totalCount();

    LogExtend selExtend(int id);
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;13&quot;&gt;&lt;li&gt;增加日志表的mapper接口类&lt;span&gt;LogMapper.java&lt;/span&gt;，对应着映射文件中的sql节点的id：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.bolingcavalry.curd.mapper;

import com.bolingcavalry.curd.entity.Log;
import com.bolingcavalry.curd.entity.LogExtend;
import org.springframework.stereotype.Repository;

@Repository
public interface LogMapper {
    Log sel(int id);

    LogExtend selExtend(int id);

    int insertWithFields(Log log);
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;14&quot;&gt;&lt;li&gt;mapper接口完成后就是service层，先写user表的service，如下所示，可见都是对mapper接口的调用：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.bolingcavalry.curd.service;

import com.bolingcavalry.curd.entity.User;
import com.bolingcavalry.curd.mapper.UserMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import java.util.List;

@Service
public class UserService {

    @Autowired
    UserMapper userMapper;

    public User sel(int id) {
        return userMapper.sel(id);
    }

    public User insertWithFields(User user) {
        userMapper.insertWithFields(user);
        return user;
    }

    public List&amp;lt;User&amp;gt; insertBatch(List&amp;lt;User&amp;gt; users) {
        userMapper.insertBatch(users);
        return users;
    }

    public int clearAll() {
       return userMapper.clearAll();
    }

    public List&amp;lt;User&amp;gt; findByName(String name) {
        return userMapper.findByName(name);
    }

    public int update(User user) {
        return userMapper.update(user);
    }

    public int delete(int id) {
        return userMapper.delete(id);
    }

    public int totalCount() {
        return userMapper.totalCount();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;15&quot;&gt;&lt;li&gt;还有log表的service：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.bolingcavalry.curd.service;

import com.bolingcavalry.curd.entity.Log;
import com.bolingcavalry.curd.entity.LogExtend;
import com.bolingcavalry.curd.entity.User;
import com.bolingcavalry.curd.mapper.LogMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class LogService {
    @Autowired
    LogMapper logMapper;

    public Log sel(int id){
        return logMapper.sel(id);
    }

    public LogExtend selExtend(int id) {
        return logMapper.selExtend(id);
    }

    public Log insertWithFields(Log log) {
        logMapper.insertWithFields(log);
        return log;
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;16&quot;&gt;&lt;li&gt;最后是controller层了，由于使用了swagger，导致controller相对上一篇略微复杂（多了些注解）：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.bolingcavalry.curd.controller;

import com.bolingcavalry.curd.entity.User;
import com.bolingcavalry.curd.service.UserService;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiImplicitParam;
import io.swagger.annotations.ApiOperation;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;
import java.util.ArrayList;
import java.util.List;

@RestController
@RequestMapping(&quot;/user&quot;)
@Api(tags = {&quot;UserController&quot;})
public class UserController {

    @Autowired
    private UserService userService;


    @ApiOperation(value = &quot;新增user记录&quot;, notes=&quot;新增user记录&quot;)
    @RequestMapping(value = &quot;/insertwithfields&quot;,method = RequestMethod.PUT)
    public User create(@RequestBody User user) {
        return userService.insertWithFields(user);
    }

    @ApiOperation(value = &quot;批量新增user记录&quot;, notes=&quot;批量新增user记录&quot;)
    @RequestMapping(value = &quot;/insertbatch&quot;, method = RequestMethod.PUT)
    public List&amp;lt;User&amp;gt; insertBatch(@RequestBody List&amp;lt;User&amp;gt; users) {
        return userService.insertBatch(users);
    }

    @ApiOperation(value = &quot;删除指定ID的user记录&quot;, notes=&quot;删除指定ID的user记录&quot;)
    @ApiImplicitParam(name = &quot;id&quot;, value = &quot;用户ID&quot;, paramType = &quot;path&quot;, required = true, dataType = &quot;Integer&quot;)
    @RequestMapping(value = &quot;/{id}&quot;, method = RequestMethod.DELETE)
    public int delete(@PathVariable int id){
        return userService.delete(id);
    }

    @ApiOperation(value = &quot;删除user表所有数据&quot;, notes=&quot;删除user表所有数据&quot;)
    @RequestMapping(value = &quot;/clearall&quot;, method = RequestMethod.DELETE)
    public int clearAll(){
        return userService.clearAll();
    }

    @ApiOperation(value = &quot;根据ID修改user记录&quot;, notes=&quot;根据ID修改user记录&quot;)
    @RequestMapping(value = &quot;/update&quot;, method = RequestMethod.POST)
    public int update(@RequestBody User user){
        return userService.update(user);
    }

    @ApiOperation(value = &quot;根据名称模糊查找所有user记录&quot;, notes=&quot;根据名称模糊查找所有user记录&quot;)
    @ApiImplicitParam(name = &quot;name&quot;, value = &quot;用户名&quot;, paramType = &quot;path&quot;, required = true, dataType = &quot;String&quot;)
    @RequestMapping(value = &quot;/findbyname/{name}&quot;, method = RequestMethod.GET)
    public List&amp;lt;User&amp;gt; findByName(@PathVariable(&quot;name&quot;) String name){
        return userService.findByName(name);
    }

    @ApiOperation(value = &quot;根据ID查找user记录&quot;, notes=&quot;根据ID查找user记录&quot;)
    @ApiImplicitParam(name = &quot;id&quot;, value = &quot;用户ID&quot;, paramType = &quot;path&quot;, required = true, dataType = &quot;Integer&quot;)
    @RequestMapping(value = &quot;/{id}&quot;, method = RequestMethod.GET)
    public User GetUser(@PathVariable int id){
        return userService.sel(id);
    }

    @ApiOperation(value = &quot;获取总数&quot;, notes=&quot;获取总数&quot;)
    @RequestMapping(value = &quot;/totalcount&quot;, method = RequestMethod.GET)
    public int totalcount(){
        return userService.totalCount();
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;17&quot;&gt;&lt;li&gt;log的controller如下：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.bolingcavalry.curd.controller;

import com.bolingcavalry.curd.entity.Log;
import com.bolingcavalry.curd.entity.LogExtend;
import com.bolingcavalry.curd.service.LogService;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiImplicitParam;
import io.swagger.annotations.ApiOperation;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping(&quot;/log&quot;)
@Api(tags = {&quot;LogController&quot;})
public class LogController {
    @Autowired
    private LogService logService;

    @ApiOperation(value = &quot;根据ID查找日志记录&quot;, notes=&quot;根据ID查找日志记录&quot;)
    @ApiImplicitParam(name = &quot;id&quot;, value = &quot;日志ID&quot;, paramType = &quot;path&quot;, required = true, dataType = &quot;Integer&quot;)
    @RequestMapping(value = &quot;/{id}&quot;, method = RequestMethod.GET)
    public LogExtend logExtend(@PathVariable int id){
        return logService.selExtend(id);
    }

    @ApiOperation(value = &quot;新增日志记录&quot;, notes=&quot;新增日志记录&quot;)
    @RequestMapping(value = &quot;/insertwithfields&quot;,method = RequestMethod.PUT)
    public Log create(@RequestBody Log log) {
        return logService.insertWithFields(log);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;18&quot;&gt;&lt;li&gt;最后是一段单元测试的代码，咱们试试通过junit进行自测，如下所示，可见一共测试了三个controller接口：先新增，再查找，最后删除，要注意的是MockMvc的用法，以及jsonPath方法的用法，还有就是通过Order注解控制执行顺序（一定要添加TestMethodOrder注解，否则Order注解不生效）：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.bolingcavalry.curd.controller;

import com.bolingcavalry.curd.entity.User;
import com.google.gson.Gson;
import com.google.gson.JsonArray;
import com.google.gson.JsonParser;
import org.junit.Ignore;
import org.junit.jupiter.api.*;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.http.MediaType;
import org.springframework.test.context.junit4.SpringRunner;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.request.MockMvcRequestBuilders;

import java.util.List;
import java.util.UUID;

import static org.hamcrest.Matchers.hasSize;
import static org.hamcrest.Matchers.is;
import static org.hamcrest.core.IsEqual.equalTo;
import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

@RunWith(SpringRunner.class)
@SpringBootTest
@AutoConfigureMockMvc
@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
class UserControllerTest {

    @Autowired
    private MockMvc mvc;

    // user表的name字段，这里为了保证测试时新增和删除的记录是同一条，用UUID作为用户名
    static String testName;

    @BeforeAll
    static void init() {
        testName = UUID.randomUUID().toString().replaceAll(&quot;-&quot;,&quot;&quot;);;
    }

    @Test
    @Order(1)
    void insertWithFields() throws Exception {
        String jsonStr = &quot;{\&quot;name\&quot;: \&quot;&quot; + testName + &quot;\&quot;, \&quot;age\&quot;: 10}&quot;;

        mvc.perform(
                MockMvcRequestBuilders.put(&quot;/user/insertwithfields&quot;)
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(jsonStr)
                        .accept(MediaType.APPLICATION_JSON))
                .andExpect(status().isOk())
                .andExpect(jsonPath(&quot;$.name&quot;, is(testName)))
                .andDo(print())
                .andReturn()
                .getResponse()
                .getContentAsString();
    }

    @Test
    @Order(2)
    void findByName() throws Exception {
        mvc.perform(MockMvcRequestBuilders.get(&quot;/user/findbyname/&quot;+ testName).accept(MediaType.APPLICATION_JSON))
                .andExpect(status().isOk())
                .andExpect(jsonPath(&quot;$&quot;, hasSize(1)))
                .andDo(print());
    }


    @Test
    @Order(3)
    void delete() throws Exception {
        // 先根据名称查出记录
        String responseString = mvc.perform(MockMvcRequestBuilders.get(&quot;/user/findbyname/&quot;+ testName).accept(MediaType.APPLICATION_JSON))
                .andExpect(status().isOk())
                .andExpect(jsonPath(&quot;$&quot;, hasSize(1)))
                .andDo(print())
                .andReturn()
                .getResponse()
                .getContentAsString();

        // 反序列化得到数组
        JsonArray jsonArray = JsonParser.parseString(responseString).getAsJsonArray();

        // 反序列化得到user实例
        User user = new Gson().fromJson(jsonArray.get(0), User.class);

        // 执行删除
        mvc.perform(MockMvcRequestBuilders.delete(&quot;/user/&quot;+ user.getId()).accept(MediaType.APPLICATION_JSON))
                .andExpect(status().isOk())
                .andExpect(content().string(equalTo(&quot;1&quot;)))
                .andDo(print());
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;至此编码结束，开始验证上述功能；&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;单元测试验证&quot;&gt;单元测试验证&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;IDEA打开&lt;span&gt;UserControllerTest.java&lt;/span&gt;，点击下图红框中的图标即可开始执行单元测试：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210118082316644-804730566.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;2. 单元测试完成后IDEA会给出结果，如下图，红框右侧可以查看详细的测试过程数据：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210118082318452-254759675.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;篇幅所限，这只有少量的单元测试用例，接下来用swagger来验证每个接口；&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;swagger验证web接口&quot;&gt;swagger验证web接口&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;如下图，启动CurdApplication类：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210118082319037-1312326279.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;2. 浏览器访问：&lt;a href=&quot;http://localhost:8080/swagger-ui.html&quot; target=&quot;_blank&quot;&gt;http://localhost:8080/swagger-ui.html&lt;/a&gt; ，即可打开swagger页面，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210118082319418-93806705.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;3. 先试试新增的接口，操作如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210118082319835-1588265045.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;点击了上图红框3的Try it out!按钮后，响应信息如下图，可见操作成功：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210118082320823-523957955.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;5. 限于篇幅，其他接口的测试就不逐一列出了，请您自行验证；&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;至此，MyBatis的基本增删改查和简单的联表操作的实战就完成了，接下来咱们会继续探索MyBatis的基本操作；&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;你不孤单，欣宸原创一路相伴&quot;&gt;你不孤单，欣宸原创一路相伴&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105068742&quot; target=&quot;_blank&quot;&gt;Java系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086498&quot; target=&quot;_blank&quot;&gt;Spring系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086732&quot; target=&quot;_blank&quot;&gt;Docker系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086794&quot; target=&quot;_blank&quot;&gt;kubernetes系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086850&quot; target=&quot;_blank&quot;&gt;数据库+中间件系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086920&quot; target=&quot;_blank&quot;&gt;DevOps系列&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;欢迎关注公众号：程序员欣宸&quot;&gt;欢迎关注公众号：程序员欣宸&lt;/h3&gt;
&lt;blockquote readability=&quot;4.258064516129&quot;&gt;
&lt;p&gt;微信搜索「程序员欣宸」，我是欣宸，期待与您一同畅游Java世界...&lt;br/&gt;&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot; target=&quot;_blank&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Mon, 18 Jan 2021 00:23:00 +0000</pubDate>
<dc:creator>程序员欣宸</dc:creator>
<og:description>欢迎访问我的GitHub https://github.com/zq2599/blog_demos 内容：所有原创文章分类汇总及配套源码，涉及Java、Docker、Kubernetes、DevOPS</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/bolingcavalry/p/14291067.html</dc:identifier>
</item>
<item>
<title>SQL Server解惑——查询条件IN中能否使用变量 - 潇湘隐者</title>
<link>http://www.cnblogs.com/kerrycode/p/14291064.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kerrycode/p/14291064.html</guid>
<description>&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;在SQL Server的查询条件中，能否在IN里面使用变量呢？ 如果可以的话，有没有需要注意的地方或一些限制呢？在回答这个问题前，我们先来看看这个例子：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div id=&quot;codeSnippetWrapper&quot; readability=&quot;9.5&quot;&gt;
&lt;div id=&quot;codeSnippet&quot; readability=&quot;14&quot;&gt;
&lt;pre&gt;
&lt;span&gt;IF&lt;/span&gt; &lt;span&gt;EXISTS&lt;/span&gt; (&lt;span&gt;SELECT&lt;/span&gt; 1 &lt;span&gt;FROM&lt;/span&gt; sys.objects &lt;span&gt;WHERE&lt;/span&gt; name=&lt;span&gt;'TEST'&lt;/span&gt; &lt;span&gt;AND&lt;/span&gt; type=&lt;span&gt;'U'&lt;/span&gt;)
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;BEGIN&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
    &lt;span&gt;DROP&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt; TEST;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;END&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;GO&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt; TEST ( ID &lt;span&gt;INT&lt;/span&gt;, NAME &lt;span&gt;VARCHAR&lt;/span&gt;(16) );
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;GO&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
INSERT &lt;span&gt;INTO&lt;/span&gt; dbo.TEST
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; 1, &lt;span&gt;'a'&lt;/span&gt;  &lt;span&gt;UNION&lt;/span&gt; &lt;span&gt;ALL&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; 2, &lt;span&gt;'b'&lt;/span&gt;  &lt;span&gt;UNION&lt;/span&gt; &lt;span&gt;ALL&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; 3, &lt;span&gt;'c'&lt;/span&gt;  &lt;span&gt;UNION&lt;/span&gt; &lt;span&gt;ALL&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; 4, &lt;span&gt;'a,b'&lt;/span&gt;&lt;span&gt;UNION&lt;/span&gt; &lt;span&gt;ALL&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; 5, &lt;span&gt;''&lt;/span&gt;&lt;span&gt;'b'&lt;/span&gt;&lt;span&gt;','&lt;/span&gt;&lt;span&gt;'c'&lt;/span&gt;&lt;span&gt;''&lt;/span&gt; &lt;span&gt;UNION&lt;/span&gt; &lt;span&gt;ALL&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; 6, &lt;span&gt;''&lt;/span&gt;&lt;span&gt;'b'&lt;/span&gt;;
&lt;/pre&gt;
&lt;pre&gt;
GO
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;a href=&quot;https://img2020.cnblogs.com/blog/73542/202101/73542-20210118081920142-679171634.png&quot;&gt;&lt;img title=&quot;clip_image001&quot; border=&quot;0&quot; alt=&quot;clip_image001&quot; src=&quot;https://img2020.cnblogs.com/blog/73542/202101/73542-20210118081920881-69613146.png&quot; width=&quot;651&quot; height=&quot;345&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;如下所示，如果查询条件里面，变量只有一个值，此时SQL是正常的。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div id=&quot;codeSnippetWrapper&quot; readability=&quot;9&quot;&gt;
&lt;div id=&quot;codeSnippet&quot; readability=&quot;13&quot;&gt;
&lt;pre&gt;
&lt;span&gt;DECLARE&lt;/span&gt; @name &lt;span&gt;VARCHAR&lt;/span&gt;(16);
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;SET&lt;/span&gt; @name=&lt;span&gt;'a'&lt;/span&gt;;
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; * &lt;span&gt;FROM&lt;/span&gt; TEST &lt;span&gt;WHERE&lt;/span&gt; name &lt;span&gt;IN&lt;/span&gt; (@name);
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;GO&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;DECLARE&lt;/span&gt; @name &lt;span&gt;VARCHAR&lt;/span&gt;(16);
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;SET&lt;/span&gt; @name=&lt;span&gt;'a,b'&lt;/span&gt;;
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; * &lt;span&gt;FROM&lt;/span&gt; TEST &lt;span&gt;WHERE&lt;/span&gt; name &lt;span&gt;IN&lt;/span&gt; (@name);
&lt;/pre&gt;
&lt;pre&gt;
GO
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;如果我们想在查询条件IN里面输入多个值呢？假如有这样的一个需求，一个变量里面包含b和c的值，现在用'b|c&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;’&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;作为条件传入，对其进行拆分为变量'b'和'c', 想查出name=b 和name=c的记录，如下截图所示，SQL其实并没有按你所&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;“&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;设想/预想&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;”&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;的查出对应记录，而是将ID=5的记录查出来了&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div id=&quot;codeSnippetWrapper&quot; readability=&quot;10.5&quot;&gt;
&lt;div id=&quot;codeSnippet&quot; readability=&quot;16&quot;&gt;
&lt;pre&gt;
&lt;span&gt;DECLARE&lt;/span&gt; @name1 &lt;span&gt;VARCHAR&lt;/span&gt;(16);
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;DECLARE&lt;/span&gt; @name2 &lt;span&gt;VARCHAR&lt;/span&gt;(16);
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;SET&lt;/span&gt; @name1=&lt;span&gt;'b|c'&lt;/span&gt;;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;SET&lt;/span&gt; @name2=REPLACE(@name1,&lt;span&gt;'|'&lt;/span&gt;,&lt;span&gt;''&lt;/span&gt;&lt;span&gt;','&lt;/span&gt;&lt;span&gt;''&lt;/span&gt;)
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; @name2
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; * &lt;span&gt;FROM&lt;/span&gt; TEST &lt;span&gt;WHERE&lt;/span&gt; name &lt;span&gt;IN&lt;/span&gt; ((&lt;span&gt;''&lt;/span&gt;&lt;span&gt;''&lt;/span&gt; + @name2 + &lt;span&gt;''&lt;/span&gt;&lt;span&gt;''&lt;/span&gt;));
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;a href=&quot;https://img2020.cnblogs.com/blog/73542/202101/73542-20210118081921249-523136337.png&quot;&gt;&lt;img title=&quot;clip_image002&quot; border=&quot;0&quot; alt=&quot;clip_image002&quot; src=&quot;https://img2020.cnblogs.com/blog/73542/202101/73542-20210118081921605-1579567965.png&quot; width=&quot;652&quot; height=&quot;394&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;下面这个SQL也是同样的结果。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div id=&quot;codeSnippetWrapper&quot; readability=&quot;10.5&quot;&gt;
&lt;div id=&quot;codeSnippet&quot; readability=&quot;16&quot;&gt;
&lt;pre&gt;
&lt;span&gt;DECLARE&lt;/span&gt; @name1 &lt;span&gt;VARCHAR&lt;/span&gt;(16);
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;DECLARE&lt;/span&gt; @name2 &lt;span&gt;VARCHAR&lt;/span&gt;(16);
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;SET&lt;/span&gt; @name1=&lt;span&gt;'b|c'&lt;/span&gt;;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;SET&lt;/span&gt; @name2=&lt;span&gt;''&lt;/span&gt;&lt;span&gt;''&lt;/span&gt; + REPLACE(@name1,&lt;span&gt;'|'&lt;/span&gt;,&lt;span&gt;''&lt;/span&gt;&lt;span&gt;','&lt;/span&gt;&lt;span&gt;''&lt;/span&gt;) +&lt;span&gt;''&lt;/span&gt;&lt;span&gt;''&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; @name2
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; * &lt;span&gt;FROM&lt;/span&gt; TEST &lt;span&gt;WHERE&lt;/span&gt; name &lt;span&gt;IN&lt;/span&gt; (@name2 );
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;为什么出现了这样的结果呢？ 查了大量的官方文档，没有看到关于这个问题的介绍和解释。如果一定要解释上面现象的情况的话，那么是因为&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt;SELECT&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; &lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;*&lt;/span&gt;&lt;/span&gt; &lt;span&gt;&lt;span&gt;FROM&lt;/span&gt;&lt;/span&gt; TEST &lt;span&gt;&lt;span&gt;WHERE&lt;/span&gt;&lt;/span&gt; name &lt;span&gt;&lt;span&gt;IN&lt;/span&gt;&lt;/span&gt; &lt;span&gt;&lt;span&gt;(&lt;/span&gt;&lt;/span&gt;@name2&lt;/span&gt; &lt;span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;&lt;span&gt;&lt;span&gt;其实转化为了&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt;SELECT&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; &lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;*&lt;/span&gt;&lt;/span&gt; &lt;span&gt;&lt;span&gt;FROM&lt;/span&gt;&lt;/span&gt; TEST &lt;span&gt;&lt;span&gt;WHERE&lt;/span&gt;&lt;/span&gt; name &lt;span&gt;&lt;span&gt;=&lt;/span&gt;&lt;/span&gt;@name2&lt;/span&gt;&lt;span&gt;&lt;span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;&lt;span&gt;&lt;span&gt;也就是说，上面SQL并不会按你所&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;“&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;设想&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;”&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;的逻辑运算。而是做了一个转换，为什么说是这样的一个转换呢？ 当然这也是一个猜想，上面构造的例子也是为了侧面验证这个猜想，另外，上面两个SQL实际执行计划的参数列表（Parameter List）也侧面印证了这个猜想。如果执行计划解析成我们想要的结果，那么Parameter List应该是'b' 和&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;‘&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;c'&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;a href=&quot;https://img2020.cnblogs.com/blog/73542/202101/73542-20210118081921965-2019845137.png&quot;&gt;&lt;img title=&quot;clip_image003&quot; border=&quot;0&quot; alt=&quot;clip_image003&quot; src=&quot;https://img2020.cnblogs.com/blog/73542/202101/73542-20210118081922311-128602673.png&quot; width=&quot;652&quot; height=&quot;268&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;a href=&quot;https://img2020.cnblogs.com/blog/73542/202101/73542-20210118081922694-346326400.png&quot;&gt;&lt;img title=&quot;clip_image004&quot; border=&quot;0&quot; alt=&quot;clip_image004&quot; src=&quot;https://img2020.cnblogs.com/blog/73542/202101/73542-20210118081923063-168118798.png&quot; width=&quot;662&quot; height=&quot;261&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;解决方案：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;1：使用动态SQL&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;使用动态SQL解决问题，似乎没啥好说的，如下例子所示：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div id=&quot;codeSnippetWrapper&quot; readability=&quot;10.5&quot;&gt;
&lt;div id=&quot;codeSnippet&quot; readability=&quot;16&quot;&gt;
&lt;pre&gt;
&lt;span&gt;DECLARE&lt;/span&gt; @sql_cmd NVARCHAR(&lt;span&gt;max&lt;/span&gt;);
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;DECLARE&lt;/span&gt; @name &lt;span&gt;VARCHAR&lt;/span&gt;(16);
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;SET&lt;/span&gt; @name=&lt;span&gt;'b|c'&lt;/span&gt;;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;SET&lt;/span&gt; @sql_cmd=&lt;span&gt;'SELECT * FROM TEST WHERE name IN ('&lt;/span&gt;&lt;span&gt;''&lt;/span&gt; + REPLACE(@name,&lt;span&gt;'|'&lt;/span&gt;,&lt;span&gt;''&lt;/span&gt;&lt;span&gt;','&lt;/span&gt;&lt;span&gt;''&lt;/span&gt;) +&lt;span&gt;''&lt;/span&gt;&lt;span&gt;');'&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;EXEC&lt;/span&gt; sp_executesql @sql_cmd;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;a href=&quot;https://img2020.cnblogs.com/blog/73542/202101/73542-20210118081923422-234915569.png&quot;&gt;&lt;img title=&quot;clip_image005&quot; border=&quot;0&quot; alt=&quot;clip_image005&quot; src=&quot;https://img2020.cnblogs.com/blog/73542/202101/73542-20210118081923720-727130134.png&quot; width=&quot;652&quot; height=&quot;286&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;2：使用临时表或表变量&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;   &lt;/span&gt;&lt;/span&gt; &lt;span&gt;以这个例子来说，就是将字符串拆分，放入临时表或表变量，然后关联表也好，在IN里面使用子查询也OK。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;3：借助STRING_SPLIT()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div id=&quot;codeSnippetWrapper&quot; readability=&quot;7.5&quot;&gt;
&lt;div id=&quot;codeSnippet&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;span&gt;DECLARE&lt;/span&gt; @name &lt;span&gt;VARCHAR&lt;/span&gt;(16);
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;SET&lt;/span&gt; @name=&lt;span&gt;'b|c'&lt;/span&gt;;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; *&lt;span&gt;FROM&lt;/span&gt;  test &lt;span&gt;WHERE&lt;/span&gt; name &lt;span&gt;IN&lt;/span&gt; (&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;value&lt;/span&gt; &lt;span&gt;FROM&lt;/span&gt; STRING_SPLIT(@name, &lt;span&gt;'|'&lt;/span&gt;))
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;a href=&quot;https://img2020.cnblogs.com/blog/73542/202101/73542-20210118081924082-1528004607.png&quot;&gt;&lt;img title=&quot;clip_image006&quot; border=&quot;0&quot; alt=&quot;clip_image006&quot; src=&quot;https://img2020.cnblogs.com/blog/73542/202101/73542-20210118081924393-362073424.png&quot; width=&quot;653&quot; height=&quot;244&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;注意&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;：&lt;/span&gt;&lt;span&gt;&lt;span&gt;STRING_SPLIT函数只有较高版本才支持，SQL Server 2017或SQL Server 2016部分版本支持。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;4：借助XML函数来解决问题&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div id=&quot;codeSnippetWrapper&quot; readability=&quot;10.5&quot;&gt;
&lt;div id=&quot;codeSnippet&quot; readability=&quot;16&quot;&gt;
&lt;pre&gt;
&lt;span&gt;DECLARE&lt;/span&gt; @name &lt;span&gt;VARCHAR&lt;/span&gt;(16);
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;DECLARE&lt;/span&gt; @xml_para XML;
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;SET&lt;/span&gt; @name = &lt;span&gt;'b|c'&lt;/span&gt;;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;SET&lt;/span&gt; @xml_para = &lt;span&gt;CAST&lt;/span&gt;(( &lt;span&gt;'&amp;lt;A&amp;gt;'&lt;/span&gt; + REPLACE(@name, &lt;span&gt;'|'&lt;/span&gt;, &lt;span&gt;'&amp;lt;/A&amp;gt;&amp;lt;A&amp;gt;'&lt;/span&gt;) + &lt;span&gt;'&amp;lt;/A&amp;gt;'&lt;/span&gt; ) &lt;span&gt;AS&lt;/span&gt; XML);
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt;  *
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;FROM&lt;/span&gt;    dbo.TEST
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;WHERE&lt;/span&gt;   NAME &lt;span&gt;IN&lt;/span&gt; ( &lt;span&gt;SELECT&lt;/span&gt;    A.&lt;span&gt;value&lt;/span&gt;(&lt;span&gt;'.'&lt;/span&gt;, &lt;span&gt;'varchar(max)'&lt;/span&gt;) &lt;span&gt;AS&lt;/span&gt; [&lt;span&gt;Column&lt;/span&gt;]
&lt;/pre&gt;
&lt;pre&gt;
                  &lt;span&gt;FROM&lt;/span&gt;      @xml_para.nodes(&lt;span&gt;'A'&lt;/span&gt;) &lt;span&gt;AS&lt;/span&gt; FN ( A ) );
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;a href=&quot;https://img2020.cnblogs.com/blog/73542/202101/73542-20210118081924722-354773326.png&quot;&gt;&lt;img title=&quot;clip_image007&quot; border=&quot;0&quot; alt=&quot;clip_image007&quot; src=&quot;https://img2020.cnblogs.com/blog/73542/202101/73542-20210118081925080-879632768.png&quot; width=&quot;653&quot; height=&quot;312&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 18 Jan 2021 00:19:00 +0000</pubDate>
<dc:creator>潇湘隐者</dc:creator>
<og:description>在SQL Server的查询条件中，能否在IN里面使用变量呢？ 如果可以的话，有没有需要注意的地方或一些限制呢？在回答这个问题前，我们先来看看这个例子： IF&amp;#160;EXISTS (SELECT</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/kerrycode/p/14291064.html</dc:identifier>
</item>
<item>
<title>带团队后的日常 - 咖啡机（K.F.J）</title>
<link>http://www.cnblogs.com/strick/p/14129000.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/strick/p/14129000.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;1）开会&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　由于公司规模并不大，因此一有事情就会拉个会议，例如需要大会、技术评审、汇报周会、突发会议等。一周中大概有20%~30%的时间会花在大大小小的会议上。&lt;/p&gt;
&lt;p&gt;　　公司会议难免会出现接锅的情况，虽然自己不想做锅靖，但是有些边界定义比较模糊的锅（既可以给后端，也可以给前端），在时间允许的时候，都会自己接下，因为服务端资源很有限，日常杂活太多，大家打工人都不容易。&lt;/p&gt;
&lt;p&gt;　　虽然比较费时，但会让自己有更多的参与感。公司办公都是用mac pro最新款，携带也比较方便，开会的时候带个笔记本，也可以在会议中处理一些工作的事情。&lt;/p&gt;
&lt;p&gt;　　在团队成员来齐后，每周五的10点，自己还会组织一个团队短会，一般控制在30分钟内。不是工作汇报，而是：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;回顾一下本周遇到的难点或费时的事情，若还未解决，可在会议上当场讨论思路。避免下次碰到又要花费太多精力。&lt;/li&gt;
&lt;li&gt;发表一下自己这周遇到的困惑，无论是技术还是公司，都可以随意发表。互相了解一下团队成员的想法。&lt;/li&gt;
&lt;li&gt;我也会传达一些公司信息，例如本周或下周的重点任务、公司的新政策等，及时与团队成员同步。&lt;/li&gt;
&lt;li&gt;若有时间还会做个简短的 Code Review，或者做技术分享，无论是当前前沿技术，或者是经典案例，都行。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;2）任务分配&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　目前公司两条产品线，加上我是3个人，他们各自负责一条线。若一些需求没时间做的时候，我也会帮忙写。&lt;/p&gt;
&lt;p&gt;　　并且与组内成员要保持任务信息的同步，大家都得清楚现在做什么，未来还有哪些活需要处理。&lt;/p&gt;
&lt;p&gt;　　新同学刚来没多久，还在适应期，给他的任务都不是紧急的。当抽不出人手时，也会让他搞，不过我和另一个同学也会协助他。&lt;/p&gt;
&lt;p&gt;　　当有紧急需求时，我会将优先级不高的任务延后，并安排给合适的人处理。&lt;/p&gt;
&lt;p&gt;　　自己除了开会之外，也要写代码，一些难弄麻烦费时的功能都留给了自己，例如那些跨团队的、或是测试环境不容易部署的功能。&lt;/p&gt;
&lt;p&gt;　　每天也会关注一下组员的进度，遇到问题可以帮忙出解决方案或应对策略，以免卡在一个地方，既影响心情，也影响开发进度。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3）错误调试&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　我们Web小组不仅维护着一个庞大的后台管理系统（前后台都做），还参与过许多后端服务（例如定时任务、金额结算）、H5活动页面、微信公众号、小程序等。&lt;/p&gt;
&lt;p&gt;　　因此，很多时候线上出问题，都会与我们组有关。经常是某个人找到我，向我反馈问题，严重的话我就得停下手中工作，立刻去拍错。&lt;/p&gt;
&lt;p&gt;　　我花了很多时间去做各种错误调试，并且经常会出现跨团队的场景，而我排错的过程一般是几步：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;页面样式出错，那毫无疑问是我们组的问题，除非那人看错了，将客户端的页面报到了我们这边。&lt;/li&gt;
&lt;li&gt;若是调用的接口问题（所有的前端接口都会通过Node服务做一层中转），那么会将接口路径拿到VS Code中做一次项目搜索，查看代码逻辑。&lt;/li&gt;
&lt;li&gt;若内部核心逻辑是调用服务端内部接口，那么就需要将问题反馈给他们，再做联调和定位是谁的问题。&lt;/li&gt;
&lt;li&gt;若接口中的逻辑没有调用内部接口，都是直接操作数据库的，那么就要查找数据库写入的逻辑。若没有，那么就去找谁在维护这张表。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;　　之前就遇到过一个问题，说是后台的一张重要的统计报表没数据了。查了半天，发现是一个定时任务在做写入，而在这个定时任务中又会涉及MongoDB的写入、客户端的上报、第三方平台和服务端的读取。在一一排除后，最终发现是服务端在写入其中一个数据源时，日期写的不对（由于时区的问题）。断断续续花了4天的时间，期间与运维、客户端、服务器、测试还有第三方平台的技术人员先后做过沟通，这种排错很费成本。&lt;/p&gt;
&lt;p&gt;　　后面又遇到一个问题，也是与后台有关，说是一张统计表看不到了。这次也是先查写入的代码，发现没有，马上与服务端联系，他们那边也没有。于是就找到测试组，因为他们组目前是公司内最了解整个管理系统的人，果然找对了人，他就说是AI算法组在维护的。找到他们之后，才查出是他们的一个定时任务挂了，怪不得没有数据。之后在周会上，我就提出让他们统计出自己维护的数据库表，并且是那些与我们组相关的数据库中的表。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4）完善文档&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　先前的 WIKI 已有部分文档，但内容非常分散，不成体系，我花了点时间重新梳理，并整理到合适的位置。&lt;/p&gt;
&lt;p&gt;　　书写之前没有的文档，尤其是现在比较重要的业务或功能，完善业务流程，甚至将相关的 SQL 查询语句都整理了出来，方便调试。&lt;/p&gt;
&lt;p&gt;　　邀请其他组的成员帮忙书写相关的文档，例如让客户端组完善 JSBridge 文档，而测试组是目前掌握最多业务细节的人，让他们帮忙写些发生突发情况或意外故障的处理过程。&lt;/p&gt;

&lt;p&gt;　　日常的工作除了做业务需求（俗称写BUG）之外，其实就是发现问题，再解决问题，有时间的话，找出合理的优化手段，避免重复踩坑。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1）MongoDB可视化界面&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　若要查询MySQL，可以借助DMS可视化界面。但要查询MongoDB，那么只能先连上跳板机，然后再通过跳板机进入MongoDB服务器，这一来一回经常要耗上点时间。&lt;/p&gt;
&lt;p&gt;　　因此，后面就着手自己写了一个简易的可视化界面，只提供查询功能。Node代码中的ORM系统采用的是Mongoose库，那么就从其find()方法着手。&lt;/p&gt;
&lt;p&gt;　　界面中需要传入一个Model名称，多行文本中只要传入 where 条件即可，语法参考的是 &lt;span&gt;&lt;a href=&quot;https://docs.mongoing.com/can-kao/mongo-shell-methods/collection-methods/db-collection-find&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;db.collection.find()&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;，下图灰色使用了 &amp;lt;pre&amp;gt; 标签，为了能在页面中显示空行和换行。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202012/211606-20201215171223807-409653262.png&quot; height=&quot;500&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　在后台管理系统中，原先有个查询redis的界面，但只查了一个库，数据类型也只列了4种，后面将库修改为可配，并且新增了一个数据类型。&lt;/p&gt;
&lt;p&gt;　　从而就能避免通过跳板机来读取redis中的缓存，可直接在页面中查询。&lt;/p&gt;
&lt;p&gt;　　脚本文件的执行，原先除了上传代码之外，还得进入服务器中，手动输入命令执行。&lt;/p&gt;
&lt;p&gt;　　这么操作略微繁琐，自己做了点加工，做成半自动，代码还是要发，不过在后台管理系统中有个按钮，点击后就能执行指定的脚本，下面是执行接口，调用了 fork() 方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
router.get('/scripts/exec', async (ctx) =&amp;gt;&lt;span&gt; {
    const path &lt;/span&gt;= require('path'&lt;span&gt;);
    const { fork } &lt;/span&gt;= require('child_process'&lt;span&gt;);
    const exactPath &lt;/span&gt;= path.resolve(__dirname, 'scripts/index.js'&lt;span&gt;);
    fork(exactPath);
    ctx.body &lt;/span&gt;= { code: 0&lt;span&gt; };
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;2）微信公众号配置封装&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　调用微信公众号的JS-SDK之前，都是需要先引入配置文件的。先前的做法是先在前端脚请求一个接口，响应得到timestamp、noncestr和signature等参数。&lt;/p&gt;
&lt;p&gt;　　然后调用wx.config()进行配置，最后在wx.ready()调用微信的onMenuShareTimeline()、onMenuShareAppMessage()等方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
    const wx = require(&quot;weixin-js-sdk&quot;&lt;span&gt;);
    const wxUrl &lt;/span&gt;= encodeURIComponent(location.href.split(&quot;#&quot;)[0&lt;span&gt;]);
    getWeixin(wxUrl).then((e) &lt;/span&gt;=&amp;gt;&lt;span&gt; {
      wx.config({
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; debug: true,&lt;/span&gt;
        appId: &quot;wx....&quot;, 　　　　　　　　　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 必填，公众号的唯一标识&lt;/span&gt;
        timestamp: e.timestamp, 　　　　　 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 必填，生成签名的时间戳&lt;/span&gt;
        nonceStr: e.noncestr, 　　　　　　 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 必填，生成签名的随机串&lt;/span&gt;
        signature: e.signature, 　　　 　 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 必填，签名&lt;/span&gt;
&lt;span&gt;        jsApiList: [
          &lt;/span&gt;&quot;onMenuShareTimeline&quot;&lt;span&gt;,
          &lt;/span&gt;&quot;onMenuShareAppMessage&quot;&lt;span&gt;,
        ], 
      });
    });
    wx.ready(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
      wx.onMenuShareTimeline({
        title: &lt;/span&gt;&quot;&quot;&lt;span&gt;,
        desc: &lt;/span&gt;&quot;&quot;&lt;span&gt;,
        link: &lt;/span&gt;&quot;&quot;&lt;span&gt;,
        imgUrl: &lt;/span&gt;&quot;&quot;&lt;span&gt;,
        success: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {},
      });
      wx.onMenuShareAppMessage({
        title: &lt;/span&gt;&quot;&quot;&lt;span&gt;,
        desc: &lt;/span&gt;&quot;&quot;&lt;span&gt;,
        link: &lt;/span&gt;&quot;&quot;&lt;span&gt;,
        imgUrl: &lt;/span&gt;&quot;&quot;&lt;span&gt;,
        success: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {},
      });
    });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　一旦需要用到微信JS-SDK就要调用这么一坨，但其实这些可以都放到服务端去执行。&lt;/p&gt;
&lt;p&gt;　　后面我将上述配置封装到后端的一个router方法中，路由成一个JS文件（例如bridge.js），前端只要调用它，然后传递一些参数做一些简单的变量声明即可，完全不需要配置appid、signature等参数。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3）后台管理系统界面优化&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　后台管理系统都会包含左边的菜单栏，刚接手的时候，每次页面刷新，菜单栏默认就会闭合，不会展开当前URL路径所处的菜单。&lt;/p&gt;
&lt;p&gt;　　在调试的时候，改一下脚本就会自动刷新窗口，一刷新菜单就会闭合，导致我要换旁边的菜单时，又要一步步的点击。&lt;/p&gt;
&lt;p&gt;　　于是就着手开始优化，在查看代码时发现，菜单数据被抽象成了多叉树结构，而选中某个页面的菜单，其实就是用深度优先算法来匹配指定路径，下面用代码简单的实现了这个功能。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;深度优先 搜索当前菜单&lt;/span&gt;
  let defaultSelectedKeys = [],   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;默认选中的菜单&lt;/span&gt;
    defaultOpenKeys = [],         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;默认需要展开的菜单路径&lt;/span&gt;
    isFind = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
  const dfs &lt;/span&gt;= (node, keys) =&amp;gt;&lt;span&gt; {
    keys.push(node.id);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(node.routers ==&lt;span&gt; props.path) {
      isFind &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
      defaultSelectedKeys.push(node.id);  
      defaultOpenKeys &lt;/span&gt;=&lt;span&gt; keys;
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    }
    node.children &lt;/span&gt;&amp;amp;&amp;amp; node.children.forEach(value =&amp;gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(isFind)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
      dfs(value, [...keys]);
    });
  };
  dfs(menuTree[&lt;/span&gt;0], []);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　其实算法离我们平时的业务并不远，只要用心发现就能挖掘出各类算法。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4）发布系统问题&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　公司买了第三方平台的一套发布系统服务，每次发布时，都会比较耗时，卡在某一步，少则7、8分钟，多则10几、20多分钟。&lt;/p&gt;
&lt;p&gt;　　向运维也反馈过很多次，但每次都没有找到针对性的解决办法。&lt;/p&gt;
&lt;p&gt;　　最后无奈，只得和运维商量，在测试环境，自己写个文件传输工具，直接把build后的代码传到指定目录，跳过发布系统。&lt;/p&gt;
&lt;p&gt;　　毕竟测试环境要经常发代码，老这么延迟，实在是会让人困扰。运维的意思是他们提供脚本，我们在跳板机上运行脚本，实现文件传输。&lt;/p&gt;
&lt;p&gt;　　虽然没有一键传输方便，但聊胜于无，总比干等好，同意了这个方案，后续跟进。&lt;/p&gt;
&lt;p&gt;　　期间还碰到了另一个棘手的问题，那就是测试和正式环境的Node版本过低，比当前稳定版本低了6个版本。&lt;/p&gt;
&lt;p&gt;　　这就导致很多库不能直接安装，得另想办法或者用该库比较老的版本。&lt;/p&gt;
&lt;p&gt;　　现在也不能立马更新，一更新就出错，测试也没有额外的资源帮忙一起调试。时间与资源的矛盾暂时还不能妥善解决。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;5）性能分析日志&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　公司购买了阿里云的日志服务，之前几个纯前端的项目虽然开通了日志服务，但并没有妥善使用起来。&lt;/p&gt;
&lt;p&gt;　　这次正好想到可以开通阿里云的&lt;span&gt;&lt;a href=&quot;https://help.aliyun.com/document_detail/67246.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;WebTracking&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;的采集功能，将性能参数推送到阿里云日志服务器中，参数搜集的库采用了之前自己封装的&lt;span&gt;&lt;a href=&quot;https://github.com/pwstrick/pineapple/tree/master/sdk&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;pineapple.js&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;性能参数demo&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;utf-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    window.pineapple &lt;/span&gt;&lt;span&gt;||&lt;/span&gt;&lt;span&gt; (pineapple &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; {});
    pineapple.param &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;token&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a0b923820dcc509a&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    };
  &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;pineapple.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在参数搜集好后，就能借助阿里云强大的&lt;span&gt;&lt;a href=&quot;https://help.aliyun.com/document_detail/63445.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;查询分析&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;功能，分析页面性能了，目前还没想好分析维度。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202012/211606-20201221182955752-494707727.png&quot; width=&quot;800&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 18 Jan 2021 00:05:00 +0000</pubDate>
<dc:creator>咖啡机（K.F.J）</dc:creator>
<og:description>一、日常工作 1）开会 由于公司规模并不大，因此一有事情就会拉个会议，例如需要大会、技术评审、汇报周会、突发会议等。一周中大概有20%~30%的时间会花在大大小小的会议上。 公司会议难免会出现接锅的情</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/strick/p/14129000.html</dc:identifier>
</item>
<item>
<title>理解领域驱动设计 - 微笑刺客D</title>
<link>http://www.cnblogs.com/CKExp/p/14289377.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CKExp/p/14289377.html</guid>
<description>&lt;p&gt;什么是领域，我习惯描述的是制药领域、环境领域、建筑领域、金融领域等，而在领域内，各种业务规则、业务知识盛行，如何有效的把控规则的变化，应对复杂知识，有一个很关键的四字词语，分而治之。分治法在很多场景下体现了其强大的作用力。领域本身很大，那就拆分，得到更小的领域，也即子域，如同递归调用一般，将一个复杂问题拆分单独求解，而最终将解汇总得到复杂问题解。&lt;/p&gt;
&lt;p&gt;怎么拆，拆成怎么样合适，依据什么拆，这些在领域驱动设计中有了一套答案，虽然领域驱动设计不是银弹，但可以说的上是一套极好的系统方法论或称为架构设计的方法论。&lt;/p&gt;
&lt;p&gt;领域驱动设计常以战略设计与战术设计来将整个领域展现的淋漓尽致，其作用范围既面向业务也面向技术。从战略角度(个人更喜欢称其为上帝视角)去规划系统、划分领域。而从战术角度则从技术层面来指导我们该如何去设计。&lt;/p&gt;

&lt;p&gt;战略设计主要从高层俯视(上帝视角)我们的软件系统，就如同玩即时战略游戏般，可以一览地图全貌，以此来决定我们是要进攻还是防守哪个方向，同样，在软件中我们也可以以此来划分领域，确定权重方向。&lt;/p&gt;
&lt;h2 id=&quot;统一语言&quot;&gt;统一语言&lt;/h2&gt;
&lt;p&gt;提炼领域知识，怎么个提炼法，千万条罗马路，各有各的看家本领。像事件风暴方法，用例分析方法，用户故事，甚至是开大会，各种讨论会等，最终目的都是提炼出领域知识，而提炼过程中，达成描述上的一致性，包括系统目标、系统范围及系统所具有的功能。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/news/1133736/202101/1133736-20210117163900146-1758749633.png&quot; alt=&quot;图片&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这不是领域驱动设计所独有的，但却是软件开发中所必须的，为领域专家、业务分析人员、编码人员和测试人员等团队所有成员交流时构建统一频道。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1133736/202101/1133736-20210117163900786-358971098.png&quot; alt=&quot;图片&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;领域子域&quot;&gt;领域/子域&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1133736/202101/1133736-20210117163901488-803831949.png&quot; alt=&quot;图片&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;领域拆分&quot;&gt;领域拆分&lt;/h3&gt;
&lt;p&gt;对于领域这个概念，习惯性会想到制药领域、环境领域、金融领域等这些概念，而领域本身所描述的是范围，是如同现实世界般的复杂，无边际。借助分治法，将问题逐级细分来降低业务和技术复杂度，将这复杂的世界划分出清晰的边界来，反过来控制着划分后不那么复杂的世界，也既领域拆分出细化后的子领域。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/news/1133736/202101/1133736-20210117163901909-834611873.png&quot; alt=&quot;图片&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;子域划分&quot;&gt;子域划分&lt;/h3&gt;
&lt;p&gt;在实际解决问题时，我们也习惯将问题拆分，而怎么拆，基于什么原则拆，可能会依据相关性，权重，甚至分类原则等，对于系统而言，会从架构方面考虑，基础设施考虑等，在领域驱动设计中，更偏向基于业务拆分，降低业务复杂度，也分离技术实现的复杂度，依照业务拆分后的子领域，本身存在权重上的差异，依照重要性和功能划分为三类，投资占比也就有所不同。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;核心域&lt;/strong&gt;：其所体现的是核心服务，是代表着产品的核心竞争力。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;支撑域&lt;/strong&gt;：其所体现的是支撑服务，没它不行，但又达不到核心的价值，围绕着产品内部所需要，但又不能单独变更为第三方服务，即它不是一个通用的服务。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;通用域&lt;/strong&gt;：其所体现的中间件服务或第三方服务。本身可以通过现有的解决方案集成来完成的服务。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1133736/202101/1133736-20210117163902258-1510661809.png&quot; alt=&quot;图片&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;限界上下文&quot;&gt;限界上下文&lt;/h2&gt;
&lt;p&gt;深入到一个子域中，又是一片小天地，在这天地中，却又还是存在着因语义与语境上的差异，让一些概念在这子域中显得额外尴尬。在一个领域 / 子域中，我们会创建一个概念上的领域边界，在这个边界中，任何领域对象都只表示特定于该边界内部的确切含义。这样边界便称为限界上下文。&lt;/p&gt;
&lt;p&gt;其本质上是限界+上下文，引用到张逸老师的一句话&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;上下文（Context）其实是动态的业务流程被边界（Bounded）静态切分的产物&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于子域与上下文间的关系，看到很多书籍或是文章中所描述的都不一样，这块的争论也没有一个最终答案，个人更倾向于子域中划分上下文，从拆分角度来讲，这样理解更加简单。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1133736/202101/1133736-20210117163902564-236413179.png&quot; alt=&quot;图片&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;上下文识别&quot;&gt;上下文识别&lt;/h3&gt;
&lt;p&gt;对于上下文的识别，没有可遵循的标准可走，从不同的角度切入将会识别到不同的上下文，可从张逸老师的领域驱动设计实践中窥之一二，以业务复杂度、管理复杂度和技术复杂度出发，面对这三个角度去依次分析，从业务视角、工作视角、应用视角去识别，进而识别出准确的上下文，通过不断的分析斟酌考虑，逐渐识别出符合当前预期的上下文，如在实际操作环节发觉当前上下文的设计显得不那么合理，还可再进行变动、拆分上下文。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/news/1133736/202101/1133736-20210117163903030-1037980104.png&quot; alt=&quot;图片&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但需注意的一个是，我们识别上下文的目的是什么，是为了控制上下文，准确的说是为了控制上下文的边界、大小，是为了保住我们所守护的上下文不会因过度成长变大而奔溃，亦或因上下文过度缩减而失去价值，保证上下文内一切的稳定，上下文与上下文间交互的可用性，也或者是当我们退出上下文时，交付出来的上下文是非常可观的，而不是一个烂摊子。&lt;/p&gt;
&lt;h3 id=&quot;上下文映射&quot;&gt;上下文映射&lt;/h3&gt;
&lt;p&gt;规划了这么多限界上下文，该如何穿针引线将这些上下文串起来便是一个问题了，用例场景的完整实现往往是由多个上下文的协作完成的，怎么去组织这些上下文，领域驱动设计提到的几种方式及软件工程中常用模式。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;合作关系：一荣俱荣，一损俱损。&lt;/li&gt;
&lt;li&gt;共享内核：上下文间共享领域实体。&lt;/li&gt;
&lt;li&gt;客户方-供应方：下游客户依赖于上游供应方。&lt;/li&gt;
&lt;li&gt;遵奉者：下游客户顺应上游供应方。&lt;/li&gt;
&lt;li&gt;各行其道：没有关系的关系，相互隔离。&lt;/li&gt;
&lt;li&gt;防腐层：在下游上下文与上游间增加一道屏障，以此来隔绝与上游的直接交互保护下游。&lt;/li&gt;
&lt;li&gt;开放主机服务：在上游与下游上下文间增加一道协议，以此来规范下游对上游的集成。&lt;/li&gt;
&lt;li&gt;已发布语言：发布方上下文发布一份包含丰富文档的信息交换语言，消费方上下文翻译并使用。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这些模式其本质是为了&lt;strong&gt;协作&lt;/strong&gt;，为了满足用例场景下对多个限界上下文的调用，通过上下文映射图，可以清楚知晓运行逻辑。为了实现上下文映射，简单讲就是如何将两个上下文连贯起来，常借助的方式是诸如 RPC、HTTP、消息队列等，依照上下文间映射类型，挑选一件趁手的工具。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1133736/202101/1133736-20210117163903529-1169926867.png&quot; alt=&quot;图片&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;分层架构&quot;&gt;分层架构&lt;/h2&gt;
&lt;p&gt;我们通常喜欢对各种事情归纳总结，如文章的层次分明，如建筑结构高低有序、疏密有致，给人一种各处所关注的信息视角不同，而组合起来显得如此美妙。软件中同样运用着分层来隔离关注点，以此来隔离每层的演进速率。&lt;/p&gt;
&lt;p&gt;当我们考虑限界上下文时，不仅需要去考虑其内部的领域设计，还得从其应用边界本身考虑，限界上下文是属于架构设计层次，主要针对的是后端架构层次的垂直切分，按照经典 DDD 的分层结构来看，共分为如下四层：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1133736/202101/1133736-20210117163903829-938058761.png&quot; alt=&quot;图片&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;User Interface 为用户界面层，向用户展示信息和传入用户命令。这里指的用户不单单只使用用户界面的人，也可能是外部系统，诸如用例中的参与者。&lt;/li&gt;
&lt;li&gt;Application 为应用层，用来协调应用的活动，不包含业务逻辑，通过编排领域模型，包括领域对象及领域服务，使它们互相协作。不保留业务对象的状态，但它保有应用任务的进度状态。&lt;/li&gt;
&lt;li&gt;Domain 为领域层，负责表达业务概念，业务状态信息以及业务规则。尽管保存业务状态的技术细节是由基础设施层实现的，但是反映业务情况的状态是由本层控制并且使用的。领域层是业务软件的核心，领域模型位于这一层。&lt;/li&gt;
&lt;li&gt;Infrastructure 为基础实施层，提供公共的基础设施组件，如持久化机制、消息管道的读取写入、文件服务的读取写入、调用邮件服务、对外部系统的调用等等。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;值得注意的是，给定的分层方式仅仅是逻辑上的分层，而对于实际的物理分层，却又有所不同，但遵守一个前提为好，即限界上下文的边界高于分层的边界。诸如如下两种开发中常见的代码组织方式，都可见到。一种是基于技术分层，而另一种更偏向基于业务分层。&lt;/p&gt;
&lt;p&gt;方式一&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-plain&quot;&gt;- application
  - productcontext
  - ordercontext
  - ...
- domain
  - productcontext
  - ordercontext
  - ...
- infrastructure
  - productcontext
  - ordercontext
  - ...
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;方式二&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-plain&quot;&gt;- productcontext
  - application
  - domain
  - infrastructure
- ordercontext
  - application
  - domain
  - infrastructure
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;具体采用哪种方式，并没有强制要求，无论代码组织结构是否表达了层的概念，都需要充分理解分层的意义，并使得整个代码结构在架构上要吻合分层架构的理念。&lt;/p&gt;

&lt;p&gt;相比于战略设计的怎么规划，战术设计更侧重于怎么执行，详细的设计和编码。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/news/1133736/202101/1133736-20210117163904339-1970828260.png&quot; alt=&quot;图片&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;聚合&quot;&gt;聚合&lt;/h2&gt;
&lt;p&gt;在认识聚合前，我们得对类再次回顾，类是作为我们开发中的最小单元，一切以类构建，而在上下文的视角中，聚合成了最小概念，包装了一组高度相关的对象，上下文内以聚合为最小单元，以此来保证聚合边界。又将分而治之的思想融入到了限界上下文的内部。&lt;/p&gt;
&lt;p&gt;聚合本身是由一个或多个实体及值对象组成，其中一个实体作为聚合根。管理着内部关联的实体与值对象，对外代表着聚合，外部来访者仅可通过聚合根进行访问。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1133736/202101/1133736-20210117163904620-687577611.png&quot; alt=&quot;图片&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对于聚合图的画法，或许因人而异，我更加倾向于用矩形代表实体，椭圆代表值对象，用 UML 类图中的组合-聚合箭头来表示其双方间的关系。&lt;/p&gt;
&lt;p&gt;需要注意的是，此处的聚合不要与 UML 类图中的聚合等同起来，两者含义并不相同。&lt;/p&gt;
&lt;h3 id=&quot;实体&quot;&gt;实体&lt;/h3&gt;
&lt;p&gt;对于实体来讲，这个概念对于我们并不陌生，拥有者唯一的身份标识符，内含属性作为该实体的静态特征，作为聚合所拥有的领域知识，拥有着与自身相关的领域行为。&lt;/p&gt;
&lt;h3 id=&quot;值对象&quot;&gt;值对象&lt;/h3&gt;
&lt;p&gt;对于值对象，我倾向于将它理解为，基础类型之延伸，既能封装基础类型，又能约束内部属性间关系，还能拥有着自身的领域行为，而与实体的区别是，没有唯一身份标识，尽管带来了持久化的一些问题，但还是存在解决方案。以 DateTime 理解值对象最好不过了，DateTime 内部的自身约束保证了，每一次变动的 DateTime 都是最新的，当我们想在 2 月 28 日加 1，这便要依靠 DateTime 中的行为去约束内部的属性。&lt;/p&gt;
&lt;h3 id=&quot;聚合划分&quot;&gt;聚合划分&lt;/h3&gt;
&lt;p&gt;经统一语言与业务分析阶段，借助一系列如事件风暴、用例分析法、名次动词法、四色建模法等活动后，获得了一系列相关联的对象。或可形成一张庞大的对象关联图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1133736/202101/1133736-20210117163904841-1388041672.png&quot; alt=&quot;图片&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如不考虑聚合的划分，我们依照以往的思路便是创建一大堆表，运用三范式或是依靠程序去保证数据的一致性不运用主外键。然后疯狂撸码，CRUD 好不快活。&lt;/p&gt;
&lt;p&gt;而随着业务的逐渐扩张，这当初的想法已有点吃力了，如同树苗逐渐成长，枝叶也逐渐增多。借助枝干我们可以分清叶子的归属，而对象网中呢，变得错综复杂了，也就隐约有了大泥球的征兆。&lt;/p&gt;
&lt;p&gt;借助划分聚合的一些方法，将其规整化。将原有复杂的对象图拆分成可控制的小型对象图。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;保持单一导航方向，解除双向依赖，保持依赖简单。&lt;/li&gt;
&lt;li&gt;保持聚合设计的小巧&lt;/li&gt;
&lt;li&gt;聚合内的业务规则一致性&lt;/li&gt;
&lt;li&gt;通过聚合标识符引用其他聚合&lt;/li&gt;
&lt;li&gt;聚合与协作聚合间因业务场景、进程边界等因素影响，可依照场景使用强一致性或是最终一致性。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如上的对象图依照关系的强弱，关系的主与次进行了聚合划分，或许得出的部分聚合存在不合理处，可再调整其边界。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/news/1133736/202101/1133736-20210117163905332-1609895559.png&quot; alt=&quot;图片&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;聚合协作&quot;&gt;聚合协作&lt;/h3&gt;
&lt;p&gt;聚合与协作聚合之间依照聚合根实体的唯一标识符进行关联，而不是通过依靠协作聚合的引用实例来完成。保持这个原则有助于保持聚合之间的边界并避免加载不必要的对象。如我们&lt;strong&gt;常习惯&lt;/strong&gt;上将关联的集合对象写入到类中，然后在仓储使用时，通过 EF 加载导航属性，以此方便直接加载关联聚合数据。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;//一个聚合内建议用
public class Order : AggregateRoot
{
    public virtual ICollection&amp;lt;OrderItem&amp;gt; OrdrItems { get; set; }
    //...
}
_orderRepository.Include(e=&amp;gt;e.OrderItems).FirstOrDefault();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如 Order 和 OrderItem，当我们考虑将其作为一个聚合时，这么使用，是可以的，但是不能说跨聚合也这么用着，如 Enterprise 和 Order，划分时我们更加倾向于划分为两个聚合，遵循保持聚合原则中，引用聚合根的 Id 这一原则，这将改善聚合的边界使其更加清晰，控制更加妥当。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;//多聚合间不建议这么用
public class Order : AggregateRoot
{
    //遵循聚合原则引用 Enterprice 聚合根 Id,而不是实例
    public int EnterpriceId {get; set;}
    //public virtual Enterprice Enterprice { get; set; }
    //...
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;考虑到多聚合的协作，便要了解下聚合的首要原则，即在一次事务中，只能更改一个聚合的状态，因此当涉及到多个聚合协作时，如创建订单完毕，需要往库存中某一商品数量减少时，订单本身一般会有商品聚合的标识，借助这个标识，通过领域事件或是集成事件方式，事件接收方将相关联的库存聚合调用起来，以此达到多个聚合间的协作。&lt;br/&gt;又或者考虑到，需要调用商品的信息以使得当前订单中商品信息更加丰富，可通过防腐层调用商品所在上下文远程服务或是应用服务，最终本质上是调用商品聚合中的信息丰富到订单中，也使得多个聚合完成协作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1133736/202101/1133736-20210117163905548-669176396.png&quot; alt=&quot;图片&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;应用服务&quot;&gt;应用服务&lt;/h2&gt;
&lt;p&gt;作为限界上下文对外的门户，也即是外观模式的体现。通过用例分析识别出来的用例在此处一一对应存在着，对外提供统一接口，以此满足完整用例场景所需的功能。在应用服务内部，通过编排领域模型对象来完成用例的功能，自身并不包含领域逻辑，但包含着应用逻辑。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1133736/202101/1133736-20210117163905881-1403031505.png&quot; alt=&quot;图片&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可借鉴整洁架构的经典图例来看应用层本身的职责所在，Use Case(用例层)-Application Business Rules，虽然是依靠着领域模型对象才完成的（具体是编排领域模型对象所具有的领域行为），却也说明了应用服务承担着的是用例的职责。&lt;/p&gt;
&lt;p&gt;需要注意的是，应用服务的职责不仅限于编排领域模型对象，还需要控制着横切关注点，如验证、日志、事物等的管理。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;[UnitOfWork]
[Authorize(PermissionNames.PartType_Create)]
public async Task CreatePartType(CreatePartTypeDto input)
{
    await _validatingPartTypeManager.CheckUniqueName(input.Name, input.Category);
    var partType= PartType.Create(input.Name, input.Description)
        .SetCategory(input.Category)
        .SetFactory(input.FactoryName);
    await _partTypeRepository.InsertAsync(partType);
    await _appNotifier.NewPartTypeAsync();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如上，事务、认证、请求参数校验(Dto 内)，协调领域模型对象和基础设施服务，这是应用服务的职责，当然也不仅限于这些职责。&lt;/p&gt;
&lt;h2 id=&quot;领域服务&quot;&gt;领域服务&lt;/h2&gt;
&lt;p&gt;当我们考虑领域逻辑时，首先想到的应该是实体与值对象中具有的领域逻辑，而有些场景下，实体与值对象无法承载这些领域行为，如对多个领域对象作为输入，进行计算并产出一个值对象；又或是需要将操作成集合化的聚合，如在 Supplier 下需要将所有 Order 中的单价汇总，而本身 Supplier 和 Order 是为两个聚合，若考虑借助 Order 去完成该业务操作，不太妥当，在此场景下，可通过领域服务来承载着这些领域行为。&lt;/p&gt;
&lt;p&gt;领域服务存在如下特征：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;执行一个显著的业务操作过程&lt;/li&gt;
&lt;li&gt;对领域对象进行转换&lt;/li&gt;
&lt;li&gt;需要使用多个聚合内的实体和值对象编排业务逻辑&lt;/li&gt;
&lt;li&gt;领域行为需要访问外部资源&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;虽说领域服务能够承载领域逻辑，却不能说将所有的领域逻辑都往里塞，如此，导致领域对象贫血。只有当实体与值对象承载不住或是本身并不属于实体或值对象的职责内时，才考虑领域服务来承载，领域服务是一种妥协的结果，并不是说领域服务越多越好。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;值对象（Value Object）→ 实体（Entity）→ 领域服务（Domain Service）
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如下场景，创建 Invoice，存在几条业务规则，相应 Order 的状态需已完成，并且对应的 Supplier 提供财月信息，这就需要多个聚合的协作，在领域服务编排这些领域对象模型及通过调用外部服务网关，完成业务逻辑。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;// InvoiceManager
public async Task ValidCheck(string orderId, string supplierId)
{
    var order = await _orderService.GetAsync(orderId);
    if(!order.IsCompleted())
    {
      throw new UserFriendlyException(&quot;Order status is not completed&quot;);
    }
    
    var supplier = await _supplierService.GetAsync(supplierId);
    if(!supplier.IsCompleted())
    {
      throw new UserFriendlyException(&quot;Order status is not completed&quot;);
    }
}
public async Task SetFinanceMonth(Invoice invoice, string supplierId)
{
    var supplierFinanceMonth = await _supplierService.GetFinanceMonthAsync(supplierId, Current.Date);
    
    if(supplierFinanceMonth == null)
    {
      throw new UserFriendlyException(&quot;Supplier not provider finance month&quot;);
    }
    
    invoice.SetFinanceMonth(supplierFinanceMonth.StartDate, supplierFinanceMonth.EndDate);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在应用服务中，通过调用聚合及领域服务，完成这一创建 Invoice 的用例。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;[UnitOfWork]
[Authorize(PermissionNames.Invoice_Create)]
public async Task CreateInvoice(CreateInvoiceDto input)
{
    await _invoiceManager.ValidCheck(input.orderId, input.SupplierId);
    var invoice = Invoice.Create(input.Name, input.Description)
        .SetOrder(input.OrderId);
    await _invoiceManager.SetFinanceMonth(invoice, input.SupplierId);
    await _invoiceRepository.InsertAsync(invoice);
    await _appNotifier.NewInvoiceAsync();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;借助领域服务，以此来完成多聚合间的协作，通过应用服务编排领域模型对象，完成一个业务用例。&lt;/p&gt;
&lt;h2 id=&quot;领域事件&quot;&gt;领域事件&lt;/h2&gt;
&lt;p&gt;在软件开发中，事件早已被我们所熟悉，一个按钮按下，产生中断事件，一个回车，前端页面有侦听事件，在事件风暴建模活动中，事件也是作为领域建模的突破口，事件的重要性不言而喻。其本质是发生的事实到引发了相关事情，在这其中的传递的信息便是事件的内容。就如同猫叫了，引发着老鼠跑了，主人醒了，其中的事件便是猫叫了，而该事件是猫执行叫的动作后的结果。&lt;/p&gt;
&lt;p&gt;在领域驱动设计中，最开始的版本中并没有领域事件的概念，在 DDD 社区对领域驱动设计的内容不断的充实中，引入了领域事件。领域事件的命名遵循英语中的“名词 + 动词过去分词”格式，如，提交订单后发布的 OrderCreated 事件，订单完成后 OrderCompleted 事件，用以表示我们建模的领域中发生过的一件事情，也符合着事件本身是具有时间特征。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/news/1133736/202101/1133736-20210117163906552-2105866018.png&quot; alt=&quot;图片&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;center&gt;(EShopOnContainers 中一个例子)&lt;/center&gt;
&lt;p&gt;对于领域事件本身，依据各层的使用方式及面对的目标不同，划分出两种事件类型，领域事件与应用事件(或集成事件)，应用事件侧重于应用层的使用，而领域事件沿用原领域事件的称呼，更偏向于领域层。而又应侧重点不同，又有着不同的使用方式，如领域事件更多的是从领域模型中发布，其最终接收者为当前聚合所在限界上下文，而应用事件更为广阔，从应用层发布，其接收者为当前上下文或是其他上下文。&lt;/p&gt;
&lt;p&gt;基于限界上下文间采用的部署方式不同，也存在着不同的通信方式，如整个应用程序为单体，则所有上下文在同一个进程内，则上下文间事件交互时所采用的可以是进程内的事件总线，或是进程间使用的消息队列，而当在进程间时，就不得不使用进程间的消息队列了。&lt;/p&gt;
&lt;p&gt;由于 DDD 中遵循一个用例对应一个事务，在一个事务中更新一个聚合，因此对于实际场景中需要变更多个聚合下，我们常通过编排方式调用其他聚合的服务，这不可避免的加重了对其他服务的依赖，借助领域事件，则可以很方便的降低这种耦合，同时对于多个聚合的变更操作，由单个聚合的事务变成了多个聚合的事务，又依照实际影响的聚合情况，有着不同的处理方式，如多个协作的聚合为同一上下文内时，可通过强一致性去保证数据一致性，而处于多个限界上下文间的聚合时，则可依照最终一致性保证数据的一致性。&lt;/p&gt;
&lt;p&gt;领域事件主要用途有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;从事件角度丰富了领域模型&lt;/li&gt;
&lt;li&gt;保证聚合间的数据一致性&lt;/li&gt;
&lt;li&gt;实现事件事件溯源和 CQRS 等&lt;/li&gt;
&lt;li&gt;限界上下文间集成(发布订阅模式)&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;资源库&quot;&gt;资源库&lt;/h2&gt;
&lt;p&gt;在刚接触资源库(Repository)时，第一反应便是这就是个 DAO 层，访问数据库，然后吧啦吧啦，但是，当接触的越久，越发认识到第一反应是错的，资源库更多的是对资源的管理，而不仅仅是数据库中的数据，数据库可以作为资源的一部分，但不是全部，我们习惯将对外部系统的调用称为外部资源的获取，这也是将外部系统作为资源的一部分。&lt;/p&gt;
&lt;p&gt;对于聚合来讲，资源库的作用是负责将聚合持久化到数据库的(通常是持久化到数据库)，并且由于聚合根负责维持聚合的生命周期，也就使得应考虑仅聚合根才应该拥有资源库，这也是与 DAO 层不同的地方。&lt;/p&gt;
&lt;p&gt;在分层设计时，考虑将资源库的抽象划分到领域层，属于领域模型对象的一部分，如同设计防腐层的抽象网关般，资源库的抽象作为特殊的网关，当在应用层或是领域层中操作资源库抽象时，将资源库作为管理聚合状态的工具，可以忽视基础设施层中对资源库的具体实现。而在考虑基础设施层中具体实现时，可根据需要选择适合的工具，以此来管理和操作资源。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1133736/202101/1133736-20210117163906789-720285276.png&quot; alt=&quot;图片&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;工厂&quot;&gt;工厂&lt;/h2&gt;
&lt;p&gt;聚合从 0 到 1 的过程，可以通过多种途径创建，一般来讲，我们开发中常直接实例化或是反射实例化，而对于聚合来讲，整个聚合是一个整体，命运共同体，并且由聚合根掌握聚合的生命周期。通常，我们可以借助几种方式来创建聚合，组装聚合，在创建过程中封装业务逻辑。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;聚合自身担任工厂，在聚合根中实现 Factory 方法&lt;/li&gt;
&lt;li&gt;独立的 Factory 类，用于有一定复杂度的创建过程，或者创建逻辑不适合放在聚合根上&lt;/li&gt;
&lt;li&gt;借助其他聚合来创建，其他聚合担任工厂角色&lt;/li&gt;
&lt;li&gt;借助构建者模式灵活组装聚合&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;聚合根的创建有多种方式，依据聚合内掌握知识的多少与创建逻辑的需要可灵活选择。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;//...
var partType= PartType.Create(input.Name, input.Description)
    .SetCategory(input.Category)
    .SetFactory(input.FactoryName);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如借助构建者模式，通过拆分许多小的方法，将过多的参数拆分，以此避免一个创建方法参数中满屏都是参数的情况，需要考虑吧拆分的方法需要满足业务一致性，如内部的一些属性间有约束条件下，需要划分到一个方法中，以维持一致性或不变性。&lt;/p&gt;

&lt;p&gt;从2004年领域驱动设计到现在已经有17年时间了，并且在其中还有诸如六边形架构，洋葱架构，整洁架构等的出现，考虑的侧重点不同，衍生着大量的新概念，也不断地完善着领域驱动设计的思想。在学习与理解领域驱动设计中，总会有新的东西改变我们以往的思想，见到的越多，越发觉认识的越少，这或许也是学起来有点阻力的原因吧。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1133736/202101/1133736-20210117163907025-1339980797.jpg&quot; alt=&quot;图片&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://book.douban.com/subject/25844633/&quot; target=&quot;_blank&quot;&gt;《实现领域驱动设计》-&lt;/a&gt;&lt;a href=&quot;https://book.douban.com/subject/25844633/&quot; target=&quot;_blank&quot;&gt; Vaughn Verno&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://gitbook.cn/gitchat/column/5cdab7fb34b6ed1398fd8de7&quot; target=&quot;_blank&quot;&gt;《领域驱动设计实践》- 张逸&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://herbertograca.com/2017/07/03/the-software-architecture-chronicles/&quot; target=&quot;_blank&quot;&gt;《软件架构编年史》- herbertograca&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/davenkin/p/road-to-ddd.html&quot; target=&quot;_blank&quot;&gt;领域驱动设计实现之路 - 滕云&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://insights.thoughtworks.cn/backend-development-ddd/&quot; target=&quot;_blank&quot;&gt;领域驱动设计编码实践 - 滕云&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.codingthearchitecture.com/2015/03/08/package_by_component_and_architecturally_aligned_testing.html&quot; target=&quot;_blank&quot;&gt;Package by component and architecturally-aligned testing - Simon&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;2021-01-18,望技术有成后能回来看见自己的脚步&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Mon, 18 Jan 2021 00:01:00 +0000</pubDate>
<dc:creator>微笑刺客D</dc:creator>
<og:description>前言 什么是领域，我习惯描述的是制药领域、环境领域、建筑领域、金融领域等，而在领域内，各种业务规则、业务知识盛行，如何有效的把控规则的变化，应对复杂知识，有一个很关键的四字词语，分而治之。分治法在很多</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/CKExp/p/14289377.html</dc:identifier>
</item>
</channel>
</rss>