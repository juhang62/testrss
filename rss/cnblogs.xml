<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>2021-2-19：请问你知道 Java 如何高性能操作文件么？ - 干货满满张哈希</title>
<link>http://www.cnblogs.com/zhxdick/p/14414403.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhxdick/p/14414403.html</guid>
<description>&lt;p&gt;一般高性能的涉及到存储框架，例如 RocketMQ，Kafka 这种消息队列，存储日志的时候，都是通过 Java File MMAP 实现的，那么什么是 Java File MMAP 呢？&lt;/p&gt;

&lt;p&gt;尽管从&lt;strong&gt;JDK 1.4&lt;/strong&gt;版本开始，Java 内存映射文件（Memory Mapped Files）就已经在&lt;code&gt;java.nio&lt;/code&gt;包中，但它对很多程序开发者来说仍然是一个相当新的概念。引入 NIO 后，Java IO 已经相当快，而且内存映射文件提供了 Java 有可能达到的最快 IO 操作，这也是为什么那些高性能 Java 应用应该使用内存映射文件来持久化数据。&lt;br/&gt;作为 NIO 的一个重要的功能，MMAP 方法为我们提供了将文件的部分或全部映射到内存地址空间的能力，同当这块内存区域被写入数据之后会变成脏页，操作系统会用一定的算法把这些数据写入到文件中，而我们的 Java 程序不需要去关心这些。这就是内存映射文件的一个关键优势，即使你的程序在刚刚写入内存后就挂了，操作系统仍然会将内存中的数据写入文件系统。&lt;br/&gt;另外一个更突出的优势是&lt;strong&gt;共享内存&lt;/strong&gt;，内存映射文件可以被多个进程同时访问，起到一种低时延共享内存的作用。&lt;/p&gt;

&lt;pre&gt;
&lt;code&gt;package com.github.hashZhang.scanfold.jdk.file;
import java.io.RandomAccessFile;
import java.nio.ByteBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.util.Random;

public class FileMmapTest {
    public static void main(String[] args) throws Exception {
        //记录开始时间
        long start = System.currentTimeMillis();
        //通过RandomAccessFile的方式获取文件的Channel，这种方式针对随机读写的文件较为常用，我们用文件一般是随机读写
        RandomAccessFile randomAccessFile = new RandomAccessFile(&quot;./FileMmapTest.txt&quot;, &quot;rw&quot;);
        FileChannel channel = randomAccessFile.getChannel();
        System.out.println(&quot;FileChannel初始化时间：&quot; + (System.currentTimeMillis() - start) + &quot;ms&quot;);

        //内存映射文件，模式是READ_WRITE，如果文件不存在，就会被创建
        MappedByteBuffer mappedByteBuffer1 = channel.map(FileChannel.MapMode.READ_WRITE, 0, 128 * 1024 * 1024);
        MappedByteBuffer mappedByteBuffer2 = channel.map(FileChannel.MapMode.READ_WRITE, 0, 128 * 1024 * 1024);

        System.out.println(&quot;MMAPFile初始化时间：&quot; + (System.currentTimeMillis() - start) + &quot;ms&quot;);

        start = System.currentTimeMillis();
        testFileChannelSequentialRW(channel);
        System.out.println(&quot;FileChannel顺序读写时间：&quot; + (System.currentTimeMillis() - start) + &quot;ms&quot;);

        start = System.currentTimeMillis();
        testFileMMapSequentialRW(mappedByteBuffer1, mappedByteBuffer2);
        System.out.println(&quot;MMAPFile顺序读写时间：&quot; + (System.currentTimeMillis() - start) + &quot;ms&quot;);

        start = System.currentTimeMillis();
        try {
            testFileChannelRandomRW(channel);
            System.out.println(&quot;FileChannel随机读写时间：&quot; + (System.currentTimeMillis() - start) + &quot;ms&quot;);
        } finally {
            randomAccessFile.close();
        }

        //文件关闭不影响MMAP写入和读取
        start = System.currentTimeMillis();
        testFileMMapRandomRW(mappedByteBuffer1, mappedByteBuffer2);
        System.out.println(&quot;MMAPFile随机读写时间：&quot; + (System.currentTimeMillis() - start) + &quot;ms&quot;);
    }


    public static void testFileChannelSequentialRW(FileChannel fileChannel) throws Exception {
            byte[] bytes = &quot;测试字符串1测试字符串1测试字符串1测试字符串1测试字符串1测试字符串1测试字符串1测试字符串1测试字符串1测试字符串1测试字符串1&quot;.getBytes();
            byte[] to = new byte[bytes.length];
            //分配直接内存，减少复制
            ByteBuffer byteBuffer = ByteBuffer.allocateDirect(bytes.length);
            //顺序写入
            for (int i = 0; i &amp;lt; 100000; i++) {
                byteBuffer.put(bytes);
                byteBuffer.flip();
                fileChannel.write(byteBuffer);
                byteBuffer.flip();
            }

            fileChannel.position(0);
            //顺序读取
            for (int i = 0; i &amp;lt; 100000; i++) {
                fileChannel.read(byteBuffer);
                byteBuffer.flip();
                byteBuffer.get(to);
                byteBuffer.flip();
            }
    }

    public static void testFileMMapSequentialRW(MappedByteBuffer mappedByteBuffer1, MappedByteBuffer mappedByteBuffer2) throws Exception {
        byte[] bytes = &quot;测试字符串2测试字符串2测试字符串2测试字符串2测试字符串2测试字符串2测试字符串2测试字符串2测试字符串2测试字符串2测试字符串2&quot;.getBytes();
        byte[] to = new byte[bytes.length];

        //顺序写入
        for (int i = 0; i &amp;lt; 100000; i++) {
            mappedByteBuffer1.put(bytes);
        }
        //顺序读取
        for (int i = 0; i &amp;lt; 100000; i++) {
            mappedByteBuffer2.get(to);
        }
    }

    public static void testFileChannelRandomRW(FileChannel fileChannel) throws Exception {
        try {
            byte[] bytes = &quot;测试字符串1测试字符串1测试字符串1测试字符串1测试字符串1测试字符串1测试字符串1测试字符串1测试字符串1测试字符串1测试字符串1&quot;.getBytes();
            byte[] to = new byte[bytes.length];
            //分配直接内存，减少复制
            ByteBuffer byteBuffer = ByteBuffer.allocateDirect(bytes.length);
            //随机写入
            for (int i = 0; i &amp;lt; 100000; i++) {
                byteBuffer.put(bytes);
                byteBuffer.flip();
                fileChannel.position(new Random(i).nextInt(bytes.length*100000));
                fileChannel.write(byteBuffer);
                byteBuffer.flip();
            }
            //随机读取
            for (int i = 0; i &amp;lt; 100000; i++) {
                fileChannel.position(new Random(i).nextInt(bytes.length*100000));
                fileChannel.read(byteBuffer);
                byteBuffer.flip();
                byteBuffer.get(to);
                byteBuffer.flip();
            }
        } finally {
            fileChannel.close();
        }
    }

    public static void testFileMMapRandomRW(MappedByteBuffer mappedByteBuffer1, MappedByteBuffer mappedByteBuffer2) throws Exception {
        byte[] bytes = &quot;测试字符串2测试字符串2测试字符串2测试字符串2测试字符串2测试字符串2测试字符串2测试字符串2测试字符串2测试字符串2测试字符串2&quot;.getBytes();
        byte[] to = new byte[bytes.length];

        //随机写入
        for (int i = 0; i &amp;lt; 100000; i++) {
            mappedByteBuffer1.position(new Random(i).nextInt(bytes.length*100000));
            mappedByteBuffer1.put(bytes);
        }
        //随机读取
        for (int i = 0; i &amp;lt; 100000; i++) {
            mappedByteBuffer2.position(new Random(i).nextInt(bytes.length*100000));
            mappedByteBuffer2.get(to);
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这里，我们初始化了一个文件，并把它映射到了128M的内存中。分FileChannel还有MMAP的方式，通过顺序或随机读写，写了一些内容并读取一部分内容。&lt;/p&gt;
&lt;p&gt;运行结果是：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;FileChannel初始化时间：7ms
MMAPFile初始化时间：8ms
FileChannel顺序读写时间：420ms
MMAPFile顺序读写时间：20ms
FileChannel随机读写时间：860ms
MMAPFile随机读写时间：45ms
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，通过MMAP内存映射文件的方式操作文件，更加快速，并且性能提升的相当明显。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;微信搜索“我的编程喵”关注公众号，每日一刷，轻松提升技术，斩获各种offer&lt;/strong&gt;：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://zhxhash-blog.oss-cn-beijing.aliyuncs.com/qr-code.jpg&quot; alt=&quot;image&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Fri, 19 Feb 2021 00:32:00 +0000</pubDate>
<dc:creator>干货满满张哈希</dc:creator>
<og:description>一般高性能的涉及到存储框架，例如 RocketMQ，Kafka 这种消息队列，存储日志的时候，都是通过 Java File MMAP 实现的，那么什么是 Java File MMAP 呢？ 什么是 J</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhxdick/p/14414403.html</dc:identifier>
</item>
<item>
<title>让 gRPC 提供 REST 服务 - WeihanLi</title>
<link>http://www.cnblogs.com/weihanli/p/14414396.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/weihanli/p/14414396.html</guid>
<description>&lt;h2 id=&quot;intro&quot;&gt;Intro&lt;/h2&gt;
&lt;blockquote readability=&quot;8.8815789473684&quot;&gt;
&lt;p&gt;&lt;a href=&quot;http://www.oschina.net/p/grpc-framework&quot; target=&quot;_blank&quot;&gt;gRPC&lt;/a&gt; 是一个高性能、开源和通用的 RPC 框架，面向移动和 HTTP/2 设计。&lt;/p&gt;
&lt;p&gt;gRPC 基于 HTTP/2 标准设计，带来诸如双向流、流控、头部压缩、单 TCP 连接上的多复用请求等特。这些特性使得其在移动设备上表现更好，更省电和节省空间占用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;gRPC 是一个很流行的现代化 RPC 框架，它以 HTTP/2 为通信协议基础，gRPC 默认使用 &lt;a href=&quot;https://developers.google.com/protocol-buffers/&quot; target=&quot;_blank&quot;&gt;protocol buffers&lt;/a&gt; 作为接口定义语言，来描述服务接口和有效载荷消息结构。&lt;/p&gt;
&lt;p&gt;尽管 gRPC 有很多应用，但是更为常用的还是基于 HTTP/1.1 的 REST 服务，应用更广，那么能否让 gRPC 同时提供 REST 服务呢？答案是肯定的，现在有一个实验性的项目(&lt;code&gt;gRPC HTTP API&lt;/code&gt; )正在进行，如果觉得这个项目不错，欢迎在 Github 上进行反馈，将你的意见反馈给 gRPC 团队或者去点个赞以提升项目的优先级 &lt;a href=&quot;https://github.com/grpc/grpc-dotnet/issues/167&quot; target=&quot;_blank&quot;&gt;https://github.com/grpc/grpc-dotnet/issues/167&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/489462/202102/489462-20210219082607125-1444375467.png&quot; alt=&quot;gRPC loves REST&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;sample&quot;&gt;Sample&lt;/h2&gt;
&lt;h3 id=&quot;proto&quot;&gt;Proto&lt;/h3&gt;
&lt;p&gt;首先我们来看一下 proto file：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-protobuf&quot;&gt;syntax = &quot;proto3&quot;;
//
import &quot;google/api/annotations.proto&quot;;

package greet.v1;

service Greeter {
  rpc SayHello (HelloRequest) returns (HelloReply) {
    option (google.api.http) = {
      get: &quot;/v1/greeter/{name}&quot;
    };
  }
  rpc SayHelloFrom (HelloRequestFrom) returns (HelloReply) {
    option (google.api.http) = {
      post: &quot;/v1/greeter&quot;
      body: &quot;*&quot;
    };
  }
}

message HelloRequest {
  string name = 1;
}

message HelloRequestFrom {
  string name = 1;
  string from = 2;
}

message HelloReply {
  string message = 1;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;和之前相比的变化就是引入了 &lt;code&gt;google/api/annotations.proto&lt;/code&gt;，然后在声明方法的地方声明了 http 请求的方式和路由&lt;/p&gt;
&lt;h3 id=&quot;project-update&quot;&gt;Project update&lt;/h3&gt;
&lt;p&gt;除了 proto file 变化之外，我们还需要引用 &lt;code&gt;Microsoft.AspNetCore.Grpc.HttpApi&lt;/code&gt; 这个包，为了更好的和 swagger 整合，也可以引用 &lt;code&gt;Microsoft.AspNetCore.Grpc.Swagger&lt;/code&gt; 这是一个 swagger 的扩展&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;Startup&lt;/code&gt; 中注册服务：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;services.AddGrpcHttpApi();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果引用了 swagger，也要注册相应的服务：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;services.AddSwaggerGen(c =&amp;gt;
    {
        c.SwaggerDoc(&quot;v1&quot;, new OpenApiInfo { Title = &quot;My API&quot;, Version = &quot;v1&quot; });
    })
    .AddGrpcSwagger();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样就可以了&lt;/p&gt;
&lt;h3 id=&quot;client-sample&quot;&gt;Client Sample&lt;/h3&gt;
&lt;p&gt;客户端调用示例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;using var client = new HttpClient()
{
    DefaultRequestVersion = HttpVersion.Version20,
    DefaultVersionPolicy = HttpVersionPolicy.RequestVersionOrHigher,
};
await InvokeHelper.TryInvokeAsync(async () =&amp;gt;
{
    var responseText = await client.GetStringAsync(&quot;https://localhost:5001/v1/greeter/test&quot;);
    Console.WriteLine($&quot;Response from https endpoint: {responseText}&quot;);
});
await InvokeHelper.TryInvokeAsync(async () =&amp;gt;
{
    var responseText = await client.GetStringAsync(&quot;http://localhost:5000/v1/greeter/test&quot;);
    Console.WriteLine($&quot;Response from http endpoint: {responseText}&quot;);
});

//
await InvokeHelper.TryInvokeAsync(async () =&amp;gt;
{
    var responseText = await client.GetStringAsync(&quot;http://localhost:5000/v1/todo&quot;);
    Console.WriteLine($&quot;Response from todo endpoint: {responseText}&quot;);
});
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;客户端输出示例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/489462/202102/489462-20210219082440431-1799390005.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;服务器端输出示例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/489462/202102/489462-20210219082453989-1005085877.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;完整的测试代码可以在 Github 获取 &lt;a href=&quot;https://github.com/WeihanLi/SamplesInPractice/tree/master/GrpcSample&quot; target=&quot;_blank&quot;&gt;https://github.com/WeihanLi/SamplesInPractice/tree/master/GrpcSample&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;known-issues&quot;&gt;Known Issues&lt;/h2&gt;
&lt;h3 id=&quot;json-serialization&quot;&gt;JSON Serialization&lt;/h3&gt;
&lt;p&gt;现在的 JSON 序列化是基于&lt;code&gt;Google.Protobuf&lt;/code&gt;，这个实现有两个问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;它是线程阻塞的（非 &lt;code&gt;async&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;没有做过性能优化&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;http-proto-file&quot;&gt;Http proto file&lt;/h3&gt;
&lt;p&gt;需要在最终用户的源代码中添加 &lt;code&gt;google / api / annotations.proto&lt;/code&gt;和 &lt;code&gt;google / api / http.proto&lt;/code&gt;，以便Protobuf编译器可以将它们与用户的proto文件一起加载。 如果以某种方式用户不必关心这些文件，那将是更好的开发人员体验。&lt;/p&gt;
&lt;h2 id=&quot;more&quot;&gt;More&lt;/h2&gt;
&lt;p&gt;这个项目使用下来感觉还是挺方便的，相当于在 &lt;code&gt;proto&lt;/code&gt; 文件中加了 http 请求相关的注解，就可以自动提供 REST 服务，这样对于 gRPC 和 REST 服务的整合就很方便了&lt;/p&gt;
&lt;p&gt;唯一让我觉得有一些美中不足的地方就是 http 只支持 Http2，如果 http 协议要支持 http1.1 的话，http请求 必须要 &lt;code&gt;https&lt;/code&gt;，如果是 http2 就可以比较好的支持 http，但是大部分的客户端都是 httpClient 都是直接请求的，大多没有设置过 Http Version，要手动设置 http2 才可以&lt;/p&gt;
&lt;p&gt;如果觉得还不错，记得去 GitHub 上反馈哈 &lt;a href=&quot;https://github.com/grpc/grpc-dotnet/issues/167&quot; target=&quot;_blank&quot;&gt;https://github.com/grpc/grpc-dotnet/issues/167&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;references&quot;&gt;References&lt;/h2&gt;
</description>
<pubDate>Fri, 19 Feb 2021 00:25:00 +0000</pubDate>
<dc:creator>WeihanLi</dc:creator>
<og:description>gRPC loves REST</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/weihanli/p/14414396.html</dc:identifier>
</item>
<item>
<title>内存包装类 Memory 和 Span 相关类型 - 大师兄石头</title>
<link>http://www.cnblogs.com/BigBrotherStone/p/memory-and-spans.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/BigBrotherStone/p/memory-and-spans.html</guid>
<description>&lt;p&gt;此文章是&lt;strong&gt;官方文档&lt;/strong&gt;的翻译，由于官方文档中文版&lt;strong&gt;是机器翻译&lt;/strong&gt;的，有些部分有疏漏和错误，所以本人进行了翻译供大家学习，如有问题欢迎指正。&lt;/p&gt;
&lt;blockquote readability=&quot;3.2222222222222&quot;&gt;
&lt;p&gt;&lt;strong&gt;参考资料&lt;/strong&gt;：&lt;br/&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/standard/memory-and-spans/&quot; target=&quot;_blank&quot;&gt;memory-and-spans&lt;/a&gt; --- Microsoft&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;.NET 包含多个相互关联的类型，它们表示任意内存的连续的强类型区域。 这些方法包括：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;System.Span&amp;lt;T&amp;gt;&lt;/code&gt;、&lt;code&gt;System.Memory&amp;lt;T&amp;gt;&lt;/code&gt; 及其对应的只读类型被设计为:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;避免&lt;/strong&gt;不必要地&lt;strong&gt;复制内存&lt;/strong&gt;或在托管堆上进行&lt;strong&gt;内存分配&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;通过 &lt;code&gt;Slice&lt;/code&gt; 方法或这些类型的的构造函数创建它们, 并不涉及复制&lt;strong&gt;底层缓冲&lt;/strong&gt;(underlying buffers): 只更新相关引用和偏移
&lt;ul&gt;&lt;li&gt;形象的说就是，只更新我们可以访问到的内存的位置和范围，而不是将这些内存数据复制出来&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;3.9444444444444&quot;&gt;
&lt;p&gt;备注:&lt;br/&gt;对于早期框架，&lt;code&gt;Span&amp;lt;T&amp;gt;&lt;/code&gt; 和 &lt;code&gt;Memory&amp;lt;T&amp;gt;&lt;/code&gt; 在 &lt;a href=&quot;https://www.nuget.org/packages/System.Memory/&quot; target=&quot;_blank&quot;&gt;System.Memory NuGet&lt;/a&gt; 包中提供。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;使用 memory 和 span&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;由于 memory 和 span 相关类型通常用于在处理 pipeline 中存储数据，因此开发人员在使用 &lt;code&gt;Span&amp;lt;T&amp;gt;&lt;/code&gt;、&lt;code&gt;Memory&amp;lt;T&amp;gt;&lt;/code&gt; 和相关类型时要务必遵循一套最佳做法。 &lt;code&gt;Memory&amp;lt;T&amp;gt;&lt;/code&gt; 和&lt;code&gt;Span&amp;lt;T&amp;gt;&lt;/code&gt; 使用准则中介绍了这些最佳做法。&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Span&amp;lt;T&amp;gt;&lt;/code&gt; 和 &lt;code&gt;ReadOnlySpan&amp;lt;T&amp;gt;&lt;/code&gt;
&lt;ul&gt;&lt;li&gt;是可由托管或非托管内存提供支持的轻量级内存缓冲区&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Memory&amp;lt;T&amp;gt;&lt;/code&gt; 及其相关类型
&lt;ul&gt;&lt;li&gt;由托管和非托管内存提供支持&lt;/li&gt;
&lt;li&gt;与 &lt;code&gt;Span&amp;lt;T&amp;gt;&lt;/code&gt; 不同，&lt;code&gt;Memory&amp;lt;T&amp;gt;&lt;/code&gt; 可以存储在托管堆上&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;Span&amp;lt;T&amp;gt;&lt;/code&gt; 和 &lt;code&gt;Memory&amp;lt;T&amp;gt;&lt;/code&gt; 都是可用于 pipeline 的结构化数据的缓冲区。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;它们设计的目的是将某些或所有数据有效地传递到 pipeline 中的组件，这些组件可以对其进行处理并修改(可选)缓冲区&lt;/li&gt;
&lt;li&gt;由于 &lt;code&gt;Memory&amp;lt;T&amp;gt;&lt;/code&gt; 及其相关类型可由多个组件或多个线程访问，因此开发人员必须遵循一些标准使用准则才能生成可靠的代码&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;31-所有者-消费者和生命周期管理&quot;&gt;3.1. 所有者, 消费者和生命周期管理&lt;/h2&gt;
&lt;p&gt;由于可以在各个 API 之间传送缓冲区，以及由于&lt;strong&gt;缓冲区&lt;/strong&gt;有时可以从多个线程进行访问，因此请务必考虑生命周期管理。 下面介绍三个核心概念：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;所有权:
&lt;ul&gt;&lt;li&gt;缓冲区实例的&lt;strong&gt;所有者&lt;/strong&gt;负责生命周期管理，包括当不再使用缓冲区时将其销毁&lt;/li&gt;
&lt;li&gt;所有缓冲区都拥有一个所有者&lt;/li&gt;
&lt;li&gt;通常，所有者是创建缓冲区或从工厂接收缓冲区的组件&lt;/li&gt;
&lt;li&gt;所有权也可以转让；
&lt;ul&gt;&lt;li&gt;组件 A 可以将缓冲区的控制权转让给组件 B，此时组件 A 就无法再使用该缓冲区，组件 B 将负责在不再使用缓冲区时将其销毁。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;消费:
&lt;ul&gt;&lt;li&gt;允许缓冲区实例的&lt;strong&gt;消费者&lt;/strong&gt;通过读取和写入来使用&lt;strong&gt;缓冲区实例&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;缓冲区一次可以拥有一个&lt;strong&gt;消费者&lt;/strong&gt;，除非提供了某些外部同步机制&lt;/li&gt;
&lt;li&gt;缓冲区的&lt;strong&gt;活跃消费者&lt;/strong&gt;不一定是缓冲区的&lt;strong&gt;所有者&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;租约:
&lt;ul&gt;&lt;li&gt;租约是指允许特定组件在一个时间长度范围内成为缓冲区消费者&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以下伪代码示例阐释了这三个概念。 它包括:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;实例化类型为 &lt;code&gt;Char&lt;/code&gt; 的 &lt;code&gt;Memory&amp;lt;T&amp;gt;&lt;/code&gt; 缓冲区的&lt;/li&gt;
&lt;li&gt;调用 &lt;code&gt;WriteInt32ToBuffer&lt;/code&gt; 方法以将整数的字符串表示形式写入缓冲区&lt;/li&gt;
&lt;li&gt;然后调用 &lt;code&gt;DisplayBufferToConsole&lt;/code&gt; 方法以显示缓冲区的值。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;using System;

class Program
{
    // Write 'value' as a human-readable string to the output buffer.
    void WriteInt32ToBuffer(int value, Buffer buffer);

    // Display the contents of the buffer to the console.
    void DisplayBufferToConsole(Buffer buffer);

    // Application code
    static void Main()
    {
        var buffer = CreateBuffer();
        try
        {
            int value = Int32.Parse(Console.ReadLine());
            WriteInt32ToBuffer(value, buffer);
            DisplayBufferToConsole(buffer);
        }
        finally
        {
            buffer.Destroy();
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;所有者
&lt;ul&gt;&lt;li&gt;Main 方法创建缓冲区（在此示例中为 &lt;code&gt;Span&amp;lt;T&amp;gt;&lt;/code&gt; 实例），因此它是其所有者。 因此，Main 将负责在不再使用缓冲区时将其销毁。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;消费者
&lt;ul&gt;&lt;li&gt;&lt;code&gt;WriteInt32ToBuffer&lt;/code&gt; 和 &lt;code&gt;DisplayBufferToConsole&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;一次只能有一个消费者
&lt;ul&gt;&lt;li&gt;先是 &lt;code&gt;WriteInt32ToBuffer&lt;/code&gt; ，然后是 &lt;code&gt;DisplayBufferToConsole&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;这两个消费者都不拥有缓冲区&lt;/li&gt;
&lt;li&gt;此上下文中的“消费者”并不意味着以只读形式查看缓冲区；如果提供了以读/写形式查看缓冲区的权限，则消费者可以像 &lt;code&gt;WriteInt32ToBuffer&lt;/code&gt; 那样修改缓冲区的内容&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;租约
&lt;ul&gt;&lt;li&gt;&lt;code&gt;WriteInt32ToBuffer&lt;/code&gt; 方法在方法调用的开始时间和方法返回的时间之间会&lt;strong&gt;租用&lt;/strong&gt;（能消费的）缓冲区&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DisplayBufferToConsole&lt;/code&gt; 在执行时会租用缓冲区，方法返回时将解除租用&lt;/li&gt;
&lt;li&gt;没有用于租约管理的 API，“租用”是概念性内容&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;32-memoryt-和所有者消费者模型&quot;&gt;3.2. Memory&amp;lt;T&amp;gt; 和所有者/消费者模型&lt;/h2&gt;
&lt;p&gt;.NET Core 支持以下两种所有权模型：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;支持单个所有权的模型
&lt;ul&gt;&lt;li&gt;缓冲区在其整个生存期内拥有单个所有者。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;支持所有权转让的模型
&lt;ul&gt;&lt;li&gt;缓冲区的所有权可以从其原始所有者（其创建者）转让给其他组件，该组件随后将负责缓冲区的生存期管理&lt;/li&gt;
&lt;li&gt;该所有者可以反过来将所有权转让给其他组件等&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;使用 &lt;code&gt;System.Buffers.IMemoryOwner&amp;lt;T&amp;gt;&lt;/code&gt; 接口&lt;strong&gt;显式的管理&lt;/strong&gt;缓冲区的所有权。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;IMemoryOwner&amp;lt;T&amp;gt;&lt;/code&gt; 支持上述这两种所有权模型&lt;/li&gt;
&lt;li&gt;具有 &lt;code&gt;IMemoryOwner&amp;lt;T&amp;gt;&lt;/code&gt; 引用的组件拥有缓冲区&lt;/li&gt;
&lt;li&gt;以下示例使用 &lt;code&gt;IMemoryOwner&amp;lt;T&amp;gt;&lt;/code&gt; 实例反映 &lt;code&gt;Memory&amp;lt;T&amp;gt;&lt;/code&gt; 缓冲区的所有权。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;using System;
using System.Buffers;

class Example
{
    static void Main()
    {
        IMemoryOwner&amp;lt;char&amp;gt; owner = MemoryPool&amp;lt;char&amp;gt;.Shared.Rent();

        Console.Write(&quot;Enter a number: &quot;);
        try {
            var value = Int32.Parse(Console.ReadLine());

            var memory = owner.Memory;

            WriteInt32ToBuffer(value, memory);

            DisplayBufferToConsole(owner.Memory.Slice(0, value.ToString().Length));
        }
        catch (FormatException) {
            Console.WriteLine(&quot;You did not enter a valid number.&quot;);
        }
        catch (OverflowException) {
            Console.WriteLine($&quot;You entered a number less than {Int32.MinValue:N0} or greater than {Int32.MaxValue:N0}.&quot;);
        }
        finally {
            owner?.Dispose();
        }
    }

    static void WriteInt32ToBuffer(int value, Memory&amp;lt;char&amp;gt; buffer)
    {
        var strValue = value.ToString();

        var span = buffer.Span;
        for (int ctr = 0; ctr &amp;lt; strValue.Length; ctr++)
            span[ctr] = strValue[ctr];
    }

    static void DisplayBufferToConsole(Memory&amp;lt;char&amp;gt; buffer) =&amp;gt;
        Console.WriteLine($&quot;Contents of the buffer: '{buffer}'&quot;);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也可以使用 &lt;strong&gt;using&lt;/strong&gt; 编写此示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;using System;
using System.Buffers;

class Example
{
    static void Main()
    {
        using (IMemoryOwner&amp;lt;char&amp;gt; owner = MemoryPool&amp;lt;char&amp;gt;.Shared.Rent())
        {
            Console.Write(&quot;Enter a number: &quot;);
            try {
                var value = Int32.Parse(Console.ReadLine());

                var memory = owner.Memory;
                WriteInt32ToBuffer(value, memory);
                DisplayBufferToConsole(memory.Slice(0, value.ToString().Length));
            }
            catch (FormatException) {
                Console.WriteLine(&quot;You did not enter a valid number.&quot;);
            }
            catch (OverflowException) {
                Console.WriteLine($&quot;You entered a number less than {Int32.MinValue:N0} or greater than {Int32.MaxValue:N0}.&quot;);
            }
        }
    }

    static void WriteInt32ToBuffer(int value, Memory&amp;lt;char&amp;gt; buffer)
    {
        var strValue = value.ToString();

        var span = buffer.Slice(0, strValue.Length).Span;
        strValue.AsSpan().CopyTo(span);
    }

    static void DisplayBufferToConsole(Memory&amp;lt;char&amp;gt; buffer) =&amp;gt;
        Console.WriteLine($&quot;Contents of the buffer: '{buffer}'&quot;);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在此代码中：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Main&lt;/strong&gt; 方法保持对 &lt;code&gt;IMemoryOwner&amp;lt;T&amp;gt;&lt;/code&gt; 实例的引用，因此 &lt;strong&gt;Main&lt;/strong&gt; 方法是缓冲区的&lt;strong&gt;所有者&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;WriteInt32ToBuffer&lt;/code&gt; 和 &lt;code&gt;DisplayBufferToConsole&lt;/code&gt; 方法接受 ``Memory 参数作为公共 API。 因此，它们是缓冲区的消费者。 并且它们同一时间仅有一个消费者&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;尽管 &lt;code&gt;WriteInt32ToBuffer&lt;/code&gt; 方法用于将数据写入缓冲区，但 &lt;code&gt;DisplayBufferToConsole&lt;/code&gt; 方法并不如此。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;若要反映此情况，方法参数类型可改为 &lt;code&gt;ReadOnlyMemory&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;33-缺少所有者-的memoryt-实例&quot;&gt;3.3. “缺少所有者” 的Memory&amp;lt;T&amp;gt; 实例&lt;/h2&gt;
&lt;p&gt;无需使用 &lt;code&gt;IMemoryOwner&amp;lt;T&amp;gt;&lt;/code&gt; 即可创建 &lt;code&gt;Memory&amp;lt;T&amp;gt;&lt;/code&gt; 实例。 在这种情况下，缓冲区的所有权是&lt;strong&gt;隐式的&lt;/strong&gt;，并且仅支持&lt;strong&gt;单所有者模型&lt;/strong&gt;。 可以通过以下方式达到此目的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;直接调用 &lt;code&gt;Memory&amp;lt;T&amp;gt;&lt;/code&gt; 构造函数之一，传入 &lt;code&gt;T[]&lt;/code&gt;，如下面的示例所示&lt;/li&gt;
&lt;li&gt;调用 &lt;code&gt;String.AsMemory&lt;/code&gt; 扩展方法以生成 &lt;code&gt;ReadOnlyMemory&amp;lt;char&amp;gt;&lt;/code&gt; 实例&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;using System;

class Example
{
    static void Main()
    {
        Memory&amp;lt;char&amp;gt; memory = new char[64];

        Console.Write(&quot;Enter a number: &quot;);
        var value = Int32.Parse(Console.ReadLine());

        WriteInt32ToBuffer(value, memory);
        DisplayBufferToConsole(memory);
    }

    static void WriteInt32ToBuffer(int value, Memory&amp;lt;char&amp;gt; buffer)
    {
        var strValue = value.ToString();
        strValue.AsSpan().CopyTo(buffer.Slice(0, strValue.Length).Span);
    }

    static void DisplayBufferToConsole(Memory&amp;lt;char&amp;gt; buffer) =&amp;gt;
        Console.WriteLine($&quot;Contents of the buffer: '{buffer}'&quot;);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;最初创建 &lt;code&gt;Memory&amp;lt;T&amp;gt;&lt;/code&gt; 实例的方法是缓冲区的&lt;strong&gt;隐式所有者&lt;/strong&gt;。 无法将&lt;strong&gt;所有权&lt;/strong&gt;转让给任何其他组件, 因为没有 &lt;code&gt;IMemoryOwner&amp;lt;T&amp;gt;&lt;/code&gt; 实例可用于进行转让
&lt;ul&gt;&lt;li&gt;也可以&lt;strong&gt;假设&lt;/strong&gt;运行时的&lt;strong&gt;垃圾回收器拥有缓冲区&lt;/strong&gt;，全部的方法只消费缓冲区&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;34-使用准则&quot;&gt;3.4. 使用准则&lt;/h2&gt;
&lt;p&gt;因为拥有一个内存块，但打算将其传递给多个组件，其中一些组件可能同时在特定的内存块上运行，所以建立使用&lt;code&gt;Memory&amp;lt;T&amp;gt;&lt;/code&gt;和&lt;code&gt;Span&amp;lt;T&amp;gt;&lt;/code&gt;的准则是很必要的，因为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;所有者释放它之后，一个组件还可能会保留对该存储块的引用。&lt;/li&gt;
&lt;li&gt;两个组件可能并发的同时在缓冲区上进行操作，从而破坏了缓冲区中的数据。&lt;/li&gt;
&lt;li&gt;尽管&lt;code&gt;Span&amp;lt;T&amp;gt;&lt;/code&gt;的&lt;strong&gt;堆栈分配性质&lt;/strong&gt;优化了性能，而且使&lt;code&gt;Span&amp;lt;T&amp;gt;&lt;/code&gt;成为在内存块上运行的&lt;strong&gt;首选类型&lt;/strong&gt;，但它也使&lt;code&gt;Span&amp;lt;T&amp;gt;&lt;/code&gt;受到一些主要限制
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;重要&lt;/strong&gt;的是要知道&lt;strong&gt;何时&lt;/strong&gt;使用&lt;code&gt;Span&amp;lt;T&amp;gt;&lt;/code&gt;以及&lt;strong&gt;何时&lt;/strong&gt;使用 &lt;code&gt;Memory&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面介绍成功使用 &lt;code&gt;Memory&amp;lt;T&amp;gt;&lt;/code&gt; 及其相关类型的建议。 除非另有明确说明，否则适用于 &lt;code&gt;Memory&amp;lt;T&amp;gt;&lt;/code&gt; 和 &lt;code&gt;Span&amp;lt;T&amp;gt;&lt;/code&gt; 的指南也适用于 &lt;code&gt;ReadOnlyMemory&amp;lt;T&amp;gt;&lt;/code&gt; 和 &lt;code&gt;ReadOnlySpan&amp;lt;T&amp;gt;&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;规则 1：对于同步 API，如有可能，请使用 Span&amp;lt;T&amp;gt;（而不是 Memory&amp;lt;T&amp;gt;）作为参数。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Span&amp;lt;T&amp;gt;&lt;/code&gt; 比 &lt;code&gt;Memory&amp;lt;T&amp;gt;&lt;/code&gt; 更多功能：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;可以表示更多种类的连续内存缓冲区&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Span&amp;lt;T&amp;gt;&lt;/code&gt; 还提供比 &lt;code&gt;Memory&amp;lt;T&amp;gt;&lt;/code&gt; 更好的性能&lt;/li&gt;
&lt;li&gt;无法进行 &lt;code&gt;Span&amp;lt;T&amp;gt;&lt;/code&gt; 到 &lt;code&gt;Memory&amp;lt;T&amp;gt;&lt;/code&gt; 的转换&lt;/li&gt;
&lt;li&gt;可以使用 &lt;code&gt;Memory&amp;lt;T&amp;gt;.Span&lt;/code&gt; 属性将 &lt;code&gt;Memory&amp;lt;T&amp;gt;&lt;/code&gt; 实例转换为 &lt;code&gt;Span&amp;lt;T&amp;gt;&lt;/code&gt;
&lt;ul&gt;&lt;li&gt;如果调用方恰好具有 &lt;code&gt;Memory&amp;lt;T&amp;gt;&lt;/code&gt; 实例，则它们不管怎样都可以使用 &lt;code&gt;Span&amp;lt;T&amp;gt;&lt;/code&gt; 参数调用你的方法&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;使用类型 &lt;code&gt;Span&amp;lt;T&amp;gt;&lt;/code&gt;（而不是类型 &lt;code&gt;Memory&amp;lt;T&amp;gt;&lt;/code&gt;）作为方法的参数类型还可以帮助你编写正确的消费方法实现。 你将自动进行编译时检查，以确保不会企图访问此方法租约之外的缓冲区&lt;/p&gt;
&lt;p&gt;有时，必须使用 &lt;code&gt;Memory&amp;lt;T&amp;gt;&lt;/code&gt; 参数（而不是 &lt;code&gt;Span&amp;lt;T&amp;gt;&lt;/code&gt; 参数），即使完全同步也是如此。 所依赖的 API 可能仅接受 &lt;code&gt;Memory&amp;lt;T&amp;gt;&lt;/code&gt; 参数。 这没有问题，但当使用同步的 &lt;code&gt;Memory&amp;lt;T&amp;gt;&lt;/code&gt; 时，应注意权衡利弊&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;规则 2：如果缓冲区应为只读，则使用 ReadOnlySpan&amp;lt;T&amp;gt; 或 ReadOnlyMemory&amp;lt;T&amp;gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在前面的示例中，&lt;code&gt;DisplayBufferToConsole&lt;/code&gt; 方法仅从缓冲区读取数据；它不修改缓冲区的内容。 方法签名应进行修改如下。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;void DisplayBufferToConsole(ReadOnlyMemory&amp;lt;char&amp;gt; buffer);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;事实上，如果我们结合 规则1 和 规则2 ，我们可以做得更好，并重写方法签名如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;void DisplayBufferToConsole(ReadOnlySpan&amp;lt;char&amp;gt; buffer);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;DisplayBufferToConsole&lt;/code&gt; 方法现在几乎适用于每一个能够想到的缓冲区类型：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;T[]&lt;/code&gt;、使用 &lt;code&gt;stackalloc&lt;/code&gt; 分配的存储 等等&lt;/li&gt;
&lt;li&gt;甚至可以向其直接传递 &lt;code&gt;String&lt;/code&gt;！&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;规则 3：如果方法接受 Memory&amp;lt;T&amp;gt; 并返回 void，则在方法返回之后不得使用 Memory&amp;lt;T&amp;gt; 实例。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这与前面提到的“租约”概念相关。 返回 void 的方法对 &lt;code&gt;Memory&amp;lt;T&amp;gt;&lt;/code&gt; 实例的租用将在进入该方法时开始，并在退出该方法时结束。 请考虑以下示例，该示例会基于控制台中的输入在循环中调用 Log。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;using System;
using System.Buffers;

public class Example
{
    // implementation provided by third party
    static extern void Log(ReadOnlyMemory&amp;lt;char&amp;gt; message);

    // user code
    public static void Main()
    {
        using (var owner = MemoryPool&amp;lt;char&amp;gt;.Shared.Rent())
        {
            var memory = owner.Memory;
            var span = memory.Span;
            while (true)
            {
                int value = Int32.Parse(Console.ReadLine());
                if (value &amp;lt; 0)
                    return;

                int numCharsWritten = ToBuffer(value, span);
                Log(memory.Slice(0, numCharsWritten));
            }
        }
    }

    private static int ToBuffer(int value, Span&amp;lt;char&amp;gt; span)
    {
        string strValue = value.ToString();
        int length = strValue.Length;
        strValue.AsSpan().CopyTo(span.Slice(0, length));
        return length;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果 &lt;code&gt;Log&lt;/code&gt; 是完全同步的方法，则此代码将按预期运行，因为在任何给定时间只有一个活跃的内存实例消费者。 但是，请想象Log具有此实现。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;// !!! INCORRECT IMPLEMENTATION !!!
static void Log(ReadOnlyMemory&amp;lt;char&amp;gt; message)
{
    // Run in background so that we don't block the main thread while performing IO.
    Task.Run(() =&amp;gt;
    {
        StreamWriter sw = File.AppendText(@&quot;.\input-numbers.dat&quot;);
        sw.WriteLine(message);
    });
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在此实现中，Log &lt;strong&gt;违反&lt;/strong&gt;了&lt;strong&gt;租约&lt;/strong&gt;，因为它在 return 之后仍尝试在后台使用 &lt;code&gt;Memory&amp;lt;T&amp;gt;&lt;/code&gt; 实例。 Main 方法可能会在 Log 尝试从缓冲区进行读取时更改缓冲区数据，这可能导致消费者在使用缓存区数据时数据已经被修改。&lt;/p&gt;
&lt;p&gt;有多种方法可解决此问题：&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;Log 方法可以按以下所示，返回 Task，而不是 void。
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;// An acceptable implementation.
static Task Log(ReadOnlyMemory&amp;lt;char&amp;gt; message)
{
    // Run in the background so that we don't block the main thread while performing IO.
    return Task.Run(() =&amp;gt; {
                StreamWriter sw = File.AppendText(@&quot;.\input-numbers.dat&quot;);
        sw.WriteLine(message);
        sw.Flush();
    });
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;也可以改为按如下所示实现 Log：
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;// An acceptable implementation.
static void Log(ReadOnlyMemory&amp;lt;char&amp;gt; message)
{
    string defensiveCopy = message.ToString();
    // Run in the background so that we don't block the main thread while performing IO.
    Task.Run(() =&amp;gt; {
        StreamWriter sw = File.AppendText(@&quot;.\input-numbers.dat&quot;);
        sw.WriteLine(defensiveCopy);
        sw.Flush();
    });
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;规则 4：如果方法接受 Memory&amp;lt;T&amp;gt; 并返回某个Task，则在Task转换为终止状态之前不得使用 Memory&amp;lt;T&amp;gt; 实例。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个是 规则3 的异步版本。 以下示例是遵守此规则，按上面例子编写的 &lt;code&gt;Log&lt;/code&gt; 方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;// An acceptable implementation.
static Task Log(ReadOnlyMemory&amp;lt;char&amp;gt; message)
{
    // Run in the background so that we don't block the main thread while performing IO.
    return Task.Run(() =&amp;gt; {
        string defensiveCopy = message.ToString();
        StreamWriter sw = File.AppendText(@&quot;.\input-numbers.dat&quot;);
        sw.WriteLine(defensiveCopy);
        sw.Flush();
    });
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此处的“终止状态”表示任务转换为 completed, faulted, canceled 状态。&lt;/p&gt;
&lt;p&gt;此指南适用于返回 &lt;code&gt;Task&lt;/code&gt;、&lt;code&gt;Task&amp;lt;TResult&amp;gt;&lt;/code&gt;、&lt;code&gt;ValueTask&amp;lt;TResult&amp;gt;&lt;/code&gt; 或任何类似类型的方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;规则5：如果构造函数接受Memory &amp;lt;T&amp;gt;作为参数，则假定构造对象上的实例方法是Memory&amp;lt;T&amp;gt;实例的消费者。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;请看以下示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;class OddValueExtractor
{
    public OddValueExtractor(ReadOnlyMemory&amp;lt;int&amp;gt; input);
    public bool TryReadNextOddValue(out int value);
}

void PrintAllOddValues(ReadOnlyMemory&amp;lt;int&amp;gt; input)
{
    var extractor = new OddValueExtractor(input);
    while (extractor.TryReadNextOddValue(out int value))
    {
      Console.WriteLine(value);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此处的 &lt;code&gt;OddValueExtractor&lt;/code&gt; 构造函数接受 &lt;code&gt;ReadOnlyMemory&amp;lt;int&amp;gt;&lt;/code&gt; 作为构造函数参数，因此构造函数本身是 &lt;code&gt;ReadOnlyMemory&amp;lt;int&amp;gt;&lt;/code&gt; 实例的消费者，并且该实例的所有实例方法也是原始 &lt;code&gt;ReadOnlyMemory&amp;lt;int&amp;gt;&lt;/code&gt; 实例的消费者。 这意味着 &lt;code&gt;TryReadNextOddValue&lt;/code&gt; 消费 &lt;code&gt;ReadOnlyMemory&amp;lt;int&amp;gt;&lt;/code&gt; 实例，即使该实例未直接传递到 &lt;code&gt;TryReadNextOddValue&lt;/code&gt; 方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;规则 6：如果一个类型具有可写的 Memory&amp;lt;T&amp;gt; 类型的属性（或等效的实例方法），则假定该对象上的实例方法是 Memory&amp;lt;T&amp;gt; 实例的消费者。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这是 规则5 的变体。之所以存在此规则，是因为假定使用了可写属性或等效方法来捕获并保留输入的 &lt;code&gt;Memory&amp;lt;T&amp;gt;&lt;/code&gt; 实例，因此同一对象上的实例方法可以利用捕获的实例。&lt;/p&gt;
&lt;p&gt;以下示例触发了此规则：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;class Person
{
    // Settable property.
    public Memory&amp;lt;char&amp;gt; FirstName { get; set; }

    // alternatively, equivalent &quot;setter&quot; method
    public SetFirstName(Memory&amp;lt;char&amp;gt; value);

    // alternatively, a public settable field
    public Memory&amp;lt;char&amp;gt; FirstName;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;规则 7：如果具有 &lt;code&gt;IMemoryOwner&amp;lt;T&amp;gt;&lt;/code&gt; 的引用，则必须在某些时候对其进行处理或转让其所有权（但不同时执行两个操作）。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;由于 &lt;code&gt;Memory&amp;lt;T&amp;gt;&lt;/code&gt; 实例可能由托管或非托管内存提供支持，因此在对 &lt;code&gt;Memory&amp;lt;T&amp;gt;&lt;/code&gt; 实例执行的工作完成之后，所有者必须调用 &lt;code&gt;MemoryPool&amp;lt;T&amp;gt;.Dispose&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;此外，所有者可能会将 &lt;code&gt;IMemoryOwner&amp;lt;T&amp;gt;&lt;/code&gt; 实例的所有权转让给其他组件，同时获取所有权的组件将负责在适当时间调用 &lt;code&gt;MemoryPool&amp;lt;T&amp;gt;.Dispose&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;调用 Dispose 方法失败可能会导致非托管内存泄漏或其他性能降低问题&lt;/li&gt;
&lt;li&gt;此规则也适用于调用工厂方法的代码（如 &lt;code&gt;MemoryPool&amp;lt;T&amp;gt;.Rent&lt;/code&gt;）。 调用方将成为工厂生产的 &lt;code&gt;IMemoryOwner&amp;lt;T&amp;gt;&lt;/code&gt; 的所有者，并负责在完成后 Dispose 该实例。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;规则 8：如果 API 接口中具有 &lt;code&gt;IMemoryOwner&amp;lt;T&amp;gt;&lt;/code&gt; 参数，即表示你接受该实例的所有权。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;接受此类型的实例表示组件打算获取此实例的所有权。 该组件将负责根据 &lt;strong&gt;规则7&lt;/strong&gt; 进行正确处理。&lt;/p&gt;
&lt;p&gt;在方法调用完成后，将 &lt;code&gt;IMemoryOwner&amp;lt;T&amp;gt;&lt;/code&gt; 实例的所有权转让给其他组件，之后该组件将不再使用该实例。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;重要:&lt;/strong&gt;&lt;br/&gt;构造函数接受 &lt;code&gt;IMemoryOwner&amp;lt;T&amp;gt;&lt;/code&gt; 作为参数的类应实现接口 &lt;code&gt;IDisposable&lt;/code&gt;，并且 &lt;code&gt;Dispose&lt;/code&gt; 方法中应调用 &lt;code&gt;MemoryPool&amp;lt;T&amp;gt;.Dispose&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;规则 9：如果要封装同步的 p/invoke 方法，则应接受 Span&amp;lt;T&amp;gt; 作为参数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;根据 规则1，&lt;code&gt;Span&amp;lt;T&amp;gt;&lt;/code&gt; 通常是用于同步 API 的合规类型。 可以通过 &lt;code&gt;fixed&lt;/code&gt; 关键字固定 &lt;code&gt;Span&amp;lt;T&amp;gt;&lt;/code&gt; 实例，如下面的示例所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;using System.Runtime.InteropServices;

[DllImport(...)]
private static extern unsafe int ExportedMethod(byte* pbData, int cbData);

public unsafe int ManagedWrapper(Span&amp;lt;byte&amp;gt; data)
{
    fixed (byte* pbData = &amp;amp;MemoryMarshal.GetReference(data))
    {
        int retVal = ExportedMethod(pbData, data.Length);

        /* error checking retVal goes here */

        return retVal;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在上一示例中，如果输入 span 为空，则 &lt;code&gt;pbData&lt;/code&gt; 可以为 Null。 如果 &lt;code&gt;ExportedMethod&lt;/code&gt; 方法参数 &lt;code&gt;pbData&lt;/code&gt; 不能为 Null，可以按如下示例实现该方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;public unsafe int ManagedWrapper(Span&amp;lt;byte&amp;gt; data)
{
    fixed (byte* pbData = &amp;amp;MemoryMarshal.GetReference(data))
    {
        byte dummy = 0;
        int retVal = ExportedMethod((pbData != null) ? pbData : &amp;amp;dummy, data.Length);

        /* error checking retVal goes here */

        return retVal;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;规则 10：如果要包装异步 p/invoke 方法，则应接受 Memory&amp;lt;T&amp;gt; 作为参数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于 fixed 关键字不能在异步操作中使用，因此使用 &lt;code&gt;Memory&amp;lt;T&amp;gt;.Pin&lt;/code&gt; 方法固定 &lt;code&gt;Memory&amp;lt;T&amp;gt;&lt;/code&gt; 实例，无论实例代表的连续内存是哪种类型。 下面的示例演示了如何使用此 API 执行异步 p/invoke 调用。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;using System.Runtime.InteropServices;

[UnmanagedFunctionPointer(...)]
private delegate void OnCompletedCallback(IntPtr state, int result);

[DllImport(...)]
private static extern unsafe int ExportedAsyncMethod(byte* pbData, int cbData, IntPtr pState, IntPtr lpfnOnCompletedCallback);

private static readonly IntPtr _callbackPtr = GetCompletionCallbackPointer();

public unsafe Task&amp;lt;int&amp;gt; ManagedWrapperAsync(Memory&amp;lt;byte&amp;gt; data)
{
    // setup
    var tcs = new TaskCompletionSource&amp;lt;int&amp;gt;();
    var state = new MyCompletedCallbackState
    {
        Tcs = tcs
    };
    var pState = (IntPtr)GCHandle.Alloc(state);

    var memoryHandle = data.Pin();
    state.MemoryHandle = memoryHandle;

    // make the call
    int result;
    try
    {
        result = ExportedAsyncMethod((byte*)memoryHandle.Pointer, data.Length, pState, _callbackPtr);
    }
    catch
    {
        ((GCHandle)pState).Free(); // cleanup since callback won't be invoked
        memoryHandle.Dispose();
        throw;
    }

    if (result != PENDING)
    {
        // Operation completed synchronously; invoke callback manually
        // for result processing and cleanup.
        MyCompletedCallbackImplementation(pState, result);
    }

    return tcs.Task;
}

private static void MyCompletedCallbackImplementation(IntPtr state, int result)
{
    GCHandle handle = (GCHandle)state;
    var actualState = (MyCompletedCallbackState)(handle.Target);
    handle.Free();
    actualState.MemoryHandle.Dispose();

    /* error checking result goes here */

    if (error)
    {
        actualState.Tcs.SetException(...);
    }
    else
    {
        actualState.Tcs.SetResult(result);
    }
}

private static IntPtr GetCompletionCallbackPointer()
{
    OnCompletedCallback callback = MyCompletedCallbackImplementation;
    GCHandle.Alloc(callback); // keep alive for lifetime of application
    return Marshal.GetFunctionPointerForDelegate(callback);
}

private class MyCompletedCallbackState
{
    public TaskCompletionSource&amp;lt;int&amp;gt; Tcs;
    public MemoryHandle MemoryHandle;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;注:&lt;br/&gt;&lt;code&gt;Memory&amp;lt;T&amp;gt;.Pin&lt;/code&gt; 方法返回内存句柄，且垃圾回收器将不会移动此处内存，直到释放该方法返回的 &lt;code&gt;MemoryHandle&lt;/code&gt; 对象为止。这使您可以检索和使用该内存地址。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Fri, 19 Feb 2021 00:23:00 +0000</pubDate>
<dc:creator>大师兄石头</dc:creator>
<og:description>1. 前言 2. 简介 3. Memory&amp;amp;lt;T&amp;amp;gt;和Span&amp;amp;lt;T&amp;amp;gt;使用准则 3.1. 所有者, 消费者和生命周期管理 3.2. Memory&amp;am</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/BigBrotherStone/p/memory-and-spans.html</dc:identifier>
</item>
<item>
<title>JUnit5学习之一：基本操作 - 程序员欣宸</title>
<link>http://www.cnblogs.com/bolingcavalry/p/14414381.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bolingcavalry/p/14414381.html</guid>
<description>&lt;h3 id=&quot;欢迎访问我的github&quot;&gt;欢迎访问我的GitHub&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot; target=&quot;_blank&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;内容：所有原创文章分类汇总及配套源码，涉及Java、Docker、Kubernetes、DevOPS等；&lt;/p&gt;
&lt;h3 id=&quot;关于《junit5学习》系列&quot;&gt;关于《JUnit5学习》系列&lt;/h3&gt;
&lt;p&gt;《JUnit5学习》系列旨在通过实战提升SpringBoot环境下的单元测试技能，一共八篇文章，链接如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/boling_cavalry/article/details/108810587&quot; target=&quot;_blank&quot;&gt;基本操作&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/boling_cavalry/article/details/108861185&quot; target=&quot;_blank&quot;&gt;Assumptions类&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/boling_cavalry/article/details/108899437&quot; target=&quot;_blank&quot;&gt;Assertions类&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/boling_cavalry/article/details/108909107&quot; target=&quot;_blank&quot;&gt;按条件执行&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/boling_cavalry/article/details/108914091&quot; target=&quot;_blank&quot;&gt;标签(Tag)和自定义注解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/boling_cavalry/article/details/108930987&quot; target=&quot;_blank&quot;&gt;参数化测试(Parameterized Tests)基础&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/boling_cavalry/article/details/108942301&quot; target=&quot;_blank&quot;&gt;参数化测试(Parameterized Tests)进阶&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/boling_cavalry/article/details/108952500&quot; target=&quot;_blank&quot;&gt;综合进阶（终篇）&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;本篇概览&quot;&gt;本篇概览&lt;/h3&gt;
&lt;p&gt;本文是《JUnit5学习》系列的第一篇，通过实战学习在SpringBoot框架下JUnit5的基本功能，全篇章节如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;JUnit5简介&lt;/li&gt;
&lt;li&gt;SpringBoot对JUnit5的依赖&lt;/li&gt;
&lt;li&gt;常用注解简介&lt;/li&gt;
&lt;li&gt;5版本已废弃的注解介绍&lt;/li&gt;
&lt;li&gt;进入实战环节，先介绍版本和环境信息&lt;/li&gt;
&lt;li&gt;创建《JUnit5学习》系列源码的父工程&lt;/li&gt;
&lt;li&gt;创建子工程，编码体验常用注解&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;关于junit5&quot;&gt;关于JUnit5&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;JUnit是常用的java单元测试框架，&lt;span&gt;5&lt;/span&gt;是当前最新版本，其整体架构如下(图片来自网络)：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202102/485422-20210219081508389-652712027.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;2. 从上图可见，整个JUnit5可以划分成三层：顶层框架(Framework)、中间的引擎（Engine），底层的平台（Platform）；&lt;br/&gt;3. 官方定义JUnit5由三部分组成：Platform、Jupiter、Vintage，功能如下；&lt;br/&gt;4. Platform：位于架构的最底层，是JVM上执行单元测试的基础平台，还对接了各种IDE（例如IDEA、eclipse），并且还与引擎层对接，定义了引擎层对接的API；&lt;br/&gt;5. Jupiter：位于引擎层，支持5版本的编程模型、扩展模型；&lt;br/&gt;6. Vintage：位于引擎层，用于执行低版本的测试用例；&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;可见整个Junit Platform是开放的，通过引擎API各种测试框架都可以接入；&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;springboot对junit5的依赖&quot;&gt;SpringBoot对JUnit5的依赖&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;这里使用SpringBoot版本为&lt;span&gt;2.3.4.RELEASE&lt;/span&gt;，在项目的pom.xml中依赖JUnit5的方法如下：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
    &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;如下图红框，可见JUnit5的jar都被&lt;span&gt;spring-boot-starter-test&lt;/span&gt;间接依赖进来了：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202102/485422-20210219081512317-591383986.jpg&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;曾经的runwith注解&quot;&gt;曾经的RunWith注解&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;在使用JUnit4的时候，咱们经常这么写单元测试类：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@RunWith(SpringRunner.class)
@SpringBootTest
public class XXXTest {
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;对于上面的RunWith注解，JUnit5官方文档的说法如下图红框所示，已经被&lt;span&gt;ExtendWith&lt;/span&gt;取代：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202102/485422-20210219081512817-1824269816.jpg&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;3. 咱们再来看看SpringBootTest注解，如下图，可见已经包含了&lt;span&gt;ExtendWith&lt;/span&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202102/485422-20210219081513101-1273618409.jpg&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;4. 综上所述，SpringBoot+JUnit5时，RunWith注解已经不需要了，正常情况下仅SpringBootTest注解即可，如果对扩展性有更多需求，可以添加ExtendWith注解，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202102/485422-20210219081513340-1191875119.jpg&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;常用的junit5注解springboot环境&quot;&gt;常用的JUnit5注解(SpringBoot环境)&lt;/h3&gt;
&lt;p&gt;注意，接下来提到的&lt;span&gt;测试方法&lt;/span&gt;，是指当前class中所有被@Test、@RepeatedTest、@ParameterizedTest、@TestFactory修饰的方法；&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;ExtendWith：这是用来取代旧版本中的RunWith注解，不过在SpringBoot环境如果没有特别要求无需额外配置，因为SpringBootTest中已经有了；&lt;/li&gt;
&lt;li&gt;Test：被该注解修饰的就是测试方法；&lt;/li&gt;
&lt;li&gt;BeforeAll：被该注解修饰的必须是静态方法，会在所有测试方法之前执行，会被子类继承，取代低版本的BeforeClass；&lt;/li&gt;
&lt;li&gt;AfterAll：被该注解修饰的必须是静态方法，会在所有测试方法执行之后才被执行，会被子类继承，取代低版本的AfterClass；&lt;/li&gt;
&lt;li&gt;BeforeEach：被该注解修饰的方法会在每个测试方法执行前被执行一次，会被子类继承，取代低版本的Before；&lt;/li&gt;
&lt;li&gt;AfterEach：被该注解修饰的方法会在每个测试方法执行后被执行一次，会被子类继承，取代低版本的Before；&lt;/li&gt;
&lt;li&gt;DisplayName：测试方法的展现名称，在测试框架中展示，支持emoji；&lt;/li&gt;
&lt;li&gt;Timeout：超时时长，被修饰的方法如果超时则会导致测试不通过；&lt;/li&gt;
&lt;li&gt;Disabled：不执行的测试方法；&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;5版本已废弃的注解&quot;&gt;5版本已废弃的注解&lt;/h3&gt;
&lt;p&gt;以下的注解都是在5之前的版本使用的，现在已经被废弃：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;被废弃的注解&lt;/th&gt;
&lt;th&gt;新的继任者&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;Before&lt;/td&gt;
&lt;td&gt;BeforeEach&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;After&lt;/td&gt;
&lt;td&gt;AfterEach&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;BeforeClass&lt;/td&gt;
&lt;td&gt;BeforeAll&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;AfterClass&lt;/td&gt;
&lt;td&gt;AfterAll&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Category&lt;/td&gt;
&lt;td&gt;Tag&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;RunWith&lt;/td&gt;
&lt;td&gt;ExtendWith&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Rule&lt;/td&gt;
&lt;td&gt;ExtendWith&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;ClassRule&lt;/td&gt;
&lt;td&gt;RegisterExtension&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;版本和环境信息&quot;&gt;版本和环境信息&lt;/h3&gt;
&lt;p&gt;整个系列的编码和执行在以下环境进行，供您参考：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;硬件配置：处理器i5-8400，内存32G，硬盘128G SSD + 500G HDD&lt;/li&gt;
&lt;li&gt;操作系统：Windows10家庭中文版&lt;/li&gt;
&lt;li&gt;IDEA：2020.2.2 (Ultimate Edition)&lt;/li&gt;
&lt;li&gt;JDK：1.8.0_181&lt;/li&gt;
&lt;li&gt;SpringBoot：2.3.4.RELEASE&lt;/li&gt;
&lt;li&gt;JUnit Jupiter：5.6.2&lt;br/&gt;接下来开始实战，咱们先建好SpringBoot项目；&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;关于lombok&quot;&gt;关于lombok&lt;/h3&gt;
&lt;p&gt;为了简化代码，项目中使用了lombok，请您在IDEA中安装lombok插件；&lt;/p&gt;
&lt;h3 id=&quot;源码下载&quot;&gt;源码下载&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;如果您不想编码，可以在GitHub下载所有源码，地址和链接信息如下表所示(&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot; target=&quot;_blank&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;)：&lt;/li&gt;
&lt;/ol&gt;&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;这个git项目中有多个文件夹，本章的应用在&lt;span&gt;junitpractice&lt;/span&gt;文件夹下，如下图红框所示：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202102/485422-20210219081513555-2046624807.jpg&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;&lt;span&gt;junitpractice&lt;/span&gt;是父子结构的工程，本篇的代码在&lt;span&gt;junit5experience&lt;/span&gt;子工程中，如下图：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202102/485422-20210219081513997-472684688.jpg&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;创建maven父工程&quot;&gt;创建Maven父工程&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;为了便于管理整个系列的源码，在此建立名为&lt;span&gt;junitpractice&lt;/span&gt;的maven工程，后续所有实战的源码都作为junitpractice的子工程；&lt;/li&gt;
&lt;li&gt;junitpractice的pom.xml如下，可见是以SpringBoot的&lt;span&gt;2.3.4.RELEASE&lt;/span&gt;版本作为其父工程：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;
    &amp;lt;modules&amp;gt;
        &amp;lt;module&amp;gt;simplebean&amp;lt;/module&amp;gt;
        &amp;lt;!--
        &amp;lt;module&amp;gt;testenvironment&amp;lt;/module&amp;gt;
        --&amp;gt;
    &amp;lt;/modules&amp;gt;
    &amp;lt;parent&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;2.3.4.RELEASE&amp;lt;/version&amp;gt;
        &amp;lt;relativePath/&amp;gt; &amp;lt;!-- lookup parent from repository --&amp;gt;
    &amp;lt;/parent&amp;gt;
    &amp;lt;groupId&amp;gt;com.bolingcavalry&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;junitpractice&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;
    &amp;lt;packaging&amp;gt;pom&amp;lt;/packaging&amp;gt;
    &amp;lt;properties&amp;gt;
        &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt;
        &amp;lt;project.reporting.outputEncoding&amp;gt;UTF-8&amp;lt;/project.reporting.outputEncoding&amp;gt;
        &amp;lt;java.version&amp;gt;1.8&amp;lt;/java.version&amp;gt;
    &amp;lt;/properties&amp;gt;

    &amp;lt;dependencyManagement&amp;gt;
        &amp;lt;dependencies&amp;gt;
            &amp;lt;dependency&amp;gt;
                &amp;lt;groupId&amp;gt;org.projectlombok&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;lombok&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;1.16.16&amp;lt;/version&amp;gt;
            &amp;lt;/dependency&amp;gt;
        &amp;lt;/dependencies&amp;gt;
    &amp;lt;/dependencyManagement&amp;gt;
&amp;lt;/project&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;本篇的源码工程&quot;&gt;本篇的源码工程&lt;/h3&gt;
&lt;p&gt;接下来咱们准备一个简单的SpringBoot工程用于做单元测试，该工程有service和controller层，包含一些简单的接口和类；&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;创建名为&lt;span&gt;junit5experience&lt;/span&gt;的子工程，pom.xml如下，注意单元测试要依赖&lt;span&gt;spring-boot-starter-test&lt;/span&gt;：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;
    &amp;lt;parent&amp;gt;
        &amp;lt;groupId&amp;gt;com.bolingcavalry&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;junitpractice&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;
        &amp;lt;relativePath&amp;gt;../pom.xml&amp;lt;/relativePath&amp;gt;
    &amp;lt;/parent&amp;gt;
    &amp;lt;groupId&amp;gt;com.bolingcavalry&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;junit5experience&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt;
    &amp;lt;name&amp;gt;junit5experience&amp;lt;/name&amp;gt;
    &amp;lt;description&amp;gt;Demo project for simplebean in Spring Boot junit5&amp;lt;/description&amp;gt;
    &amp;lt;properties&amp;gt;
        &amp;lt;java.version&amp;gt;1.8&amp;lt;/java.version&amp;gt;
    &amp;lt;/properties&amp;gt;
    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.projectlombok&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;lombok&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
            &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-webflux&amp;lt;/artifactId&amp;gt;
            &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;
    &amp;lt;build&amp;gt;
        &amp;lt;plugins&amp;gt;
            &amp;lt;plugin&amp;gt;
                &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;
            &amp;lt;/plugin&amp;gt;
        &amp;lt;/plugins&amp;gt;
    &amp;lt;/build&amp;gt;
&amp;lt;/project&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;写一些最简单的业务代码，首先是service层的接口HelloService.java：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.bolingcavalry.junit5experience.service;

public interface HelloService {
    String hello(String name);
    int increase(int value);
    /**
     * 该方法会等待1秒后返回true，这是在模拟一个耗时的远程调用
     * @return
     */
    boolean remoteRequest();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;上述接口对应的实现类如下，hello和increase方法分别返回String型和int型，remoteRequest故意sleep了1秒钟，用来测试Timeout注解的效果：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.bolingcavalry.junit5experience.service.impl;

import com.bolingcavalry.junit5experience.service.HelloService;
import org.springframework.stereotype.Service;

@Service()
public class HelloServiceImpl implements HelloService {
    @Override
    public String hello(String name) {
        return &quot;Hello &quot; + name;
    }

    @Override
    public int increase(int value) {
        return value + 1;
    }

    @Override
    public boolean remoteRequest() {
        try {
            Thread.sleep(1000);
        } catch (InterruptedException interruptedException) {
            interruptedException.printStackTrace();
        }

        return true;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;添加一个简单的controller：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.bolingcavalry.junit5experience.controller;

import com.bolingcavalry.junit5experience.service.HelloService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class HelloController {

    @Autowired
    private HelloService helloService;

    @RequestMapping(value = &quot;/{name}&quot;, method = RequestMethod.GET)
    public String hello(@PathVariable String name){
        return helloService.hello(name);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;5&quot;&gt;&lt;li&gt;启动类：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.bolingcavalry.junit5experience;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class Junit5ExperienceApplication {

    public static void main(String[] args) {
        SpringApplication.run(Junit5ExperienceApplication.class, args);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;以上就是一个典型的web工程，接下来一起为该工程编写单元测试用例；&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;编写测试代码&quot;&gt;编写测试代码&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;在下图红框位置新增单元测试类：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202102/485422-20210219081514547-1518877041.jpg&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;2. 测试类的内容如下，涵盖了刚才提到的常用注解，请注意每个方法的注释说明：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.bolingcavalry.junit5experience.service.impl;

import com.bolingcavalry.junit5experience.service.HelloService;
import lombok.extern.slf4j.Slf4j;
import org.junit.jupiter.api.*;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import java.util.concurrent.TimeUnit;
import static org.assertj.core.api.Assertions.assertThat;

@SpringBootTest
@Slf4j
class HelloServiceImplTest {

    private static final String NAME = &quot;Tom&quot;;

    @Autowired
    HelloService helloService;

    /**
     * 在所有测试方法执行前被执行
     */
    @BeforeAll
    static void beforeAll() {
        log.info(&quot;execute beforeAll&quot;);
    }

    /**
     * 在所有测试方法执行后被执行
     */
    @AfterAll
    static void afterAll() {
        log.info(&quot;execute afterAll&quot;);
    }

    /**
     * 每个测试方法执行前都会执行一次
     */
    @BeforeEach
    void beforeEach() {
        log.info(&quot;execute beforeEach&quot;);
    }

    /**
     * 每个测试方法执行后都会执行一次
     */
    @AfterEach
    void afterEach() {
        log.info(&quot;execute afterEach&quot;);
    }

    @Test
    @DisplayName(&quot;测试service层的hello方法&quot;)
    void hello() {
        log.info(&quot;execute hello&quot;);
        assertThat(helloService.hello(NAME)).isEqualTo(&quot;Hello &quot; + NAME);
    }

    /**
     * DisplayName中带有emoji，在测试框架中能够展示
     */
    @Test
    @DisplayName(&quot;测试service层的increase方法\uD83D\uDE31&quot;)
    void increase() {
        log.info(&quot;execute increase&quot;);
        assertThat(helloService.increase(1)).isEqualByComparingTo(2);
    }

    /**
     * 不会被执行的测试方法
     */
    @Test
    @Disabled
    void neverExecute() {
        log.info(&quot;execute neverExecute&quot;);
    }

    /**
     * 调用一个耗时1秒的方法，用Timeout设置超时时间是500毫秒，
     * 因此该用例会测试失败
     */
    @Test
    @Timeout(unit = TimeUnit.MILLISECONDS, value = 500)
    @Disabled
    void remoteRequest() {
        assertThat(helloService.remoteRequest()).isEqualTo(true);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;接下来执行测试用例试试，点击下图红框中的按钮：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202102/485422-20210219081514804-1138080473.jpg&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;4. 如下图，在弹出的菜单中，点击红框位置：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202102/485422-20210219081515077-1037727870.jpg&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;5&quot;&gt;&lt;li&gt;执行结果如下，可见Displayname注解的值作为测试结果的方法名展示，超时的方法会被判定为测试不通过，Disable注解修饰的方法则被标记为跳过不执行：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202102/485422-20210219081515633-490622668.jpg&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;6&quot;&gt;&lt;li&gt;在父工程junitpractice的pom.xml文件所在目录，执行&lt;span&gt;mvn test&lt;/span&gt;命令，可以看到maven执行单元测试的效果：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202102/485422-20210219081516585-1528356270.jpg&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;至此，咱们对SpringBoot环境下的JUnit5有了最基本的了解，接下来的章节会展开更多知识点和细节，对单元测试做更深入的学习。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;你不孤单，欣宸原创一路相伴&quot;&gt;你不孤单，欣宸原创一路相伴&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105068742&quot; target=&quot;_blank&quot;&gt;Java系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086498&quot; target=&quot;_blank&quot;&gt;Spring系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086732&quot; target=&quot;_blank&quot;&gt;Docker系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086794&quot; target=&quot;_blank&quot;&gt;kubernetes系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086850&quot; target=&quot;_blank&quot;&gt;数据库+中间件系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086920&quot; target=&quot;_blank&quot;&gt;DevOps系列&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;欢迎关注公众号：程序员欣宸&quot;&gt;欢迎关注公众号：程序员欣宸&lt;/h3&gt;
&lt;blockquote readability=&quot;4.258064516129&quot;&gt;
&lt;p&gt;微信搜索「程序员欣宸」，我是欣宸，期待与您一同畅游Java世界...&lt;br/&gt;&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot; target=&quot;_blank&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Fri, 19 Feb 2021 00:15:00 +0000</pubDate>
<dc:creator>程序员欣宸</dc:creator>
<og:description>欢迎访问我的GitHub https://github.com/zq2599/blog_demos 内容：所有原创文章分类汇总及配套源码，涉及Java、Docker、Kubernetes、DevOPS</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/bolingcavalry/p/14414381.html</dc:identifier>
</item>
<item>
<title>如何成为一个精力充沛的程序员——掌控 - 老于`</title>
<link>http://www.cnblogs.com/hunternet/p/14414374.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hunternet/p/14414374.html</guid>
<description>&lt;p&gt;在程序员这个行业中996工作制几乎已经成为了常态，除了着超负荷的工作以外，还有着众多的不良习惯：晚睡、久坐、&lt;/p&gt;
&lt;p&gt;不按时吃饭，再加上工作和生活上的压力，使得整个人每天都处于一个忙碌和焦虑的状态。这样的后果就是换来了一个不健康的身体。根据数据显示上海白领的体验异常率竟达到了99%，而近年来，xx大厂员工猝死的消息更是时有出现。&lt;/p&gt;
&lt;p&gt;这让身处大厂的我不禁捏了一把冷汗，仔细回顾之前的工作生活，不良习惯真是不少，几年的程序员工作下来，更是感觉到自己的精力以大不如从前，早已没有了刚毕业那会的朝气和活力，每天都有一种身心俱疲的感觉，每到周末只想在家睡觉，记忆力也大不如前......整个人处于一种浑浑噩噩的状态。&lt;/p&gt;
&lt;p&gt;那些不幸猝死的员工们已经用生命向我们发出了警示，毛爷爷曾经说过，身体是革命的本钱，一切行动的前提条件是必须要有良好的体魄。一个人要想做成一件事，必须具有多方面的素质，但所有这些都必须依托于一个前提条件——要有健康的体魄。如果你的健康没有了，那么无论是理想还是金钱都将永远离你而去！&lt;/p&gt;
&lt;p&gt;身为个体的我们也许无法改变当下的体制与行业的现状。但是却可以改变我们自己。&lt;/p&gt;
&lt;p&gt;过节期间读了一本书，《掌控：开启不疲惫、不焦虑的人生》这是一本自我管理的书，他让我们通过运动，饮食，恢复，还有心态等多个方面，让我们可以做到精力充沛，可以让我们更加科学的管理自己，拥有更好的工作和学习状态。&lt;/p&gt;
&lt;p&gt;这本书的开篇三句话就深深触动了我&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;实现对自己人生的全面掌控&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;成为一个精力充沛的人&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;摆脱有心无力的失控感&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;这正是当下的我最渴望的事情！&lt;/p&gt;
&lt;p&gt;作者认为精力充沛并非天赋，我们可以通过后天的对身体科学系统的使用来实现精力的管理。主要从运动管理、饮食管理、休息管理、心态管理四个维度来给自己不断的加油，实现可持续性地工作与生活！&lt;/p&gt;
&lt;h3 id=&quot;1-运动管理你的运动方式对了吗&quot;&gt;1 运动管理——你的运动方式对了吗&lt;/h3&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;运动健身的本质诉求&lt;/p&gt;
&lt;p&gt;是在高强度工作中游刃有余&lt;/p&gt;
&lt;p&gt;是在工作之外还有精力享受生活&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;提到如何保持身体健康，我想大多数人第一时间想到的就是运动，然而运动真的会一定会让我们的精力更充沛、身体变得更好吗？其实我们每个人也许都尝试过，在进行了大量的运动之后，往往会感觉到更加疲劳，工作起来有气无力。究其根本是我们的运动方式不正确！&lt;/p&gt;
&lt;p&gt;首先我们应该弄明白运动的目的是什么？也许不同的人会有不同的答案，有的人是为了能够瘦身，有的人是为了能够拥有诱人的马甲线，有的人是为了拥有更强大的力量......&lt;/p&gt;
&lt;p&gt;而我宁愿成为一个精力充沛的胖子！&lt;/p&gt;
&lt;p&gt;美国运动医学会提出了一个叫做健康体适能的原则，我认为是最适合我们上班族的。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;所谓健康体适能,就是指一个人每天拥有足够的精力完成工作和学习任务而不疲劳，并有余力享受休闲活动，还能应付突发状况的身体能力。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于运动，我们应该认识到几个重要的观念&lt;/p&gt;
&lt;p&gt;1、心肺功能的锻炼大于肌肉力量的提升&lt;/p&gt;
&lt;p&gt;也许大部分健身教练会告诉你肌肉力量才是最重要的！但心肺功能的锻炼才是最重要的，如果心肺出了问题，再好的零部件也是一堆废铁。&lt;/p&gt;
&lt;p&gt;据研究表明，心脑血管疾病才是所有致命疾病的首位，也是中老年人猝死的最大元凶之一，这就是一扇生死之门！而在几乎所有的外科手术之前，对心肺功能的检查更是必不可少的。因此我们运动的首要目的就是进行心肺功能的锻炼！&lt;/p&gt;
&lt;p&gt;2、 高强度的运动并不能避免疾病与伤痛&lt;/p&gt;
&lt;p&gt;很多人认为心肺功能的锻炼需要高强度的运动，但其实这并不是心肺功能锻炼的最佳选择。长时间的高强度运动会透支我们的身体各项机能，从而过早的发生一些老年疾病(如关节炎...),甚至突然开始的高强度锻炼反而会让我们透支心肺能力、甚至造成运动猝死&lt;/p&gt;
&lt;p&gt;3、运动的分寸：95%的舒适度+5%的挑战&lt;/p&gt;
&lt;p&gt;其实正确的运动强度应该是95%的舒适度+5%的挑战，在运动的时候我们应该离开自己的舒适区，但是又不能离开太远。寻找舒适区的目的是为了保证运动的安全，其次是享受运动的过程，并能从运动中获得激素改善的快感，这样才能够做到运动的可持续性，把运动变成一种乐趣。&lt;/p&gt;
&lt;p&gt;4、选择适合自己的运动方式&lt;/p&gt;
&lt;p&gt;提到运动，多数人第一时间想到的就是跑步和撸铁。但是所有人都适合这种运动方式吗？答案显然是否定的。虽然跑步相对于其他的运动方式是最简单，成本也最低。&lt;/p&gt;
&lt;p&gt;但其实在现在的社会，尤其是我们这个行业中，由于久坐、饮食不规律等一系列不好的生活习惯， 很多人的体重越来越重， 跑起来身体的负担就会也越来越大。而 如果一个人体重基数过大， 而本身肌肉不足， 腿部根本难以支撑身体的重量，容易造成腿部的损伤！&lt;/p&gt;
&lt;p&gt;因此在不同的人要根据自己的身体条件选择适合自己的运动方式，还要制定合理的运动强度！&lt;/p&gt;
&lt;h3 id=&quot;2-饮食管理吃对了、抗衰老、不疲惫&quot;&gt;2 饮食管理——吃对了、抗衰老、不疲惫&lt;/h3&gt;
&lt;p&gt;在生活中，我们常常发现有的人想要减肥，每天跑8000m也没能跑掉游泳圈，断食7天也减不掉1公斤，而有的人想要增肥，每天吃的很撑也没能涨二斤肉......&lt;/p&gt;
&lt;p&gt;我们首先应该弄清楚几个问题，那就是&lt;code&gt;运动≠一定减肥&lt;/code&gt; &lt;code&gt;节食≠一定减肥&lt;/code&gt; &lt;code&gt;吃饱≠吃对&lt;/code&gt;,无论你的目的是减肥、增肥，还是要想要一个健康的身体，恰当的运动与合理的饮食相结合才能发挥作用。&lt;/p&gt;
&lt;p&gt;也许你还不清楚，如果你想减肥，那么你吃一个巧克力，你的2公里就白跑了，而你如果吃一包乐事薯片你的10公里就白跑了。下面一张表对应了在满足了一天的热量要跑多远才能消化的食物。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;食物&lt;/th&gt;
&lt;th&gt;消耗对应的距离&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;玉米一根&lt;/td&gt;
&lt;td&gt;2.38km&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;汉堡一个&lt;/td&gt;
&lt;td&gt;4.05km&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;薯条一份&lt;/td&gt;
&lt;td&gt;5.97km&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;巧克力蛋糕一块&lt;/td&gt;
&lt;td&gt;6.94km&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;苹果一个&lt;/td&gt;
&lt;td&gt;0.89km&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;乐事薯片一包&lt;/td&gt;
&lt;td&gt;10.47km&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;啤酒一瓶&lt;/td&gt;
&lt;td&gt;2.88km&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;可乐一罐&lt;/td&gt;
&lt;td&gt;1.87km&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;看到这里你是不是能管住自己的嘴了呢?&lt;/p&gt;
&lt;p&gt;那么我不吃行不行？节食是另一大误区。据一项研究结果看,为时7天的断食减肥,脂肪的总消耗不到1kg,其他的消耗还有400g左右的糖分和200g左右的蛋白质。剩下的,全是水分。也就是说,痛苦煎熬过来的7天减掉的大多是水分,还有糖分和宝贵的蛋白质,只减少了不到1kg的脂肪。当然,7天之后脂肪的消耗会越来越多,可是又有几个人能坚持下去,而且长期断食带来的可能更多是免疫力和精力的严重下降&lt;/p&gt;
&lt;p&gt;可见,断食瘦身的方法不可取！&lt;/p&gt;
&lt;p&gt;正确饮食的要点是什么呢？&lt;/p&gt;
&lt;p&gt;1.避免三高，即高油、高糖、高热量&lt;/p&gt;
&lt;p&gt;此类食物有三个危害。首先，没有补充精力，反而消耗更多时间；其次，即便入睡，身体仍在消化运动，没有休息；第三，摄入过多热量，变成脂肪。&lt;/p&gt;
&lt;p&gt;2.人体的三大油箱——碳水化合物、蛋白质和脂肪。&lt;/p&gt;
&lt;p&gt;人体每吸收lg糖分(也就是碳水化合物),就会获取4000卡路里热量。如果摄取的碳水化合物超过身体所需,就会转化成脂肪存在身体里,碳水化合物超量同样会造成脂肪囤积&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对于碳水化合物我们要做到适量！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;相比碳水，蛋白质则益处多多。首先，蛋白质是肌肉的原料，因此许多健美运动员都有意识喝蛋白粉。其次，蛋白质与免疫吸纳高管。第三，蛋白质与头发合成相关，欠缺蛋白质摄入容易脱发。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对于蛋白质我们要做到多吃！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;很多营养学认为脂肪不是个好东西，但事实上,脂肪并不是一无是处的,它也有优点,比如可以减慢胃部排空的速度,减缓饥饿感,增加饱腹感;缓解餐后血糖的上升速度;有助于身体健康和细胞膜的修复;对特定的维生素和抗氧化剂的吸收而言,都是必需品;某些脂肪酸还有益代谢;优质脂肪可以给身体提供强力的营养,从而对关节、器官、皮肤和头发进行细胞恢复&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对于脂肪我们要做到少吃！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;3.性价比最高的天然维生素————绿叶蔬菜&lt;/p&gt;
&lt;p&gt;提到维生素的补充，很多人可能想到的是水果，水果固然重要，但其实绿叶蔬菜会更好，绿叶蔬菜的平均维生素含量居于各类蔬菜之冠。100克新鲜绿叶蔬菜的维生素C平均含量为2060mg,比如100g西蓝花含有的维生素C是51mg,几乎是100g橙子维生素C含量的1倍,是100g苹果维生素C含量的10倍。这才是我们需要精力饮食的重要燃料！&lt;/p&gt;
&lt;p&gt;4.水是最好的饮料&lt;/p&gt;
&lt;p&gt;充足的水分会增加活力,提升皮肤和筋膜的质量,保持肌肉和关节的润滑,还可以延缓衰老。因为生活中的脱水、压力影响会使筋膜和肌肉周围的结缔组织以及关节变得干燥甚至老化,水分充足可以延缓这个干燥的过程,提高肌肉组织的质量。&lt;/p&gt;
&lt;p&gt;许多人总喜欢市面上的各种饮料，但其实白水才是最好的饮料！通常甜味的饮料都含糖，而一些碳酸饮料对人体的伤害更大！&lt;/p&gt;
&lt;h3 id=&quot;3-休息管理走走停停才能跑得好人生这场马拉松&quot;&gt;3 休息管理——走走停停才能跑得好人生这场马拉松&lt;/h3&gt;
&lt;p&gt;规律运动、合理饮食只是精力管理的一部分，休息经常被忽视，但其占精力管理的一半左右。不要忘了我们的目的是能在高强度工作中游刃有余,在工作之外还有精力去享受生活。而最重要的两个精力维度“意志力”和“专注力”都要从休息中得到恢复。&lt;/p&gt;
&lt;p&gt;但是现在大多数人的休息都是在刷朋友圈、看新闻、看剧......&lt;/p&gt;
&lt;p&gt;那么这些所谓的休息方式,能够达到真正休息的目的吗？非但不是，反而会继续消耗我们的意志力或是专注力,所以每次做完这些事后反而更累了。&lt;/p&gt;
&lt;p&gt;也有的人认为休息就是睡觉，但实际上相信很多人都有感触，在周六周日休息了两天之后，到了周一上班却更加无精打采，不但没有感到精力充沛，反而更疲惫，&lt;/p&gt;
&lt;p&gt;那么应该有哪些好的休息方式呢？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优质睡眠&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;优质睡眠是休息管理最重要的一环。当睡眠不足时,身体会进入一个恶性循环,造成身体的过度损耗,精力管理更是无从谈起。&lt;/p&gt;
&lt;p&gt;对于优质睡眠有几个技巧&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;睡前远离电子产品&lt;/li&gt;
&lt;li&gt;午睡半小时，精神一整天&lt;/li&gt;
&lt;li&gt;保持良好的睡眠规律、充足的睡眠时间&lt;/li&gt;
&lt;li&gt;分析睡眠数据，优化睡眠&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;深呼吸&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们前面讲到，运动管理中最重要的一点就是提高自己的心肺能力，而深呼吸就可以很好的锻炼我们的心肺能力。而且深呼吸可以调动人体的副交感神经。和交感神经负责应激不同,副交感神经主要负责放松身体和消化吸收。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;筋膜放松&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于工作性质，长时间的伏案久坐，让我们身体各个部位的肌肉处于一个僵硬的状态，我们的肌肉不只需要强壮， 还需要柔软， 才可能保证身体和精力始终处于最佳状态 。因此经常做做按摩，进行筋膜的放松是很有必要的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;散步&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;散步在活动肢体的同时,可以让身体得到积极的放松和休息,还可以增加大脑的供血量。更重要的作用是散步给持续紧绷的大脑提供了一个恰到好处的——打断当下的工作,清一下自己的缓存，以便更加高效的工作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;和朋友聊天&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以和朋友围在桌子旁边喝喝酒、吃吃菜、聊聊天,切记不要聊一些烧脑的工作问题，没有业务压力,没有功利心,闲谈的同时还可以增进感情,缓解自己的孤独状态,不失为一种很好的放松、减压方式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;回归大自然&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于每天身处于喧嚣浮躁的我们,出去走走，亲近大自然，看一看世界的山、水、花儿......可以让我们的身心彻底放松，不失为一个很好的休息方式。&lt;/p&gt;
&lt;h3 id=&quot;4-心态管理&quot;&gt;4 心态管理&lt;/h3&gt;
&lt;p&gt;心态管理是精力管理的基石。&lt;/p&gt;
&lt;p&gt;我们在生活与工作过程中，难以避免的会遇到许多不尽如人意的事情。这些事情经常会让我们产生悲伤、恐惧、生气、焦虑......糟糕的情绪。这些坏情绪才是我们精力的最大杀手。&lt;/p&gt;
&lt;p&gt;比如我自己就不是一个能够很好的管理好自己心态的人。&lt;/p&gt;
&lt;p&gt;我曾经就常常因为一些工作生活中的小事而感到焦虑，也常常因为一些口角的争辩而愤怒，进而无心工作、无心运动、无心吃饭.....最终严重影响了自己的健康。&lt;/p&gt;
&lt;p&gt;而关于心态管理，我个人认为这本书对于这方面的讲解并不太好，希望能找到更好的关于心态管理的书来提升自己！&lt;/p&gt;
&lt;p&gt;关注下方公众号回复“掌控”二字，可得此书pdf版&lt;/p&gt;
</description>
<pubDate>Fri, 19 Feb 2021 00:01:00 +0000</pubDate>
<dc:creator>老于`</dc:creator>
<og:description>在程序员这个行业中996工作制几乎已经成为了常态，除了着超负荷的工作以外，还有着众多的不良习惯：晚睡、久坐、 不按时吃饭，再加上工作和生活上的压力，使得整个人每天都处于一个忙碌和焦虑的状态。这样的后果</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/hunternet/p/14414374.html</dc:identifier>
</item>
<item>
<title>NLog整合Exceptionless - yi念之间</title>
<link>http://www.cnblogs.com/wucy/p/14401650.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wucy/p/14401650.html</guid>
<description>&lt;h4 id=&quot;前言&quot;&gt;前言&lt;/h4&gt;
&lt;p&gt;    在实际的.Net Core相关项目开发中，很多人都会把NLog作为日志框架的首选，主要是源于它的强大和它的扩展性。同时很多时候我们需要集中式的采集日志，这时候仅仅使用NLog是不够的，NLog主要是负责代码中日志的落地，也就是收集程序中的日志。类似的使用ELK(Elasticsearch+Logstash+Kibana)或EFK(Elasticsearch+Filebeat+Kibana)的集中式日志管理平台负责统一采集各个应用端通过日志框架手机的日志并统一的管理和展示。但是无论是ELK还是EFK，操作都有一定的复杂度，而且这是重型武器，有时候可能还不需要这么大的排场，这时候就需要一种轻量级的解决方案，而Exceptionless正式这种轻量级的分布式日志管理平台。&lt;/p&gt;
&lt;h4 id=&quot;概念&quot;&gt;概念&lt;/h4&gt;
&lt;p&gt;可能有的同学对于Exceptionless或者是NLog还不是很了解，这里咱们就简单的介绍一下。&lt;/p&gt;
&lt;h5 id=&quot;exceptionless&quot;&gt;Exceptionless&lt;/h5&gt;
&lt;p&gt;    简单的来说Exceptionless就是一款分布式日志管理框架，它可以统一收集管理并展示出来程序的日志，这样的话减少了传统开发过程中还需要去服务器查找日志的痛苦，大大提升对程序的运维效率。接下来我们先亮出来自学三件套&lt;/p&gt;
&lt;p&gt;目前支持JavaScript, Node, .NET Core, .NET相关应用程序的异常信息采集。为何仅支持.Net .Net Core和JS相关的？原因很简单，Exceptionless是基于.NET Core开发的。如果你有别的语言的开发需求也想使用Exceptionless，这个时候不要气馁，因为Exceptionless本质是基于http接口的形式上报数据的，这个可在官方文档上找到如何使用http上报日志信息相关&lt;/p&gt;
&lt;p&gt;以上文档有针对Exceptionless通过http接口对接的所有信息，通过它可以封装自己的sdk。&lt;/p&gt;
&lt;h5 id=&quot;nlog&quot;&gt;NLog&lt;/h5&gt;
&lt;p&gt;    相信很多同学对NLog已经相当熟悉了，它是一款日志框架，完美的支持.Net和.Net Core，它在.Net Core的流行度和使用广泛度完全不亚于之前的Log4Net，最重要的它功能很强大，而且扩展起来非常方便，它支持将日志输入到多种target形式，比如txt文件、Sql Server、MySQL、Redis、Mq、MongoDb、ElasticSearch等，几乎能想到的所有存储相关的组件，而且还支持过时日志打包压缩自动删除等高级功能，也是我个人非常推荐的一款日志框架，而且它可以直接对接到.Net Core Logger组件上,废话不多说自学N件套地址&lt;/p&gt;
&lt;p&gt;NLog最大的优势就是强大，强大到你能用到的它几乎都支持，而且你想不到的它可能也支持了，而且使用起来也是非常的简单。作为日志框架，我觉得它是最值得一试的一款。&lt;/p&gt;
&lt;h4 id=&quot;环境搭建&quot;&gt;环境搭建&lt;/h4&gt;
&lt;p&gt;    上面我们已经分别介绍了Exceptionless和NLog知道了他们的概念。Exceptionless支持直接采集日志信息上报到Exceptionless，也就是原始的方式，这个官方文档上都有相关的介绍，这里咱们就不过多介绍这种方式了，使用原始方式的的时候可能会存在许多的问题，比如上报形式单一采集格式的问题等。许多时候我们是使用日志框架记录程序日志相关的，它的优势在于target丰富，而且支持自定义日志格式等等，恰恰NLog足够强大，支持直接将Log数据上报到Exceptionless，接下来我们就来看一下它们之间的整合方式。&lt;/p&gt;
&lt;h5 id=&quot;exceptionless搭建&quot;&gt;Exceptionless搭建&lt;/h5&gt;
&lt;p&gt;官网提供了两种使用的方式&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一种是在官方网站注册账号然后获取apiKey，这样的话不用自己搭建Exceptionless，而是将日志直接收集上报到Exceptionless服务器上。但是，一般基于安全和性能考虑，这种方式并不常用。&lt;/li&gt;
&lt;li&gt;另一种则是自建Exceptionless服务，也是本篇我们要使用的方式。之前的低版本支持在window服务器上自建服务，但是高版本已经是基于docker的方式构建了。而使用docker的方式也是我个人日常学习中比较喜欢的方式。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;官方也是提供了两种方式去基于docker构建Exceptionless，一种是基于源码自行构建，另一种则是通过官方docker镜像直接运行容器。因为Exceptionless依赖Elasticsearch存储所以官方也是也是直接提供了docker-compose的方式去运行容器。&lt;br/&gt;如果使用基于源码的方式构建，首先是找到Exceptionless的官方GitHub地址&lt;a href=&quot;https://github.com/exceptionless/Exceptionless&quot; target=&quot;_blank&quot;&gt;https://github.com/exceptionless/Exceptionless&lt;/a&gt;去clone源代码，或者直接下载源码的Release包&lt;a href=&quot;https://github.com/exceptionless/Exceptionless/releases&quot; target=&quot;_blank&quot;&gt;https://github.com/exceptionless/Exceptionless/releases&lt;/a&gt;。下载完成之后进入项目根目录找到docker-compose.dev.yml文件，文件内容如下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yml&quot;&gt;version: '3.7'

services:
  #通过源码自行构建镜像
  app:
    #依赖elasticsearch和redis
    depends_on:
      - elasticsearch
      - redis
    build:
      context: .
      target: app
    image: exceptionless/app:latest
    environment:
      EX_AppMode: Production
      EX_ConnectionStrings__Cache: provider=redis
      EX_ConnectionStrings__Elasticsearch: server=http://elasticsearch:9200
      #redis的作用是消息总线、消息队列和缓存
      EX_ConnectionStrings__MessageBus: provider=redis
      EX_ConnectionStrings__Queue: provider=redis
      EX_ConnectionStrings__Redis: server=redis,abortConnect=false
      EX_RunJobsInProcess: 'false'
    #暴露访问端口
    ports:
      - 5000:80
      - 5001:443
    volumes:
      - appdata:/app/storage
      - ssldata:/https

  jobs:
    depends_on:
      - app
    image: exceptionless/job:latest
    build:
      context: .
      target: job
    environment:
      EX_AppMode: Production
      EX_BaseURL: http://localhost:5000
      EX_ConnectionStrings__Cache: provider=redis
      EX_ConnectionStrings__Elasticsearch: server=http://elasticsearch:9200
      EX_ConnectionStrings__MessageBus: provider=redis
      EX_ConnectionStrings__Queue: provider=redis
      EX_ConnectionStrings__Redis: server=redis,abortConnect=false
      EX_ConnectionStrings__Storage: provider=folder;path=/app/storage
    volumes:
      - appdata:/app/storage

  elasticsearch:
    image: exceptionless/elasticsearch:7.10.0
    environment:
      discovery.type: single-node
      xpack.security.enabled: 'false'
      ES_JAVA_OPTS: -Xms1g -Xmx1g
    ports:
      - 9200:9200
      - 9300:9300
    volumes:
      - esdata7:/usr/share/elasticsearch/data

  kibana:
    depends_on:
      - elasticsearch
    image: docker.elastic.co/kibana/kibana:7.10.0
    ports:
      - 5601:5601

  redis:
    image: redis:6.0-alpine
    ports:
      - 6379:6379

volumes:
  esdata7:
    driver: local
  appdata:
    driver: local
  ssldata:
    driver: local
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过上面的docker-compose文件我们可以看出目前Exceptionless依赖elasticsearch和redis，大致可以看出Exceptionless存储是依赖elasticsearch，而提升性能的则是redis，比如消息总线防止并发的缓冲队列都是依赖redis的，具体实现细节我们这里就不做过多套路了。&lt;span&gt;因为使用dev的方式构建镜像的方式依赖Exceptionless源码，所以不建议移动该docker-compose文件位置&lt;/span&gt;,使用docker-compose的指令直接运行该文件&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker-compose -f docker-compose.dev.yml up
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的方式虽然可以直接依靠源码去构建，但是其实大可不必这么复杂比如kibana这种完全就是多余的，而且他的这种方式是依赖源码的，生产环境我们不可能把代码直接copy过去，所以我们需要精简一下，如下所示&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yml&quot;&gt;version: '3.7'

services:
  app:
    depends_on:
      - elasticsearch
      - redis
    image: exceptionless/exceptionless:latest
    environment:
      EX_AppMode: Production
      EX_ConnectionStrings__Cache: provider=redis
      EX_ConnectionStrings__Elasticsearch: server=http://elasticsearch:9200
      EX_ConnectionStrings__MessageBus: provider=redis
      EX_ConnectionStrings__Queue: provider=redis
      EX_ConnectionStrings__Redis: server=redis:6379,abortConnect=false
      EX_RunJobsInProcess: 'false'
    ports:
      - 5000:80
    volumes:
      - appdata:/app/storage

  jobs:
    depends_on:
      - app
    image: exceptionless/job:latest
    environment:
      EX_AppMode: Production
      EX_BaseURL: http://localhost:5000
      EX_ConnectionStrings__Cache: provider=redis
      EX_ConnectionStrings__Elasticsearch: server=http://elasticsearch:9200
      EX_ConnectionStrings__MessageBus: provider=redis
      EX_ConnectionStrings__Queue: provider=redis
      EX_ConnectionStrings__Redis: server=redis:6379,abortConnect=false
      EX_ConnectionStrings__Storage: provider=folder;path=/app/storage
    volumes:
      - appdata:/app/storage

  elasticsearch:
    image: exceptionless/elasticsearch:7.10.0
    environment:
      discovery.type: single-node
      xpack.security.enabled: 'false'
      xpack.ml.enabled: 'false'
      ES_JAVA_OPTS: -Xms1g -Xmx1g
    ports:
      - 9200:9200
      - 9300:9300
    volumes:
      - esdata7:/usr/share/elasticsearch/data

  redis:
    image: redis:6.0-alpine
    ports:
      - 6379:6379

volumes:
  esdata7:
    driver: local
  appdata:
    driver: local
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将上面的yml内容直接复制到一个新建的docker-compose.yml的空文件中就可以直运行了，无任何额外的依赖，在yml文件所在路径直接运行以下命令&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker-compose up -d
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果你的服务器已经拥有了elasticsearch和redis服务，也就是不需要使用以上docker-compose的方式进行构建，那么可以直接使用官方docker镜像的方式直接启动Exceptionless容器，可以使用docker原生的方式直接运行&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;sudo docker run -d -e EX_AppMode=Production -e EX_ConnectionStrings__Cache=&quot;provider=redis&quot; -e EX_ConnectionStrings__Elasticsearch=&quot;server=http://10.255.198.168:9200&quot; -e EX_ConnectionStrings__MessageBus=&quot;provider=redis&quot; -e EX_ConnectionStrings__Queue=&quot;provider=redis&quot; -e EX_ConnectionStrings__Redis=&quot;server=10.255.198.168:6379,abortConnect=false&quot; -e EX_RunJobsInProcess=false -e EX_Html5Mode=true -p 5000:80 exceptionless/exceptionless:latest
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里注意修改下相关服务的ip地址，因为我粘贴的是我本机的地址，而且注意elasticsearch的版本必须是7.x版本的，否则的话会报错。程序启动完成后再浏览器输输入&lt;a href=&quot;http://ip:5000&quot; target=&quot;_blank&quot;&gt;http://ip:5000&lt;/a&gt;后会自动跳转到登录界面&lt;img src=&quot;https://img2020.cnblogs.com/blog/2042116/202102/2042116-20210218163334833-1617639507.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;如果没有登录账户需要注册一个新的用户后，登录到首页如图所示&lt;img src=&quot;https://img2020.cnblogs.com/blog/2042116/202102/2042116-20210218163605836-882106628.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;因为Exceptionless每个项目的日志信息是根据apiKey去区分的，所以要在Exceptionless中添加你需要采集日志的项目，具体操作如以下步骤&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先，点击所有项目---&amp;gt;创建项目&lt;img src=&quot;https://img2020.cnblogs.com/blog/2042116/202102/2042116-20210218164325012-1427494551.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;然后，输入组织名称和项目名称&lt;img src=&quot;https://img2020.cnblogs.com/blog/2042116/202102/2042116-20210218164437191-2014137807.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;然后，选择项目类型，这里以Asp.Net Core程序为例&lt;img src=&quot;https://img2020.cnblogs.com/blog/2042116/202102/2042116-20210218164711742-1901133994.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;完成之后，点击项目管理，这里的API秘钥正是我们上传到Exceptionless服务所需要的凭证&lt;img src=&quot;https://img2020.cnblogs.com/blog/2042116/202102/2042116-20210218164912288-1827664953.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;到了这一步Exceptionless搭建基本上就完成了。&lt;/p&gt;
&lt;h5 id=&quot;集成nlog&quot;&gt;集成NLog&lt;/h5&gt;
&lt;p&gt;新建一个名叫ProductApi的Asp.Net Core的项目，项目名称任意。然后添加Exceptionless.NLog包，这个包就是将NLog数据上报到Exceptionless的包&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;PackageReference Include=&quot;Exceptionless.NLog&quot; Version=&quot;4.6.2&quot; /&amp;gt;
&amp;lt;PackageReference Include=&quot;NLog.Web.AspNetCore&quot; Version=&quot;4.10.0&quot; /&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Exceptionless.NLog的Github项目地址位于&lt;a href=&quot;https://github.com/exceptionless/Exceptionless.Net/tree/master/src/Platforms/Exceptionless.NLog&quot; target=&quot;_blank&quot;&gt;https://github.com/exceptionless/Exceptionless.Net/tree/master/src/Platforms/Exceptionless.NLog&lt;/a&gt;这个地址相当隐蔽不太容易被发现，而且说明文档也是很低调几乎没啥内容，可能是觉得NLog的文档写的太完善了，不用多说大家就能知道怎么用。添加完nuget包引用之后，修改Program.cs程序添加NLog的Logging扩展。仅仅添加UseNLog即可，因为我们使用了NLog.Web.AspNetCore扩展包，所以NLog会集成到Asp.Net Core自带的Microsoft.Extensions.Logging中去，不得不说.Net Core的整体扩展性还是非常强的，这样的话我们可以设置默认的Logging的配置即可，几乎感知不到NLog的存在&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;public static IHostBuilder CreateHostBuilder(string[] args) =&amp;gt;
            Host.CreateDefaultBuilder(args)
                .ConfigureWebHostDefaults(webBuilder =&amp;gt;
                {
                    webBuilder.UseStartup&amp;lt;Startup&amp;gt;();
                }).UseNLog();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来需要在项目根目录中新建nlog.config用来配置nlog相关信息，新建完成之后添加以下配置&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&amp;gt;
&amp;lt;nlog xmlns=&quot;http://www.nlog-project.org/schemas/NLog.xsd&quot;
      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
      throwExceptions=&quot;true&quot; internalLogFile=&quot;internal-nlog.log&quot; internalLogLevel=&quot;Debug&quot; &amp;gt;
  &amp;lt;extensions&amp;gt;
    &amp;lt;!--添加扩展Exceptionless​程序集--&amp;gt;
    &amp;lt;add assembly=&quot;Exceptionless.NLog&quot;/&amp;gt;
  &amp;lt;/extensions&amp;gt;
  &amp;lt;targets async=&quot;true&quot;&amp;gt;
    &amp;lt;!--写入本地文件--&amp;gt;
    &amp;lt;target name=&quot;File&quot; xsi:type=&quot;File&quot; fileName=&quot;${basedir}/logs/${shortdate}.log&quot;
            layout=&quot; ${longdate}|${event-properties:item=EventId_Id:whenEmpty=0}|${uppercase:${level}}|${logger}|${message} ${exception:format=tostring}|url: ${aspnet-request-url}|action: ${aspnet-mvc-action}| ${newline}&quot; &amp;gt;
    &amp;lt;/target&amp;gt;
    &amp;lt;!--上报Exceptionless--&amp;gt;
    &amp;lt;!--xsi:type:固定是Exceptionless--&amp;gt;
    &amp;lt;!--apiKey:即我们在Exceptionless中添加完项目后得到的apiKey--&amp;gt;
    &amp;lt;!--serverUrl:Exceptionless的地址--&amp;gt;
    &amp;lt;target xsi:type=&quot;Exceptionless&quot; name=&quot;Exceptionless&quot; apiKey=&quot;d66B6fXD6sz3kAuqdc5Fe04td7iIygunkDa5GoUt&quot;
            serverUrl=&quot;http://10.255.52.93:5000/&quot;&amp;gt;
      &amp;lt;!--堆栈信息--&amp;gt;
      &amp;lt;field name=&quot;StackTrace&quot; layout=&quot;${stacktrace}&quot;/&amp;gt;
      &amp;lt;!--Message信息--&amp;gt;
      &amp;lt;field name=&quot;Message&quot; layout=&quot;${message}&quot;/&amp;gt;
      &amp;lt;field name=&quot;LogLevel&quot; layout=&quot;${level}&quot;/&amp;gt;
      &amp;lt;field name=&quot;CreateDate&quot; layout=&quot;${date}&quot;/&amp;gt;
      &amp;lt;!--物理名称--&amp;gt;
      &amp;lt;field name=&quot;MachineName&quot; layout=&quot;${machinename}&quot; /&amp;gt;
      &amp;lt;!--线程ID--&amp;gt;
      &amp;lt;field name=&quot;ThreadId&quot; layout=&quot;${threadid}&quot;/&amp;gt;
      &amp;lt;!--发生源--&amp;gt;
      &amp;lt;field name=&quot;CallSite&quot; layout=&quot;${callsite}&quot;/&amp;gt;
      &amp;lt;field name=&quot;AppdomainVersion&quot; layout=&quot;${assembly-version}&quot;/&amp;gt;
      &amp;lt;field name=&quot;Appdomain&quot; layout=&quot;${appdomain}&quot;/&amp;gt; 
    &amp;lt;/target&amp;gt;
  &amp;lt;/targets&amp;gt;
  &amp;lt;rules&amp;gt;
    &amp;lt;!--本地文件--&amp;gt;
    &amp;lt;logger name=&quot;*&quot; writeTo=&quot;File&quot;/&amp;gt;
    &amp;lt;!--上报Exceptionless--&amp;gt;
    &amp;lt;logger name='*' writeTo='Exceptionless'/&amp;gt;
  &amp;lt;/rules&amp;gt;
&amp;lt;/nlog&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;新建完nlog.config之后不要忘了将右击该文件 属性---&amp;gt;复制到输出路径---&amp;gt;始终复制,或修改该项目的csproj文件添加&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;ItemGroup&amp;gt;
    &amp;lt;Content Update=&quot;nlog.config&quot;&amp;gt;
      &amp;lt;CopyToOutputDirectory&amp;gt;Always&amp;lt;/CopyToOutputDirectory&amp;gt;
    &amp;lt;/Content&amp;gt;
&amp;lt;/ItemGroup&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;到这里为止关于NLog整合Exceptionless的环境搭建就已经完成了，是不是非常的简单，抛开环境搭建工作量其实并不大，这一切都是源于.Net Core的强大和它那灵活的可扩展性。&lt;/p&gt;
&lt;h4 id=&quot;简单测试一下&quot;&gt;简单测试一下&lt;/h4&gt;
&lt;p&gt;通过上面的操作我们已经把NLog整合Exceptionless的环境搭建起来了，接下来我们随便写点代码测试一波随便建个类，就是为了演示异常，代码无任何实质意义，不喜勿喷。。。,这里我是模拟了一个ApiController抛出异常，然后用Logger记录了信息&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;[Route(&quot;productapi/[controller]&quot;)]
public class ProductController : ControllerBase
{
    private readonly ILogger _logger;
    public ProductController(ILogger&amp;lt;ProductController&amp;gt; logger)
    {
        _logger = logger;
    }

    [HttpGet(&quot;exceptiontest&quot;)]
    public string ExceptionTest()
    {
        try
        {
            throw new Exception(&quot;发生了未知的异常&quot;);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex,$&quot;{HttpContext.Connection.RemoteIpAddress}调用了productapi/product/exceptiontest接口返回了失败&quot;);
        }
        return &quot;调用失败&quot;;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行起来项目调用一下这段代码之后，查看Exceptionless，如果环境配置啥的都是正确的话，会展示出一下效果，点击All菜单展示出来的信息会比较全&lt;img src=&quot;https://img2020.cnblogs.com/blog/2042116/202102/2042116-20210218184638631-1950905259.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;可以点击查看详情，详情信息记录的非常详细，不得不说Exceptionless还是非常强大非常人性非常实用的&lt;img src=&quot;https://img2020.cnblogs.com/blog/2042116/202102/2042116-20210218184819430-820757035.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;还能查看更详细的信息&lt;img src=&quot;https://img2020.cnblogs.com/blog/2042116/202102/2042116-20210218184854241-790330472.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;到这里为止，关于NLog整合Exceptionless的操作就全部完成了，感叹一句就是不仅简单而且强大。&lt;/p&gt;
&lt;h4 id=&quot;总结&quot;&gt;总结&lt;/h4&gt;
&lt;p&gt;    通过本次整合NLog和Exceptionless，我们既感受到Exceptionless的简单和强大，也感受到了NLog的扩展性之强，希望更多地人能够尝试一下NLog。这一切还是得益于.Net Core自身的扩展性，特别是它内置的一些抽象，完全成为了构建.Net Core程序的核心，而且基于这些内置的核心抽象操作可以很轻松的扩展许多操作，使得模块之间的耦合性变得非常低，而这种设计的思想才是我们真正在编程中应该学习的。&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;span&gt;👇欢迎扫码关注我的公众号👇&lt;/span&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/2042116/202006/2042116-20200622133425514-1420050576.png&quot;/&gt;&lt;/div&gt;
</description>
<pubDate>Thu, 18 Feb 2021 23:29:00 +0000</pubDate>
<dc:creator>yi念之间</dc:creator>
<og:description>前言 在实际的.Net Core相关项目开发中，很多人都会把NLog作为日志框架的首选，主要是源于它的强大和它的扩展性。同时很多时候我们需要集中式的采集日志，这时候仅仅使用NLog是不够的，NLog主</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wucy/p/14401650.html</dc:identifier>
</item>
<item>
<title>1. VUE完整系统简介 - 盛开的太阳</title>
<link>http://www.cnblogs.com/ITPower/p/14410471.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ITPower/p/14410471.html</guid>
<description>&lt;p&gt;今天开始系统学习vue前端框架. 我是有前端基础的, 刚工作那会, 哪里分那么清楚啊, 前后端我都得做, 所以, css, js, jquery, bootstrap都会点, 还系统学过ext, 哈哈,是不是都不知道是啥, 没事, 都过时了. 现在开始, 学习最流行的Vue, 后端不会页面, 说不过去呀.....&lt;/p&gt;
&lt;p&gt;言归正传, Ready, Go!&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;&lt;span&gt;目录&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;1. 认识Vuejs&lt;/span&gt;&lt;/h3&gt;
&lt;h3&gt;&lt;span&gt;2. Vuejs的安装方式&lt;/span&gt;&lt;/h3&gt;
&lt;h3&gt;&lt;span&gt;3. Vuejs的初体验-三个案例&lt;/span&gt;&lt;/h3&gt;
&lt;h3&gt;&lt;span&gt;4. MVVM模型&lt;/span&gt;&lt;/h3&gt;
&lt;h3&gt;&lt;span&gt;5. Vue对象的生命周期&lt;/span&gt;&lt;/h3&gt;
&lt;h3&gt;&lt;span&gt;6. Vue源码&lt;/span&gt;&lt;/h3&gt;
&lt;hr/&gt;

&lt;h2&gt;　　1. 为什么学习Vuejs&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;这几年Vue.js成为前端框架中最火的一个。越来越多的网站前端开始采用Vue.js开发。前端开发必备技能.&lt;/li&gt;
&lt;li&gt;Vuejs是开源世界华人的骄傲，其作者是我国尤雨溪。学习门槛低，成本低，可跨设备和多平台开发Vue.js.&lt;/li&gt;
&lt;li&gt;前端换工作, 面试必问的框架.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;　　2. 简单认识一下Vuejs&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;官网地址: https://cn.vuejs.org/&lt;/li&gt;
&lt;li&gt;是一套用于构建用户界面的渐进式框架, 什么是渐进式框架呢?&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;_mce_tagged_br&quot;&gt;　　　　　　　　渐进式框架是说, vue可以作为应用的一部分嵌入.&lt;/p&gt;
&lt;p&gt;　　　　　　　　比如:之前项目使用的是jquery开发的, 项目体量比较大, 现在知道vue使用上,效果上都更方便, 想要替换为vue, 可问题是之前的页面特别多,如果全部替换,工作量太大,那么没关系, vue允许你部分嵌入, 也就是说原来的页面依然使用jquery, 而后开发的页面使用Vuejs. vue可以作为一部分嵌入到项目中. 后面再逐渐替换.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;如果是使用vue开发新项目, 那么可以使用vue的全家桶. 包括核心库和和生态系统. 比如: Core+Vue Router + Vuex.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;　　3. Vuejs的核心功能&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;解耦视图和数据&lt;/li&gt;
&lt;li&gt;可复用的组件&lt;/li&gt;
&lt;li&gt;前端路由技术&lt;/li&gt;
&lt;li&gt;状态管理&lt;/li&gt;
&lt;li&gt;虚拟DOM&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;vuejs的安装有三种方式, &lt;/p&gt;
&lt;h2&gt;　　1. CDN引入&lt;/h2&gt;
&lt;h2&gt;　　2. 下载和引入&lt;/h2&gt;
&lt;h2&gt;　　3. NPM安装管理&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;在用 Vue 构建大型应用时推荐使用 NPM 安装&lt;/li&gt;
&lt;li&gt;vuejs可以和webpack和CLI等模块配合使用&lt;/li&gt;
&lt;li&gt;后续学习都是用这种方式操作的.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;　　1. Hello Vuejs&lt;/h2&gt;
&lt;p&gt;　　　　我们学习程序, 经典代码helloworld. 这里说一下开发工具, 开发工具建议使用vscode, 因为里面有很多插件, 但是其他也不是不可以哈&lt;/p&gt;
&lt;p&gt;　　　　我们在感受vue的时候, 为了简单, 方便, 我们使用第二种方式, 下载vue.js, 并引入到项目中. 接下来开始操作.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h3&gt;第一步: 先搭建一个简单的项目. 我的项目名称就叫vue-study. 在里面创建一个文件夹js, 项目结构如下:&lt;/h3&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/1187916/202102/1187916-20210218063231364-754708796.png&quot; width=&quot;200&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul readability=&quot;21&quot;&gt;&lt;li&gt;
&lt;h3&gt; 第二步: 然后下载vue.js, 将其放入到js文件夹中&lt;/h3&gt;
&lt;/li&gt;
&lt;li readability=&quot;49&quot;&gt;
&lt;h3&gt; 第三步: 写一个html页面, 并引入vue.js.&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;html&amp;gt;
    &amp;lt;head&amp;gt;
        &amp;lt;title&amp;gt;第一个vue程序&amp;lt;/title&amp;gt;
        &lt;span&gt;&lt;strong&gt;&amp;lt;script src=&quot;../js/vue.js&quot;&amp;gt;&amp;lt;/script&amp;gt;&lt;/strong&gt;&lt;/span&gt;
    &amp;lt;/head&amp;gt;
    &amp;lt;body&amp;gt;
        
    &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们看到, 第一步引入了vue.js. 其实这里有个简单的办法, 只需要把项目中js拖进来, 就可以了.引入了vue.js, 那么要如何使用呢? vue.js我们可以理解为对象. 使用使用new Vue()的方式.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&amp;lt;html&amp;gt;

    &amp;lt;head&amp;gt;
        &amp;lt;title&amp;gt;第一个vue程序&amp;lt;/title&amp;gt;
        &lt;strong&gt;&amp;lt;script src=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;../js/vue.js&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;/strong&gt;
    &amp;lt;/head&amp;gt;

    &amp;lt;body&amp;gt;
        &lt;strong&gt;&amp;lt;div id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;app&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;{{message}}&amp;lt;/div&amp;gt;&lt;/strong&gt;
        &lt;span&gt;&lt;strong&gt;&amp;lt;script&amp;gt;
            &lt;span&gt;const app = new Vue&lt;/span&gt;({
                el: &quot;#app&quot;,
                data: {
                    message: &quot;hello, 盛开的太阳!&quot;
                }
            });
        &amp;lt;/script&amp;gt;&lt;/strong&gt;&lt;/span&gt;
    &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上, 我们看到了new Vue(), 相当于把这个对象构建了一份. 然后赋值给了一个常量const app. 这里需要说一下, 以前,我们都是直接使用var, 既可以设置变量也可以设置常量, 但在vue中, 我们的变量和常量都有自己的声明方式&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
声明方式:  常量使用const, 变量使用let.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;创建vue对象的时候, 传入了一个option, option中有两个元素&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
el:全称element, 表示指向的元素.其值使用的是jquery表达式. 该属性决定了这个vue对象挂载到那个元素上, 可以看出, 我们这里是挂载到了id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;app&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;的元素上

data: 这个属性用来存储数据, 这些数据可以试试手动写的, 也可以是动态从服务端取的&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;data定义数据. 这里需要重点说一下了. vue采用的是VMMV的设计模式, 也就是数据和试图分离. 这里的data指的就是数据. 而id=&quot;app&quot;的div是视图. 当页面解析的时候, 解析到script脚本时发现, 我们已经将div交给vue容器了, 那么, 这时候, vue就会去寻找目标元素是否有待填补的变量. 这里我们看到&amp;lt;div id=&quot;app&quot;&amp;gt;{{message}}&amp;lt;/div&amp;gt;里面定义了一个变量message, 而这个变量在vue容器中进行了声明, 因此可以进行对应的自动填充. &lt;/p&gt;
&lt;p&gt; 这里如果暂时不理解, 也没关系, 先混个眼熟, 后面还有详细讲解&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;7&quot;&gt;
&lt;h3&gt;第四步: 分析浏览器执行代码的流程&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &amp;lt;html&amp;gt;
&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;     &amp;lt;head&amp;gt;
&lt;span&gt; 4&lt;/span&gt;         &amp;lt;title&amp;gt;第一个vue程序&amp;lt;/title&amp;gt;
&lt;span&gt; 5&lt;/span&gt;         &amp;lt;script src=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;../js/vue.js&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/script&amp;gt;
&lt;span&gt; 6&lt;/span&gt;     &amp;lt;/head&amp;gt;
&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;     &amp;lt;body&amp;gt;
&lt;span&gt; 9&lt;/span&gt;         &amp;lt;div id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;app&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;{{message}}&amp;lt;/div&amp;gt;
&lt;span&gt;10&lt;/span&gt;         &amp;lt;script&amp;gt;
&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;const&lt;/span&gt; app = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 el: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#app&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;                data: {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                     message: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello, 盛开的太阳!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;            });
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &amp;lt;/script&amp;gt;
&lt;span&gt;18&lt;/span&gt;     &amp;lt;/body&amp;gt;
&lt;span&gt;19&lt;/span&gt; &amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;页面渲染, 首先加载1-10行, 显示出对应的html. 执行到第11行的时候, 创建了vue实例, 并且对照html进行解析和修改.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;　　2. Vue列表展示&lt;/h2&gt;
&lt;p&gt;　　　　下面来看一个稍微复杂一点的例子---列表展示&lt;/p&gt;
&lt;p&gt;　　　　先来看看效果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1187916/202102/1187916-20210218073907239-100167422.png&quot; width=&quot;300&quot; loading=&quot;lazy&quot;/&gt;　　&lt;/p&gt;
&lt;p&gt;　　　　下面思考, 如果我们使用jquery会如何实现呢? 需要些一个for循环, 然后在里面定义n个li, 然后拼装数据. 很复杂.  然而, 使用vue完全不需要在js代码中拼装html元素的数据, 下面来看看怎么做&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul readability=&quot;7.5&quot;&gt;&lt;li readability=&quot;-1.5&quot;&gt;
&lt;h3&gt;第一步: 新建一个html页面, 命名为02-list.html, 然后引入vue.js&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;en&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;title&amp;gt;列表页面&amp;lt;/title&amp;gt;
    &lt;strong&gt;&amp;lt;script src=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;../js/vue.js&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;/strong&gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;26&quot;&gt;
&lt;h3&gt; 第二步构建vue对象&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;en&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;
    &lt;strong&gt;&amp;lt;script src=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;../js/vue.js&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;/strong&gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &lt;strong&gt;&amp;lt;div id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;app&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
        &amp;lt;h1&amp;gt;{{title}}&amp;lt;/h1&amp;gt;
        &amp;lt;ul&amp;gt;
            &amp;lt;li v-&lt;span&gt;for&lt;/span&gt; = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;item in languages&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;{{item}}&amp;lt;/li&amp;gt;
        &amp;lt;/ul&amp;gt;
    &amp;lt;/div&amp;gt;&lt;/strong&gt;
    &amp;lt;script&amp;gt;
        &lt;strong&gt;&lt;span&gt;const&lt;/span&gt;&lt;span&gt; app = new&lt;/span&gt;&lt;span&gt;&lt;span&gt; Vue&lt;/span&gt;({
            el: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#app&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            data:{
                title: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;常见的后端编程语言有哪些?&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                languages: [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;python&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;go&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;java&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;net&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;php&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;c++&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
            }
        });

    &lt;/span&gt;&lt;/strong&gt;&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里指定了当前构建的vue对象挂载在id=&quot;app&quot;的元素上. 并填充值title和languages. 和上一个案例不同, 这里有一个数组元素languages. 那么数组元素应该如何取值呢?&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;ul&amp;gt;
    &lt;span&gt;&lt;strong&gt;&amp;lt;li v-for = &quot;item in languages&quot;&amp;gt;{{item}}&amp;lt;/li&amp;gt;&lt;/strong&gt;&lt;/span&gt;
&amp;lt;/ul&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意红色粗体部分. 使用了一个vue的指令v-for, 这是表示for循环, 这个第一次见到, 先熟悉一下. 后面还会具体讲. 我们以前使用jquery会怎么写呢?&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;ul&amp;gt;
    &amp;lt;li &amp;gt;python&amp;lt;/li&amp;gt;
    &amp;lt;li &amp;gt;go&amp;lt;/li&amp;gt;
    &amp;lt;li &amp;gt;java&amp;lt;/li&amp;gt;
    &amp;lt;li &amp;gt;php&amp;lt;/li&amp;gt;
    &amp;lt;li &amp;gt;.net&amp;lt;/li&amp;gt;
    &amp;lt;li &amp;gt;...&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以前我们要这么写一大堆, 如果是动态从服务端取数据, 那么还要拼li代码, 很容易出错, 还很费劲. 但使用了vue指令, 我们发现一句话就搞定了, 这里是不是可以傲娇一下. 怪不得vue能这么流行.&lt;/p&gt;

&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;　　3. 案例:计数器&lt;/h2&gt;
&lt;p&gt; 　　　　计数器是一个小的综合案例, 通过这个案例来再次感受一下vue的强大. 我们先来看一下效果&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/1187916/202102/1187916-20210218114219783-1813186113.png&quot; width=&quot;200&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　分析: 这里有一个变量, 两个按钮. 点击+, 数字加1, 点击-, 数字减1. 下面我们就来实现这个功能&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul readability=&quot;15&quot;&gt;&lt;li readability=&quot;25.5&quot;&gt;第一步: 创建一个html文件03-计数器.html　
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;en&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;
   &lt;strong&gt; &amp;lt;script src=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;../js/vue.js&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;/strong&gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;app&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&lt;strong&gt;&lt;span&gt;
        当前数字: {{counter}}
        &lt;/span&gt;&lt;/strong&gt;&amp;lt;br&amp;gt;
        &lt;strong&gt;&amp;lt;button&lt;span&gt; v-on:click=&quot;counter++&quot;&lt;/span&gt;&amp;gt; + &amp;lt;/button&amp;gt;
        &amp;lt;button &lt;span&gt;v-on:click=&quot;counter--&quot;&lt;/span&gt;&amp;gt; - &amp;lt;/button&amp;gt;&lt;/strong&gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;script&amp;gt;
        &lt;strong&gt;&lt;span&gt;const&lt;/span&gt; app  = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
            el: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#app&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            data:{
                counter: &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
            }
        });
    &lt;/span&gt;&lt;/strong&gt;&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;引入vue.js, 并创建一个Vue对象. 这些之前都说过, 就不多说了. 接下来看看&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;button v-on:click=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;counter++&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt; + &amp;lt;/button&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这是什么意思呢? 这是vue的写法. v-on是vue的指令, 这里先有个印象, 后面会详细讲解. v-on表示要执行一个事件, :click就是具体的事件, 这里是点击事件, 点击后执行什么逻辑呢? 执行counter ++. 是不是很神奇? 也许还没有感觉, 那么我们来看看, 如果是jQuery, 要怎么做吧?&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;. 给+&lt;span&gt;按钮添加一个点击事件
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;. 获取counter计数器对象的值
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;. 对counter进行++
&lt;span&gt;4&lt;/span&gt;. 再讲counter计算后的结果赋值给计数器对象.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在感受到了吧, jquery是命令式编程, 一行命令执行一个语句. 这里要执行好几句话, 而vue一句话就搞定了.&lt;/p&gt;
　&lt;/li&gt;
&lt;li readability=&quot;14&quot;&gt;第二步: 这里click事件中就有一句话, counter++, 那么要是有好多逻辑怎么办呢? 那就需要提出来单独处理了.
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;en&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;
    &amp;lt;script src=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;../js/vue.js&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;app&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&lt;span&gt;
        当前数字: {{counter}}
        &lt;/span&gt;&amp;lt;br&amp;gt;
        &amp;lt;button &lt;strong&gt;&lt;span&gt;v-on:click=&quot;add&quot;&lt;/span&gt;&lt;/strong&gt;&amp;gt; + &amp;lt;/button&amp;gt;
        &amp;lt;button &lt;span&gt;&lt;strong&gt;v-on:click=&quot;sub&quot;&lt;/strong&gt;&lt;/span&gt;&amp;gt; - &amp;lt;/button&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;script&amp;gt;
        &lt;span&gt;const&lt;/span&gt; app  = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
            el: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#app&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            data:{
                counter: &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
            },
            &lt;span&gt;&lt;strong&gt;methods: {
                add: function() {
                    console.info(&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&quot;add方法被执行&quot;)
                    this.counter ++;
                },
                sub: function () {
                    console.info(&quot;sub方法被执行&quot;)
                    this.counter --&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;;
                }
            }&lt;/strong&gt;&lt;/span&gt;
        });
    &lt;/span&gt;&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在vue里面,要想增加一个事件, 那就放在methods属性里就可以了. 这里有一点需要注意. 在方法里要对data中的变量执行counter ++, 直接这么写是不行的, 需要加上this.counter++. this表示的是new出来的Vue对象. 有朋友可能就要说了, this在方法里面, 不应该是表示当前方法么?vue做了一层代理, 所以, 这里的this指的是new Vue()对象.　　&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;　　1. 什么是MVVM&lt;/h2&gt;
&lt;p&gt;　　　　MVVM是Model-View-ViewModel的简写。它本质上就是MVC 的改进版。MVVM 就是将其中的View 的状态和行为抽象化，让我们将视图 UI 和业务逻辑分开。当然这些事 ViewModel 已经帮我们做了，它可以取出 Model 的数据同时帮忙处理 View 中由于需要展示内容而涉及的业务逻辑。View绑定到ViewModel，然后执行一些命令在向它请求一个动作。而反过来，ViewModel跟Model通讯，告诉它更新来响应UI。这样便使得为应用构建UI非常的容易。&lt;/p&gt;
&lt;p&gt;　　　　MVVM有助于将图形用户界面的开发与业务逻辑或后端逻辑（&lt;em&gt;数据模型&lt;/em&gt;）的开发分离开来，这是通过置标语言或GUI代码实现的。MVVM的&lt;em&gt;视图模型&lt;/em&gt;是一个值转换器，这意味着视图模型负责从模型中暴露（转换）数据对象，以便轻松管理和呈现对象。在这方面，视图模型比视图做得更多，并且处理大部分视图的显示逻辑。 视图模型可以实现中介者模式，组织对视图所支持的用例集的后端逻辑的访问。&lt;/p&gt;
&lt;h2&gt;　　2. MVVM的优点&lt;/h2&gt;
&lt;p&gt;　　　　MVVM模式和MVC模式一样，主要目的是分离&lt;a href=&quot;https://baike.baidu.com/item/%E8%A7%86%E5%9B%BE&quot; target=&quot;_blank&quot;&gt;视图&lt;/a&gt;（View）和模型（Model），有几大优点&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li class=&quot;para&quot;&gt;低耦合。视图（View）可以独立于Model变化和修改，一个ViewModel可以绑定到不同的&quot;View&quot;上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变。&lt;/li&gt;
&lt;li class=&quot;para&quot;&gt;可重用性。你可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑。&lt;/li&gt;
&lt;li class=&quot;para&quot;&gt;独立开发。开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计，使用Expression Blend可以很容易设计界面并生成xaml代码。&lt;/li&gt;
&lt;li class=&quot;para&quot;&gt;可测试。界面素来是比较难于测试的，测试可以针对ViewModel来写。&lt;span class=&quot;sup--normal&quot; data-sup=&quot;1&quot; data-ctrmap=&quot;:1,&quot;&gt; &lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;　　3. MVVM模式的组成部分&lt;/h2&gt;
&lt;div class=&quot;para&quot; readability=&quot;9.0588235294118&quot;&gt;　　　　　　模型是指代表真实状态内容的&lt;a href=&quot;https://baike.baidu.com/item/%E9%A2%86%E5%9F%9F%E6%A8%A1%E5%9E%8B&quot; target=&quot;_blank&quot;&gt;领域模型&lt;/a&gt;（面向对象），或指代表内容的&lt;a href=&quot;https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%E5%B1%82&quot; target=&quot;_blank&quot;&gt;数据访问层&lt;/a&gt;（以数据为中心）。&lt;/div&gt;
&lt;div class=&quot;para&quot; readability=&quot;8.568&quot;&gt;　　　　　　就像在&lt;a href=&quot;https://baike.baidu.com/item/MVC&quot; target=&quot;_blank&quot;&gt;MVC&lt;/a&gt;和&lt;a href=&quot;https://baike.baidu.com/item/MVP&quot; target=&quot;_blank&quot;&gt;MVP&lt;/a&gt;模式中一样，视图是用户在屏幕上看到的结构、布局和外观（UI）。&lt;/div&gt;
&lt;ul class=&quot;custom_dot para-list list-paddingleft-1&quot;&gt;&lt;li&gt;
&lt;ul&gt;&lt;li class=&quot;list-dot list-dot-paddingleft&quot;&gt;
&lt;h4 class=&quot;para&quot;&gt;视图模型&lt;/h4&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;em&gt;　　　　　　视图模型&lt;/em&gt;是暴露公共属性和命令的视图的抽象。MVVM没有MVC模式的控制器，也没有MVP模式的presenter，有的是一个&lt;em&gt;绑定器&lt;/em&gt;。在视图模型中，绑定器在视图和数据绑定器之间进行通信。&lt;/p&gt;
&lt;h2&gt;　　4. Vue中的VMMV&lt;/h2&gt;
&lt;p&gt;　　　　下图不仅概括了MVVM模式（Model-View-ViewModel），还描述了在Vue.js中ViewModel是如何和View以及Model进行交互的。&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/1187916/202102/1187916-20210219050939915-1485402147.png&quot; width=&quot;400&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;



&lt;p&gt;　　　　ViewModel是Vue.js的核心，它是一个Vue实例。Vue实例是作用于某一个HTML元素上的，这个元素可以是HTML的body元素，也可以是指定了id的某个元素。&lt;/p&gt;
&lt;p&gt;　　　　当创建了ViewModel后，双向绑定是如何达成的呢？&lt;/p&gt;
&lt;p&gt;　　　　首先，我们将上图中的DOM Listeners和Data Bindings看作两个工具，它们是实现双向绑定的关键。 &lt;br/&gt;　　　　从View侧看，ViewModel中的DOM Listeners工具会帮我们监测页面上DOM元素的变化，如果有变化，则更改Model中的数据； &lt;br/&gt;　　　　从Model侧看，当我们更新Model中的数据时，Data Bindings工具会帮我们更新页面中的DOM元素。&lt;/p&gt;

&lt;p&gt;　　　　拿第一个案例来说&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&amp;lt;html&amp;gt;

    &amp;lt;head&amp;gt;
        &amp;lt;title&amp;gt;第一个vue程序&amp;lt;/title&amp;gt;
        &lt;strong&gt;&amp;lt;script src=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;../js/vue.js&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;/strong&gt;
    &amp;lt;/head&amp;gt;

    &amp;lt;body&amp;gt;
        &amp;lt;div id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;app&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;{{message}}&amp;lt;/div&amp;gt;
        &amp;lt;script&amp;gt;
            &lt;strong&gt;&lt;span&gt;const&lt;/span&gt; app = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
                el: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#app&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                data: {
                    message: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello, 盛开的太阳!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
                }
            });
        &lt;/span&gt;&lt;/strong&gt;&amp;lt;/script&amp;gt;
    &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在这里, 定义了一个View, 定义了model, 创建了一个Vue实例(view-model), 它用于连接view和model&lt;/p&gt;
&lt;p&gt;在创建Vue实例时，需要传入一个选项对象，选项对象可以包含数据、挂载元素、方法、模生命周期钩子等等。&lt;/p&gt;
&lt;p&gt;在这个示例中，选项对象的el属性指向View，el: ‘#app’表示该Vue实例将挂载到&lt;code&gt;&amp;lt;div id=&quot;app&quot;&amp;gt;...&amp;lt;/div&amp;gt;&lt;/code&gt;这个元素；data属性指向Model，data: { message: &quot;hello, 盛开的太阳&quot; 表示我们的Model是一个对象。&lt;/p&gt;
&lt;p&gt;Vue.js有多种数据绑定的语法，最基础的形式是文本插值，使用一对大括号语法，在运行时{{ message }}会被数据对象的message属性替换，所以页面上会输出”&lt;strong&gt;hello, 盛开的太阳!&lt;/strong&gt;”。&lt;/p&gt;


&lt;p&gt;每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做生命周期钩子的函数，这给了用户在不同阶段添加自己的代码的机会。&lt;/p&gt;
&lt;p&gt;比如 &lt;a href=&quot;https://cn.vuejs.org/v2/api/#created&quot;&gt;&lt;code&gt;created&lt;/code&gt;&lt;/a&gt; 钩子可以用来在一个实例被创建之后执行代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
  data: {
    a: &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
  },
  &lt;span&gt;&lt;strong&gt;created&lt;/strong&gt;&lt;/span&gt;: function () {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; `this` 指向 vm 实例&lt;/span&gt;
    console.log(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a is: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt; + &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.a)
  }
})
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; =&amp;gt; &quot;a is: 1&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;也有一些其它的钩子，在实例生命周期的不同阶段被调用，如 &lt;a href=&quot;https://cn.vuejs.org/v2/api/#mounted&quot;&gt;&lt;code&gt;mounted&lt;/code&gt;&lt;/a&gt;、&lt;a href=&quot;https://cn.vuejs.org/v2/api/#updated&quot;&gt;&lt;code&gt;updated&lt;/code&gt;&lt;/a&gt; 和 &lt;a href=&quot;https://cn.vuejs.org/v2/api/#destroyed&quot;&gt;&lt;code&gt;destroyed&lt;/code&gt;&lt;/a&gt;。生命周期钩子的 &lt;code&gt;this&lt;/code&gt; 上下文指向调用它的 Vue 实例。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre readability=&quot;9&quot;&gt;
&lt;strong&gt;&lt;span&gt;注意:&lt;/span&gt;&lt;/strong&gt;&lt;p&gt;不要在选项 property 或回调上使用箭头函数，比如 &lt;br/&gt;　　created: () =&amp;gt; console.log(&lt;span&gt;this&lt;/span&gt;.a) 或 vm.$watch(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, newValue =&amp;gt; &lt;span&gt;this&lt;/span&gt;.myMethod())。&lt;br/&gt;因为箭头函数并没有 &lt;span&gt;this&lt;/span&gt;，&lt;span&gt;this&lt;/span&gt; 会作为变量一直向上级词法作用域查找，直至找到为止，经常导致 &lt;br/&gt;Uncaught TypeError: Cannot read property of undefined 或 &lt;br/&gt;Uncaught TypeError: &lt;span&gt;this&lt;/span&gt;.myMethod &lt;span&gt;is&lt;/span&gt; not a function 之类的错误。
&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;生命周期图示&quot;&gt;1. 生命周期图示&lt;/h2&gt;
&lt;p&gt;下图展示了实例的生命周期。你不需要立马弄明白所有的东西，不过随着你的不断学习和使用，它的参考价值会越来越高。 &lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1187916/202102/1187916-20210219061532116-1196518192.png&quot; width=&quot;600&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2&gt; 2. Vue生命周期函数&lt;/h2&gt;
&lt;p&gt;如上图, 常用的生命周期函数有: beforeCreate, created, beforeMount, mounted, beforeUpdate, updated, beforeDestory, destoryed, 这些钩子函数都是回调函数, 在vue生命周期执行过重,方便用户操作控制的入口&lt;/p&gt;


&lt;p&gt;我们知道了vue的生命周期了, 接下来看看vue的源码, 对vue的生命周期加深理解&lt;/p&gt;
&lt;p&gt;源码下载地址: https://github.com/vuejs/vue&lt;/p&gt;
&lt;p&gt;我们选择一个release版本. 下载代码到本地&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1187916/202102/1187916-20210219063113576-1738388427.png&quot; width=&quot;600&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;



&lt;p&gt; 下载好以后, 打开项目, 我们来看看项目结构.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1187916/202102/1187916-20210219063427352-1514436949.png&quot; width=&quot;800&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;



&lt;p&gt;刚开始, 我们不熟悉, 那么先猜测一下, 哪个是主要文件, 经验告诉我们, src里面的才是主目录, 在src中和核心目录是core. &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1187916/202102/1187916-20210219063516344-2115161360.png&quot; width=&quot;200&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 我们看到了index.js, 通常一个网站的入口是index.html, 而对应的js脚本就是index.js. 打开index.js&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;strong&gt;import Vue from './instance/index'&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;
import { initGlobalAPI } &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;./global-api/index&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
import { isServerRendering } &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;core/util/env&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
import { FunctionalRenderContext } &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;core/vdom/create-functional-component&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;

initGlobalAPI(Vue)

Object.defineProperty(Vue.prototype, &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;$isServer&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, {
  &lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;: isServerRendering
})

Object.defineProperty(Vue.prototype, &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;$ssrContext&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, {
  &lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt; () {
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; istanbul ignore next &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.$vnode &amp;amp;&amp;amp; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.$vnode.ssrContext
  }
})

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; expose FunctionalRenderContext for ssr runtime helper installation&lt;/span&gt;
Object.defineProperty(Vue, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;FunctionalRenderContext&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, {
  value: FunctionalRenderContext
})

Vue.version &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__VERSION__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&lt;strong&gt;

export default Vue&lt;/strong&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里面有两句非常重要的话, 第一句&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;strong&gt;export &lt;span&gt;default&lt;/span&gt; Vue&lt;/strong&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这句话表示export导出Vue, 我们new的就是这里导出的Vue. 我们看到index.js中没有主逻辑, 那主逻辑在哪里呢? 在第二句话里面: &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;strong&gt;import Vue &lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;./instance/index&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;/strong&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;导入了./instance/index中的文件. 我们来看看这个文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
import { initMixin } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;./init&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
import { stateMixin } &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;./state&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
import { renderMixin } &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;./render&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
import { eventsMixin } &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;./events&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
import { lifecycleMixin } &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;./lifecycle&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
import { warn } &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;../util/index&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&lt;strong&gt;

function Vue (options) {
  &lt;/strong&gt;&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (process.env.NODE_ENV !== &lt;span&gt;'&lt;/span&gt;&lt;span&gt;production&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &amp;amp;&amp;amp;
    !(&lt;span&gt;this&lt;/span&gt;&lt;span&gt; instanceof Vue)
  ) {
    warn(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Vue is a constructor and should be called with the `new` keyword&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
  }
  &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;._init(options)
}

&lt;strong&gt;initMixin(Vue)
stateMixin(Vue)
eventsMixin(Vue)
lifecycleMixin(Vue)
renderMixin(Vue)&lt;/strong&gt;

export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; Vue
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;首先, 我们看到定义了一个Vue对象, 在对象里面执行了很多操作, 初始化, 事件监听, 生命周期处理, 渲染等等. 这就是vue的整个流程. 我们进入到initMixin(Vue)初始化方法里面看一下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; @flow &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

import config &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;../config&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
import { initProxy } &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;./proxy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
import { initState } &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;./state&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
import { initRender } &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;./render&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
import { initEvents } &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;./events&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
import { mark, measure } &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;../util/perf&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
import { initLifecycle, callHook } &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;./lifecycle&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
import { initProvide, initInjections } &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;./inject&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
import { extend, mergeOptions, formatComponentName } &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;../util/index&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;

let uid &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;

export function initMixin (Vue: Class&lt;/span&gt;&amp;lt;Component&amp;gt;&lt;span&gt;) {
  Vue.prototype._init &lt;/span&gt;= function (options?&lt;span&gt;: Object) {
    &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; vm: Component = &lt;span&gt;this&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; a uid&lt;/span&gt;
    vm._uid = uid++&lt;span&gt;

    let startTag, endTag
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; istanbul ignore if &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (process.env.NODE_ENV !== &lt;span&gt;'&lt;/span&gt;&lt;span&gt;production&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &amp;amp;&amp;amp; config.performance &amp;amp;&amp;amp;&lt;span&gt; mark) {
      startTag &lt;/span&gt;= `vue-perf-&lt;span&gt;start:${vm._uid}`
      endTag &lt;/span&gt;= `vue-perf-&lt;span&gt;end:${vm._uid}`
      mark(startTag)
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; a flag to avoid this being observed&lt;/span&gt;
    vm._isVue = &lt;span&gt;true&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; merge options&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (options &amp;amp;&amp;amp;&lt;span&gt; options._isComponent) {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; optimize internal component instantiation
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; since dynamic options merging is pretty slow, and none of the
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; internal component options needs special treatment.&lt;/span&gt;
&lt;span&gt;      initInternalComponent(vm, options)
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
      vm.$options &lt;/span&gt;=&lt;span&gt; mergeOptions(
        resolveConstructorOptions(vm.constructor),
        options &lt;/span&gt;||&lt;span&gt; {},
        vm
      )
    }
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; istanbul ignore else &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (process.env.NODE_ENV !== &lt;span&gt;'&lt;/span&gt;&lt;span&gt;production&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) {
      initProxy(vm)
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
      vm._renderProxy &lt;/span&gt;=&lt;span&gt; vm
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; expose real self&lt;/span&gt;
    vm._self =&lt;span&gt; vm
    &lt;strong&gt;&lt;span&gt;initLifecycle(vm)
    initEvents(vm)
    initRender(vm)
    &lt;span&gt;callHook(vm, &lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;'beforeCreate')&lt;/span&gt;
    initInjections(vm) // resolve injections before data/props
    initState(vm)
    initProvide(vm) // resolve provide after data/props
    callHook(vm, 'created')

   ......&lt;/span&gt;&lt;/strong&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;初始化的时候又做了一系列的操作. 注意在方法创建之前有一个钩子函数&lt;strong&gt;callHook(vm,&lt;/strong&gt; &lt;strong&gt;'beforeCreate'), &lt;/strong&gt; 方法创建之后, 有一个&lt;strong&gt;callHook(vm, 'created')函数&lt;/strong&gt;, 这里可以和上面的生命周期图对比研究, 就能更加熟悉Vue的声明周期了&lt;/p&gt;

</description>
<pubDate>Thu, 18 Feb 2021 21:34:00 +0000</pubDate>
<dc:creator>盛开的太阳</dc:creator>
<og:description>今天开始系统学习vue前端框架. 我是有前端基础的, 刚工作那会, 哪里分那么清楚啊, 前后端我都得做, 所以, css, js, jquery, bootstrap都会点, 还系统学过ext, 哈哈</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ITPower/p/14410471.html</dc:identifier>
</item>
<item>
<title>教你玩转CSS border(边框) - 水香木鱼</title>
<link>http://www.cnblogs.com/chenchunbo/p/14410305.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenchunbo/p/14410305.html</guid>
<description>&lt;h2 id=&quot;边框样式&quot;&gt;边框样式&lt;/h2&gt;
&lt;p&gt;边框样式属性指定要显示什么样的边界。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;border-style&lt;/strong&gt;属性用来定义边框的样式&lt;/p&gt;
&lt;hr/&gt;
&lt;h2 id=&quot;border-style-值&quot;&gt;&lt;span&gt;border-style的值&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;代码演示：&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;en&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;viewport&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;width=device-width, initial-scale=1.0&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;http-equiv&lt;/span&gt;&lt;span&gt;=&quot;X-UA-Compatible&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;ie=edge&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;水香木鱼的博客&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        p.none &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
            border-style&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; none&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;&lt;span&gt;

        p.dotted &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
            border-style&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; dotted&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;&lt;span&gt;

        p.dashed &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
            border-style&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; dashed&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;&lt;span&gt;

        p.solid &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
            border-style&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; solid&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;&lt;span&gt;

        p.double &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
            border-style&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; double&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;&lt;span&gt;

        p.groove &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
            border-style&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; groove&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;&lt;span&gt;

        p.ridge &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
            border-style&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; ridge&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;&lt;span&gt;

        p.inset &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
            border-style&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; inset&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;&lt;span&gt;

        p.outset &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
            border-style&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; outset&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;&lt;span&gt;

        p.hidden &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
            border-style&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; hidden&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;


&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;none&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;无边框。&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;dotted&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;虚线边框。&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;dashed&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;虚线边框。&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;solid&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;实线边框。&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;double&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;双边框。&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;groove&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 凹槽边框。&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;ridge&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;垄状边框。&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;inset&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;嵌入边框。&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;outset&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;外凸边框。&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;hidden&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;隐藏边框。&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;效果演示：&lt;/h3&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/2173503/202102/2173503-20210217235226125-2021531580.png&quot; width=&quot;964&quot; height=&quot;300&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;hr/&gt;
&lt;h2 id=&quot;边框宽度&quot;&gt;边框宽度&lt;/h2&gt;
&lt;p&gt;您可以通过 &lt;code&gt;border-width&lt;/code&gt; 属性为边框指定宽度。&lt;/p&gt;
&lt;p&gt;为边框指定宽度有两种方法：可以指定长度值，比如 2px 或 0.1em(单位为 px, pt, cm, em 等)，或者使用 3 个关键字之一，它们分别是 thick 、medium（默认值） 和 thin。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;CSS 没有定义 3 个关键字的具体宽度，所以一个用户可能把 thick 、medium 和 thin 分别设置为等于 5px、3px 和 2px，而另一个用户则分别设置为 3px、2px 和 1px。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    p.one &lt;/span&gt;{&lt;span&gt;
        border-style&lt;/span&gt;:&lt;span&gt;solid&lt;/span&gt;;&lt;span&gt;
        border-width&lt;/span&gt;:&lt;span&gt;5px&lt;/span&gt;;
    }&lt;span&gt;
    p.two &lt;/span&gt;{&lt;span&gt;
        border-style&lt;/span&gt;:&lt;span&gt;solid&lt;/span&gt;;&lt;span&gt;
        border-width&lt;/span&gt;:&lt;span&gt;medium&lt;/span&gt;;
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;边框颜色&quot;&gt;边框颜色&lt;/h2&gt;
&lt;p&gt;border-color属性用于设置边框的颜色。可以设置的颜色：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;name - 指定颜色的名称，如 “red”&lt;/li&gt;
&lt;li&gt;RGB - 指定 RGB 值, 如 “rgb(255,0,0)”&lt;/li&gt;
&lt;li&gt;Hex - 指定16进制值, 如 “#ff0000”&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;您还可以设置边框的颜色为”transparent”。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; border-color单独使用是不起作用的，必须得先使用border-style来设置边框样式。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    p.one&lt;/span&gt;{&lt;span&gt;
        border-style&lt;/span&gt;:&lt;span&gt;solid&lt;/span&gt;;&lt;span&gt;
        border-color&lt;/span&gt;:&lt;span&gt;red&lt;/span&gt;;
    }&lt;span&gt;
    p.two &lt;/span&gt;{&lt;span&gt;
        border-style&lt;/span&gt;:&lt;span&gt;solid&lt;/span&gt;;&lt;span&gt;
        border-color&lt;/span&gt;:&lt;span&gt;#98bf21&lt;/span&gt;;
    }
 
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;边框-单独设置各边&quot;&gt;边框-单独设置各边&lt;/h2&gt;
&lt;p&gt;在CSS中，可以指定不同的侧面不同的边框：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    p &lt;/span&gt;{&lt;span&gt;
        border-top-style&lt;/span&gt;:&lt;span&gt;dotted&lt;/span&gt;;&lt;span&gt;
        border-right-style&lt;/span&gt;:&lt;span&gt;solid&lt;/span&gt;;&lt;span&gt;
        border-bottom-style&lt;/span&gt;:&lt;span&gt;dotted&lt;/span&gt;;&lt;span&gt;
        border-left-style&lt;/span&gt;:&lt;span&gt;solid&lt;/span&gt;;
    }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;上面的例子也可以设置一个单一属性：&lt;/p&gt;
&lt;h2 id=&quot;实例&quot;&gt;实例&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    border-style:dotted solid;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;border-style属性可以有1-4个值：&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;border-style:dotted solid double dashed;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;上边框是 dotted&lt;/li&gt;
&lt;li&gt;右边框是 solid&lt;/li&gt;
&lt;li&gt;底边框是 double&lt;/li&gt;
&lt;li&gt;左边框是 dashed&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;border-style:dotted solid double;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;上边框是 dotted&lt;/li&gt;
&lt;li&gt;左、右边框是 solid&lt;/li&gt;
&lt;li&gt;底边框是 double&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;border-style:dotted solid;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;上、底边框是 dotted&lt;/li&gt;
&lt;li&gt;右、左边框是 solid&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;border-style:dotted;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;四面边框是 dotted&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;上面的例子用了border-style。然而，它也可以和border-width 、 border-color一起使用。&lt;/p&gt;
&lt;hr/&gt;
&lt;h2 id=&quot;边框-简写属性&quot;&gt;边框-简写属性&lt;/h2&gt;
&lt;p&gt;上面的例子用了很多属性来设置边框。&lt;/p&gt;
&lt;p&gt;你也可以在一个属性中设置边框。&lt;/p&gt;
&lt;p&gt;你可以在”border”属性中设置：&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;border-width&lt;/li&gt;
&lt;li&gt;border-style (required)&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;border-color&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    border:5px solid red;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;hr/&gt;&lt;h2&gt; &lt;/h2&gt;
&lt;h2 id=&quot;css-边框属性&quot;&gt;CSS 边框属性&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2173503/202102/2173503-20210218000103281-1271356559.png&quot; width=&quot;787&quot; height=&quot;800&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 18 Feb 2021 19:14:00 +0000</pubDate>
<dc:creator>水香木鱼</dc:creator>
<og:description>边框样式 边框样式属性指定要显示什么样的边界。 border-style属性用来定义边框的样式 border-style的值 代码演示： &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/chenchunbo/p/14410305.html</dc:identifier>
</item>
<item>
<title>Echarts制作一张全球疫情图 - 春日宴</title>
<link>http://www.cnblogs.com/Lin1031/p/14414215.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Lin1031/p/14414215.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;效果图：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1535189/202102/1535189-20210219030652645-1531462348.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;一、获取全球疫情数据&quot;&gt;一、获取全球疫情数据&lt;/h2&gt;
&lt;h3 id=&quot;1获取api&quot;&gt;1)获取API&lt;/h3&gt;
&lt;p&gt;使用用友提供的&lt;a href=&quot;https://api.yonyoucloud.com/apilink/tempServicePages/260492aa-6dbd-49f6-b82a-8a463b73ac33_true.html?isPreview=true&quot; target=&quot;_blank&quot;&gt;新冠肺炎实时数据&lt;/a&gt;，登录注册之后可以免费使用。&lt;/p&gt;
&lt;h3 id=&quot;2）点击用户信息&quot;&gt;2）点击用户信息&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1535189/202102/1535189-20210218235607677-1949949960.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里的AIPCODE，复制并保存，用于后续的使用。&lt;/p&gt;
&lt;h3 id=&quot;3）api的使用&quot;&gt;3）API的使用&lt;/h3&gt;
&lt;p&gt;用友有提供一个 eclipse 的使用说明。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1535189/202102/1535189-20210218235710600-632247923.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;本文采用 IDEA 搭建 Maven 进行使用&lt;/p&gt;
&lt;h4 id=&quot;1-首先配置-maven-环境&quot;&gt;1. 首先配置 maven 环境&lt;/h4&gt;
&lt;p&gt;可以参考 &lt;a href=&quot;https://www.runoob.com/maven/maven-setup.html&quot; target=&quot;_blank&quot;&gt;Maven 环境配置&lt;/a&gt;，按照配置很简单，记住按照路径即可，方便后续使用&lt;/p&gt;
&lt;h4 id=&quot;2-使用-idea-新建一个-maven-项目&quot;&gt;2. 使用 IDEA 新建一个 Maven 项目&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1535189/202102/1535189-20210219000111768-114169110.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1535189/202102/1535189-20210219000226915-154514703.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1535189/202102/1535189-20210219000258361-881794730.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;3-在-setting-里更改maven的设置&quot;&gt;3. 在 setting 里更改maven的设置&lt;/h4&gt;
&lt;p&gt;选为更改下载的 maven 的路径，可能需要安装什么，等待他安装完成即可。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1535189/202102/1535189-20210219000630355-1695138656.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;4-打开project-structure&quot;&gt;4. 打开Project Structure&lt;/h4&gt;
&lt;p&gt;更改为本地的JDK，否则可能会提示版本问题。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1535189/202102/1535189-20210219000853628-105869754.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1535189/202102/1535189-20210219000935748-1020605713.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1535189/202102/1535189-20210219002320399-328078776.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;5-引入-jar-包&quot;&gt;5. 引入 Jar 包&lt;/h4&gt;
&lt;p&gt;在 pom.xml 中引入,点击Import Changes，等待安装完成&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.json&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;json&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;20180130&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1535189/202102/1535189-20210219001333678-907082855.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;6-新建一个-java-class&quot;&gt;6. 新建一个 JAVA Class&lt;/h4&gt;
&lt;p&gt;将用友提供的疫情全球代码复制进去。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1535189/202102/1535189-20210219001544636-798543138.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;7-更改apicode，运行&quot;&gt;7. 更改APICODE，运行&lt;/h4&gt;
&lt;p&gt;这里更改为刚刚保存的 API 码即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1535189/202102/1535189-20210219002010524-652468645.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果代码有错误提示，根据 IDEA 提供的更改建议进行更改。就一处错误。然后运行。&lt;/p&gt;
&lt;p&gt;成功获取到数据。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1535189/202102/1535189-20210219002342613-1792193718.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果出现版本错误，再按刚刚的步骤看一下哪个版本没有更改。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1535189/202102/1535189-20210219001731891-908490963.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;8-编写一个函数，将获取到的数据进行保存。&quot;&gt;8. 编写一个函数，将获取到的数据进行保存。&lt;/h4&gt;
&lt;p&gt;在getRequest函数中进行调用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1535189/202102/1535189-20210219002637378-851704150.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再次运行，就会发现获得了一个 Cov2019.json 文件&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private static void saveDataToFile(String data) {
        BufferedWriter writer = null;
        File file = new File(&quot;cov2019.json&quot;);
        //如果文件不存在，则新建一个
        if(!file.exists()){
            try {
                file.createNewFile();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        //写入
        try {
            writer = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(file,false), &quot;UTF-8&quot;));
            writer.write(data);
        } catch (IOException e) {
            e.printStackTrace();
        }finally {
            try {
                if(writer != null){
                    writer.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        System.out.println(&quot;文件写入成功！&quot;);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1535189/202102/1535189-20210219002745160-1828719183.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;二、数据处理&quot;&gt;二、数据处理&lt;/h2&gt;
&lt;p&gt;数据处理使用 PyCharm 进行。&lt;/p&gt;
&lt;h3 id=&quot;1-新建一个项目&quot;&gt;1. 新建一个项目&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1535189/202102/1535189-20210219003002031-1796025436.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;2-搭建一个环境&quot;&gt;2. 搭建一个环境&lt;/h3&gt;
&lt;p&gt;更改 python 的环境&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1535189/202102/1535189-20210219003111081-1500985412.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;3-新建一个-py-文件，并观察-cov2019json-文件&quot;&gt;3. 新建一个 py 文件，并观察 cov2019.json 文件&lt;/h3&gt;
&lt;p&gt;json 文件主要是层级递进的关系，我们需要的是 country 部分&lt;br/&gt;所以我们可以使用 Json 库进行处理。&lt;br/&gt;在处理的过程中会发现，每个洲其实都有一个 country 部分&lt;br/&gt;所以我们需要先去除每个洲，然后再提取美国国家数据。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1535189/202102/1535189-20210219003729282-1809319446.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;4-编写代码&quot;&gt;4. 编写代码&lt;/h3&gt;
&lt;p&gt;处理成方便后续可视化的格式。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# -*- coding = utf-8 -*-
# @Time :2021-02-19 0:31
# @Author: LinJH
# @File : DealData.py
# @Software: PyCharm

import json


def DealFile():
    with open('../GetData/cov2019.json', 'r', encoding=&quot;utf-8&quot;)as f:
        data = json.load(f)
        # print(data)
        DealDate(data)


# 初步提取数据
def DealDate(data):
    data = data[&quot;data&quot;][&quot;continent&quot;]
    Asia = data[0][&quot;country&quot;]
    Europe = data[1][&quot;country&quot;]
    NorthAmerica = data[2][&quot;country&quot;]
    SouthAmerica = data[3][&quot;country&quot;]
    Africa = data[4][&quot;country&quot;]
    Oceania = data[5][&quot;country&quot;]
    country = Asia + Europe + NorthAmerica + SouthAmerica + Africa + Oceania

    DealCountry(country)


# 数据格式进行处理
def DealCountry(country):
    for i in range(len(country)):
        name = country[i][&quot;provinceName&quot;]
        value = country[i][&quot;confirmedCount&quot;]
        ChangeDate(name, value)


countryList = []

LList=[]
def ChangeDate(name, value):
    # 读取国家名称中文转英文数据
    with open('countryC2E.json', 'r', encoding='utf-8') as f:
        c2e = json.load(f)

    try:
        countryDict = {}
        countryDict[&quot;name&quot;] = c2e[name]
        countryDict[&quot;value&quot;] = value
        countryList.append(countryDict)

    except:
        LList.append(name)

# 数据保存
def SaveDate(country):
    # DataDict={}
    # DataDict[&quot;data&quot;] = country
    with open(&quot;cov2019_deal.json&quot;, 'w', encoding=&quot;utf-8&quot;) as f:
        json.dump(country, f)
        print(&quot;保存成功！&quot;)


if __name__ == '__main__':
    DealFile()
    SaveDate(countryList)

&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;三、数据可视化&quot;&gt;三、数据可视化&lt;/h2&gt;
&lt;h3 id=&quot;1）使用模板，直接引入&quot;&gt;1）使用&lt;a href=&quot;https://echarts.apache.org/examples/zh/editor.html?c=map-world-dataRange&quot; target=&quot;_blank&quot;&gt;模板&lt;/a&gt;，直接引入&lt;/h3&gt;
&lt;p&gt;没做动态加载的，单一视图。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1535189/202102/1535189-20210219025510737-1987775311.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;四、源码地址&quot;&gt;四、源码地址&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/Lin1031/cov2019-world-map&quot; target=&quot;_blank&quot;&gt;GitHub&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/CodeSama346623/Bilibili346623&quot; target=&quot;_blank&quot;&gt;GitHub&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://echarts.apache.org/examples/zh/editor.html?c=map-world-dataRange&quot; target=&quot;_blank&quot;&gt;World Population (2010)&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.imooc.com/qadetail/267849&quot; target=&quot;_blank&quot;&gt;怎么引入org.json的依赖？&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 18 Feb 2021 19:01:00 +0000</pubDate>
<dc:creator>春日宴</dc:creator>
<og:description>前言 效果图： 一、获取全球疫情数据 1)获取API 使用用友提供的新冠肺炎实时数据，登录注册之后可以免费使用。 2）点击用户信息 这里的AIPCODE，复制并保存，用于后续的使用。 3）API的使用</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Lin1031/p/14414215.html</dc:identifier>
</item>
<item>
<title>持续集成(二) - 上善若水~小辉</title>
<link>http://www.cnblogs.com/strugger-0316/p/14414298.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/strugger-0316/p/14414298.html</guid>
<description>[unable to retrieve full-text content]Maven Maven是一个项目管理和综合工具。Maven提供给开发人员构建一个完整的生命周期框架。 开发团队可以自动完成该项目的基础设施建设，Maven使用标准的目录结构和默认构建生命周期。 Apache的开源项目主要服务于JAVA平台的构建、依赖管理、项目管理。 Project Object M</description>
<pubDate>Thu, 18 Feb 2021 17:49:00 +0000</pubDate>
<dc:creator>上善若水~小辉</dc:creator>
<dc:language>zh-CN</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://account.cnblogs.com:443/signin?ReturnUrl=https%3A%2F%2Fwww.cnblogs.com%2Fstrugger-0316%2Fp%2F14414298.html</dc:identifier>
</item>
</channel>
</rss>