<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>MVC + EFCore 项目实战 - 数仓管理系统2- 搭建基本框架配置EFCore - 编程小纸条</title>
<link>http://www.cnblogs.com/miro/p/13258843.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/miro/p/13258843.html</guid>
<description>&lt;p&gt;&lt;span&gt;本次课程就正式进入开发部分。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先我们先搭建项目框架，还是和之前渐进式风格保持一致，除必备组件外，尽量使用原生功能以方便大家理解。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;开发工具：vs 2019 或以上&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;数据库：SQL SERVER 2017 或以上&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;其他需要用到的我们在项目过程中再提。&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;1、打开VS 2019，Create a new project , 选择ASP.NET Core Web Application&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/101211/202007/101211-20200707084412856-1451705045.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、填入项目名称相关信息 DWMS&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/101211/202007/101211-20200707084413446-2103197838.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;3、选择MVC模板，点击 Create 完成项目新建。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/101211/202007/101211-20200707084413738-64317528.png&quot; alt=&quot;&quot; width=&quot;590&quot; height=&quot;409&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/101211/202007/101211-20200707084414086-88833428.png&quot; alt=&quot;&quot; width=&quot;592&quot; height=&quot;322&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;项目名 DWMS 代表 data warehouse management system ，即数据仓库管理系统。&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;1、右键 Views/Shared 文件夹，依次选择 Add / New Item 菜单&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/101211/202007/101211-20200707084414480-1529735098.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;2、选择 Razor Layout, 填入模板页名称 _LayoutAdmin&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/101211/202007/101211-20200707084414819-1635230383.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们对生成的文件稍作修改，增加 css 和 js 的添加入口，如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/101211/202007/101211-20200707084415225-1073468191.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;1、安装并配置好EF &lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;进入 NuGet Package Manager，安装如下两个包：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Microsoft.EntityFrameworkCore&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Microsoft.EntityFrameworkCore.SqlServer&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/101211/202007/101211-20200707084415492-73136162.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;2、新建Model用来测试EF&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;打开文件夹 Models，增加类SysUser&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/101211/202007/101211-20200707084415731-15826194.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;默认EF生成的表名会是复数，我们在类的开头指定表名为单数：[Table(&quot;SysUser&quot;)]&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;3、新建操作Context的类 &lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;新建文件夹Data，用来放置EF相关的类。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在文件夹内新建 DefaultContext, 继承于 DbContext, 用来管理实体和数据库中表的联系。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/101211/202007/101211-20200707084415980-1678373074.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;4、将 context 增加至 DI并生成数据库&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;ASP.NET Core默认实现了DI，服务在启动时进行注册，通过构造函数的方式获取。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.1 打开Startup.cs, 注册context, 如下方框处&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/101211/202007/101211-20200707084416228-1159586682.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;&lt;span&gt;4.2 下面来增加配套的 DefaultConnection。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;打开appsettings.json文件，增加配置节：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/101211/202007/101211-20200707084416457-1484129195.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.3 添加测试数据，生成数据库结构&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Data文件夹中新建静态类DbInitializer，新增方法Initialize 用来初始化数据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/101211/202007/101211-20200707084416813-1536524402.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;修改下 Program类中的Main方法，调用我们新建的Initialize 方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/101211/202007/101211-20200707084417140-569051185.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/101211/202007/101211-20200707084417451-187766984.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;CTRL+F5运行一下网站，可以看到数据库中已有数据。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/101211/202007/101211-20200707084417780-680907171.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;&lt;span&gt;本次教程我们搭建了项目DWMS(data warehouse management system)的基本框架。 包括新建项目、新建管理员模板页、配置EFCore.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其中 EFCore 3.x 和 之前的EFCore 2.x 的配置风格有些许差异，放在Program的Main函数里（之前2.0一般放在Startup中的Config方法里），职责分离的更加清晰。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;祝大家学习进步 ：）&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 07 Jul 2020 00:44:00 +0000</pubDate>
<dc:creator>编程小纸条</dc:creator>
<og:description>本次课程就正式进入开发部分。 首先我们先搭建项目框架，还是和之前渐进式风格保持一致，除必备组件外，尽量使用原生功能以方便大家理解。 开发工具：vs 2019 或以上 数据库：SQL SERVER 20</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/miro/p/13258843.html</dc:identifier>
</item>
<item>
<title>GitHub 热点速览 Vol.27：程序员的自我救赎——GitHub 摸鱼 - 削微寒</title>
<link>http://www.cnblogs.com/xueweihan/p/13257750.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xueweihan/p/13257750.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202007/759200-20200706214200411-2120427919.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;作者：HelloGitHub-&lt;strong&gt;小鱼干&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;摘要：都知道 VSCode 有各种摸鱼小插件，边听云音乐、边在 IDE 斗地主，再来一个 NBA 直播，怎一个美滋滋了得。作为 VSCode 的同门，GitHub 在摸鱼上也不输于这个后辈，除了在命令行斗地主的 Ratel，还有让你操作安卓手机在电脑上假借调试之名实则玩手机的 scrcpy，还有连 VSCode 可能都不能满足你的听取云音乐下架歌曲，Unlock-netease-cloud-music 都能满足你。在本周的热点主题中，经典街机游戏将通过 Python 代码与你见面…&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以下内容摘录自微博&lt;a href=&quot;https://www.weibo.com/hellogithub/&quot;&gt;@HelloGitHub&lt;/a&gt; 的 GitHub Trending 及 Hacker News 热帖（简称 HN 热帖），选项标准：&lt;code&gt;新发布&lt;/code&gt; | &lt;code&gt;实用&lt;/code&gt; | &lt;code&gt;有趣&lt;/code&gt;，根据项目 release 时间分类，发布时间不超过 7 day 的项目会标注 &lt;code&gt;New&lt;/code&gt;，无该标志则说明项目 release 超过一周。由于本文篇幅有限，还有部分项目未能在本文展示，望周知 🌝&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;本文目录
&lt;ul&gt;&lt;li&gt;
&lt;ol&gt;&lt;li&gt;本周特推&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;1.1 听歌，听下架的歌：Unlock-netease-cloud-music&lt;/li&gt;
&lt;li&gt;1.2 WTF Resume：resume-builder&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;GitHub Trending 周榜&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;2.1 密码分析：Pwdb-Public&lt;/li&gt;
&lt;li&gt;2.2 操控你的安卓设备：scrcpy&lt;/li&gt;
&lt;li&gt;2.3 知识管理：foam&lt;/li&gt;
&lt;li&gt;2.4 SSH 小管家：Secretive&lt;/li&gt;
&lt;li&gt;2.5 响应式开发必马：responsively-app&lt;/li&gt;
&lt;li&gt;2.6 巨硬字体：Cascadia Code&lt;/li&gt;
&lt;li&gt;2.7 中文版：OnJava8&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;本期热点#游戏吧#主题的主力军&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;3.1 游戏大全：Free Python Games&lt;/li&gt;
&lt;li&gt;3.2 命令行斗地主：Ratel&lt;/li&gt;
&lt;li&gt;3.3 沙盒游戏：Mindustry&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;推荐阅读&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202007/759200-20200706214216463-1697923578.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-本周特推&quot;&gt;1. 本周特推&lt;/h2&gt;
&lt;h3 id=&quot;11-听歌，听下架的歌：unlock-netease-cloud-music&quot;&gt;1.1 听歌，听下架的歌：Unlock-netease-cloud-music&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：1100+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Unlock-netease-cloud-music 可解锁网易云音乐客户端变灰歌曲。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/meng-chuan/Unlock-netease-cloud-music&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202007/759200-20200706214231772-722099730.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;12-wtf-resume：resume-builder&quot;&gt;1.2 WTF Resume：resume-builder&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：低于 100&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;【HN 热帖】resume-builder 是一个简洁、免费的简历制作器。特性：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;免注册使用；&lt;/li&gt;
&lt;li&gt;实时设计（拖拽）&lt;/li&gt;
&lt;li&gt;支持另存为 json，方便以后上传使用&lt;/li&gt;
&lt;li&gt;支持导出 pdf&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/sramezani/resume-builder&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202007/759200-20200706214245086-1375977955.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;2-github-trending-周榜&quot;&gt;2. GitHub Trending 周榜&lt;/h2&gt;
&lt;h3 id=&quot;21-密码分析：pwdb-public&quot;&gt;2.1 密码分析：Pwdb-Public&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：1700+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;New&lt;/code&gt; Pwdb-Public 是一个从互联网上泄露的 10 亿个证书中提取的所有数据的集合，新一代密码批量分析工具。一些有意思的结果：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;最常用的密码是123456。它大致涵盖 0.722% 了所有密码&lt;/li&gt;
&lt;li&gt;平均密码长度为 9.4822 个字符&lt;/li&gt;
&lt;li&gt;里面 257,669,588 被筛选为损坏的数据或测试账户&lt;/li&gt;
&lt;li&gt;最常见的 1000 个密码涵盖 6.607% 所有密码&lt;/li&gt;
&lt;li&gt;对于最常见的一百万个密码，命中率为 36.28 %，而对于最常见的一千万个密码，命中率为 54.00%。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/FlameOfIgnis/Pwdb-Public&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;22-操控你的安卓设备：scrcpy&quot;&gt;2.2 操控你的安卓设备：scrcpy&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：700+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;scrcpy 是一个可在 PC 端控制安卓设备的小工具，可在 GNU / Linux / Windows 和 macOS 上运行。scrcpy 可在 PC 和安卓设备间互通剪贴板、用电脑键盘打字、传输文件、安装程序、截图、录屏等等功能。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/Genymobile/scrcpy&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202007/759200-20200706214302864-390627529.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;23-知识管理：foam&quot;&gt;2.3 知识管理：foam&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：4400+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;New&lt;/code&gt;Pfoam 是一个受 Roam Research 启发的个人笔记与知识管理思维导图系统，基于 VSCode + MarkDown + GitHub。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/foambubble/foam&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202007/759200-20200706214313554-1982965883.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;24-ssh-小管家：secretive&quot;&gt;2.4 SSH 小管家：Secretive&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：1350+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Secretive 是一款可在 Secure Enclave 存储和管理 SSH 密钥的应用。受到 sekey 启发，但用 Swift 重写，没有外部依赖，还支持强大的访问控制，例如 Touch ID / Apple Watch 身份验证。此外，每次访问密钥时 Secretive 会给你发通知。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/maxgoedjen/secretive&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202007/759200-20200706214325915-1378385178.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;25-响应式开发必马：responsively-app&quot;&gt;2.5 响应式开发必马：responsively-app&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：1500+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Responsively App 是用 Electron 搭建的浏览器，方便进行响应式开发。特性&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;跨设备镜像用户交互&lt;/li&gt;
&lt;li&gt;预览布局可根据需求定制&lt;/li&gt;
&lt;li&gt;预览中所有设备的一个便捷元素检查器。&lt;/li&gt;
&lt;li&gt;30 多种内置设备配置文件，并提供添加自定义设备的选项&lt;/li&gt;
&lt;li&gt;一键截图所有设备&lt;/li&gt;
&lt;li&gt;支持热加载&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/manojVivek/responsively-app&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202007/759200-20200706214341364-1165034005.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;26-巨硬字体：cascadia-code&quot;&gt;2.6 巨硬字体：Cascadia Code&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：500+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Cascadia Code 是微软 Build 2019 开发者大会上宣布面向开发人员的等宽字体，Cascadia Code 为命令行和代码编辑器提供了全新的体验，并且它还支持编程连字（Programming Ligatures），就是在编写代码的时候，可以组合字符创建新的字形，这对于代码的可读性和呈现后的用户友好度都是一种很好的机制，同时这也增强了 Windows Terminal 的现代外观。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/microsoft/cascadia-code&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202007/759200-20200706214356857-1300751908.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;27-中文版：onjava8&quot;&gt;2.7 中文版：OnJava8&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：900+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;OnJava8 是 Bruce Eckel，撰写的《Java 编程思想》第五版的中文版，与《Java 编程思想》第四版基于 JAVA 5 版本不同，《On Java 8》 基于 JAVA 8 版本。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/LingCoder/OnJava8&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202007/759200-20200706214408068-23096133.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;3-本期热点游戏吧主题的主力军&quot;&gt;3. 本期热点#游戏吧#主题的主力军&lt;/h2&gt;
&lt;p&gt;什么？你还在 GitHub 学技术 [手动狗头] 这里有一本 GitHub 上班摸鱼指南，Let's enjoy the game~&lt;/p&gt;
&lt;h3 id=&quot;31-游戏大全：free-python-games&quot;&gt;3.1 游戏大全：Free Python Games&lt;/h3&gt;
&lt;p&gt;Free Python Games 收录了 Python 写的各种小游戏，有童年回忆贪吃蛇、吃豆人、Flappy-bird 等等。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/grantjenks/free-python-games&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202007/759200-20200706214421638-1405023319.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;32-命令行斗地主：ratel&quot;&gt;3.2 命令行斗地主：Ratel&lt;/h3&gt;
&lt;p&gt;Ratel 是一个命令行可联网的斗地主游戏。Ratel 分客户端和服务端，你可以让小伙伴们的客户端都连接你的服务器进行游戏，也可以直接连接作者的公网服务器进行游戏。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/ainilili/ratel&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202007/759200-20200706214437163-1852293164.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;33-沙盒游戏：mindustry&quot;&gt;3.3 沙盒游戏：Mindustry&lt;/h3&gt;
&lt;p&gt;Mindustry 是一款用 Java 编写的沙盒塔防游戏。玩家需要建造精密的传送带供应链，提供炮塔弹药，生产建筑材料，保护建筑并抵御敌人。也可以在跨平台多人合作游戏中与朋友一起战斗，或组队进行 PVP 比赛。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/Anuken/Mindustry&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202007/759200-20200706214448142-2058201729.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;推荐阅读&quot;&gt;推荐阅读&lt;/h2&gt;
&lt;p&gt;以上为 2020 年第 27 个工作周的 GitHub Trending 🎉如果你 Pick 其他好玩、实用的 GitHub 项目，记得来 &lt;a href=&quot;https://github.com/521xueweihan/HelloGitHub&quot;&gt;HelloGitHub&lt;/a&gt; issue 区和我们分享下哟 🌝&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;HelloGitHub 交流群现已全面开放，添加微信号：HelloGitHub 为好友入群，可同前端、Java、Go 等各界大佬谈笑风生、切磋技术~&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202007/759200-20200706214622307-1765002891.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Tue, 07 Jul 2020 00:36:00 +0000</pubDate>
<dc:creator>削微寒</dc:creator>
<og:description>作者：HelloGitHub-小鱼干 摘要：都知道 VSCode 有各种摸鱼小插件，边听云音乐、边在 IDE 斗地主，再来一个 NBA 直播，怎一个美滋滋了得。作为 VSCode 的同门，GitHub</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xueweihan/p/13257750.html</dc:identifier>
</item>
<item>
<title>个人总结：高年级有约-老菜谈新零售 - 血夜之末</title>
<link>http://www.cnblogs.com/Tiancheng-Duan/p/13253283.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Tiancheng-Duan/p/13253283.html</guid>
<description>&lt;h2 id=&quot;一，前言&quot;&gt;一，前言&lt;/h2&gt;
&lt;p&gt;前不久在高年级有约，有幸听到老菜亲自讲解新零售，并有了一些自己的体会与总结。&lt;br/&gt;这次就已经公开的部分（老菜在“&lt;strong&gt;2020联商网大会&lt;/strong&gt;”演讲中已经公开的部分），谈谈自己的总结。&lt;br/&gt;如果有不足，不正确的地方，欢迎指出，共同探讨。&lt;br/&gt;另外如果文中由于失误，出现&lt;strong&gt;敏感信息&lt;/strong&gt;，也欢迎指出。&lt;br/&gt;&lt;strong&gt;文中内容仅代表个人观点，不代表任何组织观点。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;二，新零售的基石-供应链&quot;&gt;二，新零售的基石-供应链&lt;/h2&gt;
&lt;p&gt;老菜在解读盒马新零售1.0，以及接下来新零售2.0时，多次提及供应链。而盒马供应链，作为整个盒马物流的大动脉，也确实非常优秀。&lt;/p&gt;
&lt;h3 id=&quot;特点&quot;&gt;特点&lt;/h3&gt;
&lt;p&gt;个人的理解其最大的特点，其在保质（冷藏，保鲜等），保速（云超次日达）的前提下，成本还比较低。平均来看，其成本为&lt;em&gt;/单，而天猫超市的成本为&lt;/em&gt;/单，京东的成本为&lt;em&gt;/单（没有在外部找到对应数据，所以只能写&lt;/em&gt;号）。结论是盒马的运费成本少一大截。所以，盒马的云超可以直接免运费，而猫超于京东就有各类限制。&lt;/p&gt;
&lt;h3 id=&quot;原因&quot;&gt;原因&lt;/h3&gt;
&lt;p&gt;那么为什么盒马供应链的成本更低呢？如果成本更低，为什么阿里其他BU（如天猫）不采用这种供应链模式呢？这也是在讲座后的同事交流中，一位同事询问我的问题。&lt;br/&gt;&lt;strong&gt;站在商业角度来看，是因为盒马云超面向的消费场景与猫超等不同。&lt;/strong&gt;&lt;br/&gt;举个例子，我在京东买一个电钻，往往是因为我遇到一个场景需要电钻，但手头没有，这种需求突发性更强一些。而我在盒马云超买菜什么的，往往都是有计划的，如明后天吃什么，买回来放冰箱，这种需求计划性较强。并且前一种场景较为少见一些，毕竟突发性的事情多了，人也承受不住。。。而后一种场景则是比较日常的，毕竟人都是要吃东西的。总结一下，京东的消费场景更具突发性，较为少见，而云超的消费场景计划性较强，较为常见。而高频行为，每次都收取运费的话，那么对于消费者而言，成本也是一笔不可忽视的支出。&lt;br/&gt;所以，盒马认为，盒马云超的物流应该抛弃半日达+运费，而选择次日达+免运费。这也是为什么老菜当时拒绝直接将云超挂在猫超下的原因。&lt;br/&gt;站在技术角度来看，则是较为深厚的技术积累。由于我并不是物流域的成员，目前也与他们没有工作上的交流。所以我的看法，是阿里在物流（菜鸟）上的积累，阿里自身深厚的技术积累，以及老菜自己对物流的认识（毕竟&lt;a href=&quot;https://wiki.mbalib.com/wiki/%E4%BE%AF%E6%AF%258&quot;&gt;京东物流的基础架构就是他一手搭起来的&lt;/a&gt;）。&lt;/p&gt;
&lt;h3 id=&quot;约束&quot;&gt;约束&lt;/h3&gt;
&lt;p&gt;而盒马供应链，一方面在所需场景下有着较低的成本，另一方面却也面临着所有供应链共同的瓶颈-产业链上游的约束。盒马在快速扩张的同时，需要保证产品的质量（不禁让人想起盒马快速扩张时，保证员工质量）。这就涉及到供应商，乃至产地的问题。这也就与阿里的数字农业自然挂上钩了。这块内容放在后面，我们先谈谈盒马接下来有关规模的认识。&lt;/p&gt;
&lt;h2 id=&quot;三，新零售的成长-规模&quot;&gt;三，新零售的成长-规模&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://baijiahao.baidu.com/s?id=1589197348406823368&amp;amp;wfr=spider&amp;amp;for=pc&quot;&gt;零售的历史&lt;/a&gt;，就是在物流限制下，不断提升规模。&lt;br/&gt;过去，大家对盒马扩大规模的认识，就是盒马又在哪个城市开了一家盒马生鲜店。诚然，盒马在过去的规模扩大分为两个方面：线上和线下。线上就推出各类活动，并没有很大力（这是由于线上定位的问题）。而比较明显的是线下，不断开盒马鲜生店，至今已经有几百家了。&lt;br/&gt;但是在现有条件较为成熟的情况下（目测商业模式还算靠谱，盒马鲜生店这一业态也还算OK），盒马在规模这个角度上提出了“覆盖率”。说简单点，就是盒马要渗透用户的方方面面。&lt;/p&gt;
&lt;h3 id=&quot;覆盖率&quot;&gt;覆盖率&lt;/h3&gt;
&lt;p&gt;总的来说，覆盖率分为两个部分：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;全渠道：大力开始多业态的探索。这个也一直是盒马内部的重头戏。&lt;/li&gt;
&lt;li&gt;全域：尝试线上各个平台的内容推广。首先是支付宝等阿里域，紧接着是抖音等。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;上述两个部分就已经从线上（Virtual）与线下（Reality）全面覆盖用户生活了。&lt;br/&gt;接下来，来详细谈谈。&lt;/p&gt;
&lt;h3 id=&quot;全渠道&quot;&gt;全渠道&lt;/h3&gt;
&lt;p&gt;首先是全渠道，就是&lt;strong&gt;通过多业态来尝试，并覆盖现有多元化的线下消费场景&lt;/strong&gt;。如&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;盒马鲜生店（已有）：针对大卖场所属消费场景&lt;/li&gt;
&lt;li&gt;盒马mini店（已有8家）：针对社区店（老夫妻店）所属的消费场景&lt;/li&gt;
&lt;li&gt;盒马X会员店（预计今年上海）：针对sam，costco等会员店所属的消费场景&lt;/li&gt;
&lt;li&gt;盒马C2（Cash &amp;amp; Carry）：针对Matro（麦德龙），美菜等批发店所属的消费场景&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;还有针对早餐场景的F2（盒小马），针对周末场景的盒马里等。&lt;/p&gt;
&lt;p&gt;多业态的积极探索可以带来以下的优势：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;流量导入，用户线下场景的覆盖，带来更多用户流量&lt;/li&gt;
&lt;li&gt;技术提升，多业态带来的业务复杂性，会帮助阿里锻炼出一帮杰出的技术人才&lt;/li&gt;
&lt;li&gt;基础设施，多元化的需求，也对供应链等基础设施提出更高的要求&lt;/li&gt;
&lt;li&gt;商业探索，帮助盒马继续深入摸索新零售，为新零售行业提供更多宝贵经验&lt;/li&gt;
&lt;li&gt;社会贡献，为社会提供更多商业模式的探索历程。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;不同业态的需求，决定了业态发展顺序的选择。如通过会员店，实现系统技术多业态的成熟度的突破，以及底层供应链的提升（提高供应量）。只有在底层供应链有够支撑能力后，才可以进行C2业态的探索。&lt;/p&gt;
&lt;h4 id=&quot;会员店&quot;&gt;会员店&lt;/h4&gt;
&lt;p&gt;在这里，同事也提出了一个新看法，那就是会员店的价值在哪里？依据归纳法，让我们来看看现有会员店-sam与costco。&lt;br/&gt;会员店作为一种公认的业态，其背后的商业模式不是三言两语可以说清楚的，这里只简单说三点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;会员店的收益并不来自商品利润，其利润全部让利给会员，收益来自会员费。&lt;/li&gt;
&lt;li&gt;会员店的消费场景-会员购买倾向于量大价优。从而带来会员店的成本降低，如人力成本（商品上货架可以直接叉车），商品成本（规模带来了面对上游时更高的议价权）等。&lt;/li&gt;
&lt;li&gt;随着生活水平提高，中国社会的中产阶级人数上升，拥有足够消费水平的人足够了。并且国内人们也渐渐接受了会员消费的理念。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;盒马X会员店的价值就在于两方面：以往会员店的价值，作为新业态对于盒马的价值。这不再重复上述两个观点。&lt;/p&gt;
&lt;h3 id=&quot;全域&quot;&gt;全域&lt;/h3&gt;
&lt;p&gt;至于全域，简单说就是在线上各个平台，进行推广。盒马内部是通过社群活动，推广活动，盒马云直播等，进行推广。而外部则是通过阿里域（支付宝，天猫等），外部平台（抖音-网红产品等）进行推广。这里就不再深入了。&lt;/p&gt;
&lt;h2 id=&quot;四，盒马与数字农业&quot;&gt;四，盒马与数字农业&lt;/h2&gt;
&lt;p&gt;阿里的数字农业，是大环境（产业互联网）的产物之一。而盒马这次打算勾连两者，一方面实现盒马链路成本的降低，另一方面实现数字农业的落地。&lt;/p&gt;
&lt;h3 id=&quot;价值&quot;&gt;价值&lt;/h3&gt;
&lt;p&gt;以往零售，或者说销售的上游就是工厂/产地-&amp;gt;供应商-&amp;gt;供应链执行等（全链路，后面找机会介绍）。但是由于上游缺乏足够的统筹，所以存在大量的价值浪费。举个例子，由于去年萝卜卖得好，今年大部分产地都在种萝卜。这就导致了萝卜的价格非常低廉，而去年较为充足的白菜，结果由于产量不足，价格飙高。&lt;br/&gt;这里需要明确一点，&lt;strong&gt;市场供应关系，虽然改变了最终价格，但是产品的本身价值并没有改变。&lt;/strong&gt; 站在消费者端，价格的提高并没有改变当时的产量，产品依旧紧缺。只不过消费者通过价格“挤”掉了其他消费者。所以&lt;strong&gt;在当前周期内，生产者和消费者其实都是不满意的。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;统筹&quot;&gt;统筹&lt;/h3&gt;
&lt;p&gt;如果通过阿里经济体，或其他手段实现了当前产地的全局统筹，那么完全可以按照以往消费数据等，明确今年哪些产地种什么。进而获取全局（空间）最大价值。&lt;strong&gt;对于生产者和消费者而言，也会获得全局（时间）最优，从而避免了大量价值浪费。&lt;/strong&gt;&lt;br/&gt;再举个更简单的例子，整齐划一的军队，总比散兵游勇强。这里不仅仅是单体战斗力的缘故，更重要的是统筹协作能力。&lt;br/&gt;以往信息化做的只是一个部门，一个企业，部分产业链的统筹规划。如阿里这样的巨头，以往也只是做到部分产业链的统筹规划，这也是互联网上半场的特色。而下半场就需要虚实结合，进军产业互联网，从而产生更大的价值。&lt;strong&gt;当一个人，或一个组织（无论是企业，或者政府等）对社会产生价值时，社会一定会回馈他。产生的价值越大，社会的回馈也就越大。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当然，正如淘宝，自己并不作生意，只是为商家提供一个高效的平台。盒马也不打算侵占供应商的市场，而是提供有效平台，帮助供应商更快，更好，更有效地实现价值。&lt;/p&gt;
&lt;p&gt;数字农业还有更多重点可以挖掘，在这篇文章中，就不再赘述了，避免喧宾夺主了。&lt;/p&gt;
&lt;p&gt;就如阿里的使命-让天下没有难做的生意。从淘宝，到盒马，再到数字农业，阿里正在践行它的使命。&lt;/p&gt;
&lt;h2 id=&quot;五，总结&quot;&gt;五，总结&lt;/h2&gt;
&lt;p&gt;供应链作为整个业务的底座，必须高效，低成本，并有着更高的供应能力。&lt;br/&gt;全域与全渠道（多业态）作为商业模式的体现与应用，提供了有效的覆盖率。&lt;br/&gt;而数字农业作为集团战略布局，将会与盒马相得益彰。&lt;/p&gt;
&lt;p&gt;上述只是我自己的一点感受。毕竟&lt;strong&gt;就像冰山一样，我们能看到的往往只是露出水面的一小部分&lt;/strong&gt;。&lt;br/&gt;就像我之前提到的，自己经历过，总结出来的东西与别人直接背出来的总结，是真的不一样的。我们看到的只是前辈们的结论，而这些结论下面都是满满的经历与思考，是我们无法获得与体会的。&lt;/p&gt;
&lt;p&gt;个人感觉最近工作上的运气很不错。工位就在部门Boss边上，经常可以听到Boss讲解业务。有事儿没事儿，可以听到大Boss过来讲解战役拆解。最近还现场听老菜讲解新零售，就是坐的位置有点太靠前了，周边一帮高p大佬。。。&lt;/p&gt;
&lt;p&gt;如果大家对这类商业思考的博客感兴趣，那之后就多写写。如果不感兴趣的话，那就多写写技术吧。&lt;br/&gt;毕竟除非是纯技术路线，否则大家都是需要对商业有一定认识的。&lt;/p&gt;
&lt;p&gt;愿与诸君共进步。&lt;/p&gt;
&lt;h2 id=&quot;六，附录&quot;&gt;六，附录&lt;/h2&gt;
&lt;h3 id=&quot;参考：&quot;&gt;参考：&lt;/h3&gt;
</description>
<pubDate>Tue, 07 Jul 2020 00:32:00 +0000</pubDate>
<dc:creator>血夜之末</dc:creator>
<og:description>个人总结：高年级有约-老菜谈新零售 一，前言 前不久在高年级有约，有幸听到老菜亲自讲解新零售，并有了一些自己的体会与总结。 这次就已经公开的部分（老菜在“2020联商网大会”演讲中已经公开的部分），谈</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Tiancheng-Duan/p/13253283.html</dc:identifier>
</item>
<item>
<title>什么是流处理 - 独孤风</title>
<link>http://www.cnblogs.com/tree1123/p/13258813.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tree1123/p/13258813.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1089984/202007/1089984-20200707082922133-1774407716.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;流处理正变得像数据处理一样流行。流处理已经超出了其原来的实时数据处理的范畴，它正在成为一种提供数据处理（包括批处理），实时应用乃至分布式事务的新方法的技术。&lt;/p&gt;
&lt;h2 id=&quot;1、什么是流处理？&quot;&gt;1、什么是流处理？&lt;/h2&gt;
&lt;p&gt;流处理是不断合并新数据以计算结果的动作。在流处理中，输入数据不受限制，并且没有预定的开始或结束。它只是形成一系列事件，这些事件到达流处理系统，例如信用卡交易，网站点击或来自物联网设备的传感器读数。&lt;/p&gt;
&lt;p&gt;流是一种数据分发技术，其中数据生产者将数据记录写入有序数据流，数据使用者可以从中按相同顺序读取数据。这是一个简单的数据流图，说明了数据生产者，数据流和数据使用者。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1089984/202007/1089984-20200707082929348-36775814.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;每个数据流产品都对使用案例和要支持的处理技术进行了一系列假设。这些假设导致了某些设计选择，这些选择影响可以使用它们实现的流处理行为的类型。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;来自维基百科；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;流处理是一种计算机编程范例，等效于数据流编程，事件流处理和反应式编程，它使某些应用程序可以更轻松地利用有限形式的并行处理。&lt;br/&gt;流处理是一项强大的技术，可以扫描来自传感器，信用卡刷卡，点击流和其他输入的大量数据，并几乎即时找到可行的见解。例如，流处理可以检测到包含数百万合法购买的流中的单个欺诈性交易，充当推荐引擎来确定特定客户在实际购物时要显示什么广告或促销，或者计算出最佳价格以用于只需几秒钟即可完成汽车服务。&lt;/p&gt;
&lt;p&gt;术语“流处理”是指数据以某些外部系统或多个外部系统产生的事件的连续“流”形式进入处理引擎，并且处理引擎的运行速度如此之快，以至于所有决策都无需停止数据流和首先存储信息。&lt;/p&gt;
&lt;h2 id=&quot;2、典型用例&quot;&gt;2、典型用例&lt;/h2&gt;
&lt;p&gt;流处理正在迅速获得普及并在各种业务领域中找到应用程序。随着证券交易所从场内交易转向电子交易，它在金融行业的首次使用得到了证实。如今，在几乎每个行业中，无论是通过人工活动，机器数据还是传感器数据生成流数据的任何地方，它都变得有意义。假设它起飞了，那么物联网将增加数据的数量，种类和速度，从而导致流处理技术的应用程序急剧增加。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;流处理可以解决业务问题的一些用例包括：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;网络监控&lt;/li&gt;
&lt;li&gt;情报和监视&lt;/li&gt;
&lt;li&gt;风险管理&lt;/li&gt;
&lt;li&gt;电子商务&lt;/li&gt;
&lt;li&gt;欺诈识别&lt;/li&gt;
&lt;li&gt;智能订单路由&lt;/li&gt;
&lt;li&gt;交易成本分析&lt;/li&gt;
&lt;li&gt;定价与分析&lt;/li&gt;
&lt;li&gt;市场数据管理&lt;/li&gt;
&lt;li&gt;算法交易&lt;/li&gt;
&lt;li&gt;数据仓库扩充&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1089984/202007/1089984-20200707082937864-2089596128.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;3、流处理和hadoop&quot;&gt;3、&lt;strong&gt;流处理和Hadoop&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;大数据架构包含用于实时分析的流处理，以及用于存储各种数据和长时间运行的计算的Hadoop。&lt;/p&gt;
&lt;p&gt;Hadoop最初是从MapReduce开始的，后者提供批处理，其中查询耗时数小时，数分钟或最多数秒钟。对于大数据量的复杂转换和计算，这将是非常有用的。但是，对于临时数据探索和实时分析而言，它并不是很好。但是，多家供应商已经进行了改进，并为Hadoop添加了功能，使其不仅具有批处理框架的功能。&lt;/p&gt;
&lt;p&gt;DWH，Hadoop和流处理彼此很好地互补。因此，在大数据时代，集成层显得尤为重要，因为您必须组合越来越多的不同接收器和源。&lt;/p&gt;
&lt;p&gt;自2016年以来，出现了一个称为Streaming SQL的新想法。我们将一种语言称为“流SQL”，该语言使用户能够编写类似于查询的SQL来查询流数据。现在，几乎所有流处理器都支持流SQL。&lt;/p&gt;
&lt;h2 id=&quot;4、选择流处理框架&quot;&gt;4、选择流处理框架&lt;/h2&gt;
&lt;p&gt;数据流产品有很多，很难知道从哪里开始研究它们，哪些产品可以做什么等等。&lt;/p&gt;
&lt;p&gt;在做出决定之前，必须进行典型的评估过程（长清单，短清单，概念证明）。&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;用于流分析的流处理编程语言&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;可视化开发和调试，而不是编码&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;实时分析&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;监控和警报&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;支持容错和高度优化的性能&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;产品成熟度&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;考虑一下项目需要上述哪些功能。此外，在做出选择之前，必须评估使用框架的成本，生产率，减少的工作量以及产品上市时间。&lt;/p&gt;
&lt;p&gt;我们正处于一个数据的时代。在此过程中，时间至关重要，而速度将决定赢家和输家。&lt;/p&gt;
&lt;p&gt;当必须快速连续处理数据（即必须实时计算和迅速反应）时，需要进行流处理。这个要求越来越多地出现在各个领域。市场上已经有许多不同的框架和产品。&lt;/p&gt;
&lt;p&gt;许多用例需要快速，实时的决策。尽管可以使用数据库或批处理来实现它们，但是使用这种技术只会越来越复杂。相反，流提供了一种更自然的模型来考虑，捕获和实现这些实时流用例。流SQL提供了一种简单而强大的语言来对流用例进行编程。&lt;/p&gt;
&lt;p&gt;现实情况是，&lt;strong&gt;大多数数据的价值会随着时间而下降&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;更多Flink，Kafka等相关技术博文，科技资讯，欢迎关注实时流式计算 公众号后台回复 “电子书” 下载300页Flink实战电子书&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1089984/202005/1089984-20200511083216576-1437389309.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 07 Jul 2020 00:32:00 +0000</pubDate>
<dc:creator>独孤风</dc:creator>
<og:description>流处理正变得像数据处理一样流行。流处理已经超出了其原来的实时数据处理的范畴，它正在成为一种提供数据处理（包括批处理），实时应用乃至分布式事务的新方法的技术。 1、什么是流处理？ 流处理是不断合并新数据</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tree1123/p/13258813.html</dc:identifier>
</item>
<item>
<title>小书MybatisPlus第2篇-条件构造器的应用及总结 - 字母哥博客</title>
<link>http://www.cnblogs.com/zimug/p/13258807.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zimug/p/13258807.html</guid>
<description>&lt;h2 id=&quot;一、条件构造器wrapper&quot;&gt;一、条件构造器Wrapper&lt;/h2&gt;
&lt;p&gt;Mybatis Plus为我们提供了如下的一些条件构造器，我们可以利用它们实现查询条件、删除条件、更新条件的构造。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1815316/202007/1815316-20200707082934262-700692462.png&quot; alt=&quot;mybatis-plus-wrapper&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;条件构造器用于给如下的Mapper方法传参，通常情况下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;updateWrapper用于给update方法传条件参数&lt;/li&gt;
&lt;li&gt;queryWrapper用于给delete和select方法传参&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public interface BaseMapper&amp;lt;T&amp;gt; extends Mapper&amp;lt;T&amp;gt; {

  int delete(@Param(&quot;ew&quot;) Wrapper&amp;lt;T&amp;gt; wrapper);

  int update(@Param(&quot;et&quot;) T entity, @Param(&quot;ew&quot;) Wrapper&amp;lt;T&amp;gt; updateWrapper);

  T selectOne(@Param(&quot;ew&quot;) Wrapper&amp;lt;T&amp;gt; queryWrapper);

  Integer selectCount(@Param(&quot;ew&quot;) Wrapper&amp;lt;T&amp;gt; queryWrapper);

  List&amp;lt;T&amp;gt; selectList(@Param(&quot;ew&quot;) Wrapper&amp;lt;T&amp;gt; queryWrapper);

  List&amp;lt;Map&amp;lt;String, Object&amp;gt;&amp;gt; selectMaps(@Param(&quot;ew&quot;) Wrapper&amp;lt;T&amp;gt; queryWrapper);

  List&amp;lt;Object&amp;gt; selectObjs(@Param(&quot;ew&quot;) Wrapper&amp;lt;T&amp;gt; queryWrapper);

  IPage&amp;lt;T&amp;gt; selectPage(IPage&amp;lt;T&amp;gt; page, @Param(&quot;ew&quot;) Wrapper&amp;lt;T&amp;gt; queryWrapper);

  IPage&amp;lt;Map&amp;lt;String, Object&amp;gt;&amp;gt; selectMapsPage(IPage&amp;lt;T&amp;gt; page, @Param(&quot;ew&quot;) Wrapper&amp;lt;T&amp;gt; queryWrapper);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;举例一：like-条件构造&quot;&gt;举例一：like 条件构造&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;String name = &quot;字母&quot;;  //name不为空
String email = &quot;&quot;;   //email为空串
QueryWrapper&amp;lt;User&amp;gt; query = new QueryWrapper&amp;lt;&amp;gt;();
query.like(StringUtils.isNotEmpty(name), &quot;name&quot;, name)
      //因为email为空串，该条件未生效
     .like(StringUtils.isNotEmpty(email), &quot;email&quot;, email);    

List&amp;lt;User&amp;gt; list = userMapper.selectList(query);
list.forEach(System.out::println);
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;QueryWrapper是查询条件构造器，like是一种条件构造函数，还有很多的条件构造函数。请参考：&lt;a href=&quot;https://mp.baomidou.com/guide/wrapper.html#abstractwrapper&quot;&gt;条件构造器&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1815316/202007/1815316-20200707082934472-239920629.png&quot; alt=&quot;mybatis-plus-like&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;几乎所有的条件构造函数，都提供了condition参数实现动态SQL。也就是参数判断是否返回true，如果返回false，该条件不成立。如&lt;code&gt;email=“”&lt;/code&gt;，所以&lt;code&gt;.like(StringUtils.isNotEmpty(email), &quot;email&quot;, email);&lt;/code&gt; 的条件不成立。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;所以最终的执行SQL，如下(只有name LIKE条件，没有email LIKE 条件)：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;SELECT id,name,age,email,create_time 
FROM user 
WHERE name LIKE %字母%
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;举例二：alleq条件构造器&quot;&gt;举例二：allEq条件构造器&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;all表示所有&lt;/li&gt;
&lt;li&gt;Eq是equal的缩写表示相等关系&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;//构造条件
QueryWrapper&amp;lt;User&amp;gt; query = new QueryWrapper&amp;lt;&amp;gt;();
Map&amp;lt;String, Object&amp;gt; params = new HashMap&amp;lt;&amp;gt;();
params.put(&quot;name&quot;, &quot;字母哥&quot;);
params.put(&quot;age&quot;, 18);
params.put(&quot;email&quot;, null);

// query.allEq(params,false);
query.allEq((k, v) -&amp;gt; !k.equals(&quot;name&quot;), params, false);
List&amp;lt;User&amp;gt; list = userMapper.selectList(query);
list.forEach(System.out::println);
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;第一个参数是过滤器（可选参数），lambda表达式表示(k, v) -&amp;gt; !k.equals(&quot;name&quot;)，参数的Key不能是name，所以&lt;code&gt;params.put(&quot;name&quot;, &quot;字母哥&quot;);&lt;/code&gt;这个查询条件被过滤掉&lt;/li&gt;
&lt;li&gt;第二个参数表示传入所有的params查询参数&lt;/li&gt;
&lt;li&gt;第三个参数（可选参数），表示如果值为null是否按IS NULL查询，false则忽略null列的查询，所以&lt;code&gt;params.put(&quot;email&quot;, null);&lt;/code&gt;这个查询条件被过滤掉&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;最终执行的SQL如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SELECT id,name,age,email,create_time 
FROM user 
WHERE age = ?
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;更多构造器使用方法总结&quot;&gt;更多构造器使用方法总结&lt;/h3&gt;
&lt;p&gt;请参考：&lt;a href=&quot;https://mp.baomidou.com/guide/wrapper.html#abstractwrapper&quot;&gt;官方文档：条件构造器&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1815316/202007/1815316-20200707082934852-1096524643.png&quot; alt=&quot;mybatis-plus-wrapper-use&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;二、lambda条件构造器&quot;&gt;二、lambda条件构造器&lt;/h2&gt;
&lt;h3 id=&quot;举例一：&quot;&gt;举例一：&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;// LambdaQueryWrapper&amp;lt;User&amp;gt; lambdaQ = new QueryWrapper&amp;lt;User&amp;gt;().lambda();
// LambdaQueryWrapper&amp;lt;User&amp;gt; lambdaQ = new LambdaQueryWrapper&amp;lt;&amp;gt;();
LambdaQueryWrapper&amp;lt;User&amp;gt; lambdaQ = Wrappers.lambdaQuery();
lambdaQ.like(User::getName, &quot;字母&quot;)
       .lt(User::getAge, 18);
List&amp;lt;User&amp;gt; list = userMapper.selectList(lambdaQ);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;lambda条件构造器，最终执行SQL如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SELECT id,name,age,email,create_time
FROM user 
WHERE name LIKE %字母%
AND age &amp;lt; 18
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;举例二：&quot;&gt;举例二：&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;List&amp;lt;User&amp;gt; list = new LambdaQueryChainWrapper&amp;lt;User&amp;gt;(userMapper)
        .likeRight(User::getName, &quot;字母&quot;)
        .and(q -&amp;gt; q.lt(User::getAge, 40)
                  .or()
                  .isNotNull(User::getEmail)
        )
        .list();
list.forEach(System.out::println);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;lambda条件构造器，最终执行SQL如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SELECT id,name,age,email,create_time 
FROM user 
WHERE name LIKE '字母%'
AND ( age &amp;lt; 18 OR email IS NOT NULL )
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;欢迎关注我的博客，里面有很多精品合集&quot;&gt;欢迎关注我的博客，里面有很多精品合集&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;本文转载注明出处（必须带连接，不能只转文字）：&lt;a href=&quot;http://www.zimug.com&quot;&gt;字母哥博客&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;觉得对您有帮助的话，帮我点赞、分享！您的支持是我不竭的创作动力！&lt;/strong&gt; 。另外，笔者最近一段时间输出了如下的精品内容，期待您的关注。&lt;/p&gt;
</description>
<pubDate>Tue, 07 Jul 2020 00:30:00 +0000</pubDate>
<dc:creator>字母哥博客</dc:creator>
<og:description>一、条件构造器Wrapper Mybatis Plus为我们提供了如下的一些条件构造器，我们可以利用它们实现查询条件、删除条件、更新条件的构造。 条件构造器用于给如下的Mapper方法传参，通常情况下</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zimug/p/13258807.html</dc:identifier>
</item>
<item>
<title>用Serverless Kubernetes为.NET (Core)应用保驾护航 - Catcher8</title>
<link>http://www.cnblogs.com/catcher1994/p/13258780.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/catcher1994/p/13258780.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;容器化对现在(0202年)来说，已经不算是什么新东西了，老黄最近也在公司推动这一块的发展，有幸落地了几个项目，有.NET Core的，也有.NET Framework的。&lt;/p&gt;
&lt;p&gt;容器化现在主流的就是docker，说到docker，51%的概率是离不开kubernetes的。&lt;/p&gt;
&lt;p&gt;当容器数量不多的时候，可以考虑人工+半自动化的方式维护。&lt;/p&gt;
&lt;p&gt;当容器数量多了的话，不言而喻是需要引入容器编排的利器。&lt;/p&gt;
&lt;p&gt;这也算是一个渐进的过程吧。&lt;/p&gt;
&lt;p&gt;下面来看看基于 Serverless Kubernetes 的简单实践（不会介绍kubernetes的相关内容哈）。&lt;/p&gt;
&lt;h2 id=&quot;为什么选择-serverless-kubernetes&quot;&gt;为什么选择 Serverless Kubernetes&lt;/h2&gt;
&lt;p&gt;国内云产商基本都会有提供多个版本的Kubernetes让我们自己选择，有的公司可能能力强，一套打包带走。&lt;/p&gt;
&lt;p&gt;老黄这边选择的是 Serverless 版的，Serverless 可以说是比较火的一个概念，也可以说是真正的云原生所应该有的基本形态。&lt;/p&gt;
&lt;p&gt;当然老黄做出这个决定还有一个更重要的原因，不用自己维护服务器，可以更加专注自身的业务，只需要交付打包好的镜像即可。&lt;/p&gt;
&lt;p&gt;毕竟老黄公司没有运维，已经充当半个运维了，不想让自己累趴。。&lt;/p&gt;
&lt;p&gt;相信这个是大部分中小型公司一个比较ok的选择。&lt;/p&gt;
&lt;h2 id=&quot;准备镜像&quot;&gt;准备镜像&lt;/h2&gt;
&lt;p&gt;这里会写两个简单Web Api项目用来演示，一个.NET Core的，一个.NET Framework的。&lt;/p&gt;
&lt;p&gt;其中.NET Core会暴露给集群外部访问，.NET Framework只在集群内部访问，同时.NET Core还会调用.NET Framework的接口。&lt;/p&gt;
&lt;h3 id=&quot;net-framework&quot;&gt;.NET Framework&lt;/h3&gt;
&lt;p&gt;代码的话就是一个默认的ValuesController。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;public class ValuesController : ApiController
{
    // GET api/values
    public IEnumerable&amp;lt;string&amp;gt; Get()
    {
        return new string[] { &quot;value1&quot;, &quot;value2&quot;, &quot;nfx in k8s&quot; };
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;知道.NET Framework可以基于jexus跑在Linux下面的话，应该就知道要怎么打包制作镜像了。&lt;/p&gt;
&lt;p&gt;可以直接用 beginor 做好的镜像 beginor/jexus-x64:6.2.1.12。&lt;/p&gt;
&lt;p&gt;ps: 老黄这边是因为有不少项目需要用到图片，所以是自己单独弄了一个，加了libgdiplus 等一些必备的东西进去。&lt;/p&gt;
&lt;p&gt;先准备一个jexus的配置文件，这里用的是最简单的。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-conf&quot;&gt;port=80
root=/ /app
hosts=*
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后就是Dockerfile了&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 按需替换
FROM jexus-x64-img:6.1 AS base
# FROM beginor/jexus-x64:6.2.1.12 AS base

FROM mono:6.8 AS build
WORKDIR /src
COPY . .
# 还原nuget包
RUN nuget restore ServerlessNetApp.sln -Source https://api.nuget.org/v3/index.json
# 编译
RUN msbuild NfxApi/NfxApi.csproj /t:ReBuild /p:Configuration=Release /p:OutDir=/src/out /p:DeleteExistingFiles=True /p:DeployOnBuild=True /p:DeployDefaultTarget=WebPublish /p:WebPublishMethod=FileSystem

FROM base AS final
WORKDIR /app
# 把发布文件复制过来
COPY --from=build /src/out/_PublishedWebsites/NfxApi /app
COPY ./nfxweb /usr/jexus/siteconf/default
# 按需放开
# RUN sed -i 's/TLSv1.2/TLSv1.0/g' /etc/ssl/openssl.cnf
CMD [ &quot;jws&quot;, &quot;restart&quot;]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;build一下，打包出一个镜像&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker build -t nfxapi:v1 -f ./Dockerfile.nfx .
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/558945/202007/558945-20200707081908939-1377255465.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;还有重要的一步是，推送到镜像仓库，这样容器服务那边才可以拉取到。&lt;/p&gt;
&lt;h3 id=&quot;net-core&quot;&gt;.NET Core&lt;/h3&gt;
&lt;p&gt;代码也是很简单的，多了一个用HttpClient调用.NET Framework的接口就是了。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;[ApiController]
[Route(&quot;&quot;)]
public class GwController : ControllerBase
{
    private readonly IHttpClientFactory _factory;

    public GwController(IHttpClientFactory factory)
    {
        _factory = factory;
    }

    [HttpGet]
    public string Get()
    {
        return $&quot;gw-svc in k8s&quot;;
    }

    [HttpGet(&quot;svc&quot;)]
    public async Task&amp;lt;string&amp;gt; GetAsync()
    {
        var client = _factory.CreateClient();
        
        // 请求上面的.NET Framewore 项目
        // 用服务名的方式来处理服务发现
        var resp = await client.GetAsync(&quot;http://api-nfx-svc/api/values&quot;);
        resp.EnsureSuccessStatusCode();
        var res = await resp.Content.ReadAsStringAsync();

        return $&quot;ok - {res}&quot;;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面这个Dockerfile应该好熟悉的了&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;FROM mcr.microsoft.com/dotnet/core/aspnet:3.1-buster-slim AS base
WORKDIR /app
EXPOSE 80

FROM mcr.microsoft.com/dotnet/core/sdk:3.1-buster AS build
WORKDIR /src
COPY . .
RUN dotnet restore &quot;ServerlessNetApp.sln&quot;
WORKDIR /src/GwApi
RUN dotnet build &quot;GwApi.csproj&quot; -c Release -o /app/build

FROM build AS publish
RUN dotnet publish &quot;GwApi.csproj&quot; -c Release -o /app/publish

FROM base AS final
WORKDIR /app
COPY --from=publish /app/publish .

# 按需放开
#RUN sed -i 's/TLSv1.2/TLSv1.0/g' /etc/ssl/openssl.cnf
ENTRYPOINT [&quot;dotnet&quot;, &quot;GwApi.dll&quot;]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同样的要把它打包成镜像推送到镜像仓库。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker build -t ncapi:v1 -f ./Dockerfile.nc .
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/558945/202007/558945-20200707081926086-1856626926.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;运行起来&quot;&gt;运行起来&lt;/h2&gt;
&lt;p&gt;运行起来的话就是准备一些yml文件了，这里就贴出部分内容，具体的可以去github看。&lt;/p&gt;
&lt;p&gt;先来看看Deployment和Service。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yml&quot;&gt;apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  name: api-nfx-svc
  namespace: test
  labels:
    app: api-nfx-svc
spec:
  replicas: 1
  selector:
    matchLabels:
      app: api-nfx-svc
  strategy:
    rollingUpdate:
      maxSurge: 25%
      maxUnavailable: 25%
    type: RollingUpdate
  template:
    metadata:
      labels:
        app: api-nfx-svc
    spec:
      containers:
           image: &amp;gt;-
            镜像仓库地址/api-nfx:v1
           imagePullPolicy: IfNotPresent
           name: api-nfx
           resources:
             requests:
               cpu: 250m
               memory: 512Mi
# 省略部分 ...
---
apiVersion: v1
kind: Service
metadata:
  name: api-nfx-svc
  namespace: test
spec:
  ports:
  - port: 80
    protocol: TCP
    targetPort: 80
  selector:
    app: api-nfx-svc
  clusterIP: None
  sessionAffinity: None
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为要把.NET Core项目暴露出去，让外部访问，所以我们还要有一个Ingress。&lt;/p&gt;
&lt;p&gt;这里的话是基于阿里云的负载均衡，没有用ingress-nginx或ingress-traefik，不那么通用。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yml&quot;&gt;apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  annotations:
    # 指定 SLB 的Id
    service.beta.kubernetes.io/alicloud-loadbalancer-id: lb-xxxxxxx
  name: gw-ingress
  namespace: test
spec:
  rules:
    - host: ncgw.xxx.com
      http:
        paths:
          - backend:
              serviceName: api-nc-svc
              servicePort: 80
            path: /
status:
  loadBalancer:
    ingress:
      - ip: xxx.xxx.xxx.xxxx
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;依次把服务，路由跑起来。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;kubectl apply -f ../k8s/svc-nfx.yml

kubectl apply -f ../k8s/svc-nc.yml

kubectl apply -f ../k8s/ingress.yml
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后就可以看到在控制台的无状态中出现了我们刚才创建的两个应用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/558945/202007/558945-20200707081942310-896659966.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;ps: 老黄手抖，把应用名加了个-svc。。。&lt;/p&gt;
&lt;p&gt;服务还有路由&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/558945/202007/558945-20200707081954985-1783434880.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/558945/202007/558945-20200707082008459-1775527807.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后就是负载均衡&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/558945/202007/558945-20200707082016963-550821289.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后通过DNS解析一下域名到这个负载均衡的IP就可以了。&lt;/p&gt;
&lt;p&gt;这个时候应用已经跑起来了，现在是只暴露出了.NET Core的项目可以给外面的访问&lt;/p&gt;
&lt;p&gt;访问.NET Core项目的这个地址， &lt;a href=&quot;http://ncgw.domain.com/svc%EF%BC%8C&quot;&gt;http://ncgw.domain.com/svc，&lt;/a&gt; 就是通过SLB-&amp;gt;集群里的.NET Core-&amp;gt;集群里面.NET Framework&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/558945/202007/558945-20200707082025905-1153998332.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;一些额外细节&quot;&gt;一些额外细节&lt;/h2&gt;
&lt;p&gt;阿里云的serverless kubernetes是基于弹性容器实例(ECI)的，所以最终创建的pod是运行在ECI里面的。&lt;/p&gt;
&lt;p&gt;下面是ECI的一个列表。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/558945/202007/558945-20200707082034502-499059064.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对比一下两者的监控，&lt;/p&gt;
&lt;p&gt;先是.NET Core的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/558945/202007/558945-20200707082043334-1396208200.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再看看.NET Framwork的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/558945/202007/558945-20200707082049849-1623526114.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;.NET Framework的项目确实是占用的资源多一点。&lt;/p&gt;
&lt;p&gt;进去容器里面看看吧。&lt;/p&gt;
&lt;p&gt;进来容器里面，其实就是进入了集群环境了。&lt;/p&gt;
&lt;p&gt;我们同样可以通过服务名去访问到对应的服务了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/558945/202007/558945-20200707082102012-1027234996.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后一个就是服务发现是基于DNS的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/558945/202007/558945-20200707082108613-565794447.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;写在最后&quot;&gt;写在最后&lt;/h2&gt;
&lt;p&gt;serverless kubernetes用起来确实比较方便，省了很多不必要的麻烦，不过也是踩着坑过来的，坑踩多了，也就可以轻车熟路了。&lt;/p&gt;
&lt;p&gt;这里也只是演示了最简单的应用，还有水平伸缩(HPA)，日志，监控等一系列的内容，这里是没有提及到的。&lt;/p&gt;
&lt;p&gt;可能有人会问：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;为什么还有.NET Framework，不直接.NET Core？&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;很多老业务不是说动就能动的那么干脆，毕竟还有数据库的限制。。。&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;.NET Framework容器化有什么坑？&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;只要你代码没问题，可以在linux下面跑，那就没什么坑不坑的，要是用了一些不支持的特性，那谁也救不了的。&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;serverless kubernetes的其他问题&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;可以参靠各大云产商的官方文档和提工单咨询。&lt;/p&gt;
&lt;p&gt;最后就是这篇文章的代码可以在我的github查阅：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/catcherwong-archive/2020/tree/master/07/ServerlessNetApp&quot;&gt;ServerlessNetApp&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 07 Jul 2020 00:25:00 +0000</pubDate>
<dc:creator>Catcher8</dc:creator>
<og:description>用Serverless Kubernetes为.NET (Core)应用保驾护航</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/catcher1994/p/13258780.html</dc:identifier>
</item>
<item>
<title>手把手教你玩转Git - Ziph</title>
<link>http://www.cnblogs.com/ziph/p/13258788.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ziph/p/13258788.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;文章已托管到&lt;a href=&quot;https://github.com/Ziphtracks/JavaLearningmanual&quot;&gt;GitHub&lt;/a&gt;，大家可以去GitHub查看下载！并搜索关注微信公众号 码出Offer 领取各种学习资料！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;img src=&quot;https://img-blog.csdnimg.cn/2020070416330512.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDE3MDIyMQ==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; title=&quot;在这里插入图片描述&quot;/&gt;在这里插入图片描述

&lt;hr/&gt;&lt;h3 id=&quot;hgit-1&quot;&gt;&lt;span&gt;一、初识Git&lt;/span&gt;&lt;/h3&gt;
&lt;h4 id=&quot;h11git&quot;&gt;&lt;span&gt;1.1 Git的简史&lt;/span&gt;&lt;/h4&gt;
&lt;blockquote readability=&quot;18&quot;&gt;
&lt;p&gt;同生活中的许多伟大事物一样，Git 诞生于一个极富纷争大举创新的年代。&lt;/p&gt;
&lt;p&gt;Linus在1991年创建了开源的Linux，Linux 内核开源项目有着为数众多的参与者。 绝大多数的 Linux 内核维护工作都花在了提交补丁和保存归档的繁琐事务上（1991－2002年间）。 到 2002 年，整个项目组开始启用一个专有的分布式版本控制系统 BitKeeper 来管理和维护代码。 到了 2005 年，开发Samba的Andrew试图破解BitKeeper的协议，随后开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束，他们收回了 Linux 内核社区免费使用 BitKeeper 的权力。 这就迫使 Linux 开源社区（特别是 Linux 的缔造者 Linus Torvalds）基于使用 BitKeeper 时的经验教训，Linus仅仅使用了两周的时间用C写出了Git，开发出自己的版本系统，一个月之内，Linux系统的源码已经由Git管理了。 他们对新的系统制订了若干目标：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;速度&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;简单的设计&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;对非线性开发模式的强力支持（允许成千上万个并行开发的分支）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;完全分布式&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;有能力高效管理类似 Linux 内核一样的超大规模项目（速度和数据量）&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;自诞生于 2005 年以来，Git 日臻成熟完善，在高度易用的同时，仍然保留着初期设定的目标。 它的速度飞快，极其适合管理大项目，有着令人难以置信的非线性分支管理系统。Git迅速成为最流行的分布式版本控制系统，尤其是2008年，GitHub网站上线了，它为开源项目免费提供Git存储，无数开源项目开始迁移至GitHub。&lt;/p&gt;
&lt;p&gt;这时候是不是有很多小伙伴已经被Linus所惊讶到了呢？使用了两周时间用C写出了Git！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;h12git&quot;&gt;&lt;span&gt;1.2 Git到底是什么？&lt;/span&gt;&lt;/h4&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Git是一个开源的&lt;code&gt;分布式&lt;/code&gt;版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;h13&quot;&gt;&lt;span&gt;1.3 什么是版本控制系统？&lt;/span&gt;&lt;/h4&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;版本控制是指对软件开发过程中各种程序代码、配置文件及说明文档等文件变更的管理，是软件配置管理的核心思想之一。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;h131&quot;&gt;&lt;span&gt;1.3.1 版本控制系统的作用&lt;/span&gt;&lt;/h5&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;版本控制最主要的功能就是追踪文件的变更。它将什么时候、什么人更改了文件的什么内容等信息忠实地了记录下来。每一次文件的改变，文件的版本号都将增加。除了记录版本变更外，版本控制的另一个重要功能是并行开发。软件开发往往是多人协同作业，版本控制可以有效地解决版本的同步以及不同开发者之间的开发通信问题，提高协同开发的效率。并行开发中最常见的不同版本软件的错误(Bug)修正问题也可以通过版本控制中分支与合并的方法有效地解决。&lt;/p&gt;
&lt;p&gt;版本控制系统不仅为我们解决了实际开发中多人协同开发的问题，还提供了一些功能：&lt;strong&gt;检入检出控制&lt;/strong&gt; 、&lt;strong&gt;分支和合并&lt;/strong&gt; 、&lt;strong&gt;历史记录&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;检入检出控制&lt;/code&gt;：同步控制的实质是版本的检入检出控制。检入就是把软件配置项从用户的工作环境存入到软件配置库的过程，检出就是把软件配置项从软件配置库中取出的过程。检人是检出的逆过程。同步控制可用来确保由不同的人并发执行的修改不会产生混乱。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;分支与合并&lt;/code&gt;：版本分支（以一个已有分支的特定版本为起点，但是独立发展的版本序列）的人工方法就是从主版本——称为主干上拷贝一份，并做上标记。在实行了版本控制后，版本的分支也是一份拷贝，这时的拷贝过程和标记动作由版本控制系统完成。版本合并（来自不同分支的两个版本合并为其中一个分支的新版本）有两种途径，一是将版本A的内容附加到版本B中；另一种是合并版本A和版本B的内容，形成新的版本C。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;历史记录&lt;/code&gt;：版本的历史记录有助于对软件配置项进行审核，有助于追踪问题的来源。历史记录包括版本号、版本修改时间、版本修改者、版本修改描述等最基本的内容，还可以有其他一些辅助性内容，比如版本的文件大小和读写属性。 如果我们开发中的新版本发现不适合用户的体验，这时候就可以找到历史记录的响应版本号，回退到历史记录版本！&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h4 id=&quot;h14&quot;&gt;&lt;span&gt;1.4 版本控制系统的分类（了解）&lt;/span&gt;&lt;/h4&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;常见流行的分布式版本控制管理系统有Git&lt;/p&gt;
&lt;p&gt;常见流行的集中式版本控制管理系统有CVS、SVN&lt;/p&gt;
&lt;/blockquote&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;代&lt;/th&gt;
&lt;th&gt;网络&lt;/th&gt;
&lt;th&gt;操作&lt;/th&gt;
&lt;th&gt;并发性&lt;/th&gt;
&lt;th&gt;示例&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr&gt;&lt;td&gt;第一代&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;td&gt;仅一个文件&lt;/td&gt;
&lt;td&gt;锁定的&lt;/td&gt;
&lt;td&gt;RCS、SCCS&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;第二代&lt;/td&gt;
&lt;td&gt;集中式&lt;/td&gt;
&lt;td&gt;多文件&lt;/td&gt;
&lt;td&gt;提交之前合并&lt;/td&gt;
&lt;td&gt;CVS、SourceSafe、Subversion、Team Foundation Server&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;第三代&lt;/td&gt;
&lt;td&gt;分布式&lt;/td&gt;
&lt;td&gt;变更的集合&lt;/td&gt;
&lt;td&gt;合并之前提交&lt;/td&gt;
&lt;td&gt;Bazaar、Git、Mercurial&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4 id=&quot;h15&quot;&gt;&lt;span&gt;1.5 分布式与集中式&lt;/span&gt;&lt;/h4&gt;
&lt;h5 id=&quot;h151&quot;&gt;&lt;span&gt;1.5.1 集中式&lt;/span&gt;&lt;/h5&gt;
&lt;blockquote readability=&quot;19&quot;&gt;
&lt;p&gt;&lt;code&gt;集中式系统&lt;/code&gt;是指由一台或多台主计算机组成的中心节点，数据集中存储于这个中心节点中，并且整个系统的所有业务单元都集中部署在这个中心节点上，系统的所有功能均由其集中处理。&lt;/p&gt;
&lt;p&gt;简单提了集中式的概念，那集中式版本控制也是如此。如图，我们需要合并版本、更新版本时，是将各个版本上传服务器实现集中式合并！&lt;/p&gt;
&lt;p&gt;举例来说，集中式版本控制系统在公司中的使用，需要安装一个Server（服务器），然后各个使用版本控制系统的成员安装客户端，然后就是客户端连接服务器了，只有脸上这个服务器才能做版本控制，如果连不上那就不行了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;工作流程：&lt;/strong&gt; 比较熟悉的SVN是集中式的版本控制系统，每次在进行版本控制之前，需要先从中央服务器（服务端）取出最新的版本，然后开始工作，工作完后推送给中央服务器。此时的中央服务器就好比是一个图书馆，如果你要修改一本书，需要先从图书馆借出来，然后回到自己家修改，改完之后，需要在送回到图书馆。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;img src=&quot;https://gitee.com/Ziphtracks/Figurebed/raw/master/img/1/20200705123305.png&quot; alt=&quot;image-20200623145014939&quot; title=&quot;image-20200623145014939&quot;/&gt;image-20200623145014939
&lt;h5 id=&quot;h152&quot;&gt;&lt;span&gt;1.5.2 分布式&lt;/span&gt;&lt;/h5&gt;
&lt;blockquote readability=&quot;20&quot;&gt;
&lt;p&gt;&lt;code&gt;分布式&lt;/code&gt;系统是一个硬件或软件组件分布在不同的网络计算机上（本地化存储），彼此之间仅仅通过消息传递进行通信和协调的系统。&lt;/p&gt;
&lt;p&gt;又一次简单提了分布式的概念，那分布式版本控制更是如此。如图，我们需要合并版本、更新版本时，各台计算机都可以去实现彼此之间合并、更新，不再只依赖于一个中心节点，为我们开发提供了灵活与便捷！&lt;/p&gt;
&lt;p&gt;举例来说，分布式版本控制系统在公司中的使用与集中式不同，各个成员需要安装一个Git客户端，而各个成员之间可以随时随地的实现版本控制（比如：两个人合并后，再与第三个人合并或者小组与小组之间合并进行版本控制），不再依赖于必须连接服务器才能实现，那么我们实现了各个小组之间的灵活控制后，最终还是得落到了服务器的手中。我们需要把各个成员、小组之间的版本控制结果，上传到服务器（GitHub）中进行最终合并！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;工作流程：&lt;/strong&gt; 分布式版本控制系统是没有“中央服务器”，每个人的电脑上都是一个完整的版本库，工作的时候，不再需要联网。开始工作前，在客户端克隆出完整的代码仓库，然后就可以在家、在公交车等等随心所欲地修改代码并提交了，提交到本地电脑，等到有网的时候就可以一次性地将本地仓库推送到远端仓库（临时中心服务器）中，这样一来，每个人都可以独立进行改动资料，并且所有的改动都是在完整资料信息的环境下进行的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;img src=&quot;https://gitee.com/Ziphtracks/Figurebed/raw/master/img/1/20200705123309.png&quot; alt=&quot;image-20200623145500696&quot; title=&quot;image-20200623145500696&quot;/&gt;image-20200623145500696
&lt;h5 id=&quot;h153&quot;&gt;&lt;span&gt;1.5.3 分布式与集中式的区别&lt;/span&gt;&lt;/h5&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;code&gt;集中式&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;有一个单一的集中管理的服务器，保存所有文件的修订版本，所有代码库。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;对网络的依赖性强，必须联网才能工作，上传速度受网络状况、带宽影响。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;客户端记录文件内容的具体差异，每次记录有哪些文件做了更新，以及更新了哪些行的什么内容。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt; 中央服务器的单点故障。 如果中央服务器发生宕机，所有客户端将无法提交更新、还原、对比等，也就无法协同工作。如果磁盘发生故障，信息尚无备份，还会有数据丢失的风险。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;分布式&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;本地客户机进行操作，离线工作，快速。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;安全性高，每个人电脑里都有完整的版本库，如果电脑发生了更换复制一份就可以。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;原子性提交，提交不会被打断（git）。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;工作模式非常灵活（传统的集中式工作流 + 特殊工作流 + 特殊工作流和集中式工作流的组合）。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt; 缺少权限管理、命令复杂混乱&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;h16git&quot;&gt;&lt;span&gt;1.6 Git的下载安装&lt;/span&gt;&lt;/h4&gt;
&lt;blockquote readability=&quot;9.228855721393&quot;&gt;
&lt;p&gt;Git官网下载：&lt;a href=&quot;https://git-scm.com/&quot;&gt;https://git-scm.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;TortoiseGit官网下载：&lt;a href=&quot;https://tortoisegit.org/&quot;&gt;https://tortoisegit.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Git文档下载：&lt;a href=&quot;https://git-scm.com/book/zh/v2&quot;&gt;https://git-scm.com/book/zh/v2&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Git详细安装教程参考：&lt;a href=&quot;https://blog.csdn.net/weixin_44170221/article/details/104490352&quot;&gt;https://blog.csdn.net/weixin_44170221/article/details/104490352&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 关于Git的可视化工具下载与否取决于自己，笔者不建议下载可视化工具，因为我们要大量使用并熟练使用命令来操作Git！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Git客户端下载&lt;/th&gt;
&lt;th&gt;Git可视化工具下载&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;https://gitee.com/Ziphtracks/Figurebed/raw/master/img/1/20200705155738.png&quot; alt=&quot;image-20200705155736341&quot; title=&quot;image-20200705155736341&quot;/&gt;image-20200705155736341&lt;/td&gt;
&lt;td&gt;&lt;img src=&quot;https://gitee.com/Ziphtracks/Figurebed/raw/master/img/1/20200705160144.png&quot; alt=&quot;image-20200705160142347&quot; title=&quot;image-20200705160142347&quot;/&gt;image-20200705160142347&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4 id=&quot;h17&quot;&gt;&lt;span&gt;1.7 安装后测试&lt;/span&gt;&lt;/h4&gt;
&lt;h5 id=&quot;h171&quot;&gt;&lt;span&gt;1.7.1 打开命令的两种方式&lt;/span&gt;&lt;/h5&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;Wins+R输入cmd打开Dos命令窗口&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;右键单击打开Git Bash Here窗口&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;h5 id=&quot;h173git&quot;&gt;&lt;span&gt;1.7.3 命令查看Git版本号&lt;/span&gt;&lt;/h5&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;@查看Git版本号：&lt;/strong&gt; &lt;code&gt;git version&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;img src=&quot;https://gitee.com/Ziphtracks/Figurebed/raw/master/img/1/20200705123318.png&quot; alt=&quot;1588391682513&quot; title=&quot;1588391682513&quot;/&gt;1588391682513
&lt;h5 id=&quot;h172&quot;&gt;&lt;span&gt;1.7.2 提交版本控制人信息&lt;/span&gt;&lt;/h5&gt;
&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;安装后打开命令窗口，第一次需要提交我们的信息，这样可以让我们在版本控制的时候知道是谁做的这一次的版本控制。毕竟合并、更新代码等是一件很重要的事，万一缺失损坏了怎么办呢？是吧！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@提交信息版本操作者信息：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git config --global user.name &quot;Ziph&quot;&lt;/code&gt; 【用户名】&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git config --global user.email &quot;mylifes1110@163.com&quot;&lt;/code&gt; 【邮箱】&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@查看信息：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git config -l&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;img src=&quot;https://gitee.com/Ziphtracks/Figurebed/raw/master/img/1/20200705123326.png&quot; alt=&quot;1588392070384&quot; title=&quot;1588392070384&quot;/&gt;1588392070384
&lt;h3 id=&quot;h&quot;&gt;&lt;span&gt;二、仓库&lt;/span&gt;&lt;/h3&gt;
&lt;h4 id=&quot;h21&quot;&gt;&lt;span&gt;2.1 仓库是什么？&lt;/span&gt;&lt;/h4&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;版本库又名仓库，英文名&lt;strong&gt;repository&lt;/strong&gt;，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;h22&quot;&gt;&lt;span&gt;2.2 基本结构&lt;/span&gt;&lt;/h4&gt;
&lt;blockquote readability=&quot;16&quot;&gt;
&lt;p&gt;&lt;strong&gt;工作区：&lt;/strong&gt; 由我们使用命令&lt;code&gt;git init&lt;/code&gt;初始化的一个本地文件夹，而初始化后的这个文件夹就被称为工作区&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;暂存区：&lt;/strong&gt; 由我们使用命令&lt;code&gt;git add .&lt;/code&gt;把文件添加到暂存区，而被添加的位置则是工作区中.git目录中的index文件，所以这也叫做索引&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;版本库：&lt;/strong&gt; 工作区中会有一个隐藏的.git文件夹，这个不算是工作区，而是Git的版本库，版本库中记录了我们提交过的所有版本，也就是说版本库管理着我们的所有内容&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分支：&lt;/strong&gt; 版本库中包含若干分支，提交后的文件就会存储在分支中，而开始的时候版本库中只会有一个主分支master&lt;/p&gt;
&lt;/blockquote&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;基本结构&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;https://gitee.com/Ziphtracks/Figurebed/raw/master/img/1/20200705123329.png&quot; alt=&quot;image-20200705123251618&quot; title=&quot;image-20200705123251618&quot;/&gt;image-20200705123251618&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;工作区-版本库-暂存区-分支&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;https://gitee.com/Ziphtracks/Figurebed/raw/master/img/1/20200705143643.png&quot; alt=&quot;image-20200705143640909&quot; title=&quot;image-20200705143640909&quot;/&gt;image-20200705143640909&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4 id=&quot;h23&quot;&gt;&lt;span&gt;2.3 仓库基本命令操作&lt;/span&gt;&lt;/h4&gt;
&lt;blockquote readability=&quot;52&quot;&gt;
&lt;p&gt;我们在使用git来管理本地仓库时，每次对工作区中的内容做的任何变化都需要add（添加）和commit（提交）操作来同步git版本库，只有做了添加和提交操作git才能管理我们的工作区。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@创建版本库：&lt;/strong&gt; 创建或找到一个文件夹，打开命令窗口，执行&lt;code&gt;git init&lt;/code&gt;初始化本地工作区，在该工作区内会初始化生成一个.get目录，而该目录就是版本库，它保存着仓库的所有信息&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@添加一个文件：&lt;/strong&gt; 在工作区中放入一个文件，然后在命令行窗口中执行&lt;code&gt;git add 文件名&lt;/code&gt;即可向工作区中添加一个文件&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@添加多个文件：&lt;/strong&gt; 在工作区中放入多个文件，然后在命令行窗口中执行&lt;code&gt;git add 文件名1 文件名2 ...&lt;/code&gt;即可向工作区中添加多个文件&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@添加文件夹内容：&lt;/strong&gt; 在工作区中放入一个文件夹，然而文件夹中有很多文件，打开命令行窗口执行&lt;code&gt;git add 文件夹名&lt;/code&gt;即可向工作区中添加该文件夹以及文件夹内的所有内容&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@添加工作区内所有内容：&lt;/strong&gt; 如果工作区中有很多文件夹和文件，我们一个或多个添加很麻烦，我们可以使用&lt;code&gt;git add .&lt;/code&gt;命令来添加工作区中的所有内容&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@提交某些文件：&lt;/strong&gt; 使用&lt;code&gt;git commit 文件名1 文件名2 -m &quot;本次提交的描述信息&quot;&lt;/code&gt;，注意提交的描述信息是为了记录本次提交而方便查找，所以尽量能明确反映本次提交&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@提交所有文件：&lt;/strong&gt; 使用&lt;code&gt;git commit -m &quot;本次提交的描述信息&quot;&lt;/code&gt;命令来提交文件，提交后的文件就由git来管理了。-m 后面双引号中的内容，这描述这次提交的信息，以便以后我们后续找到这次提交再做操作&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@修补提交：&lt;/strong&gt; 提交后发现有问题，比如释忘记修改，⽐如提交描述不够详细等等。我们可以执行&lt;code&gt;git commit --amend -m&quot;描述信息&quot;&lt;/code&gt;来再次提交替换上次提交&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@添加并提交文件：&lt;/strong&gt; 使用&lt;code&gt;git commit -a -m &quot;本次添加并提交的描述信息&quot;&lt;/code&gt;命令来自动添加和提交所有文件&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@删除文件：&lt;/strong&gt; 使用命令&lt;code&gt;git rm 文件名&lt;/code&gt;来删除文件，并使用&lt;code&gt;git commit 文件名 -m &quot;描述信息&quot;&lt;/code&gt;来提交这次删除的文件（了解即可）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@文件删除和修改：&lt;/strong&gt; 关于向git提交后的文件，删除和修改我们只需要重新提交即可。也就是说，我们挪动或删除了工作区中的文件或更改了工作区中的目录结构，都需要重新向git添加和提交你所变动的文件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@文件状态：&lt;/strong&gt; 关于如何查看我们添加或提交了哪些文件、还是只添加了文件没有把它提交。查看文件状态需要使用&lt;code&gt;git status&lt;/code&gt;命令查看文件的状态&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@查看该文件的改动情况：&lt;/strong&gt; 使用&lt;code&gt;git diff 文件名&lt;/code&gt;命令来查看该⽂件的改动情况&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@帮助：&lt;/strong&gt; 使用&lt;code&gt;git help commit&lt;/code&gt;或者&lt;code&gt;git commit --help&lt;/code&gt;来获取命令的提示帮助&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;h24&quot;&gt;&lt;span&gt;2.4 日志命令操作&lt;/span&gt;&lt;/h4&gt;
&lt;blockquote readability=&quot;27&quot;&gt;
&lt;p&gt;我们的每次提交，git都会随着提交的变动来记录版本变化，所以你在工作区中的所有操作都会留下日志。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@查看所有提交日志：&lt;/strong&gt; 使用&lt;code&gt;git log&lt;/code&gt;命令来显示从最早的提交点到当前提交点的所有日志&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@查看执行条数的提交日志：&lt;/strong&gt; 使用&lt;code&gt;git log -数量&lt;/code&gt;命令来显示最近指定数量条的提交日志&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@简洁日志显示：&lt;/strong&gt; 使用&lt;code&gt;git log --oneline&lt;/code&gt;命令来显示比较简洁的提交日志&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@查看最近的2次提交日志：&lt;/strong&gt; 使用&lt;code&gt;git log --oneline -数量&lt;/code&gt;命令来简洁的显示最近的数量条的提交日志&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@图形化显示分支走向：&lt;/strong&gt; 使用&lt;code&gt;git log --oneline --graph&lt;/code&gt;命令来图形化显示分支走向&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;提交ID：&lt;/strong&gt; git中的commitID是通过SHA1计算出来的⼀个⾮常⼤的数字，⽤⼗六进制表示，在分布式中保证唯一性。&lt;/p&gt;
&lt;p&gt;而关于日志中显示的commitID，使用&lt;code&gt;git log&lt;/code&gt;命令显示的提交ID是很长的字符串，而使用&lt;code&gt;git log --oneline&lt;/code&gt;命令来简洁显示的提交ID是一个7位的字符串。如果我们后续在使用commitID来操作的时候可以指定提交ID的前几位字符即可，只要在你所操作的几条commitID前几位字符不发生重复就可以使用，所以在我们使用ID的时候并不需要使用很长的ID来操作，而一般使用前7位&lt;/p&gt;
&lt;/blockquote&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;查看日志&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;https://gitee.com/Ziphtracks/Figurebed/raw/master/img/1/20200707082022.png&quot; alt=&quot;image-20200705134002824&quot; title=&quot;image-20200705134002824&quot;/&gt;image-20200705134002824&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4 id=&quot;h25&quot;&gt;&lt;span&gt;2.5 版本回退命令操作&lt;/span&gt;&lt;/h4&gt;
&lt;blockquote readability=&quot;24&quot;&gt;
&lt;p&gt;每次修改文件并添加和提交。git都会记录一个版本，如果有需要可以回退到之前的数据版本状态&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@回退上一个版本：&lt;/strong&gt; 使用&lt;code&gt;git reset --hard HEAD~&lt;/code&gt;命令来回退到上一个版本&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@回退上上个版本：&lt;/strong&gt; 使用&lt;code&gt;git reset --hard HEAD~~&lt;/code&gt;命令来回退到上上个版本&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@回退到上某数量个版本：&lt;/strong&gt; 使用&lt;code&gt;git reset --hard HEAD~数量&lt;/code&gt;命令来回退到上某数量个版本&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@回退到某次提交时的版本：&lt;/strong&gt; 使用&lt;code&gt;git reset --hard commitID&lt;/code&gt;命令来回退到某次提交时的版本&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 回退的版本指定的commitID假如是22c4302cc866fbf5a3184b1fea6bd90b8c85255f，此时我们可以使用命令&lt;code&gt;git reset --hard 22c4302&lt;/code&gt;来回退到该提交ID时的版本，虽然commitID这么长，我们只需要保证唯一性来输入前几位commitID即可。要记住回退版本并不会删除任何版本，所以版本之间可以来回切换&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@细节：&lt;/strong&gt; 发⽣版本回退后，通过&lt;code&gt;git log&lt;/code&gt;命令只能看到最原始提交点⾄当前提交点的⽇志。而&lt;code&gt;git reflog&lt;/code&gt;可以看全部⽇志（包括版本回退的日志）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;h26&quot;&gt;&lt;span&gt;2.6 文件状态&lt;/span&gt;&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;切换至某个分支，在工作区操作该文件，文件状态会有以下几种：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;文件状态&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;6&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;未跟踪&lt;/td&gt;
&lt;td&gt;⼯作区中新创建的⽂件，git中并未保存它的任何记录。使用&lt;code&gt;git add .&lt;/code&gt;命令添加至暂存时即可建立跟踪状态&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;修改&lt;/td&gt;
&lt;td&gt;已跟踪状态的文件，在工作区被修改了，则会变为修改状态&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;暂存&lt;/td&gt;
&lt;td&gt;使用&lt;code&gt;git add .&lt;/code&gt;命令添加到暂存区的文件处于暂存状态。每次暂存的是文件的当前状态，如果文件被修改过，则需要再次将该文件添加到暂存区。而每次提交，是将所有暂存区的文件提交&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;提交&lt;/td&gt;
&lt;td&gt;使用&lt;code&gt;git commit -m &quot;描述&quot;&lt;/code&gt;命令来提交文件，则该文件就将从暂存状态变为了已提交状态。每次提交，会增加一个版本，分支指针后移指向新版本&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4 id=&quot;h27&quot;&gt;&lt;span&gt;2.7 查看文件状态&lt;/span&gt;&lt;/h4&gt;
&lt;blockquote readability=&quot;19&quot;&gt;
&lt;p&gt;我们可以使用&lt;code&gt;git status&lt;/code&gt;命令来时刻查看文件所在状态&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@细节：&lt;/strong&gt; 可以使用&lt;code&gt;git diff&lt;/code&gt;命令来比对工作区内文件的变动状态&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@比对：&lt;/strong&gt; 使用&lt;code&gt;git diff 文件名&lt;/code&gt;命令来比对工作区和暂存区（若暂存区没有则比对分支）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@比对工作区与分支的最新结果：&lt;/strong&gt; 使用&lt;code&gt;git diff HEAD -- 文件名&lt;/code&gt;命令来比对工作区和分支的最新结果&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@比对暂存区与分支的最新结果：&lt;/strong&gt; 使用&lt;code&gt;git diff --staged 文件名&lt;/code&gt;命令来比对暂存区与分支的最新结果&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; &lt;code&gt;git diff HEAD -- 文件名&lt;/code&gt;命令&lt;code&gt;--&lt;/code&gt;与&lt;code&gt;文件名&lt;/code&gt;之间必须要有一个空格，不要写错！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;h28&quot;&gt;&lt;span&gt;2.8 撤销修改命令操作&lt;/span&gt;&lt;/h4&gt;
&lt;blockquote readability=&quot;16&quot;&gt;
&lt;p&gt;&lt;strong&gt;@工作区撤销：&lt;/strong&gt; 执行&lt;code&gt;git checkout -- 文件名&lt;/code&gt;命令可以撤销到最近一次&lt;code&gt;git add&lt;/code&gt;或&lt;code&gt;git commit&lt;/code&gt;的状态&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;工作区撤销内部流程：&lt;/strong&gt; 你执行了工作区撤销命令，如果暂存区有此文件，则将暂存区中的文件恢复到工作区中；如果暂存区没有此文件，则将分支中的文件恢复到工作区中&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@暂存区撤销：&lt;/strong&gt; 先执行&lt;code&gt;git reset HEAD 文件名&lt;/code&gt;命令将该文件移除暂存区，后执行&lt;code&gt;git checkout -- 文件名&lt;/code&gt;命令回退到上一个版本&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;暂存区撤销场景：&lt;/strong&gt; 如果在工作区中修改了文件并发送到了暂存区中，但文件中有需要撤销的内容&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;h-1&quot;&gt;&lt;span&gt;三、分支&lt;/span&gt;&lt;/h3&gt;
&lt;h4 id=&quot;h31&quot;&gt;&lt;span&gt;3.1 分支概述&lt;/span&gt;&lt;/h4&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;每一个被git管理的仓库都会有一个默认的主分支（master分支）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;分⽀中接收&lt;code&gt;git commit&lt;/code&gt;提交的内容，为⼀个⼀个不断向前发展的提交点。每个提交点都保存了⼀个版本&lt;/li&gt;
&lt;li&gt;&lt;span&gt;每个分⽀，都有⼀个指针，指针默认指向最近⼀次提交的版本&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;⼯作区中的内容，初始状态，就是指针所指向的版本状态&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;基于指针指向的版本代码，在⼯作区中做进⼀步的编码，功能完成后，即可&lt;code&gt;git commit&lt;/code&gt;，在分⽀中形成新的提交点。然后再在⼯作区中，添加新代码，功能完成，再 git commit,⼜形成新的提交点，指针再次后移。如此反复，不断开发，不断记录版本。&lt;/li&gt;
&lt;li&gt;&lt;span&gt;当有需要时，可以回退指针到某个提交点，在⼯作区中即可得到之前的某个版本的代码&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;分支效果图&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;https://gitee.com/Ziphtracks/Figurebed/raw/master/img/1/20200705162304.png&quot; alt=&quot;image-20200705162301187&quot; title=&quot;image-20200705162301187&quot;/&gt;image-20200705162301187&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4 id=&quot;h32&quot;&gt;&lt;span&gt;3.2 多分支&lt;/span&gt;&lt;/h4&gt;
&lt;blockquote readability=&quot;26&quot;&gt;
&lt;p&gt;为什么要使用多分支呢？那么我们就需要了解几个场景了&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;场景1：&lt;/strong&gt; 在编写一个功能代码时，需要一周的时间，在一周时间内可能会有多次提交，但最后的时候我们中间提交点的代码中发现有问题存在，那这些存在问题的提交点就掺杂在master主分支，使主分支变得十分混乱&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;场景2：&lt;/strong&gt; 在编写一个功能代码时，有一个新的思路，但不确定能否最总实现预期功能效果，只能试着编写，最后发现达不到预期功能结果，则中间提交过的很多提交点都无效了，也使得主分支变得十分混乱&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;场景3：&lt;/strong&gt; 如果该项目是多人协同开发，master主分支有错误或无效的提交点会影响其他人的开发进度&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 实际开发中master分⽀尽量只存放稳定的代码提交，保证master分⽀稳定，有效。因为这样保证了我们的开发进度不会受到影响&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决方案1：&lt;/strong&gt; ⼀直不提交，等所有都写完后，提交⼀次。虽然可以保护master分⽀，但开发过程中缺乏版本控制点，易丢失⼯作&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决方案2：&lt;/strong&gt; 在需要编写新功能时，新建⼀个开发⽤的分⽀，所有改动都在该分⽀上提交，在功能完整实现后，将该分⽀的最终内容合并到master分⽀。这样，既保证开发中有多个版本可以控制，⼜保证master分⽀是稳定，有效的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;多分支效果图&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;https://gitee.com/Ziphtracks/Figurebed/raw/master/img/1/20200705164653.png&quot; alt=&quot;image-20200705164651235&quot; title=&quot;image-20200705164651235&quot;/&gt;image-20200705164651235&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4 id=&quot;h33&quot;&gt;&lt;span&gt;3.3 多分支基本命令操作&lt;/span&gt;&lt;/h4&gt;
&lt;blockquote readability=&quot;24&quot;&gt;
&lt;p&gt;&lt;strong&gt;@创建分支：&lt;/strong&gt; 使用&lt;code&gt;git branch 分支名&lt;/code&gt;命令创建分支，会与当前分支保持同样的数据状态，即新分支和当前分支指向同一个提交点&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@切换分支：&lt;/strong&gt; 使用&lt;code&gt;git checkout 分支名&lt;/code&gt;命令切换分支，切换分支后工作区中显示当前分支内容（切换分支实际上是切换了分支的指针，让指针指向了所要切换到分支）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@查看当前分支：&lt;/strong&gt; 使用&lt;code&gt;git branch&lt;/code&gt;命令来查看当前分支&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@查看当前分支详细信息：&lt;/strong&gt; 使用&lt;code&gt;git branch -vv&lt;/code&gt;命令查看分支详细信息，分支信息则是所跟踪的远程分支信息以及是否领先远程分支等等&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@合并分支：&lt;/strong&gt; 如果新分支编写完成后，先使用&lt;code&gt;git branch master&lt;/code&gt;命令切换到master分支，再使用&lt;code&gt;git merge 新分支名&lt;/code&gt;命令将新分支合并到master分支。此次合并就是将master的指针移到了新分支的位置，等价于快速合并&lt;br/&gt;&lt;strong&gt;@查看当前合并分支：&lt;/strong&gt; 分支合并后可以使用&lt;code&gt;git branch --merged&lt;/code&gt;命令查看被当前分⽀合并了的分⽀&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@删除分支：&lt;/strong&gt; 将分支合并后，如果新分支不再继续使用，可以先使用&lt;code&gt;git branch --merged&lt;/code&gt;命令查看合并分支以确认我们即将删除的分支的确是无用分支后，再使用&lt;code&gt;git branch -d 分支名&lt;/code&gt;命令删除需要删除的无用分支。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;h34&quot;&gt;&lt;span&gt;3.4 解决分支冲突&lt;/span&gt;&lt;/h4&gt;
&lt;blockquote readability=&quot;25&quot;&gt;
&lt;p&gt;&lt;strong&gt;场景：&lt;/strong&gt; 创建一个新分支（见图1）；切换到新分支，并在文件中添加一些信息并提交（见图2）；切换到master分支，并在文件中也添加一些信息并提交（见图3）；在master分支中合并新分支。此时合并分支中会出现冲突（见图4）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分支冲突原因：&lt;/strong&gt; 两个分支对同一个文件做了改动，所以在合并时git会无法确定保留哪个分支上的数据&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@终止合并分支：&lt;/strong&gt; 当出现分支冲突时可以使用&lt;code&gt;git merge --abort&lt;/code&gt;命令来终止合并分支&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@避免因为空⽩导致冲突：&lt;/strong&gt; 在合并分支时，如果有空白内容有可能会出现分支冲突现象，所以此时可以使用&lt;code&gt;git merge 分支名 -Xignore-all-space&lt;/code&gt;命令来避免因为空白而导致的分支冲突&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决分支冲突：&lt;/strong&gt; 需要找到提交两个分支的人一起讨论最终保留哪些数据，讨论后将最终要保留的数据在一个的分支中提交。此时便解决了合并时发生的分支冲突问题，合并完成后某个分支将不再使用可以使用&lt;code&gt;git branch -d 分支名&lt;/code&gt;命令来删除无用分支&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 解决冲突要么保留其中的一方，要么达成协议商讨双方手动合并，无论如何记得删除&lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; ==== &amp;gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; 这些符号&lt;/p&gt;
&lt;/blockquote&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;分支冲突效果图&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;https://gitee.com/Ziphtracks/Figurebed/raw/master/img/1/20200705171537.png&quot; alt=&quot;image-20200705171535657&quot; title=&quot;image-20200705171535657&quot;/&gt;image-20200705171535657&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;分支冲突错误提示信息：&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;&lt;code&gt;Auto-merging test.txt CONFLICT (content): Merge conflict in test.txt Automatic merge failed; fix conflicts and then commit the result.&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;&lt;strong&gt;合并冲突后git将双方对文件的改动都保留了，并使用&lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt;、&lt;code&gt;======&lt;/code&gt;、&lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;做了分隔&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;https://gitee.com/Ziphtracks/Figurebed/raw/master/img/1/20200706200024.jpg&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4 id=&quot;h35&quot;&gt;&lt;span&gt;3.5 快照&lt;/span&gt;&lt;/h4&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;git在保存每个版本时( 对应提交点 )，并不是复制所有⽂件，没有改动的⽂件只是记录⼀个链接。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解释：&lt;/strong&gt; 首先看V1版本内有三个文件。我们将A、C文件做了修改并提交便生成了V2版本。这时内部是怎么操作的呢？其实git在内部复制了A、C两个需要修改的文件到V2版本中并做了修改，而虚线框中的B文件并没有发生任何修改，其git内部就以链接的形式在V2版本用引用了B文件，减少了重复文件的环节，大大提高了Git的效率。以此类推，以后的版本虚线框内也都是引用的上个版本的文件&lt;/p&gt;
&lt;/blockquote&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;快照效果图&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;https://gitee.com/Ziphtracks/Figurebed/raw/master/img/1/20200705173738.png&quot; alt=&quot;image-20200705173736020&quot; title=&quot;image-20200705173736020&quot;/&gt;image-20200705173736020&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4 id=&quot;h36&quot;&gt;&lt;span&gt;3.6 合并方式&lt;/span&gt;&lt;/h4&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;分支的合并方式有两种&lt;strong&gt;快速合并&lt;/strong&gt; 和&lt;strong&gt;三方合并&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;快速合并内部流程：&lt;/strong&gt; 一个人在主分支上拉出了一个新分支为newBr并提交了一次（移动了一次指针）。如果合并这两个分支，在快速合并中只需要移动master分支的指针指向newBr分支即可实现合并&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;三方合并内部流程：&lt;/strong&gt; 在三方合并中从开始分叉的那个提交点开始，分别将该提交点更新的部分数据合并至master和newBr分支，合并后就三个分支就剩下了俩个分支。则剩下的master分支和newBr分支将合并为一个新的提交点，而这个由三方合并成的新提交点为最终合并成功的那个master分支&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 以下例图并不严谨，只为传达思想！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;快读合并效果图&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;https://gitee.com/Ziphtracks/Figurebed/raw/master/img/1/20200705180014.png&quot; alt=&quot;image-20200705180012469&quot; title=&quot;image-20200705180012469&quot;/&gt;image-20200705180012469&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;三方合并效果图&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;https://gitee.com/Ziphtracks/Figurebed/raw/master/img/1/20200705180049.png&quot; alt=&quot;image-20200705180047972&quot; title=&quot;image-20200705180047972&quot;/&gt;image-20200705180047972&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;hgithub&quot;&gt;&lt;span&gt;四、远程仓库（Github）&lt;/span&gt;&lt;/h3&gt;
&lt;h4 id=&quot;h41sshkey&quot;&gt;&lt;span&gt;4.1 获取SSH key&lt;/span&gt;&lt;/h4&gt;
&lt;blockquote readability=&quot;18&quot;&gt;
&lt;p&gt;git本地仓库和GitHub或码云之间传输，建议设置SSH key，避免在传输中反复输入密码&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;设置SSH key：&lt;/strong&gt; 执行&lt;code&gt;ssh-keygen -t rsa -C &quot;邮箱&quot;&lt;/code&gt;命令后的每一步都按Enter键确定就好，知道命令执行结束（-C 后面的内容随意写就行，这只是作为title而已）&lt;/p&gt;
&lt;p&gt;命令执行完毕后，会在你电脑的&lt;code&gt;C:\Users\主机名\.ssh&lt;/code&gt;目录下生成密钥文件。&lt;code&gt;id_rsa&lt;/code&gt;是私钥，不能泄露出去。&lt;code&gt;id_rsa.pub&lt;/code&gt;是公钥，可以放⼼地告诉任何⼈。&lt;/p&gt;
&lt;p&gt;随后注册登录GitHub，在账户设置中选择&lt;code&gt;SSH Keys&lt;/code&gt;，在Title中随意填写内容，在Key中填写&lt;code&gt;id_rsa.pub&lt;/code&gt;文件中的所有内容&lt;/p&gt;
&lt;p&gt;在GitHub中添加好自己的公钥，这样和Git服务器通信时（clone，push，pull）git服务器就可以识别出你的身份了！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;h42sshkey&quot;&gt;&lt;span&gt;4.2 注册登录并设置SSHKey&lt;/span&gt;&lt;/h4&gt;
&lt;blockquote readability=&quot;2.6829268292683&quot;&gt;
&lt;p&gt;&lt;strong&gt;GitHub官网地址：&lt;/strong&gt; &lt;a href=&quot;https://github.com/&quot;&gt;https://github.com/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;h43&quot;&gt;&lt;span&gt;4.3 创建远程仓库（主四步骤）&lt;/span&gt;&lt;/h4&gt;
&lt;blockquote readability=&quot;18&quot;&gt;
&lt;p&gt;首先在GitHub中创建远程仓库，其次就是将本地仓库关联到远程仓库，这里如果做关联的话是需要执行一些命令的，虽然在GitHub创建仓库的时候已经提示命令，但是由于我想到有很多小伙伴会不清楚怎么看和执行这些命令，所以我在图中已经标注。为了全面些，我也会把这些命令罗列到下方并作以解释！&lt;/p&gt;
&lt;ol readability=&quot;4.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;@添加自述文件：&lt;/strong&gt; 如果是本地仓库是空的，我们需要创建一个自述文件（README.md），也就是说创建一个文件放入到本地仓库中，执行&lt;code&gt;git add .&lt;/code&gt;和&lt;code&gt;git commit -m &quot;add a README.md&quot;&lt;/code&gt;（最好仓库中不是空的！）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;@关联远程仓库：&lt;/strong&gt; 关联远程仓库只需要执行&lt;code&gt;git remote add 关联别名 仓库地址&lt;/code&gt;命令即可（注意：别名是可以自己取名设置的，但是不要忘记就好，因为后续push的时候会用到）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;@上传到GitHub远程仓库：&lt;/strong&gt; 执行&lt;code&gt;git push 关联别名 master&lt;/code&gt;命令将文件上传到GitHub服务器的主master分支&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;上传到GitHub远程仓库后，我们就可以正常的在GitHub查看所上传的文件。设置一次关联后，我们在本地仓库上传到GitHub远程仓库都需要&lt;code&gt;add -&amp;amp;gt; commit -&amp;amp;gt; push&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;@查看关联的所有远程仓库：&lt;/strong&gt; 执行&lt;code&gt;git remote -v&lt;/code&gt;命令查看关联的所有远程仓库&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@查看关联后远程仓库分支和本地仓库分支的对应关系：&lt;/strong&gt; 执行&lt;code&gt;git remote show 关联别名&lt;/code&gt;命令查看&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@删除关联：&lt;/strong&gt; 执行&lt;code&gt;git remote remove 关联别名&lt;/code&gt;命令删除关联&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@重命名关联别名：&lt;/strong&gt; 执行&lt;code&gt;git remote rename 原关联别名 新关联别名&lt;/code&gt;命令重命名关联别名&lt;/p&gt;
&lt;/blockquote&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;右侧头像点击 + 后打开New repository&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;https://gitee.com/Ziphtracks/Figurebed/raw/master/img/1/20200707082204.png&quot; alt=&quot;image-20200705185611385&quot; title=&quot;image-20200705185611385&quot;/&gt;image-20200705185611385&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;创建仓库&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;https://gitee.com/Ziphtracks/Figurebed/raw/master/img/1/20200705185950.png&quot; alt=&quot;image-20200705185948941&quot; title=&quot;image-20200705185948941&quot;/&gt;image-20200705185948941&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;本地仓库关联GitHub服务器&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;https://gitee.com/Ziphtracks/Figurebed/raw/master/img/1/20200705190936.png&quot; alt=&quot;image-20200705190934375&quot; title=&quot;image-20200705190934375&quot;/&gt;image-20200705190934375&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;做完以上步骤就可以在GitHub上看到我们所上传的文件了！&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4 id=&quot;h44push&quot;&gt;&lt;span&gt;4.4 上传命令操作（push）&lt;/span&gt;&lt;/h4&gt;
&lt;blockquote readability=&quot;22&quot;&gt;
&lt;p&gt;将本地仓库的文件上传到关联的GitHub远程仓库中显示（注意：push的文件是必须commit提交过的！）&lt;/p&gt;
&lt;p&gt;将本地仓库的文件上传到关联的GitHub远程仓库中显示（注意：push的文件是必须commit提交过的！）&lt;/p&gt;
&lt;p&gt;push操作需要关联仓库，也就是说必须有权限来对GitHub远程仓库做操作，而且需要在你pull之后没人push过&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@上传到GitHub远程仓库：&lt;/strong&gt; 执行&lt;code&gt;git push 关联别名 master&lt;/code&gt;命令来将本地仓库的文件上传到GitHub远程仓库显示（注意：我们是可以指定上传的分支的！）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@本地存在分支上传GitHub分支：&lt;/strong&gt; 执行&lt;code&gt;git push 关联别名 本地仓库分支:GitHub仓库分支&lt;/code&gt;命令会将本地仓库存在分支上传到GitHub分支&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@本地存在多分支上传到GitHub多分支：&lt;/strong&gt; 执行&lt;code&gt;git push 关联别名 本地仓库分支1:GitHub仓库分支1 本地仓库分支2:GitHub仓库分支2&lt;/code&gt;命令来实现一次性实现上传指定多个分支&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;h45fetchmerge&quot;&gt;&lt;span&gt;4.5 拉取远程操作（fetch、merge）&lt;/span&gt;&lt;/h4&gt;
&lt;blockquote readability=&quot;25&quot;&gt;
&lt;p&gt;拉取远程仓库的新内容到本地仓库和版本库，但是这个操作并没有合并到本地库的分⽀中，需要通过⼿动合并分支来实现。此操作并不常用，了解即可！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@拉取远程仓库分支：&lt;/strong&gt; 执行&lt;code&gt;git fetch 关联别名 master&lt;/code&gt;命令来拉取master分支下的内容&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@手动合并本地库分支：&lt;/strong&gt; 执行&lt;code&gt;git merge 关联别名/master&lt;/code&gt;命令来手动合并本地库分支下的内容&lt;/p&gt;
&lt;p&gt;上面两个命令可以将GitHub服务器上的最新状态同步到本地仓库中&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@拉取所有分支：&lt;/strong&gt; 执行&lt;code&gt;git fetch 关联别名&lt;/code&gt;命令来拉取GitHub服务器所有分支下的内容（合并分支如下）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@手动合并所有分支内容：&lt;/strong&gt; 执行&lt;code&gt;git checkout 分支1&lt;/code&gt;命令来切换分支并执行&lt;code&gt;git merge 关联别名/分支1&lt;/code&gt;合并拉取该分支的内容，并以此类推合并各个分支&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@比较拉取内容中的分支和本地分支中的不同：&lt;/strong&gt; 首先执行&lt;code&gt;git checkout 分支&lt;/code&gt;命令来切换到想要比较并拉取的分支，再执行&lt;code&gt;git diff 关联别名/分支&lt;/code&gt;命令来比较拉取的内容中的分支和本地分支的不同&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;h46pull&quot;&gt;&lt;span&gt;4.6 下载操作（pull）&lt;/span&gt;&lt;/h4&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;首先下载操作等价于拉取远程的新内容，并合并到当前分支的操作&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@下载远程内容：&lt;/strong&gt; 可以执行&lt;code&gt;git pull 关联别名 master&lt;/code&gt;命令来完成对远程仓库主分支内容的下载操作，该操作省略了本地仓库分支（当前分支），默认的将远程仓库master主分支上的内容下载到了本地仓库的master主分支&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@下载远程内容的完整写法：&lt;/strong&gt; &lt;code&gt;git pull 关联别名 远程仓库分支:本地仓库分支（当前分支）&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;h47clone&quot;&gt;&lt;span&gt;4.7 克隆操作（clone）&lt;/span&gt;&lt;/h4&gt;
&lt;blockquote readability=&quot;18&quot;&gt;
&lt;p&gt;将GitHub远程仓库的所有内容下载到本地，该方式自动搭建了本地与GitHub远程仓库的关联&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@clone操作1：&lt;/strong&gt; 执行命令&lt;code&gt;git clone SSH地址&lt;/code&gt;将远程仓库clone到本地，已设置key，不用命令&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@clone操作2：&lt;/strong&gt; 执行命令&lt;code&gt;git clone HTTPS地址&lt;/code&gt;将远程仓库clone到本地，该方式需要输入GitHub口令&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;细节1：&lt;/strong&gt; clone只在初次从git服务器下载项⽬时执⾏⼀次，后续在需要同步应该执⾏pull或fetch&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;细节2：&lt;/strong&gt; 当执⾏&lt;code&gt;git clone&lt;/code&gt;命令时，默认配置下远程 Git 仓库中的每⼀个⽂件的每⼀个版本都将被拉取下来&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;h-2&quot;&gt;&lt;span&gt;五、标签&lt;/span&gt;&lt;/h3&gt;
&lt;h4 id=&quot;h51&quot;&gt;&lt;span&gt;5.1 为什么要打标签&lt;/span&gt;&lt;/h4&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;其实在我们做项目的时候是少不了遇见很多问题的，有可能在这个版本的问题发布出现了问题，但是到了后面的几个版本都没有得到解决。而项目往往不会因为这些问题而终止项目的上传。为了让所有人能了解该版本中的问题而使用标签作为标记&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 以下所使用的v1.1.0等等标签是标签名，小伙伴们可以根据自己的需求来打标签&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;h52&quot;&gt;&lt;span&gt;5.2 打标签&lt;/span&gt;&lt;/h4&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;strong&gt;@创建轻量标签：&lt;/strong&gt; 使用&lt;code&gt;git tag v1.1.0&lt;/code&gt;命令来创建轻量标签&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@创建附加备注的轻量标签：&lt;/strong&gt; 使用&lt;code&gt;git tag -a v1.1.1 -m &quot;说明文字&quot;&lt;/code&gt;命令来创建附注标签，而创建标签会自动打在最近的提交点上&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@为以前的提交点打标签：&lt;/strong&gt; 如果为以前的提交点打标签就需要使用&lt;code&gt;git log&lt;/code&gt;命令去查看commitID，再根据commitID执行&lt;code&gt;git tag -a v1.1.1 &quot;commitID&quot;&lt;/code&gt;来为该提交点打标签&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;h53&quot;&gt;&lt;span&gt;5.3 查看标签&lt;/span&gt;&lt;/h4&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;strong&gt;@查看所有分支上的所有标签：&lt;/strong&gt; 执行&lt;code&gt;git tag&lt;/code&gt;命令来查看&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@查看标签名以“v1.1”开头的标签：&lt;/strong&gt; 执行&lt;code&gt;git tag &quot;v1.1*&quot;&lt;/code&gt;命令来查看&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@显示标签及其对应的提交信息：&lt;/strong&gt; 执行&lt;code&gt;git show v1.1.0&lt;/code&gt;命令来显示标签及其对应的提交信息&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;h54&quot;&gt;&lt;span&gt;5.4 共享标签&lt;/span&gt;&lt;/h4&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;标签不会随提交点⼀起 提交到远程服务器，需要单独push。而pull时，标签会⼀同被下载到本地&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@同步一个标签“v1.1.1”到GitHub服务器：&lt;/strong&gt; 执行&lt;code&gt;git push 关联别名 v1.1.1&lt;/code&gt;命令来同步标签&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@同步所有标签到GitHub服务器：&lt;/strong&gt; 执行&lt;code&gt;git push 关联别名 --tags&lt;/code&gt;命令来同步所有标签&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;h55&quot;&gt;&lt;span&gt;5.5 删除标签&lt;/span&gt;&lt;/h4&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;标签删除需要在本地和远程分别删除&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@在本地删除标签：&lt;/strong&gt; 执行&lt;code&gt;git tag -d v1.1.1&lt;/code&gt;命令来删除本地标签&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@删除远程库中的标签：&lt;/strong&gt; 执行&lt;code&gt;git push 关联别名 :refs/tags/v1.1.1&lt;/code&gt;命令来删除远程库中的所有标签&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;h56&quot;&gt;&lt;span&gt;5.6 标签的使用&lt;/span&gt;&lt;/h4&gt;
&lt;blockquote readability=&quot;16&quot;&gt;
&lt;p&gt;标签的主要作用是用于发布版本，假设我们已经为各个版本打了标签“v1.0”、“v2.0”等等。现在需要v1.0版本，就可以分离一个指针指向v1.0版本的提交点位置&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@原分离头指针：&lt;/strong&gt; 执行&lt;code&gt;git checkout v1.0版本的commitID&lt;/code&gt;命令来使头指针指向该commitID的提交点&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@标签分离头指针：&lt;/strong&gt; 执行&lt;code&gt;git checkout v1.0&lt;/code&gt;命令来使头指针 指向该提交点&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 分离头指针只是一个临时指针，它不归属任何分支，使用标签显然比使用commitID方便，最后随意切一个分支，分离头指针消失，就像之前什么都没有发生过一样&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;h-3&quot;&gt;&lt;span&gt;六、别名&lt;/span&gt;&lt;/h3&gt;
&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;有一些指令感觉会比较麻烦，就可以定义别名来执行命令，简化书写。下面列举一个常用的命令来实现别名的简化&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@简化commit命令书写：&lt;/strong&gt; 执行&lt;code&gt;git config --global alias.comt &quot;commit -m&quot;&lt;/code&gt;命令来简化commit -m命令，设置这种简化命令之后以后执行&lt;code&gt;git comt &quot;描述信息&quot;&lt;/code&gt;命令就等价于执行了&lt;code&gt;git commit -m &quot;描述信息&quot;&lt;/code&gt;命令&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@删除别名简化：&lt;/strong&gt; 执行&lt;code&gt;git config --global --unset alias.comt&lt;/code&gt;命令来删除我们创建的简化commit的别名，删除后使用comt则就会失效&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;hideagit&quot;&gt;&lt;span&gt;七、IDEA关联Git&lt;/span&gt;&lt;/h3&gt;
&lt;h4 id=&quot;h71git&quot;&gt;&lt;span&gt;7.1 关联Git&lt;/span&gt;&lt;/h4&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;设置关联Git&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;https://gitee.com/Ziphtracks/Figurebed/raw/master/img/1/20200706200830.png&quot; alt=&quot;image-20200706200827532&quot; title=&quot;image-20200706200827532&quot;/&gt;image-20200706200827532&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4 id=&quot;h72&quot;&gt;&lt;span&gt;7.2 创建仓库&lt;/span&gt;&lt;/h4&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;在IDEA中创建仓库之前，我们需要创建设置一个忽略文件（.gitignore）。至于为什么呢？那是因为我们在项目中会有很多文件不必上传，就比如db.properties配置文件、.idea文件、所有的.class文件等等，所以这个忽略文件就可以帮我们在上传服务器的时候忽略这些没有必要的文件，忽略后的文件不会放在版本库中管理&lt;/p&gt;
&lt;/blockquote&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;设置忽略文件&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;https://gitee.com/Ziphtracks/Figurebed/raw/master/img/1/20200706202234.jpg&quot; alt=&quot;idea-创建仓库0&quot; title=&quot;idea-创建仓库0&quot;/&gt;idea-创建仓库0&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;初始化一个仓库&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;https://gitee.com/Ziphtracks/Figurebed/raw/master/img/1/20200706202312.jpg&quot; alt=&quot;idea-创建仓库1&quot; title=&quot;idea-创建仓库1&quot;/&gt;idea-创建仓库1&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;https://gitee.com/Ziphtracks/Figurebed/raw/master/img/1/20200706202322.jpg&quot; alt=&quot;idea-创建仓库2&quot; title=&quot;idea-创建仓库2&quot;/&gt;idea-创建仓库2&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4 id=&quot;h73&quot;&gt;&lt;span&gt;7.3 提交&lt;/span&gt;&lt;/h4&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;选择提交菜单，提交一个版本&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;https://gitee.com/Ziphtracks/Figurebed/raw/master/img/1/20200706202420.jpg&quot; alt=&quot;idea-commit&quot; title=&quot;idea-commit&quot;/&gt;idea-commit&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;选择提交文件，定义提交信息&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;https://gitee.com/Ziphtracks/Figurebed/raw/master/img/1/20200706202600.jpg&quot; alt=&quot;idea-commit2&quot; title=&quot;idea-commit2&quot;/&gt;idea-commit2&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;之后会有些友好提示，可以忽略，点击“commit”即可&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;https://gitee.com/Ziphtracks/Figurebed/raw/master/img/1/20200706202641.jpg&quot; alt=&quot;idea-commit3&quot; title=&quot;idea-commit3&quot;/&gt;idea-commit3&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4 id=&quot;h74&quot;&gt;&lt;span&gt;7.4 创建分支&lt;/span&gt;&lt;/h4&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;点击右下角链接，创建新分支&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;https://gitee.com/Ziphtracks/Figurebed/raw/master/img/1/20200706203401.png&quot; alt=&quot;image-20200706203359233&quot; title=&quot;image-20200706203359233&quot;/&gt;image-20200706203359233&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;新建分支&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;https://gitee.com/Ziphtracks/Figurebed/raw/master/img/1/20200706203408.jpg&quot; alt=&quot;idea-新建分支2&quot; title=&quot;idea-新建分支2&quot;/&gt;idea-新建分支2&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;查看当前分支&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;https://gitee.com/Ziphtracks/Figurebed/raw/master/img/1/20200706203512.png&quot; alt=&quot;image-20200706203510723&quot; title=&quot;image-20200706203510723&quot;/&gt;image-20200706203510723&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4 id=&quot;h75&quot;&gt;&lt;span&gt;7.5 上传到远程仓库&lt;/span&gt;&lt;/h4&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;先创建一个仓库，随后选择push菜单&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;https://gitee.com/Ziphtracks/Figurebed/raw/master/img/1/20200706203623.jpg&quot; alt=&quot;idea-push&quot; title=&quot;idea-push&quot;/&gt;idea-push&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;定义远程仓库地址&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;https://gitee.com/Ziphtracks/Figurebed/raw/master/img/1/20200706203654.jpg&quot; alt=&quot;idea-push3&quot; title=&quot;idea-push3&quot;/&gt;idea-push3&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;开始push操作&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;https://gitee.com/Ziphtracks/Figurebed/raw/master/img/1/20200706203719.jpg&quot; alt=&quot;idea-push4&quot; title=&quot;idea-push4&quot;/&gt;idea-push4&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;push成功后 ，弹窗提示&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;https://gitee.com/Ziphtracks/Figurebed/raw/master/img/1/20200706203746.jpg&quot; alt=&quot;idea-push5&quot; title=&quot;idea-push5&quot;/&gt;idea-push5&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4 id=&quot;h76&quot;&gt;&lt;span&gt;7.6 复制到本地仓库&lt;/span&gt;&lt;/h4&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;找到GitHub或码云上的开源项目后复制链接，点击克隆菜单&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;https://gitee.com/Ziphtracks/Figurebed/raw/master/img/1/20200706203921.jpg&quot; alt=&quot;idea-clone&quot; title=&quot;idea-clone&quot;/&gt;idea-clone&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;输入如远程仓库地址&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;https://gitee.com/Ziphtracks/Figurebed/raw/master/img/1/20200706203944.jpg&quot; alt=&quot;idea-clone2&quot; title=&quot;idea-clone2&quot;/&gt;idea-clone2&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;打开项目&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;https://gitee.com/Ziphtracks/Figurebed/raw/master/img/1/20200706204004.jpg&quot; alt=&quot;idea-clone3&quot; title=&quot;idea-clone3&quot;/&gt;idea-clone3&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;打开项目，选项&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;https://gitee.com/Ziphtracks/Figurebed/raw/master/img/1/20200706204044.jpg&quot; alt=&quot;idea-clone4&quot; title=&quot;idea-clone4&quot;/&gt;idea-clone4&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4 id=&quot;h77&quot;&gt;&lt;span&gt;7.7 更新本地项目&lt;/span&gt;&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;注意：如果远程仓库有更新，则你的本地项目也需要一起更新。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;选择pull菜单&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;https://gitee.com/Ziphtracks/Figurebed/raw/master/img/1/20200706204219.jpg&quot; alt=&quot;idea-pull1&quot; title=&quot;idea-pull1&quot;/&gt;idea-pull1&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;执行pull操作&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;https://gitee.com/Ziphtracks/Figurebed/raw/master/img/1/20200706204245.jpg&quot; alt=&quot;idea-pull2&quot; title=&quot;idea-pull2&quot;/&gt;idea-pull2&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;更新日志显示&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;https://gitee.com/Ziphtracks/Figurebed/raw/master/img/1/20200706204259.jpg&quot; alt=&quot;idea-pull3&quot; title=&quot;idea-pull3&quot;/&gt;idea-pull3&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4 id=&quot;h78idea&quot;&gt;&lt;span&gt;7.8 IDEA中冲突解决&lt;/span&gt;&lt;/h4&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;冲突出现，弹窗中可以选择如下&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;https://gitee.com/Ziphtracks/Figurebed/raw/master/img/1/20200706204329.jpg&quot; alt=&quot;idea-冲突&quot; title=&quot;idea-冲突&quot;/&gt;idea-冲突&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;也可以直接修改冲突文件，然后commit即可&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;https://gitee.com/Ziphtracks/Figurebed/raw/master/img/1/20200706204349.jpg&quot; alt=&quot;idea-冲突2&quot; title=&quot;idea-冲突2&quot;/&gt;idea-冲突2&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;h-4&quot;&gt;&lt;span&gt;八、多人协同开发&lt;/span&gt;&lt;/h3&gt;
&lt;h4 id=&quot;h81&quot;&gt;&lt;span&gt;8.1 项目经理&lt;/span&gt;&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;由项目经理负责创建一个远程仓库，初始仓库中什么都没有，而库的名称建议和项⽬同名&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;管理员会在IDEA中创建⼀个空项⽬，其中包含 .gitignore⽂件 。并在项⽬根⽬录下执行&lt;code&gt;git init&lt;/code&gt;建⽴本地库，并建⽴dev开发分⽀&lt;/li&gt;
&lt;li&gt;管理员将本地库同步到远程库，执行命令&lt;code&gt;git push 远程库地址 master:master dev:dev&lt;/code&gt;操作&lt;/li&gt;
&lt;li&gt;&lt;span&gt;将项目组中的其他人员拉入远程仓库的开发人员列表中，此操作是赋予开发人员对远程仓库push等等的权限&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;master分⽀设置为 protected分⽀，只有管理员有权限将代码合并到其中。dev分⽀设置为 常规分⽀所有开发⼈员都可以其中合并代码&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 管理员拉开发人员进入开发人员列表在仓库的设置中设置&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;h82&quot;&gt;&lt;span&gt;8.2 开发人员&lt;/span&gt;&lt;/h4&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;开始的时候开发人员需要将项目使用IDEA或命令行clone远程仓库，获取项目。clone操作自动关联远程仓库并建立了本地仓库&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;获得项⽬时，本地库中只显示master分⽀，需要执⾏&lt;code&gt;git checkout dev&lt;/code&gt;即可获得dev分⽀&lt;/li&gt;
&lt;li&gt;后续的开发中，都要在dev分⽀上进⾏。开发完⼀个功能并测试通过后就可以&lt;code&gt;git add .&lt;/code&gt;并&lt;code&gt;git commit -m &quot;描述信息&quot;&lt;/code&gt;提交到本地的dev分⽀中，然后&lt;code&gt;git push&lt;/code&gt;远程库地址的dev分支并同步到远程dev分⽀中&lt;/li&gt;
&lt;li&gt;如果在&lt;code&gt;git push&lt;/code&gt;远程库时，有⼈⽐你早⼀步&lt;code&gt;git push&lt;/code&gt;，GitHub服务器将拒绝你的&lt;code&gt;git push&lt;/code&gt;操作。（乐观锁原理）不过很简单，你需要先&lt;code&gt;git pull&lt;/code&gt;远程库的dev分支后再&lt;code&gt;git push&lt;/code&gt;即可&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
</description>
<pubDate>Tue, 07 Jul 2020 00:16:00 +0000</pubDate>
<dc:creator>Ziph</dc:creator>
<og:description>万字长文，手把手教你玩转Git！</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ziph/p/13258788.html</dc:identifier>
</item>
<item>
<title>31道Java核心面试题，一次性打包送给你 - 沉默王二</title>
<link>http://www.cnblogs.com/qing-gee/p/13258782.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qing-gee/p/13258782.html</guid>
<description>&lt;blockquote readability=&quot;9.5238095238095&quot;&gt;
&lt;p&gt;先看再点赞，给自己一点思考的时间，微信搜索【&lt;strong&gt;沉默王二&lt;/strong&gt;】关注这个靠才华苟且的程序员。&lt;br/&gt;本文 &lt;strong&gt;GitHub&lt;/strong&gt; &lt;a href=&quot;https://github.com/qinggee/itwanger.github.io&quot;&gt;github.com/itwanger&lt;/a&gt; 已收录，里面还有一线大厂整理的面试题，以及我的系列文章。&lt;/p&gt;
&lt;p&gt;二哥，你好，找工作找了仨月，还没有找到，很焦虑，我该怎么办呢？你那有没有 Java 方面的面试题可以分享一波啊？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以上是读者田田给我发的私信，看完后于我心有戚戚焉啊，最近境况确实不容乐观，并非是个人的原因造成的。那，既然需要面试题，二哥就义不容辞，必须得准备一波。&lt;/p&gt;
&lt;p&gt;这次我花了一周的时间，准备了 31 道 Java 核心面试题，希望能够帮助到田田，以及其他和田田类似情况的读者朋友。&lt;/p&gt;
&lt;p&gt;（后续我打算再花一周时间，更新第二波，同样有 31 道，敬请期待）&lt;/p&gt;
&lt;h3 id=&quot;h01java14&quot;&gt;&lt;span&gt;01、请说出 Java 14 版本中更新的重要功能&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;Java 14 发布于 2020 年 3 月 17 日，更新的重要功能有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;switch 表达式&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;instanceof 增强表达式，预览功能&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;文本块，第二次预览&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Records，预览功能&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;刚好我之前写过一篇文章，关于 Java 14 的开箱体验，很香，读者朋友需要的话，可以点下面的链接看一看。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/rJHWVdeGo-cHticD9wYEyw&quot;&gt;Java 14 开箱，它真香香香香&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;h02java13&quot;&gt;&lt;span&gt;02、请说出 Java 13 版本中更新的重要功能&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;Java 13 发布于 2019 年 9 月 17 日，更新的重要功能有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;文本块，预览功能&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;switch 表达式，预览功能&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Java Socket 重新实现&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;FileSystems.newFileSystem()&lt;/code&gt; 方法&lt;/li&gt;
&lt;li&gt;&lt;span&gt;支持 Unicode 12.1&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;可伸缩、低延迟的垃圾收集器改进，用于返回未使用的内存&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;h03java12&quot;&gt;&lt;span&gt;03、请说出 Java 12 版本中更新的重要功能&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;Java 12 发布于 2019 年 3 月 19 日，更新的重要功能有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;JVM 更新&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;File.mismatch()&lt;/code&gt; 方法&lt;/li&gt;
&lt;li&gt;&lt;span&gt;紧凑型数字格式&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;String 类新增了一些方法，比如说 &lt;code&gt;indent()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;h04java11&quot;&gt;&lt;span&gt;04、请说出 Java 11 版本中更新的重要功能&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;Java 11 是继 Java 8 之后的第二个商用版本，如果你下载的是 Oracle JDK，则需要进行付费；如果想继续使用免费版本，需要下载 Open JDK。&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/07/java-mianshiti-31-01.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;Oracle JDK 中会有一些 Open JDK 没有的、商用闭源的功能。&lt;/p&gt;
&lt;p&gt;Java 11 更新的重要功能有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;可以直接使用 &lt;code&gt;java&lt;/code&gt; 命令运行 Java 程序，源代码将会隐式编译和运行。&lt;/li&gt;
&lt;li&gt;String 类新增了一些方法，比如说 &lt;code&gt;isBlank()&lt;/code&gt;、&lt;code&gt;lines()&lt;/code&gt;、&lt;code&gt;strip()&lt;/code&gt; 等等。&lt;/li&gt;
&lt;li&gt;Files 类新增了两个读写方法，&lt;code&gt;readString()&lt;/code&gt; 和 &lt;code&gt;writeString()&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;span&gt;可以在 Lambda 表达式中使用 var 作为变量类型。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;h05java10&quot;&gt;&lt;span&gt;05、请说出 Java 10 版本中更新的重要功能&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;Java 10 更新的重要功能有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;局部变量类型推断，举个例子，&lt;code&gt;var list = new ArrayList();&lt;/code&gt;，可以使用 var 来作为变量类型，Java 编译器知道 list 的类型为字符串的 ArrayList。&lt;/li&gt;
&lt;li&gt;增强 &lt;code&gt;java.util.Locale&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;span&gt;提供了一组默认的根证书颁发机构（CA）。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;h06java9&quot;&gt;&lt;span&gt;06、请说出 Java 9 版本中更新的重要功能&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;Java 9 更新的重要功能有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;模块系统&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;不可变的 List、Set、Map 的工厂方法&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;接口中可以有私有方法&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;垃圾收集器改进&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;h07java8&quot;&gt;&lt;span&gt;07、请说出 Java 8 版本中更新的重要功能&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;Java 8 发布于 2014 年 3 月份，可以说是 Java 6 之后最重要的版本更新，深受开发者的喜爱。&lt;/p&gt;
&lt;p&gt;我强烈建议点开上面的链接阅读以下，以正确理解这些概念。&lt;/p&gt;
&lt;h3 id=&quot;h08java&quot;&gt;&lt;span&gt;08、请说出 Java 面向对象编程中的一些重要概念&lt;/span&gt;&lt;/h3&gt;
&lt;h3 id=&quot;h09java&quot;&gt;&lt;span&gt;09、Java 声称的平台独立性指的是什么？&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;常见的操作系统有 Windows、Linux、OS-X，那么平台独立性意味着我们可以在任何操作系统中运行相同源代码的 Java 程序，比如说我们可以在 Windows 上编写 Java 程序，然后在 Linux 上运行它。&lt;/p&gt;
&lt;h3 id=&quot;h10jvm&quot;&gt;&lt;span&gt;10、什么是 JVM？&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;JVM（Java Virtual Machine）俗称 Java 虚拟机。之所以称为虚拟机，是因为它实际上并不存在。它提供了一种运行环境，可供 Java 字节码在上面运行。&lt;/p&gt;
&lt;p&gt;JVM 提供了以下操作：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;加载字节码&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;验证字节码&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;执行字节码&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;提供运行时环境&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;JVM 定义了以下内容：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;存储区&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;类文件格式&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;寄存器组&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;垃圾回收堆&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;致命错误报告等&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们来尝试理解一下 JVM 的内部结构，它包含了类加载器（Class Loader）、运行时数据区（Runtime Data Areas）和执行引擎（Excution Engine）。&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/07/java-mianshiti-31-02.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;&lt;strong&gt;1）类加载器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;类加载器是 JVM 的一个子系统，用于加载类文件。每当我们运行一个 Java 程序，它都会由类加载器首先加载。Java 中有三个内置的类加载器：&lt;/p&gt;
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;启动类加载器（Bootstrap Class-Loader），加载 &lt;code&gt;jre/lib&lt;/code&gt; 包下面的 jar 文件，比如说常见的 rt.jar（包含了 Java 标准库下的所有类文件，比如说 &lt;code&gt;java.lang&lt;/code&gt; 包下的类，&lt;code&gt;java.net&lt;/code&gt; 包下的类，&lt;code&gt;java.util&lt;/code&gt; 包下的类，&lt;code&gt;java.io&lt;/code&gt; 包下的类，&lt;code&gt;java.sql&lt;/code&gt; 包下的类）。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;扩展类加载器（Extension or Ext Class-Loader），加载 &lt;code&gt;jre/lib/ext&lt;/code&gt; 包下面的 jar 文件。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;应用类加载器（Application or App Clas-Loader），根据程序的类路径（classpath）来加载 Java 类。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;一般来说，Java 程序员并不需要直接同类加载器进行交互。JVM 默认的行为就已经足够满足大多数情况的需求了。不过，如果遇到了需要和类加载器进行交互的情况，而对类加载器的机制又不是很了解的话，就不得不花大量的时间去调试&lt;br/&gt;&lt;code&gt;ClassNotFoundException&lt;/code&gt; 和 &lt;code&gt;NoClassDefFoundError&lt;/code&gt; 等异常。&lt;/p&gt;
&lt;p&gt;对于任意一个类，都需要由它的类加载器和这个类本身一同确定其在 JVM 中的唯一性。也就是说，如果两个类的加载器不同，即使两个类来源于同一个字节码文件，那这两个类就必定不相等（比如两个类的 Class 对象不 &lt;code&gt;equals&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;是不是有点晕，来来来，通过一段简单的代码了解下。&lt;/p&gt;
&lt;pre readability=&quot;4.5&quot;&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;3&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Test&lt;/span&gt; &lt;/span&gt;{&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;ClassLoader loader = Test.class.getClassLoader();&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (loader != &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;) {&lt;br/&gt;System.out.println(loader.toString());&lt;br/&gt;loader = loader.getParent();&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;每个 Java 类都维护着一个指向定义它的类加载器的引用，通过 &lt;code&gt;类名.class.getClassLoader()&lt;/code&gt; 可以获取到此引用；然后通过 &lt;code&gt;loader.getParent()&lt;/code&gt; 可以获取类加载器的上层类加载器。&lt;/p&gt;
&lt;p&gt;上面这段代码的输出结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs perl&quot;&gt;sun.misc.Launcher$AppClassLoader@18b4aac2&lt;br/&gt;sun.misc.Launcher$ExtClassLoader@4617c264&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第一行输出为 Test 的类加载器，即应用类加载器，它是 &lt;code&gt;sun.misc.Launcher$AppClassLoader&lt;/code&gt; 类的实例；第二行输出为扩展类加载器，是 &lt;code&gt;sun.misc.Launcher$ExtClassLoader&lt;/code&gt; 类的实例。那启动类加载器呢？&lt;/p&gt;
&lt;p&gt;按理说，扩展类加载器的上层类加载器是启动类加载器，但在我这个版本的 JDK 中， 扩展类加载器的 &lt;code&gt;getParent()&lt;/code&gt; 返回 &lt;code&gt;null&lt;/code&gt;。所以没有输出。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2）运行时数据区&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;运行时数据区又包含以下内容。&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/07/java-mianshiti-31-03.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;ul readability=&quot;8.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;PC寄存器（PC Register），也叫程序计数器（Program Counter Register），是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的信号指示器。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;JVM 栈（Java Virtual Machine Stack），与 PC 寄存器一样，JVM 栈也是线程私有的。每一个 JVM 线程都有自己的 JVM 栈，这个栈与线程同时创建，它的生命周期与线程相同。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;本地方法栈（Native Method Stack），JVM 可能会使用到传统的栈来支持 Native 方法（使用 Java 语言以外的其它语言［C语言］编写的方法）的执行，这个栈就是本地方法栈。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;堆（Heap），在 JVM 中，堆是可供各条线程共享的运行时内存区域，也是供所有类实例和数据对象分配内存的区域。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;方法区（Method area），在 JVM 中，被加载类型的信息都保存在方法区中。包括类型信息（Type Information）和方法列表（Method Tables）。方法区是所有线程共享的，所以访问方法区信息的方法必须是线程安全的。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;运行时常量池（Runtime Constant Pool），运行时常量池是每一个类或接口的常量池在运行时的表现形式，它包括了编译器可知的数值字面量，以及运行期解析后才能获得的方法或字段的引用。简而言之，当一个方法或者变量被引用时，JVM 通过运行时常量区来查找方法或者变量在内存里的实际地址。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;3）执行引擎&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;执行引擎包含了：&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;解释器：读取字节码流，然后执行指令。因为它一条一条地解释和执行指令，所以它可以很快地解释字节码，但是执行起来会比较慢。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;即时（Just-In-Time，JIT）编译器：即时编译器用来弥补解释器的缺点，提高性能。执行引擎首先按照解释执行的方式来执行，然后在合适的时候，即时编译器把整段字节码编译成本地代码。然后，执行引擎就没有必要再去解释执行方法了，它可以直接通过本地代码去执行。执行本地代码比一条一条进行解释执行的速度快很多。编译后的代码可以执行的很快，因为本地代码是保存在缓存里的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;h11jdkjvm&quot;&gt;&lt;span&gt;11、JDK 和 JVM 有什么区别？&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;JDK 是 Java Development Kit 的首字母缩写，是提供给 Java 开发人员的软件环境，包含 JRE 和一组开发工具。可分为以下版本：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;标准版（大多数开发人员用的就是这个）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;企业版&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;微型版&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;JDK 包含了一个私有的 JVM 和一些其他资源，比如说编译器（javac 命令）、解释器（java 命令）等，帮助 Java 程序员完成开发工作。&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/07/java-mianshiti-31-04.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;h3 id=&quot;h12jvmjre&quot;&gt;&lt;span&gt;12、JVM 和 JRE 有什么区别？&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;Java Runtime Environment（JRE）是 JVM 的实现。JRE 由 JVM 和 Java 二进制文件以及其他类组成，可以执行任何程序。JRE 不包含 Java 编译器，调试器等任何开发工具。&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/07/java-mianshiti-31-05.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;h3 id=&quot;h13&quot;&gt;&lt;span&gt;13、哪个类是所有类的超类？&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;java.lang.Object&lt;/code&gt; 是所有 Java 类的超类，我们不需要继承它，因为是隐式继承的。&lt;/p&gt;
&lt;h3 id=&quot;h14java&quot;&gt;&lt;span&gt;14、为什么 Java 不支持多重继承？&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;如果有两个类共同继承（extends）一个有特定方法的父类，那么该方法会被两个子类重写。然后，如果你决定同时继承这两个子类，那么在你调用该重写方法时，编译器不能识别你要调用哪个子类的方法。这也正是著名的菱形问题，见下图。&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/07/java-mianshiti-31-06.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;ClassC 同时继承了 ClassA 和 ClassB，ClassC 的对象在调用 ClassA 和 ClassB 中重载的方法时，就不知道该调用 ClassA 的方法，还是 ClassB 的方法。&lt;/p&gt;
&lt;h3 id=&quot;h15java&quot;&gt;&lt;span&gt;15、为什么 Java 不是纯粹的面向对象编程语言？&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;之所以不能说 Java 是纯粹的面向对象编程语言，是因为 Java 支持基本数据类型，比如说 int、short、long、double 等，尽管它们有自己的包装器类型，但它们的确不能算是对象。&lt;/p&gt;
&lt;h3 id=&quot;h16pathclasspath&quot;&gt;&lt;span&gt;16、path 和 classpath 之间有什么区别？&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;path 是操作系统用来查找可执行文件的环境变量，我的电脑上就定义了下图这些 path 变量，比如 Java 和 Maven 的。&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/07/java-mianshiti-31-07.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;classpath 是针对 Java 而言的，用于指定 Java 虚拟机载入的字节码文件路径。&lt;/p&gt;
&lt;h3 id=&quot;h17javamain&quot;&gt;&lt;span&gt;17、Java 中 `main()` 方法的重要性是什么？&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;每个程序都需要一个入口，对于 Java 程序来说，入口就是 main 方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;public 关键字是另外一个访问修饰符，除了可以声明方法和变量（所有类可见），还可以声明类。&lt;code&gt;main()&lt;/code&gt; 方法必须声明为 public。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;static 关键字表示该变量或方法是静态变量或静态方法，可以直接通过类访问，不需要实例化对象来访问。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;void 关键字用于指定方法没有返回值。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;另外，main 关键字为方法的名字，Java 虚拟机在执行程序时会寻找这个标识符；args 为 &lt;code&gt;main()&lt;/code&gt; 方法的参数名，它的类型为一个 String 数组，也就是说，在使用 java 命令执行程序的时候，可以给 &lt;code&gt;main()&lt;/code&gt; 方法传递字符串数组作为参数。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs nginx&quot;&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;java&lt;/span&gt; HelloWorld 沉默王二 沉默王三&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;javac 命令用来编译程序，java 命令用来执行程序，HelloWorld 为这段程序的类名，沉默王二和沉默王三为字符串数组，中间通过空格隔开，然后就可以在 &lt;code&gt;main()&lt;/code&gt; 方法中通过 &lt;code&gt;args[0]&lt;/code&gt; 和 &lt;code&gt;args[1]&lt;/code&gt; 获取传递的参数值了。&lt;/p&gt;
&lt;pre readability=&quot;4&quot;&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;2&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;HelloWorld&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;hljs-string&quot;&gt;&quot;沉默王二&quot;&lt;/span&gt;.equals(args[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;])) {&lt;p&gt;}&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;hljs-string&quot;&gt;&quot;沉默王三&quot;&lt;/span&gt;.equals(args[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;])) {&lt;/p&gt;&lt;p&gt;}&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;main()&lt;/code&gt; 方法的写法并不是唯一的，还有其他几种变体，尽管它们可能并不常见，可以简单来了解一下。&lt;/p&gt;
&lt;p&gt;第二种，把方括号 &lt;code&gt;[]&lt;/code&gt; 往 args 靠近而不是 String 靠近：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String []args)&lt;/span&gt; &lt;/span&gt;{ }&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第三种，把方括号 &lt;code&gt;[]&lt;/code&gt; 放在 args 的右侧：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String args[])&lt;/span&gt; &lt;/span&gt;{ }&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第四种，还可以把数组形式换成可变参数的形式：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String...args)&lt;/span&gt; &lt;/span&gt;{ }&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第五种，在 &lt;code&gt;main()&lt;/code&gt; 方法上添加另外一个修饰符 &lt;code&gt;strictfp&lt;/code&gt;，用于强调在处理浮点数时的兼容性：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;strictfp&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{ }&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也可以在 &lt;code&gt;main()&lt;/code&gt; 方法上添加 final 关键字或者 synchronized 关键字。&lt;/p&gt;
&lt;p&gt;第六种，还可以为 args 参数添加 final 关键字：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;final&lt;/span&gt; String[] args)&lt;/span&gt; &lt;/span&gt;{ }&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第七种，最复杂的一种，所有可以添加的关键字统统添加上：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;strictfp&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;final&lt;/span&gt; String[] args)&lt;/span&gt; &lt;/span&gt;{ }&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然了，并不需要为了装逼特意把 &lt;code&gt;main()&lt;/code&gt; 方法写成上面提到的这些形式，使用 IDE 提供的默认形式就可以了。&lt;/p&gt;
&lt;h3 id=&quot;h18javaoverrideoverload&quot;&gt;&lt;span&gt;18、Java 的重写（Override）和重载（Overload）有什么区别？&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;先来看一段重写的代码吧。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;LaoWang&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;老王写了一本《基督山伯爵》&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;XiaoWang&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;LaoWang&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;小王写了一本《茶花女》&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;重写的两个方法名相同，方法参数的个数也相同；不过一个方法在父类中，另外一个在子类中。就好像父类 LaoWang 有一个 &lt;code&gt;write()&lt;/code&gt; 方法（无参），方法体是写一本《基督山伯爵》；子类 XiaoWang 重写了父类的 &lt;code&gt;write()&lt;/code&gt; 方法（无参），但方法体是写一本《茶花女》。&lt;/p&gt;
&lt;p&gt;来写一段测试代码。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;OverridingTest&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;LaoWang wang = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; XiaoWang();&lt;br/&gt;wang.write();&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;大家猜结果是什么？&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs&quot;&gt;小王写了一本《茶花女》&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在上面的代码中，们声明了一个类型为 LaoWang 的变量 wang。在编译期间，编译器会检查 LaoWang 类是否包含了 &lt;code&gt;write()&lt;/code&gt; 方法，发现 LaoWang 类有，于是编译通过。在运行期间，new 了一个 XiaoWang 对象，并将其赋值给 wang，此时 Java 虚拟机知道 wang 引用的是 XiaoWang 对象，所以调用的是子类 XiaoWang 中的 &lt;code&gt;write()&lt;/code&gt; 方法而不是父类 LaoWang 中的 &lt;code&gt;write()&lt;/code&gt; 方法，因此输出结果为“小王写了一本《茶花女》”。&lt;/p&gt;
&lt;p&gt;再来看一段重载的代码吧。&lt;/p&gt;
&lt;pre readability=&quot;4.5&quot;&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;3&quot;&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;LaoWang&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;老王读了一本《Web全栈开发进阶之路》&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String bookname)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;老王读了一本《&quot;&lt;/span&gt; + bookname + &lt;span class=&quot;hljs-string&quot;&gt;&quot;》&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;重载的两个方法名相同，但方法参数的个数不同，另外也不涉及到继承，两个方法在同一个类中。就好像类 LaoWang 有两个方法，名字都是 &lt;code&gt;read()&lt;/code&gt;，但一个有参数（书名），另外一个没有（只能读写死的一本书）。&lt;/p&gt;
&lt;p&gt;来写一段测试代码。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;OverloadingTest&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;LaoWang wang = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; LaoWang();&lt;br/&gt;wang.read();&lt;br/&gt;wang.read(&lt;span class=&quot;hljs-string&quot;&gt;&quot;金瓶&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这结果就不用猜了。变量 wang 的类型为 LaoWang，&lt;code&gt;wang.read()&lt;/code&gt; 调用的是无参的 &lt;code&gt;read()&lt;/code&gt; 方法，因此先输出“老王读了一本《Web全栈开发进阶之路》”；&lt;code&gt;wang.read(&quot;金瓶&quot;)&lt;/code&gt; 调用的是有参的 &lt;code&gt;read(bookname)&lt;/code&gt; 方法，因此后输出“老王读了一本《金瓶》”。在编译期间，编译器就知道这两个 &lt;code&gt;read()&lt;/code&gt; 方法时不同的，因为它们的方法签名（=方法名称+方法参数）不同。&lt;/p&gt;
&lt;p&gt;简单的来总结一下：&lt;/p&gt;
&lt;p&gt;1）编译器无法决定调用哪个重写的方法，因为只从变量的类型上是无法做出判断的，要在运行时才能决定；但编译器可以明确地知道该调用哪个重载的方法，因为引用类型是确定的，参数个数决定了该调用哪个方法。&lt;/p&gt;
&lt;p&gt;2）多态针对的是重写，而不是重载。&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/07/java-mianshiti-31-08.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;如果在一个类中有多个相同名字的方法，但参数不同，则称为方法重载。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;父类中有一个方法，子类中有另外一个和它有相同签名（方法名相同，参数相同、修饰符相同）的方法时，则称为方法重写。子类在重写父类方法的时候可以加一个 &lt;code&gt;@Override&lt;/code&gt; 注解。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;h19main&quot;&gt;&lt;span&gt;19、`main()` 方法可以重载吗？&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;可以，一个类中可以有多个名称为“main”的方法：&lt;/p&gt;
&lt;pre readability=&quot;5.5&quot;&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;5&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;MainTest&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;main(String[] args)&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String[] args,String arg)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;(String[] args,String arg&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但该类在运行的时候，只会找到一个入口，即 &lt;code&gt;public static void main(String[] args)&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;h20javapublic&quot;&gt;&lt;span&gt;20、一个 Java 源文件中有多个 public 类吗？&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;一个 Java 源文件中不能有多个 public 类。&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/07/java-mianshiti-31-09.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;h3 id=&quot;h21javapackage&quot;&gt;&lt;span&gt;21、什么是 Java 的 package（包）？&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;在 Java 中，我们使用 package（包）对相关的类、接口和子包进行分组。这样做的好处有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;使相关类型更容易查找&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;避免命名冲突，比如说 com.itwanger.Hello 和 com.itwangsan.Hello 不同&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;通过包和访问权限控制符来限定类的可见性&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;可以使用 package 关键字来定义一个包名，需要注意的是，这行代码必须处于一个类中的第一行。强烈建议在包中声明类，不要缺省，否则就失去了包结构的带来的好处。&lt;/p&gt;
&lt;p&gt;包的命名应该遵守以下规则：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;应该全部是小写字母&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;可以包含多个单词，单词之间使用“.”连接，比如说 &lt;code&gt;java.lang&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;名称由公司名或者组织名确定，采用倒序的方式，比如说，我个人博客的域名是 &lt;code&gt;www.itwanger.com&lt;/code&gt;，所以我创建的包名是就是 &lt;code&gt;com.itwanger.xxxx&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;每个包或者子包都在磁盘上有自己的目录结构，如果 Java 文件时在 &lt;code&gt;com.itwanger.xxxx&lt;/code&gt; 包下，那么该文件所在的目录结构就应该是 &lt;code&gt;com-&amp;gt;itwanger-&amp;gt;xxxx&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;默认情况下，&lt;code&gt;java.lang&lt;/code&gt; 包是默认导入的，我们不需要显式地导入该包下的任何类。&lt;/p&gt;
&lt;pre readability=&quot;4&quot;&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;2&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;package&lt;/span&gt; com.cmower.bb;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;PackageTest&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;Boolean.toString(&lt;span class=&quot;hljs-keyword&quot;&gt;true&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Boolean 类属于 &lt;code&gt;java.lang&lt;/code&gt; 包，当使用它的时候并不需要显式导入。&lt;/p&gt;
&lt;h3 id=&quot;h22&quot;&gt;&lt;span&gt;22、什么是访问权限修饰符？&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;访问权限修饰符对于 Java 来说，非常重要，目前共有四种：public、private、protected 和 default（缺省）。&lt;/p&gt;
&lt;p&gt;一个类只能使用 &lt;code&gt;public&lt;/code&gt; 或者 &lt;code&gt;default&lt;/code&gt; 修饰，public 修饰的类你之前已经见到过了，现在我来定义一个缺省权限修饰符的类给你欣赏一下。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Dog&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;哈哈，其实也没啥可以欣赏的。缺省意味着这个类可以被同一个包下的其他类进行访问；而 public 意味着这个类可以被所有包下的类进行访问。&lt;/p&gt;
&lt;p&gt;假如硬要通过 private 和 protected 来修饰类的话，编译器会生气的，它不同意。&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/07/java-mianshiti-31-10.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;private 可以用来修饰类的构造方法、字段和方法，只能被当前类进行访问。protected 也可以用来修饰类的构造方法、字段和方法，但它的权限范围更宽一些，可以被同一个包中的类进行访问，或者当前类的子类。&lt;/p&gt;
&lt;p&gt;可以通过下面这张图来对比一下四个权限修饰符之间的差别：&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/07/java-mianshiti-31-11.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;ul&gt;&lt;li&gt;&lt;span&gt;同一个类中，不管是哪种权限修饰符，都可以访问；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;同一个包下，private 修饰的无法访问；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;子类可以访问 public 和 protected 修饰的；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;public 修饰符面向世界，哈哈，可以被所有的地方访问到。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;h23final&quot;&gt;&lt;span&gt;23、什么是 final 关键字？&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;final 关键字修饰类的时候，表示该类无法被继承。比如，String 类就是 final 的，无法被继承。&lt;/p&gt;
&lt;p&gt;final 关键字修饰方法的时候，表示子类无法覆盖它。&lt;/p&gt;
&lt;p&gt;final 关键字修饰变量的时候，表示该变量只能被赋值一次，尽管变量的状态可以更改。&lt;/p&gt;
&lt;p&gt;关于 final 更详细的内容，可以参照我之前写了另外一篇文章：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/_Xhgk1su7drlsBfUPCC1xg&quot;&gt;我去，你竟然还不会用 final 关键字&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;h24static&quot;&gt;&lt;span&gt;24、什么是 static 关键字？&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;static 关键字可以用来修饰类变量，使其具有全局性，即所有对象将共享同一个变量。&lt;/p&gt;
&lt;p&gt;static 关键字可以用来修饰方法，该方法称为静态方法，只可以访问类的静态变量，并且只能调用类的静态方法。&lt;/p&gt;
&lt;p&gt;关于 static 更详细的内容，可以参照我之前写了另外一篇文章：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/24EdEt3UyP7aKZStvvuDgQ&quot;&gt;面试官：兄弟，说说Java的static关键字吧&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;h25finallyfinalize&quot;&gt;&lt;span&gt;25、finally 和 finalize 有什么区别？&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;finally 通常与 try-catch 块一起使用，即使 try-catch 块引发了异常，finally 块中的代码也会被执行，用于释放 try 块中创建的资源。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;finalize()&lt;/code&gt; 是 Object 类的一个特殊方法，当对象正在被垃圾回收时，垃圾收集器将会调用该方法。可以重写该方法用于释放系统资源。&lt;/p&gt;
&lt;h3 id=&quot;h26static&quot;&gt;&lt;span&gt;26、可以将一个类声明为 static 的吗？&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;不能将一个外部类声明为 static 的，但可以将一个内部类声明为 static 的——称为静态内部类。&lt;/p&gt;
&lt;h3 id=&quot;h27&quot;&gt;&lt;span&gt;27、什么是静态导入？&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;如果必须在一个类中使用其他类的静态变量或者静态方法，通常我们需要先导入该类，然后使用“类名.变量/方法”的形式调用。&lt;/p&gt;
&lt;pre readability=&quot;4&quot;&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;2&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; java.lang.Math;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;double&lt;/span&gt; test = Math.PI * &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;;&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也可以通过静态导入的方式，就不需要再使用类名了。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; java.lang.Math.PI;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;double&lt;/span&gt; test = PI * &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;;&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不过，静态导入容易引发混乱（变量名或者方法名容易冲突），因此最好避免使用静态导入。&lt;/p&gt;
&lt;h3 id=&quot;h28trywithresources&quot;&gt;&lt;span&gt;28、什么是 try-with-resources？&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;try-with-resources 是 Java 7 时引入的一个自动资源管理语句，在此之前，我们必须通过 try-catch-finally 的方式手动关闭资源，当我们忘记关闭资源的时候，就容易导致内存泄漏。&lt;/p&gt;
&lt;p&gt;关于 try-with-resources 更详细的内容，可以参照我之前写了另外一篇文章：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/fbTzH5B7mSr5v0tQ8mV2wA&quot;&gt;我去，你竟然还在用 try–catch-finally&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;h29multicatch&quot;&gt;&lt;span&gt;29、什么是 multi-catch？&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;Java 7 改进的另外一个地方就是 multi-catch，可以在单个 catch 中捕获多个异常，当一个 try 块抛出多个类似的异常时，这种写法更短，更清晰。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;catch&lt;/span&gt;(IOException | SQLException ex){&lt;br/&gt;logger.error(ex);&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; MyException(ex.getMessage());&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当有多个异常的时候，可以使用管道表示符“|”隔开。&lt;/p&gt;
&lt;h3 id=&quot;h30static&quot;&gt;&lt;span&gt;30、什么是 static 块？&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;static 块是由 Java ClassLoader 将类加载到内存中时执行的代码块。通常用于初始化类的静态变量或者创建静态资源。&lt;/p&gt;
&lt;h3 id=&quot;h31&quot;&gt;&lt;span&gt;31、什么是接口？&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;接口是 Java 编程语言中的一个核心概念，不仅在 JDK 源码中使用很多，还在 Java 设计模式、框架和工具中使用很多。接口提供了一种在 Java 中实现抽象的方法，用于定义子类的行为约定。&lt;/p&gt;
&lt;p&gt;关于接口更详细的内容，可以参照我之前写了另外一篇文章：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/06d5Fk_ho4yafR83mfbWag&quot;&gt;可能是把 Java 接口讲得最通俗的一篇文章&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;h&quot;&gt;&lt;span&gt;鸣谢&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;说句实在话，这 31 道 Java 核心面试题在面试的过程中还是很常见的，值得好好复习一遍。关键是还有下一波，同样 31 道，望眼欲穿吧？&lt;/p&gt;
&lt;p&gt;好了，我亲爱的小伙伴们，能看到这里绝逼是最优秀的程序员，二哥必须伸出帅气的大拇指为你点个赞！&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;我是沉默王二，一枚有颜值却靠才华苟且的程序员。&lt;strong&gt;关注即可提升学习效率，别忘了三连啊，点赞、收藏、留言，我不挑，奥利给&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;注：如果文章有任何问题，欢迎毫不留情地指正。&lt;/p&gt;
&lt;p&gt;很多读者都同情我说，“二哥母猪似的日更原创累不累？”我只能说写作不易，且行且珍惜啊，欢迎微信搜索「&lt;strong&gt;沉默王二&lt;/strong&gt;」第一时间阅读，回复「&lt;strong&gt;简历&lt;/strong&gt;」更有我精心为你准备的简历模板，本文 &lt;strong&gt;GitHub&lt;/strong&gt; &lt;a href=&quot;https://github.com/qinggee/itwanger.github.io&quot;&gt;github.com/itwanger&lt;/a&gt; 已收录，欢迎 star。&lt;/p&gt;
</description>
<pubDate>Tue, 07 Jul 2020 00:14:00 +0000</pubDate>
<dc:creator>沉默王二</dc:creator>
<og:description>先看再点赞，给自己一点思考的时间，微信搜索【沉默王二】关注这个靠才华苟且的程序员。本文 GitHub github.com/itwanger 已收录，里面还有一线大厂整理的面试题，以及我的系列文章。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qing-gee/p/13258782.html</dc:identifier>
</item>
<item>
<title>【Flutter 实战】动画核心 - 老孟Flutter</title>
<link>http://www.cnblogs.com/mengqd/p/13258725.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mengqd/p/13258725.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200707071106906-1072612261.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;老孟导读：动画系统是任何一个UI框架的核心功能，也是开发者学习一个UI框架的重中之重，同时也是比较难掌握的一部分，下面我们就一层一层的揭开 Flutter 动画的面纱。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;任何程序的动画原理都是一样的，即：视觉暂留，视觉暂留又叫视觉暂停，人眼在观察景物时，光信号传入大脑神经，需经过一段短暂的时间，光的作用结束后，视觉形象并不立即消失，这种残留的视觉称“后像”，视觉的这一现象则被称为“视觉暂留”。&lt;/p&gt;
&lt;p&gt;人眼能保留0.1-0.4秒左右的图像，所以在 1 秒内看到连续的25张图像，人就会感到画面流畅，而 1 秒内看到连续的多少张图像称为 帧率，即 &lt;strong&gt;FPS&lt;/strong&gt;，理论上 达到 24 FPS 画面比较流畅，而Flutter，理论上可以达到 60 FPS。&lt;/p&gt;
&lt;h3 id=&quot;animationcontroller&quot;&gt;AnimationController&lt;/h3&gt;
&lt;p&gt;介绍完了动画系统的基本原理，实现一个蓝色盒子大小从 100 变为 200动画效果：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;class AnimationBaseDemo extends StatefulWidget {
  @override
  _AnimationBaseDemoState createState() =&amp;gt; _AnimationBaseDemoState();
}

class _AnimationBaseDemoState extends State&amp;lt;AnimationBaseDemo&amp;gt; {
  double _size = 100;

  @override
  Widget build(BuildContext context) {
    return Center(
      child: GestureDetector(
        onTap: () {
          setState(() {
            _size = 200;
          });
        },
        child: Container(
          height: _size,
          width: _size,
          color: Colors.blue,
          alignment: Alignment.center,
          child: Text('点我变大',style: TextStyle(color: Colors.white,fontSize: 18),),
        ),
      ),
    );
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200707071107340-1556653587.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;虽然变大了，但并没有动画效果，而是直接变大的，想要使其一点点放大需要引入 &lt;strong&gt;AnimationController&lt;/strong&gt;，它是动画控制器，控制动画的启动、停止，还可以获取动画的运行状态，AnimationController 通常在 initState 方法中初始化：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;class _AnimationBaseDemoState extends State&amp;lt;AnimationBaseDemo&amp;gt; with SingleTickerProviderStateMixin{
  double _size = 100;
  AnimationController _controller;

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(vsync: this,duration: Duration(milliseconds: 500));
  }
  ...
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里有两个参数需要设置：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;vsync&lt;/strong&gt;：当创建 AnimationController 时，需要传递一个&lt;code&gt;vsync&lt;/code&gt;参数，存在&lt;code&gt;vsync&lt;/code&gt;时会防止屏幕外动画消耗不必要的资源，单个 AnimationController 的时候使用 &lt;strong&gt;SingleTickerProviderStateMixin&lt;/strong&gt;，多个 AnimationController 使用 &lt;strong&gt;TickerProviderStateMixin&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;duration&lt;/strong&gt;：表示动画执行的时间。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;修改如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;class _AnimationBaseDemoState extends State&amp;lt;AnimationBaseDemo&amp;gt; with SingleTickerProviderStateMixin{
  double _size = 100;
  AnimationController _controller;

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(vsync: this,duration: Duration(milliseconds: 500));
  }

  @override
  Widget build(BuildContext context) {
    return Center(
      child: GestureDetector(
        onTap: () {
          _controller.forward();
        },
        child: Container(
          height: _size,
          width: _size,
          color: Colors.blue,
          alignment: Alignment.center,
          child: Text('点我变大',style: TextStyle(color: Colors.white,fontSize: 18),),
        ),
      ),
    );
  }
  
  @override
  void dispose() {
    super.dispose();
    _controller.dispose();
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;点击蓝色盒子的时候不再直接更改大小，而是执行动画&lt;code&gt;_controller.forward()&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;另外在State &lt;strong&gt;dispose&lt;/strong&gt; 生命周期中释放 AnimationController。&lt;/p&gt;
&lt;p&gt;此时点击蓝色盒子发现并不会变大，StatefulWidget 组件改变外观需要调用 &lt;code&gt;setState&lt;/code&gt;，因此给 AnimationController 添加监听：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;_controller = AnimationController(vsync: this,duration: Duration(milliseconds: 500))
..addListener(() {
  setState(() {
    _size = 100+100*_controller.value;
  });
});
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;每一帧都会回调&lt;strong&gt;addListener&lt;/strong&gt; ，在此回调中设置蓝色盒子大小，蓝色的大小是由 100 变到 200，而 AnimationController 的值默认是 0 到 1，所以蓝色大小等于 _size = 100+100*_controller.value，运行效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200707071107534-2118000071.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这就是 Flutter 中最简单动画的实现方式，其中最重要的就是 &lt;strong&gt;AnimationController&lt;/strong&gt;，_controller.value 是当前动画的值，默认从 0 到 1。也可以通过参数形式设置最大值和最小值：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;_controller = AnimationController(vsync: this,duration: Duration(milliseconds: 500),lowerBound: 100,upperBound: 200)
..addListener(() {
  setState(() {
    _size = _controller.value;
  });
})
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时 _controller.value 的值就是从 100变化到 200。&lt;/p&gt;
&lt;p&gt;除了使用 addListener 监听每一帧，还可以监听动画状态的变化：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;_controller = AnimationController(
    vsync: this,
    duration: Duration(milliseconds: 500),
    lowerBound: 100,
    upperBound: 200)
  ..addStatusListener((status) {
    print('status:$status');
  })
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;动画的状态分为四种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;dismissed&lt;/strong&gt;：动画停止在开始处。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;forward&lt;/strong&gt;：动画正在从开始处运行到结束处（正向运行）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;reverse&lt;/strong&gt;：动画正在从结束处运行到开始处（反向运行）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;completed&lt;/strong&gt;：动画停止在结束处。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;再来看下动画的控制方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;forward&lt;/strong&gt;：正向执行动画。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;reverse&lt;/strong&gt;：反向执行动画。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;repeat&lt;/strong&gt;：反复执行动画。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;reset&lt;/strong&gt;：重置动画。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;forward 和 reverse 方法中都有 from 参数，这个参数的意义是一样的，表示动画从此值开始执行，而不再是从lowerBound 到 upperBound。比如上面的例子中 from 参数设置 150，那么执行动画时，蓝色盒子瞬间变为 150，然后再慢慢变大到200。&lt;/p&gt;
&lt;p&gt;让蓝色盒子大小从 100 到 200，然后再变到 100，再到 200，如此反复：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;_controller = AnimationController(
    vsync: this,
    duration: Duration(milliseconds: 500),
    lowerBound: 100,
    upperBound: 200)
  ..addStatusListener((AnimationStatus status) {
    if(status == AnimationStatus.completed){
      _controller.reverse();
    }else if(status == AnimationStatus.dismissed){
      _controller.forward();
    }
  })
  ..addListener(() {
    setState(() {
      _size = _controller.value;
    });
  });
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;只需监听动画状态变化，在动画结束后再正向/反向再次执行动画。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200707071107723-817590103.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;虽然上面讲了很多，但只有一个重点 &lt;strong&gt;AnimationController&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;AnimationController&lt;/strong&gt; 设置的最小/大值类型是 double，如果动画的变化是颜色要如何处理？&lt;/p&gt;
&lt;p&gt;AnimationController 在执行动画期间返回的值是 0 到 1，颜色从蓝色变为红色方法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;_controller =
    AnimationController(vsync: this, duration: Duration(milliseconds: 500))
      ..addListener(() {
        setState(() {
          _color = Color.lerp(_startColor, _endColor, _controller.value);
        });
      });
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;重点是 &lt;strong&gt;Color.lerp&lt;/strong&gt; 方法，此方法是在两种颜色之间线性插值。&lt;/p&gt;
&lt;p&gt;完整代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;class TweenDemo extends StatefulWidget {
  @override
  _TweenDemoState createState() =&amp;gt; _TweenDemoState();
}

class _TweenDemoState extends State&amp;lt;TweenDemo&amp;gt;
    with SingleTickerProviderStateMixin {
  AnimationController _controller;
        Color _startColor = Colors.blue;
  Color _endColor = Colors.red;

  Color _color = Colors.blue;

  @override
  void initState() {
    super.initState();
    _controller =
        AnimationController(vsync: this, duration: Duration(milliseconds: 500))
          ..addListener(() {
            setState(() {
              _color = Color.lerp(_startColor, _endColor, _controller.value);
            });
          });
  }

  @override
  Widget build(BuildContext context) {
    return Center(
      child: GestureDetector(
        onTap: () {
          _controller.forward();
        },
        child: Container(
          height: 100,
          width: 100,
          color: _color,
          alignment: Alignment.center,
          child: Text(
            '点我变色',
            style: TextStyle(color: Colors.white, fontSize: 18),
          ),
        ),
      ),
    );
  }

  @override
  void dispose() {
    super.dispose();
    _controller.dispose();
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200707071107892-571389614.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Flutter 中把这种从 0 -&amp;gt; 1 转换为 蓝色 -&amp;gt; 红色 行为称之为 &lt;strong&gt;Tween（映射）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;使用 Tween 完成动画 蓝色 -&amp;gt; 红色：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;class _TweenDemoState extends State&amp;lt;TweenDemo&amp;gt;
    with SingleTickerProviderStateMixin {
  AnimationController _controller;
  Animation&amp;lt;Color&amp;gt; _animation;

  @override
  void initState() {
    super.initState();
    _controller =
        AnimationController(vsync: this, duration: Duration(milliseconds: 500))
          ..addListener(() {
            setState(() {});
          });
    _animation =
        ColorTween(begin: Colors.blue, end: Colors.red).animate(_controller);
  }

  @override
  Widget build(BuildContext context) {
    return Center(
      child: GestureDetector(
        onTap: () {
          _controller.forward();
        },
        child: Container(
          height: 100,
          width: 100,
          color: _animation.value,
          alignment: Alignment.center,
          child: Text(
            '点我变色',
            style: TextStyle(color: Colors.white, fontSize: 18),
          ),
        ),
      ),
    );
  }

  @override
  void dispose() {
    super.dispose();
    _controller.dispose();
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果和上面是一样的。&lt;/p&gt;
&lt;p&gt;Tween 仅仅是映射，动画的控制依然由 AnimationController 控制，因此需要 &lt;strong&gt;Tween.animate(_controller)&lt;/strong&gt; 将控制器传递给Tween。&lt;/p&gt;
&lt;p&gt;系统提供了大量的 Tween：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200707071108041-1781946819.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;基本上常用的属性都包含了其对应的 Tween，看一下 ColorTween 的源代码实现：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200707071108202-267874348.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;本质上也是使用 &lt;strong&gt;Color.lerp&lt;/strong&gt; 实现的。&lt;/p&gt;
&lt;h3 id=&quot;curve&quot;&gt;Curve&lt;/h3&gt;
&lt;p&gt;动画中还有一个重要的概念就是 &lt;strong&gt;Curve&lt;/strong&gt;，即动画执行曲线。Curve 的作用和 Android 中的 Interpolator（差值器）是一样的，负责控制动画变化的速率，通俗地讲就是使动画的效果能够以匀速、加速、减速、抛物线等各种速率变化。&lt;/p&gt;
&lt;p&gt;蓝色盒子大小 100 变大到 200，动画曲线设置为 &lt;strong&gt;bounceIn（弹簧效果）&lt;/strong&gt; ：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;class CurveDemo extends StatefulWidget {
  @override
  _CurveDemoState createState() =&amp;gt; _CurveDemoState();
}

class _CurveDemoState extends State&amp;lt;CurveDemo&amp;gt;
    with SingleTickerProviderStateMixin {
  AnimationController _controller;
  Animation _animation;

  @override
  void initState() {
    super.initState();
    _controller =
        AnimationController(vsync: this, duration: Duration(milliseconds: 1000))
          ..addListener(() {
            setState(() {});
          });

    _animation = Tween(begin: 100.0, end: 200.0)
        .chain(CurveTween(curve: Curves.bounceIn))
        .animate(_controller);
  }

  @override
  Widget build(BuildContext context) {
    return Center(
      child: GestureDetector(
        onTap: () {
          _controller.forward();
        },
        child: Container(
          height: _animation.value,
          width: _animation.value,
          color: Colors.blue,
          alignment: Alignment.center,
          child: Text(
            '点我变大',
            style: TextStyle(color: Colors.white, fontSize: 18),
          ),
        ),
      ),
    );
  }

  @override
  void dispose() {
    super.dispose();
    _controller.dispose();
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200707071108400-762945343.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;动画加上&lt;strong&gt;Curve&lt;/strong&gt; 后，AnimationController 的最小/大值必须是 [0,1]之间，例如下面的写法就是错误的：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;_controller =
    AnimationController(vsync: this, duration: Duration(milliseconds: 1000),lowerBound: 100.0,upperBound: 200.0)
      ..addListener(() {
        setState(() {});
      });
_animation = CurveTween(curve: Curves.bounceIn).animate(_controller);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;抛出如下异常：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200707071108554-60918344.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;正确写法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;_controller =
        AnimationController(vsync: this, duration: Duration(milliseconds: 1000))
          ..addListener(() {
            setState(() {});
          });

    _animation = Tween(begin: 100.0, end: 200.0)
        .chain(CurveTween(curve: Curves.bounceIn))
        .animate(_controller);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;系统已经提供了38种常用到动画曲线：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;linear&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200707071108735-713289056.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;decelerate&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200707071108927-389932815.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;bounceIn&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200707071109154-83082856.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;bounceOut&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200707071109394-1027736048.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;elasticIn&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200707071109611-1053176966.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其余动画效果可以官方文档查看。&lt;/p&gt;
&lt;p&gt;通常情况下，这些曲线能够满足 99.99% 的需求，很多时候设计也就是告诉你动画 先快后慢 或者 先慢后快，所以选个类似的就可以了，但有一些 &lt;strong&gt;特别&lt;/strong&gt; 的设计非要一个系统没有的动画曲线，要怎么办？&lt;/p&gt;
&lt;h4 id=&quot;那就自定义一个动画曲线&quot;&gt;那就自定义一个动画曲线&lt;/h4&gt;
&lt;p&gt;其实自定义一个动画曲线难点在 &lt;strong&gt;数学&lt;/strong&gt; 上，怎么把数学公式用代码实现才是难点。&lt;/p&gt;
&lt;p&gt;下面是一个 &lt;strong&gt;楼梯效果&lt;/strong&gt; 的动画曲线：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200707071109754-507689999.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;自定义动画曲线需要继承 Curve 重写 transformInternal 方法即可：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;class _StairsCurve extends Curve {

  @override
  double transformInternal(double t) {
    return t;
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;直接返回 t 其实就是线性动画，即 &lt;strong&gt;Curves.linear&lt;/strong&gt;，实现楼梯效果动画代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;class _StairsCurve extends Curve {
  //阶梯的数量
  final int num;
  double _perStairY;
  double _perStairX;

  _StairsCurve(this.num) {
    _perStairY = 1.0 / (num - 1);
    _perStairX = 1.0 / num;
  }

  @override
  double transformInternal(double t) {
    return _perStairY * (t / _perStairX).floor();
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改开始处的案例，使用此曲线：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;_animation = Tween(begin: 100.0, end: 200.0)
    .chain(CurveTween(curve: _StairsCurve(5)))
    .animate(_controller);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200707071109946-1336172178.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;动画系统的核心是 &lt;strong&gt;AnimationController&lt;/strong&gt;，而且是不可或缺的，动画中必须有 AnimationController，而 Tween 和 Curve 则是对 AnimationController 的补充， Tween 实现了将 AnimationController [0,1]的值映射为其他类型的值，比如颜色、样式等，Curve 是 AnimationController 动画执行曲线，默认是线性运行。&lt;/p&gt;
&lt;p&gt;将 AnimationController 、 Tween 、Curve 进行关联的方式：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;AnimationController _controller;
Animation _animation;

@override
void initState() {
  super.initState();
  _controller =
      AnimationController(vsync: this, duration: Duration(milliseconds: 1000))
        ..addListener(() {
          setState(() {});
        });

  _animation = Tween(begin: 100.0, end: 200.0)
      .animate(_controller);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或者：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;_animation = _controller.drive(Tween(begin: 100.0, end: 200.0));
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;加入 Curve ：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;_animation = Tween(begin: 100.0, end: 200.0)
    .chain(CurveTween(curve: Curves.linear))
    .animate(_controller);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或者：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;_animation = _controller
    .drive(CurveTween(curve: Curves.linear))
    .drive(Tween(begin: 100.0, end: 200.0));
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;只需要 Curve ：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;_animation = CurveTween(curve: Curves.linear)
    .animate(_controller);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或者&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;_animation = _controller.drive(CurveTween(curve: Curves.linear));
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一个 AnimationController 可以对应多个 Animation（Tween 或者 Curve），StatefulWidget 组件可以包含多个 AnimationController ，但 SingleTickerProviderStateMixin 需要修改为 &lt;strong&gt;TickerProviderStateMixin&lt;/strong&gt;，改变颜色和大小，由两个 AnimationController 控制：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;class MultiControllerDemo extends StatefulWidget {
  @override
  _MultiControllerDemoState createState() =&amp;gt; _MultiControllerDemoState();
}

class _MultiControllerDemoState extends State&amp;lt;MultiControllerDemo&amp;gt;
    with TickerProviderStateMixin {
  AnimationController _sizeController;
  AnimationController _colorController;
  Animation&amp;lt;double&amp;gt; _sizeAnimation;
  Animation&amp;lt;Color&amp;gt; _colorAnimation;

  @override
  void initState() {
    super.initState();
    _sizeController =
        AnimationController(vsync: this, duration: Duration(milliseconds: 2000))
          ..addListener(() {
            setState(() {});
          });

    _sizeAnimation = _sizeController
        .drive(CurveTween(curve: Curves.linear))
        .drive(Tween(begin: 100.0, end: 200.0));

    _colorController =
        AnimationController(vsync: this, duration: Duration(milliseconds: 1000))
          ..addListener(() {
            setState(() {});
          });

    _colorAnimation = _colorController
        .drive(CurveTween(curve: Curves.bounceIn))
        .drive(ColorTween(begin: Colors.blue, end: Colors.red));
  }

  @override
  Widget build(BuildContext context) {
    return Center(
      child: GestureDetector(
        onTap: () {
          _sizeController.forward();
          _colorController.forward();
        },
        child: Container(
          height: _sizeAnimation.value,
          width: _sizeAnimation.value,
          color: _colorAnimation.value,
          alignment: Alignment.center,
          child: Text(
            '点我变化',
            style: TextStyle(color: Colors.white, fontSize: 18),
          ),
        ),
      ),
    );
  }

  @override
  void dispose() {
    super.dispose();
    _sizeController.dispose();
    _colorController.dispose();
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200707071110201-605135606.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;AnimationController 、Tween 、Curve 是整个动画的基础，Flutter 系统封装了大量了动画组件，但这些组件也是基于此封装的，因为深入了解这三部分比学习使用动画组件更重要，再次对这3个进行总结：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;AnimationController：动画控制器，控制动画的播放、停止等。继承自Animation&amp;lt; double &amp;gt;，是一个特殊的Animation对象，默认情况下它会线性的生成一个0.0到1.0的值，类型只能是 double 类型，不设置动画曲线的情况下，可以设置输出的最小值和最大值。&lt;/li&gt;
&lt;li&gt;Curve：动画曲线，作用和Android中的Interpolator（差值器）类似，负责控制动画变化的速率，通俗地讲就是使动画的效果能够以匀速、加速、减速、抛物线等各种速率变化。&lt;/li&gt;
&lt;li&gt;Tween：将 AnimationController 生成的 [0,1]值映射成其他属性的值，比如颜色、样式等。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;完成一个动画效果的过程如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200707071110442-1254298779.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;创建 &lt;strong&gt;AnimationController&lt;/strong&gt; 。&lt;/li&gt;
&lt;li&gt;如果需要 &lt;strong&gt;Tween&lt;/strong&gt; 或者 &lt;strong&gt;Curve&lt;/strong&gt;，将 AnimationController 与其关联，Tween 和 Curve 并不是必须的，当然大部分情况都需要。&lt;/li&gt;
&lt;li&gt;将动画值作用于组件，当没有Tween 和 Curve 时，动画值来源于AnimationController，如果有 Tween 和 Curve，动画值来源于 Tween 或者Curve 的 Animation。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;如果你发现阅读完此篇文章还是感觉不会写动画，不要灰心，这是正常的，第一次想了解这些抽象的概念还是比较困难的，如果你有其他平台的相关经验，那会好很多，对于动画，想要掌握个人认为只有一个方法就是 &lt;strong&gt;多写&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;后面会介绍动画组件基础使用、实现原理、高级动画以及自定义动画，把每一个动画组件的用法都亲自手写一遍（而不是复制黏贴），回过头来在看这篇文章，会有不一样的感觉。&lt;/p&gt;
&lt;h2 id=&quot;交流&quot;&gt;交流&lt;/h2&gt;
&lt;p&gt;老孟Flutter博客地址（330个控件用法）：&lt;a href=&quot;http://laomengit.com&quot;&gt;http://laomengit.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎加入Flutter交流群（微信：laomengit）、关注公众号【老孟Flutter】：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th/&gt;
&lt;th/&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200707071111007-279532944.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/td&gt;
&lt;td&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200707071111305-885608476.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;</description>
<pubDate>Mon, 06 Jul 2020 23:11:00 +0000</pubDate>
<dc:creator>老孟Flutter</dc:creator>
<og:description>老孟导读：动画系统是任何一个UI框架的核心功能，也是开发者学习一个UI框架的重中之重，同时也是比较难掌握的一部分，下面我们就一层一层的揭开 Flutter 动画的面纱。 任何程序的动画原理都是一样的，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mengqd/p/13258725.html</dc:identifier>
</item>
<item>
<title>使用@AutoConfigureBefore调整配置顺序竟没生效？ - YourBatman</title>
<link>http://www.cnblogs.com/yourbatman/p/13258700.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yourbatman/p/13258700.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;一个人的价值体现在能够帮助多少人。自己编码好，价值能得到很好的体现。若你做出来的东西能够帮助别人开发，大大减少开发的时间，那就功德无量。&lt;br/&gt;&lt;strong&gt;作者&lt;/strong&gt;：A哥（YourBatman）&lt;br/&gt;&lt;strong&gt;公众号&lt;/strong&gt;：BAT的乌托邦（ID：BAT-utopia）&lt;br/&gt;&lt;strong&gt;文末是否有彩蛋&lt;/strong&gt;：有&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200707062022385.png#x200&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;各位小伙伴大家好，我是A哥。&lt;code&gt;Spring Boot&lt;/code&gt;是Spring家族具有划时代意义的一款产品，它发展自&lt;code&gt;Spring Framework&lt;/code&gt;却又高于它，这种高于主要表现在其最重要的&lt;strong&gt;三大特性&lt;/strong&gt;，而相较于这三大特性中更为重要的便是&lt;strong&gt;Spring Boot的自动配置&lt;/strong&gt;（&lt;code&gt;AutoConfiguration&lt;/code&gt;）。与其说是自动，倒不如说是“智能”，该框架看起来好像“更聪明”了。因此它也顺理成章的成为了构建微服务的基础设施，稳坐第一宝座。&lt;/p&gt;
&lt;p&gt;生活之道，在于取舍。编程何尝不是，任何决定都会是一把双刃剑，&lt;code&gt;Spring Boot&lt;/code&gt;的自动配置解决了Spring Framework使用起来的众多痛点，让开发效率可以得到&lt;strong&gt;指数级提升&lt;/strong&gt;（想一想，这不就是功德无量吗？）。成也萧何败也萧何，也正是因为它的太智能，倘若出了问题就会让程序员两眼一抹黑，无从下手。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;瑕不掩瑜，Spring Boot前进的步伐浩浩荡荡，学就完了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这不，我就在前几天收到一个“求助”，希望使用&lt;code&gt;@AutoConfigureBefore&lt;/code&gt;来&lt;strong&gt;控制配置的顺序&lt;/strong&gt;，但并未能如愿。本文就针对这个场景case稍作展开，讨论下使用&lt;code&gt;@AutoConfigureBefore、@AutoConfigureAfter、@AutoConfigureOrder&lt;/code&gt;三大注解控制自动配置执行顺序的&lt;strong&gt;正确姿势&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;提示：Spring Boot的自动配置是通过@EnableAutoConfiguration注解驱动的，默认是开启状态。你也可以通过&lt;code&gt;spring.boot.enableautoconfiguration = false&lt;/code&gt;来关闭它，回退到Spring Framework时代。显然这不是本文需要讨论的内容~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2020050916181352.png#x200&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;本文将要聊的重点是Spring Boot自动配置 + 顺序控制，自动配置大家都耳熟能详，那么“首当其冲”就是知晓这个问题：配置类的执行为何需要控制顺序？&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;配置类为何需要顺序？&quot;&gt;配置类为何需要顺序？&lt;/h2&gt;
&lt;p&gt;我们已经知道Spring容器它对Bean的初始化是&lt;strong&gt;无序&lt;/strong&gt;的，我们并不能想当然的通过&lt;code&gt;@Order&lt;/code&gt;注解来控制其执行顺序。一般来说，对于容器内普通的Bean我们只需要关注依赖关系即可，而并不需要关心其绝对的顺序，而依赖关系的管理Spring的是做得很好的，这不连&lt;strong&gt;循环依赖&lt;/strong&gt;它都可以搞定麽。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;@Configuration&lt;/code&gt;配置类它也是一个Bean，但对于配置类来说，某些场景下的执行顺序是&lt;strong&gt;必须的&lt;/strong&gt;，是需要得到保证的。比如很典型的一个非A即B的case：若容器内已经存在A了，就不要再把B放进来。这种case即使用中文理解，就能知道对A的“判断”必须要放在B的前面，否则可能导致程序出问题。&lt;/p&gt;
&lt;p&gt;那么针对于配置的执行顺序，传统Spring和Spring Boot下各自是如何处理的，表现如何呢？&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;spring下控制配置执行顺序&quot;&gt;Spring下控制配置执行顺序&lt;/h3&gt;
&lt;p&gt;在传统的&lt;code&gt;Spring Framework&lt;/code&gt;里，一个&lt;code&gt;@Configuration&lt;/code&gt;注解标注的类就代表一个配置类，当存在多个&lt;code&gt;@Configuration&lt;/code&gt;时，他们的&lt;strong&gt;执行顺序&lt;/strong&gt;是由使用者靠手动指定的，就像这样：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 手动控制Config1 Config2的顺序
ApplicationContext context = new AnnotationConfigApplicationContext(Config1.class, Config2.class);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然，你可能就疑问了说：即使在传统Spirng里，我也从没有自己使用过&lt;code&gt;AnnotationConfigApplicationContext&lt;/code&gt;来显示加载配置啊，都是使用&lt;code&gt;@Configuration&lt;/code&gt;定义好配置类后，点击&lt;code&gt;Run&lt;/code&gt;一把唆的。没错，那是因为你是在web环境下使用Spring，IoC容器是借助web容器（如Tomcat等）来驱动的，Spring对此部分封装得非常好，所以做到了对使用者几乎无感知。&lt;/p&gt;
&lt;p&gt;关于这部分的内容，此处就不深究了，毕竟本文重点不在这嘛。但可以给出给小结论：&lt;code&gt;@Configuration&lt;/code&gt;配置被加载进容器的方式大体上可分为两种：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;手动。构建&lt;code&gt;ApplicationContext&lt;/code&gt; 时由构建者手动传入，可手动控制顺序&lt;/li&gt;
&lt;li&gt;自动。被&lt;code&gt;@ComponentScan&lt;/code&gt;自动扫描进去，无法控制顺序&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;绝大多数情况下我们都是使用&lt;strong&gt;自动&lt;/strong&gt;的方式，所以在Spring下对配置的顺序并无感知。其实这也是需求驱使，因为在传统Spring下我们并无此需求，所以对它无感是合乎逻辑的。另说一句，虽然我们并不能控制Bean的顺序，但是我们是可以干涉它的，比如：控制依赖关系、提升优先级、“间接”控制执行顺序...当然喽这是后面文章的内容，敬请关注。&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;spring-boot下控制配置执行顺序&quot;&gt;Spring Boot下控制配置执行顺序&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Spring Boot&lt;/code&gt;下对&lt;strong&gt;自动配置&lt;/strong&gt;的管理对比于Spring它就是黑盒，它会根据当前容器内的情况来&lt;strong&gt;动态的&lt;/strong&gt;判断自动配置类的加载与否、以及加载的顺序，所以可以说：Spring Boot的自动配置它对顺序是有&lt;strong&gt;强要求&lt;/strong&gt;的。需求驱使，Spring Boot给我们提供了&lt;code&gt;@AutoConfigureBefore、@AutoConfigureAfter、@AutoConfigureOrder&lt;/code&gt;（下面统称这三个注解为“三大注解”）这三个注解来帮我们解决这种诉求。&lt;/p&gt;
&lt;p&gt;需要注意的是：三大注解是Spring Boot提供的而非Spring Framework。其中前两个是1.0.0就有了，&lt;code&gt;@AutoConfigureOrder&lt;/code&gt;属于1.3.0版本新增，表示绝对顺序（数字越小，优先级越高）。另外，这几个注解&lt;strong&gt;并不互斥&lt;/strong&gt;，可以同时标注在同一个&lt;code&gt;@Configuration&lt;/code&gt;自动配置类上。&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;spring-boot内置的控制配置顺序举例&quot;&gt;Spring Boot内置的控制配置顺序举例&lt;/h2&gt;
&lt;p&gt;为方便大家理解，我列出一个Spring Boot它自己的使用作为示例学一学。以大家最为熟悉的WebMvc的自动配置场景为例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Configuration(proxyBeanMethods = false)
@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)
@AutoConfigureAfter({ DispatcherServletAutoConfiguration.class, TaskExecutionAutoConfiguration.class, ValidationAutoConfiguration.class })
public class WebMvcAutoConfiguration { ... }


@Configuration(proxyBeanMethods = false)
@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)
@AutoConfigureAfter(ServletWebServerFactoryAutoConfiguration.class)
public class DispatcherServletAutoConfiguration { ... }


@Configuration(proxyBeanMethods = false)
@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)
public class ServletWebServerFactoryAutoConfiguration { ... }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这几个配置是WebMVC的核心配置，他们之间是有顺序关系的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;WebMvcAutoConfiguration&lt;/code&gt;被加载的前提是：&lt;code&gt;DispatcherServletAutoConfiguration、TaskExecutionAutoConfiguration、ValidationAutoConfiguration&lt;/code&gt;这三个哥们都已经完成初始化&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DispatcherServletAutoConfiguration&lt;/code&gt;被加载的前提是：&lt;code&gt;ServletWebServerFactoryAutoConfiguration&lt;/code&gt;已经完成初始化&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ServletWebServerFactoryAutoConfiguration&lt;/code&gt;被加载的前提是：&lt;code&gt;@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)&lt;/code&gt;最高优先级，也就是说它无其它依赖，&lt;strong&gt;希望自己是最先被初始化的&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;当碰到多个配置都是最高优先级的时候，且互相之前没有关系的话，顺序也是不定的。但若互相之间存在依赖关系（如本利的&lt;code&gt;DispatcherServletAutoConfiguration&lt;/code&gt;和&lt;code&gt;ServletWebServerFactoryAutoConfiguration&lt;/code&gt;），那就按照相对顺序走&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200418160820903.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Y2NDEzODU3MTI=,size_16,color_FFFFFF,t_70#x330&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;WebMvcAutoConfiguration&lt;/code&gt;加载&lt;strong&gt;后&lt;/strong&gt;，在它&lt;strong&gt;之后&lt;/strong&gt;其实还有很多配置会尝试执行，例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@AutoConfigureAfter(WebMvcAutoConfiguration.class)
class FreeMarkerServletWebConfiguration extends AbstractFreeMarkerConfiguration { ... }

@AutoConfigureAfter(WebMvcAutoConfiguration.class)
public class GroovyTemplateAutoConfiguration { ... }

@AutoConfigureAfter({ WebMvcAutoConfiguration.class, WebFluxAutoConfiguration.class })
public class ThymeleafAutoConfiguration { ... }

@AutoConfigureAfter(WebMvcAutoConfiguration.class)
public class LifecycleMvcEndpointAutoConfiguration { ... }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这些都很容易理解：如果都不是Web环境，加载一些模版引擎的并无必要嘛。&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;三大注解使用的误区（重要）&quot;&gt;三大注解使用的误区（重要）&lt;/h2&gt;
&lt;p&gt;根据我的切身体会，针对这三大注解，实在有太多人把它&lt;strong&gt;误用&lt;/strong&gt;了，想用但是用了却又不生效，于是就容易触发一波“骂街”操作，其实这也是我书写本文的最大动力所在：纠正你的错误使用，告诉你正确姿势。&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;错误使用示例&quot;&gt;错误使用示例&lt;/h3&gt;
&lt;p&gt;我见到的非常多的小伙伴这么来使用三大注解：我这里使用“伪代码”进行模拟&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Configuration
public class B_ParentConfig {

    B_ParentConfig() {
        System.out.println(&quot;配置类ParentConfig构造器被执行...&quot;);
    }
}

@Configuration
public class A_SonConfig {

    A_SonConfig() {
        System.out.println(&quot;配置类SonConfig构造器被执行...&quot;);
    }
}

@Configuration
public class C_DemoConfig {
    public C_DemoConfig(){
        System.out.println(&quot;我是被自动扫描的配置，初始化啦....&quot;);
    }
}

@SpringBootApplication
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args).close();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过名称能知道我想要的达到的效果是：&lt;strong&gt;ParentConfig先加载，SonConfig后加载&lt;/strong&gt;。（DemoConfig作为一个参考配置，作为日志参考使用即可）&lt;/p&gt;
&lt;p&gt;启动应用，控制台打印：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;配置类SonConfig构造器被执行...
配置类ParentConfig构造器被执行...
我是被自动扫描的配置，初始化啦....
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Son优先于Parent被加载了，这明显&lt;strong&gt;不符合要求&lt;/strong&gt;。因此，我看到很多小伙伴就这么干：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@AutoConfigureBefore(A_SonConfig.class)
@Configuration
public class B_ParentConfig {

    B_ParentConfig() {
        System.out.println(&quot;配置类ParentConfig构造器被执行...&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过&lt;code&gt;@AutoConfigureBefore&lt;/code&gt;控制，表示在&lt;code&gt;A_SonConfig&lt;/code&gt;之前执行此配置。语义层面上看，貌似没有任何问题，再次启动应用：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;配置类SonConfig构造器被执行...
配置类ParentConfig构造器被执行...
我是被自动扫描的配置，初始化啦....
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;what a fuck。看到没，我没骗你吧，骂街了骂街了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200509163634888.png#x200&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;竟然没生效？代码不会骗人，&lt;code&gt;@AutoConfigureBefore&lt;/code&gt;的语义也没有问题，而是你使用的姿势不对，下面我会给你正确姿势。&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;三大注解使用的正确姿势&quot;&gt;三大注解使用的正确姿势&lt;/h2&gt;
&lt;p&gt;针对以上case，要想达到预期效果，正确姿势只需要下面两步：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;把&lt;code&gt;A_SonConfig&lt;/code&gt;和&lt;code&gt;B_ParentConfig&lt;/code&gt;挪动到Application&lt;strong&gt;扫描不到&lt;/strong&gt;的包内，切记：一定且必须是扫描不到的包内&lt;/li&gt;
&lt;li&gt;当前工程里增加配置&lt;code&gt;META-INF/spring.factories&lt;/code&gt;，内容为(配置里Son和Parent前后顺序对结果无影响)：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;org.springframework.boot.autoconfigure.EnableAutoConfiguration=com.fsx.autoconfig.A_SonConfig,com.fsx.autoconfig.B_ParentConfig
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再次启动应用看看，打印输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;我是被自动扫描的配置，初始化啦....
配置类ParentConfig构造器被执行...
配置类SonConfig构造器被执行...
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;完美&lt;/strong&gt;。符合预期，Parent终于在Son之前完成了初始化，也就是说我们的&lt;code&gt;@AutoConfigureBefore&lt;/code&gt;注解生效了。&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;使用细节注意事项&quot;&gt;使用细节注意事项&lt;/h3&gt;
&lt;p&gt;针对此使用姿势，虽然很正确，并不是完全没有“副作用”的，有如下细节平时也需要引起注意：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;若你不用&lt;code&gt;@AutoConfigureBefore&lt;/code&gt;这个注解，单单就想依赖于spring.factories里的先后顺序的来控制实际的加载顺序，答案是&lt;strong&gt;不可以&lt;/strong&gt;，控制不了&lt;/li&gt;
&lt;li&gt;例子中有个小细节：我每次都故意输出了&lt;code&gt;我是被自动扫描的配置，初始化啦....&lt;/code&gt;这句话，可以发现被扫描进去配置实例化是在它前面（见错误示例），而通过&lt;code&gt;spring.factories&lt;/code&gt;方式进去是在它的后面（见正确姿势）&lt;/li&gt;
&lt;li&gt;从这个小细节可以衍生得到结论：&lt;code&gt;Spring Boot&lt;/code&gt;的自动配置均是通过&lt;code&gt;spring.factories&lt;/code&gt;来指定的，它的优先级最低（执行时机是最晚的）；通过扫描进来的一般都是你自己自定义的配置类，所以优先级是最高的，&lt;strong&gt;肯定在自动配置之前加载&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;从这你应该学到：若你要指定扫描的包名，请千万不要扫描到形如&lt;code&gt;org.springframework&lt;/code&gt;这种包名，否则“天下大乱”（当然喽为了防止这种情况出现，Spring Boot做了容错的。它有一个类专门检测这个case防止你配置错了，具体参见&lt;code&gt;ComponentScanPackageCheck&lt;/code&gt;默认实现）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;请尽量不要让自动配置类既被扫描到了，又放在&lt;code&gt;spring.factories&lt;/code&gt;配置了，否则后者会覆盖前者，很容易造成莫名其妙的错误&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;小总结，对于三大注解的正确使用姿势是应该是：请使用在你的&lt;strong&gt;自动配置&lt;/strong&gt;里（一般是你自定义starter时使用），而不是使用在你业务工程中的&lt;code&gt;@Configuration&lt;/code&gt;里，因为那会毫无效果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200509165554902.jpg#x200&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;三大注解解析时机浅析&quot;&gt;三大注解解析时机浅析&lt;/h2&gt;
&lt;p&gt;为了更好的辅助理解，加强记忆，本文将这三大注解解析时机&lt;strong&gt;简要的&lt;/strong&gt;絮叨一下，知道了它被解析的时机，自然就很好解释为何你那么写是无效的喽。&lt;/p&gt;
&lt;p&gt;这三个注解的解析都是交给&lt;code&gt;AutoConfigurationSorter&lt;/code&gt;来排序、处理的，做法类似于&lt;code&gt;AnnotationAwareOrderComparator&lt;/code&gt;去解析排序&lt;code&gt;@Order&lt;/code&gt;注解。核心代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;class AutoConfigurationSorter {
        
        // 唯一给外部调用的方法：返回排序好的Names，因此返回的是个List嘛（ArrayList）
        List&amp;lt;String&amp;gt; getInPriorityOrder(Collection&amp;lt;String&amp;gt; classNames) {
                ...
                // 先按照自然顺序排一波
                Collections.sort(orderedClassNames);
                // 在按照@AutoConfigureBefore这三个注解排一波
                orderedClassNames = sortByAnnotation(classes, orderedClassNames);
                return orderedClassNames;
        }
        ...
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此排序器被两个地方使用到：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;AutoConfigurationImportSelector&lt;/code&gt;：Spring自动配置处理器，用于加载所有的自动配置类。它实现了&lt;code&gt;DeferredImportSelector&lt;/code&gt;接口：这也顺便解释了为何自动配置是最后执行的原因~&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AutoConfigurations&lt;/code&gt;：表示自动配置@Configuration类。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这个排序的“解析/排序”过程还是比较复杂的，本文点到为止，观其大意即可。你可以简单粗暴的记住结论：&lt;code&gt;@AutoConfigureBefore、@AutoConfigureAfter、@AutoConfigureOrder&lt;/code&gt;这三个注解只能作用于&lt;strong&gt;自动配置类&lt;/strong&gt;，而不能是自定义的@Configuration配置类。&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;关于Spring Boot自动配置顺序相关的三大注解&lt;code&gt;@AutoConfigureBefore、@AutoConfigureAfter、@AutoConfigureOrder&lt;/code&gt;就先介绍到这了，本文主要用意是为了帮助大家规范此些“常用注解”的使用，规避一些误区，端正使用姿势，避免犯错时又丈二和尚。&lt;/p&gt;
&lt;p&gt;我看到不少文章、生产上的代码都使用错了（估计有没有效果自己的都不知道，又或者刚好歪打正着确实是在xxx后面执行而以为生效了），希望本文能帮助到你。&lt;/p&gt;
</description>
<pubDate>Mon, 06 Jul 2020 22:24:00 +0000</pubDate>
<dc:creator>YourBatman</dc:creator>
<og:description>调整配置的顺序，如是而已</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yourbatman/p/13258700.html</dc:identifier>
</item>
</channel>
</rss>