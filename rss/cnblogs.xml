<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>一文带你学会国产加密算法SM4的java实现方案 - 经典鸡翅</title>
<link>http://www.cnblogs.com/jichi/p/12907453.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jichi/p/12907453.html</guid>
<description>&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;今天给大家带来一个国产SM4加密解密算法的java后端解决方案，代码完整，可以直接使用，希望给大家带来帮助，尤其是做政府系统的开发人员，可以直接应用到项目中进行加密解密。&lt;br/&gt;画重点！是SM4哦，不是SM。哈哈，各位要在知识里遨游，不要想歪。正文开始~&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1534147/202005/1534147-20200517221617605-2147056113.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;国产sm4加密解密算法概念介绍&quot;&gt;国产SM4加密解密算法概念介绍&lt;/h3&gt;
&lt;p&gt;SMS4算法是在国内广泛使用的WAPI无线网络标准中使用的加密算法，是一种32轮的迭代非平衡Feistel结构的分组加密算法，其密钥长度和分组长度均为128。SMS4算法的加解密过程中使用的算法是完全相同的，唯一不同点在于该算法的解密密钥是由它的加密密钥进行逆序变换后得到的。&lt;br/&gt;SMS4分组加密算法是中国无线标准中使用的分组加密算法，在2012年已经被国家商用密码管理局确定为国家密码行业标准，标准编号GM/T 0002-2012并且改名为SM4算法，与SM2椭圆曲线公钥密码算法，SM3密码杂凑算法共同作为国家密码的行业标准，在我国密码行业中有着极其重要的位置。&lt;br/&gt;SMS4算法的分组长度为128bit，密钥长度也是128bit。加解密算法均采用32轮非平衡Feistel迭代结构，该结构最先出现在分组密码LOKI的密钥扩展算法中。SMS4通过32轮非线性迭代后加上一个反序变换，这样只需要解密密钥是加密密钥的逆序，就能使得解密算法与加密算法保持一致。SMS4加解密算法的结构完全相同，只是在使用轮密钥时解密密钥是加密密钥的逆序。&lt;br/&gt;S盒是一种利用非线性变换构造的分组密码的一个组件，主要是为了实现分组密码过程中的混淆的特性和设计的。SMS4算法中的S盒在设计之初完全按照欧美分组密码的设计标准进行，它采用的方法是能够很好抵抗差值攻击的仿射函数逆映射复合法。&lt;/p&gt;
&lt;h3 id=&quot;sm4加密算法应用场景&quot;&gt;SM4加密算法应用场景&lt;/h3&gt;
&lt;p&gt;SM4常用于政府系统的数据传输加密，比如当我们前端向后台传参数的时候，可以使用此算法。对参数的数据进行加密，然后后台对加密的数据进行解密再存储到数据库中，保证数据传输过程中，不受泄露。&lt;br/&gt;本次提供的方案不仅提供sm4的加密解密，还提供了md5算法的完整性防篡改校验。&lt;/p&gt;
&lt;h3 id=&quot;java端解决方案&quot;&gt;Java端解决方案&lt;/h3&gt;
&lt;p&gt;对于java端，我们使用的基于spring的aop切面和自定义注解来实现。整体思路为，当后台开启加密解密的时候，针对于打上注解的方法，寻找实体类中打上注解的字段进行加密和解密。再从前端传递请求的request中取出md5的header，进行md5的完整性，防篡改校验。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1534147/202005/1534147-20200517221731169-1395324743.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;首先我们必须说的是两个工具类，一个是SM4Utils工具类，另一个则是md5工具类。&lt;br/&gt;下面先来说一下SM4Utils。这个工具类用于SM4算法的加密和解密及密码校验。我们先直接看代码，然后后面对此进行解释。&lt;/p&gt;
&lt;h4 id=&quot;sm4utils&quot;&gt;SM4Utils&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;public class Sm4Utils {

    private static final String ENCODING = &quot;UTF-8&quot;;
    public static final String ALGORIGTHM_NAME = &quot;SM4&quot;;
    public static final String ALGORITHM_NAME_ECB_PADDING = &quot;SM4/ECB/PKCS7Padding&quot;;
    public static final int DEFAULT_KEY_SIZE = 128;

    public Sm4Utils() {
    }

    static {
        Security.addProvider(new BouncyCastleProvider());
    }

    /**
     *  @Description:生成ecb暗号
     */
    private static Cipher generateEcbCipher(String algorithmName, int mode, byte[] key) throws Exception {
        Cipher cipher = Cipher.getInstance(algorithmName,BouncyCastleProvider.PROVIDER_NAME);
        Key sm4Key = new SecretKeySpec(key, ALGORIGTHM_NAME);
        cipher.init(mode, sm4Key);
        return cipher;
    }

    /**
     *  @Description:自动生成密钥
     */
    public static byte[] generateKey() throws Exception {
        return generateKey(DEFAULT_KEY_SIZE);
    }

    public static byte[] generateKey(int keySize) throws Exception {
        KeyGenerator kg = KeyGenerator.getInstance(ALGORIGTHM_NAME, BouncyCastleProvider.PROVIDER_NAME);
        kg.init(keySize, new SecureRandom());
        return kg.generateKey().getEncoded();
    }


    /**
     *  @Description:加密
     */
    public static String encryptEcb(String hexKey, String paramStr, String charset) throws Exception {
        String cipherText = &quot;&quot;;
        if (null != paramStr &amp;amp;&amp;amp; !&quot;&quot;.equals(paramStr)) {
            byte[] keyData = ByteUtils.fromHexString(hexKey);
            charset = charset.trim();
            if (charset.length() &amp;lt;= 0) {
                charset = ENCODING;
            }
            byte[] srcData = paramStr.getBytes(charset);
            byte[] cipherArray = encrypt_Ecb_Padding(keyData, srcData);
            cipherText = ByteUtils.toHexString(cipherArray);
        }
        return cipherText;
    }

    /**
     *  @Description:加密模式之ecb
     */
    public static byte[] encrypt_Ecb_Padding(byte[] key, byte[] data) throws Exception {
        Cipher cipher = generateEcbCipher(ALGORITHM_NAME_ECB_PADDING, Cipher.ENCRYPT_MODE, key);
        byte[] bs = cipher.doFinal(data);
        return bs;
    }

    /**
     *  @Description:sm4解密
     */
    public static String decryptEcb(String hexKey, String cipherText, String charset) throws Exception {
        String decryptStr = &quot;&quot;;
        byte[] keyData = ByteUtils.fromHexString(hexKey);
        byte[] cipherData = ByteUtils.fromHexString(cipherText);
        byte[] srcData = decrypt_Ecb_Padding(keyData, cipherData);
        charset = charset.trim();
        if (charset.length() &amp;lt;= 0) {
            charset = ENCODING;
        }
        decryptStr = new String(srcData, charset);
        return decryptStr;
    }

    /**
     *  @Description:解密
     */
    public static byte[] decrypt_Ecb_Padding(byte[] key, byte[] cipherText) throws Exception {
        Cipher cipher = generateEcbCipher(ALGORITHM_NAME_ECB_PADDING, Cipher.DECRYPT_MODE, key);
        return cipher.doFinal(cipherText);
    }

    /**
     *  @Description:密码校验
     */
    public static boolean verifyEcb(String hexKey,String cipherText,String paramStr) throws Exception {
        boolean flag = false;
        byte[] keyData = ByteUtils.fromHexString(hexKey);
        byte[] cipherData = ByteUtils.fromHexString(cipherText);
        byte[] decryptData = decrypt_Ecb_Padding(keyData,cipherData);
        byte[] srcData = paramStr.getBytes(ENCODING);
        flag = Arrays.equals(decryptData,srcData);
        return flag;
    }

    /**
     *  @Description:测试类
    */
    public static void main(String[] args) {
        try {
            String json = &quot;{\&quot;name\&quot;:\&quot;color\&quot;,\&quot;sex\&quot;:\&quot;man\&quot;}&quot;;
            // 自定义的32位16进制密钥
            String key = &quot;cc9368581322479ebf3e79348a2757d9&quot;;
            String cipher = Sm4Utils.encryptEcb(key, json,ENCODING);
            System.out.println(cipher);
            System.out.println(Sm4Utils.verifyEcb(key, cipher, json));
            json = Sm4Utils.decryptEcb(key, cipher,ENCODING);
            System.out.println(json);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们来仔细看一下上面的代码，首先定义了个4个静态不可修改都变量，用于下方方法的使用。包括编码utf-8，密码名称sm4，密码的分组方式SM4/ECB/PKCS7Padding和默认的key值长度128。&lt;br/&gt;整体的方法我们分为生成ecb暗号，自动生成密钥，加密，解密，密码校验的算法。&lt;br/&gt;以上为sm4utils的核心代码。&lt;/p&gt;
&lt;h4 id=&quot;md5utils&quot;&gt;MD5Utils&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;
/**
 *  @Description:md5加密工具
 */
public class Md5Utils {

    /**
     *  @Description:获得md5加密串
     */
    public static String getMD5String(String str) {
        try {
            MessageDigest md = MessageDigest.getInstance(&quot;MD5&quot;);
            md.update(str.getBytes());
            return new BigInteger(1, md.digest()).toString(16);
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;MD5Utils主要用于对参数的完整性校验，防止篡改。&lt;/p&gt;
&lt;p&gt;此时我们已经实现了主要的加密解密工具，接下来实现spring的aop自定义注解，自定义注解我们要实现三个。&lt;br/&gt;第一个是加密注解，用于方法上的，表示该方法的参数需要被加密。&lt;br/&gt;第二个是解密注解，用于方法上的，表示该方法的参数需要被解密。&lt;br/&gt;第三个是字段加密解密注解，用于标识实体类的字段是否需要被加密和解密。&lt;/p&gt;
&lt;h4 id=&quot;加密的自定义注解&quot;&gt;加密的自定义注解&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;@Documented
@Target({ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Order(-2147483648)
public @interface EncryptMethod {
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到此时打了一个order注解，-2147483648用于标识优先级最高。&lt;/p&gt;
&lt;h4 id=&quot;解密的自定义注解&quot;&gt;解密的自定义注解&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Order(-2147483648)
@Inherited
public @interface DecryptMethod {
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;加密解密字段的自定义注解&quot;&gt;加密解密字段的自定义注解&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;@Documented
@Target({ElementType.FIELD})
@Retention(RetentionPolicy.RUNTIME)
@Order(-2147483648)
public @interface EncryptField {
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注解的准备工作已经做完，接下来就是实现sm4的切面方法。不了解spring的aop的实现方法，可以去先补一下spring的相关知识，这里不做赘述。我们这里采用的切面都是环绕通知，切面的切点是加密解密的注解。&lt;/p&gt;
&lt;h4 id=&quot;加密解密切面的实现&quot;&gt;加密解密切面的实现&lt;/h4&gt;
&lt;p&gt;说一下切面的答题实现思路。我们可以看到@ConditionalOnProperty(prefix = &quot;sm4&quot;, value = &quot;enable&quot;, matchIfMissing = false)，这个我们做成了根据配置文件的配置进行动态的开关。&lt;br/&gt;我们在appication.yml文件中进行如下的配置。这样切面是否生效就取决于配置。然后我们捕捉加密的注解和解密的注解，然后对加了注解的方法中的逻辑进行加密和解密。&lt;br/&gt;下方代码的切点方法为EncryptAOPCut和DecryptAOPCut。随后通过around对切点进行捕捉。分别调用的核心的加密算法encryptMethodAop和解密算法decryptMethodAop。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;sm4:
  enable: true
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;核心的加密解密算法都是使用环绕通知的ProceedingJoinPoint类，从他的对象中我们可以取到spring的各种参数，包括request请求，请求的参数和response对象。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
/**
 *  @Description:sm4加密解密切面
 */
@Order(-2147483648)
@Aspect
@Component
@ConditionalOnProperty(prefix = &quot;sm4&quot;, value = &quot;enable&quot;, matchIfMissing = false)
public class Sm4Aspect {

    private Logger log = LoggerFactory.getLogger(Sm4Aspect.class);
    private static final String DEFAULT_KEY = &quot;cc9368581322479ebf3e79348a2757d9&quot;;

    public Sm4Aspect() {
    }

    @Pointcut(&quot;@annotation(com.jichi.aop.sm4.EncryptMethod)&quot;)
    public void EncryptAOPCut() {
    }

    @Pointcut(&quot;@annotation(com.jichi.aop.sm4.DecryptMethod)&quot;)
    public void DecryptAOPCut() {
    }

    @Around(&quot;EncryptAOPCut()&quot;)
    public Object encryptMethodAop(ProceedingJoinPoint joinPoint) {
        Object responseObj = null;
        try {
            responseObj = joinPoint.proceed();
            this.handleEncrypt(responseObj);
            //md5加密
            String md5Data = Md5Utils.getMD5String(new Gson().toJson(responseObj));
            SpringContextUtil.getHttpServletResponse().setHeader(&quot;md5&quot;,md5Data);
        } catch (Throwable throwable) {
            throwable.printStackTrace();
            this.log.error(&quot;encryptMethodAop处理出现异常{}&quot;, throwable);
        }
        return responseObj;
    }

    @Around(&quot;DecryptAOPCut()&quot;)
    public Object decryptMethodAop(ProceedingJoinPoint joinPoint) {
        Object responseObj = null;
        try {
            responseObj = joinPoint.getArgs()[0];
            //throw new RuntimeException(&quot;md5校验失败&quot;);
            this.handleDecrypt(responseObj);
            String md5 = &quot;&quot;;
            md5 = Md5Utils.getMD5String(new Gson().toJson(responseObj));
            System.out.println(md5);
            String origianlMd5 = &quot;&quot;;
            origianlMd5 = SpringContextUtil.getHttpServletRequest().getHeader(&quot;md5&quot;);
            if(origianlMd5.equals(md5)){
                responseObj = joinPoint.proceed();
            }else{
                this.log.error(&quot;参数的md5校验不同，可能存在篡改行为，请检查！&quot;);
                throw new Exception(&quot;参数的md5校验不同，可能存在篡改行为，请检查！&quot;);
            }
        } catch (Throwable throwable) {
            throwable.printStackTrace();
            this.log.error(&quot;decryptMethodAop处理出现异常{}&quot;, throwable);
        }
        return responseObj;
    }

    private void handleEncrypt(Object requestObj) throws Exception {
        if (!Objects.isNull(requestObj)) {
            Field[] fields = requestObj.getClass().getDeclaredFields();
            Field[] fieldsCopy = fields;
            int fieldLength = fields.length;
            for(int i = 0; i &amp;lt; fieldLength; ++i) {
                Field field = fieldsCopy[i];
                boolean hasSecureField = field.isAnnotationPresent(EncryptField.class);
                if (hasSecureField) {
                    field.setAccessible(true);
                    String plaintextValue = (String)field.get(requestObj);
                    String encryptValue = Sm4Utils.encryptEcb(DEFAULT_KEY, plaintextValue, &quot;&quot;);
                    field.set(requestObj, encryptValue);
                }
            }
        }
    }

    private Object handleDecrypt(Object responseObj) throws Exception {
        if (Objects.isNull(responseObj)) {
            return null;
        } else {
            Field[] fields = responseObj.getClass().getDeclaredFields();
            Field[] fieldsCopy = fields;
            int fieldLength = fields.length;
            for(int i = 0; i &amp;lt; fieldLength; ++i) {
                Field field = fieldsCopy[i];
                boolean hasSecureField = field.isAnnotationPresent(EncryptField.class);
                if (hasSecureField) {
                    field.setAccessible(true);
                    String encryptValue = (String)field.get(responseObj);
                    String plaintextValue = Sm4Utils.decryptEcb(DEFAULT_KEY, encryptValue, &quot;&quot;);
                    field.set(responseObj, plaintextValue);
                }
            }
            return responseObj;
        }
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;代码实际应用&quot;&gt;代码实际应用&lt;/h3&gt;
&lt;p&gt;首先我们可以定义一个实体类，对实体类的字段进行加密或解密的标识。我们这里建立了一个Info实体类，对于其中的name属性，我们加了注解加密解密字段，对于sex属性我们不做任何处理。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Data
public class Info {

    @EncryptField
    private String name;

    private String sex;

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们对于controller方法打上加密的方法或解密的方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@RestController
@RequestMapping(&quot;/demo/test&quot;)
public class TestController {


    @PostMapping(&quot;/saveInfo&quot;)
    @DecryptMethod
    public HashMap&amp;lt;String,String&amp;gt; saveInfo(@RequestBody Info info) {
        HashMap&amp;lt;String,String&amp;gt; result = new HashMap&amp;lt;String,String&amp;gt;();
        String name = info.getName();
        System.out.println(name);
        String sex= info.getSex();
        System.out.println(sex);
        result.put(&quot;flag&quot;,&quot;1&quot;);
        result.put(&quot;msg&quot;,&quot;操作成功&quot;);
        return result;
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意到方法上的注解@DecryptMethod，以为这着我们的这个方法将会进行解密。如果是@EncryptMethod，则代表对方法进行加密。&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;到此为止，涉及到java后端的代码解决方案已经完毕。示例代码已经给出，大家可以直接使用，本人亲测有效。文中难免有不足，欢迎大家批评指正。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1534147/202005/1534147-20200517223554796-1551566866.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 18 May 2020 00:38:00 +0000</pubDate>
<dc:creator>经典鸡翅</dc:creator>
<og:description>前言 今天给大家带来一个国产SM4加密解密算法的java后端解决方案，代码完整，可以直接使用，希望给大家带来帮助，尤其是做政府系统的开发人员，可以直接应用到项目中进行加密解密。 画重点！是SM4哦，不</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jichi/p/12907453.html</dc:identifier>
</item>
<item>
<title>真香警告！扩展 swagger支持文档自动列举所有枚举值 - Coder小黑</title>
<link>http://www.cnblogs.com/coderxiaohei/p/12908562.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/coderxiaohei/p/12908562.html</guid>
<description>&lt;p&gt;在使用 swagger 来编写接口文档时，需要告诉前端枚举类型有哪些取值，每次增加取值之后，不仅要改代码，还要找到对应的取值在哪里使用了，然后修改 swagger 文档。反正小黑我觉得这样做很不爽，那有没有什么办法可以让 swagger 框架来帮我们自动列举出所有的枚举数值呢？&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;150.02518081972&quot;&gt;
&lt;p&gt;承接上篇文章 &lt;a href=&quot;https://mp.weixin.qq.com/s/IxWbLB8J6R_xHmAVNTnvIg&quot;&gt;《一站式解决使用枚举的各种痛点》&lt;/a&gt; 文章最后提到：&lt;strong&gt;在使用 swagger 来编写接口文档时，需要告诉前端枚举类型有哪些取值，每次增加取值之后，不仅要改代码，还要找到对应的取值在哪里使用了，然后修改 swagger 文档。反正小黑我觉得这样做很不爽，那有没有什么办法可以让 swagger 框架来帮我们自动列举出所有的枚举数值呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这期小黑同学就来讲讲解决方案。&lt;/p&gt;
&lt;p&gt;先来看一下效果，有一个感性的认识&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1822265/202005/1822265-20200518083510593-1345680508.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;请注意哦，这里是课程类型不是我们手动列举出来的，是swagger框架帮我们自动列举的。对应的代码如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1822265/202005/1822265-20200518083521402-1752888625.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么，这是怎么做到的呢？&lt;/p&gt;
&lt;p&gt;简单描述一下实现：&lt;/p&gt;
&lt;p&gt;1、自定义 SwaggerDisplayEnum 注解，注解中有两个属性，这两个属性是用来干什么的呢？小黑我先不说，大家往下阅读，相信就能明白啦~&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
public @interface SwaggerDisplayEnum {
    String index() default &quot;index&quot;;

    String name() default &quot;name&quot;;

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2、在我们的自定义枚举类中标记 &lt;code&gt;@SwaggerDisplayEnum&lt;/code&gt; 注解&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Getter
@AllArgsConstructor
@SwaggerDisplayEnum(index = &quot;type&quot;, name = &quot;desc&quot;)
public enum CourseType {

    /**
     * 图文
     */
    PICTURE(102, &quot;图文&quot;),
    /**
     * 音频
     */
    AUDIO(103, &quot;音频&quot;),
    /**
     * 视频
     */
    VIDEO(104, &quot;视频&quot;),
    /**
     * 外链
     */
    URL(105, &quot;外链&quot;),
    ;

    @JsonValue
    private final int type;
    private final String desc;

    private static final Map&amp;lt;Integer, CourseType&amp;gt; mappings;

    static {
        Map&amp;lt;Integer, CourseType&amp;gt; temp = new HashMap&amp;lt;&amp;gt;();
        for (CourseType courseType : values()) {
            temp.put(courseType.type, courseType);
        }
        mappings = Collections.unmodifiableMap(temp);
    }

    @EnumConvertMethod
    @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
    @Nullable
    public static CourseType resolve(int index) {
        return mappings.get(index);
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3、实现 &lt;code&gt;ModelPropertyBuilderPlugin&lt;/code&gt; 接口，扩展 swagger，实现在文档中列举所有的枚举值。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class EnumModelPropertyBuilderPlugin implements ModelPropertyBuilderPlugin {

    @Override
    public void apply(ModelPropertyContext context) {
        Optional&amp;lt;BeanPropertyDefinition&amp;gt; optional = context.getBeanPropertyDefinition();
        if (!optional.isPresent()) {
            return;
        }

        final Class&amp;lt;?&amp;gt; fieldType = optional.get().getField().getRawType();

        addDescForEnum(context, fieldType);
    }

    @Override
    public boolean supports(DocumentationType delimiter) {
        return true;
    }

    private void addDescForEnum(ModelPropertyContext context, Class&amp;lt;?&amp;gt; fieldType) {
        if (Enum.class.isAssignableFrom(fieldType)) {
            SwaggerDisplayEnum annotation = AnnotationUtils.findAnnotation(fieldType, SwaggerDisplayEnum.class);
            if (annotation != null) {
                String index = annotation.index();
                String name = annotation.name();

                Object[] enumConstants = fieldType.getEnumConstants();

                List&amp;lt;String&amp;gt; displayValues =
                        Arrays.stream(enumConstants)
                                .filter(Objects::nonNull)
                                .map(item -&amp;gt; {
                                    Class&amp;lt;?&amp;gt; currentClass = item.getClass();

                                    Field indexField = ReflectionUtils.findField(currentClass, index);
                                    ReflectionUtils.makeAccessible(indexField);
                                    Object value = ReflectionUtils.getField(indexField, item);

                                    Field descField = ReflectionUtils.findField(currentClass, name);
                                    ReflectionUtils.makeAccessible(descField);
                                    Object desc = ReflectionUtils.getField(descField, item);
                                    return value + &quot;:&quot; + desc;

                                }).collect(Collectors.toList());


                ModelPropertyBuilder builder = context.getBuilder();
                Field descField = ReflectionUtils.findField(builder.getClass(), &quot;description&quot;);
                ReflectionUtils.makeAccessible(descField);
                String joinText = ReflectionUtils.getField(descField, builder)
                        + &quot; (&quot; + String.join(&quot;; &quot;, displayValues) + &quot;)&quot;;

                builder.description(joinText).type(context.getResolver().resolve(Integer.class));
            }
        }

    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;4、实现 &lt;code&gt;ParameterBuilderPlugin&lt;/code&gt; 和 &lt;code&gt;OperationBuilderPlugin&lt;/code&gt; 接口，列举枚举参数的所有取值。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class EnumParameterBuilderPlugin implements ParameterBuilderPlugin, OperationBuilderPlugin {

    private static final Joiner joiner = Joiner.on(&quot;,&quot;);

    @Override
    public void apply(ParameterContext context) {
        Class&amp;lt;?&amp;gt; type = context.resolvedMethodParameter().getParameterType().getErasedType();
        if (Enum.class.isAssignableFrom(type)) {
            SwaggerDisplayEnum annotation = AnnotationUtils.findAnnotation(type, SwaggerDisplayEnum.class);
            if (annotation != null) {

                String index = annotation.index();
                String name = annotation.name();
                Object[] enumConstants = type.getEnumConstants();
                List&amp;lt;String&amp;gt; displayValues = Arrays.stream(enumConstants).filter(Objects::nonNull).map(item -&amp;gt; {
                    Class&amp;lt;?&amp;gt; currentClass = item.getClass();

                    Field indexField = ReflectionUtils.findField(currentClass, index);
                    ReflectionUtils.makeAccessible(indexField);
                    Object value = ReflectionUtils.getField(indexField, item);

                    Field descField = ReflectionUtils.findField(currentClass, name);
                    ReflectionUtils.makeAccessible(descField);
                    Object desc = ReflectionUtils.getField(descField, item);
                    return value.toString();

                }).collect(Collectors.toList());

                ParameterBuilder parameterBuilder = context.parameterBuilder();
                AllowableListValues values = new AllowableListValues(displayValues, &quot;LIST&quot;);
                parameterBuilder.allowableValues(values);
            }
        }
    }


    @Override
    public boolean supports(DocumentationType delimiter) {
        return true;
    }

    @Override
    public void apply(OperationContext context) {
        Map&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
        List&amp;lt;ResolvedMethodParameter&amp;gt; parameters = context.getParameters();
        parameters.forEach(parameter -&amp;gt; {
            ResolvedType parameterType = parameter.getParameterType();
            Class&amp;lt;?&amp;gt; clazz = parameterType.getErasedType();
            if (Enum.class.isAssignableFrom(clazz)) {
                SwaggerDisplayEnum annotation = AnnotationUtils.findAnnotation(clazz, SwaggerDisplayEnum.class);
                if (annotation != null) {
                    String index = annotation.index();
                    String name = annotation.name();
                    Object[] enumConstants = clazz.getEnumConstants();

                    List&amp;lt;String&amp;gt; displayValues = Arrays.stream(enumConstants).filter(Objects::nonNull).map(item -&amp;gt; {
                        Class&amp;lt;?&amp;gt; currentClass = item.getClass();

                        Field indexField = ReflectionUtils.findField(currentClass, index);
                        ReflectionUtils.makeAccessible(indexField);
                        Object value = ReflectionUtils.getField(indexField, item);

                        Field descField = ReflectionUtils.findField(currentClass, name);
                        ReflectionUtils.makeAccessible(descField);
                        Object desc = ReflectionUtils.getField(descField, item);
                        return value + &quot;:&quot; + desc;

                    }).collect(Collectors.toList());

                    map.put(parameter.defaultName().or(&quot;&quot;), displayValues);

                    OperationBuilder operationBuilder = context.operationBuilder();
                    Field parametersField = ReflectionUtils.findField(operationBuilder.getClass(), &quot;parameters&quot;);
                    ReflectionUtils.makeAccessible(parametersField);
                    List&amp;lt;Parameter&amp;gt; list = (List&amp;lt;Parameter&amp;gt;) ReflectionUtils.getField(parametersField, operationBuilder);

                    map.forEach((k, v) -&amp;gt; {
                        for (Parameter currentParameter : list) {
                            if (StringUtils.equals(currentParameter.getName(), k)) {
                                Field description = ReflectionUtils.findField(currentParameter.getClass(), &quot;description&quot;);
                                ReflectionUtils.makeAccessible(description);
                                Object field = ReflectionUtils.getField(description, currentParameter);
                                ReflectionUtils.setField(description, currentParameter, field + &quot; , &quot; + joiner.join(v));
                                break;
                            }
                        }
                    });
                }
            }
        });
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这篇文章比较枯燥，小黑我也不知道该怎么去讲述，只是将源码附录了出来。如果有读者看了之后还是不清楚的话，可以给我留言，我会一一解答。感谢你的阅读~~&lt;/p&gt;
&lt;p&gt;相关源码已经上传到了 github：&lt;a href=&quot;https://github.com/shenjianeng/solution-for-enums&quot;&gt;https://github.com/shenjianeng/solution-for-enums&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Mon, 18 May 2020 00:36:00 +0000</pubDate>
<dc:creator>Coder小黑</dc:creator>
<og:description>在使用 swagger 来编写接口文档时，需要告诉前端枚举类型有哪些取值，每次增加取值之后，不仅要改代码，还要找到对应的取值在哪里使用了，然后修改 swagger 文档。反正小黑我觉得这样做很不爽，那</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/coderxiaohei/p/12908562.html</dc:identifier>
</item>
<item>
<title>手把手numpy教程【二】——数组与切片 - TechFlow2019</title>
<link>http://www.cnblogs.com/techflow/p/12908548.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/techflow/p/12908548.html</guid>
<description>&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天是&lt;strong&gt;Numpy专题的第二篇&lt;/strong&gt;，我们来进入正题，来看看Numpy的运算。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上一篇文章当中曾经提到过，同样大小的数据，使用Numpy的运算速度会是我们自己写循环来计算的上百倍甚至更多。并且Numpy的API非常简单，通常只要简单几行代码就可以完成非常复杂的操作。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;计算与广播&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在Python中的数组无论是什么类型，我们是无法直接对其中所有的元素进行计算的。想要做到这一点，必须要通过map这样的方式操作。而Numpy当中，我们可以很方便地&lt;strong&gt;对一整个数组或者是矩阵进行各式的计算&lt;/strong&gt;。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，我们先定义一个Numpy的数组：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;arr = np.array([[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;],[&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;]])
&lt;/code&gt;
&lt;/pre&gt;
&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/5/18/172252fab6498cc4?w=1028&amp;amp;h=152&amp;amp;f=jpeg&amp;amp;s=9548&quot; alt=&quot;image-20200516161939969&quot;/&gt;image-20200516161939969
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先而我们来看一下基本的四则运算：&lt;/p&gt;
&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/5/18/172252fab73b5e7a?w=1288&amp;amp;h=628&amp;amp;f=jpeg&amp;amp;s=45110&quot; alt=&quot;image-20200516162021455&quot;/&gt;image-20200516162021455
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这张图中我们可以看出两点，首先是Numpy当中的数组&lt;strong&gt;重载了四则运算符&lt;/strong&gt;，我们可以直接通过加减乘除进行计算。第二点是Numpy自动替我们做了映射，虽然我们运算操作的对象是数组本身，但是Numpy自动替我们映射到了其中的每一个元素。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你不喜欢直接运算，想要使用Numpy的api进行调用，也是一样可以的。Numpy当中也为加减乘除提供了api。&lt;/p&gt;
&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/5/18/172252fad76beef5?w=1216&amp;amp;h=646&amp;amp;f=jpeg&amp;amp;s=54229&quot; alt=&quot;image-20200516162427254&quot;/&gt;image-20200516162427254
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们甚至还可以比较两个数组的大小，得到的结果是一个bool型的数组，代表其中每一个元素的大小关系。&lt;/p&gt;
&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/5/18/172252fadac7e003?w=1092&amp;amp;h=154&amp;amp;f=jpeg&amp;amp;s=15414&quot; alt=&quot;image-20200516162534018&quot;/&gt;image-20200516162534018
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了列举的这些之外，Numpy当中还提供了许多其他的api来进行各种计算，几乎囊括了所有常见的数学计算公式。比如log、exp、pow、开方、三角函数等等计算，基本上api的名称和math当中的一样，大家也没有必要都记住，基本上可以根据英文猜出来，一般来说记住常用的，其他的可以等到使用的时候再查阅。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;广播&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;理解了Numpy中的基本操作之后，接下来要介绍一个非常重要的概念，叫做&lt;strong&gt;广播&lt;/strong&gt;。如果这个概念理解不到位，那么后来在使用的过程当中，会遇到很多头疼的问题，或者是总是看不懂别人的代码。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;广播的英文叫做broadcasting，这个思想应用的范围很广，比如分布式消息中间件等很多领域都有化用。在Numpy计算当中，广播指的是将一个小的数据应用在大数据的计算上。这个概念其实很形象，我们来看个例子。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如我们想要对Numpy中的数组每一位的元素都加上3，我们当然可以创造出一个同样大小的数组来，然后再把它们相加。但是大可不必这么麻烦，我们直接用原数组加上3即可，Numpy内部会发现3和我们的数据大小不一致，然后自动帮我们把3拓充到和我们的数据一样大小的数组再进行计算：&lt;/p&gt;
&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/5/18/172252fae9e69caf?w=772&amp;amp;h=162&amp;amp;f=jpeg&amp;amp;s=9443&quot; alt=&quot;image-20200516162846508&quot;/&gt;image-20200516162846508
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它其实等价于：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;np.full_like(arr, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;) + arr
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你能理解了上面这个操作，那么同样的，我们要对所有的元素平方或者是开方也都不在话下了：&lt;/p&gt;
&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/5/18/172252faf1a17f7e?w=1228&amp;amp;h=320&amp;amp;f=jpeg&amp;amp;s=32902&quot; alt=&quot;image-20200516163141477&quot;/&gt;image-20200516163141477
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;广播并不是只可以用在数组和一个整数之间，还可以&lt;strong&gt;用在数组和另外一个规模更小的数组&lt;/strong&gt;当中，但是会对两者的shape有所要求。Numpy规定，两个数组的shape必须相等或者其中一个为1才可以执行广播操作。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如说刚才我们创建的arry数组的shape是(3, 2)，我们可以让它和一个大小是(1, 2)或者是(3, 1)的“小数组”进行运算，这同样是支持的。&lt;/p&gt;
&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/5/18/172252fb11236bb1?w=1074&amp;amp;h=384&amp;amp;f=jpeg&amp;amp;s=35045&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/5/18/172252fb23e6ad11?w=1122&amp;amp;h=394&amp;amp;f=jpeg&amp;amp;s=30636&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你看不明白上面的计算过程， 我下面用一张图做一下演示。&lt;/p&gt;
&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/5/18/172252fb23db0d08?w=1589&amp;amp;h=1080&amp;amp;f=jpeg&amp;amp;s=64179&quot; alt=&quot;image-20200516164211467&quot; data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从图中可以看到左边的数组shape是(2, 3)，右边的数组shape是(2, 1)，满足Numpy对于广播机制的要求。Numpy会自动对右边数组shape为1的维度进行广播，也就是将它&lt;strong&gt;复制若干份&lt;/strong&gt;使得它们的shape相等。如果你把左边的数组看成是若干个听广播的人，右侧的数组看成是消息的话，那么广播机制就是把消息复制若干份，让每一个听广播的人听到同样的内容。所以这个名字还是很形象的。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;切片&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Python中数组为人称道的很重要的一点就是它的&lt;strong&gt;切片操作&lt;/strong&gt;非常方便，Numpy作为依托于Python的计算包，自然也继承了这一点，所以在Numpy当中，我们也可以很方便地使用切片功能。切片的使用方法和Python基本是一样的。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们用上下标加上冒号来表示我们想要切片的范围， 和Python一样，这是一个左闭右开的区间。&lt;/p&gt;
&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/5/18/172252fb3bf81057?w=1118&amp;amp;h=208&amp;amp;f=jpeg&amp;amp;s=16571&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们也可以省略其中的一个范围，只提供上界或者是下界：&lt;/p&gt;
&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/5/18/172252fb406eceac?w=1344&amp;amp;h=284&amp;amp;f=jpeg&amp;amp;s=23899&quot; alt=&quot;image-20200516165031942&quot;/&gt;image-20200516165031942
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们还可以上下界都省略，表示全部都要，以及&lt;strong&gt;倒序切片&lt;/strong&gt;的方法也和Python是一样的。&lt;/p&gt;
&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/5/18/172252fb529b80bf?w=1548&amp;amp;h=432&amp;amp;f=jpeg&amp;amp;s=41789&quot; alt=&quot;image-20200516165127699&quot;/&gt;image-20200516165127699
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是有一点不太一样，Numpy中的切片和golang中的切片比较像，它代表原数组一段区间的&lt;strong&gt;引用&lt;/strong&gt;，而不是拷贝。也就是说我们修改切片中的内容是会影响原数组的，我们对一个切片赋值，明显可以发现原数组的对应位置发生了改变。&lt;/p&gt;
&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/5/18/172252fb68908400?w=1702&amp;amp;h=216&amp;amp;f=jpeg&amp;amp;s=22568&quot; alt=&quot;image-20200516165245162&quot;/&gt;image-20200516165245162
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这么设计的原因和golang是一样的，因为Numpy是为了大数据计算而诞生的，大数据计算显然性能是一个非常重要的考量指标。如果这里不是设计成引用，而是拷贝的话，那么当一个大的切片产生的时候，必然会&lt;strong&gt;涉及到大量拷贝&lt;/strong&gt;的操作。不仅非常消耗内存，并且也会占用大量计算资源。如果使用引用可以非常快速地返回结果。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;golang当中如此设计，也是一样的道理。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那问题来了，如果我们想要拷贝出一份切片出来，而不是获得一个切片应该怎么办？答案也很简单，我们可以调用copy方法，获取一份拷贝。&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;arr[&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;].copy()
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;索引&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;理解了切片的用法之后，我们接下来看看索引。索引也是Numpy当中非常重要的概念，应用也非常普遍。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Numpy当中的索引对应数组中的维度，比如一个二维的数组，当我们用下标访问的时候，获得的其实是一个一维的数组。所以如果我们想要访问一个具体的元素的时候，能做的就是继续往下指定下标：&lt;/p&gt;
&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/5/18/172252fb962c7ef4?w=1314&amp;amp;h=396&amp;amp;f=jpeg&amp;amp;s=59140&quot; alt=&quot;image-20200516171154055&quot;/&gt;image-20200516171154055
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个很好理解，和Python当中的多维数组的用法是一样的。上面我们用了两个方括号去锁定一个元素的位置，为了写起来方便，我们还可以&lt;strong&gt;用逗号分隔查询&lt;/strong&gt;。友情提醒，Python原生的数组并不支持这样的操作，不要搞混哦。&lt;/p&gt;
&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/5/18/172252fb9fbcf9d9?w=1062&amp;amp;h=126&amp;amp;f=jpeg&amp;amp;s=10129&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样的道理，如果是多维的数组也是一样的，我们依次写出从0到k维的坐标来获取一个固定的元素。如果我们给出的坐标信息较少，那么则会获得一个数组。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;拿3维数组举例，如果我们访问的时候只用一个下标，那么我们获得的是一个二维数组。如果使用两个下标，则获得的是一个一维数组。对于更高的维度也是同样。&lt;/p&gt;
&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/5/18/172252fb8ca0cb7f?w=1462&amp;amp;h=412&amp;amp;f=jpeg&amp;amp;s=68588&quot; alt=&quot;&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;结尾&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天的文章我们一起了解了Numpy当中常见的计算api以及广播和索引机制，关于索引的使用今天只是开了个头，还有很多非常灵活的用法，由于篇幅的限制，我们分成了多篇文章，会在之后的文章当中一一介绍。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天介绍的也是Numpy的基础内容，除了广播机制稍稍需要思考一下之外，其余的应该都非常简单，我相信大家都能看明白。Numpy之所以普及，除了速度快之外，api简单易用，学习成本低也是很大的特点。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关注我，获取更多精彩文章。&lt;/p&gt;
</description>
<pubDate>Mon, 18 May 2020 00:32:00 +0000</pubDate>
<dc:creator>TechFlow2019</dc:creator>
<og:description>本文始发于个人公众号： TechFlow ，原创不易，求个关注 今天是Numpy专题的第二篇，我们来进入正题，来看看Numpy的运算。 上一篇文章当中曾经提到过，同样大小的数据，使用Numpy的运算速</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/techflow/p/12908548.html</dc:identifier>
</item>
<item>
<title>重学数据结构之树和二叉树 - TM0831</title>
<link>http://www.cnblogs.com/TM0831/p/12907394.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/TM0831/p/12907394.html</guid>
<description>&lt;h2&gt;一、树和森林&lt;/h2&gt;
&lt;h3&gt;1.基本概念&lt;/h3&gt;
&lt;p&gt;　　树状图（Tree）又称为树，是一种复杂的数据结构。树是由 n（n&amp;gt;=0）个有限节点组成一个具有层次关系的集合，把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。当 n=0 时，称之为空树，否则是非空树。&lt;/p&gt;
&lt;p&gt;　　树具有以下的特点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;每个节点有零个或多个子节点；&lt;/li&gt;
&lt;li&gt;没有父节点的节点称为根节点；&lt;/li&gt;
&lt;li&gt;每一个非根节点有且只有一个父节点；&lt;/li&gt;
&lt;li&gt;除了根节点外，每个子节点可以分为多个不相交的子树。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;2.基本术语&lt;/h3&gt;
&lt;p&gt;　　&lt;strong&gt;子女&lt;/strong&gt;：若节点的子树非空，则节点子树的根即为该节点的子女。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;双亲&lt;/strong&gt;：若节点有子女，则该节点即为子女的双亲。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;兄弟&lt;/strong&gt;：同一节点的子女互称为兄弟。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;度&lt;/strong&gt;：节点的子女个数即为该节点的度。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;分支节点&lt;/strong&gt;：度不为0的节点即为分支节点。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;叶子节点&lt;/strong&gt;：度为0的节点即为叶子节点。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;深度&lt;/strong&gt;：节点的深度即为该节点所在的层次。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;高度&lt;/strong&gt;：规定叶子节点的高度为1，其双亲节点的高度等于它的高度加1。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;森林&lt;/strong&gt;：森林是 m（m&amp;gt;=0）颗树的集合。&lt;/p&gt;

&lt;h2&gt;二、二叉树&lt;/h2&gt;
&lt;h3&gt;1.基本概念&lt;/h3&gt;
&lt;p&gt;　　一颗二叉树是节点的有限集合，该集合或者为空，或者由一个根节点和两颗分别称为左子树和右子树的、互不交叉的二叉树组成（子树有左右之分，不可颠倒）。下面是二叉树的五种形态：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/1450803/202005/1450803-20200516215113583-1632376547.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;2.基本性质&lt;/h3&gt;
&lt;p&gt;　　&lt;strong&gt;性质1&lt;/strong&gt;：若二叉树节点的层次从1开始，则在二叉树的第 i 层最多有 2&lt;sup&gt;i-1 &lt;/sup&gt;个节点（i&amp;gt;=1）。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;性质2&lt;/strong&gt;：深度为 k 的二叉树最少有 k 个节点，最多有 2&lt;sup&gt;k&lt;/sup&gt;-1个 节点（k&amp;gt;=1）。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;性质3&lt;/strong&gt;：对任意一颗二叉树，如果其叶子节点有 m 个，度为2的非叶子节点为 n 个，则有：m = n + 1。&lt;/p&gt;
&lt;p&gt;　　设度为1的节点有 p 个，总节点数为 x，总边数为 e，则 x = m + n + p，e  = n - 1 = 2 * n + p。因此有：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;2 * n + p = m + n + p - 1&lt;/p&gt;
&lt;p&gt;n = m - 1&lt;/p&gt;
&lt;p&gt;m = n + 1&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;3.满二叉树和完全二叉树&lt;/h3&gt;
&lt;p&gt;1）&lt;strong&gt;满二叉树&lt;/strong&gt;：除了最后一层无任何子节点，每一层的所有节点都有两个子节点，即除了叶子节点外的所有节点均有两个子节点，这样的二叉树就称为满二叉树。&lt;/p&gt;
&lt;p&gt;2）&lt;strong&gt;完全二叉树&lt;/strong&gt;：设一个二叉树的深度为 k，即共有 k 层。除了第 k 层外，其他各层的节点数都达到最大个数，且最后一层上只缺少右边的若干节点，这样的二叉树就称为完全二叉树。&lt;/p&gt;
&lt;h3&gt;4.Python 实现&lt;/h3&gt;
&lt;p&gt; 　　下面是用 Python 实现的一个二叉树的代码，除了实现创建二叉树，还实现了四种遍历二叉树的方法，分别是：前序遍历、中序遍历、后序遍历和层次遍历。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
  1 # 自定义树节点
  2 class&lt;span&gt; Node:
  3     def __init__(self, value=None, left=None, right=&lt;span&gt;None):
  4         self.value =&lt;span&gt; value
  5         self.left =&lt;span&gt; left
  6         self.right =&lt;span&gt; right
  7 
  8 
  9 # 自定义二叉树
 10 class&lt;span&gt; BinaryTree:
 11     def __init__(self, value=None, left=None, right=&lt;span&gt;None):
 12         &quot;&quot;&quot;
 13         根据传入的参数决定树的形态
 14         :param value: 节点值
 15         :param left: 左子树
 16         :param right: 右子树
 17         &quot;&quot;&quot;
 18         self.root = Node(value, left, right) if value else&lt;span&gt; None
 19 
 20     def&lt;span&gt; is_empty(self):
 21         &quot;&quot;&quot;
 22         判断是否为空树
 23         :return: 
 24         &quot;&quot;&quot;
 25         return True if self.root else&lt;span&gt; False
 26 
 27     def&lt;span&gt; get_root(self):
 28         &quot;&quot;&quot;
 29         获取根节点
 30         :return: 
 31         &quot;&quot;&quot;
 32         return&lt;span&gt; self.root
 33 
 34     def&lt;span&gt; get_left(self):
 35         &quot;&quot;&quot;
 36         获取左子树
 37         :return: 
 38         &quot;&quot;&quot;
 39         return self.root.left if self.root else&lt;span&gt; None
 40 
 41     def&lt;span&gt; get_right(self):
 42         &quot;&quot;&quot;
 43         获取右子树
 44         :return: 
 45         &quot;&quot;&quot;
 46         return self.root.right if self.root else&lt;span&gt; None
 47 
 48     def&lt;span&gt; set_left(self, node: Node):
 49         &quot;&quot;&quot;
 50         设置左子树
 51         :param node: 树节点
 52         :return: 
 53         &quot;&quot;&quot;
 54         self.root.left =&lt;span&gt; node
 55 
 56     def&lt;span&gt; set_right(self, node: Node):
 57         &quot;&quot;&quot;
 58         设置右子树
 59         :param node: 树节点
 60         :return: 
 61         &quot;&quot;&quot;
 62         self.root.right =&lt;span&gt; node
 63     
 64     def&lt;span&gt; pre_traverse(self, node: Node):
 65         &quot;&quot;&quot;
 66         前序遍历
 67         :param node: 根节点
 68         :return:
 69         &quot;&quot;&quot;
 70         if not&lt;span&gt; node:
 71             return
 72         print(node.value, end=&quot; &quot;&lt;span&gt;)
 73 &lt;span&gt;        self.pre_traverse(node.left)
 74 &lt;span&gt;        self.pre_traverse(node.right)
 75 
 76     def&lt;span&gt; mid_traverse(self, node: Node):
 77         &quot;&quot;&quot;
 78         中序遍历
 79         :param node: 根节点
 80         :return:
 81         &quot;&quot;&quot;
 82         if not&lt;span&gt; node:
 83             return
 84 &lt;span&gt;        self.mid_traverse(node.left)
 85         print(node.value, end=&quot; &quot;&lt;span&gt;)
 86 &lt;span&gt;        self.mid_traverse(node.right)
 87 
 88     def&lt;span&gt; after_traverse(self, node: Node):
 89         &quot;&quot;&quot;
 90         后序遍历
 91         :param node: 根节点
 92         :return:
 93         &quot;&quot;&quot;
 94         if not&lt;span&gt; node:
 95             return
 96 &lt;span&gt;        self.after_traverse(node.left)
 97 &lt;span&gt;        self.after_traverse(node.right)
 98         print(node.value, end=&quot; &quot;&lt;span&gt;)
 99 
100     def&lt;span&gt; level_traverse(self, nodes: list):
101         next_nodes =&lt;span&gt; []
102         if&lt;span&gt; nodes:
103             for node in&lt;span&gt; nodes:
104                 print(node.value, end=&quot; &quot;&lt;span&gt;)
105                 if&lt;span&gt; node.left:
106 &lt;span&gt;                    next_nodes.append(node.left)
107                 if&lt;span&gt; node.right:
108 &lt;span&gt;                    next_nodes.append(node.right)
109             self.level_traverse(next_nodes)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　当然光有这些方法还是不够的，因为要一个个的创建节点还是很麻烦，我们可以将一个树节点定义成一个三元组：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;（树节点的值，左子树，右子树）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　而左子树和右子树也都可以用这种三元组来表示，例如下面是一颗二叉树的三元组表示：&lt;/p&gt;
&lt;blockquote readability=&quot;15&quot;&gt;
&lt;p&gt;(F, (C, A, (D, B, None)), (E, H, (G, M, None)))　　 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/1450803/202005/1450803-20200517111121587-567389416.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　因此还需要实现一个将这种三元组表达形式转换成二叉树的方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
 1     def&lt;span&gt; create(self, data: tuple):
 2         &quot;&quot;&quot;
 3         创建一个二叉树
 4         :param data: 例如(1,(2,4,5),(3,6,7))
 5         &quot;&quot;&quot;
 6         self.root =&lt;span&gt; self.parse(data)
 7 
 8     def&lt;span&gt; parse(self, data: tuple):
 9         &quot;&quot;&quot;
10         解析传入的三元组，创建二叉树
11         :param data: 三元组
12         :return:
13         &quot;&quot;&quot;
14         if&lt;span&gt; data:
15             node =&lt;span&gt; Node(data[0])
16             node.left = self.parse(data[1]) if type(data[1]) == tuple else Node(data[1&lt;span&gt;])
17             node.right = self.parse(data[2]) if type(data[2]) == tuple else Node(data[2&lt;span&gt;])
18             return node&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;三、树的应用&lt;/h2&gt;
&lt;h3&gt;1.表达式计算问题&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1）问题描述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　一个结构正确的二元表达式对应于一个满二叉树，例如下面这样一颗二叉树：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/1450803/202005/1450803-20200517112007852-952190092.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　这样一颗二叉树前序遍历得到“-+1*23/45”，后序遍历得到“123*+45/-”，正是波兰表达式的形式，而其中序遍历结果就是“1+2*3-4/5”，基本就是相应数学表达式的正确形式，只是缺少了表达计算顺序的括号。输入一个简单的只包含四则运算的数学计算表达式，求出其计算后的结果。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2）问题分析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　对于任意一个二元表达式（如“a+b”）都可以用一个三元组来表示（如“('+', a, b)”），而像上面示例中的表达式，就可以用下面这种三元组表示：&lt;/p&gt;
&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;(&quot;-&quot;, (&quot;+&quot;, 1, (&quot;*&quot;, 2, 3)), (&quot;/&quot;, 4, 5))&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　这种三元表达式都包含一个操作符设为 op，两个操作数分别为 x 和 y，因而可以写出下面的计算方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
1 if op == &quot;+&quot;&lt;span&gt;:
2     return x +&lt;span&gt; y
3 if op == &quot;-&quot;&lt;span&gt;:
4     return x -&lt;span&gt; y
5 if op == &quot;*&quot;&lt;span&gt;:
6     return x *&lt;span&gt; y
7 if op == &quot;/&quot;&lt;span&gt;:
8     return x / y if y else 0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　那么现在的问题就是如何将数学表达式转换成二叉树，再就根据二叉树得到三元组，最后就能使用上面的方法把表达式的值求出来了。因为我们都知道在没有括号的情况下，乘除的优先级是高于加减的，而利用二叉树求解表达式时会从下往上，从叶子节点往根节点进行计算，所以要把加减号放在上面，乘除号放在下面。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3）二叉树求解&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　下面是根据输入的表达式字符串建立二叉树的具体代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
 1 def&lt;span&gt; build_tree(input_string):
 2     &quot;&quot;&quot;
 3     根据输入的表达式字符串建立二叉树
 4     :param input_string: 输入表达式
 5     :return:
 6     &quot;&quot;&quot;
 7     if &quot;+&quot; in input_string or &quot;-&quot; in&lt;span&gt; input_string:
 8         for i in&lt;span&gt; range(len(input_string)):
 9             if input_string[i] in [&quot;+&quot;, &quot;-&quot;] and &quot;+&quot; not in input_string[i + 1:] and &quot;-&quot; not in input_string[i + 1&lt;span&gt;:]:
10                 node = Node(input_string[i], build_tree(input_string[:i]), build_tree(input_string[i + 1&lt;span&gt;:]))
11                 return&lt;span&gt; node
12     elif &quot;*&quot; in input_string or &quot;/&quot; in&lt;span&gt; input_string:
13         for i in&lt;span&gt; range(len(input_string)):
14             if input_string[i] in [&quot;*&quot;, &quot;/&quot;&lt;span&gt;]:
15                 node = Node(input_string[i], build_tree(input_string[:i]), build_tree(input_string[i + 1&lt;span&gt;:]))
16                 return&lt;span&gt; node
17     else&lt;span&gt;:
18         return Node(input_string)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在生成二叉树之后，还要根据这个二叉树得到三元组，下面就是使用递归算法得到三元组的代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
 1 def&lt;span&gt; trans(self, node: Node, data: tuple):
 2     &quot;&quot;&quot;
 3     将二叉树转换成三元组
 4     :param node: 节点
 5     :param data: 三元组
 6     :return:
 7     &quot;&quot;&quot;
 8     left = self.trans(node.left, data) if node.left.left else&lt;span&gt; node.left.value
 9     right = self.trans(node.right, data) if node.right.left else&lt;span&gt; node.right.value
10     data =&lt;span&gt; (node.value, left, right)
11     return data&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　现在已经能生成二叉树并得到表达式的三元组了，再就是求值了，下面是使用递归算法计算三元表达式的值的代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
 1 def&lt;span&gt; solution(e):
 2     &quot;&quot;&quot;
 3     计算表达式的值
 4     :param e: 转化成三元组表达的计算表达式
 5     :return:
 6     &quot;&quot;&quot;
 7     if type(e) ==&lt;span&gt; tuple:
 8         op, a, b = e[0], solution(e[1]), solution(e[2&lt;span&gt;])
 9         x, y =&lt;span&gt; float(a), float(b)
10         if op == &quot;+&quot;&lt;span&gt;:
11             return x +&lt;span&gt; y
12         if op == &quot;-&quot;&lt;span&gt;:
13             return x -&lt;span&gt; y
14         if op == &quot;*&quot;&lt;span&gt;:
15             return x *&lt;span&gt; y
16         if op == &quot;/&quot;&lt;span&gt;:
17             return x / y if y else&lt;span&gt; 0
18     else&lt;span&gt;:
19         return e&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　求解计算表达式的代码已经完成了，下面是使用这些代码来求&quot;1+2*3-4/5&quot;的代码示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
1 s = build_tree(&quot;1+2*3-4/5&quot;&lt;span&gt;)
2 tree =&lt;span&gt; Tree()
3 tree.root =&lt;span&gt; s
4 exp =&lt;span&gt; tree.trans(s, ())
5 print&lt;span&gt;(solution(exp))
6 # 6.2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Mon, 18 May 2020 00:30:00 +0000</pubDate>
<dc:creator>TM0831</dc:creator>
<og:description>一、树和森林 1.基本概念 树状图（Tree）又称为树，是一种复杂的数据结构。树是由 n（n&amp;gt;=0）个有限节点组成一个具有层次关系的集合，把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/TM0831/p/12907394.html</dc:identifier>
</item>
<item>
<title>MySQL 入门（5）：复制 - 红鸡菌</title>
<link>http://www.cnblogs.com/hongjijun/p/12908537.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hongjijun/p/12908537.html</guid>
<description>&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;p&gt;在这篇文章中，我将从MySQL为什么需要主从复制开始讲起，然后会提到MySQL复制的前提，&lt;code&gt;bin log&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在这里会说明三种格式的&lt;code&gt;bin log&lt;/code&gt;分别会有什么优缺点。&lt;/p&gt;
&lt;p&gt;随后会讲到主从延迟方面的问题，我将从几个角度出发，提供一些可能造成延迟的思路。&lt;/p&gt;
&lt;h2 id=&quot;1-为什么需要复制&quot;&gt;1 为什么需要复制&lt;/h2&gt;
&lt;p&gt;MySQL内建的复制功能是构建大型，高性能应用程序的基础。随着目前并发量的增加，单机的MySQL渐渐没有办法承担这些请求，所以MySQL服务器也需要进行扩展。&lt;/p&gt;
&lt;p&gt;MySQL的复制功能不仅可以提高可用性，还能用作灾备，数据仓库等。&lt;/p&gt;
&lt;h2 id=&quot;2-如何复制&quot;&gt;2 如何复制&lt;/h2&gt;
&lt;p&gt;说到复制，那么问题的关键就在于数据从主库复制到从库时间需要多少，准确度能有多高。&lt;/p&gt;
&lt;p&gt;对于MySQL来说，复制使用的是&lt;code&gt;bin log&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;对于&lt;code&gt;bin log&lt;/code&gt;相信你不会陌生，我们在聊到MySQL的“两阶段提交”的时候有说到这个。&lt;/p&gt;
&lt;p&gt;也就是说，MySQL会将主库记录的&lt;code&gt;bin log&lt;/code&gt;发送到从库中，然后从库按照&lt;code&gt;bin log&lt;/code&gt;的内容，“重放一遍”主库执行过的操作，达到主从同步的目的。&lt;/p&gt;
&lt;p&gt;在这里我们先详细说一说&lt;code&gt;bin log&lt;/code&gt;记录了什么。&lt;/p&gt;
&lt;h3 id=&quot;21-sbr（statement-based-replication）&quot;&gt;2.1 SBR（statement-based replication）&lt;/h3&gt;
&lt;p&gt;在这种模式下，&lt;code&gt;bin log&lt;/code&gt;会完整的记录下所执行的SQL语句。也就是说，如果使用了&lt;code&gt;statement&lt;/code&gt;格式的&lt;code&gt;bin log&lt;/code&gt;的话，主库执行的SQL语句就会在从库中完整的再执行一遍。&lt;/p&gt;
&lt;p&gt;可是，这样的做法，是有可能导致&lt;strong&gt;主从不一致&lt;/strong&gt;的。&lt;/p&gt;
&lt;p&gt;例如下面这样的语句：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;delete from t where a &amp;gt;= 1 and b =&amp;gt; 2 limit 1;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样的语句在从库中就不一定能够实现跟主库一样的效果。因为我们不能够确定在从库中是否走的跟主库是同样的索引，所查找的第一条数据，是不是跟主库一样的，也就可能删除的数据不是同一行。&lt;/p&gt;
&lt;p&gt;又或者主库执行的SQL语句里面有一些锁相关的语句，也可能会造成主从不一致的问题。&lt;/p&gt;
&lt;p&gt;但是要注意的是，&lt;code&gt;NOW()&lt;/code&gt;函数是可以被正确执行的，因为在&lt;code&gt;bin log&lt;/code&gt;语句中会记录时间戳。&lt;/p&gt;
&lt;p&gt;也就是说，基于&lt;code&gt;statement&lt;/code&gt;模式，在上下文不同的时候，是有可能造成数据不一致的。&lt;/p&gt;
&lt;p&gt;至于其他的不安全情况，可以参考官方文档，这里不展开介绍。&lt;/p&gt;
&lt;h3 id=&quot;22-rbr（row-based-replication）&quot;&gt;2.2 RBR（row-based replication）&lt;/h3&gt;
&lt;p&gt;既然&lt;code&gt;statement&lt;/code&gt;模式下会造成数据不一致，那么有没有一种模式是上下文无关的呢？&lt;/p&gt;
&lt;p&gt;所以就有了&lt;code&gt;row&lt;/code&gt;模式。&lt;/p&gt;
&lt;p&gt;在这个模式中，&lt;code&gt;bin log&lt;/code&gt;中只记录了所操作的行的修改情况，会精确到某一行。&lt;/p&gt;
&lt;p&gt;比如你更新了某一行，在&lt;code&gt;bin log&lt;/code&gt;中就会记录在id等于多少多少，某某字段等于多少多少的行中，将某个字段的值从A改成了B。&lt;/p&gt;
&lt;p&gt;甚至是删除操作，都会记录删除了id等于多少，A字段等于多少，B字段等于多少的一行数据。&lt;/p&gt;
&lt;p&gt;听到这里你可能会觉得很方便，也很精确，主从不再会发生不一致的情况了。甚至于删库了都不需要跑路了，只需要查看&lt;code&gt;bin log&lt;/code&gt;就能恢复相应的数据了。&lt;/p&gt;
&lt;p&gt;但是使用&lt;code&gt;row&lt;/code&gt;模式同样会有一些问题。比如你在主库执行了&lt;code&gt;delete from t where id &amp;lt; 10000&lt;/code&gt;这么一行sql语句，如果使用&lt;code&gt;statement&lt;/code&gt;格式，在&lt;code&gt;bin log&lt;/code&gt;内记录只有这么一条，但是如果你使用的是&lt;code&gt;row&lt;/code&gt;模式，那么就需要记录10000条数据，占用很大的空间。&lt;/p&gt;
&lt;h3 id=&quot;23-mbr（mixd-based-replication）&quot;&gt;2.3 MBR（mixd-based replication）&lt;/h3&gt;
&lt;p&gt;于是就有了&lt;code&gt;mixd&lt;/code&gt;模式。&lt;/p&gt;
&lt;p&gt;混合了以上两种模式的优点，MySQL会在没有歧义的时候使用&lt;code&gt;statement&lt;/code&gt;格式，在有歧义的时候使用&lt;code&gt;row&lt;/code&gt;格式。&lt;/p&gt;
&lt;h2 id=&quot;3-复制的具体过程&quot;&gt;3 复制的具体过程&lt;/h2&gt;
&lt;p&gt;上面介绍了&lt;code&gt;bin log&lt;/code&gt;的作用，以及&lt;code&gt;bin log&lt;/code&gt;的组成形式，在这一章中我们聊一聊整个的复制流程。&lt;/p&gt;
&lt;p&gt;我们拿《高性能MySQL》中的图来解释：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1998080/202005/1998080-20200518082225139-1090144077.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里涉及到了有三个线程：&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Binlog dump thread&lt;br/&gt;这个线程在MySQL主库中，负责读取&lt;code&gt;bin log&lt;/code&gt;中的内容，并将这些内容推送到从库IO进程中。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;I/O thread&lt;br/&gt;这个线程在MySQL从库中，负责跟主库建立一条长连接，并且将读取到的&lt;code&gt;bin log&lt;/code&gt;数据保存到从库的中继日志（relay log）中。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;SQL thread&lt;br/&gt;这个线程也是在MySQL的从库中，负责读取中继日志中的内容，然后执行这些语句，将对数据的修改应用到从库中。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;简单的来讲，就是主库经过两阶段提交后，把修改内容保存在了&lt;code&gt;bin log&lt;/code&gt;中，然后把这个&lt;code&gt;bin log&lt;/code&gt;发送给从库，让从库也执行一次，以达到同步的目的。&lt;/p&gt;
&lt;p&gt;而这里采用了中继日志的原因是从库消费&lt;code&gt;bin log&lt;/code&gt;的速度和主库生产&lt;code&gt;bin log&lt;/code&gt;的速度是不一致的，所以需要一个中继日志作为缓冲。&lt;/p&gt;
&lt;h2 id=&quot;4-复制可能造成的问题&quot;&gt;4 复制可能造成的问题&lt;/h2&gt;
&lt;p&gt;在MySQL复制的过程中，经常出现的问题是&lt;strong&gt;延迟&lt;/strong&gt;。&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;假设我们把主库一个事务提交后&lt;code&gt;bin log&lt;/code&gt;落盘的时间点设为t1&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;把从库接受到主库新事务写的&lt;code&gt;bin log&lt;/code&gt;并写入&lt;code&gt;relay log&lt;/code&gt;的时间节点设为t2&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;把从库执行完这个新的事务的时间节点设为t3&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;那么执行一条事务，从库的延迟可以认为是（t3 - t1）。&lt;/p&gt;
&lt;p&gt;也就是说，如果我们需要分析造成主从延迟的原因，应该从两个方面考虑：传输过程，以及从库消费&lt;code&gt;relay log&lt;/code&gt;的速度。&lt;/p&gt;
&lt;h3 id=&quot;41-网络问题&quot;&gt;4.1 网络问题&lt;/h3&gt;
&lt;p&gt;网络确实可能会造成主从延迟，比如主库或者从库的带宽打满，又或者是主库的&lt;code&gt;bin log&lt;/code&gt;被设置成了&lt;code&gt;row&lt;/code&gt;格式，导致有大量的数据需要传输，造成了主库的&lt;code&gt;bin log&lt;/code&gt;没有及时的同步到从库中，导致了主从的延迟。&lt;/p&gt;
&lt;h3 id=&quot;42-机器性能&quot;&gt;4.2 机器性能&lt;/h3&gt;
&lt;p&gt;但是除了网络，更多的是从库的消费速度，跟不上主库的生产速度。&lt;/p&gt;
&lt;p&gt;这方面有很多原因，比如可能从库的机器配置低于主库，因为会有人觉得既然是备库，没什么请求，就把备库配置在了比较差的机器上面。&lt;/p&gt;
&lt;p&gt;又或者在是后台的数据分析，将CPU打满。&lt;/p&gt;
&lt;p&gt;总之，如果在从库中需要有大量的查询分析操作，需要考虑多个从库。&lt;/p&gt;
&lt;h3 id=&quot;43-大事务&quot;&gt;4.3 大事务&lt;/h3&gt;
&lt;p&gt;如果主库执行了一条耗时很长的事务，那么这条事务发送到从库中，可能也需要执行这么长的时间。而这个时候，从库是没有办法继续消费新的&lt;code&gt;relay log&lt;/code&gt;的。这就造成了主从延迟。&lt;/p&gt;
&lt;h3 id=&quot;44-锁&quot;&gt;4.4 锁&lt;/h3&gt;
&lt;p&gt;我们之前提到过了，不仅仅写数据会加锁，使用“当前读”，也一样可能会加锁。&lt;/p&gt;
&lt;p&gt;所以，如果在从库上执行了一些诸如&lt;code&gt;select ... for update&lt;/code&gt;，或者一些DDL语句，可能也会造成从库加锁，导致主从延迟。&lt;/p&gt;
&lt;h3 id=&quot;45-并发&quot;&gt;4.5 并发&lt;/h3&gt;
&lt;p&gt;在我们上面的介绍中，SQL线程是单线程的，所以，如果能够让SQL线程可以并发消费，那么主从延迟就可以大幅度的降低了。&lt;/p&gt;
&lt;p&gt;关于MySQL的并发复制策略，MySQL5.6开始已经正式支持了，本文不详细解释。&lt;/p&gt;
&lt;h2 id=&quot;写在最后&quot;&gt;写在最后&lt;/h2&gt;
&lt;p&gt;首先，谢谢你能看到这里。&lt;/p&gt;
&lt;p&gt;这一篇的文章，其实说的内容不多，大多都是一些理论性质的内容，目的是能够对MySQL的主从复制有一些大体上的了解，并且知道对于延迟方面的问题，应该从哪个方向去考虑。&lt;/p&gt;
&lt;p&gt;至于其他更具体的操作、如何调优，以及更深的原理，我想在今后的《进阶篇》来提到。&lt;/p&gt;
&lt;p&gt;并且，《MySQL 入门》系列到这里就完结了。希望这五篇的内容能够给你带来一些帮助，能够让你对MySQL的了解更深一些。&lt;/p&gt;
&lt;p&gt;当然了，在学习MySQL的过程中，我可能也会有一些错误的理解，如果有哪里是不对的，希望你能指出，谢谢你！&lt;/p&gt;
&lt;p&gt;PS：如果有其他的问题，也可以在公众号找到我，欢迎来找我玩~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1998080/202005/1998080-20200518082249440-1884537618.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 18 May 2020 00:23:00 +0000</pubDate>
<dc:creator>红鸡菌</dc:creator>
<og:description>摘要 在这篇文章中，我将从MySQL为什么需要主从复制开始讲起，然后会提到MySQL复制的前提， 。 在这里会说明三种格式的 分别会有什么优缺点。 随后会讲到主从延迟方面的问题，我将从几个角度出发，提</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/hongjijun/p/12908537.html</dc:identifier>
</item>
<item>
<title>读懂操作系统(x86)之堆栈帧（过程调用） - Jeffcky</title>
<link>http://www.cnblogs.com/CreateMyself/p/12891581.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CreateMyself/p/12891581.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;为进行基础回炉，接下来一段时间我将持续更新汇编和操作系统相关知识，希望通过屏蔽底层细节能让大家明白每节所阐述内容。当我们写下如下C代码时背后究竟发生了什么呢？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
#include &amp;lt;stdio.h&amp;gt;
&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; a = &lt;span&gt;2&lt;/span&gt;, b = &lt;span&gt;3&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; func(&lt;span&gt;int&lt;/span&gt; a, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; b);
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; c =&lt;span&gt; func(a, b);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d\n%d\n%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,a, b, c);
}

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; func(&lt;span&gt;int&lt;/span&gt; a, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; b)
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; c = &lt;span&gt;20&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; a + b +&lt;span&gt; c;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来我们gcc编译器通过如下命令&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
gcc -S fileName.c
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将其转换为如下AT＆T语法的汇编代码（看不懂的童鞋可自行忽略，接下来我会屏蔽细节，从头开始分析如下汇编代码的本质）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt;_main:
LFB13:
 .cfi_startproc
 pushl &lt;/span&gt;%&lt;span&gt;ebp
 movl &lt;/span&gt;%esp, %&lt;span&gt;ebp
 andl $&lt;/span&gt;-&lt;span&gt;16&lt;/span&gt;, %&lt;span&gt;esp
 subl $&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;, %&lt;span&gt;esp
 call ___main
 movl $&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;28&lt;/span&gt;(%&lt;span&gt;esp)
 movl $&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;, &lt;span&gt;24&lt;/span&gt;(%&lt;span&gt;esp)
 movl &lt;/span&gt;&lt;span&gt;24&lt;/span&gt;(%esp), %&lt;span&gt;eax
 movl &lt;/span&gt;%eax, &lt;span&gt;4&lt;/span&gt;(%&lt;span&gt;esp)
 movl &lt;/span&gt;&lt;span&gt;28&lt;/span&gt;(%esp), %&lt;span&gt;eax
 movl &lt;/span&gt;%eax, (%&lt;span&gt;esp)
 call _func
 movl &lt;/span&gt;%eax, &lt;span&gt;20&lt;/span&gt;(%&lt;span&gt;esp)
 movl &lt;/span&gt;&lt;span&gt;20&lt;/span&gt;(%esp), %&lt;span&gt;eax
 movl &lt;/span&gt;%eax, &lt;span&gt;12&lt;/span&gt;(%&lt;span&gt;esp)
 movl &lt;/span&gt;&lt;span&gt;24&lt;/span&gt;(%esp), %&lt;span&gt;eax
 movl &lt;/span&gt;%eax, &lt;span&gt;8&lt;/span&gt;(%&lt;span&gt;esp)
 movl &lt;/span&gt;&lt;span&gt;28&lt;/span&gt;(%esp), %&lt;span&gt;eax
 movl &lt;/span&gt;%eax, &lt;span&gt;4&lt;/span&gt;(%&lt;span&gt;esp)
 movl $LC0, (&lt;/span&gt;%&lt;span&gt;esp)
 call _printf
 movl $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;, %&lt;span&gt;eax
 leave
 .cfi_restore &lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;
 .cfi_def_cfa &lt;/span&gt;&lt;span&gt;4&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;&lt;span&gt;
 ret
 .cfi_endproc
LFE13:
 .globl _func
 .def _func; .scl &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;; .type &lt;span&gt;32&lt;/span&gt;&lt;span&gt;; .endef
_func:
LFB14:
 .cfi_startproc
 pushl &lt;/span&gt;%&lt;span&gt;ebp
 movl &lt;/span&gt;%esp, %&lt;span&gt;ebp
 subl $&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;, %&lt;span&gt;esp
 movl $&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;, -&lt;span&gt;4&lt;/span&gt;(%&lt;span&gt;ebp)
 movl &lt;/span&gt;&lt;span&gt;8&lt;/span&gt;(%ebp), %&lt;span&gt;edx
 movl &lt;/span&gt;&lt;span&gt;12&lt;/span&gt;(%ebp), %&lt;span&gt;eax
 addl &lt;/span&gt;%eax, %&lt;span&gt;edx
 movl &lt;/span&gt;-&lt;span&gt;4&lt;/span&gt;(%ebp), %&lt;span&gt;eax
 addl &lt;/span&gt;%edx, %&lt;span&gt;eax
 leave
 .cfi_restore &lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;
 .cfi_def_cfa &lt;/span&gt;&lt;span&gt;4&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;&lt;span&gt;
 ret
 .cfi_endproc
LFE14:
 .ident &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;GCC: (MinGW.org GCC Build-20200227-1) 9.2.0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
 .def _printf; .scl &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;; .type &lt;span&gt;32&lt;/span&gt;; .endef
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;CPU提供了基于栈的数据结构，当我们利用push和pop指令时说明会将寄存器上某一块地址作为栈来使用，但是当我们执行push或者pop指令时怎么知道哪一个单元是栈顶呢？此时将涉及到两个寄存器，段寄存器SS和寄存器SP，栈顶的段地址存放在SS中，而偏移地址存放在SP中，通过SS:SP即（段地址/基础地址 + 偏移地址 = 物理地址），因为堆栈是向下增长，所以当我们进行比如push ax（操作数和结果数据的累加器）即将ax压入栈时，会进行如下两步操作：（1）SP = SP - 2，SS:SP指向当前栈顶前面的单元，以当前栈顶前面的单元作为新的栈顶（画外音：SP就是堆栈指针）（2）将ax中的内容送入SS:SP指向的内存单元处，SS:SP指向新栈顶。&lt;/p&gt;
&lt;p&gt;那么CPU提供基于堆栈的数据结构可以用来做什么呢？&lt;span&gt;堆栈的主要用途在于过程调用，一个堆栈将由一个或多个堆栈帧组成，每个堆栈帧（也称作活动记录）对应于对尚未以返回终止的函数或过程的调用，堆栈帧本质就是函数或者方法。我们知道对于函数或者方法有参数、局部变量、返回值。所以对于堆栈帧由函数参数、指向前一个堆栈帧的反向指针、局部变量组成。&lt;/span&gt;有了上述基础知识铺垫，接下来我们来分析在主函数中对函数调用如何利用汇编代码实现&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; c =&lt;span&gt; func(a, b);

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; func(&lt;span&gt;int&lt;/span&gt; a, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; b)
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; c = &lt;span&gt;20&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; a + b +&lt;span&gt; c;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;参数&lt;/h2&gt;
&lt;p&gt;当调用func时，我们需要通过push指令将参数压入堆栈，此时在堆栈中入栈顺序如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;push b
push a
call func&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当每个参数被推到堆栈上时，由于堆栈会向下生长，所以将堆栈指针寄存器减4个字节（在32位模式下），并将该参数复制到堆栈指针寄存器所指向的存储位置。注意：指令会隐式将返回地址压入堆栈。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;栈帧&lt;/h2&gt;
&lt;p&gt;接下来进入被调用函数即进入栈帧，如果我们想要访问参数，可以像如下访问（注意：sp为早期处理器堆栈指针，如下esp为intel x86堆栈指针，只是名称不同而已）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[esp + &lt;span&gt;0&lt;/span&gt;]   - &lt;span&gt;return&lt;/span&gt;&lt;span&gt; address
[esp &lt;/span&gt;+ &lt;span&gt;4&lt;/span&gt;]   - parameter &lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
[esp &lt;/span&gt;+ &lt;span&gt;8&lt;/span&gt;]   - parameter &lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后我们开始为局部变量c分配空间，但是如果我们还是利用esp来指向函数局部变量将会出现问题，因为esp作为堆栈指针，若在其过程中执行push（推送）或者pop（弹出）操作时，esp堆栈指针将会发生变化，此时将导致esp无法真正引用其中任何变量即通过esp表示的局部变量的偏移地址不再有效，偏移量由编译器所计算并在指令中为其硬编码，所以在执行程序期间很难对其进行更改。&lt;/p&gt;

&lt;p&gt;为了解决这个问题，我们引入帧指针寄存器（bp），当被调用函数或方法开始执行时，我们将其设置为堆栈帧的地址，如果代码将局部变量称为相对于帧指针的偏移量而不是相对于堆栈指针的偏移量，则程序可以使用堆栈指针而不会使对自动变量的访问复杂化，然后，我们将堆栈帧中的某些内容称为offset（$ fp）而不是offset（$ sp）。&lt;/p&gt;

&lt;p&gt;上述帧指针寄存器从严格意义上来说称作为堆栈基指针寄存器（bp：base pointer），我们希望将堆栈基指针寄存器设置为当前帧，而不是先前的函数，因此，我们将旧的保存在堆栈上（这将修改堆栈上参数的偏移量），然后将当前的堆栈指针寄存器复制到堆栈基指针寄存器。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;push ebp        ; 保存之前的堆栈基指针寄存器
mov  ebp, esp   ; ebp &lt;/span&gt;= esp
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;局部变量&lt;/h2&gt;
&lt;p&gt;局部变量存在堆栈中，所以接下来我们通过esp为局部变量分配内存单元空间，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
sub esp, bytes ; bytes为局部变量所需的字节大小
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上意思则是，sub为单词（subtraction）相减缩写，堆栈向下增长（根据处理器不同可能方向有所不同，但通常是向下增长比如x86-64），若局部变量为3个(int)即双字，则字节大小为12，则堆栈指帧向上减去12即esp-12（注：这种说法不是很准确，涉及到具体细节，可暂且这样理解）。 如上所述最终将完成堆栈帧调用，最终我们将所有内容放在一起，则是如下这般&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[ebp + &lt;span&gt;12&lt;/span&gt;]  - parameter &lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
[ebp &lt;/span&gt;+ &lt;span&gt;8&lt;/span&gt;]   - parameter &lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
[ebp &lt;/span&gt;+ &lt;span&gt;4&lt;/span&gt;]   - &lt;span&gt;return&lt;/span&gt;&lt;span&gt; address
[ebp &lt;/span&gt;+ &lt;span&gt;0&lt;/span&gt;]   - saved stackbase-pointer register
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当调用函数或方法完毕后，对堆栈帧必须进行清理即进行内存释放和恢复先前堆栈帧指针寄存器继续往下执行，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;mov esp, ebp   ; 释放局部变量内存空间
pop ebp        ; 恢复先前的堆栈帧指针寄存器&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上只是从整体上去对堆栈帧调用的大概说明，我们来看看局部变量和参数基于ebp的偏移量是为正值还是负值&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;10&quot;&gt;
&lt;code class=&quot;hljs&quot; readability=&quot;14&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; a, b, c;&lt;br/&gt;a = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;&lt;br/&gt;b = &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;;&lt;br/&gt;c = &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;;&lt;br/&gt;}&lt;p&gt;执行:&lt;br/&gt;push ebp&lt;br/&gt;mov ebp, esp&lt;/p&gt;&lt;p&gt;高地址&lt;br/&gt;|&lt;br/&gt;|&amp;lt;--------------  ebp = esp &lt;br/&gt;|&lt;br/&gt;| &lt;br/&gt;低地址&lt;/p&gt;&lt;p&gt;执行:&lt;br/&gt;sub esp, &lt;span class=&quot;hljs-number&quot;&gt;12&lt;/span&gt;&lt;/p&gt;&lt;p&gt;高地址&lt;br/&gt;|&lt;br/&gt;|&amp;lt;--------------  ebp&lt;br/&gt;|&lt;br/&gt;|&amp;lt;--------------  esp&lt;br/&gt;|&lt;br/&gt;| &lt;br/&gt;低地址&lt;/p&gt;&lt;p&gt;执行：&lt;br/&gt;mov [ebp&lt;span class=&quot;hljs-number&quot;&gt;-4&lt;/span&gt;], &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;&lt;br/&gt;mov [ebp&lt;span class=&quot;hljs-number&quot;&gt;-8&lt;/span&gt;], &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;&lt;br/&gt;mov [ebp&lt;span class=&quot;hljs-number&quot;&gt;-12&lt;/span&gt;], &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;&lt;/p&gt;&lt;p&gt;高地址&lt;br/&gt;| &lt;br/&gt;| &lt;br/&gt;| &amp;lt;--------------  ebp&lt;br/&gt;|&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;&lt;br/&gt;|&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;&lt;br/&gt;|&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;&lt;br/&gt;| &amp;lt;--------------- esp&lt;br/&gt;低地址&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如上所述在进入函数后，旧的ebp值将被压入堆栈，并将ebp设置为esp的值，然后esp递减（因为堆栈在内存中向下增长），以便为函数的局部变量和临时变量分配空间。从那一刻起，在函数执行期间，函数的参数位于堆栈上，因为它们在函数调用之前被压入，所以与ebp的偏移量为正值，而局部变量位于与ebp的偏移量为负值的位置，因为它们是在函数输入之后分配在堆栈上（如上图分析）。到这里我们将开始所写的函数最终在堆栈中的内存位置是怎样的呢？图解如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/589642/202005/589642-20200514215124412-251231106.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后我们将上述通过AT＆T语法转换的汇编代码转换为intel语法汇编代码可能会更好理解一点&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
gcc -S -masm=intel &lt;span&gt;1&lt;/span&gt;.c
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;二者只不过是对应指令所使用符号有所不同而已，比如操作数为立即数时，AT＆T语法将添加$符号，而intel语法不会，对上述函数调用进行详细解释，如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;主函数栈帧    &lt;/span&gt;
&lt;span&gt;_main:
LFB13:
    push    ebp
    mov    ebp, esp
    and    esp, &lt;/span&gt;-&lt;span&gt;16&lt;/span&gt;&lt;span&gt;
    sub    esp, &lt;/span&gt;&lt;span&gt;32&lt;/span&gt;&lt;span&gt;
    call    ___main
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将立即数2写入【esp+28】&lt;/span&gt;
    mov    DWORD PTR [esp+&lt;span&gt;28&lt;/span&gt;], &lt;span&gt;2&lt;/span&gt;
    
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将立即数3写入【esp+24】&lt;/span&gt;
    mov    DWORD PTR [esp+&lt;span&gt;24&lt;/span&gt;], &lt;span&gt;3&lt;/span&gt;
    
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将【esp+24】值写入寄存器eax&lt;/span&gt;
    mov    eax, DWORD PTR [esp+&lt;span&gt;24&lt;/span&gt;&lt;span&gt;]
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将寄存器eax中的值（即3）写入【esp+4】&lt;/span&gt;
    mov    DWORD PTR [esp+&lt;span&gt;4&lt;/span&gt;&lt;span&gt;], eax
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将[esp+28]值写入eax寄存器&lt;/span&gt;
    mov    eax, DWORD PTR [esp+&lt;span&gt;28&lt;/span&gt;&lt;span&gt;]
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将寄存器eax中的值（即2）写入【esp+0】&lt;/span&gt;
&lt;span&gt;    mov    DWORD PTR [esp], eax
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用_func函数，此时将返回地址压入栈&lt;/span&gt;
&lt;span&gt;    call    _func
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将eax寄存器的值结果（即25）写入【esp+20】&lt;/span&gt;
    mov    DWORD PTR [esp+&lt;span&gt;20&lt;/span&gt;&lt;span&gt;], eax
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将【esp+20】值写入eax寄存器&lt;/span&gt;
    mov    eax, DWORD PTR [esp+&lt;span&gt;20&lt;/span&gt;&lt;span&gt;]
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将寄存器eax中的值写入【esp+12】 = 25&lt;/span&gt;
    mov    DWORD PTR [esp+&lt;span&gt;12&lt;/span&gt;&lt;span&gt;], eax
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将【esp+24】值写入eax寄存器&lt;/span&gt;
    mov    eax, DWORD PTR [esp+&lt;span&gt;24&lt;/span&gt;&lt;span&gt;]
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将寄存器eax中的值写入【esp+8】 = 3&lt;/span&gt;
    mov    DWORD PTR [esp+&lt;span&gt;8&lt;/span&gt;&lt;span&gt;], eax
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将【esp+28】值写入eax寄存器&lt;/span&gt;
    mov    eax, DWORD PTR [esp+&lt;span&gt;28&lt;/span&gt;&lt;span&gt;]
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将寄存器eax中的值写入【esp+4】 = 2&lt;/span&gt;
    mov    DWORD PTR [esp+&lt;span&gt;4&lt;/span&gt;&lt;span&gt;], eax
    
    mov    DWORD PTR [esp], OFFSET FLAT:LC0
    
    call    _printf
    
    mov    eax, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
    leave
    ret
    
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;被调用函数（_func）栈帧    &lt;/span&gt;
&lt;span&gt;_func:
LFB14:
    push    ebp
    mov    ebp, esp
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;为函数局部变量分配16个字节空间&lt;/span&gt;
    sub    esp, &lt;span&gt;16&lt;/span&gt;
    
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将立即数写入偏移栈帧4位的地址上&lt;/span&gt;
    mov    DWORD PTR [ebp-&lt;span&gt;4&lt;/span&gt;], &lt;span&gt;20&lt;/span&gt;
    
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将偏移栈帧8位上的地址值（即2）写入edx寄存器&lt;/span&gt;
    mov    edx, DWORD PTR [ebp+&lt;span&gt;8&lt;/span&gt;&lt;span&gt;]
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将偏移栈帧12位上的地址值（即3）写入eax寄存器&lt;/span&gt;
    mov    eax, DWORD PTR [ebp+&lt;span&gt;12&lt;/span&gt;&lt;span&gt;]
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将eax寄存器中的值和edx寄存器中的值相加即（a+b） = 5&lt;/span&gt;
&lt;span&gt;    add    edx, eax
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将偏移栈帧地址4位上的地址值（即20）写入寄存器eax&lt;/span&gt;
    mov    eax, DWORD PTR [ebp-&lt;span&gt;4&lt;/span&gt;&lt;span&gt;]
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将eax寄存器值和edx寄存器存储的值相加即（20+c） = 25&lt;/span&gt;
&lt;span&gt;    add    eax, edx
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;相当于执行（move esp,ebp; pop ebp;）有效清除堆栈帧空间&lt;/span&gt;
&lt;span&gt;    leave
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;相当于执行（pop ip），从堆栈中弹出返回地址，并将控制权返回到该位置&lt;/span&gt;
    ret
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上述对汇编代码的详细解释可能对零基础的汇编童鞋理解起来还是有很大困难，接下来我将再一次通过图解方式一步步给大家做出明确的解释，通过对堆栈帧的学习我们能够知道函数或方法调用的具体细节以及高级语言中值类型复制的原理，它的本质是什么呢？接下来我们一起来看看。（注：英特尔架构上的堆栈从高内存增长到低内存，因此堆栈的顶部（最新内容）位于低内存地址中）。&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/589642/202005/589642-20200515190712481-1277775786.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在主函数栈帧如图所示，首先分配局部变量内存空间，然后保存主函数的堆栈帧，最后将2和3分别压入栈，接下来进入调用函数，如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/589642/202005/589642-20200515154306085-1921269521.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后开始调用函数，当执行call指令时会将返回地址压入栈以便执行栈帧上的ret指令时进行返回，将当前堆栈针移动到堆栈针，定义了堆栈帧的开始，从此刻开始进行函数调用内部，如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/589642/202005/589642-20200515154802594-1067523847.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;首先我们保存先前的ebp值，并将堆栈帧指针设置为堆栈的顶部（堆栈指针的当前位置），&lt;/span&gt;&lt;span&gt;然后我们通过从堆栈指针中减去16个字节来增加堆栈为局部变量分配空间，在此堆栈框架中&lt;/span&gt;&lt;span&gt;，包含该函数的本地数据、&lt;/span&gt;&lt;span&gt;帧指针ebp的负偏移量（栈的顶部，到较低的内存中）r表示本地变量、&lt;/span&gt;&lt;span&gt;ebp的正偏移量将使我们能够读取传入的参数，接下来则是&lt;/span&gt;&lt;/span&gt;将局部变量c设置为20，完成后，通过leave指令将堆栈指针设置为帧指针的值（ebp），并弹出保存的帧指针值，有效地释放堆栈帧内存空间，此时，堆栈指针指向函数返回地址，执行ret指令时弹出堆栈，并将控制转移到call指令压入栈的返回地址，继续往下执行。&lt;/p&gt;
&lt;h2&gt;堆栈帧解惑&lt;/h2&gt;
&lt;p&gt;通过如上图解对比汇编代码分析可以为我们解惑两大问题，我们看到将操作数为立即数的a = 2和 b = 3入栈【esp+28】和【esp+24】的地址上，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将立即数2写入【esp+28】&lt;/span&gt;
mov    DWORD PTR [esp+&lt;span&gt;28&lt;/span&gt;], &lt;span&gt;2&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将立即数3写入【esp+24】&lt;/span&gt;
mov    DWORD PTR [esp+&lt;span&gt;24&lt;/span&gt;], &lt;span&gt;3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是我们会发现接下来会将2和3将通过寄存器eax分别写入到栈为【esp+4】和【esp+0】的地址上，但是最终获取变量a和b的值依然是对应地址【esp+28】和【esp+24】，这就是高级语言中值类型的原理即深度复制（副本）：&lt;span&gt;通过寄存器传递（比如eax）将值副本存储到堆栈帧上其他内存单元地址，参数值即从该内存单元获取。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将【esp+24】值写入寄存器eax&lt;/span&gt;
mov    eax, DWORD PTR [esp+&lt;span&gt;24&lt;/span&gt;&lt;span&gt;]

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将寄存器eax中的值（即3）写入【esp+4】&lt;/span&gt;
mov    DWORD PTR [esp+&lt;span&gt;4&lt;/span&gt;&lt;span&gt;], eax

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将[esp+28]值写入eax寄存器&lt;/span&gt;
mov    eax, DWORD PTR [esp+&lt;span&gt;28&lt;/span&gt;&lt;span&gt;]

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将寄存器eax中的值（即2）写入【esp+0】&lt;/span&gt;
&lt;span&gt;mov    DWORD PTR [esp], eax

调用完函数后：

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将【esp+24】值写入eax寄存器&lt;/span&gt;
mov    eax, DWORD PTR [esp+&lt;span&gt;24&lt;/span&gt;&lt;span&gt;]

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将寄存器eax中的值写入【esp+8】 = 3&lt;/span&gt;
mov    DWORD PTR [esp+&lt;span&gt;8&lt;/span&gt;&lt;span&gt;], eax

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将【esp+28】值写入eax寄存器&lt;/span&gt;
mov    eax, DWORD PTR [esp+&lt;span&gt;28&lt;/span&gt;&lt;span&gt;]

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将寄存器eax中的值写入【esp+4】 = 2&lt;/span&gt;
mov    DWORD PTR [esp+&lt;span&gt;4&lt;/span&gt;], eax
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将变量a和b复制到栈【esp+0】和【esp+4】地址上，就是将其作为函数或方法的调用参数，即使进行修改操作也不会修改原有变量的值，但是我们会发现在函数中当获取变量a和b的值是通过【ebp+8】和【ebp+12】来获取&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将偏移栈帧8位上的地址值（即2）写入edx寄存器&lt;/span&gt;
mov    edx, DWORD PTR [ebp+&lt;span&gt;8&lt;/span&gt;&lt;span&gt;]

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将偏移栈帧12位上的地址值（即3）写入eax寄存器&lt;/span&gt;
mov    eax, DWORD PTR [ebp+&lt;span&gt;12&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;若是看到上述汇编代码时存在看不懂的情况，结合图解3将一目了然，参数通过基于当前堆栈帧的偏移位移来获取，因为在调用函数时也将返回地址和函数的ebp压入栈，最终将堆栈针指向当前函数的ebp，所以相对于当前函数的堆栈帧而言，变量a和b的地址自然而然就变成了【ebp+8】和【ebp+12】。&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;经典的书籍针对栈顶的定义&lt;span&gt;&lt;span&gt;实际上是指&lt;/span&gt;&lt;span&gt;堆栈所占内存区域中&lt;/span&gt;&lt;span&gt;的最低地址，和我们自然习惯有所不同，有些文章若是指向堆栈内存高地址，这种说法是错误的。&lt;/span&gt;&lt;/span&gt;存在帧指针寄存器（ebp）存在的主要原因在于堆栈指针（sp）的值会发生变化，但是这只是历史遗留问题针对早期的处理器而言，现如今处理器对于sp有些已具备offset（相对寻址）属性，所以对于帧指针寄存器是可选的，不过利用bp在跟踪和调试函数的参数和局部变量更加方便。一个调用堆栈由1个或多个堆栈帧组成，每个堆栈帧对应于对尚未以返回终止的函数或过程的调用。要使用栈帧，线程保留两个指针，一个称为堆栈指针（SP），另一个称为帧指针（FP）。SP始终指向堆栈的顶部，而FP始终指向帧的顶部。此外，该线程还维护一个程序计数器（PC），该计数器指向要执行的下一条指令。栈帧中局部变量为负偏移量，参数为正偏移量。&lt;/p&gt;
</description>
<pubDate>Sun, 17 May 2020 23:55:00 +0000</pubDate>
<dc:creator>Jeffcky</dc:creator>
<og:description>前言 为进行基础回炉，接下来一段时间我将持续更新汇编和操作系统相关知识，希望通过屏蔽底层细节能让大家明白每节所阐述内容。当我们写下如下C代码时背后究竟发生了什么呢？ #include &amp;lt;stdi</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/CreateMyself/p/12891581.html</dc:identifier>
</item>
<item>
<title>服务器软件大扫盲 - 沉默王二</title>
<link>http://www.cnblogs.com/qing-gee/p/12908502.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qing-gee/p/12908502.html</guid>
<description>&lt;p&gt;先说一句哈，自从在 B 站开始刷视频后，我就觉得要学的内容实在是太多了。这篇“服务器软件大扫盲”就是我看了羊哥的一期视频后有感而发的，比如说 Web 服务器、HTTP 服务器、应用服务器这三个概念，我是见过很多次，但如果你非要我说出它们之间的区别的话，我只好哑口无言。&lt;/p&gt;
&lt;p&gt;还有，我自己用过的 Tomcat、Nginx、Apache、Jetty、Undertow，它们之间有什么优缺点，嗯。。。。。。只好继续哑口无言。可能有很多小伙伴和我一样，用过，但具体的差别还真的说不上来，所以我打算借这个机会来和大家一起学习下。（我就是课代表，我骄傲）&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/05/java-fuwuqi-01.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;先来说 Web 服务器，它一般指的是网站服务器，可以向浏览器（PC端或者移动端）等 Web 客户端提供服务，供请求数据或者下载数据。服务器使用 HTTP （超文本传输协议）和客户端浏览器进行通信，因此我们也把 Web 服务器称作为 HTTP 服务器。&lt;/p&gt;
&lt;p&gt;再来说应用服务器，它是一种软件框架，提供一个应用程序运行的环境。通常用于为应用程序提供安全、数据、事务支持、负载平衡大型分布式系统管理等服务。&lt;/p&gt;
&lt;p&gt;在我看来，Web 服务器和应用服务器之间的界限已经非常模糊，后者更高级一点，就好像公司与企业这两个名词之间的差别。&lt;/p&gt;
&lt;p&gt;常见的 Web 服务器软件包括 Nginx、Apache、IIS，常见的应用服务器软件包括 WebLogic、JBoss，前者更轻量级，后者更重量级。&lt;/p&gt;
&lt;p&gt;接下来，我们就来唠唠常见的一些服务器软件。&lt;/p&gt;
&lt;h3 id=&quot;h01tomcat&quot;&gt;&lt;span&gt;01、Tomcat&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;就我的程序生涯来看，Tomcat 用的算是最多了，没有之一。如果 Tomcat 安装成功的话，可以在本地的浏览器中访问 http://127.0.0.1:8080 来展示它的默认首页，见下图。&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/05/java-fuwuqi-02.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;Tomcat 是由 Apache 软件基金会属下 Jakarta 项目开发的 Servlet 容器，实现了对 Servlet 和 JavaServer Page（JSP）的支持，并提供了作为 Web 服务器的一些特有功能。&lt;/p&gt;
&lt;p&gt;JSP 是由 Sun Microsystems 公司主导建立的一种动态网页技术标准。 JSP 可以响应客户端发送的请求，并根据请求内容动态地生成 HTML、XML 或其他格式文档的 Web 网页，然后返回给请求者。&lt;/p&gt;
&lt;p&gt;JSP 以 Java 语言作为脚本语言，为用户的 HTTP 请求提供服务，并能与服务器上的其它 Java 程序共同处理复杂的业务需求。我是一名三线城市的 Java 程序员，免不了要开发一些小型网站，这也就是为什么我用 Tomcat 最多的原因。&lt;/p&gt;
&lt;h3 id=&quot;h02nginx&quot;&gt;&lt;span&gt;02、Nginx&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;Nginx 是一款轻量级的 Web 服务器、也支持反向代理，由于它的内存占用少，启动极快，高并发能力强，所以在互联网项目中广泛应用。&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/05/java-fuwuqi-03.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;关于 Nginx，比较令人遗憾的一件事是，它的作者伊戈尔·赛索耶夫进了监狱。&lt;/p&gt;
&lt;p&gt;Nginx 在官方测试的结果中，能够支持五万个并行连接，国内比较有名的公司，比如说百度、京东、新浪、网易、腾讯、淘宝等都在使用。&lt;/p&gt;
&lt;p&gt;不知道你有没有听过虚拟主机的概念，就是在 Web 服务里有一个独立的网站站点，这个站点对应独立的域名（也可能是IP 或端口），具有独立的程序及资源，可以独立地对外提供服务供用户访问。&lt;/p&gt;
&lt;p&gt;虚拟主机有三种类型：基于域名的虚拟主机、基于端口的虚拟主机、基于 IP 的虚拟主机。&lt;/p&gt;
&lt;p&gt;Nginx 可以使用一个 &lt;code&gt;server{}&lt;/code&gt; 标签来标识一个虚拟主机，一个 Web 服务里可以有多个虚拟主机标签对，即可以同时支持多个虚拟主机站点。这一点，非常的实用。&lt;/p&gt;
&lt;h3 id=&quot;h03apache&quot;&gt;&lt;span&gt;03、Apache&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;最开始的时候，我以为 Apache 就是 Tomcat，傻傻分不清楚。后来知道它们完全不同，logo 就不同（说什么大实话）。&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/05/java-fuwuqi-04.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;Apache 一般是指 Apache HTTP Server，是 Apache 软件基金会（和 Tomcat 同属一家基金会，因此容易混淆）下的一个网页服务器软件。由于其跨平台和安全性，被广泛使用，是最流行的 Web 服务器软件之一。它快速、可靠并且可通过简单的 API 扩展。&lt;/p&gt;
&lt;p&gt;我是在服务器上安装 WordPress 的时候用到了 Apache，当时并不知道有 LAMP 的存在，所以安装的过程中吃了很多苦，关键是最后没有安装成功，大写的尴尬。&lt;/p&gt;
&lt;p&gt;最后还是在青铜群里的一个群友的远程帮助下才完成安装的，他是搞 PHP 的。LAMP 就是他告诉我的，安装起来非常的傻瓜式，非常适合我这种对命令行有抗拒心理的程序员。&lt;/p&gt;
&lt;p&gt;LAMP 是指一组运行动态网站或者服务器的自由软件名称首字母缩写：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;Linux，操作系统（一般服务器软件都安装在 Linux 上，性能极佳）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Apache，网页服务器（就是 Apache HTTP Server）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;MariaDB 或 MySQL，数据库管理系统&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;PHP、Perl 或 Python，脚本语言&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这些软件配合起来使用的时候，极具活力，它的变体还有很多，另外一个比较有名的就是 LNMP，用 Nginx 代替 Apache。&lt;/p&gt;
&lt;h3 id=&quot;h04jetty&quot;&gt;&lt;span&gt;04、Jetty&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;Jetty 和 Tomcat 有很多相似之处，比如说可以为 JSP 和 Servlet 提供运行时环境。Jetty 是 Java 语言编写的，它的 API 以一组 JAR 包的形式发布。&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/05/java-fuwuqi-05.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;与 Tomcat 相比，Jetty 可以同时处理大量链接并且长时间的保持这些链接，例如，一些 Web 聊天应用非常适合用 Jetty 服务器，比如说淘宝的 Web 版旺旺。&lt;/p&gt;
&lt;p&gt;Jetty 的架构比较简单，它有一个基本数据模型，这个数据模型就是 Handler，所有可以被扩展的组件都可以作为一个 Handler，添加到 Server 中，Jetty 就是帮我们管理这些 Handler 的。&lt;/p&gt;
&lt;h3 id=&quot;h05undertow&quot;&gt;&lt;span&gt;05、Undertow&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;Undertow 是一个用 Java 编写的、灵活的、高性能的 Web 服务器，提供基于 NIO 的阻塞和非阻塞 API。&lt;/p&gt;
&lt;p&gt;Undertow 可以嵌入到应用程序中或独立运行，只需几行代码，非常容易上手。下面这段代码是官网提供的一个使用 Async IO 的简单 Hello World 服务器示例：&lt;/p&gt;
&lt;pre readability=&quot;6.5&quot;&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;7&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;HelloWorldServer&lt;/span&gt; &lt;/span&gt;{&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;final&lt;/span&gt; String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;Undertow server = Undertow.builder()&lt;br/&gt;.addHttpListener(&lt;span class=&quot;hljs-number&quot;&gt;8080&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;localhost&quot;&lt;/span&gt;)&lt;br/&gt;.setHandler(&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; HttpHandler() {&lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;handleRequest&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;final&lt;/span&gt; HttpServerExchange exchange)&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;exchange.getResponseHeaders().put(Headers.CONTENT_TYPE, &lt;span class=&quot;hljs-string&quot;&gt;&quot;text/plain&quot;&lt;/span&gt;);&lt;br/&gt;exchange.getResponseSender().send(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Hello World&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;}).build();&lt;br/&gt;server.start();&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;直接运行后，在浏览器中地址栏中输入 &lt;code&gt;http://localhost:8080&lt;/code&gt; 就可以访问到了。是不是感觉非常轻巧？&lt;/p&gt;
&lt;p&gt;如果有小伙伴使用过 JFinal 开发过小型网站的话，对 Undertow 应该不会陌生，因为 JFinal 的默认容器已经切换到了 Undertow。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;JFinal 是基于 Java 语言的极速 WEB + ORM 框架，其核心设计目标是开发迅速、代码量少、学习简单、功能强大、轻量级、易扩展、Restful。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;h06&quot;&gt;&lt;span&gt;06、企业级&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;至于其他的一些企业级服务器软件，我个人没有用过，就不细说了。&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;JBoss，红帽子收购过，后更名为 WildFly。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;WebLogic，甲骨文出品。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;WebSphere，IBM 公司出品。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;相信小伙伴们看了出品方，就知道这些服务器软件足够的重量级，都是大佬，都是大佬。&lt;/p&gt;
&lt;p&gt;如果觉得文章对你有点帮助，请微信搜索「 &lt;strong&gt;沉默王二&lt;/strong&gt; 」第一时间阅读。&lt;/p&gt;
&lt;blockquote readability=&quot;4.4565217391304&quot;&gt;
&lt;p&gt;本文已收录 GitHub，&lt;a href=&quot;https://github.com/qinggee/itwanger.github.io&quot;&gt;&lt;strong&gt;传送门~&lt;/strong&gt;&lt;/a&gt; ，里面更有大厂面试完整考点，欢迎 Star。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我是沉默王二，一枚有颜值却靠才华苟且的程序员。&lt;strong&gt;关注即可提升学习效率，别忘了三连啊，点赞、收藏、留言，我不挑，嘻嘻&lt;/strong&gt;。&lt;/p&gt;
</description>
<pubDate>Sun, 17 May 2020 23:53:00 +0000</pubDate>
<dc:creator>沉默王二</dc:creator>
<og:description>先说一句哈，自从在 B 站开始刷视频后，我就觉得要学的内容实在是太多了。这篇“服务器软件大扫盲”就是我看了羊哥的一期视频后有感而发的，比如说 Web 服务器、HTTP 服务器、应用服务器这三个概念，我</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qing-gee/p/12908502.html</dc:identifier>
</item>
<item>
<title>（Python基础教程之八）Python中的list操作 - 分布式编程</title>
<link>http://www.cnblogs.com/daichangya/p/12908499.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/daichangya/p/12908499.html</guid>
<description>&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://zthinker.com/archives/python%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B&quot;&gt;Python基础教程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zthinker.com/archives/%E5%9C%A8sublimeeditor%E4%B8%AD%E9%85%8D%E7%BD%AEpython%E7%8E%AF%E5%A2%83&quot;&gt;在SublimeEditor中配置Python环境&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zthinker.com/archives/python%E4%BB%A3%E7%A0%81%E4%B8%AD%E6%B7%BB%E5%8A%A0%E6%B3%A8%E9%87%8A&quot;&gt;Python代码中添加注释&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zthinker.com/archives/python%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F%E7%9A%84%E4%BD%BF%E7%94%A8&quot;&gt;Python中的变量的使用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zthinker.com/archives/python%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B&quot;&gt;Python中的数据类型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zthinker.com/archives/python%E4%B8%AD%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97&quot;&gt;Python中的关键字&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zthinker.com/archives/python%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C&quot;&gt;Python字符串操作&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zthinker.com/archives/python%E4%B8%AD%E7%9A%84list%E6%93%8D%E4%BD%9C&quot;&gt;Python中的list操作&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zthinker.com/archives/python%E4%B8%AD%E7%9A%84tuple%E6%93%8D%E4%BD%9C&quot;&gt;Python中的Tuple操作&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zthinker.com/archives/pythonmax%E5%92%8Cmin%E5%9C%A8%E5%88%97%E8%A1%A8%E6%88%96%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%9C%80%E5%A4%A7%E5%80%BC%E5%92%8C%E6%9C%80%E5%B0%8F%E5%80%BC&quot;&gt;Pythonmax（）和min（）–在列表或数组中查找最大值和最小值&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zthinker.com/archives/python%E6%89%BE%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84n%E4%B8%AA%E5%89%8Dn%E4%B8%AA%E6%88%96%E6%9C%80%E5%B0%8F%E7%9A%84n%E4%B8%AA%E9%A1%B9%E7%9B%AE&quot;&gt;Python找到最大的N个（前N个）或最小的N个项目&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zthinker.com/archives/python%E8%AF%BB%E5%86%99csv%E6%96%87%E4%BB%B6&quot;&gt;Python读写CSV文件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zthinker.com/archives/python%E4%B8%AD%E4%BD%BF%E7%94%A8httplib2httpget%E5%92%8Cpost%E7%A4%BA%E4%BE%8B&quot;&gt;Python中使用httplib2–HTTPGET和POST示例&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zthinker.com/archives/python%E5%B0%86tuple%E5%BC%80%E7%AE%B1%E4%B8%BA%E5%8F%98%E9%87%8F%E6%88%96%E5%8F%82%E6%95%B0&quot;&gt;Python将tuple开箱为变量或参数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zthinker.com/archives/python%E5%BC%80%E7%AE%B1tuple%E5%A4%AA%E5%A4%9A%E5%80%BC%E6%97%A0%E6%B3%95%E8%A7%A3%E5%8E%8B&quot;&gt;Python开箱Tuple–太多值无法解压&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zthinker.com/archives/pythonmultidict%E7%A4%BA%E4%BE%8B%E5%B0%86%E5%8D%95%E4%B8%AA%E9%94%AE%E6%98%A0%E5%B0%84%E5%88%B0%E5%AD%97%E5%85%B8%E4%B8%AD%E7%9A%84%E5%A4%9A%E4%B8%AA%E5%80%BC&quot;&gt;Pythonmultidict示例–将单个键映射到字典中的多个值&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zthinker.com/archives/pythonordereddict%E6%9C%89%E5%BA%8F%E5%AD%97%E5%85%B8&quot;&gt;PythonOrderedDict–有序字典&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zthinker.com/archives/python%E5%AD%97%E5%85%B8%E4%BA%A4%E9%9B%86%E6%AF%94%E8%BE%83%E4%B8%A4%E4%B8%AA%E5%AD%97%E5%85%B8&quot;&gt;Python字典交集–比较两个字典&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zthinker.com/archives/python%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%E7%A4%BA%E4%BE%8B&quot;&gt;Python优先级队列示例&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;在&lt;a href=&quot;https://zthinker.com/archives/python%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B&quot;&gt;Python中&lt;/a&gt;，列表为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;有序&lt;/li&gt;
&lt;li&gt;索引（索引从0开始）&lt;/li&gt;
&lt;li&gt;易变的&lt;/li&gt;
&lt;li&gt;异构的（列表中的项目不必是同一类型）&lt;/li&gt;
&lt;li&gt;写为方括号之间的逗号分隔值列表&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;listOfSubjects = ['physics', 'chemistry', &quot;mathematics&quot;]
listOfIds = [0, 1, 2, 3, 4]
miscList = [0, 'one', 2, 'three']
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;1-access-list-items&quot;&gt;1. Access list items&lt;/h2&gt;
&lt;p&gt;要访问列表中的值，请使用切片语法或数组索引形式的方括号来获取单个项目或项目范围。&lt;/p&gt;
&lt;p&gt;传递的索引值可以是正数或负数。如果索引是负数则从列表的末尾开始计数。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;list [m : n]&lt;/code&gt;表示子列表从索引&lt;code&gt;m&lt;/code&gt;（包括）开始，到索引&lt;code&gt;n&lt;/code&gt;（不包括）结束。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果&lt;code&gt;m&lt;/code&gt;未提供，则假定其值为零。&lt;/li&gt;
&lt;li&gt;如果&lt;code&gt;n&lt;/code&gt;未提供，则选择范围直到列表的最后。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;ids = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
print( ids[0] )                 # 0
print( ids[1:5] )               # [1, 2, 3, 4]
print( ids[ : 3] )              # [0, 1, 2]
print( ids[7 : ] )              # [7, 8, 9]\
print( ids[-8:-5] )             # [2, 3, 4]
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;2-modily-list&quot;&gt;2. Modily list&lt;/h2&gt;
&lt;p&gt;要更改列表中的特定项目，请使用其索引引用该项目并分配一个新值。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;charList =  [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
charList [2] = &quot;d&quot;
print (charList)        # ['a', 'b', 'd']
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;3-iterate-a-list&quot;&gt;3. Iterate a list&lt;/h2&gt;
&lt;p&gt;我们可以使用来遍历列表项&lt;code&gt;for loop&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;charList =  [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]

for x in charList:
        print(x)

# a
# b
# c
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;4-check-if-a-item-exists-in-the-list&quot;&gt;4. Check if a item exists in the list&lt;/h2&gt;
&lt;p&gt;使用&lt;code&gt;'in'&lt;/code&gt;关键字确定列表中是否存在指定的项目。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;charList =  [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
if &quot;a&quot; in charList:
        print(&quot;a is present&quot;) # a is present

if &quot;d&quot; in charList:
        print(&quot;d is present&quot;)
else:
        print(&quot;d is NOT present&quot;)     # d is NOT present
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;5-finding-length-of-the-list&quot;&gt;5. Finding length of the list&lt;/h2&gt;
&lt;p&gt;使用该&lt;code&gt;len()&lt;/code&gt;函数查找给定列表的长度。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;charList =  [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
x = len (charList)
print (x)       # 3
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;6-adding-items&quot;&gt;6. Adding items&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;要将项目添加到列表的末尾，请使用&lt;code&gt;append(item)&lt;/code&gt;方法。&lt;/li&gt;
&lt;li&gt;要在特定索引位置添加项目，请使用&lt;code&gt;insert(index, item)&lt;/code&gt;方法。如果&lt;code&gt;index&lt;/code&gt;大于索引长度，则将项目添加到列表的末尾。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;charList =  [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
charList.append(&quot;d&quot;)  
charList.append(&quot;e&quot;)
print (charList)                # ['a', 'b', 'c', 'd', 'e']
charList.insert(5, &quot;f&quot;)

print (charList)                # ['a', 'b', 'c', 'd', 'e', 'f']

charList.insert(10, &quot;h&quot;)      # No error 

print (charList)        # ['a', 'b', 'c', 'd', 'e', 'f', 'h']
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;7-removing-items&quot;&gt;7. Removing items&lt;/h2&gt;
&lt;p&gt;若要从列表中删除项目，四个途径使用一个，即&lt;code&gt;remove()&lt;/code&gt;，&lt;code&gt;pop()&lt;/code&gt;，&lt;code&gt;clear()&lt;/code&gt;或&lt;code&gt;del&lt;/code&gt;关键字。&lt;/p&gt;
&lt;h4 id=&quot;71-remove&quot;&gt;7.1. remove()&lt;/h4&gt;
&lt;p&gt;它通过其值删除指定的项目。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;charList =  [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
charList.remove(&quot;c&quot;)  
print (charList)                # ['a', 'b']
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;72-pop&quot;&gt;7.2. pop()&lt;/h4&gt;
&lt;p&gt;它通过索引删除指定的项目。如果未提供index，它将从列表中删除最后一项。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;charList =  [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]
charList.pop()                  # removes 'd' - last item
print (charList)                # ['a', 'b', 'c']
charList.pop(1)                 # removes 'b'
print (charList)                # ['a', 'c']
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;73-clear&quot;&gt;7.3. clear()&lt;/h4&gt;
&lt;p&gt;它清空列表。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;charList =  [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]
charList.clear()        
print (charList)                # []
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;74-del-keyword&quot;&gt;7.4. del keyword&lt;/h4&gt;
&lt;p&gt;它可以用来&lt;strong&gt;从列表的索引中删除项目&lt;/strong&gt;。我们也可以使用它&lt;strong&gt;删除整个列表&lt;/strong&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;charList =  [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]
del charList[0] 

print (charList)                # ['b', 'c', 'd']

del charList

print (charList)                # NameError: name 'charList' is not defined
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;8-join-two-lists&quot;&gt;8. Join two lists&lt;/h2&gt;
&lt;p&gt;我们可以使用&lt;code&gt;&quot;+&quot;&lt;/code&gt;运算符或&lt;code&gt;extend()&lt;/code&gt;函数将两个给定的列表加入Python 。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;charList = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
numList = [1, 2, 3]

list1 = charList + numList

print (list1)   # ['a', 'b', 'c', 1, 2, 3]

charList.extend(numList)

print (charList)        # ['a', 'b', 'c', 1, 2, 3]
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;9-python-list-methods&quot;&gt;9. Python list methods&lt;/h2&gt;
&lt;h4 id=&quot;91-append&quot;&gt;9.1. append()&lt;/h4&gt;
&lt;p&gt;在列表的末尾添加一个元素。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;charList =  [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]

charList.append(&quot;d&quot;)

print (charList)        # [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;92-clear&quot;&gt;9.2. clear()&lt;/h4&gt;
&lt;p&gt;从列表中删除所有元素。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;charList =  [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]

charList.clear()

print (charList)        # []
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;93-copy&quot;&gt;9.3. copy()&lt;/h4&gt;
&lt;p&gt;返回列表的副本。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;charList =  [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
newList = charList.copy()
print (newList) # [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;94-count&quot;&gt;9.4. count()&lt;/h4&gt;
&lt;p&gt;返回具有指定值的元素数。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;charList =  [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
x = charList.count('a')
print (x)       # 1
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;95-extend&quot;&gt;9.5. extend()&lt;/h4&gt;
&lt;p&gt;将列表的元素添加到当前列表的末尾。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;charList = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
numList = [1, 2, 3]
charList.extend(numList)

print (charList)        # ['a', 'b', 'c', 1, 2, 3]
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;96-index&quot;&gt;9.6. index()&lt;/h4&gt;
&lt;p&gt;返回具有指定值的第一个元素的索引。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;charList =  [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
x = charList.index('a')
print (x)       # 0
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;97-insert&quot;&gt;9.7. insert()&lt;/h4&gt;
&lt;p&gt;在指定位置添加元素。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;charList =  [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
charList.insert(3, 'd')
print (charList)        # ['a', 'b', 'c', 'd']
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;98-pop&quot;&gt;9.8. pop()&lt;/h4&gt;
&lt;p&gt;删除指定位置或列表末尾的元素。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;charList =  [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]
charList.pop()                  # removes 'd' - last item
print (charList)                # ['a', 'b', 'c']
charList.pop(1)                 # removes 'b'
print (charList)                # ['a', 'c']
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;99-remove&quot;&gt;9.9. remove()&lt;/h4&gt;
&lt;p&gt;删除具有指定值的项目。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;charList =  [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]
charList.remove('d')
print (charList)                # ['a', 'b', 'c']
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;910-reverse&quot;&gt;9.10. reverse()&lt;/h4&gt;
&lt;p&gt;颠倒列表中项目的顺序。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;charList =  [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]
charList.reverse()
print (charList)                # ['d', 'c', 'b', 'a']
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;911-sort&quot;&gt;9.11. sort()&lt;/h4&gt;
&lt;p&gt;默认情况下，以升序对给定列表进行排序。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;charList =  [&quot;a&quot;, &quot;c&quot;, &quot;b&quot;, &quot;d&quot;]
charList.sort()
print (charList)                # [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;学习愉快！&lt;/p&gt;
</description>
<pubDate>Sun, 17 May 2020 23:50:00 +0000</pubDate>
<dc:creator>分布式编程</dc:creator>
<og:description>1. &amp;quot;Python基础教程&amp;quot; 2. &amp;quot;在SublimeEditor中配置Python环境&amp;quot; 3. &amp;quot;Python代码中添加注释&amp;quot; 4. &amp;</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/daichangya/p/12908499.html</dc:identifier>
</item>
<item>
<title>数据源管理 | OLAP查询引擎，ClickHouse集群化管理 - 知了一笑</title>
<link>http://www.cnblogs.com/cicada-smile/p/12908498.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cicada-smile/p/12908498.html</guid>
<description>&lt;p&gt;本文源码：&lt;a href=&quot;https://github.com/cicadasmile/data-manage-parent&quot;&gt;GitHub·点这里&lt;/a&gt; || &lt;a href=&quot;https://gitee.com/cicadasmile/data-manage-parent&quot;&gt;GitEE·点这里&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;ClickHouse是俄罗斯的Yandex公司于2016年开源的列式存储数据库（DBMS），主要用于OLAP在线分析处理查询，能够使用SQL查询实时生成分析数据报告。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;列式存储&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1691717/202005/1691717-20200518073501212-231131744.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;行式存储和列式存储，数据在磁盘上的组织结构有着根本不同，数据分析计算时，行式存储需要遍历整表，列式存储只需要遍历单个列，所以列式库更适合做大宽表，用来做数据分析计算。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;絮叨一句&lt;/code&gt;&lt;/strong&gt;：注意这里比较的场景，是数据分析计算的场景。&lt;/p&gt;

&lt;h2 id=&quot;1、基础环境&quot;&gt;1、基础环境&lt;/h2&gt;
&lt;p&gt;ClickHouse单服务默认已经安装完毕&lt;/p&gt;
&lt;h2 id=&quot;2、取消文件限制&quot;&gt;2、取消文件限制&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;vim /etc/security/limits.conf
vim /etc/security/limits.d/90-nproc.conf
文件末尾追加
* soft nofile 65536 
* hard nofile 65536 
* soft nproc 131072 
* hard nproc 131072
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;3、取消selinux&quot;&gt;3、取消SELINUX&lt;/h2&gt;
&lt;p&gt;修改/etc/selinux/config中的SELINUX=disabled后重启&lt;/p&gt;
&lt;h2 id=&quot;4、集群配置文件&quot;&gt;4、集群配置文件&lt;/h2&gt;
&lt;p&gt;服务分别添加集群配置:vim /etc/metrika.xml&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;yandex&amp;gt;
&amp;lt;clickhouse_remote_servers&amp;gt;
    &amp;lt;clickhouse_cluster&amp;gt;
        &amp;lt;shard&amp;gt;
            &amp;lt;internal_replication&amp;gt;true&amp;lt;/internal_replication&amp;gt;
            &amp;lt;replica&amp;gt;
                &amp;lt;host&amp;gt;192.168.72.133&amp;lt;/host&amp;gt;
                &amp;lt;port&amp;gt;9000&amp;lt;/port&amp;gt;
            &amp;lt;/replica&amp;gt;
        &amp;lt;/shard&amp;gt;
        &amp;lt;shard&amp;gt;
            &amp;lt;replica&amp;gt;
                &amp;lt;internal_replication&amp;gt;true&amp;lt;/internal_replication&amp;gt;
                &amp;lt;host&amp;gt;192.168.72.136&amp;lt;/host&amp;gt;
                &amp;lt;port&amp;gt;9000&amp;lt;/port&amp;gt;
            &amp;lt;/replica&amp;gt;
        &amp;lt;/shard&amp;gt;
        &amp;lt;shard&amp;gt;
            &amp;lt;internal_replication&amp;gt;true&amp;lt;/internal_replication&amp;gt;
            &amp;lt;replica&amp;gt;
                &amp;lt;host&amp;gt;192.168.72.137&amp;lt;/host&amp;gt;
                &amp;lt;port&amp;gt;9000&amp;lt;/port&amp;gt;
            &amp;lt;/replica&amp;gt;
        &amp;lt;/shard&amp;gt;
    &amp;lt;/clickhouse_cluster&amp;gt;
&amp;lt;/clickhouse_remote_servers&amp;gt;

&amp;lt;zookeeper-servers&amp;gt;
  &amp;lt;node index=&quot;1&quot;&amp;gt;
    &amp;lt;host&amp;gt;192.168.72.133&amp;lt;/host&amp;gt;
    &amp;lt;port&amp;gt;2181&amp;lt;/port&amp;gt;
  &amp;lt;/node&amp;gt;
  &amp;lt;node index=&quot;2&quot;&amp;gt;
    &amp;lt;host&amp;gt;192.168.72.136&amp;lt;/host&amp;gt;
    &amp;lt;port&amp;gt;2181&amp;lt;/port&amp;gt;
  &amp;lt;/node&amp;gt;
  &amp;lt;node index=&quot;3&quot;&amp;gt;
    &amp;lt;host&amp;gt;192.168.72.137&amp;lt;/host&amp;gt;
    &amp;lt;port&amp;gt;2181&amp;lt;/port&amp;gt;
  &amp;lt;/node&amp;gt;
&amp;lt;/zookeeper-servers&amp;gt;

&amp;lt;macros&amp;gt;
    &amp;lt;replica&amp;gt;192.168.72.133&amp;lt;/replica&amp;gt;
&amp;lt;/macros&amp;gt;

&amp;lt;networks&amp;gt;
   &amp;lt;ip&amp;gt;::/0&amp;lt;/ip&amp;gt;
&amp;lt;/networks&amp;gt;

&amp;lt;clickhouse_compression&amp;gt;
&amp;lt;case&amp;gt;
  &amp;lt;min_part_size&amp;gt;10000000000&amp;lt;/min_part_size&amp;gt;
  &amp;lt;min_part_size_ratio&amp;gt;0.01&amp;lt;/min_part_size_ratio&amp;gt;
  &amp;lt;method&amp;gt;lz4&amp;lt;/method&amp;gt;
&amp;lt;/case&amp;gt;
&amp;lt;/clickhouse_compression&amp;gt;
&amp;lt;/yandex&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意这里&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;macros&amp;gt;
    &amp;lt;replica&amp;gt;192.168.72.133&amp;lt;/replica&amp;gt;
&amp;lt;/macros&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配置各自服务的IP地址。&lt;/p&gt;
&lt;h2 id=&quot;5、启动集群&quot;&gt;5、启动集群&lt;/h2&gt;
&lt;p&gt;分别启动三台服务&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;service clickhouse-server start
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;6、登录客户端查看&quot;&gt;6、登录客户端查看&lt;/h2&gt;
&lt;p&gt;这里登录任意一台服务就好&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;clickhouse-client
en-master :) select * from system.clusters
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1691717/202005/1691717-20200518073447168-1293517238.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里这里集群名称：clickhouse_cluster，后续使用。&lt;/p&gt;
&lt;h2 id=&quot;7、基本环境测试&quot;&gt;7、基本环境测试&lt;/h2&gt;
&lt;p&gt;三台服务上同时创建表结构。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;CREATE TABLE ontime_local (FlightDate Date,Year UInt16) ENGINE = MergeTree(FlightDate, (Year, FlightDate), 8192);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;133环境创建分布表&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;CREATE TABLE ontime_all AS ontime_local ENGINE = Distributed(clickhouse_cluster, default, ontime_local, rand());
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;随便写入一台服务数据&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;insert into ontime_local (FlightDate,Year) values ('2020-03-12',2020);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查询总表&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select * from ontime_all;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;写入总表，数据会分布到各个单表中&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;insert into ontime_all (FlightDate,Year)values('2001-10-12',2001);
insert into ontime_all (FlightDate,Year)values('2002-10-12',2002);
insert into ontime_all (FlightDate,Year)values('2003-10-12',2003);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;任意关闭一台服务，集群查询直接挂掉&lt;/p&gt;

&lt;h2 id=&quot;1、基础配置&quot;&gt;1、基础配置&lt;/h2&gt;
&lt;p&gt;url：配置全部的服务列表，主要用来管理表结构，批量处理；&lt;/p&gt;
&lt;p&gt;cluster：集群连接服务，可以基于Nginx代理服务配置；&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;spring:
  datasource:
    type: com.alibaba.druid.pool.DruidDataSource
    click:
      driverClassName: ru.yandex.clickhouse.ClickHouseDriver
      url: jdbc:clickhouse://127.0.0.1:8123/default,jdbc:clickhouse://127.0.0.1:8123/default,jdbc:clickhouse://127.0.0.1:8123/default
      cluster: jdbc:clickhouse://127.0.0.1:8123/default
      initialSize: 10
      maxActive: 100
      minIdle: 10
      maxWait: 6000
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;2、管理接口&quot;&gt;2、管理接口&lt;/h2&gt;
&lt;p&gt;分别向每个单节点服务创建表和写入数据：&lt;/p&gt;
&lt;p&gt;data_shard(单节点数据)&lt;/p&gt;
&lt;p&gt;data_all(分布数据)&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@RestController
public class DataShardWeb {

    @Resource
    private JdbcFactory jdbcFactory ;

    /**
     * 基础表结构创建
     */
    @GetMapping(&quot;/createTable&quot;)
    public String createTable (){
        List&amp;lt;JdbcTemplate&amp;gt; jdbcTemplateList = jdbcFactory.getJdbcList();
        for (JdbcTemplate jdbcTemplate:jdbcTemplateList){
            jdbcTemplate.execute(&quot;CREATE TABLE data_shard (FlightDate Date,Year UInt16) ENGINE = MergeTree(FlightDate, (Year, FlightDate), 8192)&quot;);
            jdbcTemplate.execute(&quot;CREATE TABLE data_all AS data_shard ENGINE = Distributed(clickhouse_cluster, default, data_shard, rand())&quot;);
        }
        return &quot;success&quot; ;
    }

    /**
     * 节点表写入数据
     */
    @GetMapping(&quot;/insertData&quot;)
    public String insertData (){
        List&amp;lt;JdbcTemplate&amp;gt; jdbcTemplateList = jdbcFactory.getJdbcList();
        for (JdbcTemplate jdbcTemplate:jdbcTemplateList){
            jdbcTemplate.execute(&quot;insert into data_shard (FlightDate,Year) values ('2020-04-12',2020)&quot;);
        }
        return &quot;success&quot; ;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;3、集群查询&quot;&gt;3、集群查询&lt;/h2&gt;
&lt;p&gt;上述步骤执行完成后，可以连接集群服务查询分布总表和单表的数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;基于Druid连接&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Configuration
public class DruidConfig {

    @Resource
    private JdbcParamConfig jdbcParamConfig ;

    @Bean
    public DataSource dataSource() {
        DruidDataSource datasource = new DruidDataSource();
        datasource.setUrl(jdbcParamConfig.getCluster());
        datasource.setDriverClassName(jdbcParamConfig.getDriverClassName());
        datasource.setInitialSize(jdbcParamConfig.getInitialSize());
        datasource.setMinIdle(jdbcParamConfig.getMinIdle());
        datasource.setMaxActive(jdbcParamConfig.getMaxActive());
        datasource.setMaxWait(jdbcParamConfig.getMaxWait());
        return datasource;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;基于mapper查询&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;mapper namespace=&quot;com.ckhouse.cluster.mapper.DataAllMapper&quot;&amp;gt;

    &amp;lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.ckhouse.cluster.entity.DataAllEntity&quot;&amp;gt;
        &amp;lt;result column=&quot;FlightDate&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;flightDate&quot; /&amp;gt;
        &amp;lt;result column=&quot;Year&quot; jdbcType=&quot;INTEGER&quot; property=&quot;year&quot; /&amp;gt;
    &amp;lt;/resultMap&amp;gt;

    &amp;lt;select id=&quot;getList&quot; resultMap=&quot;BaseResultMap&quot; &amp;gt;
        select * from data_all where Year=2020
    &amp;lt;/select&amp;gt;
&amp;lt;/mapper&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;

&lt;pre&gt;
&lt;code&gt;GitHub·地址
https://github.com/cicadasmile/data-manage-parent
GitEE·地址
https://gitee.com/cicadasmile/data-manage-parent
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1691717/201908/1691717-20190823075428183-1996768914.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;推荐阅读：数据源管理&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 17 May 2020 23:49:00 +0000</pubDate>
<dc:creator>知了一笑</dc:creator>
<og:description>本文源码： &amp;quot;GitHub&amp;#183;点这里&amp;quot; || &amp;quot;GitEE&amp;#183;点这里&amp;quot; 一、列式库简介 ClickHouse是俄罗斯的Yandex公司于2016</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cicada-smile/p/12908498.html</dc:identifier>
</item>
<item>
<title>互联网一线大厂社招面试都问啥问题？ - 龙跃十二</title>
<link>http://www.cnblogs.com/zhonglongbo/p/12908484.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhonglongbo/p/12908484.html</guid>
<description>&lt;blockquote data-tool=&quot;mdnice编辑器&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;少点代码，多点头发&lt;/p&gt;
&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上篇给大家写了 &lt;a href=&quot;https://mp.weixin.qq.com/s/X9iXnLut3EoOC_tSMledyA&quot;&gt;应届生工作一年不到，从被裁到上岸，我们该如何自渡？如何保证自己的核心竞争力？&lt;/a&gt; 反响很好。但是吧，我犯了一个错误，敖丙提醒我的。&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlly1gelgd783abj30xu07i3zb.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;太难了，失业这几天没发原创，连个原创都忘记标了，真是傻🐶。 所以我今天又放了一次次条，这次可标了原创。没看的赶紧看看，稳稳的有帮助。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大大小小也面试了快十家公司了，有些非常重要的面试题和面试经验必须给大家整出来。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先声明，我投的岗位是搜索方向、后端开发(偏底层、高性能)、java后台(这个岗位是阿里面试官看我简历让我试试的)。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;面试的问题主要分为几块去说，C&amp;amp;C++&amp;amp;STL、数据结构与算法(含编程)、操作系统、多线程问题、场景题目、项目。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;项目在社招面试中占据的分数很高，所以面试讲项目的时间会多。项目细节就不给大家透漏了，会把项目中的知识点穿插到对应的知识模块。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;项目这块&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这一块一定是面试最重要的地方。在整个社招面试的时候，自我介绍从来都是从项目说起，不会像校招那样会介绍来自哪里，叫什么名字，会什么技术。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每次自我介绍都是这样说的：&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;做了什么项目&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;如果项目是独立设计和开发，要描述为什么做这个项目，设计思路&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;我在项目中扮演什么角色(如果是团队项目，一定描述清楚自己做了什么功能，起到什么作用)&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;项目包括哪几个模块，每个模块实现什么功能&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;项目用了哪些技术，为什么选择用这些&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;项目中那些点是非常有意义的，为什么&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基本就是这些，在讲项目的时候注意要埋伏一些重要的伏笔，比如项目亮点，直说这些亮点非常好，至于原因可以铺垫下，引起面试官的好奇。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;阿里面试官给过我一些建议，非常中肯的，也给大家说说。&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlly1geli0g5kssj30by108wm9.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不得不说大佬的建议非常有力量的。看完大佬给的建议赶紧重新梳理了一遍项目、看看项目有哪些亮点技术和设计、那些难点、产生什么价值。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是说项目的方式和准备项目方面。面试过程中，面试官问项目是真的问到你很多都是想不到的。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你可能觉得是个很简单的问题，平时不会在意那种，但面试官深深的挖，总感觉下面有矿一样。&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlly1geli9d3u7qj305405ijr9.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可能面试官总是能通过这种细节撂倒你，你也觉得就是你的问题，没掌握好。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举个例子，高效的网络IO底层大多都是epoll实现的。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;面试官先是问我epoll的原理，底层用什么实现？为什么高效？红黑树结构中epoll结构体怎么样的？回调使用什么触发的？epoll的边缘触发和水平触发？操作系统怎么管理信号的？为什么这里用红黑树不用哈希表？等等。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就这样一层一层的往下挖，一直挖穿为止。有时候你都说道操作系统，硬件中断层面了。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是面试官还是如饥似渴，难道还需要说说高低电平，载波脉冲么？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以项目真的要细节掌握透彻，就连有时候用的一些依赖库什么的，你都的知道为啥用这个，有没有更好的？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;项目问的&lt;strong&gt;细&lt;/strong&gt;是一方面，还有一方面就是问的&lt;strong&gt;深&lt;/strong&gt;。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举个例子，当时说项目中用了一种高效的内存分配器，没有用原生的ptmalloc(也就是malloc)。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不要说new了，new的底层还是mallloc。是因为减少多线程情况下的锁开销，每次malloc都会进行加锁和解锁的过程。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;面试官紧接着就问，那你用了tcmalloc的确减少了在多线程情况下的锁性能问题。如果我让你继续优化你有什么方法？也是在多线程情况下，内存分配问题。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;紧接着又问，你刚刚说减少锁的性能开销，那你知道操作系统层面，锁的代价是多大么？你知道操作系统是怎么加锁的么(锁的原理是什么)？&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlly1gelique2a2j3073073748.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我是真的服，面试官什么都懂。🐂，遇到不会的只能说这块我没掌握，说下我的理解吧。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;社招，项目这块说的好可以占据很高的分，具体多大比例看面试项目契合度了。如果你的项目刚好对方公司也用到了，那就是基本聊项目聊完。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说的不好，那就有点难了。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总结一下，项目到底该如何准备？如何说？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;准备方面，几个核心点。&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;为什么要做这个项目？&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;怎么做的？&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;项目中那些亮点、难点、价值？&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;项目完成，有没有解决当初的问题？收益怎么样？&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如何说，其实简单。只要你准备好了，说清楚，说精彩。最好还能说得跌宕起伏，在穿插几个故事。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实项目再怎么准备都不为过，不管是从项目的深度，项目的细节。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;C&amp;amp;C++&amp;amp;STL问题&lt;/span&gt;&lt;/h3&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;程序编译问题&lt;/span&gt;&lt;/h4&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;程序编译整个过程？每个步骤都干了什么？&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;词法分析，分析什么？语法分析，分析什么？语义分析，分析什么？&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个问题我很清楚，是阿里问的。这就是说编译原理了，虽说不是科班出身，但是书还是略微看过。&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlly1gem8r6mqb2j313z0u0b29.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不用惊讶，都是为了&lt;strong&gt;修行&lt;/strong&gt;。&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;每个过程怎么用GCC编译的？&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;如何进行反汇编？&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;对象模型问题&lt;/span&gt;&lt;/h4&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;C++有哪几种对象模型，C++现在使用的那一种？&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;普通继承的对象模型是怎么样的？存在虚函数的继承对象模型是怎样？&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;虚继承的对象模型是怎样的？为什么需要虚继承？解决什么问题？&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;多重继承对下模型？&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;成员变量会内存对齐么？为什么需要内存对齐？底层怎么实现的？&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;为什么对象模型需要这样存放？&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;智能指针问题&lt;/span&gt;&lt;/h4&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;智能指针有哪几种？&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;循环引用怎么解决，为什么用weak_ptr就能解决？&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;智能指针每一种的使用场景？&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;智能指针底层怎么支持的，怎么做到的？&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;STL问题&lt;/span&gt;&lt;/h4&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;STL有哪几部分组成？&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;为什么需要迭代器？&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;vector非尾结点删除，和插入会有什么问题？迭代器失效问题？&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;优先级队列怎么实现的？&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;自己实现序列式容器需要实现哪些成员函数？关联式容器呢？&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;配置器是干嘛用的？&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;仿函数使用在什么场景？&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;boost库使用过么？使用过哪些函数？&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;多态问题&lt;/span&gt;&lt;/h4&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;为什么需要多态？&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;多态有哪几种？静态多态是什么？动态多态呢？&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;多态如何实现的？&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;虚表指针是什么？虚表里面怎么存的？顺序是什么？为什么需要按照声明的顺序？&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;虚表第一个位置存放的type_info是干什么用的？RTTI机制是干什么的？为什么需要RTTI机制？&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;使用多态中遇到哪些问题？&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其他还有一些简单问题，比如问你sizeof是编译期还是运行期决议的？函数调用约定是什么？等等&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;数据结构与算法&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;直接问你数据结构的不多，一般会搭配着项目问。&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li readability=&quot;-2&quot;&gt;
&lt;section readability=&quot;2&quot;&gt;&lt;p&gt;问你设计时为什么选用这种数据结构？&lt;/p&gt;
&lt;/section&gt;&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;
&lt;section readability=&quot;2&quot;&gt;&lt;p&gt;常见数据结构以及底层实现？&lt;/p&gt;
&lt;/section&gt;&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;
&lt;section readability=&quot;2&quot;&gt;&lt;p&gt;树形结构和哈希结构的各自优缺点？&lt;/p&gt;
&lt;/section&gt;&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;
&lt;section readability=&quot;2&quot;&gt;&lt;p&gt;有些会问你图结构一些问题&lt;/p&gt;
&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;算法也不是直接让你写一个快排什么的，都是给你场景题，让你自己选择用什么算法。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不排除直接让你写快排，比如我这次在面试某家公司的时候，让我写一个单链表快排，不能交换数值，必须交换数据节点的地址。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;查找算法和排序算法考的多。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;查找算法的话就那几种。&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;遍历查找&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;树形查找&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;二分查找&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;插值查找&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;哈希查找&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;图的遍历查找&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;排序算法也就那么几种(从之前的博客中拷贝的图)&lt;/p&gt;
&lt;img src=&quot;https://img-blog.csdn.net/20180305143329864?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzg2NDY0NzA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;常见排序算法&quot;/&gt;常见排序算法
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;链表类的问题考的特别多，写算法题目也经常让写链表类的题目。我这次面试写算法基本都是在写链表类的题目。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;操作系统&amp;amp;计算机网络&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这块也会根据项目中的问，我的项目是搜索引擎，问操作系统的问题自然多。&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;mmap如何映射？mmap在那些场景中使用？有哪些优点？&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;物理地址和虚拟地址如何映射？swap区是干嘛的？4g的内存可以运行8g的程序么？&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;32位系统和64位系统区别是啥？为什么32位系统地址是4字节，64位是8字节？&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;信号槽机制是怎么实现的？&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;信号和信号量的区别？&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;锁的性能开销，锁的实现原理？&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;进程和线程管理？&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;多线程资源竞争问题？死锁经典问题(哲学家就餐问题)？&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;io这块问的很多，包括文件IO/网络IO/映射IO，都是要讲原理和细节？&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;三次握手和四次挥手必问的？&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;三次握手和四次挥手的状态转移？&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;socket编程每个函数对应握手那个过程？有家面试官竟然问函数参数代表的意思。&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;网络io的全过程，发生多少次数据拷贝？&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;场景题目&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这块题目是真的难以准备，都是随机应变的。大多数场景题目都是看思维，有些是看你思维完了，再让你对某个模块撸个代码。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说说我这次遇到的几个深刻得场景问题。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;题目：&lt;/p&gt;
&lt;ol data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;有一个单机高性能的服务，最大只能抗qps 3k，现在因为活动qps涨到了5k。&lt;/section&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;问题：&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;面试官：你怎么解决性能问题，从那些方面去考虑？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我：先看服务内部是否需要优化，看看具体哪些地方消耗rt，针对该模块优化，在看资源是否可以扩容等等&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;面试官：紧接着说，资源是固定的不能扩容？怎样保证服务正常？&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlly1gem2m067xmj305k05nq2s.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我：思考了一会，表示惊讶。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实这道题，我思路错了，一直在纠结服务性能优化上。面试官说的很清楚，要保证服务正常。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以一定是限流，优先保证服务稳定性。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说实话，工作中的服务不算严格意义上的限流，采用的是TCP连接队列限流的。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TCP队列大小固定，当队列满了，接下来所有新链接都会被reset，当队列有空余时才可以接受新连接。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;题目：&lt;/p&gt;
&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;有一个IO场景，100work线程处理完计算服务，把计算结果进行IO操作，IO等待时间长。&lt;/section&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;问题：&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;面试官：100个同时IO耗费时间很长，大多数线程都在等待，你怎么优化？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我：可以采用批量IO，用一个单独的线程专门负责IO工作&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;面试官：IO线程何时去进行批处理？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我：io线程使用阻塞等待，满一批就进行IO；或者work线程每次写数据时检测下队列满了就去唤醒IO线程&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;面试官：那IO线程完了怎么通知那一批work线程？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我：信号通知&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;面试官：信号通知不能携带数据结构，假设IO完了之后必须给每个对应的work线程返回一个数据结构，怎么办？&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlly1gem3cniiawg308c08cq38.gif&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我：用一个全局队列保存IO返回的数据结构，work线程去阻塞等待返回的数据结果。&lt;/p&gt;
&lt;blockquote data-tool=&quot;mdnice编辑器&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;入门之前我觉得写代码应该挺难的，属于技术活。现在我发现，面试是个技术活，比写代码难度大多了。不光要有实力，也必须要有运气。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;反正你如何准备，面试官都会问到你怀疑人生。大多数时候我们都是顺着面试官的反问去思考，结合自己的经历回答。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;三个小点提示下：&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;不一定顺着面试官的思路想，要更多的有自己的思路，适当的时候记得反问面试官？&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;不一定所有问题都答出来，但是一定你答的问题很精彩。&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;遇到不会的或者比较难的问题，先说自己的思路，再去询问下面试官的思路，探讨的方式面试。&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;差不多了，今天分享就到这里了。不是所有面试题，挑选了一些重要的问题说说。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;题外话&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天开始在陆陆续续拒绝一些公司了，对于那些很还不错的公司，对你满满诚意，拒绝起来还是有些伤心的。&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlly1gem3pb88g1j30b60vydo1.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同时我在想，不管怎么样最终都只能选择一家公司工作。但是在面试的时候又不得不多尝试。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;尝试的越多，意味着做出选择的越多。但是，在职业选择上，是真的&lt;strong&gt;不是很好选&lt;/strong&gt;。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每个人对于工作回报的预期不同，有的人把工作当做全部，是实现理想价值的地方，是实现梦想的地方；有的人把工作知识当做能力锻炼的地方，为了以后更大的梦想；也有人是为了赚钱。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总结一下就是三点&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;积累个人能力&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;积累经济财富&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;实现个人价值或者梦想&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在选择职业时大家可以根据这三方面仔细思考。要是三个条件都能满足，那就太好了。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;更多时候都是有取舍的，大家自行取舍。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下一篇文章给大家总结下本次招工做中的一些总结和需要注意哪些问题。当然我的所有总结都是基于自己的经历，如果有什么异议，欢迎大家探讨。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;俊男靓女们的&lt;strong&gt;点赞&lt;/strong&gt;就是龙叔创作的最大动力，奥利给！！！&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1gev7zm5qpnj30p00dw0tn.jpg&quot; alt=&quot;&quot;/&gt;</description>
<pubDate>Sun, 17 May 2020 23:27:00 +0000</pubDate>
<dc:creator>龙跃十二</dc:creator>
<og:description>毕业一年，面了多家一线大厂，看看社招面试都在问啥问题</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhonglongbo/p/12908484.html</dc:identifier>
</item>
</channel>
</rss>