<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>[ASP.NET Core 3框架揭秘] 配置[4]：将配置绑定为对象 - Artech</title>
<link>http://www.cnblogs.com/artech/p/inside-asp-net-core-05-04.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/artech/p/inside-asp-net-core-05-04.html</guid>
<description>&lt;p&gt;虽然应用程序可以直接利用通过IConfigurationBuilder对象创建的IConfiguration对象来提取配置数据，但是我们更倾向于将其转换成一个POCO对象，以面向对象的方式来使用配置，我们将这个转换过程称为配置绑定。配置绑定可以通过如下几个针对IConfiguration的扩展方法来实现，这些扩展方法都定义在NuGet包“Microsoft.Extensions.Configuration.Binder”中。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ConfigurationBinder
{    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Bind(&lt;span&gt;this&lt;/span&gt; IConfiguration configuration, &lt;span&gt;object&lt;/span&gt;&lt;span&gt; instance);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Bind(&lt;span&gt;this&lt;/span&gt; IConfiguration configuration, &lt;span&gt;object&lt;/span&gt; instance,  Action&amp;lt;BinderOptions&amp;gt;&lt;span&gt; configureOptions);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Bind(&lt;span&gt;this&lt;/span&gt; IConfiguration configuration, &lt;span&gt;string&lt;/span&gt; key,  &lt;span&gt;object&lt;/span&gt;&lt;span&gt; instance);
   
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; T Get&amp;lt;T&amp;gt;(&lt;span&gt;this&lt;/span&gt;&lt;span&gt; IConfiguration configuration);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; T Get&amp;lt;T&amp;gt;(&lt;span&gt;this&lt;/span&gt; IConfiguration configuration,  Action&amp;lt;BinderOptions&amp;gt;&lt;span&gt; configureOptions);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; Get(&lt;span&gt;this&lt;/span&gt;&lt;span&gt; IConfiguration configuration, Type type);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; Get(&lt;span&gt;this&lt;/span&gt; IConfiguration configuration, Type type,  Action&amp;lt;BinderOptions&amp;gt;&lt;span&gt; configureOptions);
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BinderOptions
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; BindNonPublicProperties { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Bind方法将指定的IConfiguration对象（对应于configuration参数）绑定一个预先创建的对象（对应于instance参数），如果参数绑定的只是当前IConfiguration对象的某个子配置节，我们需要通过参数sectionKey指定对应子配置节的相对路径。Get和Get&amp;lt;T&amp;gt;方法则直接将指定的IConfiguration对象转换成指定类型的POCO对象。&lt;/p&gt;
&lt;p&gt;旨在生成POCO对象的配置绑定实现在IConfiguration接口的扩展方法&lt;span&gt;Bind&lt;/span&gt;上。配置绑定的目标类型可以是一个简单的&lt;span&gt;基元类&lt;/span&gt;型，也可以是一个&lt;span&gt;自定义数据类型&lt;/span&gt;，还可以是一个&lt;span&gt;数组&lt;/span&gt;、&lt;span&gt;集合&lt;/span&gt;或者&lt;span&gt;字典&lt;/span&gt;类型。通过前面的介绍我们知道IConfigurationProvider对象将原始的配置数据读取出来后会将其转换成Key和Value均为字符串的数据字典，那么针对这些完全不同的目标类型，原始的配置数据如何通过数据字典的形式来体现呢？&lt;/p&gt;

&lt;p&gt;我们知道配置模型采用字符串键值对的形式来承载基础配置数据，我们将这组键值对称为配置字典，扁平的字典因为采用路径化的Key使配置项在逻辑上具有了层次结构。IConfigurationBuilder对象将配置的层次化结构体现在由它创建的IConfigurationRoot对象上，我们将IConfigurationRoot对象视为一棵配置树。所谓的配置绑定体现为如何将映射为配置树上某个节点的IConfiguration对象（可以是IConfigurationRoot对象或者IConfigurationSection对象）转换成一个对应的POCO对象。&lt;/p&gt;
&lt;p&gt;对于针对IConfiguration对象的配置绑定来说，最简单的莫过于针对&lt;span&gt;叶子节点&lt;/span&gt;的IConfigurationSection对象的绑定。表示配置树叶子节点的IConfigurationSection对象承载着原子配置项的值，而且这个值是一个字符串，那么针对它的配置绑定最终体现为如何将这个字符串转换成指定的目标类型，这样的操作体现在IConfiguration如下两个扩展方法GetValue上。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ConfigurationBinder
{    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; T GetValue&amp;lt;T&amp;gt;(IConfiguration configuration, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; sectionKey);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; T GetValue&amp;lt;T&amp;gt;(IConfiguration configuration, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; sectionKey,  T defaultValue);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; GetValue(IConfiguration configuration, Type type,   &lt;span&gt;string&lt;/span&gt;&lt;span&gt; sectionKey);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; GetValue(IConfiguration configuration, Type type,   &lt;span&gt;string&lt;/span&gt; sectionKey, &lt;span&gt;object&lt;/span&gt;&lt;span&gt; defaultValue);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对于给出的这四个重载，其中两个方法定义了一个表示默认值的defaultValue参数，如果对应配置节的值为Null或者空字符串，指定的默认值将作为方法的返回值。对于其他的方法重载，它们实际上将Null或者Default(T)作为隐式默认值。上述这些GetValue方法被执行的时候，它们会将配置节名称（对应sectionKey参数）作为参数调用指定IConfiguation对象的GetSection方法得到表示对应配置节的IConfigurationSection对象，它的Value属性被提取出来并按照如下的逻辑转换成目标类型：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果目标类型为object，直接返回&lt;span&gt;原始值&lt;/span&gt;（字符串或者Null）。&lt;/li&gt;
&lt;li&gt;如果目标类型不是Nullable&amp;lt;T&amp;gt;，那么针对目标类型的&lt;span&gt;TypeConverter&lt;/span&gt;将被用来做类型转换。&lt;/li&gt;
&lt;li&gt;如果目标类型为Nullable&amp;lt;T&amp;gt;，那么在原始值不为Null或者空字符串的情况下会将基础类型T作为新的目标类型进行转换，否则直接返回&lt;span&gt;Null&lt;/span&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;为了验证上述这些类型转化规则，我们编写了如下的测试程序。如下面的代码片段所示，我们利用注册的MemoryConfigurationSource添加了三个配置项，对应的值分别为Null、空字符串和“123”，然后调用GetValue方法分别对它们进行类型转换，转换的目标类型分别是Object、Int32和Nullable&amp;lt;Int32&amp;gt;，上述的转换规则体现在对应的调试断言中。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Main()
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; source = &lt;span&gt;new&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;
        {
            [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;foo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;,
            [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bar&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] = &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;,
            [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;baz&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        };

        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; root = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConfigurationBuilder()
            .AddInMemoryCollection(source)
            .Build();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;针对object&lt;/span&gt;
         Debug.Assert(root.GetValue&amp;lt;&lt;span&gt;object&lt;/span&gt;&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;foo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
        Debug.Assert(&lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;.Equals(root.GetValue&amp;lt;&lt;span&gt;object&lt;/span&gt;&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bar&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)));
        Debug.Assert(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;.Equals(root.GetValue&amp;lt;&lt;span&gt;object&lt;/span&gt;&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;baz&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)));

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;针对普通类型&lt;/span&gt;
         Debug.Assert(root.GetValue&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;foo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
        Debug.Assert(root.GetValue&lt;/span&gt;&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;baz&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) == &lt;span&gt;123&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;针对Nullable&amp;lt;T&amp;gt;&lt;/span&gt;
        Debug.Assert(root.GetValue&amp;lt;&lt;span&gt;int&lt;/span&gt;?&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;foo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
        Debug.Assert(root.GetValue&lt;/span&gt;&amp;lt;&lt;span&gt;int&lt;/span&gt;?&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bar&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;按照前面介绍的类型转换规则，如果目标类型支持源自字符串的类型转换，那么我们就能够将配置项的原始值绑定为该类型的对象，而让某个类型支持某种类型转换规则的途径就是为之注册相应的TypeConverter。如下面的代码片段所示，我们定义了一个表示二维坐标的Point对象，并为它注册了一个类型为PointTypeConverter的TypeConverter，PointTypeConverter通过实现的ConvertFrom方法将坐标的字符串表达式（比如“（123，456）”）转换成一个Point对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
[TypeConverter(&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(PointTypeConverter))]
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Point
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; X { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; Y { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; PointTypeConverter : TypeConverter
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; CanConvertFrom(ITypeDescriptorContext context, Type sourceType) =&amp;gt; sourceType == &lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; ConvertFrom(ITypeDescriptorContext context,  CultureInfo culture, &lt;span&gt;object&lt;/span&gt;&lt;span&gt; value)
    {
        &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;[] split = value.ToString().Split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; x = &lt;span&gt;double&lt;/span&gt;.Parse(split[&lt;span&gt;0&lt;/span&gt;].Trim().TrimStart(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;));
        &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; y = &lt;span&gt;double&lt;/span&gt;.Parse(split[&lt;span&gt;1&lt;/span&gt;].Trim().TrimEnd(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;));
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Point { X = x, Y =&lt;span&gt; y };
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于定义的Point类型支持源自字符串的类型转换，所以如果配置项的原始值（字符串）具有与之兼容的格式，我们将能按照如下的方式将它绑定为一个Point对象。（S608）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Main()
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; source = &lt;span&gt;new&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;
        {
            [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;point&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] = &lt;span&gt;&lt;strong&gt;&quot;(123,456)&quot;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;
        };

        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; root = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConfigurationBuilder()
            .AddInMemoryCollection(source)
            .Build();

        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; point = root.GetValue&amp;lt;Point&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;point&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        Debug.Assert(point.X &lt;/span&gt;== &lt;span&gt;123&lt;/span&gt;&lt;span&gt;);
        Debug.Assert(point.Y &lt;/span&gt;== &lt;span&gt;456&lt;/span&gt;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这里所谓的复合类型表示一个具有属性数据成员的自定义类型。如果通过一颗树来表示一个复合对象，那么叶子节点承载所有的数据，并且叶子节点的数据类型均为基元类型。如果通过数据字典来提供一个复杂对象所有的原始数据，那么这个字典中只需要包含叶子节点对应的值即可。&lt;a&gt;至于如何通过一个字典对象体现复合对象的结构，我们只需要将叶子节点所在的路径作为字典元素的&lt;/a&gt;Key就可以了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Profile: IEquatable&amp;lt;Profile&amp;gt;&lt;span&gt;
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Gender Gender { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Age { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ContactInfo ContactInfo { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Profile() {}
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Profile(Gender gender, &lt;span&gt;int&lt;/span&gt; age, &lt;span&gt;string&lt;/span&gt; emailAddress, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; phoneNo)
    {
        Gender &lt;/span&gt;=&lt;span&gt; gender;
        Age &lt;/span&gt;=&lt;span&gt; age;
        ContactInfo &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ContactInfo
        {
            EmailAddress &lt;/span&gt;=&lt;span&gt; emailAddress,
            PhoneNo &lt;/span&gt;=&lt;span&gt; phoneNo
        };
    }       
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; Equals(Profile other)
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; other == &lt;span&gt;null&lt;/span&gt;
            ? &lt;span&gt;false&lt;/span&gt;&lt;span&gt;
            : Gende &lt;/span&gt;== other.Gender &amp;amp;&amp;amp;  Age == other.Age &amp;amp;&amp;amp;&lt;span&gt; ContactInfo.Equals(other.ContactInfo);
    }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ContactInfo: IEquatable&amp;lt;ContactInfo&amp;gt;&lt;span&gt;
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; EmailAddress { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; PhoneNo { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }  
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; Equals(ContactInfo other)
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; other == &lt;span&gt;null&lt;/span&gt;
           ? &lt;span&gt;false&lt;/span&gt;&lt;span&gt;
           : EmailAddress &lt;/span&gt;== other.EmailAddress &amp;amp;&amp;amp; PhoneNo ==&lt;span&gt; other.PhoneNo;
    }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt;&lt;span&gt; Gender
{
    Male,
    Female
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上面的代码片段所示，我们定义了一个表示个人基本信息的Profile类，它的三个属性（Gender、Age和ContactInfo）分别表示性别、年龄和联系方式。由于配置绑定会调用默认无参构造函数来创建绑定的目标对象，所以我们需要为Profile类型定义一个默认构造函数。表示联系信息的ContactInfo类型具有两个属性（EmailAddress和PhoneNo），它们分别表示电子邮箱地址和电话号码。一个完整的Profile对象可以通过如下图所示的树来体现。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/19327/201912/19327-20191212082918391-987649610.png&quot;&gt;&lt;img width=&quot;221&quot; height=&quot;137&quot; title=&quot;6-13&quot; alt=&quot;6-13&quot; src=&quot;https://img2018.cnblogs.com/blog/19327/201912/19327-20191212082918745-833274714.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果需要通过配置的形式来表示一个完整的Profile对象，我们只需要将四个叶子节点（性别、年龄、电子邮箱地址和电话号码）对应的数据由配置来提供即可。对于承载配置数据的数据字典，我们需要按照如下表所示的方式将这四个叶子节点的路径作为字典元素的Key。&lt;/p&gt;
&lt;table width=&quot;456&quot; border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;colgroup&gt;&lt;col width=&quot;268&quot;/&gt;&lt;/colgroup&gt;&lt;colgroup&gt;&lt;col width=&quot;188&quot;/&gt;&lt;/colgroup&gt;&lt;tbody&gt;&lt;tr height=&quot;21&quot;&gt;&lt;td width=&quot;268&quot; height=&quot;21&quot; class=&quot;xl65&quot;&gt;
&lt;p&gt;&lt;span&gt;Key&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;188&quot; class=&quot;xl65&quot;&gt;&lt;span&gt;Value&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr height=&quot;21&quot;&gt;&lt;td height=&quot;21&quot; class=&quot;xl65&quot;&gt;&lt;span&gt;Gender&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl65&quot;&gt;&lt;span&gt;Male&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr height=&quot;21&quot;&gt;&lt;td height=&quot;21&quot; class=&quot;xl65&quot;&gt;&lt;span&gt;Age&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl65&quot;&gt;&lt;span&gt;18&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr height=&quot;21&quot;&gt;&lt;td height=&quot;21&quot; class=&quot;xl65&quot;&gt;&lt;span&gt;ContactInfo:Email&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl65&quot;&gt;&lt;span&gt;foobar@outlook.com&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr height=&quot;21&quot;&gt;&lt;td height=&quot;21&quot; class=&quot;xl65&quot;&gt;&lt;span&gt;ContactInfo:PhoneNo&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl65&quot;&gt;&lt;span&gt;123456789&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;我们通过如下的程序来验证针对复合数据类型的配置绑定。我们创建了一个ConfigurationBuilder对象并为它添加了一个MemoryConfigurationSource对象，它按照如上表所示的结构提供了原始的配置数据。在调用Build方法构建出IConfiguration对象之后，我们直接调用扩展方法Get&amp;lt;T&amp;gt;将它转换成一个Profile对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Main()
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; source = &lt;span&gt;new&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;
        {
            [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;gender&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]  = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Male&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]  = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;contactInfo:emailAddress&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]  = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;foobar@outlook.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;contactInfo:phoneNo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]  = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123456789&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        };

        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; configuration = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConfigurationBuilder()
            .AddInMemoryCollection(source)
            .Build();

        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; profile = configuration.Get&amp;lt;Profile&amp;gt;&lt;span&gt;();
        Debug.Assert(profile.Equals( &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Profile(Gender.Male, &lt;span&gt;18&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;foobar@outlook.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123456789&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)));
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如果配置绑定的目标类型是一个集合（包括数组），那么当前IConfiguration对象的每一个子配置节将绑定为集合的元素。假设我们需要将一个IConfiguration对象绑定为一个元素类型为Profile的集合，它表示的配置树应该具有如下图所示的结构。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/19327/201912/19327-20191212082918953-2021973507.png&quot;&gt;&lt;img width=&quot;240&quot; height=&quot;134&quot; title=&quot;6-14&quot; alt=&quot;6-14&quot; src=&quot;https://img2018.cnblogs.com/blog/19327/201912/19327-20191212082919367-1887814084.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;既然我们能够正确将集合对象通过一个合法的配置树体现出来，那么我们就可以将它转换成配置字典。对于通过下表所示的这个包含三个元素的Profile集合，我们可以采用如下表所示的结构来定义对应的配置字典。&lt;/p&gt;
&lt;table width=&quot;456&quot; border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;colgroup&gt;&lt;col width=&quot;268&quot;/&gt;&lt;/colgroup&gt;&lt;colgroup&gt;&lt;col width=&quot;188&quot;/&gt;&lt;/colgroup&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr height=&quot;21&quot;&gt;&lt;td width=&quot;268&quot; height=&quot;21&quot; class=&quot;xl65&quot;&gt;
&lt;p&gt;&lt;span&gt;Key&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;188&quot; class=&quot;xl65&quot;&gt;&lt;span&gt;Value&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr height=&quot;21&quot;&gt;&lt;td height=&quot;21&quot; class=&quot;xl66&quot;&gt;&lt;span&gt;foo:Gender&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl66&quot;&gt;&lt;span&gt;Male&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr height=&quot;21&quot;&gt;&lt;td height=&quot;21&quot; class=&quot;xl66&quot;&gt;&lt;span&gt;foo:Age&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl66&quot;&gt;&lt;span&gt;18&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr height=&quot;21&quot; readability=&quot;2&quot;&gt;&lt;td height=&quot;21&quot; class=&quot;xl66&quot;&gt;&lt;span&gt;foo:ContactInfo:EmailAddress&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl66&quot;&gt;&lt;span&gt;foo@outlook.com&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr height=&quot;21&quot;&gt;&lt;td height=&quot;21&quot; class=&quot;xl66&quot;&gt;&lt;span&gt;foo:ContactInfo:PhoneNo&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl66&quot;&gt;&lt;span&gt;123&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr height=&quot;21&quot;&gt;&lt;td height=&quot;21&quot; class=&quot;xl66&quot;&gt;&lt;span&gt;bar:Gender&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl66&quot;&gt;&lt;span&gt;Male&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr height=&quot;21&quot;&gt;&lt;td height=&quot;21&quot; class=&quot;xl66&quot;&gt;&lt;span&gt;bar:Age&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl66&quot;&gt;&lt;span&gt;25&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr height=&quot;21&quot; readability=&quot;2&quot;&gt;&lt;td height=&quot;21&quot; class=&quot;xl66&quot;&gt;&lt;span&gt;bar:ContactInfo:EmailAddress&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl66&quot;&gt;&lt;span&gt;bar@outlook.com&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr height=&quot;21&quot;&gt;&lt;td height=&quot;21&quot; class=&quot;xl66&quot;&gt;&lt;span&gt;bar:ContactInfo:PhoneNo&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl66&quot;&gt;&lt;span&gt;456&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr height=&quot;21&quot;&gt;&lt;td height=&quot;21&quot; class=&quot;xl66&quot;&gt;&lt;span&gt;baz:Gender&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl66&quot;&gt;&lt;span&gt;Female&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr height=&quot;21&quot;&gt;&lt;td height=&quot;21&quot; class=&quot;xl66&quot;&gt;&lt;span&gt;baz:Age&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl66&quot;&gt;&lt;span&gt;40&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr height=&quot;21&quot; readability=&quot;2&quot;&gt;&lt;td height=&quot;21&quot; class=&quot;xl66&quot;&gt;&lt;span&gt;baz:ContactInfo:EmailAddress&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl66&quot;&gt;&lt;span&gt;baz@outlook.com&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr height=&quot;21&quot;&gt;&lt;td height=&quot;21&quot; class=&quot;xl66&quot;&gt;&lt;span&gt;baz:ContactInfo:PhoneNo&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;xl66&quot;&gt;&lt;span&gt;789&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;我们依然通过一个简单的实例来演示针对集合的配置绑定。如下面的代码片段所示，我们创建了一个ConfigurationBuilder对象并为它注册了一个MemoryConfigurationSource对象，它按照如s上表所示的结构提供了原始的配置数据。在得到这个ConfigurationBuilder对象创建的IConfiguration对象之后，我们两次调用其Get&amp;lt;T&amp;gt;方法将它分别绑定为一个IEnumerable&amp;lt;Profile&amp;gt;对象和一个Profile[] 数组。由于IConfigurationProvider通过GetChildKeys方法提供的Key是经过排序的，所以在绑定生成的集合或者数组中的元素的顺序与配置源是不相同的，如下的调试断言也体现了这一点。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Main()
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; source = &lt;span&gt;new&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;
        {
            [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;foo:gender&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]  = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Male&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;foo:age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]      = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;foo:contactInfo:emailAddress&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]  = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;foo@outlook.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;foo:contactInfo:phoneNo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,

            [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bar:gender&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]  = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Male&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bar:age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bar:contactInfo:emailAddress&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]  = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bar@outlook.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bar:contactInfo:phoneNo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]  = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;456&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,

            [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;baz:gender&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]  = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Female&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;baz:age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;baz:contactInfo:emailAddress&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]  = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;baz@outlook.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;baz:contactInfo:phoneNo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]  = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;789&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        };

        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; configuration = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConfigurationBuilder()
            .AddInMemoryCollection(source)
            .Build();

        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; profiles = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Profile[]
        {
            &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Profile(Gender.Male,&lt;span&gt;18&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;foo@outlook.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),
            &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Profile(Gender.Male,&lt;span&gt;25&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bar@outlook.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;456&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),
            &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Profile(Gender.Female,&lt;span&gt;36&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;baz@outlook.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;789&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),
        };

        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; collection = configuration.Get&amp;lt;IEnumerable&amp;lt;Profile&amp;gt;&amp;gt;&lt;span&gt;();
        Debug.Assert(collection.Any(it &lt;/span&gt;=&amp;gt; it.Equals(profiles[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;])));
        Debug.Assert(collection.Any(it &lt;/span&gt;=&amp;gt; it.Equals(profiles[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;])));
        Debug.Assert(collection.Any(it &lt;/span&gt;=&amp;gt; it.Equals(profiles[&lt;span&gt;2&lt;/span&gt;&lt;span&gt;])));

        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; array = configuration.Get&amp;lt;Profile[]&amp;gt;&lt;span&gt;();
        Debug.Assert(array[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;].Equals(profiles[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]));
        Debug.Assert(array[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;].Equals(profiles[&lt;span&gt;2&lt;/span&gt;&lt;span&gt;]));
        Debug.Assert(array[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;].Equals(profiles[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]));
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在针对集合类型的配置绑定过程中，如果某个配置节绑定失败，该配置节将被&lt;span&gt;忽略并选择下一个配置节继续进行绑定&lt;/span&gt;。但是如果目标类型为数组，最终绑定生成的&lt;span&gt;数组长度与子配置节的个数总是一致的，绑定失败的元素将被设置为Null&lt;/span&gt;。比如我们将上面的程序作了如下的改写，保存原始配置的字典对象包含两个元素，第一个元素的性别从“Male”改为“男”，毫无疑问这个值是不可能转换成Gender枚举对象的，所以针对这个Profile的配置绑定会失败。如果将目标类型设置为IEnumerable&amp;lt;Profile&amp;gt;，那么最终生成的集合只会有&lt;span&gt;两个元素&lt;/span&gt;，倘若目标类型切换成Profile数组，&lt;span&gt;数组的长度依然为3，但是第一个元素是Null&lt;/span&gt;。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Main()
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; source = &lt;span&gt;new&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;
        {
            [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;foo:gender&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;男&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;foo:age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]      = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;foo:contactInfo:emailAddress&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;foo@outlook.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;foo:contactInfo:phoneNo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,

            [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bar:gender&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]  = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Male&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bar:age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]      = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bar:contactInfo:emailAddress&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]  = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bar@outlook.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bar:contactInfo:phoneNo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]  = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;456&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,

            [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;baz:gender&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]  = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Female&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;baz:age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]      = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;baz:contactInfo:emailAddress&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]  = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;baz@outlook.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;baz:contactInfo:phoneNo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]  = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;789&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        };

        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; configuration = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConfigurationBuilder()
            .AddInMemoryCollection(source)
            .Build();

        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; collection = configuration.Get&amp;lt;IEnumerable&amp;lt;Profile&amp;gt;&amp;gt;&lt;span&gt;();
        Debug.Assert(collection.Count() &lt;/span&gt;== &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; array = configuration.Get&amp;lt;Profile[]&amp;gt;&lt;span&gt;();
        Debug.Assert(array.Length &lt;/span&gt;== &lt;span&gt;3&lt;/span&gt;&lt;span&gt;);
        Debug.Assert(array[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;] == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;); 
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;由于配置节按照Key进行排序，绑定失败的配置节为最后一个&lt;/span&gt;
&lt;span&gt;    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;能够通过配置绑定生成的字典是一个实现了IDictionary&amp;lt;string,T&amp;gt;的类型，也就是说配置模型没有对字典的Value类型作任何要求，但是字典对象的Key必须是一个字符串（或者枚举）。如果采用配置树的形式来表示这么一个字典对象，我们会发现它与针对集合的配置树在结构上几乎是一样的。唯一的区别是集合元素的索引直接变成了字典元素的Key。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/19327/201912/19327-20191212082919599-1368536453.png&quot;&gt;&lt;img width=&quot;240&quot; height=&quot;132&quot; title=&quot;6-14&quot; alt=&quot;6-14&quot; src=&quot;https://img2018.cnblogs.com/blog/19327/201912/19327-20191212082919807-1204579991.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;也就是说上图所示的这棵配置树同样可以表示成一个具有三个元素的Dictionary&amp;lt;string, Profile&amp;gt;对象 ，它们对应的Key分别是“Foo”、“Bar”和“Baz”，所以我们可以按照如下的方式将承载相同数据的IConfiguration对象绑定为一个IDictionary&amp;lt;string,T&amp;gt;对象。（S612）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Main()
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; source = &lt;span&gt;new&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;
        {
            [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;foo:gender&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]  = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Male&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;foo:age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]      = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;foo:contactInfo:emailAddress&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]  = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;foo@outlook.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;foo:contactInfo:phoneNo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,

            [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bar:gender&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]  = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Male&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bar:age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]      = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bar:contactInfo:emailAddress&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]  = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bar@outlook.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bar:contactInfo:phoneNo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]  = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;456&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,

            [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;baz:gender&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]  = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Female&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;baz:age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]        = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;baz:contactInfo:emailAddress&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]  = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;baz@outlook.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;baz:contactInfo:phoneNo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]  = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;789&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        };

        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; configuration = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConfigurationBuilder()
            .AddInMemoryCollection(source)
            .Build();

        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; profiles = configuration.Get&amp;lt;IDictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, Profile&amp;gt;&amp;gt;&lt;span&gt;();
        Debug.Assert(profiles[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;foo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;].Equals(  &lt;span&gt;new&lt;/span&gt; Profile(Gender.Male, &lt;span&gt;18&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;foo@outlook.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)));
        Debug.Assert(profiles[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bar&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;].Equals(  &lt;span&gt;new&lt;/span&gt; Profile(Gender.Male, &lt;span&gt;25&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bar@outlook.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;456&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)));
        Debug.Assert(profiles[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;baz&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;].Equals(  &lt;span&gt;new&lt;/span&gt; Profile(Gender.Female, &lt;span&gt;36&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;baz@outlook.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;789&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)));
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-05-01.html&quot;&gt;[ASP.NET Core 3框架揭秘] 配置[1]：读取配置数据[上篇]&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-05-02.html&quot;&gt;[ASP.NET Core 3框架揭秘] 配置[2]：读取配置数据[下篇]&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-05-03.html&quot;&gt;[ASP.NET Core 3框架揭秘] 配置[3]：配置模型总体设计&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-05-04.html&quot;&gt;[ASP.NET Core 3框架揭秘] 配置[4]：将配置绑定为对象&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-05-05.html&quot;&gt;[ASP.NET Core 3框架揭秘] 配置[5]：配置数据与数据源的实时同步&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-05-06.html&quot;&gt;[ASP.NET Core 3框架揭秘] 配置[6]：多样化的配置源[上篇]&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-05-07.html&quot;&gt;[ASP.NET Core 3框架揭秘] 配置[7]：多样化的配置源[中篇]&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-05-08.html&quot;&gt;[ASP.NET Core 3框架揭秘] 配置[8]：多样化的配置源[下篇]&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-05-09.html&quot;&gt;[ASP.NET Core 3框架揭秘] 配置[9]：自定义配置源&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 12 Dec 2019 00:29:00 +0000</pubDate>
<dc:creator>Artech</dc:creator>
<og:description>虽然应用程序可以直接利用通过IConfigurationBuilder对象创建的IConfiguration对象来提取配置数据，但是我们更倾向于将其转换成一个POCO对象，以面向对象的方式来使用配置，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/artech/p/inside-asp-net-core-05-04.html</dc:identifier>
</item>
<item>
<title>【测试理论】如何做好探索性测试（二）—增加维度 - 布道师玄柯</title>
<link>http://www.cnblogs.com/zhouliweiblog/p/12026853.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhouliweiblog/p/12026853.html</guid>
<description>&lt;p&gt;在&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIzODU5ODUxMA==&amp;amp;mid=2247483765&amp;amp;idx=1&amp;amp;sn=f71b52e55e5b964c4d1adf0de5ade8fe&amp;amp;chksm=e937a174de4028622be1c507939d04732e0aeab145d43ca0fe531e65a90eba269660e9f889bc&amp;amp;token=1051648910&amp;amp;lang=zh_CN#rd&quot;&gt;【测试理论】如何做好探索性测试（一）—基础篇&lt;/a&gt; 中，我们介绍了探索性测试的基础内容，我们简单回忆下主要包括：常规测试方案与探索性测试是相辅相成的、在工作中，寻找探索性测试点的时机(需求评审、用例评审)、寻找那些产品中的变量，比如：可计数的东西、地理位置、文件和存储、时间点等等、收集用户的反馈(操作的漫无目的及随机性)等。&lt;/p&gt;
&lt;p&gt;今天我们接着来介绍探索性测试从不同的维度深入进去来挖掘测试点，其中还是以理论偏多，希望大家能耐心的看完。同时我也建议大家去读一读探索性测试的书，比如：《探索吧，深入理解探索式软件测试》。因为我的文章也是参考的这本书，通过读这本书，我深刻的感知到探索性测试确实可以作为我们常规测试的一个补充，因为它真的可以给我们提供不一样的思路，从而帮助我们挖掘更深层次的问题。&lt;/p&gt;
&lt;h2 id=&quot;改变顺序和交互&quot;&gt;改变顺序和交互&lt;/h2&gt;
&lt;p&gt;试想过往我们经历过的场景：你负责测试某一个功能模块，其中有一些表单页面，当你对该功能模块非常熟悉时，你应该会使用相同的数据，快速的输入，比如：姓名你会固定使用周杰伦，地址你会使用xxx街22号等、又或者你登录app后，总是切换到首页的某个功能列表中等等。造成这种情况的主要原因有两个：思维定势和习惯，所以要有效的进行探索性测试，就必须打破这种常规习惯。&lt;/p&gt;
&lt;h3 id=&quot;名词和动词&quot;&gt;名词和动词&lt;/h3&gt;
&lt;p&gt;大家都清楚，一个正常的句子通常包含名词、动词和形容词，对于被测的系统来讲，我们可以尽情的找出其中的名词和动词，以测试某个邮件客户端为例(书中的例子)，名词或者事物可能包含：邮件、附件、联系人、账户和文件夹；而对应的动词有：创建、发送、编辑、转发、复制、删除、移动等。可以在表格中，将他们都列出来，这就可以得出如下图所示的表格(可以在Excel中列出)：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/12/06/9d3xtsWGuPb7U5Y.png&quot; alt=&quot;WX20191206-203230@2x.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当然上面我只是列出了一部分的组合场景，你还可以根据情况组合出更多可探索的测试点。不过需要注意的是，有些组合结果看上去像是不合乎逻辑，但我们不能就这么放过这样的组合，而应该多找找看看，有没有办法能解释这些没有意义的组合，从而可以找到可探索的点。比如上面表格中的&quot;导出签名&quot;，看上去意义不太明确，但可以考虑，是否可以理解在邮件客户端中直接将签名导出保存起来，或者将签名复制粘贴到其他地方存起来，总之不能放过任何的蛛丝马迹。&lt;/p&gt;
&lt;h3 id=&quot;随机导航&quot;&gt;随机导航&lt;/h3&gt;
&lt;p&gt;回想下，我们测试某个app时，总是点击桌面的icon图标来打开被测应用，那你有没有尝试从历史应用中打开被测应用？或者通过adb 命令打开被测应用？所谓随机导航，其实需要你收集被测系统中，&lt;strong&gt;完成相同操作所需要的方法&lt;/strong&gt;，然后可以将他们记录到表格中，比如：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/12/09/4Xiyp5fdOFbIvs1.png&quot; alt=&quot;WX20191209-135727@2x.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;将所有的情况列出来之后，就可以开始探索不同操作方式。当然还可以结合着用例场景，对不同的操作方式进行组合，也能发现一些让你惊喜的测试点。&lt;/p&gt;
&lt;h3 id=&quot;角色人物&quot;&gt;角色人物&lt;/h3&gt;
&lt;p&gt;所谓角色人物，是指将测试系统的用户群体进行细分，进而能抽象出不同的角色人物。针对不同的角色人物，你可以在测试时，设想他们的操作习惯、心理变化等，来探索他们在操作软件时会做哪些操作。&lt;/p&gt;
&lt;p&gt;拿手机淘宝app来举个例子，手淘的用户群体很广，所以也给了我们充分的设计角色人物的空间，比如下面有三种角色：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;小王，今年20岁，是个程序员，重度互联网用户，能熟练的使用app及适应其交互体验，并且碰到各类问题，都愿意自己尝试搜索解决。&lt;/li&gt;
&lt;li&gt;老张，今年40岁，之前在智能手机上就用过微信app聊天（仅限于聊天），缺乏耐心，是个急脾气，使用软件时会缺乏耐心。&lt;/li&gt;
&lt;li&gt;老王，今年50岁，刚从老年机转到智能手机上，喜欢学习，所以手机app上面的各个功能都会点点看。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;设想一个场景，比如：手淘使用某个功能时很卡，响应很慢，那么上面三个角色的反应也是不同的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;小王：因为已经对互联网产品比较熟悉，所以他能理解慢的可能原因是啥，可能是网络、或者是app本身的原因，所以他会尝试等待一段时间，然后还不行，就会尝试重启app、清理手机内存等。&lt;/li&gt;
&lt;li&gt;老张：虽然使用过微信聊天，但是不太能理解为啥app会响应慢，又因为缺乏耐心，所以会疯狂的点击屏幕。&lt;/li&gt;
&lt;li&gt;老王：他同样不太理解为啥app会响应慢，但是他有耐心，喜欢学习。会做出不同的尝试，比如：按home键前后台切换等。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果你们的产品有很详细的用户数据（年龄、职业、性别等），那就能更好的来设计角色人物。在做探索性测试时，你可以临时的让自己去扮演对应的角色，发挥自己的想象力，要注意这个角色试图做的任何事情，然后观察软件是如何响应的。&lt;/p&gt;
&lt;h2 id=&quot;探索实体及实体之间的关系&quot;&gt;探索实体及实体之间的关系&lt;/h2&gt;
&lt;p&gt;系统和软件，其实就是实体和实体构成的，所以当做探索性测试时，如果能基于它们之间的关系，挖掘一些测试点，也能帮助你发现很多问题。&lt;/p&gt;
&lt;h3 id=&quot;认识被测系统中的实体属性和依赖&quot;&gt;认识被测系统中的实体、属性和依赖&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;实体&lt;/strong&gt;：实体也可以叫做事物，是一个系统或者软件的基本组成部分，比如：一个账户、一个头像、一条数据等都可以被称之为实体。注意留意系统中的隐藏实体，比如：web页面登录后创建的会话。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;属性&lt;/strong&gt;：实体有对应的属性，比如：电子邮件有收件人、主题和正文、商品有价格和数量等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;依赖&lt;/strong&gt;：实体和实体之间，必然是有联系的，并且可能存在依赖关系。假如你看见这样的句子格式：&quot;xxx有个xxx&quot;时，一般就能找到依赖关系，比如：一张订单有多个商品item、一款商品有多家供应商等。&lt;/p&gt;
&lt;p&gt;有了上面的基础概念，我们就可以来绘制实体之间的关系图(ERD）。假如现在有一个库存管理系统，系统的每一条库存数据都对应了某一家供应商，他们之间的关系图如下（其实和数据库的表之间关系图类似）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/12/10/rHtvf3qkaiIen1U.png&quot; alt=&quot;WX20191210-135911@2x.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;crud方法&quot;&gt;CRUD方法&lt;/h3&gt;
&lt;p&gt;对数据库熟悉的小伙伴应该对CRUD不陌生，它指的是对软件中数据的增、删、改、查。在探索性测试中，也可以找到实体在CRUD时，引起的一些变化，主要有以下几个方面：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据变量的CRUD&lt;/strong&gt;：在进行CRUD时，改变实体的属性值。比如：在新创建一条库存数据时，将所有的字段全都填写上，然后再尝试去掉某几个值，并更新库存数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;其他CRUD方法&lt;/strong&gt;：这个和前面提到的随机导航类似，需要寻找不同的方式对实体进行CRUD操作，比如：新创建一个文件，可以直接通过新建菜单创建，或者可以针对一个现有文件，选择“另存为”新的文件。再比如，在某些场景下系统会触发自动创建一条提醒消息，和用户手动触发创建的提醒消息，它们经历的工作流可能是有差别的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;零、单、多依赖的CRUD&lt;/strong&gt;：主要考虑实体间的依赖关系，比如：你创建一个独立的实体，不给它添加依赖项，看系统数据是否运行正常；另外假如删除一个有很多依赖的实体，那么观察它的依赖是否也会被删除。&lt;/p&gt;
&lt;p&gt;在进行上面CRUD探索时，要时刻留意服务端的日志，看是否有异常出现，以发现潜藏的问题。&lt;/p&gt;
&lt;h2 id=&quot;发现状态和转换&quot;&gt;发现状态和转换&lt;/h2&gt;
&lt;p&gt;我们经常会碰到某些bug极难重现的情况，可能是一个非常偶然的灾难性错误，或者是无意间用到了受损的数据。这种情况，往往是凑巧碰上了一个短暂的脆弱期，因为其短暂且特殊，所以你可能花费很多时间去复现他们也会无功而返。&lt;/p&gt;
&lt;p&gt;问题的关键是，我们怎样去发现和利用出现问题时的脆弱期。幸运的是，可以采用系统化的分析方式，借助于状态模型，用于启发我们如何去探索这样的脆弱期。&lt;/p&gt;
&lt;h3 id=&quot;事件触发状态的转换&quot;&gt;事件触发状态的转换&lt;/h3&gt;
&lt;p&gt;事件可以触发系统中实体状态的转换，比如：你点击了软件界面上的某个删除按钮，那么就会触发系统中删除一条数据，在寻找事件过程中，注意以下事项：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;外部产生事件&lt;/strong&gt;：来自于软件之外的任何事件，例如：对于监控文件系统目录结构的软件来说，改变文件系统的目录结构就是一个外部产生事件的例子。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;系统产生事件&lt;/strong&gt;：这个比较好理解，是系统为了完成软件功能而产生的相应事件，比如：导入导出数据、登录验证用户等等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;时间事件&lt;/strong&gt;：和时间有关系的事件，比如超时、特定时间点的事件等。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在每个事件发生时，都会有对应的状态发生变化。&lt;/p&gt;
&lt;h3 id=&quot;状态模型图&quot;&gt;状态模型图&lt;/h3&gt;
&lt;p&gt;以某个系统的登录模块为例，来展示一个状态模型图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/12/11/2vQx1JgLpE9NkmM.png&quot; alt=&quot;WX20191211-134059@2x.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;按照这种方式，系统或软件可以被划分成很多个模块，每个模块都可以来构建状态模型图。为了更有针对性，不至于分散，可以从如下几个方面来考虑构建状态模型图。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;专注&lt;/strong&gt;：你可以控制状态模型的范围，只针对一个目标，比如说一个功能或者工作流，比如上图中登录的流程，就涉及到已登出、登入、登陆中三种状态，总之一定要让自己选择的模型可控，而不能过于分散。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;确定一个角度&lt;/strong&gt;：针对模块中的某一个角度来涉及状态模型图，比如：用微信聊天，那么别人找你聊天是一个角度，你主动找别人聊天又是一个角度。确定特定的角度，也能帮助缩小状态模型的范围。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;确定系统抽象层级&lt;/strong&gt;：简单说就是对于小的需求，可以尽可能的细致描述其中的状态转变；对于相对复杂的系统，可以进行高度的抽象，将中间的一些小细节抽象为一个大的状态就可以。比如：上面的登录模块例子中，假如还依赖了很多其他的服务或者应用，则可以将这些依赖服务统一起来，做成一个登录（中）的状态。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;探索状态模型&quot;&gt;探索状态模型&lt;/h3&gt;
&lt;p&gt;有了上面绘制的状态模型图，就可以将它作为地图，找到两个状态之间的所有路径，也能很直观的看到引起状态发生变化的事件，我们接下来我们来看看如何去寻找状态之间的所有途径。&lt;/p&gt;
&lt;p&gt;以开和关两种常见的状态为例，那么可以考虑：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;有哪些方式可以把关闭变为开启？
&lt;ul&gt;&lt;li&gt;用户手动启动。&lt;/li&gt;
&lt;li&gt;操作系统启动时自动启动。&lt;/li&gt;
&lt;li&gt;很多软件都有守护进程，由它们启动。&lt;/li&gt;
&lt;li&gt;其他软件调起了被测软件。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;有哪些方式可以把开启变为关闭？
&lt;ul&gt;&lt;li&gt;用户手动关闭。&lt;/li&gt;
&lt;li&gt;强制杀掉进程。&lt;/li&gt;
&lt;li&gt;关闭操作系统的屏幕。&lt;/li&gt;
&lt;li&gt;操作系统直接关机。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所以有了状态图，以及我们知道如何探索状态之后，就可以结合难以复现的bug，实际操作下，绘制其关联的状态模型图，然后探索从正常状态到异常状态之间的各种可能性。&lt;/p&gt;
&lt;h3 id=&quot;状态表格&quot;&gt;状态表格&lt;/h3&gt;
&lt;p&gt;此外，还可以将状态模型图转换为状态表格，这样也许你有更多机会发现状态的转换（状态模型图可以帮我们从整体上来理清楚待测系统的各种状态）。假设我们现在有一个闹铃，其功能界面如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/12/11/Pjpx7MfvmnqsEOr.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如图所示，其主要功能包含：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;打开、关闭闹铃&lt;/li&gt;
&lt;li&gt;设置闹铃&lt;/li&gt;
&lt;li&gt;重响功能，按下重响按钮，闹钟会安静9分钟后再度响起。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其状态模型图如下：&lt;br/&gt;&lt;img src=&quot;https://i.loli.net/2019/12/11/o6Rm7gIJ9z4ZfG5.png&quot; alt=&quot;微信截图_20191211234217.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;状态模型图转成表格状态图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/12/11/cyLAouFWHtREm5J.png&quot; alt=&quot;微信截图_20191211234506.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那结合上面的状态表格，我们就可以进行探索，比如：设置+时间到点—&amp;gt;表示正好设置了一个当前时间，会怎么样？凡是我们想探索的不确定的全部都标记为？？？，而对于不需要探索或不符合逻辑的状态组合，则标记为N/A。&lt;/p&gt;
&lt;h2 id=&quot;探索生态系统&quot;&gt;探索生态系统&lt;/h2&gt;
&lt;p&gt;我们要测试的软件，肯定不是单独存在的，首先它肯定运行在操作系统上，然后它需要用到内存、文件系统、数据库和网络连接等系统资源，此外某些软件还可能跟其他软件或者外部服务有关联。我们之前的讨论都是基于内部系统，但从整个系统层面来考量软件同样重要。&lt;/p&gt;
&lt;h3 id=&quot;绘制生态系统图&quot;&gt;绘制生态系统图&lt;/h3&gt;
&lt;p&gt;软件的生态系统图包括软件所处的环境、所有入口和所有外部依赖，我们可以把它作为一张探索地图，围绕连接和依赖进行针对性的系统探索，以便发现在系统控制范围外跟系统各个部分相关联的风险。我们以一个信用卡支付的web系统作为例子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/12/11/E6UQGFWNzIfbjA4.png&quot; alt=&quot;微信截图_20191211071938.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面这张图的各种元素含义如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;中间的大圆圈表示软件内外部依赖的边界。&lt;/li&gt;
&lt;li&gt;圆圈的外部右侧表示软件的用户分类，这里web系统包含管理员和普通用户。&lt;/li&gt;
&lt;li&gt;圆圈的外部左侧表示软件依赖的组件（或系统），这里只列出了“支付网关”，但我们测试的软件应该比这个复杂的多，应该有非常多的依赖，都可以列到系统图中。&lt;/li&gt;
&lt;li&gt;圆圈的内部是软件的内部实现，主要考虑软件的数据存储、软件的架构设计（根据情况，如果没有探索的价值可不写）及软件的部署方式。&lt;/li&gt;
&lt;li&gt;此外还可能包括，系统给外部提供的接口或组件等。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在画系统图时，如果不是特别清楚，可以咨询开发，或者问他们要系统设计图。通过这张系统图，我们就能很直观的，对软件的整个运行环境了解，从而找到可探索的测试点。&lt;/p&gt;
&lt;h3 id=&quot;探索信任边界&quot;&gt;探索信任边界&lt;/h3&gt;
&lt;p&gt;所谓信任边界，简单的讲就是：我们信任我们所依赖的外部系统（数据、接口、网络），以上面的生态图为例，我们相信圆圈外部的“支付网关”能提供给我们正确的数据。&lt;/p&gt;
&lt;p&gt;不过我们在做探索性测试时，要尝试打破这种“信任边界”，针对不同情况的外部依赖，我们可探索的情况如下：&lt;/p&gt;
&lt;h4 id=&quot;网络数据&quot;&gt;网络数据&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;断开网络&lt;/li&gt;
&lt;li&gt;将系统的一部分放在防火墙或者网段的另一边。&lt;/li&gt;
&lt;li&gt;降低网速（弱网测试）。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;文件&quot;&gt;文件&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;删除文件&lt;/li&gt;
&lt;li&gt;损坏文件的内容&lt;/li&gt;
&lt;li&gt;把文件弄的非常大&lt;/li&gt;
&lt;li&gt;设置文件为只读的&lt;/li&gt;
&lt;li&gt;移除文件的所有权限&lt;/li&gt;
&lt;li&gt;把硬盘装满，使得文件无法再写入。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;外部依赖接口&quot;&gt;外部依赖接口&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;mock接口，让接口不按照规则返回数据。&lt;/li&gt;
&lt;li&gt;让外部依赖接口挂掉。&lt;/li&gt;
&lt;li&gt;让外部依赖接口返回不同状态码的数据。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;因为本文内容特别多且多为理论知识，所以我们简单回顾下上面介绍的内容：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第一节强调应该突破常规的操作系统，通过名词和动词的组合来寻找探索点，此外还可以针对软件设计不同的角色人物。&lt;/li&gt;
&lt;li&gt;第二节介绍了软件系统中的实体、属性、依赖，以及他们在CRUD过程中可探索的点。&lt;/li&gt;
&lt;li&gt;第三节介绍软件系统中的各种状态，我们在进行探索性测试时，可以寻找不同状态间的路径，重而可以找到比较隐蔽的短暂中间状态。&lt;/li&gt;
&lt;li&gt;第四节介绍了软件系统所处的外部环境，根据他们的改变，来观察软件系统的变化。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;探索性测试目前还多以理论为主，但是看完相关的学习资料后，还是觉得它确实是我们做常规测试时的一个重要的补充，后面会慢慢的整理一些可以实操的行之有效的方法。但是我觉得理论知识同样重要，希望大家能有所收获。&lt;/p&gt;
</description>
<pubDate>Thu, 12 Dec 2019 00:18:00 +0000</pubDate>
<dc:creator>布道师玄柯</dc:creator>
<og:description>在 '【测试理论】如何做好探索性测试（一）—基础篇' 中，我们介绍了探索性测试的基础内容，我们简单回忆下主要包括：常规测试方案与探索性测试是相辅相成的、在工作中，寻找探索性测试点的时机(需求评审、用例</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhouliweiblog/p/12026853.html</dc:identifier>
</item>
<item>
<title>Go游戏服务端框架从零搭建（一）— 架构设计 - 五邑隐侠</title>
<link>http://www.cnblogs.com/niudanshui/p/11864281.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/niudanshui/p/11864281.html</guid>
<description>&lt;p&gt;         &lt;span&gt;五邑隐侠，本名关健昌，10年游戏生涯，现隐居海边。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;本教程以Go语言分区游戏服务端框架搭建为例。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　Go语言是Google开发的一种静态强类型、编译型、并发型、具有垃圾回收功能的编程语言。语法上近似C语言，支持接口、可通过struct包含另一个struct方式实现继承等面向对象的概念。性能上媲美C/C++，相比C/C++更健壮，更易开发并发程序。我以前也写C++服务端，接触Go后，更倾向用Go做游戏服务端开发。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;所谓分区游戏，指游戏将分为很多个区，不同区之间玩家不能互动或只有少量互动。玩家进入游戏需要选择分区，进入指定分区进行游戏，一个玩家可以同时在不同分区有角色。目前市面上大多中重度网络游戏都采用这种模式，分区游戏适合不需要大DAU互动的游戏，如卡牌、MMORPG、SLG等。从技术层面，分区属于集群扩容的一种手段；运营上，有利于分区精细运营，滚服运营已经是比较成熟的游戏运营手段。相对分区游戏，也存在不分区的社交游戏，这类游戏核心玩法是匹配对抗，例如COC。如果把分区游戏的分区，映射为该类游戏的节点服，广播服映射为匹配服，对不分区游戏的架构也就很好理解。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　本教程主要讲分区游戏服务端框架搭建。&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;总体设计如下：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/137210/201912/137210-20191211154204944-1083780098.png&quot; alt=&quot;&quot; width=&quot;591&quot; height=&quot;594&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;span&gt;分区游戏，玩家先登录游戏，然后进入指定分区。所以首先要有一个登录服务器，提供全局的登录服务。登录服务器的核心数据是玩家账号，核心业务是对玩家进行登录校验，包括使用自有账号系统、第三方账号登录。账号数据需要落地长期存储，所以在该服务器配套一个MySQL数据库，用于保存玩家账号信息。有一到多个登录服务进程，进行游戏登录校验。登录服务是一个短连接服务，使用http协议，对外通过nginx提供统一访问地址，对多个登录服务进程做负载均衡。通常，登录接口还会返回分区信息、玩家各分区角色简要信息、客户端最新版本号、配置版本、资源版本、公告等，这些信息可以通过gm服务（后面会介绍）动态更新，登录服在响应请求时获取并返回给客户端。所以在登录服务器会配套一个redis服务，用于这些数据的缓存。&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　玩家登录游戏成功后，将进入选定游戏分区。分区是一组服务进程。大部分游戏分区都采用长连接通信，如果同时兼顾现在热门的h5游戏、微信小游戏，考虑选用websocket做通信（以前使用socket）。考虑到游戏中会有广播的需求，广播数据和分区游戏数据都希望从同一个连接返回给客户端，有必要提供一个统一的分区入口网关服，网关服进程对客户端提供统一的分区地址和端口，对内做数据转发。分区的逻辑业务可以集中放在一个游戏服进程里。以前一些游戏，游戏服在线数据会保存在进程内存里，由于游戏数据变化太频繁，MySQL 频繁读写性能不高，所以会隔一定时间才保存到MySQL。但分区内&lt;/span&gt;&lt;/span&gt;游戏服是一个单点，一旦崩掉，游戏服的内存数据就会丢失，回档到上一次保存的时间。后来一些游戏为了减少这种风险，把在线数据保存到共享内存，再定时保存到MySQL。共享内存依赖系统和语言，目前发现Go没有直接支持。再后来有了memcached和redis，部分游戏选择用这种缓存系统做缓存，游戏服崩掉，数据还在缓存里不会丢失，可以快速启动游戏服恢复服务。我选用redis作为缓存，缓存活跃玩家数据。隔一定时间，把变化数据保存到MySQL。redis数据主要使用key-value方式保存数据，每次业务处理都需要读取、解析，再使用。对业务开发不是很友好。游戏服进程内存还是会保存在线玩家数据，玩家进入分区时从redis读取到游戏服内存，redis不命中则发布消息给数据服进行数据预热，预热成功后从redis读取。后面的请求可以直接通过内存数据做业务判断、处理，更改数据以事务方式保存到redis，成功后响应给客户端。这样内存数据跟redis数据一致，而且可以把玩家数据拆成更细的单元，减少跟redis间的通信。玩家下线后清除游戏服内存数据。所以分区内配套一个redis、一个MySQL。为了建立定时保存数据这个机制，且不会因游戏服崩溃而受影响，配备一个功能很简单的数据服，通过redis的发布订阅机制、消息队列，负责数据的定时落地固化、玩家注册、数据预热。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　前面提到广播服，广播服顾名思义主要负责广播，例如跑马灯广播、世界聊天、世界boss。广播服通过各个分区的网关服将数据广播给玩家，因此广播服将连接各个分区网关。广播任务通过消息队列进行缓存，这样每个分区的广播操作在写到队列后就可以响应客户端。消息队列采用redis实现。广播服是一个全局的服务，为了避免单点风险，可以做成主从，通过redis的订阅发布机制，启动时订阅redis，如果一定时间没有收到发布消息，认为主服务不存在，切换为主服务，取消消息订阅，连接各分区网关，定时向redis发布消息报活。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　除了业务相关的服务，需要对整个服务体系提供管理。例如开服、停服、更新配置/资源版本、发邮件、发公告、发放道具、踢人等。提供一个全局的gm服，各分区服务启动后，游戏服进程连接到gm服并保持心跳，以通知gm服开/停服。gm服将这些变更信息更新到登录服的redis，这样玩家登录游戏就知道各个服的状态。gm服还可以通过向redis发消息通知登录服进行封号等操作。由于各个游戏服都连接到gm服，这样就可以对各个分区发gm命令。gm服可以通过向广播服的消息队列写消息发全员广播。gm服的功能由运营人员进行操作，所以需要提供http服务，方便在网页上访问。gm服有道具发放的功能，所以第三方支付回调可以通过gm服的http接口请求发货。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　为了给运营提供决策，还需要提供统计后台，对游戏数据日志进行收集、统计。由于登录服、各分区的游戏服、gm服都会上报数据，数据来源广，数据量大，需要做消息队列。因此登录服、游戏服、gm服都通过redis的消息队列进行上报。统计服从redis读取消息，保存数据日志到MySQL。因此需要配套一个redis、一个MySQL。统计服的功能由运营人员使用，需要提供http服务，方便在网页上访问。统计服的http接口还支持客户端进行数据上报。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　为了合并运营人员的页面，gm服、统计服通过nginx提供统一的http地址。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这样就得到了如前面设计图的整个服务框架。 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　本篇介绍到这里，接下来会详细介绍各个服务的实现。在此之前，下一篇先介绍一些通用的基础机制设计和实现。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 12 Dec 2019 00:03:00 +0000</pubDate>
<dc:creator>五邑隐侠</dc:creator>
<og:description>五邑隐侠，本名关健昌，10年游戏生涯，现隐居海边。 本教程以Go语言分区游戏服务端框架搭建为例。 Go语言是Google开发的一种静态强类型、编译型、并发型、具有垃圾回收功能的编程语言。语法上近似C语</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/niudanshui/p/11864281.html</dc:identifier>
</item>
<item>
<title>白话讲解微服务注册发现及负载均衡 - 字母哥博客</title>
<link>http://www.cnblogs.com/zimug/p/12026827.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zimug/p/12026827.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1815316/201912/1815316-20191212074648466-462895226.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;一公益图书馆例子&quot;&gt;一、公益图书馆例子&lt;/h2&gt;
&lt;p&gt;笔者不想直接用专业的术语来说明“微服务注册与发现”，所以我们来看生活中的一个案例：“公益图书馆”。随着人们生活水平的不断提高，追求精神食粮的朋友也越来越多。笔者曾经在一些城市看见过公益图书馆，其运行逻辑是：一些公益组织和个人提供一块场所，然后由组织内的人向图书馆内捐书。捐出的书越多，一段时间内能够借阅的书也就越多。这种做法有助于大家分享图书、节约资金、交流读书心得。那我们来看一下几个关键环节：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;捐书：组织内的人向公益图书馆捐书，是不是直接将书放到书架上就完事了呢？当然不是，是先向图书管理系统记录一下捐书的人、书名、捐书的时间等信息，再将书放到书架上。&lt;/li&gt;
&lt;li&gt;借书：借书的人通常是通过图书管理系统的一个小程序查询图书，然后取书，全靠自觉。图书可能存在多个副本（多人捐的同一种书），借书的人会根据书籍状态择优选择。&lt;/li&gt;
&lt;li&gt;这其中非常重要的一个角色就是图书管理系统及其小程序，为大家捐书、借书提供了数据支持和集中管理功能。&lt;/li&gt;
&lt;li&gt;兼职图书管理员定期维护图书，将破损图书从图书管理系统中下架维护。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其实上面的这个“公益图书馆的例子”就是典型的服务注册与发现：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;每一本图书就是一个服务，捐书的过程就是“服务注册”的过程。&lt;/li&gt;
&lt;li&gt;借书的查询图书的过程就是“服务发现”的过程。&lt;/li&gt;
&lt;li&gt;其中最重要的角色：图书管理系统、管理员及其小程序，就是服务注册中心或者服务注册平台。&lt;/li&gt;
&lt;li&gt;捐书者可能同时是借书者。进行服务注册的微服务节点，同时可能也使用服务发现机制发现其他微服务。&lt;/li&gt;
&lt;li&gt;捐书是主动行为，不是被动行为。这和微服务的注册是一样的，微服务必须在启动的时候向服务注册组件进行主动注册。这样做的目的就是降低数据维护成本，不需要专人维护注册数据。&lt;/li&gt;
&lt;li&gt;图书下架是被动的，不是主动的，不是捐书的人将其下架。微服务也是一样，当服务出现故障发生问题，服务发现注册组件应具备将服务下线的能力。&lt;/li&gt;
&lt;li&gt;图书管理员可以检查图书并下架，这过程在服务注册与发现中被称为：健康检查&lt;/li&gt;
&lt;li&gt;对于同一种图书可能存在多个同样的副本，由使用者择优选择借哪一本书。对于服务发现获得的结果：同一种服务的多个副本的情况，由服务调用者择优决定使用哪一个服务副本。这种服务方式比较专业的说法是：客户端负载均衡。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;与客户端负载均衡相对的方法就是服务端负载均衡，如果上面的例子中借书过程一本书有多个副本，由图书管理员或系统决定借书者借其中的哪一个副本，这个就是服务端负载均衡。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;二服务注册与发现&quot;&gt;二、服务注册与发现&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;服务注册&lt;/strong&gt; -服务在中央注册表中注册其服务位置的过程。通常注册其主机和端口，有时还注册认证凭证，协议，版本号和或环境信息。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;服务发现&lt;/strong&gt; -客户端应用程序查询中央注册表以了解服务位置的过程。&lt;/li&gt;
&lt;li&gt;维护中央注册表的角色被称为服务注册平台或者服务注册中心&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;服务注册&quot;&gt;2.1. 服务注册&lt;/h3&gt;
&lt;p&gt;当一个微服务启动的时候，必须主动向服务注册中心注册其服务地址，以供其他微服务查询调用。图中橘黄色为服务注册中心，绿色为微服务节点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1815316/201912/1815316-20191212074648743-1488886339.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;客户端负载均衡&quot;&gt;2.2.客户端负载均衡&lt;/h3&gt;
&lt;p&gt;当一个微服务有多个副本的时候，由调用者决定使用哪一个副本提供服务。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1815316/201912/1815316-20191212074648933-1210598042.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;三spring-cloud常用的服务注册中心&quot;&gt;三、Spring Cloud常用的服务注册中心&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;Eureka：Spring Cloud的大儿子，出生的时候条件一般，长大后素质有限&lt;/li&gt;
&lt;li&gt;Nacos：后起之秀，曾经Spring Cloud眼中“别人家的孩子”，已经纳入收养范围（孵化项目）。&lt;/li&gt;
&lt;li&gt;Apache Zookeeper：关系户，与hadoop关系比较好&lt;/li&gt;
&lt;li&gt;etcd：关系户，与kubernetes关系比较好&lt;/li&gt;
&lt;li&gt;Consul：关系户，曾经与docker关系比较好&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果你的应用已经使用到了hadoop、kubernetes、docker，在Spring Cloud实施过程中可以考虑使用其关系户组件，避免搭建两套注册中心，节省资源。但是二者兼容使用说说容易，真正用起来还需要功夫。目前看，笔者觉得与Spring Cloud关系最好的应该是Nacos。&lt;/p&gt;
&lt;h2 id=&quot;期待您的关注&quot;&gt;期待您的关注&lt;/h2&gt;
</description>
<pubDate>Wed, 11 Dec 2019 23:47:00 +0000</pubDate>
<dc:creator>字母哥博客</dc:creator>
<og:description>一、公益图书馆例子 笔者不想直接用专业的术语来说明“微服务注册与发现”，所以我们来看生活中的一个案例：“公益图书馆”。随着人们生活水平的不断提高，追求精神食粮的朋友也越来越多。笔者曾经在一些城市看见过</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zimug/p/12026827.html</dc:identifier>
</item>
<item>
<title>灵魂拷问：Java 的 substring() 是如何工作的？ - 沉默王二</title>
<link>http://www.cnblogs.com/qing-gee/p/12026823.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qing-gee/p/12026823.html</guid>
<description>&lt;p&gt;在逛 programcreek 的时候，我发现了一些小而精悍的主题。比如说：Java 的 &lt;code&gt;substring()&lt;/code&gt; 方法是如何工作的？像这类灵魂拷问的主题，非常值得深入地研究一下。&lt;/p&gt;
&lt;p&gt;另外，我想要告诉大家的是，研究的过程非常的有趣，就好像在迷宫里探宝一样，起初有些不知所措，但经过一番用心的摸索后，不但会找到宝藏，还会有一种茅塞顿开的感觉，非常棒。&lt;/p&gt;
&lt;p&gt;对于绝大多数的初级程序员或者说不重视“内功”的老鸟来说，往往停留在“知其然不知其所以然”的层面上——会用，但要说底层的原理，可就只能挠挠头双手一摊一张问号脸了。&lt;/p&gt;
&lt;p&gt;很长一段时间内，&lt;a href=&quot;https://mp.weixin.qq.com/s/feoOINGSyivBO8Z1gaQVOA&quot;&gt;我&lt;/a&gt;也一直处于这种层面上。但我决定改变了，因为“内功”就好像是在打地基，只有把地基打好了，才能盖起经得住考验的高楼大厦。借此机会，我就和大家一起，对“Java 的 substring() 是如何工作的”进行一次深入地研究。注意了，准备打怪升级了！&lt;/p&gt;
&lt;h3 id=&quot;h01substring&quot;&gt;&lt;span&gt;01、substring() 是干嘛的&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;sub&lt;/code&gt; 是 &lt;code&gt;subtract&lt;/code&gt; 的缩写，因此 &lt;code&gt;substring&lt;/code&gt; 的字面意思就是“把字符串做个减法”。这样一分析，是不是感觉方法的命名还是蛮有讲究的？&lt;/p&gt;
&lt;p&gt;&lt;code&gt;substring()&lt;/code&gt; 的完整写法是 &lt;code&gt;substring(int beginIndex, int endIndex)&lt;/code&gt;。该方法返回一个新的字符串，介于原有字符串的起始下标 &lt;code&gt;beginIndex&lt;/code&gt; 和结尾下标 &lt;code&gt;endIndex-1&lt;/code&gt; 之间。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;String cmower = &lt;span class=&quot;hljs-string&quot;&gt;&quot;沉默王二，一枚有趣的程序员&quot;&lt;/span&gt;;&lt;br/&gt;cmower = cmower.substring(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;);&lt;br/&gt;System.out.println(cmower);&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;程序输出的结果为：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs&quot;&gt;沉默王二&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为什么呢？我来简单解释一下。&lt;/p&gt;
&lt;p&gt;Java 的下标都是从 0 开始编号的（我不确定有没有从 1 开始的编程语言），这和我们平常生活中从 1 开始编号的习惯不同。Java 这样做的原因如下：&lt;/p&gt;
&lt;p&gt;Java 是基于 C 语言实现的，而 C 语言的下标是从 0 开始的——这听起来好像是一句废话。真正的原因是下标并不是下标，在指针（C）语言中，它实际上是一个偏移量，距离开始位置的一个偏移量。第一个元素在开头，因此它的偏移量就为 0。&lt;/p&gt;
&lt;p&gt;此外，还有另外一种说法。早期的计算机资源比较匮乏，0 作为起始下标相比较于 1 作为起始下标，编译的效率更高。&lt;/p&gt;
&lt;p&gt;知道了这层原因后，再来看上面这段代码，就会豁然开朗。对于“沉默王二，一枚有趣的程序员”这串字符来说，“沉”的下标为 0，“默”的下标为 1，“王”的下标为 2，“二”的下标为 3，所以 &lt;code&gt;cmower.substring(0, 4)&lt;/code&gt; 返回的字符串是“沉默王二”——包括起始下标但不包括结尾下标。&lt;/p&gt;
&lt;h3 id=&quot;h02substring&quot;&gt;&lt;span&gt;02、substring() 在被调用的时候究竟发生了什么？&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;在此之前，我们已经了解到：[字符串是不可变的]()，因此当调用 &lt;code&gt;substring()&lt;/code&gt; 方法的时候，返回的其实是一个新的字符串。那么变量 cmower 的地址引用就会发生如下图所示的变化。&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2019/12/java-substring-2.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;为了证明上图是完全正确的，我们来看一下 JDK 7 中 &lt;code&gt;substring()&lt;/code&gt; 的源码。&lt;/p&gt;
&lt;pre readability=&quot;6&quot;&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;6&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;char&lt;/span&gt; value[], &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; offset, &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; count)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;.value = Arrays.copyOfRange(value, offset, offset + count);&lt;br/&gt;}&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;hljs-title&quot;&gt;substring&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; beginIndex, &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; endIndex)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; subLen = endIndex - beginIndex;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; String(value, beginIndex, subLen);&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看得出，&lt;code&gt;substring()&lt;/code&gt; 通过 &lt;code&gt;new String()&lt;/code&gt; 返回了一个新的字符串对象，在创建新的对象时通过 &lt;code&gt;Arrays.copyOfRange()&lt;/code&gt; 复制了一个新的字符数组。&lt;/p&gt;
&lt;p&gt;但 JDK 6 就有所不同。说到 JDK 6，可能有些读者表示不服，JDK 6？什么年代了，JDK 13 都出来了好不好？但我想告诉大家的是，对比着剖析 JDK 的源码，对学习大有裨益。&lt;/p&gt;
&lt;p&gt;不是有那么一句话嘛，要想了解一个成功人士，不能只关注他发迹以后的事，更要关注他之前做了什么。&lt;/p&gt;
&lt;p&gt;就请随我来，看看 JDK 6 中的 &lt;code&gt;substring()&lt;/code&gt; 的源码吧。&lt;/p&gt;
&lt;pre readability=&quot;6&quot;&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;6&quot;&gt;&lt;br/&gt;String(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; offset, &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; count, &lt;span class=&quot;hljs-keyword&quot;&gt;char&lt;/span&gt; value[]) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;.value = value;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;.offset = offset;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;.count = count;&lt;br/&gt;}&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;hljs-title&quot;&gt;substring&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; beginIndex, &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; endIndex)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt;  &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; String(offset + beginIndex, endIndex - beginIndex, value);&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;substring()&lt;/code&gt; 方法本身和 JDK 7 并没有很大的差别，都通过 &lt;code&gt;new String()&lt;/code&gt; 返回了一个新的字符串对象。但是 &lt;code&gt;String()&lt;/code&gt; 这个构造函数有很大的差别，JDK 6 只是简单地更改了一下两个属性（&lt;code&gt;offset&lt;/code&gt; 和 &lt;code&gt;count&lt;/code&gt;）的值，value 并没有变。&lt;/p&gt;
&lt;p&gt;PS：&lt;code&gt;value&lt;/code&gt; 是真正存储字符的数组，&lt;code&gt;offset&lt;/code&gt; 是数组中第一个元素的下标，&lt;code&gt;count&lt;/code&gt; 是数组中字符的个数。&lt;/p&gt;
&lt;p&gt;这意味着什么呢？&lt;/p&gt;
&lt;p&gt;调用 &lt;code&gt;substring()&lt;/code&gt; 的时候虽然创建了新的字符串，但字符串的值仍然指向的是内存中的同一个数组，如下图所示。&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2019/12/java-substring-3.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;h3 id=&quot;h03jdk7&quot;&gt;&lt;span&gt;03、为什么 JDK 7 的构造函数发生了变化&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;看了 JDK 6 和 JDK 7 源码之后，大家可能产生这样一个疑惑：为什么 JDK 7 要做出改变呢？大家共用同一个字符串数组不是挺好的嘛，省得占用新的内存空间。事实上呢？&lt;/p&gt;
&lt;p&gt;如果有一个很长很长的字符串，可以绕地球一周，当我们需要调用 &lt;code&gt;substring()&lt;/code&gt; 截取其中很小一段字符串时，就有可能导致性能问题。由于这一小段字符串引用了整个很长很长的字符数组，就导致很长很长的这个字符数组无法被回收，内存一直被占用着，就有可能引发内存泄露。&lt;/p&gt;
&lt;p&gt;PS：内存泄露是指由于疏忽或错误造成程序未能释放已经不再使用的内存。&lt;/p&gt;
&lt;p&gt;那 JDK 7 出现之前，这个隐患怎么应对呢？答案如下。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;cmower = cmower.substring(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;) + &lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为什么，为什么，为什么，多一个 “+ &quot;&quot;” 就能解决内存泄漏的问题？有些读者可能不太相信，我来带大家分析一下。&lt;/p&gt;
&lt;p&gt;首先呢，我们通过 &lt;a href=&quot;http://www.itwanger.com/java/2019/10/22/javac-jad.html&quot;&gt;JAD&lt;/a&gt; 对字节码反编译一下，上面这行代码就变成了如下内容。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt; cmower = (&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; StringBuilder(String.valueOf(cmower.substring(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;)))).toString();&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;“+”号操作符就相当于一个语法糖，加上空的字符串后，会被 JDK 转化为 StringBuilder 对象，该对象在处理字符串的时候会生成新的字符数组，所以 &lt;code&gt;cmower = cmower.substring(0, 4) + &quot;&quot;;&lt;/code&gt; 这行代码执行后，cmower 就指向了和 &lt;code&gt;substring()&lt;/code&gt; 调用之前不同的字符数组。&lt;/p&gt;
&lt;p&gt;PS：如果不明白“+”号操作符的工作原理，请查阅我之前写的文章《&lt;a href=&quot;https://mp.weixin.qq.com/s/doWGxF94sd6V_dSwJMmE-Q&quot;&gt;羞，Java 字符串拼接竟然有这么多姿势&lt;/a&gt;》，这里就不再赘述，免得被老读者捶。&lt;/p&gt;
&lt;h3 id=&quot;h04&quot;&gt;&lt;span&gt;04、最后&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;总结一下，JDK 7 和 JDK 6 的 &lt;code&gt;substring()&lt;/code&gt; 方法本身并没有多大的改变，但 String 类的构造函数有了很大的区别，JDK 7 会重新复制一份字符数组，而 JDK 6 不会，因此 JDK 6 在执行比较长的字符串 &lt;code&gt;substring()&lt;/code&gt; 时可能会引发内存泄露的问题。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;好了各位读者朋友们，以上就是本文的全部内容了。&lt;strong&gt;能看到这里的都是最优秀的程序员，二哥必须要为你点个赞&lt;/strong&gt;👍。如果觉得不过瘾，还想看到更多，我再推荐几篇给大家。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.itwanger.com/java/2019/11/28/java-string-shuangyinhao-gouzaohanshu.html&quot;&gt;灵魂拷问：创建 Java 字符串，用&quot;&quot;还是构造函数&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/CRQrm5zGpqWxYL_ztk-b2Q&quot;&gt;灵魂拷问：为什么 Java 字符串是不可变的？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/DBvgghP5cN6KlPnILaqjmQ&quot;&gt;灵魂拷问：如何检查Java数组中是否包含某个值 ？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果觉得这篇文章有点用的话，&lt;strong&gt;求点赞、求留言、求关注&lt;/strong&gt;，咱们一起养成好习惯！另外，我整理了一份顶级 Java 程序员必读的书单，回台回复关键字「Java」即可免费获取。&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/cmower_4.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;</description>
<pubDate>Wed, 11 Dec 2019 23:31:00 +0000</pubDate>
<dc:creator>沉默王二</dc:creator>
<og:description>在逛 programcreek 的时候，我发现了一些小而精悍的主题。比如说：Java 的 substring() 方法是如何工作的？像这类灵魂拷问的主题，非常值得深入地研究一下。 另外，我想要告诉大家</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qing-gee/p/12026823.html</dc:identifier>
</item>
<item>
<title>Android 自定义 View 详解 - huansky</title>
<link>http://www.cnblogs.com/huansky/p/11808234.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huansky/p/11808234.html</guid>
<description>&lt;h3&gt;View 的绘制系列文章：&lt;/h3&gt;
&lt;p&gt;对于 Android 开发者来说，原生控件往往无法满足要求，需要开发者自定义一些控件，因此，需要去了解自定义 view 的实现原理。这样即使碰到需要自定义控件的时候，也可以游刃有余。&lt;/p&gt;
&lt;div readability=&quot;64.286431698613&quot;&gt;

&lt;h2&gt;自定义 View 分类&lt;/h2&gt;
&lt;p&gt;自定义 View 的实现方式有以下几种：&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr&gt;&lt;td&gt;类型&lt;/td&gt;
&lt;td&gt;定义&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;自定义组合控件&lt;/td&gt;
&lt;td&gt;多个控件组合成为一个新的控件，方便多处复用&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;继承系统 View 控件&lt;/td&gt;
&lt;td&gt;继承自TextView等系统控件，在系统控件的基础功能上进行扩展&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;继承 View&lt;/td&gt;
&lt;td&gt;不复用系统控件逻辑，继承View进行功能定义&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;继承系统 ViewGroup&lt;/td&gt;
&lt;td&gt;继承自LinearLayout等系统控件，在系统控件的基础功能上进行扩展&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;继承 View ViewGroup&lt;/td&gt;
&lt;td&gt;不复用系统控件逻辑，继承ViewGroup进行功能定义&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;从上到下越来越难，需要的了解的知识也是越来越多的。&lt;/p&gt;
&lt;h3&gt;构造函数&lt;/h3&gt;
&lt;p&gt;当我们在自定义 View 的时候，构造函数都是不可缺少，需要对构造函数进行重写，构造函数有多个，至少要重写其中一个才行。例如我们新建 MyTextView：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
   &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 在java代码里new的时候会用到
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; context
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; MyTextView(Context context) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(context);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 在xml布局文件中使用时自动调用
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; context
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; MyTextView(Context context, @Nullable AttributeSet attrs) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(context, attrs);&lt;/span&gt;&lt;span&gt;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 不会自动调用，如果有默认style时，在第二个构造函数中调用
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; context
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; attrs
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; defStyleAttr
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; MyTextView(Context context, @Nullable AttributeSet attrs, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; defStyleAttr) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(context, attrs, defStyleAttr);
    }


    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 只有在API版本&amp;gt;21时才会用到
     * 不会自动调用，如果有默认style时，在第二个构造函数中调用
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; context
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; attrs
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; defStyleAttr
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; defStyleRes
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @RequiresApi(api &lt;/span&gt;=&lt;span&gt; Build.VERSION_CODES.LOLLIPOP)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; MyTextView(Context context, @Nullable AttributeSet attrs, &lt;span&gt;int&lt;/span&gt; defStyleAttr, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; defStyleRes) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(context, attrs, defStyleAttr, defStyleRes);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对于每一种构造函数的作用，都已经再代码里面写出来了。&lt;/p&gt;
&lt;h3&gt;自定义属性&lt;/h3&gt;
&lt;p&gt;写过布局的同学都知道，系统控件的属性在 xml 中都是以 android 开头的。对于自定义 View，也可以自定义属性，在 xml 中使用。&lt;/p&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;Android 自定义属性可分为以下几步:&lt;/p&gt;
&lt;ol readability=&quot;0&quot;&gt;&lt;li&gt;
&lt;p&gt;自定义一个 View&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;编写 values/attrs.xml，在其中编写 styleable 和 item 等标签元素&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;在布局文件中 View 使用自定义的属性（注意 namespace）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;在 View 的构造方法中通过 TypedArray 获取&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;
e.g  还是以上面的 MyTextView 做演示：&lt;/div&gt;
&lt;p&gt;首先我在 activity_main.xml 中引入了 MyTextView:&lt;/p&gt;
&lt;div readability=&quot;14&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;android.support.constraint.ConstraintLayout &lt;/span&gt;&lt;span&gt;xmlns:android&lt;/span&gt;&lt;span&gt;=&quot;http://schemas.android.com/apk/res/android&quot;&lt;/span&gt;&lt;span&gt;
    xmlns:app&lt;/span&gt;&lt;span&gt;=&quot;http://schemas.android.com/apk/res-auto&quot;&lt;/span&gt;&lt;span&gt;
    xmlns:tools&lt;/span&gt;&lt;span&gt;=&quot;http://schemas.android.com/tools&quot;&lt;/span&gt;&lt;span&gt;
    android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;match_parent&quot;&lt;/span&gt;&lt;span&gt;
    android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;match_parent&quot;&lt;/span&gt;&lt;span&gt;
    tools:context&lt;/span&gt;&lt;span&gt;=&quot;.MainActivity&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;com.example.myapplication.MyTextView
        &lt;/span&gt;&lt;span&gt;android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;100dp&quot;&lt;/span&gt;&lt;span&gt;
        android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;200dp&quot;&lt;/span&gt;&lt;span&gt;
        app:testAttr&lt;/span&gt;&lt;span&gt;=&quot;520&quot;&lt;/span&gt;&lt;span&gt;
        app:text&lt;/span&gt;&lt;span&gt;=&quot;helloWorld&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;android.support.constraint.ConstraintLayout&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后我在 values/attrs.xml 中添加自定义属性：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;resources&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;declare-styleable &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;test&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;attr &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt;&lt;span&gt; format&lt;/span&gt;&lt;span&gt;=&quot;string&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;attr &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;testAttr&quot;&lt;/span&gt;&lt;span&gt; format&lt;/span&gt;&lt;span&gt;=&quot;integer&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;declare-styleable&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;resources&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;记得在构造函数里面说过，xml 布局会调用第二个构造函数，因此在这个构造函数里面获取属性和解析：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
   &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 在xml布局文件中使用时自动调用
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; context
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; MyTextView(Context context, @Nullable AttributeSet attrs) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(context, attrs);
        TypedArray ta &lt;/span&gt;=&lt;span&gt; context.obtainStyledAttributes(attrs, R.styleable.test);
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; textAttr = ta.getInteger(R.styleable.test_testAttr, -1&lt;span&gt;);
        String text &lt;/span&gt;=&lt;span&gt; ta.getString(R.styleable.test_text);
        Log.d(TAG, &lt;/span&gt;&quot; text = &quot; + text + &quot;, textAttr = &quot; +&lt;span&gt; textAttr);&lt;br/&gt;&lt;span&gt;　　　　　// toast 显示获取的属性值
&lt;/span&gt;        Toast.makeText(context, text &lt;/span&gt;+ &quot; &quot; +&lt;span&gt; textAttr, Toast.LENGTH_LONG).show();
        ta.recycle();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意当你在引用自定义属性的时候，记得加上 name 前缀，否则会引用不到。&lt;/p&gt;
&lt;p&gt;这里本想截图 log 的，奈何就是不显示，就搞成 toast 了。&lt;/p&gt;
&lt;p&gt;当然，你还可以自定义很多其他属性，包括 color, string, integer, boolean, flag，甚至是混合等。&lt;/p&gt;
&lt;p&gt;view 的绘制流程可以参考文章：&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/huansky/p/9693073.html&quot;&gt;【转】深入理解Android之View的绘制流程&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;前提用户已经知道一些基础知识，不再过多介绍；主要得介绍 onMeasure, ondraw, onLayout ；事件冲突。&lt;/p&gt;
&lt;p&gt;下面直接进入正题：&lt;/p&gt;
&lt;div readability=&quot;33.440992558017&quot;&gt;
&lt;p&gt;自定义组合控件就是将多个控件组合成为一个新的控件，主要解决多次重复使用同一类型的布局。如我们顶部的HeaderView以及dailog等，我们都可以把他们组合成一个新的控件。&lt;/p&gt;
&lt;p&gt;我们通过一个自定义 MyView1 实例来了解自定义组合控件的用法。&lt;/p&gt;
&lt;p&gt;xml 布局 &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;merge &lt;/span&gt;&lt;span&gt;xmlns:android&lt;/span&gt;&lt;span&gt;=&quot;http://schemas.android.com/apk/res/android&quot;&lt;/span&gt;&lt;span&gt;
    android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;wrap_content&quot;&lt;/span&gt;&lt;span&gt;
    android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;wrap_content&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TextView
        &lt;/span&gt;&lt;span&gt;android:id&lt;/span&gt;&lt;span&gt;=&quot;@+id/feed_item_com_cont_title&quot;&lt;/span&gt;&lt;span&gt;
        android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;wrap_content&quot;&lt;/span&gt;&lt;span&gt;
        android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;wrap_content&quot;&lt;/span&gt;&lt;span&gt;
        android:ellipsize&lt;/span&gt;&lt;span&gt;=&quot;end&quot;&lt;/span&gt;&lt;span&gt;
        android:includeFontPadding&lt;/span&gt;&lt;span&gt;=&quot;false&quot;&lt;/span&gt;&lt;span&gt;
        android:maxLines&lt;/span&gt;&lt;span&gt;=&quot;2&quot;&lt;/span&gt;&lt;span&gt;
        android:text&lt;/span&gt;&lt;span&gt;=&quot;title&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TextView
        &lt;/span&gt;&lt;span&gt;android:id&lt;/span&gt;&lt;span&gt;=&quot;@+id/feed_item_com_cont_desc&quot;&lt;/span&gt;&lt;span&gt;
        android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;wrap_content&quot;&lt;/span&gt;&lt;span&gt;
        android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;wrap_content&quot;&lt;/span&gt;&lt;span&gt;
        android:layout_below&lt;/span&gt;&lt;span&gt;=&quot;@id/feed_item_com_cont_title&quot;&lt;/span&gt;&lt;span&gt;
        android:ellipsize&lt;/span&gt;&lt;span&gt;=&quot;end&quot;&lt;/span&gt;&lt;span&gt;
        android:includeFontPadding&lt;/span&gt;&lt;span&gt;=&quot;false&quot;&lt;/span&gt;&lt;span&gt;
        android:maxLines&lt;/span&gt;&lt;span&gt;=&quot;2&quot;&lt;/span&gt;&lt;span&gt;
        android:text&lt;/span&gt;&lt;span&gt;=&quot;desc&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;merge&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 自定义 View 代码 ：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.example.myapplication;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.content.Context;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.util.AttributeSet;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.view.LayoutInflater;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.view.View;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.widget.RelativeLayout;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.widget.TextView;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MyView1 &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; RelativeLayout {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 标题 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; TextView mTitle;
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 描述 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; TextView mDesc;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; MyView1(Context context) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;(context, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; MyView1(Context context, AttributeSet attrs) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;(context, attrs, 0&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; MyView1(Context context, AttributeSet attrs, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; defStyleAttr) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(context, attrs, defStyleAttr);
        initView(context);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 初使化界面视图
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; context 上下文环境
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; initView(Context context) {
        View rootView &lt;/span&gt;= LayoutInflater.from(getContext()).inflate(R.layout.my_view1, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;);

        mDesc &lt;/span&gt;=&lt;span&gt; rootView.findViewById(R.id.feed_item_com_cont_desc);
        mTitle &lt;/span&gt;=&lt;span&gt; rootView.findViewById(R.id.feed_item_com_cont_title);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在布局当中引用该控件 &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;LinearLayout &lt;/span&gt;&lt;span&gt;xmlns:android&lt;/span&gt;&lt;span&gt;=&quot;http://schemas.android.com/apk/res/android&quot;&lt;/span&gt;&lt;span&gt;
    xmlns:app&lt;/span&gt;&lt;span&gt;=&quot;http://schemas.android.com/apk/res-auto&quot;&lt;/span&gt;&lt;span&gt;
    xmlns:tools&lt;/span&gt;&lt;span&gt;=&quot;http://schemas.android.com/tools&quot;&lt;/span&gt;&lt;span&gt;
    android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;match_parent&quot;&lt;/span&gt;&lt;span&gt;
    android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;match_parent&quot;&lt;/span&gt;&lt;span&gt;
    android:orientation&lt;/span&gt;&lt;span&gt;=&quot;vertical&quot;&lt;/span&gt;&lt;span&gt;
    tools:context&lt;/span&gt;&lt;span&gt;=&quot;.MainActivity&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TextView
        &lt;/span&gt;&lt;span&gt;android:id&lt;/span&gt;&lt;span&gt;=&quot;@+id/text&quot;&lt;/span&gt;&lt;span&gt;
        android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;100dp&quot;&lt;/span&gt;&lt;span&gt;
        android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;100dp&quot;&lt;/span&gt;&lt;span&gt;
        android:clickable&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;&lt;span&gt;
        android:enabled&lt;/span&gt;&lt;span&gt;=&quot;false&quot;&lt;/span&gt;&lt;span&gt;
        android:focusable&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;&lt;span&gt;
        android:text&lt;/span&gt;&lt;span&gt;=&quot;trsfnjsfksjfnjsdfjksdhfjksdjkfhdsfsdddddddddddddddddddddddddd&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;com.example.myapplication.MyTextView
        &lt;/span&gt;&lt;span&gt;android:id&lt;/span&gt;&lt;span&gt;=&quot;@+id/myview&quot;&lt;/span&gt;&lt;span&gt;
        android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;100dp&quot;&lt;/span&gt;&lt;span&gt;
        android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;200dp&quot;&lt;/span&gt;&lt;span&gt;
        android:clickable&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;&lt;span&gt;
        android:enabled&lt;/span&gt;&lt;span&gt;=&quot;false&quot;&lt;/span&gt;&lt;span&gt;
        android:focusable&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;&lt;span&gt;
        app:testAttr&lt;/span&gt;&lt;span&gt;=&quot;520&quot;&lt;/span&gt;&lt;span&gt;
        app:text&lt;/span&gt;&lt;span&gt;=&quot;helloWorld&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;com.example.myapplication.MyView1
        &lt;/span&gt;&lt;span&gt;android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;wrap_content&quot;&lt;/span&gt;&lt;span&gt;
        android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;wrap_content&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;LinearLayout&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最终效果如下图所示 ：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/916005/201911/916005-20191124222211008-171469461.png&quot; alt=&quot;&quot; width=&quot;250&quot; height=&quot;312&quot;/&gt; &lt;/p&gt;
&lt;div readability=&quot;44.409566631103&quot;&gt;
&lt;div readability=&quot;15&quot;&gt;

&lt;p&gt;继承系统的控件可以分为继承 View子类（如 TextView 等）和继承 ViewGroup 子类(如 LinearLayout 等)，根据业务需求的不同，实现的方式也会有比较大的差异。这里介绍一个比较简单的，继承自View的实现方式。&lt;/p&gt;
&lt;p&gt;业务需求：为文字设置背景，并在布局中间添加一条横线。&lt;/p&gt;
&lt;p&gt;因为这种实现方式会复用系统的逻辑，大多数情况下我们希望复用系统的 &lt;code&gt;onMeaseur &lt;/code&gt;和 &lt;code&gt;onLayout &lt;/code&gt;流程，所以我们只需要重写 &lt;code&gt;onDraw &lt;/code&gt;方法 。实现非常简单，话不多说，直接上代码。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.example.myapplication;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.content.Context;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.graphics.Canvas;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.graphics.LinearGradient;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.graphics.Shader;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.text.TextPaint;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.util.AttributeSet;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.widget.TextView;


&lt;/span&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; android.support.v4.content.ContextCompat.getColor;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 包含分割线的textView
 * 文字左右两边有一条渐变的分割线
 * 样式如下：
 * ———————— 文字 ————————
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; DividingLineTextView &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; TextView {
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 线性渐变 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; LinearGradient mLinearGradient;
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; textPaint &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; TextPaint mPaint;
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 文字 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; String mText = &quot;&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 屏幕宽度 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; mScreenWidth;
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 开始颜色 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; mStartColor;
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 结束颜色 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; mEndColor;
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 字体大小 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; mTextSize;


    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 构造函数
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; DividingLineTextView(Context context, AttributeSet attrs, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; defStyle) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(context, attrs, defStyle);
        mTextSize &lt;/span&gt;=&lt;span&gt; getResources().getDimensionPixelSize(R.dimen.text_size);
        mScreenWidth &lt;/span&gt;=&lt;span&gt; getCalculateWidth(getContext());
        mStartColor &lt;/span&gt;=&lt;span&gt; getColor(getContext(), R.color.colorAccent);
        mEndColor &lt;/span&gt;=&lt;span&gt; getColor(getContext(), R.color.colorPrimary);
        mLinearGradient &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; LinearGradient(0, 0, mScreenWidth, 0&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;[]{mStartColor, mEndColor, mStartColor},
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; &lt;span&gt;float&lt;/span&gt;[]{0, 0.5f&lt;span&gt;, 1f},
                Shader.TileMode.CLAMP);
        mPaint &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TextPaint();
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; DividingLineTextView(Context context, AttributeSet attrs) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;(context, attrs, 0&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; DividingLineTextView(Context context) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;(context, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onDraw(Canvas canvas) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.onDraw(canvas);
        mPaint.setAntiAlias(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
        mPaint.setTextSize(mTextSize);
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; len =&lt;span&gt; getTextLength(mText, mPaint);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 文字绘制起始坐标&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; sx = mScreenWidth / 2 - len / 2&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 文字绘制结束坐标&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; ex = mScreenWidth / 2 + len / 2&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; height =&lt;span&gt; getMeasuredHeight();
        mPaint.setShader(mLinearGradient);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 绘制左边分界线，从左边开始：左边距15dp， 右边距距离文字15dp&lt;/span&gt;
        canvas.drawLine(mTextSize, height / 2, sx - mTextSize, height / 2&lt;span&gt;, mPaint);
        mPaint.setShader(mLinearGradient);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 绘制右边分界线，从文字右边开始：左边距距离文字15dp，右边距15dp&lt;/span&gt;
        canvas.drawLine(ex + mTextSize, height / 2&lt;span&gt;,
                mScreenWidth &lt;/span&gt;- mTextSize, height / 2&lt;span&gt;, mPaint);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 返回指定文字的宽度，单位px
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; str   要测量的文字
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; paint 绘制此文字的画笔
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; 返回文字的宽度，单位px
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getTextLength(String str, TextPaint paint) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt;&lt;span&gt;) paint.measureText(str);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 更新文字
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; text 文字
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; update(String text) {
        mText &lt;/span&gt;=&lt;span&gt; text;
        setText(mText);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 刷新重绘&lt;/span&gt;
&lt;span&gt;        requestLayout();
    }


    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 获取需要计算的宽度，取屏幕高宽较小值，
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; context context
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; 屏幕宽度值
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getCalculateWidth(Context context) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; height =&lt;span&gt; context.getResources().getDisplayMetrics().heightPixels;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 动态屏幕宽度，在折叠屏手机上宽度在分屏时会发生变化&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; Width =&lt;span&gt; context.getResources().getDisplayMetrics().widthPixels;

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Math.min(Width, height);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对于 View 的绘制还需要对 &lt;code&gt;Paint()&lt;/code&gt;、&lt;code&gt;canvas &lt;/code&gt;以及 &lt;code&gt;Path &lt;/code&gt;的使用有所了解，不清楚的可以稍微了解一下。 &lt;/p&gt;
&lt;p&gt;看下布局里面的引用：&lt;/p&gt;
&lt;p&gt;xml 布局 &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;LinearLayout &lt;/span&gt;&lt;span&gt;xmlns:android&lt;/span&gt;&lt;span&gt;=&quot;http://schemas.android.com/apk/res/android&quot;&lt;/span&gt;&lt;span&gt;
    xmlns:app&lt;/span&gt;&lt;span&gt;=&quot;http://schemas.android.com/apk/res-auto&quot;&lt;/span&gt;&lt;span&gt;
    xmlns:tools&lt;/span&gt;&lt;span&gt;=&quot;http://schemas.android.com/tools&quot;&lt;/span&gt;&lt;span&gt;
    android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;match_parent&quot;&lt;/span&gt;&lt;span&gt;
    android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;match_parent&quot;&lt;/span&gt;&lt;span&gt;
    android:orientation&lt;/span&gt;&lt;span&gt;=&quot;vertical&quot;&lt;/span&gt;&lt;span&gt;
    tools:context&lt;/span&gt;&lt;span&gt;=&quot;.MainActivity&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;

   // ...... 跟前面一样忽视
    &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;com.example.myapplication.DividingLineTextView
        &lt;/span&gt;&lt;span&gt;android:id&lt;/span&gt;&lt;span&gt;=&quot;@+id/divide&quot;&lt;/span&gt;&lt;span&gt;
        android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;match_parent&quot;&lt;/span&gt;&lt;span&gt;
        android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;wrap_content&quot;&lt;/span&gt;&lt;span&gt;
        android:gravity&lt;/span&gt;&lt;span&gt;=&quot;center&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;LinearLayout&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

activty 里面代码如下 ：&lt;br/&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onCreate(Bundle savedInstanceState) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        DividingLineTextView te &lt;/span&gt;=&lt;span&gt; findViewById(R.id.divide);
        te.update(&lt;/span&gt;&quot;DividingLineTextView&quot;&lt;span&gt;);
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里通过 update() 对来重新绘制，确保边线在文字的两边。视觉效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/916005/201911/916005-20191124225440440-1365561011.png&quot; alt=&quot;&quot; width=&quot;285&quot; height=&quot;370&quot;/&gt;&lt;/p&gt;


&lt;div readability=&quot;27.924293632554&quot;&gt;
&lt;div readability=&quot;11&quot;&gt;
&lt;p&gt;直接继承 View 会比上一种实现方复杂一些，这种方法的使用情景下，完全不需要复用系统控件的逻辑，除了要重写 &lt;code&gt;onDraw &lt;/code&gt;外还需要对 &lt;code&gt;onMeasure &lt;/code&gt;方法进行重写。&lt;/p&gt;
&lt;p&gt;我们用自定义 View 来绘制一个正方形。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;首先定义构造方法，以及做一些初始化操作&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
ublic &lt;span&gt;class&lt;/span&gt; RectView &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; View{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义画笔&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; Paint mPaint = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Paint();

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 实现构造方法
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; context
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; RectView(Context context) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(context);
        init();
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; RectView(Context context, @Nullable AttributeSet attrs) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(context, attrs);
        init();
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; RectView(Context context, @Nullable AttributeSet attrs, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; defStyleAttr) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(context, attrs, defStyleAttr);
        init();
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; init() {
        mPaint.setColor(Color.BLUE);

    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 重写 draw 方法，绘制正方形，注意对 padding 属性进行设置：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 重写draw方法
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; canvas
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onDraw(Canvas canvas) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.onDraw(canvas);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取各个编剧的padding值&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; paddingLeft =&lt;span&gt; getPaddingLeft();
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; paddingRight =&lt;span&gt; getPaddingRight();
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; paddingTop =&lt;span&gt; getPaddingTop();
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; paddingBottom =&lt;span&gt; getPaddingBottom();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取绘制的View的宽度&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; width = getWidth()-paddingLeft-&lt;span&gt;paddingRight;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取绘制的View的高度&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; height = getHeight()-paddingTop-&lt;span&gt;paddingBottom;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;绘制View，左上角坐标（0+paddingLeft,0+paddingTop），右下角坐标（width+paddingLeft,height+paddingTop）&lt;/span&gt;
        canvas.drawRect(0+paddingLeft,0+paddingTop,width+paddingLeft,height+&lt;span&gt;paddingTop,mPaint);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在 View 的源码当中并没有对 &lt;code&gt;AT_MOST &lt;/code&gt;和 &lt;code&gt;EXACTLY &lt;/code&gt;两个模式做出区分，也就是说 View 在 &lt;code&gt;wrap_content &lt;/code&gt;和 &lt;code&gt;match_parent &lt;/code&gt;两个模式下是完全相同的，都会是 &lt;code&gt;match_parent&lt;/code&gt;，显然这与我们平时用的 View 不同，所以我们要重写 &lt;code&gt;onMeasure &lt;/code&gt;方法。&lt;/p&gt;
&lt;div readability=&quot;16&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 重写onMeasure方法
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; widthMeasureSpec
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; heightMeasureSpec
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; onMeasure(&lt;span&gt;int&lt;/span&gt; widthMeasureSpec, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; heightMeasureSpec) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.onMeasure(widthMeasureSpec, heightMeasureSpec);
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; widthSize =&lt;span&gt; MeasureSpec.getSize(widthMeasureSpec);
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; widthMode =&lt;span&gt; MeasureSpec.getMode(widthMeasureSpec);
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; heightSize =&lt;span&gt; MeasureSpec.getSize(heightMeasureSpec);
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; heightMode =&lt;span&gt; MeasureSpec.getMode(heightMeasureSpec);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;处理wrap_contentde情况&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (widthMode == MeasureSpec.AT_MOST &amp;amp;&amp;amp; heightMode ==&lt;span&gt; MeasureSpec.AT_MOST) {
            setMeasuredDimension(&lt;/span&gt;300, 300&lt;span&gt;);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (widthMode ==&lt;span&gt; MeasureSpec.AT_MOST) {
            setMeasuredDimension(&lt;/span&gt;300&lt;span&gt;, heightSize);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (heightMode ==&lt;span&gt; MeasureSpec.AT_MOST) {
            setMeasuredDimension(widthSize, &lt;/span&gt;300&lt;span&gt;);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 最终效果如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/916005/201911/916005-20191124230044446-1792788445.png&quot; alt=&quot;&quot; width=&quot;357&quot; height=&quot;400&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以发现，我们设置的是 wrap_content，但是最后还是有尺寸的。&lt;/p&gt;
&lt;p&gt;整个过程大致如下，直接继承 View 时需要有几点注意：&lt;/p&gt;
&lt;div&gt;
&lt;div&gt;
&lt;ol readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;在 onDraw 当中对 padding 属性进行处理。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;在 onMeasure 过程中对 wrap_content 属性进行处理。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;至少要有一个构造方法。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div readability=&quot;19.932552061378&quot;&gt;
&lt;div readability=&quot;59.278129952456&quot;&gt;

&lt;p&gt;自定义 ViewGroup 的过程相对复杂一些，因为除了要对自身的大小和位置进行测量之外，还需要对子 View 的测量参数负责。&lt;/p&gt;
&lt;h2&gt;需求实例&lt;/h2&gt;
&lt;p&gt;实现一个类似于 Viewpager 的可左右滑动的布局。&lt;/p&gt;
&lt;p&gt;布局文件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;LinearLayout &lt;/span&gt;&lt;span&gt;xmlns:android&lt;/span&gt;&lt;span&gt;=&quot;http://schemas.android.com/apk/res/android&quot;&lt;/span&gt;&lt;span&gt;
    xmlns:app&lt;/span&gt;&lt;span&gt;=&quot;http://schemas.android.com/apk/res-auto&quot;&lt;/span&gt;&lt;span&gt;
    xmlns:tools&lt;/span&gt;&lt;span&gt;=&quot;http://schemas.android.com/tools&quot;&lt;/span&gt;&lt;span&gt;
    android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;match_parent&quot;&lt;/span&gt;&lt;span&gt;
    android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;match_parent&quot;&lt;/span&gt;&lt;span&gt;
    android:orientation&lt;/span&gt;&lt;span&gt;=&quot;vertical&quot;&lt;/span&gt;&lt;span&gt;
    tools:context&lt;/span&gt;&lt;span&gt;=&quot;.MainActivity&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;com.example.myapplication.MyHorizonView
        &lt;/span&gt;&lt;span&gt;android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;wrap_content&quot;&lt;/span&gt;&lt;span&gt;
        android:background&lt;/span&gt;&lt;span&gt;=&quot;@color/colorAccent&quot;&lt;/span&gt;&lt;span&gt;
        android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;400dp&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ListView
            &lt;/span&gt;&lt;span&gt;android:id&lt;/span&gt;&lt;span&gt;=&quot;@+id/list1&quot;&lt;/span&gt;&lt;span&gt;
            android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;match_parent&quot;&lt;/span&gt;&lt;span&gt;
            android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;match_parent&quot;&lt;/span&gt;&lt;span&gt;
            android:background&lt;/span&gt;&lt;span&gt;=&quot;@color/colorAccent&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;

        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ListView
            &lt;/span&gt;&lt;span&gt;android:id&lt;/span&gt;&lt;span&gt;=&quot;@+id/list2&quot;&lt;/span&gt;&lt;span&gt;
            android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;match_parent&quot;&lt;/span&gt;&lt;span&gt;
            android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;match_parent&quot;&lt;/span&gt;&lt;span&gt;
            android:background&lt;/span&gt;&lt;span&gt;=&quot;@color/colorPrimary&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;

        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ListView
            &lt;/span&gt;&lt;span&gt;android:id&lt;/span&gt;&lt;span&gt;=&quot;@+id/list3&quot;&lt;/span&gt;&lt;span&gt;
            android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;match_parent&quot;&lt;/span&gt;&lt;span&gt;
            android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;match_parent&quot;&lt;/span&gt;&lt;span&gt;
            android:background&lt;/span&gt;&lt;span&gt;=&quot;@color/colorPrimaryDark&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;com.example.myapplication.MyHorizonView&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TextView
        &lt;/span&gt;&lt;span&gt;android:id&lt;/span&gt;&lt;span&gt;=&quot;@+id/text&quot;&lt;/span&gt;&lt;span&gt;
        android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;100dp&quot;&lt;/span&gt;&lt;span&gt;
        android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;100dp&quot;&lt;/span&gt;&lt;span&gt;
        android:clickable&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;&lt;span&gt;
        android:focusable&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;&lt;span&gt;
        android:text&lt;/span&gt;&lt;span&gt;=&quot;trsfnjsfksjfnjsdfjksdhfjksdjkfhdsfsdddddddddddddddddddddddddd&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;com.example.myapplication.MyTextView
        &lt;/span&gt;&lt;span&gt;android:id&lt;/span&gt;&lt;span&gt;=&quot;@+id/myview&quot;&lt;/span&gt;&lt;span&gt;
        android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;1dp&quot;&lt;/span&gt;&lt;span&gt;
        android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;2dp&quot;&lt;/span&gt;&lt;span&gt;
        android:clickable&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;&lt;span&gt;
        android:enabled&lt;/span&gt;&lt;span&gt;=&quot;false&quot;&lt;/span&gt;&lt;span&gt;
        android:focusable&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;&lt;span&gt;
        app:testAttr&lt;/span&gt;&lt;span&gt;=&quot;520&quot;&lt;/span&gt;&lt;span&gt;
        app:text&lt;/span&gt;&lt;span&gt;=&quot;helloWorld&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;com.example.myapplication.RectView
        &lt;/span&gt;&lt;span&gt;android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;wrap_content&quot;&lt;/span&gt;&lt;span&gt;
        android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;wrap_content&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;com.example.myapplication.MyView1
        &lt;/span&gt;&lt;span&gt;android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;wrap_content&quot;&lt;/span&gt;&lt;span&gt;
        android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;wrap_content&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;com.example.myapplication.DividingLineTextView
        &lt;/span&gt;&lt;span&gt;android:id&lt;/span&gt;&lt;span&gt;=&quot;@+id/divide&quot;&lt;/span&gt;&lt;span&gt;
        android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;match_parent&quot;&lt;/span&gt;&lt;span&gt;
        android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;wrap_content&quot;&lt;/span&gt;&lt;span&gt;
        android:gravity&lt;/span&gt;&lt;span&gt;=&quot;center&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;


&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;LinearLayout&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;一个 ViewGroup 里面放入 3 个 ListView，注意 ViewGroup 设置的宽是 wrap_content。所以它的宽度是跟父 View 保持一致的。对于子 View&lt;/p&gt;
&lt;p&gt;代码比较多，我们结合注释分析。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MyHorizonView &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; ViewGroup {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String TAG = &quot;HorizontaiView&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; List&amp;lt;View&amp;gt; mMatchedChildrenList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();


    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; MyHorizonView(Context context) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(context);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; MyHorizonView(Context context, AttributeSet attributes) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(context, attributes);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; MyHorizonView(Context context, AttributeSet attributes, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; defStyleAttr) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(context, attributes, defStyleAttr);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; onLayout(&lt;span&gt;boolean&lt;/span&gt; changed, &lt;span&gt;int&lt;/span&gt; l, &lt;span&gt;int&lt;/span&gt; t, &lt;span&gt;int&lt;/span&gt; r, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; b) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; childCount =&lt;span&gt; getChildCount();
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; left = 0&lt;span&gt;;
        View child;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; childCount; i++&lt;span&gt;) {
            child &lt;/span&gt;=&lt;span&gt; getChildAt(i);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (child.getVisibility() !=&lt;span&gt; View.GONE) {
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; childWidth =&lt;span&gt; child.getMeasuredWidth();
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 因为是水平滑动的，所以以宽度来适配&lt;/span&gt;
                child.layout(left, 0, left +&lt;span&gt; childWidth, child.getMeasuredHeight());
                left &lt;/span&gt;+=&lt;span&gt; childWidth;
            }
        }
    }

    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; onMeasure(&lt;span&gt;int&lt;/span&gt; widthMeasureSpec, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; heightMeasureSpec) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.onMeasure(widthMeasureSpec, heightMeasureSpec);
        mMatchedChildrenList.clear();
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; widthSpecMode =&lt;span&gt; MeasureSpec.getMode(widthMeasureSpec);
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; widthSpecSize =&lt;span&gt; MeasureSpec.getSize(widthMeasureSpec);
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; heightSpecMode =&lt;span&gt; MeasureSpec.getMode(heightMeasureSpec);
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; heightSpecSize =&lt;span&gt; MeasureSpec.getSize(heightMeasureSpec);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果不是确定的的值，说明是 AT_MOST,与父 View 同宽高&lt;/span&gt;
        &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; measureMatchParentChildren = heightSpecMode != MeasureSpec.EXACTLY ||&lt;span&gt;
                widthSpecMode &lt;/span&gt;!=&lt;span&gt; MeasureSpec.EXACTLY;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; childCount =&lt;span&gt; getChildCount();
        View child;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; childCount; i++&lt;span&gt;) {
            child &lt;/span&gt;=&lt;span&gt; getChildAt(i);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (child.getVisibility() !=&lt;span&gt; View.GONE) {
                &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; LayoutParams layoutParams =&lt;span&gt; child.getLayoutParams();
                measureChild(child, widthMeasureSpec, heightMeasureSpec);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (measureMatchParentChildren) {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 需要先计算出父 View 的高度来再来测量子 view&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; (layoutParams.width ==&lt;span&gt; LayoutParams.MATCH_PARENT
                            &lt;/span&gt;|| layoutParams.height ==&lt;span&gt; LayoutParams.MATCH_PARENT) {
                        mMatchedChildrenList.add(child);
                    }
                }
            }
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (widthSpecMode == MeasureSpec.AT_MOST &amp;amp;&amp;amp; heightSpecMode ==&lt;span&gt; MeasureSpec.AT_MOST) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果宽高都是AT_MOST的话，即都是wrap_content布局模式，就用View自己想要的宽高值&lt;/span&gt;
&lt;span&gt;            setMeasuredDimension(getMeasuredWidth(), getMeasuredHeight());
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (widthSpecMode ==&lt;span&gt; MeasureSpec.AT_MOST) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果只有宽度都是AT_MOST的话，即只有宽度是wrap_content布局模式，宽度就用View自己想要的宽度值，高度就用父ViewGroup指定的高度值&lt;/span&gt;
&lt;span&gt;            setMeasuredDimension(getMeasuredWidth(), heightSpecSize);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (heightSpecMode ==&lt;span&gt; MeasureSpec.AT_MOST) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果只有高度都是AT_MOST的话，即只有高度是wrap_content布局模式，高度就用View自己想要的宽度值，宽度就用父ViewGroup指定的高度值&lt;/span&gt;
&lt;span&gt;            setMeasuredDimension(widthSpecSize, getMeasuredHeight());
        }

        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; mMatchedChildrenList.size(); i++&lt;span&gt;) {
            View matchChild &lt;/span&gt;=&lt;span&gt; getChildAt(i);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (matchChild.getVisibility() !=&lt;span&gt; View.GONE) {
                &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; LayoutParams layoutParams =&lt;span&gt; matchChild.getLayoutParams();
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 计算子 View 宽的 MeasureSpec&lt;/span&gt;
                &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; childWidthMeasureSpec;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (layoutParams.width ==&lt;span&gt; LayoutParams.MATCH_PARENT) {
                    childWidthMeasureSpec &lt;/span&gt;=&lt;span&gt; MeasureSpec.makeMeasureSpec(getMeasuredWidth(), MeasureSpec.EXACTLY);
                } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    childWidthMeasureSpec &lt;/span&gt;= getChildMeasureSpec(widthMeasureSpec, 0&lt;span&gt;, layoutParams.width);
                }
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 计算子 View 高的 MeasureSpec&lt;/span&gt;
                &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; childHeightMeasureSpec;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (layoutParams.height ==&lt;span&gt; LayoutParams.MATCH_PARENT) {
                    childHeightMeasureSpec &lt;/span&gt;=&lt;span&gt; MeasureSpec.makeMeasureSpec(getMeasuredHeight(), MeasureSpec.EXACTLY);
                } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    childHeightMeasureSpec &lt;/span&gt;= getChildMeasureSpec(widthMeasureSpec, 0&lt;span&gt;, layoutParams.height);
                }
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根据 MeasureSpec 计算自己的宽高&lt;/span&gt;
&lt;span&gt;                matchChild.measure(childWidthMeasureSpec, childHeightMeasureSpec);
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里我们只是重写了两个绘制过程中的重要的方法：onMeasure 和 onLayout 方法。&lt;/p&gt;
&lt;p&gt;对于 onMeasure 方法具体逻辑如下：&lt;/p&gt;
&lt;ol readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;super.onMeasure 会先计算自定义 view 的大小；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;span&gt;调用 measureChild 对 子 View 进行测量；&lt;/span&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;自定义 view 设置的宽高参数不是 MeasureSpec.EXACTLY 的话，对于子 View 是 match_parent 需要额外处理，同时也需要对 MeasureSpec.AT_MOST 情况进行额外处理。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt; 当自定义View 的大小确定后，在对子 View 是 match_parent 重新测量；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;上述的测量过程的代码也是参考 FrameLayout 源码的，具体可以参看文章：&lt;/p&gt;
&lt;p&gt;对于 onLayout 方法，因为是水平滑动的，所以要根据宽度来进行layout。&lt;/p&gt;
&lt;p&gt;到这里我们的 View 布局就已经基本结束了。但是要实现 &lt;code&gt;Viewpager &lt;/code&gt;的效果，还需要添加对事件的处理。事件的处理流程之前我们有分析过，在制作自定义 View 的时候也是会经常用到的，不了解的可以参考文章 &lt;a href=&quot;https://www.jianshu.com/p/bc4c9e5f4b1c&quot; target=&quot;_blank&quot;&gt;Android Touch事件分发超详细解析&lt;/a&gt;。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; init(Context context) {
        mScroller &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Scroller(context);
        mTracker &lt;/span&gt;=&lt;span&gt; VelocityTracker.obtain();
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 因为我们定义的是ViewGroup，从onInterceptTouchEvent开始。
     * 重写onInterceptTouchEvent,对横向滑动事件进行拦截
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; event
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; onInterceptTouchEvent(MotionEvent event) {
        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; intercepted = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; x = (&lt;span&gt;int&lt;/span&gt;&lt;span&gt;) event.getX();
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; y = (&lt;span&gt;int&lt;/span&gt;&lt;span&gt;) event.getY();
        &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (event.getAction()) {
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; MotionEvent.ACTION_DOWN:
                intercepted &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;必须不能拦截，否则后续的ACTION_MOME和ACTION_UP事件都会拦截。&lt;/span&gt;
                &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; MotionEvent.ACTION_MOVE:
                intercepted &lt;/span&gt;= Math.abs(x - mLastX) &amp;gt; Math.abs(y -&lt;span&gt; mLastY);
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        }
        Log.d(TAG, &lt;/span&gt;&quot;onInterceptTouchEvent: intercepted &quot; +&lt;span&gt; intercepted);
        mLastX &lt;/span&gt;=&lt;span&gt; x;
        mLastY &lt;/span&gt;=&lt;span&gt; y;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; intercepted ? intercepted : &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.onInterceptHoverEvent(event);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 当ViewGroup拦截下用户的横向滑动事件以后，后续的Touch事件将交付给`onTouchEvent`进行处理。
     * 重写onTouchEvent方法
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; onTouchEvent(MotionEvent event) {
        mTracker.addMovement(event);
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; x = (&lt;span&gt;int&lt;/span&gt;&lt;span&gt;) event.getX();
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; y = (&lt;span&gt;int&lt;/span&gt;&lt;span&gt;) event.getY();
        &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (event.getAction()) {
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; MotionEvent.ACTION_DOWN:
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; MotionEvent.ACTION_MOVE:
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; deltaX = x -&lt;span&gt; mLastX;
                Log.d(TAG, &lt;/span&gt;&quot;onTouchEvent: deltaX &quot; +&lt;span&gt; deltaX);

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; scrollBy 方法将对我们当前 View 的位置进行偏移&lt;/span&gt;
                scrollBy(-deltaX, 0&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; MotionEvent.ACTION_UP:
                Log.d(TAG, &lt;/span&gt;&quot;onTouchEvent: &quot; +&lt;span&gt; getScrollX());
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; getScrollX()为在X轴方向发生的便宜，mChildWidth * currentIndex表示当前View在滑动开始之前的X坐标
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; distance存储的就是此次滑动的距离&lt;/span&gt;
                &lt;span&gt;int&lt;/span&gt; distance = getScrollX() - mChildWidth *&lt;span&gt; mCurrentIndex;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当本次滑动距离&amp;gt;View宽度的1/2时，切换View&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (Math.abs(distance) &amp;gt; mChildWidth / 2&lt;span&gt;) {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (distance &amp;gt; 0&lt;span&gt;) {
                        mCurrentIndex&lt;/span&gt;++&lt;span&gt;;
                    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                        mCurrentIndex&lt;/span&gt;--&lt;span&gt;;
                    }
                } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取X轴加速度，units为单位，默认为像素，这里为每秒1000个像素点&lt;/span&gt;
                    mTracker.computeCurrentVelocity(1000&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;float&lt;/span&gt; xV =&lt;span&gt; mTracker.getXVelocity();
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当X轴加速度&amp;gt;50时，也就是产生了快速滑动，也会切换View&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; (Math.abs(xV) &amp;gt; 50&lt;span&gt;) {
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (xV &amp;lt; 0&lt;span&gt;) {
                            mCurrentIndex&lt;/span&gt;++&lt;span&gt;;
                        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                            mCurrentIndex&lt;/span&gt;--&lt;span&gt;;
                        }
                    }
                }

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;对currentIndex做出限制其范围为【0，getChildCount() - 1】&lt;/span&gt;
                mCurrentIndex = mCurrentIndex &amp;lt; 0 ? 0 : mCurrentIndex &amp;gt; getChildCount() - 1 ? getChildCount() - 1&lt;span&gt; : mCurrentIndex;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;滑动到下一个View&lt;/span&gt;
                smoothScrollTo(mCurrentIndex * mChildWidth, 0&lt;span&gt;);
                mTracker.clear();

                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        }

        Log.d(TAG, &lt;/span&gt;&quot;onTouchEvent: &quot;&lt;span&gt;);
        mLastX &lt;/span&gt;=&lt;span&gt; x;
        mLastY &lt;/span&gt;=&lt;span&gt; y;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.onTouchEvent(event);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; dispatchTouchEvent(MotionEvent ev) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.dispatchTouchEvent(ev);
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; smoothScrollTo(&lt;span&gt;int&lt;/span&gt; destX, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; destY) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; startScroll方法将产生一系列偏移量，从（getScrollX(), getScrollY()），destX - getScrollX()和destY - getScrollY()为移动的距离&lt;/span&gt;
        mScroller.startScroll(getScrollX(), getScrollY(), destX - getScrollX(), destY - getScrollY(), 1000&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; invalidate方法会重绘View，也就是调用View的onDraw方法，而onDraw又会调用computeScroll()方法&lt;/span&gt;
&lt;span&gt;        invalidate();
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 重写computeScroll方法&lt;/span&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; computeScroll() {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.computeScroll();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当scroller.computeScrollOffset()=true时表示滑动没有结束&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (mScroller.computeScrollOffset()) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用scrollTo方法进行滑动，滑动到scroller当中计算到的滑动位置&lt;/span&gt;
&lt;span&gt;            scrollTo(mScroller.getCurrX(), mScroller.getCurrY());
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 没有滑动结束，继续刷新View&lt;/span&gt;
&lt;span&gt;            postInvalidate();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;具体效果如下图所示：&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;12.5&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/916005/201911/916005-20191124231508572-1988611737.gif&quot; alt=&quot;&quot;/&gt;&lt;p&gt;&lt;strong&gt;对于 Scroller 的用法总结如下：&lt;/strong&gt;&lt;/p&gt;
&lt;div readability=&quot;12&quot;&gt;
&lt;ol readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;调用 Scroller 的 startScroll() 方法来进行一些滚动的初始化设置，然后迫使 View 进行绘制 (调用 View 的 invalidate() 或 postInvalidate() 就可以重新绘制 View)；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;绘制 View 的时候 drawchild 方法会调用 computeScroll() 方法，重写 computeScroll()，通过 Scroller 的 computeScrollOffset() 方法来判断滚动有没有结束；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;scrollTo() 方法虽然会重新绘制 View，但还是要调用下 invalidate() 或者 postInvalidate() 来触发界面重绘，重新绘制 View 又触发 computeScroll()；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;如此往复进入一个循环阶段，即可达到平滑滚动的效果；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;也许有人会问，干嘛还要调用来调用去最后在调用 scrollTo() 方法，还不如直接调用 scrollTo() 方法来实现滚动，其实直接调用是可以，只不过 scrollTo() 是瞬间滚动的，给人的用户体验不太好，所以 Android 提供了 Scroller 类实现平滑滚动的效果。&lt;/p&gt;
&lt;p&gt;为了方面大家理解，我画了一个简单的调用示意图：&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/916005/201912/916005-20191211171821600-1181713706.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;到此，自定义 view 的方法就讲完了。希望对大家有用。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;参考文献：&lt;/p&gt;
&lt;p&gt;1、&lt;a href=&quot;https://www.jianshu.com/p/705a6cb6bfee&quot; target=&quot;_blank&quot;&gt;Android自定义View全解&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 11 Dec 2019 16:39:00 +0000</pubDate>
<dc:creator>huansky</dc:creator>
<og:description>View 的绘制系列文章： Android View 绘制流程之 DecorView 与 ViewRootImpl Android View 的绘制流程之 Measure 过程详解 (一) Andro</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/huansky/p/11808234.html</dc:identifier>
</item>
<item>
<title>Spring源码学习笔记之bean标签属性介绍及作用 - 城序猿</title>
<link>http://www.cnblogs.com/cheng21553516/p/12026652.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cheng21553516/p/12026652.html</guid>
<description>&lt;pre readability=&quot;5&quot;&gt;
 传统的Spring项目, xml 配置bean在代码中是经常遇到, 那么在配置bean的时候,这些属性的作用是什么呢? &lt;br/&gt;虽然说现在boot项目兴起,基于xml配置的少了很多, 但是如果能够了解这些标签的作用对于我们基于注解的配置也有大有益处的.&lt;p&gt;首先附上测试部分涉及到的类的代码:
&lt;/p&gt;&lt;/pre&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
@Data
public class Student {

    private int age;

    private  String name = &quot;test&quot; ;

    private int sex;
}
&lt;/pre&gt;&lt;/div&gt;

&lt;pre&gt;
&lt;strong&gt;1&lt;/strong&gt;. &lt;strong&gt;id&lt;/strong&gt;:Bean的唯一标识名。它必须是合法的XMLID，在整个XML文档中唯一。&lt;br/&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1213093/201912/1213093-20191211230152291-1189805926.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;pre&gt;
2. &lt;strong&gt;name&lt;/strong&gt;:用来为id创建一个或多个别名。它可以是任意的字母符合。多个别名之间用逗号, 分号 或者空格。
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1213093/201912/1213093-20191211231011598-1138975613.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 其中bean标签解析源码部分处理代码如下:&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    public&lt;span&gt; BeanDefinitionHolder parseBeanDefinitionElement(Element ele, @Nullable BeanDefinition containingBean) {&lt;/span&gt;&lt;br/&gt;String id &lt;/span&gt;=&lt;span&gt; ele.getAttribute(ID_ATTRIBUTE);
        String nameAttr &lt;/span&gt;=&lt;span&gt; ele.getAttribute(NAME_ATTRIBUTE);
        &lt;br/&gt;&lt;strong&gt;//解析nanme 属性,&lt;br/&gt;// 其中  public static final String MULTI_VALUE_ATTRIBUTE_DELIMITERS = &quot;,; &quot;;&lt;br/&gt;// 我们可以发现name属性的分割符是支持三种的&lt;br/&gt;&lt;/strong&gt;
        List&lt;/span&gt;&amp;lt;String&amp;gt; aliases = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (StringUtils.hasLength(nameAttr)) {&lt;br/&gt;// 使用分割符分割为数组, 作为这个bean的别名
            String[] nameArr &lt;/span&gt;=&lt;span&gt; StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);
            aliases.addAll(Arrays.asList(nameArr));
        }

        String beanName &lt;/span&gt;=&lt;span&gt; id;&lt;br/&gt;// 如果id 属性为空,则讲第一个别名作为bean的名称
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!StringUtils.hasText(beanName) &amp;amp;&amp;amp; !&lt;span&gt;aliases.isEmpty()) {
            beanName &lt;/span&gt;= aliases.remove(0&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (logger.isTraceEnabled()) {
                logger.trace(&lt;/span&gt;&quot;No XML 'id' specified - using '&quot; + beanName +
                        &quot;' as bean name and &quot; + aliases + &quot; as aliases&quot;&lt;span&gt;);
            }
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (containingBean == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            checkNameUniqueness(beanName, aliases, ele);
        }

        AbstractBeanDefinition beanDefinition &lt;/span&gt;=&lt;span&gt; parseBeanDefinitionElement(ele, beanName, containingBean);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (beanDefinition != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;StringUtils.hasText(beanName)) {
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (containingBean != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                        beanName &lt;/span&gt;=&lt;span&gt; BeanDefinitionReaderUtils.generateBeanName(
                                beanDefinition, &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.readerContext.getRegistry(), &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
                    }
                    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                        beanName &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.readerContext.generateBeanName(beanDefinition);
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Register an alias for the plain bean class name, if still possible,
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; if the generator returned the class name plus a suffix.
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; This is expected for Spring 1.2/2.0 backwards compatibility.&lt;/span&gt;
                        String beanClassName =&lt;span&gt; beanDefinition.getBeanClassName();
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (beanClassName != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt;
                                beanName.startsWith(beanClassName) &lt;/span&gt;&amp;amp;&amp;amp; beanName.length() &amp;gt; beanClassName.length() &amp;amp;&amp;amp;
                                !&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.readerContext.getRegistry().isBeanNameInUse(beanClassName)) {
                            aliases.add(beanClassName);
                        }
                    }
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (logger.isTraceEnabled()) {
                        logger.trace(&lt;/span&gt;&quot;Neither XML 'id' nor 'name' specified - &quot; +
                                &quot;using generated bean name [&quot; + beanName + &quot;]&quot;&lt;span&gt;);
                    }
                }
                &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex) {
                    error(ex.getMessage(), ele);
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                }
            }
            String[] aliasesArray &lt;/span&gt;=&lt;span&gt; StringUtils.toStringArray(aliases);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);
        }

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre readability=&quot;13&quot;&gt;
&lt;p&gt;3. &lt;strong&gt;class&lt;/strong&gt;:用来定义类的全限定名（包名＋类名）。用来指定我们要实例化的类的全限定名&lt;/p&gt;&lt;p&gt;4. parent:子类Bean定义它所引用它的父类Bean。子类Bean会继承父类Bean的所有属性，子类Bean也可以覆盖父类Bean的属性。&lt;br/&gt;此时父类通过property 属性只能初始化子类同有的属性&lt;/p&gt;&lt;p&gt;5. abstract（默认为”false”）：用来定义Bean是否为抽象Bean。它表示这个Bean将不会被实例化，一般用于父类Bean，因为父类Bean主要是供子类Bean继承使用。&lt;/p&gt;&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&amp;lt;bean id=&quot;parent&quot; class=&quot;com.cbl.spring.model.Parent&quot; abstract=&quot;true&quot;&amp;gt;&lt;br/&gt;&amp;lt;property name=&quot;username&quot; value=&quot;parent name&quot;/&amp;gt;&lt;br/&gt;&amp;lt;!--        &amp;lt;property name=&quot;parent&quot; value=&quot;parent &quot;/&amp;gt;--&amp;gt;&lt;br/&gt;&amp;lt;/bean&amp;gt;&lt;br/&gt;// 这里abstract设置为了 true ,这个parentbean不会被实例化, 一下代码会报错
&lt;/pre&gt;
&lt;pre&gt;
Parent parent = applicationContext.getBean(Parent.&lt;span&gt;class&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;br/&gt;属性解析部分源代码:
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; AbstractBeanDefinition parseBeanDefinitionAttributes(Element ele, String beanName,
            @Nullable BeanDefinition containingBean, AbstractBeanDefinition bd) {
          &lt;br/&gt;// &lt;strong&gt;singleton 属性新版本不再有起任何作用, 1.x 的老版本中有使用到, 新版本使用scope 属性
        &lt;/strong&gt;&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (ele.hasAttribute(SINGLETON_ATTRIBUTE)) {
            error(&lt;/span&gt;&quot;Old 1.x 'singleton' attribute in use - upgrade to 'scope' declaration&quot;&lt;span&gt;, ele);
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (ele.hasAttribute(SCOPE_ATTRIBUTE)) {
            bd.setScope(ele.getAttribute(SCOPE_ATTRIBUTE));
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (containingBean != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Take default from containing bean in case of an inner bean definition.&lt;/span&gt;
&lt;span&gt;            bd.setScope(containingBean.getScope());
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (ele.hasAttribute(ABSTRACT_ATTRIBUTE)) {
            bd.setAbstract(TRUE_VALUE.equals(ele.getAttribute(ABSTRACT_ATTRIBUTE)));
        }

        String lazyInit &lt;/span&gt;=&lt;span&gt; ele.getAttribute(LAZY_INIT_ATTRIBUTE);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (DEFAULT_VALUE.equals(lazyInit)) {
            lazyInit &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.defaults.getLazyInit();
        }
        bd.setLazyInit(TRUE_VALUE.equals(lazyInit));

        String autowire &lt;/span&gt;=&lt;span&gt; ele.getAttribute(AUTOWIRE_ATTRIBUTE);
        bd.setAutowireMode(getAutowireMode(autowire));

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (ele.hasAttribute(DEPENDS_ON_ATTRIBUTE)) {
            String dependsOn &lt;/span&gt;=&lt;span&gt; ele.getAttribute(DEPENDS_ON_ATTRIBUTE);
            bd.setDependsOn(StringUtils.tokenizeToStringArray(dependsOn, MULTI_VALUE_ATTRIBUTE_DELIMITERS));
        }

        String autowireCandidate &lt;/span&gt;=&lt;span&gt; ele.getAttribute(AUTOWIRE_CANDIDATE_ATTRIBUTE);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&quot;&quot;.equals(autowireCandidate) ||&lt;span&gt; DEFAULT_VALUE.equals(autowireCandidate)) {
            String candidatePattern &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.defaults.getAutowireCandidates();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (candidatePattern != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                String[] patterns &lt;/span&gt;=&lt;span&gt; StringUtils.commaDelimitedListToStringArray(candidatePattern);
                bd.setAutowireCandidate(PatternMatchUtils.simpleMatch(patterns, beanName));
            }
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            bd.setAutowireCandidate(TRUE_VALUE.equals(autowireCandidate));
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (ele.hasAttribute(PRIMARY_ATTRIBUTE)) {
            bd.setPrimary(TRUE_VALUE.equals(ele.getAttribute(PRIMARY_ATTRIBUTE)));
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (ele.hasAttribute(INIT_METHOD_ATTRIBUTE)) {
            String initMethodName &lt;/span&gt;=&lt;span&gt; ele.getAttribute(INIT_METHOD_ATTRIBUTE);
            bd.setInitMethodName(initMethodName);
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.defaults.getInitMethod() != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            bd.setInitMethodName(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.defaults.getInitMethod());
            bd.setEnforceInitMethod(&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (ele.hasAttribute(DESTROY_METHOD_ATTRIBUTE)) {
            String destroyMethodName &lt;/span&gt;=&lt;span&gt; ele.getAttribute(DESTROY_METHOD_ATTRIBUTE);
            bd.setDestroyMethodName(destroyMethodName);
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.defaults.getDestroyMethod() != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            bd.setDestroyMethodName(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.defaults.getDestroyMethod());
            bd.setEnforceDestroyMethod(&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (ele.hasAttribute(FACTORY_METHOD_ATTRIBUTE)) {
            bd.setFactoryMethodName(ele.getAttribute(FACTORY_METHOD_ATTRIBUTE));
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (ele.hasAttribute(FACTORY_BEAN_ATTRIBUTE)) {
            bd.setFactoryBeanName(ele.getAttribute(FACTORY_BEAN_ATTRIBUTE));
        }

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; bd;
    }&lt;/span&gt;&lt;span&gt;&lt;strong&gt;//beanDifinition 的部分属性默认值定义&lt;/strong&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;em id=&quot;__mceDel&quot;&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; AbstractBeanDefinition &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; BeanMetadataAttributeAccessor
        &lt;/span&gt;&lt;span&gt;implements&lt;/span&gt;&lt;span&gt; BeanDefinition, Cloneable {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Constant for the default scope name: {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; &quot;&quot;}, equivalent to singleton
     * status unless overridden from a parent bean definition (if applicable).
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;     // 默认值是空,等同于singleton ,除非被父类给覆盖,也就是说默认值时 singleton
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String SCOPE_DEFAULT = &quot;&quot;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Constant that indicates no autowiring at all.
     * &lt;/span&gt;&lt;span&gt;@see&lt;/span&gt;&lt;span&gt; #setAutowireMode
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; AUTOWIRE_NO =&lt;span&gt; AutowireCapableBeanFactory.AUTOWIRE_NO;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Constant that indicates autowiring bean properties by name.
     * &lt;/span&gt;&lt;span&gt;@see&lt;/span&gt;&lt;span&gt; #setAutowireMode
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; AUTOWIRE_BY_NAME =&lt;span&gt; AutowireCapableBeanFactory.AUTOWIRE_BY_NAME;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Constant that indicates autowiring bean properties by type.
     * &lt;/span&gt;&lt;span&gt;@see&lt;/span&gt;&lt;span&gt; #setAutowireMode
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; AUTOWIRE_BY_TYPE =&lt;span&gt; AutowireCapableBeanFactory.AUTOWIRE_BY_TYPE;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Constant that indicates autowiring a constructor.
     * &lt;/span&gt;&lt;span&gt;@see&lt;/span&gt;&lt;span&gt; #setAutowireMode
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; AUTOWIRE_CONSTRUCTOR =&lt;span&gt; AutowireCapableBeanFactory.AUTOWIRE_CONSTRUCTOR;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Constant that indicates determining an appropriate autowire strategy
     * through introspection of the bean class.
     * &lt;/span&gt;&lt;span&gt;@see&lt;/span&gt;&lt;span&gt; #setAutowireMode
     * &lt;/span&gt;&lt;span&gt;@deprecated&lt;/span&gt;&lt;span&gt; as of Spring 3.0: If you are using mixed autowiring strategies,
     * use annotation-based autowiring for clearer demarcation of autowiring needs.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Deprecated
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; AUTOWIRE_AUTODETECT =&lt;span&gt; AutowireCapableBeanFactory.AUTOWIRE_AUTODETECT;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Constant that indicates no dependency check at all.
     * &lt;/span&gt;&lt;span&gt;@see&lt;/span&gt;&lt;span&gt; #setDependencyCheck
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; DEPENDENCY_CHECK_NONE = 0&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Constant that indicates dependency checking for object references.
     * &lt;/span&gt;&lt;span&gt;@see&lt;/span&gt;&lt;span&gt; #setDependencyCheck
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; DEPENDENCY_CHECK_OBJECTS = 1&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Constant that indicates dependency checking for &quot;simple&quot; properties.
     * &lt;/span&gt;&lt;span&gt;@see&lt;/span&gt;&lt;span&gt; #setDependencyCheck
     * &lt;/span&gt;&lt;span&gt;@see&lt;/span&gt;&lt;span&gt; org.springframework.beans.BeanUtils#isSimpleProperty
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; DEPENDENCY_CHECK_SIMPLE = 2&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Constant that indicates dependency checking for all properties
     * (object references as well as &quot;simple&quot; properties).
     * &lt;/span&gt;&lt;span&gt;@see&lt;/span&gt;&lt;span&gt; #setDependencyCheck
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; DEPENDENCY_CHECK_ALL = 3&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Constant that indicates the container should attempt to infer the
     * {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; #setDestroyMethodName destroy method name} for a bean as opposed to
     * explicit specification of a method name. The value {&lt;/span&gt;&lt;span&gt;@value&lt;/span&gt;&lt;span&gt;} is specifically
     * designed to include characters otherwise illegal in a method name, ensuring
     * no possibility of collisions with legitimately named methods having the same
     * name.
     * &amp;lt;p&amp;gt;Currently, the method names detected during destroy method inference
     * are &quot;close&quot; and &quot;shutdown&quot;, if present on the specific bean class.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String INFER_METHOD = &quot;(inferred)&quot;&lt;span&gt;;


    @Nullable
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt;&lt;span&gt; Object beanClass;

    @Nullable
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; String scope =&lt;span&gt; SCOPE_DEFAULT;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; abstractFlag = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;br/&gt;// 懒加载的默认值时false
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; lazyInit = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; autowireMode =&lt;span&gt; AUTOWIRE_NO;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; dependencyCheck =&lt;span&gt; DEPENDENCY_CHECK_NONE;

    @Nullable
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String[] dependsOn;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; autowireCandidate = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; primary = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Map&amp;lt;String, AutowireCandidateQualifier&amp;gt; qualifiers = &lt;span&gt;new&lt;/span&gt; LinkedHashMap&amp;lt;&amp;gt;&lt;span&gt;();

    @Nullable
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Supplier&amp;lt;?&amp;gt;&lt;span&gt; instanceSupplier;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; nonPublicAccessAllowed = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; lenientConstructorResolution = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;

    @Nullable
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String factoryBeanName;

    @Nullable
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String factoryMethodName;

    @Nullable
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; ConstructorArgumentValues constructorArgumentValues;

    @Nullable
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; MutablePropertyValues propertyValues;

    @Nullable
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; MethodOverrides methodOverrides;

    @Nullable
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String initMethodName;

    @Nullable
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String destroyMethodName;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; enforceInitMethod = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; enforceDestroyMethod = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; synthetic = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;&lt;/em&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre readability=&quot;5&quot;&gt;
&lt;p&gt;6. singleton（默认为“true”）：定义Bean是否是Singleton（单例）。
&lt;/p&gt;&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;singleton 属性新版本不再有起任何作用, 1.x 的老版本中有使用到, 新版本使用scope 属性&lt;/span&gt;
&lt;/pre&gt;
&lt;pre readability=&quot;11&quot;&gt;
&lt;br/&gt;7.lazy-init（默认为“false”）：用来定义这个Bean是否实现懒初始化。如果为“false”，它将在BeanFactory启动时初始化所有的SingletonBean。反之，如果为“true”,它只在Bean请求时才开始创建SingletonBean。&lt;p&gt;默认创建的beandefinition 对象是 &lt;em&gt;GenericBeanDefinition, 而 &lt;/em&gt;GenericBeanDefinition 继承自 AbstractBeanDefinition ,那么我们的默认的一些属性必然就使用的这两个类中提供的默认值,从上面的部分成员变量的属性值可以看出,默认值为false
&lt;/p&gt;&lt;/pre&gt;
&lt;pre readability=&quot;14&quot;&gt;
&lt;br/&gt;8、autowire（自动装配，默认为“default”）：它定义了Bean的自动装载方式。&lt;p&gt;8.1、“no”:不使用自动装配功能。&lt;/p&gt;&lt;p&gt;8.2、“byName”:通过Bean的属性名实现自动装配。&lt;/p&gt;&lt;p&gt;8.3、“byType”:通过Bean的类型实现自动装配。&lt;/p&gt;&lt;p&gt;8.4、“constructor”:类似于byType，但它是用于构造函数的参数的自动组装。&lt;/p&gt;&lt;p&gt;8.5、“autodetect”:通过Bean类的反省机制（introspection）决定是使用“constructor”  还是使用“byType”。
&lt;/p&gt;&lt;/pre&gt;
&lt;pre readability=&quot;31&quot;&gt;
&lt;br/&gt;9、dependency-check（依赖检查，默认为“default”）：它用来确保Bean组件通过JavaBean描述的所以依赖关系都得到满足。在与自动装配功能一起使用时，它特别有用。&lt;p&gt;9.1、none：不进行依赖检查。&lt;/p&gt;&lt;p&gt;9.2、objects：只做对象间依赖的检查。&lt;/p&gt;&lt;p&gt;9.3、simple：只做原始类型和String类型依赖的检查&lt;/p&gt;&lt;p&gt;9.4、all：对所有类型的依赖进行检查。它包括了前面的objects和simple。&lt;/p&gt;&lt;p&gt;10、depends-on（依赖对象）：这个Bean在初始化时依赖的对象，这个对象会在这个Bean初始化之前创建。&lt;/p&gt;&lt;p&gt;11、init-method:用来定义Bean的初始化方法，它会在Bean组装之后调用。它必须是一个无参数的方法。&lt;/p&gt;&lt;p&gt;12、destroy-method：用来定义Bean的销毁方法，它在BeanFactory关闭时调用。同样，它也必须是一个无参数的方法。它只能应用于singletonBean。&lt;/p&gt;&lt;p&gt;13、factory-method：定义创建该Bean对象的工厂方法。它用于下面的“factory-bean”，表示这个Bean是通过工厂方法创建。此时，“class”属性失效。&lt;/p&gt;&lt;p&gt;14、factory-bean:定义创建该Bean对象的工厂类。如果使用了“factory-bean”则“class”属性失效。&lt;/p&gt;&lt;p&gt;15、autowire-candidate：采用xml格式配置bean时，将&amp;lt;bean/&amp;gt;元素的autowire-candidate属性设置为false，这样容器在查找自动装配对象时，将不考虑该bean，即它不会被考虑作为其它bean自动装配的候选者，但是该bean本身还是可以使用自动装配来注入其它bean的。
&lt;/p&gt;&lt;/pre&gt;</description>
<pubDate>Wed, 11 Dec 2019 16:14:00 +0000</pubDate>
<dc:creator>城序猿</dc:creator>
<og:description>传统的Spring项目, xml 配置bean在代码中是经常遇到, 那么在配置bean的时候,这些属性的作用是什么呢? 虽然说现在boot项目兴起,基于xml配置的少了很多, 但是如果能够了解这些标签</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cheng21553516/p/12026652.html</dc:identifier>
</item>
<item>
<title>自然语言处理(NLP) - 数学基础(1) - 总述 - 叶伟民</title>
<link>http://www.cnblogs.com/adalovelacer/p/NLP-Math-1-summary.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/adalovelacer/p/NLP-Math-1-summary.html</guid>
<description>&lt;p&gt;正如我在&amp;lt;&lt;a href=&quot;https://www.cnblogs.com/adalovelacer/p/12020575.html&quot; target=&quot;_blank&quot;&gt;2019年总结&lt;/a&gt;&amp;gt;里说提到的, 我将开始一系列自然语言处理(NLP)的笔记.&lt;/p&gt;

&lt;p&gt;很多人都说, AI并不难啊, 调现有库和云的API就可以啦.&lt;/p&gt;

&lt;p&gt;然而实际上并不是这样的.&lt;/p&gt;
&lt;p&gt;首先, AI这个领域十分十分大, 而且从1950年图灵提出图灵测试, 1956年达特茅斯会议开始, AI已经发展了五十多年了, 学术界有的认为有&lt;a href=&quot;http://www.qstheory.cn/dukan/qs/2019-02/16/c_1124114625.htm&quot; target=&quot;_blank&quot;&gt;六个时期&lt;/a&gt;, 有的认为有&lt;a href=&quot;https://zhuanlan.zhihu.com/p/25774614&quot; target=&quot;_blank&quot;&gt;三起二落&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;所以Ai发展到今天, 已经有相当的规模了, 不可能有一个人熟悉AI的所有领域, 最多也就是熟悉相关联的几个领域, 比如NLP和OCR以及知识图谱相关联, 这已经顶天了.&lt;/p&gt;
&lt;p&gt;所以我不敢说我会AI, 我只敢说我做过自然语言处理(NLP)项目.&lt;/p&gt;
&lt;p&gt;换种我们所熟知的方式表达, AI就相当于.NET, .NET有七龙珠, 遍及web, 桌面, 移动端, 手游端等等, 一个人不可能熟悉所有领域, 能够熟悉web和桌面端两三个领域已经很顶天了.&lt;/p&gt;
&lt;p&gt;当一个做惯了web和桌面端的程序员突然去做移动端和手游端, 因为缺乏对应领域的基础知识, 是不能马上上手的, 也是通不过面试的, 也就是为什么很少.NET程序员能够从web和桌面端转型做手游端一样. 最典型一个问题, 让一个做web的.NET程序员去做手游客户端的自动寻路功能, 并不容易, 并不是调API就能解决的.&lt;/p&gt;
&lt;p&gt;所以虽然我做过NLP项目, 现在让我突然去做阿拉法狗, 我也是不行的.&lt;/p&gt;
&lt;p&gt;我接触到不少人做过NLP项目, 因为只会调现有库和云的API, 最终效果不佳, 不得不回退到用正则表达式处理的方式, 甚至乎类似于&quot;&lt;a href=&quot;https://cloud.tencent.com/developer/news/371848&quot; target=&quot;_blank&quot;&gt;价值一个亿的AI核心代码&lt;/a&gt;&quot;. 或者采取人工+智能的方式.&lt;/p&gt;
&lt;p&gt;在此我并没有嘲笑以上各种方法的意思, 毕竟第一我的水平也不怎么样嘛, 第二正则表达式和人工+智能的方式的确临时解决了部分问题.&lt;/p&gt;
&lt;p&gt;但是人总是要有追求的, 就像Eric说的, 就算做咸鱼都要做一条有理想的咸鱼, 而且从长远的角度来说还是要靠数学才能根本性的解决问题.&lt;/p&gt;

&lt;p&gt;数学和AI一样五花八门种类繁杂, 同样是研究数学, 研究计算共形几何和研究范畴论的两个人是很难沟通的.&lt;/p&gt;
&lt;p&gt;自然语言处理(NLP)对应的数学分支是概率论. 而概率论中又会用到微分和积分, 合称微积分.&lt;/p&gt;
&lt;p&gt;然而概率论子分类也很多, 这里就简单列一下NLP所用到的概率论知识点吧:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;概率(probability)&lt;/li&gt;
&lt;li&gt;最大似然估计(maximum likelihood estimation)&lt;/li&gt;
&lt;li&gt;条件概率(conditional probability)&lt;/li&gt;
&lt;li&gt;全概率公式(full probability)&lt;/li&gt;
&lt;li&gt;贝叶斯决策理论(Bayesian decision theory)&lt;/li&gt;
&lt;li&gt;贝叶斯法则(Bayes' theorem)&lt;/li&gt;
&lt;li&gt;二项式分布(binomial distribution)&lt;/li&gt;
&lt;li&gt;期望(expectation)&lt;/li&gt;
&lt;li&gt;方差(variance)&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;然而要弄懂上面9点, 还需要理解以下概念:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;排列组合&lt;/li&gt;
&lt;li&gt;频率与概率&lt;/li&gt;
&lt;li&gt;古典概型与几何概型&lt;/li&gt;
&lt;li&gt;条件概率&lt;/li&gt;
&lt;li&gt;全概率公式&lt;/li&gt;
&lt;li&gt;一维和二维离散型随机变量&lt;/li&gt;
&lt;li&gt;一维和二维连续随机变量&lt;/li&gt;
&lt;li&gt;协方差和相关系数&lt;/li&gt;
&lt;li&gt;大数定律及中心极限定理&lt;/li&gt;
&lt;li&gt;样本与抽样分布&lt;/li&gt;
&lt;li&gt;点估计&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;后面我会对具体每个概念写心得.&lt;/p&gt;
</description>
<pubDate>Wed, 11 Dec 2019 15:45:00 +0000</pubDate>
<dc:creator>叶伟民</dc:creator>
<og:description>很多人都说, AI并不难啊, 调现有库和云的API就可以啦. 然而实际上并不是这样的.</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/adalovelacer/p/NLP-Math-1-summary.html</dc:identifier>
</item>
<item>
<title>深入理解 BigDecimal - 不是秃头的程序员小李</title>
<link>http://www.cnblogs.com/ferryman/p/12026542.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ferryman/p/12026542.html</guid>
<description>&lt;p id=&quot;tocid_0&quot; class=&quot;toc&quot;&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/ferryman/p/12026542.html#hbigdecimal&quot;&gt;什么是 BigDecimal&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/ferryman/p/12026542.html#hbigdecimaldouble&quot;&gt;为什么用 BigDecimal 而不用 double&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/ferryman/p/12026542.html#h&quot;&gt;加减乘除&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/ferryman/p/12026542.html#h-1&quot;&gt;常用方法&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/ferryman/p/12026542.html#h-2&quot;&gt;保留两位小数&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/ferryman/p/12026542.html#h-3&quot;&gt;四舍五入&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/ferryman/p/12026542.html#h-4&quot;&gt;比较&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/ferryman/p/12026542.html#h-5&quot;&gt;注意事项&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/ferryman/p/12026542.html#h-6&quot;&gt;参考&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;BigDecimal&lt;/strong&gt; 可以表示一个任意大小且精度完全准确的浮点数。&lt;/p&gt;

&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Talk is cheap, Show me the Code.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;例 1：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 1&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;double&lt;/span&gt; d1 = &lt;span class=&quot;hljs-number&quot;&gt;0.3&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 2&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;double&lt;/span&gt; d2 = &lt;span class=&quot;hljs-number&quot;&gt;0.2&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 3&lt;/span&gt;System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Double:\t 0,3 - 0,2 = &quot;&lt;/span&gt; + (d1 - d2));&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 5&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;float&lt;/span&gt; f1 = &lt;span class=&quot;hljs-number&quot;&gt;0.3f&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 6&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;float&lt;/span&gt; f2 = &lt;span class=&quot;hljs-number&quot;&gt;0.2f&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 7&lt;/span&gt;System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Float:\t 0,3 - 0,2 = &quot;&lt;/span&gt; + (f1 - f2));&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 8&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 9&lt;/span&gt;BigDecimal bd1 = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; BigDecimal(&lt;span class=&quot;hljs-string&quot;&gt;&quot;0.3&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;10&lt;/span&gt;BigDecimal bd2 = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; BigDecimal(&lt;span class=&quot;hljs-string&quot;&gt;&quot;0.2&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;11&lt;/span&gt;System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;BigDec:\t 0,3 - 0,2 = &quot;&lt;/span&gt; + (bd1.subtract(bd2)));&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;1&lt;/span&gt;Double:     &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt; - &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; = &lt;span class=&quot;hljs-number&quot;&gt;0.09999999999999998&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;2&lt;/span&gt;Float:     &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt; - &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; = &lt;span class=&quot;hljs-number&quot;&gt;0.10000001&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;3&lt;/span&gt;BigDec:     &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt; - &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; = &lt;span class=&quot;hljs-number&quot;&gt;0.1&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从运行结果可以得出，当我们要做精确的小数操作运算时，就需要用到 BigDecimal。那下面做一下除法运算，看看结果：&lt;/p&gt;
&lt;p&gt;例 2：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 1&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;double&lt;/span&gt; d1 = &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 2&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;double&lt;/span&gt; d2 = &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 3&lt;/span&gt;System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Double:\t 10 / 3 = &quot;&lt;/span&gt; + (d1 / d2));&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 5&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;float&lt;/span&gt; f1 = &lt;span class=&quot;hljs-number&quot;&gt;10f&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 6&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;float&lt;/span&gt; f2 = &lt;span class=&quot;hljs-number&quot;&gt;3f&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 7&lt;/span&gt;System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Float:\t 10 / 3 = &quot;&lt;/span&gt; + (f1 / f2));&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 8&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 9&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;10&lt;/span&gt;BigDecimal bd3 = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; BigDecimal(&lt;span class=&quot;hljs-string&quot;&gt;&quot;10&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;11&lt;/span&gt;BigDecimal bd4 = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; BigDecimal(&lt;span class=&quot;hljs-string&quot;&gt;&quot;3&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;12&lt;/span&gt;System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;BigDec:\t 10 / 3 = &quot;&lt;/span&gt; + (bd3.divide(bd4)));&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;1&lt;/span&gt;Double:     &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt; / &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt; = &lt;span class=&quot;hljs-number&quot;&gt;3.3333333333333335&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;2&lt;/span&gt;Float:     &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt; / &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt; = &lt;span class=&quot;hljs-number&quot;&gt;3.3333333&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;3&lt;/span&gt;Exception in thread &lt;span class=&quot;hljs-string&quot;&gt;&quot;main&quot;&lt;/span&gt; java.lang.ArithmeticException: Non-terminating decimal expansion; no exact representable decimal result.&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当结果除不进，并且没有设置进位的状态值，那就会抛出异常。正确的操作如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;1&lt;/span&gt;System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;BigDec:\t 10 / 3 = &quot;&lt;/span&gt; + (bd3.divide(bd4,&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;,BigDecimal.ROUND_HALF_UP)));&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;1&lt;/span&gt;Double:     &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt; / &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt; = &lt;span class=&quot;hljs-number&quot;&gt;3.3333333333333335&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;2&lt;/span&gt;Float:     &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt; / &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt; = &lt;span class=&quot;hljs-number&quot;&gt;3.3333333&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;3&lt;/span&gt;BigDec:     &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt; / &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt; = &lt;span class=&quot;hljs-number&quot;&gt;3.3333&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;总结：当我们在精度要求非常高的时候，需要进行精确的计算，比如：货币，那我们就需要采用 java.math.BigDecimal 类来进行精确计算。&lt;/p&gt;

&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;方法&lt;/th&gt;
&lt;th&gt;叙述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;add(BigDecimal)&lt;/td&gt;
&lt;td&gt;BigDecimal对象中的值相加，然后返回这个对象&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;subtract(BigDecimal)&lt;/td&gt;
&lt;td&gt;BigDecimal对象中的值相减，然后返回这个对象&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;multiply(BigDecimal)&lt;/td&gt;
&lt;td&gt;BigDecimal对象中的值相乘，然后返回这个对象&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;divide(BigDecimal)&lt;/td&gt;
&lt;td&gt;BigDecimal对象中的值相除，然后返回这个对象&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 1&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;BigDecimalCalculation&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 2&lt;/span&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; BigDecimal a = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; BigDecimal(&lt;span class=&quot;hljs-string&quot;&gt;&quot;0.02&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 3&lt;/span&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; BigDecimal b = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; BigDecimal(&lt;span class=&quot;hljs-string&quot;&gt;&quot;0.03&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 5&lt;/span&gt;    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 6&lt;/span&gt;        System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;a + b = &quot;&lt;/span&gt; + a.add(b));&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 7&lt;/span&gt;        System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;a - b = &quot;&lt;/span&gt; + a.subtract(b));&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 8&lt;/span&gt;        System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;a * b = &quot;&lt;/span&gt; + a.multiply(b));&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 9&lt;/span&gt;        System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;a ÷ b = &quot;&lt;/span&gt; + a.divide(b,&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;,BigDecimal.ROUND_HALF_UP));&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;10&lt;/span&gt;    }&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;11&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;12&lt;/span&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;1&lt;/span&gt;a + b = &lt;span class=&quot;hljs-number&quot;&gt;0.05&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;2&lt;/span&gt;a - b = -&lt;span class=&quot;hljs-number&quot;&gt;0.01&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;3&lt;/span&gt;a * b = &lt;span class=&quot;hljs-number&quot;&gt;0.0006&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;4&lt;/span&gt;a ÷ b = &lt;span class=&quot;hljs-number&quot;&gt;0.67&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;h3 id=&quot;h-2&quot;&gt;&lt;span&gt;保留两位小数&lt;/span&gt;&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 1&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;keepTwoDecimal&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 2&lt;/span&gt;    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 3&lt;/span&gt;        BigDecimal num= &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; BigDecimal(&lt;span class=&quot;hljs-number&quot;&gt;13.154215&lt;/span&gt;);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 5&lt;/span&gt;        &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 6&lt;/span&gt;        DecimalFormat df1 = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; DecimalFormat(&lt;span class=&quot;hljs-string&quot;&gt;&quot;0.00&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 7&lt;/span&gt;        String str = df1.format(num);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 8&lt;/span&gt;        System.out.println(str);  &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 9&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;10&lt;/span&gt;        &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;11&lt;/span&gt;        &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;12&lt;/span&gt;        DecimalFormat df2 =&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; DecimalFormat(&lt;span class=&quot;hljs-string&quot;&gt;&quot;#.00&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;13&lt;/span&gt;        String str2 =df2.format(num);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;14&lt;/span&gt;        System.out.println(str2);  &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;15&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;16&lt;/span&gt;        &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;17&lt;/span&gt;        &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;18&lt;/span&gt;        String result = String.format(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%.2f&quot;&lt;/span&gt;, num);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;19&lt;/span&gt;        System.out.println(result);  &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;20&lt;/span&gt;    }&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;21&lt;/span&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;h-3&quot;&gt;&lt;span&gt;四舍五入&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;舍入远离零的舍入模式。&lt;/p&gt;
&lt;p&gt;在丢弃非零部分之前始终增加数字（始终对非零舍弃部分前面的数字加 1）&lt;/p&gt;
&lt;p&gt;例如：2.36 -&amp;gt; 2.4&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;ROUND_DOWN&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;接近零的舍入模式。&lt;/p&gt;
&lt;p&gt;在丢弃某部分之前始终不增加数字(从不对舍弃部分前面的数字加1，即截短)。&lt;/p&gt;
&lt;p&gt;例如：2.36 -&amp;gt; 2.3&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;ROUND_CEILING&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;接近正无穷大的舍入模式。&lt;/p&gt;
&lt;p&gt;如果 BigDecimal 为正，则舍入行为与 ROUND_UP 相同;&lt;/p&gt;
&lt;p&gt;如果为负，则舍入行为与 ROUND_DOWN 相同。&lt;/p&gt;
&lt;p&gt;相当于是 &lt;strong&gt;ROUND_UP&lt;/strong&gt; 和 &lt;strong&gt;ROUND_DOWN&lt;/strong&gt; 的合集&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;ROUND_FLOOR&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;接近负无穷大的舍入模式。&lt;/p&gt;
&lt;p&gt;如果 BigDecimal 为正，则舍入行为与 ROUND_DOWN 相同;&lt;/p&gt;
&lt;p&gt;如果为负，则舍入行为与 ROUND_UP 相同。&lt;/p&gt;
&lt;p&gt;与 &lt;strong&gt;ROUND_CEILING&lt;/strong&gt; 正好相反&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;ROUND_HALF_UP&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;四舍五入&lt;/p&gt;
&lt;p&gt;例如：2.35 -&amp;gt; 2.4&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;ROUND_HALF_DOWN&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;五舍六入&lt;/p&gt;
&lt;p&gt;例如：2.35 -&amp;gt; 2.3&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;ROUND_HALF_EVEN&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果舍弃部分左边的数字为奇数，则舍入行为与 ROUND_HALF_UP 相同（四舍五入）;&lt;/p&gt;
&lt;p&gt;如果为偶数，则舍入行为与 ROUND_HALF_DOWN 相同（五舍六入）。&lt;/p&gt;
&lt;p&gt;例如：1.15 -&amp;gt; 1.1，1.25 -&amp;gt; 1.2&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;ROUND_UNNECESSARY&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;断言请求的操作具有精确的结果，因此不需要舍入。&lt;/p&gt;
&lt;p&gt;如果对获得精确结果的操作指定此舍入模式，则抛出 ArithmeticException。&lt;/p&gt;
&lt;p&gt;我觉得剩下得了解下就行，而且我感觉剩下有的就是错的，比如 &lt;strong&gt;ROUND_HALF_DOWN&lt;/strong&gt; 和 &lt;strong&gt;ROUND_HALF_EVEN&lt;/strong&gt;，看下面的结果你就知道我说的是为什么了。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 1&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;BigDecimalScaleTest&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 2&lt;/span&gt;    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 3&lt;/span&gt;        &lt;span class=&quot;hljs-keyword&quot;&gt;double&lt;/span&gt; num = &lt;span class=&quot;hljs-number&quot;&gt;2.35&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 4&lt;/span&gt;        BigDecimal b = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; BigDecimal(num);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 5&lt;/span&gt;        &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 6&lt;/span&gt;        System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;ROUND_UP，结果：&quot;&lt;/span&gt; + b.setScale(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, BigDecimal.ROUND_UP).doubleValue());&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 7&lt;/span&gt;        System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;ROUND_DOWN，结果：&quot;&lt;/span&gt; + b.setScale(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, BigDecimal.ROUND_DOWN).doubleValue());&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 8&lt;/span&gt;        System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;ROUND_CEILING，结果：&quot;&lt;/span&gt; + b.setScale(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, BigDecimal.ROUND_CEILING).doubleValue());&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 9&lt;/span&gt;        System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;ROUND_FLOOR，结果：&quot;&lt;/span&gt; + b.setScale(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, BigDecimal.ROUND_FLOOR).doubleValue());&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;10&lt;/span&gt;        System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;ROUND_HALF_UP，结果：&quot;&lt;/span&gt; + b.setScale(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, BigDecimal.ROUND_HALF_UP).doubleValue());&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;11&lt;/span&gt;        System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;ROUND_HALF_DOWN，结果：&quot;&lt;/span&gt; + b.setScale(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, BigDecimal.ROUND_HALF_DOWN).doubleValue());&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;12&lt;/span&gt;        System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;ROUND_HALF_EVEN，结果：&quot;&lt;/span&gt; + b.setScale(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, BigDecimal.ROUND_HALF_EVEN).doubleValue());&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;13&lt;/span&gt;        System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;ROUND_UNNECESSARY，结果：&quot;&lt;/span&gt; + b.setScale(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, BigDecimal.ROUND_UNNECESSARY).doubleValue());&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;14&lt;/span&gt;    }&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;15&lt;/span&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs coffeescript&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;1&lt;/span&gt;ROUND_UP，结果：&lt;span class=&quot;hljs-number&quot;&gt;2.4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;2&lt;/span&gt;ROUND_DOWN，结果：&lt;span class=&quot;hljs-number&quot;&gt;2.3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;3&lt;/span&gt;ROUND_CEILING，结果：&lt;span class=&quot;hljs-number&quot;&gt;2.4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;4&lt;/span&gt;ROUND_FLOOR，结果：&lt;span class=&quot;hljs-number&quot;&gt;2.3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;5&lt;/span&gt;ROUND_HALF_UP，结果：&lt;span class=&quot;hljs-number&quot;&gt;2.4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;6&lt;/span&gt;ROUND_HALF_DOWN，结果：&lt;span class=&quot;hljs-number&quot;&gt;2.4&lt;/span&gt; (来给我解释解释这个，说好的五舍六入呢)&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;7&lt;/span&gt;ROUND_HALF_EVEN，结果：&lt;span class=&quot;hljs-number&quot;&gt;2.4&lt;/span&gt; (还有这个)&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;8&lt;/span&gt;Disconnected &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; the target VM, address: &lt;span class=&quot;hljs-string&quot;&gt;'127.0.0.1:59637'&lt;/span&gt;, transport: &lt;span class=&quot;hljs-string&quot;&gt;'socket'&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;9&lt;/span&gt;Exception &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; thread &lt;span class=&quot;hljs-string&quot;&gt;&quot;main&quot;&lt;/span&gt; java.lang.ArithmeticException: Rounding necessary&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;小结：常用的就是 &lt;strong&gt;ROUND_HALF_UP&lt;/strong&gt;、&lt;strong&gt;ROUND_UP&lt;/strong&gt; 和 &lt;strong&gt;ROUND_DOWN&lt;/strong&gt;，其它的当个笑话就行&lt;/p&gt;
&lt;h3 id=&quot;h-4&quot;&gt;&lt;span&gt;比较&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;a.compareTo(b)&lt;/p&gt;
&lt;p&gt;a &amp;gt; b 返回 1；a = b 返回 0；a &amp;lt; b 返回 -1&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 1&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;BigDecimalCompare&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 2&lt;/span&gt;    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 3&lt;/span&gt;        BigDecimal a = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; BigDecimal(&lt;span class=&quot;hljs-string&quot;&gt;&quot;0.02&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 4&lt;/span&gt;        BigDecimal b = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; BigDecimal(&lt;span class=&quot;hljs-string&quot;&gt;&quot;0.01&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 5&lt;/span&gt;        BigDecimal a2 = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; BigDecimal(&lt;span class=&quot;hljs-string&quot;&gt;&quot;0.02&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 6&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 7&lt;/span&gt;        System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot; a &amp;gt; b 返回结果：&quot;&lt;/span&gt; + a.compareTo(b));&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 8&lt;/span&gt;        System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot; a = a2 返回结果：&quot;&lt;/span&gt; + a.compareTo(a2));&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 9&lt;/span&gt;        System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot; b &amp;lt; a 返回结果：&quot;&lt;/span&gt; + b.compareTo(a));&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;10&lt;/span&gt;    }&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;11&lt;/span&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;1&lt;/span&gt; a &amp;gt; b 返回结果：&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;2&lt;/span&gt; a = a2 返回结果：&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;3&lt;/span&gt; b &amp;lt; a 返回结果：-&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;在上面的使用中，我们都用的 String 给 BigDecimal 进行 赋值，而没有使用 double 类型赋值，具体的原因看下面的例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 1&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;BigDecimalTest&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 2&lt;/span&gt;    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 3&lt;/span&gt;        BigDecimal num1 = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; BigDecimal(&lt;span class=&quot;hljs-number&quot;&gt;0.005&lt;/span&gt;);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 4&lt;/span&gt;        BigDecimal num2 = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; BigDecimal(&lt;span class=&quot;hljs-number&quot;&gt;1000000&lt;/span&gt;);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 5&lt;/span&gt;        BigDecimal num3 = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; BigDecimal(-&lt;span class=&quot;hljs-number&quot;&gt;1000000&lt;/span&gt;);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 6&lt;/span&gt;        &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 7&lt;/span&gt;        BigDecimal num12 = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; BigDecimal(&lt;span class=&quot;hljs-string&quot;&gt;&quot;0.005&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 8&lt;/span&gt;        BigDecimal num22 = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; BigDecimal(&lt;span class=&quot;hljs-string&quot;&gt;&quot;1000000&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 9&lt;/span&gt;        BigDecimal num32 = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; BigDecimal(&lt;span class=&quot;hljs-string&quot;&gt;&quot;-1000000&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;10&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;11&lt;/span&gt;        &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;12&lt;/span&gt;        BigDecimal result1 = num1.add(num2);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;13&lt;/span&gt;        BigDecimal result12 = num12.add(num22);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;14&lt;/span&gt;        &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;15&lt;/span&gt;        BigDecimal result2 = num1.subtract(num2);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;16&lt;/span&gt;        BigDecimal result22 = num12.subtract(num22);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;17&lt;/span&gt;        &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;18&lt;/span&gt;        BigDecimal result3 = num1.multiply(num2);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;19&lt;/span&gt;        BigDecimal result32 = num12.multiply(num22);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;20&lt;/span&gt;        &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;21&lt;/span&gt;        BigDecimal result4 = num3.abs();&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;22&lt;/span&gt;        BigDecimal result42 = num32.abs();&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;23&lt;/span&gt;        &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;24&lt;/span&gt;        BigDecimal result5 = num2.divide(num1,&lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;,BigDecimal.ROUND_HALF_UP);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;25&lt;/span&gt;        BigDecimal result52 = num22.divide(num12,&lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;,BigDecimal.ROUND_HALF_UP);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;26&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;27&lt;/span&gt;        System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;加法用value结果：&quot;&lt;/span&gt;+result1);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;28&lt;/span&gt;        System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;加法用string结果：&quot;&lt;/span&gt;+result12);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;29&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;30&lt;/span&gt;        System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;减法value结果：&quot;&lt;/span&gt;+result2);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;31&lt;/span&gt;        System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;减法用string结果：&quot;&lt;/span&gt;+result22);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;32&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;33&lt;/span&gt;        System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;乘法用value结果：&quot;&lt;/span&gt;+result3);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;34&lt;/span&gt;        System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;乘法用string结果：&quot;&lt;/span&gt;+result32);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;35&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;36&lt;/span&gt;        System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;绝对值用value结果：&quot;&lt;/span&gt;+result4);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;37&lt;/span&gt;        System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;绝对值用string结果：&quot;&lt;/span&gt;+result42);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;38&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;39&lt;/span&gt;        System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;除法用value结果：&quot;&lt;/span&gt;+result5);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;40&lt;/span&gt;        System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;除法用string结果：&quot;&lt;/span&gt;+result52);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;41&lt;/span&gt;    }&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;42&lt;/span&gt;  }&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs cs&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 1&lt;/span&gt;加法用&lt;span class=&quot;hljs-keyword&quot;&gt;value&lt;/span&gt;结果：&lt;span class=&quot;hljs-number&quot;&gt;1000000.005000000000000000104083408558608425664715468883514404296875&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 2&lt;/span&gt;加法用&lt;span class=&quot;hljs-keyword&quot;&gt;string&lt;/span&gt;结果：&lt;span class=&quot;hljs-number&quot;&gt;1000000.005&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 3&lt;/span&gt;减法&lt;span class=&quot;hljs-keyword&quot;&gt;value&lt;/span&gt;结果：&lt;span class=&quot;hljs-number&quot;&gt;-999999.994999999999999999895916591441391574335284531116485595703125&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 4&lt;/span&gt;减法用&lt;span class=&quot;hljs-keyword&quot;&gt;string&lt;/span&gt;结果：&lt;span class=&quot;hljs-number&quot;&gt;-999999.995&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 5&lt;/span&gt;乘法用&lt;span class=&quot;hljs-keyword&quot;&gt;value&lt;/span&gt;结果：&lt;span class=&quot;hljs-number&quot;&gt;5000.000000000000104083408558608425664715468883514404296875000000&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 6&lt;/span&gt;乘法用&lt;span class=&quot;hljs-keyword&quot;&gt;string&lt;/span&gt;结果：&lt;span class=&quot;hljs-number&quot;&gt;5000.000&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 7&lt;/span&gt;绝对值用&lt;span class=&quot;hljs-keyword&quot;&gt;value&lt;/span&gt;结果：&lt;span class=&quot;hljs-number&quot;&gt;1000000&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 8&lt;/span&gt;绝对值用&lt;span class=&quot;hljs-keyword&quot;&gt;string&lt;/span&gt;结果：&lt;span class=&quot;hljs-number&quot;&gt;1000000&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 9&lt;/span&gt;除法用&lt;span class=&quot;hljs-keyword&quot;&gt;value&lt;/span&gt;结果：&lt;span class=&quot;hljs-number&quot;&gt;199999999.99999999583666365766&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;10&lt;/span&gt;除法用&lt;span class=&quot;hljs-keyword&quot;&gt;string&lt;/span&gt;结果：&lt;span class=&quot;hljs-number&quot;&gt;200000000.00000000000000000000&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;ul&gt;&lt;li&gt;&lt;span&gt;System.out.println() 中的数字默认是 double 类型的，double 类型的小数计算不准确&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;使用 BigDecimal 的构造方法传入 double 类型时，计算的结果也是不准确的！&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所以我们在使用 BigDecimal 进行赋值的时候，最好使用传入 String 的构造函数，可以确认精度。&lt;/p&gt;

&lt;p&gt;https://blog.csdn.net/haiyinshushe/article/details/82721234&lt;/p&gt;
&lt;p&gt;https://www.jianshu.com/p/2947868d76eb&lt;/p&gt;
&lt;p&gt;https://blog.csdn.net/ochangwen/article/details/51531866&lt;/p&gt;
</description>
<pubDate>Wed, 11 Dec 2019 15:37:00 +0000</pubDate>
<dc:creator>不是秃头的程序员小李</dc:creator>
<og:description>什么是 BigDecimal为什么用 BigDecimal 而不用 double加减乘除常用方法保留两位小数四舍五入比较注意事项参考 什么是 BigDecimal BigDecimal 可以表示一个任</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ferryman/p/12026542.html</dc:identifier>
</item>
<item>
<title>程序员：这10种糟糕的程序命名，你遇到过几个？ - 张林-布莱恩特</title>
<link>http://www.cnblogs.com/zhangmumu/p/12026476.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangmumu/p/12026476.html</guid>
<description>&lt;h3 id=&quot;措不及防的缩写&quot;&gt;01 措不及防的缩写&lt;/h3&gt;
&lt;p&gt;一般来说如果单词过长的话，会采用缩写的方式，比如number 》num&lt;br/&gt;CurrentUser&amp;gt;currUser。可是工作中，经常会遇到这种“便秘式”命名，给人一种措不及防的感觉。有时候还要利用想象的空间的，猜一下这个命名到底是个什么玩意。&lt;br/&gt;写完整的算了，他不他偏要来个缩写，缩写后，我就看不懂（本身就不长，干就万事了。）&lt;br/&gt;这是一段xaml引入命名空间的代码，一个6个字符，缩写后成功地变成5个字符，最终为大家节省了点击一个键的卡路里。common完美缩写成comon&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;xmlns:comon=&quot;clr-namespace:SGS.SIO.Common.Utilities;assembly=SGS.SIO.Common&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;建议：缩写干脆点，实在想不到好的缩写，那就直接写完整的单词&lt;/p&gt;
&lt;h3 id=&quot;中文命名&quot;&gt;02 中文命名&lt;/h3&gt;
&lt;p&gt;（ps:无法展示类似代码.png)不要觉得中文命名不可思议，我以前也是这样觉得居然还有中文命名的，上一家公司就有这样的例子。工作一段时间后，你可能会遇到一些几年前甚至十年前的代码，什么是工作啊？工作嘛......&lt;br/&gt;每一种存在，都有他的存在的理由（ps：不管是好还是坏）。我的思考是，上一家公司采用中文命名是有一定的原因的，那些名词如果英文来翻译的话，非常容易歧义、难以理解、甚至跑偏，工作嘛，不能改变的时候，就只能去接受它。&lt;br/&gt;建议：不要使用中文命名，万不得已的情况下也不要，打上注释也行啊&lt;/p&gt;
&lt;h3 id=&quot;自己的姓名来命名类和方法&quot;&gt;03 自己的姓名来命名类和方法&lt;/h3&gt;
&lt;p&gt;这一case来自邹溪源老师文章&lt;a href=&quot;https://www.cnblogs.com/xiyuanMore/p/11502536.html&quot;&gt;成就卓越代码,从关注细节开始&lt;/a&gt;的第一段落&lt;br/&gt;用自己姓名来命名，我是真没遇到过，邹老师是一位80后程序员，见多识广。所以碰到过这样case，我就分享一下&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// author:zhangsan
/// &amp;lt;/summary&amp;gt;
class ZhangsanTest
{
    private void TestGetData()
    {
        int a, b, c;
    }
    private int ZhangsanGet(int s1, int s2)
    {
        int s3 = s1 + s2;
        return s3;
    } 
    private List&amp;lt;string&amp;gt; GetData()
    {
        return null;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;14&quot;&gt;
&lt;p&gt;这是一个喜欢用自己的姓名来命名类和方法的作者，在他的代码中，经常可以看到这样奇怪的对象定义，而且他还喜欢用a,b,c,d,e,f或者s1,s2这样的命名，仿佛他的代码自带混淆特效。这样的代码嗅起来会不会觉得充斥着奇怪的味道？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;建议：名字来命名这事儿挺严肃的，毕竟后面接手的人可能会认识你这个沙雕&lt;/p&gt;
&lt;h3 id=&quot;加了魔幻的方法命名&quot;&gt;04 加了魔幻的方法命名&lt;/h3&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;    private void GetData()
    {
        int a, b, c;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个我是真的见过，看到邹老师分享，我抽了根烟，相见恨晚.png。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;另外，有没有发现有许多开发者喜欢用 GetData() 来定义获取数据的方法？然后这个方法就成为一个万金油的方法，不管是爬虫采集、或者数据绑定，无论是 C# 写的后端或者 Java 写的后端代码，或者用 vue 写的前端代码，仿佛在任何场景、任何数据应用都可以看到这样的方法。&lt;br/&gt;如果一个项目中，有十几个地方都出现了这个** GetData() **方法，那种感觉一定非常难受&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;熟悉的名字，却是千变万幻的味道。&lt;br/&gt;建议：这不是写那个GetData的码农吗？你品，你细品！&lt;/p&gt;
&lt;h3 id=&quot;歧义的命名&quot;&gt;05 歧义的命名&lt;/h3&gt;
&lt;p&gt;这也是我遇到的真实案例，为此付出了无意义的1个小时调试。将一个页面的命名成this，可能觉得this好用，this挺喜欢好用。&lt;br/&gt;比如这个：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;x:Name=&quot;this&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;调用的时候&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;Command=&quot;{Binding Source={x:Reference this},Path=BindingContext.EditCmd}&quot; &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当时就有点懵逼，这个this到底指的是什么。这种以关键字来命名的，估计是想报复同事。&lt;br/&gt;良好的命名如这样的：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;&amp;lt;CheckBox x:Name=&quot;chkBoxChinese&quot; /&amp;gt; 
    &amp;lt;Label Text=&quot;chinese&quot;&amp;gt;
        &amp;lt;Label.Triggers&amp;gt;
            &amp;lt;DataTrigger TargetType=&quot;Label&quot; Binding=&quot;{Binding Source={x:Reference chkBoxChinese}, Path=IsChecked}&quot; Value=&quot;true&quot;&amp;gt; 
            &amp;lt;Setter Property=&quot;FontAttributes&quot; Value=&quot;Italic, Bold&quot; /&amp;gt; &amp;lt;Setter Property=&quot;FontSize&quot; Value=&quot;Large&quot; /&amp;gt; 
            &amp;lt;/DataTrigger&amp;gt; 
        &amp;lt;/Label.Triggers&amp;gt; 
    &amp;lt;/Label&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;建议：禁止使用关键字来命名&lt;/p&gt;
&lt;h3 id=&quot;数字化的命名&quot;&gt;06 数字化的命名&lt;/h3&gt;
&lt;p&gt;不要觉得，这事我最多也就上学时候干过。&lt;br/&gt;全面发展，数字一体化。的却挺全面，曾经做xamarin的时候，在一个activity的里面有5，6个按钮，点了一个其他按钮显示不同状态，于是每个按钮变成dialog1、dialog2、dialog3&lt;br/&gt;建议：根据实际的作用进行命名。&lt;/p&gt;
&lt;h3 id=&quot;考验眼神的命名&quot;&gt;07 考验眼神的命名&lt;/h3&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;int materialFirstNum = 8;
int materialSecondNum = 11;
int materialSumNum = materialFirstNum + materialSecondNum ;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;欢迎大家来找茬，良好的命名变量是让人一看就明白，顾名思义。把不同的部分写在中间，书写时容易了，但是不容易检查。（ps：这里指的书写容易指的是写material时，各种IDE会有提示）&lt;br/&gt;比如这样：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;int firstMaterialNum = 8;
int secondMaterialNum = 11;
int sumMaterialNum = firstMaterialNum + secondMaterialNum ;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;建议：如果有相似的名字，请把他们不同的部分卸载开头，其次是结尾。&lt;/p&gt;
&lt;h3 id=&quot;直接以类型来命名&quot;&gt;08 直接以类型来命名&lt;/h3&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;List&amp;lt;MaterialModel&amp;gt; list =new  List&amp;lt;MaterialModel&amp;gt;();
string[] array = { &quot;&quot;,&quot;&quot;,&quot;&quot;};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种名字不好的地方有两个&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;命名根本就不知道代表什么意思，毫无意义&lt;/li&gt;
&lt;li&gt;IDE提示也容易混淆，不容易输入&lt;br/&gt;有经验的程序员肯定会写出这个变量是代表什么意思的，比如这样的&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;List&amp;lt;MaterialModel&amp;gt; materialList =new  List&amp;lt;MaterialModel&amp;gt;();
string[] titleIdArray = { &quot;&quot;,&quot;&quot;,&quot;&quot;};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;建议：不要写与系统定义类型关键字的命名，命名要有意义。&lt;/p&gt;
&lt;h3 id=&quot;不规范的方法名&quot;&gt;09 不规范的方法名&lt;/h3&gt;
&lt;p&gt;比如这个命名：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public static int TwoNumSubtraction(int firstNum,int secondNum){
    return firstNum - secondNum;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最好改成 动词+名词格式，subtraction的缩写sub，这样的好处是合适的缩写顾名思义，SubTwoNum就知道是做两个数的减法运算。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public static int SubTwoNum(int firstNum,int secondNum){
    return firstNum - secondNum;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;建议：方法名最好动词+名词格式&lt;/p&gt;
&lt;h3 id=&quot;单词拼错的命名&quot;&gt;10 单词拼错的命名&lt;/h3&gt;
&lt;p&gt;SendMassage(...)看到这个，我感觉当时这哥们应该压力挺大的。&lt;br/&gt;data和date 组合拳式混写，可能当时这个当事人自己也写蒙了吧！&lt;br/&gt;form、from 。这个我也曾经常容易写错，傻傻分不清！&lt;br/&gt;dataOne, dataTwo, dataThree, DataFour (手动捂脸)&lt;br/&gt;建议：这个我真啥建议的.....&lt;/p&gt;
&lt;p&gt;结语：林子大了，什么鸟都有！最后问一句，什么是工作啊？&lt;br/&gt;下篇会写到，代码命名方式有哪些？代码规范会写成一个系列&lt;/p&gt;
</description>
<pubDate>Wed, 11 Dec 2019 15:18:00 +0000</pubDate>
<dc:creator>张林-布莱恩特</dc:creator>
<og:description>这些奇葩的命名你都遇到过多少，涨姿势了》》</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhangmumu/p/12026476.html</dc:identifier>
</item>
</channel>
</rss>