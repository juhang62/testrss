<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>深入理解Java的三种工厂模式 - 王、晨</title>
<link>http://www.cnblogs.com/w13248223001/p/10389854.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/w13248223001/p/10389854.html</guid>
<description>&lt;h3&gt;一、简单工厂模式&lt;/h3&gt;
&lt;p&gt;简单工厂的定义：提供一个创建对象实例的功能，而无须关心其具体实现。被创建实例的类型可以是接口、抽象类，也可以是具体的类&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;实现汽车接口&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Car {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;    String getName();
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;奔驰类&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Benz &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Car {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getName() {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &quot;Benz&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;宝马类&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; BMW &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Car {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getName() {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &quot;BMW&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;简单工厂，既能生产宝马又能生产奔驰&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SimpleFactory {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Car getCar(String name){
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (name.equals(&quot;BMW&quot;&lt;span&gt;)){
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BMW();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         }&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (name.equals(&quot;benz&quot;&lt;span&gt;)){
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Benz();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         }&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             System.out.println(&quot;不好意思，这个品牌的汽车生产不了&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;测试类&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SimpleFactoryTest {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args){
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         SimpleFactory simpleFactory = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SimpleFactory();
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         Car car = simpleFactory.getCar(&quot;BMW&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;        System.out.println(car.getName());
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;测试结果&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;根据简单工厂的定义，用户只要产品而不在乎产品如何生产，看起来好像很完美的样子。但大家想想，这个世界存在什么都生产的工厂吗？显然是不存在的，每一个汽车品牌都有自己的生产工厂，都有自己生产技术。映射到spring框架中，我们有很多很多种的bean需要生产，如果只依靠一个简单工厂来实现，那么我们得在工厂类中嵌套多少个if..else if啊？而且我们在代码中生产一辆汽车只是new一下就出来了，但实际操作中却不知道需要进行多少操作，加载、注册等操作都将体现在工厂类中，那么这个类就会变得紊乱，管理起来也很不方便，所以说每个品牌应该有自己的生产类。因为专一，所以专业嘛，这个时候工厂方法就出现了。&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;二、工厂方法&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;工厂接口&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义一个工厂接口，功能就是生产汽车&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Factory {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;    Car getCar();
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;奔驰工厂&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; BenzFactory &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Factory {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Car getCar() {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Benz();
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;宝马工厂&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; BMWFactory &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Factory{
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Car getCar() {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BMW();
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;测试类&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FactoryTest {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args){
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;        Factory bmwFactory = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BMWFactory();
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;       System.out.println(bmwFactory.getCar().getName());
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;        Factory benzFactory = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BenzFactory();
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;       System.out.println(benzFactory.getCar().getName());
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;测试结果&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;BMW
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; Benz
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;根据上述代码可以看出，不同品牌的汽车是由不同的工厂生产的，貌似又是很完美的。但大家看一下测试类，当一个人想要去买一辆宝马汽车的时候（假设没有销售商），那么他就要去找宝马工厂给他生产一辆，过几天又想要买一辆奔驰汽车的时候，又得跑到奔驰工厂请人生产，这无疑就增加了用户的操作复杂性。所以有没有一种方便用户操作的方法呢？这个时候抽象工厂模式就出现了。&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;三、抽象工厂&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;抽象工厂&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AbstractFactory {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;      &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt;&lt;span&gt; Car getCar();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这段代码就是动态配置的功能
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;固定模式的委派&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;      &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Car getCar(String name){
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(&quot;BMW&quot;&lt;span&gt;.equalsIgnoreCase(name)){
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BmwFactory().getCar();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         }&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(&quot;Benz&quot;&lt;span&gt;.equalsIgnoreCase(name)){
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BenzFactory().getCar();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         }&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(&quot;Audi&quot;&lt;span&gt;.equalsIgnoreCase(name)){
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AudiFactory().getCar();
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         }&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             System.out.println(&quot;这个产品产不出来&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;默认工厂&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; DefaultFactory &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; AbstractFactory {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; 
&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; AudiFactory defaultFactory = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AudiFactory();
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; 
&lt;span&gt;5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Car getCar() {
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; defaultFactory.getCar();
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; 
&lt;span&gt;9&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;宝马工厂&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; BMWFactory &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; AbstractFactory {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Car getCar() {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BMW();
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;奔驰工厂&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; BenzFactory &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; AbstractFactory {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Car getCar() {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Benz();
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;测试类&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AbstractFactoryTest {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         DefaultFactory factory = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DefaultFactory();
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         System.out.println(factory.getCar(&quot;Benz&quot;&lt;span&gt;).getName());
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;测试结果&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;根据上述代码可以看出，用户需要一辆汽车，只需要去找默认的工厂提出自己的需求（传入参数），便能得到自己想要产品，而不用根据产品去寻找不同的生产工厂，方便用户操作。注：对于设计模式，有些人嗤之以鼻，有些人敬若神明，但我是认可的。按我粗浅的理解，设计模式的经典之处，就在于解决了编写代码的人和调用代码的人双方的痛楚，不同的设计模式也只适用于不同的场景。至于用或者不用，如何使用，那就需要各位看官着重考虑了。但为了使用而使用是不应该的，细微之处，只有留给大家慢慢品味了。&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;a href=&quot;https://my.oschina.net/u/4052893/blog/2995128&quot;&gt;来源：&lt;/a&gt;&lt;a href=&quot;https://my.oschina.net/u/4052893/blog/2995128&quot;&gt;https://my.oschina.net/u/4052893/blog/2995128&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 16 Feb 2019 15:54:00 +0000</pubDate>
<dc:creator>王、晨</dc:creator>
<og:description>一、简单工厂模式 简单工厂的定义：提供一个创建对象实例的功能，而无须关心其具体实现。被创建实例的类型可以是接口、抽象类，也可以是具体的类 实现汽车接口 奔驰类 宝马类 简单工厂，既能生产宝马又能生产奔</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/w13248223001/p/10389854.html</dc:identifier>
</item>
<item>
<title>C++ 单例模式总结与剖析 - 行者孙</title>
<link>http://www.cnblogs.com/sunchaothu/p/10389842.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sunchaothu/p/10389842.html</guid>
<description>&lt;p&gt;单例可能是最常用的简单的一种设计模式，实现方法多样，根据不同的需求有不同的写法; 同时单例也有其局限性，因此有很多人是反对使用单例的。本文对C++ 单例的常见写法进行了一个总结, 包括懒汉式、线程安全、单例模板等； 按照从简单到复杂，最终回归简单的的方式循序渐进地介绍，并且对各种实现方法的局限进行了简单的阐述，大量用到了C++ 11的特性如智能指针, magic static，线程锁; 从头到尾理解下来，对于学习和巩固C++语言特性还是很有帮助的。本文的全部代码在 g++ 5.4.0 编译器下编译运行通过，可以在&lt;a href=&quot;https://github.com/sunchaothu/AdvancedCpp/tree/master/singleton&quot;&gt;我的github 仓库&lt;/a&gt;中找到。&lt;/p&gt;
&lt;h2 id=&quot;一什么是单例&quot;&gt;一、什么是单例&lt;/h2&gt;
&lt;p&gt;单例 Singleton 是设计模式的一种，其特点是只提供&lt;strong&gt;唯一&lt;/strong&gt;一个类的实例,具有全局变量的特点，在任何位置都可以通过接口获取到那个唯一实例;&lt;br/&gt;具体运用场景如：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;设备管理器，系统中可能有多个设备，但是只有一个设备管理器，用于管理设备驱动;&lt;/li&gt;
&lt;li&gt;数据池，用来缓存数据的数据结构，需要在一处写，多处读取或者多处写，多处读取;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;二c单例的实现&quot;&gt;二、C++单例的实现&lt;/h2&gt;
&lt;h3 id=&quot;基础要点&quot;&gt;2.1 基础要点&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;全局只有一个实例：static 特性，同时禁止用户自己声明并定义实例（把构造函数设为 private）&lt;/li&gt;
&lt;li&gt;线程安全&lt;/li&gt;
&lt;li&gt;禁止赋值和拷贝&lt;/li&gt;
&lt;li&gt;用户通过接口获取实例：使用 static 类成员函数&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;c-实现单例的几种方式&quot;&gt;2.2 C++ 实现单例的几种方式&lt;/h3&gt;
&lt;h4 id=&quot;有缺陷的懒汉式&quot;&gt;2.2.1 有缺陷的懒汉式&lt;/h4&gt;
&lt;p&gt;懒汉式(Lazy-Initialization)的方法是直到使用时才实例化对象，也就说直到调用get_instance() 方法的时候才 new 一个单例的对象。好处是如果被调用就不会占用内存。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include &amp;lt;iostream&amp;gt;
// version1:
// with problems below:
// 1. thread is not safe
// 2. memory leak

class Singleton{
private:
    Singleton(){
        std::cout&amp;lt;&amp;lt;&quot;constructor called!&quot;&amp;lt;&amp;lt;std::endl;
    }
    Singleton(Singleton&amp;amp;)=delete;
    Singleton&amp;amp; operator=(const Singleton&amp;amp;)=delete;
    static Singleton* m_instance_ptr;
public:
    ~Singleton(){
        std::cout&amp;lt;&amp;lt;&quot;destructor called!&quot;&amp;lt;&amp;lt;std::endl;
    }
    static Singleton* get_instance(){
        if(m_instance_ptr==nullptr){
              m_instance_ptr = new Singleton;
        }
        return m_instance_ptr;
    }
    void use() const { std::cout &amp;lt;&amp;lt; &quot;in use&quot; &amp;lt;&amp;lt; std::endl; }
};

Singleton* Singleton::m_instance_ptr = nullptr;

int main(){
    Singleton* instance = Singleton::get_instance();
    Singleton* instance_2 = Singleton::get_instance();
    return 0;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行的结果是&lt;/p&gt;
&lt;pre class=&quot;txt&quot;&gt;
&lt;code&gt;constructor called!&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，获取了两次类的实例，却只有一次类的构造函数被调用，表明只生成了唯一实例，这是个最基础版本的单例实现，他有哪些问题呢？&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;线程安全的问题&lt;/strong&gt;,当多线程获取单例时有可能引发竞态条件：第一个线程在if中判断 &lt;code&gt;m_instance_ptr&lt;/code&gt;是空的，于是开始实例化单例;同时第2个线程也尝试获取单例，这个时候判断&lt;code&gt;m_instance_ptr&lt;/code&gt;还是空的，于是也开始实例化单例;这样就会实例化出两个对象,这就是线程安全问题的由来; &lt;strong&gt;解决办法&lt;/strong&gt;:加锁&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;内存泄漏&lt;/strong&gt;. 注意到类中只负责new出对象，却没有负责delete对象，因此只有构造函数被调用，析构函数却没有被调用;因此会导致内存泄漏。&lt;strong&gt;解决办法&lt;/strong&gt;： 使用共享指针;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;因此，这里提供一个改进的，线程安全的、使用智能指针的实现;&lt;/p&gt;
&lt;h4 id=&quot;线程安全内存安全的懒汉式单例-智能指针锁&quot;&gt;2.2.2 线程安全、内存安全的懒汉式单例 （智能指针，锁）&lt;/h4&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;memory&amp;gt; // shared_ptr
#include &amp;lt;mutex&amp;gt;  // mutex

// version 2:
// with problems below fixed:
// 1. thread is safe now
// 2. memory doesn't leak

class Singleton{
public:
    typedef std::shared_ptr&amp;lt;Singleton&amp;gt; Ptr;
    ~Singleton(){
        std::cout&amp;lt;&amp;lt;&quot;destructor called!&quot;&amp;lt;&amp;lt;std::endl;
    }
    Singleton(Singleton&amp;amp;)=delete;
    Singleton&amp;amp; operator=(const Singleton&amp;amp;)=delete;
    static Ptr get_instance(){

        // &quot;double checked lock&quot;
        if(m_instance_ptr==nullptr){
            std::lock_guard&amp;lt;std::mutex&amp;gt; lk(m_mutex);
            if(m_instance_ptr == nullptr){
              m_instance_ptr = std::shared_ptr&amp;lt;Singleton&amp;gt;(new Singleton);
            }
            return m_instance_ptr;
        }
    }


private:
    Singleton(){
        std::cout&amp;lt;&amp;lt;&quot;constructor called!&quot;&amp;lt;&amp;lt;std::endl;
    }
    static Ptr m_instance_ptr;
    static std::mutex m_mutex;
};

// initialization static variables out of class
Singleton::Ptr Singleton::m_instance_ptr = nullptr;
std::mutex Singleton::m_mutex;

int main(){
    Singleton::Ptr instance = Singleton::get_instance();
    Singleton::Ptr instance2 = Singleton::get_instance();
    return 0;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果如下，发现确实只构造了一次实例，并且发生了析构。&lt;/p&gt;
&lt;pre class=&quot;txt&quot;&gt;
&lt;code&gt;constructor called!
destructor called!&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;shared_ptr和mutex都是C++11的标准，以上这种方法的优点是&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;基于 shared_ptr, 用了C++比较倡导的 RAII思想，用对象管理资源,当 shared_ptr 析构的时候，new 出来的对象也会被 delete掉。以此避免内存泄漏。&lt;/li&gt;
&lt;li&gt;加了锁，使用互斥量来达到线程安全。这里使用了两个 if判断语句的技术称为&lt;strong&gt;双检锁&lt;/strong&gt;；好处是，只有判断指针为空的时候才加锁，避免每次调用 get_instance的方法都加锁，锁的开销毕竟还是有点大的。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;不足之处在于： 使用智能指针会要求用户也得使用智能指针，非必要不应该提出这种约束; 使用锁也有开销; 同时代码量也增多了，实现上我们希望越简单越好。&lt;/p&gt;
&lt;p&gt;还有更加严重的问题，在某些平台（与编译器和指令集架构有关），==双检锁会失效==！具体可以看&lt;a href=&quot;http://www.drdobbs.com/cpp/c-and-the-perils-of-double-checked-locki/184405726&quot;&gt;这篇文章&lt;/a&gt;，解释了为什么会发生这样的事情。&lt;/p&gt;
&lt;p&gt;因此这里还有第三种的基于 Magic Staic的方法达到线程安全&lt;/p&gt;
&lt;h4 id=&quot;最推荐的懒汉式单例magic-static-局部静态变量&quot;&gt;2.2.3 最推荐的懒汉式单例(magic static )——局部静态变量&lt;/h4&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include &amp;lt;iostream&amp;gt;

class Singleton
{
public:
    ~Singleton(){
        std::cout&amp;lt;&amp;lt;&quot;destructor called!&quot;&amp;lt;&amp;lt;std::endl;
    }
    Singleton(const Singleton&amp;amp;)=delete;
    Singleton&amp;amp; operator=(const Singleton&amp;amp;)=delete;
    static Singleton&amp;amp; get_instance(){
        static Singleton instance;
        return instance;

    }
private:
    Singleton(){
        std::cout&amp;lt;&amp;lt;&quot;constructor called!&quot;&amp;lt;&amp;lt;std::endl;
    }
};

int main(int argc, char *argv[])
{
    Singleton&amp;amp; instance_1 = Singleton::get_instance();
    Singleton&amp;amp; instance_2 = Singleton::get_instance();
    return 0;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果&lt;/p&gt;
&lt;pre class=&quot;txt&quot;&gt;
&lt;code&gt;constructor called!
destructor called!&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种方法又叫做 Meyers' Singleton&lt;a href=&quot;https://stackoverflow.com/questions/449436/singleton-instance-declared-as-static-variable-of-getinstance-method-is-it-thre/449823#449823&quot;&gt;Meyer's的单例&lt;/a&gt;， 是著名的写出《Effective C++》系列书籍的作者 Meyers 提出的。所用到的特性是在C++11标准中的&lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2660.htm&quot; title=&quot;Magic Static&quot;&gt;Magic Static&lt;/a&gt;特性：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;If control enters the declaration concurrently while the variable is being initialized, the concurrent execution shall wait for completion of the initialization.&lt;br/&gt;如果当变量在初始化的时候，并发同时进入声明语句，并发线程将会阻塞等待初始化结束。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这样保证了并发线程在获取静态局部变量的时候一定是初始化过的，所以具有线程安全性。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/questions/246564/what-is-the-lifetime-of-a-static-variable-in-a-c-function&quot; title=&quot;C++静态变量生存期&quot;&gt;C++静态变量的生存期&lt;/a&gt; 是从声明到程序结束，这也是一种懒汉式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这是最推荐的一种单例实现方式：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;通过局部静态变量的特性保证了线程安全 (C++11, GCC &amp;gt; 4.3, VS2015支持该特性);&lt;/li&gt;
&lt;li&gt;不需要使用共享指针，代码简洁；&lt;/li&gt;
&lt;li&gt;注意在使用的时候需要声明单例的引用 &lt;code&gt;Single&amp;amp;&lt;/code&gt; 才能获取对象。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;另外网上有人的实现返回指针而不是返回引用&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;static Singleton* get_instance(){
    static Singleton instance;
    return &amp;amp;instance;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样做并不好，理由主要是无法避免用户使用&lt;code&gt;delete instance&lt;/code&gt;导致对象被提前销毁。还是建议大家使用返回引用的方式。&lt;/p&gt;
&lt;h4 id=&quot;函数返回引用&quot;&gt;2.2.4 函数返回引用&lt;/h4&gt;
&lt;p&gt;有人在网上提供了这样一种单例的实现方式；&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include &amp;lt;iostream&amp;gt;

class A
{
public:
    A() {
        std::cout&amp;lt;&amp;lt;&quot;constructor&quot; &amp;lt;&amp;lt;std::endl;
    }
    ~A(){
        std::cout&amp;lt;&amp;lt;&quot;destructor&quot;&amp;lt;&amp;lt;std::endl;
    }
};


A&amp;amp; ret_singleton(){
    static A instance;
    return instance;
}

int main(int argc, char *argv[])
{
    A&amp;amp; instance_1 = ret_singleton();
    A&amp;amp; instance_2 = ret_singleton();
    return 0;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;严格来说，这不属于单例了，因为类A只是个寻常的类，可以被定义出多个实例，但是亮点在于提供了&lt;code&gt;ret_singleton&lt;/code&gt;的方法，可以返回一个全局（静态）变量，起到类似单例的效果，这要求用户必须保证想要获取 全局变量A ，只通过ret_singleton()的方法。&lt;/p&gt;
&lt;p&gt;以上是各种方法实现单例的代码和说明，解释了各种技术实现的初衷和原因。这里会&lt;strong&gt;比较推荐 C++11 标准下的 2.2.3 的方式&lt;/strong&gt;，即&lt;strong&gt;使用static local的方法&lt;/strong&gt;，简单的理由来说是因为其足够简单却满足所有需求和顾虑。&lt;/p&gt;
&lt;p&gt;在某些情况下，我们系统中可能有多个单例，如果都按照这种方式的话，实际上是一种重复，有没有什么方法可以只实现一次单例而能够复用其代码从而实现多个单例呢？ 很自然的我们会考虑使用模板技术或者继承的方法，&lt;br/&gt;在我的博客中有介绍过如何使用单例的模板。&lt;/p&gt;
&lt;h3 id=&quot;单例的模板&quot;&gt;2.3 单例的模板&lt;/h3&gt;
&lt;h4 id=&quot;crtp-奇异递归模板模式实现&quot;&gt;2.3.1 CRTP 奇异递归模板模式实现&lt;/h4&gt;
&lt;p&gt;代码示例如下：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// brief: a singleton base class offering an easy way to create singleton
#include &amp;lt;iostream&amp;gt;

template&amp;lt;typename T&amp;gt;
class Singleton{
public:
    static T&amp;amp; get_instance(){
        static T instance;
        return instance;
    }
    virtual ~Singleton(){
        std::cout&amp;lt;&amp;lt;&quot;destructor called!&quot;&amp;lt;&amp;lt;std::endl;
    }
    Singleton(const Singleton&amp;amp;)=delete;
    Singleton&amp;amp; operator =(const Singleton&amp;amp;)=delete;
protected:
    Singleton(){
        std::cout&amp;lt;&amp;lt;&quot;constructor called!&quot;&amp;lt;&amp;lt;std::endl;
    }

};
/********************************************/
// Example:
// 1.friend class declaration is requiered!
// 2.constructor should be private


class DerivedSingle:public Singleton&amp;lt;DerivedSingle&amp;gt;{
   // !!!! attention!!!
   // needs to be friend in order to
   // access the private constructor/destructor
   friend class Singleton&amp;lt;DerivedSingle&amp;gt;;
public:
   DerivedSingle(const DerivedSingle&amp;amp;)=delete;
   DerivedSingle&amp;amp; operator =(const DerivedSingle&amp;amp;)= delete;
private:
   DerivedSingle()=default;
};

int main(int argc, char* argv[]){
    DerivedSingle&amp;amp; instance1 = DerivedSingle::get_instance();
    DerivedSingle&amp;amp; instance2 = DerivedSingle::get_instance();
    return 0;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上实现一个单例的模板基类，使用方法如例子所示意，子类需要&lt;strong&gt;将自己作为模板参数T&lt;/strong&gt; 传递给 &lt;code&gt;Singleton&amp;lt;T&amp;gt;&lt;/code&gt; 模板; 同时需要&lt;strong&gt;将基类声明为友元&lt;/strong&gt;，这样才能调用子类的私有构造函数。&lt;/p&gt;
&lt;p&gt;基类模板的实现要点是：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;构造函数需要是 &lt;strong&gt;protected&lt;/strong&gt;，这样子类才能继承；&lt;/li&gt;
&lt;li&gt;使用了&lt;a href=&quot;https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern&quot;&gt;奇异递归模板模式&lt;/a&gt;CRTP(Curiously recurring template pattern)&lt;/li&gt;
&lt;li&gt;get instance 方法和 2.2.3 的static local方法一个原理。&lt;/li&gt;
&lt;li&gt;在这里基类的析构函数可以不需要 virtual ，因为子类在应用中只会用 Derived 类型，保证了析构时和构造时的类型一致&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;不需要在子类声明友元的实现方法&quot;&gt;2.3.2 不需要在子类声明友元的实现方法&lt;/h4&gt;
&lt;p&gt;在 &lt;a href=&quot;https://codereview.stackexchange.com/questions/173929/modern-c-singleton-template&quot;&gt;stackoverflow&lt;/a&gt;上， 有大神给出了&lt;strong&gt;不需要在子类中声明友元的方法&lt;/strong&gt;，在这里一并放出;精髓在于使用一个代理类 token，子类构造函数需要传递token类才能构造，但是把 token保护其起来， 然后子类的构造函数就可以是公有的了，这个子类只有 &lt;code&gt;Derived(token)&lt;/code&gt;的这样的构造函数，这样用户就无法自己定义一个类的实例了，起到控制其唯一性的作用。代码如下。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// brief: a singleton base class offering an easy way to create singleton
#include &amp;lt;iostream&amp;gt;

template&amp;lt;typename T&amp;gt;
class Singleton{
public:
    static T&amp;amp; get_instance() noexcept(std::is_nothrow_constructible&amp;lt;T&amp;gt;::value){
        static T instance{token()};
        return instance;
    }
    virtual ~Singleton() =default;
    Singleton(const Singleton&amp;amp;)=delete;
    Singleton&amp;amp; operator =(const Singleton&amp;amp;)=delete;
protected:
    struct token{}; // helper class
    Singleton() noexcept=default;
};


/********************************************/
// Example:
// constructor should be public because protected `token` control the access


class DerivedSingle:public Singleton&amp;lt;DerivedSingle&amp;gt;{
public:
   DerivedSingle(token){
       std::cout&amp;lt;&amp;lt;&quot;destructor called!&quot;&amp;lt;&amp;lt;std::endl;
   }

   ~DerivedSingle(){
       std::cout&amp;lt;&amp;lt;&quot;constructor called!&quot;&amp;lt;&amp;lt;std::endl;
   }
   DerivedSingle(const DerivedSingle&amp;amp;)=delete;
   DerivedSingle&amp;amp; operator =(const DerivedSingle&amp;amp;)= delete;
};

int main(int argc, char* argv[]){
    DerivedSingle&amp;amp; instance1 = DerivedSingle::get_instance();
    DerivedSingle&amp;amp; instance2 = DerivedSingle::get_instance();
    return 0;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;函数模板返回引用&quot;&gt;2.3.3 函数模板返回引用&lt;/h4&gt;
&lt;p&gt;在 2.2.4 中提供了一种类型的全局变量的方法，可以把一个一般的类，通过这种方式提供一个类似单例的&lt;br/&gt;全局性效果（但是不能阻止用户自己声明定义这样的类的对象）;在这里我们把这个方法变成一个 template 模板函数，然后就可以得到任何一个类的全局变量。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include &amp;lt;iostream&amp;gt;

class A
{
public:
    A() {
        std::cout&amp;lt;&amp;lt;&quot;constructor&quot; &amp;lt;&amp;lt;std::endl;
    }
    ~A(){
        std::cout&amp;lt;&amp;lt;&quot;destructor&quot;&amp;lt;&amp;lt;std::endl;
    }
};

template&amp;lt;typename T&amp;gt;
T&amp;amp; get_global(){
    static T instance;
    return instance;
}

int main(int argc, char *argv[])
{
    A&amp;amp; instance_1 = get_global&amp;lt;A&amp;gt;();
    A&amp;amp; instance_2 = get_global&amp;lt;A&amp;gt;();
    return 0;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到这种方式确实非常简洁，同时类仍然具有一般类的特点而不受限制，当然也因此失去了单例那么强的约束（禁止赋值、构造和拷贝构造）。&lt;br/&gt;这里把函数命名为 &lt;code&gt;get_global()&lt;/code&gt; 是为了强调，这里可以通过这种方式获取得到单例最重要的全局变量特性；但是并不是单例的模式。&lt;/p&gt;
&lt;h2 id=&quot;三何时应该使用或者不使用单例&quot;&gt;三、何时应该使用或者不使用单例&lt;/h2&gt;
&lt;p&gt;根据stackoverflow上的一个高票答案 &lt;a href=&quot;https://stackoverflow.com/questions/86582/singleton-how-should-it-be-used&quot;&gt;singleton-how-should-it-be-used&lt;/a&gt;：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;You need to have one and only one object of a type in system&lt;br/&gt;==你需要系统中只有&lt;strong&gt;唯一&lt;/strong&gt;一个实例存在的类的&lt;strong&gt;全局&lt;/strong&gt;变量的时候才使用单例==。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;反对单例的理由&quot;&gt;反对单例的理由&lt;/h3&gt;
&lt;p&gt;当然程序员是分流派的，有些是反对单例的，有些人是反对设计模式的，有些人甚至连面向对象都反对 :).&lt;/p&gt;
&lt;p&gt;反对单例的理由有哪些：&lt;/p&gt;
&lt;h2 id=&quot;参考文章&quot;&gt;参考文章&lt;/h2&gt;
&lt;p&gt;在本文写作的过程中参考了一些博客和stackoverflow 的回答，以超链接的方式体现在文中。另外还有一些我觉得非常精彩的回答，放在下面供读者拓展阅读&lt;/p&gt;
&lt;p&gt;推荐阅读：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;高票回答中提供了一系列有益的链接(&lt;a href=&quot;https://stackoverflow.com/questions/1008019/c-singleton-design-pattern/1008289#1008289&quot; class=&quot;uri&quot;&gt;https://stackoverflow.com/questions/1008019/c-singleton-design-pattern/1008289#1008289&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;面试中的单例(&lt;a href=&quot;http://www.cnblogs.com/loveis715/archive/2012/07/18/2598409.html&quot; class=&quot;uri&quot;&gt;http://www.cnblogs.com/loveis715/archive/2012/07/18/2598409.html&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;一些观点(&lt;a href=&quot;https://segmentfault.com/q/1010000000593968&quot; class=&quot;uri&quot;&gt;https://segmentfault.com/q/1010000000593968&lt;/a&gt;)&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Sat, 16 Feb 2019 15:35:00 +0000</pubDate>
<dc:creator>行者孙</dc:creator>
<og:description>[toc] C++ 单例模式总结与剖析 单例可能是最常用的简单的一种设计模式，实现方法多样，根据不同的需求有不同的写法; 同时单例也有其局限性，因此有很多人是反对使用单例的。本文对C++ 单例的常见写</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sunchaothu/p/10389842.html</dc:identifier>
</item>
<item>
<title>springboot学习之授权Spring Security - 夏天里的Jasmine</title>
<link>http://www.cnblogs.com/qianjinyan/p/10363504.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qianjinyan/p/10363504.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;SpringSecurity核心功能：认证、授权、攻击防护（防止伪造身份）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;涉及的依赖如下：&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &amp;lt;artifactId&amp;gt;spring-boot-starter-security&amp;lt;/artifactId&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/dependency&amp;gt;&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-security&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;新建一个项目，添加如上依赖【添加依赖之后默认开始授权验证】，在控制器controller中测试，指定url，比如&lt;/span&gt;
&lt;/p&gt;&lt;/pre&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
&lt;span&gt;@Controller
public class UserController {

    @RequestMapping(value=&quot;/hello&quot;)
    @ResponseBody
    public String hello(){return &quot;=======Welcome to HelloWorld==============&quot;;}
}
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如上，原本启动项目后，在地址栏中输入&lt;a href=&quot;http://localhost:8080/hello&quot; target=&quot;_blank&quot;&gt;http://localhost:8080/hello&lt;/a&gt;应该显示返回的内容&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然而此次加了安全验证后，不管url中访问的地址是什么，hello还是hello111，均返回login页面，如下&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1064427/201902/1064427-20190211214606053-1538900330.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;此时系统都没有连DB，用户名和密码是什么？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;控制台中有消息，比如Using generated security password: 76dade1c-f190-44f8-915c-7a6b6917fb9a【每次随机生成的密码】&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;将用户名 &lt;span&gt;&lt;strong&gt;user&lt;/strong&gt;&lt;/span&gt; 和 密码 &lt;span&gt;&lt;strong&gt;76dade1c-f190-44f8-915c-7a6b6917fb9a&lt;/strong&gt;&lt;/span&gt; 填入上面对话框中，点击按钮Sign in&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1064427/201902/1064427-20190211214813673-1064582040.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 若之前访问的页面是控制器中配置的页面&lt;a href=&quot;http://localhost:8080/hello&quot; target=&quot;_blank&quot;&gt;http://localhost:8080/hello&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;则此时能成功显示&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1064427/201902/1064427-20190211215015743-1523318928.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;若之前访问的页面是其他的，控制器中未配置的，则重定向后返回页面不存在。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;当前自己的项目中，总不能用系统生成的密码进行登录获得权限，那不要被别人笑死。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;进阶阶段：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;我简单创建了一张表，希望该表的人输入匹配的用户名和密码后，方能登录。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;42&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
&lt;span&gt;CREATE TABLE `admin_user`(
`id` int(4) NOT NULL AUTO_INCREMENT,
`username` VARCHAR(100),
`password` VARCHAR(100),
`role` VARCHAR(100),
`realname` VARCHAR(100),
`mobile` VARCHAR(2000),
`state` BIT default 0,
`info` VARCHAR(200),
PRIMARY KEY (`id`)
)ENGINE=InnoDB AUTO_INCREMENT=300;
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　塞了几条数据进去，然后我希望用户在页面上进行登录，那我必须还要创建一个User对象，所谓登录就是传入username和password匹配的场景，只要匹配，就登录成功，跳转到之前的url&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
&lt;span&gt;public class User {

    private int id;
    private String name;
    private String password; 省略 getter and setter｝
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
&lt;span&gt;public interface UserService {

    User login(String name, String password);
}
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
&lt;span&gt;@Service
public class UserServiceImpl implements UserService {

    @Autowired
    private JdbcTemplate jdbcTemplate;

    @Override
    public User login(String name, String password) {
        String sql =&quot;select * from admin_user where username =? and password = ?&quot;;
        User user =jdbcTemplate.queryForObject(sql,new UserRowMapper(),name,password);
        return user;

    }
}
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
&lt;span&gt;public class UserRowMapper implements RowMapper&amp;lt;User&amp;gt; {
    @Override
    public User mapRow(ResultSet resultSet, int i) throws SQLException {
        //此处要使用表中的字段，不能使用属性
        int id =resultSet.getInt(&quot;id&quot;);
        String username = resultSet.getString(&quot;username&quot;);
        String password = resultSet.getString(&quot;password&quot;);
        //String role = resultSet.getString(&quot;role&quot;);

        User user = new User();
        user.setId(id);
        user.setName(username);
        user.setPassword(password);

        return user;
    }
}
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;登录的方法啪啪啪很快就写好了，我要怎么让系统知道，所有的请求，要先进行登录呢，登录的URL是什么？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;先看看别人的代码，貌似是实现了UserDetailsService 接口，而点进去发现该接口就一个方法&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
&lt;span&gt;package org.springframework.security.core.userdetails;

public interface UserDetailsService {
    UserDetails loadUserByUsername(String var1) throws UsernameNotFoundException;
}
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　通过一个String类型的变量val1，获取用户的详细信息。。。怎么跟我想的不太一样？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;再点进去发现UserDetails 也是一个接口&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
&lt;span&gt;package org.springframework.security.core.userdetails;

import java.io.Serializable;
import java.util.Collection;
import org.springframework.security.core.GrantedAuthority;

public interface UserDetails extends Serializable {
    Collection&amp;lt;? extends GrantedAuthority&amp;gt; getAuthorities();

    String getPassword();

    String getUsername();

    boolean isAccountNonExpired();

    boolean isAccountNonLocked();

    boolean isCredentialsNonExpired();

    boolean isEnabled();
}
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　一个集合，收集权限，结合做过的项目，有的权限是超级管理员，有的权限是普通管理员，又或者有的删，有新增，有更新等等权限；两个返回String的方法；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;还有判断账户是否过期，被锁，验证是否过期，是否开启了。。。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　看来光看别人的代码，还是丈二和尚摸不着头脑呢，去看看官方文档吧&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://spring.io/projects/spring-security&quot; target=&quot;_blank&quot;&gt;https://spring.io/projects/spring-security&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://spring.io/guides/topicals/spring-security-architecture&quot; target=&quot;_blank&quot;&gt;https://spring.io/guides/topicals/spring-security-architecture&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;英文原文我就不粘贴了，翻译过来，大意就是：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;应用程序权限归结于两个独立的问题：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. 你是谁&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. 你有什么样的权限&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一般叫法是权限控制 或者 授权&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;下面开始讲框架中的源码，通过看源码可以了解设计的思路&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. 授权策略中主要的接口是&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;typ&quot;&gt;AuthenticationManager&lt;/span&gt;&lt;/code&gt;，并且只有一个方法&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
&lt;span&gt;public interface AuthenticationManager {

  Authentication authenticate(Authentication authentication)
    throws AuthenticationException;

}　&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　验证管理员在方法authenticate()可以做三件事&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;a. 输入的信息是有效的当事人，验证通过，返回Authentication &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;b. 输入的信息是无效的当事人，验证不通过，返回&lt;code&gt;AuthenticationException&lt;/code&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;c. 无法判断的时候，返回一个null&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;看到这儿，就觉得我想通过查询 用户名 = 输入的用户名 且 密码 =输入密码的想法真是异想天开了。&lt;/span&gt;&lt;/p&gt;


&lt;h3 id=&quot;_creating_and_customizing_filter_chains&quot;&gt;&lt;span&gt;Filter Chains，过滤链，默认对所有的范文url进行过滤，意味着打开这个网站的任何链接，都弹出授权页面&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;而如果像如下的例子，则可以在foo下的下url不进行授权验证，说白了，不登录，这个url下也可以访问。 想想日常使用场景，比如总要有个注册页面吧，不能全面链接都要求登录。不注册如何登录呢？&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
&lt;span&gt;@Configuration
@Order(SecurityProperties.BASIC_AUTH_ORDER - 10)
public class ApplicationConfigurerAdapter extends WebSecurityConfigurerAdapter {
  @Override
  protected void configure(HttpSecurity http) throws Exception {
    http.antMatcher(&quot;/foo/**&quot;)
     ...;
  }
}
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;用户登录了之后，要怎么查看个人信息，传入@AuthenticationPrincipal，当事人对象Principal principal&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
&lt;span&gt;@RequestMapping(&quot;/foo&quot;)
public String foo(@AuthenticationPrincipal User user) {
  ... // do stuff with user
}
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
&lt;span&gt;@RequestMapping(&quot;/foo&quot;)
public String foo(Principal principal) {
  Authentication authentication = (Authentication) principal;
  User = (User) authentication.getPrincipal();
  ... // do stuff with user
}
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　使用规则介绍完了，花了两天把授权一个可用的项目的代码整理出来，贴上github路径&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/JasmineQian/buglist&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://github.com/JasmineQian/buglist&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;其中用的是springboot 2.1.2 Realease 版本，和以前的版本稍微有一点区别，比如必须对密码加密校验，So存进去的密码处，必须加密之后存入数据库&lt;/p&gt;
&lt;pre readability=&quot;5&quot;&gt;
&amp;lt;parent&amp;gt;&lt;br/&gt;&amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;&lt;br/&gt;&amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;&lt;br/&gt;&amp;lt;version&amp;gt;2.1.2.RELEASE&amp;lt;/version&amp;gt;&lt;br/&gt;&amp;lt;relativePath/&amp;gt; &amp;lt;!-- lookup parent from repository --&amp;gt;&lt;br/&gt;&amp;lt;/parent&amp;gt;&lt;p&gt;程序中验证的用户名和密码
&lt;/p&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1064427/201902/1064427-20190216235659601-1158995310.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
自己建一张表，叫做qa_user,添加如下数据&lt;br/&gt;2 admin $2a$10$A4EZrzoXqj4mVyXiw/fsp.mJ.Ne5aVAMWrMK0mAb2zY7lJ/H6Jryi admin ROLE_USER,ROLE_ADMIN
&lt;/pre&gt;


&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 16 Feb 2019 15:26:00 +0000</pubDate>
<dc:creator>夏天里的Jasmine</dc:creator>
<og:description>SpringSecurity核心功能：认证、授权、攻击防护（防止伪造身份） 涉及的依赖如下： 如上，原本启动项目后，在地址栏中输入http://localhost:8080/hello应该显示返回的内</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qianjinyan/p/10363504.html</dc:identifier>
</item>
<item>
<title>认识RabbitMQ交换机模型 - JJian</title>
<link>http://www.cnblogs.com/jian0110/p/10389780.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jian0110/p/10389780.html</guid>
<description>&lt;blockquote readability=&quot;14&quot;&gt;

&lt;p&gt;　　RabbitMQ是消息队列中间件（Message Queue Middleware）中一种，工作虽然有用到，但是却没有形成很好的整体包括，主要是一些基础概念的认识，这里通过阅读《RabbitMQ实战指南》整理笔记并进行代码实践，更好地理解RabbitMQ！&lt;/p&gt;
&lt;p&gt;本文只通过讲解RabbitMQ的一些基础概念，主要是RabbitMQ的“生产者-消费者”模型涉及到的交换器、路由键、绑定键、消息路由规则等，下一篇会有简单介绍RabbitMQ的运转、RabbitMQ部署，Java代码实践。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;需要电子书PDF版《RabbitMQ实战指南》（高清带标签）可以评论或者联系我&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr/&gt;

&lt;p&gt;　　讲解RabbitMQ之前先认识下MQ作为消息中间件的作用（优点），使用的时候如果不去思考为什么用MQ，怎样更好地才能达到它的作用的话，那都是毫无意义的使用！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　   &lt;span&gt;1、解耦：&lt;/span&gt;&lt;/strong&gt;可以很好地屏蔽应用程序及平台之间的特性，充当中间者，松散耦合应用程序及平台，它们彼此不需要了解远程过程调用RPC与网络协议的细节；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;span&gt;2、异步通信：&lt;/span&gt;&lt;/strong&gt;能提供C/S之间同步与异步连接，在任何时刻都可以将消息进行传送或者存储转发；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　   &lt;span&gt;&lt;span&gt;3、可恢复性：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;当消息接收方宕机或网络不通的情况下，消息转储于MQ中，直到网络恢复或接收方恢复再进行转发；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;span&gt;4、扩展性：&lt;/span&gt;&lt;/strong&gt;提高消息入队列和处理效率是容易的，只需要另外增加处理过程即可，不需要改变代码，也不需要调节参数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;span&gt;5、顺序性：&lt;/span&gt;&lt;/strong&gt;由于大部分MQ支持队列模式，自然也就能保证一定的数据处理顺序；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;span&gt;&lt;span&gt;6、缓冲&lt;/span&gt;：&lt;/span&gt;&lt;/strong&gt;MQ通过一个缓冲层来帮助任务最高效率执行，写入MQ的处理会尽可能快速。&lt;/p&gt;

&lt;p&gt;　　RabbitMQ整体的模型其实是一种&lt;span&gt;&lt;strong&gt;“生产者-消费者”&lt;/strong&gt;&lt;/span&gt;模型，发送消息的一方称之为生产者，接收消息一方称之为消费者。中间会有交换器、队列、Broker等概念。下图是简单的RabbitMQ的模型图（截图来自于《RabbitMQ实战指南》，以下截图同）&lt;/p&gt;

&lt;p&gt;　　　　　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1352849/201902/1352849-20190216221233815-2034466708.png&quot; alt=&quot;&quot; width=&quot;767&quot; height=&quot;357&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;　　1、生产者-消费者与RabbitMQ Broker　&lt;/h2&gt;
&lt;p&gt;　　　　（1）Producer：&lt;/p&gt;
&lt;p&gt;　　　　　　投递消息的一方，创建了消息之后发布到RabbitMQ中，&lt;span&gt;&lt;strong&gt;消息主要包括消息体（Payload）与Label标签&lt;/strong&gt;&lt;/span&gt;，消息体可以通常是业务数据，比如JSON等，Label则用来表述这条消息，比如一个交换机名称和一个路由键。&lt;/p&gt;
&lt;p&gt;生产者把消息交由RabbitMQ，之后会根据标签把消息发送给感兴趣的消费者。&lt;/p&gt;
&lt;p&gt;　　　　（2 Consumer：&lt;/p&gt;
&lt;p&gt;　　　　　　消费者，接收消息的一方，连接到RabbitMQ服务器，并订阅到队列上，&lt;span&gt;&lt;strong&gt;当消费者消费一条消息时只是消费了消息体payload，在消息路由过程中，消息的标签会丢失&lt;/strong&gt;&lt;/span&gt;，存入队列中只有消息体。消费者不需要知道生产者是谁。&lt;/p&gt;
&lt;p&gt;　　　　（3）Broker：&lt;/p&gt;
&lt;p&gt;　　　　　　消息中间件的服务节点，一个RabbitMQ Broker可以简单地看做一个RabbitMQ服务节或者RabbitMQ服务实例（&lt;span&gt;&lt;strong&gt;大多数情况下可以看做是一台RabbitMQ的服务器&lt;/strong&gt;&lt;/span&gt;）&lt;/p&gt;
&lt;p&gt;　　　　由上图可知，消息队列运转过程是这样的：&lt;/p&gt;
&lt;p&gt;　　　　&lt;span&gt;&lt;strong&gt;封装好的消息发送（AMQP命令为Basic.publish）到Broker中，消费者订阅并接收（Basic.Get/Basic.Consume）消息，之后再进行业务逻辑处理（可以再开另外的进程，不需要与接收消息同一个进程）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　　　　　　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1352849/201902/1352849-20190216221802597-564341280.png&quot; alt=&quot;&quot; width=&quot;781&quot; height=&quot;439&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;　　　2、队列&lt;/h2&gt;
&lt;p&gt;　　　　　　　RabbitMQ中消息都只能存储在队列中，当多个消费者订阅一个队列时，队列中的消息会被平均分摊（Round-Robin），也就是并不是每个消费者都能收到所有的消息并处理。&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1352849/201902/1352849-20190216222034950-1552099377.png&quot; alt=&quot;&quot; width=&quot;604&quot; height=&quot;175&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　注意以下几点：&lt;/p&gt;
&lt;p&gt;　　　　　　　　1）&lt;strong&gt;&lt;span&gt;对于生产者生产的消息到队列中，并不是平均分摊&lt;/span&gt;。&lt;/strong&gt;而是通过路由键、绑定键、交换器类型三个决定消息最终被哪个消费者消费，之后会介绍！&lt;/p&gt;
&lt;p&gt;　　　　　　　　2）&lt;span&gt;&lt;strong&gt;生产者与消费者之间的连接，并不只是通过队列那么简单连接&lt;/strong&gt;&lt;/span&gt;，而是外加通过TCP连接与信道Channel，之后也会介绍&lt;/p&gt;
&lt;h2&gt;　　　　3、交换器、路由键、绑定　　　&lt;/h2&gt;
&lt;p&gt;　　　　　　　　（1） &lt;strong&gt;交换器（Exchange, X&lt;/strong&gt;&lt;strong&gt;）：&lt;/strong&gt;由上图交换机模型图中看不到交换器这个东西，但实际上是存在的，生产者将消息投递到队列，然而真实情况是：&lt;strong&gt;&lt;span&gt;生产者将消息发送到Exchange，由Exchange再路由到一个或多个队列中；&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　　　　　　　　　　交换器的类型有fanout、direct、topic、headers这四种类型&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;，不同的类型的交换器有其独特的匹配规则，这里的匹配规则其实就是决定消息最终路由到哪的队列的关键，具体请往下看&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1352849/201902/1352849-20190216223218301-2069825942.png&quot; alt=&quot;&quot; width=&quot;584&quot; height=&quot;208&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　　　　　　　（2） &lt;strong&gt;路由键（RoutingKey&lt;/strong&gt;）：&lt;span&gt;&lt;strong&gt;生产者将消息发送给交换器的时候，会指定RoutingKey指定路由规则&lt;/strong&gt;&lt;/span&gt;，实际情况是需要将RoutingKey、交换器类型、绑定键联合使用才能最终生效。当交换器类型与BindingKey固定情况下，通过执行RoutingKey来决定消息流向哪里。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　　　　　（3）绑定（BindingKey）&lt;/strong&gt;：通过&lt;strong&gt;&lt;span&gt;绑定键将交换器与队列关联起来，这样RabbitMQ就知道如何正确地将消息路由到队列，&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;其实绑定键也是一种路由键的一种，不过是用在绑定交换器与队列的时候。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　　　　　　　　　　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1352849/201902/1352849-20190216223437649-1474598574.png&quot; alt=&quot;&quot; width=&quot;590&quot; height=&quot;225&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　&lt;span&gt;　&lt;strong&gt;总结有以下三点：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　　　　　　　&lt;/strong&gt;（1）&lt;span&gt; &lt;/span&gt;&lt;span&gt;&lt;strong&gt;生产者将消息发送给哪个Exchange是需要由RoutingKey决定的，生产者需要将Exchange与哪个队列绑定时需要由BindingKey决定的&lt;/strong&gt;&lt;/span&gt;（当然还要看交换器类型，BindingKey不一定会生效，如fanout类型交换器）；&lt;/p&gt;
&lt;p&gt;　　　　　　　   　　（2） 生产者将消息发送给交换器时，需要一个RoutingKey，&lt;span&gt;&lt;strong&gt;当BindingKey和RoutingKey相匹配时，消息会被路由到对象的队列中&lt;/strong&gt;&lt;/span&gt;（当然也要看交换器类型）。&lt;/p&gt;
&lt;p&gt;　　　　　　　   　　（3） &lt;span&gt; &lt;strong&gt;BindingKey其实也属于路由键的一种&lt;/strong&gt;&lt;/span&gt;，在使用邦定的时候，需要的路由键是BingdingKey，在发送消息的时，需要的路由键是RoutingKey&lt;/p&gt;
&lt;h2&gt;　　　　4、交换器类型&lt;/h2&gt;
&lt;p&gt;　　　　　　　　为什么非要介绍交换器类型呢？上文中也提到过交换器类型关系到具体的消息路由途径，处路由键、绑定键之外的还需要关注交换器的类型。不同的交换器会有不同的匹配规则。&lt;/p&gt;
&lt;p&gt;　　　　　　　　RabbitMQ常用的交换器类型有fanout、direct、topic、headers这四种类型&lt;/p&gt;
&lt;p&gt;　　　　　　　　（1）&lt;strong&gt;fanout&lt;/strong&gt;：&lt;span&gt;&lt;strong&gt;它会把所有的交换器上的消息路由到所有与该交换器邦定的队列中，不需要BindingKey生效&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　（2）&lt;strong&gt;direct&lt;/strong&gt;：它会把&lt;span&gt;&lt;strong&gt;消息路由到BindingKey与RoutingKey完全匹配的队列中&lt;/strong&gt;&lt;/span&gt;。比如在发送消息的时候，设置Label中RoutingKey为warning，则消息会路由到Queue1与Queue2上（请看下图）。&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1352849/201902/1352849-20190216225028044-974382944.png&quot; alt=&quot;&quot; width=&quot;745&quot; height=&quot;266&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　　　　　　　（3）&lt;strong&gt;topic&lt;/strong&gt;：是direct上的扩展，&lt;span&gt;&lt;strong&gt;同样是利用RoutingKey与BindingKey相匹配，但是匹配规则不一样，支持模糊匹配&lt;/strong&gt;。&lt;/span&gt;有如下的规则&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;RoutingKey为一个点号“.”分隔的字符串，每个被隔开的独立字符串即为一个单词，是匹配的单位；&lt;/li&gt;
&lt;li&gt;BindingKey和RoutingKey一样，也是&quot;.&quot;分割的字符串；&lt;/li&gt;
&lt;li&gt;但不同的是BindingKey，可以用“#”，“*”进行类似于占位符的模糊匹配，“#”表示一个单词，&quot;*&quot;表示多个单词（也可以是零个）　　　　　　　　　　　　　　　　　&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　　　　　　　　　比如:&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　RoutingKey为com.hidden.client的消息只会到队列Queue2中：因为只有Queue2的BindingKey=*.*.client匹配com.hidden.client&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　RoutingKey为com.rabbitmq.client的消息会到队列Queue1-2中: 因为Queue1的BindingKey=*.rabbitmq.*.匹配com.rabbitmq.client，Queue2的BindingKey=*.*.client匹配com.rabbitmq.client&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　RoutingKey为java.rabbitmq.demo的消息只会到队列Queue1中：因为只有Queue1的BindingKey=*.rabbitmq.*.匹配java.rabbitmq.demo&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　RoutingKey为java.util.concurrent的消息会被丢弃或者返回给生产者（需要设置）&lt;/p&gt;
&lt;p&gt; 　　　　　　　　　　　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1352849/201902/1352849-20190216225124446-896629330.png&quot; alt=&quot;&quot; width=&quot;732&quot; height=&quot;256&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　　　　　　　（4）&lt;strong&gt;headers&lt;/strong&gt;：依赖发送消息内容中的hearders属性进行匹配，在绑定队列和交换器时指定一组键值对，这里的也就是headers，当发送消息到交换器时，RabbitMQ会获取到该消息的headers，通过比较会路由到相关队列中，这种交换器性能会很差，一般不会使用。&lt;/p&gt;


&lt;hr/&gt;
&lt;p&gt;　　　　　&lt;span&gt;以上内容总结起来只是介绍了，RabbitMQ的从生产者产生消息到消费者消费消息过程中涉及到的概念。还未介绍具体的RabbitMQ是如何运转的，比如生产者是怎样建立建立的，消费者又是怎样读取消息的。这将是下一篇主要介绍的。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 16 Feb 2019 15:17:00 +0000</pubDate>
<dc:creator>JJian</dc:creator>
<og:description>前言 RabbitMQ是消息队列中间件（Message Queue Middleware）中一种，工作虽然有用到，但是却没有形成很好的整体包括，主要是一些基础概念的认识，这里通过阅读《RabbitMQ</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jian0110/p/10389780.html</dc:identifier>
</item>
<item>
<title>观察者模式 - huansky</title>
<link>http://www.cnblogs.com/huansky/p/10389751.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huansky/p/10389751.html</guid>
<description>&lt;p&gt;当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知它的依赖对象。观察者模式属于行为型模式。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;解释：&lt;span&gt;简单来说对象 A 需要关注对象 B 的状态，根据对象 B 的不同状态来做一些调整。比如播放器的 UI 变化，会依赖当前的播放状态，一旦播放状态改变了，就需要调整 UI 的显示。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。&lt;/li&gt;
&lt;/ul&gt;&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;一个对象必须通知其他对象，而并不知道这些对象是谁。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;根据上面说的，下面我们来实现一个简单的观察者模式。&lt;/p&gt;
&lt;h2&gt; 观察者&lt;/h2&gt;
&lt;p&gt;先定义一个观察者接口，具体的观察者都需要实现该接口。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.sjq.observer;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;*
 * 抽象观察者
 * 定义了一个update()方法，当被观察者调用notifyObservers()方法时，观察者的update()方法会被回调。&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Observer {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; update(String message);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接着，就是一个具体的观察者，在 update 中添加数据改变后的操作逻辑。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.sjq.observer;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 观察者
 * 实现了update方法
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; User &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Observer {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String message;
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; User(String name) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
    }
    
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; update(String message) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.message =&lt;span&gt; message;
        read();
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; read() {
        System.out.println(name &lt;/span&gt;+ &quot; 收到推送消息： &quot; +&lt;span&gt; message);
    }
    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt; 被观察者&lt;/h2&gt;
&lt;p&gt;同样的，需要定义一个被观察者接口，所有具体的被观察者对象都需要实现该接口。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.sjq.observer;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;*
 * 抽象被观察者接口
 * 声明了添加、删除、通知观察者方法
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Observerable {
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; registerObserver(Observer o);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; removeObserver(Observer o);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; notifyObserver();
    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 定义具体的被观察者对象，实现了 Observerable 接口，对 Observerable 接口的三个方法进行了具体实现，同时有一个 List 集合，用以保存注册的观察者，等需要通知观察者时，遍历该集合即可。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.sjq.observer;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.ArrayList;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 被观察者，也就是微信公众号服务
 * 实现了Observerable接口，对Observerable接口的三个方法进行了具体实现
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; WechatServer &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Observerable {
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;注意到这个List集合的泛型参数为Observer接口，设计原则：面向接口编程而不是面向实现编程&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; List&amp;lt;Observer&amp;gt;&lt;span&gt; list;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String message;
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; WechatServer() {
        list &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Observer&amp;gt;&lt;span&gt;();
    }
    
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; registerObserver(Observer o) {
        
        list.add(o);
    }
    
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; removeObserver(Observer o) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;list.isEmpty())
            list.remove(o);
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;遍历&lt;/span&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; notifyObserver() {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; list.size(); i++&lt;span&gt;) {
            Observer oserver &lt;/span&gt;=&lt;span&gt; list.get(i);
            oserver.update(message);
        }
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setInfomation(String s) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.message =&lt;span&gt; s;
        System.out.println(&lt;/span&gt;&quot;微信服务更新消息： &quot; +&lt;span&gt; s);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;消息更新，通知所有观察者&lt;/span&gt;
&lt;span&gt;        notifyObserver();
    }

}&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;代码测试&lt;/h2&gt;
&lt;p&gt;完成上面的工作之后，咱们就可以测试咱们写的代码了，看看能不能跑起来。具体如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.sjq.observer;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test {
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        WechatServer server &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; WechatServer();
        
        Observer userZhang &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; User(&quot;ZhangSan&quot;&lt;span&gt;);
        Observer userLi &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; User(&quot;LiSi&quot;&lt;span&gt;);
        Observer userWang &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; User(&quot;WangWu&quot;&lt;span&gt;);
        
        server.registerObserver(userZhang);
        server.registerObserver(userLi);
        server.registerObserver(userWang);
        server.setInfomation(&lt;/span&gt;&quot;PHP是世界上最好用的语言！&quot;&lt;span&gt;);
        
        System.out.println(&lt;/span&gt;&quot;----------------------------------------------&quot;&lt;span&gt;);
        server.removeObserver(userZhang);
        server.setInfomation(&lt;/span&gt;&quot;JAVA是世界上最好用的语言！&quot;&lt;span&gt;);
        
    }
}&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;


&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt; Android 中 Adapter 应用广泛，其实在 adapter 中就存在观察者模式得应用。比如 ListView, 当我们调用 setAdapter() 时候，内部是通过观察者模式来通知数据变化的，当数据发生变化，就会通知 ListView 自身去重新绘制。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;BrocastReceive 广播。有动态注册和静态注册，其实也是观察者模式得一种应用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;另外经常可见一些 addXXXListener 方法，其实这类也可以当做是观察者的一种体现。 &lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;&lt;span&gt;参考文献&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;1、&lt;a href=&quot;http://www.runoob.com/design-pattern/observer-pattern.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;http://www.runoob.com/design-pattern/observer-pattern.html&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;2、&lt;/span&gt;&lt;/span&gt;&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/luohanguo/p/7825656.html&quot;&gt;JAVA设计模式之观察者模式&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 16 Feb 2019 15:13:00 +0000</pubDate>
<dc:creator>huansky</dc:creator>
<og:description>定义 当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知它的依赖对象。观察者模式属于行为型模式。 解释：简单来说对象 A 需要关注对</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/huansky/p/10389751.html</dc:identifier>
</item>
<item>
<title>当我们讨论性能测试时，我们在说什么？ - 老_张</title>
<link>http://www.cnblogs.com/imyalost/p/10353954.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/imyalost/p/10353954.html</guid>
<description>&lt;p&gt;&lt;span&gt;说起性能测试，大家会想到哪些词？录制脚本、模拟高并发？性能需求分析、业务流程梳理？监控资源耗用、性能瓶颈定位？优化代码处理逻辑、提升服务器配置？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但这真的是性能测试的本质和最终目的么？这篇博客，聊聊我对软件性能的一些看法和思考。。。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先明确一点：&lt;strong&gt;技术的存在是为了解决实际的业务发展中遇到的问题和痛点！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;随着互联网时代不断深入生活工作的各方面，绝大多数的软件系统都会面临如下三个挑战：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、日益增长的用户数量；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、日渐复杂的业务场景；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、急剧膨胀的数据冲击；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这对于软件系统而言，就意味着&lt;strong&gt;及时高效的处理能力、更好的服务可用性以及长期运行的稳定性&lt;/strong&gt;等要求。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;从以上几点要求出发，站在性能测试的角度，来谈谈我们需要注意哪些事项。。。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;更及时高效的处理能力&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/983980/201902/983980-20190216194236769-603424060.png&quot; alt=&quot;&quot; width=&quot;662&quot; height=&quot;305&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在互联网最初的年代，有二五八原则一说。意思就是对用户而言，在页面做一个功能操作，如果能在2秒能出现用户期待的内容，那么用户体验就是比较好的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果5秒之内可以返回结果，那么对用户来说就是可以接受的范围，如果超过8秒，绝大多数用户就会选择离开或退出该页面。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;虽然这只是一个笼统的概念，但也能看出用户对软件系统处理能力的容忍性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;近几年随着网络通讯技术的不断发展，以及硬件设施的不断提升，导致用户对软件处理能力越来越低的容忍力。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;从性能优化角度出发，就需要我们尽力&lt;strong&gt;保持和降低系统的99%RT&lt;/strong&gt;（即一段时间内请求响应时间从低到高排序，低于99%响应时间的上限边界值）的同时，&lt;strong&gt;提高单位时间内的处理能力&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;请求响应时间=请求发送耗时+请求解析耗时+请求处理耗时+处理结果返回耗时&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;提高处理能力和降低响应时间，有很多技术方案可以实现，比如：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;提高网络传输速率、优化请求传输方式（串行→并行→连接复用→管道化）、增加缓存、优化代码处理方式、增加处理请求的机器数量、提升机器配置等方式。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;更好的服务可用性&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/983980/201902/983980-20190216194032435-70437758.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;什么是可用性（Usability）？可用性实际上并不是一个具体的东西，也没有明确的定义。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;个人觉得Jakob Nielsen大师提出的可用性五大属性，就很客观全面的介绍了可用性的特点，它们分别是：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;可学习性（Learnability）&lt;/strong&gt;：初次接触这个设计时，用户完成基本任务的难易程度；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;效率 （Efficiency）&lt;/strong&gt;：用户能多快完成任务；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;可记忆性（Memorability）&lt;/strong&gt;：当用户一段时间没有使用产品后，是否能马上回到以前的熟练程度；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;出错（Errors）&lt;/strong&gt;：用户能否从错误中恢复（从系统角度出发，可以理解为容错性）；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;满意度（Satisfaction）：&lt;/strong&gt;用户对产品的主观满意度。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果真要给出一个定义，那么我们可以这样理解：&lt;strong&gt;可用性是指在特定的使用场景下，产品为特定用户用于特定目的时所具有的有效性、效率和主观满意度&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;从可用性五大属性出发，站在性能优化角度，就要求我们做如下的一些事情，来不断提升软件服务可用性：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可学习性：尽可能减少用户操作的步骤，优化业务逻辑；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;效率：提升响应时间和系统的处理能力（回到上面提到的及时高效的处理能力）；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可记忆性：人性化的提示，导航能力，是否符合特定用户的操作习惯；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;出错：提升系统的容错能力和恢复能力；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;满意度：提高用户体验，做好用户需求调研和场景建模分析；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果只讨论技术保障方案，我们需要做好服务治理、服务解耦，通过主从模式、系统集群负载均衡、双机双工、分布式等方式，来保证系统在高可用的同时，降低故障恢复时间。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;长期运行的稳定性&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/983980/201902/983980-20190216194605915-1405873640.png&quot; alt=&quot;&quot; width=&quot;667&quot; height=&quot;374&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一般来说，系统的稳定性指标要求7*24小时或者5*8小时，系统的存活时间越长，意味着系统越稳定，这个要根据系统具体的业务定位来确定。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;现在而言，系统的稳定性要求已经不仅仅是存活时间，还要求运行过程中的&lt;strong&gt;保持服务的高可用、及时处理能力、容错能力以及出现故障的及时恢复能力&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那么如何保证系统的稳定性呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;容错能力&lt;/strong&gt;：即系统对于自身出现的错误具有一定的屏蔽或处理能力。常见的容错手段包括如下几点：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;①、失败重试机制；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;②、多机备份自动切换；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;③、设置合理的TimeOut；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;④、服务解耦，微服务模式；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;⑤、权重选举，服务降级；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;更多阅读：&lt;a href=&quot;https://blog.csdn.net/tanga842428/article/details/79664605&quot; target=&quot;_blank&quot;&gt;亿级web系统的高容错性实践&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;故障恢复能力&lt;/strong&gt;：即系统能否从出错或故障中及时恢复正常服务水平的能力。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一般来说会根据故障的严重等级和优先级，确定不同等级的故障需要在多久时间内恢复正常提供服务的能力。常见的故障有如下几种：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;①、硬件及有关设备故障；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;②、软件系统故障；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;③、数据故障；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;④、网络故障；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为了应对如上的几种故障，常见的一些容灾恢复方案有如下几种：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;①、系统需要具有自我诊断、故障报告及指示处理方法的能力，以及具备冗余及自动切换能力；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;②、监控到故障发生时，系统需要具备及时隔离、服务降级、服务快速切换的能力；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;③、主从热备，多机冷备，异地多活等措施；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;更多阅读：&lt;a href=&quot;https://blog.csdn.net/xiaokuang513204/article/details/8629415&quot; target=&quot;_blank&quot;&gt;不容忽视的软件可恢复测试&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;回到开头提到的内容：&lt;strong&gt;技术的存在是为了解决实际的业务发展中遇到的问题和痛点！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;随着业务的不断发展，软件系统面临着&lt;strong&gt;日益增长的用户数量、日渐复杂的业务场景以及急剧膨胀的数据冲击&lt;/strong&gt;这几种挑战。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这就要求我们的系统具有&lt;strong&gt;及时高效的处理能力、更好的服务可用性以及长期运行的稳定性&lt;/strong&gt;等要求。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为了解决这几点挑战，使系统具有所要求的能力，我们需要&lt;strong&gt;通过性能测试来验证系统是否具有我们所期望的能力&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们通过&lt;strong&gt;完善性能测试流程，优化性能测试工具，采用不同性能测试方法，在各种环境和条件下进行测试，全方位监控，定位分析性能瓶颈，针对性的进行优化&lt;/strong&gt;，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最终的目的是希望系统具有&lt;strong&gt;及时高效的处理能力，更好的服务可用性和长期运行的稳定性&lt;/strong&gt;，来满足系统面临的种种挑战，为业务的发展提供更好的服务保障！&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 16 Feb 2019 15:07:00 +0000</pubDate>
<dc:creator>老_张</dc:creator>
<og:description>说起性能测试，大家会想到哪些词？录制脚本、模拟高并发？性能需求分析、业务流程梳理？监控资源耗用、性能瓶颈定位？优化代码处理逻辑、提升服务器配置？ 但这真的是性能测试的本质和最终目的么？这篇博客，聊聊我</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/imyalost/p/10353954.html</dc:identifier>
</item>
<item>
<title>从零开始单排学设计模式「装饰模式」黑铁 I - LonelyKeyGuest</title>
<link>http://www.cnblogs.com/gdjk/p/10389642.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/gdjk/p/10389642.html</guid>
<description>&lt;p&gt;阅读本文大概需要 3.6 分钟。&lt;/p&gt;

&lt;p&gt;本篇是设计模式系列的第四篇，虽然之前也写过相应的文章，但是因为种种原因后来断掉了，而且发现之前写的内容也很渣，不够系统。&lt;/p&gt;

&lt;p&gt;所以现在打算重写，加上距离现在也有一段时间了，也算是自己的一个回顾吧！&lt;/p&gt;

&lt;p&gt;学而时习之，不亦说乎。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;推荐阅读：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyNDkzNzczNQ==&amp;amp;mid=2247485514&amp;amp;idx=1&amp;amp;sn=dd33498d72c50d7facad6f14957f022a&amp;amp;chksm=fa24f722cd537e342f293ce08831d1e7bd31b412be743a2dfeaa0f8f60414e32b726e3478b90&amp;amp;scene=21#wechat_redirect&quot; data-cke-saved-href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyNDkzNzczNQ==&amp;amp;mid=2247485514&amp;amp;idx=1&amp;amp;sn=dd33498d72c50d7facad6f14957f022a&amp;amp;chksm=fa24f722cd537e342f293ce08831d1e7bd31b412be743a2dfeaa0f8f60414e32b726e3478b90&amp;amp;scene=21#wechat_redirect&quot;&gt;从零开始单排学设计模式「UML类图」定级赛&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyNDkzNzczNQ==&amp;amp;mid=2247485515&amp;amp;idx=1&amp;amp;sn=ad61fd16a315fa15acca3074a0406dca&amp;amp;chksm=fa24f723cd537e35095ff4a2e7d150f63cfaa46378b588abbb7a4548d86ecc9806cee8f6ab57&amp;amp;scene=21#wechat_redirect&quot; data-cke-saved-href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyNDkzNzczNQ==&amp;amp;mid=2247485515&amp;amp;idx=1&amp;amp;sn=ad61fd16a315fa15acca3074a0406dca&amp;amp;chksm=fa24f723cd537e35095ff4a2e7d150f63cfaa46378b588abbb7a4548d86ecc9806cee8f6ab57&amp;amp;scene=21#wechat_redirect&quot;&gt;从零开始单排学设计模式「简单工厂设计模式」黑铁 III&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyNDkzNzczNQ==&amp;amp;mid=2247485617&amp;amp;idx=1&amp;amp;sn=f38fd9b9a63ac7ade48391a8a564b7c6&amp;amp;chksm=fa24f7d9cd537ecfa25a3e911be6754b01e8c6a25f96b3a523b3d75f578082d9ed12d800c4be&amp;amp;scene=21#wechat_redirect&quot; data-cke-saved-href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyNDkzNzczNQ==&amp;amp;mid=2247485617&amp;amp;idx=1&amp;amp;sn=f38fd9b9a63ac7ade48391a8a564b7c6&amp;amp;chksm=fa24f7d9cd537ecfa25a3e911be6754b01e8c6a25f96b3a523b3d75f578082d9ed12d800c4be&amp;amp;scene=21#wechat_redirect&quot;&gt;从零开始单排学设计模式「策略模式」黑铁 II&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;目前段位：&lt;strong&gt;黑铁 I&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;6&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://mmbiz.qpic.cn/mmbiz_png/TeYk478W36Ba9cUE7U4f1yJOrEDGA3IthTMOombgIog0M2B8VnxsAw6ggzMbNBrRKbIesUjiaWGX5oet94IU20w/640?wx_fmt=png&quot; alt=&quot;&quot; data-cke-saved-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/TeYk478W36Ba9cUE7U4f1yJOrEDGA3IthTMOombgIog0M2B8VnxsAw6ggzMbNBrRKbIesUjiaWGX5oet94IU20w/640?wx_fmt=png&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://mmbiz.qpic.cn/mmbiz_png/TeYk478W36Ba9cUE7U4f1yJOrEDGA3IthTMOombgIog0M2B8VnxsAw6ggzMbNBrRKbIesUjiaWGX5oet94IU20w/640?wx_fmt=png&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Let's Go！&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;设计模式不是语法，是一种巧妙的写法，能把程序变的更加灵活。架构模式比设计模式大，架构模式是战略，而设计模式是战术。&lt;/p&gt;

&lt;p&gt;设计模式分为3大类型：创建型，行为型，结构型，总共有23种。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;装饰模式&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;装饰模式（Decorator）指的是在不必改变类文件和使用继承的情况下，动态地扩展一个对象的功能。它是通过创建一个包装对象，也就是装饰来包裹真实的对象。&lt;/p&gt;

&lt;p&gt;这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;业务需求&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;公司接到一个任务，需要为某平台开发一个搭配不同服饰的小项目，比如类似QQ、网络游戏或论坛都有的Avatar系统（为了简化代码，直接使用控制台模拟）。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;代码实现&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;经过公司的慎重讨论（实际就几秒钟），开发这一个项目的重任，又当仁不让的被产品经理交给了我，我：脸上笑嘻嘻，心里MMP。发一下下的小牢骚，不过还是抓紧干活。&lt;/p&gt;

&lt;p&gt;思索一下，该系统要为不同的人进行装扮，所以定义一个人的类，不用每次装扮其他人时修改该类的代码。&lt;/p&gt;

&lt;p&gt;然后人身上要有很多的服饰，比如：大T恤、垮裤、鞋子等等，然后穿上之后，需要展示出来。所以这里的话，可以抽象出一个服饰的基类，然后各个具体的服饰都继承该基类即可。&lt;/p&gt;

&lt;p&gt;代码如下：&lt;/p&gt;
&lt;p&gt;Person类&lt;/p&gt;
&lt;pre readability=&quot;6&quot;&gt;
&lt;code class=&quot;language-html hljs&quot; readability=&quot;6&quot;&gt;/**&lt;br/&gt;* @author: LKP&lt;br/&gt;* @date: 2019/2/16&lt;br/&gt;*/&lt;br/&gt;public class Person {&lt;p&gt;private String name;&lt;br/&gt;public Person() {&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;public Person(String name) {&lt;br/&gt;this.name = name;&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;public void show() {&lt;br/&gt;System.out.println(&quot;装扮者：&quot; + name);&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;服装抽象类&lt;/p&gt;
&lt;pre readability=&quot;5.5&quot;&gt;
&lt;code class=&quot;language-html hljs&quot; readability=&quot;5&quot;&gt;/**&lt;br/&gt;* @author: LKP&lt;br/&gt;* @date: 2019/2/16&lt;br/&gt;*/&lt;br/&gt;public class Finery extends Person {&lt;p&gt;protected  Person component;&lt;br/&gt;/**&lt;br/&gt;* 打扮&lt;br/&gt;* @param component&lt;br/&gt;*/&lt;br/&gt;public void decorate(Person component){&lt;br/&gt;this.component = component;&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;@Override&lt;br/&gt;public void show() {&lt;br/&gt;if(null != component){&lt;br/&gt;component.show();&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;具体服饰类&lt;/p&gt;
&lt;pre readability=&quot;14&quot;&gt;
&lt;code class=&quot;language-html hljs&quot; readability=&quot;22&quot;&gt;/**&lt;br/&gt;* @author: LKP&lt;br/&gt;* @date: 2019/2/16&lt;br/&gt;*/&lt;br/&gt;public class TShirts extends Finery {&lt;p&gt;@Override&lt;br/&gt;public void show() {&lt;br/&gt;System.out.println(&quot;大T恤&quot;);&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;class BigTrouser extends Finery {&lt;/p&gt;&lt;p&gt;@Override&lt;br/&gt;public void show() {&lt;br/&gt;System.out.println(&quot;垮裤&quot;);&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;class Sneakers extends Finery{&lt;/p&gt;&lt;p&gt;@Override&lt;br/&gt;public void show() {&lt;br/&gt;System.out.println(&quot;破球鞋&quot;);&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;class LeatherShoes extends Finery{&lt;/p&gt;&lt;p&gt;@Override&lt;br/&gt;public void show() {&lt;br/&gt;System.out.println(&quot;皮鞋&quot;);&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;class Tie extends Finery{&lt;/p&gt;&lt;p&gt;@Override&lt;br/&gt;public void show() {&lt;br/&gt;System.out.println(&quot;领带&quot;);&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;class Suit extends Finery{&lt;/p&gt;&lt;p&gt;@Override&lt;br/&gt;public void show() {&lt;br/&gt;System.out.println(&quot;西装&quot;);&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里内部类，只是为了较少代码量，实际开发中可不要偷懒，按实际来创建。&lt;/p&gt;

&lt;p&gt;客户端代码&lt;/p&gt;
&lt;pre readability=&quot;11.5&quot;&gt;
&lt;code class=&quot;language-html hljs&quot; readability=&quot;17&quot;&gt;/**&lt;br/&gt;* @author: LKP&lt;br/&gt;* @date: 2019/2/16&lt;br/&gt;*/&lt;br/&gt;public class Main {&lt;p&gt;public static void main(String[] args) {&lt;/p&gt;&lt;p&gt;Person person = new Person(&quot;孤独键客&quot;);&lt;/p&gt;&lt;p&gt;System.out.println(&quot;第一种装扮：&quot;);&lt;/p&gt;&lt;p&gt;Finery tShirts = new TShirts();&lt;br/&gt;Finery bigTrouser = new BigTrouser();&lt;br/&gt;Finery sneakers = new Sneakers();&lt;/p&gt;&lt;p&gt;tShirts.show();&lt;br/&gt;bigTrouser.show();&lt;br/&gt;sneakers.show();&lt;br/&gt;person.show();&lt;/p&gt;&lt;p&gt;System.out.println(&quot;\n第二种装扮：&quot;);&lt;/p&gt;&lt;p&gt;Finery suit = new Suit();&lt;br/&gt;Finery tie = new Tie();&lt;br/&gt;Finery leatherShoes = new LeatherShoes();&lt;/p&gt;&lt;p&gt;suit.show();&lt;br/&gt;tie.show();&lt;br/&gt;leatherShoes.show();&lt;br/&gt;person.show();&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;代码简单搞定，接下来来看一下运行结果&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;5&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://mmbiz.qpic.cn/mmbiz_png/TeYk478W36AMsMtuwgjHeEjAfsP4zuibZTJVD1kIl59pB9Zibrv7ArC9HGuQ3mFgCrJqddCibVUouMseCd8bJU0Aw/640?wx_fmt=png&quot; alt=&quot;&quot; data-cke-saved-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/TeYk478W36AMsMtuwgjHeEjAfsP4zuibZTJVD1kIl59pB9Zibrv7ArC9HGuQ3mFgCrJqddCibVUouMseCd8bJU0Aw/640?wx_fmt=png&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://mmbiz.qpic.cn/mmbiz_png/TeYk478W36AMsMtuwgjHeEjAfsP4zuibZTJVD1kIl59pB9Zibrv7ArC9HGuQ3mFgCrJqddCibVUouMseCd8bJU0Aw/640?wx_fmt=png&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;搞定收工，审视一下，自我感觉还算不错，如果新装扮只需改变一下调用顺序即可，如果又新人物，只需重新new一个Person类就可以了。&lt;/p&gt;

&lt;p&gt;接下里将项目提交上传，然后告诉leader一声，over，离下班时间还早，好像还可以做点其他的事情~。&lt;/p&gt;

&lt;p&gt;正当你准备打开去干点其他事情，leader回复你了：&lt;/p&gt;

&lt;p&gt;leader：“你仔细看看这段代码，这样写意味着什么？&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;4&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://mmbiz.qpic.cn/mmbiz_png/TeYk478W36AMsMtuwgjHeEjAfsP4zuibZr64LHY9x78KzsJOp24BDsSMH1icSTyMYytliaoUr7AHlqlHs5ft0SpLA/640?wx_fmt=png&quot; alt=&quot;&quot; data-cke-saved-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/TeYk478W36AMsMtuwgjHeEjAfsP4zuibZr64LHY9x78KzsJOp24BDsSMH1icSTyMYytliaoUr7AHlqlHs5ft0SpLA/640?wx_fmt=png&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://mmbiz.qpic.cn/mmbiz_png/TeYk478W36AMsMtuwgjHeEjAfsP4zuibZr64LHY9x78KzsJOp24BDsSMH1icSTyMYytliaoUr7AHlqlHs5ft0SpLA/640?wx_fmt=png&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;你想象一下，是不是把‘大T恤’、‘垮裤’、‘破球鞋’、‘装扮者’一个一个词显示出来，是不是相当于你光着身子，一个一个把这些穿上，这可有点像脱衣舞哦~”。&lt;/p&gt;

&lt;p&gt;我：“你意思是，这些应该都在内部组装完毕，然后在显示出来？”。&lt;/p&gt;

&lt;p&gt;leader：&quot;宾果，而且还要按照正确的顺序串联起来控制，这里有点难度，修改好之后再给我&quot;。&lt;/p&gt;

&lt;p&gt;这似乎和某种设计模式有关，难道是建造者模式吗？不对，建造者模式要求建造的过程必须是稳定的，而这个穿搭的过程是不固定的，一个有个性的人又无数种方案。&lt;/p&gt;

&lt;p&gt;经过一番查找，这恰恰最适合用装饰模式了。&lt;/p&gt;

&lt;p&gt;我们修改一下具体的服饰类&lt;/p&gt;
&lt;pre readability=&quot;14&quot;&gt;
&lt;code class=&quot;language-html hljs&quot; readability=&quot;22&quot;&gt;/**&lt;br/&gt;* @author: LKP&lt;br/&gt;* @date: 2019/2/16&lt;br/&gt;*/&lt;br/&gt;public class TShirts extends Finery {&lt;p&gt;@Override&lt;br/&gt;public void show() {&lt;br/&gt;System.out.println(&quot;大T恤&quot;);&lt;br/&gt;super.show();&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;class BigTrouser extends Finery {&lt;/p&gt;&lt;p&gt;@Override&lt;br/&gt;public void show() {&lt;br/&gt;System.out.println(&quot;垮裤&quot;);&lt;br/&gt;super.show();&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;class Sneakers extends Finery{&lt;/p&gt;&lt;p&gt;@Override&lt;br/&gt;public void show() {&lt;br/&gt;System.out.println(&quot;破球鞋&quot;);&lt;br/&gt;super.show();&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;class LeatherShoes extends Finery{&lt;/p&gt;&lt;p&gt;@Override&lt;br/&gt;public void show() {&lt;br/&gt;System.out.println(&quot;皮鞋&quot;);&lt;br/&gt;super.show();&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;class Tie extends Finery{&lt;/p&gt;&lt;p&gt;@Override&lt;br/&gt;public void show() {&lt;br/&gt;System.out.println(&quot;领带&quot;);&lt;br/&gt;super.show();&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;class Suit extends Finery{&lt;/p&gt;&lt;p&gt;@Override&lt;br/&gt;public void show() {&lt;br/&gt;System.out.println(&quot;西装&quot;);&lt;br/&gt;super.show();&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再修改一下客户端代码：&lt;/p&gt;
&lt;pre readability=&quot;6.5&quot;&gt;
&lt;code class=&quot;language-html hljs&quot; readability=&quot;7&quot;&gt;/**&lt;br/&gt;* @author: LKP&lt;br/&gt;* @date: 2019/2/16&lt;br/&gt;*/&lt;br/&gt;public class Main {&lt;p&gt;public static void main(String[] args) {&lt;/p&gt;&lt;p&gt;Person person = new Person(&quot;孤独键客&quot;);&lt;br/&gt;System.out.println(&quot;第一种装扮：&quot;);&lt;br/&gt;Sneakers sneakers = new Sneakers();&lt;br/&gt;BigTrouser bigTrouser = new BigTrouser();&lt;br/&gt;TShirts tShirts = new TShirts();&lt;br/&gt;sneakers.decorate(person);&lt;br/&gt;bigTrouser.decorate(sneakers);&lt;br/&gt;tShirts.decorate(bigTrouser);&lt;br/&gt;tShirts.show();&lt;br/&gt;System.out.println(&quot;第二种装扮：&quot;);&lt;br/&gt;LeatherShoes leatherShoes = new LeatherShoes();&lt;br/&gt;Tie tie = new Tie();&lt;br/&gt;Suit suit = new Suit();&lt;br/&gt;leatherShoes.decorate(person);&lt;br/&gt;tie.decorate(leatherShoes);&lt;br/&gt;suit.decorate(tie);&lt;br/&gt;suit.show();&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第二版的程序写完了，来测试一下&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;3&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://mmbiz.qpic.cn/mmbiz_png/TeYk478W36AMsMtuwgjHeEjAfsP4zuibZdby1fymmYkqNmF6xtQQX3NwV4OQaKWbbMiaMzcLB9E5JrAyWSFf7hqQ/640?wx_fmt=png&quot; alt=&quot;&quot; data-cke-saved-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/TeYk478W36AMsMtuwgjHeEjAfsP4zuibZdby1fymmYkqNmF6xtQQX3NwV4OQaKWbbMiaMzcLB9E5JrAyWSFf7hqQ/640?wx_fmt=png&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://mmbiz.qpic.cn/mmbiz_png/TeYk478W36AMsMtuwgjHeEjAfsP4zuibZdby1fymmYkqNmF6xtQQX3NwV4OQaKWbbMiaMzcLB9E5JrAyWSFf7hqQ/640?wx_fmt=png&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;完美搞定，哈哈，我还可以换种装饰方式&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;2&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://mmbiz.qpic.cn/mmbiz_png/TeYk478W36AMsMtuwgjHeEjAfsP4zuibZzmPVf2vzqQ7RPctCApz2MeDaWBnoJACP4JR85D9SUfeMelHDpvHCwA/640?wx_fmt=png&quot; alt=&quot;&quot; data-cke-saved-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/TeYk478W36AMsMtuwgjHeEjAfsP4zuibZzmPVf2vzqQ7RPctCApz2MeDaWBnoJACP4JR85D9SUfeMelHDpvHCwA/640?wx_fmt=png&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://mmbiz.qpic.cn/mmbiz_png/TeYk478W36AMsMtuwgjHeEjAfsP4zuibZzmPVf2vzqQ7RPctCApz2MeDaWBnoJACP4JR85D9SUfeMelHDpvHCwA/640?wx_fmt=png&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;看下结果&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;1&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://mmbiz.qpic.cn/mmbiz_png/TeYk478W36AMsMtuwgjHeEjAfsP4zuibZyib6kHfsvQAZmCUQB44dlL951B2MfEzUGqibGDaXI5qRIf2LqLiboXX5A/640?wx_fmt=png&quot; alt=&quot;&quot; data-cke-saved-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/TeYk478W36AMsMtuwgjHeEjAfsP4zuibZyib6kHfsvQAZmCUQB44dlL951B2MfEzUGqibGDaXI5qRIf2LqLiboXX5A/640?wx_fmt=png&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://mmbiz.qpic.cn/mmbiz_png/TeYk478W36AMsMtuwgjHeEjAfsP4zuibZyib6kHfsvQAZmCUQB44dlL951B2MfEzUGqibGDaXI5qRIf2LqLiboXX5A/640?wx_fmt=png&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;光着膀子、打着领带、下身垮裤、脚上皮鞋，绝对的极具个性。&lt;/p&gt;

&lt;p&gt;最后，完美搞定，提交代码~~~&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;装饰模式UML类图&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;0&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://mmbiz.qpic.cn/mmbiz_png/TeYk478W36AMsMtuwgjHeEjAfsP4zuibZUYvnT1u9EO3LLjPEnUJ2MGlUELGE9dialQN9fVgpWGYHrE1nZ31tkoA/640?wx_fmt=png&quot; alt=&quot;&quot; data-cke-saved-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/TeYk478W36AMsMtuwgjHeEjAfsP4zuibZUYvnT1u9EO3LLjPEnUJ2MGlUELGE9dialQN9fVgpWGYHrE1nZ31tkoA/640?wx_fmt=png&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://mmbiz.qpic.cn/mmbiz_png/TeYk478W36AMsMtuwgjHeEjAfsP4zuibZUYvnT1u9EO3LLjPEnUJ2MGlUELGE9dialQN9fVgpWGYHrE1nZ31tkoA/640?wx_fmt=png&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;来总结一下装饰模式：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;主要解决&lt;/strong&gt;：一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;何时使用&lt;/strong&gt;：在不想增加很多子类的情况下扩展类。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;如何解决&lt;/strong&gt;：将具体功能职责划分，同时继承装饰者模式。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;关键代码&lt;/strong&gt;： 1、Component 类充当抽象角色，不应该具体实现。 2、修饰类引用和继承 Component 类，具体扩展类重写父类方法。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;应用实例&lt;/strong&gt;： 1、孙悟空有 72 变，当他变成&quot;庙宇&quot;后，他的根本还是一只猴子，但是他又有了庙宇的功能。 2、不论一幅画有没有画框都可以挂在墙上，但是通常都是有画框的，并且实际上是画框被挂在墙上。在挂在墙上之前，画可以被蒙上玻璃，装到框子里；这时画、玻璃和画框形成了一个物体。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;：装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;：多层装饰比较复杂。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;使用场景&lt;/strong&gt;： 1、扩展一个类的功能。 2、动态增加功能，动态撤销。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意事项&lt;/strong&gt;：可代替继承。&lt;/p&gt;



&lt;p&gt;往期精彩回顾&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyNDkzNzczNQ==&amp;amp;mid=2247485704&amp;amp;idx=1&amp;amp;sn=dd8dc47d1f3c5de77640173bf84a733d&amp;amp;chksm=fa24f660cd537f764ebc0c0c0f823cde04f1db54be1f199e62a82374e7bfbf4eadf981673dff&amp;amp;scene=21#wechat_redirect&quot; data-cke-saved-href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyNDkzNzczNQ==&amp;amp;mid=2247485704&amp;amp;idx=1&amp;amp;sn=dd8dc47d1f3c5de77640173bf84a733d&amp;amp;chksm=fa24f660cd537f764ebc0c0c0f823cde04f1db54be1f199e62a82374e7bfbf4eadf981673dff&amp;amp;scene=21#wechat_redirect&quot;&gt;每秒 570000 的写入，如何实现？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyNDkzNzczNQ==&amp;amp;mid=2247485693&amp;amp;idx=1&amp;amp;sn=993ef5ada4c0872c2e7394d6271bf6d7&amp;amp;chksm=fa24f795cd537e83058c47343ddbea31b4784d24c13fdd31dfdf953e6f76cafb65b284fdc4c7&amp;amp;scene=21#wechat_redirect&quot; data-cke-saved-href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyNDkzNzczNQ==&amp;amp;mid=2247485693&amp;amp;idx=1&amp;amp;sn=993ef5ada4c0872c2e7394d6271bf6d7&amp;amp;chksm=fa24f795cd537e83058c47343ddbea31b4784d24c13fdd31dfdf953e6f76cafb65b284fdc4c7&amp;amp;scene=21#wechat_redirect&quot;&gt;这40张图送给单身程序员，情人节请一笑而过！&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyNDkzNzczNQ==&amp;amp;mid=2247485672&amp;amp;idx=1&amp;amp;sn=8266c9dd7b0feb9e88f9394b7878ba3f&amp;amp;chksm=fa24f780cd537e96b4636cf22c6e12ddb754754573abf68ce8510989219926644801b3dcb06c&amp;amp;scene=21#wechat_redirect&quot; data-cke-saved-href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyNDkzNzczNQ==&amp;amp;mid=2247485672&amp;amp;idx=1&amp;amp;sn=8266c9dd7b0feb9e88f9394b7878ba3f&amp;amp;chksm=fa24f780cd537e96b4636cf22c6e12ddb754754573abf68ce8510989219926644801b3dcb06c&amp;amp;scene=21#wechat_redirect&quot;&gt;IDEA一定要懂的32条快捷键&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyNDkzNzczNQ==&amp;amp;mid=2247485647&amp;amp;idx=1&amp;amp;sn=73f29d6d2f41dcc64dded00bd69ae424&amp;amp;chksm=fa24f7a7cd537eb109fd567a8c51fe5e477be0f1da3ecde7f00a9a66e32798a4969f13004515&amp;amp;scene=21#wechat_redirect&quot; data-cke-saved-href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyNDkzNzczNQ==&amp;amp;mid=2247485647&amp;amp;idx=1&amp;amp;sn=73f29d6d2f41dcc64dded00bd69ae424&amp;amp;chksm=fa24f7a7cd537eb109fd567a8c51fe5e477be0f1da3ecde7f00a9a66e32798a4969f13004515&amp;amp;scene=21#wechat_redirect&quot;&gt;世上最污技术解读，我竟然秒懂了。&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyNDkzNzczNQ==&amp;amp;mid=2247485600&amp;amp;idx=1&amp;amp;sn=35e8908b04cfcedf94b750c28f3ff3dc&amp;amp;chksm=fa24f7c8cd537edef9bfc9bbca206fc4ea12ac13f38e91b107a939f6a47f9c83182289280081&amp;amp;scene=21#wechat_redirect&quot; data-cke-saved-href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyNDkzNzczNQ==&amp;amp;mid=2247485600&amp;amp;idx=1&amp;amp;sn=35e8908b04cfcedf94b750c28f3ff3dc&amp;amp;chksm=fa24f7c8cd537edef9bfc9bbca206fc4ea12ac13f38e91b107a939f6a47f9c83182289280081&amp;amp;scene=21#wechat_redirect&quot;&gt;Bing挂了！百度又“赢了”&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyNDkzNzczNQ==&amp;amp;mid=2247485611&amp;amp;idx=1&amp;amp;sn=ab272b10c23f3b3371dc4b3f276ebe2a&amp;amp;chksm=fa24f7c3cd537ed5cb66b732ee4e25cb690613c5d86b80e28d437954a784cb7827a67213b9ec&amp;amp;scene=21#wechat_redirect&quot; data-cke-saved-href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyNDkzNzczNQ==&amp;amp;mid=2247485611&amp;amp;idx=1&amp;amp;sn=ab272b10c23f3b3371dc4b3f276ebe2a&amp;amp;chksm=fa24f7c3cd537ed5cb66b732ee4e25cb690613c5d86b80e28d437954a784cb7827a67213b9ec&amp;amp;scene=21#wechat_redirect&quot;&gt;遇到卖茶女，应该如何优雅的回复她&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyNDkzNzczNQ==&amp;amp;mid=2247485610&amp;amp;idx=1&amp;amp;sn=cbdaac7255fb609635d498bdc4a63ac3&amp;amp;chksm=fa24f7c2cd537ed4dd44af682fc9f3557d3bc8d76b6230aa08597537ec6973a8f556df431862&amp;amp;scene=21#wechat_redirect&quot; data-cke-saved-href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyNDkzNzczNQ==&amp;amp;mid=2247485610&amp;amp;idx=1&amp;amp;sn=cbdaac7255fb609635d498bdc4a63ac3&amp;amp;chksm=fa24f7c2cd537ed4dd44af682fc9f3557d3bc8d76b6230aa08597537ec6973a8f556df431862&amp;amp;scene=21#wechat_redirect&quot;&gt;我被程序员坑了600万致公司倒闭，当事人逐条反驳：这锅我不背&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyNDkzNzczNQ==&amp;amp;mid=2247485440&amp;amp;idx=1&amp;amp;sn=068d918afea5b554e5d944a4dc192048&amp;amp;chksm=fa24f768cd537e7e055f1c5d9a2b0868f04449877d7e4a9a2d26137f1201f92a35ddbb362119&amp;amp;scene=21#wechat_redirect&quot; data-cke-saved-href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyNDkzNzczNQ==&amp;amp;mid=2247485440&amp;amp;idx=1&amp;amp;sn=068d918afea5b554e5d944a4dc192048&amp;amp;chksm=fa24f768cd537e7e055f1c5d9a2b0868f04449877d7e4a9a2d26137f1201f92a35ddbb362119&amp;amp;scene=21#wechat_redirect&quot;&gt;一千行MySQL详细学习笔记（值得学习与收藏）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyNDkzNzczNQ==&amp;amp;mid=2247485436&amp;amp;idx=1&amp;amp;sn=d95c4c615d4430e23904c9ce66dbb284&amp;amp;chksm=fa24f894cd537182ddb81c28d30dd34523623819eb47625052ba9ac07cdf1ac58cb230c7962b&amp;amp;scene=21#wechat_redirect&quot; data-cke-saved-href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyNDkzNzczNQ==&amp;amp;mid=2247485436&amp;amp;idx=1&amp;amp;sn=d95c4c615d4430e23904c9ce66dbb284&amp;amp;chksm=fa24f894cd537182ddb81c28d30dd34523623819eb47625052ba9ac07cdf1ac58cb230c7962b&amp;amp;scene=21#wechat_redirect&quot;&gt;七点建议助您写出优雅的Java代码&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/16/168f6bf9671adaf3?w=258&amp;amp;h=258&amp;amp;f=jpeg&amp;amp;s=27279&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;欢迎关注我的公众号「程序员的成长之路」，阅读更多精彩！  &lt;/p&gt;
</description>
<pubDate>Sat, 16 Feb 2019 14:49:00 +0000</pubDate>
<dc:creator>LonelyKeyGuest</dc:creator>
<og:description>阅读本文大概需要 3.6 分钟。 本篇是设计模式系列的第四篇，虽然之前也写过相应的文章，但是因为种种原因后来断掉了，而且发现之前写的内容也很渣，不够系统。 所以现在打算重写，加上距离现在也有一段时间了</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/gdjk/p/10389642.html</dc:identifier>
</item>
<item>
<title>Python Requests库使用指南 - jiangyx</title>
<link>http://www.cnblogs.com/Jiangyx/p/10389631.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Jiangyx/p/10389631.html</guid>
<description>&lt;blockquote readability=&quot;2.6436781609195&quot;&gt;
&lt;p&gt;本文为译文，原文链接 &lt;a href=&quot;https://realpython.com/python-requests/&quot;&gt;python-requests-library-guide&lt;/a&gt;&lt;br/&gt;本人博客: &lt;a href=&quot;http://blog.jiangyixin.top&quot;&gt;编程禅师&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://docs.python-requests.org/en/master/&quot;&gt;requests&lt;/a&gt; 库是用来在Python中发出标准的HTTP请求。 它将请求背后的复杂性抽象成一个漂亮，简单的API，以便你可以专注于与服务交互和在应用程序中使用数据。&lt;/p&gt;
&lt;p&gt;在本文中，你将看到 &lt;code&gt;requests&lt;/code&gt; 提供的一些有用的功能，以及如何针对你可能遇到的不同情况来自定义和优化这些功能。 你还将学习如何有效的使用 &lt;code&gt;requests&lt;/code&gt;，以及如何防止对外部服务的请求导致减慢应用程序的速度。&lt;/p&gt;
&lt;p&gt;在本教程中，你将学习如何:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用常见的HTTP方法发送请求&lt;/li&gt;
&lt;li&gt;定制你的请求头和数据，使用查询字符串和消息体&lt;/li&gt;
&lt;li&gt;检查你的请求和响应的数据&lt;/li&gt;
&lt;li&gt;发送带身份验证的请求&lt;/li&gt;
&lt;li&gt;配置你的请求来避免阻塞或减慢你的应用程序&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;虽然我试图包含尽可能多的信息来理解本文中包含的功能和示例，但阅读此文需要对HTTP有基础的了解。&lt;/p&gt;
&lt;p&gt;现在让我们深入了解如何在你的应用程序中使用请求！&lt;/p&gt;

&lt;p&gt;让我们首先安装 &lt;code&gt;requests&lt;/code&gt; 库。 为此，请运行以下命令:&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;pip install requests&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果你喜欢使用 &lt;a href=&quot;https://realpython.com/pipenv-guide/&quot;&gt;Pipenv&lt;/a&gt; 管理Python包，你可以运行下面的命令:&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;pipenv install requests&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一旦安装了 &lt;code&gt;requests&lt;/code&gt; ，你就可以在应用程序中使用它。像这样导入 &lt;code&gt;requests&lt;/code&gt; :&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;import requests&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在你已经都准备完成了，那么是时候开始使用 &lt;code&gt;requests&lt;/code&gt; 的旅程了。 你的第一个目标是学习如何发出GET请求。&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Request_methods&quot;&gt;HTTP方法&lt;/a&gt;（如GET和POST）决定当发出HTTP请求时尝试执行的操作。 除了GET和POST之外，还有其他一些常用的方法，你将在本教程的后面部分使用到。&lt;/p&gt;
&lt;p&gt;最常见的HTTP方法之一是GET。 GET方法表示你正在尝试从指定资源获取或检索数据。 要发送GET请求，请调用 &lt;code&gt;requests.get()&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;你可以通过下面方式来向GitHub的 &lt;a href=&quot;https://developer.github.com/v3/#root-endpoint&quot;&gt;Root REST API&lt;/a&gt; 发出GET请求：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; requests.get('https://api.github.com')
&amp;lt;Response [200]&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;恭喜！ 你发出了你的第一个请求。 接下来让我们更深入地了解该请求的响应。&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;code&gt;Response&lt;/code&gt; 是检查请求结果的强有力的对象。 让我们再次发出相同的请求，但这次将返回值存储在一个变量中，以便你可以仔细查看其属性和方法：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; response = requests.get('https://api.github.com')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在此示例中，你捕获了 &lt;code&gt;get()&lt;/code&gt; 的返回值，该值是 &lt;code&gt;Response&lt;/code&gt; 的实例，并将其存储在名为 &lt;code&gt;response&lt;/code&gt; 的变量中。 你现在可以使用 &lt;code&gt;response&lt;/code&gt; 来查看有关GET请求结果的全部信息。&lt;/p&gt;
&lt;h2 id=&quot;状态码&quot;&gt;状态码&lt;/h2&gt;
&lt;p&gt;您可以从 &lt;code&gt;Response&lt;/code&gt; 获取的第一部分信息是状态码。 状态码会展示你请求的状态。&lt;/p&gt;
&lt;p&gt;例如，&lt;code&gt;200 OK&lt;/code&gt; 状态表示你的请求成功，而 &lt;code&gt;404 NOT FOUND&lt;/code&gt; 状态表示找不到你要查找的资源。 还有许多&lt;a href=&quot;https://en.wikipedia.org/wiki/List_of_HTTP_status_codes&quot;&gt;其它的状态码&lt;/a&gt; ，可以为你提供关于你的请求所发生的具体情况。&lt;/p&gt;
&lt;p&gt;通过访问 &lt;code&gt;.status_code&lt;/code&gt;，你可以看到服务器返回的状态码：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; response.status_code
200&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;.status_code&lt;/code&gt; 返回 &lt;code&gt;200&lt;/code&gt; 意味着你的请求是成功的，并且服务器返回你要请求的数据。&lt;/p&gt;
&lt;p&gt;有时，你可能想要在代码中使用这些信息来做判断:&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;if response.status_code == 200:
    print('Success!')
elif response.status_code == 404:
    print('Not Found.')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;按照这个逻辑，如果服务器返回 &lt;code&gt;200&lt;/code&gt; 状态码，你的程序将打印 &lt;code&gt;Success!&lt;/code&gt; 如果结果是 &lt;code&gt;404&lt;/code&gt; ，你的程序将打印 &lt;code&gt;Not Found.&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;requests&lt;/code&gt; 更进一步为你简化了此过程。 如果在条件表达式中使用 &lt;code&gt;Response&lt;/code&gt; 实例，则在状态码介于 &lt;code&gt;200&lt;/code&gt; 和 &lt;code&gt;400&lt;/code&gt; 之间时将被计算为为 &lt;code&gt;True&lt;/code&gt; ，否则为 &lt;code&gt;False&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;因此，你可以通过重写 &lt;code&gt;if&lt;/code&gt; 语句来简化上一个示例:&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;if response:
    print('Success!')
else:
    print('An error has occurred.')&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7.9565217391304&quot;&gt;
&lt;p&gt;&lt;strong&gt;技术细节&lt;/strong&gt; : 因为 &lt;code&gt;__ bool __()&lt;/code&gt; 是 &lt;code&gt;Response&lt;/code&gt; 上的&lt;a href=&quot;https://realpython.com/operator-function-overloading/#making-your-objects-truthy-or-falsey-using-bool&quot;&gt;重载方法&lt;/a&gt; ，因此&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#truth-value-testing&quot;&gt;真值测试&lt;/a&gt;才成立。&lt;/p&gt;
&lt;p&gt;这意味着重新定义了 &lt;code&gt;Response&lt;/code&gt; 的默认行为，用来在确定对象的真值时考虑状态码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;请记住，此方法 &lt;code&gt;不会验证&lt;/code&gt; 状态码是否等于 &lt;code&gt;200&lt;/code&gt; 。原因是 &lt;code&gt;200&lt;/code&gt; 到 &lt;code&gt;400&lt;/code&gt; 范围内的其他状态代码，例如 &lt;code&gt;204 NO CONTENT&lt;/code&gt; 和 &lt;code&gt;304 NOT MODIFIED&lt;/code&gt; ，就意义而言也被认为是成功的响应。&lt;/p&gt;
&lt;p&gt;例如，&lt;code&gt;204&lt;/code&gt; 告诉你响应是成功的，但是下消息体中没有返回任何内容。&lt;/p&gt;
&lt;p&gt;因此，通常如果你想知道请求是否成功时，请确保使用这方便的简写，然后在必要时根据状态码适当地处理响应。&lt;/p&gt;
&lt;p&gt;假设你不想在 &lt;code&gt;if&lt;/code&gt; 语句中检查响应的状态码。 相反，如果请求不成功，你希望抛出一个异常。 你可以使用 &lt;code&gt;.raise_for_status()&lt;/code&gt;执行此操作:&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import requests
from requests.exceptions import HTTPError

for url in ['https://api.github.com', 'https://api.github.com/invalid']:
    try:
        response = requests.get(url)

        # If the response was successful, no Exception will be raised
        response.raise_for_status()
    except HTTPError as http_err:
        print(f'HTTP error occurred: {http_err}')  # Python 3.6
    except Exception as err:
        print(f'Other error occurred: {err}')  # Python 3.6
    else:
        print('Success!')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果你调用 &lt;code&gt;.raise_for_status()&lt;/code&gt;，将针对某些状态码引发 &lt;code&gt;HTTPError&lt;/code&gt; 异常。 如果状态码指示请求成功，则程序将继续进行而不会引发该异常。&lt;/p&gt;
&lt;blockquote readability=&quot;5.6223776223776&quot;&gt;
&lt;p&gt;进一步阅读：如果你不熟悉Python 3.6的 &lt;a href=&quot;https://realpython.com/python-f-strings/&quot;&gt;f-strings&lt;/a&gt;，我建议你使用它们，因为它们是简化格式化字符串的好方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;现在，你对于如何处理从服务器返回的响应的状态码了解了许多。 但是，当你发出GET请求时，你很少只关心响应的状态码。 通常，你希望看到更多。 接下来，你将看到如何查看服务器在响应正文中返回的实际数据。&lt;/p&gt;
&lt;h2 id=&quot;响应内容&quot;&gt;响应内容&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;GET&lt;/code&gt; 请求的响应通常在消息体中具有一些有价值的信息，称为有效负载。 使用 &lt;code&gt;Response&lt;/code&gt; 的属性和方法，你可以以各种不同的格式查看有效负载。&lt;/p&gt;
&lt;p&gt;要以 &lt;a href=&quot;https://realpython.com/python-strings/&quot;&gt;字节&lt;/a&gt; 格式查看响应的内容，你可以使用 &lt;code&gt;.content&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; response = requests.get('https://api.github.com')
&amp;gt;&amp;gt;&amp;gt; response.content
b'{&quot;current_user_url&quot;:&quot;https://api.github.com/user&quot;,&quot;current_user_authorizations_html_url&quot;:&quot;https://github.com/settings/connections/applications{/client_id}&quot;,&quot;authorizations_url&quot;:&quot;https://api.github.com/authorizations&quot;,&quot;code_search_url&quot;:&quot;https://api.github.com/search/code?q={query}{&amp;amp;page,per_page,sort,order}&quot;,&quot;commit_search_url&quot;:&quot;https://api.github.com/search/commits?q={query}{&amp;amp;page,per_page,sort,order}&quot;,&quot;emails_url&quot;:&quot;https://api.github.com/user/emails&quot;,&quot;emojis_url&quot;:&quot;https://api.github.com/emojis&quot;,&quot;events_url&quot;:&quot;https://api.github.com/events&quot;,&quot;feeds_url&quot;:&quot;https://api.github.com/feeds&quot;,&quot;followers_url&quot;:&quot;https://api.github.com/user/followers&quot;,&quot;following_url&quot;:&quot;https://api.github.com/user/following{/target}&quot;,&quot;gists_url&quot;:&quot;https://api.github.com/gists{/gist_id}&quot;,&quot;hub_url&quot;:&quot;https://api.github.com/hub&quot;,&quot;issue_search_url&quot;:&quot;https://api.github.com/search/issues?q={query}{&amp;amp;page,per_page,sort,order}&quot;,&quot;issues_url&quot;:&quot;https://api.github.com/issues&quot;,&quot;keys_url&quot;:&quot;https://api.github.com/user/keys&quot;,&quot;notifications_url&quot;:&quot;https://api.github.com/notifications&quot;,&quot;organization_repositories_url&quot;:&quot;https://api.github.com/orgs/{org}/repos{?type,page,per_page,sort}&quot;,&quot;organization_url&quot;:&quot;https://api.github.com/orgs/{org}&quot;,&quot;public_gists_url&quot;:&quot;https://api.github.com/gists/public&quot;,&quot;rate_limit_url&quot;:&quot;https://api.github.com/rate_limit&quot;,&quot;repository_url&quot;:&quot;https://api.github.com/repos/{owner}/{repo}&quot;,&quot;repository_search_url&quot;:&quot;https://api.github.com/search/repositories?q={query}{&amp;amp;page,per_page,sort,order}&quot;,&quot;current_user_repositories_url&quot;:&quot;https://api.github.com/user/repos{?type,page,per_page,sort}&quot;,&quot;starred_url&quot;:&quot;https://api.github.com/user/starred{/owner}{/repo}&quot;,&quot;starred_gists_url&quot;:&quot;https://api.github.com/gists/starred&quot;,&quot;team_url&quot;:&quot;https://api.github.com/teams&quot;,&quot;user_url&quot;:&quot;https://api.github.com/users/{user}&quot;,&quot;user_organizations_url&quot;:&quot;https://api.github.com/user/orgs&quot;,&quot;user_repositories_url&quot;:&quot;https://api.github.com/users/{user}/repos{?type,page,per_page,sort}&quot;,&quot;user_search_url&quot;:&quot;https://api.github.com/search/users?q={query}{&amp;amp;page,per_page,sort,order}&quot;}'
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;虽然 &lt;code&gt;.content&lt;/code&gt; 允许你访问响应有效负载的原始字节，但你通常希望使用 &lt;a href=&quot;https://en.wikipedia.org/wiki/UTF-8&quot;&gt;UTF-8&lt;/a&gt; 等字符编码将它们转换为&lt;a href=&quot;https://realpython.com/python-data-types/&quot;&gt;字符串&lt;/a&gt;。 当你访问 &lt;code&gt;.text&lt;/code&gt; 时，&lt;code&gt;response&lt;/code&gt; 将为你执行此操作：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; response.text
'{&quot;current_user_url&quot;:&quot;https://api.github.com/user&quot;,&quot;current_user_authorizations_html_url&quot;:&quot;https://github.com/settings/connections/applications{/client_id}&quot;,&quot;authorizations_url&quot;:&quot;https://api.github.com/authorizations&quot;,&quot;code_search_url&quot;:&quot;https://api.github.com/search/code?q={query}{&amp;amp;page,per_page,sort,order}&quot;...}&quot;}'
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为对 &lt;code&gt;bytes&lt;/code&gt; 解码到 &lt;code&gt;str&lt;/code&gt; 需要一个编码格式，所以如果你没有指定，请求将尝试根据响应头来猜测编码格式。 你也可以在访问 &lt;code&gt;.text&lt;/code&gt; 之前通过 &lt;code&gt;.encoding&lt;/code&gt; 来显式设置编码：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; response.encoding = 'utf-8' # Optional: requests infers this internally
&amp;gt;&amp;gt;&amp;gt; response.text
'{&quot;current_user_url&quot;:&quot;https://api.github.com/user&quot;,&quot;current_user_authorizations_html_url&quot;:&quot;https://github.com/settings/connections/applications{/client_id}&quot;,&quot;authorizations_url&quot;:&quot;https://api.github.com/authorizations&quot;,&quot;code_search_url&quot;:&quot;https://api.github.com/search/code?q={query}{&amp;amp;page,per_page,sort,order}&quot;...}&quot;}'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果你看看响应，你会发现它实际上是序列化的 &lt;code&gt;JSON&lt;/code&gt; 内容。 要获取字典内容，你可以使用 &lt;code&gt;.text&lt;/code&gt; 获取 &lt;code&gt;str&lt;/code&gt; 并使用&lt;code&gt;json.loads()&lt;/code&gt; 对其进行反序列化。 但是，完成此任务的更简单方法是使用 &lt;code&gt;.json()&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; response.json()
{'current_user_url': 'https://api.github.com/user', 'current_user_authorizations_html_url': 'https://github.com/settings/connections/applications{/client_id}'...}'}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;.json()&lt;/code&gt; 返回值的类型是字典类型，因此你可以使用键值对的方式访问对象中的值。&lt;/p&gt;
&lt;p&gt;你可以使用状态码和消息体做许多事情。 但是，如果你需要更多信息，例如有关 &lt;code&gt;response&lt;/code&gt; 本身的元数据，则需要查看响应头部。&lt;/p&gt;
&lt;h2 id=&quot;响应头部&quot;&gt;响应头部&lt;/h2&gt;
&lt;p&gt;响应头部可以为你提供有用的信息，例如响应有效负载的内容类型以及缓存响应的时间限制。 要查看这些头部，请访问 &lt;code&gt;.headers&lt;/code&gt; ：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; response.headers
{'Server': 'GitHub.com', 'Date': 'Mon, 10 Dec 2018 17:49:54 GMT', 'Content-Type': 'application/json; charset=utf-8',...}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;.headers&lt;/code&gt; 返回类似字典的对象，允许你使用键来获取头部中的值。 例如，要查看响应有效负载的内容类型，你可以访问 &lt;code&gt;Content-Type&lt;/code&gt; ：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; response.headers['Content-Type']
'application/json; charset=utf-8'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是，这个类似于字典的头部对象有一些特别之处。 HTTP规范定义头部不区分大小写，这意味着我们可以访问这些头信息而不必担心它们的大小写：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; response.headers['content-type']
'application/json; charset=utf-8'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;无论您使用 &lt;code&gt;'content-type'&lt;/code&gt; 还是 &lt;code&gt;'Content-Type'&lt;/code&gt;，你都将获得相同的值。&lt;/p&gt;
&lt;p&gt;现在，你已经学习了有关 &lt;code&gt;Response&lt;/code&gt; 的基础知识。 你已经看到了它最有用的属性和方法。 让我们退后一步，看看自定义 &lt;code&gt;GET&lt;/code&gt; 请求时你的响应如何变化。&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;自定义 &lt;code&gt;GET&lt;/code&gt; 请求的一种常用方法是通过URL中的 &lt;a href=&quot;https://en.wikipedia.org/wiki/Query_string&quot;&gt;查询字符串&lt;/a&gt; 参数传递值。 要使用 &lt;code&gt;get()&lt;/code&gt; 执行此操作，请将数据传递给 &lt;code&gt;params&lt;/code&gt; 。 例如，你可以使用GitHub的&lt;a href=&quot;https://developer.github.com/v3/search/&quot;&gt;Search&lt;/a&gt; API来查找 &lt;code&gt;requests&lt;/code&gt; 库：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import requests

# Search GitHub's repositories for requests
response = requests.get(
    'https://api.github.com/search/repositories',
    params={'q': 'requests+language:python'},
)

# Inspect some attributes of the `requests` repository
json_response = response.json()
repository = json_response['items'][0]
print(f'Repository name: {repository[&quot;name&quot;]}')  # Python 3.6+
print(f'Repository description: {repository[&quot;description&quot;]}')  # Python 3.6+&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过将字典 &lt;code&gt;{'q'：'requests + language：python'}&lt;/code&gt; 传递给 &lt;code&gt;.get()&lt;/code&gt; 的 &lt;code&gt;params&lt;/code&gt; 参数，你可以修改从Search API返回的结果。&lt;/p&gt;
&lt;p&gt;你可以像你刚才那样以字典的形式或以元组列表形式将 &lt;code&gt;params&lt;/code&gt; 传递给 &lt;code&gt;get()&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; requests.get(
...     'https://api.github.com/search/repositories',
...     params=[('q', 'requests+language:python')],
... )
&amp;lt;Response [200]&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你甚至可以传 &lt;code&gt;bytes&lt;/code&gt; 作为值:&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; requests.get(
...     'https://api.github.com/search/repositories',
...     params=b'q=requests+language:python',
... )
&amp;lt;Response [200]&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查询字符串对于参数化GET请求很有用。 你还可以通过添加或修改发送的请求的头部来自定义你的请求。&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;要自定义请求头，你可以使用 &lt;code&gt;headers&lt;/code&gt; 参数将HTTP头部组成的字典传递给 &lt;code&gt;get()&lt;/code&gt;。 例如，你可以通过 &lt;code&gt;Accept&lt;/code&gt; 中指定文本匹配媒体类型来更改以前的搜索请求，以在结果中突出显示匹配的搜索字词：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import requests

response = requests.get(
    'https://api.github.com/search/repositories',
    params={'q': 'requests+language:python'},
    headers={'Accept': 'application/vnd.github.v3.text-match+json'},
)

# View the new `text-matches` array which provides information
# about your search term within the results
json_response = response.json()
repository = json_response['items'][0]
print(f'Text matches: {repository[&quot;text_matches&quot;]}')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Accept&lt;/code&gt; 告诉服务器你的应用程序可以处理哪些内容类型。 由于你希望突出显示匹配的搜索词，所以使用的是 &lt;code&gt;application / vnd.github.v3.text-match + json&lt;/code&gt;，这是一个专有的GitHub的 &lt;code&gt;Accept&lt;/code&gt; 标头，其内容为特殊的JSON格式。&lt;/p&gt;
&lt;p&gt;在你了解更多自定义请求的方法之前，让我们通过探索其他HTTP方法来拓宽视野。&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;除了 &lt;code&gt;GET&lt;/code&gt; 之外，其他流行的HTTP方法包括 &lt;code&gt;POST&lt;/code&gt; ，`&lt;code&gt;PUT&lt;/code&gt; ，&lt;code&gt;DELETE&lt;/code&gt;，&lt;code&gt;HEAD&lt;/code&gt;，&lt;code&gt;PATCH&lt;/code&gt;和&lt;code&gt;OPTIONS&lt;/code&gt;。 &lt;code&gt;requests&lt;/code&gt; 为每个HTTP方法提供了一个方法，与 &lt;code&gt;get()&lt;/code&gt; `具有类似的结构:&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; requests.post('https://httpbin.org/post', data={'key':'value'})
&amp;gt;&amp;gt;&amp;gt; requests.put('https://httpbin.org/put', data={'key':'value'})
&amp;gt;&amp;gt;&amp;gt; requests.delete('https://httpbin.org/delete')
&amp;gt;&amp;gt;&amp;gt; requests.head('https://httpbin.org/get')
&amp;gt;&amp;gt;&amp;gt; requests.patch('https://httpbin.org/patch', data={'key':'value'})
&amp;gt;&amp;gt;&amp;gt; requests.options('https://httpbin.org/get')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;调用每个函数使用相应的HTTP方法向httpbin服务发出请求。 对于每种方法，你可以像以前一样查看其响应：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; response = requests.head('https://httpbin.org/get')
&amp;gt;&amp;gt;&amp;gt; response.headers['Content-Type']
'application/json'

&amp;gt;&amp;gt;&amp;gt; response = requests.delete('https://httpbin.org/delete')
&amp;gt;&amp;gt;&amp;gt; json_response = response.json()
&amp;gt;&amp;gt;&amp;gt; json_response['args']
{}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;每种方法的响应中都会返回头部，响应正文，状态码等。 接下来，你将进一步了解 &lt;code&gt;POST&lt;/code&gt;，`&lt;code&gt;PUT&lt;/code&gt; 和 &lt;code&gt;PATCH&lt;/code&gt; 方法，并了解它们与其他请求类型的区别。&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;根据HTTP规范，&lt;code&gt;POST&lt;/code&gt;，`&lt;code&gt;PUT&lt;/code&gt;和不太常见的&lt;code&gt;PATCH&lt;/code&gt;请求通过消息体而不是通过查询字符串参数传递它们的数据。 使用 &lt;code&gt;requests&lt;/code&gt;，你将有效负载传递给相应函数的 &lt;code&gt;data&lt;/code&gt; 参数。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;data&lt;/code&gt; 接收字典，元组列表，字节或类文件对象。 你需要将在请求正文中发送的数据调整为与你交互的服务的特定格式。&lt;/p&gt;
&lt;p&gt;例如，如果你的请求的内容类型是 &lt;code&gt;application / x-www-form-urlencoded&lt;/code&gt; ，则可以将表单数据作为字典发送：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; requests.post('https://httpbin.org/post', data={'key':'value'})
&amp;lt;Response [200]&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你还可以将相同的数据作为元组列表发送:&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; requests.post('https://httpbin.org/post', data=[('key', 'value')])
&amp;lt;Response [200]&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是，如果需要发送JSON数据，则可以使用 &lt;code&gt;json&lt;/code&gt; 参数。 当你通过 &lt;code&gt;json&lt;/code&gt; 传递JSON数据时，&lt;code&gt;requests&lt;/code&gt; 将序列化你的数据并为你添加正确的 &lt;code&gt;Content-Type&lt;/code&gt; 标头。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://httpbin.org/&quot;&gt;httpbin.org&lt;/a&gt; 是 &lt;code&gt;requests&lt;/code&gt; 作者 &lt;a href=&quot;https://realpython.com/interview-kenneth-reitz/&quot;&gt;Kenneth Reitz&lt;/a&gt; 创建的一个很好的资源。 它是一种接收测试请求并响应有关请求数据的服务。 例如，你可以使用它来检查基本的POST请求:&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; response = requests.post('https://httpbin.org/post', json={'key':'value'})
&amp;gt;&amp;gt;&amp;gt; json_response = response.json()
&amp;gt;&amp;gt;&amp;gt; json_response['data']
'{&quot;key&quot;: &quot;value&quot;}'
&amp;gt;&amp;gt;&amp;gt; json_response['headers']['Content-Type']
'application/json'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你可以从响应中看到服务器在你发送请求时收到了请求数据和标头。 &lt;code&gt;requests&lt;/code&gt; 还以 &lt;code&gt;PreparedRequest&lt;/code&gt; 的形式向你提供此信息。&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;当你发出请求时，&lt;code&gt;requests&lt;/code&gt; 库会在将请求实际发送到目标服务器之前准备该请求。 请求准备包括像验证头信息和序列化JSON内容等。&lt;/p&gt;
&lt;p&gt;你可以通过访问 &lt;code&gt;.request&lt;/code&gt; 来查看 &lt;code&gt;PreparedRequest&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; response = requests.post('https://httpbin.org/post', json={'key':'value'})
&amp;gt;&amp;gt;&amp;gt; response.request.headers['Content-Type']
'application/json'
&amp;gt;&amp;gt;&amp;gt; response.request.url
'https://httpbin.org/post'
&amp;gt;&amp;gt;&amp;gt; response.request.body
b'{&quot;key&quot;: &quot;value&quot;}'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过检查 &lt;code&gt;PreparedRequest&lt;/code&gt; ，你可以访问有关正在进行的请求的各种信息，例如有效负载，URL，头信息，身份验证等。&lt;/p&gt;
&lt;p&gt;到目前为止，你已经发送了许多不同类型的请求，但它们都有一个共同点：它们是对公共API的未经身份验证的请求。 你遇到的许多服务可能都希望你以某种方式进行身份验证。&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;身份验证可帮助服务了解你的身份。 通常，你通过将数据传递到 &lt;code&gt;Authorization&lt;/code&gt; 头信息或服务定义的自定义头信息来向服务器提供凭据。 你在此处看到的所有请求函数都提供了一个名为 &lt;code&gt;auth&lt;/code&gt; 的参数，允许你传递凭据。&lt;/p&gt;
&lt;p&gt;需要身份验证的一个示例API的是GitHub的 &lt;a href=&quot;https://developer.github.com/v3/users/#get-the-authenticated-user&quot;&gt;Authenticated User&lt;/a&gt; API。 此端点提供有关经过身份验证的用户配置文件的信息。 要向 &lt;code&gt;Authenticated User API&lt;/code&gt; 发出请求，你可以将你的GitHub的用户名和密码以元组传递给 &lt;code&gt;get()&lt;/code&gt; ：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; from getpass import getpass
&amp;gt;&amp;gt;&amp;gt; requests.get('https://api.github.com/user', auth=('username', getpass()))
&amp;lt;Response [200]&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果你在元组中传递给 &lt;code&gt;auth&lt;/code&gt; 的凭据有效，则请求成功。 如果你尝试在没有凭据的情况下发出此请求，你将看到状态代码为 &lt;code&gt;401 Unauthorized&lt;/code&gt; :&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; requests.get('https://api.github.com/user')
&amp;lt;Response [401]&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当你以元组形式吧用户名和密码传递给 &lt;code&gt;auth&lt;/code&gt; 参数时，&lt;code&gt;rqeuests&lt;/code&gt; 将使用HTTP的基本访问认证方案来应用凭据。&lt;/p&gt;
&lt;p&gt;因此，你可以通过使用 &lt;code&gt;HTTPBasicAuth&lt;/code&gt; 传递显式的基本身份验证凭据来发出相同的请求：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; from requests.auth import HTTPBasicAuth
&amp;gt;&amp;gt;&amp;gt; from getpass import getpass
&amp;gt;&amp;gt;&amp;gt; requests.get(
...     'https://api.github.com/user',
...     auth=HTTPBasicAuth('username', getpass())
... )
&amp;lt;Response [200]&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;虽然你不需要明确进行基本身份验证，但你可能希望使用其他方法进行身份验证。 &lt;code&gt;requests&lt;/code&gt; 提供了开箱即用的其他身份验证方法，例如 &lt;code&gt;HTTPDigestAuth&lt;/code&gt; 和 &lt;code&gt;HTTPProxyAuth&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;你甚至可以提供自己的身份验证机制。 为此，你必须首先创建AuthBase的子类。 然后，实现&lt;code&gt;__call __()&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import requests
from requests.auth import AuthBase

class TokenAuth(AuthBase):
    &quot;&quot;&quot;Implements a custom authentication scheme.&quot;&quot;&quot;

    def __init__(self, token):
        self.token = token

    def __call__(self, r):
        &quot;&quot;&quot;Attach an API token to a custom auth header.&quot;&quot;&quot;
        r.headers['X-TokenAuth'] = f'{self.token}'  # Python 3.6+
        return r


requests.get('https://httpbin.org/get', auth=TokenAuth('12345abcde-token'))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这里，你自定义的 &lt;code&gt;TokenAuth&lt;/code&gt; 接收一个令牌，然后在你的请求头中的 &lt;code&gt;X-TokenAuth&lt;/code&gt; 头中包含该令牌。&lt;/p&gt;
&lt;p&gt;错误的身份验证机制可能会导致安全漏洞，因此，除非服务因某种原因需要自定义身份验证机制，否则你始终希望使用像 &lt;code&gt;Basic&lt;/code&gt; 或 &lt;code&gt;OAuth&lt;/code&gt; 这样经过验证的身份验证方案。&lt;/p&gt;
&lt;p&gt;在考虑安全性时，让我们考虑使用 &lt;code&gt;requests&lt;/code&gt; 处理SSL证书。&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;每当你尝试发送或接收的数据都很敏感时，安全性就很重要。 通过HTTP与站点安全通信的方式是使用SSL建立加密连接，这意味着验证目标服务器的SSL证书至关重要。&lt;/p&gt;
&lt;p&gt;好消息是 &lt;code&gt;requests&lt;/code&gt; 默认为你执行此操作。 但是，在某些情况下，你可能希望更改此行为。&lt;/p&gt;
&lt;p&gt;如果要禁用SSL证书验证，请将 &lt;code&gt;False&lt;/code&gt; 传递给请求函数的 &lt;code&gt;verify&lt;/code&gt; 参数:&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; requests.get('https://api.github.com', verify=False)
InsecureRequestWarning: Unverified HTTPS request is being made. Adding certificate verification is strongly advised. See: https://urllib3.readthedocs.io/en/latest/advanced-usage.html#ssl-warnings
  InsecureRequestWarning)
&amp;lt;Response [200]&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当你提出不安全的请求时，&lt;code&gt;requests&lt;/code&gt; 甚至会发出警告来帮助你保护数据安全。&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;在使用 &lt;code&gt;requests&lt;/code&gt; 时，尤其是在生产应用程序环境中，考虑性能影响非常重要。 超时控制，会话和重试限制等功能可以帮助你保持应用程序平稳运行。&lt;/p&gt;
&lt;h2 id=&quot;超时控制&quot;&gt;超时控制&lt;/h2&gt;
&lt;p&gt;当你向外部服务发出请求时，系统将需要等待响应才能继续。 如果你的应用程序等待响应的时间太长，则可能会阻塞对你的服务的请求，你的用户体验可能会受到影响，或者你的后台作业可能会挂起。&lt;/p&gt;
&lt;p&gt;默认情况下，&lt;code&gt;requests&lt;/code&gt; 将无限期地等待响应，因此你几乎应始终指定超时时间以防止这些事情发生。 要设置请求的超时，请使用 &lt;code&gt;timeout&lt;/code&gt; 参数。 &lt;code&gt;timeout&lt;/code&gt; 可以是一个整数或浮点数，表示在超时之前等待响应的秒数:&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; requests.get('https://api.github.com', timeout=1)
&amp;lt;Response [200]&amp;gt;
&amp;gt;&amp;gt;&amp;gt; requests.get('https://api.github.com', timeout=3.05)
&amp;lt;Response [200]&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在第一个请求中，请求将在1秒后超时。 在第二个请求中，请求将在3.05秒后超时。&lt;/p&gt;
&lt;p&gt;你还可以将元组传递给 &lt;code&gt;timeout&lt;/code&gt;，第一个元素是连接超时（它允许客户端与服务器建立连接的时间），第二个元素是读取超时（一旦你的客户已建立连接而等待响应的时间）:&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; requests.get('https://api.github.com', timeout=(2, 5))
&amp;lt;Response [200]&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果请求在2秒内建立连接并在建立连接的5秒内接收数据，则响应将按原样返回。 如果请求超时，则该函数将抛出 &lt;code&gt;Timeout&lt;/code&gt; 异常：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import requests
from requests.exceptions import Timeout

try:
    response = requests.get('https://api.github.com', timeout=1)
except Timeout:
    print('The request timed out')
else:
    print('The request did not time out')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你的程序可以捕获 &lt;code&gt;Timeout&lt;/code&gt; 异常并做出相应的响应。&lt;/p&gt;
&lt;h2 id=&quot;session对象&quot;&gt;Session对象&lt;/h2&gt;
&lt;p&gt;到目前为止，你一直在处理高级请求API，例如 &lt;code&gt;get()&lt;/code&gt; 和 &lt;code&gt;post()&lt;/code&gt;。 这些函数是你发出请求时所发生的事情的抽象。 为了你不必担心它们，它们隐藏了实现细节，例如如何管理连接。&lt;/p&gt;
&lt;p&gt;在这些抽象之下是一个名为 &lt;code&gt;Session&lt;/code&gt; 的类。 如果你需要微调对请求的控制方式或提高请求的性能，则可能需要直接使用 &lt;code&gt;Session&lt;/code&gt; 实例。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Session&lt;/code&gt; 用于跨请求保留参数。 例如，如果要跨多个请求使用相同的身份验证，则可以使用&lt;code&gt;session&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import requests
from getpass import getpass

# By using a context manager, you can ensure the resources used by
# the session will be released after use
with requests.Session() as session:
    session.auth = ('username', getpass())

    # Instead of requests.get(), you'll use session.get()
    response = session.get('https://api.github.com/user')

# You can inspect the response just like you did before
print(response.headers)
print(response.json())&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;每次使用 &lt;code&gt;session&lt;/code&gt; 发出请求时，一旦使用身份验证凭据初始化，凭据将被保留。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;session&lt;/code&gt; 的主要性能优化以持久连接的形式出现。 当你的应用程序使用 &lt;code&gt;Session&lt;/code&gt; 建立与服务器的连接时，它会在连接池中保持该连接。 当你的应用程序想要再次连接到同一服务器时，它将重用池中的连接而不是建立新连接。&lt;/p&gt;
&lt;h2 id=&quot;最大重试&quot;&gt;最大重试&lt;/h2&gt;
&lt;p&gt;请求失败时，你可能希望应用程序重试相同的请求。 但是，默认情况下，&lt;code&gt;requests&lt;/code&gt; 不会为你执行此操作。 要应用此功能，您需要实现自定义 &lt;a href=&quot;http://docs.python-requests.org/en/master/user/advanced/#transport-adapters&quot;&gt;Transport Adapter&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;通过 &lt;code&gt;Transport Adapters&lt;/code&gt;，你可以为每个与之交互的服务定义一组配置。 例如，假设你希望所有对于https://api.github.com的请求在最终抛出 &lt;code&gt;ConnectionError&lt;/code&gt; 之前重试三次。 你将构建一个 &lt;code&gt;Transport Adapter&lt;/code&gt;，设置其 &lt;code&gt;max_retries&lt;/code&gt; 参数，并将其装载到现有的 &lt;code&gt;Session&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import requests
from requests.adapters import HTTPAdapter
from requests.exceptions import ConnectionError

github_adapter = HTTPAdapter(max_retries=3)

session = requests.Session()

# Use `github_adapter` for all requests to endpoints that start with this URL
session.mount('https://api.github.com', github_adapter)

try:
    session.get('https://api.github.com')
except ConnectionError as ce:
    print(ce)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当您将 &lt;code&gt;HTTPAdapter(github_adapter)&lt;/code&gt;挂载到 &lt;code&gt;session&lt;/code&gt; 时，&lt;code&gt;session&lt;/code&gt;将遵循其对https://api.github.com的每个请求的配置。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Timeouts&lt;/code&gt;，&lt;code&gt;Transport Adapters&lt;/code&gt;和 &lt;code&gt;Sessions&lt;/code&gt; 用于保持代码高效和应用程序的鲁棒性。&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;在学习Python中强大的 &lt;code&gt;requests&lt;/code&gt; 库方面，你已经走了很长的路。&lt;/p&gt;
&lt;p&gt;你现在能够：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用各种不同的HTTP方法发出请求，例如GET，POST和PUT&lt;/li&gt;
&lt;li&gt;通过修改请求头，身份验证，查询字符串和消息体来自定义你的请求&lt;/li&gt;
&lt;li&gt;检查发送到服务器的数据以及服务器发回给你的数据&lt;/li&gt;
&lt;li&gt;使用SSL证书验证&lt;/li&gt;
&lt;li&gt;高效的使用&lt;code&gt;requests&lt;/code&gt; 通过使用 &lt;code&gt;max_retries&lt;/code&gt;，&lt;code&gt;timeout&lt;/code&gt;，&lt;code&gt;Sessions&lt;/code&gt; 和 &lt;code&gt;Transport Adapters&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;因为您学会了如何使用 &lt;code&gt;requests&lt;/code&gt;，所以你可以使用他们提供的迷人数据探索广泛的Web服务世界并构建出色的应用程序了。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://i.loli.net/2019/02/04/5c57ae3acb5c8.jpg&quot;&gt;&lt;img src=&quot;https://i.loli.net/2019/02/04/5c57ae3acb5c8.jpg&quot; alt=&quot;代码与艺术&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;关注公众号 &amp;lt;代码与艺术&amp;gt;，学习更多国外精品技术文章。&lt;/p&gt;
</description>
<pubDate>Sat, 16 Feb 2019 14:48:00 +0000</pubDate>
<dc:creator>jiangyx</dc:creator>
<og:description>本文为译文，原文链接 'python requests library guide' 本人博客: '编程禅师' 'requests' 库是用来在Python中发出标准的HTTP请求。 它将请求背后的复</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Jiangyx/p/10389631.html</dc:identifier>
</item>
<item>
<title>Feign源码解析系列-那些注解们 - 每当变幻时</title>
<link>http://www.cnblogs.com/killbug/p/10389530.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/killbug/p/10389530.html</guid>
<description>&lt;h3 id=&quot;开始&quot;&gt;开始&lt;/h3&gt;
&lt;p&gt;Feign在Spring Cloud体系中被整合进来作为web service客户端，使用HTTP请求远程服务时能就像调用本地方法，可见在未来一段时间内，大多数Spring Cloud架构的微服务之间调用都会使用Feign来完成。&lt;/p&gt;
&lt;p&gt;所以准备完整解读一遍Feign的源码，读源码，我个人觉得一方面，可以在使用的基础上对内部实现的细节的了解，提高使用时对组件功能的信心，另一方面，开源组件的代码质量一般都比较高，对代码结构组织一般比较优秀，还有，内部实现的一些细节可能优秀开发的思考所得，值得仔细揣摩。我对后两个好处比较感兴趣，虽然现如今写的代码好与坏，其实不会太多的影响平时的工作，不过如果内心是真的爱代码，也会不断追求细节的极致。&lt;/p&gt;
&lt;p&gt;因为是Spring Cloud体系下使用Feign，必然会涉及到：服务注册（Euraka），负载均衡（Rinbon），熔断器（Hystrix）等方面的整合知识。&lt;/p&gt;
&lt;p&gt;另外，能思考的高度和广度必然有限，但是源码阅读学习又难以共同参与，所以刚好你也在这个位置，有自己的思路或想法，不吝留言。&lt;/p&gt;
&lt;h3 id=&quot;内容&quot;&gt;内容&lt;/h3&gt;
&lt;h4 id=&quot;enablefeignclients注解&quot;&gt;1，EnableFeignClients注解&lt;/h4&gt;
&lt;p&gt;大流程上，就是扫描FeignClient注解的接口，将接口方法动态代理成http客户端的接口请求操作就完成了Feign的目的。所以一个FeignClient注解对应一个客户端。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;EnableFeignClients这个注解可以配置扫描FeignClient注解的路径。可以通过value属性或basePackages属性来制定扫描的包路径。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;basePackageClasses属性并不是精准扫描哪几个Class，而是指定这些指定的class在的package会被扫描。所以注释中推荐写一个空接口来标记这个package要被扫描的方式来关联。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;defaultConfiguration属性是可以定义全局Feign配置的类，默认使用FeignClientsConfiguration类。想要自定义需要好好确认下FeignClientsConfiguration定义了那一些bean。当然如果只是想覆盖部分bean，完全不用这个，直接在Configuration定义对应bean即可。&lt;/li&gt;
&lt;li&gt;clients属性才是精准指定Class扫描，与package扫描互斥。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@Documented
@Import(FeignClientsRegistrar.class)
public @interface EnableFeignClients {
   /**
    * Alias for the {@link #basePackages()} attribute. Allows for more concise annotation
    * declarations e.g.: {@code @ComponentScan(&quot;org.my.pkg&quot;)} instead of
    * {@code @ComponentScan(basePackages=&quot;org.my.pkg&quot;)}.
    * @return the array of 'basePackages'.
    */
   String[] value() default {};
   /**
    * Base packages to scan for annotated components.
    * &amp;lt;p&amp;gt;
    * {@link #value()} is an alias for (and mutually exclusive with) this attribute.
    * &amp;lt;p&amp;gt;
    * Use {@link #basePackageClasses()} for a type-safe alternative to String-based
    * package names.
    *
    * @return the array of 'basePackages'.
    */
   String[] basePackages() default {};
   /**
    * Type-safe alternative to {@link #basePackages()} for specifying the packages to
    * scan for annotated components. The package of each class specified will be scanned.
    * &amp;lt;p&amp;gt;
    * Consider creating a special no-op marker class or interface in each package that
    * serves no purpose other than being referenced by this attribute.
    *
    * @return the array of 'basePackageClasses'.
    */
   Class&amp;lt;?&amp;gt;[] basePackageClasses() default {};
   /**
    * A custom &amp;lt;code&amp;gt;@Configuration&amp;lt;/code&amp;gt; for all feign clients. Can contain override
    * &amp;lt;code&amp;gt;@Bean&amp;lt;/code&amp;gt; definition for the pieces that make up the client, for instance
    * {@link feign.codec.Decoder}, {@link feign.codec.Encoder}, {@link feign.Contract}.
    *
    * @see FeignClientsConfiguration for the defaults
    */
   Class&amp;lt;?&amp;gt;[] defaultConfiguration() default {};
   /**
    * List of classes annotated with @FeignClient. If not empty, disables classpath scanning.
    * @return
    */
   Class&amp;lt;?&amp;gt;[] clients() default {};
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从EnableFeignClients注解的属性看，我们可以了解到，在解析这个注解属性的时候，需要利用配置的扫描的package或Class，扫描FeignClient注解，进而解析那些FeignClient注解的配置属性。并且我们还可以配置全局的Feign相关的配置。&lt;/p&gt;
&lt;p&gt;回头我们再看一下EnableFeignClients定义的元数据，@Import注解的使用值得学习一下。&lt;/p&gt;
&lt;p&gt;关于这个注解，我们可以理解成导入&lt;/p&gt;
&lt;p&gt;@Import注解导入的类 FeignClientsRegistrar 是继承 ImportBeanDefinitionRegistrar 的，ImportBeanDefinitionRegistrar的方法一般实现动态注册bean使用，在由@Import注解导入后，Spring容器启动时会执行registerBeanDefinitions方法。&lt;/p&gt;
&lt;p&gt;所以一般@Import注解和ImportBeanDefinitionRegistrar实现动态注册bean而配合使用。&lt;/p&gt;
&lt;p&gt;前面提到大流程，&lt;a href=&quot;https://zhuanlan.zhihu.com/p/30123517&quot;&gt;这篇文章&lt;/a&gt;的思路基本描述了：扫描+动态代理接口+http请求，其中也对@Import和ImportBeanDefinitionRegistrar使用场景进行了解释，可以做参考学习。&lt;/p&gt;
&lt;h4 id=&quot;feignclient注解&quot;&gt;2，FeignClient注解&lt;/h4&gt;
&lt;p&gt;每个FeignClient代表一个http客户端，定义的每一个方法对应这个一个接口。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;value和name用于定义http客户端服务的名称，在spring cloud为服务之间调用服务总要有负载均衡的，比如Rinbon。所以这里定义的会是服务提供方的应用名（serviceId）。&lt;/li&gt;
&lt;li&gt;qualifier属性在spring容器中定义FeignClient的bean时，配置名称，在装配bean的时候可以用这个名称装配。使用spring的注解：Qualifier。&lt;/li&gt;
&lt;li&gt;url属性用来定义请求的绝对URL。&lt;/li&gt;
&lt;li&gt;decode404属性，在客户端返回404时是进行decode操作还是抛出异常的标记。&lt;/li&gt;
&lt;li&gt;configuration属性，自定义配置类，可以定义Decoder, Encoder，Contract来覆盖默认的配置，可以参考默认的配置类：FeignAutoConfiguration&lt;/li&gt;
&lt;li&gt;fallback属性 使用fallback机制时可以配置的类属性，继承客户端接口，实现fallback逻辑。如果要使用fallback机制需要配合Hystrix一起，所以需要开启Hystrix。&lt;/li&gt;
&lt;li&gt;fallbackFactory属性 生产fallback实例，生产的自然是继承客户端接口的实例。&lt;/li&gt;
&lt;li&gt;path属性 每个接口url的统一前缀&lt;/li&gt;
&lt;li&gt;primary属性 标记在spring容器中为primary bean&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * Annotation for interfaces declaring that a REST client with that interface should be
 * created (e.g. for autowiring into another component). If ribbon is available it will be
 * used to load balance the backend requests, and the load balancer can be configured
 * using a &amp;lt;code&amp;gt;@RibbonClient&amp;lt;/code&amp;gt; with the same name (i.e. value) as the feign client.
 *
 * @author Spencer Gibb
 * @author Venil Noronha
 */
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface FeignClient {
   /**
    * The name of the service with optional protocol prefix. Synonym for {@link #name()
    * name}. A name must be specified for all clients, whether or not a url is provided.
    * Can be specified as property key, eg: ${propertyKey}.
    */
   @AliasFor(&quot;name&quot;)
   String value() default &quot;&quot;;
   /**
    * The service id with optional protocol prefix. Synonym for {@link #value() value}.
    *
    * @deprecated use {@link #name() name} instead
    */
   @Deprecated
   String serviceId() default &quot;&quot;;
   /**
    * The service id with optional protocol prefix. Synonym for {@link #value() value}.
    */
   @AliasFor(&quot;value&quot;)
   String name() default &quot;&quot;;
   
   /**
    * Sets the &amp;lt;code&amp;gt;@Qualifier&amp;lt;/code&amp;gt; value for the feign client.
    */
   String qualifier() default &quot;&quot;;
   /**
    * An absolute URL or resolvable hostname (the protocol is optional).
    */
   String url() default &quot;&quot;;
   /**
    * Whether 404s should be decoded instead of throwing FeignExceptions
    */
   boolean decode404() default false;
   /**
    * A custom &amp;lt;code&amp;gt;@Configuration&amp;lt;/code&amp;gt; for the feign client. Can contain override
    * &amp;lt;code&amp;gt;@Bean&amp;lt;/code&amp;gt; definition for the pieces that make up the client, for instance
    * {@link feign.codec.Decoder}, {@link feign.codec.Encoder}, {@link feign.Contract}.
    *
    * @see FeignClientsConfiguration for the defaults
    */
   Class&amp;lt;?&amp;gt;[] configuration() default {};
   /**
    * Fallback class for the specified Feign client interface. The fallback class must
    * implement the interface annotated by this annotation and be a valid spring bean.
    */
   Class&amp;lt;?&amp;gt; fallback() default void.class;
   /**
    * Define a fallback factory for the specified Feign client interface. The fallback
    * factory must produce instances of fallback classes that implement the interface
    * annotated by {@link FeignClient}. The fallback factory must be a valid spring
    * bean.
    *
    * @see feign.hystrix.FallbackFactory for details.
    */
   Class&amp;lt;?&amp;gt; fallbackFactory() default void.class;
   /**
    * Path prefix to be used by all method-level mappings. Can be used with or without
    * &amp;lt;code&amp;gt;@RibbonClient&amp;lt;/code&amp;gt;.
    */
   String path() default &quot;&quot;;
   /**
    * Whether to mark the feign proxy as a primary bean. Defaults to true.
    */
   boolean primary() default true;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过FeignClient注解的属性，可以看到针对单个Feign客户端可以做自定义的配置。&lt;/p&gt;
&lt;h4 id=&quot;定义客户端接口的注解&quot;&gt;3，定义客户端接口的注解&lt;/h4&gt;
&lt;p&gt;在Feign中需要定义http接口的办法，注解是个好解决方案。这里就看到Contract的接口，解析这些注解用的，下面是抽象类BaseContract，它有默认实现，即Contract.Default，解析了自定义注解：feign.Headers，feign.RequestLine，feign.Body，feign.Param，feign.QueryMap，feign.HeaderMap，这些注解都是用来定义描述http客户端提供的接口信息的。&lt;/p&gt;
&lt;p&gt;但是因为这里默认将Feign和Spring Cloud体系中使用，而提供了SpringMvcContract类来解析使用的注解，而这个注解就是RequestMapping。这个注解使用过spring mvc的同学必然非常熟悉，这里就是利用了这个注解的定义进行解析，只是功能上并不是和spring保持完全一致，毕竟它这里只需要考虑将接口信息定义出来即可。&lt;/p&gt;
&lt;p&gt;在SpringMvcContract的代码里，可以看到解析RequestMapping注解属性的逻辑代码，如此在使用中可以直接使用RequestMapping来定义接口。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;value属性和path属性定义接口路径&lt;/li&gt;
&lt;li&gt;method属性配置HTTP请求方法&lt;/li&gt;
&lt;li&gt;params属性在feign中不支持&lt;/li&gt;
&lt;li&gt;headers属性配置http头信息&lt;/li&gt;
&lt;li&gt;consumes属性配置http头信息，只解析使用配置了 Content-Type 属性的值&lt;/li&gt;
&lt;li&gt;produces属性配置http头信息，只解析使用配置了 Accept 属性的值&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Mapping
public @interface RequestMapping {
   /**
    * Assign a name to this mapping.
    * &amp;lt;p&amp;gt;&amp;lt;b&amp;gt;Supported at the type level as well as at the method level!&amp;lt;/b&amp;gt;
    * When used on both levels, a combined name is derived by concatenation
    * with &quot;#&quot; as separator.
    * @see org.springframework.web.servlet.mvc.method.annotation.MvcUriComponentsBuilder
    * @see org.springframework.web.servlet.handler.HandlerMethodMappingNamingStrategy
    */
   String name() default &quot;&quot;;
   /**
    * The primary mapping expressed by this annotation.
    * &amp;lt;p&amp;gt;In a Servlet environment this is an alias for {@link #path}.
    * For example {@code @RequestMapping(&quot;/foo&quot;)} is equivalent to
    * {@code @RequestMapping(path=&quot;/foo&quot;)}.
    * &amp;lt;p&amp;gt;In a Portlet environment this is the mapped portlet modes
    * (i.e. &quot;EDIT&quot;, &quot;VIEW&quot;, &quot;HELP&quot; or any custom modes).
    * &amp;lt;p&amp;gt;&amp;lt;b&amp;gt;Supported at the type level as well as at the method level!&amp;lt;/b&amp;gt;
    * When used at the type level, all method-level mappings inherit
    * this primary mapping, narrowing it for a specific handler method.
    */
   @AliasFor(&quot;path&quot;)
   String[] value() default {};
   /**
    * In a Servlet environment only: the path mapping URIs (e.g. &quot;/myPath.do&quot;).
    * Ant-style path patterns are also supported (e.g. &quot;/myPath/*.do&quot;).
    * At the method level, relative paths (e.g. &quot;edit.do&quot;) are supported within
    * the primary mapping expressed at the type level. Path mapping URIs may
    * contain placeholders (e.g. &quot;/${connect}&quot;)
    * &amp;lt;p&amp;gt;&amp;lt;b&amp;gt;Supported at the type level as well as at the method level!&amp;lt;/b&amp;gt;
    * When used at the type level, all method-level mappings inherit
    * this primary mapping, narrowing it for a specific handler method.
    * @see org.springframework.web.bind.annotation.ValueConstants#DEFAULT_NONE
    * @since 4.2
    */
   @AliasFor(&quot;value&quot;)
   String[] path() default {};
   /**
    * The HTTP request methods to map to, narrowing the primary mapping:
    * GET, POST, HEAD, OPTIONS, PUT, PATCH, DELETE, TRACE.
    * &amp;lt;p&amp;gt;&amp;lt;b&amp;gt;Supported at the type level as well as at the method level!&amp;lt;/b&amp;gt;
    * When used at the type level, all method-level mappings inherit
    * this HTTP method restriction (i.e. the type-level restriction
    * gets checked before the handler method is even resolved).
    * &amp;lt;p&amp;gt;Supported for Servlet environments as well as Portlet 2.0 environments.
    */
   RequestMethod[] method() default {};
   /**
    * The parameters of the mapped request, narrowing the primary mapping.
    * &amp;lt;p&amp;gt;Same format for any environment: a sequence of &quot;myParam=myValue&quot; style
    * expressions, with a request only mapped if each such parameter is found
    * to have the given value. Expressions can be negated by using the &quot;!=&quot; operator,
    * as in &quot;myParam!=myValue&quot;. &quot;myParam&quot; style expressions are also supported,
    * with such parameters having to be present in the request (allowed to have
    * any value). Finally, &quot;!myParam&quot; style expressions indicate that the
    * specified parameter is &amp;lt;i&amp;gt;not&amp;lt;/i&amp;gt; supposed to be present in the request.
    * &amp;lt;p&amp;gt;&amp;lt;b&amp;gt;Supported at the type level as well as at the method level!&amp;lt;/b&amp;gt;
    * When used at the type level, all method-level mappings inherit
    * this parameter restriction (i.e. the type-level restriction
    * gets checked before the handler method is even resolved).
    * &amp;lt;p&amp;gt;In a Servlet environment, parameter mappings are considered as restrictions
    * that are enforced at the type level. The primary path mapping (i.e. the
    * specified URI value) still has to uniquely identify the target handler, with
    * parameter mappings simply expressing preconditions for invoking the handler.
    * &amp;lt;p&amp;gt;In a Portlet environment, parameters are taken into account as mapping
    * differentiators, i.e. the primary portlet mode mapping plus the parameter
    * conditions uniquely identify the target handler. Different handlers may be
    * mapped onto the same portlet mode, as long as their parameter mappings differ.
    */
   String[] params() default {};
   /**
    * The headers of the mapped request, narrowing the primary mapping.
    * &amp;lt;p&amp;gt;Same format for any environment: a sequence of &quot;My-Header=myValue&quot; style
    * expressions, with a request only mapped if each such header is found
    * to have the given value. Expressions can be negated by using the &quot;!=&quot; operator,
    * as in &quot;My-Header!=myValue&quot;. &quot;My-Header&quot; style expressions are also supported,
    * with such headers having to be present in the request (allowed to have
    * any value). Finally, &quot;!My-Header&quot; style expressions indicate that the
    * specified header is &amp;lt;i&amp;gt;not&amp;lt;/i&amp;gt; supposed to be present in the request.
    * &amp;lt;p&amp;gt;Also supports media type wildcards (*), for headers such as Accept
    * and Content-Type. For instance,
    * &amp;lt;pre class=&quot;code&quot;&amp;gt;
    * &amp;amp;#064;RequestMapping(value = &quot;/something&quot;, headers = &quot;content-type=text/*&quot;)
    * &amp;lt;/pre&amp;gt;
    * will match requests with a Content-Type of &quot;text/html&quot;, &quot;text/plain&quot;, etc.
    * &amp;lt;p&amp;gt;&amp;lt;b&amp;gt;Supported at the type level as well as at the method level!&amp;lt;/b&amp;gt;
    * When used at the type level, all method-level mappings inherit
    * this header restriction (i.e. the type-level restriction
    * gets checked before the handler method is even resolved).
    * &amp;lt;p&amp;gt;Maps against HttpServletRequest headers in a Servlet environment,
    * and against PortletRequest properties in a Portlet 2.0 environment.
    * @see org.springframework.http.MediaType
    */
   String[] headers() default {};
   /**
    * The consumable media types of the mapped request, narrowing the primary mapping.
    * &amp;lt;p&amp;gt;The format is a single media type or a sequence of media types,
    * with a request only mapped if the {@code Content-Type} matches one of these media types.
    * Examples:
    * &amp;lt;pre class=&quot;code&quot;&amp;gt;
    * consumes = &quot;text/plain&quot;
    * consumes = {&quot;text/plain&quot;, &quot;application/*&quot;}
    * &amp;lt;/pre&amp;gt;
    * Expressions can be negated by using the &quot;!&quot; operator, as in &quot;!text/plain&quot;, which matches
    * all requests with a {@code Content-Type} other than &quot;text/plain&quot;.
    * &amp;lt;p&amp;gt;&amp;lt;b&amp;gt;Supported at the type level as well as at the method level!&amp;lt;/b&amp;gt;
    * When used at the type level, all method-level mappings override
    * this consumes restriction.
    * @see org.springframework.http.MediaType
    * @see javax.servlet.http.HttpServletRequest#getContentType()
    */
   String[] consumes() default {};
   /**
    * The producible media types of the mapped request, narrowing the primary mapping.
    * &amp;lt;p&amp;gt;The format is a single media type or a sequence of media types,
    * with a request only mapped if the {@code Accept} matches one of these media types.
    * Examples:
    * &amp;lt;pre class=&quot;code&quot;&amp;gt;
    * produces = &quot;text/plain&quot;
    * produces = {&quot;text/plain&quot;, &quot;application/*&quot;}
    * produces = &quot;application/json; charset=UTF-8&quot;
    * &amp;lt;/pre&amp;gt;
    * &amp;lt;p&amp;gt;It affects the actual content type written, for example to produce a JSON response
    * with UTF-8 encoding, {@code &quot;application/json; charset=UTF-8&quot;} should be used.
    * &amp;lt;p&amp;gt;Expressions can be negated by using the &quot;!&quot; operator, as in &quot;!text/plain&quot;, which matches
    * all requests with a {@code Accept} other than &quot;text/plain&quot;.
    * &amp;lt;p&amp;gt;&amp;lt;b&amp;gt;Supported at the type level as well as at the method level!&amp;lt;/b&amp;gt;
    * When used at the type level, all method-level mappings override
    * this produces restriction.
    * @see org.springframework.http.MediaType
    */
   String[] produces() default {};
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;和注解RequestMapping组合使用在传参的注解目前包含：PathVariable，RequestHeader，RequestParam。&lt;/p&gt;
&lt;p&gt;PathVariable：url占位符参数绑定&lt;br/&gt;RequestHeader：可以设置业务header&lt;br/&gt;RequestParam：将传参映射到http请求的参数，get/post请求都支持&lt;/p&gt;
&lt;p&gt;关于RequestParam，前面有文章涉及到细节：&lt;a href=&quot;https://www.cnblogs.com/killbug/p/9776287.html&quot;&gt;链接&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;结束&quot;&gt;结束&lt;/h3&gt;
&lt;p&gt;先看一眼将涉及到的注解，通过这些注解，我们可以大致了解到Feign能提供的能力范围和实现机制，而对应这些注解的源码在后续文章中也将一一学习到。&lt;/p&gt;
</description>
<pubDate>Sat, 16 Feb 2019 14:38:00 +0000</pubDate>
<dc:creator>每当变幻时</dc:creator>
<og:description>开始 Feign在Spring Cloud体系中被整合进来作为web service客户端，使用HTTP请求远程服务时能就像调用本地方法，可见在未来一段时间内，大多数Spring Cloud架构的微服</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/killbug/p/10389530.html</dc:identifier>
</item>
<item>
<title>AtCoder Beginner Contest 118 解题报告 - henry_y</title>
<link>http://www.cnblogs.com/henry-1202/p/10389574.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/henry-1202/p/10389574.html</guid>
<description>&lt;h2 id=&quot;a---b---a&quot;&gt;A - B +/- A&lt;/h2&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() {
    int a, b; std::cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b;
    b % a ? std::cout &amp;lt;&amp;lt; b - a : std::cout &amp;lt;&amp;lt; a + b;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;b---foods-loved-by-everyone&quot;&gt;B - Foods Loved by Everyone&lt;/h2&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int cnt[31], ans;
int main() {
    int n, m; std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    for(int i = 1; i &amp;lt;= n; ++i) {
        int k, x; std::cin &amp;gt;&amp;gt; k;
        while(k--) std::cin &amp;gt;&amp;gt; x, ++cnt[x];
    }
    for(int i = 1; i &amp;lt;= m; ++i) if(cnt[i] == n) ++ans;
    std::cout &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; std::endl;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;c---monsters-battle-royale&quot;&gt;C - Monsters Battle Royale&lt;/h2&gt;
&lt;p&gt;答案即为所有数的&lt;span class=&quot;math inline&quot;&gt;\(\gcd\)&lt;/span&gt;。&lt;br/&gt;考虑&lt;span class=&quot;math inline&quot;&gt;\(\gcd(n,n-x)=\gcd(n,x)\)&lt;/span&gt;。&lt;br/&gt;实际上每次减法就是在重复这个过程。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
int main() {
    int n, a, x; std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; a; --n;
    while(n--) std::cin &amp;gt;&amp;gt; x, a = std::__gcd(a, x);
    printf(&quot;%d\n&quot;,a);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;d---match-matching&quot;&gt;D - Match Matching&lt;/h2&gt;
&lt;p&gt;设&lt;span class=&quot;math inline&quot;&gt;\(f[i]\)&lt;/span&gt;表示用了&lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt;根火柴，能拼出的数的个数，输出答案对每个dp值维护一个vector即可。&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ f[i]=max\{f[i-a[j]]+1\} \]&lt;/span&gt;&lt;br/&gt;每次转移都将原数组的vector也转过去，push个a[j]进去即可。&lt;br/&gt;注意排序，按数字大小倒序排序，最后倒序输出出去。&lt;br/&gt;复杂度&lt;span class=&quot;math inline&quot;&gt;\(O(nmlen+mlogm)\)&lt;/span&gt;，因为是dp，所以这个len随机数据下实际不会跑很满，总时间才用了104ms&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
const int N = 10010;
const int s[10] = {0,2,5,5,4,5,6,3,7,6};
struct Node {int id, cnt;} a[20];
int f[N], n, m;
std::vector&amp;lt;int&amp;gt;v[N];
bool operator &amp;lt; (Node a, Node b) { return a.id &amp;gt; b.id; }
int main() {
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    for(int i = 1; i &amp;lt;= m; ++i) std::cin &amp;gt;&amp;gt; a[i].id, a[i].cnt = s[a[i].id];
    std::sort(a + 1, a + m + 1); std::memset(f, -0x3f, sizeof(f)); f[0] = 0;
    for(int i = 1; i &amp;lt;= n; ++i) 
        for(int j = 1; j &amp;lt;= m; ++j) 
            if(i - a[j].cnt &amp;gt;= 0 &amp;amp;&amp;amp; f[i - a[j].cnt] + 1 &amp;gt; f[i]) 
                v[i] = v[i - a[j].cnt], v[i].push_back(a[j].id), f[i] = f[i - a[j].cnt] + 1;
    for(int i = v[n].size() - 1; i &amp;gt;= 0; --i) std::cout &amp;lt;&amp;lt; v[n][i];
}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sat, 16 Feb 2019 14:36:00 +0000</pubDate>
<dc:creator>henry_y</dc:creator>
<og:description>A B +/ A D Match Matching 设$f[i]$表示用了$i$根火柴，能拼出的数的个数，输出答案对每个dp值维护一个vector即可。 $$ f[i]=max\{f[i a[j]]+</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/henry-1202/p/10389574.html</dc:identifier>
</item>
</channel>
</rss>