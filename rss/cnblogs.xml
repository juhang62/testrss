<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Kafka应用实践与生态集成 - 哥不是小萝莉</title>
<link>http://www.cnblogs.com/smartloli/p/10928396.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/smartloli/p/10928396.html</guid>
<description>&lt;p&gt;Apache Kafka发展至今，已经是一个很成熟的消息队列组件了，也是大数据生态圈中不可或缺的一员。Apache Kafka社区非常的活跃，通过社区成员不断的贡献代码和迭代项目，使得Apache Kafka功能越发丰富、性能越发稳定，截止本篇博客Apache Kafka发布了V2.2.0版本。&lt;/p&gt;
&lt;p&gt;那么，今天就来聊一聊Kafka应用实践与生态集成的相关内容。&lt;/p&gt;

&lt;p&gt;项目立项时，会做技术调研，那么如何知道你选择的Kafka技术是否能够满足你？据Confluent公司调研报告可知，Apache Kafka在过去几年中在功能和覆盖范围方面取得了很大成就。它被财富500强中的三分之一用于生产，包括全球十大银行中的七家，十大保险公司中的八家，以及美国十大电信公司中的九家。接下来，为大家介绍Kafka示例来帮助大家了解常见的使用模式。并且希望大家能找到与自己的工作流程有交集的地方，这样大家就可以开始利用Kafka的强大功能了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/666745/201905/666745-20190526191354212-1787770858.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;下面让先来看看Kafka提供的两个核心功能：&lt;/p&gt;
&lt;h2&gt;2.1 消息系统&lt;/h2&gt;
&lt;p&gt;消息系统常见的两种模式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;队列：队列消费者充当了工作组的角色，每条消息记录只传递给一个工作进程，从而有效的划分工作流程；&lt;/li&gt;
&lt;li&gt;发布与订阅：订阅者通常是彼此独立的，每个订阅者都可以获得每条消息的副本。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这两种模式都是有效和实用的，通过队列将工作内容分开，用于容错和扩展；发布与订阅能够允许多租户，来使系统解耦。而Apache Kafka的有点之一在于它将队列、发布与订阅结合到了一个强大的消息系统中。&lt;/p&gt;
&lt;h2&gt;2.2 流处理&lt;/h2&gt;
&lt;p&gt;Apache Kafka拥有强大，可扩展的消息系统，只需要一种简单的方法来处理消息流。而在Kafka中，Stream API提供这一功能，它是一个Java客户端类库，提供比Producer和Consumer更高级别的抽象API。&lt;/p&gt;
&lt;p&gt;这使得它使用起来非常的方便：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;无状态操作，例如过滤和转换流消息；&lt;/li&gt;
&lt;li&gt;有状态操作，例如时间窗口上的连接和聚合。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Stream API处理消息的序列化与反序列化，同时维护有状态操作所需要的状态。&lt;/p&gt;
&lt;h2&gt;2.3 典型的Kafka案例&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;旅游行业&lt;/strong&gt;：例如，在一个旅游网站，酒店和航班的价格是一直在变化的，系统的一些组件（价格告警、分析等）需要了解这些变化。你在Kafka的Topic上发布更改，并且需要通知的每个组件都充当一个消费者。每个消费者应用所组成的节点形成一个消费者组。给消费者组所消费的Topic的发送消息动态记录，这样每个消费者均可获取消息记录，同时每个消费者内能够有效的划分工作内容。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;用户分析&lt;/strong&gt;：页面查看、搜索、用户行为分析等，这些实际上是Kafka在LinkedIn设计的原始初衷。用户点击网站活动内容，每个活动类型均有一个Topic，可以实时的反馈，以便深入了解用户参与度、下载量、页面流量等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;GPS&lt;/strong&gt;：例如，能够实时获取智能手机设备的位置数据，并且希望能够实时处理这些数据来显示车辆路径、行驶距离等。传入数据到Kafka的Topic中，并使用Stream API来进行处理。当需要在特定时间段内提取和处理给定用户的所有位置数据时，使用窗口进行状态处理会有不错的效果。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如何你确定了Kafka技术适合你当前的项目，满足你的业务需求。你可能会很好奇，Kafka的内部存储工作原理是什么呢？接下来，将给大家分析Kafka是如何存储其数据的。&lt;/p&gt;
&lt;h2&gt;3.1 Kafka存储单元是分区&lt;/h2&gt;
&lt;p&gt;Topic中的分区是有序写入的，且不可变的消息序列。分区不能跨多个Broker或者多个磁盘来进行分割。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/666745/201905/666745-20190526194921913-96297082.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;3.2 保留策略来管理Topic中消息&lt;/h2&gt;
&lt;p&gt;在你创建的Topic中，你可以指定保留多少数据或者保留多长时间的数据，然后Kafka会按照顺序来清除这些消息（不管消息是否有被使用）。&lt;/p&gt;
&lt;h2&gt;3.3 分区片段&lt;/h2&gt;
&lt;p&gt;Kafka需要定期查找磁盘上待清除的数据，对于分区消息单个非常长的文件，该操作会很慢并且容易出错。为了解决这个问题，Kafka实行了分区分片策略。当Kafka将消息写入分区时，它会写入到一个片段，如果该片段到达阀值，则会新开一个新的片段来写入。片段以偏移量来命名，片段的偏移量是大于前一个片段的偏移量且小于或者等于当前片段中的偏移量。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/666745/201905/666745-20190526200547087-179262332.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;3.4 片段日志是存储消息的位置&lt;/h2&gt;
&lt;p&gt;每条消息都包含值、偏移量、时间戳、主键（KEY）、消息大小、压缩编解码器、校验、以及消息格式的版本。磁盘上的数据格式与Broker通过网络从Producer端接收的格式完全相同，然后由Consumer去获取数据，这使得Kafka能够通过零拷贝技术有效的传输数据。&lt;/p&gt;
&lt;h2&gt;3.5 片段索引将消息偏移量映射到它们在日志中的位置&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/666745/201905/666745-20190526201725606-1255700576.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;索引文件是内存映射的，偏移量查找时使用二进制搜索来查找小于或等于最近的目标偏移量。索引文件由8个字节组成，4个字节用于存储基本偏移量，另外4个字节来存储位置。&lt;/p&gt;
&lt;h2&gt;3.6 Kafka将压缩的消息包装在一起&lt;/h2&gt;
&lt;p&gt;发送压缩消息的Producer端会将压缩批处理，并将其作为包装消息的有效负载发送。和之前一样，磁盘上的数据与Broker通过网络从Producer端接收并发送给其Consumer的数据完全相同。 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/666745/201905/666745-20190526203114880-714179955.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;3.7 Kafka内部存储工作原理小结&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;Kafka的存储单元是分区；&lt;/li&gt;
&lt;li&gt;分区通过片段来进行分割；&lt;/li&gt;
&lt;li&gt;片段包含两个文件：索引和日志文件；&lt;/li&gt;
&lt;li&gt;索引将每个偏移量映射到它们所在日志中的消息位置，用于查找消息；&lt;/li&gt;
&lt;li&gt;压缩消息批处理作为包装消息的有效负载；&lt;/li&gt;
&lt;li&gt;存储在磁盘上的数据与Broker通过网络从Producer端接收并发给Consumer的数据相同。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Kafka的核心尽管在一段时间内保持相对的稳定，但是Kafka生态圈然后在快速的发展。最初的Kafka，包含Producer和Consumer，很容易理解。现在Kafka处理Producer和Consumer，还有Kafka Connect、Kafka Streams、以及KSQL。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/666745/201905/666745-20190526214743170-546503773.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;4.1 如何正确的选择Kafka API&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Kafka Producer API&lt;/strong&gt;：应用直接生成数据，例如移动设备、PC、其他硬件等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Kafka Connect Source API&lt;/strong&gt;：应用程序桥接在我们无法控制的数据存储介质，例如MongoDB、ElasticSearch、RESTAPI等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Kafka Streams API/KSQL&lt;/strong&gt;：如果希望像SQL一样操作实时流数据，可以通过KSQL来完成；如果需要编写复杂的业务逻辑，可以使用Kafka Streams API来完成。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Kafka Consumer API&lt;/strong&gt;：直接读取流数据，并对其执行实时操作，例如推送商品促销活动、发送邮件、获取游戏行为等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Kafka Connect Sink API&lt;/strong&gt;：读取实时流并将其存储到目标介质中，例如Kafka到S3、Kafka到HDFS、Kafka到HBase等。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;选择不同的API来实现不同的业务需求，例如，如果希望为实现的需求编写大量的自定义代码，Kafka Consumer API和Kafka Connect Sink API完全是可以互换的。总而言之，上述API可以帮助你在实际的业务中以最少的代码量来实现最有效的工作流程。&lt;/p&gt;
&lt;h2&gt;4.2 各个API的优势和局限&lt;/h2&gt;
&lt;h3&gt;4.2.1 Kafka Producer API&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;优势&lt;/strong&gt;： Kafka Producer API使用起来非常的简单，异步发送数据，获取回调结果。非常适合直接发送数据流的应用程序，例如日志、点击流、物联网等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;局限&lt;/strong&gt;：可以扩展和构建Kafka Producer API以便执行更多的操作，但是这需要开发人员编写更多的附加逻辑。例如，试图使用Kafka Producer API在数据库和Kafka之间执行ETL操作时，如何跟踪偏移量（即当Producer端停止后，如何正确恢复你的Producer应用程序）？、如何在若干个Producer之间分配ETL的负载？这种情况，我们使用Kafka Connect Source API会更好一些。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;4.2.2 Kafka Connect Source API&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;优势&lt;/strong&gt;：Kafka Connect Source API是一个构建在Kafka Producer API之上的完整框架。它的构建是为了让开发人员能够获得更好的API，以便为并行处理生成并分配任务。另外，可以使用各种各样的连接器，利用这些连接器来处理大多数数据介质，且无需编写任何代码。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;局限&lt;/strong&gt;：适配的数据源连接器均是专属的，如果你当前的数据源在已有的连接器中不包含，需要自行编写连接器来进行适配。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;4.2.3 Kafka Consumer API&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;优势&lt;/strong&gt;：Kafka Consumer API非常简单，可以使用Consumer Groups，因此可以并行使用Topic。新版本的Kafka（V2.2.0）对于偏移量的管理和提交、Balance、幂等性等无需开发者关心。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;局限&lt;/strong&gt;：在ETL场景中，Kafka Connect Sink更加合适，因为它们会避免针对外部数据源编写复杂的逻辑。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;4.2.4 Kafka Connect Sink API&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;优势&lt;/strong&gt;：与Kafka Connect Source API类似，Kafka Connect Sink API允许利用现有的Kafka连接器的生态系统来执行流式ETL，且无需编写任何代码。Kafka Connect Sink API建立在Kafka Consumer API的基础之上，但是与它有所不同。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;局限&lt;/strong&gt;：如果写入的数据源没有可用的适配器，那么需要自行编写Kafka Connect连接器，并且调试过程会有些复杂。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;4.2.5 Kafka Streams API&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;优势&lt;/strong&gt;：对于流处理场景，Kafka中附带Kafka Streams API，并且能够编写高级DSL（类似于函数式编程或者Spark类型的程序）或偏底层的API（类似于Storm）。Kafka Streams API完全隐藏了Producer和Consumer的复杂性，让开发者更加专注于流处理的逻辑实现上。同时，它还具有连接、聚合、一次性处理等功能。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;局限&lt;/strong&gt;：使用Kafka Streams API会让编码门槛提高，同时也可能让你业务逻辑变得复杂。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;4.2.6 KSQL&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;优势&lt;/strong&gt;：KSQL不是Kafka API的直接组成部分，而是Kafka Streams之上的包装器。这里还是值得一说的，虽然Kafka Streams允许编写一些复杂的Topology，但它还是需要一些实质性的编程知识，尤其是新手来说。KSQL希望通过提供与现有的SQL语义类似来抽象出这种复杂性。对于开发者来说，KSQL是非常具有诱惑力的，它使得流处理器变得轻而易举。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;局限&lt;/strong&gt;：对于复杂的业务场景，对数据进行复杂的转换操作，或一些特定的需求，可能还是需要使用Kafka Streams来完成。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/666745/201905/666745-20190526225021149-1460884720.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;5.1 介绍&lt;/h2&gt;
&lt;p&gt;Kubernetes是Google开源的一个容器编排引擎，它支持自动化部署、大规模可伸缩、应用容器化管理。Kubernetes旨在运行无状态工作负载，这些工作负载通常采用微服务架构形式，轻量级、水平扩展。而Kafka的本质上是一个分布式的存储介质，这意味着你在使用时必需处理状态，它比微服务更重要。尽管Kubernetes支持有状态的工作负载，但还是需要谨慎使用。&lt;/p&gt;
&lt;p&gt;那么，应该在Kubernetes上运行Kafka吗？如何让Kafka和Kubernetes互相补充，以及如何避免可能遇到的“坑”？&lt;/p&gt;
&lt;h2&gt;5.2 基础指标&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;进程&lt;/strong&gt;：Kafka Broker对CPU很友好，TLS的引入可能会产生一些开销。Kafka Client如果使用加密会需要更多的CPU，但是这并不会影响Broker。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;内存&lt;/strong&gt;：Kafka Broker的JVM通常可以设置为4GB-8GB之间，但是由于Kafka大量使用了页面缓存，因此还是需要有足够的系统内存。在Kubernetes中，相应的设置容器资源限制和请求。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;存储&lt;/strong&gt;：容器中的存储是暂时的，重启后数据将会丢失，但是可以对Kafka数据使用空目录卷。因此，需要使用持久化存储，存储必须是非本地的，以便Kubernetes在重启后或重新定位后更加灵活的选择另一个节点。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;网络&lt;/strong&gt;：与大多数分布式系统一样，Kafka性能在很大程度上取决于低网络延迟和高带宽。建议不要把所有的Broker放在同一个节点，因为这样会降低可用性。如果Kubernetes节点出现故障，那么整个Kafka集群都会出现故障。&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;5.3 性能&lt;/h2&gt;
&lt;p&gt;安装Kafka之前，做POC测试是非常重要的。这样做的好处是，在遇到有关性能瓶颈问题时，可以提供帮助。而Kafka附带了两个POC测试工具，它们分别是：kafka-producer-perf-test.sh和kafka-consumer-perf-test.sh。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;监控&lt;/strong&gt;：监控Kafka指标是非常有必要的，能够让我们及时的掌握Kafka、Zookeeper集群的健康状态，例如使用Kafka Eagle来监控和管理Kafka Topic（http://www.kafka-eagle.org/）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;日志&lt;/strong&gt;：日志是一个比较关键的部分，确保Kafka安装中所有的容器都记录到stdout和stderr中，并确保Kubernetes集群日志能集中管理，例如输送到ElasticSearch。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;动态更新&lt;/strong&gt;：StatefulSets支持自动更新，RollingUpdate策略将一次更新一个Kafka Pod，来实现零停机维护，这也是Kubernetes的优势之一。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;扩容&lt;/strong&gt;：Kubernetes可以很容易的将Pod缩放到一定数量的副本，这意味着可以声明性的定义所需数量的Kafka Broker。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;备份&amp;amp;还原&lt;/strong&gt;：Kafka部署在Kubernetes中，这样Kafka的可用性就取决于Kubernetes的可用性，如果Kubernetes集群出现故障，那么Kafka的可用性就会下降，同时，也会出现数据丢失的风险，因此需要做好数据备份策略，例如MirrorMaker，或是S3进行连接备份。&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;5.4 对于Kubernetes的选择&lt;/h2&gt;
&lt;p&gt;对于中小型的Kafka集群，将Kafka部署到Kubernetes是一个不错的选择，因为它提供了更大的灵活性、且简化了操作。如果在延迟或吞吐量方面有较高的功能性要求，独立部署的方式可能会更好。&lt;/p&gt;

&lt;p&gt;本篇博客，介绍了Kafka应用实践与生态集成，通过阅读本篇博客的内容，大家可以参考本篇博客的内容，来做出合理、有效的选择。&lt;/p&gt;

&lt;p&gt;这篇博客就和大家分享到这里，如果大家在研究学习的过程当中有什么问题，可以加群进行讨论或发送邮件给我，我会尽我所能为您解答，与君共勉！&lt;/p&gt;
&lt;p&gt;另外，博主出书了《&lt;a href=&quot;https://item.jd.com/12455361.html&quot; target=&quot;_blank&quot;&gt;Kafka并不难学&lt;/a&gt;》和《&lt;a href=&quot;https://item.jd.com/12371763.html&quot; target=&quot;_blank&quot;&gt;Hadoop大数据挖掘从入门到进阶实战&lt;/a&gt;》，喜欢的朋友或同学， 可以在公告栏那里点击购买链接购买博主的书进行学习，在此感谢大家的支持。关注下面公众号，根据提示，可免费获取书籍的教学视频。&lt;/p&gt;
</description>
<pubDate>Sun, 26 May 2019 15:48:00 +0000</pubDate>
<dc:creator>哥不是小萝莉</dc:creator>
<og:description>1.前言 Apache Kafka发展至今，已经是一个很成熟的消息队列组件了，也是大数据生态圈中不可或缺的一员。Apache Kafka社区非常的活跃，通过社区成员不断的贡献代码和迭代项目，使得Apa</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/smartloli/p/10928396.html</dc:identifier>
</item>
<item>
<title>Linux之旅第一篇-目录结构及操作目录 - 茶底世界</title>
<link>http://www.cnblogs.com/yuanqinnan/p/10928374.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuanqinnan/p/10928374.html</guid>
<description>&lt;h2&gt;一、引言&lt;/h2&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;Linux对java开发来说也是一项必备的技能，因为项目基本都是部署在Linux操作系统的服务器中，虽然项目不一定需要我们去部署，但不管是自己测试环境部署，还是一些生产环境中日志的查看，Linux操作系统都是免不了要去接触的。对于我们开发来说懂得基础的命令及简单shell脚本编写是必须的。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;跳过Linux介绍和安装，我们直接从基础命令开始。&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;二、&lt;/span&gt;&lt;span class=&quot;md-expand&quot;&gt;Linux目录&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;md-expand&quot;&gt;在Linux世界中，一切皆是文件，Linux文件采用级层式的树状目录结构，在此结构中根目录是“/”,我们可以看看根目录下面有哪些目录，使用&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
cd &lt;span&gt;/&lt;/span&gt; &lt;span&gt;--&lt;/span&gt;&lt;span&gt;进入根目录&lt;/span&gt;
ll   &lt;span&gt;--&lt;/span&gt;&lt;span&gt;查看目录接口&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这些命令我们后面再学习，结果如图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201905/1113901-20190526232645064-2114521446.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;结构整理如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201905/1113901-20190526232721354-1334256224.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;目录结构作用&lt;/span&gt;&lt;/p&gt;
&lt;table class=&quot;md-table&quot;&gt;&lt;thead&gt;&lt;tr class=&quot;md-end-block&quot;&gt;&lt;th&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;目录&lt;/span&gt;&lt;/span&gt;&lt;/th&gt;
&lt;th&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;说明&lt;/span&gt;&lt;/span&gt;&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;12&quot;&gt;&lt;tr class=&quot;md-end-block&quot; readability=&quot;4&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;bin&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;存放二进制可执行文件(ls,cat,mkdir等)&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;md-end-block&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;boot&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;存放用于系统引导时使用的各种文件&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;md-end-block&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;dev&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;用于存放设备文件&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;md-end-block&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;etc&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;存放系统配置文件&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;md-end-block&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;home&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;存放所有用户文件的根目录&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;md-end-block&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;lib&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;存放跟文件系统中的程序运行所需要的共享库及内核模块&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;md-end-block&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;mnt&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;系统管理员安装临时文件系统的安装点&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;md-end-block&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;opt&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;额外安装的可选应用程序包所放置的位置&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;md-end-block&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;proc&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;虚拟文件系统，存放当前内存的映射&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;md-end-block&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;root&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;超级用户目录&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;md-end-block&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;sbin&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;存放二进制可执行文件，只有root才能访问&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;md-end-block&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;tmp&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;用于存放各种临时文件&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;md-end-block&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;usr&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;用于存放系统应用程序，比较重要的目录/usr/local 本地管理员软件安装目录&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;md-end-block md-focus-container&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span class=&quot;td-span&quot;&gt;&lt;span&gt;var&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;td-span md-focus&quot;&gt;&lt;span&gt;用于存放运行时需要改变数据的文件&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;我们需要关注的几个目录&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot;ol-list&quot; start=&quot;&quot; readability=&quot;1.5&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;home: 存放我们用户文件的目录。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;etc ：存放配置文件的目录，当我们需要修改配置文件的时候就需要进入该目录。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;usr/local :安装自己的程序，必须放在该目录中&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;var:存在数据的目录&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2&gt;三、&lt;span class=&quot;md-expand&quot;&gt;操作文件目录&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;md-expand&quot;&gt;了解完了大体的目录结构，下面就开始一些操作文件目录的操作，其实就要记住和熟悉命令的过程，每个命令都去敲敲，无非是一个熟能生巧的过程。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span class=&quot;md-expand&quot;&gt;3.1 &lt;/span&gt;&lt;span class=&quot;md-expand&quot;&gt;ls&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;ls 显示文件和目录列表，另外还有两个可选参数：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;ls命令&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201905/1113901-20190526232930057-1910735378.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我们切换至home 目录&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201905/1113901-20190526232951420-503019287.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;ls -a&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201905/1113901-20190526233014039-447944227.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在linux中以.开头的是隐藏文件&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;3.2 mkdir&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt; mkdir 创建目录命令，一个可选参数-p:父目录不存在情况下先生成父目录&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201905/1113901-20190526233151815-1471670806.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在我们直接增加父目录时，不存在父目录就会出错&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201905/1113901-20190526233217470-1679501845.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;正确的做法：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201905/1113901-20190526233236192-2094264085.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;3.3 cd&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt; cd 是切换目录，这个命令很简单，后面加上切换的目录地址即可&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;3.4 touch&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;md-expand&quot;&gt;touch 生成一个空文件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-expand&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201905/1113901-20190526233346342-1329425540.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span class=&quot;md-expand&quot;&gt;3.5 echo&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt; echo 生成一个带内容文件&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;格式： echo hello world &amp;gt;1.txt 创建文件并写入（一个尖括号）&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;echo linux &amp;gt;&amp;gt;1.txt 追加文本内容 （两个尖括号）&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;3.6 cat&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;md-expand&quot;&gt;echo 显示文本文件内，我们来显示刚刚创建的文件内容&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-expand&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201905/1113901-20190526233455103-1511793022.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;3.7 cp&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;cp 复制文件或目录&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;格式：cp 原始文件 复制到的目录位置&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201905/1113901-20190526233530776-1993880228.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;3.8 rm&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;rm 是删除文件，有两个可选参数，&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;当我们删除的文件是一个目录是，就必须强制的删除文件，并且删除目录下的所有文件&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201905/1113901-20190526233615538-269770462.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-meta md-before&quot;&gt;&lt;strong&gt;&lt;span&gt;所以从删库到跑路的命令就是：rm -fr /*&lt;/span&gt;&lt;/strong&gt;&lt;span class=&quot;md-meta md-after&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;3.9 mv&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;md-expand&quot;&gt;mv 移动文件或目录,相当于剪切命令&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-expand&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201905/1113901-20190526233705138-1495857985.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;3.10 find&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt; find 在文件系统中查找指定的文件，有一个可选参数- name 即为文件的名称，如果不加在这个参数，直接查询文件是查询不到的，只会查找目录&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201905/1113901-20190526233740033-172933237.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;3.11 grep&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;md-expand&quot;&gt;grep 在指定的文本文件中查找指定的字符串&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-expand&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201905/1113901-20190526233819517-1962391108.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span&gt;3.12 tree&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;tree 用于以树状图列出目录的内容，默认的版本应该是没有这个命令，需要后面自主下载&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;3.13 pwd&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;pwd 显示当前工作目录，这个无需讲了&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;3.14 more&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;more 分页显示文本文件内容,当文件内容过长时，我们可以使用此命令，然后按住enter键往下浏览&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;3.15 head&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;head 显示文件开头内容&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201905/1113901-20190526233918446-1816763010.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span&gt;3.16 tail&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;tail 显示文件结尾内容，有一个可选参数，-f 跟踪输出，什么意思呢？当我们执行这个命令是，执行过后并不会立即结束，而是卡住状态，当文件被修改时，会自动的输出修改的内容&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 26 May 2019 15:45:00 +0000</pubDate>
<dc:creator>茶底世界</dc:creator>
<og:description>一、引言 Linux对java开发来说也是一项必备的技能，因为项目基本都是部署在Linux操作系统的服务器中，虽然项目不一定需要我们去部署，但不管是自己测试环境部署，还是一些生产环境中日志的查看，Li</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yuanqinnan/p/10928374.html</dc:identifier>
</item>
<item>
<title>netframework中等待多个子线程执行完毕并计算执行时间 - 紫云秀</title>
<link>http://www.cnblogs.com/ziyunxiu/p/10928331.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ziyunxiu/p/10928331.html</guid>
<description>&lt;p&gt;本文主要描述在.netframework中(实验环境.netframework版本为4.6.1)提供两种方式等待多个子线程执行完毕。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;ManualResetEvent&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;             在多线程中，将ManualResetEvent实例作为方法传入，线程执行完毕后可以设置标志位来标识当前线程已经执行完毕。代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('e782fd5b-6fd5-4037-ad13-b6f2b788e5ba')&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_e782fd5b-6fd5-4037-ad13-b6f2b788e5ba&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_e782fd5b-6fd5-4037-ad13-b6f2b788e5ba&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('e782fd5b-6fd5-4037-ad13-b6f2b788e5ba',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_e782fd5b-6fd5-4037-ad13-b6f2b788e5ba&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;  List&amp;lt;ManualResetEvent&amp;gt; manualResetEvents = &lt;span&gt;new&lt;/span&gt; List&amp;lt;ManualResetEvent&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; ManualResetEvent标志多线程是否执行完毕
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;sender&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;e&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; btn_ManualResetEvent_Click(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, EventArgs e)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; SetBtnEnabled(false);&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;             Stopwatch watch = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Stopwatch();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;            watch.Start();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; threadCount; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                 ManualResetEvent manualReset = &lt;span&gt;new&lt;/span&gt; ManualResetEvent(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;                manualResetEvents.Add(manualReset);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;                ThreadPool.QueueUserWorkItem(ManualResetEventMethod, manualReset);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;等待所有线程执行完毕&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;            WaitHandle.WaitAll(manualResetEvents.ToArray());
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;暂停watch，获取多线程执行时间&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;            watch.Stop();
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             &lt;span&gt;long&lt;/span&gt; time =&lt;span&gt; watch.ElapsedMilliseconds;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             lab_time.Text =&lt;span&gt; time.ToString();
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt;            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; SetBtnEnabled(true);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;释放句柄&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt; &lt;span&gt;            manualResetEvents.Clear();
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; ManualResetEventMethod(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; obj)
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;             Thread.Sleep(&lt;span&gt;1000&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;             ManualResetEvent mre =&lt;span&gt; (ManualResetEvent)obj;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;            mre.Set();
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;      注意：&lt;/p&gt;
&lt;p&gt;     在WaitHandle.WaitAll方法中，等待的句柄不能超过64，所以每次用完后，需要手动调用Clear方法进行释放。&lt;/p&gt;
&lt;p&gt;     如果等待的线程超过64个，可以参考博客：https://www.cnblogs.com/xiaofengfeng/archive/2012/12/27/2836183.html，在该博客中，通过对ManualResetEvent的封装，能够使等待的句柄超过64（测试环境下一次起1000个线程，没有问题）&lt;/p&gt;
&lt;p&gt;         在主线程中通过Monitor.Wait(locker)达到阻塞的目的，子线程执行完毕通过 Monitor.Pulse(locker)通知主线程，直到所有子线程执行完成，主线程再继续执行，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('a2fbd9dc-ed66-4622-ab89-b2d386410874')&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_a2fbd9dc-ed66-4622-ab89-b2d386410874&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_a2fbd9dc-ed66-4622-ab89-b2d386410874&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('a2fbd9dc-ed66-4622-ab89-b2d386410874',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_a2fbd9dc-ed66-4622-ab89-b2d386410874&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;         &lt;span&gt;object&lt;/span&gt; locker = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; threadCount = &lt;span&gt;1000&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; finshCount = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Monitor线程之间同步标记多线程执行完毕
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;sender&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;e&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; btn_Monitor_Click(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, EventArgs e)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             finshCount = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             SetBtnEnabled(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             Stopwatch watch = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Stopwatch();
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;            watch.Start();
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; threadCount; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                 Thread trd = &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ParameterizedThreadStart(MonitorMethod));
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;                trd.Start(i);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;lock&lt;/span&gt;&lt;span&gt; (locker)
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                 &lt;span&gt;while&lt;/span&gt; (finshCount !=&lt;span&gt; threadCount)
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                     Monitor.Wait(locker);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;等待&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;所有线程执行完毕，获取执行时间&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt; &lt;span&gt;            watch.Stop();
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;             &lt;span&gt;long&lt;/span&gt; time =&lt;span&gt; watch.ElapsedMilliseconds;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;             lab_time.Text =&lt;span&gt; time.ToString();
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt;             SetBtnEnabled(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; 
&lt;span&gt;35&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; MonitorMethod(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; obj)
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;             Thread.Sleep(&lt;span&gt;1000&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;             &lt;span&gt;lock&lt;/span&gt;&lt;span&gt; (locker)
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;                 finshCount++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;                 Monitor.Pulse(locker); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;完成，通知等待队列,告知已完，执行下一个。&lt;/span&gt;
&lt;span&gt;42&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;       在一次开启10、1000个线程两种环境下，分别测试以上两种方式，ManualResetEvent在多次执行时，前几次耗时会比较大，后续耗时会减少并且稳定下来，接近 Monitor的速度。相对而言，Monitor的效率更高。&lt;/p&gt;

&lt;p&gt;   如果了解过go语言，会发现通过sync包下的WaitGroup也可以达到同样的目的，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:go;collapse:true;;gutter:true;&quot;&gt;
package main

import (
        &quot;fmt&quot;
        &quot;sync&quot;
        &quot;time&quot;
)

var wg sync.WaitGroup
var count = 1000

func main() {

        startTime := time.Now().Unix()
        wg.Add(count)
        for i := 0; i &amp;lt; count; i++ {
                go func() {
                        defer wg.Done()
                        time.Sleep(time.Second)
                }()
        }
        fmt.Println(&quot;waiting for all goroutine&quot;)
        wg.Wait()

        endTime := time.Now().Unix()

        fmt.Printf(&quot;all goroutine is done! time:%v s&quot;, (endTime-startTime))

}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　相较而言，go语言的协程效率最高&lt;/p&gt;

</description>
<pubDate>Sun, 26 May 2019 15:28:00 +0000</pubDate>
<dc:creator>紫云秀</dc:creator>
<og:description>本文主要描述在.netframework中(实验环境.netframework版本为4.6.1)提供两种方式等待多个子线程执行完毕。 ManualResetEvent 在多线程中，将ManualRes</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ziyunxiu/p/10928331.html</dc:identifier>
</item>
<item>
<title>F#周报2019年第21期 - Ken.W</title>
<link>http://www.cnblogs.com/kenwoo/p/10928295.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kenwoo/p/10928295.html</guid>
<description>[unable to retrieve full-text content]新闻 &quot;F 在GitHub上的开发仓库现在变为dotnet/fsharp&quot; &quot;Ionide 4.0路线图&quot; &quot;Fable的五月公告&quot; &quot;Visual Studio 2019版本16.1&quot; &quot;WinUI 3.0路线图&quot; &quot;欢迎来到Shell时代：Xamarin.Forms 4.0发布&quot; 视频及幻灯片 </description>
<pubDate>Sun, 26 May 2019 15:21:00 +0000</pubDate>
<dc:creator>Ken.W</dc:creator>
<og:description>新闻 'F 在GitHub上的开发仓库现在变为dotnet/fsharp' 'Ionide 4.0路线图' 'Fable的五月公告' 'Visual Studio 2019版本16.1' 'WinUI</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/kenwoo/p/10928295.html</dc:identifier>
</item>
<item>
<title>SpringBoot+Mybatis增删改查实战 - 林静生寒</title>
<link>http://www.cnblogs.com/ljsh/p/10928106.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ljsh/p/10928106.html</guid>
<description>&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;SpringBoot和Mybatis是啥请自行百度，作者这里也是花了几天时间入门了这个框架用来完成任务，并且也算符合要求的完成了任务，期间也各种百度但是没找到自己想要的那种简单易懂的教程，所以踩了很多坑，写这个博客的目的就是为了让大家少踩一点坑，开始。&lt;/p&gt;
&lt;h2 id=&quot;创建一个springboot项目&quot;&gt;创建一个SpringBoot项目&lt;/h2&gt;
&lt;h3 id=&quot;httpsstart.spring.io&quot;&gt;&lt;a href=&quot;https://start.spring.io/&quot; class=&quot;uri&quot;&gt;https://start.spring.io/&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;点开这个网站，创建一个Springboot项目，如下图，这里用的是2.1.5，学技术嘛，就是要学新的。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1425720/201905/1425720-20190526223350588-806991173.png&quot;/&gt;&lt;br/&gt;选择依赖，点击左下角的Dependencies&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Web&lt;/code&gt; 我们这次开发的是web应用所以选择web&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Thymeleaf&lt;/code&gt; 一款模板引擎，能够比较方便的展现后台传来的数据&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MySQL&lt;/code&gt; 我们这次使用Mysql数据库&lt;/li&gt;
&lt;li&gt;&lt;code&gt;JDBC&lt;/code&gt; Java 数据库连接 Java Database Connectivity,简称JDBC&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MyBatis&lt;/code&gt; 请看第一段&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1425720/201905/1425720-20190526223404310-107768824.png&quot;/&gt;&lt;br/&gt;最后点击左下角的Generate Project，将会开始下载一个以你项目名称开头的zip文件，下载完成后解压到你的工作目录。&lt;/p&gt;
&lt;h3 id=&quot;打开这个项目&quot;&gt;打开这个项目&lt;/h3&gt;
&lt;p&gt;这里使用的是IDEA，别的啥也行比如eclipse，这里只讲解IDEA的操作，安装破解IDEA百度一大堆，安装好之后打开IDEA（发现IDEA有个问题，有的时候自动import包好用，有的时候不好用，坑！），然后选择左上角的File-&amp;gt;Open，找到你刚刚解压的项目文件里的pom.xml点击ok如下图&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1425720/201905/1425720-20190526223451702-1206712524.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;目录结构&quot;&gt;目录结构&lt;/h3&gt;
&lt;p&gt;增加修改目录结构为下图&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1425720/201905/1425720-20190526223501448-1867389567.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;开始编写&quot;&gt;开始编写&lt;/h2&gt;
&lt;p&gt;这里我们就编写一个人员信息的增删改查&lt;/p&gt;
&lt;h3 id=&quot;配置数据库&quot;&gt;配置数据库&lt;/h3&gt;
&lt;h4 id=&quot;数据库创建&quot;&gt;数据库创建&lt;/h4&gt;
&lt;p&gt;打开mysql数据库创建一个叫test的数据库之后创建person表，这里使用的是Navicat百度有破解版，会命令用命令行也行，如下图，记得设置主键自增，然后随便加几个数据以便之后查询。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1425720/201905/1425720-20190526223513803-1820680642.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;application.yml&quot;&gt;application.yml&lt;/h4&gt;
&lt;p&gt;路径：/resources/application.yml&lt;/p&gt;
&lt;pre class=&quot;yml&quot;&gt;
&lt;code&gt;server:
  port: 8080

spring:
  datasource:
    name:
    url: jdbc:mysql://127.0.0.1:3306/test?useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;allowMultiQueries=true&amp;amp;serverTimezone=UTC
    username: root
    password: root

mybatis:
  mapper-locations: classpath:mapper/*.xml&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;person类&quot;&gt;Person类&lt;/h3&gt;
&lt;p&gt;路径/model/Person.java&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.ljsh.test.model;

public class Person {
    /*
    {id} 自增主键
    {name} 人员姓名
    {mobile} 人员电话
     */
    private int id;
    private String name;
    private String mobile;
    
    // 右键 Generate -&amp;gt; Setter and Getter -&amp;gt; Shift全选 -&amp;gt; ok 生成如下代码

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getMobile() {
        return mobile;
    }

    public void setMobile(String mobile) {
        this.mobile = mobile;
    }
    
    // 右键 Generate -&amp;gt; toString() -&amp;gt; 全选 -&amp;gt; ok 生成如下代码

    @Override
    public String toString() {
        return &quot;Person{&quot; +
                &quot;id=&quot; + id +
                &quot;, name='&quot; + name + '\'' +
                &quot;, mobile='&quot; + mobile + '\'' +
                '}';
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;persondao&quot;&gt;PersonDao&lt;/h3&gt;
&lt;p&gt;路径：/dao/PersonDao.java&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.ljsh.test.dao;

import com.ljsh.test.model.Person;
import org.apache.ibatis.annotations.Mapper;
import java.util.List;

@Mapper
public interface PersonDao {
    /*
    查所有
    return List&amp;lt;Person&amp;gt;
     */
    List&amp;lt;Person&amp;gt; getAll();

    /*
    根据ID查询
    {id} 要查询人员的 id
     */
    Person getPersonByID(int id);
    
    /*
    删除
    {id} 要删除人员的 id
     */
    void delete(int id);

    /*
    更新
    {p} 要更新的Person实例
     */
    void update(Person p);

    /*
    增加
    {p} 要新增的Person实例
     */
    void newp(Person p);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;persondao.xml&quot;&gt;PersonDao.xml&lt;/h3&gt;
&lt;p&gt;路径：/mapper/PersonDao.xml&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&amp;gt;
&amp;lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &amp;gt;
&amp;lt;!-- 这里填写对应的Dao文件所在的路径 --&amp;gt;
&amp;lt;mapper namespace=&quot;com.ljsh.test.dao.PersonDao&quot;    &amp;gt;
    &amp;lt;!-- 填写数据库里实例Person对应的表的表名 --&amp;gt;
    &amp;lt;!-- 这里是作为一个变量使用 --&amp;gt;
    &amp;lt;sql id=&quot;table&quot;&amp;gt;person&amp;lt;/sql&amp;gt;

    &amp;lt;!-- id属性填写Dao文件里的函数名称 xxType是参数或是结果的类型根据情况填写 --&amp;gt;
    &amp;lt;!-- 查询所有   --&amp;gt;
    &amp;lt;select id=&quot;getAll&quot; resultType=&quot;com.ljsh.test.model.Person&quot;&amp;gt;
        SELECT
        *
        FROM
        &amp;lt;include refid=&quot;table&quot; /&amp;gt;
    &amp;lt;/select&amp;gt;


    &amp;lt;!-- 根据id查询 --&amp;gt;
    &amp;lt;select id=&quot;getPersonById&quot; resultType=&quot;com.ljsh.test.model.Person&quot;&amp;gt;
        SELECT
        *
        FROM
        &amp;lt;include refid=&quot;table&quot;/&amp;gt;
        WHERE
        id = #{id}
    &amp;lt;/select&amp;gt;

    &amp;lt;!-- 增 --&amp;gt;
    &amp;lt;insert id=&quot;newp&quot; parameterType=&quot;com.ljsh.test.model.Person&quot;&amp;gt;
        INSERT INTO
        &amp;lt;include refid=&quot;table&quot;/&amp;gt;
        (name,phone)
        VALUES
        (#{name},#{phone})
    &amp;lt;/insert&amp;gt;

    &amp;lt;!-- 改 --&amp;gt;
    &amp;lt;update id=&quot;update&quot; parameterType=&quot;com.ljsh.test.model.Person&quot;&amp;gt;
        UPDATE
        &amp;lt;include refid=&quot;table&quot;/&amp;gt;
        SET
        &amp;lt;!--&amp;lt;if test=&quot;name != null&quot;&amp;gt;name = #{name}&amp;lt;/if&amp;gt;--&amp;gt;
        name  = #{name},phone = #{phone},status = #{status}
        WHERE
        id = #{id}
    &amp;lt;/update&amp;gt;

    &amp;lt;!-- 删 --&amp;gt;
    &amp;lt;delete id=&quot;delete&quot; parameterType=&quot;com.ljsh.test.model.Person&quot;&amp;gt;
        DELETE FROM
        &amp;lt;include refid=&quot;table&quot;/&amp;gt;
        WHERE
        id = #{id}
    &amp;lt;/delete&amp;gt;
&amp;lt;/mapper&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;personservice&quot;&gt;PersonService&lt;/h3&gt;
&lt;p&gt;路径：/service/PersonService.java&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.ljsh.test.service;
import com.ljsh.test.dao.PersonDao;
import com.ljsh.test.model.Person;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import java.util.List;

@Service
public class PersonService {
    @Autowired
    PersonDao personDao;

    /*
        Service层介于controller和dao之间作为服务层进行一些逻辑处理，
        这里逻辑太简单所以知识单纯调用dao所以不做注释
     */
    public List&amp;lt;Person&amp;gt; getAll(){
        return personDao.getAll();
    }

    public Person getPersonByID(int id){
        return personDao.getPersonByID(id);
    }

    public void  delete(int id){
        personDao.delete(id);
    }

    public void update(Person p){
        personDao.update(p);
    }

    public void newp(Person p){
        personDao.newp(p);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;personcontroller&quot;&gt;PersonController&lt;/h3&gt;
&lt;p&gt;路径：/controller/PersonController.java&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.ljsh.test.controller;

import com.ljsh.test.model.Person;
import com.ljsh.test.service.PersonService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.servlet.ModelAndView;
import java.util.List;

@Controller
public class PersonController {

    @Autowired
    PersonService personService;

    // 设置访问路由值为路径
    @RequestMapping(&quot;/&quot;)
    public ModelAndView index(){
        // 顾名思义 实体和数据 同时返回页面模板和数据
        ModelAndView mav = new ModelAndView(&quot;index&quot;);
        List&amp;lt;Person&amp;gt; list = personService.getAll();
        mav.addObject(&quot;list&quot;,list);
        return mav;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;前端页面&quot;&gt;前端页面&lt;/h3&gt;
&lt;p&gt;路径：/templates/index.html&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;!-- --&amp;gt;
&amp;lt;!-- 使用thymeleaf需引入 --&amp;gt;
&amp;lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;div  id=&quot;tableP&quot;&amp;gt;
        &amp;lt;table&amp;gt;
            &amp;lt;caption&amp;gt;人员信息&amp;lt;/caption&amp;gt;
            &amp;lt;tr&amp;gt;
                &amp;lt;th&amp;gt;Name&amp;lt;/th&amp;gt;
                &amp;lt;th&amp;gt;Phone&amp;lt;/th&amp;gt;
            &amp;lt;/tr&amp;gt;
            &amp;lt;!-- 通过th命令使用一些操作 --&amp;gt;
            &amp;lt;!-- 通过${} 使用变量 --&amp;gt;
            &amp;lt;tr  th:each=&quot;item: ${list}&quot;&amp;gt;
                &amp;lt;td th:text=&quot;${{item.name}}&quot;&amp;gt;还没有任何人员信息哦&amp;lt;/td&amp;gt;
                &amp;lt;td th:text=&quot;${{item.mobile}}&quot;&amp;gt;你是不是想独吞奖品&amp;lt;/td&amp;gt;
            &amp;lt;/tr&amp;gt;
        &amp;lt;/table&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;右上角运行&quot;&gt;右上角运行&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1425720/201905/1425720-20190526223536192-1917348177.png&quot;/&gt;&lt;br/&gt;要是没有这个可以右侧选择TestApplication右键Run，结果图如下&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1425720/201905/1425720-20190526224319152-188703909.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;未完待续&quot;&gt;未完待续&lt;/h2&gt;
&lt;p&gt;熄灯睡觉了，写的有点慢，删改查还没来及写，如果需求留言，我会继续更新。&lt;/p&gt;
</description>
<pubDate>Sun, 26 May 2019 14:36:00 +0000</pubDate>
<dc:creator>林静生寒</dc:creator>
<og:description>简介 SpringBoot和Mybatis是啥请自行百度，作者这里也是花了几天时间入门了这个框架用来完成任务，并且也算符合要求的完成了任务，期间也各种百度但是没找到自己想要的那种简单易懂的教程，所以踩</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ljsh/p/10928106.html</dc:identifier>
</item>
<item>
<title>设计模式之代理模式（一） - justBobo</title>
<link>http://www.cnblogs.com/justBobo/p/10927408.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/justBobo/p/10927408.html</guid>
<description>&lt;p&gt;定义：为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。&lt;/p&gt;
&lt;p&gt;组成：&lt;/p&gt;
&lt;p&gt;抽象角色:（主题）通过接口或抽象类声明真实角色实现的业务方法。&lt;/p&gt;
&lt;p&gt;代理角色：实现抽象角色，是真实角色的代理，通过真实角色的业务逻辑方法来实现抽象方法，并可以附加自己的操作。&lt;/p&gt;
&lt;p&gt;真实角色：实现抽象角色，定义真实角色所要实现的业务逻辑，供代理角色调用。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;意图&lt;/strong&gt;：为其他对象提供一种代理以控制对这个对象的访问。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主要解决&lt;/strong&gt;：在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;应用实例：&lt;/strong&gt;1、Windows 里面的快捷方式。2、买火车票不一定在火车站买，也可以去代售点。 3、spring aop。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt; 1、职责清晰。&lt;/p&gt;
&lt;p&gt;　　　　被代理对象只负责自己实际的业务逻辑，不关心其他非本身的职责。并将其他事务可以通过代理类处理。&lt;/p&gt;
&lt;p&gt;　　     2、高扩展性。&lt;/p&gt;
&lt;p&gt;　　　　无论被代理对象如何改变，只要代理类和被代理类都实现了统一接口，都不同修改代理类，而且即使扩展了新的被代理类，代理类也可以使用，只要创建代理类的时候传入对应的被代理类对象。&lt;/p&gt;

&lt;p&gt;　　　 3、智能化。&lt;/p&gt;
&lt;p&gt;　　　　这主要体现在动态代理中，下面会讲解动态代理。如果有兴趣了解Spring的AOP，其实就是使用了动态代理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt; 1、由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。&lt;/p&gt;
&lt;p&gt;　　     2、实现代理模式需要额外的工作，有些代理模式的实现非常复杂。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意事项：&lt;/strong&gt; 1、和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。&lt;/p&gt;
&lt;p&gt;　　　　     2、和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。&lt;/p&gt;

&lt;p&gt;　　我们举个示例，比如在娱乐圈，客户与艺人进行商业合作，一般都不是与艺人直接联系，签订时间、地点、薪酬等合同，而是&lt;/p&gt;
&lt;p&gt;找艺人的经纪人商讨，那么这里商艺活动就是抽象对象（主题），艺人就被代理对象，经纪人就是代理对象。&lt;/p&gt;
&lt;p&gt;代码示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('208f986e-d21d-4cd1-9c7c-bb45c68addc0')&quot; readability=&quot;35.5&quot;&gt;&lt;img id=&quot;code_img_closed_208f986e-d21d-4cd1-9c7c-bb45c68addc0&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_208f986e-d21d-4cd1-9c7c-bb45c68addc0&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('208f986e-d21d-4cd1-9c7c-bb45c68addc0',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_208f986e-d21d-4cd1-9c7c-bb45c68addc0&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.pattern.proxy;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 *  抽象接口 演艺
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Performance {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Sing(String name , String address, String date);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;谁在哪个时间哪个地点唱歌&lt;/span&gt;

    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; dance(String name , String address, String date); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;谁在哪个时间哪个地点跳舞&lt;/span&gt;

    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; perform(String name , String address, String date);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;谁在哪个时间哪个地点表演&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;抽象对象（主题）&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('f17c3dad-defe-47d8-8fb1-77e4db7eda63')&quot; readability=&quot;35.5&quot;&gt;&lt;img id=&quot;code_img_closed_f17c3dad-defe-47d8-8fb1-77e4db7eda63&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_f17c3dad-defe-47d8-8fb1-77e4db7eda63&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('f17c3dad-defe-47d8-8fb1-77e4db7eda63',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_f17c3dad-defe-47d8-8fb1-77e4db7eda63&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.pattern.proxy;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 *  被代理对象 艺人
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Artist &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Performance{

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Agent agent;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取指定代理人对象

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取指定的代理人对象&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Performance getAgent(){
        agent &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Agent(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; agent;
    }


    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Sing(String name, String address, String date) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (agent == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            System.out.println(&lt;/span&gt;&quot;请使用指定的代理类&quot;&lt;span&gt;);
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        System.out.println(date&lt;/span&gt;+&quot;    &quot;+name  +&quot;在&quot;+address +&quot;rap了一首xX&quot;&lt;span&gt;);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; dance(String name, String address, String date) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (agent == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            System.out.println(&lt;/span&gt;&quot;请使用指定的代理类&quot;&lt;span&gt;);
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            System.out.println( date&lt;/span&gt;+&quot;    &quot;+name  +&quot;在&quot;+address +&quot;跳了一个芭蕾&quot;&lt;span&gt;);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; perform(String name, String address, String date) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (agent == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            System.out.println(&lt;/span&gt;&quot;请使用指定的代理类&quot;&lt;span&gt;);
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            System.out.println(date&lt;/span&gt;+&quot;    &quot;+name  +&quot;在&quot;+address +&quot;表演了打篮球&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;被代理对象&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('d63f3aa0-93ff-4032-975a-2a4166f66654')&quot; readability=&quot;38.5&quot;&gt;&lt;img id=&quot;code_img_closed_d63f3aa0-93ff-4032-975a-2a4166f66654&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_d63f3aa0-93ff-4032-975a-2a4166f66654&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('d63f3aa0-93ff-4032-975a-2a4166f66654',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_d63f3aa0-93ff-4032-975a-2a4166f66654&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;72&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.pattern.proxy;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 代理对象 经纪人
 * Created by wanbf on 2019/5/26.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Agent  &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Performance{

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;保存被代理人的实例&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Performance performance;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Agent(Performance performance){

        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.performance =&lt;span&gt; performance;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Sing(String name, String address, String date) {
        performance.Sing(name,address,date);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里经纪人是不会唱歌的，执行艺人的唱歌 下同&lt;/span&gt;
&lt;span&gt;    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; dance(String name, String address, String date) {
        performance.dance(name,address,date);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; perform(String name, String address, String date) {
        performance.perform(name,address,date);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;代理对象&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('2518668b-a0ec-4477-a5d5-7f853ae36d93')&quot; readability=&quot;35.5&quot;&gt;&lt;img id=&quot;code_img_closed_2518668b-a0ec-4477-a5d5-7f853ae36d93&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_2518668b-a0ec-4477-a5d5-7f853ae36d93&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('2518668b-a0ec-4477-a5d5-7f853ae36d93',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_2518668b-a0ec-4477-a5d5-7f853ae36d93&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args){

        Performance performance &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Artist().getAgent();

        performance.Sing(&lt;/span&gt;&quot;CXK&quot;,&quot;韩国&quot;, DateFormat.getDateInstance().format(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date()));
        performance.dance(&lt;/span&gt;&quot;CXK&quot;,&quot;韩国&quot;,DateFormat.getDateInstance().format(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date()));
        performance.perform(&lt;/span&gt;&quot;CXK&quot;,&quot;韩国&quot;,DateFormat.getDateInstance().format(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date()));

    }
输出：
&lt;/span&gt;2019-5-26&lt;span&gt;    CXK在韩国rap了一首xX
&lt;/span&gt;2019-5-26&lt;span&gt;    CXK在韩国跳了一个芭蕾
&lt;/span&gt;2019-5-26    CXK在韩国表演了打篮球
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;测试&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;上面我们是走指定的代理对象 执行方法；&lt;/p&gt;
&lt;p&gt;那么我们不通过代理方法来执行呢，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('b3c67f75-0583-4a7c-ab8f-843bf18f66c8')&quot; readability=&quot;35.5&quot;&gt;&lt;img id=&quot;code_img_closed_b3c67f75-0583-4a7c-ab8f-843bf18f66c8&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_b3c67f75-0583-4a7c-ab8f-843bf18f66c8&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('b3c67f75-0583-4a7c-ab8f-843bf18f66c8',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_b3c67f75-0583-4a7c-ab8f-843bf18f66c8&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;不通过代理还执行&lt;/span&gt;
Performance performance = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Artist();

performance.Sing(&lt;/span&gt;&quot;CXK&quot;,&quot;韩国&quot;, DateFormat.getDateInstance().format(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date()));
performance.dance(&lt;/span&gt;&quot;CXK&quot;,&quot;韩国&quot;,DateFormat.getDateInstance().format(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date()));
performance.perform(&lt;/span&gt;&quot;CXK&quot;,&quot;韩国&quot;,DateFormat.getDateInstance().format(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date()));

输出：
请使用指定的代理类
请使用指定的代理类
请使用指定的代理类&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;不走代理方法&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;很显然，不用代理方法是不能执行成功的&lt;/p&gt;
&lt;p&gt;不是指定代理方法呢，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('ddee8ba1-4e9c-492a-b4e0-6cfa8f66b0d9')&quot; readability=&quot;35.5&quot;&gt;&lt;img id=&quot;code_img_closed_ddee8ba1-4e9c-492a-b4e0-6cfa8f66b0d9&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_ddee8ba1-4e9c-492a-b4e0-6cfa8f66b0d9&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('ddee8ba1-4e9c-492a-b4e0-6cfa8f66b0d9',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_ddee8ba1-4e9c-492a-b4e0-6cfa8f66b0d9&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;不是指定的代理方法&lt;/span&gt;
Performance performance = &lt;span&gt;new&lt;/span&gt; Agent(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Artist());

performance.Sing(&lt;/span&gt;&quot;CXK&quot;,&quot;韩国&quot;, DateFormat.getDateInstance().format(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date()));
performance.dance(&lt;/span&gt;&quot;CXK&quot;,&quot;韩国&quot;,DateFormat.getDateInstance().format(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date()));
performance.perform(&lt;/span&gt;&quot;CXK&quot;,&quot;韩国&quot;,DateFormat.getDateInstance().format(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date()));
输出：
请使用指定的代理类
请使用指定的代理类
请使用指定的代理类&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;不是指定的代理方法&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;显然不是指定的代理方法也是执行不了的&lt;/p&gt;
&lt;p&gt; 这个示例是强制代理模式，概念就是要从真是角色那里查找到代理角色，不允许直接访问真实角色。&lt;/p&gt;
&lt;p&gt;上层模块只需要调用Agent()获取代理来访问真实角色的所有方法，它根本就不需要产生一个代理角色，代理的管理已经由真实角色自己来完成。&lt;/p&gt;
&lt;p&gt;后续讲解一个 基本代理 、普通代理、虚拟代理模式 和动态代理模式。&lt;/p&gt;
</description>
<pubDate>Sun, 26 May 2019 14:14:00 +0000</pubDate>
<dc:creator>justBobo</dc:creator>
<og:description>一、什么是代理模式 定义：为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。一个类代表另一个类的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/justBobo/p/10927408.html</dc:identifier>
</item>
<item>
<title>Java设计模式——单例模式 - 程序猿开心</title>
<link>http://www.cnblogs.com/programmerkaixin/p/10927837.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/programmerkaixin/p/10927837.html</guid>
<description>&lt;h3 id=&quot;java设计模式单例模式&quot;&gt;Java设计模式——单例模式&lt;/h3&gt;
&lt;p&gt;我一直觉得，设计模式的思想都是源于生活的。单例在生活之中也是经常用到的，比如国家领导人、某某公司创始人......类似这种独一无二的。单例模式也属于创建型设计模式，确保在任何情况下单例类最多只能有一个实例对象，并且提供全局访问点。单例模式可以保证内存里只有一个实例，减少了内存开销；可以避免对资源的多重占用。反正就是在内存世界里，单例模式的类的实例是独一无二的。当然也有线程单例，就是同一个线程只有一个单例类实例。&lt;/p&gt;
&lt;h3 id=&quot;饿汉式单例&quot;&gt;饿汉式单例&lt;/h3&gt;
&lt;p&gt;类加载的时候就立马初始化生成类的实例对象。不管来没来，先吃饱再说。&lt;/p&gt;
&lt;p&gt;步骤：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;提供一个单例类的私有的最终的静态全局单例类属性变量。&lt;/li&gt;
&lt;li&gt;私有化单例类的构造方法。&lt;/li&gt;
&lt;li&gt;初始化对象（可以在第一步或者第二步完成）。&lt;/li&gt;
&lt;li&gt;提供全局访问点，用于返回对象实现。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;代码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * @description: 饿汉式单例
 * @author: lmc
 * @create: 2019-04-02 20:39
 **/

public class HungrySingletonOne implements Serializable {

    /**
     * 饿汉式单例，在类初始化的时候就进行对象的创建，不存在不同步问题
     */

    //第一步提供一个私有的最终的静态全局属性变量，用于返回对象。
    private static final HungrySingletonOne hungrySingletonOne=new HungrySingletonOne();

    //第二步 私有化构造方法
    private HungrySingletonOne(){
        if(null != hungrySingletonOne){
            throw new RuntimeException(&quot;单例类，不允许被反射实例化&quot;);
        }
    }

    //提供全局访问点
    public static HungrySingletonOne getInstance(){
        return hungrySingletonOne;
    }

    /**
     * @description: 重写readResolve方法，防止序列化破坏单例
     * @return java.lang.Object
     * @date 2019/5/25 22:12
     * @author lmc
     */
    private Object readResolve(){
        return hungrySingletonOne;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * @description: 饿汉式单例
 * @author: lmc
 * @create: 2019-04-02 20:39
 **/

public class HungrySingletonTwo {

    /**
     * 饿汉式单例，在类初始化的时候就进行对象的创建
     */

    //第一步提供一个私有的最终的静态全局属性变量，用于返回对象。
    private static final HungrySingletonTwo hungrySingletonTwo;

    static {
        hungrySingletonTwo=new HungrySingletonTwo();
    }

    //第二步 私有化构造方法
    private HungrySingletonTwo(){
        if(null != hungrySingletonTwo){
            throw new RuntimeException(&quot;单例类，不允许被反射实例化&quot;);
        }
    }

    //提供全局访问点
    public static HungrySingletonTwo getInstance(){
        return hungrySingletonTwo;
    }

    /**
     * @description: 重写readResolve方法，防止序列化破坏单例
     * @return java.lang.Object
     * @date 2019/5/25 22:12
     * @author lmc
     */
    private Object readResolve(){
        return hungrySingletonTwo;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;饿汉式单例利弊&lt;/p&gt;
&lt;p&gt;利：没有加锁，执行效率高，比懒汉式体验好。饿汉式，在单例类加载的时候就已经初始化好了实例对象，不存在线程安全问题，因此没有共享的说法。&lt;/p&gt;
&lt;p&gt;弊：如果单例类不经常使用，占用了内存。&lt;/p&gt;
&lt;p&gt;Spring中 &lt;code&gt;IOC&lt;/code&gt;容器&lt;code&gt;ApplicationContext&lt;/code&gt;本身就是典型的饿汉式单例&lt;/p&gt;
&lt;p&gt;饿汉式单例不存在线程安全问题，这里就不做测试结果展示了，上面的代码都是可以直接运行测试的。&lt;/p&gt;
&lt;h3 id=&quot;懒汉式单例之双重检查锁单例&quot;&gt;懒汉式单例之双重检查锁单例&lt;/h3&gt;
&lt;p&gt;懒汉式单例类在类加载的时候不会初始化类生成单例类的实例，而是在调用单例类获取实例的方法的时候才会去初始化实例对象，并返回一个单例对象。&lt;/p&gt;
&lt;p&gt;因为懒汉式单例，是在单例类的获取实例方法被调用的时候才会去初始化对象，所以存在高并发，线程安全问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;synchronized&lt;/strong&gt;用来保证线程安全问题（原理在这里不细说了）&lt;/p&gt;
&lt;p&gt;根据业务需求，synchronized关键字能不写在方法上就不要写在方法上，写在方法里面。这样可以避免整个类都被锁住，写在方法里面，其他线程还是能够运行这个方法被锁之前的代码的。性能稍微提供提高一点点。所以我们有了双重检查锁单例。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * @description: 简单的懒汉式单例
 * @author: lmc
 * @create: 2019-04-03 08:59
 **/
public class LazySimpleSingleton implements Serializable {

    //第一步 构造方法私有化,并且设置异常防止反射破坏单例
    private LazySimpleSingleton(){
        if(null != lazySimpleSingleton){
            throw new RuntimeException(&quot;单例类，不允许被反射实例化&quot;);
        }
    }
    //第二步 定义对象属性
    private static volatile LazySimpleSingleton lazySimpleSingleton=null;

    //第三步 声明全局访问点
    /**
     * @description: 双重检查锁单例
     * @return com.lmc.gp12380.pattern.singleton.lazy.LazySimpleSingleton
     * @date 2019/5/25 21:21
     * @author lmc
     */
    public static LazySimpleSingleton getInstance(){

        if(null == lazySimpleSingleton){//第一次检查
            synchronized (LazySimpleSingleton.class){//加锁 保证线程安全性
                if(null == lazySimpleSingleton){//第二次检查
                    lazySimpleSingleton=new LazySimpleSingleton();
                }
            }
        }
        return lazySimpleSingleton;
    }

    /**
     * @description: 重写readResolve方法，防止序列化破坏单例
     * @return java.lang.Object
     * @date 2019/5/25 22:12
     * @author lmc
     */
    private Object readResolve(){
        return lazySimpleSingleton;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;双重检查锁单例，可以用 &lt;strong&gt;idea&lt;/strong&gt; 的&lt;strong&gt;debug&lt;/strong&gt;线程模式调试测试。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;volatile&lt;/strong&gt;关键字的作用在这里不细说，就是用来保证绝对的线程安全。&lt;/p&gt;
&lt;p&gt;定义一个线程执行器&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * @description: 执行线程
 * @author: lmc
 * @create: 2019-04-03 08:56
 **/
public class ExectorThread implements Runnable {

    public void run() {
        LazySimpleSingleton lazySimpleSingleton=LazySimpleSingleton.getInstance();
        System.out.println(&quot;线程&quot;+Thread.currentThread().getName()+&quot;lazySimpleSingleton&quot;+lazySimpleSingleton);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试代码&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * @description: 简单懒汉式单例测试
 * @author: lmc
 * @create: 2019-04-03 09:10
 **/
public class LazySimpleSingletonTest {

    public static void main(String[] args){
        
        for (int i = 0; i &amp;lt;10; i++) {
            Thread thread= new Thread(new ExectorThread());
            thread.start();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试结果&lt;img src=&quot;https://img2018.cnblogs.com/blog/1677319/201905/1677319-20190526214547616-705906728.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，10个线程获取的对象都是同一个实例。&lt;/p&gt;
&lt;h3 id=&quot;懒汉式单例之静态内部类单例&quot;&gt;懒汉式单例之静态内部类单例&lt;/h3&gt;
&lt;p&gt;静态内部类单例在外部类调用获取实例方法的时候才会初始化实例对象，静态内部类在类加载的时候并不会初始化，只有在创建内部类对象或者，内部类对象静态成员被第一次引用的时候才会初始化对象。然而，对于静态内部类单例来说，我们永远不会主动的去创建内部类对象。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * @description: 懒汉式静态内部类单例
 * @author: lmc
 * @create: 2019-04-03 11:28
 **/
public class LazyInnerClassSingleton implements Serializable {

    //私有化构造方法
    private LazyInnerClassSingleton(){
        if(Holder.lazy != null){//只能调用一次构造创建实例
            throw new RuntimeException(&quot;静态内部类单例，不允许创建多个实例&quot;);
        }
    }

    public static final LazyInnerClassSingleton getInstance(){
        return Holder.lazy;
    }

    /**
     * @description:静态内部类初始化外部类成员变量
     * @date 2019/5/25 22:11
     * @author lmc
     */
    private static class Holder {
        private final static LazyInnerClassSingleton lazy=new LazyInnerClassSingleton();
    }

    /**
     * @description: 重写readResolve方法，防止序列化破坏单例
     * @return java.lang.Object
     * @date 2019/5/25 22:12
     * @author lmc
     */
    private Object readResolve(){
        return Holder.lazy;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的代码中，内部类Holder的静态成员变量 lazy是 final static修饰，无论是创建内部类对象，初始化lazy还是调用静态属性lazy引用初始化都之后初始化一次。并且&lt;code&gt;LazyInnerClassSingleton&lt;/code&gt;单例类只能被内部类实例化一次。&lt;/p&gt;
&lt;p&gt;测试代码&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * @description: 内部类懒汉式单例测试
 * @author: lmc
 * @create: 2019-04-03 09:10
 **/

public class LazyInnerClassSingletonTest {


    public static void main(String[] args){

        for (int i = 0; i &amp;lt;10 ; i++) {
            Thread thread= new Thread(new Runnable() {
                @Override
                public void run() {
                    LazyInnerClassSingleton lazyInnerClassSingleton =   LazyInnerClassSingleton.getInstance();
                    System.out.println(&quot;线程&quot;+Thread.currentThread().getName()+&quot;lazyInnerClassSingleton&quot;+lazyInnerClassSingleton);
                }
            });
            thread.start();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试结果&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1677319/201905/1677319-20190526214612945-848053188.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;注册式单例之容器单例&quot;&gt;注册式单例之容器单例&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * @description: 容器式单例
 * @author: lmc
 * @create: 2019-04-08 21:43
 **/
public class ContainerSingleton {

    private ContainerSingleton(){};

    private static Map&amp;lt;String,Object&amp;gt; ioc=new ConcurrentHashMap&amp;lt;String, Object&amp;gt;();

    public static Object getBean(String className){
        if(null != className &amp;amp;&amp;amp; className!=&quot;&quot;){
            synchronized (className){
                if(ioc.containsKey(className)){
                    return ioc.get(className);
                }
                Object obj=null;
                try {
                    obj=Class.forName(className).newInstance();
                    ioc.put(className,obj);
                }catch (Exception e){
                    e.printStackTrace();
                }
                return obj;
            }
        }
        return null;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果需要创建很多单例对象，一般用容器式单例管理对象。&lt;/p&gt;
&lt;p&gt;虽然 &lt;code&gt;ConcurrentHashMap&lt;/code&gt;是线程安全的，但是调用&lt;code&gt;getBean&lt;/code&gt;方法不是线程安全的，所有要加&lt;code&gt;synchronized&lt;/code&gt;锁。&lt;/p&gt;
&lt;p&gt;容器式单例就不写测试结果了。&lt;/p&gt;
&lt;h3 id=&quot;注册式单例之枚举单例&quot;&gt;注册式单例之枚举单例&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * @description: 枚举单例
 * @author: lmc
 * @create: 2019-04-03 15:31
 **/

public enum EnumSingleton {

    INSTENCE;

    private EnumSingleton(){

    }

    private Object data;

    public Object getData() {
        return data;
    }

    public void setData(Object data) {
        this.data = data;
    }

    public static EnumSingleton getInstance(){
        return INSTENCE;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;枚举类型重&lt;code&gt;JVM&lt;/code&gt;虚拟机底层就帮我们做了防止序列化和反射破坏单例。&lt;/p&gt;
&lt;p&gt;反编译&lt;code&gt;EnumSingleton.class&lt;/code&gt;文件&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.lmc.gp12380.pattern.singleton.register;


public final class EnumSingleton extends Enum
{

    public static EnumSingleton[] values()
    {
        return (EnumSingleton[])$VALUES.clone();
    }

    public static EnumSingleton valueOf(String name)
    {
        return (EnumSingleton)Enum.valueOf(com/lmc/gp12380/pattern/singleton/register/EnumSingleton, name);
    }

    private EnumSingleton(String s, int i)
    {
        super(s, i);
    }

    public Object getData()
    {
        return data;
    }

    public void setData(Object data)
    {
        this.data = data;
    }

    public static EnumSingleton getInstance()
    {
        return INSTENCE;
    }

    public static final EnumSingleton INSTENCE;
    private Object data;
    private static final EnumSingleton $VALUES[];

    static 
    {
        INSTENCE = new EnumSingleton(&quot;INSTENCE&quot;, 0);
        $VALUES = (new EnumSingleton[] {
            INSTENCE
        });
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;反编译之后枚举 &lt;code&gt;INSTENCE&lt;/code&gt;变成了静态最终变量，由静态代码块饿汉式初始化，&lt;code&gt;EnumSingleton&lt;/code&gt;构造函数也是私有的，不允许外部创建对象。所有枚举符合单例需求。&lt;/p&gt;
&lt;p&gt;测试代码&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * @description: 枚举单例测试
 * @author: lmc
 * @create: 2019-04-03 15:33
 **/

public class EnumSingletonTest {

    public static void main(String[] args) {

        for (int i = 0; i &amp;lt;10 ; i++) {
            Thread thread=new Thread(new Runnable() {
                @Override
                public void run() {
                    EnumSingleton enumSingleton=EnumSingleton.getInstance();
                    System.out.println(Thread.currentThread().getName()+&quot;enumSingleton&amp;gt;&amp;gt;&quot;+enumSingleton);
                }
            });
            thread.start();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试结果&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1677319/201905/1677319-20190526214644649-1296220715.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;反射和序列化破坏单例测试&quot;&gt;反射和序列化破坏单例测试&lt;/h3&gt;
&lt;p&gt;上述代码中，饿汉式和懒汉式，在私有化构造方法中都是有条件抛出异常&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;if(condition){
    throw new RuntimeException(&quot;单例类，不允许被反射实例化&quot;);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段代码是为了保证单例类只能实例化一次，防止反射破坏单例。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt; private Object readResolve(){
    return hungrySingletonOne;
 }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的代码是重写了&lt;code&gt;Serializable&lt;/code&gt;接口的&lt;code&gt;readResolve&lt;/code&gt;方法，是为了防止序列化破坏单例对象。&lt;/p&gt;
&lt;p&gt;防止反射破坏单例测试&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * @description: 反射破坏单例测试
 * @author: lmc
 * @create: 2019-05-25 23:19
 **/

public class TestReflectDestructionSingleton {

    public static void main(String[] args) {

        try {
            LazyInnerClassSingleton lazyInnerClassSingleton1= LazyInnerClassSingleton.getInstance();
            System.out.println(lazyInnerClassSingleton1);
            Class&amp;lt;?&amp;gt; clazz=LazyInnerClassSingleton.class;
            Constructor c=clazz.getDeclaredConstructor(null);
            c.setAccessible(true);
            LazyInnerClassSingleton lazyInnerClassSingleton2= (LazyInnerClassSingleton) c.newInstance();
            System.out.println(lazyInnerClassSingleton2);
            System.out.println(lazyInnerClassSingleton1==lazyInnerClassSingleton2);
        }catch (Exception e){
            e.printStackTrace();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试结果&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1677319/201905/1677319-20190526214704863-489046067.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;利用反射生成实例，直接抛出异常，中断程序运行。客户端调用就不会去利用反射了。&lt;/p&gt;
&lt;p&gt;去掉上面的抛出异常的条件执行测试程序，会出现两个不一样的实例，单例被破坏。&lt;/p&gt;
&lt;p&gt;防止序列化破坏&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * @description: 序列化破坏单例测试
 * @author: lmc
 * @create: 2019-05-25 23:13
 **/

public class TestSerializDestructionSingleton {

    public static void main(String[] args) {

        LazyInnerClassSingleton s1 = null;
        LazyInnerClassSingleton s2 = LazyInnerClassSingleton.getInstance();
        FileOutputStream fos = null;
        try {
            fos = new FileOutputStream(&quot;LazyInnerClassSingleton.txt&quot;);
            ObjectOutputStream oos = new ObjectOutputStream(fos);
            oos.writeObject(s2);
            oos.flush();
            oos.close();
            FileInputStream fis = new FileInputStream(&quot;LazyInnerClassSingleton.txt&quot;);
            ObjectInputStream ois = new ObjectInputStream(fis);
            s1 = (LazyInnerClassSingleton)ois.readObject();
            ois.close();
            System.out.println(s1);
            System.out.println(s2);
            System.out.println(s1 == s2);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试结果&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1677319/201905/1677319-20190526214724239-1085933845.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;序列化和反序列化生成的对象和之前的对象是一样的，这就说明单例模式有效。&lt;/p&gt;
&lt;p&gt;验证序列化破坏单例只需要去掉重写的&lt;code&gt;readResolve&lt;/code&gt;方法就可以得到两个不一样的实例，单例被破坏。&lt;/p&gt;
&lt;p&gt;反射破坏单例测试和序列化破坏单例只需要更换类就能测试其他单例了，在这就不做测试了。&lt;/p&gt;
&lt;p&gt;注册式容器式单例是从Map集合获取对象，不需要做单例破坏测试。&lt;/p&gt;
&lt;p&gt;注册式枚举式单例是重&lt;code&gt;JVM&lt;/code&gt;层面防止单例破坏。虽然没有加上面的防止破坏代码，也可以用上面的测试代码测试。&lt;/p&gt;
</description>
<pubDate>Sun, 26 May 2019 14:04:00 +0000</pubDate>
<dc:creator>程序猿开心</dc:creator>
<og:description>Java设计模式——单例模式 我一直觉得，设计模式的思想都是源于生活的。单例在生活之中也是经常用到的，比如国家领导人、某某公司创始人......类似这种独一无二的。单例模式也属于创建型设计模式，确保在</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/programmerkaixin/p/10927837.html</dc:identifier>
</item>
<item>
<title>zookeeper源码 — 四、session建立 - lacker</title>
<link>http://www.cnblogs.com/sunshine-2015/p/10927892.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sunshine-2015/p/10927892.html</guid>
<description>&lt;p&gt;目录&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;session建立的主要过程&lt;/li&gt;
&lt;li&gt;客户端发起连接&lt;/li&gt;
&lt;li&gt;服务端创建session&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;session建立的主要过程&quot;&gt;session建立的主要过程&lt;/h2&gt;
&lt;p&gt;用一张图来说明session建立过程中client和server的交互&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/846961/201905/846961-20190526215653005-1541043264.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;主要流程&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;服务端启动，客户端启动&lt;/li&gt;
&lt;li&gt;客户端发起socket连接&lt;/li&gt;
&lt;li&gt;服务端accept socket连接，socket连接建立&lt;/li&gt;
&lt;li&gt;客户端发送ConnectRequest给server&lt;/li&gt;
&lt;li&gt;server收到后初始化ServerCnxn，代表一个和客户端的连接，即session，server发送ConnectResponse给client&lt;/li&gt;
&lt;li&gt;client处理ConnectResponse，session建立完成&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;客户发起连接&quot;&gt;客户发起连接&lt;/h2&gt;
&lt;h3 id=&quot;和server建立socket连接&quot;&gt;和server建立socket连接&lt;/h3&gt;
&lt;p&gt;客户端要发起连接要先启动，不论是使用curator client还是zkClient，初始化的都是初始化&lt;code&gt;org.apache.zookeeper.ZooKeeper#ZooKeeper&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;Zookeeper初始化的主要工作是初始化自己的一些关键组件&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Watcher，外部构造好传入&lt;/li&gt;
&lt;li&gt;初始化StaticHostProvider，决定客户端选择连接哪一个server&lt;/li&gt;
&lt;li&gt;ClientCnxn，客户端网络通信的组件，主要启动逻辑就是启动这个类&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;ClientCnxn包含两个线程&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;SendThread，负责client端消息的发送和接收&lt;/li&gt;
&lt;li&gt;EventThread，负责处理event&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;ClientCnxn初始化的过程就是初始化启动这两个线程，客户端发起连接的主要逻辑在SendThread线程中&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// org.apache.zookeeper.ClientCnxn.SendThread#run
@Override
public void run() {
    clientCnxnSocket.introduce(this,sessionId);
    clientCnxnSocket.updateNow();
    clientCnxnSocket.updateLastSendAndHeard();
    int to;
    long lastPingRwServer = System.currentTimeMillis();
    final int MAX_SEND_PING_INTERVAL = 10000; //10 seconds
    while (state.isAlive()) {
        try {
            // client是否连接到server，如果没有连接到则连接server
            if (!clientCnxnSocket.isConnected()) {
                if(!isFirstConnect){
                    try {
                        Thread.sleep(r.nextInt(1000));
                    } catch (InterruptedException e) {
                        LOG.warn(&quot;Unexpected exception&quot;, e);
                    }
                }
                // don't re-establish connection if we are closing
                if (closing || !state.isAlive()) {
                    break;
                }
                // 这个里面去连接server
                startConnect();
                clientCnxnSocket.updateLastSendAndHeard();
            }

            // 省略中间代码...
            clientCnxnSocket.doTransport(to, pendingQueue, outgoingQueue, ClientCnxn.this);
            // 省略中间代码...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;SendThread#run是一个while循环，只要client没有被关闭会一直循环，每次循环判断当前client是否连接到server，如果没有则发起连接，发起连接调用了startConnect&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private void startConnect() throws IOException {
    state = States.CONNECTING;

    InetSocketAddress addr;
    if (rwServerAddress != null) {
        addr = rwServerAddress;
        rwServerAddress = null;
    } else {
        // 通过hostProvider来获取一个server地址
        addr = hostProvider.next(1000);
    }
    // 省略中间代码...

    // 建立client与server的连接
    clientCnxnSocket.connect(addr);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;到这里client发起了socket连接，server监听的端口收到client的连接请求后和client建立连接。&lt;/p&gt;
&lt;h3 id=&quot;通过一个request来建立session连接&quot;&gt;通过一个request来建立session连接&lt;/h3&gt;
&lt;p&gt;socket连接建立后，client会向server发送一个ConnectRequest来建立session连接。两种情况会发送ConnectRequest&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在上面的connect方法中会判断是否socket已经建立成功，如果建立成功就会发送ConnectRequest&lt;/li&gt;
&lt;li&gt;如果socket没有立即建立成功（socket连接建立是异步的），则发送这个packet要延后到doTransport中&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;发送ConnectRequest是在下面的方法中&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// org.apache.zookeeper.ClientCnxn.SendThread#primeConnection
void primeConnection() throws IOException {
    LOG.info(&quot;Socket connection established to &quot;
             + clientCnxnSocket.getRemoteSocketAddress()
             + &quot;, initiating session&quot;);
    isFirstConnect = false;
    long sessId = (seenRwServerBefore) ? sessionId : 0;
    ConnectRequest conReq = new ConnectRequest(0, lastZxid,
                                               sessionTimeout, sessId, sessionPasswd);
        // 省略中间代码...
        // 将conReq封装为packet放入outgoingQueue等待发送
        outgoingQueue.addFirst(new Packet(null, null, conReq,
                                          null, null, readOnly));
    }
    clientCnxnSocket.enableReadWriteOnly();
    if (LOG.isDebugEnabled()) {
        LOG.debug(&quot;Session establishment request sent on &quot;
                  + clientCnxnSocket.getRemoteSocketAddress());
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;请求中带的参数&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;lastZxid：上一个事务的id&lt;/li&gt;
&lt;li&gt;sessionTimeout：client端配置的sessionTimeout&lt;/li&gt;
&lt;li&gt;sessId：sessionId，如果之前建立过连接取的是上一次连接的sessionId&lt;/li&gt;
&lt;li&gt;sessionPasswd：session的密码&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;服务端创建session&quot;&gt;服务端创建session&lt;/h2&gt;
&lt;h3 id=&quot;和client建立socket连接&quot;&gt;和client建立socket连接&lt;/h3&gt;
&lt;p&gt;在server启动的过程中除了会启动用于选举的网络组件还会启动用于处理client请求的网络组件&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;org.apache.zookeeper.server.NIOServerCnxnFactory&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/846961/201905/846961-20190526215715069-1719289492.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;主要启动了三个线程：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;AcceptThread：用于接收client的连接请求，建立连接后交给SelectorThread线程处理&lt;/li&gt;
&lt;li&gt;SelectorThread：用于处理读写请求&lt;/li&gt;
&lt;li&gt;ConnectionExpirerThread：检查session连接是否过期&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;client发起socket连接的时候，server监听了该端口，接收到client的连接请求，然后把建立练级的SocketChannel放入队列里面，交给SelectorThread处理&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// org.apache.zookeeper.server.NIOServerCnxnFactory.SelectorThread#addAcceptedConnection
public boolean addAcceptedConnection(SocketChannel accepted) {
    if (stopped || !acceptedQueue.offer(accepted)) {
        return false;
    }
    wakeupSelector();
    return true;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;建立session连接&quot;&gt;建立session连接&lt;/h3&gt;
&lt;p&gt;SelectorThread是一个不断循环的线程，每次循环都会处理刚刚建立的socket连接&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// org.apache.zookeeper.server.NIOServerCnxnFactory.SelectorThread#run
while (!stopped) {
    try {
        select();
        //  处理对立中的socket
        processAcceptedConnections();
        processInterestOpsUpdateRequests();
    } catch (RuntimeException e) {
        LOG.warn(&quot;Ignoring unexpected runtime exception&quot;, e);
    } catch (Exception e) {
        LOG.warn(&quot;Ignoring unexpected exception&quot;, e);
    }
}

// org.apache.zookeeper.server.NIOServerCnxnFactory.SelectorThread#processAcceptedConnections
private void processAcceptedConnections() {
    SocketChannel accepted;
    while (!stopped &amp;amp;&amp;amp; (accepted = acceptedQueue.poll()) != null) {
        SelectionKey key = null;
        try {
            // 向该socket注册读事件
            key = accepted.register(selector, SelectionKey.OP_READ);
            // 创建一个NIOServerCnxn维护session
            NIOServerCnxn cnxn = createConnection(accepted, key, this);
            key.attach(cnxn);
            addCnxn(cnxn);
        // 省略中间代码...
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;说了这么久，我们说的session究竟是什么还没有解释，session中文翻译是会话，在这里就是zk的server和client维护的一个具有一些特别属性的网络连接，网络连接这里就是socket连接，一些特别的属性包括&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;sessionId：唯一标示一个会话&lt;/li&gt;
&lt;li&gt;sessionTimeout：这个连接的超时时间，超过这个时间server就会把连接断开&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所以session建立的两步就是&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;建立socket连接&lt;/li&gt;
&lt;li&gt;client发起建立session请求，server建立一个实例来维护这个连接&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;server收到ConnectRequest之后，按照正常处理io的方式处理这个request，server端的主要操作是&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;反序列化为ConnectRequest&lt;/li&gt;
&lt;li&gt;根据request中的sessionId来判断是新的session连接还是session重连
&lt;ul&gt;&lt;li&gt;如果是新连接
&lt;ul&gt;&lt;li&gt;生成sessionId&lt;/li&gt;
&lt;li&gt;创建新的SessionImpl并放入org.apache.zookeeper.server.SessionTrackerImpl#sessionExpiryQueue&lt;/li&gt;
&lt;li&gt;封装该请求为新的request在processorChain中传递，最后交给FinalRequestProcessor处理&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;如果是重连
&lt;ul&gt;&lt;li&gt;关闭sessionId对应的原来的session
&lt;ul&gt;&lt;li&gt;关闭原来的socket连接&lt;/li&gt;
&lt;li&gt;sessionImp会在sessionExpiryQueue中由于过期被清理&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;重新打开一个session
&lt;ul&gt;&lt;li&gt;将原来的sessionId设置到当前的NIOServerCnxn实例中，作为新的连接的sessionId&lt;/li&gt;
&lt;li&gt;校验密码是否正确密码错误的时候直接返回给客户端，不可用的session&lt;/li&gt;
&lt;li&gt;密码正确的话，新建SessionImpl&lt;/li&gt;
&lt;li&gt;返回给客户端sessionId&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;总体流程是&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/846961/201905/846961-20190526215732152-1900253635.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中有一个session生成算法我们来看下&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static long initializeNextSession(long id) {
    // sessionId是long类型，共8个字节，64位
    long nextSid;
    // 取时间戳的的低40位作为初始化sessionId的第16-55位，这里使用的是无符号右移，不会出现负数
    nextSid = (Time.currentElapsedTime() &amp;lt;&amp;lt; 24) &amp;gt;&amp;gt;&amp;gt; 8;
    // 使用serverId（配置文件中指定的myid）作为高8位
    nextSid =  nextSid | (id &amp;lt;&amp;lt;56);
    // nextSid为long的最小值，这中情况不可能出现，这里只是作为一个case列在这里
    if (nextSid == EphemeralType.CONTAINER_EPHEMERAL_OWNER) {
        ++nextSid;  // this is an unlikely edge case, but check it just in case
    }
    return nextSid;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;初始化sessionId的组成&lt;/p&gt;
&lt;p&gt;myid(1字节)+截取的时间戳低40位(5个字节)+2个字节(初始化都是0)&lt;/p&gt;
&lt;p&gt;每个server再基于这个id不断自增，这样的算法就保证了每个server的sessionId是全局唯一的。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;session在zk框架中是一个重要概念，很多功能都依赖于session，比如临时节点，session关闭后就自动删除了。本文主要介绍了session的建立过程中client和server各自的处理方式。&lt;/p&gt;
</description>
<pubDate>Sun, 26 May 2019 13:58:00 +0000</pubDate>
<dc:creator>lacker</dc:creator>
<og:description>目录 session建立的主要过程 客户端发起连接 服务端创建session session建立的主要过程 用一张图来说明session建立过程中client和server的交互 主要流程 服务端启动</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/sunshine-2015/p/10927892.html</dc:identifier>
</item>
<item>
<title>死磕 java同步系列之AQS起篇 - 彤哥读源码</title>
<link>http://www.cnblogs.com/tong-yuan/p/AQS.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tong-yuan/p/AQS.html</guid>
<description>&lt;h2 id=&quot;问题&quot;&gt;问题&lt;/h2&gt;
&lt;p&gt;（1）AQS是什么？&lt;/p&gt;
&lt;p&gt;（2）AQS的定位？&lt;/p&gt;
&lt;p&gt;（3）AQS的实现原理？&lt;/p&gt;
&lt;p&gt;（4）基于AQS实现自己的锁？&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;AQS的全称是AbstractQueuedSynchronizer，它的定位是为Java中几乎所有的锁和同步器提供一个基础框架。&lt;/p&gt;
&lt;p&gt;AQS是基于FIFO的队列实现的，并且内部维护了一个状态变量state，通过原子更新这个状态变量state即可以实现加锁解锁操作。&lt;/p&gt;
&lt;p&gt;本章及后续章节的内容理解起来可能会比较晦涩，建议先阅读彤哥上一章的内容【&lt;a href=&quot;https://mp.weixin.qq.com/s/1RU5jh7UcXGtKlae8tusVA&quot;&gt;死磕 java同步系列之自己动手写一个锁Lock&lt;/a&gt;】。&lt;/p&gt;
&lt;h2 id=&quot;核心源码&quot;&gt;核心源码&lt;/h2&gt;
&lt;h3 id=&quot;主要内部类&quot;&gt;主要内部类&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;static final class Node {
    // 标识一个节点是共享模式
    static final Node SHARED = new Node();
    // 标识一个节点是互斥模式
    static final Node EXCLUSIVE = null;

    // 标识线程已取消
    static final int CANCELLED =  1;
    // 标识后继节点需要唤醒
    static final int SIGNAL    = -1;
    // 标识线程等待在一个条件上
    static final int CONDITION = -2;
    // 标识后面的共享锁需要无条件的传播（共享锁需要连续唤醒读的线程）
    static final int PROPAGATE = -3;
    
    // 当前节点保存的线程对应的等待状态
    volatile int waitStatus;

    // 前一个节点
    volatile Node prev;
    
    // 后一个节点
    volatile Node next;

    // 当前节点保存的线程
    volatile Thread thread;

    // 下一个等待在条件上的节点（Condition锁时使用）
    Node nextWaiter;

    // 是否是共享模式
    final boolean isShared() {
        return nextWaiter == SHARED;
    }

    // 获取前一个节点
    final Node predecessor() throws NullPointerException {
        Node p = prev;
        if (p == null)
            throw new NullPointerException();
        else
            return p;
    }

    // 节点的构造方法
    Node() {    // Used to establish initial head or SHARED marker
    }

    // 节点的构造方法
    Node(Thread thread, Node mode) {     // Used by addWaiter
        // 把共享模式还是互斥模式存储到nextWaiter这个字段里面了
        this.nextWaiter = mode;
        this.thread = thread;
    }

    // 节点的构造方法
    Node(Thread thread, int waitStatus) { // Used by Condition
        // 等待的状态，在Condition中使用
        this.waitStatus = waitStatus;
        this.thread = thread;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;典型的双链表结构，节点中保存着当前线程、前一个节点、后一个节点以及线程的状态等信息。&lt;/p&gt;
&lt;h3 id=&quot;主要属性&quot;&gt;主要属性&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 队列的头节点
private transient volatile Node head;
// 队列的尾节点
private transient volatile Node tail;
// 控制加锁解锁的状态变量
private volatile int state;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;定义了一个状态变量和一个队列，状态变量用来控制加锁解锁，队列用来放置等待的线程。&lt;/p&gt;
&lt;p&gt;注意，这几个变量都要使用volatile关键字来修饰，因为是在多线程环境下操作，要保证它们的值修改之后对其它线程立即可见。&lt;/p&gt;
&lt;p&gt;这几个变量的修改是直接使用的Unsafe这个类来操作的：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 获取Unsafe类的实例，注意这种方式仅限于jdk自己使用，普通用户是无法这样调用的
private static final Unsafe unsafe = Unsafe.getUnsafe();
// 状态变量state的偏移量
private static final long stateOffset;
// 头节点的偏移量
private static final long headOffset;
// 尾节点的偏移量
private static final long tailOffset;
// 等待状态的偏移量（Node的属性）
private static final long waitStatusOffset;
// 下一个节点的偏移量（Node的属性）
private static final long nextOffset;

static {
    try {
        // 获取state的偏移量
        stateOffset = unsafe.objectFieldOffset
            (AbstractQueuedSynchronizer.class.getDeclaredField(&quot;state&quot;));
        // 获取head的偏移量
        headOffset = unsafe.objectFieldOffset
            (AbstractQueuedSynchronizer.class.getDeclaredField(&quot;head&quot;));
        // 获取tail的偏移量
        tailOffset = unsafe.objectFieldOffset
            (AbstractQueuedSynchronizer.class.getDeclaredField(&quot;tail&quot;));
        // 获取waitStatus的偏移量
        waitStatusOffset = unsafe.objectFieldOffset
            (Node.class.getDeclaredField(&quot;waitStatus&quot;));
        // 获取next的偏移量
        nextOffset = unsafe.objectFieldOffset
            (Node.class.getDeclaredField(&quot;next&quot;));

    } catch (Exception ex) { throw new Error(ex); }
}

// 调用Unsafe的方法原子更新state
protected final boolean compareAndSetState(int expect, int update) {
    return unsafe.compareAndSwapInt(this, stateOffset, expect, update);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;关于Unsafe类的讲解请参考彤哥之前写的【&lt;a href=&quot;https://mp.weixin.qq.com/s/0s-u-MysppIaIHVrshp9fA&quot;&gt;死磕 java魔法类之Unsafe解析&lt;/a&gt;】。&lt;/p&gt;
&lt;h3 id=&quot;子类需要实现的主要方法&quot;&gt;子类需要实现的主要方法&lt;/h3&gt;
&lt;p&gt;我们可以看到AQS的全称是AbstractQueuedSynchronizer，它本质上是一个抽象类，说明它本质上应该是需要子类来实现的，那么子类实现一个同步器需要实现哪些方法呢？&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 互斥模式下使用：尝试获取锁
protected boolean tryAcquire(int arg) {
    throw new UnsupportedOperationException();
}
// 互斥模式下使用：尝试释放锁
protected boolean tryRelease(int arg) {
    throw new UnsupportedOperationException();
}
// 共享模式下使用：尝试获取锁
protected int tryAcquireShared(int arg) {
    throw new UnsupportedOperationException();
}
// 共享模式下使用：尝试释放锁
protected boolean tryReleaseShared(int arg) {
    throw new UnsupportedOperationException();
}
// 如果当前线程独占着锁，返回true
protected boolean isHeldExclusively() {
    throw new UnsupportedOperationException();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;问题：这几个方法为什么不直接定义成抽象方法呢？&lt;/p&gt;
&lt;p&gt;因为子类只要实现这几个方法中的一部分就可以实现一个同步器了，所以不需要定义成抽象方法。&lt;/p&gt;
&lt;p&gt;下面我们通过一个案例来介绍AQS中的部分方法。&lt;/p&gt;
&lt;h3 id=&quot;基于aqs自己动手写一个锁&quot;&gt;基于AQS自己动手写一个锁&lt;/h3&gt;
&lt;p&gt;直接上代码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class MyLockBaseOnAqs {

    // 定义一个同步器，实现AQS类
    private static class Sync extends AbstractQueuedSynchronizer {
        // 实现tryAcquire(acquires)方法
        @Override
        public boolean tryAcquire(int acquires) {
            if (compareAndSetState(0, 1)) {
                setExclusiveOwnerThread(Thread.currentThread());
                return true;
            }
            return false;
        }
        // 实现tryRelease(releases)方法
        @Override
        protected boolean tryRelease(int releases) {
            setExclusiveOwnerThread(null);
            setState(0);
            return true;
        }
    }

    // 声明同步器
    private final Sync sync = new Sync();

    // 加锁
    public void lock() {
        sync.acquire(1);
    }

    // 解锁
    public void unlock() {
        sync.release(1);
    }


    private static int count = 0;

    public static void main(String[] args) throws InterruptedException {
        MyLockBaseOnAqs lock = new MyLockBaseOnAqs();

        CountDownLatch countDownLatch = new CountDownLatch(1000);

        IntStream.range(0, 1000).forEach(i -&amp;gt; new Thread(() -&amp;gt; {
            lock.lock();

            try {
                IntStream.range(0, 10000).forEach(j -&amp;gt; {
                    count++;
                });
            } finally {
                lock.unlock();
            }
//            System.out.println(Thread.currentThread().getName());
            countDownLatch.countDown();
        }, &quot;tt-&quot; + i).start());

        countDownLatch.await();

        System.out.println(count);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行main()方法总是打印出10000000（一千万），说明这个锁也是可以直接使用的，当然这也是一个不可重入的锁。&lt;/p&gt;
&lt;p&gt;是不是很简单，只需要简单地实现AQS的两个方法就完成了上一章彤哥自己动手实现的锁的功能。&lt;/p&gt;
&lt;p&gt;它是怎么实现的呢？&lt;/p&gt;
&lt;p&gt;我们这一章先不讲源码，后面学习了ReentrantLock自然就明白了。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;这一章就到此结束了，本篇没有去深入的解析AQS的源码，笔者认为这没有必要，因为对于从来都没有看过锁相关的源码的同学来说，一上来就讲AQS的源码肯定会一脸懵逼的，具体的源码我们穿插在后面的锁和同步器的部分来学习，等所有跟AQS相关的源码学习完毕了，再来一篇总结。&lt;/p&gt;
&lt;p&gt;下面总结一下这一章的主要内容：&lt;/p&gt;
&lt;p&gt;（1）AQS是Java中几乎所有锁和同步器的一个基础框架，这里说的是“几乎”，因为有极个别确实没有通过AQS来实现；&lt;/p&gt;
&lt;p&gt;（2）AQS中维护了一个队列，这个队列使用双链表实现，用于保存等待锁排队的线程；&lt;/p&gt;
&lt;p&gt;（3）AQS中维护了一个状态变量，控制这个状态变量就可以实现加锁解锁操作了；&lt;/p&gt;
&lt;p&gt;（4）基于AQS自己动手写一个锁非常简单，只需要实现AQS的几个方法即可。&lt;/p&gt;
&lt;h2 id=&quot;彩蛋&quot;&gt;彩蛋&lt;/h2&gt;
&lt;p&gt;上一章彤哥自己动手写的锁，其实可以看成是AQS的一个缩影，看懂了那个基本上AQS可以看懂一半了，因为彤哥那个里面没有写Condition相关的内容，下一章ReentrantLock重入锁中我们将一起学习Condition相关的内容。&lt;/p&gt;
&lt;p&gt;所以呢，还是建议大家去看看这篇文章，点击下面的推荐阅读可以直达。&lt;/p&gt;
&lt;h2 id=&quot;推荐阅读&quot;&gt;推荐阅读&lt;/h2&gt;
&lt;ol readability=&quot;0.034934497816594&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/1RU5jh7UcXGtKlae8tusVA&quot;&gt;死磕 java同步系列之自己动手写一个锁Lock&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/0s-u-MysppIaIHVrshp9fA&quot;&gt;死磕 java魔法类之Unsafe解析&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/jownTN--npu3o8B4c3sbeA&quot;&gt;死磕 java同步系列之JMM（Java Memory Model）&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/TROZ4BhcDImwHvhAl_I_6w&quot;&gt;死磕 java同步系列之volatile解析&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/RT7VreIh9PU03HhE3WSLjg&quot;&gt;死磕 java同步系列之synchronized解析&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;hr/&gt;&lt;p&gt;欢迎关注我的公众号“彤哥读源码”，查看更多源码系列文章, 与彤哥一起畅游源码的海洋。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/alan-tang-tt/yuan/raw/master/%E6%AD%BB%E7%A3%95%20java%E9%9B%86%E5%90%88%E7%B3%BB%E5%88%97/resource/qrcode_ss.jpg&quot; alt=&quot;qrcode&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 26 May 2019 13:52:00 +0000</pubDate>
<dc:creator>彤哥读源码</dc:creator>
<og:description>AQS是什么？ AQS的定位？ AQS的实现原理？ 基于AQS实现自己的锁？</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tong-yuan/p/AQS.html</dc:identifier>
</item>
<item>
<title>线程池之ThreadPoolExecutor线程池源码分析笔记 - ·木木夕·</title>
<link>http://www.cnblogs.com/huangjuncong/p/10031525.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huangjuncong/p/10031525.html</guid>
<description>&lt;h2&gt;1.线程池的作用&lt;/h2&gt;
&lt;p&gt;一方面当执行大量异步任务时候线程池能够提供较好的性能，在不使用线程池的时候，每当需要执行异步任务时候是直接 new 一线程进行运行，而线程的创建和销毁是需要开销的。使用线程池时候，线程池里面的线程是可复用的，不会每次执行异步任务时候都重新创建和销毁线程。&lt;/p&gt;
&lt;p&gt;另一方面线程池提供了一种资源限制和管理的手段，比如可以限制线程的个数，动态新增线程等，每个 &lt;code&gt;ThreadPoolExecutor&lt;/code&gt; 也保留了一些基本的统计数据，比如当前线程池完成的任务数目等。&lt;/p&gt;

&lt;h2 id=&quot;jdkthreadpoolexecutor&quot;&gt; 2.ThreadPoolExecutor 原理探究&lt;/h2&gt;
&lt;h3&gt;&lt;strong&gt;类图如下：&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1202638/201905/1202638-20190526200622669-1856612537.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;

&lt;p&gt;如上类图，Executors 其实是个工具类，里面提供了好多静态方法，根据用户选择返回不同的线程池实例。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ThreadPoolExecutor&lt;/code&gt; 继承了 &lt;code&gt;AbstractExecutorService&lt;/code&gt;，成员变量 ctl 是个 Integer 的原子变量用来记录线程池状态 和 线程池中线程个数，类似于 &lt;code&gt;ReentrantReadWriteLock&lt;/code&gt; 使用一个变量存放两种信息。&lt;/p&gt;
&lt;p&gt;这里假设 Integer 类型是 32 位二进制标示，则其中高 3 位用来表示线程池状态，后面 29 位用来记录线程池线程个数。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用来标记线程池状态（高3位），线程个数（低29位）
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;默认是RUNNING状态，线程个数为0&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; AtomicInteger ctl = &lt;span&gt;new&lt;/span&gt; AtomicInteger(ctlOf(RUNNING, 0&lt;span&gt;));

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;线程个数掩码位数，并不是所有平台int类型是32位，所以准确说是具体平台下Integer的二进制位数-3后的剩余位数才是线程的个数，&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; COUNT_BITS = Integer.SIZE - 3&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;线程最大个数(低29位)00011111111111111111111111111111&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; CAPACITY   = (1 &amp;lt;&amp;lt; COUNT_BITS) - 1;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;-1&quot;&gt;&lt;strong&gt;线程池状态：&lt;/strong&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;（高3位）：11100000000000000000000000000000&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; RUNNING    = -1 &amp;lt;&amp;lt;&lt;span&gt; COUNT_BITS;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;（高3位）：00000000000000000000000000000000&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; SHUTDOWN   =  0 &amp;lt;&amp;lt;&lt;span&gt; COUNT_BITS;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;（高3位）：00100000000000000000000000000000&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; STOP       =  1 &amp;lt;&amp;lt;&lt;span&gt; COUNT_BITS;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;（高3位）：01000000000000000000000000000000&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; TIDYING    =  2 &amp;lt;&amp;lt;&lt;span&gt; COUNT_BITS;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;（高3位）：01100000000000000000000000000000&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; TERMINATED =  3 &amp;lt;&amp;lt;&lt;span&gt; COUNT_BITS;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取高三位 运行状态&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; runStateOf(&lt;span&gt;int&lt;/span&gt; c)     { &lt;span&gt;return&lt;/span&gt; c &amp;amp; ~&lt;span&gt;CAPACITY; }

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取低29位 线程个数&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; workerCountOf(&lt;span&gt;int&lt;/span&gt; c)  { &lt;span&gt;return&lt;/span&gt; c &amp;amp;&lt;span&gt; CAPACITY; }

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;计算ctl新值，线程状态 与 线程个数&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; ctlOf(&lt;span&gt;int&lt;/span&gt; rs, &lt;span&gt;int&lt;/span&gt; wc) { &lt;span&gt;return&lt;/span&gt; rs | wc; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;-2&quot;&gt;线程池状态含义：&lt;/h3&gt;
&lt;ul readability=&quot;3&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;RUNNING：接受新任务并且处理阻塞队列里的任务；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;SHUTDOWN：拒绝新任务但是处理阻塞队列里的任务；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;STOP：拒绝新任务并且抛弃阻塞队列里的任务，同时会中断正在处理的任务；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;TIDYING：所有任务都执行完（包含阻塞队列里面任务）当前线程池活动线程为 0，将要调用 &lt;code&gt;terminated&lt;/code&gt; 方法；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;TERMINATED：终止状态，terminated方法调用完成以后的状态。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;-3&quot;&gt;线程池状态转换：&lt;/h3&gt;
&lt;p&gt;       1.RUNNING -&amp;gt; SHUTDOWN：显式调用 &lt;code&gt;shutdown()&lt;/code&gt; 方法，或者隐式调用了 &lt;code&gt;finalize()&lt;/code&gt;，它里面调用了 &lt;code&gt;shutdown()&lt;/code&gt; 方法。&lt;/p&gt;
&lt;p&gt;       2.RUNNING or SHUTDOWN -&amp;gt; STOP：显式调用 &lt;code&gt;shutdownNow()&lt;/code&gt; 方法时候。&lt;/p&gt;
&lt;p&gt;       3.SHUTDOWN -&amp;gt; TIDYING：当线程池和任务队列都为空的时候。&lt;/p&gt;
&lt;p&gt;       4.STOP -&amp;gt; TIDYING：当线程池为空的时候。&lt;/p&gt;
&lt;p&gt;       5.TIDYING -&amp;gt; TERMINATED：当 &lt;code&gt;terminated() hook&lt;/code&gt; 方法执行完成时候。&lt;/p&gt;

&lt;h3&gt;线程池参数：&lt;/h3&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;corePoolSize：线程池核心线程个数；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;workQueue：用于保存等待执行的任务的阻塞队列；比如基于数组的有界 &lt;code&gt;ArrayBlockingQueue&lt;/code&gt;，基于链表的无界 &lt;code&gt;LinkedBlockingQueue&lt;/code&gt;，最多只有一个元素的同步队列 &lt;code&gt;SynchronousQueue&lt;/code&gt;，优先级队列 &lt;code&gt;PriorityBlockingQueue&lt;/code&gt; 等。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;ul readability=&quot;4&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;maximunPoolSize：线程池最大线程数量。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;ThreadFactory：创建线程的工厂。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;RejectedExecutionHandler：饱和策略，当队列满了并且线程个数达到 &lt;code&gt;maximunPoolSize&lt;/code&gt; 后采取的策略，比如 &lt;code&gt;AbortPolicy&lt;/code&gt; （抛出异常），&lt;code&gt;CallerRunsPolicy&lt;/code&gt;（使用调用者所在线程来运行任务），&lt;code&gt;DiscardOldestPolicy&lt;/code&gt;（调用 poll 丢弃一个任务，执行当前任务），&lt;code&gt;DiscardPolicy&lt;/code&gt;（默默丢弃，不抛出异常）。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;keeyAliveTime：存活时间。如果当前线程池中的线程数量比核心线程数量要多，并且是闲置状态的话，这些闲置的线程能存活的最大时间。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;TimeUnit，存活时间的时间单位。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;线程池类型：&lt;/h3&gt;
&lt;p&gt;      1.newFixedThreadPool：创建一个核心线程个数和最大线程个数都为 nThreads 的线程池，并且阻塞队列长度为 &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt;，&lt;code&gt;keeyAliveTime=0&lt;/code&gt; 说明只要线程个数比核心线程个数多并且当前空闲则回收。代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt; public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ExecutorService newFixedThreadPool(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; nThreads) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ThreadPoolExecutor(nThreads, nThreads,
                                      &lt;/span&gt;0L&lt;span&gt;, TimeUnit.MILLISECONDS,
                                      &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; LinkedBlockingQueue&amp;lt;Runnable&amp;gt;&lt;span&gt;());
 }
 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用自定义线程创建工厂&lt;/span&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ExecutorService newFixedThreadPool(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; nThreads, ThreadFactory threadFactory) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ThreadPoolExecutor(nThreads, nThreads,
                                      &lt;/span&gt;0L&lt;span&gt;, TimeUnit.MILLISECONDS,
                                      &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; LinkedBlockingQueue&amp;lt;Runnable&amp;gt;&lt;span&gt;(),
                                      threadFactory);
 }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;2.newSingleThreadExecutor：创建一个核心线程个数和最大线程个数都为1的线程池，并且阻塞队列长度为 &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt;，&lt;code&gt;keeyAliveTime=0&lt;/code&gt; 说明只要线程个数比核心线程个数多并且当前空闲则回收。代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; ExecutorService newSingleThreadExecutor() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FinalizableDelegatedExecutorService
            (&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; ThreadPoolExecutor(1, 1&lt;span&gt;,
                                    &lt;/span&gt;0L&lt;span&gt;, TimeUnit.MILLISECONDS,
                                    &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; LinkedBlockingQueue&amp;lt;Runnable&amp;gt;&lt;span&gt;()));
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用自己的线程工厂&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FinalizableDelegatedExecutorService
            (&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; ThreadPoolExecutor(1, 1&lt;span&gt;,
                                    &lt;/span&gt;0L&lt;span&gt;, TimeUnit.MILLISECONDS,
                                    &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; LinkedBlockingQueue&amp;lt;Runnable&amp;gt;&lt;span&gt;(),
                                    threadFactory));
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;3.newCachedThreadPool：创建一个按需创建线程的线程池，初始线程个数为 0，最多线程个数为 &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt;，并且阻塞队列为同步队列，&lt;code&gt;keeyAliveTime=60&lt;/code&gt; 说明只要当前线程 60s 内空闲则回收。这个特殊在于加入到同步队列的任务会被马上被执行，同步队列里面最多只有一个任务。代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; ExecutorService newCachedThreadPool() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ThreadPoolExecutor(0&lt;span&gt;, Integer.MAX_VALUE,
                                      &lt;/span&gt;60L&lt;span&gt;, TimeUnit.SECONDS,
                                      &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; SynchronousQueue&amp;lt;Runnable&amp;gt;&lt;span&gt;());
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用自定义的线程工厂&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; ExecutorService newCachedThreadPool(ThreadFactory threadFactory) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ThreadPoolExecutor(0&lt;span&gt;, Integer.MAX_VALUE,
                                      &lt;/span&gt;60L&lt;span&gt;, TimeUnit.SECONDS,
                                      &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; SynchronousQueue&amp;lt;Runnable&amp;gt;&lt;span&gt;(),
                                      threadFactory);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如类图，其中 mainLock 是独占锁，用来控制新增 Worker 线程时候的原子性，termination 是该锁对应的条件队列，在线程调用 &lt;code&gt;awaitTermination&lt;/code&gt; 时候用来存放阻塞的线程。&lt;/p&gt;
&lt;p&gt;Worker 继承 AQS 和 Runnable 接口，是具体承载任务的对象，Worker 继承了 AQS，自己实现了简单不可重入独占锁，其中 &lt;code&gt;status=0&lt;/code&gt; 标示锁未被获取状态，&lt;code&gt;state=1&lt;/code&gt; 标示锁已经被获取的状态，&lt;code&gt;state=-1&lt;/code&gt; 是创建 Worker 时候默认的状态，创建时候状态设置为 -1 是为了避免在该线程在运行 &lt;code&gt;runWorker()&lt;/code&gt; 方法前被中断，下面会具体讲解到。其中变量 firstTask 记录该工作线程执行的第一个任务，thread 是具体执行任务的线程。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;DefaultThreadFactory&lt;/code&gt; 是线程工厂，&lt;code&gt;newThread&lt;/code&gt; 方法是对线程的一个修饰，其中 &lt;code&gt;poolNumber&lt;/code&gt; 是个静态的原子变量，用来统计线程工厂的个数，&lt;code&gt;threadNumber&lt;/code&gt; 用来记录每个线程工厂创建了多少线程，这两个值也作为线程池和线程的名称的一部分。&lt;/p&gt;

&lt;h2&gt;3.源码分析&lt;/h2&gt;
&lt;p id=&quot;31publicvoidexecuterunnablecommand&quot;&gt;1 public void execute(Runnable command)：&lt;code&gt;execute&lt;/code&gt; 方法是提交任务 command 到线程池进行执行，用户线程提交任务到线程池的模型图如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1202638/201905/1202638-20190526201459529-1620612083.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图可知 &lt;code&gt;ThreadPoolExecutor&lt;/code&gt; 的实现实际是一个生产消费模型，其中当用户添加任务到线程池时候相当于生产者生产元素，workers 线程工作集中的线程直接执行任务或者从任务队列里面获取任务相当于消费者消费元素。用户线程提交任务的 &lt;code&gt;execute&lt;/code&gt; 方法具体代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; execute(Runnable command) {

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;(1) 如果任务为null，则抛出NPE异常&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (command == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NullPointerException();

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;（2）获取当前线程池的状态+线程个数变量的组合值&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; c =&lt;span&gt; ctl.get();

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;（3）当前线程池线程个数是否小于corePoolSize,小于则开启新线程运行&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (workerCountOf(c) &amp;lt;&lt;span&gt; corePoolSize) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (addWorker(command, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;))
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        c &lt;/span&gt;=&lt;span&gt; ctl.get();
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;（4）如果线程池处于RUNNING状态，则添加任务到阻塞队列&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (isRunning(c) &amp;amp;&amp;amp;&lt;span&gt; workQueue.offer(command)) {

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;（4.1）二次检查&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; recheck =&lt;span&gt; ctl.get();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;（4.2）如果当前线程池状态不是RUNNING则从队列删除任务，并执行拒绝策略&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (! isRunning(recheck) &amp;amp;&amp;amp;&lt;span&gt; remove(command))
            reject(command);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;（4.3）否者如果当前线程池线程空，则添加一个线程&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (workerCountOf(recheck) == 0&lt;span&gt;)
            addWorker(&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;（5）如果队列满了，则新增线程，新增失败则执行拒绝策略&lt;/span&gt;
    &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (!addWorker(command, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;))
        reject(command);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;1.代码（3）判断如果当前线程池线程个数小于 corePoolSize，如上图会在 workers 里面新增一个核心线程（core 线程）执行该任务。&lt;/p&gt;
&lt;p&gt;2.如果当前线程池线程个数大于等于 corePoolSize 执行代码（4），如果当前线程池处于 RUNNING 状态则添加当前任务到任务队列，这里需要判断线程池状态是因为有可能线程池已经处于非 RUNNING 状态，而非 RUNNING 状态下是抛弃新任务的。&lt;/p&gt;
&lt;p&gt;3.如果任务添加任务队列成功，则代码（4.2）对线程池状态进行二次校验，这是因为添加任务到任务队列后，执行代码（4.2）前有可能线程池的状态已经变化了，这里进行二次校验，如果当前线程池状态不是 RUNNING 了则把任务从任务队列移除，移除后执行拒绝策略；如果二次校验通过，则执行代码（4.3）重新判断当前线程池里面是否还有线程，如果没有则新增一个线程。&lt;/p&gt;
&lt;p&gt;4.如果代码（4）添加任务失败，则说明任务队列满了，则执行代码（5）尝试新开启线程（如上图 thread 3 和 thread 4）来执行该任务，如果当前线程池线程个数 &amp;gt; &lt;code&gt;maximumPoolSize&lt;/code&gt; 则执行拒绝策略。&lt;/p&gt;

&lt;p&gt;接下来看新增线程的 &lt;code&gt;addWorkder&lt;/code&gt; 方法的源码，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; addWorker(Runnable firstTask, &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; core) {
    retry:
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (;;) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; c =&lt;span&gt; ctl.get();
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; rs =&lt;span&gt; runStateOf(c);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;（6） 检查队列是否只在必要时为空&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (rs &amp;gt;= SHUTDOWN &amp;amp;&amp;amp;
            ! (rs == SHUTDOWN &amp;amp;&amp;amp;&lt;span&gt;
               firstTask &lt;/span&gt;== &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;
               !&lt;span&gt; workQueue.isEmpty()))
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;（7）循环cas增加线程个数&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (;;) {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; wc =&lt;span&gt; workerCountOf(c);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;（7.1）如果线程个数超限则返回false&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (wc &amp;gt;= CAPACITY ||&lt;span&gt;
                wc &lt;/span&gt;&amp;gt;= (core ?&lt;span&gt; corePoolSize : maximumPoolSize))
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;（7.2）cas增加线程个数，同时只有一个线程成功&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (compareAndIncrementWorkerCount(c))
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt; retry;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;（7.3）cas失败了，则看线程池状态是否变化了，变化则跳到外层循环重试重新获取线程池状态，否者内层循环重新cas。&lt;/span&gt;
            c = ctl.get();  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Re-read ctl&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (runStateOf(c) !=&lt;span&gt; rs)
                &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt; retry;
        }
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;（8）到这里说明cas成功了&lt;/span&gt;
    &lt;span&gt;boolean&lt;/span&gt; workerStarted = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; workerAdded = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    Worker w &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;（8.1）创建worker&lt;/span&gt;
        &lt;span&gt;final&lt;/span&gt; ReentrantLock mainLock = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.mainLock;
        w &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Worker(firstTask);
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Thread t =&lt;span&gt; w.thread;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (t != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;（8.2）加独占锁，为了workers同步，因为可能多个线程调用了线程池的execute方法。&lt;/span&gt;
&lt;span&gt;            mainLock.lock();
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;（8.3）重新检查线程池状态，为了避免在获取锁前调用了shutdown接口&lt;/span&gt;
                &lt;span&gt;int&lt;/span&gt; c =&lt;span&gt; ctl.get();
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; rs =&lt;span&gt; runStateOf(c);

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (rs &amp;lt; SHUTDOWN ||&lt;span&gt;
                    (rs &lt;/span&gt;== SHUTDOWN &amp;amp;&amp;amp; firstTask == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)) {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (t.isAlive()) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; precheck that t is startable&lt;/span&gt;
                        &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalThreadStateException();
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;（8.4）添加任务&lt;/span&gt;
&lt;span&gt;                    workers.add(w);
                    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; s =&lt;span&gt; workers.size();
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (s &amp;gt;&lt;span&gt; largestPoolSize)
                        largestPoolSize &lt;/span&gt;=&lt;span&gt; s;
                    workerAdded &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                }
            } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
                mainLock.unlock();
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;（8.5）添加成功则启动任务&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (workerAdded) {
                t.start();
                workerStarted &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            }
        }
    } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt; workerStarted)
            addWorkerFailed(w);
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; workerStarted;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如上代码主要分两部分，第一部分的双重循环目的是通过 cas 操作增加线程池线程数，第二部分主要是并发安全的把任务添加到 workers 里面，并且启动任务执行。&lt;/p&gt;
&lt;p&gt;先看第一部分的代码（6)，如下所示:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
rs &amp;gt;= SHUTDOWN &amp;amp;&amp;amp;
               ! (rs == SHUTDOWN &amp;amp;&amp;amp;&lt;span&gt;
                   firstTask &lt;/span&gt;== &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;
                   ! workQueue.isEmpty())
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样看不好理解，我们展开！运算符后，相当于：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
s &amp;gt;= SHUTDOWN &amp;amp;&amp;amp;&lt;span&gt;
                (rs &lt;/span&gt;!= SHUTDOWN ||&lt;span&gt;//&lt;/span&gt;&lt;span&gt;(1)&lt;/span&gt;
              firstTask != &lt;span&gt;null&lt;/span&gt; ||&lt;span&gt;//&lt;/span&gt;&lt;span&gt;(2)&lt;/span&gt;
              workQueue.isEmpty())&lt;span&gt;//&lt;/span&gt;&lt;span&gt;(3)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如上代码，也就是说代码（6）在下面几种情况下会返回 false：&lt;/p&gt;
&lt;p&gt;    1.当前线程池状态为 STOP，TIDYING，TERMINATED；&lt;/p&gt;
&lt;p&gt;    2.当前线程池状态为 SHUTDOWN 并且已经有了第一个任务；&lt;/p&gt;
&lt;p&gt;    3.当前线程池状态为 SHUTDOWN 并且任务队列为空。&lt;/p&gt;

&lt;p&gt;回到上面看新增线程的 &lt;code&gt;addWorkder&lt;/code&gt; 方法，发现内层循环作用是使用 cas 增加线程，代码（7.1）如果线程个数超限则返回 false，否者执行代码（7.2）执行 CAS 操作设置线程个数，cas 成功则退出双循环，CAS 失败则执行代码（7.3）看当前线程池的状态是否变化了，如果变了，则重新进入外层循环重新获取线程池状态，否者进入内层循环继续进行 cas 尝试。&lt;/p&gt;
&lt;p&gt;执行到第二部分的代码（8）说明使用 CAS 成功的增加了线程个数，但是现在任务还没开始执行，这里使用全局的独占锁来控制把新增的 Worker 添加到工作集 workers。代码（8.1）创建了一个工作线程 Worker。&lt;/p&gt;
&lt;p&gt;代码（8.2）获取了独占锁，代码（8.3）重新检查线程池状态，这是为了避免在获取锁前其他线程调用了 shutdown 关闭了线程池，如果线程池已经被关闭，则释放锁，新增线程失败，否者执行代码（8.4）添加工作线程到线程工作集，然后释放锁，代码（8.5）如果判断如果工作线程新增成功，则启动工作线程。&lt;/p&gt;

&lt;p id=&quot;32worker&quot;&gt;3.2 工作线程 Worker 的执行&lt;/p&gt;
&lt;p&gt;当用户线程提交任务到线程池后，具体是使用 worker 来执行的，先看下 Worker 的构造函数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Worker(Runnable firstTask) {
    setState(&lt;/span&gt;-1); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在调用runWorker前禁止中断&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;.firstTask =&lt;span&gt; firstTask;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.thread = getThreadFactory().newThread(&lt;span&gt;this&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个线程&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如上代码构造函数内首先设置 Worker 的状态为 -1，是为了避免当前 worker 在调用 &lt;code&gt;runWorker&lt;/code&gt; 方法前被中断（当其它线程调用了线程池的 shutdownNow 时候，如果 worker 状态 &amp;gt;= 0 则会中断该线程）。这里设置了线程的状态为 -1，所以该线程就不会被中断了。如下代码运行 runWorker 的代码（9）时候会调用 unlock 方法，该方法把 status 变为了 0，所以这时候调用 shutdownNow 会中断 worker 线程了。&lt;/p&gt;

&lt;p&gt;接着我们再看看runWorker方法，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; runWorker(Worker w) {
        Thread wt &lt;/span&gt;=&lt;span&gt; Thread.currentThread();
        Runnable task &lt;/span&gt;=&lt;span&gt; w.firstTask;
        w.firstTask &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        w.unlock(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;(9)status设置为0，允许中断&lt;/span&gt;
        &lt;span&gt;boolean&lt;/span&gt; completedAbruptly = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
           &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;(10)&lt;/span&gt;
            &lt;span&gt;while&lt;/span&gt; (task != &lt;span&gt;null&lt;/span&gt; || (task = getTask()) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {

                 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;(10.1)&lt;/span&gt;
&lt;span&gt;                w.lock();
               ...
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;(10.2)任务执行前干一些事情&lt;/span&gt;
&lt;span&gt;                    beforeExecute(wt, task);
                    Throwable thrown &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                        task.run();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;(10.3)执行任务&lt;/span&gt;
                    } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (RuntimeException x) {
                        thrown &lt;/span&gt;= x; &lt;span&gt;throw&lt;/span&gt;&lt;span&gt; x;
                    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Error x) {
                        thrown &lt;/span&gt;= x; &lt;span&gt;throw&lt;/span&gt;&lt;span&gt; x;
                    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable x) {
                        thrown &lt;/span&gt;= x; &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Error(x);
                    } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;(10.4)任务执行完毕后干一些事情&lt;/span&gt;
&lt;span&gt;                        afterExecute(task, thrown);
                    }
                } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
                    task &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;(10.5)统计当前worker完成了多少个任务&lt;/span&gt;
                    w.completedTasks++&lt;span&gt;;
                    w.unlock();
                }
            }
            completedAbruptly &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;(11)执行清工作&lt;/span&gt;
&lt;span&gt;            processWorkerExit(w, completedAbruptly);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如上代码（10）如果当前 task==null 或者调用 getTask 从任务队列获取的任务返回 null，则跳转到代码（11）执行。如果 task 不为 null 则执行代码（10.1）获取工作线程内部持有的独占锁，然后执行扩展接口代码（10.2）在具体任务执行前做一些事情，代码（10.3）具体执行任务，代码（10.4）在任务执行完毕后做一些事情，代码（10.5）统计当前 worker 完成了多少个任务，并释放锁。&lt;/p&gt;
&lt;p&gt;这里在执行具体任务期间加锁，是为了避免任务运行期间，其他线程调用了 shutdown 或者 shutdownNow 命令关闭了线程池。&lt;/p&gt;

&lt;p&gt;其中代码（11）执行清理任务，其代码如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; processWorkerExit(Worker w, &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; completedAbruptly) {
     ...代码太长，这里就不展示了

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;(11.1)统计整个线程池完成的任务个数,并从工作集里面删除当前woker&lt;/span&gt;
    &lt;span&gt;final&lt;/span&gt; ReentrantLock mainLock = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.mainLock;
    mainLock.lock();
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
        completedTaskCount &lt;/span&gt;+=&lt;span&gt; w.completedTasks;
        workers.remove(w);
    } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
        mainLock.unlock();
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;(11.2)尝试设置线程池状态为TERMINATED，如果当前是shutdonw状态并且工作队列为空
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;或者当前是stop状态当前线程池里面没有活动线程&lt;/span&gt;
&lt;span&gt;    tryTerminate();

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;(11.3)如果当前线程个数小于核心个数，则增加&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; c =&lt;span&gt; ctl.get();
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (runStateLessThan(c, STOP)) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;completedAbruptly) {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; min = allowCoreThreadTimeOut ? 0&lt;span&gt; : corePoolSize;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (min == 0 &amp;amp;&amp;amp; !&lt;span&gt; workQueue.isEmpty())
                min &lt;/span&gt;= 1&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (workerCountOf(c) &amp;gt;=&lt;span&gt; min)
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; replacement not needed&lt;/span&gt;
&lt;span&gt;        }
        addWorker(&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如上代码（11.1）统计线程池完成任务个数，可知在统计前加了全局锁，把当前工作线程中完成的任务累加到全局计数器，然后从工作集中删除当前 worker。&lt;/p&gt;
&lt;p&gt;代码（11.2）判断如果当前线程池状态是 shutdonw 状态并且工作队列为空或者当前是 stop 状态当前线程池里面没有活动线程则设置线程池状态为 TERMINATED，如果设置为了 TERMINATED 状态还需要调用条件变量 termination 的 &lt;code&gt;signalAll()&lt;/code&gt; 方法激活所有因为调用线程池的 &lt;code&gt;awaitTermination&lt;/code&gt; 方法而被阻塞的线程&lt;/p&gt;
&lt;p&gt;代码（11.3）则判断当前线程里面线程个数是否小于核心线程个数，如果是则新增一个线程。&lt;/p&gt;

&lt;p id=&quot;33shutdown&quot;&gt;3.3 shutdown 操作：调用 shutdown 后，线程池就不会在接受新的任务了，但是工作队列里面的任务还是要执行的，该方法立刻返回的，并不等待队列任务完成在返回。代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; shutdown() {
    &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; ReentrantLock mainLock = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.mainLock;
    mainLock.lock();
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;(12)权限检查&lt;/span&gt;
&lt;span&gt;        checkShutdownAccess();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;(13)设置当前线程池状态为SHUTDOWN，如果已经是SHUTDOWN则直接返回&lt;/span&gt;
&lt;span&gt;        advanceRunState(SHUTDOWN);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;(14)设置中断标志&lt;/span&gt;
&lt;span&gt;        interruptIdleWorkers();
        onShutdown(); 
    } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
        mainLock.unlock();
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;(15)尝试状态变为TERMINATED&lt;/span&gt;
&lt;span&gt;    tryTerminate();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如上代码（12）检查如果设置了安全管理器，则看当前调用 shutdown 命令的线程是否有关闭线程的权限，如果有权限则还要看调用线程是否有中断工作线程的权限，如果没有权限则抛出 &lt;code&gt;SecurityException&lt;/code&gt; 或者 &lt;code&gt;NullPointerException&lt;/code&gt; 异常。&lt;/p&gt;
&lt;p&gt;其中代码（13）内容如下，如果当前状态 &amp;gt;= SHUTDOWN 则直接返回，否者设置当前状态为 SHUTDOWN：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; advanceRunState(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; targetState) {
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (;;) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; c =&lt;span&gt; ctl.get();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (runStateAtLeast(c, targetState) ||&lt;span&gt;
            ctl.compareAndSet(c, ctlOf(targetState, workerCountOf(c))))
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;代码（14）内容如下，设置所有空闲线程的中断标志，这里首先加了全局锁，同时只有一个线程可以调用 shutdown 设置中断标志，然后尝试获取 worker 自己的锁，获取成功则设置中断标识，由于正在执行的任务已经获取了锁，所以正在执行的任务没有被中断。这里中断的是阻塞到 &lt;code&gt;getTask()&lt;/code&gt; 方法，企图从队列里面获取任务的线程，也就是空闲线程。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; interruptIdleWorkers(&lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; onlyOne) {
    &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; ReentrantLock mainLock = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.mainLock;
    mainLock.lock();
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Worker w : workers) {
            Thread t &lt;/span&gt;=&lt;span&gt; w.thread;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果工作线程没有被中断，并且没有正在运行则设置设置中断&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (!t.isInterrupted() &amp;amp;&amp;amp;&lt;span&gt; w.tryLock()) {
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    t.interrupt();
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (SecurityException ignore) {
                } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
                    w.unlock();
                }
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (onlyOne)
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        }
    } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
        mainLock.unlock();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;代码（15）判断如果当前线程池状态是 shutdonw 状态并且工作队列为空或者当前是 stop 状态当前线程池里面没有活动线程则设置线程池状态为 TERMINATED，如果设置为了 TERMINATED 状态还需要调用条件变量 termination 的 &lt;code&gt;signalAll()&lt;/code&gt;方法激活所有因为调用线程池的 awaitTermination 方法而被阻塞的线程&lt;/p&gt;

&lt;p id=&quot;34shutdownnow&quot;&gt;3.4 shutdownNow 操作&lt;/p&gt;
&lt;p&gt;调用 shutdownNow 后，线程池就不会在接受新的任务了，并且丢弃工作队列里面里面的任务，正在执行的任务会被中断，该方法是立刻返回的，并不等待激活的任务执行完成在返回。返回值为这时候队列里面被丢弃的任务列表。代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; List&amp;lt;Runnable&amp;gt;&lt;span&gt; shutdownNow() {


    List&lt;/span&gt;&amp;lt;Runnable&amp;gt;&lt;span&gt; tasks;
    &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; ReentrantLock mainLock = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.mainLock;
    mainLock.lock();
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
        checkShutdownAccess();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;（16)权限检查&lt;/span&gt;
        advanceRunState(STOP);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;(17) 设置线程池状态为stop&lt;/span&gt;
        interruptWorkers();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;(18)中断所有线程&lt;/span&gt;
        tasks = drainQueue();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;（19）移动队列任务到tasks&lt;/span&gt;
    } &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
        mainLock.unlock();
    }
    tryTerminate();
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; tasks;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如上代码首先调用代码（16）检查权限，然后调用代码（17）设置当前线程池状态为 stop，然后执行代码（18）中断所有的工作线程，这里需要注意的是中断所有的线程，包含空闲线程和正在执行任务的线程，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;   private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; interruptWorkers() {
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; ReentrantLock mainLock = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.mainLock;
        mainLock.lock();
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Worker w : workers)
                w.interruptIfStarted();
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            mainLock.unlock();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后代码（19）移动当前任务队列里面任务到 tasks 列表。&lt;/p&gt;
&lt;p id=&quot;34awaittermination&quot;&gt;3.4 awaitTermination 操作&lt;/p&gt;
&lt;p&gt;当线程调用 awaitTermination 方法后，当前线程会被阻塞，知道线程池状态变为了 TERMINATED 才返回，或者等待时间超时才返回，整个过程独占锁,代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; awaitTermination(&lt;span&gt;long&lt;/span&gt;&lt;span&gt; timeout, TimeUnit unit)
        &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {
        &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; nanos =&lt;span&gt; unit.toNanos(timeout);
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; ReentrantLock mainLock = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.mainLock;
        mainLock.lock();
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (;;) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (runStateAtLeast(ctl.get(), TERMINATED))
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (nanos &amp;lt;= 0&lt;span&gt;)
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                nanos &lt;/span&gt;=&lt;span&gt; termination.awaitNanos(nanos);
            }
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            mainLock.unlock();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如上代码首先获取了独占锁，然后无限循环内部首先判断当前线程池状态是否至少是 TERMINATED 状态，如果是则直接返回。否者说明当前线程池里面还有线程在执行，则看设置的超时时间 nanos 是否小于 0，小于 0 则说明不需要等待，则直接返回；如果大于0则调用条件变量 termination 的 awaitNanos 方法等待 nanos 时间，期望在这段时间内线程池状态内变为 TERMINATED 状态。&lt;/p&gt;
&lt;p&gt;在讲解 shutdown 方法时候提到当线程池状态变为 TERMINATED 后，会调用 &lt;code&gt;termination.signalAll()&lt;/code&gt; 用来激活调用条件变量 termination 的 await 系列方法被阻塞的所有线程，所以如果在调用了 &lt;code&gt;awaitTermination&lt;/code&gt; 之后调用了 &lt;code&gt;shutdown&lt;/code&gt; 方法，并且 shutdown 内部设置线程池状态为 &lt;code&gt;TERMINATED&lt;/code&gt; 了，则 &lt;code&gt;termination.awaitNanos&lt;/code&gt; 方法会返回。&lt;/p&gt;
&lt;p&gt;另外在工作线程 Worker 的 runWorker 方法内当工作线程运行结束后，会调用 processWorkerExit 方法，processWorkerExit 方法内部也会调用 tryTerminate 方法测试当前是否应该把线程池设置为 TERMINATED 状态，如果是，则也会调用 &lt;code&gt;termination.signalAll()&lt;/code&gt; 用来激活调用线程池的 &lt;code&gt;awaitTermination&lt;/code&gt; 方法而被阻塞的线程&lt;/p&gt;
&lt;p&gt;另外当等待时间超时后，&lt;code&gt;termination.awaitNanos&lt;/code&gt; 也会返回，这时候会重新检查当前线程池状态是否为 TERMINATED，如果是则直接返回，否者继续阻塞挂起自己。&lt;/p&gt;
&lt;h2 id=&quot;-5&quot;&gt;4、使用线程池需要注意的地方&lt;/h2&gt;
&lt;h3 id=&quot;41&quot;&gt;4.1 创建线程池时候要指定与业务相关的名字，以便于追溯问题&lt;/h3&gt;
&lt;p&gt;日常开发中当一个应用中需要创建多个线程池时候最好给线程池根据业务类型设置具体的名字，以便在出现问题时候方便进行定位，下面就通过实例来说明不设置时候为何难以定位问题，以及如何进行设置。&lt;/p&gt;
&lt;p&gt;下面通过简单的代码来说明不指定线程池名称为何难定位问题，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.hjc;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.LinkedBlockingQueue;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.ThreadPoolExecutor;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.TimeUnit;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * Created by cong on 2019/5/26.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ThreadPoolExecutorTest {
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; ThreadPoolExecutor executorOne = &lt;span&gt;new&lt;/span&gt; ThreadPoolExecutor(5, 5, 1, TimeUnit.MINUTES, &lt;span&gt;new&lt;/span&gt; LinkedBlockingQueue&amp;lt;&amp;gt;&lt;span&gt;());
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; ThreadPoolExecutor executorTwo = &lt;span&gt;new&lt;/span&gt; ThreadPoolExecutor(5, 5, 1, TimeUnit.MINUTES, &lt;span&gt;new&lt;/span&gt; LinkedBlockingQueue&amp;lt;&amp;gt;&lt;span&gt;());

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;接受用户链接模块&lt;/span&gt;
        executorOne.execute(&lt;span&gt;new&lt;/span&gt;&lt;span&gt;  Runnable() {
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                System.out.println(&lt;/span&gt;&quot;接受用户链接线程&quot;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NullPointerException();
            }
        });
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;具体处理用户请求模块&lt;/span&gt;
        executorTwo.execute(&lt;span&gt;new&lt;/span&gt;&lt;span&gt;  Runnable() {
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                System.out.println(&lt;/span&gt;&quot;具体处理业务请求线程&quot;&lt;span&gt;);
            }
        });

        executorOne.shutdown();
        executorTwo.shutdown();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行代码输出如下结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1202638/201905/1202638-20190526203821072-1550866983.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;同理我们并不知道是那个模块的线程池抛出了这个异常，那么我们看下这个 &lt;code&gt;pool-1-thread-1&lt;/code&gt; 是如何来的。其实是使用了线程池默认的 ThreadFactory，翻看线程池创建的源码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; ThreadPoolExecutor(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; corePoolSize,
                              &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; maximumPoolSize,
                              &lt;/span&gt;&lt;span&gt;long&lt;/span&gt;&lt;span&gt; keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue&lt;/span&gt;&amp;lt;Runnable&amp;gt;&lt;span&gt; workQueue) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
             Executors.defaultThreadFactory(), defaultHandler);
    }

   &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; ThreadFactory defaultThreadFactory() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DefaultThreadFactory();
   }

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; DefaultThreadFactory &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; ThreadFactory {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;(1)&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; AtomicInteger poolNumber = &lt;span&gt;new&lt;/span&gt; AtomicInteger(1&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; ThreadGroup group;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;(2)&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; AtomicInteger threadNumber = &lt;span&gt;new&lt;/span&gt; AtomicInteger(1&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;(3)&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; String namePrefix;

        DefaultThreadFactory() {
            SecurityManager s &lt;/span&gt;=&lt;span&gt; System.getSecurityManager();
            group &lt;/span&gt;= (s != &lt;span&gt;null&lt;/span&gt;) ?&lt;span&gt; s.getThreadGroup() :
                                  Thread.currentThread().getThreadGroup();
            namePrefix &lt;/span&gt;= &quot;pool-&quot; +&lt;span&gt;
                          poolNumber.getAndIncrement() &lt;/span&gt;+
                         &quot;-thread-&quot;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Thread newThread(Runnable r) {
           &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;(4)&lt;/span&gt;
            Thread t = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(group, r,
                                  namePrefix &lt;/span&gt;+&lt;span&gt; threadNumber.getAndIncrement(),
                                  &lt;/span&gt;0&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (t.isDaemon())
                t.setDaemon(&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (t.getPriority() !=&lt;span&gt; Thread.NORM_PRIORITY)
                t.setPriority(Thread.NORM_PRIORITY);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; t;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如上代码 &lt;code&gt;DefaultThreadFactory&lt;/code&gt; 的实现可知:&lt;/p&gt;
&lt;p&gt;     1.代码（1）poolNumber 是 static 的原子变量用来记录当前线程池的编号，它是应用级别的，所有线程池公用一个，比如创建第一个线程池时候线程池编号为1，创建第二个线程池时候线程池的编号为2，这里 &lt;code&gt;pool-1-thread-1&lt;/code&gt; 里面的 pool-1 中的 1 就是这个值。&lt;/p&gt;
&lt;p&gt;     2.代码（2）threadNumber 是线程池级别的，每个线程池有一个该变量用来记录该线程池中线程的编号，这里 &lt;code&gt;pool-1-thread-1&lt;/code&gt; 里面的 thread - 1 中的 1 就是这个值。&lt;/p&gt;
&lt;p&gt;     3.代码（3）namePrefix是线程池中线程的前缀，默认固定为pool。&lt;/p&gt;
&lt;p&gt;     4.代码（4）具体创建线程，可知线程的名称使用 &lt;code&gt;namePrefix + threadNumber.getAndIncrement()&lt;/code&gt; 拼接的。&lt;/p&gt;

&lt;p&gt;从上知道我们只需对 &lt;code&gt;DefaultThreadFactory&lt;/code&gt; 的代码中 namePrefix 的初始化做手脚，当需要创建线程池是传入与业务相关的 namePrefix 名称就可以了，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.hjc;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.ThreadFactory;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.atomic.AtomicInteger;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * Created by cong on 2019/5/26.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 命名线程工厂&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; HjcThreadFactory &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; ThreadFactory {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; AtomicInteger poolNumber = &lt;span&gt;new&lt;/span&gt; AtomicInteger(1&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; ThreadGroup group;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; AtomicInteger threadNumber = &lt;span&gt;new&lt;/span&gt; AtomicInteger(1&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; String namePrefix;

    HjcThreadFactory(String name) {

        SecurityManager s &lt;/span&gt;=&lt;span&gt; System.getSecurityManager();
        group &lt;/span&gt;= (s != &lt;span&gt;null&lt;/span&gt;) ?&lt;span&gt; s.getThreadGroup() : Thread.currentThread().getThreadGroup();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;null&lt;/span&gt; == name ||&lt;span&gt; name.isEmpty()) {
            name &lt;/span&gt;= &quot;pool&quot;&lt;span&gt;;
        }

        namePrefix &lt;/span&gt;= name + &quot;-&quot; + poolNumber.getAndIncrement() + &quot;-thread-&quot;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Thread newThread(Runnable r) {
        Thread t &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Thread(group, r, namePrefix + threadNumber.getAndIncrement(), 0&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (t.isDaemon())
            t.setDaemon(&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (t.getPriority() !=&lt;span&gt; Thread.NORM_PRIORITY)
            t.setPriority(Thread.NORM_PRIORITY);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; t;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;然后创建线程池时候如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.hjc;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.LinkedBlockingQueue;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.ThreadPoolExecutor;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.TimeUnit;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * Created by cong on 2019/5/26.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ThreadPoolExecutorTest {
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; ThreadPoolExecutor executorOne = &lt;span&gt;new&lt;/span&gt; ThreadPoolExecutor(5, 5, 1, TimeUnit.MINUTES, &lt;span&gt;new&lt;/span&gt; LinkedBlockingQueue&amp;lt;&amp;gt;(),&lt;span&gt;new&lt;/span&gt; HjcThreadFactory(&quot;ASYN-ACCEPT-POOL&quot;&lt;span&gt;));
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; ThreadPoolExecutor executorTwo = &lt;span&gt;new&lt;/span&gt; ThreadPoolExecutor(5, 5, 1, TimeUnit.MINUTES, &lt;span&gt;new&lt;/span&gt; LinkedBlockingQueue&amp;lt;&amp;gt;(),&lt;span&gt;new&lt;/span&gt; HjcThreadFactory(&quot;ASYN-PROCESS-POOL&quot;&lt;span&gt;));

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;接受用户链接模块&lt;/span&gt;
        executorOne.execute(&lt;span&gt;new&lt;/span&gt;&lt;span&gt;  Runnable() {
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                System.out.println(&lt;/span&gt;&quot;接受用户链接线程&quot;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NullPointerException();
            }
        });
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;具体处理用户请求模块&lt;/span&gt;
        executorTwo.execute(&lt;span&gt;new&lt;/span&gt;&lt;span&gt;  Runnable() {
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                System.out.println(&lt;/span&gt;&quot;具体处理业务请求线程&quot;&lt;span&gt;);
            }
        });

        executorOne.shutdown();
        executorTwo.shutdown();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 然后运行执行结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1202638/201905/1202638-20190526204604836-1689899917.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 从运行结果抛出的异常，可以看到从 &lt;code&gt;ASYN-ACCEPT-POOL-1-thread-1&lt;/code&gt; 就可以知道是接受链接线程池抛出的异常。&lt;/p&gt;

&lt;h3 id=&quot;44threadlocal&quot;&gt;4.4 线程池中使用 ThreadLocal 导致的内存泄露&lt;/h3&gt;
&lt;p&gt;下面先看线程池中使用 ThreadLocal 的例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.hjc;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.LinkedBlockingQueue;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.ThreadPoolExecutor;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * Created by cong on 2019/5/26.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ThreadPoolTest {

    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LocalVariable {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Long[] a = &lt;span&gt;new&lt;/span&gt; Long[1024 * 1024&lt;span&gt;];
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; (1)&lt;/span&gt;
    &lt;span&gt;final&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ThreadPoolExecutor poolExecutor = &lt;span&gt;new&lt;/span&gt; ThreadPoolExecutor(5, 5, 1&lt;span&gt;, TimeUnit.MINUTES,
            &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; LinkedBlockingQueue&amp;lt;&amp;gt;&lt;span&gt;());
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; (2)&lt;/span&gt;
    &lt;span&gt;final&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ThreadLocal&amp;lt;LocalVariable&amp;gt; localVariable = &lt;span&gt;new&lt;/span&gt; ThreadLocal&amp;lt;LocalVariable&amp;gt;&lt;span&gt;();

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; (3)&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 50; ++&lt;span&gt;i) {
            poolExecutor.execute(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
                &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; (4)&lt;/span&gt;
                    localVariable.set(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; LocalVariable());
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; (5)&lt;/span&gt;
                    System.out.println(&quot;use local varaible&quot;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;localVariable.remove();&lt;/span&gt;
&lt;span&gt;
                }
            });

            Thread.sleep(&lt;/span&gt;1000&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; (6)&lt;/span&gt;
        System.out.println(&quot;pool execute over&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;代码（1）创建了一个核心线程数和最大线程数为 5 的线程池，这个保证了线程池里面随时都有 5 个线程在运行。&lt;/p&gt;
&lt;p&gt;代码（2）创建了一个 ThreadLocal 的变量，泛型参数为 LocalVariable，LocalVariable 内部是一个 Long 数组。&lt;/p&gt;
&lt;p&gt;代码（3）向线程池里面放入 50 个任务&lt;/p&gt;
&lt;p&gt;代码（4）设置当前线程的 localVariable 变量，也就是把 new 的 LocalVariable 变量放入当前线程的 threadLocals 变量。&lt;/p&gt;
&lt;p&gt;由于没有调用线程池的 shutdown 或者 shutdownNow 方法所以线程池里面的用户线程不会退出，进而 JVM 进程也不会退出。&lt;/p&gt;

&lt;p&gt;运行当前代码，使用 jconsole 监控堆内存变化如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1202638/201905/1202638-20190526205537208-914655333.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;然后解开 &lt;code&gt;localVariable.remove()&lt;/code&gt; 注释，然后在运行，观察堆内存变化如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1202638/201905/1202638-20190526210810386-560411018.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;从运行结果一可知，当主线程处于休眠时候进程占用了大概 77M 内存，运行结果二则占用了大概 25M 内存，可知运行代码一时候内存发生了泄露，下面分析下泄露的原因。&lt;/p&gt;
&lt;p&gt;运行结果一的代码，在设置线程的 localVariable 变量后没有调用 &lt;code&gt;localVariable.remove()&lt;/code&gt;方法，导致线程池里面的 5 个线程的 threadLocals 变量里面的 &lt;code&gt;new LocalVariable()&lt;/code&gt; 实例没有被释放，虽然线程池里面的任务执行完毕了，但是线程池里面的 5 个线程会一直存在直到 JVM 进程被杀死。&lt;/p&gt;
&lt;p&gt;这里需要注意的是由于 localVariable 被声明了 static，虽然线程的 ThreadLocalMap 里面是对localVariable的弱引用，localVariable也不会被回收。&lt;/p&gt;
&lt;p&gt;运行结果二的代码由于线程在设置 localVariable 变量后及时调用了 &lt;code&gt;localVariable.remove()&lt;/code&gt; 方法进行了清理，所以不会存在内存泄露。&lt;/p&gt;
&lt;p&gt;总结：线程池里面设置了 ThreadLocal 变量一定要记得及时清理，因为线程池里面的核心线程是一直存在的，如果不清理，那么线程池的核心线程的 threadLocals 变量一直会持有 ThreadLocal 变量。&lt;/p&gt;
</description>
<pubDate>Sun, 26 May 2019 13:10:00 +0000</pubDate>
<dc:creator>&amp;#183;木木夕&amp;#183;</dc:creator>
<og:description>1.线程池的作用 一方面当执行大量异步任务时候线程池能够提供较好的性能，在不使用线程池的时候，每当需要执行异步任务时候是直接 new 一线程进行运行，而线程的创建和销毁是需要开销的。使用线程池时候，线</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/huangjuncong/p/10031525.html</dc:identifier>
</item>
</channel>
</rss>