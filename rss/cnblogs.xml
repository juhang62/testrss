<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>面试题-使用线程交替打印奇数偶数 - 不会敲代码的老王</title>
<link>http://www.cnblogs.com/rolandlee/p/10900149.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/rolandlee/p/10900149.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;这世上有三样东西是别人抢不走的：一是吃进胃里的食物，二是藏在心中的梦想，三是读进大脑的书&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;分析题目。需要使用两个线程交替打印奇偶数。&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;使用同步锁解决这个问题&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;使用信号量来实现交替打印&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;定义两个信号量，一个奇数信号量，一个偶数信号量，都初始化为1&lt;/li&gt;
&lt;li&gt;先用掉偶数的信号量，因为要让奇数先启动，等奇数打印完再释放&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;&lt;li&gt;具体实现思路：&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;定义两个信号量，一个奇数信号量，一个偶数信号量，都初始化为1&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;先用掉偶数的信号量，因为要让奇数先启动，等奇数打印完再释放&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;具体流程就是 第一次的时候先减掉偶数的信号量 奇数线程打印完成以后用掉奇数的信号量。然后释放偶数的信号量如此循环&lt;/strong&gt;&lt;br/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;import java.util.concurrent.Semaphore;

/**
 * @ClassName AlternatePrinting
 * @Author yunlogn
 * @Date 2019/5/21 
 * @Description 交替打印奇偶数
 */
public class AlternatePrinting {

    static int i = 0;
    public static void main(String[] args) throws InterruptedException {

      Semaphore semaphoreOdd = new Semaphore(1);
         Semaphore semaphoreEven = new Semaphore(1);

      semaphoreOdd.acquire();  //让奇数先等待启动，所以先减掉偶数的信号量 等奇数线程来释放

        SemaphorePrintEven semaphorePrintEven = new SemaphorePrintEven(semaphoreOdd, semaphoreEven);
        Thread t1 = new Thread(semaphorePrintEven);
        t1.start();

        SemaphorePrintOdd semaphorePrintOdd = new SemaphorePrintOdd(semaphoreOdd, semaphoreEven);
        Thread t2 = new Thread(semaphorePrintOdd);
        t2.start();

    }

    /**
     * 使用信号量实现
     */
    static class SemaphorePrintOdd implements Runnable {

        private Semaphore semaphoreOdd;
        private Semaphore semaphoreEven;


        public SemaphorePrintOdd(Semaphore semaphoreOdd, Semaphore semaphoreEven) {
            this.semaphoreOdd = semaphoreOdd;
            this.semaphoreEven = semaphoreEven;
        }

        @Override
        public void run() {
            try {
            
                semaphoreOdd.acquire();//获取信号量 semaphoreOdd在初始化的时候被获取了信号量所以这里被阻塞了，所以会先执行下面的奇数线程
                while (true) {
                    i++;
                    if (i % 2 == 0) {
                        System.out.println(&quot;偶数线程：&quot; + i);
                        semaphoreEven.release();//释放偶数信号量 让奇数线程那边的阻塞解除
                        //再次申请获取偶数信号量，因为之前已经获取过，如果没有奇数线程去释放，那么就会一直阻塞在这，等待奇数线程释放
                        semaphoreOdd.acquire();
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    static class SemaphorePrintEven implements Runnable {


        private Semaphore semaphoreOdd;
        private Semaphore semaphoreEven;


        public SemaphorePrintEven(Semaphore semaphoreOdd, Semaphore semaphoreEven) {
            this.semaphoreOdd = semaphoreOdd;
            this.semaphoreEven = semaphoreEven;
        }

        @Override
        public void run() {

            try {
          
           
                semaphoreEven.acquire(); 
                while (true) {
                    i++;
                    if (i % 2 == 1) {
                        System.out.println(&quot;奇数线程：&quot; + i);
                        semaphoreOdd.release(); //释放奇数信号量 让偶数线程那边的阻塞解除
                        
                //这里阻塞，等待偶数线程释放信号量
                //再次申请获取奇数信号量，需要等偶数线程执行完然后释放该信号量，不然阻塞
                semaphoreEven.acquire();
                    }
                }

            } catch (Exception ex) {}


        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;需要注意的是，如果某个线程来不及释放就异常中断了，会导致另一个线程一直在等，造成死锁。 虽然这个异常不在这个问题的考虑范围内 但是可以使用&lt;code&gt;finally&lt;/code&gt; 来包裹释放锁资源&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;&lt;li&gt;让两个线程使用同一把锁。交替执行 。&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;判断是不是奇数 如果是奇数进入奇数线程执行打印并加一。然后线程释放锁资源。然后让该线程等待&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;判断是不是偶数，如果是偶数进入偶数线程执行打印并加一。然后线程释放锁资源。然后让该线程等待&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;import java.util.concurrent.atomic.AtomicInteger;


/**
 * @ClassName AlternatePrinting
 * @Author yunlogn
 * @Date 2019/5/21
 * @Description 交替打印奇偶数
 */
public class AlternatePrinting {

    public static AtomicInteger atomicInteger = new AtomicInteger(1);

    public static void main(String[] args) throws InterruptedException {

        Thread a=new Thread(new AThread());
        Thread b=new Thread(new BThread());
        a.start();
        b.start();

    }


    public static class AThread implements Runnable {

        @Override
        public void run() {
            while (true) {
                synchronized (atomicInteger) {
                    if (atomicInteger.intValue() % 2 != 0) {
                        System.out.println(&quot;奇数线程:&quot; + atomicInteger.intValue());
                        atomicInteger.getAndIncrement();
                        // 奇数线程释放锁资源
                        atomicInteger.notify();
                        try {
                            atomicInteger.wait();
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    } else {
                        try {
                            // 奇数线程等待
                            atomicInteger.wait();
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                }
            }
        }
    }

    public static class BThread implements Runnable {

        @Override
        public void run() {
            while (true){
                synchronized (atomicInteger){
                    if(atomicInteger.intValue() %2== 0 ){
                        System.out.println(&quot;偶数线程:&quot;+ atomicInteger.intValue());
                        atomicInteger.getAndIncrement();
                        // 偶数线程释放锁资源
                        atomicInteger.notify();
                        try {
                            atomicInteger.wait();
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }else{
                        try {
                            // 偶数线程等待
                            atomicInteger.wait();
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                }
            }
        }
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;欢迎关注  http://yunlongn.github.io&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Tue, 21 May 2019 07:37:00 +0000</pubDate>
<dc:creator>不会敲代码的老王</dc:creator>
<og:description>这世上有三样东西是别人抢不走的：一是吃进胃里的食物，二是藏在心中的梦想，三是读进大脑的书 分析题目。需要使用两个线程交替打印奇偶数。 使用同步锁解决这个问题 使用信号量来实现交替打印 定义两个信号量，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/rolandlee/p/10900149.html</dc:identifier>
</item>
<item>
<title>Maven面试必备 - James_Shangguan</title>
<link>http://www.cnblogs.com/sgh1023/p/10900130.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sgh1023/p/10900130.html</guid>
<description>&lt;p&gt;Maven是一个项目管理工具，它包含了一个项目对象模型 (Project Object Model)，一组标准集合，一个项目生命周期(Project Lifecycle)，一个依赖管理系统(Dependency Management System)，和用来运行定义在生命周期阶段(phase)中插件(plugin)目标(goal)的逻辑。&lt;/p&gt;
&lt;h3 id=&quot;核心功能&quot;&gt;核心功能&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;依赖管理：Maven工程对jar包的管理过程。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;一个复杂的项目将会包含很多依赖，也有可能包含依赖于其它构件的依赖。这是Maven最强大的特征之一，它支持了传递性依赖（transitive dependencies）。假如你的项目依赖于一个库，而这个库又依赖于五个或者十个其它的库（就像Spring或者Hibernate那样）。你不必找出所有这些依赖然后把它们写在你的pom.xml里，你只需要加上你直接依赖的那些库，Maven会隐式的把这些库间接依赖的库也加入到你的项目中。Maven也会处理这些依赖中的冲突，同时能让你自定义默认行为，或者排除一些特定的传递性依赖。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;项目构建：&lt;code&gt;mvn tomcat:run&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;仓库&quot;&gt;仓库&lt;/h3&gt;
&lt;p&gt;本地仓库、远程仓库（私服）、中央仓库&lt;/p&gt;
&lt;p&gt;本地仓库默认为{user.home}.m2.repority，可以在配置文件中修改&lt;/p&gt;
&lt;h3 id=&quot;maven项目标准目录结构&quot;&gt;Maven项目标准目录结构&lt;/h3&gt;
&lt;p&gt;核心代码部分：&lt;code&gt;src/main/java&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;配置文件部分：&lt;code&gt;src/main/resources&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;测试代码部分：&lt;code&gt;src/test/java&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;测试配置文件：&lt;code&gt;src/test/resources&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;页面资源（包含js，css，图片资源等）：&lt;code&gt;src/main/webapp&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;maven常用命令&quot;&gt;Maven常用命令&lt;/h3&gt;
&lt;p&gt;clean：删除项目中已经编译好的信息，删除target目录&lt;/p&gt;
&lt;p&gt;compile：Maven工程的编译命令，用于编译项目的源代码，将&lt;code&gt;src/main/java&lt;/code&gt;下的文件编译成class文件输出到target目录下。&lt;/p&gt;
&lt;p&gt;test：使用合适的单元测试框架运行测试。&lt;/p&gt;
&lt;p&gt;package：将编译好的代码打包成可分发的格式，如JAR，WAR。&lt;/p&gt;
&lt;p&gt;install：安装包至本地仓库，以备本地的其它项目作为依赖使用。&lt;/p&gt;
&lt;p&gt;deploy：复制最终的包至远程仓库，共享给其它开发人员和项目（通常和一次正式的发布相关）。&lt;/p&gt;
&lt;p&gt;每一个构建项目的命令都对应了maven底层一个插件。&lt;/p&gt;
&lt;h3 id=&quot;maven命令packageinstalldeploy的联系与区别&quot;&gt;Maven命令package、install、deploy的联系与区别&lt;/h3&gt;
&lt;p&gt;mvn clean package依次执行了clean、resources、compile、testResources、testCompile、test、jar(打包)等７个阶段。&lt;/p&gt;
&lt;p&gt;mvn clean install依次执行了clean、resources、compile、testResources、testCompile、test、jar(打包)、install等8个阶段。&lt;/p&gt;
&lt;p&gt;mvn clean deploy依次执行了clean、resources、compile、testResources、testCompile、test、jar(打包)、install、deploy等９个阶段。&lt;/p&gt;
&lt;p&gt;主要区别：&lt;br/&gt;package命令完成了项目编译、单元测试、打包功能，但没有把打好的可执行jar包（war包或其它形式的包）布署到本地maven仓库和远程maven私服仓库。&lt;/p&gt;
&lt;p&gt;install命令完成了项目编译、单元测试、打包功能，同时把打好的可执行jar包（war包或其它形式的包）布署到本地maven仓库，但没有布署到远程maven私服仓库。&lt;/p&gt;
&lt;p&gt;deploy命令完成了项目编译、单元测试、打包功能，同时把打好的可执行jar包（war包或其它形式的包）布署到本地maven仓库和远程maven私服仓库。　&lt;/p&gt;
&lt;h3 id=&quot;maven生命周期&quot;&gt;Maven生命周期&lt;/h3&gt;
&lt;p&gt;清理生命周期：运行mvn clean将调用清理生命周期 。&lt;/p&gt;
&lt;p&gt;默认生命周期：是一个软件应用程序构建过程的总体模型 。&lt;/p&gt;
&lt;p&gt;compile，test，package，install，deploy&lt;/p&gt;
&lt;p&gt;站点生命周期：为一个或者一组项目生成项目文档和报告，使用较少。&lt;/p&gt;
&lt;h3 id=&quot;maven概念模型&quot;&gt;Maven概念模型&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1538609/201905/1538609-20190521153807781-1976482426.png&quot; alt=&quot;Maven概念模型&quot;/&gt;&lt;/p&gt;
&lt;p&gt;项目对象模型（Project Object Model，POM），对应着Maven项目中的pom.xml文件&lt;/p&gt;
&lt;p&gt;项目自身信息&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;
    &amp;lt;parent&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;2.1.0.RELEASE&amp;lt;/version&amp;gt;
        &amp;lt;relativePath/&amp;gt; &amp;lt;!-- lookup parent from repository --&amp;gt;
    &amp;lt;/parent&amp;gt;
    &amp;lt;groupId&amp;gt;com.shangguan&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;concurrency&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt;
    &amp;lt;name&amp;gt;concurrency&amp;lt;/name&amp;gt;
    &amp;lt;description&amp;gt;Demo project for Spring Boot&amp;lt;/description&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;项目运行所依赖的jar包信息，如：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
            &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;groupId&amp;gt;&lt;/code&gt;：团体，公司，小组，组织，项目，或者其它团体。团体标识的约定是，它以创建这个项目的组织名称的逆向域名(reverse domain name)开头。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;artifactId&amp;gt;&lt;/code&gt;：项目的唯一标识符&lt;/p&gt;
&lt;p&gt;&lt;code&gt;version&lt;/code&gt;：项目的版本&lt;/p&gt;
&lt;p&gt;&lt;code&gt;package&lt;/code&gt;：项目的类型，默认是jar，描述了项目打包后的输出 。&lt;/p&gt;
&lt;p&gt;项目运行环境信息，比如：jdk，tomcat信息&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;    &amp;lt;build&amp;gt;
        &amp;lt;plugins&amp;gt;
            &amp;lt;plugin&amp;gt;
                &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;
            &amp;lt;/plugin&amp;gt;
        &amp;lt;/plugins&amp;gt;
    &amp;lt;/build&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;依赖范围&lt;/p&gt;
&lt;p&gt;compile：默认的范围，编译测试运行都有效。&lt;/p&gt;
&lt;p&gt;provided：编译和运行有效，最后在运行的时候不会加入。官方举了一个例子。比如在JavaEE web项目中我们需要使用servlet的API，但是Tomcat中已经提供这个jar，我们在编译和测试的时候需要使用这个api，但是部署到tomcat的时候，如果还加入servlet构建就会产生冲突，这个时候就可以使用provided。&lt;/p&gt;
&lt;p&gt;runtime：测试和运行有效。&lt;/p&gt;
&lt;p&gt;test：测试有效。&lt;/p&gt;
&lt;p&gt;system：与本机系统关联，编译和测试时有效。&lt;/p&gt;
&lt;p&gt;import：导入的范围，它只在使用dependencyManagement中，表示从其他pom中导入dependecy的配置。&lt;/p&gt;
&lt;h3 id=&quot;maven依赖冲突&quot;&gt;Maven依赖冲突&lt;/h3&gt;
&lt;p&gt;每个显式声明的类包都会依赖于一些其它的隐式类包，这些隐式的类包会被maven间接引入进来，因而可能造成一个我们不想要的类包的载入，严重的甚至会引起类包之间的冲突。&lt;/p&gt;
&lt;p&gt;要解决这个问题，首先就是要查看pom.xml显式和隐式的依赖类包，然后通过这个类包树找出我们不想要的依赖类包，手工将其排除在外就可以了。 例如：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;exclusions&amp;gt;  
    &amp;lt;exclusion&amp;gt;  
        &amp;lt;artifactId&amp;gt;unitils-database&amp;lt;/artifactId&amp;gt;  
        &amp;lt;groupId&amp;gt;org.unitils&amp;lt;/groupId&amp;gt;  
    &amp;lt;/exclusion&amp;gt;  
&amp;lt;/exclusions&amp;gt;  &lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Tue, 21 May 2019 07:35:00 +0000</pubDate>
<dc:creator>James_Shangguan</dc:creator>
<og:description>Maven是一个项目管理工具，它包含了一个项目对象模型 (Project Object Model)，一组标准集合，一个项目生命周期(Project Lifecycle)，一个依赖管理系统(Depen</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sgh1023/p/10900130.html</dc:identifier>
</item>
<item>
<title>RabbitMQ 消息确认机制 - 海向</title>
<link>http://www.cnblogs.com/haixiang/p/10900005.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/haixiang/p/10900005.html</guid>
<description>&lt;hr/&gt;&lt;h3 id=&quot;生产端-confirm-消息确认机制&quot;&gt;生产端 Confirm 消息确认机制&lt;/h3&gt;
&lt;p&gt;消息的确认，是指生产者投递消息后，如果 Broker 收到消息，则会给我们生产者一个应答。生产者进行接收应答，用来确定这条消息是否正常的发送到 Broker ，这种方式也是消息的可靠性投递的核心保障!&lt;/p&gt;
&lt;h4 id=&quot;confirm-确认机制流程图&quot;&gt;Confirm 确认机制流程图&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1543774/201905/1543774-20190521151755443-1603960112.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;如何实现confirm确认消息&quot;&gt;如何实现Confirm确认消息?&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;第一步:在 channel 上开启确认模式: &lt;code&gt;channel.confirmSelect()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;第二步:在 channel 上添加监听: &lt;code&gt;channel.addConfirmListener(ConfirmListener listener);&lt;/code&gt;, 监听成功和失败的返回结果，根据具体的结果对消息进行重新发送、或记录日志等后续处理!&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import com.rabbitmq.client.Channel;
import com.rabbitmq.client.ConfirmListener;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;

import java.io.IOException;

public class ConfirmProducer {
    public static void main(String[] args) throws Exception {
        ConnectionFactory factory = new ConnectionFactory();
        factory.setHost(&quot;localhost&quot;);
        factory.setVirtualHost(&quot;/&quot;);
        factory.setUsername(&quot;guest&quot;);
        factory.setPassword(&quot;guest&quot;);

        Connection connection = factory.newConnection();

        Channel channel = connection.createChannel();

        String exchangeName = &quot;test_confirm_exchange&quot;;
        String routingKey = &quot;item.update&quot;;

        //指定消息的投递模式：confirm 确认模式
        channel.confirmSelect();

        //发送
        final long start = System.currentTimeMillis();
        for (int i = 0; i &amp;lt; 5 ; i++) {
            String msg = &quot;this is confirm msg &quot;;
            channel.basicPublish(exchangeName, routingKey, null, msg.getBytes());
            System.out.println(&quot;Send message : &quot; + msg);
        }

        //添加一个确认监听， 这里就不关闭连接了，为了能保证能收到监听消息
        channel.addConfirmListener(new ConfirmListener() {
            /**
             * 返回成功的回调函数
             */
            public void handleAck(long deliveryTag, boolean multiple) throws IOException {
                System.out.println(&quot;succuss ack&quot;);
                System.out.println(multiple);
                System.out.println(&quot;耗时：&quot; + (System.currentTimeMillis() - start) + &quot;ms&quot;);
            }
            /**
             * 返回失败的回调函数
             */
            public void handleNack(long deliveryTag, boolean multiple) throws IOException {
                System.out.printf(&quot;defeat ack&quot;);
                System.out.println(&quot;耗时：&quot; + (System.currentTimeMillis() - start) + &quot;ms&quot;);
            }
        });
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import com.rabbitmq.client.*;
import java.io.IOException;

public class ConfirmConsumer {
    public static void main(String[] args) throws Exception {
        ConnectionFactory factory = new ConnectionFactory();
        factory.setHost(&quot;localhost&quot;);
        factory.setVirtualHost(&quot;/&quot;);
        factory.setUsername(&quot;guest&quot;);
        factory.setPassword(&quot;guest&quot;);
        factory.setAutomaticRecoveryEnabled(true);
        factory.setNetworkRecoveryInterval(3000);

        Connection connection = factory.newConnection();

        Channel channel = connection.createChannel();
      
        String exchangeName = &quot;test_confirm_exchange&quot;;
        String queueName = &quot;test_confirm_queue&quot;;
        String routingKey = &quot;item.#&quot;;
        channel.exchangeDeclare(exchangeName, &quot;topic&quot;, true, false, null);
        channel.queueDeclare(queueName, false, false, false, null);

        //一般不用代码绑定，在管理界面手动绑定
        channel.queueBind(queueName, exchangeName, routingKey);

        //创建消费者并接收消息
        Consumer consumer = new DefaultConsumer(channel) {
            @Override
            public void handleDelivery(String consumerTag, Envelope envelope,
                                       AMQP.BasicProperties properties, byte[] body)
                    throws IOException {
                String message = new String(body, &quot;UTF-8&quot;);
                System.out.println(&quot; [x] Received '&quot; + message + &quot;'&quot;);
            }
        };

        //设置 Channel 消费者绑定队列
        channel.basicConsume(queueName, true, consumer);

    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们此处只关注生产端输出消息&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Send message : this is confirm msg 
Send message : this is confirm msg 
Send message : this is confirm msg 
Send message : this is confirm msg 
Send message : this is confirm msg 
succuss ack
true
耗时：3ms
succuss ack
true
耗时：4ms&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;注意事项&quot;&gt;注意事项&lt;/h4&gt;
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;我们采用的是异步 confirm 模式：提供一个回调方法，服务端 confirm 了一条或者多条消息后 Client 端会回调这个方法。除此之外还有单条同步 confirm 模式、批量同步 confirm 模式，由于现实场景中很少使用我们在此不做介绍，如有兴趣直接参考官方文档。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;我们运行生产端会发现每次运行结果都不一样,会有多种情况出现，因为 Broker 会进行优化，有时会批量一次性 confirm ，有时会分开几条 confirm。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;succuss ack
true
耗时：3ms
succuss ack
false
耗时：4ms

或者
succuss ack
true
耗时：3ms&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;return-消息机制&quot;&gt;Return 消息机制&lt;/h3&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li&gt;Return Listener 用于处理一-些不可路 由的消息!&lt;/li&gt;
&lt;li&gt;消息生产者，通过指定一个 &lt;code&gt;Exchange&lt;/code&gt; 和 &lt;code&gt;Routingkey&lt;/code&gt;，把消息送达到某一个队列中去，然后我们的消费者监听队列，进行消费处理操作!&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;但是在某些情况下，如果我们在发送消息的时候，当前的 exchange 不存在或者指定的路由 key 路由不到，这个时候如果我们需要监听这种不可达的消息，就要使用 &lt;code&gt;Return Listener !&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;在基础API中有一个关键的配置项:&lt;code&gt;Mandatory&lt;/code&gt;：如果为 &lt;code&gt;true&lt;/code&gt;，则监听器会接收到路由不可达的消息，然后进行后续处理，如果为 &lt;code&gt;false&lt;/code&gt;，那么 broker 端自动删除该消息!&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;return-消息机制流程图&quot;&gt;Return 消息机制流程图&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1543774/201905/1543774-20190521151825455-1532759386.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;return-消息式例&quot;&gt;Return 消息式例&lt;/h4&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;首先我们需要发送三条消息，并且故意将第 0 条消息的 &lt;code&gt;routing Key&lt;/code&gt;设置为错误的，让他无法正常路由到消费端。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mandatory&lt;/code&gt; 设置为 &lt;code&gt;true&lt;/code&gt; 路由不可达的消息会被监听到，不会被自动删除.即&lt;code&gt;channel.basicPublish(exchangeName, errRoutingKey, true,null, msg.getBytes());&lt;/code&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;最后添加监听即可监听到不可路由到消费端的消息&lt;code&gt;channel.addReturnListener(ReturnListener r))&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import com.rabbitmq.client.*;
import java.io.IOException;

public class ReturnListeningProducer {
    public static void main(String[] args) throws Exception {
        ConnectionFactory factory = new ConnectionFactory();
        factory.setHost(&quot;localhost&quot;);
        factory.setVirtualHost(&quot;/&quot;);
        factory.setUsername(&quot;guest&quot;);
        factory.setPassword(&quot;guest&quot;);
      
        Connection connection = factory.newConnection();
        Channel channel = connection.createChannel();

        String exchangeName = &quot;test_return_exchange&quot;;
        String routingKey = &quot;item.update&quot;;
        String errRoutingKey = &quot;error.update&quot;;

        //指定消息的投递模式：confirm 确认模式
        channel.confirmSelect();

        //发送
        for (int i = 0; i &amp;lt; 3 ; i++) {
            String msg = &quot;this is return——listening msg &quot;;
            //@param mandatory 设置为 true 路由不可达的消息会被监听到，不会被自动删除
            if (i == 0) {
                channel.basicPublish(exchangeName, errRoutingKey, true,null, msg.getBytes());
            } else {
                channel.basicPublish(exchangeName, routingKey, true, null, msg.getBytes());
            }
            System.out.println(&quot;Send message : &quot; + msg);
        }

        //添加一个确认监听， 这里就不关闭连接了，为了能保证能收到监听消息
        channel.addConfirmListener(new ConfirmListener() {
            /**
             * 返回成功的回调函数
             */
            public void handleAck(long deliveryTag, boolean multiple) throws IOException {
                System.out.println(&quot;succuss ack&quot;);
            }
            /**
             * 返回失败的回调函数
             */
            public void handleNack(long deliveryTag, boolean multiple) throws IOException {
                System.out.printf(&quot;defeat ack&quot;);
            }
        });

        //添加一个 return 监听
        channel.addReturnListener(new ReturnListener() {
            public void handleReturn(int replyCode, String replyText, String exchange, String routingKey, AMQP.BasicProperties properties, byte[] body) throws IOException {
                System.out.println(&quot;return relyCode: &quot; + replyCode);
                System.out.println(&quot;return replyText: &quot; + replyText);
                System.out.println(&quot;return exchange: &quot; + exchange);
                System.out.println(&quot;return routingKey: &quot; + routingKey);
                System.out.println(&quot;return properties: &quot; + properties);
                System.out.println(&quot;return body: &quot; + new String(body));
            }
        });

    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import com.rabbitmq.client.*;
import java.io.IOException;

public class ReturnListeningConsumer {
    public static void main(String[] args) throws Exception {
        //1. 创建一个 ConnectionFactory 并进行设置
        ConnectionFactory factory = new ConnectionFactory();
        factory.setHost(&quot;localhost&quot;);
        factory.setVirtualHost(&quot;/&quot;);
        factory.setUsername(&quot;guest&quot;);
        factory.setPassword(&quot;guest&quot;);
        factory.setAutomaticRecoveryEnabled(true);
        factory.setNetworkRecoveryInterval(3000);

        //2. 通过连接工厂来创建连接
        Connection connection = factory.newConnection();

        //3. 通过 Connection 来创建 Channel
        Channel channel = connection.createChannel();

        //4. 声明
        String exchangeName = &quot;test_return_exchange&quot;;
        String queueName = &quot;test_return_queue&quot;;
        String routingKey = &quot;item.#&quot;;

        channel.exchangeDeclare(exchangeName, &quot;topic&quot;, true, false, null);
        channel.queueDeclare(queueName, false, false, false, null);

        //一般不用代码绑定，在管理界面手动绑定
        channel.queueBind(queueName, exchangeName, routingKey);

        //5. 创建消费者并接收消息
        Consumer consumer = new DefaultConsumer(channel) {
            @Override
            public void handleDelivery(String consumerTag, Envelope envelope,
                                       AMQP.BasicProperties properties, byte[] body)
                    throws IOException {
                String message = new String(body, &quot;UTF-8&quot;);
                System.out.println(&quot; [x] Received '&quot; + message + &quot;'&quot;);
            }
        };

        //6. 设置 Channel 消费者绑定队列
        channel.basicConsume(queueName, true, consumer);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们只关注生产端结果，消费端只收到两条消息。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Send message : this is return——listening msg 
Send message : this is return——listening msg 
Send message : this is return——listening msg 
return relyCode: 312
return replyText: NO_ROUTE
return exchange: test_return_exchange
return routingKey: error.update
return properties: #contentHeader&amp;lt;basic&amp;gt;(content-type=null, content-encoding=null, headers=null, delivery-mode=null, priority=null, correlation-id=null, reply-to=null, expiration=null, message-id=null, timestamp=null, type=null, user-id=null, app-id=null, cluster-id=null)
return body: this is return——listening msg 
succuss ack
succuss ack
succuss ack&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;消费端-ack-和-nack-机制&quot;&gt;消费端 Ack 和 Nack 机制&lt;/h3&gt;
&lt;p&gt;消费端进行消费的时候，如果由于业务异常我们可以进行日志的记录，然后进行补偿!如果由于服务器宕机等严重问题，那我们就需要手工进行ACK保障消费端消费成功!消费端重回队列是为了对没有处理成功的消息，把消息重新会递给Broker!一般我们在实际应用中，都会关闭重回队列，也就是设置为False。&lt;/p&gt;
&lt;h4 id=&quot;参考-api&quot;&gt;参考 api&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;void basicNack(long deliveryTag, boolean multiple, boolean requeue) throws IOException;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;void basicAck(long deliveryTag, boolean multiple) throws IOException;&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;如何设置手动-ack-nack-以及重回队列&quot;&gt;如何设置手动 Ack 、Nack 以及重回队列&lt;/h4&gt;
&lt;ul readability=&quot;4.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;首先我们发送五条消息，将每条消息对应的循环下标 i 放入消息的 &lt;code&gt;properties&lt;/code&gt; 中作为标记，以便于我们在后面的回调方法中识别。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;其次， 我们将消费端的 ·&lt;code&gt;channel.basicConsume(queueName, false, consumer);&lt;/code&gt; 中的 &lt;code&gt;autoAck&lt;/code&gt;属性设置为 &lt;code&gt;false&lt;/code&gt;，如果设置为&lt;code&gt;true&lt;/code&gt;的话 将会正常输出五条消息。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;我们通过 &lt;code&gt;Thread.sleep(2000)&lt;/code&gt;来延时一秒，用以看清结果。我们获取到&lt;code&gt;properties&lt;/code&gt;中的&lt;code&gt;num&lt;/code&gt;之后，通过&lt;code&gt;channel.basicNack(envelope.getDeliveryTag(), false, true);&lt;/code&gt;将 &lt;code&gt;num&lt;/code&gt;为0的消息设置为 nack，即消费失败，并且将 &lt;code&gt;requeue&lt;/code&gt;属性设置为&lt;code&gt;true&lt;/code&gt;，即消费失败的消息重回队列末端。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import com.rabbitmq.client.*;
import java.util.HashMap;
import java.util.Map;

public class AckAndNackProducer {
    public static void main(String[] args) throws Exception {
        ConnectionFactory factory = new ConnectionFactory();
        factory.setHost(&quot;localhost&quot;);
        factory.setVirtualHost(&quot;/&quot;);
        factory.setUsername(&quot;guest&quot;);
        factory.setPassword(&quot;guest&quot;);

        Connection connection = factory.newConnection();
        Channel channel = connection.createChannel();

        String exchangeName = &quot;test_ack_exchange&quot;;
        String routingKey = &quot;item.update&quot;;

        String msg = &quot;this is ack msg&quot;;
        for (int i = 0; i &amp;lt; 5; i++) {
            Map&amp;lt;String, Object&amp;gt; headers = new HashMap&amp;lt;String, Object&amp;gt;();
            headers.put(&quot;num&quot; ,i);

            AMQP.BasicProperties properties = new AMQP.BasicProperties().builder()
                    .deliveryMode(2)
                    .headers(headers)
                    .build();

            String tem = msg + &quot;:&quot; + i;

            channel.basicPublish(exchangeName, routingKey, true, properties, tem.getBytes());
            System.out.println(&quot;Send message : &quot; + msg);
        }

        channel.close();
        connection.close();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import com.rabbitmq.client.*;
import java.io.IOException;

public class AckAndNackConsumer {
    public static void main(String[] args) throws Exception {
        ConnectionFactory factory = new ConnectionFactory();
        factory.setHost(&quot;localhost&quot;);
        factory.setVirtualHost(&quot;/&quot;);
        factory.setUsername(&quot;guest&quot;);
        factory.setPassword(&quot;guest&quot;);
        factory.setAutomaticRecoveryEnabled(true);
        factory.setNetworkRecoveryInterval(3000);

        Connection connection = factory.newConnection();

        final Channel channel = connection.createChannel();

        String exchangeName = &quot;test_ack_exchange&quot;;
        String queueName = &quot;test_ack_queue&quot;;
        String routingKey = &quot;item.#&quot;;
        channel.exchangeDeclare(exchangeName, &quot;topic&quot;, true, false, null);
        channel.queueDeclare(queueName, false, false, false, null);

        //一般不用代码绑定，在管理界面手动绑定
        channel.queueBind(queueName, exchangeName, routingKey);

        Consumer consumer = new DefaultConsumer(channel) {
            @Override
            public void handleDelivery(String consumerTag, Envelope envelope,
                                       AMQP.BasicProperties properties, byte[] body)
                    throws IOException {

                String message = new String(body, &quot;UTF-8&quot;);
                System.out.println(&quot; [x] Received '&quot; + message + &quot;'&quot;);

                try {
                    Thread.sleep(2000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }

                if ((Integer) properties.getHeaders().get(&quot;num&quot;) == 0) {
                    channel.basicNack(envelope.getDeliveryTag(), false, true);
                } else {
                    channel.basicAck(envelope.getDeliveryTag(), false);
                }
            }
        };

        //6. 设置 Channel 消费者绑定队列
        channel.basicConsume(queueName, false, consumer);

    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们此处只关心消费端输出，可以看到第 0 条消费失败重新回到队列尾部消费。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; [x] Received 'this is ack msg:1'
 [x] Received 'this is ack msg:2'
 [x] Received 'this is ack msg:3'
 [x] Received 'this is ack msg:4'
 [x] Received 'this is ack msg:0'
 [x] Received 'this is ack msg:0'
 [x] Received 'this is ack msg:0'
 [x] Received 'this is ack msg:0'
 [x] Received 'this is ack msg:0'&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Tue, 21 May 2019 07:20:00 +0000</pubDate>
<dc:creator>海向</dc:creator>
<og:description>[TOC] 生产端 Confirm 消息确认机制 消息的确认，是指生产者投递消息后，如果 Broker 收到消息，则会给我们生产者一个应答。生产者进行接收应答，用来确定这条消息是否正常的发送到 Bro</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/haixiang/p/10900005.html</dc:identifier>
</item>
<item>
<title>MySQL基础知识（一）-超详细MySQL安装教程 - 北京-宏哥</title>
<link>http://www.cnblogs.com/du-hong/p/10899327.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/du-hong/p/10899327.html</guid>
<description>&lt;h2&gt;简介&lt;/h2&gt;
&lt;p&gt;　　原计划，今天这篇想要给小伙伴们讲解一下python操作mysql数据库，但是由于近期换了一台新的电脑，所以一看mysql数据库都没安装，所有才有了这篇文章。尽管网上不乏此类型的文章，但是刚好自己要安装，所以就总结和分享一下下了&lt;/p&gt;
&lt;p&gt;这篇博文看起来可能有点长，那是因为步骤比较详细，每一步都有截图，实际操作起来是特别简单的，别心里发虚，加油 &lt;a href=&quot;http://images2015.cnblogs.com/blog/914233/201610/914233-20161019203824560-1266766094.png&quot;&gt;&lt;img title=&quot;018D5E22&quot; src=&quot;https://images2015.cnblogs.com/blog/914233/201610/914233-20161019203830951-453957755.png&quot; alt=&quot;018D5E22&quot; width=&quot;52&quot; height=&quot;52&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;环境准备&lt;/h2&gt;
&lt;p&gt;（1）小编电脑操作系统：win10&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201905/1232840-20190521133644070-1384142305.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;（2）mysql数据库版本：mysql-installer-community-5.6.15.0.msi&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201905/1232840-20190521133614875-1601260014.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt; 安装步骤&lt;/h2&gt;
&lt;h3&gt;一、下载MySQL&lt;/h3&gt;
&lt;p&gt;（1）首先，去数据库的官网&lt;a href=&quot;http://www.mysql.com/&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;http://www.mysql.com&lt;/a&gt;下载MySQL。点击进入后的首页如下： &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201905/1232840-20190521134353532-1963517750.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（2）第一步：点击downloads，第二步：点击：community，第三步：选择MySQL Community Server。如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201905/1232840-20190521135039976-169166843.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（3）点击选中“MySql Community Downloads”下边的Download后，打开的页面中就可以看到相关的下载项了。如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201905/1232840-20190521140312772-1205185650.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在图中第一个红色框标注的地方就是选择操作系统，这里我们选择Microsoft Windows，可以看到第二个红色框是Recommended download，这里就要区分了，如果是新手建议点击这个，因为这个版本的MySQL不用自己配置，就是普通的安装文件，&lt;/p&gt;
&lt;p&gt;直接一路next就安装完了，如果想深入学习，那么点击Other downloads内容区的下载，可以看到前一个是正式版，后一个是debug版，一般选择前一个，根据自己的机器32位还是64位选择下载，下载下来是个zip文件，安装的自己配置，相对复杂&lt;/p&gt;
&lt;p&gt;（4）点击go to download page进去页面之后，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201905/1232840-20190521141731892-343677398.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（5）选择第二个下载项进行下载，点击download进入下载页面选择No thanks, just start my download就可以开始下载了，当然你要是想注册也可以注册一下。 &lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201905/1232840-20190521141835271-449085652.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;二、安装MySQL&lt;/h2&gt;
&lt;p&gt;（1）打双击刚刚下载好的安装包，开始安装MySQL。 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201905/1232840-20190521142130568-173791040.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（2）点击“Install MySQL Products”，进入如下页面：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201905/1232840-20190521142419265-1513540057.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（3）选择 I accept 然后点击next进入下一步。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201905/1232840-20190521142527759-1740014392.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（4）出现查找MySql最新版本的页面（看个人情况是否需要在线更新MySQL）。个人建议：直接跳过，如果需要可以卸载再安装需要的版本。所以选中“Skip”，点击“NEXT”进入下一步&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201905/1232840-20190521143005325-399524325.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（5）这里选择Developer Default，我这里将其安装路径修改了一下，当然你也可以不修改，默认即可。然后点击next进入下一步。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201905/1232840-20190521143244346-2146822089.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（6）这一步是检查安装条件，如果电脑安装了VC2010运行库，Excel，VisualStudio前三项就会自动打上勾，因为我电脑有些没有安装，所以没有选中这些，点击next的时候会出现警告框，提示你安装傻瓜式的安装所需要的即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201905/1232840-20190521143944639-2067324597.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（7）安装好以后，所需的都选中，点击“NEXT”。如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201905/1232840-20190521144125567-1542262941.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（8）这里直接点击execute执行就可以了，执行完后点击next进入下一步。图中第二项表示安装失败，不去管它，是一个mysql连接工具，这里安装失败是由于我以前在这里单独安装过，所以这里安装失败了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201905/1232840-20190521144430263-1969149297.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（9）之后出现配置界面&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201905/1232840-20190521144539765-256170491.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（10）点击next之后开始配置，第一个配置的是mysql的运行模式和网络，其中Config Type表示运行模式，如果安装mysql是做开发用，就直接选择第一个默认的就行，第二个Server Machine表示运行模式为服务器模式，这些模式的不同会导致MySQL占用系统资源的不同，第二个配置的是网络相关，表示链接MySQL的时候使用TCP/IP协议，并指定端口号为3306，这些如果没有特殊要求就不要去改&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201905/1232840-20190521144642857-1639329654.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（11）配置完成之后点击next，需要填写MySQL中root用户的密码，长度最低为4位，第二栏中还可以添加普通用户，一般开发用不用再建立用户了，直接使用root就可以，所以我们填完密码之后点击next&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201905/1232840-20190521144741558-299852414.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（12）以下图片中需要配置的是MySQL的运行方式，第一个单选框表示是否将MySQL服务作为一个windows服务来运行，windows server name表示MySQL服务在windows server中的名称，第二个单选框表示是否在系统启动时自动启动MySQL，&lt;/p&gt;
&lt;p&gt;第三个单选框表示MySQL服务以哪个账户运行，这一页的基本别动，直接next&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201905/1232840-20190521144930603-1592253616.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（13）进入如下界面，完成后，直接next&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201905/1232840-20190521145138532-661302062.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（14）之后出现“finish”直接点击“finish”即可完成安装。&lt;/p&gt;
&lt;h2&gt;查看MySQL是否安装成功&lt;/h2&gt;
&lt;p&gt;1、右键“电脑”--&amp;gt;管理--&amp;gt;服务 排序找找是否存在mysql名字的服务&lt;/p&gt;
&lt;p&gt;2、运行--services.msc 排序查找&lt;/p&gt;
&lt;p&gt;3、任务栏右键--任务管理器--服务&lt;/p&gt;

&lt;p&gt; 　　好了，到此MySQL全部安装完成了，以后就可以在自己电脑做各种练习了！！！&lt;/p&gt;
</description>
<pubDate>Tue, 21 May 2019 07:06:00 +0000</pubDate>
<dc:creator>北京-宏哥</dc:creator>
<og:description>简介 原计划，今天这篇想要给小伙伴们讲解一下python操作mysql数据库，但是由于近期换了一台新的电脑，所以一看mysql数据库都没安装，所有才有了这篇文章。尽管网上不乏此类型的文章，但是刚好自己</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/du-hong/p/10899327.html</dc:identifier>
</item>
<item>
<title>liteos任务（二） - yooooooo</title>
<link>http://www.cnblogs.com/linhaostudy/p/10898995.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/linhaostudy/p/10898995.html</guid>
<description>&lt;h2 id=&quot;基本概念&quot;&gt;1 基本概念&lt;/h2&gt;
&lt;p&gt;从系统的角度看，任务是竞争系统资源的最小运行单元。任务可以使用或等待CPU、使用内存空间等系统资源，并独立于其它任务运行。&lt;/p&gt;
&lt;p&gt;Huawei LiteOS的任务模块可以给用户提供多个任务，实现了任务之间的切换和通信，帮助用户管理业务程序流程。这样用户可以将更多的精力投入到业务功能的实现中。&lt;/p&gt;
&lt;p&gt;Huawei LiteOS是一个支持多任务的操作系统。在Huawei LiteOS中，一个任务表示一个线程。&lt;/p&gt;
&lt;p&gt;Huawei LiteOS中的任务是抢占式调度机制，同时支持时间片轮转调度方式。&lt;/p&gt;
&lt;p&gt;高优先级的任务可打断低优先级任务，低优先级任务必须在高优先级任务阻塞或结束后才能得到调度。&lt;/p&gt;
&lt;p&gt;Huawei LiteOS的任务一共有32个优先级(0-31)，最高优先级为0，最低优先级为31。&lt;/p&gt;
&lt;h2 id=&quot;任务相关概念&quot;&gt;2 任务相关概念&lt;/h2&gt;
&lt;h3 id=&quot;任务状态&quot;&gt;2.1 任务状态&lt;/h3&gt;
&lt;p&gt;Huawei LiteOS系统中的每一任务都有多种运行状态。系统初始化完成后，创建的任务就可以在系统中竞争一定的资源，由内核进行调度。&lt;/p&gt;
&lt;p&gt;任务状态通常分为以下四种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;就绪（Ready）：该任务在就绪列表中，只等待CPU。&lt;/li&gt;
&lt;li&gt;运行（Running）：该任务正在执行。&lt;/li&gt;
&lt;li&gt;阻塞（Blocked）：该任务不在就绪列表中。包含任务被挂起、任务被延时、任务正在等待信号量、读写队列或者等待读写事件等。&lt;/li&gt;
&lt;li&gt;退出态（Dead）：该任务运行结束，等待系统回收资源。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;图 3-1 任务状态示意图&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811006/201905/811006-20190521093456210-721841443.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;就绪态-》运行态&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;任务创建后进入就绪态，发生任务切换时，就绪列表中最高优先级的任务被执行，从而进入运行态，但此刻该任务依旧在就绪列表中。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;运行态→阻塞态：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;正在运行的任务发生阻塞（挂起、延时、读信号量等待）时，该任务会从就绪列表中删除，任务状态由运行态变成阻塞态，然后发生任务切换，运行就绪列表中剩余最高优先级任务。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;阻塞态→就绪态（阻塞态→运行态）：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;阻塞的任务被恢复后（任务恢复、延时时间超时、读信号量超时或读到信号量等），此时被恢复的任务会被加入就绪列表，从而由阻塞态变成就绪态；此时如果被恢复任务的优先级高于正在运行任务的优先级，则会发生任务切换，将该任务由就绪态变成运行态。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;阻塞态→退出态&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;阻塞的任务调用删除接口，任务状态由阻塞态变为退出态。&lt;/p&gt;
&lt;h3 id=&quot;任务id&quot;&gt;2.2 任务ID&lt;/h3&gt;
&lt;p&gt;任务ID，在任务创建时通过参数返回给用户，作为任务的一个非常重要的标识。用户可以通过任务ID对指定任务进行任务挂起、任务恢复、查询任务名等操作。&lt;/p&gt;
&lt;h3 id=&quot;任务优先级&quot;&gt;2.3 任务优先级&lt;/h3&gt;
&lt;p&gt;优先级表示任务执行的优先顺序。任务的优先级决定了在发生任务切换时即将要执行的任务。在就绪列表中的最高优先级的任务将得到执行。&lt;/p&gt;
&lt;h3 id=&quot;任务入口函数&quot;&gt;2.4 任务入口函数&lt;/h3&gt;
&lt;p&gt;每个新任务得到调度后将执行的函数。该函数由用户实现，在任务创建时，通过任务创建结构体指定。&lt;/p&gt;
&lt;h3 id=&quot;任务控制块tcb&quot;&gt;2.5 任务控制块TCB&lt;/h3&gt;
&lt;p&gt;每一个任务都含有一个任务控制块(TCB)。 TCB包含了任务上下文栈指针（stack pointer）、任务状态、任务优先级、任务ID、任务名、任务栈大小等信息。 TCB可以反映出每个任务运行情况。&lt;/p&gt;
&lt;h3 id=&quot;任务栈&quot;&gt;2.6 任务栈&lt;/h3&gt;
&lt;p&gt;每一个任务都拥有一个独立的栈空间，我们称为任务栈。栈空间里保存的信息包含局部变量、寄存器、函数参数、函数返回地址等。任务在任务切换时会将切出任务的上下文信息保存在自身的任务栈空间里面，以便任务恢复时还原现场，从而在任务恢复后在切出点继续开始执行。&lt;/p&gt;
&lt;h3 id=&quot;任务切换&quot;&gt;2.7 任务切换&lt;/h3&gt;
&lt;p&gt;任务切换包含获取就绪列表中最高优先级任务、切出任务上下文保存、切入任务上下文恢复等动作。&lt;/p&gt;
&lt;h2 id=&quot;运作机制&quot;&gt;3 运作机制&lt;/h2&gt;
&lt;p&gt;Huawei LiteOS任务管理模块提供任务创建、任务延时、任务挂起和任务恢复、锁任务调度和解锁任务调度、根据任务控制块查询任务ID、根据ID查询任务控制块信息功能。&lt;/p&gt;
&lt;p&gt;在用户创建任务之前，系统会先申请任务控制块需要的内存空间，如果系统可用的内存空间小于其所需要的内存空间，任务模块就会初始化失败。如果任务初始化成功，&lt;/p&gt;
&lt;p&gt;用户创建任务时，系统会将任务栈进行初始化，预置上下文。此外，系统还会将“任务入口函数”地址放在相应位置。这样在任务第一次启动进入运行态时，将会执行“任务入口函数”。&lt;/p&gt;
&lt;h2 id=&quot;开发指导&quot;&gt;4. 开发指导&lt;/h2&gt;
&lt;h3 id=&quot;使用场景&quot;&gt;4.1 使用场景&lt;/h3&gt;
&lt;p&gt;任务创建后，内核可以执行锁任务调度，解锁任务调度，挂起，恢复，延时等操作，同时也可以设置任务优先级，获取任务优先级。任务结束的时候，如果任务的状态是自删除状态（LOS_TASK_STATUS_DETACHED），则进行当前任务自删除操作。&lt;/p&gt;
&lt;h3 id=&quot;功能&quot;&gt;4.2 功能&lt;/h3&gt;
&lt;p&gt;Huawei LiteOS 系统中的任务管理模块为用户提供下面几种功能。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;7&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;任务的创建和删除&lt;/td&gt;
&lt;td&gt;LOS_TaskCreateOnly&lt;/td&gt;
&lt;td&gt;创建任务，并使该任务进入suspend状态，并不调度&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;~&lt;/td&gt;
&lt;td&gt;LOS_TaskCreate&lt;/td&gt;
&lt;td&gt;创建任务，并使该任务进入ready状态，并调度&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;~&lt;/td&gt;
&lt;td&gt;LOS_TaskDelete&lt;/td&gt;
&lt;td&gt;删除指定的任务&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;~&lt;/td&gt;
&lt;td&gt;LOS_TaskDelete&lt;/td&gt;
&lt;td&gt;删除指定的任务&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;任务状态控制&lt;/td&gt;
&lt;td&gt;LOS_TaskResume&lt;/td&gt;
&lt;td&gt;恢复挂起的任务&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;~&lt;/td&gt;
&lt;td&gt;LOS_TaskSuspend&lt;/td&gt;
&lt;td&gt;挂起指定的任务&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;~&lt;/td&gt;
&lt;td&gt;LOS_TaskDelay&lt;/td&gt;
&lt;td&gt;任务延时等待&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;~&lt;/td&gt;
&lt;td&gt;LOS_TaskYield&lt;/td&gt;
&lt;td&gt;显式放权，调整指定优先级的任务调度顺序&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;任务调度的控制&lt;/td&gt;
&lt;td&gt;LOS_TaskLock&lt;/td&gt;
&lt;td&gt;锁任务调度&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;~&lt;/td&gt;
&lt;td&gt;LOS_TaskUnlock&lt;/td&gt;
&lt;td&gt;解锁任务调度&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;任务优先级的控制&lt;/td&gt;
&lt;td&gt;LOS_CurTaskPriSet&lt;/td&gt;
&lt;td&gt;设置当前任务的优先级&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;~&lt;/td&gt;
&lt;td&gt;LOS_TaskPriSet&lt;/td&gt;
&lt;td&gt;设置指定任务的优先级&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;~&lt;/td&gt;
&lt;td&gt;LOS_TaskPriGet&lt;/td&gt;
&lt;td&gt;获取指定任务的优先级&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;任务信息获取&lt;/td&gt;
&lt;td&gt;LOS_CurTaskIDGet&lt;/td&gt;
&lt;td&gt;获取当前任务的ID&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;~&lt;/td&gt;
&lt;td&gt;LOS_TaskInfoGet&lt;/td&gt;
&lt;td&gt;获取指定任务的信息&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;开发流程&quot;&gt;4.3 开发流程&lt;/h3&gt;
&lt;p&gt;以创建任务为例，讲解开发流程。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;在los_config.h中配置任务模块。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;配置LOSCFG_BASE_CORE_TSK_LIMIT系统支持最大任务数，这个可以根据需求自己配置。&lt;/p&gt;
&lt;p&gt;配置LOSCFG_BASE_CORE_TSK_IDLE_STACK_SIZE IDLE任务栈大小，这个默认即可。&lt;/p&gt;
&lt;p&gt;配置LOSCFG_BASE_CORE_TSK_DEFAULT_STACK_SIZE默认任务栈大小，用户根据自己的需求进行配置，在用户创建任务时，可以进行针对性设置。&lt;/p&gt;
&lt;p&gt;配置LOSCFG_BASE_CORE_TIMESLICE时间片开关为YES。&lt;/p&gt;
&lt;p&gt;配置LOSCFG_BASE_CORE_TIMESLICE_TIMEOUT时间片，根据实际情况自己配置。&lt;/p&gt;
&lt;p&gt;配置LOSCFG_BASE_CORE_TSK_MONITOR任务监测模块裁剪开关，可选择是否打开。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;锁任务LOS_TaskLock，锁住任务，防止高优先级任务调度。&lt;/li&gt;
&lt;li&gt;创建任务LOS_TaskCreate。&lt;/li&gt;
&lt;li&gt;解锁任务LOS_TaskUnlock，让任务按照优先级进行调度。&lt;/li&gt;
&lt;li&gt;延时任务LOS_TaskDelay，任务延时等待。&lt;/li&gt;
&lt;li&gt;挂起指定的任务LOS_TaskSuspend，任务挂起等待恢复操作。&lt;/li&gt;
&lt;li&gt;恢复挂起的任务LOS_TaskResume。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;task-状态&quot;&gt;4.4 TASK 状态&lt;/h3&gt;
&lt;p&gt;Huawei LiteOS任务的大多数状态由内核维护，唯有自删除状态对用户可见，需要用户在创建任务时传入：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;LOS_TASK_STATUS_DETACHED&lt;/td&gt;
&lt;td&gt;0x0080&lt;/td&gt;
&lt;td&gt;任务是自删除的&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;task-错误码&quot;&gt;4.5 TASK 错误码&lt;/h3&gt;
&lt;p&gt;对任务存在失败可能性的操作，包括创建任务、删除任务、挂起任务、恢复任务、延时任务等等，均需要返回对应的错误码，以便快速定位错误原因。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;49.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;LOS_ERRNO_TSK_NO_MEMORY&lt;/td&gt;
&lt;td&gt;0x03000200&lt;/td&gt;
&lt;td&gt;内存空间不足&lt;/td&gt;
&lt;td&gt;分配更大的内存空间&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;LOS_ERRNO_TSK_PTR_NULL&lt;/td&gt;
&lt;td&gt;0x02000201&lt;/td&gt;
&lt;td&gt;任务参数为空&lt;/td&gt;
&lt;td&gt;检查任务参数&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;LOS_ERRNO_TSK_STKSZ_NOT_ALIGN&lt;/td&gt;
&lt;td&gt;0x02000202&lt;/td&gt;
&lt;td&gt;任务栈大小未对齐&lt;/td&gt;
&lt;td&gt;对齐任务栈&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;LOS_ERRNO_TSK_PRIOR_ERROR&lt;/td&gt;
&lt;td&gt;0x02000203&lt;/td&gt;
&lt;td&gt;不正确的任务优先级&lt;/td&gt;
&lt;td&gt;检查任务优先级&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;LOS_ERRNO_TSK_ENTRY_NULL&lt;/td&gt;
&lt;td&gt;0x02000204&lt;/td&gt;
&lt;td&gt;任务入口函数为空&lt;/td&gt;
&lt;td&gt;定义任务入口函数&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;LOS_ERRNO_TSK_STKSZ_TOO_SMAL&lt;/td&gt;
&lt;td&gt;0x02000206&lt;/td&gt;
&lt;td&gt;任务栈太小&lt;/td&gt;
&lt;td&gt;扩大任务栈&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;LOS_ERRNO_TSK_ID_INVALID&lt;/td&gt;
&lt;td&gt;0x02000207&lt;/td&gt;
&lt;td&gt;无效的任务ID&lt;/td&gt;
&lt;td&gt;检查任务ID&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;LOS_ERRNO_TSK_ALREADY_SUSPENDED&lt;/td&gt;
&lt;td&gt;0x02000208&lt;/td&gt;
&lt;td&gt;任务已经被挂起&lt;/td&gt;
&lt;td&gt;等待这个任务被恢复后，再去尝试挂起这个任务&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;LOS_ERRNO_TSK_NOT_SUSPENDED&lt;/td&gt;
&lt;td&gt;0x02000209&lt;/td&gt;
&lt;td&gt;任务未被挂起&lt;/td&gt;
&lt;td&gt;挂起这个任务&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;11&lt;/td&gt;
&lt;td&gt;LOS_ERRNO_TSK_NOT_CREATED&lt;/td&gt;
&lt;td&gt;0x0200020a&lt;/td&gt;
&lt;td&gt;任务未被创建&lt;/td&gt;
&lt;td&gt;创建这个任务&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;6&quot;&gt;&lt;td&gt;12&lt;/td&gt;
&lt;td&gt;LOS_ERRNO_TSK_DELETE_LOCKED&lt;/td&gt;
&lt;td&gt;0x0300020b&lt;/td&gt;
&lt;td&gt;删除任务时，任务处于被锁状态&lt;/td&gt;
&lt;td&gt;等待解锁任务之后再进行删除操作&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;13&lt;/td&gt;
&lt;td&gt;LOS_ERRNO_TSK_MSG_NONZERO&lt;/td&gt;
&lt;td&gt;0x0200020c&lt;/td&gt;
&lt;td&gt;任务信息非零&lt;/td&gt;
&lt;td&gt;暂不使用该错误码&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;6&quot;&gt;&lt;td&gt;14&lt;/td&gt;
&lt;td&gt;LOS_ERRNO_TSK_DELAY_IN_INT&lt;/td&gt;
&lt;td&gt;0x0300020d&lt;/td&gt;
&lt;td&gt;中断期间，进行任务延时&lt;/td&gt;
&lt;td&gt;等待退出中断后再进行延时操作&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;6&quot;&gt;&lt;td&gt;15&lt;/td&gt;
&lt;td&gt;LOS_ERRNO_TSK_DELAY_IN_LOCK&lt;/td&gt;
&lt;td&gt;0x0200020e&lt;/td&gt;
&lt;td&gt;任务被锁的状态下，进行延时&lt;/td&gt;
&lt;td&gt;等待解锁任务之后再进行延时操作&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;16&lt;/td&gt;
&lt;td&gt;LOS_ERRNO_TSK_YIELD_INVALID_TASK&lt;/td&gt;
&lt;td&gt;0x0200020f&lt;/td&gt;
&lt;td&gt;将被排入行程的任务是无效的&lt;/td&gt;
&lt;td&gt;检查这个任务&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;17&lt;/td&gt;
&lt;td&gt;LOS_ERRNO_TSK_YIELD_NOT_ENOUGH_TASK&lt;/td&gt;
&lt;td&gt;0x02000210&lt;/td&gt;
&lt;td&gt;没有或者仅有一个可用任务能进行行程安排&lt;/td&gt;
&lt;td&gt;增加任务数&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;6&quot;&gt;&lt;td&gt;18&lt;/td&gt;
&lt;td&gt;LOS_ERRNO_TSK_TCB_UNAVAILABLE&lt;/td&gt;
&lt;td&gt;0x02000211&lt;/td&gt;
&lt;td&gt;没有空闲的任务控制块可用&lt;/td&gt;
&lt;td&gt;增加任务控制块数量&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;19&lt;/td&gt;
&lt;td&gt;LOS_ERRNO_TSK_HOOK_NOT_MATCH&lt;/td&gt;
&lt;td&gt;0x02000212&lt;/td&gt;
&lt;td&gt;任务的钩子函数不匹配&lt;/td&gt;
&lt;td&gt;暂不使用该错误码&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;20&lt;/td&gt;
&lt;td&gt;LOS_ERRNO_TSK_HOOK_IS_FULL&lt;/td&gt;
&lt;td&gt;0x02000213&lt;/td&gt;
&lt;td&gt;任务的钩子函数数量超过界限&lt;/td&gt;
&lt;td&gt;暂不使用该错误码&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;21&lt;/td&gt;
&lt;td&gt;LOS_ERRNO_TSK_OPERATE_IDLE&lt;/td&gt;
&lt;td&gt;0x02000214&lt;/td&gt;
&lt;td&gt;这是个IDLE任务&lt;/td&gt;
&lt;td&gt;检查任务ID，不要试图操作IDLE任务&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;6&quot;&gt;&lt;td&gt;22&lt;/td&gt;
&lt;td&gt;LOS_ERRNO_TSK_SUSPEND_LOCKED&lt;/td&gt;
&lt;td&gt;0x03000215&lt;/td&gt;
&lt;td&gt;将被挂起的任务处于被锁状态&lt;/td&gt;
&lt;td&gt;等待任务解锁后再尝试挂起任务&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;23&lt;/td&gt;
&lt;td&gt;LOS_ERRNO_TSK_FREE_STACK_FAILED&lt;/td&gt;
&lt;td&gt;0x02000217&lt;/td&gt;
&lt;td&gt;任务栈free失败&lt;/td&gt;
&lt;td&gt;该错误码暂不使用&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;24&lt;/td&gt;
&lt;td&gt;LOS_ERRNO_TSK_STKAREA_TOO_SMALL&lt;/td&gt;
&lt;td&gt;0x02000218&lt;/td&gt;
&lt;td&gt;任务栈区域太小&lt;/td&gt;
&lt;td&gt;该错误码暂不使用&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;25&lt;/td&gt;
&lt;td&gt;LOS_ERRNO_TSK_ACTIVE_FAILED&lt;/td&gt;
&lt;td&gt;0x03000219&lt;/td&gt;
&lt;td&gt;任务触发失败&lt;/td&gt;
&lt;td&gt;创建一个IDLE任务后执行任务转换&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;26&lt;/td&gt;
&lt;td&gt;LOS_ERRNO_TSK_CONFIG_TOO_MANY&lt;/td&gt;
&lt;td&gt;0x0200021a&lt;/td&gt;
&lt;td&gt;过多的任务配置项&lt;/td&gt;
&lt;td&gt;该错误码暂不使用&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;27&lt;/td&gt;
&lt;td&gt;LOS_ERRNO_TSK_CP_SAVE_AREA_NOT_ALIGN&lt;/td&gt;
&lt;td&gt;0x0200021b&lt;/td&gt;
&lt;td&gt;暂无&lt;/td&gt;
&lt;td&gt;该错误码暂不使用&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;28&lt;/td&gt;
&lt;td&gt;LOS_ERRNO_TSK_MSG_Q_TOO_MANY&lt;/td&gt;
&lt;td&gt;0x0200021d&lt;/td&gt;
&lt;td&gt;暂无&lt;/td&gt;
&lt;td&gt;该错误码暂不使用&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;29&lt;/td&gt;
&lt;td&gt;LOS_ERRNO_TSK_CP_SAVE_AREA_NULL&lt;/td&gt;
&lt;td&gt;0x0200021e&lt;/td&gt;
&lt;td&gt;暂无&lt;/td&gt;
&lt;td&gt;该错误码暂不使用&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;30&lt;/td&gt;
&lt;td&gt;LOS_ERRNO_TSK_SELF_DELETE_ERR&lt;/td&gt;
&lt;td&gt;0x0200021f&lt;/td&gt;
&lt;td&gt;暂无&lt;/td&gt;
&lt;td&gt;该错误码暂不使用&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;31&lt;/td&gt;
&lt;td&gt;LOS_ERRNO_TSK_STKSZ_TOO_LARGE&lt;/td&gt;
&lt;td&gt;0x02000220&lt;/td&gt;
&lt;td&gt;任务栈大小设置过大&lt;/td&gt;
&lt;td&gt;减小任务栈大小&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;7&quot;&gt;&lt;td&gt;32&lt;/td&gt;
&lt;td&gt;LOS_ERRNO_TSK_SUSPEND_SWTMR_NOT_ALLOWED&lt;/td&gt;
&lt;td&gt;0x02000221&lt;/td&gt;
&lt;td&gt;不允许挂起软件定时器任务&lt;/td&gt;
&lt;td&gt;检查任务ID, 不要试图挂起软件定时器任务&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;错误码定义：错误码是一个32位的存储单元， 31~24位表示错误等级， 23~16位表示错误码标志， 15~8位代表错误码所属模块， 7~0位表示错误码序号，如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#define LOS_ERRNO_OS_NORMAL(MID,ERRNO) \
(LOS_ERRTYPE_NORMAL | LOS_ERRNO_OS_ID | ((UINT32)(MID) &amp;lt;&amp;lt; 8) | (ERRNO))
LOS_ERRTYPE_NORMAL ：Define the error level as critical
LOS_ERRNO_OS_ID ：OS error code flag.
MID：OS_MOUDLE_ID
ERRNO：error ID number&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;LOS_ERRNO_TSK_NO_MEMORY LOS_ERRNO_OS_FATAL(LOS_MOD_TSK, 0x00)&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;平台差异性&quot;&gt;4.6 平台差异性&lt;/h3&gt;
&lt;p&gt;无&lt;/p&gt;
&lt;h3 id=&quot;编程实例&quot;&gt;4.7 编程实例&lt;/h3&gt;
&lt;h4 id=&quot;实例描述&quot;&gt;4.7.1 实例描述&lt;/h4&gt;
&lt;p&gt;下面的示例介绍任务的基本操作方法，包含任务创建、任务延时、任务锁与解锁调度、挂起和恢复、查询当前任务PID、根据PID查询任务信息等操作，阐述任务优先级调度的机制以及各接口的应用。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;创建了2个任务:TaskHi和TaskLo。&lt;/li&gt;
&lt;li&gt;TaskHi为高优先级任务。&lt;/li&gt;
&lt;li&gt;TaskLo为低优先级任务。&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;编程示例&quot;&gt;4.7.2 编程示例&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;UINT32 g_uwTskLoID;
UINT32 g_uwTskHiID;
#define TSK_PRIOR_HI 4
#define TSK_PRIOR_LO 5
UINT32 Example_TaskHi()
{
    UINT32 uwRet;
    UINT32 uwCurrentID;
    TSK_INFO_S stTaskInfo;
    printf(&quot;Enter TaskHi Handler.\r\n&quot;);
    /*延时2个Tick，延时后该任务会挂起，执行剩余任务中最高优先级的任务(g_uwTskLoID任务)*/
    uwRet = LOS_TaskDelay(2);
    if (uwRet != LOS_OK)
    {
        printf(&quot;Delay Task Failed.\r\n&quot;);
        return LOS_NOK;
    }
    /*2个Tick时间到了后，该任务恢复，继续执行*/
    printf(&quot;TaskHi LOS_TaskDelay Done.\r\n&quot;);
    /*挂起自身任务*/
    uwRet = LOS_TaskSuspend(g_uwTskHiID);
    if (uwRet != LOS_OK)
    {
        printf(&quot;Suspend TaskHi Failed.\r\n&quot;);
        return LOS_NOK;
    }
    printf(&quot;TaskHi LOS_TaskResume Success.\r\n&quot;);

}
/*低优先级任务入口函数*/
UINT32 Example_TaskLo()
{
    UINT32 uwRet;
    UINT32 uwCurrentID;
    TSK_INFO_S stTaskInfo;
    printf(&quot;Enter TaskLo Handler.\r\n&quot;);
    /*延时2个Tick，延时后该任务会挂起，执行剩余任务中就高优先级的任务(背景任务)*/
    uwRet = LOS_TaskDelay(2);
    if (uwRet != LOS_OK)
    {
        printf(&quot;Delay TaskLo Failed.\r\n&quot;);
        return LOS_NOK;
    }
    printf(&quot;TaskHi LOS_TaskSuspend Success.\r\n&quot;);
    /*恢复被挂起的任务g_uwTskHiID*/
    uwRet = LOS_TaskResume(g_uwTskHiID);
    if (uwRet != LOS_OK)
    {
        printf(&quot;Resume TaskHi Failed.\r\n&quot;);
        return LOS_NOK;
    }
    
    printf(&quot;TaskHi LOS_TaskDelete Success.\r\n&quot;);
}

/*任务测试入口函数，在里面创建优先级不一样的两个任务*/
UINT32 Example_TskCaseEntry(VOID)
{
    UINT32 uwRet;
    TSK_INIT_PARAM_S stInitParam;
    /*锁任务调度*/
    LOS_TaskLock();
    printf(&quot;LOS_TaskLock() Success!\r\n&quot;);
    
    stInitParam.pfnTaskEntry = (TSK_ENTRY_FUNC)Example_TaskHi;
    
    stInitParam.usTaskPrio = TSK_PRIOR_HI;
    stInitParam.pcName = &quot;HIGH_NAME&quot;;
    stInitParam.uwStackSize = 0x400;
    stInitParam.uwResved = LOS_TASK_STATUS_DETACHED;
    
    /*创建高优先级任务，由于锁任务调度，任务创建成功后不会马上执行*/                    uwRet = LOS_TaskCreate(&amp;amp;g_uwTskHiID, &amp;amp;stInitParam);
    if (uwRet != LOS_OK)
    {
        LOS_TaskUnlock();
        printf(&quot;Example_TaskHi create Failed!\r\n&quot;);
        return LOS_NOK;
    }
    printf(&quot;Example_TaskHi create Success!\r\n&quot;);
    stInitParam.pfnTaskEntry = (TSK_ENTRY_FUNC)Example_TaskLo;
    stInitParam.usTaskPrio = TSK_PRIOR_LO;
    stInitParam.pcName = &quot;LOW_NAME&quot;;
    stInitParam.uwStackSize = 0x400;
    stInitParam.uwResved = LOS_TASK_STATUS_DETACHED;
    /*创建低优先级任务，由于锁任务调度，任务创建成功后不会马上执行*/
    uwRet = LOS_TaskCreate(&amp;amp;g_uwTskLoID, &amp;amp;stInitParam);
    if (uwRet != LOS_OK)
    {
        LOS_TaskUnlock();
        printf(&quot;Example_TaskLo create Failed!\r\n&quot;);
        return LOS_NOK;
    }
    printf(&quot;Example_TaskLo create Success!\r\n&quot;);
    /*解锁任务调度，此时会发生任务调度，执行就绪列表中最高优先级任务*/
    LOS_TaskUnlock();
    while(1){};
    return LOS_OK;
}      &lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;结果验证&quot;&gt;4.7.3 结果验证&lt;/h4&gt;
&lt;p&gt;编译运行得到的结果为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811006/201905/811006-20190521145530108-949969545.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 21 May 2019 06:57:00 +0000</pubDate>
<dc:creator>yooooooo</dc:creator>
<og:description>任务 1 基本概念 从系统的角度看，任务是竞争系统资源的最小运行单元。任务可以使用或等待CPU、使用内存空间等系统资源，并独立于其它任务运行。 Huawei LiteOS的任务模块可以给用户提供多个任</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/linhaostudy/p/10898995.html</dc:identifier>
</item>
<item>
<title>Android-毛笔的探索与开发 - .double</title>
<link>http://www.cnblogs.com/doubleWin/p/10898807.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/doubleWin/p/10898807.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt; &lt;span&gt;前言&lt;/span&gt;&lt;/strong&gt;                                                                     &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这篇文章主要是关于移动端毛笔的开发，在平板上有着书写毛笔字贴的效果。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;介绍关于毛笔的算法思路。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;项目github地址&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;算法思路分析&lt;/strong&gt;&lt;/span&gt;                                                              &lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;曲线拟合算法&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;利用曲线拟合算法增加虚拟的点，使得笔迹更加光滑，关于算法思想本文采用的是B样条插值算法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;采集点：获取笔输出的两个关键点a1、a2，以及a1和a2附近的几个点a3,a4;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;拟合点：利用a1,a2,a3,a4计算出a1和a2之间曲线的步长，再根据步长计算出a1与a2之间所有的点，所&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;计算出的点即为曲线上的点；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;简单图示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1591686/201904/1591686-20190423113704020-191785903.png&quot; alt=&quot;&quot; width=&quot;515&quot; height=&quot;358&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;圆形填充轮廓粗糙算法&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;利用圆形填充思想来实现毛笔的效果，并进行轮廓的粗糙，使其更加形象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;获取笔宽：获取到a1与a2两点笔的压力，转换成对应的宽度作为此段起点和终点的宽度d1,d2，以d1与、&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;d2差再除以a1与a2点之间的个数得到曲线点之间笔宽的差值，再计算出该段曲线上所有点a1,b1...bn,a2&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对应的笔宽l1...ln；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;计算圆形：利用曲线上的点和对应的笔宽计算出圆形，利用图形模块的填充效果将圆形填充；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;处理轮廓处：对于每个笔迹的轮廓处，根据当前点与上一个点的斜率K的大小来画不同长度的线，线的颜色&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;深浅也会渐变；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;简单图示（实践的圆形点会更加稠密，所以轮廓几乎是直线）：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1591686/201905/1591686-20190521141901755-1246049727.png&quot; alt=&quot;&quot; width=&quot;550&quot; height=&quot;382&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1591686/201905/1591686-20190521142750154-1176054912.png&quot; alt=&quot;&quot; width=&quot;542&quot; height=&quot;375&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt; &lt;span&gt;项目地址&lt;/span&gt;&lt;/strong&gt;                                                                  &lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;关于github代码地址：&lt;a href=&quot;https://github.com/doubledouble123/Pens&quot; target=&quot;_blank&quot;&gt;https://github.com/doubledouble123/Pens&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;手写效果展示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1591686/201905/1591686-20190521140435426-686550808.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;                                                                      &lt;/span&gt; &lt;span&gt;   &lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本文通过曲线拟合算法和圆形填充轮廓粗糙算法完成了毛笔效果的实现，增加了平板毛笔字帖的书写体验。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 21 May 2019 06:31:00 +0000</pubDate>
<dc:creator>.double</dc:creator>
<og:description>前言 这篇文章主要是关于移动端毛笔的开发，在平板上有着书写毛笔字贴的效果。 介绍关于毛笔的算法思路。 项目github地址 算法思路分析 曲线拟合算法 利用曲线拟合算法增加虚拟的点，使得笔迹更加光滑，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/doubleWin/p/10898807.html</dc:identifier>
</item>
<item>
<title>使用vs2019进行Linux远程开发 - apocelipes</title>
<link>http://www.cnblogs.com/apocelipes/p/10899484.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/apocelipes/p/10899484.html</guid>
<description>&lt;p&gt;通常，当我们开发Linux程序时有两种方案：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;在Linux上直接编写程序并进行运行测试和调试&lt;/li&gt;
&lt;li&gt;在Windows或Mac OS X上借助工具进行远程开发&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;虽然我自己是在Linux环境上直接进行开发的，但也有许多的人是在Windows环境上从事开发工作的，如果离开自己熟悉的系统到陌生的环境上也许会影响到工作效率。&lt;/p&gt;
&lt;p&gt;因此今天我们就来看下如何在Windows上使用Visual Studio 2019进行Linux远程开发以及如何避免常见的陷阱。&lt;/p&gt;
&lt;blockquote id=&quot;bookmark&quot;&gt;
&lt;h4&gt;本文索引&lt;/h4&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;visual-studio的跨平台开发功能简介&quot;&gt;Visual Studio的跨平台开发功能简介&lt;/h2&gt;
&lt;p&gt;从visual studio 2017开始微软推出了vs的跨平台开发功能，你可以在vs中编辑代码，随后进行跨平台编译和远程调试，将原先我们需要手动完成的工作进行了自动化，大幅减轻了我们的负担。其中支持的平台包括Android和Linux，也就是我们今天要重点介绍的主角。&lt;/p&gt;
&lt;p&gt;也许你会好奇，vs究竟是怎样进行远程开发的，虽然你不用了解这些知识也可以进行开发，但我还是希望能用两分钟做个简短的解释。&lt;/p&gt;
&lt;p&gt;vs进行远程开发分为两步：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;创建远程环境的连接，随后让vs将远程环境中的系统头文件同步到本地（也可以指定其他地方的头文件，后面会讲解），c++的代码补全只需要头文件即可。&lt;/li&gt;
&lt;li&gt;当代码写好后，选择合适的远程环境，vs将目标文件和代码复制到远程环境的指定位置，接着根据你的配置进行编译。&lt;/li&gt;
&lt;li&gt;随后vs将会在console的gdb或gdbserver中运行你的程序，在此期间你可以充分享受vs debugger带来的高效和便利。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;经过上述步骤之后你就可以在vs里调试自己编写的跨平台程序了。&lt;/p&gt;
&lt;h2 id=&quot;使用vs2019进行linux远程开发&quot;&gt;使用vs2019进行Linux远程开发&lt;/h2&gt;
&lt;p&gt;简介到此结束了，下面我们来看看在vs2019进行Linux开发的图文教程。在我们开始之前，首先要做点准备工作：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;安装好vs2019，且勾选了c++ for Linux功能；&lt;/li&gt;
&lt;li&gt;准备一个可用的Linux远程环境，例如配置了静态IP的Linux虚拟机，并且已经安装好了GCC工具链以及openssh。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;做好准备后我们就该进入正题了。&lt;/p&gt;
&lt;h3 id=&quot;创建项目&quot;&gt;创建项目&lt;/h3&gt;
&lt;p&gt;安装好c++ for Linux功能后我们会在创建新项目的面板中看到Linux的选项，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1434464/201905/1434464-20190521140506627-1481698299.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里我们选择了使用传统的vs项目解决方案构建的空白控制台程序，后续的文章中你还可以看到如何创建cmake项目，这里暂且不提。&lt;/p&gt;
&lt;p&gt;下面没什么要说的，选择项目的存储位置，注意是本地的位置，远程机器的位置在后面会进行配置：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1434464/201905/1434464-20190521140454785-1039927592.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击创建，我们的远程开发项目就创建成功了。&lt;/p&gt;
&lt;h3 id=&quot;配置远程项目&quot;&gt;配置远程项目&lt;/h3&gt;
&lt;p&gt;vs不能编辑空项目的配置，所以我们先在项目中创建一个&lt;code&gt;main.cpp&lt;/code&gt;，然后点击顶部菜单：项目-&amp;gt;属性，你就能看到项目的配置界面了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1434464/201905/1434464-20190521140426607-561286254.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;远程计算机是在调试中的远程连接管理器中添加的。这里一般不需要改动，除非你需要改变项目的类型或编译结果的存放位置。如果有多个远程环境时，也可以在这里进行选择。&lt;/p&gt;
&lt;p&gt;调试部分提供了&lt;code&gt;gdb&lt;/code&gt;和&lt;code&gt;gdbserver&lt;/code&gt;，前者是让vs在Linux上启动一个console，然后在其中运行gdb并返回输出，如果你的Linux上的终端配置了彩色输出，那么和遗憾vs并不认识他们，会显示成原始的字符串；使用gdbserver时会在远程启用gdbserver，本地vs解析回传的数据不会出现杂音。这里我们选择了gdbserver，如果你发现无法打断点，那么参考微软的建议，换回gdb方案：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1434464/201905/1434464-20190521140416532-6821507.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接着是配置的重点，首先是配置需要同步的远程环境的头文件，有了这些文件vs才能对你的代码进行自动补全和提示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1434464/201905/1434464-20190521140403283-329660193.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;默认复制的路径通常已经包含了Linux上大部分的头文件，通常我们也不需要做更改。头文件的同步发生在第一次构建项目成功后或添加远程连接后手动同步。&lt;/p&gt;
&lt;p&gt;接着是c/c++编译器的选择，也就是对gcc和g++编译参数的配置，讲解这些参数超出了我们的讨论范围，我们这里只需要选择合适的c++标准版本：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1434464/201905/1434464-20190521140352922-1933981338.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里我们选择了c++17。其他设置与在Windows上进行开发时一样，vs可以自动转换成g++的参数，这里就不再赘述。&lt;/p&gt;
&lt;h3 id=&quot;添加远程环境&quot;&gt;添加远程环境&lt;/h3&gt;
&lt;p&gt;有了远程环境我们才能同步头文件或者进行调试运行。&lt;/p&gt;
&lt;p&gt;在第一次编译或调试你的项目时vs会自动让你连接远程环境，当然，我们推荐在调试-&amp;gt;选项-&amp;gt;跨平台-&amp;gt;连接管理器中进行设置：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1434464/201905/1434464-20190521140328766-1889942929.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;填入你的远程ip/域名，端口ssh默认为22，安全起见你需要修改成其他端口，这里方便演示使用了默认配置，密码同上，你应该考虑使用更安全的ssh私钥登录。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1434464/201905/1434464-20190521140321318-1338210444.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;登录成功后这个连接就添加完成了，我们看到管理器下面还有一个远程标头管理器的设置项，这就是用来同步头文件的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1434464/201905/1434464-20190521140305692-394021647.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击更新按钮就会开始同步头文件，这些文件会被缓存在本地，因为要从远程一次性复制大量文件，所以可能会花费较长的时间。&lt;/p&gt;
&lt;p&gt;这样远程环境就添加好了，可以开始写代码了。&lt;/p&gt;
&lt;h3 id=&quot;本地编写和远程调试&quot;&gt;本地编写和远程调试&lt;/h3&gt;
&lt;p&gt;至此你已经可以在vs中编写面向Linux平台的代码了，自动补全可以正常工作：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1434464/201905/1434464-20190521140248599-1884281232.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1434464/201905/1434464-20190521140239541-1182711169.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到Linux中的头文件和结构体都已经可以识别了。如果你发现无法自动补全（通常发生在刚添加远程连接或是项目设置发生了变化后），先试试关闭vs重新打开，如果没用请尝试刷新intellisense或重新同步头文件。&lt;/p&gt;
&lt;p&gt;在编辑结束后我们就能点击调试按钮运行我们的程序了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1434464/201905/1434464-20190521140225231-1754425332.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意，构建的体系架构必须是和远程环境一致的，比如远程环境是x64，这里可以选择x64或x86，但是不能选择arm，否则会报错。&lt;/p&gt;
&lt;p&gt;这是测试代码，它将输出当前Linux系统内核的版本：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include &amp;lt;sys/utsname.h&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstdio&amp;gt;

int main()
{
    auto start = chrono::high_resolution_clock::now();
    utsname names;
    if (uname(&amp;amp;names) != 0) {
        std::perror(&quot;cannot get unames&quot;);
    }

    std::cout &amp;lt;&amp;lt; &quot;Linux kernel version: &quot; &amp;lt;&amp;lt; names.release &amp;lt;&amp;lt; std::endl;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;点击调试-&amp;gt;Linux 控制台，会显示一个可以交互的console，你可以在其中输入内容或是看到程序的输出：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1434464/201905/1434464-20190521140208985-727534857.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;程序运行成功。&lt;/p&gt;
&lt;h2 id=&quot;避免踩坑&quot;&gt;避免踩坑&lt;/h2&gt;
&lt;p&gt;远程编译顺利完成后，我们就可以接着利用vs debugger设置断点，在断点处查看变量，甚至对运行中的Linux进行动态性能分析了。&lt;/p&gt;
&lt;p&gt;不过在此之前，还有一些坑需要提前踩掉。&lt;/p&gt;
&lt;h3 id=&quot;中文乱码&quot;&gt;中文乱码&lt;/h3&gt;
&lt;p&gt;编码问题带来的麻烦永远会被放在第一位，毕竟当人们看到预想的输出实际上是一堆乱码时总会不可避免得紧张起来。&lt;/p&gt;
&lt;p&gt;众所周知，编码问题一直是老大难，特别是Windows上中文环境通常是GB18030或GBK，而Linux上统一为utf8时。&lt;/p&gt;
&lt;p&gt;下面看个实际例子，通常我们的程序里只包含ASCII字符的话不容易产生问题，所以我们加上一点中文字符：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include &amp;lt;sys/utsname.h&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;string&amp;gt;

int main()
{
    utsname names;
    if (uname(&amp;amp;names) != 0) {
        std::perror(&quot;cannot get unames&quot;);
    }

    std::cout &amp;lt;&amp;lt; &quot;Linux kernel version: &quot; &amp;lt;&amp;lt; names.release &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &quot;输入内容：&quot;;
    std::string input;
    std::cin &amp;gt;&amp;gt; input;
    std::cout &amp;lt;&amp;lt; &quot;你输入了：&quot; &amp;lt;&amp;lt; input &amp;lt;&amp;lt; std::endl;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于上面的测试程序，我们添加了一点中文输出信息，现在打开控制台进行调试：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1434464/201905/1434464-20190521140143537-1591750999.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到中文输出变成了乱码，我们输入一些信息进去，这是运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1434464/201905/1434464-20190521140123729-1666194727.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，程序内写入的中文发生了乱码，而我们的输入没有。原因很简单，输入时实在linux的控制台环境下，编码默认是utf8的，所以我们的输入被正确编码，而源文件中的内容是GB18030的，所以在Linux控制台（默认以utf8解码数据并显示）中会发生乱码。&lt;/p&gt;
&lt;p&gt;错误的原因知道了解决起来也就很简单了，把源文件的编码改成utf8就行，我们选择最简单的方法，在&lt;code&gt;高级保存选项&lt;/code&gt;中修改编码（这个菜单选项默认被隐藏，网上有很多介绍如何显示它的方法的资料）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1434464/201905/1434464-20190521140106961-2136983044.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;设置好后保存文件，现在文件的编码已经被改为了utf8了。&lt;/p&gt;
&lt;p&gt;现在运行修改后的程序：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1434464/201905/1434464-20190521140048378-2110566588.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;运行结果也是正常的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1434464/201905/1434464-20190521140037078-1892417993.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;使用数学函数和第三方库&quot;&gt;使用数学函数和第三方库&lt;/h3&gt;
&lt;p&gt;在Linux上使用标准库提供的数学函数也是一个老生常谈的问题，根据你使用cpp还是c会有如下几个情况：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;使用cpp时，libstdc++依赖于libm，所以使用g++编译你的程序时会自动链接数学函数库；&lt;/li&gt;
&lt;li&gt;使用c时，如果是&lt;code&gt;sqrt(4)&lt;/code&gt;这样的形式，较新的gcc提供了替换措施，不需要显示链接libm；&lt;/li&gt;
&lt;li&gt;接上一条，如果你的参数是个变量，那么编译器可能会选择需要你链接libm。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;通常在Windows上我们无需操心这点，但在Linux上使用c语言时就很难忽略这个问题了。&lt;/p&gt;
&lt;p&gt;因此保险起见，如果你正在编写一个使用了数学函数的c程序，那么总是指定连接libm是没错的。（具体可以参考&lt;a href=&quot;http://www.linuxforums.org/forum/programming-scripting/125526-c-gcc-math-h-lm.html&quot;&gt;这里&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;另外当你使用例如boost这类第三方库时，也需要注意。在Windows上我们通常指定好附加包含目录和附加库目录即可正常编译，但是Linux上必须明确指定链接库的名字，因此我们在项目属性中进行设置。&lt;/p&gt;
&lt;p&gt;在Linux上我们可以使用pkg-config来减轻上述的重复劳动，而在vs中我们不能直接利用这一工具，当你的项目使用了大量第三方库时就会成为不小的麻烦，如果想要解决这一问题，可以参考后续文章里我会介绍的vs+cmake构建项目。&lt;/p&gt;
&lt;p&gt;下面我们给例子加上一点boost chrono的功能测试，在Linux上需要指定&lt;code&gt;-lboost_chrono&lt;/code&gt;，这是设置：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1434464/201905/1434464-20190521140013330-2002160939.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面是完整的代码：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include &amp;lt;sys/utsname.h&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;boost/chrono.hpp&amp;gt;

int main()
{
    namespace chrono = boost::chrono;
    auto start = chrono::high_resolution_clock::now();
    utsname names;
    if (uname(&amp;amp;names) != 0) {
        std::perror(&quot;cannot get unames&quot;);
    }

    std::cout &amp;lt;&amp;lt; &quot;Linux kernel version: &quot; &amp;lt;&amp;lt; names.release &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &quot;输入内容：&quot;;
    std::string input;
    std::cin &amp;gt;&amp;gt; input;
    std::cout &amp;lt;&amp;lt; &quot;你输入了：&quot; &amp;lt;&amp;lt; input &amp;lt;&amp;lt; std::endl;
    auto counter = chrono::duration_cast&amp;lt;chrono::milliseconds&amp;gt;(chrono::high_resolution_clock::now() - start);
    std::cout &amp;lt;&amp;lt; &quot;程序运行了：&quot; &amp;lt;&amp;lt; counter.count() &amp;lt;&amp;lt; &quot;ms\n&quot;;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;点击运行按钮，程序就能正常调试了，否则会报错：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1434464/201905/1434464-20190521135953030-977481405.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 21 May 2019 06:07:00 +0000</pubDate>
<dc:creator>apocelipes</dc:creator>
<og:description>通常，当我们开发Linux程序时有两种方案： 1. 在Linux上直接编写程序并进行运行测试和调试 2. 在Windows或Mac OS X上借助工具进行远程开发 虽然我自己是在Linux环境上直接进</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/apocelipes/p/10899484.html</dc:identifier>
</item>
<item>
<title>js 调用栈机制与ES6尾调用优化介绍 - OBKoro1</title>
<link>http://www.cnblogs.com/OBkoro1/p/10899391.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/OBkoro1/p/10899391.html</guid>
<description>&lt;p&gt;调用栈的英文名叫做Call Stack，大家或多或少是有听过的，但是对于js调用栈的工作方式以及如何在工作中利用这一特性，大部分人可能没有进行过更深入的研究，这块内容可以说对我们前端来说就是所谓的基础知识，咋一看好像用处并没有很大，但掌握好这个知识点，就可以让我们在以后可以走的更远，走的更快！&lt;/p&gt;
&lt;blockquote readability=&quot;0.9375&quot;&gt;
&lt;p&gt;&lt;a href=&quot;http://obkoro1.com/&quot;&gt;博客&lt;/a&gt;、&lt;a href=&quot;http://obkoro1.com/web_accumulate/accumulate/&quot;&gt;前端积累文档&lt;/a&gt;、&lt;a href=&quot;https://user-gold-cdn.xitu.io/2018/5/1/1631b6f52f7e7015?w=344&amp;amp;h=344&amp;amp;f=jpeg&amp;amp;s=8317&quot;&gt;公众号&lt;/a&gt;、&lt;a href=&quot;https://github.com/OBKoro1&quot;&gt;GitHub&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;h3 id=&quot;目录&quot;&gt;目录&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;数据结构：栈&lt;/li&gt;
&lt;li&gt;调用栈是什么？用来做什么？&lt;/li&gt;
&lt;li&gt;调用栈的运行机制&lt;/li&gt;
&lt;li&gt;调用栈优化内存&lt;/li&gt;
&lt;li&gt;调用栈debug大法&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;数据结构栈&quot;&gt;数据结构：栈&lt;/h3&gt;
&lt;p&gt;栈是一种遵从&lt;strong&gt;后进先出(&lt;code&gt;LIFO&lt;/code&gt;)原则的有序集合&lt;/strong&gt;，新元素都靠近栈顶，旧元素都接近栈底。&lt;/p&gt;
&lt;p&gt;生活中的栗子，帮助一下理解：&lt;/p&gt;
&lt;p&gt;餐厅里面堆放的盘子(栈)，一开始放的都在下面(先进)，后面放的都在上面(后进)，洗盘子的时候先从上面开始洗(先出)。&lt;/p&gt;
&lt;h3 id=&quot;调用栈是什么用来做什么&quot;&gt;调用栈是什么？用来做什么？&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;调用栈是一种栈结构的数据，它是由调用侦组成的&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;调用栈记录了函数的执行顺序和函数内部变量等信息&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;调用栈的运行机制&quot;&gt;调用栈的运行机制&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;机制&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;程序运行到一个函数，它就会将其添加到调用栈中，当从这个函数返回的时候，就会将这个函数从调用栈中删掉。&lt;/p&gt;
&lt;p&gt;看一下例子帮助理解：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// 调用栈中的执行步骤用数字表示
printSquare(5); // 1 添加
function printSquare(x) {
    var s = multiply(x, x); // 2 添加 =&amp;gt; 3 运行完成，内部没有再调用其他函数，删掉
    console.log(s); // 4 添加 =&amp;gt; 5 删掉
    // 运行完成 删掉printSquare
}
function multiply(x, y) {
    return x * y;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;调用栈中的执行步骤如下(删除multiply的步骤被省略了)：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/5/18/16acb4a439190d49?w=1024&amp;amp;h=768&amp;amp;f=png&amp;amp;s=68010&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;调用侦&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;每个进入到调用栈中的函数，都会分配到一个单独的栈空间，称为“调用侦”。&lt;/p&gt;
&lt;p&gt;在调用栈中每个“调用侦”都对应一个函数，最上方的调用帧称为“当前帧”，调用栈是由所有的调用侦形成的。&lt;/p&gt;
&lt;p&gt;找到一张图片，调用侦：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/5/19/16ace8030a36c8dd?w=326&amp;amp;h=440&amp;amp;f=png&amp;amp;s=50219&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;调用栈优化内存&quot;&gt;调用栈优化内存&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;调用栈的内存消耗&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;如上图，函数的变量等信息会被调用侦保存起来，所以&lt;strong&gt;调用侦中的变量不会被垃圾收集器回收&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;当函数嵌套的层级比较深了，调用栈中的调用侦比较多的时候，这些信息对内存消耗是非常大的。&lt;/p&gt;
&lt;p&gt;针对这种情况除了我们要尽量避免函数层级嵌套的比较深之外，ES6提供了“尾调用优化”来解决调用侦过多，引起的内存消耗过大的问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;何谓尾调用&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;尾调用指的是：&lt;strong&gt;函数的最后一步是调用另一个函数&lt;/strong&gt;。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;function f(x){
  return g(x); // 最后一步调用另一个函数并且使用return
}
function f(x){
  g(x); // 没有return 不算尾调用 因为不知道后面还有没有操作
  // return undefined; // 隐式的return
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;尾调用优化优化了什么？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;尾调用用来&lt;strong&gt;删除外层无用的调用侦&lt;/strong&gt;，只保留内层函数的调用侦，来节省浏览器的内存。&lt;/p&gt;
&lt;p&gt;下面这个例子调用栈中的调用侦一直只有一项，如果不使用尾调用的话会出现三个调用侦：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;a() // 1 添加a到调用栈
function a(){
    return b(); // 在调用栈中删除a 添加b
}
function b(){
    return c() // 删除b 添加c
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;防止爆栈&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;浏览器对&lt;a href=&quot;https://codeday.me/bug/20170824/62171.html&quot;&gt;调用栈都有大小限制&lt;/a&gt;，在ES6之前递归比较深的话，很容易出现“爆栈”问题(stack overflow)。&lt;/p&gt;
&lt;p&gt;现在可以使用“尾调用优化”来写一个“尾递归”，只保存一个调用侦，来防止爆栈问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧。&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;如果要使用外层函数的变量，可以通过参数的形式传到内层函数中&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;function a(){
    var aa = 1;
    let b = val =&amp;gt; aa + val // 使用了外层函数的参数aa
    return b(2) // 无法进行尾调用优化
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;尾调用优化只在严格模式下开启，非严格模式是无效的。&lt;/li&gt;
&lt;li&gt;如果环境不支持“尾调用优化”，代码还可以正常运行，是无害的！&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;更多&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;关于尾递归以及更多尾调用优化的内容，推荐查阅&lt;a href=&quot;http://es6.ruanyifeng.com/#docs/function#%E5%B0%BE%E8%B0%83%E7%94%A8%E4%BC%98%E5%8C%96&quot;&gt;ES6入门-阮一峰&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;调用栈debug大法&quot;&gt;调用栈debug大法&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;查看调用栈有什么用&lt;/strong&gt;&lt;/p&gt;
&lt;ol readability=&quot;0.5&quot;&gt;&lt;li&gt;查看函数的调用顺序是否跟预期一致，比如不同判断调用不同函数。&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;快速定位问题/修改三方库的代码。&lt;/p&gt;
&lt;p&gt;当接手一个历史项目，或者引用第三方库出现问题的时候，可以先查看对应API的调用栈，找到其中涉及的关键函数，针对性的修复它。&lt;/p&gt;
&lt;p&gt;通过查看调用栈的形式，帮助我快速定位问题，修改三方库的源码。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;如何查看调用栈&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;只查看调用栈：&lt;code&gt;console.trace&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;a()
function a() {
    b();
}
function b() {
    c()
}
function c() {
    let aa = 1;
    console.trace()
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如图所示,点击右侧还能查看代码位置：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/5/20/16ad3f508ab127a9?w=678&amp;amp;h=318&amp;amp;f=png&amp;amp;s=29341&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;bugger&lt;/code&gt;打断点形式，这也是我最喜欢的调试方式：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/5/20/16ad3ff354f2dac3?w=2024&amp;amp;h=1240&amp;amp;f=png&amp;amp;s=339262&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;积跬步以至千里&quot;&gt;积跬步以至千里&lt;/h3&gt;
&lt;p&gt;平时需要有意识的去做这种小的优化(我现在就是)，尽量写最佳实践的代码。&lt;/p&gt;
&lt;p&gt;项目小的时候可能没什么影响，当一个项目体量大的时候，尤其是一些小方法拼接嵌套成一个大的API输出时，这时调用栈中对内存的消耗将是巨大的！这种优化也是不可小觑的，积跬步以至千里，诸君共勉！&lt;/p&gt;
&lt;h2 id=&quot;结语&quot;&gt;结语&lt;/h2&gt;
&lt;p&gt;本文主要讲了这几个方面的内容：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;理解调用栈的运行机制，对代码背后的一些执行机制也可以更加了解，帮助我们在百尺竿头更进一步。&lt;/li&gt;
&lt;li&gt;我们应该在日常的code中，有意识的使用ES6的“尾调用优化”，来减少调用栈的长度，节省客户端内存。&lt;/li&gt;
&lt;li&gt;利用调用栈，对第三方库或者不熟悉的项目，可以更快速的定位问题，提高我们debug速度。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;最后：之前写过一篇关于&lt;a href=&quot;https://juejin.im/post/5b40581e5188251ac446c716&quot;&gt;垃圾回收机制与内存泄露&lt;/a&gt;的文章，感兴趣的同学可以扩展一下。&lt;/p&gt;
&lt;h3 id=&quot;如果这篇文章帮助到了你欢迎点赞和关注你的支持是对我最大的鼓励&quot;&gt;如果这篇文章帮助到了你，欢迎点赞和关注，你的支持是对我最大的鼓励！&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;http://obkoro1.com/&quot;&gt;博客&lt;/a&gt;、&lt;a href=&quot;http://obkoro1.com/web_accumulate/accumulate/&quot;&gt;前端积累文档&lt;/a&gt;、&lt;a href=&quot;https://user-gold-cdn.xitu.io/2018/5/1/1631b6f52f7e7015?w=344&amp;amp;h=344&amp;amp;f=jpeg&amp;amp;s=8317&quot;&gt;公众号&lt;/a&gt;、&lt;a href=&quot;https://github.com/OBKoro1&quot;&gt;GitHub&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;以上2019/5/19&lt;/p&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5b40581e5188251ac446c716&quot;&gt;JS垃圾回收机制与常见内存泄露的解决方法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://es6.ruanyifeng.com/#docs/function#%E5%B0%BE%E8%B0%83%E7%94%A8%E4%BC%98%E5%8C%96&quot;&gt;ES6入门-阮一峰&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5a05b4576fb9a04519690d42&quot;&gt;JavaScript 如何工作：对引擎、运行时、调用堆栈的概述&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000010360316&quot;&gt;浅析javascript调用栈&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 21 May 2019 05:50:00 +0000</pubDate>
<dc:creator>OBKoro1</dc:creator>
<og:description>调用栈的英文名叫做Call Stack，大家或多或少是有听过的，但是对于js调用栈的工作方式以及如何在工作中利用这一特性，大部分人可能没有进行过更深入的研究，这块内容可以说对我们前端来说就是所谓的基础</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/OBkoro1/p/10899391.html</dc:identifier>
</item>
<item>
<title>程序兵法：Java String 源码的排序算法（一） - www.bysocket.com</title>
<link>http://www.cnblogs.com/Alandre/p/10899359.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Alandre/p/10899359.html</guid>
<description>&lt;p&gt;摘要: 原创出处 https://www.bysocket.com 「公众号：泥瓦匠BYSocket 」欢迎关注和转载，保留摘要，谢谢！&lt;/p&gt;
&lt;p&gt;这是泥瓦匠的第103篇原创&lt;/p&gt;
&lt;h2&gt;《程序兵法：Java String 源码的排序算法（一）》&lt;/h2&gt;
&lt;p&gt;文章工程：&lt;br/&gt;* JDK 1.8&lt;br/&gt;* 工程名：algorithm-core-learning # StringComparisonDemo&lt;br/&gt;* 工程地址：https://github.com/JeffLi1993/algorithm-core-learning&lt;/p&gt;
&lt;h2&gt;一、前言&lt;/h2&gt;
&lt;p&gt;Q：什么是选择问题？&lt;br/&gt;选择问题，是假设一组 N 个数，要确定其中第 K 个最大值者。比如 A 与 B 对象需要哪个更大？又比如：要考虑从一些数组中找出最大项？&lt;/p&gt;
&lt;p&gt;解决选择问题，需要对象有个能力，即比较任意两个对象，并确定哪个大，哪个小或者相等。找出最大项问题的解决方法，只要依次用对象的比较（Comparable）能力，循环对象列表，一次就能解决。&lt;/p&gt;
&lt;p&gt;那么 JDK 源码如何实现比较（Comparable）能力的呢？&lt;/p&gt;
&lt;h2&gt;二、java.lang.Comparable 接口&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/509099/201905/509099-20190521134345583-841863116.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Comparable 接口，从 JDK 1.2 版本就有了，历史算悠久。Comparable 接口强制了实现类对象列表的排序。其排序称为自然顺序，其 &lt;code&gt;compareTo&lt;/code&gt; 方法，称为自然比较法。&lt;/p&gt;
&lt;p&gt;该接口只有一个方法 &lt;code&gt;public int compareTo(T o);&lt;/code&gt; ，可以看出&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;入参 T o ：实现该接口类，传入对应的要被比较的对象&lt;/li&gt;
&lt;li&gt;返回值 int：正数、负数和 0 ，代表大于、小于和等于&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对象的集合列表（Collection List）或者数组（arrays） ，也有对应的工具类可以方便的使用：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;java.util.Collections#sort(List) 列表排序&lt;/li&gt;
&lt;li&gt;java.util.Arrays#sort(Object[]) 数组排序&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;那 String 对象如何被比较的？&lt;/p&gt;
&lt;h2&gt;三、String 源码中的算法&lt;/h2&gt;
&lt;p&gt;String 源码中可以看到 String JDK 1.0 就有了。那么应该是 JDK 1.2 的时候，String 类实现了 Comparable 接口，并且传入需要被比较的对象是 String。对象如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/509099/201905/509099-20190521134355773-620020857.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;String 是一个 final 类，无法从 String 扩展新的类。从 114 行，可以看出字符串的存储结构是字符（Char）数组。先可以看看一个字符串比较案例，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java hljs&quot;&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java hljs&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;0
-&lt;span class=&quot;hljs-number&quot;&gt;1
-&lt;span class=&quot;hljs-number&quot;&gt;2
-&lt;span class=&quot;hljs-number&quot;&gt;1
-&lt;span class=&quot;hljs-number&quot;&gt;32
-&lt;span class=&quot;hljs-number&quot;&gt;2049

&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看出， &lt;code&gt;compareTo&lt;/code&gt; 方法是按字典顺序比较两个字符串。具体比较规则可以看代码注释。比较规则如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;字符串的每个字符完全一样，返回 0&lt;/li&gt;
&lt;li&gt;字符串前面部分的每个字符完全一样，返回：后面就是两个字符串长度差&lt;/li&gt;
&lt;li&gt;字符串前面部分的每个字符存在不一样，返回：出现不一样的字符 ASCII 码的差值
&lt;ul&gt;&lt;li&gt;中文比较返回对应的 Unicode 编码值（Unicode 包含 ASCII）&lt;/li&gt;
&lt;li&gt;foo 的 ‘C’ 字符 ASCII 码值为 67&lt;/li&gt;
&lt;li&gt;bar04 的 ‘D’ 字符 ASCII 码值为 68。&lt;/li&gt;
&lt;li&gt;foo.compareTo(bar04)，返回 67 – 68 = -1&lt;/li&gt;
&lt;li&gt;常见字符 ASCII 码，如图所示&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://www.bysocket.com/wp-content/uploads/2019/05/ASCII.png&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再看看 String 的 &lt;code&gt;compareTo&lt;/code&gt; 方法如何实现字典顺序的。源码如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/509099/201905/509099-20190521134432864-1422680241.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;源码解析如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第 1156 行：获取当前字符串和另一个字符串，长度较小的长度值 lim&lt;/li&gt;
&lt;li&gt;第 1161 行：如果 lim 大于 0 （较小的字符串非空），则开始比较&lt;/li&gt;
&lt;li&gt;第 1164 行：当前字符串和另一个字符串，依次字符比较。如果不相等，则返回两字符的 Unicode 编码值的差值&lt;/li&gt;
&lt;li&gt;第 1169 行：当前字符串和另一个字符串，依次字符比较。如果均相等，则返回两个字符串长度的差值&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所以要排序，肯定先有比较能力，即实现 Comparable 接口。然后实现此接口的对象列表（和数组）可以通过 Collections.sort（和 Arrays.sort）进行排序。&lt;/p&gt;
&lt;p&gt;还有 TreeSet 使用树结构实现（红黑树），集合中的元素进行排序。其中排序就是实现 Comparable 此接口&lt;/p&gt;
&lt;p&gt;另外，如果没有实现 Comparable 接口，使用排序时，会抛出 java.lang.ClassCastException 异常。详细看《Java 集合：三、HashSet，TreeSet 和 LinkedHashSet比较》https://www.bysocket.com/archives/195&lt;/p&gt;
&lt;h2&gt;四、小结&lt;/h2&gt;
&lt;p&gt;上面也说到，这种比较其实有一定的弊端：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;默认 compareTo 不忽略字符大小写。如果需要忽略，则重新自定义 compareTo 方法&lt;/li&gt;
&lt;li&gt;无法进行二维的比较决策。比如判断 2 * 1 矩形和 3 * 3 矩形，哪个更大？&lt;/li&gt;
&lt;li&gt;比如有些类无法实现该接口。一个 final 类，也无法扩展新的类。其也有解决方案：函数对象（Function Object）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;方法参数：定义一个没有数据只有方法的类，并传递该类的实例。一个函数通过将其放在一个对象内部而被传递。这种对象通常叫做函数对象（Funtion Object）&lt;/p&gt;
&lt;p&gt;在接口方法设计中， T execute(Callback callback) 参数中使用 callback 类似。比如在 Spring 源码中，可以看出很多设计是：聚合优先于继承或者实现。这样可以减少很多继承或者实现。类似 SpringJdbcTemplate 场景设计，可以考虑到这种 Callback 设计实现。&lt;/p&gt;
&lt;h3&gt;代码示例&lt;/h3&gt;
&lt;p&gt;本文示例读者可以通过查看下面仓库的中: StringComparisonDemo 字符串比较案例案例：&lt;/p&gt;
&lt;p&gt;如果您对这些感兴趣，欢迎 star、follow、收藏、转发给予支持！&lt;/p&gt;
&lt;h3&gt;参考资料&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;《数据结构与算法分析：Java语言描述（原书第3版）》&lt;/li&gt;
&lt;li&gt;https://en.wikipedia.org/wiki/Unicode&lt;/li&gt;
&lt;li&gt;https://www.cnblogs.com/vamei/tag/%E7%AE%97%E6%B3%95/&lt;/li&gt;
&lt;li&gt;https://www.bysocket.com/archives/2314/algorithm&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;以下专题教程也许您会有兴趣&lt;/h3&gt;
&lt;div readability=&quot;9&quot;&gt;&lt;img src=&quot;http://www.bysocket.com/wp-content/uploads/2017/01/qrcode_for_gh_cd421e7eb7d6_430.jpg&quot; alt=&quot;&quot; width=&quot;224&quot; height=&quot;224&quot;/&gt; &lt;br/&gt;（关注微信公众号，领取 Java 精选干货学习资料） &lt;br/&gt;（添加我微信：bysocket01。加入纯技术交流群，成长技术）&lt;/div&gt;
</description>
<pubDate>Tue, 21 May 2019 05:43:00 +0000</pubDate>
<dc:creator>www.bysocket.com</dc:creator>
<og:description>摘要: 原创出处 https://www.bysocket.com 「公众号：泥瓦匠BYSocket 」欢迎关注和转载，保留摘要，谢谢！ 这是泥瓦匠的第103篇原创 《程序兵法：Java String</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Alandre/p/10899359.html</dc:identifier>
</item>
<item>
<title>微服务架构之「 监控系统 」 - IVAN-jsjwk</title>
<link>http://www.cnblogs.com/jsjwk/p/10899175.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jsjwk/p/10899175.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1453917/201905/1453917-20190521125419843-1654064694.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在微服务架构的系列文章中，前面已经通过文章分别介绍过了微服务的「服务注册 」、「服务网关 」、「配置中心 」，今天这篇文章我们继续来聊一聊另外一个重要模块：「 监控系统 」。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因为在微服务的架构下，我们对服务进行了拆分，所以用户的每次请求不再是由某一个服务独立完成了，而是变成了多个服务一起配合完成。这种情况下，一旦请求出现异常，我们必须得知道是在哪个服务环节出了故障，就需要对每一个服务，以及各个指标都进行全面的监控。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;一、什么是「 监控系统 」？&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;在微服务架构中，监控系统按照原理和作用大致可以分为三类（并非严格分类，仅从日常使用角度来看）：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面来分别对这三种常见的监控模式进行说明：&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot;list-paddingleft-2&quot; readability=&quot;17&quot;&gt;&lt;li readability=&quot;14&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;日志类（Log）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;日志类比较常见，我们的框架代码、系统环境、以及业务逻辑中一般都会产出一些日志，这些日志我们通常把它记录后统一收集起来，方便在需要的时候进行查询。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;日志类记录的信息一般是一些事件、非结构化的一些文本内容。日志的输出和处理的解决方案比较多，大家熟知的有 &lt;strong&gt;ELK Stack&lt;/strong&gt; 方案（Elasticseach + Logstash + Kibana），如图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1453917/201905/1453917-20190521125451760-1607442033.png&quot; alt=&quot;&quot;/&gt;使用Beats（可选）在每台服务器上安装后，作为日志客户端收集器，然后通过Logstash进行统一的日志收集、解析、过滤等处理，再将数据发送给Elasticsearch中进行存储分析，最后使用Kibana来进行数据的展示。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当然还可以升级方案为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1453917/201905/1453917-20190521125458541-409171857.png&quot; alt=&quot;&quot;/&gt;&lt;span&gt;这些方案都比较成熟，搭建起来也比较简单，除了用作监控系统以外，还可以作为日志查询系统使用，非常适用于做分析、以及问题调试使用。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;调用链类（Tracing）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;调用链类监控主要是指记录一个请求的全部流程。一个请求从开始进入，在微服务中调用不同的服务节点后，再返回给客户端，在这个过程中通过调用链参数来追寻全链路行为。通过这个方式可以很方便的知道请求在哪个环节出了故障，系统的瓶颈在哪儿。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这一类的监控一般采用 &lt;strong&gt;CAT&lt;/strong&gt; 工具 来完成，一般在大中型项目较多用到，因为搭建起来有一定的成本。后面会有单独文章来讲解这个调用链监控系统。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;度量类（Metrics）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;度量类主要采用 &lt;strong&gt;时序数据库&lt;/strong&gt; 的解决方案。它是以事件发生时间以及当前数值的角度来记录的监控信息，是可以聚合运算的，用于查看一些指标数据和指标趋势。所以这类监控主要不是用来查问题的，主要是用来看趋势的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Metrics一般有5种基本的度量类型：Gauges（度量）、Counters（计数器）、 Histograms（直方图）、 Meters（TPS计算器）、Timers（计时器）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;基于时间序列数据库的监控系统是非常适合做监控告警使用的，所以现在也比较流行这个方案，如果我们要搭建一套新的监控系统，我也建议参考这类方案进行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因此本文接下来也会重点以时间序列数据库的监控系统为主角来描述。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h4&gt;&lt;span&gt;二、「 监控系统 」关注的对象和指标都是什么？&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;一般我们做「监控系统」都是需要做分层式监控的，也就是说将我们要监控的对象进行分层，一般主要分为：&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot;list-paddingleft-2&quot; readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;系统层：&lt;/strong&gt;系统层主要是指CPU、磁盘、内存、网络等服务器层面的监控，这些一般也是运维同学比较关注的对象。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;应用层：&lt;/strong&gt;应用层指的是服务角度的监控，比如接口、框架、某个服务的健康状态等，一般是服务开发或框架开发人员关注的对象。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;用户层：&lt;/strong&gt;这一层主要是与用户、与业务相关的一些监控，属于功能层面的，大多数是项目经理或产品经理会比较关注的对象。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;知道了监控的分层后，我们再来看一下监控的指标一般有哪些：&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot;list-paddingleft-2&quot; readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;延迟时间：&lt;/strong&gt;主要是响应一个请求所消耗的延迟，比如某接口的HTTP请求平均响应时间为100ms。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;请求量：&lt;/strong&gt;是指系统的容量吞吐能力，例如每秒处理多少次请求（QPS）作为指标。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;错误率：&lt;/strong&gt;主要是用来监控错误发生的比例，比如将某接口一段时间内调用时失败的比例作为指标。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h4&gt;&lt;span&gt;三、基于时序数据库的「 监控系统 」有哪些？&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;下面介绍几款目前业内比较流行的基于时间序列数据库的开源监控方案：&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;18.5&quot;&gt;&lt;li readability=&quot;22&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Prometheus&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Promethes是一款2012年开源的监控框架，其本质是时间序列数据库，由Google前员工所开发。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Promethes采用拉的模式（Pull）从应用中拉取数据，并还支持 Alert 模块可以实现监控预警。它的性能非常强劲，单机可以消费百万级时间序列。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;架构如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1453917/201905/1453917-20190521125512837-1169431086.png&quot; alt=&quot;&quot;/&gt;从看图的左下角可以看到，Prometheus 可以通过在应用里进行埋点后Pull到 Prometheus Server里，如果应用不支持埋点，也可以采用exporter方式进行数据采集。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;从图的左上角可以看到，对于一些定时任务模块，因为是周期性运行的，所以采用拉的方式无法获取数据，那么Prometheus 也提供了一种推数据的方式，但是并不是推送到Prometheus Server中，而是中间搭建一个 Pushgateway，定时任务模块将metrics信息推送到这个Pushgateway中，然后Prometheus Server再依然采用拉的方式从Pushgateway中获取数据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;需要拉取的数据既可以采用静态方式配置在Prometheus Server中，也可以采用服务发现的方式（即图的中间上面的Service discovery所示）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;PromQL：是Prometheus自带的查询语法，通过编写PromQL语句可以查询Prometheus里面的数据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Alertmanager：是用于数据的预警模块，支持通过多种方式去发送预警。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;WebUI：是用来展示数据和图形的，但是一般大多数是与Grafana结合，采用Grafana来展示。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;OpenTSDB&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;OpenTSDB是在2010年开源的一款分布式时序数据库，当然其主要用于监控方案中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;OpenTSDB采用的是Hbase的分布式存储，它获取数据的模式与Prometheus不同，它采用的是推模式（Push）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在展示层，OpenTSDB自带有WebUI视图，也可以与Grafana很好的集成，提供丰富的展示界面。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但OpenTSDB并没有自带预警模块，需要自己去开发或者与第三方组件结合使用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以通过下图来了解一下OpenTSDB的架构：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1453917/201905/1453917-20190521125520555-870718865.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;InfluxDB&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;InfluxDB是在2013年开源的一款时序数据库，在这里我们主要还是用于做监控系统方案。它收集数据也是采用推模式（Push）。在展示层，InfluxDB也是自带WebUI，也可以与Grafana集成。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1453917/201905/1453917-20190521125528754-17165716.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;以上，就是对微服务架构中「 监控系统」的一些思考。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;码字不易啊，喜欢的话不妨转发朋友，或点击文章右下角的“在看”吧。😊&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;本文原创发布于微信公众号「 不止思考 」，欢迎关注。涉及 思维认知、个人成长、架构、大数据、Web技术 等。 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1453917/201905/1453917-20190521125538793-658239156.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Tue, 21 May 2019 04:56:00 +0000</pubDate>
<dc:creator>IVAN-jsjwk</dc:creator>
<og:description>在微服务架构的系列文章中，前面已经通过文章分别介绍过了微服务的「服务注册 」、「服务网关 」、「配置中心 」，今天这篇文章我们继续来聊一聊另外一个重要模块：「 监控系统 」。 因为在微服务的架构下，我</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jsjwk/p/10899175.html</dc:identifier>
</item>
</channel>
</rss>