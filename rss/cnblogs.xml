<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>day 38 数据库MySQL之单表查询 - derboss</title>
<link>http://www.cnblogs.com/liuteacher/p/10083312.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liuteacher/p/10083312.html</guid>
<description>&lt;p&gt;一 . 单表查询的语法&lt;/p&gt;
&lt;p&gt;　　select  *  from   select  *  指的就是要查询所有字段的数据。&lt;/p&gt;
&lt;p&gt;　　select  distinct   字段1，字段2  from  库名，表名&lt;/p&gt;
&lt;p&gt;　　where  条件   #  从表中找符合条件的数据记录，where 后面跟的就是你的查询条件&lt;/p&gt;
&lt;p&gt;　　group  by  field (字段)    #   将结果按照后面的字段进行排序&lt;/p&gt;
&lt;p&gt;　　order  by  field  (字段）    #   将结果按照后面的字段进行排序&lt;/p&gt;
&lt;p&gt;　　limit    限制条数    # 将最后的结果加一个限制条数，就是说我要过滤或者说限制查询出来数据记录的条数&lt;/p&gt;
&lt;p&gt;二 .  关键字的执行优先级(重点)&lt;/p&gt;
&lt;p&gt;　　from  -  找到表  &lt;/p&gt;
&lt;p&gt;　　where  -   拿着where 指定的约束条件，去文件/ 表中取出一条条记录&lt;/p&gt;
&lt;p&gt;　　group  -   将取出的一条条记录进行分组group  by  ，如果没有group  by  ，则整体作为一组&lt;/p&gt;
&lt;p&gt;　　having   -    将分组的结果进行having  过滤  &lt;/p&gt;
&lt;p&gt;　　select   -    执行select   &lt;/p&gt;
&lt;p&gt;　　distinct    -    去重  &lt;/p&gt;
&lt;p&gt;　　order  by   -     将结果按条件排序 &lt;/p&gt;
&lt;p&gt;　　limit    -   限制结果的显示条数&lt;/p&gt;

&lt;p&gt;具体代码详情请见： https://www.cnblogs.com/clschao/articles/9995531.html?tdsourcetag=s_pctim_aiomsg#_label4&lt;/p&gt;


</description>
<pubDate>Fri, 07 Dec 2018 07:45:00 +0000</pubDate>
<dc:creator>derboss</dc:creator>
<og:description>一 . 单表查询的语法 select * from select * 指的就是要查询所有字段的数据。 select distinct 字段1，字段2 from 库名，表名 where 条件 # 从表中</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liuteacher/p/10083312.html</dc:identifier>
</item>
<item>
<title>腾讯云Mac图床插件 - Vanch</title>
<link>http://www.cnblogs.com/vanch/p/10083130.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/vanch/p/10083130.html</guid>
<description>&lt;h2 id=&quot;背景&quot;&gt;背景&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://vanch-1258064554.cos.ap-shanghai.myqcloud.com/blog/pic_1544160967_34.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;随着博客越写越多，难免会遇到需要插入图片来说明的情况。&lt;/p&gt;
&lt;h3 id=&quot;图床选择&quot;&gt;图床选择&lt;/h3&gt;
&lt;p&gt;首先调研了市面上的图床服务，本着稳定长期的目标，过滤掉了打一枪换一个地方的野鸡小网站，剩余比较靠谱的优缺点如下。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;腾讯云&lt;/td&gt;
&lt;td&gt;免费 无需域名&lt;/td&gt;
&lt;td&gt;未来可能会收费&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;七牛&lt;/td&gt;
&lt;td&gt;免费&lt;/td&gt;
&lt;td&gt;需要域名和备案&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;又拍云&lt;/td&gt;
&lt;td&gt;免费 无需域名&lt;/td&gt;
&lt;td&gt;未来可能会收费&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;阿里云&lt;/td&gt;
&lt;td&gt;目前最完备&lt;/td&gt;
&lt;td&gt;收费 需要域名&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;微博&lt;/td&gt;
&lt;td&gt;免费 无需域名&lt;/td&gt;
&lt;td&gt;不稳定 匿名上传&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;作为一个刚起步的小博客，应该把精力更多关注于内容，以后再考虑域名备案或者大流量套餐，因此尽量选择免费的图床。 &lt;del&gt;其实是穷&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;微博作为国内首屈一指的流量大户，其图床的CDN和质量肯定没有问题，但是上传图片会自带水印，且匿名上传总觉得不靠谱。&lt;/p&gt;
&lt;p&gt;剩下的选择还有两个，又拍云进军对象存储领域比腾讯云早而且更成熟，但是就规模和技术来说，我还是更愿意相信腾讯。&lt;/p&gt;
&lt;h3 id=&quot;工具&quot;&gt;工具&lt;/h3&gt;
&lt;p&gt;注册完腾讯云账号后，下一个问题就是怎么更方便的将图床与 MarkDown 结合起来使用，提高效率和体验。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://vanch-1258064554.cos.ap-shanghai.myqcloud.com/blog/pic_1544165437_77.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;iPic&lt;/strong&gt; 完美符合我的需求，这是一款 &lt;strong&gt;Mac&lt;/strong&gt; 上的状态栏软件，支持上传本地图片到设定的图床，获取图片地址后按照 &lt;code&gt;![](url)&lt;/code&gt; 格式复制到剪贴板。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;那么好的应用为啥不用呢？&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为不想&lt;strong&gt;按年交钱&lt;/strong&gt;。应用默认是微博图床，如果要使用其他图床就需要购买专业版，每年60元。如果是一次买断的话，也就买了，年费心里总有疙瘩 &lt;del&gt;矫情&lt;/del&gt;。&lt;/p&gt;
&lt;p&gt;突然，我就想到！ 自己开发一个！ &lt;del&gt;闲的蛋疼&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;开发&lt;code&gt;iPhone&lt;/code&gt;应用已经好多年了，还从未开发过&lt;code&gt;Mac&lt;/code&gt;上的状态栏软件，正好还能锻炼下&lt;code&gt;Swift&lt;/code&gt;，于是说干就干。&lt;del&gt;没想到开发了一个月&lt;/del&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;需求设计&quot;&gt;需求设计&lt;/h2&gt;
&lt;p&gt;产品使用逻辑基本与 &lt;strong&gt;iPic&lt;/strong&gt; 一致，基于状态栏交互，选择&lt;code&gt;png&lt;/code&gt; &lt;code&gt;jpg&lt;/code&gt;文件上传。&lt;/p&gt;
&lt;p&gt;可以设置是否压缩图片，压缩会压到&lt;code&gt;500K&lt;/code&gt;以下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://vanch-1258064554.cos.ap-shanghai.myqcloud.com/blog/pic_1544165455_60.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;还需要有一个登录界面记录腾讯云的账号和存储库信息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://vanch-1258064554.cos.ap-shanghai.myqcloud.com/blog/pic_1544165470_40.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;文件上传成功后，弹出通知提醒，并复制到剪贴板。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://vanch-1258064554.cos.ap-shanghai.myqcloud.com/blog/pic_1544165482_81.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果不慎复制了其他文本导致丢失了链接，再点击一次通知就可以重新获取。&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;遇到的难题&quot;&gt;遇到的难题&lt;/h2&gt;
&lt;h3 id=&quot;swift&quot;&gt;Swift&lt;/h3&gt;
&lt;p&gt;第一关就是编程语言。&lt;/p&gt;
&lt;p&gt;虽然也曾系统的学过&lt;code&gt;Swift&lt;/code&gt;，但由于常年使用&lt;code&gt;Objective-C&lt;/code&gt; 开发，思维方式还转不过来。&lt;/p&gt;
&lt;h4 id=&quot;严格的空变量&quot;&gt;严格的空变量&lt;/h4&gt;
&lt;p&gt;比较明显的区别就是处理空变量的方式。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;ObjC&lt;/code&gt;中，指针变量可以是&lt;code&gt;nil&lt;/code&gt;（也就是0），对&lt;code&gt;nil&lt;/code&gt;执行方法不会发生任何事情，因此可以算是部分安全。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Swift&lt;/code&gt;对待空变量更严格，&lt;code&gt;!&lt;/code&gt;修饰的变量必须有具体值，&lt;code&gt;?&lt;/code&gt;修饰的变量才具有空值的可能性。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;nil&lt;/code&gt;不再表示为空对象，而是一个空值，向空值调用方法会导致闪退。对待&lt;code&gt;?&lt;/code&gt;修饰的变量必须要小心，最好先判断是否有值再使用，好在有语法糖可以解决这类问题。&lt;/p&gt;
&lt;pre class=&quot;swift&quot;&gt;
&lt;code&gt;//默认为nil
var money : String?
//变量有值
money = &quot;million&quot;

//判断肯定有值后再使用
if money != nil {
    print(&quot;I have \(money!) dollars.&quot;)
}

//保证变量有值并赋值给安全变量后执行
if let account = money {
    print(&quot;I have \(account) dollars.&quot;) 
}

//变量如果没有值就执行else事件并return
guard let account = money else {
    print(&quot;I have no money.&quot;)
}

print(&quot;I have \(account) dollars.&quot;) &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;合理使用&lt;code&gt;! ?&lt;/code&gt; 会使我们的代码更安全与简洁。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;Swift 的 nil 和 Objective-C 中的 nil 并不一样。在 Objective-C 中，nil 是一个指向不存在对象的指针。在 Swift 中，nil 不是指针——它是一个确定的值，用来表示值缺失。任何类型的可选状态都可以被设置为 nil，不只是对象类型。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;抛出警告&quot;&gt;抛出警告&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;ObjC&lt;/code&gt; 有 &lt;code&gt;@throw&lt;/code&gt; 的用法，但是根据苹果官方的描述，执行的成本很大。究其原因在于 &lt;code&gt;ObjC&lt;/code&gt; 基于 &lt;code&gt;C&lt;/code&gt; 语言而不是 &lt;code&gt;C++&lt;/code&gt;，所以只能使用 &lt;code&gt;setjmp()&lt;/code&gt;和&lt;code&gt;longjmp()&lt;/code&gt; 方法实现，因此可能会造成内存泄漏。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;Important: Exceptions are resource-intensive in Objective-C. You should not use exceptions for general flow-control, or simply to signify errors (such as a file not being accessible)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;Swift&lt;/code&gt; 从根本解决了这个问题，并结合枚举优化了整个流程。&lt;/p&gt;
&lt;pre class=&quot;swift&quot;&gt;
&lt;code&gt;enum CompressError : Error {
    case NoImage
    case OverSize(size : Int)
}

func compressImage(_ imageData: Data?) throws -&amp;gt; Data? {
        guard var compressData = imageData else {
            throw CompressError.NoImage
        }

        if compressData.count &amp;gt; maxSize {
            throw CompressError.OverSize(size: compressData.count)
        }
}

func uploadImage(_ imageData: Data?) {
    var compressData : Data? = nil
    do {
        compressData = try self.compressImage(imageData)
    } catch CompressError.NoImage {
        print(&quot;Image Not Exist&quot;)
    } catch CompressError.OverSize(let size) {
        print(&quot;Image over size of \(size)&quot;)
    }  catch _ {}

    //简洁的方式，忽略处理警告
    let compressData = try? self.compressImage(imageData)
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;利用&lt;code&gt;Swift&lt;/code&gt;强大的枚举类型，可以定制化警告从而传递出我们需要的信息，使得整个流程更为顺畅。&lt;/p&gt;
&lt;p&gt;语法还支持 &lt;code&gt;try?&lt;/code&gt;忽略警告获取一个可能为空值的变量，如果自信绝对不会抛出异常的话，还能使用&lt;code&gt;try!&lt;/code&gt;获取一个肯定值。&lt;/p&gt;
&lt;h3 id=&quot;mac-os-开发&quot;&gt;Mac OS 开发&lt;/h3&gt;
&lt;p&gt;实际编写&lt;code&gt;Cocoa&lt;/code&gt;代码过程中，发现与&lt;code&gt;UIKit&lt;/code&gt;相差还是比较多的。&lt;/p&gt;
&lt;h4 id=&quot;控件逻辑&quot;&gt;控件逻辑&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;UIKit&lt;/code&gt; 的层级一般是 &lt;code&gt;UINavigationController -&amp;gt; UIViewController&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Cocoa&lt;/code&gt; 的层级则不太一样，&lt;code&gt;NSWindowController -&amp;gt; NSViewController&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;原因也很简单，手机上一般只有一个窗口，依靠导航栏进行页面跳转。但是桌面端逻辑就不太一样，新页面一般都是以新窗口的形式弹出。&lt;/p&gt;
&lt;p&gt;其次桌面端拥有特定的状态栏控件&lt;code&gt;NSMenu&lt;/code&gt;，在其中操作菜单项也是一个新的挑战。&lt;/p&gt;
&lt;h4 id=&quot;腾讯云相关&quot;&gt;腾讯云相关&lt;/h4&gt;
&lt;p&gt;由于腾讯云只提供了&lt;code&gt;iOS&lt;/code&gt;的库，所以我还需要先把库文件重新调整为&lt;code&gt;Cocoa&lt;/code&gt;代码。&lt;br/&gt;这一部分也是吃了不少苦头，需要把设备相关的代码与应用、进出后台的通知等都去除，还要处理类似功能的转换（比如&lt;code&gt;UIImage -&amp;gt; NSImage&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;同时还有第二个坑，腾讯云的库都是&lt;code&gt;ObjC&lt;/code&gt;代码，所以需要混编。&lt;/p&gt;
&lt;p&gt;创建一个工作空间后拖入两个工程，在主工程的 &lt;code&gt;Targets / Build Phases / Embed Frameworks&lt;/code&gt; 中加入SDK库。&lt;/p&gt;
&lt;p&gt;接着在&lt;code&gt;Swift&lt;/code&gt;工程中创建&lt;code&gt;Project-Bridging-Header.h&lt;/code&gt; 头文件，在其中引用SDK库。&lt;/p&gt;
&lt;p&gt;最后在 &lt;code&gt;Targets / Build Settings / Objective-C Bridging Header&lt;/code&gt; 设置头文件，就可以解决代码混编的问题。&lt;/p&gt;
&lt;p&gt;其原理在于自动创建了基于头文件的&lt;code&gt;pch&lt;/code&gt;，把头文件中引用到的&lt;code&gt;ObjC&lt;/code&gt;代码，都桥接到工程中。&lt;/p&gt;
&lt;h3 id=&quot;图片压缩算法&quot;&gt;图片压缩算法&lt;/h3&gt;
&lt;p&gt;之所以不使用现成的软件还有一个原因，就是我想自己控制压缩图片的参数和效果。&lt;/p&gt;
&lt;p&gt;通过调研和实验图片压缩效果，最终我选择压制成&lt;code&gt;jpg&lt;/code&gt;格式，&lt;code&gt;500k&lt;/code&gt;大小限制，压缩率限制为最小&lt;code&gt;0.75&lt;/code&gt;，等比宽度限制为&lt;code&gt;1280px&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://vanch-1258064554.cos.ap-shanghai.myqcloud.com/blog/pic_1544165504_98.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;文首那张美女图，初始是&lt;code&gt;1.9M 5087x3661&lt;/code&gt;，由于尺寸过大，第一次压缩图片质量后，容量反而增加到了&lt;code&gt;2.4M&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;将宽高等比缩小到&lt;code&gt;1280x922&lt;/code&gt;，图片又变大了，这次增加到了&lt;code&gt;4.7M&lt;/code&gt;。（改变宽高需要新建一张画布，创建时必须要有alpha通道等其他设置，所以会变大）&lt;/p&gt;
&lt;p&gt;我们接着压缩，最终在压缩率为&lt;code&gt;0.9&lt;/code&gt;的情况下把图片压到了&lt;code&gt;260K&lt;/code&gt;，成功达到了目标。&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;距离上一次博客已经有两个月的间隔，其中一部分原因在于生活上的一些变故，另一个原因就在于不熟悉 &lt;code&gt;Cocoa + Swift&lt;/code&gt; 开发。&lt;/p&gt;
&lt;p&gt;好在最终还是啃出来了，&lt;a href=&quot;https://github.com/VanchChen/Image2Url&quot;&gt;Github项目&lt;/a&gt;已开源，欢迎大家指点与吐槽。&lt;/p&gt;
&lt;p&gt;这次项目最大的收获在于脱离自己的舒适区。人的本性包含惰性，总是趋向于在熟悉的领域干熟悉的活。但是就和企业一样，不创新就死，技术不断在发展，如果没有跟上潮流，最终就会被淘汰。以此共勉！&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://www.swift51.com/swift4.0/&quot;&gt;Swift 4.0 教程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/9b47fc25f526&quot;&gt;App图片压缩裁剪原理和上传方案&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 07 Dec 2018 07:20:00 +0000</pubDate>
<dc:creator>Vanch</dc:creator>
<og:description>背景 随着博客越写越多，难免会遇到需要插入图片来说明的情况。 图床选择 首先调研了市面上的图床服务，本着稳定长期的目标，过滤掉了打一枪换一个地方的野鸡小网站，剩余比较靠谱的优缺点如下。 |图床|优点|</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/vanch/p/10083130.html</dc:identifier>
</item>
<item>
<title>被标记为事务的方法互相调用的坑（上） - CodeBear</title>
<link>http://www.cnblogs.com/CodeBear/p/10083053.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CodeBear/p/10083053.html</guid>
<description>&lt;p&gt;相信大家一定用过Spring中的注解型事务，配合上Spring Boot，只需要在方法上打一个@Transactional 就可以完成，真香。&lt;/p&gt;
&lt;p&gt;但是如果大家对其中的机制一知半解的话，可能一不小心就会掉进坑，然后久久无法爬出来。&lt;/p&gt;
&lt;p&gt;下面我就分享下 &lt;strong&gt;&lt;em&gt;被标记为事务的方法互相调用的坑&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;首先我写两个事务方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    @Autowired
    AccountMapper mapper;

    @Transactional
    @Override
    public void insertCodeBear() {
        Account account = new Account();
        account.setAccount(&quot;CodeBear&quot;);
        account.setPassword(&quot;CodeBear&quot;);
        mapper.insert(account);
    }

    @Transactional
    @Override
    public void insertCodeMonkey() {
        Account account = new Account();
        account.setAccount(&quot;CodeMonkey&quot;);
        account.setPassword(&quot;CodeMonkey&quot;);
        mapper.insert(account);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在我想在insertCodeBear方法里面调用insertCodeMonkey方法，但是insertCodeMonkey不是很重要，就算失败，也不能影响到insertCodeBear方法的执行，但是insertCodeMonkey该回滚的还是要回滚，我们很容易写出如下代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    @Autowired
    AccountMapper mapper;

    @Transactional
    @Override
    public void insertCodeBear() {
        try {
           insertCodeMonkey();
        } catch (Exception ex) {
        }
        Account account = new Account();
        account.setAccount(&quot;CodeBear&quot;);
        account.setPassword(&quot;CodeBear&quot;);
        mapper.insert(account);
    }

    @Transactional(propagation = Propagation.REQUIRES_NEW)
    @Override
    public void insertCodeMonkey() {
        Account account = new Account();
        account.setAccount(&quot;CodeMonkey&quot;);
        account.setPassword(&quot;CodeMonkey&quot;);
        mapper.insert(account);
        int a = 1 / 0;//自杀代码，便于测试
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在第二个方法中，用了自杀代码，便于测试。&lt;/p&gt;
&lt;p&gt;看上去一点问题都没有：第一个方法会成功，第二个方法会失败并且回滚。但是仅仅是看上去，当我们运行一下，会发现奇怪的事情发生了：&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/15100432-df8f48fead80a5b7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;br/&gt;两个方法竟然都成功了！！Why?&lt;/p&gt;
&lt;p&gt;为了排查问题，需要开启一下 有关事务 的日志，在 配置文件 中加上下面的配置：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;logging.level.org.springframework.jdbc.datasource.DataSourceTransactionManager=debug&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后运行，看下控制台打印的内容：&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/15100432-60996fc93e9e3062.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;br/&gt;图片可能有点模糊，大家可以在新标签页中打开这图片，可以看到这里分明只开了一个事务，而且事务的传播行为是PROPAGATION_REQUIRED，这是事务的默认传播行为，也就是这里只开启了insertCodeBear方法的事务，并没有开启insertCodeMonkey的事务。&lt;/p&gt;
&lt;p&gt;这是什么原因？为了更好的说明问题产生的原因，我需要手写一个AOP。&lt;/p&gt;
&lt;p&gt;在此之前大家要达成一个共识，@Transactional 其实也是通过AOP去实现的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/15100432-b21938f73bb394cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;AOP有几种实现方式，我这里采用JDK动态代理的方式：&lt;/p&gt;
&lt;p&gt;代码入口：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Main {
    public static void main(String[] args) {
        BookServiceImpl impl = new BookServiceImpl();
        InvocationHandler myInvocationHandler = new MyInvocationHandler(impl);
        Object o = Proxy.newProxyInstance(myInvocationHandler.getClass().getClassLoader(),
                impl.getClass().getInterfaces(), myInvocationHandler);
        ((IBookService) o).add();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接口：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public interface IBookService {
    void add();

    void delete();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实现类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class BookServiceImpl implements IBookService {
    public void add() {
        delete();
        System.out.println(&quot;add&quot;);
    }

    public void delete() {
        System.out.println(&quot;delete&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;切面定义：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class MyInvocationHandler implements InvocationHandler {
    private Object obj;

    public MyInvocationHandler(Object obj) {
        this.obj = obj;
    }

    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println(&quot;开始啦，小伙子&quot;);
        method.invoke(obj, args);
        System.out.println(&quot;结束啦，小伙子&quot;);
        return null;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在Main入口里面调用了实现类的代理对象，调用了add方法，add方法里面又调用了delete的方法。很简单吧。按照我们的想法，应该是打印出两次 切面中定义的话，但是事实是 只打印了一次：&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/15100432-785b807aa3690f0f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;br/&gt;让我们在切面方法中加上这行代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; System.out.println(&quot;方法是&quot; + method.getName());&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看看是哪个方法进入到了这里。&lt;/p&gt;
&lt;p&gt;运行：&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/15100432-3f6cf14e34c3dc63.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;add方法进入到了这里，但是delete方法却没有进来。&lt;/p&gt;
&lt;p&gt;让我们再回到第一个例子，为了让大家看的清楚一点，我再贴上insertCodeBear被调用的代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@RestController
@RequestMapping(&quot;/CodeBear&quot;)
public class HelloWorldController {
    @Autowired
    AccountService service;

    @GetMapping(&quot;/insert&quot;)
    public void insert() {
        service.insertCodeBear();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;AccountService 是一个接口，里面定义了insertCodeBear和insertCodeMonkey虚方法。&lt;br/&gt;我们打一个断点在&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; service.insertCodeBear();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里，然后调试看下service是一个什么东西：&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/15100432-507b93db7668ea49.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;你会发现，service已经不是简单的AccountService 的实现类了，而是实现类的代理对象，从这里也可以看出，其实@Transactional也是通过AOP去实现的。&lt;/p&gt;
&lt;p&gt;通过两个例子，可以得到一个结论：&lt;strong&gt;&lt;em&gt;只有调用代理对象的方法才能被拦截，所以 在方法A中直接调用方法B，方法B是不会被拦截的&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;这也就是为什么insertCodeMonkey的事务没有被开启的原因了，因为insertCodeMonkey方法是insertCodeBear直接调用的。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;那么，这个问题该如何解决呢？在下一篇博客，我会采用几种方式来解决这个问题（这篇博客已经比较长了，因为加上了很多看上去没什么用的“废话”，因为可以直接写出结论，然后再写解决方案就是了。但是我还是很详细的，把“废话”都写出来了，就是因为分析问题的思路才是最重要的 ）。&lt;/p&gt;
</description>
<pubDate>Fri, 07 Dec 2018 07:10:00 +0000</pubDate>
<dc:creator>CodeBear</dc:creator>
<og:description>相信大家一定用过Spring中的注解型事务，配合上Spring Boot，只需要在方法上打一个@Transactional 就可以完成，真香。 但是如果大家对其中的机制一知半解的话，可能一不小心就会掉</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CodeBear/p/10083053.html</dc:identifier>
</item>
<item>
<title>WebPack 学习：从阮神的15个DEMO开始 - WangKane</title>
<link>http://www.cnblogs.com/primadonna/p/10082867.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/primadonna/p/10082867.html</guid>
<description>&lt;h2 id=&quot;webpack-是什么&quot;&gt;WebPack 是什么&lt;/h2&gt;
&lt;p&gt;官方就一句话，&lt;strong&gt;打包所有的资源&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;从阮神的-15-deom入手-webpack&quot;&gt;从阮神的 15 DEOM入手 Webpack&lt;/h2&gt;
&lt;h3 id=&quot;github-地址&quot;&gt;Github 地址&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/ruanyf/webpack-demos&quot;&gt;阮神GIT&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;按照-readme-操作&quot;&gt;按照 ReadME 操作&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;npm webpack-dev-server ，为了能够运行起来demo的代码&lt;/li&gt;
&lt;li&gt;cd 到任何一个demo下，执行npm run dev 即可运行demo&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;npm run dev 是在 demo下的package.json文件中 配置的 script，实际上是在执行 &lt;strong&gt;webpack-dev-server --open&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;对demo拆解&quot;&gt;对DEMO拆解&lt;/h3&gt;
&lt;ul readability=&quot;23.5&quot;&gt;&lt;li&gt;准备工作：&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;请保证电脑上有npm&lt;/li&gt;
&lt;li&gt;创建一个文件夹 webpack-tutorial&lt;/li&gt;
&lt;li&gt;cmd cd到上面的文件夹，键入 npm init 根据提示步骤创建package.json文件，可以一直enter&lt;/li&gt;
&lt;li&gt;npm install webpack webpack-cli webpack-dev-server 安装需要的包&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;28&quot;&gt;
&lt;p&gt;demo1 ：单个入口&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;创建 webpack.config.js文件，代码如下&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;module.exports = {
  entry: './main.js',//入口文件是当前目录下的 main.js文件
  output: {
    filename: 'bundle.js'//打包后的文件名称是 bundle.js
    //这里webpack会自动创建dist文件夹，将bundle.js放到里面。
    //这里的./会指定到 dist下
    //比如 filename:'./js/bundle.js' 会在dist下找js文件夹放入bundle.js文件
      //可以通过path指定不同的目录
  }
};&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;创建 main.js文件 ，代码如下：&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// main.js
document.write('&amp;lt;h1&amp;gt;Hello World&amp;lt;/h1&amp;gt;');//往页面上写hello world&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;CMD中键入 webpack进行打包，键入进行开启&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;cmd&quot;&gt;
&lt;code&gt;//webpack 输出 
    Asset       Size  Chunks             Chunk Names
bundle.js  968 bytes       0  [emitted]  main
Entrypoint main = bundle.js&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;npm&quot;&gt;
&lt;code&gt;webpack-dev-server --open 
 //打开浏览器后发现是一个ftp的页面
 //我们下面将自动创建index.html文件&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;CMD 键入&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;npm&quot;&gt;
&lt;code&gt; npm install html-webpack-plugin
 //安装自动生成html插件&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;重新编辑 webpack.config.js&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;var HtmlwebpackPlugin = require('html-webpack-plugin');
module.exports = {
  entry: './main.js',//入口文件是当前目录下的 main.js文件
  output: {
    filename: 'bundle.js'//打包后的文件名称是 bundle.js
    //这里webpack会自动创建dist文件夹，将bundle.js放到里面。
    //这里的./会指定到 dist下
    //比如 filename:'./js/bundle.js' 会在dist下找js文件夹放入bundle.js文件
      //可以通过path指定不同的目录
  },
  //加入html自动生成
  plugins:[
    new HtmlwebpackPlugin({
      title: 'Webpack-tutorial',
      filename: 'index.html'
    }), 
  ]
};&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;重新CMD 键入 webpack 打包 ，键入 webpack-dev-server --open 开启server&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;cmd&quot;&gt;
&lt;code&gt;//webpack输出 
    Asset       Size  Chunks             Chunk Names
 bundle.js  968 bytes       0  [emitted]  main
index.html  187 bytes          [emitted]
Entrypoint main = bundle.js&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;会发现 dist 文件夹下自动生成了 index.html并且引入 打包好的 bundle.js文件，浏览器正常显示一个h1的hello world&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;17&quot;&gt;
&lt;p&gt;demo2 ：两个入口&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;更改 webpack.config.js 文件如下：&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;var HtmlwebpackPlugin = require('html-webpack-plugin');
module.exports = {
  entry: {
    bundle1: './main1.js',//入口1 main1.js
    bundle2: './main2.js'//入口2 main2.js
  },
  output: {
    filename: '[name].js'//name是entry的键名，最后会生成bundle1.js bundle2.js
  },
  //加入html自动生成
  plugins:[
    new HtmlwebpackPlugin({
      title: 'Webpack-tutorial',
      filename: 'index.html'
    }), 
  ]
};&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;分别创建 main1.js 与main2.js&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// main1.js
document.write('&amp;lt;h1&amp;gt;Hello World&amp;lt;/h1&amp;gt;');
// main2.js
document.write('&amp;lt;h2&amp;gt;Hello Webpack&amp;lt;/h2&amp;gt;');&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;CMD 键入 webpack 打包 ，键入 webpack-dev-server --open 开启server&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;cmd&quot;&gt;
&lt;code&gt;//webpack 输出
     Asset       Size  Chunks             Chunk Names
bundle1.js  968 bytes       0  [emitted]  bundle1
bundle2.js  971 bytes       1  [emitted]  bundle2
index.html  245 bytes          [emitted]
Entrypoint bundle1 = bundle1.js
Entrypoint bundle2 = bundle2.js
[0] ./main1.js 39 bytes {0} [built]
[1] ./main2.js 41 bytes {1} [built]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;会在dist下 创建 bundle1.js/bundle2.js/index.html，浏览器会有h1的helloworld h2的hellowebpack&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;demo3 ：Babel-loader 的使用&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;什么loaders&lt;/strong&gt;：就是webpack使用loaders来预处理文件，允许打包除了js文件外任何静态资源。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;什么是Babel-loader&lt;/strong&gt;：是javascript编译器，将现行的javascript代码变成浏览器可以兼容的代码。&lt;/p&gt;
&lt;ul readability=&quot;24.5&quot;&gt;&lt;li readability=&quot;25&quot;&gt;
&lt;ul&gt;&lt;li&gt;例子中是 react 所有我们先安装下相关的包&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;npm&quot;&gt;
&lt;code&gt;npm install react react-dom//js 用到
npm install babel-loader babel-core babel-preset-es2015 babel-preset-react
//这里说明一下 babel-loader单独安装一下7.1.5的版本，因为最新的8版本 打包时会报错&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;创建main.jsx文件&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// main.jsx
//我们需要增加一部分代码
//增加一个创建wrapper div的过程
//这边我的index.html是自动创建的，打包后在更改 会报错
//不知道阮神是怎么弄的，等我研究明白了再回来说明一下
//如下方法可成功显示
var div = document.createElement('div');  
div.id = 'wrapper';  
document.body.appendChild(div);
//结束
const React = require('react');
const ReactDOM = require('react-dom');
ReactDOM.render(
  &amp;lt;h1&amp;gt;Hello, world!&amp;lt;/h1&amp;gt;,
  document.querySelector('#wrapper')//将h1这个标签放到 id是wrapper的div中
);&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;修改webpack.config.js文件&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;var HtmlwebpackPlugin = require('html-webpack-plugin');
module.exports = {
  entry: './main.jsx',//不说明了
  output: {
    filename: 'bundle.js'
  },
  //加入html自动生成
  plugins:[
    new HtmlwebpackPlugin({
      title: 'Webpack-tutorial',
      filename: 'index.html'
    }), 
  ],
  module: {
    rules: [
      {
        test: /\.jsx?$/,//匹配.jsx文件
        exclude: /node_modules/,//不包含这个文件夹 npm包
        use: {
          loader: 'babel-loader',//使用babel-loader这个
          options: {
            presets: ['es2015', 'react']//使用 es2015 跟react
            //这里说明一下，这里的顺序是从右到左加载的，即，先用react再用es2015
          }
        }
      }
    ]
  }
};&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;CMD 键入 webpack 打包 ，键入 webpack-dev-server --open 开启server&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;cmd&quot;&gt;
&lt;code&gt;//webpack 输出
     Asset       Size  Chunks                    Chunk Names
 bundle.js    248 KiB       0  [emitted]  [big]  main
index.html  187 bytes          [emitted]&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;demo4 ：css-loader使用&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;ul&gt;&lt;li&gt;cmd 键入&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;npm&quot;&gt;
&lt;code&gt;npm install css-loader style-loader&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;20&quot;&gt;
&lt;ul&gt;&lt;li&gt;创建 app.css文件&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;body {
  background-color: blue;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;更改 webpack.config.js，增加一个css-loader&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;var HtmlwebpackPlugin = require('html-webpack-plugin');
module.exports = {
  entry: './main.js',
  output: {
    filename: 'bundle.js'
  },
  //加入html自动生成
  plugins:[
    new HtmlwebpackPlugin({
      title: 'Webpack-tutorial',
      filename: 'index.html'
    }), 
  ],
  module: {
    rules: [
      {
        test: /\.jsx?$/,
        exclude: /node_modules/,
        use: {
          loader: 'babel-loader',
          options: {
            presets: ['es2015', 'react']
          }
        }
      },
          {
        test: /\.css$/,
        use: [ 'style-loader', 'css-loader' ]//同样的 从右到左加载
      },
    ]
  }
};&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;更改main.js文件&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;require('./app.css');&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;CMD 键入 webpack 打包 ，键入 webpack-dev-server --open 开启server&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;cmd&quot;&gt;
&lt;code&gt;//webpack 输出
   Asset       Size  Chunks             Chunk Names
 bundle.js    147 KiB       0  [emitted]  main
index.html  187 bytes          [emitted]&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;demo5 ：image loader&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;不做赘述，需要 npm url-loader。与上一个demo类似&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;demo6 ： CSS Module&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Css Module：给CSS加入了局部作用域和模块依赖。详情还是请看&lt;a href=&quot;http://www.ruanyifeng.com/blog/2016/06/css_modules.html&quot;&gt;阮神博客&lt;/a&gt;。还有&lt;a href=&quot;https://css-modules.github.io/webpack-demo/&quot;&gt;官网&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;本次demo 只是介绍了局部作用于与全局作用域。&lt;/p&gt;
&lt;ul readability=&quot;11&quot;&gt;&lt;li readability=&quot;25&quot;&gt;
&lt;ul&gt;&lt;li&gt;更改main.jsx文件。同样我们增加一部分代码。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;//增加start
var div = document.createElement('div');  
div.id = 'example';  
document.body.appendChild(div);

var h1 = document.createElement('h1');  
h1.className=&quot;h1&quot;;
var t1=document.createTextNode(&quot;Hello World&quot;);
h1.appendChild(t1);
document.body.appendChild(h1);

var h2 = document.createElement('h2');
h2.className=&quot;h2&quot;;  
var t2=document.createTextNode(&quot;Hello Webpack&quot;);
h2.appendChild(t2);
document.body.appendChild(h2);
//end
var React = require('react');
var ReactDOM = require('react-dom');
var style = require('./app.css');

ReactDOM.render(
  &amp;lt;div&amp;gt;
    &amp;lt;h1 className={style.h1}&amp;gt;Hello World&amp;lt;/h1&amp;gt;
    &amp;lt;h2 className=&quot;h2&quot;&amp;gt;Hello Webpack&amp;lt;/h2&amp;gt;
  &amp;lt;/div&amp;gt;,
  document.getElementById('example')
);&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;更改webpack.config.js&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;var HtmlwebpackPlugin = require('html-webpack-plugin');
module.exports = {
  entry: './main.jsx',//每次看好打包的入口文件呦
  output: {
    filename: 'bundle.js'
  },
  //加入html自动生成
  plugins:[
    new HtmlwebpackPlugin({
      title: 'Webpack-tutorial',
      filename: 'index.html'
    }), 
  ],
  module: {
    rules: [
      {
        test: /\.jsx?$/,
        exclude: /node_modules/,
        use: {
          loader: 'babel-loader',
          options: {
            presets: ['es2015', 'react']
          }
        }
      },
          {
        test: /\.css$/,
        use: [
          {
            loader: 'style-loader'
          },
          {//使用module
             loader: 'css-loader',
             options: {
               modules: true
             }
          }
        ]
      }
    ]
  }
};&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;更改app.css&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;/* local scope */
.h1 {
  color:red;
}

/* global scope */
:global(.h2) {
  color: blue;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;CMD 键入 webpack 打包 ，键入 webpack-dev-server --open 开启server&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;cmd&quot;&gt;
&lt;code&gt;    Asset       Size  Chunks             Chunk Names
 bundle.js   6.89 KiB       0  [emitted]  main
index.html  187 bytes          [emitted]&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;结果是 有一个红色字体的h1 一个黑色字体的h1 两个蓝色字体的h2， 因为h2 的class是global的 h1的local的&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;demo7：使用 uglifyjs 插件&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;什么事uglifyjs 插件&lt;/strong&gt;：将输出的文件bundle.js变到最小。丑化js代码。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这里需要注意webpack 两种模式的 产品模式下 uglifyjs插件是默认开启的我们需要在development模式下搞&lt;/strong&gt;&lt;/p&gt;
&lt;ul readability=&quot;10&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;ul&gt;&lt;li&gt;更改main.js使用阮神demo中的代码：&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;var longVariableName = 'Hello';
longVariableName += ' World';
document.write('&amp;lt;h1&amp;gt;' + longVariableName + '&amp;lt;/h1&amp;gt;');&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;20&quot;&gt;
&lt;ul&gt;&lt;li&gt;在webpack.config.js文件中加入如下配置：&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;mode: 'development',//开发者模式&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;我们先打包一次main.js打包成的bundle.js的大小为3.89kb，然后使用插件。这个时候bundle.js可读&lt;/li&gt;
&lt;li&gt;npm install uglifyjs-webpack-plugin，更改webpack.config.js，加一个插件其他不更改&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;var HtmlwebpackPlugin = require('html-webpack-plugin');
var UglifyJsPlugin = require('uglifyjs-webpack-plugin');

module.exports = {
  entry: './main.js',//每次看好打包的入口文件呦
  output: {
    filename: 'bundle.js'
  },
  //加入html自动生成
  mode: 'development',//开发者模式
  plugins:[
    new HtmlwebpackPlugin({
      title: 'Webpack-tutorial',
      filename: 'index.html'
    }), 
      new UglifyJsPlugin(),//开发者模式下使用插件
  ],
  module: {
    rules: [
      {
        test: /\.jsx?$/,
        exclude: /node_modules/,
        use: {
          loader: 'babel-loader',
          options: {
            presets: ['es2015', 'react']
          }
        }
      },
          {
        test: /\.css$/,
        use: [
          {
            loader: 'style-loader'
          },
          {
             loader: 'css-loader',
             options: {
               modules: true
             }
          }
        ]
      }
    ]
  }
};&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;CMD 键入 webpack 打包 ，查看bundle.js大小1.23KB&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;demo8 ：html-webpack-plugin与open-browser-webpack-plugin两个插件。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;html-webpack-plugin：自动生成html插件。这个插件我们已经使用啦，不介绍了。&lt;/p&gt;
&lt;p&gt;open-browser-webpack-plugin：自动打开浏览器插件。&lt;/p&gt;
&lt;ul readability=&quot;7&quot;&gt;&lt;li readability=&quot;17&quot;&gt;
&lt;ul&gt;&lt;li&gt;npm install open-browser-webpack-plugin，更改webpack.config.js如下&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;var HtmlwebpackPlugin = require('html-webpack-plugin');
var UglifyJsPlugin = require('uglifyjs-webpack-plugin');
var OpenBrowserPlugin = require('open-browser-webpack-plugin');
module.exports = {
  entry: './main.js',//每次看好打包的入口文件呦
  output: {
    filename: 'bundle.js'
  },
  mode: 'development',
  //加入html自动生成
  plugins:[
    new HtmlwebpackPlugin({
      title: 'Webpack-tutorial',
      filename: 'index.html'
    }), 
      new UglifyJsPlugin(),
      new OpenBrowserPlugin({
      url: 'http://localhost:8080'//开启服务后自动打开这个网址
    })
  ],
  module: {
    rules: [
      {
        test: /\.jsx?$/,
        exclude: /node_modules/,
        use: {
          loader: 'babel-loader',
          options: {
            presets: ['es2015', 'react']
          }
        }
      },
          {
        test: /\.css$/,
        use: [
          {
            loader: 'style-loader'
          },
          {
             loader: 'css-loader',
             options: {
               modules: true
             }
          }
        ]
      }
    ]
  }
};&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;CMD 键入 webpack 打包 ，键入 webpack-dev-server 开启server，不需要--open了 否则会打开两个页面&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;demo9 ：Environment flags&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在开发时，有些东西要放出来，产品环境时需要屏蔽掉。我们可以定一个变量去看当前的模式。&lt;/p&gt;
&lt;ul readability=&quot;12.5&quot;&gt;&lt;li readability=&quot;28&quot;&gt;
&lt;ul&gt;&lt;li&gt;更改main.js&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;document.write('&amp;lt;h1&amp;gt;Hello World&amp;lt;/h1&amp;gt;');

if (__DEV__) {//__DEV__ 在webpack.config.js中定义
  document.write(new Date());
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;webpack.config.js&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;var HtmlwebpackPlugin = require('html-webpack-plugin');
var UglifyJsPlugin = require('uglifyjs-webpack-plugin');
var OpenBrowserPlugin = require('open-browser-webpack-plugin');

var devFlagPlugin = new webpack.DefinePlugin({
  __DEV__: JSON.stringify(JSON.parse(process.env.DEBUG || 'false'))
});


module.exports = {
  entry: './main.js',//每次看好打包的入口文件呦
  output: {
    filename: 'bundle.js'
  },
  mode: 'development',
  //加入html自动生成
  plugins:[
    new HtmlwebpackPlugin({
      title: 'Webpack-tutorial',
      filename: 'index.html'
    }), 
      new UglifyJsPlugin(),
      new OpenBrowserPlugin({
      url: 'http://localhost:8080'
    }),
      devFlagPlugin,
  ],
  module: {
    rules: [
      {
        test: /\.jsx?$/,
        exclude: /node_modules/,
        use: {
          loader: 'babel-loader',
          options: {
            presets: ['es2015', 'react']
          }
        }
      },
          {
        test: /\.css$/,
        use: [
          {
            loader: 'style-loader'
          },
          {
             loader: 'css-loader',
             options: {
               modules: true
             }
          }
        ]
      }
    ]
  }
};&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;webpack 打包，并输入cross-env DEBUG=true webpack-dev-server，来控制debug&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;阮神是想通过命令将当前是否是debug传入到程序中，我们更改一下代码。官网上介绍可以使用process.env.NODE_ENV来访问当前的mode。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;document.write('&amp;lt;h1&amp;gt;Hello World&amp;lt;/h1&amp;gt;');

if (process.env.NODE_ENV==&quot;development&quot;) {
  document.write(new Date());
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;直接看页面。注：更改了config文件需要重新打包其他的不需要。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;demo10 ：code splitting&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;code splitting：打包时，分文件打包&lt;/p&gt;
&lt;ul readability=&quot;7&quot;&gt;&lt;li readability=&quot;3&quot;&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// main.js
require.ensure(['./a'], function (require) {
  var content = require('./a');
  document.open();
  document.write('&amp;lt;h1&amp;gt;' + content + '&amp;lt;/h1&amp;gt;');
  document.close();
});&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;创建a.js&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// a.js
module.exports = 'Hello World';&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;ul&gt;&lt;li&gt;其他不变，直接webpack打包，多生成了0.bundle.js文件&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;cmd&quot;&gt;
&lt;code&gt;//wepack 输出
     Asset       Size  Chunks             Chunk Names
0.bundle.js  307 bytes       0  [emitted]
  bundle.js   2.45 KiB    main  [emitted]  main
 index.html  187 bytes          [emitted]&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;demo 11：Code splitting with bundle-loader&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;6&quot;&gt;
&lt;ul&gt;&lt;li&gt;这个与demo10 一样，npm install bundle-loader后直接更改 main.js&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// main.js

// Now a.js is requested, it will be bundled into another file
var load = require('bundle-loader!./a.js');

// To wait until a.js is available (and get the exports)
//  you need to async wait for it.
load(function(file) {
  document.open();
  document.write('&amp;lt;h1&amp;gt;' + file + '&amp;lt;/h1&amp;gt;');
  document.close();
});&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;直接webpack打包：效果是相同的&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;  Asset       Size  Chunks             Chunk Names
0.bundle.js  307 bytes       0  [emitted]
  bundle.js   2.45 KiB    main  [emitted]  main
 index.html  187 bytes          [emitted]&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;demo12:Common chunk&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;是自动将相同代码打包成一个common.js&lt;/p&gt;
&lt;ul readability=&quot;15&quot;&gt;&lt;li readability=&quot;33&quot;&gt;
&lt;ul&gt;&lt;li&gt;这里需要说明，阮神的做法在webpack4中已经&lt;strong&gt;废弃&lt;/strong&gt;了，现在可以直接使用，更改webpack.config.js&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;var HtmlwebpackPlugin = require('html-webpack-plugin');
var UglifyJsPlugin = require('uglifyjs-webpack-plugin');
var OpenBrowserPlugin = require('open-browser-webpack-plugin');
var webpack = require('webpack');
var devFlagPlugin = new webpack.DefinePlugin({
  __DEV__: JSON.stringify(JSON.parse(process.env.NODE_ENV || 'false'))
});


module.exports = {
  entry: {
    bundle1: './main1.jsx',
    bundle2: './main2.jsx'
  },
  output: {
    filename: '[name].js'
  },
  mode: 'development',
  //增加了这个配置即可
  optimization: {
      splitChunks: {      // old CommonsChunkPlugin
          chunks: &quot;all&quot;
      },
  },
  //加入html自动生成
  plugins:[
    new HtmlwebpackPlugin({
      title: 'Webpack-tutorial',
      filename: 'index.html'
    }), 
      //new UglifyJsPlugin(),//我们想看打包后的文件，注释掉这个
      new OpenBrowserPlugin({
      url: 'http://localhost:8080'
    }),
      devFlagPlugin,
  ],
  module: {
    rules: [
      {
        test: /\.jsx?$/,
        exclude: /node_modules/,
        use: {
          loader: 'babel-loader',
          options: {
            presets: ['es2015', 'react']
          }
        }
      },
          {
        test: /\.css$/,
        use: [
          {
            loader: 'style-loader'
          },
          {
             loader: 'css-loader',
             options: {
               modules: true
             }
          }
        ]
      }
    ]
  }
};&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;创建main1.jsx main2.jsx&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// main1.jsx
var React = require('react');
var ReactDOM = require('react-dom');

ReactDOM.render(
  &amp;lt;h1&amp;gt;Hello World&amp;lt;/h1&amp;gt;,
  document.getElementById('a')
);

// main2.jsx
var React = require('react');
var ReactDOM = require('react-dom');

ReactDOM.render(
  &amp;lt;h2&amp;gt;Hello Webpack&amp;lt;/h2&amp;gt;,
  document.getElementById('b')
);&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;直接webpack打包，会多一个vendors~bundle1~bundle2.js文件，&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;                     Asset       Size                   Chunks             Chunk Names
                bundle1.js   6.72 KiB                  bundle1  [emitted]  bundle1
                bundle2.js   6.72 KiB                  bundle2  [emitted]  bundle2
                index.html  318 bytes                           [emitted]
vendors~bundle1~bundle2.js    832 KiB  vendors~bundle1~bundle2  [emitted]  vendors~bundle1~bundle2&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;demo13 ：vendor chunk&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;作用：将某一部分类库，打包到vendor js中。需要先 npm install jquery&lt;/p&gt;
&lt;ul readability=&quot;26&quot;&gt;&lt;li readability=&quot;55&quot;&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;var $ = require('jquery');
$('h1').text('Hello World');&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;webpack .config.js&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;var HtmlwebpackPlugin = require('html-webpack-plugin');
var UglifyJsPlugin = require('uglifyjs-webpack-plugin');
var OpenBrowserPlugin = require('open-browser-webpack-plugin');
var webpack = require('webpack');
var devFlagPlugin = new webpack.DefinePlugin({
  __DEV__: JSON.stringify(JSON.parse(process.env.NODE_ENV || 'false'))
});


module.exports = {
  entry: {
    app: './main.js',
    vendor: ['jquery'],
  },//每次看好打包的入口文件呦
  output: {
    filename: '[name].js'
  },
  mode: 'development',
  optimization: {
      splitChunks: {      // old CommonsChunkPlugin
          chunks: &quot;all&quot;
      },
  },
  //加入html自动生成
  plugins:[
    new HtmlwebpackPlugin({
      title: 'Webpack-tutorial',
      filename: 'index.html'
    }), 
      //new UglifyJsPlugin(),
      new OpenBrowserPlugin({
      url: 'http://localhost:8080'
    }),
      devFlagPlugin,
  ],
  module: {
    rules: [
      {
        test: /\.jsx?$/,
        exclude: /node_modules/,
        use: {
          loader: 'babel-loader',
          options: {
            presets: ['es2015', 'react']
          }
        }
      },
          {
        test: /\.css$/,
        use: [
          {
            loader: 'style-loader'
          },
          {
             loader: 'css-loader',
             options: {
               modules: true
             }
          }
        ]
      }
    ]
  }
};&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;webpack 打包&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;cmd&quot;&gt;
&lt;code&gt;# webpack 输出
   Asset       Size  Chunks             Chunk Names
      0.js  552 bytes       0  [emitted]
    app.js   9.39 KiB     app  [emitted]  app
index.html  240 bytes          [emitted]
 vendor.js    305 KiB  vendor  [emitted]  vendor&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;说明下，阮神还是用的CommonsChunkPlugin，但是webpack4已经废弃了，其实本例的最后完成方法就类似于两个入口文件了，只不过其中一个的意思是所有的jquery包，打包到vendor.js中&lt;/li&gt;
&lt;li&gt;这个例子最后阮神还介绍了一种不需要一直require包的方法&lt;/li&gt;
&lt;li&gt;webpack.config.js&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;var HtmlwebpackPlugin = require('html-webpack-plugin');
var UglifyJsPlugin = require('uglifyjs-webpack-plugin');
var OpenBrowserPlugin = require('open-browser-webpack-plugin');
var webpack = require('webpack');
var devFlagPlugin = new webpack.DefinePlugin({
  __DEV__: JSON.stringify(JSON.parse(process.env.NODE_ENV || 'false'))
});


module.exports = {
  entry: {
    app: './main.js',
    vendor: ['jquery'],
  },//每次看好打包的入口文件呦
  output: {
    filename: '[name].js'
  },
  mode: 'development',
  optimization: {
      splitChunks: {      
          name (module) {
        // generate a chunk name...
        return; //...
      }
      },
  },
  //加入html自动生成
  plugins:[
    new HtmlwebpackPlugin({
      title: 'Webpack-tutorial',
      filename: 'index.html'
    }), 
      //new UglifyJsPlugin(),
      new OpenBrowserPlugin({
      url: 'http://localhost:8080'
    }),
      devFlagPlugin,
      //增加定义$ jquery 随时可以使用
  new webpack.ProvidePlugin({
      $: 'jquery',
      jQuery: 'jquery'
    })
  ],
  module: {
    rules: [
      {
        test: /\.jsx?$/,
        exclude: /node_modules/,
        use: {
          loader: 'babel-loader',
          options: {
            presets: ['es2015', 'react']
          }
        }
      },
          {
        test: /\.css$/,
        use: [
          {
            loader: 'style-loader'
          },
          {
             loader: 'css-loader',
             options: {
               modules: true
             }
          }
        ]
      }
    ]
  }
};&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;删除掉main.js中的 ，会发现 var $ = require('jquery');正常使用&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;demo14：Exposing global variables&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;作用：定义一些全局变量，并在代码中使用它。&lt;/p&gt;
&lt;ul readability=&quot;5&quot;&gt;&lt;li readability=&quot;13&quot;&gt;
&lt;ul&gt;&lt;li&gt;创建文件 data.js&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;var data = 'Hello World';//定义全局变量&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;更改 main.jsx 文件&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// main.jsx
var data = require('data');
var React = require('react');
var ReactDOM = require('react-dom');

ReactDOM.render(
  &amp;lt;h1&amp;gt;{data}&amp;lt;/h1&amp;gt;,
  document.body
);&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;webpack.config.js 文件&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;//增加如下配置
  externals: {
    // require('data') is external and available
    //  on the global var data
    'data': 'data'
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;webpack打包&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;cmd&quot;&gt;
&lt;code&gt;# webpack 输出
 Asset     Size  Chunks             Chunk Names
app.js  837 KiB     app  [emitted]  app
Entrypoint app = app.js
[./main.js] 189 bytes {app} [built]
[./node_modules/webpack/buildin/global.js] (webpack)/buildin/global.js 472 bytes {app} [built]
[data] external &quot;data&quot; 42 bytes {app} [built]
# 可以看到external data 这个变量可以require后使用了&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;不知到为什么，我使用html-webpack-plugin创建index.html后 不好使，而我在dist同级目录下创建一个index.html放入如下代码：打包开启server后，就能够正常显示data的数据了，最后也没弄清楚。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;html&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;script src=&quot;data.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&quot;app.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;demo 15：React router&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;关于这段react 留着以后再研究。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;至此阮神的15DEMO演示完毕，本人也是先从官网看的文档，看的很迷糊，一些概念性的东西，完全没头没脑的看，通过一些简单的配置，可以对webpack有一个更好地理解。&lt;/p&gt;
</description>
<pubDate>Fri, 07 Dec 2018 06:47:00 +0000</pubDate>
<dc:creator>WangKane</dc:creator>
<og:description>WebPack 是什么 官方就一句话， 打包所有的资源 。 从阮神的 15 DEOM入手 Webpack Github 地址</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/primadonna/p/10082867.html</dc:identifier>
</item>
<item>
<title>[线性代数] 矩阵代数進階：矩阵分解 Matrix factorization - HingAglaiaWong</title>
<link>http://www.cnblogs.com/HingAglaiaWong/p/10082852.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/HingAglaiaWong/p/10082852.html</guid>
<description>&lt;p&gt;&lt;strong&gt;Matrix factorization&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;导语：承载上集的矩阵代数入门，今天来聊聊进阶版，矩阵分解。其他集数可在[线性代数]标籤文章找到。有空再弄目录什麽的。&lt;/p&gt;


&lt;p&gt;Matrix factorization is quite like an application of invertible matrices, where L is an invertible matrix in LU factorization.&lt;/p&gt;
&lt;p&gt;As you may have seen, that solving Ax=b for x can be tedious with all the row-reduction algorithm. Here, we are going to explore another efficient algorithm for find x in matrix equation, which is LU Factorization. Suppose we are given L and U in the following form which reconstruct A. L is an invertible unit lower triangular mxm matrix, while U is the mxn echelon form of A. Recall a way to solve for x is by x=A&lt;sup&gt;-1&lt;/sup&gt;b and A&lt;sup&gt;-1&lt;/sup&gt; need to be invertible. Since L is invertible, LU is also invertible as proved in previous article in this series. The motivation here is that if we are to compute x for different b, we need to compute A&lt;sup&gt;-1&lt;/sup&gt;b&lt;sub&gt;i&lt;/sub&gt; for every single b. That's not desirable and we should look for ways to circumvent this…&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1099997/201812/1099997-20181207144354700-914276496.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Suppose LU are already given, expressing A=LU is just the first step in LU factorization. Remember our goal of using matrix factorization is to solve for x in matrix equation. So we rely on the following:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1099997/201812/1099997-20181207144355009-146403623.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Above suggests by row-reducing the following, we can get x. So we introduce y as the intermediate results along our way to get b. Noted that we still need to calculate each b individually for Ax=b, just that with the assistance of LU, less steps are involved.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1099997/201812/1099997-20181207144355235-1880399580.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1099997/201812/1099997-20181207144355486-175141834.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;As we know L as an lower unit triangular matrix, columns must be linearly independent. Since it's mxm, L is also invertible. This means the following:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1099997/201812/1099997-20181207144355742-531722030.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Indeed, when you get a lower triangular unit matrix L, it's trivial to get I&lt;sub&gt;mxm&lt;/sub&gt; from it. As U is the echelon form of A and is of size mxn, so identity matrix is not guaranteed as the reduced echelon form may not be of square matrix.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;The LU factorization algorithm&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The prerequisite for using this algorithm is that, given any matrix A in Ax=b, A must be reduceable to echelon form, U, using row replacements of rows in a TOP-DOWN manner. However, this is always a hard requirement to meet and people sometimes relax this restriction into allowing row interchanges before performing top-down sequential row replacement in A. If the requirements are satisfied, it's guaranteed we can get the lower triangular unit matrix L, and the proof of which is shown below:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1099997/201812/1099997-20181207144355948-1586953032.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;And if we apply the same sequence of elementary matrices onto L, we restore the identity matrix I as follows:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1099997/201812/1099997-20181207144356191-432977374.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;But now it sounds a bit abstract. What exactly does &lt;img src=&quot;https://img2018.cnblogs.com/blog/1099997/201812/1099997-20181207144356403-901454154.gif&quot; alt=&quot;&quot;/&gt; give us btw? And how is it utilized to find L? The following example shows how. During the row-reduction of A into U, entries below pivot position in each pivot column is zeroed-out. The reverse of elementary row operations just require us to gather all pivot columns before their transformation and pack them into a nxn matrix.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1099997/201812/1099997-20181207144356750-1781949529.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;When all pivot columns before row replacement gathered, L is easily available.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1099997/201812/1099997-20181207144357079-1783049529.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Examples&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;例子不定期更新&lt;/p&gt;
</description>
<pubDate>Fri, 07 Dec 2018 06:44:00 +0000</pubDate>
<dc:creator>HingAglaiaWong</dc:creator>
<og:description>Matrix factorization 导语：承载上集的矩阵代数入门，今天来聊聊进阶版，矩阵分解。其他集数可在[线性代数]标籤文章找到。有空再弄目录什麽的。 Matrix factorization</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/HingAglaiaWong/p/10082852.html</dc:identifier>
</item>
<item>
<title>带着新人学springboot的应用10（springboot+定时任务+发邮件） - java小新人</title>
<link>http://www.cnblogs.com/wyq1995/p/10076981.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wyq1995/p/10076981.html</guid>
<description>&lt;p&gt;　　接上一节，环境一样，这次来说另外两个任务，一个是定时任务，一个是发邮件。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.定时任务&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　定时任务可以设置精确到秒的准确时间去自动执行方法。&lt;/p&gt;
&lt;p&gt;　　我要一个程序每一秒钟说一句：java小新人最帅&lt;/p&gt;
&lt;p&gt;　　于是，我就写了一个方法，注解里cron里面的很多星星意思是：每个月、周一到周日 、每个小时、每一分、每一秒都执行一次这个方法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181206201814089-1379698114.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　主配置类加个开启注解&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181206201924043-372481891.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　ok，可以了，直接启动应用，不需要浏览器，直接在控制台看到打印的消息：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181206202309490-479783913.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　所以我们要掌握的是@Scheduled注解中属性cron的表达式，大概的就是下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181206205414200-1368067138.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.发邮件&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;/span&gt;来测试一下用springboot发邮件，假如我用qq邮箱向一个老哥的网易邮箱发邮件，基本的逻辑就是：从qq邮箱----------&amp;gt;腾讯qq邮箱服务器------------&amp;gt;网易邮箱服务器--------------&amp;gt;163网易邮箱&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　所以我们要配置的就是我们qq邮箱的账号密码&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;第一步：导入依赖&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181206215044419-1035128983.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;第二步：配置文件（看清楚stmp.qq.com这是SMTP服务器中qq邮件的主机地址，其他邮件有自己的STMP主机地址），最后的那个是建议ssl安全连接的，一定要开启&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181207135648637-350581804.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　其中，qq邮箱得到授权码步骤如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181206215649844-1693421080.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181206215721510-1184573135.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181206220019586-171554930.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;第三步：测试类&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181206220436579-953315631.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt; 　　运行测试方法，可以在网易云邮箱看到邮件：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181206220602680-2043614918.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt; 3.邮件的高级一点的功能(发邮件有附件)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181206225314541-2060982630.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　运行这个测试方法：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181206225436113-1107700950.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181206225532340-672727099.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.再高级一点（用模板发送邮件）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 　　还是用博客园注册为例，不知道大家注册的时候是不是收到了一个激活邮件，打开大概的格式就是：xxx用户，您注册博客园账户需要激活，请点击&lt;span&gt;激活邮件&lt;/span&gt;激活&lt;/p&gt;
&lt;p&gt;　　咳，记得不太清楚了，应该差不多，嘿嘿！话说难道每个人注册博客园都会用上面的发送html的方式，慢慢拼接html然后发送吗？其实这样也行，只是看起来太lower了，而且代码看起来会很凌乱。&lt;/p&gt;
&lt;p&gt;　　那今天我就用前面学的themeleaf给做个模板，来假装发发邮件，骗骗自己，嘿嘿~(●´∀｀●)~&lt;/p&gt;
&lt;p&gt;　　首先导入themeleaf的依赖，指定themeleaf的版本&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181207133332591-451908617.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181207133406022-398579695.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　其实真正开发中，会把这个发邮件的方法写成一个类，传入一些参数就可以发送的，我们嘛，就怎么简单怎么来吧！　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181207133954564-450492278.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　themeleaf文件的位置和内容（不要忘记themeleaf的目录位置和用法了）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181207134233062-1552940153.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181207134516081-1082647022.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　点击激活账号，就会跳转到我的controller中的方法，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181207134727724-1581616729.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　ok，到这里就可以了，记得，先运行springboot应用，然后运行测试方法，收到邮件，自己激活一下，然后就会跳转到&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181207135253592-1861253721.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181207140118009-100328978.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　成功跳转，于是你就激活成功了！&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181207135143203-1612484343.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;5.可能出现的bug&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 　　说说用模板可能会碰到的bug，哎，用了我好几个小时，现在我还是一副日了狗的心情。&lt;/p&gt;
&lt;p&gt;　　怎么回事呢？代码写了，看了好几遍也没错，就是运行就报错，在网上看了别人的代码拿过来还是报错，报错如下：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181207125630797-1635388811.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181207125338823-237081570.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181207125356523-2014414515.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　这个错误大概意思就是我的模板的html中每个标签都要是闭标签，要这种类型的&amp;lt;a&amp;gt;&amp;lt;/a&amp;gt;，假如是&amp;lt;img xxx&amp;gt;这种标签就会报错。&lt;/p&gt;
&lt;p&gt;　　如下所示，最坑的方法就是修改的，而且以后html的标签都要是一对一对的，坑啊、、、&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181207140738058-643663818.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　后来有找了很多资料，原来发现是这里，themeleaf默认应该是2.xx版本，这个版本解析标签都要是一对一对的，到了3.xx之后，就不需要这么麻烦了！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181207141053958-1612882053.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　都是版本问题，坑了我好几个小时，哎，记住记住....&lt;/p&gt;
</description>
<pubDate>Fri, 07 Dec 2018 06:14:00 +0000</pubDate>
<dc:creator>java小新人</dc:creator>
<og:description>接上一节，环境一样，这次来说另外两个任务，一个是定时任务，一个是发邮件。 1.定时任务 定时任务可以设置精确到秒的准确时间去自动执行方法。 我要一个程序每一秒钟说一句：java小新人最帅 于是，我就写</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wyq1995/p/10076981.html</dc:identifier>
</item>
<item>
<title>Springboot项目中异常拦截设计与处理 - 笨神Fany</title>
<link>http://www.cnblogs.com/f-anything/p/10082637.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/f-anything/p/10082637.html</guid>
<description>&lt;h3 id=&quot;id-异常治理v1-背景：&quot;&gt;&lt;span&gt;&lt;strong&gt;背景：&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;项目运行过程中会出现各种各样的问题，常见的有以下几种情况：&lt;/p&gt;
&lt;ol class=&quot; list-paddingleft-2&quot; readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;业务流程分析疏漏，对业务流程的反向操作、边界分析设计不充分&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;调用外部服务、调用外部系统出现的超时、错误、返回值与预期不符&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;外部资源连通性问题，db等服务器出现的网络抖动或宕机&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;无论是分析设计、开发、测试、线上都需要能够准确定位问题并制定解决方案。&lt;/p&gt;
&lt;h3 id=&quot;id-异常治理v1-目的：&quot;&gt;&lt;span&gt;&lt;strong&gt;目的：&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;ul class=&quot; list-paddingleft-2&quot; readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;规范化异常的处理过程，避免异常被吞和到处都在捕获异常的情况&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;准确的反馈异常信息，为定位问题提供依据&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;通用性异常全局处理，降低业务开发关注度 &lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;对异常情况进行预警，以便能够及时响应&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;id-异常治理v1-一、异常规划&quot;&gt;&lt;span&gt;&lt;strong&gt;一、异常规划&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;h3 id=&quot;id-异常治理v1-业务类异常&quot;&gt;&lt;span&gt;&lt;strong&gt;1. 业务类异常&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;造成业务流程不能正确执行的行为，常见的几种：&lt;/p&gt;
&lt;p&gt;这类异常需要给调用方返回明确的异常描述信息，一般情况下和代码无关，无需调整编码&lt;/p&gt;
&lt;p&gt;注：是业务完整性的一部分，需提前分析&lt;/p&gt;
&lt;h3 id=&quot;id-异常治理v1-系统类异常&quot;&gt;&lt;span&gt;&lt;strong&gt;2. 系统类异常&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;注：通常与业务流程无关，与第三方系统有关，不能简单的通过调整代码解决&lt;/p&gt;
&lt;h3 id=&quot;id-异常治理v1-通用异常&quot;&gt;&lt;span&gt;&lt;strong&gt;3. 通用异常&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;编码不严谨、数据异常造成的问题，不可预测&lt;/p&gt;
&lt;p&gt;举例：参数类型不匹配、空指针、数组越界&lt;/p&gt;
&lt;h2 id=&quot;id-异常治理v1-二、拦截&quot;&gt;&lt;span&gt;&lt;strong&gt;二、异常拦截&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;在springboot中全局异常拦截处理已知的有下面2种方案：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方案1：&lt;/strong&gt;@ControllerAdvice、实现ErrorController&lt;/p&gt;
&lt;p&gt;      注：利用springboot自带的拦截机制，只需要定义出处理的策略，没有破坏springboot的约定&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方案2：&lt;/strong&gt;继承AbstractHandlerExceptionResolver，完全自定义处理策略&lt;/p&gt;
&lt;p&gt;      注：使用spring中最底层的类，打破了springboot的约定，能够拦截到所有异常&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、方案实践&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 笔者基于方案一进行实践。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 异常拦截时序图&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qlogo.cn/mmbiz_png/e77aicficBOxBCH0NHCUksnaHpjPdqJlcniaMnURJwnjFibwhaqL8z9jTAXGdlfbiaS6FdNnWhUQx4EI5vqVxckjsMw/0?wx_fmt=png&quot; alt=&quot;&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-ratio=&quot;0.7888888888888889&quot; data-w=&quot;630&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;2. RrcRestAdvice实现代码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qlogo.cn/mmbiz_png/e77aicficBOxBCH0NHCUksnaHpjPdqJlcnl4NldPWLCO8cFZ2E75ghRaYKSP1n1TcDQElrKwAgyIQcxmTwLXqiaTg/0?wx_fmt=png&quot; alt=&quot;&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-ratio=&quot;1.1473396998635743&quot; data-w=&quot;733&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. RrcExpHandler实现代码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qlogo.cn/mmbiz_png/e77aicficBOxBCH0NHCUksnaHpjPdqJlcnSUfn7E4IwS1IdTWP27PtNUQuKChp7xCyADoVCvQKqjdWUzLuiaBAjvw/0?wx_fmt=png&quot; alt=&quot;&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-ratio=&quot;0.5987599645704162&quot; data-w=&quot;1129&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意：基于RestControllerAdvice的异常拦截只能捕获请求达controller之后的程序异常，所以需要实现ErrorController处理之前的异常。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;推荐&lt;strong&gt;基于springboot中@ControllerAdvice 和 ErrorController接口&lt;/strong&gt;的约定，相对较符合springboot的约定。&lt;/p&gt;
&lt;p&gt;其他可选方案：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;继承AbstractHandlerExceptionResolver&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;优点：可完全自定义处理策略。缺点：对框架约定破坏较为严重，自定义处理策略容易疏漏。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;继承&lt;/strong&gt;&lt;strong&gt;HandlerInterceptorAdapte&lt;/strong&gt;r&lt;/p&gt;
&lt;p&gt;理论上可以处理业务代码抛出的异常，优缺点没有进行过验证。&lt;/p&gt;

</description>
<pubDate>Fri, 07 Dec 2018 06:12:00 +0000</pubDate>
<dc:creator>笨神Fany</dc:creator>
<og:description>背景： 项目运行过程中会出现各种各样的问题，常见的有以下几种情况： 业务流程分析疏漏，对业务流程的反向操作、边界分析设计不充分 调用外部服务、调用外部系统出现的超时、错误、返回值与预期不符 外部资源连</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/f-anything/p/10082637.html</dc:identifier>
</item>
<item>
<title>使用Kubeadm(1.13)快速搭建Kubernetes集群 - 雨夜朦胧</title>
<link>http://www.cnblogs.com/RainingNight/p/using-kubeadm-to-create-a-cluster-1-13.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/RainingNight/p/using-kubeadm-to-create-a-cluster-1-13.html</guid>
<description>&lt;p&gt;Kubeadm是管理集群生命周期的重要工具，从创建到配置再到升级，Kubeadm处理现有硬件上的生产集群的引导，并以最佳实践方式配置核心Kubernetes组件，以便为新节点提供安全而简单的连接流程并支持轻松升级。随着Kubernetes 1.13 的发布，现在Kubeadm正式成为GA。&lt;/p&gt;
&lt;h2 id=&quot;准备&quot;&gt;准备&lt;/h2&gt;
&lt;p&gt;首先准备2台虚拟机（CPU最少2核），我是使用Hyper-V创建的2台Ubuntu18.04虚拟机，IP和机器名如下：&lt;/p&gt;
&lt;p&gt;172.17.20.210 master&lt;/p&gt;
&lt;p&gt;172.17.20.211 node1&lt;/p&gt;
&lt;h3 id=&quot;禁用swap&quot;&gt;禁用Swap&lt;/h3&gt;
&lt;p&gt;Kubernetes 1.8开始要求必须禁用Swap，如果不关闭，默认配置下kubelet将无法启动。&lt;/p&gt;
&lt;p&gt;编辑&lt;code&gt;/etc/fstab&lt;/code&gt;文件：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;raining@master:~$ sudo vim /etc/fstab

UUID=8be04efd-f7c5-11e8-be8b-00155d000500 / ext4 defaults 0 0
UUID=C0E3-6A72 /boot/efi vfat defaults 0 0
#/swap.img      none    swap    sw      0       0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如上，将&lt;code&gt;/swap.img&lt;/code&gt;所在的行注释掉，然后运行：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;sudo swapoff -a&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;可选dns配置&quot;&gt;(可选)DNS配置&lt;/h3&gt;
&lt;p&gt;在Ubuntu18.04+版本中，DNS由&lt;code&gt;systemd&lt;/code&gt;全面接管，接口监听在&lt;code&gt;127.0.0.53:53&lt;/code&gt;，配置文件在&lt;code&gt;/etc/systemd/resolved.conf&lt;/code&gt;中。&lt;/p&gt;
&lt;p&gt;有时候会导致无法解析域名的问题，可使用如下2种方式来解决：&lt;/p&gt;
&lt;p&gt;1.最简单的就是关闭systemd-resolvd服务&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;sudo systemctl stop systemd-resolved
sudo systemctl disable systemd-resolved&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后手动修改&lt;code&gt;/etc/resolv.conf&lt;/code&gt;文件就可以了。&lt;/p&gt;
&lt;p&gt;2.更加推荐的做法是修改systemd-resolv的设置：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;sudo vim /etc/systemd/resolved.conf

# 修改为如下
[Resolve]
DNS=1.1.1.1 1.0.0.1
#FallbackDNS=
#Domains=
LLMNR=no
#MulticastDNS=no
#DNSSEC=no
#Cache=yes
#DNSStubListener=yes&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;DNS=&lt;/strong&gt;设置的是域名解析服务器的IP地址，这里分别设为1.1.1.1和1.0.0.1&lt;br/&gt;&lt;strong&gt;LLMNR=&lt;/strong&gt;设置的是禁止运行LLMNR(Link-Local Multicast Name Resolution)，否则systemd-resolve会监听5535端口。&lt;/p&gt;
&lt;h3 id=&quot;安装docker&quot;&gt;安装Docker&lt;/h3&gt;
&lt;p&gt;Kubernetes从1.6开始使用CRI(Container Runtime Interface)容器运行时接口。默认的容器运行时仍然是Docker，是使用kubelet中内置&lt;em&gt;dockershim CRI&lt;/em&gt;来实现的。&lt;/p&gt;
&lt;p&gt;Docker的安装可以参考之前的博客：&lt;a href=&quot;http://www.cnblogs.com/RainingNight/p/first-docker-note.html#%E5%AE%89%E8%A3%85&quot;&gt;Docker初体验&lt;/a&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;15&quot;&gt;
&lt;p&gt;需要注意的是，Kubernetes 1.13已经针对Docker的1.11.1, 1.12.1, 1.13.1, 17.03, 17.06, 17.09, 18.06等版本做了验证，最低支持的Docker版本是1.11.1，最高支持是18.06，而Docker最新版本已经是&lt;code&gt;18.09&lt;/code&gt;了，故我们安装时需要指定版本为&lt;code&gt;18.06.1-ce&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;sudo apt install docker-ce=18.06.1~ce~3-0~ubuntu&lt;/code&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;h3 id=&quot;安装kubeadm-kubelet-和-kubectl&quot;&gt;安装kubeadm, kubelet 和 kubectl&lt;/h3&gt;
&lt;p&gt;部署之前，我们需要安装三个包：&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;kubeadm&lt;/strong&gt;: 引导启动k8s集群的命令行工具。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;kubelet&lt;/strong&gt;: 在群集中所有节点上运行的核心组件, 用来执行如启动pods和containers等操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;kubectl&lt;/strong&gt;: 操作集群的命令行工具。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;首先添加apt-key：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;sudo apt update &amp;amp;&amp;amp; sudo apt install -y apt-transport-https curl
curl -s https://mirrors.aliyun.com/kubernetes/apt/doc/apt-key.gpg | sudo apt-key add -&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;添加kubernetes源：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;sudo vim /etc/apt/sources.list.d/kubernetes.list

deb https://mirrors.aliyun.com/kubernetes/apt/ kubernetes-xenial main&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;安装：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;sudo apt update
sudo apt install -y kubelet kubeadm kubectl
sudo apt-mark hold kubelet kubeadm kubectl&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;使用kubeadm创建一个单master集群&quot;&gt;使用kubeadm创建一个单Master集群&lt;/h2&gt;
&lt;h3 id=&quot;初始化master节点&quot;&gt;初始化Master节点&lt;/h3&gt;
&lt;p&gt;K8s的控制面板组件运行在Master节点上，包括etcd和API server（Kubectl便是通过API server与k8s通信）。&lt;/p&gt;
&lt;p&gt;在执行初始化之前，我们还有一下3点需要注意：&lt;/p&gt;
&lt;p&gt;1.选择一个网络插件，并检查它是否需要在初始化Master时指定一些参数，比如我们可能需要根据选择的插件来设置&lt;code&gt;--pod-network-cidr&lt;/code&gt;参数。参考：&lt;a href=&quot;https://kubernetes.io/docs/setup/independent/create-cluster-kubeadm/#pod-network&quot;&gt;Installing a pod network add-on&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;2.kubeadm使用eth0的默认网络接口（通常是内网IP）做为Master节点的advertise address，如果我们想使用不同的网络接口，可以使用&lt;code&gt;--apiserver-advertise-address=&amp;lt;ip-address&amp;gt;&lt;/code&gt;参数来设置。如果适应IPv6，则必须使用IPv6d的地址，如：&lt;code&gt;--apiserver-advertise-address=fd00::101&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;3.使用&lt;code&gt;kubeadm config images pull&lt;/code&gt;来预先拉取初始化需要用到的镜像，用来检查是否能连接到Kubenetes的Registries。&lt;/p&gt;
&lt;p&gt;Kubenetes默认Registries地址是&lt;code&gt;k8s.gcr.io&lt;/code&gt;，很明显，在国内并不能访问gcr.io，因此在kubeadm v1.13之前的版本，安装起来非常麻烦，但是在&lt;code&gt;1.13&lt;/code&gt;版本中终于解决了国内的痛点，其增加了一个&lt;code&gt;--image-repository&lt;/code&gt;参数，默认值是&lt;code&gt;k8s.gcr.io&lt;/code&gt;，我们将其指定为国内镜像地址：&lt;code&gt;registry.aliyuncs.com/google_containers&lt;/code&gt;，其它的就可以完全按照官方文档来愉快的玩耍了。&lt;/p&gt;
&lt;p&gt;其次，我们还需要指定&lt;code&gt;--kubernetes-version&lt;/code&gt;参数，因为它的默认值是&lt;code&gt;stable-1&lt;/code&gt;，会导致从&lt;code&gt;https://dl.k8s.io/release/stable-1.txt&lt;/code&gt;下载最新的版本号，我们可以将其指定为固定版本（最新版：v1.13.0）来跳过网络请求。&lt;/p&gt;
&lt;p&gt;现在，我们就来试一下：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;# 使用calico网络 --pod-network-cidr=192.168.0.0/16
sudo kubeadm init --image-repository registry.aliyuncs.com/google_containers --kubernetes-version v1.13.0 --pod-network-cidr=192.168.0.0/16

# 输出
[init] Using Kubernetes version: v1.13.0
[preflight] Running pre-flight checks
[preflight] Pulling images required for setting up a Kubernetes cluster
[preflight] This might take a minute or two, depending on the speed of your internet connection
[preflight] You can also perform this action in beforehand using 'kubeadm config images pull'
[kubelet-start] Writing kubelet environment file with flags to file &quot;/var/lib/kubelet/kubeadm-flags.env&quot;
[kubelet-start] Writing kubelet configuration to file &quot;/var/lib/kubelet/config.yaml&quot;
[kubelet-start] Activating the kubelet service
[certs] Using certificateDir folder &quot;/etc/kubernetes/pki&quot;
[certs] Generating &quot;ca&quot; certificate and key
[certs] Generating &quot;apiserver&quot; certificate and key
[certs] apiserver serving cert is signed for DNS names [master kubernetes kubernetes.default kubernetes.default.svc kubernetes.default.svc.cluster.local] and IPs [10.96.0.1 172.17.20.210]
[certs] Generating &quot;apiserver-kubelet-client&quot; certificate and key
[certs] Generating &quot;front-proxy-ca&quot; certificate and key
[certs] Generating &quot;front-proxy-client&quot; certificate and key
[certs] Generating &quot;etcd/ca&quot; certificate and key
[certs] Generating &quot;etcd/peer&quot; certificate and key
[certs] etcd/peer serving cert is signed for DNS names [master localhost] and IPs [172.17.20.210 127.0.0.1 ::1]
[certs] Generating &quot;etcd/server&quot; certificate and key
[certs] etcd/server serving cert is signed for DNS names [master localhost] and IPs [172.17.20.210 127.0.0.1 ::1]
[certs] Generating &quot;etcd/healthcheck-client&quot; certificate and key
[certs] Generating &quot;apiserver-etcd-client&quot; certificate and key
[certs] Generating &quot;sa&quot; key and public key
[kubeconfig] Using kubeconfig folder &quot;/etc/kubernetes&quot;
[kubeconfig] Writing &quot;admin.conf&quot; kubeconfig file
[kubeconfig] Writing &quot;kubelet.conf&quot; kubeconfig file
[kubeconfig] Writing &quot;controller-manager.conf&quot; kubeconfig file
[kubeconfig] Writing &quot;scheduler.conf&quot; kubeconfig file
[control-plane] Using manifest folder &quot;/etc/kubernetes/manifests&quot;
[control-plane] Creating static Pod manifest for &quot;kube-apiserver&quot;
[control-plane] Creating static Pod manifest for &quot;kube-controller-manager&quot;
[control-plane] Creating static Pod manifest for &quot;kube-scheduler&quot;
[etcd] Creating static Pod manifest for local etcd in &quot;/etc/kubernetes/manifests&quot;
[wait-control-plane] Waiting for the kubelet to boot up the control plane as static Pods from directory &quot;/etc/kubernetes/manifests&quot;. This can take up to 4m0s
[kubelet-check] Initial timeout of 40s passed.
[apiclient] All control plane components are healthy after 42.003645 seconds
[uploadconfig] storing the configuration used in ConfigMap &quot;kubeadm-config&quot; in the &quot;kube-system&quot; Namespace
[kubelet] Creating a ConfigMap &quot;kubelet-config-1.13&quot; in namespace kube-system with the configuration for the kubelets in the cluster
[patchnode] Uploading the CRI Socket information &quot;/var/run/dockershim.sock&quot; to the Node API object &quot;master&quot; as an annotation
[mark-control-plane] Marking the node master as control-plane by adding the label &quot;node-role.kubernetes.io/master=''&quot;
[mark-control-plane] Marking the node master as control-plane by adding the taints [node-role.kubernetes.io/master:NoSchedule]
[bootstrap-token] Using token: 6pkrlg.8glf2fqpuf3i489m
[bootstrap-token] Configuring bootstrap tokens, cluster-info ConfigMap, RBAC Roles
[bootstraptoken] configured RBAC rules to allow Node Bootstrap tokens to post CSRs in order for nodes to get long term certificate credentials
[bootstraptoken] configured RBAC rules to allow the csrapprover controller automatically approve CSRs from a Node Bootstrap Token
[bootstraptoken] configured RBAC rules to allow certificate rotation for all node client certificates in the cluster
[bootstraptoken] creating the &quot;cluster-info&quot; ConfigMap in the &quot;kube-public&quot; namespace
[addons] Applied essential addon: CoreDNS
[addons] Applied essential addon: kube-proxy

Your Kubernetes master has initialized successfully!

To start using your cluster, you need to run the following as a regular user:

  mkdir -p $HOME/.kube
  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
  sudo chown $(id -u):$(id -g) $HOME/.kube/config

You should now deploy a pod network to the cluster.
Run &quot;kubectl apply -f [podnetwork].yaml&quot; with one of the options listed at:
  https://kubernetes.io/docs/concepts/cluster-administration/addons/

You can now join any number of machines by running the following on each node
as root:

  kubeadm join 172.17.20.210:6443 --token 6pkrlg.8glf2fqpuf3i489m --discovery-token-ca-cert-hash sha256:eebfe256113bee397b218ba832f412273ae734bd4686241fb910885d26efd222&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这次非常顺利的就部署成功了，如果我们想使用非root用户操作&lt;code&gt;kubectl&lt;/code&gt;，可以使用以下命令，这也是&lt;code&gt;kubeadm init&lt;/code&gt;输出的一部分：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;mkdir -p $HOME/.kube
sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
sudo chown $(id -u):$(id -g) $HOME/.kube/config&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;安装网络插件&quot;&gt;安装网络插件&lt;/h3&gt;
&lt;p&gt;为了让Pods间可以相互通信，我们必须安装一个网络插件，并且必须在部署任何应用之前安装，&lt;strong&gt;CoreDNS&lt;/strong&gt;也是在网络插件安装之后才会启动的。&lt;/p&gt;
&lt;p&gt;网络的插件完整列表，请参考 &lt;a href=&quot;https://kubernetes.io/docs/concepts/cluster-administration/addons/&quot;&gt;Networking and Network Policy&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;在安装之前，我们先查看一下当前Pods的状态：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;kubectl get pods --all-namespaces

# 输出
NAMESPACE     NAME                             READY   STATUS    RESTARTS   AGE
kube-system   coredns-78d4cf999f-6pgfr         0/1     Pending   0          87s
kube-system   coredns-78d4cf999f-m9kgs         0/1     Pending   0          87s
kube-system   etcd-master                      1/1     Running   0          47s
kube-system   kube-apiserver-master            1/1     Running   0          38s
kube-system   kube-controller-manager-master   1/1     Running   0          55s
kube-system   kube-proxy-mkg24                 1/1     Running   0          87s
kube-system   kube-scheduler-master            1/1     Running   0          41s&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如上，可以看到&lt;strong&gt;CoreDND&lt;/strong&gt;的状态是&lt;code&gt;Pending&lt;/code&gt;，这是因为我们还没有安装网络插件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Calico&lt;/strong&gt;是一个纯三层的虚拟网络方案，Calico 为每个容器分配一个 IP，每个 host 都是 router，把不同 host 的容器连接起来。与 VxLAN 不同的是，Calico 不对数据包做额外封装，不需要 NAT 和端口映射，扩展性和性能都很好。&lt;/p&gt;
&lt;p&gt;默认情况下，Calico网络插件使用的的网段是&lt;code&gt;192.168.0.0/16&lt;/code&gt;，在&lt;code&gt;init&lt;/code&gt;的时候，我们已经通过&lt;code&gt;--pod-network-cidr=192.168.0.0/16&lt;/code&gt;来适配Calico，当然你也可以修改&lt;code&gt;calico.yml&lt;/code&gt;文件来指定不同的网段。&lt;/p&gt;
&lt;p&gt;可以使用如下命令命令来安装&lt;code&gt;Canal&lt;/code&gt;插件：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;kubectl apply -f https://docs.projectcalico.org/v3.3/getting-started/kubernetes/installation/hosted/rbac-kdd.yaml
kubectl apply -f https://docs.projectcalico.org/v3.3/getting-started/kubernetes/installation/hosted/kubernetes-datastore/calico-networking/1.7/calico.yaml

# 上面的calico.yaml会去quay.io拉取镜像，如果无法拉取，可使用下面的国内镜像
kubectl apply -f http://mirror.faasx.com/k8s/calico/v3.3.2/rbac-kdd.yaml
kubectl apply -f http://mirror.faasx.com/k8s/calico/v3.3.2/calico.yaml&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;关于更多&lt;code&gt;Canal&lt;/code&gt;的信息可以查看Calico官方文档：&lt;a href=&quot;https://docs.projectcalico.org/v3.3/getting-started/kubernetes&quot;&gt;kubeadm quickstart&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;稍等片刻，再使用&lt;code&gt;kubectl get pods --all-namespaces&lt;/code&gt;命令来查看网络插件的安装情况：&lt;/p&gt;
&lt;pre class=&quot;text&quot;&gt;
&lt;code&gt;kubectl get pods --all-namespaces

# 输出
NAMESPACE     NAME                             READY   STATUS    RESTARTS   AGE
kube-system   calico-node-x96gn                2/2     Running   0          47s
kube-system   coredns-78d4cf999f-6pgfr         1/1     Running   0          54m
kube-system   coredns-78d4cf999f-m9kgs         1/1     Running   0          54m
kube-system   etcd-master                      1/1     Running   3          53m
kube-system   kube-apiserver-master            1/1     Running   3          53m
kube-system   kube-controller-manager-master   1/1     Running   3          53m
kube-system   kube-proxy-mkg24                 1/1     Running   2          54m
kube-system   kube-scheduler-master            1/1     Running   3          53m&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如上，STATUS全部变为了&lt;code&gt;Running&lt;/code&gt;，表示安装成功，接下来就可以加入其他节点以及部署应用了。&lt;/p&gt;
&lt;h3 id=&quot;master隔离&quot;&gt;Master隔离&lt;/h3&gt;
&lt;p&gt;默认情况下，由于安全原因，集群并不会将pods部署在Master节点上。但是在开发环境下，我们可能就只有一个Master节点，这时可以使用下面的命令来解除这个限制：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;kubectl taint nodes --all node-role.kubernetes.io/master-

## 输出
node/master untainted&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;加入工作节点&quot;&gt;加入工作节点&lt;/h3&gt;
&lt;p&gt;要为群集添加工作节点，需要为每台计算机执行以下操作：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;SSH到机器&lt;/li&gt;
&lt;li&gt;成为root用户，(如: sudo su -)&lt;/li&gt;
&lt;li&gt;运行上面的&lt;code&gt;kubeadm init&lt;/code&gt;命令输出的：&lt;code&gt;kubeadm join --token &amp;lt;token&amp;gt; &amp;lt;master-ip&amp;gt;:&amp;lt;master-port&amp;gt; --discovery-token-ca-cert-hash sha256:&amp;lt;hash&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果我们忘记了Master节点的加入token，可以使用如下命令来查看：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;kubeadm token list

# 输出
TOKEN                     TTL       EXPIRES                USAGES                   DESCRIPTION                                                EXTRA GROUPS
6pkrlg.8glf2fqpuf3i489m   22h       2018-12-07T13:46:33Z   authentication,signing   The default bootstrap token generated by 'kubeadm init'.   system:bootstrappers:kubeadm:default-node-token&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;默认情况下，token的有效期是24小时，如果我们的token已经过期的话，可以使用以下命令重新生成：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;kubeadm token create

# 输出
u2mt59.tyqpo0v5wf05lx2q&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果我们也没有&lt;code&gt;--discovery-token-ca-cert-hash&lt;/code&gt;的值，可以使用以下命令生成：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;openssl x509 -pubkey -in /etc/kubernetes/pki/ca.crt | openssl rsa -pubin -outform der 2&amp;gt;/dev/null | openssl dgst -sha256 -hex | sed 's/^.* //'

# 输出
eebfe256113bee397b218ba832f412273ae734bd4686241fb910885d26efd222&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在，我们登录到工作节点服务器，然后运行如下命令加入集群（这也是上面&lt;code&gt;init&lt;/code&gt;输出的一部分）：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;sudo kubeadm join 172.17.20.210:6443 --token 6pkrlg.8glf2fqpuf3i489m --discovery-token-ca-cert-hash sha256:eebfe256113bee397b218ba832f412273ae734bd4686241fb910885d26efd222

# 输出
[sudo] password for raining: 
[preflight] Running pre-flight checks
[discovery] Trying to connect to API Server &quot;172.17.20.210:6443&quot;
[discovery] Created cluster-info discovery client, requesting info from &quot;https://172.17.20.210:6443&quot;
[discovery] Requesting info from &quot;https://172.17.20.210:6443&quot; again to validate TLS against the pinned public key
[discovery] Cluster info signature and contents are valid and TLS certificate validates against pinned roots, will use API Server &quot;172.17.20.210:6443&quot;
[discovery] Successfully established connection with API Server &quot;172.17.20.210:6443&quot;
[join] Reading configuration from the cluster...
[join] FYI: You can look at this config file with 'kubectl -n kube-system get cm kubeadm-config -oyaml'
[kubelet] Downloading configuration for the kubelet from the &quot;kubelet-config-1.13&quot; ConfigMap in the kube-system namespace
[kubelet-start] Writing kubelet configuration to file &quot;/var/lib/kubelet/config.yaml&quot;
[kubelet-start] Writing kubelet environment file with flags to file &quot;/var/lib/kubelet/kubeadm-flags.env&quot;
[kubelet-start] Activating the kubelet service
[tlsbootstrap] Waiting for the kubelet to perform the TLS Bootstrap...
[patchnode] Uploading the CRI Socket information &quot;/var/run/dockershim.sock&quot; to the Node API object &quot;node1&quot; as an annotation

This node has joined the cluster:
* Certificate signing request was sent to apiserver and a response was received.
* The Kubelet was informed of the new secure connection details.

Run 'kubectl get nodes' on the master to see this node join the cluster.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;等待一会，我们可以在Master节点上使用&lt;code&gt;kubectl get nodes&lt;/code&gt;命令来查看节点的状态：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;kubectl get nodes

# 输出
NAME     STATUS   ROLES    AGE   VERSION
master   Ready    master   17m   v1.13.0
node1    Ready    &amp;lt;none&amp;gt;   15m   v1.13.0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如上全部&lt;code&gt;Ready&lt;/code&gt;，大功告成，我们可以运行一些命令来测试一下集群是否正常。&lt;/p&gt;
&lt;h3 id=&quot;测试&quot;&gt;测试&lt;/h3&gt;
&lt;p&gt;首先验证&lt;em&gt;kube-apiserver&lt;/em&gt;, &lt;em&gt;kube-controller-manager&lt;/em&gt;, &lt;em&gt;kube-scheduler&lt;/em&gt;, &lt;em&gt;pod network&lt;/em&gt; 是否正常：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;# 部署一个 Nginx Deployment，包含两个Pod
# https://kubernetes.io/docs/concepts/workloads/controllers/deployment/
kubectl create deployment nginx --image=nginx:alpine
kubectl scale deployment nginx --replicas=2

# 验证Nginx Pod是否正确运行，并且会分配192.168.开头的集群IP
kubectl get pods -l app=nginx -o wide

# 输出如下：
NAME                     READY   STATUS    RESTARTS   AGE   IP            NODE    NOMINATED NODE   READINESS GATES
nginx-54458cd494-p8jzs   1/1     Running   0          31s   192.168.1.2   node1   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
nginx-54458cd494-v2m4b   1/1     Running   0          24s   192.168.1.3   node1   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再验证一下&lt;code&gt;kube-proxy&lt;/code&gt;是否正常：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;# 以 NodePort 方式对外提供服务 https://kubernetes.io/docs/concepts/services-networking/connect-applications-service/
kubectl expose deployment nginx --port=80 --type=NodePort

# 查看集群外可访问的Port
kubectl get services nginx

# 输出
NAME    TYPE       CLUSTER-IP     EXTERNAL-IP   PORT(S)        AGE
nginx   NodePort   10.110.49.49   &amp;lt;none&amp;gt;        80:31899/TCP   4s

# 可以通过任意 NodeIP:Port 在集群外部访问这个服务，本示例中部署的2台集群IP分别是172.17.20.210和172.17.20.211
curl http://172.17.20.210:31899
curl http://172.17.20.211:31899&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后验证一下&lt;em&gt;dns&lt;/em&gt;, &lt;em&gt;pod network&lt;/em&gt;是否正常：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;# 运行Busybox并进入交互模式
kubectl run -it curl --image=radial/busyboxplus:curl

# 输入`nslookup nginx`查看是否可以正确解析出集群内的IP，已验证DNS是否正常
[ root@curl-66959f6557-6sfqh:/ ]$ nslookup nginx

# 输出
Server:    10.96.0.10
Address 1: 10.96.0.10 kube-dns.kube-system.svc.cluster.local

Name:      nginx
Address 1: 10.110.49.49 nginx.default.svc.cluster.local

# 通过服务名进行访问，验证kube-proxy是否正常
[ root@curl-66959f6557-6sfqh:/ ]$ curl http://nginx/

# 输出如下：
# &amp;lt;!DOCTYPE html&amp;gt; ---省略

# 分别访问一下2个Pod的内网IP，验证跨Node的网络通信是否正常
[ root@curl-66959f6557-6sfqh:/ ]$ curl http://192.168.1.2/
[ root@curl-66959f6557-6sfqh:/ ]$ curl http://192.168.1.3/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;验证通过，集群搭建成功，接下来我们就可以参考&lt;a href=&quot;https://kubernetes.io/docs/home&quot;&gt;官方文档&lt;/a&gt;来部署其他服务，愉快的玩耍了。&lt;/p&gt;
&lt;h2 id=&quot;卸载集群&quot;&gt;卸载集群&lt;/h2&gt;
&lt;p&gt;想要撤销kubeadm执行的操作，首先要&lt;a href=&quot;https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#drain&quot;&gt;排除节点&lt;/a&gt;，并确保该节点为空, 然后再将其关闭。&lt;/p&gt;
&lt;p&gt;在Master节点上运行：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;kubectl drain &amp;lt;node name&amp;gt; --delete-local-data --force --ignore-daemonsets
kubectl delete node &amp;lt;node name&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在需要移除的节点上，重置kubeadm的安装状态：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;sudo kubeadm reset&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果你想重新配置集群，使用新的参数重新运行&lt;code&gt;kubeadm init&lt;/code&gt;或者&lt;code&gt;kubeadm join&lt;/code&gt;即可。&lt;/p&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;
</description>
<pubDate>Fri, 07 Dec 2018 05:27:00 +0000</pubDate>
<dc:creator>雨夜朦胧</dc:creator>
<og:description>Kubeadm是管理集群生命周期的重要工具，从创建到配置再到升级，Kubeadm处理现有硬件上的生产集群的引导，并以最佳实践方式配置核心Kubernetes组件，以便为新节点提供安全而简单的连接流程并</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/RainingNight/p/using-kubeadm-to-create-a-cluster-1-13.html</dc:identifier>
</item>
<item>
<title>Linux环境下安装hadoop伪分布式集群+问题总结 - M珂</title>
<link>http://www.cnblogs.com/meng9688/p/10080346.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/meng9688/p/10080346.html</guid>
<description>&lt;p&gt;linux下安装hadoop伪分布式集群参考博客：https://blog.csdn.net/huiweizuotiandeni/article/details/59632613&lt;/p&gt;
&lt;p&gt;上述博客内容其实和官网上讲的差不多，跟着做理论上是不会出现问题的，但是实际中自己操作总会出现一些不应该出现的bug。&lt;/p&gt;
&lt;p&gt;而我在配置该环境的时候便出现了很多本不应该出现的问题，在此做一个总结，以防再犯。&lt;/p&gt;
&lt;p&gt;我的系统是Ubuntu18.0，和Ubuntu16.0基本一致。&lt;/p&gt;
&lt;p&gt;JAVA安装只需要下载安装包，解压之后配置环境变量，执行source 命令使环境变量生效即可。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;export PATH=$GOROOT/bin:$GOPATH/&lt;span&gt;bin:$PATH
export JAVA_HOME&lt;/span&gt;=/home/meng/app/jdk1.&lt;span&gt;8.0&lt;/span&gt;&lt;span&gt;
export CLASSPATH&lt;/span&gt;=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/&lt;span&gt;tools.jar:$CLASSPATH
export PATH&lt;/span&gt;=$JAVA_HOME/&lt;span&gt;bin:$PATH
export HADOOP_HOME&lt;/span&gt;=$HOME/app/hadoop-&lt;span&gt;2.6&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;-cdh5.&lt;span&gt;7.0&lt;/span&gt;&lt;span&gt;
export PATH&lt;/span&gt;=$HADOOP_HOME/bin:$PATH&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而Hadoop安装不仅需要这些工作（解压加配置环境变量），而且还需要修改一部分配置文件，才可以使其正常运行。&lt;/p&gt;
&lt;p&gt;而所需要配置的文件基本都在解压缩后的hadoop目录下的/etc/hadoop文件夹&lt;/p&gt;
&lt;p&gt;这些文件分别是：hadoop-env.sh、core-site.xml、hdfs-site.xml、mapred-site.xml、yarn-site.xml、slaves、master&lt;/p&gt;
&lt;p&gt;hadoop-env.sh是hadoop环境配置的文件，需要添加JAVA_HOME变量&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;# The java implementation to use.
export JAVA_HOME&lt;/span&gt;=/home/meng/app/jdk1.&lt;span&gt;8.0&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;core-site.xml文件的作用:定义hdfs中namenode的地址，还有tmp文件的地址&lt;/p&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;configuration&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 指定HADOOP所使用的文件系统schema(URI),HDFS的老大（NAMENODE）的地址  &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;fs.defaultFS&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;hdfs://192.168.72.128:9000&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;hadoop.tmp.dir&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;file:/home/meng/app/tmp&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;io.file.buffer.size&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;131702&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;configuration&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;hdfs-site.xml文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;configuration&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 指定namenode路径  &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;dfs.namenode.name.dir&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;/home/meng/app/hadoop/namenode&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 指定datanode路径 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;dfs.datanode.name.dir&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;/home/meng/app/hadoop/datanode&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 指定hdfs副本的数量 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;dfs.replication&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;dfs.namenode.secondary.http-address&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;hadoop:9001&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;dfs.webhdfs.enabled&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;true&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;configuration&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;mapred-site.xml文件（若文件夹下没有该文件，可将mapred-site.xml.template重命名为mapred-site.xml）&lt;/p&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;configuration&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 指定mapreduce 运行在yarn上  &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;mapreduce.framework.name&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;yarn&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;final&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;true&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;final&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;configuration&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;yarn-site.xml：这里的localhost只是在本机测试而使用的，实际中最好使用自己的本机IP地址替换。&lt;/p&gt;
&lt;div readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;configuration&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; Site specific YARN configuration properties &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 设置yarn的主机地址 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;yarn.resourcemanager.hostname&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;localhost&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;yarn.nodemanager.aux-services&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
　　　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;mapreduce_shuffle&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property
&amp;lt;/configuration&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;更改master文件，加入自己的IP地址或者主机名。&lt;/p&gt;
&lt;p&gt;更改slaves文件，slaves加入自己的ip地址，这是由于伪分布式master和slaves都是本机。&lt;/p&gt;
&lt;p&gt;所有配置文件修改完后，还有一个关键步骤：配置SSH免密钥登录&lt;/p&gt;
&lt;p&gt;该配置可参考博客：https://blog.csdn.net/u011414200/article/details/47681675&lt;/p&gt;
&lt;p&gt;之后便是启动hadoop&lt;/p&gt;
&lt;p&gt;首次启动，需要格式化namenode&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
hdfs namenode -format
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在hadoop安装目录下有一个sbin文件夹&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
derby.log           hdfs-config.&lt;span&gt;sh&lt;/span&gt;  metastore_db        start-all.&lt;span&gt;sh&lt;/span&gt;         start-yarn.&lt;span&gt;sh&lt;/span&gt;     stop-secure-dns.&lt;span&gt;sh&lt;/span&gt;&lt;span&gt;
distribute&lt;/span&gt;-exclude.&lt;span&gt;sh&lt;/span&gt;  httpfs.&lt;span&gt;sh&lt;/span&gt;       mr-jobhistory-daemon.&lt;span&gt;sh&lt;/span&gt;    start-balancer.&lt;span&gt;sh&lt;/span&gt;    stop-all.&lt;span&gt;sh&lt;/span&gt;       stop-yarn.&lt;span&gt;sh&lt;/span&gt;&lt;span&gt;
hadoop&lt;/span&gt;-daemon.&lt;span&gt;sh&lt;/span&gt;       kms.&lt;span&gt;sh&lt;/span&gt;           refresh-namenodes.&lt;span&gt;sh&lt;/span&gt;    start-dfs.&lt;span&gt;sh&lt;/span&gt;         stop-balancer.&lt;span&gt;sh&lt;/span&gt;  yarn-daemon.&lt;span&gt;sh&lt;/span&gt;&lt;span&gt;
hadoop&lt;/span&gt;-daemons.&lt;span&gt;sh&lt;/span&gt;      Linux           slaves.&lt;span&gt;sh&lt;/span&gt;        start-secure-dns.&lt;span&gt;sh&lt;/span&gt;  stop-dfs.&lt;span&gt;sh&lt;/span&gt;       yarn-daemons.&lt;span&gt;sh&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 执行start-all.sh文件即可。&lt;/p&gt;
&lt;p&gt;在完成上述设置后，笔者的datanode始终运行不了，后来几经修改尝试，根据core-site.xml中配置的tmp路径，找到对应的tmp文件夹，将其清空之后，便可运行成功。&lt;/p&gt;
&lt;p&gt;而在这些节点报错时，我们需要如何看错误日志呢？当我们执行start-all.sh文件文件时，控制台会打印这些信息，而下划线标注的路径即时log日志保存的路径。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
This script is Deprecated. Instead use start-dfs.&lt;span&gt;sh&lt;/span&gt; and start-yarn.&lt;span&gt;sh&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;/&lt;span&gt;12&lt;/span&gt;/&lt;span&gt;06&lt;/span&gt; &lt;span&gt;21&lt;/span&gt;:&lt;span&gt;27&lt;/span&gt;:&lt;span&gt;37&lt;/span&gt; WARN util.NativeCodeLoader: Unable to load native-hadoop library &lt;span&gt;for&lt;/span&gt; your platform... using builtin-&lt;span&gt;java classes where applicable
Starting namenodes on [&lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;72.128&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;72.128&lt;/span&gt;: starting namenode, &lt;span&gt;&lt;span&gt;&lt;strong&gt;logging to /home/meng/app/hadoop-&lt;span&gt;2.6&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;-cdh5.&lt;span&gt;7.0&lt;/span&gt;/logs/hadoop-meng-namenode-&lt;span&gt;hadoop.out
&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;72.128&lt;/span&gt;: starting datanode, &lt;span&gt;&lt;span&gt;&lt;strong&gt;logging to /home/meng/app/hadoop-&lt;span&gt;2.6&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;-cdh5.&lt;span&gt;7.0&lt;/span&gt;/logs/hadoop-meng-datanode-&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;hadoop.out&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;
Starting secondary namenodes [hadoop]
hadoop: starting secondarynamenode, &lt;span&gt;&lt;strong&gt;&lt;span&gt;logging to &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;/home/meng/app/hadoop-&lt;span&gt;2.6&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;-cdh5.&lt;span&gt;7.0&lt;/span&gt;/logs/hadoop-meng-secondarynamenode-&lt;span&gt;hadoop.out
&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;/&lt;span&gt;12&lt;/span&gt;/&lt;span&gt;06&lt;/span&gt; &lt;span&gt;21&lt;/span&gt;:&lt;span&gt;27&lt;/span&gt;:&lt;span&gt;55&lt;/span&gt; WARN util.NativeCodeLoader: Unable to load native-hadoop library &lt;span&gt;for&lt;/span&gt; your platform... using builtin-&lt;span&gt;java classes where applicable
starting yarn daemons
starting resourcemanager, &lt;span&gt;&lt;strong&gt;logging to &lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;/home/meng/app/hadoop-&lt;span&gt;2.6&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;-cdh5.&lt;span&gt;7.0&lt;/span&gt;/logs/yarn-meng-resourcemanager-&lt;span&gt;hadoop.out
&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;72.128&lt;/span&gt;: starting nodemanager, &lt;span&gt;&lt;strong&gt;logging to /home/meng/app/hadoop-&lt;span&gt;2.6&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;-cdh5.&lt;span&gt;7.0&lt;/span&gt;/logs/yarn-meng-nodemanager-hadoop.out&lt;/strong&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;datanode的日志文件报错如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;72.128&lt;/span&gt;:&lt;span&gt;9000&lt;/span&gt;&lt;span&gt; starting to offer service
&lt;/span&gt;&lt;span&gt;2018&lt;/span&gt;-&lt;span&gt;12&lt;/span&gt;-&lt;span&gt;06&lt;/span&gt; &lt;span&gt;04&lt;/span&gt;:&lt;span&gt;49&lt;/span&gt;:&lt;span&gt;08&lt;/span&gt;,&lt;span&gt;925&lt;/span&gt;&lt;span&gt; INFO org.apache.hadoop.ipc.Server: IPC Server Responder: starting
&lt;/span&gt;&lt;span&gt;2018&lt;/span&gt;-&lt;span&gt;12&lt;/span&gt;-&lt;span&gt;06&lt;/span&gt; &lt;span&gt;04&lt;/span&gt;:&lt;span&gt;49&lt;/span&gt;:&lt;span&gt;08&lt;/span&gt;,&lt;span&gt;925&lt;/span&gt; INFO org.apache.hadoop.ipc.Server: IPC Server listener on &lt;span&gt;50020&lt;/span&gt;&lt;span&gt;: starting
&lt;/span&gt;&lt;span&gt;2018&lt;/span&gt;-&lt;span&gt;12&lt;/span&gt;-&lt;span&gt;06&lt;/span&gt; &lt;span&gt;04&lt;/span&gt;:&lt;span&gt;49&lt;/span&gt;:&lt;span&gt;09&lt;/span&gt;,&lt;span&gt;530&lt;/span&gt; INFO org.apache.hadoop.hdfs.server.common.Storage: Lock on /home/meng/app/tmp/dfs/data/in_use.lock acquired by nodename &lt;span&gt;21391&lt;/span&gt;&lt;span&gt;@localhost
&lt;/span&gt;&lt;span&gt;2018&lt;/span&gt;-&lt;span&gt;12&lt;/span&gt;-&lt;span&gt;06&lt;/span&gt; &lt;span&gt;04&lt;/span&gt;:&lt;span&gt;49&lt;/span&gt;:&lt;span&gt;09&lt;/span&gt;,&lt;span&gt;541&lt;/span&gt; WARN org.apache.hadoop.hdfs.server.common.Storage: java.io.IOException: &lt;span&gt;&lt;strong&gt;&lt;span&gt;Incompatible clusterIDs &lt;span&gt;in&lt;/span&gt; /home/meng/app/tmp/dfs/data: namenode clusterID = CID-c050c6d2-b27f-4db1-acfc-cfde956261a2; datanode clusterID = CID-0a0802fc-33a1-4cb0-b179-&lt;span&gt;04c30ec901a5
&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;2018&lt;/span&gt;-&lt;span&gt;12&lt;/span&gt;-&lt;span&gt;06&lt;/span&gt; &lt;span&gt;04&lt;/span&gt;:&lt;span&gt;49&lt;/span&gt;:&lt;span&gt;09&lt;/span&gt;,&lt;span&gt;542&lt;/span&gt; FATAL org.apache.hadoop.hdfs.server.datanode.DataNode: Initialization failed &lt;span&gt;for&lt;/span&gt; Block pool &amp;lt;registering&amp;gt; (Datanode Uuid unassigned) service to /&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;72.128&lt;/span&gt;:&lt;span&gt;9000&lt;/span&gt;&lt;span&gt;. Exiting. 
java.io.IOException: &lt;span&gt;&lt;strong&gt;All specified directories are failed to load.&lt;/strong&gt;&lt;/span&gt;
    at org.apache.hadoop.hdfs.server.datanode.DataStorage.recoverTransitionRead(DataStorage.java:&lt;/span&gt;&lt;span&gt;478&lt;/span&gt;&lt;span&gt;)
    at org.apache.hadoop.hdfs.server.datanode.DataNode.initStorage(DataNode.java:&lt;/span&gt;&lt;span&gt;1394&lt;/span&gt;&lt;span&gt;)
    at org.apache.hadoop.hdfs.server.datanode.DataNode.initBlockPool(DataNode.java:&lt;/span&gt;&lt;span&gt;1355&lt;/span&gt;&lt;span&gt;)
    at org.apache.hadoop.hdfs.server.datanode.BPOfferService.verifyAndSetNamespaceInfo(BPOfferService.java:&lt;/span&gt;&lt;span&gt;317&lt;/span&gt;&lt;span&gt;)
    at org.apache.hadoop.hdfs.server.datanode.BPServiceActor.connectToNNAndHandshake(BPServiceActor.java:&lt;/span&gt;&lt;span&gt;228&lt;/span&gt;&lt;span&gt;)
    at org.apache.hadoop.hdfs.server.datanode.BPServiceActor.run(BPServiceActor.java:&lt;/span&gt;&lt;span&gt;829&lt;/span&gt;&lt;span&gt;)
    at java.lang.Thread.run(Thread.java:&lt;/span&gt;&lt;span&gt;748&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;2018&lt;/span&gt;-&lt;span&gt;12&lt;/span&gt;-&lt;span&gt;06&lt;/span&gt; &lt;span&gt;04&lt;/span&gt;:&lt;span&gt;49&lt;/span&gt;:&lt;span&gt;09&lt;/span&gt;,&lt;span&gt;543&lt;/span&gt; WARN org.apache.hadoop.hdfs.server.datanode.DataNode: Ending block pool service &lt;span&gt;for&lt;/span&gt;: Block pool &amp;lt;registering&amp;gt; (Datanode Uuid unassigned) service to /&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;72.128&lt;/span&gt;:&lt;span&gt;9000&lt;/span&gt;
&lt;span&gt;2018&lt;/span&gt;-&lt;span&gt;12&lt;/span&gt;-&lt;span&gt;06&lt;/span&gt; &lt;span&gt;04&lt;/span&gt;:&lt;span&gt;49&lt;/span&gt;:&lt;span&gt;09&lt;/span&gt;,&lt;span&gt;545&lt;/span&gt; INFO org.apache.hadoop.hdfs.server.datanode.DataNode: Removed Block pool &amp;lt;registering&amp;gt;&lt;span&gt; (Datanode Uuid unassigned)
&lt;/span&gt;&lt;span&gt;2018&lt;/span&gt;-&lt;span&gt;12&lt;/span&gt;-&lt;span&gt;06&lt;/span&gt; &lt;span&gt;04&lt;/span&gt;:&lt;span&gt;49&lt;/span&gt;:&lt;span&gt;11&lt;/span&gt;,&lt;span&gt;546&lt;/span&gt;&lt;span&gt; WARN org.apache.hadoop.hdfs.server.datanode.DataNode: Exiting Datanode
&lt;/span&gt;&lt;span&gt;2018&lt;/span&gt;-&lt;span&gt;12&lt;/span&gt;-&lt;span&gt;06&lt;/span&gt; &lt;span&gt;04&lt;/span&gt;:&lt;span&gt;49&lt;/span&gt;:&lt;span&gt;11&lt;/span&gt;,&lt;span&gt;548&lt;/span&gt; INFO org.apache.hadoop.util.ExitUtil: Exiting with status &lt;span&gt;0&lt;/span&gt;
&lt;span&gt;2018&lt;/span&gt;-&lt;span&gt;12&lt;/span&gt;-&lt;span&gt;06&lt;/span&gt; &lt;span&gt;04&lt;/span&gt;:&lt;span&gt;49&lt;/span&gt;:&lt;span&gt;11&lt;/span&gt;,&lt;span&gt;566&lt;/span&gt;&lt;span&gt; INFO org.apache.hadoop.hdfs.server.datanode.DataNode: SHUTDOWN_MSG: 
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;***********************************************************
SHUTDOWN_MSG: Shutting down DataNode at localhost/127.0.0.1
***********************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过阅读上述日志可了解大意：namenode和datanode的簇ID不相容，而这些簇ID是保存在tmp文件夹下的，想必是由于笔者多次修改配置文件导致的一些问题，并不是一定会出现的，虽然不了解簇ID的生成机制，但是通过情况tmp文件应该会使其重新生成，问题便可被解决。&lt;/p&gt;
</description>
<pubDate>Fri, 07 Dec 2018 05:20:00 +0000</pubDate>
<dc:creator>M珂</dc:creator>
<og:description>linux下安装hadoop伪分布式集群参考博客：https://blog.csdn.net/huiweizuotiandeni/article/details/59632613 上述博客内容其实和官</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/meng9688/p/10080346.html</dc:identifier>
</item>
<item>
<title>深入浅出：远离法律风险，必须了解开源项目许可证 - 张太国</title>
<link>http://www.cnblogs.com/confach/p/10082311.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/confach/p/10082311.html</guid>
<description>&lt;p&gt;本文讲开源项目的许可证（License）。&lt;/p&gt;
&lt;p&gt;现在&lt;strong&gt;FOSS（Free Open Souce Software&lt;/strong&gt;）的项目逐步增多，而且项目引进FOSS项目也越来越多，以提高我们开发的效率，避免重复造轮子。那么在我们开心享用这些FOSS项目时，感叹世界真美好，但我们有没有认真去研读过它们的许可证呢？&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;引进FOSS项目需要注意什么？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;那么在引进FOSS的项目时，我们需要注意什么呢？对此不同的人有不同的答案。对此，我的看法是：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;需要了解FOSS项目许可&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;FOSS项目是否符合自己的需求。&lt;/li&gt;
&lt;li&gt;FOSS项目是否有人维护。&lt;/li&gt;
&lt;li&gt;FOSS项目的成熟度，社区的热度。&lt;/li&gt;
&lt;li&gt;FOSS项目的质量。&lt;/li&gt;
&lt;li&gt;FOSS项目的继承难度系数，以及是否能提高开发效率。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;本文只关注这里的第一步：FOSS项目许可证。为什么把许可证放在第一条呢？因为我觉得如果许可证都不合适，下面其他要素不用考虑了。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;License的重要性&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;无论作为个体还是公司，我们引进FOSS项目时，首先必须要考虑License的问题，如果不注意License的问题，自己的项目有可能会侵权，可能会把自己或者公司陷入法律风险的境地，如果真的这种事情发生，解决起来很麻烦。&lt;/p&gt;
&lt;p&gt;一般怎么处理呢？首先如果是个体，我们必须把常见的License类型了解清楚，如果是公司，需要有法务部门来审核，但是一般公司可能没有法务部门，那需要开发人员自己去把握。我清楚的记得，在前东家里，我配合公司的法务部门核查每个项目使用FOSS项目的情况，就是为了让项目和公司不处于被动地位。（其实我也亲身碰到过专利侵权问题，不过不在本文之内）。&lt;/p&gt;
&lt;p&gt;所以，&lt;span&gt;&lt;strong&gt;我们在引进FOSS项目时，一定要仔细项目的许可证，我们自己得有法律意识，这根弦必须得绷住&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;License类型&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;现在开源项目的类型实在太多了，参看这里，http://www.gnu.org/licenses/license-list.html， 估计有百种左右。但是，我们常见的许可证类型有以下几种&lt;/p&gt;
&lt;p&gt;我们常见的软件是什么类型呢？我们看看：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Apache HTTPd ，许可证是Apache&lt;/li&gt;
&lt;li&gt;Apache Tomcat， 也是Apache，似乎Apache Foundation都采用Apache许可。Dubbo也是，可以参看https://github.com/apache/incubator-dubbo/blob/master/LICENSE &lt;/li&gt;
&lt;li&gt;Spring Boot，也是Apache，https://github.com/spring-projects/spring-boot/blob/master/LICENSE.txt&lt;/li&gt;
&lt;li&gt;React，用的是MIT，https://github.com/facebook/react/blob/master/LICENSE&lt;/li&gt;
&lt;li&gt;Linux常用命令wget，用的是GPL，https://www.gnu.org/software/wget/ &lt;/li&gt;
&lt;li&gt;Linux操作系统， 用的也是GPL，https://www.kernel.org/category/faq.html &lt;/li&gt;
&lt;li&gt;QT，不同用途有不同的许可，包括LGPL，参看http://doc.qt.io/qt-5/licensing.html&lt;/li&gt;
&lt;li&gt;VI，用的就是BSD，https://www.freebsd.org/cgi/man.cgi?query=vi&amp;amp;sektion=1&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;License介绍&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;光去阅读许可证的描述太抽象了，我借用阮一峰老师的文章：http://www.ruanyifeng.com/blog/2011/05/how_to_choose_free_software_licenses.html，以图胜千言。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1249/201812/1249-20181207125332810-1823624407.png&quot; alt=&quot;&quot; width=&quot;1058&quot; height=&quot;661&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 07 Dec 2018 05:09:00 +0000</pubDate>
<dc:creator>张太国</dc:creator>
<og:description>本文讲开源项目的许可证（License）。 现在FOSS（Free Open Souce Software）的项目逐步增多，而且项目引进FOSS项目也越来越多，以提高我们开发的效率，避免重复造轮子。那</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/confach/p/10082311.html</dc:identifier>
</item>
</channel>
</rss>