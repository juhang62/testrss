<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>补习系列(18)-springboot H2 迷你数据库 - 美码师</title>
<link>http://www.cnblogs.com/littleatp/p/10534319.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/littleatp/p/10534319.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/242916/201903/242916-20190314231312640-813017380.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;关于-h2&quot;&gt;关于 H2&lt;/h2&gt;
&lt;p&gt;H2 数据库是一个纯 Java 实现的开源的嵌入式数据库，笔者第一次使用时还是在多年前的一个客户端项目中。&lt;br/&gt;当时就觉得这个数据库很方便，如果你希望你的应用程序能&quot;自带数据库，随处运行”，那么H2是个不错的选择。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/242916/201903/242916-20190314231243522-2040928650.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;H2 的由来&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;H2 的前身是 HyperSQL(HSQL)，后者也是一个类似的嵌入式数据库，H2的作者 Thomas Mueller 一开始就是 HSQL的贡献者。&lt;br/&gt;到后来因为一些未知的原因分成了两个项目分支，H2 大概就是第二代的意思..&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;有什么特性&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;由于是Java写的，自带跨平台能力&lt;/li&gt;
&lt;li&gt;小，非常的小，完整的 Jar 包只有1-2M&lt;/li&gt;
&lt;li&gt;支持多种模式，包括内存形态、文件形态(持久化)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;一般来说，使用H2 的场景大概会是：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;计算资源受限，如嵌入式计算环境中，由于CPU、内存、Disk等限制，要求采用小巧的数据库存储方案；&lt;/li&gt;
&lt;li&gt;项目预研，在项目立项之前可能无法立即采购昂贵的数据库软件，此时往往可以退而选择临时解决方案，利用JDBC协议的通用性在后期完成切换；&lt;/li&gt;
&lt;li&gt;自动化测试，在自动化环境中可能需要大量模拟接口，包括数据存储接口，此时内存数据库是不二之选。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;接下来，介绍两种使用方式&lt;/p&gt;
&lt;h2 id=&quot;一h2-用作本地数据库&quot;&gt;一、H2 用作本地数据库&lt;/h2&gt;
&lt;h3 id=&quot;引入依赖&quot;&gt;1. 引入依赖：&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-data-jpa&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;${spring-boot.version}&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;

&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;com.h2database&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;h2&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.4.196&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;配置文件&quot;&gt;2. 配置文件&lt;/h3&gt;
&lt;p&gt;编辑 &lt;strong&gt;application.properties&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;## Spring DATASOURCE (DataSourceAutoConfiguration &amp;amp; DataSourceProperties)
spring.datasource.url=jdbc:h2:file:D:/temp/h2
spring.datasource.username=
spring.datasource.password=

# The SQL dialect makes Hibernate generate better SQL for the chosen database
spring.jpa.properties.hibernate.dialect = org.hibernate.dialect.H2Dialect

# Hibernate ddl auto (create, create-drop, validate, update)
spring.jpa.hibernate.ddl-auto = update&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中 &lt;strong&gt;&lt;em&gt;jdbc:h2:file:D:/temp/h2&lt;/em&gt;&lt;/strong&gt; 将指示H2 启用本地文件模式，数据库文件将写入 &lt;strong&gt;&lt;em&gt;D:/temp/h2&lt;/em&gt;&lt;/strong&gt; 这个目录。&lt;/p&gt;
&lt;h3 id=&quot;样例数据&quot;&gt;3. 样例数据&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;LogRecord.java&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Entity
@Table(name=&quot;log_record&quot;)
    public class LogRecord {

    @Id
    @GeneratedValue(strategy = GenerationType.AUTO )
    private Long id;

    private String level;

    private String message;

    private Date createTime;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;LogRepository.java&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Repository
public interface LogRecordRepository extends JpaRepository&amp;lt;LogRecord, Long&amp;gt; {
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;LogRecordInitializer.java&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Service
public class LogRecordInitializer {

    @Autowired
    private LogRecordRepository logRecordRepository;
    private static final Logger logger = LoggerFactory.getLogger(LogRecordInitializer.class);

    @PostConstruct
    void initData(){

        if(logRecordRepository.count() &amp;gt; 0){

            List&amp;lt;LogRecord&amp;gt; logRecords = logRecordRepository.findAll();

            logger.info(&quot;read records: {}&quot;, JsonUtil.toPrettyJson(logRecords));
            return;
        }
        for(int i=0; i&amp;lt;100; i++){

            LogRecord record = new LogRecord();
            record.setLevel(&quot;info&quot;);

            record.setMessage(&quot;Heartbeat message &quot; + UUID.randomUUID().toString());
            record.setCreateTime(new Date());

            logRecordRepository.save(record);

            logger.info(&quot;save record - &quot; + record.getMessage());
        }

    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实现的逻辑大致是，第一次启动时写入100条数据，后面每次启动将数据读取出来并打印到日志。&lt;/p&gt;
&lt;p&gt;执行SpringBoot 启动程序，发现目录中生成了&lt;strong&gt;h2.mv.db&lt;/strong&gt;文件，说明写入成功！&lt;/p&gt;
&lt;h2 id=&quot;二h2-用于单元测试&quot;&gt;二、H2 用于单元测试&lt;/h2&gt;
&lt;p&gt;H2 数据库的典型应用是 在Web项目中做单元测试。&lt;/p&gt;
&lt;p&gt;一般，测试的流程为：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;数据初始化&lt;/li&gt;
&lt;li&gt;执行测试&lt;/li&gt;
&lt;li&gt;销毁数据&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;在真实的测试代码开发中，有几类问题会造成困扰：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;数据库环境的搭建比较费时费力；&lt;/li&gt;
&lt;li&gt;数据库的数据难以保持&quot;干净&quot;，一些垃圾数据容易影响测试的成功率&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;H2作为内存数据库使用则能解决这些问题&lt;/strong&gt;，本身作为内置数据库并不需要额外的看护成本，&lt;br/&gt;而且在程序退出时，所有数据都能保证完全清除。&lt;/p&gt;
&lt;h3 id=&quot;依赖包&quot;&gt;1. 依赖包&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!-- springboot test --&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;${spring-boot.version}&amp;lt;/version&amp;gt;
    &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
&amp;lt;/dependency&amp;gt;

&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;com.h2database&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;h2&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.4.196&amp;lt;/version&amp;gt;
    &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;测试配置&quot;&gt;2. 测试配置&lt;/h3&gt;
&lt;p&gt;编辑 &lt;strong&gt;&lt;em&gt;src/test/resources/application.properties&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 数据源连接
spring.datasource.url=jdbc:h2:mem:test
# DDL脚本
spring.datasource.schema=classpath:script/test-schema.sql
# DML脚本
spring.datasource.data=classpath:script/test-data.sql

spring.jpa.properties.hibernate.dialect = org.hibernate.dialect.H2Dialect
spring.jpa.hibernate.ddl-auto = update&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;测试代码&quot;&gt;3. 测试代码&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;@RunWith(SpringRunner.class)
@SpringBootTest(classes = BootJpa.class)
public class CityViewRepositoryTest {

    @Autowired
    private CityViewRepository cityViewRepository;

    @Test
    public void testGetAll(){

        List&amp;lt;CityView&amp;gt; views = cityViewRepository.findAll();
        System.out.println(JsonUtil.toPrettyJson(views));
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;本篇介绍了 H2 数据库常用的两种使用场景。尽管此前也写过关于H2 做单元测试的文章，&lt;br/&gt;但除此之外，其作为嵌入式数据库也是不错的选择，从行业趋势来看，终端计算对于嵌入式DB的需求会越来越多，后面也是比较看好的。&lt;br/&gt;与H2 类似的数据库还有HSQL、Derby，有兴趣的朋友可以研究对比下。&lt;/p&gt;
&lt;p&gt;欢迎继续关注&quot;美码师的补习系列-springboot篇&quot; ，期待更多精彩内容^-^&lt;/p&gt;
</description>
<pubDate>Thu, 14 Mar 2019 15:14:00 +0000</pubDate>
<dc:creator>美码师</dc:creator>
<og:description>[TOC] 关于 H2 H2 数据库是一个纯 Java 实现的开源的嵌入式数据库，笔者第一次使用时还是在多年前的一个客户端项目中。 当时就觉得这个数据库很方便，如果你希望你的应用程序能'自带数据库，随</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/littleatp/p/10534319.html</dc:identifier>
</item>
<item>
<title>Django实战(一)-----用户登录与注册系统4（图片验证码） - 秦广王</title>
<link>http://www.cnblogs.com/jinyuanliu/p/10534175.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jinyuanliu/p/10534175.html</guid>
<description>&lt;p&gt;为了防止机器人频繁登录网站或者破坏分子恶意登录，很多用户登录和注册系统都提供了图形验证码功能。&lt;/p&gt;
&lt;p&gt;验证码（CAPTCHA）是一种区分用户是计算机还是人的公共全自动程序。&lt;/p&gt;
&lt;p&gt;可以防止恶意破解密码、刷票、论坛灌水，有效防止某个黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试。&lt;/p&gt;
&lt;p&gt;图形验证码的历史比较悠久，到现在已经有点英雄末路的味道了。因为机器学习、图像识别的存在，机器人已经可以比较正确的识别图像内的字符了。&lt;/p&gt;
&lt;p&gt;但不管怎么说，作为一种防御手段，至少还是可以抵挡一些低级入门的攻击手段，抬高了攻击者的门槛。&lt;/p&gt;
&lt;p&gt;在Django中实现图片验证码功能非常简单，有现成的第三方库可以使用。这个库叫做&lt;code&gt;django-simple-captcha&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;captcha&quot;&gt;一、安装captcha&lt;/h2&gt;
&lt;p&gt;在Pycharm的terminal中，首先进入mysite_env虚拟环境，然后安装第三方库：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
pip install django-simple-captcha
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Django自动帮我们安装了相关的依赖库&lt;code&gt;six&lt;/code&gt;、&lt;code&gt;olefile&lt;/code&gt;和&lt;code&gt;Pillow&lt;/code&gt;，其中的Pillow是大名鼎鼎的绘图模块。&lt;/p&gt;
&lt;h2 id=&quot;captcha_1&quot;&gt;二、注册captcha&lt;/h2&gt;
&lt;p&gt;在settings中，将‘captcha’注册到app列表里：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;42&quot;&gt;
&lt;pre class=&quot;brush:csharp;collapse:true;;gutter:true;&quot;&gt;
INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'login',
    'captcha',
]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;captcha需要在数据库中建立自己的数据表，所以需要执行migrate命令生成数据表：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
python manage.py migrate
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592208/201903/1592208-20190314224034335-393656666.png&quot; alt=&quot;&quot; width=&quot;439&quot; height=&quot;113&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;url&quot;&gt;三、添加url路由&lt;/h2&gt;
&lt;p&gt;在根目录下的urls.py文件中增加captcha对应的网址：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;46&quot;&gt;
&lt;pre class=&quot;brush:csharp;collapse:true;;gutter:true;&quot;&gt;
from django.conf.urls import url
from django.conf.urls import include
from django.contrib import admin
from login import views

urlpatterns = [
    url(r'^admin/', admin.site.urls),
    url(r'^index/', views.index),
    url(r'^login/', views.login),
    url(r'^register/', views.register),
    url(r'^logout/', views.logout),
    url(r'^captcha', include('captcha.urls'))
]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于使用了二级路由机制，需要在顶部&lt;code&gt;from django.conf.urls import include&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;formspy&quot;&gt;四、修改forms.py&lt;/h2&gt;
&lt;p&gt;如果上面都OK了，就可以直接在我们的forms.py文件中添加CaptchaField了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:csharp;collapse:true;;gutter:true;&quot;&gt;
from django import forms
from captcha.fields import CaptchaField

class UserForm(forms.Form):
    username = forms.CharField(label=&quot;用户名&quot;, max_length=128, widget=forms.TextInput(attrs={'class': 'form-control'}))
    password = forms.CharField(label=&quot;密码&quot;, max_length=256, widget=forms.PasswordInput(attrs={'class': 'form-control'}))
    captcha = CaptchaField(label='验证码')
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意需要提前导入&lt;code&gt;from captcha.fields import CaptchaField&lt;/code&gt;，然后就像写普通的form字段一样添加一个captcha字段就可以了！&lt;/p&gt;
&lt;h2 id=&quot;loginhtml&quot;&gt;五、修改login.html&lt;/h2&gt;
&lt;p&gt;由于我们前面是手动生成的form表单，所以还要修改一下，添加captcha的相关内容，如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;collapse:true;;gutter:true;&quot;&gt;
{% extends 'login/../base.html' %}
{% load staticfiles %}
{% block title %}登录{% endblock %}
{% block css %}&amp;lt;link href=&quot;{% static 'css/login.css' %}&quot; rel=&quot;stylesheet&quot;/&amp;gt;{% endblock %}


{% block content %}
    &amp;lt;div class=&quot;container&quot;&amp;gt;
        &amp;lt;div class=&quot;col-md-4 col-md-offset-4&quot;&amp;gt;
          &amp;lt;form class='form-login' action=&quot;/login/&quot; method=&quot;post&quot;&amp;gt;

              {% if message %}
                  &amp;lt;div class=&quot;alert alert-warning&quot;&amp;gt;{{ message }}&amp;lt;/div&amp;gt;
              {% endif %}
              {% csrf_token %}
              &amp;lt;h2 class=&quot;text-center&quot;&amp;gt;欢迎登录&amp;lt;/h2&amp;gt;
              &amp;lt;div class=&quot;form-group&quot;&amp;gt;
                  {{ login_form.username.label_tag }}
                  {{ login_form.username}}
              &amp;lt;/div&amp;gt;
              &amp;lt;div class=&quot;form-group&quot;&amp;gt;
                  {{ login_form.password.label_tag }}
                  {{ login_form.password }}
              &amp;lt;/div&amp;gt;

              &amp;lt;div class=&quot;form-group&quot;&amp;gt;
                  {{ login_form.captcha.errors }}
                  {{ login_form.captcha.label_tag }}
                  {{ login_form.captcha }}
              &amp;lt;/div&amp;gt;

              &amp;lt;button type=&quot;reset&quot; class=&quot;btn btn-default pull-left&quot;&amp;gt;重置&amp;lt;/button&amp;gt;
              &amp;lt;button type=&quot;submit&quot; class=&quot;btn btn-primary pull-right&quot;&amp;gt;提交&amp;lt;/button&amp;gt;

          &amp;lt;/form&amp;gt;
        &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt; &amp;lt;!-- /container --&amp;gt;
{% endblock %}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里额外增加了一条&lt;code&gt;{{ login_form.captcha.errors }}&lt;/code&gt;用于明确指示用户，你的验证码不正确。&lt;/p&gt;
&lt;h2 id=&quot;_1&quot;&gt;六、查看效果&lt;/h2&gt;
&lt;p&gt;重启服务器，进入登录页面，尝试用用户名错误、密码不对、验证码不对、全对的不同情况，看看我们新增的四位验证码的效果如何。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592208/201903/1592208-20190314224552853-2019820690.png&quot; alt=&quot;&quot; width=&quot;315&quot; height=&quot;294&quot;/&gt;&lt;/p&gt;
&lt;p&gt;就是这么简单！&lt;/p&gt;
&lt;p&gt;我们加入了一个防止机器人或者恶意登录的图形验证码功能，虽然界面难看了点，但底子是好的，你可以根据需要进行美化。&lt;/p&gt;
&lt;p&gt;其中验证图形码是否正确的工作都是在后台自动完成的，只需要使用&lt;code&gt;is_valid()&lt;/code&gt;这个forms内置的验证方法就一起进行了，完全不需要在视图函数中添加任何的验证代码，非常方便快捷！&lt;/p&gt;
&lt;p&gt;关于captcha的功能，当然绝不仅限于此，你可以设置六位、八位验证码，可以对图形噪点的生成模式进行定制，这些就留待你自己学习和研究了。&lt;/p&gt;

</description>
<pubDate>Thu, 14 Mar 2019 14:47:00 +0000</pubDate>
<dc:creator>秦广王</dc:creator>
<og:description>为了防止机器人频繁登录网站或者破坏分子恶意登录，很多用户登录和注册系统都提供了图形验证码功能。 验证码（CAPTCHA）是一种区分用户是计算机还是人的公共全自动程序。 可以防止恶意破解密码、刷票、论坛</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jinyuanliu/p/10534175.html</dc:identifier>
</item>
<item>
<title>面向过程和面向对象的区别 - 吴永吉</title>
<link>http://www.cnblogs.com/wuyongji/p/10534105.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wuyongji/p/10534105.html</guid>
<description>&lt;p&gt;　　先来看生活中的一个例子。&lt;/p&gt;
&lt;p&gt;　　想必每个人都下过五子棋吧？在下棋的整个过程中可以有两种不同的思路来实现：&lt;/p&gt;
&lt;p&gt;　　1、按步骤来看：&lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;　　（1）、开始游戏，（2）、黑子先走，（3）、绘制画面，（4）、判断输赢，（5）、轮到白子，（6）、绘&lt;em id=&quot;__mceDel&quot;&gt;制画面，（7）、判断输赢，（8）、返回步骤（2），（9）输出最后结果&lt;/em&gt;&lt;br/&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　2、按组成模块来看：&lt;br/&gt;　　&lt;em id=&quot;__mceDel&quot;&gt;（1）&lt;/em&gt;、黑白双方模块，&lt;em id=&quot;__mceDel&quot;&gt;（2）&lt;/em&gt;、棋盘模块，&lt;em id=&quot;__mceDel&quot;&gt;（3）&lt;/em&gt;、规则模块&lt;/p&gt;
&lt;p&gt;　　以上两种完全不同的设计思路，正好对应于编程中完全不同的两种思想：前者侧重于游戏步骤的设计，对应于编程中的面向过程思想；后者着重于分层，有模块化设计理念，对应于编程中的面向对象思想。可以很明显地看出：面向对象是以功能来划分问题，而不是步骤。同样是绘制棋局，这样的行为在面向过程的设计中分散在了多个步骤中，很可能出现不同的绘制版本，因为通常设计人员会考虑到实际情况进行各种各样的简化。而面向对象的设计中，绘图只可能在棋盘对象中出现，从而保证了绘图的统一。&lt;/p&gt;
&lt;p&gt;　　C语言是典型的“面向过程”设计语言。面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了。“面向过程”是一种以过程为中心的编程思想。“面向过程”也可称之为“面向记录”编程思想，它们不支持丰富的“面向对象”特性（比如继承、多态）。如下图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1533339/201903/1533339-20190314222216655-1664246684.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　Java是典型的“面向对象”设计语言。“面向对象”是一种以事物为中心的编程思想。是把构成问题的事物分解成各个对象，建立对象的目的不是为了完成某一个步骤，而是为了描述某个事物在整个解决问题的步骤中的行为。如下图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1533339/201903/1533339-20190314222327434-1488483357.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　面向过程适合于一个人的小量工作，而面向对象更侧重于团队合作，需要很多人完成的大量工作。面向过程思想是我们每一个人天生具备的。在编程时，我们总会不自觉的去考虑怎么来完成某一需求，分析出具体的步骤，然后按照步骤来一步步实现。但是在现实生活当中，并不是每一件事都可以自己独立来完成，我们需要团队，需要合作才可以完成某一项复杂的工作。这样来看的话，面向对象思想似乎更符合人们的做事方式，也更生活化。是的呢，不管是生活中，亦或是编程中，面向对象才是我们更应该具备的一种思想，先来看几组概念。&lt;/p&gt;
&lt;p&gt;　　对象：对象是人们要进行研究的任何事物，从最简单的整数到复杂的飞机等均可看做对象，它不仅能表示具体的事物，还能表示抽象的规则、计划或事件等。&lt;br/&gt;　　类：具有相同特性(数据元素)和行为(功能)的对象的抽象就是类。因此，对象的抽象是类，类的具体化就是对象，也可以说类的实例化是对象，类实际上就是一种数据类型。&lt;br/&gt;　　面向对象三大特征：封装、继承、多态。&lt;/p&gt;
&lt;p&gt;　　封装：封装是一种把代码和代码所操作的数据捆绑在一起，使这两者不受外界干扰和误用的机制。封装可被理解为一种用作保护的包装器，以防止代码和数据被包装器外部所定义的其它代码任意访问。&lt;br/&gt;　　继承：继承是指一个对象从另一个对象中获得属性和方法的过程。它支持按层次分类的概念，如果不使用层次的概念，每个对象需要明确定义各自的全部特征，通过层次分类方式，一个对象只需要在它的类中定义使它成为唯一的各个属性和方法。&lt;br/&gt;　　多态：多态是指同一个实体同时具有多种形式。同一操作作用于不用的对象，可以有不同的解释，产生不同的执行结果。在运行时，可以通过指向基类的引用，来调用实现派生类中的方法。&lt;/p&gt;
&lt;p&gt;　　面向过程&lt;br/&gt;　　优点：性能比面向对象高。&lt;br/&gt;　　缺点：没有面向对象易维护、易复用、易扩展。&lt;br/&gt;　　面向对象&lt;br/&gt;　　优点：易维护、易复用、易扩展。由于面向对象有封装、继承、多态性的特征，可以设计出低耦合的系统，使系统更加灵活，更加易于维护和扩展。&lt;br/&gt;　　缺点：性能比面向过程低。&lt;/p&gt;
</description>
<pubDate>Thu, 14 Mar 2019 14:32:00 +0000</pubDate>
<dc:creator>吴永吉</dc:creator>
<og:description>封装、继承、多态</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wuyongji/p/10534105.html</dc:identifier>
</item>
<item>
<title>java8 Stream的实现原理 (从零开始实现一个stream流) - 小熊餐馆</title>
<link>http://www.cnblogs.com/xiaoxiongcanguan/p/10511233.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaoxiongcanguan/p/10511233.html</guid>
<description>&lt;h3&gt;1.1 java8 stream介绍&lt;/h3&gt;
&lt;p&gt;　　java8新增了stream流的特性，能够让用户以函数式的方式、更为简单的操纵集合等数据结构，并实现了用户无感知的并行计算。&lt;/p&gt;
&lt;h3&gt;1.2 &lt;strong&gt;从零开始实现一个stream流&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　相信很多人在使用过java8的streamAPI接口之后，都会对其实现原理感到好奇，但往往在看到jdk的stream源码后却被其复杂的抽象、封装给弄糊涂了，而无法很好的理解其背后的原理。究其原因，是因为jdk的stream源码是高度工程化的代码，工程化的代码为了效率和满足多种多想的需求，会将代码实现的极其复杂，不易理解。&lt;/p&gt;
&lt;p&gt;　　在这里，我们将抛开jdk的实现思路，&lt;strong&gt;从零开始实现一个stream流&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　我们的&lt;strong&gt;stream流&lt;/strong&gt;同样拥有&lt;strong&gt;惰性求值&lt;/strong&gt;，&lt;strong&gt;函数式编程接口&lt;/strong&gt;等特性，并&lt;strong&gt;兼容jdk的Collection等数据结构&lt;/strong&gt;(但不支持并行计算 orz)。&lt;/p&gt;
&lt;p&gt;　　相信在亲手实现一个stream流的框架之后，大家能更好的理解流计算的原理。&lt;/p&gt;

&lt;p&gt;　　在探讨探究stream的实现原理和动手实现之前，我们先要体会stream流计算的独特之处。&lt;/p&gt;
&lt;p&gt;　　举个例子： 有一个List&amp;lt;Person&amp;gt;列表,我们需要获得年龄为70岁的前10个Person的姓名。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;过程式的解决方案：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;稍加思考，我们很快就写出了一个过程式的解决方案(&lt;strong&gt;伪代码&lt;/strong&gt;)：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
List&amp;lt;Person&amp;gt; personList = fromDB(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获得List&amp;lt;Person&amp;gt;&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; limit = 10; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 限制条件&lt;/span&gt;
List&amp;lt;String&amp;gt; nameList = &lt;span&gt;new&lt;/span&gt; ArrayList(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 收集的姓名集合&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(Person personItem : personList){
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(personItem.age == 70){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 满足条件&lt;/span&gt;
        nameList.add(personItem.name); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 加入姓名集合&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(nameList.size() &amp;gt;= 10){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断是否超过限制&lt;/span&gt;
            &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        }
    }
}
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; nameList;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;函数式stream解决方案：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;下面我们给出一种基于stream流的解决方案(&lt;strong&gt;伪代码&lt;/strong&gt;)：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
List&amp;lt;Person&amp;gt; personList = fromDB(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获得List&amp;lt;Person&amp;gt;&lt;/span&gt;
List&amp;lt;String&amp;gt; nameList =&lt;span&gt; personList.stream()
　　　　　　.filter(item&lt;/span&gt;-&amp;gt;item.age == 70) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 过滤条件&lt;/span&gt;
　　　　　　.limit(10)    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; limit限制条件&lt;/span&gt;
　　　　　　.map(item-&amp;gt;item.name) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获得姓名&lt;/span&gt;
　　　　　　.collect(Collector.toList()); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 转化为list&lt;/span&gt;

&lt;span&gt;return&lt;/span&gt; nameList;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;两种方案的不同之处：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;从函数式的角度上看，&lt;strong&gt;过程式的代码实现将收集元素、循环迭代、各种逻辑判断耦合在一起，暴露了太多细节&lt;/strong&gt;。当未来需求变动和变得更加复杂的情况下，过程式的代码将变得难以理解和维护(需要控制台打印出 年龄为70岁的前10个Person中，姓王的Person的名称）。&lt;/p&gt;
&lt;p&gt;　　函数式的解决方案&lt;strong&gt;解开了代码细节和业务逻辑的耦合&lt;/strong&gt;，类似于sql语句，表达的是&lt;strong&gt;&quot;要做什么&quot;&lt;/strong&gt;而不是&lt;strong&gt;&quot;如何去做&quot;&lt;/strong&gt;，使程序员可以更加专注于业务逻辑，写出易于理解和维护的代码。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
List&amp;lt;Person&amp;gt; personList = fromDB(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获得List&amp;lt;Person&amp;gt;&lt;/span&gt;
&lt;span&gt;personList.stream()
    .filter(item&lt;/span&gt;-&amp;gt;item.age == 70) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 过滤条件&lt;/span&gt;
    .limit(10)    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; limit限制条件&lt;/span&gt;
    .filter(item-&amp;gt;item.name.startWith(&quot;王&quot;))  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 过滤条件&lt;/span&gt;
    .map(item-&amp;gt;item.name) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获得姓名&lt;/span&gt;
    .forEach(System.out::println);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　stream API的接口是函数式的，尽管java 8也引入了lambda表达式，但java实质上依然是由&lt;strong&gt;接口-匿名内部类&lt;/strong&gt;来实现函数传参的，所以需要事先定义一系列的函数式接口。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Function: 类似于 y = F(x)&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@FunctionalInterface
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; Function&amp;lt;R,T&amp;gt;&lt;span&gt; {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 函数式接口
     * 类似于 y = F(x)
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    R apply(T t);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;BiFunction: 类似于 z = F(x,y)&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@FunctionalInterface
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; BiFunction&amp;lt;R, T, U&amp;gt;&lt;span&gt; {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 函数式接口
     * 类似于 z = F(x,y)
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    R apply(T t, U u);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;ForEach: 遍历处理&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@FunctionalInterface
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; ForEach &amp;lt;T&amp;gt;&lt;span&gt;{

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 迭代器遍历
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; item 被迭代的每一项
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; apply(T item);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Comparator: 比较器&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@FunctionalInterface
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; Comparator&amp;lt;T&amp;gt;&lt;span&gt;  {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 比较方法逻辑
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; o1    参数1
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; o2    参数2
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt;      返回值大于0 ---&amp;gt; (o1 &amp;gt; o2)
     *              返回值等于0 ---&amp;gt; (o1 = o2)
     *              返回值小于0 ---&amp;gt; (o1 &amp;lt; o2)
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt;&lt;span&gt; compare(T o1, T o2);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Predicate: 条件判断&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@FunctionalInterface
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; Predicate &amp;lt;T&amp;gt;&lt;span&gt;{

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 函数式接口
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; item 迭代的每一项
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; true 满足条件
     *          false 不满足条件
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; satisfy(T item);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Supplier：提供初始值&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@FunctionalInterface
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; Supplier&amp;lt;T&amp;gt;&lt;span&gt; {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 提供初始值
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; 初始化的值
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    T get();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;EvalFunction：stream求值函数&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@FunctionalInterface
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; EvalFunction&amp;lt;T&amp;gt;&lt;span&gt; {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * stream流的强制求值方法
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; 求值返回一个新的stream
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    MyStream&lt;/span&gt;&amp;lt;T&amp;gt;&lt;span&gt; apply();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;stream API接口：&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * stream流的API接口
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; Stream&amp;lt;T&amp;gt;&lt;span&gt; {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 映射 lazy 惰性求值
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; mapper 转换逻辑 T-&amp;gt;R
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; 一个新的流
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &amp;lt;R&amp;gt; MyStream&amp;lt;R&amp;gt; map(Function&amp;lt;R,T&amp;gt;&lt;span&gt; mapper);

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 扁平化 映射 lazy 惰性求值
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; mapper 转换逻辑 T-&amp;gt;MyStream&amp;lt;R&amp;gt;
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt;  一个新的流(扁平化之后)
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &amp;lt;R&amp;gt; MyStream&amp;lt;R&amp;gt; flatMap(Function&amp;lt;? &lt;span&gt;extends&lt;/span&gt; MyStream&amp;lt;R&amp;gt;, T&amp;gt;&lt;span&gt; mapper);

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 过滤 lazy 惰性求值
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; predicate 谓词判断
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; 一个新的流，其中元素是满足predicate条件的
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    MyStream&lt;/span&gt;&amp;lt;T&amp;gt; filter(Predicate&amp;lt;T&amp;gt;&lt;span&gt; predicate);

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 截断 lazy 惰性求值
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; n 截断流，只获取部分
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; 一个新的流，其中的元素不超过 n
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    MyStream&lt;/span&gt;&amp;lt;T&amp;gt; limit(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; n);

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 去重操作 lazy 惰性求值
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; 一个新的流，其中的元素不重复(!equals）
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    MyStream&lt;/span&gt;&amp;lt;T&amp;gt;&lt;span&gt; distinct();

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 窥视 lazy 惰性求值
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; 一个新的流，其中的元素不重复(!equals）
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    MyStream&lt;/span&gt;&amp;lt;T&amp;gt; peek(ForEach&amp;lt;T&amp;gt;&lt;span&gt; consumer);

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 遍历 eval 强制求值
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; consumer 遍历逻辑
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt; forEach(ForEach&amp;lt;T&amp;gt;&lt;span&gt; consumer);

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 浓缩 eval 强制求值
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; initVal 浓缩时的初始值
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; accumulator 浓缩时的 累加逻辑
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; 浓缩之后的结果
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &amp;lt;R&amp;gt; R reduce(R initVal, BiFunction&amp;lt;R, R, T&amp;gt;&lt;span&gt; accumulator);

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 收集 eval 强制求值
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; collector 传入所需的函数组合子，生成高阶函数
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; 收集之后的结果
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &amp;lt;R, A&amp;gt; R collect(Collector&amp;lt;T,A,R&amp;gt;&lt;span&gt; collector);

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 最大值 eval 强制求值
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; comparator 大小比较逻辑
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; 流中的最大值
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    T max(Comparator&lt;/span&gt;&amp;lt;T&amp;gt;&lt;span&gt; comparator);

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 最小值 eval 强制求值
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; comparator 大小比较逻辑
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; 流中的最小值
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    T min(Comparator&lt;/span&gt;&amp;lt;T&amp;gt;&lt;span&gt; comparator);

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 计数 eval 强制求值
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt;  当前流的个数
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt;&lt;span&gt; count();

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 流中是否存在满足predicate的项
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; true 存在 匹配项
     *          false 不存在 匹配项
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;boolean&lt;/span&gt; anyMatch(Predicate&amp;lt;? &lt;span&gt;super&lt;/span&gt; T&amp;gt;&lt;span&gt; predicate);

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 流中的元素是否全部满足predicate
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; true 全部满足
     *          false 不全部满足
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;boolean&lt;/span&gt; allMatch(Predicate&amp;lt;? &lt;span&gt;super&lt;/span&gt; T&amp;gt;&lt;span&gt; predicate);

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 返回空的 stream
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; 空stream
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; MyStream&amp;lt;T&amp;gt;&lt;span&gt; makeEmptyStream(){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; isEnd = true&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; MyStream.Builder&amp;lt;T&amp;gt;().isEnd(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;).build();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　简单介绍了API接口定义之后，我们开始深入探讨流的内部实现。&lt;/p&gt;
&lt;p&gt;　　流由两个重要的部分所组成，&lt;strong&gt;&quot;当前数据项(head)&quot;&lt;/strong&gt;和&lt;strong&gt;&quot;下一数据项的求值函数(nextItemEvalProcess)&quot;&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　其中，&lt;strong&gt;nextItemEvalProcess是流能够实现&quot;惰性求值&quot;的关键&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1506329/201903/1506329-20190312160335800-2131049743.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;流的基本属性：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MyStream&amp;lt;T&amp;gt; &lt;span&gt;implements&lt;/span&gt; Stream&amp;lt;T&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 流的头部
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; T head;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 流的下一项求值函数
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; NextItemEvalProcess nextItemEvalProcess;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 是否是流的结尾
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isEnd;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Builder&amp;lt;T&amp;gt;&lt;span&gt;{
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; MyStream&amp;lt;T&amp;gt;&lt;span&gt; target;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Builder() {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.target = &lt;span&gt;new&lt;/span&gt; MyStream&amp;lt;&amp;gt;&lt;span&gt;();
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Builder&amp;lt;T&amp;gt;&lt;span&gt; head(T head){
            target.head &lt;/span&gt;=&lt;span&gt; head;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
        }

        Builder&lt;/span&gt;&amp;lt;T&amp;gt; isEnd(&lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isEnd){
            target.isEnd &lt;/span&gt;=&lt;span&gt; isEnd;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Builder&amp;lt;T&amp;gt;&lt;span&gt; nextItemEvalProcess(NextItemEvalProcess nextItemEvalProcess){
            target.nextItemEvalProcess &lt;/span&gt;=&lt;span&gt; nextItemEvalProcess;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; MyStream&amp;lt;T&amp;gt;&lt;span&gt; build(){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; target;
        }
    }

   &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 当前流强制求值
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; 求值之后返回一个新的流
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; MyStream&amp;lt;T&amp;gt;&lt;span&gt; eval(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.nextItemEvalProcess.eval();
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 当前流 为空
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isEmptyStream(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.isEnd;
    }&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 下一个元素求值过程
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; NextItemEvalProcess {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 求值方法
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; EvalFunction evalFunction;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; NextItemEvalProcess(EvalFunction evalFunction) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.evalFunction =&lt;span&gt; evalFunction;
    }

    MyStream eval(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; evalFunction.apply();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;strong&gt;4.1 stream&lt;/strong&gt;流在使用过程中的三个阶段&lt;/h3&gt;
&lt;p&gt;　　&lt;strong&gt;1.  生成并构造一个流&lt;/strong&gt; (List.stream() 等方法)&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;2.  在流的处理过程中添加、绑定惰性求值流程  &lt;/strong&gt;(map、filter、limit 等方法)&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;3.  对流使用强制求值函数，生成最终结果 &lt;/strong&gt;(max、reduce、collect等方法)&lt;/p&gt;
&lt;h3&gt;4.2 &lt;strong&gt;生成并构造一个流&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;流在生成时是&quot;纯净&quot;的，其最初的&lt;strong&gt;NextItemEvalProcess&lt;/strong&gt;求值之后就是指向自己的下一个元素&lt;strong&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　我们以一个Integer整数流的生成为例。&lt;strong&gt;IntegerStreamGenerator.getIntegerStream(1,10) &lt;/strong&gt;会返回一个流结构，其逻辑上等价于一个从1到10的整数流。但实质是一个惰性求值的stream对象，这里称其为&lt;strong&gt;IntStream&lt;/strong&gt;，其NextItemEvalProcess是一个闭包，方法体是一个递归结构的求值函数，其中下界参数low = low + 1。&lt;/p&gt;
&lt;p&gt;　　当IntStream第一次被求值时，流开始初始化，isStart = false。当初始化完成之后，每一次求值，都会生成一个新的流对象，其中head(low) = low + 1。当low &amp;gt; high时，流被终止，返回空的流对象。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1506329/201903/1506329-20190314215343735-1476943174.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 整数流生成器
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; IntegerStreamGenerator {
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 获得一个有限的整数流 介于[low-high]之间
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; low 下界
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; high 上界
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; MyStream&amp;lt;Integer&amp;gt; getIntegerStream(&lt;span&gt;int&lt;/span&gt; low, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; high){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; getIntegerStreamInner(low,high,&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 递归函数。配合getIntegerStream(int low,int high)
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; MyStream&amp;lt;Integer&amp;gt; getIntegerStreamInner(&lt;span&gt;int&lt;/span&gt; low, &lt;span&gt;int&lt;/span&gt; high, &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isStart){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(low &amp;gt;&lt;span&gt; high){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 到达边界条件，返回空的流&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Stream.makeEmptyStream();
        }&lt;br/&gt;&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(isStart){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; MyStream.Builder&amp;lt;Integer&amp;gt;&lt;span&gt;()
                    .process(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; NextItemEvalProcess(()-&amp;gt;getIntegerStreamInner(low,high,&lt;span&gt;false&lt;/span&gt;&lt;span&gt;)))
                    .build();
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; MyStream.Builder&amp;lt;Integer&amp;gt;&lt;span&gt;()
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当前元素 low&lt;/span&gt;
&lt;span&gt;                    .head(low)
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 下一个元素 low+1&lt;/span&gt;
                    .process(&lt;span&gt;new&lt;/span&gt; NextItemEvalProcess(()-&amp;gt;getIntegerStreamInner(low+1,high,&lt;span&gt;false&lt;/span&gt;&lt;span&gt;)))
                    .build();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　可以看到，&lt;strong&gt;生成一个流的关键在于确定如何求值下一项元素。&lt;/strong&gt;对于整数流来说，low = low + 1就是其下一项的求值过程。&lt;/p&gt;
&lt;p&gt;　　那么对于我们非常关心的jdk集合容器，又该如何生成对应的流呢?&lt;/p&gt;
&lt;p&gt;　　答案是&lt;strong&gt;Iterator迭代器&lt;/strong&gt;，jdk的集合容器都实现了Iterator迭代器接口，通过迭代器我们可以轻易的取得容器的下一项元素，而不用关心容器内部实现细节。换句话说，&lt;strong&gt;只要实现过迭代器接口，就可以自然的转化为stream流，从而获得流计算的所有能力&lt;/strong&gt;。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 集合流生成器
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CollectionStreamGenerator {
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 将一个List转化为stream流
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; MyStream&amp;lt;T&amp;gt; getListStream(List&amp;lt;T&amp;gt;&lt;span&gt; list){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; getListStream(list.iterator(),&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 递归函数
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; iterator list 集合的迭代器
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; isStart 是否是第一次迭代
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; MyStream&amp;lt;T&amp;gt; getListStream(Iterator&amp;lt;T&amp;gt; iterator, &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isStart){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;iterator.hasNext()){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 不存在迭代的下一个元素，返回空的流&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Stream.makeEmptyStream();
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(isStart){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始化，只需要设置 求值过程&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; MyStream.Builder&amp;lt;T&amp;gt;&lt;span&gt;()
                    .nextItemEvalProcess(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; NextItemEvalProcess(()-&amp;gt; getListStream(iterator,&lt;span&gt;false&lt;/span&gt;&lt;span&gt;)))
                    .build();
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 非初始化，设置head和接下来的求值过程&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; MyStream.Builder&amp;lt;T&amp;gt;&lt;span&gt;()
                    .head(iterator.next())
                    .nextItemEvalProcess(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; NextItemEvalProcess(()-&amp;gt; getListStream(iterator,&lt;span&gt;false&lt;/span&gt;&lt;span&gt;)))
                    .build();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;strong&gt;思考一个小问题，如何生成一个无穷的整数流？&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;4.3 &lt;/strong&gt;在流的处理过程中添加、绑定惰性求值流程&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;/strong&gt;我们以map接口举例说明。API的map接口是一个&lt;strong&gt;惰性求值&lt;/strong&gt;接口，在流执行了map方法后(stream.map())，不会进行任何的求值运算。map在执行时，会生成一个新的求值过程&lt;strong&gt;NextItemEvalProcess&lt;/strong&gt;，新的过程将之前流的求值过程给&lt;strong&gt;&quot;包裹&quot;&lt;/strong&gt;起来了，仅仅是在&lt;strong&gt;&quot;流的生成&quot;&lt;/strong&gt;到&lt;strong&gt;&quot;流的最终求值&quot;&lt;/strong&gt;之间增加了一道处理工序，最终返回了一个新的stream流对象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;/strong&gt;API.map所依赖的内部静态map方法是一个惰性求值方法，其每次调用&lt;strong&gt;&quot;&lt;/strong&gt;只会&lt;strong&gt;&quot;&lt;/strong&gt;将当前流的head部分进行map映射操作，并且生成一个新的流。新生成流的&lt;strong&gt;NextItemEvalProcess&lt;/strong&gt;和之前逻辑基本保持一致(递归)，唯一的区别是，第二个参数传入的&lt;strong&gt;stream&lt;/strong&gt;在调用方法之前会被强制求值&lt;strong&gt;(eval)&lt;/strong&gt;后再传入。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &amp;lt;R&amp;gt; MyStream&amp;lt;R&amp;gt; map(Function&amp;lt;R, T&amp;gt;&lt;span&gt; mapper) {
        NextItemEvalProcess lastNextItemEvalProcess &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.nextItemEvalProcess;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.nextItemEvalProcess = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NextItemEvalProcess(
                ()&lt;/span&gt;-&amp;gt;&lt;span&gt;{
                    MyStream myStream &lt;/span&gt;=&lt;span&gt; lastNextItemEvalProcess.eval();
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; map(mapper, myStream);
                }
        );

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 求值链条 加入一个新的process map&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; MyStream.Builder&amp;lt;R&amp;gt;&lt;span&gt;()
                .nextItemEvalProcess(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.nextItemEvalProcess)
                .build();
    }

   &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 递归函数 配合API.map
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;R,T&amp;gt; MyStream&amp;lt;R&amp;gt; map(Function&amp;lt;R, T&amp;gt; mapper, MyStream&amp;lt;T&amp;gt;&lt;span&gt; myStream){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(myStream.isEmptyStream()){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Stream.makeEmptyStream();
        }

        R head &lt;/span&gt;=&lt;span&gt; mapper.apply(myStream.head);

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; MyStream.Builder&amp;lt;R&amp;gt;&lt;span&gt;()
                .head(head)
                .nextItemEvalProcess(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; NextItemEvalProcess(()-&amp;gt;&lt;span&gt;map(mapper, myStream.eval())))
                .build();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　惰性求值接口的实现大同小异，大家需要体会一下&lt;strong&gt;闭包&lt;/strong&gt;、&lt;strong&gt;递归、&lt;/strong&gt;&lt;strong&gt;惰性求值&lt;/strong&gt;等概念，限于篇幅就不一一展开啦。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;flatMap：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('a812fa6e-832e-4211-8aae-1a173d9ad889')&quot; readability=&quot;38&quot;&gt;&lt;img id=&quot;code_img_closed_a812fa6e-832e-4211-8aae-1a173d9ad889&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_a812fa6e-832e-4211-8aae-1a173d9ad889&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('a812fa6e-832e-4211-8aae-1a173d9ad889',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_a812fa6e-832e-4211-8aae-1a173d9ad889&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;71&quot;&gt;
&lt;pre&gt;
&lt;span&gt;   @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &amp;lt;R&amp;gt; MyStream&amp;lt;R&amp;gt; flatMap(Function&amp;lt;? &lt;span&gt;extends&lt;/span&gt; MyStream&amp;lt;R&amp;gt;,T&amp;gt;&lt;span&gt; mapper) {
        NextItemEvalProcess lastNextItemEvalProcess &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.nextItemEvalProcess;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.nextItemEvalProcess = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NextItemEvalProcess(
            ()&lt;/span&gt;-&amp;gt;&lt;span&gt;{
                MyStream myStream &lt;/span&gt;=&lt;span&gt; lastNextItemEvalProcess.eval();
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; flatMap(mapper, Stream.makeEmptyStream(), myStream);
            }
        );

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 求值链条 加入一个新的process map&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; MyStream.Builder&amp;lt;R&amp;gt;&lt;span&gt;()
            .nextItemEvalProcess(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.nextItemEvalProcess)
            .build();
    }

  &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 递归函数 配合API.flatMap
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;R,T&amp;gt; MyStream&amp;lt;R&amp;gt; flatMap(Function&amp;lt;? &lt;span&gt;extends&lt;/span&gt; MyStream&amp;lt;R&amp;gt;,T&amp;gt; mapper, MyStream&amp;lt;R&amp;gt; headMyStream, MyStream&amp;lt;T&amp;gt;&lt;span&gt; myStream){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(headMyStream.isEmptyStream()){
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(myStream.isEmptyStream()){
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Stream.makeEmptyStream();
            }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                T outerHead &lt;/span&gt;=&lt;span&gt; myStream.head;
                MyStream&lt;/span&gt;&amp;lt;R&amp;gt; newHeadMyStream =&lt;span&gt; mapper.apply(outerHead);

                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; flatMap(mapper, newHeadMyStream.eval(), myStream.eval());
            }
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; MyStream.Builder&amp;lt;R&amp;gt;&lt;span&gt;()
                        .head(headMyStream.head)
                        .nextItemEvalProcess(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; NextItemEvalProcess(()-&amp;gt;&lt;span&gt; flatMap(mapper, headMyStream.eval(), myStream)))
                        .build();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;filter：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('04ae6647-9a85-4ed4-8511-3242cecc711e')&quot; readability=&quot;34.5&quot;&gt;&lt;img id=&quot;code_img_closed_04ae6647-9a85-4ed4-8511-3242cecc711e&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_04ae6647-9a85-4ed4-8511-3242cecc711e&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('04ae6647-9a85-4ed4-8511-3242cecc711e',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_04ae6647-9a85-4ed4-8511-3242cecc711e&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; MyStream&amp;lt;T&amp;gt; filter(Predicate&amp;lt;T&amp;gt;&lt;span&gt; predicate) {
        NextItemEvalProcess lastNextItemEvalProcess &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.nextItemEvalProcess;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.nextItemEvalProcess = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NextItemEvalProcess(
                ()&lt;/span&gt;-&amp;gt;&lt;span&gt; {
                    MyStream myStream &lt;/span&gt;=&lt;span&gt; lastNextItemEvalProcess.eval();
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; filter(predicate, myStream);
                }
        );

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 求值链条 加入一个新的process filter&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
    }

  &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 递归函数 配合API.filter
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; MyStream&amp;lt;T&amp;gt; filter(Predicate&amp;lt;T&amp;gt; predicate, MyStream&amp;lt;T&amp;gt;&lt;span&gt; myStream){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(myStream.isEmptyStream()){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Stream.makeEmptyStream();
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(predicate.satisfy(myStream.head)){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Builder&amp;lt;T&amp;gt;&lt;span&gt;()
                    .head(myStream.head)
                    .nextItemEvalProcess(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; NextItemEvalProcess(()-&amp;gt;&lt;span&gt;filter(predicate, myStream.eval())))
                    .build();
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; filter(predicate, myStream.eval());
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;limit：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('7902b0da-e55d-4de9-8c71-b3a9d0526a2a')&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_7902b0da-e55d-4de9-8c71-b3a9d0526a2a&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_7902b0da-e55d-4de9-8c71-b3a9d0526a2a&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('7902b0da-e55d-4de9-8c71-b3a9d0526a2a',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_7902b0da-e55d-4de9-8c71-b3a9d0526a2a&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt;   @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; MyStream&amp;lt;T&amp;gt; limit(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; n) {
        NextItemEvalProcess lastNextItemEvalProcess &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.nextItemEvalProcess;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.nextItemEvalProcess = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NextItemEvalProcess(
                ()&lt;/span&gt;-&amp;gt;&lt;span&gt; {
                    MyStream myStream &lt;/span&gt;=&lt;span&gt; lastNextItemEvalProcess.eval();
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; limit(n, myStream);
                }
        );

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 求值链条 加入一个新的process limit&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
    }

  &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 递归函数 配合API.limit
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; MyStream&amp;lt;T&amp;gt; limit(&lt;span&gt;int&lt;/span&gt; num, MyStream&amp;lt;T&amp;gt;&lt;span&gt; myStream){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(num == 0 ||&lt;span&gt; myStream.isEmptyStream()){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Stream.makeEmptyStream();
        }

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; MyStream.Builder&amp;lt;T&amp;gt;&lt;span&gt;()
                .head(myStream.head)
                .nextItemEvalProcess(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; NextItemEvalProcess(()-&amp;gt;limit(num-1&lt;span&gt;, myStream.eval())))
                .build();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;distinct：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('53eedd00-28c2-4bf9-a99e-21e59c5eca69')&quot; readability=&quot;34.5&quot;&gt;&lt;img id=&quot;code_img_closed_53eedd00-28c2-4bf9-a99e-21e59c5eca69&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_53eedd00-28c2-4bf9-a99e-21e59c5eca69&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('53eedd00-28c2-4bf9-a99e-21e59c5eca69',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_53eedd00-28c2-4bf9-a99e-21e59c5eca69&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt;   @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; MyStream&amp;lt;T&amp;gt;&lt;span&gt; distinct() {
        NextItemEvalProcess lastNextItemEvalProcess &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.nextItemEvalProcess;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.nextItemEvalProcess = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NextItemEvalProcess(
            ()&lt;/span&gt;-&amp;gt;&lt;span&gt; {
                MyStream myStream &lt;/span&gt;=&lt;span&gt; lastNextItemEvalProcess.eval();
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; distinct(&lt;span&gt;new&lt;/span&gt; HashSet&amp;lt;&amp;gt;&lt;span&gt;(), myStream);
            }
        );

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 求值链条 加入一个新的process limit&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
    }

  &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 递归函数 配合API.distinct
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; MyStream&amp;lt;T&amp;gt; distinct(Set&amp;lt;T&amp;gt; distinctSet,MyStream&amp;lt;T&amp;gt;&lt;span&gt; myStream){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(myStream.isEmptyStream()){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Stream.makeEmptyStream();
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;distinctSet.contains(myStream.head)){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 加入集合&lt;/span&gt;
&lt;span&gt;            distinctSet.add(myStream.head);

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Builder&amp;lt;T&amp;gt;&lt;span&gt;()
                .head(myStream.head)
                .nextItemEvalProcess(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; NextItemEvalProcess(()-&amp;gt;&lt;span&gt;distinct(distinctSet, myStream.eval())))
                .build();
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; distinct(distinctSet, myStream.eval());
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;peek：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('56525837-edf6-43ab-960f-ffb819c3c73d')&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_56525837-edf6-43ab-960f-ffb819c3c73d&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_56525837-edf6-43ab-960f-ffb819c3c73d&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('56525837-edf6-43ab-960f-ffb819c3c73d',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_56525837-edf6-43ab-960f-ffb819c3c73d&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; MyStream&amp;lt;T&amp;gt; peek(ForEach&amp;lt;T&amp;gt;&lt;span&gt; consumer) {
        NextItemEvalProcess lastNextItemEvalProcess &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.nextItemEvalProcess;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.nextItemEvalProcess = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NextItemEvalProcess(
            ()&lt;/span&gt;-&amp;gt;&lt;span&gt; {
                MyStream myStream &lt;/span&gt;=&lt;span&gt; lastNextItemEvalProcess.eval();
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; peek(consumer,myStream);
            }
        );

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 求值链条 加入一个新的process peek&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
    }

  &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 递归函数 配合API.peek
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; MyStream&amp;lt;T&amp;gt; peek(ForEach&amp;lt;T&amp;gt; consumer,MyStream&amp;lt;T&amp;gt;&lt;span&gt; myStream){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(myStream.isEmptyStream()){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Stream.makeEmptyStream();
        }

        consumer.apply(myStream.head);

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; MyStream.Builder&amp;lt;T&amp;gt;&lt;span&gt;()
            .head(myStream.head)
            .nextItemEvalProcess(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; NextItemEvalProcess(()-&amp;gt;&lt;span&gt;peek(consumer, myStream.eval())))
            .build();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h3&gt;&lt;strong&gt;4.4 &lt;/strong&gt;对流使用强制求值函数，生成最终结果&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;/strong&gt;我们以&lt;strong&gt;forEach&lt;/strong&gt;方法举例说明。强制求值方法&lt;strong&gt;forEach&lt;/strong&gt;会不断的对当前stream进行求值并让consumer接收处理，直到当前流成为空流。&lt;/p&gt;
&lt;p&gt;有两种可能的情况会导致递归传入的流参数成为空流(&lt;strong&gt;empty-stream&lt;/strong&gt;)：&lt;/p&gt;
&lt;p&gt;　　1. 最初生成流的求值过程返回了空流(整数流，low &amp;gt; high 时，返回空流 )&lt;/p&gt;
&lt;p&gt;　　2. limit之类的短路操作，会提前终止流的求值返回空流(n == 0 时，返回空流)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; forEach(ForEach&amp;lt;T&amp;gt;&lt;span&gt; consumer) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 终结操作 直接开始求值&lt;/span&gt;
        forEach(consumer,&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.eval());
    }
    
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 递归函数 配合API.forEach
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; &lt;span&gt;void&lt;/span&gt; forEach(ForEach&amp;lt;T&amp;gt; consumer, MyStream&amp;lt;T&amp;gt;&lt;span&gt; myStream){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(myStream.isEmptyStream()){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }

        consumer.apply(myStream.head);
        forEach(consumer, myStream.eval());
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　强制求值的接口的实现也都大同小异，限于篇幅就不一一展开啦。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;reduce：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('f827a47e-0490-43e0-8195-ef9c5d3ee0e4')&quot; readability=&quot;40.5&quot;&gt;&lt;img id=&quot;code_img_closed_f827a47e-0490-43e0-8195-ef9c5d3ee0e4&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_f827a47e-0490-43e0-8195-ef9c5d3ee0e4&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('f827a47e-0490-43e0-8195-ef9c5d3ee0e4',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_f827a47e-0490-43e0-8195-ef9c5d3ee0e4&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;76&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 递归函数 配合API.reduce
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;R,T&amp;gt; R reduce(R initVal, BiFunction&amp;lt;R,R,T&amp;gt; accumulator, MyStream&amp;lt;T&amp;gt;&lt;span&gt; myStream){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(myStream.isEmptyStream()){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; initVal;
        }

        T head &lt;/span&gt;=&lt;span&gt; myStream.head;
        R result &lt;/span&gt;=&lt;span&gt; reduce(initVal,accumulator, myStream.eval());

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; accumulator.apply(result,head);
    }

  &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 递归函数 配合API.reduce
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;R,T&amp;gt; R reduce(R initVal, BiFunction&amp;lt;R,R,T&amp;gt; accumulator, MyStream&amp;lt;T&amp;gt;&lt;span&gt; myStream){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(myStream.isEmptyStream()){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; initVal;
        }

        T head &lt;/span&gt;=&lt;span&gt; myStream.head;
        R result &lt;/span&gt;=&lt;span&gt; reduce(initVal,accumulator, myStream.eval());

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; accumulator.apply(result,head);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;max：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('de8bf932-faad-439b-9948-46cbdfa11e48')&quot; readability=&quot;37&quot;&gt;&lt;img id=&quot;code_img_closed_de8bf932-faad-439b-9948-46cbdfa11e48&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_de8bf932-faad-439b-9948-46cbdfa11e48&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('de8bf932-faad-439b-9948-46cbdfa11e48',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_de8bf932-faad-439b-9948-46cbdfa11e48&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;69&quot;&gt;
&lt;pre&gt;
&lt;span&gt;   @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; T max(Comparator&amp;lt;T&amp;gt;&lt;span&gt; comparator) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 终结操作 直接开始求值&lt;/span&gt;
        MyStream&amp;lt;T&amp;gt; eval = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.eval();

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(eval.isEmptyStream()){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; max(comparator,eval,eval.head);
        }
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 递归函数 配合API.max
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; T max(Comparator&amp;lt;T&amp;gt; comparator, MyStream&amp;lt;T&amp;gt;&lt;span&gt; myStream, T max){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(myStream.isEnd){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; max;
        }

        T head &lt;/span&gt;=&lt;span&gt; myStream.head;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; head 和 max 进行比较&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(comparator.compare(head,max) &amp;gt; 0&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; head 较大 作为新的max传入&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; max(comparator, myStream.eval(),head);
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; max 较大 不变&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; max(comparator, myStream.eval(),max);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;min：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('b89f4b0f-8246-4aea-a20b-2ec494b0b17e')&quot; readability=&quot;37&quot;&gt;&lt;img id=&quot;code_img_closed_b89f4b0f-8246-4aea-a20b-2ec494b0b17e&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_b89f4b0f-8246-4aea-a20b-2ec494b0b17e&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('b89f4b0f-8246-4aea-a20b-2ec494b0b17e',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_b89f4b0f-8246-4aea-a20b-2ec494b0b17e&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;69&quot;&gt;
&lt;pre&gt;
&lt;span&gt;   @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; T min(Comparator&amp;lt;T&amp;gt;&lt;span&gt; comparator) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 终结操作 直接开始求值&lt;/span&gt;
        MyStream&amp;lt;T&amp;gt; eval = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.eval();

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(eval.isEmptyStream()){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; min(comparator,eval,eval.head);
        }
    }

  &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 递归函数 配合API.min
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; T min(Comparator&amp;lt;T&amp;gt; comparator, MyStream&amp;lt;T&amp;gt;&lt;span&gt; myStream, T min){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(myStream.isEnd){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; min;
        }

        T head &lt;/span&gt;=&lt;span&gt; myStream.head;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; head 和 min 进行比较&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(comparator.compare(head,min) &amp;lt; 0&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; head 较小 作为新的min传入&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; min(comparator, myStream.eval(),head);
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; min 较小 不变&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; min(comparator, myStream.eval(),min);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;count：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('9e80cbb6-0bb5-44b8-8477-aac172bd58cf')&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_9e80cbb6-0bb5-44b8-8477-aac172bd58cf&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_9e80cbb6-0bb5-44b8-8477-aac172bd58cf&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('9e80cbb6-0bb5-44b8-8477-aac172bd58cf',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_9e80cbb6-0bb5-44b8-8477-aac172bd58cf&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt;   @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; count() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 终结操作 直接开始求值&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; count(&lt;span&gt;this&lt;/span&gt;.eval(),0&lt;span&gt;);
    }

  &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 递归函数 配合API.count
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; &lt;span&gt;int&lt;/span&gt; count(MyStream&amp;lt;T&amp;gt; myStream, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; count){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(myStream.isEmptyStream()){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; count;
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; count+1 进行递归&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; count(myStream.eval(),count+1&lt;span&gt;);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;anyMatch：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('61e40265-3030-4bc7-8b7d-f60367d1bc2c')&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_61e40265-3030-4bc7-8b7d-f60367d1bc2c&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_61e40265-3030-4bc7-8b7d-f60367d1bc2c&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('61e40265-3030-4bc7-8b7d-f60367d1bc2c',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_61e40265-3030-4bc7-8b7d-f60367d1bc2c&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt;   @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; anyMatch(Predicate&amp;lt;? &lt;span&gt;super&lt;/span&gt; T&amp;gt;&lt;span&gt; predicate) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 终结操作 直接开始求值&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; anyMatch(predicate,&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.eval());
    }
    
  &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 递归函数 配合API.anyMatch
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; &lt;span&gt;boolean&lt;/span&gt; anyMatch(Predicate&amp;lt;? &lt;span&gt;super&lt;/span&gt; T&amp;gt; predicate,MyStream&amp;lt;T&amp;gt;&lt;span&gt; myStream){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(myStream.isEmptyStream()){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 截止末尾，不存在任何匹配项&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 谓词判断&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(predicate.satisfy(myStream.head)){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 匹配 存在匹配项 返回true&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 不匹配，继续检查，直到存在匹配项&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; anyMatch(predicate,myStream.eval());
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;allMatch：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('d84867b6-eeb6-441a-a486-44956de1b80a')&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_d84867b6-eeb6-441a-a486-44956de1b80a&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_d84867b6-eeb6-441a-a486-44956de1b80a&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('d84867b6-eeb6-441a-a486-44956de1b80a',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_d84867b6-eeb6-441a-a486-44956de1b80a&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt;   @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; allMatch(Predicate&amp;lt;? &lt;span&gt;super&lt;/span&gt; T&amp;gt;&lt;span&gt; predicate) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 终结操作 直接开始求值&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; allMatch(predicate,&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.eval());
    }
    
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 递归函数 配合API.anyMatch
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; &lt;span&gt;boolean&lt;/span&gt; allMatch(Predicate&amp;lt;? &lt;span&gt;super&lt;/span&gt; T&amp;gt; predicate,MyStream&amp;lt;T&amp;gt;&lt;span&gt; myStream){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(myStream.isEmptyStream()){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 全部匹配&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 谓词判断&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(predicate.satisfy(myStream.head)){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当前项匹配，继续检查&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; allMatch(predicate,myStream.eval());
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 存在不匹配的项，返回false&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h3&gt;&lt;strong&gt;4.5 &lt;/strong&gt;&lt;strong&gt;collect方法&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;collect方法是强制求值方法中，最复杂也最强大的接口，其作用是将流中的元素收集(collect)起来，并转化成特定的数据结构。&lt;/p&gt;
&lt;p&gt;　　从函数式编程的角度来看，collect方法是一个高阶函数，其接受三个函数作为参数(&lt;strong&gt;supplier&lt;/strong&gt;，&lt;strong&gt;accumulator&lt;/strong&gt;，&lt;strong&gt;finisher&lt;/strong&gt;)，最终生成一个更加强大的函数。在java中，三个函数参数以Collector实现对象的形式呈现。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;supplier&lt;/strong&gt; 方法：用于提供收集collect的初始值。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;accumulator&lt;/strong&gt; 方法：用于指定收集过程中，初始值和流中个体元素聚合的逻辑。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;finnisher&lt;/strong&gt; 方法：用于指定在收集完成之后的收尾转化操作(例如：StringBuilder.toString() ---&amp;gt; String)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;collect接口实现：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &amp;lt;R, A&amp;gt; R collect(Collector&amp;lt;T, A, R&amp;gt;&lt;span&gt; collector) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 终结操作 直接开始求值&lt;/span&gt;
        A result = collect(collector,&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.eval());

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过finish方法进行收尾&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; collector.finisher().apply(result);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 递归函数 配合API.collect
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;R, A, T&amp;gt; A collect(Collector&amp;lt;T, A, R&amp;gt; collector, MyStream&amp;lt;T&amp;gt;&lt;span&gt; myStream){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(myStream.isEmptyStream()){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; collector.supplier().get();
        }

        T head &lt;/span&gt;=&lt;span&gt; myStream.head;
        A tail &lt;/span&gt;=&lt;span&gt; collect(collector, myStream.eval());

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; collector.accumulator().apply(tail,head);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;collector接口：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * collect接口 收集器
 * 通过传入组合子，生成高阶过程
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; Collector&amp;lt;T, A, R&amp;gt;&lt;span&gt; {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 收集时，提供初始化的值
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    Supplier&lt;/span&gt;&amp;lt;A&amp;gt;&lt;span&gt; supplier();

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * A = A + T
     * 累加器，收集时的累加过程
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    BiFunction&lt;/span&gt;&amp;lt;A, A, T&amp;gt;&lt;span&gt; accumulator();

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 收集完成之后的收尾操作
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    Function&lt;/span&gt;&amp;lt;A, R&amp;gt;&lt;span&gt; finisher();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;了解jdk源码的读者可能会注意到，jdk的stream实现中collector接口多了一个combiner接口，combiner接口用于指定并行计算之后的结果集合并的逻辑，由于我们的实现不支持并行计算，因此也不需要添加combiner接口了。&lt;/p&gt;
&lt;p&gt;　　同时，jdk还提供了一个Collectors工具类，很好的满足了平时常见的需求(Collector.toList()、Collctor.groupingBy())等等。但特殊时刻还是需要用户自己指定collect传入的参数，精细的控制处理逻辑的，因此还是有必要了解一下collect方法内部原理的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;stream.collect()参数常用工具类：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * stream.collect() 参数常用工具类
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CollectUtils {
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * stream 转换为 List
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; Collector&amp;lt;T, List&amp;lt;T&amp;gt;, List&amp;lt;T&amp;gt;&amp;gt;&lt;span&gt; toList(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Collector&amp;lt;T, List&amp;lt;T&amp;gt;, List&amp;lt;T&amp;gt;&amp;gt;&lt;span&gt;() {
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Supplier&amp;lt;List&amp;lt;T&amp;gt;&amp;gt;&lt;span&gt; supplier() {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; ArrayList::&lt;span&gt;new&lt;/span&gt;&lt;span&gt;;
            }&lt;br/&gt;@Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; BiFunction&amp;lt;List&amp;lt;T&amp;gt;, List&amp;lt;T&amp;gt;, T&amp;gt;&lt;span&gt; accumulator() {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (list, item) -&amp;gt;&lt;span&gt; {
                    list.add(item);
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; list;
                };
            }&lt;br/&gt;@Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Function&amp;lt;List&amp;lt;T&amp;gt;, List&amp;lt;T&amp;gt;&amp;gt;&lt;span&gt; finisher() {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; list -&amp;gt;&lt;span&gt; list;
            }
        };
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * stream 转换为 Set
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; Collector&amp;lt;T, Set&amp;lt;T&amp;gt;, Set&amp;lt;T&amp;gt;&amp;gt;&lt;span&gt; toSet(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Collector&amp;lt;T, Set&amp;lt;T&amp;gt;, Set&amp;lt;T&amp;gt;&amp;gt;&lt;span&gt;() {
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Supplier&amp;lt;Set&amp;lt;T&amp;gt;&amp;gt;&lt;span&gt; supplier() {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; HashSet::&lt;span&gt;new&lt;/span&gt;&lt;span&gt;;
            }&lt;br/&gt;@Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; BiFunction&amp;lt;Set&amp;lt;T&amp;gt;, Set&amp;lt;T&amp;gt;, T&amp;gt;&lt;span&gt; accumulator() {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (set, item) -&amp;gt;&lt;span&gt; {
                    set.add(item);
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; set;
                };
            }&lt;br/&gt;@Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Function&amp;lt;Set&amp;lt;T&amp;gt;, Set&amp;lt;T&amp;gt;&amp;gt;&lt;span&gt; finisher() {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; set -&amp;gt;&lt;span&gt; set;
            }
        };
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;strong&gt;4.6 &lt;/strong&gt;&lt;strong&gt;举例分析&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;我们选择一个简单而又不失一般性的例子，串联起这些内容。通过完整的描述一个流求值的全过程，加深大家对流的理解。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args){&lt;/span&gt;&lt;span&gt;
        Integer sum &lt;/span&gt;=&lt;span&gt; IntegerStreamGenerator.getIntegerStream(1,10)
                    .filter(item&lt;/span&gt;-&amp;gt; item%2 == 0) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 过滤出偶数&lt;/span&gt;
                    .map(item-&amp;gt; item * item)    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 映射为平方&lt;/span&gt;
                    .limit(2)                   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 截取前两个&lt;/span&gt;
                    .reduce(0,(i1,i2)-&amp;gt; i1+i2); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 最终结果累加求和(初始值为0)&lt;/span&gt;
&lt;span&gt;
        System.out.println(sum); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt;
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　由于我们的stream实现采用的是链式编程的方式，不太好理解，将其展开为逻辑等价的形式。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args){&lt;br/&gt;&lt;/span&gt;&lt;span&gt;　　　　 //&lt;/span&gt;&lt;span&gt; 生成整数流 1-10&lt;/span&gt;
        Stream&amp;lt;Integer&amp;gt; intStream =&lt;span&gt; IntegerStreamGenerator.getIntegerStream(1,10);&lt;br/&gt;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; intStream基础上过滤出偶数&lt;/span&gt;
        Stream&amp;lt;Integer&amp;gt; filterStream =  intStream.filter(item-&amp;gt; item%2 == 0&lt;span&gt;);&lt;br/&gt;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; filterStream基础上映射为平方&lt;/span&gt;
        Stream&amp;lt;Integer&amp;gt; mapStream = filterStream.map(item-&amp;gt; item *&lt;span&gt; item);&lt;br/&gt;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; mapStream基础上截取前两个&lt;/span&gt;
        Stream&amp;lt;Integer&amp;gt; limitStream = mapStream.limit(2&lt;span&gt;);&lt;br/&gt;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 最终结果累加求和(初始值为0)&lt;/span&gt;
        Integer sum = limitStream.reduce(0,(i1,i2)-&amp;gt; i1+&lt;span&gt;i2);

        System.out.println(sum); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt;
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;reduce强制求值操作之前的执行过程图：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1506329/201903/1506329-20190313105216236-879324712.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;reduce强制求值过程中的执行过程图 ：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1506329/201903/1506329-20190314220758233-258101617.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　可以看到，stream的求值过程并不会一口气将初始的流全部求值，而是按需的、一个一个的进行求值。&lt;/p&gt;
&lt;p&gt;　　stream的一次求值过程至多只会遍历流中元素一次；如果存在短路操作(limit、anyMatch等)，实际迭代的次数会更少。&lt;/p&gt;
&lt;p&gt;　　因此不必担心多层的map、filter处理逻辑的嵌套会让流进行多次迭代，导致效率急剧下降。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1506329/201903/1506329-20190313190402408-471866930.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;5.1 当前版本缺陷&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1. 递归调用效率较低&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　为了代码的简洁性和更加的函数式，在实现中很多地方都用递归代替了循环迭代。&lt;/p&gt;
&lt;p&gt;　　虽然逻辑上递归和迭代是等价的，但在目前的计算机硬件上，每一层的递归调用都会使得函数调用栈增大。当流处理的数据量很大时，将会出现栈溢出，栈空间不足之类的系统错误。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;将递归优化为迭代能够增加当前版本流的执行效率。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. API接口较少&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;限于篇幅，我们只提供了一些较为常用的API接口。在jdk中，Collector工具类提供了很多方便易用的接口；对于同一API接口也提供了多种重载函数给用户使用。以目前已经实现的功能为基础，提供一些更加方便的接口并不困难。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 不支持并行计算&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;由于流在求值计算时生成的是对象的副本，是无副作用的，很适合通过数据分片的执行并行计算。限于个人水平，在设计之初并没有考虑将并行计算这一特性加入进来。&lt;/p&gt;
&lt;h3&gt;5.2 函数式编程&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;仔细分析整个流的执行过程，&lt;strong&gt;与其说流是一个对象，不如说流是一个高阶函数(high-order function)。&lt;/strong&gt;每当map、filter绑定了一个流，新生成的流其实是一个更加复杂的函数；每一层封装，都会使新生成的流这一高阶函数比起原基础变得更加强大和复杂。map、filter就像一个个的基础算子，在接收对应的过程后(filter(过滤出偶数)、map(平方映射))，可以不断的叠加，完成许许多多非常复杂的操作。&lt;/p&gt;
&lt;p&gt;　　这也是函数式编程的中心思想之一：&lt;strong&gt;将计算过程转化为一系列嵌套函数的调用。&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;5.3 总结&lt;/h3&gt;
&lt;p&gt;　　最初是在学习&lt;a href=&quot;https://www.zhihu.com/question/26549715&quot; target=&quot;_blank&quot;&gt;《计算机程序的构造和解释》(SICP)&lt;/a&gt;中stream流计算时突发奇想的，想着能不能用java来实现一个和书上类似的流计算框架，能和jdk的stream流功能大致相同，最终，通过反复地思考和尝试才将心中所想以java代码的形式呈现出来。&lt;/p&gt;
&lt;p&gt;　　SICP是一本小众但别具一格的计算机书籍，许多人认为它不太实用。我个人认为，虽然计算机技术发展日新月异，但是计算机技术的基础理论却往往变化缓慢，如果能够抓住技术发展背后那不变的元知识，就不容易在技术的浪潮中失去方向。SICP就是这样一本教授计算机科学元知识的书籍，虽然一开始有点枯燥，却能慢慢品味出其美妙之处。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;希望大家在阅读完这篇博客之后，能更好的理解流计算，更好的理解函数式编程。&lt;/p&gt;
&lt;p&gt;　　SICP公开课视频(中英字幕)：&lt;a href=&quot;https://www.bilibili.com/video/av8515129&quot; target=&quot;_blank&quot;&gt;https://www.bilibili.com/video/av8515129&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;　　这篇博客的完整代码在我的github上：&lt;a href=&quot;https://github.com/1399852153/Streamjava&quot; target=&quot;_blank&quot;&gt;https://github.com/1399852153/Streamjava&lt;/a&gt;，存在许多不足之处，请多多指教。&lt;/p&gt;

</description>
<pubDate>Thu, 14 Mar 2019 14:12:00 +0000</pubDate>
<dc:creator>小熊餐馆</dc:creator>
<og:description>1.Stream 流的介绍 1.1 java8 stream介绍 java8新增了stream流的特性，能够让用户以函数式的方式、更为简单的操纵集合等数据结构，并实现了用户无感知的并行计算。 1.2&amp;</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiaoxiongcanguan/p/10511233.html</dc:identifier>
</item>
<item>
<title>linux平台，对线程等待和唤醒操作的封装（涉及pthread_cond_timedwait） - 源之缘</title>
<link>http://www.cnblogs.com/yuanchenhui/p/thread_signal.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuanchenhui/p/thread_signal.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/span&gt; linux平台下，线程等待和唤醒操作是很常见的，但是平台函数不易使用；笔者对此操作做了封装，使之更易于使用。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;线程等待和唤醒函数比较&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 平台提供了线程等待相关函数，这些函数之间用法也有些差异：&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;sleep&lt;/td&gt;
&lt;td&gt;线程等待，等待期间线程无法唤醒。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;pthread_cond_wait&lt;/td&gt;
&lt;td&gt; 线程等待信号触发，如果没有信号触发，无限期等待下去。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;pthread_cond_timedwait&lt;/td&gt;
&lt;td&gt; 线程等待一定的时间，如果超时或有信号触发，线程唤醒。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;　　通过上表，可以看出pthread_cond_timedwait函数是最为灵活，使用也最为广泛。sleep的缺陷是当有紧急事件到达时，线程无法及时唤醒。pthread_cond_wait缺陷是：必须借助别的线程触发信号，否则线程自身无法唤醒，如果使用函数，线程无法处理定时任务。&lt;/p&gt;
&lt;p&gt;　　一般情况下，线程要做的工作可能有：&lt;strong&gt;定期处理某个事物；无事可做时，线程挂起；有事可做时，立即唤醒工作&lt;/strong&gt;。要完成上面所述的功能，必须用pthread_cond_timedwait函数，本文介绍的就是对该函数封装。&lt;/p&gt;
&lt;p&gt;　　线程唤醒操作还涉及互斥量pthread_mutex_t，感觉与我们理解的等待和唤醒操作无关；此函数的引入，增加了理解难度。本文封装完全屏蔽了此概念。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;函数定义如下&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;函数涉及的变量&lt;/span&gt;
typedef &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; ThreadSignal_T
{
    BOOL  relativeTimespan; &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否采用相对时间&lt;/span&gt;
&lt;span&gt;
    pthread_cond_t cond;
    pthread_mutex_t mutex;

    pthread_condattr_t cattr;

} ThreadSignal;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; ThreadSignal_Init(ThreadSignal *&lt;span&gt;signal,BOOL relativeTimespan);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; ThreadSignal_Close(ThreadSignal *&lt;span&gt;signal);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;等待n毫秒&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; ThreadSignal_Wait(ThreadSignal *signal, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; ms);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;唤醒线程&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; ThreadSignal_Signal(ThreadSignal *signal);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上述函数定义非常直观，利于理解。但是平台提供的函数，就不是那么直观。我把上述函数的实现一一列出来。&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;&lt;strong&gt;1）ThreadSignal_Init&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; ThreadSignal_Init(ThreadSignal *&lt;span&gt;signal, BOOL relativeTimespan)
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;relativeTimespan 是不是采用相对时间等待。参见函数 ThreadSignal_Wait&lt;/span&gt;
    signal-&amp;gt;relativeTimespan =&lt;span&gt; relativeTimespan;

    pthread_mutex_init(&lt;/span&gt;&amp;amp;signal-&amp;gt;&lt;span&gt;mutex, NULL);

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (relativeTimespan)
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果采用相对时间等待，需要额外的处理。
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;采用相对时间等待。可以避免：因系统调整时间，导致等待时间出现错误。&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; ret = pthread_condattr_init(&amp;amp;signal-&amp;gt;&lt;span&gt;cattr);
        ret &lt;/span&gt;= pthread_condattr_setclock(&amp;amp;signal-&amp;gt;&lt;span&gt;cattr, CLOCK_MONOTONIC);

        ret &lt;/span&gt;= pthread_cond_init(&amp;amp;signal-&amp;gt;cond, &amp;amp;signal-&amp;gt;&lt;span&gt;cattr);
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
    {
        pthread_cond_init(&lt;/span&gt;&amp;amp;signal-&amp;gt;&lt;span&gt;cond, NULL);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2) ThreadSignal_Close&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; ThreadSignal_Close(ThreadSignal *&lt;span&gt;signal)
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (signal-&amp;gt;&lt;span&gt;relativeTimespan)
    {
        pthread_condattr_destroy(&lt;/span&gt;&amp;amp;(signal-&amp;gt;&lt;span&gt;cattr));
    }

    pthread_mutex_destroy(&lt;/span&gt;&amp;amp;signal-&amp;gt;&lt;span&gt;mutex);
    pthread_cond_destroy(&lt;/span&gt;&amp;amp;signal-&amp;gt;&lt;span&gt;cond);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3) ThreadSignal_Wait&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; ThreadSignal_Wait(ThreadSignal *signal, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; ms)
{
    pthread_mutex_lock(&lt;/span&gt;&amp;amp;signal-&amp;gt;&lt;span&gt;mutex);

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (signal-&amp;gt;&lt;span&gt;relativeTimespan)
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取时间&lt;/span&gt;
        &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; timespec outtime;
        clock_gettime(CLOCK_MONOTONIC, &lt;/span&gt;&amp;amp;&lt;span&gt;outtime);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ms为毫秒，换算成秒&lt;/span&gt;
        outtime.tv_sec += ms/&lt;span&gt;1000&lt;/span&gt;&lt;span&gt;;
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在outtime的基础上，增加ms毫秒
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;outtime.tv_nsec为纳秒，1微秒=1000纳秒
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;tv_nsec此值再加上剩余的毫秒数 ms%1000，有可能超过1秒。需要特殊处理&lt;/span&gt;
        uint64_t  us = outtime.tv_nsec/&lt;span&gt;1000&lt;/span&gt; + &lt;span&gt;1000&lt;/span&gt; * (ms % &lt;span&gt;1000&lt;/span&gt;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;微秒
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;us的值有可能超过1秒，&lt;/span&gt;
        outtime.tv_sec += us / &lt;span&gt;1000000&lt;/span&gt;&lt;span&gt;; 

        us &lt;/span&gt;= us % &lt;span&gt;1000000&lt;/span&gt;&lt;span&gt;;
        outtime.tv_nsec &lt;/span&gt;= us * &lt;span&gt;1000&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;换算成纳秒&lt;/span&gt;

        &lt;span&gt;int&lt;/span&gt; ret = pthread_cond_timedwait(&amp;amp;signal-&amp;gt;cond, &amp;amp;signal-&amp;gt;mutex, &amp;amp;&lt;span&gt;outtime);
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; timeval now;
        gettimeofday(&lt;/span&gt;&amp;amp;&lt;span&gt;now, NULL);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在now基础上，增加ms毫秒&lt;/span&gt;
        &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; timespec outtime;
        outtime.tv_sec &lt;/span&gt;= now.tv_sec + ms / &lt;span&gt;1000&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;us的值有可能超过1秒&lt;/span&gt;
        uint64_t  us = now.tv_usec + &lt;span&gt;1000&lt;/span&gt; * (ms % &lt;span&gt;1000&lt;/span&gt;&lt;span&gt;); 
        outtime.tv_sec &lt;/span&gt;+= us / &lt;span&gt;1000000&lt;/span&gt;&lt;span&gt;; 

        us &lt;/span&gt;= us % &lt;span&gt;1000000&lt;/span&gt;&lt;span&gt;;
        outtime.tv_nsec &lt;/span&gt;= us * &lt;span&gt;1000&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; ret = pthread_cond_timedwait(&amp;amp;signal-&amp;gt;cond, &amp;amp;signal-&amp;gt;mutex, &amp;amp;&lt;span&gt;outtime);
    }
    pthread_mutex_unlock(&lt;/span&gt;&amp;amp;signal-&amp;gt;&lt;span&gt;mutex);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上述函数处理起来有点啰嗦，有些读者可能认为这是多此一举，其实不然。 struct timespec outtime;结构中有两个值：tv_sec ，tv_usec 。分别是秒和纳秒。等待一段时间就是：在这两个值上增加一定的数值。&lt;/p&gt;
&lt;p&gt;tv_usec 此值有范围限制的，就是不能超过1秒暨1000000000纳秒。如果超出1秒，就要在tv_sec 此值增加一秒；tv_usec 减去一秒。笔者是在实践中发现此问题的，不是无中生有。如果tv_usec 此值溢出，调用pthread_cond_timedwait函数，会立马返回。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4）ThreadSignal_Signal&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; ThreadSignal_Signal(ThreadSignal *&lt;span&gt;signal)
{
    pthread_mutex_lock(&lt;/span&gt;&amp;amp;signal-&amp;gt;&lt;span&gt;mutex);
    pthread_cond_signal(&lt;/span&gt;&amp;amp;signal-&amp;gt;&lt;span&gt;cond);
    pthread_mutex_unlock(&lt;/span&gt;&amp;amp;signal-&amp;gt;&lt;span&gt;mutex);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;&lt;strong&gt;&lt;span&gt;后记&lt;/span&gt; &lt;/strong&gt;&lt;/span&gt;一个简单的信号等待操作，linux下处理起来就如此复杂，远不如c#、java等语言处理起来那么优雅。通过本文介绍的方法，将复杂的问题封装起来，让使用者用起来得心应手，这就是函数封装要达到的目的。
&lt;/pre&gt;</description>
<pubDate>Thu, 14 Mar 2019 14:11:00 +0000</pubDate>
<dc:creator>源之缘</dc:creator>
<og:description>前言 linux平台下，线程等待和唤醒操作是很常见的，但是平台函数不易使用；笔者对此操作做了封装，使之更易于使用。 线程等待和唤醒函数比较 平台提供了线程等待相关函数，这些函数之间用法也有些差异： 通</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yuanchenhui/p/thread_signal.html</dc:identifier>
</item>
<item>
<title>搞懂MySQL分区 - GrimMjx</title>
<link>http://www.cnblogs.com/GrimMjx/p/10526821.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/GrimMjx/p/10526821.html</guid>
<description>&lt;h2&gt;一.InnoDB逻辑存储结构&lt;/h2&gt;
&lt;p&gt;　　首先要先介绍一下InnoDB逻辑存储结构和区的概念，&lt;span&gt;它的所有数据都被逻辑地存放在表空间，表空间又由段，区，页组成。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1465200/201903/1465200-20190313211422354-1043302132.png&quot; alt=&quot;&quot; width=&quot;1164&quot; height=&quot;582&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;段&lt;/h3&gt;
&lt;p&gt;　　段就是上图的segment区域，常见的段有数据段、索引段、回滚段等，在InnoDB存储引擎中，对段的管理都是由引擎自身所完成的。&lt;/p&gt;
&lt;h3&gt;区&lt;/h3&gt;
&lt;p&gt;　　区就是上图的extent区域，&lt;span&gt;区是由连续的页组成的空间，无论页的大小怎么变，区的大小默认总是为1MB。&lt;/span&gt;为了保证区中的页的连续性，InnoDB存储引擎一次从磁盘申请4-5个区，InnoDB页的大小默认为16kb，即一个区一共有64（1MB/16kb=16）个连续的页。&lt;span&gt;每个段开始，先用32页（page）大小的碎片页来存放数据，在使用完这些页之后才是64个连续页的申请。这样做的目的是，对于一些小表或者是undo类的段，可以开始申请较小的空间，节约磁盘开销。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;页&lt;/h3&gt;
&lt;p&gt;　　页就是上图的page区域，也可以叫块。&lt;span&gt;页是InnoDB磁盘管理的最小单位。默认大小为16KB&lt;/span&gt;，可以通过参数innodb_page_size来设置。常见的页类型有：数据页，undo页，系统页，事务数据页，插入缓冲位图页，插入缓冲空闲列表页，未压缩的二进制大对象页，压缩的二进制大对象页等。　　&lt;/p&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;h2&gt;二.分区概述&lt;/h2&gt;
&lt;h3&gt;分区&lt;/h3&gt;
&lt;p&gt;　　&lt;span&gt;这里讲的分区，此“区”非彼“区”，这里讲的分区的意思是指将同一表中不同行的记录分配到不同的物理文件中，几个分区就有几个.idb文件，不是我们刚刚说的区。&lt;/span&gt;MySQL在5.1时添加了对水平分区的支持。分区是将一个表或索引分解成多个更小，更可管理的部分。每个区都是独立的，可以独立处理，也可以作为一个更大对象的一部分进行处理。这个是MySQL支持的功能，&lt;span&gt;业务代码无需改动。&lt;span&gt;要知道MySQL是面向OLTP的数据，它不像TIDB等其他DB。那么对于分区的使用应该非常小心，&lt;span&gt;如果不清楚如何使用分区可能会对性能产生负面的影响。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　MySQL数据库的分区是局部分区索引，一个分区中既存了数据，又放了索引。也就是说，每个区的聚集索引和非聚集索引都放在各自区的（不同的物理文件）。目前MySQL数据库还不支持全局分区。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　无论哪种类型的分区，&lt;span&gt;如果表中存在主键或唯一索引时，分区列必须是唯一索引的一个组成部分。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;三.分区类型&lt;/h2&gt;
&lt;p&gt; 　　目前MySQL支持一下几种类型的分区，RANGE分区，LIST分区，HASH分区，KEY分区。&lt;span&gt;如果表存在主键或者唯一索引时，分区列必须是唯一索引的一个组成部分。实战十有八九都是用RANGE分区。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;RANGE分区&lt;/h3&gt;
&lt;p&gt;　　RANGE分区是实战最常用的一种分区类型，行数据基于属于一个给定的连续区间的列值被放入分区。但是记住，当插入的数据不在一个分区中定义的值的时候，会抛异常。RANGE分区主要用于日期列的分区，比如交易表啊，销售表啊等。可以根据年月来存放数据。如果你分区走的唯一索引中date类型的数据，那么注意了，优化器只能对YEAR(),TO_DAYS(),TO_SECONDS(),UNIX_TIMESTAMP()这类函数进行优化选择。实战中可以用int类型，那么只用存yyyyMM就好了。也不用关心函数了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt; `m_test_db`.`&lt;span&gt;Order&lt;/span&gt;&lt;span&gt;` (
  `id` &lt;/span&gt;&lt;span&gt;INT&lt;/span&gt; &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt; AUTO_INCREMENT,
  `partition_key` &lt;/span&gt;&lt;span&gt;INT&lt;/span&gt; &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
  `amt` &lt;/span&gt;&lt;span&gt;DECIMAL&lt;/span&gt;(&lt;span&gt;5&lt;/span&gt;) &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
  &lt;/span&gt;&lt;span&gt;PRIMARY&lt;/span&gt; &lt;span&gt;KEY&lt;/span&gt; (`id`, `partition_key`)) PARTITION &lt;span&gt;BY&lt;/span&gt; RANGE(partition_key) PARTITIONS &lt;span&gt;5&lt;/span&gt;( PARTITION part0 &lt;span&gt;VALUES&lt;/span&gt; LESS THAN (&lt;span&gt;201901&lt;/span&gt;),  PARTITION part1 &lt;span&gt;VALUES&lt;/span&gt; LESS THAN (&lt;span&gt;201902&lt;/span&gt;),  PARTITION part2 &lt;span&gt;VALUES&lt;/span&gt; LESS THAN (&lt;span&gt;201903&lt;/span&gt;),  PARTITION part3 &lt;span&gt;VALUES&lt;/span&gt; LESS THAN (&lt;span&gt;201904&lt;/span&gt;),  PARTITION part4 &lt;span&gt;VALUES&lt;/span&gt; LESS THAN (&lt;span&gt;201905&lt;/span&gt;)) ;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这时候我们先插入一些数据&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; `m_test_db`.`&lt;span&gt;Order&lt;/span&gt;` (`id`, `partition_key`, `amt`) &lt;span&gt;VALUES&lt;/span&gt; (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;201901&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1000&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; `m_test_db`.`&lt;span&gt;Order&lt;/span&gt;` (`id`, `partition_key`, `amt`) &lt;span&gt;VALUES&lt;/span&gt; (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;201902&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;800&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; `m_test_db`.`&lt;span&gt;Order&lt;/span&gt;` (`id`, `partition_key`, `amt`) &lt;span&gt;VALUES&lt;/span&gt; (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;201903&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1200&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　现在我们查询一下，通过EXPLAIN PARTITION命令发现SQL优化器只需搜对应的区，不会搜索所有分区&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1465200/201903/1465200-20190314214220819-207934787.png&quot; alt=&quot;&quot; width=&quot;891&quot; height=&quot;193&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　如果sql语句有问题，那么会走所有区。会很危险。所以分区表后，&lt;span&gt;select语句必须走分区键。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1465200/201903/1465200-20190314214317791-661280930.png&quot; alt=&quot;&quot; width=&quot;958&quot; height=&quot;207&quot;/&gt;&lt;/p&gt;

&lt;p&gt;以下3种不是太常用，就一笔带过了。&lt;/p&gt;
&lt;h3&gt;LIST分区&lt;/h3&gt;
&lt;p&gt;　　LIST分区和RANGE分区很相似，&lt;span&gt;只是分区列的值是离散的，不是连续的。LIST分区使用VALUES IN，因为每个分区的值是离散的，因此只能定义值。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;HASH分区&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　说到哈希，那么目的很明显了，&lt;span&gt;将数据均匀的分布到预先定义的各个分区中，&lt;/span&gt;保证每个分区的数量大致相同。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;KEY分区&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　KEY分区和HASH分区相似，不同之处在于HASH分区使用用户定义的函数进行分区，KEY分区使用数据库提供的函数进行分区。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;四.分区和性能&lt;/h2&gt;
&lt;p&gt;　　&lt;span&gt;一项技术，不是用了就一定带来益处。&lt;/span&gt;比如显式锁功能比内置锁强大，你没玩好可能导致很不好的情况。分区也是一样，不是启动了分区数据库就会运行的更快，分区可能会给某些sql语句性能提高，但是分区主要用于数据库高可用性的管理。数据库应用分为2类，一类是OLTP（在线事务处理），一类是OLAP（在线分析处理）。对于OLAP应用分区的确可以很好的提高查询性能，因为一般分析都需要返回大量的数据，如果按时间分区，比如一个月用户行为等数据，则只需扫描响应的分区即可。在OLTP应用中，分区更加要小心，通常不会获取一张大表的10%的数据，大部分是通过索引返回几条数据即可。&lt;/p&gt;
&lt;p&gt;　　比如一张表1000w数据量，如果一句select语句走辅助索引，但是走分区键。那么结果会很尴尬。如果1000w的B+树的高度是3，现在有10个分区。那么不是要(3+3)*10次的逻辑IO？（3次聚集索引，3次辅助索引，10个分区）。所以在OLTP应用中请小心使用分区表。&lt;/p&gt;
&lt;p&gt;　　在日常开发中，如果想查看sql语句的分区查询结果可以使用&lt;span&gt;explain partitions + select sql&lt;/span&gt;来获取，partitions标识走了哪几个分区。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
mysql&lt;span&gt;&amp;gt;&lt;/span&gt; explain partitions &lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; TxnList &lt;span&gt;where&lt;/span&gt; startTime&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2016-08-25 00:00:00&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; startTime&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2016-08-25 23:59:00&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;  
&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+-------------+-------------------+------------+------+---------------+------+---------+------+-------+-------------+  &lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; id &lt;span&gt;|&lt;/span&gt; select_type &lt;span&gt;|&lt;/span&gt; &lt;span&gt;table&lt;/span&gt;             &lt;span&gt;|&lt;/span&gt; partitions &lt;span&gt;|&lt;/span&gt; type &lt;span&gt;|&lt;/span&gt; possible_keys &lt;span&gt;|&lt;/span&gt; &lt;span&gt;key&lt;/span&gt;  &lt;span&gt;|&lt;/span&gt; key_len &lt;span&gt;|&lt;/span&gt; ref  &lt;span&gt;|&lt;/span&gt; rows  &lt;span&gt;|&lt;/span&gt; Extra       &lt;span&gt;|&lt;/span&gt;  
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+-------------+-------------------+------------+------+---------------+------+---------+------+-------+-------------+  &lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;  &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; SIMPLE      &lt;span&gt;|&lt;/span&gt; ClientActionTrack &lt;span&gt;|&lt;/span&gt; p20160825  &lt;span&gt;|&lt;/span&gt; &lt;span&gt;ALL&lt;/span&gt;  &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;          &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;    &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;33868&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; Using &lt;span&gt;where&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;  
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+-------------+-------------------+------------+------+---------------+------+---------+------+-------+-------------+  &lt;/span&gt;
&lt;span&gt;1&lt;/span&gt; row &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt; (&lt;span&gt;0.00&lt;/span&gt; sec)  
&lt;/pre&gt;&lt;/div&gt;



&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;《MySQL技术内幕》&lt;/p&gt;
&lt;p&gt;第一张图是从哪里偷来的忘记了- -！&lt;/p&gt;
</description>
<pubDate>Thu, 14 Mar 2019 14:04:00 +0000</pubDate>
<dc:creator>GrimMjx</dc:creator>
<og:description>一篇搞懂MySQL分区</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/GrimMjx/p/10526821.html</dc:identifier>
</item>
<item>
<title>QLineEdit拾遗：数据的过滤、验证和补全 - apocelipes</title>
<link>http://www.cnblogs.com/apocelipes/p/10533863.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/apocelipes/p/10533863.html</guid>
<description>&lt;p&gt;QLineEdit是使用频率最高的控件之一，当我们想获取用户输入时自然而然得会用到它。&lt;/p&gt;
&lt;p&gt;通常我们会将QLineEdit的信号或其他控件的信号绑定至槽函数，然后获取并处理编辑器内的数据。你会觉得我们拿到的是第一手的“热乎着”的数据，所以理所当然地将过滤和验证逻辑都加入槽函数中，然而事实并非如此。那么数据究竟通过了哪些流程最终才经由信号被我们获取呢？&lt;/p&gt;
&lt;p&gt;或者你希望QLineEdit能拥有自动补全或是输入联想的功能，这又如何实现呢？&lt;/p&gt;
&lt;p&gt;如果你对上面的问题毫无头绪，那么本文就是为你量身打造的，请继续往下阅读吧！&lt;/p&gt;
&lt;blockquote id=&quot;bookmark&quot;&gt;
&lt;h4&gt;本文索引&lt;/h4&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;引论&quot;&gt;引论&lt;/h2&gt;
&lt;p&gt;这一节将带你概览QLineEdit对数据的处理，并以一个示例引出后续章节的内容。你可以先在此处找到一些粗浅的回答，后续则会有详细的解释。&lt;/p&gt;
&lt;p&gt;如果要简单的回答第一问，那么在我们获取到text内容前需要经过两个步骤：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1434464/201903/1434464-20190314220147277-86339847.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;它们分别由&lt;code&gt;inputMask&lt;/code&gt;和&lt;code&gt;QValidator&lt;/code&gt;实现，前者负责过滤用户的输入，后者则用于过滤后的信息的验证。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;inputMask&lt;/code&gt;和&lt;code&gt;validator&lt;/code&gt;的表现很相似，有时它们的功能还会有一些重合，那么它们是否能取代彼此呢？答案是否定的，看起来像鸭子的鸟有时候其实不是和鸭子没关系，后面我们仔细说明。&lt;/p&gt;
&lt;p&gt;现在轮到回答第二个问题了。要实现补全和自动联想，你只需要将一个设置好的&lt;code&gt;QCompleter&lt;/code&gt;对象传递给QLineEdit。是不是够简单？大部分时间也确实如此，然而“设置好的”这一形容词的很抽象的概念，所以有的时候你可能要失望了，不过别担心，后面我们也会详细介绍它的使用。&lt;/p&gt;
&lt;p&gt;两问回答完毕，现在该来看看本文的示例了。这次我们将自己实现一个&lt;code&gt;DateEdit&lt;/code&gt;（我知道有现成的QDateEdit，不过这里请允许我为了实践所学而造一个粗糙的轮子），并根据用户输入的日期计算当天是周几，效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1434464/201903/1434464-20190314220133044-625661110.gif&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;实现customdateedit&quot;&gt;实现CustomDateEdit&lt;/h2&gt;
&lt;p&gt;在本节中我们将逐步实现CustomDateEdit，并详细介绍引论中提到的概念。&lt;/p&gt;
&lt;p&gt;按照流程图的顺序，我们首先要讲解的便是输入数据的过滤——&lt;code&gt;inputMask&lt;/code&gt;的功能。&lt;/p&gt;
&lt;h3 id=&quot;过滤用户输入inputmask&quot;&gt;过滤用户输入——inputMask&lt;/h3&gt;
&lt;p&gt;在具体介绍一个能控制显示效果的特性前，我习惯于先描述其大致功能和具体的显示效果。&lt;/p&gt;
&lt;p&gt;inputMask的功能：它是一串特定的规则，所有不符合规则的用户输入都会被丢弃，用户不管是从信号还是&lt;code&gt;text&lt;/code&gt;槽都只能获取符合mask要求的输入数据，当然这个“用户”包括我们后面要介绍的&lt;code&gt;QValidator&lt;/code&gt;及其派生类。&lt;/p&gt;
&lt;p&gt;inputMask的显示效果：你只能输入合法的字符，输入非法字符是输入内容无法显示，光标停留在原处；如果你设置了mask的填充字符，则这些字符会显示在edit中，当输入合法字符时将覆盖它们，mask中的保留字符同样显示在edit中，但输入时会被跳过不可覆盖（类似占位符），引论中的效果图就是很好的例子。&lt;/p&gt;
&lt;p&gt;inputMask就是一串由特殊字符组成的规则，通过规则给定的格式来控制文本的输入，具体的规则见下表：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;17&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;A&lt;/td&gt;
&lt;td&gt;必须输入的ascii字母，包括A-Z，a-z&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;a&lt;/td&gt;
&lt;td&gt;和&lt;code&gt;A&lt;/code&gt;一样，但是可选，也就是不输入这个字符也可以，占位符将保留&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;N&lt;/td&gt;
&lt;td&gt;必须输入的ascii字母和数字，包括A-Z，a-z，0-9&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;n&lt;/td&gt;
&lt;td&gt;和&lt;code&gt;N&lt;/code&gt;一样，但是可选&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;X&lt;/td&gt;
&lt;td&gt;必须输入的任意字符&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;和&lt;code&gt;X&lt;/code&gt;一样，但是可选&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;必填的ascii的数字字符，包括0-9&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;和&lt;code&gt;9&lt;/code&gt;一样，但是可选&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;D&lt;/td&gt;
&lt;td&gt;必填的数字，包括1-9&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;d&lt;/td&gt;
&lt;td&gt;和&lt;code&gt;D&lt;/code&gt;一样，但可选&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;#&lt;/td&gt;
&lt;td&gt;可选的数字或者加减号&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;H&lt;/td&gt;
&lt;td&gt;必填的16进制的数字，包括A-F, a-f, 0-9&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;h&lt;/td&gt;
&lt;td&gt;和&lt;code&gt;H&lt;/code&gt;一样，但可选&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;B&lt;/td&gt;
&lt;td&gt;必填的二进制数字，包括0和1&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;b&lt;/td&gt;
&lt;td&gt;和&lt;code&gt;B&lt;/code&gt;一样，但可选&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&amp;gt;&lt;/td&gt;
&lt;td&gt;所有在这个特殊字符之后的字符转换为大写&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&amp;lt;&lt;/td&gt;
&lt;td&gt;所有在这个特殊字符之后的字符转换为小写&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;!&lt;/td&gt;
&lt;td&gt;关闭前面的大小写转换&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;[ ] { }&lt;/td&gt;
&lt;td&gt;保留的特殊字符&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;\&lt;/td&gt;
&lt;td&gt;将特殊字符转义为普通字符&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;inputMask的格式为：&lt;code&gt;([特殊字符]|[普通字符])*;占位符&lt;/code&gt;，分号后跟的是占位符，用于填充特殊字符留下的空位，默认为空格。下面看些例子：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;000,000.00;_&lt;/code&gt;：用于输入一个最大6位，有两位小数的值，用&lt;code&gt;_&lt;/code&gt;填充空位，edit会显示出类似&lt;code&gt;___,___.__&lt;/code&gt;的效果&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;gt;AAAA-AAAA!-AAAA-AAAA&lt;/code&gt;：用于输入一个由连字符分割的字母数字组成的uuid或license key，且前八个字母会被转换为大写，在edit中显示为&lt;code&gt;- - -&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;9999年09月09日&lt;/code&gt;：用于输入年月日的时间格式，可以输入&lt;code&gt;2019年03月14日&lt;/code&gt;或&lt;code&gt;2019年3月14日&lt;/code&gt;，显示效果在引论的效果图中。&lt;/li&gt;
&lt;li&gt;空字符串：表示没有任何输入限制&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;你可以通过&lt;code&gt;setInputMask&lt;/code&gt;设置mask，或&lt;code&gt;inputMask&lt;/code&gt;获取当前的mask。&lt;/p&gt;
&lt;p&gt;通过上面的说明和例子你应该已经学会了inputMask的使用，现在可以看看它与validator的区别了：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;inputMask在用户进行输入时进行过滤，并且只存在符合规则和不符合两种状态，validator通常拥有第三种状态&lt;/li&gt;
&lt;li&gt;inputMask只能过滤较为固定的格式，并且对于输入的最大长度产生限制，validator则要灵活的多&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;最主要的区别是这两点。上一节提到inputMask不能替代validator，现在我们揭晓原因：inputMask只能保证输入数据的格式，但并不保证数据有意义，比如例子3中我们可以在月份上输入20，但明显日期中没有20月，而这种错误是inputMask无法处理的，这就是为什么我们说有时候一只看起来像鸭子的鸟也许和鸭子没有半点关系的原因。&lt;/p&gt;
&lt;p&gt;因此想要获得正确的数据，我们还需要验证器来帮忙。&lt;/p&gt;
&lt;h3 id=&quot;数据验证qvalidator&quot;&gt;数据验证——QValidator&lt;/h3&gt;
&lt;p&gt;现在该验证我们的输入了。因为有了inputMask的帮助，现在我们只需要验证数据本身是否正确而不用操心它的格式了，真是谢天谢地。&lt;/p&gt;
&lt;p&gt;等等，这么说好像不太对，validator拿到的数据里居然还保留着mask的占位符？你没看错，这不是bug，能在edit里显示出来的数据那么一定能被获得，mask本身的占位符是能通过过滤的，所以它会原封不动地传给validator，只有用户输入合法的数据后这些占位符才会被覆盖。所以在写自己的验证器的时候要小心了——我们需要先删除所有的占位符，因为它们不是数据的一部分！&lt;/p&gt;
&lt;p&gt;下面我们来看看validator的功能和显示效果。&lt;/p&gt;
&lt;p&gt;功能：验证数据是否合法，不合法会被丢弃，同时还要识别出数据是否输入完成，这就是validator返回的第三种状态。&lt;/p&gt;
&lt;p&gt;显示效果：和inputMask一样。如果数据未输入完则保留在edit中。&lt;/p&gt;
&lt;p&gt;大致概览后我们可以深入了解一下&lt;code&gt;QValidator&lt;/code&gt;了，所有的验证器都是它的派生类。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;QValidator&lt;/code&gt;本身是一个纯虚基类，派生类需要实现&lt;code&gt;QValidator::State QValidator::validate(QString &amp;amp;input, int &amp;amp;pos) const&lt;/code&gt;进行数据的验证，还有一个可选的&lt;code&gt;fixup&lt;/code&gt;函数用于修复输入，不过一般来说很少有自行修复输入的需求，所以这里使用默认的实现，也就是什么都不做。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;validate&lt;/code&gt;验证数据后返回数据是否合法，有&lt;code&gt;QValidator::State&lt;/code&gt;类型的值表示：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;QValidator::Invalid&lt;/code&gt; 数据不合法&lt;/li&gt;
&lt;li&gt;&lt;code&gt;QValidator::Intermediate&lt;/code&gt; 数据不完整需要进一步的输入&lt;/li&gt;
&lt;li&gt;&lt;code&gt;QValidator::Acceptable&lt;/code&gt; 数据合法&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;PyQt5中的接口稍微有些不同，处理第一个返回值的为&lt;code&gt;QValidator::State&lt;/code&gt;之外还需要把&lt;code&gt;input&lt;/code&gt;和&lt;code&gt;pos&lt;/code&gt;原封不动地作为第二和第三个值返回，否则edit无法正确显示输入的数据。&lt;/p&gt;
&lt;p&gt;你可以通过&lt;code&gt;validator&lt;/code&gt;和&lt;code&gt;setValidator&lt;/code&gt;来获取和设置验证器。&lt;/p&gt;
&lt;p&gt;因为额外引入了第三种状态，所以实现一个validator远比设置inputMask来的复杂，这里我们实现一个自定义的日期验证器用于配合&lt;code&gt;CustomDateEdit&lt;/code&gt;（我知道这个工作交给QRegExpValidator会很简单），同时介绍如何实现一个验证器。&lt;/p&gt;
&lt;p&gt;下面看看具体的代码，首先我们不需要为validator额外增加内容，只需要实现几个方法，因此不要要关注构造等行为：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class CustomDateValidator(QValidator):
    &quot;&quot;&quot;验证输入的是否是合法的年月日
    &quot;&quot;&quot;
    def validate(self, input: str, pos: int):
        date = input.replace(' ', '')  # 去除占位符
        y, m, d = self.splitDate(date)
        if not (y and m and d):
            return QValidator.Intermediate, input, pos

        try:
            arrow.get(date, self.dateFormat())  # 如果解析失败代表日期输入不合法
        except Exception:
            return QValidator.Invalid, input, pos

        return QValidator.Acceptable, input, pos

    def dateFormat(self):
        &quot;&quot;&quot;返回arrow库使用的日期解析格式，具体参见文档，这里与CustomDateEdit的inputMask保持一致
        &quot;&quot;&quot;
        return self.tr('YYYY年M月D日')

    def splitDate(self, date: str):
        &quot;&quot;&quot;分割日期成年，月，日，以便判断数据是否输入完整，
        只要有某一部分为空就表明数据未输入结束
        &quot;&quot;&quot;
        y, date = date.split(self.tr('年'))
        m, date = date.split(self.tr('月'))
        d = date.split(self.tr('日'))[0]
        return y, m, d&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到验证器的逻辑其实很简单。整个验证器加上帮助函数一共做了三件事：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;首先去除占位符，如前文所述&lt;/li&gt;
&lt;li&gt;接着将输入信息按年月日分割，如果有某一部分为空则代表输入不完整&lt;/li&gt;
&lt;li&gt;对于完整的输入则使用arrow解析成时间对象，失败则表示输入数据错误&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;其他的细节都已经在注释中说明。&lt;/p&gt;
&lt;p&gt;如此一来我们既验证了数据的合法性又处理了所有可能的输入情况。当然，通常我更建议你使用现有的&lt;code&gt;QDoubleValidator&lt;/code&gt;和&lt;code&gt;QRegExpValidator&lt;/code&gt;等现有的验证器，或将它们组合使用，这样更简单也更不容易出错。&lt;/p&gt;
&lt;h3 id=&quot;自动补全qcompleter&quot;&gt;自动补全——QCompleter&lt;/h3&gt;
&lt;p&gt;我们已经讲解了输入的过滤和验证，最后该讲讲补全了。&lt;/p&gt;
&lt;p&gt;可以说过滤和验证是比较常用的功能的话，那补全就没有那么常见了。或者说，通常我们不需要关心它，比如&lt;code&gt;QComboBox&lt;/code&gt;自带了QCompleter，它工作得也很好，所以我们往往忽略了它的存在。当然不只是下拉框，在&lt;code&gt;QLineEdit&lt;/code&gt;中我们也可以用它和它的派生类实现补全效果。&lt;/p&gt;
&lt;p&gt;功能：QCompleter包含了一个叫completeModel的数据模型，里面包含了用于根据输入信息进行补全的所有数据，通常是个listModel，也可以是设置了补全所用数据位于哪一列的tableModel，当然你还可以用treeModel，不过这超过了我们的讨论范围。&lt;/p&gt;
&lt;p&gt;显示效果：completer从你输入的第一个字符开始匹配，如果在completeModel中找到了以输入内容开头的信息则会在edit下把所有匹配项一次放入一个下拉框并显示，你也可以设置为将第一个匹配项的数据替换放入edit。&lt;/p&gt;
&lt;p&gt;还有一点我想额外补充一下，补全时弹出的下拉框其实是个view视图对象，因此你可以选择自己需要的视图以显示补全时想显示的自定义效果。&lt;/p&gt;
&lt;p&gt;你可以通过&lt;code&gt;completer&lt;/code&gt;和&lt;code&gt;setCompleter&lt;/code&gt;获取和设置completer。&lt;/p&gt;
&lt;p&gt;可以看到只要把我们用于补全输入的数据放入合适的model中，再把model设置给completer，就能实现补全功能了。&lt;/p&gt;
&lt;p&gt;下面看个设置completer的例子：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# model是一个QStandardItemModel，后面我们也会使用这个model来设置completer
completer = QCompleter()
model.setParent(completer)
completer.setModel(model)
edit.setCompleter(completer)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;另外completer得到的数据是经过验证的，所以我们无需关心数据的格式和合法性。&lt;/p&gt;
&lt;p&gt;现在我们已经把&lt;code&gt;QLineEdit&lt;/code&gt;的数据处理流程介绍了一遍，有了这些预备知识下面该实现&lt;code&gt;CustomDateEdit&lt;/code&gt;了。&lt;/p&gt;
&lt;h3 id=&quot;customdateedit的实现&quot;&gt;CustomDateEdit的实现&lt;/h3&gt;
&lt;p&gt;我们先来看代码，细节问题基本在注释中给出了说明：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class CustomDateEdit(QLineEdit):
    def __init__(self, parent=None):
        super().__init__(parent=parent)
        self.setInputMask(self.tr('9999年09月09日'))  # 设置日期格式的inputMask
        validator = CustomDateValidator()
        self.setValidator(validator)  # 设置validator
        # 设置completer
        self._completer = QCompleter()
        self.setCompleter(self._completer)
        self.completerModel = QStandardItemModel(parent=self._completer)
        self._completer.setModel(self.completerModel)
        # 预先填充一些待补全内容
        self.addDateRecord(&quot;2019年03月14日&quot;)
        self.addDateRecord(&quot;2019年03月15日&quot;)

    def addDateRecord(self, text: str):
        &quot;&quot;&quot;当有合法的输入被确认时就将其添加至completerModel，以便再次输入时补全
        &quot;&quot;&quot;
        if self.completerModel.findItems(text):  # 避免重复添加
            return

        item = QStandardItem(text)
        self.completerModel.appendRow(item)

    def weekDayInfo(self, weekDay: int):
        &quot;&quot;&quot;返回weekDay对应的名称，后面测试中会被使用
        &quot;&quot;&quot;
        week = {
            0: self.tr('周一'),
            1: self.tr('周二'),
            2: self.tr('周三'),
            3: self.tr('周四'),
            4: self.tr('周五'),
            5: self.tr('周六'),
            6: self.tr('周日'),
        }

        return week[weekDay]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;整个dateEdit的实现也很简单，所有复杂的逻辑都已经交给了inputMask，验证器和completer，而我们唯一要做的是为completer添加新输入的合法的数据，这在类方法&lt;code&gt;addDateRecord&lt;/code&gt;中完成了。&lt;/p&gt;
&lt;h2 id=&quot;测试customdateedit&quot;&gt;测试CustomDateEdit&lt;/h2&gt;
&lt;p&gt;实现&lt;code&gt;CustomDateEdit&lt;/code&gt;之后，我们就要动手实现引论一节中的程序了。&lt;/p&gt;
&lt;p&gt;前面已经说过，最终通过信号传递或者由槽函数获取到的值一定是通过了过滤和验证通过的值。所以想实现引论中的程序我们只需要正确处理&lt;code&gt;CustomDateEdit&lt;/code&gt;的信号即可。&lt;/p&gt;
&lt;p&gt;下面直接上测试代码：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class MainWindow(QMainWindow):
    def __init__(self, parent=None):
        super().__init__(parent=parent)
        center = QWidget()
        self.dateEdit = CustomDateEdit()
        self.info = QLabel(self.tr('所选日期是'))
        self.dateEdit.textEdited.connect(lambda: self.info.setText(self.tr('所选日期是')))
        # 输入结束后按回车触发该信号，同时只有输入数据通过过滤和验证后这个信号才会被发送
        self.dateEdit.returnPressed.connect(self.calcWeekDay)
        layout = QVBoxLayout()
        layout.addWidget(self.dateEdit)
        layout.addWidget(self.info, alignment=Qt.AlignCenter)
        center.setLayout(layout)
        self.setCentralWidget(center)

    def calcWeekDay(self):
        # 计算所选日期是周几
        t = arrow.get(self.dateEdit.text(), self.dateEdit.validator().dateFormat())
        weekDayInfo = self.dateEdit.weekDayInfo(t.weekday())
        self.info.setText(self.tr('所选日期是') + weekDayInfo)
        # 添加记录
        self.dateEdit.addDateRecord(self.dateEdit.text())


if __name__ == '__main__':
    app = QApplication(sys.argv)
    win = MainWindow()
    win.show()
    app.exec_()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当用户输入一个完整的日期后，按下回车键，程序会自动计算结果并更新到下方的label上。很简单的程序，主要就是为了测试我们的&lt;code&gt;CustomDateEdit&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1434464/201903/1434464-20190314220059428-1629311679.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;程序的行为和预想的差不多，现在你已经初步掌握所学的知识了。&lt;/p&gt;
&lt;p&gt;另外也许你会奇怪，为什么要大量使用&lt;code&gt;self.tr&lt;/code&gt;这个函数，不用担心，这只是为了以后介绍国际化时做的准备，现在忽略它也没问题。&lt;/p&gt;
&lt;p&gt;如果你发现了任何错误疏漏，或者仍有疑问，欢迎提出，共同进步！&lt;/p&gt;
</description>
<pubDate>Thu, 14 Mar 2019 14:02:00 +0000</pubDate>
<dc:creator>apocelipes</dc:creator>
<og:description>QLineEdit是使用频率最高的控件之一，当我们想获取用户输入时自然而然得会用到它。 通常我们会将QLineEdit的信号或其他控件的信号绑定至槽函数，然后获取并处理编辑器内的数据。你会觉得我们拿到</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/apocelipes/p/10533863.html</dc:identifier>
</item>
<item>
<title>iOS app启动流程 - Love margin</title>
<link>http://www.cnblogs.com/lovemargin/p/10533760.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lovemargin/p/10533760.html</guid>
<description>&lt;p&gt;最近看了些Runtime Runloop的一些知识.边看边摸索.看到群里有人在问 一些面试题.其中就提到了app的启动流程.&lt;/p&gt;
&lt;p&gt;所以这里也研究小结一下,以供自己学习备用.&lt;/p&gt;
&lt;p&gt;1.项目要运行,就要有入口. OC语言的入口就在main.m 文件.下面看main.m里都有什么可以窥探的.&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;8.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt; *&lt;span&gt; argv[]) {
    @autoreleasepool {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate &lt;span&gt;class&lt;/span&gt;&lt;span&gt;]));
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;在自动释放池里我们可以看到里面就一行代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;return&lt;/span&gt; UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate &lt;span&gt;class&lt;/span&gt;]));
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这行代码我们手打一下.可以看到传的参数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
UIApplicationMain(&amp;lt;#&lt;span&gt;int&lt;/span&gt; argc#&amp;gt;, &amp;lt;#&lt;span&gt;char&lt;/span&gt; * _Nonnull * _Null_unspecified argv#&amp;gt;, &amp;lt;#NSString * _Nullable principalClassName#&amp;gt;, &amp;lt;#NSString * _Nullable delegateClassName#&amp;gt;)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;下面我们一步步解析这句关键的代码如何启动App&lt;/p&gt;
&lt;p&gt;UIApplicationMain 就是OC的入门点. 里面传递了四个参数:&lt;/p&gt;
&lt;p&gt;argc 是一个int参数&lt;/p&gt;
&lt;p&gt;argv 是一个char 参数&lt;/p&gt;
&lt;p&gt;principalClassName 主程序类名( 当值为 nil 时，默认是UIApplication)&lt;/p&gt;
&lt;p&gt;delegateClassName 代理类名 默认就是常见的AppDelegate类&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic3.zhimg.com/80/v2-63f90688e042c4d3944a86b670eabcae_hd.png&quot; alt=&quot;&quot; width=&quot;851&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;851&quot; data-rawheight=&quot;58&quot; data-original=&quot;https://pic3.zhimg.com/v2-63f90688e042c4d3944a86b670eabcae_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-63f90688e042c4d3944a86b670eabcae_b.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在上面的传参时候用到了NSStringFromClass 方法.&lt;/p&gt;
&lt;p&gt;NSStringFromClass 是将类名转化为字符串的转化函数.与此类似的还有字符串转化类名的NSClassFromString.&lt;/p&gt;
&lt;p&gt;2.设定了对象和代理之后就是NSRunloop 来保持程序一直运行处理事件(详情请看上一篇说的runloop文章)&lt;/p&gt;
&lt;p&gt;3.接下来就是info.plist文件.检查是否通过main.storyboard加载指定的控制器. 把新创建的控制器作为窗口的跟控制器，让窗口显示出来.如果没有则会在下面方法中创建UIWindow 来作为主窗口&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *&lt;span&gt;)launchOptions {

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建UIWindow 来作为主窗口&lt;/span&gt;

&lt;span&gt;return&lt;/span&gt;&lt;span&gt; YES;

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;4.最后通过执行程序AppDelegate的代理.程序完成启动&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic3.zhimg.com/80/v2-d855c1c6e2c7b6639a1e4d80a6fbdd7a_hd.jpg&quot; alt=&quot;&quot; width=&quot;1036&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1036&quot; data-rawheight=&quot;743&quot; data-original=&quot;https://pic3.zhimg.com/v2-d855c1c6e2c7b6639a1e4d80a6fbdd7a_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-d855c1c6e2c7b6639a1e4d80a6fbdd7a_b.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 14 Mar 2019 13:50:00 +0000</pubDate>
<dc:creator>Love margin</dc:creator>
<og:description>最近看了些Runtime Runloop的一些知识.边看边摸索.看到群里有人在问 一些面试题.其中就提到了app的启动流程. 所以这里也研究小结一下,以供自己学习备用. 1.项目要运行,就要有入口.</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lovemargin/p/10533760.html</dc:identifier>
</item>
<item>
<title>【动态规划】01背包问题 - 弗兰克的猫</title>
<link>http://www.cnblogs.com/mfrank/p/10533701.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mfrank/p/10533701.html</guid>
<description>&lt;h2 id=&quot;说明&quot;&gt;说明&lt;/h2&gt;
&lt;p&gt;前面用&lt;code&gt;动态规划&lt;/code&gt;解决了正则表达式的问题，感觉还是不过瘾，总觉得对于&lt;code&gt;动态规划&lt;/code&gt;的理解还没有到位，所以趁热打铁，继续研究几个&lt;code&gt;动态规划&lt;/code&gt;的经典问题，希望能够借此加深对&lt;code&gt;动态规划&lt;/code&gt;的理解。在此之前，还需要说两个跟动态规划有关的理论知识。&lt;/p&gt;
&lt;h2 id=&quot;最优化原理&quot;&gt;最优化原理&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;最优化原理&lt;/code&gt;指的最优策略具有这样的性质：不论过去状态和决策如何，对前面的决策所形成的状态而言，余下的诸决策必须构成最优策略。简单来说就是一个最优策略的子策略也是必须是最优的，而所有子问题的局部最优解将导致整个问题的全局最优。如果一个问题能满足&lt;code&gt;最优化原理&lt;/code&gt;，就称其具有&lt;code&gt;最优子结构性质&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这是判断问题能否使用动态规划解决的先决条件，如果一个问题不能满足最优化原理，那么这个问题就不适合用动态规划来求解。&lt;/p&gt;
&lt;p&gt;这样说可能比较模糊，来举个栗子吧：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/03/14/5c8a1e400a1c1.jpeg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图，&lt;em&gt;求从A点到E点的最短距离&lt;/em&gt;，那么子问题就是&lt;em&gt;求从A点到E点之间的中间点到E点的最短距离，比如这里的B点&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;那么这个问题里，怎么证明最优化原理呢？&lt;/p&gt;
&lt;p&gt;我们假设从A点到E点的最短距离为d，其最优策略的子策略假设经过B点，记该策略中B点到E点的距离为&lt;code&gt;d1&lt;/code&gt;，A点到B点的距离为&lt;code&gt;d2&lt;/code&gt;。我们可以使用反证法，假设存在B点到E点的最短距离&lt;code&gt;d3&lt;/code&gt;，并且&lt;code&gt;d3 &amp;lt; d1&lt;/code&gt;，那么 &lt;code&gt;d3 + d2 &amp;lt; d1 + d2 = d&lt;/code&gt;，这与d是最短距离相矛盾，所以，&lt;code&gt;d1&lt;/code&gt;是B点到E点的最短距离。&lt;/p&gt;
&lt;p&gt;为了增加理解，这里再举一个反例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/03/14/5c8a3c4e20747.jpeg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图中有四个点，A、B、C、D，相邻两点有两条连线，代表两条通道，d1,d2,d3,d4,d5,d6代表的是道路的长度，求A到D的所有通道中，总长度除以4得到的余数最小的路径为&lt;em&gt;最优路径&lt;/em&gt;，求一条&lt;em&gt;最优路径&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;这里如果还是按照上面的思路去求解，就会误入歧途了。按照之前的思路，A的最优取值应该可以由B的最优取值来确定，而B的最优取值为（3+5）mod 4 = 0。所以应该选&lt;code&gt;d2&lt;/code&gt;和&lt;code&gt;d6&lt;/code&gt;这两条道路，而实际上，全局最优解是&lt;code&gt;d4+d5+d6&lt;/code&gt;或者&lt;code&gt;d1+d5+d3&lt;/code&gt;。所以这里子问题的最优解并不是原问题的最优解，即不满足最优化原理。所以就不适合使用动态规划来求解了。&lt;/p&gt;
&lt;h2 id=&quot;无后效性&quot;&gt;无后效性&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;无后效性&lt;/code&gt;指的是某状态下决策的收益，只与状态和决策相关，与到达该状态的方式无关。某个阶段的状态一旦确定，则此后过程的演变不再受此前各种状态及决策的影响。换句话说，未来与过去无关，当前状态是此前历史状态的完整总结，此前历史决策只能通过影响当前的状态来影响未来的演变。再换句话说，过去做的选择不会影响现在能做的最优选择，现在能做的最优选择只与当前的状态有关，与经过如何复杂的决策到达该状态的方式无关。&lt;/p&gt;
&lt;p&gt;这也是用来验证问题是否可以使用动态规划来解答的重要方法。&lt;/p&gt;
&lt;p&gt;我们再回头看看上面的最短路径问题，如果在原来的基础上加上一个限制条件：&lt;em&gt;同一个格子只能通过一次&lt;/em&gt;。那么， 这个题就不符合无后效性了，因为前一个子问题的解会对后面子问题的选择策略有影响，比如说，如果从A到B选择了一条如下图中绿色表示的路线，那么从B点出发到达E点的路线就只有一条了。也就是说从A点到B点的路径选择会影响B点到E点的路径选择。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/03/14/5c8a47085f922.jpeg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;理论部分就此打住，接下来我们实战一下。&lt;/p&gt;
&lt;h2 id=&quot;背包问题&quot;&gt;01背包问题&lt;/h2&gt;
&lt;p&gt;假设你是一名经验丰富的探险家，背着背包来到野外进行日常探险。天气晴朗而不燥热，山间的风夹杂着花香，正当你欣赏这世外桃源般的美景时，突然，你发现了一个洞穴，这个洞穴外表看起来其貌不扬，但凭借着惊为天人的直觉，这个洞穴不简单。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/03/14/5c8a47d0de9a6.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;于是，你开始往洞穴内探索，希望能发现一些有意思的东西。终于，皇天不负有心人，你在洞穴的尽头，发现了一堆不世出的珠宝，凭借你惊人的阅历，一眼便看出了它们各自的价值，心想着下下下下下下下下半辈子都有着落了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/03/14/5c8a564a63265.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然而，天有不测风云，正准备将它们收入囊中，却不小心触碰到一个防御机关，洞穴马上就要崩塌了。在此危机时刻，你只有一个背包，你必须尽快做出抉择，从中选择最值钱的珠宝塞到你的背包，让背包中珠宝的总价值最大。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/03/14/5c8a56572a8c0.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;好了好了，啰里啰嗦了大半天，我还是来精简一下问题吧。简而言之，你只有一个容量有限的背包，总容量为c，有n个可待选择的物品，每个物品只有一件，它们都有各自的重量和价值，你需要从中选择合适的组合来使得你背包中的物品总价值最大。&lt;/p&gt;
&lt;h2 id=&quot;问题分析&quot;&gt;问题分析&lt;/h2&gt;
&lt;p&gt;那还不简单，不管是什么，先往背包里塞，塞满赶紧走，狗命要紧，狗命要紧。。。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/03/10/5c8515f07c869.png&quot; alt=&quot;20190310214935.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;好了好了，开个玩笑，言归正传。&lt;/p&gt;
&lt;p&gt;简单起见，我们来将上面的问题具体化，举一个更具体的栗子：&lt;/p&gt;
&lt;p&gt;假设有5个物品，它们的价值(v)和重量(w)如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/03/10/5c851ee47f9c2.jpeg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;背包总容量为10，现在要从中选择物品装入背包中，要求物品的重量不能超过背包的容量，并且最后放在背包中物品的总价值最大。&lt;/p&gt;
&lt;p&gt;emmm，等等，为什么叫做&lt;code&gt;0/1背包&lt;/code&gt;呢？为什么不叫&lt;code&gt;1/2背包&lt;/code&gt;，&lt;code&gt;2/3背包&lt;/code&gt;？？？&lt;/p&gt;
&lt;p&gt;仔细想想，这里每个物品只有一个，对于每个物品而言，只有两种选择，盘它或者不盘，盘它记为1，不盘记为0，我们不能将物品进行分割，比如只拿半个是不允许的。这就是这个问题被称为&lt;code&gt;0/1背包&lt;/code&gt;问题的原因。&lt;/p&gt;
&lt;p&gt;所以究竟选还是不选，这是个问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/03/14/5c8a56a150bc1.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;让我们先来体验一下将珠宝装入背包的感觉，为了方便起见，用&lt;code&gt;xi&lt;/code&gt;代表第i个珠宝的选择（&lt;code&gt;xi = 1&lt;/code&gt; 代表选择该珠宝，0则代表不选），&lt;code&gt;vi&lt;/code&gt;代表第i个珠宝的价值，&lt;code&gt;wi&lt;/code&gt;代表第i个珠宝的重量。于是我们就有了这样的限制条件：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/03/10/5c851ebfd4687.jpeg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们的初始状态是背包容量为10，背包内物品总价值为0，接下来，我们就要开始做选择了。对于1号珠宝，当前容量为10，容纳它的重量2绰绰有余，因此有两种选择，选它或者不选。我们选择一个珠宝的时候，背包的容量会减少，但是里面的物品总价值会增加。就像下面这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/03/10/5c851f2254a64.jpeg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样就分出了两种情况，我们继续进行选择，如果我们选择了珠宝1，那么对于珠宝2，当前剩余容量为8，大于珠宝2的容量3，因此也有两种选择，选或者不选。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/03/10/5c8524cc69459.jpeg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在，我们得到了四个可能结果，我们每做出一个选择，就会将上面的每一种可能分裂成两种可能，后续的选择也是如此，最终，我们会得到如下的一张决策图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/03/10/5c85286b617f4.jpeg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里被涂上色的方框代表我们的最终待选结果，本来应该有16个待选结果，但有三个结果由于容量不足以容纳下最后一个珠宝，所以就没有继续进行裂变。&lt;/p&gt;
&lt;p&gt;然后，我们从这些结果中，找出价值最大的那个，也就是&lt;code&gt;13&lt;/code&gt;，这就是我们的最优选择，根据这个选择，依次找到它的所有路径，便可以知道该选哪几个珠宝，最终结果是：珠宝4，珠宝2，珠宝1。&lt;/p&gt;
&lt;h2 id=&quot;分治法&quot;&gt;分治法&lt;/h2&gt;
&lt;p&gt;接下来，我们就来分析一下，如何将它扩展到一般情况。为了实现这个目的，我们需要将问题进行抽象并建模，然后将其划分为更小的子问题，找出递推关系式，这是分治思想中很重要的一步。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;抽象问题，背包问题抽象为寻找组合（x1,x2,x3...xn，其中xi取0或1，表示第i个物品取或者不取），vi代表第i个物品的价值，wi代表第i个物品的重量，总物品数为n，背包容量为c。&lt;/li&gt;
&lt;li&gt;建模，问题即求max(x1v1 + x2v2 + x3v3 + ... + xnvn)。&lt;/li&gt;
&lt;li&gt;约束条件，x1w1 + x2w2 + x3w3 + ... + xnwn &amp;lt; c&lt;/li&gt;
&lt;li&gt;定义函数KS(i,j)：代表当前背包剩余容量为j时，前i个物品最佳组合所对应的价值；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;那这里的递推关系式是怎样的呢？对于第i个物品，有两种可能：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;背包剩余容量不足以容纳该物品，此时背包的价值与前i-1个物品的价值是一样的，KS(i,j) = KS(i-1,j)&lt;/li&gt;
&lt;li&gt;背包剩余容量可以装下该商品，此时需要进行判断，因为装了该商品不一定能使最终组合达到最大价值，如果不装该商品，则价值为：KS(i-1,j)，如果装了该商品，则价值为KS(i-1,j-wi) + vi，从两者中选择较大的那个，所以就得出了递推关系式：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/03/12/5c87b64eb1a66.jpeg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对于这个问题的子问题，这里有必要详细说明一下。原问题是，将n件物品放入容量为c的背包，子问题则是，将前i件物品放入容量为j的背包，所得到的最优价值为KS(i,j)，如果只考虑第i件物品放还是不放，那么就可以转化为一个只涉及到前i-1个物品的问题。如果不放第i个物品，那么问题就转化为“前i-1件物品放入容量为j的背包中的最优价值组合”，对应的值为KS(i-1,j)。如果放第i个物品，那么问题就转化成了“前i-1件物品放入容量为j-wi的背包中的最优价值组合”，此时对应的值为KS(i-1,j-wi)+vi。&lt;/p&gt;
&lt;p&gt;所以，就可以很容易的写出递归解法了：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Solution{
    int[] vs = {0,2,4,3,7};
    int[] ws = {0,2,3,5,5};

    @Test
    public void testKnapsack1() {
        int result = ks(4,10);
        System.out.println(result);
    }

    private int ks(int i, int c){
        int result = 0;
        if (i == 0 || c == 0){
            // 初始条件
            result = 0;
        } else if(ws[i] &amp;gt; c){
            // 装不下该珠宝
            result = ks(i-1, c);
        } else {
            // 可以装下
            int tmp1 = ks(i-1, c);
            int tmp2 = ks(i-1, c-ws[i]) + vs[i];
            result = Math.max(tmp1, tmp2);
        }
        return result;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里为了方便处理，将数组ws和vs都增加了一个补位数0，防止数组越界，输出结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;13&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样，我们就轻松加愉快的解决了这个问题。&lt;/p&gt;
&lt;h2 id=&quot;动态规划解法&quot;&gt;动态规划解法&lt;/h2&gt;
&lt;h3 id=&quot;验证可行性&quot;&gt;验证可行性&lt;/h3&gt;
&lt;p&gt;既然开头已经说了两个验证问题是否可以使用动态规划求解的方法，那么为何不试一试呢？&lt;/p&gt;
&lt;p&gt;先来看看&lt;code&gt;最优化原理&lt;/code&gt;。同样，我们使用反证法：&lt;/p&gt;
&lt;p&gt;假设(x1，x2，…，xn)是01背包问题的最优解，则有(x2，x3，…，xn)是其子问题的最优解，假设(y2，y3，…，yn)是上述问题的子问题最优解，则有(v2y2+v3y3+…+vnyn)+v1x1 &amp;gt; (v2x2+v3x3+…+vnxn)+v1x1。说明(X1，Y2，Y3，…，Yn)才是该01背包问题的最优解，这与最开始的假设(X1，X2，…，Xn)是01背包问题的最优解相矛盾，故01背包问题满足&lt;code&gt;最优性原理&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/03/14/5c8a5766a30bc.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至于&lt;code&gt;无后效性&lt;/code&gt;，其实比较好理解。对于任意一个阶段，只要背包剩余容量和可选物品是一样的，那么我们能做出的现阶段的最优选择必定是一样的，是不受之前选择了什么物品所影响的。即满足&lt;code&gt;无后效性&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;自上而下记忆法&quot;&gt;自上而下记忆法&lt;/h3&gt;
&lt;p&gt;就像上一篇里的解法一样，自上而下的解法与分治法的区别就是增加了一个数组用来存储计算的中间结果来减少重复计算。这里，我们只需要多定义一个二维数组。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/03/12/5c87c27322752.jpeg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;表格中，每一个格子都代表着一个子问题，我们最终的问题是求最右下角的格子的值，也就是&lt;code&gt;i=4,j=10&lt;/code&gt;时的值。这里，我们的初始条件便是i=0或者j=0时对应的ks值为0，这很好理解，如果可选物品为0，或者剩余容量为0，那么最大价值自然也是0。代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Solution{
    int[] vs = {0,2,4,3,7};
    int[] ws = {0,2,3,5,5};
    Integer[][] results = new Integer[5][11];

    @Test
    public void testKnapsack2() {
        int result = ks2(4,10);
        System.out.println(result);
    }

    private int ks2(int i, int c){
        int result = 0;
        // 如果该结果已经被计算，那么直接返回
        if (results[i][c] != null) return results[i][c];
        if (i == 0 || c == 0){
            // 初始条件
            result = 0;
        } else if(ws[i] &amp;gt; c){
            // 装不下该珠宝
            result = ks(i-1, c);
        } else {
            // 可以装下
            int tmp1 = ks(i-1, c);
            int tmp2 = ks(i-1, c-ws[i]) + vs[i];
            result = Math.max(tmp1, tmp2);
            results[i][c] = result;
        }
        return result;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，其实只比分治多了三行代码。&lt;/p&gt;
&lt;h3 id=&quot;自下而上填表法&quot;&gt;自下而上填表法&lt;/h3&gt;
&lt;p&gt;接下来，我们用自下而上的方法来解一下这道题，思路很简单，就是不断的填表，回想一下上一篇中的斐波拉契数列的自下而上解法，这里将使用同样的方式来解决。还是使用上面的表格，我们开始一行行填表。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/03/12/5c87c45b5d9bf.jpeg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当i=1时，即只有珠宝1可供选择，那么如果容量足够的话，最大价值自然就是珠宝1的价值了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/03/12/5c87c4c11104c.jpeg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当i=2时，有两个物品可供选择，此时应用上面的递推关系式进行判断即可。这里以i=2,j=3为例进行分析：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/03/12/5c87c673e6c36.jpeg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;剩下的格子使用相同的方法进行填充即可：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/03/12/5c87c75ba58ce.jpeg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样，我们就得到了最后的结果：13。根据结果，我们可以反向找出各个物品的选择，寻找的方法很简单，就是从&lt;code&gt;i=4,j=10&lt;/code&gt;开始寻找，如果&lt;code&gt;ks(i-1,j)=ks(i,j)&lt;/code&gt;，说明第i个物品没有被选中，从&lt;code&gt;ks(i-1,j)&lt;/code&gt;继续寻找。否则，表示第i个物品已被选中，则从&lt;code&gt;ks(i-1,j-wi)&lt;/code&gt;开始寻找。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/03/12/5c87c9244d3c9.jpeg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;转化成代码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Solution{
    int[] vs = {0,2,4,3,7};
    int[] ws = {0,2,3,5,5};
    Integer[][] results = new Integer[5][11];
    
    @Test
    public void testKnapsack3() {
        int result = ks3(4,10);
        System.out.println(result);
    }

    private int ks3(int i, int j){
        // 初始化
        for (int m = 0; m &amp;lt;= i; m++){
            results[m][0] = 0;
        }
        for (int m = 0; m &amp;lt;= j; m++){
            results[0][m] = 0;
        }
        // 开始填表
        for (int m = 1; m &amp;lt;= i; m++){
            for (int n = 1; n &amp;lt;= j; n++){
                if (n &amp;lt; ws[m]){
                    // 装不进去
                    results[m][n] = results[m-1][n];
                } else {
                    // 容量足够
                    if (results[m-1][n] &amp;gt; results[m-1][n-ws[m]] + vs[m]){
                        // 不装该珠宝，最优价值更大
                        results[m][n] = results[m-1][n];
                    } else {
                        results[m][n] = results[m-1][n-ws[m]] + vs[m];
                    }
                }
            }
        }
        return results[i][j];
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;嗯，完美解决。时间复杂度即填表耗时&lt;code&gt;O(n * c)&lt;/code&gt;，这里用了一个二维数组来存储子问题的解，所以空间复杂度为&lt;code&gt;O(n * c)&lt;/code&gt;;&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;回过头再看看上面的分析，会发现动态规划里最关键的问题其实是寻找原问题的子问题，并写出递推表达式，只要完成了这一步，代码部分都是水到渠成的事情了。&lt;/p&gt;
&lt;p&gt;那么问题来了，怎样把问题拆分成子问题呢？&lt;/p&gt;
&lt;p&gt;emmm，这个问题有点超纲了，说实话，我也没有掌握到诀窍，还是得具体情况具体分析，但是很多经典的问题都有其经典的套路，其它问题都可以归结到这些问题上面来，可以看做是它们的变种和延伸，把这些经典的问题吃透的话，自然能举一反三。比如采药问题，本质上就是01背包问题，而硬币问题，本质上就是我们之后要介绍的完全背包问题。&lt;/p&gt;
&lt;p&gt;个人认为，算法不在于刷多少个，而在于归纳总结，就跟做数学题一样，总有一些范式和套路，不管形式如何变化，其本质是一样的，万变不离其宗，说的就是这么回事。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/03/14/5c8a580b1789e.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;本篇到此就告一段落了，如果觉得有收获，不要吝啬你的赞哦，也欢迎关注我的公众号留言交流。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/03/14/5c8a58ba229ca.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 14 Mar 2019 13:40:00 +0000</pubDate>
<dc:creator>弗兰克的猫</dc:creator>
<og:description>说明 前面用 解决了正则表达式的问题，感觉还是不过瘾，总觉得对于 的理解还没有到位，所以趁热打铁，继续研究几个 的经典问题，希望能够借此加深对 的理解。在此之前，还需要说两个跟动态规划有关的理论知识。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mfrank/p/10533701.html</dc:identifier>
</item>
<item>
<title>Mysql数据类型TINYINT(1)与BOOLEAN踩坑记 - LinkLee</title>
<link>http://www.cnblogs.com/sunlightlee/p/10533466.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sunlightlee/p/10533466.html</guid>
<description>&lt;p&gt;&lt;span&gt;　　熟悉Mysql的同学应该都知道，Mysql查询的boolean结果将输出为0或者1.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　比如：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;select&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　其输出结果为1。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　查阅mysql官方文档仅找到如下描述：&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7.4764084507042&quot;&gt;
&lt;div class=&quot;section&quot; readability=&quot;18.471126760563&quot;&gt;
&lt;div class=&quot;titlepage&quot; readability=&quot;31&quot;&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;
&lt;h2 class=&quot;title&quot;&gt;&lt;span&gt;11.10 Using Data Types from Other Database Engines&lt;/span&gt;&lt;/h2&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;To facilitate the use of code written for SQL implementations from other vendors, MySQL maps data types as shown in the following table. These mappings make it easier to import table definitions from other database systems into MySQL.&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;informaltable&quot;&gt;
&lt;table cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;thead&gt;&lt;tr&gt;&lt;th scope=&quot;col&quot;&gt;&lt;span&gt;Other Vendor Type&lt;/span&gt;&lt;/th&gt;
&lt;th scope=&quot;col&quot;&gt;&lt;span&gt;MySQL Type&lt;/span&gt;&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;Data type mapping occurs at table creation time, after which the original type specifications are discarded. If you create a table with types used by other vendors and then issue a &lt;code class=&quot;literal&quot;&gt;DESCRIBE &lt;em class=&quot;replaceable&quot;&gt;&lt;code&gt;tbl_name&lt;/code&gt;&lt;/em&gt;&lt;/code&gt; statement, MySQL reports the table structure using the equivalent MySQL types. For example:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;copytoclipboard-wrapper&quot; readability=&quot;15&quot;&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;programlisting line-numbers language-sql&quot;&gt;
&lt;span&gt;&lt;code class=&quot; language-sql&quot;&gt;&lt;span class=&quot;token prompt&quot;&gt;mysql&amp;gt; &lt;span class=&quot;token keyword&quot;&gt;CREATE &lt;span class=&quot;token keyword&quot;&gt;TABLE t &lt;span class=&quot;token punctuation&quot;&gt;(a &lt;span class=&quot;token datatype&quot;&gt;BOOL&lt;span class=&quot;token punctuation&quot;&gt;, b &lt;span class=&quot;token keyword&quot;&gt;FLOAT8&lt;span class=&quot;token punctuation&quot;&gt;, c &lt;span class=&quot;token keyword&quot;&gt;LONG &lt;span class=&quot;token datatype&quot;&gt;VARCHAR&lt;span class=&quot;token punctuation&quot;&gt;, d &lt;span class=&quot;token datatype&quot;&gt;NUMERIC&lt;span class=&quot;token punctuation&quot;&gt;)&lt;span class=&quot;token punctuation&quot;&gt;;
&lt;span class=&quot;token output&quot;&gt;Query OK, 0 rows affected (0.00 sec)

&lt;span class=&quot;token prompt&quot;&gt;mysql&amp;gt; &lt;span class=&quot;token keyword&quot;&gt;DESCRIBE t&lt;span class=&quot;token punctuation&quot;&gt;;
&lt;span class=&quot;token output&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;+&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;+&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;+&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;+&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;+&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;+&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;+
&lt;span class=&quot;token output&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;| Field &lt;span class=&quot;token punctuation&quot;&gt;| Type          &lt;span class=&quot;token punctuation&quot;&gt;| Null &lt;span class=&quot;token punctuation&quot;&gt;| Key &lt;span class=&quot;token punctuation&quot;&gt;| Default &lt;span class=&quot;token punctuation&quot;&gt;| Extra &lt;span class=&quot;token punctuation&quot;&gt;|
&lt;span class=&quot;token output&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;+&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;+&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;+&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;+&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;+&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;+&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;+
&lt;span class=&quot;token output&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;| a     &lt;span class=&quot;token punctuation&quot;&gt;| tinyint(1)    &lt;span class=&quot;token punctuation&quot;&gt;| YES  &lt;span class=&quot;token punctuation&quot;&gt;|     &lt;span class=&quot;token punctuation&quot;&gt;| NULL    &lt;span class=&quot;token punctuation&quot;&gt;|       &lt;span class=&quot;token punctuation&quot;&gt;|
&lt;span class=&quot;token output&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;| b     &lt;span class=&quot;token punctuation&quot;&gt;| double        &lt;span class=&quot;token punctuation&quot;&gt;| YES  &lt;span class=&quot;token punctuation&quot;&gt;|     &lt;span class=&quot;token punctuation&quot;&gt;| NULL    &lt;span class=&quot;token punctuation&quot;&gt;|       &lt;span class=&quot;token punctuation&quot;&gt;|
&lt;span class=&quot;token output&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;| c     &lt;span class=&quot;token punctuation&quot;&gt;| mediumtext    &lt;span class=&quot;token punctuation&quot;&gt;| YES  &lt;span class=&quot;token punctuation&quot;&gt;|     &lt;span class=&quot;token punctuation&quot;&gt;| NULL    &lt;span class=&quot;token punctuation&quot;&gt;|       &lt;span class=&quot;token punctuation&quot;&gt;|
&lt;span class=&quot;token output&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;| d     &lt;span class=&quot;token punctuation&quot;&gt;| decimal(10,0) &lt;span class=&quot;token punctuation&quot;&gt;| YES  &lt;span class=&quot;token punctuation&quot;&gt;|     &lt;span class=&quot;token punctuation&quot;&gt;| NULL    &lt;span class=&quot;token punctuation&quot;&gt;|       &lt;span class=&quot;token punctuation&quot;&gt;|
&lt;span class=&quot;token output&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;+&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;+&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;+&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;+&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;+&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;+&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;-&lt;span class=&quot;token punctuation&quot;&gt;+
&lt;span class=&quot;token output&quot;&gt;4 rows in set (0.01 sec)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;　　我想说的是，今天使用一套中间件对kafka消息进行解析为mysql 语句，其中遇到如下的问题，&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;目标表有一字段设置类型为：tinyint(1)。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;源表同步消息中接收到相同类型的数据。&lt;/span&gt;&lt;/li&gt;
&lt;li readability=&quot;8&quot;&gt;&lt;span&gt;其中中间件中有如下解析部分：&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setStatement(PreparedStatement statement, DatabaseType databaseType, &lt;span&gt;boolean&lt;/span&gt; timestampChangeToLong) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; SQLException {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.value == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            statement.setNull(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.index, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.sqlType);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.sqlType) {
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; -15&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; -9&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; 1&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; 12&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; 2005&lt;span&gt;:
                String strVal &lt;/span&gt;= String.valueOf(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.value);
                statement.setString(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.index, strVal);
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; -7&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; 16&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; booleanVal = (Boolean)&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.value; &lt;span&gt;//tinyint(1) 类型的表设计字段直接进入该case,由于接收到的消息中的数据未0或者1，直接在该未知报类转换异常。&lt;/span&gt;
                statement.setBoolean(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.index, booleanVal);
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; -6&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; val2 = (Integer)&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.value;
                statement.setInt(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.index, val2);
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; -5&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; longVal = (Long)&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.value;
                statement.setLong(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.index, longVal);
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; 2&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.setStatementDataTypeNumeric(statement);
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; 3&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.setStatementDataTypeDecimal(statement, databaseType, timestampChangeToLong);
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; 4&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; val = (Integer)&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.value;
                statement.setInt(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.index, val);
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; 5&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; val1 = (Integer)&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.value;
                statement.setInt(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.index, val1);
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; 6&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;float&lt;/span&gt; floatVal = (Float)&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.value;
                statement.setFloat(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.index, floatVal);
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; 8&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; doubelVal = (Double)&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.value;
                statement.setDouble(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.index, doubelVal);
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; 91&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.setStatementDataTypeDate(statement, databaseType);
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; 92&lt;span&gt;:
                Date timeVal &lt;/span&gt;= (Date)&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.value;
                Time sqlTime &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Time(timeVal.getTime());
                statement.setTime(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.index, sqlTime);
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; 93&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.setStatementDataTypeTimestamp(statement, timestampChangeToLong);
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ConsumeException(&quot;sqlType &quot; + &lt;span&gt;this&lt;/span&gt;.sqlType + &quot; is not support&quot;&lt;span&gt;);
            }

        }
    }&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;&lt;span&gt;怎样获取的数字类型呢，代码如下：&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;span&gt; Database loadInternal(String database) {
        Connection connection &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

        Database var28;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            connection &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.dataSource.getConnection();&lt;span&gt;//获取连接&lt;/span&gt;
            DatabaseMetaData metaData &lt;/span&gt;=&lt;span&gt; connection.getMetaData();&lt;span&gt;//获取元数据&lt;/span&gt;
            String catalog &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            String[] tableTypes &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; String[]{&quot;TABLE&quot;&lt;span&gt;};
            String databasePattern &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;.databaseSchema != &lt;span&gt;null&lt;/span&gt; ? &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.databaseSchema : database;
            ResultSet tablesResultSet &lt;/span&gt;= metaData.getTables((String)catalog, databasePattern, &quot;%&quot;&lt;span&gt;, tableTypes);
            Database db &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Database();
            db.setName(database);

            Table tablei;
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt;(tablesResultSet.next()) {
                String tableName &lt;/span&gt;= tablesResultSet.getString(&quot;TABLE_NAME&quot;&lt;span&gt;);
                tablei &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Table(tableName);
                db.addTable(tablei);
            }

            Iterator var27 &lt;/span&gt;=&lt;span&gt; db.getTables().iterator();

            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt;(var27.hasNext()) {
                tablei &lt;/span&gt;=&lt;span&gt; (Table)var27.next();
                ResultSet columnsResultSet &lt;/span&gt;= metaData.getColumns((String)catalog, databasePattern, tablei.getName(), (String)&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);

                &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt;(columnsResultSet.next()) {
                    String columnName &lt;/span&gt;= columnsResultSet.getString(&quot;COLUMN_NAME&quot;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; sqlType = columnsResultSet.getInt(&quot;DATA_TYPE&quot;&lt;span&gt;)&lt;span&gt;;//此处拿到mysql返回的字段类型&lt;/span&gt;
                    String typeName &lt;/span&gt;= columnsResultSet.getString(&quot;TYPE_NAME&quot;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; size = columnsResultSet.getInt(&quot;COLUMN_SIZE&quot;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; nullable = 1 == columnsResultSet.getInt(&quot;NULLABLE&quot;&lt;span&gt;);
                    Column column &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Column();
                    column.setName(columnName);
                    column.setNullable(nullable);
                    column.setSqlType(sqlType);
                    column.setTypeName(typeName);
                    column.setSize(size);
                    tablei.addColumn(column);
                }
            }

            var28 &lt;/span&gt;=&lt;span&gt; db;
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception var25) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RuntimeException(&quot;load schema exception&quot;&lt;span&gt;, var25);
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (connection != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    connection.close();
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (SQLException var24) {
                    ;
                }
            }

        }

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; var28;
    }&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;&lt;span&gt;也就是说，字段tinyint(1)被当做boolean类型进行了返回。导致java中Integer类型无法进行强转。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;　　解决方法：alter talbe change `xxx` `xxx` tinyint(4) ...;即可。修改tinyint数据类型长度，mysql也就不再当做boolean类型进行返回了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　总结：Mysql表结构设计时，要避免设计为tinyint(1)这种类型，以免与boolean类型数据结构进行混淆。引起不必要bug。当然也可以总java代码中进行修改，修改后的影响，还需另外评估。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 14 Mar 2019 13:03:00 +0000</pubDate>
<dc:creator>LinkLee</dc:creator>
<og:description>熟悉Mysql的同学应该都知道，Mysql查询的boolean结果将输出为0或者1. 比如： 其输出结果为1。 查阅mysql官方文档仅找到如下描述： 11.10 Using Data Ty</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sunlightlee/p/10533466.html</dc:identifier>
</item>
</channel>
</rss>