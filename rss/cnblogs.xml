<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>kubernetes调度之污点(taint)和容忍(toleration) - 周国通</title>
<link>http://www.cnblogs.com/tylerzhou/p/11026364.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tylerzhou/p/11026364.html</guid>
<description>&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/tylerzhou/p/10969041.html&quot;&gt;系列目录&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;节点亲和性(affinity),是节点的一种属性,让符合条件的pod亲附于它(倾向于或者硬性要求).污点是一种相反的行为,它会使pod抗拒此节点(即pod调度的时候不被调度到此节点)&lt;/p&gt;
&lt;p&gt;污点和容易结合在一起以确保pod不会被调度到不适合的节点上.当一个或者多个污点添加到某个节点上,则意味着此节点不会接受任何不容忍这些污点的pod.&lt;code&gt;Tolerations&lt;/code&gt;作用于pod上,允许(但不是必须)pod被调度到有符合的污点(taint)的节点上&lt;/p&gt;
&lt;h2 id=&quot;概念&quot;&gt;概念&lt;/h2&gt;
&lt;p&gt;可以使用&lt;code&gt;kubectl taint&lt;/code&gt;为一个节点(node)添加污点(taint),例如:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;kubectl taint nodes node1 key=value:NoSchedule&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样就把键为&lt;code&gt;key&lt;/code&gt;,值为&lt;code&gt;value&lt;/code&gt;,效果为&lt;code&gt;NoSchedule&lt;/code&gt;的污点添加到了节点&lt;code&gt;node1&lt;/code&gt;上.这样除非pod有符合的容忍(toleration),否则不会被调度到此节点上&lt;/p&gt;
&lt;p&gt;可以通过以下命令删除刚添加的&lt;code&gt;taint&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;kubectl taint nodes node1 key:NoSchedule-&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你可以在创建pod的yml里指定一个关于&lt;code&gt;toleration&lt;/code&gt;的PodSpec,以下两个&lt;code&gt;容忍&lt;/code&gt;都会匹配前面创建的&lt;code&gt;taint&lt;/code&gt;,因此它们中的任意一个创建的pod都会被调度到节点&lt;code&gt;node1&lt;/code&gt;上&lt;/p&gt;
&lt;pre class=&quot;yml&quot;&gt;
&lt;code&gt;tolerations:
- key: &quot;key&quot;
  operator: &quot;Equal&quot;
  value: &quot;value&quot;
  effect: &quot;NoSchedule&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;tolerations:
- key: &quot;key&quot;
  operator: &quot;Exists&quot;
  effect: &quot;NoSchedule&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;只有pod的&lt;code&gt;key&lt;/code&gt;和&lt;code&gt;effect&lt;/code&gt;都和某一个污点的key与effect匹配,才被认为是匹配,并且要符合以下情形:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;operator&lt;/code&gt;是&lt;code&gt;Exists&lt;/code&gt;(这种情况下value不应当指定)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;operator&lt;/code&gt;是 &lt;code&gt;Equal&lt;/code&gt; 并且&lt;code&gt;value&lt;/code&gt;相同&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果&lt;code&gt;operator&lt;/code&gt;没有指定,则默认是&lt;code&gt;Equal&lt;/code&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;以下两种情况为特殊情况:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;1) 如果&lt;code&gt;key&lt;/code&gt;是空(是指key没有指定,而不是指key为空字符串),&lt;code&gt;operator&lt;/code&gt;为&lt;code&gt;Exists&lt;/code&gt;则匹配所有的&lt;code&gt;key&lt;/code&gt;,&lt;code&gt;value&lt;/code&gt;和&lt;code&gt;effect&lt;/code&gt;,也即匹配任何node,&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;tolerations:
- operator: &quot;Exists&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;2) 空的&lt;code&gt;effect&lt;/code&gt;匹配所有&lt;code&gt;effect&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;tolerations:
- key: &quot;key&quot;
  operator: &quot;Exists&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上会匹配所有&lt;code&gt;key&lt;/code&gt;为key的所有taint节点&lt;/p&gt;
&lt;p&gt;前面的示例中使用了&lt;code&gt;NoSchedule&lt;/code&gt;类型的&lt;code&gt;effect&lt;/code&gt;.此外,也可以使用&lt;code&gt;PreferNoSchedule&lt;/code&gt;类型的&lt;code&gt;effect&lt;/code&gt;,这是一个&lt;code&gt;优先选择&lt;/code&gt;或者&lt;code&gt;软性&lt;/code&gt;版本的&lt;code&gt;NoSchedule&lt;/code&gt;,调度系统会尽量避免调度不容忍这种污点的pod到带有此污点的节点上,但是并不是硬性要求.第三种&lt;code&gt;effect&lt;/code&gt;类型:&lt;code&gt;NoExecute&lt;/code&gt;会在晚些时候讲到&lt;/p&gt;
&lt;p&gt;你可以为一个节点(node)添加多个污点,也可以为一个pod添加多个容忍(toleration).kubernetes处理多个污点(taint)或者多个容忍(toleration)类似于过滤器:起初包含所有污点,然后忽略掉pod匹配的污点,剩下不可被忽略的污点决定此节点对pod的效果,特别地:&lt;/p&gt;
&lt;p&gt;1) 如果至少有一个不可忽略的&lt;code&gt;NoSchedule&lt;/code&gt;类型的效果(effect),kubernetes不会调度pod到此节点上来.&lt;/p&gt;
&lt;p&gt;2) 如果没有不可忽略的&lt;code&gt;NoSchedule&lt;/code&gt;类型的效果(effect),但是至少有一个&lt;code&gt;PreferNoSchedule&lt;/code&gt;类型的效果,则kubernetes会尝试调度pod到此节点上&lt;/p&gt;
&lt;p&gt;3) 如果至少有一个&lt;code&gt;NoExecute&lt;/code&gt;类型的效果(effect),则此pod会被驱离此节点(当然,前提此pod在此节点上),并且如果pod不在此节点上,也不会被调度到此节点上&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;所谓驱离是指pod被从此节点上移除,调度到其它节点上&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;示例,假如你有一个以下类型的节点&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;kubectl taint nodes node1 key1=value1:NoSchedule
kubectl taint nodes node1 key1=value1:NoExecute
kubectl taint nodes node1 key2=value2:NoSchedule&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;和以下类型的pod&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;tolerations:
- key: &quot;key1&quot;
  operator: &quot;Equal&quot;
  value: &quot;value1&quot;
  effect: &quot;NoSchedule&quot;
- key: &quot;key1&quot;
  operator: &quot;Equal&quot;
  value: &quot;value1&quot;
  effect: &quot;NoExecute&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种情况下,pod不会被调度到node1上,因为没有容忍(toleration)来匹配第三个&lt;code&gt;taint&lt;/code&gt;.但是如果它运行在此节点上,它仍然可以继续运行在此节点上,因为它仅仅不匹配第三个&lt;code&gt;taint&lt;/code&gt;.(而第三个taint的效果是&lt;code&gt;NoSchedule&lt;/code&gt;,指示不要被调度到此节点)&lt;/p&gt;
&lt;p&gt;通常情况下,一个效果类型为&lt;code&gt;NoExecute&lt;/code&gt;的&lt;code&gt;taint&lt;/code&gt;被添加到一个节点上后,所有不容忍此&lt;code&gt;taint&lt;/code&gt;的pod会被马上驱离,容忍的永远不会被驱离.但是效果类型&lt;code&gt;NoExecute&lt;/code&gt;可以指定一个&lt;code&gt;tolerationSeconds&lt;/code&gt;字段来指示当&lt;code&gt;NoExecute&lt;/code&gt;效果类型的污点被添加到节点以后,pod仍然可以继续在在指定时间内留存在此节点上.&lt;/p&gt;
&lt;p&gt;例如:&lt;/p&gt;
&lt;pre class=&quot;yml&quot;&gt;
&lt;code&gt;tolerations:
- key: &quot;key1&quot;
  operator: &quot;Equal&quot;
  value: &quot;value1&quot;
  effect: &quot;NoExecute&quot;
  tolerationSeconds: 3600&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它意味着如果pod运行在一个可以容忍的节点上,则它可以继续运行3600秒,然后被驱离,在此段时间内如果污点被移除,则pod不会被驱离.&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;以上可以理解为有条件容忍,即便匹配也不能一直运行在此节点上,只能在符合条件的时段内运行在此节点上.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;实例:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;taint&lt;/code&gt;和&lt;code&gt;toleration&lt;/code&gt;可以非常灵活地把指示pod不要调度到不合适的节点或者把已经存在的pod驱离节点,以下列举出一些用例:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;专用节点&lt;/strong&gt; 假如你想让某些节点供特定的用户专用,你可以为这些节点添加污点,例如:(&lt;code&gt;kubectl taint nodes nodename dedicated=groupName:NoSchedule&lt;/code&gt;),然后给专用这些节点的pod添加容忍(toleration),容忍节点污点的pod被允许调度到节点上,当然也可以调度到集群中的其它节点上(没有taint的节点,有taint的必须容忍).如果你想要pod仅被调度到专用的节点,则需要添加标签(使用前面讲到过的亲和属性)&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;pod的亲和性是以pod为中心的,而节点的污点则是以节点为中心.想要使pod被调度到指定节点,需要亲和属性,想要节点排斥非专用pod,则需要使用&lt;code&gt;taint&lt;/code&gt;,同时使用亲和性和污点可以保证专用节点被特定pod专用,特定pod仅使用专用节点&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;配有特殊硬件的节点&lt;/strong&gt; 在一个集群中,有部分节点包含特殊硬件(例如特殊GPU),理想的情况是把让不需要特殊硬件的pod不被调度到这些节点上以便为可能需要特殊硬件的节点留存空间,这种情况下就可以用给指定节点添加污点(taint)的方法来实现效果.(例如&lt;code&gt;kubectl taint nodes nodename special=true:NoSchedule or kubectl taint nodes nodename special=true:PreferNoSchedule&lt;/code&gt;),然后给需要使用特殊硬件的pod添加符合的容忍(toleration).&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;基于taint的驱离策略&lt;/strong&gt;(测试功能),当节点出现问题时,把不容忍的pod驱离.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;基于taint的驱离策略&quot;&gt;基于taint的驱离策略&lt;/h2&gt;
&lt;p&gt;前面我们提到过&lt;code&gt;NoExecute&lt;/code&gt;效果类型的taint,它将对已经存在于此节点上的pod产生效果:&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;不容忍此taint的pod会被马上驱离&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;容忍此taint但是没有指定&lt;code&gt;tolerationSeconds&lt;/code&gt;的pod将会永远运行在此节点&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;容忍此taint但是包含&lt;code&gt;tolerationSeconds&lt;/code&gt;属性的节点将会在此节点上留存指定时间(虽然容忍,但是是有条件的,仅在一段时间内容忍)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;第三点的言外之意即为即便容忍,但是超过容忍时间后仍然会被驱离&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;此外,kubernetes 1.6引入了对节点问题的展示.也就是说当满足了特定条件,节点控制器会自动为符合条件的节点添加&lt;code&gt;taint&lt;/code&gt;,以下是一些内置的&lt;code&gt;taint&lt;/code&gt;&lt;/p&gt;
&lt;ul readability=&quot;10&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;node.kubernetes.io/not-ready&lt;/strong&gt;,节点还没有准备好,对应节点状态&lt;code&gt;Ready&lt;/code&gt;值为false&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;node.kubernetes.io/unreachable&lt;/strong&gt;,节点控制器无法触及节点,对应节点状态&lt;code&gt;ready&lt;/code&gt;值为&lt;code&gt;Unknown&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;node.kubernetes.io/out-of-disk&lt;/strong&gt;,磁盘空间不足&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;node.kubernetes.io/memory-pressure&lt;/strong&gt;,节点存在内存压力&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;node.kubernetes.io/disk-pressure&lt;/strong&gt;,节点磁盘存在压力&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;node.kubernetes.io/network-unavailable&lt;/strong&gt;,节点网络不可用&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;node.kubernetes.io/unschedulable&lt;/strong&gt;,节点不可被调度&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;node.cloudprovider.kubernetes.io/uninitialized&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在kubernetes 1.13版本,基于污点的驱离策略提升到beta级别并且默认开启,因此污点被node控制器(kubelete)自动添加,并且普通的以节点的&lt;code&gt;Ready&lt;/code&gt;状态为基础的驱离策略被禁用.&lt;/p&gt;
&lt;p&gt;这项beta功能,加上&lt;code&gt;tolerationSeconds&lt;/code&gt;,允许节点来指定仍然可以留存长时间即便节目有一种或者多种匹配的问题&lt;/p&gt;
&lt;p&gt;例如:一个包含多种本地状态的应用在节点发生网络分裂情况时希望仍然可以留存一点时间,期望在指定的时段内网络能恢复正常以避免被驱离.这种情况下容忍此节点的pod编排如下&lt;/p&gt;
&lt;pre class=&quot;yml&quot;&gt;
&lt;code&gt;tolerations:
- key: &quot;node.kubernetes.io/unreachable&quot;
  operator: &quot;Exists&quot;
  effect: &quot;NoExecute&quot;
  tolerationSeconds: 6000&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;请注意,如果用户没有在pod的配置中指定&lt;code&gt;node.kubernetes.io/not-ready&lt;/code&gt;,则kubernetes会自动为pod配置加上&lt;code&gt;node.kubernetes.io/not-ready tolerationSeconds=300&lt;/code&gt;属性.同样地,如果没有配置,则自动添加&lt;code&gt;node.kubernetes.io/unreachable tolerationSeconds=300&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;DaemonSet&lt;/code&gt;类型的pod创建时自动为以下两种类型的taint添加&lt;code&gt;NoExecute&lt;/code&gt;效果类型并且没有&lt;code&gt;tolerationSeconds&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这确保即便节点出现问题,&lt;code&gt;DaemonSet&lt;/code&gt;也不会被驱离.&lt;/p&gt;
&lt;h2 id=&quot;有条件节点taint&quot;&gt;有条件节点taint&lt;/h2&gt;
&lt;p&gt;在kubernetes 1.12版,有条件为节点添加taint(TaintNodesByCondition)特征被提升为beta级别,节点生命周期控制器会自动根据节点的状态为节点添加taint.同样地调度器不检测node的状态,而是检测node 的污点(taint).这确保node的状态不影响哪些pod可以调度到此node上,用户可以选择通过添加相应的容忍(toleration)来忽略node的指定的问题(通过node的状态体现).注意&lt;code&gt;TaintNodesByCondition&lt;/code&gt;仅添加&lt;code&gt;NoSchedule&lt;/code&gt;类型的污点.&lt;code&gt;NoExecute&lt;/code&gt;效果类型由&lt;code&gt;TaintBasedEviction&lt;/code&gt;控制(此功能为1.13版本的beta功能)&lt;/p&gt;
&lt;p&gt;从kubernetes 1.8开始,&lt;code&gt;DaemonSet controller&lt;/code&gt;自动以下类型的为所有的&lt;code&gt;daemon&lt;/code&gt;添加&lt;code&gt;NoSchedule&lt;/code&gt;效果类型的容忍(toleration),来防止DeamonSet分裂&lt;/p&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;node.kubernetes.io/memory-pressure&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;node.kubernetes.io/disk-pressure&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;node.kubernetes.io/out-of-disk (only for critical pods)&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;node.kubernetes.io/unschedulable (1.10 or later)&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;node.kubernetes.io/network-unavailable (host network only)&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;添加了这些类型的容忍是为了向后兼容,你可以为DaemonSet添加任意类型的容忍&lt;/p&gt;
</description>
<pubDate>Sat, 15 Jun 2019 00:22:00 +0000</pubDate>
<dc:creator>周国通</dc:creator>
<og:description>'系列目录' 节点亲和性(affinity),是节点的一种属性,让符合条件的pod亲附于它(倾向于或者硬性要求).污点是一种相反的行为,它会使pod抗拒此节点(即pod调度的时候不被调度到此节点) 污</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tylerzhou/p/11026364.html</dc:identifier>
</item>
<item>
<title>Xcode 中配置 clang-format 格式化 C++ 代码 - 刘哇勇</title>
<link>http://www.cnblogs.com/Wayou/p/xcode_clang_setup.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Wayou/p/xcode_clang_setup.html</guid>
<description>&lt;p&gt;Xcode 自带的代码格式化功能（&lt;kbd&gt;control&lt;/kbd&gt; + &lt;kbd&gt;I&lt;/kbd&gt;）很有限，其 “格式化” 仅限于设置缩进，代码里面的格式是不会处理的。所以需要借助额外的工具来完成代码的美化。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://clang.llvm.org/docs/ClangFormat.html&quot; rel=&quot;nofollow&quot;&gt;clang-format&lt;/a&gt; 便是可选的工具之一，它可用来格式化 C/C++/Java/JavaScript/Objective-C/Protobuf/C# 等代码。&lt;/p&gt;
&lt;p&gt;其内置了多种预设的代码风格，分别有 LLVM, Google, Chromium, Mozilla, WebKit。&lt;/p&gt;
&lt;p&gt;可通过添加 &lt;code&gt;.clang-format&lt;/code&gt; 文件来进行配置。优先使用项目中的 &lt;code&gt;.clang-format&lt;/code&gt; 文件，然后会查找系统中存在的 &lt;code&gt;.clang-format&lt;/code&gt; 文件。&lt;/p&gt;
&lt;p&gt;一个配置文件的示例：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
BasedOnStyle: LLVM
IndentWidth: 4  
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;所有可用的配置参数可在其&lt;a href=&quot;https://clang.llvm.org/docs/ClangFormatStyleOptions.html&quot; rel=&quot;nofollow&quot;&gt;文档 Clang-Format Style Options&lt;/a&gt; 中查看。一般指定一个喜欢的预设风格即可。&lt;/p&gt;
&lt;h2&gt;clang-format 的安装&lt;/h2&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
$ brew install clang-format
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;检查安装：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
$ clang-format --version
clang-format version 8.0.0 (tags/google/stable/2019-01-18)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;虽然安装好了，但它是命令行工具，要在 Xcode 中使用，还需要借助 macOS 自带的 Automator 工具。&lt;/p&gt;
&lt;h2&gt;添加 Automator 服务&lt;/h2&gt;
&lt;p&gt;打开 Automator 选择 &quot;Quick Action&quot;。&lt;/p&gt;
&lt;p&gt;￼&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;https://user-images.githubusercontent.com/3783096/59342707-dace0600-8d3c-11e9-82ec-383ff5e3a657.png&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/3783096/59342707-dace0600-8d3c-11e9-82ec-383ff5e3a657.png&quot; alt=&quot;通过 Automator 创建 &amp;quot;Quick Action&amp;quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;通过 Automator 创建 &quot;Quick Action&quot;&lt;/p&gt;
&lt;p&gt;左侧 Library 中搜索 &quot;Run Shell Script&quot; 并拖动到右侧。在脚本编辑框中输入以下内容：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;export&lt;/span&gt; PATH=/usr/local/bin:&lt;span class=&quot;pl-smi&quot;&gt;$PATH&lt;/span&gt;
clang-format
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;https://user-images.githubusercontent.com/3783096/59342864-35676200-8d3d-11e9-8800-a4e169007902.png&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/3783096/59342864-35676200-8d3d-11e9-8800-a4e169007902.png&quot; alt=&quot;通过执行脚本实现 clang-format 服务的添加&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;通过执行脚本实现 clang-format 服务的添加&lt;/p&gt;
&lt;p&gt;同时记得勾选上 &quot;Output replaces selected text&quot;，然后保存并输入保存的名称，比如 &lt;code&gt;clang-format&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;至此一个服务便已添加好。&lt;/p&gt;
&lt;h2&gt;使用&lt;/h2&gt;
&lt;p&gt;在当前用户的根目录 &lt;code&gt;~&lt;/code&gt; 放置一个 &lt;code&gt;.clang-format&lt;/code&gt; 文件，&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot;&gt;
&lt;pre&gt;
$ touch &lt;span class=&quot;pl-k&quot;&gt;~&lt;/span&gt;/.clang-format
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在其中指定 C++ 格式化相关的配置，比如：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
BasedOnStyle: Google
IndentWidth: 2
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当然，除了配置文件，clang-format 的格式化参数也可通过 shell 的方式传递，比如上面在添加服务时输入的脚本中，带上格式化的参数：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;11&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;export&lt;/span&gt; PATH=/usr/local/bin:&lt;span class=&quot;pl-smi&quot;&gt;$PATH&lt;/span&gt;
clang-format -style=&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;{IndentWidth: 4, TabWidth: 4, UseTab: Never,   BreakBeforeBraces: Stroustrup}&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打开 Xcode，选中需要格式化的代码并右键唤出菜单。选择 &lt;code&gt;Services-&amp;gt; clang-format&lt;/code&gt;，这里 Services 中的名称即为前面步骤中保存的 Services 名称。&lt;/p&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;https://user-images.githubusercontent.com/3783096/59343020-81b2a200-8d3d-11e9-9433-92da848e4549.gif&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/3783096/59343020-81b2a200-8d3d-11e9-9433-92da848e4549.gif&quot; alt=&quot;通过菜单进行格式化&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;通过菜单进行格式化&lt;/p&gt;
&lt;h2&gt;添加快捷键&lt;/h2&gt;
&lt;p&gt;显然右键这种方式不够便捷，进一步添加快捷键来实现更加方便的代码格式化。因为 Xcode 中格式化代码默认的快捷键为 &lt;kbd&gt;control&lt;/kbd&gt; + &lt;kbd&gt;I&lt;/kbd&gt;，不防我们就设置 &lt;code&gt;clang-format&lt;/code&gt; 这个服务的快捷键为这个按键组合。&lt;/p&gt;
&lt;p&gt;打开系统的首选项设置（可通过在 SpotLight 中搜索 &quot;system preference&quot;），然后打开键盘设置 &quot;Kyeboard&quot; 并切换到 &quot;Shortcuts&quot; 标签。&lt;/p&gt;
&lt;p&gt;选中左侧 &quot;App Shortcuts&quot; 然后为 &quot;Xcode&quot; 绑定 &lt;kbd&gt;control&lt;/kbd&gt; + &lt;kbd&gt;I&lt;/kbd&gt; 执行 &lt;code&gt;clang-format&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;https://user-images.githubusercontent.com/3783096/59343056-98f18f80-8d3d-11e9-9780-20bf36e21eb5.png&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/3783096/59343056-98f18f80-8d3d-11e9-9780-20bf36e21eb5.png&quot; alt=&quot;为 clang-format 添加系统快捷键&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;为 `clang-format` 添加系统快捷键&lt;/p&gt;
&lt;p&gt;然后便可通过快捷键方便地进行代码格式化了。&lt;/p&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;https://user-images.githubusercontent.com/3783096/59343691-fc2ff180-8d3e-11e9-8919-c3e652923c44.gif&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/3783096/59343691-fc2ff180-8d3e-11e9-8919-c3e652923c44.gif&quot; alt=&quot;通过快捷键进行格式化&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;通过快捷键进行格式化&lt;/p&gt;
&lt;h2&gt;其他工具&lt;/h2&gt;
&lt;p&gt;存在一些其他以插件形式的工具，同样能达到使用 clang-format 格式化代码的目的，比如 &lt;a href=&quot;https://github.com/travisjeffery/ClangFormat-Xcode&quot;&gt;travisjeffery/ClangFormat-Xcode&lt;/a&gt;，但不支持 Xcode 9+，可安装其替代版 &lt;a href=&quot;https://github.com/V5zhou/ZZClang-format&quot;&gt;V5zhou/ZZClang-format&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;该插件安装好后，支持在文件保存时自动格式化，比较方便。&lt;/p&gt;
&lt;p&gt;但因为是来自社区的插件，需要先将 Xcode 去掉签名 （unsign），参见 &lt;a href=&quot;https://github.com/inket/update_xcode_plugins&quot;&gt;inket/update_xcode_plugins&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;相关资源&lt;/h2&gt;
</description>
<pubDate>Sat, 15 Jun 2019 00:21:00 +0000</pubDate>
<dc:creator>刘哇勇</dc:creator>
<og:description>Xcode 自带的代码格式化功能（control + I）很有限，其 “格式化” 仅限于设置缩进，代码里面的格式是不会处理的。所以需要借助额外的工具来完成代码的美化。 clang format 便是可</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Wayou/p/xcode_clang_setup.html</dc:identifier>
</item>
<item>
<title>测试工作效率低思考和改进 - 代码清洁工</title>
<link>http://www.cnblogs.com/linyfeng/p/11026339.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/linyfeng/p/11026339.html</guid>
<description>&lt;p&gt;&lt;span&gt;  &lt;span&gt;汇总统计了一下项目组近期测试项目实际工作量与基线工作量的对比，发现一个严重问题。就是工作效率特别低下。下面简单列举一下几个项目预期工作量和实际工作量以及时间耗费严重的地方、项目简要背景。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  1、B版本测试。版本预期工作量15人天，实际耗费工作量在30人天。更为严重的是测试人员&lt;span&gt;并没有因为测试周期延长和工作量投入加大而测试的更轻松，反而是&lt;/span&gt;测试期间晚上加班严重，参与测试人员测得还极其难受。有一个背景提前说明，该版本是从同测试部其他项目组第一次交接给我们项目组，另外参与B版本测试的测试人员对手上测试项内容不熟，第一次执行，此为前提。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  2、S专项测试。预期工作量3人天，实际耗费工作量6人天。中间也是各种加班。对测试人员来说，该项内容也是新东西，但是对项目组来说，该项目是相对成熟的验证内容。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 3、已知问题的&lt;strong&gt;重复又重复&lt;/strong&gt;的咨询、确认、沟通。虽然单次耗时不多，但是架不住频率太多。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  测试人员加班多，活干的还不爽，工作量产出与工作时长严重不成正比，自己也在思考这些工作现象和如何改进，否则如果这样状态长期下去肯定会出现人心浮动，身心烦躁、离职、转岗等等问题。。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;  &lt;span&gt;1、测试人员接手新项目，没有好用（容易理解、无歧义、有图文指引、详细FAQ）的文档。拿到一个文档不好用，理解费尽也无法Step by Step执行。可能也不知道谁熟悉这一块，知道谁熟悉这一块的人正好又忙的不可开交，三言两语跟你说完了你还是云里雾里，又只能回去继续埋头看，时间就悄悄过去了。过两天测试内容要交付了，活没干完，靠，加班。。烦躁&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  2、已知问题反复沟通、确认。A问B解决，C不知道该问题，又问D，D不知道又问A，A可能没记录时间长了忘记了又问B。来回循环特别耗时，看着好像挺不可能的，实际在项目组工作中很常见。有时候就是这种小的不能再小的问题阻塞你工作大半天。过程中问问题的人很郁闷（就这P大点问题搞半天），被问的也很郁闷（咋天天问，我活也干不完啊）。大家都郁闷&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 3、返工。举几个例子，环境切换后发现少了一个指令数据没有收集，切换回来。半天过去了。切换前发现某个测试项没有验证切换回来。测试报告写作时发现过程需要截图发现忘记保留，加班从新测试一遍收集一下。累不。烦不。站着旁边看我都觉着累、烦。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 4、习惯于手工操作。比如上百条的命令他可以一个个写，几十个指令的修改他可以一个个改。&lt;span&gt;太可怕了。。&lt;/span&gt;明明可以写个脚本一会会可以搞定的，就算不会写，随便组内找个小伙伴帮忙搞两下也就解决了。但是好像习惯了，还觉着很努力。。可能不是常态，但是见过不少了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 5、还有其他的，工具不好用、文档找不着、文档不成体系，遇到问题找不到FAQ等等。。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 6、策略问题。这个可能得专门说了。。不再这展开。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  这些问题不知道在大家项目组是否存在或者是否是突出问题，这里应该还与项目区人员业务、技术成熟度有关，恰巧的是我们当前部门、项目组新人太多了。。可能不是问题的问题都成了大问题。。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;  &lt;span&gt;影响测试效率低的问题上面也简单罗列了。不能光吐槽，总得想办法解决啊，起码让自己或者和自己一块干活的少加点班啊。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt; 1、梳理收集组内现有经验文档，形成知识体系。特别是经常搞的工具使用、专项验证常规特性验证、复杂特性验证等。文档一定要清晰、易懂、规范、能多截图就一张别少。能把点击菜单按钮路径写清楚就写完整。为什么是经常搞的，第一优先级高，常用。另外，统计观察过程发现，影响测试效率低最明显的就是这些常搞的内容。另外，整理完后发布在论坛上，随版本测试实时刷新。知会组内同事。如果组内同事都勤于刷新这些内容，文档和FAQ就会非常详细。另外，还有一个好处，就是可以知道谁搞过相关的事情，咨询问题时就不用来回绕了。。直接找到相关人员解决问题。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt; 2、多总结，随手记，多分享。上面说的是成体系的，这里主要是随手记一些文档，FAQ。写完可以分享在自己博客、论坛甚至发到工作群里都可以。尽量不要都记在自己电脑上，一个自己可能不好找，后面就忘记了。。另外一个，别人就没法共享你的劳动成功，资源浪费了。。好记性不如烂笔头，多总结，随手记，多分享。与己方便，与人方便。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt; 3、工具开发与维护。定期维护常用测试工具，让它更好用，不影响测试。定期收集工具需求，开发。。用工具提升测试效率，让工具替人干活，这就是自动化最大的价值。所以，要尽量多思考，多想想自己手上哪些工作可以通过工具替代的。。不要埋头手工搞，不是手工作业的时代了。。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt; 4、个人技能。这个重点就是要看个人了。。针对自己的手上工作有意识的去总结、拓展、去思考、去分享知识。业务和技能越强，依赖外部的机会就会少些，干活自然效率就会高很多。。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt; 5、培训。这个实际上是好办法办法，但是去年上半年做了半年培训 实际效果并不好。大家都只是挂着听听。互动也不好，下来就忘记了。。可能是项目太忙，可能是大家没有真实经历某些测试项时并不愿意主动花这个时间去学习，我有时候不愿意参加原因是因为一个是我没有太多时间提前了解，培训时听不懂。。可能是培训形式和方法不太对，这个需要再思考一下&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt; &lt;span&gt;上述的问题其实在很多项目组都经历过，都很普遍，改进方法也都很简单、很老套。只不过在新人多的部门和项目组暴露的更为明显。目前改进的事情如知识体系建立、FAQ整理，常用工作开发和维护都已经在进行中了。。希望工作效率可以上一个层次，大家少加班，身心愉悦&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 14 Jun 2019 23:57:00 +0000</pubDate>
<dc:creator>代码清洁工</dc:creator>
<og:description>引子 汇总统计了一下项目组近期测试项目实际工作量与基线工作量的对比，发现一个严重问题。就是工作效率特别低下。下面简单列举一下几个项目预期工作量和实际工作量以及时间耗费严重的地方、项目简要背景。 1、B</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/linyfeng/p/11026339.html</dc:identifier>
</item>
<item>
<title>每个人都应有自己的作品 - 运维咖啡吧</title>
<link>http://www.cnblogs.com/37Y37/p/11026175.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/37Y37/p/11026175.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;埋一颗种子，细心呵护，静待她枝繁叶茂，葱郁参天&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;V2论坛上有个帖子【做程序员最重要的还是一定要有自己的作品】，作者写道：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;能有一个作品和你的名字联系在一起，应当成为在职业生涯前期着意的方向

这个作品不是你的公司的项目，也不是你朋友请你帮忙的项目，更不是你接的私活

而是由你主导，也由你主刀的项目——你自己的作品

无论大小，无论用户多少，也无论 star，维护下去，有一天它会成为你改变生活，改变角色，最理所应当的理由。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;帖子下绝大多数的人对此表示了赞同，同时还有相当一部分的人贴出了自己正在运营的个人项目，这些项目或已取得一定的成果，或还正在开发迭代慢慢起步，这些都令我感到欣喜，做出自己的产品不仅对自身的综合能力有着莫大的提升，还很有可能为你谋得一份不错的工作&lt;/p&gt;
&lt;p&gt;而在我看来个人作品不仅仅会对自己的工作产生积极的影响，更重要的是能够帮助我们跳出&lt;strong&gt;拿时间换收入&lt;/strong&gt;的魔咒，阮一峰老师的文章里有这么一段话&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;主持人问，现在很多人开网约车，这样能赚多少钱，能够赚到大钱吗？&lt;/p&gt;
&lt;p&gt;这个问题很容易回答，答案就是不能。出租车司机的收入，主要由营业时间的长短决定。基本上，一天开12个小时，就是比开6个小时，收入高出一倍。每天只有24个小时，因此收入存在上限，不可能偏离平均水平很远。&lt;/p&gt;
&lt;p&gt;出租车是&quot;时间换收入&quot;的典型行业，投入的时间越多，收入越高，在家休息就没收入。很多行业都属于&quot;时间换收入&quot;，所有此类行业都赚不到大钱。因为你能用来交换的时间是有限的，而且进入中年以后，你就拿不出更多的时间来交换。开出租车赚零花钱，或者作为短期过渡，这是没问题的，但作为终身职业是很糟糕的。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;我们的职业，虽然在一定程度上能靠自己的天赋或努力在能力水平上超越其他人，从而获取更高的报酬，但结合自身实际情况看看单位时间的价值确也很容易达到瓶颈，终究还是要一直工作不能停下靠出卖时间来获取收入&lt;/p&gt;
&lt;p&gt;我们需要找到一种&lt;strong&gt;一次投入能够持续获得收益&lt;/strong&gt;的途径，而打造自己的产品就为我们提供了这么一条通道&lt;/p&gt;
&lt;p&gt;你可能不是程序员，写不出来牛逼的产品，那么好好写写文章，维护下个人的博客或者公众号也是个不错的选择，阮老师的文章里还有这么一段话：&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;能够获得暴利的职业，都有一个共同特点：可扩展性，一次劳动可以服务成千上万的人。&lt;/p&gt;
&lt;p&gt;软件、电影、游戏行业都具有可扩展性，作品的生产成本是固定的，但可以被消费无数次，所以有巨大的获利空间，创造出许许多多的富豪。另一方面，理发师、厨师、出租车司机一次劳动，只能服务少数几个人，就不具有可扩展性，很难获得暴利，生存得很辛苦。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;写作是最具可扩展性的活动。你写了一篇文章，每被看到一次，就是扩展了一次。&lt;/p&gt;
&lt;p&gt;我仔细的审视了以下自己的能力，想要写出改变世界的产品恐怕是很难完成了，所以讨巧选择了写作，把这个公众号当作自己的产品，认认真真输出内容，踏踏实实做好运营，埋下一颗种子，短时间内可能没有结果，但坚持做了说不定就能带来意外的收获~&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;https://blz.nosdn.127.net/sre/wx.qrcode.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 14 Jun 2019 22:59:00 +0000</pubDate>
<dc:creator>运维咖啡吧</dc:creator>
<og:description>埋一颗种子，细心呵护，静待她枝繁叶茂，葱郁参天 V2论坛上有个帖子【做程序员最重要的还是一定要有自己的作品】，作者写道： 帖子下绝大多数的人对此表示了赞同，同时还有相当一部分的人贴出了自己正在运营的个</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/37Y37/p/11026175.html</dc:identifier>
</item>
<item>
<title>Unity3D热更新之LuaFramework篇[05]--Lua脚本调用c#以及如何在Lua中使用Dotween - 子非鱼`</title>
<link>http://www.cnblogs.com/imteach/p/11026054.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/imteach/p/11026054.html</guid>
<description>&lt;blockquote readability=&quot;5.3421052631579&quot;&gt;
&lt;p&gt; 在上一篇文章 &lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/imteach/p/10960188.html&quot;&gt;Unity3D热更新之LuaFramework篇[04]--自定义UI监听方法&lt;/a&gt; 中，我对LuaBehaviour脚本进行了扩展，添加了两个新的UI监听方法，也提到最好能单写一个脚本处理此事。本篇文章就来继续这个工作。&lt;/p&gt;

&lt;/blockquote&gt;
&lt;h2&gt;从Lua中调用C#代码&lt;/h2&gt;
&lt;blockquote readability=&quot;46&quot;&gt;
&lt;h3&gt;1、创建UI监听脚本&lt;/h3&gt;
&lt;p&gt; 打开之前的工程，在Assets/LuaFrameworks/Scripts/Common下，创建一个UIEventEx.cs脚本，将LuaBehaviour.cs中的AddButtonClick以及AddInputFieldEndEditHandler方法迁移过来，并扩展了一些其它方法，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('c8dc81f9-f7b8-4e8c-aa35-846fe696a239')&quot; readability=&quot;40&quot;&gt;&lt;img id=&quot;code_img_closed_c8dc81f9-f7b8-4e8c-aa35-846fe696a239&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_c8dc81f9-f7b8-4e8c-aa35-846fe696a239&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('c8dc81f9-f7b8-4e8c-aa35-846fe696a239',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_c8dc81f9-f7b8-4e8c-aa35-846fe696a239&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;75&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; LuaInterface;
&lt;/span&gt;&lt;span&gt;  2&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections;
&lt;/span&gt;&lt;span&gt;  3&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; UnityEngine;
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; UnityEngine.EventSystems;
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; UnityEngine.UI;
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt; 
&lt;span&gt;  8&lt;/span&gt; &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;  9&lt;/span&gt; &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 自定义的添加UI监听的方法，可以用lua中调用以做事件绑定
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt; &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 11&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UIEventEx {
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加监听&lt;/span&gt;
&lt;span&gt; 13&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; AddButtonClick(GameObject go, LuaFunction luafunc)
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (go == &lt;span&gt;null&lt;/span&gt; || luafunc == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt; 
&lt;span&gt; 18&lt;/span&gt;         Button btn = go.GetComponent&amp;lt;Button&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (btn == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt; 
&lt;span&gt; 22&lt;/span&gt; &lt;span&gt;        btn.onClick.AddListener
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt; &lt;span&gt;        (
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt;             &lt;span&gt;delegate&lt;/span&gt;&lt;span&gt; ()
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt; &lt;span&gt;                luafunc.Call(go);
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt; &lt;span&gt;        );
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt; 
&lt;span&gt; 31&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加监听（外带数据中转功能）&lt;/span&gt;
&lt;span&gt; 32&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; AddButtonClick(GameObject go, LuaFunction luafunc, LuaTable luatable)
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (go == &lt;span&gt;null&lt;/span&gt; || luafunc == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt; 
&lt;span&gt; 37&lt;/span&gt;         Button btn = go.GetComponent&amp;lt;Button&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (btn == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt; 
&lt;span&gt; 41&lt;/span&gt; &lt;span&gt;        btn.onClick.AddListener
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt; &lt;span&gt;        (
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt;             &lt;span&gt;delegate&lt;/span&gt;&lt;span&gt; ()
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt; &lt;span&gt;                luafunc.Call(go, luatable);
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt; &lt;span&gt;        );
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt; 
&lt;span&gt; 50&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 51&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 给Toggle组件添加监听
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 53&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; AddToggle(GameObject go, LuaFunction luafunc, LuaTable luatable)
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (go == &lt;span&gt;null&lt;/span&gt; || luafunc == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt; 
&lt;span&gt; 57&lt;/span&gt;         Toggle toggle = go.GetComponent&amp;lt;Toggle&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt; 
&lt;span&gt; 59&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (toggle == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt; 
&lt;span&gt; 61&lt;/span&gt;         go.GetComponent&amp;lt;Toggle&amp;gt;&lt;span&gt;().onValueChanged.AddListener(
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt;             &lt;span&gt;delegate&lt;/span&gt; (&lt;span&gt;bool&lt;/span&gt; &lt;span&gt;select&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt;                 luafunc.Call(luatable, &lt;span&gt;select&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt; &lt;span&gt;        );
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt; 
&lt;span&gt; 68&lt;/span&gt; 
&lt;span&gt; 69&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 70&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 给Toggle组件添加监听
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 72&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; AddToggle(GameObject go, LuaFunction luafunc)
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (go == &lt;span&gt;null&lt;/span&gt; || luafunc == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt; 
&lt;span&gt; 76&lt;/span&gt;         Toggle toggle = go.GetComponent&amp;lt;Toggle&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt; 
&lt;span&gt; 78&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (toggle == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt; 
&lt;span&gt; 80&lt;/span&gt;         go.GetComponent&amp;lt;Toggle&amp;gt;&lt;span&gt;().onValueChanged.AddListener(
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt;             &lt;span&gt;delegate&lt;/span&gt; (&lt;span&gt;bool&lt;/span&gt; &lt;span&gt;select&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt;                 luafunc.Call(&lt;span&gt;select&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt; &lt;span&gt;        );
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt; 
&lt;span&gt; 87&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;给输入组件（InputField）添加结束编辑(OnEndEdit)监听&lt;/span&gt;
&lt;span&gt; 88&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; AddInputFieldEndEditHandler(GameObject go, LuaFunction luafunc)
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (go == &lt;span&gt;null&lt;/span&gt; || luafunc == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt; 
&lt;span&gt; 92&lt;/span&gt;         InputField input = go.GetComponent&amp;lt;InputField&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt; 
&lt;span&gt; 94&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (input == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt;             Debug.LogError(go.name + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;找不到InputField组件&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt; 
&lt;span&gt;100&lt;/span&gt;         go.GetComponent&amp;lt;InputField&amp;gt;&lt;span&gt;().onEndEdit.AddListener(
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt;             &lt;span&gt;delegate&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt;&lt;span&gt; text) {
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt; &lt;span&gt;                luafunc.Call(text);
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt; &lt;span&gt;        );
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt; 
&lt;span&gt;107&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;108&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 添加对光标按下|抬起事件的支持
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;110&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;go&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;目标对象&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;111&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;luafunc&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;按下事件&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;112&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;luafunc2&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;抬起事件&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;113&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; AddPointerDownUpSupport(GameObject go, LuaFunction luafunc, LuaFunction luafunc2)
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;115&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (go == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;116&lt;/span&gt; 
&lt;span&gt;117&lt;/span&gt;         EventsSupport es = go.AddComponent&amp;lt;EventsSupport&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;118&lt;/span&gt; 
&lt;span&gt;119&lt;/span&gt;         es.InitDownUpHandler((PointerEventData pointerEventData) =&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;120&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (luafunc != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;121&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;122&lt;/span&gt; &lt;span&gt;                luafunc.Call(go, pointerEventData);
&lt;/span&gt;&lt;span&gt;123&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;124&lt;/span&gt; 
&lt;span&gt;125&lt;/span&gt;         }, (PointerEventData pointerEventData) =&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;126&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (luafunc2 != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;127&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;128&lt;/span&gt; &lt;span&gt;                luafunc2.Call(go, pointerEventData);
&lt;/span&gt;&lt;span&gt;129&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;130&lt;/span&gt; &lt;span&gt;        });
&lt;/span&gt;&lt;span&gt;131&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;132&lt;/span&gt; 
&lt;span&gt;133&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;134&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 给Slider组件添加onValueChanged事件
&lt;/span&gt;&lt;span&gt;135&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;136&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;go&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;137&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;luafunc&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;138&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; AddSliderOnChangeEvent(GameObject go, LuaFunction luafunc)
&lt;/span&gt;&lt;span&gt;139&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;140&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (go == &lt;span&gt;null&lt;/span&gt; || luafunc == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;141&lt;/span&gt; 
&lt;span&gt;142&lt;/span&gt;         Slider component = go.GetComponent&amp;lt;Slider&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;143&lt;/span&gt; 
&lt;span&gt;144&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (component == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;145&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;146&lt;/span&gt;             Debug.LogError(go.name + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;找不到Slider组件&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;147&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;148&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;149&lt;/span&gt; 
&lt;span&gt;150&lt;/span&gt;         go.GetComponent&amp;lt;Slider&amp;gt;&lt;span&gt;().onValueChanged.AddListener(
&lt;/span&gt;&lt;span&gt;151&lt;/span&gt;             &lt;span&gt;delegate&lt;/span&gt; (&lt;span&gt;float&lt;/span&gt;&lt;span&gt; val) {
&lt;/span&gt;&lt;span&gt;152&lt;/span&gt; &lt;span&gt;                luafunc.Call(val);
&lt;/span&gt;&lt;span&gt;153&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;154&lt;/span&gt; &lt;span&gt;        );
&lt;/span&gt;&lt;span&gt;155&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;156&lt;/span&gt; 
&lt;span&gt;157&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;清除监听&lt;/span&gt;
&lt;span&gt;158&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ClearButtonClick(GameObject go)
&lt;/span&gt;&lt;span&gt;159&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;160&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (go == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;161&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;162&lt;/span&gt; 
&lt;span&gt;163&lt;/span&gt;         Button btn = go.GetComponent&amp;lt;Button&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;164&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (btn == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;165&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;166&lt;/span&gt; 
&lt;span&gt;167&lt;/span&gt; &lt;span&gt;        btn.onClick.RemoveAllListeners();
&lt;/span&gt;&lt;span&gt;168&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;169&lt;/span&gt; 
&lt;span&gt;170&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;UIEventEx.cs&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;在Assets/LuaFrameworks/Scripts/Common下，创建一个EventsSupport.cs脚本，该脚本是一个实现了IPointerDownHandler, IPointerUpHandler等接口的类，用于在Lua中检测鼠标输入（鼠标点击，抬起、按下等功能），配合UIEventEx.cs中的AddPointerDownUpSupport方法使用。其代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('bd04cd21-8428-4289-a4b6-87549d841b6c')&quot; readability=&quot;36.5&quot;&gt;&lt;img id=&quot;code_img_closed_bd04cd21-8428-4289-a4b6-87549d841b6c&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_bd04cd21-8428-4289-a4b6-87549d841b6c&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('bd04cd21-8428-4289-a4b6-87549d841b6c',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_bd04cd21-8428-4289-a4b6-87549d841b6c&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;68&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; UnityEngine;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; UnityEngine.EventSystems;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;  其它事件可根据需要在此类中实现
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    IPointerEnterHandler - OnPointerEnter - Called when a pointer enters the object
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    IPointerExitHandler - OnPointerExit - Called when a pointer exits the object
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    IPointerDownHandler - OnPointerDown - Called when a pointer is pressed on the object
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    IPointerUpHandler - OnPointerUp - Called when a pointer is released (called on the original the pressed object)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    IPointerClickHandler - OnPointerClick - Called when a pointer is pressed and released on the same object
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    IInitializePotentialDragHandler - OnInitializePotentialDrag - Called when a drag target is found, can be used to initialise values
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    IBeginDragHandler - OnBeginDrag - Called on the drag object when dragging is about to begin
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    IDragHandler - OnDrag - Called on the drag object when a drag is happening
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    IEndDragHandler - OnEndDrag - Called on the drag object when a drag finishes
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    IDropHandler - OnDrop - Called on the object where a drag finishes
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    IScrollHandler - OnScroll - Called when a mouse wheel scrolls
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    IUpdateSelectedHandler - OnUpdateSelected - Called on the selected object each tick
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    ISelectHandler - OnSelect - Called when the object becomes the selected object
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    IDeselectHandler - OnDeselect - Called on the selected object becomes deselected
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    IMoveHandler - OnMove - Called when a move event occurs (left, right, up, down, ect)
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    ISubmitHandler - OnSubmit - Called when the submit button is pressed
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    ICancelHandler - OnCancel - Called when the cancel button is pressed
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt; &lt;span&gt;///&lt;/span&gt;&lt;span&gt; unity事件支持（本类用于实现Unity中的各种事件，借给Lua调用）
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; EventsSupport : MonoBehaviour, IPointerDownHandler, IPointerUpHandler
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;     Action&amp;lt;PointerEventData&amp;gt; onPointerDownHandler = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;     Action&amp;lt;PointerEventData&amp;gt; onPointerUpHandler = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; 
&lt;span&gt;35&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; InitDownUpHandler (Action&amp;lt;PointerEventData&amp;gt; downHandler, Action&amp;lt;PointerEventData&amp;gt;&lt;span&gt; upHandler)
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;         onPointerDownHandler =&lt;span&gt; downHandler;
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;         onPointerUpHandler =&lt;span&gt; upHandler;
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; 
&lt;span&gt;41&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnPointerDown(PointerEventData pointerEventData)
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Output the name of the GameObject that is being clicked
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Debug.Log(&quot;[&quot; + name + &quot;] Game Object Click in Progress&quot;);&lt;/span&gt;
&lt;span&gt;45&lt;/span&gt;         
&lt;span&gt;46&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (onPointerDownHandler != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;            onPointerDownHandler(pointerEventData);
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; 
&lt;span&gt;51&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Detect if clicks are no longer registering&lt;/span&gt;
&lt;span&gt;52&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnPointerUp(PointerEventData pointerEventData)
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Debug.Log(&quot;[&quot; +　name + &quot;] No longer being clicked&quot;);&lt;/span&gt;
&lt;span&gt;55&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (onPointerUpHandler != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; &lt;span&gt;            onPointerUpHandler(pointerEventData);
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;EventsSupport.cs&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;EventsSupport.cs脚本需要挂在待检测输入的Game Object上。&lt;/p&gt;

&lt;h3&gt;2、使用脚本&lt;/h3&gt;
&lt;p&gt;这里还是以上一篇文章写的登陆界面为例，之前我们是通过LuaBehaviour给Button、Toggle以及InputField添加的监听函数，现在将相应的用法直接替换掉。&lt;/p&gt;
&lt;p&gt;替换前：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/634826/201906/634826-20190614235553195-889356487.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;替换后：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/634826/201906/634826-20190615003215243-1107313943.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;然后运行，看是否生效。&lt;/p&gt;
&lt;p&gt;......&lt;/p&gt;
&lt;p&gt;运行结果,报错了，提示全局变量 UIEventEx为nil(就是这个变量不存在的意思)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/634826/201906/634826-20190615000054912-1615721479.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  看来这样想当然的方法是行不通了，我们不能创建一个C#脚本，然后在Lua中直接使用它。&lt;/p&gt;

&lt;h3&gt;3、C#类导出&lt;/h3&gt;
&lt;p&gt;在上一步中，我们发现无法直接在Lua中使用创建的C#脚本。通过查阅资料了解到，对自定义的c#类，如果想在Lua中使用的话，需要做一个导出操作才行。&lt;/p&gt;
&lt;p&gt;ToLua的官方git上也有相关的说明：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/634826/201906/634826-20190615001345010-271593536.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;跟着说明操作：&lt;/p&gt;
&lt;p&gt;1）找到Assets\LuaFramework\Editor\下的CustomSettings.cs脚本; &lt;/p&gt;
&lt;p&gt;2）在CustomSettings的60 行左右照例添加一个导出语句&quot;&lt;span&gt;&lt;strong&gt;_GT(typeof(UIEventEx)),&lt;/strong&gt;&lt;/span&gt;&quot;;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/634826/201906/634826-20190615001938517-2111695389.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3）点击Lua/Generate All菜单，等到日志打印 Generate LuaBinder over !字样时，表明Generate操作已经完成了。&lt;/p&gt;
&lt;p&gt;此时查看Assets\LuaFramework\ToLua\Source\Generate，能找到一个叫UIEventExWrap的cs文件，这个就是UIEventEx的导出类。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/634826/201906/634826-20190615002818592-1552274889.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;4）重新运行Unity,已经不再报错了，点击Button、Toggle、在InputField中输入字符，功能都和之前使用LuaBehaviour时一致。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/634826/201906/634826-20190615003310479-1601683894.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2&gt;总结&lt;/h2&gt;
&lt;blockquote readability=&quot;23&quot;&gt;
&lt;p&gt;如果想在Lua中使用自定义的c#类，需要4个步骤：&lt;/p&gt;
&lt;p&gt;1）创建c#脚本；&lt;/p&gt;
&lt;p&gt;2）在CustomSetting.cs中添加导出语句；&lt;/p&gt;
&lt;p&gt;3）点击Lua/Generate All菜单；&lt;/p&gt;
&lt;p&gt;4）在Lua中以全局变量的形式直接使用；&lt;/p&gt;

&lt;p&gt;这里涉及的转化过程是这样的:&lt;/p&gt;
&lt;p&gt;1）&lt;span&gt;UIEventEx&lt;/span&gt;脚本通过&lt;strong&gt;Lua/Generate All&lt;/strong&gt;菜单生成&lt;span&gt;UIEventWrap&lt;/span&gt;脚本；&lt;/p&gt;
&lt;p&gt;2）&lt;span&gt;UIEventWrap&lt;/span&gt;脚本经过&lt;strong&gt;&lt;span&gt;ToLua&lt;/span&gt;&lt;/strong&gt;的作用，最终成为Lua中的一个&lt;span&gt;全局变量UIEventEx&lt;/span&gt;；&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/634826/201906/634826-20190615004651011-1521498661.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在之前的文章中我们曾直接使用Lua/Generate All菜单而未做解释，那么现在你应该明白它的做用是什么了。&lt;/p&gt;
&lt;p&gt;至于ToLua怎么把一个XxxWrap转换为Lua中的全局变量，就不是本文能讲得清的了（你可以自己做弄清楚）；&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2&gt;怎么在Lua中使用Dotween&lt;/h2&gt;
&lt;blockquote readability=&quot;66&quot;&gt;
&lt;p&gt;Dotween作为一款非常优秀的缓动动画插件，基本上快成为Unity的标配了。而如果想把所有的UI逻辑全部Lua化，那么在Lua中使用Dotween就是必须的了。&lt;/p&gt;
&lt;p&gt;根据前边的经验，Dotween相关的类对于ToLua来说，就是自定义类，想要在Lua中使用，就必须做导出操作。&lt;/p&gt;
&lt;p&gt;那么就有以下步骤：&lt;/p&gt;
&lt;h3&gt;1）给项目导入一个Dotween插件；&lt;/h3&gt;
&lt;h3&gt;2）导出Dotween相关类；&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;第二步就是要整理Dotween相关的类，然后一个个写导出语句，这不是一个简单的活儿。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;不过不必担心，ToLua已经帮我们做好了。&lt;/p&gt;
&lt;p&gt;打开Assets\LuaFramework\Editor\下的CustomSettings.cs脚本，在70~100行左右，能看到Dotween相关类的导出语句，不过由于未检测到USING_DOTWEENING宏定义的原因，这一段代码并未生效。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/634826/201906/634826-20190615010541260-1614729018.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt; 3）使用宏定义USING_DOTWEENING&lt;/h3&gt;
&lt;p&gt; 一个简单的定义宏的办法是在脚本头部加入 #define USING_DOTWEENING语句，如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/634826/201906/634826-20190615011553435-2104661365.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;另外一个办法是在PlayerSettings的Scripting Define Symbols*下添加相应的宏，如下图： &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/634826/201906/634826-20190615011128357-117745181.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中ASYNC_MOD是之前有的，两个宏之间用分号隔开，输入USING_DOTWEENING 要回车一次，让脚本重新编译。&lt;/p&gt;
&lt;p&gt;这里使用第一种办法。&lt;/p&gt;
&lt;p&gt;定义了宏之后，Dotween相关类的导出语句就生效了,然后要执行一次Lua/Generate All。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/634826/201906/634826-20190615011944902-625307077.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;4）在Lua中作用Dotween&lt;/h3&gt;
&lt;p&gt; 以登陆界面的登陆按钮为例，在LoginPanel.lua脚本中添加如下的Dotween使用方法。 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/634826/201906/634826-20190615014801780-1473145537.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后运行，能看到动画已经生效了（移动及循环都没问题），不过最后的回调没执行。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/634826/201906/634826-20190615015040608-1720956479.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看日志有一个报错，说的是TweenCallback未注册。这个就是OnComplete回调未执行的原因。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/634826/201906/634826-20190615015140644-1324598531.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; TweenCallback是一个委托类型，根据此前了知识，委托类型也需要在CustomSetting中指定位置注册。&lt;/p&gt;
&lt;p&gt;打开CustomSettings脚本，在40~50行左右的位置，添加TweenCallback的导出语句&quot;&lt;strong&gt;_DT(typeof(DG.Tweening.TweenCallback)),&lt;/strong&gt;&quot;，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/634826/201906/634826-20190615020220074-874615132.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;之后重新执行Lua/Generate All菜单（如果有报错，可先执行一次Clear再执行Generate All）。&lt;/p&gt;
&lt;p&gt;现在将循环次数改为1，重新运行。&lt;/p&gt;
&lt;p&gt;能看到动画停止后，指定的日志已经输出。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/634826/201906/634826-20190615020528835-650091165.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在Lua中使用用Dotween，就是这样一个步骤。&lt;/p&gt;

&lt;p&gt; 有一点要注意的是，在Lua中的代码提示是很不健全的，特别是在调用用C#脚本的时候。&lt;/p&gt;
&lt;p&gt;这里写Dotween动画的代码就是全靠经验，如果不熟的话，也可以先用C#写一遍，再搬到Lua中改造。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2&gt;怎么从C#中调用Lua脚本&lt;/h2&gt;
&lt;blockquote readability=&quot;14&quot;&gt;
&lt;p&gt;文章的前半部分介绍了Lua中调用c#的方法，那么相应的如何从c#中调用Lua也有必要了解一下。&lt;/p&gt;
&lt;p&gt;c#调用Lua是比较少的一个操作，基本上就在框架（LuaFramework）初始化的时候有用到。这里不做详细案例，只讲一下了解方式。&lt;/p&gt;
&lt;h3&gt;方式1：&lt;/h3&gt;
&lt;p&gt;ToLua的Examples, 03_CallLuaFunction，这个脚本详细讲述了c#调用Lua的过程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/634826/201906/634826-20190615021812102-1524962056.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;方式2：&lt;/h3&gt;
&lt;p&gt;LuaFramework的LuaManager类，这个脚本里有详细的调用Main.Lua的过程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/634826/201906/634826-20190615022256448-315087417.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;/blockquote&gt;

&lt;h2&gt;后记 &lt;/h2&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;一个疑问：&lt;/p&gt;
&lt;p&gt;在写Lua的Dotween代码的时候，使用DOLocalMove、SetLoops和OnComplete都是用冒号:的方式，实际上这三个都是static方法，这有违于上一篇文章中总结的静态方法用点号，成员方法用冒号的规则。&lt;/p&gt;
&lt;p&gt;暂不知道原因，如果你知道，还请留言指教。&lt;/p&gt;
&lt;/blockquote&gt;

</description>
<pubDate>Fri, 14 Jun 2019 18:38:00 +0000</pubDate>
<dc:creator>子非鱼`</dc:creator>
<og:description>在上一篇文章 Unity3D热更新之LuaFramework篇[04]--自定义UI监听方法 中，我对LuaBehaviour脚本进行了扩展，添加了两个新的UI监听方法，也提到最好</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/imteach/p/11026054.html</dc:identifier>
</item>
<item>
<title>SpringBoot解决跨域请求拦截 - 冬眠的山谷</title>
<link>http://www.cnblogs.com/lgjlife/p/11026093.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lgjlife/p/11026093.html</guid>
<description>
&lt;h2&gt;前言 &lt;/h2&gt;
&lt;p&gt;同源策略：判断是否是同源的，主要看这三点,协议，ip，端口。&lt;/p&gt;
&lt;p&gt;同源策略就是浏览器出于网站安全性的考虑，限制不同源之间的资源相互访问的一种政策。&lt;/p&gt;
&lt;p&gt;比如在域名https://www.baidu.com下，脚本不能够访问https://www.sina.com源下的资源，否则将会被浏览器拦截。&lt;/p&gt;

&lt;p&gt;注意两点：&lt;/p&gt;
&lt;p&gt;1.必须是脚本请求，比如AJAX请求。&lt;/p&gt;
&lt;p&gt;但是如下情况不会产生跨域拦截&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;xxx&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;='xxx&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.跨域拦截是前端请求已经发出，并且在后端返回响应时检查相关参数，是否允许接收后端请求。&lt;/p&gt;

&lt;p&gt; 在微服务开发中，一个系统包含多个微服务，会存在跨域请求的场景。&lt;/p&gt;

&lt;p&gt;本文主要讲解SpringBoot解决跨域请求拦截的问题。&lt;/p&gt;

&lt;h2&gt;搭建项目&lt;/h2&gt;
&lt;p&gt;这里创建两个web项目，web1 和 web2.&lt;/p&gt;
&lt;p&gt;web2项目请求web1项目的资源。&lt;/p&gt;
&lt;p&gt;这里只贴关键代码，完整代码参考&lt;a href=&quot;https://github.com/lgjlife/Java-Code-Demo/tree/master/SpringBoot/cors&quot; target=&quot;_blank&quot;&gt;GitHub&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;WEB2&lt;/h3&gt;
&lt;p&gt;创建一个Controller返回html页面&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Slf4j
@Controller
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HomeController {

    @RequestMapping(&lt;/span&gt;&quot;/index&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String home(){
        log.info(&lt;/span&gt;&quot;/index&quot;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;/home&quot;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;html页面 home.html&lt;/p&gt;
&lt;p&gt;这里创建了一个按钮，按钮按下则请求资源：&quot;http://localhost:8301/hello&quot;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;web2&amp;lt;/title&amp;gt;

    &amp;lt;script src=&quot;https://cdn.staticfile.org/jquery/1.10.2/jquery.min.js&quot;&amp;gt;
    &amp;lt;/script&amp;gt;

    &amp;lt;script&amp;gt;&lt;span&gt;
        $(function () {
            
            $(&lt;/span&gt;&quot;#testBtn&quot;&lt;span&gt;).click(function () {
                console.log(&lt;/span&gt;&quot;testbtn ...&quot;&lt;span&gt;);
                $.get(&lt;/span&gt;&quot;http://localhost:8301/hello&quot;&lt;span&gt;,function(data,status){
                    alert(&lt;/span&gt;&quot;数据: &quot; + data + &quot;\n状态: &quot; +&lt;span&gt; status);
                });
            })
            
        })

    &lt;/span&gt;&amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;&lt;span&gt;
    web2
    &lt;/span&gt;&amp;lt;button id=&quot;testBtn&quot;&amp;gt;测试&amp;lt;/button&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;WEB1&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Slf4j
@RestController
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Web1Controller {

    @RequestMapping(&lt;/span&gt;&quot;/hello&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String hello(){
        log.info(&lt;/span&gt;&quot;hello &quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;hello,&quot; + &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date().toString();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 这里配置两个项目为不同的端口。&lt;/p&gt;
&lt;p&gt;WEB1为8301&lt;/p&gt;
&lt;p&gt;WEB2为8302&lt;/p&gt;
&lt;p&gt;因此是不同源的。 &lt;/p&gt;
&lt;h2&gt;测试&lt;/h2&gt;
&lt;p&gt;在web1还没有配置允许跨域访问的情况下&lt;/p&gt;
&lt;p&gt;按下按钮，将会出现错误。显示Header中没有Access-Control-Allow-Origin&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
Access to XMLHttpRequest at 'http://localhost:8301/hello' from origin 'http://localhost:8300' has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource.
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;WEB1添加允许跨域请求，通过实现WebMvcConfigurer&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Configuration
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; WebMvcConfig &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; WebMvcConfigurer {

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; addCorsMappings(CorsRegistry registry) {
        registry.addMapping(&lt;/span&gt;&quot;/hello&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;再次访问将会返回正常数据。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1404294/201906/1404294-20190615021548501-671165540.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;除了以上的配置外，还可以做更细致的限制&lt;/p&gt;
&lt;p&gt;比如对请求的headers，请求的方法POST/GET...。请求的源进行限制。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1404294/201906/1404294-20190615022458719-2084688815.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;同时还可以使用注解 @CrossOrigin来替换上面的配置。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Slf4j
@RestController
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Web1Controller {

    @CrossOrigin
    @RequestMapping(&lt;/span&gt;&quot;/hello&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String hello(){
        log.info(&lt;/span&gt;&quot;hello &quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;hello,&quot; + &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date().toString();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;注解可以用在类上，也可以用在方法上，但必须是控制器类&lt;/p&gt;
&lt;p&gt;配置和上面一样，也是可以对方法，header,源进行个性化限制。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; @&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; CrossOrigin {
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt; &lt;span&gt;@deprecated&lt;/span&gt; &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Deprecated
    String[] DEFAULT_ORIGINS &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; String[]{&quot;*&quot;&lt;span&gt;};
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt; &lt;span&gt;@deprecated&lt;/span&gt; &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Deprecated
    String[] DEFAULT_ALLOWED_HEADERS &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; String[]{&quot;*&quot;&lt;span&gt;};
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt; &lt;span&gt;@deprecated&lt;/span&gt; &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Deprecated
    &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; DEFAULT_ALLOW_CREDENTIALS = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt; &lt;span&gt;@deprecated&lt;/span&gt; &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Deprecated
    &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; DEFAULT_MAX_AGE = 1800L&lt;span&gt;;

    @AliasFor(&lt;/span&gt;&quot;origins&quot;&lt;span&gt;)
    String[] value() &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; {};

    @AliasFor(&lt;/span&gt;&quot;value&quot;&lt;span&gt;)
    String[] origins() &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; {};

    String[] allowedHeaders() &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; {};

    String[] exposedHeaders() &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; {};

    RequestMethod[] methods() &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; {};

    String allowCredentials() &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; &quot;&quot;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; maxAge() &lt;span&gt;default&lt;/span&gt; -1L&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Fri, 14 Jun 2019 18:32:00 +0000</pubDate>
<dc:creator>冬眠的山谷</dc:creator>
<og:description>前言 同源策略：判断是否是同源的，主要看这三点,协议，ip，端口。 同源策略就是浏览器出于网站安全性的考虑，限制不同源之间的资源相互访问的一种政策。 比如在域名https://www.baidu.co</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lgjlife/p/11026093.html</dc:identifier>
</item>
<item>
<title>Java并发编程系列之Semaphore详解 - 爱在惜缘前</title>
<link>http://www.cnblogs.com/treeshu/p/11026065.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/treeshu/p/11026065.html</guid>
<description>&lt;h3&gt;简单介绍&lt;/h3&gt;
&lt;p&gt;我们以饭店为例，假设饭店只有三个座位，一开始三个座位都是空的。这时如果同时来了三个客人，服务员人允许他们进去用餐，然后对外说暂无座位。后来的客人必须在门口等待，直到有客人离开。这时，如果有一个客人离开，服务员告诉客人，可以进来用餐，如果又有客人离开，则又可以进来客人用餐，如此往复。&lt;br/&gt;在这个饭店中，座位是公共资源，每个人好比一个线程，服务员起的就是信号量的作用。信号量是一个非负整数，表示了当前公共资源的可用数目（在上面的例子中可以用空闲的座位类比信号量），当一个线程要使用公共资源时（在上面的例子中可以用客人比线程），首先要查看信号量，如果信号量的值大于1，则将其减1，然后去占有公共资源。如果信号量的值为0，则线程会将自己阻塞，直到有其它线程释放公共资源。&lt;/p&gt;
&lt;h4&gt;1、简单介绍Semaphore&lt;/h4&gt;
&lt;p&gt;a、可用来控制同时访问特定资源的线程数量，以此来达到协调线程工作。&lt;br/&gt;b、维护了一个虚拟的资源池，如果许可为0则线程阻塞等待，直到许可大于0时又可以有机会获取许可了。&lt;br/&gt;c、 内部也有公平锁、非公平锁来访问资源的静态内部类。&lt;/p&gt;
&lt;h4&gt;2、Semaphore方法&lt;/h4&gt;
&lt;p&gt;a、public Semaphore(int permits);// 创建一个给定许可数量的信号量对象，且默认以非公平锁方式获取资源&lt;br/&gt;b、public Semaphore(int permits, boolean fair);//创建一个给定许可数量的信号量对象，且是否公平方式由传入的fair布尔参数值决定&lt;br/&gt;c、public void acquire() ;//从此信号量获取一个许可，当许可数量小于零时，则阻塞等待&lt;br/&gt;d、public void acquire(int permits) ;//从此信号量获取permits个许可，当许可数量小于零时，则阻塞等待，但是当阻塞等待的线程被唤醒后发现被中断过的话则会抛InterruptedException异常&lt;br/&gt;e、public void acquireUninterruptibly(int permits) ;从此信号量获取permits个许可，当许可数量小于零时，则阻塞等待，但是当阻塞等待的线程被唤醒后发现被中断过的话则不会抛InterruptedException异常&lt;br/&gt;f、public void release();//释放一个许可&lt;br/&gt;g、public void release(int permits);释放permits个许可&lt;br/&gt;以上只是列出主要方法名，方法详细解释，Semaphore类上面都有注释。就不一一累出来了。&lt;/p&gt;
&lt;p&gt;举一个简单例子，帮助我们加深印象&lt;/p&gt;
&lt;pre class=&quot;hljs cpp&quot;&gt;
&lt;code class=&quot;cpp&quot;/&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果&lt;/p&gt;

&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;603&quot; data-height=&quot;339&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4327221-37b8f2b2188c2d73.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/603/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/4327221-37b8f2b2188c2d73.png&quot; data-original-width=&quot;603&quot; data-original-height=&quot;339&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;207334&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Fri, 14 Jun 2019 17:19:00 +0000</pubDate>
<dc:creator>爱在惜缘前</dc:creator>
<og:description>简单介绍 我们以饭店为例，假设饭店只有三个座位，一开始三个座位都是空的。这时如果同时来了三个客人，服务员人允许他们进去用餐，然后对外说暂无座位。后来的客人必须在门口等待，直到有客人离开。这时，如果有一</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/treeshu/p/11026065.html</dc:identifier>
</item>
<item>
<title>spark源码阅读--shuffle过程分析 - _朱葛</title>
<link>http://www.cnblogs.com/zhuge134/p/11026040.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhuge134/p/11026040.html</guid>
<description>&lt;p&gt;本篇,我们来看一下spark内核中另一个重要的模块，Shuffle管理器ShuffleManager。shuffle可以说是分布式计算中最重要的一个概念了，数据的join，聚合去重等操作都需要这个步骤。另一方面，spark之所以比mapReduce的性能高其中一个主要的原因就是对shuffle过程的优化，一方面spark的shuffle过程更好地利用内存（也就是我们前面在分析内存管理时所说的执行内存），另一方面对于shuffle过程中溢写的磁盘文件归并排序和引入索引文件。当然，spark性能高的另一个主要原因还有对计算链的优化，把多步map类型的计算chain在一起，大大减少中间过程的落盘，这也是spark显著区别于mr的地方。&lt;br/&gt;spark新版本的Shuffle管理器默认是SortShuffleManager。&lt;/p&gt;
&lt;p&gt;SparkEnv初始化部分的代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  val shortShuffleMgrNames = Map(
  &quot;sort&quot; -&amp;gt; classOf[org.apache.spark.shuffle.sort.SortShuffleManager].getName,
  &quot;tungsten-sort&quot; -&amp;gt; classOf[org.apache.spark.shuffle.sort.SortShuffleManager].getName)&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;shufflemaptask.runtask&quot;&gt;ShuffleMapTask.runTask&lt;/h3&gt;
&lt;p&gt;看shuffle管理器的源码，我们首先应该ShuffleManager的调用时机。想一下shuffle的过程，无非就是两个步骤，写和读。写是在map阶段，将数据按照一定的分区规则归类到不同的分区中，读是在reduce阶段，每个分区从map阶段的输出中拉取属于自己的数据，所以我们分析ShuffleManager源码基本也可以沿着这个思路。我们先来分析写的过程，因为对于一个完整的shuffle过程，肯定是先写然后才读的。&lt;br/&gt;回顾一下之前的对作业运行过程的分析，我们应该还记得作业被切分成任务后是在executor端执行的，而Shuffle阶段的的stage被切分成了ShuffleMapTask，shuffle的写过程正是在这个类中完成的，我们看一下代码：&lt;/p&gt;
&lt;p&gt;可以看到通过ShuffleManager.getWriter获取了一个shuffle写入器，从而将rdd的计算数据写入磁盘。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;override def runTask(context: TaskContext): MapStatus = {
// Deserialize the RDD using the broadcast variable.
val threadMXBean = ManagementFactory.getThreadMXBean
val deserializeStartTime = System.currentTimeMillis()
val deserializeStartCpuTime = if (threadMXBean.isCurrentThreadCpuTimeSupported) {
  threadMXBean.getCurrentThreadCpuTime
} else 0L
val ser = SparkEnv.get.closureSerializer.newInstance()
// 反序列化RDD和shuffle, 关键的步骤
// 这里思考rdd和shuffle反序列化时，内部的SparkContext对象是怎么反序列化的
val (rdd, dep) = ser.deserialize[(RDD[_], ShuffleDependency[_, _, _])](
  ByteBuffer.wrap(taskBinary.value), Thread.currentThread.getContextClassLoader)
_executorDeserializeTime = System.currentTimeMillis() - deserializeStartTime
_executorDeserializeCpuTime = if (threadMXBean.isCurrentThreadCpuTimeSupported) {
  threadMXBean.getCurrentThreadCpuTime - deserializeStartCpuTime
} else 0L

var writer: ShuffleWriter[Any, Any] = null
try {
  // shuffle管理器
  val manager = SparkEnv.get.shuffleManager
  // 获取一个shuffle写入器
  writer = manager.getWriter[Any, Any](dep.shuffleHandle, partitionId, context)
  // 这里可以看到rdd计算的核心方法就是iterator方法
  // SortShuffleWriter的write方法可以分为几个步骤：
  // 将上游rdd计算出的数据(通过调用rdd.iterator方法)写入内存缓冲区，
  // 在写的过程中如果超过 内存阈值就会溢写磁盘文件，可能会写多个文件
  // 最后将溢写的文件和内存中剩余的数据一起进行归并排序后写入到磁盘中形成一个大的数据文件
  // 这个排序是先按分区排序，在按key排序
  // 在最后归并排序后写的过程中，没写一个分区就会手动刷写一遍，并记录下这个分区数据在文件中的位移
  // 所以实际上最后写完一个task的数据后，磁盘上会有两个文件：数据文件和记录每个reduce端partition数据位移的索引文件
  writer.write(rdd.iterator(partition, context).asInstanceOf[Iterator[_ &amp;lt;: Product2[Any, Any]]])
  // 主要是删除中间过程的溢写文件，向内存管理器释放申请的内存
  writer.stop(success = true).get
} catch {
  case e: Exception =&amp;gt;
    try {
      if (writer != null) {
        writer.stop(success = false)
      }
    } catch {
      case e: Exception =&amp;gt;
        log.debug(&quot;Could not stop writer&quot;, e)
    }
    throw e
}
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;sortshufflemanager.getwriter&quot;&gt;SortShuffleManager.getWriter&lt;/h3&gt;
&lt;p&gt;这里根据shuffle类型获取不同的ShuffleWriter对象，大多数情况下，都是SortShuffleWriter类型，所以我们直接看SortShuffleWriter.write方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/** Get a writer for a given partition. Called on executors by map tasks. */
// 获取一个shuffle存储器，在executor端被调用，在执行一个map task调用
override def getWriter[K, V](
  handle: ShuffleHandle,
  mapId: Int,
  context: TaskContext): ShuffleWriter[K, V] = {
numMapsForShuffle.putIfAbsent(
  handle.shuffleId, handle.asInstanceOf[BaseShuffleHandle[_, _, _]].numMaps)
val env = SparkEnv.get
handle match {
  case unsafeShuffleHandle: SerializedShuffleHandle[K @unchecked, V @unchecked] =&amp;gt;
    new UnsafeShuffleWriter(
      env.blockManager,
      shuffleBlockResolver.asInstanceOf[IndexShuffleBlockResolver],
      context.taskMemoryManager(),
      unsafeShuffleHandle,
      mapId,
      context,
      env.conf)
  case bypassMergeSortHandle: BypassMergeSortShuffleHandle[K @unchecked, V @unchecked] =&amp;gt;
    new BypassMergeSortShuffleWriter(
      env.blockManager,
      shuffleBlockResolver.asInstanceOf[IndexShuffleBlockResolver],
      bypassMergeSortHandle,
      mapId,
      context,
      env.conf)
  case other: BaseShuffleHandle[K @unchecked, V @unchecked, _] =&amp;gt;
    new SortShuffleWriter(shuffleBlockResolver, other, mapId, context)
}
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;sortshufflewriter.write&quot;&gt;SortShuffleWriter.write&lt;/h3&gt;
&lt;p&gt;总结一下这个方法的主要逻辑：&lt;/p&gt;
&lt;ul readability=&quot;13&quot;&gt;&lt;li&gt;获取一个排序器，根据是否需要map端聚合传递不同的参数&lt;/li&gt;
&lt;li&gt;将数据插入排序器中，这个过程或溢写出多个磁盘文件&lt;/li&gt;
&lt;li&gt;根据shuffleid和分区id获取一个磁盘文件名，&lt;/li&gt;
&lt;li&gt;将多个溢写的磁盘文件和内存中的排序数据进行归并排序，并写到一个文件中，同时返回每个reduce端分区的数据在这个文件中的位移&lt;/li&gt;
&lt;li&gt;将索引写入一个索引文件，并将数据文件的文件名由临时文件名改成正式的文件名。&lt;/li&gt;
&lt;li&gt;最后封装一个MapStatus对象，用于ShuffleMapTask.runTask的返回值。&lt;/li&gt;
&lt;li readability=&quot;29&quot;&gt;
&lt;p&gt;在stop方法中还会做一些收尾工作，统计磁盘io耗时，删除中间溢写文件&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  override def write(records: Iterator[Product2[K, V]]): Unit = {
  sorter = if (dep.mapSideCombine) {
    // map端进行合并的情况，此时用户应该提供聚合器和顺序
    require(dep.aggregator.isDefined, &quot;Map-side combine without Aggregator specified!&quot;)
    new ExternalSorter[K, V, C](
      context, dep.aggregator, Some(dep.partitioner), dep.keyOrdering, dep.serializer)
  } else {
    // In this case we pass neither an aggregator nor an ordering to the sorter, because we don't
    // care whether the keys get sorted in each partition; that will be done on the reduce side
    // if the operation being run is sortByKey.
    new ExternalSorter[K, V, V](
      context, aggregator = None, Some(dep.partitioner), ordering = None, dep.serializer)
  }
  // 将map数据全部写入排序器中，
  // 这个过程中可能会生成多个溢写文件
  sorter.insertAll(records)

  // Don't bother including the time to open the merged output file in the shuffle write time,
  // because it just opens a single file, so is typically too fast to measure accurately
  // (see SPARK-3570).
  // mapId就是shuffleMap端RDD的partitionId
  // 获取这个map分区的shuffle输出文件名
  val output = shuffleBlockResolver.getDataFile(dep.shuffleId, mapId)
  // 加一个uuid后缀
  val tmp = Utils.tempFileWith(output)
  try {
    val blockId = ShuffleBlockId(dep.shuffleId, mapId, IndexShuffleBlockResolver.NOOP_REDUCE_ID)
    // 这一步将溢写到的磁盘的文件和内存中的数据进行归并排序，
    // 并溢写到一个文件中，这一步写的文件是临时文件名
    val partitionLengths = sorter.writePartitionedFile(blockId, tmp)
    // 这一步主要是写入索引文件，使用move方法原子第将临时索引和临时数据文件重命名为正常的文件名
    shuffleBlockResolver.writeIndexFileAndCommit(dep.shuffleId, mapId, partitionLengths, tmp)
    // 返回一个状态对象，包含shuffle服务Id和各个分区数据在文件中的位移
    mapStatus = MapStatus(blockManager.shuffleServerId, partitionLengths)
  } finally {
    if (tmp.exists() &amp;amp;&amp;amp; !tmp.delete()) {
      logError(s&quot;Error while deleting temp file ${tmp.getAbsolutePath}&quot;)
    }
  }
  }&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;indexshuffleblockresolver&quot;&gt;IndexShuffleBlockResolver&lt;/h4&gt;
&lt;p&gt;我们首先看一下获取shuffle输出文件名，是通过IndexShuffleBlockResolver组件获取的，而它的内部又是通过BlockManager内部的DiskBlockManager分配文件名的，这个DiskBlockManager我在之前分析块管理器时提到过，它的作用就是管理文件名的分配，以及spark使用的目录，子目录的创建删除等。我们看到对于数据文件和索引文件的命名规则是不一样的，他们的命名规则分别定义在ShuffleDataBlockId和ShuffleIndexBlockId中。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def getDataFile(shuffleId: Int, mapId: Int): File = {
  blockManager.diskBlockManager.getFile(ShuffleDataBlockId(shuffleId, mapId, NOOP_REDUCE_ID))
}

private def getIndexFile(shuffleId: Int, mapId: Int): File = {
  blockManager.diskBlockManager.getFile(ShuffleIndexBlockId(shuffleId, mapId, NOOP_REDUCE_ID))
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;externalsorter.insertall&quot;&gt;ExternalSorter.insertAll&lt;/h3&gt;
&lt;p&gt;我们根据SortShuffleWriter中的调用顺序，首先看一下ExternalSorter.insertAll方法：&lt;/p&gt;
&lt;ul readability=&quot;5&quot;&gt;&lt;li&gt;首选根据是否在爱map端合并分为两种情况，这两种情况使用的内存存储结构也不一样，对于在map端合并的情况使用的是PartitionedAppendOnlyMap结构，不在map合并则使用PartitionedPairBuffer。其中，PartitionedAppendOnlyMap是用数组和线性探测法实现的map结构。&lt;/li&gt;
&lt;li readability=&quot;13&quot;&gt;
&lt;p&gt;然后将数据一条一条地循环插入内存的存储结构中，同时考虑到map端合并的情况&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  def insertAll(records: Iterator[Product2[K, V]]): Unit = {
  // TODO: stop combining if we find that the reduction factor isn't high
  val shouldCombine = aggregator.isDefined

  // 在map端进行合并的情况
  if (shouldCombine) {
    // Combine values in-memory first using our AppendOnlyMap
    val mergeValue = aggregator.get.mergeValue
    val createCombiner = aggregator.get.createCombiner
    var kv: Product2[K, V] = null
    val update = (hadValue: Boolean, oldValue: C) =&amp;gt; {
      if (hadValue) mergeValue(oldValue, kv._2) else createCombiner(kv._2)
    }
    while (records.hasNext) {
      addElementsRead()
      kv = records.next()
      // 向内存缓冲中插入一条数据
      map.changeValue((getPartition(kv._1), kv._1), update)
      // 如果缓冲超过阈值，就会溢写到磁盘生成一个文件
      // 每写入一条数据就检查一遍内存
      maybeSpillCollection(usingMap = true)
    }
  } else {// 不再map端合并的情况
    // Stick values into our buffer
    while (records.hasNext) {
      addElementsRead()
      val kv = records.next()
      buffer.insert(getPartition(kv._1), kv._1, kv._2.asInstanceOf[C])
      maybeSpillCollection(usingMap = false)
    }
  }
  }&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;appendonlymap.changevalue&quot;&gt;AppendOnlyMap.changeValue&lt;/h3&gt;
&lt;p&gt;我们看一个稍微复杂一点的结构，AppendOnlyMap，&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先考虑空值的情况&lt;/li&gt;
&lt;li&gt;计算key的hash,然后对容量取余。注意，这里由于容量是2的整数次幂，所以对容量取余的操作等同于和容量-1进行位与操作，java HashMap中的操作。&lt;/li&gt;
&lt;li&gt;如果，不存在旧值，那么直接插入，&lt;/li&gt;
&lt;li&gt;如果存在旧值，更新旧值&lt;/li&gt;
&lt;li&gt;如果发生hash碰撞，那么需要向后探测，并且是跳跃性的探测，&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;可以看出，这个结构设计还是很精良的，这里面有个很重的方法，incrementSize方法中会判断当前数据量的大小，如果超过阈值就会扩容，这个扩容的方法比较复杂，就是一个重新hash再分布的过程，不过有一点，发不论是在插入新数据还是重新hash再分布的过程中，对于hash碰撞的处理策略一定要相同，否则可能造成不一致。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 向数组中插入一个kv对，
def changeValue(key: K, updateFunc: (Boolean, V) =&amp;gt; V): V = {
assert(!destroyed, destructionMessage)
val k = key.asInstanceOf[AnyRef]
// 处理key为空的情况
if (k.eq(null)) {
  // 如果是第一次插入空值，那么需要将大小增加1
  if (!haveNullValue) {
    incrementSize()
  }
  nullValue = updateFunc(haveNullValue, nullValue)
  haveNullValue = true
  return nullValue
}
var pos = rehash(k.hashCode) &amp;amp; mask
// 线性探测法处理hash碰撞
// 这里是一个加速的线性探测，即第一次碰撞时走1步，
// 第二次碰撞时走2步，第三次碰撞时走3步
var i = 1
while (true) {
  val curKey = data(2 * pos)
  if (curKey.eq(null)) {// 如果旧值不存在，直接插入
    val newValue = updateFunc(false, null.asInstanceOf[V])
    data(2 * pos) = k
    data(2 * pos + 1) = newValue.asInstanceOf[AnyRef]
    incrementSize()
    return newValue
  } else if (k.eq(curKey) || k.equals(curKey)) {// 如果旧值存在，需要更新
    val newValue = updateFunc(true, data(2 * pos + 1).asInstanceOf[V])
    data(2 * pos + 1) = newValue.asInstanceOf[AnyRef]
    return newValue
  } else {// 发生hash碰撞，向后探测，跳跃性的探测
    val delta = i
    pos = (pos + delta) &amp;amp; mask
    i += 1
  }
}
null.asInstanceOf[V] // Never reached but needed to keep compiler happy
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;externalsorter.maybespillcollection&quot;&gt;ExternalSorter.maybeSpillCollection&lt;/h3&gt;
&lt;p&gt;我们回到ExternalSorter的插入方法中，没插入一条数据都要检查内存占用，判断是否需要溢写到磁盘，如果需要就溢写到磁盘。&lt;br/&gt;这个方法里调用了map.estimateSize来估算当前插入的数据的内存占用大小，对于内存占用的追踪和估算的功能是在SizeTracker特质中实现的，这个特质我在之前分析MemoryStore时提到过，在将对象类型的数据插入内存中时使用了一个中间态的数据结构DeserializedValuesHolder,它的内部有一个SizeTrackingVector，这个类就是通过继承SizeTracker特征从而实现对象大小的追踪和估算。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private def maybeSpillCollection(usingMap: Boolean): Unit = {
var estimatedSize = 0L
if (usingMap) {
  estimatedSize = map.estimateSize()
  if (maybeSpill(map, estimatedSize)) {
    map = new PartitionedAppendOnlyMap[K, C]
  }
} else {
  estimatedSize = buffer.estimateSize()
  if (maybeSpill(buffer, estimatedSize)) {
    buffer = new PartitionedPairBuffer[K, C]
  }
}

if (estimatedSize &amp;gt; _peakMemoryUsedBytes) {
  _peakMemoryUsedBytes = estimatedSize
}
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;externalsorter.maybespill&quot;&gt;ExternalSorter.maybeSpill&lt;/h3&gt;
&lt;p&gt;首先检查当前内存占用是否超过阈值，如果超过会申请一次执行内存，如果没有申请到足够的执行内存，那么依然需要溢写到磁盘&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;protected def maybeSpill(collection: C, currentMemory: Long): Boolean = {
var shouldSpill = false
// 每写入32条数据检查一次
if (elementsRead % 32 == 0 &amp;amp;&amp;amp; currentMemory &amp;gt;= myMemoryThreshold) {
  // Claim up to double our current memory from the shuffle memory pool
  val amountToRequest = 2 * currentMemory - myMemoryThreshold
  // 向内存管理器申请执行内存
  val granted = acquireMemory(amountToRequest)
  myMemoryThreshold += granted
  // If we were granted too little memory to grow further (either tryToAcquire returned 0,
  // or we already had more memory than myMemoryThreshold), spill the current collection
  // 如果内存占用超过了阈值，那么就需要溢写
  shouldSpill = currentMemory &amp;gt;= myMemoryThreshold
}
shouldSpill = shouldSpill || _elementsRead &amp;gt; numElementsForceSpillThreshold
// Actually spill
if (shouldSpill) {
  _spillCount += 1
  logSpillage(currentMemory)
  // 溢写到磁盘
  spill(collection)
  _elementsRead = 0
  _memoryBytesSpilled += currentMemory
  // 释放内存
  releaseMemory()
}
shouldSpill
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;externalsorter.spill&quot;&gt;ExternalSorter.spill&lt;/h3&gt;
&lt;p&gt;接着上面的方法，&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;override protected[this] def spill(collection: WritablePartitionedPairCollection[K, C]): Unit = {
// 获取一个排序后的迭代器
val inMemoryIterator = collection.destructiveSortedWritablePartitionedIterator(comparator)
// 将数据写入磁盘文件中
val spillFile = spillMemoryIteratorToDisk(inMemoryIterator)
spills += spillFile
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;writablepartitionedpaircollection.destructivesortedwritablepartitionediterator&quot;&gt;WritablePartitionedPairCollection.destructiveSortedWritablePartitionedIterator&lt;/h4&gt;
&lt;p&gt;这个方法返回按照分区和key排序过的迭代器，其具体的排序逻辑在AppendOnlyMap.destructiveSortedIterator中&lt;/p&gt;
&lt;h4 id=&quot;appendonlymap.destructivesortediterator&quot;&gt;AppendOnlyMap.destructiveSortedIterator&lt;/h4&gt;
&lt;p&gt;这段代码分为两块，首先对数组进行压紧，是的稀疏的数据全部转移到数组的头部；&lt;br/&gt;然后对数组按照比较器进行排序，比较器首先是按照分区进行比较，如果分区相同才按照key进行比较；&lt;br/&gt;然后返回一个迭代器，这个迭代器仅仅是对数组的封装。通过这个方法，我们大概知道了AppendonlyMap的排序逻辑。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def destructiveSortedIterator(keyComparator: Comparator[K]): Iterator[(K, V)] = {
destroyed = true
// Pack KV pairs into the front of the underlying array
// 这段代码将稀疏的数据全部转移到数组头部，将数据压紧
var keyIndex, newIndex = 0
while (keyIndex &amp;lt; capacity) {
  if (data(2 * keyIndex) != null) {
    data(2 * newIndex) = data(2 * keyIndex)
    data(2 * newIndex + 1) = data(2 * keyIndex + 1)
    newIndex += 1
  }
  keyIndex += 1
}
assert(curSize == newIndex + (if (haveNullValue) 1 else 0))

// 根据比较器对数据进行排序
new Sorter(new KVArraySortDataFormat[K, AnyRef]).sort(data, 0, newIndex, keyComparator)

new Iterator[(K, V)] {
  var i = 0
  var nullValueReady = haveNullValue
  def hasNext: Boolean = (i &amp;lt; newIndex || nullValueReady)
  def next(): (K, V) = {
    if (nullValueReady) {
      nullValueReady = false
      (null.asInstanceOf[K], nullValue)
    } else {
      val item = (data(2 * i).asInstanceOf[K], data(2 * i + 1).asInstanceOf[V])
      i += 1
      item
    }
  }
}
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;externalsorter.spillmemoryiteratortodisk&quot;&gt;ExternalSorter.spillMemoryIteratorToDisk&lt;/h3&gt;
&lt;p&gt;回到ExternalSorter.spill方法中，在获取了经过排序后 的迭代器之后，我们就可以将数据溢写到磁盘上了。&lt;br/&gt;这个方法的代码我不贴了，总结一下主要步骤：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先通过DiskBlockManager获取一个临时块的BlockId和临时文件名&lt;/li&gt;
&lt;li&gt;通过blockManager获取一个磁盘写入器，即DiskBlockObjectWriter对象，内部封装了调用java流api写文件的逻辑&lt;/li&gt;
&lt;li&gt;循环将每条数据写入磁盘，并定期进行刷写（每隔一定的数据条数将内存中的数据刷写到磁盘上）&lt;/li&gt;
&lt;li&gt;如果发生异常，则会对之前写入的文件进行回滚&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;小结&quot;&gt;小结&lt;/h3&gt;
&lt;p&gt;总结一下数据通过ExternalSorter向磁盘溢写的全过程：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先，数据会被一条一条地向内部的map结构中插入&lt;/li&gt;
&lt;li&gt;每插入一条数据都会检查内存占用情况，如果内存占用超过阈值，并且申请不到足够的执行内存，就会将目前内存中的数据溢写到磁盘&lt;/li&gt;
&lt;li&gt;对于溢写的过程：首先会将数据按照分区和key进行排序，相同分区的数据排在一起，然后根据提供的排序器按照key的顺序排；然后通过DiskBlockManager和BlockManager获取DiskBlockWriter将数据写入磁盘形成一个文件。，并将溢写的文件信息&lt;/li&gt;
&lt;li&gt;在整个写入过程中，会溢写多个文件&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;externalsorter.writepartitionedfile&quot;&gt;ExternalSorter.writePartitionedFile&lt;/h2&gt;
&lt;p&gt;总结一下主要的步骤：&lt;/p&gt;
&lt;ul readability=&quot;5&quot;&gt;&lt;li&gt;仍然是通过blockManager获取一个磁盘写入器&lt;/li&gt;
&lt;li&gt;将内部溢写的多个磁盘文件和滞留在内存的数据进行归并排序，并分装成一个按照分区归类的迭代器&lt;/li&gt;
&lt;li readability=&quot;13&quot;&gt;
&lt;p&gt;循环将数据写入磁盘，每当一个分区的数据写完后，进行一次刷写，将数据从os的文件缓冲区同步到磁盘上，然后获取此时的文件长度，记录下每个分区在文件中的位移&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  def writePartitionedFile(
    blockId: BlockId,
    outputFile: File): Array[Long] = {

  // Track location of each range in the output file
  val lengths = new Array[Long](numPartitions)
  val writer = blockManager.getDiskWriter(blockId, outputFile, serInstance, fileBufferSize,
    context.taskMetrics().shuffleWriteMetrics)

  // 如果前面没有数据溢写到磁盘中，
  // 则只需要将内存中的数据溢写到磁盘
  if (spills.isEmpty) {
    // Case where we only have in-memory data
    val collection = if (aggregator.isDefined) map else buffer
    // 返回排序后的迭代器
    val it = collection.destructiveSortedWritablePartitionedIterator(comparator)
    while (it.hasNext) {
      val partitionId = it.nextPartition()
      while (it.hasNext &amp;amp;&amp;amp; it.nextPartition() == partitionId) {
        it.writeNext(writer)
      }
      // 写完一个分区刷写一次
      val segment = writer.commitAndGet()
      // 记录下分区的数据在文件中的位移
      lengths(partitionId) = segment.length
    }
  } else {// 有溢写到磁盘的文件
    // We must perform merge-sort; get an iterator by partition and write everything directly.
    // 封装一个用于归并各个溢写文件以及内存缓冲区数据的迭代器
    // TODO 这个封装的迭代器是实现归并排序的关键
    for ((id, elements) &amp;lt;- this.partitionedIterator) {
      if (elements.hasNext) {
        for (elem &amp;lt;- elements) {
          writer.write(elem._1, elem._2)
        }
        // 每写完一个分区，主动刷写一次，获取文件位移，
        // 这个位移就是写入的分区的位移，
        // reduce端在拉取数据时就会根据这个位移直接找到应该拉取的数据的位置
        val segment = writer.commitAndGet()
        lengths(id) = segment.length
      }
    }
  }

  writer.close()
  // 写完后更新一些统计信息
  context.taskMetrics().incMemoryBytesSpilled(memoryBytesSpilled)
  context.taskMetrics().incDiskBytesSpilled(diskBytesSpilled)
  context.taskMetrics().incPeakExecutionMemory(peakMemoryUsedBytes)

  // 返回每个reduce端分区数据在文件中的位移信息
  lengths
  }&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;indexshuffleblockresolver.writeindexfileandcommit&quot;&gt;IndexShuffleBlockResolver.writeIndexFileAndCommit&lt;/h3&gt;
&lt;p&gt;仍然回到SortShuffleWriter.write方法，最后一步调用了IndexShuffleBlockResolver.writeIndexFileAndCommit方法，&lt;br/&gt;这个方法的作用主要是将每个的分区的位移值写入到一个索引文件中，并将临时的索引文件和临时的数据文件重命名为正常的文件名（重命名操作是一个原子操作）&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;我总结shuffle写数据的过程，可以分为两个主要的步骤：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一是在数据写入的过程中会由于内存不足从而溢写多个数据文件到磁盘中，而所有的文件都是按照分区和key排序的，这为第二部归并排序打下基础&lt;/li&gt;
&lt;li&gt;第二部就是将这些溢写的小文件和最后内存中剩下的数据进行归并排序，然后写入一个大文件中，并且在写入的过程中记录每个分区数据在文件中的位移，&lt;/li&gt;
&lt;li&gt;最后还要写入一个索引文件，索引文件即记录了每个reduce端分区在数据文件中的位移，这样reduce在拉取数据的时候才能很快定位到自己分区所需要的数据&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Fri, 14 Jun 2019 16:43:00 +0000</pubDate>
<dc:creator>_朱葛</dc:creator>
<og:description>ShuffleManager（一） 本篇,我们来看一下spark内核中另一个重要的模块，Shuffle管理器ShuffleManager。shuffle可以说是分布式计算中最重要的一个概念了，数据的j</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhuge134/p/11026040.html</dc:identifier>
</item>
<item>
<title>扫雷小游戏-纯网页版 - Yokeqi</title>
<link>http://www.cnblogs.com/yokeqi/p/11025879.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yokeqi/p/11025879.html</guid>
<description>&lt;p&gt;这两天在恶补前端的相关知识，看到JQuery的动画部分时，突然心血来潮想做一个扫雷的网页版，于是花了差不多一天的时间完成了一个初始版本，权当对这几天学习成果的一个回顾，若某处功能有更好实现方式欢迎留言一起讨论。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;========== 原创作品，未经本人允许，请勿转载，谢谢！ ==========&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;==========  &lt;a href=&quot;https://www.cnblogs.com/yokeqi/p/11025879.html&quot; target=&quot;_blank&quot;&gt;  作者：Yokeqi    出处：博客园    原文链接   &lt;/a&gt;==========&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;先看看最后实现的效果：&lt;span&gt;如何内嵌一个页面？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1697247/201906/1697247-20190615000753125-1659961498.png&quot; alt=&quot;&quot; width=&quot;890&quot; height=&quot;710&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1697247/201906/1697247-20190615000741741-482853316.png&quot; alt=&quot;&quot; width=&quot;289&quot; height=&quot;360&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1697247/201906/1697247-20190615000801731-1088473528.png&quot; alt=&quot;&quot; width=&quot;293&quot; height=&quot;372&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 一、知识点介绍&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1. Html + CSS + JQuery库&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;要创建界面UI，所以需要用到各类Html标签还有CSS的布局美化。&lt;/li&gt;
&lt;li&gt;要实现各类逻辑功能，所以需要用到JQuery的选择器、事件等知识。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;2. 扫雷游戏的玩法&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;翻开某个格子，如果是雷，那么就会Boom，游戏结束。&lt;/li&gt;
&lt;li&gt;如果是空白，则代表以这个格子为中心的九宫格范围内没有雷。&lt;/li&gt;
&lt;li&gt;如果是数字，则根据数字代表这个格子为中心的九宫格范围内存在多少颗雷。&lt;/li&gt;
&lt;li&gt;正确标记出所有的雷，并翻开多余的格子，则游戏胜利。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;二、关键代码说明&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1. 创建数据地图，接下来只需要根据数据地图创建对应UI就可以了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('c380d22d-139f-4726-8504-3a9078f196ea')&quot; readability=&quot;35&quot;&gt;&lt;img id=&quot;code_img_closed_c380d22d-139f-4726-8504-3a9078f196ea&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_c380d22d-139f-4726-8504-3a9078f196ea&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('c380d22d-139f-4726-8504-3a9078f196ea',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_c380d22d-139f-4726-8504-3a9078f196ea&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; createMap() {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化为0&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; num; i++&lt;span&gt;) {
        map[i] &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Array();
        mark[i] &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Array();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; j = 0; j &amp;lt; num; j++&lt;span&gt;) {
            map[i][j] &lt;/span&gt;= 0&lt;span&gt;;
            mark[i][j] &lt;/span&gt;= 0&lt;span&gt;;
        }
    }

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; count = 0&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 生成雷&lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt; (count &amp;lt;&lt;span&gt; boomNum) {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; row = Math.floor(Math.random() * (num - 1&lt;span&gt;));
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; col = Math.floor(Math.random() * (num - 1&lt;span&gt;));
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isMine(row, col)) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这个位置已经有雷,重新生成位置&lt;/span&gt;
            &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
        }
        count&lt;/span&gt;++&lt;span&gt;;
        map[row][col] &lt;/span&gt;= 100&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 周围的雷数标记+1&lt;/span&gt;
        searchAround(row, col, &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (posX, posY) {
            map[posX][posY]&lt;/span&gt;++&lt;span&gt;;
        });
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;for (var i = 0; i &amp;lt; at.length; i++) {&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    var posX = row + at[i][0];&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    var posY = col + at[i][1];&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    // 不要超出地图范围&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    if (posX &amp;lt; 0 || posY &amp;lt; 0 || posX &amp;gt; map.length || posY &amp;gt; map[0].length)&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;        continue;&lt;/span&gt;

        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    map[posX][posY]++;&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;
&lt;span&gt;    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;2. 创建界面UI&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('bac49113-b96a-4907-b5b8-c1f3970663d9')&quot; readability=&quot;34.5&quot;&gt;&lt;img id=&quot;code_img_closed_bac49113-b96a-4907-b5b8-c1f3970663d9&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_bac49113-b96a-4907-b5b8-c1f3970663d9&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('bac49113-b96a-4907-b5b8-c1f3970663d9',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_bac49113-b96a-4907-b5b8-c1f3970663d9&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; createUI() {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 生成界面&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; num; i++&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; j = 0; j &amp;lt; num; j++&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; l = offsetX + i *&lt;span&gt; boxSize;
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; t = offsetY + j *&lt;span&gt; boxSize;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建容器Box&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; box = $(&quot;&amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;&quot;).addClass(&quot;box&quot;).css({ &quot;left&quot;: l + &quot;px&quot;, &quot;top&quot;: t + &quot;px&quot; }).attr({ &quot;row&quot;: i, &quot;col&quot;&lt;span&gt;: j });
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建遮罩层&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; cover = $(&quot;&amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;&quot;).addClass(&quot;cover&quot;).width(boxSize - 1).height(boxSize - 1);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 遮罩层，这样就直接看不到底下是不是雷&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建实际内容&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; content = $(&quot;&amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;&quot;).addClass(&quot;content&quot;).width(boxSize - 1).height(boxSize - 1).hide();&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 内容，可能是空白，可能是个提示数字，也可能就是个雷&lt;/span&gt;

            &lt;span&gt;if&lt;/span&gt; (map[i][j] &amp;gt;= 100&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果是雷，则把格子数据替换成一张Gif图。&lt;/span&gt;
                &lt;span&gt;var&lt;/span&gt; boom = $(&quot;&amp;lt;img&amp;gt;&amp;lt;/img&amp;gt;&quot;).attr(&quot;src&quot;, &quot;./imgs/boom.gif&quot;).width(40).height(40&lt;span&gt;);
                content.css(&lt;/span&gt;&quot;margin&quot;, &quot;0px&quot;&lt;span&gt;).html(boom);
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (map[i][j] &amp;gt; 0&lt;span&gt;) {
                content.text(map[i][j]);
            }

            box.append(cover).append(content);
            $(&lt;/span&gt;&quot;#panel&quot;&lt;span&gt;).append(box);
        }
    };
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;3. 注册几个核心事件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('31eba2be-7536-475d-8c5e-8b5db716f593')&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_31eba2be-7536-475d-8c5e-8b5db716f593&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_31eba2be-7536-475d-8c5e-8b5db716f593&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('31eba2be-7536-475d-8c5e-8b5db716f593',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_31eba2be-7536-475d-8c5e-8b5db716f593&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; registerEvents() {
    $(&lt;/span&gt;&quot;.box&quot;).hover(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; row = $(&lt;span&gt;this&lt;/span&gt;).attr(&quot;row&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; col = $(&lt;span&gt;this&lt;/span&gt;).attr(&quot;col&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (mark[row][col] == 0&lt;span&gt;)
            $(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;).children(&quot;.cover&quot;).css(&quot;backgroundColor&quot;, &quot;lightgray&quot;&lt;span&gt;);
    });
    $(&lt;/span&gt;&quot;.box&quot;).mouseleave(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; row = $(&lt;span&gt;this&lt;/span&gt;).attr(&quot;row&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; col = $(&lt;span&gt;this&lt;/span&gt;).attr(&quot;col&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (mark[row][col] == 0&lt;span&gt;)
            $(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;).children(&quot;.cover&quot;).css(&quot;backgroundColor&quot;, &quot;black&quot;&lt;span&gt;);
    });
    $(&lt;/span&gt;&quot;.box&quot;).dblclick(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 挖格子，看运气是不是雷&lt;/span&gt;
        sweeper($(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;));
    });

    $(&lt;/span&gt;&quot;.box&quot;).click(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; row = $(&lt;span&gt;this&lt;/span&gt;).attr(&quot;row&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; col = $(&lt;span&gt;this&lt;/span&gt;).attr(&quot;col&quot;&lt;span&gt;);
        mark[row][col] &lt;/span&gt;= mark[row][col] == 1 ? 0 : 1; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 旗子标记&lt;/span&gt;

        &lt;span&gt;var&lt;/span&gt; color = mark[row][col] == 1 ? &quot;red&quot; : &quot;black&quot;&lt;span&gt;;
        $(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;).children(&quot;.cover&quot;).css(&quot;backgroundColor&quot;&lt;span&gt;, color);

        valid(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 验证是否成功通关。&lt;/span&gt;
&lt;span&gt;    });
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;4. 挖格子功能&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('c9aec6b4-e280-47be-a928-8e3e2074b53c')&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_c9aec6b4-e280-47be-a928-8e3e2074b53c&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_c9aec6b4-e280-47be-a928-8e3e2074b53c&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('c9aec6b4-e280-47be-a928-8e3e2074b53c',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_c9aec6b4-e280-47be-a928-8e3e2074b53c&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; isMine(row, col) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; map[row][col] &amp;gt;= 100&lt;span&gt;;
}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; sweeper(box) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; row = box.attr(&quot;row&quot;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; col = box.attr(&quot;col&quot;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isMine(row, col)) {
        $(&lt;/span&gt;&quot;.cover&quot;).fadeOut(&quot;slow&quot;).siblings(&quot;.content&quot;).fadeIn(&quot;slow&quot;&lt;span&gt;);
        box.delay(&lt;/span&gt;1).queue(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
            $(&lt;/span&gt;&quot;#msg&quot;).text(&quot;Boom!!!游戏结束.&quot;).show(&quot;slow&quot;&lt;span&gt;);
        });

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果遇到空白，则自动挖开以此为中心的九宫格，并且递归搜索。&lt;/span&gt;
&lt;span&gt;    autoSweeper(row, col);

    valid();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;5. 增加了一个简单的深搜，挖到空白格子则自动挖出以此为中心的九宫格，并且遇到同样空白格子会继续挖。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('ace01afe-691c-4782-b3c3-2eb66d4912b2')&quot; readability=&quot;36&quot;&gt;&lt;img id=&quot;code_img_closed_ace01afe-691c-4782-b3c3-2eb66d4912b2&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_ace01afe-691c-4782-b3c3-2eb66d4912b2&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('ace01afe-691c-4782-b3c3-2eb66d4912b2',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_ace01afe-691c-4782-b3c3-2eb66d4912b2&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;67&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; autoSweeper(row, col) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; cover = $(&quot;.box[row=&quot; + row + &quot;][col=&quot; + col + &quot;]&quot;).children(&quot;.cover&quot;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (cover.is(&quot;:hidden&quot;&lt;span&gt;))
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;

    cover.hide(&lt;/span&gt;&quot;fast&quot;).siblings(&quot;.content&quot;).show(&quot;fast&quot;, &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (map[row][col] != 0&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果挖到空白格子，则自动挖四周&lt;/span&gt;
&lt;span&gt;        searchAround(row, col, autoSweeper);
    });
}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; searchAround(row, col, action) {
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; at.length; i++&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; posX = parseInt(row) + at[i][0&lt;span&gt;];
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; posY = parseInt(col) + at[i][1&lt;span&gt;];
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 不要超出地图范围&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (posX &amp;lt; 0 || posY &amp;lt; 0 || posX &amp;gt;= map.length || posY &amp;gt;= map[0&lt;span&gt;].length)
            &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;

        action(posX, posY);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;6. 简单验证下是否达成通关条件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('0d3fe6e3-730e-43c9-9641-d05229541445')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_0d3fe6e3-730e-43c9-9641-d05229541445&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_0d3fe6e3-730e-43c9-9641-d05229541445&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('0d3fe6e3-730e-43c9-9641-d05229541445',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_0d3fe6e3-730e-43c9-9641-d05229541445&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; valid() {

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; count =&lt;span&gt; boomNum;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; num; i++&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; j = 0; j &amp;lt; num; j++&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (mark[i][j] == 1 &amp;amp;&amp;amp; map[i][j] &amp;gt;= 100&lt;span&gt;) {
                count&lt;/span&gt;--&lt;span&gt;;
            }
        }
    }

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (count == 0&lt;span&gt;) {
        $(&lt;/span&gt;&quot;.cover&quot;).fadeOut(&quot;fast&quot;).siblings(&quot;.content&quot;).fadeIn(&quot;fast&quot;&lt;span&gt;);
        $(&lt;/span&gt;&quot;.cover&quot;).delay(1).queue(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
            $(&lt;/span&gt;&quot;#msg&quot;).text(&quot;恭喜你！成功过关.&quot;).show(&quot;slow&quot;&lt;span&gt;);
        });
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;三、参考资料&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 14 Jun 2019 15:45:00 +0000</pubDate>
<dc:creator>Yokeqi</dc:creator>
<og:description>这两天在恶补前端的相关知识，看到JQuery的动画部分时，突然心血来潮想做一个扫雷的网页版，于是花了差不多一天的时间完成了一个初始版本，权当对这几天学习成果的一个回顾，若某处功能有更好实现方式欢迎留言</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yokeqi/p/11025879.html</dc:identifier>
</item>
<item>
<title>rtmp流媒体协议播放遇到的坑 - angelfinding</title>
<link>http://www.cnblogs.com/wujx9/p/11025915.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wujx9/p/11025915.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;前提：&lt;/strong&gt;&lt;/span&gt;前端网页是不能直接播放rtmp或rtsp直播流的。&lt;/p&gt;
&lt;p&gt;项目中需要播放工场仓储物流的实时监控摄像头。经过各种调研，发现video.min.js+videojs-flash.min.js,再加上浏览器安装了adobe flash播放器，则能完美实时播放rtmp视频了。&lt;/p&gt;
&lt;p&gt;但是用video.min.js也踩了个严重的坑，很多Bug都是这样，不大，但愁人！&lt;/p&gt;
&lt;p&gt;上次看一有趣的前端Bug，说一个前端开发人员一个Bug找了一个晚上，竟不知啥原因。描述是这样，是个地图项目，却发现地图怎么都出不来，就一个蓝色背景，找了好久的原因百思不得姐阿，结果不小心拿水杯时碰到了鼠标滚轮，发现有了地图区域，于是再滚再滚，地图出来了，原来是后端人员随便给了个定位点（0，0）导致放大定位到了大西洋，全是海，尼玛真是一片蓝！~&lt;/p&gt;
&lt;p&gt;言归正传，今天遇到的播放rtmp流的坑，所以记录下来。&lt;/p&gt;
&lt;p&gt;上代码：&lt;/p&gt;
&lt;div readability=&quot;38&quot;&gt;
&lt;p&gt;changeRtmpUrl(data: any) {&lt;/p&gt;
&lt;p&gt;　　let src = data.src;&lt;/p&gt;
&lt;p&gt;　　if(this.player == null){&lt;/p&gt;
&lt;p&gt;　　　　this.player = window['videojs']('#asn_video', {&lt;/p&gt;
&lt;p&gt;　　　　　　fill: true&lt;/p&gt;
&lt;p&gt;　　　　});&lt;/p&gt;
&lt;p&gt;　　　}&lt;/p&gt;
&lt;p&gt;　　//$('#asn_video source').attr('src', src);&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;//this.player.src(src);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;&lt;span&gt;this.player.src({ type : &quot;rtmp/mp4&quot;, src : src });&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　this.player.load();&lt;/p&gt;
&lt;p&gt;　　this.player.play();&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;我的是动态切换后台给返回的rtmp流地址，结果怎么切换不能播放，于是发现，看代码红色部分this.player.src(src);直接设置src函数的值为流地址是不行的，src函数中要设置为object,里面需要有流地址的src地址源，再加上type属性则完美呈现。。。&lt;/p&gt;

&lt;p&gt;后记：关于流媒体还没有完，rtmp流创建了还是及时销毁掉，否则会引起其他页面的错误，有时间了再补充销毁的文章了，希望对相关问题上的朋友有所帮助。&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Fri, 14 Jun 2019 15:28:00 +0000</pubDate>
<dc:creator>angelfinding</dc:creator>
<og:description>前提：前端网页是不能直接播放rtmp或rtsp直播流的。 项目中需要播放工场仓储物流的实时监控摄像头。经过各种调研，发现video.min.js+videojs-flash.min.js,再加上浏览器</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wujx9/p/11025915.html</dc:identifier>
</item>
</channel>
</rss>