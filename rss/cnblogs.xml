<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>数组 - double-shuang</title>
<link>http://www.cnblogs.com/cuishuangshuang/p/13410494.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cuishuangshuang/p/13410494.html</guid>
<description>&lt;p&gt;定义数组的方法、length属性、concat方法、join方法、push方法、pop方法、unshift方法、shift方法、splice方法、reverse方法、slice方法、indexOf方法、lastIndexOf方法、sort方法、toString方法、Array.isArray方法、forEach方法、map方法、filter方法、flat方法、reduce方法、reduceRight方法、some方法、every方法、find方法、findIndex方法、fill方法、includes方法&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;741&quot;&gt;
&lt;p&gt;&lt;span&gt;1、创建数组的两种方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;第一种：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　var  arr1  =  [1, 2, 3, 4, 5];&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　var  arr2  =  [3];&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;第二种：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　var  arr3  =  new  Array(1, 2, 3, 4, 5);　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　var  arr4  =  new  Array(3);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　二者的区别：当只有一个数组成员的时候，第一种方法创建的数组arr2表示数组[3]；第二种方法创建的数组arr4表示显示3个空成员的数组[undefined, undefined, undefined]&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;2、arr.length&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;span&gt;&lt;span&gt;获取数组的长度&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　var  arr  =  [1, 2, 3, 4];&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　console.log(arr.length)　　// 4　&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;3、arr.concat( )&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　连接两个或更多的数组，并返回结果。&lt;span&gt;不改变原数组&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　第一种：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　　　var  arr  =  [1, 2, 3];&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　　　var  arr1  =  arr.concat(4,5,6);&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　　　console.log(arr1)　　// [1, 2, 3, 4, 5, 6]&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　第二种：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　　　var  arr  =  [1, 2, 3];&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　　　var  arr1  =  [4, 5, 6];&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　　　var  arr2  =  arr.concat(arr1);&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　　　console.log(arr2)　　// [1, 2, 3, 4, 5, 6]&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　第三种：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　var  arr  =  [1, 2, 3];&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　var  arr1  =  [4, 5, 6];&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　var  arr2  =  [7, 8, 9];&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　var  arr3  =  arr.concat(arr1, arr2);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　console.log(arr3)　　// [1, 2, 3, 4, 5, 6, 7, 8, 9]&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;4、arr.join( )&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　将数组的所以成员以指定的字符分隔成字符串；&lt;span&gt;不改变原数组&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　var  arr  =  [1, 2, 3, 4, 5];&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;　　var  str1  =  arr.join( );　　// 不填就是默认以逗号分隔&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　console.log(str1)　　// &quot;1,2,3,4,5&quot;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;　　var  str2  =  arr.join( '' );&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　console.log(str2)　　//&quot;12345&quot;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;5、arr.push( )&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　向数组的末尾添加一个或多个元素，并返回新数组的长度；&lt;span&gt;改变原数组&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　var  arr  =  [1, 2, 3, 4];&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　var  arr1  =  arr.push(5, 6);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　console.log(arr)　　// [1, 2, 3, 4, 5, 6]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　console.log(arr1)　　// 6&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;6、arr.pop( )　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　删除并返回数组的最后一个元素；&lt;span&gt;改变原数组&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　var  arr  =  [1, 2, 3, 4, 5];&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　var  arr1  =  arr.pop( );&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　console.log(arr)　　// [1, 2, 3, 4]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　console.log(arr1)　　// 5&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;7、arr.unshift( )&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　向数组的开头添加一个或多个元素，并返回新数组的长度；&lt;span&gt;改变原数组&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　var  arr  =  [1, 2, 3, 4];&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　var  arr1  =  arr.unshift(5, 6);&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　console.log(arr)　　// [5, 6, 1, 2, 3, 4]&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　console.log(arr1)　　// 6&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;8、arr.shift( )&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　删除并返回数组的第一个元素；&lt;span&gt;改变原数组&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　var  arr  =  [1, 2, 3, 4];&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　var  arr1  =  arr.shift( );&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　console.log(arr)　　// [2, 3, 4]&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　console.log(arr1)　　// 1&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;9、arr.splice( )&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　删除数组元素，并添加新元素&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　arr.splice(start, delCount, add1, add2, ...)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　删除的开始位置，删除的元素个数，添加的元素&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;　　var  arr  =  [1, 2, 3, 4, 5];&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　var  arr1  =  arr.splice(3);&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　console.log(arr)　　// [1, 2, 3]&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　console.log(arr1)　　// [4, 5]&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;　　var  arr  =  [1, 2, 3, 4, 5];&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　var  arr1  =  arr.splice(2, 1);&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　console.log(arr)　　// [1, 2, 4, 5]&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　console.log(arr1)　　// [3]&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;　　var  arr  =  [1, 2, 3, 4, 5];&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　var  arr1  =  arr.splice(3, 0, 7, 8)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　console.log(arr)　　// [1, 2, 3, 7, 8, 4, 5]&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　console.log(arr1)　　// [ ]5]&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;　　var  arr  =  [1, 2, 3, 4, 5];&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　var  arr1  =  arr.splice(3, 1, 7)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　console.log(arr)　　// [1, 2, 3, 7, 5]&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　console.log(arr1)　　// [4]&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;10、arr.reverse( )&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　颠倒数组中元素的顺序，并返回颠倒后的新数组；&lt;span&gt;改变原数组&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　var  arr  =  [1, 2, 3, 4, 5];&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　var  arr1  =  arr.reverse( );&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　console.log(arr)　　// [5, 4, 3, 2, 1]&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　console.log(arr1)　　// [5, 4, 3, 2, 1]&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;11、arr.slice( )&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　截取数组,&lt;/span&gt; &lt;span&gt;不改变原数组&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　var  arr  =  [1, 2, 3, 4, 5];&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　var  arr1  =  arr.slice( );&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　console.log(arr1)　　[1, 2, 3, 4, 5]&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;　　var  arr  =  [1, 2, 3, 4, 5];&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　var  arr1  =  arr.slice(3);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　console.log(arr)　　// [1, 2, 3, 4, 5]&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　console.log(arr1)　　[4, 5]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　var  arr  =  [1, 2 , 3, 4, 5];&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　var  arr1  =  arr.slice(1, 3);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　console.log(arr1)　　// [2, 3]&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;12、arr.indexOf( )&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　匹配元素是否在数组中，如果能匹配到，就返回该元素在数组中的索引；如果匹配不到，就返回-1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　var  arr  =  [1, 2, 3, 4, 5];&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　var  arr1  =  arr.indexOf(4);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　console.log(arr1)　　// 3&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;13、arr.sort( )&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　如果调用该方法时没有使用参数，将按字母顺序对数组中的元素进行排序，说得更精确点，是按照字符编码的顺序进行排序；&lt;span&gt;改变原数组&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　可以接受两个参数，a表示前面的数组元素，b表示后面的数组元素，比较a和b的大小，如果是负数或者0不改变二者位置，如果是正数，将a位置的元素和b位置的元素对调位置&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;span&gt;var arr = [1, 'abc', 5, 'a', 3, 2, 'c', 6, 'b',5, ];&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　var arr1 = arr.sort();&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　console.log(arr)　　// [1, 2, 3, 5, 5, 6, &quot;a&quot;, &quot;abc&quot;, &quot;b&quot;, &quot;c&quot;]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　console.log(arr1)　　// [1, 2, 3, 5, 5, 6, &quot;a&quot;, &quot;abc&quot;, &quot;b&quot;, &quot;c&quot;]&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;span&gt;var arr = [1, 5, 3, 2, 6, 5 ];&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　var arr1 = arr.sort((a, b) =&amp;gt; {&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　return a - b;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　});&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　console.log(arr)　　// [1, 2, 3, 5, 5, 6]&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;14、arr.toString( )&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　该方法与没有参数的join方法返回的字符串相同&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　var  arr  =  [1, 2, 3, 4, 5];&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　var  arr1  =  arr.toString( );&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　console.log(arr)　　//[1, 2, 3, 4, 5]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　console.log(arr1)　　// &quot;1,2,3,4,5&quot;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;15、Array.isArray( )&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　判断传的参数是否是数组类型，是数组类型返回true，否则返回false&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　var  arr  =  [1, 2, 3, 4];&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　var  arr1  =  Array.isArray(arr);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　console.log(arr1)　　// true&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;16、arr.forEach( )&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　遍历数组，和for循环差不多，区别是使用return或break都不能中断forEach的循环&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　let  arr  =  [1, 2, 3, 4, 5, 6];&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　let obj  =  {a:1, b:2};&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　forEach方法如果不传第二个参数，无论回调函数是es5写法还是es6写法，回调函数中的this都是window&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　arr.forEach(function(item, index){&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　　　console.log(this)　　// {a:1, b:2}　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　}, obj)&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　arr.forEach((item, index)  =&amp;gt;  {&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　console.log(this)　　// window&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　}, obj)&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;17、arr.map( )&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　返回一个新数组，数组中的成员是arr.map方法中的回调函数循环时return的值&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　var  arr  =  [1, 2, 3, 4, 5, 6];&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　var  arr1  =  arr.map((item, index)  =&amp;gt;  {&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　return item + 1;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　});&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　console.log(arr1)　　// [2, 3, 4, 5, 6, 7]&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;18、arr.filter( )&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　返回一个新数组，数组中的成员是arr.filter方法中的回调函数循环时return的值是true的item的值&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　var  arr  =  [1, 2, 3, 4, 5, 6];&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　var  arr1  =  arr.filter((item, index)  =&amp;gt;  {&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　　　return item  &amp;gt;  3;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　});&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　console.log(arr1)　　// [4, 5, 6]&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;19、arr.some( )&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　检测数组中的值是否有满足判断条件的，如果有返回true，没有返回false&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　var  arr  =  [1, 2, 3, 4, 5, 6];&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　var  arr1  =  arr.some((item, index)  =&amp;gt;  {&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　return item  &amp;gt;  3;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　});&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　console.log(arr1)　　// true&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;20、arr.every( )&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　检测数组中的值是否全部满足判断条件，如果全部满足返回true，否则返回false&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　var  arr  =  [1, 2, 3, 4, 5, 6];&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　var  arr1  =  arr.every((item, index)  =&amp;gt;  {&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　　　return item  &amp;gt;  3;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　});&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　console.log(arr1)　　// false&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;21、arr.find( )&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　返回数组中第一个满足判断条件的成员，如果都不满足返回undefined&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　var  arr  =  [1, 2, 3, 4, 5, 6];&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　var  arr1  =  arr.find((item, index)  =&amp;gt;  {&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　　　return item  &amp;gt;  3;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　});&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　console.log(arr1)　　// 4&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;22、arr.flat( )&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　　不传参数，只能将二维数组转成一维数组；加Infinity参数可以将多维数组转换成一维数组&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　var  arr  =  [1, 2, [4, 5]];&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　var  arr1  =  arr.flat( );&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　console.log(arr1)　　// [1, 2, 4, 5]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　var  arr  =  [1, 2, [3, 4, [5]]];&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　var  arr1  =  arr.flat(Infinity)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　console.log(arr1)　　// [1, 2, 3, 4, 5]&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;23、arr.fill( )&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　ES6：&lt;/span&gt;&lt;span&gt;用&lt;/span&gt;&lt;span&gt;一个固定值替换数组的元素。array.fill(value, start, end)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;token keyword&quot;&gt;　　let arr1 &lt;span class=&quot;token operator&quot;&gt;= &lt;span class=&quot;token punctuation&quot;&gt;[&lt;span class=&quot;token number&quot;&gt;1&lt;span class=&quot;token punctuation&quot;&gt;, &lt;span class=&quot;token number&quot;&gt;2&lt;span class=&quot;token punctuation&quot;&gt;, &lt;span class=&quot;token number&quot;&gt;3&lt;span class=&quot;token punctuation&quot;&gt;, &lt;span class=&quot;token number&quot;&gt;4&lt;span class=&quot;token punctuation&quot;&gt;, &lt;span class=&quot;token number&quot;&gt;56&lt;span class=&quot;token punctuation&quot;&gt;, &lt;span class=&quot;token number&quot;&gt;7&lt;span class=&quot;token punctuation&quot;&gt;, &lt;span class=&quot;token number&quot;&gt;7&lt;span class=&quot;token punctuation&quot;&gt;, &lt;span class=&quot;token number&quot;&gt;8&lt;span class=&quot;token punctuation&quot;&gt;, &lt;span class=&quot;token number&quot;&gt;9&lt;span class=&quot;token punctuation&quot;&gt;]&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;token keyword&quot;&gt;&lt;span class=&quot;token operator&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&lt;span class=&quot;token number&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&lt;span class=&quot;token number&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&lt;span class=&quot;token number&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&lt;span class=&quot;token number&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&lt;span class=&quot;token number&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&lt;span class=&quot;token number&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&lt;span class=&quot;token number&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&lt;span class=&quot;token number&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&lt;span class=&quot;token number&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;　　arr1&lt;span class=&quot;token punctuation&quot;&gt;.&lt;span class=&quot;token function&quot;&gt;fill&lt;span class=&quot;token punctuation&quot;&gt;(&lt;span class=&quot;token number&quot;&gt;4&lt;span class=&quot;token punctuation&quot;&gt;, &lt;span class=&quot;token number&quot;&gt;2&lt;span class=&quot;token punctuation&quot;&gt;, &lt;span class=&quot;token number&quot;&gt;5&lt;span class=&quot;token punctuation&quot;&gt;)&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;token keyword&quot;&gt;&lt;span class=&quot;token operator&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&lt;span class=&quot;token number&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&lt;span class=&quot;token number&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&lt;span class=&quot;token number&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&lt;span class=&quot;token number&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&lt;span class=&quot;token number&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&lt;span class=&quot;token number&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&lt;span class=&quot;token number&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&lt;span class=&quot;token number&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&lt;span class=&quot;token number&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&lt;span class=&quot;token function&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&lt;span class=&quot;token number&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&lt;span class=&quot;token number&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&lt;span class=&quot;token number&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;　　console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;span class=&quot;token function&quot;&gt;log&lt;span class=&quot;token punctuation&quot;&gt;(arr1&lt;span class=&quot;token punctuation&quot;&gt;) &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;






&lt;p&gt;&lt;span&gt;24、arr.lastIndexOf( )&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　查找参数在数组中最后一次出现的索引有就返回该索引，没有就返回-1&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　var  arr  =  [1, 2, 3, 2, 4];&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　var  arr1  =  arr.lastIndexOf(2);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　console.log(arr1)　　// 3&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;25、arr.reduce( )&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;该方法有两个参数，第一个参数是回调函数，第二个参数是可选参数，如果写第二个参数，第二个参数就是回调函数的第一个参数，回调函数的第二个参数表示数组成员；&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　如果不写第二个参数，回调函数第一个参数表示数组的第一个成员，回调函数的第二个参数表示数组的&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　var arr = [1, 2, 3, 4, 5, 6];&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　var arr1 = arr.reduce((pre,cur,index) =&amp;gt; {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　console.log(pre,cur,index)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　return pre + cur&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　});&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　console.log(arr1)　　// 21&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　var arr = [1, 2, 3, 4, 5, 6];&lt;br/&gt;　　var arr1 = arr.reduce((pre,cur,index) =&amp;gt; {&lt;br/&gt;　　　　console.log(pre,cur,index)&lt;br/&gt;　　　　return pre.concat(cur);&lt;br/&gt;　　}, [ ]);&lt;br/&gt;　　console.log(arr1)　　// [1, 2, 3, 4, 5, 6]&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;26、arr.reduceRight( )&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　和reduce用法相同，只是此方法是数组从后向前遍历&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　var arr = [1, 2, 3, 4, 5, 6];&lt;br/&gt;　　var arr1 = arr.reduceRight((pre,cur,index) =&amp;gt; {&lt;br/&gt;　　　　console.log(pre,cur,index)&lt;br/&gt;　　　　return pre.concat(cur);&lt;br/&gt;　　}, [ ]);&lt;br/&gt;　　console.log(arr1)　　// [6, 5, 4, 3, 2, 1]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;27、arr.includes( )&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　查找数组中是否有某个元素，有就返回true，否则返回false&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;span&gt;var arr = [1, 2, 3, 4, 5, 6];&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　var arr1 = arr.includes(3)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　console.log(arr1)　　// true&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Sat, 01 Aug 2020 00:11:00 +0000</pubDate>
<dc:creator>double-shuang</dc:creator>
<og:description>定义数组的方法、length属性、concat方法、join方法、push方法、pop方法、unshift方法、shift方法、splice方法、reverse方法、slice方法、indexOf方法</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cuishuangshuang/p/13410494.html</dc:identifier>
</item>
<item>
<title>CI/CD：Jenkins的流水线demo入门 - 测试生财</title>
<link>http://www.cnblogs.com/Mrchaishome/p/13413202.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Mrchaishome/p/13413202.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;在敏捷开发或者devops中，Jenkins常常作为CI/CD的主选平台，而流水线（Pipeline）是CI/CD的一个常见的体现形式，通过流水线，我们可以配置一个从编译打包，部署，自动化测试，到产品库发布的研发测试全流程，本文旨在带领大家入门一个流水线的demo，该demo展示一个了GItlab和Jenkins的联动：Gitlab的工程有Push或者分支Merge的时候会自动触发流水线的运行。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;1）选择新建任务，输入任务名称（&lt;strong&gt;不能重名&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;2）选择Job类型：流水线（&lt;strong&gt;一般2.x版本会默认支持流水线风格的job&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;3）点击确定&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;43&quot;&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200801074223530.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NjZ3NoaWdhbw==,size_16,color_FFFFFF,t_70&quot; alt=&quot;&quot; width=&quot;643&quot; height=&quot;387&quot; class=&quot;cke_widget_element&quot; data-cke-saved-src=&quot;https://img-blog.csdnimg.cn/20200801074223530.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NjZ3NoaWdhbw==,size_16,color_FFFFFF,t_70&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://img-blog.csdnimg.cn/20200801074223530.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NjZ3NoaWdhbw==,size_16,color_FFFFFF,t_70&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:643,&amp;amp;quot;height&amp;amp;quot;:387,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:[]}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; width=&quot;15&quot; height=&quot;15&quot; class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;


&lt;h2&gt;&lt;strong&gt;2.1 配置下丢弃旧的构建&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;对于大多数的JenkinsJob来说，这一项目必配置，建议保存两周到三周，最大构建数不超过30个。如果不配置的话，Jenkins机器硬盘容易爆满&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;45&quot;&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200801074631301.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NjZ3NoaWdhbw==,size_16,color_FFFFFF,t_70&quot; alt=&quot;&quot; width=&quot;651&quot; height=&quot;298&quot; class=&quot;cke_widget_element&quot; data-cke-saved-src=&quot;https://img-blog.csdnimg.cn/20200801074631301.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NjZ3NoaWdhbw==,size_16,color_FFFFFF,t_70&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://img-blog.csdnimg.cn/20200801074631301.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NjZ3NoaWdhbw==,size_16,color_FFFFFF,t_70&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:651,&amp;amp;quot;height&amp;amp;quot;:298,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:[]}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; width=&quot;15&quot; height=&quot;15&quot; class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;2.2 配置gitlab的webhook需要的url和token&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;1）url和token均由jenkins自动生成，我们只需要拷贝到gitlab对应的webhook配置中即可。&lt;br/&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;47&quot;&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200801074701995.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NjZ3NoaWdhbw==,size_16,color_FFFFFF,t_70&quot; alt=&quot;&quot; width=&quot;626&quot; height=&quot;437&quot; class=&quot;cke_widget_element&quot; data-cke-saved-src=&quot;https://img-blog.csdnimg.cn/20200801074701995.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NjZ3NoaWdhbw==,size_16,color_FFFFFF,t_70&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://img-blog.csdnimg.cn/20200801074701995.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NjZ3NoaWdhbw==,size_16,color_FFFFFF,t_70&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:626,&amp;amp;quot;height&amp;amp;quot;:437,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:[]}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; width=&quot;15&quot; height=&quot;15&quot; class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt;&lt;strong&gt;2.3 填写jenkins的pipeline的code&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;49&quot;&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200801074733741.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NjZ3NoaWdhbw==,size_16,color_FFFFFF,t_70&quot; alt=&quot;&quot; width=&quot;626&quot; height=&quot;284&quot; class=&quot;cke_widget_element&quot; data-cke-saved-src=&quot;https://img-blog.csdnimg.cn/20200801074733741.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NjZ3NoaWdhbw==,size_16,color_FFFFFF,t_70&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://img-blog.csdnimg.cn/20200801074733741.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NjZ3NoaWdhbw==,size_16,color_FFFFFF,t_70&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:626,&amp;amp;quot;height&amp;amp;quot;:284,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:[]}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; width=&quot;15&quot; height=&quot;15&quot; class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;2.4 RUN一个例子&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;51&quot;&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200801074745606.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NjZ3NoaWdhbw==,size_16,color_FFFFFF,t_70&quot; alt=&quot;&quot; width=&quot;616&quot; height=&quot;247&quot; class=&quot;cke_widget_element&quot; data-cke-saved-src=&quot;https://img-blog.csdnimg.cn/20200801074745606.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NjZ3NoaWdhbw==,size_16,color_FFFFFF,t_70&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://img-blog.csdnimg.cn/20200801074745606.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NjZ3NoaWdhbw==,size_16,color_FFFFFF,t_70&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:616,&amp;amp;quot;height&amp;amp;quot;:247,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:[]}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; width=&quot;15&quot; height=&quot;15&quot; class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;2.5 测试下流水线能否跑起来&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;53&quot;&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200801074752266.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NjZ3NoaWdhbw==,size_16,color_FFFFFF,t_70&quot; alt=&quot;&quot; width=&quot;612&quot; height=&quot;278&quot; class=&quot;cke_widget_element&quot; data-cke-saved-src=&quot;https://img-blog.csdnimg.cn/20200801074752266.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NjZ3NoaWdhbw==,size_16,color_FFFFFF,t_70&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://img-blog.csdnimg.cn/20200801074752266.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NjZ3NoaWdhbw==,size_16,color_FFFFFF,t_70&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:612,&amp;amp;quot;height&amp;amp;quot;:278,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:[]}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; width=&quot;15&quot; height=&quot;15&quot; class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;至此你已经简单了解如何通过jenkins创建一个流水线，并获取jenkins关于gitlab对应的配置，后续文章会陆续推出其他相关文章。&lt;/p&gt;
</description>
<pubDate>Fri, 31 Jul 2020 23:58:00 +0000</pubDate>
<dc:creator>测试生财</dc:creator>
<og:description>在敏捷开发或者devops中，Jenkins常常作为CI/CD的主选平台，而流水线（Pipeline）是CI/CD的一个常见的体现形式，通过流水线，我们可以配置一个从编译打包，部署，自动化测试，到产品</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Mrchaishome/p/13413202.html</dc:identifier>
</item>
<item>
<title>字段解析（3）   - HotSpot-Researcher</title>
<link>http://www.cnblogs.com/mazhimazhi/p/13413170.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mazhimazhi/p/13413170.html</guid>
<description>&lt;p&gt;对象的定义顺序和布局顺序是不一样的。我们在写代码的时候不用关心内存对齐问题，但是如果内存按照源代码定义顺序进行布局的话，由于cpu读取内存时是按寄存器（64位）大小单位载入的，如果载入的数据横跨两个64位，要操作该数据的话至少需要两次读取，加上组合移位，会产生效率问题，甚至会引发异常。比如在一些ARM处理器上，如果不按对齐要求访问数据, 会触发硬件异常。&lt;/p&gt;
&lt;p&gt;在Class文件中，字段的定义是按照代码顺序排列的，虚拟机加载后会生成相应的数据结构，包含字段的名称，字段在对象中的偏移等。重新布局后，只要改变相应的偏移值即可。 &lt;/p&gt;
&lt;p&gt;获取到fields后，下面要在ClassFileParser::parseClassFile()函数中进行变量内存布局，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
FieldLayoutInfo info;
layout_fields(class_loader, &amp;amp;fac, &amp;amp;parsed_annotations, &amp;amp;info, CHECK_NULL);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;传入的fac是之前介绍的FieldAllocationCount类型的变量，里面已经保存了各个类型变量的数量。 &lt;/p&gt;
&lt;h3&gt;1、静态变量的偏移量&lt;/h3&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
int next_static_oop_offset;
int next_static_double_offset;
int next_static_word_offset;
int next_static_short_offset;
int next_static_byte_offset;

...

// Calculate the starting byte offsets
next_static_oop_offset      = InstanceMirrorKlass::offset_of_static_fields();
next_static_double_offset   = next_static_oop_offset + (  (fac-&amp;gt;count[STATIC_OOP]) * heapOopSize  );
if ( fac-&amp;gt;count[STATIC_DOUBLE] &amp;amp;&amp;amp;
     (
        Universe::field_type_should_be_aligned(T_DOUBLE) ||  // 方法会返回true
        Universe::field_type_should_be_aligned(T_LONG)       // 方法会返回true
     )
){
  next_static_double_offset = align_size_up(next_static_double_offset, BytesPerLong);
}
next_static_word_offset     = next_static_double_offset + ((fac-&amp;gt;count[STATIC_DOUBLE]) * BytesPerLong);
next_static_short_offset    = next_static_word_offset + ((fac-&amp;gt;count[STATIC_WORD]) * BytesPerInt);
next_static_byte_offset     = next_static_short_offset + ((fac-&amp;gt;count[STATIC_SHORT]) * BytesPerShort);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;静态变量存储在镜像类InstanceMirrorKlass中，调用offset_of_static_fields()方法获取_offset_of_static_fields属性，也就是存储静态字段的偏移量。&lt;/p&gt;
&lt;p&gt;在计算next_static_double_offset时，因为首先布局的是oop，所以内存很可能不是按8字节对齐，需要调用align_size_up()方法对内存进行8字节对齐，后面就不需要对齐了，因为一定是自然对齐，8字节对齐肯定是4字节对齐的，4字节对齐肯定是2字节对齐的。&lt;/p&gt;
&lt;p&gt;调用InstanceMirrorKlass::offset_of_static_fields()方法会获取到InstanceMirrorKlass类的_offset_of_static_fields属性的值，设置_offset_of_static_fields属性的方法如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
static void init_offset_of_static_fields() {
    // java.lang.Class类使用InstanceMirrorKlass对象来表示，而java.lang.Class对象通过Oop对象来表示，那么imk-&amp;gt;size_helper()获取的就是
    // Oop对象的大小，左移3位将字转换为字节
    InstanceMirrorKlass* imk = InstanceMirrorKlass::cast(SystemDictionary::Class_klass());
    _offset_of_static_fields = imk-&amp;gt;size_helper() &amp;lt;&amp;lt; LogHeapWordSize; // LogHeapWordSize=3
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;静态字段紧挨着存储在java.lang.Class对象本身占用的内存大小之后。　　&lt;/p&gt;
&lt;p&gt;按照oop、double、word、short、byte的顺序计算各个静态变量的偏移量，next_static_xxx_offset指向的就是第一个xxx类型的静态变量在InstanceMirrorKlass中的偏移量。可以看到，在fac中统计各个类型变量的数量就是为了方便在这里计算偏移量。 &lt;/p&gt;
&lt;h3&gt;2、非静态变量的偏移量&lt;/h3&gt;
&lt;p&gt;计算非静态字段起始偏移量，在ClassFileParser::layout_fields()函数中有如下代码调用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
int nonstatic_field_size = _super_klass() == NULL ? 0 : _super_klass()-&amp;gt;nonstatic_field_size();
...
int nonstatic_fields_start  = instanceOopDesc::base_offset_in_bytes() + nonstatic_field_size * heapOopSize;
next_nonstatic_field_offset = nonstatic_fields_start;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;定义在instanceOop.hpp文件中的类instanceOopDesc中实现的base_offset_in_bytes()函数的实现如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
// If compressed, the offset of the fields of the instance may not be aligned.
static int base_offset_in_bytes() {
    // offset computation code breaks if UseCompressedClassPointers
    // only is true
    return ( UseCompressedOops &amp;amp;&amp;amp; UseCompressedClassPointers ) ?
               klass_gap_offset_in_bytes() :  // 开启指针压缩后计算出来的值为12
               sizeof(instanceOopDesc);       // 在64位上计算出来为16
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因为非静态变量存储在instanceOopDesc中，并且父类变量存储在前，所以nonstatic_fields_start变量表示的就是当前类定义的实例字段所要存储的起始偏移量位置。　&lt;/p&gt;
&lt;p&gt;子类会将父类中定义的所有非静态字段（包括private修饰的非静态字段）全部复制，以实现字段继承。所以上面在计算子类非静态字段的起始偏移量时，会将父类可被继承的字段占用的内存也考虑在内。如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1236123/202007/1236123-20200715101812562-1703460510.png&quot; alt=&quot;&quot; width=&quot;443&quot; height=&quot;227&quot; loading=&quot;lazy&quot;/&gt; &lt;/p&gt;
&lt;p&gt;下面在计算非静态字段的偏移量时还需要考虑有@Contended注解的类和字段。对于类上的@Contended注解，需要在字段之前填充ContendedPaddingWidth字节，对于有@Contended注解的变量来说，需要单独考虑布局。相关实例变量的数量需要分别进行计算，如下代码所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
// 在类上加@Contended注解的说明可参考：https://www.icode9.com/content-1-375023.html
bool is_contended_class     = parsed_annotations-&amp;gt;is_contended();
// Class is contended, pad before all the fields
if (is_contended_class) {
  next_nonstatic_field_offset += ContendedPaddingWidth;  // ContendedPaddingWidth=128
}

// Compute the non-contended fields count.
// The packing code below relies on these counts to determine if some field
// can be squeezed into the alignment gap. Contended fields are obviously exempt from that.
unsigned int nonstatic_double_count = fac-&amp;gt;count[NONSTATIC_DOUBLE] - fac_contended.count[NONSTATIC_DOUBLE];
unsigned int nonstatic_word_count   = fac-&amp;gt;count[NONSTATIC_WORD]   - fac_contended.count[NONSTATIC_WORD];
unsigned int nonstatic_short_count  = fac-&amp;gt;count[NONSTATIC_SHORT]  - fac_contended.count[NONSTATIC_SHORT];
unsigned int nonstatic_byte_count   = fac-&amp;gt;count[NONSTATIC_BYTE]   - fac_contended.count[NONSTATIC_BYTE];
unsigned int nonstatic_oop_count    = fac-&amp;gt;count[NONSTATIC_OOP]    - fac_contended.count[NONSTATIC_OOP];

// Total non-static fields count, including every contended field
unsigned int nonstatic_fields_count = fac-&amp;gt;count[NONSTATIC_DOUBLE] +
                                      fac-&amp;gt;count[NONSTATIC_WORD]   +
                                      fac-&amp;gt;count[NONSTATIC_SHORT]  +
                                      fac-&amp;gt;count[NONSTATIC_BYTE]   +
                                      fac-&amp;gt;count[NONSTATIC_OOP];
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里涉及到了对有@Contended注解的实例变量的处理，为了避免伪共享的问题，可能需要在2个变量的存储布局之间填充一些数据或空白。这个问题在前一篇已经介绍过，这里不再介绍。&lt;/p&gt;
&lt;p&gt;如果类上有@Contended注解，最终的相关变量更新后指向如下：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1236123/202007/1236123-20200715102720242-801085057.png&quot; alt=&quot;&quot; width=&quot;383&quot; height=&quot;231&quot; loading=&quot;lazy&quot;/&gt; &lt;/p&gt;
&lt;p&gt;在HotSpot中，对象布局有三种模式，如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;allocation_style=0，字段排列顺序为oops、longs/doubles、ints、shorts/chars、bytes，最后是填充字段，以满足对齐要求；&lt;/li&gt;
&lt;li&gt;allocation_style=1，字段排列顺序为longs/doubles、ints、shorts/chars、bytes、oops，最后是填充字段，以满足对齐要求；&lt;/li&gt;
&lt;li&gt;allocation_style=2，JVM在布局时会尽量使父类oops和子类oops挨在一起。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;另外，由于填充会形成空隙，比如使用压缩指针时，头占12字节，后面如果是long类型变量的话，long的对齐要求是8字节，中间会有4个字节的空隙，为了提高内存利用率, 可以把int/short/byte等相对内存占用比较小的对象塞进去，与此同时JVM提供了-XX:+/-CompactFields命令控制该特性，默认开启。 &lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;45&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
bool compact_fields   = CompactFields;         // 默认值为true
int  allocation_style = FieldsAllocationStyle; // 默认的布局为1
// ...

// Rearrange fields for a given allocation style
if( allocation_style == 0 ) {
    // Fields order: oops, longs/doubles, ints, shorts/chars, bytes, padded fields
    next_nonstatic_oop_offset    = next_nonstatic_field_offset;  // 首先布局oop类型的变量
    next_nonstatic_double_offset = next_nonstatic_oop_offset + (nonstatic_oop_count * heapOopSize);
}
else if( allocation_style == 1 ) {
    // Fields order: longs/doubles, ints, shorts/chars, bytes, oops, padded fields
    next_nonstatic_double_offset = next_nonstatic_field_offset; // 首先布局long/double类型的变量
}
else if( allocation_style == 2 ) {
    // Fields allocation: oops fields in super and sub classes are together.
    if(
         nonstatic_field_size &amp;gt; 0 &amp;amp;&amp;amp; // nonstatic_field_size指的是父类的非静态变量占用的大小
         _super_klass() != NULL &amp;amp;&amp;amp; 
         _super_klass-&amp;gt;nonstatic_oop_map_size() &amp;gt; 0
     ){
      unsigned int  map_count = _super_klass-&amp;gt;nonstatic_oop_map_count();
      OopMapBlock*  first_map = _super_klass-&amp;gt;start_of_nonstatic_oop_maps();
      OopMapBlock*  last_map  = first_map + map_count - 1;
      int next_offset = last_map-&amp;gt;offset() + (last_map-&amp;gt;count() * heapOopSize);
      if (next_offset == next_nonstatic_field_offset) {
        allocation_style = 0;   // allocate oops first
        next_nonstatic_oop_offset    = next_nonstatic_field_offset;
        next_nonstatic_double_offset = next_nonstatic_oop_offset + (nonstatic_oop_count * heapOopSize);
      }
    }

    if( allocation_style == 2 ) {
      allocation_style = 1;     // allocate oops last
      next_nonstatic_double_offset = next_nonstatic_field_offset;
    }
}
else {
     ShouldNotReachHere();
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对于allocation_style属性的值为0与为1时的逻辑非常好理解，当为2时，如果父类有OopMapBlock，那么_super_klass-&amp;gt;nonstatic_oop_map_size()大于0，并且父类将oop布局在末尾时，此时可使用allocation_style=0来布局，这样子类会首先将自己的oop布局在开始，正好和父类的oop连在一起，有利于GC扫描处理引用。剩下的其它情况都是按allocation_style属性的值为1来布局的，也就是oop在末尾。后面在介绍了OopMapBlock后就会对allocation_style等于2时的代码逻辑有更充分的理解。&lt;/p&gt;
&lt;p&gt;选定了布局策略allocation_style后，首先要向空隙中填充属性，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
// count
int nonstatic_oop_space_count   = 0;
int nonstatic_word_space_count  = 0;
int nonstatic_short_space_count = 0;
int nonstatic_byte_space_count  = 0;
// offset
int nonstatic_oop_space_offset;
int nonstatic_word_space_offset;
int nonstatic_short_space_offset;
int nonstatic_byte_space_offset;

// Try to squeeze some of the fields into the gaps due to long/double alignment.
// 向补白空隙中填充字段，填充的顺序为int、short、byte、oopmap
if( nonstatic_double_count &amp;gt; 0 ) { // 当有long/double类型的实例变量存在时，可能存在空隙
    int offset = next_nonstatic_double_offset;
    next_nonstatic_double_offset = align_size_up(offset, BytesPerLong);
    // 只有开启了-XX:+CompactFields命令时才会进行空白填充
    if( compact_fields &amp;amp;&amp;amp; offset != next_nonstatic_double_offset ) {
      // Allocate available fields into the gap before double field.
      int length = next_nonstatic_double_offset - offset;
      assert(length == BytesPerInt, &quot;&quot;);
      // nonstatic_word_count记录了word的总数，由于这个gap算一个特殊位置，故把放入这里的word从正常情况删除，
      // 并加入特殊的nonstatic_word_space_count中。
      nonstatic_word_space_offset = offset;
      if( nonstatic_word_count &amp;gt; 0 ) { // 由于long/double是8字节对齐，所以最多只能有7个字节的空隙，最多只能填充一个word类型的变量
        nonstatic_word_count      -= 1;
        nonstatic_word_space_count = 1; // Only one will fit
        length -= BytesPerInt;
        offset += BytesPerInt;
      }
      nonstatic_short_space_offset = offset;
      while( length &amp;gt;= BytesPerShort &amp;amp;&amp;amp; nonstatic_short_count &amp;gt; 0 ) {
        nonstatic_short_count       -= 1;
        nonstatic_short_space_count += 1;
        length -= BytesPerShort;
        offset += BytesPerShort;
      }
      nonstatic_byte_space_offset = offset;
      while( length &amp;gt; 0 &amp;amp;&amp;amp; nonstatic_byte_count &amp;gt; 0 ) {
        nonstatic_byte_count       -= 1;
        nonstatic_byte_space_count += 1;
        length -= 1;
      }
      // Allocate oop field in the gap if there are no other fields for that.
      nonstatic_oop_space_offset = offset;
      // when oop fields not first
      // heapOopSize在开启指针压缩时为4,否则为8,所以一个oop占用的字节数要看heapOopSize的大小，理论上空隙也最多
      // 只能存放一个oop对象
      // allocation_style必须不等于0,因为等于0时，oop要分配到开始的位置，和父类的oop进行连续存储，不能
      // 进行空隙填充
      if( length &amp;gt;= heapOopSize &amp;amp;&amp;amp; nonstatic_oop_count &amp;gt; 0 &amp;amp;&amp;amp; allocation_style != 0 ) {
        nonstatic_oop_count      -= 1;
        nonstatic_oop_space_count = 1; // Only one will fit
        length -= heapOopSize;
        offset += heapOopSize;
      }
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;long/double类型占用8字节，对齐时，最多可能留下7字节的空白。Java数据类型与JVM内部定义的5种数据类型的对应关系如下表所示。&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr&gt;&lt;td&gt;Java数据类型&lt;/td&gt;
&lt;td&gt;JVM内部数据类型&lt;/td&gt;
&lt;td&gt;数据宽度&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;reference &lt;/td&gt;
&lt;td&gt;oop&lt;/td&gt;
&lt;td&gt;4字节（指针压缩）/8字节&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;boolean/byte&lt;/td&gt;
&lt;td&gt;byte&lt;/td&gt;
&lt;td&gt;1字节&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;char/short&lt;/td&gt;
&lt;td&gt;short&lt;/td&gt;
&lt;td&gt;2字节&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;int/float&lt;/td&gt;
&lt;td&gt;word&lt;/td&gt;
&lt;td&gt;4字节&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;long/double&lt;/td&gt;
&lt;td&gt;double&lt;/td&gt;
&lt;td&gt;8字节&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;有可能对齐后会有最多7字节的空隙，这样就可按顺序填充int/float、char/short、boolean/byte及引用类型，充分利用了内存空间。&lt;/p&gt;
&lt;p&gt;下面开始计算非静态变量的偏移量，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
next_nonstatic_word_offset   = next_nonstatic_double_offset + (nonstatic_double_count * BytesPerLong);
next_nonstatic_short_offset  = next_nonstatic_word_offset   + (nonstatic_word_count * BytesPerInt);
next_nonstatic_byte_offset   = next_nonstatic_short_offset  + (nonstatic_short_count * BytesPerShort);
next_nonstatic_padded_offset = next_nonstatic_byte_offset   + nonstatic_byte_count;

// let oops jump before padding with this allocation style
// 为1时的布局为： // Fields order: longs/doubles, ints, shorts/chars, bytes, oops, padded fields
if( allocation_style == 1 ) {
    next_nonstatic_oop_offset = next_nonstatic_padded_offset;
    if( nonstatic_oop_count &amp;gt; 0 ) {
      next_nonstatic_oop_offset = align_size_up(next_nonstatic_oop_offset, heapOopSize);
    }
    next_nonstatic_padded_offset = next_nonstatic_oop_offset + (nonstatic_oop_count * heapOopSize);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将各个类型的变量在instanceOop中的偏移量计算好后，下面就是计算每个变量的实际偏移量了。 &lt;/p&gt;
&lt;h3&gt;3、计算每个变量的偏移量&lt;/h3&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
// Iterate over fields again and compute correct offsets.
// The field allocation type was temporarily stored in the offset slot.
// oop fields are located before non-oop fields (static and non-static).
for (AllFieldStream fs(_fields, _cp); !fs.done(); fs.next()) {
    // skip already laid out fields
    if (fs.is_offset_set())
        continue;
    // contended instance fields are handled below
    if (fs.is_contended() &amp;amp;&amp;amp; !fs.access_flags().is_static()){
        continue; // 这个循环逻辑不处理有@Contended注解的实例变量
    }
    int real_offset;
    FieldAllocationType atype = (FieldAllocationType) fs.allocation_type();

    // pack the rest of the fields
    switch (atype) {
      case STATIC_OOP:
        real_offset = next_static_oop_offset;
        next_static_oop_offset += heapOopSize;
        break;
      case STATIC_BYTE:
        real_offset = next_static_byte_offset;
        next_static_byte_offset += 1;
        break;
      case STATIC_SHORT:
        real_offset = next_static_short_offset;
        next_static_short_offset += BytesPerShort;
        break;
      case STATIC_WORD:
        real_offset = next_static_word_offset;
        next_static_word_offset += BytesPerInt;
        break;
      case STATIC_DOUBLE:
        real_offset = next_static_double_offset;
        next_static_double_offset += BytesPerLong;
        break;
      case NONSTATIC_OOP:
        if( nonstatic_oop_space_count &amp;gt; 0 ) {
          real_offset = nonstatic_oop_space_offset;
          nonstatic_oop_space_offset += heapOopSize;
          nonstatic_oop_space_count  -= 1;
        } else {
          real_offset = next_nonstatic_oop_offset;
          next_nonstatic_oop_offset += heapOopSize;
        }
        // Update oop maps
        if(
            nonstatic_oop_map_count &amp;gt; 0 &amp;amp;&amp;amp;
            nonstatic_oop_offsets[nonstatic_oop_map_count - 1] ==
            real_offset - int(nonstatic_oop_counts[nonstatic_oop_map_count - 1]) * heapOopSize
            ){
          // Extend current oop map
          nonstatic_oop_counts[nonstatic_oop_map_count - 1] += 1;
        } else {
          // Create new oop map
          nonstatic_oop_offsets[nonstatic_oop_map_count] = real_offset;
          nonstatic_oop_counts [nonstatic_oop_map_count] = 1;
          nonstatic_oop_map_count += 1;
          if( first_nonstatic_oop_offset == 0 ) { // Undefined
            first_nonstatic_oop_offset = real_offset;
          }
        }
        break;
      case NONSTATIC_BYTE:
        if( nonstatic_byte_space_count &amp;gt; 0 ) {
          real_offset = nonstatic_byte_space_offset;
          nonstatic_byte_space_offset += 1;
          nonstatic_byte_space_count  -= 1;
        } else {
          real_offset = next_nonstatic_byte_offset;
          next_nonstatic_byte_offset += 1;
        }
        break;
      case NONSTATIC_SHORT:
        if( nonstatic_short_space_count &amp;gt; 0 ) {
          real_offset = nonstatic_short_space_offset;
          nonstatic_short_space_offset += BytesPerShort;
          nonstatic_short_space_count  -= 1;
        } else {
          real_offset = next_nonstatic_short_offset;
          next_nonstatic_short_offset += BytesPerShort;
        }
        break;
      case NONSTATIC_WORD:
        if( nonstatic_word_space_count &amp;gt; 0 ) {
          real_offset = nonstatic_word_space_offset;
          nonstatic_word_space_offset += BytesPerInt;
          nonstatic_word_space_count  -= 1;
        } else {
          real_offset = next_nonstatic_word_offset;
          next_nonstatic_word_offset += BytesPerInt;
        }
        break;
      case NONSTATIC_DOUBLE:
        real_offset = next_nonstatic_double_offset;
        next_nonstatic_double_offset += BytesPerLong;
        break;
      default:
        ShouldNotReachHere();
    } // end switch

    fs.set_offset(real_offset);  // 设置真正的偏移量
} // end for
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于第一个变量的偏移量已经计算好，所以接下来就按顺序进行连续存储即可。不过由于实例变量会填充到空隙中，所以还需要考虑这一部分的变量，剩下的同样是通过计算出来的偏移量连续存储即可。最终算出来的每个变量的偏移量要调用fs.set_offset()保存起来，这样就能快速找到这些变量的存储位置了。&lt;/p&gt;
&lt;p&gt;对于NONSTATIC_OOP类型的变量来说，会涉及到OopMapBlock，这个知识点在下一篇中将详细介绍。 &lt;/p&gt;
&lt;h3&gt;4、@Contended变量的偏移量&lt;/h3&gt;
&lt;p&gt;实现代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;50&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
// Handle the contended cases.
//
// Each contended field should not intersect the cache line with another contended field.
// In the absence of alignment information, we end up with pessimistically separating
// the fields with full-width padding.
//
// Additionally, this should not break alignment for the fields, so we round the alignment up
// for each field.
if (nonstatic_contended_count &amp;gt; 0) { // 标注有@Contended注解的字段数量

    // if there is at least one contended field, we need to have pre-padding for them
    next_nonstatic_padded_offset += ContendedPaddingWidth;

    // collect all contended groups
    BitMap bm(_cp-&amp;gt;size());
    for (AllFieldStream fs(_fields, _cp); !fs.done(); fs.next()) {
      // skip already laid out fields
      if (fs.is_offset_set()){
          continue;
      }
      if (fs.is_contended()) {
        bm.set_bit(fs.contended_group());
      }
    }
    // 将同一组的@Contended变量布局在一起
    int current_group = -1;
    while ((current_group = (int)bm.get_next_one_offset(current_group + 1)) != (int)bm.size()) {
      for (AllFieldStream fs(_fields, _cp); !fs.done(); fs.next()) {
        // skip already laid out fields
        if (fs.is_offset_set())
                continue;
        // skip non-contended fields and fields from different group
        if (!fs.is_contended() || (fs.contended_group() != current_group))
                continue;
        // handle statics below
        if (fs.access_flags().is_static())
                continue;

        int real_offset;
        FieldAllocationType atype = (FieldAllocationType) fs.allocation_type();

        switch (atype) {
          case NONSTATIC_BYTE:
            next_nonstatic_padded_offset = align_size_up(next_nonstatic_padded_offset, 1);
            real_offset = next_nonstatic_padded_offset;
            next_nonstatic_padded_offset += 1;
            break;
          case NONSTATIC_SHORT:
            next_nonstatic_padded_offset = align_size_up(next_nonstatic_padded_offset, BytesPerShort);
            real_offset = next_nonstatic_padded_offset;
            next_nonstatic_padded_offset += BytesPerShort;
            break;
          case NONSTATIC_WORD:
            next_nonstatic_padded_offset = align_size_up(next_nonstatic_padded_offset, BytesPerInt);
            real_offset = next_nonstatic_padded_offset;
            next_nonstatic_padded_offset += BytesPerInt;
            break;
          case NONSTATIC_DOUBLE:
            next_nonstatic_padded_offset = align_size_up(next_nonstatic_padded_offset, BytesPerLong);
            real_offset = next_nonstatic_padded_offset;
            next_nonstatic_padded_offset += BytesPerLong;
            break;
          case NONSTATIC_OOP:
            next_nonstatic_padded_offset = align_size_up(next_nonstatic_padded_offset, heapOopSize);
            real_offset = next_nonstatic_padded_offset;
            next_nonstatic_padded_offset += heapOopSize;

            // Create new oop map
            assert(nonstatic_oop_map_count &amp;lt; max_nonstatic_oop_maps, &quot;range check&quot;);
            nonstatic_oop_offsets[nonstatic_oop_map_count] = real_offset;
            nonstatic_oop_counts [nonstatic_oop_map_count] = 1;
            nonstatic_oop_map_count += 1;
            if( first_nonstatic_oop_offset == 0 ) { // Undefined
              first_nonstatic_oop_offset = real_offset;
            }
            break;
          default:
            ShouldNotReachHere();
        }

        if (fs.contended_group() == 0) {
          // Contended group defines the equivalence class over the fields:
          // the fields within the same contended group are not inter-padded.
          // The only exception is default group, which does not incur the
          // equivalence, and so requires intra-padding.
          next_nonstatic_padded_offset += ContendedPaddingWidth;
        }

        fs.set_offset(real_offset);
      } // end for

      // Start laying out the next group.
      // Note that this will effectively pad the last group in the back;
      // this is expected to alleviate memory contention effects for
      // subclass fields and/or adjacent object.
      // If this was the default group, the padding is already in place.
      if (current_group != 0) {
        next_nonstatic_padded_offset += ContendedPaddingWidth;
      }
    } // end while

    // handle static fields
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;同为一组的、有@Contended注解的变量要布局在一起。同一组的变量可能类型不同，并且也不会遵循之前介绍的对实例变量的布局策略，所以要在每次开始之前调用align_size_up()进行对齐操作。在布局完一组后要填充ontendedPaddingWidth个字节，然后使用相同的逻辑布局下一组的变量。最终的变量偏移量同样会调用fs.set_offset()保存起来，以方便后续进行偏移查找。　　&lt;/p&gt;
&lt;p&gt;相关文章的链接如下：&lt;/p&gt;
&lt;p&gt;1、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13215548.html&quot; target=&quot;_blank&quot;&gt;在Ubuntu 16.04上编译OpenJDK8的源代码&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;2、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13217159.html&quot; target=&quot;_blank&quot;&gt;调试HotSpot源代码&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13222664.html&quot; target=&quot;_blank&quot;&gt;HotSpot项目结构&lt;/a&gt;　&lt;/p&gt;
&lt;p&gt;4、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13228157.html&quot; target=&quot;_blank&quot;&gt;HotSpot的启动过程&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;5、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13233607.html&quot; target=&quot;_blank&quot;&gt;HotSpot二分模型（1）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;6、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13237631.html&quot; target=&quot;_blank&quot;&gt;HotSpot的类模型（2）&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;7、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13252983.html&quot; target=&quot;_blank&quot;&gt;HotSpot的类模型（3） &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;8、&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2 vertical-middle&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13272865.html&quot;&gt;HotSpot的类模型（4）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;9、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13289686.html&quot; target=&quot;_blank&quot;&gt;HotSpot的对象模型（5） &lt;/a&gt; &lt;/p&gt;
&lt;p&gt;10、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13291427.html&quot; target=&quot;_blank&quot;&gt;HotSpot的对象模型（6）&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;11、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13297034.html&quot; target=&quot;_blank&quot;&gt;操作句柄Handle（7）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;12、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13303505.html&quot; target=&quot;_blank&quot;&gt;句柄Handle的释放（8）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;13、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13320889.html&quot; target=&quot;_blank&quot;&gt;类加载器&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;14、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13338549.html&quot; target=&quot;_blank&quot;&gt;类的双亲委派机制&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;15、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13343296.html&quot; target=&quot;_blank&quot;&gt;核心类的预装载&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;16、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13353233.html&quot; target=&quot;_blank&quot;&gt;Java主类的装载 &lt;/a&gt; &lt;/p&gt;
&lt;p&gt;17、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13354961.html&quot; target=&quot;_blank&quot;&gt;触发类的装载 &lt;/a&gt; &lt;/p&gt;
&lt;p&gt;18、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13356636.html&quot; target=&quot;_blank&quot;&gt;类文件介绍&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;19、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13358460.html&quot; target=&quot;_blank&quot;&gt;文件流&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;20、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13407609.html&quot; target=&quot;_blank&quot;&gt;解析Class文件&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;21、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13407690.html&quot; target=&quot;_blank&quot;&gt;常量池解析（1）&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;22、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13408261.html&quot; target=&quot;_blank&quot;&gt;常量池解析（2）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;23、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13409707.html&quot; target=&quot;_blank&quot;&gt;字段解析（1）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;24、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13409953.html&quot; target=&quot;_blank&quot;&gt;字段解析之伪共享（2）&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;作者持续维护的个人博客&lt;a href=&quot;http://classloading.com/&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;classloading.com&lt;/strong&gt;&lt;/a&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关注公众号，有HotSpot源码剖析系列文章！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1236123/202006/1236123-20200630200021532-955264784.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;　 　  &lt;/p&gt;
&lt;p&gt;参考文章：&lt;/p&gt;
&lt;p&gt;（1）&lt;a href=&quot;https://www.cnblogs.com/maxigang/p/9040088.html&quot; target=&quot;_blank&quot;&gt;成员变量重排序&lt;/a&gt;  &lt;/p&gt;

</description>
<pubDate>Fri, 31 Jul 2020 23:20:00 +0000</pubDate>
<dc:creator>HotSpot-Researcher</dc:creator>
<og:description>对象的定义顺序和布局顺序是不一样的。我们在写代码的时候不用关心内存对齐问题，但是如果内存按照源代码定义顺序进行布局的话，由于cpu读取内存时是按寄存器（64位）大小单位载入的，如果载入的数据横跨两个6</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mazhimazhi/p/13413170.html</dc:identifier>
</item>
<item>
<title>多任务处理方式之一：多进程 - 嗨，阿良</title>
<link>http://www.cnblogs.com/fengting0913/p/13413114.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fengting0913/p/13413114.html</guid>
<description>&lt;h4 id=&quot;进程的理解：&quot;&gt;进程的理解：&lt;/h4&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;1、系统进行&lt;strong&gt;资源分配&lt;/strong&gt;和&lt;strong&gt;调度&lt;/strong&gt;的基本单位，一个&lt;strong&gt;具有一定独立功能&lt;/strong&gt;的&lt;strong&gt;程序&lt;/strong&gt;关于&lt;strong&gt;某个数据集合&lt;/strong&gt;的一次&lt;strong&gt;运行活动&lt;/strong&gt;；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;2、它是一个&lt;strong&gt;动态的概念&lt;/strong&gt;，一个&lt;strong&gt;活动的实体&lt;/strong&gt;；&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;狭义定义：&lt;code&gt;an instance of a computer program that is being executed&lt;/code&gt; 即&lt;strong&gt;正在运行的程序的实例化对象&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;广义定义：进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动，是&lt;strong&gt;操作系统进行资源分配和调度的基本单位&lt;/strong&gt;，是&lt;strong&gt;操作系统动态执行的基本单元&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;注：其概念的关键点在于&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;1)、进程是一个实体（动态的），具有自己独立的地址空间，包括：
        文本区域（text region）:存储处理器执行的代码；
        数据区域（data region）:存储变量与进程执行期间使用的动态分配的内存；
        堆栈（stack region）:存储的是程序执行过程中调用的指令与本地变量；
        
注：正是由于每个进程是一个独立的实体，其中以上所述的三个区域，即每个进程的数据区域以及堆栈是独立的，相互隔离的，所以在多进程中可以保证数据的安全性
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;2)、编写完的代码，没有运行时，称为程序，
    正在运行的代码，称为进程
    程序是死的(静态的)，进程是活的(动态的)
&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h4 id=&quot;cpu-调度进程的方式&quot;&gt;CPU 调度进程的方式&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;先来先服务&lt;strong&gt;fcfs&lt;/strong&gt;(first come first server)：&lt;strong&gt;先来的先执行&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;短作业优先算法&lt;/strong&gt;：分配的cpu多，先把短的算完&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;时间片轮转算法&lt;/strong&gt;：每一个任务就执行一个时间片的时间.然后就执行其他的&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;多级反馈队列算法&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;越是时间长的，cpu分配的资源越少，优先级靠后&lt;/li&gt;
&lt;li&gt;越是时间短的，cpu分配的资源越多&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;h4 id=&quot;创建进程&quot;&gt;创建进程&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;导入&lt;code&gt;multiprocessing模块中的Process类&lt;/code&gt;以供后续创建类的时候直接调用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;p = Process(target = func, name = process01, args=(5,))&lt;/code&gt; 实例化进程对象&lt;/p&gt;
&lt;h5 id=&quot;process-类参数介绍&quot;&gt;Process 类参数介绍&lt;/h5&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;target = func 表示调用对象，即子进程要执行的任务 func&lt;/li&gt;
&lt;li&gt;args 表示任务 func 的位置参数元组，args=(5, )&lt;/li&gt;
&lt;li&gt;name = process01 为子进程的名称&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h5 id=&quot;process-类常⽤⽅法&quot;&gt;Process 类常⽤⽅法&lt;/h5&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;p.start( ): 启动进程，并调用该子进程中的p.run( )&lt;/li&gt;
&lt;li&gt;p.run( ): 进程启动时运行的方法，正是它去调用target指定的函数，我们自定义类的类中一定要写入该方法&lt;/li&gt;
&lt;li&gt;p.terminate( ): 强制终止进程p，不会进行任何清理操作&lt;/li&gt;
&lt;li&gt;p.is_alive( ): 如果p仍然运行，返回True。用来判断进程是否还在运行&lt;/li&gt;
&lt;li&gt;p.join([timeout]): 主进程等待子进程p终止，timeout是可选的等待时间&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# 主进程速度快于子进程，join方法可以使得子进程执行结束后，再继续执行主进程中的代码，可以用来同步代码的一致性

import multiprocessing


def func():
    print(&quot;发送第一份邮件&quot;)
    
    
if __name__ == &quot;__main__&quot;:
    p = multiprocessing.Process(target=func)
    p.start()
    p.join()
    
    print(&quot;发送第二份邮件&quot;)
    
# 发送第一份邮件
# 发送第二份邮件
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# 多个子进程配合 join 方法实现异步并发

import multiprocessing


def func(index):
    print(f&quot;发送第{index}封邮件&quot;)
   

if __name__ == &quot;__main__&quot;:
    process_list = []
    for i in range(10):
        p = multiprocessing.Process(target=func, args=(i, ))
        p.start()
        process_list.append(p)
        # p.join() 程序会变成同步阻塞
        
    for i in process_list:
        i.join()  # 异步并发
        
    print(&quot;主进程发最后一封邮件!&quot;)

&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;process类常⽤属性&quot;&gt;Process类常⽤属性&lt;/h5&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;name： 当前进程实例别名， 默认为Process-N， N为从1开始递增的整&lt;br/&gt;数&lt;/li&gt;
&lt;li&gt;pid： 当前进程实例的ID值&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h5 id=&quot;创建进程的两种方法&quot;&gt;创建进程的两种方法&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# 创建进程的方法一：
# 利用multiprocessing模块提供一个Process类来创建一个进程对象

from multiprocessing import Process
import time


def func(n):
        while n &amp;gt; 0:
                print(n)
                time.sleep(3)
                n -= 1
if __name__ == &quot;__main__&quot;:
        p = Process(target = func, args=(5,))
        p.start()
        p.join()
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# 创建进程的方法二：
# 创建新的进程可以自定义一个类去继承Process类，每次实例化这个类的时候，就等同于实例化一个进程对象

import multiprocessing
import time
class ClockProcess(multiprocessing.Process):
        def run(self):
                n = 5
                while n &amp;gt; 0:
                        print(n)
                        time.sleep(3)
                        n -= 1
if __name__ == &quot;__main__&quot;:
        p = ClockProcess()
        p.start()
        p.join()
&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h4 id=&quot;守护进程&quot;&gt;守护进程&lt;/h4&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;ul&gt;&lt;li&gt;守护 &lt;strong&gt;主进程&lt;/strong&gt; 时,如果主进程执行结束了,意味着守护进程的寿命立刻终止.立刻杀死&lt;/li&gt;
&lt;li&gt;语法:
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;进程对象.daemon = True&lt;/strong&gt; 设置&lt;strong&gt;当前进程&lt;/strong&gt;为守护进程&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;必须写在start( )调用进程之前进行设置&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;默认情况下，&lt;strong&gt;主进程会等待所有子进程执行完毕之后,关闭程序,释放资源&lt;/strong&gt;。若不等待，子进程并不方便管理,容易造成僵尸进程,在后台不停的占用系统的资源(cpu和内存),不清楚进程的来源。&lt;/li&gt;
&lt;li&gt;守护主进程即在主进程代码执行结束之后，无需等待子进程执行，立即杀死程序&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;import multiprocessing


def func():
    print(&quot;start 当前子进程&quot;)
    print(&quot;end   当前子进程&quot;)

    
if __name__ == &quot;__main__&quot;:
    p = multiprocessing.Process(target=func)
    p.daemon = True
    p.start()
    print(&quot;主进程执行结束 ... &quot;)
    
# 主进程执行结束 ... 


&lt;/code&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote readability=&quot;21&quot;&gt;
&lt;p&gt;&lt;strong&gt;多个子进程下，未守护主进程，主进程仍会等待子进程执行结束&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;守护进程的实际用途：监控报活&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;import time


# 监控报活
def alive():
    while True:
        print(&quot;给监控服务器发消息, 当前5号服务器功能正常 i am ok ~&quot;)
        time.sleep(1)


# 当前服务器正常完成的功能
def func():
    time.sleep(5)
    print(&quot;当前5号服务器功能,统计财务报表~&quot;)


if __name__ == &quot;__main__&quot;:
    p1 = Process(target=func)
    p2 = Process(target=alive)
    
    # 守护p2进程
    p2.daemon = True

    p1.start()
    p2.start()

    # 等待p1子进程执行结束之后,下面的主程序的代码才会放行;
    p1.join()
        
        # 未守护主进程,主进程会默认等待
    print(&quot;当前服务器状态:统计财务报表功能异常.....&quot;)
    
    
# 给监控服务器发消息, 当前5号服务器功能正常 i am ok ~
# 给监控服务器发消息, 当前5号服务器功能正常 i am ok ~
# 给监控服务器发消息, 当前5号服务器功能正常 i am ok ~
# 给监控服务器发消息, 当前5号服务器功能正常 i am ok ~
# 给监控服务器发消息, 当前5号服务器功能正常 i am ok ~
# 当前5号服务器功能,统计财务报表~
# 给监控服务器发消息, 当前5号服务器功能正常 i am ok ~
# 当前服务器状态:统计财务报表功能异常.....
&lt;/code&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;hr/&gt;&lt;h4 id=&quot;多任务处理方式一：多进程&quot;&gt;多任务处理方式一：多进程&lt;/h4&gt;
&lt;h5 id=&quot;创建多进程的两种方式：&quot;&gt;创建多进程的两种方式：&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# 手动创建

from multiprocessing import Process
 
num = 1


def run1():
    global num
    num += 5
    print(&quot;子进程1运行中，num = %d&quot; % (num))


def run2():
    global num
    num += 10
    print(&quot;子进程2运行中，num = %d&quot; % (num))


if __name__ == &quot;__main__&quot;:
    print(&quot;父进程启动&quot;)
    p1 = Process(target=run1)
    p2 = Process(target=run2)
    print(&quot;子进程将要执行&quot;)
    p1.start()
    p2.start()
    p1.join()
    p2.join()
    print(&quot;子进程结束&quot;)

&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# 借助旧版进程池创建多进程

from multiprocessing import Pool
import random
import time


def work(num):
    print(random.random() * num)
    time.sleep(3)


if __name__ == &quot;__main__&quot;:
    # 实例化进程池对象，设置同一时间内最多可以执行的进程数为3个
    # 题中的10个任务都由进程池中的这三个进程轮询执行，不会创建额外           的进程数
    # 若不指定则同一时间内可以执行的进程个数默认为cpu逻辑核心数
    p = Pool(3)
    for i in range(10):
        
        # apply_async 选择要调用的任务，每次循环出来的任务会用闲下来的子进程去执行
        # 使⽤⾮阻塞⽅式调⽤func（并⾏执⾏，阻塞⽅式必须为等待上⼀个进程退出后才能执⾏下⼀个进程）， args为传递给func的参数列表，kwargs为传递给func的关键字参数列表；

        p.apply_async(work, (i,))

    # 进程池关闭之后不会再接受新的请求
    p.close()
    # 等待进程池中的所有子进程都结束
    p.join()

# 多进程中，主进程一般用来等待子进程执行完毕，真正的任务都由子进程中执行
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# 借助新版进程池创建多进程

from concurrent.futures import ProcessPoolExecutor
import os
import time


def func(i):
    print(&quot;任务执行中... start&quot;, os.getpid())
    time.sleep(10)
    print(&quot;任务结束... end&quot;, i)
    return i


# ProcessPoolExecutor 进程池基本使用

&quot;&quot;&quot;
默认如果一个进程短时间内可以完成更多的任务,就不会创建额外的新的进程,以节省资源
&quot;&quot;&quot;
if __name__ == &quot;__main__&quot;:
    lst = []
    print(os.cpu_count())  # cpu逻辑核心数
    # 创建进程池对象
    &quot;&quot;&quot;进程池中默认最多创建cpu这么多个进程,所有任务全由这几个进程完成,不会额外创建进程&quot;&quot;&quot;
    p = ProcessPoolExecutor()

    # 异步提交任务
    for i in range(10):
        res = p.submit(func, i)
        lst.append(res)

    # 获取当前进程池返回值
    for i in lst:
        print(i.result())

    # 等待所有子进程执行结束
    p.shutdown()  # join

    print(&quot;主程序执行结束....&quot;)

&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h4 id=&quot;进程间通信&quot;&gt;进程间通信&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;进程间数据不共享，他们之间进行数据传递即为通信&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;from multiprocessing import Queue&lt;/code&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;借助进程队列&lt;code&gt;Queue&lt;/code&gt;完成进程间的通信&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;queue-的基本使用&quot;&gt;Queue 的基本使用&lt;/h5&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;消息队列遵循 &lt;strong&gt;先进先出&lt;/strong&gt; 的原则&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h6 id=&quot;初始化&quot;&gt;初始化&lt;/h6&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;初始化Queue()对象时（q=Queue()），若&lt;strong&gt;括号中没有指定最⼤可接收&lt;br/&gt;的消息数量&lt;/strong&gt;， 或&lt;strong&gt;数量为负值&lt;/strong&gt;， 那么就代表可接受的消息数量没有上限&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h6 id=&quot;入队操作（存数据）&quot;&gt;入队操作（存数据）&lt;/h6&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;q = Queue()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;q.put(item, [block[, timeout]])&lt;/code&gt;：&lt;strong&gt;将item消息写⼊队列&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;block 默认值为True
&lt;ul&gt;&lt;li&gt;如果block 使⽤默认值，且没有设置timeout（单位秒）时，若消息列队已经没有空间可写⼊，此时程序将被阻塞（停在写⼊状态） ，直到从消息列队腾出空间为⽌，如果设置了True和timeout，则会等待timeout秒，若还没空间，则抛 出&quot;q.Full&quot;的异常信息&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;如果block值为False， 消息列队如果出现没有空间可写⼊的情况， 则会⽴刻抛出&quot;q.Full&quot;&lt;strong&gt;满了&lt;/strong&gt;异常&lt;/li&gt;
&lt;li&gt;&lt;code&gt;q.put_nowait(item)&lt;/code&gt;： 相当&lt;code&gt;q.put(item, False)&lt;/code&gt;；&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h6 id=&quot;出队操作（取数据）&quot;&gt;出队操作（取数据）&lt;/h6&gt;
&lt;blockquote&gt;
&lt;ul readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;q.get([block[, timeout]])&lt;/code&gt;：获取队列中的⼀条消息， 然后将其从列队中移除&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;block默认值为True&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如果block使⽤默认值，且没有设置timeout（单位秒），消息列队如果为空， 此时程序将被阻塞（停在读取状态），直到从消息列队读到消息为⽌，&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如果设置了timeout， 则会等待timeout秒， 若还没读取到任何消息， 则抛&lt;br/&gt;出&quot;q.Empty&quot;异常&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;如果block值为False，消息列队如果为空，则会⽴刻抛出“q.Empty”&lt;strong&gt;空的&lt;/strong&gt;异常&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;q.get_nowait()&lt;/code&gt;：相当q.get(False)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h6 id=&quot;其他操作&quot;&gt;其他操作&lt;/h6&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;q = Queue()&lt;/li&gt;
&lt;li&gt;q.qsize()： 返回当前队列包含的消息数量&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;q.empty()： 如果队列为空， 返回True， 反之False&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;q.full()： 如果队列满了， 返回True,反之False&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h5 id=&quot;python代码实现&quot;&gt;python代码实现&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from multiprocessing import Queue, Process
import time


def write(q):
    for value in [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]:
        print(&quot;开始写入：&quot;, value)
        q.put(value)
        time.sleep(2)


def read(q):
    while True:
        if not q.empty():
            print(&quot;读取到的是&quot;, q.get())
            time.sleep(2)
        else:
            break


if __name__ == &quot;__main__&quot;:
    q = Queue()
    pw = Process(target=write, args=(q,))
    pr = Process(target=read, args=(q,))
    pw.start()
    pw.join()  #等待接收完毕

    pr.start()
    pr.join()
    print(&quot;接受完毕！&quot;)
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# 三个进程间通信

from multiprocessing import Process
from multiprocessing import Queue


def func1(q1):
    q1.put(&quot;你好！&quot;)
    print(f&quot;子进程p1往队列q1中放入的数据为：你好！&quot;)


def func2(q1, q2):
    msg = q1.get()
    print(f&quot;子进程p2从队列q1中取出的数据为：{msg}&quot;)
    q2.put(msg)
    print(f&quot;子进程p2往队列q2中放入的数据为：{msg}&quot;)


def func3(q2):
    msg = q2.get()
    print(f&quot;子进程p3从队列q2中取出的数据为：{msg}&quot;)


if __name__ == &quot;__main__&quot;:
    q1 = Queue()
    q2 = Queue()

    p1 = Process(target=func1, args=(q1,))
    p2 = Process(target=func2, args=(q1, q2))
    p3 = Process(target=func3, args=(q2,))

    p1.start()
    p2.start()
    p3.start()
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;joinablequeue-的用法&quot;&gt;JoinableQueue 的用法&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# put 存储
# get 获取
# task_done 队列计数减1
# join 阻塞

# task_done 配合 join 一起使用
# [1,2,3,4,5]
# 队列计数5 
# put 一次 每存放一个值,队列计数器加1
# get 一次 通过task_done让队列计数器减1
# join 函数,会根据队列中的计数器来判定是阻塞还是放行
# 如果计数器变量是0,意味着放行,其他情况阻塞;


from multiprocessing import Process,JoinableQueue


jq = JoinableQueue()

# put 会让队列计数器加1
jq.put(&quot;a&quot;)
print(jq.get())

# 通过task_done,让队列计数器减1
jq.task_done()

# 只有队列计数器是0的时,才会放行
jq.join() # 队列.join
print(&quot;finish&quot;)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;生产者消费者模型&quot;&gt;生产者——消费者模型&lt;/h5&gt;
&lt;h6 id=&quot;queue下的生产者消费者模型：&quot;&gt;Queue下的生产者——消费者模型：&lt;/h6&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# 消费者模型
def consumer(q, name):
        while True:
                food = q.get()
                if food is None:
                        break
                time.sleep(random.uniform(0.1, 1))
                print(&quot;%s 吃了一个%s&quot; % (name, food))


# 生产者模型
def producer(q, name, food):
        for i in range(5):
                time.sleep(random.uniform(0.1, 1))
                print(&quot;%s 生产了 %s%s&quot; % (name, food, i))
                q.put(food + str(i))


if __name__ == &quot;__main__&quot;:
        q = Queue()
        # 消费者1
        p1 = Process(target=consumer, args=(q, &quot;张三&quot;))
        p1.start()
        # 消费者2
        a2 = Process(target=consumer, args=(q, &quot;李四&quot;))
        a2.start()

        # 生产者1
        p2 = Process(target=producer, args=(q, &quot;王五&quot;, &quot;黄金&quot;))
        p2.start()

        # 生产者2
        b2 = Process(target=producer, args=(q, &quot;小明&quot;, &quot;钻石&quot;))
        b2.start()

        # 在生产完所有的数据之后,在队列的末尾塞入一个None
        p2.join()
        b2.join()
        # 消费者模型如果获取的是None,代表停止消费
        q.put(None)
        q.put(None)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h6 id=&quot;joinablequeue-下的生产者消费者模型：&quot;&gt;JoinableQueue 下的生产者——消费者模型：&lt;/h6&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from multiprocessing import Process,JoinableQueue


# 消费者模型
def consumer(q, name):
    while True:
        food = q.get()
        time.sleep(random.uniform(0.1, 1))
        print(&quot;%s 吃了一个%s&quot; % (name, food))
        q.task_done()
        

# 生产者模型
def producer(q, name, food):
    for i in range(5):
        time.sleep(random.uniform(0.1, 1))
        print(&quot;%s 生产了 %s%s&quot; % (name, food, i))
        q.put(food + str(i))


if __name__ == &quot;__main__&quot;:
    q = JoinableQueue()
    # 消费者1
    p1 = Process(target=consumer, args=(q, &quot;张三&quot;))
    p1.daemon = True
    p1.start()

    # 生产者1
    p2 = Process(target=producer, args=(q, &quot;李四&quot;, &quot;黄金&quot;))
    p2.start()

    # 把生产者所有的数据都装载到队列中
    p2.join()

    # 当队列计数器减到0的时候,会立刻放行
    # 必须等待消费者模型中所有的数据都task_done之后,变成0了就代表消费结束.
    q.join()

    print(&quot;程序结束....&quot;)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h6 id=&quot;进程池中的进程之间的通信&quot;&gt;进程池中的进程之间的通信&lt;/h6&gt;
&lt;pre&gt;
&lt;code&gt;from multiprocessing import Manager, Pool
import time


def write(q):
    for i in &quot;welcome&quot;:
        print(&quot;开始写入&quot;, i)
        q.put(i)


def read(q):
    time.sleep(2)
    for i in range(q.qsize()):  # q.qsize()获取到当前队列的消息数量！
        print(&quot;得到消息&quot;, q.get())


if __name__ == &quot;__main__&quot;:
    print(&quot;主进程启动！&quot;)
    q = Manager().Queue()
    po = Pool()
    po.apply_async(write, (q,))
    po.apply_async(read, (q,))
    po.close()
    po.join()
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 31 Jul 2020 18:30:00 +0000</pubDate>
<dc:creator>嗨，阿良</dc:creator>
<og:description>本文详细总结归纳了有关进程的相关概念</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/fengting0913/p/13413114.html</dc:identifier>
</item>
<item>
<title>Mac上使用Docker安装SQLServer - HueiFeng</title>
<link>http://www.cnblogs.com/yyfh/p/13413105.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yyfh/p/13413105.html</guid>
<description>&lt;ul&gt;&lt;li&gt;&lt;strong&gt;拉取 SQL Server 2017 Docker 镜像&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;docker pull microsoft/mssql-server-linux:2017-latest
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;运行Docker镜像&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;docker run -e 'ACCEPT_EULA=Y' -e 'MSSQL_SA_PASSWORD=您的密码' -p 1433:1433 --name sqlserver -d microsoft/mssql-server-linux:2017-latest
&lt;/code&gt;
&lt;/pre&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;参数&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;3.2031802120141&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;-e 'MSSQL_SA_PASSWORD=您的密码'&lt;/td&gt;
&lt;td&gt;设置SA用户的密码&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;-p 1433:1433&lt;/td&gt;
&lt;td&gt;映射端口&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;--name sqlserver&lt;/td&gt;
&lt;td&gt;设置Docker容器名称为sqlserver&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2.4965034965035&quot;&gt;&lt;td&gt;&lt;strong&gt;-e &quot;ACCEPT_EULA=Y&quot;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;将 ACCEPT_EULA 变量设置为任意值，以确认接受&lt;/strong&gt;&lt;a href=&quot;https://go.microsoft.com/fwlink/?LinkId=746388&quot;&gt;最终用户许可协议&lt;/a&gt;&lt;strong&gt;。 SQL Server 映像的必需设置。&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;br/&gt;&lt;strong&gt;检查Docker容器运行情况&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;docker ps -a
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/png/1543654/1596217896488-06975b19-33e4-4922-80d0-3e03ca0e3139.png#align=left&amp;amp;display=inline&amp;amp;height=139&amp;amp;margin=%5Bobject%20Object%5D&amp;amp;name=image.png&amp;amp;originHeight=292&amp;amp;originWidth=1286&amp;amp;size=118104&amp;amp;status=done&amp;amp;style=none&amp;amp;width=613&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;strong&gt;更改SQLServer密码&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;sudo docker exec -it sql1 /opt/mssql-tools/bin/sqlcmd \
   -S localhost -U SA -P &quot;您的密码&quot; \
   -Q 'ALTER LOGIN SA WITH PASSWORD=&quot;新密码&quot;'
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;连接到SQLServer&lt;/strong&gt;&lt;br/&gt;在sqlserver容器中打开Bash终端&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;sudo docker exec -it sqlserver &quot;bash&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在sqlserver容器的Bash终端中输入：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;/opt/mssql-tools/bin/sqlcmd -S localhost -U SA -P &quot;您的密码&quot;
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 31 Jul 2020 18:03:00 +0000</pubDate>
<dc:creator>HueiFeng</dc:creator>
<og:description>拉取 SQL Server 2017 Docker 镜像 docker pull microsoft/mssql-server-linux:2017-latest 运行Docker镜像 docker</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yyfh/p/13413105.html</dc:identifier>
</item>
<item>
<title>ASP.NET MVC+LayUI视频上传 - 追逐时光者</title>
<link>http://www.cnblogs.com/Can-daydayup/p/12638301.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Can-daydayup/p/12638301.html</guid>
<description>&lt;h2&gt;前言：&lt;/h2&gt;
&lt;p&gt;       前段时间在使用APS.NET MVC+LayUI做视频上传功能的时，发现当上传一些内存比较大的视频就会提示上传失败，后来通过查阅相关资料发现.NET MVC框架为考虑安全问题，在运行时对请求的文件的长度（大小）做了限制默认为4MB（4096KB），因此我们需要在Web.Config中设置最大请求文件长度大小，本篇博客主要讲解如何设置Web.Config中的最大请求文件大小配置和提供一个完整的ASP.NET MVC+LayUI上传视频的教程，并且会提供一个完整的示例（是上传到GitHub）有兴趣的可以耐心的往下看。&lt;/p&gt;
&lt;h2&gt;GitHub完整实例地址：&lt;/h2&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/YSGStudyHards/VideoUpload&quot; target=&quot;_blank&quot;&gt;https://github.com/YSGStudyHards/VideoUpload&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;上传内存较大视频提示异常（HTTP Error 404.13 - Not Found）：&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1336199/202008/1336199-20200801005453785-1023955393.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;h3&gt;异常原因分析：&lt;/h3&gt;
&lt;p&gt;由上图我们可以清楚的知道因为我们所上传的视频内容藏毒超过了配置的值，所以上传失败了，并且还告诉我们需要到web.config文件中配置允许最大上传的文件长度。&lt;/p&gt;
&lt;h2&gt;到web.config文件中的httpRuntime节点配置最大上传文件大小：&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;首先我们打开web.config=&amp;gt;找到system.web=&amp;gt;在httpRuntime中添加maxRequestLength属性值&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;如下所示（maxRequestLength根据需求设置）：&lt;/h3&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
  &amp;lt;system.web&amp;gt;
    &amp;lt;compilation debug=&quot;true&quot; targetFramework=&quot;4.7.2&quot;/&amp;gt;
    &amp;lt;!--maxRequestLength：指示 ASP.NET 支持的最大文件上传大小。该限制可用于防止用户将大量未知的文件上传到服务器导致不安全问题的发生。指定的大小以 KB 为单位。默认值为 4096 KB (4 MB)。--&amp;gt;
    &amp;lt;!--executionTimeout：表示允许执行请求的最大时间限制，单位为秒。--&amp;gt;
    &amp;lt;!--这里设置最大上传长度未200MB，执行超时时间为600s--&amp;gt;
    &amp;lt;httpRuntime targetFramework=&quot;4.7.2&quot;  maxRequestLength=&quot;204800&quot; executionTimeout=&quot;600&quot;/&amp;gt;
  &amp;lt;/system.web&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;strong&gt;httpRuntime代码解释：&lt;/strong&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
executionTimeout：表示允许执行请求的最大时间限制，单位为秒。
maxRequestLength：指示 ASP.NET 支持的最大文件上载大小。该限制可用于防止因用户将大量文件传递到该服务器而导致的拒绝服务攻击。指定的大小以 KB 为单位。默认值为 4096 KB (4 MB)。
useFullyQualifiedRedirectUrl：表示指示客户端重定向是否是完全限定的（采用 &quot;http://server/path&quot; 格式，这是某些移动控件所必需的），或者指示是否代之以将相对重定向发送到客户端。如果为 True，则所有不是完全限定的重定向都将自动转换为完全限定的格式。false 是默认选项。
minFreeThreads：表示指定允许执行新请求的自由线程的最小数目。ASP.NET 为要求附加线程来完成其处理的请求而使指定数目的线程保持自由状态。默认值为 8。
minLocalRequestFreeThreads：表示ASP.NET 保持的允许执行新本地请求的自由线程的最小数目。该线程数目是为从本地主机传入的请求而保留的，以防某些请求在其处理期间发出对本地主机的子请求。这避免了可能的因递归重新进入 Web 服务器而导致的死锁。
appRequestQueueLimit：表示ASP.NET 将为应用程序排队的请求的最大数目。当没有足够的自由线程来处理请求时，将对请求进行排队。当队列超出了该设置中指定的限制时，将通过“503 - 服务器太忙”错误信息拒绝传入的请求。
enableVersionHeader：表示指定 ASP.NET 是否应输出版本标头。Microsoft Visual Studio 2005 使用该属性来确定当前使用的 ASP.NET 版本。对于生产环境，该属性不是必需的，可以禁用。
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;设置相关配置后视频上传成功，上传效果如下所示：　　&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1336199/202008/1336199-20200801013541834-2117167042.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;前端使用LayUI的视频组件提交视频以二进制的文件格式提交到后端服务接口：&lt;/h2&gt;
&lt;h3&gt;1、首先引入相关的layUI相关的js和css文件包：&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1336199/202008/1336199-20200801014513244-329100902.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;h3&gt; 2、在页面中导入相关引用：&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1336199/202008/1336199-20200801014600995-1706796111.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;h3&gt; 3、使用layer.js视频组件提交二进制文件到后端服务:&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;link &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;~/Content/layer-v3.1.1/layer/theme/default/layer.css&quot;&lt;/span&gt;&lt;span&gt; rel&lt;/span&gt;&lt;span&gt;=&quot;stylesheet&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;link &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;~/Content/layui-v2.4.5/css/layui.css&quot;&lt;/span&gt;&lt;span&gt; rel&lt;/span&gt;&lt;span&gt;=&quot;stylesheet&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;jumbotron&quot;&lt;/span&gt;&lt;span&gt; style&lt;/span&gt;&lt;span&gt;=&quot;margin-top: 200px;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h3&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;https://www.cnblogs.com/Can-daydayup/&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;追逐时光者的ASP.NET MVC+LayUI视频上传教程&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h3&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;row&quot;&lt;/span&gt;&lt;span&gt; style&lt;/span&gt;&lt;span&gt;=&quot;margin-top: 20px;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;form-group znStyle&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;label &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;col-sm-2 control-label&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;em &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;zent-form__required&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;*&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;em&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;视频上传：&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;col-sm-6&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;upload_all_file&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;layui-upload&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;button&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;layui-btn&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;VideoBtn&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;i &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;layui-icon&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&amp;amp;#xe67c;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;i&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;上传视频&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;hidden&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;Video&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;Video&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;layui-upload-list&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;videoPlay&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;~/Content/layer-v3.1.1/layer/layer.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;~/Content/layui-v2.4.5/layui.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;


&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;layer.js视频上传&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt;&lt;span&gt; upload;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;上传图片&lt;/span&gt;
&lt;span&gt;    layui.use(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;upload&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
        upload &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; layui.upload;

        upload.render({
            before: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
                layer.msg(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;视频努力上传中,请耐心等待...&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, { icon: &lt;/span&gt;&lt;span&gt;16&lt;/span&gt;&lt;span&gt;, shade: &lt;/span&gt;&lt;span&gt;0.8&lt;/span&gt;&lt;span&gt;, time: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt; });
            },
            elem: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#VideoBtn&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
            , url: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;@Url.Action(&quot;FileLoad&quot;,&quot;FileUpload&quot;)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
            , accept: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;video&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;视频&lt;/span&gt;
&lt;span&gt;            , exts: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;mp4&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;只允许上传的后缀(mp4文件)&lt;/span&gt;
&lt;span&gt;            , done: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (res) {
                console.log(res);
                layer.closeAll();
                layer.msg(res.msg);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (res.code &lt;/span&gt;&lt;span&gt;==&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;) {
                    $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#Video&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).val(res.path);
                    $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#videoPlay&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).html(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;video controls=&quot;controls&quot; id=&quot;currentVideo&quot; style=&quot;width:400px;&quot;&amp;gt;&amp;lt;source src=&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;+&lt;/span&gt;&lt;span&gt; res.path &lt;/span&gt;&lt;span&gt;+&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&quot; type=&quot;video/mp4&quot; /&amp;gt;&amp;lt;/video&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
                    $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#videoPlay&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).show();
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 自动播放&lt;/span&gt;
&lt;span&gt;                    $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#currentVideo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;].play();
                }
            }
        });


        $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.layui-upload-list&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).on(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;click&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;i&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
            $(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;).parent().remove();
        });
    });
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt; 统一文件，图片，视频，音频上传服务(FileUploadController):&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * Authority：追追时光者
 * CreateTime：2020.08.01
 * Description：文件，图片，视频，音频统一上传接口
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.IO;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Web;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Web.Mvc;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; VideoUpload.Controllers
{
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 文件，图片，视频，音频统一上传服务
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FileUploadController : Controller
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 对验证和处理 HTML 窗体中的输入数据所需的信息进行封装，如FromData拼接而成的文件[图片,视频，文档等文件上传]
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;context&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;FemContext对验证和处理html窗体中输入的数据进行封装&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt;        [AcceptVerbs(HttpVerbs.Post)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ActionResult FileLoad(FormContext context)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;FemContext对验证和处理html窗体中输入的数据进行封装&lt;/span&gt;
&lt;span&gt;        {

            HttpPostedFileBase httpPostedFileBase &lt;/span&gt;= Request.Files[&lt;span&gt;0&lt;/span&gt;];&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取文件流&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (httpPostedFileBase != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
                {
                    ControllerContext.HttpContext.Request.ContentEncoding &lt;/span&gt;= Encoding.GetEncoding(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    ControllerContext.HttpContext.Response.Charset &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

                    &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; fileName = Path.GetFileName(httpPostedFileBase.FileName);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;原始文件名称&lt;/span&gt;
                    &lt;span&gt;string&lt;/span&gt; fileExtension = Path.GetExtension(fileName);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;文件扩展名&lt;/span&gt;

                    &lt;span&gt;byte&lt;/span&gt;[] fileData = ReadFileBytes(httpPostedFileBase);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;文件流转化为二进制字节&lt;/span&gt;

                    &lt;span&gt;string&lt;/span&gt; result = SaveFile(fileExtension, fileData);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;文件保存&lt;/span&gt;
                    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;.IsNullOrEmpty(result) ? Json(&lt;span&gt;new&lt;/span&gt; { code = &lt;span&gt;0&lt;/span&gt;, path = &lt;span&gt;&quot;&quot;&lt;/span&gt;, msg = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;网络异常，文件上传失败~&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; }) : Json(&lt;span&gt;new&lt;/span&gt; { code = &lt;span&gt;1&lt;/span&gt;, path = result, msg = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;文件上传成功&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; });
                }
                &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
                {
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Json(&lt;span&gt;new&lt;/span&gt; { code = &lt;span&gt;0&lt;/span&gt;, msg = ex.Message, path = &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt; });
                }
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Json(&lt;span&gt;new&lt;/span&gt; { code = &lt;span&gt;0&lt;/span&gt;, path = &lt;span&gt;&quot;&quot;&lt;/span&gt;, msg = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;网络异常，文件上传失败~&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; });
            }
        }


        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 将文件流转化为二进制字节
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;fileData&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;图片文件流&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[] ReadFileBytes(HttpPostedFileBase fileData)
        {
            &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[] data;
            &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; inputStream =&lt;span&gt; fileData.InputStream)
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!(inputStream &lt;span&gt;is&lt;/span&gt;&lt;span&gt; MemoryStream memoryStream))
                {
                    memoryStream &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MemoryStream();
                    inputStream.CopyTo(memoryStream);
                }
                data &lt;/span&gt;=&lt;span&gt; memoryStream.ToArray();
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; data;
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 保存文件
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;fileExtension&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;文件扩展名&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;fileData&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;图片二进制文件信息&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; SaveFile(&lt;span&gt;string&lt;/span&gt; fileExtension, &lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[] fileData)
        {
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt; result;
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; saveName = Guid.NewGuid().ToString() + fileExtension; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;保存文件名称&lt;/span&gt;
            &lt;span&gt;string&lt;/span&gt; basePath = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UploadFile&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; saveDir = DateTime.Now.ToString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;yyyy-MM-dd&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 文件上传后的保存路径&lt;/span&gt;
            &lt;span&gt;string&lt;/span&gt; serverDir = Path.Combine(Server.MapPath(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;~/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;), basePath, saveDir);

            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; fileNme = Path.Combine(serverDir, saveName);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;保存文件完整路径&lt;/span&gt;
            &lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; savePath =&lt;span&gt; Path.Combine(saveDir, saveName);

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;项目中是否存在文件夹，不存在创建&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;Directory.Exists(serverDir))
                {
                    Directory.CreateDirectory(serverDir);
                }

                System.IO.File.WriteAllBytes(fileNme, fileData);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;WriteAllBytes创建一个新的文件，按照对应的文件流写入，假如已存在则覆盖

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回前端项目文件地址&lt;/span&gt;
                result = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + basePath + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + saveDir + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; saveName;
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
            {
                result &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;发生错误&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; ex.Message;
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
        }

    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;参考文章：&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/iis/configuration/system.webServer/security/requestFiltering/requestLimits/&quot; target=&quot;_blank&quot;&gt;https://docs.microsoft.com/en-us/iis/configuration/system.webServer/security/requestFiltering/requestLimits/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.webkaka.com/tutorial/asp.net/2018/051026/&quot; target=&quot;_blank&quot;&gt;http://www.webkaka.com/tutorial/asp.net/2018/051026/&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 31 Jul 2020 17:52:00 +0000</pubDate>
<dc:creator>追逐时光者</dc:creator>
<og:description>前言： 前段时间在使用APS.NET MVC+LayUI做视频上传功能的时，发现当上传一些内存比较大的视频就会提示上传失败，后来通过查阅相关资料发现.NET MVC框架为考虑安全问题，在运行时对请求的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Can-daydayup/p/12638301.html</dc:identifier>
</item>
<item>
<title>JavaScript 闭包 - 云崖先生</title>
<link>http://www.cnblogs.com/Yunya-Cnblogs/p/13413061.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Yunya-Cnblogs/p/13413061.html</guid>
<description>&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;作用域&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　在&lt;span class=&quot;md-plain&quot;&gt;&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;Js&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;中，所有的名字（变量/常量/函数/类）都有一个作用范围，这被称之为作用域。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;全局作用域&lt;/span&gt;&lt;/h3&gt;

&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;全局作用域即是在全局下定义的名字作用范围，在&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;Js&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;中全局作用域中的名字全局有效，在任何作用域中都能进行访问。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;　　生命周期：页面打开则产生，页面完毕时销毁&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;　　数量：最多只有一个&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;https://img2020.cnblogs.com/blog/1881426/202008/1881426-20200801010321464-2056870327.png&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1881426/202008/1881426-20200801010321464-2056870327.png&quot; alt=&quot;image-20200731233734502&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;局部作用域&lt;/span&gt;&lt;/h3&gt;

&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;局部作用域通常是指在函数中定义的名字作用范围，局部有效，外部不能访问。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;生命周期：对于函数的局部作用域来说，函数调用时存活，调用完毕则销毁，也就是说每次调用函数都会新增一个局部作用域。函数执行完毕后该作用域将不复存在。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;数量：可以有多个局部作用域&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;https://img2020.cnblogs.com/blog/1881426/202008/1881426-20200801010258599-2106710931.png&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1881426/202008/1881426-20200801010258599-2106710931.png&quot; alt=&quot;image-20200731234314517&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;块级作用域&lt;/span&gt;&lt;/h3&gt;

&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;块级作用域的范围小了很多，它只包含在&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;{}&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;中由&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;let/const&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;定义的名字的作用范围，也是局部有效，外部不能访问。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;生命周期：块级作用域是可以有多个的，生命周期为当执行块级作用域中代码块时块级作用域存活，执行完毕后块级作用域销毁。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;数量：可以有多个块级作用域&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;https://img2020.cnblogs.com/blog/1881426/202008/1881426-20200801010254573-1947801070.png&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1881426/202008/1881426-20200801010254573-1947801070.png&quot; alt=&quot;image-20200731235222291&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;名字查找顺序&lt;/span&gt;&lt;/h3&gt;

&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;先到自身的作用域中查找，如果没有再到定义自己作用域的作用域中进行查找。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;https://img2020.cnblogs.com/blog/1881426/202008/1881426-20200801010243700-679859602.png&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1881426/202008/1881426-20200801010243700-679859602.png&quot; alt=&quot;image-20200731235914695&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;script&amp;gt;&lt;span&gt;
​
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;use strict&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
​
        let username &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;云崖&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
​
        let age &lt;/span&gt;= &lt;span&gt;18&lt;/span&gt;&lt;span&gt;;
​
        function show() {
​
​
                let username &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Yunya&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果这里注释掉下面的查找结果是云崖&lt;/span&gt;
&lt;span&gt;​
                let age &lt;/span&gt;= &lt;span&gt;16&lt;/span&gt;&lt;span&gt;;
​
                console.log(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;show...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
​
                (function () {
​
                        console.log(username);  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Yunya&lt;/span&gt;
&lt;span&gt;​
                }());
​
        }
​
        show();
​
​
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;块级作用域的封装&lt;/span&gt;&lt;/h3&gt;

&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;在之前没有块级作用域这一概念之前进行模块封装都是使用自执行函数利用它函数局部作用域的特性进行封装，但是现在有了&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;let/const&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;块级作用域后我们又有了新的封装方式。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-pair-s&quot;&gt;&lt;strong&gt;封装&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
​
        let show &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
                console.log(&lt;/span&gt;&quot;执行了show功能&quot;&lt;span&gt;);
        }
​
        let test &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
                console.log(&lt;/span&gt;&quot;执行了test功能&quot;&lt;span&gt;);
        }
​
        window.module &lt;/span&gt;=&lt;span&gt; { show, test };
​
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-pair-s&quot;&gt;&lt;strong&gt;调用&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;script src=&quot;JavaScript.js&quot;&amp;gt;&amp;lt;/script&amp;gt; 
&amp;lt;script&amp;gt;&lt;span&gt;
​
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 注意上面要引入模块&lt;/span&gt;
    
        &quot;use strict&quot;&lt;span&gt;;
​
        module.show();
        module.test();
​
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;闭包&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;闭包其实非常简单，它是基于函数嵌套+作用域+函数参数进行实现的。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;闭：一个封闭的函数，不能被外部直接调用，所以该函数肯定是在一个局部作用域或块级作用域中。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;包：一个包裹闭函数的函数被称之为包函数。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;我们一定要注意一件事，即局部作用域的销毁是在函数执行完后进行销毁，但是这个销毁时机是有讲究的。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;如果我们将局部作用域中的一个名字返回出去，那么该局部作用域的销毁时机是什么呢？这个得看情况。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;该名字指向的是一个值类型：立即销毁！值类型直接复制值就好了。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;该名字指向的是一个引用类型：不销毁！引用类型可能会被引用，你把局部作用域销毁了那块内存地址就空了，引用类型还引用个毛线。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;script&amp;gt;&lt;span&gt;
​
        &lt;/span&gt;&quot;use strict&quot;&lt;span&gt;;
​
        &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; outer(){
​
                let username &lt;/span&gt;= &quot;云崖&quot;&lt;span&gt;;
​
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 由于返回的是一个引用对象，故outer的作用域环境不会被销毁，如果销毁了内存地址清空就找不到这个&lt;/span&gt;
                &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 函数了，由于outer的作用域环境不会销毁那么username也将会存活。&lt;/span&gt;
&lt;span&gt;​
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){ 
​
                        console.log(username);  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 自己找不到，去上层找呗。然后找到了 云崖 &lt;/span&gt;
&lt;span&gt;​
                }
​
        }
​
        let func &lt;/span&gt;= outer(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; func就是返回出来的匿名函数&lt;/span&gt;
&lt;span&gt;        func();
​
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;闭包注意事项&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;少用，少用。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;不销毁局部作用域代表不销毁这一块的内存，因此每做一个闭包函数一旦调用就会多出一块跟随全局作用域销毁的局部作用域，如果调用多了这个闭包函数那就emmm....&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-plain&quot;&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 31 Jul 2020 17:06:00 +0000</pubDate>
<dc:creator>云崖先生</dc:creator>
<og:description>JavaScript 闭包 作用域 在Js中，所有的名字（变量/常量/函数/类）都有一个作用范围，这被称之为作用域。 全局作用域 全局作用域即是在全局下定义的名字作用范围，在Js中全局作用域中的名字全</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Yunya-Cnblogs/p/13413061.html</dc:identifier>
</item>
<item>
<title>设计模式之享元模式 - WeihanLi</title>
<link>http://www.cnblogs.com/weihanli/p/flyweight-pattern.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/weihanli/p/flyweight-pattern.html</guid>
<description>&lt;h2 id=&quot;intro&quot;&gt;Intro&lt;/h2&gt;
&lt;p&gt;享元是指一个可复用的对象，通过复用这个享元来减少应用中的内存分配。&lt;/p&gt;
&lt;p&gt;享元模式是为了减少内存占用，尽可能复用已有对象的设计模式，一般来说会把这个可复用的对象放到一个外部的数据结构中，当需要使用到的时候传给享元。&lt;/p&gt;
&lt;p&gt;享元模式的意图是复用对象，节省内存，前提是享元对象是不可变对象。&lt;/p&gt;
&lt;p&gt;具体来讲，当一个系统中存在大量重复对象的时候，我们就可以利用享元模式，将对象设计成享元，在内存中只保留一份实例，供多处代码引用，这样可以减少内存中对象的数量，以起到节省内存的目的。&lt;/p&gt;
&lt;p&gt;实际上，不仅仅相同对象可以设计成享元，对于相似对象，我们也可以将这些对象中相同的部分（字段），提取出来设计成享元，让这些大量相似对象引用这些享元。&lt;/p&gt;
&lt;h2 id=&quot;sample&quot;&gt;Sample&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public abstract class Flyweight
{
    public abstract void Operation(int extrinsicstate);
}

public class ConcreteFlyweight : Flyweight
{
    public override void Operation(int extrinsicstate)
    {
        Console.WriteLine(&quot;operation in ConcreteFlyweight&quot;);
    }
}

public class UnsharedFlyweight : Flyweight
{
    public override void Operation(int extrinsicstate)
    {
        Console.WriteLine(&quot;operation in UnsharedFlyweight&quot;);
    }
}

public class FlyWeightFactory
{
    private readonly ConcurrentDictionary&amp;lt;string, Flyweight&amp;gt; _flyweights = new ConcurrentDictionary&amp;lt;string, Flyweight&amp;gt;();

    public Flyweight GetFlyweight(string name) =&amp;gt; _flyweights.GetOrAdd(name, n =&amp;gt; new ConcreteFlyweight());
}

public class Program
{
    public static void Main(string[] args)
    {
        var counter = 20;

        var factory = new FlyWeightFactory();
        factory.GetFlyweight(&quot;X&quot;).Operation(counter--);
        factory.GetFlyweight(&quot;Y&quot;).Operation(counter--);
        factory.GetFlyweight(&quot;X&quot;).Operation(counter--);

        new UnsharedFlyweight().Operation(counter--);

        factory.GetFlyweight(&quot;X&quot;).Operation(counter--);

        Console.WriteLine(counter);
        Console.ReadLine();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;more&quot;&gt;More&lt;/h2&gt;
&lt;p&gt;享元模式的代码实现非常简单，主要是通过工厂模式，在工厂类中，通过一个 Dictionary 或数组等 来缓存已经创建好的享元对象，以达到复用的目的，可以参考上面的示例。&lt;/p&gt;
&lt;p&gt;来看一道经典的 C# 面试题目：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;var a = &quot;Hello World&quot;;
var b = &quot;Hello World&quot;;
Console.WriteLine(ReferenceEquals(a, b));
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;想一下输出结果是什么，不确定的话可以试一下哈&lt;/p&gt;
&lt;p&gt;CLR 中 string 是一个特殊的类型，string 有一个字符串池（&lt;code&gt;Intern&lt;/code&gt;） 的实现就属于是享元模式的体现，这也是上面的输出结果的原因，相同的字符串变量值指向了同一块内存地址&lt;/p&gt;
&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
</description>
<pubDate>Fri, 31 Jul 2020 16:35:00 +0000</pubDate>
<dc:creator>WeihanLi</dc:creator>
<og:description>复用对象，减少内存占用，享元模式</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/weihanli/p/flyweight-pattern.html</dc:identifier>
</item>
<item>
<title>Guava基本工具--常见Object方法 - 不懒人</title>
<link>http://www.cnblogs.com/wuwuyong/p/13413006.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wuwuyong/p/13413006.html</guid>
<description>&lt;p&gt;在Java中Object类是所有类的父类，其中有几个需要override的方法比如equals,hashCode和toString等方法。每次写这几个方法都要做很多重复性的判断, 很多类库提供了覆写这几个方法的工具类, Guava也提供了类似的方式。下面我们来看看Guava中这几个方法简单使用。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;equals方法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;equals是一个经常需要覆写的方法， 可以查看Object的equals方法注释， 对equals有几个性质的要求：&lt;br/&gt;　　　&lt;strong&gt;　1. 自反性reflexive：&lt;/strong&gt;任何非空引用x，x.equals(x)返回为true；&lt;br/&gt;　　　　&lt;strong&gt;2. 对称性symmetric：&lt;/strong&gt;任何非空引用x和y，x.equals(y)返回true当且仅当y.equals(x)返回true；&lt;br/&gt;　　　　&lt;strong&gt;3. 传递性transitive：&lt;/strong&gt;任何非空引用x和y，如果x.equals(y)返回true，并且y.equals(z)返回true，那么x.equals(z)返回true；&lt;br/&gt;　　　　&lt;strong&gt;4. 一致性consistent：&lt;/strong&gt;两个非空引用x和y，x.equals(y)的多次调用应该保持一致的结果，（前提条件是在多次比较之间没有修改x和y用于比较的相关信息）；&lt;br/&gt;　　　　&lt;strong&gt;5. 对于所有非null的值x， x.equals(null)都要返回false&lt;/strong&gt;。 (如果你要用null.equals(x)也可以，会报NullPointerException)。&lt;/p&gt;
&lt;p&gt;　　当我们要覆写的类中某些值可能为null的时候，就需要对null做很多判断和分支处理。 使用Guava的Objects.equal方法可以避免这个问题， 使得equals的方法的覆写变得更加容易， 而且可读性强，简洁优雅。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;pre&gt;
import org.junit.Test;
import com.google.common.base.Objects;

public class ObjectTest {
    
    @Test
    public void equalTest() {
        System.out.println(Objects.equal(&quot;a&quot;, &quot;a&quot;));
        System.out.println(Objects.equal(null, &quot;a&quot;)); 
        System.out.println(Objects.equal(&quot;a&quot;, null)); 
        System.out.println(Objects.equal(null, null));
    }
    
    @Test
    public void equalPersonTest() {
        System.out.println(Objects.equal(new Person(&quot;peida&quot;,23), new Person(&quot;peida&quot;,23)));
        Person person=new Person(&quot;peida&quot;,23);
        System.out.println(Objects.equal(person,person));
    }
}

class Person {
    public String name;
    public int age;

    Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
}
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;　　运行输出：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;pre&gt;
true
false
false
true
false
true
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;　　hashCode方法：&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;当覆写（override）了equals()方法之后，必须也覆写hashCode()方法，反之亦然。这个方法返回一个整型值（hash code value），如果两个对象被equals()方法判断为相等，那么它们就应该拥有同样的hash code。Object类的hashCode()方法为不同的对象返回不同的值，Object类的hashCode值表示的是对象的地址。&lt;br/&gt;　　hashCode的一般性契约（需要满足的条件）如下：&lt;br/&gt;　　1.在Java应用的一次执行过程中，如果对象用于equals比较的信息没有被修改，那么同一个对象多次调用hashCode()方法应该返回同一个整型值。应用的多次执行中，这个值不需要保持一致，即每次执行都是保持着各自不同的值。&lt;br/&gt;　　2.如果equals()判断两个对象相等，那么它们的hashCode()方法应该返回同样的值。&lt;br/&gt;　　3.并没有强制要求如果equals()判断两个对象不相等，那么它们的hashCode()方法就应该返回不同的值。即，两个对象用equals()方法比较返回false，它们的hashCode可以相同也可以不同。但是，应该意识到，为两个不相等的对象产生两个不同的hashCode可以改善哈希表的性能。&lt;br/&gt;　　写一个hashCode本来也不是很难，但是Guava提供给我们了一个更加简单的方法--Objects.hashCode(Object ...)， 这是个可变参数的方法，参数列表可以是任意数量，所以可以像这样使用Objects.hashCode(field1， field2， ...， fieldn)。非常方便和简洁。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;pre&gt;
import org.junit.Test;
import com.google.common.base.Objects;

public class ObjectTest {    
    @Test
    public void hashcodeTest() {
        System.out.println(Objects.hashCode(&quot;a&quot;));
        System.out.println(Objects.hashCode(&quot;a&quot;));
        System.out.println(Objects.hashCode(&quot;a&quot;,&quot;b&quot;));
        System.out.println(Objects.hashCode(&quot;b&quot;,&quot;a&quot;));
        System.out.println(Objects.hashCode(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;));
        
        Person person=new Person(&quot;peida&quot;,23);
        System.out.println(Objects.hashCode(person));
        System.out.println(Objects.hashCode(person));
    }
}

class Person {
    public String name;
    public int age;

    Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
}
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;pre&gt;
128
4066
4096
126145
19313256
19313256
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;　　toString()方法：&lt;/p&gt;
&lt;p&gt;　　因为每个类都直接或间接地继承自Object，因此每个类都有toString()方法。这个方法是用得最多的, 覆写得最多, 一个好的toString方法对于调试来说是非常重要的, 但是写起来确实很不爽。Guava也提供了toString（）方法。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;pre&gt;
import org.junit.Test;
import com.google.common.base.Objects;

public class ObjectTest {
    
    @Test
    public void toStringTest() {
        System.out.println(Objects.toStringHelper(this).add(&quot;x&quot;, 1).toString());
        System.out.println(Objects.toStringHelper(Person.class).add(&quot;x&quot;, 1).toString());
        
        Person person=new Person(&quot;peida&quot;,23);
        String result = Objects.toStringHelper(Person.class)
        .add(&quot;name&quot;, person.name)
        .add(&quot;age&quot;, person.age).toString();      
        System.out.print(result);
    }
}

class Person {
    public String name;
    public int age;

    Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
}

//============输出===============
ObjectTest{x=1}
Person{x=1}
Person{name=peida, age=23}
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;　　compare/compareTo方法：&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;CompareTo：&lt;/strong&gt;compareTo(Object o)方法是java.lang.Comparable&amp;lt;T&amp;gt;接口中的方法，当需要对某个类的对象进行排序时，该类需要实现 Comparable&amp;lt;T&amp;gt;接口的，必须重写public int compareTo(T o)方法。java规定，若a，b是两个对象，当a.compareTo(b)&amp;gt;0时，则a大于b，a.compareTo(b)&amp;lt;0时，a&amp;lt;b，即规定对象的比较大小的规则；&lt;br/&gt;　　&lt;strong&gt;compare：&lt;/strong&gt; compare(Object o1,Object o2)方法是java.util.Comparator&amp;lt;T&amp;gt;接口的方法，compare方法内主要靠定义的compareTo规定的对象大小关系规则来确定对象的大小。&lt;/p&gt;
&lt;p&gt;　　compareTo方法的通用约定与equals类似：将本对象与指定的对象停止比拟，如果本对象小于、等于、或大于指定对象，则分离返回正数、零、或正数。如果指定的对象类型无法与本对象停止比拟，则跑出ClassCastException。&lt;br/&gt;　　&lt;strong&gt;对称性：&lt;/strong&gt;实现者必须保证对全部的x和y都有sgn(x.compareTo(y)) == -sgn(y.compareTo(x))。这也暗示当且仅当y.compareTo(x)抛出异常时，x.compareTo(y)才抛出异常。&lt;br/&gt;　　&lt;strong&gt;传递性：&lt;/strong&gt;实现者必须保证比拟关系是可传递的，如果x.compareTo(y) &amp;gt; 0且y.compareTo(z) &amp;gt; 0，则x.compareTo(z) &amp;gt; 0。实现者必须保证x.compareTo(y)==0暗示着全部的z都有(x.compareTo(z)) == (y.compareTo(z))。&lt;br/&gt;　　&lt;strong&gt;虽不强制要求，但强烈建议(x.compareTo(y) == 0) == (x.equals(y))。&lt;/strong&gt;一般来说，任何实现了Comparable的类如果违背了这个约定，都应该明白说明。推荐这么说：“注意：本类拥有自然顺序，但与equals不一致”。&lt;br/&gt;　　第一条指出，如果颠倒两个比拟对象的比拟顺序，就会发生以下情况：如果第一个对象小于第二个对象，则第二个对象必须大于第一个对象；如果第一个对象等于第二个对象，则第二个对象也必须等于第一个对象；如果第一个对象大于第二个对象，则第二个对象小于第一个对象。&lt;br/&gt;　　第二条指出，如果第一个对象大于第二个对象，第二个对象大于第三个对象，则第一个大于第三个。&lt;br/&gt;　　第三条指出，对于两个相称的对象，他们与其他任何对象比拟结果应该雷同。&lt;br/&gt;　　这三条约定的一个结果是，compareTo方法的等同性测试必须与equals方法满意雷同的约束条件：自反性、对称性、传递性。所以也存在类同的约束：不能在扩展一个可实例化的类并添加新的值组件时，同时保证compareTo的约定，除非你愿意放弃面向对象抽象的优势。可以用与equals雷同的规避措施：如果想在实现Comparable接口的类中增加一个值组件，就不要扩展它；应该写一个不相干的类，其中包括第一个类的实例。然后供给一个view方法返回该实例。这样你就可以再第二个类上实现任何compareTo方法，同时允许客户在须要的时候将第二个类看成是第一个类的一个实例。&lt;br/&gt;　　compareTo约定的最后一段是一个强烈的建议而非真正的约定，即compareTo方法的等同性测试必须与equals方法的结果雷同。如果遵照了这一条，则称compareTo方法所施加的顺序与equals一致；反之则称为与equals不一致。当然与equals不一致的compareTo方法仍然是可以工作的，但是，如果一个有序集合包括了该类的元素，则这个集合可能就不能遵照响应集合接口（Collection、Set、Map）的通用约定。这是因为这些接口的通用约定是基于equals方法的，但是有序集合却使用了compareTo而非equals来执行。&lt;/p&gt;
&lt;p&gt;　　下面我们简单自己实现一个类的compareTo方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;pre&gt;
import org.junit.Test;

public class ObjectTest {
    
    
    @Test
    public void compareTest(){
        Person person=new Person(&quot;peida&quot;,23);
        Person person1=new Person(&quot;aida&quot;,25);
        Person person2=new Person(&quot;aida&quot;,25);
        Person person3=new Person(&quot;aida&quot;,26);
        Person person4=new Person(&quot;peida&quot;,26);
        
        System.out.println(person.compareTo(person1));
        System.out.println(person1.compareTo(person2));
        System.out.println(person1.compareTo(person3));
        System.out.println(person.compareTo(person4));
        System.out.println(person4.compareTo(person));    
    }
}

class Person implements Comparable&amp;lt;Person&amp;gt;{
    public String name;
    public int age;

    Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
    
    @Override
    public int compareTo(Person other) {
        int cmpName = name.compareTo(other.name);
        if (cmpName != 0) {
            return cmpName;
        }
        if(age&amp;gt;other.age){
            return 1;
        }
        else if(age&amp;lt;other.age){
            return -1;
        }
        return 0;  
    }
}
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;pre&gt;
//========输出===========&lt;br/&gt;15
0
-1
-1
1
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;　　上面的compareTo方法，代码看上去并不是十分优雅，如果实体属性很多，数据类型丰富，代码可读性将会很差。在guava里, 对所有原始类型都提供了比较的工具函数来避免这个麻烦. 比如对Integer, 可以用Ints.compare()。利用guava的原始类型的compare，我们对上面的方法做一个简化，实现compare方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;pre&gt;
class PersonComparator implements Comparator&amp;lt;Person&amp;gt; {  
    @Override 
    public int compare(Person p1, Person p2) {  
      int result = p1.name.compareTo(p2.name);  
      if (result != 0) {  
        return result;  
      }  
      return Ints.compare(p1.age, p2.age);  
    }  
  }  
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;　　上面的代码看上去简单了一点，但还是不那么优雅简单，对此, guava有一个相当聪明的解决办法, 提供了ComparisonChain:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;pre&gt;
class Student implements Comparable&amp;lt;Student&amp;gt;{
    public String name;
    public int age;
    public int score;    
    
    Student(String name, int age,int score) {
        this.name = name;
        this.age = age;
        this.score=score;
    }
    
    @Override
    public int compareTo(Student other) {
        return ComparisonChain.start()
        .compare(name, other.name)
        .compare(age, other.age)
        .compare(score, other.score, Ordering.natural().nullsLast())
        .result();
    }
}

class StudentComparator implements Comparator&amp;lt;Student&amp;gt; {  
    @Override public int compare(Student s1, Student s2) {  
      return ComparisonChain.start()  
          .compare(s1.name, s2.name)  
          .compare(s1.age, s2.age)  
          .compare(s1.score, s2.score)  
          .result();  
    }  
  }  
}
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;ComparisonChain是一个lazy的比较过程， 当比较结果为0的时候， 即相等的时候， 会继续比较下去， 出现非0的情况， 就会忽略后面的比较。ComparisonChain实现的compare和compareTo在代码可读性和性能上都有很大的提高。&lt;/p&gt;
&lt;p&gt;　　下面来一个综合应用实例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;65&quot;&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;pre&gt;
import java.util.Comparator;

import org.junit.Test;

import com.google.common.base.Objects;
import com.google.common.collect.ComparisonChain;
import com.google.common.collect.Ordering;

public class ObjectTest {

    
    @Test
    public void StudentTest(){
        
        Student student=new Student(&quot;peida&quot;,23,80);
        Student student1=new Student(&quot;aida&quot;,23,36);
        Student student2=new Student(&quot;jerry&quot;,24,90);
        Student student3=new Student(&quot;peida&quot;,23,80);
        
        System.out.println(&quot;==========equals===========&quot;);
        System.out.println(student.equals(student2));
        System.out.println(student.equals(student1));
        System.out.println(student.equals(student3));
        
        System.out.println(&quot;==========hashCode===========&quot;);
        System.out.println(student.hashCode());
        System.out.println(student1.hashCode());
        System.out.println(student3.hashCode());
        System.out.println(student2.hashCode());
        
        System.out.println(&quot;==========toString===========&quot;);
        System.out.println(student.toString());
        System.out.println(student1.toString());
        System.out.println(student2.toString());
        System.out.println(student3.toString());
        
        System.out.println(&quot;==========compareTo===========&quot;);
        System.out.println(student.compareTo(student1));
        System.out.println(student.compareTo(student2));
        System.out.println(student2.compareTo(student1));
        System.out.println(student2.compareTo(student));
        
    }

}

class Student implements Comparable&amp;lt;Student&amp;gt;{
    public String name;
    public int age;
    public int score;
    
    
    Student(String name, int age,int score) {
        this.name = name;
        this.age = age;
        this.score=score;
    }
    
    @Override
    public int hashCode() {
        return Objects.hashCode(name, age);
    }
    
    
    @Override
    public boolean equals(Object obj) {
        if (obj instanceof Student) {
            Student that = (Student) obj;
            return Objects.equal(name, that.name)
                    &amp;amp;&amp;amp; Objects.equal(age, that.age)
                    &amp;amp;&amp;amp; Objects.equal(score, that.score);
        }
        return false;
    }
    
    @Override
    public String toString() {
        return Objects.toStringHelper(this)
                .addValue(name)
                .addValue(age)
                .addValue(score)
                .toString();
    }
    
    
    @Override
    public int compareTo(Student other) {
        return ComparisonChain.start()
        .compare(name, other.name)
        .compare(age, other.age)
        .compare(score, other.score, Ordering.natural().nullsLast())
        .result();
    }
}



class StudentComparator implements Comparator&amp;lt;Student&amp;gt; {  
    @Override public int compare(Student s1, Student s2) {  
      return ComparisonChain.start()  
          .compare(s1.name, s2.name)  
          .compare(s1.age, s2.age)  
          .compare(s1.score, s2.score)  
          .result();  
    }  
  }  

//=============运行输出===========================
==========equals===========
false
false
true
==========hashCode===========
-991998617
92809683
-991998617
-1163491205
==========toString===========
Student{peida, 23, 80}
Student{aida, 23, 36}
Student{jerry, 24, 90}
Student{peida, 23, 80}
==========compareTo===========
1
1
1
-1
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;　转载：&lt;a href=&quot;https://www.cnblogs.com/peida/p/Guava_Objects.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/peida/p/Guava_Objects.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 31 Jul 2020 16:29:00 +0000</pubDate>
<dc:creator>不懒人</dc:creator>
<og:description>在Java中Object类是所有类的父类，其中有几个需要override的方法比如equals,hashCode和toString等方法。每次写这几个方法都要做很多重复性的判断, 很多类库提供了覆写这</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wuwuyong/p/13413006.html</dc:identifier>
</item>
<item>
<title>Ubuntu16.04编译Openjdk8,笔者亲测编译成功 - 路仁甲</title>
<link>http://www.cnblogs.com/lusaisai/p/13412478.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lusaisai/p/13412478.html</guid>
<description>&lt;p&gt;现在很多语言都不开发运行环境了，都选择在JRE上运行，足以证明JVM的优越。你精通了JVM，未来的路才可能走得轻松。这篇文章是你走近jvm的第一篇,编译Openjdk8源码&lt;/p&gt;

&lt;p&gt;　　操作系统：Ubuntu16 (ubuntu-16.04.6-desktop-amd64.iso)&lt;/p&gt;
&lt;p&gt;　　boot jdk：jdk7 (jdk-7u80-linux-x64.tar.gz)&lt;/p&gt;
&lt;p&gt;　　Openjdk：jdk8 (openjdk-8u40-src-b25-10_feb_2015.zip)&lt;/p&gt;

&lt;p&gt;Ubuntu提供两种进入方式，一个是我们平常最熟悉的图形界面形式，还有一种是纯命令行方式&lt;/p&gt;
&lt;p&gt;Ctrl + Alt + F6 即可进入纯命令行模式,进入后，需要输入用户名，密码&lt;/p&gt;
&lt;p&gt;接着安装vim工具,并用vim打开如下文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;sudo&lt;/span&gt; vim /etc/network/interfaces
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;添加以下内容&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180430153830131?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNDA4MTEz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;修改如下文件，将managed设置为true,如果是只读文件,需要授权(此处不再赘述)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
/etc/NetworkManager/NetworkManager.conf
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180430153945268?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNDA4MTEz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;打开如下文件， 添加内容&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
/etc/resolvconf/resolv.conf.d/base
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180430154041354?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNDA4MTEz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;重启网络服务&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
service network-manager restart
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Ubuntu 更改文件权限及chmod详细用法如下：&lt;br/&gt;一、常用方法如下：（其中×××指文件名）&lt;br/&gt; （所有者有读和写的权限，组用户只有读的权限）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;sudo&lt;/span&gt; &lt;span&gt;chmod&lt;/span&gt; &lt;span&gt;644&lt;/span&gt; ×××
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（每个人都有读和写以及执行的权限）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;sudo&lt;/span&gt; &lt;span&gt;chmod&lt;/span&gt; &lt;span&gt;777&lt;/span&gt; ××× 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输入以下命令进行安装远程ssh服务&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# sudo apt-get install openssh-server
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;若没有ssh，需要执行&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# sudo apt-get install ssh
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(设置完静态ip,并用xshell远程连接成功,如下图)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1671142/202007/1671142-20200731211519288-425523516.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;



&lt;p&gt;1、安装依赖(这步比较慢,耐心等待)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;sudo&lt;/span&gt; apt-get &lt;span&gt;install&lt;/span&gt; libx11-dev libxext-dev libxrender-dev libxtst-dev libxt-dev libcups2-dev libfreetype6-dev libasound2-dev ccache
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;或者&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;sudo&lt;/span&gt; apt-get &lt;span&gt;install&lt;/span&gt; libx11-dev libxext-dev libxrender-dev libxtst-dev libxt-&lt;span&gt;dev
&lt;/span&gt;&lt;span&gt;sudo&lt;/span&gt; apt-get &lt;span&gt;install&lt;/span&gt; libcups2-&lt;span&gt;dev
&lt;/span&gt;&lt;span&gt;sudo&lt;/span&gt; apt-get &lt;span&gt;install&lt;/span&gt; libfreetype6-&lt;span&gt;dev
&lt;/span&gt;&lt;span&gt;sudo&lt;/span&gt; apt-get &lt;span&gt;install&lt;/span&gt; libasound2-dev
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;2、安装boot jdk&lt;/p&gt;
&lt;p&gt;因为openjdk源码中有些功能是用Java代码实现的，比如调试工具：jps、jstat等，还有一些核心jar包，如rt.jar、tools.jar等，都需要相应版本的JDK。boot jdk需要比你编译的jdk版本低,这里我们用jdk7&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1671142/202007/1671142-20200731212703737-1456677627.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 直接解压到Documents目录下，然后配置下环境&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;tar&lt;/span&gt; zxvf jdk-7u80-linux-x64.&lt;span&gt;tar&lt;/span&gt;.gz 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;配置path&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
vim ~/.bashrc
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;code-snippet__js&quot; data-lang=&quot;bash&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;文件底部加入下面三句话(改成你自己的用户名)&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
export JAVA_HOME=/home/lusai/Documents/jdk1.&lt;span&gt;7&lt;/span&gt;&lt;span&gt;.0_80
export CLASSPATH&lt;/span&gt;=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/&lt;span&gt;tools.jar
export PATH&lt;/span&gt;=$JAVA_HOME/bin:$ANT_HOME/bin:$PATH
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;让配置的path重新生效&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
source ~/.bashrc
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查看是否安装成功&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
java -version
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1671142/202007/1671142-20200731214850610-92825775.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;3.解压openjdk8 ,&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1671142/202007/1671142-20200731224053858-503942438.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 安装 unzip&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;sudo&lt;/span&gt; apt &lt;span&gt;install&lt;/span&gt; &lt;span&gt;unzip&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;进入 openjdk8 的主目录,解压文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;unzip&lt;/span&gt; openjdk-8u40-src-b25-10_feb_2015.&lt;span&gt;zip&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;进去解压的文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
cd /home/lusai/Documents/openjdk
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1671142/202007/1671142-20200731234453228-351468471.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 执行配置命令,填写Boot jdk的安装目录&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;sudo&lt;/span&gt; bash configure --with-target-bits=&lt;span&gt;64&lt;/span&gt; --with-boot-jdk=/home/lusai/Documents/jdk1.&lt;span&gt;7&lt;/span&gt;.0_80/ --with-debug-level=slowdebug --enable-debug-symbols ZIP_DEBUGINFO_FILES=&lt;span&gt;0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果配置成功，则会显示如下信息：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1671142/202007/1671142-20200731234653739-1621788503.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt;开始编译(时间较长,请耐心等待)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;sudo&lt;/span&gt; &lt;span&gt;make&lt;/span&gt; all DISABLE_HOTSPOT_OS_VERSION_CHECK=OK ZIP_DEBUGINFO_FILES=&lt;span&gt;0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;看到下面这个画面就证明编译成功，就可以用了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1671142/202008/1671142-20200801001307056-918024657.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt;若在编译过程中，出现以下错误，请不要慌张，这并没有太大问题（网上是这么说的，最后确实也是没太大问题）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1671142/202008/1671142-20200801000105749-76278448.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt;查看刚才编译成功的openjdk版本。首先进入 以下目录，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
cd /home/lusai/Documents/openjdk/build/linux-x86_64-normal-server-slowdebug/jdk/bin
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再执行命令 ./java -version。可得如下结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
./java -version
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1671142/202008/1671142-20200801001434047-788666527.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 至此，Openjdk8编译大功告成&lt;/p&gt;
</description>
<pubDate>Fri, 31 Jul 2020 16:24:00 +0000</pubDate>
<dc:creator>路仁甲</dc:creator>
<og:description>现在很多语言都不开发运行环境了，都选择在JRE上运行，足以证明JVM的优越。你精通了JVM，未来的路才可能走得轻松。这篇文章是你走近jvm的第一篇,编译Openjdk8源码 编译环境 操作系统：Ubu</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lusaisai/p/13412478.html</dc:identifier>
</item>
</channel>
</rss>