<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>SQL Server解惑——为什么ORDER BY改变了变量的字符串拼接结果 - 潇湘隐者</title>
<link>http://www.cnblogs.com/kerrycode/p/14244499.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kerrycode/p/14244499.html</guid>
<description>&lt;p class=&quot;MsoNormal&quot; align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;&lt;span&gt;&lt;span&gt;在SQL Server中可能有这样的拼接字符串需求，需要将查询出来的一列拼接成字符串，如下案例所示，我们需要将AddressID &amp;lt;=10的AddressLine1拼接起来，分隔符为|。如下截图所示。这种方式看起来似乎没有什么问题，而且简单测试也是OK：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div id=&quot;codeSnippetWrapper&quot; readability=&quot;7.5&quot;&gt;
&lt;div id=&quot;codeSnippet&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;span&gt;USE&lt;/span&gt; AdventureWorks2014;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;GO&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;DECLARE&lt;/span&gt; @address_list NVARCHAR(&lt;span&gt;MAX&lt;/span&gt;);
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;SET&lt;/span&gt; @address_list =&lt;span&gt;''&lt;/span&gt;;
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; @address_list = @address_list + AddressLine1 + &lt;span&gt;'|'&lt;/span&gt; &lt;span&gt;FROM&lt;/span&gt; [Person].[Address] &lt;span&gt;WHERE&lt;/span&gt; AddressID &amp;lt;=10;
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; @address_list
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;a href=&quot;https://img2020.cnblogs.com/blog/73542/202101/73542-20210107084336604-605578147.png&quot;&gt;&lt;img title=&quot;clip_image001&quot; border=&quot;0&quot; alt=&quot;clip_image001&quot; src=&quot;https://img2020.cnblogs.com/blog/73542/202101/73542-20210107084337159-202268538.png&quot; width=&quot;765&quot; height=&quot;263&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;但是,如果SQL多了一个排序操作，结果就变了，这个SQL的变量&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt;@address_list&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;只获取到了最后一条记录&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;”&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;9833 Mt. Dias Blv.|&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;“&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div id=&quot;codeSnippetWrapper&quot; readability=&quot;7.5&quot;&gt;
&lt;div id=&quot;codeSnippet&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;span&gt;USE&lt;/span&gt; AdventureWorks2014;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;GO&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;DECLARE&lt;/span&gt; @address_list NVARCHAR(&lt;span&gt;MAX&lt;/span&gt;);
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;SET&lt;/span&gt; @address_list =&lt;span&gt;''&lt;/span&gt;;
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; @address_list = @address_list + AddressLine1 + &lt;span&gt;'|'&lt;/span&gt; &lt;span&gt;FROM&lt;/span&gt; [Person].[Address] &lt;span&gt;WHERE&lt;/span&gt; AddressID &amp;lt;=10 &lt;span&gt;ORDER&lt;/span&gt; &lt;span&gt;BY&lt;/span&gt; 1;
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; @address_list
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;a href=&quot;https://img2020.cnblogs.com/blog/73542/202101/73542-20210107084338621-408992928.png&quot;&gt;&lt;img title=&quot;clip_image002&quot; border=&quot;0&quot; alt=&quot;clip_image002&quot; src=&quot;https://img2020.cnblogs.com/blog/73542/202101/73542-20210107084339175-930402026.png&quot; width=&quot;652&quot; height=&quot;277&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;但是你使用其它一些字段排序的话，它又是OK的。在各种实际生产环境中，可能按某个字段排序，字符串拼接就不正常了。但是按有些字段排序又是正常的。有点搞不清套路。下面简单构造一个案例&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;div id=&quot;codeSnippetWrapper&quot; readability=&quot;18&quot;&gt;
&lt;div id=&quot;codeSnippet&quot; readability=&quot;31&quot;&gt;
&lt;pre&gt;
&lt;span&gt;USE&lt;/span&gt; AdventureWorks2014;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;GO&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt; TEST
&lt;/pre&gt;
&lt;pre&gt;
(
&lt;/pre&gt;
&lt;pre&gt;
    ID        &lt;span&gt;INT&lt;/span&gt; &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
   ,NAME    NVARCHAR(100) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; 
&lt;/pre&gt;
&lt;pre&gt;
   ,SortID  &lt;span&gt;INT&lt;/span&gt; &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
   ,&lt;span&gt;CONSTRAINT&lt;/span&gt; PK_TEST &lt;span&gt;PRIMARY&lt;/span&gt; &lt;span&gt;KEY&lt;/span&gt; (ID)
&lt;/pre&gt;
&lt;pre&gt;
);
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
INSERT &lt;span&gt;INTO&lt;/span&gt; dbo.TEST
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; 1, &lt;span&gt;'Kerry'&lt;/span&gt;  , 1 &lt;span&gt;UNION&lt;/span&gt; &lt;span&gt;ALL&lt;/span&gt; 
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; 2, &lt;span&gt;'Jerry'&lt;/span&gt;  , 2 &lt;span&gt;UNION&lt;/span&gt; &lt;span&gt;ALL&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; 3, &lt;span&gt;'Ken'&lt;/span&gt;    , 3 &lt;span&gt;UNION&lt;/span&gt; &lt;span&gt;ALL&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; 4, &lt;span&gt;'Richard'&lt;/span&gt;, 4 &lt;span&gt;UNION&lt;/span&gt; &lt;span&gt;ALL&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; 5, &lt;span&gt;'Jimmy'&lt;/span&gt;  , 5;
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;DECLARE&lt;/span&gt; @name_list NVARCHAR(100);
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;SET&lt;/span&gt; @name_list=&lt;span&gt;''&lt;/span&gt;;
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; @name_list = @name_list + t.NAME + &lt;span&gt;'|'&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;FROM&lt;/span&gt; dbo.TEST t
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;ORDER&lt;/span&gt; &lt;span&gt;BY&lt;/span&gt; t.SortID;
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; @name_list;
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;上面脚本测试都正常，下面测试就会出现连接字符串只获取了最后一行记录的情况。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div id=&quot;codeSnippetWrapper&quot; readability=&quot;7&quot;&gt;
&lt;div id=&quot;codeSnippet&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;span&gt;DECLARE&lt;/span&gt; @name_list NVARCHAR(100)=&lt;span&gt;''&lt;/span&gt;;
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;SET&lt;/span&gt; @name_list=&lt;span&gt;' '&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; @name_list = @name_list + t.NAME + &lt;span&gt;'| '&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;FROM&lt;/span&gt; dbo.TEST t
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;WHERE&lt;/span&gt; ID &lt;span&gt;IN&lt;/span&gt; (1,2,3)
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;ORDER&lt;/span&gt; &lt;span&gt;BY&lt;/span&gt; t.SortID;
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; @name_list;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;a href=&quot;https://img2020.cnblogs.com/blog/73542/202101/73542-20210107084339577-1846567052.png&quot;&gt;&lt;img title=&quot;clip_image003&quot; border=&quot;0&quot; alt=&quot;clip_image003&quot; src=&quot;https://img2020.cnblogs.com/blog/73542/202101/73542-20210107084339964-414882322.png&quot; width=&quot;651&quot; height=&quot;286&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;在生产环境还有各种魔幻的现象，按其中一个字段排序是正常，换另外一个字段排序就出现这种现象。如果你将上面测试表的字段的大小修改一下，然后测试下面脚本，发现又不会出现这种情况：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div id=&quot;codeSnippetWrapper&quot; readability=&quot;16&quot;&gt;
&lt;div id=&quot;codeSnippet&quot; readability=&quot;27&quot;&gt;
&lt;pre&gt;
&lt;span&gt;USE&lt;/span&gt; AdventureWorks2014;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;GO&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;DROP&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt; dbo.TEST;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;GO&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt; TEST
&lt;/pre&gt;
&lt;pre&gt;
(
&lt;/pre&gt;
&lt;pre&gt;
    ID         &lt;span&gt;INT&lt;/span&gt; &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
   ,NAME       NVARCHAR(32) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; 
&lt;/pre&gt;
&lt;pre&gt;
   ,SortID     &lt;span&gt;INT&lt;/span&gt; &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
   ,&lt;span&gt;CONSTRAINT&lt;/span&gt; PK_TEST &lt;span&gt;PRIMARY&lt;/span&gt; &lt;span&gt;KEY&lt;/span&gt; (ID)
&lt;/pre&gt;
&lt;pre&gt;
);
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
INSERT &lt;span&gt;INTO&lt;/span&gt; dbo.TEST
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; 1, &lt;span&gt;'Kerry'&lt;/span&gt;  , 1 &lt;span&gt;UNION&lt;/span&gt; &lt;span&gt;ALL&lt;/span&gt; 
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; 2, &lt;span&gt;'Jerry'&lt;/span&gt;  , 2 &lt;span&gt;UNION&lt;/span&gt; &lt;span&gt;ALL&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; 3, &lt;span&gt;'Ken'&lt;/span&gt;    , 3 &lt;span&gt;UNION&lt;/span&gt; &lt;span&gt;ALL&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; 4, &lt;span&gt;'Richard'&lt;/span&gt;, 4 &lt;span&gt;UNION&lt;/span&gt; &lt;span&gt;ALL&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; 5, &lt;span&gt;'Jimmy'&lt;/span&gt;  , 5;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;a href=&quot;https://img2020.cnblogs.com/blog/73542/202101/73542-20210107084340346-323882514.png&quot;&gt;&lt;img title=&quot;image&quot; border=&quot;0&quot; alt=&quot;image&quot; src=&quot;https://img2020.cnblogs.com/blog/73542/202101/73542-20210107084340726-951636873.png&quot; width=&quot;653&quot; height=&quot;332&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;初看像一个&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;“&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;Bug&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;”&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;，但是它确实不是一个Bug，官方文档&lt;u&gt;&lt;span&gt;&lt;span&gt;http://support.microsoft.com/kb/287515&lt;/span&gt;&lt;/span&gt;&lt;/u&gt;有介绍这个现象，但是目前现在这个链接失效了，搜索也找不到对应的链接了（微软的官方文档这一点是相当坑爹，不如Oracle做得好，经常一个链接失效，好的情况是链接换了，糟糕的情况就是这种，根本找不到了），下面的资料是在其它资料里面引用KB 287515的内容：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;事实证明，&lt;strong&gt;此迭代级联/迭代拼接（iterative concatenation）的功能是不受支持的功能。 Microsoft知识库文章287515指出&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;  &lt;/span&gt;&lt;/span&gt; &lt;span&gt;You may encounter unexpected results when you apply any operators or expressions to the ORDER BY clause of aggregate concatenation queries.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;  &lt;/span&gt;&lt;/span&gt; &lt;span&gt;we &lt;span&gt;do not make any guarantees on the correctness of concatenation queries&lt;/span&gt; (like using variable assignments with data retrieval in a specific order). The query output can change in SQL Server 2008 depending on the plan choice, data in the tables etc. You shouldn't rely on this working consistently even though the syntax allows you to write a SELECT statement that mixes ordered rows retrieval with variable assignment.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;  &lt;/span&gt;&lt;/span&gt; &lt;span&gt;The correct behavior for an aggregate concatenation query is undefined&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;      &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;&lt;span&gt;&lt;span&gt;简单来说，这样拼接字符串，虽然在语法上支持，但是却不能保证这样的结果正确性，聚合串联查询的行为是不确定的。如果想安全可靠的拼接字符串的话，有下面一些方式：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;1： 使用游标循环循环处理拼接字符串。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;2： 使用XML查询拼接字符串&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;方式1：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div id=&quot;codeSnippetWrapper&quot; readability=&quot;7.5&quot;&gt;
&lt;div id=&quot;codeSnippet&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;span&gt;DECLARE&lt;/span&gt; @name_list &lt;span&gt;VARCHAR&lt;/span&gt;(512);
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt;  @name_list=
&lt;/pre&gt;
&lt;pre&gt;
(
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt;  t.NAME + &lt;span&gt;'|'&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;FROM&lt;/span&gt; dbo.TEST t
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;WHERE&lt;/span&gt; ID &lt;span&gt;IN&lt;/span&gt; (1,2,3)
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;ORDER&lt;/span&gt; &lt;span&gt;BY&lt;/span&gt; t.SortID
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;FOR&lt;/span&gt; XML &lt;span&gt;PATH&lt;/span&gt;(&lt;span&gt;''&lt;/span&gt;), TYPE
&lt;/pre&gt;
&lt;pre&gt;
).&lt;span&gt;value&lt;/span&gt;(&lt;span&gt;'.'&lt;/span&gt;, &lt;span&gt;'varchar(max)'&lt;/span&gt;)
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; @name_list;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;方式2：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div id=&quot;codeSnippetWrapper&quot; readability=&quot;6&quot;&gt;
&lt;div id=&quot;codeSnippet&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; Name + &lt;span&gt;'|'&lt;/span&gt; &lt;span&gt;AS&lt;/span&gt; &lt;span&gt;'data()'&lt;/span&gt; 
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;FROM&lt;/span&gt; dbo.TEST 
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;WHERE&lt;/span&gt; ID &lt;span&gt;IN&lt;/span&gt; (1,2,3)
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;FOR&lt;/span&gt; XML &lt;span&gt;PATH&lt;/span&gt;(&lt;span&gt;''&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;方式3: 借助STUFF函数&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;注意，使用COALESCE有可能也是不行的。如果定义@name_list为 VARCHAR(512)或VARCHAR(MAX)则是OK的。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div id=&quot;codeSnippetWrapper&quot; readability=&quot;8&quot;&gt;
&lt;div id=&quot;codeSnippet&quot; readability=&quot;11&quot;&gt;
&lt;pre&gt;
&lt;span&gt;DECLARE&lt;/span&gt; @name_list &lt;span&gt;VARCHAR&lt;/span&gt;(100);
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; @name_list = &lt;span&gt;COALESCE&lt;/span&gt;(@name_list + &lt;span&gt;', '&lt;/span&gt;, &lt;span&gt;''&lt;/span&gt;) + Name 
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;FROM&lt;/span&gt; dbo.TEST
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;WHERE&lt;/span&gt; ID &lt;span&gt;IN&lt;/span&gt; (1,2,3)
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;ORDER&lt;/span&gt; &lt;span&gt;BY&lt;/span&gt; SortID
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; @name_list
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;a href=&quot;https://img2020.cnblogs.com/blog/73542/202101/73542-20210107084341121-2081691928.png&quot;&gt;&lt;img title=&quot;clip_image004&quot; border=&quot;0&quot; alt=&quot;clip_image004&quot; src=&quot;https://img2020.cnblogs.com/blog/73542/202101/73542-20210107084341490-1185736344.png&quot; width=&quot;652&quot; height=&quot;259&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;3： 使用CRL聚合拼接字符串。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;4： 如果SQL Server 2017使用STRING_AGG实现。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div id=&quot;codeSnippetWrapper&quot; readability=&quot;8.5&quot;&gt;
&lt;div id=&quot;codeSnippet&quot; readability=&quot;12&quot;&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt;  STRING_AGG(Name, &lt;span&gt;'|'&lt;/span&gt;) &lt;span&gt;AS&lt;/span&gt; Departments
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;FROM&lt;/span&gt; dbo.TEST
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;WHERE&lt;/span&gt; ID &lt;span&gt;IN&lt;/span&gt; (1,2,3)
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; SortID, STRING_AGG(Name, &lt;span&gt;'|'&lt;/span&gt;) &lt;span&gt;AS&lt;/span&gt; Departments
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;FROM&lt;/span&gt; dbo.TEST
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;WHERE&lt;/span&gt; ID &lt;span&gt;IN&lt;/span&gt; (1,2,3)
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;GROUP&lt;/span&gt; &lt;span&gt;BY&lt;/span&gt; SortID
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;ORDER&lt;/span&gt; &lt;span&gt;BY&lt;/span&gt; SortID;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;X-NONE&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;参考资料：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;u&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;https://stackoverflow.com/questions/5538187/why-sql-server-ignores-vaules-in-string-concatenation-when-order-by-clause-speci/5538210#5538210&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/u&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;u&gt;&lt;span&gt;&lt;a href=&quot;https://stackoverflow.com/questions/194852/how-to-concatenate-text-from-multiple-rows-into-a-single-text-string-in-sql-serv&quot;&gt;&lt;span&gt;&lt;span&gt;https://stackoverflow.com/questions/194852/how-to-concatenate-text-from-multiple-rows-into-a-single-text-string-in-sql-serv&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/u&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 07 Jan 2021 00:44:00 +0000</pubDate>
<dc:creator>潇湘隐者</dc:creator>
<og:description>在SQL Server中可能有这样的拼接字符串需求，需要将查询出来的一列拼接成字符串，如下案例所示，我们需要将AddressID &amp;lt;=10的AddressLine1拼接起来，分隔符为|。如下截图</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/kerrycode/p/14244499.html</dc:identifier>
</item>
<item>
<title>ASP.NET Core路由中间件[4]: EndpointRoutingMiddleware和EndpointMiddleware - Artech</title>
<link>http://www.cnblogs.com/artech/p/endpoint-middleware-04.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/artech/p/endpoint-middleware-04.html</guid>
<description>&lt;p&gt;针对终结点的路由是由EndpointRoutingMiddleware和EndpointMiddleware这两个中间件协同完成的。应用在启动之前会注册若干表示终结点的Endpoint对象（具体来说是包含路由模式的RouteEndpoint对象）。如下图所示，当应用接收到请求并创建HttpContext上下文之后，EndpointRoutingMiddleware中间件会根据请求的URL及其他相关信息从注册的终结点中选择匹配度最高的那个。之后被选择的终结点会以一个特性（Feature）的形式附加到当前HttpContext上下文中，EndpointMiddleware中间件最终提供这个终结点并用它来处理当前请求。[更多关于ASP.NET Core的文章请点&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-3.html&quot;&gt;这里&lt;/a&gt;]&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2020.cnblogs.com/blog/19327/202101/19327-20210107084403210-1532917576.png&quot;&gt;&lt;img width=&quot;318&quot; height=&quot;134&quot; title=&quot;15-13&quot; alt=&quot;15-13&quot; src=&quot;https://img2020.cnblogs.com/blog/19327/202101/19327-20210107084403497-332099360.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;目录&lt;br/&gt;一、IEndpointFeature&lt;br/&gt;二、EndpointRoutingMiddleware&lt;br/&gt;三、EndpointMiddleware&lt;br/&gt;四、注册终结点&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;EndpointRoutingMiddleware中间件选择的终结点会以特性的形式存放在当前HttpContext上下文中，这个用来封装终结点的特性通过IEndpointFeature接口表示。如下面的代码片段所示，IEndpointFeature接口通过唯一的属性Endpoint表示针对当前请求选择的终结点。我们可以调用HttpContext类型的GetEndpoint方法和SetEndpoint方法来获取与设置用来处理当前请求的终结点。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IEndpointFeature
{
    Endpoint Endpoint { &lt;/span&gt;&lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; EndpointHttpContextExtensions
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Endpoint GetEndpoint(&lt;span&gt;this&lt;/span&gt; HttpContext context)  =&amp;gt;context.Features.Get&amp;lt;IEndpointFeature&amp;gt;()?&lt;span&gt;.Endpoint;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; SetEndpoint(&lt;span&gt;this&lt;/span&gt;&lt;span&gt; HttpContext context, Endpoint endpoint)
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;  feature = context.Features.Get&amp;lt;IEndpointFeature&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (feature != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
        {
            feature.Endpoint &lt;/span&gt;=&lt;span&gt; endpoint;
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        {
            context.Features.Set&lt;/span&gt;&amp;lt;IEndpointFeature&amp;gt;(&lt;span&gt;new&lt;/span&gt; EndpointFeature { Endpoint =&lt;span&gt; endpoint });
        }       
    }
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; EndpointFeature : IEndpointFeature
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Endpoint Endpoint { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;EndpointRoutingMiddleware中间件利用一个Matcher对象选择出与当前HttpContext上下文相匹配的终结点，然后将选择的终结点以IEndpointFeature特性的形式附加到当前HttpContext上下文中。Matcher只是一个内部抽象类型，针对终结点的选择和设置实现在它的MatchAsync方法中。如果匹配的终结点被成功选择出来，MatchAsync方法还会提取出解析出来的路由参数，然后将它们逐个添加到表示当前请求的HttpRequest对象的RouteValues属性字典中。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;internal&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Matcher
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt;&lt;span&gt; Task MatchAsync(HttpContext httpContext);
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HttpRequest
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; RouteValueDictionary RouteValues { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; RouteValueDictionary : IDictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;object&lt;/span&gt;&amp;gt;, IReadOnlyDictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;object&lt;/span&gt;&amp;gt;&lt;span&gt;
{
  ...  
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;EndpointRoutingMiddleware中间件使用的Matcher由注册的MatcherFactory服务来提供。路由系统默认使用的Matcher类型为DfaMatcher，它采用一种被称为确定有限状态自动机（Deterministic Finite Automaton，DFA）的形式从候选终结点中找到与当前请求匹配度最高的那个。由于篇幅有限，具体的细节此处不再展开介绍。DfaMatcher最终会利用DfaMatcherFactory对象间接地创建出来，DfaMatcherFactory类型派生于抽象类MatcherFactory。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;internal&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MatcherFactory
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt;&lt;span&gt; Matcher CreateMatcher(EndpointDataSource dataSource);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对Matcher和MatcherFactory有了基本了解之后，我们将关注点转移到EndpointRoutingMiddleware中间件。如下所示的代码片段模拟了EndpointRoutingMiddleware中间件的实现逻辑。我们在构造函数中注入了用于提供注册终结点的IEndpointRouteBuilder对象和用来创建Matcher对象的MatcherFactory工厂。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;internal&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; EndpointRoutingMiddleware
{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; RequestDelegate _next;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; Task&amp;lt;Matcher&amp;gt;&lt;span&gt; _matcherAccessor;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; EndpointRoutingMiddleware(RequestDelegate next, IEndpointRouteBuilder builder, MatcherFactory factory)
    {
        _next &lt;/span&gt;=&lt;span&gt; next;
        _matcherAccessor &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Task&amp;lt;Matcher&amp;gt;&lt;span&gt;(CreateMatcher);

        Matcher CreateMatcher()
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; source = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CompositeEndpointDataSource(builder.DataSources);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; factory.CreateMatcher(source);
        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task InvokeAsync(HttpContext httpContext)
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; matcher = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; _matcherAccessor;
        &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; matcher.MatchAsync(httpContext);
        &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; _next(httpContext);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在实现的InvokeAsync方法中，我们只需要根据IEndpointRouteBuilder对象提供的终结点列表创建一个CompositeEndpointDataSource对象，并将其作为参数调用MatcherFactory工厂的CreateMatcher方法。该方法会返回一个Matcher对象，然后调用Matcher对象的MatchAsync方法选择出匹配的终结点，并以特性的方式附加到当前HttpContext上下文中。EndpointRoutingMiddleware中间件一般通过如下所示的UseRouting扩展方法进行注册。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; EndpointRoutingApplicationBuilderExtensions
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IApplicationBuilder UseRouting(&lt;span&gt;this&lt;/span&gt;&lt;span&gt; IApplicationBuilder builder);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;EndpointMiddleware中间件的职责特别明确，就是执行由EndpointRoutingMiddleware中间件附加到当前HttpContext上下文中的终结点。EndpointRoutingMiddleware中间件针对终结点的执行涉及如下所示的RouteOptions类型标识的配置选项。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RouteOptions
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; LowercaseUrls { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; LowercaseQueryStrings { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; AppendTrailingSlash { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IDictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, Type&amp;gt; ConstraintMap { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; SuppressCheckForUnhandledSecurityMetadata { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;配置选项RouteOptions的前三个属性与路由系统针对URL的生成有关。具体来说，LowercaseUrls属性和LowercaseQueryStrings属性决定是否会将生成的URL或者查询字符串转换成小写形式。AppendTrailingSlash属性则决定是否会为生成的URL添加后缀“/”。RouteOptions的ConstraintMap属性表示的字典与路由参数的内联约束有关，它提供了在路由模板中实现的约束字符串（如regex表示正则表达式约束）与对应约束类型（正则表达式约束类型为RegexRouteConstraint）之间的映射关系。&lt;/p&gt;
&lt;p&gt;真正与EndpointMiddleware中间件相关的是RouteOptions的SuppressCheckForUnhandledSecurityMetadata属性，它表示目标终结点利用添加的元数据设置了一些关于安全方面的要求（主要是授权和跨域资源共享方面的要求），但是目前的请求并未经过相应的中间件处理（通过请求是否具有要求的报头判断），在这种情况下是否还有必要继续执行目标终结点。如果这个属性设置为True，就意味着EndpointMiddleware中间件根本不会做这方面的检验。如下所示的代码片段模拟了EndpointMiddleware中间件对请求的处理逻辑。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;internal&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; EndpointMiddleware
{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; RequestDelegate _next;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; RouteOptions _options;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; EndpointMiddleware(RequestDelegate next, IOptions&amp;lt;RouteOptions&amp;gt;&lt;span&gt; optionsAccessor)
    {
        _next &lt;/span&gt;=&lt;span&gt; next;
        _options &lt;/span&gt;=&lt;span&gt; optionsAccessor.Value;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Task InvokeAsync(HttpContext httpContext)
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; endpoint =&lt;span&gt; httpContext.GetEndpoint();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;null&lt;/span&gt; !=&lt;span&gt; endpoint)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;_options.SuppressCheckForUnhandledSecurityMetadata)
            {
                CheckSecurity();
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; endpoint.RequestDelegate(httpContext);
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; _next(httpContext);
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; CheckSecurity();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们一般调用如下所示的UseEndpoints扩展方法来注册EndpointMiddleware中间件，该方法提供了一个类型为Action&amp;lt;IEndpointRouteBuilder&amp;gt;的参数。通过前面的介绍可知，EndpointRoutingMiddleware中间件会利用注入的IEndpointRouteBuilder对象来获取注册的表示终结点数据源的EndpointDataSource，所以可以通过这个方法为EndpointRoutingMiddleware中间件注册终结点数据源。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; EndpointRoutingApplicationBuilderExtensions
{    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IApplicationBuilder UseEndpoints(&lt;span&gt;this&lt;/span&gt; IApplicationBuilder builder, Action&amp;lt;IEndpointRouteBuilder&amp;gt;&lt;span&gt; configure);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;对于使用路由系统的应用程序来说，它的主要工作基本集中在针对EndpointDataSource的注册上。一般来说，当我们调用IApplicationBuilder接口的UseEndpoints扩展方法注册EndpointMiddleware中间件时，会利用提供的Action&amp;lt;IEndpointRouteBuilder&amp;gt;委托对象注册所需的EndpointDataSource对象。IEndpointRouteBuilder接口具有一系列的扩展方法，这些方法可以帮助我们注册所需的终结点。&lt;/p&gt;
&lt;p&gt;如下所示的Map方法会根据提供的作为路由模式和处理器的RoutePattern对象与RequestDelegate对象创建一个终结点，并以ModelEndpointDataSource的形式予以注册。如下所示的代码片段还揭示了一个细节：对于作为请求处理器的RequestDelegate委托对象来说，其对应方法上标注的所有特性会以元数据的形式添加到创建的终结点上。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; EndpointRouteBuilderExtensions
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IEndpointConventionBuilder Map(&lt;span&gt;this&lt;/span&gt;&lt;span&gt; IEndpointRouteBuilder endpoints, RoutePattern pattern, RequestDelegate requestDelegate)
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; builder = &lt;span&gt;new&lt;/span&gt; RouteEndpointBuilder(requestDelegate, pattern, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
        {
            DisplayName &lt;/span&gt;=&lt;span&gt; pattern.RawText
        };
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; attributes =&lt;span&gt; requestDelegate.Method.GetCustomAttributes();

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (attributes != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; attribute &lt;span&gt;in&lt;/span&gt;&lt;span&gt; attributes)
            {
                builder.Metadata.Add(attribute);
            }
        }
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; dataSource = endpoints.DataSources.OfType&amp;lt;ModelEndpointDataSource&amp;gt;().FirstOrDefault()?? &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ModelEndpointDataSource();
        endpoints.DataSources.Add(dataSource);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; dataSource.AddEndpointBuilder(builder);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;HTTP方法（Method）在RESTful API的设计中具有重要意义，几乎所有的终结点都会根据自身对资源的操作类型对请求采用HTTP方法做相应限制。如果需要为注册的终结点指定限定的HTTP方法，就可以调用如下所示的MapMethods方法。该方法会在Map方法的基础上为注册的终结点设置相应的显示名称，并针对指定的HTTP方法创建一个HttpMethodMetadata对象，然后作为元数据添加到注册的终结点上。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; EndpointRouteBuilderExtensions
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IEndpointConventionBuilder MapMethods(&lt;span&gt;this&lt;/span&gt; IEndpointRouteBuilder endpoints, &lt;span&gt;string&lt;/span&gt; pattern, IEnumerable&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt; httpMethods, RequestDelegate requestDelegate)
    {       
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; builder =&lt;span&gt; endpoints.Map(RoutePatternFactory.Parse(pattern), requestDelegate);
        builder.WithDisplayName($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{pattern} HTTP: {string.Join(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, httpMethods)}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        builder.WithMetadata(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpMethodMetadata(httpMethods));
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; builder;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;EndpointRoutingMiddleware中间件在为当前请求筛选匹配的终结点时，针对HTTP方法的选择策略是通过IHttpMethodMetadata接口表示的元数据指定的，HttpMethodMetadata类型正是对该接口的默认实现。如下面的代码片段所示，IHttpMethodMetadata接口除了具有一个表示可接受HTTP方法列表的HttpMethods属性，还有一个布尔类型的只读属性AcceptCorsPreflight，它表示是否接受针对跨域资源共享（Cross-Origin Resource Sharing，CORS）的预检（Preflight）请求。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IHttpMethodMetadata
{
    IReadOnlyList&lt;/span&gt;&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; HttpMethods { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; AcceptCorsPreflight { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;sealed&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HttpMethodMetadata : IHttpMethodMetadata
{        
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IReadOnlyList&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; HttpMethods { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; AcceptCorsPreflight { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }  

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; HttpMethodMetadata(IEnumerable&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; httpMethods): &lt;span&gt;this&lt;/span&gt;(httpMethods, acceptCorsPreflight: &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
    {}
   
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; HttpMethodMetadata(IEnumerable&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; httpMethods, &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; acceptCorsPreflight)
    {
        HttpMethods &lt;/span&gt;=&lt;span&gt; httpMethods.ToArray();
        AcceptCorsPreflight &lt;/span&gt;=&lt;span&gt; acceptCorsPreflight;
    }   
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;路由系统还为4种常用的HTTP方法（GET、POST、PUT和DELETE）定义了相应的方法。从如下所示的代码片段可以看出，它们最终调用的都是MapMethods方法。我们在本章开篇演示的实例中正是调用其中的MapGet方法来注册终结点的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; EndpointRouteBuilderExtensions
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IEndpointConventionBuilder MapGet(&lt;span&gt;this&lt;/span&gt; IEndpointRouteBuilder endpoints, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; pattern, RequestDelegate requestDelegate)
        &lt;/span&gt;=&amp;gt; MapMethods(endpoints, pattern, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;GET&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, requestDelegate);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IEndpointConventionBuilder MapPost(&lt;span&gt;this&lt;/span&gt; IEndpointRouteBuilder endpoints, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; pattern, RequestDelegate requestDelegate)
        &lt;/span&gt;=&amp;gt; MapMethods(endpoints, pattern, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;POST&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, requestDelegate);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IEndpointConventionBuilder MapPut(&lt;span&gt;this&lt;/span&gt; IEndpointRouteBuilder endpoints, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; pattern, RequestDelegate requestDelegate)
        &lt;/span&gt;=&amp;gt; MapMethods(endpoints, pattern, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;PUT&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, requestDelegate);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IEndpointConventionBuilder MapDelete(&lt;span&gt;this&lt;/span&gt; IEndpointRouteBuilder endpoints, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; pattern, RequestDelegate requestDelegate)
        &lt;/span&gt;=&amp;gt; MapMethods(endpoints, pattern, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DELETE&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, requestDelegate);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;调用IApplicationBuilder接口相应的扩展方法注册EndpointRoutingMiddleware中间件和EndpointMiddleware中间件时，必须确保它们依赖的服务已经被注册到依赖注入框架之中。针对路由服务的注册可以通过调用如下所示的AddRouting扩展方法重载来完成。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RoutingServiceCollectionExtensions
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IServiceCollection AddRouting(&lt;span&gt;this&lt;/span&gt;&lt;span&gt; IServiceCollection services);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IServiceCollection AddRouting(&lt;span&gt;this&lt;/span&gt; IServiceCollection services, Action&amp;lt;RouteOptions&amp;gt;&lt;span&gt; configureOptions);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/endpoint-middleware-01.html&quot;&gt;ASP.NET Core路由中间件[1]: 终结点与URL的映射&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/endpoint-middleware-02.html&quot;&gt;ASP.NET Core路由中间件[2]: 路由模式&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/endpoint-middleware-03.html&quot;&gt;ASP.NET Core路由中间件[3]: 终结点&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/endpoint-middleware-04.html&quot;&gt;ASP.NET Core路由中间件[4]: EndpointRoutingMiddleware和EndpointMiddleware&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/endpoint-middleware-05.html&quot;&gt;ASP.NET Core路由中间件[5]: 路由约束&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 07 Jan 2021 00:44:00 +0000</pubDate>
<dc:creator>Artech</dc:creator>
<og:description>目录 一、IEndpointFeature 二、EndpointRoutingMiddleware 三、EndpointMiddleware 四、注册终结点 一、IEndpointFeature 二、</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/artech/p/endpoint-middleware-04.html</dc:identifier>
</item>
<item>
<title>抄答案就是了，两套详细的设计方案，解决头疼的支付掉单问题 - 楼下小黑哥</title>
<link>http://www.cnblogs.com/goodAndyxublog/p/14244458.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/goodAndyxublog/p/14244458.html</guid>
<description>&lt;p&gt;Hello，大家好，我是楼下小黑哥~&lt;/p&gt;
&lt;p&gt;好久没写支付相关的文章了，今天继续从事老本行~&lt;/p&gt;
&lt;p&gt;上次在文章&lt;a href=&quot;https://studyidea.cn/drop-order.html&quot; target=&quot;_blank&quot;&gt;钱被扣走了，但是订单却未成功！支付掉单异常最全解决方案&lt;/a&gt;提到，支付过程会出现&lt;strong&gt;掉单、卡单&lt;/strong&gt;的情况，这种情况对于用户来讲，体验非常差，明明自己付了钱，扣了款，但是订单却未成功。&lt;/p&gt;
&lt;p&gt;上篇文章我们简单说了下解决方案，这次小黑哥就结合生产实际碰到的情况，给出两种详细设计的方案：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;定时轮询补偿方案&lt;/li&gt;
&lt;li&gt;延迟消息补偿方案&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;大家可以根据自己系统的实际情况，选择性参考。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当然了，以下设计方案可能并不完美，如果各位读者还有其他解决方案，欢迎留言指出，一起讨论，一起成长~&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5.5555555555556&quot;&gt;
&lt;p&gt;欢迎关注我的公众号：小黑十一点半，获得日常干货推送。如果您对我的专题内容感兴趣，也可以关注我的博客：&lt;a href=&quot;https://studyidea.cn&quot; target=&quot;_blank&quot;&gt;studyidea.cn&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;定时轮询补偿方案&quot;&gt;定时轮询补偿方案&lt;/h2&gt;
&lt;h3 id=&quot;整体流程&quot;&gt;整体流程&lt;/h3&gt;
&lt;p&gt;这个方案主要采用定时任务，批量查询掉单记录，从而驱动查询具体支付支付结果，然后更新内部订单。&lt;/p&gt;
&lt;p&gt;整体方案流程图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202101/1419561-20210107083620714-1094767745.jpg&quot; alt=&quot;定时任务补偿&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;前三步流程没什么好说的，正常的支付流程，咱们针对后面几步具体详细说下。&lt;/p&gt;
&lt;p&gt;第三步调用支付通道之后，如果支付通道端返回&lt;strong&gt;支付受理成功或者支付处理中&lt;/strong&gt;，我们就需要调用第四步，将这类订单插入掉单表。&lt;/p&gt;
&lt;p&gt;如果支付直接成功了，那就正常流程返回即可。&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;复习一下，网关类支付，比如支付宝、微信支付、网银支付，这种支付模式，支付通道仅仅返回支付受理成功，具体支付结果需要接收支付通道端的支付通知，这类支付我们将其称为异步支付。&lt;/p&gt;
&lt;p&gt;相应的还有同步支付，比如银行卡支付，微信、支付宝代扣类支付，这类支付，同步就能返回支付结果。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;第五步，补单应用将会定时查询数据库，批量查询掉单记录。&lt;/p&gt;
&lt;p&gt;第六步，补单应用使用线程池，多线程异步的方式发起掉单查询。&lt;/p&gt;
&lt;p&gt;第七步，调用支付通道支付查询接口。&lt;/p&gt;
&lt;p&gt;重点来了，如果第七步支付结果查询为以下状态：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;支付结果为扣款成功&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;支付结果为明确失败&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;掉单记录查询达到最大次数&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;第八步就会删除掉单记录。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最后，如果掉单查询依旧还是处理中，那么经过一定的延时之后，重复第五步，再次重新掉单补偿，直到成功或者查询到达最大次数。&lt;/p&gt;
&lt;h3 id=&quot;相关问题&quot;&gt;相关问题&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;为什么需要新建一张掉单表？不能直接使用支付订单表，查询未成功的订单吗?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个问题，实际上确实可以直接使用的支付订单表，然后批量查询当天未成功的订单，补单程序发起支付查询。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;那为什么需要新建一张掉单表？&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;主要是因为数据库查询效率问题，因为支付订单表每天都会大量记录新增，随着时间，这张表记录将会越来越多，越来越大。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;支付记录越多，批量范围查询效率就会变低，查询速度将会变慢。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所以为了查询效率，新建一张掉单表。&lt;/p&gt;
&lt;p&gt;这张表里仅记录支付未成功的订单，所以数据量就会很小，那么查询效率就会很高。&lt;/p&gt;
&lt;p&gt;另外，掉单表里的记录，不会被永久保存，只是临时性。当支付结果查询成功，或者支付结果明确失败，再或者查询次数到达规定最大次数，就会删除掉单记录。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这就是第八步为什么需要删除掉单表的原因。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果需要保存每次掉单表查询详情，那么这里建议再新增一张掉单查询记录表，保存每一次的查询记录。&lt;/p&gt;
&lt;p&gt;针对这个方案，如果还有其他问题，欢迎留言。&lt;/p&gt;
&lt;h3 id=&quot;方案优缺点&quot;&gt;方案优缺点&lt;/h3&gt;
&lt;p&gt;定时轮询补偿方案，最大的优点可能就是系统架构方案比较简单，比较容易实施。&lt;/p&gt;
&lt;p&gt;那么这个方案的缺点主要在于&lt;strong&gt;定时任务&lt;/strong&gt;上。&lt;/p&gt;
&lt;p&gt;定时任务轮询方案天然会存在以下不足：&lt;/p&gt;
&lt;ol readability=&quot;1.5&quot;&gt;&lt;li&gt;
&lt;p&gt;&lt;strong&gt;轮询效率稍低&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;每次查询数据库，已经被执行过记录，仍然会被扫描（补单程序将会根据一定策略决定是否发起支付通道查询），有&lt;strong&gt;重复计算&lt;/strong&gt;的嫌疑&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;时效性不够好&lt;/strong&gt;，如果每小时轮询一次，最差的情况下，时间误差会达到1小时&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如果为了解决时效性问题，增加定时任务查询效率，那么 1 中查询效率跟 2 的重复计算问题将会更加明显。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;延迟消息补偿方案&quot;&gt;延迟消息补偿方案&lt;/h2&gt;
&lt;p&gt;下面介绍另外一种掉单补偿方案，延迟消息补偿方案，这个方案整体流程与定时任务方案类似，最大区别可能在于，从一种&lt;strong&gt;拉模式&lt;/strong&gt;变成一种&lt;strong&gt;推模式&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;整体方案流程图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202101/1419561-20210107083620916-1904350166.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个方案主要流程跟定时方案类似，主要区别在于第四步，第五步，第八步。&lt;/p&gt;
&lt;p&gt;第四步的流程从插入掉单表变更为往&lt;strong&gt;延迟队列发送掉单消息&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;第五步，补单程序接收掉单消息，然后触发支付掉单查询。&lt;/p&gt;
&lt;p&gt;第八步，如果第七步支付结果查询为以下状态：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;支付结果为扣款成功&lt;/li&gt;
&lt;li&gt;支付结果为明确失败&lt;/li&gt;
&lt;li&gt;掉单记录查询达到最大次数&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;补单程序将会告知延迟队列消费成功，延迟队列将会删除这条掉单消息。&lt;/p&gt;
&lt;p&gt;其他状态将会告知消费失效，延迟队列将会在一定延时之后，再次发送掉单消息，然后继续重复第五步。&lt;/p&gt;
&lt;h3 id=&quot;延迟队列&quot;&gt;延迟队列&lt;/h3&gt;
&lt;p&gt;这里的延迟队列需要自己实现，复杂度还是比较高的，这里给大家推荐几种实现方案：&lt;/p&gt;
&lt;p&gt;第一种，基于 &lt;strong&gt;Redis SortedSet&lt;/strong&gt; 实现延迟队列。可以参考一下有赞的实现方案&lt;a href=&quot;https://tech.youzan.com/queuing_delay/&quot; target=&quot;_blank&quot;&gt;https://tech.youzan.com/queuing_delay/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;第二种，基于时间轮算法(&lt;strong&gt;TimingWheel&lt;/strong&gt;)实现延迟队列，具体可以参考 Kafka 延时队列。&lt;/p&gt;
&lt;p&gt;第三种，基于 &lt;strong&gt;RocketMQ&lt;/strong&gt; 延迟消息。&lt;/p&gt;
&lt;p&gt;前两种方案说起来还需要再开发，所以还是比较复杂的。&lt;/p&gt;
&lt;p&gt;这里重点说下第三种方案，该方案是 &lt;strong&gt;RocketMQ&lt;/strong&gt; 已经支持的特性，开箱即用，使用起来还是比较简单的。&lt;/p&gt;
&lt;p&gt;RocketMQ 延迟消息支持 18 个等级，分别如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;消息发送方可以通过以下方式指定延迟等级，对应上方的延迟时间。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Message#setDelayTimeLevel
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;消息消费方，如果消费失败，默认将会在消息发送方的的延迟等级基础上加 1。如果消息消费方需要指定其他的延迟等级，可以使用如下方式：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;ConsumeConcurrentlyContext#setDelayLevelWhenNextConsume
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;RocketMQ 延迟消息，支持的特性还是比较基础、简单，不支持自定义延迟时间。不过对于掉单补偿的这个场景刚好够用，但是如果需要自定义延迟的，那还是得采用其他的方案。&lt;/p&gt;
&lt;h3 id=&quot;方案优缺点-1&quot;&gt;方案优缺点&lt;/h3&gt;
&lt;p&gt;延迟消息的方案相对于定时轮询方案来讲：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;无需再查询全部订单，效率高&lt;/li&gt;
&lt;li&gt;时效性较好&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;不过延迟消息这种方案，需要基于&lt;strong&gt;延迟队列&lt;/strong&gt;，实现起来比较复杂，目前开源实现也比较少。&lt;/p&gt;
&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;支付掉单、卡单是支付过程中经常会碰到的事，我们可以采用异步补偿的方案，解决该问题。&lt;/p&gt;
&lt;p&gt;异步补偿方案可以采用如下两种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;定时轮询补偿方案&lt;/li&gt;
&lt;li&gt;延迟消息补偿方案&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;定时轮询补偿方案实现起来比较简单，但是时效性稍差。&lt;/p&gt;
&lt;p&gt;而延迟消息补偿方案总体来说比较优秀，但是实现起来比较复杂。如果没有自定义的延迟时间的需求，可以直接采用 RocketMQ 延迟消息，简单快捷。&lt;/p&gt;
&lt;p&gt;另外&lt;strong&gt;延迟队列&lt;/strong&gt;使用场景还是比较多，不仅仅能用在掉单补偿上，还可以用于支付关单等场景。所以有能力开发的团队，可以开发一个通用的延迟队列、&lt;/p&gt;
&lt;p&gt;好了，今天的文章就到这里了。&lt;/p&gt;
&lt;p&gt;我是楼下小黑哥，下篇文章再见，886~&lt;/p&gt;
&lt;blockquote readability=&quot;5.5555555555556&quot;&gt;
&lt;p&gt;欢迎关注我的公众号：小黑十一点半，获得日常干货推送。如果您对我的专题内容感兴趣，也可以关注我的博客：&lt;a href=&quot;https://studyidea.cn&quot; target=&quot;_blank&quot;&gt;studyidea.cn&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;历史支付文章推荐&quot;&gt;历史支付文章推荐&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://studyidea.cn/drop-order.html&quot; target=&quot;_blank&quot;&gt;钱被扣走了，但是订单却未成功！支付掉单异常最全解决方案&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://studyidea.cn/repeat-pay-error&quot; target=&quot;_blank&quot;&gt;一笔订单，但是误付了两笔钱！这种重复付款异常到底该如何解决？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://studyidea.cn/more-pay&quot; target=&quot;_blank&quot;&gt;收款神器！解读聚合收款码背后的原理|原创&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://studyidea.cn/offline-pay&quot; target=&quot;_blank&quot;&gt;手机没网了，却还能支付，这是什么原理？|原创&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://studyidea.cn/barcodepay&quot; target=&quot;_blank&quot;&gt;轻轻一扫，立刻扣款，付款码背后的原理你不想知道吗？|原创&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://studyidea.cn/articles/2019/08/26/1566790579930.html&quot; target=&quot;_blank&quot;&gt;支付渠道路由系统进化史&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://studyidea.cn/articles/2019/08/26/1566790305561.html&quot; target=&quot;_blank&quot;&gt;从零开始设计对账系统&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://studyidea.cn/alipay_wechatpay&quot; target=&quot;_blank&quot;&gt;微信支付宝接入大全&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://studyidea.cn/pay-route&quot; target=&quot;_blank&quot;&gt;多支付通道路由网关设计&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://studyidea.cn/onlinepay-bankCard&quot; target=&quot;_blank&quot;&gt;银行卡支付，背后到底发生了什么？&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;5.5555555555556&quot;&gt;
&lt;p&gt;欢迎关注我的公众号：小黑十一点半，获得日常干货推送。如果您对我的专题内容感兴趣，也可以关注我的博客：&lt;a href=&quot;https://studyidea.cn&quot; target=&quot;_blank&quot;&gt;studyidea.cn&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Thu, 07 Jan 2021 00:36:00 +0000</pubDate>
<dc:creator>楼下小黑哥</dc:creator>
<og:description>Hello，大家好，我是楼下小黑哥~ 好久没写支付相关的文章了，今天继续从事老本行~ 上次在文章钱被扣走了，但是订单却未成功！支付掉单异常最全解决方案提到，支付过程会出现掉单、卡单的情况，这种情况对于</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/goodAndyxublog/p/14244458.html</dc:identifier>
</item>
<item>
<title>轻量级 Kubernetes K3s - Github热点 - SpringLeee</title>
<link>http://www.cnblogs.com/myshowtime/p/14244399.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/myshowtime/p/14244399.html</guid>
<description>&lt;h3 id=&quot;轻量级-kubernetes-k3s&quot;&gt;轻量级 Kubernetes k3s&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;star: 15.5k&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;K3s是完全符合生产要求的Kubernetes发行版, 安装简单，可用于生产，整个二进制文件小于100M，作为单一文件打包部署，优势在于，你只需几秒钟就可以得到一个完全成熟的Kubernetes集群。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blog-1259586045.cos.ap-shanghai.myqcloud.com/clipboard_20210106_075853.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blog-1259586045.cos.ap-shanghai.myqcloud.com/clipboard_20210106_075338.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/k3s-io/k3s&quot; title=&quot;https://github.com/k3s-io/k3s&quot; target=&quot;_blank&quot;&gt;https://github.com/k3s-io/k3s&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;英语学习-bluesea&quot;&gt;英语学习 BlueSea&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;star: 543&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;BlueSea，是一个有趣的英语学习扩展程序,以插件扩展的形式安装到浏览器，她支持划词翻译、单词高亮、单词弹幕、记忆曲线复习、词频统计...&lt;/p&gt;
&lt;p&gt;作为开发者，虽然日常总是与英语打交道，但通常是带有强烈目的性的。&lt;/p&gt;
&lt;p&gt;因此，在解决技术问题或学习新技能的过程里，遭遇模陌生的单词时，往往直接借助翻译软件，一掠而过。不做记忆，同一个生词下次再相遇依旧不认识。&lt;/p&gt;
&lt;p&gt;BlueSea，就是用来解决这个问题的，她会帮你记下在日常工作、生活中遭遇的生词，并设计一套科学的复习方案，有趣的复习方式来帮助你记住更多的单词。当然，不仅仅是背单词，她能做更多&lt;/p&gt;
&lt;p&gt;在页面上遇到生词，进行划词翻译、发音&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blog-1259586045.cos.ap-shanghai.myqcloud.com/query_word.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;将生词加入单词本，并根据遗忘曲线，生成复习计划。在复习期间内的单词，将在页面内被高亮展示，鼠标移入可以查看信息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blog-1259586045.cos.ap-shanghai.myqcloud.com/dancigaoliang.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;单词到复习时间，自动创建单词弹幕在页面内出现，选择认识或不认识，动态调整复习计划。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blog-1259586045.cos.ap-shanghai.myqcloud.com/dancidanmu.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;dockercraft&quot;&gt;Dockercraft&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;star: 6.0k&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;欢迎来到我的世界， Docker + Minecraft = Dockercraft, 在《我的世界》中操作 Docker，一个简单的Minecraft Docker客户端，用于可视化和管理Docker容器, 还能这么玩 ？？？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blog-1259586045.cos.ap-shanghai.myqcloud.com/clipboard_20210106_081921.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blog-1259586045.cos.ap-shanghai.myqcloud.com/clipboard_20210106_082052.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/docker/dockercraft&quot; title=&quot;https://github.com/docker/dockercraft&quot; target=&quot;_blank&quot;&gt;https://github.com/docker/dockercraft&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;快速开发-quasar-sika-design&quot;&gt;快速开发 quasar-sika-design&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;star: 33&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;基于 Quasar 开发，针对与企业应用开箱即用的 Vue 模板库，响应式布局，支持PC和手机&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blog-1259586045.cos.ap-shanghai.myqcloud.com/clipboard_20210106_072435.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;抢茅台-jd_seckill&quot;&gt;抢茅台 Jd_Seckill&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;star: 444&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;继python版本的京东抢茅台后，这个是go版本的京东抢茅台神器，jd_seckill ，支持跨平台&lt;/p&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/ztino/jd_seckill&quot; title=&quot;https://github.com/ztino/jd_seckill&quot; target=&quot;_blank&quot;&gt;https://github.com/ztino/jd_seckill&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;阿里巴巴-cola&quot;&gt;阿里巴巴 COLA&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;star: 3.8k&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;COLA 是 Clean Object-Oriented and Layered Architecture的缩写，代表“整洁面向对象分层架构”。目前COLA已经发展到COLA 4.0。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blog-1259586045.cos.ap-shanghai.myqcloud.com/clipboard_20210106_070437.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;图像识别处理-faceai&quot;&gt;图像识别处理 faceai&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;star: 7.8k&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;faceai 一款入门级的人脸、视频、文字检测以及识别的项目，使用Python开发， 目前支持的功能如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;人脸检测、识别（图片、视频）&lt;/li&gt;
&lt;li&gt;轮廓标识&lt;/li&gt;
&lt;li&gt;头像合成（给人戴帽子）&lt;/li&gt;
&lt;li&gt;数字化妆（画口红、眉毛、眼睛等）&lt;/li&gt;
&lt;li&gt;性别识别&lt;/li&gt;
&lt;li&gt;表情识别（生气、厌恶、恐惧、开心、难过、惊喜、平静等七种情绪）&lt;/li&gt;
&lt;li&gt;视频对象提取&lt;/li&gt;
&lt;li&gt;图片修复（可用于水印去除）&lt;/li&gt;
&lt;li&gt;图片自动上色&lt;/li&gt;
&lt;li&gt;眼动追踪（待完善）&lt;/li&gt;
&lt;li&gt;换脸（待完善）&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/vipstone/faceai&quot; title=&quot;https://github.com/vipstone/faceai&quot; target=&quot;_blank&quot;&gt;https://github.com/vipstone/faceai&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;最后&quot;&gt;最后&lt;/h3&gt;
&lt;p&gt;欢迎扫码关注我们的公众号，专注国外优秀博客的翻译和开源项目分享，也可以添加QQ群 897216102&lt;/p&gt;
&lt;img src=&quot;https://blog-1259586045.cos.ap-shanghai.myqcloud.com/wechat-logo2.png&quot;/&gt;</description>
<pubDate>Thu, 07 Jan 2021 00:05:00 +0000</pubDate>
<dc:creator>SpringLeee</dc:creator>
<og:description>轻量级 Kubernetes k3s star: 15.5k K3s是完全符合生产要求的Kubernetes发行版, 安装简单，可用于生产，整个二进制文件小于100M，作为单一文件打包部署，优势在于，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/myshowtime/p/14244399.html</dc:identifier>
</item>
<item>
<title>Kubernetes官方java客户端之五：proto基本操作 - 程序员欣宸</title>
<link>http://www.cnblogs.com/bolingcavalry/p/14244388.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bolingcavalry/p/14244388.html</guid>
<description>&lt;h3 id=&quot;欢迎访问我的github&quot;&gt;欢迎访问我的GitHub&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot; target=&quot;_blank&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;内容：所有原创文章分类汇总及配套源码，涉及Java、Docker、Kubernetes、DevOPS等；&lt;/p&gt;
&lt;h3 id=&quot;概览&quot;&gt;概览&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;本文是《Kubernetes官方java客户端》系列的第五篇，以下提到的&lt;span&gt;java客户端&lt;/span&gt;都是指&lt;span&gt;client-jar.jar&lt;/span&gt;；&lt;/li&gt;
&lt;li&gt;经过前面四篇文章的准备和尝试，我们对java客户端有了初步了解，也成功运行了hello world，接下来要做的是继续深入学习和实践，掌握这门利器；&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;两个主要脉络&quot;&gt;两个主要脉络&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;java客户端的基本功能并不复杂，就是以何种手段发起对K8S资源的增删改查请求，把握以下两个主脉络即可：&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;&lt;span&gt;proto主线&lt;/span&gt;：用K8S官方的protobuf定义将各种资源生成java类，用少量API处理这些对象(特点，API极少，每个API都通用，处理所有类型的资源对象)；&lt;/li&gt;
&lt;li&gt;&lt;span&gt;openapi主线&lt;/span&gt;：使用openapi工具，将所有资源都自动生成增删改查的API(特点：API极多，每个资源都有自身的API)；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;今天的文章咱们来学习和了解&lt;span&gt;proto主线&lt;/span&gt;；&lt;/p&gt;
&lt;h3 id=&quot;proto主线的核心类protoclient&quot;&gt;proto主线的核心类ProtoClient&lt;/h3&gt;
&lt;ol readability=&quot;15.771312584574&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;前面曾提到proto主线的特点是API极少，咱们来看看这些少量的API的源头：&lt;span&gt;ProtoClient类&lt;/span&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210107075101286-2147165189.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如上图所示，ProtoClient提供了增删改查接口，我们可以用这些接口实现对K8S资源的操作；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;有了接口，接下来要搞清楚参数怎么准备，先看create方法的源码，看它需要什么样的参数：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210107075102359-560273858.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如上图所示，create方法的第一个参数就是&lt;span&gt;K8S资源类&lt;/span&gt;，该类的特性是在泛型中约束的，必须实现&lt;span&gt;com.google.protobuf.Message&lt;/span&gt;的子接口；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;这些入参Message的子类从哪里来呢？例如我们要创建一个NameSpace的时候，是自己写一个Message子类？还是说哪里有现成的？接下来要做的就是搞清楚K8S资源类来自哪里？毕竟所有K8S资源的操作都要用上这些java类；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0.76209677419355&quot;&gt;
&lt;p&gt;一起去&lt;span&gt;java客户端&lt;/span&gt;的源码寻找线索，这是父子结构的maven工程，在名为&lt;span&gt;client-java-proto&lt;/span&gt;的子工程中，它的README文件给出了线索，地址是：&lt;a href=&quot;https://github.com/kubernetes-client/java/tree/master/proto&quot; target=&quot;_blank&quot;&gt;https://github.com/kubernetes-client/java/tree/master/proto&lt;/a&gt; ，如下图：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210107075102803-153499015.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;上图红框中的操作向我们揭示了整个过程：先去下载另一个github仓库，然后此仓库里有脚本generate.sh，该脚本根据protobuf配置生成java类，这些java文件被放置在&lt;span&gt;java/proto/src/main/java&lt;/span&gt;目录下；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1.5403726708075&quot;&gt;
&lt;p&gt;本文是学习K8S官方java客户端的文章，有关K8S的protobuf详情不在这里展开，只给出一段关键脚本供您参考，这是根据proto自动生成代码时执行的脚本，用于下载protobuf文件，地址：&lt;a href=&quot;https://github.com/kubernetes-client/gen/blob/master/proto/dependencies.sh&quot; target=&quot;_blank&quot;&gt;https://github.com/kubernetes-client/gen/blob/master/proto/dependencies.sh&lt;/a&gt; ，如下图：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210107075103212-1916829817.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0.57&quot;&gt;
&lt;p&gt;上图红框中的地址是：&lt;a href=&quot;https://raw.githubusercontent.com/kubernetes//api/master/rbac/v1alpha1/generated.proto&quot; target=&quot;_blank&quot;&gt;https://raw.githubusercontent.com/kubernetes//api/master/rbac/v1alpha1/generated.proto&lt;/a&gt; ，内容如下，java客户端中的java代码就是根据这些内容生成的：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210107075103686-251290933.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;结合前面的分析，再回到java客户端源码的子工程&lt;span&gt;client-java-proto&lt;/span&gt;，可以找到generate.sh脚本生成的V1.java，这个java文件里面有V1版本的所有protobuf对象，如下图：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210107075104139-181139688.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;上图红框中&lt;span&gt;Namespace&lt;/span&gt;类是GeneratedMessageV3的子类，来看下GeneratedMessageV3的继承关系，如下图，该类实现了Message接口，满足ProtoClient.create方法对入参的泛型约束：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210107075104516-1904284586.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;小结&quot;&gt;小结&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;ProtoClient类提供的操作K8S资源的增删改查方法；&lt;/li&gt;
&lt;li&gt;java客户端的client-java-proto子工程内，有通过K8S官方protobuf生成的对象类，这些类就是ProtoClient的增删查用到的参数；&lt;/li&gt;
&lt;li&gt;增删改查方法有了，涉及的对象也有了，接下来可以实战了；&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;实战前的准备&quot;&gt;实战前的准备&lt;/h3&gt;
&lt;p&gt;现在还不能马上写代码，还差最后一个准备步骤：&lt;span&gt;确认API参数&lt;/span&gt;；&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;假设实战的内容是查询kube-system这个namespace下面的所有pod列表，那么API相关信息在哪获取：&lt;/li&gt;
&lt;/ul&gt;&lt;ol readability=&quot;2.00625&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;打开API在线文档，我这里K8S版本是1.15，地址是：&lt;a href=&quot;https://v1-15.docs.kubernetes.io/docs/reference/generated/kubernetes-api/v1.15/&quot; target=&quot;_blank&quot;&gt;https://v1-15.docs.kubernetes.io/docs/reference/generated/kubernetes-api/v1.15/&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如下图，红框1是pod列表的接口文档，红框2显示了该URL，有了这个URL我们可以编码了：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210107075104881-1000858394.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;在今后的操作中，所有资源都可以根据该文档找到对应的API信息，辅助我们编码；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;终于，可以开始实战了；&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;源码下载&quot;&gt;源码下载&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;如果您不想编码，可以在GitHub下载所有源码，地址和链接信息如下表所示(&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot; target=&quot;_blank&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;)：&lt;/li&gt;
&lt;/ol&gt;&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;这个git项目中有多个文件夹，本章的应用在&lt;span&gt;kubernetesclient&lt;/span&gt;文件夹下，如下图红框所示：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210107075105136-491374194.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;开始编码&quot;&gt;开始编码&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;打开&lt;a href=&quot;https://blog.csdn.net/boling_cavalry/article/details/107480015&quot; target=&quot;_blank&quot;&gt;《Kubernetes官方java客户端之一：准备 》&lt;/a&gt;中创建的kubernetesclient工程，在里面新建子工程&lt;span&gt;protobufclient&lt;/span&gt;，其pom.xml内容如下，要注意的是spring-boot-starter-json已经被排除，因此序列化工具会变为Gson(原本默认是jackson)：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;

    &amp;lt;parent&amp;gt;
        &amp;lt;groupId&amp;gt;com.bolingcavalry&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;kubernetesclient&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;
        &amp;lt;relativePath&amp;gt;../pom.xml&amp;lt;/relativePath&amp;gt;
    &amp;lt;/parent&amp;gt;

    &amp;lt;groupId&amp;gt;com.bolingcavalry&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;protobufclient&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt;
    &amp;lt;name&amp;gt;protobufclient&amp;lt;/name&amp;gt;
    &amp;lt;description&amp;gt;Demo project for protobuf client&amp;lt;/description&amp;gt;
    &amp;lt;packaging&amp;gt;jar&amp;lt;/packaging&amp;gt;

    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
            &amp;lt;exclusions&amp;gt;
                &amp;lt;exclusion&amp;gt;
                    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
                    &amp;lt;artifactId&amp;gt;spring-boot-starter-json&amp;lt;/artifactId&amp;gt;
                &amp;lt;/exclusion&amp;gt;
            &amp;lt;/exclusions&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.projectlombok&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;lombok&amp;lt;/artifactId&amp;gt;
            &amp;lt;optional&amp;gt;true&amp;lt;/optional&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;io.kubernetes&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;client-java&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;

    &amp;lt;/dependencies&amp;gt;

    &amp;lt;build&amp;gt;
        &amp;lt;plugins&amp;gt;
            &amp;lt;plugin&amp;gt;
                &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;2.3.0.RELEASE&amp;lt;/version&amp;gt;
            &amp;lt;/plugin&amp;gt;
        &amp;lt;/plugins&amp;gt;
    &amp;lt;/build&amp;gt;

&amp;lt;/project&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;新增&lt;span&gt;ProtobufApplication.java&lt;/span&gt;，这是新工程的引导类，也有通过ProtoClient查询pod列表的代码：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.bolingcavalry.protobufclient;

import com.google.gson.GsonBuilder;
import io.kubernetes.client.ProtoClient;
import io.kubernetes.client.ProtoClient.ObjectOrStatus;
import io.kubernetes.client.openapi.ApiClient;
import io.kubernetes.client.proto.Meta;
import io.kubernetes.client.proto.V1.Namespace;
import io.kubernetes.client.proto.V1.PodList;
import io.kubernetes.client.util.ClientBuilder;
import io.kubernetes.client.util.KubeConfig;
import lombok.extern.slf4j.Slf4j;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RestController;
import java.io.FileReader;

@SpringBootApplication
@RestController
@Slf4j
public class ProtobufApplication {

    public static void main(String[] args) {
        SpringApplication.run(ProtobufApplication.class, args);
    }

    /**
     * 根据配置文件创建ProtoClient实例
     * @return
     * @throws Exception
     */
    private ProtoClient buildProtoClient() throws Exception {
        // 存放K8S的config文件的全路径
        String kubeConfigPath = &quot;/Users/zhaoqin/temp/202007/05/config&quot;;
        // 以config作为入参创建的client对象，可以访问到K8S的API Server
        ApiClient client = ClientBuilder
                .kubeconfig(KubeConfig.loadKubeConfig(new FileReader(kubeConfigPath)))
                .build();

        // 创建操作类
        return new ProtoClient(client);
    }

    @RequestMapping(value = &quot;/createnamespace/{namespace}&quot;, method = RequestMethod.GET)
    public ObjectOrStatus&amp;lt;Namespace&amp;gt; createnamespace(@PathVariable(&quot;namespace&quot;) String namespace) throws Exception {
        // 创建namespace资源对象
        Namespace namespaceObj =
                Namespace.newBuilder().setMetadata(Meta.ObjectMeta.newBuilder().setName(namespace).build()).build();

        // 通过ProtoClient的create接口在K8S创建namespace
        ObjectOrStatus&amp;lt;Namespace&amp;gt; ns = buildProtoClient().create(namespaceObj, &quot;/api/v1/namespaces&quot;, &quot;v1&quot;, &quot;Namespace&quot;);

        // 使用Gson将集合对象序列化成JSON，在日志中打印出来
        log.info(&quot;ns info \n{}&quot;, new GsonBuilder().setPrettyPrinting().create().toJson(ns));

        return ns;
    }

    @RequestMapping(value = &quot;/pods/{namespace}&quot;, method = RequestMethod.GET)
    public ObjectOrStatus&amp;lt;PodList&amp;gt; pods(@PathVariable(&quot;namespace&quot;) String namespace) throws Exception {
        // 通过ProtoClient的list接口获取指定namespace下的pod列表
        ObjectOrStatus&amp;lt;PodList&amp;gt; pods = buildProtoClient().list(PodList.newBuilder(), &quot;/api/v1/namespaces/&quot; + namespace + &quot;/pods&quot;);

        // 使用Gson将集合对象序列化成JSON，在日志中打印出来
        log.info(&quot;pod info \n{}&quot;, new GsonBuilder().setPrettyPrinting().create().toJson(pods));

        return pods;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;上述代码展示了ProtoClient的API的用法，一个是获取pod列表，一个是创建namespace；&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;验证&quot;&gt;验证&lt;/h3&gt;
&lt;ol readability=&quot;6.3497267759563&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;确保K8S环境的config文件在本地可以访问(代码中kubeConfigPath变量的值)；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;运行ProtobufApplication；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;先尝试获取&lt;span&gt;kube-system&lt;/span&gt;这个namespace下的所有pod列表，在浏览器访问：&lt;a href=&quot;http://localhost:8080/pods/kube-system&quot; target=&quot;_blank&quot;&gt;http://localhost:8080/pods/kube-system&lt;/a&gt; ，响应如下图，红框中的items_数组就是所有pod信息：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210107075105464-352129329.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;上图中的&lt;span&gt;items_&lt;/span&gt;数组，展开一个却name字段是byte数组，没办法看出真实内容：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210107075105829-871599916.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;借助IDEA的断点功能，可以看清上述&lt;span&gt;name_&lt;/span&gt;字段的内容，如下图：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210107075106495-995176855.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0.77934272300469&quot;&gt;
&lt;p&gt;再来试试创建namespace的功能，浏览器执行：&lt;a href=&quot;http://localhost:8080/createnamespace/aaabbbccc&quot; target=&quot;_blank&quot;&gt;http://localhost:8080/createnamespace/aaabbbccc&lt;/a&gt; ，就会创建名为&lt;span&gt;aaabbbccc&lt;/span&gt;的namespace，并将&lt;span&gt;ProtoClient.create&lt;/span&gt;的返回信息展现到浏览器上：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210107075106953-288438517.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;SSH登录上K8S服务器，查看namespace，如下图红框，可以见到新增的namespace：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210107075107269-2131190787.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;验证完成，基于ProtoClient的API和K8S官方的在线API文档，我们可以轻松操作K8S环境；&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;protoclient的短板&quot;&gt;ProtoClient的短板&lt;/h3&gt;
&lt;ol readability=&quot;2&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;ProtoClient的短板其实在前面已经提到了，如下图红框4所示，在线API文档中提到查询pod列表的时候可以输入一些参数（例如过滤条件），但是ProtoClient提供的API咱们也看过了，并不支持输入查询参数：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210107075107660-752554579.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;来看下ProtoClient请求K8S Api service的核心代码，如下图红框所示，&lt;span&gt;请求参数字段已经写死&lt;/span&gt;，所以外面调用ProtoClient的API时根本没办法把参数传进来：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210107075108139-1158637845.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;咱们可以参考上述代码自己写一段，把红框位置改为API文档中指定的参数，但是，这样似乎略微麻烦，还有更好的办法吗？&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;当然有，敬请期待下一篇，一起学习和实战openapi主线；&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;你不孤单，欣宸原创一路相伴&quot;&gt;你不孤单，欣宸原创一路相伴&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105068742&quot; target=&quot;_blank&quot;&gt;Java系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086498&quot; target=&quot;_blank&quot;&gt;Spring系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086732&quot; target=&quot;_blank&quot;&gt;Docker系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086794&quot; target=&quot;_blank&quot;&gt;kubernetes系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086850&quot; target=&quot;_blank&quot;&gt;数据库+中间件系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086920&quot; target=&quot;_blank&quot;&gt;DevOps系列&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;欢迎关注公众号：程序员欣宸&quot;&gt;欢迎关注公众号：程序员欣宸&lt;/h3&gt;
&lt;blockquote readability=&quot;4.258064516129&quot;&gt;
&lt;p&gt;微信搜索「程序员欣宸」，我是欣宸，期待与您一同畅游Java世界...&lt;br/&gt;&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot; target=&quot;_blank&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Wed, 06 Jan 2021 23:51:00 +0000</pubDate>
<dc:creator>程序员欣宸</dc:creator>
<og:description>欢迎访问我的GitHub https://github.com/zq2599/blog_demos 内容：所有原创文章分类汇总及配套源码，涉及Java、Docker、Kubernetes、DevOPS</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/bolingcavalry/p/14244388.html</dc:identifier>
</item>
<item>
<title>腾讯IOT安卓开发初探 - 段小辉</title>
<link>http://www.cnblogs.com/xiaohuiduan/p/14244343.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaohuiduan/p/14244343.html</guid>
<description>&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;目的：将Andorid端作为一个物联网设备（device），然后将其安卓设备上面的数据发送到腾讯云IOT开发平台上。（这里我们将手机上面的GPS经纬度发送到&lt;strong&gt;腾讯云IOT&lt;/strong&gt;平台上）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;腾讯IOT开发平台：&lt;a href=&quot;https://console.cloud.tencent.com/iotexplorer&quot; target=&quot;_blank&quot;&gt;https://console.cloud.tencent.com/iotexplorer&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;腾讯IOT Java SDK GitHub：&lt;a href=&quot;https://github.com/tencentyun/iot-device-java&quot; target=&quot;_blank&quot;&gt;https://github.com/tencentyun/iot-device-java&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;开发工具：Android Studio&lt;/p&gt;
&lt;p&gt;代码Github：&lt;a href=&quot;https://github.com/xiaohuiduan/android_test_iot_for_tecent&quot; target=&quot;_blank&quot;&gt;android_test_iot_for_tecent&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;tecent-iot-开发平台的使用&quot;&gt;Tecent IOT 开发平台的使用&lt;/h2&gt;
&lt;p&gt;开发平台的官方参考文档网址：&lt;a href=&quot;https://cloud.tencent.com/document/product/1081&quot; target=&quot;_blank&quot;&gt;https://cloud.tencent.com/document/product/1081&lt;/a&gt;，不过个人觉得其文档对于Java SDK的描述不够详细，需要去看其 &lt;a href=&quot;https://github.com/tencentyun/iot-device-java/tree/master/explorer/explorer-device-android&quot; target=&quot;_blank&quot;&gt;Demo&lt;/a&gt; 源码才能明白其工作流程。&lt;/p&gt;
&lt;p&gt;腾讯云IOT开发平台的项目结构如下所示：分为两层——&lt;code&gt;项目&lt;/code&gt; 和 &lt;code&gt;产品&lt;/code&gt;。用在使用其平台的时候，既需要创建project，也需要创建product。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202101/1439869-20210107023930291-1417475570.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;我们可以将&lt;strong&gt;项目&lt;/strong&gt;理解为智能家居整个系统，因此在项目中有很多&lt;strong&gt;产品&lt;/strong&gt;，比如说智能空调，智能报警器等等产品。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;新建项目&quot;&gt;新建项目&lt;/h3&gt;
&lt;p&gt;新建项目，项目名称随意就行，创建好项目后，进入项目，然后创建产品。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202101/1439869-20210107023930600-619427062.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;创建产品&quot;&gt;创建产品&lt;/h3&gt;
&lt;p&gt;创建产品的选项如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;设备：因为我们是准备将安卓终端作为一台设备来使用的，因此，我们应该选择&lt;strong&gt;”设备“&lt;/strong&gt;，当然，如果我们是准备将它作为网关，则看着选就行了。&lt;/li&gt;
&lt;li&gt;认证方式：认证方式选择密钥认证，这样在代码中间直接写设备的密码就行，比证书稍微方便一点（不过实际上证书方便一点）。&lt;/li&gt;
&lt;li&gt;数据协议：使用数据模板即可。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202101/1439869-20210107023930878-826405533.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;添加自定义功能&quot;&gt;添加自定义功能&lt;/h3&gt;
&lt;p&gt;物联网设备，之所以叫物联网，是因为大家想把传感器获得的数据放在云端，或者通过云端去控制物联网设备。那么放什么数据，控制什么功能，则需要我们去定义。在腾讯IOT中，可以使用&lt;code&gt;新建功能&lt;/code&gt;定义这些功能。&lt;/p&gt;
&lt;p&gt;点击进入产品，选择&lt;strong&gt;新建功能&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202101/1439869-20210107023931137-301717061.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;自定义功能我们只需要两个功能：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;经度：position_x&lt;/li&gt;
&lt;li&gt;纬度：position_y&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;建立经度如下，在功能类型中选择&lt;strong&gt;属性&lt;/strong&gt;，数据类型我们选择浮点型。（经度和纬度的范围都在-180.0 ~180.0 ）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202101/1439869-20210107023931439-2098263922.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;同理将纬度配置为&lt;code&gt;position_y&lt;/code&gt;，功能类型为&lt;strong&gt;属性&lt;/strong&gt;，数据类型同样为浮点型，范围为-180.0 ~180.0 。&lt;/p&gt;
&lt;p&gt;关于功能类型的不同，可以参考下面的表格。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;以下来自官方文档&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;功能元素&lt;/th&gt;
&lt;th&gt;功能描述&lt;/th&gt;
&lt;th&gt;功能标识符&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;5.5&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;属性&lt;/td&gt;
&lt;td&gt;用于描述设备的实时状态，支持读取和设置，如模式、亮度、开关等。&lt;/td&gt;
&lt;td&gt;PropertiesId&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;事件&lt;/td&gt;
&lt;td&gt;用于描述设备运行时的事件，包括告警、信息和故障等三种事件类型，可添加多个输出参数，如环境传感器检测到空气质量很差，空调异常告警等。&lt;/td&gt;
&lt;td&gt;EventId&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;行为&lt;/td&gt;
&lt;td&gt;用于描述复杂的业务逻辑,可添加多个调用参数和返回参数,用于让设备执行某项特定的任务，例如，开锁动作需要知道是哪个用户在什么时间开锁，锁的状态如何等。&lt;/td&gt;
&lt;td&gt;ActionId&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/blockquote&gt;
&lt;p&gt;点击下一步，进入设备开发。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202101/1439869-20210107023931726-1284602902.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;设备开发&quot;&gt;设备开发&lt;/h3&gt;
&lt;p&gt;因为我们使用的是Java SDK进行开发，没有使用模组也没有基于OS开发，因此直接点击下一步。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202101/1439869-20210107023932005-1573449321.png&quot; alt=&quot;image-20210106165342612&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击下一步就到了微信小程序配置。&lt;/p&gt;
&lt;h3 id=&quot;微信小程序配置&quot;&gt;微信小程序配置&lt;/h3&gt;
&lt;p&gt;腾讯IOT平台相比较于其他平台，有一个很大的特点就是可以很好的支持小程序。也就是说，在开发的阶段，就可以使用小程序去验证设备的功能。并且这个微信小程序不需要自己写样式代码，只需要进行简单的配置，就可以直接从小程序上面看到物联网设备的数据。&lt;/p&gt;
&lt;p&gt;因为这里我们使用的数据很简单，只有经度和纬度两个数据，所以随便配置一下面板即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202101/1439869-20210107023932742-710446738.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;面板配置&quot;&gt;面板配置&lt;/h4&gt;
&lt;p&gt;这里面板类型选择&lt;strong&gt;标准面板&lt;/strong&gt;，然后配置一下模板样式（配置长按钮稍微好看一点），配置完效果图如右边所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202101/1439869-20210107023932999-690355722.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;新建设备&quot;&gt;新建设备&lt;/h3&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;新建设备`的意义：创建一个设备代表启动了一个账号（这个设备会提供一个密钥），我们的设备使用这个密钥，就可以让我们的设备连接腾讯云IOT平台进行数据交互。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;新建设备的步骤如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202101/1439869-20210107023933305-1954222109.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;使用设备&quot;&gt;使用设备&lt;/h3&gt;
&lt;p&gt;点击test_device，进入设备管理。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202101/1439869-20210107023933569-889553897.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;设备管理界面如下所示：&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;设备信息：这里面是设备的一些基本属性，其中通过设备&lt;code&gt;名称&lt;/code&gt;，&lt;code&gt;设备密钥&lt;/code&gt;，和&lt;code&gt;产品ID&lt;/code&gt;就可以唯一定位一个&lt;code&gt;设备&lt;/code&gt;，然后对其进行操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;设备日志：设备日志里面保存着设备的上行和下行数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;在线调试：通过在线调试，我们可以模拟设备的行为，或者对设备下发命令。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202101/1439869-20210107023933859-1090545495.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;🆗，以上的所有就是腾讯IOT平台的介绍，通过上面的操作，就可以创建一个设备，获得其name，key，id，然后对其进行开发了。&lt;/p&gt;
&lt;h2 id=&quot;安卓开发&quot;&gt;安卓开发&lt;/h2&gt;
&lt;p&gt;安卓开发实现的效果很简单，就是实现一个页面展示经纬度，然后将经纬度数据上传到腾讯IOT平台就行。&lt;/p&gt;
&lt;h3 id=&quot;前置配置&quot;&gt;前置配置&lt;/h3&gt;
&lt;p&gt;安卓开发，创建一个Android Studio项目，然后在APP的build gradle 中加入腾讯IOT的SDK&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;implementation 'com.tencent.iot.explorer:explorer-device-android:3.2.0'
&lt;/code&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202101/1439869-20210107023934148-153088014.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后新建两个JSON文件（必做！！！！！），&lt;code&gt;data.json&lt;/code&gt; ，代表的是设备的属性（这个文件的来源会在后面解释），然后是&lt;code&gt;app-config.json&lt;/code&gt;，这个代表的是设备的配置（来源后文解释）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202101/1439869-20210107023934683-942686719.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;datajson&quot;&gt;data.json&lt;/h4&gt;
&lt;p&gt;data.json 文件一定要放在安卓的assets目录下，安卓如何添加assets目录可以看&lt;a href=&quot;https://www.jianshu.com/p/c3cfd029d8b5&quot; target=&quot;_blank&quot;&gt;《Android studio 添加assets文件夹》&lt;/a&gt;。data.json需要存放一些数据。这个数据实际上就是&lt;strong&gt;自定义功能的数据&lt;/strong&gt;，复制之后粘贴到data.json文件中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202101/1439869-20210107023935018-402452060.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;app-configjson&quot;&gt;app-config.json&lt;/h4&gt;
&lt;p&gt;app-config.json文件的位置一定不要放错，它与src是同级目录，在app的下一级目录。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202101/1439869-20210107023935411-416361854.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;app-config里面是device的信息，数据内容如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-json&quot;&gt;{
  &quot;PRODUCT_ID&quot;:        &quot;产品ID&quot;,
  &quot;DEVICE_NAME&quot;:       &quot;设备名称&quot;,
  &quot;DEVICE_PSK&quot;:        &quot;设备密钥&quot;,
  &quot;SUB_PRODUCT_ID&quot;:    &quot;&quot;,
  &quot;SUB_DEV_NAME&quot;:      &quot;&quot;,
  &quot;SUB_DEV_PSK&quot;:       &quot;&quot;,
  &quot;SUB_PRODUCT_ID2&quot;:   &quot;&quot;,
  &quot;SUB_DEV_NAME2&quot;:     &quot;&quot;,
  &quot;SUB_DEV_PSK2&quot;:      &quot;&quot;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;来源：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202101/1439869-20210107023935652-583012346.png&quot; alt=&quot;image-20210106185636326&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;权限配置&quot;&gt;权限配置&lt;/h4&gt;
&lt;p&gt;位置权限，和联网权限。在&lt;code&gt;AndroidManifest.xml&lt;/code&gt;中添加如下权限。值得注意的是，位置权限在安卓版本比较高的设备中，需要使用代码申请位置权限。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;    &amp;lt;!--    位置权限--&amp;gt;
    &amp;lt;uses-permission android:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot; /&amp;gt;
    &amp;lt;uses-permission android:name=&quot;android.permission.ACCESS_COARSE_LOCATION&quot; /&amp;gt;
    &amp;lt;!--    联网权限--&amp;gt;
    &amp;lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;连接平台代码&quot;&gt;连接平台代码&lt;/h3&gt;
&lt;p&gt;通过官方提供的SDK，接入腾讯IOT平台实现设备连接和数据上传。代码如下所示，具体的含义写在注释中。在使用中，我们就可以通过实例化&lt;code&gt;IotCloudUtil&lt;/code&gt;，然后使用&lt;code&gt;connect()&lt;/code&gt;函数来实现连接和&lt;code&gt;propertyReport&lt;/code&gt;函数来实现上传数据。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package cc.weno.data_template;


import com.tencent.iot.explorer.device.android.common.Status;
import com.tencent.iot.explorer.device.android.data_template.TXDataTemplateClient;
import com.tencent.iot.explorer.device.android.data_template.TXDataTemplateDownStreamCallBack;
import com.tencent.iot.explorer.device.android.mqtt.TXMqttActionCallBack;
import com.tencent.iot.explorer.device.android.mqtt.TXMqttRequest;
import com.tencent.iot.explorer.device.android.utils.AsymcSslUtils;

import org.eclipse.paho.client.mqttv3.IMqttToken;
import org.eclipse.paho.client.mqttv3.MqttConnectOptions;
import org.eclipse.paho.client.mqttv3.MqttMessage;
import org.json.JSONObject;

import java.util.concurrent.atomic.AtomicInteger;

import cc.weno.location.MainActivity;


/**
 * 连接云平台的类
 *
 * @author XiaoHui
 */
public class IotCloudUtil {

    /**
     * 服务器网址
     */
    public static String mBrokerURL = &quot;ssl://iotcloud-mqtt.gz.tencentdevices.com:8883&quot;;
    /**
     * 产品ID
     */
    public static String mProductID = &quot;9JXQQW7SR5&quot;;
    /**
     * 设备名称
     */
    public static String mDevName = &quot;test_device&quot;;
    /**
     * 设备密钥
     */
    public static String mDevPSK = &quot;pCIUP7zhTp7snmfxb/72+g==&quot;;
    /**
     * data.json的名字
     */
    public static String mJsonFileName = &quot;data.json&quot;;
    /**
     * MQTTAction的回调
     */
    private TXMqttActionCallBack mMqttActionCallBack = null;
    /**
     * 下行消息的回调
     */
    private TXDataTemplateDownStreamCallBack mDownStreamCallBack = null;

    /**
     * MQTT连接实例
     */
    private TXDataTemplateClient mMqttConnection;
    /**
     * Activity实例
     */
    private MainActivity context;

    /**
     * 请求ID
     */
    private static AtomicInteger requestID = new AtomicInteger(199);


    public IotCloudUtil(MainActivity context) {
        this.context = context;
        mDownStreamCallBack = new MyDownCallback();
        mMqttActionCallBack = new MyMQttCallBack();
    }

    /**
     * 建立MQTT连接
     */
    public void connect() {
        // 创建连接client
        mMqttConnection = new TXDataTemplateClient(context, mBrokerURL, mProductID, mDevName, mDevPSK,
                null, null, mMqttActionCallBack,
                mJsonFileName, mDownStreamCallBack);
        // 设置连接参数
        MqttConnectOptions options = new MqttConnectOptions();
        // 连接超时
        options.setConnectionTimeout(8);
        // 保持活跃的时间间隔
        options.setKeepAliveInterval(240);
        // 是否自动重连
        options.setAutomaticReconnect(true);
        // 因为我们是使用密钥登录，所以需要设置这个
        options.setSocketFactory(AsymcSslUtils.getSocketFactory());
        // 建立Request请求
        TXMqttRequest mqttRequest = new TXMqttRequest(&quot;connect&quot;, requestID.getAndIncrement());
        // 建立连接
        mMqttConnection.connect(options, mqttRequest);
    }

    /**
     * 断开MQTT连接
     */
    public void disconnect() {
        TXMqttRequest mqttRequest = new TXMqttRequest(&quot;disconnect&quot;, requestID.getAndIncrement());
        mMqttConnection.disConnect(mqttRequest);
    }

    /**
     * 发送消息
     *
     * @param property 消息内容
     * @param metadata 属性的metadata，目前只包含各个属性对应的时间戳，可以为NULL
     * @return 状态
     */
    public Status propertyReport(JSONObject property, JSONObject metadata) {
        return mMqttConnection.propertyReport(property, metadata);
    }


    /**
     * MQTT的回调函数，暂时不考虑
     */
    public static class MyMQttCallBack extends TXMqttActionCallBack {

        @Override
        public void onConnectCompleted(Status status, boolean reconnect, Object userContext, String msg) {

        }

        @Override
        public void onConnectionLost(Throwable cause) {

        }

        @Override
        public void onDisconnectCompleted(Status status, Object userContext, String msg) {
        }

        @Override
        public void onPublishCompleted(Status status, IMqttToken token, Object userContext, String errMsg) {
        }

        @Override
        public void onSubscribeCompleted(Status status, IMqttToken asyncActionToken, Object userContext, String errMsg) {

        }

        @Override
        public void onMessageReceived(final String topic, final MqttMessage message) {
        }
    }

    /**
     * 实现下行消息处理的回调接口，暂时不考虑
     */
    private static class MyDownCallback extends TXDataTemplateDownStreamCallBack {

        @Override
        public void onReplyCallBack(String msg) {
        }

        @Override
        public void onGetStatusReplyCallBack(JSONObject data) {

        }

        @Override
        public JSONObject onControlCallBack(JSONObject msg) {

            return null;
        }

        @Override
        public JSONObject onActionCallBack(String actionId, JSONObject params) {

            return null;
        }
    }

}

&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;安卓页面配置&quot;&gt;安卓页面配置&lt;/h3&gt;
&lt;p&gt;安卓页面很简单，就是展示经度和纬度的数据。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202101/1439869-20210107023935854-369476434.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;页面代码如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
&amp;lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    tools:context=&quot;.MainActivity&quot;&amp;gt;

    &amp;lt;TextView
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:layout_marginLeft=&quot;20dp&quot;
        android:text=&quot;x轴:&quot; /&amp;gt;

    &amp;lt;TextView
        android:id=&quot;@+id/x_position&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:layout_marginLeft=&quot;100dp&quot;
        android:text=&quot;0.00&quot; /&amp;gt;

    &amp;lt;TextView

        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:layout_marginLeft=&quot;20dp&quot;
        android:layout_marginTop=&quot;100dp&quot;
        android:text=&quot;y轴：&quot; /&amp;gt;

    &amp;lt;TextView

        android:id=&quot;@+id/y_position&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:layout_marginLeft=&quot;100dp&quot;
        android:layout_marginTop=&quot;100dp&quot;

        android:text=&quot;0.00&quot; /&amp;gt;

&amp;lt;/RelativeLayout&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;activity代码&quot;&gt;Activity代码&lt;/h3&gt;
&lt;p&gt;在MainActivity，我们要实现如下的功能，申请位置权限，获得经纬度的数据，然后进行页面展示，最后将数据上传到云平台。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package cc.weno.location;

import android.Manifest;
import android.location.Location;
import android.os.Bundle;
import android.widget.TextView;

import androidx.appcompat.app.AppCompatActivity;
import androidx.core.app.ActivityCompat;

import com.tencent.iot.explorer.device.android.common.Status;

import org.json.JSONException;
import org.json.JSONObject;

import cc.weno.data_template.IotCloudUtil;


/**
 * 主页面，进行展示以及发送数据
 *
 * @author XiaoHui
 */
public class MainActivity extends AppCompatActivity {
    /**
     * 展示经度
     */
    private TextView xPositionView;
    /**
     * 展示纬度
     */
    private TextView yPositionView;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        xPositionView = findViewById(R.id.x_position);
        yPositionView = findViewById(R.id.y_position);
        // 基本上现在的安卓机都需要申请位置权限了
        ActivityCompat.requestPermissions(this, new String[]{Manifest.permission.ACCESS_FINE_LOCATION}, 1);
        // 获得位置数据并且发送数据到云平台
        getAndSendLocation();
    }

    private void getAndSendLocation() {
        // 获得GPS工具类
        GPSUtils gpsUtil = GPSUtils.getInstance(this);
        // 获得位置
        Location location = gpsUtil.getLocation();

        double positionX = location.getLatitude();
        double positionY = location.getLongitude();
        // 在手机页面上展示
        xPositionView.setText(String.valueOf(positionX));
        yPositionView.setText(String.valueOf(positionY));
        // IotCloudUtil
        IotCloudUtil iotCloudUtil = new IotCloudUtil(this);
        // 连接云平台
        iotCloudUtil.connect();

        // 等待几秒钟，连接成功
        try {
            Thread.sleep(4000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        // 调用发送数据的函数需要传入JsonObject类型的数据
        JSONObject property = new JSONObject();
        try {
            property.put(&quot;position_x&quot;, (float) positionX);
            property.put(&quot;position_y&quot;, (float) positionY);
            // 发送数据
            Status status = iotCloudUtil.propertyReport(property, null);
            if (status == Status.OK){
                // 发送成功
            }
        } catch (JSONException e) {
            e.printStackTrace();
        }
    }

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中GPS工具就不进行介绍了，因为其不是重点，关于具体的代码可以参考&lt;a href=&quot;https://github.com/xiaohuiduan/android_test_iot_for_tecent&quot; target=&quot;_blank&quot;&gt;GitHub&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;微信小程序使用&quot;&gt;微信小程序使用&lt;/h2&gt;
&lt;p&gt;前面我们说了，可以是用微信小程序对开发的物联网设备进行开发调试，然后我们在如下的页面得到设备的二维码。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202101/1439869-20210107023936139-1389657597.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后打开”腾讯连连“小程序，对二维码进行扫描，即可将设备加入。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202101/1439869-20210107023936561-1758581626.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后我们运行安卓程序，自动向腾讯IOT平台发送经纬度数据，然后在微信小程序上就可以看到最新的数据。&lt;/p&gt;
&lt;p&gt;中间存在些许误差，可能是因为double转float的精度原因导致的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202101/1439869-20210107023937110-930747309.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;通过上面的操作我们创建了一个安卓程序，然后能够在微信小程序上面看到安卓设备的经纬度。归咎于原理，就是MQTT协议。使用平台提供的SDK，让开发者省下了大量花费在通信协议上面的时间。然而，我们还是应该去关注MQTT协议本身。知其然，更要知其所以然。&lt;/p&gt;
&lt;h3 id=&quot;参考&quot;&gt;参考&lt;/h3&gt;
&lt;ol readability=&quot;-0.35&quot;&gt;&lt;li readability=&quot;-0.25&quot;&gt;
&lt;p&gt;Github：&lt;a href=&quot;https://github.com/xiaohuiduan/android_test_iot_for_tecent&quot; target=&quot;_blank&quot;&gt;android_test_iot_for_tecent&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-0.36734693877551&quot;&gt;
&lt;p&gt;物联网开发平台使用文档：&lt;a href=&quot;https://cloud.tencent.com/document/product/1081&quot; target=&quot;_blank&quot;&gt;物联网开发平台 - 文档中心 - 腾讯云 (tencent.com)&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Github：&lt;a href=&quot;https://github.com/tencentyun/iot-device-java&quot; target=&quot;_blank&quot;&gt;iot-device-java&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Wed, 06 Jan 2021 18:40:00 +0000</pubDate>
<dc:creator>段小辉</dc:creator>
<og:description>腾讯IOT 安卓开发初探 目的：将Andorid端作为一个物联网设备（device），然后将其安卓设备上面的数据发送到腾讯云IOT开发平台上。（这里我们将手机上面的GPS经纬度发送到腾讯云IOT平台上</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiaohuiduan/p/14244343.html</dc:identifier>
</item>
<item>
<title>对HTTP请求接口资源下载时间过长的问题分析 - lulianqi15</title>
<link>http://www.cnblogs.com/lulianqi/p/14233364.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lulianqi/p/14233364.html</guid>
<description>&lt;h2 id=&quot;id-指定HTTP接口资源下载时间异常-问题如下&quot;&gt;问题描述&lt;/h2&gt;
&lt;p&gt;我司某产品线有指定业务接口customQuery在线上环境中，与首页一起打开时下载数据的时间明显过长（平均可以达到2s）&lt;/p&gt;
&lt;p&gt;注：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;“与首页一起打开” 的含义是指用户进入WEB系统后会首次加载的主页面，该主页会提前请求customQuery数据，以用于显示首页中的列表数据。&lt;/li&gt;
&lt;li&gt;正常的想法会第一时间认为是刚进入首页请求多，导致的下载速度慢，这个自然不是这个原因，要不然也不会专门写这些内容，后面会讲到。&lt;/li&gt;
&lt;li&gt;下文中我会尽量仅针对问题本身，不掺杂业务逻辑进行表述，并尽可能的做到描述清晰，准确。不过个人表达力及知识储备难免会有盲区，下文如有描述不当或有事实错误的地方，希望大家可以直接悉心指出。&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;em&gt;这里需要单独说明下因为之前已经发过一篇关于customQuery请求gzip压缩的帖子，而这里讲的是2个没有关系的东西，不用联系在一起。&lt;/em&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;先直接上问题请求的截图&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/209007/202101/209007-20210104234510394-263485012.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图323K的数据下载用了近2s，明显是出问题了。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;该接口有在数据翻页时也会触发，不过下载时间表现正常。（如下图，同样的软硬件条件，在其他场景下，同样的参数拉取同一个接口的情况）&lt;/span&gt;&lt;br/&gt;&lt;em&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/209007/202101/209007-20210104235210681-909016611.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;上图是翻页的场景（因为是列表数据，默认进入打开第一页，也可以自己触发翻页到其他页或回到第一页），也就是说只有在首页中被调用时下载时间异常，在正常TAB页中切换翻页数据下载表现都很正常。&lt;/p&gt;
&lt;p&gt;还有一个细节，这个接口在测试或预发环境表现都是正常的，没有出现下载时间过长的问题，这也从侧面证明了并不是因为首页数据量大导致下载慢，通过查看各个整个过程的请求时间线也能明显看出，在出问题的时间断，并没有很多数据资源正在传输。&lt;/p&gt;
&lt;h2&gt;排除服务端问题&lt;/h2&gt;
&lt;p&gt;为了排除服务端的问题，自己构建了测试程序简单模拟了下面场景。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;em&gt;同一请求顺序发送10次，结果如下（下载时间全部保持在300ms以下）&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;em&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/209007/202101/209007-20210105000259144-1993753891.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;em&gt;&lt;em&gt;&lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;以下是5个一组一起发送的情况，可以看到下载时间基本上也是维持在了500ms以下（因为该请求其实很大，一个response有超过300kb，5个会有近2Mb，这个时候已经对带宽有一定的压力了，下载速度下降是正常的，而在首页加载的场景下不会有这么大的带宽压力）&lt;/span&gt;&lt;/em&gt;&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;em&gt;&lt;em&gt;&lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/209007/202101/209007-20210105000505638-1686181747.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;


&lt;p&gt;通过上面的测试不难看出无论是顺序发送，或同一个客户端同时并行请求该请求资源的情况下，下载速度都不会下降到超过1s的水平。&lt;br/&gt;Chrome DevTools 里可以看到当前浏览器默认同一个域名虽也是同时维持着6个http1.1链接，但除了目标接口，其他5个请求都会非常快的完成（其他响应大多小于1kb&lt;span&gt;,不会占用太多带宽&lt;/span&gt;）&lt;/p&gt;
&lt;p&gt;虽然这样想，但是现在也只能暂时怀疑是网络方面的问题了，为了证实自己的猜想，需要分析TCP原始报文。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;注：本文并不阐述如何解决问题，主要通过各种事实数据证明问题出现在哪一个点，从而将问题转到正确的责任人。因为一般比较诡异的问题如果不能确认是问题具体是出在哪一块（服务端，运维，前端，嵌入式），那任何一方在工作压力已经如此大的情况下难免会本能的认为是其他人的问题，最后的结果就是，问题长时间都得不到解决。不过如果有充足是事实证据证明问题出在哪里，那通常负责那一块的同学还是会尽力去解决的。&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;排查网络问题&lt;/h2&gt;
&lt;h3&gt;准备工作&lt;/h3&gt;
&lt;p&gt;为了配合Wireshark分析TCP报文我们需要使用Chrome的【Capture Network Log】直接在chrome中访问 &lt;a rel=&quot;nofollow&quot;&gt;chrome://net-export/&lt;/a&gt;  即可以打开。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;（Capture Network Log 的使用见 https://support.google.com/chrome/a/answer/3293821?hl=en 仅仅是用还是比较容易的）&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;如下图，在把Capture Network Log启动后，再次触发首页加载，DevTools显示下载时间依然很长。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/209007/202101/209007-20210105004630122-710946845.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;刚刚network logs里的数据我们可以在netlog viewer里打开（&lt;a class=&quot;external-link&quot; href=&quot;https://netlog-viewer.appspot.com/&quot; rel=&quot;nofollow&quot;&gt;https://netlog-viewer.appspot.com/&lt;/a&gt;   这是官方的在线日志分析器，访问这个链接您可能需要“梯子”）&lt;br/&gt;&lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/209007/202101/209007-20210105010004301-1517699366.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;如上图我们通过Sockets及Events里的记录定位到我们请求的链路。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;主要是要获得这个链路的本地端口号（在Wireshark里我们需要通过这个端口号跟踪我们的tcp流）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;当然还可以得到这个链路的开始时间，及耗时 （需要明确一点这个开始时间是握手开始时间，不完全等于这个请求的开始时间，而且这个链接其实也会发好几个请求，后面会提到）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;em&gt;&lt;em&gt;&lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;&lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/209007/202101/209007-20210105010410312-1227598012.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;&lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;根据netlog viewer里的信息找到指定端口，如上图追踪目标流（本质是对网卡数据包进行过滤筛选，更容易定位问题）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/209007/202101/209007-20210105011419307-1678326398.png&quot; alt=&quot;&quot; width=&quot;806&quot; height=&quot;960&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图，通过查看netlog viewer 里的SOCKET_BYTES_SENT记录我们不难发现这个链接其实一共发送了4次HTTP应用层请求（分别在第26ms，第119ms，第153ms，第184ms 注意这里使用的是相对时间）&lt;br/&gt;通过计算保留到秒的绝对时间分别为35.528；35.621；35.655；35.686 (实际是最后一个才是我们的目标请求，通过chrome时间线或响应的大小可以很容易的确认这个点)&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/209007/202101/209007-20210105020129872-748501700.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;如上图，通过在指定流筛选由客户端发出去的大小合适的数据，可以看到发送的时间点基本上是跟前面Chrome的&lt;/span&gt;netlog viewer对的上去的（因为请求实际上都很小，一个报文长度内就能发完）&lt;/p&gt;

&lt;p&gt;目标流量确认了，现在我们可以安心的去分析TCP报文了&lt;br/&gt;&lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/209007/202101/209007-20210105020734924-1959391527.png&quot; alt=&quot;&quot; width=&quot;1102&quot; height=&quot;459&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;我们只需要关注No 968 后面的报文（因为我们的目标请求是从这里开始的），可以看到其实第一个数据回包在No 1031 （时间为：35.875）&lt;br/&gt;与发出请求的那个包的时间差为189ms，这个其实就是TTFB （与chrome里计算出的198ms也是接近的）&lt;br/&gt;逐条查看后面下载的包，看起来都很正常。&lt;br/&gt;下面列出最开始在网络方向怀疑的几个可能的点，并逐个尝试排查。 （&lt;span&gt;&lt;em&gt;下一段内容主要是逐个排除自己猜测，且过程与网络传输强相关，如果实在不感兴趣可以跳过直接看&lt;a href=&quot;https://www.cnblogs.com/lulianqi/p/14233364.html#_label3&quot;&gt;结论&lt;/a&gt; &lt;/em&gt;&lt;/span&gt;）&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;id-指定HTTP接口资源下载时间异常-1:首先怀疑滑动窗持续收缩，导致后面接收效率急剧下降&quot;&gt;&lt;br/&gt;1:首先怀疑滑动窗持续收缩，导致后面接收效率急剧下降&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/209007/202101/209007-20210105021651148-1755375535.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt; 通过&lt;/span&gt;Wireshark提供的流图形我们可以直观的看到滑动窗口在整个TCP数据流里的变化趋势（当然在外面报文列表里也能直接看出来）&lt;/p&gt;
&lt;p&gt; &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;不过看起来当前流最差的情况滑动窗口也还有100kb （完全是够用，事实上只要红框处tcptrace的2条线不重合即表示滑动窗口还没有满）&lt;/span&gt;&lt;/p&gt;

&lt;h3 id=&quot;id-指定HTTP接口资源下载时间异常-2:而后是拥塞窗口cwnd，会不会是发送端因为乱序或超时导致服务器当前链路的cwnd下降而主动降速&quot;&gt;2:而后是拥塞窗口cwnd，会不会是发送端因为乱序或超时导致服务器当前链路的cwnd下降而主动降速&lt;/h3&gt;
&lt;p&gt;因为cwnd是发送端本地维护的，我们无法像Win窗口一样在Wireshark里直接看到，不过我们可以通过观察流量包的状态得出初步的判断。（分析在没有ACK确认的情况下可以发送多少数据）&lt;br/&gt;目标请求response一共323KB（服务端回我们的包一个为1460字节）理论一共大概会回复我们200多个包(通过过滤器我们可以准确统计出229个含有有效数据的回包，当然包括少量的TLS握手及前3个请求的回包)&lt;br/&gt;如果按默认拥塞窗口阀值ssthresh取65532，最差会在第45个包左右（每个报文段都充满的情况下）就会完成慢启动进入拥塞避免状态。&lt;br/&gt;&lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/209007/202101/209007-20210105125838281-760983796.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;如上图，通过查看建立链接握手时收到ACK的时间点，可以大致推断出客户端到服务器的RTT大概是10ms （因为握手的ACK一般不会延迟发送）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;&lt;br/&gt;&lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/209007/202101/209007-20210105225807181-86875411.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;&lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;通过观察服务端发送数据包序列号新增的图表我们可以发现，以10ms为间隔基本上都是15个包一组一起发送。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;&lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;几乎大部分时间都是是一次发15个包（21900字节），虽然没有达到65K（服务端cwnd应该是能达到64K甚至更高，可能是链路中的其他网络设备的窗口限制住了，毕竟这个速度运营商是要控制的），不过其实20K的cwnd也还是不错的，不应该会成为瓶颈 。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;&lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;不同的网络状态cwnd的稳定峰值可能有差异，多的时候能会超过40K。其实这个一次发送的量直接受带宽影响。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3 id=&quot;id-指定HTTP接口资源下载时间异常-3:后面想到的就是数据包乱序，或丢包&quot;&gt;3:后面想到的就是数据包乱序，或丢包&lt;/h3&gt;
&lt;p&gt;因为无论是丢包还是乱序，最终都会反应到cwnd下降，发送效率降低，不过从数据包列图表来看并没有发生这些情况。&lt;br/&gt;为了分析丢包及乱序对资源下载的影响，实际测试的时候有意创造了较差网络，分析了这些有很多乱序及重传的情况，如下图是一次有乱序的流量。（与前文中的截图不是同一个流量数据，该图是专门选取的网络条件较差的情况）&lt;br/&gt;&lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/209007/202101/209007-20210105233520758-330523909.png&quot; alt=&quot;&quot; width=&quot;1244&quot; height=&quot;381&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;可以明显看出来，即使发生了丢包及乱序，TCP恢复的都非常的快，绝不会把下载速度拖到超过1s。&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;收多次2481的乱序包后，马上就来了重传包（当然这里很可能只是迟到了的包，因为我们看到从第3个乱序ACK从发出到收到“重传”只有5ms，不到一个RTT。一般发送端会在收到3个以上的重传包以后才会认为发生丢包，上图中远不到一个RTT，是来不及收到第3个dup，然后再把重传包发送到接收方的）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;而且看后面报文发送的情况，而且这些乱序并没有导致服务端发包的量及速率并没有明显下降（上面也提到了理论上cwnd应该已经到达了65k以上，不过实际上一次发送的量因为其他限制一直被控制在20K内，所以即使服务端认为自己确实发生乱序而降低cwnd，也不会影响到现在的发送速率）&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;id-指定HTTP接口资源下载时间异常-4:确认问题&quot;&gt;确认问题&lt;/h2&gt;
&lt;h3&gt;明确原因&lt;/h3&gt;
&lt;p&gt;反复查看了多组测试数据包，怎么看都觉得流量是正常的，链路上的数据包及他们的确认包，还包括他们从异常状态中的恢复过程都很正常，完全看不不同寻常的东西。&lt;br/&gt;有的时候陷进去了是很难拔出来的，之前一直认为是运维的问题，所以竭尽全力的去寻找网络上的问题。&lt;/p&gt;
&lt;p&gt;会不会是最开始判断错了，恍然大悟，如果网络都是正常的那不可能是超过1s的传输时间啊，200多个包一次15个间隔大概10ms，那发送及确认的时间绝不会超过200ms才对！&lt;br/&gt;这个时候我才开始怀疑chrome的数据（因为之前计算TTFB的时间chrome与wireshark的时间一致，后面就再也没有怀疑过chrome的时间，也没有特意去对比后面的时间点）&lt;br/&gt;&lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/209007/202101/209007-20210106000559778-1779289174.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;如上图是这个response最后的报文段，从最开始发送response的第一个包（响应的首字节）的No 1031（35.875692），到上图的No 1374（36.045216）客户端确认最后一个服务端发来的数据包的时间差分明只有170ms。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;其实前面的流量图表上也有体现序列号都是在200ms内加上去的，只是当时没有关注到 （陷入先入为主的思维里了，一开始自己就认定是网络问题，加上最开始核对chrome的开始时间及TTFB都是对的，就放松了对chrome本身的警惕）&lt;br/&gt;现在基本上已经可以判断就是客户端（chrome）方面有问题。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;验证问题&lt;/h3&gt;
&lt;p&gt;为了验证这个的结论可以使用使用了常用的代理软件（charles及fiddler）他们都会有独立的时间线统计功能。&lt;br/&gt;&lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/209007/202101/209007-20210106003453036-228358589.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;可以看到代理上的时间明显比chrome上显示的时间少很多（一个162ms，一个2200ms）&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;其实到现在已经可以下结论是客户端的的问题（前端）。不过因为这个请求其实在浏览器除首页的其他场景或着使用其他客户端直接请求下载速度都是正常的，出问题的那次请求又是预加载的请求（同时还会有好几个请求会被一起发送），所以乍一看总会觉得是网络方面的问题，当然这个上文中的内容已经证明了，完全不是网络的问题。不过要让前端同学“诚恳”的接受这个是自己的问题并想办法修复它，可能还需要我们进一步指出问题出在了什么地方（万一有同学把问题直接推给chrome那不就无解了么）。&lt;/p&gt;

&lt;p&gt;通过上文的描述我们可以发现响应回包已经在200ms内全部被客户端socket确认，但是chrome似乎认为是1，2s。&lt;br/&gt;&lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/209007/202101/209007-20210106004201849-1028721352.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;通过观察多个被chrome统计称2s的流量的滑动窗口win数值的变化，发现了一个共性，那就是在接受该请求时客户端win的大小呈现出趋势性的下降（而正常的下载时间的场景没有这个趋势）&lt;br/&gt;开始因为这个窗口最低也只将到了200kb，实际发送方一直在以20kb的量在传输，200kb的win根本不会阻塞流量，所以自己也一直没有觉得有什么问题，而这个趋势实际上是不正常的，因为其实数据的ACK其实很快就回复了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;那这个变化趋势的产生的原因可能也是chrome里下载时间明显变长的原因。&lt;br/&gt;我们知道win的窗口大小是用来告知对方当前链接自己还能接受多少数据的一个标记，服务端发送过来的数据会占用这个win，客户端在回复ACK的时候会告知对方当前自己的win大小，通常socket收到的数据被确认后会马上被应用程序读取，这个win会迅速恢复，不会持续下降。这里的持续下降大概率就是数据没有被应用层读取。通常应用层读取本地socket接收缓存的速度比包在广域网络里传输的速度快几个量级，这里大量数据没有及时被应用读取，那就极可能是应用程序自己遇到了“非常”的情况。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;排除其他因素&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;到这一步可以说是前端应用的锅已经稳了,不过为了严谨我们还要排除是统计问题，会不会只是是chrome算时间算错了。&lt;br/&gt;其实这个还是比较好确认的，最简单的就是录屏逐帧查看是不是要等2s的下载完成后才加载数据，当然其实chrome的DevTools里的Performance工具可以帮我们完成分析（同时也会录屏）&lt;br/&gt;&lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/209007/202101/209007-20210106005158876-1592985785.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;&lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;通过Performance可以看出下载那段时间是没有渲染出数据的（其实下载完成后也还需要一段时间才能展示出数据）&lt;br/&gt;chrome看起来统计下载时间是按应用自己读取时间来的，因为“某些”异常导致读取明显滞后，最终表现在网页上就是下载时间超长。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;&lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;总结&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;&lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;应该是前端应用在预加载请求上的写法给chrome的执行照成了问题，整体上肯定是应用代码的问题跑不掉了。&lt;br/&gt;现在就需要前端同学去确定具体是什么“异常”了。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;还有一个细节，因为下载时间变长在测试或预发环境表现正常，因此一开始我按自己的经验认为是运维的问题（服务器，网络，nginx）所以一直在试图证明自己的错误的想法，偏执的去找数据流量的茬，同时也没有怀疑过chrome统计的数据可能不是真实的网络时间，导致整个过程花了很长时间。&lt;/p&gt;

</description>
<pubDate>Wed, 06 Jan 2021 18:22:00 +0000</pubDate>
<dc:creator>lulianqi15</dc:creator>
<og:description>问题描述 我司某产品线有指定业务接口customQuery在线上环境中，与首页一起打开时下载数据的时间明显过长（平均可以达到2s） 注： “与首页一起打开” 的含义是指用户进入WEB系统后会首次加载的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lulianqi/p/14233364.html</dc:identifier>
</item>
<item>
<title>Java并发包源码学习系列：CLH同步队列及同步资源获取与释放 - 天乔巴夏丶</title>
<link>http://www.cnblogs.com/summerday152/p/14244324.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/summerday152/p/14244324.html</guid>
<description>&lt;h2 id=&quot;本篇学习目标&quot;&gt;本篇学习目标&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;回顾CLH同步队列的结构。&lt;/li&gt;
&lt;li&gt;学习独占式资源获取和释放的流程。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;clh队列的结构&quot;&gt;CLH队列的结构&lt;/h2&gt;
&lt;p&gt;我在&lt;a href=&quot;https://www.cnblogs.com/summerday152/p/14238284.html#%E5%90%8C%E6%AD%A5%E9%98%9F%E5%88%97%E4%B8%8Enode%E8%8A%82%E7%82%B9&quot; target=&quot;_blank&quot;&gt;Java并发包源码学习系列：AbstractQueuedSynchronizer#同步队列与Node节点&lt;/a&gt;已经粗略地介绍了一下CLH的结构，本篇主要解析该同步队列的相关操作，因此在这边再回顾一下：&lt;/p&gt;
&lt;p&gt;AQS通过内置的FIFO同步双向队列来完成资源获取线程的排队工作，内部通过节点head【实际上是虚拟节点，真正的第一个线程在head.next的位置】和tail记录队首和队尾元素，队列元素类型为Node。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1771072/202101/1771072-20210107013340062-698786209.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果当前线程获取同步状态失败（锁）时，AQS 则会将当前线程以及等待状态等信息构造成一个节点（Node）并将其加入同步队列，同时会阻塞当前线程&lt;/li&gt;
&lt;li&gt;当同步状态释放时，则会把节点中的线程唤醒，使其再次尝试获取同步状态。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;接下来将要通过&lt;strong&gt;AQS以独占式的获取和释放资源&lt;/strong&gt;的具体案例来详解内置CLH阻塞队列的工作流程，接着往下看吧。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;资源获取&quot;&gt;资源获取&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    public final void acquire(int arg) {
        if (!tryAcquire(arg) &amp;amp;&amp;amp; // tryAcquire由子类实现，表示获取锁，如果成功，这个方法直接返回了
            acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) // 如果获取失败，执行
            selfInterrupt();
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;tryAcquire(int)是AQS提供给子类实现的钩子方法，子类可以自定义实现独占式获取资源的方式，获取成功则返回true，失败则返回false。&lt;/li&gt;
&lt;li&gt;如果tryAcquire方法获取资源成功就直接返回了，失败的化就会执行&lt;code&gt;acquireQueued(addWaiter(Node.EXCLUSIVE), arg))&lt;/code&gt;的逻辑，我们可以将其进行拆分，分为两步：
&lt;ul&gt;&lt;li&gt;addWaiter(Node.EXCLUSIVE)：将该线程包装成为独占式的节点，加入队列中。&lt;/li&gt;
&lt;li&gt;acquireQueued(node,arg)：如果当前节点是等待节点的第一个，即head.next，就尝试获取资源。如果该方法返回true，则会进入&lt;code&gt;selfInterrupt()&lt;/code&gt;的逻辑，进行阻塞。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;接下来我们分别来看看&lt;code&gt;addWaiter&lt;/code&gt;和&lt;code&gt;acquireQueued&lt;/code&gt;两个方法。&lt;/p&gt;
&lt;h3 id=&quot;入队node-addwaiternode-mode&quot;&gt;入队Node addWaiter(Node mode)&lt;/h3&gt;
&lt;p&gt;根据传入的mode参数决定独占或共享模式，为当前线程创建节点，并入队。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    // 其实就是把当前线程包装一下，设置模式，形成节点，加入队列
        private Node addWaiter(Node mode) {
        // 根据mode和thread创建节点
        Node node = new Node(Thread.currentThread(), mode);
        // 记录一下原尾节点
        Node pred = tail;
        // 尾节点不为null，队列不为空，快速尝试加入队尾。
        if (pred != null) {
            // 让node的prev指向尾节点
            node.prev = pred;
            // CAS操作设置node为新的尾节点，tail = node
            if (compareAndSetTail(pred, node)) {
                // 设置成功，让原尾节点的next指向新的node，实现双向链接
                pred.next = node;
                // 入队成功，返回
                return node;
            }
        }
        // 快速入队失败，进行不断尝试
        enq(node);
        return node;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;几个注意点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;入队的操作其实就是将线程通过指定模式包装为Node节点，如果队列尾节点不为null，利用CAS尝试快速加入队尾。&lt;/li&gt;
&lt;li&gt;快速入队失败的原因有两个：
&lt;ul&gt;&lt;li&gt;队列为空，即还没有进行初始化。&lt;/li&gt;
&lt;li&gt;CAS设置尾节点的时候失败。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;在第一次快速入队失败后，将会走到enq(node)逻辑，不断进行尝试，直到设置成功。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;不断尝试node-enqfinal-node-node&quot;&gt;不断尝试Node enq(final Node node)&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    private Node enq(final Node node) {
        // 自旋，俗称死循环，直到设置成功为止
        for (;;) {
            // 记录原尾节点
            Node t = tail;
            // 第一种情况：队列为空，原先head和tail都为null，
            // 通过CAS设置head为哨兵节点，如果设置成功，tail也指向哨兵节点
            if (t == null) { // Must initialize
                // 初始化head节点
                if (compareAndSetHead(new Node()))
                    // tail指向head，下个线程来的时候，tail就不为null了，就走到了else分支
                    tail = head;
            // 第二种情况：CAS设置尾节点失败的情况，和addWaiter一样，只不过它在for(;;)中
            } else {
                // 入队，将新节点的prev指向tail
                node.prev = t;
                // CAS设置node为尾部节点
                if (compareAndSetTail(t, node)) {
                    //原来的tail的next指向node
                    t.next = node;
                    return t;
                }
            }
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;enq的过程是自选设置队尾的过程，如果设置成功，就返回。如果设置失败，则一直尝试设置，理念就是，我总能等待设置成功那一天。&lt;/p&gt;
&lt;p&gt;我们还可以发现，head是延迟初始化的，在第一个节点尝试入队的时候，head为null，这时使用了&lt;code&gt;new Node()&lt;/code&gt;创建了一个不代表任何线程的节点，作为虚拟头节点，且我们需要注意它的waitStatus初始化为0，这一点对我们之后分析有指导意义。&lt;/p&gt;
&lt;p&gt;如果是CAS失败导致重复尝试，那就还是让他继续CAS好了。&lt;/p&gt;
&lt;h3 id=&quot;boolean-acquirequeuednode-int&quot;&gt;boolean acquireQueued(Node, int)&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    // 这个方法如果返回true，代码将进入selfInterrupt()
        final boolean acquireQueued(final Node node, int arg) {
        // 注意默认为true
        boolean failed = true;
        try {
            // 是否中断
            boolean interrupted = false;
            // 自旋，即死循环
            for (;;) {
                // 得到node的前驱节点
                final Node p = node.predecessor();
                // 我们知道head是虚拟的头节点，p==head表示如果node为阻塞队列的第一个真实节点
                // 就执行tryAcquire逻辑，这里tryAcquire也需要由子类实现
                if (p == head &amp;amp;&amp;amp; tryAcquire(arg)) {
                    // tryAcquire获取成功走到这，执行setHead出队操作 
                    setHead(node);
                    p.next = null; // help GC
                    failed = false;
                    return interrupted;
                }
                // 走到这有两种情况 1.node不是第一个节点 2.tryAcquire争夺锁失败了
                // 这里就判断 如果当前线程争锁失败，是否需要挂起当前这个线程
                if (shouldParkAfterFailedAcquire(p, node) &amp;amp;&amp;amp;
                    parkAndCheckInterrupt())
                    interrupted = true;
            }
        } finally {
            // 死循环退出，只有tryAcquire获取锁失败的时候failed才为true
            if (failed)
                cancelAcquire(node);
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;出队void-setheadnode&quot;&gt;出队void setHead(Node)&lt;/h3&gt;
&lt;p&gt;CLU同步队列遵循FIFO，首节点的线程释放同步状态后，唤醒下一个节点。将队首节点出队的操作实际上就是，将head指针指向将要出队的节点就可以了。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    private void setHead(Node node) {
        // head指针指向node
        head = node;
        // 释放资源
        node.thread = null;
        node.prev = null;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;boolean-shouldparkafterfailedacquirenodenode&quot;&gt;boolean shouldParkAfterFailedAcquire(Node,Node)&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    /**
     * 走到这有两种情况 1.node不是第一个节点 2.tryAcquire争夺锁失败了
     * 这里就判断 如果当前线程争锁失败，是否需要挂起当前这个线程
     *
     * 这里pred是前驱节点， node就是当前节点
     */
    private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {
        // 前驱节点的waitStatus
        int ws = pred.waitStatus;
        // 前驱节点为SIGNAL【-1】直接返回true，表示当前节点可以被直接挂起
        if (ws == Node.SIGNAL)
            return true;
        // ws&amp;gt;0 CANCEL 说明前驱节点取消了排队
        if (ws &amp;gt; 0) {
            // 下面这段循环其实就是跳过所有取消的节点，找到第一个正常的节点
            do {
                node.prev = pred = pred.prev;
            } while (pred.waitStatus &amp;gt; 0);
            // 将该节点的后继指向node，建立双向连接
            pred.next = node;
        } else {
            /*
             * waitStatus must be 0 or PROPAGATE.  Indicate that we
             * need a signal, but don't park yet.  Caller will need to
             * retry to make sure it cannot acquire before parking.
             * 官方说明：走到这waitStatus只能是0或propagate，默认情况下，当有新节点入队时，waitStatus总是为0
             * 下面用CAS操作将前驱节点的waitStatus值设置为signal
             */
            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);
        }
        // 返回false，接着会再进入循环，此时前驱节点为signal，返回true
        return false;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;针对前驱节点的waitStatus有三种情况：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;等待状态不会为 &lt;code&gt;Node.CONDITION&lt;/code&gt; ，因为它用在 ConditonObject 中&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;&lt;li&gt;ws==-1，即为Node.SIGNAL,表示当前节点node可以被直接挂起，在pred线程释放同步状态时，会对node线程进行唤醒。&lt;/li&gt;
&lt;li&gt;ws &amp;gt; 0，即为Node.CANCELLED，说明前驱节点已经取消了排队【可能是超时，可能是被中断】，则需要找到前面没有取消的前驱节点，一直找，直到找到为止。&lt;/li&gt;
&lt;li&gt;ws == 0 or ws == Node.PROPAGATE：
&lt;ul&gt;&lt;li&gt;默认情况下，当有新节点入队时，waitStatus总是为0，用CAS操作将前驱节点的waitStatus值设置为signal，下一次进来的时候，就走到了第一个分支。&lt;/li&gt;
&lt;li&gt;当释放锁的时候，会将占用锁的节点的ws状态更新为0。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;PROPAGATE表示共享模式下，前驱节点不仅会唤醒后继节点，同时也可能会唤醒后继的后继。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们可以发现，这个方法在第一次走进来的时候是不会返回true的。原因在于，返回true的条件时前驱节点的状态为SIGNAL，而第一次的时候还没有给前驱节点设置SIGNAL呢，只有在CAS设置了状态之后，第二次进来才会返回true。&lt;/p&gt;
&lt;p&gt;那SIGNAL的意义到底是什么呢？&lt;/p&gt;
&lt;blockquote readability=&quot;14.912721893491&quot;&gt;
&lt;p&gt;这里引用：&lt;a href=&quot;https://www.jianshu.com/p/4682a6b0802d&quot; target=&quot;_blank&quot;&gt;并发编程——详解 AQS CLH 锁 # 为什么 AQS 需要一个虚拟 head 节点&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;waitStatus这里用ws简称，每个节点都有ws变量，用于表示该节点的状态。初始化的时候为0，如果被取消为1，signal为-1。&lt;/p&gt;
&lt;p&gt;如果某个节点的状态是signal的，那么在该节点释放锁的时候，它需要唤醒下一个节点。&lt;/p&gt;
&lt;p&gt;因此，每个节点在休眠之前，如果没有将前驱节点的ws设置为signal，那么它将永远无法被唤醒。&lt;/p&gt;
&lt;p&gt;因此我们会发现上面当前驱节点的ws为0或propagate的时候，采用cas操作将ws设置为signal，目的就是让上一个节点释放锁的时候能够通知自己。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;boolean-parkandcheckinterrupt&quot;&gt;boolean parkAndCheckInterrupt()&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    private final boolean parkAndCheckInterrupt() {
        // 挂起当前线程
        LockSupport.park(this);
        return Thread.interrupted();
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;shouldParkAfterFailedAcquire方法返回true之后，就会调用该方法，挂起当前线程。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;LockSupport.park(this)&lt;/code&gt;方法挂起的线程有两种途径被唤醒：1.被unpark() 2.被interrupt()。&lt;/p&gt;
&lt;p&gt;需要注意这里的Thread.interrupted()会清除中断标记位。&lt;/p&gt;
&lt;h3 id=&quot;void-cancelacquirenode&quot;&gt;void cancelAcquire(node)&lt;/h3&gt;
&lt;p&gt;上面tryAcquire获取锁失败的时候，会走到这个方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    private void cancelAcquire(Node node) {
        // Ignore if node doesn't exist
        if (node == null)
            return;
                // 将节点的线程置空
        node.thread = null;

        // 跳过所有的取消的节点
        Node pred = node.prev;
        while (pred.waitStatus &amp;gt; 0)
            node.prev = pred = pred.prev;

        // predNext is the apparent node to unsplice. CASes below will
        // fail if not, in which case, we lost race vs another cancel
        // or signal, so no further action is necessary.
        // 这里在没有并发的情况下，preNext和node是一致的
        Node predNext = pred.next;

        // Can use unconditional write instead of CAS here. 可以直接写而不是用CAS
        // After this atomic step, other Nodes can skip past us.
        // Before, we are free of interference from other threads.
        // 设置node节点为取消状态
        node.waitStatus = Node.CANCELLED;

        // 如果node为尾节点就CAS将pred设置为新尾节点
        if (node == tail &amp;amp;&amp;amp; compareAndSetTail(node, pred)) {
            // 设置成功之后，CAS将pred的下一个节点置为空
            compareAndSetNext(pred, predNext, null);
        } else {
            // If successor needs signal, try to set pred's next-link
            // so it will get one. Otherwise wake it up to propagate.
            int ws;
            if (pred != head &amp;amp;&amp;amp; // pred不是首节点
                ((ws = pred.waitStatus) == Node.SIGNAL || // pred的ws为SIGNAL 或 可以被CAS设置为SIGNAL
                 (ws &amp;lt;= 0 &amp;amp;&amp;amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;amp;&amp;amp;
                pred.thread != null) { // pred线程非空
                // 保存node 的下一个节点
                Node next = node.next; 
                // node的下一个节点不是cancelled，就cas设置pred的下一个节点为next
                if (next != null &amp;amp;&amp;amp; next.waitStatus &amp;lt;= 0)
                    compareAndSetNext(pred, predNext, next);
            } else {
                // 上面的情况除外，则走到这个分支，唤醒node的下一个可唤醒节点线程
                unparkSuccessor(node);
            }

            node.next = node; // help GC
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;释放资源&quot;&gt;释放资源&lt;/h2&gt;
&lt;h3 id=&quot;boolean-releaseint-arg&quot;&gt;boolean release(int arg)&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    public final boolean release(int arg) {
        if (tryRelease(arg)) { // 子类实现tryRelease方法
            // 获得当前head
            Node h = head;
            // head不为null并且head的等待状态不为0
            if (h != null &amp;amp;&amp;amp; h.waitStatus != 0)
                // 唤醒下一个可以被唤醒的线程，不一定是next哦
                unparkSuccessor(h);
            return true;
        }
        return false;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;tryRelease(int)是AQS提供给子类实现的钩子方法，子类可以自定义实现独占式释放资源的方式，释放成功并返回true，否则返回false。&lt;/li&gt;
&lt;li&gt;unparkSuccessor(node)方法用于唤醒等待队列中下一个可以被唤醒的线程，不一定是下一个节点next，比如它可能是取消状态。&lt;/li&gt;
&lt;li&gt;head 的ws必须不等于0，为什么呢？当一个节点尝试挂起自己之前，都会将前置节点设置成SIGNAL -1，就算是第一个加入队列的节点，在获取锁失败后，也会将虚拟节点设置的 ws 设置成 SIGNAL，而这个判断也是防止多线程重复释放，接下来我们也能看到释放的时候，将ws设置为0的操作。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;void-unparksuccessornode-node&quot;&gt;void unparkSuccessor(Node node)&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    
        private void unparkSuccessor(Node node) {
        /*
         * If status is negative (i.e., possibly needing signal) try
         * to clear in anticipation of signalling.  It is OK if this
         * fails or if status is changed by waiting thread.
         */
        int ws = node.waitStatus;
        // 如果node的waitStatus&amp;lt;0为signal，CAS修改为0
        // 将 head 节点的 ws 改成 0，清除信号。表示，他已经释放过了。不能重复释放。
        if (ws &amp;lt; 0)
            compareAndSetWaitStatus(node, ws, 0);

        /*
         * Thread to unpark is held in successor, which is normally
         * just the next node.  But if cancelled or apparently null,
         * traverse backwards from tail to find the actual
         * non-cancelled successor.
         */
        // 唤醒后继节点，但是有可能后继节点取消了等待 即 waitStatus == 1
        Node s = node.next;
        // 如果后继节点为空或者它已经放弃锁了
        if (s == null || s.waitStatus &amp;gt; 0) {
            s = null;
            // 从队尾往前找，找到没有没取消的所有节点排在最前面的【直到t为null或t==node才退出循环嘛】
            for (Node t = tail; t != null &amp;amp;&amp;amp; t != node; t = t.prev)
                // 如果&amp;gt;0表示节点被取消了，就一直向前找呗，找到之后不会return，还会一直向前
                if (t.waitStatus &amp;lt;= 0)
                    s = t;
        }
        // 如果后继节点存在且没有被取消，会走到这，直接唤醒后继节点即可
        if (s != null)
            LockSupport.unpark(s.thread);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;参考阅读&quot;&gt;参考阅读&lt;/h2&gt;
</description>
<pubDate>Wed, 06 Jan 2021 17:34:00 +0000</pubDate>
<dc:creator>天乔巴夏丶</dc:creator>
<og:description>本篇学习目标 回顾CLH同步队列的结构。 学习独占式资源获取和释放的流程。 CLH队列的结构 我在Java并发包源码学习系列：AbstractQueuedSynchronizer#同步队列与Node节</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/summerday152/p/14244324.html</dc:identifier>
</item>
<item>
<title>BCC和libbpf的转换 - charlieroro</title>
<link>http://www.cnblogs.com/charlieroro/p/14244276.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/charlieroro/p/14244276.html</guid>
<description>&lt;h2 id=&quot;bcc和libbpf的转换&quot;&gt;BCC和libbpf的转换&lt;/h2&gt;
&lt;p&gt;本文讲述如何将基于BCC的BPF应用转换为libbpf + BPF CO-RE。BPF CO-RE可以参见上一篇&lt;a href=&quot;https://www.cnblogs.com/charlieroro/p/14206214.html&quot; target=&quot;_blank&quot;&gt;博文&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;为什么是libbpf和bpf-co-re？&quot;&gt;为什么是libbpf和BPF CO-RE？&lt;/h3&gt;
&lt;p&gt;历史上，当需要开发一个BPF应用时可以选择&lt;a href=&quot;https://github.com/iovisor/bcc/&quot; target=&quot;_blank&quot;&gt;BCC&lt;/a&gt; 框架，在实现各种用于Tracepoints的BPF程序时需要将BPF程序加载到内核中。BCC提供了内置的Clang编译器，可以在运行时编译BPF代码，并将其定制为符合特定主机内核的程序。这是在不断变化的内核内部下开发可维护的BPF应用程序的唯一方法。在&lt;a href=&quot;https://www.cnblogs.com/charlieroro/p/14206214.html&quot; target=&quot;_blank&quot;&gt;BPF的可移植性和CO-RE&lt;/a&gt;一文中详细介绍了为什么会这样，以及为什么BCC是之前唯一的可行方式，此外还解释了为什么 &lt;a href=&quot;https://github.com/libbpf/libbpf&quot; target=&quot;_blank&quot;&gt;libbpf&lt;/a&gt;是目前比较好的选择。去年，Libbpf的功能和复杂性得到了重大提升，消除了与BCC之间的很多差异(特别是对Tracepoints应用来说)，并增加了很多BCC不支持的新的且强大的特性(如全局变量和BPF skeletons)。&lt;/p&gt;
&lt;p&gt;诚然，BCC会竭尽全力简化BPF开发人员的工作，但有时在获取便利性的同时也增加了问题定位和修复的困难度。用户必须记住其命名规范以及自动生成的用于Tracepoints的结构体，且必须依赖这些代码的重写来读取内核数据和获取kprobe参数。当使用BPF map时，需要编写一个半面向对象的C代码，这与内核中发生的情况并不完全匹配。除此之外，BCC使得用户在用户空间编写了大量样板代码，且需要手动配置最琐碎的部分。&lt;/p&gt;
&lt;p&gt;如上所述，BCC依赖运行时编译，且本身嵌入了庞大的LLVM/Clang库，由于这些原因，BCC与理想的使用有一定差距：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;编译时的高资源利用率(内存和CPU)，在繁忙的服务器上时有可能干扰主流程。&lt;/li&gt;
&lt;li&gt;依赖内核头文件包，不得不在每台目标主机上进行安装。即使这样，如果需要某些没有通过公共头文件暴露的内核内容时，需要将类型定义拷贝黏贴到BPF代码中，通过这种方式达成目的。&lt;/li&gt;
&lt;li&gt;即使是很小的编译时错误也只能在运行时被检测到，之后不得不重新编译并重启用户层的应用；这大大影响了开发的迭代时间(并增加了挫败感...)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Libbpf + BPF CO-RE (Compile Once – Run Everywhere) 选择了一个不同的方式，其思想在于将BPF程序视为一个普通的用户空间的程序：仅需要将其编译成一些小的二进制，然后不用经过修改就可以部署到目的主机上。libbpf扮演了BPF程序的加载器，负责配置工作(重定位，加载和校验BPF程序，创建BPF maps，附加到BPF钩子上等)，开发者仅需要关注BPF程序的正确性和性能即可。这种方式使得开销降到了最低，消除了大量依赖，提升了整体开发者的开发体验。&lt;/p&gt;
&lt;p&gt;在API和代码约定方面，libbpf坚持&quot;最少意外&quot;的哲学，即大部分内容都需要明确地阐述：不会隐含任何头文件，也不会重写代码。仅使用简单的C代码和适当的辅助宏即可消除大部分单调的环节。 此外，用户编写的是需要执行的内容，BPF应用程序的结构是一对一的，最终由内核验证并执行。&lt;/p&gt;
&lt;p&gt;本指南用于简单快速地将BCC转换为libbpf+BPF CO-RE。本文解释了多种预配置步骤，并概述了常见的模式，以及可能会碰到的不同点，困难和陷阱。&lt;/p&gt;
&lt;p&gt;一开始将BCC转换为普通的BPF CO-RE时，可能会感到不适和困惑，但很快就会掌握它，并在下次遇到编译或验证问题时欣赏libbpf的明确性和直接性。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;此外，注意BPF CO-RE用到的很多Clang特性都比较新，&lt;strong&gt;需要用到Clang 10或更新的版本&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;15.693693693694&quot;&gt;
&lt;p&gt;可以参照官方&lt;a href=&quot;https://clang.llvm.org/get_started.html&quot; target=&quot;_blank&quot;&gt;文档&lt;/a&gt;升级Clang:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;git clone https://github.com/llvm/llvm-project.git&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Build LLVM and Clang:
&lt;ol&gt;&lt;li&gt;&lt;code&gt;cd llvm-project&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mkdir build&lt;/code&gt; (in-tree build is not supported)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cd build&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cmake -DLLVM_ENABLE_PROJECTS=clang -G &quot;Unix Makefiles&quot; ../llvm&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;make&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;注意：在2.3步执行cmake时，可能会因为&lt;code&gt;Host GCC version must be at least 5.1&lt;/code&gt;，这样的错误，需要升级GCC，升级之后&lt;a href=&quot;https://stackoverflow.com/questions/52180281/cmake-cxx-compiler-version-is-pointing-to-the-old-gcc-version&quot; target=&quot;_blank&quot;&gt;删除build&lt;/a&gt;再重新编译即可。但有时即便GCC升级成功，且清除build中的缓存，再次编译时还是会出现上述错误，可以手动指定GCC路径来解决该问题：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt; CC=$HOME/toolchains/bin/gcc cmake -DLLVM_ENABLE_PROJECTS=clang -G &quot;Unix Makefiles&quot; ../llvm
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;另外就是在执行&lt;code&gt;make&lt;/code&gt;命令时会执行lib库的编译和链接，在链接过程中会占用大量内存，建议在执行该命令时打开(或扩大)系统的swap功能，防止内存不足导致系统出问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;配置用户空间&quot;&gt;配置用户空间&lt;/h3&gt;
&lt;h4 id=&quot;生成必要的内容&quot;&gt;生成必要的内容&lt;/h4&gt;
&lt;p&gt;构建基于libbpf的BPF应用需要使用BPF CO-RE包含的几个步骤：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;生成带所有内核类型的头文件&lt;code&gt;vmlinux.h&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;使用Clang(版本10或更新版本)将BPF程序的源代码编译为&lt;code&gt;.o&lt;/code&gt;对象文件&lt;/li&gt;
&lt;li&gt;从编译好的BPF对象文件中生成BPF skeleton 头文件 (&lt;em&gt;BPF skeleton 头文件内容来自上一步生成的&lt;code&gt;.o&lt;/code&gt;文件，可以参考libbpf-tools的&lt;a href=&quot;https://github.com/iovisor/bcc/blob/master/libbpf-tools/Makefile&quot; target=&quot;_blank&quot;&gt;Makefile&lt;/a&gt;文件，可以看到 skeleton 头文件其实是通过&lt;code&gt;bpftool gen&lt;/code&gt;命令生成的&lt;/em&gt;)&lt;/li&gt;
&lt;li&gt;在用户空间代码中包含生成的BPF skeleton 头文件&lt;/li&gt;
&lt;li&gt;最后，编译用户空间代码，这样会嵌入BPF对象代码，后续就不用发布单独的文件&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;具体步骤依赖用户指定的配置和构建系统，此处不一一列出。一种方式是参考&lt;a href=&quot;https://github.com/iovisor/bcc/tree/master/libbpf-tools&quot; target=&quot;_blank&quot;&gt;BCC’s libbpf-tools&lt;/a&gt;，它给出了一个通用的Makefile文件，可以通过该文件来检查环境配置。&lt;/p&gt;
&lt;p&gt;当编译BPF代码并生成BPF skeleton后，需要在用户空间代码中包含libbpf和skeleton头文件：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;bpf/bpf.h&amp;gt;
#include &amp;lt;bpf/libbpf.h&amp;gt;
#include &quot;path/to/your/skeleton.skel.h&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;locked内存的限制&quot;&gt;Locked内存的限制&lt;/h3&gt;
&lt;p&gt;BPF的BPF maps以及其他内容使用了locked类型的内存。默认的限制非常低，因此，除非增加该值，否则有可能连一个很小的BPF程序都无法加载。BCC会无条件地将限制设置为无限大，但libbpf不会自动进行设置。&lt;/p&gt;
&lt;p&gt;生产环境中可能会有更好的方式来设置locked内存的限制。但为了快速实验或在没有更好的办法时，可以通过&lt;a href=&quot;http://man7.org/linux/man-pages/man2/setrlimit.2.html&quot; target=&quot;_blank&quot;&gt;setrlimit(2)&lt;/a&gt;系统调用进行设置(在程序开始前调用)。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;    #include &amp;lt;sys/resource.h&amp;gt;

    rlimit rlim = {
        .rlim_cur = 512UL &amp;lt;&amp;lt; 20, /* 512 MBs */
        .rlim_max = 512UL &amp;lt;&amp;lt; 20, /* 512 MBs */
    };

    err = setrlimit(RLIMIT_MEMLOCK, &amp;amp;rlim);
    if (err)
        /* handle error */
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;libbpf-日志&quot;&gt;Libbpf 日志&lt;/h3&gt;
&lt;p&gt;如果程序运行不正常，最好的方式是检查libbpf的日志输出。libbpf会以多种级别输出大量有用的日志。默认会输出error级别的日志。建议安装一个自定义的日志回调，这样就可以配置日志的输出级别：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;int print_libbpf_log(enum libbpf_print_level lvl, const char *fmt, va_list args) {
    if (!FLAGS_bpf_libbpf_debug &amp;amp;&amp;amp; lvl &amp;gt;= LIBBPF_DEBUG)
        return 0;
    return vfprintf(stderr, fmt, args);
}

/* ... */

libbpf_set_print(print_libbpf_log); /* set custom log handler */
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;bpf-skeleton-和-bpf-app-生命周期&quot;&gt;BPF skeleton 和 BPF app 生命周期&lt;/h4&gt;
&lt;p&gt;对BPF skeleton(以及libbpf API)的详细介绍和使用超出了本文档的范畴，&lt;a href=&quot;https://git.kernel.org/pub/scm/linux/kernel/git/bpf/bpf-next.git/tree/tools/testing/selftests/bpf&quot; target=&quot;_blank&quot;&gt;内核selftests&lt;/a&gt;以及BCC提供的&lt;a href=&quot;https://github.com/iovisor/bcc/tree/master/libbpf-tools&quot; target=&quot;_blank&quot;&gt;libbpf-tools 例子&lt;/a&gt;可以帮助熟悉这部分内容。查看&lt;a href=&quot;https://github.com/iovisor/bcc/blob/master/libbpf-tools/runqslower.c&quot; target=&quot;_blank&quot;&gt;runqslower&lt;/a&gt; 示例，它是一个使用skeleton的简单却真实的工具。&lt;/p&gt;
&lt;p&gt;尽管如此，了解主要的libbpf概念和每个BPF应用经过的阶段是很有用的。BPF应用包含一组BPF程序(合作或完全独立)，以及在所有的BPF程序间共享的BPF maps和全局变量(允许操作共同的数据)。BPF 也可以在用户空间(我们将用户空间中的程序称为&quot;控制app&quot;)中访问maps和全局变量，允许控制app获取或设置必要的额外数据。BPF应用通常会经过如下阶段：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;打开阶段：BPF对象文件的解析：发现但尚未创建的BPF maps，BPF程序和全局变量。在BPF app打开后，可以在所有的表项创建并加载前进行任何额外的调整(设置BPF类型；预设值全局变量的初始值等)；&lt;/li&gt;
&lt;li&gt;加载阶段：创建BPF maps并解决了符号重定位之后，BPF程序会被加载到内核进行校验。此时，BPF程序所有的部分都是有效且存在于内核中的，但此时的BPF并没有被执行。在加载阶段之后，可以配置BPF map状态的初始值，此时不会导致BPF程序代码竞争性地执行；&lt;/li&gt;
&lt;li&gt;附加阶段：此阶段中，BPF程序会附加到各种BPF钩子上(如Tracepoints，kprobes，cgroup钩子，网络报文处理流水线等)。此时，BPF会开始执行有用的工作，并读取/更新BPF maps和全局变量；&lt;/li&gt;
&lt;li&gt;清理阶段：分离并从内核卸载BPFBPF程序。销毁BPF maps，并释放所有的BPF使用的资源。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;生成的BPF skeleton 使用如下函数触发相应的阶段：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;&amp;lt;name&amp;gt;__open()&lt;/code&gt; – 创建并打开 BPF 应用(&lt;em&gt;例如的&lt;a href=&quot;https://github.com/iovisor/bcc/blob/master/libbpf-tools/runqslower.c&quot; target=&quot;_blank&quot;&gt;runqslower&lt;/a&gt;的&lt;code&gt;runqslower_bpf__open()&lt;/code&gt;函数&lt;/em&gt;);&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;name&amp;gt;__load()&lt;/code&gt; – 初始化，加载和校验BPF 应用部分;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;name&amp;gt;__attach()&lt;/code&gt; – 附加所有可以自动附加的BPF程序 (可选，可以直接使用libbpf API作更多控制);&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;name&amp;gt;__destroy()&lt;/code&gt; – 分离所有的 BPF 程序并使用其使用的所有资源.&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;bpf-代码转换&quot;&gt;BPF 代码转换&lt;/h3&gt;
&lt;p&gt;本章节会检查常用的转换流，并概述BCC和libbpf/BPF CO-RE之间存在的典型的不匹配。通过本章节，希望可以使你的BPF代码能够同时兼容BCC和BPF CO-RE。&lt;/p&gt;
&lt;h4 id=&quot;检测bcc与libbpf模式&quot;&gt;检测BCC与libbpf模式&lt;/h4&gt;
&lt;p&gt;在需要同时支持BCC和libbpf模式的场景下，需要检测BPF程序代码能够编译为哪种模式。最简单的方式是依赖BCC中的宏&lt;code&gt;BCC_SEC&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;#ifdef BCC_SEC
#define __BCC__
#endif
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;之后，在整个BPF代码中，可以执行以下操作：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;#ifdef __BCC__
/* BCC-specific code */
#else
/* libbpf-specific code */
#endif
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样就可以拥有通用的BPF源代码，并且只有必要的逻辑代码段才是BCC或libbpf特定的。&lt;/p&gt;
&lt;h4 id=&quot;头文件包含&quot;&gt;头文件包含&lt;/h4&gt;
&lt;p&gt;使用 libbpf/BPF CO-RE时，不需要包含内核头文件(如&lt;code&gt;#include &amp;lt;linux/whatever.h&amp;gt;&lt;/code&gt;)，仅需要包含一个&lt;code&gt;vmlinux.h&lt;/code&gt;和少量libbpf辅助功能的头文件：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;#ifdef __BCC__
/* linux headers needed for BCC only */
#else /* __BCC__ */
#include &quot;vmlinux.h&quot;   /* all kernel types */
#include &amp;lt;bpf/bpf_helpers.h&amp;gt;  /* most used helpers: SEC, __always_inline, etc */
#include &amp;lt;bpf/bpf_core_read.h&amp;gt;  /* for BPF CO-RE helpers */
#include &amp;lt;bpf/bpf_tracing.h&amp;gt;    /* for getting kprobe arguments */
#endif /* __BCC__ */
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;vmlinux.h&lt;/code&gt;可能不包含某些有用的内核&lt;code&gt;#define&lt;/code&gt;定义的常量，此时需要重新声明这些变量。但&lt;code&gt;bpf_helpers.h&lt;/code&gt;中提供了大部分常用的变量。&lt;/p&gt;
&lt;h4 id=&quot;字段访问&quot;&gt;字段访问&lt;/h4&gt;
&lt;p&gt;BCC会默默地重写你的BPF代码，并将诸如&lt;code&gt;tsk-&amp;gt; parent-&amp;gt; pid之&lt;/code&gt;类的字段访问转换为一系列的&lt;code&gt;bpf_probe_read()&lt;/code&gt;调用。Libbpf/BPF CO-RE没有此项功能，但&lt;code&gt;bpf_core_read.h&lt;/code&gt;提供了一系列普通C代码编写的辅助函数来完成类似的工作。上述的&lt;code&gt;tsk-&amp;gt;parent-&amp;gt;pid&lt;/code&gt;会变成&lt;code&gt;BPF_CORE_READ(tsk, parent, pid)&lt;/code&gt;。从Linux 5.5开始使用&lt;code&gt;tp_btf&lt;/code&gt;和&lt;code&gt;fentry&lt;/code&gt;/&lt;code&gt;fexit&lt;/code&gt; BPF程序类型，使用的也是C语法。但对于老版本的内核以及其他BPF程序类型(如Tracepoints和kprobe)，最好将其转换为&lt;code&gt;BPF_CORE_READ&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;BPF_CORE_READ&lt;/code&gt;宏也可以工作在BCC模式下，因此为了避免在&lt;code&gt;#ifdef __BCC__&lt;/code&gt;/&lt;code&gt;#else&lt;/code&gt;/&lt;code&gt;#endif&lt;/code&gt;中重复使用，可以将所有字段的读取转换为&lt;code&gt;BPF_CORE_READ&lt;/code&gt;，这样就可以同时给BCC和libbpf模式使用。使用BCC时，需要确保包含 &lt;code&gt;bpf_core_read.h&lt;/code&gt;头文件。&lt;/p&gt;
&lt;h4 id=&quot;bpf-maps&quot;&gt;BPF maps&lt;/h4&gt;
&lt;p&gt;BCC 和libbpf对BPF maps的声明是不同的，但转换方式很直接，下面是一些例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;/* Array */
#ifdef __BCC__
BPF_ARRAY(my_array_map, struct my_value, 128);
#else
struct {
    __uint(type, BPF_MAP_TYPE_ARRAY);
    __uint(max_entries, 128);
    __type(key, u32);
    __type(value, struct my_value);
} my_array_map SEC(&quot;.maps&quot;);
#endif

/* Hashmap */
#ifdef __BCC__
BPF_HASH(my_hash_map, u32, struct my_value);
#else
struct {
    __uint(type, BPF_MAP_TYPE_HASH);
    __uint(max_entries, 10240);
    __type(key, u32);
    __type(value, struct my_value);
} my_hash_map SEC(&quot;.maps&quot;)
#endif

/* Per-CPU array */
#ifdef __BCC__
BPF_PERCPU_ARRAY(heap, struct my_value, 1);
#else
struct {
    __uint(type, BPF_MAP_TYPE_PERCPU_ARRAY);
    __uint(max_entries, 1);
    __type(key, u32);
    __type(value, struct my_value);
} heap SEC(&quot;.maps&quot;);
#endif
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;请注意BCC中maps的默认大小，通常为&lt;strong&gt;10240&lt;/strong&gt;。使用libbpf时必须明确指定大小。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;PERF_EVENT_ARRAY&lt;/code&gt;, &lt;code&gt;STACK_TRACE&lt;/code&gt;和其他特殊的maps(&lt;code&gt;DEVMAP&lt;/code&gt;, &lt;code&gt;CPUMAP&lt;/code&gt;, etc) 尚不支持键/值类型的BTF类型，因此需要直接指定&lt;code&gt;key_size&lt;/code&gt;/&lt;code&gt;value_size&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;/* Perf event array (for use with perf_buffer API) */
#ifdef __BCC__
BPF_PERF_OUTPUT(events);
#else
struct {
    __uint(type, BPF_MAP_TYPE_PERF_EVENT_ARRAY);
    __uint(key_size, sizeof(u32));
    __uint(value_size, sizeof(u32));
} events SEC(&quot;.maps&quot;);
#endif
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;访问bpf代码中的bpf-maps&quot;&gt;访问BPF代码中的BPF maps&lt;/h4&gt;
&lt;p&gt;BCC使用伪C++语言处理maps，在幕后将其重写为实际的BPF辅助调用，通常使用如下模式：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;some_map.operation(some, args)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将其重写为如下格式：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;bpf_map_operation_elem(&amp;amp;some_map, some, args);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面是一些例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;#ifdef __BCC__
    struct event *data = heap.lookup(&amp;amp;zero);
#else
    struct event *data = bpf_map_lookup_elem(&amp;amp;heap, &amp;amp;zero);
#endif

#ifdef __BCC__
    my_hash_map.update(&amp;amp;id, my_val);
#else
    bpf_map_update_elem(&amp;amp;my_hash_map, &amp;amp;id, &amp;amp;my_val, 0 /* flags */);
#endif

#ifdef __BCC__
    events.perf_submit(args, data, data_len);
#else
    bpf_perf_event_output(args, &amp;amp;events, BPF_F_CURRENT_CPU, data, data_len);
#endif
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;bpf程序&quot;&gt;BPF程序&lt;/h4&gt;
&lt;p&gt;所有BPF程序提供的功能都需要通过&lt;code&gt;SEC()&lt;/code&gt;(来自&lt;code&gt;bpf_helpers.h&lt;/code&gt;)宏来自定义section名称，如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;#if !defined(__BCC__)
SEC(&quot;tracepoint/sched/sched_process_exec&quot;)
#endif
int tracepoint__sched__sched_process_exec(
#ifdef __BCC__
    struct tracepoint__sched__sched_process_exec *args
#else
    struct trace_event_raw_sched_process_exec *args
#endif
) {
/* ... */
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这只是一个约定，但如果遵循libbpf的section名称，会有更好的开发体验。期望的名称可以参见&lt;a href=&quot;https://github.com/libbpf/libbpf/blob/master/src/libbpf.c#L6260-L6349&quot; target=&quot;_blank&quot;&gt;此处&lt;/a&gt;(原文中给出的代码行可能不准，参见&lt;code&gt;section_defs&lt;/code&gt;的定义即可)，通常的用法为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;tp/&amp;lt;category&amp;gt;/&amp;lt;name&amp;gt;&lt;/code&gt; 用于Tracepoints;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;kprobe/&amp;lt;func_name&amp;gt;&lt;/code&gt; 用于kprobe ，&lt;code&gt;kretprobe/&amp;lt;func_name&amp;gt;&lt;/code&gt; 用于kretprobe;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;raw_tp/&amp;lt;name&amp;gt;&lt;/code&gt; 用于原始Tracepoint;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cgroup_skb/ingress&lt;/code&gt;, &lt;code&gt;cgroup_skb/egress&lt;/code&gt;，以及整个&lt;code&gt;cgroup/&amp;lt;subtype&amp;gt;&lt;/code&gt; 程序家族。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;tracepoints&quot;&gt;Tracepoints&lt;/h4&gt;
&lt;p&gt;从上面的例子中可以看到，Tracepoint上下文的类型名称略有不同。BCC允许Tracepoint使用&lt;code&gt;tracepoint__&amp;lt;category&amp;gt;__&amp;lt;name&amp;gt;&lt;/code&gt;命名模式。BCC会在编译时自动生成相应的类型。libbpf没有此功能，但幸运的是，内核已经提供了所有Tracepoint数据的类似类型，一般命名为&lt;code&gt;trace_event_raw_&amp;lt;name&amp;gt;&lt;/code&gt;，但有时内核中的少量Tracepoints会重用常用的类型，因此如果上述模式不起作用，则需要在内核源码(或 &lt;code&gt;vmlinux.h&lt;/code&gt;)中查找具体的类型名称。如必须使用&lt;code&gt;struct trace_event_raw_sched_process_template&lt;/code&gt;来代替&lt;code&gt;struct trace_event_raw_sched_process_exit&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在大多数情况下，用于访问tracepoint 上下文数据的代码完全相同，但特殊的可变长度字符串字段除外。对于此类情况，其转换也很直接：&lt;code&gt;data_loc_&amp;lt;some_field&amp;gt;&lt;/code&gt;变为&lt;code&gt;__data_loc_&amp;lt;some_field&amp;gt;&lt;/code&gt;(注意双下划线)即可。&lt;/p&gt;
&lt;h4 id=&quot;kprobes&quot;&gt;Kprobes&lt;/h4&gt;
&lt;p&gt;BCC有很多种方式声明kprobe。实践中，这类BPF程序会接收一个指向&lt;code&gt;struct pt_regs&lt;/code&gt;的指针作为上下文参数，但BCC允许像使用内核函数参数一样给BPF程序传参。使用libbpf的&lt;code&gt;BPF_KPROBE&lt;/code&gt;宏可以获得类似的效果，目前其存在于内核selftest的&lt;code&gt;bpf_trace_helpers.h&lt;/code&gt;头文件中，但后续应该会作为libbpf的一部分(&lt;em&gt;已经是了&lt;/em&gt;)：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;#ifdef __BCC__
int kprobe__acct_collect(struct pt_regs *ctx, long exit_code, int group_dead)
#else
SEC(&quot;kprobe/acct_collect&quot;)
int BPF_KPROBE(kprobe__acct_collect, long exit_code, int group_dead)
#endif
{
    /* BPF code accessing exit_code and group_dead here */
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于有返回值的kprobe，也有对应的宏&lt;code&gt;BPF_KRETPROBE&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;注意：在4.17 内核中，Syscall 函数发生了重命名。从4.17 版本开始，用于Syscall krpobe调用的&lt;code&gt;sys_kill&lt;/code&gt;对应当前的&lt;code&gt;__x64_sys_kill&lt;/code&gt;(在x64系统上，不同的架构具有不同的前缀)。在附加一个kprobe/kretprobe时应该注意这一点。但如果可能的话，尽可能遵循tracepoints。&lt;/p&gt;
&lt;p&gt;如果要开发一个新的，带tracepoint/kprobe/kretprobe的BPF程序，查看新的raw_tp/fentry/fexit 探针，它们提供了更好的性能和易用性(内核5.5开始提供此功能)。&lt;/p&gt;
&lt;h4 id=&quot;在bcc中处理编译时的if&quot;&gt;在BCC中处理编译时的#if&lt;/h4&gt;
&lt;p&gt;在BCC模式中大量使用了预处理&lt;code&gt;#ifdef&lt;/code&gt; 和　&lt;code&gt;#if&lt;/code&gt; 条件。大部分是因为支持不同的内核版本或启用／禁用可选择的逻辑(依赖应用配置)。此外，BCC允许在用户空间侧提供自定义的#&lt;code&gt;define&lt;/code&gt;，在BPF代码编译期间的运行时阶段进行替换。通常用于自定义各种参数。&lt;/p&gt;
&lt;p&gt;不能使用libbpf + BPF CO-RE做类似的事情(通过编译时(compile-time)逻辑)，原因是BPF程序遵循一次编译就可以在所有可能的内核以及应用配置上运行。&lt;/p&gt;
&lt;p&gt;为了处理不同的内核版本，BPF CO-RE支持两种补充机制：&lt;strong&gt;Kconfig externs&lt;/strong&gt; 和 &lt;strong&gt;struct “flavors”&lt;/strong&gt;(在&lt;a href=&quot;https://www.cnblogs.com/charlieroro/p/14206214.html&quot; target=&quot;_blank&quot;&gt;上一篇&lt;/a&gt;博客中有涉及)。通过声明外部变量，BPF代码可以知道处理的内核版本：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;#define KERNEL_VERSION(a, b, c) (((a) &amp;lt;&amp;lt; 16) + ((b) &amp;lt;&amp;lt; 8) + (c))

extern int LINUX_KERNEL_VERSION __kconfig;

if (LINUX_KERNEL_VERSION &amp;lt; KERNEL_VERSION(5, 2, 0)) {
  /* deal with older kernels */
} else {
  /* 5.2 or newer */
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;类似地，可以通过从Kconfig(位于内核的&lt;code&gt;.config&lt;/code&gt;文件中)中抽取类似&lt;code&gt;CONFIG_xxx&lt;/code&gt;的变量来获取内核版本：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;extern int CONFIG_HZ __kconfig;

/* now you can use CONFIG_HZ in calculations */
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通常，如果重命名了一个字段，或将其移入一个子结构体中时，可以通过检查目标内核是否存在该字段来判断是否发生了这种情况。可以通过&lt;code&gt;bpf_core_field_exists(&amp;lt;field&amp;gt;)&lt;/code&gt;实现，如果返回1，则表示目标字段位于目标内核中；返回0则表示不存在内核中。配合struct flavors，可以处理内核结构布局的发生重大变动的情况。下面是一个简短的例子，展示了如何适应 &lt;code&gt;struct kernfs_iattrs&lt;/code&gt;在不同内核版本中的变化：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;/* struct kernfs_iattrs will come from vmlinux.h */

struct kernfs_iattrs___old {
    struct iattr ia_iattr;
};

if (bpf_core_field_exists(root_kernfs-&amp;gt;iattr-&amp;gt;ia_mtime)) {
    data-&amp;gt;cgroup_root_mtime = BPF_CORE_READ(root_kernfs, iattr, ia_mtime.tv_nsec);
} else {
    struct kernfs_iattrs___old *root_iattr = (void *)BPF_CORE_READ(root_kernfs, iattr);
    data-&amp;gt;cgroup_root_mtime = BPF_CORE_READ(root_iattr, ia_iattr.ia_mtime.tv_nsec);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;应用配置&quot;&gt;应用配置&lt;/h4&gt;
&lt;p&gt;BPF CO-RE的办法是使用全局变量自定义程序的行为。全局变量允许用户空间app在BPF程序加载和校验前预配置必要的参数和标志。全局变量可以是可变的或恒定的。常量(只读)最常用于指定一个BPF程序的一次性配置(在程序加载和校验前)。可变的量在BPF程序加载并运行后，可用于BPF程序与其用户空间副本之间的双向数据交换。&lt;/p&gt;
&lt;p&gt;在BPF代码侧，可以使用一个&lt;code&gt;const volatile&lt;/code&gt;全局变量(当用于可变的量时，只需丢弃&lt;code&gt;const volatile&lt;/code&gt;修饰符)声明只读的全局变量。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;const volatile struct {
    bool feature_enabled;
    int pid_to_filter;
} my_cfg = {};
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有如下几点需要重点关注：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;必须指定&lt;code&gt;const volatile&lt;/code&gt;来防止不合时宜的编译器优化(编译器可能并且会错误地采用零值并将其内联到代码中)；&lt;/li&gt;
&lt;li&gt;如果定义了一个可变的(非&lt;code&gt;const&lt;/code&gt;)量时，确保不会被标记为&lt;code&gt;static&lt;/code&gt;：非静态全局变量最好与编译器配合。这种情况下通常不需要&lt;code&gt;volatile&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;变量需要被初始化，否则libbpf会拒绝加载BPF应用。初始值可以为0或其他任意值。这类值作为变量的默认值，除非在控制应用程序中覆盖。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;使用BPF代码中的全局变量很简单：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;if (my_cfg.feature_enabled) {
    /* … */
}

if (my_cfg.pid_to_filter &amp;amp;&amp;amp; pid == my_cfg.pid_to_filter) {
    /* … */
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;全局变量提供了更好的用户体验，并避免了BPF map查询造成的开销。此外，对于不变的量，它们的值是对BPF验证器来说是透明的(众所周知的)，并在程序验证期间将其视为常量。这种方式可以允许BPF校验器精确且高效地消除无用代码分支。&lt;/p&gt;
&lt;p&gt;控制app可以使用BPF skeleton方便地提供这类变量：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;struct &amp;lt;name&amp;gt; *skel = &amp;lt;name&amp;gt;__open();
if (!skel)
    /* handle errors */

skel-&amp;gt;rodata-&amp;gt;my_cfg.feature_enabled = true;
skel-&amp;gt;rodata-&amp;gt;my_cfg.pid_to_filter = 123;

if (&amp;lt;name&amp;gt;__load(skel))
    /* handle errors */
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;只读变量可以在BPF skeleton加载前在用户空间进行设置和修改。一旦加载了BPF程序，则无法在用户空间进行设置和修改。这保证BPF校验器在校验期间将这类变量视为常数，以便更好地移除无效代码。而非常量则可以在BPF skeleton加载之后的整个生命周期中(从BPF和用户空间)进行修改，这些变量可以用于交换可变的配置，状态等等。&lt;/p&gt;
&lt;h3 id=&quot;常见的问题&quot;&gt;常见的问题&lt;/h3&gt;
&lt;p&gt;在运行BPF程序时可能会遇到各种问题。有时只是一个误解，有时是因为BCC和libbpf实现上的差异导致的。下面给出了一些典型的场景，可以帮助更好地进行BCC到BPF CO-RE的转换。&lt;/p&gt;
&lt;h4 id=&quot;全局变量&quot;&gt;全局变量&lt;/h4&gt;
&lt;p&gt;BPF全局变量看起来就像一个用户空间的变量：它们可以在表达式中使用，也可以更新（非const表达式），甚至可以使用它们的地址并传递到辅助函数中。但这是在BPF代码侧有效。在用户空间侧，只能通过&lt;strong&gt;BPF skeletob&lt;/strong&gt;进行读取和更新。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;skel-&amp;gt;rodata&lt;/code&gt; 用于只读变量；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;skel-&amp;gt;bss&lt;/code&gt; 用于初始值为0的可变量；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;skel-&amp;gt;data&lt;/code&gt; 用于初始值非0的可变量。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;可以在用户空间进行读取/更新，这些更新会立即反映到BPF侧。但在用户空间侧，这些变量并不是全局的，它们只是BPF skeleton的&lt;code&gt;rodata&lt;/code&gt;、&lt;code&gt;bss&lt;/code&gt;、或&lt;code&gt;data&lt;/code&gt;的成员，在skeleton 加载期间进行了初始化。因此意味着在BPF代码和用户空间代码中声明完全相同的全局变量将视为完全独立的变量，在任何情况下都不会出现交集。&lt;/p&gt;
&lt;h4 id=&quot;循环展开&quot;&gt;循环展开&lt;/h4&gt;
&lt;p&gt;除非目标内核为5.3以上的版本，否则BPF代码中的所有循环都必须使用&lt;code&gt;#pragma unroll&lt;/code&gt;标识，强制Clang进行循环展开，并消除所有可能的循环控制流：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;#pragma unroll
for (i = 0; i &amp;lt; 10; i++) { ... }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果没有循环展开，或循环没有在固定迭代之后结束，那么会返回一个&quot;back-edge from insn X to Y&quot;的校验器错误，即BPF校验器检测到了一个无限循环(或无法在有限次数的迭代之后结束的循环)。&lt;/p&gt;
&lt;h4 id=&quot;辅助子程序&quot;&gt;辅助子程序&lt;/h4&gt;
&lt;p&gt;如果使用静态辅助函数，则必须将其标记为&lt;code&gt;static __always_inline&lt;/code&gt;(由于当前libbpf的处理限制)：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;static __always_inline unsigned long
probe_read_lim(void *dst, void *src, unsigned long len, unsigned long max)
{
    ...
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从5.5内核开始支持非内联的全局函数，但它们具有与静态函数不同的语义和校验限制，这种情况下，最好也使用内核标记！&lt;/p&gt;
&lt;h4 id=&quot;bpf_printk-调试&quot;&gt;bpf_printk 调试&lt;/h4&gt;
&lt;p&gt;BPF程序没有常规调试器可以用于设置断点，检查变量和BPF maps，以及代码的单步调试等。使用这类工具通常无法确定BPF代码的问题所在。&lt;/p&gt;
&lt;p&gt;这种情况下，使用日志输出是最好的选择。使用&lt;code&gt;bpf_printk(fmt, args...)&lt;/code&gt;打印输出额外的信息来理解发生的事情。该函数接受&lt;code&gt;printf&lt;/code&gt;类的格式，最大支持3个参数。它的使用非常简单，但开销也比较大，不适合用于生产环境，因此仅适用于临时调试：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;char comm[16];
u64 ts = bpf_ktime_get_ns();
u32 pid = bpf_get_current_pid_tgid();

bpf_get_current_comm(&amp;amp;comm, sizeof(comm));
bpf_printk(&quot;ts: %lu, comm: %s, pid: %d\n&quot;, ts, comm, pid);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;日志信息可以从一个特殊的&lt;code&gt;/sys/kernel/debug/tracing/trace_pipe&lt;/code&gt;文件中读取：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ sudo cat /sys/kernel/debug/tracing/trace_pipe
...
      [...] ts: 342697952554659, comm: runqslower, pid: 378
      [...] ts: 342697952587289, comm: kworker/3:0, pid: 320
...
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Wed, 06 Jan 2021 17:01:00 +0000</pubDate>
<dc:creator>charlieroro</dc:creator>
<og:description>BCC和libbpf的转换 本文讲述如何将基于BCC的BPF应用转换为libbpf + BPF CO-RE。BPF CO-RE可以参见上一篇博文。 为什么是libbpf和BPF CO-RE？ 历史上，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/charlieroro/p/14244276.html</dc:identifier>
</item>
<item>
<title>换个角度，聊聊全链路压测 - 老_张</title>
<link>http://www.cnblogs.com/imyalost/p/14244184.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/imyalost/p/14244184.html</guid>
<description>&lt;h2 id=&quot;LPsjr&quot; data-lake-id=&quot;c1b23aacfa2d4e0c74b315323ee55872&quot;&gt;前言&lt;/h2&gt;
&lt;p data-lake-id=&quot;9d662396ed1135e6220cdf254cf2d659&quot;&gt;之前自己也写过好几篇关于全链路压测的文章或者博客，最近看了infoQ上&lt;a href=&quot;https://www.infoq.cn/profile/455FE8F8C3F6C8/publish&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;infoQ-数列科技杨德华&lt;/strong&gt;&lt;/a&gt;的专栏，复盘了下自己以往在全链路压测实施方面的工作，发觉还有很多可以做的更好的地方。&lt;/p&gt;
&lt;p data-lake-id=&quot;9d662396ed1135e6220cdf254cf2d659&quot;&gt;就以这篇文章来做个总结，顺带说说我自己实施全链路压测工作方面的一些收获和经验。&lt;/p&gt;
&lt;p data-lake-id=&quot;fe66b4447d2b442578ee80d408b192af&quot;&gt;18年初：&lt;a href=&quot;https://www.cnblogs.com/imyalost/p/8439910.html&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;聊聊全链路压测&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p data-lake-id=&quot;a3dacc300190435d910a15c6e18da33c&quot;&gt;19年初：&lt;a href=&quot;https://www.cnblogs.com/imyalost/p/10525766.html&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;再谈全链路压测&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p data-lake-id=&quot;5b4c43eecc56235d029ceb816c58677c&quot;&gt;20年初：&lt;a href=&quot;https://www.cnblogs.com/imyalost/p/12524078.html&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;全链路压测探索实践之路&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p data-lake-id=&quot;e60983f7c40e1a6df9a275f47e6c4555&quot;&gt;19年双十一备战：&lt;a href=&quot;https://www.cnblogs.com/imyalost/p/11811142.html&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;全链路压测第一次实践&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p data-lake-id=&quot;216f9498c8c7e59351c558c1e05001a5&quot;&gt;20年618大促总结：&lt;a href=&quot;https://www.cnblogs.com/imyalost/p/13236978.html&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;生产全链路压测实践之道&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p data-lake-id=&quot;ab31d8a68cff48e5254c4d564ad5a910&quot;&gt;20年双11大促总结：&lt;a href=&quot;https://www.cnblogs.com/imyalost/p/14204484.html&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;全链路压测落地和演进之路&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p data-lake-id=&quot;0aa58e36a50cf0e706e51ce9909ca8fd&quot;&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;XmHyL&quot; data-lake-id=&quot;bafda4059ae66a7475d5045cb623f5c3&quot;&gt;观点&lt;/h2&gt;
&lt;p data-lake-id=&quot;7fafdb1ab3ec3555a7047d7e64aa4b08&quot;&gt;很多同学问过我关于全链路压测如何实施落地，如何在生产环境实现的技术问题。&lt;/p&gt;
&lt;p data-lake-id=&quot;7fafdb1ab3ec3555a7047d7e64aa4b08&quot;&gt;这里我想借用上面infoQ专栏大佬的一句话：&lt;strong&gt;&lt;span&gt;生产全链路压测，表面是一个技术工程，实际上是一个很有难度的组织协调项目&lt;/span&gt;&lt;/strong&gt;。&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p data-lake-id=&quot;0b49329486461b0a42fa6ae83d684543&quot;&gt;下面我会从几个方面来谈谈我个人现在对于全链路压测的一些思考和经验总结。&lt;/p&gt;
&lt;p data-lake-id=&quot;96683ade97dd5ee312867d18e5628dd1&quot;&gt; &lt;/p&gt;
&lt;h2 id=&quot;wjDQu&quot; data-lake-id=&quot;de1f1da45305460b6cb6796dd9ed291e&quot;&gt;技术&lt;/h2&gt;
&lt;p data-lake-id=&quot;3551c6465b83f6dcd877760c96fc592f&quot;&gt;很多同学说起全链路压测，都喜欢深究它的技术细节，这没错。&lt;/p&gt;
&lt;p data-lake-id=&quot;3551c6465b83f6dcd877760c96fc592f&quot;&gt;但全链路压测想要成功的在生产环境实施，更多的是考验组织协调能力的一个项目。至于技术层面，能说的有很多，这次我们先聊聊比较核心的一些技术点。&lt;/p&gt;
&lt;h3 id=&quot;oK3Jf&quot; data-lake-id=&quot;41f2a101bb1e999f56d68edb53286410&quot;&gt;隔离方案&lt;/h3&gt;
&lt;h4 id=&quot;ZJiVo&quot; data-lake-id=&quot;322be2ad5b8e6c5e15a90ebe0e79843f&quot;&gt;流量隔离&lt;/h4&gt;
&lt;p data-lake-id=&quot;50837aab58e1d36c3f3d05a58537da4e&quot;&gt;既然我们的前提是在生产环境进行压测，那么无论是趁着业务流量低峰期，还是生产全链路压测常态化，对于压测流量的隔离区分，是一定要首先解决的。如下图所示：&lt;/p&gt;
&lt;p data-lake-id=&quot;570a7568dc74a2366f97430bdc3f06e8&quot;&gt;&lt;span class=&quot;lake-selected&quot; data-card-type=&quot;inline&quot; data-lake-card=&quot;image&quot; data-card-value=&quot;data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F403166%2F1573629693705-70ef3a68-54c1-451f-ab21-34b5c1d8e460.png%3Fx-oss-process%3Dimage%252Fresize%252Cw_393%22%2C%22originWidth%22%3A393%2C%22originHeight%22%3A356%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22style%22%3A%22none%22%2C%22search%22%3A%22%22%2C%22margin%22%3A%7B%22top%22%3Afalse%2C%22bottom%22%3Afalse%7D%2C%22width%22%3A393%2C%22height%22%3A356%7D&quot;&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2019/png/403166/1573629693705-70ef3a68-54c1-451f-ab21-34b5c1d8e460.png?x-oss-process=image%2Fresize%2Cw_393&quot; alt=&quot;image&quot; class=&quot;image lake-drag-image&quot; title=&quot;image&quot; data-role=&quot;image&quot; data-raw-src=&quot;&quot; data-height=&quot;356px&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p data-lake-id=&quot;d0cc602163dad07faf2a1f50da631261&quot;&gt;目前业内比较常见的方案，有如下两种：&lt;/p&gt;
&lt;p data-lake-id=&quot;402a1be08fde5b3f981793fc368b3a8d&quot;&gt;1）中间件改造+流量标透传（业务侵入较多）；&lt;/p&gt;
&lt;p data-lake-id=&quot;76ce4682d706bbccd228e529b171d185&quot;&gt;2）agent+字节码增强技术（业务侵入较低）；&lt;/p&gt;
&lt;p data-lake-id=&quot;4736fa45fa6e8689f1de2b89fd5b97f9&quot;&gt;这两种方案的选型，需要基于研发团队的整体技术栈以及业务迭代情况等因素综合考虑。&lt;/p&gt;
&lt;p data-lake-id=&quot;4736fa45fa6e8689f1de2b89fd5b97f9&quot;&gt;比如我司，采用的是第一种方案：基础架构团队基于spring cloud全家桶二次开发了一套全链路压测框架的脚手架，由业务研发团队接入。&lt;/p&gt;
&lt;h4 id=&quot;mQm6t&quot; data-lake-id=&quot;c97eae40e02249ba19fbe1b482a3b4f9&quot;&gt;资源隔离&lt;/h4&gt;
&lt;p data-lake-id=&quot;f6dcc72f016cce3ee3fceb992703f803&quot;&gt;资源隔离主要指的服务器、Redis、MQ、DB等资源。一般来讲大部分企业的业务都是白天流量较高，凌晨是流量低谷。&lt;/p&gt;
&lt;p data-lake-id=&quot;f6dcc72f016cce3ee3fceb992703f803&quot;&gt;在流量低谷期，直接压测生产的服务，风险相对较小且可控。&lt;/p&gt;
&lt;p data-lake-id=&quot;f6dcc72f016cce3ee3fceb992703f803&quot;&gt;如果生产服务稳定性较好，且能做到按比例资源隔离以及压测流量识别透传，那么第二种方案反而可以考虑。&lt;/p&gt;
&lt;p data-lake-id=&quot;b88acb68419ce0ff36ca4f2114e5a5e8&quot;&gt;且如果要采用资源隔离方案，那么核心链路梳理和区分工作是必须要做的。&lt;/p&gt;
&lt;p data-lake-id=&quot;b88acb68419ce0ff36ca4f2114e5a5e8&quot;&gt;区分核心和非核心业务，核心业务分级（P0/P1/P2），由小及大的不断覆盖。&lt;/p&gt;
&lt;h4 id=&quot;bmQMY&quot; data-lake-id=&quot;10096c1507c9192762efcf9ad4d96778&quot;&gt;数据隔离&lt;/h4&gt;
&lt;p data-lake-id=&quot;ee47fde1206f1be4293e21d3b86f0361&quot;&gt;压测会产生大量的数据，这些数据如何处理是DBA团队面临的最大挑战。&lt;/p&gt;
&lt;p data-lake-id=&quot;ee47fde1206f1be4293e21d3b86f0361&quot;&gt;目前来说，业内比较通用的方式都是采用影子库表或者压测数据带特殊标识进入生产业务库表，以tag或者特殊字段做区分。他们的区别如下：&lt;/p&gt;
&lt;p data-lake-id=&quot;af7898a2d7be756dfc9306c3a3e42750&quot;&gt;1）影子库+影子表：一般生产库和影子库都是在同一个DB实例上，基础数据会脱敏后同步过去；&lt;/p&gt;
&lt;p data-lake-id=&quot;45a9c781a6ffcc7996e3e86cfdda59bb&quot;&gt;2）生产业务表标识：在生产业务表中新增压测标识字段，压测数据需要定时清理（饿了么采用这套方案）；&lt;/p&gt;
&lt;p data-lake-id=&quot;df73d8ed1d9839521ab8979a7d341188&quot;&gt;我司采用的方案如下：&lt;/p&gt;
&lt;p data-lake-id=&quot;17c454622e1a28daf7249dac06a02b02&quot;&gt;&lt;span class=&quot;lake-fontsize-11&quot;&gt;DB路由：①.同instance不同schema（风险大）；②.不同instance同schema（安全性高，成本高）；&lt;/span&gt;&lt;/p&gt;
&lt;p data-lake-id=&quot;a0eac40d3e12fcaec6f37208780e283d&quot;&gt;&lt;span class=&quot;lake-fontsize-11&quot;&gt;Redis路由：①.key值加统一前缀；②.Redis-client做路由；&lt;/span&gt;&lt;/p&gt;
&lt;p data-lake-id=&quot;a9c7bdc9561fd3499ba699a197990618&quot;&gt;&lt;span class=&quot;lake-fontsize-11&quot;&gt;MQ路由：采用影子topic模式，带压测标识的数据进入影子topic；&lt;/span&gt;&lt;/p&gt;
&lt;p data-lake-id=&quot;3875dc4980542fb1d579b98fbc80021a&quot;&gt;&lt;span class=&quot;lake-fontsize-11&quot;&gt;ES路由：①.index统一加前缀，提供统一ES client做数据访问，由client做路由；&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&quot;MRqJs&quot; data-lake-id=&quot;54928b5dea5f4703860f2d97074af0c4&quot;&gt;日志隔离&lt;/h4&gt;
&lt;p data-lake-id=&quot;d25ec6af84f035c6ac6f79336f02a61e&quot;&gt;压测会产生大量日志，为了便于正常的业务问题跟进排查和压测区分，个人建议还是对带压测标的日志进行前缀处理，这样运维同学也可以快速的清理，以免磁盘写满导致生产故障。&lt;/p&gt;
&lt;p data-lake-id=&quot;514812cfced1474216aa9368c70aae36&quot;&gt; &lt;/p&gt;
&lt;h3 id=&quot;yJXm0&quot; data-lake-id=&quot;131f73aa942dc3b08a9d00f687fa679c&quot;&gt;改造工作&lt;/h3&gt;
&lt;h4 id=&quot;VwSYp&quot; data-lake-id=&quot;5e77b0041acff837d5acf41428417d41&quot;&gt;监控平台&lt;/h4&gt;
&lt;p data-lake-id=&quot;1fa47b1aa8ade8e82e92ddf32d6d0fe4&quot;&gt;监控系统需要透明化，且压测监控大盘和业务监控大盘需要单独配置。其中有如下的点需要注意：&lt;/p&gt;
&lt;p data-lake-id=&quot;486b52a2d4817f725decdaecbfe1dbcf&quot;&gt;1）设定告警阈值、告警降噪、专项业务告警；&lt;/p&gt;
&lt;p data-lake-id=&quot;3bfdcd6e6e2ff184ffee53fede2aa7ca&quot;&gt;2）专项告警，需要覆盖核心接口、监控大盘、业务大盘；&lt;/p&gt;
&lt;p data-lake-id=&quot;8a4d9bd4686f9f8d38d8bc355b36af4f&quot;&gt;3）优点：问题快速定位，避免不透明影响问题的发现和修复速率；&lt;/p&gt;
&lt;p data-lake-id=&quot;6773f4a499f4c2b8ddf9c68fd53324a2&quot;&gt;4）容量规划：借助监控平台的赋能，快速梳理清楚系统架构、拓扑关系，才便于做容量规划；&lt;/p&gt;
&lt;h4 id=&quot;cYCTW&quot; data-lake-id=&quot;5162277a6f19d325ab2b1521e6456d40&quot;&gt;流控平台&lt;/h4&gt;
&lt;p data-lake-id=&quot;c01b65ba4892698c550159d6806a90fe&quot;&gt;流量发起和服务保护功能是全链路压测成功开展的必要前提。服务保护方面，业内常用的组件有Sentinel、Hystrix，他们一般都是基于线程池/信号量来进行流控。&lt;/p&gt;
&lt;h4 id=&quot;KoFOY&quot; data-lake-id=&quot;e1aa20f88eb980fff6124240a4c792fc&quot;&gt;预案平台&lt;/h4&gt;
&lt;p data-lake-id=&quot;4ce60d9900ce84e6ea157195a427fa28&quot;&gt;常说大促时候，&lt;span&gt;&lt;strong&gt;服务稳定性有三大利器：限流、熔断和降级&lt;/strong&gt;&lt;/span&gt;。前面介绍了流控（限流和熔断），那么降级是什么呢？按照我个人的经验，降级预案一般分为主动降级和紧急降级。&lt;/p&gt;
&lt;p data-lake-id=&quot;eceaba0663bd37a26cb48dc6af0ec683&quot;&gt;主动降级：商品首页缓存&amp;amp;数据兜底、小红点、客户端限流浮层、重试机制等；&lt;/p&gt;
&lt;p data-lake-id=&quot;fc5e91146faec1616f99bc2e0515153a&quot;&gt;紧急降级：收货地址、浮动费率、运费计算、运营位固定等方案；&lt;/p&gt;
&lt;p data-lake-id=&quot;faf3dc3340ea98bca583e04bda830997&quot;&gt;当然，无论是主动降级方案还是紧急降级方案，都是需要进行业务梳理和细化拆分的，还要和产品运营等团队的同学提前沟通好，避免跨团队沟通的Gap产生。&lt;/p&gt;
&lt;p data-lake-id=&quot;e9e2d6f1610867a69cfad3d95b690c95&quot;&gt;还有些前置事项，比如业务拆分（订单拆分为正逆向），比如不同业务服务集群隔离，比如DB垂直拆分、读写分离、分库分表等方案，这些都是需要考虑的。&lt;/p&gt;
&lt;p data-lake-id=&quot;8b756240b268d01aed2fbd4a88dccd16&quot;&gt;至于异地多活、故障演练、灾备演练，这些更需要成熟的技术体系建设和多方达成一致，才能更好的保障生产服务的稳定性。总的来说，全链路压测除了技术，更多的还需要沟通与协调。&lt;/p&gt;
&lt;p data-lake-id=&quot;73f58d2b947dfd0e72333969cf20a0ed&quot;&gt; &lt;/p&gt;
&lt;h3 id=&quot;Z5NnL&quot; data-lake-id=&quot;99e49d9995be7ae649e2642e44655e4c&quot;&gt;压测实施&lt;/h3&gt;
&lt;p data-lake-id=&quot;c423c10ff6701671917a0227171f67aa&quot;&gt;到了压测实施阶段，基本就只能硬着头皮硬上了，特别是第一次搞生产全链路压测，至今记忆深刻。生产全链路压测，需要注意以下几点：&lt;/p&gt;
&lt;h4 id=&quot;IgaaS&quot; data-lake-id=&quot;fd53c36ff22980132e20b8d76b8da2bd&quot;&gt;服务扩容&lt;/h4&gt;
&lt;p data-lake-id=&quot;85bed012ef29d1740fbb05020b010558&quot;&gt;需要注意的是，在生产开始压测前，系统需要进行前置扩容，避免资源不足导致整体容量瓶颈。还需要注意的是，在大促峰值流量来临时，尽可能不要去执行扩容操作。&lt;/p&gt;
&lt;h4 id=&quot;LoJdq&quot; data-lake-id=&quot;15bbd5188a04c36b84847a924ed8875e&quot;&gt;压测方式&lt;/h4&gt;
&lt;p data-lake-id=&quot;65c293c2c4194d9cfa1aa9f33e1773a9&quot;&gt;至于压测执行方式，业内能玩的基本就是这几种方式。当然，压测前的预热，是必不可少的。压测执行方式方面，主要有如下几项：&lt;/p&gt;
&lt;p data-lake-id=&quot;0af6f405ba59b319bf7b49eacfff72ac&quot;&gt;1）阶梯递增：这种方式的目的在于不断递增流量，找到系统的性能拐点；&lt;/p&gt;
&lt;p data-lake-id=&quot;463e5beee990d8e93add2841efd8de20&quot;&gt;2）峰值脉冲：有些特殊场景，需要区分流量是逐渐变大，还是骤升后保持高峰；&lt;/p&gt;
&lt;p data-lake-id=&quot;0f42326494cab53e96ded0c27e49b95d&quot;&gt;3）系统摸高：关闭熔断降级限流等fallback功能，提高压测流量观察系统性能转折点；&lt;/p&gt;
&lt;p data-lake-id=&quot;b3409ccbbcd8876151961b6d4aba0101&quot;&gt;4）预案验证：开启熔断限流等fallback功能，功能是否生效，系统是否能扛得住；&lt;/p&gt;
&lt;p data-lake-id=&quot;680387bd9281b601faed21dc4ef9686f&quot;&gt;5）破坏性测试：主要为了验证预案的有效性，类似于容灾演练时的预案执行演练，验证后手抢救方案。&lt;/p&gt;
&lt;p data-lake-id=&quot;0da0da908162d789d46b61fe0397ad2e&quot;&gt;注意：&lt;span&gt;&lt;strong&gt;执行第4/5项时，建议进行生产业务的功能正确性验证！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&quot;21xgk&quot; data-lake-id=&quot;6340fb24203ab32af8645390d824cc5b&quot;&gt;预案评审&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p data-lake-id=&quot;1338a996387836e403e3791a8d4b15ed&quot;&gt;在预案评审和演练阶段，进行预案演练的目的主要有如下几项：&lt;/p&gt;
&lt;p data-lake-id=&quot;6dff38b511552f554371ad2f6558ae9c&quot;&gt;1）验证预案是否生效；&lt;/p&gt;
&lt;p data-lake-id=&quot;59cac47df38502597bc62b86de388771&quot;&gt;2）针对预案设定阈值进行测试调优；&lt;/p&gt;
&lt;p data-lake-id=&quot;40062e05537c563804d517da8a629573&quot;&gt;3）验证预案生效时服务本身的性能表现；&lt;/p&gt;
&lt;p data-lake-id=&quot;a5f2918aa59d0f82d39e7864457e1bd7&quot;&gt;4）针对上述专项场景进行实战演练；&lt;/p&gt;
&lt;p data-lake-id=&quot;3f9a22af2c16836b2cd4152de512d64e&quot;&gt;建议：按照我个人的实施经验，建议输出对应的&lt;span&gt;&lt;strong&gt;全链路压测SOP&amp;amp;大促作战SOP&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p data-lake-id=&quot;dd6557f03d102792ade6140cf4cd019f&quot;&gt; &lt;/p&gt;
&lt;h2 id=&quot;Q2x6z&quot; data-lake-id=&quot;7501e1f503283b232e61930677cadcb6&quot;&gt;管理&lt;/h2&gt;
&lt;p data-lake-id=&quot;b9707999b240fff864f291d1d1430761&quot;&gt;前面关于全链路压测的观点，已经提到了：&lt;strong&gt;&lt;span&gt;生产全链路压测，表面是一个技术工程，实际上是一个很有难度的组织协调项目&lt;/span&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;p data-lake-id=&quot;b9707999b240fff864f291d1d1430761&quot;&gt;从管理的角度出发，下面三项是管理者或者项目推动者应该高度重视的。&lt;/p&gt;
&lt;h3 id=&quot;fSRMj&quot; data-lake-id=&quot;1fccac66bcb0923cdf1c27cf83e3976f&quot;&gt;目标&lt;/h3&gt;
&lt;p data-lake-id=&quot;d2326b3bc7fc76ae3d932f3464d669ef&quot;&gt;大家应该都了解SMART体系，在考虑实施全链路压测时候，下面几点SMART目标，也是需要重点考虑的。&lt;/p&gt;
&lt;p data-lake-id=&quot;2aaaac5066eba255e57ed3d3369af33f&quot;&gt;目标与标准：SMART5大元素&lt;/p&gt;
&lt;p data-lake-id=&quot;8035d2af8817d8cea70edef135c6d0e8&quot;&gt;1）目标必须是具体的（Specific）——业务指标、技术指标、容量指标等；&lt;/p&gt;
&lt;p data-lake-id=&quot;588dd4b53b37a9b6c9f0799c5d8df4d1&quot;&gt;2）目标必须是可以衡量的（Measurable）——从不同的维度和数据来评估；&lt;/p&gt;
&lt;p data-lake-id=&quot;e936beb0f06fad9b053aadd8b0617357&quot;&gt;3）目标必须是可以达到的（Attainable）——不要设定过高的脱离现实的目标；&lt;/p&gt;
&lt;p data-lake-id=&quot;4eaa26474ef42fb3c5587a249e52da79&quot;&gt;4）目标必须和其他目标具在相关性（Relevant）——对业务以及技术团队有什么价值；&lt;/p&gt;
&lt;p data-lake-id=&quot;eb355c792e159dd84d681bbb87ced75f&quot;&gt;5）目标必须说明明确的截止期限（Time-based）——根据日期和任务资源倒排期，保障项目成功；&lt;/p&gt;
&lt;h3 id=&quot;KaITm&quot; data-lake-id=&quot;19d1af4111efc68f42e094c209c590f6&quot;&gt;流程&lt;/h3&gt;
&lt;p data-lake-id=&quot;fb027926ac15a5a214667fbec9975137&quot;&gt;总结一下，生产全链路压测这个技术项目，可以用三个维度和五个阶段来概括。&lt;/p&gt;
&lt;p data-lake-id=&quot;57d810199b71fdd361ea69ec58b5757d&quot;&gt;五个阶段：准备阶段、执行阶段、故障修复、项目复盘、项目结项；&lt;/p&gt;
&lt;p data-lake-id=&quot;211e4e81026fffb77ddb8dedde1f6a41&quot;&gt;三个维度：做什么、风险如何处理、事项review（保持信息同步）。&lt;/p&gt;
&lt;h3 id=&quot;jogiF&quot; data-lake-id=&quot;0e39027c4e5e775fcac7e28784a802fe&quot;&gt;组织&lt;/h3&gt;
&lt;p data-lake-id=&quot;8026aed23cf095a04d2c968b69f996b1&quot;&gt;日常工作中，我们一般有版本迭代的常规需求以及一些特殊的独立项目。非业务或者弱业务的事情，可以通过虚拟的组织架构来明确定义不同岗位的职责，避免混乱。&lt;/p&gt;
&lt;p data-lake-id=&quot;3ad15a71192b6ddc67b3b71391a8cfda&quot;&gt;一般来说，生产全链路压测中，虚拟的组织架构一般有如下几种角色：&lt;/p&gt;
&lt;p data-lake-id=&quot;295371332b545231adcaa691109d039d&quot;&gt;&lt;strong&gt;Sponsor&lt;/strong&gt;：发起&amp;amp;组织人；&lt;/p&gt;
&lt;p data-lake-id=&quot;5a866bba722601a687da64eb79d019e0&quot;&gt;&lt;strong&gt;PMO&lt;/strong&gt;：项目管理、项目经理；&lt;/p&gt;
&lt;p data-lake-id=&quot;246a7a2a3b6296da214c65938f9c3436&quot;&gt;&lt;strong&gt;Principal&lt;/strong&gt;：（主）负责人；&lt;/p&gt;
&lt;p data-lake-id=&quot;12575340f22ebf4787849ae504be627c&quot;&gt;&lt;strong&gt;Owner&lt;/strong&gt;：业务&amp;amp;技术某一领域负责人（领头人）；&lt;/p&gt;
&lt;p data-lake-id=&quot;12575340f22ebf4787849ae504be627c&quot;&gt;&lt;img alt=&quot;&quot;/&gt;&lt;span class=&quot;lake-card-margin-top lake-card-margin-bottom lake-selected&quot; data-card-type=&quot;inline&quot; data-lake-card=&quot;image&quot; data-card-value=&quot;data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2021%2Fpng%2F403166%2F1609948145179-7fdd66c6-1861-44b8-afec-f2e92c3d3165.png%22%2C%22originWidth%22%3A1215%2C%22originHeight%22%3A604%2C%22name%22%3A%22image.png%22%2C%22size%22%3A50274%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22ocrLocations%22%3A%5B%7B%22x%22%3A546.4833%2C%22y%22%3A37.119183%2C%22width%22%3A44.41489999999999%2C%22height%22%3A10.977397000000003%2C%22text%22%3A%22Sponsor%22%7D%2C%7B%22x%22%3A288.62155%2C%22y%22%3A147.60716%2C%22width%22%3A30.12518%2C%22height%22%3A12.399609999999996%2C%22text%22%3A%22PMO%22%7D%2C%7B%22x%22%3A793.0449%2C%22y%22%3A149.97823%2C%22width%22%3A52.24739999999997%2C%22height%22%3A12.990890000000007%2C%22text%22%3A%22Principal%22%7D%2C%7B%22x%22%3A740.3989%2C%22y%22%3A259.8063%2C%22width%22%3A78.79147%2C%22height%22%3A17.52127999999999%2C%22text%22%3A%22%E7%A8%B3%E5%AE%9A%E6%80%A7Qwner%22%7D%2C%7B%22x%22%3A117.51802%2C%22y%22%3A267.55008%2C%22width%22%3A63.40192999999999%2C%22height%22%3A14.087280000000021%2C%22text%22%3A%22%E4%B8%9A%E5%8A%A1OwwneR%22%7D%2C%7B%22x%22%3A967.79346%2C%22y%22%3A339.94635%2C%22width%22%3A30.484370000000013%2C%22height%22%3A16.756070000000022%2C%22text%22%3A%22%E7%94%A8%E6%88%B7%22%7D%2C%7B%22x%22%3A414.16998%2C%22y%22%3A340.04984%2C%22width%22%3A29.307469999999967%2C%22height%22%3A16.006129999999985%2C%22text%22%3A%22%E8%90%A5%E9%94%80%22%7D%2C%7B%22x%22%3A210.07838%2C%22y%22%3A340.4989%2C%22width%22%3A28.711669999999998%2C%22height%22%3A16.677999999999997%2C%22text%22%3A%22%E5%A2%9E%E9%95%BF%22%7D%2C%7B%22x%22%3A602.7969%2C%22y%22%3A340.67%2C%22width%22%3A53.41679999999997%2C%22height%22%3A16.40440000000001%2C%22text%22%3A%22%E8%AE%A2%E5%8D%95%E6%AD%A3%E5%90%91%22%7D%2C%7B%22x%22%3A803.1633%2C%22y%22%3A341.0729%2C%22width%22%3A27.122099999999932%2C%22height%22%3A14.694219999999973%2C%22text%22%3A%22%E5%8E%8B%E6%B5%8B%22%7D%2C%7B%22x%22%3A1136.0544%2C%22y%22%3A341.1849%2C%22width%22%3A27.876999999999953%2C%22height%22%3A14.889599999999973%2C%22text%22%3A%22%E9%99%90%E6%B5%81%22%7D%2C%7B%22x%22%3A52.93727%2C%22y%22%3A341.9291%2C%22width%22%3A28.679450000000003%2C%22height%22%3A15.775759999999991%2C%22text%22%3A%22%E8%90%A5%E9%94%80%22%7D%2C%7B%22x%22%3A413.0557%2C%22y%22%3A400.00604%2C%22width%22%3A29.69240000000002%2C%22height%22%3A16.981629999999996%2C%22text%22%3A%22%E5%A2%9E%E9%95%BF%22%7D%2C%7B%22x%22%3A804.07733%2C%22y%22%3A400.63562%2C%22width%22%3A27.862610000000018%2C%22height%22%3A15.288419999999974%2C%22text%22%3A%22%E7%BD%91%E5%85%B3%22%7D%2C%7B%22x%22%3A971.2611%2C%22y%22%3A400.97818%2C%22width%22%3A29.257999999999925%2C%22height%22%3A15.545379999999966%2C%22text%22%3A%22%E9%A3%8E%E6%8E%A7%22%7D%2C%7B%22x%22%3A603.2167%2C%22y%22%3A401.2381%2C%22width%22%3A52.699800000000096%2C%22height%22%3A15.062280000000044%2C%22text%22%3A%22%E8%AE%A2%E5%8D%95%E9%80%86%E5%90%91%22%7D%2C%7B%22x%22%3A1133.8527%2C%22y%22%3A401.40424%2C%22width%22%3A27.22090000000003%2C%22height%22%3A15.403930000000003%2C%22text%22%3A%22%E8%BF%90%E7%BB%B4%22%7D%2C%7B%22x%22%3A410.14447%2C%22y%22%3A455.8876%2C%22width%22%3A31.472109999999986%2C%22height%22%3A18.77157999999997%2C%22text%22%3A%22%E7%AE%97%E6%B3%95%22%7D%2C%7B%22x%22%3A791.26434%2C%22y%22%3A456.73605%2C%22width%22%3A52.91386%2C%22height%22%3A16.38480000000004%2C%22text%22%3A%22%E5%8E%8B%E6%B5%8B%E5%B9%B3%E5%8F%B0%22%7D%2C%7B%22x%22%3A969.4534%2C%22y%22%3A457.52344%2C%22width%22%3A28.154449999999997%2C%22height%22%3A16.136779999999987%2C%22text%22%3A%22%E5%95%86%E5%AE%B6%22%7D%2C%7B%22x%22%3A614.6523%2C%22y%22%3A459.07288%2C%22width%22%3A30.596200000000067%2C%22height%22%3A14.325249999999983%2C%22text%22%3A%22%E5%BA%93%E5%AD%98%22%7D%2C%7B%22x%22%3A1136.8389%2C%22y%22%3A459.5121%2C%22width%22%3A25.907899999999927%2C%22height%22%3A12.251330000000053%2C%22text%22%3A%22DBA%22%7D%2C%7B%22x%22%3A1133.3245%2C%22y%22%3A512.8176%2C%22width%22%3A28.738900000000058%2C%22height%22%3A15.723100000000045%2C%22text%22%3A%22%E7%9F%AD%E4%BF%A1%22%7D%2C%7B%22x%22%3A412.26328%2C%22y%22%3A513.1895%2C%22width%22%3A28.781090000000006%2C%22height%22%3A15.057500000000005%2C%22text%22%3A%22%E5%95%86%E5%93%81%22%7D%2C%7B%22x%22%3A613.5539%2C%22y%22%3A513.554%2C%22width%22%3A32.18690000000004%2C%22height%22%3A16.858839999999987%2C%22text%22%3A%22%E6%94%AF%E4%BB%98%22%7D%2C%7B%22x%22%3A790.3622%2C%22y%22%3A514.3902%2C%22width%22%3A55.41139999999996%2C%22height%22%3A15.337769999999978%2C%22text%22%3A%22%E7%9B%91%E6%8E%A7%E5%91%8A%E8%AD%A6%22%7D%2C%7B%22x%22%3A963.42017%2C%22y%22%3A514.4765%2C%22width%22%3A41.871579999999994%2C%22height%22%3A14.820900000000051%2C%22text%22%3A%22%E4%BE%9B%E5%BA%94%E9%93%BE%22%7D%2C%7B%22x%22%3A398.88864%2C%22y%22%3A569.3839%2C%22width%22%3A55.270159999999976%2C%22height%22%3A16.215649999999982%2C%22text%22%3A%22%E6%95%B0%E6%8D%AE%E5%A4%A7%E5%B1%8F%22%7D%2C%7B%22x%22%3A1119.3054%2C%22y%22%3A569.9847%2C%22width%22%3A54.29510000000005%2C%22height%22%3A15.262699999999995%2C%22text%22%3A%22%E5%8F%91%E5%B8%83%E5%B9%B3%E5%8F%B0%22%7D%5D%2C%22style%22%3A%22none%22%2C%22search%22%3A%22Sponsor%20PMO%20Principal%20%E7%A8%B3%E5%AE%9A%E6%80%A7Qwner%20%E4%B8%9A%E5%8A%A1OwwneR%20%E7%94%A8%E6%88%B7%20%E8%90%A5%E9%94%80%20%E5%A2%9E%E9%95%BF%20%E8%AE%A2%E5%8D%95%E6%AD%A3%E5%90%91%20%E5%8E%8B%E6%B5%8B%20%E9%99%90%E6%B5%81%20%E8%90%A5%E9%94%80%20%E5%A2%9E%E9%95%BF%20%E7%BD%91%E5%85%B3%20%E9%A3%8E%E6%8E%A7%20%E8%AE%A2%E5%8D%95%E9%80%86%E5%90%91%20%E8%BF%90%E7%BB%B4%20%E7%AE%97%E6%B3%95%20%E5%8E%8B%E6%B5%8B%E5%B9%B3%E5%8F%B0%20%E5%95%86%E5%AE%B6%20%E5%BA%93%E5%AD%98%20DBA%20%E7%9F%AD%E4%BF%A1%20%E5%95%86%E5%93%81%20%E6%94%AF%E4%BB%98%20%E7%9B%91%E6%8E%A7%E5%91%8A%E8%AD%A6%20%E4%BE%9B%E5%BA%94%E9%93%BE%20%E6%95%B0%E6%8D%AE%E5%A4%A7%E5%B1%8F%20%E5%8F%91%E5%B8%83%E5%B9%B3%E5%8F%B0%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%2C%22width%22%3A1215%2C%22height%22%3A604%7D&quot;&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2021/png/403166/1609948145179-7fdd66c6-1861-44b8-afec-f2e92c3d3165.png&quot; alt=&quot;image.png&quot; width=&quot;1049&quot; height=&quot;521&quot; class=&quot;image lake-drag-image&quot; title=&quot;image.png&quot; data-role=&quot;image&quot; data-raw-src=&quot;&quot; data-height=&quot;604px&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p data-lake-id=&quot;d876b32119305b53be2629073d3dd13b&quot;&gt; &lt;/p&gt;
&lt;h2 id=&quot;s3IyH&quot; data-lake-id=&quot;850cbb19abea5e628d88783209812527&quot;&gt;价值&lt;/h2&gt;
&lt;p data-lake-id=&quot;25a6415a6b8c82cb6e64ed69e5244cb4&quot;&gt;最开始我司推动实施全链路压测时，我画了下面这张图，用来体现全链路压测的价值：&lt;/p&gt;
&lt;p data-lake-id=&quot;e072a3d798b3600678747d55d40c7acc&quot;&gt;&lt;span class=&quot;lake-selected&quot; data-card-type=&quot;inline&quot; data-lake-card=&quot;image&quot; data-card-value=&quot;data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F403166%2F1574164370117-f138ac80-f5a6-4bb9-a864-b0f6df978985.png%22%2C%22originWidth%22%3A517%2C%22originHeight%22%3A367%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22style%22%3A%22none%22%2C%22search%22%3A%22%22%2C%22margin%22%3A%7B%22top%22%3Afalse%2C%22bottom%22%3Afalse%7D%2C%22width%22%3A517%2C%22height%22%3A367%7D&quot;&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2019/png/403166/1574164370117-f138ac80-f5a6-4bb9-a864-b0f6df978985.png&quot; alt=&quot;image&quot; class=&quot;image lake-drag-image&quot; title=&quot;image&quot; data-role=&quot;image&quot; data-raw-src=&quot;&quot; data-height=&quot;367px&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p data-lake-id=&quot;8b96d489368459badc6e87f433e9f4d7&quot;&gt;从我个人角度来说，全链路压测的最大价值在于：&lt;/p&gt;
&lt;p data-lake-id=&quot;f87742b7dfc2917c635d8c24ba088faa&quot;&gt;1）成本：降低环境成本，人力成本（不断实践，投入的人力越来越少）；&lt;/p&gt;
&lt;p data-lake-id=&quot;f62f90a8727c1fafd3fc89156faa9f6a&quot;&gt;2）问题：提前发现大流量下系统潜在的隐患，提升系统稳定性；&lt;/p&gt;
&lt;p data-lake-id=&quot;9c4a395f6b995a8229c57a18f91f3ad8&quot;&gt;3）容量：提升性能，识别短板，机器配比有了明确的数值，避免不必要的冗余；&lt;/p&gt;
&lt;p data-lake-id=&quot;fb56307692b0f17854fbb0a6e8eabdb6&quot;&gt;4）限流：倒逼各个服务&amp;amp;系统进行限流降级等服务稳定性保障措施，预案验证演练；&lt;/p&gt;
&lt;p data-lake-id=&quot;e8ebd827351e0740c48068262479683f&quot;&gt;5）ROI：降低沟通成本，团队练兵协调组织能力提升，形成自己的一些技术规范和手册；&lt;/p&gt;
&lt;p data-lake-id=&quot;e8ebd827351e0740c48068262479683f&quot;&gt; &lt;/p&gt;
</description>
<pubDate>Wed, 06 Jan 2021 15:58:00 +0000</pubDate>
<dc:creator>老_张</dc:creator>
<og:description>前言 之前自己也写过好几篇关于全链路压测的文章或者博客，最近看了infoQ上infoQ-数列科技杨德华的专栏，复盘了下自己以往在全链路压测实施方面的工作，发觉还有很多可以做的更好的地方。 就以这篇文章</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/imyalost/p/14244184.html</dc:identifier>
</item>
</channel>
</rss>