<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Python-使用tkinter实现的摇骰子小游戏 - Colliventy</title>
<link>http://www.cnblogs.com/ywfft/p/a20200702.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ywfft/p/a20200702.html</guid>
<description>&lt;p&gt;贴吧看到的一个求助题，大致需求是：3个人摇骰子，每人摇3次，点数之和最大的获胜，支持玩家名称输入。我觉得这个题目挺有意思的，做了个界面程序，欢迎大家交流指正~&lt;/p&gt;&lt;div readability=&quot;123&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;!usr/bin/env python&lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; -*- coding: utf-8 -*-&lt;/span&gt;
&lt;span&gt;  3&lt;/span&gt; 
&lt;span&gt;  4&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; author: ***&lt;/span&gt;
&lt;span&gt;  5&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; date: 2020/06/10&lt;/span&gt;
&lt;span&gt;  6&lt;/span&gt; 
&lt;span&gt;  7&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; tkinter &lt;span&gt;import&lt;/span&gt; *
&lt;span&gt;  8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; tkinter as tk
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; random
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; threading &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Thread
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt; 
&lt;span&gt; 13&lt;/span&gt; root =&lt;span&gt; Tk()
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt; root.geometry(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;620x660&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt; root.title(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;摇骰子&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt; sigpic = PhotoImage(file=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;signature.png&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt; shake_cup = PhotoImage(file=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;touzi/box.png&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt; crown = PhotoImage(file=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;touzi/win.png&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt; readystate = 3
&lt;span&gt; 20&lt;/span&gt; playing =&lt;span&gt; False
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt; used_name =&lt;span&gt; set()
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt; result_dict =&lt;span&gt; dict()
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt; remain = 3
&lt;span&gt; 24&lt;/span&gt; esv_A =&lt;span&gt; StringVar()
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt; esv_B =&lt;span&gt; StringVar()
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt; esv_C =&lt;span&gt; StringVar()
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt; 
&lt;span&gt; 28&lt;/span&gt; pi_list =&lt;span&gt; list()
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(1, 7&lt;span&gt;):
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt;     pi = PhotoImage(file=r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;touzi/t%s.png&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; i)
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt; &lt;span&gt;    pi_list.append(pi)
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt; 
&lt;span&gt; 33&lt;/span&gt; 
&lt;span&gt; 34&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; set_name(cw, ew, nw):
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt;     &lt;span&gt;global&lt;/span&gt;&lt;span&gt; readystate
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt;     entryV =&lt;span&gt; ew.get()
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; entryV:
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; entryV &lt;span&gt;in&lt;/span&gt;&lt;span&gt; used_name:
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt;             default = nw[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt;             nw.config(text=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;名称已存在！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt;             cw.config(state=&lt;span&gt;tk.DISABLED)
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt; &lt;span&gt;            font_shake(nw, default)
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt;             cw.config(state=&lt;span&gt;tk.ACTIVE)
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt; &lt;span&gt;            used_name.add(entryV)
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt;             nw.config(text=&lt;span&gt;entryV)
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt;             ew.config(state=&lt;span&gt;tk.DISABLED)
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt;             cw.config(state=&lt;span&gt;tk.DISABLED)
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt;             readystate -= 1
&lt;span&gt; 50&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; readystate ==&lt;span&gt; 0:
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ABC&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt;             eval(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;play_btn_%s.config(state=tk.ACTIVE, text=&quot;第一次机会&quot;)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; i)
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt; 
&lt;span&gt; 54&lt;/span&gt; 
&lt;span&gt; 55&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; throw_touzi(pw, rw, nw):
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt;     &lt;span&gt;global&lt;/span&gt;&lt;span&gt; playing
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt;     &lt;span&gt;global&lt;/span&gt;&lt;span&gt; remain
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; pw[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]==&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;第一次机会&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt;         playing =&lt;span&gt; True
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt; &lt;span&gt;        pbStack.remove(pw)
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; widget &lt;span&gt;in&lt;/span&gt;&lt;span&gt; pbStack:
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt;             widget.config(state=&lt;span&gt;tk.DISABLED)
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt;         pw.config(state=tk.DISABLED, text=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;第二次机会&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt;     &lt;span&gt;elif&lt;/span&gt; pw[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]==&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;第二次机会&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt;         pw.config(state=tk.DISABLED, text=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;第三次机会&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt;         playing =&lt;span&gt; False
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt;         remain -= 1
&lt;span&gt; 69&lt;/span&gt;         pw.config(state=tk.DISABLED, text=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;play&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt;     thread = Thread(target=change_img, args=&lt;span&gt;[pw, rw, nw])
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt; &lt;span&gt;    thread.start()
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt; 
&lt;span&gt; 73&lt;/span&gt; 
&lt;span&gt; 74&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; change_img(pw, rw, nw):
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt;     result_number = random.randint(1, 6&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt;     ranum_list =&lt;span&gt; list()
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt;     times = 5
&lt;span&gt; 78&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;&lt;span&gt; times:
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt;         ranum = random.randint(1, 6&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; ranum &lt;span&gt;not&lt;/span&gt; &lt;span&gt;in&lt;/span&gt;&lt;span&gt; ranum_list:
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt; &lt;span&gt;            ranum_list.append(ranum)
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt;             times = times - 1
&lt;span&gt; 83&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; ranum_list:
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt;         time.sleep(0.3&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt;         throw_label.config(image=pi_list[i-1&lt;span&gt;])
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt;     time.sleep(0.3&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt;     throw_label.config(image=pi_list[result_number-1&lt;span&gt;])
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt;     time.sleep(0.5&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; rw[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;结果&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt;         rw[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] =&lt;span&gt; str(result_number)
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt;         rw[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = str(rw[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]) + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;+%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; result_number
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt;     time.sleep(0.5&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt;     rw[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = eval(rw[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; pw[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] != &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;play&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt;         pw.config(state=&lt;span&gt;tk.ACTIVE)
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; playing ==&lt;span&gt; False:
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt;         result_dict[nw[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]] = rw[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; widget &lt;span&gt;in&lt;/span&gt;&lt;span&gt; pbStack:
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;             widget.config(state=&lt;span&gt;tk.ACTIVE)
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; remain:
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt;         result_list = sorted(result_dict.items(), reverse=True, key=&lt;span&gt;lambda&lt;/span&gt; rt: rt[1&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; result_list[0][1] == result_list[1][1&lt;span&gt;]:
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; result_list[1][1] == result_list[2][1&lt;span&gt;]:
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt;                 throw_winner[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;gt; 平局 &amp;lt;&amp;lt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;106&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt;                 winner = result_list[0][0] + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + result_list[1&lt;span&gt;][0]
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt;                 throw_winner[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Winner: %s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; winner
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt;             winner =&lt;span&gt; result_list[0][0]
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt;             throw_winner[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Winner: %s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; winner
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt;         throw_label[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;image&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] =&lt;span&gt; crown
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt;         reset_btn.config(state=tk.ACTIVE, text=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;重新开始&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, relief=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;raised&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt; 
&lt;span&gt;115&lt;/span&gt; 
&lt;span&gt;116&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; font_shake(nw, default):
&lt;/span&gt;&lt;span&gt;117&lt;/span&gt;     nw.config(foreground=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;red&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;118&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(5&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;119&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; i%2 ==&lt;span&gt; 0:
&lt;/span&gt;&lt;span&gt;120&lt;/span&gt;             time.sleep(0.05&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;121&lt;/span&gt;             nw.config(anchor=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;122&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;             time.sleep(0.05&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;124&lt;/span&gt;             nw.config(anchor=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;125&lt;/span&gt; &lt;span&gt;        root.update()
&lt;/span&gt;&lt;span&gt;126&lt;/span&gt;     nw.config(anchor=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;127&lt;/span&gt; &lt;span&gt;    root.update()
&lt;/span&gt;&lt;span&gt;128&lt;/span&gt;     time.sleep(0.5&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;129&lt;/span&gt;     nw.config(text=default, foreground=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;black&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;130&lt;/span&gt; 
&lt;span&gt;131&lt;/span&gt; 
&lt;span&gt;132&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; restart():
&lt;/span&gt;&lt;span&gt;133&lt;/span&gt;     &lt;span&gt;global&lt;/span&gt;&lt;span&gt; readystate, used_name, result_dict, remain, pbStack
&lt;/span&gt;&lt;span&gt;134&lt;/span&gt;     throw_label[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;image&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] =&lt;span&gt; shake_cup
&lt;/span&gt;&lt;span&gt;135&lt;/span&gt;     readystate = 3
&lt;span&gt;136&lt;/span&gt;     used_name =&lt;span&gt; set()
&lt;/span&gt;&lt;span&gt;137&lt;/span&gt;     result_dict =&lt;span&gt; dict()
&lt;/span&gt;&lt;span&gt;138&lt;/span&gt;     remain = 3
&lt;span&gt;139&lt;/span&gt;     pbStack =&lt;span&gt; {play_btn_A, play_btn_B, play_btn_C}
&lt;/span&gt;&lt;span&gt;140&lt;/span&gt;     reset_btn.config(state=tk.DISABLED, relief=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;flat&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, text=&lt;span&gt;''&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;141&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ABC&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;142&lt;/span&gt;         eval(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name_%s.config(text=&quot;player %s&quot;)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; (i, i))
&lt;/span&gt;&lt;span&gt;143&lt;/span&gt;         eval(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;entry_%s.config(state=tk.NORMAL)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; i)
&lt;/span&gt;&lt;span&gt;144&lt;/span&gt;         eval(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;esv_%s.set(&quot;&quot;)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; i)
&lt;/span&gt;&lt;span&gt;145&lt;/span&gt;         eval(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;confirm_btn_%s.config(state=tk.ACTIVE)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; i)
&lt;/span&gt;&lt;span&gt;146&lt;/span&gt;         eval(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;result_%s.config(text=&quot;结果&quot;)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; i)
&lt;/span&gt;&lt;span&gt;147&lt;/span&gt;     throw_winner[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = &lt;span&gt;&quot;&quot;&lt;/span&gt;
&lt;span&gt;148&lt;/span&gt; 
&lt;span&gt;149&lt;/span&gt; 
&lt;span&gt;150&lt;/span&gt; box_frame_A =&lt;span&gt; Frame(root)
&lt;/span&gt;&lt;span&gt;151&lt;/span&gt; box_frame_A.grid(column=1, ipadx=3&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;152&lt;/span&gt; name_A = Label(box_frame_A, text=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;player A&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, height=2&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;153&lt;/span&gt; &lt;span&gt;name_A.pack()
&lt;/span&gt;&lt;span&gt;154&lt;/span&gt; signature_A = Label(box_frame_A, image=&lt;span&gt;sigpic)
&lt;/span&gt;&lt;span&gt;155&lt;/span&gt; &lt;span&gt;signature_A.pack()
&lt;/span&gt;&lt;span&gt;156&lt;/span&gt; play_btn_A = Button(box_frame_A, text=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;play&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, command=&lt;span&gt;lambda&lt;/span&gt;&lt;span&gt; : throw_touzi(play_btn_A, result_A, name_A))
&lt;/span&gt;&lt;span&gt;157&lt;/span&gt; play_btn_A.pack(side=BOTTOM, pady=3&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;158&lt;/span&gt; result_A = Label(box_frame_A, text=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;结果&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;159&lt;/span&gt; result_A.pack(side=&lt;span&gt;BOTTOM)
&lt;/span&gt;&lt;span&gt;160&lt;/span&gt; entry_A = Entry(box_frame_A, textvariable=&lt;span&gt;esv_A)
&lt;/span&gt;&lt;span&gt;161&lt;/span&gt; entry_A.pack(side=LEFT, padx=5&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;162&lt;/span&gt; confirm_btn_A = Button(box_frame_A, text=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;确定&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, command=&lt;span&gt;lambda&lt;/span&gt;&lt;span&gt; : set_name(confirm_btn_A, entry_A, name_A))
&lt;/span&gt;&lt;span&gt;163&lt;/span&gt; confirm_btn_A.pack(side=&lt;span&gt;LEFT)
&lt;/span&gt;&lt;span&gt;164&lt;/span&gt; 
&lt;span&gt;165&lt;/span&gt; center_frame =&lt;span&gt; Frame(root)
&lt;/span&gt;&lt;span&gt;166&lt;/span&gt; center_frame.grid(row=1, column=1, pady=20&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;167&lt;/span&gt; throw_label = Label(center_frame, image=&lt;span&gt;shake_cup)
&lt;/span&gt;&lt;span&gt;168&lt;/span&gt; &lt;span&gt;throw_label.pack()
&lt;/span&gt;&lt;span&gt;169&lt;/span&gt; throw_winner =&lt;span&gt; Label(center_frame)
&lt;/span&gt;&lt;span&gt;170&lt;/span&gt; &lt;span&gt;throw_winner.pack()
&lt;/span&gt;&lt;span&gt;171&lt;/span&gt; reset_btn = Button(center_frame, state=tk.DISABLED, relief=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;flat&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, command=&lt;span&gt;restart)
&lt;/span&gt;&lt;span&gt;172&lt;/span&gt; &lt;span&gt;reset_btn.pack()
&lt;/span&gt;&lt;span&gt;173&lt;/span&gt; 
&lt;span&gt;174&lt;/span&gt; box_frame_B =&lt;span&gt; Frame(root)
&lt;/span&gt;&lt;span&gt;175&lt;/span&gt; box_frame_B.grid(row=3, padx=10&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;176&lt;/span&gt; name_B = Label(box_frame_B, text=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;player B&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, height=2&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;177&lt;/span&gt; &lt;span&gt;name_B.pack()
&lt;/span&gt;&lt;span&gt;178&lt;/span&gt; signature_B = Label(box_frame_B, image=&lt;span&gt;sigpic)
&lt;/span&gt;&lt;span&gt;179&lt;/span&gt; &lt;span&gt;signature_B.pack()
&lt;/span&gt;&lt;span&gt;180&lt;/span&gt; play_btn_B = Button(box_frame_B, text=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;play&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, command=&lt;span&gt;lambda&lt;/span&gt;&lt;span&gt; : throw_touzi(play_btn_B, result_B, name_B))
&lt;/span&gt;&lt;span&gt;181&lt;/span&gt; play_btn_B.pack(side=&lt;span&gt;BOTTOM)
&lt;/span&gt;&lt;span&gt;182&lt;/span&gt; result_B = Label(box_frame_B, text=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;结果&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;183&lt;/span&gt; result_B.pack(side=&lt;span&gt;BOTTOM)
&lt;/span&gt;&lt;span&gt;184&lt;/span&gt; entry_B = Entry(box_frame_B, textvariable=&lt;span&gt;esv_B)
&lt;/span&gt;&lt;span&gt;185&lt;/span&gt; entry_B.pack(side=LEFT, padx=5&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;186&lt;/span&gt; confirm_btn_B = Button(box_frame_B, text=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;确定&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, command=&lt;span&gt;lambda&lt;/span&gt;&lt;span&gt; : set_name(confirm_btn_B, entry_B, name_B))
&lt;/span&gt;&lt;span&gt;187&lt;/span&gt; confirm_btn_B.pack(side=&lt;span&gt;LEFT)
&lt;/span&gt;&lt;span&gt;188&lt;/span&gt; 
&lt;span&gt;189&lt;/span&gt; 
&lt;span&gt;190&lt;/span&gt; box_frame_C =&lt;span&gt; Frame(root)
&lt;/span&gt;&lt;span&gt;191&lt;/span&gt; box_frame_C.grid(row=3, column=2, padx=10&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;192&lt;/span&gt; name_C = Label(box_frame_C,  text=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;player C&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, height=2&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;193&lt;/span&gt; &lt;span&gt;name_C.pack()
&lt;/span&gt;&lt;span&gt;194&lt;/span&gt; signature_C = Label(box_frame_C, image=&lt;span&gt;sigpic)
&lt;/span&gt;&lt;span&gt;195&lt;/span&gt; &lt;span&gt;signature_C.pack()
&lt;/span&gt;&lt;span&gt;196&lt;/span&gt; play_btn_C = Button(box_frame_C, text=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;play&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, command=&lt;span&gt;lambda&lt;/span&gt;&lt;span&gt; : throw_touzi(play_btn_C, result_C, name_C))
&lt;/span&gt;&lt;span&gt;197&lt;/span&gt; play_btn_C.pack(side=&lt;span&gt;BOTTOM)
&lt;/span&gt;&lt;span&gt;198&lt;/span&gt; result_C = Label(box_frame_C, text=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;结果&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;199&lt;/span&gt; result_C.pack(side=&lt;span&gt;BOTTOM)
&lt;/span&gt;&lt;span&gt;200&lt;/span&gt; entry_C = Entry(box_frame_C, textvariable=&lt;span&gt;esv_C)
&lt;/span&gt;&lt;span&gt;201&lt;/span&gt; entry_C.pack(side=LEFT, padx=5&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;202&lt;/span&gt; confirm_btn_C = Button(box_frame_C, text=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;确定&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, command=&lt;span&gt;lambda&lt;/span&gt;&lt;span&gt; : set_name(confirm_btn_C, entry_C, name_C))
&lt;/span&gt;&lt;span&gt;203&lt;/span&gt; confirm_btn_C.pack(side=&lt;span&gt;LEFT)
&lt;/span&gt;&lt;span&gt;204&lt;/span&gt; 
&lt;span&gt;205&lt;/span&gt; 
&lt;span&gt;206&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;207&lt;/span&gt;     pbStack =&lt;span&gt; {play_btn_A, play_btn_B, play_btn_C}
&lt;/span&gt;&lt;span&gt;208&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ABC&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;209&lt;/span&gt;         eval(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;play_btn_%s.config(state=tk.DISABLED)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; i)
&lt;/span&gt;&lt;span&gt;210&lt;/span&gt;     root.mainloop()
&lt;/pre&gt;&lt;/div&gt;</description>
<pubDate>Thu, 02 Jul 2020 00:33:00 +0000</pubDate>
<dc:creator>Colliventy</dc:creator>
<og:description>贴吧看到的一个求助题，大致需求是：3个人摇骰子，每人摇3次，点数之和最大的获胜，支持玩家名称输入。我觉得这个题目挺有意思的，做了个界面程序，欢迎大家交流指正~ 1 #!usr/bin/env pyth</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ywfft/p/a20200702.html</dc:identifier>
</item>
<item>
<title>Linux常用命令整合 - Kikm9999</title>
<link>http://www.cnblogs.com/ykcom/p/13222728.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ykcom/p/13222728.html</guid>
<description>[unable to retrieve full-text content]Linux常用命令 命令格式 注意：下文中的 &lt;command&gt;在使用时请用真实命令代替，如 ls， rm &lt;command&gt;[-option] [parameter] []表示可选，要用空格隔开各个参数 [-option] 中有的命令分为短版本和长版本，如 -a 和 --all 几个短命令可以组合</description>
<pubDate>Thu, 02 Jul 2020 00:25:00 +0000</pubDate>
<dc:creator>Kikm9999</dc:creator>
<dc:language>zh-CN</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://account.cnblogs.com:443/signin?ReturnUrl=https%3A%2F%2Fwww.cnblogs.com%2Fykcom%2Fp%2F13222728.html</dc:identifier>
</item>
<item>
<title>恕我直言你可能真的不会java第11篇-Stream API终端操作 - 字母哥博客</title>
<link>http://www.cnblogs.com/zimug/p/13222718.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zimug/p/13222718.html</guid>
<description>&lt;h2 id=&quot;一、java-stream管道数据处理操作&quot;&gt;一、Java Stream管道数据处理操作&lt;/h2&gt;
&lt;p&gt;在本号之前写过的文章中，曾经给大家介绍过 Java Stream管道流是用于简化集合类元素处理的java API。在使用的过程中分为三个阶段。在开始本文之前，我觉得仍然需要给一些新朋友介绍一下这三个阶段，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1815316/202007/1815316-20200702080922639-1389688561.jpg&quot; alt=&quot;Java Stream函数式编程？用过都说好，案例图文详解送给你&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第一阶段(图中蓝色)：将集合、数组、或行文本文件转换为java Stream管道流&lt;/li&gt;
&lt;li&gt;第二阶段(图中虚线部分)：管道流式数据处理操作，处理管道中的每一个元素。上一个管道中的输出元素作为下一个管道的输入元素。&lt;/li&gt;
&lt;li&gt;第三阶段(图中绿色)：管道流结果处理操作，也就是本文的将介绍的核心内容。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在开始学习之前，仍然有必要回顾一下我们之前给大家讲过的一个例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
List&amp;lt;String&amp;gt; nameStrs = Arrays.asList(&quot;Monkey&quot;, &quot;Lion&quot;, &quot;Giraffe&quot;,&quot;Lemur&quot;);

List&amp;lt;String&amp;gt; list = nameStrs.stream()
        .filter(s -&amp;gt; s.startsWith(&quot;L&quot;))
        .map(String::toUpperCase)
        .sorted()
        .collect(toList());
System.out.println(list);
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;首先使用stream()方法将字符串List转换为管道流Stream&lt;/li&gt;
&lt;li&gt;然后进行管道数据处理操作，先用fliter函数过滤所有大写L开头的字符串，然后将管道中的字符串转换为大写字母toUpperCase，然后调用sorted方法排序。这些API的用法在本号之前的文章有介绍过。其中还使用到了lambda表达式和函数引用。&lt;/li&gt;
&lt;li&gt;最后使用collect函数进行结果处理，将java Stream管道流转换为List。最终list的输出结果是:&lt;code&gt;[LEMUR, LION]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果你不使用java Stream管道流的话，想一想你需要多少行代码完成上面的功能呢？回到正题，这篇文章就是要给大家介绍第三阶段：对管道流处理结果都可以做哪些操作呢？下面开始吧！&lt;/p&gt;
&lt;h2 id=&quot;二、foreach和foreachordered&quot;&gt;二、ForEach和ForEachOrdered&lt;/h2&gt;
&lt;p&gt;如果我们只是希望将Stream管道流的处理结果打印出来，而不是进行类型转换，我们就可以使用forEach()方法或forEachOrdered()方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
Stream.of(&quot;Monkey&quot;, &quot;Lion&quot;, &quot;Giraffe&quot;, &quot;Lemur&quot;, &quot;Lion&quot;)
        .parallel()
        .forEach(System.out::println);
Stream.of(&quot;Monkey&quot;, &quot;Lion&quot;, &quot;Giraffe&quot;, &quot;Lemur&quot;, &quot;Lion&quot;)
        .parallel()
        .forEachOrdered(System.out::println);
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;parallel()函数表示对管道中的元素进行并行处理，而不是串行处理，这样处理速度更快。但是这样就有可能导致管道流中后面的元素先处理，前面的元素后处理，也就是元素的顺序无法保证&lt;/li&gt;
&lt;li&gt;forEachOrdered从名字上看就可以理解，虽然在数据处理顺序上可能无法保障，但是forEachOrdered方法可以在元素输出的顺序上保证与元素进入管道流的顺序一致。也就是下面的样子（forEach方法则无法保证这个顺序）：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;Monkey
Lion
Giraffe
Lemur
Lion
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;三、元素的收集collect&quot;&gt;三、元素的收集collect&lt;/h2&gt;
&lt;p&gt;java Stream 最常见的用法就是：一将集合类转换成管道流，二对管道流数据处理，三将管道流处理结果在转换成集合类。那么collect()方法就为我们提供了这样的功能：将管道流处理结果在转换成集合类。&lt;/p&gt;
&lt;h3 id=&quot;31收集为set&quot;&gt;3.1.收集为Set&lt;/h3&gt;
&lt;p&gt;通过Collectors.toSet()方法收集Stream的处理结果，将所有元素收集到Set集合中。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
Set&amp;lt;String&amp;gt; collectToSet = Stream.of(
   &quot;Monkey&quot;, &quot;Lion&quot;, &quot;Giraffe&quot;, &quot;Lemur&quot;, &quot;Lion&quot;
) 
.collect(Collectors.toSet());

//最终collectToSet 中的元素是:[Monkey, Lion, Giraffe, Lemur]，注意Set会去重。
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;32收集到list&quot;&gt;3.2.收集到List&lt;/h3&gt;
&lt;p&gt;同样，可以将元素收集到&lt;code&gt;List&lt;/code&gt;使用&lt;code&gt;toList()&lt;/code&gt;收集器中。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
List&amp;lt;String&amp;gt; collectToList = Stream.of(
   &quot;Monkey&quot;, &quot;Lion&quot;, &quot;Giraffe&quot;, &quot;Lemur&quot;, &quot;Lion&quot;
).collect(Collectors.toList());

// 最终collectToList中的元素是: [Monkey, Lion, Giraffe, Lemur, Lion]
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;33通用的收集方式&quot;&gt;3.3.通用的收集方式&lt;/h3&gt;
&lt;p&gt;上面为大家介绍的元素收集方式，都是专用的。比如使用Collectors.toSet()收集为Set类型集合；使用Collectors.toList()收集为List类型集合。那么，有没有一种比较通用的数据元素收集方式，将数据收集为任意的Collection接口子类型。&lt;br/&gt;所以，这里就像大家介绍一种通用的元素收集方式，你可以将数据元素收集到任意的Collection类型：即向所需Collection类型提供构造函数的方式。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
LinkedList&amp;lt;String&amp;gt; collectToCollection = Stream.of(
   &quot;Monkey&quot;, &quot;Lion&quot;, &quot;Giraffe&quot;, &quot;Lemur&quot;, &quot;Lion&quot;
).collect(Collectors.toCollection(LinkedList::new));

//最终collectToCollection中的元素是: [Monkey, Lion, Giraffe, Lemur, Lion]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：代码中使用了LinkedList::new，实际是调用LinkedList的构造函数，将元素收集到Linked List。当然你还可以使用诸如&lt;code&gt;LinkedHashSet::new&lt;/code&gt;和&lt;code&gt;PriorityQueue::new&lt;/code&gt;将数据元素收集为其他的集合类型，这样就比较通用了。&lt;/p&gt;
&lt;h3 id=&quot;34收集到array&quot;&gt;3.4.收集到Array&lt;/h3&gt;
&lt;p&gt;通过toArray(String[]::new)方法收集Stream的处理结果，将所有元素收集到字符串数组中。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
String[] toArray = Stream.of(
   &quot;Monkey&quot;, &quot;Lion&quot;, &quot;Giraffe&quot;, &quot;Lemur&quot;, &quot;Lion&quot;
) .toArray(String[]::new);

//最终toArray字符串数组中的元素是: [Monkey, Lion, Giraffe, Lemur, Lion]
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;35收集到map&quot;&gt;3.5.收集到Map&lt;/h3&gt;
&lt;p&gt;使用Collectors.toMap()方法将数据元素收集到Map里面，但是出现一个问题：那就是管道中的元素是作为key，还是作为value。我们用到了一个Function.identity()方法，该方法很简单就是返回一个“ t -&amp;gt; t ”（输入就是输出的lambda表达式）。另外使用管道流处理函数&lt;code&gt;distinct()&lt;/code&gt;来确保Map键值的唯一性。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
Map&amp;lt;String, Integer&amp;gt; toMap = Stream.of(
    &quot;Monkey&quot;, &quot;Lion&quot;, &quot;Giraffe&quot;, &quot;Lemur&quot;, &quot;Lion&quot;
)
.distinct()
.collect(Collectors.toMap(
       Function.identity(),   //元素输入就是输出，作为key
       s -&amp;gt; (int) s.chars().distinct().count()// 输入元素的不同的字母个数，作为value
));

// 最终toMap的结果是: {Monkey=6, Lion=4, Lemur=5, Giraffe=6}   
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;36分组收集groupingby&quot;&gt;3.6.分组收集groupingBy&lt;/h3&gt;
&lt;p&gt;Collectors.groupingBy用来实现元素的分组收集，下面的代码演示如何根据首字母将不同的数据元素收集到不同的List，并封装为Map。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
Map&amp;lt;Character, List&amp;lt;String&amp;gt;&amp;gt; groupingByList =  Stream.of(
    &quot;Monkey&quot;, &quot;Lion&quot;, &quot;Giraffe&quot;, &quot;Lemur&quot;, &quot;Lion&quot;
)
.collect(Collectors.groupingBy(
       s -&amp;gt; s.charAt(0) ,  //根据元素首字母分组，相同的在一组
       // counting()        // 加上这一行代码可以实现分组统计
));

// 最终groupingByList内的元素: {G=[Giraffe], L=[Lion, Lemur, Lion], M=[Monkey]}
//如果加上counting() ，结果是:  {G=1, L=3, M=1}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是该过程的说明：groupingBy第一个参数作为分组条件，第二个参数是子收集器。&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/zimug/p/images/screenshot_1572666789749.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;四、其他常用方法&quot;&gt;四、其他常用方法&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;
boolean containsTwo = IntStream.of(1, 2, 3).anyMatch(i -&amp;gt; i == 2);
// 判断管道中是否包含2，结果是: true

long nrOfAnimals = Stream.of(
    &quot;Monkey&quot;, &quot;Lion&quot;, &quot;Giraffe&quot;, &quot;Lemur&quot;
).count();
// 管道中元素数据总计结果nrOfAnimals: 4


int sum = IntStream.of(1, 2, 3).sum();
// 管道中元素数据累加结果sum: 6


OptionalDouble average = IntStream.of(1, 2, 3).average();
//管道中元素数据平均值average: OptionalDouble[2.0]



int max = IntStream.of(1, 2, 3).max().orElse(0);
//管道中元素数据最大值max: 3



IntSummaryStatistics statistics = IntStream.of(1, 2, 3).summaryStatistics();
// 全面的统计结果statistics: IntSummaryStatistics{count=3, sum=6, min=1, average=2.000000, max=3}

&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;欢迎关注我的博客，里面有很多精品合集&quot;&gt;欢迎关注我的博客，里面有很多精品合集&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;本文转载注明出处（必须带连接，不能只转文字）：&lt;a href=&quot;http://www.zimug.com&quot;&gt;字母哥博客&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;觉得对您有帮助的话，帮我点赞、分享！您的支持是我不竭的创作动力！&lt;/strong&gt; 。另外，笔者最近一段时间输出了如下的精品内容，期待您的关注。&lt;/p&gt;
</description>
<pubDate>Thu, 02 Jul 2020 00:09:00 +0000</pubDate>
<dc:creator>字母哥博客</dc:creator>
<og:description>一、Java Stream管道数据处理操作 在本号之前写过的文章中，曾经给大家介绍过 Java Stream管道流是用于简化集合类元素处理的java API。在使用的过程中分为三个阶段。在开始本文之前</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zimug/p/13222718.html</dc:identifier>
</item>
<item>
<title>【代码修炼系列分享】改掉这些坏习惯，还怕写不出健壮的代码？(二) - 一猿小讲</title>
<link>http://www.cnblogs.com/socoool/p/13222689.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/socoool/p/13222689.html</guid>
<description>&lt;p&gt;Code Review 是一场苦涩但有意思的修行。书接上篇，本次继续探讨一下，该如何写出健壮的代码？&lt;/p&gt;

&lt;h3&gt;举个栗子：&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
String amount = request.getParameter(&quot;amount&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 校验金额小数点后最多两位小数&lt;/span&gt;
BigDecimal a = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BigDecimal(amount);
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (a.doubleValue() * 100 - Math.floor(a.doubleValue() * 100) != 0&lt;span&gt;) {
    System.out.println(&lt;/span&gt;&quot;交易金额错误&quot;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; do something ... ...&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;摘一段跑在生产环境上的代码，代码咋一看没啥问题，主要功能是获取请求参数；然后完成数据校验。&lt;/p&gt;
&lt;p&gt;看似很顺眼，但是你细品，就会发现其中之奥秘，下面一起在本地跑跑代码，来分析一下到底会存在什么问题？&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;问题一：坑死人的 NPE&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;null（当 amount 输入为空时）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输出：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
Exception in thread &quot;main&quot;&lt;span&gt; java.lang.NullPointerException
  at java.math.BigDecimal.&lt;/span&gt;&amp;lt;init&amp;gt;(BigDecimal.java:806&lt;span&gt;)
  at PayController.main(PayController.java:&lt;/span&gt;300)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;分析：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　根据上面异常信息，见 BigDecimal 的源码第 806 行，如下图所示，很显然 BigDecimal 构造不会判断传入的 val 是否为空，所以会出现空指针异常。&lt;/p&gt;
&lt;div class=&quot;image-block&quot;&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/yehe-6035134/79u7tq61j9.png?imageView2/2/w/1620&quot;/&gt;&lt;/div&gt;
&lt;p&gt;目前没有出现问题，那只能算庆幸，不过终究是个定时炸弹。切记调用 BigDecimal 的构造时，请勿传入 null 值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;心声：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　身边老码农真真的排查了好长时间，问题场景与此类似，直接阻断了程序后续的流程。&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;问题二：同样是传入数字，结果咋就匪夷所思。&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;输入：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
6666.66（当 amount 输入为 6666.66）
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当 amount 输入为 6666.66 时，amount 的值校验通过。&lt;/p&gt;
&lt;p&gt;真的是看到的这个样子吗？换个数试试呗。&lt;/p&gt;
&lt;p&gt;输入：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
8888.88（当 amount 输入为 8888.88）
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出：交易金额错误&lt;/p&gt;
&lt;p&gt;分析：容我拆解一下代码，当 amount 传入为 8888.88 时：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;double&lt;/span&gt; d1 = a.doubleValue() * 100&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;double&lt;/span&gt; d2 = Math.floor(a.doubleValue() * 100&lt;span&gt;);
System.out.println(d1); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输出：888887.9999999999&lt;/span&gt;
System.out.println(d2); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输出：888887.0&lt;/span&gt;
System.out.println(d1 - d2); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输出：0.9999999998835847&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;很显然， d1 - d2 的值 != 0，那么如下表达式的值则满足，会输出交易金额错误。&lt;/p&gt;
&lt;div class=&quot;image-block&quot;&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/yehe-6035134/4seqaaidj0.png?imageView2/2/w/1620&quot;/&gt;&lt;/div&gt;
&lt;p&gt;为什么呢？归根揭底是 double 运算时精度丢失而导致程序处理出错，虽然在 Java 中提倡用 BigDecimal 进行四则运算，但是上面的校验实现，貌似跟 BigDecimal 没有啥关系，到底该怎么解决呢？&lt;/p&gt;
&lt;p&gt;不费脑简单实现方式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;if&lt;/span&gt; (amount.contains(&quot;.&quot;) &amp;amp;&amp;amp; amount.substring(amount.indexOf(&quot;.&quot;) + 1).length() &amp;gt; 2&lt;span&gt;) {
      System.out.println(&lt;/span&gt;&quot;校验失败 2&quot;&lt;span&gt;);
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; do something ... ...&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上面代码段所示，直接判断传入的 amount 字符串小数点后面的位数就可以啦。&lt;/p&gt;
&lt;p&gt;当然，仁者见仁智者见智，实现方式有很多，不去多深究。&lt;/p&gt;

&lt;h3&gt;举个栗子：&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; convertDaysToMilliseconds(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; days) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 1000 * 3600 * 24 *&lt;span&gt; days;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;分析：1000 * 3600 * 24 * days 结果默认为 int 类型，最大值为 2147483647，如果超过 int 范围，则会出现截断，程序不会出错，但是结果却匪夷所思。&lt;/p&gt;
&lt;p&gt;例如：当 days 输入为 &lt;span class=&quot;token number&quot;&gt;30 时，程序输出：&lt;span class=&quot;token operator&quot;&gt;-&lt;span class=&quot;token number&quot;&gt;1702967296。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;改进方式一：&lt;/p&gt;
&lt;div class=&quot;image-block&quot;&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/yehe-6035134/ttj7eyzbhd.png?imageView2/2/w/1620&quot;/&gt;&lt;/div&gt;
&lt;p&gt;改进方式二：&lt;/p&gt;
&lt;div class=&quot;image-block&quot;&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/yehe-6035134/dlql2ujvk7.png?imageView2/2/w/1620&quot;/&gt;&lt;/div&gt;
&lt;h3&gt;再举个栗子：&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Date getDate(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; seconds) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Date(seconds * 1000&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;分析：当 seconds * 1000 值为 int 类型，当超过 int 最大值为2147483647 时，程序不会出错，但是结果却匪夷所思。&lt;/p&gt;
&lt;p&gt;改进方式：&lt;/p&gt;
&lt;div class=&quot;image-block&quot;&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/yehe-6035134/i4082ag81r.png?imageView2/2/w/1620&quot;/&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;分享一下心声：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1. 禁止使用 double 直接参与金额运算，会出现意想不到的结果。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;浮点数采用“尾数+阶码”的编码方式，类似于科学计数法的“有效数字+指数”的表示方式。 二进制无法精确表示大部分的十进制小数。 —— 请自行科普，留作业。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;2. 禁止使用构造方法 BigDecimal(double)的方式把 double 值转化为 BigDecimal 对象。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;BigDecimal(double)存在精度损失风险，在精确计算或值比较的场景中可能会导致业务逻辑异常。 如:BigDecimal g = new BigDecimal(0.1f); 实际的存储值为:0.10000000149 优先推荐入参为 String 的构造方法，或使用 BigDecimal 的 valueOf 方法，此方法内部其实执行了 Double 的 toString，而 Double 的 toString 按 double 的实际能表达的精度对尾数进行了截断。 —— 阿里开发手册&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;3. 那些看似顺眼的代码，或者线上跑着的代码，未必就没问题，只是没有走到异常分支上去，随着时间的推移，定时炸弹迟早会爆，定期审查代码，以及充分的测试是非常的必要。&lt;/p&gt;

&lt;h3&gt;坏习惯一：记录日志时，缺失参数。&lt;/h3&gt;
&lt;p&gt;反例：&lt;/p&gt;
&lt;div class=&quot;image-block&quot;&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/7151457/ddcjrl6ka3.png?imageView2/2/w/1620&quot;/&gt;&lt;/div&gt;
&lt;p&gt;正解：&lt;/p&gt;
&lt;p&gt;　　1. 日志打印时，占位符 {} 要严格与参数相对应，如果对应不上，按照截图示意，日志输出则不会打印 queryString 的参数，会直接输出 {}，但是某些版本下会出现空指针异常。&lt;/p&gt;
&lt;p&gt;　　2.说一句废话：图中的 isVarfiy 是什么鬼？莫非是 isVerify，单词好好拼，千万别拼错，不然易被后人拍砖。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;坏习惯二：记录日志时，缺失占位符 {}。&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;反例：&lt;/p&gt;
&lt;div class=&quot;image-block&quot;&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/7151457/ok7m9blf9w.png?imageView2/2/w/1620&quot;/&gt;&lt;/div&gt;
&lt;p&gt;正解：&lt;/p&gt;
&lt;p&gt;　　类似的这种问题，多数程序员都犯过。记录日志时占位符少，而参数值多，日志输出时想打印的参数，日志中却没有打印。&lt;/p&gt;
&lt;p&gt;　　如上面截图中代码所示，想输出请求的 queryString，但是由于缺失对应的占位符 {}，则不会打印到日志中。&lt;/p&gt;

&lt;p&gt;老子曰：有道无术，术尚可求也。有术无道，止于术。&lt;/p&gt;
&lt;p&gt;庄子曰：以道驭术，术必成。离道之术，术必衰。&lt;/p&gt;
&lt;p&gt;古人曰：上人用道，中人用术，下人用力。&lt;/p&gt;
&lt;p&gt;小猿曰：管它什么道与术，能助力搬砖采石就足矣，因为我等采石之人心怀大教堂之愿景，哈哈&lt;strong&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;常在河边站哪有不湿鞋，金无足赤人无完人，再牛逼的团队，编码都会有出 Bug 的时候。近期微信公众号推出了一个专辑功能，而我迫不及待的想体验。&lt;/p&gt;
&lt;p&gt;谁成想，当我点击创建专辑时，输入专辑名称「码农心声」等信息，然后点击保存，却发现列表页面出现了多个「码农心声」，而且赶紧截了个图，不知道是不是个 Bug？&lt;/p&gt;
&lt;div class=&quot;image-block&quot;&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/7151457/q0fjc67a8o.png?imageView2/2/w/1620&quot;/&gt;&lt;/div&gt;
&lt;p&gt;But who cares？多出来的直接删除就行啦，又不影响使用。关注同名公众号：一猿小讲，回复「1024」可以获取精心为您准备的职场打怪进阶资料。&lt;/p&gt;
&lt;p&gt;好了，代码修炼的系列分享，本次就谈到这里，不知道有多少是触动了你的心弦，希望有则改之。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一起聊技术、谈业务、喷架构，少走弯路，不踩大坑。会持续输出原创精彩分享，敬请期待！&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 01 Jul 2020 23:44:00 +0000</pubDate>
<dc:creator>一猿小讲</dc:creator>
<og:description>Code Review 是一场苦涩但有意思的修行。书接上篇，本次继续探讨一下，该如何写出健壮的代码？ 一、编码时：看似顺眼，实则不然。 举个栗子： String amount = request.ge</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/socoool/p/13222689.html</dc:identifier>
</item>
<item>
<title>Flutter vs React Native vs Native：深度性能比较 - 老孟Flutter</title>
<link>http://www.cnblogs.com/mengqd/p/13222676.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mengqd/p/13222676.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200702071252081-248471360.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6.6552901023891&quot;&gt;
&lt;p&gt;&lt;strong&gt;老孟导读&lt;/strong&gt;：这是老孟翻译的付费文章，文章所有权归原作者所有。&lt;/p&gt;
&lt;p&gt;欢迎加入老孟Flutter交流群，每周翻译2-3篇付费文章，精彩不容错过。&lt;/p&gt;
&lt;p&gt;原文地址：&lt;a href=&quot;https://medium.com/swlh/flutter-vs-react-native-vs-native-deep-performance-comparison-990b90c11433&quot;&gt;https://medium.com/swlh/flutter-vs-react-native-vs-native-deep-performance-comparison-990b90c11433&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;让我们比较流行的移动开发工具在日常生活中的FPS，CPU，内存和GPU性能。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200702071252774-1013520597.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;研究背后的故事&quot;&gt;研究背后的故事&lt;/h3&gt;
&lt;p&gt;inVerita及其移动开发团队不断研究市场上提供的跨平台移动解决方案的性能，以回答哪种技术最适合您的产品，是 Flutter 或 React Native（或 Native）甚至是职业（原文是：maybe even career），这就是 &lt;a href=&quot;https://medium.com/swlh/flutter-vs-native-vs-react-native-examining-performance-31338f081980&quot;&gt;Flutter vs React Native vs Native 第一篇文章&lt;/a&gt;出现的原因。是的，这颇有争议，因为有人可以说我们不是每天使用React Native进行多次计算（可能是这种情况），但是在这种情况下，Flutter或Native应用程序可以更好地执行CPU繁重的任务。&lt;/p&gt;
&lt;p&gt;因此，在本文中，我们决定研究UI的性能，该性能对日常使用移动应用程序的用户影响更大。&lt;/p&gt;
&lt;p&gt;衡量UI性能很复杂，这要求工程师在每个平台上以相同的方式实现相同的功能。我们将 GameBench 作为测试工具，并确保我们保持客观性（这并没有改变我们在很多方面都非常喜欢Flutter的事实：），并且仍在运行许多React Native和Native项目）。 GameBench有很多改进空间，但我们的目标是设法将每个应用程序置于一个测试环境中。&lt;/p&gt;
&lt;p&gt;源代码是开放的，因此请尝试并与我们分享您的想法。 UI动画通常在不同平台上使用不同的工具，因此我们将所有内容都缩小到每个平台支持的库中（但只有一种情况），或者至少我们做了能够做到的一切。测试结果可能会有所不同，并且取决于您的实施方法，我们相信您作为特定技术的潜在真正专家可以将您的特定工具集推到极限，使其超过我们的数量，如果您这样做，我们将非常高兴。现在，让我们看一下案例。&lt;/p&gt;
&lt;h3 id=&quot;硬件信息：&quot;&gt;硬件信息：&lt;/h3&gt;
&lt;p&gt;为了进行测试，我们使用了价格合理的小米Redmi Note 5和iPhone 6s。&lt;/p&gt;
&lt;h3 id=&quot;仓库地址&quot;&gt;仓库地址&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/InVeritaSoft/Mobile_frameworks_UI-benchmarks&quot;&gt;https://github.com/InVeritaSoft/Mobile_frameworks_UI-benchmarks&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;用例1-列表视图基准&quot;&gt;用例1 —列表视图基准&lt;/h3&gt;
&lt;p&gt;我们使用Native，React Native和Flutter在Android和iOS上实现了相同的UI。我们还使用Android上的RecyclerView.SmoothScroller来自动化滚动速度。在iOS和React Native上，我们使用了带有计时器的方法，并以编程方式滚动到位置。在Flutter上，我们使用ScrollController平滑滚动列表。在每种情况下，我们在列表视图中都有1000个项目，并且滚动时间相同以到达最后一个列表元素。在每种情况下，我们都使用每个平台具有不同库的图像缓存。更多细节可以在&lt;a href=&quot;https://github.com/InVeritaSoft/Mobile_frameworks_UI-benchmarks&quot;&gt;源代码&lt;/a&gt;中揭示。&lt;/p&gt;
&lt;h4 id=&quot;在这种情况下使用的第三方库：&quot;&gt;在这种情况下使用的第三方库：&lt;/h4&gt;
&lt;p&gt;iOS：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;加载和缓存图像 — &lt;a href=&quot;https://github.com/kean/Nuke&quot;&gt;Nuke&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Android：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;加载和缓存图像 — &lt;a href=&quot;https://github.com/bumptech/glide&quot;&gt;Glide&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;React Native&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200702071253417-370392175.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200702071253779-1208664537.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;所有测试均显示出大致相同的FPS。&lt;/li&gt;
&lt;li&gt;与Flutter和React Native相比，Android Native使用的内存只有一半。&lt;/li&gt;
&lt;li&gt;React Native需要最多的CPU开发。原因是在JS和本机代码之间使用JSBridge，这会导致序列化和反序列化方面的资源浪费。&lt;/li&gt;
&lt;li&gt;关于电池开发，Android Native具有最佳效果。 React-native落后于Android和Flutter。运行连续动画会在React Native上消耗更多电池电量。&lt;/li&gt;
&lt;/ol&gt;&lt;h5 id=&quot;iphone-6s-test&quot;&gt;iPhone 6s test&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200702071254596-1192918836.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;FPS，React Native的结果比Flutter和Swift差。原因是无法在iOS上使用IoT编译。&lt;/li&gt;
&lt;li&gt;内存。 Flutter与Native在内存消耗上几乎一样，但在CPU上仍然较重。在此测试中，React Native远远落后于Flutter和native。&lt;/li&gt;
&lt;li&gt;Flutter和Swift之间的区别。当iOS Native积极使用GPU时，Flutter积极使用CPU。 Flutter中的协调会增加CPU的负载。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;用例2-繁重的动画测试&quot;&gt;用例2 —繁重的动画测试&lt;/h3&gt;
&lt;p&gt;如今，大多数在Android和iOS上运行的手机都具有强大的硬件。在大多数情况下，使用常规的商业应用程序时，不会发现fps下降。因此，我们决定对重型动画进行一些测试。重得足以导致fps下降。我们使用了在Android，iOS，React Native上使用Lottie进行动画处理的矢量动画，并在Flutter上使用了与Flare相同的动画。&lt;/p&gt;
&lt;p&gt;Android，iOS，React Native 使用 Lottie 动画，Flutter 使用 &lt;a href=&quot;https://pub.dev/packages/flare_flutter&quot;&gt;Flare&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.cnblogs.com/Users/mengqingdong/Downloads/20200701214128.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200702071256190-1719643252.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200702071256977-192420525.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;android&quot;&gt;Android&lt;/h5&gt;
&lt;ol&gt;&lt;li&gt;Android和React Native在性能上有相似之处。很明显，因为Lottie for React Native使用本地方式（16–19％CPU，30–29 FPS）。&lt;/li&gt;
&lt;li&gt;Flutter的结局令人惊讶，在演出中有点糟。 （12％的CPU和9 FPS）。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;我们发现从网格中删除一个特定的动画会使Flutter上的FPS最高提高40％。我们认为Flare较重且未针对此类任务进行优化，这就是Flutter导致FPS下降的原因。&lt;/p&gt;
&lt;p&gt;怪这一个：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200702071257300-1772017524.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;Android需要最少的内存（205 Mb）； React Native需要280 Mb，Flutter需要266 Mb。&lt;/li&gt;
&lt;li&gt;冷启动应用程序。根据此指标，Flutter处于领先地位（2秒）。对于Android Native和React Native，大约需要4秒钟。&lt;/li&gt;
&lt;/ol&gt;&lt;h5 id=&quot;ios&quot;&gt;iOS&lt;/h5&gt;
&lt;ol&gt;&lt;li&gt;iOS和React Native在此测试中的结果几乎与Lottie for React Native使用本地方法相同。&lt;/li&gt;
&lt;li&gt;Flare和Flutter不会令人惊讶。Flare 还有很长的一段路要走。&lt;/li&gt;
&lt;li&gt;iOS Native需要最少的内存量（48 Mb）。 React Native需要135 Mb，Flutter需要117 Mb。&lt;/li&gt;
&lt;li&gt;冷启动应用程序。根据此指标，Flutter处于领先地位（2秒）。对于iOS和React Native，大约需要10秒钟。&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;请注意：在这种情况下，我们为Flutter使用了一个不同的库，该库比我们在其他平台上使用的库重得多，这可能是fps下降的原因。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;用例3-更重的动画会测试旋转，缩放和淡入淡出。&quot;&gt;用例3-更重的动画会测试旋转，缩放和淡入淡出。&lt;/h3&gt;
&lt;p&gt;在此测试中，我们比较了动画200张图像时的性能。刻度旋转和淡入淡出动画同时执行。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200702071417125-52676977.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200702071428042-2145936618.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200702071428042-2145936618.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;android-2&quot;&gt;Android&lt;/h5&gt;
&lt;ol&gt;&lt;li&gt;Native 显示出最佳性能和最有效的内存消耗。&lt;/li&gt;
&lt;li&gt;Flutter显示出非常接近本机fps，并且内存开销增加了两倍，但性能仍然不错。&lt;/li&gt;
&lt;li&gt;React Native-在这种情况下表现不佳。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200702071429663-1995452285.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;ios-2&quot;&gt;iOS&lt;/h5&gt;
&lt;ol&gt;&lt;li&gt;iPhone 6s足够强大，在所有3种情况下都不会降低fps。&lt;/li&gt;
&lt;li&gt;Native 使用的资源较少，而GPU则最多使用。&lt;/li&gt;
&lt;li&gt;React Native主要使用CPU进行渲染，而Flutter使用GPU。&lt;/li&gt;
&lt;li&gt;React Native使用了更多的内存。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;对于具有次要动画和闪亮外观的常规商务应用程序，技术根本不重要。但是，如果要制作一些繁重的动画，请记住，Native具有最强大的性能。接下来是Flutter和React Native。我们绝对不建议在CPU繁重的操作中使用React Native，而Flutter从CPU和内存的角度来看都非常适合此类任务。&lt;/p&gt;
&lt;p&gt;您选择的工具取决于您的特定产品和业务案例。如果您要开发单平台MVP，请使用Native，但请记住，Flutter应用程序可以为移动，Web和桌面环境构建，因此Flutter可能会成为跨平台开发之王未来并非遥不可及，直到今天，Flutter还是对Native开发工具进行了非常不错的竞争，尤其是在您的开发预算不太紧张但您仍在寻找应用程序性能不错的情况下。&lt;/p&gt;
&lt;p&gt;我们面对这样一个事实，即可能有许多因素会影响每种技术的实施和基准，并且你们当中许多人可能是特定平台的真正专家，他们可能会从更多受欢迎的工具中挤出更多的钱。我们通过为每个要测试的应用程序创建一个单一的环境以及一套用于衡量性能的工具，试图为流程带来尽可能多的透明度，我希望您喜欢这样的结果。再一次，我们的移动团队和Flutter团队很高兴收到并承担您所有反馈和建议的重担。&lt;/p&gt;
&lt;h2 id=&quot;交流&quot;&gt;交流&lt;/h2&gt;
&lt;p&gt;老孟Flutter博客地址（330个控件用法）：&lt;a href=&quot;http://laomengit.com&quot;&gt;http://laomengit.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎加入Flutter交流群（微信：laomengit）、关注公众号【老孟Flutter】：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th/&gt;
&lt;th/&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200702071430363-1837483181.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/td&gt;
&lt;td&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202007/467322-20200702071430889-1889800177.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;</description>
<pubDate>Wed, 01 Jul 2020 23:15:00 +0000</pubDate>
<dc:creator>老孟Flutter</dc:creator>
<og:description>老孟导读：这是老孟翻译的付费文章，文章所有权归原作者所有。 欢迎加入老孟Flutter交流群，每周翻译2-3篇付费文章，精彩不容错过。 原文地址：https://medium.com/swlh/flu</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mengqd/p/13222676.html</dc:identifier>
</item>
<item>
<title>C#由转换二进制所引起的思考，了解下？ - Jeffcky</title>
<link>http://www.cnblogs.com/CreateMyself/p/13216212.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CreateMyself/p/13216212.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;最近遇到很有意思转换二进制的问题，有部分童鞋俨然已了解，可能也有一部分童鞋没碰到过也就不知情，这里我们来深入学习下转换二进制所带来的问题。&lt;/p&gt;
&lt;h2&gt;二进制转换问题&lt;/h2&gt;
&lt;p&gt;假设现在我们有一个int类型的数据，它的范围区间暂且定在0-15之间，我们需要将其转换为二进制，然后获取二进制中的每一位，若不足4位则0填充。看似很简单是不是，直接通过C#内置APi即可达到此需求，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;var&lt;/span&gt; binary = Convert.ToString(&lt;span&gt;7&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;).PadLeft(&lt;span&gt;4&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).ToArray();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上述将数字7转换为包含二进制位的字符串数组形式，7转换二进制然后不足4位以0填充即（0111），我们如下获取二进制位字符串数组为索引的位，结果应该打印出0，对吗？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; zerobit = binary[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];
Console.WriteLine(zerobit);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/589642/202006/589642-20200630221400607-1347010274.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;好像一点毛病也没有，这是在控制台中进行打印，若是将该数据导出到Excel中，你会发现结果将可能是48或49而不是0或1（你可以一试）这是因为如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/589642/202006/589642-20200630221636052-667002088.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们通过调试可知实际上在字符0上还携带有48，这个48实际上是字符0的ASCII码，字符1的ASCII码是49，通过如下代码即可证明：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; b &lt;span&gt;in&lt;/span&gt;&lt;span&gt; System.Text.Encoding.UTF8.GetBytes(binary))
{
    Console.WriteLine(b.ToString());
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/589642/202006/589642-20200630222225408-1427496652.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/589642/202006/589642-20200630222249019-286847038.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们对将对应字符数组索引数据进行如下ToString转换即可避免导出数据时可能出现的问题&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; zerobit = binary[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];
Console.WriteLine(zerobit.ToString());&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;转换字符数组问题&lt;/h2&gt;
&lt;p&gt;当我们转换为字符数组时，有两种方式，既可采用上述ToArray方法，也可以通过ToCharArray方法来实现，如下，那么哪种方法会更好呢？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; binary = Convert.ToString(&lt;span&gt;7&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;).PadLeft(&lt;span&gt;4&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).ToArray();

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; binary1 = Convert.ToString(&lt;span&gt;7&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;).PadLeft(&lt;span&gt;4&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).ToCharArray();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时比较此二者方法的性能好坏，只能去看对应源码实现，首先我们来看看ToCharArray方法，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;unsafe&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;&lt;span&gt;[] ToCharArray()
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (Length == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Array.Empty&amp;lt;&lt;span&gt;char&lt;/span&gt;&amp;gt;&lt;span&gt;();
    }
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;[] array = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;&lt;span&gt;[Length];
    &lt;/span&gt;&lt;span&gt;fixed&lt;/span&gt; (&lt;span&gt;char&lt;/span&gt;* smem = &amp;amp;&lt;span&gt;_firstChar)
    {
        &lt;/span&gt;&lt;span&gt;fixed&lt;/span&gt; (&lt;span&gt;char&lt;/span&gt;* dmem = &amp;amp;array[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;])
        {
            wstrcpy(dmem, smem, Length);
        }
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; array;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;internal&lt;/span&gt; &lt;span&gt;unsafe&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; wstrcpy(&lt;span&gt;char&lt;/span&gt;* dmem, &lt;span&gt;char&lt;/span&gt;* smem, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; charCount)
{
    Buffer.Memmove((&lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;*)dmem, (&lt;span&gt;byte&lt;/span&gt;*)smem, (&lt;span&gt;uint&lt;/span&gt;)(charCount * &lt;span&gt;2&lt;/span&gt;&lt;span&gt;));
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上述对于ToCharArray代码量还是不多，我们来看看ToArray方法实现，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; TSource[] ToArray&amp;lt;TSource&amp;gt;(&lt;span&gt;this&lt;/span&gt; IEnumerable&amp;lt;TSource&amp;gt;&lt;span&gt; source)
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (source == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; Error.ArgumentNull(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;source&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Buffer&amp;lt;TSource&amp;gt;&lt;span&gt;(source).ToArray();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上述只是写了一个扩展方法，我们继续往下看Buffer类的具体实现，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;internal&lt;/span&gt; Buffer(IEnumerable&amp;lt;TElement&amp;gt;&lt;span&gt; source)
{
    TElement[] array &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; num = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    ICollection&lt;/span&gt;&amp;lt;TElement&amp;gt; collection = source &lt;span&gt;as&lt;/span&gt; ICollection&amp;lt;TElement&amp;gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (collection != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
    {
        num &lt;/span&gt;=&lt;span&gt; collection.Count;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (num &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
        {
            array &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TElement[num];
            collection.CopyTo(array, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
        }
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (TElement item &lt;span&gt;in&lt;/span&gt;&lt;span&gt; source)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (array == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                array &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; TElement[&lt;span&gt;4&lt;/span&gt;&lt;span&gt;];
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (array.Length ==&lt;span&gt; num)
            {
                TElement[] array2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; TElement[&lt;span&gt;checked&lt;/span&gt;(num * &lt;span&gt;2&lt;/span&gt;&lt;span&gt;)];
                Array.Copy(array, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;, array2, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, num);
                array &lt;/span&gt;=&lt;span&gt; array2;
            }
            array[num] &lt;/span&gt;=&lt;span&gt; item;
            num&lt;/span&gt;++&lt;span&gt;;
        }
    }
    items &lt;/span&gt;=&lt;span&gt; array;
    count &lt;/span&gt;=&lt;span&gt; num;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从代码量上看就觉得ToArray方法实现稍微复杂一点，所以我们选择使用ToCharArray会更好，我要是如此草草结束此文，一定会喷。原归正传，我们一步步来分析，如上做了一点优化，首先会判断参数是否属于集合接口，若是则直接通过复制转换为数组形式，但是我们知道字符串肯定没有实现ICollection&amp;lt;T&amp;gt;接口，所以走另外一个条件分支，但是有的童鞋可能就有疑问了，此时为何可以遍历呢？那是因为针对字符实现了IEnumerable&amp;lt;char&amp;gt;接口，所以可以进行遍历，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;sealed&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; CharEnumerator : IEnumerator, ICloneable, IEnumerator&amp;lt;&lt;span&gt;char&lt;/span&gt;&amp;gt;&lt;span&gt;, IDisposable
{......}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来则是初始化容量为4的数组，为何这里为4呢？这里我认为应该谈不上优化，与其说是实现者的一种拍脑袋的想法，我倾向于理解为是一种权衡或考量，既然转到此分支说明一定是转换为二进制位的数组，比如上述进行填充后长度刚好为4。再接下来无用我再多讲，就是遍历所有字符数组，将每一个字符串添加到数组中去，直到数组长度和变量值（num）相等最终进行一次性复制，最终将数组赋值给数组元素以及将变量num赋值给数组元素的数量（count）。 &lt;/p&gt;

&lt;p&gt;好了，讲解了这么多，那么问题来了，到底谁的性能会更好呢？ToCharArray方法实现底层采用指针操作转化为字符数组，而利用ToArray方法由于string没有实现ICollection&amp;lt;T&amp;gt;接口，也就是说根本不清楚字符串中字符数组的长度，所以只能采取低效遍历的方式去进行转换，我们可认为通过中间缓冲区的方式（即上述通过实例化数组作为桥梁最终进行复制）实现。由此得出，在将字符串转换为字符数组时，一定要用ToCharArray方法而不是ToArray，ToCharArray性能优于ToArray方法，我不禁在想，针对字符转换为数组只提供ToCharArray方法不就好了么，为何还要提供ToArray方法，让人容易产生误会，它的场景难道还有其他吗？&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;本文详细讲解了在转换二进制数据所引发的一点个人思考，在将字符串转换为字符数组时，通过方法名称意思可能直接就用ToCharArray方法，但是又偏偏提供了字符串的ToArray方法，其本质是针对字符数组的扩展方法，如果对源码不了解的话，根本就不清楚到底应该用哪一个，从性能角度讲，ToCharArray方法优于ToArray方法，至于最终用哪一个，你说了算。&lt;/p&gt;
</description>
<pubDate>Wed, 01 Jul 2020 23:15:00 +0000</pubDate>
<dc:creator>Jeffcky</dc:creator>
<og:description>前言 最近遇到很有意思转换二进制的问题，有部分童鞋俨然已了解，可能也有一部分童鞋没碰到过也就不知情，这里我们来深入学习下转换二进制所带来的问题。 二进制转换问题 假设现在我们有一个int类型的数据，它</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/CreateMyself/p/13216212.html</dc:identifier>
</item>
<item>
<title>React源码之组件的实现与首次渲染 - whosmeya</title>
<link>http://www.cnblogs.com/whosmeya/p/13222478.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/whosmeya/p/13222478.html</guid>
<description>&lt;p&gt;react: v15.0.0&lt;/p&gt;
&lt;p&gt;本文讲 组件如何编译 以及 ReactDOM.render 的渲染过程。&lt;/p&gt;
&lt;br/&gt;&lt;h2 id=&quot;babel-的编译&quot;&gt;babel 的编译&lt;/h2&gt;
&lt;p&gt;babel 将 React JSX 编译成 JavaScript.&lt;/p&gt;
&lt;p&gt;在 babel 官网写一段 JSX 代码编译结果如图：&lt;/p&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/1141466/202007/1141466-20200701110510613-275226880.png&quot;/&gt;&lt;p&gt;每个标签的创建都调用了 React.createElement.&lt;/p&gt;
&lt;br/&gt;&lt;h2 id=&quot;源码中的两种数据结构&quot;&gt;源码中的两种数据结构&lt;/h2&gt;
&lt;p&gt;贯穿源码，常见的两种数据结构，有助于快速阅读源码。&lt;/p&gt;
&lt;h3 id=&quot;reactelement&quot;&gt;ReactElement&lt;/h3&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/1141466/202007/1141466-20200701223118807-1667124983.png&quot;/&gt;&lt;p&gt;结构如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;{
  $$typeof  // ReactElement标识符
  type      // 组件
  key
  ref
  props     // 组件属性和children
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;是 React.createElement 的返回值。&lt;/p&gt;
&lt;h3 id=&quot;reactcomponent&quot;&gt;ReactComponent&lt;/h3&gt;
&lt;p&gt;ReactComponent 这个名字有点奇怪。&lt;/p&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/1141466/202007/1141466-20200701225856992-909218791.png&quot;/&gt;&lt;p&gt;结构如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;{
  _currentElement    // ReactElement
  ...

  // 原型链上的方法
  mountComponent,    // 组件初次加载调用
  updateComponent,   // 组件更新调用
  unmountComponent,  // 组件卸载调用
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;是 ReactCompositeComponent 的 instance 类型。其余三种构造函数 ReactDOMComponent、ReactDOMTextComponent、ReactEmptyComponent 的实例结构与其相似。&lt;/p&gt;
&lt;br/&gt;&lt;h2 id=&quot;reactcreateelement&quot;&gt;React.createElement&lt;/h2&gt;
&lt;p&gt;React.createElement 实际执行的是 ReactElement.createElement。&lt;/p&gt;
&lt;p&gt;ReactElement.createElement 接收三个参数：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;type: string | Component&lt;/li&gt;
&lt;li&gt;config: 标签上的属性&lt;/li&gt;
&lt;li&gt;...children: children元素集合&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;重点关注 type 和 props。&lt;/p&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/1141466/202007/1141466-20200701112819125-1454911396.png&quot;/&gt;&lt;p&gt;然后看 ReactElement 方法，只是做了赋值动作。&lt;/p&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/1141466/202007/1141466-20200701113450513-1728092157.png&quot;/&gt;&lt;p&gt;综上，我们写的代码编译后是这样的：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;class C extends React.Component {
  render() {
    return {
      type: &quot;div&quot;,
      props: {
        children: this.props.value,
      },
    };
  }
}

class App extends React.Component {
  render() {
    return {
      type: &quot;div&quot;,
      props: {
        children: [
          {
            type: &quot;span&quot;,
            props: {
              children: &quot;aaapppppp&quot;,
            },
          },
          &quot;123&quot;,
          {
            type: C,
            props: {
              value: &quot;ccc&quot;,
            },
          },
        ]
      },
    };
  }
}

ReactDOM.render(
  {
    type: App,
    props: {},
  },
  document.getElementById(&quot;root&quot;)
);
&lt;/code&gt;
&lt;/pre&gt;
&lt;br/&gt;&lt;h2 id=&quot;reactdomrender&quot;&gt;ReactDOM.render&lt;/h2&gt;
&lt;p&gt;先来看下 ReactDOM.render 源码的执行过程&lt;/p&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/1141466/202007/1141466-20200701165005557-100283254.png&quot;/&gt;&lt;br/&gt;&lt;h3 id=&quot;instantiatereactcomponent&quot;&gt;instantiateReactComponent&lt;/h3&gt;
&lt;p&gt;在 _renderNewRootComponent 方法中，调用了 instantiateReactComponent，生成了的实例结构类似于 ReactComponent。&lt;/p&gt;
&lt;p&gt;instantiateReactComponent 的参数是 node，node 的其中一种格式就是 ReactElement。&lt;/p&gt;
&lt;p&gt;根据 node &amp;amp; node.type 的类型，会执行不同的方法生成实例&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ReactCompositeComponent&lt;/li&gt;
&lt;li&gt;ReactDOMComponent&lt;/li&gt;
&lt;li&gt;ReactDOMTextComponent&lt;/li&gt;
&lt;li&gt;ReactEmptyComponent&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;简化如下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;var instantiateReactComponent = function (node) {
  if (node === null || node === false) {
    return new ReactEmptyComponent(node);
  } else if (typeof node === 'object') {
    if (node.type === 'string') {
      return new ReactDOMComponent(node);
    } else {
      return new ReactCompositeComponent(node);
    }
  } else if (typeof node === 'string' || typeof node === 'number') {
    return new ReactDOMTextComponent(node);
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过四种方式实例化后的对象基本相似&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;var instance = {
  _currentElement: node,
  _rootNodeID: null,
  ...
}
instance.__proto__ = {
  mountComponent,
  updateComponent,
  unmountComponent,
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;四种 mountComponent 简化如下&lt;/p&gt;
&lt;h4 id=&quot;reactcompositecomponent&quot;&gt;ReactCompositeComponent&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;mountComponent: function () {
  // 创建当前组件的实例
  this._instance = new this._currentElement.type();

  // 调用组件的 render 方法，得到组件的 renderedElement
  renderedElement = this._instance.render();

  // 调用 instantiateReactComponent,  得到 renderedElement 的实例化 ReactComponent
  this._renderedComponent = instantiateReactComponent(renderedElement);

  // 调用 ReactComponent.mountComponent
  return this._renderedComponent.mountComponent();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;reactdomcomponent&quot;&gt;ReactDOMComponent&lt;/h4&gt;
&lt;p&gt;react 源码中，插入 container 前使用 ownerDocument、DOMLazyTree 创建和存放节点，此处为了方便理解，使用 document.createElement 模拟。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;mountComponent: function () {
  var { type, props } = this._currentElement;

  var element = document.createElement(type);

  if (props.children) {
    var childrenMarkups = props.children.map(function (node) {
      var instance = instantiateReactComponent(node);
      return instance.mountComponent();
    })

    element.appendChild(childrenMarkups)
  }

  return element;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;reactdomtextcomponent&quot;&gt;ReactDOMTextComponent&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;mountComponent: function () {
  return this._currentElement;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;reactemptycomponent&quot;&gt;ReactEmptyComponent&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;mountComponent: function () {
  return null;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;br/&gt;&lt;h3 id=&quot;reactdomrender-简化&quot;&gt;ReactDOM.render 简化&lt;/h3&gt;
&lt;p&gt;简化如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;ReactDOM.render = function (nextElement, container) {
  var nextWrappedElement = ReactElement(
    TopLevelWrapper,
    null,
    null,
    null,
    null,
    null,
    nextElement
  );

  var componentInstance = instantiateReactComponent(nextElement);

  var markup = componentInstance.mountComponent;

  container.innerHTML = markup;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;br/&gt;&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;babel 将 JSX 语法编译成 React.createElement 形式。&lt;/li&gt;
&lt;li&gt;源码中用到了两个重要的数据结构
&lt;ul&gt;&lt;li&gt;ReactElement&lt;/li&gt;
&lt;li&gt;ReactComponent&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;React.createElement 将我们写的组件处理成 ReactElement 结构。&lt;/li&gt;
&lt;li&gt;ReactDOM.render 传入 ReactElement 和 container, 渲染流程如下
&lt;ul&gt;&lt;li&gt;在 ReactElement 外套一层，生成新的 ReactElement&lt;/li&gt;
&lt;li&gt;实例化 ReactElement：var instance = instantiateReactComponent(ReactElement)&lt;/li&gt;
&lt;li&gt;递归生成 markup：var markup = instance.mountComponent()&lt;/li&gt;
&lt;li&gt;将 markup 插入 container：container.innerHTML = markup&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;a href=&quot;https://www.whosmeya.com/&quot;&gt;whosmeya.com&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 01 Jul 2020 16:13:00 +0000</pubDate>
<dc:creator>whosmeya</dc:creator>
<og:description>react: v15.0.0 本文讲 组件如何编译 以及 ReactDOM.render 的渲染过程。 babel 的编译 babel 将 React JSX 编译成 JavaScript. 在 ba</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/whosmeya/p/13222478.html</dc:identifier>
</item>
<item>
<title>05 . k8s实战之部署PHP/JAVA网站 - you-men</title>
<link>http://www.cnblogs.com/you-men/p/13222462.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/you-men/p/13222462.html</guid>
<description>&lt;h4 id=&quot;传统部署和k8s部署区别&quot;&gt;传统部署和k8s部署区别&lt;/h4&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;通常使用传统的部署的时候，我们一个web项目，网站的搭建，往往使用的如下的一种整体架构，可能有的公司在某一环节使用的东西是不一样，但是大体的框架流程是都是差不多的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1871335/202007/1871335-20200702000255237-1936489177.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;使用k8s部署,便于弹性伸缩,节约资源,发布周期快,整体框架如下&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1871335/202007/1871335-20200702000318627-270266447.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;环境&quot;&gt;环境&lt;/h4&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;节点名&lt;/th&gt;
&lt;th&gt;IP&lt;/th&gt;
&lt;th&gt;软件版本&lt;/th&gt;
&lt;th&gt;硬件&lt;/th&gt;
&lt;th&gt;网络&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;K8s-master&lt;/td&gt;
&lt;td&gt;192.168.43.190&lt;/td&gt;
&lt;td&gt;list 里面都有&lt;/td&gt;
&lt;td&gt;2C4G&lt;/td&gt;
&lt;td&gt;Nat，内网&lt;/td&gt;
&lt;td&gt;测试环境&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;K8s-node1&lt;/td&gt;
&lt;td&gt;192.168.43.120&lt;/td&gt;
&lt;td&gt;list 里面都有&lt;/td&gt;
&lt;td&gt;2C4G&lt;/td&gt;
&lt;td&gt;Nat，内网&lt;/td&gt;
&lt;td&gt;测试环境&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;K8s-node2&lt;/td&gt;
&lt;td&gt;192.168.43.9&lt;/td&gt;
&lt;td&gt;list 里面都有&lt;/td&gt;
&lt;td&gt;2C4G&lt;/td&gt;
&lt;td&gt;Nat，内网&lt;/td&gt;
&lt;td&gt;测试环境&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;K8s-harbor&lt;/td&gt;
&lt;td&gt;192.168.43.129&lt;/td&gt;
&lt;td&gt;list 里面都有&lt;/td&gt;
&lt;td&gt;2C4G&lt;/td&gt;
&lt;td&gt;Nat，内网&lt;/td&gt;
&lt;td&gt;测试环境&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4 id=&quot;安装运行harbor（http方式）&quot;&gt;安装运行harbor（http方式）&lt;/h4&gt;
&lt;h5 id=&quot;安装docker&quot;&gt;安装docker&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# 安装一些必要的系统工具
sudo yum install -y yum-utils device-mapper-persistent-data lvm2
# 添加软件源信息
# docker 官方源
sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo

# 阿里云源
sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo

  
# 安装前可以先更新 yum 缓存：
sudo yum makecache fast

# CentOS7安装 Docker-ce
yum -y install docker-ce        # CentOS 中安装
apt-get install docker-ce       # Ubuntu 中安装
pacman -S docker                # Arch 中安装
emerge --ask docker             # Gentoo 中安装

# 如果想安装特定版本的Docker-ce版本，先列出repo中可用版本，然后选择安装
yum list docker-ce --showduplicates |sort -r
Loading mirror speeds from cached hostfile
Loaded plugins: fastestmirror
Installed Packages
docker-ce.x86_64            3:19.03.4-3.el7                    docker-ce-stable
docker-ce.x86_64            3:19.03.4-3.el7                    @docker-ce-stable
docker-ce.x86_64            3:19.03.3-3.el7                    docker-ce-stable
docker-ce.x86_64            3:19.03.2-3.el7                    docker-ce-stable
docker-ce.x86_64            3:19.03.1-3.el7                    docker-ce-stable

yum install docker-ce-&amp;lt;VERSION STRING&amp;gt;
# 选择安装 docker-ce-18.06.1.ce
yum install docker-ce-18.06.1.ce -y

# Docker镜像加速
# 没有启动/etc/docker目录不存在，需要自己创建，docker启动也会自己创建
# 为了期望我们的镜像下载快一点，应该定义一个镜像加速器，加速器在国内
mkdir /etc/docker
vim /etc/docker/daemon.json
{
&quot;registry-mirrors&quot;: [&quot;https://registry.docker-cn.com&quot;]
}

# 启动Docker后台服务
systemctl start docker &amp;amp;&amp;amp; systemctl enable docker
systemctl daemon-reload                 # 守护进程重启

# 通过运行hello-world镜像，验证是否正确安装了docker，或者通过查看版本
docker run hello-world
docker version
Client: Docker Engine - Community
Version:           19.03.4
API version:       1.40
Go version:        go1.12.10
Git commit:        9013bf583a
Built:            Fri Oct 18 15:52:22 2019
OS/Arch:           linux/amd64
Experimental:      false
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;https请看我下面专门写的文章&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/you-men/p/13121835.html&quot;&gt;https://www.cnblogs.com/you-men/p/13121835.html&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;15&quot;&gt;
&lt;p&gt;Harbor 可帮助用户迅速搭建企业级的 Registry 服务, 它提供了管理图形界面, 基于角色的访问控制 ( Role Based Access Control), 镜像远程复制 (同步), AD/LDAP 集成, 以及审计日志等企业用户需求的功能, 同时还原生支持中文, 深受中国用户的喜爱;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;安装harbor&quot;&gt;安装harbor&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;注意&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;安装harbor之前需要安装docker&lt;/code&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;9.4331983805668&quot;&gt;
&lt;p&gt;是 &lt;code&gt;VMware&lt;/code&gt; 公司开源了企业级 &lt;code&gt;Registry&lt;/code&gt; 项目, 其的目标是帮助用户迅速搭建一个企业级的 &lt;code&gt;Docker registry&lt;/code&gt; 服务。&lt;/p&gt;
&lt;p&gt;由于 Harbor 是基于 Docker Registry V2 版本，所以 docker 版本必须 &lt;code&gt;&amp;gt;=1.10.0&lt;/code&gt; &lt;a href=&quot;https://docs.docker.com/compose/install/#prerequisites&quot;&gt;docker-compose&lt;/a&gt; &lt;code&gt;&amp;gt;=1.6.0&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下载最新版 &lt;code&gt;Docker Compose&lt;/code&gt;&lt;br/&gt;curl -L &quot;&lt;a href=&quot;https://github.com/docker/compose/releases/download/1.22.0/docker-compose-$&quot;&gt;https://github.com/docker/compose/releases/download/1.22.0/docker-compose-$&lt;/a&gt;(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose&lt;/p&gt;
&lt;p&gt;下载最新版&lt;code&gt;Docker Harbor&lt;/code&gt;&lt;br/&gt;wget &lt;a href=&quot;https://github.com/goharbor/harbor/releases/download/v1.10.0-rc1/harbor-offline-installer-v1.10.0-rc1.tgz&quot;&gt;https://github.com/goharbor/harbor/releases/download/v1.10.0-rc1/harbor-offline-installer-v1.10.0-rc1.tgz&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;# 对二进制文件应用可执行权限：
sudo chmod +x /usr/local/bin/docker-compose
# 测试是否安装成功
docker-compose --version
# 按照上面给的docker harbor地址，下载离线安装包
tar xvf harbor-offline-installer-v1.8.1.tgz -C  /usr/local/
vim  /usr/local/harbor/harbor.yml
hostname: 47.92.24.137

# 运行安装脚本
./install.sh 
[Step 0]: checking installation environment ...
Note: docker version: 19.03.4
Note: docker-compose version: 1.22.0
[Step 1]: loading Harbor images ...
Loaded image: goharbor/harbor-core:v1.8.1
Loaded image: goharbor/harbor-registryctl:v1.8.1
Loaded image: goharbor/redis-photon:v1.8.1
Loaded image: goharbor/notary-server-photon:v0.6.1-v1.8.1
Loaded image: goharbor/chartmuseum-photon:v0.8.1-v1.8.1
Loaded image: goharbor/harbor-db:v1.8.1
Loaded image: goharbor/harbor-jobservice:v1.8.1
Loaded image: goharbor/nginx-photon:v1.8.1
Loaded image: goharbor/registry-photon:v2.7.1-patch-2819-v1.8.1
Loaded image: goharbor/harbor-migrator:v1.8.1
Loaded image: goharbor/prepare:v1.8.1
Loaded image: goharbor/harbor-portal:v1.8.1
Loaded image: goharbor/harbor-log:v1.8.1
Loaded image: goharbor/notary-signer-photon:v0.6.1-v1.8.1
Loaded image: goharbor/clair-photon:v2.0.8-v1.8.1
[Step 2]: preparing environment ...
prepare base dir is set to /usr/local/harbor
Generated configuration file: /config/log/logrotate.conf
Generated configuration file: /config/nginx/nginx.conf
Generated configuration file: /config/core/env
Generated configuration file: /config/core/app.conf
Generated configuration file: /config/registry/config.yml
Generated configuration file: /config/registryctl/env
Generated configuration file: /config/db/env
Generated configuration file: /config/jobservice/env
Generated configuration file: /config/jobservice/config.yml
Generated and saved secret to file: /secret/keys/secretkey
Generated certificate, key file:/secret/core/private_key.pem, cert file:/secret/registry/root.crt
Generated configuration file: /compose_location/docker-compose.yml
Clean up the input dir
[Step 3]: starting Harbor ...
✔ ----Harbor has been installed and started successfully.----
Now you should be able to visit the admin portal at http://47.92.24.137. 
For more details, please visit https://github.com/goharbor/harbor
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;接下来我们可以直接浏览器访问配置文件定义的IP或者域名加端口&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;默认用户密码: admin/Harbor12345&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1871335/202006/1871335-20200614142622406-811602712.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1871335/202006/1871335-20200614142640336-195980062.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;修改harbor端口&quot;&gt;修改harbor端口&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;# 因为harbor默认端口是80，而大多数时候是不希望使用80端口，修改方法如下
# vim harbor.yml
# 找到port选项修改端口，然后执行./install 就会使用配置文件端口

# 还有一种情况就是更改已有harbor的配置
vim docker-compose.yml
    dns_search: .
    ports:
      - 99:80

auth:
  token:
    issuer: harbor-token-issuer
    realm: http://47.92.24.137:99/service/token
    rootcertbundle: /etc/registry/root.crt
    service: harbor-registry

docker-compose down -v
docker-compose up -d
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1871335/202006/1871335-20200614142732436-229786301.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;使用harbor&quot;&gt;使用harbor&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;为了体现出效果，建议使用非harbor的另一台机器&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;# 镜像推送
docker login 47.92.24.137:99 -u admin -p Harbor12345
vim  /etc/docker/daemon.json
{
  &quot;insecure-registries&quot;:[&quot;192.168.43.129&quot;]
}
systemctl daemon-reload
systemctl restart docker
# 因为docker默认使用的是https协议，而搭建harbor是http提供服务的，
# 所以要配置可信任,或者强制docker login和docker push 走http的80端口，而不是443端口.
docker tag daocloud.io/library/nginx:latest 192.168.43.129/library/nginx:latest

docker push 192.168.43.129/library/nginx:latest
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1871335/202006/1871335-20200614142751691-45988431.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;php部署项目流程&quot;&gt;PHP部署项目流程&lt;/h4&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;当我们把项目迁移到K8S平台上时，首先我们需要了解的是整个部署的流程，按照这个流程部署，才能避免出现问题，也方便大家理解&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1871335/202007/1871335-20200702002512717-1105447235.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;制作镜像&quot;&gt;制作镜像&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;使用Dockerfile制作镜像，把应用程序、运行环境、文件系统一起打包成一个镜像，然后推送到Harbor镜像仓库中 首先在k8s的master节点进行操作&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;[root@k8s-master ]# git clone https://github.com/zhangdongdong7/php-demo.git
[root@k8s-master ]# cd php-demo
[root@k8s-master php-demo]# ls
deployment.yaml  ingress.yaml  mysql.yaml  namespace.yaml  README.md  service.yaml  wordpress
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;使用wordpress创建一个博客网站，打开wordpress，编写Dockerfile构建镜像，然后推送到一个harbor镜像仓库中，可以看前面章节，harbor镜像的搭建，这里是使用的harbor镜像仓库地址为192.168.43.129&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;[root@k8s-master php-demo]cd wordpress
[root@k8s-master wordpress]# vim Dockerfile 
FROM lizhenliang/nginx-php:latest
MAINTAINER www.ctnrs.com
ADD . /usr/local/nginx/html

[root@k8s-master wordpress]docker login 192.168.43.129

[root@k8s-master wordpress] docker build -t 192.168.43.129/library/php-demo:latest .
  
[root@k8s-master wordpress] docker push 192.168.43.129/library/php-demo:latest
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1871335/202007/1871335-20200702000207282-264272168.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;创建控制器管理pod&quot;&gt;创建控制器管理Pod&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;回到php-demo目录编写yaml，首先部署一个test的命令空间&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;[root@k8s-master wordpress]# cd ../
[root@k8s-master php-demo]# vim namespace.yaml 
apiVersion: v1
kind: Namespace
metadata:
  name: test
[root@k8s-master php-demo]# kubectl apply -f  namespace.yaml

kubectl get ns
NAME                   STATUS   AGE
default                Active   5h59m
kube-node-lease        Active   5h59m
kube-public            Active   5h59m
kube-system            Active   5h59m
kubernetes-dashboard   Active   5h18m
test                   Active   3s
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;创建认证&quot;&gt;创建认证&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;kubectl create secret docker-registry regsecret --docker-server=192.168.43.129 --docker-username=admin --docker-password=Harbor12345 -n test
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;配置deployment控制器&quot;&gt;配置deployment控制器&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;编写deployment.yaml控制器,这里需要把image进行修改成刚才推送到Harbor镜像仓库中的地址&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;[root@k8s-master php-demo]# vim deployment.yaml 
apiVersion: apps/v1beta1
kind: Deployment
metadata:
  name: php-demo
  namespace: test
spec:
  replicas: 2
  selector:
    matchLabels:
      project: www
      app: php-demo
  template:
    metadata:
      labels:
        project: www
        app: php-demo
    spec:
      imagePullSecrets:
      - name: registry-pull-secret
      containers:
      - name: nginx
        image: 192.168.43.129/library/php-demo:latest 
        imagePullPolicy: Always
        ports:
        - containerPort: 80
          name: web
          protocol: TCP
        resources:
          requests:
            cpu: 0.5
            memory: 256Mi
          limits:
            cpu: 1
            memory: 1Gi
        resources:
          requests:
            cpu: 0.5
            memory: 256Mi
          limits:
            cpu: 1
            memory: 1Gi
        livenessProbe:
          httpGet:
            path: /status.php
            port: 80
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;pod数据持久化&quot;&gt;Pod数据持久化&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;因为是一个静态的网站,基本不需要做持久化,直接把代码打包到镜像中&lt;/code&gt;&lt;/p&gt;
&lt;h5 id=&quot;暴露应用&quot;&gt;暴露应用&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;创建一个service来暴露应用，直接使用的了ingress控制器的方式暴露应用了&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;[root@k8s-master php-demo]# vim service.yaml
apiVersion: v1
kind: Service
metadata:
  name: php-demo
  namespace: test
spec:
  selector:
    project: www
    app: php-demo
  ports:
  - name: web
    port: 80
    targetPort: 80
      
      
[root@k8s-master php-demo]# kubectl apply -f service.yaml

[root@k8s-master php-demo]# kubectl apply -f deployment.yaml 


[root@master php-demo]# kubectl get pods,svc -n test -o wide
NAME                            READY   STATUS    RESTARTS   AGE   IP            NODE     NOMINATED NODE   READINESS GATES
pod/php-demo-65bc56fdb8-grklk   1/1     Running   0          15s   10.244.0.11   master   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
pod/php-demo-65bc56fdb8-td6nv   0/1     Running   0          15s   10.244.2.7    node2    &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;

NAME               TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE     SELECTOR
service/php-demo   ClusterIP   10.0.0.221   &amp;lt;none&amp;gt;        80/TCP    4m16s   app=php-demo,project=www
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;创建ingress对外发布应用&quot;&gt;创建ingress对外发布应用&lt;/h5&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;编写yaml，首先创建ingress控制器，创建ingress，最后可以查看pod，svc，ingress的状态，全部都正常可以开始下一步，如果有异常可以使用kubectl describe命令查看日志进行排错&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;[root@k8s-master java-demo]# kubectl apply -f mandatory.yaml
[root@k8s-master php-demo]# vim ingress.yaml 
apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: php-demo
  namespace: test
spec:
  rules:
    - host: php.ctnrs.com
      http:
        paths:
        - path: /
          backend:
            serviceName: php-demo
            servicePort: 80
[root@k8s-master php-demo]# kubectl apply -f ingress.yaml 

kubectl get pods,svc,ingress -n test -o wide
NAME                            READY   STATUS    RESTARTS   AGE     IP            NODE     NOMINATED NODE   READINESS GATES
pod/php-demo-65bc56fdb8-grklk   1/1     Running   0          2m31s   10.244.0.11   master   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
pod/php-demo-65bc56fdb8-td6nv   1/1     Running   0          2m31s   10.244.2.7    node2    &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;

NAME               TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE     SELECTOR
service/php-demo   ClusterIP   10.0.0.221   &amp;lt;none&amp;gt;        80/TCP    6m32s   app=php-demo,project=www

NAME                          CLASS    HOSTS           ADDRESS   PORTS   AGE
ingress.extensions/php-demo   &amp;lt;none&amp;gt;   php.ctnrs.com             80      60s
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1871335/202007/1871335-20200702002449385-1849152069.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;可以在集群之外找一个数据库,也可以在harbor镜像仓库安装&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;docker run -d -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 daocloud.io/library/mysql:5.7.5
    
docker exec -it mysql:5.7 /bin/bash
mysql -uroot -p$MYSQL_ROOT_PASSWORD
create database wp;
grant all on youmen.* TO 'youmen'@'%' IDENTIFIED BY 'zhoujian20';

# 我们可以进入已经运行的pod修改下数据库ip,最好构建镜像时候就修改好
# 此处就不演示了,我们能访问到错误页面说明服务访问暴露是没有问题的
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;绑定hosts访问域名验证&quot;&gt;绑定hosts,访问域名验证&lt;/h5&gt;
&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;windows系统，hosts文件地址：C:\Windows\System32\drivers\etc&lt;/p&gt;
&lt;p&gt;Mac系统sudo vi /private/etc/hosts 编辑hosts文件，在底部加入域名和ip，用于解析&lt;/p&gt;
&lt;p&gt;这个ip地址为node节点ip地址 加入如下命令，然后保存&lt;/p&gt;
&lt;p&gt;在浏览器中，输入php.ctnrs.com，会跳转到初始化设置界面，设置对应的账号，然后安装，登录，然后就可以编辑文章发布了，一个简单的WordPress的php网站搭建完成&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;java项目部署流程&quot;&gt;Java项目部署流程&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1871335/202007/1871335-20200702002423768-1516332322.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;制作镜像-2&quot;&gt;制作镜像&lt;/h5&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;使用Dockerfile制作镜像，把应用程序、运行环境、文件系统一起打包成一个镜像，然后推送到Harbor镜像仓库中&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;首先在k8s的master节点进行操作&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;[root@k8s-master ]# git clone https://github.com/zhangdongdong7/java-demo.git
[root@k8s-master java-demo]# cd java-demo
[root@k8s-master java-demo]# ls
deployment.yaml  ingress.yaml    mysql.yaml      README.md     tomcat-java-demo-master.zipdeploy.yml       mandatory.yaml  namespace.yaml  service.yaml
[root@k8s-master java-demo]# unzip tomcat-java-demo-master.zip
[root@k8s-master java-demo]# cd tomcat-java-demo-master/
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;安装环境&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;[root@k8s-master tomcat-java-demo-master]# yum install java-1.8.0-openjdk maven -y
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;编译构建&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;如果maven构建慢可以使用阿里源&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;vim /etc/maven/settings.xml，大概在（159-164行），更换为如下代码&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;[root@k8s-master tomcat-java-demo-master]# vim /etc/maven/settings.xml    
    ...
    &amp;lt;mirror&amp;gt;
      &amp;lt;id&amp;gt;central&amp;lt;/id&amp;gt;
      &amp;lt;mirrorOf&amp;gt;central&amp;lt;/mirrorOf&amp;gt;
      &amp;lt;name&amp;gt;aliyun maven&amp;lt;/name&amp;gt;
      &amp;lt;url&amp;gt;https://maven.aliyun.com/repository/public&amp;lt;/url&amp;gt;
    &amp;lt;/mirror&amp;gt;
    ...
    

[root@k8s-master tomcat-java-demo-master]# ls
db  Dockerfile  LICENSE  pom.xml  README.md  src  target

# 这一次我们提前修改好数据库配置再生成镜像
vim src/main/resources/application.yml 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;在tomcat目录下创建镜像&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;[root@k8s-master tomcat-java-demo-master]# docker login 192.168.73.136
Authenticating with existing credentials…WARNING! 
Your password will be stored unencrypted in /root/.docker/config.json.Configure a credential helper to remove this warning. 
Seehttps://docs.docker.com/engine/reference/commandline/login/#credentials-storeLogin 
Succeeded

[root@k8s-master tomcat-java-demo-master]# docker build -t 192.168.43.129/library/java-demo:latest .
  
[root@k8s-master tomcat-java-demo-master]# docker push 192.168.73.136/test/java-demo:latest
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;回到上一级java-demo目录中&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;[root@k8s-master tomcat-java-demo-master]# cd ../
[root@k8s-master java-demo]# ls
db               deploy.yml    mandatory.yaml  namespace.yaml  service.yaml             tomcat-java-demo-master.zip
deployment.yaml  ingress.yaml  mysql.yaml      README.md       tomcat-java-demo-master
[root@k8s-master java-demo]#
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;创建一个test的命令空间&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;[root@k8s-master java-demo]# cat namespace.yaml 
apiVersion: v1
kind: Namespace
metadata:
  name: test namespace.yaml
[root@k8s-master java-demo]# kubectl apply -f namespace.yaml  
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;创建控制器管理pod-2&quot;&gt;创建控制器管理Pod&lt;/h5&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;编写deployment.yaml，创建pods，这里需要把image进行修改成刚才推送到Harbor镜像仓库中的地址&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;[root@k8s-master java-demo]# vim deployment.yaml 
apiVersion: apps/v1
kind: Deployment
metadata:
  name: tomcat-java-demo
  namespace: test
spec:
  replicas: 2
  selector:
    matchLabels:
      project: www
      app: java-demo
  template:
    metadata:
      labels:
        project: www
        app: java-demo
    spec:
      imagePullSecrets:
      - name: registry-pull-secret
      containers:
      - name: tomcat
        image: 192.168.73.136/test/java-demo:latest
        imagePullPolicy: Always
        ports:
        - containerPort: 8080
          name: web
          protocol: TCP
        resources:
          requests:
            cpu: 0.25
            memory: 1Gi
          limits:
            cpu: 1
            memory: 2Gi
        livenessProbe:
          httpGet:
            path: /
            port: 8080
          initialDelaySeconds: 60
          timeoutSeconds: 20
        readinessProbe:
          httpGet:
            path: /
            port: 8080
          initialDelaySeconds: 60
[root@k8s-master java-demo]# kubectl adpply -f deployment.yaml 
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;pod数据持久化-2&quot;&gt;Pod数据持久化&lt;/h5&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;这里演示的是一个静态的web网站，基本不需要做持久化，直接把代码打包到了镜像中&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;暴露应用-2&quot;&gt;暴露应用&lt;/h5&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;创建一个service来暴露应用，直接使用的了ingress控制器的方式暴露应用了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;[root@k8s-master java-demo]# cat service.yaml
apiVersion: v1
kind: Service
metadata:
  name: tomcat-java-demo
  namespace: test
spec:
  selector:
    project: www
    app: java-demo
  ports:
  - name: web
    port: 80
    targetPort: 8080
[root@k8s-master java-demo]# kubectl apply -f service.yaml  
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;创建ingress对外发布应用-2&quot;&gt;创建ingress对外发布应用&lt;/h5&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;编写yaml，因为刚才php项目创建过ingress控制器，因此可以不用创建，直接创建ingress，最后可以查看pod，svc，ingress的状态，全部都正常可以开始下一步，如果有异常可以使用kubectl describe命令查看日志进行排错&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;[root@k8s-master java-demo]# cat ingress.yaml 
apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: tomcat-java-demo 
  namespace: test
spec:
  rules:
    - host: java.ctnrs.com
      http:
        paths:
        - path: /
          backend:
            serviceName: tomcat-java-demo 
            servicePort: 80
[root@k8s-master java-demo]# kubectl apply -f ingress.yaml
[root@k8s-master java-demo]# kubectl get pod,svc,ingress -n test -o wide
NAME                                    READY   STATUS    RESTARTS   AGE   IP            NODE         NOMINATED NODE   READINESS GATES
pod/php-demo-66d9c64968-4r4vn           1/1     Running   0          24h   10.244.1.73   k8s-node01   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
pod/php-demo-66d9c64968-8zw9s           1/1     Running   0          24h   10.244.2.43   k8s-node02   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
pod/tomcat-java-demo-5f4f64dd4b-tcmtv   1/1     Running   0          24h   10.244.2.42   k8s-node02   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
pod/tomcat-java-demo-5f4f64dd4b-vvx5x   1/1     Running   0          24h   10.244.1.72   k8s-node01   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;

NAME                       TYPE        CLUSTER-IP    EXTERNAL-IP   PORT(S)        AGE   SELECTOR
service/php-demo           NodePort    10.1.136.96   &amp;lt;none&amp;gt;        80:32625/TCP   24h   app=php-demo,project=www
service/tomcat-java-demo   ClusterIP   10.1.198.15   &amp;lt;none&amp;gt;        80/TCP         24h   app=java-demo,project=www

NAME                                  HOSTS            ADDRESS   PORTS   AGE
ingress.extensions/php-demo           php.ctnrs.com              80      24h
ingress.extensions/tomcat-java-demo   java.ctnrs.com             80      24h 
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;绑定本机hosts访问域名验证&quot;&gt;绑定本机hosts,访问域名验证&lt;/h5&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;windows系统，hosts文件地址：C:\Windows\System32\drivers\etc&lt;/p&gt;
&lt;p&gt;Mac系统sudo vi /private/etc/hosts 编辑hosts文件，在底部加入域名和ip，用于解析,这里的ip是node的ip地址 加入如下命令，然后保存&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;192.168.43.120 java.ctnrs.com
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Wed, 01 Jul 2020 16:04:00 +0000</pubDate>
<dc:creator>you-men</dc:creator>
<og:description>传统部署和k8s部署区别 通常使用传统的部署的时候，我们一个web项目，网站的搭建，往往使用的如下的一种整体架构，可能有的公司在某一环节使用的东西是不一样，但是大体的框架流程是都是差不多的 使用k8s</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/you-men/p/13222462.html</dc:identifier>
</item>
<item>
<title>ibit-mybatis 2.x 介绍 - IBIT程序猿</title>
<link>http://www.cnblogs.com/javaDeveloper/p/13222407.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/javaDeveloper/p/13222407.html</guid>
<description>&lt;p&gt;原文链接：&lt;a href=&quot;https://ibit.tech/archives/ibit-mybatis-2x&quot;&gt;ibit-mybatis 2.x 介绍&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;概述&quot;&gt;概述&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;ibit-mybatis&lt;/code&gt; 是一个 Mybatis 的增强工具，在 Mybatis 的基础上增加了新的特性与功能，志在简化开发流程、提高开发效率。&lt;/p&gt;
&lt;h3 id=&quot;特性&quot;&gt;特性&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;无侵入，引入&lt;code&gt;ibit-mybatis&lt;/code&gt;对现有工程不会产生影响。&lt;/li&gt;
&lt;li&gt;无 xml 配置，基于注解的方式实现&lt;/li&gt;
&lt;li&gt;灵活的CRUD（增、删、改、查）操作，Mapper，支持常用的单表CRUD操作，更有强大的SQL构造器（&lt;a href=&quot;https://github.com/ibit-tech/sql-builder&quot;&gt;sql-builder&lt;/a&gt;），满足更为复杂的操作（如聚合函数、分组、连表、分页），为了让sql-builder更好的支持 ibit-mybatis，从 ibit-mybatis 2.0 开始，sql-builder 合并到 ibit-mybatis 中。&lt;/li&gt;
&lt;li&gt;内置代码生成器（&lt;a href=&quot;https://github.com/ibit-tech/ibit-mybatis-generator&quot;&gt;ibit-mybatis-generator&lt;/a&gt;），指定数据库表，自动生成Mapper（无主键、单主键和多主键 Mapper）、Entity、Properties等基础类，减少重复或者相似代码编写。&lt;/li&gt;
&lt;li&gt;扩展支持，数据脱敏（后续支持）&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;sql-builder描述&quot;&gt;sql-builder描述&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;sql-builder&lt;/code&gt;定义动态SQL的生成规则，用来实现单表的CRUD操作。&lt;/p&gt;
&lt;h4 id=&quot;核心-sql-接口&quot;&gt;核心 sql 接口&lt;/h4&gt;
&lt;p&gt;详细 api 文档参考：&lt;a href=&quot;https://ibit.tech/apidocs/ibit-mybatis/2.x/index.html&quot;&gt;ibit-mybatis 2.x API 文档&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;sql-接口支持&quot;&gt;sql 接口支持&lt;/h4&gt;
&lt;p&gt;不同类型的 sql， 其语句的约束不一样，下表列举所有的语句支持。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;接口&lt;/th&gt;
&lt;th&gt;支持方法&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;16&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;ColumnSupport&lt;/td&gt;
&lt;td&gt;column&lt;br/&gt;columnPo&lt;/td&gt;
&lt;td&gt;&lt;code&gt;SELECT column1[, column2...]&lt;/code&gt; 语句&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;DeleteSupport&lt;/td&gt;
&lt;td&gt;delete&lt;/td&gt;
&lt;td&gt;&lt;code&gt;DELETE t1.*&lt;/code&gt; 语句&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;DistinctSupport&lt;/td&gt;
&lt;td&gt;distinct&lt;/td&gt;
&lt;td&gt;&lt;code&gt;DISTINCT&lt;/code&gt; 语句&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;FromSupport&lt;/td&gt;
&lt;td&gt;from&lt;/td&gt;
&lt;td&gt;&lt;code&gt;FROM table1 t1[, table2 t2...]&lt;/code&gt; 语句&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;GroupBySupport&lt;/td&gt;
&lt;td&gt;groupBy&lt;/td&gt;
&lt;td&gt;&lt;code&gt;GROUP BY t1.column1[, t2.column2, ...]&lt;/code&gt;语句&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;HavingSupport&lt;/td&gt;
&lt;td&gt;having&lt;br/&gt;andHaving&lt;br/&gt;orHaving&lt;/td&gt;
&lt;td&gt;&lt;code&gt;HAVING&lt;/code&gt;语句&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;InsertTableSupport&lt;/td&gt;
&lt;td&gt;insert&lt;/td&gt;
&lt;td&gt;&lt;code&gt;INSERT INTO table1 t1&lt;/code&gt; 语句, t1表示 &quot;表别名&quot;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;JoinOnSupport&lt;/td&gt;
&lt;td&gt;joinOn&lt;br/&gt;leftJoinOn&lt;br/&gt;rightJoinOn&lt;br/&gt;fullJoinOn&lt;br/&gt;innerJoinOn&lt;br/&gt;complexLeftJoinOn&lt;br/&gt;complexRightJoinOn&lt;br/&gt;complexFullJoinOn&lt;br/&gt;complexInnerJoinOn&lt;/td&gt;
&lt;td&gt;&lt;code&gt;[LEFT\|RIGHT\|FULL\|INNER] JOIN ON&lt;/code&gt;语句&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;LimitSupport&lt;/td&gt;
&lt;td&gt;limit&lt;/td&gt;
&lt;td&gt;&lt;code&gt;LIMIT #{start}, #{limit}&lt;/code&gt;语句&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;OrderBySupport&lt;/td&gt;
&lt;td&gt;orderBy&lt;/td&gt;
&lt;td&gt;&lt;code&gt;ORDER BY&lt;/code&gt; 语句&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;SetSupport&lt;/td&gt;
&lt;td&gt;set&lt;/td&gt;
&lt;td&gt;SET 条件语句&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;UpdateTableSupport&lt;/td&gt;
&lt;td&gt;update&lt;/td&gt;
&lt;td&gt;&lt;code&gt;UPDATE table1 t1[, table2 t2...]&lt;/code&gt;语句，t1，t2表示&quot;表别名&quot;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;ValuesSupport&lt;/td&gt;
&lt;td&gt;values&lt;/td&gt;
&lt;td&gt;&lt;code&gt;(column1, column2, ...) VALUES(?, ?, ...)&lt;/code&gt;语句&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;WhereSupport&lt;/td&gt;
&lt;td&gt;where&lt;br/&gt;andWhere&lt;br/&gt;orWhere&lt;/td&gt;
&lt;td&gt;&lt;code&gt;WHERE&lt;/code&gt; 语句&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4 id=&quot;sql-工厂类&quot;&gt;sql 工厂类&lt;/h4&gt;
&lt;p&gt;工厂类：&lt;code&gt;tech.ibit.mybatis.sqlbuilder.SqlFactory&lt;/code&gt;，一般不直接使用，继承 &lt;code&gt;RawMapper&lt;/code&gt; 的 Mapper 可直接创建 &lt;code&gt;QuerySql&lt;/code&gt;、&lt;code&gt;CountSql&lt;/code&gt;、&lt;code&gt;DeleteSql&lt;/code&gt;、&lt;code&gt;InsertSql&lt;/code&gt; 和 &lt;code&gt;UpdateSql&lt;/code&gt; 对应实例。&lt;/p&gt;
&lt;h3 id=&quot;mapper-说明&quot;&gt;Mapper 说明&lt;/h3&gt;
&lt;h4 id=&quot;mapper-基础支持&quot;&gt;Mapper 基础支持&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;ibit-mybatis&lt;/code&gt; 定义了 4 种 Mapper，分别是 &lt;code&gt;RawMapper&lt;/code&gt;，&lt;code&gt;NoIdMapper&lt;/code&gt;，&lt;code&gt;SingleIdMapper&lt;/code&gt;，&lt;code&gt;MultipleIdMapper&lt;/code&gt;。以下分别说明。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Mapper 类型&lt;/th&gt;
&lt;th&gt;父接口&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;RawMapper&lt;/td&gt;
&lt;td&gt;/&lt;/td&gt;
&lt;td&gt;定义最原始的增、删、改、查和 Sql 实例创建&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;NoIdMapper&lt;/td&gt;
&lt;td&gt;RawMapper&lt;/td&gt;
&lt;td&gt;扩展无主键表的增&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;SingleIdMapper&lt;/td&gt;
&lt;td&gt;NoIdMapper&lt;/td&gt;
&lt;td&gt;扩展单主键表的根据id增、删、改、查&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;MultipleIdMapper&lt;/td&gt;
&lt;td&gt;NoIdMapper&lt;/td&gt;
&lt;td&gt;扩展多主键表的根据id增、删、改、查&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;使用 &lt;a href=&quot;https://github.com/ibit-tech/ibit-mybatis-generator&quot;&gt;ibit-mybatis-generator&lt;/a&gt; 2.x 版本，会根据表主键数量，继承不同的 Mapper。&lt;/p&gt;
&lt;h4 id=&quot;mapper-结合-sql-自定义增、删、改、查&quot;&gt;Mapper 结合 Sql 自定义增、删、改、查&lt;/h4&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Mapper 创建 Sql 实例方法&lt;/th&gt;
&lt;th&gt;实例类型&lt;/th&gt;
&lt;th&gt;实例执行方法说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;createQuery&lt;/td&gt;
&lt;td&gt;QuerySql&lt;/td&gt;
&lt;td&gt;executeQueryPage：查询（包含分页信息）&lt;br/&gt;executeQuery：查询列表&lt;br/&gt;executeQueryOne：查询单条&lt;br/&gt;executeQueryDefaultPage：查询基本类型（包含分页信息）&lt;br/&gt;executeQueryDefault：查询基本类型&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;createCount&lt;/td&gt;
&lt;td&gt;CountSql&lt;/td&gt;
&lt;td&gt;executeCount：计数&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;createDelete&lt;/td&gt;
&lt;td&gt;DeleteSql&lt;/td&gt;
&lt;td&gt;executeDelete：执行删除&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;createInsert&lt;/td&gt;
&lt;td&gt;InsertSql&lt;/td&gt;
&lt;td&gt;executeInsert：执行插入&lt;br/&gt;executeInsertWithGenerateKeys：执行插入并生成主键&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;createUpdate&lt;/td&gt;
&lt;td&gt;UpdateSql&lt;/td&gt;
&lt;td&gt;executeUpdate：执行更新&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;自定义查询例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public User getByUsername(String username) {
    if (StringUtils.isBlank(username)) {
        return null;
    }
    return mapper
            .createQuery()
            .columnPo(User.class)
            .from(UserProperties.TABLE)
            .andWhere(UserProperties.username.eq(username))
            .limit(1)
            .executeQueryOne();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;用法&quot;&gt;用法&lt;/h2&gt;
&lt;h3 id=&quot;相关引用&quot;&gt;相关引用&lt;/h3&gt;
&lt;h4 id=&quot;gradle&quot;&gt;Gradle&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;compile 'tech.ibit:ibit-mybatis:${lastest}'
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;maven&quot;&gt;Maven&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;tech.ibit&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;ibit-mybatis&amp;lt;/artifactId&amp;gt;
  &amp;lt;version&amp;gt;${latest}&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;: 将 &quot;${latest}&quot; 替换成 &lt;code&gt;2.0&lt;/code&gt; 以上版本。&lt;/p&gt;
&lt;h3 id=&quot;配置说明&quot;&gt;配置说明&lt;/h3&gt;
&lt;p&gt;需要将 Mybatis Configuration 的 &lt;code&gt;mapUnderscoreToCamelCase&lt;/code&gt; 的值设置为 true。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方式1&lt;/strong&gt;：使用 mybatis-config.xml&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;configuration&amp;gt;
    &amp;lt;settings&amp;gt;
        &amp;lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&amp;gt;
    &amp;lt;/settings&amp;gt;
&amp;lt;/configuration&amp;gt;    
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;方式2&lt;/strong&gt;：java 代码方式&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Configuration configuration = new Configuration(environment);
configuration.setMapUnderscoreToCamelCase(true);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;方式3&lt;/strong&gt;：使用了 &lt;code&gt;mybatis-spring-boot-starter&lt;/code&gt;，修改配置如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 字段映射驼峰
mybatis.configuration.map-underscore-to-camel-case=true
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;其他说明&quot;&gt;其他说明&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;ibit-mybatis&lt;/code&gt; 定义了枚举类型（&lt;code&gt;CommonEnum&lt;/code&gt;，枚举-Integer转换），其&lt;code&gt;TypeHandler&lt;/code&gt;为 &lt;code&gt;CommonEnumTypeHandler&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如果使用 &lt;code&gt;CommonEnum&lt;/code&gt; 作为系统通用枚举类，则需要做以下改造。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;a.&lt;/strong&gt; 新的枚举需要实现&lt;code&gt;CommonEnum#getValue&lt;/code&gt;方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;b.&lt;/strong&gt; SqlProvider 需要做配置&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SqlProvider.setValueFormatter(new LinkedHashMap&amp;lt;Class, Function&amp;lt;Object, Object&amp;gt;&amp;gt;() {{
    put(tech.ibit.mybatis.CommonEnum.class, o -&amp;gt; ((tech.ibit.mybatis.CommonEnum) o).getValue());
}});
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;c.&lt;/strong&gt; 修改默认的枚举 TypeHandler&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方式1&lt;/strong&gt;：使用 mybatis-config.xml&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;configuration&amp;gt;
    &amp;lt;settings&amp;gt;
        &amp;lt;setting name=&quot;defaultEnumTypeHandler&quot; value=&quot;tech.ibit.mybatis.CommonEnumTypeHandler&quot;/&amp;gt;
    &amp;lt;/settings&amp;gt;
&amp;lt;/configuration&amp;gt;    
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;方式2&lt;/strong&gt;：java 代码方式&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Configuration configuration = new Configuration(environment);
configuration.setDefaultEnumTypeHandler(tech.ibit.mybatis.CommonEnumTypeHandler.class);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;方式3&lt;/strong&gt;：使用了 &lt;code&gt;mybatis-spring-boot-starter&lt;/code&gt;，修改配置如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 指定默认的枚举处理类
mybatis.configuration.default-enum-type-handler=tech.ibit.mybatis.CommonEnumTypeHandler
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;相关项目项目&quot;&gt;相关项目项目&lt;/h2&gt;
&lt;h2 id=&quot;公众号&quot;&gt;公众号&lt;/h2&gt;
&lt;p&gt;喜欢我的文章，请关注公众号&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://x-halo.oss-cn-beijing.aliyuncs.com/halo/wechat_1589272852710.jpg&quot; alt=&quot;IBIT程序猿&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 01 Jul 2020 15:50:00 +0000</pubDate>
<dc:creator>IBIT程序猿</dc:creator>
<og:description>原文链接：ibit-mybatis 2.x 介绍 概述 ibit-mybatis 是一个 Mybatis 的增强工具，在 Mybatis 的基础上增加了新的特性与功能，志在简化开发流程、提高开发效率。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/javaDeveloper/p/13222407.html</dc:identifier>
</item>
<item>
<title>【FastDFS】FastDFS 分布式文件系统的安装与使用，看这一篇就够了！！ - 冰河团队</title>
<link>http://www.cnblogs.com/binghe001/p/13222361.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/binghe001/p/13222361.html</guid>
<description>&lt;h2 id=&quot;写在前面&quot;&gt;写在前面&lt;/h2&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;有不少小伙伴在实际工作中，对于如何存储文件（图片、视频、音频等）没有一个很好的解决思路。都明白不能将文件存储在单台服务器的磁盘上，也知道需要将文件进行副本备份。如果自己手动写文件的副本机制，那就太麻烦了，这会涉及冗余副本机制、服务器的调度、副本检测、服务器节点检测、文件副本存放策略、网络环境检测等等一系列的难题。了解Hadoop的小伙伴，会自然而然的想到HDFS，没错，HDFS可以存储文件，也能够将大文件切分成一个个文件块进行存储，还能够根据配置自动提供冗余副本机制，不用我们自己去处理复杂的冗余副本机制，也不用处理服务器的调度、副本检测、服务器节点检测、文件副本存放策略、网络环境检测等等一系列的难题。不过，HDFS适合存储大文件，原因是文件的元数据信息全部存储在NameNode节点中，如果使用HDFS大量的存储小文件，则会使NameNode的内存占用率迅速上升，NameNode节点会成为整个集群环境的瓶颈。&lt;/p&gt;

&lt;p&gt;基于种种原因的考虑，今天，我为大家推荐一款高性能的分布式文件系统——FastDFS，FastDFS同样能够提供冗余副本机制，也能够处理上述所说的种种问题。不多说了，我们进入主题吧。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;前期准备&quot;&gt;前期准备&lt;/h2&gt;
&lt;p&gt;跟踪服务器： 192.168.50.131 (liuyazhuang131)&lt;br/&gt;存储服务器： 192.168.50.132 (liuyazhuang132)&lt;br/&gt;环境： CentOS 6.5&lt;br/&gt;用户： root&lt;br/&gt;数据目录： /fastdfs （注： 数据目录按你的数据盘挂载路径而定）&lt;/p&gt;
&lt;p&gt;安装包：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;FastDFS v5.05&lt;/li&gt;
&lt;li&gt;libfastcommon-master.zip（是从 FastDFS 和 FastDHT 中提取出来的公共 C 函数库）&lt;/li&gt;
&lt;li&gt;fastdfs-nginx-module_v1.16.tar.gz&lt;/li&gt;
&lt;li&gt;nginx-1.6.2.tar.gz&lt;/li&gt;
&lt;li&gt;fastdfs_client_java._v1.25.tar.gz&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;源码地址： &lt;a href=&quot;https://github.com/happyfish100/&quot;&gt;https://github.com/happyfish100/&lt;/a&gt;&lt;br/&gt;下载地址： &lt;a href=&quot;http://sourceforge.net/projects/fastdfs/files/&quot;&gt;http://sourceforge.net/projects/fastdfs/files/&lt;/a&gt;&lt;br/&gt;官方论坛： &lt;a href=&quot;http://bbs.chinaunix.net/forum-240-1.html&quot;&gt;http://bbs.chinaunix.net/forum-240-1.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;所有服务器执行的操作&quot;&gt;所有服务器执行的操作&lt;/h2&gt;
&lt;h3 id=&quot;1、编译和安装所需的依赖包&quot;&gt;1、编译和安装所需的依赖包&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# yum install make cmake gcc gcc-c++
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;2、-安装-libfastcommon&quot;&gt;2、 安装 libfastcommon&lt;/h3&gt;
&lt;p&gt;(1)上传或下载 libfastcommon-master.zip 到/usr/local/src 目录&lt;/p&gt;
&lt;p&gt;(2)解压&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# cd /usr/local/src/
# unzip libfastcommon-master.zip
# cd libfastcommon-master
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200701233050618.png#pic_center&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;(3) 编译、安装&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# ./make.sh
# ./make.sh install
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;libfastcommon 默认安装到了如下位置。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;/usr/lib64/libfastcommon.so
/usr/lib64/libfdfsclient.so
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;(4)因为 FastDFS 主程序设置的 lib 目录是/usr/local/lib， 所以需要创建软链接&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# ln -s /usr/lib64/libfastcommon.so /usr/local/lib/libfastcommon.so
# ln -s /usr/lib64/libfastcommon.so /usr/lib/libfastcommon.so
# ln -s /usr/lib64/libfdfsclient.so /usr/local/lib/libfdfsclient.so
# ln -s /usr/lib64/libfdfsclient.so /usr/lib/libfdfsclient.so
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;3、安装-fastdfs&quot;&gt;3、安装 FastDFS&lt;/h3&gt;
&lt;p&gt;(1)上传或下载 FastDFS 源码包（FastDFS_v5.05.tar.gz） 到 /usr/local/src 目录&lt;/p&gt;
&lt;p&gt;(2)解压&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# cd /usr/local/src/
# tar -zxvf FastDFS_v5.05.tar.gz
# cd FastDFS
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200701233115412.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;(3)编译、 安装（编译前要确保已经成功安装了 libfastcommon）&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# ./make.sh
# ./make.sh install
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;采用默认安装的方式安装,安装后的相应文件与目录：&lt;/p&gt;
&lt;p&gt;A、 服务脚本在：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;/etc/init.d/fdfs_storaged
/etc/init.d/fdfs_tracker
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;B、 配置文件在（样例配置文件）&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;/etc/fdfs/client.conf.sample
/etc/fdfs/storage.conf.sample
/etc/fdfs/tracker.conf.sample
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;C、 命令工具在/usr/bin/目录下的&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;fdfs_appender_test
fdfs_appender_test1
fdfs_append_file
fdfs_crc32
fdfs_delete_file
fdfs_download_file
fdfs_file_info
fdfs_monitor
fdfs_storaged
fdfs_test
fdfs_test1
fdfs_trackerd
fdfs_upload_appender
fdfs_upload_file
stop.sh
restart.sh
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;(4)因为 FastDFS 服务脚本设置的 bin 目录是/usr/local/bin， 但实际命令安装在/usr/bin， 可以进入/user/bin 目录使用以下命令查看 fdfs 的相关命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# cd /usr/bin/
# ls | grep fdfs
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200701233140455.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;因此需要修改 FastDFS 服务脚本中相应的命令路径，也就是把/etc/init.d/fdfs_storaged和/etc/init.d/fdfs_trackerd 两个脚本中的/usr/local/bin 修改成/usr/bin：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# vi fdfs_trackerd
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用查找替换命令进统一修改:%s+/usr/local/bin+/usr/bin&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# vi fdfs_storaged
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用查找替换命令进统一修改:%s+/usr/local/bin+/usr/bin&lt;/p&gt;
&lt;p&gt;&lt;code&gt;注：使用查找替换命令为进入vi / vim编辑器，按下esc键，输入冒号(:),再输入%s+/usr/local/bin+/usr/bin即可把所有的/usr/local/bin修改为/usr/bin&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;配置-fastdfs-跟踪器19216850131&quot;&gt;配置 FastDFS 跟踪器(192.168.50.131)&lt;/h2&gt;
&lt;h3 id=&quot;1、复制-fastdfs-跟踪器样例配置文件&quot;&gt;1、复制 FastDFS 跟踪器样例配置文件&lt;/h3&gt;
&lt;p&gt;复制 FastDFS 跟踪器样例配置文件,并重命名:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# cd /etc/fdfs/
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200701233244562.png#pic_center&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# cp tracker.conf.sample tracker.conf
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;2、编辑跟踪器配置文件&quot;&gt;2、编辑跟踪器配置文件&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# vi /etc/fdfs/tracker.conf
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改的内容如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;disabled=false
port=22122
base_path=/fastdfs/tracker
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（其它参数保留默认配置， 具体配置解释请参考官方文档说明：&lt;a href=&quot;http://bbs.chinaunix.net/thread-1941456-1-1.html&quot;&gt;http://bbs.chinaunix.net/thread-1941456-1-1.html&lt;/a&gt; ）&lt;/p&gt;
&lt;h3 id=&quot;3、创建基础数据目录（参考基础目录-base_path-配置）&quot;&gt;3、创建基础数据目录（参考基础目录 base_path 配置）&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# mkdir -p /fastdfs/tracker
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;4、防火墙中打开跟踪器端口（默认为-22122）&quot;&gt;4、防火墙中打开跟踪器端口（默认为 22122）&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# vi /etc/sysconfig/iptables
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;添加如下端口行：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;-A INPUT -m state --state NEW -m tcp -p tcp --dport 22122 -j ACCEPT
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;重启防火墙&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# service iptables restart
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;5、启动-tracker&quot;&gt;5、启动 Tracker&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# /etc/init.d/fdfs_trackerd start
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（初次成功启动，会在/fastdfs/tracker 目录下创建 data、 logs 两个目录）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200701233324421.png#pic_center&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;查看 FastDFS Tracker 是否已成功启动。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# ps -ef | grep fdfs
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200701233336458.png#pic_center&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;6、-关闭-tracker&quot;&gt;6、 关闭 Tracker&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# /etc/init.d/fdfs_trackerd stop
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;7、设置-fastdfs-跟踪器开机启动&quot;&gt;7、设置 FastDFS 跟踪器开机启动&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# vi /etc/rc.d/rc.local
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;添加以下内容&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;## FastDFS Tracker
/etc/init.d/fdfs_trackerd start
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;配置-fastdfs-存储19216850132&quot;&gt;配置 FastDFS 存储(192.168.50.132)&lt;/h2&gt;
&lt;h3 id=&quot;1、-复制-fastdfs-存储器样例配置文件&quot;&gt;1、 复制 FastDFS 存储器样例配置文件&lt;/h3&gt;
&lt;p&gt;复制 FastDFS 存储器样例配置文件,并重命名&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# cd /etc/fdfs/
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2020070123335179.png#pic_center&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# cp storage.conf.sample storage.conf
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;2、编辑存储器样例配置文件&quot;&gt;2、编辑存储器样例配置文件&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# vi /etc/fdfs/storage.conf
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改的内容如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;disabled=false
port=23000
base_path=/fastdfs/storage
store_path0=/fastdfs/storage
tracker_server=192.168.50.131:22122
http.server_port=8888
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（其它参数保留默认配置， 具体配置解释请参考官方文档说明：&lt;a href=&quot;http://bbs.chinaunix.net/thread-1941456-1-1.html&quot;&gt;http://bbs.chinaunix.net/thread-1941456-1-1.html&lt;/a&gt; ）&lt;/p&gt;
&lt;h3 id=&quot;3、创建基础数据目录（参考基础目录-base_path-配置）-2&quot;&gt;3、创建基础数据目录（参考基础目录 base_path 配置）&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# mkdir -p /fastdfs/storage
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;4、-防火墙中打开存储器端口（默认为-23000）&quot;&gt;4、 防火墙中打开存储器端口（默认为 23000）&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# vi /etc/sysconfig/iptables
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;添加如下端口行：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;-A INPUT -m state --state NEW -m tcp -p tcp --dport 23000 -j ACCEPT
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;重启防火墙：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# service iptables restart
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;5、启动-storage&quot;&gt;5、启动 Storage&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# /etc/init.d/fdfs_storaged start
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（初次成功启动，会在/fastdfs/storage 目录下创建 data、 logs 两个目录）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200701233414395.png#pic_center&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;查看 FastDFS Storage 是否已成功启动&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# ps -ef | grep fdfs
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200701233428866.png#pic_center&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;6、关闭-storage&quot;&gt;6、关闭 Storage&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# /etc/init.d/fdfs_storaged stop
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;7、设置-fastdfs-存储器开机启动&quot;&gt;7、设置 FastDFS 存储器开机启动&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# vi /etc/rc.d/rc.local
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;添加：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;## FastDFS Storage
/etc/init.d/fdfs_storaged start
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;文件上传测试19216850131&quot;&gt;文件上传测试(192.168.50.131)&lt;/h2&gt;
&lt;h3 id=&quot;1、修改-tracker-服务器中的客户端配置文件&quot;&gt;1、修改 Tracker 服务器中的客户端配置文件&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# cp /etc/fdfs/client.conf.sample /etc/fdfs/client.conf
# vi /etc/fdfs/client.conf
base_path=/fastdfs/tracker
tracker_server=192.168.50.131:22122
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;2、执行如下文件上传命令&quot;&gt;2、执行如下文件上传命令&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# /usr/bin/fdfs_upload_file /etc/fdfs/client.conf /usr/local/src/FastDFS_v5.05.tar.gz
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;返回 ID 号： group1/M00/00/00/wKgEfVUYNYeAb7XFAAVFOL7FJU4.tar.gz（能返回以上文件 ID， 说明文件上传成功）&lt;/p&gt;
&lt;h2 id=&quot;在每个存储节点上安装-nginx&quot;&gt;在每个存储节点上安装 nginx&lt;/h2&gt;
&lt;h3 id=&quot;1、-fastdfs-nginx-module-作用说明&quot;&gt;1、 fastdfs-nginx-module 作用说明&lt;/h3&gt;
&lt;p&gt;FastDFS 通过 Tracker 服务器,将文件放在 Storage 服务器存储， 但是同组存储服务器之间需要进入文件复制， 有同步延迟的问题。假设 Tracker 服务器将文件上传到了 192.168.50.132，上传成功后文件 ID已经返回给客户端。此时 FastDFS 存储集群机制会将这个文件同步到同组存储 192.168.50.133，在文件还没有复制完成的情况下，客户端如果用这个文件 ID 在 192.168.50.133 上取文件,就会出现文件无法访问的错误。而 fastdfs-nginx-module 可以重定向文件连接到源服务器取文件,避免客户端由于复制延迟导致的文件无法访问错误。（解压后的 fastdfs-nginx-module 在 nginx 安装时使用）&lt;/p&gt;
&lt;h3 id=&quot;2、上传-fastdfs-nginx-module_v116targz-到usrlocalsrc&quot;&gt;2、上传 fastdfs-nginx-module_v1.16.tar.gz 到/usr/local/src&lt;/h3&gt;
&lt;h3 id=&quot;3、解压&quot;&gt;3、解压&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# cd /usr/local/src/
# tar -zxvf fastdfs-nginx-module_v1.16.tar.gz
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;4、修改-fastdfs-nginx-module-的-config-配置文件&quot;&gt;4、修改 fastdfs-nginx-module 的 config 配置文件&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# cd fastdfs-nginx-module/src
# vi config
CORE_INCS=&quot;$CORE_INCS /usr/local/include/fastdfs /usr/local/include/fastcommon/&quot;
修改为：
CORE_INCS=&quot;$CORE_INCS /usr/include/fastdfs /usr/include/fastcommon/&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（注意： 这个路径修改是很重要的，不然在 nginx 编译的时候会报错的）&lt;/p&gt;
&lt;h3 id=&quot;5、上传当前的稳定版本-nginxnginx-1130targz到usrlocalsrc-目录&quot;&gt;5、上传当前的稳定版本 Nginx(nginx-1.13.0.tar.gz)到/usr/local/src 目录&lt;/h3&gt;
&lt;h3 id=&quot;6、安装编译-nginx-所需的依赖包&quot;&gt;6、安装编译 Nginx 所需的依赖包&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# yum install gcc gcc-c++ make automake autoconf libtool pcre* zlib openssl openssl-devel
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;7、编译安装-nginx（添加-fastdfs-nginx-module-模块）&quot;&gt;7、编译安装 Nginx（添加 fastdfs-nginx-module 模块）&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# cd /usr/local/src/
# tar -zxvf nginx-1.13.0.tar.gz
# cd nginx-1.13.0
# ./configure --add-module=/usr/local/src/fastdfs-nginx-module/src
# make &amp;amp;&amp;amp; make install
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;8、复制-fastdfs-nginx-module&quot;&gt;8、复制 fastdfs-nginx-module&lt;/h3&gt;
&lt;p&gt;复制 fastdfs-nginx-module 源码中的配置文件到/etc/fdfs 目录， 并修改&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# cp /usr/local/src/fastdfs-nginx-module/src/mod_fastdfs.conf /etc/fdfs/
# vi /etc/fdfs/mod_fastdfs.conf
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改以下配置：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;connect_timeout=10
base_path=/tmp
tracker_server=192.168.50.131:22122
storage_server_port=23000
group_name=group1
url_have_group_name = true
store_path0=/fastdfs/storage
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;9、复制-fastdfs-的部分配置文件到etcfdfs-目录&quot;&gt;9、复制 FastDFS 的部分配置文件到/etc/fdfs 目录&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# cd /usr/local/src/FastDFS/conf
# cp http.conf mime.types /etc/fdfs/
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;10、在fastdfsstorage-文件存储目录下创建软连接将其链接到实际存放数据的目录&quot;&gt;10、在/fastdfs/storage 文件存储目录下创建软连接,将其链接到实际存放数据的目录&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# ln -s /fastdfs/storage/data/ /fastdfs/storage/data/M00
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;11、配置-nginx&quot;&gt;11、配置 Nginx&lt;/h3&gt;
&lt;p&gt;简洁版 nginx 配置样例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;user root;
worker_processes 1;
events {
        worker_connections 1024;
}
http {
        include mime.types;
        default_type application/octet-stream;
        sendfile on;
        keepalive_timeout 65;
        server {
                listen 8888;
                server_name localhost;
                location ~/group([0-9])/M00 {
                        #alias /fastdfs/storage/data;
                        ngx_fastdfs_module;
                }
                error_page 500 502 503 504 /50x.html;
                location = /50x.html {
                        root html;
                }
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意、 说明：&lt;br/&gt;A、 8888 端口值是要与/etc/fdfs/storage.conf 中的 http.server_port=8888 相对应，因为 http.server_port 默认为 8888,如果想改成 80，则要对应修改过来。&lt;br/&gt;B、 Storage 对应有多个 group 的情况下，访问路径带 group 名，如/group1/M00/00/00/xxx，对应的 Nginx 配置为：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;location ~/group([0-9])/M00 {
        ngx_fastdfs_module;
} 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;C、 如查下载时如发现老报 404， 将 nginx.conf 第一行 user nobody 修改为 user root 后重新启动。&lt;/p&gt;
&lt;h3 id=&quot;12、防火墙中打开-nginx-的-8888-端口&quot;&gt;12、防火墙中打开 Nginx 的 8888 端口&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# vi /etc/sysconfig/iptables
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;添加：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;-A INPUT -m state --state NEW -m tcp -p tcp --dport 8888 -j ACCEPT
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;重启防火墙&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# service iptables restart
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;13、启动-nginx&quot;&gt;13、启动 Nginx&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# /usr/local/nginx/sbin/nginx
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动成功后会输入：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;ngx_http_fastdfs_set pid=xxx
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（重启 Nginx 的命令为： /usr/local/nginx/sbin/nginx -s reload）&lt;/p&gt;
&lt;h3 id=&quot;14、通过浏览器访问测试时上传的文件&quot;&gt;14、通过浏览器访问测试时上传的文件&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;http://192.168.50.132:8888/group1/M00/00/00/wKgyhFkWubGAcwrWAAVFOL7FJU4.tar.gz&quot;&gt;http://192.168.50.132:8888/group1/M00/00/00/wKgyhFkWubGAcwrWAAVFOL7FJU4.tar.gz&lt;/a&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200701233512197.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;strong&gt;注意： 千万不要使用 kill -9 命令强杀 FastDFS 进程，否则可能会导致 binlog 数据丢失。另外，大家可以到链接&lt;a href=&quot;http://download.csdn.net/detail/l1028386804/9841444&quot;&gt;http://download.csdn.net/detail/l1028386804/9841444&lt;/a&gt;下载FastDFS_v5.05_安装包、工具包&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;好了，咱们今天就聊到这儿吧！别忘了给个在看和转发，让更多的人看到，一起学习一起进步！！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;写在最后&quot;&gt;写在最后&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;如果觉得文章对你有点帮助，请微信搜索并关注「 冰河技术 」微信公众号，跟冰河学习分布式存储技术。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Wed, 01 Jul 2020 15:41:00 +0000</pubDate>
<dc:creator>冰河团队</dc:creator>
<og:description>写在前面 有不少小伙伴在实际工作中，对于如何存储文件（图片、视频、音频等）没有一个很好的解决思路。都明白不能将文件存储在单台服务器的磁盘上，也知道需要将文件进行副本备份。如果自己手动写文件的副本机制，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/binghe001/p/13222361.html</dc:identifier>
</item>
</channel>
</rss>