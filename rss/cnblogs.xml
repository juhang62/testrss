<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>XML的相关基础知识分享(二) - 萌萌丶小魔王</title>
<link>http://www.cnblogs.com/xiaomowang/p/12376035.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaomowang/p/12376035.html</guid>
<description>&lt;p&gt;&lt;span&gt;前面我们讲了一下&lt;a href=&quot;https://www.cnblogs.com/xiaomowang/p/11504426.html&quot; target=&quot;_blank&quot;&gt;XML相关的基础知识(一)&lt;/a&gt;，下面我们在加深一下，看一下XML高级方面。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一、命名空间&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、命名冲突&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;XML命名空间提供避免元素冲突的方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;命名冲突：在XML中，元素名称是由开发者定义的，当两个不同的文档使用相同的原俗名时，就会发生命名冲突。例如：下面这个XML文档携带者某个表格中的信息：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;1&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;table&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Apples&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Bananas&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt;    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;table&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个XML文档携带有关桌子的信息（一件家具）：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;1&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;table&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;African Coffee Table&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;width&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;80&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;width&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;length&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;120&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;length&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;table&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;假如这两个XML文档被一起使用，由于两个文档都包含带有不同内容和定义的&amp;lt;table&amp;gt;元素，就会发生命名冲突。XML解析器无法确定如何处理这类冲突。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、使用前缀来避免命名冲突&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;此文档带有某个表格的信息：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;table&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;African Coffee Table&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;width&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;80&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;width&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;length&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;120&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;length&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;table&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;此XML文档携带着有关一件家具的信息：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;f:table&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;f:name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;African Coffee Table&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;f:name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;f:width&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;80&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;f:width&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;f:length&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;120&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;f:length&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;f:table&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;现在，命名冲突不存在了，这是由于两个文档都使用了不同的名称来命名他们&amp;lt;table&amp;gt;元素(&amp;lt;h:table&amp;gt;和&amp;lt;f:table&amp;gt;)，通过使用前缀，我们创建了两种不同类型的&amp;lt;table&amp;gt;元素。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、使用命名空间&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个XML文档携带着某个表格的信息：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h:table &lt;/span&gt;&lt;span&gt;xmlns:h&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/TR/html4/&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h:tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h:td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Apples&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h:td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h:td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Bananas&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h:td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h:tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h:table&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;此XML文档携带着有关一件家具的信息：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;f:table &lt;/span&gt;&lt;span&gt;xmlns:f&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3school.com.cn/furniture&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;f:name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;African Coffee Table&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;f:name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;f:width&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;80&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;f:width&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;f:length&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;120&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;f:length&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;f:table&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;与仅仅使用前缀不同，我们为&amp;lt;table&amp;gt;标间添加了一个xmlns属性，这样就为前缀赋予了一个与某个命名控件相关联的限定名称。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、XML Namespace（xmlns）属性&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;XML命名空间属性被放置于元素的开始标间之中，并使用语法：xmlns:namespace-prefix=&quot;namespaceURI&quot;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当命名空间被定义在元素的开始标签中时，所有带有相同前缀的子元素都会与同一个命名空间关联。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注释：用于标示命名空间的地址不会被解析器用于查找信息，其唯一的作用是赋予命名空间一个唯一的名称，不过，很多公司常会作为指针来使用命名空间指向实际存在的网页，这个网页包含命名空间的信息。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4、统一资源标识符（Uniform Resource Identifier（URL））&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;统一资源标识符是一串可以标识因特网资源的字符。最常用的URI是用来标识因特网域名地址的统一资源定位器（URL），另一个不那么常用的URI是统一资源命名（URN）。在我们的例子中，我们仅使用URL。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5、默认的命名空间（Default Namespace）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为元素定义默认的命名空间可以让我们省去在所有子元素中使用前缀的工作。语法：xmlns=&quot;namespaceURI&quot;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个XML文档携带着某个表格中的信息：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;table &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/TR/html4/&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Apples&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Bananas&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;table&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;此XML文档携带着有关一件家具的信息：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;table &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3school.com.cn/furniture&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;African Coffee Table&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;width&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;80&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;width&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;length&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;120&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;length&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;table&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6、命名空间的实际应用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当开始使用XSL时，您不久就会看到实际使用中的命名空间。XSL样式表用于将XML文档转换为其他格式，比如HTML。如果您仔细观察下面这个XSL文档，就会看到大多数的标签都是HTML标签。非HTML的标签都有前缀xsl，并由此命名空间标示：“http://www.w3.org/1999/XSL/Transform”：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;xsl:stylesheet &lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;=&quot;1.0&quot;&lt;/span&gt;&lt;span&gt; xmlns:xsl&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/1999/XSL/Transform&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;xsl:template &lt;/span&gt;&lt;span&gt;match&lt;/span&gt;&lt;span&gt;=&quot;/&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h2&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;My CD Collection&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h2&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;table &lt;/span&gt;&lt;span&gt;border&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;th &lt;/span&gt;&lt;span&gt;align&lt;/span&gt;&lt;span&gt;=&quot;left&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Title&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;th&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;th &lt;/span&gt;&lt;span&gt;align&lt;/span&gt;&lt;span&gt;=&quot;left&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Artist&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;th&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;xsl:for-each &lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;=&quot;catalog/cd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;xsl:value-of &lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;=&quot;title&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;xsl:value-of &lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;=&quot;artist&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;xsl:for-each&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;table&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;xsl:template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;xsl:stylesheet&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; 二、CDATA区段&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所有XML文档中的文本均会被解析器解析，只有CDATA区段（CDATA section）中的文本会被解析器忽略。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、PCDATA&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;PCDATA指的是被解析的字符数据（Parsed Character Data）。XML解析器通常会解析XML文档中所有的文本，当某个XML元素被解析时，其标签之间的文本也会被解析，如：&amp;lt;message&amp;gt;此文本也会被解析&amp;lt;/message&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;解析器之所以这么做是因为XML元素可以包含其他元素，就像下面例子中&amp;lt;name&amp;gt;元素包含着另外的两个元素first和last：&amp;lt;name&amp;gt;&amp;lt;first&amp;gt;Bill&amp;lt;/first&amp;gt;&amp;lt;last&amp;gt;Gates&amp;lt;/last&amp;gt;&amp;lt;/name&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而解析器会把它分解为像这样的子元素：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;first&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Bill&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;first&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;last&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Gates&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;last&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、转义字符&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;非法的XML字符必须被替换为实体引用（entity reference）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;假如您在XML文档中放置了一个类似“&amp;lt;”的字符，那么这个文档会产生一个错误，这是因为解析器会把它解释为新元素的开始，因此你不能这样写：&amp;lt;message&amp;gt;if salary &amp;lt; 1000 then&amp;lt;/message&amp;gt;。为了避免此类错误，需要把字符“&amp;lt;”替换为实体引用，就像这样：&amp;lt;message&amp;gt;if salary &amp;amp;lt; 1000 then&amp;lt;/message&amp;gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在XML中，有5个预定义的实体引用：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/799221/202003/799221-20200301155325456-292124513.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 注释：严格的讲，在XML中仅有字符“&amp;lt;”和“&amp;amp;”是非法的，省略号，引号和大于号是合法的，但是把他们替换为实体引用是个好习惯。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、CDATA&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;术语CDATA指的是不应由XML解析器进行解析的文本数据（Unparsed Character Data）。在XML元素中，“&amp;lt;”和“&amp;amp;”是非法的。&quot;&amp;lt;&quot;会产生错误，因为解析器会把该字符解释为新元素的开始。&quot;&amp;amp;&quot;也会产生错误，因为解析器会把该字符解析为字符实体的开始。某些文本，比如JavaScript代码，包含大量的“&amp;lt;&quot;和“&amp;amp;”字符，为了避免错误，可以将脚本代码定义为CDATA。CDATA部分中的所有内容都会被解析器忽略。CDATA部分由&quot;&amp;lt;![CDATA[&quot;开始，由“]]&amp;gt;”结束：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;![CDATA[&lt;/span&gt;&lt;span&gt;
function matchwo(a,b)
{
if (a &amp;lt; b &amp;amp;&amp;amp; a &amp;lt; 0) then
  {
  return 1;
  }
else
  {
  return 0;
  }
}
&lt;/span&gt;&lt;span&gt;]]&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在上面的例子中，解析器会忽略CDATA部分中的所有内容。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意：CDATA部分不能包含字符串”]]&amp;gt;“，也不允许嵌套的CDATA部分。标记CDATA部分结尾的”]]&amp;gt;“不能包含空格或折行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;好了，关于这次的XML相关知识分享，本次就先到这里。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 02 Mar 2020 00:39:00 +0000</pubDate>
<dc:creator>萌萌丶小魔王</dc:creator>
<og:description>前面我们讲了一下XML相关的基础知识(一)，下面我们在加深一下，看一下XML高级方面。 一、命名空间 1、命名冲突 XML命名空间提供避免元素冲突的方法。 命名冲突：在XML中，元素名称是由开发者定义</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiaomowang/p/12376035.html</dc:identifier>
</item>
<item>
<title>上周 GitHub 热点速览 vol.09：手撕 LeetCode 一日 star 破两千 - 削微寒</title>
<link>http://www.cnblogs.com/xueweihan/p/12391823.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xueweihan/p/12391823.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/202003/759200-20200301202441164-184740857.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;作者：HelloGitHub-&lt;strong&gt;小鱼干&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;摘要：上周 GitHub 趋势榜相较上上周就如同前故事一般，跌到不行，无论是新晋开源小项，还是坚挺老项目，Star 增长量都不如之前，即使“大环境”欠佳，但是有些新开源项目的表现让人眼前一亮，比如开源 6 天 star 破 3k 的 UI Heroicons 是当之无愧的上周热门项目，其他的项目虽表现平平，也不妨碍 HelloGitHub 觉得他们是个值得推荐给你的项目 👀 或许是月底综合症导致大家的 star 兴致不高呢&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以下内容摘录自上周微博的 GitHub Trending，选项标准：&lt;code&gt;新发布&lt;/code&gt; | &lt;code&gt;实用&lt;/code&gt; | &lt;code&gt;有趣&lt;/code&gt;，根据项目 release 时间分类，发布时间超过 30 天的项目一律称之为成熟稳重老项目，由于文章篇幅问题还有部分项目未能在本文展示，望周知 🌝&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;本文目录
&lt;ul&gt;&lt;li&gt;
&lt;ol&gt;&lt;li&gt;可怕 GitHub 新生&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;1.1 数据分析：PostHog&lt;/li&gt;
&lt;li&gt;1.2 建站神器：goxygen&lt;/li&gt;
&lt;li&gt;1.3 收藏夹+1：25 most recommended programming books of all-time&lt;/li&gt;
&lt;li&gt;1.4 视频工具：Free-HLS&lt;/li&gt;
&lt;li&gt;1.5 UI icon：Heroicons&lt;/li&gt;
&lt;li&gt;1.6 事件管理器：Dispatch&lt;/li&gt;
&lt;li&gt;1.7 刷题吗？：fucking-algorithm&lt;/li&gt;
&lt;li&gt;1.8 高校资源：AI Curriculum&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ol&gt;&lt;li&gt;尚能星否 GitHub 老项目&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;2.1 iOS 虚拟机：UTM&lt;/li&gt;
&lt;li&gt;2.2 Python 实践：pytudes&lt;/li&gt;
&lt;li&gt;2.3 图片处理：BlurHash&lt;/li&gt;
&lt;li&gt;2.4 机器学习作业：coursera-ml-py&lt;/li&gt;
&lt;li&gt;2.5 Java 实操：flink-recommandSystem-demo&lt;/li&gt;
&lt;li&gt;2.6 应用 Case：industry-machine-learning&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ol&gt;&lt;li&gt;本周 GitHub Trending #前端专场#主题的主力军&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;3.1 前端测试：Front-End-Checklist&lt;/li&gt;
&lt;li&gt;3.2 前端小框架：Alpine.js&lt;/li&gt;
&lt;li&gt;3.3 Demo 之母：RealWorld&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;可怕-github-新生&quot;&gt;1. 可怕 GitHub 新生&lt;/h2&gt;
&lt;h3 id=&quot;数据分析posthog&quot;&gt;1.1 数据分析：PostHog&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：300+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;PostHog 是一个为 Devs 准备的数据分析工具，它能帮你监控网站 / App 的每个事件用来做用户数据分析，只要一键部署即可通过 API / SQL 来访问数据。 ​​​​&lt;/p&gt;
&lt;blockquote readability=&quot;1.6&quot;&gt;
&lt;p&gt;GitHub 地址→&lt;a href=&quot;https://github.com/PostHog/posthog&quot; class=&quot;uri&quot;&gt;https://github.com/PostHog/posthog&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/202003/759200-20200301202453752-705758246.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;建站神器goxygen&quot;&gt;1.2 建站神器：goxygen&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：700+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;goxygen 可以让你在几秒钟内构建一个 Web 项目，前端使用 React ，后端代码由 Golang 生成，而数据库方便采用的是 MongoDB。&lt;/p&gt;
&lt;blockquote readability=&quot;1.6326530612245&quot;&gt;
&lt;p&gt;GitHub 地址→&lt;a href=&quot;https://github.com/Shpota/goxygen&quot; class=&quot;uri&quot;&gt;https://github.com/Shpota/goxygen&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/202003/759200-20200301202506149-1461904205.gif&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;收藏夹125-most-recommended-programming-books-of-all-time&quot;&gt;1.3 收藏夹+1：25 most recommended programming books of all-time&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：400+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;25 most recommended programming books of all-time 收录了 25 本值得推荐阅读的编程书籍，包括：代码简洁之道、算法、编程艺术等方面内容。 ​​​​&lt;/p&gt;
&lt;blockquote readability=&quot;1.0666666666667&quot;&gt;
&lt;p&gt;GitHub 地址→&lt;a href=&quot;https://github.com/daolf/Most-recommended-programming-books&quot; class=&quot;uri&quot;&gt;https://github.com/daolf/Most-recommended-programming-books&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/202003/759200-20200301202520150-535167211.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;视频工具free-hls&quot;&gt;1.4 视频工具：Free-HLS&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：150+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Free-HLS 是一个免费的 HLS 视频解决方案，即所谓的视频床。本项目提供一整套集成化解决方案，囊括了各环节所需的切片、转码、上传、即时分享等套件。让你可以以更方便、更低廉的方式分享你的视频到任意地方。&lt;/p&gt;
&lt;blockquote readability=&quot;1.6&quot;&gt;
&lt;p&gt;GitHub 地址→&lt;a href=&quot;https://github.com/sxyazi/free-hls&quot; class=&quot;uri&quot;&gt;https://github.com/sxyazi/free-hls&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;ui-iconheroicons&quot;&gt;1.5 UI icon：Heroicons&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：3000+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Heroicons 是一个可免费使用的 SVG 项目，项目尚在更新目前 icon 数量为 140 个。 ​​​​&lt;/p&gt;
&lt;blockquote readability=&quot;1.3793103448276&quot;&gt;
&lt;p&gt;GitHub 地址→&lt;a href=&quot;https://github.com/refactoringui/heroicons&quot; class=&quot;uri&quot;&gt;https://github.com/refactoringui/heroicons&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/202003/759200-20200301202529302-1710825421.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;事件管理器dispatch&quot;&gt;1.6 事件管理器：Dispatch&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：1100+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Dispatch 是 Netflix 开源的安全事件管理器，它通过高度集成现有的管理工具，例如 Slack、GSuite、Jira 来管理事件，它可以让你专注于创建资源、集合参与者、发送通知、跟踪任务、协助事件评审。&lt;/p&gt;
&lt;blockquote readability=&quot;1.5686274509804&quot;&gt;
&lt;p&gt;GitHub 地址→&lt;a href=&quot;https://github.com/Netflix/dispatch&quot; class=&quot;uri&quot;&gt;https://github.com/Netflix/dispatch&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/202003/759200-20200301202539352-1801820865.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;刷题吗fucking-algorithm&quot;&gt;1.7 刷题吗？：fucking-algorithm&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：2800+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;fucking-algorithm 是一个总结 LeetCode 刷题思路和技巧的项目，在短短 2 天之内获得 1k+ 个 star，该项目不是简单地刷题，而是帮你培养解题思维，希望这份小抄能帮你打开升职加薪大门。&lt;/p&gt;
&lt;blockquote readability=&quot;1.2698412698413&quot;&gt;
&lt;p&gt;GitHub 地址→&lt;a href=&quot;https://github.com/labuladong/fucking-algorithm&quot; class=&quot;uri&quot;&gt;https://github.com/labuladong/fucking-algorithm&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/202003/759200-20200301202549558-1425665198.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;高校资源ai-curriculum&quot;&gt;1.8 高校资源：AI Curriculum&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：650+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;AI Curriculum 是一个收录 斯坦福大学，麻省理工学院和加州大学伯克利分校等顶尖大学深度学习和强化学习讲座的项目，目前你可以学到：深度学习导论、视觉识别 CNN、NLP、深度学习进阶等内容。&lt;/p&gt;
&lt;blockquote readability=&quot;1.1267605633803&quot;&gt;
&lt;p&gt;GitHub 地址→&lt;a href=&quot;https://github.com/Machine-Learning-Tokyo/AI_Curriculum&quot; class=&quot;uri&quot;&gt;https://github.com/Machine-Learning-Tokyo/AI_Curriculum&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/202003/759200-20200301202605166-1496182788.gif&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;尚能星否-github-老项目&quot;&gt;2. 尚能星否 GitHub 老项目&lt;/h2&gt;
&lt;h3 id=&quot;ios-虚拟机utm&quot;&gt;2.1 iOS 虚拟机：UTM&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：1500+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;UTM 是一个国外大佬开发的 iOS 虚拟机，允许你在 iPhone 或 iPad 等苹果设备上运行 Windows 和 Linux。它主要有以下特点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;依托 QEMU 支持 30+ 种处理器，包括 x86_64，ARM64 和 RISC-V；&lt;/li&gt;
&lt;li&gt;用 SPICE 实现快速本地图形处理；&lt;/li&gt;
&lt;li&gt;用 QWMU TCG 实现 JIT 加速；&lt;/li&gt;
&lt;li&gt;无需越狱；&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;1.7777777777778&quot;&gt;
&lt;p&gt;GitHub 地址→&lt;a href=&quot;https://github.com/utmapp/UTM&quot; class=&quot;uri&quot;&gt;https://github.com/utmapp/UTM&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/202003/759200-20200301202615437-367055842.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;python-实践pytudes&quot;&gt;2.2 Python 实践：pytudes&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：1050+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;少年想学 Python 吗？Pytudes 是 Google 大佬总结的 Python 编程示范代码。 ​​​​&lt;/p&gt;
&lt;blockquote readability=&quot;1.6326530612245&quot;&gt;
&lt;p&gt;GitHub 地址→&lt;a href=&quot;https://github.com/norvig/pytudes&quot; class=&quot;uri&quot;&gt;https://github.com/norvig/pytudes&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/202003/759200-20200301202628264-1049682.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;图片处理blurhash&quot;&gt;2.3 图片处理：BlurHash&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：550+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;BlurHash 是一个图像占位符，它允许你加载图片时显示模糊色块来缓解图片未加载的尴尬，同样的，它也支持将清晰的图片模糊化。该项目目前有 C、Swift、Kotlin、Typescript、Python 等版本。&lt;/p&gt;
&lt;blockquote readability=&quot;1.5686274509804&quot;&gt;
&lt;p&gt;GitHub 地址→&lt;a href=&quot;https://github.com/woltapp/blurhash&quot; class=&quot;uri&quot;&gt;https://github.com/woltapp/blurhash&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/202003/759200-20200301202639789-2071823465.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;机器学习作业coursera-ml-py&quot;&gt;2.4 机器学习作业：coursera-ml-py&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：50+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;coursera-ml-py 是 Coursera 的 Andrew Ng 教授为机器学习编写的 Python 编程作业，包括：线性回归、逻辑回归、神经网路、向量机、推荐系统等方面。 ​​​​&lt;/p&gt;
&lt;blockquote readability=&quot;1.4035087719298&quot;&gt;
&lt;p&gt;GitHub 地址→&lt;a href=&quot;https://github.com/nsoojin/coursera-ml-py&quot; class=&quot;uri&quot;&gt;https://github.com/nsoojin/coursera-ml-py&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/202003/759200-20200301202756605-191989427.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;java-实操flink-recommandsystem-demo&quot;&gt;2.5 Java 实操：flink-recommandSystem-demo&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：50+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;flink-recommandSystem-demo 是一个基于 Flink 实现的商品实时推荐系统。Flink 统计商品热度，放入 Redis 缓存，分析日志信息，将画像标签和实时记录放入 HBase。在用户发起推荐请求后，根据用户画像重排序热度榜，并结合协同过滤和标签两个推荐模块为新生成的榜单的每一个产品添加关联产品，最后返回新的用户列表。&lt;/p&gt;
&lt;blockquote readability=&quot;1.0810810810811&quot;&gt;
&lt;p&gt;GitHub 地址→&lt;a href=&quot;https://github.com/CheckChe0803/flink-recommandSystem-demo&quot; class=&quot;uri&quot;&gt;https://github.com/CheckChe0803/flink-recommandSystem-demo&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/202003/759200-20200301202809698-1745965146.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;应用-caseindustry-machine-learning&quot;&gt;2.6 应用 Case：industry-machine-learning&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：200+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;industry-machine-learning 是一个收录了多个行业应用机器学习与数据科学的项目，其中包括会计、银行、保险、律师等多个行业的分类。 ​​​​&lt;/p&gt;
&lt;blockquote readability=&quot;1.1940298507463&quot;&gt;
&lt;p&gt;GitHub 地址→&lt;a href=&quot;https://github.com/firmai/industry-machine-learning&quot; class=&quot;uri&quot;&gt;https://github.com/firmai/industry-machine-learning&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/202003/759200-20200301202820802-1785243951.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;本周-github-trending-前端专场主题的主力军&quot;&gt;3. 本周 GitHub Trending #前端专场#主题的主力军&lt;/h2&gt;
&lt;p&gt;本周 GitHub Trending 上有不少前端开发项目，这里小鱼干推荐 3 个前端相关 Repo 希望对你有用~&lt;/p&gt;
&lt;h3 id=&quot;前端测试front-end-checklist&quot;&gt;3.1 前端测试：Front-End-Checklist&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：400+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Front-End-Checklist 是一个前端测试清单，它详细罗列了一个网站测试所涉及的方方面面，包括 HTML、CSS、安全、性能、SEO…并按照 Low、Medium、High 对测试的必要性进行划分。 ​​​​&lt;/p&gt;
&lt;blockquote readability=&quot;1.1940298507463&quot;&gt;
&lt;p&gt;GitHub 地址→&lt;a href=&quot;https://github.com/thedaviddias/Front-End-Checklist&quot; class=&quot;uri&quot;&gt;https://github.com/thedaviddias/Front-End-Checklist&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/202003/759200-20200301202837175-234289700.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;前端小框架alpine.js&quot;&gt;3.2 前端小框架：Alpine.js&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：650+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Alpine.js 是一个以较低成本提供大型框架（比如 Vue、React）的响应性和声明性的小框架，当然它支持你保留自己的 DOM，并按照自己的想法构建模型。 ​​​​&lt;/p&gt;
&lt;blockquote readability=&quot;1.6&quot;&gt;
&lt;p&gt;GitHub 地址→&lt;a href=&quot;https://github.com/alpinejs/alpine&quot; class=&quot;uri&quot;&gt;https://github.com/alpinejs/alpine&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/202003/759200-20200301202846747-1500471461.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;demo-之母realworld&quot;&gt;3.3 Demo 之母：RealWorld&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：850+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;RealWorld 向大家展示了如何使用 React/Angular 等框架在 Node/Django 等平台上构建类 Medium 博客平台。开发者可以把它们混合起来，因为它们都遵循相同的 API 规范。&lt;/p&gt;
&lt;blockquote readability=&quot;1.4285714285714&quot;&gt;
&lt;p&gt;GitHub 地址→&lt;a href=&quot;https://github.com/gothinkster/realworld&quot; class=&quot;uri&quot;&gt;https://github.com/gothinkster/realworld&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/202003/759200-20200301202858466-1480483023.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以上为 2020 年第 9 个工作周的 GitHub Trending 🎉如果你 Pick 其他好玩、实用的 GitHub 项目，记得来 HelloGitHub issue 区和我们分享下哟 🌝&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;HelloGitHub 交流群现已全面开放，添加微信号：HelloGitHub 为好友可同前端、Java、Go…各界大佬谈笑风生、切磋技术~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/202002/759200-20200217165012919-1203910757.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关注公众号加入交流群&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 02 Mar 2020 00:24:00 +0000</pubDate>
<dc:creator>削微寒</dc:creator>
<og:description>作者：HelloGitHub 小鱼干 摘要：上周 GitHub 趋势榜相较上上周就如同前故事一般，跌到不行，无论是新晋开源小项，还是坚挺老项目，Star 增长量都不如之前，即使“大环境”欠佳，但是有些</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xueweihan/p/12391823.html</dc:identifier>
</item>
<item>
<title>ASP.NET Core 反向代理部署知多少 - 「圣杰」</title>
<link>http://www.cnblogs.com/sheng-jie/p/Deploy-ASP-NET-CORE-WITH-REVERSE-PROXY.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sheng-jie/p/Deploy-ASP-NET-CORE-WITH-REVERSE-PROXY.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/2/29/1708ecde60c7a331?w=600&amp;amp;h=315&amp;amp;f=png&amp;amp;s=20494&quot;/&gt;&lt;/p&gt;

&lt;p&gt;最近在折腾统一认证中心，看到开源项目&lt;a href=&quot;https://github.com/skoruba/IdentityServer4.Admin&quot;&gt;IdentityServer4.Admin&lt;/a&gt;集成了IdentityServer4和管理面板，就直接拿过来用了。在尝试Nginx部署时遇到了诸如虚拟目录映射，请求头超长、基础路径映射有误等问题，简单记录，以供后人参考。&lt;/p&gt;

&lt;p&gt;首先来看下&lt;a href=&quot;https://github.com/skoruba/IdentityServer4.Admin&quot;&gt;IdentityServer4.Admin&lt;/a&gt;的项目结构：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;IdentityServer4.Admin /                         
├── Id4.Admin.Api                  # 用于提供访问Id4资源的WebApi项目
├── Id4.Admin                      # 用于提供管理Id4资源的Web管理面板 
├── Id4.STS.Identity               # 用于提供 STS 服务的Web项目&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;作为三个独立的项目，分开部署很简单，但为了统一入口管理，我倾向于将&lt;code&gt;Id4.Admin&lt;/code&gt;和&lt;code&gt;Id4.STS.Identity&lt;/code&gt; 部署在一个域名之下，&lt;code&gt;Id4.Admin.API&lt;/code&gt;项目部署到网关中去。也就是通过&lt;code&gt;http://auth.xxx.com&lt;/code&gt;访问&lt;code&gt;Id4.STS.Identity&lt;/code&gt;，通过&lt;code&gt;http://auth.xxx.com/admin&lt;/code&gt;访问&lt;code&gt;Id4.Admin&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这也就是遇到的第一个问题如何借助Nginx实现单域名多站点部署！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Kestrel作为一个边缘web服务器部署时，其将独占一个IP和端口。在没有反向代理服务器的情况下，用作边缘服务器的Kestrel不支持在多个进程之间共享相同的IP和端口。当将Kestrel配置为在端口上侦听时，Kestrel将处理该端口的所有网络通信，并且忽略请求头中指定的&lt;code&gt;Host&lt;/code&gt;请求头，也就意味着Kestrel 不会负责请求转发。&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/2/29/1708ecde61f3bde6?w=422&amp;amp;h=82&amp;amp;f=png&amp;amp;s=2362&quot; alt=&quot;Use Kestrel Server&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因此为了进行端口共享，我们需借助反向代理将唯一的IP和端口上将请求转发给Kestrel。也就是下面这张图。&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/2/29/1708ecde62fff765?w=641&amp;amp;h=82&amp;amp;f=png&amp;amp;s=3373&quot; alt=&quot;Use Reverse Proxy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;根据Nginx 官方配置文档，通过配置Location就可以实现指定路径路由转发。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;server {
    listen 80;
    listen [::]:80;
    server_name mysite;
    
    location / {
        proxy_pass http://id4.sts.identity:80;
        proxy_set_header Host $host;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
    
    location /admin/ {
        proxy_pass http://id4.admin:80/;
        proxy_set_header Host $host;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们 比较下两个proxy_pass的配置：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;location / { proxy_pass &lt;a href=&quot;http://id4.sts.identity:80&quot; class=&quot;uri&quot;&gt;http://id4.sts.identity:80&lt;/a&gt;; }&lt;/li&gt;
&lt;li&gt;location /admin/ { proxy_pass &lt;a href=&quot;http://id4.admin:80&quot; class=&quot;uri&quot;&gt;http://id4.admin:80&lt;/a&gt;&lt;strong&gt;/&lt;/strong&gt;; }&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;主要的不同点是 &lt;code&gt;location /admin/&lt;/code&gt; 节点下&lt;code&gt;proxy_pass http://id4.admin:80/&lt;/code&gt;结尾包含一个左斜杠 &lt;strong&gt;/&lt;/strong&gt;。（如果没有这个左斜杠，所有的请求都会被路由到根节点。）比如有个请求&lt;code&gt;http://auth.xxx.com/admin/dashboard&lt;/code&gt;，那么nginx根据以上配置会将请求路由到&lt;code&gt;http://id4.admin:80/dashboard&lt;/code&gt;。也就是最后一个左斜杠会将替换掉 location 指定的路由规则，也就是这里的&lt;code&gt;/admin&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;但这样就OK了吗？Absolutely no！执行&lt;code&gt;nginx -s reload&lt;/code&gt; 你将会得到一个大大的&lt;code&gt;404&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;这时就要用到UsePathBase中间件了，其作用就是设置站点请求基础路径。在Web项目中添加&lt;code&gt;UsePathBase&lt;/code&gt; 中间件很简单，首先在&lt;code&gt;appsettings.json&lt;/code&gt;中添加一个配置项&lt;code&gt;PATHBASE&lt;/code&gt;，然后Startup的Config中启用就好。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;appsettings.json
{
    &quot;PATHBASE&quot;:&quot;/admin&quot;
}
-----

public class Startup
{
    public Startup(IConfiguration configuration)
    {
        Configuration = configuration;
    }
    private IConfiguration Configuration { get; }
    // ...
    public void Configure(...)
    {
        // ...
        app.UsePathBase(Configuration.GetValue&amp;lt;string&amp;gt;(&quot;PATHBASE&quot;));&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;使用反向代理还有一个问题要注意，那就是反向代理会模糊一些请求信息：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;通过HTTP代理HTTPS请求时，原始传输协议（HTTPS）丢失，必须在请求头中转发。&lt;/li&gt;
&lt;li&gt;由于应用程序是从代理服务器收到请求的，而不是真正的请求来源，因此原始客户端IP地址也必须在请求头中转发。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这也就是为什么上面的Nginx 配置，会默认包含以下两项配置的原因。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
proxy_set_header X-Forwarded-Proto $scheme;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Nginx已经默认配置转发了以上信息，那么自然要显式告知ASP.NET Core Web 应用要从请求头中取回真实的请求信息。配置很简单，需要安`&lt;a href=&quot;https://www.nuget.org/packages/Microsoft.AspNetCore.HttpOverrides/&quot;&gt;Microsoft.AspNetCore.HttpOverrides&lt;/a&gt; NuGet包，然后在Startup的Config中启用中间件。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Startup
{
    public Startup(IConfiguration configuration)
    {
        Configuration = configuration;
    }
    private IConfiguration Configuration { get; }
    // ...
    public void Configure(...)
    {
        // ...        
        app.UseForwardedHeaders(new ForwardedHeadersOptions{
          ForwardedHeaders = ForwardedHeaders.XForwardedFor | ForwardedHeaders.XForwardedProto });

        app.UsePathBase(Configuration.GetValue&amp;lt;string&amp;gt;(&quot;PATHBASE&quot;));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有一点必须注意，依赖于传输协议的任何组件，例如身份验证，链接生成，重定向和地理位置，都必须在请求头转发中间件之后启用。通常，除了诊断和错误处理中间件外，请求头转发中间件应先于其他中间件运行。&lt;/p&gt;
&lt;p&gt;配置完成后，重新部署，对于一般的项目，应该可以正常运行了。但也可能遭遇：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/2/29/1708ecde62e293e2?w=1054&amp;amp;h=513&amp;amp;f=png&amp;amp;s=30749&quot;/&gt;&lt;/p&gt;

&lt;p&gt;针对这种错误当然要查Nginx错误日志了，如果Nginx服务器部署在Linux服务器，那么默认日志文件在&lt;code&gt;/var/log/nginx/error.log&lt;/code&gt;，日志如下：&lt;em&gt;17677925 upstream sent too big header while reading response header from upstream&lt;/em&gt;。简单翻译就是请求头数据过大。那我们就来看看转发的请求头到底会有多大，从下图来看请求头中携带的Cookie最大的有3K多。&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/2/29/1708ecde6377aee5?w=670&amp;amp;h=175&amp;amp;f=png&amp;amp;s=7413&quot;/&gt;&lt;/p&gt;
&lt;p&gt;nginx添加下面的配置即可：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;proxy_buffer_size          128k;
proxy_buffers              4 256k;
proxy_busy_buffers_size    256k;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;重新加载Nginx 配置，访问成功。&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/2/29/1708ecde68e06832?w=1164&amp;amp;h=871&amp;amp;f=png&amp;amp;s=54451&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Is All Set? No!&lt;/p&gt;

&lt;p&gt;当我尝试点击Admin管理面板的链接时，得到无情的404，因为链接地址为：&lt;code&gt;http://auth.xxx.com/configruaion/clients&lt;/code&gt;，正确的链接地址应该是&lt;code&gt;http://auth.xxx.com/admin/configruaion/clients&lt;/code&gt;。也就是Razor TagHelper 渲染的&lt;code&gt;&amp;lt;a asp-controller=&quot;Configruaion&quot; asp-action=&quot;Clients&quot;&amp;gt;Manage Client&amp;lt;/a&amp;gt;&lt;/code&gt;，并没有帮按照&lt;code&gt;UsePathBase&lt;/code&gt;指定的路径生成a标签链接。咱们只能看看源码一探究竟了&lt;a href=&quot;https://github.com/aspnet/Mvc/blob/master/src/Microsoft.AspNetCore.Mvc.TagHelpers/AnchorTagHelper.cs&quot;&gt;Microsoft.AspNetCore.Mvc.TagHelpers/AnchorTagHelper.cs&lt;/a&gt;，最终在拼接&lt;code&gt;Herf&lt;/code&gt;属性时使用的是&lt;code&gt;var pathBase = ActionContext.HttpContext.Request.PathBase;&lt;/code&gt;来拼接基础路径。也就是说说TagHelper根据Http请求上下文中获取基础路径。因此如果采用&lt;code&gt;location /admin/ { proxy_pass http://id4.admin:80/;&lt;/code&gt;这种路由映射，最终会丢失原始路由的基础路径，也就是&lt;code&gt;/admin/&lt;/code&gt; 路由部分。所以，我们还是乖乖把基础路径补充上，也就是&lt;code&gt;proxy_pass http://id4.admin:80/admin/;&lt;/code&gt;&lt;br/&gt;至此完成反向代理的单域名多站点部署。&lt;/p&gt;

&lt;p&gt;一波三折，但最终不负期望。最后完整Nginx配置放出，以供参考：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;server {
    listen 80;
    listen [::]:80;
    server_name mysite;
    
    location / {
        proxy_pass http://id4.sts.identity:80;
        proxy_set_header Host $host;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
    
    location /admin/ {
        proxy_pass http://id4.admin:80/admin/;
        proxy_set_header Host $host;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_buffer_size          128k;
        proxy_buffers              4 256k;
        proxy_busy_buffers_size    256k;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/proxy-load-balancer?view=aspnetcore-3.1&quot;&gt;Configure ASP.NET Core to work with proxy servers and load balancers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/AspNetCore.Docs/issues/15464&quot;&gt;GitHub Issue: Deploy to subdirectory #15464&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.endycahyono.com/article/aspnetcore3-running-under-subdirectory-on-nginx&quot;&gt;ASP.Net Core 3 App Running under a Subdirectory on Nginx&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Mon, 02 Mar 2020 00:20:00 +0000</pubDate>
<dc:creator>「圣杰」</dc:creator>
<og:description>如何实现多域名单站点部署？</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/sheng-jie/p/Deploy-ASP-NET-CORE-WITH-REVERSE-PROXY.html</dc:identifier>
</item>
<item>
<title>LeetCode 32，并不Hard的难题，解法超级经典，带你领略动态规划的精彩 - TechFlow2019</title>
<link>http://www.cnblogs.com/techflow/p/12393742.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/techflow/p/12393742.html</guid>
<description>&lt;p&gt;本文始发于个人公众号：&lt;strong&gt;TechFlow&lt;/strong&gt;，原创不易，求个关注&lt;/p&gt;

&lt;p&gt;今天给大家分享的是LeetCode当中的32题，这是一道Hard难度的题。也是一道经典的字符串处理问题，在接下来的文章当中，我们会详细地解读有关它的三个解法。&lt;/p&gt;
&lt;p&gt;希望大家不要被题目上的标记吓到，虽然这题标着难度是Hard，但其实真的不难。我自信你们看完文章之后也一定会这么觉得。&lt;/p&gt;

&lt;h3 id=&quot;链接&quot;&gt;链接&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/longest-valid-parentheses&quot;&gt;Longest Valid Parentheses&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;难度&quot;&gt;难度&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;Hard&lt;/span&gt;&lt;/p&gt;

&lt;h3 id=&quot;描述&quot;&gt;描述&lt;/h3&gt;
&lt;p&gt;给定一个只包含左右括号的字符串，返回最长能够组成合法括号的长度&lt;/p&gt;
&lt;p&gt;Given a string containing just the characters &lt;code&gt;'('&lt;/code&gt; and &lt;code&gt;')'&lt;/code&gt;, find the length&lt;br/&gt;of the longest valid (well-formed) parentheses substring.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;样例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Input:  &quot;(()&quot;
Output: 2
## Explanation: The longest valid parentheses substring is &quot;()&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;样例 2:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Input:  &quot;)()())&quot;
Output: 4
## Explanation: The longest valid parentheses substring is &quot;()()&quot;&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;思考&quot;&gt;思考&lt;/h2&gt;

&lt;p&gt;我们来分析一下题目，这题的题目很容易理解，本质上是一个寻找字符串最大子串的问题。合法的条件是括号合法，也就是左右括号能够对上。我们之前分析过左右括号的合法条件，其实很简单，我们只需要保证右括号出现的数量一直小于等于左括号的数量。&lt;/p&gt;
&lt;p&gt;也就是说((()是有可能合法的，而())是一定不合法的。原因很简单，因为如果左括号的数量大于右括号，那么由于后续还可能会有括号出现，所以还是有可能构成合法的。而反之则不行，所以如果右括号的数量过多，那么一定不合法。&lt;/p&gt;

&lt;h2 id=&quot;暴力&quot;&gt;暴力&lt;/h2&gt;

&lt;p&gt;根据我们上面分析的结果，我们不难想出暴力的解法。我们可以枚举所有的字符串的位置，作为开头，接着找出从这个开头开始可以达成合法的最大的长度。&lt;/p&gt;
&lt;p&gt;我们前面说了如果(出现的数量大于）的时候，后面仍然可能构成合法的匹配，所以我们不能结束，还需要往下继续搜索。而如果）的数量超过（那后面的就可以不用看了，直接退出即可。如果（的数量等于），那么说明可以构成匹配，我们试着更新答案。&lt;/p&gt;
&lt;p&gt;我们用代码实现这个逻辑：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def brute_force(s):
    ans = 0
    for i in range(len(s)):
        if s[i] == '(':
            l = r = 0
            for j in range(i, len):
                if s[j] == '(':
                    l++
                else:
                    r++
                # 如果已经不可能构成答案
                if r &amp;gt; l:
                    break
                if r == l:
                    ans = max(ans, 2 * r)
    return ans&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段代码应该都能看懂，我们只需要判断非法和合法两种情况，如果非法则退出循环，枚举下一个起始位置。如果合法，则试着更新答案。最后，我们返回最大的结果。&lt;/p&gt;
&lt;p&gt;这个暴力的解法当然没问题，但是显然复杂度不够完美，还有很大提升的空间。而且如果这题就这么个难度，那么也肯定算不上是Hard了。接下来要给大家介绍一种非常巧妙的方法，它不会涉及许多新的算法和知识点，只是和之前的题目一样，需要我们对问题有比较深入的理解。&lt;/p&gt;

&lt;h2 id=&quot;寻找模式法&quot;&gt;寻找模式法&lt;/h2&gt;

&lt;p&gt;接下来要介绍的这个方法非常硬核，我们不需要记录太多的信息，也不会用到新奇的或者是高端的算法，但是需要我们仔细分析问题，找到问题的“模式”。我把它称作是模式匹配算法。&lt;/p&gt;
&lt;p&gt;其实模式匹配是专有名词，我这里只是借用一下。它有些像是正则表达式，我们写下一个模式匹配的规则，然后正则表达式引擎就可以根据我们写下的模式规则去寻找匹配的字符串。比如说我们希望找到所有的邮箱，我们约定一个模式，它接受一个3到20的字符串，中间必须要存在一个@符号，然后需要一个域名作为后缀。&lt;/p&gt;
&lt;p&gt;我们刚才对于一个邮箱地址的描述，包括长度、内容以及必须存在的字符等等这些要求其实就是模式。这个概念有些抽象，但是并不难理解，我相信你们应该都能明白。理解了这个概念之后，我们来思考一个问题，在这个问题当中，最终长度最大的答案它的模式是什么？我们稍微想一下就可以想明白，不论它多长，它里面的内容是什么样，它应该是以(为开头，以)为结尾。&lt;/p&gt;
&lt;p&gt;我们把这个答案命名为t，我们继续来思考，t前面和后面的一个符号的组合会是什么样的？&lt;/p&gt;
&lt;p&gt;我们列举一下就能知道，一共只有3种情况，分别是(t(，)t)和)t(。(t)是不可能的，因为这样可以组成更长的答案，这和我们一开始的假设矛盾了。所以只有这三种情况。&lt;/p&gt;
&lt;p&gt;我们来关注一下)t)和)t(这两种情况，对于这两种情况来说，我们可以肯定一点，t前面的)一定不是一个合法括号的结尾。答案也很简单，如果)能够构成合法的括号匹配，那么答案的长度显然也会增加。所以它一定是在一个非法的位置，既然出现在非法的位置，那么我们就可以忽略。换句话说，对于这两种情况而言，我们只需要遍历一次字符串，维护构成的合法括号的位置，就一定可以找到它们。&lt;/p&gt;
&lt;p&gt;原因也很简单，在我们遍历到了t前面的)的位置的时候，由于非法，我们会将所有记录的左右括号的信息清除。所以我们一定可以顺利地找到t，并且不会受到其他符号的干扰。&lt;/p&gt;
&lt;p&gt;但是这样只能包含两种情况，对于(t(的情况我们怎么处理呢？因为是左括号，我们无法判断它的出现是否会产生非法。也就是说我们在遍历的时候，无法将t前面的左括号带来的影响消除。对于这个问题其实很简单，我们只需要反向遍历即可。由于我们遍历的顺序翻转，所以(成了可能构成非法的符号，而)不是，于是就可以识别这一种情况了。&lt;/p&gt;
&lt;p&gt;我们写出代码，真的很简单，只有两次遍历数组：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class Solution:
    def longestValidParentheses(self, s: str) -&amp;gt; int:
        n = len(s)
        ans = 0
        l, r = 0, 0
        # 正向遍历，寻找)t( 和 )t(两种情况
        for i in range(n):
            if s[i] == '(':
                l += 1
            else:
                r += 1
                if r &amp;gt; l:
                    l, r = 0, 0
                elif r == l:
                    ans = max(ans, l + r)
                    
        l, r = 0, 0
        # 反向遍历，寻找(t(这种情况
        for i in range(n-1, -1, -1):
            # 由于反向遍历，所以非法的判断条件和正向相反
            if s[i] == '(':
                l += 1
                if l &amp;gt; r:
                    l, r = 0, 0
                elif l == r:
                    ans = max(ans, l+r)
            else:
                r += 1
        return ans&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种方法实现非常简单，几乎毫无难度，效率也很高，是&lt;span class=&quot;math inline&quot;&gt;\(O(n)\)&lt;/span&gt;的算法，但是需要对问题有很深的思考和理解才行。很多同学可能会苦恼，觉得这种方法太取巧了，自己不一定能想得到这么巧妙的方法。没有关系，我们接下来会继续介绍一种中规中矩比较容易想到的方法。&lt;/p&gt;

&lt;h2 id=&quot;dp&quot;&gt;dp&lt;/h2&gt;

&lt;p&gt;接下来要介绍的是鼎鼎大名的dp算法，dp是英文dynamic programming的缩写，翻译过来的意思是动态规划。它是一个频繁出现在各个算法领域以及面试当中的算法，并且应用广泛，在许多问题上用到了动态规划的思路，可以说得上是教科书级的算法了。因此对于我们算法学习者来说，它也非常的重要。&lt;/p&gt;
&lt;p&gt;很多初学者对于动态规划可能理解并不深入，不是觉得非常困难，就是还停留在背包问题的范畴当中。在这题当中，我会尽可能地讲解清楚动态规划的内在逻辑，以及它运行的原理，让大家真正理解这一算法的思路。至于动态规划算法具体的学习方法和一些经典例题，我们会放在之后的文章当中再详细讲解。所以如果是没有基础的同学，也不用担心，接下来的内容也一样能够看懂。&lt;/p&gt;
&lt;p&gt;动态规划最朴素的思路就是拆分问题，将大问题拆分成小问题。但是和分治算法不同的是，动态规划更加关注子问题和原问题之间的逻辑联系，而分治算法可能更加侧重拆分。并且分治算法的拆分通常是基于数据和问题规模的，而动态规划则不然，更加侧重逻辑上的联系。除此之外，动态规划也非常注重模式的构造。&lt;/p&gt;
&lt;p&gt;如果你看到这里一脸懵逼，啥也没看明白，没有关系，我们用实际问题来举例就明白了。我们先来学一个技巧，在动态规划问题当中，我们最经常干的一件事情就是创建一个叫做dp的数组，它来记录每一个位置能够达到的最佳结果。比如在这题当中，最佳结果就是最长匹配的括号串。所以dp[i]就记录以s[i]结尾的字符串能够构成的最长的匹配串的长度。&lt;/p&gt;
&lt;p&gt;那么，我们继续分析，假设当前处理的位置i之前的结果都已经存在了，我们怎么通过之前的数据获得当前的dp[i]呢？这个可以认为是动态规划的精髓，利用之前已经存储的结果推算当前需要求的值。&lt;/p&gt;
&lt;p&gt;显然如果s[i]是(，没什么好说的，以i为结尾一定不能构成合法的串，那么dp[i]=0。也就是说只有s[i]是)的时候，dp[i]的值才有可能大于0。那么这个值会是多少呢？我们继续来推算。&lt;/p&gt;
&lt;p&gt;显然，我们需要观察i-1的位置，如果i-1的位置是(，那么说明我们至少可以构成一个match。构成这个match之后呢？其实就要看dp[i-2]了。因为在一个合法的结果后面加上一个括号对显然也是合法的。所以如果i-1处的结果是(，那么我们可以得到dp[i] = dp[i-2] + 2。&lt;/p&gt;
&lt;p&gt;那如果i-1的位置也是)呢？我们来举个例子看看就知道了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;s:    a       b    (    )     )
idx:  i-4    i-3   i-2  i-1   i&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上面这个例子可以看出来，当i-1的位置也是)的时候，我们可以知道dp[i-1]有可能不为0，那么很简单，我们只需要跳过dp[i-1]长度的位置就好了。比如上面这个例子，i-1的位置可以和i-2构成match，那么我们就可以跳过dp[i-1]也就是2个长度，去查看i-3的位置和i是否构成match，如果构成match，那么最终的答案就是dp[i-1] + 2 + dp[i-4]。因为dp[i-4]也有可能还有合法的串。&lt;/p&gt;
&lt;p&gt;所以，到这里我们就把所有子问题之间的逻辑联系都分析清楚了。剩下的就很简单了，我们只需要根据上面的分析结果写出答案而已。&lt;/p&gt;
&lt;p&gt;不过还有一点，由于我们一直是利用前面的结果来推导后面的结果，我们需要一个初始的推导基点。这个基点就是dp[0]，显然在这个问题当中dp[0]=0。这个基点有了，剩下的就顺理成章了。&lt;/p&gt;
&lt;p&gt;我们写出代码来看下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class Solution:
    def longestValidParentheses(self, s: str) -&amp;gt; int:
        n = len(s)
        ans = 0
        dp = [0 for _ in range(n)]
        for i in range(1, n):
            if s[i] == ')':
                # 如果i-1是（，那么我们判断i-2
                if s[i-1] == '(':
                    dp[i] = 2 + (dp[i-2] if i &amp;gt; 1 else 0)
                # 如果i-1也是)，我们需要继续往前判断
                # 这里要特别注意下下标， 很容易写错
                elif i - dp[i-1] &amp;gt; 0 and s[i - dp[i-1] - 1] == '(':
                    dp[i] = 2 + dp[i-1] + (dp[i - dp[i-1] - 2] if i - dp[i-1] - 2 &amp;gt;= 0 else 0)
                    
            ans = max(ans, dp[i])
        return ans&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我相信上面的解释应该都能看懂，其实是很简单的推理。我相信即使是对dp不太熟悉的同学，也应该都能看懂整个的运行原理。整个过程同样是&lt;span class=&quot;math inline&quot;&gt;\(O(n)\)&lt;/span&gt;的计算过程，但是和上面的方法相比，我们额外开辟了数组记录每个位置的状态。这也是dp算法的特点，就是我们会存储几乎所有中间状态的结果，因为我们逻辑关系上的推导过程正是基于这些中间状态进行的。&lt;/p&gt;
&lt;p&gt;所以这题虽然是Hard，但如果从dp的角度来讲，如果你能想到用dp算法来解决，其实距离解开真的已经不远了。所以不要被题目上标记的Hard吓到，真的没有那么难。另外，我个人也觉得这题将算法的魅力发挥得非常明显，尤其是第二种解法真的非常巧妙。希望大家都能喜欢这题。&lt;/p&gt;
&lt;p&gt;今天的文章就是这些，如果觉得有所收获，请&lt;strong&gt;顺手扫码点个关注&lt;/strong&gt;吧，你们的举手之劳对我来说很重要。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/3/2/17098914245a1ab7?w=258&amp;amp;h=258&amp;amp;f=png&amp;amp;s=23988&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 02 Mar 2020 00:09:00 +0000</pubDate>
<dc:creator>TechFlow2019</dc:creator>
<og:description>本文始发于个人公众号： TechFlow ，原创不易，求个关注 今天给大家分享的是LeetCode当中的32题，这是一道Hard难度的题。也是一道经典的字符串处理问题，在接下来的文章当中，我们会详细地</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/techflow/p/12393742.html</dc:identifier>
</item>
<item>
<title>架构设计|异步请求如何同步处理？ - 楼下小黑哥</title>
<link>http://www.cnblogs.com/goodAndyxublog/p/12393723.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/goodAndyxublog/p/12393723.html</guid>
<description>&lt;p&gt;Hello，大家好，本周的文章来源于一次业务需求，需要接入一个只提供异步 API 的第三方外部服务。为了不影响现有系统同步处理的方式，对外屏蔽这种差异，应用内部实现异步请求同步。 方案设计参考 Dubbo 同步请求实现方式，结合自身业务，加了特定的设计。 输出这篇文章，希望对各位读者碰到这种场景需求提供一些思路。 欢迎大家留言，一起讨论。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;196.280283265&quot;&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1419561/202003/1419561-20200302075403261-938273518.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;本文创意来自一次业务需求，这次需要接入一个第三方外部服务。由于这个服务只提供异步 API，为了不影响现有系统同步处理的方式，接入该外部服务时，应用对外屏蔽这种差异，内部实现异步请求同步。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;全文摘要&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;异步给现有架构带来的问题&lt;/li&gt;
&lt;li&gt;Dubbo 异步转同步解决方法&lt;/li&gt;
&lt;li&gt;异步转同步架构设计方案&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;x00.-前言&quot;&gt;0x00. 前言&lt;/h2&gt;
&lt;p&gt;现有一个系统，整体架构如下所示:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1419561/202003/1419561-20200302075403817-2033123627.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是一个很常见的同步设计方案，上游系统需要等待下游系统接口返回调用结果。&lt;/p&gt;
&lt;p&gt;现在需要接入另外一个第三方服务 B，该服务与服务 A 最大区别在于，这是一个&lt;strong&gt;异步&lt;/strong&gt; &lt;code&gt;API&lt;/code&gt;。调用之后，仅仅返回&lt;strong&gt;受理成功&lt;/strong&gt;，处理结果后续通过异步通知返回。&lt;/p&gt;
&lt;p&gt;接入之后，整体架构如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1419561/202003/1419561-20200302075405214-1219126737.jpg&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;由于网络隔离策略，通知接收程序与通信服务需要单独分开部署。若没此要求，可以将通信服务 B 与通知接收程序合并成一个应用。&lt;/p&gt;
&lt;p&gt;另外图中所有应用采用双节点部署。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为了不影响 &lt;code&gt;OpenAPI&lt;/code&gt; 上游系统同步处理逻辑，通信服务 B 调用第三方服务之后，不能立刻返回，需要等待结果通知，拿到具体返回结果。这就需要通信服务 B 内部将异步转为同步。&lt;/p&gt;
&lt;p&gt;这就是一个典型的异步转同步问题，整个过程涉及两个问题。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;通信服务 B 业务线程如何进入&lt;strong&gt;等待&lt;/strong&gt;状态？又如何&lt;strong&gt;唤醒&lt;/strong&gt;正确等待线程？&lt;/li&gt;
&lt;li&gt;由于通信服务 B 双节点部署，通知接收程序如何将结果转发到正在等待处理的节点？&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;问题 1 的解决方案参考了 Dubbo 设计思路。&lt;/p&gt;
&lt;p&gt;我们在使用 Dubbo 调用远程服务时，默认情况下，这是一种阻塞式调用方式，即 Consumer 端代码一直阻塞等待，直到 Provider 端返回为止。&lt;/p&gt;
&lt;p&gt;由于 Dubbo 底层基于 &lt;code&gt;Netty&lt;/code&gt; 发送网络请求，这其是一个异步的过程。为了让业务线程能同步等待，这个过程就需要将异步转为同步。&lt;/p&gt;
&lt;h2 id=&quot;x01.-dubbo-异步转同步解决办法&quot;&gt;0x01. Dubbo 异步转同步解决办法&lt;/h2&gt;
&lt;h3 id=&quot;业务线程同步阻塞&quot;&gt;1.1 业务线程同步阻塞&lt;/h3&gt;
&lt;p&gt;Dubbo 发起远程调用代码位于 &lt;code&gt;DubboInvoker#doInvoke&lt;/code&gt;：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Dubbo 版本为：2.6.X 版本。2,7.X 重构 &lt;code&gt;DefaultFuture&lt;/code&gt; ，但是本质原理还是一样。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1419561/202003/1419561-20200302075409391-1499532828.jpg&quot; alt=&quot;0082zybply1gc7t3m2louj31650u0u0x&quot;/&gt;&lt;/p&gt;
&lt;p&gt;默认情况下，Dubbo 支持同步调用方式，这里将会创建 &lt;code&gt;DefaultFuture&lt;/code&gt; 对象。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1419561/202003/1419561-20200302075411242-319581085.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里有个非常重要逻辑，每个请求生成一个唯一 &lt;strong&gt;ID&lt;/strong&gt;，然后将 &lt;code&gt;ID&lt;/code&gt; 与 &lt;code&gt;DefaultFuture&lt;/code&gt; 映射关系，存入 &lt;code&gt;Map&lt;/code&gt; 中。&lt;/p&gt;
&lt;p&gt;这个请求 &lt;strong&gt;ID&lt;/strong&gt; 在之所以这么重要，是因为消费者并发调用服务发送请求，同时将会有多个业务线程进入阻塞。当收到响应之后，我们需要唤醒正确的等待线程，并将处理结果返回。&lt;/p&gt;
&lt;p&gt;通过 &lt;strong&gt;ID&lt;/strong&gt; 这个唯一映射的关系，很自然可以找到其对应 &lt;code&gt;DefaultFuture&lt;/code&gt;，唤醒其对应的业务线程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1419561/202003/1419561-20200302075413952-1498836289.jpg&quot; alt=&quot;来源：Dubbo 官网&quot;/&gt;&lt;/p&gt;
&lt;p&gt;业务线程调用 &lt;code&gt;DefaultFuture#get&lt;/code&gt;方法进入阻塞。这段代码比较简单，通过调用 &lt;code&gt;Condition#await&lt;/code&gt; 阻塞线层。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1419561/202003/1419561-20200302075416561-406333272.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;唤醒业务线程&quot;&gt;1.2 唤醒业务线程&lt;/h3&gt;
&lt;p&gt;当消费者接收到服务提供者的返回结果，将会调用 &lt;code&gt;DefaultFuture#received&lt;/code&gt; 方法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1419561/202003/1419561-20200302075420187-1279004870.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1419561/202003/1419561-20200302075421152-1250829726.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过响应对象中的唯一 &lt;strong&gt;ID&lt;/strong&gt;，找到其对应 &lt;code&gt;DefaultFuture&lt;/code&gt; 对象，从而将结果设置 &lt;code&gt;DefaultFuture&lt;/code&gt; 对象中，然后唤醒的相应的业务线程。&lt;/p&gt;
&lt;blockquote readability=&quot;6.2626262626263&quot;&gt;
&lt;p&gt;这里实际有个优化点，使用 done#signalAll 代替 done#signal。使用 condition 等待通知机制的时候需要注意这一点。&lt;/p&gt;
&lt;p&gt;详情参考:&lt;a href=&quot;https://github.com/apache/dubbo/issues/3678&quot; class=&quot;uri&quot;&gt;https://github.com/apache/dubbo/issues/3678&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;设计注意点&quot;&gt;1.3 设计注意点&lt;/h3&gt;
&lt;p&gt;正常情况下，当消费者接收到响应之后，将会从 &lt;code&gt;FUTURES&lt;/code&gt; 这个 &lt;code&gt;Map&lt;/code&gt; 移除 &lt;code&gt;DefaultFuture&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;但是在异常情况下，服务提供者若处理缓慢，不能及时返回响应结果，消费者业务线程将会因为超时苏醒。这种情况下 &lt;code&gt;FUTURES&lt;/code&gt; 积压了无效 &lt;code&gt;DefaultFuture&lt;/code&gt; 对象。如果不及时清理，极端情况下，将会发生 &lt;strong&gt;OOM&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;DefaultFuture&lt;/code&gt; 内部将会开启一个异步线程，定时轮询 &lt;code&gt;FUTURES&lt;/code&gt; 判断 &lt;code&gt;DefaultFuture&lt;/code&gt; 超时时间，及时清理已经无效（超时）的 &lt;code&gt;DefaultFuture&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1419561/202003/1419561-20200302075424870-1183186731.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;x02.-转发方案设计&quot;&gt;0x02. 转发方案设计&lt;/h2&gt;
&lt;p&gt;根据 Dubbo 解决思路，问题 1 解决办法就比较简单了。具体流程如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;通信服务 B 内部生成一个唯一请求 &lt;strong&gt;ID&lt;/strong&gt; ，发给第三方服务&lt;/li&gt;
&lt;li&gt;若请求成功，内部版使用 &lt;code&gt;Map&lt;/code&gt; 存储对应关系，并使业务线程阻塞等待&lt;/li&gt;
&lt;li&gt;通信服务 B 收到异步通知结果，通过 &lt;strong&gt;ID&lt;/strong&gt; 查找对应业务线程，唤醒的相应的线程&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这个设计过程需要注意设置合理的&lt;strong&gt;超时时间&lt;/strong&gt;，这个超时时间需要考虑远程服务调用耗时，可以参考如下公式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;业务线程等待时间=通信服务 B 接口的超时时间 - 调用第三方服务 B 接口消耗时间&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里就不贴出具体的代码，详细代码参考 Dubbo &lt;code&gt;DefaultFuture&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;接下来重点看下通知服务如何将结果转发给正确的通信服务 B 的节点。这里想到两种方案：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;SocketServer&lt;/strong&gt; 方案&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;MQ&lt;/strong&gt; 方案&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;socketserver&quot;&gt;2.1 SocketServer&lt;/h3&gt;
&lt;p&gt;通信服务 B 使用 &lt;strong&gt;SocketServer&lt;/strong&gt; 构建一个服务接收程序，当通知接收程序收到第三方服务 B 通知时，通过 &lt;code&gt;Socket&lt;/code&gt; 将结果转发给通信服务 B。&lt;/p&gt;
&lt;p&gt;整个系统架构如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1419561/202003/1419561-20200302075426780-2120853896.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由于生产服务双节点部署，通知接收程序就不能写死转发地址。这里我们将请求 &lt;strong&gt;ID&lt;/strong&gt; 与通信服务 B &lt;code&gt;socket&lt;/code&gt; 服务地址关系存入 &lt;code&gt;Redis&lt;/code&gt; 中，然后通知接收程序通过 &lt;strong&gt;ID&lt;/strong&gt; 找到正确的地址。&lt;/p&gt;
&lt;p&gt;这个方案说实话有点复杂。&lt;/p&gt;
&lt;p&gt;第一 &lt;strong&gt;SocketServer&lt;/strong&gt; 编码难度较大，编写一个高效 &lt;strong&gt;SocketServer&lt;/strong&gt; 就比较难，一不小心可能产生各种 &lt;strong&gt;Bug&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;第二通信服务 B 服务地址配置在配置文件中，由于两个节点地址不同，这就导致同一应用存在不同配置。这对于后面维护就很不友好。&lt;/p&gt;
&lt;p&gt;第三额外引入 &lt;code&gt;Redis&lt;/code&gt; 依赖，系统复杂度变高。&lt;/p&gt;
&lt;h3 id=&quot;mq-方案&quot;&gt;2.2 MQ 方案&lt;/h3&gt;
&lt;p&gt;相对 &lt;code&gt;SocketServer&lt;/code&gt; 方案，&lt;code&gt;MQ&lt;/code&gt; 方案相对简单，这里采用 &lt;code&gt;MQ&lt;/code&gt; 广播消费的方式，架构如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1419561/202003/1419561-20200302075427767-1848773650.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通知接收程序收到异步通知之后，直接将结果发送到 &lt;code&gt;MQ&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;通信服务 B 开启广播消费模式，拉取 &lt;code&gt;MQ&lt;/code&gt; 消息。&lt;/p&gt;
&lt;p&gt;通信服务 B_1 拉取消息，通过请求 &lt;strong&gt;ID&lt;/strong&gt; 映射关系，没找到内部等待的线程，知道这不是自己的等待消息，于是 B_1 直接丢弃即可。&lt;/p&gt;
&lt;p&gt;通信服务 B_2 拉取消息，通过请求 &lt;strong&gt;ID&lt;/strong&gt; 映射关系，顺利找到正在等待的线程，然后可以唤醒等待线程，返回最后的结果。&lt;/p&gt;
&lt;p&gt;对比 &lt;code&gt;SocketServer&lt;/code&gt; 方案，&lt;code&gt;MQ&lt;/code&gt; 方案整体流程比较简单，编程难度低，也没用存在特殊的配置。&lt;/p&gt;
&lt;p&gt;不过这个方案十分依赖 &lt;code&gt;MQ&lt;/code&gt; 消息实时性，若 &lt;code&gt;MQ&lt;/code&gt; 消息投递延迟很高，这就会导致通信服务 B 业务线程超时苏醒，业务异常返回。&lt;/p&gt;
&lt;p&gt;这里我们选择使用 &lt;code&gt;RocketMQ&lt;/code&gt;，长轮询 &lt;code&gt;Pull&lt;/code&gt; 方式，可保证消息非常实时，&lt;/p&gt;
&lt;p&gt;综上，这里采用 &lt;code&gt;MQ&lt;/code&gt; 的方案。&lt;/p&gt;
&lt;h2 id=&quot;x03.-总结&quot;&gt;0x03. 总结&lt;/h2&gt;
&lt;p&gt;异步转同步我们需要解决同步阻塞，以及如何唤醒的问题。&lt;/p&gt;
&lt;p&gt;阻塞/唤醒可以分别使用 &lt;code&gt;Condition#await/signalAll&lt;/code&gt;。不过这个过程我们需要生成一个唯一请求 &lt;strong&gt;ID&lt;/strong&gt;，并且保存这个 &lt;strong&gt;ID&lt;/strong&gt; 与业务线程映射关系。后续等到结果返回我们才能通过唯一 &lt;strong&gt;ID&lt;/strong&gt; 唤醒正确等待线程。&lt;/p&gt;
&lt;p&gt;只要了解上面几点，异步转同步的问题就就可以迎刃而解。&lt;/p&gt;
&lt;p&gt;另外，如果你也有碰到异步转同步问题，本文的方案希望对你有帮助。如果你有其他设计方案，欢迎留言，一起讨论~&lt;/p&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;http://dubbo.apache.org/zh-cn/docs/source_code_guide/service-invoking-process.html&quot; class=&quot;uri&quot;&gt;http://dubbo.apache.org/zh-cn/docs/source_code_guide/service-invoking-process.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://dubbo.apache.org/zh-cn/blog/dubbo-invoke.html&quot; class=&quot;uri&quot;&gt;http://dubbo.apache.org/zh-cn/blog/dubbo-invoke.html&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;最会说一句-求关注&quot;&gt;最会说一句 (求关注)&lt;/h2&gt;
&lt;p&gt;这篇文章其实写了挺久的，写的挺难得。之前很早想到写这篇文章，但是没想好到底咋写，艰难产出。&lt;/p&gt;
&lt;p&gt;看到这里，点个关注呀，点个赞呗。别下次一定啊，大哥。写文章很辛苦的，需要来点正反馈。&lt;/p&gt;
&lt;p&gt;才疏学浅，难免会有纰漏，如果你发现了错误的地方，还请你留言给我指出来，我对其加以修改。&lt;/p&gt;
&lt;p&gt;感谢您的阅读，我坚持原创，十分欢迎并感谢您的关注&lt;/p&gt;
&lt;blockquote readability=&quot;5.5384615384615&quot;&gt;
&lt;p&gt;欢迎关注我的公众号：程序通事，获得日常干货推送。如果您对我的专题内容感兴趣，也可以关注我的博客：&lt;a href=&quot;https://studyidea.cn&quot;&gt;studyidea.cn&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;</description>
<pubDate>Sun, 01 Mar 2020 23:54:00 +0000</pubDate>
<dc:creator>楼下小黑哥</dc:creator>
<og:description>Hello，大家好，本周的文章来源于一次业务需求，需要接入一个只提供异步 API 的第三方外部服务。为了不影响现有系统同步处理的方式，对外屏蔽这种差异，应用内部实现异步请求同步。  方案设计参考 Du</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/goodAndyxublog/p/12393723.html</dc:identifier>
</item>
<item>
<title>Matplotlib数据可视化（3）：文本与轴 - 奥辰</title>
<link>http://www.cnblogs.com/chenhuabin/p/12393720.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenhuabin/p/12393720.html</guid>
<description>&lt;p&gt;在一幅图表中，文本、坐标轴和图像的是信息传递的核心，对着三者的设置是作图这最为关心的内容，在上一篇博客中虽然列举了一些设置方法，但没有进行深入介绍，本文以围绕如何对文本和坐标轴进行设置展开（对图像的设置在后续介绍到各种图绘制时介绍）。&lt;/p&gt;
&lt;p&gt;这里所说的文本是指在使用matplotlib作图过程中通过代码的方式往图中添加的各种文字，包括figure标题、axes标题、坐标轴标签、坐标轴刻度标签、注释、普通文本等。轴设置指的是对与坐标轴相关的的元素的设置，例如显示范围、刻度、刻度标签等。&lt;/p&gt;
</description>
<pubDate>Sun, 01 Mar 2020 23:53:00 +0000</pubDate>
<dc:creator>奥辰</dc:creator>
<og:description>在一幅图表中，文本、坐标轴和图像的是信息传递的核心，对着三者的设置是作图这最为关心的内容，在上一篇博客中虽然列举了一些设置方法，但没有进行深入介绍，本文以围绕如何对文本和坐标轴进行设置展开（对图像的设</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/chenhuabin/p/12393720.html</dc:identifier>
</item>
<item>
<title>聊聊RabbitMQ那一些事儿之一基础应用 - 程序员修炼之旅</title>
<link>http://www.cnblogs.com/xiaoXuZhi/p/RabbitMQ_01.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaoXuZhi/p/RabbitMQ_01.html</guid>
<description>&lt;p&gt;RabbitMQ的简介，关键词，以及是如果运行的，其运作模式有哪一些，在使用的时候需要注意一些什么。带着这一些问题，一起进入到文章中去。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;199.5&quot;&gt;

&lt;p&gt;&lt;span&gt;　　Hi,各位热爱技术的小伙伴您们好，今年的疫情&lt;span class=&quot;character selected js_checktext&quot; data-splitid=&quot;1583103308169_0.7364861081301048&quot; data-text=&quot;%E5%AE%B3&quot;&gt;害人啊，真心祝愿您和您的家人大家都平平安安，健健康康。年前到现在一直没有总结点东西，写点东西，不然久了自己感觉自己都要被废啦。这个周末花了一些时间来梳理了一下RabbitMQ的相关知识点。先来一个基础篇，先用起来。我也是一个边学习边梳理的过程，如果有什么梳理的不妥之处，多多指点，相互学习，谢谢！&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在使用前，我们首先第一件事情就是环境搭建。至于RabbitMQ的环境搭建，我就不在此啰嗦了，网上一搜一大堆，还没有搭建环境的小伙伴，可以网上找度娘哈，嘿嘿。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;一、&lt;strong&gt;什么是MQ&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　MQ简单的说就是队列，队列的特性就是先进先出。我们其实可以把队列理解为一个消息管道，通过消息管道实现消息传递。最终达到不同的进程间、不同服务间的通讯需要。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在一个程序中，我们 可以通过MQ实现不同进程间的通讯。在不同程序/服务间，我们同样可以通过MQ来实现相互通讯，这也是本文的重点，这个时候就该今天的主角登场了。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;二、&lt;strong&gt;RabbitMQ&lt;/strong&gt;&lt;strong&gt;介绍&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　RabbitMQ是一个开源的，在AMQP基础完整的，可复用的企业消息系统。我个人的简单的理解就是，实现消息的接收、存储、管理、分发。在操作系统支持上，支持主流的操作系统（Linux、Windows）；在开发语言接口支持上，支持所有的主流开发语言；在性能上，支持消息持久化、集群化、高并发等等。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;三、&lt;strong&gt;RabbitMQ&lt;/strong&gt;&lt;strong&gt;关键词介绍&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　Broker（Server）：接受客户端连接，实现AMQP消息队列和路由功能的进程，我们可以把Broker叫做RabbitMQ服务器。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Virtual Host：一个虚拟概念，其实简单的理解你可以认为是在逻辑上对MQ进行分区隔离，这样避免不同业务的MQ直接交叉感染。一个Virtual Host里面可以有若干个Exchange和Queue，主要用于权限控制，隔离应用。如应用程序A使用VhostA，应用程序B使用VhostB，那么我们在VhostA中只存放应用程序A的exchange，queue和消息，应用程序A的用户只能访问VhostA，不能访问VhostB中的数据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Exchange：接受生产者发送的消息，并根据Binding规则将消息路由给服务器中的队列。ExchangeType决定了Exchange路由消息的行为，例如，在RabbitMQ中，ExchangeType有Direct、Fanout、Topic和Header四种，不同类型的Exchange路由规则是不一样的（这些以后会详细介绍）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Queue：消息队列，用于存储还未被消费者消费的消息，队列是先进先出的，默认情况下先存储的消息先被处理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Message：就是消息，由Header和Body组成，Header是由生产者添加的各种属性的集合，包括Message是否被持久化、由哪个Message Queue接受、优先级是多少等，Body是真正传输的数据，内容格式为byte[]。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Connection：连接，对于RabbitMQ而言，其实就是一个位于客户端和Broker之间的TCP连接。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Channel：&lt;span class=&quot;character selected js_checktext&quot; data-splitid=&quot;1583103308205_0.8096727944605935&quot; data-text=&quot;%E4%BF%A1&quot;&gt;信&lt;span class=&quot;character selected js_checktext&quot; data-splitid=&quot;1583103308205_0.8096727944605935&quot; data-text=&quot;%E9%81%93&quot;&gt;道，仅仅创建了客户端到Broker之间的连接Connection后，客户端还是不能发送消息的。需要在Connection的基础上创建Channel，AMQP协议规定只有通过Channel才能执行AMQP的命令，一个Connection可以包含多个Channel。之所以需要Channel，是因为TCP连接的建立和释放都是十分昂贵的。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;四、&lt;strong&gt;RabbitMQ&lt;/strong&gt;&lt;strong&gt;三大角色介绍&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　通过上面的一些简单介绍，我相信你对MQ有了一个初步的印象。也许你会云里雾里的，到底是怎么运行起来的啊，来一个实际点的。哈哈，不急，下面马上进入RabbitMQ跑起来阶段。其实要跑起来，我们还要简单介绍一下RabbitMQ重要的三个角色：生产者、服务器、消费者。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　生产者：也就是消息生产方，通过RabbitMQ提高的API，将消息推送到RabbitMQ服务器。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　服务器：RabbitMQ的服务中心，接收生产者生产的消息，并根据分发规则，将消息推送到对应的消费者。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　消费者：顾名思义，就是消息的最终接收处理者。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这样一来，我相信大家脑海里面已经有一个画面了，生产者--生成消息--&amp;gt;服务器--转发--&amp;gt;消费者（最终处理消息）。这就是一个消息的整体流程和生命周期。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SIB9aSbJhQm9cYlJexrAmueZjJ1icCUz4qWYKXicmh9suy3DgOmnE6kJMYIW8ZTUiaiakAFd08mlMRDM06q68icHcrw/640?wx_fmt=png&quot; alt=&quot;&quot; data-ratio=&quot;0.19827586206896552&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;580&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;五、RabbitMQ跑起来&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　通过上面的介绍，我们应该知道MQ的简单的消息交互的流程。有了这个基础，下面我们就分类来介绍一下三大角色的数据交付方式。整体上来说，数据交互方式上有以下5种方式（5种工作模式），在网上找了一张图，很方便的供大家参考。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SIB9aSbJhQm9cYlJexrAmueZjJ1icCUz4Tib2Rd5zCtoibz6ZLMBJUcDdyMqGgibAkG2Vq1WO8LNqGBibkWOPmQSdjw/640?wx_fmt=png&quot; alt=&quot;&quot; data-ratio=&quot;0.5690376569037657&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;956&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　其实通过上面的图，我们会发现，前两种情况，消费者和生成者之间都是直接通过连接，后面三种情况，消费者和生产者直接有一层交换机（Exchange）。这样一来，我们可以从整体上分为两个大类：其一、消息直推队列；其二、消息推送给交换机，交换机根据路由规则转发至队列。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　其实在实际的工作中，第一大类，我们是不会使用到的，都是采用的第二大类来实现实际的项目开发需求。但是第一大类，能够很好的将我们先领我们入门，先简单的把程序跑起来。由于时间原因，今天我们也就先实现第一大类的两种情况，第二大类的，明后天在专门的文章来详细介绍。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;简单模式：&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;简单模式就是只有一个生产者，一个消费者。这个很简单，下面用一个实际例子来说明。直接贴代码：&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;生产者代码： &lt;/h3&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;43&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
/// &amp;lt;summary&amp;gt;
 /// 消息生成者
 /// &amp;lt;/summary&amp;gt;
public class Program
{
    static void Main(string[] args)
    {
        // rabbitMQ链接对象
        var factory = new ConnectionFactory();
        // RabbitMQ服务在本地运行
        factory.HostName = &quot;192.168.1.1&quot;;
        // RabbitMQ服务端口
        factory.Port = 5672;
        // 用户名
        factory.UserName = &quot;guest&quot;;
        // 密码
        factory.Password = &quot;guest&quot;;
        // 虚拟主机名称
        factory.VirtualHost = &quot;/&quot;;

        // 队列名称
        string queueName = &quot;hello&quot;;

        // 创建链接
        using (var connection = factory.CreateConnection())
        {
            // 创建通道
            using (var channel = connection.CreateModel())
            {
                // 创建一个名称为hello的消息队列--当然一步也可以通过RabbitMQ管理后台添加
                // 当已经存在该队列时，不会重复添加，但是如果已存在的队列和新建的队列存在属性差异时，会创建失败，会抛异常，所以在实际使用时，如果要通过程序创建队列，最好要捕捉异常，避免因为这样的问题而导致程序崩溃。
                channel.QueueDeclare(queueName, false, false, false, null);
                Console.WriteLine(&quot;我是生成者&quot;);

                while (true)
                {
                    Console.WriteLine(&quot;请输入你要发送的消息,并按Enter键结束&quot;);

                    // 接收用户输入的消息
                    string message = Console.ReadLine();
                    // 消息编码
                    var body = Encoding.UTF8.GetBytes(message);
                    // 向消息服务器推送消息
                    channel.BasicPublish(&quot;&quot;, queueName, null, body);

                    Console.WriteLine($&quot;已发送 {System.DateTime.Now.ToString(&quot;HH:mm:ss&quot;)}： {message}&quot;);
                }
            }
        }
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　消费者代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;43&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
 /// &amp;lt;summary&amp;gt;
 /// 消息消费者
 /// &amp;lt;/summary&amp;gt;
 public class Program
 {
     static void Main(string[] args)
     {
         // rabbitMQ链接对象
         var factory = new ConnectionFactory();
         // RabbitMQ服务在本地运行
         factory.HostName = &quot;192.168.1.1&quot;;
         // RabbitMQ服务端口
         factory.Port = 5672;
         // 用户名
         factory.UserName = &quot;guest&quot;;
         // 密码
         factory.Password = &quot;guest&quot;;
         // 虚拟主机名称
         factory.VirtualHost = &quot;/&quot;;

         // 队列名称
         string queueName = &quot;hello&quot;;

         // 创建链接
         using (var connection = factory.CreateConnection())
         {
             // 创建通道
             using (var channel = connection.CreateModel())
             {

                 // 创建一个名称为hello的消息队列--当然一步也可以通过RabbitMQ管理后台添加
                 // 当已经存在该队列时，不会重复添加，但是如果已存在的队列和新建的队列存在属性差异时，会创建失败，会抛异常，所以在实际使用时，如果要通过程序创建队列，最好要捕捉异常，避免因为这样的问题而导致程序崩溃。
                 channel.QueueDeclare(queueName, false, false, false, null);
                 Console.WriteLine(&quot;我是消费者&quot;);

                 // 创建一个消费者
                 var consumer = new EventingBasicConsumer(channel);
                 // 订阅对应的消息 autoAck:是否自动确认
                 channel.BasicConsume(queueName, autoAck:false, consumer);

                 consumer.Received += (model, ea) =&amp;gt;
                 {
                     var body = ea.Body;
                     var message = Encoding.UTF8.GetString(body);
                     Console.WriteLine($&quot;已接收 {System.DateTime.Now.ToString(&quot;HH:mm:ss&quot;)}： {message}&quot;);

                     // 为了模拟推送过程，在此程序休息1分钟
                     Thread.Sleep(6000);
                     // 确认消费
                     channel.BasicAck(ea.DeliveryTag, false);
                 };
                 Console.ReadLine();
             }
         }
     }
 }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SIB9aSbJhQm9cYlJexrAmueZjJ1icCUz4CbRUVtWtG8ibu9AzgPKlM7icQOra4fPHkricTQptlqic9a8f3OTmkphK6Q/640?wx_fmt=png&quot; alt=&quot;&quot; data-ratio=&quot;0.345&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　通过实际的运行结果图，我们很清楚的知道，生产者的消息发生顺序，和消费者消费的顺序是一直的，这也就MQ的基本原理所在。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上面介绍了简单模式，下面我在来介绍一下比简单模式复杂一点的工作模式。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;工作模式：&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　我理解的简单模式，只是带我们入门，让我们明白MQ的运行效果是咋样的。但是在实际工作中，不可能只会有一个消费者，在实际的生产环境中生产者、消费者都可能会有多个存在，这也就是我们说的工作模式。那么，有多个生成的者的时候，不同的生产者之间又是怎么来消费消息的呢?下面我们先通过实践的例子来说明：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　具体的代码和上面的代码是一样的，我们可以直接开两个消费者就可以实现数据模拟，直接看运行结果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SIB9aSbJhQm9cYlJexrAmueZjJ1icCUz4V7POoIjfH411fJXVPtNmuk0IbKBz6embqCRDvtLN8r13LAJkUQs5Uw/640?wx_fmt=png&quot; alt=&quot;&quot; data-ratio=&quot;0.4938101788170564&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;727&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　同上面的实际运行结果我们可以简单的得出以下结论：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　当一个队列有多个消费者时，在生成的实时消息时，消息队列服务器会轮&lt;span class=&quot;character selected js_checktext&quot; data-splitid=&quot;1583103308303_0.3456290050177686&quot; data-text=&quot;%E8%AF%A2&quot;&gt;询的均匀的分发给每一个消费者。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　哈哈哈，注意了，上面的结论我说的是实时消息哦，这里面就包含了一个坑，在实际的使用过程中要特别注意。那就是历史消息处理上，在实际项目使用过程中，我们经常会遇到，当消费者打开时，队列中已经有很多消息待消费，这个时候又该如何保证多个消费均匀分配消息呢?避免忙绿的消费者累死现象。其实很简单，只需在消费端加上如下一个配置即可：&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;code-snippet__js code-snippet code-snippet_nowrap&quot; data-lang=&quot;cs&quot;&gt;
&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
 // 通过Qos设置每次接收消息的条数
 // 三个参数说明
 // prefetchSize：为预取的长度，一般设置为0即可，表示长度不限
 // prefetchCount：表示预取的条数，即发送的最大消息条数
 // global表示是否在Connection中全局设置，true表示Connetion下的所有channel都设置为这个配置。
 channel.BasicQos(prefetchSize: 0,
                  prefetchCount: 1,
                  global: false);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;　　上面的配置中，最关键的一个参数就是prefetchCount，当我们设置为1时，就是能够实现均匀的分发。下面分别对prefetchCount设置不同的值，来看看不同的效果：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　实例一：将prefetchCount设置为10，并生成3条历史消息，然后同时打开两个消费者，看看3条消息的分发消费情况：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SIB9aSbJhQm9cYlJexrAmueZjJ1icCUz4hvj4WroLf8fiaE1FgzAAFalia5H9xycydnVJkx02fRlFlSF0qeKGPz0Q/640?wx_fmt=png&quot; alt=&quot;&quot; data-ratio=&quot;0.45045045045045046&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;777&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　通过图，我们得出，3条历史消息全部推送给了一个消费者，这样就导致了一个消费者累死，一个消费者闲的慌。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　实例二：将prefetchCount设置为1，并生成4条历史消息，然后同时打开两个消费者，看看3条消息的分发消费情况：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SIB9aSbJhQm9cYlJexrAmueZjJ1icCUz40cIlvWt3zgRYibp4ZMejGW2ic5W5TUPIhEUnvuD1S7lFaLiakodZzFAiag/640?wx_fmt=png&quot; alt=&quot;&quot; data-ratio=&quot;0.3404761904761905&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;840&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;　　通过图，我们得出，4条历史消息平均的分发给了两个消费者，这也是我们想要的效果。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　所以在实际工作中，一定要注意这一个细节，不然有可能导致在服务器重启时，有的服务器直接卡死现象。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　好了，时间不早了，今天就先写到这，明天我们继续分享后面的几种模式。在分析完每一种模式后，我还好结合实际，封装一个dll出来，供大家参考，到时候也会直接把源码提出来。欢迎大家关注，持续交流。疫情无情，我们学习不能停。加油吧，每一个小伙伴！​&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;END&lt;br/&gt;为了更高的交流，欢迎大家关注我的公众号，扫描下面二维码即可关注，谢谢：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/381957/201912/381957-20191228212329551-622814065.jpg&quot; alt=&quot;&quot; width=&quot;262&quot; height=&quot;262&quot;/&gt;&lt;/p&gt;

&lt;/div&gt;</description>
<pubDate>Sun, 01 Mar 2020 23:26:00 +0000</pubDate>
<dc:creator>程序员修炼之旅</dc:creator>
<og:description>RabbitMQ的简介，关键词，以及是如果运行的，其运作模式有哪一些，在使用的时候需要注意一些什么。带着这一些问题，一起进入到文章中去。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiaoXuZhi/p/RabbitMQ_01.html</dc:identifier>
</item>
<item>
<title>IdentityServer4迁移至3.x版本注意问题详解 - Jeffcky</title>
<link>http://www.cnblogs.com/CreateMyself/p/12391267.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CreateMyself/p/12391267.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;之前有一位购买我课程的童鞋利用最新的IdentityServer4版本即对应.NET Core 3.x，发布到生产环境在学习，结果出了一些问题，此前我并未过多关注IdentityServer4升级到3.x版本，所以在此做一个基本的总结，或许能对出现相同问题的童鞋能提供一点帮助。&lt;/p&gt;
&lt;h2&gt;IdentityServer4迁移至3.x版本问题&lt;/h2&gt;
&lt;p&gt;针对将.NET Core 2.x升级到3.x就不用再多讲，请参看官方迁移文档（&lt;a href=&quot;https://docs.microsoft.com/en-us/aspnet/core/migration/22-to-30?view=aspnetcore-3.1&amp;amp;tabs=visual-studio&quot;&gt;https://docs.microsoft.com/en-us/aspnet/core/migration/22-to-30?view=aspnetcore-3.1&amp;amp;tabs=visual-studio&lt;/a&gt;），我们只介绍对于对于配置IdentityServer4方面的更改变化&lt;/p&gt;
&lt;h3&gt;.NET Core Identity&lt;/h3&gt;
&lt;p&gt;对于Identity里面的上下文【IdentityDbContext】需要额外下载包【Microsoft.AspNetCore.Identity.EntityFrameworkCore】&lt;/p&gt;
&lt;h3&gt; OIDC配置&lt;/h3&gt;
&lt;p&gt; 针对如下客户端OIDC的配置，需要下载包【Microsoft.AspNetCore.Authentication.OpenIdConnect】&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/589642/202003/589642-20200301203928050-756771280.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;授权中间件配置 &lt;/h3&gt;
&lt;p&gt;针对客户端认证和授权配置，需要如下配置授权中间件（认证和授权无先后顺序）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/589642/202003/589642-20200301210324084-985625421.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;迁移类生成&lt;/h3&gt;
&lt;p&gt;我们知道在此之前对于迁移命名是包含在dotnet CLI里面，现已修改为通过单独的包来进行，所以我们需要下载包【Microsoft.EntityFrameworkCore.Design】，否则将抛出如下异常&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/589642/202003/589642-20200301210917368-864226369.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;还有可能遇到命令行工具版本和当前.NET Core版本不一致的问题，通过如下命令进行更新&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用PowerShell或CMD命令更新

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;更新到指定版本&lt;/span&gt;
（&lt;span&gt;1&lt;/span&gt;）dotnet tool update --&lt;span&gt;global&lt;/span&gt; dotnet-ef --version &lt;span&gt;3.1&lt;/span&gt;.2

  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;更新到最新版本&lt;/span&gt;
（&lt;span&gt;2&lt;/span&gt;） dotnet tool update --&lt;span&gt;global&lt;/span&gt; dotnet-ef
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Cookie安全策略问题（划重点） &lt;/h3&gt;
&lt;p&gt;在本地环境可能么有任何问题，但是到了生产环境，可能会抛出如下错误，我们是不是会一脸懵逼呢。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
warn: Microsoft.AspNetCore.Authentication.OpenIdConnect.OpenIdConnectHandler[&lt;span&gt;15&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.AspNetCore.Correlation.oidc.x9I39lxuVXliU0_mOAEPEbZy_EPESHQQRvq7LPatX7rv7y_vQi-HKLIwqNacHM62AeKarJVmr_KvjAL7nSX6hdeR&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; cookie not found.
info: Microsoft.AspNetCore.Authentication.OpenIdConnect.OpenIdConnectHandler[&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;]
Error &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; RemoteAuthentication: Correlation failed..
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这要从Cookie的出生故事说起，大约在20年前设计cookie时以及之后重新设计该cookie时，跨站点请求伪造（CSRF）攻击和跟踪用户都不是什么大事，在cookie规范中说，如果为特定域设置了cookie，则浏览器发出的每个请求都会将其发送到该域，无论我们是否直接导航到该域，如果浏览器只是从该域加载资源（即图像），向其发送POST请求或将其一部分嵌入到iframe中，但是还有一种情况，我们并不希望浏览器自动将用户会话cookie发送到服务器，因为这将允许任何网站会执行脚本，该脚本在该用户的上下文中对服务器执行请求，为避免这种情况，于2016年起草了SameSite cookie规范，它使我们可以更好地控制何时应发送和不应该发送cookie，设置cookie时，我们现在可以在浏览器将其添加到其中时为每个cookie明确指定，为此，它引入了当浏览器位于我们自己的域上时相同站点cookie的概念，以及当浏览器导航到另一个域但将请求发送到我们的域时跨站点cookie的概念，为了向后兼容，相同站点cookie的默认设置并不会更改以前的行为，若我们加入该新功能，需要将cookie显式设置为SameSite = Lax或SameSite = Strict，以使其更加安全，这已在.NET Framework和所有常见的浏览器中实现，Lax表示将在初始导航时将cookie发送到服务器，Strict表示仅在我们已经在该域中时（即在初始导航之后发送第二个请求）才发送cookie。但是呢，这项新功能却并没有被广泛采用（基于2019年3月Chrome的遥测数据，Chrome在全球范围内处理的所有cookie中，只有0.1％使用了SameSite标志，Google为了实现推动该新功能的目标，他们决定更改世界上最常用的浏览器的默认设置：Chrome 80将需要新指定的设置SameSite = None来保持处理Cookie的旧方法，并且如果我们像建议的旧规范那样省略SameSite字段的话，它将cookie与SameSite = Lax一起设置，&lt;span&gt;请注意：仅当cookie也被标记为Secure并且需要HTTPS连接时，设置SameSite = None才有效，&lt;/span&gt;这里关于更多SameSite的信息就不再阐述。如果我们有一个单页Web应用程序（SPA），该Web应用程序通过另一个域上托管的身份提供程序（例如IdentityServer 4中的Idp）进行身份验证，并且该应用程序使用所谓的令牌刷新，则将会受到影响，登录IdP时，它将为我们的用户设置一个会话cookie，并且该cookie来自IdP域，在身份验证流程结束时，来自不同域的应用程序将收到某种访问令牌，这些令牌通常生命周期并不长，当该令牌过期时，应用程序将无法再访问资源服务器（API），如果用户每次都必须再次登录，可想用户体验之差，为防止这种情况，我们可以使用刷新令牌，在这种情况下，应用程序将创建一个用户不可见的iframe，然后在该iframe中再次启动身份验证过程， IdP的网站已加载到iframe中，并且如果浏览器通过IdP发送会话cookie，则会识别用户并发出新令牌，现在，iframe位于应用程序域中托管的SPA中，其内容来自IdP域，这将被视为跨站点请求，因此，如果Cookie明确指出SameSite = None，则Chrome 80只会将该Cookie从iframe发送到IdP，否则，令牌刷新将在Chrome 80中出现中断的情况。也还有其他可能潜在的问题，如果我们在Web应用程序或网站中嵌入了来自另一个域的元素（例如视频），并且这些元素需要Cookie才能正常运行（例如自动播放设置），那么这些也会需要设置SameSite策略，如果我们的应用程序需要从浏览器请求依赖Cookie身份验证的第三方API，则同样适用，我们只能更改自己服务器从而设置cookie行为。&lt;/p&gt;

&lt;p&gt;讲解了这么多貌似好像没有用的废话，实际上就是出现了跨站点安全策略即SameSite的设定，如上异常的抛出，追本溯源在于是什么原因导致了客户端的Cookie丢失？通过上述对Cookie的讲解，我们可以显式设置SameSite安全策略从而保证到底发不发送Cookie，所以我猜测在.NET Core 3.x中是不是更改了Cookie的安全策略，如果客户端的为Strict的话，那就会导致上述异常的发生，比如如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/589642/202003/589642-20200301222823591-1598283466.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;说到这里，为了验证我的结论，我立马翻看了关于.NET Core中Cookie对于安全策略的设置，难道真的将Strict作为默认的安全策略吗？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/589642/202003/589642-20200301230457201-1282733102.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;原来该安全策略的默认选项就是Lax（宽松策略），然后继续来到上述的issue（&lt;a href=&quot;https://github.com/aspnet/Security/issues/1231&quot;&gt;https://github.com/aspnet/Security/issues/1231&lt;/a&gt;），在2.0中就解决了此问题将Strict修改为了Lax，就是为了解决OAuth中重定向跳转认证的问题。这个结果虽在意料之中，但是也在意料之外，那位童鞋也遇到了抛出上述异常的问题，我就是显式设置上述安全策略为Lax得到了解决，让我很是纳闷，这是何故，我也不知道，但是确确实实是解决了，最终客户端也正常跑起来了，真是（捂脸）的表情。最后也同样重要的是，&lt;span&gt;IdentityServer4在生产环境中是启用了HTTPS，所以在发布到生产环境后若未使用HTTPS，一定要将启用HTTPS选项显式配置为false，而本地则不然，遇到问题首先分析问题，然后看官方文档，如若还不能解决，只能通过经验来进行可能原因分析了。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;本节我只是将IdentityServer4升级到.NET Core 3.x的版本需要注意的问题做了一个粗略的解答，根据我的经验，一部分原因出在对于官方文档概念未详细解导致，另外一部分原因出在由于版本升级导致内置处理出现了更改，但官方文档并未更新，这个最麻烦，出现这样的问题只能硬啃源代码并调试，我也同时将我原先在长沙社区成立时所演讲的IDS4 Demo已更新到了最新.NET Core 3.1.2版本（&lt;a title=&quot;https://github.com/wangpengxpy/IdentityServer4Sample&quot; href=&quot;https://github.com/wangpengxpy/IdentityServer4Sample&quot; target=&quot;_blank&quot;&gt;https://github.com/wangpengxpy/IdentityServer4Sample&lt;/a&gt;）。&lt;/p&gt;
</description>
<pubDate>Sun, 01 Mar 2020 23:15:00 +0000</pubDate>
<dc:creator>Jeffcky</dc:creator>
<og:description>前言 之前有一位购买我课程的童鞋利用最新的IdentityServer4版本即对应.NET Core 3.x，发布到生产环境在学习，结果出了一些问题，此前我并未过多关注IdentityServer4升</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/CreateMyself/p/12391267.html</dc:identifier>
</item>
<item>
<title>如何正确使用redis分布式锁 - 悟空不败</title>
<link>http://www.cnblogs.com/wukongbubai/p/12393370.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wukongbubai/p/12393370.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;  笔者在公司担任技术面试官,在笔者面试过程中,如果面试候选人提到了reids分布式锁,笔者都会问一下redis分布式锁的知识点,但是令笔者遗憾的是,该知识点十个人中有九个人都答得不清楚,或者回答错误,这让笔者有了写这篇文章的想法,来帮助童鞋们正确认识reids分布式锁.&lt;/p&gt;
&lt;h2 id=&quot;什么是分布式锁为什么需要分布式锁&quot;&gt;什么是分布式锁?为什么需要分布式锁?&lt;/h2&gt;
&lt;p&gt;  在java中,在单进程多线程的情况下,为了防止多个线程共同竞争同一个资源,因此需要锁,java中有显示锁和隐式锁来保证,而在多进程的情况下,普通的锁就无法满足要求了,因此我们需要分布式锁,常用的分布式锁解决方案有三种,分别是基于数据库/redis/zookeeper,本文我们主要讨论redis分布式锁.&lt;/p&gt;
&lt;h2 id=&quot;redis分布式锁实现&quot;&gt;redis分布式锁实现&lt;/h2&gt;
&lt;p&gt;  笔者在面试过程中,问redis分布式锁知识点时的第一个问题就是如何实现一个redis分布式锁,许多候选人直接说,啊,这很简单啊,使用setNx()方法,设置一个过期时间就可以了,我接着问,那如何释放锁锁呢?候选人回答说,那很简单啊,直接调用delete方法就可以了,我接着问,释放锁直接调用delete方法就可以了吗?候选人回答,对啊,delete方法也是线程安全的,我.....那么如何实现一个redis分布式锁,我们用代码来演示一下,首先来看一下加锁的代码片段:&lt;br/&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9ncmFwaC5iYWlkdS5jb20vcmVzb3VyY2UvMjIyYWE3YjgyM2RjNjgyZmViYjU4MDE1ODMwODUxMzIucG5n?x-oss-process=image/format,png&quot; alt=&quot;file&quot;/&gt;&lt;br/&gt;  首先我们的分布式锁实现了Lock接口,然后主要看我们的lock方法,阻塞式自旋锁,加锁方法直接使用tryLock(),接下来我们再来看看tryLock()方法:&lt;br/&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9ncmFwaC5iYWlkdS5jb20vcmVzb3VyY2UvMjIyNjM5OTNiMWFiYzAwMDYwNmZkMDE1ODMwODUxNDUucG5n?x-oss-process=image/format,png&quot; alt=&quot;file&quot;/&gt;&lt;br/&gt;  其实很简单,主要是调用redis的set方法(其中UUID笔者为了方便演示,直接使用UUID,在分布式的生产环境下应该使用诸如雪花算法等来保证分布式系统下UUDI的唯一性),如果返回OK则说明加锁成功,否则失败,再来看看释放锁的方法,面试过程中很多候选人童鞋说直接调用delete方法,我们写一段代码,然后分析一下直接调用delete方法的问题:&lt;br/&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9ncmFwaC5iYWlkdS5jb20vcmVzb3VyY2UvMjIyZjQ2NTQwYjRmNzdmOWFiNTZmMDE1ODMwODUxNTgucG5n?x-oss-process=image/format,png&quot; alt=&quot;file&quot;/&gt;&lt;br/&gt;  如上一段代码,假设一种极端场景下有两个线程A和B,A线程先获取锁,设置过期时间为10秒,然后A线程执行释放锁操作,执行到if判断语句并且成功进入时,此时耗时刚好10秒,锁过期了,并且CPU分配给A线程的时间片刚好用完,此时B线程开始执行并且成功获取到该分布式锁,然后执行一段时间后B线程的时间片用完,此时A继续执行删除操作,此时A删除的就是B线程的锁,会造成误删除操作,因此为了避免这种情况,我们需要一种机制来保证判断和删除操作的原子性,redis官方推荐我们使用lua脚本,因此正确的解锁方式如下:&lt;br/&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9ncmFwaC5iYWlkdS5jb20vcmVzb3VyY2UvMjIyOTkxODQzNDZhMGJlY2UwMzEyMDE1ODMwODUxNjkucG5n?x-oss-process=image/format,png&quot; alt=&quot;file&quot;/&gt;&lt;br/&gt;  其中的UNLOCK_LUA_SCRIPT如下:&lt;br/&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9ncmFwaC5iYWlkdS5jb20vcmVzb3VyY2UvMjIyOGYxMjhjZGFlMDAxOGVkYWQxMDE1ODMwODUxNzcucG5n?x-oss-process=image/format,png&quot; alt=&quot;file&quot;/&gt;&lt;br/&gt;  redis使用lua脚本能保证该操作的原子性,因此这样才能正确释放分布式锁.这也回答了为什么之前说释放锁的时候直接调用delete方法是错误的.&lt;/p&gt;
&lt;h2 id=&quot;有什么问题&quot;&gt;有什么问题?&lt;/h2&gt;
&lt;p&gt;  在上文中,我们使用redis构建了一个分布式锁,但是请注意,该代码在单机环境下没有任何问题,但是我们在生产中往往都是redis集群部署,由于redis主从节点的数据同步是异步的,如果Redis的master节点在锁未同步到Slave节点的时候宕机了怎么办？举例来说:&lt;br/&gt;  1.进程A在master节点获得了锁。&lt;br/&gt;  2.在锁同步到slave之前，master宕机，数据还没有同步到slave&lt;br/&gt;  3.slave变成了新的master节点&lt;br/&gt;  4.进程B也得到了和A相同的锁.&lt;br/&gt;  因此,如果你的业务允许在master宕机期间，多个客户端允许同时都持有锁,那如上的分布式锁是可以接受的,否则就不能使用上述的分布式锁,在这种情况下,redis官方为我们提供了另一种解决方案----RedLock算法.&lt;/p&gt;
&lt;h2 id=&quot;redlock算法&quot;&gt;RedLock算法&lt;/h2&gt;
&lt;p&gt;  假设我们有N个Master节点(N一般为奇数),这些节点互相之间相互独立,不需要进行数据同步,我们用在单节点获取和释放锁的方式来操纵这些节点,具体过程为:&lt;br/&gt;  1.获取当前时间(单位是毫秒)。&lt;br/&gt;  2.轮流用相同的key和随机值在N个节点上请求锁，在这一步里，客户端在每个master上请求锁时，会有一个和总的锁释放时间相比小的多的超时时间。比如如果锁自动释放时间是10秒钟，那每个节点锁请求的超时时间可能是5-50毫秒的范围，这个可以防止一个客户端在某个宕掉的master节点上阻塞过长时间，如果一个master节点不可用了，我们应该尽快尝试下一个master节点。&lt;br/&gt;  3.客户端计算第二步中获取锁所花的时间，只有当客户端在大多数master节点上成功获取了锁（N/2+1在这里是3个），而且总共消耗的时间不超过锁释放时间，这个锁就认为是获取成功了。&lt;br/&gt;  4.如果锁获取成功了，那现在锁自动释放时间就是最初的锁释放时间减去之前获取锁所消耗的时间。&lt;br/&gt;  5.如果锁获取失败了，不管是因为获取成功的锁不超过一半（N/2+1)还是因为总消耗时间超过了锁释放时间，客户端都会到每个master节点上释放锁，即便是那些他认为没有获取成功的锁。&lt;br/&gt;  有关RedLock的算法,可以详见&lt;a href=&quot;https://redis.io/topics/distlock&quot;&gt;官网文档&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;redlock算法是否真的足够安全&quot;&gt;RedLock算法是否真的足够安全?&lt;/h2&gt;
&lt;p&gt;  要回答这个问题,可以看看国外大神&lt;a href=&quot;https://martin.kleppmann.com&quot;&gt;Martin Kleppmann&lt;/a&gt;在他的一篇文章&lt;a href=&quot;https://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html&quot;&gt;How to do distributed locking&lt;/a&gt;中详细描述了为什么他认为RedLock仍然是不安全的,简单来说,RedLock最大的弊端有两个:&lt;br/&gt;  1.进程由于各种原因pause,类似于上文说的多线程间的时间片切换,比如由于GC停顿等导致锁过期,但是进程并未感知到,同时另一个进程已经获取了该分布式锁,就会导致奇怪的结果发生.&lt;br/&gt;  2.算法对时钟依赖性太强,假设N个节点为5,按照超过一半的原则,假设进程X成功获取了A/B/C三个节点的锁,此时认为X获取锁成功,此时X在TTL时间段内没有执行完成,锁到期自动释放,此时由于C节点的时间比A/B节点快,导致C节点先释放锁,此时Y节点获取了C/D/E三个节点的锁,又导致两个进程获取了同一个锁.&lt;br/&gt;  无论如何,在多master节点的情况下,没有任何方案能完美保证RedLock的绝对安全,因此,我们在使用redis分布式锁的时候一定要弄清楚我们的目的是什么?一般来说,有两种情况:&lt;br/&gt;  1.为了提高性能.比如持有该锁使我们的程序不会进行重复的计算,在这种情况下,如果锁失败了我们付出的代价仅仅是进行了重复的计算,不会影响我们的业务结果.&lt;br/&gt;  2.为了保证业务的正确性.比如我们是一个银行系统,为了保证转账操作扣款唯一性,拥有该锁可以确保我们的扣款操作的唯一性,如果锁失效,会导致多次扣款,这是无法接受的.&lt;/p&gt;
&lt;p&gt;  如果我们是为了提升性能,那没有必要使用RedLock算法,它成本高(假设需要5个master节点,这些节点还要保证高可用,则需要更多的节点)且又复杂,不如使用在单机情况下的分布式锁,前提是你的业务能容忍我们上述说的宕机期间相同锁的问题.&lt;br/&gt;  如果是为了保证业务的正确性,我们说了RedLock也不能完美保证绝对安全,因此也不能放心的使用RedLock.&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;  总而言之,使用Redis分布式锁实在不是一个好的选择,Redis设计的初衷也并不是满足分布式锁的需求.对于需求性能的分布式锁应用它太重了且成本高;对于需求正确性的应用来说它不够安全.如果你的应用只需要高性能的分布式锁并且不要求多高的正确性,那么单节点的Redis分布式锁足够了;如果你的应用想要保证正确性,那么不建议 RedLock,建议使用一个合适的一致性协调系统,比如基于Zookeeper的分布式锁!&lt;/p&gt;
&lt;blockquote readability=&quot;4.1509433962264&quot;&gt;
&lt;p&gt;本文由博客一文多发平台 &lt;a href=&quot;https://openwrite.cn?from=article_bottom&quot;&gt;OpenWrite&lt;/a&gt; 发布！&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sun, 01 Mar 2020 18:11:00 +0000</pubDate>
<dc:creator>悟空不败</dc:creator>
<og:description>前言 笔者在公司担任技术面试官,在笔者面试过程中,如果面试候选人提到了reids分布式锁,笔者都会问一下redis分布式锁的知识点,但是令笔者遗憾的是,该知识点十个人中有九个人都答得不清楚,或者回答错</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wukongbubai/p/12393370.html</dc:identifier>
</item>
<item>
<title>《算法导论》图相关算法小结 - 五岳</title>
<link>http://www.cnblogs.com/wuyuegb2312/p/12390576.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wuyuegb2312/p/12390576.html</guid>
<description>&lt;p&gt;《算法导论》图相关的内容贯穿很多章节，适用条件各异，而且都有证明过程。如果不打算熟记证明，仅仅是应用，遇到具体场景再去回忆适用于哪种算法不太方便。汇总一下便于查阅。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;74&quot;&gt;
&lt;p&gt;最近又抽空读了一遍《算法导论》，关于图的内容贯穿了多个章节（比如在动态规划一章埋了无权最短路径的伏笔，后面才专门讲），适用条件各异，而且都有证明过程。&lt;br/&gt;如果不打算熟记证明，仅仅是应用，遇到具体场景再去回忆适用于哪种算法不太方便。&lt;/p&gt;
&lt;p&gt;以下内容以手头的机械工业出版社基于原书第2版的译本整理了一下，便于速查。&lt;br/&gt;不包含思考题、标注为“*”的章节和习题内容。&lt;/p&gt;
&lt;h2 id=&quot;符号定义&quot;&gt;符号定义&lt;/h2&gt;
&lt;p&gt;一般地，&lt;br/&gt;图&lt;code&gt;G=(V, E)&lt;/code&gt;，其中&lt;code&gt;V&lt;/code&gt;代表&lt;code&gt;顶点&lt;/code&gt;集合，&lt;code&gt;E&lt;/code&gt;代表&lt;code&gt;边&lt;/code&gt;集合。&lt;code&gt;ω(u, v)&lt;/code&gt;代表从顶点u到顶点v的边的权值。&lt;br/&gt;如果&lt;code&gt;ω(u, v)&lt;/code&gt;总为1，则称G为不加权的图。&lt;/p&gt;
&lt;h2 id=&quot;补充定义&quot;&gt;补充定义&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;DAG：有向无回路图&lt;/li&gt;
&lt;li&gt;拓扑排序：将DAG的节点按照一定规则输出：当有u到v的边，则u在v前面。&lt;/li&gt;
&lt;li&gt;强连通分支：对于图G(V, E)，如果一个顶点集合C⊆G，其中每对顶点u和v，u和v相互都是可以到达的，那么称C是G的一个强连通分支&lt;/li&gt;
&lt;li&gt;最小生成树：无向连通图G的子集T，包含了所有顶点，且边的权值之和为最小。&lt;/li&gt;
&lt;li&gt;松弛技术：对于s顶点，d[v]表示s到v的距离。如果d[v] &amp;gt; d[u] + ω(u,v)，则更新d[v] = d[u] + ω(u,v)&lt;/li&gt;
&lt;li&gt;最大流：对于包含源节点和汇节点的有向非负权图，最大的流量&lt;/li&gt;
&lt;li&gt;最大二分匹配：对于图G=(V,E)，存在边的子集M⊆E，满足所有v∈V，M中最多有一条边与v关联。最大匹配是最大势的匹配，即不存在一个边数更多的M'。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;速查表&quot;&gt;速查表&lt;/h2&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;40&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;9&quot;&gt;&lt;td&gt;&lt;strong&gt;广度优先搜索BFS&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;有向图/无向图，不涉及权重&lt;/td&gt;
&lt;td&gt;1.队列 2.顶点按是否访问过着色&lt;/td&gt;
&lt;td&gt;依次访问一个节点的所有相邻顶点，访问时着色并加入队列。每次循环从队列出队。&lt;/td&gt;
&lt;td&gt;O(V+E)&lt;/td&gt;
&lt;td&gt;可计算不加权的图最短路径&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;6&quot;&gt;&lt;td&gt;&lt;strong&gt;深度优先搜索DFS)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;有向图/无向图，不涉及权重&lt;/td&gt;
&lt;td&gt;1.递归 2.顶点按是否访问过着色&lt;/td&gt;
&lt;td&gt;依次访问一个节点的所有相邻顶点，访问时着色并递归访问它的相邻顶点。&lt;/td&gt;
&lt;td&gt;O(V+E)&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;拓扑排序(DFS)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;DAG&lt;/td&gt;
&lt;td&gt;DFS&lt;/td&gt;
&lt;td&gt;执行DFS，当一个顶点DFS完成时插入链表头，这个链表就是拓扑排序结果&lt;/td&gt;
&lt;td&gt;O(V+E)&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td&gt;&lt;strong&gt;计算强连通分支(DFS)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;DAG&lt;/td&gt;
&lt;td&gt;DFS&lt;/td&gt;
&lt;td&gt;执行DFS，对图G倒置后按照节点访问次序的降序再计算一次DFS，第二次DFS的生成树即为强连通分支&lt;/td&gt;
&lt;td&gt;O(V+E)&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;7&quot;&gt;&lt;td&gt;&lt;strong&gt;最小生成树-Kruskal算法&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;无向连通图&lt;/td&gt;
&lt;td&gt;贪心算法&lt;/td&gt;
&lt;td&gt;节点集合A初始化为空集，每次选一条安全边加入A。具体的，初始化每个节点都是一个集合，每次取最小权值的边，满足它的节点(u，v)所在集合不相等，此时令A=A∪{(u,v)}&lt;/td&gt;
&lt;td&gt;O(ElgV)&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;10&quot;&gt;&lt;td&gt;&lt;strong&gt;最小生成树-Prim算法&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;无向连通图&lt;/td&gt;
&lt;td&gt;贪心算法&lt;/td&gt;
&lt;td&gt;节点集合A初始化为空集，每次选一条安全边加入A。具体的，初始化所有节点距离A为正无穷，先在A加入一个节点，距离A为0。每次取一个离集合A中所有顶点中最近的边，加入它和它的顶点u，并将u的所有相邻节点v的距离更新一次(新距离=min(u到v, key(v)))，直到所有顶点都加入了A&lt;/td&gt;
&lt;td&gt;O(ElgV)，可以改进到O(E+VlgV)&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;8&quot;&gt;&lt;td&gt;&lt;strong&gt;单源最短路径-Bellman-Ford算法&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;有向图，权重可为负&lt;/td&gt;
&lt;td&gt;松弛技术&lt;/td&gt;
&lt;td&gt;松弛多次，次数为顶点数-1&lt;/td&gt;
&lt;td&gt;O(VE)&lt;/td&gt;
&lt;td&gt;如果有负权回路，返回值false。可用于差分约束问题求解。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;&lt;strong&gt;单源最短路径-DAG&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;DAG&lt;/td&gt;
&lt;td&gt;拓朴排序、松弛技术&lt;/td&gt;
&lt;td&gt;拓朴排序，按序取顶点，对它的所有临边松弛&lt;/td&gt;
&lt;td&gt;O(V+E)&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;9&quot;&gt;&lt;td&gt;&lt;strong&gt;单源最短路径-Dijkstra算法&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;有向图，边权重非负&lt;/td&gt;
&lt;td&gt;松弛技术&lt;/td&gt;
&lt;td&gt;顶点集合S初始化为空集，加入源节点s。选取距离S整体最近的顶点u，松弛u的所有相邻顶点v，直到所有顶点都并入S&lt;/td&gt;
&lt;td&gt;O((V+E)lgV)&lt;/td&gt;
&lt;td&gt;可以用斐波那契堆优化至O(VlgV+E)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;6&quot;&gt;&lt;td&gt;&lt;strong&gt;每对顶点最短路径-Floyd-Warshall算法&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;有向图&lt;/td&gt;
&lt;td&gt;动态规划&lt;/td&gt;
&lt;td&gt;三重循环，k、i、j -&amp;gt; 1 to n, d(k)(i)(j) = min(d(k-1)(i)(j), d(k-1)(i)(k) + d(k-1)(j)(k))&lt;/td&gt;
&lt;td&gt;O(n^3)&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;6&quot;&gt;&lt;td&gt;&lt;strong&gt;每对顶点最短路径-Johnson算法&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;有向图，稀疏图，边权重非负&lt;/td&gt;
&lt;td&gt;重赋权，Dijkstra + Bellman-Ford&lt;/td&gt;
&lt;td&gt;较为复杂，略&lt;/td&gt;
&lt;td&gt;O(V^2lgV+VE)&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;8&quot;&gt;&lt;td&gt;&lt;strong&gt;最大流-Ford-Fulkerson方法&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;有向图，边权重非负，包含源节点和汇顶点&lt;/td&gt;
&lt;td&gt;依赖三种思想及其对应实现&lt;/td&gt;
&lt;td&gt;较为复杂，略&lt;/td&gt;
&lt;td&gt;基本算法为O(E|f*|)&lt;/td&gt;
&lt;td&gt;本书只介绍了基本算法、Edmods-Karp算法等。可用于解最大二分匹配问题&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;后注&quot;&gt;后注&lt;/h2&gt;
&lt;p&gt;每对顶点间最短路径也可以用Dijkstra和Bellman-Ford解决但不是最优，具体分析略。&lt;/p&gt;
&lt;h2 id=&quot;附图相关的np完全问题&quot;&gt;附：图相关的NP完全问题&lt;/h2&gt;
&lt;p&gt;不详细介绍问题的含义。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;团问题&lt;/li&gt;
&lt;li&gt;顶点覆盖问题，在35章介绍了近似算法&lt;/li&gt;
&lt;li&gt;哈密顿回路问题&lt;/li&gt;
&lt;li&gt;旅行商问题，在35章介绍了近似算法&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;</description>
<pubDate>Sun, 01 Mar 2020 16:57:00 +0000</pubDate>
<dc:creator>五岳</dc:creator>
<og:description>《算法导论》图相关的内容贯穿很多章节，适用条件各异，而且都有证明过程。如果不打算熟记证明，仅仅是应用，遇到具体场景再去回忆适用于哪种算法不太方便。汇总一下便于查阅。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wuyuegb2312/p/12390576.html</dc:identifier>
</item>
</channel>
</rss>