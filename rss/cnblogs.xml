<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>mariaDB vs mysql - 轩脉刃</title>
<link>http://www.cnblogs.com/yjf512/p/10605036.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yjf512/p/10605036.html</guid>
<description>&lt;p&gt;今天遇到一个库使用的是mariaDB的数据库版本&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Server version: 10.1.20-MariaDB MariaDB Server&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;理了一下mariaDB和mysql的关系。&lt;/p&gt;

&lt;p&gt;简要来说，mariaDB是mysql上的分支。首先为什么要有这个分支呢？mysql被oracle收购之后，原本的那些mysql的开发者（MySQL 的联合创始人兼CEO Michael Widenius）觉得mysql后续的发展之路会受到oracle公司的影响。所以单独出来，创建了一家公司Monty Program Ab。这个公司从mysql上拉一个分支出来进行开发和维护，命名为mariaDB。&lt;/p&gt;
&lt;p&gt;mariaDB的github上的项目地址为：&lt;a href=&quot;https://github.com/MariaDB&quot; class=&quot;uri&quot;&gt;https://github.com/MariaDB&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;mariaDB的主页为：&lt;a href=&quot;https://mariadb.org/&quot; class=&quot;uri&quot;&gt;https://mariadb.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;mysql现在最新版本是5.7。mariaDB在5.5之前都兼容了mysql所有的新特性。也就是说，mariaDB是mysql的超集。但是当然mariaDB每次需要同步mysql的新的特性到自己的分支，这个是非常痛苦的事情。但是mariaDB的目标是另外创建一个独立产品和社区。所以mariaDB创建了10的版本号。从这个版本号开始，mariaDB的特性和功能就越来越走向独立了。&lt;/p&gt;

&lt;p&gt;mariaDB的可以看作是mysql的超集。mysql有的特性mariaDB都有，但是mariaDB有的功能不一定mysql有。比如Dynamic columns。&lt;/p&gt;
&lt;h2 id=&quot;dynamic-columns&quot;&gt;Dynamic columns&lt;/h2&gt;
&lt;p&gt;这个功能有点像json，表中有一个字段，可以存储key,value格式的数据，并且这个value的数据类型可以动态定义。这样，就好像mysql的表扩展了多个动态列。&lt;/p&gt;
&lt;p&gt;比如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;CREATE TABLE bird_sightings
(
    sighting_id INT AUTO_INCREMENT KEY,
    human_id INT,
    time_seen DATETIME,
    observations BLOB
);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的observations是BLOB类型，可以存储key-value的格式。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;INSERT INTO bird_sightings
(human_id, time_seen, observations)
VALUES
  (36, NOW(),
   COLUMN_CREATE(
       'wing-shape','rounded',
       'wingspan','60',
       'bill-shape','all-purpose',
       'main-color','orange'
      ));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看这里的observations就存储了四个key-value。&lt;br/&gt;当select的时候&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ECT name_first AS 'Birder',
DATE_FORMAT(time_seen, '%b %d') AS 'Date',
COLUMN_GET(observations, 'wing-shape' AS CHAR) AS 'Wings',
COLUMN_GET(observations, 'wingspan' AS INT) AS 'Span (cm)',
COLUMN_GET(observations, 'bill-shape' AS CHAR) AS 'Beak'
FROM bird_sightings
JOIN humans USING(human_id);

+---------+--------+---------+-----------+-------------+
| Birder  | Date   | Wings   | Span (cm) | Beak        |
+---------+--------+---------+-----------+-------------+
| Anahit  | Apr 14 | pointed |      NULL | all-purpose |
| Michael | Apr 14 | rounded |        60 | all-purpose |
+---------+--------+---------+-----------+-------------+
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的COLUMN_GET有个输出类型的设置。这一个功能就是mariaDB特有的。感觉和postgres里面的jsonb结构很相似。&lt;/p&gt;
&lt;h2 id=&quot;存储引擎&quot;&gt;存储引擎&lt;/h2&gt;
&lt;p&gt;mariaDB提供的XtraDB存储引擎替换InnoDB。XtraDB 是 Percona 开发维护的 InnoDB 威力加强版，整合 Google、Facebook 等公司和 MySQL 社区的补丁。&lt;/p&gt;

&lt;p&gt;在性能上，mariaDB的性能有一定程度优于mysql是不争的事实。比如维基百科就从mysql迁移到mariaDB了。反馈，总的来说，mariaDB会比mysql在qps上有2－10%的提升。当然我相信不同的场景，不同的语言可能会有不同的性能提升程度。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://radar.oreilly.com/2015/04/dynamic-columns-in-mariadb.html&quot; class=&quot;uri&quot;&gt;http://radar.oreilly.com/2015/04/dynamic-columns-in-mariadb.html&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://seravo.fi/2015/10-reasons-to-migrate-to-mariadb-if-still-using-mysql&quot; class=&quot;uri&quot;&gt;https://seravo.fi/2015/10-reasons-to-migrate-to-mariadb-if-still-using-mysql&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://softwareengineering.stackexchange.com/questions/120178/whats-the-difference-between-mariadb-and-mysql&quot; class=&quot;uri&quot;&gt;https://softwareengineering.stackexchange.com/questions/120178/whats-the-difference-between-mariadb-and-mysql&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 26 Mar 2019 23:24:00 +0000</pubDate>
<dc:creator>轩脉刃</dc:creator>
<og:description>mariaDB vs mysql 今天遇到一个库使用的是mariaDB的数据库版本 理了一下mariaDB和mysql的关系。 分支 简要来说，mariaDB是mysql上的分支。首先为什么要有这个分</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yjf512/p/10605036.html</dc:identifier>
</item>
<item>
<title>git 入门教程之里程碑式标签 - 雪之梦技术驿站</title>
<link>http://www.cnblogs.com/snowdreams1006/p/10604955.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/snowdreams1006/p/10604955.html</guid>
<description>&lt;p&gt;&quot;春风得意马蹄疾,一日看尽长安花&quot;,对于项目也是如此,最值得期待的恐怕就要数&lt;strong&gt;新版本&lt;/strong&gt;发布的时刻了吧?每当发布新版本时要么是版本号命名(比如&lt;code&gt;v0.0.1&lt;/code&gt;)或者代号命名(比如&lt;code&gt;Chelsea&lt;/code&gt;),不管怎么说这种里程碑阶段总是要留下些许纪念意义.&lt;/p&gt;
&lt;p&gt;既然想要纪念这种特殊的历史时刻,自然是希望它能够固定下来,不要发生&lt;strong&gt;随意移动&lt;/strong&gt;,产生不可预期后果.&lt;/p&gt;
&lt;p&gt;这种需求其实和我们前面说的&lt;strong&gt;分支&lt;/strong&gt;概念很相似,均是源于特殊的版本号,逐渐收集起一系列版本,最终形成一条&lt;strong&gt;相对独立&lt;/strong&gt;的历史线,但&lt;strong&gt;分支&lt;/strong&gt;并不是实现&lt;strong&gt;里程碑&lt;/strong&gt;概念的最佳选择,为什么?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分支&lt;/strong&gt;适合多人&lt;strong&gt;协作开发&lt;/strong&gt;时互不影响,适当时机主动合并他人工作成果这种模式,而这种模式是由不同的功能模块进行驱动的,正所谓&quot;天下大势分久必合,合久必分&quot;,当功能模块开发完毕后自然也就没有分支存在的必要性,更何况分支在收集版本的过程中会一直移动,并没有特殊的固定版本,显然&lt;strong&gt;分支&lt;/strong&gt;不是最佳选择!&lt;/p&gt;
&lt;p&gt;但是,&lt;strong&gt;分支&lt;/strong&gt;确定一定程度上和&lt;strong&gt;里程碑&lt;/strong&gt;概念很相似,源于特定版本,自主命名,收集版本等,那么何必重头再来,为何不复用已有概念呢?&lt;/p&gt;
&lt;p&gt;实际上,&lt;code&gt;git&lt;/code&gt; 中的标签(&lt;code&gt;tag&lt;/code&gt;) 就是实现&lt;strong&gt;里程碑&lt;/strong&gt;概念的方式,它可以永久性指向特定的提交并将命名,然后就可以将其理解成分支一样引用了!&lt;/p&gt;
&lt;p&gt;但标签(&lt;code&gt;tag&lt;/code&gt;)不是分支(&lt;code&gt;branch&lt;/code&gt;),标签是一个点的话,分支就是若干点连接而成的线,标签是静态的,分支是动态的,标签是只读的,分只是可读可写的.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-597cdd84e7ada066.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;git-tag-create.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;创建标签-git-tag-tag&quot;&gt;创建标签 &lt;code&gt;git tag &amp;lt;tag&amp;gt;&lt;/code&gt;&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;# 方式一: 默认 `HEAD` 指向的版本
git tag v0.0.1

# 方式二: 指定 `commit_id` 表示的版本
git tag v0.0.2 f971647

# 方式三: 指定 `commit_id` 表示的版本,同时创建标签说明信息
git tag -a v0.0.3 -m &quot;v0.0.3&quot; f971647&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-69c717ed78b15c2d.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;git-tag.gif&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;列出标签-git-tag&quot;&gt;列出标签 &lt;code&gt;git tag&lt;/code&gt;&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;git tag &lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;显示标签-git-show-tag&quot;&gt;显示标签 &lt;code&gt;git show &amp;lt;tag&amp;gt;&lt;/code&gt;&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;git show v0.0.1&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;删除标签-git-tag--d-tag&quot;&gt;删除标签 &lt;code&gt;git tag -d &amp;lt;tag&amp;gt;&lt;/code&gt;&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;git tag -d v0.0.1&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;推送标签-git-push-origin-tag&quot;&gt;推送标签 &lt;code&gt;git push origin &amp;lt;tag&amp;gt;&lt;/code&gt;&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;git push origin v0.0.1&lt;/code&gt;
&lt;/pre&gt;

&lt;pre&gt;
&lt;code&gt;git push origin --tags&lt;/code&gt;
&lt;/pre&gt;

&lt;pre&gt;
&lt;code&gt;# 删除本地标签 
git tag -d v0.0.1

# 推送删除标签(删除也是推送)
git push origin :refs/tags/v0.0.1&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Tue, 26 Mar 2019 16:59:00 +0000</pubDate>
<dc:creator>雪之梦技术驿站</dc:creator>
<og:description>'春风得意马蹄疾,一日看尽长安花',对于项目也是如此,最值得期待的恐怕就要数**新版本**发布的时刻了吧?每当发布新版本时要么是版本号命名(比如`v0.0.1`)或者代号命名(比如`Chelsea`)</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/snowdreams1006/p/10604955.html</dc:identifier>
</item>
<item>
<title>介绍几款 Python 类型检查工具 - 豌豆花下猫</title>
<link>http://www.cnblogs.com/pythonista/p/10604929.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pythonista/p/10604929.html</guid>
<description>&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;近日，微软在 Github 上开源了一个 Python 静态类型检查工具：&lt;span&gt;&lt;code&gt;pyright&lt;/code&gt; &lt;span&gt;，引起了社区内的多方关注。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;微软在开源项目上的参与力度是越来越大了，不说收购 Github 这种大的战略野心，只说它家开源的 VS Code 编辑器，在猿界已经割粉无数，连我们 Python 圈的红人 Kenneth Reitz （多个开源项目的作者，包括 requests、requests-html、responder等）都对它赞不绝口。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;如今开源的 Pyright ，口碑还不错，那我们就来看看它有啥本事，顺便再介绍其它几款类型检查工具。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;众所周知，Python 是一门动态类型语言，在运行期才知道变量的实际类型。这本就是动态语言的特色，然而在团队合作或大型项目上，维护的代价也不可避免，俗话说的是：“&lt;span&gt;动态一时爽，重构火葬场 &lt;span&gt;”。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;早在 2006 年的 PEP-3107，Python 就推出了函数注解的功能，最终落在 3.0 版本实现。而到了 3.5 版本，Python 继续引入了静态类型检查的语法（即 PEP-484，type hints）。2014 年的 PEP-483 更是以《The Theory of Type Hints》为题，做出了理论上的归纳。后来，又陆续提出了 PEP-526、PEP-544，类型检查的规范逐渐丰富。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;类型检查的好处是及早检查，提前发现类型的错误，增强代码的一致性与可维护性。（还有防止脱发，喵）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences md-end-block md-fences-with-lineno&quot;&gt;
  
  # 不加检查
  def greeting(name):
      return 'Hello ' + name
  ​
  # 添加检查
  def greeting(name: str) -&amp;gt; str:
      return 'Hello ' + name
&lt;/pre&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;如上例所示，增加检查后，可以在编译期就判断入参和返回值是否是字符串类型。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;在微软推出 pyright 之前，主流的静态检查工具有三款：官方的&lt;span&gt;&lt;code&gt;mypy&lt;/code&gt; &lt;span&gt;、Google 出的&lt;span&gt;&lt;code&gt;pytype&lt;/code&gt; &lt;span&gt;、Facebook 出的&lt;span&gt;&lt;code&gt;pyre-check&lt;/code&gt; &lt;span&gt;。三足鼎立的局面要被打破了。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;http://ww1.sinaimg.cn/large/68b02e3bgy1g1gmiohkzij20fp06imxk.jpg&quot;&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/68b02e3bgy1g1gmiohkzij20fp06imxk.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;pyright 的文档宣称它有如下特点：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot; readability=&quot;7&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;速度快。相较于 mypy 及其它用 Python 写的检查工具，它的速度是 5 倍甚至更多。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;不依赖 Python 环境。它用 TypeScript 写成，运行于 node 上，不依赖 Python 环境或第三方包。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;可配置性强。支持自由地配置，支持指定不同的运行环境（PYTHONPATH 设置、Python 版本、平台目标）。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;检查项齐全。支持类型检查及其它语法项的检查（如 PEP-484、PEP-526、PEP-544），以及函数返回值、类变量、全局变量的检查，甚至可以检查条件循环语句&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;命令行工具。它包含两个 VS Code 插件：一个命令行工具和一个语言服务器协议（Language Server Protocol）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;内置 Stubs 。使用的是 &lt;span&gt;&lt;code&gt;Typeshed&lt;/code&gt; &lt;span&gt;的副本。（注：使用静态的 pyi 文件，检查内置模块、标准库和三方件 ）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;语言服务特性。悬停提示信息、符号定义的跳转、实时的编辑反馈&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;就此而言，不可谓不强大。事实上，pyright 是“站在了巨人的肩膀上”，它的各项功能似乎都继承自其它几位前辈。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;接着看官方的 mypy ，它由“Python 之父” Guido van Rossum 亲自参与开发，是最主流的选择，推出得早，用户基数大，文档与社区经验也最丰富。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;在集成 IDE 方面，所有主流的编辑器都支持：PyCharm、Vim、Emacs、Sublime Text、VS Code、Atom......在业界经验上，Instagram 和 Dropbox 的项目从 py2 迁移到 py3 ，就是用的它来做保障。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;接着看谷歌的 pytype ，据文档描述，它可以：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot; readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;标记常见错误，如拼写错误、函数调用错误&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;加强自定义的类型注解&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;支持对 pyi 文件生成类型注解&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;查看文档，我发现它有个功能还挺人性化的，即“&lt;span&gt;错误降噪 &lt;span&gt;”，对于那些不必修改的错误，可以添加注释，来消除类型检查。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;此外，还有一个考虑也不错，为了写类型检查，模块中可能会额外引入其它的模块，对于后者，pytype 有办法隐藏它，只在做类型检查时才加载。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;最后，要介绍的是脸书的 pyre-check，它是去年开源的，也曾收获一片好评（说不定正是因为它，微软才上马了 pyright 项目也说不定）。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;基本的功能点大同小异，不过它也是有亮点的。pyre-check 可集成&lt;span&gt;&lt;code&gt;Watchman&lt;/code&gt; &lt;span&gt;模块，该“观察者”会监听代码文件，跟踪所做的修改。微软的 pyright 有个 watch 模式，应该是吸收了这点，而且更加好用（因为不需要额外安装 Watchman 和其它依赖）。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;pyre-check 还有个亮点，它有个&lt;span&gt;&lt;code&gt;query&lt;/code&gt; &lt;span&gt;参数，可以对源码做局部区域性的检查，例如查询某行中一个表达式的类型、查询一个类的全部方法并返回成列表，等等，这样可以避免做全面的检查。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;4 种类型检查工具介绍完毕，下面是一份概要对比：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;http://ww1.sinaimg.cn/large/68b02e3bgy1g1gmi46ke4j20x205at98.jpg&quot;&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/68b02e3bgy1g1gmi46ke4j20x205at98.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;至于它们的性能如何，是否真如 pyright 所说，它的速度是其它几个的 5 倍呢？感兴趣的同学们可以去试试。有什么使用体会，欢迎留言与我交流。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;项目地址：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;&lt;a href=&quot;https://github.com/python/mypy&quot;&gt;&lt;span&gt;https://github.com/python/mypy&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;&lt;a href=&quot;https://github.com/Microsoft/pyright&quot;&gt;&lt;span&gt;https://github.com/Microsoft/pyright&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;&lt;a href=&quot;https://github.com/google/pytype&quot;&gt;&lt;span&gt;https://github.com/google/pytype&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;&lt;a href=&quot;https://github.com/facebook/pyre-check&quot;&gt;&lt;span&gt;https://github.com/facebook/pyre-check&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;http://ww1.sinaimg.cn/large/68b02e3bgy1g08dfkg8sdj2076076t96.jpg&quot;&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/68b02e3bgy1g08dfkg8sdj2076076t96.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;公众号【&lt;span&gt;Python猫&lt;span&gt;】， 专注Python技术、数据科学和深度学习，力图创造一个有趣又有用的学习分享平台。本号连载优质的系列文章，有喵星哲学猫系列、Python进阶系列、好书推荐系列、优质英文推荐与翻译等等，欢迎关注哦。PS：后台回复“&lt;span&gt;爱学习&lt;span&gt;”，免费获得一份学习大礼包。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 26 Mar 2019 16:40:00 +0000</pubDate>
<dc:creator>豌豆花下猫</dc:creator>
<og:description>近日，微软在 Github 上开源了一个 Python 静态类型检查工具：pyright ，引起了社区内的多方关注。 微软在开源项目上的参与力度是越来越大了，不说收购 Github 这种大的战略野心，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pythonista/p/10604929.html</dc:identifier>
</item>
<item>
<title>大数据技术之_16_Scala学习_04_函数式编程-基础+面向对象编程-基础 - 黑泽君</title>
<link>http://www.cnblogs.com/chenmingjun/p/10604813.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenmingjun/p/10604813.html</guid>
<description>&lt;p id=&quot;tocid_0&quot; class=&quot;toc&quot;&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h&quot;&gt;第五章 函数式编程-基础&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h51&quot;&gt;5.1 函数式编程内容说明&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h511&quot;&gt;5.1.1 函数式编程内容&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h512&quot;&gt;5.1.2 函数式编程授课顺序&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h52&quot;&gt;5.2 函数式编程介绍&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h521&quot;&gt;5.2.1 几个概念的说明&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h522&quot;&gt;5.2.2 方法、函数、函数式编程和面向对象编程关系分析图&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h523&quot;&gt;5.2.3 函数式编程小结&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h53&quot;&gt;5.3 为什么需要函数&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h54&quot;&gt;5.4 函数的定义&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h541&quot;&gt;5.4.1 函数的定义&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h542&quot;&gt;5.4.2 快速入门案例&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h55&quot;&gt;5.5 函数的调用机制&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h551&quot;&gt;5.5.1 函数的调用过程&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h552&quot;&gt;5.5.2 函数的递归调用&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h553&quot;&gt;5.5.3 递归练习题&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h56&quot;&gt;5.6 函数注意事项和细节讨论&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h57&quot;&gt;5.7 函数练习题&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h58&quot;&gt;5.8 过程&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h581&quot;&gt;5.8.1 基本概念&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h582&quot;&gt;5.8.2 注意事项和细节说明&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h59&quot;&gt;5.9 惰性函数&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h591&quot;&gt;5.9.1 看一个应用场景&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h592&quot;&gt;5.9.2 画图说明（大数据推荐系统）&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h593java&quot;&gt;5.9.3 Java 实现懒加载的代码&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h594&quot;&gt;5.9.4 惰性函数介绍&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h595&quot;&gt;5.9.5 案例演示&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h596&quot;&gt;5.9.6 注意事项和细节&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h510&quot;&gt;5.10 异常&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h5101&quot;&gt;5.10.1 介绍&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h5102java&quot;&gt;5.10.2 Java 异常处理回顾&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h5103java&quot;&gt;5.10.3 Java 异常处理的注意点&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h5104scala&quot;&gt;5.10.4 Scala 异常处理举例&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h5105scala&quot;&gt;5.10.5 Scala 异常处理小结&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h511-1&quot;&gt;5.11 函数的练习题&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h-1&quot;&gt;第六章 面向对象编程-基础&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h61&quot;&gt;6.1 类与对象&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h611scala&quot;&gt;6.1.1 Scala 语言是面向对象的&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h612&quot;&gt;6.1.2 快速入门-面向对象的方式解决养猫问题&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h613&quot;&gt;6.1.3 类和对象的区别和联系&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h614&quot;&gt;6.1.4 如何定义类&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h615&quot;&gt;6.1.5 属性&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h616&quot;&gt;6.1.6 属性/成员变量&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h617&quot;&gt;6.1.7 属性的高级部分&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h618&quot;&gt;6.1.8 如何创建对象&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h619&quot;&gt;6.1.9 类和对象的内存分配机制（重要）&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h62&quot;&gt;6.2 方法&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h621&quot;&gt;6.2.1 基本说明和基本语法&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h622&quot;&gt;6.2.2 方法的调用机制原理&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h623&quot;&gt;6.2.3 方法练习题&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h63&quot;&gt;6.3 类与对象应用实例&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h64&quot;&gt;6.4 构造器&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h641&quot;&gt;6.4.1 看一个需求&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h642java&quot;&gt;6.4.2 回顾-Java 构造器的介绍+基本语法+特点+案例&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h643scala&quot;&gt;6.4.3 Scala 构造器的介绍+基本语法+快速入门&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h644scala&quot;&gt;6.4.4 Scala 构造器注意事项和细节&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h65&quot;&gt;6.5 属性高级&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h651&quot;&gt;6.5.1 构造器参数&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h652bean&quot;&gt;6.5.2 Bean 属性&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h66scala&quot;&gt;6.6 Scala 对象创建的流程分析&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10604813.html#h6703&quot;&gt;6.7 作业03&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;h&quot;&gt;&lt;span&gt;&lt;strong&gt;第五章 函数式编程-基础&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;h3 id=&quot;h51&quot;&gt;&lt;span&gt;&lt;strong&gt;5.1 函数式编程内容说明&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;h4 id=&quot;h511&quot;&gt;&lt;span&gt;&lt;strong&gt;5.1.1 函数式编程内容&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;函数式编程-基础&lt;/strong&gt;&lt;br/&gt;  1、函数定义/声明&lt;br/&gt;  2、函数运行机制&lt;br/&gt;  3、&lt;strong&gt;递归&lt;/strong&gt;【难点：最短路径，邮差问题，背包问题，迷宫问题，回溯】&lt;br/&gt;  4、过程&lt;br/&gt;  5、惰性函数和异常&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;函数式编程-高级&lt;/strong&gt;&lt;br/&gt;  6、值函数(函数字面量)&lt;br/&gt;  7、高阶函数&lt;br/&gt;  8、闭包&lt;br/&gt;  9、应用函数&lt;br/&gt;  10、柯里化函数，抽象控制…&lt;/p&gt;
&lt;h4 id=&quot;h512&quot;&gt;&lt;span&gt;&lt;strong&gt;5.1.2 函数式编程授课顺序&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;  1、在 scala 中，函数式编程和面向对象编程融合在一起，学习函数式编程式需要 oop 的知识，同样学习 oop 需要函数式编程的基础。[矛盾]&lt;br/&gt;  2、二者关系如下图:&lt;br/&gt;  &lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/26/Aa9nTU.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;  3、授课顺序：函数式编程基础 -&amp;gt; 面向对象编程 -&amp;gt; 函数式编程高级

&lt;h3 id=&quot;h52&quot;&gt;&lt;span&gt;&lt;strong&gt;5.2 函数式编程介绍&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;h4 id=&quot;h521&quot;&gt;&lt;span&gt;&lt;strong&gt;5.2.1 几个概念的说明&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;  在学习 Scala 中将方法、函数、函数式编程和面向对象编程明确一下：&lt;br/&gt;  1、在 scala 中，&lt;code&gt;方法&lt;/code&gt;和&lt;code&gt;函数&lt;/code&gt;几乎可以等同(比如他们的定义、使用、运行机制都一样的)，只是函数的使用方式更加的灵活多样。&lt;br/&gt;  2、&lt;code&gt;函数式编程&lt;/code&gt;是从编程方式(范式)的角度来谈的，可以这样理解：函数式编程把函数当做一等公民&lt;code&gt;，充分利用函数、支持的函数的多种使用方式&lt;/code&gt;。&lt;br/&gt;  比如：在 Scala 当中，函数是一等公民，像变量一样，既可以作为函数的参数使用，也可以将函数赋值给一个变量，函数的创建不用依赖于类或者对象，而在 Java 当中，函数的创建则要依赖于类、抽象类或者接口。&lt;br/&gt;  3、&lt;code&gt;面向对象编程&lt;/code&gt;是以对象为基础的编程方式。&lt;br/&gt;  4、在 scala 中函数式编程和面向对象编程融合在一起了。&lt;br/&gt;示例代码如下：&lt;/p&gt;
&lt;pre readability=&quot;12&quot;&gt;
&lt;code class=&quot;scala language-scala&quot; readability=&quot;18&quot;&gt;package com.atguigu.chapter05&lt;p&gt;object Method2Function {&lt;br/&gt;def main(args: Array[String]): Unit = {&lt;br/&gt;// 传统的方式使用方法&lt;br/&gt;// 先创建一个对象&lt;br/&gt;val dog = new Dog&lt;br/&gt;println(dog.sum(10, 20))&lt;/p&gt;&lt;p&gt;// 方法转成函数后使用函数&lt;br/&gt;val f1 = dog.sum _&lt;br/&gt;println(&quot;f1=&quot; + f1) // f1=&amp;lt;function2&amp;gt;&lt;br/&gt;println(&quot;f1=&quot; + f1(50, 60))&lt;/p&gt;&lt;p&gt;// 直接写一个函数并使用函数&lt;br/&gt;// 格式：val f2 = (Int, Int) =&amp;gt; {}&lt;br/&gt;val f2 = (n1: Int, n2: Int) =&amp;gt; {&lt;br/&gt;n1 + n2 // 函数体&lt;br/&gt;}&lt;br/&gt;println(&quot;f2=&quot; + f2) // f2=&amp;lt;function2&amp;gt;&lt;br/&gt;println(&quot;f2=&quot; + f2(80, 90))&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;class Dog {&lt;br/&gt;// 方法&lt;br/&gt;def sum(n1: Int, n2: Int): Int = {&lt;br/&gt;n1 + n2 // 方法体&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs makefile&quot;&gt;30&lt;br/&gt;f1=&amp;lt;function2&amp;gt;&lt;br/&gt;f1=110&lt;br/&gt;f2=&amp;lt;function2&amp;gt;&lt;br/&gt;f2=170&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;h522&quot;&gt;&lt;span&gt;&lt;strong&gt;5.2.2 方法、函数、函数式编程和面向对象编程关系分析图&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;在学习 Scala 中将方法、函数、函数式编程和面向对象编程关系分析图如下：&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/26/Aa9emV.png&quot; alt=&quot;&quot;/&gt;&lt;h4 id=&quot;h523&quot;&gt;&lt;span&gt;&lt;strong&gt;5.2.3 函数式编程小结&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;  1、“函数式编程”是一种“编程范式”（programming paradigm）。&lt;br/&gt;  2、它属于“结构化编程”的一种，主要思想是把运算过程尽量写成一系列嵌套的函数调用。&lt;br/&gt;  3、函数式编程中，&lt;code&gt;将函数也当做数据类型&lt;/code&gt;，因此可以接受函数当作输入（参数）和输出（返回值）。&lt;br/&gt;  4、函数式编程中，最重要的就是函数。&lt;/p&gt;
&lt;h3 id=&quot;h53&quot;&gt;&lt;span&gt;&lt;strong&gt;5.3 为什么需要函数&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/26/Aa9MY4.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;学习一个技术或者知识点的流程：&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/26/Aa9KkF.png&quot; alt=&quot;&quot;/&gt;&lt;h3 id=&quot;h54&quot;&gt;&lt;span&gt;&lt;strong&gt;5.4 函数的定义&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;h4 id=&quot;h541&quot;&gt;&lt;span&gt;&lt;strong&gt;5.4.1 函数的定义&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/26/Aa9mwT.png&quot; alt=&quot;&quot;/&gt;&lt;h4 id=&quot;h542&quot;&gt;&lt;span&gt;&lt;strong&gt;5.4.2 快速入门案例&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;使用函数完全前面的案例。&lt;br/&gt;示例代码如下：&lt;/p&gt;
&lt;pre readability=&quot;8.5&quot;&gt;
&lt;code class=&quot;scala language-scala&quot; readability=&quot;11&quot;&gt;package com.atguigu.chapter05&lt;p&gt;object FunDemo01 {&lt;br/&gt;def main(args: Array[String]): Unit = {&lt;br/&gt;println(&quot;&quot; + getRes(10, 20, '+'))&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;// 定义一个函数/方法&lt;br/&gt;def getRes(n1: Int, n2: Int, oper: Char) = { // 返回值形式2: = 表示返回值类型不确定，使用类型推导完成。&lt;br/&gt;if (oper == '+') {&lt;br/&gt;// return n1 + n2 // return 关键字可以写可以不写&lt;br/&gt;n1 + n2&lt;br/&gt;} else if (oper == '-') {&lt;br/&gt;n1 - n2&lt;br/&gt;} else {&lt;br/&gt;// 返回 null&lt;br/&gt;null&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;h55&quot;&gt;&lt;span&gt;&lt;strong&gt;5.5 函数的调用机制&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/26/Aa91p9.png&quot; alt=&quot;&quot;/&gt;&lt;h4 id=&quot;h551&quot;&gt;&lt;span&gt;&lt;strong&gt;5.5.1 函数的调用过程&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;  为了让大家更好的理解函数调用机制，看1个案例，并画出示意图，这个很重要，比如 getSum 计算两个数的和，并返回结果。&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/26/Aa9QfJ.png&quot; alt=&quot;&quot;/&gt;&lt;h4 id=&quot;h552&quot;&gt;&lt;span&gt;&lt;strong&gt;5.5.2 函数的递归调用&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/26/Aa93lR.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;&lt;code&gt;注意&lt;/code&gt;：Struts2 中的拦截器的底层实现机制就是把一个对象放到堆中，然后不停的开栈去指向该对象的内存地址，每一个栈都有机会去修改该对象的值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;函数递归需要遵守的重要原则（总结）&lt;/strong&gt;&lt;br/&gt;  1、程序执行一个函数时，就创建一个新的受保护的独立空间(新函数栈)。&lt;br/&gt;  2、函数的局部变量是独立的，不会相互影响。&lt;br/&gt;  3、递归必须向退出递归的条件逼近，否则就是无限递归，死龟了:)&lt;br/&gt;  4、当一个函数执行完毕，或者遇到 return，就会返回，遵守谁调用，就将结果返回给谁。&lt;/p&gt;
&lt;h4 id=&quot;h553&quot;&gt;&lt;span&gt;&lt;strong&gt;5.5.3 递归练习题&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;题1：斐波那契数，请使用递归的方式，求出斐波那契数1,1,2,3,5,8,13…给你一个整数n，求出它的斐波那契数是多少？&lt;br/&gt;示例代码如下：&lt;/p&gt;
&lt;pre readability=&quot;14.5&quot;&gt;
&lt;code class=&quot;scala language-scala&quot; readability=&quot;23&quot;&gt;package com.atguigu.chapter05.recursive&lt;p&gt;import scala.io.StdIn&lt;/p&gt;&lt;p&gt;/**&lt;br/&gt;* 题1：斐波那契数，请使用递归的方式，求出斐波那契数1,1,2,3,5,8,13... 给你一个整数n，求出它的斐波那契数是多少？&lt;br/&gt;* 思路：f(1)=1, f(2)=1, f(3)=f(2)+f(1)=1+1=2, f(4)=f(2)+f(3)=1+2=3, ..., f(n)=f(n-1)+f(n-2)&lt;br/&gt;*/&lt;br/&gt;object Exercise01 {&lt;br/&gt;def main(args: Array[String]): Unit = {&lt;/p&gt;&lt;p&gt;println(&quot;请输入一个正整数：&quot;)&lt;br/&gt;val n = StdIn.readInt()&lt;br/&gt;printf(&quot;%d的斐波那契数是：%d&quot;, n, fbn(n))&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;def fbn(n: Int): Int = {&lt;br/&gt;if (n == 1 || n == 2) {&lt;br/&gt;1&lt;br/&gt;} else {&lt;br/&gt;fbn(n - 1) + fbn(n - 2)&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;题2：求函数值，已知 f(1)=3; f(n) = 2*f(n-1)+1; 请使用递归的思想编程，求出 f(n) 的值？&lt;br/&gt;示例代码如下：&lt;/p&gt;
&lt;pre readability=&quot;9&quot;&gt;
&lt;code class=&quot;scala language-scala&quot; readability=&quot;12&quot;&gt;package com.atguigu.chapter05.recursive&lt;p&gt;import scala.io.StdIn&lt;/p&gt;&lt;p&gt;/**&lt;br/&gt;* 题2：求函数值，已知 f(1)=3; f(n) = 2*f(n-1)+1; 请使用递归的思想编程，求出 f(n) 的值？&lt;br/&gt;* n=1, f(1)=3&lt;br/&gt;* n=2, f(2)=2*f(1)+1=7&lt;br/&gt;* n=3, f(3)=2*f(2)+1=15&lt;br/&gt;*&lt;br/&gt;*/&lt;br/&gt;object Exercise02 {&lt;br/&gt;def main(args: Array[String]): Unit = {&lt;br/&gt;println(&quot;请输入一个正整数：&quot;)&lt;br/&gt;val n = StdIn.readInt()&lt;br/&gt;printf(&quot;f(%d) 的值是：%d&quot;, n, f(n))&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;def f(n: Int): Int = {&lt;br/&gt;if (n == 1) {&lt;br/&gt;3&lt;br/&gt;} else {&lt;br/&gt;2 * f(n - 1) + 1&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;题3：猴子吃桃子问题：有一堆桃子，猴子第一天吃了其中的一半，并再多吃了一个！以后每天猴子都吃其中的一半，然后再多吃一个。当到第十天时，想再吃时（还没吃），发现只有1个桃子了。问题：最初共多少个桃子？&lt;br/&gt;示例代码如下：&lt;/p&gt;
&lt;pre readability=&quot;7.5&quot;&gt;
&lt;code class=&quot;scala language-scala&quot; readability=&quot;9&quot;&gt;package com.atguigu.chapter05.recursive&lt;p&gt;import com.atguigu.chapter05.recursive.Exercise02.f&lt;/p&gt;&lt;p&gt;import scala.io.StdIn&lt;/p&gt;&lt;p&gt;/**&lt;br/&gt;* 题3：猴子吃桃子问题：有一堆桃子，猴子第一天吃了其中的一半，并再多吃了一个！&lt;br/&gt;* 以后每天猴子都吃其中的一半，然后再多吃一个。当到第十天时，想再吃时（还没吃），发现只有1个桃子了。问题：最初共多少个桃子？&lt;br/&gt;*&lt;br/&gt;* day = 10 桃子有 1&lt;br/&gt;* day =  9 桃子有 (day10的桃子 + 1) *2&lt;br/&gt;* day =  8 桃子有 (day9 的桃子 + 1) *2&lt;br/&gt;*&lt;br/&gt;*/&lt;br/&gt;object Exercise03 {&lt;br/&gt;def main(args: Array[String]): Unit = {&lt;br/&gt;println(&quot;最初共有:&quot; + f(1) + &quot;个桃子&quot;)&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;def f(n: Int): Int = {&lt;br/&gt;if (n == 10) {&lt;br/&gt;1&lt;br/&gt;} else {&lt;br/&gt;(f(n + 1) + 1) * 2&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;h56&quot;&gt;&lt;span&gt;&lt;strong&gt;5.6 函数注意事项和细节讨论&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;  1、函数的形参列表可以是多个，如果函数没有形参，调用时可以不带()。&lt;/p&gt;
&lt;p&gt;  2、函数的形参列表和返回值列表的数据类型可以是值类型和引用类型。【案例演示】&lt;br/&gt;示例代码如下：&lt;/p&gt;
&lt;pre readability=&quot;9.5&quot;&gt;
&lt;code class=&quot;scala language-scala&quot; readability=&quot;13&quot;&gt;package com.atguigu.chapter05.fundetails&lt;p&gt;object Details01 {&lt;br/&gt;def main(args: Array[String]): Unit = {&lt;br/&gt;val tiger = new Tiger&lt;br/&gt;val tiger2 = test01(10, tiger)&lt;br/&gt;println(tiger2.name) // tom&lt;br/&gt;println(tiger.name)  // tom&lt;br/&gt;println(tiger.hashCode() + &quot; &quot; + tiger2.hashCode()) // 2101440631 2101440631&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;// 2、函数的形参列表和返回值列表的数据类型可以是值类型和引用类型。&lt;br/&gt;def test01(n: Int, tiger: Tiger): Tiger = {&lt;br/&gt;println(&quot;n=&quot; + n)&lt;br/&gt;tiger.name = &quot;tom&quot;&lt;br/&gt;tiger&lt;br/&gt;// return tiger // 3、Scala 中的函数可以根据函数体最后一行代码自行推断函数返回值类型。那么在这种情况下，return 关键字可以省略。&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;class Tiger {&lt;br/&gt;var name = &quot;&quot;&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  3、Scala 中的函数可以根据函数体最后一行代码自行推断函数返回值类型。那么在这种情况下，return 关键字可以省略。【案例同上】&lt;br/&gt;  4、因为 Scala 可以自行推断，所以在省略 return 关键字的场合，返回值类型也可以省略。&lt;br/&gt;  &lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/26/Aa9861.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;  5、如果函数明确使用 return 关键字，那么函数返回就不能使用自行推断了，这时要明确写成 &lt;code&gt;: 返回值类型 =&lt;/code&gt; ，当然如果你什么都不写，即使有 return，那么返回值为()，即这时 return 无效。&lt;br/&gt;  6、如果函数明确声明无返回值（声明 Unit），那么函数体中即使使用 return 关键字也不会有返回值。&lt;br/&gt;示例代码如下：
&lt;pre readability=&quot;13&quot;&gt;
&lt;code class=&quot;scala language-scala&quot; readability=&quot;20&quot;&gt;package com.atguigu.chapter05.fundetails&lt;p&gt;object Details02 {&lt;br/&gt;def main(args: Array[String]): Unit = {&lt;/p&gt;&lt;p&gt;println(getSum2(10, 30))  // ()&lt;/p&gt;&lt;p&gt;println(getSum3(9, 9))    // ()&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;p&gt;// 如果写了 return，那么返回值类型就不能省略。&lt;br/&gt;def getSum(n1: Int, n2: Int): Int = {&lt;br/&gt;return n1 + n2&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;// 如果返回值这里什么什么都没有写，即表示该函数没有返回值。&lt;br/&gt;// 这时 return 无效&lt;br/&gt;def getSum2(n1: Int, n2: Int) {&lt;br/&gt;return n1 + n2&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;// 如果函数明确声明无返回值（声明Unit），那么函数体中即使使用 return 关键字也不会有返回值。&lt;br/&gt;def getSum3(n1: Int, n2: Int): Unit = {&lt;br/&gt;return n1 + n2&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  7、如果明确函数无返回值或不确定返回值类型，那么返回值类型可以省略（或声明为 Any）。&lt;br/&gt;示例代码如下：&lt;/p&gt;
&lt;pre readability=&quot;6.5&quot;&gt;
&lt;code class=&quot;scala language-scala&quot; readability=&quot;7&quot;&gt;package com.atguigu.chapter05.fundetails&lt;p&gt;object Details03 {&lt;br/&gt;def main(args: Array[String]): Unit = {&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;p&gt;// 7、如果明确函数无返回值或不确定返回值类型，那么返回值类型可以省略（或声明为 Any）。&lt;br/&gt;def f3(s: String) = {&lt;br/&gt;if (s.length &amp;gt;= 3)&lt;br/&gt;s + &quot;123&quot;&lt;br/&gt;else&lt;br/&gt;3&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;def f4(s: String): Any = {&lt;br/&gt;if (s.length &amp;gt;= 3)&lt;br/&gt;s + &quot;123&quot;&lt;br/&gt;else&lt;br/&gt;3&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  8、Scala 语法中任何的语法结构都可以嵌套其他语法结构(很灵活)，即：&lt;code&gt;函数中可以再声明/定义函数&lt;/code&gt;，&lt;code&gt;类中可以再声明类&lt;/code&gt;，&lt;code&gt;方法中可以再声明/定义方法&lt;/code&gt;。&lt;br/&gt;示例代码如下：&lt;/p&gt;
&lt;pre readability=&quot;7.5&quot;&gt;
&lt;code class=&quot;scala language-scala&quot; readability=&quot;9&quot;&gt;package com.atguigu.chapter05.fundetails&lt;p&gt;object Details04 {&lt;br/&gt;def main(args: Array[String]): Unit = { // public void main(String[] args)&lt;/p&gt;&lt;p&gt;def f1():Unit = { // private final void f1$1&lt;br/&gt;println(&quot;f1&quot;)&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;def sayok(): Unit = { // private final void sayok$1&lt;br/&gt;println(&quot;sayok~&quot;)&lt;br/&gt;def sayok(): Unit = { // private final void sayok$2&lt;br/&gt;println(&quot;sayok~~&quot;)&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;println(&quot;ok&quot;)&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;def sayok(): Unit = { // public void sayok()&lt;br/&gt;println(&quot;sayok&quot;)&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  9、Scala 函数的形参，在声明参数时，直接赋初始值(默认值)，这时调用函数时，如果没有指定实参，则会使用默认值。如果指定了实参，则&lt;code&gt;实参会覆盖默认值&lt;/code&gt;。&lt;br/&gt;示例代码如下：&lt;/p&gt;
&lt;pre readability=&quot;5.5&quot;&gt;
&lt;code class=&quot;scala language-scala&quot; readability=&quot;5&quot;&gt;package com.atguigu.chapter05.fundetails&lt;p&gt;object Details05 {&lt;br/&gt;def main(args: Array[String]): Unit = {&lt;br/&gt;println(sayOk())      // jack ok!&lt;br/&gt;println(sayOk(&quot;tom&quot;)) // tom ok!&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;def sayOk(name: String = &quot;jack&quot;): String = {&lt;br/&gt;return name + &quot; ok! &quot;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  10、如果函数存在多个参数，每一个参数都可以设定默认值，那么这个时候，传递的参数到底是覆盖默认值，还是赋值给没有默认值的参数，就不确定了(默认按照声明顺序[&lt;strong&gt;从左到右&lt;/strong&gt;])。在这种情况下，可以采用&lt;strong&gt;带名参数&lt;/strong&gt;。&lt;br/&gt;示例代码如下：&lt;/p&gt;
&lt;pre readability=&quot;13&quot;&gt;
&lt;code class=&quot;scala language-scala&quot; readability=&quot;20&quot;&gt;package com.atguigu.chapter05.fundetails&lt;p&gt;object Details06 {&lt;br/&gt;def main(args: Array[String]): Unit = {&lt;br/&gt;mysqlCon()&lt;br/&gt;mysqlCon(&quot;127.0.0.1&quot;, 7777) // 从左到右覆盖&lt;/p&gt;&lt;p&gt;// 如果我们希望指定覆盖某一个默认值，则使用带名参数即可，比如只想修改用户名和密码，其他的不改&lt;br/&gt;mysqlCon(user = &quot;tom&quot;, pwd = &quot;1234&quot;)&lt;/p&gt;&lt;p&gt;// 练习&lt;br/&gt;// f6(&quot;v2&quot;) // 报错，p2的值没有指定&lt;br/&gt;f6(p2 = &quot;v2&quot;) // v1v2&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;def mysqlCon(add: String = &quot;localhost&quot;, port: Int = 3306,&lt;br/&gt;user: String = &quot;root&quot;, pwd: String = &quot;root&quot;): Unit = {&lt;br/&gt;println(&quot;add=&quot; + add)&lt;br/&gt;println(&quot;port=&quot; + port)&lt;br/&gt;println(&quot;user=&quot; + user)&lt;br/&gt;println(&quot;pwd=&quot; + pwd)&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;def f6(p1: String = &quot;v1&quot;, p2: String) {&lt;br/&gt;println(p1 + p2);&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  11、&lt;code&gt;scala 函数的形参默认是 val 的&lt;/code&gt;，因此不能在函数中进行修改。&lt;/p&gt;
&lt;p&gt;  12、递归函数未执行之前是无法推断出来结果类型，在使用时必须有明确的返回值类型。&lt;br/&gt;示例代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;scala language-scala&quot;&gt;  def f(n: Int) = { // 错误，递归不能使用类型推断，必须指定返回的数据类型。&lt;br/&gt;if (n &amp;lt;= 0)&lt;br/&gt;1&lt;br/&gt;else&lt;br/&gt;n * f(n - 1)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  13、Scala 函数支持&lt;code&gt;可变参数&lt;/code&gt;。&lt;br/&gt;示例代码如下：&lt;/p&gt;
&lt;pre readability=&quot;4.5&quot;&gt;
&lt;code class=&quot;scala language-scala&quot; readability=&quot;3&quot;&gt;  // 支持0到多个参数&lt;br/&gt;def sum(args: Int*): Int = {&lt;br/&gt;}&lt;p&gt;// 支持1到多个参数&lt;br/&gt;def sum(n1: Int, args: Int*): Int = {&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  说明:&lt;br/&gt;  1、&lt;code&gt;args 是集合, 通过 for 循环 可以访问到各个值&lt;/code&gt;。【args 是参数名，可以任意起】&lt;br/&gt;  2、案例演示： 编写一个函数 sum，可以求出 1 到多个 int 的和。&lt;br/&gt;  3、可变参数需要写在形参列表的最后。&lt;br/&gt;示例代码如下：&lt;/p&gt;
&lt;pre readability=&quot;7.5&quot;&gt;
&lt;code class=&quot;scala language-scala&quot; readability=&quot;9&quot;&gt;package com.atguigu.chapter05.fundetails&lt;p&gt;object VarParameters {&lt;br/&gt;def main(args: Array[String]): Unit = {&lt;br/&gt;println(sum(10, 20, 30)) // 这里可变参数为2个&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;// 支持1到多个参数&lt;br/&gt;def sum(n1: Int, args: Int*): Int = {&lt;br/&gt;println(&quot;args.length=&quot; + args.length)&lt;br/&gt;var sum = n1&lt;br/&gt;for (item &amp;lt;- args) {&lt;br/&gt;sum += item&lt;br/&gt;}&lt;br/&gt;sum&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;h57&quot;&gt;&lt;span&gt;&lt;strong&gt;5.7 函数练习题&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;判断下面的代码是否正确：&lt;br/&gt;示例代码如下：&lt;/p&gt;
&lt;pre readability=&quot;5&quot;&gt;
&lt;code class=&quot;scala language-scala&quot; readability=&quot;4&quot;&gt;  object Hello01 {&lt;br/&gt;def main(args: Array[String]): Unit = {&lt;br/&gt;def f1 = &quot;venassa&quot;&lt;br/&gt;println(f1) // 输出 venassa&lt;br/&gt;}&lt;br/&gt;}&lt;p&gt;// 上面代码 def f1 = &quot;venassa&quot; 等价于&lt;br/&gt;def f1() = {&lt;br/&gt;&quot;venassa&quot;&lt;br/&gt;}&lt;br/&gt;// 说明：&lt;br/&gt;// 1、函数的形参列表可以是多个，如果函数没有形参，函数可以不带()。&lt;br/&gt;// 2、函数的函数体只有一行代码时，可以省略{}。&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;h58&quot;&gt;&lt;span&gt;&lt;strong&gt;5.8 过程&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;h4 id=&quot;h581&quot;&gt;&lt;span&gt;&lt;strong&gt;5.8.1 基本概念&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;基本介绍：&lt;/strong&gt;&lt;br/&gt;  将函数的返回类型为 Unit 的函数称之为过程(procedure)，如果明确函数没有返回值，那么等号可以省略。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;案例说明：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;scala language-scala&quot;&gt;  // f10 没有返回值，可以使用 Unit 来说明&lt;br/&gt;// 这时，这个函数我们也叫过程（procedure）&lt;br/&gt;def f10(name: String): Unit = { // 如果明确函数没有返回值，那么等号可以省略。&lt;br/&gt;println(name+ &quot;hello&quot;)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;h582&quot;&gt;&lt;span&gt;&lt;strong&gt;5.8.2 注意事项和细节说明&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;  1、注意区分: 如果函数声明时没有返回值类型，但是有 = 号，可以进行&lt;strong&gt;类型推断&lt;/strong&gt;最后一行代码。这时这个函数实际是有返回值的，该函数并不是过程。(这点在讲解函数细节的时候讲过的)&lt;br/&gt;  2、开发工具的自动代码补全功能，虽然会自动加上 Unit，但是考虑到 Scala 语言的简单，灵活，最好不加。&lt;/p&gt;
&lt;h3 id=&quot;h59&quot;&gt;&lt;span&gt;&lt;strong&gt;5.9 惰性函数&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;h4 id=&quot;h591&quot;&gt;&lt;span&gt;&lt;strong&gt;5.9.1 看一个应用场景&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;  惰性计算（&lt;code&gt;尽可能延迟表达式求值&lt;/code&gt;）是许多函数式编程语言的特性。惰性集合在需要时提供其元素，无需预先计算它们，这带来了一些好处。首先，您可以将耗时的计算推迟到绝对需要的时候。其次，您可以创造无限个集合，只要它们继续收到请求，就会继续提供元素。函数的惰性使用让您能够得到更高效的代码。Java 并没有为惰性提供原生支持，Scala 提供了。&lt;/p&gt;
&lt;h4 id=&quot;h592&quot;&gt;&lt;span&gt;&lt;strong&gt;5.9.2 画图说明（大数据推荐系统）&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/26/Aa9akD.png&quot; alt=&quot;&quot;/&gt;&lt;h4 id=&quot;h593java&quot;&gt;&lt;span&gt;&lt;strong&gt;5.9.3 Java 实现懒加载的代码&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;示例代码如下：&lt;/p&gt;
&lt;pre readability=&quot;5&quot;&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;4&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;package&lt;/span&gt; com.atguigu.chapter05;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;LazyDemo&lt;/span&gt; &lt;/span&gt;{&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; String property; &lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;hljs-title&quot;&gt;getProperty&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (property == &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;) { &lt;br/&gt;property = initProperty();&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; property;&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; String &lt;span class=&quot;hljs-title&quot;&gt;initProperty&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;property&quot;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;h594&quot;&gt;&lt;span&gt;&lt;strong&gt;5.9.4 惰性函数介绍&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;  &lt;code&gt;当函数返回值被声明为 lazy 时&lt;/code&gt;，函数的执行将被推迟，直到我们首次对此取值，该函数才会执行，这种函数我们称之为&lt;code&gt;惰性函数&lt;/code&gt;。在 Java 的某些框架代码中称之为&lt;code&gt;懒加载(延迟加载)&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id=&quot;h595&quot;&gt;&lt;span&gt;&lt;strong&gt;5.9.5 案例演示&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;示例代码如下：&lt;/p&gt;
&lt;pre readability=&quot;6.5&quot;&gt;
&lt;code class=&quot;scala language-scala&quot; readability=&quot;7&quot;&gt;package com.atguigu.chapter05.mylazy&lt;p&gt;object LazyDemo01 {&lt;br/&gt;def main(args: Array[String]): Unit = {&lt;br/&gt;lazy val res = sum(10, 20)&lt;br/&gt;println(&quot;----------&quot;)&lt;br/&gt;println(&quot;res=&quot; + res) // 在要使用 res 前，才执行&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;def sum(n1: Int, n2: Int): Int = {&lt;br/&gt;println(&quot;sum() 执行了..&quot;)&lt;br/&gt;return n1 + n2&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs makefile&quot;&gt;----------&lt;br/&gt;sum() 执行了..&lt;br/&gt;res=30&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;h596&quot;&gt;&lt;span&gt;&lt;strong&gt;5.9.6 注意事项和细节&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;  1、lazy 不能修饰 var 类型的变量。&lt;br/&gt;  2、不但是在调用函数时，加了 lazy，会导致函数的执行被推迟，&lt;code&gt;我们在声明一个变量时，如果声明了 lazy，那么变量值的分配也会推迟&lt;/code&gt;。 比如 lazy val i = 10。&lt;/p&gt;
&lt;h3 id=&quot;h510&quot;&gt;&lt;span&gt;&lt;strong&gt;5.10 异常&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;h4 id=&quot;h5101&quot;&gt;&lt;span&gt;&lt;strong&gt;5.10.1 介绍&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;  &lt;code&gt;Scala 提供 try 块和 catch 块来处理异常&lt;/code&gt;。try 块用于包含可能出错的代码。catch 块用于处理 try 块中发生的异常。可以根据需要在程序中有任意数量的 try…catch 块。&lt;br/&gt;  语法处理上和 Java 类似，但是又不尽相同。&lt;/p&gt;
&lt;h4 id=&quot;h5102java&quot;&gt;&lt;span&gt;&lt;strong&gt;5.10.2 Java 异常处理回顾&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;示例代码如下：&lt;/p&gt;
&lt;pre readability=&quot;6&quot;&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;6&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;package&lt;/span&gt; com.atguigu.chapter05.exception;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;JavaExceptionDemo&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;try&lt;/span&gt; {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; b = &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; c = b / i; &lt;br/&gt;} &lt;span class=&quot;hljs-keyword&quot;&gt;catch&lt;/span&gt; (Exception e) {&lt;br/&gt;e.printStackTrace();&lt;br/&gt;} &lt;span class=&quot;hljs-keyword&quot;&gt;finally&lt;/span&gt; {&lt;br/&gt;System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;java finally&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;继续执行&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;java &lt;span class=&quot;hljs-keyword&quot;&gt;finally&lt;/span&gt;&lt;br/&gt;继续执行&lt;br/&gt;java.lang.ArithmeticException: / by zero&lt;br/&gt;at com.atguigu.chapter05.exception.JavaExceptionDemo.main(JavaExceptionDemo.java:&lt;span class=&quot;hljs-number&quot;&gt;9&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;h5103java&quot;&gt;&lt;span&gt;&lt;strong&gt;5.10.3 Java 异常处理的注意点&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;  1、java 语言按照 try-catch-catch…-finally 的方式来处理异常。&lt;br/&gt;  2、不管有没有异常捕获，都会执行 finally，因此通常可以在 finally 代码块中释放资源。&lt;br/&gt;  3、可以有多个 catch，分别捕获对应的异常，这时需要把范围小的异常类写在前面，把范围大的异常类写在后面，否则编译错误。会提示 &quot;Exception 'java.lang.xxxxxx' has already been caught&quot;。&lt;/p&gt;
&lt;h4 id=&quot;h5104scala&quot;&gt;&lt;span&gt;&lt;strong&gt;5.10.4 Scala 异常处理举例&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;示例代码如下：&lt;/p&gt;
&lt;pre readability=&quot;7&quot;&gt;
&lt;code class=&quot;scala language-scala&quot; readability=&quot;8&quot;&gt;package com.atguigu.chapter05.exception&lt;p&gt;object ScalaExceptionDemo {&lt;br/&gt;def main(args: Array[String]): Unit = {&lt;br/&gt;try {&lt;br/&gt;val r = 10 / 0&lt;br/&gt;} catch {&lt;br/&gt;// 说明&lt;br/&gt;// 1. 在 scala 中只有一个 catch&lt;br/&gt;// 2. 在 catch 中有多个 case, 每个 case 可以匹配一种异常&lt;br/&gt;// 3. =&amp;gt; 关键符号，表示后面是对该异常的处理代码块&lt;br/&gt;// 4. finally 最终要执行的代码&lt;br/&gt;case ex: ArithmeticException =&amp;gt; { println(&quot;捕获了除数为零的算数异常&quot;) } // 当对该异常的处理代码块为一行时，{}可以省略&lt;br/&gt;case ex: Exception =&amp;gt; println(&quot;捕获了异常&quot;)&lt;br/&gt;} finally {&lt;br/&gt;// 最终要执行的代码&lt;br/&gt;println(&quot;scala finally&quot;)&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;System.out.println(&quot;继续执行&quot;)&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;捕获了除数为零的算数异常&lt;br/&gt;scala &lt;span class=&quot;hljs-keyword&quot;&gt;finally&lt;/span&gt;&lt;br/&gt;继续执行&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;h5105scala&quot;&gt;&lt;span&gt;&lt;strong&gt;5.10.5 Scala 异常处理小结&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;  1、我们&lt;code&gt;将可疑代码封装在 try 块中&lt;/code&gt;。在 try 块之后使用了一个 catch 处理程序来捕获异常。如果发生任何异常，catch 处理程序将处理它，&lt;code&gt;异常处理了程序将不会异常终止&lt;/code&gt;。&lt;br/&gt;  2、Scala 的异常的工作机制和 Java 一样，但是 &lt;code&gt;Scala 没有“checked(编译期)” 异常&lt;/code&gt;，即 Scala 没有编译异常这个概念，异常都是在运行的时候捕获处理。&lt;br/&gt;  3、Scala &lt;code&gt;用 throw 关键字，抛出一个异常对象&lt;/code&gt;。所有异常都是 Throwable 的子类型。throw 表达式是有类型的，就是 Nothing，因为 Nothing 是所有类型的子类型，所以 throw 表达式可以用在需要类型的地方。&lt;br/&gt;示例代码如下：&lt;/p&gt;
&lt;pre readability=&quot;10&quot;&gt;
&lt;code class=&quot;scala language-scala&quot; readability=&quot;14&quot;&gt;package com.atguigu.chapter05.exception&lt;p&gt;object ThrowDemo {&lt;br/&gt;def main(args: Array[String]): Unit = {&lt;br/&gt;// val res = test()&lt;br/&gt;// println(res.toString)&lt;br/&gt;// println(&quot;继续执行002&quot;) // 异常抛出了，但是没有被处理，后续程序不能执行&lt;/p&gt;&lt;p&gt;// 如果我们希望在 test() 抛出异常后，后续代码可以继续执行，则我们需要如下处理&lt;br/&gt;try {&lt;br/&gt;test()&lt;br/&gt;} catch {&lt;br/&gt;case ex: Exception =&amp;gt; {&lt;br/&gt;println(&quot;捕获到异常是：&quot; + ex.getMessage)&lt;br/&gt;println(&quot;继续执行001&quot;)&lt;br/&gt;}&lt;br/&gt;case ex: ArithmeticException =&amp;gt; println(&quot;得到一个算术异常（小范围异常）&quot;)&lt;br/&gt;} finally {&lt;br/&gt;// 写上对 try{} 中的资源的分配&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;println(&quot;继续执行002&quot;)&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;def test(): Nothing = {&lt;br/&gt;// Exception(&quot;异常出现&quot;)&lt;br/&gt;throw new ArithmeticException(&quot;算术异常&quot;)&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;捕获到异常是：算术异常&lt;br/&gt;继续执行&lt;span class=&quot;hljs-number&quot;&gt;001&lt;/span&gt;&lt;br/&gt;继续执行&lt;span class=&quot;hljs-number&quot;&gt;002&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  4、在 Scala 里，借用了&lt;code&gt;模式匹配的思想来做异常的匹配&lt;/code&gt;，因此，在 catch 的代码里，是一系列 case 子句来匹配异常。【前面案例可以看出这个特点，模式匹配我们后面详解】，当匹配上后 =&amp;gt; 有多条语句可以换行写，类似 java 的 switch case x: 代码块…&lt;br/&gt;  5、异常捕捉的机制与其他语言中一样，如果有异常发生，catch 子句是按次序捕捉的。因此，在 catch 子句中，&lt;code&gt;越具体的异常越要靠前，越普遍的异常越靠后&lt;/code&gt;，如果把越普遍的异常写在前，把具体的异常写在后，在 scala 中也不会报错，但这样是非常不好的编程风格。&lt;br/&gt;  6、finally 子句用于执行不管是正常处理还是有异常发生时都需要执行的步骤，一般用于对象的清理工作，这点和 Java 一样。&lt;br/&gt;  7、Scala 提供了 throws 关键字来声明异常。可以使用方法定义声明异常。它向调用者函数提供了此方法可能引发此异常的信息。它有助于调用函数处理并将该代码包含在 try-catch 块中，以避免程序异常终止。在 scala 中，可以使用 throws 注释来声明异常。&lt;br/&gt;示例代码如下：&lt;/p&gt;
&lt;pre readability=&quot;5.5&quot;&gt;
&lt;code class=&quot;scala language-scala&quot; readability=&quot;5&quot;&gt;package com.atguigu.chapter05.exception&lt;p&gt;object ThrowsComment {&lt;br/&gt;def main(args: Array[String]): Unit = {&lt;br/&gt;f()&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;@throws(classOf[NumberFormatException]) // 等同于 Java 中 NumberFormatException.class&lt;br/&gt;def f() = {&lt;br/&gt;&quot;abc&quot;.toInt&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;Exception in thread &lt;span class=&quot;hljs-string&quot;&gt;&quot;main&quot;&lt;/span&gt; java.lang.NumberFormatException: For input string: &lt;span class=&quot;hljs-string&quot;&gt;&quot;abc&quot;&lt;/span&gt;&lt;br/&gt;at java.lang.NumberFormatException.forInputString(NumberFormatException.java:&lt;span class=&quot;hljs-number&quot;&gt;65&lt;/span&gt;)&lt;br/&gt;at java.lang.Integer.parseInt(Integer.java:&lt;span class=&quot;hljs-number&quot;&gt;580&lt;/span&gt;)&lt;br/&gt;at java.lang.Integer.parseInt(Integer.java:&lt;span class=&quot;hljs-number&quot;&gt;615&lt;/span&gt;)&lt;br/&gt;at scala.collection.immutable.StringLike$&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt;.&lt;span class=&quot;hljs-title&quot;&gt;toInt&lt;/span&gt;(&lt;span class=&quot;hljs-title&quot;&gt;StringLike&lt;/span&gt;.&lt;span class=&quot;hljs-title&quot;&gt;scala&lt;/span&gt;:272)&lt;br/&gt;&lt;span class=&quot;hljs-title&quot;&gt;at&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;scala&lt;/span&gt;.&lt;span class=&quot;hljs-title&quot;&gt;collection&lt;/span&gt;.&lt;span class=&quot;hljs-title&quot;&gt;immutable&lt;/span&gt;.&lt;span class=&quot;hljs-title&quot;&gt;StringOps&lt;/span&gt;.&lt;span class=&quot;hljs-title&quot;&gt;toInt&lt;/span&gt;(&lt;span class=&quot;hljs-title&quot;&gt;StringOps&lt;/span&gt;.&lt;span class=&quot;hljs-title&quot;&gt;scala&lt;/span&gt;:29)&lt;br/&gt;&lt;span class=&quot;hljs-title&quot;&gt;at&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;com&lt;/span&gt;.&lt;span class=&quot;hljs-title&quot;&gt;atguigu&lt;/span&gt;.&lt;span class=&quot;hljs-title&quot;&gt;chapter05&lt;/span&gt;.&lt;span class=&quot;hljs-title&quot;&gt;exception&lt;/span&gt;.&lt;span class=&quot;hljs-title&quot;&gt;ThrowsComment&lt;/span&gt;$.&lt;span class=&quot;hljs-title&quot;&gt;f&lt;/span&gt;(&lt;span class=&quot;hljs-title&quot;&gt;ThrowsComment&lt;/span&gt;.&lt;span class=&quot;hljs-title&quot;&gt;scala&lt;/span&gt;:10)&lt;br/&gt;&lt;span class=&quot;hljs-title&quot;&gt;at&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;com&lt;/span&gt;.&lt;span class=&quot;hljs-title&quot;&gt;atguigu&lt;/span&gt;.&lt;span class=&quot;hljs-title&quot;&gt;chapter05&lt;/span&gt;.&lt;span class=&quot;hljs-title&quot;&gt;exception&lt;/span&gt;.&lt;span class=&quot;hljs-title&quot;&gt;ThrowsComment&lt;/span&gt;$.&lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;(&lt;span class=&quot;hljs-title&quot;&gt;ThrowsComment&lt;/span&gt;.&lt;span class=&quot;hljs-title&quot;&gt;scala&lt;/span&gt;:5)&lt;br/&gt;&lt;span class=&quot;hljs-title&quot;&gt;at&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;com&lt;/span&gt;.&lt;span class=&quot;hljs-title&quot;&gt;atguigu&lt;/span&gt;.&lt;span class=&quot;hljs-title&quot;&gt;chapter05&lt;/span&gt;.&lt;span class=&quot;hljs-title&quot;&gt;exception&lt;/span&gt;.&lt;span class=&quot;hljs-title&quot;&gt;ThrowsComment&lt;/span&gt;.&lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;(&lt;span class=&quot;hljs-title&quot;&gt;ThrowsComment&lt;/span&gt;.&lt;span class=&quot;hljs-title&quot;&gt;scala&lt;/span&gt;)&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;h511-1&quot;&gt;&lt;span&gt;&lt;strong&gt;5.11 函数的练习题&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;1、函数可以没有返回值案例，编写一个函数，从终端输入一个整数打印出对应的金子塔。&lt;br/&gt;示例代码如下：&lt;/p&gt;
&lt;pre readability=&quot;7.5&quot;&gt;
&lt;code class=&quot;scala language-scala&quot; readability=&quot;9&quot;&gt;package com.atguigu.chapter05.exercises&lt;p&gt;import scala.io.StdIn&lt;/p&gt;&lt;p&gt;/**&lt;br/&gt;* 1、函数可以没有返回值案例，编写一个函数，从终端输入一个整数打印出对应的金子塔。&lt;br/&gt;* 思路：本质是打印出所有的 n行m列 数据。 分别循环即可！&lt;br/&gt;*/&lt;br/&gt;object Exercise01 {&lt;br/&gt;def main(args: Array[String]): Unit = {&lt;br/&gt;println(&quot;请输入一个整数n(n&amp;gt;=1)：&quot;)&lt;br/&gt;val n = StdIn.readInt()&lt;br/&gt;printJin(n)&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;def printJin(n: Int): Unit = {&lt;br/&gt;for (i &amp;lt;- 1 to n) { // 行数&lt;br/&gt;for (j &amp;lt;- 1 to (n - i)) {&lt;br/&gt;printf(&quot;-&quot;)&lt;br/&gt;}&lt;br/&gt;for (j &amp;lt;- 1 to (2 * i - 1)) { // 列数&lt;br/&gt;printf(&quot;*&quot;)&lt;br/&gt;}&lt;br/&gt;for (j &amp;lt;- 1 to (n - i)) {&lt;br/&gt;printf(&quot;-&quot;)&lt;br/&gt;}&lt;br/&gt;println()&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;请输入一个整数n(n&amp;gt;=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;)：&lt;br/&gt;&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;&lt;br/&gt;----*----&lt;br/&gt;---***---&lt;br/&gt;--*****--&lt;br/&gt;-*******-&lt;br/&gt;*********&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2、编写一个函数，从终端输入一个整数(1—9)，打印出对应的乘法表。&lt;br/&gt;示例代码如下：&lt;/p&gt;
&lt;pre readability=&quot;8&quot;&gt;
&lt;code class=&quot;scala language-scala&quot; readability=&quot;10&quot;&gt;package com.atguigu.chapter05.exercises&lt;p&gt;import scala.io.StdIn&lt;/p&gt;&lt;p&gt;/**&lt;br/&gt;* 2、编写一个函数，从终端输入一个整数(1—9)，打印出对应的乘法表。&lt;br/&gt;*/&lt;br/&gt;object Exercise01 {&lt;br/&gt;def main(args: Array[String]): Unit = {&lt;br/&gt;println(&quot;请输入数字（1-9）之间：&quot;)&lt;br/&gt;val n = StdIn.readInt()&lt;br/&gt;print99(n)&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;def print99(n: Int): Unit = {&lt;br/&gt;for (i &amp;lt;- 1 to n) {&lt;br/&gt;for (j &amp;lt;- 1 to i) {&lt;br/&gt;printf(&quot;%d * %d = %d\t&quot;, j, i, j * i)&lt;br/&gt;}&lt;br/&gt;println()&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3、编写函数，对给定的一个二维数组 (3×3) 转置，这个题讲数组的时候再完成。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs&quot;&gt;    1 2 3       1 4 7            &lt;br/&gt;4 5 6       2 5 8               &lt;br/&gt;7 8 9       3 6 9&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;h-1&quot;&gt;&lt;span&gt;&lt;strong&gt;第六章 面向对象编程-基础&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;h3 id=&quot;h61&quot;&gt;&lt;span&gt;&lt;strong&gt;6.1 类与对象&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;看一个养猫猫问题：&lt;/strong&gt;&lt;br/&gt;  张老太养了只猫猫：一只名字叫小白，今年3岁，白色。还有一只叫小花，今年10岁，花色。请编写一个程序，当用户输入小猫的名字时，就显示该猫的名字，年龄，颜色。如果用户输入的小猫名错误，则显示张老太没有这只猫猫。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;问题：&lt;/strong&gt;&lt;br/&gt;  1、猫有三个属性，类型不一样。&lt;br/&gt;  2、如果使用普通的变量就不好管理。&lt;br/&gt;  3、使用一种新的数据类型：&lt;br/&gt;    (1) 可以管理多个不同类型的数据 [属性]。&lt;br/&gt;    (2) 可以对属性进行操作 =&amp;gt; 方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;类与对象的关系示意图&lt;/strong&gt;&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/26/Aa9GOx.png&quot; alt=&quot;&quot;/&gt;&lt;h4 id=&quot;h611scala&quot;&gt;&lt;span&gt;&lt;strong&gt;6.1.1 Scala 语言是面向对象的&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;  1、Java 是面向对象的编程语言，由于历史原因，Java 中还存在着非面向对象的内容：基本类型，null，静态方法等。&lt;br/&gt;  2、Scala 语言来自于 Java，所以天生就是面向对象的语言，而且 Scala 是纯粹的面向对象的语言，即在 Scala 中，一切皆为对象。&lt;br/&gt;  3、在面向对象的学习过程中可以对比着 Java 语言学习。&lt;/p&gt;
&lt;h4 id=&quot;h612&quot;&gt;&lt;span&gt;&lt;strong&gt;6.1.2 快速入门-面向对象的方式解决养猫问题&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;示例代码如下：&lt;/p&gt;
&lt;pre readability=&quot;17.5&quot;&gt;
&lt;code class=&quot;scala language-scala&quot; readability=&quot;29&quot;&gt;package com.atguigu.chapter06.oop&lt;p&gt;object CatDemo {&lt;br/&gt;def main(args: Array[String]): Unit = {&lt;/p&gt;&lt;p&gt;// 创建一只猫&lt;br/&gt;val cat = new Cat&lt;/p&gt;&lt;p&gt;// 给猫的属性赋值&lt;br/&gt;// 说明&lt;br/&gt;// 1. cat.name = &quot;小白&quot; 其实不是直接访问属性，而是等价于 cat.name_$eq(&quot;小白&quot;)&lt;br/&gt;// 2. cat.name 等价于 cat.name()&lt;br/&gt;cat.name = &quot;小白&quot;&lt;br/&gt;cat.age = 3&lt;br/&gt;cat.color = &quot;白色&quot;&lt;/p&gt;&lt;p&gt;printf(&quot;\n小猫的信息如下：%s %d %s&quot;, cat.name, cat.age, cat.color)&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;/* 反编译查看源码&lt;br/&gt;public void main (String[] args) {&lt;br/&gt;Cat cat = new Cat ();&lt;/p&gt;&lt;p&gt;cat.name_$eq (&quot;小白&quot;);&lt;br/&gt;cat.age_$eq (3);&lt;br/&gt;cat.color_$eq (&quot;白色&quot;);&lt;br/&gt;}&lt;br/&gt;*/&lt;/p&gt;&lt;p&gt;// 定义一个 Cat 类&lt;br/&gt;// 一个class Cat 对应的字节码文件只有一个 Cat.class ，默认是public&lt;br/&gt;class Cat {&lt;br/&gt;// 定义/声明三个属性&lt;br/&gt;// 说明&lt;br/&gt;// 1. 当我们声明了 var name: String 时，同时在底层对应生成 private name&lt;br/&gt;// 2. 同时在底层会生成 两个 public 方法 public String name() 类似 =&amp;gt; getter 和 public void name_$eq(String x$1) =&amp;gt; setter&lt;br/&gt;var name: String = &quot;&quot; // Scala 中定义变量必须给初始值&lt;br/&gt;var age: Int = _ // 下划线表示给 age 一个默认值，如果是 Int 类型，默认就是 0&lt;br/&gt;var color: String = _ // 如果是 String 类型，默认值就是 null&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;/* 反编译查看源码&lt;br/&gt;public class Cat {&lt;br/&gt;private String name = &quot;&quot;;&lt;br/&gt;private int age;&lt;br/&gt;private String color;&lt;/p&gt;&lt;p&gt;public String name() {&lt;br/&gt;return this.name;&lt;br/&gt;}&lt;br/&gt;public void name_$eq(String x$1) {&lt;br/&gt;this.name = x$1;&lt;br/&gt;}&lt;br/&gt;public int age() {&lt;br/&gt;return this.age;&lt;br/&gt;}&lt;br/&gt;public void age_$eq(int x$1) {&lt;br/&gt;this.age = x$1;&lt;br/&gt;}&lt;br/&gt;public String color() {&lt;br/&gt;return this.color;&lt;br/&gt;}&lt;br/&gt;public void color_$eq(String x$1) {&lt;br/&gt;this.color = x$1;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;*/&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs&quot;&gt;小猫的信息如下：小白 3 白色&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;h613&quot;&gt;&lt;span&gt;&lt;strong&gt;6.1.3 类和对象的区别和联系&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;通过上面的案例和讲解我们可以看出：&lt;br/&gt;  1、类是抽象的，概念的，代表一类事物，比如人类，猫类…&lt;br/&gt;  2、对象是具体的，实际的，代表一个具体事物。&lt;br/&gt;  3、类是对象的模板，对象是类的一个个体，对应一个实例。&lt;br/&gt;  4、Scala 中类和对象的区别和联系 和 Java 是一样的。&lt;/p&gt;
&lt;h4 id=&quot;h614&quot;&gt;&lt;span&gt;&lt;strong&gt;6.1.4 如何定义类&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/26/Aa9Ym6.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;我们可以通过&lt;strong&gt;反编译&lt;/strong&gt;来看 scala 的类默认为 public 的特性。
&lt;h4 id=&quot;h615&quot;&gt;&lt;span&gt;&lt;strong&gt;6.1.5 属性&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/26/Aa9t0K.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;示例代码如下：

&lt;pre&gt;
&lt;code class=&quot;scala language-scala&quot;&gt;class Dog {&lt;br/&gt;var name = &quot;jack&quot;&lt;br/&gt;var lover = new Fish&lt;br/&gt;}&lt;p&gt;class Fish {&lt;/p&gt;&lt;p&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;h616&quot;&gt;&lt;span&gt;&lt;strong&gt;6.1.6 属性/成员变量&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/26/Aa9wfH.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;示例代码如下：

&lt;pre readability=&quot;12&quot;&gt;
&lt;code class=&quot;scala language-scala&quot; readability=&quot;18&quot;&gt;package com.atguigu.chapter06.oop&lt;p&gt;object PropertyDemo {&lt;br/&gt;def main(args: Array[String]): Unit = {&lt;br/&gt;// val p1 = new Person&lt;br/&gt;// println(p1.Name)     // Null&lt;br/&gt;// println(p1.address)  // String 类型&lt;/p&gt;&lt;p&gt;val a = new A&lt;br/&gt;println(a.var1) // null&lt;br/&gt;println(a.var2) // 0&lt;br/&gt;println(a.var3) // 0.0&lt;br/&gt;println(a.var4) // false&lt;/p&gt;&lt;p&gt;// 不同对象的属性是独立，互不影响，一个对象对属性的更改，不影响另外一个&lt;br/&gt;// 创建两个对象&lt;br/&gt;var worker1 = new Worker&lt;br/&gt;worker1.name = &quot;jack&quot;&lt;br/&gt;var worker2 = new Worker&lt;br/&gt;worker2.name = &quot;tom&quot;&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;class Person3 {&lt;br/&gt;var age: Int = 10   // 给属性赋初值，省略类型，会自动推导&lt;br/&gt;var sal = 8090.9&lt;br/&gt;var Name = null     // Name 是什么类型&lt;br/&gt;var address: String = null // ok&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;class A {&lt;br/&gt;var var1: String = _  // null   String 和 引用类型默认值是 null&lt;br/&gt;var var2: Byte = _    // 0&lt;br/&gt;var var3: Double = _  // 0.0&lt;br/&gt;var var4: Boolean = _ // false&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;class Worker {&lt;br/&gt;var name = &quot;&quot;&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs coffeescript&quot;&gt;&lt;span class=&quot;hljs-literal&quot;&gt;null&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-number&quot;&gt;0.0&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;h617&quot;&gt;&lt;span&gt;&lt;strong&gt;6.1.7 属性的高级部分&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;  说明：属性的高级部分和构造器(构造方法/函数) 相关，我们把属性高级部分放到构造器那里讲解。&lt;/p&gt;
&lt;h4 id=&quot;h618&quot;&gt;&lt;span&gt;&lt;strong&gt;6.1.8 如何创建对象&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/26/Aa9NTO.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;示例代码如下：
&lt;pre readability=&quot;7&quot;&gt;
&lt;code class=&quot;scala language-scala&quot; readability=&quot;8&quot;&gt;package com.atguigu.chapter06.oop&lt;p&gt;object CreateObjDemo {&lt;br/&gt;def main(args: Array[String]): Unit = {&lt;br/&gt;val emp = new Emp // 此时的 emp 类型就是 Emp&lt;/p&gt;&lt;p&gt;// 如果我们希望将子类对象，交给父类引用，这时就需要写上类型，不能省略！&lt;br/&gt;val emp1: Person = new Emp&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;class Person {&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;p&gt;class Emp extends Person {&lt;/p&gt;&lt;p&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;h619&quot;&gt;&lt;span&gt;&lt;strong&gt;6.1.9 类和对象的内存分配机制（重要）&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;内存布局图：&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/26/Aa9D1A.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;示例代码如下：
&lt;pre readability=&quot;7.5&quot;&gt;
&lt;code class=&quot;scala language-scala&quot; readability=&quot;9&quot;&gt;package com.atguigu.chapter06.oop&lt;p&gt;object MemState {&lt;br/&gt;def main(args: Array[String]): Unit = {&lt;br/&gt;val p2 = new Person2&lt;br/&gt;p2.name = &quot;jack&quot;&lt;br/&gt;p2.age= 10&lt;/p&gt;&lt;p&gt;val p1 = p2&lt;br/&gt;println(p1 == p2) // true&lt;br/&gt;println(&quot;p2.age=&quot; + p2.age) // 10&lt;br/&gt;println(&quot;p1.age=&quot; + p1.age) // 10&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;class Person2 {&lt;br/&gt;var name = &quot;&quot;&lt;br/&gt;var age: Int = _ // 如果是用下划线的方式给默认值，则属性必须指定类型，因为这有这样，scala 底层才能够进行类型推断&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;h62&quot;&gt;&lt;span&gt;&lt;strong&gt;6.2 方法&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;h4 id=&quot;h621&quot;&gt;&lt;span&gt;&lt;strong&gt;6.2.1 基本说明和基本语法&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/26/Aa9dte.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;示例代码如下：
&lt;pre readability=&quot;7.5&quot;&gt;
&lt;code class=&quot;scala language-scala&quot; readability=&quot;9&quot;&gt;package com.atguigu.chapter06.method&lt;p&gt;object MethodDemo01 {&lt;br/&gt;def main(args: Array[String]): Unit = {&lt;br/&gt;// 使用一把&lt;br/&gt;val dog = new Dog&lt;br/&gt;println(dog.cal(10, 20))&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;class Dog {&lt;br/&gt;private var sal: Double = _&lt;br/&gt;var food: String = _&lt;/p&gt;&lt;p&gt;def cal(n1: Int, n2: Int): Int = {&lt;br/&gt;return n1 + n2&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;h622&quot;&gt;&lt;span&gt;&lt;strong&gt;6.2.2 方法的调用机制原理&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/26/Aa96nP.png&quot; alt=&quot;&quot;/&gt;&lt;h4 id=&quot;h623&quot;&gt;&lt;span&gt;&lt;strong&gt;6.2.3 方法练习题&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/26/Aa9Bpd.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;1~3题的示例代码如下：
&lt;pre readability=&quot;15.5&quot;&gt;
&lt;code class=&quot;scala language-scala&quot; readability=&quot;25&quot;&gt;package com.atguigu.chapter06.method&lt;p&gt;/**&lt;br/&gt;* 1、编写类(MethodExec)，编写一个方法，方法不需要参数，在方法中打印一个10*8的矩形，在main方法中调用该方法。&lt;br/&gt;*&lt;br/&gt;* 2、修改上一个程序，编写一个方法中，方法不需要参数，计算该矩形的面积，并将其作为方法返回值。在main方法中调用该方法，接收返回的面积值并打印(结果保留小数点2位)。&lt;br/&gt;*&lt;br/&gt;* 3、修改上一个程序，编写一个方法，提供m和n两个参数，方法中打印一个m*n的矩形，再编写一个方法计算该矩形的面积(可以接收长len和宽width)， 将其作为方法返回值。在main方法中调用该方法，接收返回的面积值并打印。&lt;br/&gt;*/&lt;br/&gt;object MethodDemo02 {&lt;br/&gt;def main(args: Array[String]): Unit = {&lt;br/&gt;val m = new MethodExec&lt;br/&gt;m.printRect1()&lt;/p&gt;&lt;p&gt;m.len = 1.2&lt;br/&gt;m.width = 3.4&lt;br/&gt;println(&quot;面积=&quot; + m.area1())&lt;/p&gt;&lt;p&gt;m.printRect2(5, 4)&lt;br/&gt;println(&quot;面积=&quot; + m.area2(1.2, 3.4))&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;class MethodExec {&lt;/p&gt;&lt;p&gt;var len = 0.0&lt;br/&gt;var width = 0.0&lt;/p&gt;&lt;p&gt;def printRect1(): Unit = {&lt;br/&gt;for (i &amp;lt;- 0 until 10) {&lt;br/&gt;for (j &amp;lt;- 0 until 8) {&lt;br/&gt;print(&quot;*&quot;)&lt;br/&gt;}&lt;br/&gt;println()&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;def area1(): Double = {&lt;br/&gt;this.len * this.width.formatted(&quot;%.2f&quot;).toDouble&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;def printRect2(m: Int, n: Int): Unit = {&lt;br/&gt;for (i &amp;lt;- 0 until m) {&lt;br/&gt;for (j &amp;lt;- 0 until n) {&lt;br/&gt;printf(&quot;*&quot;)&lt;br/&gt;}&lt;br/&gt;println()&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;def area2(len: Double, width: Double): Double = {&lt;br/&gt;len * width.formatted(&quot;%.2f&quot;).toDouble&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs markdown&quot;&gt;&lt;span class=&quot;hljs-strong&quot;&gt;*****&lt;/span&gt;&lt;span class=&quot;hljs-emphasis&quot;&gt;***&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-strong&quot;&gt;*****&lt;/span&gt;&lt;span class=&quot;hljs-emphasis&quot;&gt;***&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-strong&quot;&gt;*****&lt;/span&gt;&lt;span class=&quot;hljs-emphasis&quot;&gt;***&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-strong&quot;&gt;*****&lt;/span&gt;&lt;span class=&quot;hljs-emphasis&quot;&gt;***&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-strong&quot;&gt;*****&lt;/span&gt;&lt;span class=&quot;hljs-emphasis&quot;&gt;***&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-strong&quot;&gt;*****&lt;/span&gt;&lt;span class=&quot;hljs-emphasis&quot;&gt;***&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-strong&quot;&gt;*****&lt;/span&gt;&lt;span class=&quot;hljs-emphasis&quot;&gt;***&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-strong&quot;&gt;*****&lt;/span&gt;&lt;span class=&quot;hljs-emphasis&quot;&gt;***&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-strong&quot;&gt;*****&lt;/span&gt;&lt;span class=&quot;hljs-emphasis&quot;&gt;***&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-strong&quot;&gt;*****&lt;/span&gt;&lt;span class=&quot;hljs-emphasis&quot;&gt;***&lt;/span&gt;&lt;br/&gt;面积=4.08&lt;br/&gt;&lt;span class=&quot;hljs-emphasis&quot;&gt;***&lt;/span&gt;*&lt;br/&gt;&lt;span class=&quot;hljs-emphasis&quot;&gt;***&lt;/span&gt;*&lt;br/&gt;&lt;span class=&quot;hljs-emphasis&quot;&gt;***&lt;/span&gt;*&lt;br/&gt;&lt;span class=&quot;hljs-emphasis&quot;&gt;***&lt;/span&gt;*&lt;br/&gt;&lt;span class=&quot;hljs-emphasis&quot;&gt;***&lt;/span&gt;*&lt;br/&gt;面积=4.08&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;4~6题的示例代码原理同上1~3题，不在赘述！&lt;/p&gt;
&lt;h3 id=&quot;h63&quot;&gt;&lt;span&gt;&lt;strong&gt;6.3 类与对象应用实例&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/26/Aa9r6I.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;景区门票案例&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/26/Aa9sXt.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;小狗案列的示例代码如下：
&lt;pre readability=&quot;8&quot;&gt;
&lt;code class=&quot;scala language-scala&quot; readability=&quot;10&quot;&gt;package com.atguigu.chapter06.dogcase&lt;p&gt;/**&lt;br/&gt;* 小狗案例&lt;br/&gt;*&lt;br/&gt;* 编写一个Dog类，包含name(String)、age(Int)、weight(Double)属性。&lt;br/&gt;* 类中声明一个say方法，返回String类型，方法返回信息中包含所有属性值。&lt;br/&gt;* 在另一个DogCaseTest类中的main方法中，创建Dog对象，并访问say方法和所有属性，将调用结果打印输出。&lt;br/&gt;*/&lt;br/&gt;object DogCaseTest {&lt;br/&gt;def main(args: Array[String]): Unit = {&lt;br/&gt;val dog = new Dog&lt;br/&gt;dog.name = &quot;泰斯特&quot;&lt;br/&gt;dog.age = 2&lt;br/&gt;dog.weight = 50&lt;br/&gt;println(dog.say())&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;class Dog {&lt;br/&gt;var name = &quot;&quot;&lt;br/&gt;var age = 0&lt;br/&gt;var weight = 0.0&lt;/p&gt;&lt;p&gt;def say(): String = {&lt;br/&gt;&quot;小狗的信息是：name=&quot; + this.name + &quot;\tage=&quot; + this.age + &quot;\tweight=&quot; + this.weight&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs delphi&quot;&gt;小狗的信息是：&lt;span class=&quot;hljs-keyword&quot;&gt;name&lt;/span&gt;=泰斯特    age=&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;   weight=&lt;span class=&quot;hljs-number&quot;&gt;50.0&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;盒子案列、景区门票案例的示例代码原理同上小狗案例，不在赘述！&lt;/p&gt;
&lt;h3 id=&quot;h64&quot;&gt;&lt;span&gt;&lt;strong&gt;6.4 构造器&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;h4 id=&quot;h641&quot;&gt;&lt;span&gt;&lt;strong&gt;6.4.1 看一个需求&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;  前面我们在创建 Person 的对象时，是先把一个对象创建好后，再给他的年龄和姓名属性赋值，如果现在我要求，在创建人类的对象时，就直接指定这个对象的年龄和姓名，该怎么做? 这时就可以使用构造方法/构造器。&lt;/p&gt;
&lt;h4 id=&quot;h642java&quot;&gt;&lt;span&gt;&lt;strong&gt;6.4.2 回顾-Java 构造器的介绍+基本语法+特点+案例&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Java 构造器的介绍&lt;/strong&gt;&lt;br/&gt;  构造器(constructor)又叫构造方法，是类的一种特殊的方法，它的主要作用是&lt;code&gt;完成对新对象的初始化&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Java 构造器的基本语法&lt;/strong&gt;&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/26/Aa951s.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;&lt;strong&gt;Java 构造器的特点&lt;/strong&gt;&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/26/Aa9c0f.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;&lt;strong&gt;Java 构造器的案例&lt;/strong&gt;&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/26/Aa9RAS.png&quot; alt=&quot;&quot;/&gt;&lt;h4 id=&quot;h643scala&quot;&gt;&lt;span&gt;&lt;strong&gt;6.4.3 Scala 构造器的介绍+基本语法+快速入门&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Scala 构造器的介绍&lt;/strong&gt;&lt;br/&gt;  和 Java 一样，Scala 构造对象也需要调用构造方法，并且可以有任意多个构造方法（即 scala 中构造器也支持重载）。&lt;br/&gt;  Scala 类的构造器包括： &lt;code&gt;主构造器&lt;/code&gt; 和 &lt;code&gt;辅助构造器&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Scala 构造器的基本语法&lt;/strong&gt;&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/26/Aa9g78.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;&lt;strong&gt;Scala 构造器的快速入门&lt;/strong&gt;&lt;br/&gt;示例代码如下：&lt;/p&gt;
&lt;pre readability=&quot;8.5&quot;&gt;
&lt;code class=&quot;scala language-scala&quot; readability=&quot;11&quot;&gt;package com.atguigu.chapter06.constructor&lt;p&gt;/**&lt;br/&gt;* Scala构造器的快速入门：创建Person对象的同时初始化对象的age属性值和name属性值&lt;br/&gt;*/&lt;br/&gt;object ConstructorDemo01 {&lt;br/&gt;def main(args: Array[String]): Unit = {&lt;br/&gt;val p1 = new Person(&quot;bruce&quot;, 20)&lt;br/&gt;println(p1)&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;class Person(inName: String, inAge: Int) {&lt;br/&gt;var name: String = inName&lt;br/&gt;var age: Int = inAge&lt;/p&gt;&lt;p&gt;// 重写toString方法&lt;br/&gt;override def toString: String = {&lt;br/&gt;&quot;name=&quot; + this.name + &quot;\tage=&quot; + this.age&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs ini&quot;&gt;&lt;span class=&quot;hljs-attr&quot;&gt;name&lt;/span&gt;=bruce    age=&lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;h644scala&quot;&gt;&lt;span&gt;&lt;strong&gt;6.4.4 Scala 构造器注意事项和细节&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;  1、Scala 构造器作用是完成对新对象的初始化，构造器没有返回值。&lt;br/&gt;  2、主构造器的声明直接放置于类名之后。【可以反编译查看】&lt;br/&gt;  3、主构造器会执行类定义中的所有语句(除掉函数部分)，这里可以体会到 Scala 的函数式编程和面向对象编程融合在一起，即：&lt;code&gt;构造器也是方法（函数）&lt;/code&gt;，传递参数和使用方法和前面的函数部分内容没有区别。【案例演示+反编译查看-语法糖】&lt;br/&gt;  4、如果主构造器无参数，小括号可省略，构建对象时调用的构造方法的小括号也可以省略。&lt;br/&gt;  5、辅助构造器名称为 this（这个和 Java 是不一样的），多个辅助构造器通过不同参数列表进行区分， 在底层就是f构造器重载。【案例演示+反编译查看】&lt;br/&gt;示例代码如下：&lt;/p&gt;
&lt;pre readability=&quot;8&quot;&gt;
&lt;code class=&quot;scala language-scala&quot; readability=&quot;10&quot;&gt;package com.atguigu.chapter06.constructor&lt;p&gt;object ConstructorDemo02 {&lt;br/&gt;def main(args: Array[String]): Unit = {&lt;br/&gt;// val a = new A&lt;br/&gt;val aa = new A(&quot;jack&quot;)&lt;br/&gt;// 执行顺序：&lt;br/&gt;// 1、bbb  父类构造器&lt;br/&gt;// 2、A    子类主构造器&lt;br/&gt;// 3、aaa  子类辅助构造器&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;class B {&lt;br/&gt;println(&quot;bbb&quot;)&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;class A extends B {&lt;br/&gt;println(&quot;A&quot;)&lt;br/&gt;def this(name: String) {&lt;br/&gt;this // 调用A的主构造器，其根本原因就是实现子类与父类之间的继承关系，不然继承关系就断了！！！&lt;br/&gt;println(&quot;aaa&quot;)&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs nginx&quot;&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;bbb&lt;/span&gt;&lt;br/&gt;A&lt;br/&gt;aaa&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;示例代码如下：&lt;/p&gt;
&lt;pre readability=&quot;13&quot;&gt;
&lt;code class=&quot;scala language-scala&quot; readability=&quot;20&quot;&gt;package com.atguigu.chapter06.constructor&lt;p&gt;object ConstructorDemo03 {&lt;br/&gt;def main(args: Array[String]): Unit = {&lt;br/&gt;val p1 = new Person(&quot;scott&quot;)&lt;br/&gt;p1.showInfo()&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;class Person() {&lt;br/&gt;var name: String = _&lt;br/&gt;var age: Int = _&lt;/p&gt;&lt;p&gt;def this(name: String) {&lt;br/&gt;// 辅助构造器无论是直接或间接，最终都一定要调用主构造器，执行主构造器的逻辑&lt;br/&gt;// 而且需要放在辅助构造器的第一行[这点和 java 一样，java 中一个构造器要调用同类的其它构造器，也需要放在第一行]&lt;br/&gt;this() // 直接调用主构造器&lt;br/&gt;this.name = name&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;def this(name: String, age: Int) {&lt;br/&gt;this() // 直接调用主构造器&lt;br/&gt;this.name = name&lt;br/&gt;this.age = age&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;def this(age: Int) {&lt;br/&gt;this(&quot;匿名&quot;) // 间接调用主构造器，因为 def this(name: String) 中直接调用了主构造器&lt;br/&gt;this.age = age&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;def showInfo(): Unit = {&lt;br/&gt;println(&quot;person信息如下:&quot;)&lt;br/&gt;println(&quot;name=&quot; + this.name)&lt;br/&gt;println(&quot;age=&quot; + this.age)&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs makefile&quot;&gt;&lt;span class=&quot;hljs-section&quot;&gt;person信息如下:&lt;/span&gt;&lt;br/&gt;name=scott&lt;br/&gt;age=0&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  6、如果想让主构造器变成私有的，可以在()之前加上 private，这样用户只能通过辅助构造器来构造对象了。【反编译查看】&lt;br/&gt;  7、辅助构造器的声明不能和主构造器的声明(即形参列表)一致，会发生错误(即构造器名重复)。&lt;/p&gt;
&lt;h3 id=&quot;h65&quot;&gt;&lt;span&gt;&lt;strong&gt;6.5 属性高级&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;  前面我们讲过属性了，这里我们再对属性的内容做一个加强。&lt;/p&gt;
&lt;h4 id=&quot;h651&quot;&gt;&lt;span&gt;&lt;strong&gt;6.5.1 构造器参数&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/26/Aa9fhQ.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;示例代码如下：
&lt;pre readability=&quot;10.5&quot;&gt;
&lt;code class=&quot;scala language-scala&quot; readability=&quot;15&quot;&gt;package com.atguigu.chapter06.constructor&lt;p&gt;object ConstructorDemo04 {&lt;br/&gt;def main(args: Array[String]): Unit = {&lt;br/&gt;val worker1 = new Worker1(&quot;smith1&quot;)&lt;br/&gt;worker1.name    // 不能访问 inName&lt;/p&gt;&lt;p&gt;val worker2 = new Worker2(&quot;smith2&quot;)&lt;br/&gt;worker2.inName  // 可以访问 inName&lt;br/&gt;println(&quot;hello!&quot;)&lt;/p&gt;&lt;p&gt;val worker3 = new Worker3(&quot;jack&quot;)&lt;br/&gt;worker3.inName = &quot;mary&quot;&lt;br/&gt;println(worker3.inName)&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;// 1. 如果 主构造器是 Worker1(inName: String)，那么 inName 就是一个局部变量。&lt;br/&gt;class Worker1(inName: String) {&lt;br/&gt;var name = inName&lt;br/&gt;}&lt;br/&gt;// 2. 如果 主构造器是 Worker2(val inName: String)，那么 inName 就是 Worker2 的一个 private 的只读属性。&lt;br/&gt;class Worker2(val inName: String) {&lt;br/&gt;var name = inName&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;// 3. 如果 主构造器是 Worker3(var inName: String)，那么 inName 就是 Worker3 的一个 private 的可以读写属性。&lt;br/&gt;class Worker3(var inName: String) {&lt;br/&gt;var name = inName&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;h652bean&quot;&gt;&lt;span&gt;&lt;strong&gt;6.5.2 Bean 属性&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/26/Aa9Wtg.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;示例代码如下：
&lt;pre readability=&quot;8&quot;&gt;
&lt;code class=&quot;scala language-scala&quot; readability=&quot;10&quot;&gt;package com.atguigu.chapter06.constructor&lt;p&gt;import scala.beans.BeanProperty&lt;/p&gt;&lt;p&gt;object BeanPropertDemo {&lt;br/&gt;def main(args: Array[String]): Unit = {&lt;br/&gt;val car = new Car&lt;br/&gt;car.name = &quot;宝马&quot;&lt;br/&gt;println(car.name)&lt;/p&gt;&lt;p&gt;// 使用 @BeanProperty 自动生成 getXxx() 和 setXxx()&lt;br/&gt;car.setName(&quot;奔驰&quot;)&lt;br/&gt;println(car.getName())&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;class Car {&lt;br/&gt;@BeanProperty var name: String = null&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;h66scala&quot;&gt;&lt;span&gt;&lt;strong&gt;6.6 Scala 对象创建的流程分析&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/26/Aa94pj.png&quot; alt=&quot;&quot;/&gt;&lt;h3 id=&quot;h6703&quot;&gt;&lt;span&gt;&lt;strong&gt;6.7 作业03&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;1、一个数字如果为正数，则它的 signum 为1.0，如果是负数，则 signum 为-1.0，如果为0，则 signum 为0.0。编写一个函数来计算这个值。&lt;br/&gt;示例代码如下：&lt;/p&gt;
&lt;pre readability=&quot;6.5&quot;&gt;
&lt;code class=&quot;scala language-scala&quot; readability=&quot;7&quot;&gt;package com.atguigu.chapter06.exercises&lt;p&gt;import scala.io.StdIn&lt;/p&gt;&lt;p&gt;/**&lt;br/&gt;* 1、一个数字如果为正数，则它的 signum 为1，如果是负数，则 signum 为-1，如果为0，则 signum 为0。编写一个函数来计算这个值。&lt;br/&gt;*/&lt;br/&gt;object Exercise01 {&lt;br/&gt;def main(args: Array[String]): Unit = {&lt;br/&gt;println(&quot;请输入一个数字：&quot;)&lt;br/&gt;val n = StdIn.readDouble()&lt;br/&gt;println(&quot;该数的 signum 为：&quot; + signum(n))&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;def signum(n: Double): Double = {&lt;br/&gt;if (n &amp;gt; 0) {&lt;br/&gt;1&lt;br/&gt;} else if (n &amp;lt; 0) {&lt;br/&gt;-1&lt;br/&gt;} else {&lt;br/&gt;0&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果如下：&lt;/p&gt;
&lt;pre readability=&quot;5&quot;&gt;
&lt;code class=&quot;hljs css&quot; readability=&quot;4&quot;&gt;请输入一个数字：&lt;br/&gt;0&lt;br/&gt;该数的 &lt;span class=&quot;hljs-selector-tag&quot;&gt;signum&lt;/span&gt; 为：0&lt;span class=&quot;hljs-selector-class&quot;&gt;.0&lt;/span&gt;&lt;p&gt;请输入一个数字：&lt;br/&gt;5&lt;br/&gt;该数的 &lt;span class=&quot;hljs-selector-tag&quot;&gt;signum&lt;/span&gt; 为：1&lt;span class=&quot;hljs-selector-class&quot;&gt;.0&lt;/span&gt;&lt;/p&gt;&lt;p&gt;请输入一个数字：&lt;br/&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;-3&lt;/span&gt;&lt;br/&gt;该数的 &lt;span class=&quot;hljs-selector-tag&quot;&gt;signum&lt;/span&gt; 为：&lt;span class=&quot;hljs-selector-tag&quot;&gt;-1&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.0&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2、一个空的块表达式&lt;code&gt;{}&lt;/code&gt;的值是什么？类型是什么？&lt;br/&gt;示例代码如下：&lt;/p&gt;
&lt;pre readability=&quot;5&quot;&gt;
&lt;code class=&quot;scala language-scala&quot; readability=&quot;4&quot;&gt;package com.atguigu.chapter06.exercises&lt;p&gt;/**&lt;br/&gt;* 2、一个空的块表达式 {} 的值是什么？类型是什么？&lt;br/&gt;*/&lt;br/&gt;object Exercise02 {&lt;br/&gt;def main(args: Array[String]): Unit = {&lt;br/&gt;val t = {}&lt;br/&gt;println(&quot;t=&quot; + t) // t=()&lt;br/&gt;println(t.isInstanceOf[Unit]) // true&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3、针对下列 Java 循环编写一个 Scala 版本：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;; i&amp;gt;=&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i–-) {&lt;br/&gt;System.out.println(i);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;示例代码如下：&lt;/p&gt;
&lt;pre readability=&quot;10.5&quot;&gt;
&lt;code class=&quot;scala language-scala&quot; readability=&quot;15&quot;&gt;package com.atguigu.chapter06.exercises&lt;p&gt;/**&lt;br/&gt;* 3、针对下列 Java 循环编写一个 Scala 版本：&lt;br/&gt;* for (int i=10; i&amp;gt;=0; i–-) {&lt;br/&gt;*   System.out.println(i);&lt;br/&gt;* }&lt;br/&gt;*/&lt;br/&gt;object Exercise03 {&lt;br/&gt;def main(args: Array[String]): Unit = {&lt;br/&gt;// 方式一：&lt;br/&gt;for (i &amp;lt;- 0 to 10) {&lt;br/&gt;println(&quot;i=&quot; + (10 - i))&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;println(&quot;----------&quot;)&lt;/p&gt;&lt;p&gt;// 方式二：&lt;br/&gt;for (i &amp;lt;- 0 to 10 reverse) { // 逆序&lt;br/&gt;println(&quot;i=&quot; + i)&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;// 定义一个 List 集合&lt;br/&gt;val list = List(1, 2, 3)&lt;br/&gt;println(list) // List(1, 2, 3)&lt;br/&gt;println(list.reverse) // List(3, 2, 1)&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;4、编写一个过程 countdown(n:Int)，打印从 n 到 0 的数字。&lt;br/&gt;示例代码如下：&lt;/p&gt;
&lt;pre readability=&quot;16&quot;&gt;
&lt;code class=&quot;scala language-scala&quot; readability=&quot;26&quot;&gt;package com.atguigu.chapter06.exercises&lt;p&gt;import scala.io.StdIn&lt;/p&gt;&lt;p&gt;/**&lt;br/&gt;* 4、编写一个过程 countdown(n:Int)，打印从 n 到 0 的数字。&lt;br/&gt;*/&lt;br/&gt;object Exercise04 {&lt;br/&gt;def main(args: Array[String]): Unit = {&lt;/p&gt;&lt;p&gt;val m=3&lt;br/&gt;val res1 = (0 to m).reverse&lt;br/&gt;println(res1) // Range(3, 2, 1, 0)&lt;/p&gt;&lt;p&gt;// foreach&lt;br/&gt;// foreach 函数可以接收 (f: Int =&amp;gt; U)，即接收一个输入参数为 Int，输出参数为 Unit 的函数&lt;br/&gt;// 下面这句代码的含义是：&lt;br/&gt;// 1、将 res1 的每个元素依次遍历出来，传递给 println(x)&lt;br/&gt;// 调用系统的 println 函数&lt;br/&gt;res1.foreach(println)&lt;/p&gt;&lt;p&gt;// 调用自定义的 println 函数&lt;br/&gt;res1.foreach(myPrintln)&lt;/p&gt;&lt;p&gt;println(&quot;----------&quot;)&lt;br/&gt;println(&quot;请输入一个数字：&quot;)&lt;br/&gt;val n = StdIn.readInt()&lt;br/&gt;println(&quot;----------&quot;)&lt;br/&gt;countdown(n)&lt;br/&gt;println(&quot;----------&quot;)&lt;br/&gt;countdown2(n)&lt;br/&gt;println(&quot;----------&quot;)&lt;br/&gt;countdown3(n)&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;// 自定义一个 println 函数&lt;br/&gt;def myPrintln(n:Int):Unit = {&lt;br/&gt;println(n)&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;// 方式一：&lt;br/&gt;def countdown(n: Int): Unit = {&lt;br/&gt;for (i &amp;lt;- 0 to n) {&lt;br/&gt;println(n-i)&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;// 方式二：&lt;br/&gt;def countdown2(n: Int): Unit = {&lt;br/&gt;for (i &amp;lt;- 0 to n reverse) {&lt;br/&gt;println(i)&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;// 方式三：&lt;br/&gt;def countdown3(n: Int): Unit = {&lt;br/&gt;// 说明&lt;br/&gt;// 这里使用到高阶函数的特性&lt;br/&gt;(0 to n).reverse.foreach(println)&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;5、编写一个 for 循环，计算字符串中所有字母的 Unicode 代码（toLong 方法）的乘积。举例来说，&quot;Hello&quot; 中所有字符串的乘积为 9415087488L。&lt;br/&gt;示例代码如下：&lt;/p&gt;
&lt;pre readability=&quot;8.5&quot;&gt;
&lt;code class=&quot;scala language-scala&quot; readability=&quot;11&quot;&gt;package com.atguigu.chapter06.exercises&lt;p&gt;import scala.io.StdIn&lt;/p&gt;&lt;p&gt;/**&lt;br/&gt;* 5、编写一个 for 循环，计算字符串中所有字母的 Unicode 代码（toLong 方法）的乘积。举例来说，&quot;Hello&quot; 中所有字符串的乘积为 9415087488L。&lt;br/&gt;*/&lt;br/&gt;object Exercise05 {&lt;br/&gt;def main(args: Array[String]): Unit = {&lt;br/&gt;println(&quot;请输入一行字符串：&quot;)&lt;br/&gt;val str = StdIn.readLine()&lt;br/&gt;println(&quot;该字符串中所有字母的 Unicode 代码的乘积为：&quot; + unicode(str))&lt;/p&gt;&lt;p&gt;unicode2()&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;// 方式一：&lt;br/&gt;def unicode(str: String): Long = {&lt;br/&gt;var res:Long = 1&lt;br/&gt;for (i &amp;lt;- 0 to str.length - 1) { // 索引从0开始&lt;br/&gt;var s = str.charAt(i).toLong&lt;br/&gt;res *= s&lt;br/&gt;}&lt;br/&gt;res&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;// 方式二：&lt;br/&gt;def unicode2() = {&lt;br/&gt;var res:Long = 1&lt;br/&gt;for (i &amp;lt;- &quot;Hello&quot;) {&lt;br/&gt;res *= i.toLong&lt;br/&gt;}&lt;br/&gt;println(&quot;res=&quot; + res)&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs makefile&quot;&gt;请输入一行字符串：&lt;br/&gt;Hello&lt;br/&gt;该字符串中所有字母的 Unicode 代码的乘积为：9415087488&lt;br/&gt;res=9415087488&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;6、同样是解决前一个练习的问题，请用 StringOps 的 foreach 方式解决。&lt;br/&gt;示例代码如下：&lt;/p&gt;
&lt;pre readability=&quot;7&quot;&gt;
&lt;code class=&quot;scala language-scala&quot; readability=&quot;8&quot;&gt;package com.atguigu.chapter06.exercises&lt;p&gt;import scala.io.StdIn&lt;/p&gt;&lt;p&gt;/**&lt;br/&gt;* 6、同样是解决前一个练习的问题，请用 StringOps 的 foreach 方式解决。&lt;br/&gt;*/&lt;br/&gt;object Exercise06 {&lt;br/&gt;def main(args: Array[String]): Unit = {&lt;br/&gt;var res1: Long = 1&lt;br/&gt;// 说明&lt;br/&gt;// 方式一：&lt;br/&gt;// &quot;Hello&quot;.foreach((_) =&amp;gt; {res *= _.toLong})&lt;br/&gt;&quot;Hello&quot;.foreach(res1 *= _.toLong)&lt;br/&gt;println(&quot;res1=&quot; + res1)&lt;/p&gt;&lt;p&gt;// 方式二：&lt;br/&gt;var res2 = 1L&lt;br/&gt;&quot;Hello&quot;.foreach(myCount)&lt;br/&gt;println(&quot;res1=&quot; + res2)&lt;br/&gt;def myCount(char: Char): Unit = {&lt;br/&gt;res2 *= char.toLong&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs ini&quot;&gt;&lt;span class=&quot;hljs-attr&quot;&gt;res1&lt;/span&gt;=&lt;span class=&quot;hljs-number&quot;&gt;9415087488&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;res1&lt;/span&gt;=&lt;span class=&quot;hljs-number&quot;&gt;9415087488&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;7、编写一个函数 product(str: String)，计算字符串中所有字母的 Unicode 代码（toLong 方法）的乘积。&lt;br/&gt;示例代码如下：&lt;/p&gt;
&lt;pre readability=&quot;8.5&quot;&gt;
&lt;code class=&quot;scala language-scala&quot; readability=&quot;11&quot;&gt;package com.atguigu.chapter06.exercises&lt;p&gt;import scala.io.StdIn&lt;/p&gt;&lt;p&gt;/**&lt;br/&gt;* 7、编写一个函数 product(str: String)，计算字符串中所有字母的 Unicode 代码（toLong 方法）的乘积。&lt;br/&gt;*/&lt;br/&gt;object Exercise07 {&lt;br/&gt;def main(args: Array[String]): Unit = {&lt;br/&gt;println(&quot;请输入一行字符串：&quot;)&lt;br/&gt;val str = StdIn.readLine()&lt;br/&gt;println(&quot;该字符串中所有字母的 Unicode 代码的乘积为：&quot; + product1(str))&lt;br/&gt;println(&quot;该字符串中所有字母的 Unicode 代码的乘积为：&quot; + product2(str))&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;// 方式一：&lt;br/&gt;def product1(str: String): Long = {&lt;br/&gt;var multi = 1L&lt;br/&gt;for (i &amp;lt;- 0 to str.length - 1) { // 索引从0开始&lt;br/&gt;var s = str.charAt(i).toLong&lt;br/&gt;multi *= s&lt;br/&gt;}&lt;br/&gt;multi&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;// 方式二：&lt;br/&gt;def product2(str: String): Long = {&lt;br/&gt;var multi = 1L&lt;br/&gt;for (i &amp;lt;- str) {&lt;br/&gt;multi *= i.toLong&lt;br/&gt;}&lt;br/&gt;multi&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs vbnet&quot;&gt;请输入一行字符串：&lt;br/&gt;Hello&lt;br/&gt;该字符串中所有字母的 &lt;span class=&quot;hljs-keyword&quot;&gt;Unicode&lt;/span&gt; 代码的乘积为：&lt;span class=&quot;hljs-number&quot;&gt;9415087488&lt;/span&gt;&lt;br/&gt;该字符串中所有字母的 &lt;span class=&quot;hljs-keyword&quot;&gt;Unicode&lt;/span&gt; 代码的乘积为：&lt;span class=&quot;hljs-number&quot;&gt;9415087488&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;8、把7练习中的函数改成递归函数。&lt;br/&gt;示例代码如下：&lt;/p&gt;
&lt;pre readability=&quot;7.5&quot;&gt;
&lt;code class=&quot;scala language-scala&quot; readability=&quot;9&quot;&gt;package com.atguigu.chapter06.exercises&lt;p&gt;/**&lt;br/&gt;* 8、把7练习中的函数改成递归函数。&lt;br/&gt;*/&lt;br/&gt;object Exercise08 {&lt;br/&gt;def main(args: Array[String]): Unit = {&lt;br/&gt;println(&quot;res=&quot; + product(&quot;Hello&quot;)) // res=9415087488&lt;/p&gt;&lt;p&gt;println(&quot;Hello&quot;.take(1)) // H     获取的是该字符串的第一个字符串&lt;br/&gt;println(&quot;Hello&quot;.drop(1)) // ello  获取的是该字符串的除第一个字符串之外的剩余字符串&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;def product(str: String): Long = {&lt;br/&gt;if (str.length == 1) return str.charAt(0).toLong&lt;br/&gt;else str.take(1).charAt(0).toLong * product(str.drop(1))&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs makefile&quot;&gt;res=9415087488&lt;br/&gt;H&lt;br/&gt;ello&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;9、编写函数计算，其中 n 是整数，使用如下的递归定义：&lt;/strong&gt;&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/26/Aa9oXq.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;示例代码如下：
&lt;pre readability=&quot;8&quot;&gt;
&lt;code class=&quot;scala language-scala&quot; readability=&quot;10&quot;&gt;package com.atguigu.chapter06.exercises&lt;p&gt;/**&lt;br/&gt;* 9、编写函数计算，其中 n 是整数，使用如下的递归定义：&lt;br/&gt;*/&lt;br/&gt;object Exercise09 {&lt;br/&gt;def main(args: Array[String]): Unit = {&lt;br/&gt;println(mi(2.5, 3))&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;// 递归的妙用：求 x 的 n 次方，厉害啊！！！&lt;br/&gt;def mi(x: Double, n: Int): Double = {&lt;br/&gt;if (n == 0) 1   // x 的 0 次方等于 1&lt;br/&gt;else if (n &amp;gt; 0) x * mi(x, n - 1)&lt;br/&gt;else 1 / mi(x, -n)&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意：本题可以用于好好理解“递归”的妙用！！！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Java 与 Scala 在函数层面上的不同体现：&lt;br/&gt;// 在 Java 中&lt;br/&gt;函数(接收参数)&lt;/p&gt;
&lt;p&gt;// 在 Scala 中&lt;br/&gt;集合.函数(函数)&lt;/p&gt;
&lt;p&gt;如下图所示：&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/26/Aa9Icn.png&quot; alt=&quot;&quot;/&gt;</description>
<pubDate>Tue, 26 Mar 2019 15:58:00 +0000</pubDate>
<dc:creator>黑泽君</dc:creator>
<og:description>第五章 函数式编程-基础5.1 函数式编程内容说明5.1.1 函数式编程内容5.1.2 函数式编程授课顺序5.2 函数式编程介绍5.2.1 几个概念的说明5.2.2 方法、函数、函数式编程和面向对象编</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenmingjun/p/10604813.html</dc:identifier>
</item>
<item>
<title>js数组乱序输出 数组乱序排列 - 怒其不争1</title>
<link>http://www.cnblogs.com/Mir-bink/p/10604747.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Mir-bink/p/10604747.html</guid>
<description>&lt;p&gt;&lt;span&gt;网上看的数组乱序输出，要么不合实际，要么代码繁琐。自己试了下，希望能给大家带来帮助。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;重要思想也是Math.random*arr.length随机下标，然后删除取到的元素，继续随机下标。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将数组乱序输出&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; arr = [1,2,3,4,5,6,7,8,9,10&lt;span&gt;];
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; newArr =&lt;span&gt; [];
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i=0; i&amp;lt;arr.length; i++&lt;span&gt;){
                 &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; index = Math.floor(Math.random()*arr.length);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;随机下标&lt;/span&gt;
                     newArr.push(arr[index]);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将随机出的元素，存放新数组newArr中去&lt;/span&gt;
                     arr.splice(index,1);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    将随机出的元素在arr中删除            &lt;/span&gt;
&lt;span&gt;            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;arr中删除随机出的元素,arr.length-1,同时i++,导致循环不会10次,会是5次.最后得到newArr中只有一半的随机数字,arr中剩下另一半. 将其合并到一起,得到res&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; res =&lt;span&gt;[...newArr,...arr];
            console.log(res)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;结果如下：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1581103/201903/1581103-20190326232504975-238289851.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;随后也有个问题，这个其实只随机了一半的数字，后一半没有随机，只是合并了上去。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;改进后：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; arr = [1,2,3,4,5,6,7,8,9,10&lt;span&gt;];
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; newArr =&lt;span&gt; [];
        var len &lt;/span&gt;=&lt;span&gt; arr.length;
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i=0; i&amp;lt;len; i++&lt;span&gt;){
                 &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; index = Math.floor(Math.random()*arr.length);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;随机下标&lt;/span&gt;
                     newArr.push(arr[index]);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将随机出的元素，存放新数组newArr中去&lt;/span&gt;
                     arr.splice(index,1);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    将随机出的元素在arr中删除            &lt;/span&gt;
&lt;span&gt;            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;arr中删除随机出的元素,arr.length-1,同时i++,导致循环不会10次,会是5次.最后得到newArr中只有一半的随机数字,arr中剩下另一半. 将其合并到一起,得到res&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; res =&lt;span&gt;[...newArr,...arr];
            console.log(res) &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;把len当成，作为循环条件，最后所有的都是随机的，结果如下：&lt;img src=&quot;https://img2018.cnblogs.com/blog/1581103/201903/1581103-20190326233902400-1332984222.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 26 Mar 2019 15:41:00 +0000</pubDate>
<dc:creator>怒其不争1</dc:creator>
<og:description>js数组乱序输出，数组乱序排列</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Mir-bink/p/10604747.html</dc:identifier>
</item>
<item>
<title>【RAY TRACING THE REST OF YOUR LIFE 超详解】 光线追踪 3-7 混合概率密度 - 林-兮</title>
<link>http://www.cnblogs.com/lv-anchoret/p/10604712.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lv-anchoret/p/10604712.html</guid>
<description>&lt;p&gt;&lt;span class=&quot;tlid-translation translation&quot; lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;&quot;&gt;但是评估pdf_mixture会稍微有点微妙。 &lt;span title=&quot;&quot;&gt;我们需要同时评估pdf_reflection和pdf_light，因为有一些方向可以生成pdf方向。 &lt;span title=&quot;&quot;&gt;例如，我们可以使用pdf_reflection生成朝向光的方向&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;tlid-translation translation&quot; lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;&quot;&gt;&lt;span title=&quot;&quot;&gt;&lt;span title=&quot;&quot;&gt;如果我们回顾之前的内容，你会发现，这一部分主要解决两个问题：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;tlid-translation translation&quot; lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;&quot;&gt;&lt;span title=&quot;&quot;&gt;&lt;span title=&quot;&quot;&gt;我们抽象出这些操作之后，就可以写一个关于我们的pdf的一个基类：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;div readability=&quot;107.83914608415&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;///&lt;/span&gt;&lt;span&gt;pdf.hpp&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt; -----------------------------------------------------
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; [author]        lv
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; [ time ]        2019.3
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; [brief ]        In the Monte Carlo system, pdf acts as the
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                most important element of Important-Sample
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; -----------------------------------------------------&lt;/span&gt;


&lt;span&gt;#pragma&lt;/span&gt; once


&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; rt
{

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; the basic class of pdf system&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; pdf
    {
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
    @brief: we get the value of pdf function by this interface
    @param: the direction of location
    @retur: the value of the pdf function
    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;virtual&lt;/span&gt; rtvar value(&lt;span&gt;const&lt;/span&gt; rtvec &amp;amp; direction)&lt;span&gt;const&lt;/span&gt; = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
    @brief: generate a random number with a Probability model
    @param: none
    @retur: the Three-dimensional random vector
    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;virtual&lt;/span&gt; rtvec generate()&lt;span&gt;const&lt;/span&gt; = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    };


}&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;rt namespace&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;我们来实现关于它的一些子类&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先我们来实现关于cosine 概率密度的模型&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;///&lt;/span&gt;&lt;span&gt;cosine_pdf.hpp&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt; -----------------------------------------------------
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; [author]        lv
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; [ time ]        2019.3
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; [brief ]        one of the pdf' forms
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; -----------------------------------------------------&lt;/span&gt;


&lt;span&gt;#pragma&lt;/span&gt; once


&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; rt
{

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; cosine_pdf :&lt;span&gt;public&lt;/span&gt;&lt;span&gt; pdf
    {
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;constructor&lt;/span&gt;
    cosine_pdf(&lt;span&gt;const&lt;/span&gt; rtvec&amp;amp;&lt;span&gt; w);            

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
    @brief: we get the value of pdf function by this interface
    @param:    the direction of location
    @retur: the value of the pdf function
    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;virtual&lt;/span&gt; rtvar value(&lt;span&gt;const&lt;/span&gt; rtvec&amp;amp; direction)&lt;span&gt;const&lt;/span&gt;&lt;span&gt;;


    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
    @brief: generate a random number with a Probability model
    @param: none
    @retur:    the Three-dimensional random vector
    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;virtual&lt;/span&gt; rtvec generate()&lt;span&gt;const&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt;:

    onb _uvw;
    };

inline cosine_pdf::cosine_pdf(&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; rtvec&amp;amp;&lt;span&gt; w)
    {
    _uvw.build_from_w(w);
    }

rtvar cosine_pdf::value(&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; rtvec&amp;amp; direction)&lt;span&gt;const&lt;/span&gt;&lt;span&gt;
    {
    rtvar cosine &lt;/span&gt;=&lt;span&gt; dot(direction.ret_unitization(), _uvw.w());
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (cosine &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;.)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; cosine /&lt;span&gt; π;
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;.;
    }

rtvec cosine_pdf::generate()&lt;/span&gt;&lt;span&gt;const&lt;/span&gt;&lt;span&gt;
    {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; _uvw.local(random_cosine_direction());
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这个模型之前细说过，cosine大于0的时候返回cosine/π，反之，则返回0。因为光线反射之后如果和表面法线的夹角为钝角的时候，违反反射规律，不以反射。生成随机数的那个之前也讲过，在&lt;a href=&quot;https://www.cnblogs.com/lv-anchoret/p/10518961.html&quot; target=&quot;_blank&quot;&gt;上上一篇&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其实这些都不是新东西，就是把之前讲的的那一套整合了一下&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;得到结果也就是之前的效果&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们把主函数里面的lerp（）也改一下&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1316111/201903/1316111-20190326194923111-837358898.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;每个像素点采样100次，取均值，即sample 为 100时&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1316111/201903/1316111-20190326202956020-1725014225.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; 这是代码敲错了，意外得到的一张图&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1316111/201903/1316111-20190326195417442-15109798.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; 现在我们尝试，光源采样，即&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;///&lt;/span&gt;&lt;span&gt;hit_pdf.hpp&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt; -----------------------------------------------------
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; [author]        lv
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; [ time ]        2019.3
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; [brief ]        toward to the hitable
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; -----------------------------------------------------&lt;/span&gt;

&lt;span&gt;#pragma&lt;/span&gt; once


&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; rt
{

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; hit_pdf :&lt;span&gt;public&lt;/span&gt;&lt;span&gt; pdf
    {
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
    @param: info -&amp;gt; Geometry information
            origion -&amp;gt; the point of intersection
    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    hit_pdf(intersect&lt;/span&gt;* info, &lt;span&gt;const&lt;/span&gt; rtvec&amp;amp;&lt;span&gt; origion)
        :_intersectp(info)
        ,_o(origion)
    {
    }


    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
    @brief: we get the value of pdf function by this interface
    @param:    the direction of location
    @retur: the value of the pdf function
    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;virtual&lt;/span&gt; rtvar value(&lt;span&gt;const&lt;/span&gt; rtvec&amp;amp; direction)&lt;span&gt;const&lt;/span&gt;&lt;span&gt;
        {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; _intersectp-&amp;gt;&lt;span&gt;pdf_value(_o, direction);
        }
    

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
    @brief: generate a random number with a Probability model
    @param: none
    @retur:    the Three-dimensional random vector
    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;virtual&lt;/span&gt; rtvec generate()&lt;span&gt;const&lt;/span&gt;&lt;span&gt;
        {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; _intersectp-&amp;gt;&lt;span&gt;random(_o);
        }

&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt;:
        
    rtvec _o;

    intersect &lt;/span&gt;*&lt;span&gt; _intersectp;
    };

}&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; rt namespace&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;对应的intersect类也要改一下&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;///&lt;/span&gt;&lt;span&gt; intersect.hpp&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;https://www.cnblogs.com/lv-anchoret/p/10190092.html&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; -----------------------------------------------------
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; [author]        lv
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; [begin ]        2018.12
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; [refre ]        2019.3
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; [brief ]        the intersect-class for the ray-tracing project
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                from the 《ray tracing in one week》
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; -----------------------------------------------------&lt;/span&gt;

&lt;span&gt;#pragma&lt;/span&gt; once&lt;span&gt;

#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;E:\OpenGL\光线追踪\code\ray tracing 1-3\ray tracing 1-3\ray.hpp&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;


&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; rt
{
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; material;
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; aabb;


&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; the infomation of intersection point&lt;/span&gt;

&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; hitInfo
    {
    lvgm::precision _t;        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ray 中的系数t&lt;/span&gt;
    rtvec _p;                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;相交点、撞击点&lt;/span&gt;
    rtvec _n;                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;_p点的表面法线&lt;/span&gt;
    material* _materialp;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;材质&lt;/span&gt;
    rtvar _u;                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;texture-u&lt;/span&gt;
    rtvar _v;                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;texture-v&lt;/span&gt;
&lt;span&gt;    };


&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; the statement of intersect class&lt;/span&gt;

&lt;span&gt;class&lt;/span&gt;&lt;span&gt; intersect
    {
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
    @brief: 撞击函数，求取撞击点相关记录信息
    @param: sight-&amp;gt;视线
    系数t的上下界-&amp;gt;筛选撞击点
    info-&amp;gt;返回撞击点信息
    @retur: 是否存在合法撞击点
    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; hit(&lt;span&gt;const&lt;/span&gt; ray&amp;amp; sight, rtvar t_min, rtvar t_max, hitInfo&amp;amp; info)&lt;span&gt;const&lt;/span&gt; = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
    @brief: get the box of Geometry
    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;virtual&lt;/span&gt; aabb getbox()&lt;span&gt;const&lt;/span&gt; = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
    Get the value of pdf function
    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;virtual&lt;/span&gt; rtvar pdf_value(&lt;span&gt;const&lt;/span&gt; rtvec&amp;amp; o, &lt;span&gt;const&lt;/span&gt; rtvec&amp;amp; v)&lt;span&gt;const&lt;/span&gt;&lt;span&gt;
        {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;.;
        }

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
    generate the random number
    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;virtual&lt;/span&gt; rtvec random(&lt;span&gt;const&lt;/span&gt; rtvec&amp;amp; o)&lt;span&gt;const&lt;/span&gt;&lt;span&gt;
        {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; rtvec(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
        }


    };

}&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; rt namespace&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;因为我们现在只是拿区域光源做实验，并不是所有的几何体派生类都要继承pdf相关的方法，所以，它们两个以虚函数的形式存在即可。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那么就剩下xz长方形了&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
rtvar xz_rect::pdf_value(&lt;span&gt;const&lt;/span&gt; rtvec&amp;amp; o, &lt;span&gt;const&lt;/span&gt; rtvec&amp;amp; v)&lt;span&gt;const&lt;/span&gt;&lt;span&gt;
    {
    hitInfo rec;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;-&amp;gt;hit(ray(o, v), 1e-&lt;span&gt;3&lt;/span&gt;&lt;span&gt;, rt::rtInf(), rec))
        {
        rtvar area &lt;/span&gt;= (_x2 - _x1)*(_z2 -&lt;span&gt; _z1);
        rtvar distance_squared &lt;/span&gt;= rec._t * rec._t *&lt;span&gt; v.squar();
        rtvar cosine &lt;/span&gt;= fabs(dot(v, rec._n) /&lt;span&gt; v.normal());
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; distance_squared / (cosine*&lt;span&gt;area);
        }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;.;
    }

rtvec xz_rect::random(&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; rtvec&amp;amp; o)&lt;span&gt;const&lt;/span&gt;&lt;span&gt;
    {
    rtvec random_point &lt;/span&gt;= rtvec(_x1 + lvgm::rand01() * (_x2 - _x1), _other, _z1 + lvgm::rand01()*(_z2 -&lt;span&gt; _z1));
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; random_point -&lt;span&gt; o;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt; 把上一篇写在lerp函数里面的一大堆东西整合到类里面&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那么我们的lerp就统一化了：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1316111/201903/1316111-20190326203808111-1087094476.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们取sample为10，即可得到很好的效果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1316111/201903/1316111-20190326220956704-545685690.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;现在我们将写一个关于混合概率密度的类：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;///&lt;/span&gt;&lt;span&gt;mixture_pdf.hpp&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt; -----------------------------------------------------
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; [author]        lv
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; [ time ]        2019.3
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; [brief ]        mixture pdfs
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; -----------------------------------------------------&lt;/span&gt;


&lt;span&gt;#pragma&lt;/span&gt; once


&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; rt
{

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; mixture_pdf :&lt;span&gt;public&lt;/span&gt;&lt;span&gt; pdf
    {
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:

    mixture_pdf(pdf &lt;/span&gt;* p1, pdf*&lt;span&gt; p2)
        {
        _p[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;] =&lt;span&gt; p1;
        _p[1&lt;/span&gt;] =&lt;span&gt; p2;
        }


    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
    @brief: we get the value of pdf function by this interface
    @param:    the direction of location
    @retur: the value of the pdf function
    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;virtual&lt;/span&gt; rtvar value(&lt;span&gt;const&lt;/span&gt; rtvec&amp;amp; direction)&lt;span&gt;const&lt;/span&gt;&lt;span&gt;
        {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0.5&lt;/span&gt;*_p[&lt;span&gt;0&lt;/span&gt;]-&amp;gt;value(direction) + &lt;span&gt;0.5&lt;/span&gt;*_p[&lt;span&gt;1&lt;/span&gt;]-&amp;gt;&lt;span&gt;value(direction);
        }


    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
    @brief: generate a random number with a Probability model
    @param: none
    @retur:    the Three-dimensional random vector
    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;virtual&lt;/span&gt; rtvec generate()&lt;span&gt;const&lt;/span&gt;&lt;span&gt;
        {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (lvgm::rand01() &amp;lt; &lt;span&gt;0.5&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; _p[&lt;span&gt;0&lt;/span&gt;]-&amp;gt;&lt;span&gt;generate();
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; _p[&lt;span&gt;1&lt;/span&gt;]-&amp;gt;&lt;span&gt;generate();
        }

&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt;:

    pdf&lt;/span&gt;* _p[&lt;span&gt;2&lt;/span&gt;&lt;span&gt;];

    };


}&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; rt namespace&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;我们的lerp函数如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1316111/201903/1316111-20190326221826365-713567498.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;我们采样10次得到：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1316111/201903/1316111-20190326223552664-1653431163.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是觉得效果不是很理想，我们来做一些测试&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;1. pdf 方程修改为 mixture_pdf = 1/3 * hit_pdf + 2/3  * cosine_pdf&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1316111/201903/1316111-20190326223943779-1325076970.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;2. pdf 方程修改为 mixture_pdf = 2/3 * hit_pdf + 1/3  * cosine_pdf&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1316111/201903/1316111-20190326224334596-1698922572.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;3. random修改  2/3 取 hit_pdf产生的随机值， 1/3 取 cosine_pdf 产生的随机值&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1316111/201903/1316111-20190326224719726-1918203670.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;4. random修改  1/3 取 hit_pdf产生的随机值， 2/3 取 cosine_pdf 产生的随机值&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1316111/201903/1316111-20190326225240806-1289391468.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;我们去上述方案的3、1，即：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1316111/201903/1316111-20190326230101125-119281067.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;得到图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1316111/201903/1316111-20190326230133856-581228878.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这张图显然比均分的效果要好&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;这里我们看不出到底是random起作用还是value，我们不妨取2、3组合&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1316111/201903/1316111-20190326230436398-493314455.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3把2的彩色噪声消除了些，但是这张图和原始的均分图差不多一样&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以结论，random和value的比例交叉比较好&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;我们采样1000次得到：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 渲染中。。。。（就是清晰了点）&lt;/p&gt;

&lt;p&gt;&lt;span&gt;本书第九章（下一章）介绍了一些关于当前渲染器的看法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;作者在描述阴影光线和混合密度设计时，作者个人更偏向于混合密度设计，所以并没有在渲染器中采用阴影光线&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;作者描述了关于lerp函数中内存问题以及编码的不足&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;作者描述了关于玻璃材质和镜面的一些处理方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;作者还描述了关于HDR的0~1浮点表示以及RGB分组的0~255表示，还说明了这个渲染器是RGB的且基于物理的，还有一种是基于光谱的，以及两者结合的，但做起来很难，所以我们坚持RGB且基于物理的渲染器。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1316111/201903/1316111-20190326232130050-858795909.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1316111/201903/1316111-20190326232244201-723306021.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; 感谢您的阅读，生活愉快~&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Tue, 26 Mar 2019 15:35:00 +0000</pubDate>
<dc:creator>林-兮</dc:creator>
<og:description>Mixture Densities</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lv-anchoret/p/10604712.html</dc:identifier>
</item>
<item>
<title>node 调试相关 - 刘哇勇</title>
<link>http://www.cnblogs.com/Wayou/p/node_debug.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Wayou/p/node_debug.html</guid>
<description>&lt;h2&gt;#0 node 正确的书写方式&lt;/h2&gt;
&lt;p&gt;为了防止后面出现混乱的各种书写，先来了解一下如何正确书写 node 的名称。&lt;/p&gt;
&lt;p&gt;下面使用来自&lt;a href=&quot;https://twitter.com/bitandbang/status/1087359646367731719&quot; rel=&quot;nofollow&quot;&gt;@bitandbang 推文&lt;/a&gt;中的图片展示如何正确书写 node 名称。&lt;/p&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;https://raw.githubusercontent.com/wayou/wayou.github.io/master/posts/nodejs-debug/assets/node_the_right_way.jpg&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/wayou/wayou.github.io/master/posts/nodejs-debug/assets/node_the_right_way.jpg&quot; alt=&quot;node 名称的正确书写方式&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&lt;em&gt;node 名称的正确书写方式&lt;/em&gt;&lt;/p&gt;
&lt;h3&gt;&lt;code&gt;--inspect&lt;/code&gt; 参数&lt;/h3&gt;
&lt;p&gt;本地开发，无论是 web 应用还是命令行工具，使用 &lt;code&gt;--inspect-brk&lt;/code&gt; 参数启动程序，然后结合 Chrome DevTools 调试恐怕能满足大多数场景了。&lt;/p&gt;
&lt;p&gt;具体步骤：&lt;/p&gt;
&lt;p&gt;通过 &lt;code&gt;--inspect-brk&lt;/code&gt; 参数启动程序，会进入调试模式。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
$ &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;node --inspect-brk index.js&lt;span class=&quot;pl-pds&quot;&gt;`&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里使用 &lt;code&gt;--inspect-brk&lt;/code&gt; 而非 &lt;code&gt;--inspect&lt;/code&gt; 可保证代码第一时间断在开程序开头。如果使用后者，有可能无法进行后续操作。&lt;/p&gt;
&lt;p&gt;打开 Chrome 新开标签页访问 &lt;code&gt;chrome://inspect&lt;/code&gt;。不出意外会看到刚刚创建的一个调试实例，直接点击 &lt;code&gt;inspect&lt;/code&gt; 即可启动调试。因为是 &lt;code&gt;--inspect-brk&lt;/code&gt; 启动的，调试界面打开后会断在程序开头。后面在哪里加断点就有很大自主权了。&lt;/p&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;https://raw.githubusercontent.com/wayou/wayou.github.io/master/posts/nodejs-debug/assets/chrome_inspect_panel.png&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/wayou/wayou.github.io/master/posts/nodejs-debug/assets/chrome_inspect_panel.png&quot; alt=&quot;chrome://inspect 界面&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&lt;em&gt;&lt;code&gt;chrome://inspect&lt;/code&gt; 界面&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;需要注意的是，因为此时断在了程序开始，程序中其他文件可能没加载。所以无法看到。这种情况下，可事先在需要加断点的地方写上 &lt;code&gt;debugger&lt;/code&gt;。&lt;/p&gt;
&lt;h3&gt;子进程中代码的调试&lt;/h3&gt;
&lt;p&gt;另一个需要注意的地方就是子进程。对于 &lt;strong&gt;子进程&lt;/strong&gt; 中的代码，是无法断点的，这是调试大多数框架及复杂程序时的痛点。&lt;/p&gt;
&lt;p&gt;一个简单的子进程示例：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;index.js&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; cp &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;child_process&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;);
&lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; child &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;cp&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;fork&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;./child&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;);

&lt;span class=&quot;pl-smi&quot;&gt;child&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;on&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;message&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;m&lt;/span&gt;) {
  &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;received: &lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;+&lt;/span&gt; m);
});

&lt;span class=&quot;pl-smi&quot;&gt;child&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;send&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;Please up-case this string&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;child.js&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-c1&quot;&gt;process&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;on&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;message&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;m&lt;/span&gt;) {
  &lt;span class=&quot;pl-k&quot;&gt;debugger&lt;/span&gt;;
  &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; Do work  (in this case just up-case the string&lt;/span&gt;
  m &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;m&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;toUpperCase&lt;/span&gt;();

  &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;//&lt;/span&gt; Pass results back to parent process&lt;/span&gt;
  &lt;span class=&quot;pl-c1&quot;&gt;process&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;send&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;m&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;toUpperCase&lt;/span&gt;(m));
});
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里，&lt;code&gt;node --inspect-brk index.js&lt;/code&gt; 启动调试后，&lt;code&gt;child.js&lt;/code&gt; 中的 &lt;code&gt;debugger&lt;/code&gt; 并不会生效，因为它的代码在子进程中。&lt;/p&gt;
&lt;p&gt;这也就是为什么，当你想调试 webpack 编译，恰好又用了类似 &lt;a href=&quot;https://github.com/amireh/happypack&quot;&gt;happypack&lt;/a&gt; 这种多进程加速编译的工具时，发现 loader 及 插件中无法断点的原因。&lt;/p&gt;
&lt;p&gt;又比如，调试 eggjs，它也是多进程的模型，业务代码是运行在 worker 进程中的，直接通过 node 的调试参数肯定是不行的。当然框架一般会有自身配套的调试方案，你可以安装 egg 的 vscode 调试插件，或者使用 egg-scripts 来启动调试。&lt;/p&gt;
&lt;p&gt;那是不是就无能为力了？当然不是，只是需要费劲一点。我们需要找到开启子进程的地方，在开启的时候加上调试参数。&lt;/p&gt;
&lt;p&gt;还是上面的示例，改造主文件为如下：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-diff&quot; readability=&quot;12&quot;&gt;
&lt;pre&gt;
var cp = require('child_process');
&lt;span class=&quot;pl-mi1&quot;&gt;&lt;span class=&quot;pl-mi1&quot;&gt;+&lt;/span&gt;var child = cp.fork('./child',[],{execArgv:['--inspect-brk']});&lt;/span&gt;

child.on('message', function(m) {
  console.log('received: ' + m);
});

child.send('Please up-case this string');
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样，就表示以调试模式来运行子进程中的代码，此时启动程序不要加 &lt;code&gt;inspect&lt;/code&gt;，因为那是开启对主进程的调试，直接运行程序即可。&lt;code&gt;node index.js&lt;/code&gt;。然后我们会在 &lt;code&gt;Chrome://inspect&lt;/code&gt; 看到子进程已经 attach 到了调试界面。&lt;/p&gt;
&lt;p&gt;所以，无论是通过 &lt;code&gt;require('child_process'&lt;/code&gt; 的 &lt;code&gt;exec&lt;/code&gt; 还是 &lt;code&gt;spawn&lt;/code&gt;，只需要找到开启子进程的地方，加上调试参数。&lt;/p&gt;
&lt;p&gt;但问题是，就看你能不能正确地找到所使用的框架工具他们开启子进程的地方。&lt;/p&gt;
&lt;h3&gt;善用 npx&lt;/h3&gt;
&lt;p&gt;调试 node 模块时，特别是 npm 包，你需要手动拼出该模块的入口文件的路径，类似 &lt;code&gt;node —inspect node_modules/webpack/bin/webpack.js&lt;/code&gt;, 但通过 &lt;code&gt;npx&lt;/code&gt; 则不用，因为 npx 会自动在项目的 &lt;code&gt;node_modules&lt;/code&gt; 或系统全局中寻找模块的入口文件，甚至如果本机没有安装，它还会自动搜索 registry 自动安装后执行。&lt;/p&gt;
&lt;p&gt;以至于你在初始化一个项目时，可使用如下命令：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
$ npx license mit &lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt; LICENSE
$ npx gitignore node
$ npx covgen YOUR_EMAIL_ADDRESS
$ npm init -y
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;即使你本地并没有安装 &lt;code&gt;mit&lt;/code&gt;，&lt;code&gt;gitignore&lt;/code&gt;，&lt;code&gt;covgen&lt;/code&gt; 等 npm 包。&lt;/p&gt;
&lt;p&gt;使用 npx 时可通过 &lt;code&gt;—node-arg&lt;/code&gt; 来传递参数给 node。因为本质上 npx 也是执行 js 文件，与直接使用 &lt;code&gt;node&lt;/code&gt; 命令来启动文件没什么差异。&lt;code&gt;—node-arg&lt;/code&gt; 指定的参数会透传给 node，所以，可以这样来启动一个 npm 包的调试：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
$ npx —node-arg=—inspect-brk webpack
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;node 内建的 debugger&lt;/h3&gt;
&lt;p&gt;node 自带的 v8 调试工具，是个命令行工具。操作起来是难用，但在远端服务器上这种不能使用 Chrome Devtools 进行可视化调试的场景下，就显得很有用了，比如调试路由重定向次数过多这种瞬间发生的问题，它能将代码及时在服务器上断下来，让我们慢慢分析现场。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot;&gt;
&lt;pre&gt;
$ node inspect index.js
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;https://raw.githubusercontent.com/wayou/wayou.github.io/master/posts/nodejs-debug/assets/node_builtin_debugger.png&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/wayou/wayou.github.io/master/posts/nodejs-debug/assets/node_builtin_debugger.png&quot; alt=&quot;node 自带的 debugger&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&lt;em&gt;node 自带的 debugger&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;进入调试模式后，代码会断在开始处。可通过以下常用命令进行 debug:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;c/cont&lt;/code&gt;：断续执行，类似于 Chrome DevTools 中的 &lt;kbd&gt;F8&lt;/kbd&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;n/next&lt;/code&gt;：步进，类似于 Chrome DevTools 中的 &lt;kbd&gt;F10&lt;/kbd&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;step/s&lt;/code&gt;: 进入，类似于 Chrome DevTools 中的 &lt;kbd&gt;F11&lt;/kbd&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;setBreakpoint()/sb()&lt;/code&gt;: 设置断点。
&lt;ul&gt;&lt;li&gt;通过调用该函数可对代码设置断点。&lt;/li&gt;
&lt;li&gt;直接调用则在当前所处的行设置断点。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sb(line_number)&lt;/code&gt; 传递一个行数，对相应行设置上断点。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sb(file_name,line_number)&lt;/code&gt; 传递文件名及行数，可对非当前文件进行断点的设置。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;clearBreakpoint&lt;/code&gt;: 参数与 &lt;code&gt;setBreakpoint&lt;/code&gt; 类似，作用是清除断点。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;breakpoints&lt;/code&gt;，查看设置的断点。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;观察变量的值。在这种调试模式下，可通过输入 &lt;code&gt;repl&lt;/code&gt; 进入 REPL（Read-Eval-Print-Loop） 模式来查看变量的值。&lt;/p&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;https://raw.githubusercontent.com/wayou/wayou.github.io/master/posts/nodejs-debug/assets/repl_in_node_debugger.png&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/wayou/wayou.github.io/master/posts/nodejs-debug/assets/repl_in_node_debugger.png&quot; alt=&quot;通过进入 REPL 模式查看断点处的变量值&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&lt;em&gt;通过进入 &lt;code&gt;REPL&lt;/code&gt; 模式查看断点处的变量值&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;实际使用中发现个弊端，就是打印出来的对象是不完整的，如上图。如果想查看没展示出来的属性，那就得记住属性名，然后手动点出来。你当然可以通过 &lt;code&gt;JSON.stringify(variable)&lt;/code&gt; 将变量转字符后打出来。但 JSON 序列化可并不是处处都管用，比如 koa 中的 response, request 对象，如果尝试进行 JSON 序列化，会报 JSON 循环引用的错误。而且在这里的 REPL 环境下，不能调用 node 模块，不然就可以通过自带的 &lt;code&gt;require('util').inspect(variable)&lt;/code&gt; 来打印了。&lt;/p&gt;
&lt;p&gt;如果每次断在某处时，都需要查看某个变量的值，可通过设置 watcher 来更加方便地查看。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;watch&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;my_expression&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;日志加 &lt;code&gt;tail -f&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;服务器上面更加常用的应该还是日志加 &lt;code&gt;tail&lt;/code&gt;，配合 &lt;code&gt;-f&lt;/code&gt; 参数，可时实将最新的 log 输出到命令行。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot;&gt;
&lt;pre&gt;
$ tail -f /your/logs/log
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Remote Debug&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://nodejs.org/en/docs/guides/debugging-getting-started/#enabling-remote-debugging-scenarios&quot; rel=&quot;nofollow&quot;&gt;Remote Debug&lt;/a&gt; 这个就有点厉害了，没配置过，获取相应服务器权限设置好之后，估计没有比这个更便捷的调试服务器上代码的方式了。在有些资源或服务只在服务器环境才有的情况下，本地又不好还原场景。&lt;/p&gt;
&lt;h3&gt;相关资源&lt;/h3&gt;
</description>
<pubDate>Tue, 26 Mar 2019 15:22:00 +0000</pubDate>
<dc:creator>刘哇勇</dc:creator>
<og:description>0 node 正确的书写方式 为了防止后面出现混乱的各种书写，先来了解一下如何正确书写 node 的名称。 下面使用来自@bitandbang 推文中的图片展示如何正确书写 node 名称。 node</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Wayou/p/node_debug.html</dc:identifier>
</item>
<item>
<title>前端菜鸟的小程序摸索记录 - 鲲逸鹏</title>
<link>http://www.cnblogs.com/dotnetcrazy/p/10597311.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dotnetcrazy/p/10597311.html</guid>
<description>&lt;p&gt;写在前面的话：&lt;strong&gt;算不了入门教程，只能算这几晚的摸索教程，下次会出一篇&lt;code&gt;一文入门小程序&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本文示例源码：&lt;a href=&quot;https://github.com/lotapp/BaseCode/tree/master/javascript/5.wechat/base&quot; class=&quot;uri&quot;&gt;https://github.com/lotapp/BaseCode/tree/master/javascript/5.wechat/base&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;屁话一箩筐&quot;&gt;1.屁话一箩筐&lt;/h2&gt;
&lt;p&gt;有些同志留言说我消失了，文章更新频率比以前慢多了？我这边先统一回复一下：&lt;/p&gt;
&lt;p&gt;最近这&lt;code&gt;几个月&lt;/code&gt;利用空闲时间把&lt;strong&gt;三国&lt;/strong&gt;读完了（咳，别问我为什么读，就是突然想读了）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;PS：有空聊聊呗~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;然后最近&lt;code&gt;两个星期&lt;/code&gt;迷上了&lt;strong&gt;读书&lt;/strong&gt;，回头可能会发点读书笔记，推荐几本不错的书给大家&lt;/p&gt;
&lt;p&gt;然后就是&lt;code&gt;上次发文&lt;/code&gt;，修复Shopee上传限制的时候使用了下&lt;code&gt;JQ&lt;/code&gt;来快速实现&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;PS：说到底还是个后端偏数据方向的，也就&lt;code&gt;JQ&lt;/code&gt;还记得。。。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;然后本着专研的精神，又把&lt;code&gt;H5&lt;/code&gt;复习了一下&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;PS：几年前曾经在旧博客写过H5的读书笔记&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本来准备找下思维导图快速过下的，之后发现。。。当时懒了一下，只是发图，所以。。&lt;code&gt;丢包了&lt;/code&gt;。。。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;PS：于是最近几天闲暇之余&lt;code&gt;W3C&lt;/code&gt;逛的比较多&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;然后先是改写了上次的脚本，再写了&lt;code&gt;H5&lt;/code&gt;的markdown&lt;code&gt;草稿&lt;/code&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;PS：过几天你们应该可以看到了，咳，人老了~容易疲劳。。让我先缓缓。。先缓缓&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;然后专研的毛病又来了，草稿写到导航和多媒体的时候想用小程序试试，毕竟现在是小程序的天下了&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;PS：之前前给亲戚弄小程序的时候研究了1个晚上，发现不是很难，然后现在想到了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;然后发现~前端的东西的确不难，但是我这人有个毛病：喜欢追求页面的美感。。&lt;/p&gt;
&lt;p&gt;于是发现。。demo几分钟搞定了，为了调个漂亮样式却耗去几小时。。。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;PS：本来今天可以早点休息的，于是乎~陪大家熬个夜吧。。。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;记录点小程序功能点&quot;&gt;2.记录点小程序功能点&lt;/h2&gt;
&lt;p&gt;我用的不多，简单引入一下，小程序API用起来很简单的，更全的可以去官方查看&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;PS：唉，还是Python官方文档最省心啊~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;话说，以后还是老老实实先把上面几个系列文章清了再说吧~&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;PS：清了以后，我还会回来的~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;前言&quot;&gt;2.1.前言&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;小程序|公众号&lt;/code&gt;登录注册页面：&lt;a href=&quot;https://mp.weixin.qq.com/&quot; class=&quot;uri&quot;&gt;https://mp.weixin.qq.com/&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;3.024&quot;&gt;
&lt;p&gt;这个太简单，就不浪费时间了，贴个官方教程：&lt;a href=&quot;https://developers.weixin.qq.com/miniprogram/dev/#%E7%94%B3%E8%AF%B7%E5%B8%90%E5%8F%B7&quot; class=&quot;uri&quot;&gt;https://developers.weixin.qq.com/miniprogram/dev/#申请帐号&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下载开发工具：&lt;a href=&quot;https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html&quot; class=&quot;uri&quot;&gt;https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;新建个简单项目：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201903/1127869-20190325224116723-28315307.png&quot; alt=&quot;1.创建小程序.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;项目基本配置：一般在详细里面改就行了&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201903/1127869-20190325224600194-98472293.png&quot; alt=&quot;2.配置文件.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;文件简单介绍：（图说的很清楚了）&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201903/1127869-20190325225154791-1001356193.png&quot; alt=&quot;3.文件介绍.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PS：用法和css一样，在小程序中像素单位全部用&lt;code&gt;rpx&lt;/code&gt;（类似于&lt;code&gt;rem&lt;/code&gt;）&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;2.6046511627907&quot;&gt;
&lt;p&gt;&lt;code&gt;rpx&lt;/code&gt;: 可以根据屏幕宽度进行自适应，文档：&lt;a href=&quot;https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxss.html&quot; class=&quot;uri&quot;&gt;https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxss.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;PS：小程序支持的标签&lt;/strong&gt;：&lt;a href=&quot;https://developers.weixin.qq.com/miniprogram/dev/component/&quot; class=&quot;uri&quot;&gt;https://developers.weixin.qq.com/miniprogram/dev/component/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下面开始就记录下遇到的&lt;strong&gt;小技术点&lt;/strong&gt;：&lt;/p&gt;
&lt;h3 id=&quot;页面初始数据的使用&quot;&gt;2.2.页面初始数据的使用&lt;/h3&gt;
&lt;p&gt;源码：&lt;a href=&quot;https://github.com/lotapp/BaseCode/tree/master/javascript/5.wechat/base/pages/1data&quot; class=&quot;uri&quot;&gt;https://github.com/lotapp/BaseCode/tree/master/javascript/5.wechat/base/pages/1data&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;获取&quot;&gt;2.2.1.获取&lt;/h4&gt;
&lt;p&gt;在页面的data中定义了几个字段：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201903/1127869-20190325230857294-116538029.png&quot; alt=&quot;3.data.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;想在页面中显示只需要写成&lt;code&gt;{{xxx}}&lt;/code&gt;即可&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201903/1127869-20190325231045040-1440724405.png&quot; alt=&quot;3.渲染.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PS：你每次保存，左边都会有预览的&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;&lt;code&gt;{{xxx}}&lt;/code&gt;也可以在样式和属性中哦~&lt;/strong&gt;（&lt;code&gt;wxss和css用法一样&lt;/code&gt;）&lt;/p&gt;
&lt;p&gt;贴下demo：（支持的标签看官方文档即可）&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;!--index.wxml--&amp;gt;
&amp;lt;view class='container'&amp;gt;
  &amp;lt;view class='{{my_class}}'&amp;gt;{{name}}&amp;lt;/view&amp;gt;
  &amp;lt;view&amp;gt;{{age}}&amp;lt;/view&amp;gt;
  &amp;lt;view&amp;gt;{{work.name}}&amp;lt;/view&amp;gt;
  &amp;lt;view&amp;gt;{{work.location}}&amp;lt;/view&amp;gt;
&amp;lt;/view&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;脚本：（支持ES6语法）&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;//index.js
Page({
  data: {
    name: &quot;小明&quot;,
    age: 23,
    work: {
      &quot;name&quot;: &quot;微软&quot;,
      &quot;location&quot;: &quot;中国&quot;
    },
    my_class: &quot;red&quot;
  },
  onLoad: function() {
    console.log(&quot;页面加载完成&quot;);
  }
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;样式：&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;/* index.wxss */
view {
  padding: 10rpx;
}

.red {
  color: red;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果演示：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201903/1127869-20190325231648198-915308454.png&quot; alt=&quot;3.渲染2.png&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h4 id=&quot;设置&quot;&gt;2.2.2.设置&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;知识点&lt;/code&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;获取：&lt;code&gt;this.data.xxx&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;设置：&lt;code&gt;this.setData({xxx:xx})&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;绑定事件：在标签中添加&lt;code&gt;bindtap=&quot;自定义方法&quot;&lt;/code&gt;属性&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;来个修改页面初始数据的案例：（官方说先修改js中的值，然后异步修改页面中的值）&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;!--index.wxml--&amp;gt;
&amp;lt;view class='container'&amp;gt;
  &amp;lt;view class='{{my_class}}'&amp;gt;{{name}}&amp;lt;/view&amp;gt;
  &amp;lt;view&amp;gt;{{age}}&amp;lt;/view&amp;gt;
  &amp;lt;view&amp;gt;{{work.name}}&amp;lt;/view&amp;gt;
  &amp;lt;view&amp;gt;{{work.location}}&amp;lt;/view&amp;gt;
  &amp;lt;button bindtap='update_info'&amp;gt;点我就修改&amp;lt;/button&amp;gt;
&amp;lt;/view&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;脚本文件：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;//index.js
Page({
  data: {
    name: &quot;小明&quot;,
    age: 23,
    work: {
      &quot;name&quot;: &quot;微软&quot;,
      &quot;location&quot;: &quot;中国&quot;
    },
    my_class: &quot;red&quot;
  },
  onLoad: function() {
    console.log(&quot;页面加载完成&quot;);
  },
  // 自定义方法  // look：新增内容
  update_info: function() {
    // this对象经常容易变，我一般都存一份
    var that = this;
    // 后台获取data里的值
    console.log(that.data.name, that.data.age)
    // 修改data(直接赋值没用)
    that.setData({
      age: 25,
      name: &quot;小华&quot;,
      work: {
        &quot;name&quot;: &quot;苹果&quot;,
        &quot;location&quot;: &quot;美国&quot;
      }
    });
  }
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果展示：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201903/1127869-20190327070604273-667627718.gif&quot; alt=&quot;3.点我修改.gif&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;弹框提醒&quot;&gt;3.弹框提醒&lt;/h2&gt;
&lt;p&gt;官方文档：&lt;a href=&quot;https://developers.weixin.qq.com/miniprogram/dev/api/wx.showToast.html&quot; class=&quot;uri&quot;&gt;https://developers.weixin.qq.com/miniprogram/dev/api/wx.showToast.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;源码：&lt;a href=&quot;https://github.com/lotapp/BaseCode/tree/master/javascript/5.wechat/base/pages/2show&quot; class=&quot;uri&quot;&gt;https://github.com/lotapp/BaseCode/tree/master/javascript/5.wechat/base/pages/2show&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;知识点：&lt;code&gt;wx.showToast({title:'内容',icon:'什么图标',duration:多少毫秒})&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在View中添加按钮：&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;button bindtap='show_msg1'&amp;gt;点我弹两行&amp;lt;/button&amp;gt;
&amp;lt;button bindtap='show_msg2'&amp;gt;点我就成功&amp;lt;/button&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;脚本中添加自定义方法：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;Page({
  data: {
    title1: '你知道吗？这是可以显示多行的弹框提醒~\r\n你知道吗？这是可以显示多行的弹框提醒~\r\n你知道吗？这是可以显示多行的弹框提醒~',
    title2: '一二三四五六七八'
  },
  onLoad: function() {
    console.log(&quot;页面加载完成&quot;);
  },
  // 弹框提醒
  show_msg1: function() {
    wx.showToast({
      title: this.data.title1,
      icon: 'none', // 可以显示2行
      duration: 2000 // 默认1500
    })
  },
  // 弹框提醒
  show_msg2: function() {
    // 默认只能显示7个中文字
    wx.showToast({
      title: this.data.title2
    })
  }
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果演示：（&lt;strong&gt;&lt;code&gt;\r\n&lt;/code&gt;可能在PC调试的时候不换行，但是可以在手机中换行&lt;/strong&gt;）&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201903/1127869-20190326104652801-934338968.png&quot; alt=&quot;4.默认弹框.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201903/1127869-20190326104732515-980510372.png&quot; alt=&quot;4.两行弹框.png&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;页面自定义属性值&quot;&gt;4.页面自定义属性值&lt;/h2&gt;
&lt;p&gt;源码：&lt;a href=&quot;https://github.com/lotapp/BaseCode/tree/master/javascript/5.wechat/base/pages/3data&quot; class=&quot;uri&quot;&gt;https://github.com/lotapp/BaseCode/tree/master/javascript/5.wechat/base/pages/3data&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;h5的自定义属性值&quot;&gt;4.1.H5的自定义属性值&lt;/h3&gt;
&lt;p&gt;说这个之前，先普及一下H5的这方面知识：&lt;br/&gt;&lt;strong&gt;&lt;code&gt;自定义属性&lt;/code&gt;&lt;/strong&gt;：在标签中的&lt;code&gt;data-自定义属性名&lt;/code&gt;（为了规范化）&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;获取自定义属性：&lt;code&gt;dom.dataset.自定义属性名&lt;/code&gt; or &lt;code&gt;dom.dataset[&quot;自定义属性名&quot;]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;设置自定义属性：&lt;code&gt;dom.dataset.自定义属性名 = xxx&lt;/code&gt; or &lt;code&gt;dom.dataset[&quot;自定义属性名&quot;] = xxx&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;删除自定义属性：&lt;code&gt;delete dom.dataset.自定义属性名&lt;/code&gt; or &lt;code&gt;delete dom.dataset[&quot;自定义属性名&quot;]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;一般属性：
&lt;ul&gt;&lt;li&gt;获取某个属性：&lt;code&gt;dom.getAttribute(&quot;属性名&quot;)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;删除某个属性：&lt;code&gt;dom.removeAttribute(&quot;属性名&quot;)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;设置某个属性：&lt;code&gt;dom.setAttribute(&quot;属性名&quot;, &quot;值&quot;)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;是否包含属性：&lt;code&gt;dom.hasAttribute(&quot;属性名&quot;)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;举个栗子：&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;div class=&quot;test&quot; data-name=&quot;mmd&quot; data-test-one=&quot;test&quot;&amp;gt;自定义属性&amp;lt;/div&amp;gt;
&amp;lt;script&amp;gt;
    // 获取标签的自定义属性值
    let list = document.querySelector(&quot;.test&quot;).dataset;
    // 获取：dom.dataset.自定义属性名（属性名不包含`data-`)
    console.log(list.name);
    // PS：test-one名字会改成驼峰命名的变量：testOne
    console.log(list.testOne)
    // 设置：dom.dataset.自定义属性名 = xxx or dataset[自定义属性名] = xxx
    list.name = &quot;小明&quot;; // 标签中对应值会变成小明
    list.age = 23; // 添加一个属性
    // PS：设置为data-test-two
    list.testTwo = &quot;test2&quot;;
&amp;lt;/script&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出效果：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201903/1127869-20190324083824298-83228614.png&quot; alt=&quot;/h5/2019-03-16/3.h5api.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;小程序版&quot;&gt;4.2.小程序版&lt;/h3&gt;
&lt;p&gt;官方文档：&lt;a href=&quot;https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html&quot; class=&quot;uri&quot;&gt;https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;知识点：&lt;code&gt;设置hover样式&lt;/code&gt;：在标签内置了&lt;code&gt;hover-class=&quot;xxx&quot;&lt;/code&gt;属性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;view：&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;view class='container'&amp;gt;
  &amp;lt;view data-name='小张' data-age='22' bindtap='get_datas' hover-class='hover'&amp;gt;点我获取data值&amp;lt;/view&amp;gt;
&amp;lt;/view&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;js：（ES6语法忘记的同志可以去之前写的&lt;a href=&quot;https://www.cnblogs.com/dotnetcrazy/p/10061671.html&quot; target=&quot;_blank&quot;&gt;一文读懂ES6&lt;/a&gt;）&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;Page({
  data: {
    title: '获取Data属性的值'
  },
  onLoad: function(options) {
    // 设置标题
    wx.setNavigationBarTitle({
      title: this.data.title,
    });
  },
  get_datas: function(e) {
    console.log(e);
    let infos = e.currentTarget.dataset;
    // 显示弹框
    wx.showToast({
      title: `Name：${infos.name}，Age：${infos.age}`, // ES6语法
      icon: 'none'
    })
  }
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;样式：&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;.hover {
  color: green;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;动态演示：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201903/1127869-20190326111307038-1932379785.gif&quot; alt=&quot;5.获取data属性.gif&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;小程序标题&quot;&gt;5.小程序标题&lt;/h2&gt;
&lt;p&gt;官方文档：&lt;a href=&quot;https://developers.weixin.qq.com/miniprogram/dev/api/wx.setNavigationBarTitle.html&quot; class=&quot;uri&quot;&gt;https://developers.weixin.qq.com/miniprogram/dev/api/wx.setNavigationBarTitle.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;源码：&lt;a href=&quot;https://github.com/lotapp/BaseCode/tree/master/javascript/5.wechat/base/pages/4title&quot; class=&quot;uri&quot;&gt;https://github.com/lotapp/BaseCode/tree/master/javascript/5.wechat/base/pages/4title&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;知识点：&lt;code&gt;wx.setNavigationBarTitle({title:&quot;xxx&quot;})&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;view：&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;view class='container'&amp;gt;
  &amp;lt;text&amp;gt;这是一个测试页面&amp;lt;/text&amp;gt;
&amp;lt;/view&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;js文件：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;Page({
  data: {
    title: '欢迎光临'
  },
  onLoad: function(options) {
    // 设置标题
    wx.setNavigationBarTitle({
      title: this.data.title,
    });
  }
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果演示：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201903/1127869-20190326105906987-531269632.png&quot; alt=&quot;5.标题.png&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;拨打电话&quot;&gt;6.拨打电话&lt;/h2&gt;
&lt;p&gt;官方文档：&lt;a href=&quot;https://developers.weixin.qq.com/miniprogram/dev/api/wx.makePhoneCall.html&quot; class=&quot;uri&quot;&gt;https://developers.weixin.qq.com/miniprogram/dev/api/wx.makePhoneCall.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;源码：&lt;a href=&quot;https://github.com/lotapp/BaseCode/tree/master/javascript/5.wechat/base/pages/6tel&quot; class=&quot;uri&quot;&gt;https://github.com/lotapp/BaseCode/tree/master/javascript/5.wechat/base/pages/6tel&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;知识点：&lt;code&gt;wx.makePhoneCall({phoneNumber:&quot;xx&quot;})&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;view:&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;view class='container'&amp;gt;
  &amp;lt;view hover-class='hover'&amp;gt;
    &amp;lt;text data-tel='{{tel}}' bindtap='call_tel'&amp;gt;{{info}}{{tel}}&amp;lt;/text&amp;gt;
  &amp;lt;/view&amp;gt;
&amp;lt;/view&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;js：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;Page({
  data: {
    info: &quot;客服电话：&quot;,
    tel: &quot;95017&quot;
  },
  onLoad: function(options) {},
  call_tel: function() {
    // 打电话
    wx.makePhoneCall({
      phoneNumber: this.data.tel
    });
  }
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;动态演示：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201903/1127869-20190326140939062-1334196460.gif&quot; alt=&quot;8.call.gif&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;图片背景&quot;&gt;7.图片背景&lt;/h2&gt;
&lt;p&gt;源码：&lt;a href=&quot;https://github.com/lotapp/BaseCode/tree/master/javascript/5.wechat/base/pages/5img&quot; class=&quot;uri&quot;&gt;https://github.com/lotapp/BaseCode/tree/master/javascript/5.wechat/base/pages/5img&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;背景图片&quot;&gt;7.1.背景图片&lt;/h3&gt;
&lt;p&gt;这个和html一样，CSS3就可以实现了&lt;/p&gt;
&lt;p&gt;wxml:&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;view class='container bg'&amp;gt;
  &amp;lt;view&amp;gt;This is Test&amp;lt;/view&amp;gt;
&amp;lt;/view&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;wxss:&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;.container {
  height: 1500rpx;
}

.bg {
  /* 设置背景图片的尺寸 */
  background-size: 100% 100%; /* CSS3 */
  /* 不支持本地图片，可以使用Base64或者允许域名下的图片 */
  background-image: url(data:image/jpeg;base64,/9j/4AAQSkZJ...省略);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;动态展示：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201903/1127869-20190326122114318-463714131.gif&quot; alt=&quot;7.填充页面.gif&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;页面填充&quot;&gt;7.2.页面填充&lt;/h3&gt;
&lt;p&gt;官方文档：&lt;a href=&quot;https://developers.weixin.qq.com/miniprogram/dev/component/image.html&quot; class=&quot;uri&quot;&gt;https://developers.weixin.qq.com/miniprogram/dev/component/image.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PS：图片懒加载：&lt;code&gt;lazy-load=&quot;true&quot;&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;wxml:&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;view class='container'&amp;gt;
  &amp;lt;!-- 高度自适应 --&amp;gt;
  &amp;lt;image class=&quot;bg&quot; src=&quot;../../images/bg.jpg&quot; mode=&quot;widthFix&quot;&amp;gt;&amp;lt;/image&amp;gt;
&amp;lt;/view&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;wxss:&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;.container {
  padding: 0rpx;
}

.bg {
  width: 100%;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;动态展示：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201903/1127869-20190326122114318-463714131.gif&quot; alt=&quot;7.填充页面.gif&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;新思路&quot;&gt;7.3.新思路&lt;/h3&gt;
&lt;p&gt;其实很多时候都是因为height设置100%，它不生效，所以才各种样式来调节&lt;/p&gt;
&lt;p&gt;可以这样设置来达到目的：&lt;strong&gt;&lt;code&gt;设置宽度100%，高度100vh&lt;/code&gt;&lt;/strong&gt;（整个屏幕默认满屏为100vh）&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;PS：地图用的比较多&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;扩展：&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;页面跳转&quot;&gt;8.页面跳转&lt;/h2&gt;
&lt;p&gt;源码：&lt;a href=&quot;https://github.com/lotapp/BaseCode/tree/master/javascript/5.wechat/base/pages/7goto&quot; class=&quot;uri&quot;&gt;https://github.com/lotapp/BaseCode/tree/master/javascript/5.wechat/base/pages/7goto&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;知识点&lt;/code&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;通过方法跳转：&lt;code&gt;wx.navigateTo({url:&quot;url地址&quot;})&lt;/code&gt;&lt;/strong&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;页面直接跳转：&lt;code&gt;&amp;lt;navigator url='url地址'&amp;gt;xxx&amp;lt;/navigator&amp;gt;&lt;/code&gt;&lt;/strong&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;先看一下目录结构：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201903/1127869-20190326151327051-150295575.png&quot; alt=&quot;9.目录结构.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;index页面&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;view class='container'&amp;gt;
  &amp;lt;view&amp;gt;
    &amp;lt;navigator url='{{url}}' hover-class='hover'&amp;gt;链接跳转&amp;lt;/navigator&amp;gt;
  &amp;lt;/view&amp;gt;
  &amp;lt;view hover-class='hover' bindtap='to_page' data-url='{{url}}'&amp;gt;方法跳转&amp;lt;/view&amp;gt;
  &amp;lt;view hover-class='hover' bindtap='goto_page' data-url='{{url2}}'&amp;gt;带参跳转&amp;lt;/view&amp;gt;
&amp;lt;/view&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;index脚本：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;Page({
  data: {
    name: '小明',
    age: 22,
    url: '../1data/update_info',
    url2: './main'
  },
  onLoad: function(options) {

  },
  to_page: e =&amp;gt; {
    // 页面跳转
    wx.navigateTo({
      url: e.currentTarget.dataset.url
    })
  },
  goto_page: function(e) {
    var that = this;
    // 页面跳转
    wx.navigateTo({
      url: `${e.currentTarget.dataset.url}?name=${that.data.name}&amp;amp;age=${that.data.age}`
    });
  }
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;main页面：&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;view class='container'&amp;gt;
  &amp;lt;view&amp;gt;{{name}}&amp;lt;/view&amp;gt;
  &amp;lt;view&amp;gt;{{age}}&amp;lt;/view&amp;gt;
&amp;lt;/view&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;main脚本：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;Page({
  data: {},
  onLoad: function(pms) {
    console.log(pms);

    var that = this;
    // 设置data值
    this.setData({
      name: pms.name,
      age: pms.age
    });
  }
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;动态演示：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201903/1127869-20190326151114427-1912999017.gif&quot; alt=&quot;9.跳转.gif&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;这些东西都是用API，算是比较简单的了，就是找起来麻烦点，时间不早了，地图这块我再贴一个案例就先结束吧&lt;/p&gt;
&lt;h2 id=&quot;地图相关&quot;&gt;9.地图相关&lt;/h2&gt;
&lt;p&gt;源码：&lt;a href=&quot;https://github.com/lotapp/BaseCode/tree/master/javascript/5.wechat/base/pages/8map&quot; class=&quot;uri&quot;&gt;https://github.com/lotapp/BaseCode/tree/master/javascript/5.wechat/base/pages/8map&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;简单案例&quot;&gt;9.1.简单案例&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;知识点&lt;/code&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;wx.getLocation({success:成功执行的方法,fail:失败执行的方法})&lt;/code&gt;：获取经纬度&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;wx.openLocation({latitude: 经度值, longitude: 纬度值})&lt;/code&gt;：显示对应位置的地图&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;wxml：&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;view&amp;gt;
  &amp;lt;button bindtap='get_location'&amp;gt;{{demo1}}&amp;lt;/button&amp;gt;
  &amp;lt;button bindtap='open_location'&amp;gt;{{demo2}}&amp;lt;/button&amp;gt;
&amp;lt;/view&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;js源码：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;Page({
  data: {
    demo1: '获取经纬',
    demo2: '打开地图',
    lon: 120.636146,
    lat: 31.25893
  },
  onLoad: function(options) {},
  // 需要使用this的时候，最外面方法老老实实写function()
  get_location: function() {
    var that = this;
    // 获取经纬度
    wx.getLocation({
      // 成功的时候
      success: res =&amp;gt; {
        console.log(res.latitude, res.longitude, res.speed, res.accuracy);
        // 更新页面数据
        that.setData({
          lon: res.longitude,
          lat: res.latitude
        });
        // 弹框提醒
        wx.showToast({
          title: `(${res.longitude}，${res.latitude})`, // ES6语法
          icon: 'none'
        });
      },
      // 失败的时候
      fail: ex =&amp;gt; {
        // 弹框提醒
        wx.showToast({
          title: '定位未授权，请重新授权：\r\n删除小程序后再打开',
          icon: 'none'
        });
      }
    });
  },
  // 打开位置
  open_location: function() {
    var that = this;
    // 打开位置
    wx.openLocation({
      latitude: that.data.lat,
      longitude: that.data.lon
    });
  }
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;简单说下成功之后的参数含义&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;res.longitude&lt;/code&gt;：经度&lt;/li&gt;
&lt;li&gt;&lt;code&gt;res.latitude&lt;/code&gt;：纬度&lt;/li&gt;
&lt;li&gt;&lt;code&gt;res.speed&lt;/code&gt;：移动速度（实时定位的时候用的多）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;res.accuracy&lt;/code&gt;：精确度（一般低于50，经纬数据就偏差太多）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;失败摸拟：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201903/1127869-20190326204908335-1529831664.gif&quot; alt=&quot;10.获取失败.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;成功摸拟：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201903/1127869-20190326204920797-786094848.gif&quot; alt=&quot;10.成功获取.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;额外说明：需要配置一下你需要使用的权限&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201903/1127869-20190326204940995-1736596599.png&quot; alt=&quot;10.权限声明.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;PS：授权之后，在开发的时候可以清楚状态（现实中重新授权需要&lt;code&gt;删除小程序再打开&lt;/code&gt;）&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201903/1127869-20190326204949678-716674858.png&quot; alt=&quot;10.清除状态.png&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;map组件&quot;&gt;9.2.Map组件&lt;/h3&gt;
&lt;p&gt;官方文档：&lt;a href=&quot;https://developers.weixin.qq.com/miniprogram/dev/component/map.html&quot; class=&quot;uri&quot;&gt;https://developers.weixin.qq.com/miniprogram/dev/component/map.html&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;简单案例扩展&quot;&gt;1.简单案例扩展&lt;/h4&gt;
&lt;p&gt;先看下简单案例的扩展：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在打开地图的时候指定&lt;code&gt;address&lt;/code&gt;&lt;/strong&gt; 可以更人性化显示：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;Page({
  data: {
    lon: 120.674297,
    lat: 31.324571
  },
open_location: function() {
    var that = this;
    // 打开位置
    wx.openLocation({
      latitude: that.data.lat,
      longitude: that.data.lon,
      // scale: 10, // 缩放级别（5~18）默认是18
      address: '江苏省苏州市工业园区都市花园' // 这个信息可以通过地图api逆向解析
    });
  }
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201903/1127869-20190326221239839-525522820.png&quot; alt=&quot;10.位置信息.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;map组件案例&quot;&gt;2.Map组件案例&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;知识点&lt;/code&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;show-location&lt;/code&gt;：显示当前定位点&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;markers&lt;/code&gt;：多个标识&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;bindmarkertap&lt;/code&gt;：标记点击事件&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;满屏设置：&lt;code&gt;width:100%;height:100vh&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;wxml：&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;view&amp;gt;
  &amp;lt;map longitude='{{lon}}' latitude='{{lat}}' markers='{{markers}}' show-location='true' bindmarkertap='makertap' style='width:100%;height:100vh'&amp;gt;&amp;lt;/map&amp;gt;
  &amp;lt;!--  --&amp;gt;
&amp;lt;/view&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;JS：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;Page({
  data: {
    lon: 120.674297,
    lat: 31.324571,
    markers: []
  },
  // 页面加载
  onLoad: function() {
    var that = this;
    // eg：可以通过baidu Map获取到markers信息
    // BMap.regeocoding({success: ret =&amp;gt; {ret.wxMarkerData}});
    // 假设通过API获取到了数据
    that.setData({
      markers: [{
        id: 0,
        latitude: that.data.lat,
        longitude: that.data.lon,
        address: '江苏省苏州市工业园区都市花园',
        iconPath: '/images/marker_red.png',
        callout: {
          'content': '江苏省苏州市工业园区都市花园',
          'bgColor': '#fff',
          'color': '#f00',
          'padding': 15,
          'display': 'ALWAYS', // BYCLICK：点击显示
          'borderRadius': 5
        }
      }]
    });
  },
  // 标记点击事件
  makertap: function(e) {
    var that = this;
    // 提示
    wx.showToast({
      title: `点击了标记点${e.markerId}`,
      icon: 'none'
    });
    // 可以根据e.markerId获取marker信息
    console.log(that.data.markers[e.markerId]);
  }
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;动态演示：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201903/1127869-20190326230453128-1140451874.gif&quot; alt=&quot;10.点击标记.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;PS：可以通过经纬信息来获取对应的位置信息（&lt;code&gt;最后一个百度地图的demo里有贴&lt;/code&gt;）&lt;/p&gt;
&lt;blockquote readability=&quot;0.9375&quot;&gt;
&lt;p&gt;官方文档：&lt;a href=&quot;http://lbsyun.baidu.com/index.php?title=wxjsapi/guide/getlocation&quot; class=&quot;uri&quot;&gt;http://lbsyun.baidu.com/index.php?title=wxjsapi/guide/getlocation&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我还写了一个惯连的案例，这边就不演示了，给大家课后自测吧：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201903/1127869-20190327070906920-2041141046.png&quot; alt=&quot;10.自测.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;PS：在使用外部链接的时候需要添加到白名单中（补充说明里有贴哦~）&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;补充说明&quot;&gt;补充说明&lt;/h2&gt;
&lt;h3 id=&quot;关于调试&quot;&gt;1.关于调试&lt;/h3&gt;
&lt;p&gt;开发的时候可以在手机中预览，也可以真机调试把输出信息直接显示到PC端：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201903/1127869-20190327071353592-1174322290.png&quot; alt=&quot;调试.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;手机调试可以打开调试模式：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201903/1127869-20190327072716642-1678919687.png&quot; alt=&quot;开启调试.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;之后的操作都会记录，而且控制台输出也会显示：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201903/1127869-20190327073051489-541846628.png&quot; alt=&quot;效果预览.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201903/1127869-20190327072923504-343822558.png&quot; alt=&quot;显示信息.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;关于开发者设置&quot;&gt;2.关于开发者设置&lt;/h3&gt;
&lt;p&gt;有了AppID，并不可以开发，还需要是开发者|管理员：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201903/1127869-20190327071911494-1434445242.png&quot; alt=&quot;添加开发者.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在没有上线前，职工开发和体验成员使用：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201903/1127869-20190327072056187-1929845025.png&quot; alt=&quot;预览和体验.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;关于网络资源的说明&quot;&gt;3.关于网络资源的说明&lt;/h3&gt;
&lt;p&gt;在使用外部链接的时候需要添加到白名单中（网站必须备案过）&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201903/1127869-20190327072310859-1371514052.png&quot; alt=&quot;添加域名.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;发布和预览&quot;&gt;4.发布和预览&lt;/h3&gt;
&lt;p&gt;先要上传代码：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201903/1127869-20190327073202245-543152913.png&quot; alt=&quot;上传.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201903/1127869-20190327073329536-1802599638.png&quot; alt=&quot;上传2.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这时候可以选择&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201903/1127869-20190327073447267-284556829.png&quot; alt=&quot;设置体验版.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201903/1127869-20190327073558499-1521502462.png&quot; alt=&quot;体验首页.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201903/1127869-20190327073709420-615345948.png&quot; alt=&quot;可体验.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;PS：提交核审后就可以上线了（不推荐把自己做的demo提交核审，腾讯会处罚的~）&lt;/p&gt;
&lt;p&gt;现在小程序提供了&lt;code&gt;云开发&lt;/code&gt;的API（可以当做&lt;code&gt;数据库&lt;/code&gt;+&lt;code&gt;文件上传下载&lt;/code&gt;）感兴趣的可以先了解下：&lt;/p&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://developers.weixin.qq.com/miniprogram/dev/wxcloud/basis/getting-started.html&quot; class=&quot;uri&quot;&gt;https://developers.weixin.qq.com/miniprogram/dev/wxcloud/basis/getting-started.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;时候不早了，建议大家明天再看这篇文章（待续...）&lt;/p&gt;
</description>
<pubDate>Tue, 26 Mar 2019 15:10:00 +0000</pubDate>
<dc:creator>鲲逸鹏</dc:creator>
<og:description>一文摸摸小程序的底 写在前面的话： 算不了入门教程，只能算这几晚的摸索教程，下次会出一篇 本文示例源码： 1.屁话一箩筐 有些同志留言说我消失了，文章更新频率比以前慢多了？我这边先统一回复一下： 最近</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dotnetcrazy/p/10597311.html</dc:identifier>
</item>
<item>
<title>html+css制作五环（代码极简） - 差生_G</title>
<link>http://www.cnblogs.com/gzyc/p/10604474.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/gzyc/p/10604474.html</guid>
<description>&lt;h2 id=&quot;五环&quot;&gt;五环&lt;/h2&gt;
&lt;p&gt;把五环做成一个浮动，总是位于屏幕中央的效果。&lt;/p&gt;
&lt;h2 id=&quot;难点&quot;&gt;难点&lt;/h2&gt;
&lt;ol readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;定位的练习 position ：fixed&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;位于body中间的时候 left：50%；top:50%;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;css内部样式表的使用 style=&quot;text/css&quot;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;&lt;li&gt;使用border-radius: 50%再加上z-index设置层叠关系&lt;/li&gt;
&lt;li&gt;首先我们用5个块级元素来形成5个环的颜色和形状，并把这5个环放置到一个父级容器div内，再将这个父级元素div放置到浏览器中间位置。&lt;/li&gt;
&lt;/ol&gt;
&lt;ol readability=&quot;-1&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;div的作用:div是一个块级元素。它可以将html分割成独立的、不同的部分。如果用id和class来标记div，那么该标签便可以被css所使用变的更有效，通过id或class设计各种的样式。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1525608/201903/1525608-20190326224250478-332086165.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;html的设计：&lt;/p&gt;
&lt;p&gt;首先给5个环设置class用来css文件关联样式，并把这5个环放置一个父级div中&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;div class =&quot;plat&quot;&amp;gt; 
    &amp;lt;div class=&quot;a1&quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div class=&quot;a2&quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div class=&quot;a3&quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div class=&quot;a4&quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div class=&quot;a5&quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;div&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;css样式设计：&lt;/p&gt;
&lt;ol readability=&quot;5.5&quot;&gt;&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;通过绑定html中设置好的class，然后绘制五个环的形状和大小还有位置&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; .a1,.a2,.a3,.a4,.a5{
                     position:absolute;  
                     width: 100px;
                     height: 100px;
                     background-color: transparent;
                     border: 10px solid;
                     border-radius: 110px;
             }&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;绘制每个环的颜色和位置：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;         .a1{
             border-color: blue;
             left: 0;
             top: 0;

         }
         .a2{
             border-color: black;
             top: 0px;
             left: 130px;
             z-index: 4;
         }
         .a3{
             border-color: yellow;
             top: 0px;
             left: 260px;
             z-index: 4;
         }
         .a4{
             border-color: red;
             top: 65px;
             left: 65px;
             z-index: 5;

         }
         .a5{
             border-color: green;
             top: 65px;
             left: 198px;
             z-index: 6;
         }&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;设计父级div的位置：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;首先要知道，我们设计的5环是在div内部，所以调整div的位置便可以实现浏览器居中i效果。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;.plat{
    
                position: fixed;
                top: 50%;
                left: 50%;
                margin-left:-140px;
                margin-top: -70px;
                width: 280px;
                height: 140px;
            }&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;代码&quot;&gt;代码&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;    &amp;lt;!DOCTYPE html&amp;gt;
    &amp;lt;html &amp;gt;
    &amp;lt;head&amp;gt;
        &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
        &amp;lt;title&amp;gt;居中五环&amp;lt;/title&amp;gt;
        &amp;lt;style type=&quot;text/css&quot;&amp;gt;
            .a1,.a2,.a3,.a4,.a5{
                    position:absolute;  
                    width: 100px;
                    height: 100px;
                    background-color: transparent;
                    border: 10px solid;
                    border-radius: 110px;
            }
            .plat{
    
                position: fixed;
                top: 50%;
                left: 50%;
                margin-left:-140px;
                margin-top: -70px;
                width: 280px;
                height: 140px;
            }
            .a1{
                border-color: blue;
                left: 0;
                top: 0;
    
            }
            .a2{
                border-color: black;
                top: 0px;
                left: 130px;
                z-index: 4;
            }
            .a3{
                border-color: yellow;
                top: 0px;
                left: 260px;
                z-index: 4;
            }
            .a4{
                border-color: red;
                top: 65px;
                left: 65px;
                z-index: 5;
    
            }
            .a5{
                border-color: green;
                top: 65px;
                left: 198px;
                z-index: 6;
            }
        &amp;lt;/style&amp;gt;
        
    &amp;lt;body&amp;gt;
    &amp;lt;div class =&quot;plat&quot;&amp;gt; 
        &amp;lt;div class=&quot;a1&quot;&amp;gt;&amp;lt;/div&amp;gt;
        &amp;lt;div class=&quot;a2&quot;&amp;gt;&amp;lt;/div&amp;gt;
        &amp;lt;div class=&quot;a3&quot;&amp;gt;&amp;lt;/div&amp;gt;
        &amp;lt;div class=&quot;a4&quot;&amp;gt;&amp;lt;/div&amp;gt;
        &amp;lt;div class=&quot;a5&quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div&amp;gt;
        
    &amp;lt;/body&amp;gt;
    &amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;效果&quot;&gt;效果&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1525608/201903/1525608-20190326164612218-2020884551.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 26 Mar 2019 14:53:00 +0000</pubDate>
<dc:creator>差生_G</dc:creator>
<og:description>五环 把五环做成一个浮动，总是位于屏幕中央的效果。 难点 1. 定位的练习 position ：fixed 2. 位于body中间的时候 left：50%；top:50%; 3. css内部样式表的使</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/gzyc/p/10604474.html</dc:identifier>
</item>
<item>
<title>Spring @ModelAttribute - 喜欢日向雏田一样的女子啊</title>
<link>http://www.cnblogs.com/lvbinbin2yujie/p/10604420.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lvbinbin2yujie/p/10604420.html</guid>
<description>&lt;h2&gt;正文开始之前，先介绍个东西，Spring能够自动将请求参数封装到对应JavaBean上!&lt;/h2&gt;
&lt;p&gt;代码比较简单，也没有什么配置要记录，只是开启了&amp;lt;mvc:annotation-driven/&amp;gt;，可以看到达到了这样的效果：&lt;/p&gt;
&lt;p&gt;请求中属性name  age 自动映射到 User对象上，返回视图时 属性又自动封装填充到 request属性域中.  填充的属性 键值key默认为类名首字母小写.&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/1550387/201903/1550387-20190326223953652-1811359789.png&quot; alt=&quot;image&quot; width=&quot;675&quot; height=&quot;451&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;记录下，请求中参数是如何绑定到User对象上并且填充到request属性域中.&lt;/h2&gt;
&lt;p&gt;Spring抽象出来一个接口HandlerMethodArgumentResolver，这个接口主要实现两个功能：判断我们能否完成对这种参数类型的转换工作，以及我们如何去完成参数类型转换的工作？  等等，完成什么参数类型转换工作？ 当然是完成@RequestMapping方法入参的参数转换工作啊！&lt;/p&gt;
&lt;p&gt;那我们肯定需要一堆的HandlerMethodArgumentResolver这个接口实现类吧，肯定要有顺序吧，肯定用ArrayList来存储这个实现类。&lt;/p&gt;
&lt;p&gt;Spring&amp;lt;mvc:annotation-driven/&amp;gt;肯定偷偷帮我们注册了一系列的HandlerMethodArgumentResolver实现类吧！没错，SpringMvc偷偷注册了十来个这样的HandlerMethodArgumentResolver，具体怎么工作的这里不叙述了，&lt;/p&gt;
&lt;p&gt;其中专门用来解析自定义对象JavaBean的是ArrayList的最后一个HandlerMethodArgumentResolver  ：ServletModelAttributeMethodProcessor， 前面HandlerMethodArgumentResolver  都没用，才考虑到我，┭┮﹏┭┮&lt;/p&gt;
&lt;p&gt;(其实也不是最后一个，因为注册了两个ServletModelAttributeMethodProcessor，只是这种情况我们用的是最后一个).&lt;/p&gt;

&lt;h3&gt;上面提及的两个工作，肯定是先判断我们能否完成对这种参数类型的转换工作：&lt;/h3&gt;
&lt;p&gt;    我们现在讨论的不带 ModelAttribute注解，所以前面条件返回false , 后面条件 ： this指代ServletModelAttributeMethodProcessor，annotationNotRequired为 true （这就是注册两个ServletModelAttributeMethodProcessor的原因，排在前面只 解析@ModelAttribute的参数，而排在后面的解析自定义 JavaBean对象的转换）&lt;/p&gt;
&lt;p&gt;   annotationNotRequired为true的情况下，后面条件判断的是 进一步限定 参数类型， 不是Date、数组、URI、URL、Number这种类型的，我才有必要进行 属性映射到对象上；&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/1550387/201903/1550387-20190326223954543-1040888443.png&quot; alt=&quot;image&quot; width=&quot;900&quot; height=&quot;109&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代码片段位于:&lt;span&gt;org.springframework.web.method.annotation.ModelAttributeMethodProcessor#supportsParameter&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;这么看来 自定义对象完全满足使用 ServletModelAttributeMethodProcessor 来进行参数转换，下一步就是请求参数 转换到 JavaBean对象的事儿了.&lt;/h3&gt;
&lt;p&gt;逐行简单介绍下作用：Line100 检测方法入参parameter上是否有ModelAttribute注解，有就以@ModelAttribute(value=”xx”)的value作为name,没有就以parameter的class属性，类名转小写作为name  例如User---&amp;gt;user&lt;/p&gt;
&lt;p&gt;    Line101. 首先判断现在的ModelMap中是否有该name属性， 有就直接取出来作为attribute(ModelMap可以通过@ModelAttribute标注在普通方法上预先绑定一些属性);&lt;/p&gt;
&lt;p&gt;                                                                                   没有就尝试创建，首先看是不是可以通过 URI中的PathVariable、request中直接getAttribute获取啊，都行不通的情况就直接构造这个class的实例，构造总要有构造器，采用默认的空参构造器，你没有空参构造器就会抛出异常！&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;这也告诉我们，参数类型需要有默认的空参构造器；&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;   Line104  判断下这个属性是不是被列入黑名单，bindingDisabled, 加入黑名单方式目前暂知 通过@ModelAttribute(binding=false)设置，暂时不考虑这种情况;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;   Line111 WebDataBinder对象，这里也涉及了@InitBinder注解的解析，可以看之前的博客记录； target就是存的上面的attribute&lt;/p&gt;
&lt;p&gt;   Line112 attribute不为空，Line114行完成了属性的绑定，name、age映射到User上，映射方式按照名称映射，支持 . 进行级联等复杂映射，映射方式具体API可以看我下面的例子.&lt;/p&gt;
&lt;p&gt;   这里完成调用了ConversionService进行一定的转换，比如支持@DateTimeFormat等等.&lt;/p&gt;
&lt;p&gt;   Line116 @Valid注解解析过程，这里跳过；            Line127 底层使用converter进行类型转换，我想不明白为啥还要再转换一次?  上面已经完成了请求参数绑定到JavaBean中.&lt;/p&gt;

&lt;p&gt;完成请求方法参数---&amp;gt;JavaBean以后，ModelMap中的值最终都会存到ModelAndView视图的model属性,  InternalResourceView的renderMergedOutputModel方法进行将 model属性一个个存入request的属性中；&lt;br/&gt;跳转到对应的视图比如jsp一般都是request.getRequestDispatcher进行跳转;   假如@RequestMapping方法返回值不是前往某个视图JSP, 不会将属性存入request中。&lt;/p&gt;
&lt;h3&gt;另外注意：存储在request中的 key为 name，当前情况也就是 类名首字母小写。&lt;/h3&gt;
&lt;p&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/1550387/201903/1550387-20190326223955732-2055678233.png&quot; alt=&quot;image&quot; width=&quot;900&quot; height=&quot;550&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代码片段位于：&lt;span&gt;org.springframework.web.method.annotation.ModelAttributeMethodProcessor#resolveArgument&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;展示下如何利用Spring Api完成这样的请求参数绑定生成具体的实例&lt;/h3&gt;
&lt;pre class=&quot;brush: java;html-script: false;quick-code: true;smart-tabs: true;auto-links: true;toolbar: true;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
public class SimpleTest {
    public static void main(String[] args) {
        //接受Pojo对象
        BeanWrapperImpl bw = new BeanWrapperImpl(new Form7Pojo());
        PropertyValues pvs=new MutablePropertyValues();
        ((MutablePropertyValues) pvs).add(&quot;name&quot;,&quot;HelloWorld BeanWrapper&quot;);
        ((MutablePropertyValues) pvs).add(&quot;age&quot;,24);
        bw.setPropertyValues(pvs,false,false);
        Object target = bw.getWrappedInstance();
        System.out.println(target);


        BeanWrapperImpl bw2 = new BeanWrapperImpl(new Address());
        bw2.setAutoGrowNestedPaths(true);
        PropertyValues pvs2=new MutablePropertyValues();
        ((MutablePropertyValues) pvs2).add(&quot;city.name&quot;,&quot;南京&quot;);
        ((MutablePropertyValues) pvs2).add(&quot;location&quot;,&quot;鼓楼区&quot;);
        bw2.setPropertyValues(pvs2,false,false);
        Object target2 = bw2.getWrappedInstance();
        System.out.println(target2);
    }
}

@Setter
@Getter
@ToString
public class Form7Pojo {
    private String name;
    private Integer age;

}

@Setter
@Getter
@ToString
public class Address {
    private City city;
    private String location;
}

@Setter
@ToString
public class City {
    private String name;
}

&lt;/pre&gt;

&lt;h2&gt;记录@ModelAttribute用法：&lt;/h2&gt;
&lt;h3&gt;用法一： 单单用在 @RequestMapping中的方法参数中， 作用将当前对象以 “user2”的名字存入request ，展示在视图界面，默认是 “user”的名字.&lt;/h3&gt;
&lt;p&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/1550387/201903/1550387-20190326223956532-652696554.png&quot; alt=&quot;image&quot; width=&quot;900&quot; height=&quot;142&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;用法二.   单单用在 @Controller方法中，不加@RequestMapping注解 ，作用： &lt;span&gt;该@ModelAttribute方法会在每个@RequestMapping方法执行之前执行一次&lt;/span&gt;， 在每个@RequestMapping方法中获取的方式：注入modelMap属性，modelMap.get(“skill”)的方式获取属性。&lt;/h3&gt;
&lt;p&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/1550387/201903/1550387-20190326223957141-1460577751.png&quot; alt=&quot;image&quot; width=&quot;900&quot; height=&quot;131&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;
&lt;p&gt;效果等同于如下方法：&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/1550387/201903/1550387-20190326223957746-414841702.png&quot; alt=&quot;image&quot; width=&quot;900&quot; height=&quot;112&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;用法三： 这种方式比较奇葩，先直接说结论，跳转到默认的JSP页面，比如我的默认JSP页面就是 /WEB-INF/jsp/demo5.jsp，&lt;span&gt;request中存储属性{professionalSkill=hello}.&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;这个时候返回值类型String已经不重要了，反正都要存到request的attribute属性域中，&lt;span&gt;key就是 @ModelAttribute注解的 value , value就是@RequestMapping方法返回值;&lt;/span&gt;&lt;/h3&gt;
&lt;h3&gt;至于为啥跳转到/WEB-INF/jsp/demo5.jsp呢， DispatcherServlet的applyDefaultViewName方法是计算默认展示界面&lt;/h3&gt;
&lt;p&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/1550387/201903/1550387-20190326223958290-978114857.png&quot; alt=&quot;image&quot; width=&quot;900&quot; height=&quot;187&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;SpringMvc计算默认展示界面规则：视图解析器前缀 +  请求相对路径 + 视图解析器后缀 ，请求相对路径就是/demo5&lt;/h3&gt;
&lt;p&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/1550387/201903/1550387-20190326223958899-629556531.png&quot; alt=&quot;image&quot; width=&quot;900&quot; height=&quot;277&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;
&lt;p&gt;验证：下面是一个不含视图名的ModelAndView返回给前端，结果如下(因为Controller上有@RequestMapping为/modelAttri  )：&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/1550387/201903/1550387-20190326223959798-617789156.png&quot; alt=&quot;image&quot; width=&quot;900&quot; height=&quot;337&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;用法四. 比如demoa方法，入参a就是demoaaaaaaa，其实通过注入ModelMap，然后get(“strA”)方法一样可以达到效果;  但是JSP页面上仍然可以使用 ${strA} ${strB}访问到对应属性；&lt;/h2&gt;
&lt;p&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/1550387/201903/1550387-20190326224000525-796588693.png&quot; alt=&quot;image&quot; width=&quot;826&quot; height=&quot;446&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;简单记录下：SpringMvc @ModelAttribute注解解析位置：&lt;/h3&gt;
&lt;h3&gt; &lt;span&gt;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter#getModelFactory&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/1550387/201903/1550387-20190326224001619-1355868606.png&quot; alt=&quot;image&quot; width=&quot;741&quot; height=&quot;367&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;总结：&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;感觉@ModelAttribute不是个很实用的注解，映射到JavaBean的时候吧，不需要它也能存入到request中，用它大概就是为了自定义存入request的key值吧.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在每个@RequestMapping方法之前做些处理吧，感觉有点像拦截器，但是每个@ModelAttribute都要执行一遍，有点多余哈，还不能指定只执行一个，有点搞不明白能用来做啥┭┮﹏┭┮.&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 26 Mar 2019 14:45:00 +0000</pubDate>
<dc:creator>喜欢日向雏田一样的女子啊</dc:creator>
<og:description>正文开始之前，先介绍个东西，Spring能够自动将请求参数封装到对应JavaBean上! 代码比较简单，也没有什么配置要记录，只是开启了&lt;mvc:annotation-driven/&gt;，可</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lvbinbin2yujie/p/10604420.html</dc:identifier>
</item>
</channel>
</rss>