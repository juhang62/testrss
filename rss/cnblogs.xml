<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>SpringMVC源码阅读：属性编辑器、数据绑定 - Rest探路者</title>
<link>http://www.cnblogs.com/Java-Starter/p/10352276.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Java-Starter/p/10352276.html</guid>
<description>&lt;h2&gt;1.前言&lt;/h2&gt;
&lt;p&gt;SpringMVC是目前J2EE平台的主流Web框架，不熟悉的园友可以看&lt;span&gt;&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/Java-Starter/p/10304896.html&quot;&gt;&lt;span&gt;SpringMVC源码阅读入门&lt;/span&gt;&lt;/a&gt;&lt;span class=&quot;postTitle2&quot;&gt;,它交代了SpringMVC的基础知识和源码阅读的技巧&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;本文将通过源码(基于Spring4.3.7)分析，弄清楚SpringMVC如何通过类型转换完成数据绑定和属性编辑器的原理，并自定义属性编辑器&lt;/p&gt;
&lt;h2&gt;2.源码分析&lt;/h2&gt;
&lt;p&gt;进入RequestMappingHandlerAdapter,该类支持参数解析和数据返回，进入invokeHandlerMethod方法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201453/201902/1201453-20190204211040184-1075239167.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;794行构造WebDataBinderFactory,传入HandlerMethod参数&lt;/p&gt;
&lt;p&gt;点进去getDataBinderFactory方法，看看它做什么&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1201453/201902/1201453-20190204215220223-724539544.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;886行获取@&lt;span&gt;InitBinder&lt;/span&gt;方法&lt;/p&gt;
&lt;p&gt;891行查找带有@ControllerAdvice注解支持的Controller&lt;/p&gt;
&lt;p&gt;看下RequestParamMethodArgumentResolver的父类AbstractNamedValueMethodArgumentResolver的resolveArgument方法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201453/201902/1201453-20190204222251017-1800932183.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;117行获取到@InitBinder注解修饰的方法和@ControllerAdvice中的@InitBinder注解修饰的方法&lt;/p&gt;
&lt;p&gt;118行创建一个ExtendedServletRequestDataBinder&lt;/p&gt;
&lt;p&gt;120行arg获取参数转换结果&lt;/p&gt;
&lt;p&gt;binderFactory变量是&lt;span&gt;WebDataBinderFactory类型，打开WebDataBinderFactory,该类在Spring3.1引入，用来创建WebDataBinder&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;进入WebDataBinder,该类用于处理Web请求参数和JavaBean之间的数据绑定，ctrl+alt+h打开类继承图，WebDataBinder继承DataBinder&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201453/201902/1201453-20190204223008555-1485330318.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;打开DataBinder类，该类允许在目标对象上设置属性值，支持数据验证和绑定，实现了&lt;span&gt;PropertyEditorRegistry&lt;/span&gt;和&lt;span&gt;TypeConverter&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;先打开PropertyEditorRegistry，该类给注册的JavaBean封装方法，注释提到被BeanWrapper继承，由BeanWrapperImpl实现&lt;/p&gt;
&lt;p&gt;BeanWrappert接口提供操作JavaBean的方法，配置set/get方法&lt;/p&gt;
&lt;p&gt;再打开TypeConverter，该类是定义类型转换方法的接口，和&lt;span&gt;PropertyEditorRegistry&lt;/span&gt;组合使用&lt;/p&gt;
&lt;p&gt;最后我们找到PropertyEditor，它是属性编辑的核心接口，看它的子类&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201453/201902/1201453-20190204224554231-1367026675.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;稍后我们自定义属性编辑器要继承该类，重写setAsText方法&lt;/p&gt;
&lt;h2&gt;3.实例&lt;/h2&gt;
&lt;h3&gt;3.1 测试BeanWrapper&lt;/h3&gt;
&lt;p&gt;创建实体类TestModel&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestModel {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; age;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Date birth;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; good;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; times;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getAge() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; age;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setAge(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; age) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Date getBirth() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; birth;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setBirth(Date birth) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.birth =&lt;span&gt; birth;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getName() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; name;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setName(String name) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isGood() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; good;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setGood(&lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; good) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.good =&lt;span&gt; good;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; getTimes() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; times;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setTimes(&lt;span&gt;long&lt;/span&gt;&lt;span&gt; times) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.times =&lt;span&gt; times;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    @RequestMapping(value = &quot;/testWrapper&quot;, produces={&quot;application/json; charset=UTF-8&quot;&lt;span&gt;})
    @ResponseBody
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; TestModel testWrapper() {
        TestModel tm &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TestModel();
        BeanWrapper bw &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BeanWrapperImpl(tm);&lt;/span&gt;
        bw.setPropertyValue(&quot;good&quot;, &quot;1&quot;&lt;span&gt;);&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; tm;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;浏览器输入http://localhost:8080/springmvcdemo/test/testWrapper&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201453/201902/1201453-20190204225704994-655793684.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在PropertyEditorSupport(实现PropertyEditor)的子类&lt;span&gt;CustomBooleanEditor中，setAsText方法对上述现象进行了处理&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201453/201902/1201453-20190204225925143-988349117.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;3.2 测试不使用BeanWrapper&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    @RequestMapping(value = &quot;/testNotUseWrapper&quot;, produces={&quot;application/json; charset=UTF-8&quot;&lt;span&gt;})
    @ResponseBody
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; TestModel testNotUseWrapper() {
        TestModel tm &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TestModel();
        BeanWrapperImpl bw &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; BeanWrapperImpl(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
        bw.setWrappedInstance(tm);
        bw.setPropertyValue(&lt;/span&gt;&quot;good&quot;, &quot;1&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; tm;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;浏览器输入http://localhost:8080/springmvcdemo/test/testNotUseWrapper&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201453/201902/1201453-20190204230307576-796776439.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因为没有对应的属性编辑器，导致String类型“1”无法转换成Boolean类型&lt;/p&gt;
&lt;h3&gt;3.3 测试无注解对象参数绑定&lt;/h3&gt;
&lt;p&gt;在&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/Java-Starter/p/10329479.html&quot;&gt;SpringMVC源码阅读：Controller中参数解析&lt;/a&gt;我说过，ServletModelAttributeMethodProcessor处理无注解对象&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    @RequestMapping(value = &quot;testObj&quot;, produces={&quot;application/json; charset=UTF-8&quot;&lt;span&gt;})
    @ResponseBody
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Map testObj(Employee e) {
        Map resultMap &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HashMap();
        resultMap.put(&lt;/span&gt;&quot;Employee&quot;&lt;span&gt;,e);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; resultMap;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;浏览器输入http://localhost:8080/springmvcdemo/test/testObj?id=1&amp;amp;name=s&amp;amp;age=12&amp;amp;dept.id=1&amp;amp;dept.name=20&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201453/201902/1201453-20190204232507742-935799233.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;resolveArgument方法在ServletModelAttributeMethodProcessor已废弃，在其父类ModelAttributeMethodProcessor被实现&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201453/201902/1201453-20190204233417078-1801058981.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;99行获取参数别名&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201453/201902/1201453-20190204233625303-422433791.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;100行获取属性列表&lt;/p&gt;
&lt;p&gt;110行创建ExtendedServletRequestDataBinder,前文已经说过&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201453/201902/1201453-20190204233502928-217798723.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;113行绑定请求参数，此时属性列表参数绑定完毕&lt;/p&gt;
&lt;h2&gt;4.编写自定义属性编辑器&lt;/h2&gt;
&lt;p&gt;自定义属性编辑器，实现PropertyEditorSupport&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; CustomDeptEditor &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; PropertyEditorSupport {

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setAsText(String text) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IllegalArgumentException {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(text.indexOf(&quot;,&quot;) &amp;gt; 0&lt;span&gt;) {
            Dept dept &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Dept();
            String[] arr &lt;/span&gt;= text.split(&quot;,&quot;&lt;span&gt;);
            dept.setId(Integer.parseInt(arr[&lt;/span&gt;0&lt;span&gt;]));
            dept.setName(arr[&lt;/span&gt;1&lt;span&gt;]);
            setValue(dept);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException(&quot;dept param is error&quot;&lt;span&gt;);
        }
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在TestController添加@InitBinder&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @InitBinder
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; initBinderDept(WebDataBinder binder) {
        binder.registerCustomEditor(Dept.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CustomDeptEditor());
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;添加@ControllerAdvice,保证InitBinder应用到RequestMapping,就是说Controller里定义的@InitBinder和自定义的@ControllerAdvice里@InitBinder存在一个即可&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@ControllerAdvice
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; InitBinderControllerAdvice {

    @InitBinder
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; initBinder(WebDataBinder binder) {
        binder.registerCustomEditor(Dept.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CustomDeptEditor());
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;dispatcher-servlet需要配置component-scan，扫描到我们定义的ControllerAdvice&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;context:component-scan base-&lt;span&gt;package&lt;/span&gt;=&quot;org.format.demo.controlleradvice&quot; /&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;浏览器输入http://localhost:8080/springmvcdemo/test/testObj?id=1&amp;amp;name=s&amp;amp;age=12&amp;amp;dept=1,research&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201453/201902/1201453-20190204234806604-1332951988.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201453/201902/1201453-20190204234359808-480334142.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1201453/201902/1201453-20190204234812869-1387037085.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;5.总结&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;PropertyEditor是属性编辑器的接口，setAsText是核心方法，实现类PropertyEditorSupport&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;PropertyEditorRegistry接口给JavaBean注册对应的属性编辑器，实现类PropertyEditorRegistrySupport的createDefaultEditors创建默认的属性编辑器&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;TypeConverter接口，通过该接口，可以将value转换为指定类型对象，实现类TypeConverterSupport将类型转换委托给TypeConverterDelegate处理&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;BeanWrapper接口操作JavaBean，配置set/get方法和查询数据的可读可写性，实现类为BeanWrapperImpl&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;DataBinder用来set值和数据验证，WebDataBinder处理对Web请求参数到JavaBean的数据绑定&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RequestMappingHandlerAdapter调用invokeHandlerMethod方法创建WebDataBinderFactory，WebDataBinderFactory创建WebDataBinder&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最后HandlerMethodArgumentResolver解析参数&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;6.参考&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.spring.io/spring/docs/4.3.7.RELEASE/spring-framework-reference/htmlsingle/#beans-beans-conversion&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://docs.spring.io/spring/docs/4.3.7.RELEASE/spring-framework-reference/htmlsingle/#beans-beans-conversion&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.spring.io/spring/docs/current/javadoc-api/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://docs.spring.io/spring/docs/current/javadoc-api/&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/fangjian0423/p/springMVC-databind-typeconvert.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;http://www.cnblogs.com/fangjian0423/p/springMVC-databind-typeconvert.html&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/spring-projects/spring-framework&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://github.com/spring-projects/spring-framework&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;文中难免有不足，还望指出&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;年三十晚上完成了这篇文章，新年快乐&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 04 Feb 2019 15:57:00 +0000</pubDate>
<dc:creator>Rest探路者</dc:creator>
<og:description>1.前言 SpringMVC是目前J2EE平台的主流Web框架，不熟悉的园友可以看SpringMVC源码阅读入门,它交代了SpringMVC的基础知识和源码阅读的技巧 本文将通过源码(基于Spring</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Java-Starter/p/10352276.html</dc:identifier>
</item>
<item>
<title>RNN - LSTM - GRU - massquantity</title>
<link>http://www.cnblogs.com/massquantity/p/10352328.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/massquantity/p/10352328.html</guid>
<description>&lt;p&gt;循环神经网络 (Recurrent Neural Network，RNN) 是一类具有短期记忆能力的神经网络，因而常用于序列建模。本篇先总结 RNN 的基本概念，以及其训练中时常遇到梯度爆炸和梯度消失问题，再引出 RNN 的两个主流变种 —— LSTM 和 GRU。&lt;/p&gt;

&lt;center&gt;

&lt;/center&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;Vanilla RNN 的主体结构：&lt;/span&gt;&lt;/p&gt;
&lt;center&gt;

&lt;/center&gt;

&lt;p&gt;上图中 &lt;span class=&quot;math inline&quot;&gt;\(\bf{X, h, y}\)&lt;/span&gt; 都是向量，公式如下：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ % &amp;lt;![CDATA[ \begin{align} \textbf{h}_{t} &amp;amp;= f_{\textbf{W}}\left(\textbf{h}_{t-1}, \textbf{x}_{t} \right) \tag{1} \\ \textbf{h}_{t} &amp;amp;= f\left(\textbf{W}_{hx}\textbf{x}_{t} + \textbf{W}_{hh}\textbf{h}_{t-1} + \textbf{b}_{h}\right) \tag{2a} \\ \textbf{h}_{t} &amp;amp;= \textbf{tanh}\left(\textbf{W}_{hx}\textbf{x}_{t} + \textbf{W}_{hh}\textbf{h}_{t-1} + \textbf{b}_{h}\right) \tag{2b} \\ \hat{\textbf{y}}_{t} &amp;amp;= \textbf{softmax}\left(\textbf{W}_{yh}\textbf{h}_{t} + \textbf{b}_{y}\right) \tag{3} \end{align} %]]&amp;gt; \]&lt;/span&gt;&lt;br/&gt;其中 &lt;span class=&quot;math inline&quot;&gt;\(\textbf{W}_{hx} \in \mathbb{R}^{h \times x}, \; \textbf{W}_{hh} \in \mathbb{R}^{h \times h}, \; \textbf{W}_{yh} \in \mathbb{R}^{y \times h}, \; \textbf{b}_{h} \in \mathbb{R}^{h}, \; \textbf{b}_{y} \in \mathbb{R}^{y}\)&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\((2a)\)&lt;/span&gt; 式中的两个矩阵 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf{W}\)&lt;/span&gt; 可以合并：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{align*} \textbf{h}_{t} &amp;amp;= f\left(\textbf{W}_{hx}\textbf{x}_{t} + \textbf{W}_{hh}\textbf{h}_{t-1} + \textbf{b}_{h}\right) \\ &amp;amp; = f\left(\left(\textbf{W}_{hx}, \textbf{W}_{hh}\right) \begin{pmatrix} \textbf{x}_t \\ \textbf{h}_{t-1} \end{pmatrix} + \textbf{b}_{h}\right) \\ &amp;amp; = f\left(\textbf{W} \begin{pmatrix} \textbf{x}_t \\ \textbf{h}_{t-1} \end{pmatrix} + \textbf{b}_{h}\right) \end{align*} \]&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;注意到在计算时，每一 time step 中使用的参数 &lt;span class=&quot;math inline&quot;&gt;\(\textbf{W}, \; \textbf{b}\)&lt;/span&gt; 是一样的，也就是说每个步骤的参数都是共享的，这是RNN的重要特点。&lt;/p&gt;
&lt;p&gt;和普通的全连接层相比，RNN 除了输入 &lt;span class=&quot;math inline&quot;&gt;\(\textbf{x}_t\)&lt;/span&gt; 外，还有输入隐藏层上一节点 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf{h}_{t-1}\)&lt;/span&gt; ，RNN 每一层的输出就是这两个输入用矩阵 &lt;span class=&quot;math inline&quot;&gt;\(\textbf{W}_{hx}\)&lt;/span&gt;，&lt;span class=&quot;math inline&quot;&gt;\(\textbf{W}_{hh}\)&lt;/span&gt;和激活函数进行组合的结果。从 &lt;span class=&quot;math inline&quot;&gt;\((2a)\)&lt;/span&gt; 式可以看出 &lt;span class=&quot;math inline&quot;&gt;\(\textbf{x}_t\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf{h}_{t-1}\)&lt;/span&gt; 都是与 &lt;span class=&quot;math inline&quot;&gt;\(\textbf{h}_h\)&lt;/span&gt; 全连接的，下图形象展示了各个时间节点 RNN 隐藏层记忆的变化。随着时间流逝，最初的蓝色结点保留地越来越少，这意味着RNN对于长时记忆的困难。&lt;/p&gt;
&lt;center&gt;

&lt;/center&gt;

&lt;h2 id=&quot;vanishing-exploding-gradient-problems&quot;&gt;Vanishing &amp;amp; Exploding Gradient Problems&lt;/h2&gt;
&lt;p&gt;RNN 对于长时记忆的困难主要来源于梯度爆炸 / 消失问题，下面进行说明。RNN 中 Loss 的计算图示例：&lt;/p&gt;

&lt;center&gt;

&lt;/center&gt;

&lt;p&gt;总的 Loss 是每个 time step 的加和 ： &lt;span class=&quot;math inline&quot;&gt;\(\mathcal{\large{L}} (\hat{\textbf{y}}, \textbf{y}) = \sum_{t = 1}^{T} \mathcal{ \large{L} }(\hat{\textbf{y}_t}, \textbf{y}_{t})\)&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;由 &lt;strong&gt;backpropagation through time (BPTT)&lt;/strong&gt; 算法，参数的梯度为：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \frac{\partial \boldsymbol{\mathcal{L}}}{\partial \textbf{W}} = \sum_{t=1}^{T} \frac{\partial \boldsymbol{\mathcal{L}}_{t}}{\partial \textbf{W}} = \sum_{t=1}^{T} \frac{\partial \boldsymbol{\mathcal{L}}_t}{\partial \textbf{y}_{t}} \frac{\partial \textbf{y}_{t}}{\partial \textbf{h}_{t}} \overbrace{\frac{\partial \textbf{h}_{t}}{\partial \textbf{h}_{k}}}^{ \bigstar } \frac{\partial \textbf{h}_{k}}{\partial \textbf{W}} \]&lt;/span&gt;&lt;br/&gt;其中 &lt;span class=&quot;math inline&quot;&gt;\(\frac{\partial \textbf{h}_{t}}{\partial \textbf{h}_{k}}\)&lt;/span&gt; 包含一系列 &lt;span class=&quot;math inline&quot;&gt;\(\text{Jacobian}\)&lt;/span&gt; 矩阵，&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \frac{\partial \textbf{h}_{t}}{\partial \textbf{h}_{k}} = \frac{\partial \textbf{h}_{t}}{\partial \textbf{h}_{t-1}} \frac{\partial \textbf{h}_{t-1}}{\partial \textbf{h}_{t-2}} \cdots \frac{\partial \textbf{h}_{k+1}}{\partial \textbf{h}_{k}} = \prod_{i=k+1}^{t} \frac{\partial \textbf{h}_{i}}{\partial \textbf{h}_{i-1}} \]&lt;/span&gt;&lt;br/&gt;由于 RNN 中每个 time step 都是用相同的 &lt;span class=&quot;math inline&quot;&gt;\(\textbf{W}\)&lt;/span&gt; ，所以由 &lt;span class=&quot;math inline&quot;&gt;\((2a)\)&lt;/span&gt; 式可得：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \prod_{i=k+1}^{t} \frac{\partial \textbf{h}_{i}}{\partial \textbf{h}_{i-1}} = \prod_{i=k+1}^{t} \textbf{W}^\top \text{diag} \left[ f'\left(\textbf{h}_{i-1}\right) \right] \]&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;由于 &lt;span class=&quot;math inline&quot;&gt;\(\textbf{W}_{hh} \in \mathbb{R}^{h \times h}\)&lt;/span&gt; 为方阵，对其进行特征值分解：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \mathbf{W} = \mathbf{V} \, \text{diag}(\boldsymbol{\lambda}) \, \mathbf{V}^{-1} \]&lt;/span&gt;&lt;br/&gt;由于上式是连乘 &lt;span class=&quot;math inline&quot;&gt;\(\text{t}\)&lt;/span&gt; 次 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf{W}\)&lt;/span&gt; :&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \mathbf{W}^t = (\mathbf{V} \, \text{diag}(\boldsymbol{\lambda}) \, \mathbf{V}^{-1})^t = \mathbf{V} \, \text{diag}(\boldsymbol{\lambda})^t \, \mathbf{V}^{-1} \]&lt;/span&gt;&lt;br/&gt;连乘的次数多了之后，则若最大的特征值 &lt;span class=&quot;math inline&quot;&gt;\(\lambda &amp;gt;1\)&lt;/span&gt; ，会产生梯度爆炸； &lt;span class=&quot;math inline&quot;&gt;\(\lambda &amp;lt; 1\)&lt;/span&gt; ，则会产生梯度消失 。不论哪种情况，都会导致模型难以学到有用的模式。&lt;/p&gt;

&lt;p&gt;下左图显示一个 time step 中 tanh 函数的计算结果，右图显示整个神经网络的计算结果，可以清楚地看到哪个区域最容易产生梯度爆炸/消失问题。&lt;/p&gt;
&lt;center&gt;

&lt;/center&gt;

&lt;h2 id=&quot;梯度爆炸的解决办法&quot;&gt;梯度爆炸的解决办法：&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;(1) &lt;strong&gt;Truncated Backpropagation through time&lt;/strong&gt;&lt;/span&gt;：每次只 BP 固定的 time step 数，类似于 mini-batch SGD。缺点是丧失了长距离记忆的能力。&lt;/p&gt;
&lt;center&gt;

&lt;/center&gt;

&lt;p&gt;&lt;span&gt;(2) &lt;strong&gt;Clipping Gradients&lt;/strong&gt;&lt;/span&gt;： 当梯度超过一定的 threshold 后，就进行 element-wise 的裁剪，该方法的缺点是又引入了一个新的参数 threshold。同时该方法也可视为一种基于瞬时梯度大小来自适应 learning rate 的方法：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \text{if} \quad \lVert \textbf{g} \rVert \ge \text{threshold} \\[1ex] \textbf{g} \leftarrow \frac{\text{threshold}}{\lVert \textbf{g} \rVert} \textbf{g} \]&lt;/span&gt;&lt;/p&gt;
&lt;center&gt;

&lt;/center&gt;

&lt;h2 id=&quot;梯度消失的解决办法&quot;&gt;梯度消失的解决办法&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;(1)&lt;/strong&gt;&lt;/span&gt; 使用 LSTM、GRU等升级版 RNN，使用各种 gates 控制信息的流通。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;(2)&lt;/strong&gt;&lt;/span&gt; 在这篇论文 ( &lt;a href=&quot;https://arxiv.org/pdf/1602.06662.pdf&quot;&gt;&lt;span&gt;https://arxiv.org/pdf/1602.06662.pdf&lt;/span&gt;&lt;/a&gt; ) 中提出将权重矩阵 &lt;span class=&quot;math inline&quot;&gt;\(\textbf{W}\)&lt;/span&gt; 初始化为正交矩阵。正交矩阵有如下性质：&lt;span class=&quot;math inline&quot;&gt;\(A^T A =A A^T = I, \; A^T = A^{-1}\)&lt;/span&gt;， 正交矩阵的特征值的绝对值为 &lt;span class=&quot;math inline&quot;&gt;\(\text{1}\)&lt;/span&gt; 。证明如下， 对矩阵 &lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt; 有：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{align*} &amp;amp; A \mathbf{v} = \lambda \mathbf{v} \\[1ex] ||A \mathbf{v}||^2&amp;amp; = (A \mathbf{v})^\text{T} (A \mathbf{v}) \\ &amp;amp;= \mathbf{v}^\text{T}A ^{\text{T}}A \mathbf{v} \\ &amp;amp; = \mathbf{v}^{\text{T}}\mathbf{v} \\ &amp;amp; = ||\mathbf{v}||^2 \\ &amp;amp; = |\lambda|^2 ||\mathbf{v}||^2 \end{align*} \]&lt;/span&gt;&lt;br/&gt;由于 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf{v}\)&lt;/span&gt; 为特征向量，&lt;span class=&quot;math inline&quot;&gt;\(\mathbf{v} \neq 0\)&lt;/span&gt; ，所以 &lt;span class=&quot;math inline&quot;&gt;\(|\lambda| = 1\)&lt;/span&gt; ，这样连乘之后 &lt;span class=&quot;math inline&quot;&gt;\(\lambda^t\)&lt;/span&gt; 不会出现越来越小的情况。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;(3)&lt;/strong&gt;&lt;/span&gt; 反转输入序列。像在机器翻译中使用 seq2seq 模型，若使用正常序列输入，则输入序列的第一个词和输出序列的第一个词相距较远，难以学到长期依赖。将输入序列反向后，输入序列的第一个词就会和输出序列的第一个词非常接近，二者的相互关系也就比较容易学习了。这样模型可以先学前几个词的短期依赖，再学后面词的长期依赖关系。见下图正常输入顺序是 &lt;span class=&quot;math inline&quot;&gt;\(|\text{ABC}|\)&lt;/span&gt;，反向是 &lt;span class=&quot;math inline&quot;&gt;\(|\text{CBA}|\)&lt;/span&gt; ，则 &lt;span class=&quot;math inline&quot;&gt;\(\text{A}\)&lt;/span&gt; 与第一个输出词 &lt;span class=&quot;math inline&quot;&gt;\(\text{W}\)&lt;/span&gt; 接近：&lt;/p&gt;
&lt;center&gt;

&lt;/center&gt;

&lt;center&gt;

&lt;/center&gt;
&lt;hr/&gt;
&lt;p&gt;虽然 Vanilla RNN 理论上可以建立长时间间隔状态之间的依赖关系，但由于梯度爆炸或消失问题，实际上只能学到短期依赖关系。为了学到长期依赖关系，LSTM 中引入了门控机制来控制信息的累计速度，包括有选择地加入新的信息，并有选择地遗忘之前累计的信息，整个 LSTM 单元结构如下图所示：&lt;/p&gt;
&lt;center&gt;

&lt;/center&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{align} \text{input gate}&amp;amp;: \quad \textbf{i}_t = \sigma(\textbf{W}_i\textbf{x}_t + \textbf{U}_i\textbf{h}_{t-1} + \textbf{b}_i)\tag{1} \\ \text{forget gate}&amp;amp;: \quad \textbf{f}_t = \sigma(\textbf{W}_f\textbf{x}_t + \textbf{U}_f\textbf{h}_{t-1} + \textbf{b}_f) \tag{2}\\ \text{output gate}&amp;amp;: \quad \textbf{o}_t = \sigma(\textbf{W}_o\textbf{x}_t + \textbf{U}_o\textbf{h}_{t-1} + \textbf{b}_o) \tag{3}\\ \text{new memory cell}&amp;amp;: \quad \tilde{\textbf{c}}_t = \text{tanh}(\textbf{W}_c\textbf{x}_t + \textbf{U}_c\textbf{h}_{t-1} + \textbf{b}_c) \tag{4}\\ \text{final memory cell}&amp;amp; : \quad \textbf{c}_t = \textbf{f}_t \odot \textbf{c}_{t-1} + \textbf{i}_t \odot \tilde{\textbf{c}}_t \tag{5}\\ \text{final hidden state} &amp;amp;: \quad \textbf{h}_t= \textbf{o}_t \odot \text{tanh}(\textbf{c}_t) \tag{6} \end{align} \]&lt;/span&gt;&lt;br/&gt;式 $(1) \sim (4) $ 的输入都一样，因而可以合并：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{pmatrix} \textbf{i}_t \\ \textbf{f}_{t} \\ \textbf{o}_t \\ \tilde{\textbf{c}}_t \end{pmatrix} = \begin{pmatrix} \sigma \\ \sigma \\ \sigma \\ \text{tanh} \end{pmatrix} \left(\textbf{W} \begin{bmatrix} \textbf{x}_t \\ \textbf{h}_{t-1} \end{bmatrix} + \textbf{b} \right) \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;$\tilde{\textbf{c}}_t $ 为时刻 t 的候选状态，&lt;span class=&quot;math inline&quot;&gt;\(\textbf{i}_t\)&lt;/span&gt; 控制 &lt;span class=&quot;math inline&quot;&gt;\(\tilde{\textbf{c}}_t\)&lt;/span&gt; 中有多少新信息需要保存，&lt;span class=&quot;math inline&quot;&gt;\(\textbf{f}_{t}\)&lt;/span&gt; 控制上一时刻的内部状态 &lt;span class=&quot;math inline&quot;&gt;\(\textbf{c}_{t-1}\)&lt;/span&gt; 需要遗忘多少信息，&lt;span class=&quot;math inline&quot;&gt;\(\textbf{o}_t\)&lt;/span&gt; 控制当前时刻的内部状态 &lt;span class=&quot;math inline&quot;&gt;\(\textbf{c}_t\)&lt;/span&gt; 有多少信息需要输出给外部状态 &lt;span class=&quot;math inline&quot;&gt;\(\textbf{h}_t\)&lt;/span&gt; 。&lt;/p&gt;
&lt;p&gt;下表显示 forget gate 和 input gate 的关系，可以看出 forget gate 其实更应该被称为 “remember gate”， 因为其开启时之前的记忆信息 &lt;span class=&quot;math inline&quot;&gt;\(\textbf{c}_{t-1}\)&lt;/span&gt; 才会被保留，关闭时则会遗忘所有：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;保留上一时刻的状态 &lt;span class=&quot;math inline&quot;&gt;\(\textbf{c}_{t-1}\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;保留上一时刻 &lt;span class=&quot;math inline&quot;&gt;\(\textbf{c}_{t-1}\)&lt;/span&gt; 和添加新信息 &lt;span class=&quot;math inline&quot;&gt;\(\tilde{\textbf{c}}_t\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;清空历史信息，引入新信息 &lt;span class=&quot;math inline&quot;&gt;\(\tilde{\textbf{c}}_t\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;清空所有新旧信息&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;对比 Vanilla RNN，可以发现在时刻 t，Vanilla RNN 通过 &lt;span class=&quot;math inline&quot;&gt;\(\textbf{h}_t\)&lt;/span&gt; 来保存和传递信息，上文已分析了如果时间间隔较大容易产生梯度消失的问题。 LSTM 则通过记忆单元 &lt;span class=&quot;math inline&quot;&gt;\(\textbf{c}_t\)&lt;/span&gt; 来传递信息，通过 &lt;span class=&quot;math inline&quot;&gt;\(\textbf{i}_t\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\(\textbf{f}_{t}\)&lt;/span&gt; 的调控，&lt;span class=&quot;math inline&quot;&gt;\(\textbf{c}_t\)&lt;/span&gt; 可以在 t 时刻捕捉到某个关键信息，并有能力将此关键信息保存一定的时间间隔。&lt;/p&gt;

&lt;p&gt;原始的 LSTM 中是没有 forget gate 的，即：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \textbf{c}_t = \textbf{c}_{t-1} + \textbf{i}_t \odot \tilde{\textbf{c}}_t \]&lt;/span&gt;&lt;br/&gt;这样 &lt;span class=&quot;math inline&quot;&gt;\(\frac{\partial \textbf{c}_t}{\partial \textbf{c}_{t-1}}\)&lt;/span&gt; 恒为 &lt;span class=&quot;math inline&quot;&gt;\(\text{1}\)&lt;/span&gt; 。但是这样 &lt;span class=&quot;math inline&quot;&gt;\(\textbf{c}_t\)&lt;/span&gt; 会不断增大，容易饱和从而降低模型性能。后来引入了 forget gate ，则梯度变为 &lt;span class=&quot;math inline&quot;&gt;\(\textbf{f}_{t}\)&lt;/span&gt; ，事实上连乘多个 &lt;span class=&quot;math inline&quot;&gt;\(\textbf{f}_{t} \in (0,1)\)&lt;/span&gt; 同样会导致梯度消失，但是 LSTM 的一个初始化技巧就是将 forget gate 的 bias 置为正数（例如 1 或者 5，如 tensorflow 中的默认值就是 &lt;span class=&quot;math inline&quot;&gt;\(1.0\)&lt;/span&gt; ），这样一来模型刚开始训练时 forget gate 的值都接近 1，不会发生梯度消失 (反之若 forget gate 的初始值过小则意味着前一时刻的大部分信息都丢失了，这样很难捕捉到长距离依赖关系)。 随着训练过程的进行，forget gate 就不再恒为 1 了。不过，一个训好的模型里各个 gate 值往往不是在 [0, 1] 这个区间里，而是要么 0 要么 1，很少有类似 0.5 这样的中间值，其实相当于一个二元的开关。假如在某个序列里，forget gate 全是 1，那么梯度不会消失；某一个 forget gate 是 0，模型选择遗忘上一时刻的信息。&lt;/p&gt;

&lt;p&gt;LSTM 的一种变体增加 peephole 连接，这样三个 gate 不仅依赖于 &lt;span class=&quot;math inline&quot;&gt;\(\textbf{x}_t\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\(\textbf{h}_{t-1}\)&lt;/span&gt;，也依赖于记忆单元 &lt;span class=&quot;math inline&quot;&gt;\(\textbf{c}\)&lt;/span&gt; ：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{align*} \text{input gate}&amp;amp;: \quad \textbf{i}_t = \sigma(\textbf{W}_i\textbf{x}_t + \textbf{U}_i\textbf{h}_{t-1} + \textbf{V}_i\textbf{c}_{t-1} + \textbf{b}_i) \\ \text{forget gate}&amp;amp;: \quad \textbf{f}_t = \sigma(\textbf{W}_f\textbf{x}_t + \textbf{U}_f\textbf{h}_{t-1} + \textbf{V}_f\textbf{c}_{t-1} +\textbf{b}_f) \\ \text{output gate}&amp;amp;: \quad \textbf{o}_t = \sigma(\textbf{W}_o\textbf{x}_t + \textbf{U}_o\textbf{h}_{t-1} + \textbf{V}_o\textbf{c}_{t} +\textbf{b}_o) \\ \end{align*} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;注意 input gate 和 forget gate 连接的是 &lt;span class=&quot;math inline&quot;&gt;\(\textbf{c}_{t-1}\)&lt;/span&gt; ，而 output gate 连接的是 &lt;span class=&quot;math inline&quot;&gt;\(\textbf{c}_t\)&lt;/span&gt; 。下图来自 &lt;a href=&quot;https://arxiv.org/pdf/1503.04069.pdf&quot;&gt;&lt;span&gt;《LSTM: A Search Space Odyssey》&lt;/span&gt;&lt;/a&gt;，标注了 peephole 连接的样貌。&lt;/p&gt;
&lt;center&gt;

&lt;/center&gt;

&lt;center&gt;

&lt;/center&gt;
&lt;hr/&gt;
&lt;p&gt;相比于 Vanilla RNN (每个 time step 有一个输入 &lt;span class=&quot;math inline&quot;&gt;\(\textbf{x}_t\)&lt;/span&gt; )，从上面的 &lt;span class=&quot;math inline&quot;&gt;\((1) \sim (4)\)&lt;/span&gt; 式可以看出 一个 LSTM 单元有四个输入 (如下图，不考虑 peephole) ，因而参数是 Vanilla RNN 的四倍，带来的结果是训练起来很慢，因而在2014年 Cho 等人提出了 &lt;a href=&quot;https://arxiv.org/pdf/1409.1259.pdf&quot;&gt;&lt;span&gt;GRU&lt;/span&gt;&lt;/a&gt; ，对 LSTM 进行了简化，在不影响效果的前提下加快了训练速度。&lt;/p&gt;

&lt;center&gt;

&lt;/center&gt;

&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(\large\scr{LSTM:}\)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \normalsize \begin{align} \text{input gate}&amp;amp;: \quad \textbf{i}_t = \sigma(\textbf{W}_i\textbf{x}_t + \textbf{U}_i\textbf{h}_{t-1} + \textbf{b}_i)\tag{1} \\ \text{forget gate}&amp;amp;: \quad \textbf{f}_t = \sigma(\textbf{W}_f\textbf{x}_t + \textbf{U}_f\textbf{h}_{t-1} + \textbf{b}_f) \tag{2}\\ \text{output gate}&amp;amp;: \quad \textbf{o}_t = \sigma(\textbf{W}_o\textbf{x}_t + \textbf{U}_o\textbf{h}_{t-1} + \textbf{b}_o) \tag{3}\\ \text{new memory cell}&amp;amp;: \quad \tilde{\textbf{c}}_t = \text{tanh}(\textbf{W}_c\textbf{x}_t + \textbf{U}_c\textbf{h}_{t-1} + \textbf{b}_c) \tag{4}\\ \text{final memory cell}&amp;amp; : \quad \textbf{c}_t = \textbf{f}_t \odot \textbf{c}_{t-1} + \textbf{i}_t \odot \tilde{\textbf{c}}_t \tag{5}\\ \text{final hidden state} &amp;amp;: \quad \textbf{h}_t= \textbf{o}_t \odot \text{tanh}(\textbf{c}_t) \tag{6} \end{align} \]&lt;/span&gt;&lt;br/&gt;在式 &lt;span class=&quot;math inline&quot;&gt;\((5)​\)&lt;/span&gt; 中 forget gate 和 input gate 是互补关系，因而比较冗余，GRU 将其合并为一个 update gate。同时 GRU 也不引入额外的记忆单元 (LSTM 中的 &lt;span class=&quot;math inline&quot;&gt;\(\textbf{c}​\)&lt;/span&gt;) ，而是直接在当前状态 &lt;span class=&quot;math inline&quot;&gt;\(\textbf{h}_t​\)&lt;/span&gt; 和历史状态 &lt;span class=&quot;math inline&quot;&gt;\(\textbf{h}_{t-1}​\)&lt;/span&gt; 之间建立线性依赖关系。&lt;/p&gt;
&lt;center&gt;

&lt;/center&gt;

&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(\large\scr{GRU:}\)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \normalsize \begin{align} \text{reset gate}&amp;amp;: \quad \textbf{r}_t = \sigma(\textbf{W}_r\textbf{x}_t + \textbf{U}_r\textbf{h}_{t-1} + \textbf{b}_r)\tag{7} \\ \text{update gate}&amp;amp;: \quad \textbf{z}_t = \sigma(\textbf{W}_z\textbf{x}_t + \textbf{U}_z\textbf{h}_{t-1} + \textbf{b}_z)\tag{8} \\ \text{new memory cell}&amp;amp;: \quad \tilde{\textbf{h}}_t = \text{tanh}(\textbf{W}_h\textbf{x}_t + \textbf{r}_t \odot (\textbf{U}_h\textbf{h}_{t-1}) + \textbf{b}_h) \tag{9}\\ \text{final hidden state}&amp;amp;: \quad \textbf{h}_t = \textbf{z}_t \odot \textbf{h}_{t-1} + (1 - \textbf{z}_t) \odot \tilde{\textbf{h}}_t \tag{10} \end{align} \]&lt;/span&gt;&lt;br/&gt;$ \tilde{\textbf{h}}_t $ 为时刻 t 的候选状态，&lt;span class=&quot;math inline&quot;&gt;\(\textbf{r}_t\)&lt;/span&gt; 控制 $ \tilde{\textbf{h}}_t $ 有多少依赖于上一时刻的状态 &lt;span class=&quot;math inline&quot;&gt;\(\textbf{h}_{t-1}\)&lt;/span&gt; ，如果 &lt;span class=&quot;math inline&quot;&gt;\(\textbf{r}_t = 1\)&lt;/span&gt; ，则式 &lt;span class=&quot;math inline&quot;&gt;\((9)\)&lt;/span&gt; 与 Vanilla RNN 一致，对于短依赖的 GRU 单元，reset gate 通常会更新频繁。&lt;span class=&quot;math inline&quot;&gt;\(\textbf{z}_t\)&lt;/span&gt; 控制当前的内部状态 &lt;span class=&quot;math inline&quot;&gt;\(\textbf{h}_t\)&lt;/span&gt; 中有多少来自于上一时刻的 &lt;span class=&quot;math inline&quot;&gt;\(\textbf{h}_{t-1}\)&lt;/span&gt; 。如果 &lt;span class=&quot;math inline&quot;&gt;\(\textbf{z}_t = 1\)&lt;/span&gt; ，则会每步都传递同样的信息，和当前输入 &lt;span class=&quot;math inline&quot;&gt;\(\textbf{x}_t\)&lt;/span&gt; 无关。&lt;/p&gt;

&lt;p&gt;另一方面看，&lt;span class=&quot;math inline&quot;&gt;\(\textbf{r}_t\)&lt;/span&gt; 与 LSTM 中的 &lt;span class=&quot;math inline&quot;&gt;\(\textbf{o}_t\)&lt;/span&gt; 角色有些类似，因为将上面的 &lt;span class=&quot;math inline&quot;&gt;\((6)\)&lt;/span&gt; 式代入 &lt;span class=&quot;math inline&quot;&gt;\((4)\)&lt;/span&gt; 式可以得到：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{align*} \tilde{\textbf{c}}_t &amp;amp;= \text{tanh}(\textbf{W}_c\textbf{x}_t + \textbf{U}_c\textbf{h}_{t-1} + \textbf{b}_c) \\ \textbf{h}_t &amp;amp;= \textbf{o}_t \odot \text{tanh}(\textbf{c}_t) \end{align*} \quad \Longrightarrow \quad \tilde{\textbf{c}}_t = \text{tanh}(\textbf{W}_c\textbf{x}_t + \textbf{U}_c \left(\textbf{o}_{t-1} \odot \text{tanh}(\textbf{c}_{t-1})\right) + \textbf{b}_c) \]&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;最后是 cs224n 中提出的 RNN 训练 tips：&lt;/p&gt;
&lt;center&gt;

&lt;/center&gt;

&lt;p&gt;/&lt;/p&gt;
</description>
<pubDate>Mon, 04 Feb 2019 15:55:00 +0000</pubDate>
<dc:creator>massquantity</dc:creator>
<og:description>循环神经网络 (Recurrent Neural Network，RNN) 是一类具有短期记忆能力的神经网络，因而常用于序列建模。本篇先总结 RNN 的基本概念，以及其训练中时常遇到梯度爆炸和梯度消失</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/massquantity/p/10352328.html</dc:identifier>
</item>
<item>
<title>ThinkInJava之内部类 - 爱我-中华</title>
<link>http://www.cnblogs.com/jinliang374003909/p/10351877.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jinliang374003909/p/10351877.html</guid>
<description>&lt;h3&gt;一：内部类概述&lt;/h3&gt;
&lt;p&gt;　　将一个类的定义放在另一个类的内部，这就是内部类。内部类是Java一种非常有用的特征，因为他允许你把一些逻辑相关的数据组织在一起，并控制它的可见性。&lt;/p&gt;
&lt;h3&gt;二：内部类的创建&lt;/h3&gt;
&lt;p&gt;　　我们都知道类的创建语法（简略）如下　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[&lt;span&gt;public&lt;/span&gt; |...] &lt;span&gt;class&lt;/span&gt; 类名 [&lt;span&gt;implements&lt;/span&gt;|&lt;span&gt;....]{
    定义属性（注意不同的修饰符（如public ....））&lt;/span&gt;&lt;span&gt;
    定义方法语法（构造方法或普通方法）                  
}    &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而内部类的创建就是把该类放在外部类的 同属性的位置或方法（包括构造方法）内    定义例下（希望大家可以看懂）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; OutClass{&lt;br/&gt;　　public  OutClass（）{ //构造方法内创建内部类&lt;br/&gt;　　　　class C{}&lt;br/&gt;　　}
    （修饰符）&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; A{} #局部内部类（同属性的位置）
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; B getB(){  #简称方法内部类（方法的内部）
         &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; B{}&lt;br/&gt;return new B();
    }  
}&lt;/span&gt;　　&lt;br/&gt;####在次都忽略了修饰符，如果加上了修饰符如（static | public |private），会影响内部类的可见范围或和外围类的关系（如static），详细信息可参考修饰&lt;br/&gt;符（和修饰符的用法及其相识）的讲解，和下文，因为篇幅有限不可能全面讲到。
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;三：外部类访问（创建）内部类（和内部类的修饰符有关系（如private public  static 。。。。））&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;内部类的创建方式有两种&lt;br/&gt;方法一：在外围类环境下（），直接通过new 关键字和普通类一样创建&lt;br/&gt;方法二：通过外围类实例创建，具体细节如下&lt;br/&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Parcel2 {
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Contents{
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; i = 11&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; values() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; i;
        }
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Contents contents() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt;  Contents(); #在外部类环境内创建（方法一）
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        Parcel2 parcel2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Parcel2();
                #注意这是两种创建内部类的方法
        Contents contents &lt;/span&gt;=&lt;span&gt; parcel2.contents(); #在外部类环境内直接创建
        Contents contents &lt;/span&gt;= parcel2.&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Contents();#通过外部类对象和关键字new创建内部类 （方法二）    
    }    
}    &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;备注：其它很多博客对内部类做了分类，这些分类也不外乎就是定义内部时用的修饰符和内部类定义位置的不同给内部起的名字而已。例如&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;成员内部类&lt;/span&gt;：同属性一样定义（修饰符一般是public或private）。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;匿名内部类&lt;/span&gt;：即一个方法接受一个接口（interfaceA）类型的类。在其它类中调用这个方法，直接通过new interfaceA（）这个接口并实现了该接口的所有方法，new interfaceA就是匿名内部了。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;方法内部类&lt;/span&gt;：就是定义在外类普通方法内的内部类。&lt;/p&gt;
&lt;p&gt;      &lt;span&gt;局部内部类&lt;/span&gt;：就是定义在构造方法内的内部类。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;嵌套内部类&lt;/span&gt;：就是把定义内部了时用static关键字修饰的内部类。这个类我想多说点，普通内部类对象隐式的保存了一个外部类对象的引用，然而内部类通过static修饰就不一样了，该内部类就和外部类完全分离了，即不需要通过外部类对象创建内部类，内部了没有关联的外部类引用了。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;接口内部类&lt;/span&gt;：外部类不是一个类，而是一个接口，接口内定义了一个内部类，该内部类可以实现自己，案例如五 接口内部了&lt;/p&gt;
&lt;h3&gt;四：关键字this 和new&lt;/h3&gt;
&lt;p&gt;4.1  new 的用法已经介绍过（通过外部类实例创建内部类实例）&lt;/p&gt;
&lt;p&gt;4.2 this 通过OutClass.this 方式可访问创建自自己的的外部类实例（非常重要注意理解，有助于帮助我们理解为什么外部类对象的属性（包括private）完全报漏给内部类，检验如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; OutClass {
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; print() {
        System.out.println(&lt;/span&gt;&quot;id:&quot;+ &lt;span&gt;this&lt;/span&gt;.hashCode()+&quot;我是外部类的方法&quot;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; InnerClass{
        &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; print() {
            System.out.println(&lt;/span&gt;&quot;我是内部类的方法&quot;&lt;span&gt;);
            System.out.println(&lt;/span&gt;&quot;___________&quot;&lt;span&gt;);
            OutClass.&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.print();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;内部类内访问创建它的外部类实例，并调用外部类的方法&lt;/span&gt;
&lt;span&gt;        }
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        OutClass outClass &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; OutClass();
        System.out.println(&lt;/span&gt;&quot;id:&quot; +&lt;span&gt; outClass.hashCode());
        InnerClass innerClass &lt;/span&gt;= outClass.&lt;span&gt;new&lt;/span&gt;&lt;span&gt; InnerClass();
        innerClass.print();
    }
}
结果：
id:&lt;/span&gt;865113938&lt;span&gt;
我是内部类的方法
___________
id:865113938我是外部类的方法&lt;br/&gt;分析结果，我们发现打印的hashCode()值相同，可知两次打印都是同一个对象的引用地址。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt; 五：接口内部类&lt;/h3&gt;
&lt;p&gt;　　正常情况下，不能在接口内放置任何代码，但嵌套类可以作为接口的一部分，你放入接口中的任何类都自动转化为public和static，因为类是static，只是将&lt;/p&gt;
&lt;p&gt;嵌套类置于接口的命名空间内，这并不违反接口规则。你可以在内部类中实现外围接口如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
public interface ClassInInterface {&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; howdy();    
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt; Test &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; ClassInInterface{
        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; howdy() {
            System.out.println(&lt;/span&gt;&quot;我是接口内部类接口&quot;&lt;span&gt;);
        };
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
            &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Test().howdy();
        }    
    }    
}&lt;br/&gt;注意：在编译器内（eclipse），无法直接运行该main方法，可通过Javac编译代码，然后用Java命令运行&lt;br/&gt;备注：如果你想创建某些公共代码，只想让默些特定类（实现了该接口的类）拥有。就可用该接口内部了特性。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
测试：ClassInInterface
&lt;/pre&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;strong&gt;public&lt;/strong&gt; &lt;span class=&quot;s1&quot;&gt;&lt;strong&gt;class&lt;/strong&gt; ClassInInterfaceImpl &lt;span class=&quot;s1&quot;&gt;&lt;strong&gt;implements&lt;/strong&gt; ClassInInterface{&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;&lt;span class=&quot;s2&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;strong&gt;public&lt;/strong&gt; &lt;span class=&quot;s1&quot;&gt;&lt;strong&gt;void&lt;/strong&gt; howdy() {&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;strong&gt;new&lt;/strong&gt; Test().howdy();&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;System.&lt;span class=&quot;s3&quot;&gt;&lt;strong&gt;&lt;em&gt;out&lt;/em&gt;&lt;/strong&gt;.println(&lt;span class=&quot;s4&quot;&gt;&quot;我自己的方法&quot;);&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;strong&gt;public&lt;/strong&gt; &lt;span class=&quot;s1&quot;&gt;&lt;strong&gt;static&lt;/strong&gt; &lt;span class=&quot;s1&quot;&gt;&lt;strong&gt;void&lt;/strong&gt; main(String[] &lt;span class=&quot;s5&quot;&gt;args) {&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;ClassInInterfaceImpl &lt;span class=&quot;s5&quot;&gt;classInInterfaceImpl = &lt;span class=&quot;s1&quot;&gt;&lt;strong&gt;new&lt;/strong&gt; ClassInInterfaceImpl();&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s2&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;classInInterfaceImpl&lt;span class=&quot;s2&quot;&gt;.howdy();&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;}&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;em&gt;结果：&lt;/em&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;我是接口内部类接口&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;我自己的方法&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;59.5&quot;&gt;
&lt;h3 class=&quot;p1&quot;&gt;六：关于使用内部类的一些小结&lt;/h3&gt;
&lt;p class=&quot;p1&quot;&gt;　　6.1:解决了java多重继承的问题。比如有个类需要继承其它两个类，然而Java只支持单继承，故我们可以通过编写一个内部类来继承另一个类的我们需要的类（当然我们也可以通过组合的方式来完成相识功能）&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;　　6.2:封装一些功能，只让特定的类拥有该方法。例如接口内部类，只有实现了该接口的类才拥有使用特定功能。&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;　　6.3：一个类中要实现一个接口方法的不同功能。&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;　何时（什么情况下）使用内部类？请注意这个问题(引用ThinkInJava)，如果只是需要一个接口的引用，为什么不通过外围类实现那个接口呢？答案是：如果这能满足需求，那么就行该这样做（即不用内部类）&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;同时，因为内部类引用了外部类的对象的地址，导致外部类始终有一个对象在引用他，如果不刻意手动清空内部类，就会导致内存泄漏。如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Clear {
    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; finalize() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
        &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.finalize();
        System.out.println(&lt;/span&gt;&quot;垃圾回收器要清理我&quot;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {    
        Clear clear &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Clear();
        代码1.&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;InnerClass innerClass = clear.new InnerClass();
        代码2.&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;innerClass = null&lt;br/&gt;　　　　　代码3.//&lt;/span&gt;&lt;em&gt;new Clear().&lt;/em&gt;new InnerClass()&lt;br/&gt;clear = &lt;span&gt;null&lt;/span&gt;;&lt;span&gt;//&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        System.gc();&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;    }
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; InnerClass{    
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果：垃圾回收器要清理我&lt;/p&gt;
&lt;p&gt;如果我们把代码1注射打开，就不会执行finalize()方法，必须同时把代码2也要打开。如果是代码3的写法？那么垃圾怎么回收外部类呢？？（就导致了内存泄漏）&lt;/p&gt;

&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;备注：在thinkInJava中内部类这一节讲到了闭包的概念，他是这样定义闭包的：闭包是一个可调用的对象，它记录了一些信息，这些信息来自创建它的作用&lt;em id=&quot;__mceDel&quot;&gt;域。通过这个定义，可以看出内部类是面向对象的闭包，它不仅包含外围类对象的信息，还自动拥有一个指向外部类的引用，在此作用域内，内部类可以有权操作所有成员，包括private成员。&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;

&lt;/div&gt;
</description>
<pubDate>Mon, 04 Feb 2019 13:50:00 +0000</pubDate>
<dc:creator>爱我-中华</dc:creator>
<og:description>一：内部类概述 将一个类的定义放在另一个类的内部，这就是内部类。内部类是Java一种非常有用的特征，因为他允许你把一些逻辑相关的数据组织在一起，并控制它的可见性。 二：内部类的创建 我们都知道类的创建</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jinliang374003909/p/10351877.html</dc:identifier>
</item>
<item>
<title>进程控制概念简介 多线程上篇（三） - noteless</title>
<link>http://www.cnblogs.com/noteless/p/10350215.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/noteless/p/10350215.html</guid>
<description>&lt;h3&gt;&lt;span&gt;进程控制&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;进程的基本数据信息是操作系统控制管理进程的数据集合，这些信息就是用来控制进程的，此处我们说的进程控制就是进程的管理。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如进程有状态，那么进程的创建、终止，状态的切换，这都不是进程自主进行的，都是通过操作系统进行管理的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如下图所示，所有的相关数据都是操作系统用来管理维护进程的&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190203130839887-1571483452.png&quot;&gt;&lt;img title=&quot;image_5c567789_1f96&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190203130851862-1250208514.png&quot; alt=&quot;image_5c567789_1f96&quot; width=&quot;780&quot; height=&quot;344&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;操作系统抽象出进程概念的核心是为了运行程序&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;所以进程的执行态是最为核心的&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其他的状态则是为了更好的控制管理进程以及进程的并发执行而附加的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;所以，一定程度上来讲，操作系统对于进程的控制，可以认为是对于进程的不同状态之间完成切换所需要做的一系列事件处理&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以核心的操作有&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;进程的创建&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;进程的终止&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;进程的阻塞与唤醒&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;进程的挂起与激活&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;以下为进程控制的核心操作的思维导图&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190203130854103-2060579949.png&quot;&gt;&lt;img title=&quot;image_5c56778a_7652&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190203130858229-1713804126.png&quot; alt=&quot;image_5c56778a_7652&quot; width=&quot;1277&quot; height=&quot;2696&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;小结&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;进程的控制就是操作系统对进程的主要管理工作，最重要的就是状态的切换维护&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;每种状态都有不同的引发事件，每种状态又有各自不同的处理步骤和过程，整个进程控制主要就是涉及这些内容。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本文主要就是对这些状态进行简单的描述，以更好地对“进程的控制”这个概念有一个透彻的理解&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上图中的思维导图是进程控制的核心&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;必须要理解：操作系统对于进程的控制就是对于这些状态的切换，以及切换所需要的数据维护&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 04 Feb 2019 10:49:00 +0000</pubDate>
<dc:creator>noteless</dc:creator>
<og:description>进程的控制，是操作系统对于程序的运行提出进程概念之后，对于进程的详细管理，归根结底是对于进程状态的切换以及维护，能够做好进程状态的切换以及维护就能够做到进程的切换，就能够实现并发</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/noteless/p/10350215.html</dc:identifier>
</item>
<item>
<title>Mybatis关系映射 - 风沙迷了眼</title>
<link>http://www.cnblogs.com/fsmly/p/10339619.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fsmly/p/10339619.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;一、一对一关系映射&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;使用resultType+包装类实现&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;/strong&gt;1、假设问题背景是要求在某一个购物平台的后台程序中添加一个这样的功能：查询某个订单的信息和下该订单的用户信息。首先我们可以知道，一般这样的平台上面，某一笔订单只属于某一个用户，从这个角度来看，可以作为一对一的参考模型&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　①首先创建数据表user（用户表）&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt; `&lt;span&gt;user&lt;/span&gt;&lt;span&gt;` (
  `uid` &lt;/span&gt;&lt;span&gt;INT&lt;/span&gt;(&lt;span&gt;11&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt; AUTO_INCREMENT,
  `username` &lt;/span&gt;&lt;span&gt;VARCHAR&lt;/span&gt;(&lt;span&gt;255&lt;/span&gt;) &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
  `password` &lt;/span&gt;&lt;span&gt;VARCHAR&lt;/span&gt;(&lt;span&gt;255&lt;/span&gt;) &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
  `sex` &lt;/span&gt;&lt;span&gt;VARCHAR&lt;/span&gt;(&lt;span&gt;255&lt;/span&gt;) &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
  &lt;/span&gt;&lt;span&gt;PRIMARY&lt;/span&gt; &lt;span&gt;KEY&lt;/span&gt;&lt;span&gt; (`uid`)
) ENGINE&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;INNODB AUTO_INCREMENT&lt;span&gt;=&lt;/span&gt;&lt;span&gt;9&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; CHARSET&lt;span&gt;=&lt;/span&gt;utf8
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　创建orders表（所用的订单表）&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt;&lt;span&gt; `orders` (
  `oid` &lt;/span&gt;&lt;span&gt;INT&lt;/span&gt;(&lt;span&gt;11&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt; AUTO_INCREMENT,
  `total` &lt;/span&gt;&lt;span&gt;DOUBLE&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
  `ordertime` &lt;/span&gt;&lt;span&gt;DATETIME&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
  `name` &lt;/span&gt;&lt;span&gt;VARCHAR&lt;/span&gt;(&lt;span&gt;20&lt;/span&gt;) &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
  `uid` &lt;/span&gt;&lt;span&gt;INT&lt;/span&gt;(&lt;span&gt;11&lt;/span&gt;) &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
  &lt;/span&gt;&lt;span&gt;PRIMARY&lt;/span&gt; &lt;span&gt;KEY&lt;/span&gt;&lt;span&gt; (`oid`),
  &lt;/span&gt;&lt;span&gt;KEY&lt;/span&gt;&lt;span&gt; `FKC3DF62E5AA3D9C7` (`uid`),
  &lt;/span&gt;&lt;span&gt;CONSTRAINT&lt;/span&gt; `FKC3DF62E5AA3D9C7` &lt;span&gt;FOREIGN&lt;/span&gt; &lt;span&gt;KEY&lt;/span&gt; (`uid`) &lt;span&gt;REFERENCES&lt;/span&gt; `&lt;span&gt;user&lt;/span&gt;&lt;span&gt;` (`uid`)
) ENGINE&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;INNODB AUTO_INCREMENT&lt;span&gt;=&lt;/span&gt;&lt;span&gt;9004&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; CHARSET&lt;span&gt;=&lt;/span&gt;utf8
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201901/1368768-20190130152941469-1362209365.png&quot; alt=&quot;&quot; width=&quot;397&quot; height=&quot;180&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　②创建User和Order的实体类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;&lt;img id=&quot;code_img_closed_c944adf9-b9a8-4331-b6ff-d8b11f57057a&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_c944adf9-b9a8-4331-b6ff-d8b11f57057a&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_c944adf9-b9a8-4331-b6ff-d8b11f57057a&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;67&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; cn.mybatis.po;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; User {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; uid;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String username;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String password;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String address;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String sex;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getUid() {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; uid;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setUid(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; uid) {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.uid =&lt;span&gt; uid;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getUsername() {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; username;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getPassword() {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; password;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getAddress() {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; address;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getSex() {
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; sex;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; 
&lt;span&gt;34&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setUsername(String username) {
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.username =&lt;span&gt; username;
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; 
&lt;span&gt;38&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setPassword(String password) {
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.password =&lt;span&gt; password;
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; 
&lt;span&gt;42&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setAddress(String address) {
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.address =&lt;span&gt; address;
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; 
&lt;span&gt;46&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setSex(String sex) {
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.sex =&lt;span&gt; sex;
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; 
&lt;span&gt;50&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; User(String username, String password, String address, String sex) {
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.username =&lt;span&gt; username;
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.password =&lt;span&gt; password;
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.address =&lt;span&gt; address;
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.sex =&lt;span&gt; sex;
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; 
&lt;span&gt;57&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; User() {
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; 
&lt;span&gt;60&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &quot;User{&quot; +
&lt;span&gt;63&lt;/span&gt;                 &quot;uid=&quot; + uid +
&lt;span&gt;64&lt;/span&gt;                 &quot;, username='&quot; + username + '\'' +
&lt;span&gt;65&lt;/span&gt;                 &quot;, password='&quot; + password + '\'' +
&lt;span&gt;66&lt;/span&gt;                 &quot;, address='&quot; + address + '\'' +
&lt;span&gt;67&lt;/span&gt;                 &quot;, sex='&quot; + sex + '\'' +
&lt;span&gt;68&lt;/span&gt;                 '}'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;User类&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_56c257cb-635b-418a-90fe-e5f10520e773&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_56c257cb-635b-418a-90fe-e5f10520e773&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_56c257cb-635b-418a-90fe-e5f10520e773&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; cn.mybatis.po;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Date;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Order {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; oid;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; total;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Date ordettime;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getOid() {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; oid;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setOid(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; oid) {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.oid =&lt;span&gt; oid;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; getTotal() {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; total;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setTotal(&lt;span&gt;double&lt;/span&gt;&lt;span&gt; total) {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.total =&lt;span&gt; total;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Date getOrdettime() {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ordettime;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setOrdettime(Date ordettime) {
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.ordettime =&lt;span&gt; ordettime;
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getName() {
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; name;
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; 
&lt;span&gt;40&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setName(String name) {
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; 
&lt;span&gt;44&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &quot;Order{&quot; +
&lt;span&gt;47&lt;/span&gt;                 &quot;oid=&quot; + oid +
&lt;span&gt;48&lt;/span&gt;                 &quot;, total=&quot; + total +
&lt;span&gt;49&lt;/span&gt;                 &quot;, ordettime=&quot; + ordettime +
&lt;span&gt;50&lt;/span&gt;                 &quot;, name='&quot; + name + '\'' +
&lt;span&gt;51&lt;/span&gt;                 '}'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;Order类&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;　　③用于需要同时查询User和Order的信息，所以需要用到&lt;a href=&quot;https://www.cnblogs.com/fsmly/p/10335456.html&quot; target=&quot;_blank&quot;&gt;上一篇&lt;/a&gt;中讲到的POJO输出映射类型。具体来说就是，需要自定义一个OrderPoJo，其中包含我们要查询的Order和User信息，定义的OrderPoJo类型如下（这里我们可以使用继承的方式，如果我们查询结果中哪一个类的要查询结果多就继承该类，可以简便包装类的编写）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; cn.mybatis.po;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; OrderPoJo &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Order{
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String username;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String address;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String sex;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getUsername() {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; username;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setUsername(String username) {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.username =&lt;span&gt; username;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getAddress() {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; address;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setAddress(String address) {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.address =&lt;span&gt; address;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getSex() {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; sex;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setSex(String sex) {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.sex =&lt;span&gt; sex;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &quot;OrderPoJo{&quot; +
&lt;span&gt;36&lt;/span&gt;                 &lt;span&gt;super&lt;/span&gt;.toString() +
&lt;span&gt;37&lt;/span&gt;                 &quot;username='&quot; + username + '\'' +
&lt;span&gt;38&lt;/span&gt;                 &quot;, address='&quot; + address + '\'' +
&lt;span&gt;39&lt;/span&gt;                 &quot;, sex='&quot; + sex + '\'' +
&lt;span&gt;40&lt;/span&gt;                 '}'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　④编写好对应的实体类和包装类之后就开始写，mapper配置文件和mapper.java。mapper配置文件中我们只需要根据问题背景写好相应的Sql语句就好&lt;/p&gt;
&lt;p&gt; 　　这是编写好Sql的Mapper配置文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; &lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE mapper
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;mapper为根元素，namespace指定了命名空间&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mapper &lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt;=&quot;cn.mybatis.mapper.OrderMapper&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;select &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;findOrderAndUser&quot;&lt;/span&gt;&lt;span&gt; parameterType&lt;/span&gt;&lt;span&gt;=&quot;int&quot;&lt;/span&gt;&lt;span&gt; resultType&lt;/span&gt;&lt;span&gt;=&quot;orderPoJo&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        SELECT orders.*,
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;                user.username,user.sex,user.address
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;                FROM orders,USER
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;                WHERE oid = #{id} AND user.uid = orders.uid
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;mapper&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　下面是mapper接口中的一个方法，由于我们只需要完成这一个问题，所以OrderMapper接口也比较简单&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201901/1368768-20190130170242403-2043618825.png&quot; alt=&quot;&quot; width=&quot;384&quot; height=&quot;47&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　⑤编写好所有的文件后，使用Junit来测试文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; cn.mybatis.mapper;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; cn.mybatis.po.OrderPoJo;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.ibatis.io.Resources;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.ibatis.session.SqlSession;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.ibatis.session.SqlSessionFactory;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.ibatis.session.SqlSessionFactoryBuilder;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.Before;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.Test;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.InputStream;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; OrderMapperTest {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; SqlSessionFactory sqlSessionFactory;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    @Before
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setUp() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         InputStream inputStream = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         sqlSessionFactory = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SqlSessionFactoryBuilder().build(inputStream);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    @Test
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; testFindOrderAndUser() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         SqlSession sqlSession =&lt;span&gt; sqlSessionFactory.openSession();
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         OrderMapper orderMapper = sqlSession.getMapper(OrderMapper.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt;         OrderPoJo orderPoJo = orderMapper.findOrderAndUser(3&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt; &lt;span&gt;        System.out.println(orderPoJo);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt; &lt;span&gt;        sqlSession.close();
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; 
&lt;span&gt;35&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; 
&lt;span&gt;37&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　⑥我们来通过日志分析一下结果：最终能够按照既定的Sql查询出响应的结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201901/1368768-20190130170517645-1227149195.png&quot; alt=&quot;&quot; width=&quot;848&quot; height=&quot;191&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;使用resultMap在配置文件中实现&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　1、我们使用resultMap来进行测试的时候，首先需要注意的是，由于没有自定义包装类型，所以需要在原始的Order中添加User类型的属性，保证可以在Mapper配置文件中将查询到的User属性配置到user中，从而得到关联查询结果&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; cn.mybatis.po;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Date;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Order {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; oid;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; total;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Date ordertime;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; User user;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getOid() {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; oid;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setOid(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; oid) {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.oid =&lt;span&gt; oid;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; getTotal() {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; total;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setTotal(&lt;span&gt;double&lt;/span&gt;&lt;span&gt; total) {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.total =&lt;span&gt; total;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Date getOrdertime() {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ordertime;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setOrdertime(Date ordertime) {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.ordertime =&lt;span&gt; ordertime;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; 
&lt;span&gt;37&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getName() {
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; name;
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; 
&lt;span&gt;41&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; User getUser() {
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; user;
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; 
&lt;span&gt;45&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setUser(User user) {
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.user =&lt;span&gt; user;
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; 
&lt;span&gt;49&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setName(String name) {
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; 
&lt;span&gt;53&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &quot;Order{&quot; +
&lt;span&gt;56&lt;/span&gt;                 &quot;oid=&quot; + oid +
&lt;span&gt;57&lt;/span&gt;                 &quot;, total=&quot; + total +
&lt;span&gt;58&lt;/span&gt;                 &quot;, ordertime=&quot; + ordertime +
&lt;span&gt;59&lt;/span&gt;                 &quot;, name='&quot; + name + '\'' +
&lt;span&gt;60&lt;/span&gt;                 &quot;, user=&quot; + user +
&lt;span&gt;61&lt;/span&gt;                 '}'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　2、相关类和上面的内容一样，我们使用resultMap来实现，显然需要在Mapper中配置resultMap&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;&amp;lt;!--&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;        订单关联User的查询resultMap
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;        将查询的结果全部映射到Order类中
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;resultMap &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;OrderResultMap&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;cn.mybatis.po.Order&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;配置映射订单&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;id &lt;/span&gt;&lt;span&gt;column&lt;/span&gt;&lt;span&gt;=&quot;oid&quot;&lt;/span&gt;&lt;span&gt; property&lt;/span&gt;&lt;span&gt;=&quot;oid&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;column&lt;/span&gt;&lt;span&gt;=&quot;total&quot;&lt;/span&gt;&lt;span&gt; property&lt;/span&gt;&lt;span&gt;=&quot;total&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;result&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;column&lt;/span&gt;&lt;span&gt;=&quot;ordertime&quot;&lt;/span&gt;&lt;span&gt; property&lt;/span&gt;&lt;span&gt;=&quot;ordertime&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;result&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;column&lt;/span&gt;&lt;span&gt;=&quot;name&quot;&lt;/span&gt;&lt;span&gt; property&lt;/span&gt;&lt;span&gt;=&quot;name&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;result&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;配置关联用户信息&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;&amp;lt;!--&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;            association:用于映射关联查询单个对象的信息
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;            property:用于设置将关联信息映射到Order的哪个属性中
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;association &lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;=&quot;user&quot;&lt;/span&gt;&lt;span&gt; javaType&lt;/span&gt;&lt;span&gt;=&quot;cn.mybatis.po.User&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;id &lt;/span&gt;&lt;span&gt;column&lt;/span&gt;&lt;span&gt;=&quot;uid&quot;&lt;/span&gt;&lt;span&gt; property&lt;/span&gt;&lt;span&gt;=&quot;uid&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;column&lt;/span&gt;&lt;span&gt;=&quot;username&quot;&lt;/span&gt;&lt;span&gt; property&lt;/span&gt;&lt;span&gt;=&quot;username&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;result&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;column&lt;/span&gt;&lt;span&gt;=&quot;address&quot;&lt;/span&gt;&lt;span&gt; property&lt;/span&gt;&lt;span&gt;=&quot;address&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;result&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;column&lt;/span&gt;&lt;span&gt;=&quot;sex&quot;&lt;/span&gt;&lt;span&gt; property&lt;/span&gt;&lt;span&gt;=&quot;sex&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;result&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;association&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;resultMap&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　3、然后在Mapper配置文件中使用resultMap类型的statment&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;select &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;findOrderAndUserByResultMap&quot;&lt;/span&gt;&lt;span&gt; parameterType&lt;/span&gt;&lt;span&gt;=&quot;int&quot;&lt;/span&gt;&lt;span&gt; resultMap&lt;/span&gt;&lt;span&gt;=&quot;OrderResultMap&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        SELECT orders.*,
                user.username,user.sex,user.address
                FROM orders,USER
                WHERE oid = #{id} AND user.uid = orders.uid
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　4、结果同使用resultType的结果一样&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201901/1368768-20190130190145143-1055493964.png&quot; alt=&quot;&quot; width=&quot;658&quot; height=&quot;111&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;二、一对多关系映射&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　 1、我们先分析一下orderitem和orders两张数据表的关系，我们能够想到一条订单中包含许多详细的订单条目信息，所以简单的得到下面的关系&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201901/1368768-20190130191736439-791146128.png&quot; alt=&quot;&quot; width=&quot;339&quot; height=&quot;164&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　2、在上面的基础上，我们再创建一张orderitem数据表&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt;&lt;span&gt; `orderitem` (
  `itemid` &lt;/span&gt;&lt;span&gt;INT&lt;/span&gt;(&lt;span&gt;11&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt; AUTO_INCREMENT,
  `&lt;/span&gt;&lt;span&gt;count&lt;/span&gt;` &lt;span&gt;INT&lt;/span&gt;(&lt;span&gt;11&lt;/span&gt;) &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
  `subtotal` &lt;/span&gt;&lt;span&gt;DOUBLE&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
  `pid` &lt;/span&gt;&lt;span&gt;INT&lt;/span&gt;(&lt;span&gt;11&lt;/span&gt;) &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
  `oid` &lt;/span&gt;&lt;span&gt;INT&lt;/span&gt;(&lt;span&gt;11&lt;/span&gt;) &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
  &lt;/span&gt;&lt;span&gt;PRIMARY&lt;/span&gt; &lt;span&gt;KEY&lt;/span&gt;&lt;span&gt; (`itemid`),
  &lt;/span&gt;&lt;span&gt;KEY&lt;/span&gt;&lt;span&gt;  (`oid`),
  &lt;/span&gt;&lt;span&gt;KEY&lt;/span&gt;&lt;span&gt;  (`pid`),
  &lt;/span&gt;&lt;span&gt;KEY&lt;/span&gt;&lt;span&gt;  (`oid`),
  &lt;/span&gt;&lt;span&gt;FOREIGN&lt;/span&gt; &lt;span&gt;KEY&lt;/span&gt; (`oid`) &lt;span&gt;REFERENCES&lt;/span&gt;&lt;span&gt; `orders` (`oid`),
  &lt;/span&gt;&lt;span&gt;FOREIGN&lt;/span&gt; &lt;span&gt;KEY&lt;/span&gt; (`pid`) &lt;span&gt;REFERENCES&lt;/span&gt;&lt;span&gt; `product` (`pid`)
) ENGINE&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;INNODB AUTO_INCREMENT&lt;span&gt;=&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; CHARSET&lt;span&gt;=&lt;/span&gt;utf8
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　3、我们再创建相应的实体类orderitem&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_b475cc68-093b-4dfc-ba9a-1a3c066ba276&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_b475cc68-093b-4dfc-ba9a-1a3c066ba276&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_b475cc68-093b-4dfc-ba9a-1a3c066ba276&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; cn.mybatis.po;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; OrderItem {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; itemid;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; count;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; subtotal;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; pid;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getItemid() {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; itemid;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setItemid(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; itemid) {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.itemid =&lt;span&gt; itemid;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getCount() {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; count;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setCount(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; count) {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.count =&lt;span&gt; count;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; getSubtotal() {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; subtotal;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setSubtotal(&lt;span&gt;double&lt;/span&gt;&lt;span&gt; subtotal) {
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.subtotal =&lt;span&gt; subtotal;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; 
&lt;span&gt;34&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getPid() {
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; pid;
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; 
&lt;span&gt;38&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setPid(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; pid) {
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.pid =&lt;span&gt; pid;
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; 
&lt;span&gt;42&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &quot;OrderItem{&quot; +
&lt;span&gt;45&lt;/span&gt;                 &quot;itemid=&quot; + itemid +
&lt;span&gt;46&lt;/span&gt;                 &quot;, count=&quot; + count +
&lt;span&gt;47&lt;/span&gt;                 &quot;, subtotal=&quot; + subtotal +
&lt;span&gt;48&lt;/span&gt;                 &quot;, pid=&quot; + pid +
&lt;span&gt;49&lt;/span&gt;                 '}'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;orderitem实体类&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;　　4、类似于上面讲到的使用resultMap的方式，我们在Order中添加上orderitem这一属性，作用就是维护Order和Orderitem的关联关系&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;&lt;img id=&quot;code_img_closed_6e1b9ffe-158f-417a-be28-d22c1389c31c&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_6e1b9ffe-158f-417a-be28-d22c1389c31c&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_6e1b9ffe-158f-417a-be28-d22c1389c31c&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; cn.mybatis.po;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Date;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Order {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; oid;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; total;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Date ordertime;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; User user;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; List&amp;lt;OrderItem&amp;gt;&lt;span&gt; orderItems;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getOid() {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; oid;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setOid(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; oid) {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.oid =&lt;span&gt; oid;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; getTotal() {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; total;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setTotal(&lt;span&gt;double&lt;/span&gt;&lt;span&gt; total) {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.total =&lt;span&gt; total;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Date getOrdertime() {
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ordertime;
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setOrdertime(Date ordertime) {
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.ordertime =&lt;span&gt; ordertime;
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; 
&lt;span&gt;40&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getName() {
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; name;
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; 
&lt;span&gt;44&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; User getUser() {
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; user;
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; 
&lt;span&gt;48&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setUser(User user) {
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.user =&lt;span&gt; user;
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; 
&lt;span&gt;52&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setName(String name) {
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; 
&lt;span&gt;56&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; List&amp;lt;OrderItem&amp;gt;&lt;span&gt; getOrderItems() {
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; orderItems;
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; 
&lt;span&gt;60&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setOrderItems(List&amp;lt;OrderItem&amp;gt;&lt;span&gt; orderItems) {
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.orderItems =&lt;span&gt; orderItems;
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; 
&lt;span&gt;64&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &quot;Order{&quot; +
&lt;span&gt;67&lt;/span&gt;                 &quot;oid=&quot; + oid +
&lt;span&gt;68&lt;/span&gt;                 &quot;, total=&quot; + total +
&lt;span&gt;69&lt;/span&gt;                 &quot;, ordertime=&quot; + ordertime +
&lt;span&gt;70&lt;/span&gt;                 &quot;, name='&quot; + name + '\'' +
&lt;span&gt;71&lt;/span&gt;                 &quot;, user=&quot; + user +
&lt;span&gt;72&lt;/span&gt;                 &quot;, orderItems=&quot; + orderItems +
&lt;span&gt;73&lt;/span&gt;                 '}'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;修改后的Order类&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;　　5、我们先配置Mapper文件。使用collection配置实体类中的List属性（List&amp;lt;OrderItem&amp;gt;）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;查询Order和OrderItem的配置（一对多关系查询配置）&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;resultMap &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;OrderAndOrderItemByResultMap&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;cn.mybatis.po.Order&quot;&lt;/span&gt;&lt;span&gt; extends&lt;/span&gt;&lt;span&gt;=&quot;OrderResultMap&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;使用extends，可以将某一段resultMap继承过来&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;OrderItem信息&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;collections:将查询到的多条信息映射到集合中
            property：将查询到的多条记录映射到Order中的相应属性中（orderItems）
            ofType：指的是要映射的集合中的JavaType&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;collection &lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;=&quot;orderItems&quot;&lt;/span&gt;&lt;span&gt; ofType&lt;/span&gt;&lt;span&gt;=&quot;cn.mybatis.po.OrderItem&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;id &lt;/span&gt;&lt;span&gt;column&lt;/span&gt;&lt;span&gt;=&quot;itemid&quot;&lt;/span&gt;&lt;span&gt; property&lt;/span&gt;&lt;span&gt;=&quot;itemid&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;column&lt;/span&gt;&lt;span&gt;=&quot;count&quot;&lt;/span&gt;&lt;span&gt; property&lt;/span&gt;&lt;span&gt;=&quot;count&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;result&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;column&lt;/span&gt;&lt;span&gt;=&quot;subtotal&quot;&lt;/span&gt;&lt;span&gt; property&lt;/span&gt;&lt;span&gt;=&quot;subtotal&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;result&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;collection&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;resultMap&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 　　6、然后将上面配置的resultMap加入到statment中&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;select &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;findOrderAndOrderItemByResultMap&quot;&lt;/span&gt;&lt;span&gt; parameterType&lt;/span&gt;&lt;span&gt;=&quot;int&quot;&lt;/span&gt;&lt;span&gt; resultMap&lt;/span&gt;&lt;span&gt;=&quot;OrderAndOrderItemByResultMap&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        SELECT orders.*,
            user.username,
            user.sex,
            user.address,
            orderitem.itemid,
            orderitem.count,
            orderitem.subtotal
            FROM
            orders,
            USER,
            orderitem
            WHERE orders.oid = #{id} AND user.uid = orders.uid AND orderitem.oid = orders.oid
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　7、然后在Mapper接口中添加测试方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;一对多关系测试&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; Order findOrderAndOrderItemByResultMap(&lt;span&gt;int&lt;/span&gt; id) &lt;span&gt;throws&lt;/span&gt; Exception;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　8、将查询的结果进行输出可以发现能够正常查询出想要的结果&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
Order{oid=2, total=32.0, ordertime=Thu Dec 26 21:47:04 CST 2019, name='Lucy', user=User{uid=2, username='Rose', password='null', address='武汉市', sex='women'}, orderItems=[OrderItem{itemid=2, count=21, subtotal=32.0, pid=0}, OrderItem{itemid=4, count=32, subtotal=54.0, pid=0}]}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt; 三、多对多关系映射&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　1、问题背景就是查询User所购买的商品详细信息，即查询结果包括User信息和Product信息。我们先分析一下整个数据表之间的关系如下图所示&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201901/1368768-20190131115343387-600341051.png&quot; alt=&quot;&quot; width=&quot;612&quot; height=&quot;320&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　2、在上面分析的基础上，我们创建Product数据表的对应的Product实体类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt;&lt;span&gt; `product` (
  `pid` &lt;/span&gt;&lt;span&gt;INT&lt;/span&gt;(&lt;span&gt;11&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt; AUTO_INCREMENT,
  `pname` &lt;/span&gt;&lt;span&gt;VARCHAR&lt;/span&gt;(&lt;span&gt;255&lt;/span&gt;) &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
  `shop_price` &lt;/span&gt;&lt;span&gt;DOUBLE&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
  &lt;/span&gt;&lt;span&gt;PRIMARY&lt;/span&gt; &lt;span&gt;KEY&lt;/span&gt;&lt;span&gt; (`pid`)
) ENGINE&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;INNODB AUTO_INCREMENT&lt;span&gt;=&lt;/span&gt;&lt;span&gt;80&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; CHARSET&lt;span&gt;=&lt;/span&gt;utf8
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_38e4ecf0-ec0f-4503-a4c8-ae4343ae8f99&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_38e4ecf0-ec0f-4503-a4c8-ae4343ae8f99&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_38e4ecf0-ec0f-4503-a4c8-ae4343ae8f99&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; cn.mybatis.po;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Product {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; pid;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String pname;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; shop_price;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getPid() {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; pid;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setPid(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; pid) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.pid =&lt;span&gt; pid;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getPname() {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; pname;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setPname(String pname) {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.pname =&lt;span&gt; pname;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; getShop_price() {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; shop_price;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setShop_price(&lt;span&gt;double&lt;/span&gt;&lt;span&gt; shop_price) {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.shop_price =&lt;span&gt; shop_price;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &quot;Product{&quot; +
&lt;span&gt;35&lt;/span&gt;                 &quot;pid=&quot; + pid +
&lt;span&gt;36&lt;/span&gt;                 &quot;, pname='&quot; + pname + '\'' +
&lt;span&gt;37&lt;/span&gt;                 &quot;, shop_price=&quot; + shop_price +
&lt;span&gt;38&lt;/span&gt;                 '}'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;Product实体类&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;　　3、一般编写Mapper配置文件可以使用resultMap或者resultType(+自定义扩展类型)来实现，这里，我们使用resultMap在Mapper配置文件中进行，所以需要在OrderItem类中添加Product类型的属性，修改后的OrderItem类如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_e88a1509-c154-4690-a5f6-562c6be52090&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_e88a1509-c154-4690-a5f6-562c6be52090&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_e88a1509-c154-4690-a5f6-562c6be52090&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; cn.mybatis.po;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; OrderItem {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; itemid;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; count;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; subtotal;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Product product;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getItemid() {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; itemid;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setItemid(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; itemid) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.itemid =&lt;span&gt; itemid;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getCount() {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; count;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setCount(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; count) {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.count =&lt;span&gt; count;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; getSubtotal() {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; subtotal;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setSubtotal(&lt;span&gt;double&lt;/span&gt;&lt;span&gt; subtotal) {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.subtotal =&lt;span&gt; subtotal;
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; 
&lt;span&gt;35&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Product getProduct() {
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; product;
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; 
&lt;span&gt;39&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setProduct(Product product) {
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.product =&lt;span&gt; product;
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; 
&lt;span&gt;43&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &quot;OrderItem{&quot; +
&lt;span&gt;46&lt;/span&gt;                 &quot;itemid=&quot; + itemid +
&lt;span&gt;47&lt;/span&gt;                 &quot;, count=&quot; + count +
&lt;span&gt;48&lt;/span&gt;                 &quot;, subtotal=&quot; + subtotal +
&lt;span&gt;49&lt;/span&gt;                 &quot;, product=&quot; + product +
&lt;span&gt;50&lt;/span&gt;                 '}'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;修改的OrderItem类&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　4、修改相应的实体类后，可以再Mapper配置文件中配置查询结果User信息以及关联的Order、OrderItem和所要的Product信息，配置如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;查询User和Product关系结果（多对多关系）&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;resultMap &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;UserAndProductResultMap&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;cn.mybatis.po.User&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;User信息&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;id &lt;/span&gt;&lt;span&gt;column&lt;/span&gt;&lt;span&gt;=&quot;uid&quot;&lt;/span&gt;&lt;span&gt; property&lt;/span&gt;&lt;span&gt;=&quot;uid&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;column&lt;/span&gt;&lt;span&gt;=&quot;username&quot;&lt;/span&gt;&lt;span&gt; property&lt;/span&gt;&lt;span&gt;=&quot;username&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;result&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;column&lt;/span&gt;&lt;span&gt;=&quot;address&quot;&lt;/span&gt;&lt;span&gt; property&lt;/span&gt;&lt;span&gt;=&quot;address&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;result&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;column&lt;/span&gt;&lt;span&gt;=&quot;sex&quot;&lt;/span&gt;&lt;span&gt; property&lt;/span&gt;&lt;span&gt;=&quot;sex&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;result&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;Order信息&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;collection &lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;=&quot;orders&quot;&lt;/span&gt;&lt;span&gt; ofType&lt;/span&gt;&lt;span&gt;=&quot;cn.mybatis.po.Order&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;id &lt;/span&gt;&lt;span&gt;column&lt;/span&gt;&lt;span&gt;=&quot;oid&quot;&lt;/span&gt;&lt;span&gt; property&lt;/span&gt;&lt;span&gt;=&quot;oid&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;column&lt;/span&gt;&lt;span&gt;=&quot;total&quot;&lt;/span&gt;&lt;span&gt; property&lt;/span&gt;&lt;span&gt;=&quot;total&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;result&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;column&lt;/span&gt;&lt;span&gt;=&quot;ordertime&quot;&lt;/span&gt;&lt;span&gt; property&lt;/span&gt;&lt;span&gt;=&quot;ordertime&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;result&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;column&lt;/span&gt;&lt;span&gt;=&quot;name&quot;&lt;/span&gt;&lt;span&gt; property&lt;/span&gt;&lt;span&gt;=&quot;name&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;result&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

            &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;OrderItem信息&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;collection &lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;=&quot;orderItems&quot;&lt;/span&gt;&lt;span&gt; ofType&lt;/span&gt;&lt;span&gt;=&quot;cn.mybatis.po.OrderItem&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;id &lt;/span&gt;&lt;span&gt;column&lt;/span&gt;&lt;span&gt;=&quot;itemid&quot;&lt;/span&gt;&lt;span&gt; property&lt;/span&gt;&lt;span&gt;=&quot;itemid&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;column&lt;/span&gt;&lt;span&gt;=&quot;count&quot;&lt;/span&gt;&lt;span&gt; property&lt;/span&gt;&lt;span&gt;=&quot;count&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;result&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;column&lt;/span&gt;&lt;span&gt;=&quot;subtotal&quot;&lt;/span&gt;&lt;span&gt; property&lt;/span&gt;&lt;span&gt;=&quot;subtotal&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;result&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;association &lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;=&quot;product&quot;&lt;/span&gt;&lt;span&gt; javaType&lt;/span&gt;&lt;span&gt;=&quot;cn.mybatis.po.Product&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;id &lt;/span&gt;&lt;span&gt;column&lt;/span&gt;&lt;span&gt;=&quot;pid&quot;&lt;/span&gt;&lt;span&gt; property&lt;/span&gt;&lt;span&gt;=&quot;pid&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;column&lt;/span&gt;&lt;span&gt;=&quot;pname&quot;&lt;/span&gt;&lt;span&gt; property&lt;/span&gt;&lt;span&gt;=&quot;pname&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;result&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;column&lt;/span&gt;&lt;span&gt;=&quot;shop_price&quot;&lt;/span&gt;&lt;span&gt; property&lt;/span&gt;&lt;span&gt;=&quot;shop_price&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;result&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;association&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;collection&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;collection&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;resultMap&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　5、然后编写响应的Sql，并添加到Mapper中的statment中&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;select &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;findUsersAndProduct&quot;&lt;/span&gt;&lt;span&gt; parameterType&lt;/span&gt;&lt;span&gt;=&quot;int&quot;&lt;/span&gt;&lt;span&gt; resultMap&lt;/span&gt;&lt;span&gt;=&quot;UserAndProductResultMap&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        SELECT orders.*,
            user.username,
            user.sex,
            user.address,
            orderitem.itemid,
            orderitem.count,
            orderitem.subtotal,
            product.pid,
            product.pname,
            product.shop_price
            FROM
            orders,
            USER,
            orderitem,
            product
            WHERE user.uid = orders.uid AND orderitem.oid = orders.oid
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　6、在Mapper.java中添加响应的方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; List&amp;lt;User&amp;gt; findUsersAndProduct() &lt;span&gt;throws&lt;/span&gt; Exception;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　7、最后使用Junit测试结果如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201901/1368768-20190131113456883-1389772751.png&quot; alt=&quot;&quot; width=&quot;832&quot; height=&quot;94&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 04 Feb 2019 07:48:00 +0000</pubDate>
<dc:creator>风沙迷了眼</dc:creator>
<og:description>一、一对一关系映射 使用resultType+包装类实现 1、假设问题背景是要求在某一个购物平台的后台程序中添加一个这样的功能：查询某个订单的信息和下该订单的用户信息。首先我们可以知道，一般这样的平台</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fsmly/p/10339619.html</dc:identifier>
</item>
<item>
<title>SpringBoot基础系列-SpringCache使用 - 唯一浩哥</title>
<link>http://www.cnblogs.com/V1haoge/p/10351734.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/V1haoge/p/10351734.html</guid>
<description>&lt;p&gt;&lt;strong&gt;原创文章，转载请标注出处：&lt;a href=&quot;https://www.cnblogs.com/V1haoge/p/10351734.html&quot;&gt;《SpringBoot基础系列-SpringCache使用》&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;一概述&quot;&gt;一、概述&lt;/h2&gt;
&lt;p&gt;SpringCache本身是一个缓存体系的抽象实现，并没有具体的缓存能力，要使用SpringCache还需要配合具体的缓存实现来完成。&lt;/p&gt;
&lt;p&gt;虽然如此，但是SpringCache是所有Spring支持的缓存结构的基础，而且所有的缓存的使用最后都要归结于SpringCache，那么一来，要想使用SpringCache，还是要仔细研究一下的。&lt;/p&gt;
&lt;h2 id=&quot;二缓存注解&quot;&gt;二、缓存注解&lt;/h2&gt;
&lt;p&gt;SpringCache缓存功能的实现是依靠下面的这几个注解完成的。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@EnableCaching
@Configuration
public class CacheConfig {
    @Bean
    public CacheManager cacheManager() {
        SimpleCacheManager cacheManager = new SimpleCacheManager();
        cacheManager.setCaches(Arrays.asList(new ConcurrentMapCache(&quot;default&quot;)));
        return cacheManager;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;注意：在SpringBoot中使用SpringCache可以由自动配置功能来完成CacheManager的注册，SpringBoot会自动发现项目中拥有的缓存系统，而注册对应的缓存管理器，当然我们也可以手动指定。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;使用该注解和如下XML配置具有一样的效果：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;beans&amp;gt;
    &amp;lt;cache:annotation-driven/&amp;gt;
    &amp;lt;bean id=&quot;cacheManager&quot; class=&quot;org.springframework.cache.support.SimpleCacheManager&amp;gt;
        &amp;lt;property name=&quot;caches&quot;&amp;gt;
            &amp;lt;set&amp;gt;
                &amp;lt;bean class=&quot;org.springframework.cache.concurrent.ConcurrentMapCacheFactoryBean&amp;gt;
                    &amp;lt;property name=&quot;name&quot; value=&quot;default&quot;/&amp;gt;
                &amp;lt;/bean&amp;gt;
            &amp;lt;/set&amp;gt;
        &amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;
&amp;lt;/beans&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面来看看@EnableCaching的源码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Import(CachingConfigurationSelector.class)
public @interface EnableCaching {
    // 用于设置使用哪种代理方式，默认为基于接口的JDK动态代理（false），
    // 设置为true，则使用基于继承的CGLIB动态代理
    boolean proxyTargetClass() default false;
    // 用于设置切面织入方式(设置面向切面编程的实现方式)，
    // 默认为使用动态代理的方式织入，当然也可以设置为ASPECTJ的方式来实现AOP
    AdviceMode mode() default AdviceMode.PROXY;
    // 用于设置在一个切点存在多个通知的时候各个通知的执行顺序，默认为最低优先级，
    // 其中数字却大优先级越低，这里默认为最低优先级，int LOWEST_PRECEDENCE =
    // Integer.MAX_VALUE;，却是整数的最大值
    int order() default Ordered.LOWEST_PRECEDENCE;
}
public enum AdviceMode {
    PROXY,
    ASPECTJ
}
public interface Ordered {
    int HIGHEST_PRECEDENCE = Integer.MIN_VALUE;
    int LOWEST_PRECEDENCE = Integer.MAX_VALUE;
    int getOrder();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由上面的源码可以看出，缓存功能是依靠AOP来实现的。&lt;/p&gt;
&lt;h3 id=&quot;cacheable&quot;&gt;2.2 @Cacheable&lt;/h3&gt;
&lt;p&gt;该注解用于标注于方法之上用于标识该方法的返回结果需要被缓存起来，标注于类之上标识该类中所有方法均需要将结果缓存起来。&lt;/p&gt;
&lt;p&gt;该注解标注的方法每次被调用前都会触发缓存校验，校验指定参数的缓存是否已存在（已发生过相同参数的调用），若存在，直接返回缓存结果，否则执行方法内容，最后将方法执行结果保存到缓存中。&lt;/p&gt;
&lt;h4 id=&quot;使用&quot;&gt;2.2.1 使用&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Service
@Log4j2
public class AnimalService {
    @Autowired
    private AnimalRepository animalRepository;
    //...
//    @Cacheable(&quot;animalById&quot;)
    @Cacheable(value = &quot;animalById&quot;, key = &quot;#id&quot;)
    public ResponseEntity&amp;lt;Animal&amp;gt; getAnimalById(final int id){
        return ResponseEntity.ok(animalRepository.selectById(id));
    }
    //...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的实例中两个@Cacheable配置效果其实是一样的，其中value指定的缓存的名称，它和另一个方法cacheName效果一样，一般来说这个缓存名称必须要有，因为这个是区别于其他方法的缓存的唯一方法。&lt;/p&gt;
&lt;p&gt;这里我们介绍一下缓存的简单结构，在缓存中，每个这样的缓存名称的名下都会存在着多个缓存条目，这些缓存条目对应在使用不同的参数调用当前方法时生成的缓存，所有一个缓存名称并不是一个缓存，而是一系列缓存。&lt;/p&gt;
&lt;p&gt;另一个key用于指定当前方法的缓存保存时的键的组合方式，默认的情况下使用所有的参数组合而成，这样可以有效区分不同参数的缓存。当然我们也可以手动指定，指定的方法是使用SPEL表达式。&lt;/p&gt;
&lt;p&gt;这里我么来简单看看其源码，了解下其他几个方法的作用：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Inherited
@Documented
public @interface Cacheable {
    // 用于指定缓存名称，与cacheNames()方法效果一致
    @AliasFor(&quot;cacheNames&quot;)
    String[] value() default {};
    // 用于指定缓存名称，与value()方法效果一致
    @AliasFor(&quot;value&quot;)
    String[] cacheNames() default {};
    // 用于使用SPEL手动指定缓存键的组合方式，默认情况使用所有的参数来组合成键，除非自定义了keyGenerator。
    // 使用SPEL表达式可以根据上下文环境来获取到指定的数据：
    // #root.method：用于获取当前方法的Method实例
    // #root.target：用于获取当前方法的target实例
    // #root.caches：用于获取当前方法关联的缓存
    // #root.methodName：用于获取当前方法的名称
    // #root.targetClass：用于获取目标类类型
    // #root.args[1]：获取当前方法的第二个参数，等同于：#p1和#a1和#argumentName
    String key() default &quot;&quot;;
    // 自定义键生成器，定义了该方法之后，上面的key方法自动失效，这个键生成器是：
    // org.springframework.cache.interceptor.KeyGenerator，这是一个函数式接口，
    // 只有一个generate方法，我们可以通过自定义的逻辑来实现自定义的key生成策略。
    String keyGenerator() default &quot;&quot;;
    // 用于设置自定义的cacheManager(缓存管理器),可以自动生成一个cacheResolver
    // （缓存解析器），这一下面的cacheResolver()方法设置互斥
    String cacheManager() default &quot;&quot;;
    // 用于设置一个自定义的缓存解析器
    String cacheResolver() default &quot;&quot;;
    // 用于设置执行缓存的条件，如果条件不满足，方法返回的结果就不会被缓存，默认无条件全部缓存。
    // 同样使用SPEL来定义条件，可以使用的获取方式同key方法。
    String condition() default &quot;&quot;;
    // 这个用于禁止缓存功能，如果设置的条件满足，就不执行缓存结果，与上面的condition不同之处在于，
    // 该方法执行在当前方法调用结束，结果出来之后，因此，它除了可以使用上面condition所能使用的SPEL
    // 表达式之外，还可以使用#result来获取方法的执行结果，亦即可以根据结果的不同来决定是否缓存。
    String unless() default &quot;&quot;;
    // 设置是否对多个针对同一key执行缓存加载的操作的线程进行同步，默认不同步。这个功能需要明确确定所
    // 使用的缓存工具支持该功能，否则不要滥用。
    boolean sync() default false;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如何自定义一个KeyGenerator呢？&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class AnimalKeyGenerator implements KeyGenerator {
    @Override
    public Object generate(Object target, Method method, Object... params) {
        StringBuilder sb = new StringBuilder(&quot;animal-&quot;);
        sb.append(target.getClass().getSimpleName()).append(&quot;-&quot;).append(method.getName()).append(&quot;-&quot;);
        for (Object o : params) {
            String s = o.toString();
            sb.append(s).append(&quot;-&quot;);
        }
        return sb.deleteCharAt(sb.lastIndexOf(&quot;-&quot;)).toString();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;cacheput&quot;&gt;2.3 @CachePut&lt;/h3&gt;
&lt;p&gt;该注解用于更新缓存，无论结果是否已经缓存，都会在方法执行结束插入缓存，相当于更新缓存。一般用于更新方法之上。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Service
@Log4j2
public class AnimalService {
    @Autowired
    private AnimalRepository animalRepository;
    //...
    @CachePut(value = &quot;animalById&quot;, key = &quot;#animal.id&quot;)
    public ResponseEntity&amp;lt;Animal&amp;gt; updateAnimal(final Animal animal){
        Wrapper&amp;lt;Animal&amp;gt; animalWrapper = new UpdateWrapper&amp;lt;&amp;gt;();
        ((UpdateWrapper&amp;lt;Animal&amp;gt;) animalWrapper).eq(&quot;id&quot;,animal.getId());
        animalRepository.update(animal, animalWrapper);
        return ResponseEntity.ok(this.getAnimalById(animal.getId()));
    }
    //...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里指定更新缓存，value同样还是缓存名称，这里更新的是上面查询操作的同一缓存，而且key设置为id也与上面的key设置对应。&lt;/p&gt;
&lt;p&gt;如此设置之后，每次执行update方法时都会直接执行方法内容，然后将返回的结果保存到缓存中，如果存在相同的key,直接替换缓存内容执行缓存更新。&lt;/p&gt;
&lt;p&gt;下面来看看源码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Inherited
@Documented
public @interface CachePut {
    // 同上
    @AliasFor(&quot;cacheNames&quot;)
    String[] value() default {};
    // 同上
    @AliasFor(&quot;value&quot;)
    String[] cacheNames() default {};
    // 同上
    String key() default &quot;&quot;;
    // 同上
    String keyGenerator() default &quot;&quot;;
    // 同上
    String cacheManager() default &quot;&quot;;
    // 同上
    String cacheResolver() default &quot;&quot;;
    // 同上
    String condition() default &quot;&quot;;
    // 同上
    String unless() default &quot;&quot;;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;只有一点要注意：这里的设置一定要和执行缓存保存的方法的@Cacheable的设置一致，否则无法准确更新。&lt;/p&gt;
&lt;h3 id=&quot;cacheevict&quot;&gt;2.4 @CacheEvict&lt;/h3&gt;
&lt;p&gt;该注解主要用于删除缓存操作。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Service
@Log4j2
public class AnimalService {
    @Autowired
    private AnimalRepository animalRepository;
    //...
    @CacheEvict(value = &quot;animalById&quot;, key = &quot;#id&quot;)
    public ResponseEntity&amp;lt;Integer&amp;gt; deleteAnimalById(final int id){
        return ResponseEntity.ok(animalRepository.deleteById(id));
    }
    //...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;简单明了，看看源码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Inherited
@Documented
public @interface CacheEvict {
    // 同上
    @AliasFor(&quot;cacheNames&quot;)
    String[] value() default {};
    // 同上
    @AliasFor(&quot;value&quot;)
    String[] cacheNames() default {};
    // 同上
    String key() default &quot;&quot;;
    // 同上
    String keyGenerator() default &quot;&quot;;
    // 同上
    String cacheManager() default &quot;&quot;;
    // 同上
    String cacheResolver() default &quot;&quot;;
    // 同上
    String condition() default &quot;&quot;;
    // 这个设置用于指定当前缓存名称名下的所有缓存是否全部删除，默认false。
    boolean allEntries() default false;
    // 这个用于指定删除缓存的操作是否在方法调用之前完成，默认为false，表示先调用方法，在执行缓存删除。
    boolean beforeInvocation() default false;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;caching&quot;&gt;2.5 @Caching&lt;/h3&gt;
&lt;p&gt;这个注解用于组个多个缓存操作，包括针对不用缓存名称的相同操作等，源码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Inherited
@Documented
public @interface Caching {
    // 用于指定多个缓存设置操作
    Cacheable[] cacheable() default {};
    // 用于指定多个缓存更新操作
    CachePut[] put() default {};
    // 用于指定多个缓存失效操作
    CacheEvict[] evict() default {};
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;简单用法：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Service
@Log4j2
public class AnimalService {
    @Autowired
    private AnimalRepository animalRepository;
    //...
    @Caching(
        evict = {
            @CacheEvict(value = &quot;animalById&quot;, key = &quot;#id&quot;),
            @CacheEvict(value = &quot;animals&quot;, allEntries = true, beforeInvocation = true)
        }
    )
    public ResponseEntity&amp;lt;Integer&amp;gt; deleteAnimalById(final int id){
        return ResponseEntity.ok(animalRepository.deleteById(id));
    }
    @Cacheable(&quot;animals&quot;)
    public ResponseEntity&amp;lt;Page&amp;lt;Animal&amp;gt;&amp;gt; getAnimalPage(final Animal animal, final int pageId, final int pageSize){
        Page&amp;lt;Animal&amp;gt; page = new Page&amp;lt;&amp;gt;();
        page.setCurrent(pageId);
        page.setSize(pageSize);
        return ResponseEntity.ok((Page&amp;lt;Animal&amp;gt;) animalRepository.selectPage(page,packWrapper(animal, WrapperType.QUERY)));
    }
    //...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;cacheconfig&quot;&gt;2.6 @CacheConfig&lt;/h3&gt;
&lt;p&gt;该注解标注于类之上，用于进行一些公共的缓存相关配置。源码为：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface CacheConfig {
    // 设置统一的缓存名，适用于整个类中的方法全部是针对同一缓存名操作的情况
    String[] cacheNames() default {};
    // 设置统一个键生成器，免去了每个缓存设置中单独设置
    String keyGenerator() default &quot;&quot;;
    // 设置统一个自定义缓存管理器
    String cacheManager() default &quot;&quot;;
    // 设置统一个自定义缓存解析器
    String cacheResolver() default &quot;&quot;;
}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Mon, 04 Feb 2019 06:33:00 +0000</pubDate>
<dc:creator>唯一浩哥</dc:creator>
<og:description>原创文章，转载请标注出处： '《SpringBoot基础系列 SpringCache使用》' 一、概述 SpringCache本身是一个缓存体系的抽象实现，并没有具体的缓存能力，要使用SpringCa</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/V1haoge/p/10351734.html</dc:identifier>
</item>
<item>
<title>基于 Webpack 4 和 React hooks 搭建项目 - Jeff.Zhong</title>
<link>http://www.cnblogs.com/edwardloveyou/p/10351697.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/edwardloveyou/p/10351697.html</guid>
<description>&lt;p&gt;面对日新月异的前端，我表示快学不动了😂。 &lt;strong&gt;Webpack&lt;/strong&gt; 老早就已经更新到了 V4.x，前段时间 &lt;strong&gt;React&lt;/strong&gt; 又推出了 &lt;strong&gt;hooks&lt;/strong&gt; API。刚好春节在家里休假，时间比较空闲，还是赶紧把 &lt;strong&gt;React&lt;/strong&gt;技术栈这块补上。&lt;/p&gt;
&lt;p&gt;网上有很多介绍 &lt;strong&gt;hooks&lt;/strong&gt; 知识点的文章，但都比较零碎，基本只能写一些小 &lt;strong&gt;Demo&lt;/strong&gt;。还没有比较系统的，全新的基于 &lt;strong&gt;hooks&lt;/strong&gt; 进行搭建实际项目的讲解。所以这里就从开发实际项目的角度，搭建起单页面 &lt;strong&gt;Web App&lt;/strong&gt;项目的基本脚手架，并基于 &lt;strong&gt;hooks&lt;/strong&gt; API 实现一个 &lt;strong&gt;react&lt;/strong&gt; 项目模版。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Hooks&lt;/strong&gt; 最吸引人的地方就是用 &lt;strong&gt;函数式组件&lt;/strong&gt; 代替面向对象的 &lt;strong&gt;类组件&lt;/strong&gt;。此前的 &lt;strong&gt;react&lt;/strong&gt; 如果涉及到状态，解决方案通常只能使用 &lt;strong&gt;类组件&lt;/strong&gt;，业务逻辑一复杂就容易导致组件臃肿，模块的解藕也是个问题。而使用基于 &lt;strong&gt;hooks&lt;/strong&gt; 的 &lt;strong&gt;函数组件&lt;/strong&gt; 后，代码不仅更加简洁，写起来更爽，而且模块复用也方便得多，非常看好它的未来。&lt;br/&gt;&lt;/p&gt;
&lt;h2 id=&quot;webpack-4-的配置&quot;&gt;webpack 4 的配置&lt;/h2&gt;
&lt;p&gt;没有使用 &lt;strong&gt;create-react-app&lt;/strong&gt; 这个脚手架，而是从头开始配置开发环境，因为这样自定义配置某些功能会更方便些。下面这个是通用的配置 &lt;strong&gt;webpack.common.js&lt;/strong&gt; 文件。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;const { resolve } = require('path');
const HtmlWebpackPlugin = require('html-webpack-plugin');
const CleanWebpackPlugin = require('clean-webpack-plugin');
const { HotModuleReplacementPlugin } = require('webpack');

module.exports = {
    entry: './src/index.js',//单入口
    output: {
        path: resolve(__dirname, 'dist'),
        filename: '[name].[hash].js'//输出文件添加hash
    },
    optimization: { // 代替commonchunk, 代码分割
        runtimeChunk: 'single',
        splitChunks: {
            cacheGroups: {
                vendor: {
                    test: /[\\/]node_modules[\\/]/,
                    name: 'vendors',
                    chunks: 'all'
                }
            }
        }
    },
    module: {
        rules: [
            {
                test: /\.jsx?$/,
                exclude: /node_modules/,
                use: ['babel-loader']
            },
            {
                test: /\.css$/,
                use: ['style-loader', 'css-loader']
            },
            {
                test: /\.scss$/,
                use: ['style-loader',
                    {
                        loader: 'css-loader',
                        options: {
                            importLoaders: 1,
                            modules: true,//css modules
                            localIdentName: '[name]___[local]___[hash:base64:5]'
                        },
                    },
                    'postcss-loader', 'sass-loader']
            },
            {   /* 
                当文件体积小于 limit 时，url-loader 把文件转为 Data URI 的格式内联到引用的地方
                当文件大于 limit 时，url-loader 会调用 file-loader, 把文件储存到输出目录，并把引用的文件路径改写成输出后的路径 
                */
                test: /\.(png|jpg|jpeg|gif|eot|ttf|woff|woff2|svg|svgz)(\?.+)?$/,
                use: [{
                    loader: 'url-loader',
                    options: {
                        limit: 1000
                    }
                }]
            }
        ]
    },
    plugins: [
        new CleanWebpackPlugin(['dist']),//生成新文件时，清空生出目录
        new HtmlWebpackPlugin({
            template: './public/index.html',//模版路径
            favicon: './public/favicon.png',
            minify: { //压缩
                removeAttributeQuotes:true,
                removeComments: true,
                collapseWhitespace: true,
                removeScriptTypeAttributes:true,
                removeStyleLinkTypeAttributes:true
             },
        }),
        new HotModuleReplacementPlugin()//HMR
    ]
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接着基于 &lt;strong&gt;webpack.common.js&lt;/strong&gt; 文件，配置出开发环境的 &lt;strong&gt;webpack.dev.js&lt;/strong&gt; 文件，主要就是启动开发服务器。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;const merge = require('webpack-merge');
const common = require('./webpack.common.js');

module.exports = merge(common, {
    mode: 'development',
    devtool: 'inline-source-map',
    devServer: {
        contentBase: './dist',
        port: 4001,
        hot: true
    }
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;生成模式的 &lt;strong&gt;webpack.prod.js&lt;/strong&gt; 文件，只要定义了 &lt;strong&gt;mode:'production'&lt;/strong&gt;， &lt;strong&gt;webpack 4&lt;/strong&gt; 打包时就会自动压缩优化代码。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;const merge = require('webpack-merge');
const common = require('./webpack.common.js');

module.exports = merge(common, {
  mode: 'production',
  devtool: 'source-map'
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配置 &lt;strong&gt;package.js&lt;/strong&gt; 中的 &lt;strong&gt;scripts&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
  &quot;scripts&quot;: {
     &quot;start&quot;: &quot;webpack-dev-server --open --config webpack.dev.js&quot;,
     &quot;build&quot;: &quot;webpack --config webpack.prod.js&quot;
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;babel-的配置&quot;&gt;Babel 的配置&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;babel&lt;/strong&gt; 的 &lt;strong&gt;.babelrc&lt;/strong&gt; 文件， &lt;strong&gt;css module&lt;/strong&gt; 包这里推荐 &lt;em&gt;&lt;a href=&quot;https://github.com/gajus/babel-plugin-react-css-modules&quot;&gt;babel-plugin-react-css-modules&lt;/a&gt;&lt;/em&gt;。&lt;br/&gt;&lt;strong&gt;react-css-modules&lt;/strong&gt; 既支持全局的css(默认 &lt;strong&gt;className&lt;/strong&gt; 属性)，同时也支持局部css module( &lt;strong&gt;styleName&lt;/strong&gt; 属性)，还支持css预编译器，这里使用的是 &lt;strong&gt;scss&lt;/strong&gt;。&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
    &quot;presets&quot;: [
        &quot;@babel/preset-env&quot;,
        &quot;@babel/preset-react&quot;
    ],
    &quot;plugins&quot;: [
        &quot;@babel/plugin-proposal-class-properties&quot;,
        &quot;@babel/plugin-transform-runtime&quot;,
        [
            &quot;react-css-modules&quot;,
            {
                &quot;exclude&quot;: &quot;node_modules&quot;,
                &quot;filetypes&quot;: {
                    &quot;.scss&quot;: {
                        &quot;syntax&quot;: &quot;postcss-scss&quot;
                    }
                },
                &quot;generateScopedName&quot;: &quot;[name]___[local]___[hash:base64:5]&quot;
            }
        ]
    ]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;react-项目&quot;&gt;React 项目&lt;/h2&gt;
&lt;p&gt;下面是项目基本的目录树结构，接着从入口开始一步步细化整个项目。&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;├ package.json
├ src
│ ├ component // 组件目录
│ ├ reducer   // reducer目录
│ ├ action.js
│ ├ constants.js
│ ├ context.js
│ └ index.js
├ public // 静态文件目录
│ ├ css
│ └ index.html
├ .babelrc
├ webpack.common.js
├ webpack.dev.js
└ webpack.prod.js&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;状态管理组件使用 &lt;strong&gt;redux&lt;/strong&gt;， &lt;strong&gt;react-router&lt;/strong&gt; 用于构建单页面的项目，因为使用了 &lt;strong&gt;hooks&lt;/strong&gt; API，所以不再需要 &lt;strong&gt;react-redux&lt;/strong&gt; 连接状态 &lt;strong&gt;state&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;入口文件 &lt;strong&gt;index.js&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// index.js
import React, { useReducer } from 'react'
import { render } from 'react-dom'
import { HashRouter as Router, Route, Redirect, Switch } from 'react-router-dom'
import Context from './context.js'
import Home from './component/home.js'
import List from './component/list.js'
import rootReducer from './reducer'
import '../public/css/index.css'

const Root = () =&amp;gt; {
    const initState = {
        list: [
            { id: 0, txt: 'webpack 4' },
            { id: 1, txt: 'react' },
            { id: 2, txt: 'redux' },
        ]
    };
    // useReducer映射出state，dispatch
    const [state, dispatch] = useReducer(rootReducer, initState);
    // &amp;lt;Context.Provider value={{ state, dispatch }}&amp;gt; 基本代替了 react-redux 的 &amp;lt;Provider store={store}&amp;gt;
    return &amp;lt;Context.Provider value={{ state, dispatch }}&amp;gt;
        &amp;lt;Router&amp;gt;
            &amp;lt;Switch&amp;gt;
                &amp;lt;Route exact path=&quot;/&quot; component={Home} /&amp;gt;
                &amp;lt;Route exact path=&quot;/list&quot; component={List} /&amp;gt;
                &amp;lt;Route render={() =&amp;gt; (&amp;lt;Redirect to=&quot;/&quot; /&amp;gt;)} /&amp;gt;
            &amp;lt;/Switch&amp;gt;
        &amp;lt;/Router&amp;gt;
    &amp;lt;/Context.Provider&amp;gt;
}
render(
    &amp;lt;Root /&amp;gt;,
    document.getElementById('root')
)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;constants.js&lt;/strong&gt; ， &lt;strong&gt;action.js&lt;/strong&gt; 和 &lt;strong&gt;reducer.js&lt;/strong&gt; 与之前的写法是一致的。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// constants.js
export const ADD_COMMENT = 'ADD_COMMENT'
export const REMOVE_COMMENT = 'REMOVE_COMMENT'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;action.js&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// action.js
import { ADD_COMMENT, REMOVE_COMMENT } from './constants'

export function addComment(comment) {
  return {
    type: ADD_COMMENT,
    comment
  }
}

export function removeComment(id) {
  return {
    type: REMOVE_COMMENT,
    id
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;list.js&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;//list.js
import { ADD_COMMENT, REMOVE_COMMENT } from '../constants.js'

const list = (state = [], payload) =&amp;gt; {
    switch (payload.type) {
        case ADD_COMMENT:
            if (Array.isArray(payload.comment)) {
                return [...state, ...payload.comment];
            } else {
                return [...state, payload.comment];
            }
        case REMOVE_COMMENT:
            return state.filter(i =&amp;gt; i.id != payload.id);
        default: return state;
    }
};
export default list&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;reducer.js&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;//reducer.js
import { combineReducers } from 'redux'
import list from './list.js'
import user from './user.js'

const rootReducer = combineReducers({
  list,
  user
});

export default rootReducer&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最大区别的地方就是 &lt;strong&gt;component&lt;/strong&gt; 组件，基于 &lt;strong&gt;函数式&lt;/strong&gt;，内部的表达式就像是即插即用的插槽，可以很方便的抽取出通用的组件，然后从外部引用。相比之前的 &lt;strong&gt;面向对象&lt;/strong&gt; 方式，我觉得 &lt;strong&gt;函数表达式&lt;/strong&gt; 更受前端开发者欢迎。&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li&gt;&lt;strong&gt;useContext&lt;/strong&gt; 获取全局的 &lt;strong&gt;state&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;useRef&lt;/strong&gt; 代替之前的 &lt;strong&gt;ref&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;useState&lt;/strong&gt; 代替之前的 &lt;strong&gt;state&lt;/strong&gt;&lt;/li&gt;
&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;useEffect&lt;/strong&gt; 则可以代替生命周期钩子函数&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;//监控数组中的参数，一旦变化就执行
useEffect(() =&amp;gt; { updateData(); },[id]);

//不传第二个参数的话，它就等价于每次componentDidMount和componentDidUpdate时执行
useEffect(() =&amp;gt; { updateData(); });

//第二个参数传空数组，等价于只在componentDidMount和componentWillUnMount时执行， 
//第一个参数中的返回函数用于执行清理功能
useEffect(() =&amp;gt; { 
    initData(); 
    reutrn () =&amp;gt; console.log('componentWillUnMount cleanup...'); 
}, []);&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;最后就是实现具体界面和业务逻辑的组件了，下面是其中的List组件&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// list.js
import React, { useRef, useState, useContext } from 'react'
import { bindActionCreators } from 'redux'
import { Link } from 'react-router-dom'
import Context from '../context.js'
import * as actions from '../action.js'
import Dialog from './dialog.js'
import './list.scss'

const List = () =&amp;gt; {
    const ctx = useContext(Context);//获取全局状态state
    const { user, list } = ctx.state;
    const [visible, setVisible] = useState(false);
    const [rid, setRid] = useState('');
    const inputRef = useRef(null);
    const { removeComment, addComment } = bindActionCreators(actions, ctx.dispatch);

    const confirmHandle = () =&amp;gt; {
        setVisible(false);
        removeComment(rid);
    }

    const cancelHandle = () =&amp;gt; {
        setVisible(false);
    }

    const add = () =&amp;gt; {
        const input = inputRef.current,
            val = input.value.trim();
        if (!val) return;
        addComment({
            id: Math.round(Math.random() * 1000000),
            txt: val
        });
        input.value = '';
    }

    return &amp;lt;&amp;gt;
        &amp;lt;div styleName=&quot;form&quot;&amp;gt;
            &amp;lt;h3 styleName=&quot;sub-title&quot;&amp;gt;This is list page&amp;lt;/h3&amp;gt;
            &amp;lt;div&amp;gt;
                &amp;lt;p&amp;gt;hello, {user.name} !&amp;lt;/p&amp;gt;
                &amp;lt;p&amp;gt;your email is {user.email} !&amp;lt;/p&amp;gt;
                &amp;lt;p styleName=&quot;tip&quot;&amp;gt;please add and remove the list item !!&amp;lt;/p&amp;gt;
            &amp;lt;/div&amp;gt;
            &amp;lt;ul&amp;gt; {
                list.map(l =&amp;gt; &amp;lt;li key={l.id}&amp;gt;{l.txt}&amp;lt;i className=&quot;icon-minus&quot; title=&quot;remove item&quot; onClick={() =&amp;gt; {
                    setVisible(true);
                    setRid(l.id);
                }}&amp;gt;&amp;lt;/i&amp;gt;&amp;lt;/li&amp;gt;)
            } &amp;lt;/ul&amp;gt;
            &amp;lt;input ref={inputRef} type=&quot;text&quot; /&amp;gt;
            &amp;lt;button onClick={add} title=&quot;add item&quot;&amp;gt;Add Item&amp;lt;/button&amp;gt;
            &amp;lt;Link styleName=&quot;link&quot; to=&quot;/&quot;&amp;gt;redirect to home&amp;lt;/Link&amp;gt;
        &amp;lt;/div&amp;gt;
        &amp;lt;Dialog visible={visible} confirm={confirmHandle} cancel={cancelHandle}&amp;gt;remove this item ?&amp;lt;/Dialog&amp;gt;
    &amp;lt;/&amp;gt;
}

export default List;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;项目代码&quot;&gt;项目代码&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;&lt;a href=&quot;https://github.com/edwardzhong/webpack_react&quot; class=&quot;uri&quot;&gt;https://github.com/edwardzhong/webpack_react&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 04 Feb 2019 05:54:00 +0000</pubDate>
<dc:creator>Jeff.Zhong</dc:creator>
<og:description>面对日新月异的前端，我表示快学不动了😂。 Webpack 老早就已经更新到了 V4.x，前段时间 React 又推出了 hooks API。刚好春节在家里休假，时间比较空闲，还是赶紧把 React</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/edwardloveyou/p/10351697.html</dc:identifier>
</item>
<item>
<title>最简单的设计模式——单例模式的演进和推荐写法（Java 版） - dashuai的博客</title>
<link>http://www.cnblogs.com/kubixuesheng/p/10344533.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kubixuesheng/p/10344533.html</guid>
<description>&lt;p&gt;如下是之前总结的 C++ 版的；&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/kubixuesheng/p/4355055.html&quot;&gt;软件开发常用设计模式—单例模式总结（c++版）&lt;/a&gt;，对比发现 Java 实现的单例模式和 C++ 的在线程安全上还是有些区别的。&lt;/p&gt;
&lt;p&gt;概念不多说，没意思，我自己总结就是：&lt;/p&gt;
&lt;p&gt;有这样一个类，该类在生命周期内有且只能有一个实例，该类必须自己创建自己的这个唯一实例，该类必须给所有其他对象提供这一实例（提供全局访问点），这样的类就叫单例类。&lt;/p&gt;
&lt;p&gt;简单的说就是满足三个条件：&lt;/p&gt;
&lt;p&gt;1、生命周期内有且只能有一个实例&lt;/p&gt;
&lt;p&gt;2、自己提供这个独一无二的实例&lt;/p&gt;
&lt;p&gt;3、该实例必须是能全局访问的&lt;/p&gt;

&lt;p&gt;进一步，单例类，最好能实现懒加载，随用随生成，而不是初始化的时候就生成，提高启动速度和优化内存。&lt;/p&gt;
&lt;p&gt;还有应该考虑并发环境下的场景，多线程的单例模式实现有什么难点，回答这个问题，必须先知道Java的内存模型，参考：&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/kubixuesheng/p/5202556.html&quot;&gt;JVM学习（3）——总结Java内存模型&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;考虑黑客会做反序列化的攻击&lt;/p&gt;
&lt;p&gt;考虑黑客会做反射的攻击，因为反射可以访问私有方法&lt;/p&gt;
&lt;p&gt;。。。&lt;/p&gt;

&lt;p&gt;如果程序确认没有多线程的使用场景，完全可以简单一些写。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; NoThreadSafeLazySingleton {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; NoThreadSafeLazySingleton lazySingleton = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; NoThreadSafeLazySingleton() {
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; NoThreadSafeLazySingleton getLazySingleton() {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (lazySingleton == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            lazySingleton &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NoThreadSafeLazySingleton();
        }

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; lazySingleton;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;很简单，但是只适用于单线程环境&lt;/p&gt;

&lt;p&gt;原理也很简单，没什么可说的，如下示例代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ThreadSafeLazySingleton {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; ThreadSafeLazySingleton lazySingleton = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; ThreadSafeLazySingleton() {
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; ThreadSafeLazySingleton getLazySingleton() {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (lazySingleton == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt; (ThreadSafeLazySingleton.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (lazySingleton == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                    lazySingleton &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ThreadSafeLazySingleton();
                }
            }
        }

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; lazySingleton;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;主要是注意 volatile 关键字的使用，否则这种所谓双重检查的线程安全的单例是有 bug 的。参考：&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/kubixuesheng/p/5202556.html&quot;&gt;JVM学习（3）——总结Java内存模型&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;在某些情况中，JVM 隐含了同步操作，这些情况下就不用自己再来进行同步控制了。这些情况包括：&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;由静态初始化器（在静态字段上或static{}块中的初始化器）初始化数据时&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;访问final字段时&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;在创建线程之前创建对象时&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;线程可以看见它将要处理的对象时&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在静态内部类里去创建本类（外部类）的对象，这样只要不使用这个静态内部类，那就不创建对象实例，从而同时实现延迟加载和线程安全。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Integer age;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Person() {
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Person(String name, Integer age) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在静态内部类里去创建本类（外部类）的对象&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Person getInstance() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Holder.instatnce;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 静态内部类相当于外部类 Person 的 static 域，它的对象与外部类对象间不存在依赖关系，因此可直接创建。
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 因为静态内部类相当于其外部类 Person 的静态成员，所以在第一次被使用的时候才被会装载，且只装载一次。&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Holder {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 内部类的对象实例 instatnce ，是绑定在外部 Person 对象实例中的
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 静态内部类中可以定义静态方法，在静态方法中只能够引用外部类中的静态成员方法或者成员变量，比如 new Person
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用静态初始化器来实现线程安全的单例类，它由 JVM 来保证线程安全性。&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Person instatnce = &lt;span&gt;new&lt;/span&gt; Person(&quot;John&quot;, 31&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;静态内部类相当于外部类 Person 的 static 域（静态成员），它的对象与外部类对象间不存在依赖关系，因此可直接创建。&lt;/p&gt;
&lt;p&gt;既然，静态内部类相当于其外部类 Person 的静态成员，所以在第一次被使用的时候才被会装载，且只装载一次，实现了懒加载和单例。&lt;/p&gt;
&lt;p&gt;而且，使用静态初始化器来实现单例类，是线程安全的，因为由 JVM 来保证线程安全性&lt;/p&gt;
&lt;p&gt;客户端调用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
    Person person = Person.getInstance();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;该方案实现了，线程安全的单例 + 懒加载的单例，但是并不能防反序列化攻击，需要额外的加以约束。&lt;/p&gt;

&lt;p&gt;其实这个 case 没必要说太多，知道就行，因为哪里就这么巧，一个能序列化的类（实现了Serializable/Externalizable接口的类），就恰恰是单例的呢？&lt;/p&gt;
&lt;p&gt;看下面例子，把 Person 类改造为能序列化的类，然后用反序列攻击单例&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SerializationTest {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException, ClassNotFoundException {
        Person person &lt;/span&gt;=&lt;span&gt; Person.getInstance();
        ObjectOutputStream objectOutputStream &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ObjectOutputStream(&lt;span&gt;new&lt;/span&gt; FileOutputStream(&quot;person&quot;&lt;span&gt;));
        objectOutputStream.writeObject(person);

        ObjectInputStream objectInputStream &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ObjectInputStream(&lt;span&gt;new&lt;/span&gt; FileInputStream(&quot;person&quot;&lt;span&gt;));
        Person person1 &lt;/span&gt;=&lt;span&gt; (Person) objectInputStream.readObject();

        System.out.println(person &lt;/span&gt;== person1); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; false&lt;/span&gt;
&lt;span&gt;    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;比较两个 person 实例地址，是 false，说明生成了两个对象，违背了单例类的初衷，那么为了能在序列化过程仍能保持单例的特性，可以在Person类中添加一个readResolve()方法，在该方法中直接返回Person的单例对象&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object readResolve() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Holder.instatnce;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;原理是当从 I/O 流中读取对象时，ObjectInputStream 类里有 readResolve() 方法，该方法会被自动调用，期间经过种种逻辑，最后会调用到可序列化类里的 readResolve()方法，这样可以用 readResolve() 中返回的单例对象直接替换在反序列化过程中创建的对象，实现单例特性。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;也就是说，无论如何，反序列化都会额外创建对象，只不过使用 readResolve() 方法可以替换之。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;postTitle&quot;&gt;具体有关Java 对象的序列化可以参考笔记：&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/kubixuesheng/p/10350523.html&quot;&gt;深入理解Java对象序列化&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;直接看例子，做法很简单，通过 Java 的反射机制，看看能不能拿到单例类的私有构造器，并且改变构造器的访问属性&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ReflectTest {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, ClassNotFoundException {
        Person person &lt;/span&gt;=&lt;span&gt; Person.getInstance();

        Class clazz &lt;/span&gt;= Class.forName(&quot;com.dashuai.D13Singleton.Person&quot;&lt;span&gt;);
        Constructor constructor &lt;/span&gt;=&lt;span&gt; clazz.getDeclaredConstructor();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        constructor.setAccessible(true);&lt;/span&gt;
        Person person1 =&lt;span&gt; (Person) constructor.newInstance();

        System.out.println(person &lt;/span&gt;== person1); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; false&lt;/span&gt;
&lt;span&gt;    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行抛出了异常：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/682679/201902/682679-20190204004404503-618213571.png&quot; alt=&quot;&quot; width=&quot;691&quot; height=&quot;84&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是，如果把注释的行打开，就不会出错，且打印 false。&lt;/p&gt;
&lt;p&gt;网上有一些解决方案，比如在构造器里加判断，如果二次调用就抛出异常，其实也没从根本上解决问题。&lt;/p&gt;

&lt;p&gt;目前公认的最佳方案，代码极少，线程安全，防止反射和序列化攻击&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt;&lt;span&gt; EnumSingleton {
    ENUM_SINGLETON;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getName() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; name;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setName(String name) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
    }
}
&lt;/span&gt;&lt;span&gt;////////////////////////&lt;/span&gt;&lt;span&gt;调用&lt;/span&gt;
EnumSingleton.ENUM_SINGLETON.setName(&quot;dashuai&quot;&lt;span&gt;);
System.out.println(EnumSingleton.ENUM_SINGLETON.getName());&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;所有的变量都是单例的。至于为什么，可以通过反编译工具查看枚举的源码。可以安装 idea 的 jad 插件，会发现就是按照单例模式设计的。&lt;/p&gt;

&lt;p&gt;享元模式是对象级别的, 也就是说在多个使用到这个对象的地方都只需要使用这一个对象即可满足要求。&lt;/p&gt;
&lt;p&gt;单例模式是类级别的, 就是说这个类必须只能实例化出来一个对象。&lt;/p&gt;
&lt;p&gt;可以这么说, 单例是享元的一种特例, 设计模式不用拘泥于具体代码, 代码实现可能有n多种方式, 而单例可以看做是享元的实现方式中的一种, 他比享元模式更加严格的控制了对象的唯一性&lt;/p&gt;

&lt;p&gt;1、单例类只能有一个实例。&lt;/p&gt;
&lt;p&gt;2、单例类必须自己创建自己的唯一实例。&lt;/p&gt;
&lt;p&gt;3、单例类必须给所有其他对象提供这一实例。&lt;/p&gt;

&lt;p&gt;java.lang.runtime getRuntime，代码也很简单。 &lt;/p&gt;
</description>
<pubDate>Mon, 04 Feb 2019 03:11:00 +0000</pubDate>
<dc:creator>dashuai的博客</dc:creator>
<og:description>前言 如下是之前总结的 C++ 版的；软件开发常用设计模式—单例模式总结（c++版），对比发现 Java 实现的单例模式和 C++ 的在线程安全上还是有些区别的。 概念不多说，没意思，我自己总结就是：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kubixuesheng/p/10344533.html</dc:identifier>
</item>
<item>
<title>ES6躬行记（7）——代码模块化 - 咖啡机（K.F.J）</title>
<link>http://www.cnblogs.com/strick/p/10173976.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/strick/p/10173976.html</guid>
<description>&lt;p&gt;　　在ES6之前，由于ECMAScript不具备模块化管理的能力，因此往往需要借助第三方类库（例如遵守AMD规范的RequireJS或遵循CMD规范的SeaJS等）才能实现模块加载。而自从ES6引入了模块化标准后，就不需要再特地加载一次外部脚本了。模块化的语法不仅让JavaScript代码的组织变得更有条理，还包含封装、按需导出或导入等实用功能，可轻松应对日益复杂和庞大的前端工程。但有一点要注意，模块中的代码默认运行在严格模式中。&lt;/p&gt;

&lt;p&gt;　　一个模块就是一个独立的JavaScript文件，如果要读取文件内的变量、函数或类（ES6新增的概念），那么必须先将它们用export关键字导出，因为它们默认都是私有的。导出的方式有多种，下面会依依列举。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1）第一种&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　将export关键字放在变量、函数等声明之前，常被称为命名导出（named export），如下所示。注意，命名导出的变量或函数都需要有名称，否则会抛出语法错误。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
export let name = &quot;strick&quot;&lt;span&gt;;
export &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; getName() {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;strick&quot;&lt;span&gt;;
}
export class people {
  getName() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;strick&quot;&lt;span&gt;;
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　以上述代码中的name变量为例，本质上，export导出的是变量本身的引用，也就是为该变量在两个模块之间建立一种关联（即绑定）。如果变量在模块内部实时更新了，那么导出的变量的值也会随之改变。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;2）第二种&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　第二种也叫命名导出，只是形式不同，声明和导出会分成两步，要导出的标识符会用花括号包裹起来，如下代码所示。此时，还能通过as关键字为导出的变量、函数等设置别名。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
let age = 28&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; getAge() {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 28&lt;span&gt;;
}
export { age, getAge };
export { age as myAge, getAge as getMyAge };        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置别名&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3）第三种&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　第三种用于导出模块的全部或部分成员（例如变量、函数或类等），此时需要包含四部分，分别是导出标识符、模块路径（也叫模块说明符，module specifier）以及两个关键字：export和from。如果要导出全部，那么导出标识符得用星号（*）表示；而如果只要导出部分，那么导出标识符可以像第二种命名导出那么写，具体如下代码所示。注意，模块路径不能简写，需要以“/”、“./”或“../”开头，千万不要因为文件在同级就省略相应的字符。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
export * from &quot;./1.js&quot;;                    　　　　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt;导出全部&lt;/span&gt;
export { name, age } from &quot;./1.js&quot;;                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;导出部分&lt;/span&gt;
export { getAge as getMyAge } from &quot;./1.js&quot;;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;导出部分并设置别名&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面代码的第二条导出语句，其实可以分解成下面两条语句，第三条也有类似的分解。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
import { name, age } from &quot;./1.js&quot;&lt;span&gt;;
export { name, age };&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　如果想导入某个模块的成员，可以使用import关键字。它的语法与前面第三种导出方式类似，也包含四个部分，分别是导入标识符、模块路径以及两个关键字：import和from，其中模块路径也不能简写，如下代码所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
import * as people from &quot;./1.js&quot;;                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;导入全部&lt;/span&gt;
import { name, age } from &quot;./1.js&quot;;              &lt;span&gt;//&lt;/span&gt;&lt;span&gt;导入部分&lt;/span&gt;
import { getAge as getMyAge } from &quot;./1.js&quot;;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;导入部分并设置别名&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　注意上面的第一行代码，使用了命名空间导入（Namespace Import）。与导出模块的全部成员不同，在导入时，除了要与星号组合之外，还必须为其设置别名。这是由于加载的整个模块会被当成一个对象，而此对象需要一个名称，它的属性就是该模块所有的导出。另外两行使用了命名导入（Named Import），花括号内的导入标识符要与模块的导出标识符一一对应。&lt;/p&gt;
&lt;p&gt;　　import语句在内部实现了单例模式，尽管上面代码对同一个模块执行了三次导入，但该模块只会被实例化一次。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1）只读变量&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　用import导入的变量都是只读的，相当于为它添加了const限制，如果在模块中为其重新赋值，那么必会引起类型错误。想要更新导入的变量的值，有一种间接的实现办法，如下代码所示，先在要导出的1.js模块内定义name变量和setName()函数。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
export let name = &quot;strick&quot;&lt;span&gt;;
export &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; setName(str) {
  name &lt;/span&gt;=&lt;span&gt; str;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　然后在另一个模块中导入刚刚的两个成员，接着将新的name值通过setName()函数传入到1.js模块内部进行更新，如下代码所示，name变量最终输出的结果正是那个新值。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
import { name, setName } from &quot;./1.js&quot;&lt;span&gt;;
console.log(name);        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;&quot;strick&quot;&lt;/span&gt;
setName(&quot;freedom&quot;&lt;span&gt;);
console.log(name);        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;&quot;freedom&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2）成员提升&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　从模块中导入的成员默认都会被提升至当前模块作用域的顶部，类似于声明提升。因此，像下面这样的写法都是正确的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;console.log(age);
getAge();
import { age, getAge } from &lt;/span&gt;&quot;./1.js&quot;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3）简洁导入&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　import语句中的导入标识符和from关键字都是可选的，但要注意，只有当两者一起省略时，语句才能被正确执行，如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
import &quot;./jquery.js&quot;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　由于import加载的模块都会被执行一次，因此可以用上面这种简洁导入来实现脚本的预加载。而这些脚本既可以是自己封装的代码段，也可以是jQuery、Zepto等第三方类库。&lt;/p&gt;

&lt;p&gt;　　ES6中的default关键字可指定模块的默认值（例如变量、函数或类等），即为模块指定默认的导出和导入。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1）默认导出&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　一个模块只能存在一个默认导出，下面会列出默认导出的四种写法，为了便于比较，将它们放在了一起。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
let name = &quot;strick&quot;&lt;span&gt;;
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; name;                　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt;写法一&lt;/span&gt;
export &lt;span&gt;default&lt;/span&gt; &lt;span&gt;function&lt;/span&gt; getName() {    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;写法二&lt;/span&gt;
  &lt;span&gt;return&lt;/span&gt; &quot;strick&quot;&lt;span&gt;;
}
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;() {            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;写法三&lt;/span&gt;
  &lt;span&gt;return&lt;/span&gt; &quot;strick&quot;&lt;span&gt;;
}
export { name as &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; };            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;写法四&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　export语句中的default其实就是要导出的模块成员，它的名称就叫default，而default后面能够跟一个表达式、命名函数或匿名函数，注意观察上面代码的前三种写法。第四种写法比较特殊，是在命名导出时，将标识符重命名成default。&lt;/p&gt;
&lt;p&gt;　　默认导出可以简单的理解为给default赋值，因此下面的前两条语句都能被正确执行，而第三条语句由于包含了声明变量的关键字（let），所以会引起语法错误。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
export &lt;span&gt;default&lt;/span&gt; name = &quot;strick&quot;&lt;span&gt;;
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; &quot;strick&quot;&lt;span&gt;;
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; let name = &quot;strick&quot;;            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;语法错误&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2）默认导入&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　如果要导入模块的默认值，那么可以像下面这样写，同样，为了便于比较，将它们放在了一起。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
import name from &quot;./1.js&quot;;                　　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt;写法一&lt;/span&gt;
import name, { age } from &quot;./1.js&quot;;            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;写法二&lt;/span&gt;
import name, * as people from &quot;./1.js&quot;;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;写法三&lt;/span&gt;
import { &lt;span&gt;default&lt;/span&gt; as myName } from &quot;./1.js&quot;;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;写法四&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　因为模块只能有一个默认导出，所以对应的导入标识符可以不用花括号包裹（注意观察前三种写法），不仅如此，还能像第四种写法那样通过default关键字为其重命名。但有一点要注意，当同时使用默认和非默认的导入标识符时，必须把默认的写在前面。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;1）模块路径&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　由于ES6中的模块被设计成了静态的，因此需要在编译阶段就明确模块之间的依赖关系，而不是在运行过程中动态计算，像下面这样将模块路径设为变量或表达式都是错误的写法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
let path = &quot;./1.js&quot;&lt;span&gt;;
export &lt;/span&gt;* from path;                　　　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt;变量&lt;/span&gt;
export * from &quot;./&quot; + &quot;1.js&quot;;            　&lt;span&gt;//&lt;/span&gt;&lt;span&gt;表达式&lt;/span&gt;
import * as people from path;        　　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt;变量&lt;/span&gt;
import * as people from &quot;./&quot; + &quot;1.js&quot;;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;表达式&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2）作用域&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　export和import语句都是静态的，无法动态导出和导入。因此只能出现在模块的顶层作用域中，而不能出现在块级或函数作用域中，下面的写法都会引起语法错误。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;函数作用域&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; getName() {
  export &lt;/span&gt;* from &quot;./1.js&quot;&lt;span&gt;;
  import &lt;/span&gt;* as people from &quot;./1.js&quot;&lt;span&gt;;
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;块级作用域&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;) {
  export &lt;/span&gt;* from &quot;./1.js&quot;&lt;span&gt;;
  import &lt;/span&gt;* as people from &quot;./1.js&quot;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3）标识符&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　导出和导入语句中的标识符如果重复，那么也会引起语法错误，如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
export { name, name } from &quot;./1.js&quot;&lt;span&gt;;
import { name, name } from &lt;/span&gt;&quot;./1.js&quot;;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　在浏览器中，无论是以外部还是内联的方式嵌入模块文件，都需要将它的type属性设为“module”，如下代码所示。并且在加载模块时为了避免脚本阻塞，会自动应用布尔属性defer，即HTML文档的解析和模块文件的下载是同时进行的，待到解析完后才会执行模块。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;1.js&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;module&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;module&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
  import { name } from &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;./1.js&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;; 
  console.log(name);
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;2.js&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;module&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面代码会被依次执行，先执行第一个外部模块，再执行内联模块，最后执行第二个外部模块。注意，在每个模块中用import导入的其它模块也会被解析和下载，并且同一个模块每次只能被加载一次。&lt;/p&gt;

</description>
<pubDate>Mon, 04 Feb 2019 01:47:00 +0000</pubDate>
<dc:creator>咖啡机（K.F.J）</dc:creator>
<og:description>在ES6之前，由于ECMAScript不具备模块化管理的能力，因此往往需要借助第三方类库（例如遵守AMD规范的RequireJS或遵循CMD规范的SeaJS等）才能实现模块加载。而自从ES6引入了模块</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/strick/p/10173976.html</dc:identifier>
</item>
<item>
<title>进行概念详解 多线程上篇（二） - noteless</title>
<link>http://www.cnblogs.com/noteless/p/10350186.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/noteless/p/10350186.html</guid>
<description>&lt;p&gt;&lt;span&gt;操作系统是程序与硬件交互的中间层，现代操作系统将程序的一次执行抽象为进程和线程的概念。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;进程作为资源分配的基本单位，线程作为执行的基本单位。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;进程和线程其实就是操作系统程序本身实现控制一个程序运行的数据项描述&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;所有的程序都是面向语言进行开发的，而语言本身是面向操作系统的，线程是操作系统对程序一次运行的抽象&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以，所有的多线程编程模型，必然遵从操作系统的大逻辑，必然是符合操作系统的对线程的抽象概念，操作系统在抽象之上提供了API供应用程序调用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;简言之，应用程序的底层是借助于操作系统来完成多线程编程模型的，所以怎么可能逾越系统这一根本？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本篇对操作系统中线程进程相关概念进行简单介绍&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;进程&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;在很久很久之前的串行执行时，程序按顺序加载到计算机中并运行，程序独占计算机的所有资源&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;程序具有顺序性，封闭性和可重现性&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span&gt;多道程序出现之后，程序需要并发的执行，计算机的资源是共享的，而不再是某一程序运行后独享&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;所以不再是顺序的，而是间断的，也不再是封闭，也不再具有可重现性&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190203125847889-1420880069.png&quot;&gt;&lt;img title=&quot;image_5c56750f_433&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190203125848409-1166457291.png&quot; alt=&quot;image_5c56750f_433&quot; width=&quot;909&quot; height=&quot;606&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;还是以做饭为例，当只有你一个人使用厨房时，你可以随便；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是当多个人共享时，如果你还把你自己切了一半的菜扔到那边，可能会被扔掉，可能会被用掉，当然也可能没事。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为了解决程序并发执行的问题，进程的概念被抽象出来，其实就相当于“一个厨房使用规章”被制定出来&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以说进程和线程就是操作系统用来管理维护一个程序的运行于切换而设计出来的一个概念，然后通过各种数据结构以及值等实现描绘出来&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;进程实体&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一个程序的运行主要下面几个部分的数据&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;进程本身的信息（现在谁在用厨房？现在盆盆罐罐都被你放了什么？）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;可执行的代码是哪些？（菜谱步骤是什么？）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;程序运行所需要的数据是什么？（食材是什么？佐料又是什么？）&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;程序段、数据段、PCB（Process Control Block）三部分构成了进程实体&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190203125848727-607533876.png&quot;&gt;&lt;img title=&quot;image_5c567510_705&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190203125849136-1507469912.png&quot; alt=&quot;image_5c567510_705&quot; width=&quot;533&quot; height=&quot;340&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;h4&gt;&lt;span&gt;进程特征&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;程序的并发运行与之前的串行顺序运行有了很大的变化，主要有下面几个特征&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;动态性&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;并发性&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;独立性&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;异步性&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;div&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190203125849712-1622855433.png&quot;&gt;&lt;img title=&quot;image_5c567510_5e4b&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190203125851198-1914655961.png&quot; alt=&quot;image_5c567510_5e4b&quot; width=&quot;693&quot; height=&quot;426&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;

&lt;h3&gt;&lt;span&gt;进程状态&lt;/span&gt;&lt;/h3&gt;
&lt;h4&gt;&lt;span&gt;基本状态&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;多人轮流使用厨房时，某一时刻的你到底是做完饭了？还是还在排队？还是正在做？你会有一个状态用来表述你现在的这种情况&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于进程也有状态的概念&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最基本的状态包括：&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;创建&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;就绪&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;执行&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;阻塞&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;终止&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;其中核心是：就绪、执行、阻塞&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190203125852535-1590961683.png&quot;&gt;&lt;img title=&quot;image_5c567510_26b3&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190203125854495-1032746872.png&quot; alt=&quot;image_5c567510_26b3&quot; width=&quot;876&quot; height=&quot;517&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;基本的状态切换如下&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190203125855520-1315833933.png&quot;&gt;&lt;img title=&quot;image_5c567510_5a7d&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190203125857162-1974986263.png&quot; alt=&quot;image_5c567510_5a7d&quot; width=&quot;634&quot; height=&quot;366&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;状态转变简介：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;进程创建后，会创建PCB，以及相关的必须信息，然后就进入就绪状态，等待CPU的调度&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一旦CPU对该进程调度执行，也就是该进程获得了时间片，那么就会进行执行&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当时间片用完之后，如果任务还没有结束，那么就需要继续等待（比如你做饭需要5小时，然而每个人只允许2小时，如果2小时你做不完，你必须让别人先做，你重新排队来）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果一个正在执行的程序遇到了IO请求，这通常是比较耗时的，进程会进入阻塞状态&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;进入阻塞状态的进程一旦获得了想要的结果，比如IO完成，那么就再次进入就绪状态，等待CPU的临幸&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;挂起状态&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;有些系统中，还会有挂起状态，可能系统需要让正在执行的程序暂停下来，也可能是资源不足了，将某些不重要的进程暂停。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;挂起是更彻底的暂停，可以认为挂起是“暂时被淘汰出内存的进程”&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;阻塞状态获得资源后会进入就绪状态，而一旦挂起，除非解除这个状态，否则他将一直暂停，被抛出运行之外&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;阻塞是因为某些原因暂时不能被执行，挂起是直接将你暂停&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当你做饭时等待水烧开，这就是阻塞，而如果是老大说我们几个人先来，于是他们几个轮流使用，然后你站门口看着，这就是挂起&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190203125859618-1318349754.png&quot;&gt;&lt;img title=&quot;image_5c567510_710c&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190203125904983-1891994769.png&quot; alt=&quot;image_5c567510_710c&quot; width=&quot;660&quot; height=&quot;536&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;包含挂起状态的系统基本情况如上图所示&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;就绪状态挂起后称之为静态就绪，阻塞状态挂起后称之为静态阻塞，挂起后的状态不能够直接转换到执行状态&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;活动状态经过挂起转换为静止状态，静止状态经过激活转换为活动状态&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;活动就绪与静止就绪通过挂起和激活转换；活动阻塞与静止阻塞通过挂起和激活转换；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;活动就绪的状态经过进程调度获得CPU时间片，进入执行状态，执行状态遇到请求IO等阻塞操作进入活动阻塞状态，活动阻塞状态IO完成将会进入活动就绪状态，继续等待被CPU临幸，如上图蓝色三角区域&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;看起来复杂其实也很好理解，前提是要理解挂起的含义&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;比如资源不充足时，将一些不重要的进程暂时挂起，挂起是真正的暂停执行，是一种主动式的管理，阻塞则是被动的，挂起也意味着置换到外存中，而不是内存中&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不管是活动阻塞还是活动就绪，他们都在内存中，具备了相关条件，IO完成或者获得CPU时间片，就可以进行执行&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;挂起（静止）状态，静止阻塞还是静止就绪，他们都是外存中，并不能够执行，他们还需要一个载入到内存的过程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一个静止阻塞的状态就相当于在外存中等待一个事件的完成，事件完成后，进入静止就绪状态，他此时还是不会得到CPU的调度，激活后才有机会得到CPU临幸&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;存在挂起状态的系统，经过创建后，可能进入活动就绪，也可能进入静止就绪，并不是一定进入活动就绪，然后再被挂起&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;在当前系统的性能和内存的容量均允许的情况下，完成对进程创建的必要操作后，相应的系统进程将进程的状态转换为活动就绪状态&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;考虑到系统当前资源状况和性能要求，并不分配给新建进程所需资源，主要是主存资源，相应的系统进程将进程状态转为静止就绪状态&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;h4&gt;&lt;span&gt;终止状态的转换&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;终止状态通常是从执行状态进行转换，一般情况下不管一个什么状态的线程，他只有被执行时，才会可能进入终止状态&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是，在某些系统中，父进程有权利终止一个子进程，所以说这种情况下，就可能从阻塞或者就绪直接转换为终止状态&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;进程控制块&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;进程是对于程序执行的抽象描述，那么进程控制块，这个对进程的描述，就相当于进程的元数据，用于描述进程本身&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;尽管实现很复杂，但是我们应该想象得到，操作系统内核都是C/C++，毕竟也只是一种编程语言，编程语言对于抽象概念的描述也只能是通过语言本身&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;所以说，他就是一个数据结构，记录了用于控制管理进程的各个数据项。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;20.5&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;“PCB 中记录了操作系统所需的、用于描述进程的当前情况以及控制进程运行的全部信息。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;进程控制块的作用是使一个在多道程序环境下不能独立运行的程序(含数据)，成为一个能独立运行的基本单位，一个能与其它进程并发执行的进程。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;或者说&lt;/span&gt;，&lt;span&gt;&lt;strong&gt;OS是根据 PCB来对并发执行的进程进行控制和管理的&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;21&quot;&gt;
&lt;p&gt;&lt;span&gt;例如，当OS要调度某进程执行时，要从该进程的 PCB&lt;span&gt;中查出其现行状态及优先级；&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;在调度到某进程后，要根据其 PCB 中所保存的处理机状态信&lt;/span&gt;&lt;span&gt;息，设置该进程恢复运行的现场，并根据其 PCB 中的程序和数据的内存始址，找到其程序&lt;/span&gt;&lt;span&gt;和数据；&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;进程在执行过程中，当需要和与之合作的进程实现同步、通信或访问文件时，也&lt;/span&gt;&lt;span&gt;都需要访问 PCB；&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;当进程由于某种原因而暂停执行时，又须将其断点的处理机环境保存在&lt;/span&gt;&lt;span&gt;PCB中。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;可见，在进程的整个生命期中，系统总是通过 PCB对进程进行控制的，亦即，系&lt;/span&gt;&lt;span&gt;统是根据进程的PCB而不是任何别的什么而感知到该进程的存在的。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;所以说，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;PCB是进程&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;存在的惟一标志&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;”《计算机操作系统 第三版》&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;div&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190203125906994-547184057.png&quot;&gt;&lt;img title=&quot;image_5c567510_4ccc&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190203125907476-643470710.png&quot; alt=&quot;image_5c567510_4ccc&quot; width=&quot;948&quot; height=&quot;932&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;进程控制块主要包括:&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;进程标识符&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;计算机状态&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;进程调度信息&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;进程控制信息&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;进程用来管理程序运行，对于一个运行中的程序总归要有个名字，这就是进程标识符；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;计算机运行时各个硬件设备寄存器保存的值就是计算机的状态（如同做饭时厨房盆盆罐罐里面的东西）；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;进程有状态，这些状态信息主要用来进行调度，也就是安排任务需要的信息（可能你长得好看，就能多一次机会使用厨房）；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;另外还有一些对进程的控制，比如进程（线程）同步数据、程序地址等&lt;/span&gt;&lt;/p&gt;

&lt;div readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span&gt;在一个系统中，通常可拥有数十个、 数百个乃至数千个 PCB。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;为了能对它们加以有效的管理，应该用适当的方式将这些PCB组织起来。目前常用的组织方式有以下两种。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190203125909595-588618957.png&quot;&gt;&lt;img title=&quot;image_5c567510_7bb2&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190203125910905-1765764387.png&quot; alt=&quot;image_5c567510_7bb2&quot; width=&quot;623&quot; height=&quot;302&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;三座大山&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;进程作为操作系统对程序一次运行的抽象描述&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;进程的基本信息相当于元数据，就好像表结构一样以及一些必备的数据结构&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于进程的掌控主要有三座大山：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;进程控制、进程同步、进程通信&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;进程控制：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一个进程从无到有，需要创建，创建之后因为调度而运行，因为撤销而消亡，需要有人管理他们，进程基本信息比如PCB从哪里来？都需要有人去做，这部分工作被称为进程控制&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;进程同步：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;多进程并发执行，必然可能会出现竟态，比如同时访问某个共享资源，一个打印机不能同时打印语文和数学，所以必须做好顺序的调度，这部分的工作被称之为进程同步&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;进程通信：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;多进程并发运行，如何进行进程间的联系，如何传递数据？不同计算机中的两个进程又是如何进行数据交互？这部分工作被称之为进程通信&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;如果一个员工是一个进程，进程控制相当于人事、财务部门，负责招聘薪资考勤等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;进程同步相当于项目经理，负责项目中各人员的任务分配调度。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;进程通信就相当于一种工作方式、沟通形式，比如你给我一个SVN标签号并且告知我意图，我去库中检索指定标签修改的指定内容，就完成了一个任务的协作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比喻或许不足够恰当，仅供个人理解。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;进程作为操作系统对程序执行的抽象，那么就使用了足够多的数据项对进程进行描述，所有的信息都是为了进程的管理、维护、调度、切换等&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;就比如你用一个数组以及一个栈顶标记来描述一个堆栈，如下图所示&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190203125911461-133691195.png&quot;&gt;&lt;img title=&quot;image_5c567510_739&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190203125911988-836058426.png&quot; alt=&quot;image_5c567510_739&quot; width=&quot;493&quot; height=&quot;403&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;数组a[]以及变量top就是使用数组对栈这种数据结构进行抽象描述的数据项，对于数据元素操作访问（入栈、出栈）限制就是规则&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;进程看似复杂，原理也是如此，操作系统使用多个数据项（数据结构）对程序的执行进行描述，然后定义了一整套的操作逻辑与规则&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这就是我们现在学习的进程的运行原理&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通过编码将设计思路以及运行规则从抽象到具体数据结构以及编码的实现就完成了进程的实现。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;操作系统想要管理程序的运行，需要指定一个唯一的标识符，既然放一群羊，还想对羊进行合理的管理识别，最简单的办法就是每只羊挂个项圈写上序号。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;进程有状态信息，操作系统负责管理状态的切换，那么必然需要记录进程的状态信息&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;既然是轮流分配时间片，就好像去办理业务，排队等待一样，但是无数个场景下都有VIP的存在，进程也是，也有优先级的概念&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;计算机的程序最终会转换为一条条的指令，每一条指令的执行都需要借助于程序计数器，程序计数器是用于存放下一条指令所在单元的地址的地方，所以想要知道并且记住程序执行的进度位置，还需要掌握程序计数器的值&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;我们熟悉的x86和arm指令大多都是基于寄存器的（虚拟机VM是基于栈）基于寄存器的架构最明显的特征就在于指令的执行要依赖寄存器，如同厨房的盆盆罐罐，里面装着运行时的状态数据、值（好比计算1+2+3+4，1放到a寄存器，2放到b寄存器，add a，b 计算中间结果，这句纯属为了说明，具体不要较真）   &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;想要更好地管理进程，那么必然还会有一些统计信息，比如某进程运行了多久等记录统计信息&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这些重要的信息都保存在进程的PCB中，所以说PCB是进程概念的核心，有了PCB程序才有并发执行的能力，通常，通常情况下，创建进程指的就是创建PCB&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;简言之，操作系统对进程的抽象就是对于一组数据结构以及操作这些数据结构的规则逻辑的实现。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;进程的核心状态有执行、就绪、阻塞。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;就绪就是一切准备妥当，可以被执行，就差CPU时间片了，在执行过程中如果时间片用完，那么仍旧是转换为就绪状态，他什么都不差，只是被剥夺了时间片&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;执行状态下，如果执行不下去了，比如需要等待IO，就会进入阻塞，阻塞必须要等到要等的事情发生才会解除阻塞，因为他差一个事件的发生和时间片，事件到达就解除阻塞，所以就差时间片了，所以转换为就绪状态&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如你去银行办业务，人家手续都带好了在那边排队就是就绪，你身份证没复印好，就得先复印好身份证再过来排队，否则即使到你了，你也办不成&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;就绪涉及到很多事情要处理，所以为了更加安全合理，有了创建的状态，创建就是为了保障就绪是真的就绪了，也就是检查你的确各种资料都带齐全了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;终止状态也是类似为了更合理安排管理，结束后也有一些事情需要做，比如你把你的资料状态或者还可能要排队领取个什么别的东西，这些都不需要在柜台了，在大厅自助或者找大堂经理就好了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;进程涉及到各种数据结构，各种规则处理，所以进程很复杂，但是进程又很简单，就好比单例模式的实现有多种方式有些比较复杂，但是逻辑上却又很清晰，保证唯一&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 04 Feb 2019 00:58:00 +0000</pubDate>
<dc:creator>noteless</dc:creator>
<og:description>多并发的概念本身就是来自于计算机操作系统的进程的概念，本文对进程的相关概念进行讲解，对进程进行了介绍，只有了解了最根本最核心的内容才能够对后续多线程以及Java的并发有很好的掌握</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/noteless/p/10350186.html</dc:identifier>
</item>
</channel>
</rss>