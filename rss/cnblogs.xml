<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>《吊打面试官》系列-Redis哨兵、持久化、主从、手撕LRU - 敖丙</title>
<link>http://www.cnblogs.com/aobing/p/11832602.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/aobing/p/11832602.html</guid>
<description>&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;你知道的越多，你不知道的越多&lt;/p&gt;
&lt;p&gt;点赞再看，养成习惯&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;h&quot;&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Redis&lt;/strong&gt;在互联网技术存储方面使用如此广泛，几乎所有的后端技术面试官都要在&lt;strong&gt;Redis&lt;/strong&gt;的使用和原理方面对小伙伴们进行360°的刁难。作为一个在互联网公司面一次拿一次offer的面霸（&lt;strong&gt;请允许我使用一下夸张的修辞手法&lt;/strong&gt;），打败了无数竞争对手，每次都只能看到无数落寞的身影失望的离开，略感愧疚，在一个寂寞难耐的夜晚，我痛定思痛，决定开始写&lt;strong&gt;《吊打面试官》&lt;/strong&gt;系列，希望能帮助各位读者以后面试势如破竹，对面试官进行360°的反击，吊打问你的面试官，让一同面试的同僚瞠目结舌，疯狂收割大厂&lt;strong&gt;Offer&lt;/strong&gt;！&lt;/p&gt;
&lt;h2 id=&quot;h-1&quot;&gt;&lt;span&gt;絮叨&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;写这期其实比较纠结，我之前的写的比较通俗易懂，一是我都知道这些点，二是之前我在所在的电商公司对雪崩，击穿啥的还算有场景去接触。但是线上的Redis集群我实际操作经验很少，总不能在公司线上环境实践那些操作吧，所以最后看了下官网，还有一些资料（文章后面我都会贴出来），强行怼了这么篇出来。&lt;/p&gt;
&lt;p&gt;最近双十一小忙，周末双十一值班目测没时间写，那我是暖男呀，我不能鸽啊，就有了这一篇，下一篇迟到你们不要喷我哈，而且下一篇还是&lt;strong&gt;Redis&lt;/strong&gt;的终章还是得构思下，不熟悉的知识点我怕漏洞多，特意让以前的大牛同事看了下，所以有啥不对的地方大家及时留言&lt;strong&gt;Diss&lt;/strong&gt;我，写这篇是真的难，诺下面就是我本人某天凌晨两点的拍的视频，多动症的仔。&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/006y8mN6ly1g8p9gh78ueg30hs0a8e81.gif&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;之前说过系列第二篇到300赞我就发第三篇&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/006y8mN6ly1g8pc846lx5j30ad08lq5v.jpg&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006y8mN6ly1g8pcvajvgcj30jk0390t6.jpg&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;咋样没骗你们吧，就很枯竭，不BB了，开搞。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不点个赞对不起我，这次不要白嫖我！&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;h-2&quot;&gt;&lt;span&gt;正文&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;上几期&lt;strong&gt;《吊打面试官》&lt;/strong&gt;还没看的小伙伴可以回顾一下（明明就写了两期说的好像很多一样）！&lt;/p&gt;
&lt;p&gt;大家都知道一个技术的引入方便了开发，解决了各种问题，但是也会带来对应的问题，&lt;strong&gt;技术是把双刃剑&lt;/strong&gt;嘛，集群的引入也会带来很多问题，如：集群的高可用怎么保证，数据怎么同步等等，我们话不多说，有请下一位受害者为我们展示。&lt;/p&gt;
&lt;h3 id=&quot;h-3&quot;&gt;&lt;span&gt;面试开始&lt;/span&gt;&lt;/h3&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;三个大腹便便，穿着格子衬衣的中年男子，拿着三个满是划痕的mac向你走来，看着快秃顶的头发，心想着肯定是尼玛顶级架构师吧！而且还是三个，但是还好我看过敖丙写的《吊打面试官》系列，腹有诗书气自华，根本虚都不虚好伐。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/006y8mN6ly1g8p9gdh974j30t00dm408.jpg&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;h4 id=&quot;hredis&quot;&gt;&lt;span&gt;小伙子你好，之前问过了你基础知识以及一些缓存的常见几个大问题了，那你能跟我聊聊为啥Redis那么快么？&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;哦，帅气迷人的面试官您好，我们可以先看一下关系型数据库跟Redis本质上的区别。&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/006y8mN6ly1g8p9giaxfbj31dq0mk0vc.jpg&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;&lt;strong&gt;Redis&lt;/strong&gt;采用的是基于内存的采用的是单进程单线程模型的 KV 数据库，由C语言编写，官方提供的数据是可以达到100000+的&lt;strong&gt;QPS（每秒内查询次数）&lt;/strong&gt;。&lt;/p&gt;
&lt;ul readability=&quot;5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。它的，数据存在内存中，类似于&lt;strong&gt;HashMap&lt;/strong&gt;，&lt;strong&gt;HashMap&lt;/strong&gt;的优势就是查找和操作的时间复杂度都是O(1)；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;数据结构简单，对数据操作也简单，&lt;strong&gt;Redis&lt;/strong&gt;中的数据结构是专门进行设计的；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 &lt;strong&gt;CPU&lt;/strong&gt;，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;使用多路I/O复用模型，非阻塞IO；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，&lt;strong&gt;Redis&lt;/strong&gt;直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;h-4&quot;&gt;&lt;span&gt;我可以问一下啥是上下文切换么？&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;我可以打个比方么：我记得有过一个小伙伴微信问过我上下文切换是啥，为啥可能会线程不安全，我是这么说的，就好比你看一本英文书，你看到第十页发现有个单词不会读，你加了个书签，然后去查字典，过了一会你又回来继续从书签那里读，ok到目前为止没啥问题。&lt;/p&gt;
&lt;p&gt;如果是你一个人读肯定没啥问题，但是你去查的时候，别的小伙伴好奇你在看啥他就翻了一下你的书，然后溜了，哦豁，你再看的时候就发现书不是你看的那一页了。不知道到这里为止我有没有解释清楚，以及为啥会线程不安全，就是因为你一个人怎么看都没事，但是人多了换来换去的操作一本书数据就乱了。可能我的解释很粗糙，但是道理应该是一样的。&lt;/p&gt;
&lt;h3 id=&quot;h-5&quot;&gt;&lt;span&gt;那他是单线程的，我们现在服务器都是多核的，那不是很浪费？&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;是的他是单线程的，但是，我们可以通过在单机开多个&lt;strong&gt;Redis实例&lt;/strong&gt;嘛。&lt;/p&gt;
&lt;h3 id=&quot;h-6&quot;&gt;&lt;span&gt;既然提到了单机会有瓶颈，那你们是怎么解决这个瓶颈的？&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;我们用到了集群的部署方式也就是&lt;strong&gt;Redis cluster&lt;/strong&gt;，并且是主从同步读写分离，类似&lt;strong&gt;Mysql&lt;/strong&gt;的主从同步，&lt;strong&gt;Redis cluster&lt;/strong&gt; 支撑 N 个 &lt;strong&gt;Redis master node&lt;/strong&gt;，每个&lt;strong&gt;master node&lt;/strong&gt;都可以挂载多个 &lt;strong&gt;slave node&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这样整个 &lt;strong&gt;Redis&lt;/strong&gt; 就可以横向扩容了。如果你要支撑更大数据量的缓存，那就横向扩容更多的 &lt;strong&gt;master&lt;/strong&gt; 节点，每个 &lt;strong&gt;master&lt;/strong&gt; 节点就能存放更多的数据了。&lt;/p&gt;
&lt;h3 id=&quot;hredisredis&quot;&gt;&lt;span&gt;哦？那问题就来了，他们之间是怎么进行数据交互的？以及Redis是怎么进行持久化的？Redis数据都在内存中，一断电或者重启不就木有了嘛？&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;是的，持久化的话是&lt;strong&gt;Redis&lt;/strong&gt;高可用中比较重要的一个环节，因为&lt;strong&gt;Redis&lt;/strong&gt;数据在内存的特性，持久化必须得有，我了解到的持久化是有两种方式的。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;RDB：&lt;strong&gt;RDB&lt;/strong&gt; 持久化机制，是对 &lt;strong&gt;Redis&lt;/strong&gt; 中的数据执行&lt;strong&gt;周期性&lt;/strong&gt;的持久化。&lt;/li&gt;
&lt;li&gt;AOF：&lt;strong&gt;AOF&lt;/strong&gt; 机制对每条写入命令作为日志，以 &lt;strong&gt;append-only&lt;/strong&gt; 的模式写入一个日志文件中，因为这个模式是只追加的方式，所以没有任何磁盘寻址的开销，所以很快，有点像Mysql中的&lt;strong&gt;binlog&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;两种方式都可以把&lt;strong&gt;Redis&lt;/strong&gt;内存中的数据持久化到磁盘上，然后再将这些数据备份到别的地方去，&lt;strong&gt;RDB&lt;/strong&gt;更适合做&lt;strong&gt;冷备&lt;/strong&gt;，&lt;strong&gt;AOF&lt;/strong&gt;更适合做&lt;strong&gt;热备&lt;/strong&gt;，比如我杭州的某电商公司有这两个数据，我备份一份到我杭州的节点，再备份一个到上海的，就算发生无法避免的自然灾害，也不会两个地方都一起挂吧，这&lt;strong&gt;灾备&lt;/strong&gt;也就是&lt;strong&gt;异地容灾&lt;/strong&gt;，地球毁灭他没办法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;tip：两种机制全部开启的时候，Redis在重启的时候会默认使用AOF去重新构建数据，因为AOF的数据是比RDB更完整的。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;h-7&quot;&gt;&lt;span&gt;那这两种机制各自优缺点是啥？&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;我先说&lt;strong&gt;RDB&lt;/strong&gt;吧&lt;/p&gt;
&lt;h4 id=&quot;h-8&quot;&gt;&lt;span&gt;优点：&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;他会生成多个数据文件，每个数据文件分别都代表了某一时刻&lt;strong&gt;Redis&lt;/strong&gt;里面的数据，这种方式，有没有觉得很适合做&lt;strong&gt;冷备&lt;/strong&gt;，完整的数据运维设置定时任务，定时同步到远端的服务器，比如阿里的云服务，这样一旦线上挂了，你想恢复多少分钟之前的数据，就去远端拷贝一份之前的数据就好了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;RDB&lt;/strong&gt;对&lt;strong&gt;Redis&lt;/strong&gt;的性能影响非常小，是因为在同步数据的时候他只是&lt;strong&gt;fork&lt;/strong&gt;了一个子进程去做持久化的，而且他在数据恢复的时候速度比&lt;strong&gt;AOF&lt;/strong&gt;来的快。&lt;/p&gt;
&lt;h4 id=&quot;h-9&quot;&gt;&lt;span&gt;缺点：&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;RDB&lt;/strong&gt;都是快照文件，都是默认五分钟甚至更久的时间才会生成一次，这意味着你这次同步到下次同步这中间五分钟的数据都很可能全部丢失掉。&lt;strong&gt;AOF&lt;/strong&gt;则最多丢一秒的数据，&lt;strong&gt;数据完整性&lt;/strong&gt;上高下立判。&lt;/p&gt;
&lt;p&gt;还有就是&lt;strong&gt;RDB&lt;/strong&gt;在生成数据快照的时候，如果文件很大，客户端可能会暂停几毫秒甚至几秒，你公司在做秒杀的时候他刚好在这个时候&lt;strong&gt;fork&lt;/strong&gt;了一个子进程去生成一个大快照，哦豁，出大问题。&lt;/p&gt;
&lt;p&gt;我们再来说说&lt;strong&gt;AOF&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;h-10&quot;&gt;&lt;span&gt;优点：&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;上面提到了，&lt;strong&gt;RDB&lt;/strong&gt;五分钟一次生成快照，但是&lt;strong&gt;AOF&lt;/strong&gt;是一秒一次去通过一个后台的线程&lt;code&gt;fsync&lt;/code&gt;操作，那最多丢这一秒的数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;AOF&lt;/strong&gt;在对日志文件进行操作的时候是以&lt;code&gt;append-only&lt;/code&gt;的方式去写的，他只是追加的方式写数据，自然就少了很多磁盘寻址的开销了，写入性能惊人，文件也不容易破损。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;AOF&lt;/strong&gt;的日志是通过一个叫&lt;strong&gt;非常可读&lt;/strong&gt;的方式记录的，这样的特性就适合做&lt;strong&gt;灾难性数据误删除&lt;/strong&gt;的紧急恢复了，比如公司的实习生通过&lt;strong&gt;flushall&lt;/strong&gt;清空了所有的数据，只要这个时候后台重写还没发生，你马上拷贝一份&lt;strong&gt;AOF&lt;/strong&gt;日志文件，把最后一条&lt;strong&gt;flushall&lt;/strong&gt;命令删了就完事了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;tip：我说的命令你们别真去线上系统操作啊，想试去自己买的服务器上装个Redis试，别到时候来说，敖丙真是个渣男，害我把服务器搞崩了，Redis官网上的命令都去看看，不要乱试！！！&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;h-11&quot;&gt;&lt;span&gt;缺点：&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;一样的数据，&lt;strong&gt;AOF&lt;/strong&gt;文件比&lt;strong&gt;RDB&lt;/strong&gt;还要大。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;AOF&lt;/strong&gt;开启后，&lt;strong&gt;Redis&lt;/strong&gt;支持写的&lt;strong&gt;QPS&lt;/strong&gt;会比&lt;strong&gt;RDB&lt;/strong&gt;支持写的要低，他不是每秒都要去异步刷新一次日志嘛&lt;strong&gt;fsync&lt;/strong&gt;，当然即使这样性能还是很高，我记得&lt;strong&gt;ElasticSearch&lt;/strong&gt;也是这样的，异步刷新缓存区的数据去持久化，为啥这么做呢，不直接来一条怼一条呢，那我会告诉你这样性能可能低到没办法用的，大家可以思考下为啥哟。&lt;/p&gt;
&lt;h3 id=&quot;h-12&quot;&gt;&lt;span&gt;那两者怎么选择？&lt;/span&gt;&lt;/h3&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/006y8mN6ly1g8p9gc6e9pj30go0b4js2.jpg&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;小孩子才做选择，&lt;strong&gt;我全都要&lt;/strong&gt;，你单独用&lt;strong&gt;RDB&lt;/strong&gt;你会丢失很多数据，你单独用&lt;strong&gt;AOF&lt;/strong&gt;，你数据恢复没&lt;strong&gt;RDB&lt;/strong&gt;来的快，真出什么时候第一时间用&lt;strong&gt;RDB&lt;/strong&gt;恢复，然后&lt;strong&gt;AOF&lt;/strong&gt;做数据补全，真香！冷备热备一起上，才是互联网时代一个高健壮性系统的王道。&lt;/p&gt;
&lt;h3 id=&quot;hredis-1&quot;&gt;&lt;span&gt;看不出来年纪轻轻有点东西的呀，对了我听你提到了高可用，Redis还有其他保证集群高可用的方式么？&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;！！！晕 自己给自己埋个坑（其实是明早就准备好了，故意抛出这个词等他问，就怕他不问）。&lt;/p&gt;
&lt;p&gt;假装思考一会（&lt;strong&gt;不要太久，免得以为你真的不会&lt;/strong&gt;），哦我想起来了，还有哨兵集群&lt;strong&gt;sentinel&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;哨兵必须用三个实例去保证自己的健壮性的，哨兵+主从并&lt;strong&gt;不能保证数据不丢失&lt;/strong&gt;，但是可以保证集群的&lt;strong&gt;高可用&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;为啥必须要三个实例呢？我们先看看两个哨兵会咋样。&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/006y8mN6ly1g8p9ghsrztj30930773yg.jpg&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;master宕机了 s1和s2两个哨兵只要有一个认为你宕机了就切换了，并且会选举出一个哨兵去执行故障，但是这个时候也需要大多数哨兵都是运行的。&lt;/p&gt;
&lt;p&gt;那这样有啥问题呢？M1宕机了，S1没挂那其实是OK的，但是整个机器都挂了呢？哨兵就只剩下S2个裸屌了，没有哨兵去允许故障转移了，虽然另外一个机器上还有R1，但是故障转移就是不执行。&lt;/p&gt;
&lt;p&gt;经典的哨兵集群是这样的：&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/006y8mN6ly1g8p9gj3qyaj309309pwei.jpg&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;M1所在的机器挂了，哨兵还有两个，两个人一看他不是挂了嘛，那我们就选举一个出来执行故障转移不就好了。&lt;/p&gt;
&lt;p&gt;暖男我，小的总结下哨兵组件的主要功能：&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;集群监控：负责监控 Redis master 和 slave 进程是否正常工作。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;消息通知：如果某个 &lt;strong&gt;Redis&lt;/strong&gt; 实例有故障，那么哨兵负责发送消息作为报警通知给管理员。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;故障转移：如果 master node 挂掉了，会自动转移到 slave node 上。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;配置中心：如果故障转移发生了，通知 client 客户端新的 master 地址。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;h-13&quot;&gt;&lt;span&gt;我记得你还提到了主从同步，能说一下主从之间的数据怎么同步的么？&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;面试官您的记性可真是一级棒呢，我都要忘了你还记得，我特么谢谢你，提到这个，就跟我前面提到的数据持久化的&lt;strong&gt;RDB&lt;/strong&gt;和&lt;strong&gt;AOF&lt;/strong&gt;有着比密切的关系了。&lt;/p&gt;
&lt;p&gt;我先说下为啥要用主从这样的架构模式，前面提到了单机&lt;strong&gt;QPS&lt;/strong&gt;是有上限的，而且&lt;strong&gt;Redis&lt;/strong&gt;的特性就是必须支撑读高并发的，那你一台机器又读又写，&lt;strong&gt;这谁顶得住啊&lt;/strong&gt;，不当人啊！但是你让这个master机器去写，数据同步给别的slave机器，他们都拿去读，分发掉大量的请求那是不是好很多，而且扩容的时候还可以轻松实现水平扩容。&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/006y8mN6ly1g8p9gedwerj312y0hodhm.jpg&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;&lt;strong&gt;回归正题，他们数据怎么同步的呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;你启动一台slave 的时候，他会发送一个&lt;strong&gt;psync&lt;/strong&gt;命令给master ，如果是这个slave第一次连接到master，他会触发一个全量复制。master就会启动一个线程，生成&lt;strong&gt;RDB&lt;/strong&gt;快照，还会把新的写请求都缓存在内存中，&lt;strong&gt;RDB&lt;/strong&gt;文件生成后，master会将这个&lt;strong&gt;RDB&lt;/strong&gt;发送给slave的，slave拿到之后做的第一件事情就是写进本地的磁盘，然后加载进内存，然后master会把内存里面缓存的那些新命名都发给slave。&lt;/p&gt;
&lt;h3 id=&quot;h-14&quot;&gt;&lt;span&gt;数据传输的时候断网了或者服务器挂了怎么办啊？&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;传输过程中有什么网络问题啥的，会自动重连的，并且连接之后会把缺少的数据补上的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;大家需要记得的就是，RDB快照的数据生成的时候，缓存区也必须同时开始接受新请求，不然你旧的数据过去了，你在同步期间的增量数据咋办？是吧？&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;hlru&quot;&gt;&lt;span&gt;那说了这么多你能说一下他的内存淘汰机制么，来手写一下LRU代码？&lt;/span&gt;&lt;/h3&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/006y8mN6ly1g8p9gjm0cwg308c08cmx3.gif&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;h4 id=&quot;hlruareufkkiddingme&quot;&gt;&lt;span&gt;手写LRU？你是不是想直接跳起来说一句：Are U F**k Kidding me？&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;这个问题是我在蚂蚁金服三面的时候亲身被问过的问题，不知道大家有没有被怼到过这个问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Redis&lt;/strong&gt;的过期策略，是有&lt;strong&gt;定期删除+惰性删除&lt;/strong&gt;两种。&lt;/p&gt;
&lt;p&gt;定期好理解，默认100s就随机抽一些设置了过期时间的key，去检查是否过期，过期了就删了。&lt;/p&gt;
&lt;h3 id=&quot;hkey&quot;&gt;&lt;span&gt;为啥不扫描全部设置了过期时间的key呢？&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;假如Redis里面所有的key都有过期时间，都扫描一遍？那太恐怖了，而且我们线上基本上也都是会设置一定的过期时间的。全扫描跟你去查数据库不带where条件不走索引全表扫描一样，100s一次，Redis累都累死了。&lt;/p&gt;
&lt;h3 id=&quot;hkeykey&quot;&gt;&lt;span&gt;如果一直没随机到很多key，里面不就存在大量的无效key了？&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;好问题，&lt;strong&gt;惰性删除&lt;/strong&gt;，见名知意，惰性嘛，我不主动删，我懒，我等你来查询了我看看你过期没，过期就删了还不给你返回，没过期该怎么样就怎么样。&lt;/p&gt;
&lt;h3 id=&quot;h-15&quot;&gt;&lt;span&gt;最后就是如果的如果，定期没删，我也没查询，那可咋整？&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;内存淘汰机制&lt;/strong&gt;！&lt;/p&gt;
&lt;p&gt;官网上给到的内存淘汰机制是以下几个：&lt;/p&gt;
&lt;ul readability=&quot;8&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;noeviction&lt;/strong&gt;:返回错误当内存限制达到并且客户端尝试执行会让更多内存被使用的命令（大部分的写入指令，但DEL和几个例外）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;allkeys-lru&lt;/strong&gt;: 尝试回收最少使用的键（LRU），使得新添加的数据有空间存放。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;volatile-lru&lt;/strong&gt;: 尝试回收最少使用的键（LRU），但仅限于在过期集合的键,使得新添加的数据有空间存放。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;allkeys-random&lt;/strong&gt;: 回收随机的键使得新添加的数据有空间存放。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;volatile-random&lt;/strong&gt;: 回收随机的键使得新添加的数据有空间存放，但仅限于在过期集合的键。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;volatile-ttl&lt;/strong&gt;: 回收在过期集合的键，并且优先回收存活时间（TTL）较短的键,使得新添加的数据有空间存放。&lt;/p&gt;
&lt;p&gt;如果没有键满足回收的前提条件的话，策略&lt;strong&gt;volatile-lru&lt;/strong&gt;, &lt;strong&gt;volatile-random&lt;/strong&gt;以及&lt;strong&gt;volatile-ttl&lt;/strong&gt;就和noeviction 差不多了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;至于&lt;strong&gt;LRU&lt;/strong&gt;我也简单提一下，手写实在是太长了，大家可以去&lt;strong&gt;Redis官网&lt;/strong&gt;看看，我把&lt;strong&gt;近视LUR&lt;/strong&gt;效果给大家看看&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;tip：Redis为什么不使用真实的LRU实现是因为这需要太多的内存。不过近似的LRU算法对于应用而言应该是等价的。使用真实的LRU算法与近似的算法可以通过下面的图像对比。&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/006y8mN6ly1g8p9gjzdsvj30nq0chmzd.jpg&quot; alt=&quot;LRU comparison&quot; title=&quot;LRU comparison&quot;/&gt;LRU comparison
&lt;p&gt;你可以看到三种点在图片中, 形成了三种带.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;浅灰色带是已经被回收的对象。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;灰色带是没有被回收的对象。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;绿色带是被添加的对象。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;在&lt;strong&gt;LRU&lt;/strong&gt;实现的理论中，我们希望的是，在旧键中的第一半将会过期。&lt;strong&gt;Redis&lt;/strong&gt;的&lt;strong&gt;LRU&lt;/strong&gt;算法则是概率的过期旧的键。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;你可以看到，在都是五个采样的时候Redis 3.0比Redis 2.8要好，Redis2.8中在最后一次访问之间的大多数的对象依然保留着。使用10个采样大小的Redis 3.0的近似值已经非常接近理论的性能。&lt;/p&gt;
&lt;p&gt;注意LRU只是个预测键将如何被访问的模型。另外，如果你的数据访问模式非常接近幂定律，大部分的访问将集中在一个键的集合中，LRU的近似算法将处理得很好。&lt;/p&gt;
&lt;p&gt;其实在大家熟悉的&lt;strong&gt;LinkedHashMap&lt;/strong&gt;中也实现了Lru算法的，实现如下：&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/006y8mN6ly1g8p9gl0t7nj30qw08p3z4.jpg&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;当容量超过100时，开始执行&lt;strong&gt;LRU&lt;/strong&gt;策略：将最近最少未使用的 &lt;strong&gt;TimeoutInfoHolder&lt;/strong&gt; 对象 &lt;strong&gt;evict&lt;/strong&gt; 掉。&lt;/p&gt;
&lt;p&gt;真实面试中会让你写LUR算法，你可别搞原始的那个，那真TM多，写不完的，你要么怼上面这个，要么怼下面这个，找一个数据结构实现下Java版本的LRU还是比较容易的，知道啥原理就好了。&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/006y8mN6ly1g8orgm8oj0j30p10f7wfq.jpg&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;h2 id=&quot;h-16&quot;&gt;&lt;span&gt;面试结束&lt;/span&gt;&lt;/h2&gt;
&lt;h3 id=&quot;hhrbp&quot;&gt;&lt;span&gt;小伙子，你确实有点东西，HRBP会联系你的，请务必保持你的手机畅通好么？&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;好的谢谢面试官，面试官真好，我还想再面几次，噗此。&lt;/p&gt;
&lt;p&gt;能回答得这么全面这么细节还是忍不住点赞&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（暗示点赞，每次都看了不点赞，你们想白嫖我么？你们好坏喲，不过我好喜欢）&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;h-17&quot;&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;好了，我们玩归玩，闹归闹，别拿面试开玩笑，我这么写是为了节目效果，大家面试请认真对待。&lt;/p&gt;
&lt;p&gt;这一期是这期没前面好理解了对吧，我就在自己的服务器上启动了，然后再去官网看看命令一顿瞎操作的，查阅了部分资料，这里给大家推荐几本经典的Redis入门的书籍和我参考的资料。&lt;/p&gt;
&lt;p&gt;不出意外的话这是Redis的倒数第二期，最后一期不知道写啥还没想好，我得好好想想，加上最近不是双十一嘛得加加班，&lt;strong&gt;你看看开头的我，多可怜，那还不点个赞？买个服务器&lt;/strong&gt;？不确定下一期多久出，想早点看到更新的小伙伴可以去公众号&lt;strong&gt;催更&lt;/strong&gt;，公众号提前一到两天更新。&lt;/p&gt;
&lt;h3 id=&quot;hend&quot;&gt;&lt;span&gt;END&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;好了各位，以上就是这篇文章的全部内容了，能看到这里的人呀，都是&lt;strong&gt;人才&lt;/strong&gt;，我后面会每周都更新几篇《&lt;strong&gt;吊打面试官&lt;/strong&gt;》系列和&lt;strong&gt;Java技术栈&lt;/strong&gt;相关的文章。如果你有什么想知道的，也可以&lt;strong&gt;留言&lt;/strong&gt;给我，我一有时间就会写出来，我们共同进步。&lt;/p&gt;
&lt;p&gt;非常感谢&lt;strong&gt;靓仔/靓女&lt;/strong&gt;您能看到这里，如果这个文章写得还不错，觉得敖丙有点东西 &lt;strong&gt;求点赞&lt;/strong&gt; &lt;strong&gt;求关注&lt;/strong&gt; &lt;strong&gt;求分享&lt;/strong&gt; &lt;strong&gt;求留言&lt;/strong&gt; &lt;strong&gt;（对我非常有用）&lt;/strong&gt;各位的支持和认可，就是我创作的最大动力，我们下篇文章见！&lt;/p&gt;
&lt;p&gt;敖丙 | 文 【原创】&lt;/p&gt;
&lt;hr/&gt;&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;每周都会持续更新《吊打面试官》系列可以关注我的公众号 &lt;strong&gt;JavaFamily&lt;/strong&gt; 第一时间阅读和催更，公众号比博客提前一到两天更新，也可以在公众号回复【人才】加入人才交流群，里面都是人才长得好看说话还好听，进去就像回家了一样，就业和工作上有什么问题也可以直接滴滴我，我也是个新人，不过不影响我们一起进步。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Mon, 11 Nov 2019 00:44:00 +0000</pubDate>
<dc:creator>敖丙</dc:creator>
<og:description>你知道的越多，你不知道的越多 点赞再看，养成习惯 前言 Redis在互联网技术存储方面使用如此广泛，几乎所有的后端技术面试官都要在Redis的使用和原理方面对小伙伴们进行360°的刁难。作为一个在互联</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/aobing/p/11832602.html</dc:identifier>
</item>
<item>
<title>小白学 Python（18）：基础文件操作 - 极客挖掘机</title>
<link>http://www.cnblogs.com/babycomeon/p/11832779.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/babycomeon/p/11832779.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201911/908359-20191111084420179-93238876.jpg&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;人生苦短，我选Python&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;前文传送门&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/10/12/2870915863/&quot;&gt;小白学 Python（1）：开篇&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/10/13/2870915864/&quot;&gt;小白学 Python（2）：基础数据类型（上）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/10/15/25090937/&quot;&gt;小白学 Python（3）：基础数据类型（下）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/10/17/2392286754/&quot;&gt;小白学 Python（4）：变量基础操作&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/10/18/999362065/&quot;&gt;小白学 Python（5）：基础运算符（上）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/10/20/2416267271/&quot;&gt;小白学 Python（6）：基础运算符（下）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/10/22/979409150/&quot;&gt;小白学 Python（7）：基础流程控制（上）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/10/23/2184234984/&quot;&gt;小白学 Python（8）：基础流程控制（下）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/10/23/3066758654/&quot;&gt;小白学 Python（9）：基础数据结构（列表）（上）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/10/25/1277177083/&quot;&gt;小白学 Python（10）：基础数据结构（列表）（下）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/10/26/1783681326/&quot;&gt;小白学 Python（11）：基础数据结构（元组）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/10/27/1304658395/&quot;&gt;小白学 Python（12）：基础数据结构（字典）（上）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/10/27/2327215405/&quot;&gt;小白学 Python（13）：基础数据结构（字典）（下）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/10/29/2327215406/&quot;&gt;小白学 Python（14）：基础数据结构（集合）（上）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/10/30/3105860436/&quot;&gt;小白学 Python（15）：基础数据结构（集合）（下）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/10/31/3818474124/&quot;&gt;小白学 Python（16）：基础数据类型（函数）（上）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/11/01/619492986/&quot;&gt;小白学 Python（17）：基础数据类型（函数）（下）&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;绝对路径和相对路径&quot;&gt;绝对路径和相对路径&lt;/h2&gt;
&lt;p&gt;在介绍文件操作之前，我们先介绍两个概念，绝对路径和相对路径。&lt;/p&gt;
&lt;p&gt;先百度下看下百度的解释：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;绝对路径：是指目录下的绝对位置，直接到达目标位置，通常是从盘符开始的路径。完整的描述文件位置的路径就是绝对路径。&lt;/li&gt;
&lt;li&gt;相对路径：相对路径就是指由这个文件所在的路径引起的跟其它文件（或文件夹）的路径关系。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;不知各位同学看懂了没，没看懂我再举个栗子给各位加深下理解。&lt;/p&gt;
&lt;h3 id=&quot;绝对路径&quot;&gt;绝对路径&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201911/908359-20191111084420395-1945260369.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;比如我们要描述 &lt;code&gt;Demo.py&lt;/code&gt; 的绝对路径，那么就是： &lt;code&gt;F:/project/python-learning/base-data-def/Demo.py&lt;/code&gt; 。&lt;/p&gt;
&lt;h3 id=&quot;相对路径&quot;&gt;相对路径&lt;/h3&gt;
&lt;p&gt;相对路径是描述当前位置相对于目标位置的路径，比如当前我们存在的路径是 &lt;code&gt;F:/project/python-learning/&lt;/code&gt; ，我们还是要描述上面的那个 &lt;code&gt;Demo.py&lt;/code&gt; ，那么它的相对路径是 &lt;code&gt;./base-data-def/Demo.py&lt;/code&gt; 。&lt;/p&gt;
&lt;h2 id=&quot;打开文件&quot;&gt;打开文件&lt;/h2&gt;
&lt;p&gt;Python 为我们提供了打开文件的内置函数 &lt;code&gt;open()&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;常用语法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;open(file, mode='r')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;完整语法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参数说明:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;file: 必需，文件路径（相对或者绝对路径）。&lt;/li&gt;
&lt;li&gt;mode: 可选，文件打开模式&lt;/li&gt;
&lt;li&gt;buffering: 设置缓冲&lt;/li&gt;
&lt;li&gt;encoding: 一般使用 utf-8&lt;/li&gt;
&lt;li&gt;errors: 报错级别&lt;/li&gt;
&lt;li&gt;newline: 区分换行符&lt;/li&gt;
&lt;li&gt;closefd: 传入的file参数类型&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;mode 参数常用值：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;21&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;&lt;code&gt;t&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;文本模式 (默认)。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;x&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;写模式，新建一个文件，如果该文件已存在则会报错。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;&lt;code&gt;b&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;二进制模式。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;+&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;打开一个文件进行更新(可读可写)。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;r&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;&lt;code&gt;rb&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。一般用于非文本文件如图片等。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;r+&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;打开一个文件用于读写。文件指针将会放在文件的开头。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;&lt;code&gt;rb+&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。一般用于非文本文件如图片等。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;&lt;code&gt;w&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;&lt;code&gt;wb&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;&lt;code&gt;w+&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;&lt;code&gt;wb+&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;&lt;code&gt;a&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;&lt;code&gt;ab&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;&lt;code&gt;a+&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;&lt;code&gt;ab+&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;光说不练假把式，下面开启我们第一个示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;str1 = open('F:/project/python-learning/base-data-def/Demo.py', mode='r').read()
print(str1)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;打印结果我就不贴出来了，正常打印了我们前几篇文章的示例代码。&lt;/p&gt;
&lt;h2 id=&quot;编码格式&quot;&gt;编码格式&lt;/h2&gt;
&lt;p&gt;根据编码格式的不同，可以将文件分为文本字符和二进制字节。&lt;/p&gt;
&lt;p&gt;我们日常看到的都是文本字符，但是文本字符在保存计算机的时候都会转变成二进制字节，这时候，就要考虑到编码的问题了。&lt;/p&gt;
&lt;p&gt;我们看下转换的示例图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201911/908359-20191111084420541-2092086372.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;值得注意的是，在 Python3 中，文件默认的编码方式是 UTF-8 ，文本字符的常用的编码有 ASCII 和 Unicode 。&lt;/p&gt;
&lt;p&gt;说了这么多，还是看一个示例代码吧：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;str2 = '好好学习，天天向上'
print(type(str2))
a = str2.encode('utf-8')
print(type(a))
print(a.decode('utf-8'))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;打印结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;class 'str'&amp;gt;
&amp;lt;class 'bytes'&amp;gt;
好好学习，天天向上&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，我们将字符串 &lt;code&gt;encode()&lt;/code&gt; 编码以后，类型变成了 &lt;code&gt;byte&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;如果我们使用编码 &lt;code&gt;gbk&lt;/code&gt; 的方式解码上面的 a 会怎么样呢？&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;print(a.decode('gbk'))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Traceback (most recent call last):
  File &quot;F:/project/python-learning/base-file/Demo.py&quot;, line 10, in &amp;lt;module&amp;gt;
    print(a.decode('gbk'))
UnicodeDecodeError: 'gbk' codec can't decode byte 0x8a in position 26: incomplete multibyte sequence&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;告诉我们不能使用 &lt;code&gt;gbk&lt;/code&gt; 来进行解码操作。&lt;/p&gt;
&lt;p&gt;这个其实很好理解，好比我们将中文翻译成为了英文（编码），然后我们通过日文翻译想要将英文翻译回中文（解码），那么这个日文翻译肯定会骂你脑子有病。&lt;/p&gt;
&lt;h2 id=&quot;os-模块&quot;&gt;OS 模块&lt;/h2&gt;
&lt;p&gt;前面我们介绍了通过内置函数来操作文件，我们还可以通过 OS 模块更简单的l哎操作文件。&lt;/p&gt;
&lt;p&gt;OS 模块是和操作系统相关的模块。&lt;/p&gt;
&lt;p&gt;为了演示，先建立一个 &lt;code&gt;test.txt&lt;/code&gt; 文件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201911/908359-20191111084420712-58922857.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先，我们打开这个文件：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import os
os.chdir('F:/project')
file = open('test.txt')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;读取这个文件并打印：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;print(file.read())&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;微信公众号：极客挖掘机&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们在下面再加一些内容：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;file.write('关注公众号，好好学习，天天向上')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后发现执行报错了：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Traceback (most recent call last):
  File &quot;F:/project/python-learning/base-file/Demo.py&quot;, line 17, in &amp;lt;module&amp;gt;
    file.write('关注公众号，好好学习，天天向上')
io.UnsupportedOperation: not writable&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从报错信息可以看出，是我们当前读取权限的问题，因为我们读取时是只读权限，无法写入，所以稍微修改下上面读取文件的代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import os
os.chdir('F:/project')
file = open('test.txt', mode='a+')
file.write(' \n 关注公众号，好好学习，天天向上')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行完成后我们再看下我们的测试文件：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201911/908359-20191111084420855-1619653807.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;写入成功。&lt;/p&gt;
&lt;p&gt;我们测试一个有意思的事情，如果同一个文件我们读取两次会怎么样？&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import os
os.chdir('F:/project')
file = open('test.txt')
print(file.read())
print(file.read())&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;打印结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;微信公众号：极客挖掘机
关注公众号，好好学习，天天向上&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们明明在代码中打印了两次，为什么只显示了一次呢？&lt;/p&gt;
&lt;p&gt;因为 &lt;code&gt;read()&lt;/code&gt; 读取所有内容，读取完后，游标是指在最后的，再往后读取肯定就读不到内容了。&lt;/p&gt;
&lt;p&gt;好了，本篇的内容就到此为止了，希望各位同学能动手练习下示例代码。&lt;/p&gt;
&lt;h2 id=&quot;示例代码&quot;&gt;示例代码&lt;/h2&gt;
&lt;p&gt;本系列的所有代码小编都会放在代码管理仓库 Github 和 Gitee 上，方便大家取用。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/meteor1993/python-learning/tree/master/base-file&quot; title=&quot;示例代码-Github&quot;&gt;示例代码-Github&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gitee.com/inwsy/python-learning/tree/master/base-file&quot; title=&quot;示例代码-Gitee&quot;&gt;示例代码-Gitee&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 11 Nov 2019 00:44:00 +0000</pubDate>
<dc:creator>极客挖掘机</dc:creator>
<og:description>人生苦短，我选Python 前文传送门 '小白学 Python（1）：开篇' '小白学 Python（2）：基础数据类型（上）' '小白学 Python（3）：基础数据类型（下）' '小白学 Pyth</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/babycomeon/p/11832779.html</dc:identifier>
</item>
<item>
<title>如何在 Spring/Spring Boot 中做参数校验？你需要了解的都在这里！ - JavaGuide</title>
<link>http://www.cnblogs.com/javaguide/p/11832752.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/javaguide/p/11832752.html</guid>
<description>&lt;blockquote readability=&quot;7.4732510288066&quot;&gt;
&lt;p&gt;本文为作者原创，如需转载请在文首著名地址，公众号转载请申请开白。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/Snailclimb/springboot-guide&quot;&gt;springboot-guide&lt;/a&gt; : 适合新手入门以及有经验的开发人员查阅的 Spring Boot 教程（业余时间维护中，欢迎一起维护）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;数据的校验的重要性就不用说了，即使在前端对数据进行校验的情况下，我们还是要对传入后端的数据再进行一遍校验，避免用户绕过浏览器直接通过一些 HTTP 工具直接向后端请求一些违法数据。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本文结合自己在项目中的实际使用经验，可以说&lt;strong&gt;文章介绍的内容很实用，不了解的朋友可以学习一下，后面可以立马实践到项目上去。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面我会通过实例程序演示如何在 Java 程序中尤其是 Spring 程序中优雅地的进行参数验证。&lt;/p&gt;
&lt;h2 id=&quot;基础设施搭建&quot;&gt;基础设施搭建&lt;/h2&gt;
&lt;h3 id=&quot;相关依赖&quot;&gt;相关依赖&lt;/h3&gt;
&lt;p&gt;如果开发普通 Java 程序的的话，你需要可能需要像下面这样依赖：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;   &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.hibernate.validator&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;hibernate-validator&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;6.0.9.Final&amp;lt;/version&amp;gt;
   &amp;lt;/dependency&amp;gt;
   &amp;lt;dependency&amp;gt;
             &amp;lt;groupId&amp;gt;javax.el&amp;lt;/groupId&amp;gt;
             &amp;lt;artifactId&amp;gt;javax.el-api&amp;lt;/artifactId&amp;gt;
             &amp;lt;version&amp;gt;3.0.0&amp;lt;/version&amp;gt;
     &amp;lt;/dependency&amp;gt;
     &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.glassfish.web&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;javax.el&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;2.2.6&amp;lt;/version&amp;gt;
     &amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用 Spring Boot 程序的话只需要&lt;code&gt;spring-boot-starter-web&lt;/code&gt; 就够了，它的子依赖包含了我们所需要的东西。除了这个依赖，下面的演示还用到了 lombok ，所以不要忘记添加上相关依赖。&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.projectlombok&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;lombok&amp;lt;/artifactId&amp;gt;
            &amp;lt;optional&amp;gt;true&amp;lt;/optional&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
            &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;实体类&quot;&gt;实体类&lt;/h3&gt;
&lt;p&gt;下面这个是示例用到的实体类。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Data
@AllArgsConstructor
@NoArgsConstructor
public class Person {

    @NotNull(message = &quot;classId 不能为空&quot;)
    private String classId;

    @Size(max = 33)
    @NotNull(message = &quot;name 不能为空&quot;)
    private String name;

    @Pattern(regexp = &quot;((^Man$|^Woman$|^UGM$))&quot;, message = &quot;sex 值不在可选范围&quot;)
    @NotNull(message = &quot;sex 不能为空&quot;)
    private String sex;

    @Email(message = &quot;email 格式不正确&quot;)
    @NotNull(message = &quot;email 不能为空&quot;)
    private String email;

}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;正则表达式说明：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;- ^string : 匹配以 string 开头的字符串
- string$ ：匹配以 string 结尾的字符串
- ^string$ ：精确匹配 string 字符串
- ((^Man$|^Woman$|^UGM$)) : 值只能在 Man,Woman,UGM 这三个值中选择&lt;/code&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt;下面这部分校验注解说明内容参考自：https://www.cnkirito.moe/spring-validation/ ，感谢@&lt;a href=&quot;https://github.com/lexburner&quot;&gt;徐靖峰&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;JSR提供的校验注解&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;@Null&lt;/code&gt; 被注释的元素必须为 null&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@NotNull&lt;/code&gt; 被注释的元素必须不为 null&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@AssertTrue&lt;/code&gt; 被注释的元素必须为 true&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@AssertFalse&lt;/code&gt; 被注释的元素必须为 false&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Min(value)&lt;/code&gt; 被注释的元素必须是一个数字，其值必须大于等于指定的最小值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Max(value)&lt;/code&gt; 被注释的元素必须是一个数字，其值必须小于等于指定的最大值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@DecimalMin(value)&lt;/code&gt; 被注释的元素必须是一个数字，其值必须大于等于指定的最小值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@DecimalMax(value)&lt;/code&gt; 被注释的元素必须是一个数字，其值必须小于等于指定的最大值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Size(max=, min=)&lt;/code&gt; 被注释的元素的大小必须在指定的范围内&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Digits (integer, fraction)&lt;/code&gt; 被注释的元素必须是一个数字，其值必须在可接受的范围内&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Past&lt;/code&gt; 被注释的元素必须是一个过去的日期&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Future&lt;/code&gt; 被注释的元素必须是一个将来的日期&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Pattern(regex=,flag=)&lt;/code&gt; 被注释的元素必须符合指定的正则表达式&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Hibernate Validator提供的校验注解&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;@NotBlank(message =)&lt;/code&gt; 验证字符串非null，且长度必须大于0&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Email&lt;/code&gt; 被注释的元素必须是电子邮箱地址&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Length(min=,max=)&lt;/code&gt; 被注释的字符串的大小必须在指定的范围内&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@NotEmpty&lt;/code&gt; 被注释的字符串的必须非空&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Range(min=,max=,message=)&lt;/code&gt; 被注释的元素必须在合适的范围内&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;验证controller的输入&quot;&gt;验证Controller的输入&lt;/h2&gt;
&lt;h3 id=&quot;验证请求体requestbody&quot;&gt;验证请求体(RequestBody)&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Controller：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们在需要验证的参数上加上了&lt;code&gt;@Valid&lt;/code&gt;注解，如果验证失败，它将抛出&lt;code&gt;MethodArgumentNotValidException&lt;/code&gt;。默认情况下，Spring会将此异常转换为HTTP Status 400（错误请求）。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
@RestController
@RequestMapping(&quot;/api&quot;)
public class PersonController {

    @PostMapping(&quot;/person&quot;)
    public ResponseEntity&amp;lt;Person&amp;gt; getPerson(@RequestBody @Valid Person person) {
        return ResponseEntity.ok().body(person);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;ExceptionHandler：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;自定义异常处理器可以帮助我们捕获异常，并进行一些简单的处理。如果对于下面的处理异常的代码不太理解的话，可以查看这篇文章 &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;amp;mid=2247485568&amp;amp;idx=2&amp;amp;sn=c5ba880fd0c5d82e39531fa42cb036ac&amp;amp;chksm=cea2474bf9d5ce5dcbc6a5f6580198fdce4bc92ef577579183a729cb5d1430e4994720d59b34&amp;amp;token=1924773784&amp;amp;lang=zh_CN#rd&quot;&gt;《SpringBoot 处理异常的几种常见姿势》&lt;/a&gt;。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@ControllerAdvice(assignableTypes = {PersonController.class})
public class GlobalExceptionHandler {
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity&amp;lt;Map&amp;lt;String, String&amp;gt;&amp;gt; handleValidationExceptions(
            MethodArgumentNotValidException ex) {
        Map&amp;lt;String, String&amp;gt; errors = new HashMap&amp;lt;&amp;gt;();
        ex.getBindingResult().getAllErrors().forEach((error) -&amp;gt; {
            String fieldName = ((FieldError) error).getField();
            String errorMessage = error.getDefaultMessage();
            errors.put(fieldName, errorMessage);
        });
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(errors);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;通过测试验证：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面我通过 MockMvc 模拟请求 Controller 的方式来验证是否生效，当然你也可以通过 Postman 这种工具来验证。&lt;/p&gt;
&lt;p&gt;我们试一下所有参数输入正确的情况。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@RunWith(SpringRunner.class)
@SpringBootTest
@AutoConfigureMockMvc
public class PersonControllerTest {
    @Autowired
    private MockMvc mockMvc;

    @Autowired
    private ObjectMapper objectMapper;

    @Test
    public void should_get_person_correctly() throws Exception {
        Person person = new Person();
        person.setName(&quot;SnailClimb&quot;);
        person.setSex(&quot;Man&quot;);
        person.setClassId(&quot;82938390&quot;);
        person.setEmail(&quot;Snailclimb@qq.com&quot;);

        mockMvc.perform(post(&quot;/api/person&quot;)
                .contentType(MediaType.APPLICATION_JSON_UTF8)
                .content(objectMapper.writeValueAsString(person)))
                .andExpect(MockMvcResultMatchers.jsonPath(&quot;name&quot;).value(&quot;SnailClimb&quot;))
                .andExpect(MockMvcResultMatchers.jsonPath(&quot;classId&quot;).value(&quot;82938390&quot;))
                .andExpect(MockMvcResultMatchers.jsonPath(&quot;sex&quot;).value(&quot;Man&quot;))
                .andExpect(MockMvcResultMatchers.jsonPath(&quot;email&quot;).value(&quot;Snailclimb@qq.com&quot;));
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;验证出现参数不合法的情况抛出异常并且可以正确被捕获。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt; @Test
    public void should_check_person_value() throws Exception {
        Person person = new Person();
        person.setSex(&quot;Man22&quot;);
        person.setClassId(&quot;82938390&quot;);
        person.setEmail(&quot;SnailClimb&quot;);

        mockMvc.perform(post(&quot;/api/person&quot;)
                .contentType(MediaType.APPLICATION_JSON_UTF8)
                .content(objectMapper.writeValueAsString(person)))
                .andExpect(MockMvcResultMatchers.jsonPath(&quot;sex&quot;).value(&quot;sex 值不在可选范围&quot;))
                .andExpect(MockMvcResultMatchers.jsonPath(&quot;name&quot;).value(&quot;name 不能为空&quot;))
                .andExpect(MockMvcResultMatchers.jsonPath(&quot;email&quot;).value(&quot;email 格式不正确&quot;));
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用 Postman 验证结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1843652/201911/1843652-20191111083137288-2081122723.png&quot; alt=&quot;Postman 验证结果&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;验证请求参数path-variables-和-request-parameters&quot;&gt;验证请求参数(Path Variables 和 Request Parameters)&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Controller：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一定一定不要忘记在类上加上 &lt;code&gt;Validated&lt;/code&gt; 注解了，这个参数可以告诉 Spring 去校验方法参数。&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@RestController
@RequestMapping(&quot;/api&quot;)
@Validated
public class PersonController {

    @GetMapping(&quot;/person/{id}&quot;)
    public ResponseEntity&amp;lt;Integer&amp;gt; getPersonByID(@Valid @PathVariable(&quot;id&quot;) @Max(value = 5,message = &quot;超过 id 的范围了&quot;) Integer id) {
        return ResponseEntity.ok().body(id);
    }

    @PutMapping(&quot;/person&quot;)
    public ResponseEntity&amp;lt;String&amp;gt; getPersonByName(@Valid @RequestParam(&quot;name&quot;) @Size(max = 6,message = &quot;超过 name 的范围了&quot;) String name) {
        return ResponseEntity.ok().body(name);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;ExceptionHandler：&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    @ExceptionHandler(ConstraintViolationException.class)
    ResponseEntity&amp;lt;String&amp;gt; handleConstraintViolationException(ConstraintViolationException e) {
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(e.getMessage());
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;通过测试验证：&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;  @Test
    public void should_check_param_value() throws Exception {

        mockMvc.perform(get(&quot;/api/person/6&quot;)
                .contentType(MediaType.APPLICATION_JSON_UTF8))
                .andExpect(status().isBadRequest())
                .andExpect(content().string(&quot;getPersonByID.id: 超过 id 的范围了&quot;));
    }

    @Test
    public void should_check_param_value2() throws Exception {

        mockMvc.perform(put(&quot;/api/person&quot;)
                .param(&quot;name&quot;,&quot;snailclimbsnailclimb&quot;)
                .contentType(MediaType.APPLICATION_JSON_UTF8))
                .andExpect(status().isBadRequest())
                .andExpect(content().string(&quot;getPersonByName.name: 超过 name 的范围了&quot;));
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;验证-service-中的方法&quot;&gt;验证 Service 中的方法&lt;/h2&gt;
&lt;p&gt;我们还可以验证任何Spring组件的输入，而不是验证控制器级别的输入，我们可以使用&lt;code&gt;@Validated&lt;/code&gt;和&lt;code&gt;@Valid&lt;/code&gt;注释的组合来实现这一需求。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一定一定不要忘记在类上加上 &lt;code&gt;Validated&lt;/code&gt; 注解了，这个参数可以告诉 Spring 去校验方法参数。&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Service
@Validated
public class PersonService {

    public void validatePerson(@Valid Person person){
        // do something
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;通过测试验证：&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@RunWith(SpringRunner.class)
@SpringBootTest
@AutoConfigureMockMvc
public class PersonServiceTest {
    @Autowired
    private PersonService service;

    @Test(expected = ConstraintViolationException.class)
    public void should_throw_exception_when_person_is_not_valid() {
        Person person = new Person();
        person.setSex(&quot;Man22&quot;);
        person.setClassId(&quot;82938390&quot;);
        person.setEmail(&quot;SnailClimb&quot;);
        service.validatePerson(person);
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;validator-编程方式手动进行参数验证&quot;&gt;Validator 编程方式手动进行参数验证&lt;/h2&gt;
&lt;p&gt;某些场景下可能会需要我们手动校验并获得校验结果。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    @Test
    public void check_person_manually() {

        ValidatorFactory factory = Validation.buildDefaultValidatorFactory();
        Validator validator = factory.getValidator();
        Person person = new Person();
        person.setSex(&quot;Man22&quot;);
        person.setClassId(&quot;82938390&quot;);
        person.setEmail(&quot;SnailClimb&quot;);
        Set&amp;lt;ConstraintViolation&amp;lt;Person&amp;gt;&amp;gt; violations = validator.validate(person);
        //output:
        //email 格式不正确
        //name 不能为空
        //sex 值不在可选范围
        for (ConstraintViolation&amp;lt;Person&amp;gt; constraintViolation : violations) {
            System.out.println(constraintViolation.getMessage());
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面我们是通过 &lt;code&gt;Validator&lt;/code&gt; 工厂类获得的 &lt;code&gt;Validator&lt;/code&gt; 示例，当然你也可以通过 &lt;code&gt;@Autowired&lt;/code&gt; 直接注入的方式。但是在非 Spring Component 类中使用这种方式的话，只能通过工厂类来获得 &lt;code&gt;Validator&lt;/code&gt;。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Autowired
Validator validate&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;自定以-validator实用&quot;&gt;自定以 Validator(实用)&lt;/h2&gt;
&lt;p&gt;如果自带的校验注解无法满足你的需求的话，你还可以自定义实现注解。&lt;/p&gt;
&lt;h3 id=&quot;案例一校验特定字段的值是否在可选范围&quot;&gt;案例一:校验特定字段的值是否在可选范围&lt;/h3&gt;
&lt;p&gt;比如我们现在多了这样一个需求：Person类多了一个 region 字段，region 字段只能是&lt;code&gt;China&lt;/code&gt;、&lt;code&gt;China-Taiwan&lt;/code&gt;、&lt;code&gt;China-HongKong&lt;/code&gt;这三个中的一个。&lt;/p&gt;
&lt;p&gt;第一步你需要创建一个注解：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Target({FIELD})
@Retention(RUNTIME)
@Constraint(validatedBy = RegionValidator.class)
@Documented
public @interface Region {

    String message() default &quot;Region 值不在可选范围内&quot;;

    Class&amp;lt;?&amp;gt;[] groups() default {};

    Class&amp;lt;? extends Payload&amp;gt;[] payload() default {};
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第二步你需要实现 &lt;code&gt;ConstraintValidator&lt;/code&gt;接口，并重写&lt;code&gt;isValid&lt;/code&gt; 方法：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import javax.validation.ConstraintValidator;
import javax.validation.ConstraintValidatorContext;
import java.util.HashSet;

public class RegionValidator implements ConstraintValidator&amp;lt;Region, String&amp;gt; {

    @Override
    public boolean isValid(String value, ConstraintValidatorContext context) {
        HashSet&amp;lt;Object&amp;gt; regions = new HashSet&amp;lt;&amp;gt;();
        regions.add(&quot;China&quot;);
        regions.add(&quot;China-Taiwan&quot;);
        regions.add(&quot;China-HongKong&quot;);
        return regions.contains(value);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在你就可以使用这个注解：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    @Region
    private String region;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;案例二校验电话号码&quot;&gt;案例二:校验电话号码&lt;/h3&gt;
&lt;p&gt;校验我们的电话号码是否合法，这个可以通过正则表达式来做，相关的正则表达式都可以在网上搜到，你甚至可以搜索到针对特定运营商电话号码段的正则表达式。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;PhoneNumber.java&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import javax.validation.Constraint;
import java.lang.annotation.Documented;
import java.lang.annotation.Retention;
import java.lang.annotation.Target;

import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.PARAMETER;
import static java.lang.annotation.RetentionPolicy.RUNTIME;

@Documented
@Constraint(validatedBy = PhoneNumberValidator.class)
@Target({FIELD, PARAMETER})
@Retention(RUNTIME)
public @interface PhoneNumber {
    String message() default &quot;Invalid phone number&quot;;
    Class[] groups() default {};
    Class[] payload() default {};
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;PhoneNumberValidator.java&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import javax.validation.ConstraintValidator;
import javax.validation.ConstraintValidatorContext;

public class PhoneNumberValidator implements ConstraintValidator&amp;lt;PhoneNumber,String&amp;gt; {

    @Override
    public boolean isValid(String phoneField, ConstraintValidatorContext context) {
        if (phoneField == null) {
            // can be null
            return true;
        }
        return phoneField.matches(&quot;^1(3[0-9]|4[57]|5[0-35-9]|8[0-9]|70)\\d{8}$&quot;) &amp;amp;&amp;amp; phoneField.length() &amp;gt; 8 &amp;amp;&amp;amp; phoneField.length() &amp;lt; 14;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;搞定，我们现在就可以使用这个注解了。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@PhoneNumber(message = &quot;phoneNumber 格式不正确&quot;)
@NotNull(message = &quot;phoneNumber 不能为空&quot;)
private String phoneNumber;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;使用验证组&quot;&gt;使用验证组&lt;/h2&gt;
&lt;p&gt;某些场景下我们需要使用到验证组，这样说可能不太清楚，说简单点就是对对象操作的不同方法有不同的验证规则，示例如下（这个就我目前经历的项目来说使用的比较少，因为本身这个在代码层面理解起来是比较麻烦的，然后写起来也比较麻烦）。&lt;/p&gt;
&lt;p&gt;先创建两个接口：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface AddPersonGroup {
}
public interface DeletePersonGroup {
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以这样去使用验证组&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@NotNull(groups = DeletePersonGroup.class)
@Null(groups = AddPersonGroup.class)
private String group;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Service
@Validated
public class PersonService {

    public void validatePerson(@Valid Person person) {
        // do something
    }

    @Validated(AddPersonGroup.class)
    public void validatePersonGroupForAdd(@Valid Person person) {
        // do something
    }

    @Validated(DeletePersonGroup.class)
    public void validatePersonGroupForDelete(@Valid Person person) {
        // do something
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过测试验证：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;  @Test(expected = ConstraintViolationException.class)
    public void should_check_person_with_groups() {
        Person person = new Person();
        person.setSex(&quot;Man22&quot;);
        person.setClassId(&quot;82938390&quot;);
        person.setEmail(&quot;SnailClimb&quot;);
        person.setGroup(&quot;group1&quot;);
        service.validatePersonGroupForAdd(person);
    }

    @Test(expected = ConstraintViolationException.class)
    public void should_check_person_with_groups2() {
        Person person = new Person();
        person.setSex(&quot;Man22&quot;);
        person.setClassId(&quot;82938390&quot;);
        person.setEmail(&quot;SnailClimb&quot;);
        service.validatePersonGroupForDelete(person);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用验证组这种方式的时候一定要小心，这是一种反模式，还会造成代码逻辑性变差。&lt;/p&gt;
&lt;p&gt;代码地址：https://github.com/Snailclimb/springboot-guide/tree/master/source-code/advanced/bean-validation-demo&lt;/p&gt;
&lt;h2 id=&quot;notnull-vs-columnnullable-false重要&quot;&gt;&lt;code&gt;@NotNull&lt;/code&gt; vs &lt;code&gt;@Column(nullable = false)&lt;/code&gt;(重要)&lt;/h2&gt;
&lt;p&gt;在使用 JPA 操作数据的时候会经常碰到 &lt;code&gt;@Column(nullable = false)&lt;/code&gt; 这种类型的约束，那么它和 &lt;code&gt;@NotNull&lt;/code&gt; 有何区别呢？搞清楚这个还是很重要的！&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;@NotNull&lt;/code&gt;是 JSR 303 Bean验证批注,它与数据库约束本身无关。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Column(nullable = false)&lt;/code&gt; : 是JPA声明列为非空的方法。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;总结来说就是即前者用于验证，而后者则用于指示数据库创建表的时候对表的约束。&lt;/p&gt;
&lt;h2 id=&quot;todo&quot;&gt;TODO&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;[ ] 原理分析&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;https://reflectoring.io/bean-validation-with-spring-boot/&lt;/li&gt;
&lt;li&gt;https://www.cnkirito.moe/spring-validation//&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;开源项目推荐&quot;&gt;开源项目推荐&lt;/h3&gt;
&lt;p&gt;作者的其他开源项目推荐：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/Snailclimb/JavaGuide&quot;&gt;JavaGuide&lt;/a&gt;：【Java学习+面试指南】 一份涵盖大部分Java程序员所需要掌握的核心知识。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/Snailclimb/springboot-guide&quot;&gt;springboot-guide&lt;/a&gt; : 适合新手入门以及有经验的开发人员查阅的 Spring Boot 教程（业余时间维护中，欢迎一起维护）。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/Snailclimb/programmer-advancement&quot;&gt;programmer-advancement&lt;/a&gt; : 我觉得技术人员应该有的一些好习惯！&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/Snailclimb/spring-security-jwt-guide&quot;&gt;spring-security-jwt-guide&lt;/a&gt; :从零入门 ！Spring Security With JWT（含权限验证）后端部分代码。&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Mon, 11 Nov 2019 00:32:00 +0000</pubDate>
<dc:creator>JavaGuide</dc:creator>
<og:description>本文为作者原创，如需转载请在文首著名地址，公众号转载请申请开白。 'springboot guide' : 适合新手入门以及有经验的开发人员查阅的 Spring Boot 教程（业余时间维护中，欢迎一</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/javaguide/p/11832752.html</dc:identifier>
</item>
<item>
<title>详解SpringBoot应用跨域访问解决方案 - 字母哥博客</title>
<link>http://www.cnblogs.com/zimug/p/11832737.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zimug/p/11832737.html</guid>
<description>&lt;h2 id=&quot;一什么是跨域访问&quot;&gt;一、什么是跨域访问&lt;/h2&gt;
&lt;p&gt;说到跨域访问，必须先解释一个名词：同源策略。所谓同源策略就是在浏览器端出于安全考量，向服务端发起请求必须满足：协议相同、Host(ip)相同、端口相同的条件，否则访问将被禁止，该访问也就被称为跨域访问。&lt;br/&gt;虽然跨域访问被禁止之后，可以在一定程度上提高了应用的安全性，但也为开发带来了一定的麻烦。比如：我们开发一个前后端分离的易用，页面及js部署在一个主机的nginx服务中，后端接口部署在一个tomcat应用容器中，当前端向后端发起请求的时候一定是不符合同源策略的，也就无法访问。那么我们如何解决这个问题？就是本文需要向大家说明的内容。&lt;/p&gt;
&lt;h2 id=&quot;二跨域访问的解决方案有哪些&quot;&gt;二、跨域访问的解决方案有哪些？&lt;/h2&gt;
&lt;h3 id=&quot;第一类方案前端解决方案&quot;&gt;2.1.第一类方案：前端解决方案&lt;/h3&gt;
&lt;p&gt;虽然浏览器对于不符合同源策略的访问是禁止的，但是仍然存在例外的情况，如以下资源引用的标签不受同源策略的限制：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;html的script标签&lt;/li&gt;
&lt;li&gt;html的link标签&lt;/li&gt;
&lt;li&gt;html的img标签&lt;/li&gt;
&lt;li&gt;html的iframe标签：对于使用jsp、freemarker开发的项目，这是实现跨域访问最常见的方法，&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;除了基于HTML本身的特性实现跨域访问，我们还可以使用jsonp、window的postMessage实现跨域访问。这些都是前端实现跨域访问的方式。&lt;/p&gt;
&lt;h3 id=&quot;第二类方案使用代理&quot;&gt;2.2.第二类方案：使用代理&lt;/h3&gt;
&lt;p&gt;实际上对跨域访问的支持在服务端实现起来更加容易，最常用的方法就是通过代理的方式，如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;nginx或haproxy代理跨域&lt;/li&gt;
&lt;li&gt;nodejs中间件代理跨域&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其实实现代理跨域的逻辑非常简单：就是在不同的资源服务：js资源、html资源、css资源、接口数据资源服务的前端搭建一个中间层，所有的浏览器及客户端访问都通过代理转发。所以在浏览器、客户端看来，它们访问的都是同一个ip、同一个端口的资源，从而符合同源策略实现跨域访问。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1815316/201911/1815316-20191111082300677-447204491.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;第三类方案cors&quot;&gt;2.3 第三类方案：CORS&lt;/h3&gt;
&lt;p&gt;跨域资源共享（CORS）：通过修改Http协议header的方式，实现跨域。说的简单点就是，通过设置HTTP的响应头信息，告知浏览器哪些情况在不符合同源策略的条件下也可以跨域访问，浏览器通过解析Http协议中的Header执行具体判断。具体的Header如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CROS跨域常用header&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Access-Control-Allow-Origin: 允许哪些ip或域名可以跨域访问&lt;/li&gt;
&lt;li&gt;Access-Control-Max-Age: 表示在多少秒之内不需要重复校验该请求的跨域访问权限&lt;/li&gt;
&lt;li&gt;Access-Control-Allow-Methods: 表示允许跨域请求的HTTP方法，如：GET,POST,PUT,DELETE&lt;/li&gt;
&lt;li&gt;Access-Control-Allow-Headers: 表示访问请求中允许携带哪些Header信息，如：&lt;code&gt;Accept&lt;/code&gt;、&lt;code&gt;Accept-Language&lt;/code&gt;、&lt;code&gt;Content-Language&lt;/code&gt;、&lt;code&gt;Content-Type&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;三springboot下实现cors的四种方式&quot;&gt;三、SpringBoot下实现CORS的四种方式&lt;/h2&gt;
&lt;p&gt;为大家介绍四种实现CORS的方法，两种是全局配置，两种是局部接口生效的配置。一般来说，SpringBoot项目采用其中一种方式实现CORS即可。&lt;/p&gt;
&lt;h3 id=&quot;使用corsfilter进行全局跨域配置&quot;&gt;3.1.使用CorsFilter进行全局跨域配置&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;    @Configuration
    public class GlobalCorsConfig {
        @Bean
        public CorsFilter corsFilter() {
    
            CorsConfiguration config = new CorsConfiguration();
            //开放哪些ip、端口、域名的访问权限，星号表示开放所有域
            config.addAllowedOrigin(&quot;*&quot;);
            //是否允许发送Cookie信息
            config.setAllowCredentials(true);
            //开放哪些Http方法，允许跨域访问
            config.addAllowedMethod(&quot;GET&quot;,&quot;POST&quot;, &quot;PUT&quot;, &quot;DELETE&quot;);
            //允许HTTP请求中的携带哪些Header信息
            config.addAllowedHeader(&quot;*&quot;);
            //暴露哪些头部信息（因为跨域访问默认不能获取全部头部信息）
            config.addExposedHeader(&quot;*&quot;);
    
            //添加映射路径，“/**”表示对所有的路径实行全局跨域访问权限的设置
            UrlBasedCorsConfigurationSource configSource = new UrlBasedCorsConfigurationSource();
            configSource.registerCorsConfiguration(&quot;/**&quot;, config);
    
            return new CorsFilter(configSource);
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;重写webmvcconfigurer的addcorsmappings方法全局跨域配置&quot;&gt;3.2. 重写WebMvcConfigurer的addCorsMappings方法（全局跨域配置）&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;    @Configuration
    public class GlobalCorsConfig {
        @Bean
        public WebMvcConfigurer corsConfigurer() {
            return new WebMvcConfigurer() {
                @Override
                public void addCorsMappings(CorsRegistry registry) {
                    registry.addMapping(&quot;/**&quot;)    //添加映射路径，“/**”表示对所有的路径实行全局跨域访问权限的设置
                            .allowedOrigins(&quot;*&quot;)    //开放哪些ip、端口、域名的访问权限
                            .allowCredentials(true)  //是否允许发送Cookie信息 
                            .allowedMethods(&quot;GET&quot;,&quot;POST&quot;, &quot;PUT&quot;, &quot;DELETE&quot;)     //开放哪些Http方法，允许跨域访问
                            .allowedHeaders(&quot;*&quot;)     //允许HTTP请求中的携带哪些Header信息
                            .exposedHeaders(&quot;*&quot;);   //暴露哪些头部信息（因为跨域访问默认不能获取全部头部信息）
                }
            };
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;使用crossorigin注解局部跨域配置&quot;&gt;3.3.使用CrossOrigin注解（局部跨域配置）&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;将CrossOrigin注解加在Controller层的方法上，该方法定义的RequestMapping端点将支持跨域访问&lt;/li&gt;
&lt;li&gt;将CrossOrigin注解加在Controller层的类定义处，整个类所有的方法对应的RequestMapping端点都将支持跨域访问&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;    @RequestMapping(&quot;/cors&quot;)
    @ResponseBody
    @CrossOrigin(origins = &quot;http://localhost:8080&quot;, maxAge = 3600) 
    public String cors( ){
        return &quot;cors&quot;;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;使用httpservletresponse设置响应头局部跨域配置&quot;&gt;3.4 使用HttpServletResponse设置响应头(局部跨域配置)&lt;/h3&gt;
&lt;p&gt;这种方式略显麻烦，不建议在SpringBoot项目中使用。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    @RequestMapping(&quot;/cors&quot;)
    @ResponseBody
    public String cors(HttpServletResponse response){
        //使用HttpServletResponse定义HTTP请求头，最原始的方法也是最通用的方法
        response.addHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;http://localhost:8080&quot;);
        return &quot;cors&quot;;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;四实现与测试&quot;&gt;四、实现与测试&lt;/h2&gt;
&lt;p&gt;在SpringBoot&lt;strong&gt;项目外&lt;/strong&gt;随便定义一个HTML，并写代码触发如下的ajax代码。（触发过程我就不写了，定义一个按钮加一个监听函数即可）。以下是跨域AJAX请求验证的核心代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    $.ajax({
            url: 'http://localhost:8090/cors',
            type: &quot;POST&quot;,
            xhrFields: {
               withCredentials: true    //允许发送Cookie信息
            },
            success: function (data) {
                alert(&quot;跨域请求配置成功&quot;)
            },
            error: function (data) {
                alert(&quot;跨域请求配置失败&quot;)
            }
        })&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;跨域请求配置成功表示：我们的跨域配置生效，ajax请求可以正确访问服务端接口。&lt;/li&gt;
&lt;li&gt;跨域请求配置失败表示：我们的跨域配置未生效，请参照检查第三节检查各项配置是否正确。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;期待您的关注&quot;&gt;期待您的关注&lt;/h2&gt;
</description>
<pubDate>Mon, 11 Nov 2019 00:23:00 +0000</pubDate>
<dc:creator>字母哥博客</dc:creator>
<og:description>一、什么是跨域访问 说到跨域访问，必须先解释一个名词：同源策略。所谓同源策略就是在浏览器端出于安全考量，向服务端发起请求必须满足：协议相同、Host(ip)相同、端口相同的条件，否则访问将被禁止，该访</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zimug/p/11832737.html</dc:identifier>
</item>
<item>
<title>深度解密Go语言之 pprof - Stefno</title>
<link>http://www.cnblogs.com/qcrao-2018/p/11832732.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qcrao-2018/p/11832732.html</guid>
<description>&lt;p&gt;相信很多人都听过“雷神 3”关于性能优化的故事。在一个 3D 游戏引擎的源码里，John Carmack 将 &lt;code&gt;1/sqrt(x)&lt;/code&gt; 这个函数的执行效率优化到了极致。&lt;/p&gt;
&lt;p&gt;一般我们使用二分法，或者牛顿迭代法计算一个浮点数的平方根。但在这个函数里，作者使用了一个“魔数”，根本没有迭代，两步就直接算出了平方根。令人叹为观止！&lt;/p&gt;
&lt;p&gt;因为它是最底层的函数，而游戏里涉及到大量的这种运算，使得在运算资源极其紧张的 DOS 时代，游戏也可以流畅地运行。这就是性能优化的魅力！&lt;/p&gt;
&lt;p&gt;工作中，当业务量比较小的时候，用的机器也少，体会不到性能优化带来的收益。而当一个业务使用了几千台机器的时候，性能优化 20%，那就能省下几百台机器，一年能省几百万。省下来的这些钱，给员工发年终奖，那得多 Happy！&lt;/p&gt;
&lt;p&gt;一般而言，性能分析可以从三个层次来考虑：应用层、系统层、代码层。&lt;/p&gt;
&lt;p&gt;应用层主要是梳理业务方的使用方式，让他们更合理地使用，在满足使用方需求的前提下，减少无意义的调用；系统层关注服务的架构，例如增加一层缓存；代码层则关心函数的执行效率，例如使用效率更高的开方算法等。&lt;/p&gt;
&lt;p&gt;做任何事，都要讲究方法。在很多情况下，迅速把事情最关键的部分完成，就能拿到绝大部分的收益了。其他的一些边边角角，可以慢慢地缝合。一上来就想完成 100%，往往会陷入付出了巨大的努力，却收获寥寥的境地。&lt;/p&gt;
&lt;p&gt;性能优化这件事也一样，识别出性能瓶颈，会让我们付出最小的努力，而得到最大的回报。&lt;/p&gt;
&lt;p&gt;Go 语言里，pprof 就是这样一个工具，帮助我们快速找到性能瓶颈，进而进行有针对性地优化。&lt;/p&gt;

&lt;p&gt;代码上线前，我们通过压测可以获知系统的性能，例如每秒能处理的请求数，平均响应时间，错误率等指标。这样，我们对自己服务的性能算是有个底。&lt;/p&gt;
&lt;p&gt;但是压测是线下的模拟流量，如果到了线上呢？会遇到高并发、大流量，不靠谱的上下游，突发的尖峰流量等等场景，这些都是不可预知的。&lt;/p&gt;
&lt;p&gt;线上突然大量报警，接口超时，错误数增加，除了看日志、监控，就是用性能分析工具分析程序的性能，找到瓶颈。当然，一般这种情形不会让你有机会去分析，降级、限流、回滚才是首先要做的，要先止损嘛。回归正常之后，通过线上流量回放，或者压测等手段，制造性能问题，再通过工具来分析系统的瓶颈。&lt;/p&gt;
&lt;p&gt;一般而言，性能分析主要关注 CPU、内存、磁盘 IO、网络这些指标。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Profiling&lt;/code&gt; 是指在程序执行过程中，收集能够反映程序执行状态的数据。在软件工程中，性能分析（performance analysis，也称为 profiling），是以收集程序运行时信息为手段研究程序行为的分析方法，是一种动态程序分析的方法。&lt;/p&gt;
&lt;p&gt;Go 语言自带的 pprof 库就可以分析程序的运行情况，并且提供可视化的功能。它包含两个相关的库：&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;runtime/pprof&lt;br/&gt;对于只跑一次的程序，例如每天只跑一次的离线预处理程序，调用 pprof 包提供的函数，手动开启性能数据采集。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;net/http/pprof&lt;br/&gt;对于在线服务，对于一个 HTTP Server，访问 pprof 提供的 HTTP 接口，获得性能数据。当然，实际上这里底层也是调用的 runtime/pprof 提供的函数，封装成接口对外提供网络访问。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;pprof&lt;/code&gt; 是 Go 语言中分析程序运行性能的工具，它能提供各种性能数据：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/7698088/68523507-3ce36500-02f5-11ea-8e8f-438c9ef2b9f8.png&quot; alt=&quot;pprof 采集的信息类型&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;allocs&lt;/code&gt; 和 &lt;code&gt;heap&lt;/code&gt; 采样的信息一致，不过前者是所有对象的内存分配，而 heap 则是活跃对象的内存分配。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;The difference between the two is the way the pprof tool reads there at start time. Allocs profile will start pprof in a mode which displays the total number of bytes allocated since the program began (including garbage-collected bytes).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上图来自参考资料【wolfogre】的一篇 pprof 实战的文章，提供了一个样例程序，通过 pprof 来排查、分析、解决性能问题，非常精彩。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;当 CPU 性能分析启用后，Go runtime 会每 10ms 就暂停一下，记录当前运行的 goroutine 的调用堆栈及相关数据。当性能分析数据保存到硬盘后，我们就可以分析代码中的热点了。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;内存性能分析则是在堆（Heap）分配的时候，记录一下调用堆栈。默认情况下，是每 1000 次分配，取样一次，这个数值可以改变。栈(Stack)分配 由于会随时释放，因此不会被内存分析所记录。由于内存分析是取样方式，并且也因为其记录的是分配内存，而不是使用内存。因此使用内存性能分析工具来准确判断程序具体的内存使用是比较困难的。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;阻塞分析是一个很独特的分析，它有点儿类似于 CPU 性能分析，但是它所记录的是 goroutine 等待资源所花的时间。阻塞分析对分析程序并发瓶颈非常有帮助，阻塞性能分析可以显示出什么时候出现了大批的 goroutine 被阻塞了。阻塞性能分析是特殊的分析工具，在排除 CPU 和内存瓶颈前，不应该用它来分析。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;

&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;我们可以通过 &lt;code&gt;报告生成&lt;/code&gt;、&lt;code&gt;Web 可视化界面&lt;/code&gt;、&lt;code&gt;交互式终端&lt;/code&gt; 三种方式来使用 &lt;code&gt;pprof&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;—— 煎鱼《Golang 大杀器之性能剖析 PProf》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;runtimepprof&quot;&gt;runtime/pprof&lt;/h2&gt;
&lt;p&gt;拿 CPU profiling 举例，增加两行代码，调用 &lt;code&gt;pprof.StartCPUProfile&lt;/code&gt; 启动 cpu profiling，调用 &lt;code&gt;pprof.StopCPUProfile()&lt;/code&gt; 将数据刷到文件里：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;import &quot;runtime/pprof&quot;

var cpuprofile = flag.String(&quot;cpuprofile&quot;, &quot;&quot;, &quot;write cpu profile to file&quot;)

func main() {
    // …………
        
    pprof.StartCPUProfile(f)
    defer pprof.StopCPUProfile()
    
    // …………
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;nethttppprof&quot;&gt;net/http/pprof&lt;/h2&gt;
&lt;p&gt;启动一个端口（和正常提供业务服务的端口不同）监听 pprof 请求：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;import _ &quot;net/http/pprof&quot;

func initPprofMonitor() error {
    pPort := global.Conf.MustInt(&quot;http_server&quot;, &quot;pprofport&quot;, 8080)

    var err error
    addr := &quot;:&quot; + strconv.Itoa(pPort)

    go func() {
        err = http.ListenAndServe(addr, nil)
        if err != nil {
            logger.Error(&quot;funcRetErr=http.ListenAndServe||err=%s&quot;, err.Error())
        }
    }()

    return err
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;pprof&lt;/code&gt; 包会自动注册 handler， 处理相关的请求：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;// src/net/http/pprof/pprof.go:71

func init() {
    http.Handle(&quot;/debug/pprof/&quot;, http.HandlerFunc(Index))
    http.Handle(&quot;/debug/pprof/cmdline&quot;, http.HandlerFunc(Cmdline))
    http.Handle(&quot;/debug/pprof/profile&quot;, http.HandlerFunc(Profile))
    http.Handle(&quot;/debug/pprof/symbol&quot;, http.HandlerFunc(Symbol))
    http.Handle(&quot;/debug/pprof/trace&quot;, http.HandlerFunc(Trace))
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第一个路径 &lt;code&gt;/debug/pprof/&lt;/code&gt; 下面其实还有 5 个子路径：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;goroutine&lt;br/&gt;threadcreate&lt;br/&gt;heap&lt;br/&gt;block&lt;br/&gt;mutex&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;启动服务后，直接在浏览器访问：&lt;/p&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;http://47.93.238.9:8080/debug/pprof/&quot; class=&quot;uri&quot;&gt;http://47.93.238.9:8080/debug/pprof/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;就可以得到一个汇总页面：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/7698088/68526001-46c79100-0312-11ea-9a7f-7eb41cf482d6.png&quot; alt=&quot;页面 /debug/pprof&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以直接点击上面的链接，进入子页面，查看相关的汇总信息。&lt;/p&gt;
&lt;p&gt;关于 goroutine 的信息有两个链接，&lt;code&gt;goroutine&lt;/code&gt; 和 &lt;code&gt;full goroutine stack dump&lt;/code&gt;，前者是一个汇总的消息，可以查看 goroutines 的总体情况，后者则可以看到每一个 goroutine 的状态。页面具体内容的解读可以参考【大彬】的文章。&lt;/p&gt;
&lt;p&gt;点击 &lt;code&gt;profile&lt;/code&gt; 和 &lt;code&gt;trace&lt;/code&gt; 则会在后台进行一段时间的数据采样，采样完成后，返回给浏览器一个 profile 文件，之后在本地通过 &lt;code&gt;go tool pprof&lt;/code&gt; 工具进行分析。&lt;/p&gt;
&lt;p&gt;当我们下载得到了 profile 文件后，执行命令：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;go tool pprof ~/Downloads/profile&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/7698088/68529660-bb62f580-033b-11ea-9ff3-67630ce1d21f.png&quot; alt=&quot;pprof profile&quot;/&gt;&lt;/p&gt;
&lt;p&gt;就可以进入命令行交互式使用模式。执行 &lt;code&gt;go tool pprof -help&lt;/code&gt; 可以查看帮助信息。&lt;/p&gt;
&lt;p&gt;直接使用如下命令，则不需要通过点击浏览器上的链接就能进入命令行交互模式：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;go tool pprof http://47.93.238.9:8080/debug/pprof/profile&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然也是需要先后台采集一段时间的数据，再将数据文件下载到本地，最后进行分析。上述的 Url 后面还可以带上时间参数：&lt;code&gt;?seconds=60&lt;/code&gt;，自定义 CPU Profiling 的时长。&lt;/p&gt;
&lt;p&gt;类似的命令还有：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;# 下载 cpu profile，默认从当前开始收集 30s 的 cpu 使用情况，需要等待 30s
go tool pprof http://47.93.238.9:8080/debug/pprof/profile
# wait 120s
go tool pprof http://47.93.238.9:8080/debug/pprof/profile?seconds=120     

# 下载 heap profile
go tool pprof http://47.93.238.9:8080/debug/pprof/heap

# 下载 goroutine profile
go tool pprof http://47.93.238.9:8080/debug/pprof/goroutine

# 下载 block profile
go tool pprof http://47.93.238.9:8080/debug/pprof/block

# 下载 mutex profile
go tool pprof http://47.93.238.9:8080/debug/pprof/mutex&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;进入交互式模式之后，比较常用的有 &lt;code&gt;top&lt;/code&gt;、&lt;code&gt;list&lt;/code&gt;、&lt;code&gt;web&lt;/code&gt; 等命令。&lt;/p&gt;
&lt;p&gt;执行 &lt;code&gt;top&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/7698088/68526610-ea1ba480-0318-11ea-9a13-ea49a1b849b0.png&quot; alt=&quot;pprof top&quot;/&gt;&lt;/p&gt;
&lt;p&gt;得到四列数据：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;4.5&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;flat&lt;/td&gt;
&lt;td&gt;本函数的执行耗时&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;flat%&lt;/td&gt;
&lt;td&gt;flat 占 CPU 总时间的比例。程序总耗时 16.22s, Eat 的 16.19s 占了 99.82%&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;sum%&lt;/td&gt;
&lt;td&gt;前面每一行的 flat 占比总和&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;cum&lt;/td&gt;
&lt;td&gt;累计量。指该函数加上该函数调用的函数总耗时&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;cum%&lt;/td&gt;
&lt;td&gt;cum 占 CPU 总时间的比例&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;其他类型，如 heap 的 flat, sum, cum 的意义和上面的类似，只不过计算的东西不同，一个是 CPU 耗时，一个是内存大小。&lt;/p&gt;
&lt;p&gt;执行 &lt;code&gt;list&lt;/code&gt;，使用&lt;code&gt;正则&lt;/code&gt;匹配，找到相关的代码：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;list Eat&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;直接定位到了相关长耗时的代码处：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/7698088/68526943-34eaeb80-031c-11ea-8d3d-c3e103c5a8a0.png&quot; alt=&quot;pprof list&quot;/&gt;&lt;/p&gt;
&lt;p&gt;执行 &lt;code&gt;web&lt;/code&gt;（需要安装 graphviz，pprof 能够借助 grapgviz 生成程序的调用图），会生成一个 svg 格式的文件，直接在浏览器里打开（可能需要设置一下 .svg 文件格式的默认打开方式）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/7698088/68526883-9c546b80-031b-11ea-86be-ebe59c7cccad.png&quot; alt=&quot;pprof web&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图中的连线代表对方法的调用，连线上的标签代表指定的方法调用的采样值（例如时间、内存分配大小等），方框的大小与方法运行的采样值的大小有关。&lt;/p&gt;
&lt;p&gt;每个方框由两个标签组成：在 cpu profile 中，一个是方法运行的时间占比，一个是它在采样的堆栈中出现的时间占比（前者是 flat 时间，后者则是 cumulate 时间占比)；框越大，代表耗时越多或是内存分配越多。&lt;/p&gt;
&lt;p&gt;另外，&lt;code&gt;traces&lt;/code&gt; 命令还可以列出函数的调用栈：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/7698088/68537697-6b1f7e00-03a3-11ea-9d68-d7bdd12c38a4.png&quot; alt=&quot;pprof traces&quot;/&gt;&lt;/p&gt;
&lt;p&gt;除了上面讲到的两种方式（报告生成、命令行交互），还可以在浏览器里进行交互。先生成 profile 文件，再执行命令：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;go tool pprof --http=:8080 ~/Downloads/profile&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;进入一个可视化操作界面：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/7698088/68528770-214a7f80-0332-11ea-9ed9-b3b80a244fb5.png&quot; alt=&quot;pprof 可视化界面&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击菜单栏可以在：Top/Graph/Peek/Source 之间进行切换，甚至可以看到火焰图（Flame Graph）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/7698088/68528787-48a14c80-0332-11ea-8e9f-1cf730a02083.png&quot; alt=&quot;pprof 火焰图&quot;/&gt;&lt;/p&gt;
&lt;p&gt;它和一般的火焰图相比刚好倒过来了，调用关系的展现是从上到下。形状越长，表示执行时间越长。注：我这里使用的 go 版本是 1.13，更老一些的版本 pprof 工具不支持 &lt;code&gt;-http&lt;/code&gt; 的参数。当然也可以下载其他的库查看火焰图，例如：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;go get -u github.com/google/pprof

或者

go get github.com/uber/go-torch&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;我在参考资料部分给出了一些使用 pprof 工具进行性能分析的实战文章，可以跟着动手实践一下，之后再用到自己的平时工作中。&lt;/p&gt;
&lt;h2 id=&quot;russ-cox-实战&quot;&gt;Russ Cox 实战&lt;/h2&gt;
&lt;p&gt;这部分主要内容来自参考资料【Ross Cox】，学习一下大牛的优化思路。&lt;/p&gt;
&lt;p&gt;事情的起因是这样的，有人发表了一篇文章，用各种语言实现了一个算法，结果用 go 写的程序非常慢，而 C++ 则最快。然后 Russ Cox 就鸣不平了，哪受得了这个气？马上启用 pprof 大杀器进行优化。最后，程序不仅更快，而且使用的内存更少了！&lt;/p&gt;
&lt;p&gt;首先，增加 cpu profiling 的代码：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;var cpuprofile = flag.String(&quot;cpuprofile&quot;, &quot;&quot;, &quot;write cpu profile to file&quot;)

func main() {
    flag.Parse()
    if *cpuprofile != &quot;&quot; {
        f, err := os.Create(*cpuprofile)
        if err != nil {
            log.Fatal(err)
        }
        
        pprof.StartCPUProfile(f)
        defer pprof.StopCPUProfile()
    }
    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用 pprof 观察耗时 &lt;code&gt;top5&lt;/code&gt; 的函数，发现一个读 map 的函数耗时最长：&lt;code&gt;mapaccess1_fast64&lt;/code&gt;，而它出现在一个递归函数中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/7698088/68537368-47593980-039d-11ea-8c77-187b4760b866.png&quot; alt=&quot;web&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一眼就能看到框最大的 &lt;code&gt;mapacess1_fast64&lt;/code&gt; 函数。执行 &lt;code&gt;web mapaccess1&lt;/code&gt; 命令，更聚焦一些：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/7698088/68537381-88e9e480-039d-11ea-9c7b-3741f791cbc9.png&quot; alt=&quot;web mapaccess1&quot;/&gt;&lt;/p&gt;
&lt;p&gt;调用 &lt;code&gt;mapaccess1_fast64&lt;/code&gt; 函数最多的就是 main.FindLoops 和 main.DFS，是时候定位到具体的代码了，执行命令：&lt;code&gt;list DFS&lt;/code&gt;，定位到相关的代码。&lt;/p&gt;
&lt;p&gt;优化的方法是将 map 改成 slice，能这样做的原因当然和 key 的类型是 int 而且不是太稀疏有关。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;The take away will be that for smaller data sets, you shouldn’t use maps where slices would suffice, as maps have a large overhead.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;修改完之后，再次通过 cpu profiling，发现递归函数的耗时已经不在 top5 中了。但是新增了长耗时函数：runtime.mallocgc，占比 54.2%，而这和分存分配以及垃圾回收相关。&lt;/p&gt;
&lt;p&gt;下一步，增加采集内存数据的代码：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;var memprofile = flag.String(&quot;memprofile&quot;, &quot;&quot;, &quot;write memory profile to this file&quot;)

func main() {
    // …………
    
    FindHavlakLoops(cfgraph, lsgraph)
    if *memprofile != &quot;&quot; {
        f, err := os.Create(*memprofile)
        if err != nil {
            log.Fatal(err)
        }
        pprof.WriteHeapProfile(f)
        f.Close()
        return
    }
    
    // …………
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;继续通过 &lt;code&gt;top5&lt;/code&gt;、&lt;code&gt;list&lt;/code&gt; 命令找到内存分配最多的代码位置，发现这回是向 map 里插入元素使用的内存比较多。改进方式同样是用 slice 代替 map，但 map 还有一个特点是可以重复插入元素，因此新写了一个向 slice 插入元素的函数：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;func appendUnique(a []int, x int) []int {
    for _, y := range a {
        if x == y {
            return a
        }
    }
    return append(a, x)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;好了，现在程序比最初的时候快了 2.1 倍。再次查看 cpu profile 数据，发现 &lt;code&gt;runtime.mallocgc&lt;/code&gt; 降了一些，但仍然占比 50.9%。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;Another way to look at why the system is garbage collecting is to look at the allocations that are causing the collections, the ones that spend most of the time in mallocgc.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因此需要查看垃圾回收到底在回收哪些内容，这些内容就是导致频繁垃圾回收的“罪魁祸首”。&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;web mallocgc&lt;/code&gt; 命令，将和 mallocgc 相关的函数用矢量图的方式展现出来，但是有太多样本量很少的节点影响观察，增加过滤命令：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;go tool pprof --nodefraction=0.1 profile&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/7698088/68537420-13cadf00-039e-11ea-98d9-f215a0eaabb8.png&quot; alt=&quot;web mallocgc&quot;/&gt;&lt;/p&gt;
&lt;p&gt;将少于 &lt;code&gt;10%&lt;/code&gt; 的采样点过滤掉，新的矢量图可以直观地看出，&lt;code&gt;FindLoops&lt;/code&gt; 触发了最多的垃圾回收操作。继续使用命令 &lt;code&gt;list FindLoops&lt;/code&gt; 直接找到代码的位置。&lt;/p&gt;
&lt;p&gt;原来，每次执行 &lt;code&gt;FindLoops&lt;/code&gt; 函数时，都要 &lt;code&gt;make&lt;/code&gt; 一些临时变量，这会加重垃圾回收器的负担。改进方式是增加一个全局变量 cache，可以重复利用。坏处是，现在不是线程安全的了。&lt;/p&gt;
&lt;p&gt;使用 pprof 工具进行的优化到这就结束了。最后的结果很不错，基本上能达到和 C++ 同等的速度和同等的内存分配大小。&lt;/p&gt;
&lt;p&gt;我们能得到的启发就是先使用 cpu profile 找出耗时最多的函数，进行优化。如果发现 gc 执行比较多的时候，找出内存分配最多的代码以及引发内存分配的函数，进行优化。&lt;/p&gt;
&lt;p&gt;原文很精彩，虽然写作时间比较久远（最初写于 2011 年）了，但仍然值得一看。另外，参考资料【wolfogre】的实战文章也非常精彩，而且用的招式和这篇文章差不多，但是你可以运行文章提供的样例程序，一步步地解决性能问题，很有意思！&lt;/p&gt;
&lt;h2 id=&quot;查找内存泄露&quot;&gt;查找内存泄露&lt;/h2&gt;
&lt;p&gt;内存分配既可以发生在堆上也可以在栈上。堆上分配的内存需要垃圾回收或者手动回收（对于没有垃圾回收的语言，例如 C++），栈上的内存则通常在函数退出后自动释放。&lt;/p&gt;
&lt;p&gt;Go 语言通过逃逸分析会将尽可能多的对象分配到栈上，以使程序可以运行地更快。&lt;/p&gt;
&lt;p&gt;这里说明一下，有两种内存分析策略：一种是当前的（这一次采集）内存或对象的分配，称为 &lt;code&gt;inuse&lt;/code&gt;；另一种是从程序运行到现在所有的内存分配，不管是否已经被 gc 过了，称为 &lt;code&gt;alloc&lt;/code&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;As mentioned above, there are two main memory analysis strategies with pprof. One is around looking at the current allocations (bytes or object count), called inuse. The other is looking at all the allocated bytes or object count throughout the run-time of the program, called alloc. This means regardless if it was gc-ed, a summation of everything sampled.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;加上 &lt;code&gt;-sample_index&lt;/code&gt; 参数后，可以切换内存分析的类型：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;go tool pprof -sample_index=alloc_space  http://47.93.238.9:8080/debug/pprof/heap&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;共有 4 种：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;inuse_space&lt;/td&gt;
&lt;td&gt;amount of memory allocated and not released yet&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;inuse_objects&lt;/td&gt;
&lt;td&gt;amount of objects allocated and not released yet&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;alloc_space&lt;/td&gt;
&lt;td&gt;total amount of memory allocated (regardless of released)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;alloc_objects&lt;/td&gt;
&lt;td&gt;total amount of objects allocated (regardless of released)&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;参考资料【大彬 实战内存泄露】讲述了如何通过类似于 diff 的方式找到前后两个时刻多出的 goroutine，进而找到 goroutine 泄露的原因，并没有直接使用 heap 或者 goroutine 的 profile 文件。同样推荐阅读！&lt;/p&gt;

&lt;p&gt;&lt;code&gt;pprof&lt;/code&gt; 是进行 Go 程序性能分析的有力工具，它通过采样、收集运行中的 Go 程序性能相关的数据，生成 profile 文件。之后，提供三种不同的展现形式，让我们能更直观地看到相关的性能数据。&lt;/p&gt;
&lt;p&gt;得到性能数据后，可以使用 &lt;code&gt;top&lt;/code&gt;、&lt;code&gt;web&lt;/code&gt;、&lt;code&gt;list&lt;/code&gt;等命令迅速定位到相应的代码处，并进行优化。&lt;/p&gt;
&lt;p&gt;“过早的优化是万恶之源”。实际工作中，很少有人会关注性能，但当你写出的程序存在性能瓶颈，qa 压测时，qps 上不去，为了展示一下技术实力，还是要通过 pprof 观察性能瓶颈，进行相应的性能优化。&lt;/p&gt;

&lt;p&gt;【Russ Cox 优化过程，并附上代码】&lt;a href=&quot;https://blog.golang.org/profiling-go-programs&quot; class=&quot;uri&quot;&gt;https://blog.golang.org/profiling-go-programs&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【google pprof】&lt;a href=&quot;https://github.com/google/pprof&quot; class=&quot;uri&quot;&gt;https://github.com/google/pprof&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【使用 pprof 和火焰图调试 golang 应用】&lt;a href=&quot;https://cizixs.com/2017/09/11/profiling-golang-program/&quot; class=&quot;uri&quot;&gt;https://cizixs.com/2017/09/11/profiling-golang-program/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【资源合集】&lt;a href=&quot;https://jvns.ca/blog/2017/09/24/profiling-go-with-pprof/&quot; class=&quot;uri&quot;&gt;https://jvns.ca/blog/2017/09/24/profiling-go-with-pprof/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【Profiling your Golang app in 3 steps】&lt;a href=&quot;https://coder.today/tech/2018-11-10_profiling-your-golang-app-in-3-steps/&quot; class=&quot;uri&quot;&gt;https://coder.today/tech/2018-11-10_profiling-your-golang-app-in-3-steps/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【案例，压测 Golang remote profiling and flamegraphs】&lt;a href=&quot;https://matoski.com/article/golang-profiling-flamegraphs/&quot; class=&quot;uri&quot;&gt;https://matoski.com/article/golang-profiling-flamegraphs/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【煎鱼 pprof】&lt;a href=&quot;https://segmentfault.com/a/1190000016412013&quot; class=&quot;uri&quot;&gt;https://segmentfault.com/a/1190000016412013&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【鸟窝 pprof】&lt;a href=&quot;https://colobu.com/2017/03/02/a-short-survey-of-golang-pprof/&quot; class=&quot;uri&quot;&gt;https://colobu.com/2017/03/02/a-short-survey-of-golang-pprof/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【关于 Go 的 7 种性能分析方法】&lt;a href=&quot;https://blog.lab99.org/post/golang-2017-10-20-video-seven-ways-to-profile-go-apps.html&quot; class=&quot;uri&quot;&gt;https://blog.lab99.org/post/golang-2017-10-20-video-seven-ways-to-profile-go-apps.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【pprof 比较全】&lt;a href=&quot;https://juejin.im/entry/5ac9cf3a518825556534c76e&quot; class=&quot;uri&quot;&gt;https://juejin.im/entry/5ac9cf3a518825556534c76e&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【通过实例来讲解分析、优化过程】&lt;a href=&quot;https://artem.krylysov.com/blog/2017/03/13/profiling-and-optimizing-go-web-applications/&quot; class=&quot;uri&quot;&gt;https://artem.krylysov.com/blog/2017/03/13/profiling-and-optimizing-go-web-applications/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【Go 作者 Dmitry Vyukov】&lt;a href=&quot;https://github.com/golang/go/wiki/Performance&quot; class=&quot;uri&quot;&gt;https://github.com/golang/go/wiki/Performance&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【wolfogre 非常精彩的实战文章】&lt;a href=&quot;https://blog.wolfogre.com/posts/go-ppof-practice/&quot; class=&quot;uri&quot;&gt;https://blog.wolfogre.com/posts/go-ppof-practice/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【dave.cheney】&lt;a href=&quot;https://dave.cheney.net/high-performance-go-workshop/dotgo-paris.html&quot; class=&quot;uri&quot;&gt;https://dave.cheney.net/high-performance-go-workshop/dotgo-paris.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【实战案例】&lt;a href=&quot;https://www.cnblogs.com/sunsky303/p/11058808.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/sunsky303/p/11058808.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【大彬 实战内存泄露】&lt;a href=&quot;https://segmentfault.com/a/1190000019222661&quot; class=&quot;uri&quot;&gt;https://segmentfault.com/a/1190000019222661&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【查找内存泄露】&lt;a href=&quot;https://www.freecodecamp.org/news/how-i-investigated-memory-leaks-in-go-using-pprof-on-a-large-codebase-4bec4325e192/&quot; class=&quot;uri&quot;&gt;https://www.freecodecamp.org/news/how-i-investigated-memory-leaks-in-go-using-pprof-on-a-large-codebase-4bec4325e192/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【雷神 3 性能优化】&lt;a href=&quot;https://diducoder.com/sotry-about-sqrt.html&quot; class=&quot;uri&quot;&gt;https://diducoder.com/sotry-about-sqrt.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 11 Nov 2019 00:16:00 +0000</pubDate>
<dc:creator>Stefno</dc:creator>
<og:description>过早的优化是万恶之源。而在真正遇到瓶颈的时候，pprof 可以快速定位到需要优化的地方。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qcrao-2018/p/11832732.html</dc:identifier>
</item>
<item>
<title>[ASP.NET Core 3框架揭秘] 依赖注入[5]: 利用容器提供服务 - Artech</title>
<link>http://www.cnblogs.com/artech/p/inside-asp-net-core-03-05.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/artech/p/inside-asp-net-core-03-05.html</guid>
<description>&lt;p&gt;毫不夸张地说，整个ASP.NET Core框架是建立在依赖注入框架之上的。ASP.NET Core应用在启动时构建管道以及利用该管道处理每个请求过程中使用到的服务对象均来源于依赖注入容器。该依赖注入容器不仅为ASP.NET Core框架自身提供必要的服务，同时也是应用程序的服务提供者，依赖注入已经成为了ASP.NET Core应用的基本编程模式。&lt;/p&gt;

&lt;p&gt;为了让读者朋友们能够更加容易地认识.NET Core提供的依赖注入框架，我在“《&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-03-04.html&quot;&gt;一个迷你版DI框架&lt;/a&gt;》”中特意创建了一个名为Cat的迷你版依赖注入框架。不论是编程模式还是实现原理，Cat与我们即将介绍的依赖注入框架都非常相似。这个依赖注入框架主要涉及两个NuGet包，我们在编程过程中频繁使用的一些接口和基础数据类型都定义在NuGet包“Microsoft.Extensions.DependencyInjection.Abstractions”中，而依赖注入的具体实现则由“Microsoft.Extensions.DependencyInjection”这个NuGet包来承载。&lt;/p&gt;
&lt;p&gt;我在设计Cat的时候，既将它作为提供服务实例的依赖注入容器，也将它作为存放服务注册的集合，但是.NET Core依赖注入框架则将这两者分离开来。我们添加的服务注册被保存到通过IServiceCollection接口表示的集合之中，由这个集合创建的依赖注入容器体现为一个IServiceProvider对象。&lt;/p&gt;
&lt;p&gt;作为依赖注入容器的IServiceProvider对象不仅具有类似于Cat的层次结构，两者对提供的服务实例也采用一致的生命周期管理方式。依赖注入框架利用如下这个枚举ServiceLifetime来表示Singleton、Scoped和Transient三种生命周期模式，我在Cat中则将其命名为Root、Self和Transient，前者命名关注于现象，后者则关注于内部实现。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt;&lt;span&gt; ServiceLifetime
{
    Singleton,
    Scoped,
    Transient
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;应用程序初始化过程中添加的服务注册是依赖注入容器用来提供所需服务实例的依据。由于IServiceProvider对象总是利用指定的服务类型来提供对应服务实例，所以服务总是基于类型进行注册。我们倾向于利用接口来对服务进行抽象，所以这里的服务类型一般为接口，但是依赖注入框架对服务注册的类型并没有任何限制。具体的服务注册主要体现为如下三种形式，除了直接提供一个服务实例的注册形式之外（这种形式默认采用Singleton模式），我们在注册服务的时候必须指定一个具体的生命周期模式。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;指定具体的服务实现类型。&lt;/li&gt;
&lt;li&gt;提供一个现成的服务实例。&lt;/li&gt;
&lt;li&gt;指定一个创建服务实例的工厂。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们的演示实例时一个普通的控制台应用。由于“Microsoft.Extensions.DependencyInjection”这个NuGet包承载了整个依赖注入框架的实现，所以我们应该添加该NuGet包的依赖。由于是ASP.NET Core框架的基础NuGet包之一，所以我们可以通过修改项目文件并按照如下的方式添加针对“Microsoft.AspNetCore.App”的框架引用（FrameworkReference）来引入该NuGet包。对于后续部分中采用 “Microsoft.NET.Sdk”作为SDK的演示实例，如果未作说明，在默认采用这种方式添加所需NuGet包的依赖。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Project &lt;/span&gt;&lt;span&gt;Sdk&lt;/span&gt;&lt;span&gt;=&quot;Microsoft.NET.Sdk&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;PropertyGroup&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;OutputType&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Exe&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;OutputType&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TargetFramework&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;netcoreapp3.0&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;TargetFramework&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;PropertyGroup&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ItemGroup&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;FrameworkReference &lt;/span&gt;&lt;span&gt;Include&lt;/span&gt;&lt;span&gt;=&quot;Microsoft.AspNetCore.App&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ItemGroup&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Project&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在添加了针对“Microsoft.Extensions.DependencyInjection”这个NuGet包的依赖之后，我们定义了如下这些接口和实现类型来表示相应的服务。如下面的代码片段所示，Foo、Bar和Baz分别实现了对应的接口IFoo、IBar和IBaz。为了反映DI框架对服务实例生命周期的控制，我们让它们派生于同一个基类Base。Base实现了IDisposable接口，我们在其构造函数和实现的Dispose方法中打印出相应的文字以确定对应的实例何时被创建和释放。我们还定义了一个泛型的接口IFoobar&amp;lt;T1, T2&amp;gt;和对应的实现类Foobar&amp;lt;T1, T2&amp;gt;来演示针对泛型服务实例的提供。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IFoo {}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IBar {}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IBaz {}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; IFoobar&amp;lt;T1, T2&amp;gt;&lt;span&gt; {}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Base : IDisposable
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Base()  =&amp;gt; Console.WriteLine($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;An instance of {GetType().Name} is created.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Dispose() =&amp;gt; Console.WriteLine($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;The instance of {GetType().Name} is disposed.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foo : Base, IFoo, IDisposable { }
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Bar : Base, IBar, IDisposable { }
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Baz : Base, IBaz, IDisposable { }
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Foobar&amp;lt;T1, T2&amp;gt;: IFoobar&amp;lt;T1,T2&amp;gt;&lt;span&gt;
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IFoo Foo { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IBar Bar { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Foobar(IFoo foo, IBar bar)
    {
        Foo &lt;/span&gt;=&lt;span&gt; foo;
        Bar &lt;/span&gt;=&lt;span&gt; bar;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
在如下所示的代码片段中，我们创建了一个ServiceCollection（它是对IServiceCollection接口的默认实现）对象并调用相应的方法（AddTransient、AddScoped和AddSingleton）针对接口IFoo、IBar和IBaz注册了对应的服务，从方法命名可以看出注册的服务采用的生命周期模式分别为Transient、Scoped和Singleton。在完成服务注册之后，我们调用IServiceCollection接口的扩展方法BuildServiceProvider创建出代表依赖注入容器的IServiceProvider对象，并调用该对象的GetService方法来提供相应的服务实例。调试断言表明IServiceProvider对象提供的服务实例与预先添加的服务注册是一致的。
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
{
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Main()
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; provider = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ServiceCollection()
            .AddTransient&lt;/span&gt;&amp;lt;IFoo, Foo&amp;gt;&lt;span&gt;()
            .AddScoped&lt;/span&gt;&amp;lt;IBar&amp;gt;(_ =&amp;gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Bar())
            .AddSingleton&lt;/span&gt;&amp;lt;IBaz, Baz&amp;gt;&lt;span&gt;()
            .BuildServiceProvider();
        Debug.Assert(provider.GetService&lt;/span&gt;&amp;lt;IFoo&amp;gt;() &lt;span&gt;is&lt;/span&gt;&lt;span&gt; Foo);
        Debug.Assert(provider.GetService&lt;/span&gt;&amp;lt;IBar&amp;gt;() &lt;span&gt;is&lt;/span&gt;&lt;span&gt; Bar);
        Debug.Assert(provider.GetService&lt;/span&gt;&amp;lt;IBaz&amp;gt;() &lt;span&gt;is&lt;/span&gt;&lt;span&gt; Baz); 
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;除了提供类似于IFoo、IBar和IBaz这样普通的服务实例之外，IServiceProvider对象同样也能提供&lt;span&gt;泛型&lt;/span&gt;服务实例。如下面的代码片段所示，在为创建的ServiceCollection对象添加了针对IFoo和IBar接口的服务注册之后，我们调用AddTransient方法注册了针对泛型定义IFoobar&amp;lt;,&amp;gt;的服务注册（实现的类型为Foobar&amp;lt;,&amp;gt;）。当我们利用ServiceCollection创建出代表依赖注入容器的IServiceProvider对象并由它提供一个类型为IFoobar&amp;lt;IFoo, IBar&amp;gt;的服务实例的时候，它会创建并返回一个Foobar&amp;lt;Foo, Bar&amp;gt;对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Main()
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; provider = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ServiceCollection()
            .AddTransient&lt;/span&gt;&amp;lt;IFoo, Foo&amp;gt;&lt;span&gt;()
            .AddTransient&lt;/span&gt;&amp;lt;IBar, Bar&amp;gt;&lt;span&gt;()
            .AddTransient(&lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;(IFoobar&amp;lt;,&amp;gt;), &lt;span&gt;typeof&lt;/span&gt;(Foobar&amp;lt;,&amp;gt;&lt;span&gt;))
            .BuildServiceProvider();

        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; foobar = (Foobar&amp;lt;IFoo, IBar&amp;gt;)provider.GetService&amp;lt;IFoobar&amp;lt;IFoo, IBar&amp;gt;&amp;gt;&lt;span&gt;();
        Debug.Assert(foobar.Foo &lt;/span&gt;&lt;span&gt;is&lt;/span&gt;&lt;span&gt; Foo);
        Debug.Assert(foobar.Bar &lt;/span&gt;&lt;span&gt;is&lt;/span&gt;&lt;span&gt; Bar);       
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当我们在进行服务注册的时候，可以为同一个类型添加多个服务注册。虽然添加的所有服务注册均是有效的，但是由于扩展方法GetService&amp;lt;T&amp;gt;总是返回一个服务实例。依赖注入框架对该方法采用了“后来居上”的策略，也就是说它总是采用最近添加的服务注册来创建服务实例。如果我们调用另一个扩展方法GetServices&amp;lt;TService&amp;gt;，它将利用返回根据所有服务注册提供的服务实例。如下面的代码片段所示，我们为创建的ServiceCollection对象添加了三个针对Base类型的服务注册，对应的实现类型分别为Foo、Bar和Baz。我们最后将Base作为泛型参数调用了&lt;span&gt;GetServices&amp;lt;Base&amp;gt;&lt;/span&gt;方法，该方法会返回包含三个Base对象的集合，集合元素的类型分别为Foo、Bar和Baz。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Main()
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; services = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ServiceCollection()
            .AddTransient&lt;/span&gt;&amp;lt;Base, Foo&amp;gt;&lt;span&gt;()
            .AddTransient&lt;/span&gt;&amp;lt;Base, Bar&amp;gt;&lt;span&gt;()
            .AddTransient&lt;/span&gt;&amp;lt;Base, Baz&amp;gt;&lt;span&gt;()
            .BuildServiceProvider()
            .GetServices&lt;/span&gt;&amp;lt;Base&amp;gt;&lt;span&gt;();
        Debug.Assert(services.OfType&lt;/span&gt;&amp;lt;Foo&amp;gt;&lt;span&gt;().Any());
        Debug.Assert(services.OfType&lt;/span&gt;&amp;lt;Bar&amp;gt;&lt;span&gt;().Any());
        Debug.Assert(services.OfType&lt;/span&gt;&amp;lt;Baz&amp;gt;&lt;span&gt;().Any());      
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对于IServiceProvider针对服务实例的提供还有这么一个细节：如果我们在调用GetService或者GetService&amp;lt;T&amp;gt;方法时服务类型设置为IServiceProvider接口，提供的服务实例实际上就是当前的IServiceProvider对象。这一特性意味着我们可以将代表依赖注入容器的IServiceProvider作为服务进行注入，这一特性体现在如下所示的调试断言中。但是在上一章已经提到过，一旦我们在应用中利用注入的IServiceProvider来获取其他依赖的服务实例，意味着我们在使用“Service Locator”模式。这是一种“反模式（Anti-Pattern）”，当我们的应用程序出现了这样的代码时，最好多想想是否真的需要这么做。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; provider = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ServiceCollection().BuildServiceProvider();
Debug.Assert(provider.GetService&lt;/span&gt;&amp;lt;IServiceProvider&amp;gt;() == provider);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;代表依赖注入容器的IServiceProvider对象之间的层次结构造就了三种不同的生命周期模式。由于Singleton服务实例保存在作为根容器的IServiceProvider对象上，所以它能够在多个同根IServiceProvider对象之间提供真正的单例保证。Scoped服务实例被保存在当前IServiceProvider对象上，所以它只能在当前范围内保证提供的实例是单例的。没有实现IDisposable接口的Transient服务则采用“&lt;span&gt;即用即建，用后即弃&lt;/span&gt;”的策略。&lt;/p&gt;
&lt;p&gt;接下来我们通过对前面演示的实例略作修改来演示三种不同生命周期模式的差异。在如下所示的代码片段中我们创建了一个ServiceCollection对象并针对接口IFoo、IBar和IBaz注册了对应的服务，它们采用的生命周期模式分别为Transient、Scoped和Singleton。在利用ServiceCollection创建出代表依赖注入容器的IServiceProvider对象之后，我们调用其CreateScope方法创建了两个代表“服务范围”的IServiceScope对象，该对象的ServiceProvider属性返回一个新的IServiceProvider对象，它实际上是当前IServiceProvider对象的子容器。我们最后利用作为子容器的IServiceProvider对象来提供相应的服务实例。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
{
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Main()
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; root = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ServiceCollection()
            .AddTransient&lt;/span&gt;&amp;lt;IFoo, Foo&amp;gt;&lt;span&gt;()
            .AddScoped&lt;/span&gt;&amp;lt;IBar&amp;gt;(_ =&amp;gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Bar())
            .AddSingleton&lt;/span&gt;&amp;lt;IBaz, Baz&amp;gt;&lt;span&gt;()
            .BuildServiceProvider();
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; provider1 =&lt;span&gt; root.CreateScope().ServiceProvider;
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; provider2 =&lt;span&gt; root.CreateScope().ServiceProvider;

        GetServices&lt;/span&gt;&amp;lt;IFoo&amp;gt;&lt;span&gt;(provider1);
        GetServices&lt;/span&gt;&amp;lt;IBar&amp;gt;&lt;span&gt;(provider1);
        GetServices&lt;/span&gt;&amp;lt;IBaz&amp;gt;&lt;span&gt;(provider1);
        Console.WriteLine();
        GetServices&lt;/span&gt;&amp;lt;IFoo&amp;gt;&lt;span&gt;(provider2);
        GetServices&lt;/span&gt;&amp;lt;IBar&amp;gt;&lt;span&gt;(provider2);
        GetServices&lt;/span&gt;&amp;lt;IBaz&amp;gt;&lt;span&gt;(provider2);

        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; GetServices&amp;lt;T&amp;gt;&lt;span&gt;(IServiceProvider provider)
        {
            provider.GetService&lt;/span&gt;&amp;lt;T&amp;gt;&lt;span&gt;();
            provider.GetService&lt;/span&gt;&amp;lt;T&amp;gt;&lt;span&gt;();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的程序运行之后会在控制台上输出如下图所示的结果。由于服务IFoo被注册为Transient服务，所以IServiceProvider针对该接口类型的四次调用都会创建一个全新的Foo对象。IBar服务的生命周期模式为Scoped，如果我们利用同一个IServiceProvider对象来提供对应的服务实例，它只会创建一个Bar对象，所以整个程序执行过程中会创建两个Bar对象。IBaz服务采用Singleton生命周期，所以具有同根的两个IServiceProvider对象提供的总是同一个Baz对象，后者只会被创建一次。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/19327/201911/19327-20191111082033138-480669082.png&quot;&gt;&lt;img width=&quot;325&quot; height=&quot;234&quot; title=&quot;4-1&quot; alt=&quot;4-1&quot; src=&quot;https://img2018.cnblogs.com/blog/19327/201911/19327-20191111082033438-2134653211.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作为依赖注入容器的IServiceProvider对象不仅为我们提供所需的服务实例，它还帮我们管理这些服务实例的生命周期。如果某个服务类型实现了IDisposable接口，意味着当生命周期完结的时候需要通过调用Dispose方法执行一些资源释放操作，这些操作同样由提供该服务实例的IServiceProvider对象来驱动执行。依赖注入框架针对提供服务实例的释放策略取决于对应的服务注册采用的生命周期模式，具体的策略如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Transient和Scoped：所有实现了IDisposable接口的服务实例会被当前IServiceProvider对象保存起来，当IServiceProvider对象的Dispose方法被调用的时候，这些服务实例的Dispose方法会随之被调用。&lt;/li&gt;
&lt;li&gt;Singleton：由于服务实例保存在作为根容器的IServiceProvider对象上，只有当后者的Dispose方法被调用的时候，这些服务实例的Dispose方法才会随之被调用。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对于一个ASP.NET Core应用来说，它具有一个与当前应用绑定代表全局根容器的IServiceProvider对象。对于处理的每一次请求，ASP.NET Core框架都会利用这个根容器来创建基于当前请求的服务范围，并利用后者提供的IServiceProvider对象来提供请求处理所需的服务实例。请求处理完成之后，创建的服务范围被终结，对应的IServiceProvider对象也随之被释放，此时由它提供的Scoped服务实例以及实现了IDisposable接口的Transient服务实例得以及时释放。&lt;/p&gt;
&lt;p&gt;上述的释放策略可以通过如下的演示实例来印证。我们在如下的代码片段中创建了一个ServiceCollection对象，并针对不同的生命周期模式添加了针对IFoo、IBar和IBaz的服务注册。在利用ServiceCollection创建出作为根容器的IServiceProvider之后，我们调用它的CreateScope方法创建出对应的服务范围。接下来我们利用创建的服务范围得到代表子容器的IServiceProvider对象，并用它提供了三个注册服务对应的实例。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
{
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Main()
    {
        &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; root = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ServiceCollection()
            .AddTransient&lt;/span&gt;&amp;lt;IFoo, Foo&amp;gt;&lt;span&gt;()
            .AddScoped&lt;/span&gt;&amp;lt;IBar, Bar&amp;gt;&lt;span&gt;()
            .AddSingleton&lt;/span&gt;&amp;lt;IBaz, Baz&amp;gt;&lt;span&gt;()
            .BuildServiceProvider())
        {
            &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; scope =&lt;span&gt; root.CreateScope())
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; provider =&lt;span&gt; scope.ServiceProvider;
                provider.GetService&lt;/span&gt;&amp;lt;IFoo&amp;gt;&lt;span&gt;();
                provider.GetService&lt;/span&gt;&amp;lt;IBar&amp;gt;&lt;span&gt;();
                provider.GetService&lt;/span&gt;&amp;lt;IBaz&amp;gt;&lt;span&gt;();
                Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Child container is disposed.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Root container is disposed.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于代表根容器的IServiceProvider对象和服务范围的创建都是在using块中进行的，所有针对它们的Dispose方法都会在using块结束的地方被调用。为了确定方法被调用的时机，我们特意在控制台上打印了相应的文字。该程序运行之后会在控制台上输出如下图所示的结果，我们可以看到当作为子容器的IServiceProvider对象被释放的时候，由它提供的两个生命周期模式分别为Transient和Scoped的两个服务实例（Foo和Bar）被正常释放了。至于生命周期模式为Singleton的服务实例Baz，它的Dispose方法会延迟到作为根容器的IServiceProvider对象被释放的时候。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/19327/201911/19327-20191111082033599-970971357.png&quot;&gt;&lt;img width=&quot;356&quot; height=&quot;220&quot; title=&quot;4-2&quot; alt=&quot;4-2&quot; src=&quot;https://img2018.cnblogs.com/blog/19327/201911/19327-20191111082033828-1286821543.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Singleton和Scoped这两种不同的生命周期是通过将提供的服务实例分别存放到作为根容器的IServiceProvider对象和当前IServiceProvider对象来实现的，这意味着&lt;span&gt;作为根容器的IServiceProvider对象提供的Scoped服务实例也是单例的&lt;/span&gt;。&lt;span&gt;如果某个Singleton服务依赖另一个Scoped服务，那么Scoped服务实例将被一个Singleton服务实例所引用，意味着Scoped服务实例也成了一个Singleton服务实例&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;在ASP.NET Core应用中，我们将某个服务注册的生命周期设置为Scoped的真正意图是希望依赖注入容器根据每个接收的请求来创建和释放服务实例，但是一旦出现上述这种情况，意味着Scoped服务实例将变成一个Singleton服务实例，这样的Scoped服务实例会直到应用关闭的那一刻才会被释放，这无疑不是我们希望得到的结果。如果某个Scoped服务实例引用的资源（比如数据库连接）需要被及时释放，这可能会对应用造成灭顶之灾。为了避免这种情况的出现，我们在利用IServiceProvider提供服务过程中可以开启针对服务范围的验证。&lt;/p&gt;
&lt;p&gt;如果希望IServiceProvider在提供服务的过程中对服务范围作有效性检验，我们只需要在调用IServiceCollection的BuildServiceProvider扩展方法的时候将一个布尔类型的True值作为参数即可。在如下所示的演示程序中，我们定义了两个服务接口（IFoo和IBar）和对应的实现类型（Foo和Bar），其中Foo依赖IBar。我们将IFoo和IBar分别注册为Singleton和Scoped服务，当调用BuildServiceProvider方法创建代表依赖注入容器的IServiceProvider对象的时候，我们将参数设置为True以开启针对服务范围的检验。我们最后分别利用代表根容器和子容器的IServiceProvider来提供这两种类型的服务实例。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
{
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Main()
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; root = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ServiceCollection()
            .AddSingleton&lt;/span&gt;&amp;lt;IFoo, Foo&amp;gt;&lt;span&gt;()
            .AddScoped&lt;/span&gt;&amp;lt;IBar, Bar&amp;gt;&lt;span&gt;()
            .BuildServiceProvider(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);    
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; child =&lt;span&gt; root.CreateScope().ServiceProvider;

        &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; ResolveService&amp;lt;T&amp;gt;&lt;span&gt;(IServiceProvider provider)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; isRootContainer = root == provider ? &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Yes&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;No&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                provider.GetService&lt;/span&gt;&amp;lt;T&amp;gt;&lt;span&gt;();
                Console.WriteLine( $&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Status: Success; &lt;/span&gt;
                    Service Type: {&lt;span&gt;typeof&lt;/span&gt;(T).Name}; Root: {isRootContainer}&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;
&lt;span&gt;            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
            {
                Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Status: Fail; &lt;/span&gt;
                    Service Type: {&lt;span&gt;typeof&lt;/span&gt;(T).Name}; Root: {isRootContainer}&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;
                Console.WriteLine($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Error: {ex.Message}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }
        }

        ResolveService&lt;/span&gt;&amp;lt;IFoo&amp;gt;&lt;span&gt;(root);
        ResolveService&lt;/span&gt;&amp;lt;IBar&amp;gt;&lt;span&gt;(root);
        ResolveService&lt;/span&gt;&amp;lt;IFoo&amp;gt;&lt;span&gt;(child);
        ResolveService&lt;/span&gt;&amp;lt;IBar&amp;gt;&lt;span&gt;(child);
    }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IFoo {}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IBar {}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foo : IFoo
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IBar Bar { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Foo(IBar bar) =&amp;gt; Bar =&lt;span&gt; bar;
}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Bar : IBar {}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面这个演示实例启动之后将在控制台上输出如下图所示的结果。从输出结果可以看出针对四个服务解析，只有一次（使用代表子容器的IServiceProvider提供IBar服务实例）是成功的。这个实例充分说明了一旦开启了针对服务范围的验证，IServiceProvider对象不可能提供以单例形式存在的Scoped服务。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/19327/201911/19327-20191111082034051-1395900354.png&quot;&gt;&lt;img width=&quot;710&quot; height=&quot;228&quot; title=&quot;4-3&quot; alt=&quot;4-3&quot; src=&quot;https://img2018.cnblogs.com/blog/19327/201911/19327-20191111082034286-228205451.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;针对服务范围的检验体现在配置选项类型ServiceProviderOptions的ValidateScopes属性上。如下面的代码片段所示，ServiceProviderOptions还具有另一个名为ValidateOnBuild的属性，如果该属性设置为True，意味着IServiceProvider对象被构建的时候会检验提供的每个ServiceDescriptor的有效性，即确保它们最终都具有提供对应服务实例的能力。默认情况下ValidateOnBuild的属性值为False，意味着只有利用IServiceProvider对象来提供我们所需的服务实例的时候，相应的异常采用才会抛出来。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ServiceProviderOptions
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; ValidateScopes { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; ValidateOnBuild { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们照例来作一个在构建IServiceProvider对象时检验服务注册有效性的实例。我们定义了如下一个接口IFoobar和对应的实现类型Foobar，由于我们希望采用单例的形式来使用Foobar对象，所以我们为它定义了唯一的私有构造函数。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IFoobar {}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foobar : IFoobar
{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Foobar() {}
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; Foobar Instance = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Foobar();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在如下的演示实例中，我们定义了一个内嵌的BuildServiceProvider方法来完成针对IFoobar/Foobar的服务注册和最终对IServiceProvider对象的创建。当我们在调用扩展方法BuildServiceProvider创建对应IServiceProvider对象时指定了一个ServiceProviderOptions对象，而它的ValidateOnBuild属性来源于内嵌方法的同名参数。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
{
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Main()
    {        
       BuildServiceProvider(&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
        BuildServiceProvider(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; BuildServiceProvider(&lt;span&gt;bool&lt;/span&gt;&lt;span&gt; validateOnBuild)
        {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; options = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ServiceProviderOptions
                {
                    ValidateOnBuild &lt;/span&gt;=&lt;span&gt; validateOnBuild
                };
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ServiceCollection()
                    .AddSingleton&lt;/span&gt;&amp;lt;IFoobar, Foobar&amp;gt;&lt;span&gt;()
                    .BuildServiceProvider(options);
                Console.WriteLine(
                    $&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Status: Success; ValidateOnBuild: {validateOnBuild}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
            {
                Console.WriteLine( $&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Status: Fail; ValidateOnBuild: {validateOnBuild}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Error: {ex.Message}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于Foobar只具有一个唯一的私有构造函数，所以内嵌方法BuildServiceProvider提供的服务注册并不能提供我们所需的服务实例，所以这个服务注册是无效的。由于默认情况下构建IServiceProvider对象的时候并不会对服务注册作有效性检验，所以此时无效的服务注册并不会及时被探测到。一旦我们将ValidateOnBuild选项设置为True，IServiceProvider对象在被构建的时候就会抛出异常，如下图所示的输出结果体现了这一点。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/19327/201911/19327-20191111082034545-563096366.png&quot;&gt;&lt;img width=&quot;729&quot; height=&quot;204&quot; title=&quot;4-4&quot; alt=&quot;4-4&quot; src=&quot;https://img2018.cnblogs.com/blog/19327/201911/19327-20191111082034798-1592081888.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-03-01.html&quot;&gt;[ASP.NET Core 3框架揭秘] 依赖注入[1]：控制反转&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-03-02.html&quot;&gt;[ASP.NET Core 3框架揭秘] 依赖注入[2]：IoC模式&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-03-03.html&quot;&gt;[ASP.NET Core 3框架揭秘] 依赖注入[3]：依赖注入模式&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-03-04.html&quot;&gt;[ASP.NET Core 3框架揭秘] 依赖注入[4]：一个迷你版DI框架&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-03-05.html&quot;&gt;[ASP.NET Core 3框架揭秘] 依赖注入[5]：利用容器提供服务&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-03-06.html&quot;&gt;[ASP.NET Core 3框架揭秘] 依赖注入[6]：服务注册&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-03-07.html&quot;&gt;[ASP.NET Core 3框架揭秘] 依赖注入[7]：服务消费&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-03-08.html&quot;&gt;[ASP.NET Core 3框架揭秘] 依赖注入[8]：服务实例的生命周期&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-03-09.html&quot;&gt;[ASP.NET Core 3框架揭秘] 依赖注入[9]：实现概述&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-03-10.html&quot;&gt;[ASP.NET Core 3框架揭秘] 依赖注入[10]：与第三方依赖注入框架的适配&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 11 Nov 2019 00:15:00 +0000</pubDate>
<dc:creator>Artech</dc:creator>
<og:description>毫不夸张地说，整个ASP.NET Core框架是建立在依赖注入框架之上的。ASP.NET Core应用在启动时构建管道以及利用该管道处理每个请求过程中使用到的服务对象均来源于依赖注入容器。该依赖注入容</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/artech/p/inside-asp-net-core-03-05.html</dc:identifier>
</item>
<item>
<title>【java基础】程序员你真的理解反射机制吗？ - 宜春</title>
<link>http://www.cnblogs.com/yichunguo/p/11832728.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yichunguo/p/11832728.html</guid>
<description>&lt;h2 id=&quot;section&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;很多讲解反射的博客文章并没有详细讲解Class类，&lt;sub&gt;当然包括之前的我也一样&lt;/sub&gt;，这样的文章只会让反射徒有其表，并不能让大多数初学者真正理解反射，而恰恰反射的原理就在于&lt;code&gt;Class&lt;/code&gt;对象！可见他的重要性，这篇文章我将总结一下关于&lt;code&gt;Class&lt;/code&gt;类的知识，可能还不是很全面，各位担待点哈QnQ，我之前也写过几篇关于反射的文章，主要是反射真的太重要了，现在重新总结一篇&lt;sub&gt;主要是前面总结的太潦草了&lt;/sub&gt;，对反射重新认识顺道再结合一些优秀文章再总结一下。&lt;/p&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;p&gt;JDK1.8_API.../docs/api/java/lang/Class.html&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.ibm.com/developerworks/cn/java/j-lo-classloader/&quot;&gt;http://www.ibm.com/developerworks/cn/java/j-lo-classloader/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/sinat_38259539/article/details/71799078&quot;&gt;https://blog.csdn.net/sinat_38259539/article/details/71799078&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;@[toc]&lt;/p&gt;
&lt;h2 id=&quot;section-1&quot;&gt;1、反射的概述&lt;/h2&gt;
&lt;p&gt;一句话定义反射就是在运行时才知道要操作的类是什么，并且可以在运行时获取类的完整构造，并调用对应的方法，所谓反射其实是获取类的字节码文件，也就是&lt;code&gt;.class&lt;/code&gt;文件。平时我们要调用某个类中的方法的时候都需要创建该类的对象，通过对象去调用类里面的方法，反射则是一开始并不知道我要初始化的类对象是什么，自然也无法使用 new 关键字来创建对象了，在这种情况下（没有创建对象）我们都能够对它的方法和属性进行调用，我们把这种&lt;span&gt;&lt;strong&gt;动态获取对象信息和调用对象方法的功能称之为反射机制&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;反射才体现出java是如何创建对象的。当java虚拟机(JVM)加载一个&lt;code&gt;class&lt;/code&gt;类文件时，就创建这个类的&lt;code&gt;class&lt;/code&gt;对象，以后的对象都是由这个&lt;code&gt;class&lt;/code&gt;对象创建的，所以同一个类的所有对象的&lt;code&gt;class&lt;/code&gt;对象都是一个，比如&lt;code&gt;A a=new A(); A b=new A()&lt;/code&gt;; &lt;code&gt;a.class()==b.class()&lt;/code&gt;返回&lt;code&gt;true&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;class&quot;&gt;2、正式使用反射之前很有必要了解的Class类&lt;/h2&gt;
&lt;p&gt;很多讲解反射的博客文章并没有详细讲解Class类，&lt;sub&gt;当然包括之前的我也一样&lt;/sub&gt;，这样的文章并不能让大多数初学者真正理解反射，而恰恰反射的原理就在于&lt;code&gt;Class&lt;/code&gt;对象！可见他的重要性，这篇文章我将总结一下关于&lt;code&gt;Class&lt;/code&gt;类的知识，可能还不是很全面，各位担待点哈~&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;首先，我要给初学者或者小白定位一下对Class类的理解。常用类有String类、Math类等等，这里的Class也是一个类似于String类、Math类等等的类，和我们随便创建的类的概念是有本质区别的，Class类位于&lt;code&gt;java.lang&lt;/code&gt;包下！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;大家到知道，一个类拥有成员变量、方法、构造方法、所在包、字段属性等等成分组成，而反射就是把java类中的各种成分映射成一个个的Java对象，可以理解为利用反射技术对一个类进行“解剖”，把各个组成部分映射成一个个的对象。其实，一个类中这些成员方法、构造方法、在加入类中都有一个&lt;code&gt;Class&lt;/code&gt;类来描述，在正式使用反射之前，很有必要先来了解了解这个&lt;code&gt;Class&lt;/code&gt;类！&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;反射的原理就在于&lt;code&gt;Class&lt;/code&gt;对象&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;section-2&quot;&gt;2.1、 普通类的加载过程&lt;/h4&gt;
&lt;p&gt;熟悉一下加载的时候：&lt;code&gt;Class&lt;/code&gt;对象的由来是将class文件读入内存，并为之创建一个&lt;code&gt;Class&lt;/code&gt;对象。反射的本质理解就是得到&lt;code&gt;Class&lt;/code&gt;对象后反向获取&lt;code&gt;Student&lt;/code&gt;对象的各种成分信息（成分信息包括成员变量、方法、构造方法、所在包、字段属性等等），下面就以Student对象为例，图解Student类的正常加载过程~ &lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/11/11/16e57cb6e56130d2?w=1244&amp;amp;h=514&amp;amp;f=png&amp;amp;s=142333&quot; alt=&quot;在这里插入图片描述&quot;/&gt; 可以看出图中这个Class对象很特殊。我们进一步了解一下这个Class类！&lt;/p&gt;
&lt;h4 id=&quot;classapi1.7api&quot;&gt;2.2、 分析Class类的API（1.7的API）&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/11/11/16e57cb6e55c32b1?w=1237&amp;amp;h=581&amp;amp;f=png&amp;amp;s=155287&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;Class 类的实例表示正在运行的 Java应用程序中的类和接口。也就是jvm中有N多的实例每个类都有该Class对象。（包括基本数据类型） Class 没有公共构造方法。Class对象是在加载类时由 Java 虚拟机以及通过调用类加载器中的defineClass方法自动构造的。&lt;strong&gt;也就是这不需要我们自己去处理创建Class对象，JVM已经帮我们创建好了。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;class-1&quot;&gt;2.3、 Class类的常用方法&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;Class&lt;/code&gt;类没有公共的构造方法，&lt;code&gt;JVM&lt;/code&gt;会自动帮我们创建好，但方法却共有64个，这里主要讲一下常用的方法。&lt;/p&gt;
&lt;p&gt;1、&lt;code&gt;getName()&lt;/code&gt; : 返回此 Class对象所表示的实体（类、接口、数组类、基本类型或 void）名称&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;一个Class对象描述了一个特定类的属性，Class类中最常用的方法getName以 String 的形式返回此 Class 对象所表示的实体（类、接口、数组类、基本类型或 void）名称。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;2、&lt;code&gt;newInstance()&lt;/code&gt;: 为类创建一个实例，但&lt;span&gt;&lt;strong&gt;只能&lt;/strong&gt;&lt;/span&gt;调用默认构造器（无参数构造器）&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;Class还有一个有用的方法可以为类创建一个实例，这个方法叫做newInstance()。例如： x.getClass.newInstance()，创建了一个同x一样类型的新实例。&lt;code&gt;newInstance()&lt;/code&gt;方法&lt;strong&gt;只能&lt;/strong&gt;调用默认构造器（无参数构造器）初始化新建对象。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;3、&lt;code&gt;getClassLoader()&lt;/code&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;getClassLoader() 方法主要返回该类的类加载器。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;4&lt;code&gt;、getComponentType()&lt;/code&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;getComponentType() 方法主要返回表示数组组件类型的 Class。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;5、&lt;code&gt;getSuperclass()&lt;/code&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;getSuperclass() 返回表示此 Class 所表示的实体（类、接口、基本类型或 void）的超类的 Class。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;6、&lt;code&gt;isArray()&lt;/code&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;isArray() 判定此 Class 对象是否表示一个数组类。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;需要注意一点的是，&lt;code&gt;forName&lt;/code&gt;和&lt;code&gt;newInstance&lt;/code&gt;结合起来使用【 &lt;code&gt;Class.forName()&lt;/code&gt;方法下面会单独讲解】，可以根据存储在字符串中的类名创建对象。例如&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;Object obj = Class.forName(s).newInstance();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;另外虚拟机为每种类型管理一个独一无二的&lt;code&gt;Class&lt;/code&gt;对象,也就是说&lt;code&gt;Class&lt;/code&gt;对象是&lt;span&gt;惟一&lt;/span&gt;的。因此可以使用==操作符来比较类对象。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;if(e.getClass() == Employee.class)…
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;class.forname&quot;&gt;2.4、 Class.forName()方法&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;Class.forName()&lt;/code&gt;是一种获取&lt;code&gt;Class&lt;/code&gt;对象的方法，而且是静态方法。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;code&gt;Class.forName()&lt;/code&gt;是一个静态方法，同样可以用来加载类，&lt;code&gt;Class.forName()&lt;/code&gt;返回与给定的字符串名称相关联类或接口的&lt;code&gt;Class&lt;/code&gt;对象。注意这是一种获取&lt;code&gt;Class&lt;/code&gt;对象的方法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;官方给出的API文档如下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;publicstatic Class&amp;lt;?&amp;gt; forName(String className)

Returns the Class object associated withthe class or interface with the given string name. Invokingthis method is equivalent to:

Class.forName(className,true, currentLoader)

where currentLoader denotes the definingclass loader of the current class.

For example, thefollowing code fragment returns the runtime Class descriptor for theclass named java.lang.Thread:

Class t =Class.forName(&quot;java.lang.Thread&quot;)

A call to forName(&quot;X&quot;) causes theclass named X to beinitialized.

Parameters:

className - the fully qualifiedname of the desired class.

Returns:

the Class object for the classwith the specified name.
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看出，&lt;code&gt;Class.forName(className)&lt;/code&gt;实际上是调用&lt;code&gt;Class.forName(className,true, this.getClass().getClassLoader())&lt;/code&gt;。第二个参数，是指&lt;code&gt;Class&lt;/code&gt;被&lt;code&gt;loading&lt;/code&gt;后是不是必须被初始化。可以看出，使用&lt;code&gt;Class.forName（className）&lt;/code&gt;加载类时则已初始化。&lt;span&gt;所以&lt;code&gt;Class.forName()&lt;/code&gt;方法可以简单的理解为：获得字符串参数中指定的类，并初始化该类。&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&quot;class-2&quot;&gt;2.5、关于Class类值得思考的问题&lt;/h4&gt;
&lt;p&gt;1.在初始化一个类，生成一个实例的时候，&lt;code&gt;newInstance()&lt;/code&gt;方法和&lt;code&gt;new&lt;/code&gt;关键字除了一个是方法，一个是关键字外，最主要有什么区别？&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;它们的区别在于创建对象的方式不一样，前者是使用类加载机制，后者是创建一个新类。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;2.那么为什么会有两种创建对象方式？&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;这主要考虑到软件的可伸缩、可扩展和可重用等软件设计思想。 Java中工厂模式经常使用&lt;code&gt;newInstance()&lt;/code&gt;方法来创建对象，因此从为什么要使用工厂模式上可以找到具体答案。例如下面代码&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;  class c = Class.forName(“Example”);  

factory = (ExampleInterface)c.newInstance();  
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中&lt;code&gt;ExampleInterface&lt;/code&gt;是&lt;code&gt;Example&lt;/code&gt;的接口，可以写成如下形式：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt; String className = “Example”;  

  class c = Class.forName(className);  

  factory = (ExampleInterface)c.newInstance();  
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;进一步可以写成如下形式：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt; String className = readfromXMlConfig;//从xml 配置文件中获得字符串

         class c = Class.forName(className);  

         factory = (ExampleInterface)c.newInstance();  
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面代码已经不存在&lt;code&gt;Example&lt;/code&gt;的类名称，它的优点是，无论&lt;code&gt;Example&lt;/code&gt;类怎么变化，上述代码不变，甚至可以更换&lt;code&gt;Example&lt;/code&gt;的兄弟类&lt;code&gt;Example2&lt;/code&gt; , &lt;code&gt;Example3&lt;/code&gt; , &lt;code&gt;Example4&lt;/code&gt;……，只要他们继承&lt;code&gt;ExampleInterface&lt;/code&gt;就可以。&lt;br/&gt;3.从JVM的角度看，我们使用关键字new创建一个类的时候，这个类可以没有被加载。 但是使用&lt;code&gt;newInstance()&lt;/code&gt;方法的时候，就必须保证：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;1、这个类已经加载； 2、这个类已经连接了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;而完成上面两个步骤的正是&lt;code&gt;Class&lt;/code&gt;的静态方法&lt;code&gt;forName()&lt;/code&gt;所完成的，这个静态方法调用了启动类加载器，即加载 &lt;code&gt;java API&lt;/code&gt;的那个加载器。 现在可以看出，&lt;code&gt;newInstance()&lt;/code&gt;实际上是把&lt;code&gt;new&lt;/code&gt;这个方式分解为两步，即首先调用&lt;code&gt;Class&lt;/code&gt;加载方法加载某个类，然后实例化。这样分步的好处是显而易见的。我们可以在调用&lt;code&gt;class&lt;/code&gt;的静态加载方法&lt;code&gt;forName&lt;/code&gt;时获得更好 的灵活性，提供给了一种&lt;strong&gt;降耦&lt;/strong&gt;的手段。&lt;/p&gt;
&lt;p&gt;4、加载数据库驱动的时候&lt;code&gt;Class.forName&lt;/code&gt;的一个很常见的用法是在加载数据库驱动的时候，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;Class.forName(&quot;com.gx.sqlserver.jdbc.SQLServerDriver&quot;);
Connection con=DriverManager.getConnection(&quot;jdbc:sqlserver://localhost:1433;DatabaseName==NP&quot;,&quot;jph&quot;,&quot;jph&quot;);    
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为什么在我们加载数据库驱动包的时候有的却没有调用&lt;code&gt;newInstance( )&lt;/code&gt;方法呢？即有的jdbc连接数据库的写法里是&lt;code&gt;Class.forName(xxx.xx.xx)&lt;/code&gt;;而有一些：&lt;code&gt;Class.forName(xxx.xx.xx).newInstance()&lt;/code&gt;，为什么会有这两种写法呢？&lt;/p&gt;
&lt;p&gt;刚才提到，&lt;code&gt;Class.forName(&quot; &quot;)&lt;/code&gt;的作用是要求&lt;code&gt;JVM&lt;/code&gt;查找并加载指定的类，如果在类中有静态初始化器的话，&lt;code&gt;JVM&lt;/code&gt;必然会执行该类的静态代码段。而在&lt;code&gt;JDBC&lt;/code&gt;规范中明确要求这个&lt;code&gt;Driver&lt;/code&gt;类必须向&lt;code&gt;DriverManager&lt;/code&gt;注册自己，即任何一个&lt;code&gt;JDBCDriver&lt;/code&gt;的&lt;code&gt;Driver&lt;/code&gt;类的代码都必须类似如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt; public classMyJDBCDriver implements Driver {
    static{
         DriverManager.registerDriver(new MyJDBCDriver());
       }
  } 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;既然在静态初始化器的中已经进行了注册，所以我们在使用&lt;code&gt;JDBC&lt;/code&gt;时只需要&lt;code&gt;Class.forName(XXX.XXX)&lt;/code&gt;;就可以了。&lt;/p&gt;
&lt;p&gt;5、最后用最简单的描述来区分&lt;code&gt;new&lt;/code&gt;关键字和&lt;code&gt;newInstance()&lt;/code&gt;方法的区别：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;newInstance&lt;/code&gt;: 弱类型。低效率。只能调用无参构造。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;new&lt;/code&gt;: 强类型。相对高效。能调用任何public构造。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;到这里，&lt;code&gt;Class&lt;/code&gt;类就差不多了，可以开始学习使用反射了。&lt;/p&gt;
&lt;h2 id=&quot;section-3&quot;&gt;3、反射的使用&lt;/h2&gt;
&lt;p&gt;在 &lt;code&gt;JDK&lt;/code&gt; 中，反射相关的 &lt;code&gt;API&lt;/code&gt; 可以分为下面几个方面：获取反射的 &lt;code&gt;Class&lt;/code&gt; 对象、通过反射创建类对象、通过反射获取类属性方法及构造器。&lt;/p&gt;
&lt;h4 id=&quot;class-3&quot;&gt;3.1、获取Class对象的三种方式&lt;/h4&gt;
&lt;p&gt;对于为什么第一步是获取Class对象，是因为我在前面讲到过反射的本质理解就是得到&lt;code&gt;Class&lt;/code&gt;对象后反向获取&lt;code&gt;Student&lt;/code&gt;对象的各种成分信息（成分信息包括成员变量、方法、构造方法、所在包、字段属性等等），所以反射的第一步是获取需要被反射的类的&lt;code&gt;Class&lt;/code&gt;对象。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;1、使用&lt;code&gt;Class.forName&lt;/code&gt; 静态方法。 当你知道该类的全路径名时，你可以使用该方法获取 Class 类对象&lt;span&gt;&lt;strong&gt;【最常用，必须掌握】&lt;/strong&gt;&lt;/span&gt; 2、使用 &lt;code&gt;.class&lt;/code&gt;方法。 这种方法只适合在编译前就知道操作的 Class，但是这种方法需要导入类的包，依赖性太强，所以用的比第一种稍微要少 【重点】 3、使用类对象的&lt;code&gt;getClass()&lt;/code&gt; 方法。 这种方法已经创建了对象，那么这个时候就不需要去进行反射了，显得有点多此一举。【&lt;strong&gt;不常用，了解即可&lt;/strong&gt;】&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;//第一种，使用Class.forName 静态方法。
Class Student= Class.forname(&quot;com.FanSe.Student&quot;);//类的全路径名

//第二种，使用 .class方法。
Class Student= 类名.class;//这种方法需要导入类的包，依赖性太强

//第三种，使用类对象的 getClass() 方法。
Student str = new Student();
Class clz = str.getClass();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;小结：开发中一般都用第一种&lt;code&gt;Class.forName&lt;/code&gt; 静态方法，可以一个字符串传入（类的全路径名）也可写在配置文件中等多种方法。而且需要注意的是在运行期间，一个类，只有一个Class对象产生。&lt;/p&gt;
&lt;h4 id=&quot;section-4&quot;&gt;3.2、反射获取构造方法并使用&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;1).批量获取构造方法：&lt;/strong&gt; public Constructor[] &lt;code&gt;getConstructors()&lt;/code&gt;：所有&quot;公有的&quot;构造方法&lt;/p&gt;
&lt;p&gt;public Constructor[] &lt;code&gt;getDeclaredConstructors()&lt;/code&gt;：获取所有的构造方法(包括私有、受保护、默认、公有)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2).获取单个的方法，并调用：&lt;/strong&gt; public Constructor &lt;code&gt;getConstructor(Class... parameterTypes)&lt;/code&gt;：获取单个的&quot;公有的&quot;构造方法： public Constructor &lt;code&gt;getDeclaredConstructor(Class... parameterTypes)&lt;/code&gt;：获取&quot;某个构造方法&quot;可以是私有的，或受保护、默认、公有；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3）调用构造方法：&lt;/strong&gt; &lt;code&gt;Constructor&lt;/code&gt;--&amp;gt;&lt;code&gt;newInstance&lt;/code&gt;(Object... initargs)&lt;/p&gt;
&lt;p&gt;&lt;code&gt;newInstance&lt;/code&gt;是 &lt;code&gt;Constructor&lt;/code&gt;类的方法（管理构造函数的类），&lt;code&gt;api&lt;/code&gt;的解释为：&lt;code&gt;newInstance&lt;/code&gt;(Object... initargs)，使用此 &lt;code&gt;Constructor&lt;/code&gt; 对象表示的构造方法来创建该构造方法的声明类的新实例，并用指定的初始化参数初始化该实例。它的返回值是&lt;code&gt;T&lt;/code&gt;类型，所以&lt;code&gt;newInstance&lt;/code&gt;是创建了一个构造方法的声明类的新实例对象。并为之调用。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;反射获取构造方法总结：当我们去获取类构造器时，如果要获取私有方法或私有构造器，则必须使用有 &lt;code&gt;declared&lt;/code&gt; 关键字的方法。【当然不止构造器，获取类方法、类属性也是一样使用 declared 关键字的方法】&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;下面开始进入实践代码阶段&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;创建一个普通Student 类&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;package fanshe;
 
public class Student {
        
        //---------------构造方法-------------------
        //（默认的构造方法）
        Student(String str){
                System.out.println(&quot;(默认)的构造方法 s = &quot; + str);
        }
        
        //无参构造方法
        public Student(){
                System.out.println(&quot;调用了公有、无参构造方法执行了。。。&quot;);
        }
        
        //有一个参数的构造方法
        public Student(char name){
                System.out.println(&quot;姓名：&quot; + name);
        }
        
        //有多个参数的构造方法
        public Student(String name ,int age){
                System.out.println(&quot;姓名：&quot;+name+&quot;年龄：&quot;+ age);//这的执行效率有问题，以后解决。
        }
        
        //受保护的构造方法
        protected Student(boolean n){
                System.out.println(&quot;受保护的构造方法 n = &quot; + n);
        }
        
        //私有构造方法
        private Student(int age){
                System.out.println(&quot;私有的构造方法   年龄：&quot;+ age);
        }
 
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;编写测试类&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;package fanshe;
 
import java.lang.reflect.Constructor;
 
 
/*
 * 通过Class对象可以获取某个类中的：构造方法、成员变量、成员方法；并访问成员；
 * 
 * 1.获取构造方法：
 *              1).批量的方法：
 *                      public Constructor[] getConstructors()：所有&quot;公有的&quot;构造方法
            public Constructor[] getDeclaredConstructors()：获取所有的构造方法(包括私有、受保护、默认、公有)
     
 *              2).获取单个的方法，并调用：
 *                      public Constructor getConstructor(Class... parameterTypes):获取单个的&quot;公有的&quot;构造方法：
 *                      public Constructor getDeclaredConstructor(Class... parameterTypes):获取&quot;某个构造方法&quot;可以是私有的，或受保护、默认、公有；
 *              
 *                      调用构造方法：
 *                      Constructor--&amp;gt;newInstance(Object... initargs)
 */
public class Constructors {
 
        public static void main(String[] args) throws Exception {
                //1.加载Class对象
                Class clazz = Class.forName(&quot;fanshe.Student&quot;);
                
                
                //2.获取所有公有构造方法
                System.out.println(&quot;**********************所有公有构造方法*********************************&quot;);
                Constructor[] conArray = clazz.getConstructors();
                for(Constructor c : conArray){
                        System.out.println(c);
                }
                
                
                System.out.println(&quot;************所有的构造方法(包括：私有、受保护、默认、公有)***************&quot;);
                conArray = clazz.getDeclaredConstructors();
                for(Constructor c : conArray){
                        System.out.println(c);
                }
                
                System.out.println(&quot;*****************获取公有、无参的构造方法*******************************&quot;);
                Constructor con = clazz.getConstructor(null);
                //1&amp;gt;、因为是无参的构造方法所以类型是一个null,不写也可以：这里需要的是一个参数的类型，切记是类型
                //2&amp;gt;、返回的是描述这个无参构造函数的类对象。
        
                System.out.println(&quot;con = &quot; + con);
                //调用构造方法
                Object obj = con.newInstance();
        //      System.out.println(&quot;obj = &quot; + obj);
        //      Student stu = (Student)obj;
                
                System.out.println(&quot;******************获取私有构造方法，并调用*******************************&quot;);
                con = clazz.getDeclaredConstructor(char.class);
                System.out.println(con);
                //调用构造方法
                con.setAccessible(true);//暴力访问(忽略掉访问修饰符)
                obj = con.newInstance('男');
        }
        
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试结果&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;**********************所有公有构造方法*********************************
public fanshe.Student(java.lang.String,int)
public fanshe.Student(char)
public fanshe.Student()
************所有的构造方法(包括：私有、受保护、默认、公有)***************
private fanshe.Student(int)
protected fanshe.Student(boolean)
public fanshe.Student(java.lang.String,int)
public fanshe.Student(char)
public fanshe.Student()
fanshe.Student(java.lang.String)
*****************获取公有、无参的构造方法*******************************
con = public fanshe.Student()
调用了公有、无参构造方法执行了。。。
******************获取私有构造方法，并调用*******************************
public fanshe.Student(char)
姓名：男

&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;section-5&quot;&gt;3.3、反射获取成员变量并调用&lt;/h4&gt;
&lt;p&gt;创建Student 类&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;package fanshe.field;
 
public class Student {
        public Student(){
                
        }
        //**********字段*************//
        public String name;
        protected int age;
        char sex;
        private String phoneNum;
        
        @Override
        public String toString() {
                return &quot;Student [name=&quot; + name + &quot;, age=&quot; + age + &quot;, sex=&quot; + sex
                                + &quot;, phoneNum=&quot; + phoneNum + &quot;]&quot;;
        }
        
        
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试类&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;package fanshe.field;
import java.lang.reflect.Field;
/*
 * 获取成员变量并调用：
 * 
 * 1.批量的
 *              1).Field[] getFields():获取所有的&quot;公有字段&quot;
 *              2).Field[] getDeclaredFields():获取所有字段，包括：私有、受保护、默认、公有；
 * 2.获取单个的：
 *              1).public Field getField(String fieldName):获取某个&quot;公有的&quot;字段；
 *              2).public Field getDeclaredField(String fieldName):获取某个字段(可以是私有的)
 * 
 *       设置字段的值：
 *              Field --&amp;gt; public void set(Object obj,Object value):
 *                                      参数说明：
 *                                      1.obj:要设置的字段所在的对象；
 *                                      2.value:要为字段设置的值；
 * 
 */
public class Fields {
 
                public static void main(String[] args) throws Exception {
                        //1.获取Class对象
                        Class stuClass = Class.forName(&quot;fanshe.field.Student&quot;);
                        //2.获取字段
                        System.out.println(&quot;************获取所有公有的字段********************&quot;);
                        Field[] fieldArray = stuClass.getFields();
                        for(Field f : fieldArray){
                                System.out.println(f);
                        }
                        System.out.println(&quot;************获取所有的字段(包括私有、受保护、默认的)********************&quot;);
                        fieldArray = stuClass.getDeclaredFields();
                        for(Field f : fieldArray){
                                System.out.println(f);
                        }
                        System.out.println(&quot;*************获取公有字段**并调用***********************************&quot;);
                        Field f = stuClass.getField(&quot;name&quot;);
                        System.out.println(f);
                        //获取一个对象
                        Object obj = stuClass.getConstructor().newInstance();//产生Student对象--》Student stu = new Student();
                        //为字段设置值
                        f.set(obj, &quot;刘德华&quot;);//为Student对象中的name属性赋值--》stu.name = &quot;刘德华&quot;
                        //验证
                        Student stu = (Student)obj;
                        System.out.println(&quot;验证姓名：&quot; + stu.name);
                        
                        
                        System.out.println(&quot;**************获取私有字段****并调用********************************&quot;);
                        f = stuClass.getDeclaredField(&quot;phoneNum&quot;);
                        System.out.println(f);
                        f.setAccessible(true);//暴力反射，解除私有限定
                        f.set(obj, &quot;18888889999&quot;);
                        System.out.println(&quot;验证电话：&quot; + stu);
                        
                }
        }

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试效果&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;************获取所有公有的字段********************
public java.lang.String fanshe.field.Student.name
************获取所有的字段(包括私有、受保护、默认的)********************
public java.lang.String fanshe.field.Student.name
protected int fanshe.field.Student.age
char fanshe.field.Student.sex
private java.lang.String fanshe.field.Student.phoneNum
*************获取公有字段**并调用***********************************
public java.lang.String fanshe.field.Student.name
验证姓名：刘德华
**************获取私有字段****并调用********************************
private java.lang.String fanshe.field.Student.phoneNum
验证电话：Student [name=刘德华, age=0, sex=

&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;由此可见，调用字段时：需要传递两个参数： Object obj =stuClass.getConstructor().newInstance();//产生Student对象--》Student stu = new Student(); //为字段设置值 f.set(obj, &quot;刘德华&quot;);//为Student对象中的name属性赋值--》stu.name = &quot;刘德华&quot; 第一个参数：要传入设置的对象，第二个参数：要传入实参&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;section-6&quot;&gt;3.4、反射获取成员方法并调用&lt;/h4&gt;
&lt;p&gt;创建student类&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;package fanshe.method;
 
public class Student {
        //**************成员方法***************//
        public void show1(String s){
                System.out.println(&quot;调用了：公有的，String参数的show1(): s = &quot; + s);
        }
        protected void show2(){
                System.out.println(&quot;调用了：受保护的，无参的show2()&quot;);
        }
        void show3(){
                System.out.println(&quot;调用了：默认的，无参的show3()&quot;);
        }
        private String show4(int age){
                System.out.println(&quot;调用了，私有的，并且有返回值的，int参数的show4(): age = &quot; + age);
                return &quot;abcd&quot;;
        }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;编写测试类&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;package fanshe.method;
 
import java.lang.reflect.Method;
 
/*
 * 获取成员方法并调用：
 * 
 * 1.批量的：
 *              public Method[] getMethods():获取所有&quot;公有方法&quot;；（包含了父类的方法也包含Object类）
 *              public Method[] getDeclaredMethods():获取所有的成员方法，包括私有的(不包括继承的)
 * 2.获取单个的：
 *              public Method getMethod(String name,Class&amp;lt;?&amp;gt;... parameterTypes):
 *                                      参数：
 *                                              name : 方法名；
 *                                              Class ... : 形参的Class类型对象
 *              public Method getDeclaredMethod(String name,Class&amp;lt;?&amp;gt;... parameterTypes)
 * 
 *       调用方法：
 *              Method --&amp;gt; public Object invoke(Object obj,Object... args):
 *                                      参数说明：
 *                                      obj : 要调用方法的对象；
 *                                      args:调用方式时所传递的实参；
):
 */
public class MethodClass {
 
        public static void main(String[] args) throws Exception {
                //1.获取Class对象
                Class stuClass = Class.forName(&quot;fanshe.method.Student&quot;);
                //2.获取所有公有方法
                System.out.println(&quot;***************获取所有的”公有“方法*******************&quot;);
                stuClass.getMethods();
                Method[] methodArray = stuClass.getMethods();
                for(Method m : methodArray){
                        System.out.println(m);
                }
                System.out.println(&quot;***************获取所有的方法，包括私有的*******************&quot;);
                methodArray = stuClass.getDeclaredMethods();
                for(Method m : methodArray){
                        System.out.println(m);
                }
                System.out.println(&quot;***************获取公有的show1()方法*******************&quot;);
                Method m = stuClass.getMethod(&quot;show1&quot;, String.class);
                System.out.println(m);
                //实例化一个Student对象
                Object obj = stuClass.getConstructor().newInstance();
                m.invoke(obj, &quot;刘德华&quot;);
                
                System.out.println(&quot;***************获取私有的show4()方法******************&quot;);
                m = stuClass.getDeclaredMethod(&quot;show4&quot;, int.class);
                System.out.println(m);
                m.setAccessible(true);//解除私有限定
                Object result = m.invoke(obj, 20);//需要两个参数，一个是要调用的对象（获取有反射），一个是实参
                System.out.println(&quot;返回值：&quot; + result);
                
                
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;***************获取所有的”公有“方法*******************
public void fanshe.method.Student.show1(java.lang.String)
public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException
public final native void java.lang.Object.wait(long) throws java.lang.InterruptedException
public final void java.lang.Object.wait() throws java.lang.InterruptedException
public boolean java.lang.Object.equals(java.lang.Object)
public java.lang.String java.lang.Object.toString()
public native int java.lang.Object.hashCode()
public final native java.lang.Class java.lang.Object.getClass()
public final native void java.lang.Object.notify()
public final native void java.lang.Object.notifyAll()
***************获取所有的方法，包括私有的*******************
public void fanshe.method.Student.show1(java.lang.String)
private java.lang.String fanshe.method.Student.show4(int)
protected void fanshe.method.Student.show2()
void fanshe.method.Student.show3()
***************获取公有的show1()方法*******************
public void fanshe.method.Student.show1(java.lang.String)
调用了：公有的，String参数的show1(): s = 刘德华
***************获取私有的show4()方法******************
private java.lang.String fanshe.method.Student.show4(int)
调用了，私有的，并且有返回值的，int参数的show4(): age = 20
返回值：abcd
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;由此可见： m = stuClass.getDeclaredMethod(&quot;show4&quot;, int.class);//调用制定方法（所有包括私有的），需要传入两个参数，第一个是调用的方法名称，第二个是方法的形参类型，切记是类型。 System.out.println(m); m.setAccessible(true);//解除私有限定 Object result = m.invoke(obj, 20);//需要两个参数，一个是要调用的对象（获取有反射），一个是实参 System.out.println(&quot;返回值：&quot; + result);&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;main&quot;&gt;3.5、 反射main方法&lt;/h4&gt;
&lt;p&gt;Student类&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;package fanshe.main;
 
public class Student {
 
        public static void main(String[] args) {
                System.out.println(&quot;main方法执行了。。。&quot;);
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;编写测试类&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;package fanshe.main;
 
import java.lang.reflect.Method;
 
/**
 * 获取Student类的main方法、不要与当前的main方法搞混了
 */
public class Main {
        
        public static void main(String[] args) {
                try {
                        //1、获取Student对象的字节码
                        Class clazz = Class.forName(&quot;fanshe.main.Student&quot;);
                        
                        //2、获取main方法
                         Method methodMain = clazz.getMethod(&quot;main&quot;, String[].class);//第一个参数：方法名称，第二个参数：方法形参的类型，
                        //3、调用main方法
                        // methodMain.invoke(null, new String[]{&quot;a&quot;,&quot;b&quot;,&quot;c&quot;});
                         //第一个参数，对象类型，因为方法是static静态的，所以为null可以，第二个参数是String数组，这里要注意在jdk1.4时是数组，jdk1.5之后是可变参数
                         //这里拆的时候将  new String[]{&quot;a&quot;,&quot;b&quot;,&quot;c&quot;} 拆成3个对象。。。所以需要将它强转。
                         methodMain.invoke(null, (Object)new String[]{&quot;a&quot;,&quot;b&quot;,&quot;c&quot;});//方式一
                        // methodMain.invoke(null, new Object[]{new String[]{&quot;a&quot;,&quot;b&quot;,&quot;c&quot;}});//方式二
                        
                } catch (Exception e) {
                        e.printStackTrace();
                }
                
                
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试结果&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;main方法执行了。。。
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;section-7&quot;&gt;3.6、反射方法的其它使用 ---通过反射运行配置文件内容&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;public class Student {
        public void show(){
                System.out.println(&quot;is show()&quot;);
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配置文件以txt文件为例子（pro.txt）：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;className = cn.fanshe.Student
methodName = show
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;demo类&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.lang.reflect.Method;
import java.util.Properties;
 
/*
 * 我们利用反射和配置文件，可以使：应用程序更新时，对源码无需进行任何修改
 * 我们只需要将新类发送给客户端，并修改配置文件即可
 */
public class Demo {
        public static void main(String[] args) throws Exception {
                //通过反射获取Class对象
                Class stuClass = Class.forName(getValue(&quot;className&quot;));//&quot;cn.fanshe.Student&quot;
                //2获取show()方法
                Method m = stuClass.getMethod(getValue(&quot;methodName&quot;));//show
                //3.调用show()方法
                m.invoke(stuClass.getConstructor().newInstance());
                
        }
        
        //此方法接收一个key，在配置文件中获取相应的value
        public static String getValue(String key) throws IOException{
                Properties pro = new Properties();//获取配置文件的对象
                FileReader in = new FileReader(&quot;pro.txt&quot;);//获取输入流
                pro.load(in);//将流加载到配置文件对象中
                in.close();
                return pro.getProperty(key);//返回根据key获取的value值
        }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;is show()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需求： 当我们升级这个系统时，不要Student类，而需要新写一个Student2的类时，这时只需要更改pro.txt的文件内容就可以了。代码就一点不用改动&lt;/p&gt;
&lt;p&gt;要替换的student2类：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;public class Student2 {
        public void show2(){
                System.out.println(&quot;is show2()&quot;);
        }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配置文件更改为：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;className = cn.fanshe.Student2
methodName = show2
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;控制台输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;is show2();
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;section-8&quot;&gt;3.7、反射方法的其它使用 ---通过反射越过泛型检查&lt;/h4&gt;
&lt;p&gt;泛型用在编译期，编译过后泛型擦除（消失掉）。所以是可以通过反射越过泛型检查的 测试类：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;import java.lang.reflect.Method;
import java.util.ArrayList;
 
/*
 * 通过反射越过泛型检查
 * 
 * 例如：有一个String泛型的集合，怎样能向这个集合中添加一个Integer类型的值？
 */
public class Demo {
        public static void main(String[] args) throws Exception{
                ArrayList&amp;lt;String&amp;gt; strList = new ArrayList&amp;lt;&amp;gt;();
                strList.add(&quot;aaa&quot;);
                strList.add(&quot;bbb&quot;);
                
        //      strList.add(100);
                //获取ArrayList的Class对象，反向的调用add()方法，添加数据
                Class listClass = strList.getClass(); //得到 strList 对象的字节码 对象
                //获取add()方法
                Method m = listClass.getMethod(&quot;add&quot;, Object.class);
                //调用add()方法
                m.invoke(strList, 100);
                
                //遍历集合
                for(Object obj : strList){
                        System.out.println(obj);
                }
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;控制台输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;aaa
bbb
100
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我的反射的另一篇文章&lt;a href=&quot;https://blog.csdn.net/qq_44543508/article/details/95098363#font_colorred_Constructor__newInstance_font_164&quot;&gt;Java基础重点——反射机制入门、使用&lt;/a&gt; ，写的不怎好，不过也可以参照对比着看看，还是不错的。&lt;/p&gt;
&lt;p&gt;最后，欢迎各位关注我的公众号，一起探讨技术，向往技术，追求技术，说好了来了就是盆友喔...&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/11/7/16e434427587000f?w=430&amp;amp;h=430&amp;amp;f=png&amp;amp;s=94196&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 11 Nov 2019 00:12:00 +0000</pubDate>
<dc:creator>宜春</dc:creator>
<og:description>前言 很多讲解反射的博客文章并没有详细讲解Class类，~当然包括之前的我也一样~，这样的文章只会让反射徒有其表，并不能让大多数初学者真正理解反射，而恰恰反射的原理就在于 对象！可见他的重要性，这篇文</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yichunguo/p/11832728.html</dc:identifier>
</item>
<item>
<title>基于 Jenkins Pipeline 自动化部署 - 后端进阶</title>
<link>http://www.cnblogs.com/objcoding/p/11832669.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/objcoding/p/11832669.html</guid>
<description>&lt;p&gt;最近在公司推行Docker Swarm集群的过程中，需要用到Jenkins来做自动化部署，Jenkins实现自动化部署有很多种方案，可以直接在jenkins页面写Job，把一些操作和脚本都通过页面设置，也可以在每个项目中直接写Pipeline脚本，但像我那么优秀，那么追求极致的程序员来说，这些方案都打动不了我那颗骚动的心，下面我会跟你们讲讲我是如何通过Pipeline脚本实现自动化部署方案的，并且实现多分支构建，还实现了所有项目共享一个Pipeline脚本。&lt;/p&gt;
&lt;h2 id=&quot;使用jenkins前的一些设置&quot;&gt;使用Jenkins前的一些设置&lt;/h2&gt;
&lt;p&gt;为了快速搭建Jenkins，我这里使用Docker安装运行Jenkins：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ sudo docker run -it -d \
  --rm \
  -u root \
  -p 8080:8080 \
  -v jenkins-data:/var/jenkins_home \
  -v /var/run/docker.sock:/var/run/docker.sock \
  -v &quot;$HOME&quot;:/home \
  --name jenkins jenkinsci/blueocean&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;初次使用jenkins，进入Jenkins页面前，需要密码验证，我们需要进入docker容器查看密码：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ sudo docker exec -it jenkins /bin/bash
$ vi /var/jenkins_home/secrets/initialAdminPassword&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Docker安装的Jenkins稍微有那么一点缺陷，shell版本跟CenOS宿主机的版本不兼容，这时我们需要进入Jenkins容器手动设置shell：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ sudo docker exec -it jenkins /bin/bash
$ ln -sf /bin/bash /bin/sh&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于我们的Pipeline还需要在远程服务器执行任务，需要通过ssh连接，那么我们就需要在Jenkins里面生成ssh的公钥密钥：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ sudo docker exec -it jenkins /bin/bash
$ ssh-keygen -C &quot;root@jenkins&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在远程节点的~/.ssh/authorized_keys中添加jenkins的公钥（id_rsa.pub）&lt;/p&gt;
&lt;p&gt;还需要安装一些必要的插件：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Pipeline Maven Integration&lt;/li&gt;
&lt;li&gt;SSH Pipeline Steps&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;安装完插件后，还需要去全局工具那里添加maven：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1860306/201911/1860306-20191111070856578-49508002.png&quot; alt=&quot;maven&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里后面Jenkinsfile有用到。&lt;/p&gt;
&lt;h2 id=&quot;mutibranch多分支构建&quot;&gt;mutiBranch多分支构建&lt;/h2&gt;
&lt;p&gt;由于我们的开发是基于多分支开发，每个开发环境都对应有一条分支，所以普通的Pipeline自动化构建并不能满足现有的开发部署需求，所以我们需要使用Jenkins的mutiBranch Pipeline。&lt;/p&gt;
&lt;p&gt;首先当然是新建一个mutiBranch多分支构建job：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1860306/201911/1860306-20191111070857998-1360615483.png&quot; alt=&quot;maven&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接着设置分支源，分支源就是你项目的git地址，选择Jenkinsfile在项目的路径&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1860306/201911/1860306-20191111070858447-1556691748.png&quot; alt=&quot;maven&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来Jenkins会在分支源中扫描每个分支下的Jenkinsfile，如果该分支下有Jenkinsfile，那么就会创建一个分支Job&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1860306/201911/1860306-20191111070859619-152723008.png&quot; alt=&quot;maven&quot;/&gt;&lt;/p&gt;
&lt;p&gt;该job下的分支job如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1860306/201911/1860306-20191111070900733-1284289666.png&quot; alt=&quot;maven&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这里需要注意的是，只有需要部署的分支，才加上Jenkinsfile，不然Jenkins会将其余分支也创建一个分支job。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;通用化pipeline脚本&quot;&gt;通用化Pipeline脚本&lt;/h2&gt;
&lt;p&gt;到这里之前，基本就可以基于Pipeline脚本自动化部署了，但如果你是一个追求极致，不甘于平庸的程序员，你一定会想，随着项目的增多，Pipeline脚本不断增多，这会造成越来越大的维护成本，随着业务的增长，难免会在脚本中修改东西，这就会牵扯太多Pipeline脚本了，而且这些脚本基本都相同，那么对于我这么优秀的程序员，怎么会想不到这个问题呢，我第一时间就想到通用化pipeline脚本。所幸，Jenkins已经看出了我不断骚动的心了，Jenkins甩手就给我一个Shared Libraries。&lt;/p&gt;
&lt;p&gt;Shared Libraries是什么呢？顾名思义，它就是一个共享库，它的主要作用是用于将通用的Pipeline脚本放在一个地方，其它项目可以从它那里获取到一个全局通用化的Pipeline脚本，项目之间通过不通的变量参数传递，达到通用化的目的。&lt;/p&gt;
&lt;p&gt;接下来我们先创建一个用于存储通用Pipeline脚本的git仓库：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1860306/201911/1860306-20191111070901856-38061923.png&quot; alt=&quot;maven&quot;/&gt;&lt;/p&gt;
&lt;p&gt;仓库目录不是随便乱添加了，Jenkins有一个严格的规范，下面是官方说明：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1860306/201911/1860306-20191111070903528-690806094.png&quot; alt=&quot;maven&quot;/&gt;&lt;/p&gt;
&lt;p&gt;官方已经讲得很清楚了，大概意思就是vars目录用于存储通用Pipeline脚本，resources用于存储非Groovy文件。所以我这里就把Pipeline需要的构建脚本以及编排文件都集中放在这里，完全对业务工程师隐蔽，这样做的目的就是为了避免业务工程师不懂瞎几把乱改，导致出bug。&lt;/p&gt;
&lt;p&gt;创建完git仓库后，我们还需要在jenkins的&lt;code&gt;Manage Jenkins » Configure System » Global Pipeline Libraries&lt;/code&gt;中定义全局库：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1860306/201911/1860306-20191111070905240-486567791.png&quot; alt=&quot;maven&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里的name，可以在jenkinsfile中通过以下命令引用：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;@Library 'objcoding-pipeline-library'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面我们来看通用Pipeline脚本的编写规则：&lt;/p&gt;
&lt;pre class=&quot;groovy&quot;&gt;
&lt;code&gt;#!groovy

def getServer() {
    def remote = [:]
    remote.name = 'manager node'
    remote.user = 'dev'
    remote.host = &quot;${REMOTE_HOST}&quot;
    remote.port = 22
    remote.identityFile = '/root/.ssh/id_rsa'
    remote.allowAnyHosts = true
    return remote
}

def call(Map map) {

    pipeline {
        agent any

        environment {
            REMOTE_HOST = &quot;${map.REMOTE_HOST}&quot;
            REPO_URL = &quot;${map.REPO_URL}&quot;
            BRANCH_NAME = &quot;${map.BRANCH_NAME}&quot;
            STACK_NAME = &quot;${map.STACK_NAME}&quot;
            COMPOSE_FILE_NAME = &quot;docker-compose-&quot; + &quot;${map.STACK_NAME}&quot; + &quot;-&quot; + &quot;${map.BRANCH_NAME}&quot; + &quot;.yml&quot;
        }

        stages {
            stage('获取代码') {
                steps {
                    git([url: &quot;${REPO_URL}&quot;, branch: &quot;${BRANCH_NAME}&quot;])
                }
            }

            stage('编译代码') {
                steps {
                    withMaven(maven: 'maven 3.6') {
                        sh &quot;mvn -U -am clean package -DskipTests&quot;
                    }
                }
            }

            stage('构建镜像') {
                steps {
                    sh &quot;wget -O build.sh https://git.x-vipay.com/docker/jenkins-pipeline-library/raw/master/resources/shell/build.sh&quot;
                    sh &quot;sh build.sh ${BRANCH_NAME} &quot;
                }
            }

            stage('init-server') {
                steps {
                    script {
                        server = getServer()
                    }
                }
            }

            stage('执行发版') {
                steps {
                    writeFile file: 'deploy.sh', text: &quot;wget -O ${COMPOSE_FILE_NAME} &quot; +
                        &quot; https://git.x-vipay.com/docker/jenkins-pipeline-library/raw/master/resources/docker-compose/${COMPOSE_FILE_NAME} \n&quot; +
                        &quot;sudo docker stack deploy -c ${COMPOSE_FILE_NAME} ${STACK_NAME}&quot;
                    sshScript remote: server, script: &quot;deploy.sh&quot;
                }
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;由于我们需要在远程服务器执行任务，所以定义一个远程服务器的信息其中&lt;code&gt;remote.identityFile&lt;/code&gt;就是我们上面在容器生成的密钥的地址；&lt;/li&gt;
&lt;li&gt;定义一个call()方法，这个方法用于在各个项目的Jenkinsfile中调用，注意一定得叫call；&lt;/li&gt;
&lt;li&gt;在call()方法中定义一个pipeline；&lt;/li&gt;
&lt;li&gt;environment参数即是可变通用参数，通过传递参数Map来给定值，该Map是从各个项目中定义的传参；&lt;/li&gt;
&lt;li&gt;接下来就是一顿步骤操作啦，“编译代码”这步骤需要填写上面我们在全局工具类设置的maven，“构建镜像”的构建脚本巧妙地利用wget从本远程仓库中拉取下来，”执行发版“的编排文件也是这么做，“init-server”步骤主要是初始化一个server对象，供“执行发版使用”。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;从脚本看出来Jenkins将来要推崇的一种思维：配置即代码。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;写完通用Pipeline脚本后，接下来我们就需要在各个项目的需要自动化部署的分支的根目录下新建一个Jenkinsfile脚本了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1860306/201911/1860306-20191111070905771-1093728160.png&quot; alt=&quot;maven&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来我来解释一下Jenkinsfile内容：&lt;/p&gt;
&lt;pre class=&quot;groovy&quot;&gt;
&lt;code&gt;#!groovy

// 在多分支构建下，严格规定Jenkinsfile只存在可以发版的分支上

// 引用在jenkins已经全局定义好的library
library 'objcoding-pipeline-library'
def map = [:]

// 远程管理节点地址（用于执行发版）
map.put('REMOTE_HOST','xxx.xx.xx.xxx')
// 项目gitlab代码地址
map.put('REPO_URL','https://github.com/objcoding/docker-jenkins-pipeline-sample.git')
// 分支名称
map.put('BRANCH_NAME','master')
// 服务栈名称
map.put('STACK_NAME','vipay')

// 调用library中var目录下的build.groovy脚本
build(map)&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;通过&lt;code&gt;library 'objcoding-pipeline-library'&lt;/code&gt;引用我们在Jenkins定义的全局库，定义一个map参数；&lt;/li&gt;
&lt;li&gt;接下来就是将项目具体的参数保存到map中，调用build()方法传递给通用Pipeline脚本。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Shared Libraries共享库极大地提升了Pipeline脚本的通用性，避免了脚本过多带来的问题，也符合了一个优秀程序员的审美观，如果你是一个有追求的程序员，你一定会爱上它。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1860306/201911/1860306-20191111070908171-1716522622.png&quot; alt=&quot;maven&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;更多精彩文章请关注作者维护的公众号「后端进阶」，这是一个专注后端相关技术的公众号。&lt;br/&gt;关注公众号并回复「后端」免费领取后端相关电子书籍。&lt;br/&gt;欢迎分享，转载请保留出处。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1860306/201911/1860306-20191107010000897-1336452455.jpg&quot; alt=&quot;公众号「后端进阶」，专注后端技术分享！&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 10 Nov 2019 23:09:00 +0000</pubDate>
<dc:creator>后端进阶</dc:creator>
<og:description>最近在公司推行Docker Swarm集群的过程中，需要用到Jenkins来做自动化部署，Jenkins实现自动化部署有很多种方案，可以直接在jenkins页面写Job，把一些操作和脚本都通过页面设置</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/objcoding/p/11832669.html</dc:identifier>
</item>
<item>
<title>工作半年就迷茫，给你一盏明灯 - 沉默王二</title>
<link>http://www.cnblogs.com/qing-gee/p/11832646.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qing-gee/p/11832646.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;大神，前端工作半年了，学的很迷茫，总感觉不知道怎么去自学，看书吸收能力差，可以给迷茫的人一点您的宝贵意见吗？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;前几天，小伙伴星星微信我说了上面这段话。&lt;/p&gt;
&lt;p&gt;首先呢，纠正两点，我不是大神，我真的不是，顶多是个大佬（皮一下）；我对星星你没有任何意见哦，要有的话，也只是一点点建议，仅供参考哈。&lt;/p&gt;
&lt;p&gt;其次呢，说实话，工作半年，迷茫的有点早啊。就我所知，刚入职的年轻人都喜欢热火朝天地干，就像刚刚交往的恋人一样，投入的很呢。难道说对工作不爱了？&lt;/p&gt;
&lt;h3 id=&quot;先开一剂药&quot;&gt;01、先开一剂药&lt;/h3&gt;
&lt;p&gt;针对前端来说，掘金是一个绝佳的学习网站，里面的大牛每天都会推各种学习的路线。我特意花了一上午的时间找了几个。&lt;/p&gt;
&lt;p&gt;1）&lt;a href=&quot;https://juejin.im/post/5d8989296fb9a06b1f147070&quot;&gt;前端开发中79条不可忽视的知识点汇总&lt;/a&gt;，这篇文章截止到目前共获得了 1494 个赞。&lt;/p&gt;
&lt;p&gt;2）&lt;a href=&quot;https://juejin.im/post/5d3a6d9e51882570d50f5566&quot;&gt;解密初、中、高级程序员的进化之路（前端）&lt;/a&gt;，这篇文章截止到目前共获得了 1406 个赞。&lt;/p&gt;
&lt;p&gt;3）&lt;a href=&quot;https://juejin.im/post/5d387f696fb9a07eeb13ea60&quot;&gt;一个合格(优秀)的前端都应该阅读这些文章&lt;/a&gt;，这篇文章截止到目前共获得了 4854 个赞。&lt;/p&gt;
&lt;p&gt;4）&lt;a href=&quot;https://juejin.im/post/5d23e750f265da1b855c7bbe&quot;&gt;前端 100 问：能搞懂 80% 的请把简历给我&lt;/a&gt;，这篇文章截止到目前共获得了 6006 个赞。&lt;/p&gt;
&lt;p&gt;5）&lt;a href=&quot;https://juejin.im/post/5d0878aaf265da1b83338f74&quot;&gt;8年前端开发的知识点沉淀&lt;/a&gt;，这篇文章截止到目前共获得了 1801 个赞。&lt;/p&gt;
&lt;p&gt;6）&lt;a href=&quot;https://juejin.im/post/5cc1da82f265da036023b628&quot;&gt;一名【合格】前端工程师的自检清单&lt;/a&gt;，这篇文章截止到目前共获得了 4144 个赞。&lt;/p&gt;
&lt;p&gt;还有很多，我就不再一一列举了。这 6 篇文章包罗万象，里面的前端知识点足够你学习一段时间了，再贪多就嚼不烂了。&lt;/p&gt;
&lt;h3 id=&quot;再来点偏方&quot;&gt;02、再来点偏方&lt;/h3&gt;
&lt;p&gt;在我看来，自学最有效的方法就是照葫芦画瓢，别看不起啊。&lt;/p&gt;
&lt;p&gt;在我初入职场的时候，本事真没多少，唯一能拿得出手的就是抄。领导安排的任务，不会做，怎么办？面向搜索引擎编程啊，找到解决方案就开始搬砖。&lt;/p&gt;
&lt;p&gt;任务完成的空闲时间里，怎么有效地提升自己呢？就去各种编程网站上抄人家提供的例子。早年我就是照着编程入门网的 demo 一个个的敲，敲出一个聊天室（前端 Flex，后端 Java，Socket 通信）都觉得无比的兴奋。可惜时过境迁，这个网站已经不存在了。&lt;/p&gt;
&lt;p&gt;别耻笑我这种没有创意的做法，人丫的天生不都是模仿着长大吗？从小学说话，照着大人的嘴跟读就行了，发音不准确没关系，随着时间的推移，慢慢就好了。&lt;/p&gt;
&lt;p&gt;学习也是这个道理，尤其是针对职场的新人来说，别怕丢人，就一心一意的模仿，照着 demo 抄。&lt;/p&gt;
&lt;p&gt;和我当时一块参加工作的新人有好几个，其中一个叫惠惠的关系还不错。但是他很看不惯我这种没技术含量的做法，经常调侃我说，“你丫这样照着抄有意思吗？”&lt;/p&gt;
&lt;p&gt;为了他能挂住点面子，我嘴上没回他。心里就默默地骂他了：“别特么眼高手低了，行不，就你那点‘一瓶子不满半瓶子晃荡’的水准，哪有资格来调侃我？”&lt;/p&gt;
&lt;p&gt;总之，不为他的调侃烦恼，依然我行我素。你以为照抄很容易吗？说句良心话，就算是照抄，也经常抄不出人家文章中的效果，不信我举个例子给你看。&lt;/p&gt;
&lt;p&gt;前端代码已经好久没写了，就举个后端代码的例子吧。我之前在学习 Java 的 fail-fast 机制的时候，看到 Hollis 大神的一篇文章，里面有这样一段代码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;List&amp;lt;String&amp;gt; userNames = new ArrayList&amp;lt;String&amp;gt;() {{
    add(&quot;Hollis&quot;);
    add(&quot;hollis&quot;);
    add(&quot;HollisChuang&quot;);
    add(&quot;H&quot;);
}};

for (String userName : userNames) {
    if (userName.equals(&quot;Hollis&quot;)) {
        userNames.remove(userName);
    }
}

System.out.println(userNames);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我就抄到我本地，稍微做了点改动：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
list.add(&quot;沉默王二&quot;);
list.add(&quot;一个文章真特么有趣的程序员&quot;);

for (String str : list) {
    if (&quot;沉默王二&quot;.equals(str)) {
        list.remove(str);
    }
}

System.out.println(list);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;两段代码差别不大吧！但是运行的结果却完全不同，第一段代码会抛出异常。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Exception in thread &quot;main&quot; java.util.ConcurrentModificationException
    at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:901)
    at java.util.ArrayList$Itr.next(ArrayList.java:851)
    at com.cmower.java_demo.str.Cmower7.main(Cmower7.java:16)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第二个代码就不会。当时我就纳闷了，难道 Hollis 大神的文章写错了？我还准备在他文章底部留言提醒他一下呢，结果我翻看了源码以后明白了。&lt;/p&gt;
&lt;p&gt;你看，照抄这么简单的代码都能出问题，还逼着我去研究了一番 ArrayList 的源码，还真的学到了很多之前不曾了解过的知识点。知道怎么自学了吧！&lt;/p&gt;
&lt;h3 id=&quot;再来点秘方&quot;&gt;03、再来点秘方&lt;/h3&gt;
&lt;p&gt;良心话，市面上很多技术书都特别枯燥无味，看这些书的时间，还真的不如玩一把俄罗斯方块（wang zhe nong yao）。书名叫啥我就不方便透露了，给作者或者译者留点面子。&lt;/p&gt;
&lt;p&gt;那难道就无书可读了，那难道就放弃读书了，不是宋朝有句流行诗叫做：“书中自有黄金屋，书中自有颜如玉”嘛？&lt;/p&gt;
&lt;p&gt;书当然要读，但读书要讲究点方法，不然真的很难吸收啊。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1）看视频&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;汲取知识的方法有很多种，看书只是其中的一种。记得我刚开始学习编程的时候，看书就看不进去，看一会就跑神。&lt;/p&gt;
&lt;p&gt;当时学校图书馆有各种《21 天学会 XXX》的书，看起来真心痛苦，感觉就像在啃一块发霉的石头。那时候也没有前辈列一些优质的书单，或者说列了我不知道。&lt;/p&gt;
&lt;p&gt;但是呢，那时候马士兵老师和李兴华老师的课程很流行，大家伙都看这个，我也跟着看。我尤其钟爱李兴华老师，讲课讲得风生水起，比听易中天品三国都带劲。李兴华老师还有一个特色，就是打字竟然用的是智能 ABC，但是，打字那叫一个迅速、流畅，作为观众的我由衷的佩服。&lt;/p&gt;
&lt;p&gt;为了向偶像致敬，我甚至卸载了最爱的谷歌拼音输入法，也改成智能 ABC，硬生生撑了两个月，最后......没撑下去，换回了谷歌拼音输入法。&lt;/p&gt;
&lt;p&gt;看视频学习有什么好处呢，就是注意力可以高度集中，用一个专业的成语形容一下——聚精会神。&lt;/p&gt;
&lt;p&gt;那去哪里找这些优质的、紧跟时代的高清教学视频呢？&lt;/p&gt;
&lt;p&gt;好朋友“江南一点雨”给了我一份，价值连城啊，这一套视频包罗万象（大前端的有“HTML5 新特性”、“AngularJS 视频教程”、“NodeJS 视频教程”、“React 视频教程”、“Vue 项目实战视频”、“JavaScript140 集”），已经分门别类好，大家可以根据索引按需下载（关注公众号后，回复“免费视频”即可查看索引）。&lt;/p&gt;
&lt;p&gt;2）正确的读书方法&lt;/p&gt;
&lt;p&gt;去年的时候，我读了这样一套书，系列名叫做《大师带你学语文》，里面提到的几种读书方法，我觉得非常有用，再次推荐给大家。&lt;/p&gt;
&lt;p&gt;①、泛读&lt;/p&gt;
&lt;p&gt;泛读可不是指泛泛而读，而是要博众家之长，开拓思路，广泛涉猎各方面的书。比如说，一名前端程序员最好也要读一读《软技能》、《代码大全》、《代码整洁之道》这类书。&lt;/p&gt;
&lt;p&gt;②、精读&lt;/p&gt;
&lt;p&gt;有些知识是要反复琢磨、反复研究的，务求明白透彻，了解于心，以便吸取精华。比如一些算法、设计模式方面的书。我读过的《趣学算法》、《设计模式之禅》。&lt;/p&gt;
&lt;p&gt;③、跳读&lt;/p&gt;
&lt;p&gt;这是一种跳跃式的读书方法。可以把书中无关紧要的内容放在一边，抓住书的筋骨脉络阅读。有时候遇到反复思考不得其解的内容时，可以跳过去，等后面的读完了再回头读，说不定就前后贯通了。如果整本书都跳过了，说明这本书就要先束之高阁了。&lt;/p&gt;
&lt;p&gt;④、写读&lt;/p&gt;
&lt;p&gt;俗话说得好，“好记性不如烂笔头”。读书的时候能把重要的知识摘选出来，然后写心得，这样不仅能积累大量的材料，而且能有效地提高写作水平，更重要的是能够提高读书的吸收能力。&lt;/p&gt;
&lt;p&gt;老读者可能比较清楚，我很多文章的写作灵感都来源于读书。我在读书的时候，其实就是在寻找一个写作题材，或者说找到命题作文的题目，然后准备素材，最后文章写完后，发现自己把所有的知识点都掌握了。&lt;/p&gt;
&lt;h3 id=&quot;最后的银弹&quot;&gt;04、最后的银弹&lt;/h3&gt;
&lt;p&gt;我敢赌一块钱，所有的人都会经历迷茫期。处在迷茫期的人最需要什么呢？&lt;/p&gt;
&lt;p&gt;绝不是劈头盖脸的批评和嘲讽，比如说，你咋这么不上进呢？你竟然还有时间迷茫，真了不起。&lt;/p&gt;
&lt;p&gt;迷茫的人需要一盏明灯，或者说需要一位亦师亦友的朋友。我非常期待能够成为你的朋友。&lt;/p&gt;
&lt;p&gt;以上就是我给星星的一点点建议，仅供参考哈。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;谢谢大家的阅读，原创不易，喜欢就随手点个赞，这将是我最强的写作动力。如果你觉得文章对你有所帮助，也蛮有趣的，就关注一下我的微信公众号「&lt;strong&gt;沉默王二&lt;/strong&gt;」，拜谢。&lt;/p&gt;
</description>
<pubDate>Sun, 10 Nov 2019 22:17:00 +0000</pubDate>
<dc:creator>沉默王二</dc:creator>
<og:description>大神，前端工作半年了，学的很迷茫，总感觉不知道怎么去自学，看书吸收能力差，可以给迷茫的人一点您的宝贵意见吗？ 前几天，小伙伴星星微信我说了上面这段话。 首先呢，纠正两点，我不是大神，我真的不是，顶多是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qing-gee/p/11832646.html</dc:identifier>
</item>
<item>
<title>Spring Boot 2.x实战之StateMachine - javaadu</title>
<link>http://www.cnblogs.com/javaadu/p/11832581.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/javaadu/p/11832581.html</guid>
<description>&lt;blockquote readability=&quot;2.2727272727273&quot;&gt;
&lt;p&gt;本文首发于个人网站：&lt;a href=&quot;http://www.javaadu.online/?p=655&quot;&gt;Spring Boot 2.x实战之StateMachine&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Spring StateMachine是一个状态机框架，在Spring框架项目中，开发者可以通过简单的配置就能获得一个业务状态机，而不需要自己去管理状态机的定义、初始化等过程。今天这篇文章，我们通过一个案例学习下Spring StateMachine框架的用法。&lt;/p&gt;
&lt;h2 id=&quot;案例介绍&quot;&gt;案例介绍&lt;/h2&gt;
&lt;p&gt;假设在一个业务系统中，有这样一个对象，它有三个状态：草稿、待发布、发布完成，针对这三个状态的业务动作也比较简单，分别是：上线、发布、回滚。该业务状态机如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/721786/201911/721786-20191111012712622-634591325.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;实战&quot;&gt;实战&lt;/h2&gt;
&lt;p&gt;接下来，基于上面的业务状态机进行Spring StateMachine的演示。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;创建一个基础的Spring Boot工程，在主pom文件中加入Spring StateMachine的依赖：&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;
  &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;
  &amp;lt;parent&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;2.2.1.RELEASE&amp;lt;/version&amp;gt;
    &amp;lt;relativePath/&amp;gt; &amp;lt;!-- lookup parent from repository --&amp;gt;
  &amp;lt;/parent&amp;gt;
  &amp;lt;groupId&amp;gt;online.javaadu&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;statemachinedemo&amp;lt;/artifactId&amp;gt;
  &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt;
  &amp;lt;name&amp;gt;statemachinedemo&amp;lt;/name&amp;gt;
  &amp;lt;description&amp;gt;Demo project for Spring Boot&amp;lt;/description&amp;gt;

  &amp;lt;properties&amp;gt;
    &amp;lt;java.version&amp;gt;1.8&amp;lt;/java.version&amp;gt;
  &amp;lt;/properties&amp;gt;

  &amp;lt;dependencies&amp;gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;spring-boot-starter&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;org.projectlombok&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;lombok&amp;lt;/artifactId&amp;gt;
      &amp;lt;optional&amp;gt;true&amp;lt;/optional&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
      &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
      &amp;lt;exclusions&amp;gt;
        &amp;lt;exclusion&amp;gt;
          &amp;lt;groupId&amp;gt;org.junit.vintage&amp;lt;/groupId&amp;gt;
          &amp;lt;artifactId&amp;gt;junit-vintage-engine&amp;lt;/artifactId&amp;gt;
        &amp;lt;/exclusion&amp;gt;
      &amp;lt;/exclusions&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;!--加入spring statemachine的依赖--&amp;gt;
        &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.statemachine&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-statemachine-core&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;2.1.3.RELEASE&amp;lt;/version&amp;gt;
      &amp;lt;/dependency&amp;gt;
  &amp;lt;/dependencies&amp;gt;

  &amp;lt;build&amp;gt;
    &amp;lt;plugins&amp;gt;
      &amp;lt;plugin&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;
      &amp;lt;/plugin&amp;gt;
    &amp;lt;/plugins&amp;gt;
  &amp;lt;/build&amp;gt;

&amp;lt;/project&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;定义状态枚举和事件枚举，代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
* 状态枚举
**/
public enum States {
    DRAFT,
    PUBLISH_TODO,
    PUBLISH_DONE,
}

/**
* 事件枚举
**/
public enum Events {
    ONLINE,
    PUBLISH,
    ROLLBACK
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;完成状态机的配置，包括：（1）状态机的初始状态和所有状态；（2）状态之间的转移规则&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Configuration
@EnableStateMachine
public class StateMachineConfig extends EnumStateMachineConfigurerAdapter&amp;lt;States, Events&amp;gt; {

    @Override
    public void configure(StateMachineStateConfigurer&amp;lt;States, Events&amp;gt; states) throws Exception {
        states.withStates().initial(States.DRAFT).states(EnumSet.allOf(States.class));
    }

    @Override
    public void configure(StateMachineTransitionConfigurer&amp;lt;States, Events&amp;gt; transitions) throws Exception {
        transitions.withExternal()
            .source(States.DRAFT).target(States.PUBLISH_TODO)
            .event(Events.ONLINE)
            .and()
            .withExternal()
            .source(States.PUBLISH_TODO).target(States.PUBLISH_DONE)
            .event(Events.PUBLISH)
            .and()
            .withExternal()
            .source(States.PUBLISH_DONE).target(States.DRAFT)
            .event(Events.ROLLBACK);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;定义一个测试业务对象，状态机的状态转移都会反映到该业务对象的状态变更上&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@WithStateMachine
@Data
@Slf4j
public class BizBean {

    /**
     * @see States
     */
    private String status = States.DRAFT.name();

    @OnTransition(target = &quot;PUBLISH_TODO&quot;)
    public void online() {
        log.info(&quot;操作上线，待发布. target status:{}&quot;, States.PUBLISH_TODO.name());
        setStatus(States.PUBLISH_TODO.name());
    }

    @OnTransition(target = &quot;PUBLISH_DONE&quot;)
    public void publish() {
        log.info(&quot;操作发布,发布完成. target status:{}&quot;, States.PUBLISH_DONE.name());
        setStatus(States.PUBLISH_DONE.name());
    }

    @OnTransition(target = &quot;DRAFT&quot;)
    public void rollback() {
        log.info(&quot;操作回滚,回到草稿状态. target status:{}&quot;, States.DRAFT.name());
        setStatus(States.DRAFT.name());
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;编写测试用例，这里我们使用CommandLineRunner接口代替，定义了一个StartupRunner，在该类的run方法中启动状态机、发送不同的事件，通过日志验证状态机的流转过程。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class StartupRunner implements CommandLineRunner {

    @Resource
    StateMachine&amp;lt;States, Events&amp;gt; stateMachine;

    @Override
    public void run(String... args) throws Exception {
        stateMachine.start();
        stateMachine.sendEvent(Events.ONLINE);
        stateMachine.sendEvent(Events.PUBLISH);
        stateMachine.sendEvent(Events.ROLLBACK);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在运行上述程序后，我们可以在控制台中获得如下输出，我们执行了三个操作：上线、发布、回滚，在下图中也确实看到了对应的日志。不过我还发现有一个意料之外的地方——在启动状态机的时候，还打印出了一个日志——“操作回滚，回到草稿状态. target status:DRAFT”，这里应该是状态机设置初始状态的时候触发的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/721786/201911/721786-20191111012714820-655870405.png&quot; alt=&quot;image-20191110162618938&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;分析&quot;&gt;分析&lt;/h2&gt;
&lt;p&gt;如上面的实战过程所示，使用Spring StateMachine的步骤如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;定义状态枚举和事件枚举&lt;/li&gt;
&lt;li&gt;定义状态机的初始状态和所有状态&lt;/li&gt;
&lt;li&gt;定义状态之间的转移规则&lt;/li&gt;
&lt;li&gt;在业务对象中使用状态机，编写响应状态变化的监听器方法&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;为了将状态变更的操作都统一管理起来，我们会考虑在项目中引入状态机，这样其他的业务模块就和状态转移模块隔离开来了，其他业务模块也不会纠结于当前的状态是什么，应该做什么操作。在应用状态机实现业务需求时，关键是业务状态的分析，只要状态机设计得没问题，具体的实现可以选择用Spring StateMachine，也可以自己去实现一个状态机。&lt;/p&gt;
&lt;p&gt;使用Spring StateMachine的好处在于自己无需关心状态机的实现细节，只需要关心业务有什么状态、它们之间的转移规则是什么、每个状态转移后真正要进行的业务操作。&lt;/p&gt;
&lt;p&gt;本文完整实例参见：&lt;a href=&quot;https://github.com/duqicauc/Spring-Boot-2.x-In-Action/tree/master/statemachinedemo&quot; class=&quot;uri&quot;&gt;https://github.com/duqicauc/Spring-Boot-2.x-In-Action/tree/master/statemachinedemo&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;http://blog.didispace.com/spring-statemachine/&quot; class=&quot;uri&quot;&gt;http://blog.didispace.com/spring-statemachine/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.javaadu.online/wp-admin/post-new.php&quot;&gt;https://projects.spring.io/spring-statemachine/#quick-start&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;hr/&gt;&lt;p&gt;本号专注于后端技术、JVM问题排查和优化、Java面试题、个人成长和自我管理等主题，为读者提供一线开发者的工作和成长经验，期待你能在这里有所收获。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/721786/201911/721786-20191111012715359-1381822920.png&quot; alt=&quot;javaadu&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 10 Nov 2019 17:27:00 +0000</pubDate>
<dc:creator>javaadu</dc:creator>
<og:description>本文首发于个人网站： 'Spring Boot 2.x实战之StateMachine' Spring StateMachine是一个状态机框架，在Spring框架项目中，开发者可以通过简单的配置就能获</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/javaadu/p/11832581.html</dc:identifier>
</item>
</channel>
</rss>