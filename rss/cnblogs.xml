<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>AVR单片机教程——UART进阶 - jerry_fuyi</title>
<link>http://www.cnblogs.com/jerry-fuyi/p/12222738.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jerry-fuyi/p/12222738.html</guid>
<description>&lt;p&gt;本文隶属于&lt;a href=&quot;https://www.cnblogs.com/jerry-fuyi/p/avr_tutorial.html&quot; target=&quot;_blank&quot;&gt;AVR单片机教程&lt;/a&gt;系列。&lt;/p&gt;

&lt;p&gt;在第一期中，我们已经开始使用UART来实现单片机开发板与计算机之间的通信，但只是简单地讲了讲一些概念和库函数的使用。在这一篇教程中，我们将从硬件与软件等各方面更深入地了解UART。&lt;/p&gt;
&lt;h3 id=&quot;usart组件&quot;&gt;USART组件&lt;/h3&gt;
&lt;p&gt;一直在讲的UART其实是USART组件的一部分，USART比UART多了同步的一部分，但这一部分用得太少（我从来没用过），而且缺乏实例，所以就略过了。然而，单片机的设计者很机智地把这个鸡肋功能升华了一下，USART组件可以支持SPI模式。SPI是一种同步串行总线，可以支持很高的传输速率。这个功能使得ATmega324PA支持最多3个SPI通道，其中一个是纯SPI，另两个就是SPI模式下的USART。我们将在下一讲中揭开SPI的神秘面纱。&lt;/p&gt;
&lt;p&gt;回到UART模式下的USART组件。开发板引出的&lt;code&gt;RX&lt;/code&gt;和&lt;code&gt;TX&lt;/code&gt;引脚是属于USART0组件的，因此使用时以下&lt;code&gt;n&lt;/code&gt;都用&lt;code&gt;0&lt;/code&gt;代替。&lt;/p&gt;
&lt;p&gt;UART共有5个寄存器：&lt;/p&gt;
&lt;ul readability=&quot;4&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;code&gt;UDRn&lt;/code&gt;是收发数据寄存器，收（&lt;code&gt;RXB&lt;/code&gt;）和发（&lt;code&gt;TXB&lt;/code&gt;）使用不同的寄存器，但都通过&lt;code&gt;UDRn&lt;/code&gt;来访问。向&lt;code&gt;TXB&lt;/code&gt;写入一个字节，UART就开始发送；&lt;code&gt;RXB&lt;/code&gt;保存接收到的数据，带有额外一个字节的缓冲（如同下一节要讲的缓冲区）。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;UCSRnA&lt;/code&gt;包含UART状态位，如三个中断对应的标志，以及一些不常用的设置位。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;UCSRnB&lt;/code&gt;主要用于使能，包括收发器与三个中断的使能位，以及9位帧格式相关的位。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;UCSRnC&lt;/code&gt;是最主要的控制寄存器，可以配置USART的模式与格式。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;UBRRnL&lt;/code&gt;和&lt;code&gt;UBRRnH&lt;/code&gt;（可以通过&lt;code&gt;UBRRn&lt;/code&gt;来访问这个16位寄存器）用于设定波特率，在异步模式下，&lt;span class=&quot;math inline&quot;&gt;\(BAUD = \frac {f_{CPU}} {16(UBRRn + 1)}\)&lt;/span&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;UART支持三个中断，分别是接收完成（&lt;code&gt;RX&lt;/code&gt;）、数据寄存器空（&lt;code&gt;UDRE&lt;/code&gt;）、发送完成（&lt;code&gt;TX&lt;/code&gt;）。第一个用于接收，后两个用于发送，一般使用&lt;code&gt;UDRE&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;RX&lt;/code&gt;中断允许程序在任何时刻及时地接收并处理总线上发来的数据。沿用“串口接收”一讲中的例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#include &amp;lt;avr/io.h&amp;gt;
#include &amp;lt;avr/interrupt.h&amp;gt;
#include &amp;lt;ee1/led.h&amp;gt;

int main(void)
{
    led_init();
    PORTD |=    1 &amp;lt;&amp;lt; 0;      // RXD0 pull-up
    UCSR0B =    1 &amp;lt;&amp;lt; RXCIE0  // RX interrupt
           |    1 &amp;lt;&amp;lt; RXEN0   // RX enabled
           |    1 &amp;lt;&amp;lt; TXEN0;  // TX enabled
    UCSR0C = 0b00 &amp;lt;&amp;lt; UMSEL00 // asynchronous USART
           | 0b10 &amp;lt;&amp;lt; UPM00   // even parity
           |    0 &amp;lt;&amp;lt; USBS0   // 1 stop bit
           | 0b11 &amp;lt;&amp;lt; UCSZ00; // 8-bit
    UBRR0L = 40;             // 38400bps
    sei();
    while (1)
        ;
}

ISR(USART0_RX_vect)
{
    static const char led_char[4] = {'r', 'y', 'g', 'b'};
    static uint8_t which = 4;
    uint8_t byte = UDR0;
    bool matched = false;
    for (uint8_t i = 0; i != 4; ++i)
        if (byte == led_char[i])
        {
            matched = true;
            which = i;
            break;
        }
    if (!matched &amp;amp;&amp;amp; (byte == '0' || byte == '1'))
    {
        matched = true;
        if (which &amp;lt; 4)
            led_set(which, byte - '0');
        which = 4;
    }
    if (!matched)
        which = 4;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;TX&lt;/code&gt;与&lt;code&gt;UDRE&lt;/code&gt;中断允许程序在总线发送数据同时执行其他代码。比如，在打印ASCII表的同时控制LED闪烁。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#include &amp;lt;avr/io.h&amp;gt;
#include &amp;lt;avr/interrupt.h&amp;gt;
#include &amp;lt;ee1/led.h&amp;gt;
#include &amp;lt;ee1/delay.h&amp;gt;

int main(void)
{
    led_init();
    UCSR0B =    1 &amp;lt;&amp;lt; UDRIE0  // UDRE interrupt
           |    1 &amp;lt;&amp;lt; TXEN0;  // TX only
    UCSR0C = 0b00 &amp;lt;&amp;lt; UMSEL00 // asynchronous USART
           | 0b10 &amp;lt;&amp;lt; UPM00   // even parity
           |    0 &amp;lt;&amp;lt; USBS0   // 1 stop bit
           | 0b11 &amp;lt;&amp;lt; UCSZ00; // 8-bit
    UBRR0L = 40;             // 38400bps
    sei();
    while (1)
    {
        led_on();
        delay(500);
        led_off();
        delay(500);
    }
}

ISR(USART0_UDRE_vect)
{
    static char c = 0x21;
    UDR0 = c;
    if (++c == 0x7F)
        c = 0x21;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你看，不用定时器，只需总线中断与老套的&lt;code&gt;main&lt;/code&gt;结合即可。&lt;/p&gt;
&lt;p&gt;值得一提的是&lt;code&gt;UDRE&lt;/code&gt;中断的设计特别人性化——&lt;code&gt;UDREn&lt;/code&gt;的复位值是&lt;code&gt;1&lt;/code&gt;，程序可以把所有数据都放在中断中，控制部分只需开关中断——而SPI和I²C组件都没有这个特性。至于它到底带来多少好处，只有在码的过程中体会了。&lt;/p&gt;
&lt;h3 id=&quot;缓冲区&quot;&gt;缓冲区&lt;/h3&gt;
&lt;p&gt;如果你较真一点，就会觉得上面这个程序很烂：&lt;/p&gt;
&lt;ol readability=&quot;6&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;把硬件驱动（UART配置与中断）与业务逻辑（要输出的内容）紧紧地连接在一起（专业点讲，叫“紧耦合”），不符合可复用性等一系列设计原则；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;ASCII表是十分有规律的，而大多数程序的输出则不然，需要&lt;code&gt;UDRE&lt;/code&gt;中断以外的代码来决定要输出什么字符串，仅中断并不能解放常规的输出。&lt;/p&gt;
&lt;p&gt;其实我们还遇到过其他问题：&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;相比25MHz的CPU频率，UART的38400波特率是很慢的，传输一个字节的时间可以让CPU执行几千条指令，但&lt;code&gt;uart_print_string&lt;/code&gt;等函数的策略都是等待UART把数据发送完成才返回，是&lt;strong&gt;阻塞&lt;/strong&gt;的；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;uart_scan_string&lt;/code&gt;等函数要求程序乖乖地等待总线上的数据到来，不能错过，这使程序不能在等待的同时做其他事；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;以上两点相结合更让人尴尬——在发送的同时接收到的数据会被错过，怎么还能叫全双工总线呢？&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这输入和输出两方面的问题可以用一种高度对称的手段来解决，它就是缓冲区。缓冲区是这样一种结构，它存放着一串字符，来自于程序的输出或UART的接收，并可以按顺序取出，用于UART的发送或程序的输入。显然，这需要用到中断：在&lt;code&gt;RX&lt;/code&gt;中断中，向缓冲区中放入接收到的数据；在&lt;code&gt;UDRE&lt;/code&gt;中断中，如果缓冲区中有数据，则取出并发送之。&lt;/p&gt;
&lt;p&gt;于是，当程序需要输入时，可以从缓冲区中取一些字符，并解析成整数等类型，如果缓冲区为空，则等待输入，与C语言标准输入&lt;code&gt;scanf&lt;/code&gt;很类似；当程序需要输出时，可以直接把字符串写到缓冲区中，让中断来逐字节发送，而主程序可以无需等待，直接继续工作，这种输出是&lt;strong&gt;异步&lt;/strong&gt;的。这个“异步”与UART总线的“异步”是不同的概念。关于阻塞、异步等概念，可参考：&lt;a href=&quot;https://www.zhihu.com/question/19732473&quot; target=&quot;_blank&quot;&gt;怎样理解阻塞非阻塞与同步异步的区别？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;但是现在“缓冲区”还只是一个抽象概念，我们要把它落实成代码。如何实现一个缓冲区呢？&lt;/p&gt;
&lt;p&gt;我们先把缓冲区想象成一个管道，有头和尾两端，我们需要从尾部放入球，从头部取出。这种数据结构称为&lt;strong&gt;队列&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;队列可以用链表来实现，好处是队列的长度没有限制，除非内存耗尽。但是在我们的应用场景中，链表节点中有效的数据是一个字节，却还需要两个字节来存放一个指针，不太划算。并且，&lt;code&gt;malloc&lt;/code&gt;函数是比较耗时的，应避免频繁调用。&lt;/p&gt;
&lt;p&gt;我们使用一种叫作“循环队列”的实现。循环队列是一个数组，保存两个下标，分别指向头和尾（由于我主要写C++，我习惯用尾后）。循环体现在，假如队列的大小是64，那么下标为63的元素的后一个就是下标为0的元素。如果把普通数组想象成一个矩形，那么循环队列就是一个圆环。&lt;/p&gt;
&lt;p&gt;初始时，头和尾下标相同。向尾部放入一个字节，就是在尾下标处写数据，并让尾下标指向下一个元素；取出一个字节，就是读取头下标处的数据，并让头下标指向下一个元素。当两个下标相等时，队列为空；当尾的后一个等于头时，队列满——可是明明这时只放了63个元素，为什么不再放一个呢？因为会与队列空的情况冲突，无法分辨，为了省事，还是浪费一个字节吧。&lt;/p&gt;
&lt;p&gt;下面这段代码需要你认真阅读并理解，但是请先忽略&lt;code&gt;volatile&lt;/code&gt;和&lt;code&gt;ATOMIC_BLOCK(ATOMIC_FORCEON)&lt;/code&gt;，当它们不存在就可以了。你也可以参考一些循环队列相关的资料来更好地理解这种结构（本来我想写的，但这篇已经很长了）。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#include &amp;lt;stdint.h&amp;gt;
#include &amp;lt;stdbool.h&amp;gt;
#include &amp;lt;avr/io.h&amp;gt;
#include &amp;lt;avr/interrupt.h&amp;gt;
#include &amp;lt;util/atomic.h&amp;gt;

#define UART_TX_BUFFER_SIZE 64
#define UART_TX_BUFFER_MASK (UART_TX_BUFFER_SIZE - 1)

volatile char uart_tx_buffer[UART_TX_BUFFER_SIZE];
volatile uint8_t uart_tx_head = 0;
volatile uint8_t uart_tx_tail = 0;

void uart_init_buffered()
{
    UCSR0B =    0 &amp;lt;&amp;lt; UDRIE0  // UDRE interrupt disabled
           |    1 &amp;lt;&amp;lt; TXEN0;  // TX only
    UCSR0C = 0b00 &amp;lt;&amp;lt; UMSEL00 // asynchronous USART
           | 0b10 &amp;lt;&amp;lt; UPM00   // even parity
           |    0 &amp;lt;&amp;lt; USBS0   // 1 stop bit
           | 0b11 &amp;lt;&amp;lt; UCSZ00; // 8-bit
    UBRR0L = 40;             // 38400bps
}

void uart_print_char_buffered(char c)
{
    bool full = true;
    while (1)
    {
        ATOMIC_BLOCK(ATOMIC_FORCEON)
        {
            if (((uart_tx_tail + 1) &amp;amp; UART_TX_BUFFER_MASK) // 0-&amp;gt;1, ..., 63-&amp;gt;0
                != uart_tx_head)
                full = false;
        }
        if (!full)
            break; // if full, wait until buffer is not full
    }
    ATOMIC_BLOCK(ATOMIC_FORCEON)
    {
        if (uart_tx_head == uart_tx_tail)
            UCSR0B |= 1 &amp;lt;&amp;lt; UDRIE0;
        uart_tx_buffer[uart_tx_tail] = c;
        uart_tx_tail = (uart_tx_tail + 1) &amp;amp; UART_TX_BUFFER_MASK;
    }
}

ISR(USART0_UDRE_vect)
{
    UDR0 = uart_tx_buffer[uart_tx_head];
    uart_tx_head = (uart_tx_head + 1) &amp;amp; UART_TX_BUFFER_MASK;
    if (uart_tx_head == uart_tx_tail)
        UCSR0B &amp;amp;= ~(1 &amp;lt;&amp;lt; UDRIE0);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看到这里我默认你已经理解了循环数组，下面来看这些被忽略的语句。声明为&lt;code&gt;volatile&lt;/code&gt;的变量一定会被放在内存中而不是通用寄存器中；&lt;code&gt;ATOMIC_BLOCK&lt;/code&gt;的功能是，后面的大括号中的语句是&lt;strong&gt;原子&lt;/strong&gt;的，在执行时不会被中断；&lt;code&gt;ATOMIC_FORCEON&lt;/code&gt;会在执行完后把全局中断打开。&lt;/p&gt;
&lt;p&gt;相信你一定对这种代码感到不适，为什么需要这么麻烦呢？以&lt;code&gt;if (uart_tx_head == uart_tx_tail)&lt;/code&gt;这一句为例，这句语句通常由主程序执行。&lt;/p&gt;
&lt;ol readability=&quot;4&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;假设执行到这一句前时&lt;code&gt;uart_tx_head&lt;/code&gt;为&lt;code&gt;41&lt;/code&gt;，&lt;code&gt;uart_tx_tail&lt;/code&gt;为&lt;code&gt;42&lt;/code&gt;，即缓冲区中还有&lt;code&gt;1&lt;/code&gt;字节没有发送。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;程序读取&lt;code&gt;uart_tx_head&lt;/code&gt;，其值为&lt;code&gt;41&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;在读取&lt;code&gt;uart_tx_tail&lt;/code&gt;之前，&lt;code&gt;USART0_UDRE_vect&lt;/code&gt;中断触发了，在中断中最后一个字节被发送，&lt;code&gt;uart_tx_head&lt;/code&gt;被修改为&lt;code&gt;42&lt;/code&gt;，&lt;code&gt;UDRIE0&lt;/code&gt;被写&lt;code&gt;0&lt;/code&gt;，关掉了这个中断，随后中断退出。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;程序读取&lt;code&gt;uart_tx_tail&lt;/code&gt;，其值为&lt;code&gt;42&lt;/code&gt;，两者不相等，&lt;code&gt;UDRIE0&lt;/code&gt;不会被写&lt;code&gt;1&lt;/code&gt;，中断保持关闭状态。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;缓冲区中被写了一个字节，&lt;code&gt;uart_tx_tail&lt;/code&gt;变为&lt;code&gt;43&lt;/code&gt;。缓冲区明明非空，&lt;code&gt;UDRE&lt;/code&gt;中断却没有开，这个字节无法发送。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这样分析很累，我写的时候并没有认真分析不加原子操作可能带来的问题，而是遵循这样的原则：对于非中断与中断的代码共享的数据，在非中断代码中一定要加原子，在中断代码中，如果在使用这些数据时全局中断可能处于打开状态，则也需要加原子。&lt;/p&gt;
&lt;p&gt;现在我们实现了串口输出缓冲区，输入缓冲区的原理类似，留作作业。我们还需要关注几个问题：&lt;/p&gt;
&lt;ol readability=&quot;2&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;串口输出是连续的字符流。“连续”是指不存在发送几个字节，停顿一下，再继续发送的情况；“字符流”是指发送的数据都是字符。在字符流的假设下，如果需要可以断开的输出，可以通过用&lt;code&gt;\0&lt;/code&gt;标记断点来实现。但是对于字节流，即数据本身就可能包含&lt;code&gt;\0&lt;/code&gt;的情形下，如何标记断点呢？作业4在缓冲区的基础之上增加了这样的需求。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;以上代码对于在缓冲区满时插入字符的策略是等待直到缓冲区有空位，虽然一定能等到，保证数据被发送，但可能需要等待很长时间。比如，在缓冲区满时发送一个较长的字符串，插入每一字节时都需要等待一个字节被发送的时间，总体上与同步发送无异。这里提供几种方案：用一种结构来标记是否发生了错误，以及发生何种错误；给发送函数添加返回值，指示是否发送成功；使用动态缓冲区，当缓冲区满时新开辟一块空间存放。不过，还是要根据应用选择最合适的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;多路发送&quot;&gt;多路发送&lt;/h3&gt;
&lt;p&gt;UART是稀缺资源，单片机一共有两个，我设计的时候用掉一个，要是再加个串口调试，就用完了。但是，利用一个额外的GPIO和开发板左上角的逻辑门资源，我们可以把一个UART发送通道扩展成两个。&lt;/p&gt;
&lt;p&gt;这个组合电路有两个输入：单片机UART输出（&lt;code&gt;UART&lt;/code&gt;，简写为&lt;code&gt;U&lt;/code&gt;）和信号选择（&lt;code&gt;SEL&lt;/code&gt;，简写为&lt;code&gt;S&lt;/code&gt;）；两个输出：当&lt;code&gt;SEL&lt;/code&gt;为低电平时有效的通道A（&lt;code&gt;OUTA&lt;/code&gt;，简写为&lt;code&gt;A&lt;/code&gt;）和当&lt;code&gt;SEL&lt;/code&gt;为高电平时有效的通道B（&lt;code&gt;OUTB&lt;/code&gt;，简写为&lt;code&gt;B&lt;/code&gt;，以上名字都是随便起的）。这样，尽管不能在两个通道同时发送，但至少&lt;code&gt;SEL&lt;/code&gt;可以控制每个字节的流向。&lt;/p&gt;
&lt;p&gt;回顾UART的帧格式，当信号线上没有信号的时候，它是保持高电平的，因此对于A通道，当&lt;code&gt;SEL&lt;/code&gt;为高时，&lt;code&gt;OUTA&lt;/code&gt;总是为高；当&lt;code&gt;SEL&lt;/code&gt;为低时，&lt;code&gt;OUTA&lt;/code&gt;电平与&lt;code&gt;UART&lt;/code&gt;相同，可以得到&lt;span class=&quot;math inline&quot;&gt;\(A = U + S\)&lt;/span&gt;，&lt;code&gt;+&lt;/code&gt;号表示逻辑或。同理，&lt;span class=&quot;math inline&quot;&gt;\(B = U + \overline {S}\)&lt;/span&gt;，上划线表示逻辑非。另外，&lt;code&gt;·&lt;/code&gt;号表示逻辑与。&lt;/p&gt;
&lt;p&gt;但是开发板上并没有或门和非门，只有与非门（&lt;code&gt;|&lt;/code&gt;，C语言中&lt;code&gt;|&lt;/code&gt;表示什么？）和或非门（&lt;code&gt;↓&lt;/code&gt;），我们需要把这两个式子变形一下：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(A = U + S = \overline { \overline{U} \cdot \overline{S} } = (U \downarrow 0) | (S \downarrow 0)\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(B = U + \overline {S} = \overline { \overline{U} \cdot S } = (U \downarrow 0) | S\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这样我们就可以画出原理图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1734552/202001/1734552-20200123221953239-355068606.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;左边两个是&lt;strong&gt;或非门&lt;/strong&gt;，右边是&lt;strong&gt;与非门&lt;/strong&gt;，分别位于开发板左上角标注&lt;code&gt;NOR&lt;/code&gt;和&lt;code&gt;NAND&lt;/code&gt;处。每个门有两个输入和一个输出，对应&lt;code&gt;A&lt;/code&gt;、&lt;code&gt;B&lt;/code&gt;、&lt;code&gt;O&lt;/code&gt;三个引脚，&lt;code&gt;A&lt;/code&gt;和&lt;code&gt;B&lt;/code&gt;是可以对调的。&lt;/p&gt;
&lt;p&gt;然后就要根据原理图搭建电路。也许你对这张并不复杂的电路图毫无头绪。的确，面包板上看似简单的电路也可能很复杂，不过还是有规则可以遵循的：&lt;/p&gt;
&lt;ol readability=&quot;6.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;每一条杜邦线有两端，是黑色胶壳加上一根针或者没有针。有针的称为“公”，没有的称为“母”（我真没开车）。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;板上的排针连接母头，面包板连接公头。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;杜邦线有3种：公对公、公对母、母对母。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;面包板上，一行5个孔是连接起来的。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;各个引脚可以划分为若干不相交集合，相同集合内的引脚有导线连接，不同集合内的引脚没有引脚连接。每个集合称为一个net。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;对于只有一个引脚的net，不管它。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;对于有两个引脚的net，选用合适的杜邦线把两个引脚直接连接。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;对于有至少3个引脚的net，通常需要借助面包板，选用合适的杜邦线把每个引脚与面包板上同一行连接。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这张图里只有&lt;code&gt;SEL&lt;/code&gt;和第一个或非门的输出这两个net有3个引脚，因此面包板上只会有6根线，像这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1734552/202001/1734552-20200125115533264-1175692397.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后简单地测试一下，&lt;code&gt;PIN_D&lt;/code&gt;用作&lt;code&gt;SEL&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#include &amp;lt;ee1/pin.h&amp;gt;
#include &amp;lt;ee1/uart.h&amp;gt;
#include &amp;lt;ee1/delay.h&amp;gt;

int main(void)
{
    pin_mode(PIN_D, OUTPUT);
    uart_init(UART_TX);
    for (int16_t i = 0; ; ++i)
    {
        pin_write(PIN_D, i &amp;amp; 1);
        uart_print_int(i);
        uart_print_line();
        delay(500);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;把两个通道连接到USB转串口工具上，分别可以看到奇数和偶数的输出。&lt;/p&gt;
&lt;h3 id=&quot;作业&quot;&gt;作业&lt;/h3&gt;
&lt;ol readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;为什么通常使用UDRE而不是TX？什么时候不能使用UDRE而只能选择TX？&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;使用中断与缓冲区改写“串口接收”一讲中的例程。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;如何使用74HC138来扩展UART输出？&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;实现一个两个发送通道共用的缓冲区（注意第1题）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Sat, 25 Jan 2020 15:08:00 +0000</pubDate>
<dc:creator>jerry_fuyi</dc:creator>
<og:description>本文隶属于AVR单片机教程系列。 在第一期中，我们已经开始使用UART来实现单片机开发板与计算机之间的通信，但只是简单地讲了讲一些概念和库函数的使用。在这一篇教程中，我们将从硬件与软件等各方面更深入地</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jerry-fuyi/p/12222738.html</dc:identifier>
</item>
<item>
<title>计算广告丨《互联网广告算法和系统实践》读书笔记 - vincent1997</title>
<link>http://www.cnblogs.com/vincent1997/p/12233566.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/vincent1997/p/12233566.html</guid>
<description>&lt;h2 id=&quot;引言&quot;&gt;引言&lt;/h2&gt;
&lt;p&gt;这是我阅读《互联网广告算法和系统实践》的笔记，作者王勇睿，在百度阅读上可以购买，书的篇幅很短，一天就能看完。&lt;/p&gt;
&lt;p&gt;本书主要介绍了搜索广告算法、非搜索（定向）广告算法和实时竞价广告算法，为读者梳理了广告中的常用概念如CTR、ECPM，一个广告系统如何组成，实践中还会考虑什么问题，没有涉及多的数学和算法模型。本书适合入门，但作为小白，很多内容读完后没有具体的案例消化，理解深度上有所欠缺。我想当具备了一定的实践经验后再来翻阅此书，才能融会贯通。之后的计划是继续阅读刘鹏老师的《计算广告学》。&lt;/p&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://yuedu.baidu.com/ebook/3e31c551964bcf84b9d57bc0?pn=1&amp;amp;rf=https%3A%2F%2Fwww.baidu.com%2Flink%3Furl%3Dt_2h3Y8qWbLih18HQ4bqCbd_bZV7X28z1IOTRTvws3hjAu3FnL7mdU7_wAmEoSRQmkCHNH95jhXGJiw1rj0NQdngBP4nitUxald_FHsxQejrMH5SJvtM7nKbA4X71kpoEGEFwrP7hY2gMlYKn0z7xYdRykNQXSL2N-fyqgArBzfnQeArWlxzcjVGcx6UVFarUMjVaK7s1k517Kxt6rooMy241u7eV1DIF955g2zXDe2pCrEsFT567F4ef31OZHeg%26wd%3D%26eqid%3D971878c3002e4bf0000000065e2c54ab&quot;&gt;互联网广告算法和系统实践&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;第一部分-互联网广告简介&quot;&gt;第一部分 互联网广告简介&lt;/h2&gt;
&lt;h3 id=&quot;广告简介&quot;&gt;1.1 广告简介&lt;/h3&gt;
&lt;h3 id=&quot;互联网广告&quot;&gt;1.2 互联网广告&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;显示广告、合约广告、定向广告、受众定向技术&lt;/li&gt;
&lt;li&gt;担保式投放&lt;/li&gt;
&lt;li&gt;竞价广告、广义二阶拍卖GSP、广义一阶拍卖GSP&lt;/li&gt;
&lt;li&gt;搜索广告、上下文广告、实时竞价&lt;/li&gt;
&lt;li&gt;广告交易平台、需求方平台、提供方平台&lt;/li&gt;
&lt;li&gt;计费方式：点击付费CPC、销售付费CPS、千次展现付费CPM&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;互联网广告类型&quot;&gt;1.3 互联网广告类型&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;条幅广告&lt;/li&gt;
&lt;li&gt;邮件直接营销广告&lt;/li&gt;
&lt;li&gt;富媒体广告&lt;/li&gt;
&lt;li&gt;视频广告&lt;/li&gt;
&lt;li&gt;文字链广告&lt;/li&gt;
&lt;li&gt;社交广告&lt;/li&gt;
&lt;li&gt;移动端广告&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;有效性模型&quot;&gt;1.4 有效性模型&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519578/202001/1519578-20200125230613071-1818402483.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;曝光：位置很重要。&lt;/li&gt;
&lt;li&gt;关注：广告创意吸引人，借助算法定向精准投放&lt;/li&gt;
&lt;li&gt;理解：让用户迅速理解广告&lt;/li&gt;
&lt;li&gt;信息接受：研究人群行为，还要借助心理学&lt;/li&gt;
&lt;li&gt;保持：追求中长期转化&lt;/li&gt;
&lt;li&gt;购买：最终决策，给用户提供更多更好的选择&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;好创意不但能吸引人（提升CTR），而且能够抓住人（提升ROI）。&lt;/p&gt;
&lt;h3 id=&quot;计费模式&quot;&gt;1.5 计费模式&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;CPM：Cost Per Mile，按照千次展现计费，展现之后的效果广告平台不保证。适合品牌广告。&lt;/li&gt;
&lt;li&gt;CPT：Cost Per Time，按照单位时间计费。为了增加曝光度。&lt;/li&gt;
&lt;li&gt;CPC：Cost Per Click，按照千次点击计费，广告系统要负责对点击率CTR预估；广告主可以参与竞价。关注点击率，但不关注广告实际成交情况，风险由广告主承担。&lt;/li&gt;
&lt;li&gt;CPS：Cost Per Sale，关注转化率，对广告主有利。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对广告主，风险从大到小：CPM/CPT、CPC、CPS&lt;/p&gt;
&lt;p&gt;广告系统收益指标：若千次展现的期望收益CPM值eCPM。&lt;/p&gt;
&lt;h3 id=&quot;机制设计&quot;&gt;1.6 机制设计&lt;/h3&gt;
&lt;h4 id=&quot;广告位拍卖&quot;&gt;1.6.1 广告位拍卖&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;n个广告A，m个广告位S，m＜n，广告位拍卖从A中选取m条广告，依次放置到S中。&lt;/li&gt;
&lt;li&gt;拍卖竞争除了展现机会，还包括S中排序位置。&lt;/li&gt;
&lt;li&gt;广告位拍卖过程分为广告排序和广告扣费。广告排序考虑展现哪些广告，广告扣费考虑收取多少费用。&lt;/li&gt;
&lt;li&gt;广告拍卖是多次重复博弈，纳什均衡点、本地无嫉妒均衡、占优策略、激烈相容&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;广义一阶价格gfp&quot;&gt;1.6.2 广义一阶价格GFP&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;广告展现不扣费&lt;/li&gt;
&lt;li&gt;一阶价格是指广告主本身出价。&lt;/li&gt;
&lt;li&gt;不存在纳什均衡点，竞价机器人导致广告系统收益大大降低。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;广义二阶价格gsp&quot;&gt;1.6.3 广义二阶价格GSP&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;对应第i位广告，若发生点击，GSP收取第i位广告主，第i+1位广告竞价加上一个货币最小值。&lt;/li&gt;
&lt;li&gt;若广告主降低竞价，其展现位置不变时，不会降低收费。下家没有降低竞价行为，导致上家付出更多点击费用。存在本地无嫉妒均衡。&lt;/li&gt;
&lt;li&gt;均衡报价：n个广告A，每条广告价值V，m个广告位S，每个位置点击率X，每个位置当前竞价P。对于任意广告位i上获得位置的广告j有&lt;span class=&quot;math inline&quot;&gt;\((v_j-p_i)x_i\ge(v_j-p_{i-1})x_{i-1}\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;均衡点不唯一，不是激励相容。&lt;/li&gt;
&lt;li&gt;现实中广告扣费要考虑点击率因素。对于广告i，广告系统预估i在当前场景点击率ai，结合竞价bi，计算每千次展现期望收益&lt;span class=&quot;math inline&quot;&gt;\(ecpm_i=a_ib_i\)&lt;/span&gt;，随后将广告集合按照&lt;span class=&quot;math inline&quot;&gt;\(ecpm\)&lt;/span&gt;排序，排序靠前若干条用于展现。计费时，若第i个广告被点击，从广告主扣除费用为&lt;span class=&quot;math inline&quot;&gt;\(\frac{a_{i+1}b_{i+1}}{a_i}+最小货币单位\)&lt;/span&gt;
&lt;ul&gt;&lt;li&gt;若广告点击率越高，广告主扣除费用越少，激励用户优化广告质量提高广告点击率。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;vcg机制&quot;&gt;1.6.4 VCG机制&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;目标为最大化社会价值&lt;/li&gt;
&lt;li&gt;有n个广告A，广告竞价为V，广告平台提供S广告位，每个位置点击率X，每条广告真实价格V。当广告i不参与关键字拍卖，排在i后的广告主i+1,...,m可获得的预期总收益为&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ x_iv_{i+1}+x_{i+1}v_{i+2}+...+x_mv_{m+1} \]&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;由于&lt;span class=&quot;math inline&quot;&gt;\(a_i\)&lt;/span&gt;参与，广告获得价值为&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ x_{i+1}v_{i+1}+x_{i+2}v_{i+2}+...+x_mv_{m}+x_{m+1}v_{m+1} \]&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;通常只有m个广告位，所以&lt;span class=&quot;math inline&quot;&gt;\(x_{m+1}=0\)&lt;/span&gt;，如果&lt;span class=&quot;math inline&quot;&gt;\(a_i\)&lt;/span&gt;被点击，那么它要付出代价是给社会其他个体带来的利益损失&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ (x_i-x_{i+1})v_{i+1}+(x_{i+1}-x{i+2})v_{i+2}+...+(x_{m-1}-x_m)v_m+(x_m-x_{m+1})v_{m+1} \]&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;VCG相比GSP优势
&lt;ol&gt;&lt;li&gt;VCG激烈相容，按照真实估价出价是最优选择&lt;/li&gt;
&lt;li&gt;VCG机制最大化社会价值，有利于广告主&lt;/li&gt;
&lt;li&gt;VCG存在纳什均衡，均衡点唯一&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;缺点
&lt;ol&gt;&lt;li&gt;计算困难，可解释性差&lt;/li&gt;
&lt;li&gt;相同竞价情况VCG扣费低于GSP机制，广告系统不愿意降低收入&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;技术课题&quot;&gt;1.7 技术课题&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;优化目标
&lt;ul&gt;&lt;li&gt;计算广告学：找到用户、上下文和合适广告间最佳匹配。&lt;/li&gt;
&lt;li&gt;互联网广告算法核心问题：根据用户、环境、广告全部有效消息，找到最合适的投放策略和模型，兼顾浏览者、广告主、广告平台的最大利益，并不断调整。&lt;/li&gt;
&lt;li&gt;用户U、环境C、广告A，算法目标函数为&lt;span class=&quot;math inline&quot;&gt;\(F(U,C,A)\)&lt;/span&gt;
&lt;ul&gt;&lt;li&gt;对于广告主，关注投资回报率ROI，&lt;span class=&quot;math inline&quot;&gt;\(F=\frac{\sum_iReturn_i}{\sum_iInvest_i}\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;对于用户，&lt;span class=&quot;math inline&quot;&gt;\(F=\frac{\sum_iClick_i}{\sum_iImpression_i}\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;对于广告系统，&lt;span class=&quot;math inline&quot;&gt;\(F=CTR*PPC*Discount\)&lt;/span&gt;，&lt;span class=&quot;math inline&quot;&gt;\(CTR\)&lt;/span&gt;是点击率，&lt;span class=&quot;math inline&quot;&gt;\(PPC\)&lt;/span&gt;是点击收费，&lt;span class=&quot;math inline&quot;&gt;\(Discount\)&lt;/span&gt;业务因子。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;搜索引擎技术
&lt;ul&gt;&lt;li&gt;广告系统和搜索引擎相似，广告系统没有爬虫模块，通过规范化步骤获取。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;存储技术和实时计算技术
&lt;ul&gt;&lt;li&gt;需要一个适合大规模读写的存储系统，需要实时计算系统。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;推荐技术&lt;/li&gt;
&lt;li&gt;点击率预估CTR Prediction&lt;/li&gt;
&lt;li&gt;广告主工具
&lt;ul&gt;&lt;li&gt;对广告主，广告系统提供推广工具和统计工具。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;系统架构简介
&lt;ul&gt;&lt;li&gt;前端引擎：接受网页发来广告请求，初步处理发给后端，拿到结果拼接返回请求者，这是在线部分Online&lt;/li&gt;
&lt;li&gt;检索引擎：关注效率和性能，Online&lt;/li&gt;
&lt;li&gt;实时点击率预估服务：对广告打分，一维、二维分数，Online&lt;/li&gt;
&lt;li&gt;广告主操作消息更新服务：广告主有权随时更改广告竞价，Online&lt;/li&gt;
&lt;li&gt;用户行为数据收集和更新系统：一般是Online&lt;/li&gt;
&lt;li&gt;特征提取和行为分析：一般用Hadoop平台，Offline&lt;/li&gt;
&lt;li&gt;反作弊系统：Offine和Online&lt;/li&gt;
&lt;li&gt;广告主后台：Offline和Online&lt;/li&gt;
&lt;li&gt;存储系统：存储任务&amp;lt;key,value&amp;gt;形式，有Offline和Online&lt;/li&gt;
&lt;li&gt;计算系统：信息挖掘，一般采取Hadoop作数据挖掘和特征提取计算，采取MPI架构做模型训练。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;第二部分-搜索广告&quot;&gt;第二部分 搜索广告&lt;/h2&gt;
&lt;h3 id=&quot;搜索广告架构&quot;&gt;2.1 搜索广告架构&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;搜索广告：搜索过程中搜索引擎推送的互联网广告。&lt;/li&gt;
&lt;li&gt;当用户输入查询后，广告系统会经过：&lt;strong&gt;广告检索、广告排序、流量分配&lt;/strong&gt;三个模块为用户提供广告。&lt;/li&gt;
&lt;li&gt;广告检索：以当前查询关键字为基础+用户自身信息，从数以万计的广告集合中粗选出合适的广告。可分为广告索引和广告匹配子模块。
&lt;ul&gt;&lt;li&gt;广告索引：将广告建成&lt;span class=&quot;math inline&quot;&gt;\(&amp;lt;key：用户竞价词, value：关联的广告列表&amp;gt;\)&lt;/span&gt;的索引形式。&lt;/li&gt;
&lt;li&gt;广告匹配：将用户查询分解成相关竞价词，从建好的索引中提取广告。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;广告排序：计算检索到广告的质量分数并排序。&lt;/li&gt;
&lt;li&gt;流量分配：根据广告排序分数，决定当前情况给用户出哪些广告。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;广告检索&quot;&gt;2.2 广告检索&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;根据用户关键字，选出相关广告，实际设置粗选和精选两个步骤：
&lt;ul&gt;&lt;li&gt;粗选：用信息检索，选取和查询关键字相关的一批广告。&lt;/li&gt;
&lt;li&gt;精选：精确的预估广告的点击率，进行排序。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;广告检索经过三步骤：广告分析，关键字分析和相关性匹配。
&lt;ul&gt;&lt;li&gt;广告分析：对广告进行处理，获取广告相关信息。&lt;/li&gt;
&lt;li&gt;关键字分析：根据用户输入，判断是否出广告，出什么广告。&lt;/li&gt;
&lt;li&gt;相关性匹配：根据关键字分析结果，去索引库中检索广告。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;广告分析&quot;&gt;2.2.1 广告分析&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;两个目的：
&lt;ul&gt;&lt;li&gt;将广告组织成倒排索引形式&lt;span class=&quot;math inline&quot;&gt;\(&amp;lt;key：竞价词-value：广告id链表&amp;gt;\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;从广告中抽取特征。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;广告主建立广告会选择相关的竞价词，容易造成常见词严重倾斜，解决问题的方法包括竞价词生成和模糊匹配。
&lt;ul&gt;&lt;li&gt;竞价词生成：广告系统通过分析广告主的landing page，帮助广告主选取竞价词。&lt;/li&gt;
&lt;li&gt;模糊匹配：用户选择一个通股出价，按照出价，广告系统自己选择跟广告相关的竞价词。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;查询分析&quot;&gt;2.2.2 查询分析&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;长串：语义信息丰富，展现量不足，总量大，存储压力大。提取关键词汇很重要。&lt;/li&gt;
&lt;li&gt;短串：语义信息不明确，根据用户个性化信息或上下文信息消除歧义。&lt;/li&gt;
&lt;li&gt;重要指标：扩大召回。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;相关性匹配&quot;&gt;2.2.3 相关性匹配&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;精确匹配：关键字严格包含某个竞价词才触发广告。&lt;/li&gt;
&lt;li&gt;模糊匹配&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;广告排序&quot;&gt;2.3 广告排序&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;广告系统按照ECPM降序排列广告候选集，将排序靠前广告展现出来。
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(ECPM=广告竞拍价*广告CTR*1000\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;广告竞拍价：广告主提供；CTR：广告系统利用机器学习准确预估；&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;基于点击模型的CTR预估方法
&lt;ul&gt;&lt;li&gt;点击率建模为&lt;span class=&quot;math display&quot;&gt;\[P(click)=P(click|Seen)P(Seen)\]&lt;/span&gt;，从而计算&lt;span class=&quot;math inline&quot;&gt;\(P(click|Seen)\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;基于机器学习的CTR预估算法&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;逻辑回归模型&quot;&gt;2.3.1 逻辑回归模型&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;函数形式&lt;span class=&quot;math inline&quot;&gt;\(y=\frac{1}{(1+e^{-w^Tx})}\)&lt;/span&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(x输入特征向量，y预测目标，w学习特征权重\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;输入x，类别为1的条件概率&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519578/202001/1519578-20200125225930797-1417590638.png&quot; alt=&quot;1579939149214&quot;/&gt;；输入x，类别为0的条件概率&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519578/202001/1519578-20200125225930111-1979086956.png&quot; alt=&quot;1579939171792&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519578/202001/1519578-20200125225929348-1318584587.png&quot; alt=&quot;1579938941540&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;特征处理方式&quot;&gt;2.3.2 特征处理方式&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;将人的先验知识，表示成机器学习算法能够接受的方式。&lt;/li&gt;
&lt;li&gt;常用特征
&lt;ul&gt;&lt;li&gt;广告和查询关键字的相似度：广告本身特征、查询本身特征、相似广告的特征、相似查询的特征。&lt;/li&gt;
&lt;li&gt;广告的树形结构信息：广告主-广告账户-广告计划-广告组-广告创意，同一个广告主的其他广告创意的CTR能帮助当前广告创意的CTR。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;算法评估&quot;&gt;2.3.3 算法评估&lt;/h4&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;CTR预估模型效果是否好：全流量-小流量实验-离线指标验证&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;衡量预估CTR和真实CTR之间差异，使用AUC衡量CTR预估精度。AUC是ROC曲线下的面积。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ROC是二维平面上的曲线，横坐标是FPR，纵坐标是TPR。调节分类器参数，使得ROC曲线形成一条从(0,0)到(1,1)的曲线，AUC就是ROC曲线下面积之和。&lt;/li&gt;
&lt;li&gt;互联网广告系统计算AUC：AUC等价于正样本score大于负样本score的概率。若正负样本score值相同，则按0.5正样本score大于负样本score对计算。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;假设正样本数M，负样本数N，计算AUC开销是M*N，通过排序减少AUC时间复杂度。&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;将样本按照score大小从高到低排序，score第一大样本获得n=M+N的rank值；第二大样本获得rank值为n-1。对rank为r的正样本i，组成正样本score大于负样本score的样本对个数为 r-排在i后的正样本数。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;因此AUC可如下方式计算&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519578/202001/1519578-20200125225920395-28466690.png&quot; alt=&quot;1579940261004&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;广告主推荐工具&quot;&gt;2.4 广告主推荐工具&lt;/h3&gt;
&lt;h4 id=&quot;投放要素&quot;&gt;2.4.1 投放要素&lt;/h4&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;广告主注册一个推广账户Account，包含多个推广计划Campaign，每个计划包含多个推广单元Group，设置Group主要需要竞价词Bidword和广告创意Creative。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519578/202001/1519578-20200125225919694-1627945233.png&quot; alt=&quot;1579940402529&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;一个Group完整投放需求和策略列表&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519578/202001/1519578-20200125225918936-242744027.png&quot; alt=&quot;1579940467074&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;搜索广告系统需要帮助广告主”充分表达自己投放需求”，给广告主提供投放基本元素。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519578/202001/1519578-20200125225918288-595817594.png&quot; alt=&quot;1579940526096&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;推荐重点在于竞价词Bidword。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;竞价词推荐方式&quot;&gt;2.4.2 竞价词推荐方式&lt;/h4&gt;
&lt;h4 id=&quot;其他工具&quot;&gt;2.4. 3 其他工具&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;投放前后，广告主需要一些数据帮助决策或者反馈，如下&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519578/202001/1519578-20200125225916744-642358859.png&quot; alt=&quot;1579940966768&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;实践一在线学习前沿&quot;&gt;2.5 实践一：在线学习前沿&lt;/h3&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;为了让模型特征量缩减，可以将逻辑回归目标函数修改成，模型将倾向于学习稀疏的&lt;span class=&quot;math inline&quot;&gt;\(w\)&lt;/span&gt;权重。&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[NLL(w)+\lambda\|w\|_1\]&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;随机梯度下降法简单易行，但往往难以得到特征向量稀疏的结果，Google提出FTRL-Proximal方法可以得到稀疏性更好的训练结果，其更新公式为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519578/202001/1519578-20200125225916084-1971634538.png&quot; alt=&quot;1579941142376&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519578/202001/1519578-20200125225915341-820910885.png&quot; alt=&quot;1579941155950&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519578/202001/1519578-20200125225914682-78266442.png&quot; alt=&quot;1579941167797&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;海量数据下，模型存储量过大给并发查询时效性带来很大挑战。
&lt;ul&gt;&lt;li&gt;降低模型特征维数，泊松选择法&lt;/li&gt;
&lt;li&gt;降低每一维特征存储量，float是4个字节，Google提出q2.13编码方式，用2个字节。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;第三部分-定向广告&quot;&gt;第三部分 定向广告&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;定向广告即非搜索广告&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;上下文定向&quot;&gt;3.1 上下文定向&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;根据投放页面内容，推送相关广告。关键问题对页面内容的刻画：
&lt;ul&gt;&lt;li&gt;内容提供商自定义：广告平台预先人工定义一些网页的类型标签，内容提供商自己选择网页类型。&lt;/li&gt;
&lt;li&gt;页面关键字提取：爬虫抽取网页中内容，进行一定内容分析，从中抽取可以精确匹配上的竞价词，然后到广告库中检索广告。&lt;/li&gt;
&lt;li&gt;网页聚类：使用爬虫抽取网页内容，然后对网页库进行文本聚类。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;受众定向&quot;&gt;3.2 受众定向&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;给当前用户流量打标签的过程
&lt;ul&gt;&lt;li&gt;显示标签应用：按照标签售卖流量&lt;/li&gt;
&lt;li&gt;隐式应用：不按照用户标签显示售卖流量&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;受众定向方法：
&lt;ul&gt;&lt;li&gt;用户背景资料调查、行为定向&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;监督行为定向&quot;&gt;3.2.1 监督行为定向&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;线性泊松回归模型&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519578/202001/1519578-20200125225913986-651811340.png&quot; alt=&quot;1579955766311&quot;/&gt;，其中&lt;span class=&quot;math inline&quot;&gt;\(\lambda=w^tx\)&lt;/span&gt;，W为预估参数，x为特征向量，y为事件发生频次。
&lt;ul&gt;&lt;li&gt;给定数据集&lt;span class=&quot;math inline&quot;&gt;\(T={(x_i,y_i)}\)&lt;/span&gt;，有对数似然函数&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519578/202001/1519578-20200125225913322-718502061.png&quot; alt=&quot;1579955798287&quot;/&gt;&lt;/li&gt;
&lt;li&gt;其对w的对每一项梯度值为&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519578/202001/1519578-20200125225912604-299852195.png&quot; alt=&quot;1579955820198&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;通过上面的线性泊松回归求出用户对该兴趣点的浏览频次的期望&lt;span class=&quot;math inline&quot;&gt;\(\lambda_{view}\)&lt;/span&gt;和点击频次的期望&lt;span class=&quot;math inline&quot;&gt;\(\lambda_{click}\)&lt;/span&gt;，用户i对类别k的CTR计算方法&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519578/202001/1519578-20200125225911933-327307383.png&quot; alt=&quot;1579955859851&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;非监督行为定向&quot;&gt;3.2.2 非监督行为定向&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;将用户向量化表示
&lt;ul&gt;&lt;li&gt;基于item的向量表示法、基于query的向量表示法&lt;/li&gt;
&lt;li&gt;向量化后，行为定向问题建模成经典的聚类问题。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;行为定向&quot;&gt;3.3 行为定向&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;按照用户的历史行为，进行广告推荐。用户的行为在不同类型的广告系统中有不同定义。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;推荐系统&quot;&gt;3.4 推荐系统&lt;/h3&gt;
&lt;h4 id=&quot;基于用户的协同过滤算法&quot;&gt;3.4.1 基于用户的协同过滤算法&lt;/h4&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;想知道用户n对电影m的评分，需要参考与用户n相似的其他用户，用他们对m的评分来拟合n对m的评分&lt;span class=&quot;math inline&quot;&gt;\(r_{nm}\)&lt;/span&gt;。对于给定用户&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;，他打过分的电影集合是&lt;span class=&quot;math inline&quot;&gt;\(M_n\)&lt;/span&gt;，那么&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;的平均得分是&lt;span class=&quot;math inline&quot;&gt;\(r_n=\frac{1}{|M_n|}\sum_i^{\in}r_{ni}\)&lt;/span&gt;，用户n对电影m的评分可以通过如下公式计算，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519578/202001/1519578-20200125225906306-1724348053.png&quot; alt=&quot;1579957017762&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(U_n\)&lt;/span&gt;表示与n相似的用户集合，&lt;span class=&quot;math inline&quot;&gt;\(s_{uv}\)&lt;/span&gt;表示用户u和v之间的相似度，&lt;span class=&quot;math inline&quot;&gt;\(z_n\)&lt;/span&gt;是相似度平滑因子，&lt;span class=&quot;math inline&quot;&gt;\(z_n=\sum_i^{\in}|s_{uv}|\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;如何定义与n相似的用户集合，用什么方法衡量用户之间相似度，根据具体应用不断调试。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;基于单品的协同过滤算法&quot;&gt;3.4.2 基于单品的协同过滤算法&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;用相似单品的得分来计算&lt;span class=&quot;math inline&quot;&gt;\(r_{nm}\)&lt;/span&gt;，计算方法如下&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519578/202001/1519578-20200125225905178-884621967.png&quot; alt=&quot;1579957240915&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(s_{im}\)&lt;/span&gt;表示电影i同电影m的相似度，与基于用户的协同过滤算法相同，该相似度也需要根据具体应用不断调试。该算法需要用户有充足行为，当用户行为比较稀疏，难以给出准确预估结果。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;奇异值分解svd&quot;&gt;3.4.3 奇异值分解SVD&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;希望将数据维度降低，实现某种程度上的聚合。&lt;/li&gt;
&lt;li&gt;将数据聚集成K个隐藏类，原始矩阵R可被分解成两个矩阵乘积形式&lt;span class=&quot;math inline&quot;&gt;\(R_{nm}=W_{nk}V_{km}\)&lt;/span&gt;，&lt;span class=&quot;math inline&quot;&gt;\(w_{nk}\)&lt;/span&gt;表示用户n对k类型电影的兴趣度，&lt;span class=&quot;math inline&quot;&gt;\(v_{km}\)&lt;/span&gt;表示电影m属于k类型电影的隶属度。&lt;/li&gt;
&lt;li&gt;线性代数中，任何一个实矩阵R可分解为&lt;span class=&quot;math inline&quot;&gt;\(R=U\sum P^T\)&lt;/span&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(\sum\)&lt;/span&gt;是K*K的对角线矩阵，&lt;span class=&quot;math inline&quot;&gt;\(K\)&lt;/span&gt;为矩阵R的秩，对角线上每个元素为&lt;span class=&quot;math inline&quot;&gt;\(RR^T\)&lt;/span&gt;矩阵特征值的平方根。&lt;/li&gt;
&lt;li&gt;U是N*K的矩阵，每一列是矩阵&lt;span class=&quot;math inline&quot;&gt;\(RR^T\)&lt;/span&gt;的特征向量。&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(P^T\)&lt;/span&gt;为K*M的矩阵，P中每一列是矩阵&lt;span class=&quot;math inline&quot;&gt;\(A^TA\)&lt;/span&gt;的特征向量。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;去除&lt;span class=&quot;math inline&quot;&gt;\(\sum\)&lt;/span&gt;中绝对值较小的特征值，并在U和P中除去其对于的特征向量使得&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519578/202001/1519578-20200125225904339-661984694.png&quot; alt=&quot;1579957812761&quot;/&gt;，从而达到降维目的，使得R计算高效。&lt;/li&gt;
&lt;li&gt;实际推荐系统，除了使用SVD方法求得W和V以外，另一种方法令&lt;span class=&quot;math inline&quot;&gt;\(\hat{R}=WV\)&lt;/span&gt;，最小化&lt;span class=&quot;math inline&quot;&gt;\(\hat{R}\)&lt;/span&gt;和R的差异，求解出最优W和V。损失函数是&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519578/202001/1519578-20200125225903634-800654183.png&quot; alt=&quot;1579957911063&quot;/&gt;&lt;ul&gt;&lt;li&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519578/202001/1519578-20200125225902960-1037292951.png&quot; alt=&quot;1579957942011&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;定向排序&quot;&gt;3.5 定向排序&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;定向广告排序和搜索广告排序机制基本相同，cpc收费下，两者按照ecpm进行排序。计算ecpm最重要因素是对广告进行ctr预估。&lt;/li&gt;
&lt;li&gt;搜索广告的ctr预估一般是单模态模型，而定向ctr预估可看作是多模态模型，如何融合不同定向方式也是多模态学习的难点。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;实践一定向广告算法架构&quot;&gt;3.6 实践一：定向广告算法架构&lt;/h3&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;定向广告解决“这样一个人”应该配&quot;什么样的广告&quot;？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;定向广告要素&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519578/202001/1519578-20200125225902072-446550681.png&quot; alt=&quot;1579958232002&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;第一步根据用户历史行为，选定一批用户的意图，并找到对应的广告。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;推荐系统（利用用户历史行为）&lt;/li&gt;
&lt;li&gt;利用用户属性方法（人口统计学）&lt;/li&gt;
&lt;li&gt;利用标签方法&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;第二步根据这些广告，进行排序。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果考虑点击率就是做&lt;span class=&quot;math inline&quot;&gt;\(&amp;lt;user,ad&amp;gt;\)&lt;/span&gt;点击率预估，获得打分。&lt;/li&gt;
&lt;li&gt;采用ecpm进行排序&lt;span class=&quot;math inline&quot;&gt;\(ecpm=ctr*bidprice\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519578/202001/1519578-20200125225901266-1961426584.png&quot; alt=&quot;1579958298858&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;实践二定向广告的平衡之道&quot;&gt;3.7 实践二：定向广告的平衡之道&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;关于用户疲劳
&lt;ul&gt;&lt;li&gt;针对频繁访问的用户&lt;/li&gt;
&lt;li&gt;针对访问次数稀疏，兴趣点转换很慢的用户&lt;/li&gt;
&lt;li&gt;“一次性”的类型兴趣&lt;/li&gt;
&lt;li&gt;“连续型”的类型兴趣&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;关于多样性
&lt;ul&gt;&lt;li&gt;给用户选择的余地&lt;/li&gt;
&lt;li&gt;首先保证召回率，然后根据候选集进行进一步选择，保证底线。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;关于多目标
&lt;ul&gt;&lt;li&gt;除了CTR，还有ROI、CVR&lt;/li&gt;
&lt;li&gt;多指标线性融合&lt;span class=&quot;math inline&quot;&gt;\(rankscore=ctr*roi*bidprice\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;对ROI好的创意筛选再利用&lt;span class=&quot;math inline&quot;&gt;\(rankscore=ctr*bidprice\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;关于E&amp;amp;E（搜寻和探索）
&lt;ul&gt;&lt;li&gt;如何给新加入的广告和冷广告展现的机会。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;第四部分-实时广告竞价&quot;&gt;第四部分 实时广告竞价&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;实时广告竞价：建立一种流量交换的协议，使得媒体和广告联盟向全网范围的广告主提供尚未出售的流量，广告主和广告联盟实现合作共赢。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;基本概念&quot;&gt;4.1 基本概念&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;技术核心
&lt;ul&gt;&lt;li&gt;将实时产生的展示广告流量及相关特征如客户信息、广告位信息推送给每个感兴趣的购买者，并且搜索出反馈协议。&lt;/li&gt;
&lt;li&gt;对推送流量的价值进行实时评价并给出具体CPM出价的方法。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;三类角色&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;广告交易市场AdExchange：实时广告竞价中流量进行实时交易的平台。&lt;/li&gt;
&lt;li&gt;需求方平台DSP：广告交易市场中的买方。&lt;/li&gt;
&lt;li&gt;供应方平台SSP：广告交易市场中的卖方。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519578/202001/1519578-20200125225900370-118563657.png&quot; alt=&quot;1579961540380&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;广告交易市场&quot;&gt;4.2 广告交易市场&lt;/h3&gt;
&lt;h4 id=&quot;历史与现状&quot;&gt;4.2.1 历史与现状&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;Mike Walrath创办Right Media，与Double Click、AdECN三足鼎立，随后被Yahoo收购。&lt;/li&gt;
&lt;li&gt;2007年广告交易市场元年&lt;/li&gt;
&lt;li&gt;2009年，实时广告竞价&lt;/li&gt;
&lt;li&gt;2011年9月，阿里巴巴TANX平台&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;实时广告竞价&quot;&gt;4.2.2 实时广告竞价&lt;/h4&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;线下部分：竞价交易各参与者之间实现用户ID相互转换和对应，即Cookie Mapping。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;线上部分：处理广告请求到来时的竞价和投放过程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519578/202001/1519578-20200125225859607-248255713.png&quot; alt=&quot;1579961861197&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;cookie-mapping&quot;&gt;4.2.3 Cookie Mapping&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;使用cookie累计用户再互联网上的行为数据。&lt;/li&gt;
&lt;li&gt;实时竞价时，用户信息不能共享给第三方，于是只将用户标识再竞价请求中提供给流量需求方。Cookie Mapping是解决各互联网公司标识不一致的标准方案。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;实践1-典型的广告交易市场架构&quot;&gt;4.2.4 实践1 典型的广告交易市场架构&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519578/202001/1519578-20200125225858490-1102150907.png&quot; alt=&quot;1579962394266&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;围绕核心的流量交换引擎，有三个重要子系统：
&lt;ul&gt;&lt;li&gt;业务系统：为需求方和供给方提供接入共给交易市场的接口。&lt;/li&gt;
&lt;li&gt;财务系统：提供安全、高效的财务结算功能&lt;/li&gt;
&lt;li&gt;数据系统：对交易过程中产生的数据进行记录、处理&lt;/li&gt;
&lt;li&gt;流量交换引擎：实时广告竞价体系的核心。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;第五部分-广告系统架构及挑战&quot;&gt;第五部分 广告系统架构及挑战&lt;/h2&gt;
&lt;h3 id=&quot;广告系统的特点&quot;&gt;5.1 广告系统的特点&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;高性能&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;海量数据和存储&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可运维性&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;功能职责划分&quot;&gt;5.2 功能职责划分&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;广告业务系统&lt;/li&gt;
&lt;li&gt;广告投放引擎&lt;/li&gt;
&lt;li&gt;广告效果检测系统&lt;/li&gt;
&lt;li&gt;广告防作弊和结算&lt;/li&gt;
&lt;li&gt;数据平台和算法&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;大型广告系统采用的技术&quot;&gt;5.3 大型广告系统采用的技术&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;高性能广告投放引擎&lt;/li&gt;
&lt;li&gt;基于Hadoop的数据平台：分布式计算框架&lt;/li&gt;
&lt;li&gt;CDN&lt;/li&gt;
&lt;li&gt;关系数据库&lt;/li&gt;
&lt;li&gt;J2EE或LAMP应用开发框架&lt;/li&gt;
&lt;li&gt;负载均衡&lt;/li&gt;
&lt;li&gt;服务化&lt;/li&gt;
&lt;li&gt;消息中间件&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;后记&quot;&gt;后记&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519578/202001/1519578-20200125225856810-1687065068.png&quot; alt=&quot;1579963369206&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;DMP允许外部数据挖掘引擎接入，产生不同的数据分析结果，供不同的应用方使用&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1519578/202001/1519578-20200125225855813-979676935.png&quot; alt=&quot;1579963435605&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 25 Jan 2020 15:04:00 +0000</pubDate>
<dc:creator>vincent1997</dc:creator>
<og:description>引言 这是我阅读《互联网广告算法和系统实践》的笔记，作者王勇睿，在百度阅读上可以购买，书的篇幅很短，一天就能看完。 本书主要介绍了搜索广告算法、非搜索（定向）广告算法和实时竞价广告算法，为读者梳理了广</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/vincent1997/p/12233566.html</dc:identifier>
</item>
<item>
<title>python接口自动化测试 - mock模块基本使用介绍 - 小菠萝测试笔记</title>
<link>http://www.cnblogs.com/poloyy/p/12233507.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/poloyy/p/12233507.html</guid>
<description>&lt;h2&gt;mock简介&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;py3已将mock集成到unittest库中&lt;/li&gt;
&lt;li&gt;为的就是更好的进行单元测试&lt;/li&gt;
&lt;li&gt;简单理解，&lt;strong&gt;模拟接口返回参数&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;通俗易懂，&lt;strong&gt;直接修改接口返回参数的值&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;strong&gt;mock作用&lt;/strong&gt;&lt;/h2&gt;
&lt;h3&gt;解决依赖问题，达到解耦作用&lt;/h3&gt;
&lt;p&gt;当我们测试某个&lt;strong&gt;目标接口（模块）&lt;/strong&gt;时，该接口&lt;strong&gt;依赖其他接口&lt;/strong&gt;，当被依赖的接口未开发完成时，可以&lt;strong&gt;用mock模拟被依赖接口&lt;/strong&gt;，完成目标接口的测试&lt;/p&gt;

&lt;h3&gt;模拟复杂业务的接口&lt;/h3&gt;
&lt;p&gt;当我们测试某个&lt;strong&gt;目标接口（模块）&lt;/strong&gt;，该接口&lt;strong&gt;依赖一个非常复杂的接口&lt;/strong&gt;时，可以&lt;strong&gt;用mock来模拟这个复杂的业务接口&lt;/strong&gt;；也解决接口依赖一样的原理&lt;/p&gt;

&lt;h3&gt;单元测试&lt;/h3&gt;
&lt;p&gt;如果某个接口（模块）未开发完成时，又需要编写测试用例，则可以通过mock模拟该接口（模块）进行测试&lt;/p&gt;

&lt;h3&gt;前后端联调&lt;/h3&gt;
&lt;p&gt;前端开发的页面需要根据后端返回的不同状态码展示不同的页面，当后端接口未开发完成时，也可通过mock来模拟后端接口返回自己想要的数据&lt;/p&gt;

&lt;h2&gt;mock类解读&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;class&lt;/span&gt; Mock(spec=None,side_effect=None,return_value=DEFFAULT,name=None)&lt;/span&gt; &lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;secp&lt;/strong&gt;：定义mock对象的属性值，可以是列表，字符串，甚至一个对象或者实例 &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;side_effect&lt;/strong&gt;：可以用来&lt;strong&gt;抛出异常&lt;/strong&gt;或者动态改变返回值，它必须是一个iterator（列表），它会覆盖return_value&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;return_value&lt;/strong&gt;：定义mock方法的返回值，它可以是一个值，可以是一个对象（如果存在side_effect参数那这个就没有用，也就是不能同时用）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;name&lt;/strong&gt;：作为mock对象的一个标识，在print时可以看到&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;mock实际使用&lt;/h2&gt;
&lt;h3&gt;一个未开发完成的功能如何测试？&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; add(self, a, b):
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;两个数相加&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;pass&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestSub(unittest.TestCase):
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;测试两个数相加用例&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; test_sub(self):
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建一个mock对象 return_value代表mock一个数据&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;         mock_add = mock.Mock(return_value=15&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 将mock对象赋予给被测函数&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;         add =&lt;span&gt; mock_add
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 调用被测函数&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;         result = add(5, 5&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 断言实际结果和预期结果&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;         self.assertEqual(result, 15)
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;一个完成开发的功能如何测试？&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SubClass(object):
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; add(self, a, b):
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;两个数相加&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; a +&lt;span&gt; b
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestSub(unittest.TestCase):
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;测试两个数相加用例&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; test_add2(self):
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 初始化被测函数类实例&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;         sub =&lt;span&gt; SubClass()
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建一个mock对象 return_value代表mock一个数据&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 传递side_effect关键字参数, 会覆盖return_value参数值, 使用真实的add方法测试&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;         sub.add = mock.Mock(return_value=15, side_effect=&lt;span&gt;sub.add)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 调用被测函数&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;         result = sub.add(5, 5&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 断言实际结果和预期结果&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         self.assertEqual(result, 10)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;side_effect：&lt;/strong&gt;这里给的参数值是sub.add相当于add方法的地址，当我们调用add方法时就会调用真实的add方法&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;简单理解成：&lt;/strong&gt;传递了side_effect参数且值为被测函数地址时，mock不会起作用；&lt;strong&gt;两者不可共存&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;另外，side_effect接受的是一个可迭代序列，当传递多个值时，每次调用mock时会返回不同的值；如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; mock_obj = mock.Mock(side_effect= [1,2,3&lt;span&gt;])
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(mock_obj())
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(mock_obj())
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(mock_obj())
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(mock_obj())
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 输出&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;Traceback (most recent call last):
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 1
&lt;span&gt;10&lt;/span&gt;   File &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;D:/MyThreading/mymock.py&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, line 37, &lt;span&gt;in&lt;/span&gt; &amp;lt;module&amp;gt;
&lt;span&gt;11&lt;/span&gt; 2
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(mock_obj())
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 3
&lt;span&gt;14&lt;/span&gt;   File &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C:\Python36\lib\unittest\mock.py&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, line 939, &lt;span&gt;in&lt;/span&gt; &lt;span&gt;__call__&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; _mock_self._mock_call(*args, **&lt;span&gt;kwargs)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;   File &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C:\Python36\lib\unittest\mock.py&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, line 998, &lt;span&gt;in&lt;/span&gt;&lt;span&gt; _mock_call
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     result =&lt;span&gt; next(effect)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;StopIteration&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h4 id=&quot;autoid-0-4-3&quot;&gt;存在依赖关系的功能如何测试？&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 支付类&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Payment:
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; requestOutofSystem(self, card_num, amount):
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;'''&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        请求第三方外部支付接口，并返回响应码
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        :param card_num: 卡号
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        :param amount: 支付金额
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        :return: 返回状态码，200 代表支付成功，500 代表支付异常失败
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;'''&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 第三方支付接口请求地址(故意写错)&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;         url = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://third.payment.pay/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 请求参数&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;         data = {&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;card_num&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: card_num, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;amount&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: amount}
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         response = requests.post(url, data=&lt;span&gt;data)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 返回状态码&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; response.status_code
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; doPay(self, user_id, card_num, amount):
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;'''&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        支付
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;        :param userId: 用户ID
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        :param card_num: 卡号
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;        :param amount: 支付金额
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;        :return:
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;'''&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 调用第三方支付接口请求进行真实扣款&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;             resp =&lt;span&gt; self.requestOutofSystem(card_num, amount)
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;调用第三方支付接口返回结果：&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, resp)
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;except&lt;/span&gt;&lt;span&gt; TimeoutError:
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如果超时就重新调用一次&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;重试一次&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;             resp =&lt;span&gt; self.requestOutofSystem(card_num, amount)
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; resp == 200&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 返回第三方支付成功，则进行系统里面的扣款并记录支付记录等操作&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{0}支付{1}成功！！！进行扣款并记录支付记录&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.format(user_id, amount))
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;success&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt; 
&lt;span&gt;41&lt;/span&gt;         &lt;span&gt;elif&lt;/span&gt; resp == 500&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 返回第三方支付失败，则不进行扣款&lt;/span&gt;
&lt;span&gt;43&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{0}支付{1}失败！！不进行扣款！！！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.format(user_id, amount))
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;fail&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;45&lt;/span&gt; 
&lt;span&gt;46&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 单元测试类&lt;/span&gt;
&lt;span&gt;47&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; payTest(unittest.TestCase):
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; 
&lt;span&gt;49&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; test_pay_success(self):
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;         pay =&lt;span&gt; Payment()
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 模拟第三方支付接口返回200&lt;/span&gt;
&lt;span&gt;52&lt;/span&gt;         pay.requestOutofSystem = mock.Mock(return_value=200&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;         resp = pay.doPay(user_id=1, card_num=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;12345678&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, amount=100&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;         self.assertEqual(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;success&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, resp)
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; 
&lt;span&gt;56&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; test_pay_fail(self):
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;         pay =&lt;span&gt; Payment()
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 模拟第三方支付接口返回500&lt;/span&gt;
&lt;span&gt;59&lt;/span&gt;         pay.requestOutofSystem = mock.Mock(return_value=500&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;         resp = pay.doPay(user_id=1, card_num=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;12345678&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, amount=100&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;         self.assertEqual(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;fail&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, resp)
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt; 
&lt;span&gt;63&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; test_pay_time_success(self):
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt;         pay =&lt;span&gt; Payment()
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 模拟第三方支付接口首次支付超时,重试第二次成功&lt;/span&gt;
&lt;span&gt;66&lt;/span&gt;         pay.requestOutofSystem = mock.Mock(side_effect=[TimeoutError, 200&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt;         resp = pay.doPay(user_id=1, card_num=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;12345678&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, amount=100&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt;         self.assertEqual(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;success&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, resp)
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt; 
&lt;span&gt;70&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; test_pay_time_fail(self):
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt;         pay =&lt;span&gt; Payment()
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 模拟第三方支付接口首次支付超时,重试第二次失败&lt;/span&gt;
&lt;span&gt;73&lt;/span&gt;         pay.requestOutofSystem = mock.Mock(side_effect=[TimeoutError, 500&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt;         resp = pay.doPay(user_id=1, card_num=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;12345678&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, amount=100&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt;         self.assertEqual(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;fail&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, resp)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;也许有小伙伴会问，第三方支付都不能用，我们的测试结果是否是有效的呢？&lt;/p&gt;
&lt;p&gt;通常在测试一个模块的时候，是可以认为&lt;strong&gt;其他模块的功能是正常的，只针对目标模块进行测试是没有任何问题的&lt;/strong&gt;，所以说测试结果也是正确的&lt;/p&gt;

&lt;h2&gt;mock装饰器&lt;/h2&gt;
&lt;p&gt;一共两种格式&lt;/p&gt;
&lt;ol&gt;&lt;li&gt; &lt;span class=&quot;cnblogs_code&quot;&gt;@patch(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;module名字.方法名&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)&lt;/span&gt; &lt;/li&gt;
&lt;li&gt; &lt;span class=&quot;cnblogs_code&quot;&gt;@patch.object(类名, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;方法名&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)&lt;/span&gt; &lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;68&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 装饰类演示&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; mock &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Mock, patch
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 单独的相乘函数&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; multiple(a, b):
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; a *&lt;span&gt; b
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 单独的捕获Exception函数&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; is_error():
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         os.mkdir(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; False
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;except&lt;/span&gt;&lt;span&gt; Exception as e:
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; True
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 计算类,包含add方法&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; calculator(object):
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; add(self, a, b):
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; a +&lt;span&gt; b
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 装饰类演示 - 单元测试类&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestProducer(unittest.TestCase):
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; case执行前&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; setUp(self):
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         self.calculator =&lt;span&gt; calculator()
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; mock一个函数,注意也要指定module&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt;     @patch(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;mock_learn.multiple&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; test_multiple(self, mock_multiple):
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;         mock_multiple.return_value = 3
&lt;span&gt;36&lt;/span&gt;         self.assertEqual(multiple(8, 14), 3&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; 
&lt;span&gt;38&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; mock一个类对象的方法&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt;     @patch.object(calculator, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;add&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; test_add(self, mock_add):
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;         mock_add.return_value = 3
&lt;span&gt;42&lt;/span&gt;         self.assertEqual(self.calculator.add(8, 14), 3&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; 
&lt;span&gt;44&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; mock调用方法返回多个不同的值&lt;/span&gt;
&lt;span&gt;45&lt;/span&gt;     @patch.object(calculator, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;add&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; test_effect(self, mock_add):
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;         mock_add.side_effect = [1, 2, 3&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;         self.assertEqual(self.calculator.add(8, 14), 1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;         self.assertEqual(self.calculator.add(8, 14), 2&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;         self.assertEqual(self.calculator.add(8, 14), 3&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; 
&lt;span&gt;52&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; mock的函数抛出Exception&lt;/span&gt;
&lt;span&gt;53&lt;/span&gt;     @patch(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;os.mkdir&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; test_exception(self, mkdir):
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;         mkdir.side_effect =&lt;span&gt; Exception
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; &lt;span&gt;        self.assertEqual(is_error(), True)
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; 
&lt;span&gt;58&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; mock多个函数,注意函数调用顺序&lt;/span&gt;
&lt;span&gt;59&lt;/span&gt;     @patch.object(calculator, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;add&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;     @patch(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;mock_learn.multiple&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; test_more(self, mock_multiple, mock_add):
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;         mock_add.return_value = 1
&lt;span&gt;63&lt;/span&gt;         mock_multiple.return_value = 4
&lt;span&gt;64&lt;/span&gt;         self.assertEqual(self.calculator.add(3, 3), 1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt;         self.assertEqual(multiple(3, 3), 4)
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sat, 25 Jan 2020 14:19:00 +0000</pubDate>
<dc:creator>小菠萝测试笔记</dc:creator>
<og:description>mock简介 py3已将mock集成到unittest库中 为的就是更好的进行单元测试 简单理解，模拟接口返回参数 通俗易懂，直接修改接口返回参数的值 mock作用 解决依赖问题，达到解耦作用 当我们</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/poloyy/p/12233507.html</dc:identifier>
</item>
<item>
<title>【自制操作系统04】从实模式到保护模式 - 闪客sun</title>
<link>http://www.cnblogs.com/flashsun/p/12233407.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/flashsun/p/12233407.html</guid>
<description>&lt;p&gt;通过前三章的努力，我们成功将控制权转交给了 loader.asm 这个程序。具体说就是 bios 通过&lt;strong&gt;加载并跳转到 0x7c00&lt;/strong&gt;（IMB大叔们定的） 把控制权转交给了我们操作系统的第一个汇编程序 mbr.asm，然后 mbr.asm 里做的事就是通过&lt;strong&gt;加载 loader 程序并跳转到 0x900&lt;/strong&gt;（这个是我们自己定的）把控制权转交给了 loader.asm 程序，目前这个程序里还只是向屏幕输出一行字符串“loader”，今天我们就将扩展它。并且今天我们要做的事，是操作系统中的第一个精彩之处，就是&lt;strong&gt;从实模式跨越到保护模式&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;一实模式与保护模式鸟瞰&quot;&gt;一、实模式与保护模式鸟瞰&lt;/h2&gt;
&lt;p&gt;我这人喜欢直面问题，其实本章只需要搞明白三个主要问题就行了，什么是实模式和保护模式，实模式与保护模式的区别是什么，怎么进入保护模式。我先来简单阐述下这三个问题&lt;/p&gt;
&lt;h4 id=&quot;什么是实模式和保护模式&quot;&gt;什么是实模式和保护模式&lt;/h4&gt;
&lt;p&gt;Intel 8086 是一个由 Intel 于 1978 年所设计的 16 位微处理器芯片，是 x86 架构的鼻祖。紧接着 Intel 又推出了第一款 32 位的 cpu Intel 80286（很快被淘汰，80386更经典一些），这款 cpu 由于和之前有很多不同的“保护”特性，所以称为保护模式，也是与此同时，之前的 8086 这个 16 位 cpu 才有了实模式的叫法。&lt;/p&gt;
&lt;p&gt;所以什么是实模式和保护模式，其实就是 Intel 给自己的处理器特性命的一个名字而已，具体有哪些特性那就是细节问题了，但最起码有一点刚刚已经有所透露，那就是保护模式至少是 32 位的，而实模式是 16 位的（即使一个 32 位的 cpu 也有实模式）&lt;/p&gt;
&lt;h4 id=&quot;实模式与保护模式的区别是什么&quot;&gt;实模式与保护模式的区别是什么&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;实模式 16 位，保护模式 32 位&lt;/li&gt;
&lt;li&gt;实模式下的地址是段寄存器地址偏移4位+偏移地址得到物理地址。保护模式下段寄存器存入了段选择子，在段描述符表中寻找段基址，再加上偏移地址得到物理地址（开启分页下为逻辑地址）&lt;/li&gt;
&lt;li&gt;这个我觉得是个 1 的推论，就是实模式寻址空间是 1M，保护模式是 4G&lt;/li&gt;
&lt;li&gt;这个我觉得是 2 的推论，就是段描述符表记录了段的权限，改变了实模式下可以随意访问所有内存的隐患（这也是保护这两个字的体现）&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;怎么进入保护模式&quot;&gt;怎么进入保护模式&lt;/h4&gt;
&lt;p&gt;进入保护模式有三步：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;打开 A20&lt;/li&gt;
&lt;li&gt;加载 gdt&lt;/li&gt;
&lt;li&gt;将 cr0 的 pe 位置 1&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;可以看出进入保护模式的操作是很简单的，但提前要做好准备工作，最重要的就是 gdt(Global Descriptor Table 全局描述表)的准备。&lt;/p&gt;
&lt;h2 id=&quot;二代码鸟瞰&quot;&gt;二、代码鸟瞰&lt;/h2&gt;
&lt;h4 id=&quot;loader.asm&quot;&gt;loader.asm&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;section loader vstart=0x900

jmp protect_mode

gdt:
;0描述符
    dd  0x00000000
    dd  0x00000000
;1描述符(4GB代码段描述符)
    dd  0x0000ffff
    dd  0x00cf9800
;2描述符(4GB数据段描述符)
    dd  0x0000ffff
    dd  0x00cf9200
;3描述符(28Kb的视频段描述符)
    dd  0x80000007
    dd  0x00c0900b

lgdt_value:
    dw $-gdt-1  ;高16位表示表的最后一个字节的偏移（表的大小-1） 
    dd gdt      ;低32位表示起始位置（GDT的物理地址）

SELECTOR_CODE   equ 0x0001&amp;lt;&amp;lt;3
SELECTOR_DATA   equ 0x0002&amp;lt;&amp;lt;3
SELECTOR_VIDEO  equ 0x0003&amp;lt;&amp;lt;3

protect_mode:
;进入32位
    lgdt [lgdt_value]
    in al,0x92
    or al,0000_0010b
    out 0x92,al
    cli
    mov eax,cr0
    or eax,1
    mov cr0,eax
    
    jmp dword SELECTOR_CODE:main
    
[bits 32]
;正式进入32位
main:
mov ax,SELECTOR_DATA
mov ds,ax
mov es,ax
mov ss,ax
mov esp,LOADER_STACK_TOP
mov ax,SELECTOR_VIDEO
mov gs,ax

mov byte [gs:0xa0],'3'
mov byte [gs:0xa2],'2'
mov byte [gs:0xa4],'m'
mov byte [gs:0xa6],'o'
mov byte [gs:0xa8],'d'

jmp $
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里说说我的心得体会，现在看整段的代码虽不能说每一行让我自己写能写出来，但现在看起来极为清晰。我现在其实已经想不起来当时为什么理解了好久好久就是理解不了，调试了好半天也老是有各种问题。不过这个代码是我去掉了一些可有可无影响理解的部分，只留下了最精华的部分，我不知道如果我一开始接触的是这样的代码是否能够理解到位。&lt;/p&gt;
&lt;p&gt;鸟瞰整段代码，大概分为三块。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第一块用二进制方式网内存中写了数据（四个段描述符），并定义了三个常量&lt;/li&gt;
&lt;li&gt;第二块其实仔细观察会发现就是进入保护模式的步骤（打开A20、加载gdt、将cr0的pe位置1）&lt;/li&gt;
&lt;li&gt;第三块还是一个在屏幕上输出“32mod”字符串，与之前不同的是这是在保护模式下的输出&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;三代码第一块解读全局段描述符表gdt&quot;&gt;三、代码第一块解读：全局段描述符表（GDT）&lt;/h2&gt;
&lt;h4 id=&quot;cpu-与操作系统打配合的方式&quot;&gt;cpu 与操作系统打配合的方式&lt;/h4&gt;
&lt;p&gt;有件事现在说可能体会不大，写到后面好多地方你会发现，像加载 gdt 这种操作模式好多地方都是通用的，咱先不用管 gdt 是什么，总之 cpu 会有很多与操作系统相互打配合的地方，这个就是其中之一。配合怎么打呢，那就是 cpu 定义好一个数据结构，再给你一个寄存器。操作系统一般负责做三件事情&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;负责在内存中某位置按照这个数据结构写一堆数据（如本讲的段描述符表gdt，以及之后要说的页表）&lt;/li&gt;
&lt;li&gt;然后再把你写在内存的哪个位置这个信息（起始地址），存在 cpu 给你预留的一个寄存器里，这一般会有一条专门的指令，比如本讲的 lgdt，不会说让你用 mov 操作的&lt;/li&gt;
&lt;li&gt;操作系统将 cpu 某寄存器中的某位置 1&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;然后就开启了这个功能，段描述符表如此，页表如此，TSS亦是如此，这个之后讲到会深有体会。我现在已经有所体会了，但还没整理出全部的这种打配合的地方，等我再深入些再给大家整理一份。&lt;/p&gt;
&lt;h4 id=&quot;先说说什么是段描述符&quot;&gt;先说说什么是段描述符&lt;/h4&gt;
&lt;p&gt;直接上干货，还记不记得第一节课说的内容&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;在你开机的一瞬间，CPU 的 PC 寄存器被强制初始化为 0xFFFF0。如果再说具体些，CPU 将段基址寄存器 cs 初始化为 0xF000，将偏移地址寄存器 IP 初始化为 0xFFF0，根据实模式下的最终地址计算规则，&lt;strong&gt;将段基址左移 4 位，加上偏移地址，得到最终的物理地址&lt;/strong&gt;也就是抽象出来的 PC 寄存器地址为 0xFFFF0。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这种段基址左移 4 位，加上偏移地址，得到物理地址的方式，就是实模式下的地址转换方式。&lt;/p&gt;
&lt;p&gt;然而保护模式下不一样了&lt;/p&gt;
&lt;p&gt;在保护模式下，段基址寄存器中存的数据，被理解为&lt;strong&gt;段选择子&lt;/strong&gt;，根据这个值去我们自己在内存中写好的&lt;strong&gt;段描述符表&lt;/strong&gt;中找，找到对应的&lt;strong&gt;段描述符&lt;/strong&gt;，从中取出&lt;strong&gt;段基址&lt;/strong&gt;。用这个段基址加上偏移地址，最终得到物理地址（逻辑地址和页表的事以后再说，不冲突）。&lt;/p&gt;
&lt;p&gt;就这么点区别&lt;/p&gt;
&lt;p&gt;那自然就有两个问题，一个是段描述符表长什么样子呀？决定了我们往内存中写的数据结构是什么。另一个就是去哪找段描述符表压，这个就需要告诉 cpu 为我们提前预留好的寄存器，也就是 lgdt 指令。下面我们就分别看着两个问题&lt;/p&gt;
&lt;h4 id=&quot;段描述符表长什么样子&quot;&gt;段描述符表长什么样子&lt;/h4&gt;
&lt;p&gt;首先&lt;strong&gt;段描述符表&lt;/strong&gt;是一张表，在内存中也就是个&lt;strong&gt;数组&lt;/strong&gt;，是一个个的段描述符一个个紧挨着的结果。所以我们要了解&lt;strong&gt;段描述符&lt;/strong&gt;长什么样就好了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1096103/202001/1096103-20200125204046804-940378396.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里我顺便把&lt;strong&gt;选择子&lt;/strong&gt;和 &lt;strong&gt;GDTR 寄存器&lt;/strong&gt;的结构也列出来了，这些就是全部的需要我们自己写数据的地方了，也是 cpu 和操作系统配合中需要约定的全部事情&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;;0描述符
    dd  0x00000000
    dd  0x00000000
;1描述符(4GB代码段描述符)
    dd  0x0000ffff
    dd  0x00cf9800
;2描述符(4GB数据段描述符)
    dd  0x0000ffff
    dd  0x00cf9200
;3描述符(28Kb的视频段描述符)
    dd  0x80000007
    dd  0x00c0900b&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们看看这些直接在内存中写死的常量，就是按照段描述符的数据结构写的&lt;/p&gt;
&lt;p&gt;代码段描述符转化为二进制是 00000000_00000000_11111111_11111111_00000000_11001111_10011000_00000000&lt;br/&gt;数据段描述符转为为二进制是 00000000_00000000_11111111_11111111_00000000_11001111_10010010_00000000&lt;br/&gt;视频段描述符转化为二进制是 10000000_00000000_00000000_00000111_00000000_11000000_10010000_00000000&lt;/p&gt;
&lt;p&gt;这里我们拿视频段描述符来分析，提取（拼凑）出段基址的数据，00000000_00000000_10000000_00000000，转换为十六进制是 0x80000。怎么样熟不熟悉，这恰好是显卡黑白模式在内存中的映射的起始地址。可以看下第一章的内容，不过我这里还是把图贴出来。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1096103/202001/1096103-20200125214030444-1218638448.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来的几个常量定义，很容易明白它们的意思&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;lgdt_value:
    dw $-gdt-1  ;高16位表示表的最后一个字节的偏移（表的大小-1） 
    dd gdt      ;低32位表示起始位置（GDT的物理地址）

SELECTOR_CODE   equ 0x0001&amp;lt;&amp;lt;3
SELECTOR_DATA   equ 0x0002&amp;lt;&amp;lt;3
SELECTOR_VIDEO  equ 0x0003&amp;lt;&amp;lt;3&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;lgdt_value 就是按照 lgdt 寄存器规定的数据结构拼凑出来的，下面的三个常量其实就是对应上面定义的三个段描述符的偏移量，由于每个描述符占 64 位，也就是占 8 个地址单元，所以索引下标的计算就是第几个描述符 * 8就好了，相信这个不难理解。&lt;/p&gt;
&lt;h2 id=&quot;四代码第二块解读进入保护模式三步走&quot;&gt;四、代码第二块解读：进入保护模式三步走&lt;/h2&gt;
&lt;p&gt;代码直接对应上面的三步&lt;/p&gt;
&lt;p&gt;加载 gdt&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;lgdt [lgdt_value]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;打开 A20&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;in al,0x92
or al,0000_0010b
out 0x92,al
cli    ;禁止中断，先不用管&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将 cr0 的 pe 位置 1&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mov eax,cr0
or eax,1
mov cr0,eax&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时已经进入保护模式了，段基址寄存器的意义已经变了，所以跳转指令变成了&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;jmp dword SELECTOR_CODE:main&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;五代码第三块解读保护模式下的简单代码&quot;&gt;五、代码第三块解读：保护模式下的简单代码&lt;/h2&gt;
&lt;p&gt;前面就是将数据段寄存器赋值给一些段基址寄存器用于访问数据段，然后将栈基址赋值位本次加载到的内存位置，重点是下面几句&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mov ax,SELECTOR_VIDEO
mov gs,ax
mov byte [gs:0xa0],'3'
...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段将我们刚刚写好的常量 SELECTOR_VIDEO 写入了段基址寄存器 gs，并在其后用了这个基址寄存器去进行 mov 操作。通过这个段选择子，在段描述符表里寻找出来的段基址是我们写好的显卡的内存映射的起始地址，所以同前几章在实模式下的输出就一样了。&lt;/p&gt;
&lt;h2 id=&quot;六运行代码&quot;&gt;六、运行代码&lt;/h2&gt;
&lt;p&gt;我们并没有增加新文件，所以Makefile和上一篇一样，不用变，直接运行看效果，make brun&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1096103/202001/1096103-20200125204812965-1997581006.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，我们的段基址寄存器没有直接写显卡的起始地址，而是通过段选择子索引的，但依然正常输出了 &quot;32mod&quot; 字符串，说明成功了&lt;/p&gt;
&lt;h2 id=&quot;写在最后开源项目和课程规划&quot;&gt;写在最后：开源项目和课程规划&lt;/h2&gt;
&lt;p&gt;如果你对自制一个操作系统感兴趣，不妨跟随这个系列课程看下去，甚至加入我们，一起来开发。&lt;/p&gt;
&lt;h4 id=&quot;参考书籍&quot;&gt;参考书籍&lt;/h4&gt;
&lt;p&gt;《操作系统真相还原》这本书真的赞！强烈推荐&lt;/p&gt;
&lt;h4 id=&quot;项目开源&quot;&gt;项目开源&lt;/h4&gt;
&lt;blockquote readability=&quot;1.875&quot;&gt;
&lt;p&gt;项目开源地址：&lt;a href=&quot;https://gitee.com/sunym1993/flashos&quot; class=&quot;uri&quot;&gt;https://gitee.com/sunym1993/flashos&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当你看到该文章时，代码可能已经比文章中的又多写了一些部分了。你可以通过提交记录历史来查看历史的代码，我会慢慢梳理提交历史以及项目说明文档，争取给每一课都准备一个可执行的代码。当然文章中的代码也是全的，采用复制粘贴的方式也是完全可以的。&lt;/p&gt;
&lt;p&gt;如果你有兴趣加入这个自制操作系统的大军，也可以在留言区留下您的联系方式，或者在 gitee 私信我您的联系方式。&lt;/p&gt;
&lt;h4 id=&quot;课程规划&quot;&gt;课程规划&lt;/h4&gt;
&lt;p&gt;本课程打算出系列课程，我写到哪觉得可以写成一篇文章了就写出来分享给大家，最终会完成一个功能全面的操作系统，我觉得这是最好的学习操作系统的方式了。所以中间遇到的各种坎也会写进去，如果你能持续跟进，跟着我一块写，必然会有很好的收货。即使没有，交个朋友也是好的哈哈。&lt;/p&gt;
&lt;p&gt;目前的系列包括&lt;/p&gt;
</description>
<pubDate>Sat, 25 Jan 2020 13:45:00 +0000</pubDate>
<dc:creator>闪客sun</dc:creator>
<og:description>通过前三章的努力，我们成功将控制权转交给了 loader.asm 这个程序。具体说就是 bios 通过 加载并跳转到 0x7c00 （IMB大叔们定的） 把控制权转交给了我们操作系统的第一个汇编程序</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/flashsun/p/12233407.html</dc:identifier>
</item>
<item>
<title>[apue] 使用 Ctrl+S停止输出而不用挂起前台进程 - goodcitizen</title>
<link>http://www.cnblogs.com/goodcitizen/p/12233461.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/goodcitizen/p/12233461.html</guid>
<description>&lt;p&gt;之前一直知道使用 Ctrl+Z 挂起前台进程来阻止进程运行，之后可以再通过 shell 的作业控制 (jobs / fg N) 来将后台进程切换为前台，从而继续运行。&lt;/p&gt;
&lt;p&gt;最近学到一种新的方法，对于不停有 console 输出的前台进程，可以使用 Ctrl+S 来 STOP 一个进程的输出，从而暂停进程。&lt;/p&gt;
&lt;p&gt;之后可以通过 Ctrl+Q 或输入任意字符来重启 (START) 进程输出，从而继续运行。&lt;/p&gt;

&lt;p&gt;看到这个方法，立即想到写个脚本验证一下：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/goodpaperman/apue/blob/master/18.chapter/deadloop.sh&quot; target=&quot;_blank&quot;&gt;deadloop.sh&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; #! /bin/&lt;span&gt;sh&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; var=&lt;span&gt;1&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;while&lt;/span&gt;&lt;span&gt; :
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;do&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt;   &lt;span&gt;echo&lt;/span&gt;&lt;span&gt; this is $var
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;   var=$(($var+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;   usleep &lt;span&gt;100000&lt;/span&gt;
&lt;span&gt;8&lt;/span&gt; &lt;span&gt;done&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这个脚本每 100 毫秒输出一条日志 “this is N”，其中 N 为日志序号，可以帮我们确定在一次暂停与重启之间，是否有输出丢失。&lt;/p&gt;
&lt;p&gt;运行过程中按下 Ctrl+S，输出果然暂停了：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:false;&quot;&gt;
&amp;gt;./deadloop.sh 
this is 1
this is 2
this is 3
this is 4
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;再按下 Ctrl+Q 则输出继续，直到按下 Ctrl+Z 挂起进程：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:false;&quot;&gt;
&amp;gt;./deadloop.sh 
this is 1
this is 2
this is 3
this is 4
this is 5
this is 6
this is 7
this is 8
this is 9
this is 10
this is 11
^Z
[1]+  Stopped                 ./deadloop.sh
&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;首先可以看到重启后的输出序号与重启前的可以接上，所以中间并没有输出丢失，也就是说是进程被暂停了，而不只是输出停止了。&lt;/p&gt;
&lt;p&gt;其次在按下 Ctrl+Z 时终端会回显 ^Z，而按下 Ctrl+S 或 Ctrl+Q 时，终端没有任何回显。&lt;/p&gt;

&lt;p&gt;于是重点对比按下 Ctrl+S 时与 Ctrl+Z 时进程的状态，来看这两种暂停方式的区别。&lt;/p&gt;
&lt;p&gt;通过 ps 命令查看下两种暂停时进程的状态：&lt;/p&gt;
&lt;p&gt;Ctrl+S&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;55&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:false;&quot;&gt;
&amp;gt;ps xfo pid,ppid,pgid,sid,tpgid,suid,euid,user,stat,tty,command&lt;br/&gt;PID  PPID  PGID   SID TPGID  SUID  EUID USER     STAT TT       COMMAND
 6653  6652  2786  2786    -1   500   500 yunhai   S    ?         \_ gnome-pty-helper
 6655  6652  6655  6655  6655   500   500 yunhai   Ss+  pts/0     \_ /bin/bash
&lt;span&gt;12539  6652 12539 12539 16673   500   500 yunhai   Ss   pts/1     \_ /bin/bash
16673 12539 16673 12539 16673   500   500 yunhai   S+   pts/1     |   \_ /bin/sh ./deadloop.sh&lt;/span&gt;
12797  6652 12797 12797 13349   500   500 yunhai   Ss   pts/2     \_ /bin/bash
15959  6652 15959 15959 16766   500   500 yunhai   Ss   pts/3     \_ /bin/bash
16766 15959 16766 15959 16766   500   500 yunhai   R+   pts/3         \_ ps xfo pid,ppid,pgid,sid,tpgid,suid,euid,user,stat,tty,command
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Ctrl+Z&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;55&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:false;&quot;&gt;
&amp;gt;ps xfo pid,ppid,pgid,sid,tpgid,suid,euid,user,stat,tty,command
  PID  PPID  PGID   SID TPGID  SUID  EUID USER     STAT TT       COMMAND
 6653  6652  2786  2786    -1   500   500 yunhai   S    ?         \_ gnome-pty-helper
 6655  6652  6655  6655  6655   500   500 yunhai   Ss+  pts/0     \_ /bin/bash
&lt;span&gt;12539  6652 12539 12539 16717   500   500 yunhai   Ss   pts/1     \_ /bin/bash&lt;/span&gt;
&lt;span&gt;16673 12539 16673 12539 16717   500   500 yunhai   T    pts/1     |   \_ /bin/sh ./deadloop.sh
16688 16673 16673 12539 16717   500   500 yunhai   T    pts/1     |   |   \_ usleep 100000&lt;/span&gt;
16717 12539 16717 12539 16717   500   500 yunhai   R+   pts/1     |   \_ ps xfo pid,ppid,pgid,sid,tpgid,suid,euid,user,stat,tty,command
12797  6652 12797 12797 13349   500   500 yunhai   Ss   pts/2     \_ /bin/bash
15959  6652 15959 15959 15959   500   500 yunhai   Ss+  pts/3     \_ /bin/bash
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以看到最大的不同是，通过 Ctrl+Z 停止的进程状态为挂起 ('T')，而通过 Ctrl+S 停止的进程状态为运行 ('S+')。&lt;/p&gt;
&lt;p&gt;另一方面，我们启动 stap 探测进程间信号的收发，可以在 Ctrl+Z 停止进程时收到以下的输出：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/goodpaperman/apue/blob/master/09.chapter/stap_signal.sh&quot; target=&quot;_blank&quot;&gt;stap_signal.sh&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:false;&quot;&gt;
22       events/3         16688 usleep           20     &lt;span&gt;SIGTSTP&lt;/span&gt;         &lt;br/&gt;22       events/3         16673 deadloop.sh      20     &lt;span&gt;SIGTSTP&lt;/span&gt;         &lt;br/&gt;16673    deadloop.sh      12539 bash             17     SIGCHLD         &lt;br/&gt;16688    usleep           16673 deadloop.sh      17     SIGCHLD  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;也就是说可以观察到向前台进程发送的 SIGTSTP 信号。而在使用 Ctrl+S 时并无特别的信号被侦测到 (仅 usleep 进程结束时向父进程发送的 SIGCHILD)。&lt;/p&gt;

&lt;p&gt;注意：此处的 SIGCHLD 并不表示 deadloop.sh 与 usleep 结束，而是挂起时向父进程发送的通知。关于这一点，可以参考我之前写的一篇文章：&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/goodcitizen/p/11133705.html&quot;&gt;[apue] 等待子进程的那些事儿&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;在暂停期间，通过 pstack 命令查看两种方式暂停的进程堆栈信息：&lt;/p&gt;
&lt;p&gt;Ctrl+S&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:false;&quot;&gt;
&amp;gt;pstack 16673
#0  0x00119424 in __kernel_vsyscall ()
#1  0x007a7cd3 in &lt;span&gt;__write_nocancel&lt;/span&gt; () from /lib/libc.so.6
#2  0x007411b4 in _IO_new_file_write () from /lib/libc.so.6
#3  0x00742a90 in _IO_new_do_write () from /lib/libc.so.6
#4  0x00741c80 in _IO_new_file_overflow () from /lib/libc.so.6
#5  0x00744b2a in __overflow () from /lib/libc.so.6
#6  0x0073e0b5 in putc () from /lib/libc.so.6
#7  0x080aebb0 in echo_builtin ()
#8  0x08070c51 in ?? ()
#9  0x08072e41 in ?? ()
#10 0x08073aa0 in execute_command_internal ()
#11 0x080747a4 in execute_command ()
#12 0x08076d89 in ?? ()
#13 0x08073a02 in execute_command_internal ()
#14 0x080747a4 in execute_command ()
#15 0x08076d89 in ?? ()
#16 0x08073a02 in execute_command_internal ()
#17 0x080747a4 in execute_command ()
#18 0x080750e4 in ?? ()
#19 0x08073bc4 in execute_command_internal ()
#20 0x080747a4 in execute_command ()
#21 0x08060857 in reader_loop ()
#22 0x0805fed9 in main ()
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Ctrl+Z&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:false;&quot;&gt;
&amp;gt;pstack 16673
#0  0x00119424 in __kernel_vsyscall ()
#1  0x00776673 in &lt;span&gt;__waitpid_nocancel&lt;/span&gt; () from /lib/libc.so.6
#2  0x080830f2 in ?? ()
#3  0x0808432e in wait_for ()
#4  0x08074635 in execute_command_internal ()
#5  0x08076dcd in ?? ()
#6  0x08073a02 in execute_command_internal ()
#7  0x080747a4 in execute_command ()
#8  0x080750e4 in ?? ()
#9  0x08073bc4 in execute_command_internal ()
#10 0x080747a4 in execute_command ()
#11 0x08060857 in reader_loop ()
#12 0x0805fed9 in main ()
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;前者停止在了 write 系统调用，后者停止在了 waitpid 系统调用。&lt;/p&gt;
&lt;p&gt;所以前者应该是在输出时被暂停的，而后者是在等待 usleep 子进程返回时被挂起的。&lt;/p&gt;
&lt;p&gt;大家可以体会一下这两处方式在细微处的差别。&lt;/p&gt;

&lt;p&gt;最后，可以使用 Ctrl+S 停止前台进程的前提是 必需打开终端的 IXON 标志，使用之前的小工具：&lt;/p&gt;
&lt;p&gt;&lt;a class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/goodcitizen/p/12222417.html&quot;&gt;[apue] 一个查看当前终端标志位设置的小工具&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;可以查看终端的输入 flag 是否已经打开了这个标志：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:false;&quot;&gt;
&amp;gt;./term
input flag 0x00006f02
    BRKINT
    ICRNL
    IMAXBEL
    &lt;span&gt;IXANY&lt;/span&gt;
    &lt;span&gt;IXON&lt;/span&gt;
output flag 0x00000005
    ONLCR
    OPOST
control flag 0x000004bf
    CREAD
    CSIZE
    CS6
    CS7
    CS8
    HUPCL
local flag 0x00008a3b
    ECHO
    ECHOE
    ECHOK
    ICANON
    IEXTEN
    ISIG
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;一般终端都是打开的。如果再打开 IXANY 标志位，则使用任意键都可以重启被停止的输出，而不一定要使用 Ctrl+Q。&lt;/p&gt;
&lt;p&gt;最后，还有一个隐藏的前提，就是被暂停的进程在前台有频繁的输出，否则 Ctrl+S 也无用武之地。&lt;/p&gt;

&lt;p&gt;总结一下，今天学到一个新的方法去暂停运行中的前台进程，可能对于运维老鸟来说已经是手到擒来，对我却是完全的新鲜，&lt;/p&gt;
&lt;p&gt;所以花了些时间研究下，感觉 linux 博大精深，不起眼处可能就藏着一些好东西，值得挖掘！&lt;/p&gt;

</description>
<pubDate>Sat, 25 Jan 2020 13:42:00 +0000</pubDate>
<dc:creator>goodcitizen</dc:creator>
<og:description>之前一直知道使用 Ctrl+Z 挂起前台进程来阻止进程运行，之后可以再通过 shell 的作业控制 (jobs / fg N) 来将后台进程切换为前台，从而继续运行。 最近学到一种新的方法，对于不停有</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/goodcitizen/p/12233461.html</dc:identifier>
</item>
<item>
<title>Spring（三）核心容器 - ApplicationContext 上下文启动准备 - 龙四丶</title>
<link>http://www.cnblogs.com/loongk/p/12233417.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/loongk/p/12233417.html</guid>
<description>&lt;p&gt;前面介绍了 Spring 容器的概念，其核心可归纳为两个类： BeanFactory 和 ApplicationContext，ApplicationContext 继承自 BeanFactory ，其不仅包含 BeanFactory 所有功能，还扩展了容器功能。之后介绍了在 SSM 时期和 SpringBoot 时期如何启动 ApplicationContext 。在结尾处，我们指出，ApplicationContext 核心其实是 refresh 方法，容器一系列功能都在该方法中实现，如：注册 Bean、注入 Bean 等。&lt;/p&gt;
&lt;p&gt;在 refresh 方法中，实现容器核心功能前，先进行了一系列环境准备工作，我们以 SpringBoot 为当前运行环境，深入讨论这部分内容。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注：本篇文章使用的 SpringBoot 版本为 2.0.3.RELEASE，其 Spring 版本为 5.0.7.RELEASE&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;refresh 方法定义在 ConfigurableApplicationContext 接口中，被 AbstractApplicationContext 抽象类实现，该方法由十几个子方法组成，这些子方法各司其职，但部分子方法被 AbstractApplicationContext 的子类进行扩展，来增强功能。其中，前四个子方法主要进行上下文准备工作。&lt;/p&gt;
&lt;h2 id=&quot;第一步preparerefresh&quot;&gt;第一步：prepareRefresh&lt;/h2&gt;
&lt;p&gt;我们先从 refresh 中的 prepareRefresh 方法开始讨论：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void refresh() throws BeansException, IllegalStateException {
    synchronized (this.startupShutdownMonitor) {
        // 初始化上下文环境，就是记录下容器的启动时间、活动状态等
        prepareRefresh();

        ...
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该方法被继承 AbstractApplicationContext 抽象类的子类进行扩展，扩展该方法的子类有：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwgy1gb5p8nikslj32fa0aidkx.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因本次演示的环境是 SpringBoot ，前面我们讲过，SpringBoot 会根据当前 Web 应用类型创建不同的上下文对象 ，如 Servlet Web、Reactive Web 等。这里演示的是 Servlet Web 应用，所以创建的上下文对象是 AnnotationConfigServletWebServerApplicationContext 。该类的 prepareRefresh 方法会被执行：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class AnnotationConfigServletWebServerApplicationContext
        extends ServletWebServerApplicationContext implements AnnotationConfigRegistry {

    ...
    
    @Override
    protected void prepareRefresh() {
    
        // 清除 Class 的元数据缓存。底层用 Map 保存元数据，执行 Map 的 clear 方法
        this.scanner.clearCache();
        
        // 调用父类，也就是 AbstractApplicationContext 的 prepareRefresh 方法
        super.prepareRefresh();
    }
    ...     
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public abstract class AbstractApplicationContext {
    
    ...
    
    private long startupDate;
    
    private final AtomicBoolean active = new AtomicBoolean();

    private final AtomicBoolean closed = new AtomicBoolean();

    private Set&amp;lt;ApplicationEvent&amp;gt; earlyApplicationEvents;

    ...

    protected void prepareRefresh() {
        
        // 记录此上下文开始时的系统时间（以毫秒为单位）
        this.startupDate = System.currentTimeMillis();
        
        // 记录此上下文是否已关闭，这里设置为未关闭
        this.closed.set(false);
        
        // 记录此上下文是否处于活动状态，这里设置为活动状态
        this.active.set(true);
    
        if (logger.isInfoEnabled()) {
            logger.info(&quot;Refreshing &quot; + this);
        }
    
        // 这也是交由子类扩展的方法。具体子类为 GenericWebApplicationContext，主要是初始化属性源，
        // 将 ServletContext 和 ServletConfig 属性配置添加到 Environment 环境上下文中
        initPropertySources();
    
        // 校验 Environment 中那些必备的属性配置是否存在，不存在则抛异常。
        getEnvironment().validateRequiredProperties();
    
        // 创建 ApplicationEvent 事件集合
        this.earlyApplicationEvents = new LinkedHashSet&amp;lt;&amp;gt;();
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;refresh 中的 prepareRefresh 方法执行结束，主要是记录容器的启动时间、活动状态、检查必备属性是否存在。其中，关于 Environment 环境配置，在前面 SpringBoot 系列文章中有详细讨论，感兴趣的同学可自行翻阅。&lt;/p&gt;
&lt;h2 id=&quot;第二步obtainfreshbeanfactory&quot;&gt;第二步：obtainFreshBeanFactory&lt;/h2&gt;
&lt;p&gt;接着进入 refresh 中的 obtainFreshBeanFactory 方法&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public abstract class AbstractApplicationContext {
    
    ...
    
    public void refresh() throws BeansException, IllegalStateException {
        synchronized (this.startupShutdownMonitor) {
            
            ...
            
            ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();
    
            ...
        }
    }
    ...
    
    protected ConfigurableListableBeanFactory obtainFreshBeanFactory() {
        // 该方法也是由子类扩展，其子类有 AbstractRefreshableApplicationContext 和 GenericApplicationContext，
        // 因当前是 Servlet Web 应用，所以执行的是 GenericApplicationContext 中的 refreshBeanFactory 方法。
        // 该方法主要设置 BeanFactory 的 serializationId 属性值，也就是序列化id
        refreshBeanFactory();
        
        // 通过 getBeanFactory 返回 BeanFactory 对象。同样也是由子类扩展，调用的是 GenericApplicationContext 类中的 getBeanFactory 方法。
        // 返回的是 DefaultListableBeanFactory 。
        ConfigurableListableBeanFactory beanFactory = getBeanFactory();
        if (logger.isDebugEnabled()) {
            logger.debug(&quot;Bean factory for &quot; + getDisplayName() + &quot;: &quot; + beanFactory);
        }
        return beanFactory;
    }
    
    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;obtainFreshBeanFactory 方法很简单，但如果当前是非 Servlet Web 应用，执行的就是 AbstractRefreshableApplicationContext 中的 refreshBeanFactory 方法，那可就复杂多了，这里就不展开讨论。之后，该方法还返回了 BeanFactory 对象，从这也可以看出 ApplicationContext 底层是以 BeanFactory 为基础，逐步扩展 Spring 容器功能。&lt;/p&gt;
&lt;h2 id=&quot;第三步preparebeanfactory&quot;&gt;第三步：prepareBeanFactory&lt;/h2&gt;
&lt;p&gt;接着进入 refresh 中的 prepareBeanFactory 方法。prepareBeanFactory 方法主要是对 BeanFactory 做一些配置，包含各种类加载器、需要忽略的依赖以及后置处理器、解析器等，&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void refresh() throws BeansException, IllegalStateException {
    synchronized (this.startupShutdownMonitor) {
            
        ...
        
        prepareBeanFactory(beanFactory);
        ... 
    }
    ...
}

protected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) {
    // 设置类加载器
    beanFactory.setBeanClassLoader(getClassLoader());
    // 设置表达式解析器，主要用来解析 EL 表达式； Bean 初始化完成后填充属性时会用到
    beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));
    // 设置属性注册解析器，主要用来解析 Bean 中的各种属性类型，如 String、int 等
    beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment()));
    // 添加一个后置处理器：ApplicationContextAwareProcessor。
    // 该后置处理器用于向实现了 Aware 系列接口的 bean 设置相应属性。
    // （后置处理器和 Aware 接口也是比较核心的概念，后面会有文章详细讨论）
    beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));
    
    // 以下接口，在自动注入时会被忽略，其都是 Aware 系列接口
    beanFactory.ignoreDependencyInterface(EnvironmentAware.class);
    beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);
    beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);
    beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);
    beanFactory.ignoreDependencyInterface(MessageSourceAware.class);
    beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);

    // 当以下特殊的 Bean 需自动注入时，指定其注入的类型 。
    // 如：注入 BeanFactory 时，注入的类型对象为 ConfigurableListableBeanFactory 。
    beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);
    beanFactory.registerResolvableDependency(ResourceLoader.class, this);
    beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this);
    beanFactory.registerResolvableDependency(ApplicationContext.class, this);

    // 添加 ApplicationListenerDetector 后置处理器。
    // 该后置处理器用来检测那些实现了 ApplicationListener 接口的 bean，并将其添加到应用上下文的事件广播器上。
    beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this));

    // 判断容器中是否存在 loadTimeWeaver Bean，如果存在则上下文使用临时的 ClassLoader 进行类型匹配。
    // 集成 AspectJ 时会用到 loadTimeWeaver 对象。
    if (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {
        beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));
        beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));
    }

    // 注册和环境相关的 Bean，如 environment、systemProperties、systemEnvironment
    if (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) {
        beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());
    }
    if (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) {
        beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());
    }
    if (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) {
        beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 prepareBeanFactory 方法中，主要对 BeanFactory 添加了一系列属性项，如添加忽略自动注入的接口、添加 BeanPostProcessor 后置处理器、手动注册部分特殊的 Bean及环境相关的 Bean 。&lt;/p&gt;
&lt;h2 id=&quot;第四步postprocessbeanfactory&quot;&gt;第四步：postProcessBeanFactory&lt;/h2&gt;
&lt;p&gt;postProcessBeanFactory 方法是上下文准备的最后一步，主要用来注册 Web 请求相关的处理器、Bean及配置。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void refresh() throws BeansException, IllegalStateException {
    synchronized (this.startupShutdownMonitor) {
        
        ...
        
        postProcessBeanFactory(beanFactory);
        ...   
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该方法也是由子类进行扩展，实现该方法的子类有：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwgy1gb7hzdoecoj32kw0rgdsu.jpg&quot; alt=&quot;image&quot;/&gt;&lt;br/&gt;前面也说过，当前是 Servlet Web 应用，所以创建的 ApplicationContext 上下文是 AnnotationConfigServletWebServerApplicationContext，执行该类的 postProcessBeanFactory 方法。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class AnnotationConfigServletWebServerApplicationContext
        extends ServletWebServerApplicationContext implements AnnotationConfigRegistry {

    private final AnnotatedBeanDefinitionReader reader;

    private final ClassPathBeanDefinitionScanner scanner;

    private final Set&amp;lt;Class&amp;lt;?&amp;gt;&amp;gt; annotatedClasses = new LinkedHashSet&amp;lt;&amp;gt;();

    private String[] basePackages;
    
    ...
    
    @Override
    protected void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {
        // 先执行父类 ServletWebServerApplicationContext 的 postProcessBeanFactory 方法。
        // 跳转到 1 查看父类实现
        super.postProcessBeanFactory(beanFactory);
        
        // basePackages 存储的是类路径。先判断是否为 null，不为 null 则通过 ClassPathBeanDefinitionScanner 的 scan 方法
        // 扫描该路径下符合条件的 Class，并将 Class 信息包装成 BeanDefinition 注册到容器中，
        // 当然，这里没有指定扫描路径，所以不会进入这个 if。
        // （BeanDefinition 概念会在后面章节详细讨论）
        if (this.basePackages != null &amp;amp;&amp;amp; this.basePackages.length &amp;gt; 0) {
            this.scanner.scan(this.basePackages);
        }
        
        // annotatedClasses 存储的 Class 集合。先判断该集合是否为空，不为空则通过
        // AnnotatedBeanDefinitionReader 的 register 方法将 Class 信息包装成 BeanDefinition 注册到容器中，
        // 这里同样没有设置 Class 集合内容，所以不会进入这个 if。
        if (!this.annotatedClasses.isEmpty()) {
            this.reader.register(ClassUtils.toClassArray(this.annotatedClasses));
        }
    }       
}

1、
public class ServletWebServerApplicationContext extends GenericWebApplicationContext
        implements ConfigurableWebServerApplicationContext {
    ...

    @Override
    protected void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {
        // 添加 BeanPostProcessor 后置处理器：WebApplicationContextServletContextAwareProcessor，
        // 该后置处理器主要是从 ConfigurableWebApplicationContext 上下文中获取 ServletContext 和 ServletConfig 对象
        beanFactory.addBeanPostProcessor(new WebApplicationContextServletContextAwareProcessor(this));
        
        // 添加一个 忽略自动注入的接口
        beanFactory.ignoreDependencyInterface(ServletContextAware.class);
    }
    ...         
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;postProcessBeanFactory 方法执行的操作和前面类似，也是添加了后置处理器和忽略自动注入的接口。&lt;/p&gt;

&lt;p&gt;ApplicationContext 上下文准备工作基本结束，主要还是在 BeanFactory 中添加一系列后置处理器、注册特殊的 Bean 及设置忽略自动注入的接口。其中还提到了 Spring 容器的三个核心部分：Aware 系列接口、BeanPostProcessor 后置处理器、BeanDefinition ，这部分在后面的文章会逐步讨论。接下来将对 Spring 容器的核心功能展开讨论。&lt;/p&gt;

&lt;p&gt;以上就是本章内容，如果文章中有错误或者需要补充的请及时提出，本人感激不尽。&lt;/p&gt;
</description>
<pubDate>Sat, 25 Jan 2020 13:15:00 +0000</pubDate>
<dc:creator>龙四丶</dc:creator>
<og:description>[toc] 前言 前面介绍了 Spring 容器的概念，其核心可归纳为两个类： BeanFactory 和 ApplicationContext，ApplicationContext 继承自 Bean</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/loongk/p/12233417.html</dc:identifier>
</item>
<item>
<title>【自制操作系统03】读取硬盘中的数据 - 闪客sun</title>
<link>http://www.cnblogs.com/flashsun/p/12232630.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/flashsun/p/12232630.html</guid>
<description>&lt;p&gt;通过 &lt;a href=&quot;https://www.cnblogs.com/flashsun/p/12218813.html&quot;&gt;【自制操作系统01】硬核讲解计算机的启动过程&lt;/a&gt; 和 &lt;a href=&quot;https://www.cnblogs.com/flashsun/p/12218865.html&quot;&gt;【自制操作系统02】环境准备与启动区实现&lt;/a&gt; 的讲解，我们已经实现了一个最简单的操作系统（仅仅一条机器指令）。&lt;/p&gt;
&lt;p&gt;今天我们要再往前进一步，逐渐将这个最简单的操作系统完善起来。之前最简单的操作系统是写在启动区的 512 字节里，这么小的空间以后肯定不能全部用来写操作系统的代码，所以它的主要任务就是将硬盘中更多的数据读取到内存里，并跳转到内存的那个位置开始运行。&lt;/p&gt;
&lt;p&gt;这里不得不回顾一下每节课都说到的四次跳跃：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;一跳&lt;/strong&gt;：按下开机键，CPU 将 PC 寄存器的值强制初始化为 0xffff0，这个位置是 BIOS 程序的入口地址&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;二跳&lt;/strong&gt;：该入口地址处是一个跳转指令，跳转到 0xfe05b 位置，开始执行&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;三跳&lt;/strong&gt;：执行了一些硬件检测工作后，最后一步将启动区内容加载（复制）到内存 0x7c00，并跳转到这里&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;四跳&lt;/strong&gt;：启动区代码主要是加载操作系统内核，并跳转到加载处&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;其实我们可以无限跳跃下去，只要感觉某一个环节的任务复杂了，就可以分成两步来走。但也完全可以从第三跳开始就再也不跳转了，把所有操作系统需要的指令和数据都从硬盘中加载到内存，然后执行，但这样显然不好。&lt;/p&gt;
&lt;h2 id=&quot;一代码总览&quot;&gt;一、代码总览&lt;/h2&gt;
&lt;p&gt;先不说别的，先发上来一份本章内容的全部代码&lt;/p&gt;
&lt;h4 id=&quot;mbr.asm&quot;&gt;mbr.asm&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;;----BIOS把启动区加载到内存的该位置，所以需设置地址偏移量
section mbr vstart=0x7c00

;----设置堆栈地址
mov sp,0x7c00

;----卷屏中断，目的是清屏
mov ax,0x0600
mov bx,0x0700
mov cx,0
mov dx,0x184f
int 0x10

;----直接往显存中写数据
mov ax,0xb800
mov gs,ax
mov byte [gs:0x00],'m'
mov byte [gs:0x02],'b'
mov byte [gs:0x04],'r'

;----读取硬盘（第2扇区）并加载到内存（0x900)
mov eax,0x02    ;起始扇区lba地址，LBA=(柱面号*磁头数+磁头号)*扇区数+扇区编号-1
mov bx,0x900    ;写入的内存地址，之后用
mov cx,4        ;待读入的扇区数
call read_disk
jmp 0x900

;----读硬盘方法，eax为lba扇区号，bx为待写入内存地址，cx为读入的扇区数
read_disk:
    mov esi,eax ;备份
    mov di,cx   ;备份
    
;第一步，设置要读取的扇区数
    mov dx,0x1f2
    mov al,cl
    out dx,al
    mov eax,esi ;恢复
    
;第二步，设置LBA地址
    mov cl,8
    ;0-7位写入0x1f3
    mov dx,0x1f3
    out dx,al
    ;8-15位写入0x1f4
    mov dx,0x1f4
    shr eax,cl
    out dx,al
    ;16-23位写入0x1f5
    mov dx,0x1f5
    shr eax,cl
    out dx,al
    ;24-27位写入0x1f6
    mov dx,0x1f6
    shr eax,cl
    and al,0x0f ;lba的24-27位
    or al,0xe0  ;另外4位为1110，表示lba模式
    out dx,al
    
;第三步，写入读命令
    mov dx,0x1f7
    mov al,0x20
    out dx,al

;第四步，检测硬盘状态
.not_ready:
    nop
    in al,dx
    and al,0x88 ;第4位为1表示准备好，第7位为1表示忙
    cmp al,0x08
    jnz .not_ready
    
;第五步，读数据
    mov ax,di
    mov dx,256
    mul dx
    mov cx,ax
    
    mov dx,0x1f0
    .go_on_read:
        in ax,dx
        mov [bx],ax
        add bx,2
        loop .go_on_read
        ret
    
;----512字节的最后两字节是启动区标识
times 510-($-$$) db 0
db 0x55,0xaa&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;loader.asm&quot;&gt;loader.asm&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;section loader vstart=0x900
mov byte [gs:0xa0],'l'
mov byte [gs:0xa2],'o'
mov byte [gs:0xa4],'a'
mov byte [gs:0xa6],'d'
mov byte [gs:0xa8],'e'
mov byte [gs:0xaa],'r'&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;makefile&quot;&gt;Makefile&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;mbr.bin: mbr.asm
    nasm -I include/ -o out/mbr.bin mbr.asm -l out/mbr.lst
    
loader.bin: loader.asm
    nasm -I include/ -o out/loader.bin loader.asm -l out/loader.lst
    
os.raw: mbr.bin loader.bin
    ../bochs/bin/bximage -hd -mode=&quot;flat&quot; -size=60 -q target/os.raw
    dd if=out/mbr.bin of=target/os.raw bs=512 count=1
    dd if=out/loader.bin of=target/os.raw bs=512 count=4 seek=2
    
brun:
    make install
    make only-bochs-run
    
only-bochs-run:
    ../bochs/bin/bochs -f ../bochs/bochsrc.disk -q
    
install:
    make clean
    make -r os.raw
    
clean:
    rm -rf target/*
    rm -rf out/*&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;二磁盘&quot;&gt;二、磁盘&lt;/h2&gt;
&lt;p&gt;如果你粗略地读了一下代码，起码可以知道 mbr.asm 中的代码，前半部分是在屏幕上输出一个 mbr 字符串，这是上节课为了做最小操作系统而用直观方式写的代码，可有可无。后半部分仅仅是读取了几个扇区的硬盘数据，加载到内存中的某个位置，然后跳转到此位置，这部分是关键，也是 mbr 的职责所在。&lt;/p&gt;
&lt;p&gt;那怎么读取硬盘中的数据呢，这就要从磁盘的结构说起。硬件的东西并不是很懂，所以也只能说个大概。硬盘属于磁盘的一种，磁盘分为硬盘和软盘。但他们的逻辑结构是一样的：&lt;/p&gt;
&lt;p&gt;盘片（platter）&lt;br/&gt;磁头（head）&lt;br/&gt;磁道（track）&lt;br/&gt;扇区（sector）&lt;br/&gt;柱面（cylinder）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1096103/202001/1096103-20200124221117441-1025681554.png&quot; alt=&quot;机械式硬盘示意图&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我不想管它怎么动的，我只需要想明白，确定一个磁头、柱面、扇区，就确定了一个 512 字节大小的区域，这就够了。这也就是硬盘的 &lt;strong&gt;CHS 表示法&lt;/strong&gt;，即 Cylinder（柱面）、Head（磁头）、Sector（扇区），只要知道了硬盘的 CHS 的数目，即可确定硬盘的容量，&lt;strong&gt;硬盘的容量 = 柱面数 × 磁头数 × 扇区数 × 512B&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如果不考虑这个物理结构，其实硬盘就是 n 多个 512 字节的区域构成的，我们完全可以从 0 开始编号，每 512 字节加一，这样就可以完全不用考虑什么扇区啦，柱面啦，这种是我比较喜欢的（看来还是软件工程师思想呀），这种方式叫做 &lt;strong&gt;LBA 表示法&lt;/strong&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;LBA = (柱面号 * 磁头数 + 磁头号) * 扇区数 + 扇区编号 - 1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以 CPU 要和硬盘打交道，要么用这个 CHS 表示法，就至少要告诉硬盘柱面、磁头、扇区号是多少，要么用 LBA 表示法告诉硬盘一个 LBA 号码，然后再给硬盘一个是读还是写的信号。硬盘制作厂商千千万，CPU制作厂商也是各不相同，自然就会想到一定有一个硬盘接口标准，这个标准就叫做 &lt;strong&gt;ATA 标准&lt;/strong&gt;，也可以俗称为 &lt;strong&gt;IDE 硬盘接口技术标准&lt;/strong&gt;。这个标准可以下载 AT_Attachment_with_Packet_Interface 共三册的内容，但我们用不到那么多，我这里找到了一个还算原汁原味的中文版的论文 &lt;a href=&quot;https://files.cnblogs.com/files/flashsun/IDE%E6%8E%A5%E5%8F%A3%E7%A1%AC%E7%9B%98%E8%AF%BB%E5%86%99%E6%8A%80%E6%9C%AF.rar&quot;&gt;《IDE接口硬盘读写技术》&lt;/a&gt; ，看这个基本就够用了。&lt;/p&gt;
&lt;h2 id=&quot;三ide硬盘接口技术&quot;&gt;三、IDE硬盘接口技术&lt;/h2&gt;
&lt;p&gt;CPU 与外设是通过 IO 接口交互的，所以最核心的就是这个技术标准定义的 IO 接口都有哪些，分别有什么作用&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;10&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;1F0H&lt;/td&gt;
&lt;td&gt;数据寄存器&lt;/td&gt;
&lt;td&gt;数据寄存器&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;1F1H&lt;/td&gt;
&lt;td&gt;错误寄存器(只读寄存器)&lt;/td&gt;
&lt;td&gt;特征寄存器&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;1F2H&lt;/td&gt;
&lt;td&gt;扇区计数寄存器&lt;/td&gt;
&lt;td&gt;扇区计数寄存器&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;1F3H&lt;/td&gt;
&lt;td&gt;扇区号寄存器或 LBA 块地址 0~7&lt;/td&gt;
&lt;td&gt;扇区号或 LBA 块地址 0~7&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;1F4H&lt;/td&gt;
&lt;td&gt;磁道数低 8 位或 LBA 块地址 8~15&lt;/td&gt;
&lt;td&gt;磁道数低 8 位或 LBA 块地址 8~15&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;1F5H&lt;/td&gt;
&lt;td&gt;磁道数高 8 位或 LBA 块地址 16~23&lt;/td&gt;
&lt;td&gt;磁道数高 8 位或 LBA 块地址 16~23&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;1F6H&lt;/td&gt;
&lt;td&gt;驱动器/磁头或 LBA 块地址 24~27&lt;/td&gt;
&lt;td&gt;驱动器/磁头或 LBA 块地址 24~27&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;1F7H&lt;/td&gt;
&lt;td&gt;命令寄存器或状态寄存器&lt;/td&gt;
&lt;td&gt;命令寄存器&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;所以如果要写一个程序来读文件的话，不难分析出整个过程就是：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;在 1F2H 写入要读取的扇区数&lt;/li&gt;
&lt;li&gt;在 1F3H ~ 1F6H 这四个端口写入计算好的起始 LBA 地址&lt;/li&gt;
&lt;li&gt;在 1F7H 处写入读命令的指令号&lt;/li&gt;
&lt;li&gt;不断检测 1F7H （此时已成为状态寄存器的含义）的忙位&lt;/li&gt;
&lt;li&gt;如果第四步骤为不忙，则开始不断从 1F0H 出读取数据到内存指定位置，知道读完&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这五步刚刚好对应着上面的代码&lt;/p&gt;
&lt;p&gt;最后，别忘了我们这些代码仍然是要加载到启动区的，所以最后两个字节依然要是启动区标识符 0x55 0xaa&lt;/p&gt;
&lt;h2 id=&quot;四运行代码&quot;&gt;四、运行代码&lt;/h2&gt;
&lt;p&gt;写好了 mbr.asm，我们再写一个 loader.asm，设置其起始地址为 0x900（因为读写磁盘后存入的内存位置就是这个，这是我们自己定义的），并把它放在磁盘的第二扇区（这也是我们自己定的，只要和读盘的代码保持一致就行）&lt;/p&gt;
&lt;p&gt;#### loader.asm&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;section loader vstart=0x900
mov byte [gs:0xa0],'l'
mov byte [gs:0xa2],'o'
mov byte [gs:0xa4],'a'
mov byte [gs:0xa6],'d'
mov byte [gs:0xa8],'e'
mov byte [gs:0xaa],'r'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;剩下的精华就在于我们的 Makefile 文件了，可以参考下上面的代码&lt;/p&gt;
&lt;p&gt;执行 make brun，可以看到如下效果，说明加载磁盘中的 loader 代码到内存这个过程生效了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1096103/202001/1096103-20200125173135159-2079203969.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;五开源项目和课程规划&quot;&gt;五、开源项目和课程规划&lt;/h2&gt;
&lt;p&gt;如果你对自制一个操作系统感兴趣，不妨跟随这个系列课程看下去，甚至加入我们，一起来开发。&lt;/p&gt;
&lt;h4 id=&quot;参考书籍&quot;&gt;参考书籍&lt;/h4&gt;
&lt;p&gt;《操作系统真相还原》这本书真的赞！强烈推荐&lt;/p&gt;
&lt;h4 id=&quot;项目开源&quot;&gt;项目开源&lt;/h4&gt;
&lt;blockquote readability=&quot;1.875&quot;&gt;
&lt;p&gt;项目开源地址：&lt;a href=&quot;https://gitee.com/sunym1993/flashos&quot; class=&quot;uri&quot;&gt;https://gitee.com/sunym1993/flashos&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当你看到该文章时，代码可能已经比文章中的又多写了一些部分了。你可以通过提交记录历史来查看历史的代码，我会慢慢梳理提交历史以及项目说明文档，争取给每一课都准备一个可执行的代码。当然文章中的代码也是全的，采用复制粘贴的方式也是完全可以的。&lt;/p&gt;
&lt;p&gt;如果你有兴趣加入这个自制操作系统的大军，也可以在留言区留下您的联系方式，或者在 gitee 私信我您的联系方式。&lt;/p&gt;
&lt;h4 id=&quot;课程规划&quot;&gt;课程规划&lt;/h4&gt;
&lt;p&gt;本课程打算出系列课程，我写到哪觉得可以写成一篇文章了就写出来分享给大家，最终会完成一个功能全面的操作系统，我觉得这是最好的学习操作系统的方式了。所以中间遇到的各种坎也会写进去，如果你能持续跟进，跟着我一块写，必然会有很好的收货。即使没有，交个朋友也是好的哈哈。&lt;/p&gt;
&lt;p&gt;目前的系列包括&lt;/p&gt;
</description>
<pubDate>Sat, 25 Jan 2020 09:38:00 +0000</pubDate>
<dc:creator>闪客sun</dc:creator>
<og:description>通过 &amp;quot;【自制操作系统01】硬核讲解计算机的启动过程&amp;quot; 和 &amp;quot;【自制操作系统02】环境准备与启动区实现&amp;quot; 的讲解，我们已经实现了一个最简单的操作系统（仅仅一条机</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/flashsun/p/12232630.html</dc:identifier>
</item>
<item>
<title>高通量计算框架HTCondor(五)——分布计算 - charlee44</title>
<link>http://www.cnblogs.com/charlee44/p/12233064.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/charlee44/p/12233064.html</guid>
<description>&lt;h2 id=&quot;任务描述文件&quot;&gt;1.1. 任务描述文件&lt;/h2&gt;
&lt;p&gt;前文提到过，HTCondor是通过condor_submit命令将提交任务的，这个命令需要提供一个任务描述文件。这个任务描述文件详细描述了任务运行的需求情况，如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;universe = vanilla
requirements = (Arch == &quot;INTEL&quot; || Arch == &quot;X86_64&quot;) &amp;amp;&amp;amp; (OpSys == &quot;WINDOWS&quot;) &amp;amp;&amp;amp; (Machine == &quot;charlee-PC&quot; || Machine == &quot;DESKTOP-OVHV440&quot;) 
executable = D:\Work\HTC\Work\bin\TaskProgram.exe
should_transfer_files = YES
when_to_transfer_output = on_exit
notification = complete
skip_filechecks = true

arguments = 0
initialdir = D:\Work\HTC\Work\0
transfer_input_files = input.txt
transfer_output_files = output.dat
output = $(CLUSTER)_$(PROCESS).out
log = $(CLUSTER)_$(PROCESS).log
error = $(CLUSTER)_$(PROCESS).error
queue

arguments = 1
initialdir = D:\Work\HTC\Work\1
transfer_input_files = input.txt
transfer_output_files = output.dat
output = $(CLUSTER)_$(PROCESS).out
log = $(CLUSTER)_$(PROCESS).log
error = $(CLUSTER)_$(PROCESS).error
queue

...

arguments = 15
initialdir = D:\Work\HTC\Work\15
transfer_input_files = input.txt
transfer_output_files = output.dat
output = $(CLUSTER)_$(PROCESS).out
log = $(CLUSTER)_$(PROCESS).log
error = $(CLUSTER)_$(PROCESS).error
queue&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;universe参数表示HTCondor的运行环境，默认为vanilla。vanilla提供的功能会少一些，但是使用也会较为方便。如果要使用一些高级的功能，可以使用standard环境，standard环境提供了断点和迁移的功能，不过需要一些额外的重链接操作生成特定的可执行程序。&lt;/p&gt;
&lt;p&gt;requirements参数表示该一系列任务的需求。HTCondor采取了一种ClassAds匹配策略，每台计算机会一直在Pool中广播关于自己资源的Ad，通过这个参数，可以匹配该任务是否与该计算机适配。这里设置的意思是选择X86的Windows机器，且机器名称为&quot;charlee-PC&quot;或&quot;DESKTOP-OVHV440&quot;。使用&quot;name == &quot;slot1@USER-EHN3KRBP1V&quot;的形式，甚至可以指定到某一核来运行。&lt;/p&gt;
&lt;p&gt;executable也就是上一篇中实现的可执行程序。&lt;/p&gt;
&lt;p&gt;should_transfer_files表示使用文件传输机制。文件传输机制也就是任务程序需要的数据，跟随任务程序一起发送到任务机中运行。如果不使用文件传输机制，就需要如NFS或AFS这样的共享文件系统。&lt;/p&gt;
&lt;p&gt;when_to_transfer_output = on_exit表示当任务程序完成之后，会有输出的文件一起传送回本机。&lt;/p&gt;
&lt;p&gt;接下来arguments开头queue结尾的代码描述了16组任务的详细描述。initialdir是初始化目录，也就是上一节中创建的每个分任务的目录。&lt;/p&gt;
&lt;p&gt;transfer_input_files表示传送到任务机的文件。这个参数可以设置成具体的文件，目录，设置是可执行程序依赖的dll。注意发送到任务机后这些文件与执行任务文件在同一个目录中。&lt;/p&gt;
&lt;p&gt;when_to_transfer_output表示发送回本机的文件。当任务程序运行完成后，会生成处理好的数据，可以通过这个参数将文件传送回本机。&lt;/p&gt;
&lt;p&gt;output表示任务程序的输出文件，可以截获任务程序的stdout流。&lt;/p&gt;
&lt;p&gt;log表示集群执行任务程序的状态，一般是HTCondor框架自动生成。&lt;/p&gt;
&lt;p&gt;error表示任务程序的错误文件，可以截获任务程序的stderr流。&lt;/p&gt;
&lt;h2 id=&quot;提交任务&quot;&gt;1.2. 提交任务&lt;/h2&gt;
&lt;p&gt;在命令提示符窗口中输入condor_submit指令：&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1000410/202001/1000410-20200125145956589-414460745.png&quot; alt=&quot;condor_submit指令&quot;/&gt;&lt;/div&gt;
&lt;p&gt;可以看到成功提交后，返回了一个任务ID号。可以通过condor_q指令查看当前的任务队列状态：&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1000410/202001/1000410-20200125150009862-463145238.png&quot; alt=&quot;condor_q指令&quot;/&gt;&lt;/div&gt;
&lt;p&gt;ST这一列的I代表idle，也就是闲置的。这时由于任务刚提交上去，还来不及匹配任务机器或者没有更新状态，多刷新几次，可以看到这一栏会编程R，也就是Run，表示运行状态：&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1000410/202001/1000410-20200125150020310-1177865662.png&quot; alt=&quot;condor_q指令&quot;/&gt;&lt;/div&gt;
&lt;p&gt;继续输入condor_status,查看当前计算机资源的情况。这时的状态刷新会更慢些，也可以多输入几次：&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1000410/202001/1000410-20200125150030838-895218165.png&quot; alt=&quot;condor_status指令&quot;/&gt;&lt;/div&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1000410/202001/1000410-20200125150041384-1623080672.png&quot; alt=&quot;condor_status指令&quot;/&gt;&lt;/div&gt;
&lt;p&gt;State表示资源占用情况，Claimed表示已占用，Claimed表示未占用。Activity表示当前的活动状态，Idle就是闲置，Busy表示繁忙。&lt;/p&gt;
&lt;p&gt;通过以上指令，可以查看当前任务是否正常。等待直到condor_q中的任务队列为空，就说明当前所有的任务已经完成了。&lt;/p&gt;
&lt;h2 id=&quot;返回结果&quot;&gt;1.3. 返回结果&lt;/h2&gt;
&lt;p&gt;根据任务描述文件，任务程序会返回一个输出数据output.dat已经相关的日志信息.log、.out、.error。任务完成后会回传到各自的初始化目录中：&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1000410/202001/1000410-20200125150051408-2037620643.png&quot; alt=&quot;返回结果&quot;/&gt;&lt;/div&gt;
&lt;p&gt;.out是任务程序的stdout流，可以用来输出信息；.error是任务程序的stderr流，可以用来输出错误信息。在任务程序中输出信息和日志是必要的，可以第一事件排查是哪一段代码出问题。如果连这两个文件都没有，可以考虑是否是HTCondor的环境配置问题，或者任务描述文件是否出错。&lt;/p&gt;
&lt;p&gt;.log是HTCondor的输出日志，可以用来参考。output.dat就是任务程序的输出数据了，当然这个数据因任务程序而异，任务程序输出什么，任务描述文件就返回对应的数据，当然也可以什么都不用返回。&lt;/p&gt;
&lt;p&gt;在HTCondor任务程序计算的过程中，会把任务程序传送到对应的任务机器，也就是任务机器HTCondor安装目录的execute目录中，运行时会看到任务程序，以及传送过来的数据等:&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1000410/202001/1000410-20200125150101787-395890507.png&quot; alt=&quot;返回结果&quot;/&gt;&lt;/div&gt;
&lt;p&gt;当然，在运行完成后，这个execute目录就会自动清空。&lt;/p&gt;
&lt;p&gt;至此，一个简单的分布式计算流程就算完成了。实际的运用当然没这么简单，但是总体的思路都是这样的：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;拆分任务——提交任务——监视任务——任务完成——合并结果。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/fafa1899/HTC&quot;&gt;代码和数据地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/charlee44/p/12232507.html&quot;&gt;上一篇&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/charlee44/p/12204715.html&quot;&gt;目录&lt;/a&gt;&lt;br/&gt;下一篇&lt;/p&gt;
</description>
<pubDate>Sat, 25 Jan 2020 07:05:00 +0000</pubDate>
<dc:creator>charlee44</dc:creator>
<og:description>使用一个实例进行简单的分布式计算。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/charlee44/p/12233064.html</dc:identifier>
</item>
<item>
<title>Linux内存管理解析(一) : 分段与分页机制 - Vizdl</title>
<link>http://www.cnblogs.com/vizdl/p/12233033.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/vizdl/p/12233033.html</guid>
<description>&lt;p&gt;&lt;span&gt;背景 : 在此文章里会从分页分段机制去解析Linux内存管理系统如何工作的,由于Linux内存管理过于复杂而本人能力有限。会尽量将自己总结归纳的部分写清晰。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;从实模式到保护模式的寻址方式的不同 : &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　16位CPU的寻址方式 : 在 8086 CPU 中,提供了两类寄存器来进行寻址,分别为&lt;strong&gt;段寄存器(例如 CS,DS,SS)&lt;/strong&gt;和&lt;strong&gt;段偏移寄存器(例如 SI,DI,SP)。&lt;/strong&gt;而这几种寄存器的长度都为16bit,寻址方式也很简单 : cs:ip = (cs &amp;lt;&amp;lt; 4 + ip)。也就是说 cs寄存器的值左移4位加上ip的值得到的就是&lt;strong&gt;物理地址(物理地址就是内存中真实的值)。&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;/strong&gt;32位CPU的寻址方式 : 在80X86 CPU 中,提供了&lt;strong&gt;分段与分页机制&lt;/strong&gt;。对于CPU的寻址而言,不再像 8086 CPU 那般将 段寄存器段偏移寄存器 直接运算得到结果。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;1)那么在32位CPU中是如何寻址的呢?&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;i)如何开启分页分段模式?&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　首先要介绍的就是 &lt;strong&gt;CR0 寄存器&lt;/strong&gt;(如下图):&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/common/1409682/202001/1409682-20200125130832727-567672857.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　　　　&lt;span&gt;对于CR0来说,存在两个bit : &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　PE位 :  如若置位(1)则表示开启保护(分段)模式。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　PG位 : 在PE位置位的前提下置位PG位表示开启分页模式。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;ii)分段机制如何进行寻址(得到&lt;span&gt;线性地址&lt;/span&gt;)?&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　简述 : 段寄存器(例如CS) 里面存在一个索引(index),它会根据GDTR寄存器找到一个表(GDT),然后这个表里面有元素,元素内部含有段基址。而这个段基址加上段变址寄存器的值就直接得到了线性地址的值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　详述 :&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　在开启分段模式之后,段寄存器里面的值的含义就不再只是一个简单&lt;strong&gt;段基址&lt;/strong&gt;了(也就是 (cs &amp;lt;&amp;lt; 4)得到段基址),当下段寄存器加载的值称为&lt;strong&gt;段选择子&lt;/strong&gt;,结构如下:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/common/1409682/202001/1409682-20200125132736050-1661828081.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　可以看到这里有一个由几个bit组成的 &lt;strong&gt;描述符索引(也就是简述里所说的index)&lt;/strong&gt;,以及TI和RPL位(但目前不用管它)。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　GDTR : &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/common/1409682/202001/1409682-20200125133654049-1054196316.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　可以看到GDTR和IDTR(这个其实是另一个类似于GDTR的寄存器)都是由&lt;strong&gt;线性基地址&lt;/strong&gt;和&lt;strong&gt;表长度&lt;/strong&gt;组成,线性基地址也就是说这个表的头部所在的线性基地址(类似于数组名),表长度也就是这个表的长度啦。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　那么自然我们就能得到一个类似于数组(由连续的地址组成)的表。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　对于这个&quot;数组&quot;来说,它的元素则被称为 &lt;strong&gt;段描述符&lt;/strong&gt;:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/common/1409682/202001/1409682-20200125134420910-299563545.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　可以看到段描述符很长(一共64bit)...但是没关系,我们当下只需要把其分为三个部分 : 段基地址,段限长,段属性。即可。(这里之所以基地址和段限长啥的分了几个部分主要是因为历史遗留问题,但是没关系,他们只不过需要把几个分开的连在一起就能得到了真正的段基地址了)。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　那么得到了段基址,我们自然将其与段变址寄存器内的值相加就得到了线性地址了！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　iii)分页机制如何进行寻址(得到&lt;span&gt;&lt;strong&gt;物理地址&lt;/strong&gt;&lt;/span&gt;)?&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　如若我们开始分页了,那么就表示我们已经得到了一个线性地址(分页是在分段的基础上进行的)。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　简述 : 首先我们把线性地址分为几个部分,&lt;strong&gt;目录(本质是页目录表的索引)&lt;/strong&gt;,&lt;strong&gt;页面(本质是页表的索引)&lt;/strong&gt;,&lt;strong&gt;页内偏移(本质是偏移量)&lt;/strong&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　由 &lt;strong&gt;CR3寄存器&lt;/strong&gt; 作为 &lt;strong&gt;页目录表&lt;/strong&gt; 的指针,通过CR3寄存器就可以得到一个表称为页目录表,页目录表内元素 称为 页目录项, 页目录项本质也是一个指针,指向一个 页表, 而页表内元素称为页表项,页表项内存在着 页基地址, 物理地址 = 页基地址(物理基地址) + 页内偏移(物理偏移地址)。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　简单来说我们可以把 页目录表和页表想象成一个二维的数组。页目录表元素是页表(一维数组),页表元素则是页基地址。 &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/common/1409682/202001/1409682-20200125141351591-489675549.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;span&gt;我们只需要有两个元素(页目录表索引和页表索引)就可以得到一个物理(页)基地址,然后我们再将 页内偏移加上物理基地址,就得到了真正的物理地址了！而一个页在80x86中是4K大小(页基址 至 页基址 + 4K 为一页)。所以内存管理的页也是4K大小。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　附图(寄存器数据) :&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/common/1409682/202001/1409682-20200125142258007-1486387727.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　由图我门可以知道,页基地址(页帧),是4K对齐的(2^12 = 4K),也就是说页表项内只有12 - 31位是页基地址,其他的位是页属性,每次通过页表项计算物理地址只需要将 0 - 11位复位(0),即可。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　对于页属性 : 表述这个页的权限之类的,因为有的页面是属于内核才能去使用的。&lt;strong&gt;更重要的一点是 : 这个页是否存在。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　　　页目录和页表的表项格式:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/common/1409682/202001/1409682-20200125143057212-682966711.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;span&gt;如图所示 : 我们可以知道当 &lt;strong&gt;P位&lt;/strong&gt; 被置位则表示页面存在,当 &lt;strong&gt;P位&lt;/strong&gt;复位(为0) 则表示页面不存在,如若页面不存在,那么就会产生&lt;strong&gt;缺页中断&lt;/strong&gt;,执行&lt;strong&gt;缺页中断处理程序&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 25 Jan 2020 06:35:00 +0000</pubDate>
<dc:creator>Vizdl</dc:creator>
<og:description>背景 : 在此文章里会从分页分段机制去解析Linux内存管理系统如何工作的,由于Linux内存管理过于复杂而本人能力有限。会尽量将自己总结归纳的部分写清晰。 从实模式到保护模式的寻址方式的不同 : 1</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/vizdl/p/12233033.html</dc:identifier>
</item>
<item>
<title>Java框架之MyBatis 07-动态SQL-缓存机制-逆向工程-分页插件 - 远离颠倒梦想</title>
<link>http://www.cnblogs.com/Open-ing/p/12232989.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Open-ing/p/12232989.html</guid>
<description>&lt;h2&gt;MyBatis&lt;/h2&gt;
&lt;h3&gt;　　今天大年初一，你在学习！不学习做什么，斗地主...人都凑不齐。学习吧，学习使我快乐！除了诗和远方还有责任，我也想担当，我也想负责，可臣妾做不到啊，怎么办？你说怎么办，为啥人家能做到你做不到，因为人家比你多做了那么一点点。哪一点点？就那么一点点，只要你也多做那么一点点，不就做到了！...就那么一点点呀，我回顾SE去了。万丈高楼平地起，基础打的牢，怕什么狂风暴雨&lt;/h3&gt;
&lt;h3&gt;MyBatis 动态SQL&lt;/h3&gt;
&lt;p&gt;　　MyBatis为了解决通过一些不确定性的条件进行SQL语句的拼接操作的问题, 提供了动态SQL. 具体来说，就是提供了一些标签 &amp;lt;if&amp;gt; &amp;lt;where&amp;gt; &amp;lt;trim&amp;gt; &amp;lt;set&amp;gt; &amp;lt;choose&amp;gt; &amp;lt;foreach&amp;gt; 等.写出可扩展SQL语句&lt;/p&gt;
&lt;p&gt;　　MyBatis 采用功能强大的基于 OGNL 的表达式来简化操作&lt;/p&gt;
&lt;p&gt;　　OGNL（ Object Graph Navigation Language ）对象图导航语言，这是一种强大的表达式语言，通过它可以非常方便的来操作对象属性。 类似于EL表达式,例：&lt;/p&gt;
&lt;p&gt;　　　　访问对象属性：              person.name&lt;/p&gt;
&lt;p&gt;　　　　调用方法：                     person.getName()&lt;/p&gt;
&lt;p&gt;　　　　调用静态属性/方法：     @java.lang.Math@PI    &lt;/p&gt;
&lt;p&gt;　　　　调用构造方法：              new com.bean.Person(‘admin’).name&lt;/p&gt;
&lt;p&gt;　　　　运算符：                         +,-*,/,%&lt;/p&gt;
&lt;p&gt;　　　　逻辑运算符：                  in,not in,&amp;gt;,&amp;gt;=,&amp;lt;,&amp;lt;=,==,!=&lt;/p&gt;
&lt;p&gt;　　　　注意：xml中特殊符号如”,&amp;gt;,&amp;lt;等这些都需要使用转义字符&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 标签&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　 1)&lt;strong&gt; &amp;lt;if&amp;gt;：&lt;/strong&gt;用于完成简单的判断.只有一个属性 &lt;strong&gt;test&lt;/strong&gt; 用于判断条件是否成立&lt;/p&gt;
&lt;p&gt; 　　2) &lt;strong&gt;&amp;lt;where&amp;gt;：&lt;/strong&gt;在SQL语句中添加WHERE关键字， 作用：去掉 where 后面第一个条件前面的 and / or 。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;select &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;getBook&quot;&lt;/span&gt;&lt;span&gt; resultType&lt;/span&gt;&lt;span&gt;=&quot;main.beans.Book&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        SELECT id,title,author,price
        FROM books
        &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;where&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;if &lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;=&quot;id != null&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; and id= #{id}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;if &lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;=&quot;title != null&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; and title = #{title}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;where&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　3)&lt;strong&gt; &amp;lt;trim&amp;gt;&lt;/strong&gt; : 可以在条件判断完的SQL语句的前后 添加内容 或者去掉指定的内容. 去掉第一个或最后一个&lt;/p&gt;
&lt;p&gt;　　　　prefix: 添加前缀　　prefixOverrides: 去掉前缀&lt;/p&gt;
&lt;p&gt;　　　　suffix: 添加后缀　　suffixOverrides: 去掉后缀&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;delete &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;deleteBook&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        DELETE FROM books
        &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;trim &lt;/span&gt;&lt;span&gt;prefix&lt;/span&gt;&lt;span&gt;=&quot;WHERE&quot;&lt;/span&gt;&lt;span&gt; suffixOverrides&lt;/span&gt;&lt;span&gt;=&quot;and&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;if &lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;=&quot;id != null&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;id = #{id} and&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;if &lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;=&quot;title != null&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;itle = #{title} and&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;trim &lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;delete&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　4) &lt;strong&gt;&amp;lt;set&amp;gt; &lt;/strong&gt; ：在修改的操作中， 去掉SQL语句中多出的逗号，即在sql语句中最后句可能多出的逗号&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;update &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;updateBook&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        UPDATE books
        &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;if &lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;=&quot;title != null&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;title = #{title},&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;if &lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;=&quot;author != null&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;author = #{author},&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        where id = #{id}
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;update&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　5) &lt;strong&gt;&amp;lt;sql&amp;gt;&lt;/strong&gt; 标签是用于抽取可重用的sql片段，将使用频繁的SQL片段抽取出来，不仅仅只提取整条sql语句，字段也可以提取&lt;/p&gt;
&lt;p&gt;　　　　id：指定被提取的 sql 片段唯一标识被引用&lt;/p&gt;
&lt;p&gt;　　　　引用：在任何需要插入此 sql 片段的语句中使用 &amp;lt;include refid=&quot;id标识&quot;&amp;gt;&amp;lt;/include&amp;gt; 引入即可&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;sql &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;bookFields&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        id,title,author,price,sales,stock,img_path
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;sql&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;insert &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;insertBook&quot;&lt;/span&gt;&lt;span&gt; useGeneratedKeys&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;&lt;span&gt; keyProperty&lt;/span&gt;&lt;span&gt;=&quot;id&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        INSERT INTO books (&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;include &lt;/span&gt;&lt;span&gt;refid&lt;/span&gt;&lt;span&gt;=&quot;bookFields&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;include&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;)
        VALUES(#{id},#{title},#{author},#{price},#{sales},#{stock},#{imgPath})
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　6) &lt;strong&gt;&amp;lt;choose&amp;gt;&lt;/strong&gt; &amp;lt;when&amp;gt; &amp;lt;otherwise&amp;gt; : 用于分支判断，最终只会满足其中的一个分支.  类似于 switch case 语句. &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;select &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;selectBookPrice&quot;&lt;/span&gt;&lt;span&gt; resultType&lt;/span&gt;&lt;span&gt;=&quot;main.beans.Book&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        SELECT &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;include &lt;/span&gt;&lt;span&gt;refid&lt;/span&gt;&lt;span&gt;=&quot;bookFields&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;include&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        FROM books
        &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;where&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;choose&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;when &lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;=&quot;id != null&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;id = #{id}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;when&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;otherwise&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;price &amp;gt; #{price}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;otherwise&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;choose&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;where&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　7) &lt;strong&gt;&amp;lt;foreach&amp;gt;&lt;/strong&gt;: 主要用于循环迭代&lt;/p&gt;
&lt;p&gt;　　　　　　collection: 要迭代的集合&lt;/p&gt;
&lt;p&gt;　　　　　　item: 当前从集合中迭代出的元素赋值的变量&lt;/p&gt;
&lt;p&gt;　　　　　　open: 开始字符&lt;/p&gt;
&lt;p&gt;　　　　　　close:结束字符&lt;/p&gt;
&lt;p&gt;　　　　　　separator: 指定元素与元素之间的分隔符&lt;/p&gt;
&lt;p&gt;　　　　　　index:&lt;/p&gt;
&lt;p&gt;　　　　　　　　迭代的是List集合: index表示当前元素的下标&lt;/p&gt;
&lt;p&gt;　　　　　　　　迭代的Map集合:  index表示当前元素的 key&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;注意&lt;/strong&gt;：此操作属于批量操作需在 properties 配置的 url 中添加 &lt;strong&gt;allowMultiQueries=true&lt;/strong&gt; 开启批处理&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;select &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;getBooks&quot;&lt;/span&gt;&lt;span&gt; resultType&lt;/span&gt;&lt;span&gt;=&quot;main.beans.Book&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        SELECT &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;include &lt;/span&gt;&lt;span&gt;refid&lt;/span&gt;&lt;span&gt;=&quot;bookFields&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;include&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        FROM books where id in
        &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;foreach &lt;/span&gt;&lt;span&gt;collection&lt;/span&gt;&lt;span&gt;=&quot;ids&quot;&lt;/span&gt;&lt;span&gt; item&lt;/span&gt;&lt;span&gt;=&quot;id&quot;&lt;/span&gt;&lt;span&gt; separator&lt;/span&gt;&lt;span&gt;=&quot;,&quot;&lt;/span&gt;&lt;span&gt; open&lt;/span&gt;&lt;span&gt;=&quot;(&quot;&lt;/span&gt;&lt;span&gt; close&lt;/span&gt;&lt;span&gt;=&quot;)&quot;&lt;/span&gt; &lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
            #{id}
        &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;MyBatis 缓存机制&lt;/h3&gt;
&lt;p&gt;　　  MyBatis 包含一个非常强大的查询缓存特性,它可以非常方便地配置和定制。缓存可以极大的提升&lt;strong&gt;查询效率&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　  MyBatis系统中默认定义了两级缓存：一级缓存、二级缓存&lt;/p&gt;
&lt;p&gt;　　  默认情况下，只有一级缓存（SqlSession级别的缓存，也称为本地缓存）开启。&lt;/p&gt;
&lt;p&gt;　　  二级缓存需要手动开启和配置，他是基于namespace级别的缓存。为了提高扩展性。MyBatis定义了缓存接口Cache，支持第三方缓存。&lt;/p&gt;
&lt;h4&gt;一级缓存&lt;/h4&gt;
&lt;p&gt;　　1) 一级缓存(local cache), 即本地缓存, 作用域默认为sqlSession。&lt;strong&gt;每个sqlSession对象都有自己的一级缓存&lt;/strong&gt;，相互独立不共享。当  Session flush 或 close 后, 该 Session 中的所有 Cache 将被清空。&lt;/p&gt;
&lt;p&gt;　　2) 本地缓存&lt;strong&gt;不能被关闭&lt;/strong&gt;, 但可以调用 clearCache() 来清空本地缓存, 或者改变缓存的作用域.&lt;/p&gt;
&lt;p&gt;　　3) 在mybatis3.1之后, 可以配置本地缓存的作用域. 在 mybatis.xml 中配置&lt;/p&gt;
&lt;p&gt;　　4) 一级缓存的工作机制，同一次会话期间只要查询过的数据都会保存在当前SqlSession的一个Map中&lt;/p&gt;
&lt;p&gt;　　　　　key: hashCode+查询的SqlId+编写的sql查询语句+参数&lt;/p&gt;
&lt;p&gt;缓存机制：&lt;/p&gt;
&lt;p&gt;　　基于相同sqlSession多次查询，每次查询都会先从缓存中获取数据，如果缓存中没获取到数据，则从数据库中获取数据，之后，将数据存放到一级缓存。&lt;/p&gt;
&lt;p&gt;一级缓存的失效问题&lt;/p&gt;
&lt;p&gt;　　1)不同的SqlSession对应不同的一级缓存&lt;/p&gt;
&lt;p&gt;　　2)同一个SqlSession但是查询条件不同&lt;/p&gt;
&lt;p&gt;　　3)同一个SqlSession两次查询期间执行了任何一次增删改操作&lt;br/&gt;　　　　增删改操作，会默认清空缓存。&lt;/p&gt;
&lt;p&gt;　　4)同一个SqlSession两次查询期间手动清空了缓存&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;：当同一 SqlSession 多次&lt;strong&gt;查询&lt;/strong&gt;同一语句时，且中间未有增删改或手动刷新、关闭、清空 clearCache() 过缓存，便会直接从缓存中取数据。若开启了二级缓存则会先从二级缓存读取，若二级缓存里没有再去一级缓存读取，如果只想从一级缓存中读取可在对应 &amp;lt;select&amp;gt; 配置属性中设置 &lt;strong&gt; useCache=&quot;false&quot; &lt;/strong&gt;来关闭当前二级缓存，注意增删改不涉及缓存机制&lt;/p&gt;
&lt;h4&gt;二级缓存&lt;/h4&gt;
&lt;p&gt;　　默认关闭，使用需要满足三个条件才被开启&lt;/p&gt;
&lt;p&gt;　　二级缓存：namespace级别缓存（sqlSessionFacotry）级别的缓存，作用域更广但是需要在 sqlSessionFacotry 内的 sqlSession 提交或关闭以后才会生效。即才会将 sqlSession 中的缓存存到二级缓存中。&lt;/p&gt;
&lt;p&gt;      二级缓存使用的步骤:&lt;/p&gt;
&lt;p&gt;　　　　①   全局配置文件中开启二级缓存&amp;lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&amp;gt;&lt;/p&gt;
&lt;p&gt;　　　　②   在需要使用二级缓存的映射文件（ &amp;lt;mapper&amp;gt; 配置文件）使用 cache 标签配置缓存&amp;lt;cache /&amp;gt;&lt;/p&gt;
&lt;p&gt;　　　　③   注意：POJO需要实现 Serializable 接口&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&amp;lt;cache&amp;gt;&lt;/strong&gt; 标签属性&lt;/p&gt;
&lt;p&gt;　　　　①   eviction=“LRU”：缓存回收策略：默认的是 LRU。&lt;/p&gt;
&lt;p&gt;　　　　　　　　LRU – 最近最少使用的：移除最长时间不被使用的对象。&lt;/p&gt;
&lt;p&gt;　　　　　　　　FIFO – 先进先出：按对象进入缓存的顺序来移除它们。&lt;/p&gt;
&lt;p&gt;　　　　　　　　SOFT – 软引用：移除基于垃圾回收器状态和软引用规则的对象。&lt;/p&gt;
&lt;p&gt;　　　　　　　　WEAK – 弱引用：更积极地移除基于垃圾收集器状态和弱引用规则的对象。&lt;/p&gt;
&lt;p&gt;　　　　 ②   flushInterval：刷新间隔，单位毫秒&lt;/p&gt;
&lt;p&gt;　　　　　　　　默认情况是不设置，也就是没有刷新间隔，缓存仅仅调用语句时刷新&lt;/p&gt;
&lt;p&gt;　　　　③   size：引用数目，正整数&lt;/p&gt;
&lt;p&gt;　　　　　　　　代表缓存最多可以存储多少个对象，太大容易导致内存溢出&lt;/p&gt;
&lt;p&gt;　　　　④   readOnly：只读，默认是 false。虽然设为true能提高效率但是为了安全，因此不需设置此项&lt;/p&gt;
&lt;p&gt;　　　　⑤　type:引入缓存类库（第三方缓存）&lt;/p&gt;
&lt;p&gt;　　其他相关属性设置&lt;/p&gt;
&lt;p&gt;　　　　1) 全局setting的 cacheEnable：&lt;/p&gt;
&lt;p&gt;　　　　　　　配置二级缓存的开关，一级缓存一直是打开的。&lt;/p&gt;
&lt;p&gt;　　　　2) select标签的 useCache 属性：&lt;/p&gt;
&lt;p&gt;　　　　　　    配置这个 select 是否使用二级缓存。一级缓存一直是使用的&lt;/p&gt;
&lt;p&gt;　　　　3) sql标签的 flushCache 属性：&lt;/p&gt;
&lt;p&gt;　　　　　　　增删改默认 flushCache=true。sql执行以后，会同时清空一级和二级缓存。&lt;/p&gt;
&lt;p&gt;　　　　　　　查询默认 flushCache=false。&lt;/p&gt;
&lt;p&gt;　　　　4) sqlSession.clearCache()：只是用来清除一级缓存。&lt;/p&gt;
&lt;p&gt;　　二级缓存机制&lt;/p&gt;
&lt;p&gt;　　　　基于相同sqlSessionFactory下，多次查询，优先去二级缓存中获取数据，二级缓存获取不到数据，去一级缓存中获取数据，一级缓存中也获取不到数据，直接去数据库中查询数据。&lt;/p&gt;
&lt;p&gt;　　　　查询后，将数据直接存放一级缓存，&lt;strong&gt;提交或关闭 sqlSession 时，才将一级缓存中的数据，缓存到二级缓存中。&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;EhCache第三方缓存&lt;/h3&gt;
&lt;p&gt;　　EhCache 是一个纯Java的进程内缓存框架，具有快速、精干等特点，是Hibernate中默认的CacheProvider&lt;/p&gt;
&lt;p&gt;　　整合EhCache缓存的步骤:&lt;/p&gt;
&lt;p&gt;　　　　① 导入ehcache包，以及整合包，日志包&lt;/p&gt;
&lt;p&gt;　　　　　　ehcache-core-2.6.8.jar、mybatis-ehcache-1.0.3.jar&lt;/p&gt;
&lt;p&gt;　　　　　　slf4j-api-1.6.1.jar、slf4j-log4j12-1.6.2.jar&lt;/p&gt;
&lt;p&gt;　　　　② 编写 ehcache.xml 配置文件&lt;/p&gt;
&lt;p&gt;　　　　③ 配置 cache 标签&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
　　　　　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;cache &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;org.mybatis.caches.ehcache.EhcacheCache&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;cache&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　第三方缓存的使用机制，同二级缓存一样也需要 setting 的 cacheEnable 设置为 true 并且实现序列化接口 Serializable &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ehcache &lt;/span&gt;&lt;span&gt;xmlns:xsi&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;span&gt;
 xsi:noNamespaceSchemaLocation&lt;/span&gt;&lt;span&gt;=&quot;../config/ehcache.xsd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
 &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 磁盘保存路径 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;diskStore &lt;/span&gt;&lt;span&gt;path&lt;/span&gt;&lt;span&gt;=&quot;F:\code\mysql\ehcache&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;defaultCache 
   &lt;/span&gt;&lt;span&gt;maxElementsInMemory&lt;/span&gt;&lt;span&gt;=&quot;1000&quot;&lt;/span&gt;&lt;span&gt; 
   maxElementsOnDisk&lt;/span&gt;&lt;span&gt;=&quot;10000000&quot;&lt;/span&gt;&lt;span&gt;
   eternal&lt;/span&gt;&lt;span&gt;=&quot;false&quot;&lt;/span&gt;&lt;span&gt; 
   overflowToDisk&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;&lt;span&gt; 
   timeToIdleSeconds&lt;/span&gt;&lt;span&gt;=&quot;120&quot;&lt;/span&gt;&lt;span&gt;
   timeToLiveSeconds&lt;/span&gt;&lt;span&gt;=&quot;120&quot;&lt;/span&gt;&lt;span&gt; 
   diskExpiryThreadIntervalSeconds&lt;/span&gt;&lt;span&gt;=&quot;120&quot;&lt;/span&gt;&lt;span&gt;
   memoryStoreEvictionPolicy&lt;/span&gt;&lt;span&gt;=&quot;LRU&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
 &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;defaultCache&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ehcache&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt; MyBatis 逆向工程&lt;/h3&gt;
&lt;p&gt;　　MyBatis Generator: 简称MBG，是一个专门为MyBatis框架使用者定制的代码生成器，可以快速的根据表生成对应的映射文件，接口，以及bean类。支持基本的增删改查，以及QBC风格的条件查询。但是表连接、存储过程等这些复杂sql的定义需要我们手工编写&lt;/p&gt;
&lt;p&gt;Mybatis使用逆向工程步骤&lt;br/&gt;　　1.加入逆向工程相关的jar包.&lt;/p&gt;
&lt;p&gt;　　　　mybatis-generator-core-1.3.2.jar&lt;/p&gt;
&lt;p&gt;　　2.配置逆向工程的配置文件: mbg.xml ==&amp;gt; 生成的版本 、 javaBean、Mapper接口、映射文件的生成策略 、 分析的表 .&lt;/p&gt;
&lt;p&gt;　　　　mbg.xml 文件&lt;strong&gt;直接放在项目工程根目录下&lt;/strong&gt;方便路径配置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE generatorConfiguration
        PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;generatorConfiguration&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;
            targetRuntime: 执行生成的逆向工程的版本
                  MyBatis3Simple: 生成基本的CRUD
                  MyBatis3: 生成带条件的CRUD
   &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;context &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;DB2Tables&quot;&lt;/span&gt;&lt;span&gt; targetRuntime&lt;/span&gt;&lt;span&gt;=&quot;MyBatis3&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;        数据库连接设置&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;jdbcConnection &lt;/span&gt;&lt;span&gt;driverClass&lt;/span&gt;&lt;span&gt;=&quot;com.mysql.jdbc.Driver&quot;&lt;/span&gt;&lt;span&gt;
                        connectionURL&lt;/span&gt;&lt;span&gt;=&quot;jdbc:mysql://localhost:3306/bookstore?allowMultiQueries=true&quot;&lt;/span&gt;&lt;span&gt;
                        userId&lt;/span&gt;&lt;span&gt;=&quot;root&quot;&lt;/span&gt;&lt;span&gt;
                        password&lt;/span&gt;&lt;span&gt;=&quot;12345&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;jdbcConnection&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; javaBean的生成策略 bean的存放路径&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;javaModelGenerator &lt;/span&gt;&lt;span&gt;targetPackage&lt;/span&gt;&lt;span&gt;=&quot;main.beans&quot;&lt;/span&gt;&lt;span&gt; targetProject&lt;/span&gt;&lt;span&gt;=&quot;.\src&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;enableSubPackages&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;trimStrings&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;javaModelGenerator&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; SQL映射文件的生成策略 mapper.xml文件路径&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;sqlMapGenerator &lt;/span&gt;&lt;span&gt;targetPackage&lt;/span&gt;&lt;span&gt;=&quot;main.mapper&quot;&lt;/span&gt;&lt;span&gt; targetProject&lt;/span&gt;&lt;span&gt;=&quot;.\conf&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;enableSubPackages&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;sqlMapGenerator&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; Mapper接口的生成策略 mapper接口路径&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;javaClientGenerator &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;XMLMAPPER&quot;&lt;/span&gt;&lt;span&gt; targetPackage&lt;/span&gt;&lt;span&gt;=&quot;main.mapper&quot;&lt;/span&gt;&lt;span&gt; targetProject&lt;/span&gt;&lt;span&gt;=&quot;.\src&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;enableSubPackages&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;javaClientGenerator&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 逆向分析的表 表名对应的javaBean名&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;table &lt;/span&gt;&lt;span&gt;tableName&lt;/span&gt;&lt;span&gt;=&quot;books&quot;&lt;/span&gt;&lt;span&gt; domainObjectName&lt;/span&gt;&lt;span&gt;=&quot;Book&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;table&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;table &lt;/span&gt;&lt;span&gt;tableName&lt;/span&gt;&lt;span&gt;=&quot;users&quot;&lt;/span&gt;&lt;span&gt; domainObjectName&lt;/span&gt;&lt;span&gt;=&quot;User&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;table&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;context&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;generatorConfiguration&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　3.执行生成代码.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; testMbg() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        List&lt;/span&gt;&amp;lt;String&amp;gt; warnings = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;String&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; overwrite = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        File configFile &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; File(&quot;mbg.xml&quot;&lt;span&gt;);
        ConfigurationParser cp &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConfigurationParser(warnings);
        Configuration config &lt;/span&gt;=&lt;span&gt; cp.parseConfiguration(configFile);
        DefaultShellCallback callback &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DefaultShellCallback(overwrite);
        MyBatisGenerator myBatisGenerator &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MyBatisGenerator(config,callback, warnings);
        myBatisGenerator.generate(&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;PageHelper 分页插件&lt;/h3&gt;
&lt;p&gt;　　PageHelper 是MyBatis中非常方便的第三方分页插件。内部提供了 PageHelper 和 PageInfo 两个非常强大的类库。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用步骤&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　1) 导入相关包 pagehelper-5.0.0.jar 和 jsqlparser-0.9.5.jar&lt;/p&gt;
&lt;p&gt;　　2) 在MyBatis全局配置文件中配置分页插件，注意标签位置不可乱序&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;plugins&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;plugin &lt;/span&gt;&lt;span&gt;interceptor&lt;/span&gt;&lt;span&gt;=&quot;com.github.pagehelper.PageInterceptor&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;plugin&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;plugins&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　3) 使用：在查询出集合之前开启分页查询&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
        Page&amp;lt;Book&amp;gt; page = PageHelper.startPage(3,2&lt;span&gt; );
        List&lt;/span&gt;&amp;lt;Book&amp;gt; books =&lt;span&gt; mapper.selectByExample(bookExample);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;查询出当前为第3页，每页显示2条的图书信息，其还可得到更多页码相关值&lt;/span&gt;
        books.forEach((book -&amp;gt; System.out.println(&quot;book = &quot; +&lt;span&gt; book)));
        PageInfo&lt;/span&gt;&amp;lt;Book&amp;gt; info = &lt;span&gt;new&lt;/span&gt; PageInfo&amp;lt;&amp;gt;(books,3&lt;span&gt;);
        System.out.println(&lt;/span&gt;&quot;=============获取详细分页相关的信息=================&quot;&lt;span&gt;);
        System.out.println(&lt;/span&gt;&quot;当前页: &quot; +&lt;span&gt; info.getPageNum());
        System.out.println(&lt;/span&gt;&quot;总页码: &quot; +&lt;span&gt; info.getPages());
        System.out.println(&lt;/span&gt;&quot;总条数: &quot; +&lt;span&gt; info.getTotal());
        System.out.println(&lt;/span&gt;&quot;每页显示的条数: &quot; +&lt;span&gt; info.getPageSize());
        System.out.println(&lt;/span&gt;&quot;是否是第一页: &quot; +&lt;span&gt; info.isIsFirstPage());
        System.out.println(&lt;/span&gt;&quot;是否是最后一页: &quot; +&lt;span&gt; info.isIsLastPage());
        System.out.println(&lt;/span&gt;&quot;是否有上一页: &quot; +&lt;span&gt; info.isHasPreviousPage());
        System.out.println(&lt;/span&gt;&quot;是否有下一页: &quot; +&lt;span&gt; info.isHasNextPage());
        System.out.println(&lt;/span&gt;&quot;============分页逻辑===============&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;[] nums =&lt;span&gt; info.getNavigatepageNums();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt;&lt;span&gt; num : nums) {
            System.out.println(&lt;/span&gt;&quot;num = &quot; +&lt;span&gt; num);
        } &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　Page对象&lt;/p&gt;
&lt;p&gt;　　　　在查询之前通过PageHelper.startPage(页码，条数)设置分页信息，该方法返回Page对象&lt;/p&gt;
&lt;p&gt;　　PageInfo对象&lt;/p&gt;
&lt;p&gt;　　　　在查询完数据后，使用PageInfo对象封装查询结果，可以获取更详细的分页信息以及可以完成分页逻辑&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;https://www.cnblogs.com/Open-ing/articles/12230479.html&quot; target=&quot;_blank&quot;&gt;SSM配置文件&lt;/a&gt;&lt;/h3&gt;

</description>
<pubDate>Sat, 25 Jan 2020 05:56:00 +0000</pubDate>
<dc:creator>远离颠倒梦想</dc:creator>
<og:description>MyBatis 今天大年初一，你在学习！不学习做什么，斗地主...人都凑不齐。学习吧，学习使我快乐！除了诗和远方还有责任，我也想担当，我也想负责，可臣妾做不到啊，怎么办？你说怎么办，为啥人家能做到你做</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Open-ing/p/12232989.html</dc:identifier>
</item>
</channel>
</rss>