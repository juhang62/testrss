<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>numpy数组之读写文件 - wuliytTaotao</title>
<link>http://www.cnblogs.com/wuliytTaotao/p/10914932.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wuliytTaotao/p/10914932.html</guid>
<description>&lt;p&gt;将 numpy 数组存入文件，有多种文件类型可供选择，对应地就有不同的方法来读写。&lt;/p&gt;
&lt;p&gt;下面我将介绍读写 numpy 的三类文件：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;txt 或者 csv 文件&lt;/li&gt;
&lt;li&gt;npy 或者 npz 文件&lt;/li&gt;
&lt;li&gt;hdf5 文件&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;通过-numpy-读写-txt-或-csv-文件&quot;&gt;通过 numpy 读写 txt 或 csv 文件&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;import numpy as np

a = np.array(range(20)).reshape((4, 5))
print(a)

# 后缀改为 .txt 一样
filename = 'data/a.csv'
# 写文件
np.savetxt(filename, a, fmt='%d', delimiter=',')

# 读文件
b = np.loadtxt(filename, dtype=np.int32, delimiter=',')
print(b)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;缺点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;只能保存一维和二维 numpy 数组，当 numpy 数组 &lt;code&gt;a&lt;/code&gt; 有多维时，需要将其 &lt;code&gt;a.reshape((a.shape[0], -1))&lt;/code&gt; 后才能用这种方式保存。&lt;/li&gt;
&lt;li&gt;不能追加保存，即每次 &lt;code&gt;np.savetxt()&lt;/code&gt; 都会覆盖之前的内容。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;通过-numpy-读写-npy-或-npz-文件&quot;&gt;通过 numpy 读写 npy 或 npz 文件&lt;/h2&gt;
&lt;h3 id=&quot;读写-npy-文件&quot;&gt;读写 npy 文件&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;import numpy as np

a = np.array(range(20)).reshape((2, 2, 5))
print(a)

filename = 'data/a.npy'
# 写文件
np.save(filename, a)

# 读文件
b = np.load(filename)
print(b)
print(b.shape)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;优点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;npy 文件可以保存任意维度的 numpy 数组，不限于一维和二维；&lt;/li&gt;
&lt;li&gt;npy 保存了 numpy 数组的结构，保存的时候是什么 shape 和 dtype，取出来时就是什么样的 shape 和 dtype。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;缺点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;只能保存一个 numpy 数组，每次保存会覆盖掉之前文件中存在的内容（如果有的话）。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;读写-npz-文件&quot;&gt;读写 npz 文件&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;import numpy as np

a = np.array(range(20)).reshape((2, 2, 5))
b = np.array(range(20, 44)).reshape(2, 3 ,4)
print('a:\n', a)
print('b:\n', b)

filename = 'data/a.npz'
# 写文件， 如果不指定key，那么默认key为'arr_0'、'arr_1'，一直排下去。
np.savez(filename, a, b=b)

# 读文件
c = np.load(filename)
print('keys of NpzFile c:\n', c.keys())
print(&quot;c['arr_0']:\n&quot;, c['arr_0'])
print(&quot;c['b']:\n&quot;, c['b'])&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;优点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;npy 文件可以保存任意维度的 numpy 数组，不限于一维和二维；&lt;/li&gt;
&lt;li&gt;npy 保存了 numpy 数组的结构，保存的时候是什么 shape 和 dtype，取出来时就是什么样的 shape 和 dtype；&lt;/li&gt;
&lt;li&gt;可以同时保存多个 numpy 数组；&lt;/li&gt;
&lt;li&gt;可以指定保存 numpy 数组的 key，读取的时候很方便，不会混乱。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;缺点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;保存多个 numpy 数组时，只能同时保存，即 &lt;code&gt;np.savez(filename, a, b=b)&lt;/code&gt;。每次保存会覆盖掉之前文件中存在的内容（如果有的话）。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;通过-h5py-读写-hdf5-文件&quot;&gt;通过 h5py 读写 hdf5 文件&lt;/h2&gt;
&lt;p&gt;优点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;不限 numpy 数组维度，可以保持 numpy 数组结构和数据类型；&lt;/li&gt;
&lt;li&gt;适合 numpy 数组很大的情况，文件占用空间小；&lt;/li&gt;
&lt;li&gt;可以通过 key 来访问 dataset（可以理解为 numpy.array），读取的时候很方便，不会混乱。&lt;/li&gt;
&lt;li&gt;可以不覆盖原文件中含有的内容。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;简单读取&quot;&gt;简单读取&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;import numpy as np
import h5py

a = np.array(range(20)).reshape((2, 2, 5))
b = np.array(range(20)).reshape((1, 4, 5))
print(a)
print(b)

filename = 'data/data.h5'
# 写文件
h5f = h5py.File(filename, 'w')
h5f.create_dataset('a', data=a)
h5f.create_dataset('b', data=b)
h5f.close()

# 读文件
h5f = h5py.File(filename, 'r')
print(type(h5f))
# 通过切片得到numpy数组
print(h5f['a'][:])
print(h5f['b'][:])
h5f.close()&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;通过切片赋值&quot;&gt;通过切片赋值&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;import numpy as np
import h5py

a = np.array(range(20)).reshape((2, 2, 5))
print(a)

filename = 'data/a.h5'
# 写文件
h5f = h5py.File(filename, 'w')
# 当数组a太大，需要切片进行操作时，可以不直接对h5f['a']进行初始化；
# 当之后不需要改变h5f['a']的shape时，可以省略maxshape参数
h5f.create_dataset('a', shape=(2, 2, 5), maxshape=(None, 2, 5), dtype=np.int32, compression='gzip')
for i in range(2):
    # 采用切片的形式赋值
    h5f['a'][i] = a[i]
h5f.close()

# 读文件
h5f = h5py.File(filename, 'r')
print(type(h5f))
print(h5f['a'])
# 通过切片得到numpy数组
print(h5f['a'][:])&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同一个 hdf5 文件可以创建多个 dataset，读取的时候按照 key 来即可。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;csv 和 txt 只能用来存一维或二维 numpy 数组；&lt;/li&gt;
&lt;li&gt;npy 用来存单个 numpy 数组，npz 可以同时存多个 numpy 数组，两者都不限 numpy 维度，且都保持 numpy 数组的 shape 和 dtype，写文件时若原文件存在只能覆盖原文件内容；&lt;/li&gt;
&lt;li&gt;当 numpy 数组很大时，最好使用 hdf5 文件，hdf5 文件相对更小；&lt;/li&gt;
&lt;li&gt;当 numpy 数组很大时，对整个 numpy 数组进行运算容易发生 MemoryError，那么此时可以选择对 numpy 数组切片，将运算后的数组保存到 hdf5 文件中，hdf5 文件支持切片索引。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;references&quot;&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/ae12525450e8&quot;&gt;当Python遇上HDF5--性能优化实战 -- 张玉腾&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/Ponys/p/3671458.html&quot;&gt;杂： PYTHON上数据储存：推荐h5py -- Pony_s&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 23 May 2019 15:37:00 +0000</pubDate>
<dc:creator>wuliytTaotao</dc:creator>
<og:description>numpy 数组常用的读写方式和文件，第一种文件类型 txt 或 csv，第二种 npy 和 npz，第三种 hdf5。本文简单对比各种方法的优劣，并给出相应的简单例子。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wuliytTaotao/p/10914932.html</dc:identifier>
</item>
<item>
<title>[Inside HotSpot] Serial垃圾回收器 (二) Minor GC - kelthuzadx</title>
<link>http://www.cnblogs.com/kelthuzadx/p/10915224.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kelthuzadx/p/10915224.html</guid>
<description>&lt;h2 id=&quot;defnewgeneration垃圾回收&quot;&gt;1. DefNewGeneration垃圾回收&lt;/h2&gt;
&lt;p&gt;新生代使用复制算法做垃圾回收，比老年代的标记-压缩简单很多，所有回收代码都位于DefNewGeneration::collect：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// hotspot\share\gc\serial\defNewGeneration.cpp
void DefNewGeneration::collect(bool   full,
                               bool   clear_all_soft_refs,
                               size_t size,
                               bool   is_tlab) {
  SerialHeap* heap = SerialHeap::heap();
  _old_gen = heap-&amp;gt;old_gen();
  // 如果新生代全是存活对象，老年代可能容不下新生代的晋升
  // 则设置增量垃圾回收失败，直接返回
  if (!collection_attempt_is_safe()) {
    heap-&amp;gt;set_incremental_collection_failed(); 
    return;
  }
  ...
  // 各种闭包初始化
  IsAliveClosure is_alive(this);
  ...
  
  {
    // 扫描GC Root，用快速扫描闭包做对象复制
    StrongRootsScope srs(0);
    heap-&amp;gt;young_process_roots(&amp;amp;srs,
                              &amp;amp;fsc_with_no_gc_barrier,
                              &amp;amp;fsc_with_gc_barrier,
                              &amp;amp;cld_scan_closure);
  }
  // 用快速成员处理闭包处理非GC Root直达对象
  evacuate_followers.do_void();
  // 特殊处理软引用，弱引用，虚引用，final引用
 ...

  // 如果晋升成功，则清空eden，from；交换from，to分区；调整老年代晋升阈值
  // 同时还需要确保晋升成功的情况下to区一定是空的
  if (!_promotion_failed) {
    eden()-&amp;gt;clear(SpaceDecorator::Mangle);
    from()-&amp;gt;clear(SpaceDecorator::Mangle);
    if (ZapUnusedHeapArea) {
      to()-&amp;gt;mangle_unused_area();
    }
    swap_spaces();
    adjust_desired_tenuring_threshold();
    AdaptiveSizePolicy* size_policy = heap-&amp;gt;size_policy();
    size_policy-&amp;gt;reset_gc_overhead_limit_count();
  } 
  // 否则晋升失败，提醒老年代
  else {
    _promo_failure_scan_stack.clear(true); 
    remove_forwarding_pointers();
    log_info(gc, promotion)(&quot;Promotion failed&quot;);
    swap_spaces();
    from()-&amp;gt;set_next_compaction_space(to());
    heap-&amp;gt;set_incremental_collection_failed();
    _old_gen-&amp;gt;promotion_failure_occurred();
  }
  // 更新gc日志，清除preserved mar
  ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在做Minor GC之前会检查此次垃圾回收是否安全(collection_attempt_is_safe)，所谓&lt;strong&gt;是否安全&lt;/strong&gt;是指最坏情况下新生代全是需要晋升的存活对象，这时候老年代能否安全容纳下。如果JVM回答可以做垃圾回收，那么再做下面的展开。&lt;/p&gt;
&lt;h2 id=&quot;快速扫描闭包fastscanclosure&quot;&gt;2. 快速扫描闭包(FastScanClosure)&lt;/h2&gt;
&lt;p&gt;新生代的复制动作主要位于young_process_roots(),该函数首先会扫描所有类型的GC Root，使用快速扫描闭包配合GC Root将直达的存活对象复制到To survivor区，然后再扫描从老年代指向新生代的应用。快速扫描闭包指的是&lt;code&gt;FastScanClosure&lt;/code&gt;，它的代码如下：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// hotspot\share\gc\shared\genOopClosures.inline.hpp
inline void FastScanClosure::do_oop(oop* p)       { FastScanClosure::do_oop_work(p); }
template &amp;lt;class T&amp;gt; inline void FastScanClosure::do_oop_work(T* p) {
  // 从地址p处获取对象 
  T heap_oop = RawAccess&amp;lt;&amp;gt;::oop_load(p);
  if (!CompressedOops::is_null(heap_oop)) {
    oop obj = CompressedOops::decode_not_null(heap_oop);
    // 如果对象位于新生代
    if ((HeapWord*)obj &amp;lt; _boundary) {
      // 如果对象有转发指针（相当于已复制过）就保持原位
      // 否则根据情况进行复制
      oop new_obj = obj-&amp;gt;is_forwarded() ? obj-&amp;gt;forwardee()
                                        : _g-&amp;gt;copy_to_survivor_space(obj);
      RawAccess&amp;lt;IS_NOT_NULL&amp;gt;::oop_store(p, new_obj);
      if (is_scanning_a_cld()) {
        do_cld_barrier();
      } else if (_gc_barrier) {
        // 根据情况设置gc barrier
        do_barrier(p);
      }
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一句话总结，快速扫描闭包的能力是&lt;strong&gt;视情况复制地址所指对象或者晋升它&lt;/strong&gt;。这段代码有两个值得提及的地方：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;根据情况进行复制的copy_to_survivor_space()&lt;/li&gt;
&lt;li&gt;根据情况设置gc屏障的do_barrier()&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;新生代到to-survivor的复制&quot;&gt;2.1 新生代到To survivor的复制&lt;/h3&gt;
&lt;p&gt;先说第一个复制：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// hotspot\share\gc\serial\defNewGeneration.cpp
oop DefNewGeneration::copy_to_survivor_space(oop old) {
  size_t s = old-&amp;gt;size();
  oop obj = NULL;
  // 如果对象还年轻就在to区分配空间
  if (old-&amp;gt;age() &amp;lt; tenuring_threshold()) {
    obj = (oop) to()-&amp;gt;allocate_aligned(s);
  }
  // 如果对象比较老或者to区分配失败，晋升到老年代
  if (obj == NULL) {
    obj = _old_gen-&amp;gt;promote(old, s);
    if (obj == NULL) { // 晋升失败处理
      handle_promotion_failure(old);
      return old;
    }
  } else {
    // 如果to分配成功，在新分配的空间里面放入对象
    const intx interval = PrefetchCopyIntervalInBytes;
    Prefetch::write(obj, interval);
    Copy::aligned_disjoint_words((HeapWord*)old, (HeapWord*)obj, s);
    // 对象年龄递增且加入年龄表
    obj-&amp;gt;incr_age();
    age_table()-&amp;gt;add(obj, s);
  }
  // 把新地址插入对象mark word，表示该对象已经复制过了。
  old-&amp;gt;forward_to(obj);
  return obj;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码很清晰，如果GC Root里面引用的对象年龄没有超过晋升阈值，就把它从新生代(Eden+From)转移到To,如果超过阈值直接从新生代转移到老年代。&lt;/p&gt;
&lt;h3 id=&quot;gc屏障&quot;&gt;2.2 GC屏障&lt;/h3&gt;
&lt;p&gt;然后说说gc barrier。&lt;a href=&quot;http://www.cnblogs.com/kelthuzadx/p/gc_heap_overview.md&quot;&gt;之前文章提到&lt;/a&gt;过老年代（TenuredGeneration，久任代）继承自卡表代（CardGeneration），卡表代把堆空间划分为一张张512字节的卡片，如果某个卡是脏卡（dirty card）就表示该卡表示的512字节内存空间存在指向新生代的对象，就需要扫描这篇区域。do_barrier()会检查是否开启gc barrier，是否老年代地址p指向的对象存在指向新生代的对象。如果条件都满足就会将卡标记为dirty，那么具体是怎么做的？&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;//hotspot\share\gc\shared\cardTableRS.hpp
class CardTableRS: public CardTable {
  ...
  void inline_write_ref_field_gc(void* field, oop new_val) {
    jbyte* byte = byte_for(field);
    *byte = youngergen_card;
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;field表示这个老年代对象的地址，byte_for()会找到该地址对应的card，然后&lt;code&gt;*byte = youngergen_card&lt;/code&gt;标记为脏卡，再来看看byte_for()又是怎么根据地址找到card的：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;//hotspot\share\gc\shared\cardTable.hpp
class CardTable: public CHeapObj&amp;lt;mtGC&amp;gt; {
  ...
  jbyte* byte_for(const void* p) const {
    jbyte* result = &amp;amp;_byte_map_base[uintptr_t(p) &amp;gt;&amp;gt; card_shift];
    return result;
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;card_shift表示常量9，卡表是一个字节数组，每个字节映射老年代512字节，计算方法就是当前地址除以512向下取整，然后查找卡表数组对应的字节：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1654682/201905/1654682-20190523203107347-978135511.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;快速成员处理闭包fastevacuatefollowersclosure&quot;&gt;3. 快速成员处理闭包(FastEvacuateFollowersClosure)&lt;/h2&gt;
&lt;p&gt;不难看出，快速扫描闭包只是复制和晋升了GC Root直接可达的对象引用。但问题是对象还可能有成员，可达性分析是从GC Root出发寻找对象引用，以及对象成员的引用，对象成员的成员的引用...快速成员处理闭包正是处理剩下不那么直接的对象引用：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;//hotspot\share\gc\serial\defNewGeneration.cpp
void DefNewGeneration::FastEvacuateFollowersClosure::do_void() {
  do {
    // 对整个堆引用快速成员处理闭包，注意快速扫描闭包是不能单独行动的
    // 他还需要借助快速扫描闭包的力量，因为快速扫描闭包有复制对象的能力
    // _scan_cur_or_nonheap表示快速扫描闭包
    // _scan_older表示带gc屏障的快速扫描闭包
    _heap-&amp;gt;oop_since_save_marks_iterate(_scan_cur_or_nonheap, _scan_older);
  } while (!_heap-&amp;gt;no_allocs_since_save_marks());
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第一步快速扫描闭包可能会将Eden+From区的对象提升到老年代，这时候如果只处理新生代是不够的，因为这些提升了的对象可能还有新生代的成员域，所以快速成员处理闭包作用的是除了To survivor的整个堆(Eden+From+Tenured)。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;//hotspot\share\gc\shared\space.inline.hpp
template &amp;lt;typename OopClosureType&amp;gt;
void ContiguousSpace::oop_since_save_marks_iterate(OopClosureType* blk) {
  HeapWord* t;
  // 扫描指针为灰色对象开始
  HeapWord* p = saved_mark_word();
  const intx interval = PrefetchScanIntervalInBytes;
  do {
    // 灰色对象结束
    t = top();
    while (p &amp;lt; t) {
      Prefetch::write(p, interval);
      oop m = oop(p);
      // 迭代处理对象m的成员&amp;amp;&amp;amp;返回对象m的大小
      // 扫描指针向前推进
      p += m-&amp;gt;oop_iterate_size(blk);
    }
  } while (t &amp;lt; top());
  set_saved_mark_word(p);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里比较坑的是&lt;code&gt;oop_iterate_size()&lt;/code&gt;函数会同时迭代处理对象m的成员并返回对象m的大小...还要注意oop_iterate_size()传入的blk表示的是快速扫描闭包，同样一句话总结，快速成员处理闭包的能力是&lt;strong&gt;递归式处理一个分区所有对象及对象成员&lt;/strong&gt;，这种能力配合上快速扫描闭包最终效果就是将一个分区的对象视情况复制到到To survivor区或者晋升到老年代。&lt;/p&gt;
&lt;p&gt;关于快速扫描闭包和快速成员处理闭包用图片说明可能更简单，假设有ABCD四个对象：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1654682/201905/1654682-20190523203135261-872710087.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当快速扫描闭包完成时A假设会进入To区域：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1654682/201905/1654682-20190523203148854-2035683993.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当快速成员处理闭包完成时A的成员B和老年代C指向的成员D也会进入To：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1654682/201905/1654682-20190523203202627-2005986866.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 23 May 2019 15:07:00 +0000</pubDate>
<dc:creator>kelthuzadx</dc:creator>
<og:description>Serial垃圾回收器Minor GC 1. DefNewGeneration垃圾回收 新生代使用复制算法做垃圾回收，比老年代的标记 压缩简单很多，所有回收代码都位于DefNewGeneration:</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kelthuzadx/p/10915224.html</dc:identifier>
</item>
<item>
<title>MySQL 事务 - 刘哇勇</title>
<link>http://www.cnblogs.com/Wayou/p/mysql_transaction.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Wayou/p/mysql_transaction.html</guid>
<description>&lt;p&gt;多表关联的情况下，一条新记录的生成往往涉及多多张表的操作。&lt;/p&gt;
&lt;p&gt;一个典型的场景，银行转帐。要完成 A 转帐到 B，&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;从 A 帐户减去相应金额&lt;/li&gt;
&lt;li&gt;给 B 帐户加上相应金额。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这两步要么一起成功，要么都失败，否则就会造成数据不一致。比如 A 的钱少了，但 B 的钱没增加，或者 A 的扣款失败，B 的钱也增加了。&lt;/p&gt;
&lt;p&gt;所以需要一种机制来保证这一操作过程中每一步的正确性，当其中任意操作失败时应该将已经进行过的操作回滚，保证整体都失败。&lt;/p&gt;
&lt;p&gt;此时这些被绑定的一连串操作便形成了 &lt;strong&gt;事务&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;下面创建一张空表，为后面示例作准备。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-sql&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
mysql&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt; CREATE TABLE test(idx &lt;span class=&quot;pl-k&quot;&gt;int&lt;/span&gt;);
Query OK, &lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt; rows affected (&lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;02&lt;/span&gt; sec)
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;事务的语法&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;MySQL 中，通过 &lt;code&gt;START TRANSACTION&lt;/code&gt; 语句来开始一个事务，也可以使用别名 &lt;code&gt;BEGIN&lt;/code&gt; 和 &lt;code&gt;BEGIN WORK&lt;/code&gt; 语句。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;COMMIT&lt;/code&gt; 语句提交修改。&lt;/li&gt;
&lt;li&gt;通过 &lt;code&gt;ROLLBACK&lt;/code&gt; 语句回滚。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其中 &lt;code&gt;COMMIT&lt;/code&gt; 或 &lt;code&gt;ROLLBACK&lt;/code&gt; 均可用来结束一个事务。&lt;/p&gt;
&lt;p&gt;来看一个简单的示例：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;14&quot;&gt;
&lt;pre&gt;
mysql&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt; BEGIN&lt;span class=&quot;pl-k&quot;&gt;;&lt;/span&gt;
Query OK, 0 rows affected (0.00 sec)

mysql&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt; INSERT INTO &lt;span class=&quot;pl-c1&quot;&gt;test&lt;/span&gt; values(1)&lt;span class=&quot;pl-k&quot;&gt;;&lt;/span&gt;
Query OK, 1 row affected (0.01 sec)

mysql&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt; INSERT INTO &lt;span class=&quot;pl-c1&quot;&gt;test&lt;/span&gt; values(2)&lt;span class=&quot;pl-k&quot;&gt;;&lt;/span&gt;
Query OK, 1 row affected (0.00 sec)

mysql&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt; SELECT &lt;span class=&quot;pl-k&quot;&gt;*&lt;/span&gt; FROM &lt;span class=&quot;pl-c1&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;;&lt;/span&gt;
+------+
&lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; idx  &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt;
+------+
&lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt;    1 &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt;    2 &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt;
+------+
2 rows &lt;span class=&quot;pl-k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;set&lt;/span&gt; (0.00 sec)

mysql&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt; ROLLBACK&lt;span class=&quot;pl-k&quot;&gt;;&lt;/span&gt;
Query OK, 0 rows affected (0.00 sec)

mysql&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt; SELECT &lt;span class=&quot;pl-k&quot;&gt;*&lt;/span&gt; FROM &lt;span class=&quot;pl-c1&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;;&lt;/span&gt;
Empty &lt;span class=&quot;pl-c1&quot;&gt;set&lt;/span&gt; (0.00 sec)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面创建了一个名为 &lt;code&gt;test&lt;/code&gt; 的表，开始事务，向其中分两次插入记录。&lt;/p&gt;
&lt;p&gt;然后查询刚刚插入的两条记录。因为此时是处于一个事务中，所以这两条记录实际上是可以被回滚的。&lt;/p&gt;
&lt;p&gt;调用 &lt;code&gt;ROLLBACK&lt;/code&gt; 后两次查询，表中已经没有了刚刚的两条记录。&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;autocommit&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;抛开事务&lt;/strong&gt;，MySQL 默认情况下开启了一个自动提交的模式 &lt;code&gt;autocommit&lt;/code&gt;，一条语句被回车执行后该语句便生效了，变更会保存在 MySQL 的文件中，无法撤消。当使用相应语句比如 &lt;code&gt;BEGIN&lt;/code&gt; 显式声明开始一个事务时，&lt;code&gt;autocommit&lt;/code&gt; 默认会是关闭状态。&lt;/p&gt;
&lt;p&gt;可通过查询 &lt;code&gt;@@autocommit&lt;/code&gt; 变量来查看当前是否是自动提交的状态，&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
mysql&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt; SELECT @@autocommit&lt;span class=&quot;pl-k&quot;&gt;;&lt;/span&gt;
+--------------+
&lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; @@autocommit &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt;
+--------------+
&lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt;            1 &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt;
+--------------+
1 row &lt;span class=&quot;pl-k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;set&lt;/span&gt; (0.00 sec)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过设置 &lt;code&gt;autocommit&lt;/code&gt; 为 &lt;code&gt;0&lt;/code&gt; 可关闭自动提交，&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-sql&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;SET&lt;/span&gt; autocommit &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;无论是否是自动提交模式，语句执行后都会生效，区别在于，非自动模式下，没提交的那些操作是可以回滚的，一旦提交后便不可撤消了。换句话说，当 &lt;code&gt;autocommit&lt;/code&gt; 关闭时，一直是处于事务操作中的，可随时调用 &lt;code&gt;ROLLBACK&lt;/code&gt; 进行回滚。&lt;/p&gt;
&lt;p&gt;下面的语句展示了 &lt;code&gt;autocommit&lt;/code&gt; 关闭时 &lt;code&gt;COMMIT&lt;/code&gt; 与否的影响，&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;17&quot;&gt;
&lt;pre&gt;
mysql&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;@@autocommit;&lt;/span&gt;
+--------------+
&lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; @@autocommit &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt;
+--------------+
&lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt;            1 &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt;
+--------------+
1 row &lt;span class=&quot;pl-k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;set&lt;/span&gt; (0.00 sec)

mysql&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;set&lt;/span&gt; autocommit=0&lt;span class=&quot;pl-k&quot;&gt;;&lt;/span&gt;
Query OK, 0 rows affected (0.00 sec)

mysql&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;*&lt;/span&gt; from &lt;span class=&quot;pl-c1&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;;&lt;/span&gt;
Empty &lt;span class=&quot;pl-c1&quot;&gt;set&lt;/span&gt; (0.00 sec)

mysql&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt; insert into &lt;span class=&quot;pl-c1&quot;&gt;test&lt;/span&gt; values(1)&lt;span class=&quot;pl-k&quot;&gt;;&lt;/span&gt;
Query OK, 1 row affected (0.00 sec)

mysql&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt; insert into &lt;span class=&quot;pl-c1&quot;&gt;test&lt;/span&gt; values(2)&lt;span class=&quot;pl-k&quot;&gt;;&lt;/span&gt;
Query OK, 1 row affected (0.00 sec)

mysql&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;*&lt;/span&gt; from &lt;span class=&quot;pl-c1&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;;&lt;/span&gt;
+------+
&lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; idx  &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt;
+------+
&lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt;    1 &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt;    2 &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt;
+------+
2 rows &lt;span class=&quot;pl-k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;set&lt;/span&gt; (0.00 sec)

mysql&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt; rollback&lt;span class=&quot;pl-k&quot;&gt;;&lt;/span&gt;
Query OK, 0 rows affected (0.00 sec)

mysql&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;*&lt;/span&gt; from &lt;span class=&quot;pl-c1&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;;&lt;/span&gt;
Empty &lt;span class=&quot;pl-c1&quot;&gt;set&lt;/span&gt; (0.00 sec)

mysql&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt; insert into &lt;span class=&quot;pl-c1&quot;&gt;test&lt;/span&gt; values(3)&lt;span class=&quot;pl-k&quot;&gt;;&lt;/span&gt;
Query OK, 1 row affected (0.00 sec)

mysql&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt; commit&lt;span class=&quot;pl-k&quot;&gt;;&lt;/span&gt;
Query OK, 0 rows affected (0.00 sec)

mysql&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt; rollback&lt;span class=&quot;pl-k&quot;&gt;;&lt;/span&gt;
Query OK, 0 rows affected (0.00 sec)

mysql&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;*&lt;/span&gt; from &lt;span class=&quot;pl-c1&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;;&lt;/span&gt;
+------+
&lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; idx  &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt;
+------+
&lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt;    3 &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt;
+------+
1 row &lt;span class=&quot;pl-k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;set&lt;/span&gt; (0.00 sec)
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;事务中会触发隐式提交的操作&lt;/h2&gt;
&lt;p&gt;虽说事务模式下关闭了 &lt;code&gt;autocommit&lt;/code&gt; 必需手动执行 &lt;code&gt;COMMIT&lt;/code&gt; 才能提交，但有些语句和操作是会隐式触发提交的，在进行事务过程中需要注意，这些操作可在官方文档 &lt;a href=&quot;https://dev.mysql.com/doc/refman/5.5/en/implicit-commit.html&quot; rel=&quot;nofollow&quot;&gt;Statements That Cause an Implicit Commit&lt;/a&gt; 中查找到。&lt;/p&gt;
&lt;p&gt;所以不能单纯地认为一个事务中所有操作都是绝对安全可回滚的。&lt;/p&gt;
&lt;h2&gt;Node.js 示例&lt;/h2&gt;
&lt;p&gt;以下是来自 npm 模块 &lt;a href=&quot;https://github.com/mysqljs/mysql#transactions&quot;&gt;mysqljs/mysql&lt;/a&gt; 关于事务的示例：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;18&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-smi&quot;&gt;connection&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;beginTransaction&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;err&lt;/span&gt;) {
  &lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; (err) { &lt;span class=&quot;pl-k&quot;&gt;throw&lt;/span&gt; err; }
  &lt;span class=&quot;pl-smi&quot;&gt;connection&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;query&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;INSERT INTO posts SET title=?&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;, title, &lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;pl-smi&quot;&gt;error&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;results&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;fields&lt;/span&gt;) {
    &lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; (error) {
      &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;connection&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;rollback&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt;() {
        &lt;span class=&quot;pl-k&quot;&gt;throw&lt;/span&gt; error;
      });
    }

    &lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; log &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;Post &lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;results&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;insertId&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt; added&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;;

    &lt;span class=&quot;pl-smi&quot;&gt;connection&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;query&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;INSERT INTO log SET data=?&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;, log, &lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;pl-smi&quot;&gt;error&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;results&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;fields&lt;/span&gt;) {
      &lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; (error) {
        &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;connection&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;rollback&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt;() {
          &lt;span class=&quot;pl-k&quot;&gt;throw&lt;/span&gt; error;
        });
      }
      &lt;span class=&quot;pl-smi&quot;&gt;connection&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;commit&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;err&lt;/span&gt;) {
        &lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; (err) {
          &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;connection&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;rollback&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt;() {
            &lt;span class=&quot;pl-k&quot;&gt;throw&lt;/span&gt; err;
          });
        }
        &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;success!&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;);
      });
    });
  });
});
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;关于 &lt;code&gt;autocommit&lt;/code&gt; 与事务，他们其实是这样的关系：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;MySQL 每一步操作都可看成一个原子操作。&lt;/li&gt;
&lt;li&gt;默认情况下，&lt;code&gt;autocommit&lt;/code&gt; 是开启状态，所以第一条语句都是执行后自动提交，语句产生的效果被记录保存了下来。&lt;/li&gt;
&lt;li&gt;关于 &lt;code&gt;autocommit&lt;/code&gt; 后，语句不会自动提交，需要手动调用 &lt;code&gt;COMMIT&lt;/code&gt; 来让效果被持久化。&lt;/li&gt;
&lt;li&gt;也可通过 &lt;code&gt;BEGIN&lt;/code&gt; 开始一个事务，此时 &lt;code&gt;autocommit&lt;/code&gt; 隐式地被关闭了，因此事务操作过程中也是需要显式调用 &lt;code&gt;COMMIT&lt;/code&gt; 来让效果永久生效。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BEGIN&lt;/code&gt; 开启事务后，使用 &lt;code&gt;COMMIT&lt;/code&gt; 或 &lt;code&gt;ROLLBACK&lt;/code&gt; 来结束该事务。事务结束后 &lt;code&gt;autocommit&lt;/code&gt; 回到原有的状态。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所以，&lt;code&gt;autocommit&lt;/code&gt; 这个开关相当于一个记录的事务标记，它被关闭时你一直处于一个可回滚的状态。而 &lt;code&gt;BEGIN&lt;/code&gt; 开启的是一次临时事务，一旦 &lt;code&gt;COMMIT&lt;/code&gt; 或 &lt;code&gt;ROLLBACK&lt;/code&gt; 本次事务便结束了。&lt;/p&gt;
&lt;h2&gt;相关资源&lt;/h2&gt;
</description>
<pubDate>Thu, 23 May 2019 15:06:00 +0000</pubDate>
<dc:creator>刘哇勇</dc:creator>
<og:description>多表关联的情况下，一条新记录的生成往往涉及多多张表的操作。 一个典型的场景，银行转帐。要完成 A 转帐到 B， 从 A 帐户减去相应金额 给 B 帐户加上相应金额。 这两步要么一起成功，要么都失败，否</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Wayou/p/mysql_transaction.html</dc:identifier>
</item>
<item>
<title>死磕 java同步系列之自己动手写一个锁Lock - 彤哥读源码</title>
<link>http://www.cnblogs.com/tong-yuan/p/mylock.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tong-yuan/p/mylock.html</guid>
<description>&lt;h2 id=&quot;问题&quot;&gt;问题&lt;/h2&gt;
&lt;p&gt;（1）自己动手写一个锁需要哪些知识？&lt;/p&gt;
&lt;p&gt;（2）自己动手写一个锁到底有多简单？&lt;/p&gt;
&lt;p&gt;（3）自己能不能写出来一个完美的锁？&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;本篇文章的目标一是自己动手写一个锁，这个锁的功能很简单，能进行正常的加锁、解锁操作。&lt;/p&gt;
&lt;p&gt;本篇文章的目标二是通过自己动手写一个锁，能更好地理解后面章节将要学习的AQS及各种同步器实现的原理。&lt;/p&gt;
&lt;h2 id=&quot;分析&quot;&gt;分析&lt;/h2&gt;
&lt;p&gt;自己动手写一个锁需要准备些什么呢？&lt;/p&gt;
&lt;p&gt;首先，在上一章学习synchronized的时候我们说过它的实现原理是更改对象头中的MarkWord，标记为已加锁或未加锁。&lt;/p&gt;
&lt;p&gt;但是，我们自己是无法修改对象头信息的，那么我们可不可以用一个变量来代替呢？&lt;/p&gt;
&lt;p&gt;比如，这个变量的值为1的时候就说明已加锁，变量值为0的时候就说明未加锁，我觉得可行。&lt;/p&gt;
&lt;p&gt;其次，我们要保证多个线程对上面我们定义的变量的争用是可控的，所谓可控即同时只能有一个线程把它的值修改为1，且当它的值为1的时候其它线程不能再修改它的值，这种是不是就是典型的CAS操作，所以我们需要使用Unsafe这个类来做CAS操作。&lt;/p&gt;
&lt;p&gt;然后，我们知道在多线程的环境下，多个线程对同一个锁的争用肯定只有一个能成功，那么，其它的线程就要排队，所以我们还需要一个队列。&lt;/p&gt;
&lt;p&gt;最后，这些线程排队的时候干嘛呢？它们不能再继续执行自己的程序，那就只能阻塞了，阻塞完了当轮到这个线程的时候还要唤醒，所以我们还需要Unsfae这个类来阻塞（park）和唤醒（unpark）线程。&lt;/p&gt;
&lt;p&gt;基于以上四点，我们需要的神器大致有：一个变量、一个队列、执行CAS/park/unpark的Unsafe类。&lt;/p&gt;
&lt;p&gt;大概的流程图如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/alan-tang-tt/yuan/raw/master/%E6%AD%BB%E7%A3%95%20java%E5%90%8C%E6%AD%A5%E7%B3%BB%E5%88%97/resource/mylock1.png&quot; alt=&quot;mylock&quot;/&gt;&lt;/p&gt;
&lt;p&gt;关于Unsafe类的相关讲解请参考彤哥之前发的文章：&lt;/p&gt;
&lt;p&gt;【&lt;a href=&quot;https://mp.weixin.qq.com/s/0s-u-MysppIaIHVrshp9fA&quot;&gt;死磕 java魔法类之Unsafe解析&lt;/a&gt;】&lt;/p&gt;
&lt;h2 id=&quot;解决&quot;&gt;解决&lt;/h2&gt;
&lt;h3 id=&quot;一个变量&quot;&gt;一个变量&lt;/h3&gt;
&lt;p&gt;这个变量只支持同时只有一个线程能把它修改为1，所以它修改完了一定要让其它线程可见，因此，这个变量需要使用volatile来修饰。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private volatile int state;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;cas&quot;&gt;CAS&lt;/h3&gt;
&lt;p&gt;这个变量的修改必须是原子操作，所以我们需要CAS更新它，我们这里使用Unsafe来直接CAS更新int类型的state。&lt;/p&gt;
&lt;p&gt;当然，这个变量如果直接使用AtomicInteger也是可以的，不过，既然我们学习了更底层的Unsafe类那就应该用（浪）起来。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private boolean compareAndSetState(int expect, int update) {
    return unsafe.compareAndSwapInt(this, stateOffset, expect, update);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;一个队列&quot;&gt;一个队列&lt;/h3&gt;
&lt;p&gt;队列的实现有很多，数组、链表都可以，我们这里采用链表，毕竟链表实现队列相对简单一些，不用考虑扩容等问题。&lt;/p&gt;
&lt;p&gt;这个队列的操作很有特点：&lt;/p&gt;
&lt;p&gt;放元素的时候都是放到尾部，且可能是多个线程一起放，所以对尾部的操作要CAS更新；&lt;/p&gt;
&lt;p&gt;唤醒一个元素的时候从头部开始，但同时只有一个线程在操作，即获得了锁的那个线程，所以对头部的操作不需要CAS去更新。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private static class Node {
    // 存储的元素为线程
    Thread thread;
    // 前一个节点（可以没有，但实现起来很困难）
    Node prev;
    // 后一个节点
    Node next;

    public Node() {
    }

    public Node(Thread thread, Node prev) {
        this.thread = thread;
        this.prev = prev;
    }
}
// 链表头
private volatile Node head;
// 链表尾
private volatile Node tail;
// 原子更新tail字段
private boolean compareAndSetTail(Node expect, Node update) {
    return unsafe.compareAndSwapObject(this, tailOffset, expect, update);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个队列很简单，存储的元素是线程，需要有指向下一个待唤醒的节点，前一个节点可有可无，但是没有实现起来很困难，不信学完这篇文章你试试。&lt;/p&gt;
&lt;h3 id=&quot;加锁&quot;&gt;加锁&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void lock() {
    // 尝试更新state字段，更新成功说明占有了锁
    if (compareAndSetState(0, 1)) {
        return;
    }
    // 未更新成功则入队
    Node node = enqueue();
    Node prev = node.prev;
    // 再次尝试获取锁，需要检测上一个节点是不是head，按入队顺序加锁
    while (node.prev != head || !compareAndSetState(0, 1)) {
        // 未获取到锁，阻塞
        unsafe.park(false, 0L);
    }
    // 下面不需要原子更新，因为同时只有一个线程访问到这里
    // 获取到锁了且上一个节点是head
    // head后移一位
    head = node;
    // 清空当前节点的内容，协助GC
    node.thread = null;
    // 将上一个节点从链表中剔除，协助GC
    node.prev = null;
    prev.next = null;
}
// 入队
private Node enqueue() {
    while (true) {
        // 获取尾节点
        Node t = tail;
        // 构造新节点
        Node node = new Node(Thread.currentThread(), t);
        // 不断尝试原子更新尾节点
        if (compareAndSetTail(t, node)) {
            // 更新尾节点成功了，让原尾节点的next指针指向当前节点
            t.next = node;
            return node;
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（1）尝试获取锁，成功了就直接返回；&lt;/p&gt;
&lt;p&gt;（2）未获取到锁，就进入队列排队；&lt;/p&gt;
&lt;p&gt;（3）入队之后，再次尝试获取锁；&lt;/p&gt;
&lt;p&gt;（4）如果不成功，就阻塞；&lt;/p&gt;
&lt;p&gt;（5）如果成功了，就把头节点后移一位，并清空当前节点的内容，且与上一个节点断绝关系；&lt;/p&gt;
&lt;p&gt;（6）加锁结束；&lt;/p&gt;
&lt;h3 id=&quot;解锁&quot;&gt;解锁&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 解锁
public void unlock() {
    // 把state更新成0，这里不需要原子更新，因为同时只有一个线程访问到这里
    state = 0;
    // 下一个待唤醒的节点
    Node next = head.next;
    // 下一个节点不为空，就唤醒它
    if (next != null) {
        unsafe.unpark(next.thread);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（1）把state改成0，这里不需要CAS更新，因为现在还在加锁中，只有一个线程去更新，在这句之后就释放了锁；&lt;/p&gt;
&lt;p&gt;（2）如果有下一个节点就唤醒它；&lt;/p&gt;
&lt;p&gt;（3）唤醒之后就会接着走上面lock()方法的while循环再去尝试获取锁；&lt;/p&gt;
&lt;p&gt;（4）唤醒的线程不是百分之百能获取到锁的，因为这里state更新成0的时候就解锁了，之后可能就有线程去尝试加锁了。&lt;/p&gt;
&lt;h3 id=&quot;测试&quot;&gt;测试&lt;/h3&gt;
&lt;p&gt;上面完整的锁的实现就完了，是不是很简单，但是它是不是真的可靠呢，敢不敢来试试？！&lt;/p&gt;
&lt;p&gt;直接上测试代码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private static int count = 0;

public static void main(String[] args) throws InterruptedException {
    MyLock lock = new MyLock();

    CountDownLatch countDownLatch = new CountDownLatch(1000);

    IntStream.range(0, 1000).forEach(i -&amp;gt; new Thread(() -&amp;gt; {
        lock.lock();

        try {
            IntStream.range(0, 10000).forEach(j -&amp;gt; {
                count++;
            });
        } finally {
            lock.unlock();
        }
//            System.out.println(Thread.currentThread().getName());
        countDownLatch.countDown();
    }, &quot;tt-&quot; + i).start());

    countDownLatch.await();

    System.out.println(count);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行这段代码的结果是总是打印出10000000（一千万），说明我们的锁是正确的、可靠的、完美的。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;（1）自己动手写一个锁需要做准备：一个变量、一个队列、Unsafe类。&lt;/p&gt;
&lt;p&gt;（2）原子更新变量为1说明获得锁成功；&lt;/p&gt;
&lt;p&gt;（3）原子更新变量为1失败说明获得锁失败，进入队列排队；&lt;/p&gt;
&lt;p&gt;（4）更新队列尾节点的时候是多线程竞争的，所以要使用原子更新；&lt;/p&gt;
&lt;p&gt;（5）更新队列头节点的时候只有一个线程，不存在竞争，所以不需要使用原子更新；&lt;/p&gt;
&lt;p&gt;（6）队列节点中的前一个节点prev的使用很巧妙，没有它将很难实现一个锁，只有写过的人才明白，不信你试试^^&lt;/p&gt;
&lt;h2 id=&quot;彩蛋&quot;&gt;彩蛋&lt;/h2&gt;
&lt;p&gt;（1）我们实现的锁支持可重入吗？&lt;/p&gt;
&lt;p&gt;答：不可重入，因为我们每次只把state更新为1。如果要支持可重入也很简单，获取锁时检测锁是不是被当前线程占有着，如果是就把state的值加1，释放锁时每次减1即可，减为0时表示锁已释放。&lt;/p&gt;
&lt;p&gt;（2）我们实现的锁是公平锁还是非公平锁？&lt;/p&gt;
&lt;p&gt;答：非公平锁，因为获取锁的时候我们先尝试了一次，这里并不是严格的排队，所以是非公平锁。&lt;/p&gt;
&lt;p&gt;（3）完整源码&lt;/p&gt;
&lt;p&gt;关注我的公众号“彤哥读源码”，后台回复“mylock”获取本章完整源码。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;注：下一章我们将开始分析传说中的AQS，这章是基础，请各位老铁务必搞明白。&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;推荐阅读&quot;&gt;推荐阅读&lt;/h2&gt;
&lt;ol readability=&quot;0.017241379310345&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/0s-u-MysppIaIHVrshp9fA&quot;&gt;死磕 java魔法类之Unsafe解析&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/jownTN--npu3o8B4c3sbeA&quot;&gt;死磕 java同步系列之JMM（Java Memory Model）&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/TROZ4BhcDImwHvhAl_I_6w&quot;&gt;死磕 java同步系列之volatile解析&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/RT7VreIh9PU03HhE3WSLjg&quot;&gt;死磕 java同步系列之synchronized解析&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;hr/&gt;&lt;p&gt;欢迎关注我的公众号“彤哥读源码”，查看更多源码系列文章, 与彤哥一起畅游源码的海洋。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/alan-tang-tt/yuan/raw/master/%E6%AD%BB%E7%A3%95%20java%E9%9B%86%E5%90%88%E7%B3%BB%E5%88%97/resource/qrcode_ss.jpg&quot; alt=&quot;qrcode&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 23 May 2019 14:47:00 +0000</pubDate>
<dc:creator>彤哥读源码</dc:creator>
<og:description>自己动手写一个锁需要哪些知识？ 自己动手写一个锁到底有多简单？ 自己能不能写出来一个完美的锁？</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tong-yuan/p/mylock.html</dc:identifier>
</item>
<item>
<title>C# 多线程小试牛刀 - BUTTERAPPLE</title>
<link>http://www.cnblogs.com/xiyin/p/10915068.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiyin/p/10915068.html</guid>
<description>&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;昨天在上班时浏览博问，发现了一个问题，虽然自己在 C# 多线程上没有怎么尝试过，看了几遍 CLR 中关于 线程的概念和讲解（后面三章）。也想拿来实践实践。问题定义是这样的：&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;对于多线程不是很懂，面试的时候遇到一个多线程的题，不会做，分享出来，懂的大佬指点一下，谢谢&lt;/p&gt;
&lt;p&gt;建一个winform窗体，在窗体中放上一个开始按钮，一个停止按钮，一个文本框，在窗体中声明一个List类型的属性，点击开始按钮后开启10个线程，所有线程同时不间断的给List集合中添加1-10000之间的随机数，要求添加List集合中的数字不能重复，并且实时在文本框中显示集合的长度，当集合List的长度等于1000时自动停止所有线程，如果中途点击停止按钮也停止所有线程，点击开始又继续执行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我其实没有完全实现了这位博问中提问的同学的需求，具体问题的来源可查看该地址 &lt;a href=&quot;https://q.cnblogs.com/q/115424/&quot;&gt;问题来源&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;开始尝试&quot;&gt;开始尝试&lt;/h3&gt;
&lt;p&gt;刚拿到这个需求的时候，映入我脑海里的是 Task, Threadpool，Concurrent，和 Lock 等概念，接下来就是组装和编码的过程了，首先理一理头绪，&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;生成随机数&lt;/li&gt;
&lt;li&gt;插入到 List 中，且不能重复&lt;/li&gt;
&lt;li&gt;开启多个线程同时插入。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;首先是生成 随机数，使用 System.Random 类来生成伪随机数（这个其实性能和效率贼低，后面再叙述）&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;private int GenerateInt32Num()
{
    var num = random.Next(0, TOTAL_NUM);
    return num;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后是插入到 &lt;code&gt;List&amp;lt;Int32&amp;gt;&lt;/code&gt; 中的代码，判断是否 已经达到了 我们需要的 List 长度，如果已满足，则退出程序。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;private void AddToList(int num)
{
    if (numList.Count == ENDNUM)
    {
        return;
    }

    numList.Add(num);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果是个 单线程的，按照上面那样 while(true) 然后一直插入即可，可这个是个 多线程，那么需要如何处理呢？&lt;/p&gt;
&lt;p&gt;我思考了一下，想到了之前在 CLR 中学到的 可以用 CancellationTokenSource 中的 Cancel 来通知 Task 来取消操作。所以现在的逻辑是，用线程池来实现多线程。然后传入 CancellationTokenSource.Token 来取消任务。&lt;/p&gt;
&lt;p&gt;最后用 Task.WhanAny() 来获取到第一个到达此 Task 的 ID。&lt;/p&gt;
&lt;p&gt;首先是建立 Task[] 的数组&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;internal void DoTheCompeteSecond()
{
    Task[] tasks = new Task[10];

    for (int i = 0; i &amp;lt; 10; ++i)
    {
        int num = i;
        tasks[i] = Task.Factory.StartNew(() =&amp;gt; AddNumToList(num, cts), cts.Token);
    }

    Task.WaitAny(tasks);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后 AddNumToList 方法是这样定义的，&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;private void AddNumToList(object state, CancellationTokenSource cts)
{-
    Console.WriteLine(&quot;This is the {0} thread,Current ThreadId={1}&quot;,
                      state,
                      Thread.CurrentThread.ManagedThreadId);

    while (!cts.Token.IsCancellationRequested)
    {
        if (GetTheListCount() == ENDNUM)
        {
            cts.Cancel();
            Console.WriteLine(&quot;Current Thread Id={0},Current Count={1}&quot;,
                              Thread.CurrentThread.ManagedThreadId,
                              GetTheListCount());

            break;
        }
        var insertNum = GenerateInt32Num();
        if (numList.Contains(insertNum))
        {
            insertNum = GenerateInt32Num();
        }

        AddToList(insertNum);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看起来是没有什么问题的，运行了一下。得到了如下结果，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/q/778580/201905/778580-20190522224507485-463217976.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这应该是昨晚运行时得到的数据，当时也没有多想，就贴了上去，回答了那位提问同学的问题。但是心里有一个疑惑，为什么会同时由 两个 Thread 同时达到了该目标呢？&lt;/p&gt;
&lt;h3 id=&quot;发现问题&quot;&gt;发现问题&lt;/h3&gt;
&lt;p&gt;今天早上到公司时，我又打开了这个 代码，发现确实有点不对劲，于是就和我边上 做 Go 语言开发的同学，问了问他，哪里出现了问题，他和我说：“你加了读写锁了吗?” 你这里有数据脏读写。心里面有了点眉目。&lt;/p&gt;
&lt;p&gt;按照他说的，修改了一下&lt;code&gt;AddToList&lt;/code&gt; 里面的逻辑，这时候，确实解决了上面的问题，&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;private void AddToList(int num)
{
    rwls.EnterReadLock();
    if (numList.Count == ENDNUM)
        return;
    rwls.ExitReadLock();

    rwls.EnterWriteLock();
    numList.Add(num);
    rwls.ExitWriteLock();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;得到的结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/q/778580/201905/778580-20190523122738237-1390845021.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;完整的代码如下所示：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Threading;
using System.Threading.Tasks;

namespace CSharpFundamental
{
    class MultipleThreadCompete
    {
        List&amp;lt;int&amp;gt; numList = new List&amp;lt;int&amp;gt;();
        Random random = new Random();
        CancellationTokenSource cts = new CancellationTokenSource();
        private const int ENDNUM = 1000000;

        ReaderWriterLockSlim rwls = new ReaderWriterLockSlim();

        internal void DoTheCompeteSecond()
        {
            Stopwatch sw = new Stopwatch();
            sw.Start();
            Task[] tasks = new Task[100];

            for (int i = 0; i &amp;lt; 100; ++i)
            {
                int num = i;
                tasks[i] = Task.Run(() =&amp;gt; AddNumToList(num, cts), cts.Token);
            }

            Task.WaitAny(tasks);

            Console.WriteLine(&quot;ExecuteTime={0}&quot;, sw.ElapsedMilliseconds / 1000);
        }

        private int GetTheListCount()
        {
            return numList.Count;
        }

        private void AddToList(int num)
        {
            rwls.EnterReadLock();
            if (numList.Count == ENDNUM)
                return;
            rwls.ExitReadLock();

            rwls.EnterWriteLock();
            numList.Add(num);
            rwls.ExitWriteLock();
        }

        private void AddNumToList(object state, CancellationTokenSource cts)
        {
            Console.WriteLine(&quot;This is the {0} thread,Current ThreadId={1}&quot;,
                state,
                Thread.CurrentThread.ManagedThreadId);

            while (!cts.Token.IsCancellationRequested)
            {
                try
                {
                    rwls.EnterReadLock();
                    if (numList.Count == ENDNUM)
                    {
                        cts.Cancel();
                        Console.WriteLine(&quot;Current Thread Id={0},Current Count={1}&quot;,
                            Thread.CurrentThread.ManagedThreadId,
                            GetTheListCount());
                        break;
                    }
                }
                finally
                {
                    rwls.ExitReadLock();
                }

                var insertNum = GenerateInt32Num();
                if (numList.Contains(insertNum))
                {
                    insertNum = GenerateInt32Num();
                }

                AddToList(insertNum);
            }
        }

        private int GenerateInt32Num()
        {
            return random.Next(1, ENDNUM);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这时候，那位 Go 语言的同学和我说，我们试试 1000w 的数据插入，看看需要多少时间？于是我让他用 Go 语言实现了一下上面的逻辑，1000w数据用了 三分钟，我让他看看总共生成了多少随机数，他查看了一下生成了 1亿4千多万的数据。&lt;/p&gt;
&lt;p&gt;最开始我用上面的代码来测，发现我插入 1000w 的数据，CPU 到100% 而且花了挺长时间，程序根本没反应，查看了一下我判断重复的语句&lt;code&gt;numList.Contains()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;底层实现的代码为:&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;[__DynamicallyInvokable]
    public bool Contains(T item)
    {
        if ((object) item == null)
        {
            for (int index = 0; index &amp;lt; this._size; ++index)
            {
                if ((object) this._items[index] == null)
                    return true;
            }
            return false;
        }
        EqualityComparer&amp;lt;T&amp;gt; equalityComparer = EqualityComparer&amp;lt;T&amp;gt;.Default;
        for (int index = 0; index &amp;lt; this._size; ++index)
        {
            if (equalityComparer.Equals(this._items[index], item))
                return true;
        }
        return false;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可想而知，如果数据量很大的话，这个循环不就 及其缓慢吗？&lt;/p&gt;
&lt;p&gt;我于是请教了那位 GO 的同学，判断重复的逻辑用什么来实现的，他和我说了一个位图 bitmap 的概念，&lt;/p&gt;
&lt;p&gt;我用其重写了一下判断重复的逻辑，代码如下：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;int[] bitmap = new int[MAX_SIZE]；

var index = num % TOTAL_NUM;
bitMap[index] = 1;

return bitMap[num] == 1;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在添加到 List 的时候，顺便插入到 bitmap 中，判断重复只需要根据当前元素的位置是否 等于 1 即可，&lt;/p&gt;
&lt;p&gt;我修改代码后，跑了一下 1000w 的数据用来 3000+ ms。&lt;/p&gt;
&lt;p&gt;这时候，引起了他的极度怀疑，一向以高性能并发 著称的 Go 速度竟然这么慢吗？他一度怀疑我的逻辑有问题。&lt;/p&gt;
&lt;p&gt;下午结束了一个阶段的工作后，我又拾起了我上午写的代码，果不其然，发现了逻辑错误：&lt;/p&gt;
&lt;p&gt;如下：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;var insertNum = GenerateInt32Num();
if (numList.Contains(insertNum))
{
    insertNum = GenerateInt32Num();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;生成随机数这里，这里有个大问题，就是其实只判断了一次，导致速度那么快，正确的写法应该是&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;while (ContainsNum(currentNum))
{
    currentNum = GenerateInt32Num();
}

private int GenerateInt32Num()
{
    var num = random.Next(0, TOTAL_NUM);
    //Console.WriteLine(num);

    return num;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后的代码如下：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Threading;
using System.Threading.Tasks;

namespace CSharpFundamental
{
    class MultipleThreadCompete
    {
        List&amp;lt;int&amp;gt; numList = new List&amp;lt;int&amp;gt;();
        Random random = new Random();
        CancellationTokenSource cts = new CancellationTokenSource();
        private const int TOTAL_NUM = 1000000;
        private const int CURRENT_THREAD_COUNT = 35;

        ReaderWriterLockSlim rwls = new ReaderWriterLockSlim();

        int[] bitMap = new int[TOTAL_NUM];

        internal void DoTheCompete()
        {
            //ThreadPool.SetMinThreads(CURRENT_THREAD_COUNT, CURRENT_THREAD_COUNT);
            Stopwatch sw = new Stopwatch();
            sw.Start();
            Task[] tasks = new Task[CURRENT_THREAD_COUNT];

            for (int i = 0; i &amp;lt; CURRENT_THREAD_COUNT; ++i)
            {
                int num = i;
                tasks[i] = Task.Run(() =&amp;gt; ExecuteTheTask(num, cts), cts.Token);
            }

            Task.WaitAny(tasks);

            Console.WriteLine(&quot;ExecuteTime={0}&quot;, sw.ElapsedMilliseconds);
        }

        private int GetTheListCount()
        {
            return numList.Count;
        }

        private void AddToList(int num)
        {
            if (numList.Count == TOTAL_NUM)
                return;
            numList.Add(num);

            var index = num % TOTAL_NUM;
            bitMap[index] = 1;
        }

        private void ExecuteTheTask(object state, CancellationTokenSource cts)
        {
            Console.WriteLine(&quot;This is the {0} thread,Current ThreadId={1}&quot;,
                state,
                Thread.CurrentThread.ManagedThreadId);

            while (!cts.Token.IsCancellationRequested)
            {
                try
                {
                    rwls.EnterReadLock();
                    if (numList.Count == TOTAL_NUM)
                    {
                        cts.Cancel();
                        Console.WriteLine(&quot;Current Thread Id={0},Current Count={1}&quot;,
                            Thread.CurrentThread.ManagedThreadId,
                            GetTheListCount());
                        break;
                    }
                }
                finally
                {
                    rwls.ExitReadLock();
                }

                var currentNum = GenerateInt32Num();

                while (ContainsNum(currentNum))
                {
                    currentNum = GenerateInt32Num();
                }

                rwls.EnterWriteLock();
                AddToList(currentNum);
                rwls.ExitWriteLock();
            }
        }

        private int GenerateInt32Num()
        {
            var num = random.Next(0, TOTAL_NUM);
            //Console.WriteLine(num);

            return num;
        }

        private bool ContainsNum(int num)
        {
            rwls.EnterReadLock();
            var contains = bitMap[num] == 1;
            rwls.ExitReadLock();

            return contains;
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/q/778580/201905/778580-20190523222833151-2142892477.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是这个代码执行 1000w的数据需要好久。 这个问题继续研究。&lt;/p&gt;
&lt;p&gt;源码地址：&lt;a href=&quot;https://github.com/doublnt/dotnetcore/tree/master/CSharpFundamental&quot; class=&quot;uri&quot;&gt;https://github.com/doublnt/dotnetcore/tree/master/CSharpFundamental&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎大佬指点，还望不吝赐教。&lt;/p&gt;
</description>
<pubDate>Thu, 23 May 2019 14:34:00 +0000</pubDate>
<dc:creator>BUTTERAPPLE</dc:creator>
<og:description>前言 昨天在上班时浏览博问，发现了一个问题，虽然自己在 C 多线程上没有怎么尝试过，看了几遍 CLR 中关于 线程的概念和讲解（后面三章）。也想拿来实践实践。问题定义是这样的： 对于多线程不是很懂，面</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiyin/p/10915068.html</dc:identifier>
</item>
<item>
<title>深入探究Java中hashCode()和equals()的关系 - 炭烧生蚝</title>
<link>http://www.cnblogs.com/tanshaoshenghao/p/10915055.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tanshaoshenghao/p/10915055.html</guid>
<description>&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;在学习hashCode()和equals()之间的关系之前, 我们有必要先单独了解他俩自身的特点.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;equals()方法用于比较两个对象是否相等, 它与&quot;==&quot;相等比较符有着本质的不同. 在万物皆对象的Java体系中, 系统把判断对象是否相等的权力交给程序员, 具体的措施是把equals()方法写入到Object类中, 并让所有类继承Object类. 这样程序员就能在类中自定义equals()方法, 从而实现自己的业务逻辑.&lt;/li&gt;
&lt;li&gt;关于equals()和&quot;==&quot;的区别你可以&lt;a href=&quot;https://juejin.im/post/5ce2a8bc6fb9a07f04201bb5&quot;&gt;--参考这篇文章--&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;&lt;li&gt;hashCode()的意思是哈希值, 哈希值是哈希函数运算后得到的结果, 哈希函数能够保证相同的输入能够得到相同的输出(哈希值), 但是不能够保证不同的输入总是能得出不同的输出. 当输入的样本量足够大时, 是会产生哈希冲突的, 也就是不同的输入产生了相同的输出.&lt;/li&gt;
&lt;li&gt;暂且不谈冲突, 就相同的输入能够产生相同的输出这点而言, 是及其宝贵的. 它使得系统只需要通过简单的运算, 在时间复杂度O(1)的情况下就能得出数据的映射关系, 根据这种特性引申出了散列表这种数据结构.&lt;/li&gt;
&lt;li&gt;一种主流的散列表实现是: 用数组作为哈希函数的输出域, 输入值经过哈希函数计算后得到哈希值, 然后根据哈希值在数组种找到对应的存储单元. 当发生冲突时, 对应的存储单元以链表的形式保存冲突的数据.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;下面我们从一个宏观的角度引入hashCode()和equals()之间的关系&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;在大多数编程实践中, 归根结底会落实到数据的存取问题上. 在汇编语言时代, 你需要老老实实地对每个数据操作编写存取语句; 随着时代发展到今天, 我们都用类似Java这样的高级语言编写代码. Java除了拥有面向对象的核心思想外, 还给我们封装了一系列操作数据的api, 为编程工作提供了极大的便利.&lt;/li&gt;
&lt;li&gt;但在我们对数据进行操作之前, 首先要把数据按照一定的数据结构保存到存储单元中, 否则操作数据将无从谈起. 然而不同的数据结构有各自的特点, 我们在存储数据的时候需要选择适合自己的数据结构进行存储. Java根据不同的数据结构提供了丰富的容器类, 方便程序员选择适合业务的容器类进行开发.&lt;/li&gt;
&lt;li&gt;而Java的容器类被分为Collection和Map两大类, Collection又可以进一步分为List和Set. 其中Map和Set都是不允许元素重复的, 严格来说Map存储的是键值对, 它不允许重复的键值. 值得注意的是: Map和Set的绝大多数实现类的底层都会用到散列表结构.&lt;/li&gt;
&lt;li&gt;讲到这里我们提取两个关键字&lt;strong&gt;不允许重复&lt;/strong&gt;和&lt;strong&gt;散列表结构&lt;/strong&gt;, 回顾hashCode()和equals()的特点, 你是否想到了些什么东西呢?&lt;/li&gt;
&lt;/ul&gt;

&lt;ul&gt;&lt;li&gt;上面提到Set和Map不存放重复的元素(key), 那么在存储元素的时候就必须对元素做出判断: &lt;strong&gt;在当前的容器中有没有和新元素相同的元素?&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;你可能会想: 这容易呀, 直接调用元素对象的equals()方法进行比较不就行了吗? 如果容器中的存储的对象数量较少, 这确实是个好主意, 但是如果容器中存放的对象达到了一定的规模, 要调用容器中所有对象的equals()方法和新元素进行比较就不是一件容易的事情了, 就算equals()方法的比较逻辑简单无比, 这也是一个时间复杂度为O(n)的操作啊.&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;&lt;li&gt;但在散列表的基础上判断&quot;新对象是否和容器中任一对象相同&quot;就容易得多了. 由于每个对象都自带有hashCode(), 这个hashCode将会用作散列表哈希函数的输入, hashCode经过哈希函数计算后得到哈希值, 新对象根据哈希值存储到相应的内存的单元.&lt;/li&gt;
&lt;li&gt;我们不妨假设&lt;strong&gt;两个相同的对象, hashCode()一定相同&lt;/strong&gt;, 这么一来就体现出哈希函数的威力了, 由于相同的输入一定会产生相同的输出, 于是如果新对象和容器中已存在的对象相同, 新对象计算出的哈希值就会和已存在的对象的哈希值产生冲突, 这时容器就能判断: 这个新加入的元素已经存在, 需要另作处理(覆盖掉原来的元素(key)或舍弃).&lt;/li&gt;
&lt;li&gt;按照这个思路, 如果这个元素计算出的哈希值所对应的地址没有产生冲突, 也就是没有重复的元素, 那么它就可以直接插入. &lt;strong&gt;所以当运用hashCode()时, 判断是否有相同元素的代价只是一次哈希计算, 时间复杂度为O(1)&lt;/strong&gt;, 这极大地提高了数据的存储性能.&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;&lt;li&gt;但是前面我们还提到: 当输入样本量足够大时, 不相同的输入是会产生相同输出的, 也就是形成哈希冲突. 这么一来就麻烦了, 原来我们设定的&quot;如果产生冲突, 就意味着两个对象相同&quot;的规则瞬间被打破, 产生冲突的很有可能是两个不同的对象!&lt;/li&gt;
&lt;li&gt;而令人欣慰的是我们除了hashCode()方法, 还有一张王牌: equals()方法. 也就是说当两个不相同的对象产生哈希冲突后, 我们可以用equals()方法进一步判断两个对象是否相同. 这时equals()方法就相当重要了, 这个情况下它必须要能判定这两个对象是不相同的.&lt;/li&gt;
&lt;li&gt;讲到这里就引出了Java程序设计中一些重要原则:&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;如果两个对象是相等的, 它们的equals()方法应该要返回true, 它们的hashCode()需要返回相同的结果&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;但有时候面试题不会问得这么直接, 它会问你:&lt;strong&gt;两个对象的hashCdoe()相同, 它的equals()方法一定要返回true, 对吗?&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;那答案肯定不对. 因为我们不能保证每个程序设计者都会遵循编码规则, 有可能两个不同对象的hashCode()会返回相同的结果. 如果你理解上面的内容, 这个问题就很好解答: 两个对象的hashCode()相同, 将来会在散列表中产生哈希冲突, 但是它们不一定是相同的对象呀. 当产生哈希冲突时, 我们还得通过equals()方法进一步判断两个对象是否相同, equals()方法不一定会返回true.&lt;/li&gt;
&lt;li&gt;这也是为什么Java官方推荐我们最好同时重写hashCode()和equals()方法的原因.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;以上的文字是我经过思考后得出的, 它有一定依据但并非完全可靠, 下面我们根据HashMap的源码(JDK1.8)和官方文档来验证这些推论是否正确.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;通过阅读JDK8的官方文档, 我们发现equals()方法介绍的最后有这么一段话:&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;Note that it is generally necessary to override the hashCode method whenever this method is overridden, so as to maintain the general contract for the hashCode method, which states that equal objects must have equal hash codes.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;官方文档提醒我们当重写equals方法的时候, 最好也要重写hashCode()方法. 也就是说如果我们通过重写equals方法判断两个对象相同时, 他们的hash code也应该相同, 这样才能让hashCode()方法发挥它的作用.&lt;/li&gt;
&lt;li&gt;那它究竟能发会怎样的作用呢? 我们结合部分较为常用的HashMap源码进一步分析. (像HashSet底层也是通过HashMap实现)&lt;/li&gt;
&lt;li&gt;在HashMap中用得最多无疑是put()方法了, 以下是put()的源码:&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public V put(K key, V value) {
    return putVal(hash(key), key, value, false, true);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;我们可以看到put()方法实际调用的是putVal()方法, 继续跟进:&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
               boolean evict) {
    Node&amp;lt;K,V&amp;gt;[] tab; Node&amp;lt;K,V&amp;gt; p; int n, i;
    //在我们创建HashMap对象的时候, 内存中并没有为HashMap分配表的空间, 直到往HashMap中put添加元素的时候才调用resize()方法初始化表
    if ((tab = table) == null || (n = tab.length) == 0)
        n = (tab = resize()).length;//同时确定了表的长度
        
    //((n - 1) &amp;amp; hash)确定了要put的元素的位置, 如果要插入的地方是空的, 就可以直接插入.
    if ((p = tab[i = (n - 1) &amp;amp; hash]) == null)
        tab[i] = newNode(hash, key, value, null);
    else {//如果发生了冲突, 就要在冲突位置的链表末尾插入元素
        Node&amp;lt;K,V&amp;gt; e; K k;
        if (p.hash == hash &amp;amp;&amp;amp;   
            ((k = p.key) == key || (key != null &amp;amp;&amp;amp; key.equals(k))))
            //关键!!!当判断新加入的元素是否与已有的元素相同, 首先判断的是hash值, 后面再调用equals()方法. 如果hash值不同是直接跳过的
            e = p;
        else if (p instanceof TreeNode)//如果冲突解决方案已经变成红黑树的话, 按红黑树的策略添加结点. 
            e = ((TreeNode&amp;lt;K,V&amp;gt;)p).putTreeVal(this, tab, hash, key, value);
        else {//解决冲突的方式仍是链表
            for (int binCount = 0; ; ++binCount) {//找到链表的末尾, 插入.
                if ((e = p.next) == null) {
                    p.next = newNode(hash, key, value, null);
                    if (binCount &amp;gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
                        treeifyBin(tab, hash);//插入之后要判断链表的长度, 如果到达一定的值就可能要转换为红黑树. 
                    break;
                }//在遍历的过程中仍会不停地判定当前key是否与传入的key相同, 判断的第一条件仍然是hash值. 
                if (e.hash == hash &amp;amp;&amp;amp;
                    ((k = e.key) == key || (key != null &amp;amp;&amp;amp; key.equals(k))))
                    break;
                p = e;
            }
        }
        if (e != null) { // existing mapping for key
            V oldValue = e.value;
            if (!onlyIfAbsent || oldValue == null)
                e.value = value;
            afterNodeAccess(e);
            return oldValue;
        }
    }
    ++modCount;//修改map的次数增加
    if (++size &amp;gt; threshold)//如果hashMap的容量到达了一定值就要进行扩容
        resize();
    afterNodeInsertion(evict);
    return null;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;我们可以看到每当判断key是否相同的是否, 首先会判断hash值, 如果hash值相同(产生了冲突), 然后会判断key引用所指的对象是否相同, 最终会通过equals()方法作最后的判定.&lt;/li&gt;
&lt;li&gt;如果key的hash值不同, 后面的判断将不会执行, 直接认定两个对象不相同.&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;if (p.hash == hash &amp;amp;&amp;amp;
    ((k = p.key) == key || (key != null &amp;amp;&amp;amp; key.equals(k))))
    e = p;&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;结束&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;讲到这里希望大家对hashCode()与equals()方法能有更深入的理解, 明白背后的设计思想与原理.&lt;/li&gt;
&lt;li&gt;我之前有一个疑问, 可能大家看完这篇文章后也会有: equals()方法平时我会用到, 所以我知道它除了和hashCode()方法有密切联系外, 还有别的用途. 但是hashCode()呢, 它除了和equals()方法有密切联系外, 还有其他用途吗?&lt;/li&gt;
&lt;li&gt;经过在互联网上一番搜寻, 我目前给出的答案是没有. 也就是说hashCode()仅在散列表中才有用，在其它情况下没用.&lt;/li&gt;
&lt;li&gt;当然如果这个答案不正确, 或者你还有别的思考, 欢迎留言与我交流~&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;
&lt;ul&gt;&lt;li&gt;最后欢迎关注我的&lt;strong&gt;免费&lt;/strong&gt;知识星球, 我会在星球中持续更新系统的Java后端面试题分析, 将会囊括Java基础知识到主流框架原理. 还会分享关于编程的趣味漫画.&lt;/li&gt;
&lt;/ul&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/tanshaoshenghao/1426602/o_%e6%98%9f%e7%90%832.png&quot;/&gt;</description>
<pubDate>Thu, 23 May 2019 14:30:00 +0000</pubDate>
<dc:creator>炭烧生蚝</dc:creator>
<og:description>[toc] 一. 基础: hashCode()和equals()简介 在学习hashCode()和equals()之间的关系之前, 我们有必要先单独了解他俩自身的特点. equals()方法用于比较两</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tanshaoshenghao/p/10915055.html</dc:identifier>
</item>
<item>
<title>RabbitMQ核心组件及应用场景 - 柠檬树开花了</title>
<link>http://www.cnblogs.com/tangquanbin/p/10914547.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tangquanbin/p/10914547.html</guid>
<description>&lt;h3 id=&quot;一适用场景&quot;&gt;一、适用场景&lt;/h3&gt;
&lt;h5 id=&quot;解耦&quot;&gt;1.解耦&lt;/h5&gt;
&lt;h5 id=&quot;最终一致性&quot;&gt;2.最终一致性&lt;/h5&gt;
&lt;h5 id=&quot;广播&quot;&gt;3.广播&lt;/h5&gt;
&lt;h5 id=&quot;错峰与流控秒杀业务用于流量削峰场景&quot;&gt;4.错峰与流控(秒杀业务用于流量削峰场景)&lt;/h5&gt;
&lt;p&gt;&lt;a href=&quot;http://youzhixueyuan.com/how-to-realize-flow-peak-cutting.html&quot;&gt;秒杀场景&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;二核心组件关键点交换器队列绑定&quot;&gt;二、核心组件，关键点(交换器、队列、绑定)&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/LighterTang/RabbitMQUtils/blob/master/pic/clipboard.png?raw=true&quot;/&gt;&lt;/p&gt;
&lt;p&gt;AMPQ消息路由必要三部分：交换器、队列、绑定。&lt;/p&gt;
&lt;p&gt;Java核心组件：ConnectionFactory、Connection、Channel、Delivery、DeliverCallback、CancelCallback&lt;/p&gt;
&lt;h4 id=&quot;队列&quot;&gt;队列&lt;/h4&gt;
&lt;h5 id=&quot;建立连接&quot;&gt;1. 建立连接&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;ConnectionFactory factory = new ConnectionFactory();
factory.setHost(&quot;127.0.0.1&quot;);
factory.setPort(5672);
factory.setUsername(&quot;admin&quot;);
factory.setPassword(&quot;admin&quot;);
Connection connection = factory.newConnection();
Channel channel = connection.createChannel();&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;声明队列&quot;&gt;2. 声明队列&lt;/h5&gt;
&lt;p&gt;如果在同一条信道上订阅了另一个队列，那就不能再声明队列，必须先取消订阅。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Queue.DeclareOk queueDeclare(String queue, boolean durable, boolean exclusive, boolean autoDelete,
                             Map&amp;lt;String, Object&amp;gt; arguments) throws IOException;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;queue:需要指定队列名称，如果不指定，MQ会随机分配一个并在queue.declare命令中返回，&lt;/p&gt;
&lt;p&gt;durable:队列将在服务器重启后存在。&lt;/p&gt;
&lt;p&gt;exclusive:为true时，队列变成私有的。&lt;/p&gt;
&lt;p&gt;autoDelete: 为true时，当最后一个消费者取消订阅时，队列自动移除。&lt;/p&gt;
&lt;h5 id=&quot;消费者通过amqp的basic.consume命令订阅消息将信道置为接收模式&quot;&gt;3. 消费者通过AMQP的basic.consume命令订阅消息，将信道置为接收模式。&lt;/h5&gt;
&lt;p&gt;Java代码Channel：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;String basicConsume(String queue, boolean autoAck, DeliverCallback deliverCallback, CancelCallback cancelCallback) throws IOException;&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;当有多个消费者存在时队列里的消息将以循环的方式发送给消费者消费者接收到消息后必须进行确认可通过basic.ack显示确认&quot;&gt;4. 当有多个消费者存在时，队列里的消息将以循环的方式发送给消费者。消费者接收到消息后必须进行确认，可通过basic.ack显示确认:&lt;/h5&gt;
&lt;p&gt;Java代码Channel：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void basicAck(long deliveryTag, boolean multiple) throws IOException;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的手动确认,第二个参数为true,批量确认;如果为false,会一次确认一条。当有耗时任务时，可以利用手动确认延迟确认消息，防止消息大量涌入应用导致过载。&lt;br/&gt;也可以在订阅队列时就将basicConsume方法的autoAck参数设置为true，开启自动确认。确认成功后rabbitmq会从队列中删除消息。&lt;/p&gt;
&lt;h5 id=&quot;如果在确认过程中和rabbitmq服务器断链那么这条消息就会发送给下一个消费者可以使用basic.reject拒绝消息&quot;&gt;5. 如果在确认过程中和rabbitmq服务器断链，那么这条消息就会发送给下一个消费者。可以使用basic.reject拒绝消息：&lt;/h5&gt;
&lt;p&gt;Java代码Channel：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void basicReject(long deliveryTag, boolean requeue) throws IOException;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第二个参数requeue设置为true,消息会重新排队并发送给下一个消费者；为false则会丢弃该条消息。可以利用此性质丢弃错误格式的消息。&lt;/p&gt;
&lt;h5 id=&quot;发布消息&quot;&gt;6. 发布消息&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;void basicPublish(String exchange, String routingKey, BasicProperties props, byte[] body) throws IOException;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;exchange:第一个参数是交换的名称。空字符串表示默认或无名交换,消息通过routingKey路由到指定队列。&lt;/p&gt;
&lt;h4 id=&quot;交换器和绑定&quot;&gt;交换器和绑定&lt;/h4&gt;

&lt;p&gt;Java中Channel申明交换器：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Exchange.DeclareOk exchangeDeclare(String exchange, BuiltinExchangeType type) throws IOException;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;BuiltinExchangeType对应有四种枚举类型：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;DIRECT(&quot;direct&quot;), FANOUT(&quot;fanout&quot;), TOPIC(&quot;topic&quot;), HEADERS(&quot;headers&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;队列通过路由键routing-key绑定到交换器&quot;&gt;2. 队列通过路由键（routing key）绑定到交换器。&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;channel.queueBind(String queue, String exchange, String routingKey)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;RabbitMQ中消息传递模型的核心思想是生产者永远不会将任何消息直接发送到队列。实际上，生产者甚至不知道消息是否会被传递到哪个队列。&lt;/p&gt;
&lt;p&gt;不指定队列名时，通过服务器随机生成队列名称：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;String queueName = channel.queueDeclare().getQueue();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不传参数时，queueDeclare生成一个非持久的，独占的自动删除队列&lt;/p&gt;
&lt;p&gt;在linux服务器上可以通过命令查看所有交换器：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;rabbitmqctl list_exchanges&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;fanout广播方式&quot;&gt;3. fanout广播方式&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/LighterTang/RabbitMQUtils/blob/master/pic/python-three-overall.png?raw=true&quot;/&gt;&lt;/p&gt;
&lt;p&gt;广播方式会将消息投递给所有附加在此交换器的队列。&lt;/p&gt;
&lt;h5 id=&quot;direct模式&quot;&gt;4. direct模式&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/LighterTang/RabbitMQUtils/blob/master/pic/python-four.png?raw=true&quot;/&gt;&lt;/p&gt;
&lt;p&gt;direct类型在绑定时设定一个routing_key,消息的routing_key匹配时, 才会被交换器投递到绑定的队列中去.&lt;/p&gt;
&lt;h5 id=&quot;topic模式&quot;&gt;5. topic模式&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/LighterTang/RabbitMQUtils/blob/master/pic/python-five.png?raw=true&quot;/&gt;&lt;/p&gt;
&lt;p&gt;按规则投递，通过通配符#和*组合&lt;/p&gt;
&lt;p&gt;*（星号）可以替代一个单词。&lt;/p&gt;
&lt;p&gt;#（hash）可以替换零个或多个单词。&lt;/p&gt;
&lt;h4 id=&quot;持久化&quot;&gt;持久化&lt;/h4&gt;
&lt;p&gt;将队列和交换器的durable属性设置为true&lt;/p&gt;
&lt;p&gt;申明队列时：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;channel.queueDeclare(String queue, boolean durable, boolean exclusive, boolean autoDelete,
                             Map&amp;lt;String, Object&amp;gt; arguments) throws IOException;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;申明交换器时:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;channel.exchangeDeclare(String exchange, BuiltinExchangeType type, boolean durable) throws IOException;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;投递消息时将投递模式（delivery mode）设置为2，Java代码中MessageProperties.PERSISTENT_TEXT_PLAIN来设置：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;channel.basicPublish(EXCHANGE_NAME, routingKey, MessageProperties.PERSISTENT_TEXT_PLAIN, message.getBytes(&quot;UTF-8&quot;));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在MessageProperties源码中如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/** Content-type &quot;text/plain&quot;, deliveryMode 2 (persistent), priority zero */
public static final BasicProperties PERSISTENT_TEXT_PLAIN =
    new BasicProperties(&quot;text/plain&quot;,
                        null,
                        null,
                        2,
                        0, null, null, null,
                        null, null, null, null,
                        null, null);&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;实现事务功能发送方确认&quot;&gt;实现事务功能（发送方确认）&lt;/h4&gt;
&lt;p&gt;使用事务会使rabbitmq的性能大大降低，为了避免这个问题，rabbitmq支持：发送方确认模式。通过这个模式来保证消息的投递。当生产者P投递消息后会等待消费者C发送确认，P收到确认后可以调用回调函数处理相关业务。在生产者P等待确认的同时也可以继续发送下一条消息。&lt;/p&gt;
&lt;h4 id=&quot;服务器管理&quot;&gt;服务器管理&lt;/h4&gt;
&lt;h5 id=&quot;虚拟主机vhost&quot;&gt;1、虚拟主机vhost&lt;/h5&gt;
&lt;p&gt;rabbitmq支持创建虚拟主机，默认的虚拟主机为“/”,默认用户guest；当在rabbitmq集群中创建虚拟主机时，整个集群都会创建。&lt;/p&gt;
&lt;h5 id=&quot;错误日志查看&quot;&gt;2、错误日志查看&lt;/h5&gt;
&lt;p&gt;rabbitmq的日志文件在/var/log/rabbitmq/下的rabbit@[localhost].log&lt;/p&gt;
&lt;h5 id=&quot;rabbitmq配置文件&quot;&gt;3、rabbitmq配置文件&lt;/h5&gt;
&lt;p&gt;配置文件在rpm安装/usr/share/doc/rabbitmq-server-3.6.5/rabbitmq.config.example，复制一份：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cp /usr/share/doc/rabbitmq-server-3.5.3/rabbitmq.config.example /etc/rabbitmq.config&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参考官网配置：https://www.rabbitmq.com/configure.html#configuration-file&lt;/p&gt;
&lt;h3 id=&quot;三底层原理主要实现&quot;&gt;三、底层原理，主要实现&lt;/h3&gt;
&lt;p&gt;应用程序和rabbitmq服务器之间建立一条tcp连接，tcp连接打开后，应用程序就可以和rabbitmq创建多条AMQP信道，信道是建立在tcp连接上的虚拟连接。&lt;/p&gt;
&lt;h3 id=&quot;四同类技术产品比较&quot;&gt;四、同类技术产品比较&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/LighterTang/RabbitMQUtils/blob/master/pic/22e54b26a6f341edac5a7a1e8d2a2b8c.jpg?raw=true&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;activemq&quot;&gt;1.ActiveMQ&lt;/h5&gt;
&lt;p&gt;优点&lt;/p&gt;
&lt;p&gt;单机吞吐量：万级&lt;br/&gt;topic数量都吞吐量的影响：&lt;br/&gt;时效性：ms级&lt;br/&gt;可用性：高，基于主从架构实现高可用性&lt;br/&gt;消息可靠性：有较低的概率丢失数据&lt;br/&gt;功能支持：MQ领域的功能极其完备&lt;br/&gt;缺点:&lt;/p&gt;
&lt;p&gt;官方社区现在对ActiveMQ 5.x维护越来越少，较少在大规模吞吐的场景中使用。&lt;/p&gt;
&lt;h5 id=&quot;kafka&quot;&gt;2.Kafka&lt;/h5&gt;
&lt;p&gt;号称大数据的杀手锏，谈到大数据领域内的消息传输，则绕不开Kafka，这款为大数据而生的消息中间件，以其百万级TPS的吞吐量名声大噪，迅速成为大数据领域的宠儿，在数据采集、传输、存储的过程中发挥着举足轻重的作用。&lt;/p&gt;
&lt;p&gt;Apache Kafka它最初由LinkedIn公司基于独特的设计实现为一个分布式的提交日志系统( a distributed commit log)，之后成为Apache项目的一部分。&lt;/p&gt;
&lt;p&gt;目前已经被LinkedIn，Uber, Twitter, Netflix等大公司所采纳。&lt;/p&gt;
&lt;p&gt;优点&lt;/p&gt;
&lt;p&gt;性能卓越，单机写入TPS约在百万条/秒，最大的优点，就是吞吐量高。&lt;br/&gt;时效性：ms级&lt;br/&gt;可用性：非常高，kafka是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用&lt;br/&gt;消费者采用Pull方式获取消息, 消息有序, 通过控制能够保证所有消息被消费且仅被消费一次;&lt;br/&gt;有优秀的第三方Kafka Web管理界面Kafka-Manager；&lt;br/&gt;在日志领域比较成熟，被多家公司和多个开源项目使用；&lt;br/&gt;功能支持：功能较为简单，主要支持简单的MQ功能，在大数据领域的实时计算以及日志采集被大规模使用&lt;br/&gt;缺点：&lt;/p&gt;
&lt;p&gt;Kafka单机超过64个队列/分区，Load会发生明显的飙高现象，队列越多，load越高，发送消息响应时间变长&lt;br/&gt;使用短轮询方式，实时性取决于轮询间隔时间；&lt;br/&gt;消费失败不支持重试；&lt;br/&gt;支持消息顺序，但是一台代理宕机后，就会产生消息乱序；&lt;br/&gt;社区更新较慢；&lt;/p&gt;
&lt;h5 id=&quot;rabbitmq&quot;&gt;3.RabbitMQ&lt;/h5&gt;
&lt;p&gt;RabbitMQ 2007年发布，是一个在AMQP(高级消息队列协议)基础上完成的，可复用的企业消息系统，是当前最主流的消息中间件之一。&lt;/p&gt;
&lt;p&gt;RabbitMQ优点：&lt;/p&gt;
&lt;p&gt;由于erlang语言的特性，mq 性能较好，高并发；&lt;br/&gt;吞吐量到万级，MQ功能比较完备&lt;br/&gt;健壮、稳定、易用、跨平台、支持多种语言、文档齐全；&lt;br/&gt;开源提供的管理界面非常棒，用起来很好用&lt;br/&gt;社区活跃度高；&lt;br/&gt;RabbitMQ缺点：&lt;/p&gt;
&lt;p&gt;erlang开发，很难去看懂源码，基本职能依赖于开源社区的快速维护和修复bug，不利于做二次开发和维护。&lt;br/&gt;RabbitMQ确实吞吐量会低一些，这是因为他做的实现机制比较重。&lt;br/&gt;需要学习比较复杂的接口和协议，学习和维护成本较高。&lt;/p&gt;
&lt;h5 id=&quot;rocketmq&quot;&gt;4.RocketMQ&lt;/h5&gt;
&lt;p&gt;RocketMQ出自 阿里公司的开源产品，用 Java 语言实现，在设计时参考了 Kafka，并做出了自己的一些改进。&lt;/p&gt;
&lt;p&gt;RocketMQ在阿里集团被广泛应用在订单，交易，充值，流计算，消息推送，日志流式处理，binglog分发等场景。&lt;/p&gt;
&lt;p&gt;RocketMQ优点：&lt;/p&gt;
&lt;p&gt;单机吞吐量：十万级&lt;br/&gt;可用性：非常高，分布式架构&lt;br/&gt;消息可靠性：经过参数优化配置，消息可以做到0丢失&lt;br/&gt;功能支持：MQ功能较为完善，还是分布式的，扩展性好&lt;br/&gt;支持10亿级别的消息堆积，不会因为堆积导致性能下降&lt;br/&gt;源码是java，我们可以自己阅读源码，定制自己公司的MQ，可以掌控&lt;br/&gt;RocketMQ缺点：&lt;/p&gt;
&lt;p&gt;支持的客户端语言不多，目前是java及c++，其中c++不成熟；&lt;br/&gt;社区活跃度一般&lt;br/&gt;没有在 mq 核心中去实现JMS等接口，有些系统要迁移需要修改大量代码&lt;/p&gt;
&lt;h5 id=&quot;github代码&quot;&gt;github代码&lt;/h5&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/LighterTang/RabbitMQUtils/tree/master/rabbitmq_base/src/main/java/com/mq/mqutils/mqdoc&quot; class=&quot;uri&quot;&gt;https://github.com/LighterTang/RabbitMQUtils/tree/master/rabbitmq_base/src/main/java/com/mq/mqutils/mqdoc&lt;/a&gt;&lt;/p&gt;
&lt;h5 id=&quot;参考资料&quot;&gt;参考资料&lt;/h5&gt;
&lt;p&gt;&lt;a href=&quot;https://www.rabbitmq.com&quot; class=&quot;uri&quot;&gt;https://www.rabbitmq.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://youzhixueyuan.com/comparison-of-kafka-rocketmq-rabbitmq.html&quot; class=&quot;uri&quot;&gt;http://youzhixueyuan.com/comparison-of-kafka-rocketmq-rabbitmq.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 23 May 2019 13:13:00 +0000</pubDate>
<dc:creator>柠檬树开花了</dc:creator>
<og:description>一、适用场景 1.解耦 2.最终一致性 3.广播 4.错峰与流控(秒杀业务用于流量削峰场景) '秒杀场景' 二、核心组件，关键点(交换器、队列、绑定) AMPQ消息路由必要三部分：交换器、队列、绑定。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tangquanbin/p/10914547.html</dc:identifier>
</item>
<item>
<title>数字IC设计入门必备——VIM自定义模板调用与VCS基本仿真操作示例 - 没落骑士</title>
<link>http://www.cnblogs.com/moluoqishi/p/10913990.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/moluoqishi/p/10913990.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、前言&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;毕业论文答辩结束，闲下来写篇文章。芯片研发人员都在Linux系统下借助各种EDA工具和代码语言完成工作，因此提高代码开发效率，熟练运用开发工具是十分必要的。本文讲述VIM编辑神器的verilogHDL自定义模板调用以及VCS仿真软件的基本使用方式。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、VIM编辑器自定义模板调用&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在之前的博文中谈到过GVIM编辑器中可以通过调用模板来生成重复性代码，但没有介绍自定义模板的方式。关于VIM的安装与配置详细内容，见参考文献1。这里主要用到VIM的用户配置文件：.vimrc（若没有新建该文件并编辑），我们在用户目录下使用ls -al命令可以看到该文件：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201289/201905/1201289-20190523192843972-904361690.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;使用VIM编辑器打开VIM配置文件，以下部分是在文件底部自行添加的命令：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201289/201905/1201289-20190523193008083-1013926506.png&quot; alt=&quot;&quot; width=&quot;1505&quot; height=&quot;144&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　&lt;span&gt;　自定义模板的格式为    :ab &amp;lt;com&amp;gt; &amp;lt;code&amp;gt;   &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　其中com是调用指令，code是当前指令生成的代码。我们新建一个.v文件测试下就能看出模板调用的妙处了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;编辑（插入）模式下，输入Shixu后按下回车生成：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201289/201905/1201289-20190523195151459-2121951420.png&quot; alt=&quot;&quot; width=&quot;392&quot; height=&quot;172&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;输入Zuhe后按下回车生成：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201289/201905/1201289-20190523195219247-1641671574.png&quot; alt=&quot;&quot; width=&quot;179&quot; height=&quot;75&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;输入Counter后按下回车生成：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201289/201905/1201289-20190523195321599-1450401373.png&quot; alt=&quot;&quot; width=&quot;379&quot; height=&quot;262&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;这三个是最常用到的代码，三者相互组合可以完成很多功能了。但若状态或工作模式较多，一般采用状态机完成。输入FSM后按下回车生成：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201289/201905/1201289-20190523195536579-1928955329.png&quot; alt=&quot;&quot; width=&quot;368&quot; height=&quot;201&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;在设计时，经常要根据数值范围设定变量的位宽。此时经常用到一个位宽计算到函数。输入Width_func后按下回车生成：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201289/201905/1201289-20190523195815838-1015698284.png&quot; alt=&quot;&quot; width=&quot;444&quot; height=&quot;118&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;在设计文件里常用的重复性代码基本就这些了，可以根据自己的coding style灵活调整。接下来说说testbench部分。输入Test后按下回车生成：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201289/201905/1201289-20190523200018461-605488021.png&quot; alt=&quot;&quot; width=&quot;210&quot; height=&quot;195&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;里边包括了testbench中的时钟和复位相关的参数与信号定义。实际上时钟和复位信号的产生也是可以复用的。输入Clock_rst后按下回车生成：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201289/201905/1201289-20190523200156320-402567975.png&quot; alt=&quot;&quot; width=&quot;165&quot; height=&quot;283&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　通过使用上班&lt;span&gt;自定义模板还没有灵活到可以自动生成例化模板，这一部分功能得借助其他脚本语言完成了，笔者还没有尝试过。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、VCS软件仿真&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　光说这个软件没什么意思，我们来举个栗子~设计一个计数器，输出位宽固定32位。当使能信号拉高则开始从0计数直到最大值后再次从0开始递增。设计代码counter.v：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201289/201905/1201289-20190523200814499-514331167.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;测试代码 counter_tb.v：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201289/201905/1201289-20190523200925116-2004735179.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;VCS仿真大体分为三步：编译、仿真以及调试。编译命令：vcs *.v -debug_all 命令行界面会显示些信息：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201289/201905/1201289-20190523201144712-1348675820.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;之后文件夹内会生成simv文件，执行该文件进行仿真。./simv -gui   这里使用-gui选项打开DVE图形界面。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201289/201905/1201289-20190523201414118-1101414094.png&quot; alt=&quot;&quot; width=&quot;1421&quot; height=&quot;867&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;接下来的操作和常用的Modelsim差不多了。把要观测的信号添加到波形窗口：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201289/201905/1201289-20190523201511943-1571473219.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;点击左上角按钮运行仿真：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201289/201905/1201289-20190523201619370-1999119788.png&quot; alt=&quot;&quot; width=&quot;1406&quot; height=&quot;745&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;按下红色箭头所指位置观察全局波形：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201289/201905/1201289-20190523201758921-768318685.png&quot; alt=&quot;&quot; width=&quot;1356&quot; height=&quot;348&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;按住鼠标左键拖动来局部放大数据波形，计数器与输出从0到19周期性递增，功能正确。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201289/201905/1201289-20190523202016529-792871484.png&quot; alt=&quot;&quot; width=&quot;1399&quot; height=&quot;184&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　&lt;span&gt;　复杂的操作后续用到再学。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;参考文献&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1 vim 的安装及配置 - QIYUEXIN - 博客园 https://www.cnblogs.com/qiyuexin/p/6398606.html&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;2 &lt;/em&gt;VCS使用学习 - IC_SOC_ARM - CSDN博客 https://blog.csdn.net/ic_soc_arm_robin/article/details/44262063&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;em&gt;3 &lt;/em&gt;&lt;/em&gt;VCS-DVE - 百度文库 &lt;em id=&quot;__mceDel&quot;&gt;https://wenku.baidu.com/view/f5f7ce8f69eae009591becc1.html&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;em&gt;4 &lt;/em&gt;&lt;/em&gt;&lt;em id=&quot;__mceDel&quot;&gt;数字芯片实验室的个人空间 - 哔哩哔哩 ( ゜- ゜)つロ 乾杯~ Bilibili &lt;/em&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;https://space.bilibili.com/87907395/channel/detail?cid=64692&lt;/em&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 23 May 2019 12:26:00 +0000</pubDate>
<dc:creator>没落骑士</dc:creator>
<og:description>一、前言 毕业论文答辩结束，闲下来写篇文章。芯片研发人员都在Linux系统下借助各种EDA工具和代码语言完成工作，因此提高代码开发效率，熟练运用开发工具是十分必要的。本文讲述VIM编辑神器的veril</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/moluoqishi/p/10913990.html</dc:identifier>
</item>
<item>
<title>Spring Boot 2 快速教程：WebFlux 集成 Mongodb（四） - www.bysocket.com</title>
<link>http://www.cnblogs.com/Alandre/p/10914240.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Alandre/p/10914240.html</guid>
<description>&lt;p&gt;摘要: 原创出处 https://www.bysocket.com 「公众号：泥瓦匠BYSocket 」欢迎关注和转载，保留摘要，谢谢！&lt;/p&gt;
&lt;p&gt;这是泥瓦匠的第104篇原创&lt;/p&gt;
&lt;p&gt;文章工程：&lt;br/&gt;* JDK 1.8&lt;br/&gt;* Maven 3.5.2&lt;br/&gt;* Spring Boot 2.1.3.RELEASE&lt;br/&gt;* 工程名：springboot-webflux-4-thymeleaf&lt;br/&gt;* 工程地址：见文末&lt;/p&gt;
&lt;h2&gt;一、前言&lt;/h2&gt;
&lt;p&gt;上一讲用 Map 数据结构内存式存储了数据。这样数据就不会持久化，本文我们用 MongoDB 来实现 WebFlux 对数据源的操作。&lt;/p&gt;
&lt;p&gt;什么是 MongoDB ?&lt;/p&gt;
&lt;p&gt;官网：https://www.mongodb.com/&lt;/p&gt;
&lt;p&gt;MongoDB 是一个基于分布式文件存储的数据库，由 C++ 语言编写，旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。&lt;/p&gt;
&lt;p&gt;MongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。&lt;/p&gt;
&lt;p&gt;由于操作方便，本文用 Docker 启动一个 MognoDB 服务。如果 Docker 不会安装的，请参考此文：Docker 安装与基本操作 https://www.jianshu.com/p/f272726db9c5&lt;/p&gt;
&lt;p&gt;Docker 安装 MognoDB 并启动如下：&lt;/p&gt;
&lt;p&gt;1、创建挂载目录&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs sql&quot;&gt;docker volume &lt;span class=&quot;hljs-keyword&quot;&gt;create mongo_data_db
docker volume &lt;span class=&quot;hljs-keyword&quot;&gt;create mongo_data_configdb
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2、启动 MognoDB&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs nginx&quot;&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;docker run -d \
    --name mongo \
    -v mongo_data_configdb:/data/configdb \
    -v mongo_data_db:/data/db \
    -p &lt;span class=&quot;hljs-number&quot;&gt;27017:&lt;span class=&quot;hljs-number&quot;&gt;27017 \
    mongo \
    --auth
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3、初始化管理员账号&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot;&gt;docker &lt;span class=&quot;hljs-built_in&quot;&gt;exec -it mongo     mongo              admin
                        // 容器名   // mongo命令 数据库名

&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;4、测试连通性&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs perl&quot;&gt;docker run -it --rm --&lt;span class=&quot;hljs-keyword&quot;&gt;link mongo:mongo mongo mongo -u admin -p admin --authenticationDatabase admin mongo/admin
&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;MognoDB 基本操作：&lt;/p&gt;
&lt;p&gt;类似 MySQL 命令，显示库列表：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs nginx&quot;&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;show dbs
&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用某数据库&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs sql&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;use &lt;span class=&quot;hljs-keyword&quot;&gt;admin
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;显示表列表&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs nginx&quot;&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;show collections
&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果存在 city 表，格式化显示 city 表内容&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs css&quot;&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;db&lt;span class=&quot;hljs-selector-class&quot;&gt;.city&lt;span class=&quot;hljs-selector-class&quot;&gt;.find()&lt;span class=&quot;hljs-selector-class&quot;&gt;.pretty()
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;二、结构&lt;/h2&gt;
&lt;p&gt;类似上面讲的工程搭建，新建一个工程编写此案例。工程如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://springforall.ufile.ucloud.com.cn/static/img/02b199c85e5548663557753d48f4b95c1523803&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt;目录核心如下&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;pom.xml maven 配置&lt;/li&gt;
&lt;li&gt;application.properties 配置文件&lt;/li&gt;
&lt;li&gt;dao 数据访问层，本文要点&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;三、新增 POM 依赖与配置&lt;/h2&gt;
&lt;p&gt;在 pom.xml 配置新的依赖：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java hljs&quot;&gt;    &amp;lt;!-- Spring Boot 响应式 MongoDB 依赖 --&amp;gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;spring-boot-starter-data-mongodb-reactive&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;类似配了 MySQL 和 JDBC 驱动，肯定得去配置数据库。在 application.properties 配置下上面启动的 MongoDB 配置：&lt;/p&gt;
&lt;p&gt;数据库名为 admin、账号密码也为 admin。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs&quot;&gt;spring.data.mongodb.host=localhost
spring.data.mongodb.database=admin
spring.data.mongodb.port=27017
spring.data.mongodb.username=admin
spring.data.mongodb.password=admin
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这就一个巨大的问题了，为啥不用我们常用的 MySQL 数据库呢？&lt;/p&gt;
&lt;p&gt;答案是 Spring Data Reactive Repositories 目前支持 Mongo、Cassandra、Redis、Couchbase。不支持 MySQL ，那究竟为啥呢？那就说明下 JDBC 和 Spring Data 的关系。&lt;/p&gt;
&lt;p&gt;Spring Data Reactive Repositories 突出点是 Reactive，即非阻塞的。区别如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;基于 JDBC 实现的 Spring Data ，比如 Spring Data JPA 是阻塞的。原理是基于阻塞 IO 模型&lt;br/&gt;消耗每个调用数据库的线程（Connection）&lt;/li&gt;
&lt;li&gt;事务只能在一个 java.sql.Connection 使用，即一个事务一个操作。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;那如何异步非阻塞封装下 JDBC 的思想也不新鲜，Scala 库 Slick 3 就实现了。简单的实现原理如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一个事务多个操作，那么共享一个 java.sql.Connection 。可以使用透明事务管理，利用回调编程模型去传递&lt;/li&gt;
&lt;li&gt;保持有限的空闲连接&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;最后，我坚信非阻塞 JDBC 很快就会出现的。这样我们就开心的调用 MySQL 了。&lt;/p&gt;
&lt;h2&gt;四、对象&lt;/h2&gt;
&lt;p&gt;修改 org.spring.springboot.domain 包里面的城市实体对象类。修改城市（City）对象 City，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import org.springframework.data.annotation.Id;

&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;@Id 注解标记对应库表的主键或者唯一标识符。因为这个是我们的 DO ，数据访问对象一一映射到数据存储。&lt;/p&gt;
&lt;h2&gt;五、MongoDB 数据访问层 CityRepository&lt;/h2&gt;
&lt;p&gt;修改 CityRepository 类，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import org.spring.springboot.domain.City;
&lt;span class=&quot;hljs-keyword&quot;&gt;import org.springframework.data.mongodb.repository.ReactiveMongoRepository;
&lt;span class=&quot;hljs-keyword&quot;&gt;import org.springframework.stereotype.Repository;

&lt;span class=&quot;hljs-meta&quot;&gt;@Repository
&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;interface &lt;span class=&quot;hljs-title&quot;&gt;CityRepository &lt;span class=&quot;hljs-keyword&quot;&gt;extends &lt;span class=&quot;hljs-title&quot;&gt;ReactiveMongoRepository&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;City, &lt;span class=&quot;hljs-title&quot;&gt;Long&amp;gt; {

}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;CityRepository 接口只要继承 ReactiveMongoRepository 类即可。默认会提供很多实现，比如 CRUD 和列表查询参数相关的实现。ReactiveMongoRepository 接口默认实现了如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java hljs&quot;&gt;    &amp;lt;S extends T&amp;gt; &lt;span class=&quot;hljs-function&quot;&gt;Mono&amp;lt;S&amp;gt; &lt;span class=&quot;hljs-title&quot;&gt;insert&lt;span class=&quot;hljs-params&quot;&gt;(S var1);

    &amp;lt;S extends T&amp;gt; &lt;span class=&quot;hljs-function&quot;&gt;Flux&amp;lt;S&amp;gt; &lt;span class=&quot;hljs-title&quot;&gt;insert&lt;span class=&quot;hljs-params&quot;&gt;(Iterable&amp;lt;S&amp;gt; var1);

    &amp;lt;S extends T&amp;gt; &lt;span class=&quot;hljs-function&quot;&gt;Flux&amp;lt;S&amp;gt; &lt;span class=&quot;hljs-title&quot;&gt;insert&lt;span class=&quot;hljs-params&quot;&gt;(Publisher&amp;lt;S&amp;gt; var1);

    &amp;lt;S extends T&amp;gt; &lt;span class=&quot;hljs-function&quot;&gt;Flux&amp;lt;S&amp;gt; &lt;span class=&quot;hljs-title&quot;&gt;findAll&lt;span class=&quot;hljs-params&quot;&gt;(Example&amp;lt;S&amp;gt; var1);

    &amp;lt;S extends T&amp;gt; &lt;span class=&quot;hljs-function&quot;&gt;Flux&amp;lt;S&amp;gt; &lt;span class=&quot;hljs-title&quot;&gt;findAll&lt;span class=&quot;hljs-params&quot;&gt;(Example&amp;lt;S&amp;gt; var1, Sort var2);
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如图，ReactiveMongoRepository 的集成类 ReactiveSortingRepository、ReactiveCrudRepository 实现了很多常用的接口：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://springforall.ufile.ucloud.com.cn/static/img/40689f2921c9e1289a03e12acef6b80e1523882&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt;ReactiveCrudRepository 接口如图所示：&lt;br/&gt;&lt;img src=&quot;http://springforall.ufile.ucloud.com.cn/static/img/428841a694e29b128fa99d93bc9fcb391523882&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt;另外可以看出，接口的命名是遵循规范的。常用命名规则如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;关键字 ：： 方法命名&lt;/li&gt;
&lt;li&gt;And ：： findByNameAndPwd&lt;/li&gt;
&lt;li&gt;Or ：： findByNameOrSex&lt;/li&gt;
&lt;li&gt;Is ：： findById&lt;/li&gt;
&lt;li&gt;Between ：： findByIdBetween&lt;/li&gt;
&lt;li&gt;Like ：： findByNameLike&lt;/li&gt;
&lt;li&gt;NotLike ：： findByNameNotLike&lt;/li&gt;
&lt;li&gt;OrderBy ：： findByIdOrderByXDesc&lt;/li&gt;
&lt;li&gt;Not ：： findByNameNot&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;常用案例，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java hljs&quot;&gt;    &lt;span class=&quot;hljs-function&quot;&gt;Flux&amp;lt;Person&amp;gt; &lt;span class=&quot;hljs-title&quot;&gt;findByLastname&lt;span class=&quot;hljs-params&quot;&gt;(String lastname);

    &lt;span class=&quot;hljs-meta&quot;&gt;@Query(&lt;span class=&quot;hljs-string&quot;&gt;&quot;{ 'firstname': ?0, 'lastname': ?1}&quot;)
    &lt;span class=&quot;hljs-function&quot;&gt;Mono&amp;lt;Person&amp;gt; &lt;span class=&quot;hljs-title&quot;&gt;findByFirstnameAndLastname&lt;span class=&quot;hljs-params&quot;&gt;(String firstname, String lastname);

    &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4&gt;5.1 源码层面&lt;/h4&gt;
&lt;p&gt;ReactiveCrudRepository 抽象在 reactive 包，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://springforall.ufile.ucloud.com.cn/static/img/ab17d9ea07db0b4fc9b5d310655b98f51523883&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里我们可以看出，支持了 reactive 还支持了 RxJava。对应老的 CrudRepository 新增了 ReactiveCrudRepository 接口及各种存储实现。&lt;/p&gt;
&lt;h2&gt;六、处理器类 Handler 和控制器类 Controller&lt;/h2&gt;
&lt;p&gt;修改下 Handler ，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java hljs&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Component
&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;CityHandler {

    &lt;span class=&quot;hljs-keyword&quot;&gt;private &lt;span class=&quot;hljs-keyword&quot;&gt;final CityRepository cityRepository;

    &lt;span class=&quot;hljs-meta&quot;&gt;@Autowired
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-title&quot;&gt;CityHandler&lt;span class=&quot;hljs-params&quot;&gt;(CityRepository cityRepository) {
        &lt;span class=&quot;hljs-keyword&quot;&gt;this.cityRepository = cityRepository;
    }

    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public Mono&amp;lt;City&amp;gt; &lt;span class=&quot;hljs-title&quot;&gt;save&lt;span class=&quot;hljs-params&quot;&gt;(City city) {
        &lt;span class=&quot;hljs-keyword&quot;&gt;return cityRepository.save(city);
    }

    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public Mono&amp;lt;City&amp;gt; &lt;span class=&quot;hljs-title&quot;&gt;findCityById&lt;span class=&quot;hljs-params&quot;&gt;(Long id) {

        &lt;span class=&quot;hljs-keyword&quot;&gt;return cityRepository.findById(id);
    }

    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public Flux&amp;lt;City&amp;gt; &lt;span class=&quot;hljs-title&quot;&gt;findAllCity&lt;span class=&quot;hljs-params&quot;&gt;() {

        &lt;span class=&quot;hljs-keyword&quot;&gt;return cityRepository.findAll();
    }

    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public Mono&amp;lt;City&amp;gt; &lt;span class=&quot;hljs-title&quot;&gt;modifyCity&lt;span class=&quot;hljs-params&quot;&gt;(City city) {

        &lt;span class=&quot;hljs-keyword&quot;&gt;return cityRepository.save(city);
    }

    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public Mono&amp;lt;Long&amp;gt; &lt;span class=&quot;hljs-title&quot;&gt;deleteCity&lt;span class=&quot;hljs-params&quot;&gt;(Long id) {
        cityRepository.deleteById(id);
        &lt;span class=&quot;hljs-keyword&quot;&gt;return Mono.create(cityMonoSink -&amp;gt; cityMonoSink.success(id));
    }
}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不要对 Mono 、Flux 陌生，把他当成对象即可。继续修改下控制器类 Controller ，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java hljs&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@RestController
&lt;span class=&quot;hljs-meta&quot;&gt;@RequestMapping(value = &lt;span class=&quot;hljs-string&quot;&gt;&quot;/city&quot;)
&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;CityWebFluxController {

    &lt;span class=&quot;hljs-meta&quot;&gt;@Autowired
    &lt;span class=&quot;hljs-keyword&quot;&gt;private CityHandler cityHandler;

    &lt;span class=&quot;hljs-meta&quot;&gt;@GetMapping(value = &lt;span class=&quot;hljs-string&quot;&gt;&quot;/{id}&quot;)
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public Mono&amp;lt;City&amp;gt; &lt;span class=&quot;hljs-title&quot;&gt;findCityById&lt;span class=&quot;hljs-params&quot;&gt;(@PathVariable(&lt;span class=&quot;hljs-string&quot;&gt;&quot;id&quot;) Long id) {
        &lt;span class=&quot;hljs-keyword&quot;&gt;return cityHandler.findCityById(id);
    }

    &lt;span class=&quot;hljs-meta&quot;&gt;@GetMapping()
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public Flux&amp;lt;City&amp;gt; &lt;span class=&quot;hljs-title&quot;&gt;findAllCity&lt;span class=&quot;hljs-params&quot;&gt;() {
        &lt;span class=&quot;hljs-keyword&quot;&gt;return cityHandler.findAllCity();
    }

    &lt;span class=&quot;hljs-meta&quot;&gt;@PostMapping()
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public Mono&amp;lt;City&amp;gt; &lt;span class=&quot;hljs-title&quot;&gt;saveCity&lt;span class=&quot;hljs-params&quot;&gt;(@RequestBody City city) {
        &lt;span class=&quot;hljs-keyword&quot;&gt;return cityHandler.save(city);
    }

    &lt;span class=&quot;hljs-meta&quot;&gt;@PutMapping()
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public Mono&amp;lt;City&amp;gt; &lt;span class=&quot;hljs-title&quot;&gt;modifyCity&lt;span class=&quot;hljs-params&quot;&gt;(@RequestBody City city) {
        &lt;span class=&quot;hljs-keyword&quot;&gt;return cityHandler.modifyCity(city);
    }

    &lt;span class=&quot;hljs-meta&quot;&gt;@DeleteMapping(value = &lt;span class=&quot;hljs-string&quot;&gt;&quot;/{id}&quot;)
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public Mono&amp;lt;Long&amp;gt; &lt;span class=&quot;hljs-title&quot;&gt;deleteCity&lt;span class=&quot;hljs-params&quot;&gt;(@PathVariable(&lt;span class=&quot;hljs-string&quot;&gt;&quot;id&quot;) Long id) {
        &lt;span class=&quot;hljs-keyword&quot;&gt;return cityHandler.deleteCity(id);
    }
}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;七、运行工程&lt;/h2&gt;
&lt;p&gt;一个 CRUD 的 Spring Boot Webflux 工程就开发完毕了，下面运行工程验证下。使用 IDEA 右侧工具栏，点击 Maven Project Tab ，点击使用下 Maven 插件的 &lt;code&gt;install&lt;/code&gt; 命令。或者使用命令行的形式，在工程根目录下，执行 Maven 清理和安装工程的指令：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java hljs&quot;&gt;cd springboot-webflux-&lt;span class=&quot;hljs-number&quot;&gt;3-mongodb
mvn clean install
&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在控制台中看到成功的输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java hljs&quot;&gt;... 省略
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time: &lt;span class=&quot;hljs-number&quot;&gt;01:&lt;span class=&quot;hljs-number&quot;&gt;30 min
[INFO] Finished at: &lt;span class=&quot;hljs-number&quot;&gt;2017-&lt;span class=&quot;hljs-number&quot;&gt;10-&lt;span class=&quot;hljs-number&quot;&gt;15T10:&lt;span class=&quot;hljs-number&quot;&gt;00:&lt;span class=&quot;hljs-number&quot;&gt;54+&lt;span class=&quot;hljs-number&quot;&gt;08:&lt;span class=&quot;hljs-number&quot;&gt;00
[INFO] Final Memory: &lt;span class=&quot;hljs-number&quot;&gt;31M/&lt;span class=&quot;hljs-number&quot;&gt;174M
[INFO] ------------------------------------------------------------------------
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 IDEA 中执行 &lt;code&gt;Application&lt;/code&gt; 类启动，任意正常模式或者 Debug 模式。可以在控制台看到成功运行的输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java hljs&quot;&gt;... 省略
&lt;span class=&quot;hljs-number&quot;&gt;2018-&lt;span class=&quot;hljs-number&quot;&gt;04-&lt;span class=&quot;hljs-number&quot;&gt;10 &lt;span class=&quot;hljs-number&quot;&gt;08:&lt;span class=&quot;hljs-number&quot;&gt;43:&lt;span class=&quot;hljs-number&quot;&gt;39.932  INFO &lt;span class=&quot;hljs-number&quot;&gt;2052 --- [ctor-http-nio-&lt;span class=&quot;hljs-number&quot;&gt;1] r.ipc.netty.tcp.BlockingNettyContext     : Started HttpServer on /&lt;span class=&quot;hljs-number&quot;&gt;0:&lt;span class=&quot;hljs-number&quot;&gt;0:&lt;span class=&quot;hljs-number&quot;&gt;0:&lt;span class=&quot;hljs-number&quot;&gt;0:&lt;span class=&quot;hljs-number&quot;&gt;0:&lt;span class=&quot;hljs-number&quot;&gt;0:&lt;span class=&quot;hljs-number&quot;&gt;0:&lt;span class=&quot;hljs-number&quot;&gt;0:&lt;span class=&quot;hljs-number&quot;&gt;8080
&lt;span class=&quot;hljs-number&quot;&gt;2018-&lt;span class=&quot;hljs-number&quot;&gt;04-&lt;span class=&quot;hljs-number&quot;&gt;10 &lt;span class=&quot;hljs-number&quot;&gt;08:&lt;span class=&quot;hljs-number&quot;&gt;43:&lt;span class=&quot;hljs-number&quot;&gt;39.935  INFO &lt;span class=&quot;hljs-number&quot;&gt;2052 --- [           main] o.s.b.web.embedded.netty.NettyWebServer  : &lt;span class=&quot;hljs-function&quot;&gt;Netty started on &lt;span class=&quot;hljs-title&quot;&gt;port&lt;span class=&quot;hljs-params&quot;&gt;(s): 8080
2018-04-10 08:43:39.960  INFO 2052 --- [           main] org.spring.springboot.Application        : Started Application in 6.547 &lt;span class=&quot;hljs-title&quot;&gt;seconds &lt;span class=&quot;hljs-params&quot;&gt;(JVM running &lt;span class=&quot;hljs-keyword&quot;&gt;for &lt;span class=&quot;hljs-number&quot;&gt;9.851)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;打开 POST MAN 工具，开发必备。进行下面操作：&lt;/p&gt;
&lt;p&gt;新增城市信息 POST http://127.0.0.1:8080/city&lt;br/&gt;&lt;img src=&quot;http://springforall.ufile.ucloud.com.cn/static/img/f69fa5b09730de686ef4837824da48e71523883&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;7.1 连接 MongoDB , 验证数据&lt;/h3&gt;
&lt;p&gt;连接 MongoDB&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs perl&quot;&gt;docker run -it --rm --&lt;span class=&quot;hljs-keyword&quot;&gt;link mongo:mongo mongo mongo -u admin -p admin --authenticationDatabase admin mongo/admin
&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://springforall.ufile.ucloud.com.cn/static/img/5d6d5003dcde1e358ab3a0a47ca08f951523884&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt;显示库列表：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs nginx&quot;&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;show dbs
&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用某数据库&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs sql&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;use &lt;span class=&quot;hljs-keyword&quot;&gt;admin
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;显示表列表&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs nginx&quot;&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;show collections
&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果存在 city 表，格式化显示 city 表内容：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs css&quot;&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;db&lt;span class=&quot;hljs-selector-class&quot;&gt;.city&lt;span class=&quot;hljs-selector-class&quot;&gt;.find()&lt;span class=&quot;hljs-selector-class&quot;&gt;.pretty()
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://springforall.ufile.ucloud.com.cn/static/img/093c97deaa04b8855291fcb9765edd011523884&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;八、总结&lt;/h2&gt;
&lt;p&gt;这里，探讨了 Spring WebFlux 的如何整合 MongoDB 。整合其他存储 Cassandra、Redis、Couchbase，就大同小异了。下面，我们能会整合 Thymeleaf，更好的页面展示给大家。顺便让大家学习下 Thymeleaf 的基本用法。&lt;/p&gt;
&lt;h3&gt;系列教程目录&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;《01：WebFlux 系列教程大纲》&lt;/li&gt;
&lt;li&gt;《02：WebFlux 快速入门实践》&lt;/li&gt;
&lt;li&gt;《03：WebFlux Web CRUD 实践》&lt;/li&gt;
&lt;li&gt;《04：WebFlux 整合 Mongodb》&lt;/li&gt;
&lt;li&gt;《05：WebFlux 整合 Thymeleaf》&lt;/li&gt;
&lt;li&gt;《06：WebFlux 中 Thymeleaf 和 Mongodb 实践》&lt;/li&gt;
&lt;li&gt;《07：WebFlux 整合 Redis》&lt;/li&gt;
&lt;li&gt;《08：WebFlux 中 Redis 实现缓存》&lt;/li&gt;
&lt;li&gt;《09：WebFlux 中 WebSocket 实现通信》&lt;/li&gt;
&lt;li&gt;《10：WebFlux 集成测试及部署》&lt;/li&gt;
&lt;li&gt;《11：WebFlux 实战图书管理系统》&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;代码示例&lt;/h3&gt;
&lt;p&gt;本文示例读者可以通过查看下面仓库的中的模块工程名: 2-x-spring-boot-webflux-handling-errors：&lt;/p&gt;
&lt;p&gt;如果您对这些感兴趣，欢迎 star、follow、收藏、转发给予支持！&lt;/p&gt;
&lt;h3&gt;参考资料&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;Spring Boot 2.x WebFlux 系列：https://www.bysocket.com/archives/2290&lt;/li&gt;
&lt;li&gt;spring.io 官方文档&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;以下专题教程也许您会有兴趣&lt;/h3&gt;
&lt;div readability=&quot;9&quot;&gt;&lt;img src=&quot;http://www.bysocket.com/wp-content/uploads/2017/01/qrcode_for_gh_cd421e7eb7d6_430.jpg&quot; alt=&quot;&quot; width=&quot;224&quot; height=&quot;224&quot;/&gt; &lt;br/&gt;（关注微信公众号，领取 Java 精选干货学习资料） &lt;br/&gt;（添加我微信：bysocket01。加入纯技术交流群，成长技术）&lt;/div&gt;
</description>
<pubDate>Thu, 23 May 2019 12:16:00 +0000</pubDate>
<dc:creator>www.bysocket.com</dc:creator>
<og:description>摘要: 原创出处 https://www.bysocket.com 「公众号：泥瓦匠BYSocket 」欢迎关注和转载，保留摘要，谢谢！ 这是泥瓦匠的第104篇原创 文章工程：* JDK 1.8* M</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Alandre/p/10914240.html</dc:identifier>
</item>
<item>
<title>小窥React360——用React创建360全景VR体验 - venoral</title>
<link>http://www.cnblogs.com/venoral/p/10914222.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/venoral/p/10914222.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;前言   &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;混迹VR届的发烧友兼开发者们一定不要错过这款FaceBook推出的跨端VR开发框架——React360，称为360全景体验框架更为准确，因为其前身是FaceBook和Oculus2017年发布的一个叫作“Racet VR”的JS库，用来在web端创建3D和VR体验。后来Oculus使用该框架的原生C++版本构建自己部分应用，随着时间推移，由于要求框架解决不同需求，项目的APIs开始发生分叉。为了避免两个系统的混淆，开源框架重命名为React360，这更好地反映它的使用场景：创建横跨PC，移动端，VR设备上的沉浸式360体验。&lt;/p&gt;
&lt;p&gt;可以先看一下官方示例效果，这是一个稍复杂的应用，加入了3D模型，在3D模型和2D面板间共享数据。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/861164/201905/861164-20190523201118520-815385546.gif&quot; alt=&quot;&quot; width=&quot;645&quot; height=&quot;318&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;体验&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;工作原理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;官方提供了构建工具react-360-cli，内部使用和ReactNative一样的打包工具Metro，基于JS Bundle在自己的JS Runtime中进行解析，通过事件机制与客户端通信，其实该框架还有很多方面相像或依赖于RN。构建一个React360应用程序需要完成两部分，需要渲染的Raect组件和Runtime定义（这种角色划分直接借鉴于React Native）。这也很清楚地反映出React360的工作流程，可以参见下图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/861164/201905/861164-20190523171422182-1450056896.png&quot; alt=&quot;&quot; width=&quot;607&quot; height=&quot;313&quot;/&gt;（工作流程图）&lt;/p&gt;
&lt;p&gt;基于JavaScript Core/V8引擎，React360提供了Runtime需要的APIs，在客户端（头戴设备，移动端，浏览器等）完成构建界面，web端的渲染底层依赖于Three.js，这是业界较为成熟的3D图形框架，一般需要手动设置3D网格和纹理，而框架中的react-360-web模块隐藏了这些细节。当创建了新的React组件，框架会指示Runtime将它们添加到3D场景中，当用户提供输入将作为事件通过Runtime传递给React，这两部分相互合作形成一个凝合系统。如果想在系统中分享数据，就需要借助框架提供的Native Modules。&lt;/p&gt;
&lt;p&gt;需要注意的是，由于JS运作在浏览器中是单线程的，应用中任何阻碍行为都有可能造成渲染延迟，这对于VR这种即时性很强的体验是十分致命的，所以框架将React组件和渲染过程放在分离的上下文中情有可原。&lt;/p&gt;
&lt;p&gt;默认情况下，React360使用Web Worker执行你的React代码，而不是标准浏览器，这就意味着在组件定义的文件中访问不到原生window.location这类APIs。并不是严格意义上的无法访问，事实上当你打印window对象时React360提供了一个DedicatedWorkerGlobalScope类型实例，它包装了window的一些内容。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Surfaces&lt;/strong&gt;&lt;br/&gt;Surfaces实际上是一个载体，允许你添加2D内容到3D场景，开发者依据像素定义Surfaces宽高，React360获取信息产生合适尺寸的对象，官方介绍了两种类型的Surfaces，Cylinder和Flat。一个Cylinder Surface让2D内容投射到半径为4m的Cylinder内部，其实是假想的圆柱模式。一个Flat Surface位于4m半径的球体外侧，一个假想的球体模式。APIs也提供了像yaw（垂摇），pitch（纵摇），roll（横摇）这些物体自由度控制信息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/861164/201905/861164-20190523180745810-1211295049.png&quot; alt=&quot;&quot; width=&quot;569&quot; height=&quot;311&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为了将React组建附着在Surface上，需要使用AppRegistry注册组件，又一次与ReactNative相似。这会告知Runtime你的组件通过id字段被唯一确定。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
AppRegistry.registerComponent('MyAppName', () =&amp;gt; MyAppName);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;同时在Runtime文件中引用。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;r360.renderToSurface(
  r360.createRoot(&lt;/span&gt;'MyAppName'&lt;span&gt;),
  r360.getDefaultSurface(),
  &lt;/span&gt;'default' &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 可选项，引用的surface的名称 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Components&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;官方提供了呈现2D，3D内容的展示组件和交互按钮组件。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;View：UI构建最基本的元素，被用来组织实体或其他View元素，也是输入事件的容器。&lt;/li&gt;
&lt;li&gt;Image：呈现2D图像&lt;/li&gt;
&lt;li&gt;ENtity：渲染3D对象，支持obj，mtl，gltf格式文件&lt;/li&gt;
&lt;li&gt;VrButton：是一个实用程序类，是捕获事件的包装器。可以检测各种输入设备上单击类型操作，这是通过一个可以监听按键事件的内部状态机做到的。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Layout&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;支持2D Surface布局，完全以Flexbox格式布局，又是一个和RN相似的点。支持3D Space布局，使用Entity组件时候，通过transform完成3D对象放置，x轴指向用户右侧，y轴指向上方，z轴指向用户后方。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;APIs&lt;br/&gt;&lt;/strong&gt;官方提供了常见的APIs，例如来自React Native的Animated；键值对存储系统AsyncStorage；值得一提的是提供的ControllerInfo可以被用来响应控制器的connect/disconnect事件，获取关于所连接的游戏手柄和控制器的静态信息，比如唯一标识符，按钮，轴数等信息。环境API Environment用来改变场景的背景，包括图片，音频，视频。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实例解读&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;利用react-360-cli生成的项目中主要有这三个文件：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;index.js：放置应用的主要代码，React组件的地方，在这里可以组织拆分多个组件&lt;/li&gt;
&lt;li&gt;client.js：也就是Runtime的配置，这部分连接浏览器环境和React应用。根据代码示例看到主要完成三件事：（1）创建React360一个新实例，加载并附加React代码到DOM特定位置，这里也是传递初始化选项的地方。（2）将你的代码挂载到3D场景中，在index.js中声明的挂载点附着在应用程序的默认曲面。（3）添加背景信息，这个部分可选，允许代码仍在加载过程中展示图片，让用户尽快看到一些内容。&lt;/li&gt;
&lt;li&gt;index.html：提供安装JS代码的挂载点。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; import {ReactInstance} from 'react-360-web'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;function&lt;/span&gt; init(bundle, parent, options =&lt;span&gt; {}) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;   const r360 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ReactInstance(bundle, parent, {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     fullScreen: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    ...options,
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;  });
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;  r360.renderToSurface(
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     r360.createRoot('SlideshowSample'&lt;span&gt;, {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;      photos: [
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         {uri: './static_assets/360_world.jpg', title: '360 World1', format: '2D'&lt;span&gt;},
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         {uri: './static_assets/360_world2.jpg', title: '360 World2', format: '2D'&lt;span&gt;},
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Add your own 180 / 360 photos to this array,&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; with an associated title and format&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;      ],
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    }),
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    r360.getDefaultSurface(),
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;  );
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt; window.React360 = {init};
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Native Modules&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;前面说过React组件运行在单独上下文中，那么如何与主窗口通信，官方提供了Native Modules模块，让React代码有了回调到Runtime的能力，包括在加载中存值，请求有关连接控制器信息或操纵渲染环境。Native模块被创建在Runtime代码中，使用Native Module需要自定义类，继承自Module，使用前需注册，这个示例模板代码演示了Native Modules的许多用法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; import {Module} from 'react-360-web'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;class MyModule extends Module {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;  constructor() {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使这个模块在NativeModules.MyModule可用&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     super('MyModule'&lt;span&gt;); 
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;   
&lt;span&gt; 9&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这个方法将被暴露到React应用一侧&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;  doSomething() {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; const r360 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ReactInstance(
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;   'MyApp.bundle?platform=vr'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;   document.getElementById('container'&lt;span&gt;),
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;  {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在初始时刻注册自定义模块，接收Native Module实例，或一个返回实例的函数（需要传递上下文）&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    nativeModules: [
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;       &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MyModule(),
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;       ctx =&amp;gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MyModule(ctx)
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    ]
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; );
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通常有两种使用场景，暴露常量和普通到React（同步），回调函数或返回Promise方法（异步）。这一段代码同时演示了这几种使用场景，这是一个发送浏览器信息到React侧的应用示例，在注册阶段，模块构造时常量生成并添加模块实例的userAgent属性上，这个值被直接传递给React。第二个例子是暴露了同步setTitle()方法，只需要一个字符串设置窗口标题栏。剩下两个异步方法展示了异步数据如何返回到React。当getBatteryLevel()在React侧被调用，开发者传递的回调在数据可用时触发，&lt;span&gt;调用上下文提供的&lt;span&gt;invokeCallback，将参数放置在数组中，你可以给回调传递任意数量的参数。尽管回调是处理异步任务的一种方式，但我们更偏向于用Promise创建有组织可读性强的异步逻辑链。通过Native Module，你可以使用$符号前缀形式来暴露这种行为，两个回调ID会作为Promise的resolve, reject自动传递给Runtime，该方法会返回一个Promise到调用端。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49.5&quot;&gt;
&lt;pre readability=&quot;16&quot;&gt;
&lt;span&gt; 1&lt;/span&gt; import {Module} from 'react-360-web'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; export &lt;span&gt;default&lt;/span&gt;&lt;span&gt; class BrowserInfoModule extends Module {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;  constructor(ctx) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     super('BrowserInfo'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;._rnctx =&lt;span&gt; ctx;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.userAgent =&lt;span&gt; navigator.userAgent;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;   /*&lt;p&gt;*/
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;  setTitle(title) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     document.title =&lt;span&gt; title;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;   getBatteryLevel(cb) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 读取window信息&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;     const getBattery = navigator.mozGetBattery ||&lt;span&gt; navigator.getBattery;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    getBattery
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;      .call(navigator)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;      .then(
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         battery =&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;           &lt;span&gt;//&lt;/span&gt;&lt;span&gt; extract the level and return it&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;           &lt;span&gt;return&lt;/span&gt;&lt;span&gt; battery.level;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;        },
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         e =&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;           &lt;span&gt;//&lt;/span&gt;&lt;span&gt; if an error occurs, return null&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;           &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;      )
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;       .then(level =&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;._rnctx) {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;           &lt;span&gt;this&lt;/span&gt;&lt;span&gt;._rnctx.invokeCallback(cb, [level]);
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;      });
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; 
&lt;span&gt;35&lt;/span&gt; &lt;span&gt;  $getConfirmation(message, resolve, reject) {
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;     const result =&lt;span&gt; window.confirm(message);
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;._rnctx) {
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;       &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (result) {
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;&lt;span&gt;._rnctx.invokeCallback(resolve, []);
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;       } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; When rejecting a Promise, a message should be provided to populate&lt;/span&gt;
&lt;span&gt;42&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; the Error object on the React side&lt;/span&gt;
&lt;span&gt;43&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;._rnctx.invokeCallback(reject, [{message: 'Canceled the dialog'&lt;span&gt;}]);
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; }
&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;后记&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于React360的整体一览，官方文档还是对在web端介绍比较多，官方开发团队在GitHub也比较活跃，所以有问题可以及时issue都会有人回复。Facebook在几年前收购了Oculus足已看出其进军VR届的雄心已经初见倪端，目前市面上许多APP对360全景图的应用也万象回春，微博的全景图借助手机的陀螺仪和重力传感器在不点击图片详情的情况下跟随用户手势动态变化，自如的VR看房，在我们APP里也引入了全景酒店实景体验。在昂贵的VR设备消费者负担不起的情况下，360度全境体验正是VR在当今阶段最普及的形态，虽然只是纯粹的平面图像，却也一定程度上营造了沉浸式感受，而React360在静态全景的基础上引入了多种交互，这更加方便消费者了解需求，相信360全景的未来还能做得更多。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参考&lt;br/&gt;&lt;a href=&quot;https://facebook.github.io/react-360/&quot;&gt;https://facebook.github.io/react-360/&lt;/a&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 23 May 2019 12:14:00 +0000</pubDate>
<dc:creator>venoral</dc:creator>
<og:description>前言 混迹VR届的发烧友兼开发者们一定不要错过这款FaceBook推出的跨端VR开发框架——React360，称为360全景体验框架更为准确，因为其前身是FaceBook和Oculus2017年发布的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/venoral/p/10914222.html</dc:identifier>
</item>
</channel>
</rss>