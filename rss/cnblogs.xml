<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>print( &quot;Hello，NumPy！&quot; ) - 玩世不恭的Coder</title>
<link>http://www.cnblogs.com/LiT-26647879-510087153/p/13943370.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/LiT-26647879-510087153/p/13943370.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://gitee.com/tianxingjian123/my-images-repository/raw/master/img/5.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;学习痛苦啊，今天学，明天丢。这种天气，还是睡觉最舒服了。&lt;/p&gt;
&lt;img src=&quot;https://gitee.com/tianxingjian123/my-images-repository/raw/master/img/u=3900302641,982460618&amp;amp;fm=26&amp;amp;gp=0.jpg&quot; width=&quot;150&quot;/&gt;&lt;p&gt;咱说归说，闹归闹，但还是得学才行啊。&lt;/p&gt;
&lt;p&gt;之前在学习的过程中一直都有记录笔记的习惯，但笔记质量可不敢恭维，大多都未曾整理，不过拿来复习倒是个不错的选择。&lt;/p&gt;
&lt;img src=&quot;https://gitee.com/tianxingjian123/my-images-repository/raw/master/img/article_category.png&quot; width=&quot;500&quot;/&gt;&lt;p&gt;自打接触Python以来，写的最多的就是爬虫了，什么网络小说啊，虚拟游戏币啊，考试题库啊之类的都有写过，也帮别人爬过不少网站公开数据。之前也整理过一篇爬虫相关的文章（太懒了，才一篇，之后有机会有时间，再整理出来吧）：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI4NjMyMDM4Mg==&amp;amp;mid=2247483692&amp;amp;idx=1&amp;amp;sn=ae61943c0fe7625b6f1dbac08dde1dd2&amp;amp;chksm=ebdff2bddca87bab4d236f47c6ae4a670d45ad5fa266fd5e359bd47441bb7cf34bdc52d4b23e&amp;amp;token=1984820117&amp;amp;lang=zh_CN#rd&quot;&gt;网络爬虫之页面花式解析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;再之后的话，就对Social Engineering产生了一定的兴趣，或许需要能言善辩，巧舌如簧，达到“江湖骗子”的等级，才能玩转社会工程学吧。之前也写过一篇Web渗透相关的文章：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI4NjMyMDM4Mg==&amp;amp;mid=2247483902&amp;amp;idx=1&amp;amp;sn=8fb1b76b9b4095469b3b0ee9e5d84d97&amp;amp;chksm=ebdff26fdca87b79dffc7dbf79466ea5ec0effcf032134d67be98f84b161c07b224789ffab6c&amp;amp;token=1026440270&amp;amp;lang=zh_CN#rd&quot;&gt;Taoye渗透到一家黑平台总部，背后的真相细思极恐&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这里还是有必要提醒一下大家，对于一些不信任的人或信息，如果你会一些网络安全相关技能，可以当做一次渗透经验，否则的话，最好的处理方式是置之不理，别让你的好奇心成为坠入深渊的开始，尤其是在这云龙混杂的虚拟网络世界中。就在前几天，警方还破获了全国最大网络 luo liao 敲诈案呢，受害者达10余万人，涉案金额也有XXXXXXXXXXXXXXX，大家还是需要注意的。&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&quot;https://gitee.com/tianxingjian123/my-images-repository/raw/master/img/hacker.png&quot; width=&quot;300&quot;/&gt;&lt;p&gt;反正，学的东西很多、很杂，学的也不精，记录的笔记也很少回过头复习。工欲善其事，必先利其器，这不开始系统性学习机器学习么，所以想把之前记录的Numpy、Pandas、Matplotlib“三剑客”笔记重新整理一下，也算是做一个回顾。&lt;/p&gt;
&lt;p&gt;后期的话，会学习一些机器学习算法，主要参考《机器学习实战 / Machine Learning in Action》和周志华老师的《机器学习》西瓜书，以及其他一些圈内大佬写的一些技术文章。能手撕的话尽量手撕，不能手撕只能说明自己还有待提高吧。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Flag立的太多，感觉会被啪啪打脸。没事，慢慢来吧，打脸也不怕，反正皮糙肉厚 (￣_,￣ )&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这篇文章先把NumPy整理出来吧，可能记录的并不全面，只记录了一些常用的，其他的话后期用到了再进行更新吧。以下内容主要参考菜鸟教程和NumPy官方文档：&lt;/p&gt;
&lt;p&gt;关于NumPy的安装，前面在介绍深度学习环境搭建的时候已经介绍过了，推荐安装Anaconda，其内部集成了大量第三方工具模块，而不需要手动 &lt;code&gt;pip install ...&lt;/code&gt;，这一点就有点像Java中的Maven。Anaconda可参考：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI4NjMyMDM4Mg==&amp;amp;mid=2247483687&amp;amp;idx=1&amp;amp;sn=619c42cf73ebfa8c996dc9217b8408c8&amp;amp;chksm=ebdff2b6dca87ba060c547b1ac62c32aa1690d85d0d6995a084c2e83133044a888c9b383b14d&amp;amp;token=1622870448&amp;amp;lang=zh_CN#rd&quot;&gt;基于Ubuntu+Python+Tensorflow+Jupyter notebook搭建深度学习环境&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果您没有安装Anaconda那也没事，只需要在Python环境下执行以下命令安装NumPy即可：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt; pip3 install numpy -i https://pypi.tuna.tsinghua.edu.cn/simple
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以下内容采用的NumPy的版本为：1.18.1&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;In [1]: import numpy as np

In [2]: np.__version__
Out[2]: '1.18.1'
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在NumPy中，操作的对象大多为ndarray类型，也可称其别名为array，我们可以把它看做矩阵或向量。&lt;/p&gt;
&lt;p&gt;创建np.ndarray对象有多种方式，NumPy中也有多个api可供调用，比如我们可以通过如下方式创建一个指定的ndarray对象：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;In [7]: temp_array = np.array([[1, 2, 3], [4, 5, 6]], dtype = np.int32)

In [8]: temp_array
Out[8]:
array([[1, 2, 3],
       [4, 5, 6]])

In [9]: type(temp_array)
Out[9]: numpy.ndarray       # 输出的类型为ndarray
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然了，也可以调用&lt;code&gt;arange&lt;/code&gt;，然后对其进行&lt;code&gt;reshape&lt;/code&gt;操作来改变其形状，将向量转换成2x3的矩阵形式，此时的对象类型依然是&lt;code&gt;numpy.ndarray&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;In [14]: temp_array = np.arange(1, 7).reshape(2, 3)     # arange产生向量，reshape改变形状，转化成矩阵

In [15]: temp_array
Out[15]:
array([[1, 2, 3],
       [4, 5, 6]])

In [16]: type(temp_array)       # 输出的类型依然是ndarray
Out[16]: numpy.ndarray
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由上，我们可以发现，无论通过什么方式（其他方式后期会有介绍）来创建对象，NumPy操作的都是ndarray类型，且该类型对象中主要包含以下属性：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;ndarray.ndim：&lt;/strong&gt;表示ndarray的轴数，也可理解成维度，&lt;strong&gt;或者可以通俗的理解成外层中括号的数量。&lt;/strong&gt;比如[1, 2, 3]的ndim就是1，[[1], [2], [3]]的ndim等于2，[[[1]], [[2]], [[3]]]的ndim等于3（注意观察外层中括号的数量）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ndarray.shape：&lt;/strong&gt;表示ndarray的形状，输出的是一个元组。该ndarray有n行m列，那输出的就是(n, m)，比如[[1], [2], [3]]输出的是(3, 1)，[[[1]], [[2]], [[3]]]输出的是(3, 1, 1)，[[[1, 2]], [[3, 4]]]输出的是(2, 1, 2)。通过上述3个例子，&lt;strong&gt;可以发现shape是按照从外至内的顺序来表示的&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ndarray.size：&lt;/strong&gt;这个比较容易理解，表示的就是ndarray内部元素的总个数，也就是shape的乘积&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ndarray.dtype：&lt;/strong&gt;表示ndarray内部元素的数据类型，常见的有&lt;code&gt;numpy.int32、numpy.int64、numpy.float32、numpy.float64&lt;/code&gt;等&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以上就是ndarray中常见的一些属性，&lt;strong&gt;注意：只是部分，并非全部，其他属性可参考官方文档&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们可以通过以下列子来观察下ndarray的各个属性，以及其内部的属性应该如何修改：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/tianxingjian123/my-images-repository/raw/master/img/attribute.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以上例子中涉及到的&lt;code&gt;np.expand_dims&lt;/code&gt;和&lt;code&gt;np.astype&lt;/code&gt;会在后面进行介绍。&lt;/p&gt;
&lt;p&gt;np.zeros可以创建一个元素全0的ndarray，np.ones则可以创建一个元素全1的ndarray。创建的时候可以指定ndarray的shape形状，也可以通过dtype属性指定内部元素的数据类型：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;In [70]: np.zeros([2,3,2], dtype=np.float32)
Out[70]:
array([[[0., 0.],
        [0., 0.],
        [0., 0.]],

       [[0., 0.],
        [0., 0.],
        [0., 0.]]], dtype=float32)

In [71]: np.ones([3,2,2], dtype=np.float32)
Out[71]:
array([[[1., 1.],
        [1., 1.]],

       [[1., 1.],
        [1., 1.]],

       [[1., 1.],
        [1., 1.]]], dtype=float32)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;另外，在Tensorflow中可以通过tf.fill产生指定元素的指定shape张量，如下产生2x3的张量，且内部元素为100：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;In [76]: import tensorflow as tf

In [77]: tf.fill([2,3], 100)
Out[77]:
&amp;lt;tf.Tensor: shape=(2, 3), dtype=int32, numpy=
array([[100, 100, 100],
       [100, 100, 100]])&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而在NumPy中，也有fill接口，只不过只能通过已有的ndarray才能调用fill，而无法直接np.fill进行调用：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;In [79]: data = np.zeros([2, 3])

In [80]: data.fill(100)

In [81]: data
Out[81]:
array([[100., 100., 100.],
       [100., 100., 100.]])
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;np.arange与常用的range作用类似，用于产生一个固定区间连续的ndarray，注意取左不取右，且数组之间成一个等差数列，公差可自行定义（可为小数），如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;In [85]: np.arange(10)
Out[85]: array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])

In [86]: np.arange(3, 10, 2)
Out[86]: array([3, 5, 7, 9])

In [87]: np.arange(3, 10, 0.7)
Out[87]: array([3. , 3.7, 4.4, 5.1, 5.8, 6.5, 7.2, 7.9, 8.6, 9.3])
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;numpy.linspace 函数用于创建一个一维数组，数组是一个等差数列构成的，可以指定元素内部元素的个数以及是否包含stop值。如下，在区间1-5中创建一个元素数目为10的等差数列：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;In [89]: np.linspace(1, 5, 10)      # 默认包含stop
Out[89]:
array([1.        , 1.44444444, 1.88888889, 2.33333333, 2.77777778,
       3.22222222, 3.66666667, 4.11111111, 4.55555556, 5.        ])

In [90]: np.linspace(1, 5, 10, endpoint = False)    # endpoint属性可以设置不包含stop
Out[90]: array([1. , 1.4, 1.8, 2.2, 2.6, 3. , 3.4, 3.8, 4.2, 4.6])
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;np.random.random和np.random.rand随机从0-1中生成对应shape的ndarray对象：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;In [4]: np.random.random([3, 2])
Out[4]:
array([[0.68755531, 0.56727707],
       [0.86027161, 0.01362836],
       [0.56557302, 0.94283249]])

In [5]: np.random.rand(2, 3)
Out[5]:
array([[0.19894754, 0.8568503 , 0.35165264],
       [0.75464769, 0.29596171, 0.88393648]])
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;np.random.randint随机生成指定范围的ndarray，且内部元素为int类型：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;In [6]: np.random.randint(0, 10, [2, 3])
Out[6]:
array([[0, 6, 9],
       [5, 9, 1]])
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;np.random.randn返回满足标准正态分布的ndarray（均值为0，方差为1）：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;In [7]: np.random.randn(2,3)
Out[7]:
array([[ 2.46765106, -1.50832149,  0.62060066],
       [-1.04513254, -0.79800882,  1.98508459]])
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;另外，我们在NumPy中使用random的时候，都是随机产生的一组数据，而&lt;strong&gt;要想每次产生的数据相同&lt;/strong&gt;，则需要通过np.random.seed来进行设置：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;In [33]: np.random.seed(100)

In [34]: np.random.randn(2, 3)
Out[34]:
array([[-1.74976547,  0.3426804 ,  1.1530358 ],
       [-0.25243604,  0.98132079,  0.51421884]])

In [35]: np.random.seed(100)

In [36]: np.random.randn(2, 3)
Out[36]:
array([[-1.74976547,  0.3426804 ,  1.1530358 ],
       [-0.25243604,  0.98132079,  0.51421884]])
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在NumPy中的一维ndarray里，就如同列表一样操作，可以对其进行切片和遍历等操作：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;In [5]: a
Out[5]: array([1., 2., 3., 4., 5., 6., 7., 8., 9.])

In [6]: a[2], a[2:5]
Out[6]: (3.0, array([3., 4., 5.]))

In [7]: a * 3, a ** 3   # 立方
Out[7]:
(array([ 3.,  6.,  9., 12., 15., 18., 21., 24., 27.]),
 array([  1.,   8.,  27.,  64., 125., 216., 343., 512., 729.]))
 
In [13]: for i in a:
...:     print(i, end=&quot;, &quot;)
1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0,
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;假如我们的ndarray并非是一维数组，而是二维矩阵，或是更高维度的ndarray，则我们需要对其进行多维度的切分。且&lt;strong&gt;当我们对高维度的ndarray进行遍历的时候，则遍历出单个结果的维度比元维度少一，比如2维矩阵遍历得到的结果为1维向量，三维遍历的结果为2维矩阵。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;另外，还有一点需要说明的是，加入我的数据的维度相当高，为了方便我们对数据进行索引，NumPy为我们提供了&lt;code&gt;...&lt;/code&gt;的方式来进行切分，具体例子如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;In [14]: a = np.random.randint(0, 2, 6).reshape(2, 3)

In [15]: a
Out[15]:
array([[1, 1, 1],
       [1, 0, 1]])

In [16]: a[:, :2]
Out[16]:
array([[1, 1],
       [1, 0]])

In [17]: for i in a:        # 对矩阵进行遍历，则输出的是行向量，单个输出的维度比原维度少1
    ...:     print(i, end=&quot;, &quot;)
[1 1 1], [1 0 1],

In [19]: data = np.random.randint(0, 2, [2, 2, 3])

In [20]: data
Out[20]:
array([[[0, 0, 1],
        [0, 1, 1]],

       [[1, 0, 0],
        [0, 1, 0]]])

In [21]: data[..., :2]      # ...则表示前两个维度全要，相当于 data[:, :, :2]
Out[21]:
array([[[0, 0],
        [0, 1]],

       [[1, 0],
        [0, 1]]])
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;shape操作：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;a.ravel()、ndarray.flatten()，将ndarray进行拉伸操作（拉直成向量形式）&lt;/li&gt;
&lt;li&gt;a.reshape()，重新改变a的shape外形&lt;/li&gt;
&lt;li&gt;a.T、a.transpose()，返回a的倒置矩阵&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以上几个操作返回的都是新的结果，而不改变原来的ndarray（a）。且&lt;strong&gt;上述操作默认的都是横向操作，如果需要纵向，则需要控制order参数，具体操作可参考菜鸟教程。&lt;/strong&gt;除了reshape之外，还有resize，只不过resize会改变a的结果，而并非产生一个新的结果：&lt;/p&gt;
&lt;img src=&quot;https://gitee.com/tianxingjian123/my-images-repository/raw/master/img/change.png&quot; width=&quot;600&quot;/&gt;&lt;p&gt;还有一个小技巧需要掌握的是，在进行reshape的时候，假如传入-1，则会自动计算出对应的结果。比如一个 2x3的矩阵a，我们进行a.reshape(3, -1)，则这里的-1代表的就是2，当我们数据量大的时候，这个用起来还是挺方便的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;In [44]: a
Out[44]:
array([[1, 1, 1],
       [1, 0, 1]])

In [45]: a.reshape([3, -1])
Out[45]:
array([[1, 1],
       [1, 1],
       [0, 1]])
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;数组维度的修改：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;维度&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;broadcast_to&lt;/td&gt;
&lt;td&gt;将数组广播到新形状&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;expand_dims&lt;/td&gt;
&lt;td&gt;扩展数组的形状&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;squeeze&lt;/td&gt;
&lt;td&gt;从数组的形状中删除一维条目&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;具体操作如下：&lt;/p&gt;
&lt;img src=&quot;https://gitee.com/tianxingjian123/my-images-repository/raw/master/img/dims.png&quot; width=&quot;600&quot;/&gt;&lt;p&gt;数组的连接：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;concatenate&lt;/td&gt;
&lt;td&gt;连接沿现有轴的数组序列&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;hstack&lt;/td&gt;
&lt;td&gt;水平堆叠序列中的数组（列方向）&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;vstack&lt;/td&gt;
&lt;td&gt;竖直堆叠序列中的数组（行方向）&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;下面代码显示了数组连接的操作，其中concatenate可以通过控制axis的值来确定连接的方向，作用等同于hstack和vstack。还有一点需要注意的是：以下示例仅仅是连接两个数组，其实可以同时连接多个的，比如&lt;code&gt;np.concatenate((x, y, z), axis=1)&lt;/code&gt;&lt;/p&gt;
&lt;img src=&quot;https://gitee.com/tianxingjian123/my-images-repository/raw/master/img/stack.png&quot; width=&quot;600&quot;/&gt;&lt;p&gt;数组的切分：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;split&lt;/td&gt;
&lt;td&gt;将一个数组分割为多个子数组&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;hsplit&lt;/td&gt;
&lt;td&gt;将一个数组水平分割为多个子数组（按列）&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;vsplit&lt;/td&gt;
&lt;td&gt;将一个数组垂直分割为多个子数组（按行）&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;同数组的连接一样，split可以通过控制axis属性来得到与hsplit、vsplit相同的作用，下面只给出split的示例，关于hsplit和vsplit可参考官方文档：&lt;/p&gt;
&lt;img src=&quot;https://gitee.com/tianxingjian123/my-images-repository/raw/master/img/split.png&quot; width=&quot;600&quot;/&gt;&lt;p&gt;数组元素的添加和删除：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;append&lt;/td&gt;
&lt;td&gt;将值添加到数组末尾&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;insert&lt;/td&gt;
&lt;td&gt;沿指定轴将值插入到指定下标之前&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;delete&lt;/td&gt;
&lt;td&gt;删掉某个轴的子数组，并返回删除后的新数组&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;img src=&quot;https://gitee.com/tianxingjian123/my-images-repository/raw/master/img/append_insert_delete.png&quot; width=&quot;600&quot;/&gt;&lt;p&gt;广播(Broadcast)是 numpy 对不同形状(shape)的数组进行数值计算的方式， 对数组的算术运算通常在相应的元素上进行。&lt;/p&gt;
&lt;p&gt;如果两个数组 a 和 b 形状相同，即满足 a.shape == b.shape，那么 a*b 的结果就是 a 与 b 数组对应位相乘。这要求维数相同，且各维度的长度相同。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;In [8]: import numpy as np

In [9]: a = np.array([1,2,3,4])
   ...: b = np.array([10,20,30,40])

In [10]: a * b
Out[10]: array([ 10,  40,  90, 160])
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当运算中的 2 个数组的形状不同时，numpy 将自动触发广播机制。如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;In [11]: a = np.array([[ 0, 0, 0],
    ...:            [10,10,10],
    ...:            [20,20,20],
    ...:            [30,30,30]])
    ...: b = np.array([1,2,3])

In [12]: a + b
Out[12]:
array([[ 1,  2,  3],
       [11, 12, 13],
       [21, 22, 23],
       [31, 32, 33]])
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面的图片展示了数组 b 如何通过广播来与数组 a 兼容。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.runoob.com/wp-content/uploads/2018/10/image0020619.gif&quot; alt=&quot;来源：菜鸟教程&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;np.tile可以对目标操作数组进行广播扩展，比如 1x3 如下操作可以广播为 4x6，注意与前面所说的broadcast_to进行区别，broadcast_to必须要扩维，而tile可扩维，也可不扩维，具体操作根据自己的实际需求进行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;有过Tensorflow经验的读者应该知道，其内部也有tile和broadcast操作，但是当我们的数据量比较大的时候，据说tile的效率比broadcast要低，暂时还没了解原因，以后有用到在了解吧。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;In [20]: a
Out[20]: array([[1, 1, 0]])

In [21]: np.tile(a, [4, 2])     # 第二个参数表示各个维度广播的倍数，这里表示的是行扩4倍，列扩2倍
Out[21]:
array([[1, 1, 0, 1, 1, 0],
       [1, 1, 0, 1, 1, 0],
       [1, 1, 0, 1, 1, 0],
       [1, 1, 0, 1, 1, 0]])
&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;关于NumPy中的复制和试图：这个部分的知识也是我之前在学习NumPy时候所遗漏的点，趁着这个机会，把它在这记录一下。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;没有复制&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;关于这一点，其实在之前记录&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI4NjMyMDM4Mg==&amp;amp;mid=2247483926&amp;amp;idx=1&amp;amp;sn=771f69bc69a2a182b5d4c64d6bdd4f49&amp;amp;chksm=ebdff187dca87891882011a7c01d59591466acaa38d8906e0a3535266d26eb12e48c77d10019&amp;amp;token=1026440270&amp;amp;lang=zh_CN#rd&quot;&gt;LeetCode 热题 HOT 100（01，两数相加）&lt;/a&gt;算法的时候同样提到过，&lt;strong&gt;这一点还是需要格外注意的。&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&quot;https://gitee.com/tianxingjian123/my-images-repository/raw/master/img/fuzhi.png&quot; width=&quot;500&quot;/&gt;&lt;ul&gt;&lt;li&gt;视图或者浅拷贝（view）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;同样采用上面一样的代码，仅仅修改了第57行，将 y = x 和 y = x.view()，可以发现，此时的x和y的id值不一样，也就是说他们的内存地址不一样，我们修改x的shape之后，y的shape并没有发生改变。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;但是，当我们改变不是shape，而是改一个变数组内部的数据，则另一个数组同样会发生改变&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&quot;https://gitee.com/tianxingjian123/my-images-repository/raw/master/img/view_.png&quot; width=&quot;600&quot;/&gt;&lt;ul&gt;&lt;li&gt;副本或者深拷贝(copy)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;视图或者浅拷贝采用的是&lt;code&gt;view&lt;/code&gt;，而副本或者深拷贝采用的是&lt;code&gt;copy&lt;/code&gt;。使用&lt;code&gt;copy&lt;/code&gt;的时候无论是修改一个数组的shape，还是内部元素，另一个数组都不会发生改变。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（关于copy，这里就不再演示代码了，读者可自行操作，然后进行比较）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最后总结一下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;y = x，说明x和y的&lt;strong&gt;内存地址相同，修改其中一个，另一个也会随着发生改变（无论是shape，还是内部元素）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;y = x.view()，&lt;strong&gt;两者的内存地址不一样&lt;/strong&gt;，修改其中一个的shape，&lt;strong&gt;另一个不会发生改变&lt;/strong&gt;；而修改其中一个元组的内部元素，&lt;strong&gt;则另外一个会跟着发生改变&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;y = x.copy()，&lt;strong&gt;两者的内存地址不一样&lt;/strong&gt;，无论是修改一个元组的shape，还是内部元素，&lt;strong&gt;另外一个都不会发生改变，两者相互独立&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;p&gt;NumPy中的数学相关函数，这部分内容没什么好讲的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;np.pi，返回π值&lt;/li&gt;
&lt;li&gt;np.sin()，返回正弦值&lt;/li&gt;
&lt;li&gt;np.cos()，返回余弦值&lt;/li&gt;
&lt;li&gt;np.tan()，返回正切值&lt;/li&gt;
&lt;li&gt;numpy.ceil()，返回大于或者等于指定表达式的最小整数，即向上取整。&lt;/li&gt;
&lt;li&gt;np.exp(2)，返回指数值，也就是 $e^2$&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其他相关数学函数，可参考官方文档。&lt;/p&gt;
&lt;p&gt;NumPy中的算术运算，这部分内容也没什么好讲的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;numpy.add(a,b)：两数组相加&lt;/li&gt;
&lt;li&gt;numpy.subtract(a,b)：两数组相减&lt;/li&gt;
&lt;li&gt;numpy.multiply(a,b)：两数组相乘&lt;/li&gt;
&lt;li&gt;numpy.divide(a,b)：两数组相除&lt;/li&gt;
&lt;li&gt;numpy.reciprocal(a)，返回倒数&lt;/li&gt;
&lt;li&gt;numpy.power(a, 4)，返回a的四次方&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;p&gt;NumPy中的统计函数，这个稍微记录一下：&lt;/p&gt;
&lt;img src=&quot;https://gitee.com/tianxingjian123/my-images-repository/raw/master/img/tongjifunction.png&quot; width=&quot;400&quot;/&gt;&lt;p&gt;以上示例了在数组中获取最值以及最值之差的方式，传入了axis参数，则按照对应方向获取，假如没有传入axis参数，则表示获取数组整体的最值。除了以上几个接口之外，还有其他一些常见的统计函数，具体操作和上述并无一二，如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;np.amin()：获取最小值&lt;/li&gt;
&lt;li&gt;np.amax()：获取最大值&lt;/li&gt;
&lt;li&gt;np.ptp()：获取最值之差&lt;/li&gt;
&lt;li&gt;np.median()：获取中位数（中值）&lt;/li&gt;
&lt;li&gt;np.mean()：获取均值&lt;/li&gt;
&lt;li&gt;np.var()：获取方差，$\sigma^2 = \frac{1}{n}\sum_{i=1}&lt;sup&gt;n(x_i-\overline{x})&lt;/sup&gt;2$&lt;/li&gt;
&lt;li&gt;np.std()：获取标准差，$\sigma$&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;p&gt;NumPy中的线性代数：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;np.dot(a, b) 就是两个矩阵的乘积&lt;/li&gt;
&lt;li&gt;np.vdot(a, b) 两个矩阵对应位置数的乘积之和&lt;/li&gt;
&lt;li&gt;np.inner(a, b) 內积，就是a的每行与b的每行相乘求和&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;比如a=[[1, 0], [1, 1]]，b=[[1, 2], [1, 3]]&lt;br/&gt;np.inner(a, b)相当于[1, 0] * [1, 2] = 1 -&amp;gt; 为第一个数&lt;br/&gt;[1, 0] * [1, 3] = 1 -&amp;gt; 为第二个数&lt;br/&gt;[1, 1] * [1, 2] = 3 -&amp;gt; 为第三个数&lt;br/&gt;[1, 1] * [1, 3] = 4 -&amp;gt; 为第四个数&lt;/p&gt;
&lt;p&gt;矩阵乘积就是第一个矩阵的行与第二个矩阵的列乘积之和，而inner相当于第一个矩阵和第二个矩阵的行乘积之和&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;np.matmul(a, b) 目前感觉和np.dot(a, b)作用一样，都是矩阵乘积&lt;/li&gt;
&lt;li&gt;np.linalg.det(a) 计算矩阵的行列式的值&lt;/li&gt;
&lt;li&gt;np.linalg.solve(a, [[1], [1]]) 求线性方程组的解，第一个的参数相当于系数，第二个参数相当于参数项&lt;/li&gt;
&lt;li&gt;np.linalg.inv(a) 计算矩阵的逆矩阵&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;pre&gt;
&lt;code&gt;# 将数组保存到以 .npy 为扩展名的文件中。
numpy.save(file, arr, allow_pickle=True, fix_imports=True)
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;file：要保存的文件，扩展名为 .npy，如果文件路径末尾没有扩展名 .npy，该扩展名会被自动加上。&lt;/li&gt;
&lt;li&gt;arr: 要保存的数组&lt;/li&gt;
&lt;li&gt;allow_pickle: 可选，布尔值，允许使用 Python pickles 保存对象数组，Python 中的 pickle 用于在保存到磁盘文件或从磁盘文件读取之前，对对象进行序列化和反序列化。&lt;/li&gt;
&lt;li&gt;fix_imports: 可选，为了方便 Pyhton2 中读取 Python3 保存的数据。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;In [81]: a = np.random.randint(1, 10, [3, 4])

In [82]: np.save(&quot;a.npy&quot;, a)

In [83]: np.load(&quot;a.npy&quot;)
Out[83]:
array([[2, 7, 3, 1],
       [4, 6, 4, 3],
       [2, 2, 9, 5]])
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参考资料：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;[1] NumPy菜鸟教程：&lt;a href=&quot;https://www.runoob.com/numpy/numpy-tutorial.html&quot;&gt;https://www.runoob.com/numpy/numpy-tutorial.html&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;[2] NumPy官方文档：&lt;a href=&quot;https://numpy.org/doc/stable/user/quickstart.html&quot;&gt;https://numpy.org/doc/stable/user/quickstart.html&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;时间不太够，后面写的有点仓促了，但应该并不影响正常阅读和以后的复习，暂时就这样吧。&lt;/p&gt;
&lt;p&gt;注意：只记录了一些常用的，其他的话后期用到了再进行更新吧，其他内容可自行参考文档。&lt;/p&gt;
&lt;p&gt;本来是打算按照《机器学习实战 / Machine Learning in Action》这本书来手撕其中代码的，但由于实际原因，可能需要先手撕SVM了，这个算法感觉还是挺让人头疼，其中内部太复杂了，也很少有资料将其完整的推导出来，也涉及到了许多陌声的名词，如：非线性约束条件下的最优化、KKT条件、拉格朗日对偶、最大间隔、最优下界、核函数等等，天书或许、可能、大概就是这样的吧。好在之前有学习过SVM，但想必依然需要花费大力气来手撕，也需要参考不少资料，包括但不局限于《机器学习实战 / Machine Learning in Action》、《机器学习》、《统计学习方法》。&lt;/p&gt;
&lt;p&gt;所以，下期的话，应该会开始手撕SVM，至于最后能不能手撕成功，还真不好说。时间可能需要不少，这期间的LeetCode HOT 100 还需要正常刷起来。&lt;/p&gt;
&lt;p&gt;我是Taoye，爱专研，爱分享，热衷于各种技术，学习之余喜欢下象棋、听音乐、聊动漫，希望借此一亩三分地记录自己的成长过程以及生活点滴，也希望能结实更多志同道合的圈内朋友，更多内容欢迎来访微信公主号：&lt;strong&gt;玩世不恭的Coder&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;推荐阅读：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI4NjMyMDM4Mg==&amp;amp;mid=2247483942&amp;amp;idx=1&amp;amp;sn=70cacac0414637254e10ea35ba328cc5&amp;amp;chksm=ebdff1b7dca878a1895ef45dac886f0d084c409d84014284e3a8700ad3bcadd3d07d6ea19409&amp;amp;token=1281450696&amp;amp;lang=zh_CN#rd&quot;&gt;干啥啥不行，吃饭第一名&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI4NjMyMDM4Mg==&amp;amp;mid=2247483902&amp;amp;idx=1&amp;amp;sn=8fb1b76b9b4095469b3b0ee9e5d84d97&amp;amp;chksm=ebdff26fdca87b79dffc7dbf79466ea5ec0effcf032134d67be98f84b161c07b224789ffab6c&amp;amp;token=1984820117&amp;amp;lang=zh_CN#rd&quot;&gt;Taoye渗透到一家黑平台总部，背后的真相细思极恐&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI4NjMyMDM4Mg==&amp;amp;mid=2247483871&amp;amp;idx=1&amp;amp;sn=ae9976268a0efb03a9ba30ffeb3cb419&amp;amp;chksm=ebdff24edca87b585c5cb8d6ff2212846dd270db71de573f8240b314e7c3143a78d56644ed00&amp;amp;token=1984820117&amp;amp;lang=zh_CN#rd&quot;&gt;《大话数据库》-SQL语句执行时，底层究竟做了什么小动作？&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI4NjMyMDM4Mg==&amp;amp;mid=2247483781&amp;amp;idx=1&amp;amp;sn=066c44c0771a029b1ba877bc9e919e3f&amp;amp;chksm=ebdff214dca87b021fd1470253383b1370277ead2b3a8fcc98f0d49b21d2aca0a45b5d5d179f&amp;amp;token=1984820117&amp;amp;lang=zh_CN#rd&quot;&gt;那些年，我们玩过的Git，真香&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI4NjMyMDM4Mg==&amp;amp;mid=2247483687&amp;amp;idx=1&amp;amp;sn=619c42cf73ebfa8c996dc9217b8408c8&amp;amp;chksm=ebdff2b6dca87ba060c547b1ac62c32aa1690d85d0d6995a084c2e83133044a888c9b383b14d&amp;amp;token=1984820117&amp;amp;lang=zh_CN#rd&quot;&gt;基于Ubuntu+Python+Tensorflow+Jupyter notebook搭建深度学习环境&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI4NjMyMDM4Mg==&amp;amp;mid=2247483692&amp;amp;idx=1&amp;amp;sn=ae61943c0fe7625b6f1dbac08dde1dd2&amp;amp;chksm=ebdff2bddca87bab4d236f47c6ae4a670d45ad5fa266fd5e359bd47441bb7cf34bdc52d4b23e&amp;amp;token=1984820117&amp;amp;lang=zh_CN#rd&quot;&gt;网络爬虫之页面花式解析&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI4NjMyMDM4Mg==&amp;amp;mid=2247483696&amp;amp;idx=1&amp;amp;sn=cbb2309b0622aae6ba27bd47e6b5f3c3&amp;amp;chksm=ebdff2a1dca87bb72e0e9bf17bf839b4ad1c158fddafd8e8a27d4879b6542135f78f2a656413&amp;amp;token=1984820117&amp;amp;lang=zh_CN#rd&quot;&gt;手握手带你了解Docker容器技术&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI4NjMyMDM4Mg==&amp;amp;mid=2247483686&amp;amp;idx=1&amp;amp;sn=f4aff7b4887b520a4af71c969bf8e7b9&amp;amp;chksm=ebdff2b7dca87ba10fd6b4b8aad787ca0e9c47f978044a49447dd9648106512033cf318890ee&amp;amp;token=1984820117&amp;amp;lang=zh_CN#rd&quot;&gt;一文详解Hexo+Github小白建站&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI4NjMyMDM4Mg==&amp;amp;mid=2247483677&amp;amp;idx=1&amp;amp;sn=e6c00b8c9fddf5791b6c2e9b64b9191d&amp;amp;chksm=ebdff28cdca87b9a2abae1f543021e208ed71d6ab1ad00b0c957fbf09f239f0d7888cb37b45c&amp;amp;token=1984820117&amp;amp;lang=zh_CN#rd&quot;&gt;​打开ElasticSearch、kibana、logstash的正确方式&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 08 Nov 2020 00:12:00 +0000</pubDate>
<dc:creator>玩世不恭的Coder</dc:creator>
<og:description>print( &amp;amp;quot;Hello，NumPy！&amp;amp;quot; ) 学习痛苦啊，今天学，明天丢。这种天气，还是睡觉最舒服了。 咱说归说，闹归闹，但还是得学才行啊。 之前在学习的过程中一</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/LiT-26647879-510087153/p/13943370.html</dc:identifier>
</item>
<item>
<title>进程、线程和协程的区别 - 王泽宾</title>
<link>http://www.cnblogs.com/wanghao72214/p/13943359.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wanghao72214/p/13943359.html</guid>
<description>&lt;p&gt;在面试中，经常会有面试官问题“进程、线程和协程的区别”这个问题，这也是大学课程操作系统中最基本的知识。我们通常对此都说上几句，但细节又不是特别深入明了。我整理了一下相关的内容，加上自己的理解，与君共享。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;105.60659793814&quot;&gt;
&lt;p&gt;在面试中，经常会有面试官问题“进程、线程和协程的区别”这个问题，这也是大学课程操作系统中最基本的知识。我们通常对此都说上几句，但细节又不是特别深入明了。我整理了一下相关的内容，加上自己的理解，与君共享。&lt;/p&gt;
&lt;h4 id=&quot;1-进程&quot;&gt;1. 进程&lt;/h4&gt;
&lt;h5 id=&quot;11-定义&quot;&gt;1.1 定义&lt;/h5&gt;
&lt;p&gt;​ 进程是计算机中程序的一次运行活动，是操作系统进行资源分配和调度的基本单位。每一个进程都拥有自己的地址空间，一般包括代码段、数据段、堆和栈。其中，代码段用来存放处理器执行的代码；数据段存放全局和静态变量；堆用来存放动态分配的内存；栈用来存放局部变量、函数参数和寄存器的值等。&lt;/p&gt;
&lt;h5 id=&quot;12-进程切换&quot;&gt;1.2 进程切换&lt;/h5&gt;
&lt;p&gt;​ 多个进程同时运行时，为了保证所有进程都能获得执行机会，就需要按照一定的算法不断地进行进程切换。所谓进程切换就是从运行中的进程中收回处理器，然后再使待运行进程来占用处理器。从某个进程收回处理器，实质上就是把进程运行过程中寄存器的中间数据存放到进程的堆栈。让某个进程来占用处理器，实质上是把这个进程存放在堆栈中的寄存器数据恢复到处理器的寄存器中去，并把待运行进程的断点送入处理器的程序计数器。&lt;/p&gt;
&lt;p&gt;​ 一个进程存储在处理器各寄存器中的中间数据叫做进程的上下文，所以进程切换就是被中止进程与待运行进程上下文的切换。进程切换上下文时，需要进出操作系统内核，并进行寄存器数据切换等工作，都需要一定的时间开销。&lt;/p&gt;
&lt;h5 id=&quot;13-进程函数&quot;&gt;1.3 进程函数&lt;/h5&gt;
&lt;ul readability=&quot;5.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;pid_t fork(void)&lt;/p&gt;
&lt;p&gt;功能：创建一个子进程&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;int clone(int (*fn)(void &lt;em&gt;), void&lt;/em&gt;child_stack, int flags, void *arg)&lt;/p&gt;
&lt;p&gt;功能：复制一个子进程&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;pid_t getpid(void)&lt;/p&gt;
&lt;p&gt;功能：获取自己的进程id&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;pid_t wait(int *status) or pid_t waitpid(pid_t pid, int *status, int options)&lt;/p&gt;
&lt;p&gt;功能：阻塞父进程，直到子进程结束或者接收到指定的信号&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;2-线程&quot;&gt;2. 线程&lt;/h4&gt;
&lt;h5 id=&quot;21-定义&quot;&gt;2.1 定义&lt;/h5&gt;
&lt;p&gt;​ 线程是进程中的一个实体，是处理器调度和分派的基本单位，它是比进程更小的能独立运行的单元。线程基本上不拥有独立的系统资源，它与同属一个进程的其他的线程共享进程拥有的资源，线程独自拥有少量的程序计数器、数据寄存器和栈等运行中必不可少的私有资源。因此，操作系统调度线程比进程付出的开销小得多，利用线程能够有效地提高系统的并发效率。&lt;/p&gt;
&lt;p&gt;​ 总之&lt;strong&gt;进程是资源分配的基本单位，线程是调度的基本单位&lt;/strong&gt;。&lt;/p&gt;
&lt;h5 id=&quot;22-共享资源&quot;&gt;2.2 共享资源&lt;/h5&gt;
&lt;p&gt;​ 线程共享了所属进程的资源，包括：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;内存地址空间&lt;/li&gt;
&lt;li&gt;进程基础信息&lt;/li&gt;
&lt;li&gt;打开的文件&lt;/li&gt;
&lt;li&gt;信号处理&lt;/li&gt;
&lt;li&gt;当前工作目录&lt;/li&gt;
&lt;li&gt;用户和用户组属性&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;23-线程函数&quot;&gt;2.3 线程函数&lt;/h5&gt;
&lt;ul readability=&quot;6.5&quot;&gt;&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;pthread_create(tid,&amp;amp;attr,func,&amp;amp;arg)　&lt;/p&gt;
&lt;p&gt;功能：创建一个新的线程。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;pthread_join(tid,void **retval)&lt;/p&gt;
&lt;p&gt;功能：等待线程号为tid的线程执行结束后回收线程资源，类似于进程的wait()函数，阻塞进程。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;pthread_exit(void *retval)&lt;/p&gt;
&lt;p&gt;功能：结束线程，并返回结束码&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;pthread_cancel(tid)&lt;/p&gt;
&lt;p&gt;功能：取消线程&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;pthread_self(void)&lt;/p&gt;
&lt;p&gt;功能：获取线程id号&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;3-协程&quot;&gt;3. 协程&lt;/h4&gt;
&lt;h5 id=&quot;31-定义&quot;&gt;3.1 定义&lt;/h5&gt;
&lt;p&gt;​ 协程本质上是一种用户态线程，它不需要操作系统来进行调度，而是由用户程序自行管理和调度。它寄存于线程中，系统开销极小，可以显著的提高性能和并发能力。使用协程的优点是运行效率高、编程简单、结构清晰；缺点是需要编程语言的支持，如果不支持，则需要在用户自行实现调度器。目前，原生支持协程的语言不是很多。&lt;/p&gt;
&lt;p&gt;​ 协程有自己的上下文，同属一个进程的协程共享进程拥有的系统资源。协程的切换由自己控制，由切换到其他协程由当前协程来控制。与线程和进程相比，协程的最大优势在于其“轻量级”，可以轻松创建上百万个而不会导致系统资源衰竭。&lt;/p&gt;
&lt;h5 id=&quot;32-go语言的协程&quot;&gt;3.2 go语言的协程&lt;/h5&gt;
&lt;p&gt;　　 go语言在语言级别支持协程，go的协程叫goroutine。go语言标准库提供的所有系统调用操作，都会出让 处理器给其它goroutine，这使得协程切换管理不再依赖于系统的线程和进程。&lt;/p&gt;
&lt;p&gt;​ go协程与线程的性能比较：&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li&gt;
&lt;p&gt;内存消耗&lt;/p&gt;
&lt;p&gt;goroutine：2KB&lt;/p&gt;
&lt;p&gt;线程：8MB&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;调度切换开销&lt;/p&gt;
&lt;p&gt;goroutine：只修改PC/SP/DX寄存器的值&lt;/p&gt;
&lt;p&gt;线程：模式切换用户态和内核态之间的模式切换)、所有寄存器的刷新&lt;/p&gt;
&lt;p&gt;通过关键字go 就启动了一个 goroutine。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;package main

import (        ·
        &quot;fmt&quot;
        &quot;time&quot;
)

func echo(s string)  {
        fmt.Println(s)
}

func main() {
        // 启动两个协程（goroutine）
        go echo(&quot;Hello world 1&quot;)
        go echo(&quot;Hello world 2&quot;)

        // 阻塞3秒，等待协程执行完毕
        time.Sleep(3*time.Second)
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;本文时候用的开发工具为：&lt;a href=&quot;http://www.sousou88.com/software/2072802.html&quot;&gt;goland&lt;/a&gt; 来自 &lt;a href=&quot;http://www.sousou88.com&quot;&gt;嗖嗖下载&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Sat, 07 Nov 2020 23:50:00 +0000</pubDate>
<dc:creator>王泽宾</dc:creator>
<og:description>在面试中，经常会有面试官问题“进程、线程和协程的区别”这个问题，这也是大学课程操作系统中最基本的知识。我们通常对此都说上几句，但细节又不是特别深入明了。我整理了一下相关的内容，加上自己的理解，与君共享</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wanghao72214/p/13943359.html</dc:identifier>
</item>
<item>
<title>技术人员该如何接手一个复杂的系统？ - 一猿小讲</title>
<link>http://www.cnblogs.com/socoool/p/13943349.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/socoool/p/13943349.html</guid>
<description>&lt;p&gt;作为程序员，无论是小菜还是老鸟，都会因为离职交接或者岗位异动等各种原因，而避免不了要如羚羊奔跑版的速度接手一个复杂业务系统。因为只有尽快熟悉系统，方能够快速支持业务需求的研发。&lt;/p&gt;
&lt;p&gt;那么问题就来了，面对一个一无所知的复杂的系统，我们该如何入手呢？&lt;/p&gt;
&lt;p&gt;本文将结合菜菜同学多年来的沉（经）淀（验），再融合老中医望闻问切的招式，吐血整理成一剂锦囊妙药和一副图，送给大家。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;《一剂良药》&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;「菊花」&lt;/strong&gt;看文档，记疑惑。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;「薄荷」&lt;/strong&gt;串文档，理脉络。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;「莲心」&lt;/strong&gt;讲系统，要知彼。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;「荷叶」&lt;/strong&gt;捋代码，了梗概。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;「&lt;strong&gt;玄参&lt;/strong&gt;」盘经验，理大坑。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;「&lt;strong&gt;芦根&lt;/strong&gt;」亲操刀，细解剖。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;《一幅图》&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1514436/202011/1514436-20201108070655220-1873287376.png&quot; alt=&quot;&quot; width=&quot;742&quot; height=&quot;504&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;老中医：望。望诊，是对病人的神、色、形、态、舌象等进行有目的的观察，以测知内脏病变。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;菜菜同学结合「望诊」而独创快速接手一个复杂系统之&lt;strong&gt;招式一：看文档，知脉略&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;当一个复杂的系统要交接到你手上时，理想中各种文档样样全，要啥有啥，而现实啪啪打脸。多数情况下都没有文档，如果有一些文档可看，无论质量如何，都是一件值得庆幸的事情。&lt;/p&gt;
&lt;p&gt;如果项目组比较规范，沉淀了一些入门文档、产品介绍文档、业务架构设计文档、数据库设计文档，那就更值得庆幸啦，静下来仔细去看，通过文档多少会了解一些系统的前世今生，对系统有一个初步的认识。&lt;/p&gt;
&lt;p&gt;不过，当接手一个系统时，一定要看看文档在哪里？是在 Wiki 上，还是在 SVN、Git 上，如若有文档的情况下，尽快找到它，并粗略的看一遍。&lt;/p&gt;
&lt;p&gt;看了这么多文档，肯定有太多的疑惑，先拿小本本记下来，制造机会请老鸟给你答疑解惑。 &lt;/p&gt;

&lt;p&gt;&lt;span&gt;老中医：闻。闻诊，主要是听患者语言气息的高低、强弱、清浊、缓急……等变化，以分辨病情的虚实寒热。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;菜菜同学结合「闻诊」而独创快速接手一个复杂系统之&lt;strong&gt;招式二：听细节，聊全局。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;拿着你事先记录好满满疑惑的小本本，组个会议，喊上老鸟好好给你指点迷津。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;首先，请老鸟串一串文档。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;大概理一理，然后把你之前小本本上的问题，一股脑抛出来当面请教。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;然后，请老鸟讲一讲系统。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;大概要了解一下系统的使用方是谁？系统依赖的系统有哪些？系统主要干系人有哪些？系统研发的需求来自于哪里？最重要的是要请老鸟演示一下如何把系统跑起来？跑起来后功能该怎么用？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;最后，请老鸟捋一捋代码。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;大概捋一捋代码的设计，了解一下主要分为几大块？程序入口在哪里？技术栈是啥样子？... ...&lt;/p&gt;

&lt;p&gt;&lt;span&gt;老中医：问。问诊，通过了解既往病史与家族病史、起病原因、发病经过及治疗过程，主要痛苦所在，自觉症状，饮食喜恶等情况，结合望、切、闻三诊，综合分析，作出判断。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;菜菜同学结合「问诊」而独创快速接手一个复杂系统之&lt;strong&gt;招式三：问疑难，解杂症。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;首先，问老鸟：要接手的系统，历史事故都发生过哪些？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了不贰过，要了解一下要接手的系统，历史的事故是代码问题，还是人祸导致的？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;最后，问老鸟：要接手的系统，坑在哪里？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;大概了解一下老鸟以往趟过的那些坑，前车之鉴必是后车之师。重点了解系统有哪块会有潜在的问题，当接手之后一定要细心着重对待，防患于未然。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;老中医：切。切脉又称诊脉，是医者用手指按其腕后桡动脉搏动处，借以体察脉象变化，辨别脏腑功能盛衰，气血津精虚滞的一种方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;菜菜同学结合「切诊」而独创快速接手一个复杂系统之&lt;strong&gt;招式四：亲操刀，细解剖。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过前面三种招式相结合，我们文档也看了，系统功能也了解了，历史事故也知道了，接下来要进入程序员最擅长区域——解剖代码。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;首先，加注释，加关键日志。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;找到程序入口，根据自己的理解，一步一步去加注释，要敢于动手去加，确定不了的，有疑问的用注释标记好，或者记个大大的问号，把你的想法理解都用注释记录一下，相信对代码的理解，一遍比一遍更透彻。&lt;/p&gt;
&lt;p&gt;当然，除了加注释的一种方式，还推荐加关键日志，因为加入关键日志，不过日志最好有一些特色，例如都还有「haha：」，这样能够在子模块调用比较复杂的情形下，在项目启动后，根据加入日志文件，直接关注「haha：」就能把相关子系统的调用流程串在一起，屡试不爽。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;然后，跑应用，Debug。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;除了加注释，加关键日志能够理解代码逻辑外，Debug 也是推荐的一种方式，从程序入口开始逐步进行调试，也会对代码有一个质的理解。&lt;/p&gt;
&lt;p&gt;仁者见仁智者见智，依据个人习惯，还是更推荐加日志，或许是因为 Debug 有些时候遇到反射或者库调用，跟着跟着就乱掉了。&lt;/p&gt;
&lt;p&gt;在这里，建议一定要把应用跑起来，只有跑起来，才能根据之前加入的日志，梳理梳理系统调用关系，模块调用关系，再好好体验体验功能。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;最后，画画图，善分享。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;加日志、加注释、Debug 的事儿多数铁子都干过，但是能把自己对代码的理解真心画下来的估计会很少，这块真心推荐大家没事的时候静下来画一画，是对代码理解质的一次提升，画出来才能理解的更透彻，更清晰，如果闲暇之余把上手系统的经过写成手册，相信对于后面接手的同事而言是一大笔“财富”。&lt;/p&gt;
&lt;p&gt;当然了，除了画图、写手册还是不够的，重要的是能够拉几个同事进行分享一下，这样才能更快变成自己的知识，在这里忍不住要抛一张图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1514436/202011/1514436-20201108071145619-470723322.png&quot; alt=&quot;&quot; width=&quot;759&quot; height=&quot;535&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;另外，接手系统解剖代码这块放到最后一部分去谈，原因这块确实考验个人的技术能力，而且是一个长久的过程，需要慢慢去磨。&lt;/p&gt;

&lt;p&gt;本次主要谈谈如何快速接手一个系统？吐血推荐的一幅图和一剂药，如果有接手系统的困惑，而且没有更好的方法时，那不妨拿去实践，屡试不爽。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;前路漫长，人生实苦，每个人方法都不一样，条条大路通罗马，选择适合自己的。奔跑是追梦人的气质，用奋斗定义人生价值，在奔跑中抵达远方，铁子们加油💪。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;好了，分享就到这里，希望对你有帮助。&lt;strong&gt;一起聊技术、谈业务、喷架构，少走弯路，不踩大坑。&lt;/strong&gt;会持续输出原创精彩分享，敬请期待！&lt;/p&gt;
</description>
<pubDate>Sat, 07 Nov 2020 23:19:00 +0000</pubDate>
<dc:creator>一猿小讲</dc:creator>
<og:description>如何接手一个复杂的系统？ 作为程序员，无论是小菜还是老鸟，都会因为离职交接或者岗位异动等各种原因，而避免不了要如羚羊奔跑版的速度接手一个复杂业务系统。因为只有尽快熟悉系统，方能够快速支持业务需求的研发</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/socoool/p/13943349.html</dc:identifier>
</item>
<item>
<title>ts流中的pcr与pts计算与逆运算 - OnlyTime_唯有时光</title>
<link>http://www.cnblogs.com/Dreaming-in-Gottingen/p/13943202.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Dreaming-in-Gottingen/p/13943202.html</guid>
<description>&lt;p&gt;　　mpeg2ts文件格式中有pcr和pts的概念，其代码含义如下：&lt;/p&gt;
&lt;p&gt;　　&lt;em&gt;PCR(Program Clock Reference)——指示系统时钟本身的瞬时值的时间标签称为节目参考时钟标签(PCR)。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;　　PTS(Presentation Time Stamp)——&lt;/em&gt;&lt;em&gt;指示音视频显示时间的时间戳称为显示时间戳(PTS)。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　二者的更具体含义可以网上查找资料，本博文的重点不再于此。本博文主题为：利用编码帧bitstream所携带的时间戳，如何换算出ts文件中的pcr和pts值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1. 一段典型的音视频ts数据包：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;AAC:&lt;/strong&gt;&lt;/span&gt; 47 41 E1 3F 07 10 &lt;strong&gt;&lt;span&gt;00 F9 F2 B6 FE B3&lt;/span&gt;&lt;/strong&gt; 00 00 01 C0 01 6A 84 80 05 &lt;strong&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;1 07 CF CA DB&lt;/span&gt;&lt;/strong&gt; 。。。(bitstream)。。。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;AVC:&lt;/strong&gt;&lt;/span&gt; 47 41 E2 3D 07 10 &lt;strong&gt;&lt;span&gt;00 F9 F2 B6 FE B3&lt;/span&gt;&lt;/strong&gt; 00 00 01 E0 98 65 84 80 05 &lt;span&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;1 07 CF CA DB&lt;/strong&gt;&lt;/span&gt; 。。。(bitstream)。。。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;&lt;span&gt;红色&lt;/span&gt;&lt;/strong&gt;的&lt;strong&gt;六个字节&lt;/strong&gt;为pcr值（188Bytes的TS数据包的第7个字节），&lt;strong&gt;&lt;span&gt;粉红色&lt;/span&gt;&lt;/strong&gt;的&lt;strong&gt;五个半字节&lt;/strong&gt;为pts值（头的尾部，后面直接跟编码数据）。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2. pcr及pts算法介绍（pcr_val(48b)和pts[32..30..0](33b)）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　两段典型的示例如下：&lt;/p&gt;
&lt;p&gt;　　时间戳为00:06:04.013（timsUs=364013000）的一帧数据，其pcr的值：&lt;span&gt;00 F9 F2 A9 7E 0D&lt;/span&gt; ，其pts[32...0]值为：&lt;span&gt;21 07 CF CA A5&lt;/span&gt;&lt;br/&gt;　　时间戳为00:06:04.034（timsUs=364034000）的一帧数据，其pcr的值：&lt;span&gt;00 F9 F6 59 FE CF&lt;/span&gt; ，其pts[32...0]值为：&lt;span&gt;21 07 CF D9 69&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　其中，编码模块送给封装模块（Android中为MPEG2TSWriter）的编码帧所携带的时间戳并不是“00:06:04.013”形式，而是一个long long型的整数，单位为微秒，例如364013000（代表364.013秒），换算成人容易识别的格式（hh:mm:ss）为：00:06:04.013。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　注意，ts在封装时，标准规定了pcr值和pts各个位如何排布（参考下面的pcr_val和pts_val数组，即符合spec规定）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3. timeUs和pcr之间转换&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;正向运算：timeUs -&amp;gt; pcr （用于封装）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　float tmp = timeUs / 1000000 + (timeUs % 1000000) / 1000 * 0.001; //timeUs以us为单位，tmp以s为单位，即换算成xy.z格式（小数点放在倒数第六个字节前），xy为秒值，z为毫秒值&lt;br/&gt;　　　　long long pcr = (long long)(tmp * 27000000.0);&lt;br/&gt;　　　　long long pcr_low = pcr % 300LL;&lt;/p&gt;
&lt;p&gt;　　　　long long pcr_high = pcr / 300LL;&lt;/p&gt;
&lt;p&gt;　　　　&lt;span&gt;unsigned char pcr_val[6]; 　　&lt;span&gt;// 待写到ts文件中pcr位置的6个字节值&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　pcr_val[0] = pcr_high&amp;gt;&amp;gt;25;&lt;br/&gt;　　　　pcr_val[1] = pcr_high&amp;gt;&amp;gt;17;&lt;br/&gt;　　　　pcr_val[2] = pcr_high&amp;gt;&amp;gt;9;&lt;br/&gt;　　　　pcr_val[3] = pcr_high&amp;gt;&amp;gt;1;&lt;br/&gt;　　　　pcr_val[4] = pcr_high&amp;lt;&amp;lt;7 | pcr_low&amp;gt;&amp;gt;8 | 0x7e;&lt;br/&gt;　　　　pcr_val[5] = pcr_low;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;　　逆向运算：pcr -&amp;gt; timeUs （用于解封装时获取时间戳，由已知ts文件算出音视频帧的时间戳）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　long long PCR_LOW = pcr_val[5] + ((pcr_val[4]&amp;amp;0x1)&amp;lt;&amp;lt;8);&lt;br/&gt;　　　　long long PCR_HIGH = (pcr_val[4]&amp;gt;&amp;gt;7) + (pcr_val[3]&amp;lt;&amp;lt;1) + (pcr_val[2]&amp;lt;&amp;lt;9) + (pcr_val[1]&amp;lt;&amp;lt;17) + (pcr_val[0]&amp;lt;&amp;lt;25);&lt;br/&gt;　　　　long long PCR = PCR_HIGH * 300 + PCR_LOW;&lt;br/&gt;　　　　float TMS = PCR / 27000000.0;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;4. timeUs和pts之间的转换&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　正向运算：timeUs -&amp;gt; pts&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　long long pts = timeUs * 9LL / 100LL;&lt;br/&gt;　　　　unsigned char pts_val[5];&lt;br/&gt;　　　　pts_val[0] = 0x20 | (((pts &amp;gt;&amp;gt; 30) &amp;amp; 7) &amp;lt;&amp;lt; 1) | 1;  　  // 3bits&lt;br/&gt;　　　　pts_val[1] = (pts &amp;gt;&amp;gt; 22) &amp;amp; 0xff;　　　　　　　　　// 8bits&lt;br/&gt;　　　　pts_val[2] = (((pts &amp;gt;&amp;gt; 15) &amp;amp; 0x7f) &amp;lt;&amp;lt; 1) | 1;　　　   // 7bits&lt;br/&gt;　　　　pts_val[3] = (pts &amp;gt;&amp;gt; 7) &amp;amp; 0xff;　　　　　　　　　  // 8bits&lt;br/&gt;　　　　pts_val[4] = ((pts &amp;amp; 0x7f) &amp;lt;&amp;lt; 1) | 1;　　　　　　　 // 7bits&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　逆向运算：pts -&amp;gt; timeUs&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　long long PTS = (pts_val[4]&amp;gt;&amp;gt;1) | (pts_val[3]&amp;lt;&amp;lt;7) | (pts_val[2]&amp;gt;&amp;gt;1)&amp;lt;&amp;lt;15 | pts_val[1]&amp;lt;&amp;lt;22 | (pts_val[0]&amp;gt;&amp;gt;1)&amp;lt;&amp;lt;30;&lt;br/&gt;　　　　long long TIMEUS = PTS * 100LL / 9LL;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;5. 完整demo演示&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_894cf010-81ae-4833-add7-1c0331e82d58&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_894cf010-81ae-4833-add7-1c0331e82d58&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_894cf010-81ae-4833-add7-1c0331e82d58&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;101&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; #include &amp;lt;stdio.h&amp;gt;
&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; timeUs = &lt;span&gt;364034000&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;float&lt;/span&gt; tm = timeUs / &lt;span&gt;1000000&lt;/span&gt; + (timeUs % &lt;span&gt;1000000&lt;/span&gt;) / &lt;span&gt;1000&lt;/span&gt; * &lt;span&gt;0.001&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; pcr = (&lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;)(tm * &lt;span&gt;27000000.0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; pcr_low = pcr %&lt;span&gt; 300LL;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; pcr_high = pcr /&lt;span&gt; 300LL;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;     unsigned &lt;span&gt;char&lt;/span&gt; pcr_val[&lt;span&gt;6&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     pcr_val[&lt;span&gt;0&lt;/span&gt;] = pcr_high&amp;gt;&amp;gt;&lt;span&gt;25&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     pcr_val[&lt;span&gt;1&lt;/span&gt;] = pcr_high&amp;gt;&amp;gt;&lt;span&gt;17&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     pcr_val[&lt;span&gt;2&lt;/span&gt;] = pcr_high&amp;gt;&amp;gt;&lt;span&gt;9&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     pcr_val[&lt;span&gt;3&lt;/span&gt;] = pcr_high&amp;gt;&amp;gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     pcr_val[&lt;span&gt;4&lt;/span&gt;] = pcr_high&amp;lt;&amp;lt;&lt;span&gt;7&lt;/span&gt; | pcr_low&amp;gt;&amp;gt;&lt;span&gt;8&lt;/span&gt; | &lt;span&gt;0x7e&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     pcr_val[&lt;span&gt;5&lt;/span&gt;] =&lt;span&gt; pcr_low;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;calculate pcr by timeUs!\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;    timeUs=%lld us, tm=%f s\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, timeUs, tm);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;    pcr=%llx, pcr_low=%#llx, pcr_high=%#llx\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, pcr, pcr_low, pcr_high);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;    pcr_val[0-5]: %#x, %#x, %#x, %#x, %#x, %#x\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, pcr_val[&lt;span&gt;0&lt;/span&gt;], pcr_val[&lt;span&gt;1&lt;/span&gt;], pcr_val[&lt;span&gt;2&lt;/span&gt;], pcr_val[&lt;span&gt;3&lt;/span&gt;], pcr_val[&lt;span&gt;4&lt;/span&gt;], pcr_val[&lt;span&gt;5&lt;/span&gt;&lt;span&gt;]);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; PCR_LOW = pcr_val[&lt;span&gt;5&lt;/span&gt;] + ((pcr_val[&lt;span&gt;4&lt;/span&gt;]&amp;amp;&lt;span&gt;0x1&lt;/span&gt;)&amp;lt;&amp;lt;&lt;span&gt;8&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; PCR_HIGH = (pcr_val[&lt;span&gt;4&lt;/span&gt;]&amp;gt;&amp;gt;&lt;span&gt;7&lt;/span&gt;) + (pcr_val[&lt;span&gt;3&lt;/span&gt;]&amp;lt;&amp;lt;&lt;span&gt;1&lt;/span&gt;) + (pcr_val[&lt;span&gt;2&lt;/span&gt;]&amp;lt;&amp;lt;&lt;span&gt;9&lt;/span&gt;) + (pcr_val[&lt;span&gt;1&lt;/span&gt;]&amp;lt;&amp;lt;&lt;span&gt;17&lt;/span&gt;) + (pcr_val[&lt;span&gt;0&lt;/span&gt;]&amp;lt;&amp;lt;&lt;span&gt;25&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; PCR = PCR_HIGH * &lt;span&gt;300&lt;/span&gt; +&lt;span&gt; PCR_LOW;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;float&lt;/span&gt; TMS = PCR / &lt;span&gt;27000000.0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;revert test by pcr_val[0-5]!\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;    PCR_LOW=%#llx, PCR_HIGH=%#llx, PCR=%#llx, TMS=%f s\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, PCR_LOW, PCR_HIGH, PCR, TMS);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt;     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;---------------------------------------------------------------------------\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;calculate pts by timeUs!\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;     &lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; pts = timeUs * 9LL /&lt;span&gt; 100LL;
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;     unsigned &lt;span&gt;char&lt;/span&gt; pts_val[&lt;span&gt;5&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;     pts_val[&lt;span&gt;0&lt;/span&gt;] = &lt;span&gt;0x20&lt;/span&gt; | (((pts &amp;gt;&amp;gt; &lt;span&gt;30&lt;/span&gt;) &amp;amp; &lt;span&gt;7&lt;/span&gt;) &amp;lt;&amp;lt; &lt;span&gt;1&lt;/span&gt;) | &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;     pts_val[&lt;span&gt;1&lt;/span&gt;] = (pts &amp;gt;&amp;gt; &lt;span&gt;22&lt;/span&gt;) &amp;amp; &lt;span&gt;0xff&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;     pts_val[&lt;span&gt;2&lt;/span&gt;] = (((pts &amp;gt;&amp;gt; &lt;span&gt;15&lt;/span&gt;) &amp;amp; &lt;span&gt;0x7f&lt;/span&gt;) &amp;lt;&amp;lt; &lt;span&gt;1&lt;/span&gt;) | &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;     pts_val[&lt;span&gt;3&lt;/span&gt;] = (pts &amp;gt;&amp;gt; &lt;span&gt;7&lt;/span&gt;) &amp;amp; &lt;span&gt;0xff&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;     pts_val[&lt;span&gt;4&lt;/span&gt;] = ((pts &amp;amp; &lt;span&gt;0x7f&lt;/span&gt;) &amp;lt;&amp;lt; &lt;span&gt;1&lt;/span&gt;) | &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;    pts_val[0-4]: %#x, %#x, %#x, %#x, %#x\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, pts_val[&lt;span&gt;0&lt;/span&gt;], pts_val[&lt;span&gt;1&lt;/span&gt;], pts_val[&lt;span&gt;2&lt;/span&gt;], pts_val[&lt;span&gt;3&lt;/span&gt;], pts_val[&lt;span&gt;4&lt;/span&gt;&lt;span&gt;]);
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; 
&lt;span&gt;42&lt;/span&gt;     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;revert test by pts_val[0-4]!\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;     &lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; PTS = (pts_val[&lt;span&gt;4&lt;/span&gt;]&amp;gt;&amp;gt;&lt;span&gt;1&lt;/span&gt;) | (pts_val[&lt;span&gt;3&lt;/span&gt;]&amp;lt;&amp;lt;&lt;span&gt;7&lt;/span&gt;) | (pts_val[&lt;span&gt;2&lt;/span&gt;]&amp;gt;&amp;gt;&lt;span&gt;1&lt;/span&gt;)&amp;lt;&amp;lt;&lt;span&gt;15&lt;/span&gt; | pts_val[&lt;span&gt;1&lt;/span&gt;]&amp;lt;&amp;lt;&lt;span&gt;22&lt;/span&gt; | (pts_val[&lt;span&gt;0&lt;/span&gt;]&amp;gt;&amp;gt;&lt;span&gt;1&lt;/span&gt;)&amp;lt;&amp;lt;&lt;span&gt;30&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;     &lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; TIMEUS = PTS * 100LL /&lt;span&gt; 9LL;
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;    PTS=%lld, TIMEUS=%lld\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, PTS, TIMEUS);
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; 
&lt;span&gt;47&lt;/span&gt;     &lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; PTS_VAL = (1LL * pts_val[&lt;span&gt;0&lt;/span&gt;]&amp;lt;&amp;lt;&lt;span&gt;32&lt;/span&gt;) + (1LL * pts_val[&lt;span&gt;1&lt;/span&gt;]&amp;lt;&amp;lt;&lt;span&gt;24&lt;/span&gt;) + (1LL * pts_val[&lt;span&gt;2&lt;/span&gt;]&amp;lt;&amp;lt;&lt;span&gt;16&lt;/span&gt;) + (1LL * pts_val[&lt;span&gt;3&lt;/span&gt;]&amp;lt;&amp;lt;&lt;span&gt;8&lt;/span&gt;) + (1LL * pts_val[&lt;span&gt;4&lt;/span&gt;&lt;span&gt;]);
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;     &lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; PTS1 = ((PTS_VAL&amp;gt;&amp;gt;&lt;span&gt;1&lt;/span&gt;)&amp;amp;&lt;span&gt;0x7f&lt;/span&gt;) | ((PTS_VAL&amp;gt;&amp;gt;&lt;span&gt;8&lt;/span&gt;)&amp;amp;&lt;span&gt;0xff&lt;/span&gt;)&amp;lt;&amp;lt;&lt;span&gt;7&lt;/span&gt; | ((PTS_VAL&amp;gt;&amp;gt;(&lt;span&gt;16&lt;/span&gt;+&lt;span&gt;1&lt;/span&gt;))&amp;amp;&lt;span&gt;0x7f&lt;/span&gt;)&amp;lt;&amp;lt;&lt;span&gt;15&lt;/span&gt; | ((PTS_VAL&amp;gt;&amp;gt;&lt;span&gt;24&lt;/span&gt;)&amp;amp;&lt;span&gt;0xff&lt;/span&gt;)&amp;lt;&amp;lt;&lt;span&gt;22&lt;/span&gt; | ((PTS_VAL&amp;gt;&amp;gt;(&lt;span&gt;32&lt;/span&gt;+&lt;span&gt;1&lt;/span&gt;))&amp;amp;&lt;span&gt;7&lt;/span&gt;)&amp;lt;&amp;lt;&lt;span&gt;30&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;     &lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; TIMEUS1 = PTS1 * 100LL /&lt;span&gt; 9LL;
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;    PTS1=%lld, TIMEUS1=%lld\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, PTS1, TIMEUS1);
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; 
&lt;span&gt;52&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　运行结果：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/1770222/202011/1770222-20201108010958478-295041317.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt; 6. 延伸&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　ts文件中音视频帧的最大时间戳是多少？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　当最大时，即意味着pts处或pcr处的二进制位值都为1。&lt;/p&gt;
&lt;p&gt;　　由于pts为33bit宽，则其最大值为：0x1 FF FF FF FF（对应文件中pcr_val[]为：0x2F FF FF FF FF），算得timeUs=pts_max * 100L / 9LL =  95443717666 us = 95443 s = 26.5h&lt;/p&gt;
&lt;p&gt;　　即，从timeUs从0开始，到1天再过2.5h后，就会发生时间戳溢出。&lt;/p&gt;



</description>
<pubDate>Sat, 07 Nov 2020 17:18:00 +0000</pubDate>
<dc:creator>OnlyTime_唯有时光</dc:creator>
<og:description>mpeg2ts文件格式中有pcr和pts的概念，其代码含义如下： PCR(Program Clock Reference)——指示系统时钟本身的瞬时值的时间标签称为节目参考时钟标签(PCR)。 PTS</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Dreaming-in-Gottingen/p/13943202.html</dc:identifier>
</item>
<item>
<title>Codeforce算法题 | 你能想出解法，让你的基友少氪金吗？ - RioTian</title>
<link>http://www.cnblogs.com/RioTian/p/13943050.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/RioTian/p/13943050.html</guid>
<description>&lt;p&gt;在TechFlow学长的公众号里发现一道挺有意思的CF算法题，现在利用学长的思路学习一下&lt;/p&gt;
&lt;p&gt;题目链接：&lt;a href=&quot;https://codeforces.com/contest/1418/problem/C&quot;&gt;https://codeforces.com/contest/1418/problem/C&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;题意&quot;&gt;&lt;strong&gt;题意&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;这道题的题意也很有意思，背景也是游戏。说是有一天你和你的基友一起在家打游戏，这个游戏一共有n个boss。这些boss的难度不同，有些boss简单，有些boss困难。你的技术要比基友的好一些，你们两人轮流打boss。&lt;/p&gt;
&lt;p&gt;游戏规定每次进行游戏最少打1个boss，最多打两个boss。由于你的实力更好，你可以战胜所有的boss。但是你的基友比较菜，只能打得过简单的boss，如果碰上hard模式的boss就只能氪金。基友的钱也是钱，你们希望在&lt;strong&gt;尽量少氪金&lt;/strong&gt;的前提下把游戏通关。现在已知所有boss的难易情况并且基友先开始游戏，请问在最佳策略下，最少需要氪金多少次？&lt;/p&gt;
&lt;h3 id=&quot;样例&quot;&gt;&lt;strong&gt;样例&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;首先给定一个数字t，表示测试数据组数。对于每组数据，给定一个数字n，表示boss的数量。接着给定n个0或者1的整数，0表示boss是简单模式，1表示是困难模式。要求返回一个数字，即最少的氪金次数。其中&lt;/p&gt;
&lt;p&gt;\[n≤2⋅10^5 \]&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;input: 
8
1 0 1 1 0 1 1 1

output:
2
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;样例解释&quot;&gt;样例解释&lt;/h4&gt;
&lt;p&gt;基友先杀1和2两个boss，氪金一次。&lt;/p&gt;
&lt;p&gt;“我”杀3和4号boss&lt;/p&gt;
&lt;p&gt;基友杀5号boss&lt;/p&gt;
&lt;p&gt;“我”杀6和7号boss&lt;/p&gt;
&lt;p&gt;基友击杀8号boss，氪金一次，总共氪金两次。&lt;/p&gt;
&lt;h3 id=&quot;题解&quot;&gt;&lt;strong&gt;题解&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;这道题我们最先想到的可能就是贪心，比如我们可以想到一种贪心策略，就是每次基友杀怪的时候先杀1个，然后看第二个是0还是1，如果是0的则一起杀了，否则不杀留给“我”。&lt;/p&gt;
&lt;p&gt;我们可以用之前介绍过的等价判断法来判断一下这个贪心策略可不可行，对于这道题而言，贪心的本质是让氪金的次数最少。所以当基友的第二个怪是0的时候，杀和不杀对于当前的氪金次数来说是没有影响的。但是&lt;strong&gt;对于后面的局面是会有影响&lt;/strong&gt;的，并且可能会出现不同的结果。&lt;/p&gt;
&lt;p&gt;比如我们可以找到一个例子10011，基友杀不杀第二个怪，直接影响后面的结果。如果基友杀了，那么不论“我”怎么选，基友都必须要至少再氪金一次。如果基友不杀，那么“我”杀第二个怪，基友再杀第三个怪，最后两个boss都交给“我”，那么基友全局只需要氪金一次。所以贪心算法不可行。&lt;/p&gt;
&lt;h4 id=&quot;动态规划&quot;&gt;&lt;strong&gt;动态规划&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;如果你熟悉动态规划的话，那么几乎可以发现这是一道经典的&lt;strong&gt;动态规划&lt;/strong&gt;问题。对于每一个怪来说，它都有两种状态，分别是被基友杀或者是被“我”杀。我们用0和1来分别表示，0表示被基友杀，1表示被“我”杀。一共有n个怪，所以我们可以用一个n * 2的数组来记录所有怪的状态。&lt;/p&gt;
&lt;p&gt;对于第i个怪而言，如果它是被“我”杀的，那么它可以由基友杀了i-1或者是i-2个怪的状态转移得到。比如如果从基友杀了i-1转移得到，说明“我”杀了i，否则说明“我”不仅杀了i，还杀了i-1。同理i被基友杀的情况也是一样，所以这个状态转移方程就非常明显了。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# 学长的Python解法，注释满满
import sys

t = int(input())

for _ in range(t):
    n = int(input())
    arr = list(map(int, input().split(' ')))
    dp = [[sys.maxsize, sys.maxsize] for _ in range(n+2)]

    dp[0][1] = 0

    for i in range(1, n+1):
        if i &amp;gt; 1:
            # 如果i &amp;gt; 1，那么说明可以杀两个
            # 0表示基友杀怪的情况，基友可以杀1个从i-1转移得到，也可以杀2个从i-2转移得到
            # 需要加上氪金的次数
            dp[i][0] = min(dp[i-1][1] + arr[i-1], dp[i-2][1] + arr[i-2] + arr[i-1])
            # 我杀怪不用氪金，直接赋值即可
            dp[i][1] = min(dp[i-1][0], dp[i-2][0])
        else:
            # i=1，那么只能杀一个
            dp[i][0] = dp[i-1][1] + arr[i-1]
            dp[i][1] = dp[i-1][0]

    print(min(dp[n][0], dp[n][1]))
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;// 蒟蒻C++解法
// Author : RioTian
// Time : 20/11/07
#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
typedef long long ll;
const int N = 1e5 + 10;
int main() {
    // freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);
    ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
    int t;
    cin &amp;gt;&amp;gt; t;
    while (t--) {
        int n;
        cin &amp;gt;&amp;gt; n;
        int x, ans = 0, sum = 0;
        n--;
        cin &amp;gt;&amp;gt; ans;
        while (n--) {
            cin &amp;gt;&amp;gt; x;
            if (x)
                sum++;
            else
                ans += sum / 3, sum = 0;
        }
        cout &amp;lt;&amp;lt; ans + sum / 3 &amp;lt;&amp;lt; endl;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后，这道题非常的基础，可以说是动态规划的基础问题了。如果对动态规划这个概念不是很熟悉的话，非常建议动手做一做，加深一下印象。&lt;/p&gt;
</description>
<pubDate>Sat, 07 Nov 2020 15:58:00 +0000</pubDate>
<dc:creator>RioTian</dc:creator>
<og:description>在TechFlow学长的公众号里发现一道挺有意思的CF算法题，现在利用学长的思路学习一下 题目链接：https://codeforces.com/contest/1418/problem/C 题意 这</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/RioTian/p/13943050.html</dc:identifier>
</item>
<item>
<title>【原创】Linux虚拟化KVM-Qemu分析（五）之内存虚拟化 - LoyenWang</title>
<link>http://www.cnblogs.com/LoyenWang/p/13943005.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/LoyenWang/p/13943005.html</guid>
<description>&lt;ul&gt;&lt;li&gt;&lt;code&gt;Read the fucking source code!&lt;/code&gt; --By 鲁迅&lt;/li&gt;
&lt;li&gt;&lt;code&gt;A picture is worth a thousand words.&lt;/code&gt; --By 高尔基&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;说明：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;KVM版本：5.9.1&lt;/li&gt;
&lt;li&gt;QEMU版本：5.0.0&lt;/li&gt;
&lt;li&gt;工具：Source Insight 3.5， Visio&lt;/li&gt;
&lt;li&gt;文章同步在博客园：&lt;code&gt;https://www.cnblogs.com/LoyenWang/&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;《Linux虚拟化KVM-Qemu分析（二）之ARMv8虚拟化》&lt;/code&gt;文中描述过内存虚拟化大体框架，再来回顾一下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;非虚拟化下的内存的访问&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1771657/202011/1771657-20201107233823163-1248765431.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;CPU访问物理内存前，需要先建立页表映射（虚拟地址到物理地址的映射），最终通过查表的方式来完成访问。在ARMv8中，内核页表基地址存放在&lt;code&gt;TTBR1_EL1&lt;/code&gt;中，用户空间页表基地址存放在&lt;code&gt;TTBR0_EL0&lt;/code&gt;中；&lt;/li&gt;
&lt;/ul&gt;&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;虚拟化下的内存访问&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1771657/202011/1771657-20201107233831393-633851095.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;虚拟化情况下，内存的访问会分为两个&lt;code&gt;Stage&lt;/code&gt;，&lt;code&gt;Hypervisor&lt;/code&gt;通过&lt;code&gt;Stage 2&lt;/code&gt;来控制虚拟机的内存视图，控制虚拟机是否可以访问某块物理内存，进而达到隔离的目的；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Stage 1&lt;/code&gt;：&lt;code&gt;VA(Virtual Address)-&amp;gt;IPA(Intermediate Physical Address)&lt;/code&gt;，Host的操作系统控制&lt;code&gt;Stage 1&lt;/code&gt;的转换；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Stage 2&lt;/code&gt;：&lt;code&gt;IPA(Intermediate Physical Address)-&amp;gt;PA(Physical Address)&lt;/code&gt;，Hypervisor控制&lt;code&gt;Stage 2&lt;/code&gt;的转换；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;猛一看上边两个图，好像明白了啥，仔细一想，啥也不明白，本文的目标就是将这个过程讲明白。&lt;/p&gt;
&lt;p&gt;在开始细节讲解之前，需要先描述几个概念：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;gva - guest virtual address
gpa - guest physical address
hva - host virtual address
hpa - host physical address
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1771657/202011/1771657-20201107233844101-140556043.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Guest OS中的虚拟地址到物理地址的映射，就是典型的常规操作，参考之前的内存管理模块系列文章；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;铺垫了这么久，来到了本文的两个主题：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;GPA-&amp;gt;HVA&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;HVA-&amp;gt;HPA&lt;/code&gt;;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;开始吧！&lt;/p&gt;

&lt;p&gt;还记得上一篇文章&lt;code&gt;《Linux虚拟化KVM-Qemu分析（四）之CPU虚拟化（2）》&lt;/code&gt;中的Sample Code吗？&lt;br/&gt;KVM-Qemu方案中，GPA-&amp;gt;HVA的转换，是通过&lt;code&gt;ioctl&lt;/code&gt;中的&lt;code&gt;KVM_SET_USER_MEMORY_REGION&lt;/code&gt;命令来实现的，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1771657/202011/1771657-20201107233855813-554323553.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;找到了入口，让我们进一步揭开神秘的面纱。&lt;/p&gt;
&lt;h2 id=&quot;21-数据结构&quot;&gt;2.1 数据结构&lt;/h2&gt;
&lt;p&gt;关键的数据结构如下：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1771657/202011/1771657-20201107233904748-592916078.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;虚拟机使用&lt;code&gt;slot&lt;/code&gt;来组织物理内存，每个&lt;code&gt;slot&lt;/code&gt;对应一个&lt;code&gt;struct kvm_memory_slot&lt;/code&gt;，一个虚拟机的所有&lt;code&gt;slot&lt;/code&gt;构成了它的物理地址空间；&lt;/li&gt;
&lt;li&gt;用户态使用&lt;code&gt;struct kvm_userspace_memory_region&lt;/code&gt;来设置内存&lt;code&gt;slot&lt;/code&gt;，在内核中使用&lt;code&gt;struct kvm_memslots&lt;/code&gt;结构来将&lt;code&gt;kvm_memory_slot&lt;/code&gt;组织起来；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;struct kvm_userspace_memory_region&lt;/code&gt;结构体中，包含了&lt;code&gt;slot&lt;/code&gt;的ID号用于查找对应的&lt;code&gt;slot&lt;/code&gt;，此外还包含了物理内存起始地址及大小，以及HVA地址，HVA地址是在用户进程地址空间中分配的，也就是Qemu进程地址空间中的一段区域；&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;22-流程分析&quot;&gt;2.2 流程分析&lt;/h2&gt;
&lt;p&gt;数据结构部分已经罗列了大体的关系，那么在&lt;code&gt;KVM_SET_USER_MEMORY_REGION&lt;/code&gt;时，围绕的操作就是&lt;code&gt;slots&lt;/code&gt;的创建、删除，更新等操作，话不多说，来图了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1771657/202011/1771657-20201107233915050-1368514616.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当用户要设置内存区域时，最终会调用到&lt;code&gt;__kvm_set_memory_region&lt;/code&gt;函数，在该函数中完成所有的逻辑处理；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;__kvm_set_memory_region&lt;/code&gt;函数，首先会对传入的&lt;code&gt;struct kvm_userspace_memory_region&lt;/code&gt;的各个字段进行合法性检测判断，主要是包括了地址的对齐，范围的检测等；&lt;/li&gt;
&lt;li&gt;根据用户传递的&lt;code&gt;slot&lt;/code&gt;索引号，去查找虚拟机中对应的&lt;code&gt;slot&lt;/code&gt;，查找的结果只有两种：1）找到一个现有的slot；2）找不到则新建一个slot；&lt;/li&gt;
&lt;li&gt;如果传入的参数中&lt;code&gt;memory_size&lt;/code&gt;为0，那么会将对应&lt;code&gt;slot&lt;/code&gt;进行删除操作；&lt;/li&gt;
&lt;li&gt;根据用户传入的参数，设置&lt;code&gt;slot&lt;/code&gt;的处理方式：&lt;code&gt;KVM_MR_CREATE&lt;/code&gt;，&lt;code&gt;KVM_MR_MOVE&lt;/code&gt;，&lt;code&gt;KVM_MEM_READONLY&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;根据用户传递的参数决定是否需要分配脏页的bitmap，标识页是否可用；&lt;/li&gt;
&lt;li&gt;最终调用&lt;code&gt;kvm_set_memslot&lt;/code&gt;来设置和更新&lt;code&gt;slot&lt;/code&gt;信息；&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;221-kvm_set_memslot&quot;&gt;2.2.1 kvm_set_memslot&lt;/h3&gt;
&lt;p&gt;具体的&lt;code&gt;memslot&lt;/code&gt;的设置在&lt;code&gt;kvm_set_memslot&lt;/code&gt;函数中完成，&lt;code&gt;slot&lt;/code&gt;的操作流程如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1771657/202011/1771657-20201107233927534-60352225.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先分配一个新的&lt;code&gt;memslots&lt;/code&gt;，并将原来的&lt;code&gt;memslots&lt;/code&gt;内容复制到新的&lt;code&gt;memslots&lt;/code&gt;中；&lt;/li&gt;
&lt;li&gt;如果针对&lt;code&gt;slot&lt;/code&gt;的操作是删除或者移动，首先根据旧的&lt;code&gt;slot id&lt;/code&gt;号从&lt;code&gt;memslots&lt;/code&gt;中找到原来的&lt;code&gt;slot&lt;/code&gt;，将该&lt;code&gt;slot&lt;/code&gt;设置成不可用状态，再将&lt;code&gt;memslots&lt;/code&gt;安装回去。这个安装的意思，就是RCU的assignment操作，不理解这个的，建议去看看之前的RCU系列文章。由于&lt;code&gt;slot&lt;/code&gt;不可用了，需要解除stage2的映射；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;kvm_arch_prepare_memory_region&lt;/code&gt;函数，用于处理新的&lt;code&gt;slot&lt;/code&gt;可能跨越多个用户进程VMA区域的问题，如果为设备区域，还需要将该区域映射到&lt;code&gt;Guest IPA&lt;/code&gt;中；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;update_memslots&lt;/code&gt;用于更新整个&lt;code&gt;memslots&lt;/code&gt;，&lt;code&gt;memslots&lt;/code&gt;基于PFN来进行排序的，添加、删除、移动等操作都是基于这个条件。由于都是有序的，因此可以选择二分法来进行查找操作；&lt;/li&gt;
&lt;li&gt;将添加新的&lt;code&gt;slot&lt;/code&gt;后的&lt;code&gt;memslots&lt;/code&gt;安装回KVM中；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;kvfree&lt;/code&gt;用于将原来的&lt;code&gt;memslots&lt;/code&gt;释放掉；&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;222-kvm_delete_memslot&quot;&gt;2.2.2 kvm_delete_memslot&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;kvm_delete_memslot&lt;/code&gt;函数，实际就是调用的&lt;code&gt;kvm_set_memslot&lt;/code&gt;函数，只是&lt;code&gt;slot&lt;/code&gt;的操作设置成&lt;code&gt;KVM_MR_DELETE&lt;/code&gt;而已，不再赘述。&lt;/p&gt;

&lt;p&gt;光有了GPA-&amp;gt;HVA，似乎还是跟&lt;code&gt;Hypervisor&lt;/code&gt;没有太大关系，到底是怎么去访问物理内存的呢？貌似也没有看到去建立页表映射啊？&lt;br/&gt;跟我走吧，带着问题出发！&lt;/p&gt;
&lt;p&gt;之前内存管理相关文章中提到过，用户态程序中分配虚拟地址vma后，实际与物理内存的映射是在&lt;code&gt;page fault&lt;/code&gt;时进行的。那么同样的道理，我们可以顺着这个思路去查找是否HVA-&amp;gt;HPA的映射也是在异常处理的过程中创建的？答案是显然的。&lt;/p&gt;
&lt;p&gt;回顾一下前文&lt;code&gt;《Linux虚拟化KVM-Qemu分析（四）之CPU虚拟化（2）》&lt;/code&gt;的一张图片：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1771657/202011/1771657-20201107233941226-1298320533.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当用户态触发&lt;code&gt;kvm_arch_vcpu_ioctl_run&lt;/code&gt;时，会让&lt;code&gt;Guest OS&lt;/code&gt;去跑在&lt;code&gt;Hypervisor&lt;/code&gt;上，当&lt;code&gt;Guest OS&lt;/code&gt;中出现异常退出到&lt;code&gt;Host&lt;/code&gt;时，此时&lt;code&gt;handle_exit&lt;/code&gt;将对退出的原因进行处理；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;异常处理函数&lt;code&gt;arm_exit_handlers&lt;/code&gt;如下，具体调用选择哪个处理函数，是根据&lt;code&gt;ESR_EL2, Exception Syndrome Register(EL2)&lt;/code&gt;中的值来确定的。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;static exit_handle_fn arm_exit_handlers[] = {
        [0 ... ESR_ELx_EC_MAX]  = kvm_handle_unknown_ec,
        [ESR_ELx_EC_WFx]        = kvm_handle_wfx,
        [ESR_ELx_EC_CP15_32]    = kvm_handle_cp15_32,
        [ESR_ELx_EC_CP15_64]    = kvm_handle_cp15_64,
        [ESR_ELx_EC_CP14_MR]    = kvm_handle_cp14_32,
        [ESR_ELx_EC_CP14_LS]    = kvm_handle_cp14_load_store,
        [ESR_ELx_EC_CP14_64]    = kvm_handle_cp14_64,
        [ESR_ELx_EC_HVC32]      = handle_hvc,
        [ESR_ELx_EC_SMC32]      = handle_smc,
        [ESR_ELx_EC_HVC64]      = handle_hvc,
        [ESR_ELx_EC_SMC64]      = handle_smc,
        [ESR_ELx_EC_SYS64]      = kvm_handle_sys_reg,
        [ESR_ELx_EC_SVE]        = handle_sve,
        [ESR_ELx_EC_IABT_LOW]   = kvm_handle_guest_abort,
        [ESR_ELx_EC_DABT_LOW]   = kvm_handle_guest_abort,
        [ESR_ELx_EC_SOFTSTP_LOW]= kvm_handle_guest_debug,
        [ESR_ELx_EC_WATCHPT_LOW]= kvm_handle_guest_debug,
        [ESR_ELx_EC_BREAKPT_LOW]= kvm_handle_guest_debug,
        [ESR_ELx_EC_BKPT32]     = kvm_handle_guest_debug,
        [ESR_ELx_EC_BRK64]      = kvm_handle_guest_debug,
        [ESR_ELx_EC_FP_ASIMD]   = handle_no_fpsimd,
        [ESR_ELx_EC_PAC]        = kvm_handle_ptrauth,
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;用你那双水汪汪的大眼睛扫描一下这个函数表，发现&lt;code&gt;ESR_ELx_EC_DABT_LOW&lt;/code&gt;和&lt;code&gt;ESR_ELx_EC_IABT_LOW&lt;/code&gt;两个异常，这不就是指令异常和数据异常吗，我们大胆的猜测，&lt;code&gt;HVA-&amp;gt;HPA&lt;/code&gt;映射的建立就在&lt;code&gt;kvm_handle_guest_abort&lt;/code&gt;函数中。&lt;/p&gt;
&lt;h2 id=&quot;31-kvm_handle_guest_abort&quot;&gt;3.1 &lt;code&gt;kvm_handle_guest_abort&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;先来补充点知识点，可以更方便的理解接下里的内容：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Guest OS在执行到敏感指令时，产生EL2异常，CPU切换模式并跳转到&lt;code&gt;EL2&lt;/code&gt;的&lt;code&gt;el1_sync&lt;/code&gt;（&lt;code&gt;arch/arm64/kvm/hyp/entry-hyp.S&lt;/code&gt;）异常入口；&lt;/li&gt;
&lt;li&gt;CPU的&lt;code&gt;ESR_EL2&lt;/code&gt;寄存器记录了异常产生的原因；&lt;/li&gt;
&lt;li&gt;Guest退出到kvm后，kvm根据异常产生的原因进行对应的处理。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;简要看一下&lt;code&gt;ESR_EL2&lt;/code&gt;寄存器：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1771657/202011/1771657-20201107233952862-20535881.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;EC&lt;/code&gt;：Exception class，异常类，用于标识异常的原因；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ISS&lt;/code&gt;：Instruction Specific Syndrome，ISS域定义了更详细的异常细节；&lt;/li&gt;
&lt;li&gt;在&lt;code&gt;kvm_handle_guest_abort&lt;/code&gt;函数中，多处需要对异常进行判断处理；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;kvm_handle_guest_abort&lt;/code&gt;函数，处理地址访问异常，可以分为两类：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;常规内存访问异常，包括未建立页表映射、读写权限等；&lt;/li&gt;
&lt;li&gt;IO内存访问异常，IO的模拟通常需要Qemu来进行模拟；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;先看一下&lt;code&gt;kvm_handle_guest_abort&lt;/code&gt;函数的注释吧：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;/**
 * kvm_handle_guest_abort - handles all 2nd stage aborts
 *
 * Any abort that gets to the host is almost guaranteed to be caused by a
 * missing second stage translation table entry, which can mean that either the
 * guest simply needs more memory and we must allocate an appropriate page or it
 * can mean that the guest tried to access I/O memory, which is emulated by user
 * space. The distinction is based on the IPA causing the fault and whether this
 * memory region has been registered as standard RAM by user space.
 */
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;到达Host的abort都是由于缺乏Stage 2页表转换条目导致的，这个可能是Guest需要分配更多内存而必须为其分配内存页，或者也可能是Guest尝试去访问IO空间，IO操作由用户空间来模拟的。两者的区别是触发异常的IPA地址是否已经在用户空间中注册为标准的RAM；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;调用流程来了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1771657/202011/1771657-20201107234014086-1464598545.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;kvm_vcpu_trap_get_fault_type&lt;/code&gt;用于获取&lt;code&gt;ESR_EL2&lt;/code&gt;的数据异常和指令异常的&lt;code&gt;fault status code&lt;/code&gt;，也就是&lt;code&gt;ESR_EL2&lt;/code&gt;的ISS域；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;kvm_vcpu_get_fault_ipa&lt;/code&gt;用于获取触发异常的IPA地址；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;kvm_vcpu_trap_is_iabt&lt;/code&gt;用于获取异常类，也就是&lt;code&gt;ESR_EL2&lt;/code&gt;的&lt;code&gt;EC&lt;/code&gt;，并且判断是否为&lt;code&gt;ESR_ELx_IABT_LOW&lt;/code&gt;，也就是指令异常类型；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;kvm_vcpu_dabt_isextabt&lt;/code&gt;用于判断是否为同步外部异常，同步外部异常的情况下，如果支持RAS，Host能处理该异常，不需要将异常注入给Guest；&lt;/li&gt;
&lt;li&gt;异常如果不是&lt;code&gt;FSC_FAULT&lt;/code&gt;，&lt;code&gt;FSC_PERM&lt;/code&gt;，&lt;code&gt;FSC_ACCESS&lt;/code&gt;三种类型的话，直接返回错误；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;gfn_to_memslot&lt;/code&gt;，&lt;code&gt;gfn_to_hva_memslot_prot&lt;/code&gt;这两个函数，是根据IPA去获取到对应的memslot和HVA地址，这个地方就对应到了上文中第二章节中地址关系的建立了，由于建立了连接关系，便可以通过IPA去找到对应的HVA；&lt;/li&gt;
&lt;li&gt;如果注册了RAM，能获取到正确的HVA，如果是IO内存访问，那么HVA将会被设置成&lt;code&gt;KVM_HVA_ERR_BAD&lt;/code&gt;。&lt;code&gt;kvm_is_error_hva&lt;/code&gt;或者&lt;code&gt;(write_fault &amp;amp;&amp;amp; !writable)&lt;/code&gt;代表两种错误：1）指令错误，向Guest注入指令异常；2）IO访问错误，IO访问又存在两种情况：2.1）Cache维护指令，则直接跳过该指令；2.2）正常的IO操作指令，调用&lt;code&gt;io_mem_abort&lt;/code&gt;进行IO模拟操作；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;handle_access_fault&lt;/code&gt;用于处理访问权限问题，如果内存页无法访问，则对其权限进行更新；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;user_mem_abort&lt;/code&gt;，用于分配更多的内存，实际上就是完成Stage 2页表映射的建立，根据异常的IPA地址，已经对应的HVA，建立映射，细节的地方就不表了。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;来龙去脉摸清楚了，那就草草收场吧，下回见了。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;《Arm Architecture Registers Armv8, for Armv8-A architecture profile》&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;欢迎关注个人公众号，不定期分享技术文章。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1771657/202011/1771657-20201107234044212-1724655073.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 07 Nov 2020 15:43:00 +0000</pubDate>
<dc:creator>LoyenWang</dc:creator>
<og:description>背景 Read the fucking source code! --By 鲁迅 A picture is worth a thousand words. --By 高尔基 说明： KVM版本：5.9</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/LoyenWang/p/13943005.html</dc:identifier>
</item>
<item>
<title>Redis数据结构之字典 - sherlock_lin</title>
<link>http://www.cnblogs.com/sherlock-lin/p/13942995.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sherlock-lin/p/13942995.html</guid>
<description>&lt;p&gt;当我们使用 Redis 的 Hash 操作时，底层的实现就是字典。&lt;/p&gt;
&lt;p&gt;在介绍字典之后，我们先回忆一下 Redis 中的 Hash 操作。最常用的就是 &lt;strong&gt;HSET&lt;/strong&gt; 和 &lt;strong&gt;HGET&lt;/strong&gt; 了&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;127.0.0.1:6379&amp;gt; HSET user name sherlock
(integer) 1
127.0.0.1:6379&amp;gt; HSET user age 20
(integer) 1
127.0.0.1:6379&amp;gt; HGET user name
&quot;sherlock&quot;
127.0.0.1:6379&amp;gt; HGET user age
&quot;20&quot;
127.0.0.1:6379&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;除了 &lt;strong&gt;HSET&lt;/strong&gt; 和 &lt;strong&gt;HGET&lt;/strong&gt; 外的常见指令还有：&lt;strong&gt;HDEL、HEXISTS、HGETALL、HMGET 等等&lt;/strong&gt;，这里就不一一列举了，Redis 的 Hash 操作一般都是以 H 开头的。&lt;/p&gt;
&lt;p&gt;我们可以看到，Hash 操作可以保存很多组键值对，其底层的视线就是字典&lt;/p&gt;

&lt;p&gt;字典的定义在源码目录下 src/dict.h 文件中，为了便于理解，我们从最基本的结构往上介绍&lt;/p&gt;
&lt;h2 id=&quot;21、dictentry&quot;&gt;2.1、dictEntry&lt;/h2&gt;
&lt;p&gt;首先是 &lt;strong&gt;dictEntry&lt;/strong&gt;，它表示字典中的一组键值对，声明如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;typedef struct dictEntry {
    void *key;  //键
    union {
        void *val;
        uint64_t u64;
        int64_t s64;
        double d;
    } v;        //值
    struct dictEntry *next;     //指向下个键值对
} dictEntry;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;key&lt;/strong&gt; 表示的键值对的键；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;v&lt;/strong&gt; 表示键值对的值，&lt;strong&gt;v&lt;/strong&gt; 是一个共同体，表示这里的值类型可以是指针、uint64_t、int64_t 和 double 其中之一，用共同体可以节约内存；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;dictEntrynext&lt;/strong&gt; 指向下一组键值对，这里是链表，当需要存储的键值对最后计算得到的存储的位置索引出现重复的时候，就使用链表，将多个键值对存在一个数组元素中，而且，Redis 中，新数据会存储在链表的最前面&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;22、dictht&quot;&gt;2.2、dictht&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;dictht&lt;/strong&gt; 即为 Redis 操作时的值结构，用于保存多组的键值对，声明如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;typedef struct dictht {
    dictEntry **table;          //键值对数组，数组的元素是个链表
    unsigned long size;         //键值对数组的大小
    unsigned long sizemask;     //掩码，用于计算索引
    unsigned long used;         //键值对数量
} dictht;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;table&lt;/strong&gt; 是一个 &lt;strong&gt;dictEntry&lt;/strong&gt; 类型的数组指针，它的每个元素都是指针，都指向一个 &lt;strong&gt;dictEntry&lt;/strong&gt; 类型；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;size&lt;/strong&gt; 表示键值对数组的大小；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;sizemask&lt;/strong&gt; 为掩码，用于计算键值对插入时的数组索引，它总是 size - 1，后面会再次说到；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;used&lt;/strong&gt; 表示当前哈希表存储的键值对的数量；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下图是一个 dictht 的存储结构，k0和k1的键值计算的索引相同，所以放在一个数组元素中：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/sherlock-lin/1599036/o_201107153836image-20201107211840121.png&quot; alt=&quot;image-20201107211840121&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;23、dict&quot;&gt;2.3、dict&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;dict&lt;/strong&gt; 是最终的字典的数据结构，声明如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;typedef struct dictType {
    unsigned int (*hashFunction)(const void *key);
    void *(*keyDup)(void *privdata, const void *key);
    void *(*valDup)(void *privdata, const void *obj);
    int (*keyCompare)(void *privdata, const void *key1, const void *key2);
    void (*keyDestructor)(void *privdata, void *key);
    void (*valDestructor)(void *privdata, void *obj);
} dictType;

typedef struct dict {
    dictType *type;
    void *privdata;
    dictht ht[2];
    long rehashidx; /* rehashing not in progress if rehashidx == -1 */
    int iterators; /* number of iterators currently running */
} dict;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;3&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;dictType&lt;/strong&gt; 是一组操作函数指针，用于操作特定类型的键值对，Redis 会为不同类型的键值对设置不同类型的函数；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;privdata&lt;/strong&gt; 表示需要传递给操作函数的特定私有数据；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;ht&lt;/strong&gt; 是一个 &lt;strong&gt;dictht&lt;/strong&gt; 类型的数组，有两个元素，之所以两个，是因为需要rehash，后面会再次说到；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;rehashidx&lt;/strong&gt; 表示 rehash 进度，-1表示当前并没有进行 rehash；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;iterators&lt;/strong&gt; 表示当前运行的迭代器数量，本次不做特别说明；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下图表示一个没有在rehash的字典&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/sherlock-lin/1599036/o_201107153840image-20201107212436924.png&quot; alt=&quot;image-20201107212436924&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Redis 中的哈希操作，顾名思义，存储方法肯定和哈希算法有关，这里先简单介绍一下哈希算法。&lt;/p&gt;
&lt;h2 id=&quot;31、哈希算法&quot;&gt;3.1、哈希算法&lt;/h2&gt;
&lt;p&gt;哈希算法又称之为散列函数，它把任意长度的输入，通过一系列的算法， 变换成固定长度的输出。&lt;/p&gt;
&lt;p&gt;Redis 底层使用的哈希算法是 MurmurHash 算法，最初由 Austin Appleby 在2008 年发明，其优势在于，无论输入是否有规律，输出都是随机分布的，而且速度很快。&lt;/p&gt;
&lt;p&gt;其实了解哈希的同学都能够明白，用有限的hash值来表示无限的数据，肯定会出现不同的数据得出重复的哈希值的问题，当然，专业的说法不叫重复，叫 碰撞。&lt;/p&gt;
&lt;h2 id=&quot;32、存储过程和键冲突&quot;&gt;3.2、存储过程和键冲突&lt;/h2&gt;
&lt;p&gt;回到正题，现在当一个键值对添加到字典中，会先计算出当前键值对需要存储在 &lt;strong&gt;table&lt;/strong&gt; 中的 &lt;strong&gt;index&lt;/strong&gt;，计算分两步，先根据键计算hash值，再根据hash值和掩码计算index&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;hash = dict-&amp;gt;type-&amp;gt;hashFunction(key);       //根据键计算其hash值
//根据hash值和掩码计算索引，ht[x]可能会是h[0]，也可能是h[1]，根据rehash来定
index = hash &amp;amp; dict-&amp;gt;ht[x].sizemask;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先，对于不同的key，这里计算的hash值可能相同，其次，不同的hash值经过和掩码取&amp;amp;，会出现相同的index，这也是使用链表的原因，在 Redis 中称之为键发生了冲突（collision）&lt;/p&gt;
&lt;p&gt;我们前面说到，sizemask 总是 size - 1，即数组的最大索引，hash &amp;amp; sizemask 就保证得出的 index一定是一个小于等于 sizemask 的值，即一定在数组内&lt;/p&gt;
&lt;p&gt;计算错 index 之后，就把该键值对保存到 table 对应的位置，table 的元素都是链表，新插入的键值对，会保存在链表的最前端，这样效率最高，时间复杂度为 O(1)，如果保存在最后端，那么时间复杂度为O(N)。反正放在最前端和最后端都一样，就取一个插入最快的吧。&lt;/p&gt;
&lt;p&gt;这样存储完成之后，我们取数据也就是要在数组和链表中取，时间复杂度也就是 O(1) + O(N)，这里的N越小越好，即链表越小越好，最好没有键冲突，那么时间复杂度就是O(1)&lt;/p&gt;
&lt;h2 id=&quot;33、rehash&quot;&gt;3.3、rehash&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;rehash&lt;/strong&gt; 即对hash表进行扩展和收缩。&lt;/p&gt;
&lt;p&gt;这个操作是非常又必要的，可以想象一下，假设一开始创建的 &lt;strong&gt;dictEntry&lt;/strong&gt; 数组的大小只有100个，结果随着时间的推移，保存的键值对慢慢变多，变成五六百个，那么，键冲突的概率就会成倍地增加，最后就会导致个别数组内的链表元素有多个，这样就大大地增加了读取的效率，此时就很有必要对原先只有100个元素的数组进行拓展，比如扩展成五六百个，尽量保证，链表节点的数量最小。同理，当保存的键值对删减之后，缩小数组可以节约内存，反正空着也是空着，不如释放了。&lt;/p&gt;
&lt;p&gt;提到hash，就不得不提负载因子（load factor）的概念，它是保存的键值对和数组大小的一个比值，使用扩展和收缩的手段，把它控制在一个合理的范围之内，可以避免内存的浪费和读取的低效&lt;/p&gt;
&lt;p&gt;负载因子的计算公式如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;load_factor = ht[0].used / ht[0].size
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;used 是保存的的键值对的数目，size 是数组的大小&lt;/p&gt;
&lt;p&gt;可见，如果负载因子太大，表示数组中的元素的链表元素会多，即键冲突的概率会变大；&lt;/p&gt;
&lt;p&gt;而如果负载因子太小，表示数组中可能有些元素没有使用，即有些内存浪费了；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;哈希表的收缩和扩展：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Redis 中，当满足下面两个条件之一时，会自动进行扩展操作：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;当服务器没有执行 &lt;strong&gt;BGSAVE&lt;/strong&gt; 和 &lt;strong&gt;BGREWRITEAOF&lt;/strong&gt; 命令，并且负载因子大于等于1的时候；&lt;/li&gt;
&lt;li&gt;当服务器正在执行 &lt;strong&gt;BGSAVE&lt;/strong&gt; 和 &lt;strong&gt;BGREWRITEAOF&lt;/strong&gt; 命令，并且负载因子大于等于5的时候；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这是因为这两个命令在执行过程中，Redis 需要创建子进程，而大多数的操作系统都采用写时复制的技术来优化子进程的使用效率，所以在子进程存在期间，服务器会提高触发扩展所需的负载因子，尽可能避免在子进程存在期间进行扩展操作，最大限度地节约内存。&lt;/p&gt;
&lt;p&gt;当 Redis 进行 rehash 这种操作的时候，客户端还在使用，要兼顾 rehash 和 客户端，就要保证原数据和新数据同时存储和查询。这就是 &lt;strong&gt;dict&lt;/strong&gt; 结构中 &lt;strong&gt;ht&lt;/strong&gt; 大小为2的原因。&lt;/p&gt;
&lt;p&gt;在没有进行 rehash 的时候，只使用 ht[0]，rehash 会将新旧数据都重新散列，存入 ht[1] 中。rehash 完成之后，将 ht[1] 变成 ht[0]，原来的 ht[0] 释放掉，再新建一个 ht[1]&lt;/p&gt;
&lt;h2 id=&quot;34、渐进式rehash&quot;&gt;3.4、渐进式rehash&lt;/h2&gt;
&lt;p&gt;当数据量很大的时候，rehash 操作如果一次性将h[0]数据转到ht[1]，会导致服务宕机，这是不能接受的。因此，Redis 的 rehash 操作并不是一次性、集中式地完成，而是分多次、渐进式地完成的。&lt;/p&gt;
&lt;p&gt;大致步骤如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;为 ht[1] 分配空间，，让字典同时持有 ht[0] 和 ht[1] 两个哈希表；&lt;/li&gt;
&lt;li&gt;将 rehashindex 值设置为0，表示开始 rehash；&lt;/li&gt;
&lt;li&gt;在 rehash 期间，每次对字典执行增删查改的操作时，程序还会顺带将 ht[0] 中哈希表在 rehashindex 上的所有键值对 rehash 到 ht[1] 上，完成只有，rehashindex 递增；&lt;/li&gt;
&lt;li&gt;随着字典的操作的不断执行，最终在某个时间点上，ht[0] 的所有键值对都会被rehash至 ht[1]，这时候，rehash 全部完成，将 rehashindex 设置为-1；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;渐进式 rehash 的好处在于，其采用分治的方式，将 rehash 键值对的工作量均摊到每次对字典的增删查改上，避免了集中式 rehash 带来的庞大的计算量&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;渐进式 rehash 执行期间的哈希表操作：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;rehash 的时候，ht[0] 和 ht[1] 同时使用，字典的增删查改等操作会先后在 ht[0] 和 ht[1] 上执行，比如查找时，先在 ht[0] 上查找，如果没有找到，则在 ht[1] 上查找。&lt;/p&gt;
&lt;p&gt;rehash 的时候，ht[0] 只删改查，不会进行添加操作，添加会直接添加到 ht[1] 中，保证了 ht[0] 中的键值对数量只减不增，直到 rehash 完成之后，ht[0] 变成空表。&lt;/p&gt;

&lt;ol&gt;&lt;li&gt;字典广泛用于实现 Redis 的各种功能，包括数据库和哈希键；&lt;/li&gt;
&lt;li&gt;字典底层使用哈希表实现，每个字典带有两个哈希表，一个平时使用，一个 rehash 的时候使用；&lt;/li&gt;
&lt;li&gt;哈希表使用单项链表来解决键冲突；&lt;/li&gt;
&lt;li&gt;哈希表扩展和收缩时，Redis 会将一个哈希表 rehash 到另一个哈希表上，这个操作是渐进式的，不是一次完成的；&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Sat, 07 Nov 2020 15:41:00 +0000</pubDate>
<dc:creator>sherlock_lin</dc:creator>
<og:description>1、说明 当我们使用 Redis 的 Hash 操作时，底层的实现就是字典。 在介绍字典之后，我们先回忆一下 Redis 中的 Hash 操作。最常用的就是 HSET 和 HGET 了 127.0.0</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/sherlock-lin/p/13942995.html</dc:identifier>
</item>
<item>
<title>高并发，你真的理解透彻了吗？ - IT人的职场进阶</title>
<link>http://www.cnblogs.com/luojunwu/p/13942873.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/luojunwu/p/13942873.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/fb215e9c-4749-4266-bf20-1142acfc80d9.jpg&quot; alt=&quot;&quot; width=&quot;770&quot; height=&quot;431&quot; data-cke-saved-src=&quot;https://oscimg.oschina.net/oscnet/fb215e9c-4749-4266-bf20-1142acfc80d9.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;高并发，几乎是每个程序员都想拥有的经验。原因很简单：随着流量变大，会遇到各种各样的技术问题，比如接口响应超时、CPU load升高、GC频繁、死锁、大数据量存储等等，这些问题能推动我们在技术深度上不断精进。&lt;/p&gt;
&lt;p&gt;在过往的面试中，如果候选人做过高并发的项目，我通常会让对方谈谈对于高并发的理解，但是能系统性地回答好此问题的人并不多，大概分成这样几类：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1、对数据化的指标没有概念&lt;/strong&gt;：&lt;span&gt;不清楚选择什么样的指标来衡量高并发系统？分不清并发量和QPS，甚至不知道自己系统的总用户量、活跃用户量，平峰和高峰时的QPS和TPS等关键数据。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2、设计了一些方案，但是细节掌握不透彻&lt;/strong&gt;：&lt;span&gt;讲不出该方案要关注的技术点和可能带来的副作用。比如读性能有瓶颈会引入缓存，但是忽视了缓存命中率、热点key、数据一致性等问题。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3、理解片面，把高并发设计等同于性能优化&lt;/strong&gt;：&lt;span&gt;大谈并发编程、多级缓存、异步化、水平扩容，却忽视高可用设计、服务治理和运维保障。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4、掌握大方案，却忽视最基本的东西&lt;/strong&gt;：&lt;span&gt;能讲清楚垂直分层、水平分区、缓存等大思路，却没意识去分析数据结构是否合理，算法是否高效，没想过从最根本的IO和计算两个维度去做细节优化。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这篇文章，我想结合自己的高并发项目经验，系统性地总结下高并发需要掌握的知识和实践思路，希望对你有所帮助。内容分成以下3个部分：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;如何理解高并发？&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;高并发系统设计的目标是什么？&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;高并发的实践方案有哪些？&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;高并发意味着大流量，需要运用技术手段抵抗流量的冲击，这些手段好比操作流量，能让流量更平稳地被系统所处理，带给用户更好的体验。&lt;/p&gt;
&lt;p&gt;我们常见的高并发场景有：淘宝的双11、春运时的抢票、微博大V的热点新闻等。除了这些典型事情，每秒几十万请求的秒杀系统、每天千万级的订单系统、每天亿级日活的信息流系统等，都可以归为高并发。&lt;/p&gt;
&lt;p&gt;很显然，上面谈到的高并发场景，并发量各不相同，&lt;span&gt;&lt;strong&gt;那到底多大并发才算高并发呢？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1、不能只看数字，要看具体的业务场景。不能说10W QPS的秒杀是高并发，而1W QPS的信息流就不是高并发。信息流场景涉及复杂的推荐模型和各种人工策略，它的业务逻辑可能比秒杀场景复杂10倍不止。因此，不在同一个维度，没有任何比较意义。&lt;/p&gt;
&lt;p&gt;2、业务都是从0到1做起来的，并发量和QPS只是参考指标，最重要的是：在业务量逐渐变成原来的10倍、100倍的过程中，你是否用到了高并发的处理方法去演进你的系统，从架构设计、编码实现、甚至产品方案等维度去预防和解决高并发引起的问题？而不是一味的升级硬件、加机器做水平扩展。&lt;/p&gt;
&lt;p&gt;此外，各个高并发场景的业务特点完全不同：有读多写少的信息流场景、有读多写多的交易场景，&lt;strong&gt;那是否有通用的技术方案解决不同场景的高并发问题呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我觉得大的思路可以借鉴，别人的方案也可以参考，但是真正落地过程中，细节上还会有无数的坑。另外，由于软硬件环境、技术栈、以及产品逻辑都没法做到完全一致，这些都会导致同样的业务场景，就算用相同的技术方案也会面临不同的问题，这些坑还得一个个趟。&lt;/p&gt;
&lt;p&gt;因此，这篇文章我会将重点放在基础知识、通用思路、和我曾经实践过的有效经验上，希望让你对高并发有更深的理解。&lt;/p&gt;


&lt;p&gt;先搞清楚高并发系统设计的目标，在此基础上再讨论设计方案和实践经验才有意义和针对性。&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;2.1 宏观目标&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;高并发绝不意味着只追求高性能，这是很多人片面的理解。从宏观角度看，高并发系统设计的目标有三个：高性能、高可用，以及高可扩展。&lt;/p&gt;
&lt;p&gt;1、高性能：性能体现了系统的并行处理能力，在有限的硬件投入下，提高性能意味着节省成本。同时，性能也反映了用户体验，响应时间分别是100毫秒和1秒，给用户的感受是完全不同的。&lt;/p&gt;
&lt;p&gt;2、高可用：表示系统可以正常服务的时间。一个全年不停机、无故障；另一个隔三差五出线上事故、宕机，用户肯定选择前者。另外，如果系统只能做到90%可用，也会大大拖累业务。&lt;/p&gt;
&lt;p&gt;3、高扩展：表示系统的扩展能力，流量高峰时能否在短时间内完成扩容，更平稳地承接峰值流量，比如双11活动、明星离婚等热点事件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/f38e9b9b-1fe6-466c-b784-3ea36fa9bbaf.png&quot; width=&quot;500&quot; data-cke-saved-src=&quot;https://oscimg.oschina.net/oscnet/f38e9b9b-1fe6-466c-b784-3ea36fa9bbaf.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这3个目标是需要通盘考虑的，因为它们互相关联、甚至也会相互影响。&lt;/p&gt;
&lt;p&gt;比如说：考虑系统的扩展能力，你会将服务设计成无状态的，这种集群设计保证了高扩展性，其实也间接提升了系统的性能和可用性。&lt;/p&gt;
&lt;p&gt;再比如说：为了保证可用性，通常会对服务接口进行超时设置，以防大量线程阻塞在慢请求上造成系统雪崩，那超时时间设置成多少合理呢？一般，我们会参考依赖服务的性能表现进行设置。&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;2.2 微观目标&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;再从微观角度来看，高性能、高可用和高扩展又有哪些具体的指标来衡量？为什么会选择这些指标呢？&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;2.2.1 性能指标&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;通过性能指标可以度量目前存在的性能问题，同时作为性能优化的评估依据。一般来说，会采用一段时间内的接口响应时间作为指标。&lt;/p&gt;
&lt;p&gt;1、平均响应时间：最常用，但是缺陷很明显，对于慢请求不敏感。比如1万次请求，其中9900次是1ms，100次是100ms，则平均响应时间为1.99ms，虽然平均耗时仅增加了0.99ms，但是1%请求的响应时间已经增加了100倍。&lt;/p&gt;
&lt;p&gt;2、TP90、TP99等分位值：将响应时间按照从小到大排序，TP90表示排在第90分位的响应时间， 分位值越大，对慢请求越敏感。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/2da25aae-4860-49b3-8b1a-fae08139ce6d.jpg&quot; alt=&quot;&quot; width=&quot;626&quot; height=&quot;172&quot; data-cke-saved-src=&quot;https://oscimg.oschina.net/oscnet/2da25aae-4860-49b3-8b1a-fae08139ce6d.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3、吞吐量：和响应时间呈反比，比如响应时间是1ms，则吞吐量为每秒1000次。&lt;/p&gt;
&lt;p&gt;通常，设定性能目标时会兼顾吞吐量和响应时间，比如这样表述：在每秒1万次请求下，AVG控制在50ms以下，TP99控制在100ms以下。对于高并发系统，AVG和TP分位值必须同时要考虑。&lt;/p&gt;
&lt;p&gt;另外，从用户体验角度来看，200毫秒被认为是第一个分界点，用户感觉不到延迟，1秒是第二个分界点，用户能感受到延迟，但是可以接受。&lt;/p&gt;
&lt;p&gt;因此，对于一个健康的高并发系统，TP99应该控制在200毫秒以内，TP999或者TP9999应该控制在1秒以内。&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;2.2.2 可用性指标&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;高可用性是指系统具有较高的无故障运行能力，可用性 = 正常运行时间 / 系统总运行时间，一般使用几个9来描述系统的可用性。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/963c63c7-8994-42cf-a914-190835a5c7f3.png&quot; alt=&quot;&quot; width=&quot;616&quot; height=&quot;247&quot; data-cke-saved-src=&quot;https://oscimg.oschina.net/oscnet/963c63c7-8994-42cf-a914-190835a5c7f3.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对于高并发系统来说，最基本的要求是：保证3个9或者4个9。原因很简单，如果你只能做到2个9，意味着有1%的故障时间，像一些大公司每年动辄千亿以上的GMV或者收入，1%就是10亿级别的业务影响。&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;2.2.3 可扩展性指标&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;面对突发流量，不可能临时改造架构，最快的方式就是增加机器来线性提高系统的处理能力。&lt;/p&gt;
&lt;p&gt;对于业务集群或者基础组件来说，扩展性 = 性能提升比例 / 机器增加比例，理想的扩展能力是：资源增加几倍，性能提升几倍。通常来说，扩展能力要维持在70%以上。&lt;/p&gt;
&lt;p&gt;但是从高并发系统的整体架构角度来看，扩展的目标不仅仅是把服务设计成无状态就行了，因为当流量增加10倍，业务服务可以快速扩容10倍，但是数据库可能就成为了新的瓶颈。&lt;/p&gt;
&lt;p&gt;像MySQL这种有状态的存储服务通常是扩展的技术难点，如果架构上没提前做好规划（垂直和水平拆分），就会涉及到大量数据的迁移。&lt;/p&gt;
&lt;p&gt;因此，高扩展性需要考虑：服务集群、数据库、缓存和消息队列等中间件、负载均衡、带宽、依赖的第三方等，当并发达到某一个量级后，上述每个因素都可能成为扩展的瓶颈点。&lt;/p&gt;


&lt;p&gt;了解了高并发设计的3大目标后，再系统性总结下高并发的设计方案，会从以下两部分展开：先总结下通用的设计方法，然后再围绕高性能、高可用、高扩展分别给出具体的实践方案。&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;3.1 通用的设计方法&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;通用的设计方法主要是从「纵向」和「横向」两个维度出发，俗称高并发处理的两板斧：纵向扩展和横向扩展。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;3.1.1 纵向扩展（scale-up）&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;它的目标是提升单机的处理能力，方案又包括：&lt;/p&gt;
&lt;p&gt;1、提升单机的硬件性能：通过增加内存、 CPU核数、存储容量、或者将磁盘 升级成SSD 等堆硬 件 的 方 式 来 提升 。&lt;/p&gt;
&lt;p&gt;2、提升单机的软件性能：使用缓存减少IO次数，使用并发或者异步的方式增加吞吐量。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;3.1.2 横向扩展（scale-out）&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;因为单机性能总会存在极限，所以最终还需要引入横向扩展，通过集群部署以进一步提高并发处理能力，又包括以下2个方向：&lt;/p&gt;
&lt;p&gt;1、做好分层架构：这是横向扩展的提前，因为高并发系统往往业务复杂，通过分层处理可以简化复杂问题，更容易做到横向扩展。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/8262fce0-aca5-4122-9ee6-8be09077a4f1.png&quot; alt=&quot;&quot; width=&quot;836&quot; height=&quot;669&quot; data-cke-saved-src=&quot;https://oscimg.oschina.net/oscnet/8262fce0-aca5-4122-9ee6-8be09077a4f1.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面这种图是互联网最常见的分层架构，当然真实的高并发系统架构会在此基础上进一步完善。比如会做动静分离并引入CDN，反向代理层可以是LVS+Nginx，Web层可以是统一的API网关，业务服务层可进一步按垂直业务做微服务化，存储层可以是各种异构数据库。&lt;/p&gt;
&lt;p&gt;2、各层进行水平扩展：无状态水平扩容，有状态做分片路由。业务集群通常能设计成无状态的，而数据库和缓存往往是有状态的，因此需要设计分区键做好存储分片，当然也可以通过主从同步、读写分离的方案提升读性能。&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;3.2 具体的实践方案&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;下面再结合我的个人经验，针对高性能、高可用、高扩展3个方面，总结下可落地的实践方案。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;3.2.1 高性能的实践方案&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;1、集群部署，通过负载均衡减轻单机压力。&lt;/p&gt;
&lt;p&gt;2、多级缓存，包括静态数据使用CDN、本地缓存、分布式缓存等，以及对缓存场景中的热点key、缓存穿透、缓存并发、数据一致性等问题的处理。&lt;/p&gt;
&lt;p&gt;3、分库分表和索引优化，以及借助搜索引擎解决复杂查询问题。&lt;/p&gt;
&lt;p&gt;4、考虑NoSQL数据库的使用，比如HBase、TiDB等，但是团队必须熟悉这些组件，且有较强的运维能力。&lt;/p&gt;
&lt;p&gt;5、异步化，将次要流程通过多线程、MQ、甚至延时任务进行异步处理。&lt;/p&gt;
&lt;p&gt;6、限流，需要先考虑业务是否允许限流（比如秒杀场景是允许的），包括前端限流、Nginx接入层的限流、服务端的限流。&lt;/p&gt;
&lt;p&gt;7、对流量进行 削峰填谷 ，通过 MQ承接流量。&lt;/p&gt;
&lt;p&gt;8、并发处理，通过多线程将串行逻辑并行化。&lt;/p&gt;
&lt;p&gt;9、预计算，比如抢红包场景，可以提前计算好红包金额缓存起来，发红包时直接使用即可。&lt;/p&gt;
&lt;p&gt;10、 缓存预热 ，通过异步 任务 提前 预热数据到本地缓存或者分布式缓存中。&lt;/p&gt;
&lt;p&gt;11、减少IO次数，比如数据库和缓存的批量读写、RPC的批量接口支持、或者通过冗余数据的方式干掉RPC调用。&lt;/p&gt;
&lt;p&gt;12、减少IO时的数据包大小，包括采用轻量级的通信协议、合适的数据结构、去掉接口中的多余字段、减少缓存key的大小、压缩缓存value等。&lt;/p&gt;
&lt;p&gt;13、程序逻辑优化，比如将大概率阻断执行流程的判断逻辑前置、For循环的计算逻辑优化，或者采用更高效的算法。&lt;/p&gt;
&lt;p&gt;14、各种池化技术的使用和池大小的设置，包括HTTP请求池、线程池（考虑CPU密集型还是IO密集型设置核心参数）、数据库和Redis连接池等。&lt;/p&gt;
&lt;p&gt;15、JVM优化，包括新生代和老年代的大小、GC算法的选择等，尽可能减少GC频率和耗时。&lt;/p&gt;
&lt;p&gt;16、锁选择，读多写少的场景用乐观锁，或者考虑通过分段锁的方式减少锁冲突。&lt;/p&gt;
&lt;p&gt;上述方案无外乎从计算和 IO 两个维度考虑所有可能的优化点，需要有配套的监控系统实时了解当前的性能表现，并支撑你进行性能瓶颈分析，然后再遵循二八原则，抓主要矛盾进行优化。&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;3.2.2 高可用的实践方案&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;1、对等节点的故障转移，Nginx和服务治理框架均支持一个节点失败后访问另一个节点。&lt;/p&gt;
&lt;p&gt;2、非对等节点的故障转移，通过心跳检测并实施主备切换（比如redis的哨兵模式或者集群模式、MySQL的主从切换等）。&lt;/p&gt;
&lt;p&gt;3、接口层面的超时设置、重试策略和幂等设计。&lt;/p&gt;
&lt;p&gt;4、降级处理：保证核心服务，牺牲非核心服务，必要时进行熔断；或者核心链路出问题时，有备选链路。&lt;/p&gt;
&lt;p&gt;5、限流处理：对超过系统处理能力的请求直接拒绝或者返回错误码。&lt;/p&gt;
&lt;p&gt;6、MQ场景的消息可靠性保证，包括producer端的重试机制、broker侧的持久化、consumer端的ack机制等。&lt;/p&gt;
&lt;p&gt;7、灰度发布，能支持按机器维度进行小流量部署，观察系统日志和业务指标，等运行平稳后再推全量。&lt;/p&gt;
&lt;p&gt;8、监控报警：全方位的监控体系，包括最基础的CPU、内存、磁盘、网络的监控，以及Web服务器、JVM、数据库、各类中间件的监控和业务指标的监控。&lt;/p&gt;
&lt;p&gt;9、灾备演练：类似当前的“混沌工程”，对系统进行一些破坏性手段，观察局部故障是否会引起可用性问题。&lt;/p&gt;
&lt;p&gt;高可用的方案主要从冗余、取舍、系统运维3个方向考虑，同时需要有配套的值班机制和故障处理流程，当出现线上问题时，可及时跟进处理。&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;3.2.3 高扩展的实践方案&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;1、合理的分层架构：比如上面谈到的互联网最常见的分层架构，另外还能进一步按照数据访问层、业务逻辑层对微服务做更细粒度的分层（但是需要评估性能，会存在网络多一跳的情况）。&lt;/p&gt;
&lt;p&gt;2、存储层的拆分：按照业务维度做垂直拆分、按照数据特征维度进一步做水平拆分（分库分表）。&lt;/p&gt;
&lt;p&gt;3、业务层的拆分：最常见的是按照业务维度拆（比如电商场景的商品服务、订单服务等），也可以按照核心接口和非核心接口拆，还可以按照请求源拆（比如To C和To B，APP和H5 ）。&lt;/p&gt;


&lt;p&gt;高并发确实是一个复杂且系统性的问题，由于篇幅有限，诸如分布式Trace、全链路压测、柔性事务都是要考虑的技术点。另外，如果业务场景不同，高并发的落地方案也会存在差异，但是总体的设计思路和可借鉴的方案基本类似。&lt;/p&gt;
&lt;p&gt;高并发设计同样要秉承架构设计的3个原则：简单、合适和演进。&quot;过早的优化是万恶之源&quot;，不能脱离业务的实际情况，更不要过度设计，合适的方案就是最完美的。&lt;/p&gt;
&lt;p&gt;希望这篇文章能带给你关于高并发更全面的认识，如果你也有可借鉴的经验和深入的思考，欢迎评论区留言讨论。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;作者简介：985硕士，前亚马逊工程师，现58转转技术总监。欢迎关注我的个人公众号：IT人的职场进阶&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 07 Nov 2020 15:22:00 +0000</pubDate>
<dc:creator>IT人的职场进阶</dc:creator>
<og:description>高并发，几乎是每个程序员都想拥有的经验。原因很简单：随着流量变大，会遇到各种各样的技术问题，比如接口响应超时、CPU load升高、GC频繁、死锁、大数据量存储等等，这些问题能推动我们在技术深度上不断</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/luojunwu/p/13942873.html</dc:identifier>
</item>
<item>
<title>1.深入Istio：Sidecar自动注入如何实现的？ - luozhiyun</title>
<link>http://www.cnblogs.com/luozhiyun/p/13942838.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/luozhiyun/p/13942838.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img.luozhiyun.com/20201107230410.jpg&quot; alt=&quot;80614165_p0_master1200&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5.75&quot;&gt;
&lt;p&gt;转载请声明出处哦~，本篇文章发布于luozhiyun的博客：&lt;a href=&quot;https://www.luozhiyun.com&quot;&gt;https://www.luozhiyun.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文使用的Istio源码是 release 1.5。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这篇文章打算讲一下sidecar，我在刚学习Istio的时候会有一些疑惑，sidecar是如何做到无感知的注入的，很多学习资料都没有详细去讲这部分的内容，下面打算解析一下。&lt;/p&gt;
&lt;h2 id=&quot;sidecar-介绍&quot;&gt;Sidecar 介绍&lt;/h2&gt;
&lt;p&gt;在Sidecar部署方式中会为每个应用的容器部署一个伴生容器。对于Istio，Sidecar接管进出应用程序容器的所有网络流量。&lt;/p&gt;
&lt;p&gt;使用 Sidecar 模式部署服务网格时，无需在节点上运行代理，但是集群中将运行多个相同的 Sidecar 副本。在 Kubernetes 的 Pod 中，在原有的应用容器旁边运行一个 Sidecar 容器，可以理解为两个容器共享存储、网络等资源，可以广义的将这个注入了 Sidecar 容器的 Pod 理解为一台主机，两个容器共享主机资源。&lt;/p&gt;
&lt;h3 id=&quot;sidecar-注入过程&quot;&gt;Sidecar 注入过程&lt;/h3&gt;
&lt;p&gt;注入 Sidecar的时候会在生成pod的时候附加上两个容器：istio-init、istio-proxy。istio-init这个容器从名字上看也可以知道它属于k8s中的Init Containers，主要用于设置iptables规则，让出入流量都转由 Sidecar 进行处理。istio-proxy是基于Envoy实现的一个网络代理容器，是真正的Sidecar，应用的流量会被重定向进入或流出Sidecar。&lt;/p&gt;
&lt;p&gt;我们在使用Sidecar自动注入的时候只需要给对应的应用部署的命名空间打个istio-injection=enabled标签，这个命名空间中新建的任何 Pod 都会被 Istio 注入 Sidecar。&lt;/p&gt;
&lt;p&gt;应用部署后我们可以通过kubectl describe查看pod内的容器：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt; [root@localhost ~]# kubectl describe pod details-v1-6c9f8bcbcb-shltm
 
 Name:         details-v1-6c9f8bcbcb-shltm
Namespace:    default
...
Labels:       app=details
              pod-template-hash=6c9f8bcbcb
              security.istio.io/tlsMode=istio
              service.istio.io/canonical-name=details
              service.istio.io/canonical-revision=v1
              version=v1
Annotations:  sidecar.istio.io/status:
                {&quot;version&quot;:&quot;3bc68d1f27d8b6b9bf1cb3e9904f5d5f8c2ecab1c93d933fbb3d0db76fae2633&quot;,&quot;initContainers&quot;:[&quot;istio-init&quot;],&quot;containers&quot;:[&quot;istio-proxy&quot;]...
Status:       Running
IP:           172.20.0.14
IPs:
  IP:           172.20.0.14
Controlled By:  ReplicaSet/details-v1-6c9f8bcbcb
Init Containers:
  istio-init:
    Container ID:  docker://6d14ccc83bd119236bf8fda13f6799609c87891be9b2c5af7cbf7d8c913ce17e
    Image:         docker.io/istio/proxyv2:1.5.10
    Image ID:      docker-pullable://istio/proxyv2@sha256:abbe8ad6d50474814f1aa9316dafc2401fbba89175638446f01afc36b5a37919
    ...
    Ready:          True
    Restart Count:  0
    ...
Containers:
  details:
    Container ID:   docker://ed216429216ea1b8a1ba20960590edb7322557467c38cceff3c3e847bcff0a14
    Image:          docker.io/istio/examples-bookinfo-details-v1:1.15.1
    Image ID:       docker-pullable://istio/examples-bookinfo-details-v1@sha256:344b1c18703ab1e51aa6d698f459c95ea734f8317d779189f4638de7a00e61ae
    ...
  istio-proxy:
    Container ID:  docker://a3862cc8f53198c8f86a911089e73e00f4cc4aa02eea05aaeb0bd267a8e98482
    Image:         docker.io/istio/proxyv2:1.5.10
    Image ID:      docker-pullable://istio/proxyv2@sha256:abbe8ad6d50474814f1aa9316dafc2401fbba89175638446f01afc36b5a37919
    ...
    Ready:          True
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;details-v1-6c9f8bcbcb-shltm这个应用是我们在上篇文章中创建的一个details服务，里面有istio-init、istio-proxy、details这三个container。&lt;/p&gt;
&lt;h2 id=&quot;sidecar-注入原理&quot;&gt;Sidecar 注入原理&lt;/h2&gt;
&lt;p&gt;Sidecar 注入主要是依托k8s的准入控制器Admission Controller来实现的。&lt;/p&gt;
&lt;p&gt;准入控制器会拦截 Kubernetes API Server 收到的请求，拦截发生在认证和鉴权完成之后，对象进行持久化之前。可以定义两种类型的 Admission webhook：Validating 和 Mutating。Validating 类型的 Webhook 可以根据自定义的准入策略决定是否拒绝请求；Mutating 类型的 Webhook 可以根据自定义配置来对请求进行编辑。&lt;/p&gt;
&lt;p&gt;我们可以看看配置详情：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;[root@localhost ~]# kubectl get mutatingwebhookconfiguration istio-sidecar-injector -o yaml

apiVersion: admissionregistration.k8s.io/v1
kind: MutatingWebhookConfiguration
metadata:
  annotations:
    ...
  creationTimestamp: &quot;2020-10-18T08:22:01Z&quot;
  generation: 2
  labels:
    app: sidecar-injector
    operator.istio.io/component: Pilot
    operator.istio.io/managed: Reconcile
    operator.istio.io/version: 1.5.10
    release: istio
  ... 
webhooks:
- admissionReviewVersions:
  - v1beta1
  clientConfig:
    caBundle: ...
    service:
      name: istiod
      namespace: istio-system
      path: /inject
      port: 443
  failurePolicy: Fail
  matchPolicy: Exact
  name: sidecar-injector.istio.io
  namespaceSelector:
    matchLabels:
      istio-injection: enabled
  rules:
  - apiGroups:
    - &quot;&quot;
    apiVersions:
    - v1
    operations:
    - CREATE
    resources:
    - pods
    scope: '*'
  ...
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里有一个namespaceSelector，match的标签是istio-injection: enabled的命名空间，请求规则rules是CREATE，表示匹配所有pod的创建请求。当apiserver收到一个符合规则的请求时，apiserver会给 Webhook 服务发送一个准入审核的请求，在上面的配置中webhook指定的是一个叫istiod的service。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;[root@localhost ~]# kubectl get svc --namespace=istio-system | grep istiod
istiod                      ClusterIP      10.68.222.38    &amp;lt;none&amp;gt;        15012/TCP,443/TCP
                                                  32h
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通常Sidecar注入由以下步骤完成：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;解析Webhook REST请求，将AdmissionReview原始数据反序列化；&lt;/li&gt;
&lt;li&gt;解析pod，将AdmissionReview中的AdmissionRequest反序列化；&lt;/li&gt;
&lt;li&gt;利用Pod及网格配置渲染Sidecar配置模板；&lt;/li&gt;
&lt;li&gt;利用Pod及渲染后的模板创建Json Patch；&lt;/li&gt;
&lt;li&gt;构造AdmissionResponse；&lt;/li&gt;
&lt;li&gt;构造AdmissionReview，将其发给apiserver；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;源码流程差不多是这个样子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.luozhiyun.com/20201107230416.png&quot; alt=&quot;image-20201107174326312&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面我们来看看源码。&lt;/p&gt;
&lt;p&gt;源码位置：pkg/kube/inject/webhook.go&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;func NewWebhook(p WebhookParameters) (*Webhook, error) {
    wh := &amp;amp;Webhook{
        ...
    }
        ...
        if p.Mux != nil {
                p.Mux.HandleFunc(&quot;/inject&quot;, wh.serveInject)
                mux = p.Mux
        } else {
                wh.server = &amp;amp;http.Server{
                        Addr: fmt.Sprintf(&quot;:%v&quot;, p.Port), 
                        TLSConfig: &amp;amp;tls.Config{GetCertificate: wh.getCert},
                }
                mux = http.NewServeMux()
                mux.HandleFunc(&quot;/inject&quot;, wh.serveInject)
                wh.server.Handler = mux
        }
        ...
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在初始化Webhook实例的时候会注册/inject对应的处理器，也就是当apiserver回调/inject请求的时候会调用到serveInject方法中。&lt;/p&gt;
&lt;p&gt;然后我们进入到serveInject方法中：&lt;/p&gt;
&lt;p&gt;文件位置：pkg/kube/inject/webhook.go&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;func (wh *Webhook) serveInject(w http.ResponseWriter, r *http.Request) {
        totalInjections.Increment()
        var body []byte
        if r.Body != nil {
                //读取请求体
                if data, err := ioutil.ReadAll(r.Body); err == nil {
                        body = data
                }
        }
        ... 
        var reviewResponse *v1beta1.AdmissionResponse
        ar := v1beta1.AdmissionReview{}
        //解码请求体
        if _, _, err := deserializer.Decode(body, nil, &amp;amp;ar); err != nil {
                handleError(fmt.Sprintf(&quot;Could not decode body: %v&quot;, err))
                reviewResponse = toAdmissionResponse(err)
        } else {
                //解码成功调用inject方法，并传入AdmissionReview
                reviewResponse = wh.inject(&amp;amp;ar)
        }
        //构建AdmissionReview作为参数返回给调用方
        response := v1beta1.AdmissionReview{}
        if reviewResponse != nil {
                response.Response = reviewResponse
                if ar.Request != nil {
                        response.Response.UID = ar.Request.UID
                }
        }

        resp, err := json.Marshal(response)
        if err != nil {
                log.Errorf(&quot;Could not encode response: %v&quot;, err)
                http.Error(w, fmt.Sprintf(&quot;could not encode response: %v&quot;, err), http.StatusInternalServerError)
        }
        if _, err := w.Write(resp); err != nil {
                log.Errorf(&quot;Could not write response: %v&quot;, err)
                http.Error(w, fmt.Sprintf(&quot;could not write response: %v&quot;, err), http.StatusInternalServerError)
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个方法很简单，主要就是读取请求体并解码，然后调用inject方法，构建AdmissionReview作为参数返回给调用方。&lt;/p&gt;
&lt;p&gt;主要逻辑从这里可以看出都在inject方法里面，下面看看这个方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;func (wh *Webhook) inject(ar *v1beta1.AdmissionReview) *v1beta1.AdmissionResponse {
        req := ar.Request
        var pod corev1.Pod
        //json反序列化请求数据
        if err := json.Unmarshal(req.Object.Raw, &amp;amp;pod); err != nil {
                handleError(fmt.Sprintf(&quot;Could not unmarshal raw object: %v %s&quot;, err,
                        string(req.Object.Raw)))
                return toAdmissionResponse(err)
        }

        ...
        //封装模板数据
        spec, iStatus, err := InjectionData(wh.Config.Template, wh.valuesConfig, wh.sidecarTemplateVersion, typeMetadata, deployMeta, &amp;amp;pod.Spec, &amp;amp;pod.ObjectMeta, wh.meshConfig.DefaultConfig, wh.meshConfig) // nolint: lll
        if err != nil {
                handleError(fmt.Sprintf(&quot;Injection data: err=%v spec=%v\n&quot;, err, iStatus))
                return toAdmissionResponse(err)
        } 
        ...
        //将需要注入的有istio-init/istio-proxy container封装成patch操作
        //具体可以看这里:https://kubernetes.io/zh/docs/reference/access-authn-authz/extensible-admission-controllers/#response
        patchBytes, err := createPatch(&amp;amp;pod, injectionStatus(&amp;amp;pod), annotations, spec, deployMeta.Name)
        if err != nil {
                handleError(fmt.Sprintf(&quot;AdmissionResponse: err=%v spec=%v\n&quot;, err, spec))
                return toAdmissionResponse(err)
        }

        log.Debugf(&quot;AdmissionResponse: patch=%v\n&quot;, string(patchBytes))
        //将需要patch的配置封装成AdmissionResponse返回
        reviewResponse := v1beta1.AdmissionResponse{
                Allowed: true,
                Patch:   patchBytes,
                PatchType: func() *v1beta1.PatchType {
                        pt := v1beta1.PatchTypeJSONPatch
                        return &amp;amp;pt
                }(),
        }
        totalSuccessfulInjections.Increment()
        return &amp;amp;reviewResponse
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;inject方法逻辑主要分为以下几个步骤：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;json反序列化请求数据到pod中；&lt;/li&gt;
&lt;li&gt;调用InjectionData根据模板封装数据，主要是构造istio-init、istio-proxy等容器配置；&lt;/li&gt;
&lt;li&gt;调用createPatch方法将模板数据转化成json形式，到时候在创建容器的时候会patch到创建容器的配置中，具体可以看这里：&lt;a href=&quot;https://kubernetes.io/zh/docs/reference/access-authn-authz/extensible-admission-controllers/#response&quot;&gt;https://kubernetes.io/zh/docs/reference/access-authn-authz/extensible-admission-controllers/#response&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;最后将数据封装成AdmissionResponse返回；&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;本篇文章重点讲解Sidecar容器注入实现原理，通过使用k8s的准入控制器来做到在每个新建的pod里面都无感知的创建sidecar做流量托管。&lt;/p&gt;
&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/istio/istio.io/blob/release-1.1/content/blog/2019/data-plane-setup/index.md&quot;&gt;https://github.com/istio/istio.io/blob/release-1.1/content/blog/2019/data-plane-setup/index.md&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/&quot;&gt;https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/&quot;&gt;https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://jimmysong.io/blog/envoy-sidecar-injection-in-istio-service-mesh-deep-dive/&quot;&gt;https://jimmysong.io/blog/envoy-sidecar-injection-in-istio-service-mesh-deep-dive/&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 07 Nov 2020 15:07:00 +0000</pubDate>
<dc:creator>luozhiyun</dc:creator>
<og:description>转载请声明出处哦~，本篇文章发布于luozhiyun的博客：https://www.luozhiyun.com 本文使用的Istio源码是 release 1.5。 这篇文章打算讲一下sidecar，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/luozhiyun/p/13942838.html</dc:identifier>
</item>
<item>
<title>c# 表达式树（一） - 梦里小探花</title>
<link>http://www.cnblogs.com/aoximin/p/13942812.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/aoximin/p/13942812.html</guid>
<description>&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;打算整理c# 代码简化史系列，所以相关的整理一下，简单的引出一下概念。&lt;/p&gt;
&lt;p&gt;什么是表达式树呢?&lt;/p&gt;
&lt;p&gt;表达式树以树形数据结构表示代码，其中每一个节点都是一种表达式，比如方法调用和 x &amp;lt; y 这样的二元运算等。&lt;/p&gt;
&lt;p&gt;这个是什么意思呢？用结构表示代码？ 用静态的表示动态的，一般来说是某种约定。&lt;/p&gt;
&lt;p&gt;比如计算机中的强弱电路，可能这样不好理解。举一个盒子的例子:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1289794/202011/1289794-20201107203552648-1337324827.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;假设我要计算加法，那么如果表示加法呢？我用一个盒型结构，把第一个数放在第一个位置，把第二个数放在第二个位置，然后第三个位置我传入方法，表示第一个和第二个会执行第三个位置的方法，在这里呢，还是结构，因为并没有去运行，只是说组合了这样一种结构。&lt;/p&gt;
&lt;p&gt;现在呢，假设按照某种约定组合成一种结构，那么这种就称为表达式，就是用来表示某种情况的嘛。然后呢，现在这种表达式是树，那么就叫表达式树了。&lt;/p&gt;
&lt;p&gt;这里介绍一下表达式，来增强一波:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1289794/202011/1289794-20201107204033289-909454172.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后再来透析一波:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1289794/202011/1289794-20201107204725327-2067257976.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;正文&quot;&gt;正文&lt;/h3&gt;
&lt;p&gt;用一个例子来表示正则表达吧,例子是官网的，但是官网解释的比较含糊，所以再来解释一波吧。&lt;/p&gt;
&lt;p&gt;官网用的一个例子是:Where(company =&amp;gt; (company.ToLower() == &quot;coho winery&quot; || company.Length &amp;gt; 16)).orderby(company=&amp;gt;company)&lt;/p&gt;
&lt;p&gt;那么来看一下吧:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;string[] companies = { &quot;Consolidated Messenger&quot;, &quot;Alpine Ski House&quot;, &quot;Southridge Video&quot;, &quot;City Power &amp;amp; Light&quot;,
           &quot;Coho Winery&quot;, &quot;Wide World Importers&quot;, &quot;Graphic Design Institute&quot;, &quot;Adventure Works&quot;,
           &quot;Humongous Insurance&quot;, &quot;Woodgrove Bank&quot;, &quot;Margie's Travel&quot;, &quot;Northwind Traders&quot;,
           &quot;Blue Yonder Airlines&quot;, &quot;Trey Research&quot;, &quot;The Phone Company&quot;,
           &quot;Wingtip Toys&quot;, &quot;Lucerne Publishing&quot;, &quot;Fourth Coffee&quot; };

// The IQueryable data to query.  
IQueryable&amp;lt;String&amp;gt; queryableData = companies.AsQueryable&amp;lt;string&amp;gt;();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有一个数组，然后转换成IQueryable 格式，这么做的目的其实就是因为queryable 实现了一些expression的属性。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1289794/202011/1289794-20201107214502040-1960985937.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;好吧，暂时就不解释这几个参数的作用，后面看下去自然就明白了。&lt;/p&gt;
&lt;p&gt;接着放代码:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ParameterExpression pe = Expression.Parameter(typeof(string), &quot;company&quot;);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个意思就是说创建了一个属性是company的变量，相当于我们以前的xy，名字随便取。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Expression left = Expression.Call(pe, typeof(string).GetMethod(&quot;ToLower&quot;, System.Type.EmptyTypes));
Expression right = Expression.Constant(&quot;coho winery&quot;);
Expression e1 = Expression.Equal(left, right);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为其实树结构，那么这里的参数left就是左子树，right 就是右子树。&lt;/p&gt;
&lt;p&gt;left 呢，这个call 就是说pe（也就是company变量）将会执行一个方法，ToLower,对应的就是company.ToLower()。&lt;/p&gt;
&lt;p&gt;然后右边就是一个固定的参数coho winery，现在的表达式就是company.ToLower()=='coho winery',返回的是一个bool类型。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;left = Expression.Property(pe, typeof(string).GetProperty(&quot;Length&quot;));
right = Expression.Constant(16, typeof(int));
Expression e2 = Expression.GreaterThan(left, right);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来就是就是获取compay的属性Length，然后和int 类型相比，就是conpany.length&amp;gt;16&lt;br/&gt;Expression predicateBody = Expression.OrElse(e1, e2);&lt;br/&gt;那么就是e1和e2相连，中间用的是or,company.ToLower() == &quot;coho winery&quot; || company.Length &amp;gt; 16 好的现在表达式完了，那么如何和数据联系在一起呢？&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Create an expression tree that represents the expression  
// 'queryableData.Where(company =&amp;gt; (company.ToLower() == &quot;coho winery&quot; || company.Length &amp;gt; 16))'  
MethodCallExpression whereCallExpression = Expression.Call(
        typeof(Queryable),
        &quot;Where&quot;,
        new Type[] { queryableData.ElementType },
        queryableData.Expression,
        Expression.Lambda&amp;lt;Func&amp;lt;string, bool&amp;gt;&amp;gt;(predicateBody, new ParameterExpression[] { pe }));
// ***** End Where *****  

// ***** OrderBy(company =&amp;gt; company) *****  
// Create an expression tree that represents the expression  
// 'whereCallExpression.OrderBy(company =&amp;gt; company)'  
MethodCallExpression orderByCallExpression = Expression.Call(
        typeof(Queryable),
        &quot;OrderBy&quot;,
        new Type[] { queryableData.ElementType, queryableData.ElementType },
        whereCallExpression,
        Expression.Lambda&amp;lt;Func&amp;lt;string, string&amp;gt;&amp;gt;(pe, new ParameterExpression[] { pe }));
// ***** End OrderBy *****  

// Create an executable query from the expression tree.  
IQueryable&amp;lt;string&amp;gt; results = queryableData.Provider.CreateQuery&amp;lt;string&amp;gt;(orderByCallExpression);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;whereCallExpression 和 orderByCallExpression 表示要执行的操作，用whereCallExpression 举例目标类型是Queryable，调用where，然后表达式是predicateBody，参数是pe。&lt;/p&gt;
&lt;p&gt;orderByCallExpression 类推。&lt;/p&gt;
&lt;p&gt;最后一步就是传递表达:IQueryable results = queryableData.Provider.CreateQuery(orderByCallExpression);&lt;/p&gt;
&lt;p&gt;里面的实现是非常复杂的，我自己也没有去看，因为觉得没有必要，这种东西就是一个工具，谁要是这样写，那可正是思维逻辑不是一般的强，一般来说和汇编差不多。&lt;/p&gt;
&lt;p&gt;需要明白的就是它不会立即去执行，而是就是一个表达式和其紧密连接。有兴趣可以去了解iqueryable的实现，复杂的一批。&lt;/p&gt;
&lt;p&gt;那么不管其多么复杂，就是本质上就是制定一套规则，我们按照它这个规则然后给我们填充，那么就会对应相应的结果给我们，我们可能设计不出这么好的表达式，但是有时候我们也会去制作相应的规则，比如说某种格式等，但你不要去想想它的代码多优雅，因为其稳定性很高，不需要追求优雅。&lt;/p&gt;
&lt;p&gt;那么我们为了延后实现，我们就要去这样做吗？如果这样做的话，我想很多人会设计出另外一套，没有这么繁琐，可能就是几个参数，然后一个委托组合成一颗树，虽然很大的局限性，但是写这样的代码真的痛苦。&lt;/p&gt;
&lt;p&gt;这个时候人们就想有没有什么能中间转换一下的呢？比如说我写一串字符，然后我就自动按照某种规则去解析不就可以了，但是这种有一个很不好的地方在于，字符串是弱类型调试相当麻烦，这时候就瞄准好了lambda了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;若 lambda 表达式被分配给 Expression&amp;lt;TDelegate&amp;gt; 类型的变量，则编译器可以发射代码以创建表示该 lambda 表达式的表达式树。

C# 编译器只能从表达式 Lambda（或单行 Lambda）生成表达式树。 它无法解析语句 lambda （或多行 lambda）。
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;举个例子:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Expression&amp;lt;Func&amp;lt;int, bool&amp;gt;&amp;gt; lambda = num =&amp;gt; num &amp;lt; 5;  
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;就可以使用lambda表达式进行一个expression的转换。&lt;/p&gt;
&lt;p&gt;从Expression到Expression 之间呢，还有一层，他们的继承关系是&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; Object
 Expression
 LambdaExpression
 Expression&amp;lt;TDelegate&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;很多时候lambda 表达式转换的表达式就可以为我们解决大部分问题，但是不要觉得这是Expression的全部，因为转换的只有一行，然后expression还有很多是无法用lambda来表示的。&lt;/p&gt;
&lt;h3 id=&quot;续&quot;&gt;续&lt;/h3&gt;
&lt;p&gt;未完待续。&lt;/p&gt;
</description>
<pubDate>Sat, 07 Nov 2020 14:55:00 +0000</pubDate>
<dc:creator>梦里小探花</dc:creator>
<og:description>前言 打算整理c# 代码简化史系列，所以相关的整理一下，简单的引出一下概念。 什么是表达式树呢? 表达式树以树形数据结构表示代码，其中每一个节点都是一种表达式，比如方法调用和 x &amp;amp;lt; y</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/aoximin/p/13942812.html</dc:identifier>
</item>
</channel>
</rss>