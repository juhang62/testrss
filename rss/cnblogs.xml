<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>List、Set集合系列之剖析HashSet存储原理（HashMap底层） - 宜春</title>
<link>http://www.cnblogs.com/yichunguo/p/11809866.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yichunguo/p/11809866.html</guid>
<description>&lt;p&gt;前言&lt;/p&gt;
&lt;p&gt;在之前的博客文章中已经介绍了Collection接口使用，本篇将介绍Collection接口中的子类的用法，至于为啥要讲它的子类这种小白问题就不要问我了。啥？有小白在看我写的文章...不好意思不好意思，原谅我刚才说的话，请允许博主我重新组织一下语言...咳咳，至于&lt;strong&gt;为啥要讲Collection接口的子类呢&lt;/strong&gt;？小白童鞋啊，Collection接口他是接口哇，接口的目的是啥？就是定义一套规范，没有具体类去实现接口，接口就毫无意义了！小白童鞋你何什左咩鸭。&lt;/p&gt;
&lt;p&gt;还有一点就是如果对Collection接口还不熟悉的小白童鞋&lt;strong&gt;强烈建议&lt;/strong&gt;先去了解Collection接口之后再看这篇文章，不然只会&lt;span&gt;&lt;strong&gt;事倍功半&lt;/strong&gt;&lt;/span&gt;！好吧，我就知道就是博主我强烈建议过了肯定还有小白童鞋不去找，没事，博主没别的目的，就是想让小白童鞋好好学java，所以我已经准备好了下面这篇文章~点击蓝色字体即可进入~&lt;a href=&quot;https://blog.csdn.net/qq_44543508/article/details/102173065&quot;&gt;Collection集合以及Iterator迭代器实现原理&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;@&lt;/p&gt;

&lt;p&gt;接下来，我们一起学习Collection中的常用两个子类&lt;code&gt;java.util.List&lt;/code&gt;集合、&lt;code&gt;java.util.Set&lt;/code&gt;集合。&lt;/p&gt;
&lt;h2 id=&quot;list接口介绍&quot;&gt;1.1 List接口介绍&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;java.util.List&lt;/code&gt;接口继承自&lt;code&gt;Collection&lt;/code&gt;接口，在List集合&lt;span&gt;&lt;strong&gt;元素可重复&lt;/strong&gt;&lt;/span&gt;、&lt;span&gt;&lt;strong&gt;元素有序&lt;/strong&gt;&lt;/span&gt;。所有的元素是以一种线性方式进行存储的，在程序中可以通过索引来访问集合中的指定元素，而且元素的存入顺序和取出顺序一致。&lt;/p&gt;
&lt;p&gt;List接口特点分析：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;元素存取有序&lt;/strong&gt;：例如，存元素的顺序是“我”、“是”、“佩”、“奇”，那么集合中，元素的存储就是按照“我”、“是”、“佩”、“奇”的顺序完成的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;带有索引的集合&lt;/strong&gt;：与数组的索引是一个道理&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;元素重复&lt;/strong&gt;：通过元素的&lt;code&gt;equals&lt;/code&gt;方法，来比较是否为重复的元素。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;h2 id=&quot;list接口中常用方法&quot;&gt;1.2 List接口中常用方法&lt;/h2&gt;
&lt;p&gt;List作为Collection集合的子接口，不但继承了Collection接口中的全部方法，还有一些根据&lt;span&gt;&lt;strong&gt;元素索引&lt;/strong&gt;&lt;/span&gt;来&lt;span&gt;&lt;strong&gt;操作集合&lt;/strong&gt;&lt;/span&gt;的&lt;span&gt;&lt;strong&gt;特有&lt;/strong&gt;&lt;/span&gt;方法，如下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;public void add(int index, E element)&lt;/code&gt;: 将指定的元素，添加到该集合中的指定位置上。- &lt;code&gt;public E get(int index)&lt;/code&gt;:返回集合中指定位置的元素。&lt;br/&gt;&lt;code&gt;public E remove(int index)&lt;/code&gt;: 移除列表中指定位置的元素, 返回的是被移除的元素。&lt;br/&gt;&lt;code&gt;public E set(int index, E element)&lt;/code&gt;:用指定元素替换集合中指定位置的元素,返回值的更新前的元素。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;List集合特有的方法都是跟索引相关&lt;/strong&gt;&lt;/span&gt;，代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class ListDemo {
    public static void main(String[] args) {
        // 创建List集合对象
        List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;String&amp;gt;();
        
        // 往 尾部添加 指定元素
        list.add(&quot;安琪拉屎&quot;);
        list.add(&quot;刘备胎&quot;);
        list.add(&quot;廉颇妇&quot;);
        
        System.out.println(list);
        // add(int index,String s) 往指定位置添加
        list.add(1,&quot;猪脚亮&quot;);
        
        System.out.println(list);
        // String remove(int index) 删除指定位置元素  返回被删除元素
        // 删除索引位置为2的元素 
        System.out.println(&quot;删除索引位置为2的元素&quot;);
        System.out.println(list.remove(2));
        
        System.out.println(list);
        
        // String set(int index,String s)
        // 在指定位置 进行 元素替代（改） 
        // 修改指定位置元素
        list.set(0, &quot;东皇太二&quot;);
        System.out.println(list);
        
        // String get(int index)  获取指定位置元素
        
        // 跟size() 方法一起用  来 遍历的 
        for(int i = 0;i&amp;lt;list.size();i++){
            System.out.println(list.get(i));
        }
        //还可以使用增强for
        for (String string : list) {
            System.out.println(string);
        }   
    }
}&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;arraylist集合&quot;&gt;2.1 ArrayList集合&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;java.util.ArrayList&lt;/code&gt;集合数据存储的结构是&lt;span&gt;&lt;strong&gt;数组&lt;/strong&gt;&lt;/span&gt;结构。元素&lt;span&gt;&lt;strong&gt;增删慢，查找快&lt;/strong&gt;&lt;/span&gt;，由于日常开发中使用最多的功能为查询数据、遍历数据，所以&lt;code&gt;ArrayList&lt;/code&gt;是最常用的集合。&lt;/p&gt;
&lt;h2 id=&quot;linkedlist集合&quot;&gt;2.2 LinkedList集合&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;java.util.LinkedList&lt;/code&gt;集合数据存储的结构是&lt;span&gt;&lt;strong&gt;链表&lt;/strong&gt;&lt;/span&gt;结构。元素&lt;span&gt;&lt;strong&gt;增删快，查找慢&lt;/strong&gt;&lt;/span&gt;的集合。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;LinkedList是一个双向链表，那么双向链表是什么样子的呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191018145416654.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;实际开发中对一个集合元素的添加与删除经常涉及到首尾操作，而LinkedList提供了大量首尾操作的方法。下面这些方法我们作为&lt;strong&gt;了解即可&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;public void addFirst(E e)&lt;/code&gt;:将指定元素插入此列表的开头。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;public void addLast(E e)&lt;/code&gt;:将指定元素添加到此列表的结尾。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;public E getFirst()&lt;/code&gt;:返回此列表的第一个元素。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;public E getLast()&lt;/code&gt;:返回此列表的最后一个元素。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;public E removeFirst()&lt;/code&gt;:移除并返回此列表的第一个元素。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;public E removeLast()&lt;/code&gt;:移除并返回此列表的最后一个元素。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;public E pop()&lt;/code&gt;:从此列表所表示的堆栈处弹出一个元素。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;public void push(E e)&lt;/code&gt;:将元素推入此列表所表示的堆栈。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;public boolean isEmpty()&lt;/code&gt;：如果列表不包含元素，则返回true。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;LinkedList是List的子类，List中的方法LinkedList都是可以使用，这里就不做详细介绍，我们只需要了解LinkedList的特有方法即可。在开发时，LinkedList集合也可以作为堆栈，队列的结构使用。（了解即可）&lt;/p&gt;
&lt;p&gt;方法代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class LinkedListDemo {
    public static void main(String[] args) {
        LinkedList&amp;lt;String&amp;gt; link = new LinkedList&amp;lt;String&amp;gt;();
        //添加元素
        link.addFirst(&quot;大乔&quot;);
        link.addFirst(&quot;小桥&quot;);
        link.addFirst(&quot;老乔&quot;);
        System.out.println(link);
        // 获取元素
        System.out.println(link.getFirst());
        System.out.println(link.getLast());
        // 删除元素
        System.out.println(link.removeFirst());
        System.out.println(link.removeLast());

        while (!link.isEmpty()) { //判断集合是否为空
            System.out.println(link.pop()); //弹出集合中的栈顶元素
        }

        System.out.println(link);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;好了，到这里，list集合就先告一段落。&lt;/p&gt;

&lt;h2 id=&quot;set接口介绍&quot;&gt;3.1 Set接口介绍&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;java.util.Set&lt;/code&gt;接口和&lt;code&gt;java.util.List&lt;/code&gt;接口一样，同样继承自&lt;code&gt;Collection&lt;/code&gt;接口，它与&lt;code&gt;Collection&lt;/code&gt;接口中的方法基本一致，并没有对&lt;code&gt;Collection&lt;/code&gt;接口进行功能上的扩充，只是比&lt;code&gt;Collection&lt;/code&gt;接口更加严格了。与&lt;code&gt;List&lt;/code&gt;接口不同的是，&lt;code&gt;Set&lt;/code&gt;接口中&lt;span&gt;&lt;strong&gt;元素无序&lt;/strong&gt;&lt;/span&gt;且&lt;span&gt;&lt;strong&gt;不重复&lt;/strong&gt;&lt;/span&gt;，刚好全&lt;span&gt;&lt;strong&gt;与list相反&lt;/strong&gt;&lt;/span&gt;，set会以某种规则保证存入的元素不出现重复。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Set&lt;/code&gt;集合有多个子类，这里我们介绍其中的&lt;code&gt;java.util.HashSet&lt;/code&gt;、&lt;code&gt;java.util.LinkedHashSet&lt;/code&gt;这两个集合。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Set集合取出元素的方式可以采用：迭代器、增强for。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;hashset集合介绍&quot;&gt;4.1 HashSet集合介绍&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;java.util.HashSet&lt;/code&gt;是&lt;code&gt;Set&lt;/code&gt;接口的一个&lt;span&gt;&lt;strong&gt;实现类&lt;/strong&gt;&lt;/span&gt;，它所存储的元素是&lt;span&gt;&lt;strong&gt;不可重复、无序&lt;/strong&gt;&lt;/span&gt;(即存取顺序不一致)。&lt;code&gt;java.util.HashSet&lt;/code&gt;底层的实现其实是一个&lt;code&gt;java.util.HashMap&lt;/code&gt;支持。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;HashSet&lt;/code&gt;是根据对象的哈希值来确定元素在集合中的存储位置，因此具有良好的存取和查找性能。保证元素唯一性的方式依赖于：&lt;code&gt;hashCode&lt;/code&gt;与&lt;code&gt;equals&lt;/code&gt;方法。&lt;/p&gt;
&lt;p&gt;我们先来使用一下Set集合存储，看下现象，再进行原理的讲解:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class HashSetDemo {
    public static void main(String[] args) {
        //创建 Set集合
        HashSet&amp;lt;String&amp;gt;  set = new HashSet&amp;lt;String&amp;gt;();

        //添加元素
        set.add(new String(&quot;安琪拉屎&quot;));
        set.add(&quot;刘备胎&quot;);
        set.add(&quot;猪八戒烟&quot;); 
        set.add(&quot;安琪拉屎&quot;);  
        //遍历
        for (String name : set) {
            System.out.println(name);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果如下，说明集合中不能存储重复元素：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;安琪拉屎
刘备胎
猪八戒烟&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;根据结果我们发现字符串 &quot;安琪拉屎&quot; 只存储了一个，也就是说重复的元素set集合不存储。&lt;/p&gt;
&lt;h2 id=&quot;hashset集合存储数据的结构哈希表&quot;&gt;4.2 HashSet集合存储数据的结构（哈希表）&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;什么是哈希表呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在&lt;strong&gt;JDK1.8&lt;/strong&gt;之前，&lt;span&gt;&lt;strong&gt;哈希表底层采用数组+链表实现&lt;/strong&gt;&lt;/span&gt;，即使用链表处理冲突，同一hash值的链表都存储在一个链表里。但是当位于一个桶中的元素较多，即hash值相等的元素较多时，通过key值依次查找的效率较低。而&lt;strong&gt;JDK1.8中&lt;/strong&gt;，&lt;span&gt;&lt;strong&gt;哈希表存储采用数组+链表+红黑树实现&lt;/strong&gt;&lt;/span&gt;，当链表长度超过阈值（8）时，将链表转换为红黑树，这样大大减少了查找时间。&lt;/p&gt;
&lt;p&gt;简单的来说，哈希表是由数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的，如下图所示。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191018151954730.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;看到这张图就有童鞋要问了，这个是怎么存储的呢？看下图就明白了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191018152531518.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;总而言之，&lt;strong&gt;JDK1.8&lt;/strong&gt;引入红黑树大程度优化了HashMap的性能，那么对于我们来讲保证HashSet集合元素的唯一，其实就是根据对象的hashCode和equals方法来决定的。如果我们往集合中存放自定义的对象，那么保证其唯一，就必须复写hashCode和equals方法建立属于当前对象的比较方式。&lt;/p&gt;
&lt;p&gt;至于数据结构关于数组以及链表我之前写过，为了方便各位阅读，我就贴在下面了&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/qq_44543508/article/details/100033998&quot;&gt;【数据结构01】浅谈数组&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/qq_44543508/article/details/100522120&quot;&gt;【数据结构03】浅谈链表&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;啥？还要看红黑树？额...暂时还没写，如果不是特别急着看博主就往后推一点写，~毕竟忙嘛~ 实在急着看博主尽量抽空写一篇出来...&lt;/p&gt;
&lt;h2 id=&quot;源码分析&quot;&gt;4.3源码分析&lt;/h2&gt;
&lt;p&gt;QnQ&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;public class HashSet&amp;lt;E&amp;gt;  
    extends AbstractSet&amp;lt;E&amp;gt;  
    implements Set&amp;lt;E&amp;gt;, Cloneable, java.io.Serializable  
{  
    static final long serialVersionUID = -5024744406713321676L;  
 
    // 底层使用HashMap来保存HashSet中所有元素。  
    private transient HashMap&amp;lt;E,Object&amp;gt; map;  
 
    // 定义一个虚拟的Object对象作为HashMap的value，将此对象定义为static final。  
    private static final Object PRESENT = new Object();  
 
    /** 
     * 默认的无参构造器，构造一个空的HashSet。 
     *  
     * 实际底层会初始化一个空的HashMap，并使用默认初始容量为16和加载因子0.75。 
     */  
    public HashSet() {  
    map = new HashMap&amp;lt;E,Object&amp;gt;();  
    }  
 
    /** 
     * 构造一个包含指定collection中的元素的新set。 
     * 
     * 实际底层使用默认的加载因子0.75和足以包含指定 
     * collection中所有元素的初始容量来创建一个HashMap。 
     * @param c 其中的元素将存放在此set中的collection。 
     */  
    public HashSet(Collection&amp;lt;? extends E&amp;gt; c) {  
    map = new HashMap&amp;lt;E,Object&amp;gt;(Math.max((int) (c.size()/.75f) + 1, 16));  
    addAll(c);  
    }  
 
    /** 
     * 以指定的initialCapacity和loadFactor构造一个空的HashSet。 
     * 
     * 实际底层以相应的参数构造一个空的HashMap。 
     * @param initialCapacity 初始容量。 
     * @param loadFactor 加载因子。 
     */  
    public HashSet(int initialCapacity, float loadFactor) {  
    map = new HashMap&amp;lt;E,Object&amp;gt;(initialCapacity, loadFactor);  
    }  
 
    /** 
     * 以指定的initialCapacity构造一个空的HashSet。 
     * 
     * 实际底层以相应的参数及加载因子loadFactor为0.75构造一个空的HashMap。 
     * @param initialCapacity 初始容量。 
     */  
    public HashSet(int initialCapacity) {  
    map = new HashMap&amp;lt;E,Object&amp;gt;(initialCapacity);  
    }  
 
    /** 
     * 以指定的initialCapacity和loadFactor构造一个新的空链接哈希集合。 
     * 此构造函数为包访问权限，不对外公开，实际只是是对LinkedHashSet的支持。 
     * 
     * 实际底层会以指定的参数构造一个空LinkedHashMap实例来实现。 
     * @param initialCapacity 初始容量。 
     * @param loadFactor 加载因子。 
     * @param dummy 标记。 
     */  
    HashSet(int initialCapacity, float loadFactor, boolean dummy) {  
    map = new LinkedHashMap&amp;lt;E,Object&amp;gt;(initialCapacity, loadFactor);  
    }  
 
    /** 
     * 返回对此set中元素进行迭代的迭代器。返回元素的顺序并不是特定的。 
     *  
     * 底层实际调用底层HashMap的keySet来返回所有的key。 
     * 可见HashSet中的元素，只是存放在了底层HashMap的key上， 
     * value使用一个static final的Object对象标识。 
     * @return 对此set中元素进行迭代的Iterator。 
     */  
    public Iterator&amp;lt;E&amp;gt; iterator() {  
    return map.keySet().iterator();  
    }  
 
    /** 
     * 返回此set中的元素的数量（set的容量）。 
     * 
     * 底层实际调用HashMap的size()方法返回Entry的数量，就得到该Set中元素的个数。 
     * @return 此set中的元素的数量（set的容量）。 
     */  
    public int size() {  
    return map.size();  
    }  
 
    /** 
     * 如果此set不包含任何元素，则返回true。 
     * 
     * 底层实际调用HashMap的isEmpty()判断该HashSet是否为空。 
     * @return 如果此set不包含任何元素，则返回true。 
     */  
    public boolean isEmpty() {  
    return map.isEmpty();  
    }  
 
    /** 
     * 如果此set包含指定元素，则返回true。 
     * 更确切地讲，当且仅当此set包含一个满足(o==null ? e==null : o.equals(e)) 
     * 的e元素时，返回true。 
     * 
     * 底层实际调用HashMap的containsKey判断是否包含指定key。 
     * @param o 在此set中的存在已得到测试的元素。 
     * @return 如果此set包含指定元素，则返回true。 
     */  
    public boolean contains(Object o) {  
    return map.containsKey(o);  
    }  
 
    /** 
     * 如果此set中尚未包含指定元素，则添加指定元素。 
     * 更确切地讲，如果此 set 没有包含满足(e==null ? e2==null : e.equals(e2)) 
     * 的元素e2，则向此set 添加指定的元素e。 
     * 如果此set已包含该元素，则该调用不更改set并返回false。 
     * 
     * 底层实际将将该元素作为key放入HashMap。 
     * 由于HashMap的put()方法添加key-value对时，当新放入HashMap的Entry中key 
     * 与集合中原有Entry的key相同（hashCode()返回值相等，通过equals比较也返回true）， 
     * 新添加的Entry的value会将覆盖原来Entry的value，但key不会有任何改变， 
     * 因此如果向HashSet中添加一个已经存在的元素时，新添加的集合元素将不会被放入HashMap中， 
     * 原来的元素也不会有任何改变，这也就满足了Set中元素不重复的特性。 
     * @param e 将添加到此set中的元素。 
     * @return 如果此set尚未包含指定元素，则返回true。 
     */  
    public boolean add(E e) {  
    return map.put(e, PRESENT)==null;  
    }  
 
    /** 
     * 如果指定元素存在于此set中，则将其移除。 
     * 更确切地讲，如果此set包含一个满足(o==null ? e==null : o.equals(e))的元素e， 
     * 则将其移除。如果此set已包含该元素，则返回true 
     * （或者：如果此set因调用而发生更改，则返回true）。（一旦调用返回，则此set不再包含该元素）。 
     * 
     * 底层实际调用HashMap的remove方法删除指定Entry。 
     * @param o 如果存在于此set中则需要将其移除的对象。 
     * @return 如果set包含指定元素，则返回true。 
     */  
    public boolean remove(Object o) {  
    return map.remove(o)==PRESENT;  
    }  
 
    /** 
     * 从此set中移除所有元素。此调用返回后，该set将为空。 
     * 
     * 底层实际调用HashMap的clear方法清空Entry中所有元素。 
     */  
    public void clear() {  
    map.clear();  
    }  
 
    /** 
     * 返回此HashSet实例的浅表副本：并没有复制这些元素本身。 
     * 
     * 底层实际调用HashMap的clone()方法，获取HashMap的浅表副本，并设置到HashSet中。 
     */  
    public Object clone() {  
        try {  
            HashSet&amp;lt;E&amp;gt; newSet = (HashSet&amp;lt;E&amp;gt;) super.clone();  
            newSet.map = (HashMap&amp;lt;E, Object&amp;gt;) map.clone();  
            return newSet;  
        } catch (CloneNotSupportedException e) {  
            throw new InternalError();  
        }  
    }  
}  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;说白了，HashSet就是限制了功能的HashMap，所以了解HashMap的实现原理，这个HashSet自然就通,对于HashSet中保存的对象，主要要正确重写equals方法和hashCode方法，以保证放入Set对象的唯一性,&lt;strong&gt;虽说是Set是对于重复的元素不放入，倒不如直接说是底层的Map直接把原值替代了&lt;/strong&gt;（这个Set的put方法的返回值真有意思）。HashSet没有提供get()方法，愿意是同HashMap一样，Set内部是无序的，只能通过迭代的方式获得。&lt;/p&gt;
&lt;h2 id=&quot;hashset存储自定义类型元素&quot;&gt;4.4 HashSet存储自定义类型元素&lt;/h2&gt;
&lt;p&gt;给HashSet中存放自定义类型元素时，需要重写对象中的&lt;code&gt;hashCode&lt;/code&gt;和&lt;code&gt;equals&lt;/code&gt;方法，建立自己的比较方式，才能保证&lt;code&gt;HashSet&lt;/code&gt;集合中的对象唯一&lt;/p&gt;
&lt;p&gt;创建自定义Student类&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Student {
    private String name;
    private int age;

    public Student() {
    }

    public Student(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o)
            return true;
        if (o == null || getClass() != o.getClass())
            return false;
        Student student = (Student) o;
        return age == student.age &amp;amp;&amp;amp;
               Objects.equals(name, student.name);
    }

    @Override
    public int hashCode() {
        return Objects.hash(name, age);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class HashSetDemo2 {
    public static void main(String[] args) {
        //创建集合对象   该集合中存储 Student类型对象
        HashSet&amp;lt;Student&amp;gt; stuSet = new HashSet&amp;lt;Student&amp;gt;();
        //存储 
        Student stu = new Student(&quot;程序员老王&quot;, 43);
        stuSet.add(stu);
        stuSet.add(new Student(&quot;程序员小王&quot;, 44));
        stuSet.add(new Student(&quot;程序员老王&quot;, 43));
        stuSet.add(new Student(&quot;程序员秃头哥&quot;, 23));
        stuSet.add(stu);

        for (Student stud : stuSet) {
            System.out.println(stud);
        }
    }
}
执行结果：
Student [name=程序员小王, age=44]
Student [name=程序员老王, age=43]
Student [name=程序员秃头哥, age=23]&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;linkedhashset&quot;&gt;4.5 LinkedHashSet&lt;/h2&gt;
&lt;p&gt;我们知道HashSet保证元素唯一，可是元素存放进去是没有顺序的，那么我们要保证有序，怎么办呢？在HashSet下面有一个子类&lt;code&gt;java.util.LinkedHashSet&lt;/code&gt;，它是链表和哈希表组合的一个数据存储结构。&lt;/p&gt;
&lt;p&gt;代码如下:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class LinkedHashSetDemo {
    public static void main(String[] args) {
        Set&amp;lt;String&amp;gt; set = new LinkedHashSet&amp;lt;String&amp;gt;();
        set.add(&quot;秃头哥&quot;);
        set.add(&quot;地中海哥&quot;);
        set.add(&quot;平头哥&quot;);
        set.add(&quot;假发哥&quot;);
        Iterator&amp;lt;String&amp;gt; it = set.iterator();
        while (it.hasNext()) {
            System.out.println(it.next());
        }
    }
}
结果：
 秃头哥
 地中海哥
 平头哥
 假发哥&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后，欢迎各位关注我的公众号，一起探讨技术，向往技术，追求技术...&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191028085725979.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 07 Nov 2019 00:33:00 +0000</pubDate>
<dc:creator>宜春</dc:creator>
<og:description>前言 在之前的博客文章中已经介绍了Collection接口使用，本篇将介绍Collection接口中的子类的用法，至于为啥要讲它的子类这种小白问题就不要问我了。啥？有小白在看我写的文章...不好意思不</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yichunguo/p/11809866.html</dc:identifier>
</item>
<item>
<title>从一个简单的例子看spring ApplicationContext上下文隔离 - 来自非洲大草原的食人虎</title>
<link>http://www.cnblogs.com/yql1986/p/11805772.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yql1986/p/11805772.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;　　某天，浏览博客园的时候，对首页上面的一篇文章，标题为：&amp;lt;&amp;lt;一个普通类就能干趴你的springboot，你信吗？&amp;gt;&amp;gt;，文章链接：&lt;a href=&quot;https://www.cnblogs.com/rongdi/p/11780204.html#4414216&quot;&gt;https://www.cnblogs.com/rongdi/p/11780204.html#4414216&lt;/a&gt; 很是感兴趣。点进去之后，大致看一下。该篇博文主要说的是&lt;strong&gt;&lt;span&gt;在使用spring boot环境下想创建一个名为Environment的bean，结果发现创建不了&lt;/span&gt;&lt;/strong&gt;，于是不断调试终于找到了“真理”。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　说真的。这篇博文的内容非常长，主要也是记录调试过程的“流水账”。我也只看到了看头，就迅速拉到文章结尾看一下。比较让我感到震惊的是，博主提到为了写这篇文章花费了很长的时间，从该博主的这篇文章中摘录了一句话：&lt;span&gt;周五晚上从下班回家一边一步步断点一遍写这篇博客。&lt;span&gt;可以看出该博主很是用心，调试程序是一件很费心，耗时的事。于是评论区送上一个大大的赞。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　无论是调试还是阅读Spring源码，真的是一件很枯燥的事，非常考验人的耐心，由其是spring发展了这么多年，已经形成了生态圈。其代码也是高度抽象。曾经对spring进行过一番折腾，也是为了给自己所在小团队提供一个基于spring封装的迷你型的小框架。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　由于有折腾过spring的经历，我一眼就看出了问题的所在。根本原因就在于spring框架自身也有一个Environment类，在应用程序启动时也会向spring ApplicationContext中注入名为environment的bean，这样就会跟博主命名Environment类注入名为environment的bean产生冲突，因为这两个bean的名称一样。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　像BAT这样级别的公司往往内部或多或少都会有自己的框架，这些框架往往都是由一个类似于基础架构部的团队来负责提供的，这样应用开发小组会基于这个框架快速的开发应用。应用开发者一般只会关心如何使用框架，一般都由专门的人来折腾框架。虽然我没有在这样体量的公司里面工作过，鉴于之前折腾框架经验来看。框架无论多么的高大上，有一点是可以肯定的时，框架所使用的资源跟应用所使用的资源肯定会进行隔离。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　为什么会这样说呢，打个比方。封装框架的过程中肯定会引入一些第三方的jar，应用在开发的过程也会引用第三方jar，假设框架和应用同时引用一个jar但是二者的版本不同？那可能会导致程序在运行的过程中搞不好就会出现&lt;span class=&quot; newTimeFactor_before_abs m&quot;&gt; java.lang.NoSuchMethodException异常，包冲突了。这时该怎么办？如果要框架jar跟应用的jar保持一致，那就不得了，这么多应用都使用框架进行开发，牵一发而动全身，风险即大。如果应用使用跟框架一样的jar，但是这个jar又没有相应的方法，使用不了。可以想象一样，如果框架和应用没有分别定义自身的类加载器来加载各自的所引用的jar，遇到这样的场景，解决起来将会非常棘手。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　所以在封装框架的过程中，都会对框架所引用的资源跟应用所使用的资源都要进行相应的隔离，如果不隔离的话，框架三天两天就要改动，对应用开发者来说就会认为框架非常的不稳定。由其在BAT这样大体量的公司，开发人员如此众多，对框架提供技术支撑的人不会很多，框架如果不够稳定的话，搞不好那么那些提供技术支撑人员的电话，每天都会响个不停，会到处去解决问题，疲于奔命。就像那篇文章提到定义Envrionment bean时候，应用就会跑起不来，打电话给技术支撑的人，人家一过来捣鼓一番对像你说，老兄，对不住啊，命名冲突了，换这个名字吧。也许重新命个名字了事，但是有些场景这个类的名字改不了，别人的代码已经固定了要使用这个名字来调用你的bean，改名字别人就调不了。&lt;/span&gt;&lt;span&gt;重新命名也许可以解决问题，但内心深处，你会对这个框架失去信心了。什么框架，还限制别人bean的名字。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　像spring框架就提供了对ApplicationContext进行隔离的功能，可以轻松解决这个问题。在spring官网的文档中我也没有看到有提到，不允许应用程序注入一个命名为Environment的Bean。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;程序出错&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;我已经将复现同样错误的示例程序代码上传到了gitee上面。大家可以把代码拉下来，跑起来会出现跟那篇文章中提所到的一模一样错误。 出现这样错误的原因就是由于两个同名的类注入到同一个ApplicationContext中导致的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;示例代码链接：&lt;a href=&quot;https://gitee.com/fiercetiger/laboratory/tree/master/applicationcontext-test&quot;&gt;https://gitee.com/fiercetiger/laboratory/tree/master/applicationcontext-test&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;导致程序出错，Bean的源码如下所示：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;@Component
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Environment {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;ApplicationContext隔离&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;　　spring ApplicationContext是可以设置成上下级关系的，查找bean的时候如果在当前的ApplicationContext中没有找到的话，就会到自己的父级的ApplicationContext中去查找，一直向上回溯，如果找到就会返回。这样一来的话，我们可以这样处理。让应用的ApplicationContext作为spring框架的ApplicationContext的父级。示例程序，我也提交到了gitee上面，可以把代码拉下来，跑一下就会发现没有报错。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;示例代码链接：&lt;a href=&quot;https://gitee.com/fiercetiger/laboratory/tree/master/applicationcontext-test2&quot;&gt;https://gitee.com/fiercetiger/laboratory/tree/master/applicationcontext-test2&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/112331/201911/112331-20191106174548068-1381463394.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　关键代码如下所示，定义一个类继承spring boot的SpringApplication类，覆盖其createApplicationContext方法，在方法中首先创建应用的ApplicationContext，并注入应用所定义的Environment Bean，随后将其设置为spring boot ApplicationContext的父级。为了更好的演示向上回溯查找Bean的效果，特意定义了一个MyService Bean，这个Bean注入到spring boot ApplicationContext中，并且在MyService Bean中自动注入对应用所定义的Environment Bean的依赖。当应用程序启动之后，没有报错。说明了MyService Bean成功注入了父级的application context中所定义的Environment Bean&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.boot.SpringApplication;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.ConfigurableApplicationContext;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.support.StaticApplicationContext;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MySpringApplication &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; SpringApplication {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; MySpringApplication(Class&amp;lt;?&amp;gt;&lt;span&gt;[] classes){
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;super&lt;/span&gt;&lt;span&gt;(classes);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt;&lt;span&gt; ConfigurableApplicationContext createApplicationContext(){
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         
&lt;span&gt;14&lt;/span&gt;         StaticApplicationContext parent=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; StaticApplicationContext();
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         parent.registerBean(Environment.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        parent.refresh();
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         
&lt;span&gt;18&lt;/span&gt;         ConfigurableApplicationContext child=&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.createApplicationContext();
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        child.setParent(parent);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; child;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    }    
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;strong&gt;&lt;span&gt;结尾&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;　　写这篇文章的旨在分享有关spring ApplicationContext 一个小小的知识点，Spring所涉及到的知识点非常庞杂。那篇文章的博主为了弄清楚问题的真相，花费大量的程序来调试程序，还花了大篇幅的文章记录下来，可以看到出该博主是一个对技术有着执着追求的人。这篇文章也完整呈现了我在那篇文章评论区中所提到，可以采用对applicationcontext进行分层来解决这一问题。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 07 Nov 2019 00:30:00 +0000</pubDate>
<dc:creator>来自非洲大草原的食人虎</dc:creator>
<og:description>前言 某天，浏览博客园的时候，对首页上面的一篇文章，标题为：&amp;lt;&amp;lt;一个普通类就能干趴你的springboot，你信吗？&amp;gt;&amp;gt;，文章链接：https://www.cnblogs.co</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yql1986/p/11805772.html</dc:identifier>
</item>
<item>
<title>盘点一下Creator星球上的开源工具包！ - 张晓衡</title>
<link>http://www.cnblogs.com/creator-star/p/11809841.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/creator-star/p/11809841.html</guid>
<description>&lt;p&gt;晓衡开始写公众号，最早是从上架 Cocos 商店的 pbkiller 插件开始的，到至今有2年2个月了。在这期间，又陆续在公众号上分享了多个实用工具包，在这里统一盘点一下，方便与大家交流学习。&lt;/p&gt;

&lt;p&gt;奎特尔星球上有一件绝世神兵，就像是一把雷神之锤，在它的号令之下指挥着节点、组件和触摸事件，从而大量减少冗余代码与编辑器上的设置。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://shawn-blog-bucket.oss-cn-beijing.aliyuncs.com/image-1573085035606.png&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt;视频链接：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://v.qq.com/x/page/b0558yaj9ht.html&quot; class=&quot;uri&quot;&gt;https://v.qq.com/x/page/b0558yaj9ht.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;相关教程：&lt;/p&gt;
&lt;p&gt;github地址：&lt;/p&gt;

&lt;p&gt;《CreatorPrimer》系列教程推出接近一年了，目前共计30篇，可以快速让你Get到Cocos Creator引擎组件化的实质，编写出可复用的组件脚本，更好地与美术、策划协作创作游戏内容，游戏会因你而更精彩！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1755688/201911/1755688-20191107081616607-668155454.png&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt;视频链接：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://v.qq.com/x/page/s08805v5ws7.html&quot; class=&quot;uri&quot;&gt;https://v.qq.com/x/page/s08805v5ws7.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;相关教程：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzA5MjEwOTI4Ng==&amp;amp;mid=2247484719&amp;amp;idx=1&amp;amp;sn=8ab8fb69720abfb8b4b6646a08e5ebd8&amp;amp;chksm=907365a6a704ecb0f473c632fa71ab840d5ef4c5402a6c1d138eb0101a02962c61235685d85e&amp;amp;scene=21#wechat_redirect&quot;&gt;CreatorPrimer 30篇教程汇总&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;教程中提供了如场景切换、精灵切换、预制加载、节点拖动、二维码、绘图板等可通用的组件代码，下面是源码仓库：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/ShawnZhang2015/CreatorPrimer&quot; class=&quot;uri&quot;&gt;https://github.com/ShawnZhang2015/CreatorPrimer&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1755688/201911/1755688-20191107081620523-1260685334.png&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1755688/201911/1755688-20191107081624475-680490338.png&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt;视频链接：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://v.qq.com/x/page/r3001mwvlx6.html&quot; class=&quot;uri&quot;&gt;https://v.qq.com/x/page/r3001mwvlx6.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;支持Creator 2.2.0 的ShaderHelper 也提交到了Github，目前 ShaderHelper 有三个版本，分别是：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Creator 2.0.10 之前使用 ShaderHelper；&lt;/li&gt;
&lt;li&gt;Creator 2.1.2 ~ Creator 2.1.3 ShaderHelper2 Master分支&lt;/li&gt;
&lt;li&gt;Creator 2.2.0 ShaderHelper2 2.2.0 分支&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;相关教程：&lt;/p&gt;
&lt;p&gt;源码仓库：&lt;/p&gt;

&lt;p&gt;在 Cocos Creator 项目中使用一种&lt;strong&gt;配置式&lt;/strong&gt;、&lt;strong&gt;可编程&lt;/strong&gt; 的新手引导编程体验，支持自定义指令、录像与回放，可用于自动化测试，可运行在浏览器、微信、原生环境。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1755688/201911/1755688-20191107081631285-500660375.png&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt;视频链接：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://v.qq.com/x/page/w3017utnw14.html&quot; class=&quot;uri&quot;&gt;https://v.qq.com/x/page/w3017utnw14.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;相关教程：&lt;/p&gt;
&lt;p&gt;源码仓库：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/ShawnZhang2015/GodGuide&quot; class=&quot;uri&quot;&gt;https://github.com/ShawnZhang2015/GodGuide&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;「game-legends」目前仅只包含【微信小游戏换量导航】，开启一个从『A游戏』通向『B游戏』的传送门，提高游戏的曝光率和用户活跃度，目前支持3大模式5类应用场景。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1755688/201911/1755688-20191107081635882-1855918468.png&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt;视频链接：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://v.qq.com/x/page/c3000cefbkt.html&quot; class=&quot;uri&quot;&gt;https://v.qq.com/x/page/c3000cefbkt.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;相关教程：&lt;/p&gt;
&lt;p&gt;源码仓库：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/ShawnZhang2015/creator-game-legends&quot; class=&quot;uri&quot;&gt;https://github.com/ShawnZhang2015/creator-game-legends&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;pbkiller 是一位专业的争对 protobuf 问题训练有素的杀手，我可以为您轻松搞定 protobuf 在 Cocos Creaotr 开发中的诸多问题，并且可以让你随意折磨曾经折磨过你的 protbuf 问题。目前最新的 pbkiller 也能在 Creator 3D 中运行，看下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1755688/201911/1755688-20191107081637074-1407645291.png&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt;视频链接：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://v.qq.com/x/page/o3014reen9d.html&quot; class=&quot;uri&quot;&gt;https://v.qq.com/x/page/o3014reen9d.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;相关教程：&lt;/p&gt;
</description>
<pubDate>Thu, 07 Nov 2019 00:17:00 +0000</pubDate>
<dc:creator>张晓衡</dc:creator>
<og:description>晓衡开始写公众号，最早是从上架 Cocos 商店的 pbkiller 插件开始的，到至今有2年2个月了。在这期间，又陆续在公众号上分享了多个实用工具包，在这里统一盘点一下，方便与大家交流学习。 一、u</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/creator-star/p/11809841.html</dc:identifier>
</item>
<item>
<title>一位年轻而优秀的.NET开发者的成长点滴 - 溪源More</title>
<link>http://www.cnblogs.com/xiyuanMore/p/11809840.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiyuanMore/p/11809840.html</guid>
<description>&lt;p&gt;今年3月的一次技术交流活动上，那是我们.NET技术社区第一次组织线下活动，由于没什么经验，所以活动组织得比较仓促，内容也比较一般，效果还是有点欠缺。当然，活动本身是必要的，这次活动上有幸认识了许多长沙的优秀开发者，这让我非常的高兴。&lt;/p&gt;
&lt;p&gt;事实上搞技术活动，与其说是交流技术，倒不如说是扩大圈子，交流感情，认识更多的朋友。毕竟每个职场人往往圈子都是固定的，哪怕是在大公司，真正经常来往的朋友其实也不过三两人而已。但是在北上广深的大城市，往往有时候刚刚认识几个朋友，对方可能就离开了，这也是一种遗憾。相对而言，在小城市或许也相对容易形成更加稳定的精准小圈子，这也是我认为一个社区存在的最大价值。&lt;/p&gt;
&lt;p&gt;小城市的职业发展方向大概都是一样的，从入门级小程序员出发，然后到高级程序员，再到项目经理，然后逐渐脱离技术的主航道，直到被技术抛弃。有朋友戏谑道，长沙的程序员大概率都是一样的，靠经验的简单复制、依靠人际关系技巧或者靠资历，而真正钻研技术的非常少。&lt;/p&gt;
&lt;p&gt;哪怕有许多开发者得以突破转到了项目管理或其他方向，也很难能够在专业领域能够进一步的发展。毕竟首先企业大环境决定了个人的职业选择，其次就是很少有开发者能够明白的看清自己的职业发展规划，为了钱而生存无可厚非，然后整个职业生涯都迷迷茫茫，只能导致最终到了一定的年纪，就开始原地踏步了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/farway000/techq.xyz/master/images/%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84%E4%B8%8D%E6%96%AD%E8%BF%9B%E5%8F%96/image.png&quot; alt=&quot;别瞎迷茫了&quot;/&gt;&lt;/p&gt;

&lt;p&gt;而公众号DotNet骚操作的作者周杰是参加了我们第一次活动的三十位开发者中的一位，也是小城市中少有的对技术始终保持热心的优秀开发者。&lt;/p&gt;
&lt;p&gt;事实上很多年前（三年前）我就对他的名字有所耳闻，我的好几个朋友都说他的生活除了工作，家庭，剩下的就都是技术，是一个不折不扣的.NET技术狂。&lt;/p&gt;
&lt;p&gt;不过由于当时我主要是沉浸于小行业应用的泥坑之中，还不能体会.NET技术作为基础技术的巨大价值，自然而然相对来说比较无感。直到从泥坑中出来才能深深体会到技术的无穷魅力，也才真正理解在长沙这座城市，能够踏踏实实的以.NET技术作为自己的核心竞争力的开发者是何其的珍贵。&lt;/p&gt;
&lt;p&gt;当时的他的公众号【DotNet骚操作】还没开，以前他经常做开源项目。与许多内地城市的开源项目参与者热衷于刷开源项目，以fork了哪些项目贡献了多少文档的形式相比，他更倾向于自己造轮子。在他的github仓库（&lt;a href=&quot;https://github.com/sdcb&quot; class=&quot;uri&quot;&gt;https://github.com/sdcb&lt;/a&gt;）中还有许多各种各样的开源项目，这些都是他一点一滴的积累，几乎每个方法都会认真考虑代码背后的实现逻辑和性能优化，这些小巧玲珑、性能完美、代码整洁的小轮子，既让他在技能方面得到了积累，更是让其他人能从中获益。&lt;/p&gt;
&lt;p&gt;当时他还很少写博客，我就撺掇他写博客，他也说干就干，很快就写完一篇，那篇文章的具体内容我不太记得了，我只记得他对于技术问题的专注和专业，令我非常钦佩。&lt;/p&gt;
&lt;p&gt;这个时候就体现了他过去那么多年积累的价值，一旦开始写博客，就产量特别高。到现在短短五个月时间已经写了二十篇，而且素材越写越多，质量也越来越好，几乎每一篇都会成为博客园的推荐文章。他立下了一个flag，要写五十篇精品博客，让大家看到DotNet技术的美妙与精彩。&lt;/p&gt;
&lt;p&gt;我们偶尔会讨论.NET开发者的焦虑，许多.NET开发者都以自己选择了.NET为耻，总觉得是这个技术让自己的路越走越窄，经常在各种技术群里吐槽，说自己人生最大的错误就是选择了.Net。&lt;/p&gt;
&lt;p&gt;我们都对这种人觉得惋惜。他说，程序员只有因为自己没能努力学习而感到焦虑，真正掌握了一种开发技术，一定也能适应其他语言和技术。优秀开发者根本没时间焦虑，毕竟要学习的技能点随着年龄的增长越来越多，恨不能每天有48个小时来学习技术，哪里还有其他闲心去思考工作，家庭，技术之外的其他事情？只要自己技术过硬，哪里还需要担心什么未来前途不保？&lt;/p&gt;
&lt;p&gt;我们也经常讨论招人难的问题。尤其是对于基于.NET技术栈的企业来说，都遇到了这样的问题。一方面，确实越来越少的开发者使用.NET技术栈，一方面许多使用.NET技术栈的开发者都在从事边缘业务的开发者，很难触及底层技术或核心的技术。这并非企业行为，而是兴趣爱好驱动的。&lt;/p&gt;
&lt;p&gt;也必须承认，过去十年借助于互联网取得财富自由的.NET开发者几乎非常罕见，许多以前致力于研究.NET技术的开发者的出路都只能选择出国。这样的前提让功利的中国社会，越来越少人选择.NET技术。但是这也是.NET开发者最大的机会，好好学习技术、努力跳出自己的圈子，看看世界，选择将让你成长。&lt;/p&gt;
&lt;p&gt;我深以为然。程序员，不仅仅是.NET程序员或java程序员，能够用心学好技术，努力提高自己的技能，并时刻保持学习的精神，才是程序员的最大的价值。&lt;/p&gt;
&lt;p&gt;周杰正是按照这样的节奏在坚持自己的方向，他深刻的明白贪多嚼不烂的道理、没有追求一蹴而就，而是一步一个脚印，每一步都踏得严严实实。这种严于律己的优秀开发者的自我进取，也正是开发者所应该具备的自我刷新的精神。&lt;/p&gt;
&lt;p&gt;他使我明白，无论是什么岗位，在什么环境下，都应该清楚自己的职业发展方向，并努力提高自己的硬技能和软实力，这是开发者得以利足于时代永不淘汰的光辉色彩。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/farway000/techq.xyz/master/images/%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84%E4%B8%8D%E6%96%AD%E8%BF%9B%E5%8F%96/person.png&quot; alt=&quot;才华照&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（ps，大概需要减肥了。。）&lt;/p&gt;

&lt;p&gt;在互联网技术飞速发展的今天，越是优秀的企业也往往最能凝聚最优秀的人才，正是这种人才间相互吸引的魅力，让企业更加优秀，也让人才得以借助企业提供的平台取得了更好的发展。&lt;/p&gt;
&lt;p&gt;而优秀人才并非偶然天成、往往也得益于兴趣和团队氛围的培养，关注于结果，同样也要关注于过程，既关注于人才的保健因素（例如工作条件，上下级关系，同事关系，工资，职位，安全），也同样关注于人才的激励因素（工作中的成就感，得到的认可与奖励，本身的挑战与兴趣，职务的责任感，工作的发展前途，个人成长的晋升的机会等），才更能实现人才的价值提升。&lt;/p&gt;
&lt;p&gt;人才、人才、人才，这正是在互联网大时代最宝贵的财富。&lt;/p&gt;

&lt;p&gt;欢迎大家关注他的公众号，【DotNet骚操作】。也请大家记住他，一位年轻而充满激情的开发者。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/191302/201911/191302-20191107083115337-222367204.png&quot; alt=&quot;DotNET骚操作公众号二维码&quot;/&gt;&lt;/p&gt;
&lt;p&gt;让我们一起跟随他的步伐，看看DotNet的一系列骚操作将如何给我们的生活带来更多精彩。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/191302/201911/191302-20191107083325021-982706970.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;本文版权归原作者和博客园共同拥有。作品采用知识共享署名-非商业性使用-相同方式共享4.0 国际许可协议进行许可。&lt;br/&gt;本文来自： 溪源 | 长沙.NET技术社区。阅读更多精彩好文，欢迎关注长沙.NET技术社区公众号【DotNET技术圈】。&lt;br/&gt;首发于溪源的个人博客www.techq.xyz&lt;/p&gt;
</description>
<pubDate>Thu, 07 Nov 2019 00:16:00 +0000</pubDate>
<dc:creator>溪源More</dc:creator>
<og:description>一，社区的小圈子 今年3月的一次技术交流活动上，那是我们.NET技术社区第一次组织线下活动，由于没什么经验，所以活动组织得比较仓促，内容也比较一般，效果还是有点欠缺。当然，活动本身是必要的，这次活动上</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiyuanMore/p/11809840.html</dc:identifier>
</item>
<item>
<title>[springboot 开发单体web shop] 3. 用户注册实现 - IsaacZhang</title>
<link>http://www.cnblogs.com/zhangpan1244/p/11809826.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangpan1244/p/11809826.html</guid>
<description>&lt;p&gt;作为一个现代化电商平台，什么最重要呢？of course 是用户，广大用户群体是支持我们可持续发展的基石，&lt;code&gt;顾客是上帝&lt;/code&gt;， 虽然在当今上帝已经不被重视了，特别是很多的平台对于老用户就是恨不得赶紧Out...但是用户量是一切的基础，那我们就开始创建我们的上帝吧！&lt;/p&gt;
&lt;h2 id=&quot;创建数据库&quot;&gt;## 创建数据库&lt;/h2&gt;
&lt;p&gt;数据库的部分，我在这里就不多讲了，大家需要的话可以直接去&lt;a href=&quot;https://github.com/Isaac-Zhang/expensive-shop/tree/master/db&quot;&gt;传送门&lt;/a&gt; 抓取脚本&lt;code&gt;expensive-shop.sql&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&quot;生成usermapper&quot;&gt;## 生成UserMapper&lt;/h2&gt;
&lt;p&gt;参考上节内容：&lt;a href=&quot;https://www.cnblogs.com/zhangpan1244/p/11803023.html&quot;&gt;传送门&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;编写业务逻辑&quot;&gt;## 编写业务逻辑&lt;/h2&gt;
&lt;p&gt;首先，我们先来分析一下要注册一个用户，我们系统都需要做哪些动作？&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/48397/201911/48397-20191107080000826-746739688.png&quot; alt=&quot;user register&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;validate
&lt;ul&gt;&lt;li&gt;input string(校验输入我们需要通过两个角度处理)
&lt;ul&gt;&lt;li readability=&quot;-1.5&quot;&gt;
&lt;p&gt;FrontEnd valid&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;前端校验是为了降低我们服务器端压力而做的一部分校验，这部分校验可以拦截大多数的错误请求。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Backend valid&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;后端校验是为了防止某些不法小伙伴绕开前端从而直接访问我们的api造成数据请求服务器错误，或者前端小伙伴程序有bug...无论是哪一种可能性，都有可能造成严重的后果。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;-1.5&quot;&gt;
&lt;p&gt;email &amp;amp; mobile invalid&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;因为本人没有追求email / 短信发送服务器，所以这一步就pass，小伙伴们可以自行研究哈。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;control
&lt;ul&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;create user&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;校验通过后，就可以进行创建用户的动作了。&lt;br/&gt;接下来，我们就可以来实际编码实现业务了，我们使用最基本的分层架构，在之前我们已经通过&lt;code&gt;Mybatis Generator&lt;/code&gt;工具生成了基本的&lt;code&gt;pojo&lt;/code&gt;,&lt;code&gt;mapper&lt;/code&gt;，对于简单的操作我们只需要再编写&lt;code&gt;service&lt;/code&gt;和&lt;code&gt;controller&lt;/code&gt;层就可以完成我们的开发工作了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;编写user-service&quot;&gt;## 编写user service&lt;/h2&gt;
&lt;p&gt;在&lt;code&gt;mscx-shop-service&lt;/code&gt;中创建&lt;code&gt;com.liferunner.service.IUserService&lt;/code&gt;接口，包含2个方法&lt;code&gt;findUserByUserName&lt;/code&gt;和&lt;code&gt;createUser&lt;/code&gt;，如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface IUserService {

    /**
     * 根据用户名查询用户是否存在
     *
     * @param username
     * @return
     */
    Users findUserByUserName(String username);

    /**
     * 创建用户
     *
     * @param userRequestDTO 用户请求dto
     * @return 当前用户
     */
    Users createUser(UserRequestDTO userRequestDTO) throws Exception;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接着，我们需要具体实现这个接口类，如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Service
@Slf4j
public class UserServiceImpl implements IUserService {
    private final String FACE_IMG = &quot;https://avatars1.githubusercontent.com/u/4083152?s=88&amp;amp;v=4&quot;;

    // 构造器注入
    private final UsersMapper usersMapper;
    private final Sid sid;

    @Autowired
    public UserServiceImpl(UsersMapper usersMapper, Sid sid) {
        this.usersMapper = usersMapper;
        this.sid = sid;
    }

    @Override
    public Users findUserByUserName(String username) {
        // 构建查询条件
        Example example = new Example(Users.class);
        val condition = example.createCriteria()
                .andEqualTo(&quot;username&quot;, username);
        return this.usersMapper.selectOneByExample(example);
    }

    @Transactional(propagation = Propagation.REQUIRED)
    @Override
    public Users createUser(UserRequestDTO userRequestDTO) throws Exception {
        log.info(&quot;======begin create user : {}=======&quot;, userRequestDTO);
        val user = Users.builder()
                .id(sid.next()) //生成分布式id
                .username(userRequestDTO.getUsername())
                .password(MD5GeneratorTools.getMD5Str(userRequestDTO.getPassword()))
                .birthday(DateUtils.parseDate(&quot;1970-01-01&quot;, &quot;yyyy-MM-dd&quot;))
                .nickname(userRequestDTO.getUsername())
                .face(this.FACE_IMG)
                .sex(SexEnum.secret.type)
                .createdTime(new Date())
                .updatedTime(new Date())
                .build();
        this.usersMapper.insertSelective(user);
        log.info(&quot;======end create user : {}=======&quot;, userRequestDTO);
        return user;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里有几处地方有必要说明一下：&lt;/p&gt;
&lt;h3 id=&quot;userserviceimplfinduserbyusername-说明&quot;&gt;UserServiceImpl#findUserByUserName 说明&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;tk.mybatis.mapper.entity.Example&lt;/code&gt; 通过使用Example来构建mybatis的查询参数，如果有多个查询条件，可以通过&lt;code&gt;example.createCriteria().addxxx&lt;/code&gt;逐一添加。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;userserviceimplcreateuser-说明&quot;&gt;UserServiceImpl#createUser 说明&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;@Transactional(propagation = Propagation.REQUIRED)&lt;/code&gt;,开启事务，选择事务传播级别为&lt;code&gt;REQUIRED&lt;/code&gt;,表示必须要有一个事务存在，如果调用者不存在事务，那本方法就自己开启一个新的事物，如果调用方本身存在一个活跃的事务，那本方法就加入到它里面（同生共死）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;org.n3r.idworker.Sid&lt;/code&gt;, 这个是一个开源的 分布式ID生成器组件，&lt;a href=&quot;https://github.com/bingoohuang/idworker-client&quot;&gt;传送门&lt;/a&gt;, 后期有机会的话，会专门写一个id生成器文章。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MD5GeneratorTools&lt;/code&gt; 是用来对数据进行MD5加密的工具类，大家可以在源码中下载。也可以直接使用&lt;code&gt;java.security.MessageDigest&lt;/code&gt; 直接加密实现，总之密码不能明文存储就行了。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SexEnum&lt;/code&gt; 这个是一个表述性别类型的枚举，在我们编码的规范中，尽量要求不要出现&lt;code&gt;Magic number&lt;/code&gt;,就是开发界常说的魔术数字（即1,2,300...）&lt;/li&gt;
&lt;li&gt;这里的日志打印，可能有人会问为什么你没有声明类似:&lt;code&gt;private final static Logger logger = LoggerFactory.getLogger(UserServiceImpl.class);&lt;/code&gt; ,这是因为我们在开始的时候，我们引入了&lt;code&gt;lombok&lt;/code&gt;依赖，不记得的同学可以参考&lt;a href=&quot;https://www.cnblogs.com/zhangpan1244/p/11793065.html&quot;&gt;传送门&lt;/a&gt;。在这里依赖中，它继承了很多的日志组件，我们只需要使用一个注解&lt;code&gt;lombok.extern.slf4j.Slf4j&lt;/code&gt;来开启日志，使用&lt;code&gt;log.info..&lt;/code&gt;就可以了。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;UserRequestDTO&lt;/code&gt; 又是个什么鬼？在我们开发的过程中，很可能会有大批量的参数需要传递，这时我们如果使用&lt;code&gt;xxx#(String aa,Integer bb,Boolean cc...)&lt;/code&gt;会让我们烦不胜数，而且看着也不美观，这时候我们就可以选择创建一个新对象来帮助我们传递数据，那么也就是我们的&lt;code&gt;UserRequestDTO&lt;/code&gt;对象，所谓的&lt;code&gt;DTO&lt;/code&gt;就是&lt;code&gt;Data Transfer Object&lt;/code&gt;的首字母缩写，顾名思义，它是用来传递数据对象用的。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;编写user-controller&quot;&gt;## 编写user controller&lt;/h2&gt;
&lt;p&gt;同样在&lt;code&gt;mscx-shop-api&lt;/code&gt;中，创建&lt;code&gt;com.liferunner.api.controller.UserController&lt;/code&gt;,实现用户创建。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@RestController
@RequestMapping(name = &quot;/users&quot;)
@Slf4j
@Api(tags=&quot;用户管理&quot;)
public class UserController {

    @Autowired
    private IUserService userService;

    @ApiOperation(&quot;校验是否重名&quot;)
    @GetMapping(&quot;/validateUsername&quot;)
    public JsonResponse validateUsername(@RequestParam String username) {
        // 判断用户名是否非法
        if (StringUtils.isBlank(username))
            return JsonResponse.errorMsg(&quot;用户名不能为空！&quot;);
        if (null != userService.findUserByUserName(username))
            return JsonResponse.errorMsg(&quot;用户名已存在！&quot;);
        // 用户名可用
        return JsonResponse.ok();
    }

    @ApiOperation(&quot;创建用户&quot;)
    @PostMapping(&quot;/create&quot;)
    public JsonResponse createUser(@RequestBody UserRequestDTO userRequestDTO) {
        try {
            if (StringUtils.isBlank(userRequestDTO.getUsername()))
                return JsonResponse.errorMsg(&quot;用户名不能为空&quot;);
            if (null != this.userService.findUserByUserName(userRequestDTO.getUsername())) {
                return JsonResponse.errorMsg(&quot;用户名已存在！&quot;);
            }
            if (StringUtils.isBlank(userRequestDTO.getPassword()) ||
                    StringUtils.isBlank(userRequestDTO.getConfimPassword()) ||
                    userRequestDTO.getPassword().length() &amp;lt; 8) {
                return JsonResponse.errorMsg(&quot;密码为空或长度小于8位&quot;);
            }
            if (!userRequestDTO.getPassword().equals(userRequestDTO.getConfimPassword()))
                return JsonResponse.errorMsg(&quot;两次密码不一致！&quot;);
            val user = this.userService.createUser(userRequestDTO);
            if (null != user)
                return JsonResponse.ok(user);
        } catch (Exception e) {
            log.error(&quot;创建用户失败,{}&quot;, userRequestDTO);
        }
        return JsonResponse.errorMsg(&quot;创建用户失败&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;usercontrollervalidateusernameusername-说明&quot;&gt;UserController#validateUsername(username) 说明&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;JsonResponse&lt;/code&gt;对象是为了方便返回给客户端一个统一的格式而封装的数据对象。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Data
@NoArgsConstructor
@AllArgsConstructor
public class JsonResponse {

    // 定义jackson对象
    private static final ObjectMapper MAPPER = new ObjectMapper();
    // 响应业务状态
    private Integer status;
    // 响应消息
    private String message;
    // 响应中的数据
    private Object data;

    public static JsonResponse build(Integer status, String msg, Object data) {
        return new JsonResponse(status, msg, data);
    }

    public static JsonResponse ok(Object data) {
        return new JsonResponse(data);
    }

    public static JsonResponse ok() {
        return new JsonResponse(null);
    }

    public static JsonResponse errorMsg(String msg) {
        return new JsonResponse(500, msg, null);
    }

    public static JsonResponse errorMap(Object data) {
        return new JsonResponse(501, &quot;error&quot;, data);
    }

    public static JsonResponse errorTokenMsg(String msg) {
        return new JsonResponse(502, msg, null);
    }

    public static JsonResponse errorException(String msg) {
        return new JsonResponse(555, msg, null);
    }

    public static JsonResponse errorUserQQ(String msg) {
        return new JsonResponse(556, msg, null);
    }

    public JsonResponse(Object data) {
        this.status = 200;
        this.message = &quot;OK&quot;;
        this.data = data;
    }

    public Boolean isOK() {
        return this.status == 200;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;usercontrollercreateuseruserrequestdto-说明&quot;&gt;UserController#createUser(UserRequestDTO) 说明&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;如上文所讲，需要先做各种校验&lt;/li&gt;
&lt;li&gt;成功则返回&lt;code&gt;JsonResponse&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;细心的同学可能看到了上文中有几个注解&lt;code&gt;@Api(tags=&quot;用户管理&quot;)&lt;/code&gt;,&lt;code&gt;@ApiOperation(&quot;创建用户&quot;)&lt;/code&gt;,这个是Swagger 的注解，我们会在下一节和大家详细探讨，以及如何生成&lt;code&gt;off-line docs&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;测试api&quot;&gt;测试API&lt;/h2&gt;
&lt;hr/&gt;&lt;p&gt;在我们每次修改完成之后，都尽可能的&lt;code&gt;mvn clean install&lt;/code&gt;一次，因为我们隶属不同的project，如果不重新安装一次，偶尔遇到的问题会让人怀疑人生的。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;...
[INFO] expensive-shop ..................................... SUCCESS [  1.220 s]
[INFO] mscx-shop-common ................................... SUCCESS [  9.440 s]
[INFO] mscx-shop-pojo ..................................... SUCCESS [  2.020 s]
[INFO] mscx-shop-mapper ................................... SUCCESS [  1.564 s]
[INFO] mscx-shop-service .................................. SUCCESS [  1.366 s]
[INFO] mscx-shop-api ...................................... SUCCESS [  4.614 s]
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time:  20.739 s
[INFO] Finished at: 2019-11-06T14:53:55+08:00
[INFO] ------------------------------------------------------------------------&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当看到上述运行结果之后，就可以启动我们的应用就行测试啦～&lt;/p&gt;
&lt;h3 id=&quot;usercontrollervalidateusernameusername-测试&quot;&gt;UserController#validateUsername(username) 测试&lt;/h3&gt;
&lt;p&gt;测试API的方式有很多种，比如&lt;code&gt;curl localhost:8080/validateUsername&lt;/code&gt;，在比如使用超级流行的&lt;code&gt;Postman&lt;/code&gt;也是完全ok的，我这里用的是之前在第一篇中和大家所说的一个插件&lt;code&gt;Restful Toolkit(可以实现和postman一样的简单效果,同时还能帮助我们生成一部分测试信息)&lt;/code&gt;，当我们应用启动之后，效果如下图，&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/48397/201911/48397-20191107080001145-887150546.png&quot; alt=&quot;rest plugin&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以看到，插件帮我们生成了几个测试方法，比如我们点击&lt;code&gt;validateUsername&lt;/code&gt;,下方就会生成当前方法是一个包含&lt;code&gt;username&lt;/code&gt;参数的&lt;code&gt;GET&lt;/code&gt;方法，&lt;code&gt;demoData&lt;/code&gt;是插件默认给我们生成的测试数据。可以随意修改。&lt;br/&gt;点击Send：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/48397/201911/48397-20191107080001381-290828842.png&quot; alt=&quot;result&quot;/&gt;&lt;br/&gt;可以看到请求成功了，并且返回我们自定义的JSON格式数据。&lt;/p&gt;
&lt;h3 id=&quot;usercontrollercreateuseruserrequestdto-测试&quot;&gt;UserController#createUser(UserRequestDTO) 测试&lt;/h3&gt;
&lt;p&gt;接着我们继续测试用户注册接口，请求如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/48397/201911/48397-20191107080001555-591604200.png&quot; alt=&quot;send&quot;/&gt;&lt;br/&gt;可以看到，当我们选择&lt;code&gt;create&lt;/code&gt;方法时，插件自动帮我们设置请求类型为&lt;code&gt;POST&lt;/code&gt;，并且&lt;code&gt;RequestBody&lt;/code&gt;的默认值也帮助我们生成了，我只修改了默认的&lt;code&gt;username&lt;/code&gt;和&lt;code&gt;password&lt;/code&gt;值，&lt;code&gt;confimPassword&lt;/code&gt;的默认值我没有变动，那按照我们的校验逻辑，它应该返回的是&lt;code&gt;return JsonResponse.errorMsg(&quot;两次密码不一致！&quot;);&lt;/code&gt;这一行，点击Send：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/48397/201911/48397-20191107080001723-69134168.png&quot; alt=&quot;result&quot;/&gt;&lt;br/&gt;修改&lt;code&gt;confimPassword&lt;/code&gt;为&lt;code&gt;12345678&lt;/code&gt;,点击Send：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/48397/201911/48397-20191107080001896-535784066.png&quot; alt=&quot;result2&quot;/&gt;&lt;br/&gt;可以看到，创建用户成功，并且将当前创建的用户返回到了我们请求客户端。那么我们继续重复点击创建，会怎么样呢？继续Send:&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/48397/201911/48397-20191107080002108-1817077697.png&quot; alt=&quot;result3&quot;/&gt;&lt;br/&gt;可以看到，我们的验证重复用户也已经生效啦。&lt;/p&gt;
&lt;h2 id=&quot;下节预告&quot;&gt;下节预告&lt;/h2&gt;
&lt;hr/&gt;&lt;p&gt;下一节我们将学习如何使用Swagger自动生成API接口文档给前端，以及如果没有外部网络的情况下，或者需要和第三方平台对接的时候，我们如何生成&lt;code&gt;离线文档&lt;/code&gt;给到第三方。&lt;br/&gt;gogogo！&lt;/p&gt;
</description>
<pubDate>Thu, 07 Nov 2019 00:00:00 +0000</pubDate>
<dc:creator>IsaacZhang</dc:creator>
<og:description>[TOC] 用户注册 作为一个现代化电商平台，什么最重要呢？of course 是用户，广大用户群体是支持我们可持续发展的基石， ， 虽然在当今上帝已经不被重视了，特别是很多的平台对于老用户就是恨不得</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhangpan1244/p/11809826.html</dc:identifier>
</item>
<item>
<title>使用Spring Data JPA进行数据分页与排序 - 字母哥博客</title>
<link>http://www.cnblogs.com/zimug/p/11809827.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zimug/p/11809827.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1815316/201911/1815316-20191107080003827-938890217.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;一导读&quot;&gt;一、导读&lt;/h2&gt;
&lt;p&gt;如果一次性加载成千上万的列表数据，在网页上显示将十分的耗时，用户体验不好。所以处理较大数据查询结果展现的时候，分页查询是必不可少的。分页查询必然伴随着一定的排序规则，否则分页数据的状态很难控制，导致用户可能在不同的页看到同一条数据。那么，本文的主要内容就是给大家介绍一下，如何使用Spring Data JPA进行分页与排序。&lt;/p&gt;
&lt;h2 id=&quot;二实体定义&quot;&gt;二、实体定义&lt;/h2&gt;
&lt;p&gt;我们使用一个简单的实体定义：Article(文章)&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Data
@AllArgsConstructor
@NoArgsConstructor
@Builder
@Entity
@Table(name=&quot;article&quot;)
public class Article {

    @Id
    @GeneratedValue
    private Long id;

    @Column(nullable = false,length = 32)
    private String author;

    @Column(nullable = false, unique = true,length = 32)
    private String title;

    @Column(length = 512)
    private String content;

    private Date createTime;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;@Entity 表示这个类是一个实体类，接受JPA控制管理，对应数据库中的一个表&lt;/li&gt;
&lt;li&gt;@Table 指定这个类对应数据库中的表名。如果这个类名和数据库表名符合驼峰及下划线规则，可以省略这个注解。如FlowType类名对应表名flow_type。&lt;/li&gt;
&lt;li&gt;@Id 指定这个字段为表的主键&lt;/li&gt;
&lt;li&gt;@GeneratedValue(strategy=GenerationType.IDENTITY) 指定主键的生成方式，一般主键为自增的话，就采用GenerationType.IDENTITY的生成方式&lt;/li&gt;
&lt;li&gt;@Column 注解针对一个字段，对应表中的一列。nullable = false表示数据库字段不能为空, unique = true表示数据库字段不能有重复值,length = 32表示数据库字段最大程度为32.&lt;/li&gt;
&lt;li&gt;@Data、@AllArgsConstructor、@NoArgsConstructor、@Builder都是插件lombok的注解，用来帮助我们生成set、get方法、构造函数等实体类的模板代码。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;三repository定义&quot;&gt;三、Repository定义&lt;/h2&gt;
&lt;p&gt;定义一个接口ArticleRepository继承 PagingAndSortingRepository。PagingAndSortingRepository接口不仅包含基础的CURD函数，还支持排序、分页的接口函数定义。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public interface ArticleRepository extends PagingAndSortingRepository&amp;lt;Article,Long&amp;gt; {
     //查询article表的所有数据，传入Pageable分页参数，不需要自己写SQL
    Page&amp;lt;Article&amp;gt; findAll(Pageable pageable);
    //根据author字段查询article表数据，传入Pageable分页参数，不需要自己写SQL
    Page&amp;lt;Article&amp;gt; findByAuthor(String author, Pageable pageable);
    //根据author字段和title字段，查询article表数据，传入Pageable分页参数，不需要自己写SQL
    Slice&amp;lt;Article&amp;gt; findByAuthorAndTitle(String author, String title, Pageable pageable);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;四实现分页&quot;&gt;四、实现分页&lt;/h2&gt;
&lt;p&gt; Pageable 是Spring定义的接口，用于分页参数的传递，我们看看如何使用它。首先将ArticleRepository注入到你需要进行持久层操作的类里面，通常是一个@Service注解的类，然后在服务方法内使用如下代码进行分页操作：查询第一页(从0开始)的数据，每页10条数据。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Pageable pageable = PageRequest.of(0, 10);   //第一页
//Pageable pageable = PageRequest.of(0, 10);  //第二页
//Pageable pageable = PageRequest.of(0, 10);  // 第三页
//数据库操作获取查询结果
Page&amp;lt;Article&amp;gt; articlePage = articleRepository.findAll(pageable);
//将查询结果转换为List
List&amp;lt;Article&amp;gt; articleList = articlePage.getContent();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;findAll方法以Page类的对象作为响应，如果我们想获取查询结果List，可以使用getContent()方法。但是笔者不建议这样进行转换，因为前端展示一个分页列表，不仅需要数据，而且还需要一些分页信息。如：当前第几页，每页多少条，总共多少页，总共多少条。这些信息在Page(articlePage)对象里面均可以获取到(下文中有介绍)。&lt;/p&gt;
&lt;h2 id=&quot;五实现排序&quot;&gt;五、实现排序&lt;/h2&gt;
&lt;p&gt;Spring Data JPA提供了一个 &lt;code&gt;Sort&lt;/code&gt;对象，用以提供一种排序机制。让我们看一下排序的方式。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
articleRepository.findAll(Sort.by(&quot;createTime&quot;));

articleRepository.findAll(Sort.by(&quot;author&quot;).ascending()
                        .and(Sort.by(&quot;createTime&quot;).descending()));
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;第一个findAll方法是按照createTime的升序进行排序&lt;/li&gt;
&lt;li&gt;第一个findAll方法是按照author的升序排序，再按照createTime的降序进行排序&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;分页和排序在一起&quot;&gt;&lt;strong&gt;分页和排序在一起&lt;/strong&gt;&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;Pageable pageable = PageRequest.of(0, 10,Sort.by(&quot;createTime&quot;));&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;六slice与page&quot;&gt;六、Slice与Page&lt;/h2&gt;
&lt;p&gt;在ArticleRepository我们看到了一个方法返回Slice和另一个方法返回了Page。它们都是Spring Data JPA的数据响应接口，其中 Page 是 Slice的子接口。它们都用于保存和返回数据。&lt;/p&gt;
&lt;h3 id=&quot;slice&quot;&gt;6.1.&lt;strong&gt;Slice&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;让我们看一下 Slice的一些重要方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;List &amp;lt;T&amp;gt;  getContent（）; //获取切片的内容

Pageable  getPageable（）; //当前切片的分页信息

boolean  hasContent（）; //是否有查询结果？

boolean  isFirst（）;  //是否是第一个切片

boolean  isLast（）;  //是否是最后一个切片

Pageable nextPageable(); // 下一个切片的分页信息

Pageable previousPageable(); // 上一个切片的分页信息&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;page&quot;&gt;6.2.&lt;strong&gt;Page&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt; Page是Slice的子接口，以下是的一些重要方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//总页数
int getTotalPages();

//总数据条数
long getTotalElements();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;那么，什么时候使用Slice？什么时候使用Page？&lt;/strong&gt;&lt;br/&gt;答：通过这两个接口的函数定义可以看出，Slice只关心是不是存在下一个分片(分页)，不会去数据库count计算总条数、总页数。所以比较适合大数据量列表的的鼠标或手指滑屏操作，不关心总共有多少页，只关心有没有下一页。Page比较适合传统应用中的table开发，需要知道总页数和总条数。&lt;/p&gt;
&lt;h2 id=&quot;期待您的关注&quot;&gt;期待您的关注&lt;/h2&gt;
</description>
<pubDate>Thu, 07 Nov 2019 00:00:00 +0000</pubDate>
<dc:creator>字母哥博客</dc:creator>
<og:description>一、导读 如果一次性加载成千上万的列表数据，在网页上显示将十分的耗时，用户体验不好。所以处理较大数据查询结果展现的时候，分页查询是必不可少的。分页查询必然伴随着一定的排序规则，否则分页数据的状态很难控</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zimug/p/11809827.html</dc:identifier>
</item>
<item>
<title>适用于Windows桌面应用程序的.NET Core 3 - WalterGao</title>
<link>http://www.cnblogs.com/muran/p/11808508.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/muran/p/11808508.html</guid>
<description>&lt;h2 id=&quot;介绍&quot;&gt;介绍&lt;/h2&gt;
&lt;p&gt;9月，微软发布了新版.NET Core，用于构建Windows桌面应用程序，包括WPF和Windows Forms。从那时起开发人员可以将传统的nfx桌面应用程序（和控件库）迁移到.NET Core。一般使用WPF和Windows Forms开发的业务范围包括：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;UI密集数据形式（FOD）应用程序&lt;/li&gt;
&lt;li&gt;响应式低延迟UI&lt;/li&gt;
&lt;li&gt;需要脱机/断开连接运行的应用程序&lt;/li&gt;
&lt;li&gt;依赖于自定义设备驱动程序的应用程序&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这只是.NET Core上Windows应用程序开发的开始。继续阅读以了解有关.NET Core对构建Windows应用程序更多好处的信息。&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;为什么在.net-core上使用windows-desktop&quot;&gt;为什么在.NET Core上使用Windows desktop？&lt;/h2&gt;
&lt;p&gt;.NET Core（以及将来在.NET Core之上构建的.NET 5）将是.NET的未来。在未来几年内微软将继续支持.NET Framework，但是不会增加任何新功能，这些新功能只会添加到.NET Core（最终是.NET 5）中。为了改进Windows桌面应用领域，并使.NET桌面开发人员可以从中受益，微软将Windows Forms和WPF引入了.NET Core，但因为与Windows API紧密相关，所以仍将仅支持Windows平台。但是.NET Core除了可以跨平台使用外，还具有许多其他功能，可以增强桌面应用程序。&lt;/p&gt;
&lt;p&gt;首先，所有运行时改进和语言功能将仅添加到.NET Core中，以后也将添加到.NET 5中。一个很好的例子是C# 8，它已在.NET Core 3.0中可用。而且Windows Forms和WPF的.NET Core版本将成为.NET 5平台的一部分。&lt;/p&gt;
&lt;p&gt;此外，.NET Core通过.NET Framework中不可用的新选项为应用程序带来了部署灵活性，例如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;并行部署&lt;/strong&gt;。可以在同一台计算机上拥有多个.NET Core版本，并且可以选择每个应用程序应针对的版本。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;独立部署&lt;/strong&gt;。可以与应用程序一起部署.NET Core平台，并完全独立于最终用户环境。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;较小的应用程序大小&lt;/strong&gt;。在.NET Core 3中，微软引入了一个称为链接器（有时也称为微调器）的新功能，该功能将分析代码并将所需的程序集包括在自包含的部署中，不需要的都将被修剪掉。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;单个.exe文件&lt;/strong&gt;。可以将应用程序和.NET Core平台打包在一个.exe文件中。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;改进了运行时性能&lt;/strong&gt;。与.NET Framework相比，.NET Core具有许多性能优化。具体来说，在很大程度上依赖于I/O操作，网络和数据库操作的桌面应用程序可能会看到这些方面的性能提高。在UI渲染性能或应用程序启动性能有一定的提示，但不是很高。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;使用readytorun优化.net-core应用&quot;&gt;使用ReadyToRun优化.NET Core应用&lt;/h4&gt;
&lt;p&gt;通过将应用程序程序集编译为ReadyToRun（R2R）格式，可以缩短.NET Core应用程序的启动时间。R2R是一种提前（AOT）编译的形式。它是.NET Core 3.0中的发布时选择功能。&lt;/p&gt;
&lt;p&gt;R2R二进制文件通过减少应用程序加载时JIT需要完成的工作量来提高启动性能。R2R二进制文件较大，因为它们既包含中间语言（IL）代码（某些情况下仍然需要此代码），也包含相同代码的本机版本，以改善启动。&lt;/p&gt;
&lt;p&gt;要启用ReadyToRun编译：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;将&lt;code&gt;PublishReadyToRun&lt;/code&gt;属性设置为&lt;code&gt;true&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;使用显式发布&lt;code&gt;RuntimeIdentifier&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;注意：编译应用程序程序集时，生成的本机代码特定于平台和体系结构（这就是发布时必须指定有效的RuntimeIdentifier的原因）。&lt;/p&gt;
&lt;p&gt;下面是一个例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&amp;gt;
  &amp;lt;PropertyGroup&amp;gt;
    &amp;lt;OutputType&amp;gt;Exe&amp;lt;/OutputType&amp;gt;
    &amp;lt;TargetFramework&amp;gt;netcoreapp3.0&amp;lt;/TargetFramework&amp;gt;
    &amp;lt;PublishReadyToRun&amp;gt;true&amp;lt;/PublishReadyToRun&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;
&amp;lt;/Project&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;并使用以下命令发布：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;dotnet publish -r win-x64 -c Release
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;RuntimeIdentifier&lt;/code&gt;可以将其设置为其他操作系统或芯片。也可以在项目文件中设置。&lt;/li&gt;
&lt;li&gt;如果在发布过程中遇到错误，请添加&lt;code&gt;&amp;lt;PublishReadyToRunShowWarnings&amp;gt;true&amp;lt;/PublishReadyToRunShowWarnings&amp;gt;&lt;/code&gt; 查看详情日志。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;assembly-linking&quot;&gt;Assembly linking&lt;/h4&gt;
&lt;p&gt;.NET core 3.0 SDK附带了一个工具，该工具可以通过分析IL和修剪未使用的程序集来减小应用程序的大小。这是.NET Core 3.0中的另一个发布时选择加入功能。&lt;/p&gt;
&lt;p&gt;借助.NET Core，始终可以发布包含运行代码所需的一切的自包含应用程序，而无需在部署目标上安装.NET。在某些情况下，该应用仅需要框架的一小部分即可运行，并且可能仅包含所使用的库就可以变得更小。&lt;/p&gt;
&lt;p&gt;使用&lt;a href=&quot;https://github.com/mono/linker&quot;&gt;IL链接器&lt;/a&gt;扫描应用程序的IL，以检测实际需要哪些代码，然后修剪未使用的框架库。这可以大大减小某些应用程序的大小。通常，类似小型工具的控制台应用程序受益最大，因为它们倾向于使用框架的较小子集，并且通常更易于调整。&lt;/p&gt;
&lt;p&gt;要使用链接器：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;将&lt;code&gt;PublishTrimmed&lt;/code&gt;属性设置为&lt;code&gt;true&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;使用显式发布&lt;code&gt;RuntimeIdentifier&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面是一个例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&amp;gt;
  &amp;lt;PropertyGroup&amp;gt;
    &amp;lt;OutputType&amp;gt;Exe&amp;lt;/OutputType&amp;gt;
    &amp;lt;TargetFramework&amp;gt;netcoreapp3.0&amp;lt;/TargetFramework&amp;gt;
    &amp;lt;PublishTrimmed&amp;gt;true&amp;lt;/PublishTrimmed&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;
&amp;lt;/Project&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;并使用以下命令发布：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;dotnet publish -r win-x64 -c Release&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：&lt;code&gt;RuntimeIdentifier&lt;/code&gt;可以将其设置为其他操作系统或芯片。也可以在项目文件中设置。&lt;/p&gt;
&lt;p&gt;经测试对于helloworld应用程序，大小从〜68MB减小到〜28MB。&lt;/p&gt;
&lt;p&gt;修剪后使用反射或相关动态功能的应用程序或框架（包括ASP.NET Core和WPF）通常会中断，因为链接器不了解这种动态行为，并且通常无法确定反射所需的框架类型在运行时。要修剪此类应用程序，您需要告知链接器有关代码中以及依赖的任何包或框架中反射所需要的任何类型。修剪后一定要测试应用程序。针对这个问题微软在.NET 5上正在努力改善。&lt;/p&gt;
&lt;p&gt;有关IL Linker的更多信息，请参阅&lt;a href=&quot;https://aka.ms/dotnet-illink&quot;&gt;文档&lt;/a&gt;，或访问&lt;a href=&quot;https://github.com/mono/linker&quot;&gt;mono / linker存储&lt;/a&gt;库。&lt;/p&gt;
&lt;p&gt;注意：在.NET Core的&lt;a href=&quot;https://dotnet.myget.org/feed/dotnet-core/package/nuget/Illink.Tasks&quot;&gt;早期&lt;/a&gt;版本中，&lt;a href=&quot;https://dotnet.myget.org/feed/dotnet-core/package/nuget/Illink.Tasks&quot;&gt;ILLink.Tasks&lt;/a&gt;作为外部NuGet软件包提供，并提供了许多相同的功能。请更新到.NET Core 3.0 SDK，然后尝试新的体验！&lt;/p&gt;
&lt;p&gt;Assembly linking和ReadyToRun compiler可用于同一应用程序。通常，Assembly linking使应用程序更小，ready-to-run compiler 使应用程序更大一些，但在性能上有明显优势。可以在各种配置中进行测试以了解每个选项的影响。&lt;/p&gt;
&lt;h4 id=&quot;发布单文件可执行文件&quot;&gt;发布单文件可执行文件&lt;/h4&gt;
&lt;p&gt;可以使用发布单个文件的可执行文件&lt;code&gt;dotnet publish&lt;/code&gt;。这种形式的单个EXE实际上是一个自解压缩的可执行文件。它包含所有依赖项（包括本地依赖项）作为资源。在第一次启动时，它将所有依赖项复制到一个临时目录，并在该目录中加载它们。它只需要解压缩依赖项一次。当再次启动时将会很快启动，并且没有任何损失。&lt;/p&gt;
&lt;p&gt;可以通过将&lt;code&gt;PublishSingleFile&lt;/code&gt;属性添加到项目文件或在命令行上添加新的参数来启用此发布选项。&lt;/p&gt;
&lt;p&gt;要生成一个独立的单个EXE应用程序，在这种情况下，对于64位Windows：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;dotnet publish -r win10-x64 /p:PublishSingleFile=true&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;RuntimeIdentifier&lt;/code&gt;可以将其设置为其他操作系统或芯片。也可以在项目文件中设置。&lt;/li&gt;
&lt;li&gt;关于临时目录，请参考&lt;a href=&quot;https://github.com/dotnet/designs/blob/master/accepted/single-file/extract.md#extraction-location&quot;&gt;Extracting Bundled Files to Disk&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;有关更多信息，请参见&lt;a href=&quot;https://github.com/dotnet/core-setup/pull/5286&quot;&gt;单文件捆绑器&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;Assembly trimmer, ahead-of-time compilation（通过crossgen）和单个文件捆绑都是.NET Core 3.0中的所有新功能，可以一起使用，也可以单独使用。&lt;/p&gt;
&lt;h4 id=&quot;综合使用&quot;&gt;综合使用&lt;/h4&gt;
&lt;p&gt;通过设置属性&lt;code&gt;&amp;lt;PublishSingleFile&amp;gt;&lt;/code&gt;，&lt;code&gt;&amp;lt;RuntimeIdentifier&amp;gt;&lt;/code&gt;、&lt;code&gt;&amp;lt;PublishTrimmed&amp;gt;&lt;/code&gt;、 &lt;code&gt;&amp;lt;PublishReadyToRun&amp;gt;&lt;/code&gt;、&lt;code&gt;&amp;lt;PublishReadyToRunShowWarnings&amp;gt;&lt;/code&gt;在发布配置文件中，能够将修剪、ahead-of-time compilation后的自包含应用程序部署为单个.exe文件，如下面的示例所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;PropertyGroup&amp;gt;
    &amp;lt;OutputType&amp;gt;Exe&amp;lt;/OutputType&amp;gt;
    &amp;lt;TargetFramework&amp;gt;netcoreapp3.0&amp;lt;/TargetFramework&amp;gt;
    &amp;lt;PublishSingleFile&amp;gt;true&amp;lt;/PublishSingleFile&amp;gt;
    &amp;lt;RuntimeIdentifier&amp;gt;win-x64&amp;lt;/RuntimeIdentifier&amp;gt;
    &amp;lt;PublishReadyToRun&amp;gt;true&amp;lt;/PublishReadyToRun&amp;gt;
    &amp;lt;PublishReadyToRunShowWarnings&amp;gt;true&amp;lt;/PublishReadyToRunShowWarnings&amp;gt;
    &amp;lt;PublishTrimmed&amp;gt;true&amp;lt;/PublishTrimmed&amp;gt;
&amp;lt;/PropertyGroup&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后使用Visual Studio发布工具或者命令&lt;code&gt;dotnet publish -c release&lt;/code&gt;发布。&lt;/p&gt;
&lt;h4 id=&quot;msix&quot;&gt;MSIX&lt;/h4&gt;
&lt;p&gt;如果你正在寻找一种将应用程序分发给最终用户的方法，那么将其打包为&lt;a href=&quot;https://docs.microsoft.com/en-us/windows/msix/&quot;&gt;MSIX&lt;/a&gt;可能比创建单个&lt;code&gt;.exe&lt;/code&gt;文件更好。&lt;code&gt;PublishSingleFile&lt;/code&gt;提供了一个包含所有应用程序依赖项的自解压ZIP文件，而MSIX提供了干净可靠的Windows集成应用程序安装和卸载。《MSDN杂志》上写了&lt;a href=&quot;https://msdn.microsoft.com/en-us/magazine/mt833462&quot;&gt;一篇文章&lt;/a&gt;，不仅展示了如何打包应用程序，而且还展示了如何为MSIX包设置持续集成（CI），持续部署（CD）和自动更新。&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;net-framework-desktop-和.net-core-desktop-之间的区别&quot;&gt;.NET Framework desktop 和.NET Core desktop 之间的区别&lt;/h2&gt;
&lt;p&gt;WPF应用程序在.NET Core上完全受支持。对于Windows Forms，运行时部分已完全移植到.NET Core，并且微软团队正在继续开发&lt;strong&gt;Windows窗体设计器&lt;/strong&gt;。微软计划在2020年第四季度之前将其准备就绪，现在可以在&lt;a href=&quot;https://visualstudio.microsoft.com/vs/preview/&quot;&gt;Visual Studio预览下载页面&lt;/a&gt; 16.4 Preview 3或更高版本中签出设计器的Preview版本。别忘了在&lt;strong&gt;工具-&amp;gt;选项-&amp;gt;预览功能-&amp;gt;使用.NET Core应用程序的Windows窗体设计器预览，然后重新启动Visual Studio&lt;/strong&gt; 。&lt;/p&gt;
&lt;h3 id=&quot;重大变化&quot;&gt;重大变化&lt;/h3&gt;
&lt;p&gt;.NET Framework和.NET Core之间有一些&lt;a href=&quot;https://docs.microsoft.com/dotnet/core/compatibility/framework-core&quot;&gt;重大更改&lt;/a&gt;，但与Windows窗体和WPF区域相关的大多数代码都按原样移植到了Core。如果使用的组件包括WCF客户端，代码访问安全性，应用程序域，互操作性和远程处理，则要切换到.NET Core，则需要重构代码。&lt;/p&gt;
&lt;p&gt;请记住另一件事，.NET Core上的默认输出路径与.NET Framework上的默认输出路径不同，因此，如果在代码中对正在运行的应用程序的文件/文件夹结构进行了一些假设，则它可能会在运行时失败。&lt;/p&gt;
&lt;p&gt;此外，配置.NET功能的方式也有所变化。.NET Core而非&lt;code&gt;machine.config&lt;/code&gt;文件使用的&lt;code&gt;&amp;lt;something&amp;gt;.runtimeconfig.json&lt;/code&gt;是应用程序随附的文件，该文件具有相同的通用目的和相似的信息。一些配置，如&lt;code&gt;system.diagnostics&lt;/code&gt;，&lt;code&gt;system.net&lt;/code&gt;或&lt;code&gt;system.servicemodel&lt;/code&gt;不被支持，那么应用程序配置文件将失败是否含有这些内容的加载。此更改影响&lt;code&gt;System.Diagnostics&lt;/code&gt;以前使用XML配置通常配置的跟踪和WCF客户端方案。在.NET Core中，需要改为在代码中进行配置。要更改行为而无需重新编译，请考虑使用从&lt;code&gt;Microsoft.Extensions.Configuration&lt;/code&gt;源或从中加载的值来设置跟踪和WCF类型&lt;code&gt;appSettings&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;可以在&lt;a href=&quot;https://docs.microsoft.com/dotnet/core/porting/net-framework-tech-unavailable&quot;&gt;.NET Core无法使用的.NET Framework技术&lt;/a&gt;找到有关.NET Core和.NET Framework之间差异的更多信息。&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;从.net-framework移植到.net-core&quot;&gt;从.NET Framework移植到.NET Core&lt;/h2&gt;
&lt;p&gt;首先，运行&lt;a href=&quot;https://github.com/Microsoft/dotnet-apiport-ui/releases/download/1.1/PortabilityAnalyzer.zip&quot;&gt;可移植性分析器&lt;/a&gt;并在需要时更新代码以与.NET Core 100％兼容。这是&lt;a href=&quot;https://devblogs.microsoft.com/dotnet/are-your-windows-forms-and-wpf-applications-ready-for-net-core-3-0/&quot;&gt;有关使用可移植性分析器的说明&lt;/a&gt;。建议在对应用程序进行任何更改之前使用源代码控制或备份代码，以防重构无法按照希望的方式进行。&lt;/p&gt;
&lt;p&gt;当应用程序与.NET Core完全兼容时，就可以准备移植它了。首先，可以尝试使用工具&lt;a href=&quot;https://github.com/dotnet/try-convert&quot;&gt;try-convert&lt;/a&gt;以帮助将.NET Framework项目自动转换为.NET Core。&lt;/p&gt;
&lt;p&gt;此工具只是通往.NET Core的起点。它也不是受支持的Microsoft产品。尽管它可以帮助解决迁移的某些机械问题，但它不能处理所有方案或项目类型。如果遇到该工具无法转换的项目，则必须手动进行移植。&lt;/p&gt;
&lt;h2 id=&quot;关于.net-core3.1的支持&quot;&gt;关于.Net Core3.1的支持&lt;/h2&gt;
&lt;p&gt;.NET Core 3.1是一个小型且简短的发行版，着重于Blazor和Windows桌面应用（.NET Core 3.0的两个重大改进）的关键改进。这将是一个长期支持（LTS）版本，至少支持3年，预计最终发布日期为2019年12月。&lt;br/&gt;此版本中最大的改进是&lt;strong&gt;对C++/CLI（又称为“托管C++”）的支持&lt;/strong&gt;。&lt;/p&gt;
</description>
<pubDate>Wed, 06 Nov 2019 23:31:00 +0000</pubDate>
<dc:creator>WalterGao</dc:creator>
<og:description>介绍 9月，微软发布了新版.NET Core，用于构建Windows桌面应用程序，包括WPF和Windows Forms。从那时起开发人员可以将传统的nfx桌面应用程序（和控件库）迁移到.NET Co</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/muran/p/11808508.html</dc:identifier>
</item>
<item>
<title>Head First设计模式——简单工厂、工厂、抽象工厂 - Spring2Sun</title>
<link>http://www.cnblogs.com/SunSpring/p/11809721.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/SunSpring/p/11809721.html</guid>
<description>&lt;p&gt;前言：按照惯例我以Head First设计模式的工厂模式例子开始编码学习。并由简单工厂，工厂模式，抽象工厂模式依次演变，归纳他们的相同与不同。&lt;/p&gt;
&lt;p&gt;话说Head First认为简单工厂并不是设计模式，而是一种编程习惯，但并不妨碍我们使用它，接下来我们对工厂模式一探究竟。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;1、披萨店例子&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;首先我们要开一个披萨店，对于业务不复杂的情况下我们可以快速的开发出一个披萨店以及订购披萨的逻辑&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
    public Pizza OrderPizza() {
            Pizza pizza = new Pizza();

            pizza.Prepare();
            pizza.Bake();
            pizza.Cut();
            pizza.Box();
            return pizza;
        }
    }

    public  class Pizza {
        //准备
        public void Prepare() { }
        //烘烤
        public void Bake() { }
        //切片
        public void Cut() { }
        //装盒
        public void Box() { }
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;     如果我们有更多的披萨种类可能需要将Pizza定义成抽象类 在订单里面根据订购的披萨种类返回不同的披萨，我们对披萨进行抽象并改造Order。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
    public class PizzaStore
    {
        public Pizza OrderPizza(string type)
        {
            Pizza pizza=null;
            if (type == &quot;cheese&quot;)
            {
                pizza = new CheesePizza();
            }
            else if (type == &quot;viggie&quot;) {
                pizza = new VeggiePizza();
            }
            //else if ......
            pizza.Prepare();
            pizza.Bake();
            pizza.Cut();
            pizza.Box();
            return pizza;
        }
    }

    public abstract class Pizza
    {
        //准备
        public void Prepare() { }
        //烘烤
        public void Bake() { }
        //切片
        public void Cut() { }
        //装盒
        public void Box() { }
    }

    //奶酪披萨
    public class CheesePizza : Pizza
    {
    }
    //素食披萨
    public class VeggiePizza : Pizza
    {
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;   到这里我们可能想到了，如果增加披萨种类或者移除披萨那么我们将对披萨店进行修改。&lt;/p&gt;
&lt;p&gt;   设计原则对扩展开放，对修改关闭。我们需要将创建披萨的变化封装起来。对此弄出来一个专门创建披萨的“工厂“类。&lt;/p&gt;
&lt;p&gt;   并采用静态，这样就不需要实例化对象，也遵循了不对实现编程原则。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
 public class PizzaStore
    {
        public Pizza OrderPizza(string type)
        {
            Pizza pizza = SimplePizzaFactory.CreatePizza(type);

            pizza.Prepare();
            pizza.Bake();
            pizza.Cut();
            pizza.Box();
            return pizza;
        }
    }

    public static class SimplePizzaFactory {
        public static Pizza CreatePizza(string type) {
            Pizza pizza = null;
            if (type == &quot;cheese&quot;)
            {
                pizza = new CheesePizza();
            }
            else if (type == &quot;viggie&quot;)
            {
                pizza = new VeggiePizza();
            }
            return pizza;
        }
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这样将创建披萨简单的封装起来即是简单工厂（静态工厂），简单工厂也可以不用静态类，但简单工厂并不是一种专门的设计模式（有时候可能会混淆，认为这即是”工厂模式“），更像是我们平时编程都会做的一种习惯。我们将改动封装在一个局部当有变化的时候只需要修改这个工厂类。&lt;/p&gt;
&lt;h3&gt;2、更多的披萨店&lt;/h3&gt;
&lt;p&gt;现在我们要开更多的披萨店，例如美国风格披萨店（USSytlePizzaStore）、中国风格披萨店(CHNSytlePizzaStore)。&lt;/p&gt;
&lt;p&gt;我们可以采用简单工厂模式，创建两个不同风格的披萨工厂，然后创建两个不同风格的披萨店，不同风格的披萨店使用对应的披萨工厂来获取。&lt;/p&gt;
&lt;p&gt;但是我们此时的变化点是披萨店。我们希望披萨店的结构或者流程是按照一定规则的，只是不同风格的披萨。此时我们有更好的解决办法：工厂模式。&lt;/p&gt;
&lt;p&gt;接下来我们看如何实现&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
    public abstract class PizzaStore
    {
        public Pizza OrderPizza(string type)
        {
            Pizza pizza= CreatePizza(type);
            

            pizza.Prepare();
            pizza.Bake();
            pizza.Cut();
            pizza.Box();
            return pizza;
        }

        public abstract Pizza CreatePizza(string type);
    }

    public class USSytlePizzaStore : PizzaStore
    {
        public override Pizza CreatePizza(string type)
        {
            Pizza pizza = null;
            if (type == &quot;cheese&quot;)
            {
                pizza = new USStyleCheesePizza();
            }
            else if (type == &quot;viggie&quot;)
            {
                pizza = new USStyleVeggiePizza();
            }
            return pizza;
        }
    }

    public class CHNSytlePizzaStore : PizzaStore
    {
        public override Pizza CreatePizza(string type)
        {
            Pizza pizza = null;
            if (type == &quot;cheese&quot;)
            {
                pizza = new CHNStyleCheesePizza();
            }
            else if (type == &quot;viggie&quot;)
            {
                pizza = new CHNStyleVeggiePizza();
            }
            return pizza;
        }
    }

    //US奶酪披萨
    public class USStyleCheesePizza : Pizza
    {
    }
    //US素食披萨
    public class USStyleVeggiePizza : Pizza
    {
    }

    //CHN奶酪披萨
    public class CHNStyleCheesePizza : Pizza
    {
    }
    //CHN素食披萨
    public class CHNStyleVeggiePizza : Pizza
    {
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;   由实现我们可以看到我们将PizzaStore修改成抽象类，不同的披萨店继承抽象类返回自己不同风格的披萨。&lt;/p&gt;
&lt;p&gt;   这样设计后当增加产品，我们也只是在具体的子类披萨店中修改其中的披萨创建，不会影响披萨店本身流程和其他披萨店的实现。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  工厂方法模式：定义了一个创建对象的接口，由子类决定要实例化的类是哪一个，工厂方法让类把实例化推迟到子类。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  工厂方法与简单工厂的区别：工厂方法的子类看起来很像简单工厂。简单工厂把全部的事情在一个地方处理完成，而工厂方法却是创建一个框架，让子类决定如何实现。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;3、披萨的不同原料&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;不同风格的披萨店有不同风格的披萨，而这些披萨的不同风格是来自不同原料造成，所以不同风格的披萨变化的部分是材料。&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我们先建造原料和原料工厂，以中国披萨原料工厂为例&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
//披萨原料工厂接口 &lt;br/&gt;public interface PizzaIngredientFactory {
        public Veggie CreateVeggie();
        public Cheese CreateCheese();
    }&lt;br/&gt;//具体工厂实现&lt;br/&gt;public class CNHPizzaIngredientFactory : PizzaIngredientFactory
    {
        public Cheese CreateCheese()
        {
            return new CHNCheese();
        }

        public Veggie CreateVeggie()
        {
            return new CHNVeggie();
        }
    }

    public abstract class Veggie
    {
    }
    public class USVeggie : Veggie { 
    }
    public class CHNVeggie : Veggie { 
    }

    public abstract class Cheese
    {
    }
    public class USCheese : Cheese
    {
    }
    public class CHNCheese : Cheese
    {
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　然后重做Pizza&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
    public abstract class Pizza
    {
        public String Name;
        Veggie veggie;
        Cheese cheese;
        //准备
        public abstract void Prepare()；
        //烘烤
        public void Bake() { }
        //切片
        public void Cut() { }
        //装盒
        public void Box() { }
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　加入了原料的抽象 Veggie 和 Cheese,同时我们让Prepare变成抽象方法，让他的具体子类决定用什么材制造不同风格的披萨。接着我们重做子类，以CheesePizza为例 &lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
    //奶酪披萨
    public class CheesePizza : Pizza
    {
        PizzaIngredientFactory IngredientFactory;
        public CheesePizza(PizzaIngredientFactory IngredientFactory) {
            this.IngredientFactory = IngredientFactory;
        }
        public override void Prepare()
        {
            IngredientFactory.CreateCheese();
        }
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　修改中国披萨店&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
    public class CHNSytlePizzaStore : PizzaStore
    {
        public override Pizza CreatePizza(string type)
        {
            Pizza pizza = null;&lt;br/&gt;//创建中国原材料工厂
            CNHPizzaIngredientFactory ingredientFactory = new CNHPizzaIngredientFactory();
            if (type == &quot;cheese&quot;)
            {
                pizza = new CheesePizza(ingredientFactory);
            }
            else if (type == &quot;viggie&quot;)
            {
                pizza = new VeggiePizza(ingredientFactory);
            }
            return pizza;
        }
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过这一系列的改造我们引入了新类型的工厂，也就是所谓的抽象工厂，抽象工厂用来创造原料。&lt;/p&gt;
&lt;p&gt;利用抽象工厂我们代码将从实际工厂解耦，这样如果我们的工厂需要扩展那么我们则可在子类中进行修改扩展。&lt;/p&gt;
&lt;p&gt;工厂方法与抽象工厂的异同优缺点&lt;/p&gt;
&lt;p&gt;&lt;span&gt;相同：都是用来创建对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不同：工厂方法使用的是继承，抽象工厂使用的是组合。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;优点：工厂方法只负责从具体类型中解耦，抽象工厂适合将一群相关的产品集合起来。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;缺点：抽象工厂扩展接口需要修改每个子类。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 06 Nov 2019 17:38:00 +0000</pubDate>
<dc:creator>Spring2Sun</dc:creator>
<og:description>前言：按照惯例我以Head First设计模式的工厂模式例子开始编码学习。并由简单工厂，工厂模式，抽象工厂模式依次演变，归纳他们的相同与不同。 话说Head First认为简单工厂并不是设计模式，而是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/SunSpring/p/11809721.html</dc:identifier>
</item>
<item>
<title>Dubbo 全链路追踪日志的实现 - 后端进阶</title>
<link>http://www.cnblogs.com/objcoding/p/11809709.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/objcoding/p/11809709.html</guid>
<description>&lt;p&gt;微服务架构的项目，一次请求可能会调用多个微服务，这样就会产生多个微服务的请求日志，当我们想要查看整个请求链路的日志时，就会变得困难，所幸的是我们有一些集中日志收集工具，比如很热门的ELK，我们需要把这些日志串联起来，这是一个很关键的问题，如果没有串联起来，查询起来很是很困难，我们的做法是在开始请求系统时生成一个全局唯一的id，这个id伴随这整个请求的调用周期，即当一个服务调用另外一个服务的时候，会往下传递，形成一条链路，当我们查看日志时，只需要搜索这个id，整条链路的日志都可以查出来了。&lt;/p&gt;
&lt;p&gt;现在以dubbo微服务架构为背景，举个栗子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;A -&amp;gt; B -&amp;gt; C&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们需要将A/B/C/三个微服务间的日志按照链式打印，我们都知道Dubbo的RpcContext只能做到消费者和提供者共享同一个RpcContext，比如A-&amp;gt;B，那么A和B都可以获取相同内容的RpcContext，但是B-&amp;gt;C时，A和C就无法共享相同内容的RpcContext了，也就是无法做到链式打印日志了。&lt;/p&gt;
&lt;p&gt;那么我们是如何做到呢？&lt;/p&gt;
&lt;p&gt;我们可以用左手交换右手的思路来解决，假设左手是线程的ThreadLocal，右手是RpcContext，那么在交换之前，我们首先将必要的日志信息保存到ThreadLocal中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在我们的项目微服务中大致分为两种容器类型的微服务，一种是Dubbo容器，这种容器的特点是只使用spring容器启动，然后使用dubbo进行服务的暴露，然后将服务注册到zookeeper，提供服务给消费者；另一种是SpringMVC容器，也即是我们常见的WEB容器，它是我们项目唯一可以对外开放接口的容器，也是充当项目的网关功能。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在了解了微服务容器之后，我们现在知道了调用链的第一层一定是在SpringMVC容器层中，那么我们直接在这层写个自定义拦截器就ojbk了，talk is cheap，show you the demo code：&lt;/p&gt;
&lt;p&gt;举例一个Demo代码，公共拦截器的前置拦截中代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class CommonInterceptor implements HandlerInterceptor {
    @Override
    public boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object handler)
        throws Exception {

        // ...

        // 初始化全局的Context容器
        Request request = initRequest(httpServletRequest);
        // 新建一个全局唯一的请求traceId，并set进request中
        request.setTraceId(JrnGenerator.genTraceId());
        // 将初始化的请求信息放进ThreadLocal中
        Context.initialLocal(request);

        // ...

        return true;
    }
    
    // ...
    
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;系统内部上下文对象：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Context {
    
    // ...
    
    private static final ThreadLocal&amp;lt;Request&amp;gt; REQUEST_LOCAL = new ThreadLocal&amp;lt;&amp;gt;();
    
    public final static void initialLocal(Request request) {
        if (null == request) {
            return;
        }
        REQUEST_LOCAL.set(request);
    }
    
    public static Request getCurrentRequest() {
        return REQUEST_LOCAL.get();
    }
    
    // ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;拦截器实现了&lt;code&gt;org.springframework.web.servlet.HandlerInterceptor&lt;/code&gt;接口，它的主要作用是用于拦截处理请求，可以在MVC层做一些日志记录与权限检查等操作，这相当于MVC层的AOP，即符合横切关注点的所有功能都可以放入拦截器实现。&lt;/p&gt;
&lt;p&gt;这里的&lt;code&gt;initRequest(httpServletRequest);&lt;/code&gt;就是将请求信息封装成系统内容的请求对象&lt;code&gt;Request&lt;/code&gt;，并初始化一个全局唯一的traceId放进Request中，然后再把它放进系统内部上下文ThreadLocal字段中。&lt;/p&gt;
&lt;p&gt;接下来讲讲如何将ThreadLocal中的内容放到RpcContext中，在讲之前，我先来说说Dubbo基于spi扩展机制，官方文档对拦截器扩展解释如下：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;服务提供方和服务消费方调用过程拦截，Dubbo 本身的大多功能均基于此扩展点实现，每次远程方法执行，该拦截都会被执行，请注意对性能的影响。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;也就是说我们进行服务远程调用前，拦截器会对此调用进行拦截处理，那么就好办了，在消费者调用远程服务之前，我们可以偷偷把ThreadLocal的内容放进RpcContext容器中，我们可以基于dubbo的spi机制扩展两个拦截器，一个在消费者端生效，另一个在提供者端生效：&lt;/p&gt;
&lt;p&gt;在META-INF中加入com.alibaba.dubbo.rpc.Filter文件，内容如下：&lt;/p&gt;
&lt;pre class=&quot;properties&quot;&gt;
&lt;code&gt;provider=com.objcoding.dubbo.filter.ProviderFilter
consumer=com.objcoding.dubbo.filter.ConsumerFilter&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;消费者端拦截处理：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
public class ConsumerFilter implements Filter {
    @Override
    public Result invoke(Invoker&amp;lt;?&amp;gt; invoker, Invocation invocation) 
        throws RpcException {

        //1.从ThreadLocal获取请求信息
        Request request = Context.getCurrentRequest();
        //2.将Context参数放到RpcContext
        RpcContext rpcCTX = RpcContext.getContext();
        // 将初始化的请求信息放进ThreadLocal中
        Context.initialLocal(request);

        // ...

    }   
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Context.getCurrentRequest();&lt;/code&gt;就是从ThreadLocal中拿到Request请求内容，&lt;code&gt;contextToDubboContext(request);&lt;/code&gt;将Request内容放进当前线程的RpcContext容器中。&lt;/p&gt;
&lt;p&gt;很容易联想到提供者也就是把RpcContext中的内容拿出来放到ThreadLocal中：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class ProviderFilter extends AbstractDubboFilter implements Filter{
     @Override
    public Result invoke(Invoker&amp;lt;?&amp;gt; invoker, Invocation invocation) 
        throws RpcException {
        // 1.获取RPC远程调用上下文
        RpcContext rpcCTX = RpcContext.getContext();
        // 2.初始化请求信息
        Request request = dubboContextToContext(rpcCTX);
        // 3.将初始化的请求信息放进ThreadLocal中
        Context.initialLocal(request);

        // ...

    }   
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来我们还要配置log4j2，使得我们同一条请求在关联的每一个容器打印的消息，都有一个共同的traceId，那么我们在ELK想要查询某个请求时，只需要搜索traceId，就可以看到整条请求链路的日志了。&lt;/p&gt;
&lt;p&gt;我们在Context上下文对象的&lt;code&gt;initialLocal(Request request)&lt;/code&gt;方法中在log4j2的上下文中添加traceId信息：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Context {
    
    // ...

    final public static String TRACEID = &quot;_traceid&quot;;

    public final static void initialLocal(Request request) {
        if (null == request) {
            return;
        }
        // 在log4j2的上下文中添加traceId
        ThreadContext.put(TRACEID, request.getTraceId());
        REQUEST_LOCAL.set(request);
    }
    
    // ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来实现&lt;code&gt;org.apache.logging.log4j.core.appender.rewrite.RewritePolicy&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Plugin(name = &quot;Rewrite&quot;, category = &quot;Core&quot;, elementType = &quot;rewritePolicy&quot;, printObject = true)
public final class MyRewritePolicy implements RewritePolicy {

    // ...
    
    @Override
    public LogEvent rewrite(final LogEvent source) {
        HashMap&amp;lt;String, String&amp;gt; contextMap = Maps.newHashMap(source.getContextMap());
        contextMap.put(Context.TRACEID, contextMap.containsKey(Context.TRACEID) ? contextMap.get(Context.TRACEID) : NULL);
        return new Log4jLogEvent.Builder(source).setContextMap(contextMap).build();
    }
    
    // ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;RewritePolicy的作用是我们每次输出日志，log4j都会调用这个类进行一些处理的操作。&lt;/p&gt;
&lt;p&gt;配置log4j2.xml：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;Configuration status=&quot;warn&quot;&amp;gt;
    &amp;lt;Appenders&amp;gt;
        &amp;lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&amp;gt;
            &amp;lt;PatternLayout
                pattern=&quot;[%d{yyyy/MM/dd HH:mm:ss,SSS}][${ctx:_traceid}]%m%n&quot; /&amp;gt;
        &amp;lt;/Console&amp;gt;
        
        &amp;lt;!--定义一个Rewrite--&amp;gt;
        &amp;lt;Rewrite name=&quot;Rewrite&quot;&amp;gt;
            &amp;lt;MyRewritePolicy/&amp;gt;
            &amp;lt;!--引用输出模板--&amp;gt;
            &amp;lt;AppenderRef ref=&quot;Console&quot;/&amp;gt;
        &amp;lt;/Rewrite&amp;gt;
    &amp;lt;/Appenders&amp;gt;
    &amp;lt;Loggers&amp;gt;
       
        &amp;lt;!--使用日志模板--&amp;gt;
        &amp;lt;Logger name=&quot;com.objcoding.MyLogger&quot; level=&quot;debug&quot; additivity=&quot;false&quot;&amp;gt;
            &amp;lt;!--引用Rewrite--&amp;gt;
            &amp;lt;AppenderRef ref=&quot;Rewrite&quot;/&amp;gt;
        &amp;lt;/Logger&amp;gt;
    &amp;lt;/Loggers&amp;gt;
&amp;lt;/Configuration&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;自定义日志类：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class MyLogger {
    private static final Logger logger = LoggerFactory.getLogger(MyLogger.class);
    
     public static void info(String msg, Object... args) {
        if (canLog() == 1 &amp;amp;&amp;amp; logger.isInfoEnabled()) {
            logger.info(msg, args);
        }
    }
    
    public static void debug(String message, Object... args) {
        if (canLog() == 1 &amp;amp;&amp;amp; logger.isDebugEnabled()) {
            logger.debug(message, args);
        }
    }
    
    // ..
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;更多精彩文章请关注作者维护的公众号「后端进阶」，这是一个专注后端相关技术的公众号。&lt;br/&gt;关注公众号并回复「后端」免费领取后端相关电子书籍。&lt;br/&gt;欢迎分享，转载请保留出处。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1860306/201911/1860306-20191107010000897-1336452455.jpg&quot; alt=&quot;公众号「后端进阶」，专注后端技术分享！&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 06 Nov 2019 17:00:00 +0000</pubDate>
<dc:creator>后端进阶</dc:creator>
<og:description>微服务架构的项目，一次请求可能会调用多个微服务，这样就会产生多个微服务的请求日志，当我们想要查看整个请求链路的日志时，就会变得困难，所幸的是我们有一些集中日志收集工具，比如很热门的ELK，我们需要把这</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/objcoding/p/11809709.html</dc:identifier>
</item>
<item>
<title>【重构】Android Studio在代码重构中的妙用 - 宋者为王</title>
<link>http://www.cnblogs.com/andy-songwei/p/11809700.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/andy-songwei/p/11809700.html</guid>
<description>&lt;p&gt;       代码重构几乎是每个程序员在软件开发中必须要不断去做的事情，以此来不断提高代码的质量。Android Stido（以下简称AS）以其强大的功能，成为当下Android开发工程师最受欢迎的开发工具，也是Android官方推荐使用的工具。如此优秀的工具，自然少不了要在代码重构这件事情上好好表现一把了。本文将通过代码演示，功能截图来详细介绍AS为代码重构提供的各项功能。&lt;/p&gt;
&lt;p&gt;       在AS的主菜单栏中有一项“Refactor”下拉菜单，点击该下拉菜单，会看到如下的界面，菜单中的每一项，都是为代码重构提供的一项自动实现功能。这么多的功能项，可见AS在代码重构功能上的强大，下面我们对这些功能项一一进行介绍。另外，还可以在编辑界面中点击右键，在弹出的菜单中也可以找到“Refactor”。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201911/472002-20191106122446987-960201700.png&quot; alt=&quot;&quot; width=&quot;484&quot; height=&quot;576&quot;/&gt;&lt;/p&gt;

&lt;p&gt;1、Refactor This&lt;/p&gt;
&lt;p&gt;       作用：重构当前。操作此项，会显示对当前光标选中处可行的重构方法。&lt;/p&gt;
&lt;p&gt;       示例：选择了类名“RefactorTest”，操作“Refactor This”后，显示了可执行的重构方法列表，可以通过选择数字来执行对应的方法。&lt;/p&gt;
&lt;p&gt;       &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201911/472002-20191105192611574-1169088005.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;2、Rename&lt;/p&gt;
&lt;p&gt;       作用：对光标选中项进行重命名。不仅可以对类中的成员变量进行重命名，还能对文件名，包名等进行重命名，Module中与之相关联的所有地方都会一起修改，而不用一一手动修改。&lt;/p&gt;
&lt;p&gt;       快捷键：Shift + F6&lt;/p&gt;
&lt;p&gt;       示例：在红框中输入修改后的名称，并按Enter键即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201911/472002-20191105194319671-862929977.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;3、Rename File&lt;/p&gt;
&lt;p&gt;       作用：修改当前编辑界面显示的文件的文件名。就相当于鼠标选中该文件，并执行“Rename”方法。&lt;/p&gt;
&lt;p&gt;       示例：在显示的对话框中输入新文件名。可以在下方的选项框中选择修改范围，引用该文件的地方，注释，字符串中都可以选择一起修改。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201911/472002-20191105193812833-1243142756.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;4、Change Signature&lt;/p&gt;
&lt;p&gt;       作用：修改方法、类、构造函数的签名，其实就是修改所选项的一些属性。&lt;/p&gt;
&lt;p&gt;       快捷键：Ctr l+ F6&lt;code&gt;&lt;br/&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;       示例：如下展示了一个方法重构前，重构过程，以及重构后的情形（以修改一个方法签名为例）。&lt;/p&gt;
&lt;p&gt;       重构前：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; testChangeSignature(&lt;span&gt;int&lt;/span&gt; first, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; second) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;选中方法名后，执行该重构方法后，会弹出如下对话框，可以对该方法各种属性进行修改，添加/删除参数，调整参数顺序，新增/删除异常等。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201911/472002-20191105200640322-510406496.png&quot; alt=&quot;&quot; width=&quot;595&quot; height=&quot;493&quot;/&gt;&lt;/p&gt;
&lt;p&gt;        重构后：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; testChangeSignature(&lt;span&gt;int&lt;/span&gt; second, &lt;span&gt;int&lt;/span&gt; first, String third) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; NullPointerException {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;5、Type Migration&lt;/p&gt;
&lt;p&gt;       作用：类型迁移，即对变量数据类型，或者方法的返回类型进行修改。前面介绍了对文件名，包名，变量名等进行修改，这里对类型进行修改。&lt;/p&gt;
&lt;p&gt;       快捷键：Ctrl + Shift + F6&lt;/p&gt;
&lt;p&gt;       重构前：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; age = 10&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; RefactorTest(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; age) {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;选中要修改的类型，执行该重构方法，会弹出对话框，根据需要编辑类型，选中作用范围即可。指定范围内，与该变量相关联处都会被修改。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201911/472002-20191105202944762-1405752833.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;重构后（由于从int修改到String，所以还需要手动修改变量值）： &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; String age = &quot;10&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; RefactorTest(String age) {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;  6、Make Static&lt;/p&gt;
&lt;p&gt;       作用：给内部类或者方法添加static关键字。示例比较简单，就不做演示了。&lt;/p&gt;

&lt;p&gt;  7、Convert To Instance Method&lt;/p&gt;
&lt;p&gt;       作用： 转换为实例方法，即将静态方法去掉static关键字。&lt;/p&gt;

&lt;p&gt;  8、Move&lt;/p&gt;
&lt;p&gt;       功能：移动文件到指定路径&lt;/p&gt;
&lt;p&gt;       快捷键：F6&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201911/472002-20191106085134012-633443800.png&quot; alt=&quot;&quot; width=&quot;497&quot; height=&quot;295&quot;/&gt;&lt;/p&gt;

&lt;p&gt;9、Copy&lt;/p&gt;
&lt;p&gt;       作用：在指定包中拷贝一份当前文件&lt;/p&gt;
&lt;p&gt;       快捷键：F5&lt;code&gt;&lt;br/&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201911/472002-20191106085218589-1891729928.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;10、Safe Detele&lt;/p&gt;
&lt;p&gt;       作用：安全删除，可用于对方法/字段等进行快速删除，会删除掉与之相关联的引用。&lt;/p&gt;
&lt;p&gt;       快捷键：Alt + Delete&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201911/472002-20191106090020104-1911178906.png&quot; alt=&quot;&quot; width=&quot;452&quot; height=&quot;258&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201911/472002-20191106090115260-1787502757.png&quot; alt=&quot;&quot; width=&quot;467&quot; height=&quot;167&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201911/472002-20191106090236384-1242114519.png&quot; alt=&quot;&quot; width=&quot;461&quot; height=&quot;265&quot;/&gt;&lt;/p&gt;

&lt;p&gt;11、Extract&lt;/p&gt;
&lt;p&gt;   （1）Variable &lt;/p&gt;
&lt;p&gt;       作用：提取变量。这一点在碰到比较长的表达式时经常用到，将看起来很长很复杂的表达式提取出来作为一个变量表示。&lt;/p&gt;
&lt;p&gt;       快捷键：Ctrl + Alt + V&lt;/p&gt;
&lt;p&gt;       重构前：我们常会看到这样的代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testExtractVariable() {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;      Log.i(&quot;demo&quot;, &quot;age=&quot; + getAaaaaaaaaaaaaaaaaaaaaaaaaaaAge() + &quot;;name=&quot; +&lt;span&gt; getNnnnnnnnnnnnnnnnnnnnnnname());
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt; }
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;  &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getAaaaaaaaaaaaaaaaaaaaaaaaaaaAge() {
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;      &lt;span&gt;return&lt;/span&gt;&lt;span&gt; age;
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt; }
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;  &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String getNnnnnnnnnnnnnnnnnnnnnnname() {
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;      &lt;span&gt;return&lt;/span&gt;&lt;span&gt; name;
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;  }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第二行的要打印的信息表达式太长了，希望单独提取出来用一个变量表示。本示例中鼠标停留在第2行“getAaaaaaaaaaaaaaaaaaaaaaaaaaaAge”处，执行该重构方法，会弹出如下红框部分对话框，显示的是选中表达式相关的可提取部分，根据需要选择要提取的部分即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201911/472002-20191106093709272-193079948.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;重构后： &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testExtractVariable() {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     String msg = &quot;age=&quot; + getAaaaaaaaaaaaaaaaaaaaaaaaaaaAge() + &quot;;name=&quot; +&lt;span&gt; getNnnnnnnnnnnnnnnnnnnnnnname();
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     Log.i(&quot;demo&quot;&lt;span&gt;, msg);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getAaaaaaaaaaaaaaaaaaaaaaaaaaaAge() {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; age;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String getNnnnnnnnnnnnnnnnnnnnnnname() {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; name;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    （2）Constant&lt;/p&gt;
&lt;p&gt;       作用：提取常量，将表达式中的值提取为常量。&lt;/p&gt;
&lt;p&gt;       快捷键：Ctrl + Alt +C&lt;/p&gt;
&lt;p&gt;       重构前：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testExtractConstant() {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;   String filename = &quot;sdcard&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201911/472002-20191106095529640-116961016.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;重构后：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String SDCARD = &quot;sdcard&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testExtractConstant() {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;   String filename =&lt;span&gt; SDCARD;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    （3）Filed&lt;/p&gt;
&lt;p&gt;       作用：提取字段，将局部变量提取为全局变量。&lt;/p&gt;
&lt;p&gt;       快捷键：Ctrl + Alt +F&lt;/p&gt;
&lt;p&gt;       重构前：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testExtractField() {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;    String name =&quot;zhangsan&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201911/472002-20191106100616258-927557805.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;        重构后：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String string = &quot;zhangsan&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testExtractField() {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    （4）Parameter&lt;/p&gt;
&lt;p&gt;       作用：将局部变量提取为方法的参数。&lt;/p&gt;
&lt;p&gt;       快捷键：Ctrl + Alt +P&lt;/p&gt;
&lt;p&gt;       重构前：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testExtractParameter() {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;    printName();
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; printName(){
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     String name = &quot;zhangsan&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     Log.i(&quot;demo&quot;,&quot;My name is:&quot;+&lt;span&gt;name);
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201911/472002-20191106102316735-930313326.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;      重构后：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testExtractParameter() {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     printName(&quot;zhangsan&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; printName(String name){
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     Log.i(&quot;demo&quot;,&quot;My name is:&quot;+&lt;span&gt; name);
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    （5）Functional Parameter （ 函数式参数 ） &lt;code&gt;Ctrl + Alt + Shift + P&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;    （6）Parameter Object&lt;/p&gt;
&lt;p&gt;       作用：将参数提取为一个对象。该功能主要是针对参数比较多的时候，将这些参数提取出来作为一个Bean实例传入。&lt;/p&gt;
&lt;p&gt;       重构前：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testExtractParamObject() {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     String info = getInfo(&quot;zhangshan&quot;, 20&lt;span&gt;, 180f);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; String getInfo(String name, &lt;span&gt;int&lt;/span&gt; age, &lt;span&gt;float&lt;/span&gt;&lt;span&gt; height) {
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &quot;name=&quot; + name + &quot;;age=&quot; + age + &quot;;height=&quot; +&lt;span&gt; height;
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201911/472002-20191106110159641-1021638230.png&quot; alt=&quot;&quot; width=&quot;512&quot; height=&quot;695&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       重构后：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testExtractParamObject() {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     String info = getInfo(&lt;span&gt;new&lt;/span&gt; Person(&quot;zhangshan&quot;, 20&lt;span&gt;, 180f));
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String getInfo(Person person) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &quot;name=&quot; + person.getName() + &quot;;age=&quot; + person.getAge() + &quot;;height=&quot; +&lt;span&gt; person.getHeight();
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; String name;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; age;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;float&lt;/span&gt;&lt;span&gt; height;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; Person(String name, &lt;span&gt;int&lt;/span&gt; age, &lt;span&gt;float&lt;/span&gt;&lt;span&gt; height) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.height =&lt;span&gt; height;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getName() {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; name;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getAge() {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; age;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;float&lt;/span&gt;&lt;span&gt; getHeight() {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; height;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    （7）Mehtod&lt;/p&gt;
&lt;p&gt;       作用：提取为方法&lt;/p&gt;
&lt;p&gt;       快捷键：Ctrl + Alt +M&lt;/p&gt;
&lt;p&gt;       重构前：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testExtractMethod() {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     List&amp;lt;String&amp;gt; nameList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     nameList.add(&quot;zhangshan&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     nameList.add(&quot;lisi&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     nameList.add(&quot;wangwu&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; size =&lt;span&gt; nameList.size();
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;鼠标光标选中第2~5行后执行该重构方法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201911/472002-20191106103314108-476454976.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;        重构后：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testExtractMethod() {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     List&amp;lt;String&amp;gt; nameList =&lt;span&gt; getNameList();
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; size =&lt;span&gt; nameList.size();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;@NonNull
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; List&amp;lt;String&amp;gt;&lt;span&gt; getNameList() {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     List&amp;lt;String&amp;gt; nameList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     nameList.add(&quot;zhangshan&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     nameList.add(&quot;lisi&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     nameList.add(&quot;wangwu&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; nameList;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    （8）Type Parameter&lt;/p&gt;
&lt;p&gt;    （9）Method Object&lt;/p&gt;
&lt;p&gt;       作用：将该选中的内容提取为一个方法，并提取到一个独立的类中。和“Method”很类似，不同的是提取的方法最后放在哪里。&lt;/p&gt;
&lt;p&gt;       重构前：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testExtractMethod() {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     List&amp;lt;String&amp;gt; nameList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     nameList.add(&quot;zhangshan&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     nameList.add(&quot;lisi&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     nameList.add(&quot;wangwu&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; size =&lt;span&gt; nameList.size();
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201911/472002-20191106105310948-1472625909.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;        重构后：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testExtractMethod() {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     List&amp;lt;String&amp;gt; nameList =&lt;span&gt; Utils.invoke();
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; size =&lt;span&gt; nameList.size();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Utils {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; List&amp;lt;String&amp;gt;&lt;span&gt; invoke() {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         List&amp;lt;String&amp;gt; nameList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         nameList.add(&quot;zhangshan&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         nameList.add(&quot;lisi&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         nameList.add(&quot;wangwu&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; nameList;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    （10）Delegate&lt;/p&gt;
&lt;p&gt;       作用：提取为一个代理类。&lt;/p&gt;
&lt;p&gt;       重构前：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RefactorTest{
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; 
&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testExtractInterface() {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         System.out.print(&quot;testExtractInterface&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201911/472002-20191106144905232-568936115.png&quot; alt=&quot;&quot; width=&quot;622&quot; height=&quot;432&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       重构后：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RefactorTestDelegate {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; RefactorTestDelegate() {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testExtractInterface() {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         System.out.print(&quot;testExtractInterface&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RefactorTest{
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; RefactorTestDelegate refactorTestDelegate = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RefactorTestDelegate();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testExtractInterface() {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        refactorTestDelegate.testExtractInterface();
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    （11）Interrface&lt;/p&gt;
&lt;p&gt;       作用：提取为接口。&lt;/p&gt;
&lt;p&gt;       重构前：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RefactorTest {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; 
&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testExtractInterface() {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         System.out.print(&quot;testExtractInterface&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;public修饰的方法才可以被提取到接口中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201911/472002-20191106141743358-328309130.png&quot; alt=&quot;&quot; width=&quot;503&quot; height=&quot;628&quot;/&gt;&lt;/p&gt;
&lt;p&gt;        重构后： &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IRefactorTest {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testExtractInterface();
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; RefactorTest &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; IRefactorTest {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testExtractInterface() {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         System.out.print(&quot;testExtractInterface&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    （12）Superclass&lt;/p&gt;
&lt;p&gt;       作用：将指定内容提取到父类中。&lt;/p&gt;
&lt;p&gt;       重构前：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testExtractSupperclass() {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;      testSuper();
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; 
&lt;span&gt;5&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testSuper() {
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;      System.out.print(&quot;testSuper&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201911/472002-20191106113800931-1714293965.png&quot; alt=&quot;&quot; width=&quot;552&quot; height=&quot;635&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       重构后：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;=======RefactorTest extends RefactorTestBase=======&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testExtractSupperclass() {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    testSuper();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RefactorTestBase {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testSuper() {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         System.out.print(&quot;testSuper&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;12、Inline&lt;/p&gt;
&lt;p&gt;       作用：转换为内联、方法链形式的调用。&lt;/p&gt;
&lt;p&gt;       快捷键：Ctrl + Alt +N&lt;/p&gt;
&lt;p&gt;       重构前：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testInline() {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; a = 100&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; b = 200&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;    System.out.print(add(a, b));
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; add(&lt;span&gt;int&lt;/span&gt; a, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; b) {
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;     System.out.print(&quot;a=&quot; + a + &quot;;b=&quot; +&lt;span&gt; b);
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; a*2 + b*3&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201911/472002-20191106162652835-978372556.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       重构后： &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testInline() {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; a = 100&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; b = 200&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     System.out.print(&quot;a=&quot; + a + &quot;;b=&quot; +&lt;span&gt; b);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     System.out.print(a * 2 + b * 3&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;原先需要调用一个方法，重构后直接把该方法中的代码给复制过来了。因为上面选中的是内联所有的，并且删除该方法，所以add方法也就被删除了。&lt;/p&gt;

&lt;p&gt;13、Find and Replace Code Duplicates&lt;/p&gt;

&lt;p&gt;14、Invert Boolean&lt;/p&gt;
&lt;p&gt;       作用：转换Boolean值，将当前false/true的值进行转化为相反的值。&lt;/p&gt;
&lt;p&gt;       重构前：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isEmpty(String str) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (str != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; str.length() == 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201911/472002-20191106164426667-1330324599.png&quot; alt=&quot;&quot; width=&quot;610&quot; height=&quot;139&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       重构后：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isNotEmpty(String str) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (str != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; str.length() == 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;15、Pull Members Up&lt;/p&gt;
&lt;p&gt;       作用：将子类的成员上移到父类中。&lt;/p&gt;
&lt;p&gt;       重构前：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RefactorBase {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; RafactorSub &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; RefactorBase {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; age = 10&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; printSub() {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        System.out.print(age);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201911/472002-20191106171652797-394616629.png&quot; alt=&quot;&quot; width=&quot;536&quot; height=&quot;447&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       重构后：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RefactorBase {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; age = 10&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; printSub() {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;        System.out.print(age);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; RafactorSub &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; RefactorBase {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;16、Push Members Down&lt;/p&gt;
&lt;p&gt;       作用：将父类中的成员下移到子类中，正好是“Pull Members Up”的反向操作。&lt;/p&gt;
&lt;p&gt;       重构前：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RefactorBase {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; age = 10&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; printSub() {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;        System.out.print(age);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;  
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; RafactorSub &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; RefactorBase {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;  
&lt;span&gt;10&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201911/472002-20191106172445533-435618905.png&quot; alt=&quot;&quot; width=&quot;554&quot; height=&quot;434&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       重构后：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RefactorBase {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; 
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; RafactorSub &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; RefactorBase {
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; age = 10&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; printSub() {
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;        System.out.print(age);
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;17、Use Interface Where Possible&lt;/p&gt;

&lt;p&gt;18、Replace Inheritance with Delegation&lt;/p&gt;
&lt;p&gt;       作用：使用代理替代继承。在java中，提倡使用组合，而不是继承。&lt;/p&gt;
&lt;p&gt;       重构前：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AbsClass {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; print();
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ClassWrapper &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; AbsClass {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; print() {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         System.out.print(&quot;print&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testReplaceInheritanceWithDelegation() {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ClassWrapper().print();
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201911/472002-20191106192816676-120234083.png&quot; alt=&quot;&quot; width=&quot;422&quot; height=&quot;484&quot;/&gt;&lt;/p&gt;
&lt;p&gt;        重构后：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AbsClass {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; print();
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ClassWrapper {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ClassImpl absClass = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ClassImpl();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; print() {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        absClass.print();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ClassImpl &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; AbsClass {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        @Override
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; print() {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             System.out.print(&quot;print&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RefactorTest {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testReplaceInheritanceWithDelegation() {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ClassWrapper().print();
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 这一部分有点像Android中Context，ContextWrapper，ContextImpl类之间的关系。&lt;/p&gt;

&lt;p&gt;19、Remove Middleman&lt;/p&gt;
&lt;p&gt;       作用：移除中间人，其实就是移除中间过程。&lt;/p&gt;
&lt;p&gt;       重构前：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RefactorTest {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testRemoveMiddleMan() {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         BookManager bookManager = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BookManager();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         bookManager.addBook(&quot;java&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BookManager {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; List&amp;lt;String&amp;gt; mBookList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; addBook(String bookName) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;            mBookList.add(bookName);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201911/472002-20191106195618774-1417930203.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       重构后：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RefactorTest {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testRemoveMiddleMan() {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         BookManager bookManager = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BookManager();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         bookManager.getmBookList().add(&quot;java&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BookManager {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; List&amp;lt;String&amp;gt; mBookList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; List&amp;lt;String&amp;gt;&lt;span&gt; getmBookList() {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; mBookList;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对比重构前和重构后会发现，添加book这个动作，从由BookManager的addBook方法来执行，变成了直接有mBookList来执行了。这个addBook就是这个MiddleMan，显得多余，可以优化掉。实际上优化后就变成一个inline方式了，可以对比前面讲到的“Inline”。&lt;/p&gt;

&lt;p&gt;20、Wrap Method Return Value&lt;/p&gt;
&lt;p&gt;       作用：封装返回值&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RefactorTest {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testWrapReturnValue() {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         String name =&lt;span&gt; getName();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String getName() {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &quot;zhangsan&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201911/472002-20191106193611397-2048092649.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       重构后：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RefactorTest {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testWrapReturnValue() {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         String name =&lt;span&gt; getName().getValue();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Person getName() {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Person(&quot;zhangsan&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; String value;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Person(String value) {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.value =&lt;span&gt; value;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getValue() {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; value;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;21、Convert Anonymous to Inner&lt;/p&gt;
&lt;p&gt;       作用：将匿名内部类转为内部类。&lt;/p&gt;
&lt;p&gt;       重构前：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testConvertAnonymousToInner(){
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     view.setOnClickListener(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; View.OnClickListener() {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;        @Override
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onClick(View v) {
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;    });
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201911/472002-20191106151659906-1031075311.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;        重构后：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RefactorTest{
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    View view;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testConvertAnonymousToInner(){
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         view.setOnClickListener(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; MyOnClickListener());
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MyOnClickListener &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; View.OnClickListener {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        @Override
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onClick(View v) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;22、Encapsulate Fields&lt;/p&gt;
&lt;p&gt;       作用：封装字段，用于生成Getter/Setter&lt;/p&gt;
&lt;p&gt;       重构前：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; String name = &quot;zhangsan&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testEncapsulateFields() {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;    System.out.println(name);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201911/472002-20191106161154148-1177677247.png&quot; alt=&quot;&quot; width=&quot;559&quot; height=&quot;483&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 通过该对话框，可以选择要封装的字段，设置修饰符等。默认选择时，name字段的修饰符从public变成了private，这也就避免了外部类通过实例直接访问它。&lt;/p&gt;
&lt;p&gt;       重构后：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; String name = &quot;zhangsan&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testEncapsulateFields() {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    System.out.println(getName());
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getName() {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; name;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setName(String name) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;23、Replace Temp With Query&lt;/p&gt;

&lt;p&gt;24、Replace Constructor with Factory Method&lt;/p&gt;
&lt;p&gt;       作用：将构造方法替换为工厂方法&lt;/p&gt;
&lt;p&gt;       重构前：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyClass {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String title;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String message;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String sure;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String cancel;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; MyClass(String title, String message, String sure, String cancel) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.title =&lt;span&gt; title;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.message =&lt;span&gt; message;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.sure =&lt;span&gt; sure;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.cancel =&lt;span&gt; cancel;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RefactorTest {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testReplaceConstructorWithFactory(Context context) {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         MyClass myClass = &lt;span&gt;new&lt;/span&gt; MyClass(&quot;title&quot;, &quot;message&quot;, &quot;sure&quot;, &quot;cancle&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201911/472002-20191106185748175-1688904170.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       重构后：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyClass {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String title;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String message;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String sure;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String cancel;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; MyClass(String title, String message, String sure, String cancel) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.title =&lt;span&gt; title;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.message =&lt;span&gt; message;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.sure =&lt;span&gt; sure;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.cancel =&lt;span&gt; cancel;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; MyClass createMyClass(String title, String message, String sure, String cancel) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MyClass(title, message, sure, cancel);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RefactorTest {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testReplaceConstructorWithFactory(Context context) {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         MyClass myClass = MyClass.createMyClass(&quot;title&quot;, &quot;message&quot;, &quot;sure&quot;, &quot;cancle&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;原先public修饰的构造函数，已经变成private了，MyClass类只能通过工厂方法来获取实例，而无法再直接new了。&lt;/p&gt;

&lt;p&gt;25、Replace Constructor with Builder&lt;/p&gt;
&lt;p&gt;       作用：将构造方法替换为Builder方式&lt;/p&gt;
&lt;p&gt;       重构前：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RefactorTest{
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testReplaceConstructorWithBuilder(Context context){
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         MyDialog dialog =  &lt;span&gt;new&lt;/span&gt; MyDialog(context,&quot;title&quot;,&quot;message&quot;,&quot;sure&quot;,&quot;cancle&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MyDialog &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Dialog {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String title;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String message;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String sure;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String cancel;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; MyDialog(@NonNull Context context) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;super&lt;/span&gt;&lt;span&gt;(context);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; MyDialog(Context context, String title, String message, String sure, String cancel) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;super&lt;/span&gt;&lt;span&gt;(context);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.title =&lt;span&gt; title;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.message =&lt;span&gt; message;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.sure =&lt;span&gt; sure;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.cancel =&lt;span&gt; cancel;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201911/472002-20191106184651118-442312397.png&quot; alt=&quot;&quot; width=&quot;708&quot; height=&quot;634&quot;/&gt;&lt;/p&gt;
&lt;p&gt;重构后：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RefactorTest {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testReplaceConstructorWithBuilder(Context context) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         MyDialog dialog = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MyDialogBuilder()
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;                .setContext(context)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;                 .setTitle(&quot;title&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;                 .setMessage(&quot;message&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                 .setSure(&quot;sure&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                 .setCancel(&quot;cancle&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;                .createMyDialog();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyDialogBuilder {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Context context;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String title;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String message;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String sure;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String cancel;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; MyDialogBuilder setContext(Context context) {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.context =&lt;span&gt; context;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; MyDialogBuilder setTitle(String title) {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.title =&lt;span&gt; title;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; MyDialogBuilder setMessage(String message) {
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.message =&lt;span&gt; message;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; 
&lt;span&gt;35&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; MyDialogBuilder setSure(String sure) {
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.sure =&lt;span&gt; sure;
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; 
&lt;span&gt;40&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; MyDialogBuilder setCancel(String cancel) {
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.cancel =&lt;span&gt; cancel;
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; 
&lt;span&gt;45&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; MyDialog createMyDialog() {
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MyDialog(context);
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;看到这里，我们应该能够联想到AlertDialog类中的Builder了。将构造函数的形式，转变为了建造者模式的形式，这样不会拘泥于构造函数的参数个数，参数类型的限制，从而灵活设置属性。 &lt;/p&gt;

&lt;p&gt;26、Generify&lt;/p&gt;
&lt;p&gt;       作用：泛型重构，自动添加泛型的参数。&lt;/p&gt;
&lt;p&gt;       重构前：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testGenerify() {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     List list = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ArrayList();
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     list.add(&quot;one&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     list.add(&quot;two&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     list.add(&quot;three&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201911/472002-20191106162114874-2022652776.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       重构后：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testGenerify() {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     List&amp;lt;String&amp;gt; list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;String&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     list.add(&quot;one&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     list.add(&quot;two&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     list.add(&quot;three&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;27、Migrate&lt;/p&gt;
&lt;p&gt;28、Internationalize（国际化）&lt;/p&gt;

&lt;p&gt;29、Remove Unused Resources&lt;/p&gt;
&lt;p&gt;       作用：一直不用的资源&lt;/p&gt;
&lt;p&gt;       示例：下图中1.jpg是一个没有被应用的文件。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201911/472002-20191106201415771-1487784239.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201911/472002-20191106201455559-694085221.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在执行该重构方法后，1.jpg就被删除了。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201911/472002-20191106201511839-188625785.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;参考：&lt;a href=&quot;https://www.jianshu.com/p/f8cb51bc8e19&quot;&gt;https://www.jianshu.com/p/f8cb51bc8e19&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 06 Nov 2019 16:52:00 +0000</pubDate>
<dc:creator>宋者为王</dc:creator>
<og:description>代码重构几乎是每个程序员在软件开发中必须要不断去做的事情，以此来不断提高代码的质量。Android Stido（以下简称AS）以其强大的功能，成为当下Android开发工程师最受欢迎的开发工具，也是A</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/andy-songwei/p/11809700.html</dc:identifier>
</item>
</channel>
</rss>