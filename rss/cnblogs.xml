<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>JDK1.8-Java虚拟机运行时数据区域和HotSpot虚拟机的内存模型 - 炭烧生蚝</title>
<link>http://www.cnblogs.com/tanshaoshenghao/p/10721256.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tanshaoshenghao/p/10721256.html</guid>
<description>&lt;ul&gt;&lt;li&gt;初学Java虚拟机几天, 被方法区, 永久代这些混杂的概念搞混了. 我觉得学习这部分知识应该把官方定义的虚拟机运行时数据区域和虚拟机内存结构分开叙述, 要不然容易误导.&lt;/li&gt;
&lt;li&gt;本文先介绍官方文档规定的运行时数据区域, 然后以JDK1.8的HotSpot虚拟机为例, 介绍虚拟机的内存结构.&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;&lt;li&gt;官方文档中规定的运行时数据区一共就几块: PC计数器, 虚拟机栈, 本地方法栈, 堆区, 方法区, 运行时常量池. 这里的官方规定是说, 如果你要做一个Java虚拟机的话, 必须要包含这几个区域, 但是这几个区域在你的虚拟机中是用哪块内存实现的, 这由虚拟机制作者决定.&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;程序计数器&quot;&gt;程序计数器&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;The pc Register, 程序计数器. 如果了解过计算机系统, 对这个名词应该不陌生了, 它指向下一条指令的地址, 程序靠它跑起来.&lt;/li&gt;
&lt;li&gt;Java虚拟机支持多线程, 每条线程都有自己的程序计数器.&lt;/li&gt;
&lt;li&gt;如果当前线程正在执行一个Java方法, 它的计数器记录的是正在执行的Java虚拟机指令的地址. 如果执行的是本地方法(比如系统的C语言函数), 计数器中的值为空(Undefined).&lt;/li&gt;
&lt;li&gt;正因为程序计数器记录的是指令地址, 所以它占用的空间较少, Java虚拟机规范中并没有规定这块内存有OutOfMemoryError(内存溢出)的情况.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;java虚拟机栈&quot;&gt;Java虚拟机栈&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;Java Virtual Machine Stacks, Java虚拟机栈.&lt;/li&gt;
&lt;li&gt;Java虚拟机栈是线程私有的, 生命周期与线程相同. 虚拟机栈存放栈帧, 栈帧用于存储局部变量表, 部分结果值, 方法的初始化参数和返回信息, 方法的执行通过栈帧的压栈和出栈实现.&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;本地方法栈&quot;&gt;本地方法栈&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;本地方法栈和上面的虚拟机栈是相似的, 从名字也看出, 虚拟机方法栈是用来执行Java代码的, 而本地方法栈则是用来执行本地系统代码的, 比如C代码.&lt;/li&gt;
&lt;li&gt;也因为规范中没有规定本地方法栈执行的代码, 如果想执行Java代码也是可以的, 我们可以看到Oracle官方的虚拟机HotSpot虚拟机把Java虚拟机栈和本地方法栈合二为一, 这么做避免了要为不同的语言设计栈, 提高了虚拟机的性能.&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;虚拟机栈和本地方法栈溢出&quot;&gt;虚拟机栈和本地方法栈溢出&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;那么当出现错误信息后, 我们在什么错误信息下可以去排查是否虚拟机栈和本地方法栈这两块内存出错呢? 这里以HotSpot虚拟机为例讲解(HotSpot把两块栈结构合在一起实现了), 在JDK1.8的虚拟机规范中对这两块栈空间可能出现的错误给出了相同的描述.&lt;/li&gt;
&lt;li&gt;一: 如果一条线程所需要的内存大于虚拟机所分配给它的内存, 将抛出&lt;code&gt;StackOverflowError&lt;/code&gt;异常.&lt;/li&gt;
&lt;li&gt;二: 如果栈内存可以扩展并尝试扩展时可用的内存不足, 或者创建新线程并为其分配栈内存时可能的内存不足, 会抛出&lt;code&gt;OutOfMemoryError&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;下面先演示第一个&lt;code&gt;StackOverflowError&lt;/code&gt;异常&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//设置虚拟机参数 -Xss128k, 设置单个线程的栈空间大小为128k
public class StackErrorTest1 {
    private int stackLength = 1;

    public void stackLeak(){
         stackLength++;
         stackLeak();
    }

    public static void main(String[] args) {
        StackErrorTest1 set1 = new StackErrorTest1();
        try{
            set1.stackLeak();
        }catch (Throwable e){
            System.out.println(&quot;stack length:&quot; + set1.stackLength);
            e.printStackTrace();
        }
    }
}
//输出异常信息
stack length:1000
java.lang.StackOverflowError
    at jvm.StackErrorTest1.stackLeak(StackErrorTest1.java:7)
    at jvm.StackErrorTest1.stackLeak(StackErrorTest1.java:8)
    ...&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;所以当遇到&lt;code&gt;StackOverflowError&lt;/code&gt;时可以考虑是否是是虚拟机的栈容量太小, 比如这里的无穷递归, 栈空间不够用. 当然生产环境中肯定不会写无穷递归, 这时可以通过设置-Xss参数调整单条线程的栈内存大小.&lt;/li&gt;
&lt;li&gt;上面描述的栈内存可以扩展并尝试扩展时可用的内存不足导致出现&lt;code&gt;OutOfMemoryError&lt;/code&gt;的情况暂时没有好的演示代码, 在周志明的《深入理解Java虚拟机》中提到&quot;定义了大量本地变量,增大方法帧中本地变量表的长度, 结果仍抛出&lt;code&gt;StackOverflowError&lt;/code&gt;&quot;. 不知道是不是没有触发虚拟机动态扩充栈空间, 所以仍然判定是栈所需的空间超出了虚拟机规定的大小. 总结来说无论是栈帧太大还是栈空间太小都会抛出&lt;code&gt;StackOverflowError&lt;/code&gt;, 可以考虑调整-Xss参数.&lt;/li&gt;
&lt;li&gt;上面还提到当创建新线程并分配新的栈空间时, 如果可用的内存不够, 会抛出&lt;code&gt;OutOfMemoryError&lt;/code&gt;异常, 下面是这种情况的代码演示.&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class StackErrorTest2 {

    private void keepRunning(){
        while(true){
        }
    }

    public void stackLeakByThread(){
        while(true){
            Thread thread = new Thread(new Runnable() {
                @Override
                public void run() {
                    keepRunning();
                }
            });
            thread.start();
        }
    }

    public static void main(String[] args){
        StackErrorTest2 set2 = new StackErrorTest2();
        set2.stackLeakByThread();
    }
}
//运行结果, 来源《深入理解Java虚拟机》
Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: unable to create new native thread&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;这段代码也来自深入理解jvm, 书中也说明跑这段代码要小心, 因为Java的线程是映射到内核线程上的, 果不其然我的机子一跑就死机了.&lt;/li&gt;
&lt;li&gt;问什么会出现这样的错误? 32位Windows系统分配给一个进程的内存最大为2GB(32位能寻址4GB地址空间, 除去内核的空间剩2GB, 64位则大得多). 这2GB减去最大堆容量, 减去方法区的容量, 剩下的就是虚拟机栈和本地方法区栈的内存空间了. (补充: PC计数器占的空间很小, 运行时常量池在方法区中, HotSpot中虚拟机栈和本地方法栈一起实现, 所以能分成这么三大块内存).&lt;/li&gt;
&lt;li&gt;了解了三大块内存区后(HotSpot下), 解决思路也出来了: 1. 减小最大堆内存, 腾出更多位置给栈空间. 2. 如果程序的线程数量不可以减少, 那么就看看是否可以减少每条线程的栈内存.&lt;/li&gt;
&lt;li&gt;当然用一台配置高的机器, 该用64位的Java虚拟机也是一种方法.&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;java堆&quot;&gt;Java堆&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;Java堆是随着虚拟机的启动而创建的, 用于存放对象实例, 所有的对象实例和数组都在堆内存分配, 它被所有线程共享. Java堆是Java虚拟机管理的内存中最大的一块, 也是垃圾回收器管理的主要区域. 从内存回收的角度看, Java堆内存还可以被继续划分, 并且和具体的虚拟机实现有关.&lt;/li&gt;
&lt;li&gt;当前主流的虚拟机都是支持堆内存动态扩展的, 就是说当堆内存的大不够时, 它会扩充容量; 当不要太多的空间时, 它能自己进行压缩. 我们可以人为地通过-Xmx和-Xms设定堆内存的最大值和最小值(初始大小). 如果我们把-Xmx和-Xms设置为相同的值, 就等同于设定了固定大小的Java堆. (这是gc调优的一种手段)&lt;/li&gt;
&lt;li&gt;若堆内存分配内存时发现已经没有更过可用空间时, 会抛出&lt;code&gt;OutOfMemoryError&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;演示堆内存溢出&quot;&gt;演示堆内存溢出&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;堆内存是存放对象实例的地方, 这个应该比较好理解, 直接上代码&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * VM Args: -Xms20m -Xmx20m
 */
public class HeapErrorTest {
    static class Object{
    }

    public static void main(String[] args) {
        List&amp;lt;Object&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
        while(true){
            list.add(new Object());
        }
    }
}
//运行结果
Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space
    at java.util.Arrays.copyOf(Arrays.java:3210)
    at java.util.Arrays.copyOf(Arrays.java:3181)&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;由结果可以看到当堆内存溢出后除了有&lt;code&gt;java.lang.OutOfMemoryError&lt;/code&gt;外, 还会提示&lt;code&gt;Java heap space&lt;/code&gt;. 在这个例子中, 我们明确地知道了是由于堆内存不够大而造成的溢出. 然而在生产环境中, 当系统报出堆内存溢出时, 我们首先要搞清楚是因为内存泄漏导致的内存溢出, 还是纯粹的内存溢出.&lt;/li&gt;
&lt;li&gt;内存溢出指的是分配内存的时候, 没有足够的空间供其使用. 内存泄漏指的是在分配一块内存使用完后没有释放, 在Java中对应的场景是没有被垃圾回收器回收. 一点点的内存泄漏用户可能感受不到, 但是当泄漏的内存积少成多的时候, 会耗尽内存, 导致内存溢出.&lt;/li&gt;
&lt;li&gt;有一些常用的分析内存溢出的手段和工具, 这里就不详细叙述了, 可以参考书籍或网上的资料. 当我们判断是内存泄漏导致的溢出后, 可以根据工具定位出现泄漏的代码位置; 如果不存在泄漏只是单纯的溢出的话, 可以通过设置虚拟参数调整堆内存大小(前提是机器的配置能够支持相应的内存大小), 或者看看代码中是否存在一些生命周期很长的对象实例, 看看能否作出修改.&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;方法区&quot;&gt;方法区&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;方法区用于存储以被虚拟机加载的类信息, 常量, 静态变量, 即时编译器编译后的代码数据等, 它是所有线程共享的. 虚拟机规范中说方法区在逻辑上是堆的一部分, 但是它的别名叫&quot;non-Heap&quot;也就是非堆的意思, 表明它和堆内存是两块独立的内存. 至于说在逻辑上是堆区的一部分, 是因为在物理实现上, 方法区的内存地址包含于堆中, 所以说是逻辑上的一部分, 实际用的时候是完全不同的部分. 这么设计可能是因为便于垃圾收集器统一管理吧.&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;运行时常量池&quot;&gt;运行时常量池&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;运行时常量池的内存由方法区分配, 也就是说它属于方法区的一部分. 它用于存储Class文件中的类版本, 字段, 方法, 接口和常量池等, 也用于存放编译期生成的各种字面量和符号引用.&lt;/li&gt;
&lt;li&gt;运行时常量池区别于Class文件常量池的一个重要特征是具备动态特性. 也就说并非在Class文件中定义的常量才能进入运行时常量池, 在程序运行的过程中也有可能将新的常量放入池中.&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;演示方法区溢出&quot;&gt;演示方法区溢出&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;演示方法区溢出和堆区的思路一样, 不断往方法堆中加入东西使其溢出. 只是方法区中保存的是类信息, 我们通过不断动态生成类演示&lt;/li&gt;
&lt;li&gt;本代码示例来源于深入理解jvm, 但是其中的参数需要改变, 该书的最新版本是基于JDK1.7的, JDK1.7中方法区是在永久代中实现的, 而JDK1.8中已经没有永久代了, 方法区中Metaspace元数据区中, 通过设置&lt;code&gt;-XX:MetaspaceSize&lt;/code&gt;和&lt;code&gt;-XX:MaxMetaspaceSize&lt;/code&gt;来指定方法区的大小&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;/**
 * VM Args: -XX:MetaspaceSize=10m -XX:MaxMetaspaceSize=10m
 */
public class MethodAreaTest {

    static class Object{
    }

    public static void main(String[] args) {
        int count = 0;
        while (true) {
            Enhancer enhancer = new Enhancer();
            enhancer.setSuperclass(Object.class);
            enhancer.setUseCache(false);
            enhancer.setCallback(new MethodInterceptor() {
                @Override
                public java.lang.Object intercept(java.lang.Object o, Method method, java.lang.Object[] objects, MethodProxy methodProxy) throws Throwable {
                    return methodProxy.invokeSuper(objects, objects);
                }
            });
            enhancer.create();
            System.out.println(++count);
        }
    }
}

运行结果:
Caused by: java.lang.OutOfMemoryError: Metaspace
    at java.lang.ClassLoader.defineClass1(Native Method)
    at java.lang.ClassLoader.defineClass(ClassLoader.java:763)
    ... 8 more&lt;/code&gt;
&lt;/pre&gt;


&lt;ul&gt;&lt;li&gt;在介绍完Java虚拟机运行时数据区域后, 接着以HotSpot虚拟机为例介绍虚拟机内存模型.&lt;/li&gt;
&lt;li&gt;首先有一个&lt;strong&gt;重要的概念&lt;/strong&gt;要搞清楚, 要不然容易犯晕.&lt;/li&gt;
&lt;li&gt;在前面介绍Java运行时数据区域时我们谈到PC计数器, 虚拟机栈, 本地方法栈这3块内存都是线程私有的, 它们的随线程的创建而分配, 随线程的结束而释放, 也就是说Java虚拟机是明确知道这三块内存是什么时候该被回收的, 只要线程没执行完就不能回收, 否则线程跑不起来.&lt;/li&gt;
&lt;li&gt;而我们在谈论虚拟机的内存模型时, 通常要和垃圾回收结合在一起讨论. 既然上面的三块内存回收的时间已定, 暂时不需要过多考虑, 虚拟机分配内存时给它们留有空间就行.&lt;/li&gt;
&lt;li&gt;但另外的两块内存堆内存和方法区则不一样, 它们是所有线程共享的, 在这里面内存的分配和释放具有不确定性. 比如说在多态的情况下, 一个接口对应的实现类不同, 具体的实现方法也不同, 虚拟机只有在程序运行的过程中才知道要创建哪些对象, 这部分内存的分配和释放都是动态的, 垃圾收集器关注的也是这部分的内容.&lt;/li&gt;
&lt;li&gt;所以说我们后续描述的虚拟机内存模型是建立在Java堆内存和方法区上的.&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;jvm实现的堆内存和方法区&quot;&gt;JVM实现的堆内存和方法区&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;正如上述所说, 当谈论JVM的内存结构时, 讨论的重点就由整个运行时数据区域转为对堆内存和方法区的讨论, 因为这两部分是垃圾回收的重点区域(如果两者要比较的话, 重点收集区域是堆区).&lt;/li&gt;
&lt;li&gt;而HotSpot虚拟机的内存结构由三大部分组成: 新生代, 老年代和元数据区(JDK1.7及以前叫老年代). 其中新生代和老年代是虚拟机规范中Java堆内存的实现, 元数据区是规范中方法区的实现. 在讲述为什么这么定义之前, 先明确这个关系对于理解概念是很重要的, 下面有幅图帮助理解.&lt;/li&gt;
&lt;/ul&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/tanshaoshenghao/1426602/o_jvm3.png&quot;/&gt;&lt;ul&gt;&lt;li&gt;这里有个小失误, 题目中明明讲的是JDK1.8, 为什么还提永久代呢? 由于永久代存在的时间长, 永久代的说法经过这么多年可能已经深入人心, 所以先并列讲, 要知道永久代和元数据区是有本质的差别的, 这留到后面讲, 先认清概念.&lt;/li&gt;
&lt;li&gt;希望图片加描述能够帮助你立即规范定义的数据区域和JVM内存结构之间的关系. 下面将对HotSpot虚拟机的内存模型做进一步分析.&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;新生代和老年代.&quot;&gt;新生代和老年代.&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;Java堆内存被实现为新生代和老年代, 是为了更方便地进行垃圾回收. 我们知道对象是存储在堆内存中的, 从字面上理解新生代就是新创建的对象区域, 老年代就是使用多次生命周期长的对象区域. 新生代对象生命周期通常较短, 很多用完即可以释放; 老年代对象的生命周期较长, 可能在整个程序的运行过程中都是有用的.&lt;/li&gt;
&lt;li&gt;由于新对象和老对象具有不同的性质, 为对这两种对象设计的垃圾回收算法也不同, 所以要把它们分开.&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;新生代中的内存划分&quot;&gt;新生代中的内存划分&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;新生代的内存被分为一个Eden区和两个Survivor区. 为了讲述为什么要这么分, 需简单引入垃圾回收算法.&lt;/li&gt;
&lt;li&gt;首先最基础, 最简单的垃圾回收算法叫标记-清除算法. 算法流程和算法名完全一致: 首先标记出哪些是可以回收的对象, 标记完后把对象清除. 如果按照这么个流程, 新生代应该就是一块简单的内存就行, 现实结论告诉我们这个算法是可以优化的.&lt;/li&gt;
&lt;li&gt;标记清除算法的不足在于一块完整的内存在经过标记-清除算法后有些内存会被释放掉, 这时会造成内存空间不连续, 可能不能够存放一些较大的对象.&lt;/li&gt;
&lt;li&gt;标记-清除算法的升级版是复制算法, 它在标记-清除的思路上作出了些改变. 首先将内存分为两块, 当创建新对象分配内存的时候只用两块中的一块A. 当进行垃圾回收的时候只对有对象的一块A内存使用标记-清除算法进行回收, 回收后剩余的存活对象从内存A移到另一块空的内存B中, 这样A内存重新变为空内存, 继续重复此分配回收过程. 这个算法似乎更好一些, 但是也只是两块内存, 说明还不是现实中的最优解.&lt;/li&gt;
&lt;li&gt;考虑新的算法, 把内存分配成均等两块, 等同于能够使用的内存变为原来的二分之一了, 根据IBM专门部分研究新生代中百分之98%的对象都是&quot;朝生夕死&quot;的, 也就是说在进行垃圾回收时98%的对象都被回收掉, 只有2%会从A内存移动到B内存. 这么一想我们把两块内存割为相同的两块是不是有点太亏了?&lt;/li&gt;
&lt;li&gt;下面揭晓答案: HotSpot虚拟机回收虚拟机时使用的是复制算法, 但是它分成三块内存, 一个占80%内存的Eden区(堆内存), 两个分别占10%的Survivor区. 具体操作是这样的: 程序运行时, 用Eden区和一个Survivor区A存放新创建的对象. 当发生垃圾回收时, 把存活下来的对象(很少)复制到另一块Survivor区B中, 使得Eden区和Survivor区A重新为空, 然后继续重复这个分配回收的过程.&lt;/li&gt;
&lt;li&gt;所以说详细点的Jvm的内存模型是下面这样的&lt;/li&gt;
&lt;/ul&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/tanshaoshenghao/1426602/o_jvm4.png&quot;/&gt;&lt;h2 id=&quot;由jdk1.7及以前的永久代到jdk1.8的元数据区&quot;&gt;由JDK1.7及以前的永久代到JDK1.8的元数据区&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;搞定完堆区在JVM内存模型中的实现, 下面谈论方法区的实现.&lt;/li&gt;
&lt;li&gt;在JDK1.7及以前, JVM使用永久代来实现方法区. 这里用&quot;实现&quot;二字是经过斟酌的, 因为永久代并不等同于方法区. 从名字也可以看出它和新生代, 老年代是一脉相承的, 逻辑上是一体的, 命名为永久代是因为这部分内存很少几乎不被回收. 这一很少几乎不被回收的特性正好对应方法区中存储的类信息, 常量, 静态变量等元素. 所以说用永久代来实现方法区.&lt;/li&gt;
&lt;li&gt;但是用永久代来实现方法区并不是最优解, 比如容易出现内存溢出问题(具体分析去除永久代, 改用Metaspace的原因可以参考文章末尾所列出的资料). 在JDK1.8中JVM改为使用元数据区来实现方法区.&lt;/li&gt;
&lt;li&gt;元数据区和永久代有着本质的区别, 永久代属于虚拟机内存的一部分, 也就是说当在操作系统中启动虚拟机进程时为它分配了一块内存, 而虚拟机为永久代分配内存时用的是它自己分配得的内存.&lt;/li&gt;
&lt;li&gt;而元数据区Metaspace是直接在本地内存(Native Memory)中申请的, 这样元数据区的大小(方法区大小)只会受本地内存大小限制, 和虚拟机进程所分得内存无关.&lt;/li&gt;
&lt;li&gt;所以最后JVM内存模型图的终极版应该是这样子&lt;/li&gt;
&lt;/ul&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/tanshaoshenghao/1426602/o_jvm.png&quot;/&gt;&lt;ul&gt;&lt;li&gt;到此为止, 本篇结束, 希望对你有帮助.&lt;/li&gt;
&lt;/ul&gt;
</description>
<pubDate>Tue, 16 Apr 2019 23:42:00 +0000</pubDate>
<dc:creator>炭烧生蚝</dc:creator>
<og:description>[TOC] 介绍 初学Java虚拟机几天, 被方法区, 永久代这些混杂的概念搞混了. 我觉得学习这部分知识应该把官方定义的虚拟机运行时数据区域和虚拟机内存结构分开叙述, 要不然容易误导. 本文先介绍官</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tanshaoshenghao/p/10721256.html</dc:identifier>
</item>
<item>
<title>TiDB show processlist命令源码分析 - mantu</title>
<link>http://www.cnblogs.com/mantu/p/10721122.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mantu/p/10721122.html</guid>
<description>&lt;p data-source-line=&quot;2&quot;&gt;因为丰巢自去年年底开始在推送平台上尝试了TiDB，最近又要将承接丰巢所有交易的支付平台切到TiDB上。我本人一直没有抽出时间对TiDB的源码进行学习，最近准备开始一系列的学习和分享。由于我本人没有数据库相关的经验，本着学习的心态和大家一起探讨，欢迎高手随时指正。总结一下本次学习分享的目的：&lt;/p&gt;
&lt;ul data-source-line=&quot;3&quot;&gt;&lt;li&gt;丰巢把最重要的两个基础业务都放到了TiDB上，后续应该会有更多的核心系统跑在TiDB上，我们丰巢中间件团队作为引入TiDB到丰巢的推动人和执行者，对于TiDB的稳定性和突发事件的处理，一定要做足功课；&lt;/li&gt;
&lt;li&gt;以TiDB为代表的newsql代表的是现在和未来，作为个人来说，有着充足的动力去学习；&lt;/li&gt;
&lt;li&gt;我们不满足于只是作为TiDB的使用者，我们需要在TiDB上定制开发对于丰巢更有意义的模块，如果能给社区做贡献，那更是非常棒的一件事；&lt;/li&gt;
&lt;/ul&gt;&lt;p data-source-line=&quot;7&quot;&gt;言归正传，说一下本文的产生原因：去年我们在推送平台上使用TiDB的过程中，就发现老版本的TiDB是无法通过外部手段kill调用慢查询的，而慢查询的危害对于数据库来说会有致命的风险，后来pingcap公司在2.1版本(具体的版本参见TiDB的说明)中增加了show processlist和kill tidb命令，但是因为TiDB本身是无状态的，这两个命令属于单机命令，在使用的过程中，大家还是要提前做好准备，要直连到具体的TiDB的server上才可使用，不要通过nginx等服务进行转发请求，到时不但不能解决问题，还有可能带来意外的风险。今天第一章，我们先来看一下show processlist这个比较简单的命令的源码，下一章，我们再分析kill tidb这个命令。&lt;/p&gt;

&lt;h2 id=&quot;环境信息&quot; data-source-line=&quot;9&quot;&gt;环境信息&lt;/h2&gt;
&lt;ul data-source-line=&quot;10&quot;&gt;&lt;li&gt;软件：TiDB2.1.7、PD2.1.4、TiKV2.1.4；&lt;/li&gt;
&lt;li&gt;硬件：为了随时调试，TiDB跑在本机的mac上、PD和TiKV跑在linux虚拟机上；&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;操作过程&quot; data-source-line=&quot;12&quot;&gt;操作过程&lt;/h2&gt;
&lt;ul data-source-line=&quot;13&quot;&gt;&lt;li&gt;打开一个直连TiDB的客户端，输入命令：show PROCESSLIST；&lt;/li&gt;
&lt;li&gt;客户端会输出下图的列表；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1003073/201904/1003073-20190417003547932-2079178319.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p data-source-line=&quot;16&quot;&gt;上面的列表中展示了当前TiDB正在处理每个连接的sql语句详情。&lt;/p&gt;
&lt;h2 id=&quot;问题&quot; data-source-line=&quot;17&quot;&gt;问题&lt;/h2&gt;
&lt;p data-source-line=&quot;18&quot;&gt;在我分析源码之前，我问了自己本次分析源码要搞清楚的两个问题，在这里和大家分享一下：&lt;/p&gt;
&lt;ul data-source-line=&quot;19&quot;&gt;&lt;li&gt;show processlist到底是不是单机的命令，和TiKV、PD有没有啥关系？&lt;/li&gt;
&lt;li&gt;kill tidb需要使用的id字段到底代表的是什么？&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;接收命令&quot; data-source-line=&quot;21&quot;&gt;接收命令&lt;/h2&gt;
&lt;p data-source-line=&quot;22&quot;&gt;首先，启动TiDB server.代码在tidb-server/main.go里面，主要方法是：runServer方法&lt;/p&gt;
&lt;pre data-source-line=&quot;23&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;func &lt;span class=&quot;hljs-selector-tag&quot;&gt;runServer() {
        &lt;span class=&quot;hljs-attribute&quot;&gt;err := svr.&lt;span class=&quot;hljs-built_in&quot;&gt;Run()
}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-source-line=&quot;28&quot;&gt;再来看一下：server/server.go源码：&lt;/p&gt;
&lt;pre data-source-line=&quot;29&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func &lt;span class=&quot;hljs-params&quot;&gt;(s *Server) &lt;span class=&quot;hljs-title&quot;&gt;Run&lt;span class=&quot;hljs-params&quot;&gt;() &lt;span class=&quot;hljs-title&quot;&gt;error {
        &lt;span class=&quot;hljs-keyword&quot;&gt;for {
                conn, err := s.listener.Accept()
                &lt;span class=&quot;hljs-keyword&quot;&gt;go s.onConn(conn)
        }
}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-source-line=&quot;37&quot;&gt;重点代码是监听端口，并创建连接，启动另一协程去服务新来的连接，接下来再看看server.go中的onConn方法：&lt;/p&gt;
&lt;pre data-source-line=&quot;38&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;func (&lt;span class=&quot;hljs-selector-tag&quot;&gt;s *&lt;span class=&quot;hljs-selector-tag&quot;&gt;Server) &lt;span class=&quot;hljs-selector-tag&quot;&gt;onConn(&lt;span class=&quot;hljs-selector-tag&quot;&gt;c &lt;span class=&quot;hljs-selector-tag&quot;&gt;net&lt;span class=&quot;hljs-selector-class&quot;&gt;.Conn) {
        &lt;span class=&quot;hljs-attribute&quot;&gt;conn := s.&lt;span class=&quot;hljs-built_in&quot;&gt;newConn(c)
        conn.&lt;span class=&quot;hljs-built_in&quot;&gt;Run()
}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-source-line=&quot;44&quot;&gt;其中，s.newConn方法会将net. Conn连接包装成clientConn连接，并分配在这个TiDB server下唯一的connectionID，此connectionID为原子变量，每次新连接自增加1，我们先记住这个id，后面分析的时候会用到它。我们来看看server/conn.go下的Run方法：&lt;/p&gt;
&lt;pre data-source-line=&quot;46&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func &lt;span class=&quot;hljs-params&quot;&gt;(cc *clientConn) &lt;span class=&quot;hljs-title&quot;&gt;Run&lt;span class=&quot;hljs-params&quot;&gt;() {
        &lt;span class=&quot;hljs-keyword&quot;&gt;for {
                data, err := cc.readPacket()
                cc.dispatch(data) 
        }
}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-source-line=&quot;54&quot;&gt;Run方法主要就是不断的轮训读取clientConn中的内容，并将它交给dispatch方法进行下面的分析及返回结果操作，至此关于接收show processlist命令部分已经分析完毕，当然其它的sql语句也是经过这个过程进入到dispatch方法中的。&lt;/p&gt;
&lt;h2 id=&quot;show-processlist的构建executor&quot; data-source-line=&quot;55&quot;&gt;show processlist的构建Executor&lt;/h2&gt;
&lt;p data-source-line=&quot;56&quot;&gt;接着分析dispatch方法在处理show processlist命令的流程：&lt;/p&gt;
&lt;pre data-source-line=&quot;57&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func &lt;span class=&quot;hljs-params&quot;&gt;(cc *clientConn) &lt;span class=&quot;hljs-title&quot;&gt;dispatch&lt;span class=&quot;hljs-params&quot;&gt;(data []byte) &lt;span class=&quot;hljs-title&quot;&gt;error {
        &lt;span class=&quot;hljs-keyword&quot;&gt;switch cmd {
        &lt;span class=&quot;hljs-keyword&quot;&gt;case mysql.ComQuery: 
                &lt;span class=&quot;hljs-keyword&quot;&gt;return cc.handleQuery(ctx1, hack.&lt;span class=&quot;hljs-built_in&quot;&gt;String(data))
        }
}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-source-line=&quot;65&quot;&gt;show processlist命令属于mysql.ComQuery，因此流程会走到handleQuery方法里面，我们来看一下：&lt;/p&gt;
&lt;pre data-source-line=&quot;66&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func &lt;span class=&quot;hljs-params&quot;&gt;(cc *clientConn) &lt;span class=&quot;hljs-title&quot;&gt;handleQuery&lt;span class=&quot;hljs-params&quot;&gt;(ctx context.Context, sql &lt;span class=&quot;hljs-keyword&quot;&gt;string) &lt;span class=&quot;hljs-params&quot;&gt;(err error) {
        rs, err := cc.ctx.Execute(ctx, sql)
        err = cc.writeResultset(ctx, rs[&lt;span class=&quot;hljs-number&quot;&gt;0], &lt;span class=&quot;hljs-literal&quot;&gt;false, &lt;span class=&quot;hljs-number&quot;&gt;0, &lt;span class=&quot;hljs-number&quot;&gt;0)
}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-source-line=&quot;72&quot;&gt;handleQuery中处理show processlist命令的重点代码就是上面的两行，我们先来看一下server/driver_tidb.go中的Execute方法：&lt;/p&gt;
&lt;pre data-source-line=&quot;73&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;rsList, err := tc&lt;span class=&quot;hljs-selector-class&quot;&gt;.session&lt;span class=&quot;hljs-selector-class&quot;&gt;.Execute(ctx, sql)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-source-line=&quot;76&quot;&gt;Execute中的重点就是调用session/session.go中的Execute方法：&lt;/p&gt;
&lt;pre data-source-line=&quot;77&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func &lt;span class=&quot;hljs-params&quot;&gt;(s *session) &lt;span class=&quot;hljs-title&quot;&gt;execute&lt;span class=&quot;hljs-params&quot;&gt;(ctx context.Context, sql &lt;span class=&quot;hljs-keyword&quot;&gt;string) &lt;span class=&quot;hljs-params&quot;&gt;(recordSets []sqlexec.RecordSet, err error) {
        s.PrepareTxnCtx(ctx)
        stmtNodes, warns, err := s.ParseSQL(ctx, sql, charsetInfo, collation)
        compiler := executor.Compiler{Ctx: s}
        &lt;span class=&quot;hljs-keyword&quot;&gt;for _, stmtNode := &lt;span class=&quot;hljs-keyword&quot;&gt;range stmtNodes {
                recordSets, err = s.executeStatement(ctx, connID, stmtNode, stmt, recordSets); 
        }
}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-source-line=&quot;87&quot;&gt;上面的execute方法中会对sql语句进行处理及制定执行计划，处理完成后调用executeStatement方法，executeStatement中的重点方法是runStmt：&lt;/p&gt;
&lt;pre data-source-line=&quot;88&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-symbol&quot;&gt;recordSet, err := runStmt(ctx, s, &lt;span class=&quot;hljs-keyword&quot;&gt;stmt)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-source-line=&quot;91&quot;&gt;我们再来看看session/tidb.go中的runStmt方法：&lt;/p&gt;
&lt;pre data-source-line=&quot;92&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;func runStmt(ctx context&lt;span class=&quot;hljs-selector-class&quot;&gt;.Context, sctx sessionctx&lt;span class=&quot;hljs-selector-class&quot;&gt;.Context, s sqlexec.Statement) (sqlexec&lt;span class=&quot;hljs-selector-class&quot;&gt;.RecordSet, error) {
        rs, err = s.Exec(ctx)
        err = finishStmt(ctx, sctx, se, sessVars, err)
}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-source-line=&quot;98&quot;&gt;继续来分析executor/adapter中的(a *ExecStmt) Exec方法，一样采取划重点的方式：&lt;/p&gt;
&lt;pre data-source-line=&quot;99&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func &lt;span class=&quot;hljs-params&quot;&gt;(a *ExecStmt) &lt;span class=&quot;hljs-title&quot;&gt;Exec&lt;span class=&quot;hljs-params&quot;&gt;(ctx context.Context) &lt;span class=&quot;hljs-params&quot;&gt;(sqlexec.RecordSet, error) {
    e, err := a.buildExecutor(sctx)
    e.Open(ctx)
        &lt;span class=&quot;hljs-keyword&quot;&gt;var pi processinfoSetter
        &lt;span class=&quot;hljs-keyword&quot;&gt;if raw, ok := sctx.(processinfoSetter); ok {
                pi = raw
                sql := a.OriginText()
                &lt;span class=&quot;hljs-keyword&quot;&gt;if simple, ok := a.Plan.(*plannercore.Simple); ok &amp;amp;&amp;amp; simple.Statement != &lt;span class=&quot;hljs-literal&quot;&gt;nil {
                        &lt;span class=&quot;hljs-keyword&quot;&gt;if ss, ok := simple.Statement.(ast.SensitiveStmtNode); ok {
                                &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-source-line=&quot;127&quot;&gt;(a *ExecStmt) Exec方法中raw, ok := sctx.(processinfoSetter)这段逻辑就是把当前连接正在执行的语句存储到processinfo里面取，关于这部分细节比较简单，在这里不展开来分析。我们先来看看buildExecutor中做了什么事情？&lt;/p&gt;
&lt;pre data-source-line=&quot;128&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt; &lt;span class=&quot;hljs-selector-tag&quot;&gt;b := newExecutorBuilder(ctx, &lt;span class=&quot;hljs-selector-tag&quot;&gt;a.InfoSchema)
        e := &lt;span class=&quot;hljs-selector-tag&quot;&gt;b.build(&lt;span class=&quot;hljs-selector-tag&quot;&gt;a.Plan)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-source-line=&quot;132&quot;&gt;重点要来了，在executor/builder.go中的build方法做了啥事？&lt;/p&gt;
&lt;pre data-source-line=&quot;133&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt; case *plannercore&lt;span class=&quot;hljs-selector-class&quot;&gt;.Show:
                return &lt;span class=&quot;hljs-selector-tag&quot;&gt;b.buildShow(v)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-source-line=&quot;137&quot;&gt;build方法会根据不同的语句类型来构建不同的Executor并返回，show processlist命令会匹配到plannercore.Show类型，我们看看buildShow方法的实现：&lt;/p&gt;
&lt;pre data-source-line=&quot;138&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt; e := &amp;amp;ShowExec{
                baseExecutor: newBaseExecutor(&lt;span class=&quot;hljs-selector-tag&quot;&gt;b&lt;span class=&quot;hljs-selector-class&quot;&gt;.ctx, v.Schema(), v.ExplainID()),
                Tp:           v&lt;span class=&quot;hljs-selector-class&quot;&gt;.Tp,
                DBName:       model.NewCIStr(v.DBName),
                Table:        v&lt;span class=&quot;hljs-selector-class&quot;&gt;.Table,
                Column:       v&lt;span class=&quot;hljs-selector-class&quot;&gt;.Column,
                User:         v&lt;span class=&quot;hljs-selector-class&quot;&gt;.User,
                Flag:         v&lt;span class=&quot;hljs-selector-class&quot;&gt;.Flag,
                Full:         v&lt;span class=&quot;hljs-selector-class&quot;&gt;.Full,
                GlobalScope:  v&lt;span class=&quot;hljs-selector-class&quot;&gt;.GlobalScope,
                is:           &lt;span class=&quot;hljs-selector-tag&quot;&gt;b&lt;span class=&quot;hljs-selector-class&quot;&gt;.is,
        }
        &lt;span class=&quot;hljs-keyword&quot;&gt;if len(v.Conditions) == &lt;span class=&quot;hljs-number&quot;&gt;0 {
                return e
        }
        sel := &amp;amp;SelectionExec{
                baseExecutor: newBaseExecutor(&lt;span class=&quot;hljs-selector-tag&quot;&gt;b&lt;span class=&quot;hljs-selector-class&quot;&gt;.ctx, v.Schema(), v.ExplainID(), e),
                filters:      v&lt;span class=&quot;hljs-selector-class&quot;&gt;.Conditions,
        }
        return sel
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-source-line=&quot;160&quot;&gt;因为v.Conditions为0，所以返回类型为ShowExec的Executor，我们接下来再刚才的Exec方法中的e.Open方法，其实就是ShowExec的Open方法,ShowExec位于executor/show.go文件中，我们查找后发现ShowExec中没有Open方法，我当时是被搞蒙了，后来发现这是go的一个语言特性，它使用的是baseExecutor的Open方法：&lt;/p&gt;
&lt;pre data-source-line=&quot;161&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func &lt;span class=&quot;hljs-params&quot;&gt;(e *baseExecutor) &lt;span class=&quot;hljs-title&quot;&gt;Open&lt;span class=&quot;hljs-params&quot;&gt;(ctx context.Context) &lt;span class=&quot;hljs-title&quot;&gt;error {
        &lt;span class=&quot;hljs-keyword&quot;&gt;for _, child := &lt;span class=&quot;hljs-keyword&quot;&gt;range e.children {
                err := child.Open(ctx)
                &lt;span class=&quot;hljs-keyword&quot;&gt;if err != &lt;span class=&quot;hljs-literal&quot;&gt;nil {
                        &lt;span class=&quot;hljs-keyword&quot;&gt;return errors.Trace(err)
                }
        }
        &lt;span class=&quot;hljs-keyword&quot;&gt;return &lt;span class=&quot;hljs-literal&quot;&gt;nil
}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-source-line=&quot;172&quot;&gt;上面的方法会遍历baseExecutor中的children的Executor，然后调用它们的Open方法，但是因为ShowExec在创建它的baseExecutor的时候，没有任何的children，所以在show processlist这个操作过程中，Open方法相当于啥也没干，但是大家在分析其它语句时，这个Open方法是一个很重要的方法。我们再来看刚才Exec中的最后的return块里面，返回了包装executor、processinfo等信息的recordSet类型。至此关于show processlist命令如何包装成Executor并和processinfo等信息作为recordSet类型的返回值返回给上层函数分析完毕。&lt;/p&gt;
&lt;h2 id=&quot;show-processlist的获取各个连接的processinfo信息&quot; data-source-line=&quot;173&quot;&gt;show processlist的获取各个连接的processinfo信息&lt;/h2&gt;
&lt;p data-source-line=&quot;174&quot;&gt;接下来我们再来看handleQuery中的writeResultset方法：&lt;/p&gt;
&lt;pre data-source-line=&quot;175&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-attr&quot;&gt;err = cc.writeResultset(ctx, rs[&lt;span class=&quot;hljs-number&quot;&gt;0], &lt;span class=&quot;hljs-literal&quot;&gt;false, &lt;span class=&quot;hljs-number&quot;&gt;0, &lt;span class=&quot;hljs-number&quot;&gt;0)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-source-line=&quot;178&quot;&gt;在server/conn.go中的writeResultset主要的逻辑就是下面的逻辑：&lt;/p&gt;
&lt;pre data-source-line=&quot;179&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-attr&quot;&gt;err = cc.writeChunks(ctx, rs, binary, serverStatus)
&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-source-line=&quot;182&quot;&gt;我们继续来分析writeChunks中的重要部分:&lt;/p&gt;
&lt;pre data-source-line=&quot;183&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func &lt;span class=&quot;hljs-params&quot;&gt;(cc *clientConn) &lt;span class=&quot;hljs-title&quot;&gt;writeChunks&lt;span class=&quot;hljs-params&quot;&gt;(ctx context.Context, rs ResultSet, binary &lt;span class=&quot;hljs-keyword&quot;&gt;bool, serverStatus &lt;span class=&quot;hljs-keyword&quot;&gt;uint16) &lt;span class=&quot;hljs-title&quot;&gt;error {
        &lt;span class=&quot;hljs-keyword&quot;&gt;for {
                err := rs.Next(ctx, chk)
        }
}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-source-line=&quot;190&quot;&gt;writeChunks里面主要就是循环调用rs.Next的方法，直到满足条件为止，rs的类型实际上是server/driver_tidb.go下的tidbResultSet类型，我们来看一下它的Next方法：&lt;/p&gt;
&lt;pre data-source-line=&quot;191&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func &lt;span class=&quot;hljs-params&quot;&gt;(trs *tidbResultSet) &lt;span class=&quot;hljs-title&quot;&gt;Next&lt;span class=&quot;hljs-params&quot;&gt;(ctx context.Context, chk *chunk.Chunk) &lt;span class=&quot;hljs-title&quot;&gt;error {
        &lt;span class=&quot;hljs-keyword&quot;&gt;return trs.recordSet.&lt;span class=&quot;hljs-keyword&quot;&gt;Next(ctx, chk)
}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-source-line=&quot;196&quot;&gt;tidbResultSet的Next方法主要是调用了executor/adapter.go中的recordSet类型的Next方法，我们来看看这个Next方法：&lt;/p&gt;
&lt;pre data-source-line=&quot;197&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;func (&lt;span class=&quot;hljs-selector-tag&quot;&gt;a *&lt;span class=&quot;hljs-selector-tag&quot;&gt;recordSet) &lt;span class=&quot;hljs-selector-tag&quot;&gt;Next(&lt;span class=&quot;hljs-selector-tag&quot;&gt;ctx &lt;span class=&quot;hljs-selector-tag&quot;&gt;context&lt;span class=&quot;hljs-selector-class&quot;&gt;.Context, &lt;span class=&quot;hljs-selector-tag&quot;&gt;chk *&lt;span class=&quot;hljs-selector-tag&quot;&gt;chunk&lt;span class=&quot;hljs-selector-class&quot;&gt;.Chunk) &lt;span class=&quot;hljs-selector-tag&quot;&gt;error {
        &lt;span class=&quot;hljs-attribute&quot;&gt;err := a.executor.&lt;span class=&quot;hljs-built_in&quot;&gt;Next(ctx, chk)
}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-source-line=&quot;202&quot;&gt;recordSet方法的重点就是调用它的executor的Next方法，我们在上一个小节 结尾处分析出recordSet的executor就是之前生成的ShowExec(可算是找到它了，我已经累晕)。那么，我们接着分析它的Next方法：&lt;/p&gt;
&lt;pre data-source-line=&quot;203&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;e&lt;span class=&quot;hljs-selector-class&quot;&gt;.fetchAll()
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-source-line=&quot;206&quot;&gt;ShowExec中的Next方法的主要逻辑就是调用它的fetchAll方法，接着往下看：&lt;/p&gt;
&lt;pre data-source-line=&quot;207&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;case ast.&lt;span class=&quot;hljs-string&quot;&gt;ShowProcessList:
                &lt;span class=&quot;hljs-keyword&quot;&gt;return e.fetchShowProcessList()
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-source-line=&quot;211&quot;&gt;因为匹配到了这个case，所以会调用它的fetchShowProcessList方法：&lt;/p&gt;
&lt;pre data-source-line=&quot;212&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;func (&lt;span class=&quot;hljs-selector-tag&quot;&gt;e *&lt;span class=&quot;hljs-selector-tag&quot;&gt;ShowExec) &lt;span class=&quot;hljs-selector-tag&quot;&gt;fetchShowProcessList() &lt;span class=&quot;hljs-selector-tag&quot;&gt;error {
        &lt;span class=&quot;hljs-attribute&quot;&gt;sm := e.ctx.&lt;span class=&quot;hljs-built_in&quot;&gt;GetSessionManager()
        pl := sm.&lt;span class=&quot;hljs-built_in&quot;&gt;ShowProcessList()
}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-source-line=&quot;218&quot;&gt;上面的sm类型的server/server.go中的Server类型，我们来看看它的ShowProcessList方法：&lt;/p&gt;
&lt;pre data-source-line=&quot;219&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;func (s *Server) ShowProcessList() map[uint64]util&lt;span class=&quot;hljs-selector-class&quot;&gt;.ProcessInfo {
        s&lt;span class=&quot;hljs-selector-class&quot;&gt;.rwlock&lt;span class=&quot;hljs-selector-class&quot;&gt;.RLock()
        rs := make(map[uint64]util&lt;span class=&quot;hljs-selector-class&quot;&gt;.ProcessInfo, len(s.clients))
        &lt;span class=&quot;hljs-keyword&quot;&gt;for _, client := range s&lt;span class=&quot;hljs-selector-class&quot;&gt;.clients {
                &lt;span class=&quot;hljs-keyword&quot;&gt;if atomic.LoadInt32(&amp;amp;client.status) == connStatusWaitShutdown {
                        continue
                }
                pi := client&lt;span class=&quot;hljs-selector-class&quot;&gt;.ctx&lt;span class=&quot;hljs-selector-class&quot;&gt;.ShowProcess()
                rs[pi.ID] = pi
        }
        s&lt;span class=&quot;hljs-selector-class&quot;&gt;.rwlock&lt;span class=&quot;hljs-selector-class&quot;&gt;.RUnlock()
        return rs
}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-source-line=&quot;234&quot;&gt;它主要是遍历当前所有的客户端，并获取到所有客户端的ShowProcess，其中的client.ctx类型为server.TiDBContext，我们来看看它的ShowProcess:&lt;/p&gt;
&lt;pre data-source-line=&quot;235&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func &lt;span class=&quot;hljs-params&quot;&gt;(tc *TiDBContext) &lt;span class=&quot;hljs-title&quot;&gt;ShowProcess&lt;span class=&quot;hljs-params&quot;&gt;() &lt;span class=&quot;hljs-title&quot;&gt;util.&lt;span class=&quot;hljs-title&quot;&gt;ProcessInfo {
        &lt;span class=&quot;hljs-keyword&quot;&gt;return tc.session.ShowProcess()
}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-source-line=&quot;240&quot;&gt;逻辑比较简单，就是调用类型为session.session的ShowProcess方法，接着往下看：&lt;/p&gt;
&lt;pre data-source-line=&quot;241&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;func (s *session) ShowProcess() util&lt;span class=&quot;hljs-selector-class&quot;&gt;.ProcessInfo {
        &lt;span class=&quot;hljs-selector-tag&quot;&gt;var pi util&lt;span class=&quot;hljs-selector-class&quot;&gt;.ProcessInfo
        tmp := s&lt;span class=&quot;hljs-selector-class&quot;&gt;.processInfo&lt;span class=&quot;hljs-selector-class&quot;&gt;.Load()
        &lt;span class=&quot;hljs-keyword&quot;&gt;if tmp != nil {
                pi = tmp.(util.ProcessInfo)
                pi&lt;span class=&quot;hljs-selector-class&quot;&gt;.Mem = s.GetSessionVars()&lt;span class=&quot;hljs-selector-class&quot;&gt;.StmtCtx&lt;span class=&quot;hljs-selector-class&quot;&gt;.MemTracker&lt;span class=&quot;hljs-selector-class&quot;&gt;.BytesConsumed()
        }
        return pi
}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-source-line=&quot;252&quot;&gt;session的ShowProcess方法会从内存中加载当前session的processInfo信息。至此我们分析show processlist命令的源码分析完毕，关于每个连接如何设置自身的processinfo信息，逻辑也比较简单，大家有兴趣可以自己去研究一下。&lt;/p&gt;

&lt;p data-source-line=&quot;254&quot;&gt;我们可以回答一下开头提出的两个问题：&lt;/p&gt;
&lt;ul data-source-line=&quot;255&quot;&gt;&lt;li&gt;show processlist到底是不是单机的命令，和TiKV、PD有没有啥关系？答案是show processlist确实是一个单机命令，和TiKV、PD没有任何关系。&lt;/li&gt;
&lt;li&gt;kill tidb需要使用的id字段到底代表的是什么？id字段就是在创建连接时，分配的connectionId，它在单个TiDB服务内唯一。&lt;/li&gt;
&lt;/ul&gt;&lt;p data-source-line=&quot;258&quot;&gt;通过上面的分析，我们还可以总结以下的特点：&lt;/p&gt;
&lt;ul data-source-line=&quot;259&quot;&gt;&lt;li&gt;TiDB的连接在客户端不能够复用，因为它处理请求时，主流程是在单协程中处理的，处理完一个再处理下一个；&lt;/li&gt;
&lt;li&gt;show processlist命令的处理中关于ShowExec的Open方法调用，其实是它内部的baseExecutor的Open方法；&lt;/li&gt;
&lt;li&gt;每个连接的session负责独立管理此连接的processinfo信息；&lt;/li&gt;
&lt;li&gt;TiDB的Executor机制靠next的方式不断在它的链式处理结构上传递；&lt;/li&gt;
&lt;li&gt;show processlist因为没有其它条件，所以它在处理时的Executor类型为ShowExec，没有再包装SelectionExec类型；&lt;/li&gt;
&lt;li&gt;真正的语句执行(获取show processlist的信息)其实是在write的时候，我在分析这点的时候，花了不少时间；&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;源码阅读方法&quot; data-source-line=&quot;265&quot;&gt;源码阅读方法&lt;/h2&gt;
&lt;p data-source-line=&quot;266&quot;&gt;最后，我想和大家分享一下，我自己在源码阅读里面用到的一些方法和技巧，大的方面会有两种方法：&lt;/p&gt;
&lt;ul data-source-line=&quot;267&quot;&gt;&lt;li&gt;由因导果：就是由某一行代码，开始自顶向下的正向阅读；&lt;/li&gt;
&lt;li&gt;执果索因：就是从结果处出发，开始自底向上的反向阅读和推导；&lt;/li&gt;
&lt;/ul&gt;&lt;p data-source-line=&quot;270&quot;&gt;上面的两种方法，会伴随大家在源码阅读的各个阶段，但是有了这两种方法还是远远不够的，我再分享一下我的相关技巧：&lt;/p&gt;
&lt;ul data-source-line=&quot;271&quot;&gt;&lt;li&gt;编译运行：当我们在下定决心要阅读某个框架的源码时，第一步要做的就是，将这个框架的源码从源码库拉下来后，用我们的IDE工具编译运行起来，对于有些框架运行的难度会比较高，就比如说我这次选择的TiDB，在编译过程中花费了好多的时间。建议大家在这个过程中，不要放弃，第一步是一定要把它编译运行起来；&lt;/li&gt;
&lt;li&gt;资料参考：一般来讲只要不是太冷门的组件，一般网上都会有比较多的源码分享，我们需要甄别出写的好的源码分析资料，然后参考验证我们的源码阅读；&lt;/li&gt;
&lt;li&gt;重要类的结构关系图整理：我们都知道，java体系的组件（golang的也一样），在设计时都会有各种复杂接口和抽象类继承关系，在阅读源码时，我们很容易便陷入到这种复杂的继承关系中去，所以利用IDE工具绘出类的结构关系图，会在我们阅读源码时，有很大的帮助；&lt;/li&gt;
&lt;li&gt;掌握调试技巧：有较好的调试技巧可以便于我们分析代码流程和上下游关系；&lt;/li&gt;
&lt;li&gt;修改源码：在我们不能完全确定流程分支等情况下，可以靠修改源码去理解；&lt;/li&gt;
&lt;li&gt;提问题：在本文分析show processlist源码的过程中，提问题一直都伴随着我们的源码阅读过程，提问题能让我们更好的理解背后的含义，便于深入到源码的架构设计中去；&lt;/li&gt;
&lt;li&gt;聚焦：对于类似于TiDB如此复杂的组件，我们在一开始分析的过程中，一定要先选定分析的主线路，比如：本章的“show processlist”，在这个过程中，有意的忽略我们本次分析主线路之外的逻辑分支，目标明确，才能不会陷入到框架各种复杂的设计中去；&lt;/li&gt;
&lt;li&gt;总结分享：这一点是最重要的，源码阅读完后，如果不进行总结，过一段时间，我们便很容易遗忘了，同时分享也很重要，开源软件本身就是一种众包思想，我们既然是受益方，同时也要通过知识分享回馈他人；&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Tue, 16 Apr 2019 16:40:00 +0000</pubDate>
<dc:creator>mantu</dc:creator>
<og:description>- 丰巢把最重要的两个基础业务都放到了TiDB上，后续应该会有更多的核心系统跑在TiDB上，我们丰巢中间件团队作为引入TiDB到丰巢的推动人和执行者，对于TiDB的稳定性和突发事件的处理，一定要做足功</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mantu/p/10721122.html</dc:identifier>
</item>
<item>
<title>在商城系统中使用设计模式----策略模式之在spring中使用策略模式 - 那个男孩很坏</title>
<link>http://www.cnblogs.com/boychen/p/10721078.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/boychen/p/10721078.html</guid>
<description>&lt;div class=&quot;Box-body&quot;&gt;
&lt;p&gt;  场景：商城活动中有几种，满减，打折，送积分.我们要获取商品对最终价格。&lt;/p&gt;

&lt;p&gt;4.实现&lt;/p&gt;
&lt;p&gt;步骤一.创建接口类 &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; GoodsActivity {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 获取应该支付的金额
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; amount 商品的单价
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    BigDecimal getPayPrice(BigDecimal amount);

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 步骤二.实现接口，并添加@Component注解&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Component
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; DiscountActivity &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; GoodsActivity {

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;折扣&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; discount ;

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; BigDecimal getPayPrice(BigDecimal amount) {

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;假装从数据库的配置表取折扣&lt;/span&gt;
        discount = 8.0&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; BigDecimal(discount).multiply(amount).divide(&lt;span&gt;new&lt;/span&gt; BigDecimal(10&lt;span&gt;));
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Component
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; FullReduceActivity &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; GoodsActivity {

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;满多少&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; BigDecimal fullAmount;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;减多少&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; BigDecimal reductionAmount ;

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; BigDecimal getPayPrice(BigDecimal amount) {

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;假装从数据库的配置表取配置数据&lt;/span&gt;
        fullAmount = &lt;span&gt;new&lt;/span&gt; BigDecimal(300&lt;span&gt;);

        reductionAmount  &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; BigDecimal(100&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; amount.compareTo(fullAmount)&amp;gt;=0?&lt;span&gt;amount.subtract(reductionAmount):amount;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Component
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; IntegralActivity &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; GoodsActivity {

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;抵扣的积分  10积分=1元&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; integral = 100&lt;span&gt;;

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; BigDecimal getPayPrice(BigDecimal amount) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; amount.subtract(&lt;span&gt;new&lt;/span&gt; BigDecimal(integral/10&lt;span&gt;));
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;步骤三.创建context&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; GoodsActivityContext {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; GoodsActivity goodsActivity;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; GoodsActivityContext(GoodsActivity goodsActivity){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.goodsActivity=&lt;span&gt;goodsActivity;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 获取商品价格
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; amount
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; BigDecimal getPrice(BigDecimal amount){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; goodsActivity.getPayPrice(amount);
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;步骤四.在控制层中调用策略模式&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@RestController
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ActivityController{

    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; DiscountActivity discountActivity;

    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; FullReduceActivity fullReduceActivity;

    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; IntegralActivity integralActivity;


    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 获取最终售价
     *  （这样的控制层写法很不友好，需要写大量的代码去实现）
     *      为了解决这个问题，将引用工厂模式...
     *
     *      工厂是创建型模式,它的作用就是创建对象；
     *      策略是行为型模式,它的作用是让一个对象在许多行为中选择一种行为;
     *
     *  解决不同的问题
     * 工厂模式是创建型的设计模式，它接受指令，创建出符合要求的实例；它主要解决的是资源的统一分发，将对象的创建完全独立出来，让对象的创建和具体的使用客户无关。主要应用在多数据库选择，类库文件加载等。
     * 策略模式是为了解决的是策略的切换与扩展，更简洁的说是定义策略族，分别封装起来，让他们之间可以相互替换，策略模式让策略的变化独立于使用策略的客户。
     *
     * 工厂相当于黑盒子，策略相当于白盒子；
     *
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; activityType
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; amount
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @RequestMapping(&lt;/span&gt;&quot;getLastPrice&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ResponseResult getLastPrice(String activityType,BigDecimal amount){

        ResponseResult responseResult &lt;/span&gt;=&lt;span&gt; ResponseResult.getInstance();

        GoodsActivityContext goodsActivityContext;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据活动类型获取最终售价&lt;/span&gt;
        &lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (activityType){
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &quot;discount&quot;&lt;span&gt;:
                goodsActivityContext &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; GoodsActivityContext(discountActivity);
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &quot;fullReduce&quot;&lt;span&gt;:
                goodsActivityContext &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; GoodsActivityContext(fullReduceActivity);
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &quot;integral&quot;&lt;span&gt;:
                goodsActivityContext &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; GoodsActivityContext(integralActivity);
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
                responseResult.setCode(&lt;/span&gt;1&lt;span&gt;);
                responseResult.setMsg(&lt;/span&gt;&quot;数据类型错误&quot;&lt;span&gt;);
                responseResult.setData(&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; responseResult;
        }

        responseResult.setCode(&lt;/span&gt;0&lt;span&gt;);
        responseResult.setMsg(&lt;/span&gt;&quot;操作成功&quot;&lt;span&gt;);
        responseResult.setData(goodsActivityContext.getPrice(amount));

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; responseResult;
    }


}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;总结：按照注释说明，很明显我们需要优化这个策略模式。&lt;/p&gt;
&lt;p&gt; 步骤三：（2） 引入工厂模式，对策略对象进行管理&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Component
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; GoodsActivityStrategyFactory {

    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Map&amp;lt;String,GoodsActivity&amp;gt;&lt;span&gt; goodsActivityMap;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 根据活动类型 获取所对应的策略
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; activityType
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; GoodsActivityContext getGoodsActivityStrategy(String activityType){

        GoodsActivityContext goodsActivityContext;

        &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (activityType){
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &quot;discount&quot;&lt;span&gt;:
                goodsActivityContext &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; GoodsActivityContext(goodsActivityMap.get(&quot;discountActivity&quot;&lt;span&gt;));
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &quot;fullReduce&quot;&lt;span&gt;:
                goodsActivityContext &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; GoodsActivityContext(goodsActivityMap.get(&quot;fullReduceActivity&quot;&lt;span&gt;));
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &quot;integral&quot;&lt;span&gt;:
                goodsActivityContext &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; GoodsActivityContext(goodsActivityMap.get(&quot;integralActivity&quot;&lt;span&gt;));
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
                goodsActivityContext &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; goodsActivityContext;
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;步骤四.在控制层中调用策略模式&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@RestController
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ActivityController{

    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; GoodsActivityStrategyFactory goodsActivityStrategyFactory;


    @RequestMapping(&lt;/span&gt;&quot;getLastPrice_V2&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ResponseResult getLastPrice_V2(String activityType,BigDecimal amount){


        ResponseResult responseResult &lt;/span&gt;=&lt;span&gt; ResponseResult.getInstance();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从工厂中获取  活动策略&lt;/span&gt;
        GoodsActivityContext goodsActivityContext =&lt;span&gt; goodsActivityStrategyFactory.getGoodsActivityStrategy(activityType);

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (goodsActivityContext==&lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            responseResult.setCode(&lt;/span&gt;1&lt;span&gt;);
            responseResult.setData(&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
            responseResult.setMsg(&lt;/span&gt;&quot;数据类型错误&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; responseResult;
        }

        responseResult.setCode(&lt;/span&gt;0&lt;span&gt;);
        responseResult.setMsg(&lt;/span&gt;&quot;操作成功&quot;&lt;span&gt;);
        responseResult.setData(goodsActivityContext.getPrice(amount));

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; responseResult;

    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;源码：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/littleStone-chan/design-patternsIn-mall/tree/master/spring-boot-strategy&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;在springboot中使用策略模式&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/littleStone-chan/design-patternsIn-mall/tree/master/spring-boot-strategy&quot; target=&quot;_blank&quot;&gt; &lt;/a&gt;&lt;/p&gt;
&lt;p&gt; 在工作中，不能灵活的时候设计模式。希望通过这次的学习，可以加深对设计模式对理解。&lt;/p&gt;
&lt;p&gt;接下来会继续整理出自己在工作对时候可以使用对设计模式，不对望指点。如果文章对您有帮助，github给个start吧。&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Tue, 16 Apr 2019 16:12:00 +0000</pubDate>
<dc:creator>那个男孩很坏</dc:creator>
<og:description>1.前言： 这是策略模式在spring中的使用，对策略模式不了解对同学可以移步在商城中简单对使用策略模式。 2.问题： 在策略模式中，我们创建表示各种策略的对象和一个行为，随着策略对象改变而改变的 c</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/boychen/p/10721078.html</dc:identifier>
</item>
<item>
<title>Java面试题解析（一） - JRookie丶</title>
<link>http://www.cnblogs.com/JRookie/p/10721056.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/JRookie/p/10721056.html</guid>
<description>&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;本文是面试题目系列的第一篇，题目主要来自 GitChat 上一个课程，在此特别记录自身想的答案和在网上查询的结果，分享出来，大家共同学习。如果有不对的地方，欢迎大家指出。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr/&gt;&lt;h2 id=&quot;jdk-和-jre有什么区别&quot;&gt;JDK 和 JRE有什么区别&lt;/h2&gt;
&lt;p&gt;JDK:Java Development Kit,java开发包,其包括JRE和一些Java工具,如javac,javap等&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;开发环境(编译,调试,分析工具)和运行环境&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;JRE:Java Runtime environment,Java运行时环境,其包括JVM和Java运行过程中所需要的一些核心类库.如lang,util等常用的...&lt;/p&gt;
&lt;p&gt;--&lt;/p&gt;
&lt;h2 id=&quot;和equals的区别是什么&quot;&gt;== 和equals的区别是什么&lt;/h2&gt;
&lt;p&gt;对于基本类型来说,== 是用来比较两者的字面值是否相同的,基本类型没有equals方法&lt;/p&gt;
&lt;p&gt;对于引用来说,== 是用来比较两者的引用是否相同,equals是用来比较引用指向的对象是否相同的&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;自定义对象如果需要比较两者是否相同,需要开发者自己手动重写equals()方法,一般重写这个方法也会带着重写hashcode()方法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;h2 id=&quot;两个对象的-hashcode-相同则-equals-也一定为-true对吗&quot;&gt;两个对象的 hashCode() 相同，则 equals() 也一定为 true，对吗&lt;/h2&gt;
&lt;p&gt;不对,hashcode()只是将对象按照一定的Hash算法生成对应的16进制字符串,因为有长度的限制,因此必定会出现重复的情况,但他们的equals()此时并不一定相同.&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;final-在-java-中有什么作用&quot;&gt;final 在 java 中有什么作用&lt;/h2&gt;
&lt;p&gt;final是Java中的一个关键字.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;定义基本变量:变量是常量,在第一次声明值后就无法修改.&lt;/li&gt;
&lt;li&gt;定义对象:对象的引用无法修改,即无法指向其他的对象,但对象内部的值可以修改&lt;/li&gt;
&lt;li&gt;定义方法:方法无法被重写,一般用来表示方法已经完善了,不希望别人重写该方法&lt;/li&gt;
&lt;li&gt;定义类:类无法被继承,Java中的String等类就无法被继承.&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;h2 id=&quot;java-中的-math.round-1.5-等于多少&quot;&gt;java 中的 Math.round(-1.5) 等于多少&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;
    public void testMath(){
        log.info(&quot;-1.8:,{}&quot;,Math.round(-1.8));
        log.info(&quot;-1.5:,{}&quot;,Math.round(-1.5));
        log.info(&quot;-1.2:,{}&quot;,Math.round(-1.2));
        log.info(&quot;1.2:,{}&quot;,Math.round(1.2));
        log.info(&quot;1.5:,{}&quot;,Math.round(1.5));
        log.info(&quot;1.8:,{}&quot;,Math.round(1.8));
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;// 运行结果
2019-04-04 10:59:32.599  INFO 8076 --- [           main] com.jrookie.service.DemoServiceTest      : -1.8:,-2
2019-04-04 10:59:32.600  INFO 8076 --- [           main] com.jrookie.service.DemoServiceTest      : -1.5:,-1
2019-04-04 10:59:32.600  INFO 8076 --- [           main] com.jrookie.service.DemoServiceTest      : -1.2:,-1
2019-04-04 10:59:32.600  INFO 8076 --- [           main] com.jrookie.service.DemoServiceTest      : 1.2:,1
2019-04-04 10:59:32.600  INFO 8076 --- [           main] com.jrookie.service.DemoServiceTest      : 1.5:,2
2019-04-04 10:59:32.601  INFO 8076 --- [           main] com.jrookie.service.DemoServiceTest      : 1.8:,2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过结果可以看出除了-1.5都像是四舍五入的结果,但通过分析源码可以得出&lt;br/&gt;其结果是&lt;strong&gt;数据+0.5再向下取整&lt;/strong&gt;即可&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;string-属于基础的数据类型吗&quot;&gt;String 属于基础的数据类型吗&lt;/h2&gt;
&lt;p&gt;String属于Java核心类库的对象&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
* 内部由不可变的char数组来实现,这也解释了为什么String是不可变的类型
*/
public final class String
    implements java.io.Serializable, Comparable&amp;lt;String&amp;gt;, CharSequence {
 private final char value[];&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h2 id=&quot;java-中操作字符串都有哪些类它们之间有什么区别&quot;&gt;java 中操作字符串都有哪些类？它们之间有什么区别&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;String:最基本的字符串类型,创建后不可变&lt;/li&gt;
&lt;li&gt;StringBuilder:其内部的char[]数组都是可变,因此是可变类型&lt;/li&gt;
&lt;li&gt;StringBuffer:也是可变类型,但其内部大量使用了&lt;strong&gt;synchronized&lt;/strong&gt;关键字,表明内部的方法都是线程安全的.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;因此在性能比较上:String &amp;gt; StringBuilder &amp;gt; StringBuffer&lt;br/&gt;但如果想要用可变类型,可以直接使用StringBuffer,这个是线程安全的,且性能和StringBuilder相比,并没有差很多.&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;string-stri与-string-strnew-stringi一样吗&quot;&gt;String str=&quot;i&quot;与 String str=new String(“i”)一样吗&lt;/h2&gt;
&lt;p&gt;不一样,String str=&quot;i&quot;,是声明一个引用直接指向字符串常量池,而String str=new String(“i”),会生成一个堆对象,引用指向该对象,该对象再指向字符串常量池.&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;如何将字符串反转&quot;&gt;如何将字符串反转&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/JohnTsai/p/5606719.html&quot;&gt;多种解法及其编码实现&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;数组的方式引入第三方数据,作为存储&lt;/li&gt;
&lt;li&gt;直接在原数据上进行操作.可以考虑使用异或的方式来交换数据,效率更高&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;StringBuilder 和 StringBuffer 中封装好了对应的反转操作,可以直接使用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;h2 id=&quot;string-类的常用方法都有那些&quot;&gt;String 类的常用方法都有那些&lt;/h2&gt;
&lt;hr/&gt;&lt;h2 id=&quot;抽象类必须要有抽象方法吗&quot;&gt;抽象类必须要有抽象方法吗&lt;/h2&gt;
&lt;p&gt;根据下面的代码实例,表明应该是可以的&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public abstract class AbstractDemoClass {
    public void test(){
        System.out.println(&quot;hello,world&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h2 id=&quot;普通类和抽象类有哪些区别&quot;&gt;普通类和抽象类有哪些区别&lt;/h2&gt;
&lt;hr/&gt;&lt;h2 id=&quot;抽象类能使用-final-修饰吗&quot;&gt;抽象类能使用 final 修饰吗&lt;/h2&gt;
&lt;p&gt;不可以,抽象类必须要有子类来继承它,实现其中的抽象方法,才可以实例化,如果用final来修饰的话,该类就无法被继承,那么这个抽象类就没有用处了.&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;接口和抽象类有什么区别&quot;&gt;接口和抽象类有什么区别&lt;/h2&gt;
&lt;hr/&gt;&lt;h2 id=&quot;java-中-io-流分为几种&quot;&gt;java 中 IO 流分为几种&lt;/h2&gt;
&lt;p&gt;分为字节流和字符流,其中每个又细分为输入和输出,因此一共有四种流,分为为InputStream,OutputStream,Reader,Writer.&lt;/p&gt;
&lt;p&gt;在处理字节流和字符流之间的转换问题时,注意编码的问题.&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;bionioaio-有什么区别&quot;&gt;BIO、NIO、AIO 有什么区别&lt;/h2&gt;
&lt;h3 id=&quot;bio&quot;&gt;BIO&lt;/h3&gt;
&lt;p&gt;同步阻塞模型,A调用B,A需要收到B的返回结果才可以继续执行,B去立即执行&lt;/p&gt;
&lt;h3 id=&quot;nio&quot;&gt;NIO&lt;/h3&gt;
&lt;p&gt;非阻塞IO,A调用B,A不用收到结果就可以继续执行&lt;/p&gt;
&lt;h3 id=&quot;aio&quot;&gt;AIO&lt;/h3&gt;
&lt;p&gt;异步非阻塞IO,A调用B,B返回给A保证会执行,然后A继续干其他事,当B干完了后通知A,再让A来处理数据&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;操作基于事件和回调机制&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;h2 id=&quot;files的常用方法都有哪些&quot;&gt;Files的常用方法都有哪些&lt;/h2&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;对应collection的Collections类,是对File的操作类,封装了一些常用方法:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Files. exists()：检测文件路径是否存在。&lt;/li&gt;
&lt;li&gt;Files. createFile()：创建文件。 [ createFile()：创建文件。]&lt;/li&gt;
&lt;li&gt;Files. createDirectory()：创建文件夹。&lt;/li&gt;
&lt;li&gt;Files. delete()：删除一个文件或目录。&lt;/li&gt;
&lt;li&gt;Files. copy()：复制文件。&lt;/li&gt;
&lt;li&gt;Files. move()：移动文件。&lt;/li&gt;
&lt;li&gt;Files. size()：查看文件个数。&lt;/li&gt;
&lt;li&gt;Files. read()：读取文件。&lt;/li&gt;
&lt;li&gt;Files. write()：写入文件。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
</description>
<pubDate>Tue, 16 Apr 2019 16:01:00 +0000</pubDate>
<dc:creator>JRookie丶</dc:creator>
<og:description>在GitChat上看到的一个面试题合集，在其中添加了自己的回答，供大家和自身查漏补缺。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/JRookie/p/10721056.html</dc:identifier>
</item>
<item>
<title>连载《一个程序猿的生命周期》-《发展篇》- 27.从来没有996过，仍然需要人生的选择权 - 一个程序猿的生命周期</title>
<link>http://www.cnblogs.com/blog470130547/p/10720957.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/blog470130547/p/10720957.html</guid>
<description>&lt;p&gt;&lt;span&gt;       在项目现场，去其他团队人员的房间闲聊一个多小时，大致讲述了自己的工作经历和人生感悟的心灵鸡汤，确实不想让他们走弯路。我参加工作已经有12年的时间，小同志感慨到：&lt;strong&gt;想想要写10多年的代码...哎...&lt;/strong&gt;。我说：&lt;strong&gt;写代码只是进入社会的切入点，要以这个点向外扩充，可做的事情很多，产品经理、项目经理......；不要把程序员看作另类的职业，和其他职业没有什么区别，他们也在不断的学习，我们更应该保持一种好的心态......&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       自已从来没有996过，但是回忆过往，也算奋进和努力。传统行业和所谓“互联网”行业确实有很大区别，技术相对落后、思维相对保守、迭代相对缓慢，但是意味着可做的事情比较多。在工作方面，干过设备安装和维护、干过项目经理、一直开发软件、有自己的框架产品；业余时间做过社交网站、破解技术网站、干过绿色农业、有自己的产品网站......。一路走来，一直在探索和提高认知水平，历练了综合能力，&lt;strong&gt;人要补短板，往往是生于短处、死于长处&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       &lt;strong&gt;在互联网如火如荼的发展过程中，我确实想过一头钻进去，用时间换金钱，实现所谓的财务自由&lt;/strong&gt;。可能生活从来都没有给过我这样的机会，在第一家公司工作五六年的时候，我们有了小孩子，从此我们三个人相依为命，即要工作也要照顾家庭，所有事情都要协调和平衡，更何况现在又有了二宝。&lt;strong&gt;人生走到这个阶段，所谓的成熟可能是避免极端&lt;/strong&gt;。后来对进入“互联网”这件事越来越没有了兴趣，有时候在想这并不是我想要的生活，可能和出身于无拘无束的大山之中和第一家公司散养式的管理有关系。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       我没有996式的工作过，不代表我不思进取！在工作中一直认为很努力、很奋斗，组建团队、平台和产品开发、项目执行等等，关键是谁认可我的努力和奋斗？价值决定权在谁哪？在不同维度或高度看待这种努力和奋斗可能一文不值，可是我还一厢情愿的强调我付出的努力。&lt;strong&gt;不过我现在变聪明了，只是用工作的心态去工作，不会强调任何价值取向，任由任何人去评定好了，因为我不掌握价值决定权&lt;/strong&gt;。能避免现在各大厂的裁员嘛，我确实没有这样的把握；除了工作之外，我也一直认为很努力、很奋斗，干了一年多的绿色农业，结果没有再坚持下去。现在回到老本行，找了几个兼职人员开发产品，希望这次能够走的更长远（接受投资）。总之为了更美好的生活。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      有句话说：毁掉一个人的最好方式，是让他“忙”到没有其他时间。&lt;strong&gt;996工作没有时间去选择，没有996工作没有时间去努力，大部分人的焦虑貌似进入了死循环，这种焦虑的本质是缺少能够掌握内心的选择权，所谓的“忙”伪装成了没有时间的借口，&lt;/strong&gt;&lt;strong&gt;焦虑、努力（“忙”）、越焦虑......&lt;/strong&gt;。主动或被动跳槽解决了不本质问题，总是在重建价值决定权，总有跳不动的时候，我们往往缺少有效人生规划的路径选择，确实付出实践的坚持。&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;hr/&gt;&lt;div&gt;
&lt;div&gt;
&lt;div&gt;
&lt;div readability=&quot;6.241134751773&quot;&gt;
&lt;div readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一个程序猿的生命周期 微信平台&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;口   号：职业交流，职业规划；面对现实，用心去交流、感悟。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;公众号：iterlifetime&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;strong&gt;百木-ITer职业交流奋斗 群：141588103&lt;/strong&gt;   &lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;二维码：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/691334/201606/691334-20160618075950167-974887453.jpg&quot; alt=&quot;&quot; width=&quot;120&quot; height=&quot;120&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Tue, 16 Apr 2019 15:36:00 +0000</pubDate>
<dc:creator>一个程序猿的生命周期</dc:creator>
<og:description>在项目现场，去其他团队人员的房间闲聊一个多小时，大致讲述了自己的工作经历和人生感悟的心灵鸡汤，确实不想让他们走弯路。我参加工作已经有12年的时间，小同志感慨到：想想要写10多年的代码...哎...。我</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/blog470130547/p/10720957.html</dc:identifier>
</item>
<item>
<title>利用MAT玩转JVM内存分析（一） - javaadu</title>
<link>http://www.cnblogs.com/javaadu/p/10720799.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/javaadu/p/10720799.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;本文首发于公众号：javaadu&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;尽管JVM提供了自动内存管理的机制，试图降低程序员的开发门槛，确实也实现了这一目标，在日常开发中，我们一般都不需要关心对象的内存释放。JVM大部分都是使用trace算法来判断一个对象是否该被回收，那么JVM只能回收那些从gc roots不可达的对象。&lt;/p&gt;
&lt;p&gt;如果我们在使用某些大的对象、集合对象或者一些三方包里的资源，忘记及时释放资源的话，还是会造成JVM的内存泄漏或内存浪费的问题。因此，如果想成为更高阶的Java开发工程师，我们需要了解常见的问题排查的办法和工具，这个系列的文章，准备介绍一个用来做JVM堆内存分析的工具——MAT（Memory Aanlysis Tool）。&lt;/p&gt;
&lt;p&gt;MAT的官网在：&lt;a href=&quot;https://www.eclipse.org/mat/%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%9C%8B%E4%B8%8B%E5%AE%83%E7%9A%84%E4%BB%8B%E7%BB%8D&quot; class=&quot;uri&quot;&gt;https://www.eclipse.org/mat/，可以看下它的介绍&lt;/a&gt;——MAT是一款高性能、具备丰富功能的Java堆内存分析工具，可以用来排查内存泄漏和内存浪费的问题。&lt;/p&gt;
&lt;h2 id=&quot;一安装和装设置&quot;&gt;一、安装和装设置&lt;/h2&gt;
&lt;h3 id=&quot;mac安装&quot;&gt;1.1 mac安装&lt;/h3&gt;
&lt;p&gt;MAT 支持两种安装方式，一种是&quot;单机版“的，也就是说用户不必安装 Eclipse IDE 环境，MAT 作为一个独立的 Eclipse RCP 应用运行；另一种是”集成版“的，也就是说 MAT 也可以作为 Eclipse IDE 的一部分，和现有的开发平台集成。&lt;/p&gt;
&lt;p&gt;这里我们考虑独立安装，在观望的下载页面，选择mac os版本的安装文件下载即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/44770-0fffa136e9c4db53.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;MAT的独立下载地址&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;安装遇到的坑&quot;&gt;安装遇到的坑&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;启动直接报错，针对这个问题，我找到了这个答案：&lt;a href=&quot;https://stackoverflow.com/questions/47909239/how-to-run-eclipse-memory-analyzer-on-mac-os&quot; class=&quot;uri&quot;&gt;https://stackoverflow.com/questions/47909239/how-to-run-eclipse-memory-analyzer-on-mac-os&lt;/a&gt;，这个帖子里给出了两个方案：
&lt;ul&gt;&lt;li&gt;系统默认的workspace是只读的，更换掉即可。怎么更换呢，在文件&lt;code&gt;/Applications/mat.app/Contents/Eclipse/MemoryAnalyzer.ini&lt;/code&gt;中进行修改。&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/44770-038dea9b2408b9d7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;在mat的安装目录下，我的机器是&lt;code&gt;/Applications/mat.app/Contents/MacOS&lt;/code&gt;，执行&lt;code&gt;./MemoryAnalyzer&lt;/code&gt;命令，这种只能通过命令启动，不能通过图表启动。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;关于方案1，这篇文章讲得更细致：&lt;a href=&quot;https://www.jianshu.com/p/9bbbe3c4cc8b&quot; class=&quot;uri&quot;&gt;https://www.jianshu.com/p/9bbbe3c4cc8b&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;启动后，UI界面没反应，参考：&lt;a href=&quot;https://www.eclipse.org/forums/index.php/t/1090889/%EF%BC%8C%E6%8D%A2%E4%B8%AA%E5%8C%85%E5%8D%B3%E5%8F%AF%E3%80%82%E8%BF%99%E4%B8%AA%E9%97%AE%E9%A2%98%E6%88%91%E9%81%87%E5%88%B0%E8%BF%87%E5%BE%88%E5%A4%9A%E6%AC%A1&quot; class=&quot;uri&quot;&gt;https://www.eclipse.org/forums/index.php/t/1090889/，换个包即可。这个问题我遇到过很多次&lt;/a&gt;。&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/44770-79873fd7a95a5e60.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;mat的设置&quot;&gt;1.2 mat的设置&lt;/h3&gt;
&lt;h4 id=&quot;配置mat的堆内存大小&quot;&gt;配置mat的堆内存大小&lt;/h4&gt;
&lt;p&gt;我的电脑是8C16G的，那理论上分析10G的堆文件没问题，但是MAT默认的配置没有这么大，需要在&lt;code&gt;/Applications/mat.app/Contents/Eclipse/MemoryAnalyzer.ini&lt;/code&gt;文件中进行修改。如下图所示，我将我的MAT自己的运行时堆内存配置成了6G。&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/44770-faf635c26afab7a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;配置mat的使用&quot;&gt;配置MAT的使用&lt;/h4&gt;
&lt;p&gt;MAT的配置页面可以从Window——&amp;gt;Preferences找到，如下图所示。 &lt;img src=&quot;https://upload-images.jianshu.io/upload_images/44770-637cdd6c843e6e61.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;MAT的一般配置有几个选项&lt;/p&gt;
&lt;ol readability=&quot;3&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Keep unreachable objects：如果勾选这个，则在分析的时候会包含dump文件中的不可达对象；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Hide the getting started wizard：隐藏分析完成后的首页，控制是否要展示一个对话框，用来展示内存泄漏分析、消耗最多内存的对象排序。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Hide popup query help：隐藏弹出查询帮助，除非用户通过F1或Help按钮查询帮助。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Hide Welcome screen on launch：隐藏启动时候的欢迎界面&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Bytes Display：设置分析结果中内存大小的展示单位&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;可以看出，MAT不仅支持HPROF文件的分析，还支持DTFJ文件的分析。一般sun公司系列的JVM生成的dump文件都是HPROF格式的，IBM的JVM生成的dump文件时DTFJ格式的。&lt;/p&gt;
&lt;h2 id=&quot;二基本概念&quot;&gt;二、基本概念&lt;/h2&gt;
&lt;h3 id=&quot;heap-dump&quot;&gt;Heap Dump&lt;/h3&gt;
&lt;p&gt;Heap Dump是Java进程在某个时刻的内存快照，不同JVM的实现的Heap Dump的文件格式可能不同，进而存储的数据也可能不同，但是一般来说。&lt;/p&gt;
&lt;p&gt;Heap Dump中主要包含当生成快照时堆中的java对象和类的信息，主要分为如下几类：&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;对象信息：类名、属性、基础类型和引用类型&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;类信息：类加载器、类名称、超类、静态属性&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;gc roots：JVM中的一个定义，进行垃圾收集时，要遍历可达对象的起点节点的集合&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;线程栈和局部变量：快照生成时候的线程调用栈，和每个栈上的局部变量&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Heap Dump中没有包含对象的分配信息，因此它不能用来分析这种问题：一个对象什么时候被创建、一个对象时被谁创建的。&lt;/p&gt;
&lt;h3 id=&quot;shallow-vs.-retained-heap&quot;&gt;Shallow vs. Retained Heap&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Shallow heap&lt;/strong&gt;是一个对象本身占用的堆内存大小。一个对象中，每个引用占用8或64位，Integer占用4字节，Long占用8字节等等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Retained set&lt;/strong&gt;，对于某个对象X来说，它的Retained set指的是——如果X被垃圾收集器回收了，那么这个集合中的对象都会被回收，同理，如果X没有被垃圾收集器回收，那么这个集合中的对象都不会被回收。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Retained heap&lt;/strong&gt;，对象X的Retained heap指的时候它的Retained set中的所有对象的Shallow si的和，换句话说，Retained heap指的是对象X的保留内存大小，即由于它的存活导致多大的内存也没有被回收。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;leading set&lt;/strong&gt;，对象X可能不止有一个，这些对象统一构成了leading set。如果leading set中的对象都不可达，那么这个leading set对应的retained set中的对象就会被回收。一般有以下几种情况：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;某个类的所有实例对象，这个类对象就是leading object&lt;/li&gt;
&lt;li&gt;某个类记载器加载的所有类，以及这些类的实例对象，这个类加载器对象就是leading object&lt;/li&gt;
&lt;li&gt;一组对象，要达到其他对象的必经路径上的对象，就是leading object&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;在下面这张图中，A和B是gc roots中的节点（方法参数、局部变量，或者调用了wait()、notify()或synchronized()的对象）等等。可以看出，E的存在，会导致G无法被回收，因此E的Retained set是E和G；C的存在，会导致E、D、F、G、H都无法被回收，因此C的Retined set是C、E、D、F、G、H；A和B的存在，会导致C、E、D、F、G、H都无法被回收，因此A和B的Retained set是A、B、C、E、D、F、G、H。&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/44770-1c25329c291f4498.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;dominator-tree&quot;&gt;Dominator Tree&lt;/h3&gt;
&lt;p&gt;MAT根据堆上的对象引用关系构建了支配树（Dominator Tree），通过支配树可以很方便得识别出哪些对象占用了大量的内存，并可以看到它们之间的依赖关系。&lt;/p&gt;
&lt;p&gt;如果在对象图中，从gc root或者x上游的一个节点开始遍历，x是y的必经节点，那么就可以说x支配了y（&lt;strong&gt;dominate&lt;/strong&gt;）。&lt;/p&gt;
&lt;p&gt;如果在对象图中，x支配的所有对象中，y的距离最近，那么就可以说x直接支配（&lt;strong&gt;immediate dominate&lt;/strong&gt;）y。&lt;/p&gt;
&lt;p&gt;支配树是基于对象的引用关系图建立的，在支配树中每个节点都是它的子节点的直接支配节点。基于支配树可以很清楚得看到对象之间的依赖关系。&lt;/p&gt;
&lt;p&gt;现在看个例子，在下面这张图中&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;x节点的子树就是所有被x支配的节点集合，也正式x的retained set；&lt;/li&gt;
&lt;li&gt;如果x是y的直接支配节点，那么x的支配节点也可以支配y&lt;/li&gt;
&lt;li&gt;支配树中的边跟对象引用图中的引用关系并不是一一对应的。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/44770-5be2b9e84ebe546c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;garbage-collection-roots&quot;&gt;Garbage Collection Roots&lt;/h3&gt;
&lt;p&gt;在MAT中，gc roots的概念跟研究垃圾收集算法时候的概念稍微有点不同。gc roots中的对象，是指那些可以从堆外访问到的对象的集合。如果一个对象符合下面这些场景中的一个，就可以被认为是gc roots中的节点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;System Class：由bootstrap classloader加载的类，例如rt.jar，里面的类的包名都是&lt;code&gt;java.util.*&lt;/code&gt;开头的。&lt;/li&gt;
&lt;li&gt;JNI Local：native代码中的局部变量，例如用户编写的JNI代码或JVM内部代码。&lt;/li&gt;
&lt;li&gt;JNI Global：native代码中的全局变量，例如用户编写的JNI代码或JVM内部代码。&lt;/li&gt;
&lt;li&gt;Thread Block：被当前活跃的线程锁引用的对象。&lt;/li&gt;
&lt;li&gt;Thread：正在存活的线程&lt;/li&gt;
&lt;li&gt;Busy Monitor：调用了wait()、notify()或synchronized关键字修饰的代码——例如&lt;code&gt;synchronized(object)&lt;/code&gt;或&lt;code&gt;synchronized&lt;/code&gt;方法。&lt;/li&gt;
&lt;li&gt;Java Local：局部变量。例如函数的输入参数、正在运行的线程栈里创建的对象。&lt;/li&gt;
&lt;li&gt;Native Stack：native代码的输入或输出参数，例如用户定义的JNI代码或JVM的内部代码。在文件/网络IO方法或反射方法的参数。&lt;/li&gt;
&lt;li&gt;Finalizable：在finalize队列中等待它的finalizer对象运行的对象。&lt;/li&gt;
&lt;li&gt;Unfinalized：重载了finalize方法，但是还没有进入finalize队列中的对象。&lt;/li&gt;
&lt;li&gt;Unreachable：从任何gc roots节点都不可达的对象，在MAT中将这些对象视为root节点，如果不这么做，就不能对这些对象进行分析。&lt;/li&gt;
&lt;li&gt;Java Stack Frame：Java栈帧，用于存放局部变量。只在dump文件被解析的时候会将java stack frame视为对象。&lt;/li&gt;
&lt;li&gt;Unknown：没有root类型的对象。有些dump文件（例如IBM的Portable Heap Dump）没有root信息。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;三获取dump文件&quot;&gt;三、获取Dump文件&lt;/h2&gt;
&lt;ol readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;通过MAT生成dump文件&lt;br/&gt;通过这个路径找到生成dump文件的对话框&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/44770-41395cd611310d7e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;br/&gt;选择一个进程，点击finish即可 &lt;img src=&quot;https://upload-images.jianshu.io/upload_images/44770-6f7a6e9103e934c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;通过jmap命令生成dump文件
&lt;ul&gt;&lt;li&gt;命令格式：&lt;code&gt;jmap -dump:live,format=b,file=heap.bin &amp;lt;pid&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;注意：如果要保留heapdump中的不可达对象，则需要把”:live“去掉，即使用命令”jmap -dump,format=b,file=heap.bin “&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;通过设置JVM参数自动生成&lt;br/&gt;使用&lt;code&gt;-XX:+HeapDumpOnOutOfMemoryError&lt;/code&gt;这个JVM参数，在Java进程运行过程中发生OOM的时候就会生成一个heapdump文件，并写入到指定目录，一般用&lt;code&gt;-XX:HeapDumpPath=${HOME}/logs/test&lt;/code&gt;来设置。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;hr/&gt;&lt;p&gt;本号专注于后端技术、JVM问题排查和优化、Java面试题、个人成长和自我管理等主题，为读者提供一线开发者的工作和成长经验，期待你能在这里有所收获。&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/44770-7daebe9e48739106.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;javaadu&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 16 Apr 2019 15:10:00 +0000</pubDate>
<dc:creator>javaadu</dc:creator>
<og:description>本文首发于公众号：javaadu 尽管JVM提供了自动内存管理的机制，试图降低程序员的开发门槛，确实也实现了这一目标，在日常开发中，我们一般都不需要关心对象的内存释放。JVM大部分都是使用trace算</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/javaadu/p/10720799.html</dc:identifier>
</item>
<item>
<title>JPA中自定义的插入、更新、删除方法为什么要添加@Modifying注解和@Transactional注解？ - 无恨之都</title>
<link>http://www.cnblogs.com/wuhenzhidu/p/jpa.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wuhenzhidu/p/jpa.html</guid>
<description>&lt;p&gt;　　前几天，有个同事在使用JPA的自定义SQL方法时，程序一直报异常，捣鼓了半天也没能解决，咨询我的时候，我看了一眼他的程序，差不多是这个样子的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;@Repository
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; UserRepository &lt;span&gt;extends&lt;/span&gt; JpaRepository&amp;lt;User,Long&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; 
&lt;span&gt;4&lt;/span&gt;     @Query(value = &quot;delete from pro_user where id = ?1&quot;,nativeQuery = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt;&lt;span&gt; deleteUserById(Long id);
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　我告诉他，你的deleteUserById方法缺少了@Modifying注解和@Transactional注解，他半信半疑地试了一下，然后果然就解决了。其实，如果他查一下官方资料或许很快也就能找到答案。基于这个背景，本文详细讲解一下为何我们自定义的插入、更新、删除操作需要加@Modifying注解和@Transactional注解。&lt;/p&gt;
&lt;h2&gt;一、@Modifying注解&lt;/h2&gt;
&lt;p&gt;　　在官方资料中，给出了这样几句说明：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre readability=&quot;6&quot;&gt;
&lt;span&gt;As the queries themselves are tied to the Java method that executes them, you can actually bind them directly by using the Spring Data JPA @Query annotation 
rather than annotating them to the domain &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span readability=&quot;6&quot;&gt;.&lt;br/&gt;You can modify queries that only need parameter binding by annotating the query method with @Modifying&lt;p&gt;The @Modifying annotation is only relevant in combination with the @Query annotation. Derived query methods or custom methods do not require this Annotation.&lt;/p&gt;&lt;p&gt;Doing so triggers the query annotated to the method as an updating query instead of a selecting one.&lt;/p&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Modifying
@Query(&lt;/span&gt;&quot;update User u set u.firstname = ?1 where u.lastname = ?2&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; setFixedFirstnameFor(String firstname, String lastname);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　第一句话的意思是可以用@Query注解来将自定义sql语句绑定到自定义方法上。&lt;/p&gt;
&lt;p&gt;　　第二句话的意思时，可以用@Modifying注解来标注只需要绑定参数的自定义的更新类语句（更新、插入、删除）。&lt;/p&gt;
&lt;p&gt;　　第三名话的意思是说@Modifying只与@Query联合使用，派生类的查询方法和自定义的方法不需要此注解，如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;@Repository
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; UserRepository &lt;span&gt;extends&lt;/span&gt; JpaRepository&amp;lt;User,Long&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 父类的保存方法&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    User save(User entity); 
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 按照JPA语法规则自定义的查询方法&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     List&amp;lt;User&amp;gt;&lt;span&gt; findFirst10ByLastname(String lastName, Pageable pageable);  
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　第四句话的意思是，当加上@Modifying注解时，JPA会以更新类语句来执行，而不再是以查询语句执行。　　&lt;/p&gt;
&lt;p&gt;　　也就是说，当我们要通过自已写的更新、插入、删除SQL语句来实现更新、插入、删除操作时，至少需要用两个步骤：&lt;/p&gt;
&lt;p&gt;　　1）@Query来注入我们自定义的sql；&lt;/p&gt;
&lt;p&gt;　　2）使用@Modifying来标注是一个更新类的自定义语句。&lt;/p&gt;
&lt;p&gt;　　按照这个规则，修改同事的那个方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt; @Repository
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; UserRepository &lt;span&gt;extends&lt;/span&gt; JpaRepository&amp;lt;User,Long&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;  
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;     @Modifying
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;      @Query(value = &quot;delete from pro_user where id = ?1&quot;,nativeQuery = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;      &lt;span&gt;void&lt;/span&gt;&lt;span&gt; deleteUserById(Long id);
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;  }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　但是，此时，该方法还不完整，执行时程序会报以下错误：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
org.springframework.dao.InvalidDataAccessApiUsageException: Executing an update/delete query; nested exception is javax.persistence.TransactionRequiredException: &lt;br/&gt;Executing an update/&lt;span&gt;delete query
    at org.springframework.orm.jpa.EntityManagerFactoryUtils.convertJpaAccessExceptionIfPossible(EntityManagerFactoryUtils.java:&lt;/span&gt;402&lt;span&gt;)
    at org.springframework.orm.jpa.vendor.HibernateJpaDialect.translateExceptionIfPossible(HibernateJpaDialect.java:&lt;/span&gt;255&lt;span&gt;)
    ......
    at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:&lt;/span&gt;70&lt;span&gt;)
Caused by: javax.persistence.TransactionRequiredException: Executing an update&lt;/span&gt;/&lt;span&gt;delete query
    at org.hibernate.internal.AbstractSharedSessionContract.checkTransactionNeededForUpdateOperation(AbstractSharedSessionContract.java:&lt;/span&gt;398&lt;span&gt;)
    at org.hibernate.query.internal.AbstractProducedQuery.executeUpdate(AbstractProducedQuery.java:&lt;/span&gt;1585&lt;span&gt;)
    .......&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;二、@Transactional注解&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;　　官方的说明：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-expand&quot;&gt;　　By default, CRUD methods on repository instances are transactional. For read operations, the transaction configuration&lt;/span&gt; &lt;span&gt;&lt;code&gt;readOnly&lt;/code&gt;&lt;/span&gt; &lt;span&gt;flag is set to&lt;/span&gt; &lt;span&gt;&lt;code&gt;true&lt;/code&gt;&lt;/span&gt;&lt;span&gt;. All others are configured with a plain&lt;/span&gt; &lt;span&gt;&lt;code&gt;@Transactional&lt;/code&gt;&lt;/span&gt; &lt;span&gt;so that default transaction configuration applies. For details, see JavaDoc of&lt;/span&gt; &lt;span&gt;&lt;a href=&quot;https://docs.spring.io/spring-data/data-jpa/docs/current/api/index.html?org/springframework/data/jpa/repository/support/SimpleJpaRepository.html&quot;&gt;&lt;span&gt;&lt;code&gt;SimpleJpaRepository&lt;/code&gt;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;span&gt;. If you need to tweak transaction configuration for one of the methods declared in a repository, redeclare the method in your repository interface, as follows:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;em&gt;&lt;span&gt;Example. Custom transaction configuration for CRUD&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; UserRepository &lt;span&gt;extends&lt;/span&gt; CrudRepository&amp;lt;User, Long&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; 
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;  @Override
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;   @Transactional(timeout = 10&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;   &lt;span&gt;public&lt;/span&gt; List&amp;lt;User&amp;gt;&lt;span&gt; findAll();
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; 
&lt;span&gt;7&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Further query method declarations&lt;/span&gt;
&lt;span&gt;8&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这句话的意思是，默认情况下，repository 接口中的CRUD方法都是被@Transactional注解修饰了的，对于读的操作方法，@Transactional注解的readOnly属性是被设置为true的，即只读；CRUD中的其他方法被@Transactional修饰，即非只读。如果你需要修改repository 接口中的某些方法的事务属性，可以在该方法上重新加上@Transactional注解，并设置需要的属性。&lt;/p&gt;
&lt;p&gt;　　我们先来看一下，@Transactional注解的源码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;@Target({ElementType.METHOD, ElementType.TYPE})
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;@Retention(RetentionPolicy.RUNTIME)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;@Inherited
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;@Documented
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; @&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Transactional {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;     Propagation propagation() &lt;span&gt;default&lt;/span&gt;&lt;span&gt; Propagation.REQUIRED;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     Isolation isolation() &lt;span&gt;default&lt;/span&gt;&lt;span&gt; Isolation.DEFAULT;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; timeout() &lt;span&gt;default&lt;/span&gt; -1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;boolean&lt;/span&gt; readOnly() &lt;span&gt;default&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;   
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 其他省略&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　由上可见@Transactional注解的readOnly默认的属性的false，即非只读，当一个事务是非只读事务的时候，我们可以进行任何操作。&lt;/p&gt;
&lt;p&gt;　　再看一下repository 接口的实现类SimpleJpaRepository的源码(只摘了部分源码)：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;@Repository
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;@Transactional(
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     readOnly = &lt;span&gt;true&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; SimpleJpaRepository&amp;lt;T, ID&amp;gt; &lt;span&gt;implements&lt;/span&gt; JpaRepositoryImplementation&amp;lt;T, ID&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;    
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    @Transactional
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; deleteById(ID id) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         Assert.notNull(id, &quot;The given id must not be null!&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.delete(&lt;span&gt;this&lt;/span&gt;.findById(id).orElseThrow(() -&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; EmptyResultDataAccessException(String.format(&quot;No %s entity with id %s exists!&quot;, &lt;span&gt;this&lt;/span&gt;.entityInformation.getJavaType(), id), 1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        }));
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    @Transactional
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; delete(T entity) {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         Assert.notNull(entity, &quot;The entity must not be null!&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.em.remove(&lt;span&gt;this&lt;/span&gt;.em.contains(entity) ? entity : &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.em.merge(entity));
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    @Transactional
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; deleteAll(Iterable&amp;lt;? &lt;span&gt;extends&lt;/span&gt; T&amp;gt;&lt;span&gt; entities) {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         Assert.notNull(entities, &quot;The given Iterable of entities not be null!&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         Iterator var2 =&lt;span&gt; entities.iterator();
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt;&lt;span&gt;(var2.hasNext()) {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;             T entity =&lt;span&gt; var2.next();
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.delete(entity);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; T getOne(ID id) {
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         Assert.notNull(id, &quot;The given id must not be null!&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.em.getReference(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getDomainClass(), id);
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; 
&lt;span&gt;37&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; List&amp;lt;T&amp;gt;&lt;span&gt; findAll() {
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.getQuery((Specification)&lt;span&gt;null&lt;/span&gt;&lt;span&gt;, (Sort)Sort.unsorted()).getResultList();
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; 
&lt;span&gt;41&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; List&amp;lt;T&amp;gt; findAll(@Nullable Specification&amp;lt;T&amp;gt;&lt;span&gt; spec) {
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getQuery(spec, Sort.unsorted()).getResultList();
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; 
&lt;span&gt;45&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; List&amp;lt;T&amp;gt; findAll(@Nullable Specification&amp;lt;T&amp;gt;&lt;span&gt; spec, Sort sort) {
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getQuery(spec, sort).getResultList();
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; 
&lt;span&gt;49&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &amp;lt;S &lt;span&gt;extends&lt;/span&gt; T&amp;gt; &lt;span&gt;long&lt;/span&gt; count(Example&amp;lt;S&amp;gt;&lt;span&gt; example) {
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; executeCountQuery(&lt;span&gt;this&lt;/span&gt;.getCountQuery(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; SimpleJpaRepository.ExampleSpecification(example), example.getProbeType()));
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; 
&lt;span&gt;53&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &amp;lt;S &lt;span&gt;extends&lt;/span&gt; T&amp;gt; &lt;span&gt;boolean&lt;/span&gt; exists(Example&amp;lt;S&amp;gt;&lt;span&gt; example) {
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; !&lt;span&gt;this&lt;/span&gt;.getQuery(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; SimpleJpaRepository.ExampleSpecification(example), example.getProbeType(), (Sort)Sort.unsorted()).getResultList().isEmpty();
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; 
&lt;span&gt;57&lt;/span&gt; &lt;span&gt;    @Transactional
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &amp;lt;S &lt;span&gt;extends&lt;/span&gt; T&amp;gt;&lt;span&gt; S save(S entity) {
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.entityInformation.isNew(entity)) {
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.em.persist(entity);
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; entity;
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;         } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.em.merge(entity);
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt; 
&lt;span&gt;67&lt;/span&gt; &lt;span&gt;    @Transactional
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &amp;lt;S &lt;span&gt;extends&lt;/span&gt; T&amp;gt;&lt;span&gt; S saveAndFlush(S entity) {
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt;         S result = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.save(entity);
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.flush();
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;73&lt;/span&gt; 
&lt;span&gt;74&lt;/span&gt; &lt;span&gt;    @Transactional
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; flush() {
&lt;/span&gt;&lt;span&gt;76&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.em.flush();
&lt;/span&gt;&lt;span&gt;77&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;78&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　从SimpleJpaRepository源码中可以看出：&lt;/p&gt;
&lt;p&gt;　   1）该类上注解了只读事务@Transactional(readOnly = true)；&lt;/p&gt;
&lt;p&gt;       2）该类的所有查询类操作方法都与类相同，都拥有只读事务；&lt;/p&gt;
&lt;p&gt;       3）该类的所有保存、更新、删除操作方法都用@Transactional重新注解了（默认readOnly=false）。&lt;/p&gt;
&lt;p&gt;　　说明JPA为我们提供的所有方法，包括JPA规则的自定义方法在其底层都为我们做好了事务处理，而我们自定义的方法需要自己来标注事务的类型是只读还是非只读。根据这个原理，再次修改开篇所列出的方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;@Repository
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; UserRepository &lt;span&gt;extends&lt;/span&gt; JpaRepository&amp;lt;User,Long&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; 
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;    @Transactional
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;    @Modifying
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     @Query(value = &quot;delete from pro_user where id = ?1&quot;,nativeQuery = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt;&lt;span&gt; deleteUserById(Long id);
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　至此，该方法按所期望的结果运行成功了。&lt;/p&gt;
&lt;h2&gt;三、@Modifying注解补充说明&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;@Retention(RetentionPolicy.RUNTIME)
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;@Target({ ElementType.METHOD, ElementType.ANNOTATION_TYPE })
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;@Documented
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; @&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Modifying {
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; 
&lt;span&gt;6&lt;/span&gt;     &lt;span&gt;boolean&lt;/span&gt; flushAutomatically() &lt;span&gt;default&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; 
&lt;span&gt;8&lt;/span&gt;     &lt;span&gt;boolean&lt;/span&gt; clearAutomatically() &lt;span&gt;default&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　该注解中有两个属性：flushAutomatically、clearAutomatically，从字面理解是自动刷新和自动清除。&lt;/p&gt;
&lt;p&gt;　　自动刷新，即执行完语句后立即将变化内容刷新到磁盘，如果是insert语句操作，则与JPA的&amp;lt;S extends T&amp;gt; S saveAndFlush(S entity);方法效果相同；&lt;/p&gt;
&lt;p&gt;　　自动清除，即执行完语句后自动清除掉已经过期的实体，比如，我们删除了一个实体，但是在还没有执行flush操作时，这个实体还存在于实体管理器EntityManager中，但这个实体已经过期没有任何用处，直到flush操作时才会被删除掉。如果希望在删除该实体时立即将该实体从实体管理器中删除，则可以将该属性设置为true，如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; @Modifying(clearAutomatically = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;    @Transactional
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     @Query(value = &quot;delete from pro_user where id = ?1&quot;,nativeQuery = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt; deleteUserById(Long id);
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Tue, 16 Apr 2019 14:44:00 +0000</pubDate>
<dc:creator>无恨之都</dc:creator>
<og:description>前几天，有个同事在使用JPA的自定义SQL方法时，程序一直报异常，捣鼓了半天也没能解决，咨询我的时候，我看了一眼他的程序，差不多是这个样子的： 我告诉他，你的deleteUserById方法缺少了@M</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wuhenzhidu/p/jpa.html</dc:identifier>
</item>
<item>
<title>面试必备的数据库悲观锁与乐观锁 - Coder编程</title>
<link>http://www.cnblogs.com/coder-programming/p/10720524.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/coder-programming/p/10720524.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/4/16/16a26835c73ea038?w=900&amp;amp;h=383&amp;amp;f=png&amp;amp;s=178029&quot; alt=&quot;悲观锁与乐观锁&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;在上一个章节&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIwMTg3NzYyOA==&amp;amp;mid=2247483728&amp;amp;idx=1&amp;amp;sn=cdc5dc4708e48051e56b8e7d2a9fe5a8&amp;amp;chksm=96e67043a191f955b93e7228b88572beb486e6fac3308a1b69f5ee83c9e9ced6957e30b12d58&amp;amp;token=1787261466&amp;amp;lang=zh_CN#rd&quot;&gt;5分钟带你读懂事务隔离性与隔离级别&lt;/a&gt;的最后，其实我们已经提到了锁的概念。本章节接下来将主要介绍以下数据库&lt;code&gt;悲观锁与乐观锁&lt;/code&gt;的相关知识。如有错误还请大家及时指出~&lt;/p&gt;
&lt;blockquote readability=&quot;4.320987654321&quot;&gt;
&lt;p&gt;本文已同步至 &lt;a href=&quot;https://github.com/CoderMerlin/coder-programming&quot;&gt;GitHub&lt;/a&gt;/&lt;a href=&quot;https://gitee.com/573059382/coder-programming&quot;&gt;Gitee&lt;/a&gt;/公众号，感兴趣的同学帮忙点波关注~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;为什么需要锁？&lt;/li&gt;
&lt;li&gt;什么是悲观锁？&lt;/li&gt;
&lt;li&gt;什么是乐观锁？&lt;/li&gt;
&lt;li&gt;悲观锁与乐观锁区别与联系？&lt;/li&gt;
&lt;li&gt;悲观锁与乐观锁的使用场景？&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;为什么需要锁&quot;&gt;为什么需要锁？&lt;/h2&gt;
&lt;p&gt;在并发环境下，如果多个客户端访问同一条数据，此时就会产生数据不一致的问题，如何解决，通过加锁的机制，常见的有两种锁，乐观锁和悲观锁，可以在一定程度上解决并发访问。&lt;/p&gt;
&lt;h2 id=&quot;悲观锁pessimistic-lock&quot;&gt;1. 悲观锁（Pessimistic Lock）&lt;/h2&gt;
&lt;h3 id=&quot;定义&quot;&gt;1.1 定义&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;百度百科：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;悲观锁，正如其名，具有强烈的独占和排他特性。它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;其他知识点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;悲观锁主要是&lt;code&gt;共享锁&lt;/code&gt;或&lt;code&gt;排他锁&lt;/code&gt;&lt;br/&gt;&lt;code&gt;共享锁&lt;/code&gt;又称为读锁，简称S锁，顾名思义，共享锁就是多个事务对于同一数据可以共享一把锁，都能访问到数据，但是只能读不能修改。&lt;br/&gt;&lt;code&gt;排他锁&lt;/code&gt;又称为写锁，简称X锁，顾名思义，排他锁就是不能与其他所并存，如一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁，包括共享锁和排他锁，但是获取排他锁的事务是可以对数据就行读取和修改。&lt;/p&gt;
&lt;h3 id=&quot;案例分析&quot;&gt;1.2 案例分析&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;使用场景举例：以MySQL InnoDB为例&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;作为演示，我们继续使用之前的数据库表：product表&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;小米&lt;/td&gt;
&lt;td&gt;1999&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;魅族&lt;/td&gt;
&lt;td&gt;1999&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;首先我们需要&lt;code&gt;set autocommit=0&lt;/code&gt;，即不允许自动提交&lt;/p&gt;
&lt;p&gt;有看过上一篇文章&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIwMTg3NzYyOA==&amp;amp;mid=2247483728&amp;amp;idx=1&amp;amp;sn=cdc5dc4708e48051e56b8e7d2a9fe5a8&amp;amp;chksm=96e67043a191f955b93e7228b88572beb486e6fac3308a1b69f5ee83c9e9ced6957e30b12d58&amp;amp;token=1787261466&amp;amp;lang=zh_CN#rd&quot;&gt;5分钟带你读懂事务隔离性与隔离级别&lt;/a&gt;的同学，可以看到最后我们使用事务隔离级别时，所引申出来的根本问题就是可以通过锁机制解决。&lt;/p&gt;
&lt;h4 id=&quot;问题&quot;&gt;问题&lt;/h4&gt;
&lt;p&gt;在并发情况下回导致数据一致性的问题：&lt;br/&gt;如果有A、B两个用户需要抢productId =1的小米手机，A、B用户都查询小米手机数量是100，A购买后修改商品的数量为99，B购买后修改数量为99。&lt;/p&gt;
&lt;h4 id=&quot;用法&quot;&gt;用法&lt;/h4&gt;
&lt;p&gt;每次获取小米手机时，对该商品加排他锁。也就是在用户A获取获取 id=1 的小米手机信息时对该行记录加锁，期间其他用户阻塞等待访问该记录。代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;start transaction；
 
select p.productCount from product p where p.productId = 1 for update;
 
update product p set p.productCount=p.productCount-1 where p.productId=1 ;
 
commit;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;操作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面同时打开两个窗口模拟2个用户并发访问数据库&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;T1&lt;/td&gt;
&lt;td&gt;start transaction;&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;T2&lt;/td&gt;
&lt;td&gt;select p.productCount from product p where p.productId = 1 for update;&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;T3&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;start transaction;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;T4&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;select p.productCount from product p where p.productId = 1 for update;(等待中...)&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;流程说明&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;用户A start transaction开启一个事物。前一步我们关闭了mysql的autocommit，所以需要手动控制事务的提交。&lt;/li&gt;
&lt;li&gt;在获得小米手机信息（productId = 1 ）时，进行数据加锁操作（for update）。与普通查询方式不同，我们使用了&lt;code&gt;select…for update&lt;/code&gt;的方式，这样就通过数据库实现了悲观锁。在这个update事务提交之前其他外界是不能修改这条数据的，但是这种处理方式效率比较低，一般不推荐使用。&lt;/li&gt;
&lt;li&gt;用户B start transaction开启一个事物。&lt;/li&gt;
&lt;li&gt;用户B 也进行查询操作，此时处于等待中（阻塞状态）。ps:需要等待用户A事务提交后，才会执行。&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;注意：在事务中，只有select…for update(排他锁) 或lock in share mode(共享锁) 操作同一个数据时才会等待其它事务结束后才执行，一般select... 则不受此影响。例如在 T3中执行select p.productCount from product p where p.productId = 1;则能正常查询出数据，不会受第一个事务的影响。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;乐观锁optimistic-lock&quot;&gt;2. 乐观锁（Optimistic Lock）&lt;/h2&gt;
&lt;h3 id=&quot;定义-1&quot;&gt;2.1 定义&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;百度百科：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;乐观锁机制采取了更加宽松的加锁机制。乐观锁是相对悲观锁而言，也是为了避免数据库幻读、业务处理时间过长等原因引起数据处理错误的一种机制，但乐观锁不会刻意使用数据库本身的锁机制，而是依据数据本身来保证数据的正确性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;其他知识点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;实现乐观锁一般来说有以下2种方式：&lt;/p&gt;
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;使用版本号&lt;br/&gt;使用数据版本（Version）记录机制实现，这是乐观锁最常用的一种实现方式。何谓数据版本？即为数据增加一个版本标识，一般是通过为数据库表增加一个数字类型的 “version” 字段来实现。当读取数据时，将version字段的值一同读出，数据每更新一次，对此version值加一。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的version值进行比对，如果数据库表当前版本号与第一次取出来的version值相等，则予以更新，否则认为是过期数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;使用时间戳&lt;br/&gt;乐观锁定的第二种实现方式和第一种差不多，同样是在需要乐观锁控制的table中增加一个字段，名称无所谓，字段类型使用时间戳（timestamp）, 和上面的version类似，也是在更新提交的时候检查当前数据库中数据的时间戳和自己更新前取到的时间戳进行对比，如果一致则OK，否则就是版本冲突。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;案例分析-1&quot;&gt;2.2 案例分析&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;使用场景举例：以MySQL InnoDB为例&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;作为演示，我们继续使用之前的数据库表：product表&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;小米&lt;/td&gt;
&lt;td&gt;1999&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;魅族&lt;/td&gt;
&lt;td&gt;1999&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;我们以&lt;code&gt;版本号&lt;/code&gt;实现的方式进行说明。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;操作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;查询当前事务隔离级别：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
SELECT @@tx_isolation;


结果：
REPEATABLE-READ
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面同时打开两个窗口模拟2个用户并发访问数据库&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一种测试&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;7&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;T1&lt;/td&gt;
&lt;td&gt;start transaction;&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;T2&lt;/td&gt;
&lt;td&gt;select * from product p where p.productId = 1;(productCount=100)&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;T3&lt;/td&gt;
&lt;td&gt;update product p set p.productCount = 99,version=version+1 where p.productId = 1 and version = 1;(受影响的行: 1)&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;T4&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;start transaction;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;T5&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;select * from product p where p.productId = 1;(productCount=100)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;T6&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;update product p set p.productCount = 99,version=version+1 where p.productId = 1 and version = 1;(等待中...)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;T7&lt;/td&gt;
&lt;td&gt;commit;&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;T8&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;T6执行(受影响的行: 0)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;T9&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;commit;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;流程说明&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;事务A开启事务。&lt;/li&gt;
&lt;li&gt;事务A查询当前小米手机数量为100。&lt;/li&gt;
&lt;li&gt;事务A购买小米手机，小米手机数量更新为99。(此时并未提交事务)。&lt;/li&gt;
&lt;li&gt;事务B开启事务。&lt;/li&gt;
&lt;li&gt;事务B查询当前小米手机数量为100。&lt;/li&gt;
&lt;li&gt;事务B购买小米手机，小米手机数量更新为99。注意：此时处于阻塞状态。&lt;/li&gt;
&lt;li&gt;事务A提交事务。&lt;/li&gt;
&lt;li&gt;此时第六步执行完毕，但并未成功(受影响的行: 0)。&lt;/li&gt;
&lt;li&gt;事务B提交事务。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;第二种测试&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;6&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;T1&lt;/td&gt;
&lt;td&gt;select * from product p where p.productId = 1;(productCount=100)&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;T2&lt;/td&gt;
&lt;td&gt;update product p set p.productCount = 99,version=version+1 where p.productId = 1 and version = 1;(受影响的行: 1)&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;T3&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;select * from product p where p.productId = 1;(productCount=100)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;T4&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;update product p set p.productCount = 99,version=version+1 where p.productId = 1 and version = 1;(受影响的行: 0)&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;乐观锁小结&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;用户B修改数据的时候，受影响行数为0，对业务来说，及更新失败。这时候我们只需要告诉用户购买失败，重新查询一遍即可。&lt;/li&gt;
&lt;li&gt;对比第一种和第二种测试，我们会发现第一种测试，将update语句放入事务中会出现阻塞的情况，而第二种测试不会出现阻塞情况。这是为什么呢？update其实在不在事务中都无所谓，在内部是这样的：update是单线程的，及如果一个线程对一条数据进行update操作，会获得锁，其他线程如果要对同一条数据操作会阻塞，直到这个线程update成功后释放锁。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;乐观锁不需要数据库底层的支持！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;适用场景&quot;&gt;3. 适用场景&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;悲观锁&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;比较适合写入操作比较频繁的场景，如果出现大量的读取操作，每次读取的时候都会进行加锁，这样会增加大量的锁的开销，降低了系统的吞吐量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;乐观锁&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;比较适合读取操作比较频繁的场景，如果出现大量的写入操作，数据发生冲突的可能性就会增大，为了保证数据的一致性，应用层需要不断的重新获取数据，这样会增加大量的查询操作，降低了系统的吞吐量。&lt;/p&gt;
&lt;h2 id=&quot;文末&quot;&gt;文末&lt;/h2&gt;
&lt;p&gt;本章节主要简单介绍了数据库中&lt;code&gt;乐观锁与悲观锁&lt;/code&gt;的相关知识，后续我们将会继续介绍数据库中的其他锁以及相关知识。例如行锁、表锁、死锁、&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;欢迎关注公众号：&lt;strong&gt;Coder编程&lt;/strong&gt;&lt;br/&gt;获取最新原创技术文章和相关免费学习资料，随时随地学习技术知识！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;参考文章：&lt;/p&gt;
&lt;p&gt;https://chenzhou123520.iteye.com/blog/1860954&lt;/p&gt;
&lt;p&gt;https://chenzhou123520.iteye.com/blog/1863407&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/4/16/16a26835c75c12fc?w=300&amp;amp;h=390&amp;amp;f=png&amp;amp;s=18217&quot; alt=&quot;微信公众号&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;推荐阅读&quot;&gt;推荐阅读&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIwMTg3NzYyOA==&amp;amp;mid=2247483713&amp;amp;idx=1&amp;amp;sn=d61ad0aed42dc36d64d17732db352288&amp;amp;chksm=96e67052a191f9445bbe3d5825ce547ad3171c3874b571a93b97977d0668413e37a164c3e0bc&amp;amp;token=1144933717&amp;amp;lang=zh_CN#rd&quot;&gt;带你了解数据库中JOIN的用法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIwMTg3NzYyOA==&amp;amp;mid=2247483722&amp;amp;idx=1&amp;amp;sn=e8bc8bd82c559e0cfe7f35cf46100af3&amp;amp;chksm=96e67059a191f94fe8948e5b5e4ef177b77fa7707d86d945b153f67e7f2e76b83ed0c768ef27&amp;amp;token=128531458&amp;amp;lang=zh_CN#rd&quot;&gt;带你了解数据库中事务的ACID特性&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIwMTg3NzYyOA==&amp;amp;mid=2247483728&amp;amp;idx=1&amp;amp;sn=cdc5dc4708e48051e56b8e7d2a9fe5a8&amp;amp;chksm=96e67043a191f955b93e7228b88572beb486e6fac3308a1b69f5ee83c9e9ced6957e30b12d58&amp;amp;token=1787261466&amp;amp;lang=zh_CN#rd&quot;&gt;5分钟带你读懂事务隔离性与隔离级别&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 16 Apr 2019 14:25:00 +0000</pubDate>
<dc:creator>Coder编程</dc:creator>
<og:description>前言 在上一个章节 '5分钟带你读懂事务隔离性与隔离级别 ' 的最后，其实我们已经提到了锁的概念。本章节接下来将主要介绍以下数据库 的相关知识。如有错误还请大家及时指出~ 本文已同步至 'GitHub</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/coder-programming/p/10720524.html</dc:identifier>
</item>
<item>
<title>Dynamics 365 CRM 开发架构简介 - 氢氦</title>
<link>http://www.cnblogs.com/hhelibeb/p/10718080.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hhelibeb/p/10718080.html</guid>
<description>&lt;p&gt;Dynamics 365 CRM提供了多种编程模型，你可以灵活地按需选用最佳模式。&lt;/p&gt;
&lt;p&gt;本文是对Dynamics 365 CRM编程模型的综述。&lt;/p&gt;
&lt;h2&gt;概览&lt;/h2&gt;
&lt;p&gt;下图表明了Dynamics 365 CRM的主要可编程场景。请根据整体解决方案选择合适的模型。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/994049/201904/994049-20190416164223320-1161450035.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从扩展的角度来看，你可以在Dynamics 365中实现以下附加功能：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span class=&quot;h2title&quot;&gt;应用于PC或移动设备的控制台应用程序或者WPF（Windows Presentation Foundation），即图中上方.Net下的绿框。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;h2title&quot;&gt;&lt;span class=&quot;h2title&quot;&gt;处理Dynamics的Web表单的扩展，即图中右侧&lt;span class=&quot;h2title&quot;&gt;web application部分。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;h2title&quot;&gt;&lt;span class=&quot;h2title&quot;&gt;处理Dynamics服务端的扩展&lt;span class=&quot;h2title&quot;&gt;，即图中左侧&lt;span class=&quot;h2title&quot;&gt;.NET plug-ins和workflows下方的绿色方框。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;其中1和2属于客户端扩展，3属于服务端扩展。&lt;/p&gt;
&lt;h3&gt;名词解释&lt;/h3&gt;
&lt;p&gt;上图中的部分名词的基本概念。&lt;/p&gt;
&lt;p id=&quot;web-resource-types&quot; class=&quot;heading-with-anchor&quot;&gt;&lt;strong&gt;Web resources&lt;/strong&gt;：存储在Dynamics 365 CRM数据库中的虚拟文件，比如图片，网页，XML等，可以通过URL访问。&lt;/p&gt;
&lt;p class=&quot;heading-with-anchor&quot;&gt;&lt;strong&gt;Forms scripts&lt;/strong&gt;：Dynamics 365 CRM中的一种常见的Javascript应用方式，使用场景是通过自定义代码对表单输入内容校验、或进行其它自动化处理。（参考：&lt;a href=&quot;https://crmbook.powerobjects.com/extending-crm/javascript/#why_and_when&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;Form Scripts&lt;/strong&gt;&lt;/a&gt;）&lt;/p&gt;
&lt;p class=&quot;heading-with-anchor&quot;&gt;&lt;span class=&quot;st&quot;&gt;&lt;strong&gt;Ribbon commands&lt;/strong&gt;：Ribbon的的定义见&lt;a href=&quot;https://docs.microsoft.com/en-us/windows/desktop/uxguide/cmd-ribbons&quot; target=&quot;_blank&quot;&gt;微软文档&lt;/a&gt;，&lt;span class=&quot;st&quot;&gt;Ribbon commands是定义&lt;span class=&quot;st&quot;&gt;&lt;span class=&quot;st&quot;&gt;Ribbon的一种方式。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;heading-with-anchor&quot;&gt;&lt;span class=&quot;st&quot;&gt;&lt;span class=&quot;st&quot;&gt;&lt;span class=&quot;st&quot;&gt;&lt;span class=&quot;st&quot;&gt;&lt;strong&gt;Workflow&lt;/strong&gt;：通过&lt;span class=&quot;st&quot;&gt;&lt;span class=&quot;st&quot;&gt;&lt;span class=&quot;st&quot;&gt;&lt;span class=&quot;st&quot;&gt;Workflow&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;可以创建和管理自动化的业务过程，它也提供了定制和扩展标准流程的机制。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;heading-with-anchor&quot;&gt;&lt;span class=&quot;st&quot;&gt;&lt;span class=&quot;st&quot;&gt;&lt;span class=&quot;st&quot;&gt;&lt;span class=&quot;st&quot;&gt;&lt;strong&gt;Plug-ins&lt;/strong&gt;：一种事件处理程序，通过它可以修改或扩充标准的业务流程。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;heading-with-anchor&quot;&gt;&lt;span class=&quot;st&quot;&gt;&lt;span class=&quot;st&quot;&gt;&lt;span class=&quot;st&quot;&gt;&lt;span class=&quot;st&quot;&gt;&lt;strong&gt;Organization service&lt;/strong&gt;：客户端连接服务端的一种方式，适用于.Net客户端。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;heading-with-anchor&quot;&gt;&lt;span class=&quot;st&quot;&gt;&lt;span class=&quot;st&quot;&gt;&lt;span class=&quot;st&quot;&gt;&lt;span class=&quot;st&quot;&gt;&lt;span class=&quot;st&quot;&gt;&lt;span class=&quot;st&quot;&gt;&lt;span class=&quot;st&quot;&gt;&lt;span class=&quot;st&quot;&gt;&lt;strong&gt;Web API&lt;/strong&gt;：客户端连接服务端的一种方式，拥有良好的平台兼容性，适用于各种客户端。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Service Contracts&lt;/strong&gt;：Dynamics中的一种单据类型，这里和主旨无关。&lt;/p&gt;
&lt;p&gt;本文链接：&lt;a id=&quot;Editor_Edit_hlEntryLink&quot; title=&quot;view: Dynamics 365 CRM 开发架构简介&quot; href=&quot;https://www.cnblogs.com/hhelibeb/p/10718080.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/hhelibeb/p/10718080.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;转载请注明&lt;/p&gt;

&lt;h2&gt;连接到Dynamics 365 CRM&lt;/h2&gt;
&lt;p&gt;客户端要访问Dynamics 365 CRM中的数据，有2种方案可以选择：使用Web API或者organization service。&lt;/p&gt;
&lt;h3&gt;Web API&lt;/h3&gt;
&lt;p&gt;Web API在2016年11月的更新中被引入，它提供了跨编程语言、跨平台和跨设备的开发体验。Web API实现了&lt;a href=&quot;http://odata.org&quot; data-linktype=&quot;external&quot;&gt;OData&lt;/a&gt; (Open Data Protocol) v4。OData是一个用于构建和消费RESTfulAPIs的&lt;a href=&quot;https://en.wikipedia.org/wiki/OASIS_(organization)&quot; target=&quot;_blank&quot;&gt;OASIS&lt;/a&gt;标准。&lt;/p&gt;
&lt;p&gt;使用Web API时，可以选择&lt;a href=&quot;http://www.odata.org/libraries/&quot; target=&quot;_blank&quot;&gt;由社区支持的支持OData V4标准的库&lt;/a&gt;。你也可以选择写代码直接使用HTTP。&lt;/p&gt;
&lt;p&gt;相关内容：&lt;a href=&quot;https://docs.microsoft.com/zh-cn/dynamics365/customer-engagement/developer/use-microsoft-dynamics-365-web-api&quot; data-linktype=&quot;relative-path&quot;&gt;使用Dynamics 365 CRM Web API&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;连接Dynamics 365 CRM时，可以使用&lt;a href=&quot;https://azure.microsoft.com/documentation/articles/active-directory-authentication-libraries/&quot; data-linktype=&quot;external&quot;&gt;Azure AD Authentication Libraries (ADAL)&lt;/a&gt;以启用支持多语言/多平台的认证。&lt;/p&gt;
&lt;p&gt;相关内容：&lt;a href=&quot;https://docs.microsoft.com/zh-cn/dynamics365/customer-engagement/developer/webapi/authenticate-web-api&quot; data-linktype=&quot;relative-path&quot;&gt;通过Web API进行身份认证&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;organization-service&quot; class=&quot;heading-with-anchor&quot;&gt;Organization service&lt;/h3&gt;
&lt;p&gt;如果你是位.Net开发者，那么你既可以使用Web API，也可以使用organization service。通过organization service可以使用组件和工具生成强类型类，包含已经被添加到Dynamics 365 CRM实例中的自定义实体和属性。&lt;/p&gt;

&lt;p&gt;通过SDK组件和工具， 你可以使用&lt;a class=&quot;xref&quot; href=&quot;https://docs.microsoft.com/en-us/dotnet/api/microsoft.xrm.sdk.client.organizationservicecontext&quot; data-linktype=&quot;absolute-path&quot;&gt;OrganizationServiceContext&lt;/a&gt;，通过这个类可以跟踪变更、管理身份和关系。它也提供了访问Dynamics 365 CRM中的LINQ的入口。当你使用代码生成工具的时候，会得到当前已定义的实体和属性的强类型类，它们被称为&lt;strong&gt;早绑定&lt;/strong&gt;类（early-bound classes）。&lt;/p&gt;
&lt;p&gt;更多信息：&lt;a href=&quot;https://docs.microsoft.com/zh-cn/dynamics365/customer-engagement/developer/org-service/use-early-bound-entity-classes-code&quot; data-linktype=&quot;relative-path&quot;&gt;在代码中使用早绑定实体类&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;当代码需要处理生成代码时尚不知道的实体和属性时，你可以在代码中使用允许指定实体和属性的实体类。这种&lt;strong&gt;晚绑定&lt;/strong&gt;（late-bound）的代码风格提供了更大的灵活性，但是不允许完整的编译期类型检查，因此不会出现隐式转换。在晚绑定下，只有在对象创建或者对类型执行操作的时候才会检查类型。需要显示指定实体类的类型，以避免隐式转换。&lt;/p&gt;
&lt;p&gt;相关内容：&lt;a href=&quot;https://docs.microsoft.com/zh-cn/dynamics365/customer-engagement/developer/org-service/use-late-bound-entity-class-code&quot; data-linktype=&quot;relative-path&quot;&gt;在代码中使用晚绑定&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;如果要创建Windows客户端或者使用Windows PoweShell，可以使用Xrm.Tolling。它提供了一套API，通过使用SDK组件来提供额外的功能和资源，用于Windows客户端的开发。&lt;/p&gt;
&lt;p&gt;相关内容：&lt;a href=&quot;https://docs.microsoft.com/zh-cn/dynamics365/customer-engagement/developer/build-windows-client-applications-xrm-tools&quot; data-linktype=&quot;relative-path&quot;&gt;使用XRM工具创建Windows客户端应用&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;选择 - Web API vs. Organization service&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/994049/201904/994049-20190416215527364-1282146190.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注：organization service目前使用的是过时的2011 SOAP Endpoint，未来它的内部实现会迁移到Web API。&lt;/p&gt;
&lt;h2&gt;扩展服务端&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;tlid-translation translation&quot; lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;&quot;&gt;可以编写监听事件的代码，并应用自定义业务逻辑来修改或扩充平台的标准行为。 &lt;span title=&quot;&quot;&gt;这种代码仅可使用.NET托管代码编写，开发人员的体验基于SDK组件中定义的相同对象。你可以使用organization service操作Dynamics 365 CRM中的数据。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;tlid-translation translation&quot; lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;&quot;&gt;&lt;span title=&quot;&quot;&gt;相关信息： &lt;a href=&quot;https://docs.microsoft.com/zh-cn/dynamics365/customer-engagement/developer/write-plugin-extend-business-processes&quot; data-linktype=&quot;relative-path&quot;&gt;写插件来扩展业务处理&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;tlid-translation translation&quot; lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;&quot;&gt;&lt;span title=&quot;&quot;&gt;可以基于&lt;a href=&quot;https://msdn.microsoft.com/netframework/aa663328.aspx&quot; data-linktype=&quot;external&quot;&gt;Windows Workflow Foundation&lt;/a&gt;编程模型创建自定义流程。可以创建多种不同的处理，多数时候通过使用workflow设计器来实现功能。但是设计器有一些做不到的事情，此时可以通过代码来定义。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;tlid-translation translation&quot; lang=&quot;zh-CN&quot;&gt;&lt;span title=&quot;&quot;&gt;&lt;span title=&quot;&quot;&gt;相关信息：&lt;a href=&quot;https://docs.microsoft.com/zh-cn/dynamics365/customer-engagement/developer/automate-business-processes-customer-engagement&quot; data-linktype=&quot;relative-path&quot;&gt;写Workflow来自动化业务处理&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;扩展应用端&lt;/h2&gt;
&lt;p&gt;Dynamics 365 CRM提供的每个客户端应用都具备定制和部署到不同类型客户端的能力。Web应用、Dynamics 365 for Outlook、Dynamics 365 for 平板、and Dynamics 365 for 电话——都提供了自定义导航和命令的能力，也提供了Xrm对象模型和Xrm.Utility功能，可以通过使用Javascript为客户端提供响应式体验。&lt;/p&gt;
&lt;p&gt;在客户端中，可以通过URL访问Web resource，比如Javascript库、HTML页面、图像，或其它文件。&lt;/p&gt;
&lt;p&gt;相关内容：&lt;a href=&quot;https://docs.microsoft.com/zh-cn/dynamics365/customer-engagement/developer/use-javascript&quot; target=&quot;_blank&quot;&gt;在CRM app中使用Javascript&lt;/a&gt;，&lt;a href=&quot;https://docs.microsoft.com/zh-cn/dynamics365/customer-engagement/developer/web-resources&quot; data-linktype=&quot;relative-path&quot;&gt;Dynamics 365  CRM中的Web Resource&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;当你需要访问在Javascript上下文中不可用的Dynamics 365 CRM数据时，可以调用服务器获取数据。可以使用organization service，但使用JSON格式的Web API会比基于XML的organization service更简单，因为JS在应用上下文中运行，会自动获得身份认证。&lt;/p&gt;
&lt;p&gt;相关内容：&lt;a href=&quot;https://docs.microsoft.com/zh-cn/dynamics365/customer-engagement/developer/webapi/get-started-web-api-client-side-javascript&quot; data-linktype=&quot;relative-path&quot;&gt;Dynamics 365 CRM Web API入门 (客户端JavaScript)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;参考：&lt;a href=&quot;https://docs.microsoft.com/zh-cn/dynamics365/customer-engagement/developer/programming-models&quot; target=&quot;_blank&quot;&gt;Programming models for Dynamics 365 for Customer Engagement apps&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;           &lt;a href=&quot;https://www.apriorit.com/dev-blog/448-microsoft-dynamics-365-custom-extensions-and-data-import&quot; target=&quot;_blank&quot;&gt;Microsoft Dynamics 365: Custom Extensions and Data Import&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;           &lt;a href=&quot;https://crmbook.powerobjects.com/extending-crm/javascript/#why_and_when&quot; target=&quot;_blank&quot;&gt;JavaScript and HTML Resources&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 16 Apr 2019 14:08:00 +0000</pubDate>
<dc:creator>氢氦</dc:creator>
<og:description>Dynamics 365 CRM提供了多种编程模型，你可以灵活地按需选用最佳模式。 本文是对Dynamics 365 CRM编程模型的综述。 概览 下图表明了Dynamics 365 CRM的主要可编</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hhelibeb/p/10718080.html</dc:identifier>
</item>
<item>
<title>面试的反杀-你有没有想要问我的 - stoneFang</title>
<link>http://www.cnblogs.com/stoneFang/p/10720160.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/stoneFang/p/10720160.html</guid>
<description>&lt;p&gt;前一段时候脉脉上有个段子&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;面试官问候选人什么时候红黑树，候选人答不太熟悉，不知道具体怎么实现的，最后面试官问候选人有什么想问他的。候选人问面试官什么是红黑树，面试官支支吾吾了半天，最后说太久了，都忘了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不知道是不是真的，但是面试结束的时候，面试官通常会问下候选人 &lt;code class=&quot;prettyprint code-in-text prettyprinted&quot;&gt;&lt;span class=&quot;pun&quot;&gt;你有没有想要问我的&lt;/span&gt;&lt;/code&gt;，今天结合我自己的面试和被面试的经历聊聊这个话题。&lt;/p&gt;

&lt;p&gt;我换个两份工作，社招过2次。我对我问的问题印象很深刻，为什么呢，因为问的都是自己之前公司缺少的，想在下家公司获得的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一家&lt;/strong&gt; 因为第一份工作团队人员流失率非常高，作为一个工作1年的人就得扛起大旗，每走一个人，意味着留给我的坑又多了许多。所以导致本来明明是一家养老公司，我却天天在加班。所以面试时我问的永远只有1条&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&lt;span class=&quot;pun&quot;&gt;   这个&lt;span class=&quot;pln&quot;&gt;hc&lt;span class=&quot;pun&quot;&gt;是什么原因空出来的，我将要入职的团队稳定吗?&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二家&lt;/strong&gt; 第二家公司团队真的很稳定，但是因为是美资世界五百强，做的事情没有什么挑战性，始终觉得技术没有得到施展，发挥应有的价值。所以面试时我的问题就是&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&lt;span class=&quot;pun&quot;&gt;   这个工作有没有挑战性？公司的发展空间有多大？&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;等我入职后我发现像我这么问有问题，因为把前公司好的一面都丢到了，来到新公司，难免会比较，如果新公司没有之前公司的优点，我想要的新的期望又不突出，那么在新公司待的就比较痛苦了。&lt;/p&gt;

&lt;p&gt;在&lt;a href=&quot;https://fangzhang.blog.csdn.net/article/details/88908060&quot;&gt;最近招聘java高级工程师的几点感想&lt;/a&gt;一文中提到过我们招聘的几点要求&lt;/p&gt;
&lt;ol class=&quot;linenums&quot;&gt;&lt;li class=&quot;L0&quot;&gt;&lt;code&gt;&lt;span class=&quot;lit&quot;&gt;1. &lt;span class=&quot;pln&quot;&gt;java &lt;span class=&quot;pun&quot;&gt;基础要好，有&lt;span class=&quot;pln&quot;&gt;OO&lt;span class=&quot;pun&quot;&gt;思想&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li class=&quot;L0&quot;&gt;&lt;code&gt;&lt;span class=&quot;lit&quot;&gt;&lt;span class=&quot;pln&quot;&gt; &lt;span class=&quot;pun&quot;&gt;分布式要有一定了解，能基本匹配公司技术栈&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li class=&quot;L0&quot;&gt;&lt;code&gt;&lt;span class=&quot;lit&quot;&gt;&lt;span class=&quot;pln&quot;&gt; &lt;span class=&quot;pun&quot;&gt;熟悉线上问题排查手段，了解稳定性保障常用方法&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li class=&quot;L0&quot;&gt;&lt;code&gt;&lt;span class=&quot;lit&quot;&gt;&lt;span class=&quot;pln&quot;&gt; &lt;span class=&quot;pun&quot;&gt;对技术有一定追求，有一定潜力&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;第四点听上去比较虚，不好考量。但其实作为技术面试官，还是会在交流过程中能够识别出来对技术是否有追求的，其中最后一问也可以考察到这个。&lt;/p&gt;
&lt;p&gt;总结一下我收到的常见的几类问题&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;无所谓型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;业务技术型&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;假如我进去后，负责的业务是什么&lt;/li&gt;
&lt;li&gt;公司目前技术栈是什么&lt;/li&gt;
&lt;li&gt;团队怎么样&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这种是务实型，个人比较喜欢的小伙伴，如果业务/技术/团队都问到了，并且在我回答过程中能够有更进一步的交流时，就更加分了。比如&lt;/p&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;我之前了解过你们这块业务，发现你们主要做的是XXX，我认为他很有价值，但是我个人觉得可以更近一步XXX。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;你们的技术栈和我们的有点区别，我可能在某某方面比较欠缺，不过根据我之前做XX的经验，我觉得我学习一段时间应该很快能上手。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;寻求反馈型&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;您对我这次的面试评价是什么&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;从面试过程中，您觉得我的优点是什么，不足在什么地方&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这种属于成熟机灵型，个人比较喜欢。这种候选人一般是面试经验丰富而且善于总结。另外比较机灵吧，因为面试结果一般是不允许现场给出的，需要和用人经理沟通综合考虑决定过不过的。所以这种问题算是巧妙的避开了直接反馈的。&lt;/p&gt;
&lt;p&gt;我的回答一般是还不错，然后客观点评，先说好的，再说不足。一般不轻易透露喜好，和结果。除非是觉得你非常的不错，我会毫不吝惜的说 &lt;code class=&quot;prettyprint code-in-text prettyprinted&quot;&gt;&lt;span class=&quot;pun&quot;&gt;我觉得你非常不错，&lt;span class=&quot;pln&quot;&gt;bla&lt;span class=&quot;pun&quot;&gt;,&lt;span class=&quot;pln&quot;&gt;bla&lt;span class=&quot;pun&quot;&gt;，从各个方面都很适合我们这个岗位。不过我这只是一/二面，后面还有几轮面试，希望你继续加油&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;或者如果我想争取你来，博得你的好感，我也会指出你的不足，然后提到我们团队有这方面经验，能够帮助你弥补这块的空缺。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;反杀型&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;你刚才问我的那道题答案是什么&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;不知道是不是因为脉脉那个段子带火了还是怎么回事，反杀型的问我的越来越多了。虽然只要候选人问了，我都会回答他，从我个人来说，从来没有问过我自己不知道答案的问题。&lt;/p&gt;
&lt;p&gt;但是从我个人角度来说不是很喜欢这种问题。为什么呢？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;问的时机不对，面试的过程不是你问我答，是交流的过程，如果当时问这个问题的时候，你不知道，我一般会提醒你从哪些角度思考，如果提醒还不知道，会再问相关的问题，如果都不知道，就会一个类型题目问，比如问了你数据库相关的，你基本都不知道，就会换着问java相关的。所以这个问题应该在面试过程中问，而不是结束的时候问&lt;/li&gt;
&lt;li&gt;一般面试java高级工程师的问题，都是比较系统化的，由点到面的。如果你不知道，说明在某方面缺失了，需要自己面试完去总结，查找资料。而不是直接去问到答案。&lt;/li&gt;
&lt;li&gt;跟风，抖机灵。面试是一个严肃的过程，是双方相互考察的机会，短短几十分钟的时间很珍贵，应当多呈现一些你自己独特的一面，经过思考的问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其实最后一问，并没有特别重要，属于锦上添花型。如果你前面面试的时候表现优秀，不会因为这个问题答的不好把你pass掉； 如果你前面表现不好，也不会因为这个问题答的好让你过。 但是你可以利用这个问题，问到你想要了解关于公司的问题。不妨假如自己已经成功入职了这家公司，你对这家公司，有什么期待，你对自己的未来规划有什么打算，这家公司具备什么样的条件能够满足你的期望。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190414123311685.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mYW5nemhhbmcuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 16 Apr 2019 13:29:00 +0000</pubDate>
<dc:creator>stoneFang</dc:creator>
<og:description>摘要 前一段时候脉脉上有个段子 面试官问候选人什么时候红黑树，候选人答不太熟悉，不知道具体怎么实现的，最后面试官问候选人有什么想问他的。候选人问面试官什么是红黑树，面试官支支吾吾了半天，最后说太久了，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/stoneFang/p/10720160.html</dc:identifier>
</item>
</channel>
</rss>