<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>DRF比Django的认证和权限高在哪里 - dongfanger</title>
<link>http://www.cnblogs.com/df888/p/14161813.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/df888/p/14161813.html</guid>
<description>&lt;p&gt;Django可以用&lt;code&gt;LoginRequiredMixin&lt;/code&gt;和&lt;code&gt;PermissionRequiredMixin&lt;/code&gt;给类视图添加认证和权限，DRF做了高级封装，提供了更简洁的实现方式。我们通过继续学习官网教程来进行了解。&lt;/p&gt;

&lt;p&gt;首先修改&lt;code&gt;Snippet&lt;/code&gt;模型，添加2个字段：&lt;code&gt;owner&lt;/code&gt;，存储snippet创建者，&lt;code&gt;highlighted&lt;/code&gt;，存储高亮HTML。同时重写&lt;code&gt;save&lt;/code&gt;方法，在同步数据库的时候，使用&lt;code&gt;pygments&lt;/code&gt;包把&lt;code&gt;code&lt;/code&gt;格式化后存到&lt;code&gt;highlighted&lt;/code&gt;字段。修改后的&lt;code&gt;snippets/models.py&lt;/code&gt;完整代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from django.db import models
from pygments.lexers import get_all_lexers
from pygments.styles import get_all_styles
from pygments.lexers import get_lexer_by_name
from pygments.formatters.html import HtmlFormatter
from pygments import highlight

LEXERS = [item for item in get_all_lexers() if item[1]]
LANGUAGE_CHOICES = sorted([(item[1][0], item[0]) for item in LEXERS])
STYLE_CHOICES = sorted([(item, item) for item in get_all_styles()])


class Snippet(models.Model):
    created = models.DateTimeField(auto_now_add=True)
    title = models.CharField(max_length=100, blank=True, default='')
    code = models.TextField()
    linenos = models.BooleanField(default=False)
    language = models.CharField(choices=LANGUAGE_CHOICES, default='python', max_length=100)
    style = models.CharField(choices=STYLE_CHOICES, default='friendly', max_length=100)
    owner = models.ForeignKey('auth.User', related_name='snippets', on_delete=models.CASCADE)
    highlighted = models.TextField()

    class Meta:
        ordering = ['created']

    def save(self, *args, **kwargs):
        &quot;&quot;&quot;
        Use the `pygments` library to create a highlighted HTML
        representation of the code snippet.
        &quot;&quot;&quot;
        lexer = get_lexer_by_name(self.language)
        linenos = 'table' if self.linenos else False
        options = {'title': self.title} if self.title else {}
        formatter = HtmlFormatter(style=self.style, linenos=linenos,
                                  full=True, **options)
        self.highlighted = highlight(self.code, lexer, formatter)
        super(Snippet, self).save(*args, **kwargs)

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接着删除数据库和&lt;code&gt;migrations&lt;/code&gt;，重新迁移数据库：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;rm -f db.sqlite3
rm -r snippets/migrations
python manage.py makemigrations snippets
python manage.py migrate
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;并创建超级管理员：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;python manage.py createsuperuser
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;Endpoint，表示API的具体网址。我们按照&lt;code&gt;models.py&lt;/code&gt;→&lt;code&gt;serializers.py&lt;/code&gt;→&lt;code&gt;views.py&lt;/code&gt;→&lt;code&gt;urls.py&lt;/code&gt;的代码编写顺序，给User模型添加Endpoint。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;models.py&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;直接使用Django默认User模型，不需要修改代码。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;serializers.py&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;添加&lt;code&gt;UserSerializer&lt;/code&gt;，由于User没有&lt;code&gt;snippets&lt;/code&gt;字段，所以需要显式添加：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from django.contrib.auth.models import User

class UserSerializer(serializers.ModelSerializer):
    snippets = serializers.PrimaryKeyRelatedField(many=True, queryset=Snippet.objects.all())

    class Meta:
        model = User
        fields = ['id', 'username', 'snippets']
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;views.py&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;添加只读的列表视图&lt;code&gt;UserList&lt;/code&gt;和详情视图&lt;code&gt;UserDetail&lt;/code&gt;，分别用到了&lt;code&gt;ListAPIView&lt;/code&gt;和&lt;code&gt;RetrieveAPIView&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from django.contrib.auth.models import User
from snippets.serializers import UserSerializer


class UserList(generics.ListAPIView):
    queryset = User.objects.all()
    serializer_class = UserSerializer


class UserDetail(generics.RetrieveAPIView):
    queryset = User.objects.all()
    serializer_class = UserSerializer
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;urls.py&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;添加访问路径：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;path('users/', views.UserList.as_view()),
path('users/&amp;lt;int:pk&amp;gt;/', views.UserDetail.as_view()),
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;如果使用POST方法请求&lt;code&gt;http://127.0.0.1:8000/snippets/&lt;/code&gt;，尝试添加1条数据：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202012/1629545-20201220085506702-56728604.png&quot; alt=&quot;image-20201219145940635&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;会发现接口报错了：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202012/1629545-20201220085509923-1752186033.png&quot;/&gt;&lt;/center&gt;
&lt;p&gt;owner_id不能为空？因为前面只给&lt;code&gt;Snippet&lt;/code&gt;添加了&lt;code&gt;owner&lt;/code&gt;字段，还没有写反序列化更新模型的代码，所以通过请求访问视图，再尝试反序列化的时候，报错了。我们先修改视图&lt;code&gt;SnippetList&lt;/code&gt;来修复这个问题：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;def perform_create(self, serializer):
    serializer.save(owner=self.request.user)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在&lt;code&gt;SnippetList&lt;/code&gt;视图中重写&lt;code&gt;perform_create()&lt;/code&gt;方法，意思是在保存时，把&lt;code&gt;request.user&lt;/code&gt;值赋给&lt;code&gt;owner&lt;/code&gt;字段。&lt;code&gt;perform_create()&lt;/code&gt;方法的源码是：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;class CreateModelMixin:
    &quot;&quot;&quot;
    Create a model instance.
    &quot;&quot;&quot;
    def create(self, request, *args, **kwargs):
        serializer = self.get_serializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        self.perform_create(serializer)
        headers = self.get_success_headers(serializer.data)
        return Response(serializer.data, status=status.HTTP_201_CREATED, headers=headers)

    def perform_create(self, serializer):
        serializer.save()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再修改&lt;code&gt;snippets/serializers.py&lt;/code&gt;，添加&lt;code&gt;owner&lt;/code&gt;字段，支持序列化：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;class SnippetSerializer(serializers.ModelSerializer):
    # ReadOnlyField表示只能序列化为JSON，不能反序列化更新模型
    # 也可以改成CharField(read_only=True)
    owner = serializers.ReadOnlyField(source='owner.username')

    class Meta:
        model = Snippet
        fields = ['id', 'title', 'code', 'linenos', 'language', 'style', 'owner']

&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注意Meta.fields也要加上&lt;code&gt;owner&lt;/code&gt;哦。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;再请求一次：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202012/1629545-20201220085507102-191082781.png&quot; alt=&quot;image-20201219151728225&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;刚才的错误没有了，但是报了个新的错误：&lt;code&gt;Snippet.owner&lt;/code&gt;必须是&lt;code&gt;User&lt;/code&gt;实例，给它赋值的是&lt;code&gt;AnonymousUser&lt;/code&gt;（匿名用户），导致ValueError了。这个报错是发生这条代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;serializer.save(owner=self.request.user)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也就是说请求访问视图后，进行反序列化了，但是反序列化失败了。非常奇怪！我们的请求中并没有用户信息，正常来说在访问视图的时候就该被拦截了。&lt;/p&gt;

&lt;p&gt;我们需要让API更符合常规，让未认证的用户不能执行视图中的代码。DRF提供了&lt;code&gt;rest_framework .permissions&lt;/code&gt;来给视图添加认证：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202012/1629545-20201220085510236-1962183111.png&quot;/&gt;&lt;/center&gt;
&lt;p&gt;其中&lt;code&gt;IsAuthenticatedOrReadOnly&lt;/code&gt;表示只有认证了才能读写，否则只能读。把它添加到&lt;code&gt;SnippetList&lt;/code&gt;和&lt;code&gt;SnippetDetail&lt;/code&gt;视图中：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from rest_framework import permissions

permission_classes = [permissions.IsAuthenticatedOrReadOnly]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再请求试试，刚才的错误没有了，API返回的是需要提供用户凭证：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202012/1629545-20201220085507380-263609294.png&quot; alt=&quot;image-20201219160601041&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;如果用浏览器打开&lt;code&gt;http://127.0.0.1:8000/snippets/&lt;/code&gt;，会发现只有GET方法没有POST，这是因为需要添加DRF登录视图，在&lt;code&gt;tutorial/urls.py&lt;/code&gt;中添加&lt;code&gt;rest_framework.urls&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;urlpatterns += [
    path('api-auth/', include('rest_framework.urls')),
]
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;api-auth/可以自定义。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;刷新页面右上角就会出现&lt;code&gt;Log in&lt;/code&gt;按钮，登录后就能POST了。&lt;/p&gt;

&lt;p&gt;为了更细粒度的控制权限，让用户只能编辑自己创建的&lt;code&gt;snippet&lt;/code&gt;，新建&lt;code&gt;snippets/permissions.py&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from rest_framework import permissions


class IsOwnerOrReadOnly(permissions.BasePermission):
    &quot;&quot;&quot;
    Custom permission to only allow owners of an object to edit it.
    &quot;&quot;&quot;

    def has_object_permission(self, request, view, obj):
        # Read permissions are allowed to any request,
        # so we'll always allow GET, HEAD or OPTIONS requests.
        if request.method in permissions.SAFE_METHODS:
            return True

        # Write permissions are only allowed to the owner of the snippet.
        return obj.owner == request.user
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;新增&lt;code&gt;IsOwnerOrReadOnly&lt;/code&gt;权限，继承了&lt;code&gt;permissions.BasePermission&lt;/code&gt;，重写了&lt;code&gt;has_object_permission()&lt;/code&gt;方法。接着在&lt;code&gt;snippets/views.py&lt;/code&gt;中给&lt;code&gt;SnippetDetail&lt;/code&gt;加上：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from snippets.permissions import IsOwnerOrReadOnly


permission_classes = [permissions.IsAuthenticatedOrReadOnly,
                      IsOwnerOrReadOnly]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;试下访问其他用户创建的&lt;code&gt;snippet&lt;/code&gt;，发现只能查看：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202012/1629545-20201220085507689-652116533.png&quot; alt=&quot;image-20201219180310509&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;访问自己创建的&lt;code&gt;snippet&lt;/code&gt;，可以修改和删除：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202012/1629545-20201220085508095-2099010933.png&quot; alt=&quot;image-20201219180516850&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;以上是官网的示例，我在Postman测试了下，发现超管dongfanger可以创建&lt;code&gt;snippet&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202012/1629545-20201220085508507-227071889.png&quot; alt=&quot;image-20201219152719121&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;普通用户player也可以创建&lt;code&gt;snippet&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202012/1629545-20201220085508911-686423342.png&quot; alt=&quot;image-20201219153118906&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我想让普通用户不能创建，只能超管创建。仿照官网示例，在&lt;code&gt;snippets/permissions.py&lt;/code&gt;中添加&lt;code&gt;IsAdminOrReadOnly&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;class IsAdminOrReadOnly(permissions.BasePermission):
    def has_permission(self, request, view):
        return request.user.is_superuser
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接着给&lt;code&gt;SnippetList&lt;/code&gt;加上：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;permission_classes = [permissions.IsAuthenticatedOrReadOnly,
                      IsAdminOrReadOnly]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;用普通用户尝试创建，提示没有权限：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202012/1629545-20201220085509319-581369982.png&quot; alt=&quot;image-20201219181059751&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;用超级管理员尝试创建，成功：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202012/1629545-20201220085509643-353762766.png&quot; alt=&quot;image-20201219181537178&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;本文使用的认证方式是默认的&lt;code&gt;SessionAuthentication&lt;/code&gt;和&lt;code&gt;BasicAuthentication&lt;/code&gt;，只要数据库的用户名、密码和请求中的用户凭证（用户名、密码）匹配上了，就认为认证成功。如果要实现token或jwt认证，需要使用到&lt;code&gt;rest_framework.authentication&lt;/code&gt;：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202012/1629545-20201220085510535-1245091642.png&quot;/&gt;&lt;/center&gt;
&lt;p&gt;或&lt;code&gt;rest_framework_jwt.authentication&lt;/code&gt;：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202012/1629545-20201220085510782-975408109.png&quot;/&gt;&lt;/center&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;pip install djangorestframework-jwt&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这一部分内容官网教程中并没有提及，等我们把教程学完了，以后再找时间来介绍。&lt;/p&gt;

&lt;p&gt;DRF实现认证和权限的关键在于新增&lt;code&gt;permissions.py&lt;/code&gt;模块，编写class，继承&lt;code&gt;permissions.BasePermission&lt;/code&gt;，重写&lt;code&gt;has_permission()&lt;/code&gt;或&lt;code&gt;has_object_permission()&lt;/code&gt;方法，再添加class到类视图的&lt;code&gt;permission_classes&lt;/code&gt;中。这块的内容比Django的认证系统那套简洁，但是有点混淆，另外我之前参照网上实现了一版JWT，也有点不一样。看来还得写篇对比的文章才行。&lt;/p&gt;
&lt;blockquote readability=&quot;0.83333333333333&quot;&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.django-rest-framework.org/tutorial/4-authentication-and-permissions/&quot; target=&quot;_blank&quot;&gt;https://www.django-rest-framework.org/tutorial/4-authentication-and-permissions/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sun, 20 Dec 2020 00:56:00 +0000</pubDate>
<dc:creator>dongfanger</dc:creator>
<og:description>Django可以用LoginRequiredMixin和PermissionRequiredMixin给类视图添加认证和权限，DRF做了高级封装，提供了更简洁的实现方式。我们通过继续学习官网教程来进行</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/df888/p/14161813.html</dc:identifier>
</item>
<item>
<title>WinForm引用ActiveX组件，对Com组件的学习 - XSpringSun</title>
<link>http://www.cnblogs.com/SunSpring/p/14157251.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/SunSpring/p/14157251.html</guid>
<description>&lt;p&gt;工作中写WinForm程序经常会引用第三方的组件，包括引用Com组件，做了一个桌面程序需要展示PDF，看了些其它的开源组件对PDF的兼容性都不是很好，有些看着PDF是正常的但是复制出来的字有很多乱码。然后就直接引用了adboe pdf reader来显示，测试了不同pdf兼容性算是不错的。那如何引用呢？&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li&gt;
&lt;p&gt;在工具栏选择项&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/993045/202012/993045-20201218214610373-242246603.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;添加Com组件&lt;br/&gt;找到Adobe PDF Reader勾选，然后点击确定之后组件就被添加到工具箱里面了。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/993045/202012/993045-20201218214712940-1166550684.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;使用Com组件&lt;br/&gt;新建一个窗体或者用户控件，将刚才添加的Adobe PDF Reader 组件拖入到窗体中就可以像winform控件一样操作该控件了。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/993045/202012/993045-20201218214738910-1313327100.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在该窗体类中生成了一个AxAcroPDFLib.AxAcroPDF的控件，进入该控件类可以看到控件类对外提供的方法，包括用于加载显示pdf的 LoadFile 方法，gotoFirstPage 等翻页的方法。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/993045/202012/993045-20201218214847343-116146995.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/993045/202012/993045-20201218214854713-807390809.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而该控件有一个父类AxHost类，进入Axhost类有一个摘要：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;包装 ActiveX 控件，并将它们作为功能完整的 Windows 窗体控件公开&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对此我陷入了沉思，ActiveX控件到底是什么，com组件如何被使用，AxAxAcroPDFLib.AxAcroPDF类是如何生成的，Winform和Com如何互操作？于是我进行了一番资料查找和学习。&lt;/p&gt;

&lt;p&gt;ActiveX控件技术基于由COM，可连接对象，复合文档，属性页，OLE自动化，对象持久性以及系统提供的字体和图片对象组成的基础。&lt;br/&gt;控件本质上是一个COM对象，它公开IUnknown接口，客户端可以通过该对象获取指向其其他接口的指针。控件可以通过IClassFactory2和自我注册来支持许可。&lt;br/&gt;也就是说ActiveX控件是基于COM对象的，使用COM技术让不同语言编写的控件可以进行互相调用，而如何编写ActiveX控件呢，可以使用ATL 和 MFC，但是两个我都没使用过！并且没编写过，所以我就略过，只先了解其概念。既然它是基于COM，那接下来看看COM是什么东东。&lt;/p&gt;

&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;Microsoft组件对象模型（COM）定义了一个二进制互操作性标准，用于创建在运行时进行交互的可重用软件库。您可以使用COM库，而无需将其编译到应用程序中。COM是许多Microsoft产品和技术（例如Windows Media Player和Windows Server）的基础。&lt;br/&gt;COM定义了适用于许多操作系统和硬件平台的二进制标准。对于网络计算，COM为在不同硬件平台上运行的对象之间的交互定义了标准的有线格式和协议。COM独立于实现语言，这意味着您可以使用其他编程语言（例如C ++和.NET Framework中的编程语言）创建COM库。&lt;br/&gt;COM规范提供了支持跨平台软件重用的所有基本概念：&lt;br/&gt;组件之间的函数调用的二进制标准。&lt;br/&gt;将功能强类型分组到接口中的规定。&lt;br/&gt;提供多态性，功能发现和对象生存期跟踪的基本接口。&lt;br/&gt;唯一标识组件及其接口的机制。&lt;br/&gt;组件加载器，可从部署中创建组件实例。&lt;br/&gt;COM具有多个部分，这些部分可以一起工作以创建由可重用组件构建的应用程序：&lt;br/&gt;一个主机系统提供了一个运行时环境符合的COM规范。&lt;br/&gt;定义要素合同的接口和实现接口的组件。&lt;br/&gt;为系统提供组件的服务器，以及使用组件提供的功能的客户端。&lt;br/&gt;一个注册表，用于跟踪组件在本地和远程主机上的部署位置。&lt;br/&gt;一个服务控制管理器，可以在本地和远程主机上找到组件，并将服务器连接到客户端。&lt;br/&gt;一种结构化的存储协议，它定义了如何导航主机文件系统上文件的内容。&lt;br/&gt;跨主机和平台启用代码重用对于COM至关重要。可重用的接口实现被称为组件，组件对象或COM对象。组件实现一个或多个COM接口。&lt;br/&gt;您可以通过设计库实现的接口来定义自定义COM库。图书馆的使用者可以发现和使用其功能，而无需了解图书馆的部署和实施细节。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这是官方的定义，当然还有很多细节说明可以看看&lt;a href=&quot;https://docs.microsoft.com/zh-cn/windows/win32/com/com-technical-overview&quot; target=&quot;_blank&quot;&gt;https://docs.microsoft.com/zh-cn/windows/win32/com/com-technical-overview&lt;/a&gt; 其中包括实现的定义和方式，对象和接口、接口实现、IUnknown接口等等。&lt;/p&gt;
&lt;p&gt;那是如何实现如何调用呢，引用一段有趣的概括性的描述：&lt;/p&gt;
&lt;p&gt;COM主要是一套给C/C++用的接口，当然为了微软的野心，它也被推广到了VB、Delphi以及其他一大堆奇奇怪怪的平台上。它主要为了使用dll发布基于interface的接口。我们知道dll的接口是为了C设计的，它导出的基本都是C的函数，从原理上来说，将dll加载到内存之后，会告诉你一组函数的地址，你自己call进去就可以调用相应的函数。&lt;br/&gt;但是对于C++来说这个事情就头疼了，现在假设你有一个类，我们知道使用一个类的第一步是创建这个类：new MyClass()。这里直接就出问题了，new方法通过编译器计算MyClass的大小来分配相应的内存空间，但是如果库升级了，相应的类可能会增加新的成员，大小就变了，那么使用旧的定义分配出来的空间就不能在新的库当中使用。&lt;br/&gt;要解决这问题，我们必须在dll当中导出一个CreateObject的方法，用来代替构造函数，然后返回一个接口。然而，接口的定义在不同版本当中也是有可能会变化的，为了兼容以前的版本同时也提供新功能，还需要让这个对象可以返回不同版本的接口。接口其实是一个只有纯虚函数的C++类，不过对它进行了一些改造来兼容C和其他一些编程语言。&lt;br/&gt;在这样改造之后，出问题的还有析构过程~MyClass()或者说delete myClass，因为同一个对象可能返回了很多个接口，有些接口还在被使用，如果其中一个被人delete了，其他接口都会出错，所以又引入了引用计数，来让许多人可以共享同一个对象。&lt;br/&gt;其实到此为止也并不算是很奇怪的技术，我们用C++有的时候也会使用Factory方法来代替构造函数实现某些特殊的多态，也会用引用计数等等。COM技术的奇怪地方在于微软实在是脑洞太大了，它们构造了一个操作系统级别的Factory，规定所有人的Interface都统一用UUID来标识，以后想要哪个Interface只要报出UUID来就行了。这样甚至连链接到特定的dll都省了。&lt;br/&gt;这就好比一个COM程序员，只要他在Windows平台上，调用别的库就只要首先翻一下魔导书，查到了一个用奇怪文字写的“Excel = {xxx-xxx-xxxx...}”的记号，然后它只要对着空中喊一声：“召唤，Excel！CoCreateInstance, {xxx-xxx-xxxx...}”&lt;br/&gt;然后呼的从魔法阵里面窜出来了一个怪物，它长什么样我们完全看不清，因为这时候它的类型是IUnknow，这是脑洞奇大无比的微软为所有接口设计的一个基类。我们需要进一步要求它变成我们能控制的接口形态，于是我们再喊下一条指令：&lt;br/&gt;“变身，Excel 2003形态！QueryInterface, {xxx-xxx-xxxx...}”&lt;br/&gt;QueryInterface使用的是另一个UUID，用来表示不同版本的接口。于是怪物就变成了我们需要的Excel 2003接口，虽然我们不知道它实际上是2003还是2007还是更高版本。&lt;br/&gt;等我们使唤完这只召唤兽，我们就会对它说“回去吧，召唤兽！Release！”但是它不一定听话，因为之前给它的命令也许还没有执行完，它会忠诚地等到执行完再回去，当然我们并不关心这些细节。(引用地址：&lt;a href=&quot;https://www.zhihu.com/question/49433640&quot; target=&quot;_blank&quot;&gt;https://www.zhihu.com/question/49433640&lt;/a&gt;)&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/993045/202012/993045-20201218215738708-1383327861.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从这个概括理解，所有的COM类其实都继承了IUnknown,当我们拿到IUnknown接口后还需要转成我们需要使用的类型，而这个类型如果用强转可能会出错，但是微软认为，直接由用户来转型是不安全的需要唯一的一个标识符来确定一个类，那么这个标识符就是GUID。类ID就叫作&lt;strong&gt;CLSID&lt;/strong&gt;，接口ID就叫作&lt;strong&gt;IID&lt;/strong&gt;,还需要一个转型的函数叫QueryInterface。QueryInterface作为IUnknown中的一个纯虚函数，做的事情其实很简单，判断自己能不能转成某个GUID所指向的类而已。如果不可以，则返回E_NOTIMPL，可以的话返回S_OK，并将转换后的指针作为参数返回。&lt;br/&gt;COM组件并不需要名字，或者说不需要UUID，因为我们总是使用他里面的接口，而不是直接使用COM组件，所以接口也要UUID。说了这么多，COM架构这么复杂，肯定需要一个中间层，或者说摆渡人，这就是&lt;strong&gt;COM Library&lt;/strong&gt;（一堆dll） + 注册表。A应用通知COM Library，并输入接口的UUID,由COM Library装入B应用的该组件对应的dll，并把接口指针返回给A应用，指针里指示的是一堆函数指针，由这些指针，可以调用到B应用里的函数功能。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;注：上面有时说的UUID,有时说的GUDI,UUID即是GUID值。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;有了上面的ActiveX控件和Com组件的介绍，我们再回到开始我们如何导入的ActiveX控件。&lt;br/&gt;ActiveX 控件导入程序将 ActiveX 控件的 COM 类型库中的类型定义转换为 Windows 窗体控件。&lt;br/&gt;Windows 窗体只能承载 Windows 窗体控件，即从 Control 派生的类。 Aximp.exe 生成可承载于 Windows 窗体上的 ActiveX 控件的包装器类。 这使你得以使用适用于其他 Windows 窗体控件的同一设计时支持和编程方法。&lt;br/&gt;若要承载 ActiveX 控件，必须生成从 AxHost 派生的包装器控件。 此包装器控件包含基础 ActiveX 控件的一个实例。 它知道如何与 ActiveX 控件通信，但它显示为 Windows 窗体控件。 这个生成的控件承载 ActiveX 控件并将其属性、方法和事件作为生成的控件的属性、方法和事件公开。&lt;br/&gt;&lt;strong&gt;由此可见当我们再工具箱里面选择添加com组件后实际隐含执行了该导入程序，为我们生成了对应的AxAcroPDFLib.AxAcroPDF包装器控件。而AxAcroPDFLib则如同第三点中讲的那样就是COM Library。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;既然AxAcroPDFLib 是摆渡人(&lt;strong&gt;互操作程序集&lt;/strong&gt;) 那么我们可以看到这个COM Library的引用&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/993045/202012/993045-20201218220207488-1963425885.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;有了互操作程序那么这个互操作程序必然是去调用COM组件，调用COM组件那么UUID呢？将这个程序集放到Dnspy反编译可以看到在ClsidAttribute标记有{ca8a9780-280d-11cf-a24d-444553540000}，构造函数里面有UUID。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/993045/202012/993045-20201218220232665-1291396374.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后我们打开注册表查询下对应的值和注册表的情况。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/993045/202012/993045-20201218220241921-484545330.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/993045/202012/993045-20201218220303541-88165590.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;所以通过上面的概念了解和猜想验证，基本清楚了com的设计和想法，以及ActiveX控件的调用过程。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Activex控件时COM实现的一种方式。&lt;/li&gt;
&lt;li&gt;Activex控件通过VS工具引用时调用了Aximp.exe 。&lt;/li&gt;
&lt;li&gt;Aximp.exe程序生成了互操作程序集AxAcroPDFLib，同时生成可承载于 Windows 窗体上的 ActiveX 控件的从 AxHost 派生的包装器控件。&lt;/li&gt;
&lt;li&gt;调用AxAcroPDF方法时通过com组件调用引用控件的功能。&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Sun, 20 Dec 2020 00:24:00 +0000</pubDate>
<dc:creator>XSpringSun</dc:creator>
<og:description>1、WinForm引用Adobe PDF Reader 工作中写WinForm程序经常会引用第三方的组件，包括引用Com组件，做了一个桌面程序需要展示PDF，看了些其它的开源组件对PDF的兼容性都不是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/SunSpring/p/14157251.html</dc:identifier>
</item>
<item>
<title>c语言实现一些简单图形的打印 - guguguhuha</title>
<link>http://www.cnblogs.com/guguguhuha/p/14162498.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/guguguhuha/p/14162498.html</guid>
<description>&lt;p&gt; &lt;span class=&quot;cnblogs_code&quot;&gt;1 #define _CRT_SECURE_NO_WARNINGS 1 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;因为笔者采用的是VS的编译环境所以有了上面的这一句话&lt;/p&gt;
&lt;p&gt;我们都知道平面图形是由一条条线段构成，所以我们就先实现线段的打印&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 1 //打印自定义长度的线段
 2 #include&amp;lt;stdio.h&amp;gt;
 3 int&lt;span&gt; main()
 4 &lt;span&gt;{
 5     int i = 0&lt;span&gt;;
 6     int&lt;span&gt; n;
 7     while (~scanf(&quot;%d&quot;, &amp;amp;&lt;span&gt;n))
 8 &lt;span&gt;    {
 9         for (i = 0; i &amp;lt; n; i++&lt;span&gt;)
10             printf(&quot;* &quot;&lt;span&gt;);
11         printf(&quot;\n&quot;&lt;span&gt;);
12 &lt;span&gt;    }
13     return 0;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2230905/202012/2230905-20201219231634228-1491177197.png&quot; alt=&quot;运行结果&quot; width=&quot;92&quot; height=&quot;95&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么，线段学会了，我们就可以进行简单图形的打印了&lt;/p&gt;
&lt;p&gt;首先我们从正方形开始：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
 1 //打印自定义边长的正方形
 2 #include&amp;lt;stdio.h&amp;gt;
 3 int&lt;span&gt; main()
 4 &lt;span&gt;{
 5     int j = 0, i = 0&lt;span&gt;;
 6     int&lt;span&gt; n;
 7     while (~scanf(&quot;%d&quot;, &amp;amp;&lt;span&gt;n))
 8 &lt;span&gt;    {
 9         for (i = 0; i &amp;lt; n; i++)//控制行
10 &lt;span&gt;        {
11             for (j = 0; j &amp;lt; n; j++)//控制列
12                 printf(&quot;* &quot;&lt;span&gt;);
13             printf(&quot;\n&quot;&lt;span&gt;);
14 &lt;span&gt;        }
15 &lt;span&gt;    }
16     return 0&lt;span&gt;;
17 }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2230905/202012/2230905-20201219232007859-1922539875.png&quot; alt=&quot;运行结果&quot; width=&quot;53&quot; height=&quot;151&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 接下来是三角形：（笔者准备了六种三角形）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
  1 //打印三角形—1
  2 #include&amp;lt;stdio.h&amp;gt;
  3 int&lt;span&gt; main()
  4 &lt;span&gt;{
  5     int j = 0, i = 0&lt;span&gt;, n;
  6     while (~scanf(&quot;%d&quot;, &amp;amp;&lt;span&gt;n))
  7 &lt;span&gt;    {
  8         for (j = 0; j &amp;lt; n; j++)//行
  9 &lt;span&gt;        {
 10             for (i = 0; i &amp;lt; n - j; i++)//列
 11 &lt;span&gt;            {
 12                 printf(&quot;* &quot;&lt;span&gt;);
 13 &lt;span&gt;            }
 14             printf(&quot;\n&quot;&lt;span&gt;);
 15 &lt;span&gt;        }
 16 &lt;span&gt;    }
 17     return 0&lt;span&gt;;
 18 &lt;span&gt;}
 19  
 20 //打印三角形—2
 21 #include&amp;lt;stdio.h&amp;gt;
 22 int&lt;span&gt; main()
 23 &lt;span&gt;{
 24     int j = 0, i = 0&lt;span&gt;, n;
 25     while (~scanf(&quot;%d&quot;, &amp;amp;&lt;span&gt;n))
 26 &lt;span&gt;    {
 27         for (j = 0; j &amp;lt; n; j++)//行
 28 &lt;span&gt;        {
 29             for (i = 0; i &amp;lt;= j; i++)//列
 30 &lt;span&gt;            {
 31                 printf(&quot;* &quot;&lt;span&gt;);
 32 &lt;span&gt;            }
 33             printf(&quot;\n&quot;&lt;span&gt;);
 34 &lt;span&gt;        }
 35 &lt;span&gt;    }
 36     return 0&lt;span&gt;;
 37 &lt;span&gt;}
 38 
 39 //打印三角形—3
 40 #include&amp;lt;stdio.h&amp;gt;
 41 int&lt;span&gt; main()
 42 &lt;span&gt;{
 43     int j = 0, i = 0&lt;span&gt;, n;
 44     while (~scanf(&quot;%d&quot;, &amp;amp;&lt;span&gt;n))
 45 &lt;span&gt;    {
 46         for (j = 0; j &amp;lt; n; j++)//行
 47 &lt;span&gt;        {
 48             for (i = 0; i &amp;lt; n - j - 1; i++)//列
 49 &lt;span&gt;            {
 50                 printf(&quot;  &quot;&lt;span&gt;);
 51 &lt;span&gt;            }
 52             for (i = 0; i &amp;lt;= j; i++&lt;span&gt;)
 53 &lt;span&gt;            {
 54                 printf(&quot;* &quot;&lt;span&gt;);
 55 &lt;span&gt;            }
 56             printf(&quot;\n&quot;&lt;span&gt;);
 57 &lt;span&gt;        }
 58 &lt;span&gt;    }
 59     return 0&lt;span&gt;;
 60 &lt;span&gt;}
 61 
 62 //打印三角形—4
 63 #include&amp;lt;stdio.h&amp;gt;
 64 int&lt;span&gt; main()
 65 &lt;span&gt;{
 66     int j = 0, i = 0&lt;span&gt;, n;
 67     while (~scanf(&quot;%d&quot;, &amp;amp;&lt;span&gt;n))
 68 &lt;span&gt;    {
 69         for (j = 0; j &amp;lt; n; j++)//行
 70 &lt;span&gt;        {
 71             for (i = 0; i &amp;lt; j ; i++)//列
 72 &lt;span&gt;            {
 73                 printf(&quot;  &quot;&lt;span&gt;);
 74 &lt;span&gt;            }
 75             for (i = 0; i &amp;lt; n - j ; i++&lt;span&gt;)
 76 &lt;span&gt;            {
 77                 printf(&quot;* &quot;&lt;span&gt;);
 78 &lt;span&gt;            }
 79             printf(&quot;\n&quot;&lt;span&gt;);
 80 &lt;span&gt;        }
 81 &lt;span&gt;    }
 82     return 0&lt;span&gt;;
 83 &lt;span&gt;}
 84 
 85 //打印三角形—5
 86 #include&amp;lt;stdio.h&amp;gt;
 87 int&lt;span&gt; main()
 88 &lt;span&gt;{
 89     int j = 0, i = 0&lt;span&gt;, n;
 90     while (~scanf(&quot;%d&quot;, &amp;amp;&lt;span&gt;n))
 91 &lt;span&gt;    {
 92         for (j = 0; j &amp;lt; n; j++)//行
 93 &lt;span&gt;        {
 94             for (i = 0; i &amp;lt;= n - j ; i++)//列
 95 &lt;span&gt;            {
 96                 printf(&quot; &quot;&lt;span&gt;);
 97 &lt;span&gt;            }
 98             for (i = 0; i &amp;lt;= j; i++&lt;span&gt;)
 99 &lt;span&gt;            {
100                 printf(&quot;* &quot;&lt;span&gt;);
101 &lt;span&gt;            }
102             printf(&quot;\n&quot;&lt;span&gt;);
103 &lt;span&gt;        }
104 &lt;span&gt;    }
105     return 0&lt;span&gt;;
106 &lt;span&gt;}
107 
108 //打印三角形—6
109 #include&amp;lt;stdio.h&amp;gt;
110 int&lt;span&gt; main()
111 &lt;span&gt;{
112     int j = 0, i = 0&lt;span&gt;, n;
113     while (~scanf(&quot;%d&quot;, &amp;amp;&lt;span&gt;n))
114 &lt;span&gt;    {
115         for (j = 0; j &amp;lt; n; j++)//行
116 &lt;span&gt;        {
117             for (i = 0; i &amp;lt; j; i++)//列
118 &lt;span&gt;            {
119                 printf(&quot; &quot;&lt;span&gt;);
120 &lt;span&gt;            }
121             for (i = 0; i &amp;lt; n - j; i++&lt;span&gt;)
122 &lt;span&gt;            {
123                 printf(&quot;* &quot;&lt;span&gt;);
124 &lt;span&gt;            }
125             printf(&quot;\n&quot;&lt;span&gt;);
126 &lt;span&gt;        }
127 &lt;span&gt;    }
128     return 0&lt;span&gt;;
129 }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/2230905/202012/2230905-20201219232309685-239055025.png&quot; alt=&quot;&quot; width=&quot;155&quot; height=&quot;284&quot; loading=&quot;lazy&quot;/&gt;  &lt;img src=&quot;https://img2020.cnblogs.com/blog/2230905/202012/2230905-20201219232358765-291830942.png&quot; alt=&quot;&quot; width=&quot;102&quot; height=&quot;276&quot; loading=&quot;lazy&quot;/&gt;   &lt;img src=&quot;https://img2020.cnblogs.com/blog/2230905/202012/2230905-20201219232454633-783100765.png&quot; alt=&quot;&quot; width=&quot;164&quot; height=&quot;265&quot; loading=&quot;lazy&quot;/&gt;   &lt;img src=&quot;https://img2020.cnblogs.com/blog/2230905/202012/2230905-20201219232545739-2065484395.png&quot; alt=&quot;&quot; width=&quot;139&quot; height=&quot;288&quot; loading=&quot;lazy&quot;/&gt;   &lt;img src=&quot;https://img2020.cnblogs.com/blog/2230905/202012/2230905-20201219232642245-403048080.png&quot; alt=&quot;&quot; width=&quot;179&quot; height=&quot;276&quot; loading=&quot;lazy&quot;/&gt;   &lt;img src=&quot;https://img2020.cnblogs.com/blog/2230905/202012/2230905-20201219232728388-1800619514.png&quot; alt=&quot;&quot; width=&quot;121&quot; height=&quot;266&quot; loading=&quot;lazy&quot;/&gt; &lt;/p&gt;


&lt;p&gt;现在就可以尝试一下图形的挖空了&lt;/p&gt;
&lt;p&gt;我们仍然保持之前的顺序从正方形到三角形：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
//空心正方形
#include&amp;lt;stdio.h&amp;gt;
int&lt;span&gt; main()
{
    int j = 0,i=0&lt;span&gt;;
    int&lt;span&gt; n;
    while (~scanf(&quot;%d&quot;, &amp;amp;&lt;span&gt;n))
    {
        for (j = 0; j &amp;lt; n; j++&lt;span&gt;)
        {
            for (i = 0; i &amp;lt; n; i++&lt;span&gt;)
            {
                if (j == 0 || i==0 ||j==n-1 || i==n-1&lt;span&gt;)
                    printf(&quot;* &quot;&lt;span&gt;);
                else&lt;span&gt;
                    printf(&quot;  &quot;&lt;span&gt;);
            }
            printf(&quot;\n&quot;&lt;span&gt;);
        }
    }
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
 1 //空心三角形
 2 #include&amp;lt;stdio.h&amp;gt;
 3 int&lt;span&gt; main()
 4 &lt;span&gt;{
 5     int&lt;span&gt; n;
 6     int i = 0, j = 0&lt;span&gt;;
 7     while (~scanf(&quot;%d&quot;, &amp;amp;&lt;span&gt;n))
 8 &lt;span&gt;    {
 9         for (i = 0; i &amp;lt; n; i++&lt;span&gt;)
10 &lt;span&gt;        {
11             for (j = 0; j &amp;lt;= i; j++&lt;span&gt;)
12 &lt;span&gt;            {
13                 if (j == 0 || i == j || i==n-1&lt;span&gt; )
14                     printf(&quot;* &quot;&lt;span&gt;);
15                 else
16                     printf(&quot;  &quot;&lt;span&gt;);
17 &lt;span&gt;            }
18                 
19             printf(&quot;\n&quot;&lt;span&gt;);
20 &lt;span&gt;        }
21 &lt;span&gt;    }
22 }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2230905/202012/2230905-20201219233415804-422094753.png&quot; alt=&quot;&quot; width=&quot;104&quot; height=&quot;231&quot; loading=&quot;lazy&quot;/&gt;   &lt;img src=&quot;https://img2020.cnblogs.com/blog/2230905/202012/2230905-20201219233500607-391712948.png&quot; alt=&quot;&quot; width=&quot;109&quot; height=&quot;218&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 那么我们可以从以上知识尝试一下自己打出一个菱形以及空心菱形&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
 1 #define _CRT_SECURE_NO_WARNINGS 1
 2 #include&amp;lt;stdio.h&amp;gt;
 3 #include&amp;lt;math.h&amp;gt;
 4 int&lt;span&gt; main()
 5 &lt;span&gt;{
 6     int i = 0, j = 0&lt;span&gt;;
 7     int&lt;span&gt; n;
 8     while (~scanf(&quot;%d&quot;, &amp;amp;&lt;span&gt;n))//在这的n我们必须保证是奇数
 9 &lt;span&gt;    {
10         for (i = 0; i &amp;lt; n; i++&lt;span&gt;)
11 &lt;span&gt;        {
12             for (j = 0; j &amp;lt; abs(n / 2 - i); j++&lt;span&gt;)
13                 printf(&quot; &quot;&lt;span&gt;);
14             for (j = 0; j &amp;lt; n - 2 * abs(n / 2 - i); j++&lt;span&gt;)
15                 printf(&quot;*&quot;&lt;span&gt;);
16             printf(&quot;\n&quot;&lt;span&gt;);
17 &lt;span&gt;        }
18 &lt;span&gt;    }
19     return 0;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;为了更好的理解，笔者微微修改了以上代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
#define _CRT_SECURE_NO_WARNINGS 1&lt;span&gt;
#include&amp;lt;stdio.h&amp;gt;&lt;span&gt;
#include&amp;lt;math.h&amp;gt;&lt;span&gt;
#include&amp;lt;Windows.h&amp;gt;
int&lt;span&gt; main()
{
    int i = 0, j = 0&lt;span&gt;;
    int&lt;span&gt; n;
    while (~scanf(&quot;%d&quot;, &amp;amp;&lt;span&gt;n))
    {
        for (i = 0; i &amp;lt; n; i++&lt;span&gt;)
            printf(&quot;%2d&quot;&lt;span&gt;,i);
        printf(&quot;\n&quot;&lt;span&gt;);
        for (i = 0; i &amp;lt; n; i++&lt;span&gt;)
        {
            
            for (j = 0; j &amp;lt; abs(n / 2 - i); j++&lt;span&gt;)
            {
                printf(&quot;  &quot;&lt;span&gt;);
                Sleep(100&lt;span&gt;);
            }
            for (j = 0; j &amp;lt; n - 2 * abs(n / 2 - i); j++&lt;span&gt;)
            {
                printf(&quot;* &quot;&lt;span&gt;);
                Sleep(100&lt;span&gt;);
            }
            printf(&quot;\n&quot;&lt;span&gt;);
            Sleep(100&lt;span&gt;);
        }
    }
    return 0&lt;span&gt;;
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此外在提供一个打印菱形的代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;68&quot;&gt;
&lt;p align=&quot;left&quot;&gt;#include&amp;lt;stdio.h&amp;gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;int main()&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;{&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;    int i, j, n;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;    {&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;         while (~scanf(&quot;%d&quot;, &amp;amp;n))&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;         {//上边部分&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;             for (i = 0; i &amp;lt; n; i++)&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;             {&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;                 for (j = i; j &amp;lt; n - 1; j++)&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;                      printf(&quot; &quot;);&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;                 for (j = 0; j &amp;lt; 2 * i + 1; j++)&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;                      printf(&quot;*&quot;);&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;                 printf(&quot;\n&quot;);&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;             }&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;             for (i = n - 2; i &amp;gt;= 0; i--) //这里i从n-2开始的，要是从n-1开始会出现两行相同的情况&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;             {&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;                 for (j = i; j &amp;lt; n - 1; j++)&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;                      printf(&quot; &quot;);&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;                 for (j = 0; j &amp;lt; 2 * i + 1; j++)&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;                      printf(&quot;*&quot;);&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;                 printf(&quot;\n&quot;);&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;             }//下边部分&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;         }&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;         return 0;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;    }&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;}&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;当然，肯定要在这给几个笔者参考过的文章&lt;/p&gt;
&lt;p&gt;参考&lt;a target=&quot;_blank&quot;&gt; https://blog.csdn.net/marwi_study/article/details/88749427?utm_source=app&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在这笔者再提供一个由字符组成的三角形 &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
#include&amp;lt;stdio.h&amp;gt;

int&lt;span&gt; main()
{
    int i, j, n, k = 0&lt;span&gt;;
    char ch = 'A'&lt;span&gt;;
    printf(&quot;请输入行数:&quot;&lt;span&gt;);
    scanf(&quot;%d&quot;, &amp;amp;&lt;span&gt;n);
    for (i = 0; i &amp;lt; n; i++&lt;span&gt;)
    {
        for (j = 0; j &amp;lt; 2*(n-i)-1; j++&lt;span&gt;)
        {
            k++&lt;span&gt;;
            if (k % 2 != 0&lt;span&gt;)
            {
                printf(&quot;%c&quot;, ch++&lt;span&gt;);
            }
            else&lt;span&gt;
                printf(&quot;%c&quot;&lt;span&gt;, ch);
        }
        printf(&quot;\n&quot;&lt;span&gt;);
    }
    return 0&lt;span&gt;;
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2230905/202012/2230905-20201219235557746-2038537723.png&quot; alt=&quot;&quot; width=&quot;122&quot; height=&quot;108&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后可以大家可以尝试一下自己打印空心菱形以及由字符构成的图形&lt;/p&gt;

</description>
<pubDate>Sun, 20 Dec 2020 00:03:00 +0000</pubDate>
<dc:creator>guguguhuha</dc:creator>
<og:description>1&amp;#160;#define&amp;#160;_CRT_SECURE_NO_WARNINGS 1 因为笔者采用的是VS的编译环境所以有了上面的这一句话 我们都知道平面图形是由一条条线段构成，所以我们就先实现</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/guguguhuha/p/14162498.html</dc:identifier>
</item>
<item>
<title>嵌入式开发笔记——调试组件SEGGER_RTT - zzssdd2</title>
<link>http://www.cnblogs.com/zzssdd2/p/14162382.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zzssdd2/p/14162382.html</guid>
<description>&lt;p&gt;在嵌入式开发过程中，经常会通过打印输出一些调试信息来调试参数、查找问题等，通常我的做法都是使用芯片的串口硬件设备配合串口助手软件来进行调试。但是这次项目的PCB硬件设计并未预留串口调试接口，所以想使用串口调试就不方便了。经过查找资料发现&lt;strong&gt;Segger&lt;/strong&gt; 提供了一种非常方便的调试方式——自家的&lt;code&gt;J-Link&lt;/code&gt;硬件配合&lt;code&gt;J-Link RTT Viewer&lt;/code&gt;软件进行信息输入输出调试。&lt;/p&gt;

&lt;p&gt;要使用该调试组件，需要添加Segger提供的SEGGER_RTT组件代码，该代码位于J-Link软件安装目录下，而且在用户手册中提供了详细的说明。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;组件源码位置：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2193174/202012/2193174-20201220012547505-1278875697.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;用户手册位置：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2193174/202012/2193174-20201220012600923-78502058.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在手册的16章节对RTT组件进行了说明：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2193174/202012/2193174-20201220012611159-469197709.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;将组件源码复制到工程目录下，工程中添加相关文件及包含路径：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2193174/202012/2193174-20201220012622239-208762045.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后在需要使用打印调试信息的文件中包含&lt;code&gt;#include &quot;SEGGER_RTT.h&quot;&lt;/code&gt;头文件就可以使用该组件了。&lt;/p&gt;

&lt;p&gt;关于组件提供的各API函数在手册中都有相应的说明。举例应用如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输出测试：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;int a = 3;
SEGGER_RTT_TerminalOut(0,RTT_CTRL_BG_BLACK&quot;&quot;RTT_CTRL_TEXT_BRIGHT_GREEN&quot;SEGGER_RTT_TerminalOut 0\r\n&quot;);
SEGGER_RTT_TerminalOut(1,RTT_CTRL_BG_BLUE&quot;&quot;RTT_CTRL_TEXT_BRIGHT_YELLOW&quot;SEGGER_RTT_TerminalOut 1\r\n&quot;);
SEGGER_RTT_SetTerminal(2);
SEGGER_RTT_printf(0,RTT_CTRL_BG_WHITE&quot;&quot;RTT_CTRL_TEXT_BRIGHT_BLACK&quot;SEGGER_RTT_printf 2\r\n&quot;);
SEGGER_RTT_SetTerminal(3);
SEGGER_RTT_printf(0,&quot;SEGGER_RTT_printf %d\r\n&quot;, a);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;打开&lt;code&gt;J-Link RTT Viewer&lt;/code&gt;软件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2193174/202012/2193174-20201220012647436-72055555.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;RTT Viewer打印结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2193174/202012/2193174-20201220012658495-1273453009.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入测试:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;int a;

while(1)
{
    if ((a = SEGGER_RTT_WaitKey()) &amp;gt; 0) 
    {
        SEGGER_RTT_SetTerminal(0);
        SEGGER_RTT_printf(0, &quot;SEGGER_RTT_GetKey = %c\r\n&quot;, a);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;RTT Viewer打印结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2193174/202012/2193174-20201220012712136-977651510.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;经过上面对SEGGER_RTT的使用，发现其确实非常的方便，大多数调试都能够替代串口调试实现了，但是&lt;code&gt;SEGGER_RTT_printf()&lt;/code&gt;函数无法打印浮点数。手册中对该函数列出了支持的转换说明符如下：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Conversion specifier&lt;/th&gt;
&lt;th&gt;Meaning&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;6&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;c&lt;/td&gt;
&lt;td&gt;Print the argument as one char&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;d&lt;/td&gt;
&lt;td&gt;Print the argument as a signed integer&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;u&lt;/td&gt;
&lt;td&gt;Print the argument as an unsigned integer&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;Print the argument as an hexadecimal integer&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;s&lt;/td&gt;
&lt;td&gt;Print the string pointed to by the argument&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;p&lt;/td&gt;
&lt;td&gt;Print the argument as an 8-digit hexadecimal integer. (Argument shall be a pointer to void.)&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;其中并没有浮点数&lt;code&gt;f&lt;/code&gt;选项。但是可以使用SEGGER_RTT输出函数自己修改一个printf函数，这样就可以使用完整的printf函数了。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;添加自己修改的printf函数如下：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;/*********************************************************************
*
*       rtt_printf()
*
*  Function description
*    print a formatted string using RTT and standard library formatting.
**********************************************************************/
int rtt_printf(const char *fmt,...) 
{
  int     n;
  char    aBuffer[256]; //根据应用需求调整大小
  va_list args;

  va_start (args, fmt);
  n = vsnprintf(aBuffer, sizeof(aBuffer), fmt, args);
  if (n &amp;gt; (int)sizeof(aBuffer)) {
    SEGGER_RTT_Write(0, aBuffer, sizeof(aBuffer));
  } else if (n &amp;gt; 0) {
    SEGGER_RTT_Write(0, aBuffer, n);
  }
  va_end(args);
  return n;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;接下来测试浮点数打印：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;double fa = 0.1f;
double fb = 2.0f;

while(1)
{
    fa += 0.0001f;
    fb -= 0.0002f;
    rtt_printf(&quot;floating test:\tfa = %f, fb = %f\r\n&quot;, fa, fb);
    delay(0x0fffffff);
} 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2193174/202012/2193174-20201220012727855-2104058030.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 19 Dec 2020 17:30:00 +0000</pubDate>
<dc:creator>zzssdd2</dc:creator>
<og:description>一、前言 在嵌入式开发过程中，经常会通过打印输出一些调试信息来调试参数、查找问题等，通常我的做法都是使用芯片的串口硬件设备配合串口助手软件来进行调试。但是这次项目的PCB硬件设计并未预留串口调试接口，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zzssdd2/p/14162382.html</dc:identifier>
</item>
<item>
<title>抢先看：笔者亲历的2020年中国.NET开发者大会活动纪实 - 溪源More</title>
<link>http://www.cnblogs.com/xiyuanMore/p/netconfchina2020.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiyuanMore/p/netconfchina2020.html</guid>
<description>&lt;h3 id=&quot;1&quot;&gt;1&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/191302/202012/191302-20201220011459844-1728985616.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2020年12月19日的苏州工业园区，天公作美，阳光明媚，气象迷人，正是一个搞事的好日子。在这里，数百名中国.NET开发者们汇聚一堂，怀揣着激情和梦想，一起参加了第二次中国.NET开发者大会。溪源有幸全程参与今天的活动，并很荣幸的在此记下本次活动的盛况。&lt;/p&gt;
&lt;p&gt;这次活动虽然受疫情影响，线下活动的规模可能稍微小一些，但大家的热情丝毫未减。在活动现场，有几十位专家为大家带来了四十多场围绕.NET主题的技术分享，涵盖云/.NET 5/企业级开发框架/微服务架构/人工智能和物联网等多个领域，满满干货吸引了共有约400人出席了本次活动，还有约10万人次通过互联网在线直播的形式，在CSDN和思否两个平台观看了本次活动的直播。&lt;/p&gt;
&lt;p&gt;本次活动也吸引了许多优秀企业带来赞助，微软、明源云、葡萄城、朝夕教育等多家公司提供的赞助，为社区活动的成功举办提供了充足的弹药，而CSDN和思否提供了直播技术支持，还有许多技术社群的参与，也为社区的成功举办立下的汗马功劳。&lt;/p&gt;
&lt;h3 id=&quot;2&quot;&gt;2&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/191302/202012/191302-20201220011515653-167669879.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/191302/202012/191302-20201220011536299-2086223062.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;本次活动9点半开始，当笔者于8点40左右到达现场时，现场签到处就已经排起了长龙，虽然大家都带好了口罩，但大家脸上都洋溢着对本次活动的美好期待。而9点半活动开始后，更是可以看到，会场已经座无虚席，后排还站满了前来学技术的优秀开发者。&lt;/p&gt;
&lt;p&gt;活动的出品人、盛派网络总经理兼首席架构师苏震巍老师兼任本次活动的主持人，他也邀请到苏州优秀的RPA企业数字力量公司的.NET开发兼RPA商务总监宁静宁总一起联袂主持，并邀请了一系列嘉宾到场致辞。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/191302/202012/191302-20201220011550233-1986246573.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;3&quot;&gt;3&lt;/h3&gt;
&lt;p&gt;首先带来致辞的是苏州工业园区科信局周村局长，周局长首先介绍了苏州工业园区优越的地理位置和政策条件，以及近年来在改善营商环境上做出的业绩，以及在国际国内赢得的良好的口碑，吸引了许多优秀的IT企业再次设立总部、分部或研发中心，也吸引了微软这样优秀的国际巨头。&lt;br/&gt;他也感谢微软在技术社区的贡献，相信在大家的参与下，.NET这种技术也将为苏州的经济发展带来新的动力。作为一位政府领导，周局长也对.NET这种技术的优越性进行了赞扬，他认为.NET技术也是一门先进的技术体系，能够吸引如此多开发者来的苏州工业园区，将有利于为苏州园区打造更好的品牌形象。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/191302/202012/191302-20201220011611346-140292723.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;随后，微软全渠道事业部的CTO徐明强博士为大家做了一个题为《.NET 应您所想的开发平台》，从.NET生态动力、.NET在全球影响力、中国.NET社区和.NET5的技术提升等多个方面微软近年来在.NET5和开源生态上做出的努力。&lt;/p&gt;
&lt;p&gt;徐博士也是一位多年经验的资深开发者，加入微软将近20年，他幽默风趣的提到，自己学过从C/C++/Python/VB/Java等各种语言，但C#语言的魅力一直让他着迷。他提到了微软近年来致力于打造更好的开发平台，让天下没有难写的代码。他也指出，如果没有与时俱进，最终会被开发者淘汰。在过去的若干年，.NET技术由于未开源，曾经逐渐的失去了光环，但随着微软的战略转型，随着开始拥抱开源，已经让.NET这种技术，又开始焕发出新的光芒，在全球的开发者数量已经突破五百万人，其中每年有23万开发者是新加入.NET Core的开发者，每月通过Visual Studio实现项目发布的次数，也突破了200万次。&lt;/p&gt;
&lt;p&gt;他重点提到了.NET 5的许多新特性，例如许多新功能和性能改善，以及一组数据，都说明.NET技术的性能丝毫不亚于其他语言。最后，他也提到了.NET的长期发展规划，并希冀开发者们对.NET充满信心，.NET大有可为！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/191302/202012/191302-20201220011640453-2062734605.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第三位带来致辞的是微软大中华区Azure事业部总经理，林家伟林总，他的演讲主题为《Together,Invovate More》,这也是2021年微软社区推广的口号，通过大家的共同努力，探索更多可能。在他的演讲中，他邀请了两位重量级人物给大会准备的vcr。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/191302/202012/191302-20201220011657911-1482842917.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一位是微软全球资深副总裁&lt;em&gt;潘正磊&lt;/em&gt;(Julia Liuson)潘总给大会致辞，潘总说中国.NET社区的兴起，也正在给.NET技术带来着新的希望，而微软也正在把大家的希望变成可能。在.NET Core开源的过去六年间，.NET技术迎来了蜕变，短短六年时间，开发者规模逐渐递增，新的开发者也在不断的加入，使得.NET正在成为新鲜和强大的技术力量。&lt;br/&gt;除了微软在不断的为.NET注入动力外，由于开源的魅力，使得更多的开发者也在共同助力.NET生态的健全，例如NCC社区，盛派开发者社区，龙芯社区等，他们的贡献使得.NET的开发门槛越来越低。潘总深信.NET的前景非常广阔。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/191302/202012/191302-20201220011711385-225743901.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;林总邀请的带来VCR的另外一位嘉宾是Scott Hutter，也是.NET项目的项目经理，Scott用一句中文【祝中国.NET社区大会圆满成功】引起了.NET5的各项新特性和功能改进，让大家对.NET5有了更加深入的了解。&lt;br/&gt;林总在他的致辞最后，引用了微软的使命【予力全球每个人，每个组织成就不凡】，让全场的气氛到达了一个高潮。&lt;/p&gt;
&lt;h3 id=&quot;4&quot;&gt;4&lt;/h3&gt;
&lt;p&gt;在各位领导致辞之后，就是干活满满的技术分享时间，上午场邀请了两家具有代表性的企业给大家带来分享。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/191302/202012/191302-20201220011735529-388621714.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先上台分享的是龙芯CLR和JVM负责人敖琪敖博士，敖琪博士从龙芯、龙芯的产品体系介绍开始，讲到龙芯目前已经支持的各大平台，并提到了从去年开始，龙芯开始将CLR当作一个非常重点的项目在跟进。从2019年5月开始调研，需求，工作量和风险缝隙，版本选择，到8月构建成功，10月输出第一个hello world，再到今天，终于得以输出了一个Release版本，算是取得了阶段性的成果。&lt;/p&gt;
&lt;p&gt;当前的.NET Core是基于.NET Core3.1进行构建，已经支持了该版本具备的所有功能，性能于x64/arm64相当，并提供长期支持，而且最大的特点是完全开源，感兴趣的开发者还能通过龙芯的提供的开源仓库地址，自行编译，了解该版本的实际情况。&lt;/p&gt;
&lt;p&gt;随后，他介绍了龙芯.NET Core的构建过程，例如，如何构建源码，如果进行通过测试用例，共提交了多少行代码，改进了多少工作，使得大家对龙芯.NET Core有了更深的认识。敖博士最后提到了该.NET Core的未来计划，也希望.NET的应用开发者能够积极了解底层技术，从Clr等底层平台中获取更多土壤，也将有利于我们更好掌握.NET这种优秀的技术。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/191302/202012/191302-20201220011838935-2063222906.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;随后给大家带来分享的是来自葡萄城科技的高级架构师王鸿先生，王先生首先从葡萄城的公司发展史开始介绍，他风趣的跟全场开发者说，葡萄城并非一家卖葡萄酒的电商公司或葡萄园，而是一家拥有扎实技术实力的优秀公司。公司成立一直致力于为企业赋能，专注于企业级控件领域，开发出许多优秀的产品，给开发者们带来了许多便利。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/191302/202012/191302-20201220011901270-8869336.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在本次分享中，他重点介绍了他在研发的电子表格组件过程中，总结的几点对.NET代码性能优化的几点建议，包括减少垃圾回收的影响，共享对象提升性能，压缩数据降低内存，充分利用高速缓存等方式。全场内容干货满满，通过一个个鲜活的示例代码+时间对比，让大家对相关主题形成了非常深刻的认识。&lt;/p&gt;
&lt;p&gt;尤其是在第一个建议，仅仅将object改成double，将class改成值类型的struct，就能通过减少装箱拆箱成本、减少gc成本，带来性能优化，使在场的开发者都获得了不少启发。而后面的示例，他也介绍了如何通过改善数据结构、改善循环体的方式来提升性能，这些策略也都是简单易用的策略，无不充满了资深开发者的智慧。&lt;/p&gt;
&lt;p&gt;最后，他提到了其他策略，例如，创建cache，注意异常带来的性能影响，利用span类型和静态变量等避免频繁申请内存，利用SIMD计算大量数据，基于集合的操作运算，利用多线程提升并发能力等策略，当然，由于时间关系，这些策略未能一一细化，但相信也能带给许多机智的开发者不少触动。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/191302/202012/191302-20201220011922326-1254093607.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上午的最后一位分享嘉宾是人称张队长的张善友老师，他也是连续15年的MVP，深圳友浩达科技有限公司CTO，并成为了.NET基金会的会员。他分享的题材主要是.NET 5和.NET未来，他从.NET 5的重要更新，.NET的未来发展，.NET是一个统一的平台等多个方面，给大家介绍了.NET 5的现状，为.NET开发者做了一次全面的.NET技术普及。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/191302/202012/191302-20201220011939159-1296384575.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;5&quot;&gt;5&lt;/h3&gt;
&lt;p&gt;上午场结束后，下午场也是同样精彩的技术主题分享，这次共有约40场各种类型主题，分在4个会场进行，溪源有幸聆听了A会场的部分分享。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/191302/202012/191302-20201220011954210-982780487.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;溪源首先聆听的是本次大会出品人、主持人、东道主苏震巍老师分享的NCF框架，这是从盛派业务系统中孵化出来的一款优秀的开源框架，它集模块化，快速易用，多环境迁移，支持容器和微服务等众多优势于一体，是一款性能优异，功能强大的框架。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/191302/202012/191302-20201220012019894-203004351.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;苏老师重点介绍了该框架的双离合性能，他从双离合变速箱作为示例，介绍了在这款框架中具备的双离合特性，通过让两个DBFactory常驻内存的机制，从而实现了多数据库启动时，毫秒级切换的优秀性能，他还提到了在多数据库迁移方面做的优雅的设计，通过一系列精心设计的模式，有利于为开发者打造一款功能强大的快速开发神器。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/191302/202012/191302-20201220012044280-822795134.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;随后是来自苏州三星负责工业视觉方面的技术专家仇华先生分享的【.NET工业视觉解决方案】话题和SSW高级软件架构师、高级咨询师洛姜斌老师分享的【ASP.NET Core高级功能托管服务】话题，以及来自人大数媒技术总监黄立敬黄总分享的【国产化系统下的.NET Core实践】。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/191302/202012/191302-20201220012106614-385369468.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;各位老师精彩的演讲，让全场时不时响起了雷鸣般的掌声。&lt;/p&gt;
&lt;h3 id=&quot;6&quot;&gt;6&lt;/h3&gt;
&lt;p&gt;溪源有幸连续两年参加了中国.NET社区开发者大会，每次都有不一样的体会。今年虽然由于疫情的影响，线下活动的举办备受掣肘，但今天的活动，也让我们再次见证了.NET社区的团结。我也相信，每一位参加活动的开发者，无论是到现场还是观看了直播，总能获得饱满的收获。&lt;/p&gt;
&lt;p&gt;当然，学习之余，我们也当把握当下，做好自己，抬头看天，低头看路，为建设更好的.NET生态，贡献自己的绵薄之力。&lt;/p&gt;
&lt;p&gt;由于时间仓促，溪源未能仔细记下每一个关键细节，后期应该也会有视频回放和资料分享，请大家持续关注组委会相关的公众号。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/191302/202012/191302-20201220012138593-973015974.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;另外，插播一条广告，长沙.NET社区计划12月27日组织一次小范围的线下技术活动，现招募讲师，也请有兴趣参与交流的各位开发者持续关注本公众号后期的活动链接分享。2020年中国.NET开发者大会活动纪实&lt;/p&gt;
</description>
<pubDate>Sat, 19 Dec 2020 17:26:00 +0000</pubDate>
<dc:creator>溪源More</dc:creator>
<og:description>2020年中国.NET开发者大会活动纪实 1 2020年12月19日的苏州工业园区，天公作美，阳光明媚，气象迷人，正是一个搞事的好日子。在这里，数百名中国.NET开发者们汇聚一堂，怀揣着激情和梦想，一</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiyuanMore/p/netconfchina2020.html</dc:identifier>
</item>
<item>
<title>被 Pandas read_csv 坑了 - 机器学习算法与Python</title>
<link>http://www.cnblogs.com/jpld/p/14162305.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jpld/p/14162305.html</guid>
<description>&lt;h2 id=&quot;被-pandas-read_csv-坑了&quot;&gt;被 Pandas read_csv 坑了&lt;/h2&gt;
&lt;p&gt;-- 不怕前路坎坷，只怕从一开始就走错了方向&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Pandas&lt;/strong&gt; 是python的一个数据分析包，纳入了大量库和一些标准的数据模型，提供了高效地操作大型数据集所需的工具。Pandas 就是为解决数据分析任务生的，无论是数据分析还是机器学习项目数据预处理中， Pandas 无处不在。&lt;/p&gt;
&lt;p&gt;最近掉进一坑，差点铸成大错。实在没想到居然栽在pandas.read_csv上了，这里分享一下，希望大家注意。&lt;/p&gt;
&lt;p&gt;另：业务数据不方便拿出来演示，为尽可能复现，这里我手造了一份，另存为 income.csv 文件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://my-wechat.oss-cn-beijing.aliyuncs.com/image_20201217223946.png&quot; alt=&quot;看起来都是正经的数据&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;翻船记&quot;&gt;翻船记&lt;/h2&gt;
&lt;p&gt;读取csv文件小菜一碟&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import numpy as np
import pandas as pd
df = pd.read_csv(r'C:\...\income.csv',encoding='utf-8')
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;读好了看看数据信息吧：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;df.info()


RangeIndex: 6 entries, 0 to 5
Data columns (total 1 columns):
 #   Column  Non-Null Count  Dtype 
---  ------  --------------  ----- 
 0   income  6 non-null      object
dtypes: object(1)
memory usage: 176.0+ bytes

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;诶，怎么数据成了object？不应该是float吗？&lt;/p&gt;
&lt;p&gt;不管他，硬转一发&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;df=pd.DataFrame(df,dtype=np.float)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;居然报错了，1000被读成了字符串。&lt;br/&gt;&lt;img src=&quot;https://my-wechat.oss-cn-beijing.aliyuncs.com/image_20201217225004.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其实这里我还掉进了另一个坑，使用了一个已被弃用的 .convert_objects 方法。这种方法更硬，直接把string转成了NaN，所以后面各种操作流畅且错误地进行着....这都是 pandas 没升级的锅，定期检查升级包太有必要了（&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzA4MjYwMTc5Nw==&amp;amp;mid=2648944700&amp;amp;idx=1&amp;amp;sn=c9d663a96bbd72a67e6946e24494ad9d&amp;amp;chksm=87942216b0e3ab001e185612eb465dcc8b192b3bf06ba191889cd7d00c03b1d6149500870e8e&amp;amp;token=1454358884&amp;amp;lang=zh_CN#rd&quot; target=&quot;_blank&quot;&gt;pip 的高阶玩法&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;说回刚才的问题，1,000被读成了字符串是因为csv文件中它使用了千位分隔符。问题其实非常简单，设置一下 &lt;strong&gt;thousands&lt;/strong&gt; 参数就行了&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;df2 = pd.read_csv(r'C:\...\income.csv',encoding='utf-8',thousands =',')
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看一下info&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;df2.info()

&amp;lt;class 'pandas.core.frame.DataFrame'&amp;gt;
RangeIndex: 6 entries, 0 to 5
Data columns (total 1 columns):
 #   Column  Non-Null Count  Dtype  
---  ------  --------------  -----  
 0   income  6 non-null      float64
dtypes: float64(1)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;往下继续&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
df2.describe()

            income
count   6.000000
mean    16934.983333
std     40695.203980
min     0.000000
25%     32.425000
50%     300.000000
75%     875.000000
max     100000.000000
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一切正常!&lt;/p&gt;
&lt;h2 id=&quot;pandasread_csv参数&quot;&gt;pandas.read_csv()参数&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://my-wechat.oss-cn-beijing.aliyuncs.com/image_20201217223616.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;pandas.read_csv()的参数特别多，除了filepath，其他均可缺省。参数的具体含义这里就不赘述，还想复习一下的同学可以直接去看官方文档&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://pandas.pydata.org/pandas-docs/stable/io.html&quot; target=&quot;_blank&quot;&gt;http://pandas.pydata.org/pandas-docs/stable/io.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;英语不好的同学可以看一下热心博主的翻译版：&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/datablog/p/6127000.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/datablog/p/6127000.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 19 Dec 2020 16:33:00 +0000</pubDate>
<dc:creator>机器学习算法与Python</dc:creator>
<og:description>被 Pandas read_csv 坑了 -- 不怕前路坎坷，只怕从一开始就走错了方向 Pandas 是python的一个数据分析包，纳入了大量库和一些标准的数据模型，提供了高效地操作大型数据集所需的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jpld/p/14162305.html</dc:identifier>
</item>
<item>
<title>职场PUA，管理者的五宗罪 - pointersss</title>
<link>http://www.cnblogs.com/pointers/p/14162093.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pointers/p/14162093.html</guid>
<description>&lt;p&gt;在目前的社会环境下，程序员似乎成了“弱势群体”。我们经常谈论的职场PUA已经成为程序员的代名词。&lt;/p&gt;
&lt;p&gt;我一直在想，为什么这么多管理者能力会这么差。&lt;/p&gt;
&lt;p&gt;但最后最吃亏的还是可怜的程序员。&lt;/p&gt;
&lt;p&gt;也许问题的关键是他们被告知了一些伟大的真理。&lt;/p&gt;
&lt;p&gt;而这些真理往往陷入老生常谈的陈词滥调。比如“赋权”、“辅导”、“激励”等等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所以今天，我们要用大家熟悉的“五大罪”来揭露罪恶的管理者。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当然，文学手法的描述在用于企业管理时需要稍加润色，但形容当前管理者们也比较贴切。&lt;/p&gt;
&lt;p&gt;亲爱的堵着门可以看看你的老板，是有一两项罪名，还是“五毒俱全”？&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;互联网行业有句话叫：代码写的好不如PPT讲的好。&lt;/p&gt;
&lt;p&gt;PPT在实际工作中似乎并没有起到很大的作用，但是有了好的PPT，能够让其他人更好的理解工作内容，也就更容易得到老板的提拔和赏识。&lt;/p&gt;
&lt;p&gt;很多技术岗位的人觉得不公平。我在产品开发过程中做了很多工作。为什么我在升职加薪方面不如一个”PPTer“？&lt;/p&gt;
&lt;p&gt;我的观点是：&lt;strong&gt;PPT演讲的好和代码写的好是不冲突的，酒香也怕巷子深。很多情况下，PPT讲解也是很重要的技能&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;很多基层管理者被下属诟病的不是不善于工作，而是只有一句话来工作。&lt;/p&gt;
&lt;p&gt;什么意思？&lt;/p&gt;
&lt;p&gt;就是交代任务一句话，任务成果全给他。&lt;/p&gt;
&lt;p&gt;中间过程没有提供任何设计思路，没有协助解决任何问题。&lt;/p&gt;
&lt;p&gt;程序员们经过努力设计、开发、验证，通宵过多少次，爆过多少肝，最终所产生的成熟的果子，被领导悄无声息的摘走了，然后呈现到高级管理者面前，作为自己邀功请赏的政绩。&lt;/p&gt;
&lt;p&gt;这招过河拆桥，玩的真的很溜啊。&lt;/p&gt;
&lt;p&gt;可以说这种管理者不在少数，他们善于窃取下属的劳动成果。他们像水蛭一样吸下属的血，恶心至极，令人作呕。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在这里提醒可爱的程序员们，拥有优秀的开发能力很重要，PPT软能力要提高，怎样才能及时保存劳动果实。&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;大部分管理者，尤其是中层管理者，往往是身不由己的。&lt;/p&gt;
&lt;p&gt;他们没有多少资源和权力可以支配。核心资源和权力牢牢掌握在高层管理者手中，但真正的承压的却在底层。权力少的基层管理者更珍惜权力，最终会导致基层管理者对权力的贪婪到令人发指的程度。&lt;/p&gt;
&lt;p&gt;作为管理者，你应该学会放权。合理适度的授权可以让工作更有效率。&lt;/p&gt;
&lt;p&gt;以下几句话是针对基层管理者的，提醒你们几句：&lt;/p&gt;
&lt;p&gt;1.允许下属们犯错。你死死禁锢他，他永远长不大；&lt;/p&gt;
&lt;p&gt;2.让下属比你更专业。做到每次交流意见，都被他启发。相反，他丢三落四，漏洞百出，这就是你的失败；&lt;/p&gt;
&lt;p&gt;3.释放自己，把自己从“超人”变成普通人。如果你的下属们能力不行，你自己行，那你还为他们能做多少？&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;暴怒不需要解释了。&lt;/p&gt;
&lt;p&gt;我们在部门的各个岗位和领域上都能看得到这种人。&lt;/p&gt;
&lt;p&gt;我的前任领导就是个典型，先是涨红脸，随之开始慢慢提高音量，然后对着某个没解决bug的可怜同事大吼大叫。&lt;/p&gt;
&lt;p&gt;我的一位学弟，前几个月辞职了，是因为一个震惊的原因。&lt;/p&gt;
&lt;p&gt;我以为，他在一家互联网大厂，也很喜欢软件开发，所以听到这个消息都很惊讶。&lt;/p&gt;
&lt;p&gt;一开始和他聊起这件事的时候，他只是轻描淡写地说：“我领导脾气不是很好。”&lt;/p&gt;
&lt;p&gt;后来，我们才发现，他有一些抑郁了。而诱因也与他这份不错的工作有关：&lt;/p&gt;
&lt;p&gt;“老板会突然向我发脾气，而且当着全楼层的人骂我，破口大骂。时间长了，我也怀疑是不是真的自己能力太差了，频繁写出bug，不值得公司给的资源。&lt;/p&gt;
&lt;p&gt;我也努力过，只要是交给我的开发任务，加班加点也会去完成，但是他看都不看，可能是还没有达到他的理想结果吧……但这样工作真的太压抑了，所以想逃走。”&lt;/p&gt;
&lt;p&gt;如果你也和我的学弟一样，因为一些“臭脾气”的老板或同事而倍感压抑、怀疑自己，甚至待不下去。&lt;/p&gt;
&lt;p&gt;也许该反思的并不是“我是不是能力不行”，而是&lt;strong&gt;“我是不是在遭受语言暴力？&lt;/strong&gt;”&lt;/p&gt;
&lt;p&gt;我想说对这类管理者说：&lt;strong&gt;脾气差不能成为摆脱语言暴力的理由，请尊重每一位敬业的程序员&lt;/strong&gt;。&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;懒惰是人性，在每个人的身上都会发生。&lt;/p&gt;
&lt;p&gt;懒惰在职场中表现就是对于任何事情都无动于衷。&lt;/p&gt;
&lt;p&gt;如果是怠惰成性的管理者就是没有想动手做事的意愿，他们总是心不在焉，不做团队的沟通，对下属不闻不问，对团队的需求也不感兴趣。&lt;/p&gt;
&lt;p&gt;他们心里想的只是自己的闲适自在，心思经常游移到工作以外的个人兴趣上，而且你总会看到他拿个手机在刷着什么。&lt;/p&gt;
&lt;p&gt;我相信你肯定遇到过工作中的懒汉领导。&lt;/p&gt;
&lt;p&gt;比如去一趟厕所，超过半个小时，却称自己忙得没时间和你沟通需求和方案的领导。&lt;/p&gt;
&lt;p&gt;比如承诺回头答复你却杳无音信的领导。&lt;/p&gt;
&lt;p&gt;等等。&lt;/p&gt;
&lt;p&gt;虽然懒惰很少成为头条新闻，不过我觉得大部分管理者身上或多或少都有怠惰的影子。&lt;/p&gt;
&lt;p&gt;当你的企业正在开疆拓土，面临强大竞争时，如果由于懒惰行为，没有做出适应性的调整，那么等待就是高昂的代价。&lt;/p&gt;
&lt;p&gt;真正的将懒惰表现的淋漓尽致的领导就是&lt;strong&gt;甩手掌柜&lt;/strong&gt;。美其名曰授权给下属。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PVZcww4Su3icxqW28rtgt1ib4Iia7XUeWT9yWnQbeXxLtAGF3IasXgOdCKS5RM6RCsOFMKkbbq0tF6YEfBK79Oibsg/640?wx_fmt=jpeg&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;图片&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过能力和意愿可以将员工分为4类，能力强和意愿强的员工，通过授权，固然是最好的手段。&lt;/p&gt;
&lt;p&gt;但是有意愿无能力的员工，还需要领导作为教练帮助其提升。怎么能做甩手掌柜呢？&lt;/p&gt;
&lt;p&gt;显然这人是不负责任，天性懒惰的领导。成为其下属，你觉得你会有前途吗？&lt;/p&gt;

&lt;p&gt;你跟领导讨论方案，肯定会碰到如下场景：&lt;/p&gt;
&lt;p&gt;你提了一个方案，你还没有开始解释，领导立即打断你，立即使用权威终止你的发言，并且让你不要再提这个方案。&lt;/p&gt;
&lt;p&gt;这就是管理者的傲慢。频繁打断别人的话，对自己意见的坚持，坚持让对方按照自己的思路行事。&lt;/p&gt;
&lt;p&gt;管理者的高级境界是说服，说服下属帮你心甘情愿干事，而不是利用强权和自己过往的经验抹杀下属的表达意见机会。&lt;/p&gt;
&lt;p&gt;莎士比亚说过：&lt;strong&gt;闪光的东西，并不都是金子；动听的语言，并不都是好话&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;人都有物质、精神需求，都会追求成就感，当取得成就后渴望被表扬和肯定，这是人之常情。&lt;/p&gt;
&lt;p&gt;当管理者沉浸在动听的赞美声中时，往往会伴随傲慢的出现，甚至不再努力。&lt;/p&gt;
&lt;p&gt;更可怕的是，因自己过往的成就，不再听取别人的意见和建议，不但不再倾听，还会否定别人、批判别人，逐步陷入成就性的傲慢陷阱。&lt;/p&gt;
&lt;p&gt;前一段时间，对于996，社会产生了大讨论，每个人都各抒己见。有说996是福报，有说996是剥削。&lt;/p&gt;
&lt;p&gt;我认为强制灌输“996”，体现的是管理者的傲慢。&lt;/p&gt;
&lt;p&gt;不能给反对“996”的员工贴上“混日子”“不奋斗”的道德标签。&lt;/p&gt;
&lt;p&gt;从企业家和创业者的角度来看，他们身上的极限奋斗精神是可贵的，但要考虑到普通员工的位置不同，强制灌输“996”的加班文化，不仅体现了企业中管理者的傲慢，也不实际、不公平。&lt;/p&gt;
&lt;p&gt;所以我想对管理者说：&lt;strong&gt;不要站在自己的角度评价他人的行为，不要因自己过往的成就，而不再倾听。&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;我是袁吴范，大厂技术总监，公众号：”pointers“；&lt;/p&gt;
&lt;p&gt;扫下面微信二维码，欢迎和我做朋友，坑位有限，先到先得哈。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4XQ0RVoHjpwshyeiaZvUcjdmibSXXBd7eJYkXUjIevg54jcEKJfaVdNaaGJUso5RWNn4cicmlQxEbuUx8jd7QEDIg/640?wx_fmt=jpeg&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;图片&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;em&gt;推荐阅读（干货）&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg4MTU0NTkxNA==&amp;amp;mid=2247484159&amp;amp;idx=1&amp;amp;sn=5d3b5d416a98f6a0d91e3d105b464924&amp;amp;chksm=cf65052af8128c3c1af6649b83d8ebdb5c0aad01f8bc9757976b7ab7418af68c155cdcf114d7&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot;&gt;7年，从“游戏少年”到大厂技术总监的逆袭之路&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg4MTU0NTkxNA==&amp;amp;mid=2247484169&amp;amp;idx=1&amp;amp;sn=b807b5ce8b1e046b995d5247b8c238bb&amp;amp;chksm=cf6504dcf8128dca25ad377fb62da1a80eef3c10856c26c820fe4d7f87ca270681ec8d917f29&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot;&gt;程序员成为高级管理者的三次跃升&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg4MTU0NTkxNA==&amp;amp;mid=2247484150&amp;amp;idx=1&amp;amp;sn=a75d0eb3811746b204007b36f260d7cc&amp;amp;chksm=cf650523f8128c356ef04f44ca060566d711e2aa8c83927c1206598ba9ae43b17fa23fc8fd08&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot;&gt;35岁以后，不要成为程序员中的钻石&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 19 Dec 2020 15:34:00 +0000</pubDate>
<dc:creator>pointersss</dc:creator>
<og:description>在目前的社会环境下，程序员似乎成了“弱势群体”。我们经常谈论的职场PUA已经成为程序员的代名词。 我一直在想，为什么这么多管理者能力会这么差。 但最后最吃亏的还是可怜的程序员。 也许问题的关键是他们被</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/pointers/p/14162093.html</dc:identifier>
</item>
<item>
<title>浅谈任务委托与团队建设 - bee0060</title>
<link>http://www.cnblogs.com/bee0060/p/14055119.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bee0060/p/14055119.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;在我们工作一段时间后，伴随能力的提升，一般会更被信任和认可，之后会承担更多的职责和工作。 完成更多的职责和工作可以更进一步的证明自己并获得更多认同，然后又是更多的信任、职责、工作，形成一个循环。&lt;br/&gt;在这个循环中，我想大部分同学都倾向于靠自己承担和完成所有的这些职责和工作，因为从中我们可以得到认可、成就感、成长机会、升迁机会等等对自己非常有益的东西。&lt;/p&gt;
&lt;p&gt;但是，人力总有穷尽的时候，随着越来越被重用，领导会交给我们更多工作，同事会更多的向我们求助，终有一天，我们已无法独自完成所有这些。即使一天工作16小时且全年无休，也总有扛不住的时候，怎么办？&lt;/p&gt;
&lt;p&gt;办法当然不止一种，例如适当的拒绝（如何说“不”），但这不是本文想讲的。&lt;/p&gt;
&lt;p&gt;还有一个办法就是&lt;strong&gt;任务委托&lt;/strong&gt;，而本文想分享的，正是关于任务委托与团队建设的一些想法。&lt;/p&gt;
&lt;h2 id=&quot;本文范围&quot;&gt;本文范围&lt;/h2&gt;
&lt;p&gt;本文主要讨论为什么我们需要任务委托，委托对我们自己和团队的影响。具体怎么委托暂不在本文范围内，也许以后会再写一篇聊一下，也许不会。&lt;/p&gt;
&lt;h2 id=&quot;任务委托与团队建设&quot;&gt;任务委托与团队建设&lt;/h2&gt;
&lt;h3 id=&quot;误解&quot;&gt;误解&lt;/h3&gt;
&lt;p&gt;首先，将任务委托出去并不是“无能的表现”。当你已经独自完成了足够多的工作后，将部分任务适当的委托给别人，是你综合大局考虑后，对自己与团队更有利、更合理的决策。&lt;br/&gt;委托也不是甩锅，不是简单的将责任丢给别人，是不能胡乱委托的。委托的基本要求是，被委托出去的任务能在可以接受的范围内被完成。&lt;/p&gt;
&lt;p&gt;也许读到这里，你对委托仍有点抗拒，或不以为然，那么我们可以先聊一下不委托的话，可能有什么影响。&lt;/p&gt;
&lt;h3 id=&quot;不委托的利与弊&quot;&gt;不委托的利与弊&lt;/h3&gt;
&lt;p&gt;先说“&lt;strong&gt;利&lt;/strong&gt;”： 前言也提到不少的利，这里再补充一些。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;成为明星&lt;/strong&gt;：随着承担的职责越来越多，完成的事情越来越多，来求助的人和事也越来越多，最常见的情况就是让你成为一个炙手可热的明星。大家都有求于你，而你是那么的忙，那么的不可或缺。要约你的“档期&quot;是那么的不容易。领导重视你，同事喜欢甚至崇拜你，被众人环绕追捧，这感觉简直爽爆了好不好？说不定你正好处于这个阶段呢。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;晋升机会&lt;/strong&gt;： 只要是个正常的企业，在你独立完成了那么多任务，解决了那么多难题后，只要你性格和为人不是很让人讨厌，升职加薪优先想到你不是理所当然的吗?&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;学习机会&lt;/strong&gt;： 因为你解决了很多难题，所以别人如果遇到难题也会先找你帮忙，而解决难题往往是不可多得的成长机会。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;再说“&lt;strong&gt;弊&lt;/strong&gt;”&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;累&lt;/strong&gt;: 别人对你优秀的期待可能让你压力倍增，为此需要付出更多。所以你很累，身体累，偶尔还可能心累，因为一般人不容易发现别人的付出，更容易发现别人的收获，甚至可能有人会质疑你不应该得到这么多。这可能会打断你的“优秀”，让你消极怠工甚至想换份工作。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;进步放缓甚至停滞&lt;/strong&gt;：在我们被委以更多职责后，一般会带来一些常态化的工作，这些工作在刚开始时能让我们成长，但是做多了之后，可能很难再从中学到很多，当这种工作多到一定程度，很可能让你没有时间思考和学习，终日忙于熟悉而繁杂的常见任务中，以致止步不前。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;遭到妒忌&lt;/strong&gt;： 妒忌可能来自两种人，一种就是看不到你付出，只看到你收获的人。 另一种就是都看到，且上进的人，难题、职责都是晋升和学习的机会，而机会都被你占了，他们有激情有能力却无法施展。你自以为承担了重担让同事们更轻松，却没意识到也剥夺了他人成长的机会，有些人可能会妒忌或埋怨你，有些人可能很厚道不怪你，但是为了自身的成长与晋升，离你而去。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;成为瓶颈&lt;/strong&gt;： 我们一天都只有24小时，当事情多到在你这要排队的时候，你可能已经成为团队的瓶颈，因为别人要等你这好了才能继续进行。你不是没有能力，只是事情太多不够时间及时完成。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;何时开始委托&quot;&gt;何时开始委托&lt;/h3&gt;
&lt;p&gt;综合利与弊，其实我认为，最早的时机是当你有可以委托的人的时候，就可以进行委托了。如果你已经不堪重负或者成为团队瓶颈或阻碍到别人的工作进展了，那么我建议现在着手准备委托些任务出去。&lt;/p&gt;
&lt;h3 id=&quot;哪些任务不适合委托&quot;&gt;哪些任务不适合委托&lt;/h3&gt;
&lt;p&gt;并不是什么任务都适合委托的，有些应该拒绝，有些应该自己完成，先搞清楚哪些可以委托，否则闹笑话事小，让同事领导对你不满事大。暂时我只想到以下两点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;和自己工作职责完全无关的工作 - 比如让一个后端开发去修一下咖啡机。如果你有时间且有这个能力，你当然也可以选择接受并自己完成，但千万别接受后又委托给别人。最建议的做法是拒绝。至于怎么拒绝，因为超出本文范围，您可能需要自己搜一下&lt;/li&gt;
&lt;li&gt;主要的本职工作 - 一般每个岗位都有最根本的职责，简单来说就是本职工作，不同公司和岗位不同，这里无法穷举，但是你心里应该知道，如果不知道，你可能需要找你的领导聊一下。一般都是你的领导或公司对你最基本的期望，例如前端开发就是要实现页面样式和逻辑。对于这种工作，你有时间自己完成的话，不建议委托出去，因为这是你的本职工作，本职工作都委托出去了，你还要干嘛呢？&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;委托的好处&quot;&gt;委托的好处&lt;/h3&gt;
&lt;p&gt;如果你已经能接受“有些任务是可以委托出去的“这个观点，那么我们可以接着说说委托对自己和团队的好处了。&lt;/p&gt;
&lt;h4 id=&quot;-对自己&quot;&gt;-&lt;em&gt;&lt;strong&gt;对自己&lt;/strong&gt;&lt;/em&gt;&lt;/h4&gt;
&lt;p&gt;首先能想到的，当然就是不用再那么忙了。你开始可以量力而行，不用再别人走完了还一个人继续苦干。 心里可能曾有的不平衡也会消散。你的状态会更好了，有时间学习了，也可以开始思考更多了，例如职业规划，自我发展，你可以在你收到的茫茫多的任务中挑选对你成长（职位或能力）最有益的，留下来自己做，将那些对你不那么有益的委托出去。你可能慢慢从问题解决者变成协调者，看似你独立解决了更少问题。但在别人看来，找你能解决的问题反而变多了，因为你可以调动身边的资源帮助别人解决更多问题，而且可能比你自己一个人解决质和量都更好。&lt;/p&gt;
&lt;p&gt;此外，你有更多时间后也有机会学习和思考更高维度的问题，如果你是开发人员，之前都在写业务和救火，那么现在你可以开始考虑架构优化、开发流程优化、制作工具或部分自动化提高开发效率、制定文档标准等等事情了。&lt;/p&gt;
&lt;h4 id=&quot;-对被委托人&quot;&gt;-&lt;em&gt;&lt;strong&gt;对被委托人&lt;/strong&gt;&lt;/em&gt;&lt;/h4&gt;
&lt;p&gt;可能你会觉得过意不去，因为你让被委托人承担了额外的工作。事实也确实是如此，不过凡是有两面性。 你想想你之所以可以得到这么多成长和机会是因为什么？ 你除了加大了别人的工作量，也带给别人更多的成长和晋升机会，前提是你没有把功劳都抢了。 如果你不是强迫式的委托给别人任务，那么你委托出去的任务有可能正是对方渴望的。这也反映出，委托之前必须与被委托人沟通好，强迫他人接受很容易带来双输的局面，但是如果是对别人有益的任务，且别人不那么抗拒，很可能带来双赢。&lt;/p&gt;
&lt;p&gt;另外，因为有了学习和成长的机会，只要压力在被委托人的承受范围内，那么这个被委托人的离职风险一般也会降低一些。&lt;/p&gt;
&lt;h4 id=&quot;-对任务分配人（或求助者）&quot;&gt;-&lt;em&gt;&lt;strong&gt;对任务分配人（或求助者）&lt;/strong&gt;&lt;/em&gt;&lt;/h4&gt;
&lt;p&gt;由于你不再是唯一可以解决问题的人，需要等待你完成的情况会越来越少，需要你的任务完成后才能开始工作的人的等待时间将会大大减小，咱应该都了解串行和并行。 都等你来，就是串行，你一个人阻塞一群人。 你可以适当委托出去后，这些任务就变成并行，别人的等待时间大大减少。这可以减少团队的时间浪费、提高效率。&lt;/p&gt;
&lt;h4 id=&quot;-对团队&quot;&gt;-&lt;em&gt;&lt;strong&gt;对团队&lt;/strong&gt;&lt;/em&gt;&lt;/h4&gt;
&lt;p&gt;如果我们都认可“解决不同问题能带来不同的能力提升”这个观点，那么你的委托如果具有足够合理的策略，那么你的委托将让团队越来越健壮和强大。无论你是团队的管理者或只是其中一员。&lt;/p&gt;
&lt;p&gt;我们工作几年后，一般会发现，程序员的职业生涯中，想要不断提高自己，需要的已经不光是编码技能。我们需要的能力可谓五花八门，有编码能力、架构设计能力、学习能力、技术调研能力、沟通能力、写作的能力（文档或邮件）、面试别人的能力等等等等。&lt;/p&gt;
&lt;p&gt;也已经有很多文章或理论提到，不要让团队中个别成员成为某一问题的唯一解决者，这样团队将陷入巨大的风险。试想有个问题只有一个人能解决，如果有一天他突然离职了呢？&lt;/p&gt;
&lt;p&gt;有一个东西叫&lt;a href=&quot;https://www.aqee.net/post/bus-count.html&quot; target=&quot;_blank&quot;&gt;巴士指数&lt;/a&gt;，巴士指数高一般比低要好，大家有兴趣的可以看一下。 任务委托可以增加巴士指数，让团队的抗风险能力显著提高。&lt;/p&gt;
&lt;p&gt;简单来说就是，同一类型的任务，不要总是由同一个人来解决，适时的委托给不同的人，让大家都有机会学习所需的技能，在一个成员掌握的差不多之后，再委托给另一个人。如此执行下去，大部分问题都能找到超过一个能解决的人。机会和压力也可以分摊，不必都压在少数几个人头上。离职率一般也会有所降低。团队更稳定，风险更低，效率也会更高，即使有人员流动，其带来的不良影响也能降低。&lt;/p&gt;
&lt;p&gt;技术面试、写文档、技术调研这样的任务就很适合以团队建设为目的进行委托。&lt;/p&gt;
&lt;h2 id=&quot;最后&quot;&gt;最后&lt;/h2&gt;
&lt;p&gt;很多东西并不是有多难，大家不那么做的原因有时仅仅是不认可或没有意识到它的好处。所以本文旨在分享我对于“为什么要进行任务委托”的看法，其好处和影响，希望对大家有帮助。&lt;br/&gt;对于具体怎么委托，我有一些想法，但是还不能成文，所以文中暂时没有提及。但我相信大家只要坚持做了，总能摸索出一条适合自己的方法，也自然会去找相关的资料来学习，问题也就不大了。&lt;/p&gt;
&lt;p&gt;本文说的不对的地方，欢迎指正，更欢迎分享你的想法和经验。&lt;/p&gt;
&lt;p&gt;转载请注明出处：&lt;a href=&quot;https://www.cnblogs.com/bee0060/p/14055119.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/bee0060/p/14055119.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 19 Dec 2020 15:33:00 +0000</pubDate>
<dc:creator>bee0060</dc:creator>
<og:description>前言 在我们工作一段时间后，伴随能力的提升，一般会更被信任和认可，之后会承担更多的职责和工作。 完成更多的职责和工作可以更进一步的证明自己并获得更多认同，然后又是更多的信任、职责、工作，形成一个循环。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/bee0060/p/14055119.html</dc:identifier>
</item>
<item>
<title>SPI机制剖析——基于DriverManager+ServiceLoader的源码分析 - 数小钱钱的种花兔</title>
<link>http://www.cnblogs.com/buptleida/p/14162051.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/buptleida/p/14162051.html</guid>
<description>&lt;p&gt;我的上一篇博客&lt;a href=&quot;https://www.cnblogs.com/buptleida/p/14111058.html&quot; target=&quot;_blank&quot;&gt;类加载器与双亲委派&lt;/a&gt;中提到，SPI机制是一种上级类加载器调用下级类加载器的情形，因此会打破类加载的双亲委派模型。为了深入理解其中的细节，本博客详细剖析一下SPI机制，并以JDBC为例，基于源码来进行分析。&lt;/p&gt;
&lt;h2 id=&quot;spi&quot;&gt;SPI&lt;/h2&gt;
&lt;h3 id=&quot;原理介绍&quot;&gt;原理介绍&lt;/h3&gt;
&lt;p&gt;SPI（Service Provider Interface），是JDK内置的服务提供发现机制。即JDK内部定义规范的接口，不同厂商基于标准服务接口实现具体的实现类和方法。SPI一般被用来做框架扩展的开发。&lt;br/&gt;下面这张图，很简明扼要地阐释了SPI的机理。&lt;br/&gt;&lt;img src=&quot;https://qiniu.debrisflow.cn/20201219SPI.png&quot; alt=&quot;SPI机制&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;与SPI相对应的，是我们耳熟能详的API。API不需要上图中“标准服务接口”这一环节，而是调用方直接调用服务提供方。按照上一篇博客的分析，“标准服务接口”位于Java核心类库中，使用boot类加载器进行加载，而boot类加载器是无法获取“第三方实现类”的位置的。所以，相较于API而言，SPI需要打破双亲委派模型。&lt;/p&gt;
&lt;h3 id=&quot;优缺点&quot;&gt;优缺点&lt;/h3&gt;
&lt;h4 id=&quot;好处&quot;&gt;好处&lt;/h4&gt;
&lt;p&gt;但是，我陷入思考，SPI这样的模式有什么好处吗，或者说API有什么缺点吗？&lt;/p&gt;
&lt;p&gt;想象一下，如果程序直接调用第三方类库，当第三方类库发生改动时，应用程序代码很可能需要随之改动。但如果在JDK内部定义标准服务接口，要求第三方厂商实现这些接口，那无论实现类如何改动，只要标准接口不变，都不会影响到应用程序。所以我认为SPI机制的根本目的是为了&lt;strong&gt;“解耦”&lt;/strong&gt;。这也就是面向对象中所谓的“接口编程”，把装配的控制权移到程序之外。&lt;/p&gt;
&lt;p&gt;许多著名的第三方类库都采纳了SPI机制，JDBC就是其中之一。数据库厂商会基于标准接口来开发相应的连接库。如MySQL何PostgreSql的驱动都实现了标准接口：java.sql.Driver。对于应用程序而言，无需关心是MySQL还是PostgreSql，只需要与标准服务接口打交道即可。SPI正是基于这种模式完成了解耦合。&lt;/p&gt;
&lt;h4 id=&quot;不足&quot;&gt;不足&lt;/h4&gt;
&lt;p&gt;当然，即便如此，SPI依旧是存在缺点和不足的，如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;不能按需加载。需要遍历所有的实现，并且进行实例化，某些实现的实例化可能很耗时，这样会造成浪费；&lt;/li&gt;
&lt;li&gt;获取实现类的方式不够灵活，只能通过Iterator获取，不能根据某个参数来获取实现类；&lt;/li&gt;
&lt;li&gt;ServiceLoader类的实例线程不安全。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;jdbc的spi机制&quot;&gt;JDBC的SPI机制&lt;/h2&gt;
&lt;p&gt;首先来看一段使用JDBC的简单代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Test
public void testJDBC() throws SQLException, ClassNotFoundException {
    String url = &quot;jdbc:mysql://localhost:3307/mls&quot;;
    String userName = &quot;root&quot;;
    String password = &quot;123456&quot;;
    // Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);
    Connection con = DriverManager.getConnection(url, userName, password);
    Statement statement = con.createStatement();
    String sql = &quot;select * from mlsdb where id=1&quot;;
    ResultSet rs = statement.executeQuery(sql);
    while (rs.next()) {
        System.out.println(rs.getString(&quot;province&quot;));
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意到中间有一行注释的代码&lt;code&gt;Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);&lt;/code&gt;，其实这一行可写可不写。&lt;/p&gt;
&lt;p&gt;我的倒数第二篇博客&lt;a href=&quot;https://www.cnblogs.com/buptleida/p/14094708.html&quot; target=&quot;_blank&quot;&gt;类加载时机与过程&lt;/a&gt;里提到，Class.forName方法会触发“初始化”，即触发类加载的进行。因此如果写上这行代码，此处则是使用APP类加载器加载mysql的jdbc驱动类。&lt;/p&gt;
&lt;p&gt;然而，这一句Class.forName不用写，代码也能正常运行。因为加载DriverManager类时，会将MySQL的Driver对象注册进DriverManager中。具体流程后文会细说。其实这就是SPI思想的一个典型的实现。得益于SPI思想，应用程序中无需指定类似&quot;com.mysql.cj.jdbc.Driver&quot;这种全类名，尽可能地将第三方驱动从应用程序中解耦出来。&lt;/p&gt;
&lt;p&gt;下面，通过源码来分析驱动加载以及服务发现的过程，主要涉及到DriverManager和ServiceLoader两个类&lt;/p&gt;
&lt;h3 id=&quot;源码分析&quot;&gt;源码分析&lt;/h3&gt;
&lt;p&gt;DriverManager是用于管理Jdbc驱动的基础服务类，位于Java.sql包中，因此是由boot类加载器来进行加载。加载该类时，会执行如下代码块：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * Load the initial JDBC drivers by checking the System property
 * jdbc.properties and then use the {@code ServiceLoader} mechanism
 */
static {
    loadInitialDrivers();
    println(&quot;JDBC DriverManager initialized&quot;);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述静态代码块会执行loadInitialDrivers()方法，该方法用于加载各个数据库驱动。代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private static void loadInitialDrivers() {
    String drivers;
    try {
        drivers = AccessController.doPrivileged(new PrivilegedAction&amp;lt;String&amp;gt;() {
            public String run() {
                return System.getProperty(&quot;jdbc.drivers&quot;);
            }
        });
    } catch (Exception ex) {
        drivers = null;
    }

    AccessController.doPrivileged(new PrivilegedAction&amp;lt;Void&amp;gt;() {
        public Void run() {

            ServiceLoader&amp;lt;Driver&amp;gt; loadedDrivers = ServiceLoader.load(Driver.class);//实例化ServiceLoader对象，并注入线程上下文类加载器和Driver.class
            Iterator&amp;lt;Driver&amp;gt; driversIterator = loadedDrivers.iterator();//获得迭代器

            try{
                while(driversIterator.hasNext()) {
                    driversIterator.next();//进行类加载
         `       }
         `   } catch(Throwable t) {
            // Do nothing
            }
            return null;
        }
    });

    println(&quot;DriverManager.initialize: jdbc.drivers = &quot; + drivers);

    if (drivers == null || drivers.equals(&quot;&quot;)) {
        return;
    }
    String[] driversList = drivers.split(&quot;:&quot;);
    println(&quot;number of Drivers:&quot; + driversList.length);
    for (String aDriver : driversList) {
        try {
            println(&quot;DriverManager.Initialize: loading &quot; + aDriver);
            Class.forName(aDriver, true,
                    ClassLoader.getSystemClassLoader());
        } catch (Exception ex) {
            println(&quot;DriverManager.Initialize: load failed: &quot; + ex);
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;ServiceLoader.load(Driver.class)&lt;/code&gt;此方法会把实例化一个ServiceLoader对象，并且向其注入线程上下文类加载器和Driver.class；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;loadedDrivers.iterator()&lt;/code&gt;：获得ServiceLoader对象的迭代器；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;driversIterator.hasNext()&lt;/code&gt;：查找Driver类；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;driversIterator.next()&lt;/code&gt;：在实现的“next()”方法中进行类加载，使用上面的线程上下文类加载器。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;ServiceLoader.load(Driver.class);&lt;/code&gt;的代码及相关调用方法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static &amp;lt;S&amp;gt; ServiceLoader&amp;lt;S&amp;gt; load(Class&amp;lt;S&amp;gt; service) {
    ClassLoader cl = Thread.currentThread().getContextClassLoader();// 获得线程上下文类加载器
    return ServiceLoader.load(service, cl);
}
public static &amp;lt;S&amp;gt; ServiceLoader&amp;lt;S&amp;gt; load(Class&amp;lt;S&amp;gt; service,
                                            ClassLoader loader)
{
    return new ServiceLoader&amp;lt;&amp;gt;(service, loader);
}

public void reload() {
    providers.clear();
    lookupIterator = new LazyIterator(service, loader);
}

private ServiceLoader(Class&amp;lt;S&amp;gt; svc, ClassLoader cl) {
    service = Objects.requireNonNull(svc, &quot;Service interface cannot be null&quot;);
    loader = (cl == null) ? ClassLoader.getSystemClassLoader() : cl;
    acc = (System.getSecurityManager() != null) ? AccessController.getContext() : null;
    reload();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;经过上述过程，用成员变量&lt;code&gt;private final ClassLoader loader;&lt;/code&gt;引用传入的类加载器，用service接收Driver.class。同时，上述过程中实例化了一个LazyIterator对象，并用成员变量lookupIterator来引用。&lt;br/&gt;执行ServiceLoader的“hasNext()”方法时最终会调用lookupIterator迭代器的“hasNext()”方法（此处暂且省略调用过程），如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private boolean hasNextService() {
    if (nextName != null) {
        return true;
    }
    if (configs == null) {
        try {
            String fullName = PREFIX + service.getName();
            if (loader == null)
                configs = ClassLoader.getSystemResources(fullName);
            else
                configs = loader.getResources(fullName);//进行服务查找
        } catch (IOException x) {
            fail(service, &quot;Error locating configuration files&quot;, x);
        }
    }
    while ((pending == null) || !pending.hasNext()) {
        if (!configs.hasMoreElements()) {
            return false;
        }
        pending = parse(service, configs.nextElement());
    }
    nextName = pending.next();
    return true;
}
public boolean hasNext() {
    if (acc == null) {
        return hasNextService();
    } else {
        PrivilegedAction&amp;lt;Boolean&amp;gt; action = new PrivilegedAction&amp;lt;Boolean&amp;gt;() {
            public Boolean run() { return hasNextService(); }
        };
        return AccessController.doPrivileged(action, acc);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述过程通过&lt;code&gt;configs = loader.getResources(fullName)&lt;/code&gt;来查找实现Driver接口的类。&lt;/p&gt;
&lt;p&gt;同样，ServiceLoader的迭代器的“next()”方法最终会调用lookupIterator迭代器的“next()”方法，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private S nextService() {
    if (!hasNextService())
        throw new NoSuchElementException();
    String cn = nextName;
    nextName = null;
    Class&amp;lt;?&amp;gt; c = null;
    try {
        c = Class.forName(cn, false, loader);//使用loader来进行类加载
    } catch (ClassNotFoundException x) {
        fail(service,
             &quot;Provider &quot; + cn + &quot; not found&quot;);
    }
    if (!service.isAssignableFrom(c)) {
        fail(service,
             &quot;Provider &quot; + cn  + &quot; not a subtype&quot;);
    }
    try {
        S p = service.cast(c.newInstance());
        providers.put(cn, p);
        return p;
    } catch (Throwable x) {
        fail(service,
             &quot;Provider &quot; + cn + &quot; could not be instantiated&quot;,
             x);
    }
    throw new Error();          // This cannot happen
}

public S next() {
    if (acc == null) {
        return nextService();
    } else {
        PrivilegedAction&amp;lt;S&amp;gt; action = new PrivilegedAction&amp;lt;S&amp;gt;() {
            public S run() { return nextService(); }
        };
        return AccessController.doPrivileged(action, acc);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，next()会最终调用到nextService()方法，并在此方法中通过&lt;code&gt;c = Class.forName(cn, false, loader);&lt;/code&gt;执行类加载。此处的loader也是由ServiceLoader中的loader传入的，即为前文提到的线程上下文类加载器。&lt;/p&gt;
&lt;p&gt;经历了上述ServiceLoader类中一系列操作之后（包括服务发现和类加载），位于mysql驱动包中的Driver类会被初始化。该类如下所示&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.mysql.cj.jdbc;

import java.sql.DriverManager;
import java.sql.SQLException;

public class Driver extends NonRegisteringDriver implements java.sql.Driver {
    public Driver() throws SQLException {
    }

    static {
        try {
            DriverManager.registerDriver(new Driver());
        } catch (SQLException var1) {
            throw new RuntimeException(&quot;Can't register driver!&quot;);
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述Driver类加载时，会执行静态代码块，即执行&lt;code&gt;DriverManager.registerDriver(new Driver());&lt;/code&gt;方法向DriverManager中注册一个Driver实例。&lt;br/&gt;我们再回到DriverManager类中，看看registerDriver方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static synchronized void registerDriver(java.sql.Driver driver,
            DriverAction da)
        throws SQLException {

    /* Register the driver if it has not already been added to our list */
    if(driver != null) {
        registeredDrivers.addIfAbsent(new DriverInfo(driver, da));
    } else {
        // This is for compatibility with the original DriverManager
        throw new NullPointerException();
    }

    println(&quot;registerDriver: &quot; + driver);

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;会将该MySQL驱动添加到成员变量registeredDrivers中，该成员变量存放已注册的jdbc驱动列表，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// List of registered JDBC drivers
private final static CopyOnWriteArrayList&amp;lt;DriverInfo&amp;gt; registeredDrivers = new CopyOnWriteArrayList&amp;lt;&amp;gt;();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如此一来，服务发现、类加载、驱动注册便到此结束。接下来，应用程序执行数据库连接操作时，会调用“getConnection”方法，遍历registeredDrivers，获取驱动，建立数据库连接。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;以上便是JDBC的SPI机制总结，最核心的地方在于，ServiceLoader中使用低级别的加载器发现Driver类，并进行类加载。这些工作是BootStrap类加载器所办不到的。由于DriverManager和ServiceLoader都位于Java核心类库中，使用BootStrap类加载器来加载，所以需要通过线程上下文类加载器向ServiceLoader对象中传入一个低级别的类加载器，如系统类加载器，从而来打破双亲委派机制。&lt;/p&gt;
</description>
<pubDate>Sat, 19 Dec 2020 15:26:00 +0000</pubDate>
<dc:creator>数小钱钱的种花兔</dc:creator>
<og:description>我的上一篇博客类加载器与双亲委派中提到，SPI机制是一种上级类加载器调用下级类加载器的情形，因此会打破类加载的双亲委派模型。为了深入理解其中的细节，本博客详细剖析一下SPI机制，并以JDBC为例，基于</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/buptleida/p/14162051.html</dc:identifier>
</item>
<item>
<title>Raft算法系列教程1：Leader选举 - 楚楚99</title>
<link>http://www.cnblogs.com/chuchublog/p/14161781.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chuchublog/p/14161781.html</guid>
<description>&lt;h2&gt;1、服务器的三种角色&lt;/h2&gt;
&lt;p&gt;Raft算法中服务器主要分为三种角色：&lt;code&gt;Leader&lt;/code&gt;、&lt;code&gt;Follower&lt;/code&gt;、&lt;code&gt;Candidate&lt;/code&gt;，并且三种角色相互独立，也就是服务器在同一时间内只可能扮演其中一种角色。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Leader&lt;/code&gt;：用于对所有用户的请求进行处理以及日志的复制等等。&lt;br/&gt;&lt;code&gt;Follower&lt;/code&gt;：不会主动发送消息，只响应来自&lt;code&gt;Leader&lt;/code&gt;与&lt;code&gt;Candidate&lt;/code&gt;的请求。&lt;br/&gt;&lt;code&gt;Candidate&lt;/code&gt;：用于选举新的Leader。&lt;/p&gt;
&lt;h2&gt;2、任期介绍&lt;/h2&gt;
&lt;p&gt;Raft 算法将时间划分成为任意不同长度的任期（&lt;code&gt;term&lt;/code&gt;）。任期用连续的数字进行表示。每一个任期的开始都是一次选举（&lt;code&gt;election&lt;/code&gt;），一个或多个候选人会试图成为领导人。如果一个候选人赢得了选举，它就会在该任期的剩余时间担任领导人。在某些情况下，选票会被瓜分，有可能没有选出领导人，那么，将会开始另一个任期，并且立刻开始下一次选举。Raft 算法保证在给定的一个任期最多只有一个领导人。&lt;/p&gt;
&lt;h2&gt;3、网络状态&lt;/h2&gt;
&lt;p&gt;网络状态分为两种情况：选举阶段，正常运行阶段。&lt;code&gt;备注：网络状态还可能会有成员变化阶段，暂时先不考虑。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;每一个任期都是以选举阶段开始。但不一定以正常运行阶段结束。在某些情况下一个完整的任期可能全部为选举阶段。如下图:&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1713156/202012/1713156-20201219223923821-412520268.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;4、选举阶段-&amp;gt;正常运行阶段&lt;/h2&gt;
&lt;p&gt;在网络初始化时，网络中所有的服务器都以&lt;code&gt;Follower&lt;/code&gt;的角色启动。由于&lt;code&gt;Follower&lt;/code&gt;只被动接收消息，所以全网中所有服务器都处于等待状态。同时每一个服务器都在本地维护一个计时器。计时器的作用很简单，就是判断当前阶段(选举阶段或正常运行阶段)是否超时，而当计时器超时后，任期将会加1。&lt;/p&gt;
&lt;p&gt;总之，在网络启动后所有服务器等待指定长度的一段时间之后，计时器将会超时。这时候计时器超时的服务器将转换自己的角色为&lt;code&gt;Candidate&lt;/code&gt;，从而进入选举阶段。进入选举阶段的&lt;code&gt;Candidate&lt;/code&gt;将会做以下几件事:&lt;/p&gt;
&lt;p&gt;（1）将自己的任期号加1。&lt;br/&gt;（2）为自己投一票用以选举出新的Leader。&lt;br/&gt;（3）将本地的计时器重置。&lt;br/&gt;（4）发送投票请求到网络中的其他所有的服务器。&lt;br/&gt;（5）等待下一次的计时器超时。&lt;/p&gt;
&lt;p&gt;同时，投票选举&lt;code&gt;Leader&lt;/code&gt;具有以下几点要求:&lt;/p&gt;
&lt;p&gt;（1）每个服务器在一个任期内只能投一票，并且只能投先到者(即投票给自己收到的第一个请求)。&lt;code&gt;如果没有先到者，只能投票选自己了。&lt;/code&gt;&lt;br/&gt;（2）请求投票的消息中需要带有请求者所处的当前任期号。&lt;br/&gt;（3）投票者只会投票给任期号大于等于自己当前任期号的服务器。&lt;/p&gt;
&lt;p&gt;在选举状态会出现三种结果:&lt;/p&gt;
&lt;p&gt;（1）自己成功当选Leader&lt;br/&gt;（2）网络中其他服务器当选Leader&lt;br/&gt;（3）网络中没有服务器当选Leader&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1713156/202012/1713156-20201219223947679-1322144499.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当网络中某一个&lt;code&gt;Candidate&lt;/code&gt;接收到网络中大多数成员的投票后，即可将自己的身份转换为&lt;code&gt;Leader&lt;/code&gt;。在当选&lt;code&gt;Leader&lt;/code&gt;后，该服务器将周期性地发送心跳信息(心跳信息包含成功当选&lt;code&gt;Leader&lt;/code&gt;的服务器的当前任期号)到网络中其他服务器。在网络中其他的服务器收到心跳信息后检查心跳消息中的任期号是否大于等于自己的任期号。如果满足该条件的话&lt;code&gt;Candidate&lt;/code&gt;将会转换为&lt;code&gt;Follower&lt;/code&gt;状态，并重置计时器。而如果任期号小于自己的任期号，服务器将拒绝该心跳消息并继续处于&lt;code&gt;Candidate&lt;/code&gt;状态。&lt;/p&gt;
&lt;p&gt;第三种情况为网络中没有服务器成功当选&lt;code&gt;Leader&lt;/code&gt;。这种情况在有很多&lt;code&gt;Follower&lt;/code&gt;同时成为&lt;code&gt;Candidate&lt;/code&gt;时会发生。因为当角色转换为&lt;code&gt;Candidate&lt;/code&gt;后将会将选票投给自己，从而导致选票被分散开来，没有&lt;code&gt;Candidate&lt;/code&gt;可以得到网络中大部分节点的选票，从而没有节点可以成为&lt;code&gt;Leader&lt;/code&gt;。这种情况下计时器将再次超时，网络状态将从选举阶段进入下一个选举阶段，同时&lt;code&gt;Candidate&lt;/code&gt;将会再次执行上面说明的几件事。&lt;/p&gt;
&lt;p&gt;Raft算法采用了随机选举超时机制来避免出现这种情况。即当计时器超时后，服务器将随机延迟指定的时间后才进入选举阶段。&lt;br/&gt;由于随机延迟的原因，将降低服务器在同一时间选举超时的情况，可以有效避免选票分散的情况。&lt;/p&gt;
&lt;h2&gt;5、正常运行阶段-&amp;gt;选举阶段&lt;/h2&gt;
&lt;p&gt;当&lt;code&gt;Leader&lt;/code&gt;成功选举之后，将周期性发送心跳消息到网络中其他服务器。同时其他服务器将转换自己的角色为&lt;code&gt;Follower&lt;/code&gt;，并且每次收到心跳消息后都会重置自己的计时器，防止超时再次进入选举阶段。&lt;/p&gt;
&lt;p&gt;如果&lt;code&gt;Leader&lt;/code&gt;因为特殊情况崩溃时，网络中的其他服务器将不再接收到心跳消息，在等待指定时间后计时器将会超时，从而再次进入选举阶段。&lt;/p&gt;
&lt;p&gt;如果&lt;code&gt;Leader&lt;/code&gt;崩溃时间较短，可以在其他服务器计时器超时之间恢复，并发送心跳消息，网络仍然可以恢复为&lt;code&gt;Leader&lt;/code&gt;崩溃之前的状态。&lt;/p&gt;
&lt;p&gt;如果&lt;code&gt;Leader&lt;/code&gt;崩溃时间较长，在网络中已有新的&lt;code&gt;Leader&lt;/code&gt;选举产生后恢复，由于旧的&lt;code&gt;Leader&lt;/code&gt;任期号将小于新的&lt;code&gt;Leader&lt;/code&gt;，在旧的&lt;code&gt;Leader&lt;/code&gt;接收到新的&lt;code&gt;Leader&lt;/code&gt;发送的心跳消息后则会变为&lt;code&gt;Follower&lt;/code&gt;状态。&lt;/p&gt;
&lt;h2&gt;6、参考&lt;/h2&gt;
&lt;p&gt;http://www.mybatis.cn/archives/1147.html&lt;/p&gt;
</description>
<pubDate>Sat, 19 Dec 2020 14:42:00 +0000</pubDate>
<dc:creator>楚楚99</dc:creator>
<og:description>1、服务器的三种角色 Raft算法中服务器主要分为三种角色：Leader、Follower、Candidate，并且三种角色相互独立，也就是服务器在同一时间内只可能扮演其中一种角色。 Leader：用</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/chuchublog/p/14161781.html</dc:identifier>
</item>
</channel>
</rss>