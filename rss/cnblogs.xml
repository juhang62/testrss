<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>微服务模式笔记:服务分解策略 - fairjm</title>
<link>http://www.cnblogs.com/fairjm/p/Microservices_Patterns_ch2_notes.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fairjm/p/Microservices_Patterns_ch2_notes.html</guid>
<description>&lt;p&gt;Microservice Patterns第二章的读书笔记&lt;br/&gt;原章节链接: &lt;a href=&quot;https://learning.oreilly.com/library/view/microservices-patterns/9781617294549/kindle_split_010.html&quot; class=&quot;uri&quot;&gt;https://learning.oreilly.com/library/view/microservices-patterns/9781617294549/kindle_split_010.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Decomposition strategies&lt;/p&gt;
&lt;p&gt;微服务最关键的挑战 也就是微服务的本质是如何将应用的功能分解到服务中去&lt;br/&gt;服务是业务相关而不是技术相关&lt;/p&gt;

&lt;h2 id=&quot;what-is-software-architecture-and-why-does-it-matter&quot;&gt;2.1.1. What is software architecture and why does it matter?&lt;/h2&gt;
&lt;p&gt;应用架构是将应用分解成各个部分(元素)和这些部分间的关系&lt;/p&gt;
&lt;p&gt;软件架构的4+1 view model&lt;br/&gt;简单理解就是从几个角度来描述架构&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1244488/201902/1244488-20190213011614249-992071651.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/fairjm/p/www.cs.ubc.ca/~gregor/teaching/papers/4+1view-architecture.pdf&quot; class=&quot;uri&quot;&gt;www.cs.ubc.ca/~gregor/teaching/papers/4+1view-architecture.pdf&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Logical view : 开发者创建的软件元素。就像类和包 类之间的继承 关联和依赖&lt;/li&gt;
&lt;li&gt;Implementataion view: 构建系统的产出。比如java是jar或者war&lt;/li&gt;
&lt;li&gt;Process view:运行时组件.每个元素都是一个进程，和各个进程间的进程间通信。&lt;/li&gt;
&lt;li&gt;Deployment：进程是如何映射到机器的。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;架构对于功能需求基本没有什么帮助&lt;br/&gt;但架构又是重要的 因为他让应用满足第二种需求: 服务质量(quality of service,QoS)需求&lt;/p&gt;
&lt;h2 id=&quot;overview-of-architectural-styles&quot;&gt;2.1.2. Overview of architectural styles&lt;/h2&gt;
&lt;p&gt;一种特定的架构提供有限的元素(组件)调色盘和关系(connectors)&lt;br/&gt;你从中定义出应用架构的视图&lt;/p&gt;
&lt;h3 id=&quot;分层架构&quot;&gt;分层架构&lt;/h3&gt;
&lt;p&gt;定义了三层:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Presentation layer: 包含实现了用户界面和额外的API的代码&lt;/li&gt;
&lt;li&gt;Business logic layer： 包含业务逻辑&lt;/li&gt;
&lt;li&gt;Persistence layer：包含和数据库交互的逻辑&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;但是也有明显的缺点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;单一的展示层&lt;/li&gt;
&lt;li&gt;单一的持久层&lt;/li&gt;
&lt;li&gt;定义的业务逻辑依赖于持久层 离开数据库无法测试&lt;br/&gt;会存在依赖倒置，业务层定义的数据访问接口最后需要持久层定义DAO类去实现(低层依赖高层所提供的接口)&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;六边形架构&quot;&gt;六边形架构&lt;/h3&gt;
&lt;p&gt;将业务放在了最中心&lt;br/&gt;&lt;code&gt;inbound adapter&lt;/code&gt;&lt;br/&gt;&lt;code&gt;outbound adapter&lt;/code&gt;&lt;br/&gt;业务逻辑不依赖于adapter 相反是adapter依赖于业务逻辑&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1244488/201902/1244488-20190213010815889-2062967823.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一个业务逻辑有一个或多个&lt;code&gt;ports&lt;/code&gt;&lt;br/&gt;一个&lt;code&gt;port&lt;/code&gt;定义了一系列业务逻辑和外部交互的操作&lt;/p&gt;
&lt;p&gt;六边形架构最大的好处是将展示层和数据访问逻辑从业务逻辑中解耦&lt;/p&gt;
&lt;h2 id=&quot;the-microservice-architecture-is-an-architectural-style&quot;&gt;2.1.3. The microservice architecture is an architectural style&lt;/h2&gt;
&lt;p&gt;单体架构在implement view就是一个单独可执行的jar或war&lt;br/&gt;&lt;a href=&quot;http://microservices.io/patterns/monolithic.html&quot; class=&quot;uri&quot;&gt;http://microservices.io/patterns/monolithic.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://microservices.io/patterns/microservices.html&quot; class=&quot;uri&quot;&gt;http://microservices.io/patterns/microservices.html&lt;/a&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1244488/201902/1244488-20190213010839549-1161206549.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;什么是服务&quot;&gt;什么是服务&lt;/h3&gt;
&lt;p&gt;服务是独立的 无依赖的可部署软件组件 实现了一些有用的功能&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1244488/201902/1244488-20190213010850162-1923323128.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不同服务间只能通过API调用 不像单体还可以通过代码&lt;/p&gt;
&lt;h3 id=&quot;松耦合&quot;&gt;松耦合&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Loose_coupling&quot; class=&quot;uri&quot;&gt;https://en.wikipedia.org/wiki/Loose_coupling&lt;/a&gt;&lt;br/&gt;服务间的交互只通过API 封装细节&lt;/p&gt;
&lt;h3 id=&quot;共享库&quot;&gt;共享库&lt;/h3&gt;
&lt;p&gt;只在不太可能会发生变化的地方使用共享库&lt;br/&gt;和具体业务无关 通用的功能上&lt;/p&gt;
&lt;h3 id=&quot;服务的大小不重要&quot;&gt;服务的大小不重要&lt;/h3&gt;
&lt;p&gt;和组织结构相关&lt;/p&gt;

&lt;p&gt;3步定义应用的微服务架构&lt;br/&gt;这里只是展示一个例子 现实中会有更多的问题&lt;br/&gt;需要迭代等&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1244488/201902/1244488-20190213010902827-949019283.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第一步找到服务的具体操作 这里定义为了&lt;code&gt;system operation&lt;/code&gt;&lt;br/&gt;其实也就是找到各个请求和回应(或者找到各个事件)&lt;br/&gt;服务拆分的一些阻碍:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;网络延迟&lt;/li&gt;
&lt;li&gt;服务间的同步调用降低了可用性&lt;/li&gt;
&lt;li&gt;在不同服务间维持数据一致性&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;identifying-the-system-operations&quot;&gt;2.2.1. Identifying the system operations&lt;/h2&gt;
&lt;p&gt;从应用的需求出发 包括user story和对应的用户场景&lt;/p&gt;
&lt;p&gt;有两种类型的&lt;code&gt;system operation&lt;/code&gt;&lt;br/&gt;commands:创建 更新和删除数据&lt;br/&gt;queries: 查询数据&lt;/p&gt;
&lt;p&gt;分析user stories和场景中的动词&lt;br/&gt;一个例子:&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1244488/201902/1244488-20190213011117033-940471440.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;defining-services-by-applying-the-decompose-by-business-capability-pattern&quot;&gt;2.2.2. Defining services by applying the Decompose by business capability pattern&lt;/h2&gt;
&lt;p&gt;通过业务能力分解&lt;br/&gt;&lt;a href=&quot;http://microservices.io/patterns/decomposition/decompose-by-business-capability.html&quot; class=&quot;uri&quot;&gt;http://microservices.io/patterns/decomposition/decompose-by-business-capability.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1244488/201902/1244488-20190213011136593-1822789472.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;业务能力 子能力以及与服务的对应&lt;/p&gt;
&lt;p&gt;但业务变迁&lt;br/&gt;频繁的RPC带来的性能损耗&lt;br/&gt;会带来一定的阻碍&lt;/p&gt;
&lt;h2 id=&quot;defining-services-by-applying-the-decompose-by-sub-domain-pattern&quot;&gt;2.2.3. Defining services by applying the Decompose by sub-domain pattern&lt;/h2&gt;
&lt;p&gt;DDD&lt;br/&gt;subdmain&lt;br/&gt;bounded context&lt;br/&gt;&lt;a href=&quot;http://microservices.io/patterns/decomposition/decompose-by-subdomain.html&quot; class=&quot;uri&quot;&gt;http://microservices.io/patterns/decomposition/decompose-by-subdomain.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1244488/201902/1244488-20190213011153564-1888824784.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;decomposition-guidelines&quot;&gt;2.2.4. Decomposition guidelines&lt;/h2&gt;
&lt;p&gt;一些分解的原则&lt;br/&gt;可以沿用一些OO里的原则&lt;/p&gt;
&lt;h3 id=&quot;单一职责原则&quot;&gt;单一职责原则&lt;/h3&gt;
&lt;h3 id=&quot;共同封闭原则common-closure-principle&quot;&gt;共同封闭原则(Common Closure Principle)&lt;/h3&gt;
&lt;p&gt;因为一个相同的原因导致两个类需要修改 这两个类应该在一个包下&lt;br/&gt;对应于微服务 把要因为同一个原因修改的组件放到同一个服务里去&lt;/p&gt;
&lt;p&gt;通过业务能力和子域 结合SRP和CCP是一个很好的分解一个应用到服务的技术&lt;br/&gt;为了应用他们成功地开发微服务架构 你必须解决一些事务管理和跨进程通信问题&lt;/p&gt;
&lt;h2 id=&quot;obstacles-to-decomposing-an-application-into-services&quot;&gt;2.2.5. Obstacles to decomposing an application into services&lt;/h2&gt;
&lt;p&gt;一些阻碍:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;网络延迟&lt;/li&gt;
&lt;li&gt;同步通信导致的可用性降低&lt;/li&gt;
&lt;li&gt;跨服务的数据一致性维护&lt;/li&gt;
&lt;li&gt;获取数据的一致性视图&lt;/li&gt;
&lt;li&gt;上帝类阻止分解&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;网络延迟&quot;&gt;网络延迟&lt;/h3&gt;
&lt;p&gt;网络延迟是分布式系统长期困扰的问题.&lt;br/&gt;服务拆解之后可能会发现有大量的服务间的往返通信&lt;br/&gt;可以提供批处理API在一次往返中&lt;br/&gt;但一些其他场景 可能就需要整合服务了&lt;/p&gt;
&lt;h3 id=&quot;同步通信导致的可用性降低&quot;&gt;同步通信导致的可用性降低&lt;/h3&gt;
&lt;p&gt;改进方法是异步消息传输&lt;/p&gt;
&lt;h3 id=&quot;跨服务的数据一致性维护&quot;&gt;跨服务的数据一致性维护&lt;/h3&gt;
&lt;p&gt;涉及到分布式事务 saga 最终一致性&lt;/p&gt;
&lt;h3 id=&quot;获取数据的一致性视图&quot;&gt;获取数据的一致性视图&lt;/h3&gt;
&lt;p&gt;实践中一般不会是太大的问题&lt;/p&gt;
&lt;h3 id=&quot;上帝类阻止分解&quot;&gt;上帝类阻止分解&lt;/h3&gt;
&lt;p&gt;上帝类(god classes)是一个庞大的类 在整个项目中被贯穿使用&lt;br/&gt;一般都是为了实现了一个应用不同方面的业务逻辑 有大量的field&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1244488/201902/1244488-20190213011219565-1974762110.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;方案1:&lt;br/&gt;提供一个库 并创建一个中央的order数据库&lt;br/&gt;问题是紧耦合…所有的服务都要连到这个库&lt;/p&gt;
&lt;p&gt;方案2:&lt;br/&gt;封装order数据库到order服务&lt;br/&gt;这样就把他变为了类似数据库API的服务 只是为了提供order数据库的访问而存在&lt;/p&gt;
&lt;p&gt;方案3:&lt;br/&gt;使用DDD 将order的概念分解 各个子域有自己的order&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1244488/201902/1244488-20190213011237612-887560591.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但这样会影响用户体验 在用户体验和多个实际模型间要有一种翻译&lt;/p&gt;
&lt;h2 id=&quot;defining-service-apis&quot;&gt;2.2.6. Defining service APIs&lt;/h2&gt;
&lt;p&gt;定义服务API&lt;br/&gt;他的操作和事件&lt;/p&gt;
&lt;p&gt;基于两点:&lt;br/&gt;1.&lt;code&gt;System operation&lt;/code&gt;需要&lt;br/&gt;这个API可能是被客户端直接调用 也可能是服务端直接调用 用来完成这个服务里的某个具体操作&lt;/p&gt;
&lt;p&gt;2.支持服务间协作&lt;br/&gt;为其他服务的实现提供一些帮助&lt;/p&gt;
</description>
<pubDate>Tue, 12 Feb 2019 17:15:00 +0000</pubDate>
<dc:creator>fairjm</dc:creator>
<og:description>Microservice Patterns第二章的读书笔记 原章节链接: 'https://learning.oreilly.com/library/view/microservices patter</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fairjm/p/Microservices_Patterns_ch2_notes.html</dc:identifier>
</item>
<item>
<title>做了十年的程序员，为什么我没有加班 - 自由飞</title>
<link>http://www.cnblogs.com/freeflying/p/10367679.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/freeflying/p/10367679.html</guid>
<description>&lt;p&gt;十年老码农，基本上没怎么加过班。所以很长一段时间听说程序员怎么怎么加班怎么怎么过劳，都以为是谣言。后来接触的朋友多了，才慢慢明白为什么我不加班，大概几个原因：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;用的是.NET&lt;/li&gt;
&lt;li&gt;非互联网行业&lt;/li&gt;
&lt;li&gt;欧美外资企业&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;上述3个原因，第1个原因是根本原因，O(∩_∩)O哈哈~&lt;/p&gt;

&lt;p&gt;很多同学觉得第3条才是根本原因。确实，有些用.NET的私营企业/互联网企业，一样加班；欧美外资企业即使用Java用PHP，一样不加班。但是，我想强调的是：为什么国内企业用.NET的越来越少，但欧美外资用.NET的却越来越多？&lt;/p&gt;
&lt;p&gt;这些事，也只有我们这种老码农才知道了。简单的说，其实就四句话：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;以前用.NET是要给微软交钱的&lt;/li&gt;
&lt;li&gt;国内知识产权保护越来越严厉&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;欧美发达国家的人工很贵&lt;/li&gt;
&lt;li&gt;现在.NET开源和跨平台了&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;具体点说，以前，我一定要强调以前，用.NET，尤其是ASP.NET，是要给微软一大笔钱的，包括但不限于：Windows Server要收费，MS Sql要收费，Visual Studio要收费……而且这些费用都不低！&lt;/p&gt;
&lt;p&gt;但是，这笔钱对于国内企业来说都不是事儿。我还是要强调，是以前。我第一家公司，服务器都是盗版的，微软发律师函，直接扔垃圾桶里。但现在肯定不行了，不光是服务器，公司内部使用的Visual Studio，甚至Office，都有可能会被微软带工商过来查，查到了就惨了——只有你公司还有钱。&lt;/p&gt;
&lt;p&gt;而互联网公司是不可能缺钱的，缺钱的都已经死掉了。所以，国内使用.NET的越来越少，尤其是互联网行业。贵啊！这些东西，真贵。Visual Studio每个开发人手一套，Windows Server动不动就是做集群，SQL server按CPU收费（记得）……全都是白花花的银子啊！用Java，或者PHP，配合MySql啥的，就完全没有这笔费用，多爽？&lt;/p&gt;

&lt;p&gt;但是，注意这个但是，即使是在以前，.NET需要这么多额外费用的时候，一样很多欧美企业选择.NET，为什么？因为这些国家的人工太贵了。&lt;/p&gt;
&lt;p&gt;.NET开发，就一个字：爽。一定要再加一个字，那就是：快。连起来：爽快！&lt;/p&gt;
&lt;p&gt;不管是以前被鄙视的“拖控件”，还是现在大家都承认的“宇宙最强IDE”，都是这两个字的体现。对企业而言，就是节省了人工。体现在很多方面，比如.NET开发人员的工资会低一点，毕竟这门技术的门槛要低一点，最直观的就是windows server，图形化界面，肯定比Linux简单吧？也不一定需要养着几个大牛，用的是微软的产品，复杂的问题有微软提供的售后专家团队帮你搞定……&lt;/p&gt;
&lt;p&gt;说白了，欧美这些企业家，宁愿把钱给微软，也不愿意给开发人员。这也是为什么传统企业愿意更愿意用.NET的原因之一，传统企业，是宁愿相信机器或者机构，而不愿意相信人（员工）的。微软是一家信得过的公司，.NET是她的产品（机器），开发人员不过是使用这个机器的人。哪个工厂会由工人来定机器，而且用一套没有生产厂家、没有质量检测报告、没有售后服务的三无产品（仔细想想，开源是不是这样的）？天方夜谭啊，简直是。&lt;/p&gt;
&lt;p&gt;上面说的，都是些老黄历了。大概两三年前吧，我懒得查了，.NET宣布开源和跨平台——因为扛不住了。互联网企业就特么这么奇葩，颠覆了太多的东西。典型的，什么都可以不要钱。做出来的产品，你随便用，不收钱！百度google，QQ微信，各种乱七八糟的网站APP，不用你盗版，直接给你免费用！当然，免费的东西，你就不要太奢求质量了……所以，微软卖产品那一套，越来越尴尬了。&lt;/p&gt;
&lt;p&gt;微软当然不能坐以待毙，最终宣布开源跨平台——其实就是免费。开源，代码（产品）你随便用；跨平台，Linux/iOS上面也可以跑。Visual Studio出社区版，MS Sql还扛着的，没有免费，但你完全可以用mysql……这下，应该是把之前交钱的那些企业给乐坏了！甚至我记得在.NET宣布这个消息的时候，很多人忍不住的问：这下JAVA是不是真的要死了？&lt;/p&gt;
&lt;p&gt;当然Java没死，Android救了它。而且Java使用这么广泛的一门语言，像一个网友说的：就算你都死了，Java也不会死！——有点刻薄，但确实如此。&lt;/p&gt;
&lt;p&gt;Java不会死，.NET也不会死，一个语言或者平台，最危险的时候，是它问世的那几年，要死，最有可能就死在那时候，.NET早已度过了这段时期。从2002年问世，.NET已经诞生16年了，旗下的C#，在Tiobe排行中，很早就占据了第5的位置，之后就没跌出过前7（我是这样记得的），查一下吧：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;img-responsive&quot; title=&quot;&quot; src=&quot;http://17bang.ren/Images/Attachment/2019/2/13/fe797ff3-cd44-4603-9433-6592ddf5b2ff.png&quot; alt=&quot;&quot; data-original-title=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;最意料之外的是，Java居然一直保持着下降趋势，呵呵。&lt;/li&gt;
&lt;li&gt;其次是VB.NET的异军突起，居然在2018年开始超过了C#？&lt;/li&gt;
&lt;li&gt;Javascript也让我有点意外，某乎上前端闹成了一锅粥，以为火得一塌糊涂，其实长期来看也就那样，没啥变化。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;最意料之中的是，SQL无比的稳定，简直就是一条水平线。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;其次是C++持续下滑，很好理解，桌面程序的时代已经越来越远了；PHP从2010开始也一直在走下坡路，当然是被ASP.NET和Java Web给挤的，而且它作为一个脚本语言，也越来越不适合越来越大规模的Web应用。&lt;/li&gt;
&lt;li&gt;不能理解的是C，实际项目中这么可能有这么大的份额？我严重怀疑是因为大学计算机专业的课程设置。而且不明白为什么在2016年到2018年这两年间突然下滑。&lt;br/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;大家可以去网站里看看，&lt;a href=&quot;https://www.tiobe.com/tiobe-index/&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;https://www.tiobe.com/tiobe-index/&lt;/a&gt;，还蛮有意思的。&lt;/p&gt;
&lt;p&gt;一不小心跑题了，但我还是想说：考虑.NET平台的实力，至少应该把C#和VB.NET加在一起算才对，他们都是.NET平台下的语言。那么按2019年2月的统计，他们占了2.846%+7.095%=9.941%的份额，仅次于Java和C。考虑到MSDN良好的文档（所以不用使用搜索引擎），.NET非学院派的背景（很大大学教学使用的都是Java和C），这个成绩简直是牛逼到爆！&lt;/p&gt;
&lt;p&gt;前面说的是企业为什么选择.NET，和加班啥关系呢？&lt;/p&gt;
&lt;p&gt;你必须要明白，人力成本高，通常就意味着劳动法律健全。或者说对劳动者的保护更有力。我忘了那里看到的一个理论：如果没有劳动法的保护，工人的平均工资永远只能维持在“勉强活着”的水平。禁止加班，或者说加班要给加班费，是劳动法的基本要求。这些企业在这种法治环境下已经形成了习惯：让员工无偿加班是可耻的，更是违法的！&lt;/p&gt;
&lt;p&gt;但对比中国的互联网企业，呵呵。前段时间，哪家公司，还有点名气的，现在名气更大了，居然在年会上公然要求“全面996”，“没时间陪家人就离婚”？在这一点上，很多互联网企业，还比不上一些传统企业，人家至少知道加班了要给加班费。当然，换个角度想想，互联网行业工资这么高，也可以算做“已经含了加班费”啦。&lt;/p&gt;

&lt;p&gt;最后最后，大过节的，我都没想到，Java和.NET之争在园子里又火了一把。我已经来晚了，就提供一个视角：Java的工资真的比.NET高么？你算的是月薪还是时薪？996比965高个百分之十百分之二十真的那么有意思？另外，学Java就真的好找工作？Java的岗位需求和.NET相比，是3:1的比例，但学Java的同学和学.NET同学的比例呢？我估计30:1都不止吧？而且学Java的，多半都是科班生哟。你培训班毕业的，和他们去争，呵呵……&lt;/p&gt;
&lt;p&gt;随便说说，大家自己考虑。反正飞哥的“源栈”就18张床位18张桌子，我是无所谓的，不可能这么大一个中国，18个愿意学.NET都没有。&lt;/p&gt;

&lt;p&gt;+++++++++++++++++&lt;/p&gt;

&lt;p&gt;最后，想招一个“半工半读”的软妹子，在“源栈”学习开发之余，能帮我干点杂活，大概就是招生（在QQ群里回答咨询）/行政（淘宝上买点东西啥的）/其他日常管理事项吧。可以视情况减免学费、提供津贴等，最好相貌清秀、温柔细心，别买个床垫搞成这样就行：&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/49387/201902/49387-20190213005553182-225662947.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;欢迎毛遂自荐或者推荐，有意的加QQ群：729600626，有意向只参加“源栈”培训的，也可以加这个群。&lt;/p&gt;
&lt;p&gt;文章欢迎转载，但别把我最后的招聘删了，^_^&lt;/p&gt;
</description>
<pubDate>Tue, 12 Feb 2019 16:54:00 +0000</pubDate>
<dc:creator>自由飞</dc:creator>
<og:description>十年老码农，基本上没怎么加过班。所以很长一段时间听说程序员怎么怎么加班怎么怎么过劳，都以为是谣言。后来接触的朋友多了，才慢慢明白为什么我不加班，大概几个原因： 上述3个原因，第1个原因是根本原因，O(</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/freeflying/p/10367679.html</dc:identifier>
</item>
<item>
<title>三种方法为QLineEdit添加清除内容按钮 - apocelipes</title>
<link>http://www.cnblogs.com/apocelipes/p/10367521.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/apocelipes/p/10367521.html</guid>
<description>&lt;p&gt;很多时候我们会发现输入的一长串内容不得不全部删除重新输入，这时比起一直按着退格键不放一个清除内容按钮更受欢迎。&lt;/p&gt;
&lt;p&gt;今天我将介绍三种为QLineEdit添加清除内容按钮的方法，其中两种方法有较强的功能针对性，另一种方法则是通用的，不仅可以用来实现清除输入内容，还可以扩展出其他功能。&lt;/p&gt;
&lt;blockquote id=&quot;bookmark&quot;&gt;
&lt;h4&gt;本文索引&lt;/h4&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;plan1&quot;&gt;方法1：setClearButtonEnabled显示清除按钮&lt;/h2&gt;
&lt;p&gt;这是Qt5.2之后提供的方法，当使用了&lt;code&gt;setClearButtonEnabled(true);&lt;/code&gt;之后会在 QLineEdit的右侧显示一个图标为&lt;code&gt;QStyle::SP_DialogResetButto&lt;/code&gt;的QAction，点击后会清除输入内容：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// 方案1
auto edit1 = new QLineEdit;
edit1-&amp;gt;setClearButtonEnabled(true);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1434464/201902/1434464-20190212230823154-2067997125.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看到右边那个图标，如果是Qt自带的话会是一个类似扫把的图形，如果使用了系统主题那么会有些许差异，点击它，输入内容就会全部清除。&lt;/p&gt;
&lt;h2 id=&quot;plan2&quot;&gt;方法2：使用QAction实现清除按钮&lt;/h2&gt;
&lt;p&gt;如前所述，&lt;code&gt;setClearButtonEnabled&lt;/code&gt;其实只是让实现存在的QAction显示出来而已，所以我们也可以自己实现这一过程。&lt;/p&gt;
&lt;p&gt;要实现这一功能，需要Qt5.2之后提供的&lt;code&gt;addAction&lt;/code&gt;方法。它负责把一个QAction添加到edit的指定位置。&lt;/p&gt;
&lt;p&gt;不过要注意的是，这个QAction只能显示出图标，文字内容的显示不出的。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// 方案2
auto clearAction = new QAction;
clearAction-&amp;gt;setIcon(QApplication::style()-&amp;gt;standardIcon(QStyle::SP_DialogResetButton));
auto edit2 = new QLineEdit;
// QLineEdit::TrailingPosition表示将action放置在右边
edit2-&amp;gt;addAction(clearAction, QLineEdit::TrailingPosition);
QObject::connect(clearAction,
      &amp;amp;QAction::triggered,
      edit2,
      [edit2]{ edit2-&amp;gt;setText(&quot;&quot;); });&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为我们知道lineedit默认使用的清除按钮的图标，也知道如何清除输入，所以可以自己实现这一过程。&lt;/p&gt;
&lt;p&gt;这是效果，与方法1时几乎没什么区别：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1434464/201902/1434464-20190212230758946-1389389609.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不过方法二的威力不止于此，基于我们可以使用自己的QAction，那么就可以定制一些操作，比如使用我们自己的图标:&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;clearAction-&amp;gt;setIcon(QIcon(&quot;:/clear.png&quot;));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1434464/201902/1434464-20190212230746750-260459178.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这种方法相比前一种略显复杂，然而却提供了更好的扩展性。&lt;/p&gt;
&lt;p&gt;接下来要介绍的最后一种方法更加的灵活，你不仅可以显示自定义图标，还可以显示自定义文字，当然作为代价它比第二种方法要复杂不少。&lt;/p&gt;
&lt;h2 id=&quot;plan3&quot;/&gt;
&lt;p&gt;方法3：自定义QLineEdit为其添加按钮&lt;br/&gt;这种方法对Qt的版本没有什么要求，所以它也足够通用。&lt;/p&gt;
&lt;p&gt;想要在QLineEdit上添加一个widget一点也不复杂，首先我们要弄清以下几个原理：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;qt的widget和layout是可以堆叠的，之前在&lt;a href=&quot;https://www.cnblogs.com/apocelipes/p/10268108.html&quot;&gt;实现半透明遮罩&lt;/a&gt;中有提过&lt;/li&gt;
&lt;li&gt;你可以为QLineEdit设置layout，如你所料layout会堆叠在edit的输入框上&lt;/li&gt;
&lt;li&gt;edit的layout会只使用控件的最小尺寸，这样不会导致将整个输入框遮盖掉&lt;/li&gt;
&lt;li&gt;edit的可输入区域是可以设置的，你可以合理的设置输入区的大小避免文字进入layout之下被遮盖&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所以如果我们想为QLineEdit或是其派生类添加一个widget比如QPushButton，那么需要如下几部：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;创建你需要的widget以及一个布局管理器&lt;/li&gt;
&lt;li&gt;添加拉伸因子和widget至布局管理器，拉伸因子可以不添加，只要设置好布局管理器的排列方向即可&lt;/li&gt;
&lt;li&gt;设置布局管理器里组件的排列方向并把布局管理器添加到QLineEdit&lt;/li&gt;
&lt;li&gt;获取你添加的widget的宽度，然后在加上合适的边框距离，将QLineEdit的输入区域限制在合理的大小&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;说起来简单做起来难，我们边看代码边讲解。&lt;/p&gt;
&lt;p&gt;我们先看类的定义，&lt;code&gt;ButtonEdit&lt;/code&gt;是一个带有按钮的QLineEdit：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include &amp;lt;QWidget&amp;gt;
#include &amp;lt;QLineEdit&amp;gt;
#include &amp;lt;QPushButton&amp;gt;
#include &amp;lt;QString&amp;gt;
#include &amp;lt;QIcon&amp;gt;

class ButtonEdit: public QLineEdit {
    Q_OBJECT
public:
    explicit ButtonEdit(const QString &amp;amp;btnText, QWidget *parent = nullptr);
    explicit ButtonEdit(const QIcon &amp;amp;icon, QWidget *parent = nullptr);
    ~ButtonEdit() override = default;

private:
    // 设置文本按钮或图标按钮的大小和外观
    void setTextButton();
    void setIconButton();
    // 将按钮添加到edit
    void addButton();

    QPushButton *button;

Q_SIGNALS:
    void buttonClicked(bool);
};

// 按钮和输入内容的边距
constexpr int buttonMargin = 3;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们的类可以从一个string或者icon构建，当edit的按钮被点击那么我们就发出&lt;code&gt;buttonClicked&lt;/code&gt;信号。&lt;/p&gt;
&lt;p&gt;也许你会觉得对于按钮的设置分成两类没什么必要。事实不然，图形应用的开发有很多麻烦事，而其中比较头疼的要数如何让控件保持一个恰到好处的尺寸，而对于图标的处理和文本是不一样的，所以有分开的必要。当然，如果你不介意文字或者图标只显示一半或者突出到编辑框的话也可以跳过这一步。&lt;/p&gt;
&lt;p&gt;下面我们来看下类成员的实现，构造函数没什么亮点，无非构造button，然后交由其他成员去处理：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;ButtonEdit::ButtonEdit(const QString &amp;amp;btnText, QWidget *parent)
 : QLineEdit(parent)
{
    button = new QPushButton(btnText);
    setTextButton();
    addButton();
}

ButtonEdit::ButtonEdit(const QIcon &amp;amp;icon, QWidget *parent)
 : QLineEdit(parent)
{
    button = new QPushButton;
    button-&amp;gt;setIcon(icon);
    setIconButton();
    addButton();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接着是&lt;code&gt;addButton&lt;/code&gt;，在这里我们先把button添加进layout，随后又设置了输入区域的大小避免输入内容被遮住：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void ButtonEdit::addButton() {
    connect(button,
            &amp;amp;QPushButton::clicked,
            this,
            &amp;amp;ButtonEdit::buttonClicked);
    // 按钮已经是edit的一部分了，不应该再能被单独聚焦，否则可能导致误触
    button-&amp;gt;setFocusPolicy(Qt::NoFocus);
    // 设置鼠标，否则点击按钮时仍然会显示输入内容是的鼠标图标
    button-&amp;gt;setCursor(Qt::ArrowCursor);

    auto btnLayout = new QHBoxLayout;
    btnLayout-&amp;gt;addStretch();
    btnLayout-&amp;gt;addWidget(button);
    // 设置组件右对齐，按钮会显示在edit的右侧
    btnLayout-&amp;gt;setAlignment(Qt::AlignRight);
    btnLayout-&amp;gt;setContentsMargins(0, 0, 0, 0);
    setLayout(btnLayout);
    // 设置输入区域的范围，从edit的最左到按钮的最左(包含了按钮设置的buttonMargin)
    setTextMargins(0, 0, button-&amp;gt;width(), 0);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面就是如何设置button的大小和样式了，大小我们设置和图标/文本的大小一样大，然后两边加上&lt;code&gt;buttonMargin&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;对于图标按钮我们还要设置按钮背景平时不可见，毕竟图标周围有个&lt;code&gt;buttonMargin&lt;/code&gt;宽度的框不太好看：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// 帮助函数，设置按钮的width，大小策略为fixed，不可放大或缩小
static void setButtonSize(QPushButton *button, int width) {
    auto policy = button-&amp;gt;sizePolicy();
    policy.setHorizontalPolicy(QSizePolicy::Fixed);
    button-&amp;gt;setSizePolicy(policy);
    // 固定宽度，加上边距
    button-&amp;gt;setFixedWidth(width + buttonMargin*2);
}

void ButtonEdit::setTextButton() {
    if (!button) {
        return;
    }

    // 获得当前字体下文本内容的像素宽度
    auto width = QWidget::fontMetrics().width(button-&amp;gt;text());
    setButtonSize(button, width);
}

void ButtonEdit::setIconButton() {
    if (!button) {
        return;
    }

    // 获取图标的width简单得多
    auto width = button-&amp;gt;iconSize().width();
    setButtonSize(button, width);
    // 设置背景和边框在非点击时不可见
    button-&amp;gt;setFlat(true);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在工作完成了，不管我们添加什么样的图标还是多长的文本，按钮都可以保证有一个合适的大小，输入内容也不会被按钮遮住。&lt;/p&gt;
&lt;p&gt;现在我们看下使用：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// 方案3
// 使用文本按钮
auto edit3_1 = new ButtonEdit(&quot;clear&quot;);
QObject::connect(edit3_1,
                &amp;amp;ButtonEdit::buttonClicked,
                edit3_1,
                [edit3_1]{ edit3_1-&amp;gt;setText(&quot;&quot;); });
// 使用图标按钮
auto edit3_2 = new ButtonEdit(QApplication::style()-&amp;gt;standardIcon(QStyle::SP_DialogResetButton));
QObject::connect(edit3_2,
                &amp;amp;ButtonEdit::buttonClicked,
                edit3_2,
                [edit3_2]{ edit3_2-&amp;gt;setText(&quot;&quot;); });&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1434464/201902/1434464-20190212230705789-129055682.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这种方案是最复杂的，但也是最灵活的，我们可以定制button的外观，通过&lt;code&gt;buttonClicked&lt;/code&gt;信号我们可以定制按钮按下后的行为。所以我在上一节才说这是扩展性最好的方法。&lt;/p&gt;
&lt;p&gt;不过方案二和三都有一个显著的缺点，即使输入框中没有内容按钮或QAction也会一直显示，有些时候这不是我们需要的行为。解决办法也很简单，合理利用QLineEdit的信号加上&lt;code&gt;QWidget::hide&lt;/code&gt;和&lt;code&gt;QAction::setVisible&lt;/code&gt;就能实现按钮的隐藏，这一功能的实现就当做练习吧。&lt;/p&gt;
&lt;h2 id=&quot;最终的显示效果&quot;&gt;最终的显示效果&lt;/h2&gt;
&lt;p&gt;现在我们将三种方法合并显示在一起，以便大家看到各个方案带来的显示效果：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include &amp;lt;QLineEdit&amp;gt;
#include &amp;lt;QApplication&amp;gt;
#include &amp;lt;QWidget&amp;gt;
#include &amp;lt;QAction&amp;gt;
#include &amp;lt;QObject&amp;gt;
#include &amp;lt;QIcon&amp;gt;
#include &amp;lt;QFormLayout&amp;gt;
#include &amp;lt;QStyle&amp;gt;

#include &quot;ButtonEdit&quot;

int main(int argc, char *argv[]) {
    QApplication app(argc, argv);

    // 方案1
    auto edit1 = new QLineEdit;
    edit1-&amp;gt;setClearButtonEnabled(true);

    // 方案2
    auto clearAction = new QAction;
    clearAction-&amp;gt;setIcon(QIcon(&quot;:/clear.png&quot;));
    auto edit2 = new QLineEdit;
    edit2-&amp;gt;addAction(clearAction, QLineEdit::TrailingPosition);
    QObject::connect(clearAction,
            &amp;amp;QAction::triggered,
            edit2,
            [edit2]{ edit2-&amp;gt;setText(&quot;&quot;); });

    // 方案3
    // 使用文本按钮
    auto edit3_1 = new ButtonEdit(&quot;clear&quot;);
    QObject::connect(edit3_1,
                     &amp;amp;ButtonEdit::buttonClicked,
                     edit3_1,
                     [edit3_1]{ edit3_1-&amp;gt;setText(&quot;&quot;); });
    // 使用图标按钮
    auto edit3_2 = new ButtonEdit(QApplication::style()-&amp;gt;standardIcon(QStyle::SP_DialogResetButton));
    QObject::connect(edit3_2,
                     &amp;amp;ButtonEdit::buttonClicked,
                     edit3_2,
                     [edit3_2]{ edit3_2-&amp;gt;setText(&quot;&quot;); });

    auto win = new QWidget;
    auto layout = new QFormLayout;
    layout-&amp;gt;addRow(&quot;方案1：&quot;, edit1);
    layout-&amp;gt;addRow(&quot;方案2：&quot;, edit2);
    layout-&amp;gt;addRow(&quot;方案3_1：&quot;, edit3_1);
    layout-&amp;gt;addRow(&quot;方案3_2：&quot;, edit3_2);
    win-&amp;gt;setLayout(layout);

    win-&amp;gt;show();

    return app.exec();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当无输入内容时：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1434464/201902/1434464-20190212230638647-2099047190.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当有输入内容时：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1434464/201902/1434464-20190212230621036-1065914811.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样三种方法都介绍完了，选用哪种需要自己决定。&lt;/p&gt;
&lt;p&gt;当然最后两种方案不仅仅能用来做清除内容按钮，只要加入一点点想象力还有更高级的功能可以用它们来实现。&lt;/p&gt;
</description>
<pubDate>Tue, 12 Feb 2019 15:10:00 +0000</pubDate>
<dc:creator>apocelipes</dc:creator>
<og:description>很多时候我们会发现输入的一长串内容不得不全部删除重新输入，这时比起一直按着退格键不放一个清除内容按钮更受欢迎。 今天我将介绍三种为QLineEdit添加清除内容按钮的方法，其中两种方法有较强的功能针对</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/apocelipes/p/10367521.html</dc:identifier>
</item>
<item>
<title>逆向分析-之深入理解函数 - 秃桔子</title>
<link>http://www.cnblogs.com/godoforange/p/10367470.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/godoforange/p/10367470.html</guid>
<description>&lt;p&gt;程序都是由具有不同功能的函数组成的，&lt;/p&gt;
&lt;p&gt;因此在逆向分析中将重点放在 函数的识别 和 参数的传递 上是明智的，&lt;/p&gt;
&lt;p&gt;这样做可以将注意力集中在某一段代码上。函数是一个程序模块，用来实现一个特定的功能。一个函数包括函数名，入口参数，返回值，函数功能等部分。&lt;/p&gt;
&lt;p&gt;1. 函数的识别&lt;/p&gt;
&lt;p&gt;　　程序通过调用程序来调用函数,在函数执行后又返回调用程序继续执行。函数如何知道要返回的函数的地址呢？&lt;/p&gt;
&lt;p&gt;　　实际上，调用函数的代码中保存了一个返回地址，该地址会与参数一起传递给被调用的函数。有多种方法可以实现这个功能，在绝大多数情况下，编译器都使用&lt;span&gt;call和ret 指令&lt;/span&gt;来调用函数及返回调用指令。&lt;/p&gt;
&lt;p&gt;　　call指令与跳转指令类似。&lt;/p&gt;
&lt;p&gt;　　不同的是，call指令保存返回信息，即将其之后的指令地址压入栈顶，当遇到ret指令时返回这个地址。&lt;/p&gt;
&lt;p&gt;　　也就是说，call指令给出的地址就是被调用函数的起始地址。ret指令则用于结束函数的执行(当然,不是所有的ret指令都标志着函数的结束)。&lt;/p&gt;
&lt;p&gt;　　通过这一机制可以很容易地把函数调用和其他跳转指令区分开来。&lt;/p&gt;
&lt;p&gt;　　因此，可以通过定位call机器指令或利用ret指令结束的标志来识别函数。call指令的操作数就是所调用函数的首地址。&lt;/p&gt;
&lt;p&gt;　　这种函数直接调用方式使程序变得很简单。&lt;/p&gt;
&lt;p&gt;2.函数的参数&lt;/p&gt;
&lt;p&gt;　　函数传递参数有3种方式，&lt;span&gt;栈方式&lt;/span&gt;，&lt;span&gt;寄存器方式&lt;/span&gt;以及通过全局变量进行&lt;span&gt;隐含参数传递方式&lt;/span&gt;。如果参数是通过栈传递的，就需要定义参数在栈中的顺序，并约定函数被调用后由谁来平衡栈。如果参数是通过寄存器传递的，就要确定参数存放在哪个寄存器中。&lt;/p&gt;
&lt;p&gt;　　每种机制都有优缺点，并且和使用的编译语言有关。&lt;/p&gt;
&lt;p&gt;　　(1)栈方式&lt;/p&gt;
&lt;p&gt;　　　　栈是一种先进后出的存储区，栈顶指针esp 指向栈中第一个可用的数据项。在调用函数时，调用者依此把参数压入栈，然后调用函数，函数被调用后，在栈中取得数据并进行计算。函数计算结束后，由调用者或函数本身修改栈，使栈恢复原样。即平衡。&lt;/p&gt;
&lt;p&gt;　　　　在参数的传递中有俩个很重要的问题：&lt;/p&gt;
&lt;p&gt;　　　　1.当参数个数多于1个时，按照什么顺序把参数压入栈？&lt;/p&gt;
&lt;p&gt;　　　　2.函数结束后,由谁来平衡栈？这些都必须有约定。这种在程序设计语言中为了实现函数调用而建立的协议称为调用约定。这种协议规定了函数中的参数传送方式，参数是否可变和由谁处理栈问题等。&lt;/p&gt;
&lt;p&gt;　　　　C举例子。C的参数传递顺序为从右到左，平衡栈者是调用者。&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
push param3//参数从右到左
push param2
push param1
call test1
add esp,0C;//平衡栈
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　函数对参数的存取及局部变量都是通过栈定义的，非优化编译器用一个专门的寄存器(通常是 ebp)对参数进行寻址。C,C++,pascal等高级语言的函数执行过程基本一致情况如下：&lt;/p&gt;
&lt;p&gt;　　　　调用者将函数（子程序）执行完毕时应返回的地址，参数压入栈。&lt;/p&gt;
&lt;p&gt;　　　　子程序使用 ”ebp指针+偏移量“对栈中的参数进行寻址并取出，完成操作&lt;/p&gt;
&lt;p&gt;　　　　子程序使用ret或retf返回 。此时CPU将eip置为栈中保存的地址，并继续执行它。&lt;/p&gt;
&lt;p&gt;　　　　栈在整个过程中发挥着非常重要的作用。栈是一个先进后出的区域，只有一个出口，即当前栈顶。栈操作的对象只能说双操作数(占4字节) 。&lt;/p&gt;
&lt;p&gt;　　　　在许多时候，编译器会按优化方式来编译程序，栈寻址稍有不同。这时，编译器为了节省ebp寄存器或尽可能减少代码以提高速度，会直接通过esp对参数进行寻址。esp的值在函数执行期间会发生变化，该变化出现在每次有数据进出栈时。要想确定对那个变量进行寻址，就要知道程序当前位置的esp的值，为此必须从函数的开始部分进行跟踪。&lt;/p&gt;
&lt;p&gt;　　　(2)利用寄存器传递参数&lt;/p&gt;
&lt;p&gt;　　　　寄存器传递参数的方式没有标准，所有与平台相关的方式都是由编译器开发人员制定的。尽管没有标准，但绝大多数编译器提供商都在不对兼容性进行声明的情况下遵循相应的规范，即fastcall规范。fastcall 顾名思义，特点就是快(因为它是靠寄存器传递参数的)&lt;/p&gt;
&lt;p&gt;　　　　不同编译器实现的Fastcall 稍有不同。Microsoft Visual C++ 编译器在采用Fastcall 规范传递参数时，左边的2个不大于4字节的参数分别放在ecx和edx寄存器中，寄存器用完后就要使用栈，其余参数仍按照从左到右的顺序压入栈，被调用的函数在返回前清理传送参数的栈，浮点值，远指针和__int64 类型总是通过栈来传递的。而Borland Delphi/C++ 编译器在采用Fastcall 规范传递参数时候，左边的3个不大于4字节(dword)的参数分别放在eax,edx,和ecx寄存器中，寄存器使用完之后，其余参数按照从左到右的PASCAL方式压入栈。&lt;/p&gt;
&lt;p&gt;　　　　另有一款编译器Watcom C 总是通过寄存器来传递参数，它严格为每一个参数分配一个寄存器，默认情况下第一个参数用eax，第二个参数用edx，第三个参数用ebx，第四个阐述用ecx。如果寄存器用完，就会用栈来传递参数。因此，其参数实际上可能通过任何寄存器进行传递。&lt;/p&gt;
&lt;p&gt;　　　(3)名称修饰约定&lt;/p&gt;
&lt;p&gt;　　　　为了允许使用操作符和函数重载，C++编译器往往会按照某种规则改写每一个入口点的符号名，从而允许同一个名字(具有不同的参数类型或者不同的作用域) 有多个用法且不会破坏现有的基于C的链接器。这项技术通常称为名称改编或者名称修饰。许多C++编译器厂商都制定了自己的名称修饰方案。&lt;/p&gt;
&lt;p&gt;　　　　在VC++中，函数修饰名由变异类型（C或C++），函数名，类名，调用约定，返回类型，参数等共同决定。关于名称的内容很多，&lt;/p&gt;
&lt;p&gt;　　　　　stdcall调用约定在输出函数名前面加一个下划线前缀，在后面加一个”@“符号以及参数的字节数，格式为”_functionname@number“&lt;/p&gt;
&lt;p&gt;　　　　_cdecl调用约定仅在输出函数名前面加一个下划线前缀，格式为”_functionname“&lt;/p&gt;
&lt;p&gt;　　　　Fastcall 调用约定在输出函数名前面加一个”@“符号，在后面加一个”@“符号及其参数的字节数，格式为”@functionname@number“&lt;/p&gt;
&lt;p&gt;3.函数的返回值&lt;/p&gt;
&lt;p&gt;　　函数被调用执行后，将向调用者返回1个或多个执行结果，称为函数返回值。返回值最常见的形式是return操作符，还有通过参数按传引用的方式返回值，通过全局变量返回值等。&lt;/p&gt;
&lt;p&gt;　　(1) 用return 操作符返回值&lt;/p&gt;
&lt;p&gt;　　　　在一般情况下，函数的返回值放在eax寄存器中返回，如果处理结果的大小超过eax寄存器的容量，其高32位就会放到edx寄存器中。&lt;/p&gt;
&lt;p&gt;　　(2)通过参数按照引用方式返回值&lt;/p&gt;
&lt;p&gt;　　　　给参数传递的方式有俩种，分别是传值和传引用。进行传值调用时，会建立参数的一份复本，并把它传给调用函数，在调用函数中修改参数的复本不会影响原始的变量值。&lt;/p&gt;
&lt;p&gt;　　　　传引用调用允许调用参数修改原始变量的值。调用某个函数，当把变量的地址传递给函数时，可以在函数中用间接运算符修改调用函数内存单元该变量的值。&lt;/p&gt;
</description>
<pubDate>Tue, 12 Feb 2019 14:56:00 +0000</pubDate>
<dc:creator>秃桔子</dc:creator>
<og:description>程序都是由具有不同功能的函数组成的， 因此在逆向分析中将重点放在 函数的识别 和 参数的传递 上是明智的， 这样做可以将注意力集中在某一段代码上。函数是一个程序模块，用来实现一个特定的功能。一个函数包</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/godoforange/p/10367470.html</dc:identifier>
</item>
<item>
<title>聊聊银企直联服务那些事 - good_andyxu</title>
<link>http://www.cnblogs.com/goodAndyxublog/p/10367408.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/goodAndyxublog/p/10367408.html</guid>
<description>&lt;h2 id=&quot;背景&quot;&gt;背景&lt;/h2&gt;
&lt;p&gt;相关 &lt;a href=&quot;https://wiki.mbalib.com/wiki/%E9%93%B6%E4%BC%81%E7%9B%B4%E8%81%94&quot;&gt;wiki&lt;/a&gt; 定义。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;银企直联是指集团企业在集团内部建立自己的资金管理系统，通过数据接口将内部资金管理系统与商业银行核心系统、网银或者现金管理平台实现联接。通过银企直联系统企业可实现实时帐户信息查询、明细查询、自动转帐、交易查询等功能。并且交易的实时性和方便性得到大幅提高。“银企直联”的应用特点是连接手段不限，公网、专线均可。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面说说一些使用银企直联的实际场景。&lt;/p&gt;
&lt;p&gt;公司一般都会在某个银行开设对公账户，相关款项需要通过该对公账户出款。使用对公账户出款需要使用企业网银，出款流程类似我们使用个人网银出款流程。&lt;/p&gt;
&lt;p&gt;若业务场景需要将商家的当天收款金额转账至其银行卡。未接入银企之前，财务同学需要登录企业网银，创建出款信息，然后插入银行 U 盾，确认出款。接入银企之后，可以实现自动将商家的金额汇总然后转账出款，无需繁琐的网银流程。这样可以与内部服务关联，实现线上化。&lt;/p&gt;
&lt;p&gt;当然银企服务还可以实现查找银行流水等功能。&lt;/p&gt;
&lt;p&gt;我司基于银企直联服务，开发了公司内部服务，很大程度解决财务打款，后期做账核对繁琐问题。&lt;/p&gt;
&lt;p&gt;现就将本人接入几家银行经历，谈谈银企直联服务接入流程。&lt;/p&gt;
&lt;h2 id=&quot;银企接入流程&quot;&gt;银企接入流程&lt;/h2&gt;
&lt;p&gt;银企接入流程：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;与银行签订相关服务，获取相关开发文档，以及生产相关配置参数。&lt;/li&gt;
&lt;li&gt;安装银企前置服务。&lt;/li&gt;
&lt;li&gt;根据文档接入相关接口。&lt;/li&gt;
&lt;li&gt;相关接口测试环境测试，完成测试报告，提交给银行。银行开通正式环境权限，然后在正式环境测试连通性。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;第一步一般由公司财务相关人员与银行客户经理商谈即可。&lt;/p&gt;
&lt;p&gt;第二步安装银企前置服务软件。整个银企服务一般由企业应用程序，银企前置程序，银行服务构成。三者关系见下图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2019/png/254022/1549888516180-435a0ff2-4799-411f-8f49-e338fbfdb6a4.png&quot; alt=&quot;部署图&quot;/&gt;&lt;/p&gt;
&lt;p&gt;企业内部程序根据银行文档组装报文，报文格式一般以 xml 为主。然后内部程序将报文通过 HTTP 或 Socket 方式发送至银行前置程序。银行前置程序接受报文，先进行相关报文格式校验，然后使用数字证书加密报文，发送至银行服务。最后银行前置程序验证银行服务返回报文，再将解析后报文返回企业内部程序。&lt;/p&gt;
&lt;p&gt;银行前置程序与银行服务连接有两种方式：&lt;/p&gt;
&lt;p&gt;公网连接，特点成本低，网速容易受外部网络环境影响。&lt;/p&gt;
&lt;p&gt;专线连接，采用专门线路物理连接企业与银行两端。该方式网速稳定，不易受外部网络环境影响。但是成本相对较高。&lt;/p&gt;
&lt;p&gt;需要注意的是，银企前置程序大都只能安装在 Windows 上，可能与银企直联所需要的 U 盾驱动只兼容 Windows 有关。有的银企前置程序为单独软件，需要安装，有的为 Java 程序，无需单独安装。&lt;/p&gt;
&lt;p&gt;第三步，根据银行开发文档接入相关接口。&lt;/p&gt;
&lt;p&gt;银企服务一般会提供转账，查询流水，查询余额等接口。&lt;/p&gt;
&lt;p&gt;第四步测试相关银企服务，有的银行需要在测试环境测试通过后，才能开通正式生产环境。&lt;/p&gt;
&lt;p&gt;目前已经开发的银行如下:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;[x] 招商银行&lt;/li&gt;
&lt;li&gt;[x] 建设银行&lt;/li&gt;
&lt;li&gt;[x] 宁波银行&lt;/li&gt;
&lt;li&gt;[x] 平安银行&lt;/li&gt;
&lt;li&gt;[x] 工商银行&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;相关银行开发经验&quot;&gt;相关银行开发经验&lt;/h2&gt;
&lt;h3 id=&quot;招商银行&quot;&gt;招商银行&lt;/h3&gt;
&lt;p&gt;招行银企前置程序需要单独安装，相关接口按照文档开发即可。招行开发文档比较完善，且存在相关 Demo，接入比较简单。&lt;/p&gt;
&lt;h3 id=&quot;建设银行&quot;&gt;建设银行&lt;/h3&gt;
&lt;p&gt;建行银企前置服务为 Java 程序，需要安装 JDK5+ 。&lt;/p&gt;
&lt;p&gt;建行银企前置程序需要设置操作员，需要提前在企业网银处设置，设置过程比较繁琐。&lt;/p&gt;
&lt;p&gt;建行开发文档未提供开发 Demo，可以向银行支持技术索取。企业程序向建行前置服务发送报文需要使用以下方式 &lt;strong&gt;requestXML='xml'&lt;/strong&gt; 。&lt;/p&gt;
&lt;h3 id=&quot;宁波银行&quot;&gt;宁波银行&lt;/h3&gt;
&lt;p&gt;这家银行相对坑爹，前期银行技术支持给错文档，且支持人员不知道前置机软件怎么安装。后经与其总行交谈，才获取接口等文档。&lt;/p&gt;
&lt;p&gt;前置程序需要单独安装，设置也比较麻烦，需要指定两个端口，一个为报文接受端口，一个为加密端口。&lt;/p&gt;
&lt;p&gt;宁波银行与上面银行不同之处在于，其每笔报文需要先通过登陆接口获取 session，然后再构建报文。转账接口报文需要先将报文发送到前置机加密，获取签名数据，然后将签名数据组装到报文中构成完整 xml。&lt;/p&gt;
&lt;p&gt;宁波银行前置程序使用 U 盾驱动兼容性较差，长时间使用过程中会出现 U 盾突然无法识别情况，需要重新插拔。&lt;/p&gt;
&lt;h3 id=&quot;平安银行&quot;&gt;平安银行&lt;/h3&gt;
&lt;p&gt;银行前置程序为 Java web，需要使用 JDK 6+ 版本。&lt;/p&gt;
&lt;p&gt;平安银行报文由报头加报文体构成。报文头按照固定格式拼接，报文体根据接口拼接。部分接口需要前置机加密，需要在前置机软件后台提前设置。&lt;/p&gt;
&lt;h3 id=&quot;工商银行&quot;&gt;工商银行&lt;/h3&gt;
&lt;p&gt;工行前期接入过程需要注意 U 盾自带驱动存在问题，需要使用特殊的驱动程序。&lt;/p&gt;
&lt;p&gt;U 盾证书刚开始拿到可能无法用于交易，需要银行人员分配证书权限。&lt;/p&gt;
&lt;h3 id=&quot;相关问题&quot;&gt;相关问题&lt;/h3&gt;
&lt;p&gt;下面说说接入或日常运维中中可能碰到的问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;转账掉单问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;银企转账接口，未返回一个不明确状态（成功或失败），这种情况我们称为掉单。&lt;/p&gt;
&lt;p&gt;导致掉单的原因可能为银行内部服务出错，或网络问题。&lt;/p&gt;
&lt;p&gt;对于这种掉单情况，需要配合使用银企查询接口，查询最终状态。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;银企前置程序并发问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;银企前置程序一般无法支持很高并发交易量，如招商银行文档就建议同时不超过 50 。若企业程序调用转账接口并发数较大，可以采用批量打包方式，每隔一段时间将所有交易组装成报文，然后调用银企批量转账接口。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;安全问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;企业内部服务与银企前置服务通讯报文一般都是未加密的明文，这个通讯过程比较容易被监听，篡改，安全性较低。&lt;/p&gt;
&lt;p&gt;我们之前做法为将银企服务与企业内部程序部署在企业内网。外部网络访问需通过相关 VPN 才能访问。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;转账时效&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;银企转账接口通常内部使用人行大小额系统或超级网银系统。采用系统不同，转账时效性也不同。&lt;/p&gt;
&lt;p&gt;大小额系统由大额支付系统与小额支付系统构成。小额系统全年无休，7x24 小时工作，金额小于 5W 的交易会采用小额系统。大额系统运行在工作日的 8:00 ~ 17:00，金额大于 5 W 以上的以上会使用大额系统。&lt;/p&gt;
&lt;p&gt;超级网银系统，央行第二代支付系统，交易限额为 5w,到账速度非常快，但是相对转账费率较高。&lt;/p&gt;
&lt;p&gt;对于非工作日大于 5w 的交易若想保证时效性，可以采用拆单方法，将一笔转账拆分成多笔转账出去。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;联行号/超级行号&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;银企转账接口，一般对于跨行转账，接口需要传入他行卡所在行的联行号/超级行号。联行号/超级行号相关资料可以让银行提供，但是不同银行给的资料可能不太相同。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;企业网银设置问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;前期接入过程，若报文组装正确，但是报文始终无法通过，多半由于权限未正常设置导致。一般需要登录企业网银单独设置权限，设置比较繁琐，且每家银行都不太一样，详情咨询银行客户经理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;银行 U 盾密码问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;银企程序每次启动运行前会读取加载 U 盾数字证书，读取过程需要输入 U 盾数字密码。需要注意输入正确密码，输错次数过多，会导致 U 盾被银行锁死无法使用。需要去银行解锁或重新申请新 U 盾。这个说多了都是泪。：（&lt;/p&gt;
&lt;h2 id=&quot;参考文档&quot;&gt;参考文档&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://wiki.mbalib.com/wiki/%E9%93%B6%E4%BC%81%E7%9B%B4%E8%81%94&quot;&gt;&lt;strong&gt;银企直联系统&lt;/strong&gt;&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://wiki.mbalib.com/wiki/%E5%B0%8F%E9%A2%9D%E6%89%B9%E9%87%8F%E6%94%AF%E4%BB%98%E7%B3%BB%E7%BB%9F&quot;&gt;&lt;strong&gt;小额批量支付系统&lt;/strong&gt;&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://wiki.mbalib.com/wiki/%E5%A4%A7%E9%A2%9D%E5%AE%9E%E6%97%B6%E6%94%AF%E4%BB%98%E7%B3%BB%E7%BB%9F&quot;&gt;&lt;strong&gt;大额实时支付系统&lt;/strong&gt;&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://wiki.mbalib.com/wiki/%E8%B6%85%E7%BA%A7%E7%BD%91%E9%93%B6&quot;&gt;&lt;strong&gt;超级网银&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 12 Feb 2019 14:37:00 +0000</pubDate>
<dc:creator>good_andyxu</dc:creator>
<og:description>背景 相关 'wiki' 定义。 银企直联是指集团企业在集团内部建立自己的资金管理系统，通过数据接口将内部资金管理系统与商业银行核心系统、网银或者现金管理平台实现联接。通过银企直联系统企业可实现实时帐</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/goodAndyxublog/p/10367408.html</dc:identifier>
</item>
<item>
<title>Golang之轻松化解defer的温柔陷阱 - Stefno</title>
<link>http://www.cnblogs.com/qcrao-2018/p/10367346.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qcrao-2018/p/10367346.html</guid>
<description>&lt;p&gt;&lt;code&gt;defer&lt;/code&gt;是Go语言提供的一种用于注册延迟调用的机制：让函数或语句可以在当前函数执行完毕后（包括通过return正常结束或者panic导致的异常结束）执行。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;defer&lt;/code&gt;语句通常用于一些成对操作的场景：打开连接/关闭连接；加锁/释放锁；打开文件/关闭文件等。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;defer&lt;/code&gt;在一些需要回收资源的场景非常有用，可以很方便地在函数结束前做一些清理操作。在打开资源语句的下一行，直接一句defer就可以在函数返回前关闭资源，可谓相当优雅。&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;f, _ := os.Open(&quot;defer.txt&quot;)
defer f.Close()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：以上代码，忽略了err, 实际上应该先判断是否出错，如果出错了，直接return. 接着再判断&lt;code&gt;f&lt;/code&gt;是否为空，如果&lt;code&gt;f&lt;/code&gt;为空，就不能调用&lt;code&gt;f.Close()&lt;/code&gt;函数了，会直接panic的。&lt;/p&gt;

&lt;p&gt;程序员在编程的时候，经常需要打开一些资源，比如数据库连接、文件、锁等，这些资源需要在用完之后释放掉，否则会造成内存泄漏。&lt;/p&gt;
&lt;p&gt;但是程序员都是人，是人就会犯错。因此经常有程序员忘记关闭这些资源。Golang直接在语言层面提供&lt;code&gt;defer&lt;/code&gt;关键字，在打开资源语句的下一行，就可以直接用&lt;code&gt;defer&lt;/code&gt;语句来注册函数结束后执行关闭资源的操作。因为这样一颗“小小”的语法糖，程序员忘写关闭资源语句的情况就大大地减少了。&lt;/p&gt;

&lt;p&gt;defer的使用其实非常简单：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;f,err := os.Open(filename)
if err != nil {
    panic(err)
}

if f != nil {
    defer f.Close()
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在打开文件的语句附近，用defer语句关闭文件。这样，在函数结束之前，会自动执行defer后面的语句来关闭文件。&lt;/p&gt;
&lt;p&gt;当然，defer会有小小地延迟，对时间要求特别特别特别高的程序，可以避免使用它，其他一般忽略它带来的延迟。&lt;/p&gt;

&lt;h2 id=&quot;defer的底层原理是什么&quot;&gt;defer的底层原理是什么？&lt;/h2&gt;
&lt;p&gt;我们先看一下官方对&lt;code&gt;defer&lt;/code&gt;的解释：&lt;/p&gt;
&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;Each time a “defer” statement executes, the function value and parameters to the call are evaluated as usual and saved anew but the actual function is not invoked. Instead, deferred functions are invoked immediately before the surrounding function returns, in the reverse order they were deferred. If a deferred function value evaluates to nil, execution panics when the function is invoked, not when the “defer” statement is executed.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;翻译一下：每次defer语句执行的时候，会把函数“压栈”，函数参数会被拷贝下来；当外层函数（非代码块，如一个for循环）退出时，defer函数按照定义的逆序执行；如果defer执行的函数为nil, 那么会在最终调用函数的产生panic.&lt;/p&gt;
&lt;p&gt;defer语句并不会马上执行，而是会进入一个栈，函数return前，会按先进先出的顺序执行。也说是说最先被定义的defer语句最后执行。先进先出的原因是后面定义的函数可能会依赖前面的资源，自然要先执行；否则，如果前面先执行，那后面函数的依赖就没有了。&lt;/p&gt;
&lt;p&gt;在defer函数定义时，对外部变量的引用是有两种方式的，分别是作为函数参数和作为闭包引用。作为函数参数，则在defer定义时就把值传递给defer，并被cache起来；作为闭包引用的话，则会在defer函数真正调用时根据整个上下文确定当前的值。&lt;/p&gt;
&lt;p&gt;defer后面的语句在执行的时候，函数调用的参数会被保存起来，也就是复制了一份。真正执行的时候，实际上用到的是这个复制的变量，因此如果此变量是一个“值”，那么就和定义的时候是一致的。如果此变量是一个“引用”，那么就可能和定义的时候不一致。&lt;/p&gt;
&lt;p&gt;举个例子：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;func main() {
    var whatever [3]struct{}
    
    for i := range whatever {
        defer func() { 
            fmt.Println(i) 
        }()
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;2
2
2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;defer后面跟的是一个闭包（后面会讲到），i是“引用”类型的变量，最后i的值为2, 因此最后打印了三个2.&lt;/p&gt;
&lt;p&gt;有了上面的基础，我们来检验一下成果：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;type number int

func (n number) print()   { fmt.Println(n) }
func (n *number) pprint() { fmt.Println(*n) }

func main() {
    var n number

    defer n.print()
    defer n.pprint()
    defer func() { n.print() }()
    defer func() { n.pprint() }()

    n = 3
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果是：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;3
3
3
0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第四个defer语句是闭包，引用外部函数的n, 最终结果是3;&lt;br/&gt;第三个defer语句同第四个；&lt;br/&gt;第二个defer语句，n是引用，最终求值是3.&lt;br/&gt;第一个defer语句，对n直接求值，开始的时候n=0, 所以最后是0;&lt;/p&gt;
&lt;h2 id=&quot;利用defer原理&quot;&gt;利用defer原理&lt;/h2&gt;
&lt;p&gt;有些情况下，我们会故意用到defer的先求值，再延迟调用的性质。想象这样的场景：在一个函数里，需要打开两个文件进行合并操作，合并完后，在函数执行完后关闭打开的文件句柄。&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;func mergeFile() error {
    f, _ := os.Open(&quot;file1.txt&quot;)
    if f != nil {
        defer func(f io.Closer) {
            if err := f.Close(); err != nil {
                fmt.Printf(&quot;defer close file1.txt err %v\n&quot;, err)
            }
        }(f)
    }

    // ……

    f, _ = os.Open(&quot;file2.txt&quot;)
    if f != nil {
        defer func(f io.Closer) {
            if err := f.Close(); err != nil {
                fmt.Printf(&quot;defer close file2.txt err %v\n&quot;, err)
            }
        }(f)
    }

    return nil
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的代码中就用到了defer的原理，defer函数定义的时候，参数就已经复制进去了，之后，真正执行close()函数的时候就刚好关闭的是正确的“文件”了，妙哉！可以想像一下如果不这样将f当成函数参数传递进去的话，最后两个语句关闭的就是同一个文件了，都是最后一个打开的文件。&lt;/p&gt;
&lt;p&gt;不过在调用close()函数的时候，要注意一点：先判断调用主体是否为空，否则会panic. 比如上面的代码片段里，先判断&lt;code&gt;f&lt;/code&gt;不为空，才会调用&lt;code&gt;Close()&lt;/code&gt;函数，这样最安全。&lt;/p&gt;
&lt;h2 id=&quot;defer命令的拆解&quot;&gt;defer命令的拆解&lt;/h2&gt;
&lt;p&gt;如果defer像上面介绍地那样简单（其实也不简单啦），这个世界就完美了。事情总是没这么简单，defer用得不好，是会跳进很多坑的。&lt;/p&gt;
&lt;p&gt;理解这些坑的关键是这条语句：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;return xxx&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面这条语句经过编译之后，变成了三条指令：&lt;/p&gt;
&lt;pre class=&quot;asm&quot;&gt;
&lt;code&gt;1. 返回值 = xxx
2. 调用defer函数
3. 空的return&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;1,3步才是Return 语句真正的命令，第2步是defer定义的语句，这里可能会操作返回值。&lt;/p&gt;
&lt;p&gt;下面我们来看两个例子，试着将return语句和defer语句拆解到正确的顺序。&lt;/p&gt;
&lt;p&gt;第一个例子：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;func f() (r int) {
     t := 5
     defer func() {
       t = t + 5
     }()
     return t
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;拆解后：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;func f() (r int) {
     t := 5
     
     // 1. 赋值指令
     r = t
     
     // 2. defer被插入到赋值与返回之间执行，这个例子中返回值r没被修改过
     func() {        
         t = t + 5
     }
     
     // 3. 空的return指令
     return
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里第二步没有操作返回值r, 因此，main函数中调用f()得到5.&lt;/p&gt;
&lt;p&gt;第二个例子：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;func f() (r int) {
    defer func(r int) {
          r = r + 5
    }(r)
    return 1
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;拆解后：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;func f() (r int) {
     // 1. 赋值
     r = 1
     
     // 2. 这里改的r是之前传值传进去的r，不会改变要返回的那个r值
     func(r int) { 
          r = r + 5
     }(r)
     
     // 3. 空的return
     return
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因此，main函数中调用f()得到1.&lt;/p&gt;
&lt;h2 id=&quot;defer语句的参数&quot;&gt;defer语句的参数&lt;/h2&gt;
&lt;p&gt;defer语句表达式的值在定义时就已经确定了。下面展示三个函数：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;func f1() {
    var err error
    
    defer fmt.Println(err)

    err = errors.New(&quot;defer error&quot;)
    return
}

func f2() {
    var err error
    
    defer func() {
        fmt.Println(err)
    }()

    err = errors.New(&quot;defer error&quot;)
    return
}

func f3() {
    var err error
    
    defer func(err error) {
        fmt.Println(err)
    }(err)

    err = errors.New(&quot;defer error&quot;)
    return
}

func main() {
    f1()
    f2()
    f3()
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;&amp;lt;nil&amp;gt;
defer error
&amp;lt;nil&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第1，3个函数是因为作为函数参数，定义的时候就会求值，定义的时候err变量的值都是nil, 所以最后打印的时候都是nil. 第2个函数的参数其实也是会在定义的时候求值，只不过，第2个例子中是一个闭包，它引用的变量err在执行的时候最终变成&lt;code&gt;defer error&lt;/code&gt;了。关于闭包在本文后面有介绍。&lt;/p&gt;
&lt;p&gt;第3个函数的错误还比较容易犯，在生产环境中，很容易写出这样的错误代码。最后defer语句没有起到作用。&lt;/p&gt;
&lt;h2 id=&quot;闭包是什么&quot;&gt;闭包是什么？&lt;/h2&gt;
&lt;p&gt;闭包是由函数及其相关引用环境组合而成的实体,即：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;闭包=函数+引用环境&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一般的函数都有函数名，但是匿名函数就没有。匿名函数不能独立存在，但可以直接调用或者赋值于某个变量。匿名函数也被称为闭包，一个闭包继承了函数声明时的作用域。在Golang中，所有的匿名函数都是闭包。&lt;/p&gt;
&lt;p&gt;有个不太恰当的例子，可以把闭包看成是一个类，一个闭包函数调用就是实例化一个类。闭包在运行时可以有多个实例，它会将同一个作用域里的变量和常量捕获下来，无论闭包在什么地方被调用（实例化）时，都可以使用这些变量和常量。而且，闭包捕获的变量和常量是引用传递，不是值传递。&lt;/p&gt;
&lt;p&gt;举个简单的例子：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;func main() {
    var a = Accumulator()

    fmt.Printf(&quot;%d\n&quot;, a(1))
    fmt.Printf(&quot;%d\n&quot;, a(10))
    fmt.Printf(&quot;%d\n&quot;, a(100))

    fmt.Println(&quot;------------------------&quot;)
    var b = Accumulator()

    fmt.Printf(&quot;%d\n&quot;, b(1))
    fmt.Printf(&quot;%d\n&quot;, b(10))
    fmt.Printf(&quot;%d\n&quot;, b(100))


}

func Accumulator() func(int) int {
    var x int

    return func(delta int) int {
        fmt.Printf(&quot;(%+v, %+v) - &quot;, &amp;amp;x, x)
        x += delta
        return x
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;(0xc420014070, 0) - 1
(0xc420014070, 1) - 11
(0xc420014070, 11) - 111
------------------------
(0xc4200140b8, 0) - 1
(0xc4200140b8, 1) - 11
(0xc4200140b8, 11) - 111&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;闭包引用了x变量，a,b可看作2个不同的实例，实例之间互不影响。实例内部，x变量是同一个地址，因此具有“累加效应”。&lt;/p&gt;
&lt;h2 id=&quot;defer配合recover&quot;&gt;defer配合recover&lt;/h2&gt;
&lt;p&gt;Golang被诟病比较多的就是它的error, 经常是各种error满天飞。编程的时候总是会返回一个error, 留给调用者处理。如果是那种致命的错误，比如程序执行初始化的时候出问题，直接panic掉，省得上线运行后出更大的问题。&lt;/p&gt;
&lt;p&gt;但是有些时候，我们需要从异常中恢复。比如服务器程序遇到严重问题，产生了panic, 这时我们至少可以在程序崩溃前做一些“扫尾工作”，如关闭客户端的连接，防止客户端一直等待等等。&lt;/p&gt;
&lt;p&gt;panic会停掉当前正在执行的程序，不只是当前协程。在这之前，它会有序地执行完当前协程defer列表里的语句，其它协程里挂的defer语句不作保证。因此，我们经常在defer里挂一个recover语句，防止程序直接挂掉，这起到了&lt;code&gt;try...catch&lt;/code&gt;的效果。&lt;/p&gt;
&lt;p&gt;注意，recover()函数只在defer的上下文中才有效（且只有通过在defer中用匿名函数调用才有效），直接调用的话，只会返回&lt;code&gt;nil&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;func main() {
    defer fmt.Println(&quot;defer main&quot;)
    var user = os.Getenv(&quot;USER_&quot;)
    
    go func() {
        defer func() {
            fmt.Println(&quot;defer caller&quot;)
            if err := recover(); err != nil {
                fmt.Println(&quot;recover success. err: &quot;, err)
            }
        }()

        func() {
            defer func() {
                fmt.Println(&quot;defer here&quot;)
            }()

            if user == &quot;&quot; {
                panic(&quot;should set user env.&quot;)
            }

            // 此处不会执行
            fmt.Println(&quot;after panic&quot;)
        }()
    }()

    time.Sleep(100)
    fmt.Println(&quot;end of main function&quot;)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的panic最终会被recover捕获到。这样的处理方式在一个http server的主流程常常会被用到。一次偶然的请求可能会触发某个bug, 这时用recover捕获panic, 稳住主流程，不影响其他请求。&lt;/p&gt;
&lt;p&gt;程序员通过监控获知此次panic的发生，按时间点定位到日志相应位置，找到发生panic的原因，三下五除二，修复上线。一看四周，大家都埋头干自己的事，简直完美：偷偷修复了一个bug, 没有发现！嘿嘿！&lt;/p&gt;

&lt;p&gt;defer非常好用，一般情况下不会有什么问题。但是只有深入理解了defer的原理才会避开它的温柔陷阱。掌握了它的原理后，就会写出易懂易维护的代码。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/7698088/51420568-305b1800-1bce-11e9-962a-52b12be7eb2e.png&quot; alt=&quot;QR&quot;/&gt;&lt;/p&gt;

&lt;p&gt;【defer那些事】&lt;a href=&quot;https://xiaozhou.net/something-about-defer-2014-05-25.html&quot; class=&quot;uri&quot;&gt;https://xiaozhou.net/something-about-defer-2014-05-25.html&lt;/a&gt;&lt;br/&gt;【defer代码案例】&lt;a href=&quot;https://tiancaiamao.gitbooks.io/go-internals/content/zh/03.4.html&quot; class=&quot;uri&quot;&gt;https://tiancaiamao.gitbooks.io/go-internals/content/zh/03.4.html&lt;/a&gt;&lt;br/&gt;【闭包】&lt;a href=&quot;https://www.kancloud.cn/liupengjie/go/576456&quot; class=&quot;uri&quot;&gt;https://www.kancloud.cn/liupengjie/go/576456&lt;/a&gt;&lt;br/&gt;【闭包】&lt;a href=&quot;http://blog.51cto.com/speakingbaicai/1703229&quot; class=&quot;uri&quot;&gt;http://blog.51cto.com/speakingbaicai/1703229&lt;/a&gt;&lt;br/&gt;【闭包】&lt;a href=&quot;https://blog.csdn.net/zhangzhebjut/article/details/25181151&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/zhangzhebjut/article/details/25181151&lt;/a&gt;&lt;br/&gt;【延迟】&lt;a href=&quot;http://liyangliang.me/posts/2014/12/defer-in-golang/&quot; class=&quot;uri&quot;&gt;http://liyangliang.me/posts/2014/12/defer-in-golang/&lt;/a&gt;&lt;br/&gt;【defer三条原则】&lt;a href=&quot;https://leokongwq.github.io/2016/10/15/golang-defer.html&quot; class=&quot;uri&quot;&gt;https://leokongwq.github.io/2016/10/15/golang-defer.html&lt;/a&gt;&lt;br/&gt;【defer代码例子】&lt;a href=&quot;https://juejin.im/post/5b948b3e6fb9a05d3827beda&quot; class=&quot;uri&quot;&gt;https://juejin.im/post/5b948b3e6fb9a05d3827beda&lt;/a&gt;&lt;br/&gt;【defer panic】&lt;a href=&quot;https://ieevee.com/tech/2017/11/23/go-panic.html&quot; class=&quot;uri&quot;&gt;https://ieevee.com/tech/2017/11/23/go-panic.html&lt;/a&gt;&lt;br/&gt;【defer panic】&lt;a href=&quot;https://zhuanlan.zhihu.com/p/33743255&quot; class=&quot;uri&quot;&gt;https://zhuanlan.zhihu.com/p/33743255&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 12 Feb 2019 14:20:00 +0000</pubDate>
<dc:creator>Stefno</dc:creator>
<og:description>defer是Go语言提供的一种用于注册延迟调用的机制：让函数或语句可以在当前函数执行完毕后（包括通过return正常结束或者panic导致的异常结束）执行。深受Go开发者的欢迎，但一不小心就会掉进它的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qcrao-2018/p/10367346.html</dc:identifier>
</item>
<item>
<title>C# Lambda表达式 - 阡陌染</title>
<link>http://www.cnblogs.com/forever-Ys/p/10344247.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/forever-Ys/p/10344247.html</guid>
<description>&lt;h2&gt;一、简介　　&lt;/h2&gt;
&lt;p&gt;　　Lambda表达式来源于数学家Alonzo Church等人在1920~1930期间发明的Lambad积分。Lambda积分是用于表示函数的一套系统，它使用希腊字母Lambda（ λ ）来表示无名函数。&lt;/p&gt;
&lt;p&gt;　　C# 3.0引入了Lambda表达式，它是一种简化的匿名函数，可用于创建委托或表达式目录树。你也可以将 Lambda 表达式作为参数进行传递，或者将它作用于函数调用值调用后返回的一个函数来使用。&lt;/p&gt;

&lt;h2&gt;二、基础&lt;/h2&gt;
&lt;p&gt;　　它的语法形式是： &lt;span&gt;&lt;span&gt;输入参数 =&amp;gt; 表达式或语句块&lt;/span&gt;　　&lt;span&gt;即运算符的左边是输入参数(如果有)，右边是表达式或语句块。 （ “ =&amp;gt; ” 读作 “ goes to ” ）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;　　2.1 表达式Lambda&lt;/h3&gt;
&lt;p&gt;　　      &lt;span id=&quot;mt20&quot; data-guid=&quot;a858e2d952158bf6851beccbb9fa2be6&quot; data-source=&quot;A lambda expression with an expression on the right side of the =&amp;amp;gt; operator is called an &amp;lt;span class=&amp;quot;parameter&amp;quot;&amp;gt;expression lambda.&quot;&gt;表达式位于 =&amp;gt; 运算符右侧的 lambda 表达式称为“表达式 lambda”。&lt;span id=&quot;mt20&quot; data-guid=&quot;a858e2d952158bf6851beccbb9fa2be6&quot; data-source=&quot;A lambda expression with an expression on the right side of the =&amp;amp;gt; operator is called an &amp;lt;span class=&amp;quot;parameter&amp;quot;&amp;gt;expression lambda.&quot;&gt;&lt;span id=&quot;mt21&quot; data-guid=&quot;7a917f4505a3fade6bfa2a6b684acc36&quot; data-source=&quot;Expression lambdas are used extensively in the construction of &amp;lt;span class=&amp;quot;mtpsTagOuterHtml&amp;quot; &amp;gt;Expression Trees (C# and Visual Basic).&quot;&gt; &lt;span id=&quot;mt22&quot; data-guid=&quot;e0853a0372a587eee38648f09324a192&quot; data-source=&quot;An expression lambda returns the result of the expression and takes the following basic form:&quot;&gt;&lt;span&gt;表达式 Lambda 会返回表达式的结果&lt;/span&gt;，并采用以下基本形式：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div id=&quot;code-snippet-3&quot;&gt;
&lt;div&gt;
&lt;div id=&quot;CodeSnippetContainerCode_15792d55-be25-4dc3-9100-9a9a6111fd13&quot; dir=&quot;ltr&quot; readability=&quot;6&quot;&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    (input parameters) =&amp;gt; expression&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;delegate&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; myDel(&lt;span&gt;int&lt;/span&gt; x,&lt;span&gt;int&lt;/span&gt; y);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;声明委托&lt;/span&gt;

&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            myDel del &lt;/span&gt;= (x,y) =&amp;gt;  x+&lt;span&gt;y;&lt;/span&gt;    &lt;span&gt;//返回x+y的结果&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;　　　　　　　Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;values {0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,del(&lt;span&gt;5&lt;/span&gt;,&lt;span&gt;8&lt;/span&gt;)); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出13&lt;/span&gt; &lt;span&gt; 　　　　　 Console.ReadKey(); &lt;br/&gt;　　　　　} &lt;br/&gt;　　}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;有关Lambda表达式的参数列表要点如下：&lt;/p&gt;
&lt;p&gt;♥　Lambda表达式参数列表中的参数必须在参数数量、类型和位置上&lt;span&gt;与委托相匹配&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;♥    表达式参数列表中的参数不一定需要包含类型（隐式类型），除非委托有ref或out参数----此时必须注明类型（显式类型）&lt;/p&gt;
&lt;p&gt;♥    如果只有一个参数，并且是隐式类型的，周围的圆括号可以被省略，否则必须有括号&lt;/p&gt;
&lt;p&gt;♥    &lt;span&gt;如果没有参数，必须使用一组空的圆括号&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;　　2.2  语句Lambda&lt;/h3&gt;
&lt;p&gt;　　　　当lambda表达式中，有多个语句时，写成如下形式：&lt;/p&gt;
&lt;p&gt;　　　　(input parameters) =&amp;gt; {  statement； }&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;delegate&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; myDel(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; str);

    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            myDel del &lt;/span&gt;= (str) =&amp;gt;&lt;span&gt;
            {
                Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello {0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,str);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;123&lt;/span&gt;&lt;span&gt;;
            };
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;values {0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,del(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;world&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
            Console.ReadKey();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;三、运用&lt;/h2&gt;
&lt;p&gt;　　知道了Lamda的基本用法，下面看看怎么在LINQ和异步中使用它&lt;/p&gt;

&lt;h3&gt;　　3.1   LINQ查询中使用Lambda表达式参数的示例&lt;/h3&gt;
&lt;p&gt; 　　　引用MSDN中的例子。&lt;span data-ttu-id=&quot;ede37-107&quot;&gt;下面的示例演示如何通过 &lt;a class=&quot;xref&quot; href=&quot;https://docs.microsoft.com/zh-cn/dotnet/api/system.linq.enumerable.where&quot; data-linktype=&quot;absolute-path&quot;&gt;Enumerable.Where&lt;/a&gt; 标准查询运算符，在基于方法的查询中使用 lambda 表达式。 &lt;span data-ttu-id=&quot;ede37-108&quot;&gt;请注意，此示例中的 &lt;a class=&quot;xref&quot; href=&quot;https://docs.microsoft.com/zh-cn/dotnet/api/system.linq.enumerable.where&quot; data-linktype=&quot;absolute-path&quot;&gt;Where&lt;/a&gt; 方法具有一个 &lt;a class=&quot;xref&quot; href=&quot;https://docs.microsoft.com/zh-cn/dotnet/api/system.func-1&quot; data-linktype=&quot;absolute-path&quot;&gt;Func&amp;lt;TResult&amp;gt;&lt;/a&gt; 委托类型的输入参数，该委托采用整数作为输入并返回一个布尔值。 &lt;span data-ttu-id=&quot;ede37-109&quot;&gt;Lambda 表达式可以转换为该委托。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; SimpleLambda
{
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Main()
    {

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Data source.&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt;[] scores = { &lt;span&gt;90&lt;/span&gt;, &lt;span&gt;71&lt;/span&gt;, &lt;span&gt;82&lt;/span&gt;, &lt;span&gt;93&lt;/span&gt;, &lt;span&gt;75&lt;/span&gt;, &lt;span&gt;82&lt;/span&gt;&lt;span&gt; };

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; The call to Count forces iteration of the source&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; highScoreCount = scores.Where(n =&amp;gt; n &amp;gt; &lt;span&gt;80&lt;/span&gt;&lt;span&gt;).Count();

        Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{0} scores are greater than 80&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, highScoreCount);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Outputs: 4 scores are greater than 80            &lt;/span&gt;
&lt;span&gt;    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;　　3.2   使用异步Lambda表达式&lt;/h3&gt;
&lt;p&gt; 　　&lt;span data-ttu-id=&quot;666f1-144&quot;&gt;你可以使用异步 lambda 添加事件处理程序。 &lt;span data-ttu-id=&quot;666f1-145&quot;&gt;若要添加此处理程序，请在 lambda 参数列表前添加一个 &lt;code&gt;async&lt;/code&gt; 修饰符，如下例，lambda表达式被注册为一个按钮点击事件的事件处理程序。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;partial&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Form1 : Form  
{  
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Form1()  
    {  
        InitializeComponent();  
        button1.Click &lt;/span&gt;+= &lt;span&gt;async&lt;/span&gt; (sender, e) =&amp;gt;      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;异步Lambda表达式&lt;/span&gt;
&lt;span&gt;        {  
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ExampleMethodAsync returns a Task.  &lt;/span&gt;
            &lt;span&gt;await&lt;/span&gt;&lt;span&gt; ExampleMethodAsync();  
            textBox1.Text &lt;/span&gt;+= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\nControl returned to Click event handler.\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;  
        };  
    }  
  
    &lt;/span&gt;&lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task ExampleMethodAsync()  
    {  
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; The following line simulates a task-returning asynchronous process.  &lt;/span&gt;
        &lt;span&gt;await&lt;/span&gt; Task.Delay(&lt;span&gt;1000&lt;/span&gt;&lt;span&gt;);  
    }  
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　有关异步和LINQ的知识，可以参阅我以前写过的博客&lt;/p&gt;

</description>
<pubDate>Tue, 12 Feb 2019 14:02:00 +0000</pubDate>
<dc:creator>阡陌染</dc:creator>
<og:description>一、简介 Lambda表达式来源于数学家Alonzo Church等人在1920~1930期间发明的Lambad积分。Lambda积分是用于表示函数的一套系统，它使用希腊字母Lambda（ λ ）来表</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/forever-Ys/p/10344247.html</dc:identifier>
</item>
<item>
<title>ML.NET 0.10特性简介 - Ken.W</title>
<link>http://www.cnblogs.com/kenwoo/p/10367137.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kenwoo/p/10367137.html</guid>
<description>&lt;p&gt;IDataView组件为表格式数据提供了非常高效的处理方式，尤其是用于机器学习和高级分析应用。它被设计为可以高效地处理高维数据和大型数据集。并且也适合处理属于更大的分布式数据集中的单个数据区块结点。&lt;/p&gt;
&lt;p&gt;在ML.NET 0.10中，IDataView被拆分成单个程序集和NuGet类库包。这对于与其它API及框架交互是极重要的一步。&lt;/p&gt;
&lt;p&gt;在被拆分后，其它的类库将能直接引用它，而不需要引用整个ML.NET。这样有助于第三方类库也能使用IDataView所提供的强大功能。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/991496/201902/991496-20190212205901864-1632817045.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;在之前的ML.NET版本中，当使用场感知分解机(FFM)训练器时，仅可以提供单个特征列。&lt;/p&gt;
&lt;p&gt;在新的版本里，支持在Options参数里添加额外的特征列。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;var ffmArgs = new FieldAwareFactorizationMachineTrainer.Options();

// Create the multiple field names.
ffmArgs.FeatureColumn = nameof(MyObservationClass.MyField1); // 首个字段
ffmArgs.ExtraFeatureColumns = new[]{ nameof(MyObservationClass.MyField2), nameof(MyObservationClass.MyField3) }; // 额外的字段

var pipeline = mlContext.BinaryClassification.Trainers.FieldAwareFactorizationMachine(ffmArgs);

var model = pipeline.Fit(dataView);&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;之前的版本里，即使预测多类别分类问题，也只能返回单一的标签。&lt;/p&gt;
&lt;p&gt;现在，这一缺陷终于被修复了。(其实在内部逻辑里已经对多项预测完成处理，但过去的API只返回了单一的结果)&lt;/p&gt;

&lt;p&gt;作为ML.NET Samples的一部分，现在新增了一个特殊&lt;a href=&quot;https://github.com/dotnet/machinelearning-samples/blob/master/docs/COMMUNITY-SAMPLES.md&quot;&gt;页面&lt;/a&gt;——由社区提供的多个示例。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/991496/201902/991496-20190212211755135-1044449696.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;里面有不少很好的例子：&lt;/p&gt;
&lt;p&gt;照片查询的WPF应用，其内部运行TensorFlow模型，并导出为ONNX格式。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/991496/201902/991496-20190212211806011-1669319724.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用ML.NET的UWP应用：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/991496/201902/991496-20190212211817479-517026897.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当然，欢迎有越来越多的贡献者加入其中，提供更多的示例。&lt;/p&gt;
</description>
<pubDate>Tue, 12 Feb 2019 13:26:00 +0000</pubDate>
<dc:creator>Ken.W</dc:creator>
<og:description>IDataView被单独作为一个类库包 IDataView组件为表格式数据提供了非常高效的处理方式，尤其是用于机器学习和高级分析应用。它被设计为可以高效地处理高维数据和大型数据集。并且也适合处理属于更</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kenwoo/p/10367137.html</dc:identifier>
</item>
<item>
<title>JDK源码分析（9）之 WeakHashMap 相关 - 三枣</title>
<link>http://www.cnblogs.com/sanzao/p/10367123.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sanzao/p/10367123.html</guid>
<description>&lt;p&gt;平时我们使用最多的数据结构肯定是 HashMap，但是在使用的时候我们必须知道每个键值对的生命周期，并且手动清除它；但是如果我们不是很清楚它的生命周期，这时候就比较麻烦；通常有这样几种处理方式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;由一个线程定时处理，可以是&lt;code&gt;Timer&lt;/code&gt;或者&lt;code&gt;ScheduledThreadPoolExecutor&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;利用重写&lt;code&gt;LinkedHashMap.removeEldestEntry()&lt;/code&gt;，实现 FIFOCache 或者 LRUCache；可以参考我之前写的一篇博客 &lt;a href=&quot;https://www.cnblogs.com/sanzao/p/10297220.html&quot;&gt;LinkedHashMap 相关&lt;/a&gt;；&lt;/li&gt;
&lt;li&gt;利用 &lt;code&gt;WeakHashMap&lt;/code&gt; 的特性，如果逻辑比较复杂还可以直接使用&lt;code&gt;Reference&lt;/code&gt;；这里可以参考 &lt;a href=&quot;https://www.cnblogs.com/sanzao/p/10343166.html&quot;&gt;Reference 完全解读&lt;/a&gt; 和 &lt;a href=&quot;https://www.cnblogs.com/sanzao/p/10337291.html&quot;&gt;Reference 框架概览&lt;/a&gt;；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所以本文将主要介绍&lt;code&gt;WeakHashMap&lt;/code&gt;的特性，以及补充一些关于 HashMap 实现的对比；相关 HashMap 的介绍也可以参考 &lt;a href=&quot;https://www.cnblogs.com/sanzao/p/10245212.html&quot;&gt;HashMap 相关&lt;/a&gt;；&lt;/p&gt;
&lt;h2 id=&quot;一使用场景&quot;&gt;一、使用场景&lt;/h2&gt;
&lt;p&gt;上面也介绍了，&lt;code&gt;WeakHashMap&lt;/code&gt;适用于不是非常重要的缓存类似的场景；例如：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;WeakHashMap&amp;lt;Object, Integer&amp;gt; map = new WeakHashMap&amp;lt;&amp;gt;();

for (int i = 0; i &amp;lt; 100; i++) {
  map.put(new Object(), i);
}

System.out.println(map.size());  // 1
System.gc();                     // 2
System.out.println(map.size());  // 3
System.out.println(map.size());  // 4
System.out.println(map.size());  // 5
System.out.println(map);         // 6
System.out.println(map.size());  // 7&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;// 打印：&lt;br/&gt;100&lt;br/&gt;100&lt;br/&gt;100&lt;br/&gt;46&lt;br/&gt;{}&lt;br/&gt;0&lt;/p&gt;
&lt;p&gt;对于以上的结果你可能和我打印的不一样，&lt;code&gt;WeakHashMap&lt;/code&gt;按照语义应该是，当 key 没有强引用指向的时候，会自动清除 key 和 value；我这里先解释它的释放过程，如果你觉得很清晰，那&lt;code&gt;WeakHashMap&lt;/code&gt;你就算是掌握了；&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先 for 循环结束的时候，key 已经没用强引用指向了，此时所有的 key 都是弱引用了；&lt;/li&gt;
&lt;li&gt;接下来执行1，因为我这里只有一个方法，新生代还有足够的空间，所以不会触发 GC，所以所有的 key 任然在堆里面，所以打印100；&lt;/li&gt;
&lt;li&gt;然后手动触发 GC，虽然&lt;code&gt;System.gc();&lt;/code&gt;不一定会立即执行，但是我这里只有一个方法，所以肯定会执行 GC，这里可以打开 GC 日志查看，&lt;code&gt;-verbose:gc&lt;/code&gt;；因为 所有的 key 都是弱引用，所以&lt;code&gt;referent&lt;/code&gt;被致为 null，同时将 key 注册到 &lt;code&gt;ReferenceQueue&lt;/code&gt;中；&lt;/li&gt;
&lt;li&gt;在执行 3-7 的时候，按语义 map 应该为空；但是将 key 注册到 &lt;code&gt;ReferenceQueue&lt;/code&gt;并非原子性一次完成的，所以这里会打印不同的值，每注册完成一个，在 map 进行操作的时候，就会将其移除；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;将上面的代码改成多线程分析思路也是一样的，如果你觉得有不清楚的地方可以查看下文；&lt;/p&gt;
&lt;h2 id=&quot;二weakhashmap-源码分析&quot;&gt;二、WeakHashMap 源码分析&lt;/h2&gt;
&lt;h3 id=&quot;类定义&quot;&gt;1. 类定义&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class WeakHashMap&amp;lt;K,V&amp;gt; extends AbstractMap&amp;lt;K,V&amp;gt; implements Map&amp;lt;K,V&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到虽然&lt;code&gt;WeakHashMap&lt;/code&gt;也是基于哈希表，但是却并非像&lt;code&gt;LinkedHashMap&lt;/code&gt;一样是继承于&lt;code&gt;HashMap&lt;/code&gt;，并且&lt;code&gt;WeakHashMap&lt;/code&gt;也没有实现&lt;code&gt;Cloneable, Serializable&lt;/code&gt;两个接口，这是因为&lt;code&gt;WeakHashMap&lt;/code&gt;基于&lt;code&gt;WeakReference&lt;/code&gt;实现的，弱引用并不建议实现序列化，同时弱引用一般用于不是很重要的缓存，也就没必要实现&lt;code&gt;Cloneable, Serializable&lt;/code&gt;两个接口了；&lt;/p&gt;
&lt;h3 id=&quot;核心方法&quot;&gt;2. 核心方法&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private final ReferenceQueue&amp;lt;Object&amp;gt; queue = new ReferenceQueue&amp;lt;&amp;gt;();

private static class Entry&amp;lt;K,V&amp;gt; extends WeakReference&amp;lt;Object&amp;gt; implements Map.Entry&amp;lt;K,V&amp;gt; {
  V value;
  final int hash;
  Entry&amp;lt;K,V&amp;gt; next;

  Entry(Object key, V value, ReferenceQueue&amp;lt;Object&amp;gt; queue, int hash, Entry&amp;lt;K,V&amp;gt; next) {
    super(key, queue);
    this.value = value;
    this.hash  = hash;
    this.next  = next;
  }

  public K getKey() { }
  public V getValue() {
  public V setValue(V newValue) {
  public int hashCode() {
  public String toString() {
}

private void expungeStaleEntries() {
  for (Object x; (x = queue.poll()) != null; ) {
    synchronized (queue) {
      @SuppressWarnings(&quot;unchecked&quot;)
        Entry&amp;lt;K,V&amp;gt; e = (Entry&amp;lt;K,V&amp;gt;) x;
      int i = indexFor(e.hash, table.length);

      Entry&amp;lt;K,V&amp;gt; prev = table[i];
      Entry&amp;lt;K,V&amp;gt; p = prev;
      while (p != null) {
        Entry&amp;lt;K,V&amp;gt; next = p.next;
        if (p == e) {
          if (prev == e)
            table[i] = next;
          else
            prev.next = next;
          // Must not null out e.next;
          // stale entries may be in use by a HashIterator
          e.value = null; // Help GC
          size--;
          break;
        }
        prev = p;
        p = next;
      }
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面代码所列的&lt;code&gt;ReferenceQueue，Entry，expungeStaleEntries()&lt;/code&gt;就是&lt;code&gt;WeakHashMap&lt;/code&gt;实现的核心了；这里强烈建议要先看 &lt;a href=&quot;https://www.cnblogs.com/sanzao/p/10343166.html&quot;&gt;Reference 完全解读&lt;/a&gt; 和 &lt;a href=&quot;https://www.cnblogs.com/sanzao/p/10337291.html&quot;&gt;Reference 框架概览&lt;/a&gt; 这两篇博客，里面同样的内容我也不会再赘述了；&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Entry&amp;lt;K,V&amp;gt; extends WeakReference&amp;lt;Object&amp;gt;&lt;/code&gt;， 表明所有的节点都是&lt;code&gt;WeakReference&lt;/code&gt;，而 key 则是 referent；&lt;/li&gt;
&lt;li&gt;queue，所有 key 使用同一个&lt;code&gt;ReferenceQueue&lt;/code&gt;监听器，每当 key 被回收的时候，entry 将会被注册到&lt;code&gt;ReferenceQueue&lt;/code&gt;中；&lt;/li&gt;
&lt;li&gt;expungeStaleEntries，将注册到&lt;code&gt;ReferenceQueue&lt;/code&gt;中的 entry 移除，并将 value 置为 null；&lt;code&gt;WeakHashMap&lt;/code&gt;的所有操作都先执行&lt;code&gt;expungeStaleEntries&lt;/code&gt;，这样&lt;code&gt;WeakHashMap&lt;/code&gt;就实现了自动回收不在需要的 key 和 value；&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;三性能对比&quot;&gt;三、性能对比&lt;/h2&gt;
&lt;p&gt;其实上面的内容就已经将&lt;code&gt;WeakHashMap&lt;/code&gt;的主要实现讲完了，但是我之前在看&lt;code&gt;HashMap&lt;/code&gt;源码的时候，并没有对比 JDK1.7 和 JDK1.8，但是在这里发现其实&lt;code&gt;WeakHashMap&lt;/code&gt;的实现和 JDK1.7 差不多，所以接下来我将主要对比一下&lt;code&gt;WeakHashMap&lt;/code&gt;和&lt;code&gt;HashMap&lt;/code&gt;；&lt;/p&gt;
&lt;h3 id=&quot;容量计算&quot;&gt;1. 容量计算&lt;/h3&gt;
&lt;p&gt;在&lt;code&gt;WeakHashMap&lt;/code&gt;和&lt;code&gt;HashMap&lt;/code&gt;中都要求容量是2的幂，因为当容量为2的幂时，使用除留余数法计算哈希桶位置时可以使用&lt;code&gt;hash % length = hash &amp;amp; (length-1)&lt;/code&gt;的性质进行优化；&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// WeakHashMap
int capacity = 1;
while (capacity &amp;lt; initialCapacity)
  capacity &amp;lt;&amp;lt;= 1;

// HashMap
static final int tableSizeFor(int cap) {
  int n = cap - 1;
  n |= n &amp;gt;&amp;gt;&amp;gt; 1;
  n |= n &amp;gt;&amp;gt;&amp;gt; 2;
  n |= n &amp;gt;&amp;gt;&amp;gt; 4;
  n |= n &amp;gt;&amp;gt;&amp;gt; 8;
  n |= n &amp;gt;&amp;gt;&amp;gt; 16;
  return (n &amp;lt; 0) ? 1 : (n &amp;gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;简单测试可以得到：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;WeakHashMap&lt;/td&gt;
&lt;td&gt;30&lt;/td&gt;
&lt;td&gt;32&lt;/td&gt;
&lt;td&gt;26&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;HashMap&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;代码比较简单我就不贴了，从上表也可以看到了&lt;code&gt;tableSizeFor&lt;/code&gt;不仅高效而且稳定；&lt;/p&gt;
&lt;h3 id=&quot;哈希计算&quot;&gt;2. 哈希计算&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// WeakHashMap
final int hash(Object k) {
  int h = k.hashCode();
  h ^= (h &amp;gt;&amp;gt;&amp;gt; 20) ^ (h &amp;gt;&amp;gt;&amp;gt; 12);
  return h ^ (h &amp;gt;&amp;gt;&amp;gt; 7) ^ (h &amp;gt;&amp;gt;&amp;gt; 4);
}

// HashMap
static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &amp;gt;&amp;gt;&amp;gt; 16);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;两种hash算法都是要避免极端的&lt;code&gt;hashCode()&lt;/code&gt;，但是&lt;code&gt;HashMap&lt;/code&gt;却更为透彻，因为影响哈希桶位置的只有 hash 的低位（容量2的n次方，n个低位），直接将高位与上低位，使高位 hash 参与位置计算，简洁且高效；&lt;/p&gt;
&lt;p&gt;此外还有&lt;code&gt;put&lt;/code&gt;方法，但是里面还牵涉红黑树，对于本文就扯得有点远了，所以暂不讲；&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;WeakHashMap&lt;/code&gt;是&lt;code&gt;WeakReference&lt;/code&gt;的典型应用，在灵活应用&lt;code&gt;WeakHashMap&lt;/code&gt;之后，如果有更为复杂的逻辑，可以直接使用&lt;code&gt;Reference&lt;/code&gt;实现；&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Tue, 12 Feb 2019 13:14:00 +0000</pubDate>
<dc:creator>三枣</dc:creator>
<og:description>平时我们使用最多的数据结构肯定是 HashMap，但是在使用的时候我们必须知道每个键值对的生命周期，并且手动清除它；但是如果我们不是很清楚它的生命周期，这时候就比较麻烦；通常有这样几种处理方式： 由一</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sanzao/p/10367123.html</dc:identifier>
</item>
<item>
<title>自制简单的诗歌搜索系统 - jclian91</title>
<link>http://www.cnblogs.com/jclian91/p/10367113.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jclian91/p/10367113.html</guid>
<description>&lt;h3 id=&quot;项目简介&quot;&gt;项目简介&lt;/h3&gt;
&lt;p&gt;  本文将介绍一个笔者自己的项目：自制简单的诗歌搜索系统。该系统主要的实现功能如下：指定一个关键词，检索出包含这个关键词的诗歌，比如关键词为“白云”，则检索出的诗歌可以为王维的《送别》，内容为“下马饮君酒，问君何所之？君言不得意，归卧南山陲。但去莫复问，白云无尽时。”&lt;br/&gt;  该项目使用的Python模块为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;requests&lt;/li&gt;
&lt;li&gt;BeautifulSoup&lt;/li&gt;
&lt;li&gt;pymongo&lt;/li&gt;
&lt;li&gt;tornado&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其中，requests模块和BeautifulSoup模块用来制作爬虫，爬取网上的诗歌。pymongo模块用来将爬取的诗歌写入到MongoDB数据库。tornado模块用于网页端展示。&lt;br/&gt;  该项目主要分以下三步实现：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;收集数据：使用爬虫，爬取网上的诗歌作为项目的数据集；&lt;/li&gt;
&lt;li&gt;存入数据库：将爬取到的诗歌写入到MongoDB数据库；&lt;/li&gt;
&lt;li&gt;网页展示：利用tornado框架实现诗歌搜索功能。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;该项目的结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/9419034-afaa1770637eb0fc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;poem_search项目结构&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;数据收集&quot;&gt;数据收集&lt;/h3&gt;
&lt;p&gt;  首先，我们利用Python爬虫来爬取诗歌，存为CSV文件poem.csv。爬取的网址为：&lt;a href=&quot;https://www.gushiwen.org/&quot;&gt;https://www.gushiwen.org&lt;/a&gt; 。由于仅是展示该项目的思路，因此，只爬取了该页面中的唐诗三百首、古诗三百、宋词三百、宋词精选，一共大约1100多首诗歌。&lt;br/&gt;  实现该爬虫的代码文件为poem_scrape.py，代码如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# -*- coding: utf-8 -*-

import re
import requests
from bs4 import BeautifulSoup
import pandas as pd

# 爬取的诗歌网址
urls = ['https://www.gushiwen.org/gushi/tangshi.aspx',
        'https://www.gushiwen.org/gushi/sanbai.aspx',
        'https://www.gushiwen.org/gushi/songsan.aspx',
        'https://www.gushiwen.org/gushi/songci.aspx'
        ]

poem_links = []
# 诗歌的网址
for url in urls:
    # 请求头部
    headers = {'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.87 Safari/537.36'}
    req = requests.get(url, headers=headers)

    soup = BeautifulSoup(req.text, &quot;lxml&quot;)
    content = soup.find_all('div', class_=&quot;sons&quot;)[0]
    links = content.find_all('a')

    for link in links:
        poem_links.append(link['href'])

# print(poem_links)
# print(len(poem_links))

content_list = []
title_list = []
dynasty_list = []
poet_list = []

# 爬取诗歌页面
def get_poem(url):
    #url = 'https://so.gushiwen.org/shiwenv_45c396367f59.aspx'
    # 请求头部
    headers = {'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.87 Safari/537.36'}
    req = requests.get(url, headers=headers)
    soup = BeautifulSoup(req.text, &quot;lxml&quot;)

    # 诗歌内容
    poem = soup.find('div', class_='contson').text.strip()
    poem = poem.replace(' ', '')
    poem = re.sub(re.compile(r&quot;\([\s\S]*?\)&quot;), '', poem)
    poem = re.sub(re.compile(r&quot;（[\s\S]*?）&quot;), '', poem)
    poem = re.sub(re.compile(r&quot;。\([\s\S]*?）&quot;), '', poem)
    poem = poem.replace('!', '！').replace('?', '？').replace('\n', '')
    content = poem

    if content:
        content_list.append(content)
    else:
        content_list.append('')

    # 诗歌朝代，诗人
    dynasty_poet = soup.find('p', class_='source').text
    if '：' in dynasty_poet:
        dynasty, poet = dynasty_poet.split('：')
    else:
        dynasty, poet = '', ''

    dynasty_list.append(dynasty)
    poet_list.append(poet)

    # 诗歌标题
    title = soup.find('h1').text
    if title:
        title_list.append(title)
    else:
        title_list.append('')

# 爬取诗歌
for url in poem_links:
    get_poem(url)

# 写入至csv文件
df = pd.DataFrame({'title': title_list,
                   'dynasty': dynasty_list,
                   'poet': poet_list,
                   'content': content_list
                   })
print(df.head())

df.to_csv('./poem.csv', index=False)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;储存的poem.csv的前几行如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/9419034-3b0329016475f4a2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;poem.csv文件&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;数据库&quot;&gt;数据库&lt;/h3&gt;
&lt;p&gt;  数据收集完毕后，我们需要将这些数据出访到数据库中，便于后续的调用，在这里选择MongoDB。利用文件write2mongodb.py文件可以将刚才爬取到的诗歌存放至MongoDB数据库中，完整的代码如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import pandas as pd
from pymongo import MongoClient

# 连接MongoDB
conn = MongoClient('mongodb://localhost:27017/')
db = conn[&quot;test&quot;]

# 插入诗歌
df = pd.read_csv('poem.csv')
columns = ['title', 'dynasty', 'poet', 'content']
for i in range(df.shape[0]):
    print(i)
    row = df.iloc[i, :]
    db.poem.insert(dict(zip(columns, row[columns])))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  不到一分钟，我们可以看到MongoDB中的内容如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/9419034-c8bcb306580ba479.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;mongodb数据&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;前端展示&quot;&gt;前端展示&lt;/h3&gt;
&lt;p&gt;  准备好数据集后，我们需要可视化地展示诗歌检索功能，我们选择tornado这个框架来实现。诗歌检索功能为：指定一个关键词，检索出包含这个关键词的诗歌。关键词由用户输入，提交HTTP请求，在后台实现诗歌检索功能，然后在前端页面展示出来。&lt;br/&gt;  实现的server.py的代码如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# -*- coding: utf-8 -*-

import random
import os.path
import tornado.httpserver
import tornado.ioloop
import tornado.options
import tornado.web
from tornado.options import define, options
from pymongo import MongoClient

# 连接MongoDB
conn = MongoClient('mongodb://localhost:27017/')
coll = conn[&quot;test&quot;].poem

#定义端口为8000
define(&quot;port&quot;, default=8000, help=&quot;run on the given port&quot;, type=int)

# GET请求
class QueryHandler(tornado.web.RequestHandler):
    # get函数
    def get(self):
        self.render('query.html')

# POST请求
# POST请求参数：query_string
class ResultHandler(tornado.web.RequestHandler):
    # post函数
    def post(self):
        query = self.get_argument('query_string')
        res = list(coll.find({'content': {'$regex': query}}))

        if len(res) &amp;gt; 0:
            result = random.sample(res, 1)[0]
            del result[&quot;_id&quot;]
            title = result['title']
            dynasty = result['dynasty']
            poet = result['poet']
            content = result['content']
        else:
            title = ''
            dynasty = ''
            poet = ''
            content = ''

        self.render('result.html', query=query, title=title, dynasty=dynasty, poet=poet, content=content)

# 主函数
def main():
    tornado.options.parse_command_line()
    # 定义app
    app = tornado.web.Application(
            handlers=[(r'/query', QueryHandler), (r'/result', ResultHandler)], #网页路径控制
            template_path=os.path.join(os.path.dirname(__file__), &quot;templates&quot;) # 模板路径
          )
    http_server = tornado.httpserver.HTTPServer(app)
    http_server.listen(options.port)
    tornado.ioloop.IOLoop.instance().start()

main()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中，query路径对应的网页query.html的代码如下：&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;Poem Query&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;h2&amp;gt;请输入查询&amp;lt;/h2&amp;gt;
&amp;lt;form method=&quot;post&quot; action=&quot;/result&quot;&amp;gt;
&amp;lt;p&amp;gt;包含文字: &amp;lt;input type=&quot;text&quot; name=&quot;query_string&quot;&amp;gt;&amp;lt;/p&amp;gt;
&amp;lt;input type=&quot;submit&quot;&amp;gt;
&amp;lt;/form&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;result路径对应的网页result.html如下：&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;Result&amp;lt;/title&amp;gt;
    &amp;lt;script&amp;gt;
    //highlight query word in the page
    function Func(){
        var query = document.getElementById(&quot;query&quot;).innerHTML;
        query = query.split('：')[1];
        if(query == ''){alert('查询词为空!')}
        else{
            document.getElementById(&quot;result&quot;).innerHTML = document.getElementById(&quot;result&quot;).innerHTML.replace(new RegExp(query,'g'),'&amp;lt;mark&amp;gt;'+query+'&amp;lt;/mark&amp;gt;');
        }
    }
    &amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;font color=&quot;red&quot;&amp;gt;&amp;lt;p id=&quot;query&quot;&amp;gt;查询词：{{query}}&amp;lt;/p&amp;gt;&amp;lt;/font&amp;gt;
&amp;lt;p&amp;gt;标题：{{title}}&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;朝代：{{dynasty}}&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;诗人：{{poet}}&amp;lt;/p&amp;gt;
&amp;lt;p id=&quot;result&quot;&amp;gt;内容：{{content}}&amp;lt;/p&amp;gt;
&amp;lt;a href=&quot;/query&quot;&amp;gt;&amp;lt;button type=&quot;button&quot;&amp;gt;返回&amp;lt;/button&amp;gt;&amp;lt;/a&amp;gt;
&amp;lt;button type=&quot;button&quot; onclick=&quot;Func()&quot;&amp;gt;查询词高亮&amp;lt;/button&amp;gt;
&amp;lt;/body&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;使用示例&quot;&gt;使用示例&lt;/h3&gt;
&lt;p&gt;  运行server.py, 在浏览器中输入网址：&lt;a href=&quot;http://localhost:8000/query&quot; class=&quot;uri&quot;&gt;http://localhost:8000/query&lt;/a&gt; ，界面如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/9419034-f485b09461d3d6cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;诗歌搜索界面&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在其中输入搜索关键词，比如“白云”，则会显示一条随机的结果，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/9419034-420f5651f645b917.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;诗歌搜索结果&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击“查询词高亮”，则查询词部分会高亮显示。&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;  本项目仅为展示诗歌检索的一种实现思路，仍有许多功能还待完善，后续将进一步补充实现。本项目的github地址为：&lt;a href=&quot;https://github.com/percent4/Poem-Search&quot; class=&quot;uri&quot;&gt;https://github.com/percent4/Poem-Search&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;注意：本人现已开通微信公众号： Python爬虫与算法（微信号为：easy_web_scrape）， 欢迎大家关注哦~~&lt;/p&gt;
</description>
<pubDate>Tue, 12 Feb 2019 13:09:00 +0000</pubDate>
<dc:creator>jclian91</dc:creator>
<og:description>自制简单的诗歌搜索系统</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jclian91/p/10367113.html</dc:identifier>
</item>
</channel>
</rss>