<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>超声波手势识别（STM32四路超声波获取） - 东小东</title>
<link>http://www.cnblogs.com/dongxiaodong/p/10134873.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dongxiaodong/p/10134873.html</guid>
<description>
&lt;p&gt;       超声波手势识别在市场上已经有见实现，但研究其传感器发现并不是市场上随意可见的，如果暂且考虑成本，该如何入门实现简单的手势识别呢。聊天中老师给出一个很好的提议，就是固定四个超声波，分别为上下左右，然后进行程序上的对应编号，用单片机实现四路超声波的距离数据读取，然后程序分析读取的数据进而判断手势。STM32单片机有多个定时器，每个定时器接入一个超声波，分别接入四个，定时器分别开始工作以计数，将得到的距离信息一次性发送四个方向的值到串口，串口连接到PC机，PC机获取到四组值，然后进行分析解释。下面将实现第一步，STM32 实现四路超声波获取。&lt;/p&gt;
&lt;h2&gt;实现效果：&lt;/h2&gt;
&lt;p&gt;Python的串口程序上每次从串口获取到上下左右四组值，并输出在控制台，相关的串口实现可以参考：&lt;a href=&quot;https://www.cnblogs.com/dongxiaodong/p/9992083.html&quot;&gt;Python的串口通信（pyserial）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1485202/201812/1485202-20181218005427530-523570235.png&quot; alt=&quot;&quot; width=&quot;464&quot; height=&quot;319&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1485202/201812/1485202-20181218005452248-1133485530.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;超声波模块：HC-SR04&lt;/p&gt;
&lt;p&gt;单片机：stm32f103c8t6&lt;/p&gt;
&lt;p&gt;注意：程序正常工作的前提是必须按复位键&lt;/p&gt;
&lt;p&gt;获取值【上，下，左，右】&lt;/p&gt;
&lt;p&gt;对应echo的IO【PA0   ,   PA11   ,   PA7   ,   PB6】&lt;/p&gt;
&lt;p&gt;对应trig 的IO【PB12   ,   PB13   ,   PB14   ,   PB15】&lt;/p&gt;
&lt;p&gt;对应定时器【定时器2通道1，定时器1通道4，定时器3通道2，定时器4通道1】&lt;/p&gt;
&lt;p&gt;串口1：A9为TX    A10为RX&lt;/p&gt;
&lt;h2&gt;超声波使用基本介绍：&lt;/h2&gt;
&lt;p&gt;(1)采用IO口TRIG触发测距，给至少10us的高电平信号;&lt;/p&gt;
&lt;p&gt;(2)模块自动发送8个40khz的方波，自动检测是否有信号返回；&lt;/p&gt;
&lt;p&gt;(3)有信号返回，通过IO口ECHO输出一个高电平，高电平持续的时间就是超声波从发射到返回的时间。测试距离=(高电平时间*声速(340M/S)) （未实现）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;超声波时序：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1485202/201812/1485202-20181218005628774-1289635157.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;主函数代码：&lt;/strong&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;stm32f10x.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;STM32头文件&lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sys.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;  3&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;delay.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;  4&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;usart.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;  5&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;timex.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;  6&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;trig.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;  7&lt;/span&gt; 
&lt;span&gt;  8&lt;/span&gt; &lt;span&gt;extern&lt;/span&gt; u8  TIM3CH1_CAPTURE_STA;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;输入捕获状态                            &lt;/span&gt;
&lt;span&gt;  9&lt;/span&gt; &lt;span&gt;extern&lt;/span&gt; u16    TIM3CH1_CAPTURE_VAL;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;输入捕获值    &lt;/span&gt;
&lt;span&gt; 10&lt;/span&gt; &lt;span&gt;extern&lt;/span&gt; u8  TIM3CH2_CAPTURE_STA;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;输入捕获状态                            &lt;/span&gt;
&lt;span&gt; 11&lt;/span&gt; &lt;span&gt;extern&lt;/span&gt; u16    TIM3CH2_CAPTURE_VAL;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;输入捕获值    &lt;/span&gt;
&lt;span&gt; 12&lt;/span&gt; &lt;span&gt;extern&lt;/span&gt; u8  TIM2CH1_CAPTURE_STA;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;输入捕获状态                            &lt;/span&gt;
&lt;span&gt; 13&lt;/span&gt; &lt;span&gt;extern&lt;/span&gt; u16    TIM2CH1_CAPTURE_VAL;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;输入捕获值&lt;/span&gt;
&lt;span&gt; 14&lt;/span&gt; &lt;span&gt;extern&lt;/span&gt; u8  TIM4CH1_CAPTURE_STA;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;输入捕获状态                            &lt;/span&gt;
&lt;span&gt; 15&lt;/span&gt; &lt;span&gt;extern&lt;/span&gt; u16    TIM4CH1_CAPTURE_VAL;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;输入捕获值&lt;/span&gt;
&lt;span&gt; 16&lt;/span&gt; &lt;span&gt;extern&lt;/span&gt; u8  TIM1CH4_CAPTURE_STA;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;输入捕获状态                            &lt;/span&gt;
&lt;span&gt; 17&lt;/span&gt; &lt;span&gt;extern&lt;/span&gt; u16    TIM1CH4_CAPTURE_VAL;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;输入捕获值&lt;/span&gt;
&lt;span&gt; 18&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; main (&lt;span&gt;void&lt;/span&gt;){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;主程序&lt;/span&gt;
&lt;span&gt; 19&lt;/span&gt; u32 temp1=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;; 
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;u32 temp2=0; &lt;/span&gt;
&lt;span&gt; 21&lt;/span&gt; u32 temp3=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;; 
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt; u32 temp4=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;; 
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt; u32 temp24=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt; RCC_Configuration(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;时钟设置&lt;/span&gt;
&lt;span&gt; 25&lt;/span&gt; TR_Init(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出初始化&lt;/span&gt;
&lt;span&gt; 26&lt;/span&gt; 
&lt;span&gt; 27&lt;/span&gt; USART1_Init(&lt;span&gt;115200&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt; 
&lt;span&gt; 29&lt;/span&gt; TIM3_Cap_Init(&lt;span&gt;0XFFFF&lt;/span&gt;,&lt;span&gt;72&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;以1Mhz的频率计数       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;打印总的高点平时间&lt;/span&gt;
&lt;span&gt; 30&lt;/span&gt; TIM2_Cap_Init(&lt;span&gt;0XFFFF&lt;/span&gt;,&lt;span&gt;72&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;以1Mhz的频率计数       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;打印总的高点平时间&lt;/span&gt;
&lt;span&gt; 31&lt;/span&gt; TIM4_Cap_Init(&lt;span&gt;0XFFFF&lt;/span&gt;,&lt;span&gt;72&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;以1Mhz的频率计数       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;打印总的高点平时间&lt;/span&gt;
&lt;span&gt; 32&lt;/span&gt; TIM1_Cap_Init(&lt;span&gt;0XFFFF&lt;/span&gt;,&lt;span&gt;72&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;以1Mhz的频率计数       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;打印总的高点平时间&lt;/span&gt;
&lt;span&gt; 33&lt;/span&gt; delay_s(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt; printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;********** INIT ALL 11*********\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt; PBout(&lt;span&gt;12&lt;/span&gt;)=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt; delay_us(&lt;span&gt;13&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt; PBout(&lt;span&gt;12&lt;/span&gt;)=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt; 
&lt;span&gt; 39&lt;/span&gt; PBout(&lt;span&gt;14&lt;/span&gt;)=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt; delay_us(&lt;span&gt;13&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt; PBout(&lt;span&gt;14&lt;/span&gt;)=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt; 
&lt;span&gt; 43&lt;/span&gt; PBout(&lt;span&gt;15&lt;/span&gt;)=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt; delay_us(&lt;span&gt;13&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt; PBout(&lt;span&gt;15&lt;/span&gt;)=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt; 
&lt;span&gt; 47&lt;/span&gt; PBout(&lt;span&gt;13&lt;/span&gt;)=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt; delay_us(&lt;span&gt;13&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt; PBout(&lt;span&gt;13&lt;/span&gt;)=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt; 
&lt;span&gt; 51&lt;/span&gt; &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定时器2通道1 &lt;/span&gt;
&lt;span&gt; 53&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(TIM2CH1_CAPTURE_STA&amp;amp;&lt;span&gt;0X80&lt;/span&gt;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;成功捕获到了一次上升沿&lt;/span&gt;
&lt;span&gt; 54&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt;             temp1=TIM2CH1_CAPTURE_STA&amp;amp;&lt;span&gt;0X3F&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt;             temp1*=&lt;span&gt;65536&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;溢出时间总和&lt;/span&gt;
&lt;span&gt; 57&lt;/span&gt;             temp1+=TIM2CH1_CAPTURE_VAL;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到总的高电平时间&lt;/span&gt;
&lt;span&gt; 58&lt;/span&gt;             printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;time2-----:%d \r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,temp1);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;打印总的高点平时间&lt;/span&gt;
&lt;span&gt; 59&lt;/span&gt;             TIM2CH1_CAPTURE_STA=&lt;span&gt;0&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;开启下一次捕获&lt;/span&gt;
&lt;span&gt; 60&lt;/span&gt;             PBout(&lt;span&gt;12&lt;/span&gt;)=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt;             delay_us(&lt;span&gt;13&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt;             PBout(&lt;span&gt;12&lt;/span&gt;)=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt; 
&lt;span&gt; 65&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定时器1通道4 &lt;/span&gt;
&lt;span&gt; 66&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(TIM1CH4_CAPTURE_STA&amp;amp;&lt;span&gt;0X80&lt;/span&gt;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;成功捕获到了一次上升沿&lt;/span&gt;
&lt;span&gt; 67&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt;             temp24=TIM1CH4_CAPTURE_STA&amp;amp;&lt;span&gt;0X3F&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt;             temp24*=&lt;span&gt;65536&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;溢出时间总和&lt;/span&gt;
&lt;span&gt; 70&lt;/span&gt;             temp24+=TIM1CH4_CAPTURE_VAL;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到总的高电平时间&lt;/span&gt;
&lt;span&gt; 71&lt;/span&gt;             printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;time14-----:%d \r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,temp24);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;打印总的高点平时间&lt;/span&gt;
&lt;span&gt; 72&lt;/span&gt;             TIM1CH4_CAPTURE_STA=&lt;span&gt;0&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;开启下一次捕获&lt;/span&gt;
&lt;span&gt; 73&lt;/span&gt;             PBout(&lt;span&gt;13&lt;/span&gt;)=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt;             delay_us(&lt;span&gt;13&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt;             PBout(&lt;span&gt;13&lt;/span&gt;)=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定时器3通道2&lt;/span&gt;
&lt;span&gt; 78&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(TIM3CH2_CAPTURE_STA&amp;amp;&lt;span&gt;0X80&lt;/span&gt;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;成功捕获到了一次上升沿&lt;/span&gt;
&lt;span&gt; 79&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt;             temp3=TIM3CH2_CAPTURE_STA&amp;amp;&lt;span&gt;0X3F&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt;             temp3*=&lt;span&gt;65536&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;溢出时间总和&lt;/span&gt;
&lt;span&gt; 82&lt;/span&gt;             temp3+=TIM3CH2_CAPTURE_VAL;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到总的高电平时间&lt;/span&gt;
&lt;span&gt; 83&lt;/span&gt;             printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;time32----:%d \r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,temp3);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;打印总的高点平时间&lt;/span&gt;
&lt;span&gt; 84&lt;/span&gt;             TIM3CH2_CAPTURE_STA=&lt;span&gt;0&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;开启下一次捕获&lt;/span&gt;
&lt;span&gt; 85&lt;/span&gt;             PBout(&lt;span&gt;14&lt;/span&gt;)=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt;             delay_us(&lt;span&gt;13&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt;             PBout(&lt;span&gt;14&lt;/span&gt;)=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定时器4通道1 &lt;/span&gt;
&lt;span&gt; 90&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(TIM4CH1_CAPTURE_STA&amp;amp;&lt;span&gt;0X80&lt;/span&gt;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;成功捕获到了一次上升沿&lt;/span&gt;
&lt;span&gt; 91&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt;             temp4=TIM4CH1_CAPTURE_STA&amp;amp;&lt;span&gt;0X3F&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt;             temp4*=&lt;span&gt;65536&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;溢出时间总和&lt;/span&gt;
&lt;span&gt; 94&lt;/span&gt;             temp4+=TIM4CH1_CAPTURE_VAL;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到总的高电平时间&lt;/span&gt;
&lt;span&gt; 95&lt;/span&gt;             printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;time4-----:%d \r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,temp4);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;打印总的高点平时间&lt;/span&gt;
&lt;span&gt; 96&lt;/span&gt;             TIM4CH1_CAPTURE_STA=&lt;span&gt;0&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;开启下一次捕获&lt;/span&gt;
&lt;span&gt; 97&lt;/span&gt;             PBout(&lt;span&gt;15&lt;/span&gt;)=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt;             delay_us(&lt;span&gt;13&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt;             PBout(&lt;span&gt;15&lt;/span&gt;)=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt; 
&lt;span&gt;102&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;发送最终结果------------------------------------&lt;/span&gt;
&lt;span&gt;103&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;((temp1 &amp;gt;&lt;span&gt;0&lt;/span&gt;)&amp;amp;&amp;amp;(temp24 &amp;gt;&lt;span&gt;0&lt;/span&gt;)&amp;amp;&amp;amp;(temp3 &amp;gt;&lt;span&gt;0&lt;/span&gt;)&amp;amp;&amp;amp;(temp4 &amp;gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)){
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt; 
&lt;span&gt;105&lt;/span&gt;           printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;[%d,%d,%d,%d]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,temp1,temp24,temp3,temp4);
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt;           temp1=temp24=temp3=temp4=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt;           PBout(&lt;span&gt;0&lt;/span&gt;)=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt; 
&lt;span&gt;110&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;strong&gt;定时器2通道1代码实现：&lt;/strong&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;54&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; #include&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;timex.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;usart.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定时器3通道1输入捕获配置&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;TIM_ICInitTypeDef  TIM2_ICInitStructure;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; TIM2_Cap_Init(u16 arr,u16 psc)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;{     
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;      GPIO_InitTypeDef GPIO_InitStructure;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;      TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;      NVIC_InitTypeDef NVIC_InitStructure;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;       printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;---time 22222  1111 ---\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;       RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;使能TIM2时钟&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;       RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;使能GPIOA时钟&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;     
&lt;span&gt;19&lt;/span&gt;       GPIO_InitStructure.GPIO_Pin  = GPIO_Pin_0;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;PA0清除之前设置  &lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;       GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPD; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;PA0 输入  &lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;       GPIO_Init(GPIOA, &amp;amp;&lt;span&gt;GPIO_InitStructure);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;       GPIO_ResetBits(GPIOA,GPIO_Pin_0);                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;PA0下拉
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     
&lt;span&gt;24&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化定时器5 TIM5     &lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;       TIM_TimeBaseStructure.TIM_Period = arr; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设定计数器自动重装值 &lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;       TIM_TimeBaseStructure.TIM_Prescaler =psc;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;预分频器   &lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;       TIM_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV1; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置时钟分割:TDTS = Tck_tim&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;       TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;TIM向上计数模式&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;       TIM_TimeBaseInit(TIM2, &amp;amp;TIM_TimeBaseStructure); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据TIM_TimeBaseInitStruct中指定的参数初始化TIMx的时间基数单位
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;   
&lt;span&gt;31&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化TIM5输入捕获参数&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;       TIM2_ICInitStructure.TIM_Channel = TIM_Channel_1; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;CC1S=01     选择输入端 IC1映射到TI1上&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt;       TIM2_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Rising;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;上升沿捕获&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt;       TIM2_ICInitStructure.TIM_ICSelection = TIM_ICSelection_DirectTI; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;映射到TI1上&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt;       TIM2_ICInitStructure.TIM_ICPrescaler = TIM_ICPSC_DIV1;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;配置输入分频,不分频 &lt;/span&gt;
&lt;span&gt;36&lt;/span&gt;       TIM2_ICInitStructure.TIM_ICFilter = &lt;span&gt;0x00&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;IC1F=0000 配置输入滤波器 不滤波&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt;       TIM_ICInit(TIM2, &amp;amp;&lt;span&gt;TIM2_ICInitStructure);
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;     
&lt;span&gt;39&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;中断分组初始化&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt;       NVIC_InitStructure.NVIC_IRQChannel = TIM2_IRQn;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;TIM3中断&lt;/span&gt;
&lt;span&gt;41&lt;/span&gt;       NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = &lt;span&gt;2&lt;/span&gt;;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;先占优先级2级&lt;/span&gt;
&lt;span&gt;42&lt;/span&gt;       NVIC_InitStructure.NVIC_IRQChannelSubPriority = &lt;span&gt;0&lt;/span&gt;;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;从优先级0级&lt;/span&gt;
&lt;span&gt;43&lt;/span&gt;       NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;IRQ通道被使能&lt;/span&gt;
&lt;span&gt;44&lt;/span&gt;       NVIC_Init(&amp;amp;NVIC_InitStructure);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据NVIC_InitStruct中指定的参数初始化外设NVIC寄存器 
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;printf(&quot;***********************************\r\n&quot;);    &lt;/span&gt;
&lt;span&gt;46&lt;/span&gt;       TIM_ITConfig(TIM2,TIM_IT_Update|TIM_IT_CC1,ENABLE);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;允许更新中断 ,允许CC1IE捕获中断    &lt;/span&gt;
&lt;span&gt;47&lt;/span&gt;     
&lt;span&gt;48&lt;/span&gt;       TIM_Cmd(TIM2,ENABLE );     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;使能定时器5&lt;/span&gt;
&lt;span&gt;49&lt;/span&gt;    
&lt;span&gt;50&lt;/span&gt; 
&lt;span&gt;51&lt;/span&gt; 
&lt;span&gt;52&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; 
&lt;span&gt;54&lt;/span&gt; u8  TIM2CH1_CAPTURE_STA=&lt;span&gt;0&lt;/span&gt;;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;输入捕获状态                            &lt;/span&gt;
&lt;span&gt;55&lt;/span&gt; u16 TIM2CH1_CAPTURE_VAL;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;输入捕获值
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;  
&lt;span&gt;57&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定时器5中断服务程序     &lt;/span&gt;
&lt;span&gt;58&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; TIM2_IRQHandler(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; &lt;span&gt;{ 
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;printf(&quot;********************222222***************\r\n&quot;);    &lt;/span&gt;
&lt;span&gt;61&lt;/span&gt;      &lt;span&gt;if&lt;/span&gt;((TIM2CH1_CAPTURE_STA&amp;amp;&lt;span&gt;0X80&lt;/span&gt;)==&lt;span&gt;0&lt;/span&gt;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;还未成功捕获    &lt;/span&gt;
&lt;span&gt;62&lt;/span&gt; &lt;span&gt;    {      
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (TIM_GetITStatus(TIM2, TIM_IT_Update) !=&lt;span&gt; RESET)
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt;          
&lt;span&gt;65&lt;/span&gt; &lt;span&gt;        {        
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(TIM2CH1_CAPTURE_STA&amp;amp;&lt;span&gt;0X40&lt;/span&gt;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;已经捕获到高电平了&lt;/span&gt;
&lt;span&gt;67&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;((TIM2CH1_CAPTURE_STA&amp;amp;&lt;span&gt;0X3F&lt;/span&gt;)==&lt;span&gt;0X3F&lt;/span&gt;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;高电平太长了&lt;/span&gt;
&lt;span&gt;69&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt;                     TIM2CH1_CAPTURE_STA|=&lt;span&gt;0X80&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;标记成功捕获了一次&lt;/span&gt;
&lt;span&gt;71&lt;/span&gt;                     TIM2CH1_CAPTURE_VAL=&lt;span&gt;0XFFFF&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt;                 }&lt;span&gt;else&lt;/span&gt; TIM2CH1_CAPTURE_STA++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;73&lt;/span&gt; &lt;span&gt;            }     
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (TIM_GetITStatus(TIM2, TIM_IT_CC1) != RESET)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;捕获1发生捕获事件&lt;/span&gt;
&lt;span&gt;76&lt;/span&gt; &lt;span&gt;        {    
&lt;/span&gt;&lt;span&gt;77&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(TIM2CH1_CAPTURE_STA&amp;amp;&lt;span&gt;0X40&lt;/span&gt;)        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;捕获到一个下降沿         &lt;/span&gt;
&lt;span&gt;78&lt;/span&gt; &lt;span&gt;            {                  
&lt;/span&gt;&lt;span&gt;79&lt;/span&gt;                 TIM2CH1_CAPTURE_STA|=&lt;span&gt;0X80&lt;/span&gt;;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;标记成功捕获到一次高电平脉宽&lt;/span&gt;
&lt;span&gt;80&lt;/span&gt;                 TIM2CH1_CAPTURE_VAL=&lt;span&gt;TIM_GetCapture1(TIM2);
&lt;/span&gt;&lt;span&gt;81&lt;/span&gt;                 TIM_OC1PolarityConfig(TIM2,TIM_ICPolarity_Rising); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;CC1P=0 设置为上升沿捕获&lt;/span&gt;
&lt;span&gt;82&lt;/span&gt;             }&lt;span&gt;else&lt;/span&gt;                                  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;还未开始,第一次捕获上升沿&lt;/span&gt;
&lt;span&gt;83&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;84&lt;/span&gt;                 TIM2CH1_CAPTURE_STA=&lt;span&gt;0&lt;/span&gt;;            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;清空&lt;/span&gt;
&lt;span&gt;85&lt;/span&gt;                 TIM2CH1_CAPTURE_VAL=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;86&lt;/span&gt;                 TIM_SetCounter(TIM2,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;87&lt;/span&gt;                 TIM2CH1_CAPTURE_STA|=&lt;span&gt;0X40&lt;/span&gt;;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;标记捕获到了上升沿&lt;/span&gt;
&lt;span&gt;88&lt;/span&gt;                 TIM_OC1PolarityConfig(TIM2,TIM_ICPolarity_Falling);        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;CC1P=1 设置为下降沿捕获&lt;/span&gt;
&lt;span&gt;89&lt;/span&gt; &lt;span&gt;            }            
&lt;/span&gt;&lt;span&gt;90&lt;/span&gt; &lt;span&gt;        }                                                
&lt;/span&gt;&lt;span&gt;91&lt;/span&gt; &lt;span&gt;     }
&lt;/span&gt;&lt;span&gt;92&lt;/span&gt; 
&lt;span&gt;93&lt;/span&gt;     TIM_ClearITPendingBit(TIM2, TIM_IT_CC1|TIM_IT_Update); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;清除中断标志位&lt;/span&gt;
&lt;span&gt;94&lt;/span&gt;  
&lt;span&gt;95&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt; &lt;strong&gt;定时器&lt;/strong&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;strong&gt;通道&lt;/strong&gt;&lt;strong&gt;4实现：&lt;/strong&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;56&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; #include&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;timex.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;usart.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;  3&lt;/span&gt; 
&lt;span&gt;  4&lt;/span&gt; 
&lt;span&gt;  5&lt;/span&gt; 
&lt;span&gt;  6&lt;/span&gt; &lt;span&gt;TIM_ICInitTypeDef  TIM1_ICInitStructure;
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt; 
&lt;span&gt;  8&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; TIM1_Cap_Init(u16 arr,u16 psc)
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt; &lt;span&gt;{  
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt;      
&lt;span&gt; 11&lt;/span&gt; &lt;span&gt;      GPIO_InitTypeDef GPIO_InitStructure;
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt; &lt;span&gt;      TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt; &lt;span&gt;      NVIC_InitTypeDef NVIC_InitStructure;
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt;       printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;---time 11111  4444 ---\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt;       RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM1, ENABLE);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;使能时钟&lt;/span&gt;
&lt;span&gt; 16&lt;/span&gt;       RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);  
&lt;span&gt; 17&lt;/span&gt;     
&lt;span&gt; 18&lt;/span&gt;       GPIO_InitStructure.GPIO_Pin  = GPIO_Pin_8|GPIO_Pin_11;  //&lt;span&gt;清除之前设置  &lt;/span&gt;
&lt;span&gt; 19&lt;/span&gt;       GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPD; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输入  &lt;/span&gt;
&lt;span&gt; 20&lt;/span&gt;       GPIO_Init(GPIOA, &amp;amp;&lt;span&gt;GPIO_InitStructure);
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt;       GPIO_ResetBits(GPIOA,GPIO_Pin_8|GPIO_Pin_11);                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;下拉
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt;     
&lt;span&gt; 23&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化定时器1     &lt;/span&gt;
&lt;span&gt; 24&lt;/span&gt;       TIM_TimeBaseStructure.TIM_Period = arr; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设定计数器自动重装值 &lt;/span&gt;
&lt;span&gt; 25&lt;/span&gt;       TIM_TimeBaseStructure.TIM_Prescaler =psc;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;预分频器   &lt;/span&gt;
&lt;span&gt; 26&lt;/span&gt;       TIM_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV1; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置时钟分割:TDTS = Tck_tim&lt;/span&gt;
&lt;span&gt; 27&lt;/span&gt;       TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;TIM向上计数模式&lt;/span&gt;
&lt;span&gt; 28&lt;/span&gt;       TIM_TimeBaseInit(TIM1, &amp;amp;TIM_TimeBaseStructure); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据TIM_TimeBaseInitStruct中指定的参数初始化TIMx的时间基数单位
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt;   
&lt;span&gt; 30&lt;/span&gt;      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化TIM1&lt;/span&gt;
&lt;span&gt; 31&lt;/span&gt;       TIM1_ICInitStructure.TIM_Channel = TIM_Channel_4; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;CC1S=01     选择输入端 IC1映射到TI1上&lt;/span&gt;
&lt;span&gt; 32&lt;/span&gt;       TIM1_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Rising;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;上升沿捕获&lt;/span&gt;
&lt;span&gt; 33&lt;/span&gt;       TIM1_ICInitStructure.TIM_ICSelection = TIM_ICSelection_DirectTI; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;映射到TI1上&lt;/span&gt;
&lt;span&gt; 34&lt;/span&gt;       TIM1_ICInitStructure.TIM_ICPrescaler = TIM_ICPSC_DIV1;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;配置输入分频,不分频 &lt;/span&gt;
&lt;span&gt; 35&lt;/span&gt;       TIM1_ICInitStructure.TIM_ICFilter = &lt;span&gt;0x00&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;IC1F=0000 配置输入滤波器 不滤波&lt;/span&gt;
&lt;span&gt; 36&lt;/span&gt;       TIM_ICInit(TIM1, &amp;amp;&lt;span&gt;TIM1_ICInitStructure);
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt;     
&lt;span&gt; 38&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;中断分组初始化
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Device header&lt;/span&gt;
&lt;span&gt; 40&lt;/span&gt;       NVIC_InitStructure.NVIC_IRQChannel = TIM1_CC_IRQn;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;中断&lt;/span&gt;
&lt;span&gt; 41&lt;/span&gt;       NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = &lt;span&gt;2&lt;/span&gt;;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;先占优先级2级&lt;/span&gt;
&lt;span&gt; 42&lt;/span&gt;       NVIC_InitStructure.NVIC_IRQChannelSubPriority = &lt;span&gt;0&lt;/span&gt;;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;从优先级0级&lt;/span&gt;
&lt;span&gt; 43&lt;/span&gt;       NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;IRQ通道被使能&lt;/span&gt;
&lt;span&gt; 44&lt;/span&gt;       NVIC_Init(&amp;amp;NVIC_InitStructure);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据NVIC_InitStruct中指定的参数初始化外设NVIC寄存器 &lt;/span&gt;
&lt;span&gt; 45&lt;/span&gt;     
&lt;span&gt; 46&lt;/span&gt;       TIM_ITConfig(TIM1,TIM_IT_CC4|TIM_IT_Update,ENABLE);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;允许更新中断 ,允许CC1IE捕获中断    &lt;/span&gt;
&lt;span&gt; 47&lt;/span&gt;     
&lt;span&gt; 48&lt;/span&gt;       TIM_Cmd(TIM1,ENABLE );     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;使能定时器1&lt;/span&gt;
&lt;span&gt; 49&lt;/span&gt;  
&lt;span&gt; 50&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt; 
&lt;span&gt; 52&lt;/span&gt; 
&lt;span&gt; 53&lt;/span&gt;  u8  TIM1CH4_CAPTURE_STA=&lt;span&gt;0&lt;/span&gt;;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;输入捕获状态                            &lt;/span&gt;
&lt;span&gt; 54&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;    TIM1CH4_CAPTURE_VAL_0,TIM1CH4_CAPTURE_VAL;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;输入捕获值
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定时器5中断服务程序     &lt;/span&gt;
&lt;span&gt; 56&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; TIM1_UP_IRQHandler(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt; 
&lt;span&gt; 59&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;((TIM1CH4_CAPTURE_STA&amp;amp;&lt;span&gt;0X80&lt;/span&gt;)==&lt;span&gt;0&lt;/span&gt;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;还未成功捕获    &lt;/span&gt;
&lt;span&gt; 60&lt;/span&gt; &lt;span&gt;    {      
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (TIM_GetITStatus(TIM1, TIM_IT_Update) !=&lt;span&gt; RESET)
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt;          
&lt;span&gt; 63&lt;/span&gt; &lt;span&gt;        {         
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(TIM1CH4_CAPTURE_STA&amp;amp;&lt;span&gt;0X40&lt;/span&gt;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;已经捕获到高电平了&lt;/span&gt;
&lt;span&gt; 65&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;((TIM1CH4_CAPTURE_STA&amp;amp;&lt;span&gt;0X3F&lt;/span&gt;)==&lt;span&gt;0X3F&lt;/span&gt;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;高电平太长了&lt;/span&gt;
&lt;span&gt; 67&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt;                     TIM1CH4_CAPTURE_STA|=&lt;span&gt;0X80&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;标记成功捕获了一次&lt;/span&gt;
&lt;span&gt; 69&lt;/span&gt;                     TIM1CH4_CAPTURE_VAL=&lt;span&gt;0XFFFF&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt;                 }&lt;span&gt;else&lt;/span&gt; TIM1CH4_CAPTURE_STA++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt; &lt;span&gt;            }     
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt; &lt;span&gt;     }
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt;  
&lt;span&gt; 75&lt;/span&gt;     TIM_ClearITPendingBit(TIM1, TIM_IT_Update); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;清除中断标志位&lt;/span&gt;
&lt;span&gt; 76&lt;/span&gt; 
&lt;span&gt; 77&lt;/span&gt; 
&lt;span&gt; 78&lt;/span&gt; 
&lt;span&gt; 79&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; TIM1_CC_IRQHandler(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt; &lt;span&gt;{     
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;((TIM1CH4_CAPTURE_STA&amp;amp;&lt;span&gt;0X80&lt;/span&gt;)==&lt;span&gt;0&lt;/span&gt;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;还未成功捕获    &lt;/span&gt;
&lt;span&gt; 83&lt;/span&gt; &lt;span&gt;    {      
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt;       &lt;span&gt;if&lt;/span&gt; (TIM_GetITStatus(TIM1, TIM_IT_CC4) != RESET)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;捕获1发生捕获事件&lt;/span&gt;
&lt;span&gt; 85&lt;/span&gt; &lt;span&gt;        {    
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(TIM1CH4_CAPTURE_STA&amp;amp;&lt;span&gt;0X40&lt;/span&gt;)        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;捕获到一个下降沿         &lt;/span&gt;
&lt;span&gt; 87&lt;/span&gt; &lt;span&gt;            {                  
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt;                 TIM1CH4_CAPTURE_STA|=&lt;span&gt;0X80&lt;/span&gt;;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;标记成功捕获到一次上升沿&lt;/span&gt;
&lt;span&gt; 89&lt;/span&gt;                 TIM1CH4_CAPTURE_VAL=TIM_GetCapture4(TIM1)-&lt;span&gt;TIM1CH4_CAPTURE_VAL_0;
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt;                 TIM_OC4PolarityConfig(TIM1,TIM_ICPolarity_Rising); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;CC1P=0 设置为上升沿捕获&lt;/span&gt;
&lt;span&gt; 91&lt;/span&gt;             }&lt;span&gt;else&lt;/span&gt;                                  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;还未开始,第一次捕获上升沿&lt;/span&gt;
&lt;span&gt; 92&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt;                  TIM1CH4_CAPTURE_STA=&lt;span&gt;0&lt;/span&gt;;            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;清空&lt;/span&gt;
&lt;span&gt; 94&lt;/span&gt;                  TIM1CH4_CAPTURE_VAL_0=TIM_GetCapture4(TIM1);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;!!!!!!!!!!!!!!!!!!!!!!!
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt;                  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;TIM_SetCounter(TIM1,0);&lt;/span&gt;
&lt;span&gt; 96&lt;/span&gt;                  TIM1CH4_CAPTURE_STA|=&lt;span&gt;0X40&lt;/span&gt;;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;标记捕获到了上升沿&lt;/span&gt;
&lt;span&gt; 97&lt;/span&gt;                  TIM_OC4PolarityConfig(TIM1,TIM_ICPolarity_Falling);        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;CC1P=1 设置为下降沿捕获&lt;/span&gt;
&lt;span&gt; 98&lt;/span&gt; &lt;span&gt;            }            
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt; &lt;span&gt;        }                    
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt; &lt;span&gt;     }
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt;  
&lt;span&gt;102&lt;/span&gt;     TIM_ClearITPendingBit(TIM1, TIM_IT_CC1); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;清除中断标志位&lt;/span&gt;
&lt;span&gt;103&lt;/span&gt;  
&lt;span&gt;104&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;strong&gt;定时器&lt;/strong&gt;&lt;strong&gt;3&lt;/strong&gt;&lt;strong&gt;通道&lt;/strong&gt;&lt;strong&gt;2代码实现：&lt;/strong&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt;  #include&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;timex.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt;     #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;usart.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;  3&lt;/span&gt; 
&lt;span&gt;  4&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定时器3通道1输入捕获配置&lt;/span&gt;
&lt;span&gt;  5&lt;/span&gt; 
&lt;span&gt;  6&lt;/span&gt; &lt;span&gt;TIM_ICInitTypeDef  TIM3_ICInitStructure;
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt; &lt;span&gt;TIM_ICInitTypeDef  TIM3_ICInitStructure1;
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; TIM3_Cap_Init(u16 arr,u16 psc)
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt; &lt;span&gt;{     
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt; 
&lt;span&gt; 11&lt;/span&gt; &lt;span&gt;      GPIO_InitTypeDef GPIO_InitStructure;
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt; &lt;span&gt;      TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt; &lt;span&gt;      NVIC_InitTypeDef NVIC_InitStructure;
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt;  
&lt;span&gt; 15&lt;/span&gt;       printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;---time 33333  2222 ---\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt;       RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;使能时钟&lt;/span&gt;
&lt;span&gt; 17&lt;/span&gt;       RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);  
&lt;span&gt; 18&lt;/span&gt;     
&lt;span&gt; 19&lt;/span&gt;       GPIO_InitStructure.GPIO_Pin  = GPIO_Pin_6|GPIO_Pin_7;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;清除之前设置  &lt;/span&gt;
&lt;span&gt; 20&lt;/span&gt;       GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPD; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;输入  &lt;/span&gt;
&lt;span&gt; 21&lt;/span&gt;       GPIO_Init(GPIOA, &amp;amp;&lt;span&gt;GPIO_InitStructure);
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt;       GPIO_ResetBits(GPIOA,GPIO_Pin_6 | GPIO_Pin_7);                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;下拉
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt;     
&lt;span&gt; 24&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化定时器5 TIM5     &lt;/span&gt;
&lt;span&gt; 25&lt;/span&gt;       TIM_TimeBaseStructure.TIM_Period = arr; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设定计数器自动重装值 &lt;/span&gt;
&lt;span&gt; 26&lt;/span&gt;       TIM_TimeBaseStructure.TIM_Prescaler =psc;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;预分频器   &lt;/span&gt;
&lt;span&gt; 27&lt;/span&gt;       TIM_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV1; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置时钟分割:TDTS = Tck_tim&lt;/span&gt;
&lt;span&gt; 28&lt;/span&gt;       TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;TIM向上计数模式&lt;/span&gt;
&lt;span&gt; 29&lt;/span&gt;       TIM_TimeBaseInit(TIM3, &amp;amp;TIM_TimeBaseStructure); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据TIM_TimeBaseInitStruct中指定的参数初始化TIMx的时间基数单位
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt;   
&lt;span&gt; 31&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化TIM5输入捕获参数&lt;/span&gt;
&lt;span&gt; 32&lt;/span&gt;       TIM3_ICInitStructure.TIM_Channel = TIM_Channel_1; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;CC1S=01     选择输入端 IC1映射到TI1上&lt;/span&gt;
&lt;span&gt; 33&lt;/span&gt;       TIM3_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Rising;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;上升沿捕获&lt;/span&gt;
&lt;span&gt; 34&lt;/span&gt;       TIM3_ICInitStructure.TIM_ICSelection = TIM_ICSelection_DirectTI; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;映射到TI1上&lt;/span&gt;
&lt;span&gt; 35&lt;/span&gt;       TIM3_ICInitStructure.TIM_ICPrescaler = TIM_ICPSC_DIV1;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;配置输入分频,不分频 &lt;/span&gt;
&lt;span&gt; 36&lt;/span&gt;       TIM3_ICInitStructure.TIM_ICFilter = &lt;span&gt;0x00&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;IC1F=0000 配置输入滤波器 不滤波&lt;/span&gt;
&lt;span&gt; 37&lt;/span&gt;       TIM_ICInit(TIM3, &amp;amp;&lt;span&gt;TIM3_ICInitStructure);
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt;     
&lt;span&gt; 39&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化TIM5输入捕获参数&lt;/span&gt;
&lt;span&gt; 40&lt;/span&gt;       TIM3_ICInitStructure1.TIM_Channel = TIM_Channel_2; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;CC1S=01     选择输入端 IC1映射到TI1上&lt;/span&gt;
&lt;span&gt; 41&lt;/span&gt;       TIM3_ICInitStructure1.TIM_ICPolarity = TIM_ICPolarity_Rising;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;上升沿捕获&lt;/span&gt;
&lt;span&gt; 42&lt;/span&gt;       TIM3_ICInitStructure1.TIM_ICSelection = TIM_ICSelection_DirectTI; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;映射到TI2上！！！！！！！！！！！！！！     ！！！！！&lt;/span&gt;
&lt;span&gt; 43&lt;/span&gt;       TIM3_ICInitStructure1.TIM_ICPrescaler = TIM_ICPSC_DIV1;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;配置输入分频,不分频 &lt;/span&gt;
&lt;span&gt; 44&lt;/span&gt;       TIM3_ICInitStructure1.TIM_ICFilter = &lt;span&gt;0x00&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;IC1F=0000 配置输入滤波器 不滤波&lt;/span&gt;
&lt;span&gt; 45&lt;/span&gt;       TIM_ICInit(TIM3, &amp;amp;&lt;span&gt;TIM3_ICInitStructure1);
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt; 
&lt;span&gt; 47&lt;/span&gt; 
&lt;span&gt; 48&lt;/span&gt; 
&lt;span&gt; 49&lt;/span&gt; 
&lt;span&gt; 50&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;中断分组初始化&lt;/span&gt;
&lt;span&gt; 51&lt;/span&gt;       NVIC_InitStructure.NVIC_IRQChannel = TIM3_IRQn;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;TIM3中断&lt;/span&gt;
&lt;span&gt; 52&lt;/span&gt;       NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = &lt;span&gt;1&lt;/span&gt;;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;先占优先级2级&lt;/span&gt;
&lt;span&gt; 53&lt;/span&gt;       NVIC_InitStructure.NVIC_IRQChannelSubPriority = &lt;span&gt;0&lt;/span&gt;;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;从优先级0级&lt;/span&gt;
&lt;span&gt; 54&lt;/span&gt;       NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;IRQ通道被使能&lt;/span&gt;
&lt;span&gt; 55&lt;/span&gt;       NVIC_Init(&amp;amp;NVIC_InitStructure);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据NVIC_InitStruct中指定的参数初始化外设NVIC寄存器 
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;printf(&quot;***********************************\r\n&quot;);    &lt;/span&gt;
&lt;span&gt; 57&lt;/span&gt;       TIM_ITConfig(TIM3,TIM_IT_Update|TIM_IT_CC1|TIM_IT_CC2,ENABLE);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;允许更新中断 ,允许CC1IE捕获中断    &lt;/span&gt;
&lt;span&gt; 58&lt;/span&gt;     
&lt;span&gt; 59&lt;/span&gt;       TIM_Cmd(TIM3,ENABLE );     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;使能定时器5&lt;/span&gt;
&lt;span&gt; 60&lt;/span&gt;    
&lt;span&gt; 61&lt;/span&gt; 
&lt;span&gt; 62&lt;/span&gt; 
&lt;span&gt; 63&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt; 
&lt;span&gt; 65&lt;/span&gt; u8  TIM3CH1_CAPTURE_STA=&lt;span&gt;0&lt;/span&gt;;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;输入捕获状态                            &lt;/span&gt;
&lt;span&gt; 66&lt;/span&gt; u16    TIM3CH1_CAPTURE_VAL;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;输入捕获值&lt;/span&gt;
&lt;span&gt; 67&lt;/span&gt; 
&lt;span&gt; 68&lt;/span&gt; u8  TIM3CH2_CAPTURE_STA=&lt;span&gt;0&lt;/span&gt;;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;输入捕获状态                            &lt;/span&gt;
&lt;span&gt; 69&lt;/span&gt; u16    TIM3CH2_CAPTURE_VAL;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;输入捕获值&lt;/span&gt;
&lt;span&gt; 70&lt;/span&gt;  
&lt;span&gt; 71&lt;/span&gt;  &lt;span&gt;void&lt;/span&gt; TIM3_IRQHandler(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt; &lt;span&gt;{ 
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt;      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;printf(&quot;********************222222***************\r\n&quot;);    &lt;/span&gt;
&lt;span&gt; 74&lt;/span&gt;        
&lt;span&gt; 75&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (TIM_GetITStatus(TIM3, TIM_IT_Update) !=&lt;span&gt; RESET)
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt;          
&lt;span&gt; 77&lt;/span&gt; &lt;span&gt;        {    
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;((TIM3CH1_CAPTURE_STA&amp;amp;&lt;span&gt;0X80&lt;/span&gt;)==&lt;span&gt;0&lt;/span&gt;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;还未成功捕获    &lt;/span&gt;
&lt;span&gt; 79&lt;/span&gt; &lt;span&gt;        {    
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(TIM3CH1_CAPTURE_STA&amp;amp;&lt;span&gt;0X40&lt;/span&gt;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;已经捕获到高电平了&lt;/span&gt;
&lt;span&gt; 81&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;((TIM3CH1_CAPTURE_STA&amp;amp;&lt;span&gt;0X3F&lt;/span&gt;)==&lt;span&gt;0X3F&lt;/span&gt;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;高电平太长了&lt;/span&gt;
&lt;span&gt; 83&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt;                 
&lt;span&gt; 85&lt;/span&gt;                     TIM3CH1_CAPTURE_VAL=&lt;span&gt;0XFFFF&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt;                     TIM3CH1_CAPTURE_STA|=&lt;span&gt;0X80&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;标记成功捕获了一次&lt;/span&gt;
&lt;span&gt; 87&lt;/span&gt;                 }&lt;span&gt;else&lt;/span&gt; TIM3CH1_CAPTURE_STA++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt; &lt;span&gt;            }    
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt;         
&lt;span&gt; 91&lt;/span&gt;             
&lt;span&gt; 92&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;((TIM3CH2_CAPTURE_STA&amp;amp;&lt;span&gt;0X80&lt;/span&gt;)==&lt;span&gt;0&lt;/span&gt;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;还未成功捕获    &lt;/span&gt;
&lt;span&gt; 93&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;(TIM3CH2_CAPTURE_STA&amp;amp;&lt;span&gt;0X40&lt;/span&gt;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;已经捕获到高电平了&lt;/span&gt;
&lt;span&gt; 95&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;((TIM3CH2_CAPTURE_STA&amp;amp;&lt;span&gt;0X3F&lt;/span&gt;)==&lt;span&gt;0X3F&lt;/span&gt;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;高电平太长了&lt;/span&gt;
&lt;span&gt; 97&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt;                 
&lt;span&gt; 99&lt;/span&gt;                     TIM3CH2_CAPTURE_VAL=&lt;span&gt;0XFFFF&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;                     TIM3CH2_CAPTURE_STA|=&lt;span&gt;0X80&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;标记成功捕获了一次&lt;/span&gt;
&lt;span&gt;101&lt;/span&gt;                 }&lt;span&gt;else&lt;/span&gt; TIM3CH2_CAPTURE_STA++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt; &lt;span&gt;            } 
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt; 
&lt;span&gt;104&lt;/span&gt; &lt;span&gt;        } 
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt;         }&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt; 
&lt;span&gt;107&lt;/span&gt; 
&lt;span&gt;108&lt;/span&gt; 
&lt;span&gt;109&lt;/span&gt; 
&lt;span&gt;110&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;((TIM3CH1_CAPTURE_STA&amp;amp;&lt;span&gt;0X80&lt;/span&gt;)==&lt;span&gt;0&lt;/span&gt;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;还未成功捕获    &lt;/span&gt;
&lt;span&gt;111&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (TIM_GetITStatus(TIM3, TIM_IT_CC1) != RESET)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;捕获1发生捕获事件&lt;/span&gt;
&lt;span&gt;113&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt;             
&lt;span&gt;115&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(TIM3CH1_CAPTURE_STA&amp;amp;&lt;span&gt;0X40&lt;/span&gt;)        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;捕获到一个下降沿         &lt;/span&gt;
&lt;span&gt;116&lt;/span&gt; &lt;span&gt;            {                  
&lt;/span&gt;&lt;span&gt;117&lt;/span&gt;                 TIM3CH1_CAPTURE_STA|=&lt;span&gt;0X80&lt;/span&gt;;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;标记成功捕获到一次高电平脉宽&lt;/span&gt;
&lt;span&gt;118&lt;/span&gt;                 TIM3CH1_CAPTURE_VAL=&lt;span&gt;TIM_GetCapture1(TIM3);
&lt;/span&gt;&lt;span&gt;119&lt;/span&gt;                 TIM_OC1PolarityConfig(TIM3,TIM_ICPolarity_Rising); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;CC1P=0 设置为上升沿捕获&lt;/span&gt;
&lt;span&gt;120&lt;/span&gt;             }&lt;span&gt;else&lt;/span&gt;                                  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;还未开始,第一次捕获上升沿&lt;/span&gt;
&lt;span&gt;121&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;122&lt;/span&gt;                 TIM3CH1_CAPTURE_STA=&lt;span&gt;0&lt;/span&gt;;            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;清空&lt;/span&gt;
&lt;span&gt;123&lt;/span&gt;                 TIM3CH1_CAPTURE_VAL=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;124&lt;/span&gt;                 TIM_SetCounter(TIM3,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;125&lt;/span&gt;                 
&lt;span&gt;126&lt;/span&gt;                 TIM_OC1PolarityConfig(TIM3,TIM_ICPolarity_Falling);        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;CC1P=1 设置为下降沿捕获&lt;/span&gt;
&lt;span&gt;127&lt;/span&gt;                 TIM3CH1_CAPTURE_STA|=&lt;span&gt;0X40&lt;/span&gt;;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;标记捕获到了上升沿&lt;/span&gt;
&lt;span&gt;128&lt;/span&gt; &lt;span&gt;            }            
&lt;/span&gt;&lt;span&gt;129&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;130&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;131&lt;/span&gt; 
&lt;span&gt;132&lt;/span&gt; 
&lt;span&gt;133&lt;/span&gt; 
&lt;span&gt;134&lt;/span&gt; 
&lt;span&gt;135&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;((TIM3CH2_CAPTURE_STA&amp;amp;&lt;span&gt;0X80&lt;/span&gt;)==&lt;span&gt;0&lt;/span&gt;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;还未成功捕获    &lt;/span&gt;
&lt;span&gt;136&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;137&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (TIM_GetITStatus(TIM3, TIM_IT_CC2) != RESET)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;捕获1发生捕获事件&lt;/span&gt;
&lt;span&gt;138&lt;/span&gt; &lt;span&gt;        {    
&lt;/span&gt;&lt;span&gt;139&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(TIM3CH2_CAPTURE_STA&amp;amp;&lt;span&gt;0X40&lt;/span&gt;)        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;捕获到一个下降沿         &lt;/span&gt;
&lt;span&gt;140&lt;/span&gt; &lt;span&gt;            {                  
&lt;/span&gt;&lt;span&gt;141&lt;/span&gt;                  TIM3CH2_CAPTURE_STA|=&lt;span&gt;0X80&lt;/span&gt;;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;标记成功捕获到一次高电平脉宽&lt;/span&gt;
&lt;span&gt;142&lt;/span&gt;                  TIM3CH2_CAPTURE_VAL=&lt;span&gt;TIM_GetCapture2(TIM3);
&lt;/span&gt;&lt;span&gt;143&lt;/span&gt;                  TIM_OC2PolarityConfig(TIM3,TIM_ICPolarity_Rising); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;CC1P=0 设置为上升沿捕获&lt;/span&gt;
&lt;span&gt;144&lt;/span&gt;             }&lt;span&gt;else&lt;/span&gt;                                  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;还未开始,第一次捕获上升沿&lt;/span&gt;
&lt;span&gt;145&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;146&lt;/span&gt;                  TIM3CH2_CAPTURE_STA=&lt;span&gt;0&lt;/span&gt;;            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;清空&lt;/span&gt;
&lt;span&gt;147&lt;/span&gt;                  TIM3CH2_CAPTURE_VAL=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;148&lt;/span&gt;                  TIM_SetCounter(TIM3,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;149&lt;/span&gt;             
&lt;span&gt;150&lt;/span&gt;                  TIM_OC2PolarityConfig(TIM3,TIM_ICPolarity_Falling);        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;CC1P=1 设置为下降沿捕获&lt;/span&gt;
&lt;span&gt;151&lt;/span&gt;                  TIM3CH2_CAPTURE_STA|=&lt;span&gt;0X40&lt;/span&gt;;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;标记捕获到了上升沿&lt;/span&gt;
&lt;span&gt;152&lt;/span&gt; &lt;span&gt;            }            
&lt;/span&gt;&lt;span&gt;153&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;154&lt;/span&gt;         
&lt;span&gt;155&lt;/span&gt; &lt;span&gt;    }}    
&lt;/span&gt;&lt;span&gt;156&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    TIM_SetCounter(TIM3,0);    &lt;/span&gt;
&lt;span&gt;157&lt;/span&gt;     TIM_ClearITPendingBit(TIM3, TIM_IT_CC1|TIM_IT_Update|TIM_IT_CC2); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;清除中断标志位&lt;/span&gt;
&lt;span&gt;158&lt;/span&gt;  
&lt;span&gt;159&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;strong&gt;定时器&lt;/strong&gt;&lt;strong&gt;4&lt;/strong&gt;&lt;strong&gt;通道&lt;/strong&gt;&lt;strong&gt;1代码实现：&lt;/strong&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;54&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; #include&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;timex.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;usart.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定时器4通道1输入捕获配置&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;TIM_ICInitTypeDef  TIM4_ICInitStructure;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; TIM4_Cap_Init(u16 arr,u16 psc)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;{     
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;        &lt;span&gt;GPIO_InitTypeDef GPIO_InitStructure;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;        &lt;span&gt;TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;       NVIC_InitTypeDef NVIC_InitStructure;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;        printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;---time 44444  1111 ---\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;        RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM4, ENABLE);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;使能TIM4时钟&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;        RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;使能GPIOB时钟&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;     
&lt;span&gt;19&lt;/span&gt;        GPIO_InitStructure.GPIO_Pin  = GPIO_Pin_6;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;清除之前设置  &lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;        GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPD; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;输入  &lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;        GPIO_Init(GPIOB, &amp;amp;&lt;span&gt;GPIO_InitStructure);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;        GPIO_ResetBits(GPIOB,GPIO_Pin_6);                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 下拉
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     
&lt;span&gt;24&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化定时器5 TIM5     &lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;        TIM_TimeBaseStructure.TIM_Period = arr; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设定计数器自动重装值 &lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;        TIM_TimeBaseStructure.TIM_Prescaler =psc;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;预分频器   &lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;        TIM_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV1; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置时钟分割:TDTS = Tck_tim&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;        TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;TIM向上计数模式&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;        TIM_TimeBaseInit(TIM4, &amp;amp;TIM_TimeBaseStructure); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据TIM_TimeBaseInitStruct中指定的参数初始化TIMx的时间基数单位
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;   
&lt;span&gt;31&lt;/span&gt;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化TIM5输入捕获参数&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;        TIM4_ICInitStructure.TIM_Channel = TIM_Channel_1; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;CC1S=01     选择输入端 IC1映射到TI1上&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt;        TIM4_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Rising;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;上升沿捕获&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt;        TIM4_ICInitStructure.TIM_ICSelection = TIM_ICSelection_DirectTI; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;映射到TI1上&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt;        TIM4_ICInitStructure.TIM_ICPrescaler = TIM_ICPSC_DIV1;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;配置输入分频,不分频 &lt;/span&gt;
&lt;span&gt;36&lt;/span&gt;        TIM4_ICInitStructure.TIM_ICFilter = &lt;span&gt;0x00&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;IC1F=0000 配置输入滤波器 不滤波&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt;        TIM_ICInit(TIM4, &amp;amp;&lt;span&gt;TIM4_ICInitStructure);
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;     
&lt;span&gt;39&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;中断分组初始化&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt;       NVIC_InitStructure.NVIC_IRQChannel = TIM4_IRQn;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;TIM3中断&lt;/span&gt;
&lt;span&gt;41&lt;/span&gt;       NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = &lt;span&gt;2&lt;/span&gt;;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;先占优先级2级&lt;/span&gt;
&lt;span&gt;42&lt;/span&gt;       NVIC_InitStructure.NVIC_IRQChannelSubPriority = &lt;span&gt;0&lt;/span&gt;;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;从优先级0级&lt;/span&gt;
&lt;span&gt;43&lt;/span&gt;       NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;IRQ通道被使能&lt;/span&gt;
&lt;span&gt;44&lt;/span&gt;       NVIC_Init(&amp;amp;NVIC_InitStructure);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据NVIC_InitStruct中指定的参数初始化外设NVIC寄存器 
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;printf(&quot;***********************************\r\n&quot;);    &lt;/span&gt;
&lt;span&gt;46&lt;/span&gt;       TIM_ITConfig(TIM4,TIM_IT_Update|TIM_IT_CC1,ENABLE);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;允许更新中断 ,允许CC1IE捕获中断    &lt;/span&gt;
&lt;span&gt;47&lt;/span&gt;     
&lt;span&gt;48&lt;/span&gt;       TIM_Cmd(TIM4,ENABLE );     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;使能定时器5&lt;/span&gt;
&lt;span&gt;49&lt;/span&gt;    
&lt;span&gt;50&lt;/span&gt; 
&lt;span&gt;51&lt;/span&gt; 
&lt;span&gt;52&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; 
&lt;span&gt;54&lt;/span&gt; u8  TIM4CH1_CAPTURE_STA=&lt;span&gt;0&lt;/span&gt;;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;输入捕获状态                            &lt;/span&gt;
&lt;span&gt;55&lt;/span&gt; u16    TIM4CH1_CAPTURE_VAL;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;输入捕获值
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;  
&lt;span&gt;57&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定时器5中断服务程序     &lt;/span&gt;
&lt;span&gt;58&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; TIM4_IRQHandler(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; &lt;span&gt;{ 
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;printf(&quot;********************222222***************\r\n&quot;);    &lt;/span&gt;
&lt;span&gt;61&lt;/span&gt;      &lt;span&gt;if&lt;/span&gt;((TIM4CH1_CAPTURE_STA&amp;amp;&lt;span&gt;0X80&lt;/span&gt;)==&lt;span&gt;0&lt;/span&gt;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;还未成功捕获    &lt;/span&gt;
&lt;span&gt;62&lt;/span&gt; &lt;span&gt;    {      
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (TIM_GetITStatus(TIM4, TIM_IT_Update) !=&lt;span&gt; RESET)
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt;          
&lt;span&gt;65&lt;/span&gt; &lt;span&gt;        {        
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(TIM4CH1_CAPTURE_STA&amp;amp;&lt;span&gt;0X40&lt;/span&gt;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;已经捕获到高电平了&lt;/span&gt;
&lt;span&gt;67&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;((TIM4CH1_CAPTURE_STA&amp;amp;&lt;span&gt;0X3F&lt;/span&gt;)==&lt;span&gt;0X3F&lt;/span&gt;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;高电平太长了&lt;/span&gt;
&lt;span&gt;69&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt;                     TIM4CH1_CAPTURE_STA|=&lt;span&gt;0X80&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;标记成功捕获了一次&lt;/span&gt;
&lt;span&gt;71&lt;/span&gt;                     TIM4CH1_CAPTURE_VAL=&lt;span&gt;0XFFFF&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt;                 }&lt;span&gt;else&lt;/span&gt; TIM4CH1_CAPTURE_STA++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;73&lt;/span&gt; &lt;span&gt;            }     
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (TIM_GetITStatus(TIM4, TIM_IT_CC1) != RESET)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;捕获1发生捕获事件&lt;/span&gt;
&lt;span&gt;76&lt;/span&gt; &lt;span&gt;        {    
&lt;/span&gt;&lt;span&gt;77&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(TIM4CH1_CAPTURE_STA&amp;amp;&lt;span&gt;0X40&lt;/span&gt;)        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;捕获到一个下降沿         &lt;/span&gt;
&lt;span&gt;78&lt;/span&gt; &lt;span&gt;            {                  
&lt;/span&gt;&lt;span&gt;79&lt;/span&gt;                  TIM4CH1_CAPTURE_STA|=&lt;span&gt;0X80&lt;/span&gt;;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;标记成功捕获到一次高电平脉宽&lt;/span&gt;
&lt;span&gt;80&lt;/span&gt;                  TIM4CH1_CAPTURE_VAL=&lt;span&gt;TIM_GetCapture1(TIM4);
&lt;/span&gt;&lt;span&gt;81&lt;/span&gt;                  TIM_OC1PolarityConfig(TIM4,TIM_ICPolarity_Rising); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;CC1P=0 设置为上升沿捕获&lt;/span&gt;
&lt;span&gt;82&lt;/span&gt;             }&lt;span&gt;else&lt;/span&gt;                                  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;还未开始,第一次捕获上升沿&lt;/span&gt;
&lt;span&gt;83&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;84&lt;/span&gt;                  TIM4CH1_CAPTURE_STA=&lt;span&gt;0&lt;/span&gt;;            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;清空&lt;/span&gt;
&lt;span&gt;85&lt;/span&gt;                  TIM4CH1_CAPTURE_VAL=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;86&lt;/span&gt;                  TIM_SetCounter(TIM4,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;87&lt;/span&gt;                  TIM4CH1_CAPTURE_STA|=&lt;span&gt;0X40&lt;/span&gt;;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;标记捕获到了上升沿&lt;/span&gt;
&lt;span&gt;88&lt;/span&gt;                  TIM_OC1PolarityConfig(TIM4,TIM_ICPolarity_Falling);        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;CC1P=1 设置为下降沿捕获&lt;/span&gt;
&lt;span&gt;89&lt;/span&gt; &lt;span&gt;            }            
&lt;/span&gt;&lt;span&gt;90&lt;/span&gt; &lt;span&gt;        }                                                
&lt;/span&gt;&lt;span&gt;91&lt;/span&gt; &lt;span&gt;     }
&lt;/span&gt;&lt;span&gt;92&lt;/span&gt; 
&lt;span&gt;93&lt;/span&gt;     TIM_ClearITPendingBit(TIM4, TIM_IT_CC1|TIM_IT_Update); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;清除中断标志位&lt;/span&gt;
&lt;span&gt;94&lt;/span&gt;  
&lt;span&gt;95&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;hr/&gt;
</description>
<pubDate>Sun, 27 Jan 2019 17:21:00 +0000</pubDate>
<dc:creator>东小东</dc:creator>
<og:description>超声波手势识别在市场上已经有见实现，但研究其传感器发现并不是市场上随意可见的，如果暂且考虑成本，该如何入门实现简单的手势识别呢。聊天中老师给出一个很好的提议，就是固定四个超声波，分别为上下左右，然后进</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dongxiaodong/p/10134873.html</dc:identifier>
</item>
<item>
<title>大数据学习之_02_Shell学习_Shell概述+Shell解析器+Shell脚本入门+运算符+条件判断+流程控制(重点)+read读取控制台输入+函数+Shell工具(重点)+企业真实面试题(重点) - 黑泽君</title>
<link>http://www.cnblogs.com/chenmingjun/p/10328583.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenmingjun/p/10328583.html</guid>
<description>&lt;p id=&quot;tocid_0&quot; class=&quot;toc&quot;&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10328583.html#h1shell&quot;&gt;1 Shell概述&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10328583.html#h2shell&quot;&gt;2 Shell解析器&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10328583.html#h3shell&quot;&gt;3 Shell脚本入门&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10328583.html#h4shell&quot;&gt;4 Shell中的变量&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10328583.html#h41&quot;&gt;4.1 系统变量&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10328583.html#h42&quot;&gt;4.2 自定义变量&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10328583.html#h43dn&quot;&gt;4.3 特殊变量：`$n`&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10328583.html#h44d&quot;&gt;4.4 特殊变量：`$#`&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10328583.html#h45dd&quot;&gt;4.5 特殊变量：`$*、$@`&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10328583.html#h46d&quot;&gt;4.6 特殊变量：`$?`&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10328583.html#h5&quot;&gt;5 运算符&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10328583.html#h6&quot;&gt;6 条件判断&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10328583.html#h7&quot;&gt;7 流程控制（重点）&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10328583.html#h71if&quot;&gt;7.1 if 判断&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10328583.html#h72case&quot;&gt;7.2 case 语句&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10328583.html#h73for&quot;&gt;7.3 for 循环&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10328583.html#h74while&quot;&gt;7.4 while 循环&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10328583.html#h8read&quot;&gt;8 read读取控制台输入&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10328583.html#h9&quot;&gt;9 函数&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10328583.html#h91&quot;&gt;9.1 系统自带函数&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10328583.html#h92&quot;&gt;9.2 自定义函数&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10328583.html#h10shell&quot;&gt;10 Shell工具（重点）&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10328583.html#h101cut&quot;&gt;10.1 cut&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10328583.html#h102sed&quot;&gt;10.2 sed&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10328583.html#h103awk&quot;&gt;10.3 awk&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10328583.html#h104sort&quot;&gt;10.4 sort&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10328583.html#h11&quot;&gt;11 企业真实面试题（重点）&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10328583.html#h111&quot;&gt;11.1 京东&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10328583.html#h112&quot;&gt;11.2 搜狐&amp;amp;和讯网&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10328583.html#h113&quot;&gt;11.3 新浪&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10328583.html#h114&quot;&gt;11.4金和网络&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10328583.html#h115shell&quot;&gt;11.5 数据库备份shell脚本的编写示例&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10328583.html#h12&quot;&gt;12 资料附录&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;h1shell&quot;&gt;&lt;span&gt;&lt;strong&gt;1 Shell概述&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;大数据程序员为什么要学习Shell呢？&lt;br/&gt;  1）需要看懂运维人员编写的Shell程序。&lt;br/&gt;  2）偶尔会编写一些简单Shell程序来管理集群、提高开发效率。&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/28/kKBY4J.png&quot; alt=&quot;&quot;/&gt;&lt;/blockquote&gt;
&lt;h2 id=&quot;h2shell&quot;&gt;&lt;span&gt;&lt;strong&gt;2 Shell解析器&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;（1）Linux提供的Shell解析器有：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;shell language-shell hljs&quot;&gt;[root@hadoop ~]# cat /etc/shells &lt;br/&gt;/bin/sh&lt;br/&gt;/bin/bash&lt;br/&gt;/sbin/nologin&lt;br/&gt;/bin/dash&lt;br/&gt;/bin/tcsh&lt;br/&gt;/bin/csh&lt;br/&gt;[root@hadoop ~]# &lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如下图所示：&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/28/kKBJN4.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;（2）bash和sh的关系
&lt;pre&gt;
&lt;code class=&quot;shell language-shell hljs&quot;&gt;[root@hadoop ~]# cd /bin/&lt;br/&gt;[root@hadoop bin]# pwd&lt;br/&gt;/bin&lt;br/&gt;[root@hadoop bin]# ll | grep bash&lt;br/&gt;-rwxr-xr-x. 1 root root 941880 5月  11 2016 bash&lt;br/&gt;lrwxrwxrwx. 1 root root      4 1月  24 22:21 sh -&amp;gt; bash&lt;br/&gt;[root@hadoop bin]# &lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如下图所示：&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/28/kKBNC9.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;（3）Centos默认的解析器是bash
&lt;pre&gt;
&lt;code class=&quot;shell language-shell hljs&quot;&gt;[root@hadoop bin]# echo $SHELL&lt;br/&gt;/bin/bash&lt;br/&gt;[root@hadoop bin]# &lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如下图所示：&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/28/kKBGEF.png&quot; alt=&quot;&quot;/&gt;&lt;h2 id=&quot;h3shell&quot;&gt;&lt;span&gt;&lt;strong&gt;3 Shell脚本入门&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1、脚本格式&lt;/strong&gt;&lt;br/&gt;脚本以&lt;code&gt;#!/bin/bash&lt;/code&gt;开头（表示指定解析器）&lt;br/&gt;&lt;strong&gt;2、第一个Shell脚本：helloworld&lt;/strong&gt;&lt;br/&gt;（1）需求：创建一个Shell脚本，输出helloworld&lt;br/&gt;（2）案例实操：&lt;/p&gt;
&lt;pre readability=&quot;4&quot;&gt;
&lt;code class=&quot;shell language-shell hljs&quot; readability=&quot;2&quot;&gt;[jack@hadoop datas]$ echo &quot;hello world&quot;&lt;br/&gt;hello world&lt;br/&gt;[jack@hadoop datas]$ touch helloworld.sh&lt;br/&gt;[jack@hadoop datas]$ vim helloworld.sh &lt;br/&gt;[jack@hadoop datas]$ cat helloworld.sh &lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt;!/bin/bash&lt;/span&gt;&lt;p&gt;echo &quot;hello world&quot;&lt;br/&gt;[jack@hadoop datas]$ &lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在helloworld.sh中输入如下内容：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;shell language-shell hljs&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt;!/bin/bash&lt;/span&gt;&lt;p&gt;echo &quot;helloworld&quot;&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（3）脚本的常用执行方式&lt;br/&gt;&lt;strong&gt;第一种&lt;/strong&gt;：采用bash或sh+脚本的相对路径或绝对路径（不用赋予脚本+x权限）&lt;br/&gt;sh+脚本的相对路径&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;shell language-shell hljs&quot;&gt;[jack@hadoop datas]$ sh helloworld.sh &lt;br/&gt;hello world&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;sh+脚本的绝对路径&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;shell language-shell hljs&quot;&gt;[jack@hadoop datas]$ sh /home/jack/datas/helloworld.sh &lt;br/&gt;hello world&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;bash+脚本的相对路径&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;shell language-shell hljs&quot;&gt;[jack@hadoop datas]$ bash helloworld.sh &lt;br/&gt;hello world&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;bash+脚本的绝对路径&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;shell language-shell hljs&quot;&gt;[jack@hadoop datas]$ bash /home/jack/datas/helloworld.sh &lt;br/&gt;hello world&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;第二种&lt;/strong&gt;：采用输入脚本的相对路径或绝对路径执行脚本（脚本必须具有可执行权限+x）&lt;br/&gt;（a）首先要赋予helloworld.sh脚本的+x权限&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;shell language-shell hljs&quot;&gt;[atguigu@hadoop101 datas]$ chmod 777 helloworld.sh&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（b）执行脚本&lt;br/&gt;相对路径&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;shell language-shell hljs&quot;&gt;[jack@hadoop datas]$ ./helloworld.sh &lt;br/&gt;hello world&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;绝对路径&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;shell language-shell hljs&quot;&gt;[jack@hadoop datas]$ /home/jack/datas/helloworld.sh &lt;br/&gt;hello world&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;注意：&lt;/code&gt;第一种执行方法，本质是bash解析器帮你执行脚本，所以脚本本身不需要执行权限。第二种执行方法，本质是脚本需要自己执行，所以需要执行权限。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、第二个Shell脚本：多命令处理&lt;/strong&gt;&lt;br/&gt;（1）需求：在/home/jack/目录下创建一个banzhang.txt，在banzhang.txt文件中增加“I love cls”。&lt;br/&gt;（2）案例实操：&lt;/p&gt;
&lt;pre readability=&quot;4&quot;&gt;
&lt;code class=&quot;shell language-shell hljs&quot; readability=&quot;2&quot;&gt;[jack@hadoop datas]$ touch banzhang.txt&lt;br/&gt;[jack@hadoop datas]$ vim banzhang.txt &lt;br/&gt;[jack@hadoop datas]$ cat banzhang.txt &lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt;!/bin/bash&lt;/span&gt;&lt;p&gt;cd /home/jack&lt;br/&gt;touch banzhang.txt&lt;br/&gt;echo &quot;I love lxy&quot; &amp;gt;&amp;gt; banzhang.txt&lt;br/&gt;[jack@hadoop datas]$&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在batch.sh中输入如下内容&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#!/bin/bash&lt;br/&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;cd&lt;/span&gt; /home/jack&lt;br/&gt;touch banzhang.txt&lt;br/&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;I love lxy&quot;&lt;/span&gt; &amp;gt;&amp;gt; banzhang.txt&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;h4shell&quot;&gt;&lt;span&gt;&lt;strong&gt;4 Shell中的变量&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;h3 id=&quot;h41&quot;&gt;&lt;span&gt;&lt;strong&gt;4.1 系统变量&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1、常用系统变量&lt;/strong&gt;&lt;br/&gt;&lt;code&gt;$HOME、$PWD、$SHELL、$USER&lt;/code&gt;等&lt;br/&gt;&lt;strong&gt;2、案例实操&lt;/strong&gt;&lt;br/&gt;（1）查看系统变量的值&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;shell language-shell hljs&quot;&gt;[jack@hadoop datas]$ echo $HOME&lt;br/&gt;/home/jack&lt;br/&gt;[jack@hadoop datas]$ echo $PWD&lt;br/&gt;/home/jack/datas&lt;br/&gt;[jack@hadoop datas]$ echo $SHELL&lt;br/&gt;/bin/bash&lt;br/&gt;[jack@hadoop datas]$ echo $USER&lt;br/&gt;jack&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（2）显示当前Shell中所有变量：set&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/28/kKB3HU.png&quot; alt=&quot;&quot;/&gt;&lt;h3 id=&quot;h42&quot;&gt;&lt;span&gt;&lt;strong&gt;4.2 自定义变量&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1、基本语法&lt;/strong&gt;&lt;br/&gt;（1）定义变量：变量=值&lt;br/&gt;（2）撤销变量：unset 变量&lt;br/&gt;（3）声明静态变量不赋值：readonly 变量，注意：静态变量不能unset&lt;br/&gt;（4）声明静态变量并赋值：readonly 变量=值，注意：静态变量不能unset，静态变量的值只能初始化一次&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、变量定义规则&lt;/strong&gt;&lt;br/&gt;（1）变量名称可以由字母、数字和下划线组成，但是不能以数字开头，环境变量名建议全部大写。&lt;br/&gt;（2）&lt;code&gt;等号两侧不能有空格&lt;/code&gt;。&lt;br/&gt;（3）在bash中，变量默认类型都是字符串类型，无法直接进行数值运算。&lt;br/&gt;（4）变量的值如果有空格，需要使用双引号或单引号括起来。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、案例实操&lt;/strong&gt;&lt;br/&gt;  （1）定义变量A&lt;br/&gt;  （2）给变量A重新赋值&lt;br/&gt;  （3）撤销变量A&lt;br/&gt;  （4）声明静态的变量C=4，不能unset&lt;br/&gt;  （5）在bash中，变量默认类型都是字符串类型，无法直接进行数值运算&lt;br/&gt;  （6）变量的值如果有空格，需要使用双引号或单引号括起来&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/28/kKBU3R.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;  （7）可把变量提升为全局环境变量，可供其他Shell程序使用&lt;br/&gt;    export 变量名&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/28/kKBag1.png&quot; alt=&quot;&quot;/&gt;&lt;h3 id=&quot;h43dn&quot;&gt;&lt;span&gt;&lt;strong&gt;4.3 特殊变量：`$n`&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1、基本语法&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;code&gt;$n&lt;/code&gt;（功能描述：n为数字，&lt;code&gt;$0&lt;/code&gt;代表该脚本名称，&lt;code&gt;$1-$9&lt;/code&gt;代表第一到第九个参数，十以上的参数需要用大括号包含，如&lt;code&gt;${10}&lt;/code&gt;）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;2、案例实操&lt;/strong&gt;&lt;br/&gt;（1）输出该脚本文件名称、输入参数1、输入参数2和输入参数3的值&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/28/kKBBDK.png&quot; alt=&quot;&quot;/&gt;&lt;h3 id=&quot;h44d&quot;&gt;&lt;span&gt;&lt;strong&gt;4.4 特殊变量：`$#`&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1、基本语法&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code&gt;$#&lt;/code&gt; （功能描述：获取所有输入参数的个数，常用于循环）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;2、案例实操&lt;/strong&gt;&lt;br/&gt;（1）获取输入参数的个数&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/28/kKBdjx.png&quot; alt=&quot;&quot;/&gt;&lt;h3 id=&quot;h45dd&quot;&gt;&lt;span&gt;&lt;strong&gt;4.5 特殊变量：`$*、$@`&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1、基本语法&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;code&gt;$*&lt;/code&gt; （功能描述：这个变量代表命令行中所有的参数，&lt;code&gt;$*&lt;/code&gt;把所有的参数看成一个整体）&lt;br/&gt;&lt;code&gt;$@&lt;/code&gt; （功能描述：这个变量也代表命令行中所有的参数，不过&lt;code&gt;$@&lt;/code&gt;把每个参数区分对待）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;2、案例实操&lt;/strong&gt;&lt;br/&gt;（1）打印输入的所有参数&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/28/kKB0u6.png&quot; alt=&quot;&quot;/&gt;&lt;h3 id=&quot;h46d&quot;&gt;&lt;span&gt;&lt;strong&gt;4.6 特殊变量：`$?`&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1、基本语法&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;code&gt;$?&lt;/code&gt; （功能描述：最后一次执行的命令的返回状态。如果这个变量的值为0，证明上一个命令正确执行；如果这个变量的值为非0（具体是哪个数，由命令自己来决定），则证明上一个命令执行不正确了）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;2、案例实操&lt;/strong&gt;&lt;br/&gt;（1）判断helloworld.sh脚本是否正确执行&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/28/kKBgCd.png&quot; alt=&quot;&quot;/&gt;&lt;h2 id=&quot;h5&quot;&gt;&lt;span&gt;&lt;strong&gt;5 运算符&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1、基本语法&lt;/strong&gt;&lt;br/&gt;  （1）&lt;code&gt;$((运算式))&lt;/code&gt;或&lt;code&gt;$[运算式]&lt;/code&gt;&lt;br/&gt;  （2）&lt;code&gt;expr + , - , \*, /, %&lt;/code&gt; 加，减，乘，除，取余&lt;br/&gt;  &lt;strong&gt;注意：&lt;/strong&gt;&lt;code&gt;expr运算符间要有空格。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、案例实操&lt;/strong&gt;&lt;br/&gt;  （1）计算3+2的值&lt;br/&gt;  （2）计算3-2的值&lt;br/&gt;  （3）计算(2+3) x 4的值&lt;br/&gt;  （a）expr一步完成计算&lt;br/&gt;  （b）采用&lt;code&gt;$[运算式]&lt;/code&gt;方式&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/28/kKBsED.png&quot; alt=&quot;&quot;/&gt;&lt;h2 id=&quot;h6&quot;&gt;&lt;span&gt;&lt;strong&gt;6 条件判断&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1、基本语法&lt;/strong&gt;&lt;br/&gt;&lt;code&gt;[ condition ]&lt;/code&gt; （注意：condition前后要有空格）&lt;br/&gt;  &lt;strong&gt;注意：&lt;/strong&gt;条件非空即为true，[ hodoop ]返回true，[] 返回false。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、常用判断条件&lt;/strong&gt;&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/28/kKByUe.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;&lt;strong&gt;3、案例实操&lt;/strong&gt;&lt;br/&gt;  （1）23是否大于等于22&lt;br/&gt;  （2）helloworld.sh是否具有写权限&lt;br/&gt;  （3）/home/jack/cls.txt 目录中的文件是否存在&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/28/kKBDHO.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;  （4）多条件判断（&amp;amp;&amp;amp; 表示前一条命令执行成功时，才执行后一条命令，|| 表示上一条命令执行失败后，才执行下一条命令）&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/28/kKB64H.png&quot; alt=&quot;&quot;/&gt;&lt;h2 id=&quot;h7&quot;&gt;&lt;span&gt;&lt;strong&gt;7 流程控制（重点）&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;h3 id=&quot;h71if&quot;&gt;&lt;span&gt;&lt;strong&gt;7.1 if 判断&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1、基本语法&lt;/strong&gt;&lt;/p&gt;
&lt;pre readability=&quot;4&quot;&gt;
&lt;code class=&quot;shell language-shell hljs&quot; readability=&quot;2&quot;&gt;if [ 条件判断式 ];then &lt;br/&gt;程序 &lt;br/&gt;fi &lt;p&gt;或者&lt;/p&gt;&lt;p&gt;if [ 条件判断式 ] &lt;br/&gt;then &lt;br/&gt;程序 &lt;br/&gt;fi&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意事项：&lt;/strong&gt;&lt;br/&gt;  （1）[ 条件判断式 ]，中括号和条件判断式之间必须有空格。&lt;br/&gt;  （2）if后要有空格。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、案例实操&lt;/strong&gt;&lt;br/&gt;  （1）输入一个数字，如果是1，则输出banzhang zhen shuai，如果是2，则输出lxy zhen mei，如果是其它，什么也不输出。&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/28/kKB28A.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;if.sh
&lt;pre readability=&quot;4&quot;&gt;
&lt;code class=&quot;shell language-shell hljs&quot; readability=&quot;2&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt;!/bin/bash&lt;/span&gt;&lt;p&gt;if [ $1 -eq &quot;1&quot; ]&lt;br/&gt;then&lt;br/&gt;echo &quot;banzhang zhen shuai&quot;&lt;br/&gt;elif [ $1 -eq &quot;2&quot; ]&lt;br/&gt;then&lt;br/&gt;echo &quot;lxy zhen mei&quot;&lt;br/&gt;fi&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;h72case&quot;&gt;&lt;span&gt;&lt;strong&gt;7.2 case 语句&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1、基本语法&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;shell language-shell hljs&quot;&gt;case $变量名 in &lt;br/&gt;&quot;值1&quot;)&lt;br/&gt;如果变量的值等于值1，则执行程序1 &lt;br/&gt;;;&lt;br/&gt;&quot;值2&quot;)&lt;br/&gt;如果变量的值等于值2，则执行程序2 &lt;br/&gt;;;&lt;br/&gt;...省略其他分支...&lt;br/&gt;*)&lt;br/&gt;如果变量的值都不是以上的值，则执行此程序 &lt;br/&gt;;; &lt;br/&gt;esac&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意事项：&lt;/strong&gt;&lt;br/&gt;  1) case行尾必须为单词“in”，每一个模式匹配必须以右括号&lt;code&gt;)&lt;/code&gt;结束。&lt;br/&gt;  2) 双分号&lt;code&gt;;;&lt;/code&gt;表示命令序列结束，相当于java中的break。&lt;br/&gt;  3) 最后的&lt;code&gt;*)&lt;/code&gt;表示默认模式，相当于java中的default。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、案例实操&lt;/strong&gt;&lt;br/&gt;（1）输入一个数字，如果是1，则输出banzhang，如果是2，则输出lyx，如果是其它，输出renyao。&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/28/kKDkx1.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;case.sh
&lt;pre readability=&quot;4&quot;&gt;
&lt;code class=&quot;shell language-shell hljs&quot; readability=&quot;2&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt;!/bin/bash&lt;/span&gt;&lt;p&gt;case $1 in&lt;br/&gt;&quot;1&quot;)&lt;br/&gt;echo &quot;banzhang&quot;&lt;br/&gt;;;&lt;br/&gt;&quot;2&quot;)&lt;br/&gt;echo &quot;lxy&quot;&lt;br/&gt;;;&lt;br/&gt;*)&lt;br/&gt;echo &quot;renyao&quot;&lt;br/&gt;;;&lt;br/&gt;esac&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;h73for&quot;&gt;&lt;span&gt;&lt;strong&gt;7.3 for 循环&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1、基本语法1&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;shell language-shell hljs&quot;&gt;for ((初始值;循环控制条件;变量变化)) &lt;br/&gt;do &lt;br/&gt;程序 &lt;br/&gt;done&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2、案例实操&lt;/strong&gt;&lt;br/&gt;（1）从1加到100&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/28/kKB5b8.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;for1.sh
&lt;pre readability=&quot;4&quot;&gt;
&lt;code class=&quot;shell language-shell hljs&quot; readability=&quot;2&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt;!/bin/bash&lt;/span&gt;&lt;p&gt;s=0&lt;br/&gt;for((i=0;i&amp;lt;=100;i++))&lt;br/&gt;do&lt;br/&gt;s=$[$s+$i]&lt;br/&gt;done&lt;br/&gt;echo $s&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;3、基本语法2&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;shell language-shell hljs&quot;&gt;for 变量 in 值1 值2 值3 ...&lt;br/&gt;do &lt;br/&gt;程序 &lt;br/&gt;done&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;4、案例实操&lt;/strong&gt;&lt;br/&gt;（1）打印所有的输入参数&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/28/kKBhKP.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;for2.sh
&lt;pre readability=&quot;4&quot;&gt;
&lt;code class=&quot;shell language-shell hljs&quot; readability=&quot;2&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt;!/bin/bash&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt;打印数字&lt;/span&gt;&lt;p&gt;for i in $*&lt;br/&gt;do&lt;br/&gt;echo &quot;banzhang love $i&quot;&lt;br/&gt;done&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（2）比较&lt;code&gt;$*&lt;/code&gt;和&lt;code&gt;$@&lt;/code&gt;区别&lt;br/&gt;（a）&lt;code&gt;$*&lt;/code&gt;和&lt;code&gt;$@&lt;/code&gt;都表示传递给函数或脚本的所有参数，不被双引号“”包含时，都以&lt;code&gt;$1 $2 ... $n&lt;/code&gt;的形式输出所有参数。&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/28/kKBRgI.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;for3.sh
&lt;pre readability=&quot;5&quot;&gt;
&lt;code class=&quot;shell language-shell hljs&quot; readability=&quot;4&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt;!/bin/bash &lt;/span&gt;&lt;p&gt;for i in $*&lt;br/&gt;do&lt;br/&gt;echo &quot;banzhang love $i&quot;&lt;br/&gt;done&lt;/p&gt;&lt;p&gt;for j in $@&lt;br/&gt;do      &lt;br/&gt;echo &quot;banzhang love $j&quot;&lt;br/&gt;done&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（b）当它们被双引号“”包含时，&lt;code&gt;$*&lt;/code&gt;会将所有的参数作为一个整体，以&lt;code&gt;$1 $2 ... $n&lt;/code&gt;的形式输出所有参数；&lt;code&gt;$@&lt;/code&gt;会将各个参数分开，以&lt;code&gt;“$1” “$2”…”$n”&lt;/code&gt;的形式输出所有参数。&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/28/kKBWvt.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;for4.sh
&lt;pre readability=&quot;6&quot;&gt;
&lt;code class=&quot;shell language-shell hljs&quot; readability=&quot;6&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt;!/bin/bash &lt;/span&gt;&lt;p&gt;for i in &quot;$*&quot; &lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt;$*中的所有参数看成是一个整体，所以这个&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;循环只会循环一次 &lt;/span&gt;&lt;br/&gt;do &lt;br/&gt;echo &quot;banzhang love $i&quot;&lt;br/&gt;done &lt;/p&gt;&lt;p&gt;for j in &quot;$@&quot; &lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt;&lt;span class=&quot;hljs-variable&quot;&gt;$@&lt;/span&gt;中的每个参数都看成是独立的，所以“&lt;span class=&quot;hljs-variable&quot;&gt;$@&lt;/span&gt;”中有几个参数，就会循环几次 &lt;/span&gt;&lt;br/&gt;do &lt;br/&gt;echo &quot;banzhang love $j&quot; &lt;br/&gt;done&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;h74while&quot;&gt;&lt;span&gt;&lt;strong&gt;7.4 while 循环&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1、基本语法&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;shell language-shell hljs&quot;&gt;while [ 条件判断式 ] &lt;br/&gt;do &lt;br/&gt;程序&lt;br/&gt;done&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2、案例实操&lt;/strong&gt;&lt;br/&gt;（1）从1加到100&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/28/kKB4Df.png&quot; alt=&quot;&quot;/&gt;&lt;pre readability=&quot;4&quot;&gt;
&lt;code class=&quot;shell language-shell hljs&quot; readability=&quot;2&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt;!/bin/bash&lt;/span&gt;&lt;p&gt;s=0&lt;br/&gt;i=1&lt;br/&gt;while [ $i -le 100 ]&lt;br/&gt;do&lt;br/&gt;s=$[$s+$i]&lt;br/&gt;i=$[$i+1]&lt;br/&gt;done&lt;br/&gt;echo $s&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;h8read&quot;&gt;&lt;span&gt;&lt;strong&gt;8 read读取控制台输入&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1、基本语法&lt;/strong&gt;&lt;br/&gt;read 选项 参数&lt;br/&gt;选项：&lt;br/&gt;  -p：指定读取值时的提示符。&lt;br/&gt;  -t：指定读取值时等待的时间（秒）。&lt;br/&gt;参数：&lt;br/&gt;  变量：指定读取值的变量名。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、案例实操&lt;/strong&gt;&lt;br/&gt;（1）提示7秒内，读取控制台输入的名称。&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/28/kKBoVS.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;read.sh
&lt;pre readability=&quot;4&quot;&gt;
&lt;code class=&quot;shell language-shell hljs&quot; readability=&quot;2&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt;!/bin/bash&lt;/span&gt;&lt;p&gt;read -t 7 -p &quot;input your name in 7 seconds &quot; NAME&lt;br/&gt;echo $NAME&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;h9&quot;&gt;&lt;span&gt;&lt;strong&gt;9 函数&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;h3 id=&quot;h91&quot;&gt;&lt;span&gt;&lt;strong&gt;9.1 系统自带函数&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1、basename基本语法&lt;/strong&gt;&lt;br/&gt;basename [string / pathname] [suffix] （功能描述：basename命令会删掉所有的前缀包括最后一个（‘/’）字符，然后将字符串显示出来。&lt;br/&gt;选项：&lt;br/&gt;  suffix为后缀，如果suffix被指定了，basename会将pathname或string中的suffix去掉。&lt;br/&gt;&lt;strong&gt;2、案例实操&lt;/strong&gt;&lt;br/&gt;（1）截取该/home/jack/banzhang.txt路径的文件名称&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/28/kKBTUg.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;示例：
&lt;pre&gt;
&lt;code class=&quot;shell language-shell hljs&quot;&gt;[jack@hadoop datas]$ basename /home/jack/banzhang.txt &lt;br/&gt;banzhang.txt&lt;br/&gt;[jack@hadoop datas]$ basename /home/jack/banzhang.txt .txt&lt;br/&gt;banzhang&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;3、dirname基本语法&lt;/strong&gt;&lt;br/&gt;dirname 文件绝对路径 （功能描述：从给定的包含绝对路径的文件名中去除文件名（非目录的部分），然后返回剩下的路径（目录的部分））&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4、案例实操&lt;/strong&gt;&lt;br/&gt;（1）获取banzhang.txt文件的路径&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/28/kKBxbT.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;示例：
&lt;pre&gt;
&lt;code class=&quot;shell language-shell hljs&quot;&gt;[jack@hadoop datas]$ dirname /home/jack/banzhang.txt &lt;br/&gt;/home/jack&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;h92&quot;&gt;&lt;span&gt;&lt;strong&gt;9.2 自定义函数&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1、基本语法&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;shell language-shell hljs&quot;&gt;[ function ] funname[()]&lt;br/&gt;{&lt;br/&gt;Action;&lt;br/&gt;[return int;]&lt;br/&gt;}&lt;br/&gt;funname&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2、经验技巧&lt;/strong&gt;&lt;br/&gt;（1）必须在调用函数地方之前，先声明函数，shell脚本是逐行运行。不会像其它语言那样先编译。&lt;br/&gt;（2）函数返回值，只能通过&lt;code&gt;$?&lt;/code&gt;系统变量获得，可以显示加：return返回，如果不加，将以最后一条命令运行结果，作为返回值。return后跟数值n(0-255)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、案例实操&lt;/strong&gt;&lt;br/&gt;（1）计算两个输入参数的和&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/28/kKB75Q.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;fun.sh
&lt;pre readability=&quot;5&quot;&gt;
&lt;code class=&quot;shell language-shell hljs&quot; readability=&quot;4&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt;!/bin/bash&lt;/span&gt;&lt;p&gt;function sum()&lt;br/&gt;{&lt;br/&gt;s=0&lt;br/&gt;s=$[ $1 + $2 ]&lt;br/&gt;echo &quot;$s&quot;&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;read -p &quot;Please input the number1: &quot; n1;&lt;br/&gt;read -p &quot;Please input the number2: &quot; n2;&lt;br/&gt;sum $n1 $n2;&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;h10shell&quot;&gt;&lt;span&gt;&lt;strong&gt;10 Shell工具（重点）&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;h3 id=&quot;h101cut&quot;&gt;&lt;span&gt;&lt;strong&gt;10.1 cut&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;cut的工作就是“剪”，具体的说就是&lt;code&gt;在文件中负责剪切数据用的&lt;/code&gt;。cut 命令从文件的每一行剪切字节、字符和字段并将这些字节、字符和字段输出。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;1、基本用法&lt;/strong&gt;&lt;br/&gt;cut [选项参数] filename&lt;br/&gt;&lt;strong&gt;说明：&lt;/strong&gt;默认分隔符是&lt;code&gt;制表符\t&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、选项参数说明&lt;/strong&gt;&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/28/kKBbCj.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;&lt;strong&gt;3、案例实操&lt;/strong&gt;&lt;br/&gt;（0）数据准备&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;shell language-shell hljs&quot;&gt;[jack@hadoop datas]$ touch cut.txt&lt;br/&gt;[jack@hadoop datas]$ vim cut.txt &lt;br/&gt;[jack@hadoop datas]$ cat cut.txt &lt;br/&gt;dong shen&lt;br/&gt;guan zhen&lt;br/&gt;wo  wo&lt;br/&gt;lai  lai&lt;br/&gt;le  le&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（1）切割cut.txt第一列（提示：用空格作为分隔符）&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;shell language-shell hljs&quot;&gt;[jack@hadoop datas]$ cut -f 1 -d &quot; &quot; cut.txt &lt;br/&gt;dong&lt;br/&gt;guan&lt;br/&gt;wo&lt;br/&gt;lai&lt;br/&gt;le&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（2）切割cut.txt第二、三列&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;shell language-shell hljs&quot;&gt;[jack@hadoop datas]$ cut -f 2,3 -d &quot; &quot; cut.txt&lt;br/&gt;shen&lt;br/&gt;zhen&lt;br/&gt;wo&lt;br/&gt;lai&lt;br/&gt;le&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;原理图解：&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/28/kKBq8s.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;（3）在cut.txt文件中切割出guan
&lt;pre&gt;
&lt;code class=&quot;shell language-shell hljs&quot;&gt;[jack@hadoop datas]$ cat cut.txt &lt;br/&gt;dong shen&lt;br/&gt;guan zhen&lt;br/&gt;wo  wo&lt;br/&gt;lai  lai&lt;br/&gt;le  le&lt;br/&gt;[jack@hadoop datas]$ cat cut.txt | grep guan&lt;br/&gt;guan zhen&lt;br/&gt;[jack@hadoop datas]$ cat cut.txt | grep guan | cut -f 1 -d &quot; &quot;&lt;br/&gt;guan&lt;br/&gt;[jack@hadoop datas]$ &lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;图解如下：&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/28/kKBL2n.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;（4）选取系统PATH变量值，第2个“：”开始后的所有路径
&lt;pre&gt;
&lt;code class=&quot;shell language-shell hljs&quot;&gt;[jack@hadoop datas]$ echo $PATH&lt;br/&gt;/usr/lib64/qt-3.3/bin:/usr/local/bin:/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/sbin:/home/jack/bin&lt;br/&gt;[jack@hadoop datas]$ echo $PATH | cut -d : -f 3-&lt;br/&gt;/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/sbin:/home/jack/bin&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;图解如下：&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/28/kKBjK0.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;（5）切割ifconfig后打印的IPV4的地址
&lt;pre readability=&quot;5.5&quot;&gt;
&lt;code class=&quot;shell language-shell hljs&quot; readability=&quot;5&quot;&gt;[jack@hadoop datas]$ ifconfig eth1&lt;br/&gt;eth1      Link encap:Ethernet  HWaddr 00:0C:29:F0:1C:55  &lt;br/&gt;inet addr:192.168.25.204  Bcast:192.168.25.255  Mask:255.255.255.0&lt;br/&gt;inet6 addr: fe80::20c:29ff:fef0:1c55/64 Scope:Link&lt;br/&gt;UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1&lt;br/&gt;RX packets:8845 errors:0 dropped:0 overruns:0 frame:0&lt;br/&gt;TX packets:5687 errors:0 dropped:0 overruns:0 carrier:0&lt;br/&gt;collisions:0 txqueuelen:1000 &lt;br/&gt;RX bytes:805027 (786.1 KiB)  TX bytes:826298 (806.9 KiB)&lt;p&gt;[jack@hadoop datas]$ ifconfig eth1 | grep &quot;inet addr&quot;&lt;br/&gt;inet addr:192.168.25.204  Bcast:192.168.25.255  Mask:255.255.255.0&lt;br/&gt;[jack@hadoop datas]$ ifconfig eth1 | grep &quot;inet addr&quot; | cut -d : -f 2&lt;br/&gt;192.168.25.204  Bcast&lt;br/&gt;[jack@hadoop datas]$ ifconfig eth1 | grep &quot;inet addr&quot; | cut -d : -f 2 | cut -d &quot; &quot; -f 1&lt;br/&gt;192.168.25.204&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;图解如下：&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/28/kKBOvq.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;容易蒙圈的地方：&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/28/kKBvrV.png&quot; alt=&quot;&quot;/&gt;&lt;h3 id=&quot;h102sed&quot;&gt;&lt;span&gt;&lt;strong&gt;10.2 sed&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;sed是一种&lt;code&gt;流编辑器&lt;/code&gt;，它一次处理一行内容。处理时，把当前处理的行存储在临时缓冲区中，称为“模式空间”，接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行，这样不断重复，直到文件末尾。&lt;code&gt;文件内容并没有改变&lt;/code&gt;，除非你使用重定向存储输出。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;1、基本用法&lt;/strong&gt;&lt;br/&gt;sed [选项参数] 'command' filename&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、选项参数说明&lt;/strong&gt;&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/28/kKDSVU.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;&lt;strong&gt;3、命令功能描述&lt;/strong&gt;&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/28/kKDF2R.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;&lt;strong&gt;4、案例实操&lt;/strong&gt;&lt;br/&gt;（0）数据准备&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;shell language-shell hljs&quot;&gt;[jack@hadoop datas]$ touch sed.txt&lt;br/&gt;[jack@hadoop datas]$ vim sed.txt &lt;br/&gt;[jack@hadoop datas]$ cat sed.txt &lt;br/&gt;dong shen&lt;br/&gt;guan zhen&lt;br/&gt;wo  wo&lt;br/&gt;lai  lai&lt;p&gt;le  le&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（1）将“mei nv”这个单词插入到sed.txt第二行下，打印。&lt;/p&gt;
&lt;pre readability=&quot;4&quot;&gt;
&lt;code class=&quot;shell language-shell hljs&quot; readability=&quot;2&quot;&gt;[jack@hadoop datas]$ sed &quot;2a mei nv&quot; sed.txt&lt;br/&gt;dong shen&lt;br/&gt;guan zhen&lt;br/&gt;mei nv&lt;br/&gt;wo  wo&lt;br/&gt;lai  lai&lt;p&gt;le  le&lt;br/&gt;[jack@hadoop datas]$ cat sed.txt &lt;br/&gt;dong shen&lt;br/&gt;guan zhen&lt;br/&gt;wo  wo&lt;br/&gt;lai  lai&lt;/p&gt;&lt;p&gt;le  le&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;文件并没有改变。&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/28/kKDpaF.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;（2）删除sed.txt文件所有包含wo的行&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;shell language-shell hljs&quot;&gt;[jack@hadoop datas]$ sed &quot;/wo/d&quot; sed.txt &lt;br/&gt;dong shen&lt;br/&gt;guan zhen&lt;br/&gt;lai  lai&lt;p&gt;le  le&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（3）将sed.txt文件中wo替换为ni&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;shell language-shell hljs&quot;&gt;[jack@hadoop datas]$ sed &quot;s/wo/ni/g&quot; sed.txt &lt;br/&gt;dong shen&lt;br/&gt;guan zhen&lt;br/&gt;ni  ni&lt;br/&gt;lai  lai&lt;p&gt;le  le&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;‘g’表示global，全部替换。&lt;br/&gt;（4）将sed.txt文件中的第二行删除并将wo替换为ni&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;shell language-shell hljs&quot;&gt;[jack@hadoop datas]$ sed -e &quot;2d&quot; -e &quot;s/wo/ni/g&quot; sed.txt &lt;br/&gt;dong shen&lt;br/&gt;ni  ni&lt;br/&gt;lai  lai&lt;p&gt;le  le&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;h103awk&quot;&gt;&lt;span&gt;&lt;strong&gt;10.3 awk&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;一个强大的文本分析工具，把文件逐行的读入，以空格为默认分隔符将每行切片，切开的部分再进行分析处理。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;1、基本用法&lt;/strong&gt;&lt;br/&gt;awk [选项参数] 'pattern1 {action1} pattern2 {action2} …' filename&lt;br/&gt;  pattern：表示AWK在数据中查找的内容，就是匹配模式（正则匹配）。&lt;br/&gt;  action：在找到匹配内容时所执行的一系列命令。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、选项参数说明&lt;/strong&gt;&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/28/kKDiG9.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;&lt;strong&gt;3、案例实操&lt;/strong&gt;&lt;br/&gt;（0）数据准备&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;shell language-shell hljs&quot;&gt;[jack@hadoop datas]$ pwd&lt;br/&gt;/home/jack/datas&lt;br/&gt;[jack@hadoop datas]$ sudo cp /etc/passwd ./&lt;br/&gt;[sudo] password for jack: &lt;br/&gt;[jack@hadoop datas]$ &lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;出现问题：&lt;/strong&gt;&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/28/kKD954.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;用户名 不在 sudoers文件中。此事将被报告。&lt;br/&gt;sudo命令可以让你以root身份执行命令，来完成一些我们这个帐号完成不了的任务。&lt;br/&gt;其实并非所有用户都能够执行sudo，因为有权限的用户都在/etc/sudoers中呢。&lt;br/&gt;我们可以通过编辑器来打开&lt;code&gt;vim /etc/sudoers&lt;/code&gt;，sudoers的权限是0440，即只有root才能读。在你用root或sudo编辑后强行保存并退出（wq!）即可。&lt;br/&gt;打开sudoers后，像如下那样加上自己的帐号保存后就可以了。&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/28/kKDPPJ.png&quot; alt=&quot;&quot;/&gt;&lt;/blockquote&gt;
&lt;p&gt;（1）搜索passwd文件以root关键字开头的所有行，并输出该行的第7列。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;shell language-shell hljs&quot;&gt;[jack@hadoop datas]$ awk -F : '/^root/ {print $7}' passwd &lt;br/&gt;/bin/bash&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（2）搜索passwd文件以root关键字开头的所有行，并输出该行的第1列和第7列，中间以“，”号分割。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;shell language-shell hljs&quot;&gt;[jack@hadoop datas]$ awk -F : '/^root/ {print $1&quot;,&quot;$7}' passwd &lt;br/&gt;root,/bin/bash&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：只有匹配了pattern的行才会执行action。&lt;br/&gt;（3）只显示/etc/passwd的第一列和第七列，以逗号分割，且在所有行前面添加列名user,shell，在最后一行添加&quot;lxy,/bin/zuimei&quot;。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;shell language-shell hljs&quot;&gt;[jack@hadoop datas]$ awk -F : 'BEGIN {print &quot;user,shell&quot;} {print $1&quot;,&quot;$7} END {print &quot;lxy,/bin/zuimei&quot;}' passwd&lt;br/&gt;user,shell&lt;br/&gt;root,/bin/bash&lt;br/&gt;bin,/sbin/nologin&lt;br/&gt;......&lt;br/&gt;xh,/bin/bash&lt;br/&gt;xq,/bin/bash&lt;br/&gt;lxy,/bin/zuimei&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：BEGIN 在所有数据读取行之前执行；END 在所有数据执行之后执行。&lt;br/&gt;（4）将passwd文件中的用户id增加数值1并输出&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;shell language-shell hljs&quot;&gt;[jack@hadoop datas]$ awk -F : -v i=1 '{print $3+i}' passwd &lt;br/&gt;1&lt;br/&gt;2&lt;br/&gt;3&lt;br/&gt;......&lt;br/&gt;503&lt;br/&gt;504&lt;br/&gt;505&lt;br/&gt;[jack@hadoop datas]$ &lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;4、awk的内置变量&lt;/strong&gt;&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/28/kKDVr6.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;&lt;strong&gt;5、案例实操&lt;/strong&gt;&lt;br/&gt;（1）统计passwd文件名，每行的行号，每行的列数&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;shell language-shell hljs&quot;&gt;[jack@hadoop datas]$ awk -F : '{print &quot;filename:&quot; FILENAME &quot;, linenumber:&quot; NR &quot;, columns:&quot; NF}' passwd &lt;br/&gt;filename:passwd, linenumber:1, columns:7&lt;br/&gt;filename:passwd, linenumber:2, columns:7&lt;br/&gt;filename:passwd, linenumber:3, columns:7&lt;br/&gt;......&lt;br/&gt;filename:passwd, linenumber:33, columns:7&lt;br/&gt;filename:passwd, linenumber:34, columns:7&lt;br/&gt;filename:passwd, linenumber:35, columns:7&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（2）切割IP&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;shell language-shell hljs&quot;&gt;[jack@hadoop datas]$ ifconfig eth1 | grep &quot;inet addr&quot;&lt;br/&gt;inet addr:192.168.25.204  Bcast:192.168.25.255  Mask:255.255.255.0&lt;br/&gt;[jack@hadoop datas]$ ifconfig eth1 | grep &quot;inet addr&quot; | awk -F : '{print $2}'&lt;br/&gt;192.168.25.204  Bcast&lt;br/&gt;[jack@hadoop datas]$ ifconfig eth1 | grep &quot;inet addr&quot; | awk -F : '{print $2}' | awk -F &quot; &quot; '{print $1}'&lt;br/&gt;192.168.25.204&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（3）查询sed.txt中空行所在的行号&lt;/p&gt;
&lt;pre readability=&quot;4&quot;&gt;
&lt;code class=&quot;shell language-shell hljs&quot; readability=&quot;2&quot;&gt;[jack@hadoop datas]$ cat sed.txt &lt;br/&gt;dong shen&lt;br/&gt;guan zhen&lt;br/&gt;wo  wo&lt;br/&gt;lai  lai&lt;p&gt;le  le&lt;br/&gt;[jack@hadoop datas]$ awk '/^$/ {print NR}' sed.txt &lt;br/&gt;5&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;h104sort&quot;&gt;&lt;span&gt;&lt;strong&gt;10.4 sort&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;sort命令是在Linux里非常有用，它将文件进行排序，并将排序结果标准输出。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;1、基本语法&lt;/strong&gt;&lt;br/&gt;sort 选项 参数&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/28/kKDEKx.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;参数：指定待排序的文件列表。
&lt;p&gt;&lt;strong&gt;2、案例实操&lt;/strong&gt;&lt;br/&gt;（0）数据准备&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;shell language-shell hljs&quot;&gt;[jack@hadoop datas]$ touch sort.sh&lt;br/&gt;[jack@hadoop datas]$ vim sort.sh &lt;br/&gt;[jack@hadoop datas]$ cat sort.sh &lt;br/&gt;bb:40:5.4&lt;br/&gt;bd:20:4.2&lt;br/&gt;xz:50:2.3&lt;br/&gt;cls:10:3.5&lt;br/&gt;ss:30:1.6&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（1）按照“:”分割后的第二列倒序排序。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;shell language-shell hljs&quot;&gt;[jack@hadoop datas]$ cat sort.sh &lt;br/&gt;bb:40:5.4&lt;br/&gt;bd:20:4.2&lt;br/&gt;xz:50:2.3&lt;br/&gt;cls:10:3.5&lt;br/&gt;ss:30:1.6&lt;br/&gt;[jack@hadoop datas]$ sort -t : -nrk 2 sort.sh &lt;br/&gt;xz:50:2.3&lt;br/&gt;bb:40:5.4&lt;br/&gt;ss:30:1.6&lt;br/&gt;bd:20:4.2&lt;br/&gt;cls:10:3.5&lt;br/&gt;[jack@hadoop datas]$ &lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;h11&quot;&gt;&lt;span&gt;&lt;strong&gt;11 企业真实面试题（重点）&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;h3 id=&quot;h111&quot;&gt;&lt;span&gt;&lt;strong&gt;11.1 京东&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;问题1：使用Linux命令查询文件file1中空行所在的行号。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;shell language-shell hljs&quot;&gt;[jack@hadoop datas]$ awk '/^$/ {print NR}' file1&lt;br/&gt;5&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;数据清洗（ETL）：干掉 空行、null、404、500。&lt;/p&gt;
&lt;p&gt;问题2：有文件chengji.txt内容如下:&lt;br/&gt;张三 40&lt;br/&gt;李四 50&lt;br/&gt;王五 60&lt;br/&gt;使用Linux命令计算第二列的和并输出。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;shell language-shell hljs&quot;&gt;[jack@hadoop datas]$ cat chengji.txt | awk -F &quot; &quot; '{sum+=$2} END {print sum}'&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;h112&quot;&gt;&lt;span&gt;&lt;strong&gt;11.2 搜狐&amp;amp;和讯网&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;问题1：Shell脚本里如何检查一个文件是否存在？如果不存在该如何处理？&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;shell language-shell hljs&quot;&gt;if [ -e file.txt ]&lt;br/&gt;then&lt;br/&gt;echo &quot;文件存在！&quot;&lt;br/&gt;else&lt;br/&gt;echo &quot;文件不存在！&quot;&lt;br/&gt;fi&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;h113&quot;&gt;&lt;span&gt;&lt;strong&gt;11.3 新浪&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;问题1：用shell写一个脚本，对文本中无序的一列数字排序。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;shell language-shell hljs&quot;&gt;[root@CentOS6-2 ~]# cat test.txt&lt;br/&gt;9&lt;br/&gt;8&lt;br/&gt;7&lt;br/&gt;6&lt;br/&gt;5&lt;br/&gt;4&lt;br/&gt;3&lt;br/&gt;2&lt;br/&gt;10&lt;br/&gt;1&lt;br/&gt;[root@CentOS6-2 ~]# sort -n test.txt | awk '{a+=$0;print $0} END {print &quot;SUM=&quot; a}'&lt;br/&gt;1&lt;br/&gt;2&lt;br/&gt;3&lt;br/&gt;4&lt;br/&gt;5&lt;br/&gt;6&lt;br/&gt;7&lt;br/&gt;8&lt;br/&gt;9&lt;br/&gt;10&lt;br/&gt;SUM=55&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;h114&quot;&gt;&lt;span&gt;&lt;strong&gt;11.4金和网络&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;问题1：请用shell脚本写出查找当前文件夹（/home/）下所有的文本文件内容中包含有字符”shen”的文件名称。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;shell language-shell hljs&quot;&gt;[jack@hadoop datas]$ grep -r &quot;shen&quot; /home/&lt;br/&gt;/home/jack/datas/sed.txt:dong shen&lt;br/&gt;/home/jack/datas/cut.txt:dong shen&lt;br/&gt;[jack@hadoop datas]$ grep -r &quot;shen&quot; /home/ | cut -d &quot;:&quot; -f 1&lt;br/&gt;/home/jack/datas/sed.txt&lt;br/&gt;/home/jack/datas/cut.txt&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; grep -R/-r /home/ 以递归方式读取/home/目录下的所有文件&lt;/p&gt;
&lt;h3 id=&quot;h115shell&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;11.5 数据库备份shell脚本的编写示例&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/28/kKDIQ1.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;shell脚本文件内容：&lt;/p&gt;
&lt;pre readability=&quot;9&quot;&gt;
&lt;code class=&quot;shell language-shell hljs&quot; readability=&quot;12&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt;!/bin/bash&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&lt;br/&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt;备份路径&lt;/span&gt;&lt;br/&gt;BACKUP=/data/backup/sql/dy&lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt;当前时间&lt;/span&gt;&lt;br/&gt;DATETIME=$(date +%Y-%m-%d_%H:%M:%S)&lt;p&gt;echo &quot;===备份开始===&quot;&lt;br/&gt;echo &quot;备份文件存放于${BACKUP}/$DATETIME.tar.gz&quot;&lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&lt;br/&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt;数据库地址&lt;/span&gt;&lt;br/&gt;HOST=localhost&lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt;数据库用户名&lt;/span&gt;&lt;br/&gt;DB_USER=root&lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt;数据库密码&lt;/span&gt;&lt;br/&gt;DB_PW=Ces123456&lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt;创建备份目录&lt;/span&gt;&lt;br/&gt;[ ! -d &quot;${BACKUP}/$DATETIME&quot; ] &amp;amp;&amp;amp; mkdir -p &quot;${BACKUP}/$DATETIME&quot;&lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&lt;br/&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt;后台系统数据库&lt;/span&gt;&lt;br/&gt;DATABASE=dy_backgroundms&lt;br/&gt;mysqldump -u${DB_USER} -p${DB_PW} --host=$HOST -q -R --databases $DATABASE | gzip &amp;gt; ${BACKUP}/$DATETIME/$DATABASE.sql.gz&lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&lt;br/&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt;投入品监管数据库&lt;/span&gt;&lt;br/&gt;DATABASE=dy_firip&lt;br/&gt;mysqldump -u${DB_USER} -p${DB_PW} --host=$HOST -q -R --databases $DATABASE | gzip &amp;gt; ${BACKUP}/$DATETIME/$DATABASE.sql.gz&lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&lt;br/&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt;压缩成tar.gz包&lt;/span&gt;&lt;br/&gt;cd $BACKUP&lt;br/&gt;tar -zcvf $DATETIME.tar.gz $DATETIME&lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt;删除备份目录&lt;/span&gt;&lt;br/&gt;rm -rf ${BACKUP}/$DATETIME&lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&lt;br/&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt;删除30天前备份的数据&lt;/span&gt;&lt;br/&gt;find $BACKUP -mtime +30 -name &quot;*.tar.gz&quot; -exec rm -rf {} \;&lt;/p&gt;&lt;p&gt;echo &quot;===备份成功===&quot;&lt;/p&gt;&lt;p&gt;注：find：linux的查找命令，用户查找指定条件的文件。&lt;br/&gt;-mtime：标准语句写法。&lt;br/&gt;＋10：查找10天前的文件，这里用数字代表天数，＋30表示查找30天前的文件。&lt;br/&gt;&quot;*.*&quot;：希望查找的数据类型，&quot;*.jpg&quot;表示查找扩展名为jpg的所有文件，&quot;*&quot;表示查找所有文件，这个可以灵活运用，举一反三。&lt;br/&gt;-exec：固定写法。&lt;br/&gt;rm -rf：强制删除文件，包括目录。&lt;br/&gt;{} \; ：固定写法，一对大括号+空格+\;&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;h12&quot;&gt;&lt;span&gt;&lt;strong&gt;12 资料附录&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
</description>
<pubDate>Sun, 27 Jan 2019 16:54:00 +0000</pubDate>
<dc:creator>黑泽君</dc:creator>
<og:description>1 Shell概述2 Shell解析器3 Shell脚本入门4 Shell中的变量4.1 系统变量4.2 自定义变量4.3 特殊变量：`$n`4.4 特殊变量：`$#`4.5 特殊变量：`$*、$@`</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenmingjun/p/10328583.html</dc:identifier>
</item>
<item>
<title>谈谈前端模块化的演变历程 - fozero</title>
<link>http://www.cnblogs.com/fozero/p/10328556.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fozero/p/10328556.html</guid>
<description>&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;Javascript不是一种模块化编程语言，它不支持&quot;类&quot;（class），更遑论&quot;模块&quot;（module）了，随着前端发展对&lt;br/&gt;模块需求越来越大，模块也是经历了从最初的简单模块写法到AMD和CMD规范的出现，再到ES6发布，目前已经可以&lt;br/&gt;很方便的在Javascript中使用&quot;类&quot;和&quot;模块&quot;了。&lt;/p&gt;
&lt;h3 id=&quot;一以前的写法&quot;&gt;一、以前的写法&lt;/h3&gt;
&lt;p&gt;1、原始写法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function m1(){
　　　　//...
　　}

　　function m2(){
　　　　//...
　　}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;缺点 ：&lt;br/&gt;&quot;污染&quot;了全局变量，无法保证不与其他模块发生变量名冲突，而且模块成员之间看不出直接关系。&lt;/p&gt;
&lt;p&gt;2、对象写法&lt;br/&gt;为了解决上面缺点，把模块写成一个对象，所有的模块成员都放到这个对象里面&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var module1 = new Object({

　　　　_count : 0,

　　　　m1 : function (){
　　　　　　//...
　　　　},

　　　　m2 : function (){
　　　　　　//...
　　　　}

　　});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;module1.m1();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;存在缺点：&lt;br/&gt;但是，这样的写法会暴露所有模块成员，内部状态可以被外部改写。比如，外部代码可以直接改变内部计数器的值。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;module1._count = 5;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3、立即执行函数写法&lt;/p&gt;
&lt;p&gt;立即执行函数（IIFE），可以达到不暴露私有成员的目的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var module1 = (function(){

　　　　var _count = 0;

　　　　var m1 = function(){
　　　　　　//...
　　　　};

　　　　var m2 = function(){
　　　　　　//...
　　　　};

　　　　return {
　　　　　　m1 : m1,
　　　　　　m2 : m2
　　　　};

　　})();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的写法，外部代码无法读取内部的_count变量。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;console.info(module1._count); //undefined&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;4、放大模式&lt;br/&gt;如果一个模块很大，必须分成几个部分，或者一个模块需要继承另一个模块&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;　　var module1 = (function (mod){

　　　　mod.m3 = function () {
　　　　　　//...
　　　　};

　　　　return mod;

　　})(module1);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的代码为module1模块添加了一个新方法m3()，然后返回新的module1模块。&lt;/p&gt;
&lt;p&gt;5、宽放大模式&lt;br/&gt;在浏览器环境中，模块的各个部分通常都是从网上获取的，有时无法知道哪个部分会先加载。如果采用上一节的写法，第一个执行的部分有可能加载一个不存在空对象，这时就要采用&quot;宽放大模式&quot;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var module1 = ( function (mod){

　　　　//...

　　　　return mod;

　　})(window.module1 || {});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;与&quot;放大模式&quot;相比，＂宽放大模式＂就是&quot;立即执行函数&quot;的参数可以是空对象。&lt;/p&gt;
&lt;p&gt;6、输入全局变量&lt;br/&gt;独立性是模块的重要特点，模块内部最好不与程序的其他部分直接交互。&lt;br/&gt;为了在模块内部调用全局变量，必须显式地将其他变量输入模块&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var module1 = (function ($, YAHOO) {

　　　　//...

　　})(jQuery, YAHOO);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的module1模块需要使用jQuery库和YUI库，就把这两个库（其实是两个模块）当作参数输入module1&lt;br/&gt;好处：&lt;br/&gt;这样做除了保证模块的独立性，还使得模块之间的依赖关系变得明显&lt;/p&gt;
&lt;h3 id=&quot;二commonjsamd和cmd的出现&quot;&gt;二、CommonJS、AMD和CMD的出现&lt;/h3&gt;
&lt;p&gt;谈到AMD和CMD，不得不说下CommonJS。2009年，美国程序员Ryan Dahl创造了node.js项目，将javascript语言用于服务器端编程，&lt;br/&gt;由于浏览器端网页还比较简单 ，对于模块不是特别依赖，但在服务器端因为要与操作系统和其他应用程序互动，CommonJS&lt;br/&gt;就在这样的背景下诞生了。&lt;/p&gt;
&lt;p&gt;引入第三方模块并调用方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var math = require('math');
math.add(2,3); // 5&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里有一个CommonJS模块使用的例子&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//模块定义 myModule.js
var name = 'Byron';
function printName(){
    console.log(name);
}
function printFullName(firstName){
    console.log(firstName + name);
}
module.exports = {
    printName: printName,
    printFullName: printFullName
}
//加载模块
var myModule = require('./myModule.js');
myModule.printName();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;1、AMD规范&lt;/p&gt;
&lt;p&gt;想象一下如果把这段代码放到浏览器端 ，math.add(2, 3)，在第一行require('math')之后运行，因此必须等math.js加载完成。也就是说，如果加载时间很长，整个应用就会停在那里等&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var math = require('math');
　　math.add(2, 3);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这对服务器端不是一个问题，因为所有的模块都存放在本地硬盘，可以同步加载完成，等待时间就是硬盘的读取时间。但是，对于浏览器，这却是一个大问题，因为模块都放在服务器端，等待时间取决于网速的快慢，可能要等很长时间，浏览器处于&quot;假死&quot;状态&lt;/p&gt;
&lt;p&gt;因此，浏览器端的模块，不能采用&quot;同步加载&quot;（synchronous），只能采用&quot;异步加载&quot;（asynchronous）&lt;/p&gt;
&lt;p&gt;AMD也采用require()语句加载模块，但是不同于CommonJS，它要求两个参数&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;require([module], callback);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面代码改写成AMD形式就是这样&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;require(['math'], function (math) {

　　　　math.add(2, 3);

　　});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;目前实现AMD规范的有RequireJS和curl.js&lt;/p&gt;
&lt;p&gt;RequireJS模块例子:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 定义模块 myModule.js
define('myModule', ['dependency'], function(){
    var name = 'Byron';
    function printName(){
        console.log(name);
    }
    return {
        printName: printName
    };
});

// 加载模块
require(['myModule'], function (my){
　 my.printName();
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2、CMD规范&lt;br/&gt;CMD: Common Module Definition通用模块定义, 由国内发展出来, SeaJS是其典型代表, 即SeaJS是通过浏览器对CMD的具体实现&lt;/p&gt;
&lt;p&gt;SeaJS模块例子:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 定义模块  myModule.js
define(function(require, exports, module) {
  var $ = require('jquery.js');
  var foo = require('foo');
  var out = foo.bar();
  $('div').addClass('active');
  module.exports = out;
});

// 加载模块
seajs.use(['myModule.js'], function(my){

});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3、CommonJS、AMD和CMD区别&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;CommonJS是同步的, 主要用于服务器&lt;/li&gt;
&lt;li&gt;AMD和CMD是异步的, 两者的模块定义和加载机制稍有不同, 主要用于浏览器&lt;/li&gt;
&lt;li&gt;AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块,CMD`推崇就近依赖，只有在用到某个模块的时候再去require&lt;br/&gt;两个都是定义的全局define函数来定义模块, define接收函数function(require, exports, module)保持一致&lt;/li&gt;
&lt;li&gt;CMD是懒加载, 仅在require时才会加载模块; - AMD是预加载, 在定义模块时就提前加载好所有依赖&lt;/li&gt;
&lt;li&gt;CMD保留了CommonJS风格&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;三es6的使用&quot;&gt;三、ES6的使用&lt;/h3&gt;
&lt;p&gt;ES6在语言标准的层面上, 实现了模块功能, 而且实现得相当简单, 完全可以取代CommonJS和AMD规范, 是浏览器和服务器通用的模块解决方案&lt;/p&gt;
&lt;p&gt;ES6模块例子:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//模块定义 myModule.js
const name = 'Byron';
function printName(){
    console.log(name);
}
function printFullName(firstName){
    console.log(firstName + name);
}
const myModule = {
    printName: printName,
    printFullName: printFullName
};
export myModule;

//加载模块
import myModule, { printFullName } from './myModule.js';
myModule.printName();
printFullName('Michael');&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;四最后再说说browserify和webpack&quot;&gt;四、最后再说说browserify和webpack&lt;/h3&gt;
&lt;p&gt;说到 browserify / webpack ，那还要说到 seajs / requirejs 。这四个都是JS模块化的方案。其中seajs / require 是一种类型，browserify / webpack 是另一种类型。&lt;/p&gt;
&lt;p&gt;1、seajs / require :&lt;br/&gt;是一种在线&quot;编译&quot;模块的方案，相当于在页面上加载一个 CMD/AMD 解释器。这样浏览器就认识了 define、exports、module 这些东西。也就实现了模块化。&lt;/p&gt;
&lt;p&gt;2、browserify / webpack : 是一个预编译模块的方案，相比于上面 ，这个方案更加智能。没用过browserify，这里以webpack为例。首先，它是预编译的，不需要在浏览器中加载解释器。另外，你在本地直接写JS，不管是 AMD / CMD / ES6 风格的模块化，它都能认识，并且编译成浏览器认识的JS。&lt;/p&gt;
&lt;h3 id=&quot;参考阅读&quot;&gt;参考阅读：&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2012/10/javascript_module.html&quot; class=&quot;uri&quot;&gt;http://www.ruanyifeng.com/blog/2012/10/javascript_module.html&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.jianshu.com/p/5226bd9644b6&quot; class=&quot;uri&quot;&gt;https://www.jianshu.com/p/5226bd9644b6&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://es6.ruanyifeng.com/#docs/module&quot; class=&quot;uri&quot;&gt;http://es6.ruanyifeng.com/#docs/module&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 27 Jan 2019 16:23:00 +0000</pubDate>
<dc:creator>fozero</dc:creator>
<og:description>前言 Javascript不是一种模块化编程语言，它不支持'类'（class），更遑论'模块'（module）了，随着前端发展对 模块需求越来越大，模块也是经历了从最初的简单模块写法到AMD和CMD规</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fozero/p/10328556.html</dc:identifier>
</item>
<item>
<title>asp.net core根据用户权限控制页面元素的显示 - WeihanLi</title>
<link>http://www.cnblogs.com/weihanli/p/10328554.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/weihanli/p/10328554.html</guid>
<description>&lt;h2 id=&quot;intro&quot;&gt;Intro&lt;/h2&gt;
&lt;p&gt;在 web 应用中我们经常需要根据用户的不同允许用户访问不同的资源，显示不同的内容，之前做了一个 &lt;a href=&quot;https://github.com/WeihanLi/AccessControlHelper&quot;&gt;AccessControlHelper&lt;/a&gt; 的项目，就是解决这个问题的。&lt;/p&gt;
&lt;p&gt;asp.net core 支持 TagHelper 和 基于 Policy 的认证&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.nuget.org/packages/WeihanLi.AspNetMvc.AccessControlHelper/&quot;&gt;AccessControlHelper&lt;/a&gt; 从1.4.0 版本开始支持 TagHelper 和 基于 Policy 的认证&lt;/p&gt;
&lt;h2 id=&quot;taghelper-用法&quot;&gt;TagHelper 用法&lt;/h2&gt;
&lt;p&gt;在 Views 目录下的 &lt;code&gt;~ViewImport.cshtml&lt;/code&gt; 中加入 TagHelper 引用&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@addTagHelper *, WeihanLi.AspNetMvc.AccessControlHelper&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在需要有权限才能访问的元素上加上 &lt;code&gt;asp-access&lt;/code&gt; ，支持自定义一个key，如果有特殊的key可以设置 &lt;code&gt;asp-access-key&lt;/code&gt;，下面有个示例&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;     &amp;lt;ul class=&quot;list-group&quot; asp-access asp-access-key=&quot;12334&quot;&amp;gt;
            &amp;lt;li role=&quot;separator&quot; class=&quot;list-unstyled&quot;&amp;gt;
                &amp;lt;br /&amp;gt;
            &amp;lt;/li&amp;gt;
            &amp;lt;li class=&quot;list-group-item&quot;&amp;gt;@Html.ActionLink(&quot;用户管理&quot;, &quot;UserList&quot;, &quot;Account&quot;)&amp;lt;/li&amp;gt;

            &amp;lt;li class=&quot;list-group-item&quot;&amp;gt;@Html.ActionLink(&quot;操作日志查看&quot;, &quot;Index&quot;, &quot;OperationLog&quot;)&amp;lt;/li&amp;gt;
            &amp;lt;li class=&quot;list-group-item&quot;&amp;gt;@Html.ActionLink(&quot;系统设置管理&quot;, &quot;Index&quot;, &quot;SystemSettings&quot;)&amp;lt;/li&amp;gt;
            &amp;lt;li class=&quot;list-group-item&quot;&amp;gt;
                @Html.ActionLink(&quot;微信设置管理&quot;, &quot;Index&quot;, new {
                controller = &quot;Config&quot;,
                area = &quot;Wechat&quot;
            })
            &amp;lt;/li&amp;gt;
        &amp;lt;/ul&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;示例代码完整&lt;a href=&quot;https://github.com/WeihanLi/ActivityReservation/blob/dev/ActivityReservation/Areas/Admin/Views/Home/Index.cshtml&quot;&gt;源码&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;实现自己的访问策略&quot;&gt;实现自己的访问策略&lt;/h2&gt;
&lt;p&gt;可以参考这个项目的实现 &lt;a href=&quot;https://github.com/WeihanLi/ActivityReservation/blob/dev/ActivityReservation.Helper/Services/PermissionRequireStrategy.cs&quot; class=&quot;uri&quot;&gt;https://github.com/WeihanLi/ActivityReservation/blob/dev/ActivityReservation.Helper/Services/PermissionRequireStrategy.cs&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc;
using WeihanLi.AspNetMvc.AccessControlHelper;
using WeihanLi.Common.Models;

namespace ActivityReservation.Filters
{
    public class AdminPermissionRequireStrategy : IActionAccessStrategy
    {
        private readonly IHttpContextAccessor _accessor;

        public AdminPermissionRequireStrategy(IHttpContextAccessor accessor)
        {
            _accessor = accessor;
        }

        public bool IsCanAccess(string accessKey)
        {
            var user = _accessor.HttpContext.User;
            return user.Identity.IsAuthenticated &amp;amp;&amp;amp; user.IsInRole(&quot;Admin&quot;);
        }

        public IActionResult DisallowedCommonResult =&amp;gt; new ContentResult
        {
            Content = &quot;No Permission&quot;,
            ContentType = &quot;text/plain&quot;,
            StatusCode = 403
        };

        public IActionResult DisallowedAjaxResult =&amp;gt; new JsonResult(new JsonResultModel
        {
            ErrorMsg = &quot;No Permission&quot;,
            Status = JsonResultStatus.NoPermission
        });
    }

    public class AdminOnlyControlAccessStragety : IControlAccessStrategy
    {
        private readonly IHttpContextAccessor _accessor;

        public AdminOnlyControlAccessStragety(IHttpContextAccessor httpContextAccessor) =&amp;gt; _accessor = httpContextAccessor;

        public bool IsControlCanAccess(string accessKey)
        {
            var user = _accessor.HttpContext.User;
            return user.Identity.IsAuthenticated &amp;amp;&amp;amp; user.IsInRole(&quot;Admin&quot;);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个示例实现的比较简单，只是判断了一下是否有 &lt;code&gt;Admin&lt;/code&gt; 角色，可以根据实际情况根据请求的地址以及当前登录用户及其它可能用到的信息去判断是否有权限访问。&lt;/p&gt;
&lt;h2 id=&quot;注册服务&quot;&gt;注册服务&lt;/h2&gt;
&lt;p&gt;在 Startup 文件中 ConfigureServices 中注册权限服务，注册自己的访问策略&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;// register access control service
services.AddAccessControlHelper&amp;lt;Filters.AdminPermissionRequireStrategy, Filters.AdminOnlyControlAccessStragety&amp;gt;();&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;policy-访问使用&quot;&gt;Policy 访问使用&lt;/h2&gt;
&lt;p&gt;在需要设置权限的 Action 或者 Controller 上加 &lt;code&gt;[Authorize(&quot;AccessControl&quot;)]&lt;/code&gt; 或者 &lt;code&gt;[Authorization(Policy=&quot;AccessControl&quot;)]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这两种方式是 asp.net core 下支持的 Policy 方式使用&lt;br/&gt;也支持比较传统的直接使用 &lt;code&gt;[AccessControl]&lt;/code&gt;，&lt;code&gt;AccessControl&lt;/code&gt; 和 &lt;code&gt;NoAccessControl&lt;/code&gt; 可以搭配使用， 类似于 &lt;code&gt;Authorize&lt;/code&gt; 和 &lt;code&gt;AllowAnoymous&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;taghelper-使用效果实例&quot;&gt;TagHelper 使用效果实例&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://reservation.weihanli.xyz/Admin/Account/Login?ReturnUrl=%2FAdmin%2FHome%2FIndex&quot;&gt;测试登录地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;普通用户： Alice/Test1234&lt;br/&gt;管理员： admin/Admin888&lt;/p&gt;
&lt;p&gt;查看&lt;a href=&quot;https://reservation.weihanli.xyz/Admin/Home/Index&quot;&gt;后台首页&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;管理员用户登录看到的界面：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2432073-81e35f5dfaaf3654.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;admin-user&quot;/&gt;&lt;/p&gt;
&lt;p&gt;普通用户登录看到的界面：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2432073-a2c03a89ffd8a288.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;common-user&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
</description>
<pubDate>Sun, 27 Jan 2019 16:21:00 +0000</pubDate>
<dc:creator>WeihanLi</dc:creator>
<og:description>在 web 应用中我们经常需要根据用户的不同允许用户访问不同的资源，显示不同的内容，之前做了一个 AccessControlHelper 的项目，就是解决这个问题的。 asp.net core</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/weihanli/p/10328554.html</dc:identifier>
</item>
<item>
<title>20190127-Orleans与SF小伙伴的部分问答 - 几维</title>
<link>http://www.cnblogs.com/CharlesZHENG/p/10328451.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CharlesZHENG/p/10328451.html</guid>
<description>&lt;div class=&quot;markdown-here-wrapper&quot; data-md-url=&quot;https://i.cnblogs.com/EditPosts.aspx?opt=1&quot; readability=&quot;24.529258400927&quot;&gt;
&lt;h5 id=&quot;orleans&quot;&gt;Orleans&lt;/h5&gt;
&lt;ol&gt;&lt;li&gt;怎么部署到服务器？&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;方式1：Orleans 服务端寄宿在Web应用中，将Web应用部署到服务器&lt;/li&gt;
&lt;li&gt;方式2：通过SF/K8s部署到服务器&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;不同服务器上的谷仓和谷如何调配？&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;由Orleans框架调度。当部署到有一组节点的集群时，Orleans在内部实现了一组协议，来发现和维护集群中Orleans silo的成员身份，包括检测节点故障和自动重新配置。&lt;/li&gt;
&lt;/ul&gt;&lt;ol readability=&quot;-1&quot;&gt;&lt;li readability=&quot;1&quot;&gt;谷和谷仓如何连接
&lt;pre&gt;
&lt;code&gt; var silo = new SiloHostBuilder()
 [...]
 // Endpoints
 .ConfigureEndpoints(siloPort: 11111, gatewayPort: 30000)
 [...]
&lt;/code&gt;
&lt;/pre&gt;
Orleans silo有两种典型类型的端点配置：&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;silo-to-silo端点(siloPort)，用于同一集群中的silo之间的通信&lt;/li&gt;
&lt;li&gt;client-to-silo端点（gatewayPort），用于同一集群中的客户端和silo之间的通信&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在示例中，我们使用帮助方法.ConfigureEndpoints(siloPort: 11111, gatewayPort: 30000)，将用于silo-to-silo通信的端口设置为11111和用于网关的端口设置为30000。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;接口、服务、actor概念的边界&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;结合OrleansSample.zip示例程序理解接口、服务、actor的概念&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;明确谷仓的含义&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;Grain的集合&lt;/li&gt;
&lt;li&gt;结合OrleansSample.zip示例程序理解
&lt;h5 id=&quot;actor&quot;&gt;Actor&lt;/h5&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;无状态的Actor上数据如何处理&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;通过调用actor的方法，对actor的字段数据CRUD&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;示例：&lt;br/&gt;Grain:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public class HelloGrain : Orleans.Grain, IHello
    {
        private readonly ILogger logger;
        private string tempData;
        public HelloGrain(ILogger&amp;lt;HelloGrain&amp;gt; logger)
        {
            this.logger = logger;
        }
        Task&amp;lt;string&amp;gt; IHello.SayHello(string greeting)
        {
            var result = string.IsNullOrEmpty(tempData) ? $&quot;You said: '{greeting}', I say: Hello!&quot; : $&quot;You said:'{tempData}-{greeting}'&quot;;
            return Task.FromResult(result);
        }

        public Task SetValue(string temp)
        {
            tempData = temp;
            return Task.CompletedTask;
        }
    }`
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;调用：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public class HomeController : Controller
    {
        private IClientFactory clientFactory;
        public HomeController(IClientFactory clientFactory)
        {
            this.clientFactory = clientFactory;
        }
        public async Task&amp;lt;IActionResult&amp;gt; Index()
        {
            var client = clientFactory.GetClient();
            var actor = client.GetGrain&amp;lt;IHello&amp;gt;(0);
            var r = await actor.SayHello(&quot;Kiwi&quot;);
            return Content(r);
        }
        public async Task SetValue(string str)
        {
            var client = clientFactory.GetClient();
            var actor = client.GetGrain&amp;lt;IHello&amp;gt;(0);
            await actor.SetValue(str);
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;Actor持续化的过程怎么实现&lt;/li&gt;
&lt;/ol&gt;&lt;ol&gt;&lt;li&gt;多个物理分离的服务如何连接在一起&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;通过&lt;code&gt;orleansmembershiptable&lt;/code&gt;表和Orleans框架维护的协调方式。&lt;/li&gt;
&lt;li&gt;相关回答 Orleans问题 3&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;Orleans+Actor 怎么部署 实际使用&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;相关回答 Orleans 问题 1
&lt;h5 id=&quot;sf&quot;&gt;SF&lt;/h5&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;SF与IIS的区别是什么?&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;Internet Information Service（IIS）是windows开设web网页服务的组件,提供Web、FTP、SMTP等服务，是用来搭载&lt;code&gt;网站运行程序&lt;/code&gt;的平台。&lt;/li&gt;
&lt;li&gt;Service Fabric 是一款分布式系统平台，可方便用户轻松打包、部署和管理可缩放的可靠微服务和容器。&lt;/li&gt;
&lt;li&gt;Service Fabric 可帮助你构建使用微服务方法的应用程序，它提供：
&lt;ol&gt;&lt;li&gt;提供系统服务的平台，用于部署、升级、检测和重启失败的服务、发现服务、路由消息、管理状态和监视运行状况。&lt;/li&gt;
&lt;li&gt;能够部署在容器中运行或作为进程运行的应用程序。 Service Fabric 是容器和进程 Orchestrator。&lt;/li&gt;
&lt;li&gt;有助于以微服务形式生成应用程序的编程模型，如：ASP.NET Core、Reliable Actors。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;SF的节点之间如何保证同步（例：一个节点死掉之后，再复原的时候依据的数据是怎么获得的）&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;可靠性子系统通过使用复制器、故障转移管理器和资源平衡器提供一种机制，使得 Service Fabric 服务的状态高度可用。&lt;br/&gt;复制器确保主服务副本中的状态更改会自动复制到辅助副本，从而维护服务副本集中主副本和辅助副本之间的一致性。 复制器负责副本集中副本间的仲裁管理。 它与故障转移单元进行交互以获取要复制的操作列表，重新配置代理为其提供副本集的配置。 该配置指示操作需要复制到哪些副本。 Service Fabric 提供名为 Fabric Replicator 的默认复制器，编程模型 API 可使用它来使服务状态高度可用和高度可靠。&lt;br/&gt;故障转移管理器确保向群集添加节点或从群集中删除节点时，会自动在可用节点间重新分发负载。 如果群集中的节点失败，群集会自动重新配置服务副本以维持可用性。&lt;br/&gt;Resource Manager 在群集中的失败域之间放置服务副本，并确保所有故障转移单元正常运行。 Resource Manager 还会平衡群集节点基础共享池中的服务资源，从而获得最佳的统一负载分布。&lt;/li&gt;
&lt;li&gt;SF中的微服务支持备份还原、容错域等概念实现高可用&lt;/li&gt;
&lt;li&gt;相关参考&lt;a href=&quot;https://docs.microsoft.com/zh-cn/azure/service-fabric/service-fabric-reliable-services-introduction&quot;&gt;Reliable Services 概述&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;SF与docker的关系&lt;/li&gt;
&lt;/ol&gt;&lt;ol&gt;&lt;li&gt;SF是否可以做到负载均衡&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;一般sf上的微服务之前，会配置专门的负载均衡器。&lt;/li&gt;
&lt;li&gt;支持。&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;在SF中，是否一个node对应多个服务器&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;Service Fabric 群集是一组通过网络连接在一起的虚拟机或物理计算机，微服务会在其中部署和管理。&lt;/li&gt;
&lt;li&gt;群集可以扩展到成千上万台计算机。&lt;/li&gt;
&lt;li&gt;属于群集一部分的计算机或 VM 称为节点。需为每个节点分配节点名称（字符串）。 节点具有各种特征，如放置属性。 每个计算机或 VM 都有一个自动启动 Windows 服务 FabricHost.exe，此服务在引导时开始运行，并启动两个可执行文件：Fabric.exe 和 FabricGateway.exe。 这两个可执行文件构成了节点。在开发或测试方案中，可以通过运行 Fabric.exe 和 FabricGateway.exe 的多个实例，在单台计算机或 VM 上托管多个节点。&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;p&gt;总结：&lt;br/&gt;上面表述摘自官方文档，可以理解为：生产环境，一个node对应一个服务器（一台物理机或一个VM）；测试开发环境，单台计算机或VM可以托管多个node&lt;/p&gt;
&lt;hr/&gt;&lt;ol&gt;&lt;li&gt;actor如何跨服务器通信&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;Silo对消息进行路由的过程分为以下3步
&lt;ol&gt;&lt;li&gt;查找本地的Actor Activation数据字典，如果找到了，直接路由到本地的Actor Activation进行消息处理&lt;/li&gt;
&lt;li&gt;如果本地的Actor Activation数据字典中没有这个Grain,则查找缓存字典,找到后根据字典中的Silo地址，然后将消息路由到对应的Silo&lt;/li&gt;
&lt;li&gt;如果缓存中也没找到，会根据GrainId，通过Consistent Hash来获得目标Silo，进行远程的Silo查找GrainId对应的激活，然后保存到本地的缓存字典中&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;相关参考 Orleans问题3和Actor问题3&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;如果SF部署两个cloud，是两个不同进程吗？&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;Service Fabric 是容器和进程Orchestrator。能够部署在容器中运行或作为进程运行的应用程序。&lt;/li&gt;
&lt;li&gt;sf集群中的协调器，帮助运行其他进程。协调器的数量和机制没有看到相关文档。&lt;/li&gt;
&lt;li&gt;如果Cloud_A下有一个应用程序项目；Cloud_B下有一个应用程序项目，是两个进程。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;​&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Sun, 27 Jan 2019 15:29:00 +0000</pubDate>
<dc:creator>几维</dc:creator>
<og:description>Orleans 怎么部署到服务器？ 方式1：Orleans 服务端寄宿在Web应用中，将Web应用部署到服务器 方式2：通过SF/K8s部署到服务器 不同服务器上的谷仓和谷如何调配？ 由Orleans</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CharlesZHENG/p/10328451.html</dc:identifier>
</item>
<item>
<title>Quartz.NET 3.0.7 + MySql 实现动态调度作业+动态切换版本+多作业引用同一程序集不同版本+持久化+集群(二) - 热敷哥</title>
<link>http://www.cnblogs.com/refuge/p/10325163.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/refuge/p/10325163.html</guid>
<description>&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/refuge/p/10324578.html&quot;&gt;Quartz.NET 3.0.7 + MySql 实现动态调度作业+动态切换版本+多作业引用同一程序集不同版本+持久化+集群(一)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;上篇文章搞定了第一个功能.&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.利用反射动态创建Job;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2.调度服务如何知道有新的任务来了?是调度服务轮询数据库?还是管理后台通知调度服务?又或者远程代理?&lt;/p&gt;
&lt;p&gt;3.需要一个管理后台,提供启动,暂停,恢复,停止等功能;&lt;/p&gt;
&lt;p&gt;4.至于集群,Quartz.NET 本身就提供该功能,只不过要使用它的持久化方案而已.这个点只需要在配置文件上做做手脚就可以了,并不需要怎么开发.&lt;/p&gt;
&lt;p&gt;5.管理后台如何实现启动,暂停,恢复,停止等功能?靠远程代理?还是通过其他方式?&lt;/p&gt;

&lt;p&gt;接下来解决剩下的问题.&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我一直认为世间万物,尘归尘,土归土,本质都是一样的.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;动物与动物交流,机器与机器交流,两个应用程序之间的交流,管你是什么东西交流,都跟人与人交流一样.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;要么你不停的问他,要么你等他告诉你.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;再不济,你俩都看对方不顺眼,不想彼此直接交流,于是找来一个中间人.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;他告诉中间人,中间人告诉你,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;或者中间人不停的问他,有了消息,中间人再告诉你.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;又或者你想要什么消息了,就去问中间人.中间人告诉你没有,那就没有.中间人说&quot;我找一找&quot;,&quot;诶,这里有.来给你消息&quot;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我认为其实就是这么回事儿,当然,我入行不久,理解还不够深入.不过目前我觉得这样理解能解决问题,就够了.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;学习讲究的是方法,一来就研究到最底层,不是明智之举.等哪天发现这么理解不能解决问题,这么理解有问题的时候,再深入研究也不迟.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;还是那句话,路要一步一步走,饭要一口一口吃.存在的就是合理的.&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;当我们在管理后台新增一个作业的时候,作业的信息,比如名称,时间表达式,程序集物理路径,作业类型的完全限定名等,我们肯定是要找张表单独存起来的,所以这里需要新建一张表:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;&lt;img id=&quot;code_img_closed_16c7e062-127b-4ef8-bc3d-b68b91ce0937&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_16c7e062-127b-4ef8-bc3d-b68b91ce0937&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_16c7e062-127b-4ef8-bc3d-b68b91ce0937&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;73&quot;&gt;
&lt;pre&gt;
&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt;&lt;span&gt; `jobinfo` (
  `Id` &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;(&lt;span&gt;11&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; AUTO_INCREMENT COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;编号&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
  `SchedName` &lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;20&lt;/span&gt;) &lt;span&gt;CHARACTER&lt;/span&gt; &lt;span&gt;SET&lt;/span&gt; utf8mb4 &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;调度器名称&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
  `JobName` &lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;50&lt;/span&gt;) &lt;span&gt;CHARACTER&lt;/span&gt; &lt;span&gt;SET&lt;/span&gt; utf8mb4 &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;''&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;作业名称&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
  `JobGroup` &lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;20&lt;/span&gt;) &lt;span&gt;CHARACTER&lt;/span&gt; &lt;span&gt;SET&lt;/span&gt; utf8mb4 &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;''&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;作业组&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
  `Cron` &lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;50&lt;/span&gt;) &lt;span&gt;CHARACTER&lt;/span&gt; &lt;span&gt;SET&lt;/span&gt; utf8mb4 &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;''&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;时间表达式&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
  `Second` &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;(&lt;span&gt;11&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;间隔时间,单位:秒&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
  `AssemblyPath` &lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;250&lt;/span&gt;) &lt;span&gt;CHARACTER&lt;/span&gt; &lt;span&gt;SET&lt;/span&gt; utf8mb4 &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;''&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;作业程序集物理路径&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
  `ClassType` &lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;100&lt;/span&gt;) &lt;span&gt;CHARACTER&lt;/span&gt; &lt;span&gt;SET&lt;/span&gt; utf8mb4 &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;''&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;作业完全限定名&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
  `StartTime` &lt;/span&gt;&lt;span&gt;datetime&lt;/span&gt; &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;0001-01-01 00:00:00&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;作业开始时间&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
  `CreateTime` &lt;/span&gt;&lt;span&gt;datetime&lt;/span&gt; &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;0001-01-01 00:00:00&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;作业创建时间&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
  `ProjectTeam` &lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;20&lt;/span&gt;) &lt;span&gt;CHARACTER&lt;/span&gt; &lt;span&gt;SET&lt;/span&gt; utf8mb4 &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;项目组&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
  `IsDeleted` &lt;/span&gt;&lt;span&gt;tinyint&lt;/span&gt;(&lt;span&gt;4&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;是否删除 0:否 1:是&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
  &lt;/span&gt;&lt;span&gt;PRIMARY&lt;/span&gt; &lt;span&gt;KEY&lt;/span&gt;&lt;span&gt; (`Id`)
) ENGINE&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;InnoDB &lt;span&gt;DEFAULT&lt;/span&gt; CHARSET&lt;span&gt;=&lt;/span&gt;utf8;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;那么这些数据如何让调度服务知道呢?(由于调研 Quartz,NET 框架的时候,看到很多大神说,IIS 回收池有坑.所以我就没考虑把调度服务和管理后台集成在一起)&lt;/p&gt;
&lt;p&gt;我第一版做的轮询 ,就是在调度服务启动的时候,启动一个预先已经建好的轮询job(轮询的间隔时间尽量短一点,调低哑火忍耐时间,设置好失火策略),&lt;/p&gt;
&lt;p&gt;轮询job扫描这张表(下简称:作业表),然后根据表里的某个字段来判断是否已经启动了该job.&lt;/p&gt;
&lt;p&gt;同时,当Job监听器监听到本次轮询job执行完成后,暂停它,避免无谓的轮询.&lt;/p&gt;
&lt;p&gt;当管理后台新增了一个作业时,就通过远程代理对象恢复该轮询job.&lt;/p&gt;
&lt;p&gt;我自以为这个方案很牛B,或者有那么一点点小&quot;聪明&quot;.&lt;/p&gt;
&lt;p&gt;但是,我后来把这个方案干掉了.&lt;/p&gt;
&lt;p&gt;因为要使用远程代理,管理后台就必须要 安装 Quartz.NET ,这一点我感觉很不爽.我只想在调度服务一个地方安装它.&lt;/p&gt;
&lt;p&gt;这里插一句.&lt;/p&gt;
&lt;p&gt;为了实现远程代理,网上找了好多代码,各种配置,都失败了,不知道是我没copy对,还是版本问题.&lt;/p&gt;
&lt;p&gt;这里奉上我自己研究出来的,实测可用的代码.至于远程代理的配置文件,就不贴出来了,网上太多了.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
                RemotingSchedulerProxyFactory proxyFactory = new&lt;span&gt; RemotingSchedulerProxyFactory
                {
                    Address = &quot;tcp://127.0.0.1:555/QuartzScheduler&quot;&lt;span&gt;
                };
                var schedulerProxy = proxyFactory.GetProxy();&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;第二版,也就是目前采用的方案:&lt;/p&gt;
&lt;p&gt;在调度服务内利用 owinself 组件内置一个api接口,接收管理后台的请求,拿到作业的数据后,实现该作业的启动,暂停,恢复,停止等操作. &lt;/p&gt;
&lt;p&gt;因此,管理后台不需要安装 Quartz.NET 组件了,只需要操作一下作业表,把作业的信息post给调度服务内置的api接口即可.&lt;/p&gt;
&lt;p&gt;整个设计如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1189148/201901/1189148-20190127204155623-16637230.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;(03 调度服务框架核心 中的 Middleware 大家可以不用理它,仅仅是我拿来练手用的)&lt;/p&gt;
&lt;p&gt;引用关系如下:&lt;/p&gt;
&lt;p&gt;Host 引用 Service ,Service 里面主要是初始化调度器,启动API监听方面的代码;&lt;/p&gt;
&lt;p&gt;Service 引用 Api , Api 接收管理后台的请求&lt;/p&gt;
&lt;p&gt;Api 引用 Logic ,Logic 里面就是具体的对Job的启动,暂停,恢复等操作了.&lt;/p&gt;
&lt;p&gt;另外, Api , Logic 都需要应用 Model&lt;/p&gt;
&lt;p&gt;Logic 还需要引用 BaseJob &lt;/p&gt;
&lt;p&gt;管理后台与调度框架没半毛钱联系.(当然,Model还是要引用一下)&lt;/p&gt;
&lt;p&gt;个人觉得这个设计耦合度比较低了.不过,还是那句话,任何事物都要辩证来看,耦合度是低了,开发量就相对多了一些.&lt;/p&gt;
&lt;p&gt;是时候看看界面了,MVC做的,很清(jian)爽(lou)吧!我的水平实在有限,就这个界面我还是网上抄的模板,当然也参考了这位前辈对Quartz.NET使用方面的一些思路.原谅我,帖子找不到了....&lt;/p&gt;
&lt;p&gt;像很多功能,比如触发器的触发机制选择,执行次数,失火策略等,我就没有在页面上体现了,而是在调度框架内部暂时写死了.一是时间来不及,二是公司的调度任务基本都差不多,没有什么大的区别.不过以后肯定还是要加上.比如我只想今天下午执行10次等等&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1189148/201901/1189148-20190126223204569-1187676081.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 对这个界面做一个简单的说明:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;从&quot;编号&quot;到&quot;程序集&quot;,这些字段的值来自作业表 jobInfo.&lt;/li&gt;
&lt;li&gt;&quot;状态&quot;,&quot;开始时间&quot;,&quot;上次执行&quot;,&quot;下次执行&quot;4个字段来自官方的 qrtz_triggers 表.&lt;/li&gt;
&lt;li&gt;页面暂时不是实时的,要看最新状态需要F5刷新.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对于&quot;调度器名称&quot;字段需要特别说明.&lt;/p&gt;
&lt;p&gt;整个框架开发到一半的时候,来了个新需求:&lt;/p&gt;
&lt;p&gt;要同时开多个调度服务(控制台程序)调度不同的任务,但是用同一张数据库表,同一个管理后台来管理.&lt;/p&gt;
&lt;p&gt;比如现在已经启了一个控制台程序了,管理了10个任务;&lt;/p&gt;
&lt;p&gt;再启一个控制台程序,管理另外10个任务,但是管理后台还是同一个,数据库表还是同一张.注意,不是集群,只是想分开管理任务而已.&lt;/p&gt;
&lt;p&gt;基于这个需求,所以设计了&quot;调度器名称&quot;字段.&lt;/p&gt;
&lt;p&gt;了解持久化方案的朋友肯定知道,在quartz.config配置文件中有这么一行:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
  quartz.scheduler.instanceName = &lt;span&gt;wechat&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我的方案就是利用这句配置,&lt;/p&gt;
&lt;p&gt;一个控制台程序(宿主)就是一个调度器,同时,将api地址放到控制台程序的配置文件中:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;add key=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ApiAddress&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:&lt;span&gt;25250&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当我们再开一个控制台程序时,(注意,不是集群),就需要同时修改上面两个配置,&lt;/p&gt;
&lt;p&gt;比如新的控制台程序的配置及新的quartz.config如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
 quartz.scheduler.instanceName =&lt;span&gt; refuge

&lt;/span&gt;&amp;lt;add key=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ApiAddress&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:&lt;span&gt;25251&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;那么,这时候管理后台就需要增加如下配置了:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
 &amp;lt;add key=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wechat&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:&lt;span&gt;25250&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
 &amp;lt;add key=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;refuge&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:&lt;span&gt;25251&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当我们点击按钮,发送请求前,先根据这个job的 &quot;调度器名称&quot; 字段从配置文件中获取它应该请求的地址.&lt;/p&gt;
&lt;p&gt;为了做到绝对安全,我在控制台程序的api中添加了过滤器,操作请求过来的时候,检查传过来的job数据中的&quot;调度器名称&quot;是否和该控制台程序中的调度器名称一样.不一样则不做任何操作.&lt;/p&gt;
&lt;p&gt;效果:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1189148/201901/1189148-20190126233512974-880594517.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;既然说到这个份上了,顺便把集群也说了.配置文件就不贴了,网上太多.&lt;/p&gt;
&lt;p&gt;Quartz.NET 的集群功能到底是个什么功能?它实际覆盖两个功能:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;解决单点问题&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;均衡服务器压力&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;解决单点问题&lt;/h2&gt;
&lt;p&gt;简单说就是启动两个控制台程序,作业只会被一个控制台程序调度,当其中一个挂了,另外一个立马开始工作.&lt;/p&gt;
&lt;p&gt;由于我这个框架内置了api,api监听地址肯定不能重复,所以要使用集群,必须修改api地址.&lt;/p&gt;
&lt;p&gt;那么在集群模式下,管理后台怎么知道应该请求哪个api呢?&lt;/p&gt;
&lt;p&gt;我们先看看效果,然后再解释.&lt;/p&gt;
&lt;p&gt;假设现在有两个控制台应用程序,配置如下,调度器名称都叫 &quot;wechat&quot;,并且本身已经存在一个Job了.&lt;/p&gt;
&lt;p&gt;控制台1:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
  &amp;lt;add key=&quot;ApiAddress&quot; value=&quot;http://localhost:25250&quot; /&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;控制台2:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
  &amp;lt;add key=&quot;ApiAddress&quot; value=&quot;http://localhost:25260&quot; /&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;效果图: &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1189148/201901/1189148-20190127210525674-1209550300.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;可以清楚的看到,下面的控制台程序并没有执行Job,现在我们关掉上面的控制台,&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1189148/201901/1189148-20190127210609683-2001890412.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我是20秒的时候关闭的,过了16秒,下面的控制台开始执行了.&lt;/p&gt;
&lt;p&gt;现在来解释下,管理后台的操作到底请求哪个api.&lt;/p&gt;
&lt;p&gt;可能会有朋友认为,肯定要请求 25250 ,因为 25260 的控制台处于&quot;备用&quot;状态,请求它没效果.&lt;/p&gt;
&lt;p&gt;事实上,这样理解是错的.&lt;/p&gt;
&lt;p&gt;&lt;span&gt;就算请求发送到 25260 控制台,虽然表面上这个控制台的调度器是处于&quot;备用&quot;状态,但实际上它只是&quot;待命&quot;而已,有请求过来,它依然能&quot;干活&quot;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&quot;改革春风吹满地&quot;,实践是检验真理的唯一标准.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;还是上面两个控制台,配置文件不变,现在修改一下管理后台的配置文件,api地址修改为 25260&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
   &amp;lt;add key=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wechat&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:25260&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行效果:&lt;/p&gt;
&lt;p&gt;21:18:00左右的时候 ,我通过管理后台启动了 Job2,可以看到 25260 所在的控制台开始干活了.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1189148/201901/1189148-20190127211709608-721103908.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;所以,根本不用担心,以集群的方式运行多个宿主的时候,管理后台应该请求哪一个api,而事实上,我们应该在管理后台的配置文件中,把所有集群的api地址都写上:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &amp;lt;add key=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wechat&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:25250,http://localhost:25260&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后,请求的时候,判断地址是否被监听,只要被监听了,post过去就不会有问题.&lt;br/&gt;比如上面这个配置,如果某一天 25250 控制台挂了,无所谓,25260 不还在么?请求发送到 25260 就OK了.我们要做的仅仅是在请求前判断一下这个地址是否已被监听就行了,没被监听,就换一个.&lt;/p&gt;
&lt;h2&gt;均衡服务器压力&lt;/h2&gt;
&lt;p&gt;这个就直接上图吧!&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1189148/201901/1189148-20190127224535698-2109800087.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;下面来解释一下:&lt;/p&gt;
&lt;p&gt;首先,4个Job的时间表达式都一样: 0/30 * * * * ?&lt;/p&gt;
&lt;p&gt;我先启动上面的控制台,在22:38:00 秒,4个Job都执行完成后,我启动了下面的控制台,可以看到,&quot;负载均衡&quot;是起到了效果的.但是,4个Job在下面的控制台都各自重复了一次.&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而且不管Job的间隔时间是多久,不过失火策略是什么,不管哑火的忍耐时间是多久,不管我隔多久启动下面的控制台,我做了很多实验,都会重复.而且迟早会重复一次,比如上面的 Job3 .但是只会重复一次.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这个有点小&quot;坑&quot;...我反复检查了我的代码,感觉不是代码层面的问题.&lt;/p&gt;
&lt;p&gt;我不知道这到底原因是什么?有没有哪位前辈知道的?能否告知一下,或者大概可能是哪个方面的原因?&lt;/p&gt;
&lt;p&gt;先到这吧!太晚了,明天继续写。&lt;/p&gt;

&lt;p&gt;躺在床上，想起一个问题，判断api地址是否被监听不对！&lt;/p&gt;
&lt;p&gt;万一我的集群是在两个服务器上呢？我去......&lt;/p&gt;
&lt;p&gt;我傻逼了......妈蛋......睡觉💤&lt;/p&gt;
</description>
<pubDate>Sun, 27 Jan 2019 15:17:00 +0000</pubDate>
<dc:creator>热敷哥</dc:creator>
<og:description>Quartz.NET 3.0.7 + MySql 实现动态调度作业+动态切换版本+多作业引用同一程序集不同版本+持久化+集群(一) 上篇文章搞定了第一个功能. 1.利用反射动态创建Job; 2.调度服</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/refuge/p/10325163.html</dc:identifier>
</item>
<item>
<title>一份来自一月寒冬互联网一线的面经（附面试题） - NovaCN</title>
<link>http://www.cnblogs.com/novaCN/p/10328380.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/novaCN/p/10328380.html</guid>
<description>&lt;h3&gt;1.背景：&lt;/h3&gt;
&lt;p&gt;因为公司变动，lz不得不出来看看机会， 面试的岗位主要是后端，历经三周，面了北京大大小小的几家公司，最后收获了满意的offer。&lt;/p&gt;
&lt;p&gt;自己也成长收获了不少， 谨以笔记，自己可以日后回忆，也希望能帮助到最近寒冬下需要找工作的同学，在文章的后面会附上一点小心得和建议。&lt;/p&gt;

&lt;h3&gt;2.level&lt;/h3&gt;
&lt;p&gt;我是16年本科毕业， 算上实习接近2年半-3年的工作经历吧，一直做java后端。  自己定位大概能到p6+的水平。有大厂经验，本科211， 所以面试机会总体来说还是挺多的。&lt;/p&gt;

&lt;h3&gt;3.过程&lt;/h3&gt;
&lt;p&gt;大概是从元旦过后开始写简历，投简历，从7号开始陆陆续续面了若干公司， 有好有坏，以表格形式记录如下，以我面试的时间排序。&lt;/p&gt;
&lt;p&gt;声明：虽然博客没有什么人看，但是如果您认为记录有不实或者伤害到下述公司名誉啥的， 直接联系我删除即可。&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;23.5&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;公司&lt;/td&gt;
&lt;td&gt;部门&lt;/td&gt;
&lt;td&gt; 渠道&lt;/td&gt;
&lt;td&gt; 结果&lt;/td&gt;
&lt;td&gt; 感受（办公环境，面试难度，感受）&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;14.5&quot;&gt;&lt;td&gt; 
&lt;p class=&quot;p1&quot;&gt;百信银行&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt; 
&lt;p class=&quot;p1&quot;&gt;DevOps&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;Boss&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt; 4+0，拿到offer.&lt;/p&gt;
&lt;p&gt;（4技术面 0hr面，下同）&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;16&quot;&gt;
&lt;p&gt; 百信的位置和办公环境都很不错，位于安贞门。&lt;/p&gt;
&lt;p&gt;面试官人很nice，没有多余的操作， 并且友好地帮我倒了一杯水。&lt;/p&gt;
&lt;p&gt;主要针对简历中的项目，以及java基础进行面试。&lt;/p&gt;
&lt;p&gt;难度也是循序渐进， 说实话因为是第一家面试， 我确实很多地方没有准备好，但是还是感谢面试官给我机会。&lt;/p&gt;
&lt;p&gt;感受：之前感觉银行可能比较水， 但是感觉各方面都挺与时俱进的， 待遇和人文也很有竞争力。 百信应该有大几百人的研发团队，各方面应该都不输于D轮的互联网公司。 总体是比较赞的。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;8.5&quot;&gt;&lt;td&gt; 动动&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; Boss&lt;/td&gt;
&lt;td&gt; 线上笔试&lt;/td&gt;
&lt;td readability=&quot;10&quot;&gt;
&lt;p&gt; 3道Codility，英文，大概3h限时， 我应该1h就写完了，用例跑通我就提交了，但是只有一道题ac。（很奇怪，也没有错误用例的提示，和LeetCode有些不一样）&lt;/p&gt;
&lt;p&gt; 然后hr还是让我去面试， 我拒绝了，可能是我当时已经对这家公司没有太大兴趣了。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;9&quot;&gt;&lt;td&gt;悉见科技&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;笔试+面试&lt;/td&gt;
&lt;td readability=&quot;11&quot;&gt;
&lt;p&gt;一家AI创业公司， 看jd介绍不错就去了。 最后发现是在一个很偏，有点破的创业园，里面环境有点像家乡的网吧。&lt;/p&gt;
&lt;p&gt;笔试3道很简单的题， 面试也没什么深度，面试官说实话感觉挺菜的。&lt;/p&gt;
&lt;p&gt;总体技术和互联网差别很大， 我当时也是抱着练手的态度过去。 所以也没下文了。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td&gt; vivo&lt;/td&gt;
&lt;td&gt; 金融&lt;/td&gt;
&lt;td&gt;Boss &lt;/td&gt;
&lt;td&gt; 视频面试&lt;/td&gt;
&lt;td readability=&quot;9&quot;&gt;
&lt;p&gt; 1面视频面，难度循序渐进，两位面试官提问。 面试官说第二天hr联系我，结果也没联系。我也没问了。&lt;/p&gt;
&lt;p&gt;主要是因为vivo在深圳，我在北京，可能我也不是很想换城市，后面投的都是在北京了。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;8&quot;&gt;&lt;td&gt; 美团&lt;/td&gt;
&lt;td&gt; --&lt;/td&gt;
&lt;td&gt; Boss&lt;/td&gt;
&lt;td&gt;3+0 拿到offer &lt;/td&gt;
&lt;td readability=&quot;11&quot;&gt;
&lt;p&gt;美团的环境感觉就是标准的互联网风格，&lt;/p&gt;
&lt;p&gt;面试官也很务实友好， 难度循序渐进，二面会问一些底层，并发的理解。&lt;/p&gt;
&lt;p&gt;美团无论是从技术沉淀还是我面试团队的潜力， 都是我很心仪的。&lt;/p&gt;
&lt;p&gt;很幸运也给了我一个不错的定级和待遇。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;15.5&quot;&gt;&lt;td&gt; 小米&lt;/td&gt;
&lt;td&gt; 有品&lt;/td&gt;
&lt;td&gt; Boss&lt;/td&gt;
&lt;td&gt;2面撤了&lt;/td&gt;
&lt;td readability=&quot;24&quot;&gt;
&lt;p&gt; 说实话，我开始是不想投小米的，但是考虑到我是湖北人，可能回武汉。&lt;/p&gt;
&lt;p&gt;但是！！！我面试之前应该在脉脉上搜一搜这个部门的。&lt;/p&gt;
&lt;p&gt;这个部门位于清河一个挺偏的地方， 周围仿佛回到了18县小乡镇。&lt;/p&gt;
&lt;p&gt;面试官也是low爆炸了，一面面试官穿了一个脱鞋，让我在楼下等了20min，前台态度也不好。&lt;/p&gt;
&lt;p&gt;然后竟然去了一个茶吧台面试。不过一面面试官总体态度还行。（小米不提供饮水，面试官带我去饮料机买了瓶汽水，当然是我自费，从小米出来我就有了带水的习惯了。）&lt;/p&gt;
&lt;p&gt;二面简直是个活宝，上来站着问，你懂hashmap吗， 我简单答了一下数组+链表，然后按理应该往碰撞，或者并发的方向继续问， 结果坐下，抖腿，问什么抓包的原理，然后扯的乱七八糟的。 最后憋了一分钟吧，出了一个很无聊的题（LeetCode第十题）。 我实在不想浪费彼此时间，就直接走了。&lt;/p&gt;
&lt;p&gt;小米本身在我心中还是个挺有态度的公司，和雷总也是老乡。  哎，真是刷新了我的三观。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;11.5&quot;&gt;&lt;td&gt; 脉脉&lt;/td&gt;
&lt;td&gt; 效能&lt;/td&gt;
&lt;td&gt; Boss&lt;/td&gt;
&lt;td&gt; 2+1&lt;/td&gt;
&lt;td readability=&quot;16&quot;&gt;
&lt;p&gt; 脉脉我觉得公司和产品一样nice， 位于768，环境很安静。&lt;/p&gt;
&lt;p&gt;hr笑的很开心，面试官也很有礼节。&lt;/p&gt;
&lt;p&gt;他们主后端是用python， java主要做一些离线和效能的工作。&lt;/p&gt;
&lt;p&gt;因为第一天3面面试官不在， hr让我第二天过去， 但是由于面试过程中了解到是去做效能平台，财务平台。&lt;/p&gt;
&lt;p&gt;秉着发展的考虑，我还是拒绝了。 &lt;/p&gt;
&lt;p&gt;但是我还是推荐脉脉， 小而美。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;13&quot;&gt;&lt;td&gt; 字节跳动&lt;/td&gt;
&lt;td&gt; 广告&lt;/td&gt;
&lt;td&gt; 猎头&lt;/td&gt;
&lt;td&gt; 3+1，拿到offer&lt;/td&gt;
&lt;td readability=&quot;19&quot;&gt;
&lt;p&gt; 面完小米之后，我觉得我不能在小公司上面浪费时间，同时也有了美团的offer。&lt;/p&gt;
&lt;p&gt;于是我把其余的面试都取消了，只剩下了头条和阿里。&lt;/p&gt;
&lt;p&gt;头条办公环境，位置都很好。 每层都有食堂（请我吃了一顿，很好吃）&lt;/p&gt;
&lt;p&gt;同学们给我最大的感受是 年轻，有活力，友好。 还有就是真的忙。&lt;/p&gt;
&lt;p&gt;我身边已经有陆陆续续不少同事选择了头条了。&lt;/p&gt;
&lt;p&gt;面试难度其实没有传说中的那么难， 不至于手写红黑树，但是基本的数据结构和算法要熟悉，每一面都会写算法。&lt;/p&gt;
&lt;p&gt;hr感觉也很尽心尽责。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;14&quot;&gt;&lt;td&gt;阿里巴巴&lt;/td&gt;
&lt;td&gt;文学&lt;/td&gt;
&lt;td&gt;Boss&lt;/td&gt;
&lt;td&gt;3+1&lt;/td&gt;
&lt;td readability=&quot;21&quot;&gt;
&lt;p&gt;阿里巴巴的面试总体有点失望，首先hr没预约会议室，导致在休息区面试。 也没有茶水，虽然我自带了。&lt;/p&gt;
&lt;p&gt;然后是办公区到处都是屏幕，循环着马云的创业视频。&lt;/p&gt;
&lt;p&gt;三面面试中规中矩。&lt;/p&gt;
&lt;p&gt;文学本来就不是我投的部门（我投的uc，不知道咋流过去了，然后让我面试，我也想试一试吧，然后hr说我蚂蚁简历没过，可我压根没投过）&lt;/p&gt;
&lt;p&gt;阿里最难的是hr面，  一个hr非要充当心里学家，问你人生高潮是啥， 非常没有礼貌，说话直接打断，也没什么信用，感觉这群hr把阿里搞得乌烟瘴气。   特别是hr套路很多， 面完了说没有hc，hc要审批（那你喊我来干嘛） ，然后我有很优秀的同事面过了 ，我说有人拿offer了 ，hr又说人家面的早。让我感觉她就是在刷kpi啥的。&lt;/p&gt;
&lt;p&gt;反正这个部门我是不建议去了， 周围拿到文学offer的同事也打算拒了再看看。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;亚马逊&lt;/td&gt;
&lt;td&gt;物流仓储&lt;/td&gt;
&lt;td&gt;Boss&lt;/td&gt;
&lt;td&gt;还没面&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h3&gt;4.总结及建议&lt;/h3&gt;
&lt;p&gt;1.一定要提前准备好，刷一定量的题，特别是现在各大公司都有自己的招聘系统，如果一面就挂了，可能直接就拉黑，后续面试就更难了。&lt;/p&gt;
&lt;p&gt;2.关于刷题，大概刷完剑指offer上面的经典题， 或者leetcode前100道应该就够了，我建议有选择的刷，主攻排序，链表，大文件处理这些面试高频的，也有意义的。&lt;/p&gt;
&lt;p&gt;3.关于练手，我觉得不要有太大的心里负担， 你去一般公司面试，对于公司可能是一种匹配，但是对个人可是一次很好的自我认知反省的机会，甚至会改变后续的很多结果。&lt;/p&gt;
&lt;p&gt;我们结合对行业的了解，如下公司可以说小而美（其实也是大独角兽了），本身就值得加入，面试也有很多收获： 猿辅导，脉脉，探探，瓜子，vivo互联网。&lt;/p&gt;
&lt;p&gt;当然拿大厂的边缘部门练手也未尝不可，就是有风险有记录。&lt;/p&gt;
&lt;p&gt;当然也有一些黑名单，面试官迷之自信，态度傲慢，技术浅显， 建议大家面试前脉脉一下。。&lt;/p&gt;
&lt;p&gt;最后一棒子打死，感觉位于清河的公司，可能都不太利于个人生活和发展。&lt;/p&gt;
&lt;p&gt;4.关于基础，我在下面附上一些前辈整理好的url。一定要夯实打捞。&lt;/p&gt;
&lt;p&gt;5.我觉得面试礼仪是衡量双方的重要标准， 面试者要注重自己的仪表整洁，谈吐礼貌自然。 可以从公司面试官的行为判断出公司的大体人员素质，我个人比较看重公司行政或者面试官是否能给瓶矿泉水或者倒杯水，我认为这是尊重一个面试者的基本表现，虽然后来我都是自己带水。 我面试中就小米和阿里没有(并且阿里文学是饭点约去面试，也不管饭，饿着肚子从5点面到9点多），然后就是双方是否守时，我一般提前20分钟到，提前10分钟给hr打个电话。 &lt;/p&gt;
&lt;p&gt;6.关于面试难度，我觉得正常应该是围绕简历和基础循序渐进，一上来手撕红黑树，给个hard基本要dp的，或许不是真心想招人的。 &lt;/p&gt;
&lt;p&gt;当然，即使难点也不要慌， 表达好自己的思考过程， 即使错了也没太大关系。&lt;/p&gt;
&lt;p&gt;其他的想到在整理吧。&lt;/p&gt;


&lt;h3&gt;5.面试题+基础&lt;/h3&gt;
&lt;p&gt;各家的面试题其实都大同小异， 掌握基础和原理，走到哪都不怕。&lt;/p&gt;
&lt;p&gt;电脑没电了 明天去公司再整理格式吧。&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;strong&gt;reids&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;知道&lt;span class=&quot;s1&quot;&gt;redis吗，&lt;span class=&quot;s1&quot;&gt;redis是如何做持久化的&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;介绍下&lt;span class=&quot;s1&quot;&gt;redis的特点，&lt;span class=&quot;s1&quot;&gt;redis的基本数据结构，数据持久化方式，主从之间如何同步；&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;导致&lt;span class=&quot;s1&quot;&gt;redis性能瓶颈的操作&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p4&quot;&gt;redis&lt;span class=&quot;s2&quot;&gt;有哪些接口&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&lt;span class=&quot;s1&quot;&gt;Redis的实现模式；&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&lt;span class=&quot;s1&quot;&gt;redis为什么这么快？&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;strong&gt;java-core&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;p4&quot;&gt;1&lt;span class=&quot;s2&quot;&gt;、List &lt;span class=&quot;s2&quot;&gt;和 Set &lt;span class=&quot;s2&quot;&gt;的区别2&lt;span class=&quot;s2&quot;&gt;、HashSet &lt;span class=&quot;s2&quot;&gt;是如何保证不重复的3&lt;span class=&quot;s2&quot;&gt;、HashMap &lt;span class=&quot;s2&quot;&gt;是线程安全的吗，为什么不是线程安全的（最好画图说明多线程环境下不安全）?4&lt;span class=&quot;s2&quot;&gt;、HashMap &lt;span class=&quot;s2&quot;&gt;的扩容过程5&lt;span class=&quot;s2&quot;&gt;、HashMap 1.7 &lt;span class=&quot;s2&quot;&gt;与 1.8 &lt;span class=&quot;s2&quot;&gt;的 &lt;span class=&quot;s2&quot;&gt;区别，说明 1.8 &lt;span class=&quot;s2&quot;&gt;做了哪些优化，如何优化的？6&lt;span class=&quot;s2&quot;&gt;、final finally finalize7&lt;span class=&quot;s2&quot;&gt;、强引用 &lt;span class=&quot;s2&quot;&gt;、软引用、 &lt;span class=&quot;s2&quot;&gt;弱引用、虚引用8&lt;span class=&quot;s2&quot;&gt;、Java&lt;span class=&quot;s2&quot;&gt;反射9&lt;span class=&quot;s2&quot;&gt;、Arrays.sort &lt;span class=&quot;s2&quot;&gt;实现原理和 Collection &lt;span class=&quot;s2&quot;&gt;实现原理10&lt;span class=&quot;s2&quot;&gt;、LinkedHashMap&lt;span class=&quot;s2&quot;&gt;的应用11&lt;span class=&quot;s2&quot;&gt;、cloneable&lt;span class=&quot;s2&quot;&gt;接口实现原理12&lt;span class=&quot;s2&quot;&gt;、异常分类以及处理机制13&lt;span class=&quot;s2&quot;&gt;、wait&lt;span class=&quot;s2&quot;&gt;和sleep&lt;span class=&quot;s2&quot;&gt;的区别14&lt;span class=&quot;s2&quot;&gt;、数组在内存中如何分配&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;strong&gt;java-&lt;/strong&gt;&lt;span class=&quot;s3&quot;&gt;并发&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&lt;span class=&quot;s1&quot;&gt;1、&lt;span class=&quot;s1&quot;&gt;synchronized 的实现原理以及锁优化？&lt;span class=&quot;s1&quot;&gt;2、&lt;span class=&quot;s1&quot;&gt;volatile 的实现原理？&lt;span class=&quot;s1&quot;&gt;3、&lt;span class=&quot;s1&quot;&gt;Java 的信号灯？&lt;span class=&quot;s1&quot;&gt;4、&lt;span class=&quot;s1&quot;&gt;synchronized 在静态方法和普通方法的区别？&lt;span class=&quot;s1&quot;&gt;5、怎么实现所有线程在等待某个事件的发生才会去执行？&lt;span class=&quot;s1&quot;&gt;6、&lt;span class=&quot;s1&quot;&gt;CAS？&lt;span class=&quot;s1&quot;&gt;CAS 有什么缺陷，如何解决？&lt;span class=&quot;s1&quot;&gt;7、&lt;span class=&quot;s1&quot;&gt;synchronized 和 &lt;span class=&quot;s1&quot;&gt;lock 有什么区别？&lt;span class=&quot;s1&quot;&gt;8、&lt;span class=&quot;s1&quot;&gt;Hashtable 是怎么加锁的 &lt;span class=&quot;s1&quot;&gt;？&lt;span class=&quot;s1&quot;&gt;9、&lt;span class=&quot;s1&quot;&gt;HashMap 的并发问题？&lt;span class=&quot;s1&quot;&gt;10、&lt;span class=&quot;s1&quot;&gt;ConcurrenHashMap 介绍？&lt;span class=&quot;s1&quot;&gt;1.8 中为什么要用红黑树？&lt;span class=&quot;s1&quot;&gt;11、&lt;span class=&quot;s1&quot;&gt;AQS12、如何检测死锁？怎么预防死锁？&lt;span class=&quot;s1&quot;&gt;13、&lt;span class=&quot;s1&quot;&gt;Java 内存模型？&lt;span class=&quot;s1&quot;&gt;14、如何保证多线程下 &lt;span class=&quot;s1&quot;&gt;i++ 结果正确？&lt;span class=&quot;s1&quot;&gt;15、线程池的种类，区别和使用场景？&lt;span class=&quot;s1&quot;&gt;16、分析线程池的实现原理和线程的调度过程？&lt;span class=&quot;s1&quot;&gt;17、线程池如何调优，最大数目如何确认？&lt;span class=&quot;s1&quot;&gt;18、&lt;span class=&quot;s1&quot;&gt;ThreadLocal原理，用的时候需要注意什么？&lt;span class=&quot;s1&quot;&gt;19、&lt;span class=&quot;s1&quot;&gt;CountDownLatch 和 &lt;span class=&quot;s1&quot;&gt;CyclicBarrier 的用法，以及相互之间的差别&lt;span class=&quot;s1&quot;&gt;?20、&lt;span class=&quot;s1&quot;&gt;LockSupport工具&lt;span class=&quot;s1&quot;&gt;21、&lt;span class=&quot;s1&quot;&gt;Condition接口及其实现原理&lt;span class=&quot;s1&quot;&gt;22、&lt;span class=&quot;s1&quot;&gt;Fork/Join框架的理解&lt;span class=&quot;s1&quot;&gt;23、分段锁的原理,锁力度减小的思考&lt;span class=&quot;s1&quot;&gt;24、八种阻塞队列以及各个阻塞队列的特性&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;ul1&quot;&gt;&lt;li class=&quot;li3&quot;&gt;&lt;span class=&quot;s4&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;单机上一个线程池正在处理服务，如果忽然断电了怎么办（正在处理和阻塞队列里的请求怎么处理）？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;li3&quot;&gt;&lt;span class=&quot;s4&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;为什么要使用线程池？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;li3&quot;&gt;&lt;span class=&quot;s4&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;线程池有什么作用？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;li3&quot;&gt;&lt;span class=&quot;s4&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;说说几种常见的线程池及使用场景。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;li3&quot;&gt;&lt;span class=&quot;s4&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;线程池都有哪几种工作队列？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;li3&quot;&gt;&lt;span class=&quot;s4&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;怎么理解无界队列和有界队列？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;li3&quot;&gt;&lt;span class=&quot;s4&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;线程池中的几种重要的参数及流程说明。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;p2&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;strong&gt;JVM&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&lt;span class=&quot;s1&quot;&gt;1、详细&lt;span class=&quot;s1&quot;&gt;jvm内存模型&lt;span class=&quot;s1&quot;&gt;2、讲讲什么情况下回出现内存溢出，内存泄漏？ &lt;span class=&quot;s1&quot;&gt;3、说说&lt;span class=&quot;s1&quot;&gt;Java线程栈&lt;span class=&quot;s1&quot;&gt;4、&lt;span class=&quot;s1&quot;&gt;JVM 年轻代到年老代的晋升过程的判断条件是什么呢？&lt;span class=&quot;s1&quot;&gt;5、&lt;span class=&quot;s1&quot;&gt;JVM 出现 &lt;span class=&quot;s1&quot;&gt;fullGC 很频繁，怎么去线上排查问题？&lt;span class=&quot;s1&quot;&gt;6、类加载为什么要使用双亲委派模式，有没有什么场景是打破了这个模式？&lt;span class=&quot;s1&quot;&gt;7、类的实例化顺序&lt;span class=&quot;s1&quot;&gt;8、&lt;span class=&quot;s1&quot;&gt;JVM垃圾回收机制，何时触发&lt;span class=&quot;s1&quot;&gt;MinorGC等操作&lt;span class=&quot;s1&quot;&gt;9、&lt;span class=&quot;s1&quot;&gt;JVM 中一次完整的 &lt;span class=&quot;s1&quot;&gt;GC 流程（从 &lt;span class=&quot;s1&quot;&gt;ygc 到 &lt;span class=&quot;s1&quot;&gt;fgc）是怎样的&lt;span class=&quot;s1&quot;&gt;10、各种回收器，各自优缺点，重点&lt;span class=&quot;s1&quot;&gt;CMS、&lt;span class=&quot;s1&quot;&gt;G111、各种回收算法&lt;span class=&quot;s1&quot;&gt;12、&lt;span class=&quot;s1&quot;&gt;OOM错误，&lt;span class=&quot;s1&quot;&gt;stackoverflow错误，&lt;span class=&quot;s1&quot;&gt;permgen space错误&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;ul1&quot;&gt;&lt;li class=&quot;li3&quot;&gt;&lt;span class=&quot;s4&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;说一下对&lt;span class=&quot;s1&quot;&gt;jvm的理解，&lt;span class=&quot;s1&quot;&gt;jvm的组成部分，各个部分的存储内容以及常见的&lt;span class=&quot;s1&quot;&gt;jvm的问题排查步骤。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;li3&quot;&gt;&lt;span class=&quot;s4&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;对&lt;span class=&quot;s1&quot;&gt;JVM熟不熟悉？简单说说类加载过程，里面执行的那些操作？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;li3&quot;&gt;&lt;span class=&quot;s4&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;JVM方法区存储内容 &lt;span class=&quot;s1&quot;&gt;是否会动态扩展 &lt;span class=&quot;s1&quot;&gt;是否会出现内存溢出 &lt;span class=&quot;s1&quot;&gt;出现的原因有哪些。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;li4&quot;&gt;&lt;span class=&quot;s4&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;span class=&quot;s2&quot;&gt;介绍介绍CMS&lt;span class=&quot;s2&quot;&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;li3&quot;&gt;&lt;span class=&quot;s4&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;介绍介绍&lt;span class=&quot;s1&quot;&gt;G1。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;li4&quot;&gt;&lt;span class=&quot;s4&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;span class=&quot;s2&quot;&gt;为什么jdk8&lt;span class=&quot;s2&quot;&gt;用metaspace&lt;span class=&quot;s2&quot;&gt;数据结构用来替代perm&lt;span class=&quot;s2&quot;&gt;？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;li3&quot;&gt;&lt;span class=&quot;s4&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;简单谈谈堆外内存以及你的理解和认识。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;li3&quot;&gt;&lt;span class=&quot;s4&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;JVM的内存模型的理解，&lt;span class=&quot;s1&quot;&gt;threadlocal使用场景及注意事项？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;li3&quot;&gt;&lt;span class=&quot;s4&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;JVM老年代和新生代的比例？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;li4&quot;&gt;&lt;span class=&quot;s4&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;jstack&lt;span class=&quot;s2&quot;&gt;,jmap&lt;span class=&quot;s2&quot;&gt;,jutil&lt;span class=&quot;s2&quot;&gt;分别的意义？如何线上排查JVM&lt;span class=&quot;s2&quot;&gt;的相关问题？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;li3&quot;&gt;&lt;span class=&quot;s4&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;Java虚拟机中，数据类型可以分为哪几类？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;li3&quot;&gt;&lt;span class=&quot;s4&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;怎么理解栈、堆？堆中存什么？栈中存什么？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;li3&quot;&gt;&lt;span class=&quot;s4&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;为什么要把堆和栈区分出来呢？栈中不是也可以存储数据吗？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;li3&quot;&gt;&lt;span class=&quot;s4&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;在&lt;span class=&quot;s1&quot;&gt;Java中，什么是是栈的起始点，同是也是程序的起始点？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;li3&quot;&gt;&lt;span class=&quot;s4&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;为什么不把基本类型放堆中呢？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;li3&quot;&gt;&lt;span class=&quot;s4&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;Java中的参数传递时传值呢？还是传引用？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;li3&quot;&gt;&lt;span class=&quot;s4&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;Java中有没有指针的概念？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;li3&quot;&gt;&lt;span class=&quot;s4&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;Java中，栈的大小通过什么参数来设置？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;li3&quot;&gt;&lt;span class=&quot;s4&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;一个空&lt;span class=&quot;s1&quot;&gt;Object对象的占多大空间？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;li3&quot;&gt;&lt;span class=&quot;s4&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;对象引用类型分为哪几类？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;li3&quot;&gt;&lt;span class=&quot;s4&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;讲一讲垃圾回收算法。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;li3&quot;&gt;&lt;span class=&quot;s4&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;如何解决内存碎片的问题？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;li3&quot;&gt;&lt;span class=&quot;s4&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;如何解决同时存在的对象创建和对象回收问题？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;li3&quot;&gt;&lt;span class=&quot;s4&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;讲一讲内存分代及生命周期。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;li3&quot;&gt;&lt;span class=&quot;s4&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;什么情况下触发垃圾回收？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;li3&quot;&gt;&lt;span class=&quot;s4&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;如何选择合适的垃圾收集算法？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;li3&quot;&gt;&lt;span class=&quot;s4&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;JVM中最大堆大小有没有限制？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;li3&quot;&gt;&lt;span class=&quot;s4&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;堆大小通过什么参数设置？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;li3&quot;&gt;&lt;span class=&quot;s4&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;JVM有哪三种垃圾回收器？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;li3&quot;&gt;&lt;span class=&quot;s4&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;吞吐量优先选择什么垃圾回收器？响应时间优先呢？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;li3&quot;&gt;&lt;span class=&quot;s4&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;如何进行&lt;span class=&quot;s1&quot;&gt;JVM调优？有哪些方法？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;li3&quot;&gt;&lt;span class=&quot;s4&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;&lt;span class=&quot;Apple-tab-span&quot;&gt;如何理解内存泄漏问题？有哪些情况会导致内存泄露？如何解决？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;p2&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;strong&gt;Spring&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;p4&quot;&gt;1&lt;span class=&quot;s2&quot;&gt;、BeanFactory &lt;span class=&quot;s2&quot;&gt;和 FactoryBean&lt;span class=&quot;s2&quot;&gt;？2&lt;span class=&quot;s2&quot;&gt;、Spring IOC &lt;span class=&quot;s2&quot;&gt;的理解，其初始化过程？3&lt;span class=&quot;s2&quot;&gt;、BeanFactory &lt;span class=&quot;s2&quot;&gt;和 ApplicationContext&lt;span class=&quot;s2&quot;&gt;？4&lt;span class=&quot;s2&quot;&gt;、Spring Bean &lt;span class=&quot;s2&quot;&gt;的生命周期，如何被管理的？5&lt;span class=&quot;s2&quot;&gt;、Spring Bean &lt;span class=&quot;s2&quot;&gt;的加载过程是怎样的？6&lt;span class=&quot;s2&quot;&gt;、如果要你实现Spring AOP&lt;span class=&quot;s2&quot;&gt;，请问怎么实现？7&lt;span class=&quot;s2&quot;&gt;、如果要你实现Spring IOC&lt;span class=&quot;s2&quot;&gt;，你会注意哪些问题？8&lt;span class=&quot;s2&quot;&gt;、Spring &lt;span class=&quot;s2&quot;&gt;是如何管理事务的，事务管理机制？9&lt;span class=&quot;s2&quot;&gt;、Spring &lt;span class=&quot;s2&quot;&gt;的不同事务传播行为有哪些，干什么用的？10&lt;span class=&quot;s2&quot;&gt;、Spring &lt;span class=&quot;s2&quot;&gt;中用到了那些设计模式？11&lt;span class=&quot;s2&quot;&gt;、Spring MVC &lt;span class=&quot;s2&quot;&gt;的工作原理？12&lt;span class=&quot;s2&quot;&gt;、Spring &lt;span class=&quot;s2&quot;&gt;循环注入的原理？13&lt;span class=&quot;s2&quot;&gt;、Spring AOP&lt;span class=&quot;s2&quot;&gt;的理解，各个术语，他们是怎么相互工作的？14&lt;span class=&quot;s2&quot;&gt;、Spring &lt;span class=&quot;s2&quot;&gt;如何保证 Controller &lt;span class=&quot;s2&quot;&gt;并发的安全？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;strong&gt;Netty&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p5&quot;&gt;分布式相关&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&lt;span class=&quot;s1&quot;&gt;1、&lt;span class=&quot;s1&quot;&gt;Dubbo的底层实现原理和机制&lt;span class=&quot;s1&quot;&gt;2、描述一个服务从发布到被消费的详细过程&lt;span class=&quot;s1&quot;&gt;3、分布式系统怎么做服务治理&lt;span class=&quot;s1&quot;&gt;4、接口的幂等性的概念&lt;span class=&quot;s1&quot;&gt;5、消息中间件如何解决消息丢失问题&lt;span class=&quot;s1&quot;&gt;6、&lt;span class=&quot;s1&quot;&gt;Dubbo的服务请求失败怎么处理&lt;span class=&quot;s1&quot;&gt;7、重连机制会不会造成错误&lt;span class=&quot;s1&quot;&gt;8、对分布式事务的理解&lt;span class=&quot;s1&quot;&gt;9、如何实现负载均衡，有哪些算法可以实现？&lt;span class=&quot;s1&quot;&gt;10、&lt;span class=&quot;s1&quot;&gt;Zookeeper的用途，选举的原理是什么？&lt;span class=&quot;s1&quot;&gt;11、数据的垂直拆分水平拆分。&lt;span class=&quot;s1&quot;&gt;12、&lt;span class=&quot;s1&quot;&gt;zookeeper原理和适用场景&lt;span class=&quot;s1&quot;&gt;13、&lt;span class=&quot;s1&quot;&gt;zookeeper watch机制&lt;span class=&quot;s1&quot;&gt;14、&lt;span class=&quot;s1&quot;&gt;redis/zk节点宕机如何处理&lt;span class=&quot;s1&quot;&gt;15、分布式集群下如何做到唯一序列号&lt;span class=&quot;s1&quot;&gt;16、如何做一个分布式锁&lt;span class=&quot;s1&quot;&gt;17、用过哪些&lt;span class=&quot;s1&quot;&gt;MQ，怎么用的，和其他&lt;span class=&quot;s1&quot;&gt;mq比较有什么优缺点，&lt;span class=&quot;s1&quot;&gt;MQ的连接是线程安全的吗&lt;span class=&quot;s1&quot;&gt;18、&lt;span class=&quot;s1&quot;&gt;MQ系统的数据如何保证不丢失&lt;span class=&quot;s1&quot;&gt;19、列举出你能想到的数据库分库分表策略；分库分表后，如何解决全表查询的问题&lt;span class=&quot;s1&quot;&gt;20、&lt;span class=&quot;s1&quot;&gt;zookeeper的选举策略&lt;span class=&quot;s1&quot;&gt;21、全局&lt;span class=&quot;s1&quot;&gt;ID&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;strong&gt;mysql:&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;p4&quot;&gt;http://www.iocoder.cn/Interview/MySQL-01/&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&lt;span class=&quot;s1&quot;&gt;mysql索引的实现原理&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&lt;span class=&quot;s1&quot;&gt;Innodb中，什么是聚集索引，非聚集索引，他们是什么关系&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;插入一条记录时，聚集索引和非聚集索引是如何修改的&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;建立索引的标准是什么&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;查看 &lt;span class=&quot;s1&quot;&gt;SQL 是不是使用了索引？（有什么工具）&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&lt;span class=&quot;s1&quot;&gt;SQL 索引的顺序，字段的顺序&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&lt;span class=&quot;s1&quot;&gt;MySQL 分页查询语句,&lt;span class=&quot;s1&quot;&gt;mysql分页有什么优化&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt; &lt;/p&gt;
</description>
<pubDate>Sun, 27 Jan 2019 15:03:00 +0000</pubDate>
<dc:creator>NovaCN</dc:creator>
<og:description>1.背景： 因为公司变动，lz不得不出来看看机会， 面试的岗位主要是后端，历经三周，面了北京大大小小的几家公司，最后收获了满意的offer。 自己也成长收获了不少， 谨以笔记，自己可以日后回忆，也希望</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/novaCN/p/10328380.html</dc:identifier>
</item>
<item>
<title>SpringBoot(二十六)整合Redis之共享Session - 请叫我头头哥</title>
<link>http://www.cnblogs.com/toutou/p/redis_session.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/toutou/p/redis_session.html</guid>
<description>&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mapper &lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt;=&quot;com.demo.dao.UserAccountMapper&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;resultMap &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;BaseResultMap&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;com.demo.pojo.UserAccount&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;id &lt;/span&gt;&lt;span&gt;column&lt;/span&gt;&lt;span&gt;=&quot;id&quot;&lt;/span&gt;&lt;span&gt; jdbcType&lt;/span&gt;&lt;span&gt;=&quot;INTEGER&quot;&lt;/span&gt;&lt;span&gt; property&lt;/span&gt;&lt;span&gt;=&quot;id&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;column&lt;/span&gt;&lt;span&gt;=&quot;username&quot;&lt;/span&gt;&lt;span&gt; jdbcType&lt;/span&gt;&lt;span&gt;=&quot;VARCHAR&quot;&lt;/span&gt;&lt;span&gt; property&lt;/span&gt;&lt;span&gt;=&quot;username&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;column&lt;/span&gt;&lt;span&gt;=&quot;age&quot;&lt;/span&gt;&lt;span&gt; jdbcType&lt;/span&gt;&lt;span&gt;=&quot;INTEGER&quot;&lt;/span&gt;&lt;span&gt; property&lt;/span&gt;&lt;span&gt;=&quot;age&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;column&lt;/span&gt;&lt;span&gt;=&quot;phone&quot;&lt;/span&gt;&lt;span&gt; jdbcType&lt;/span&gt;&lt;span&gt;=&quot;BIGINT&quot;&lt;/span&gt;&lt;span&gt; property&lt;/span&gt;&lt;span&gt;=&quot;phone&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;column&lt;/span&gt;&lt;span&gt;=&quot;email&quot;&lt;/span&gt;&lt;span&gt; jdbcType&lt;/span&gt;&lt;span&gt;=&quot;VARCHAR&quot;&lt;/span&gt;&lt;span&gt; property&lt;/span&gt;&lt;span&gt;=&quot;email&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;column&lt;/span&gt;&lt;span&gt;=&quot;account&quot;&lt;/span&gt;&lt;span&gt; jdbcType&lt;/span&gt;&lt;span&gt;=&quot;VARCHAR&quot;&lt;/span&gt;&lt;span&gt; property&lt;/span&gt;&lt;span&gt;=&quot;account&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;column&lt;/span&gt;&lt;span&gt;=&quot;pwd&quot;&lt;/span&gt;&lt;span&gt; jdbcType&lt;/span&gt;&lt;span&gt;=&quot;VARCHAR&quot;&lt;/span&gt;&lt;span&gt; property&lt;/span&gt;&lt;span&gt;=&quot;pwd&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;resultMap&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;sql &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;Base_Column_List&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    id, username, age, phone, email, account, pwd
  &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;sql&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;select &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;selectByPrimaryKey&quot;&lt;/span&gt;&lt;span&gt; parameterType&lt;/span&gt;&lt;span&gt;=&quot;java.lang.Integer&quot;&lt;/span&gt;&lt;span&gt; resultMap&lt;/span&gt;&lt;span&gt;=&quot;BaseResultMap&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    select 
    &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;include &lt;/span&gt;&lt;span&gt;refid&lt;/span&gt;&lt;span&gt;=&quot;Base_Column_List&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;span&gt;
    from useraccount
    where id = #{id,jdbcType=INTEGER}
  &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;select &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;getUserByAccount&quot;&lt;/span&gt;&lt;span&gt; parameterType&lt;/span&gt;&lt;span&gt;=&quot;java.lang.String&quot;&lt;/span&gt;&lt;span&gt; resultMap&lt;/span&gt;&lt;span&gt;=&quot;BaseResultMap&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    select
    &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;include &lt;/span&gt;&lt;span&gt;refid&lt;/span&gt;&lt;span&gt;=&quot;Base_Column_List&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;span&gt;
    from useraccount
    where account = #{account}
  &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;delete &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;deleteByPrimaryKey&quot;&lt;/span&gt;&lt;span&gt; parameterType&lt;/span&gt;&lt;span&gt;=&quot;java.lang.Integer&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    delete from useraccount
    where id = #{id,jdbcType=INTEGER}
  &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;delete&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;insert &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;insert&quot;&lt;/span&gt;&lt;span&gt; parameterType&lt;/span&gt;&lt;span&gt;=&quot;com.demo.pojo.UserAccount&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    insert into useraccount (id, username, age, 
      phone, email, account, 
      pwd)
    values (#{id,jdbcType=INTEGER}, #{username,jdbcType=VARCHAR}, #{age,jdbcType=INTEGER}, 
      #{phone,jdbcType=BIGINT}, #{email,jdbcType=VARCHAR}, #{account,jdbcType=VARCHAR}, 
      #{pwd,jdbcType=VARCHAR})
  &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;insert &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;insertSelective&quot;&lt;/span&gt;&lt;span&gt; parameterType&lt;/span&gt;&lt;span&gt;=&quot;com.demo.pojo.UserAccount&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    insert into useraccount
    &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;trim &lt;/span&gt;&lt;span&gt;prefix&lt;/span&gt;&lt;span&gt;=&quot;(&quot;&lt;/span&gt;&lt;span&gt; suffix&lt;/span&gt;&lt;span&gt;=&quot;)&quot;&lt;/span&gt;&lt;span&gt; suffixOverrides&lt;/span&gt;&lt;span&gt;=&quot;,&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;if &lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;=&quot;id != null&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        id,
      &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;if &lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;=&quot;username != null&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        username,
      &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;if &lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;=&quot;age != null&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        age,
      &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;if &lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;=&quot;phone != null&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        phone,
      &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;if &lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;=&quot;email != null&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        email,
      &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;if &lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;=&quot;account != null&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        account,
      &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;if &lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;=&quot;pwd != null&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        pwd,
      &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;trim&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;trim &lt;/span&gt;&lt;span&gt;prefix&lt;/span&gt;&lt;span&gt;=&quot;values (&quot;&lt;/span&gt;&lt;span&gt; suffix&lt;/span&gt;&lt;span&gt;=&quot;)&quot;&lt;/span&gt;&lt;span&gt; suffixOverrides&lt;/span&gt;&lt;span&gt;=&quot;,&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;if &lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;=&quot;id != null&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        #{id,jdbcType=INTEGER},
      &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;if &lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;=&quot;username != null&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        #{username,jdbcType=VARCHAR},
      &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;if &lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;=&quot;age != null&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        #{age,jdbcType=INTEGER},
      &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;if &lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;=&quot;phone != null&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        #{phone,jdbcType=BIGINT},
      &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;if &lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;=&quot;email != null&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        #{email,jdbcType=VARCHAR},
      &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;if &lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;=&quot;account != null&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        #{account,jdbcType=VARCHAR},
      &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;if &lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;=&quot;pwd != null&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        #{pwd,jdbcType=VARCHAR},
      &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;trim&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;update &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;updateByPrimaryKeySelective&quot;&lt;/span&gt;&lt;span&gt; parameterType&lt;/span&gt;&lt;span&gt;=&quot;com.demo.pojo.UserAccount&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    update useraccount
    &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;if &lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;=&quot;username != null&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        username = #{username,jdbcType=VARCHAR},
      &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;if &lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;=&quot;age != null&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        age = #{age,jdbcType=INTEGER},
      &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;if &lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;=&quot;phone != null&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        phone = #{phone,jdbcType=BIGINT},
      &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;if &lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;=&quot;email != null&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        email = #{email,jdbcType=VARCHAR},
      &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;if &lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;=&quot;account != null&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        account = #{account,jdbcType=VARCHAR},
      &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;if &lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;=&quot;pwd != null&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        pwd = #{pwd,jdbcType=VARCHAR},
      &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    where id = #{id,jdbcType=INTEGER}
  &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;update&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;update &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;updateByPrimaryKey&quot;&lt;/span&gt;&lt;span&gt; parameterType&lt;/span&gt;&lt;span&gt;=&quot;com.demo.pojo.UserAccount&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    update useraccount
    set username = #{username,jdbcType=VARCHAR},
      age = #{age,jdbcType=INTEGER},
      phone = #{phone,jdbcType=BIGINT},
      email = #{email,jdbcType=VARCHAR},
      account = #{account,jdbcType=VARCHAR},
      pwd = #{pwd,jdbcType=VARCHAR}
    where id = #{id,jdbcType=INTEGER}
  &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;update&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;mapper&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;</description>
<pubDate>Sun, 27 Jan 2019 14:32:00 +0000</pubDate>
<dc:creator>请叫我头头哥</dc:creator>
<og:description>集群现在越来越常见，当我们项目搭建了集群，就会产生session共享问题。因为session是保存在服务器上面的。那么解决这一问题，大致有三个方案，1.通过nginx的负载均衡其中一种ip绑定来实现（</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/toutou/p/redis_session.html</dc:identifier>
</item>
<item>
<title>设计模式---六大原则 - 涛姐涛哥</title>
<link>http://www.cnblogs.com/taojietaoge/p/10317701.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/taojietaoge/p/10317701.html</guid>
<description>&lt;p&gt;&lt;span&gt;背景：听说设计模式是进入BAT的必经之路。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;First、何谓设计模式&lt;/strong&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;设计模式(Design Pattern)是一套被反复使用、多数人知晓的、经过分类的、代码设计经验的总结。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;设计模式的好处&amp;amp;学习目的&lt;/strong&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、为了代码可重用行、让代码更易被他人理解、保证代码的可靠性、使代码编写真正实现工程化；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、设计模式便于我们维护项目，增强系统的健壮性和可扩展性；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、设计模式还可以锻炼码农的设计思维、升华代码质量等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;六大指导原则&lt;/strong&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;程序设计模式有六大基本指导原则，但规则毕竟都是人定的，So我们要灵活遵守、灵活运用这六大原则。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、开-闭原则&lt;/strong&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、开闭原则顾名思义就是对修改关闭，对扩展开放；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、开闭原则是六大原则的核心，即我们之后做的任何改变都不需要修改原有的代码，只需要加入一些新的实现即可达到目的；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、开闭原则也是任何一个系统设计期望达到的理想境界。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、单一职责原则&lt;/strong&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;单一职责即每个类都只负责单一的功能，莫要太贪心，除此之外尽量把一个类的功能完善到极致，可以用final来修饰的程度。下面就有一个例子类Scientific 从一个文件中读取两个数，并返回两者之和，如此设计可以很明显的看到它们之间的职责问题存在太多耦合了。如图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1580332/201901/1580332-20190125001836678-866086044.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上图中显示的&lt;span&gt;Scientific&lt;/span&gt; 类并没有错，但是我们要是读取文件的地址改变了呢？要是结果改为两者之差、&lt;span&gt;两者之积或&lt;span&gt;两者之商或者是&lt;span&gt;两者之模呢？然后，我们需要复制许多份相同的代码，想想这种设计就不合理；这时我们就要考虑下“&lt;span&gt;单一职责原则&lt;/span&gt;”，分离出一个类ReadFile 来读取数据，再分离出一个类DesignScientific 对读取到的数据进行处理(加减乘除等)。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.BufferedReader;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.FileReader;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ReadFile {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; numOne;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; numTwo;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; ReadFile(String path) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         BufferedReader br = &lt;span&gt;new&lt;/span&gt; BufferedReader(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; FileReader(path));
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;          numOne =&lt;span&gt; Integer.valueOf(br.readLine());
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;          numTwo =&lt;span&gt; Integer.valueOf(br.readLine());
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         System.out.println(&quot;numOne is: &quot;+numOne+&quot; &amp;amp;&amp;amp; &quot;+&quot;numTwo is: &quot;+&lt;span&gt;numTwo);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getNumOne() {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; numOne;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getnumTwo() {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; numTwo;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1580332/201901/1580332-20190125003430798-122319089.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如此，将一个类拆为两个，既不会有那么多重复的代码，也多了跟多结果的选择性，也恰恰体现了单一职责原则是我们设计模式最应该遵守的原则之一。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、里氏替换原则&lt;/strong&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;里氏替换原则具体指的是一个子类可以在替换掉其父类后正常工作，也就是自类不应该重写父类的方法，其主要作用是规范继承是子类的一些书写规则，主要目的是保持父类方法不被覆盖。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、子类可以实现父类的抽象方法，但不能覆盖父类的抽象方法(要不重新写给类算了，干嘛要继承)；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、子类中可以增加自己特有的方法；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、当子类覆盖或实现父类方法时，方法的前置条件(方法的形参)要比其父类方法的输入参数更宽松(如：fun&lt;span&gt;(&lt;span&gt;&lt;span&gt;ArrayLIst&lt;/span&gt;&lt;/span&gt;, list) VS fun(List, list)&lt;/span&gt; )；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4、当子类的方法实现父类的抽象方法时，方法的后置条件(方法的返回值)要比其父类更严格。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;四、接口隔离原则&lt;/strong&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接口隔离原则也叫做接口最小化原则，指的是一个接口拥有的行为应该尽可能的最小。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、如果设计的时候没有考虑到接口隔离原则，就会出现一个类实现了一个接口但实现类中只有个别的方法实现了其他方法都是空的状况，导致强制实现了不得不实现而又本不该实现的方法，而最终也一直没有调用过此方法，造成资源浪费；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、比如我们设计一个手机Mobile的接口时，就要考虑手机哪些属性时必须的，要让该接口尽量最小最细化，即只要是手机就必须要具备的属性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;没有遵守接口隔离原则的Mobile接口设计：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Mobile {&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; call();  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;手机可以打电话&lt;/span&gt;    
&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; sendMessage();  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;手机可以发短信&lt;/span&gt;   
&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; weChat();  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;手机可以上微信weChat？&lt;/span&gt;
&lt;span&gt;5   &lt;/span&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;上述Mobile接口很明显不是一个手机必须具备的功能属性，那么什么的Mobile接口就不是最小接口，因为非智能手机就只可以打电话和发短信，而上微信就是智能手机的专属特性，如此就会有多余的实现方法，可以做如下修改，充分考虑&lt;span&gt;接口隔离原则&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; SmartPhone &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Mobile{&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;weChat&lt;/span&gt;();   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;智能手机的接口就可以加入这个方法了&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;五、依赖倒置原则&lt;/strong&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个原则描述的是高层模块不该依赖于低层模块，两个模块都应该依赖依赖于抽象，抽象不应该依赖于细节，细节应该依赖于抽象。因为实现都是易变的，只有抽象是稳定的，所以当我们依赖于抽象是，实现的变化就不会影响客户端的调用；就比如上面“&lt;span&gt;单一职责&lt;/span&gt;”中的计算器的例子，计算器其实是依赖于数据读取类的，这样设计还是有一些缺陷，因为若是当数据不是在文件里，而是在数据库当中呢？这时候为了不影响现有的代码，只能将ReaderFile类整个大改，或是新增一个DBReader类，把程序代码中所有使用到ReaderFile读取到地方替换成DBReader，这样做勉强可以接受，但是仍然达不到可复制化的标准；若是数据读取有的是从数据库、有点是从XML文件、有的是从网络或是从键盘输入读取，这时就有充分考虑依赖倒置原则。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Reader {&lt;br/&gt;&lt;/span&gt;2      //&lt;span&gt;依赖倒置抽象出的一个抽象接口&lt;/span&gt;
3     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getA();  
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getB();
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;依赖倒置原则&lt;/span&gt;&lt;span&gt;让我们抽象出一个抽象类或者接口，来表述数据读取行为，然后让上面所有的读取方式所实现的类都实现该接口，客户端方面只使用我们定义好的接口，当我们的实现变化时，我们只需设置下不同的实际类型就OK了，这样设计对于系统的扩展行将会是一个巨大的提升；这样设计的话，计算器就依赖于一个很稳定的抽象接口，之后不论是从哪里读取数据，两个获取数据的方法都不会改变；无论是DBReader、XMLReader、NetReader或是OutPutStreamReader之类的都可以实现Reader这个抽象接口，不管是从哪里读取数据都OK，因为我们不需要关心这个，只要可以从Reader接口中获得A和B的值就OK了；同时，依赖于抽象也体现了JAVA语言的动态特性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;六、迪米特原则&lt;/strong&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;迪米特原则也称最小知道原则，就是一个类尽量不应该知道(包括)其他类太多的东西，不要和其他类有太多的交集。该原则的制定的终极目的就是解耦，即将细节全部高内聚于类的内部，其他的类只需知道这个类主要提供的功能就OK了，减少不必要的依赖，高聚合低耦合。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;   &lt;br/&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 27 Jan 2019 14:23:00 +0000</pubDate>
<dc:creator>涛姐涛哥</dc:creator>
<og:description>背景：听说设计模式是进入BAT的必经之路。 First、何谓设计模式： 设计模式(Design Pattern)是一套被反复使用、多数人知晓的、经过分类的、代码设计经验的总结。 设计模式的好处&amp;</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/taojietaoge/p/10317701.html</dc:identifier>
</item>
<item>
<title>玩转redux--从会用到庖丁解牛 - 安乐最胜吉祥君</title>
<link>http://www.cnblogs.com/anlewo/p/10328201.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/anlewo/p/10328201.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;为何而写&quot;&gt;为何而写&lt;/h2&gt;
&lt;p&gt;　　以前没怎么写过技术类的文章，对于技术很多时候是现用现学，这样通常能解决遇到过的绝大多数问题，但也带来了一个弊端，那就是仅停留于解决问题的层面，而忽略了对技术背后的设计思想和设计理念进行深入的研究。虽然技术的发展日新月异，但那些终归只是由设计思想演绎出来的玩物，如果只是不断的去学习演绎出来的东西，而忽略了对思想的研究，就终究会陷入舍本逐末的恶性循环。&lt;/p&gt;
&lt;p&gt;　　技术的提高离不开实践，实践有助于深化对技术的理解，但如果只实践而不加以总结的话也容易陷入只见树木不见森林的迷途。如果说实践是战术上的肉搏，那总结就是战略上的提炼，高屋建瓴，将实践中的精髓抽取出来，以达到去繁入简、返璞归真的境界。&lt;br/&gt;　　&lt;br/&gt;　　鉴于此，也就打算把学习、实践过的技术进行再次的学习、总结，并以博文的形式记录下来，这样一方面有助于理清思路，建立知识体系，另一方面更有助于深入对技术的理解和掌握，这也是我打算开始写技术文章的初衷。&lt;br/&gt;　　&lt;/p&gt;
&lt;h2 id=&quot;redux是什么&quot;&gt;redux是什么&lt;/h2&gt;
&lt;p&gt;　　redux是一个库，用于管理状态，也可以说是一个容器，这个容器里容纳了各种需要的状态信息，并对外提供了一些方法来管理这些状态。目前redux更多的实践是和react结合，管理react的视图状态，但它也可以独立当作发布、订阅系统来使用。总之这些只是概念层面上的东西，实践完之后再来看概念就会容易理解，否则概念永远是模糊的。&lt;/p&gt;
&lt;h2 id=&quot;redux的设计哲学&quot;&gt;redux的设计哲学&lt;/h2&gt;
&lt;p&gt;redux有三大设计哲学：&lt;br/&gt;1、单一数据源。&lt;br/&gt;顾名思义就是所有的状态信息都存储在同一个容器里。&lt;br/&gt;2、状态是只读的。&lt;br/&gt;redux是用来管理状态的，竟然能管理，那就包含了对状态的增、删、改操作。这里的只读是指新状态不会破坏原来的旧状态，也就是说新状态的产生过程是：1、先从旧状态进行深拷贝得到一个复本。2、对复本进行操作得到新状态。&lt;br/&gt;3、使用纯函数来更新状态。&lt;br/&gt;纯函数是指输入相同的参数时，总能得到相同的输出结果，并且不会修改输入的参数。&lt;/p&gt;
&lt;p&gt;这三大设计哲学主要是为了简化对状态的管理，让状态可预测、可追踪，从而易于维护代码，也更易于排查bug。&lt;/p&gt;
&lt;h2 id=&quot;redux的工作流&quot;&gt;redux的工作流&lt;/h2&gt;
&lt;p&gt;redux的工作流如下图所示：&lt;/p&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://slides.com/jenyaterpil/redux-from-twitter-hype-to-production#/9&quot; class=&quot;uri&quot;&gt;https://slides.com/jenyaterpil/redux-from-twitter-hype-to-production#/9&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1586118/201901/1586118-20190127220934659-398215677.gif&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;redux的几个核心要素&quot;&gt;redux的几个核心要素&lt;/h2&gt;
&lt;h3 id=&quot;store&quot;&gt;store&lt;/h3&gt;
&lt;p&gt;redux是管理状态的，所有的状态都存储在“store”里，所以store是一个数据中心，也是最核心的要素。同时store对外暴露了一些api用于管理store里的数据，这些api包括getState、dispatch、subscribe、replaceReducer。store是由createStore函数创建的，如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;const store = createStore(reducer, preloadedState, enhancer)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;createStore的实现原理如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;const createStore = reducer =&amp;gt; {
    let state;
    // listeners用来存储所有的监听函数
    let listeners = [];
    
    const getState = () =&amp;gt; state;
    
    const dispatch = action =&amp;gt; {
        state = reducer(state, action);
        // 每一次状态更新后，都需要调用listeners数组中的每一个监听函数
        listeners.forEach(listener =&amp;gt; listener());
    }
    
    const subscribe = listener =&amp;gt; {
        // subscribe可能会被调用多交，每一次调用时，都将相关的监听函数存入listeners数组中
        listeners.push(listener);
        // 返回一个函数，进行取消订阅
        return () =&amp;gt; {
            listeners = listeners.filter(item =&amp;gt; item !== listener);
        }
    }
    
    return { getState, dispatch, subscribe };
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;dispatch&quot;&gt;dispatch&lt;/h4&gt;
&lt;p&gt;dispatch用来派发一个action，所有对state的更新以及获取数据都是通过派发一个action来完成的。如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let action1 = {
    type: 'READ_BOOK',
    data: {
        book: 'book1'
    }
};

store.dispatch(action1);&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;getstate&quot;&gt;getState&lt;/h4&gt;
&lt;p&gt;getState用于获取store里的状态数据，即state。如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let state = store.getState();&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;subscribe&quot;&gt;subscribe&lt;/h4&gt;
&lt;p&gt;subscribe用于订阅store里的数据状态，当store里state数据变更时，通知订阅方。如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;const render = () =&amp;gt; {
    ...
}

store.subscribe(render);&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;replacereducer&quot;&gt;replaceReducer&lt;/h4&gt;
&lt;p&gt;这个一般开发用不到。&lt;/p&gt;
&lt;h3 id=&quot;action&quot;&gt;action&lt;/h3&gt;
&lt;p&gt;action是指一个操作动作，当需要操作store里的数据时，就需要分发一个action来通知store。每个action描述了一个操作，它是一个object的数据结构，有一个必填属性“type”，值是字符串常量，用于标识动作，可以理解为动作的ID，另外action对象里还可以携带其他数据信息，这要根据action所要完成的操作来定。&lt;/p&gt;
&lt;h3 id=&quot;reducer&quot;&gt;reducer&lt;/h3&gt;
&lt;p&gt;reducer是用来响应action来处理状态的，它会对每个分发的action进行操作，根据传过来的action和store里已有的sate值进行一些运算，然后返回新的state。&lt;/p&gt;
&lt;h3 id=&quot;actioncreator&quot;&gt;actionCreator&lt;/h3&gt;
&lt;p&gt;actionCreator是一个类似于工厂模式的生产工具，用于生产action。如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;const learnReduxActionFactory = book =&amp;gt; {
    type: 'READ_REDUX_BOOK',
    book
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;combinereducers&quot;&gt;combineReducers&lt;/h3&gt;
&lt;p&gt;combineReducers是Redux提供的一个工具函数，可以把多个拆分的reducer合并成一完整的reducer。&lt;br/&gt;例如在页面状态中存储三种数据状态，分别为data1、data2和data3, 它们是相互独立的。如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;state = {
    data1: {
        ...
    },
    data2: {
        ...
    },
    data3: {
        ...
    }
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同样我们把处理这三种数据状态的reducer函数也拆分成三个小的reducer,分别为reducer1、reducer2和reducer3。如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;const reducer1 = (previousState= {}, action) =&amp;gt; {
    // 根据action和state.data1计算产生新的state.data1
    return state.data1;
};
const reducer2 = (previousState= {}, action) =&amp;gt; {
    // 根据action和state.data2计算产生新的state.data2
    return state.data2;
}
const reducer3 = (previousState= {}, action) =&amp;gt; {
    // 根据action和state.data3计算产生新的state.data3
    return state.data3;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后利用combineReducer将这三个子reducer函数合并成一个完整的reducer并返回。如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;const { combineReducers } = Redux;
const finalReducer = combineReducers({
    data1: reducer1,
    data2: reducer2,
    data3: reducer3
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在ES6开发环境下，常用的做法是令子reducer函数名称和数据状态的命名保持一致，即将reducer1、reducer2、reducer3分别命名为data1、data2、data3。即：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;const finalReducer = combineReducers({
    data1: data1,
    data2: data2,
    data3: data3
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也可以简写为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;const finalReducer = combineReducers({data1, data2, data3});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;日常开发中，通常会将大的reducer拆分成多个小的reducer进行单独维护，这样的分治能提高维护效率。&lt;/p&gt;
&lt;h2 id=&quot;redux中间件&quot;&gt;redux中间件&lt;/h2&gt;
&lt;p&gt;redux中间件提供的是位于action被派发之后，到达reducer之前的扩展点，因此可以利用redux中间件来完成日志记录、调用异步接口或者路由等。redux中间件的作用主要有两个：&lt;br/&gt;1、截获action&lt;br/&gt;2、发出action&lt;br/&gt;redux中间件异步请求的工作流如下图所示：&lt;/p&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://slides.com/jenyaterpil/redux-from-twitter-hype-to-production#/23&quot; class=&quot;uri&quot;&gt;https://slides.com/jenyaterpil/redux-from-twitter-hype-to-production#/23&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://static.zybuluo.com/juewuly/meehjhsquzi2ko32j7sagx39/ARCH-Redux2-extended-real.gif&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;redux既可以作为发布订阅系统独立使用，也可以和react结合来管理react组件的状态。目前最常见的使用场景是与react结合，让react组件间通信更加容易。另外通过使用丰富的redux中间件，能扩展系统的特性。&lt;/p&gt;
</description>
<pubDate>Sun, 27 Jan 2019 14:20:00 +0000</pubDate>
<dc:creator>安乐最胜吉祥君</dc:creator>
<og:description>[TOC] 为何而写 以前没怎么写过技术类的文章，对于技术很多时候是现用现学，这样通常能解决遇到过的绝大多数问题，但也带来了一个弊端，那就是仅停留于解决问题的层面，而忽略了对技术背后的设计思想和设计理</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/anlewo/p/10328201.html</dc:identifier>
</item>
</channel>
</rss>