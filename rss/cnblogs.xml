<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Redis 主从复制（Replication） - buttercup</title>
<link>http://www.cnblogs.com/buttercup/p/14017314.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/buttercup/p/14017314.html</guid>
<description>&lt;p&gt;为了保证服务的可用性，现代数据库都提供了复制功能，同时在多个进程中维护一致的数据状态。&lt;br/&gt;Redis 支持一主多从的复制架构，该功能被简化成了一条 &lt;code&gt;SLAVEOF&lt;/code&gt; 命令，下面通过条命令来解析 Redis 的主从复制机制。&lt;/p&gt;

&lt;p&gt;在本机上通过 redis-server 启动两个服务，然后通过 tcpdump 观察主从间的交互情况：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;redis-server --port 6379 --requirepass 123456 # 启动 master
redis-server --port 6380 --masterauth 123456  # 启动 slave
tcpdump -t -i lo0 host localhost and port 6379 | awk -F ']' '{print $1&quot;]&quot;$3}'

# 在 localhost:6380 上执行 SLAVEOF localhost 6379 建立同步连接，进入 Full-ReSync 阶段
localhost.59297 &amp;gt; localhost.6379: Flags [S]
localhost.6379 &amp;gt; localhost.59297: Flags [S.]
localhost.59297 &amp;gt; localhost.6379: Flags [P.] &quot;PING&quot;
localhost.6379 &amp;gt; localhost.59297: Flags [P.] &quot;NOAUTH Authentication required.&quot;
localhost.59297 &amp;gt; localhost.6379: Flags [P.] &quot;AUTH 123456&quot;
localhost.6379 &amp;gt; localhost.59297: Flags [P.] &quot;OK&quot;
localhost.59297 &amp;gt; localhost.6379: Flags [P.] &quot;REPLCONF listening-port 6380&quot;
localhost.6379 &amp;gt; localhost.59297: Flags [P.] &quot;OK&quot;:
localhost.59297 &amp;gt; localhost.6379: Flags [P.] &quot;REPLCONF capa eof&quot;
localhost.6379 &amp;gt; localhost.59297: Flags [P.] &quot;OK&quot;:
localhost.59297 &amp;gt; localhost.6379: Flags [P.] &quot;PSYNC ? -1&quot;
localhost.6379 &amp;gt; localhost.59297: Flags [P.] &quot;FULLRESYNC 8efb6ca4edf1258c05a5ced43b0c73fe4deb1908 1&quot;
localhost.6379 &amp;gt; localhost.59297: Flags [P.] [|RESP:
localhost.6379 &amp;gt; localhost.59297: Flags [P.] &quot;REDIS0007M-z^Iredis-ver^F3.2.11M-z&quot; [|RESP

# 完成 Full-ReSync 后进入 Propagation 阶段
localhost.59297 &amp;gt; localhost.6379: Flags [P.] &quot;REPLCONF&quot; &quot;ACK&quot; &quot;1&quot;
localhost.59297 &amp;gt; localhost.6379: Flags [P.] &quot;REPLCONF&quot; &quot;ACK&quot; &quot;1&quot;
localhost.6379 &amp;gt; localhost.59297: Flags [P.] &quot;PING&quot;
localhost.59297 &amp;gt; localhost.6379: Flags [P.] &quot;REPLCONF&quot; &quot;ACK&quot; &quot;15&quot;
localhost.59297 &amp;gt; localhost.6379: Flags [P.] &quot;REPLCONF&quot; &quot;ACK&quot; &quot;15&quot;
localhost.6379 &amp;gt; localhost.59297: Flags [P.] &quot;SELECT&quot; &quot;0&quot; &quot;SET&quot; &quot;KEY&quot; &quot;VALUE&quot;
localhost.59297 &amp;gt; localhost.6379: Flags [P.] &quot;REPLCONF&quot; &quot;ACK&quot; &quot;85&quot;
localhost.59297 &amp;gt; localhost.6379: Flags [P.] &quot;REPLCONF&quot; &quot;ACK&quot; &quot;85&quot;
localhost.6379 &amp;gt; localhost.59297: Flags [P.] &quot;SET&quot; &quot;KEY2&quot; &quot;VALUE2&quot;
localhost.6379 &amp;gt; localhost.59297: Flags [P.] &quot;MSET&quot; &quot;KEY3&quot; &quot;VALUE3&quot; &quot;KEY4&quot; &quot;VALUE4&quot; &quot;KEY5&quot; &quot;VALUE5&quot;
localhost.59297 &amp;gt; localhost.6379: Flags [P.] &quot;REPLCONF&quot; &quot;ACK&quot; &quot;256&quot;
localhost.59297 &amp;gt; localhost.6379: Flags [P.] &quot;REPLCONF&quot; &quot;ACK&quot; &quot;256&quot;
localhost.6379 &amp;gt; localhost.59297: Flags [P.] &quot;PING&quot;
localhost.59297 &amp;gt; localhost.6379: Flags [P.] &quot;REPLCONF&quot; &quot;ACK&quot; &quot;270&quot;
localhost.59297 &amp;gt; localhost.6379: Flags [P.] &quot;REPLCONF&quot; &quot;ACK&quot; &quot;270&quot;

# 在 localhost:6380 上执行 DEBUG SLEEP 60 模拟网络中断的情况
localhost.6379 &amp;gt; localhost.59297: Flags [P.] &quot;PING&quot;
localhost.6379 &amp;gt; localhost.59297: Flags [P.] &quot;SET&quot; &quot;KEY6&quot; &quot;VALUE6&quot;
localhost.6379 &amp;gt; localhost.59297: Flags [P.] &quot;SET&quot; &quot;KEY7&quot; &quot;VALUE7&quot;
localhost.6379 &amp;gt; localhost.59297: Flags [P.] &quot;PING&quot;
localhost.6379 &amp;gt; localhost.59297: Flags [P.] &quot;MSET&quot; &quot;KEY8&quot; &quot;VALUE8&quot; &quot;KEY9&quot; &quot;VALUE9&quot;
localhost.6379 &amp;gt; localhost.59297: Flags [P.] &quot;PING&quot;
localhost.6379 &amp;gt; localhost.59297: Flags [P.] &quot;PING&quot;
localhost.59297 &amp;gt; localhost.6379: Flags [.]
localhost.59297 &amp;gt; localhost.6379: Flags [R.]

# 旧的同步连接断开后重新建立同步连接，进入 Partical-ReSync 阶段
localhost.59313 &amp;gt; localhost.6379: Flags [S]
localhost.6379 &amp;gt; localhost.59313: Flags [S.]
localhost.59313 &amp;gt; localhost.6379: Flags [P.] &quot;PING&quot;
localhost.6379 &amp;gt; localhost.59313: Flags [P.] &quot;NOAUTH Authentication required.&quot;
localhost.59313 &amp;gt; localhost.6379: Flags [P.] &quot;AUTH 123456&quot;
localhost.6379 &amp;gt; localhost.59313: Flags [P.] &quot;OK&quot;
localhost.59313 &amp;gt; localhost.6379: Flags [P.] &quot;REPLCONF listening-port 6380&quot;
localhost.6379 &amp;gt; localhost.59313: Flags [P.] &quot;OK&quot;
localhost.59313 &amp;gt; localhost.6379: Flags [P.] &quot;REPLCONF capa eof&quot;
localhost.6379 &amp;gt; localhost.59313: Flags [P.] &quot;OK&quot;
localhost.59313 &amp;gt; localhost.6379: Flags [P.] &quot;PSYNC 8efb6ca4edf1258c05a5ced43b0c73fe4deb1908 271&quot;
localhost.6379 &amp;gt; localhost.59313: Flags [P.] &quot;CONTINUE&quot;
localhost.6379 &amp;gt; localhost.59313: Flags [P.] &quot;PING&quot; &quot;PING&quot; &quot;SET&quot; &quot;KEY6&quot; &quot;VALUE6&quot; &quot;PING&quot; &quot;SET&quot; &quot;KEY7&quot; &quot;VALUE7&quot; &quot;PING&quot; &quot;MSET&quot; &quot;KEY8&quot; &quot;VALUE8&quot; &quot;KEY9&quot; &quot;VALUE9&quot; &quot;PING&quot; &quot;PING&quot;
localhost.59313 &amp;gt; localhost.6379: Flags [P.] &quot;REPLCONF&quot; &quot;ACK&quot; &quot;519&quot;
localhost.59313 &amp;gt; localhost.6379: Flags [P.] &quot;REPLCONF&quot; &quot;ACK&quot; &quot;519&quot;
localhost.6379 &amp;gt; localhost.59313: Flags [P.] &quot;PING&quot;
localhost.59313 &amp;gt; localhost.6379: Flags [P.]: &quot;REPLCONF&quot; &quot;ACK&quot; &quot;533&quot;
localhost.59313 &amp;gt; localhost.6379: Flags [P.]: &quot;REPLCONF&quot; &quot;ACK&quot; &quot;533&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;整个过程可以分为 &lt;code&gt;Full-ReSync&lt;/code&gt;, &lt;code&gt;Command-Propagate&lt;/code&gt;, &lt;code&gt;Partical-ReSync&lt;/code&gt; 总共 3 阶段：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-text&quot;&gt;             +----------------------+                +---------------------+
             | redisServer (master) |                | redisServer (slave) |
             |    localhost:6379    |                |    localhost:6380   |
             +----------------------+                +---------------------+ 
             |        slaves        |                |        master       | 
             +----------------------+                +---------------------+ 
                        |                                       |
                 +----------------+                      +-------------+
                 | redisClient[?] |                      | redisClient |  
                 +----------------+                      +-------------+
                                                                |
       ^                &amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; PING &amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;                
       |                |                                               Step 1 : 检查套接字与 master 状态
       |                &amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; PONG / NOAUTH &amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;                
       |                                                        |                
       |                &amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; AUTH &amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;                
       |                |                                               Step 2 : 身份验证
       |                &amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; OK &amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;                
       |                                                        |                
       |                &amp;lt;&amp;lt;&amp;lt;&amp;lt; REPLCONF listening-port [port] &amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;                
       |                |                                               Step 3 : 发送 slave 端口 
   Full-ReSync          &amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; OK &amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;           
       |                                                        |                
       |                &amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; REPLCONF capa [eof|psync2] &amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;                
       |                |                                               Step 4 : 检查命令兼容性
       |                &amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; OK &amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;                
       |                                                        |                
       |                &amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; PSYNC ? -1 &amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;                
       |                |                                                        
       |                &amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; FULLRESYNC [replid] [offset] &amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;       Step 6 : 执行全量同步
       |                V                                                        
       |              BGSAVE                                                     
       |                V                                                        
       v                &amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; RDB Snapshot &amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;                


       ^                &amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; REPLCONF ACK [offset] &amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;               
       |                &amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; COMMAND 1 &amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;                
       |                &amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; COMMAND 2 &amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;                
       |                &amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; REPLCONF ACK [offset+?] &amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;       心跳检测 &amp;amp; 命令传播         
Command-Propagate       &amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; PING &amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;          
       |                &amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; COMMAND 3 &amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;                
       |                &amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; REPLCONF ACK [offset+?] &amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;                
       |                &amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; REPLCONF ACK [offset+?] &amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;                
       v                &amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; PING &amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;                


       ^                =========================================                
       |                ====== The Same With Full-ReSync ========                
       |                =========================================                
       |                                                        |                
  Partical-ReSync       &amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; PSYNC [replid] [offset] &amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;       重连后执行部分同步
       |                |                                                        
       |                &amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; CONTINUE &amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;                
       |                &amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; COMMAND N &amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;                
       v                &amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; COMMAND ... &amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;                
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;最初 Redis 用于同步的命令是&lt;code&gt;SYNC&lt;/code&gt;，每次重连执行该命令时都会生成、传输、加载整个完整的 RDB 快照，严重占用机器资源与网络带宽。为了解决这一问题，后续版本的 Redis 追加了&lt;code&gt;PSYNC&lt;/code&gt;命令，该命令支持以下两种同步模式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;全量重新同步&lt;code&gt;Full-ReSync&lt;/code&gt;&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;slave 首次连接 master&lt;/li&gt;
&lt;li&gt;master 与 slave 之间的状态差异过大&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;部分重新同步&lt;code&gt;Partical-ReSync&lt;/code&gt;&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;网络抖动导致同步连接断开重连&lt;/li&gt;
&lt;li&gt;sentinel 机制导致 master 节点发生变更&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;数据结构&quot;&gt;数据结构&lt;/h2&gt;
&lt;p&gt;下面看看 redisServer 中与&lt;code&gt;PSYNC&lt;/code&gt;相关的数据结构：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;struct redisServer {
    /*
     *  节点ID 与 复制偏移量
     *
     *     若当前节点是 master
     *     server.replid 就是 server.runid
     *
     *     若当前节点原本是 master，转化为 slave 节点后
     *     server.replid 与 server.master_repl_offset 会被新 master 的同步信息覆盖
     *
     *     若当前节点原本是 slave，被提升为 master 节点后
     *     rserver.eplid2 与 server.second_replid_offset 会记录当前节点作为 slave 时的同步信息
     */
    char runid[CONFIG_RUN_ID_SIZE+1];   /* 当前节点的运行时ID（每次重启都会发生变化） */
    char replid[CONFIG_RUN_ID_SIZE+1];  /* 当前 master 节点的 runid */
    char replid2[CONFIG_RUN_ID_SIZE+1]; /* 当前 master 节点作为 slave 节点时连接的 master 的 runid */
    long long master_repl_offset;   /* 当前 master 节点的复制偏移量 */
    long long second_replid_offset; /* 当前 master 节点作为 slave 节点时的同步偏移量 */

    /*
     * 复制积压缓冲
     *
     *     master 只维护一个全局的 server.repl_backlog，由所有 slave 节点共享 
     *     为了减少内存占用，server.repl_backlog 仅在 slave 节点存在时按需创建
     */
    char *repl_backlog;             /* 复制积压缓冲（环形缓冲）*/
    long long repl_backlog_size;    /* 积压缓冲大小 */
    long long repl_backlog_histlen; /* 积压数据长度 */
    long long repl_backlog_idx;     /* 积压缓冲尾部（可写位置）*/
    long long repl_backlog_off;     /* 积压缓冲首字节对应的同步偏移量（master offset）*/
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;运行id&quot;&gt;&lt;strong&gt;运行ID&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;　无论主从，每个 Redis 服务器会在启动时生成一个长度为 40 的十六进制字符串作为运行ID&lt;code&gt;runid&lt;/code&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当 slave 首次请求同步时，会将 master 返回的&lt;code&gt;server.runid&lt;/code&gt;保存至&lt;code&gt;server.replid&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;当 slave 重新请求同步时，会将之前保存的&lt;code&gt;server.replid&lt;/code&gt;发送给 master：
&lt;ul&gt;&lt;li&gt;如果该 ID 与当前 master 的&lt;code&gt;server.runid&lt;/code&gt;不一致，则必须执行一次全量重新同步&lt;/li&gt;
&lt;li&gt;如果该 ID 与当前 master 的&lt;code&gt;server.runid&lt;/code&gt;一致，则可以尝试执行部分同步操作&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;复制偏移量&quot;&gt;&lt;strong&gt;复制偏移量&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;　主从双方都会维护一个单位为字节的复制偏移量&lt;code&gt;offset&lt;/code&gt;，通过该偏移量可以判断主从间的状态是否一致：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;master 向 slave 传播 N 字节数据后，会将自己的复制偏移量增加 N&lt;/li&gt;
&lt;li&gt;slave 接收到 master 传来的 N 个字节数据时，会将自己的复制偏移量增加 N&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　当 master 接收到 &lt;code&gt;REPLCONF ACK&lt;/code&gt; 中的偏移量时，可以据此判断发送给 slave 的数据是否发生了丢失，并重发丢失的数据。&lt;/p&gt;
&lt;h4 id=&quot;积压缓冲&quot;&gt;&lt;strong&gt;积压缓冲&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;　master 端维护了一个定长的积压缓冲队列&lt;code&gt;backlog&lt;/code&gt;。&lt;br/&gt;　master 向 slave 传播命令时会同时将命令放入该队列，因此缓冲区里会保留一部分最新的命令。&lt;br/&gt;　slave 发出同步请求时，如果 slave 的偏移量之后 &lt;strong&gt;(offset+1)&lt;/strong&gt; 的数据存在于积压缓冲，master 才会执行部分同步。&lt;/p&gt;

&lt;h2 id=&quot;slave-视角&quot;&gt;SLAVE 视角&lt;/h2&gt;
&lt;p&gt;slave 接收到&lt;code&gt;SLAVEOF&lt;/code&gt;命令后，会调用&lt;code&gt;replicaofCommand&lt;/code&gt;开始执行主从同步：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;void replicaofCommand(client *c) {
    // ...

    if (!strcasecmp(c-&amp;gt;argv[1]-&amp;gt;ptr,&quot;no&quot;) &amp;amp;&amp;amp;
        !strcasecmp(c-&amp;gt;argv[2]-&amp;gt;ptr,&quot;one&quot;)) {
        if (server.masterhost) { // 如果接收到的命令是 SLAVE NO ONE 则断开主从同步
            // ...
        }
    } else { 
        if (c-&amp;gt;flags &amp;amp; CLIENT_SLAVE) {
            return; // 如果已经是客户端是一个 slave 节点，则拒绝该命令
        }

        if (server.masterhost &amp;amp;&amp;amp; !strcasecmp(server.masterhost,c-&amp;gt;argv[1]-&amp;gt;ptr) &amp;amp;&amp;amp; server.masterport == port) {
            return; // 如果已经连接上 SLAVEOF 中指定的 master 节点，则直接返回
        }

        // 如果尚未连接任意 master 节点，则根据 masterhost 与 masterport 建立 TCP 连接
        // 并注册监听函数 syncWithMaster
    }
}

void syncWithMaster(connection *conn) {
    // 向 master 节点发送 PING 命令
    if (server.repl_state == REPL_STATE_CONNECTING) {
        server.repl_state = REPL_STATE_RECEIVE_PONG;
        err = sendSynchronousCommand(SYNC_CMD_WRITE,conn,&quot;PING&quot;,NULL); // 发送 PING 命令
        // ...
    }

    // 监听到 master 对 PING 命令的响应
    if (server.repl_state == REPL_STATE_RECEIVE_PONG) {
        if (err[0] != '+' &amp;amp;&amp;amp;
            strncmp(err,&quot;-NOAUTH&quot;,7) != 0 &amp;amp;&amp;amp;
            strncmp(err,&quot;-NOPERM&quot;,7) != 0 &amp;amp;&amp;amp;
            strncmp(err,&quot;-ERR operation not permitted&quot;,28) != 0)
        {
            goto error;
        }
        server.repl_state = REPL_STATE_SEND_AUTH; // 只处理 master 响应值为 PONG、NOAUTH、NOPERM 的情况
    }

    // 根据 master 对 PING 的响应值，判断是否需要授权
    if (server.repl_state == REPL_STATE_SEND_AUTH) {
        if (server.masteruser &amp;amp;&amp;amp; server.masterauth) {
            err = sendSynchronousCommand(SYNC_CMD_WRITE,conn,&quot;AUTH&quot;,
                                         server.masteruser,server.masterauth,NULL); // 发送 AUTH 命令
            // ...
            server.repl_state = REPL_STATE_RECEIVE_AUTH;
        } else {
            // 如果没有设置 server.masteruser 与 server.masterauth 授权信息，则跳过 AUTH
            server.repl_state = REPL_STATE_SEND_PORT;
        }
    }

    // 此处略过以下步骤：
    // 使用 REPLCONF listening-port 命令将 slave 的端口告知 master
    // 使用 REPLCONF ip-address 命令将 slave 的 IP 告知 master
    // 使用 REPLCONF capa eof / capa psync2 命令将 slave 兼容性（支持的特性）告知 master

     // 开始发送 PSYNC 命令
    if (server.repl_state == REPL_STATE_SEND_PSYNC) {
        if (slaveTryPartialResynchronization(conn,0) == PSYNC_WRITE_ERROR) {
            goto write_error;
        }
        server.repl_state = REPL_STATE_RECEIVE_PSYNC;
        return;
    }

    // 读取 PSYNC 命令的响应
    psync_result = slaveTryPartialResynchronization(conn,1);

    // 如果监听到 CONTINUE 响应，跳过全量同步
    if (psync_result == PSYNC_CONTINUE) return;

    // 如果返回值为 PSYNC_FULLRESYNC 或 PSYNC_NOT_SUPPORTED
    // 开始执行执行全量同步，注册 readSyncBulkPayload 监听 RDB 文件下载
    if (connSetReadHandler(conn, readSyncBulkPayload) == C_ERR) {
        // ...
        goto error;
    }

    server.repl_state = REPL_STATE_TRANSFER;

    // ...
}

int slaveTryPartialResynchronization(connection *conn, int read_reply) {
    if (!read_reply) {
        if (server.cached_master) { // server.cached_master 中存在记录，尝试执行部分同步
            psync_replid = server.cached_master-&amp;gt;replid;
        } else {
            psync_replid = &quot;?&quot;; // server.cached_master 中不存在记录，只能执行全量同步
        }
        // 发起 PSYNC 命令
        reply = sendSynchronousCommand(SYNC_CMD_WRITE,conn,&quot;PSYNC&quot;,psync_replid,psync_offset,NULL);
        // ...
        return PSYNC_WAIT_REPLY;
    }

    reply = sendSynchronousCommand(SYNC_CMD_READ,conn,NULL); // 读取 PSYNC 响应

    // 如果 master 响应 FULLRESYNC 则直接进行全量同步
    if (!strncmp(reply,&quot;+FULLRESYNC&quot;,11)) {
        // ...
        return PSYNC_FULLRESYNC;
    }

    // 如果 master 响应 CONTINUE 则尝试执行部分同步
    if (!strncmp(reply,&quot;+CONTINUE&quot;,9)) {
        // ...
        return PSYNC_CONTINUE;
    }

    // master 暂时无法处理 PSYNC 命令 —&amp;gt; PSYNC_TRY_LATER
    // master 不支持 PSYNC 命令 -&amp;gt; PSYNC_NOT_SUPPORTED
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;master-视角&quot;&gt;MASTER 视角&lt;/h2&gt;
&lt;p&gt;master 接收到&lt;code&gt;PSYNC&lt;/code&gt;命令后，会调用&lt;code&gt;syncCommand&lt;/code&gt;开启同步流程：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;void syncCommand(client *c) {
    // 接收到 slave 发送的 PSYNC 命令
    if (!strcasecmp(c-&amp;gt;argv[0]-&amp;gt;ptr,&quot;psync&quot;)) {
        if (masterTryPartialResynchronization(c) == C_OK) {
            return; // 无需全量同步，直接返回
        }
    }

    // 若代码运行至此处，意味着部分同步失败，需要执行全量同步
    // master 会执行 BGSAVE 命令生成快照并传输给 slave
    // 同步 RDB 快照的方式有两种：
    //     基于磁盘(Disk-backed)：在磁盘生成 RDB 快照文件，然后再传输给 slave
    //     无盘(Diskless)：直接将 RDB 快照数据写入 slave socket

}

int masterTryPartialResynchronization(client *c) {
    long long psync_offset; // 该 slave 最新的同步偏移量
    char *master_replid;    // slave 同步偏移量对应的 master 的 runid

    /*
     *  以下情况可以避免全量同步：
     *  1. slave 最近一次同步的 master 是当前实例（网络抖动）
     *  2. slave 与当前节点原本是同个 master 的从节点，且当前节点的同步偏移量 second_replid_offset 较大（维护重启、故障切换）*/

    if (strcasecmp(master_replid, server.replid) &amp;amp;&amp;amp;
       (strcasecmp(master_replid, server.replid2) ||psync_offset &amp;gt; server.second_replid_offset))
    {
        goto need_full_resync; // 不满足 PSYNC 条件，需要执行全量同步
    }

    /*
     *  以下情况只能执行全量同步：
     *  1. master 没有初始化积压缓冲 
     *  2. slave 的同步偏移量落后于积压缓冲 */
    if (!server.repl_backlog || 
        psync_offset &amp;lt; server.repl_backlog_off ||
        psync_offset &amp;gt; (server.repl_backlog_off + server.repl_backlog_histlen))
    {
        goto need_full_resync; // 进行全量同步
    }

    // 若代码运行至此处，意味着可以执行部分同步
    listAddNodeTail(server.slaves,c);

    // 根据客户端是否兼容 PSYNC2，返回不同的 CONTINUE 响应
    if (c-&amp;gt;slave_capa &amp;amp; SLAVE_CAPA_PSYNC2) {
        buflen = snprintf(buf,sizeof(buf),&quot;+CONTINUE %s\r\n&quot;, server.replid);
    } else {
        buflen = snprintf(buf,sizeof(buf),&quot;+CONTINUE\r\n&quot;);
    }

    // CONTINUE 命令后面，紧接着就是 server.repl_backlog 的内容
    psync_len = addReplyReplicationBacklog(c,psync_offset);

    // ...

}
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;Redis 每秒会执行一次定时任务&lt;code&gt;replicationCron&lt;/code&gt;，其中就包含主从同步间的心跳，可以发现主从双方的心跳频率是不一致的：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;void replicationCron(void) {

    // slave 定时向 master 发送 REPLCONF ACK 命令
    if (server.masterhost &amp;amp;&amp;amp; server.master &amp;amp;&amp;amp;
        !(server.master-&amp;gt;flags &amp;amp; CLIENT_PRE_PSYNC)) {
        addReplyArrayLen(c,3);
        addReplyBulkCString(c,&quot;REPLCONF&quot;);
        addReplyBulkCString(c,&quot;ACK&quot;);
        addReplyBulkLongLong(c,c-&amp;gt;reploff);
    }

    // master 定时向 slave 发送 PING 命令
    if ((replication_cron_loops % server.repl_ping_slave_period) == 0 &amp;amp;&amp;amp;
        listLength(server.slaves))
    {
        robj *ping_argv[1];
        ping_argv[0] = createStringObject(&quot;PING&quot;,4);
        replicationFeedSlaves(server.slaves, server.slaveseldb, ping_argv, 1);
        decrRefCount(ping_argv[0]);
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;master 在调用&lt;code&gt;call&lt;/code&gt;函数执行客户端传过来的命令时，会将命令传播给 slave 并同时写入积压缓冲：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;void call(client *c, int flags) {
    // ...
    if (flags &amp;amp; CMD_CALL_PROPAGATE &amp;amp;&amp;amp; (c-&amp;gt;flags &amp;amp; CLIENT_PREVENT_PROP) != CLIENT_PREVENT_PROP)
    {
        // 当前命令是否需要传播
        if (propagate_flags != PROPAGATE_NONE &amp;amp;&amp;amp; !(c-&amp;gt;cmd-&amp;gt;flags &amp;amp; CMD_MODULE))
            propagate(c-&amp;gt;cmd,c-&amp;gt;db-&amp;gt;id,c-&amp;gt;argv,c-&amp;gt;argc,propagate_flags);
    }
}

void propagate(struct redisCommand *cmd, int dbid, robj **argv, int argc,
               int flags)
{
    // ...
    if (flags &amp;amp; PROPAGATE_REPL)
        replicationFeedSlaves(server.slaves,dbid,argv,argc);
}

void replicationFeedSlaves(list *slaves, int dictid, robj **argv, int argc) {

    // 如果当前节点没有 slave 节点或复制积压缓冲，立即返回
    if (server.repl_backlog == NULL &amp;amp;&amp;amp; listLength(slaves) == 0) return;

    // 向 repl_backlog 中批量写入命令
    if (server.repl_backlog) {
        char aux[LONG_STR_SIZE+3]; // 命令缓冲，用于序列化 redis 命令

        /* 写入当前批次的命令数量 */
        aux[0] = '*';
        len = ll2string(aux+1,sizeof(aux)-1,argc);
        aux[len+1] = '\r';
        aux[len+2] = '\n';
        feedReplicationBacklog(aux,len+3);

        /* 逐个遍历命令，将其序列化后写入 repl_backlog */
        for (j = 0; j &amp;lt; argc; j++) {
            long objlen = stringObjectLen(argv[j]);
            
            aux[0] = '$';
            len = ll2string(aux+1,sizeof(aux)-1,objlen);
            aux[len+1] = '\r';
            aux[len+2] = '\n';
            feedReplicationBacklog(aux,len+3);
            feedReplicationBacklogWithObject(argv[j]);
            feedReplicationBacklog(aux+len+1,2);
        }
    }

    // 将命令批量传播给所有 slaves 对应的 client
    listRewind(slaves,&amp;amp;li);
    while((ln = listNext(&amp;amp;li))) {
        client *slave = ln-&amp;gt;value;

        /* 写入当前批次的命令数量 */
        addReplyArrayLen(slave,argc);

        /* 逐个遍历命令，将传播给 slave 节点 */
        for (j = 0; j &amp;lt; argc; j++)
            addReplyBulk(slave,argv[j]);
    }
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;h3 id=&quot;slave-serve-stale-data&quot;&gt;slave-serve-stale-data&lt;/h3&gt;
&lt;p&gt;　主从节点断开时或同步未完成时，slave 如何响应客户端请求&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;yes&lt;/strong&gt;：正常响应命令，但是不保证数据质量&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;no&lt;/strong&gt;：拒绝响应命令，返回 &lt;strong&gt;SYNC with master in progress&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;repl-diskless-sync&quot;&gt;repl-diskless-sync&lt;/h3&gt;
&lt;p&gt;　执行全量同步时，master 如何将 RDB 快照传输给 slave&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;no&lt;/strong&gt;：先在磁盘生成 RDB 文件再进行传输（低带宽网络）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;yes&lt;/strong&gt;：直接将 RDB 快照写入 slave 的 socket（低速磁盘 + 高带宽网络）&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;repl-ping-slave-period&quot;&gt;repl-ping-slave-period&lt;/h3&gt;
&lt;p&gt;　master 向 slave 发送 &lt;code&gt;PING&lt;/code&gt; 心跳的间隔，默认 10s 发送一次&lt;/p&gt;
&lt;h3 id=&quot;repl-backlog-size&quot;&gt;repl-backlog-size&lt;/h3&gt;
&lt;p&gt;　同步积压缓冲的空间，默认值大小为 1mb。&lt;br/&gt;　由于主从连接断开后，所有的命令都会积压在这里，如果该值太小会导致 &lt;code&gt;PSYNC&lt;/code&gt; 命令会无法执行部分同步。&lt;br/&gt;　如果 master 需要执行大量写命令，或者 slave 需要较长时间才能重连成功，则需要根据实际情况进行估算。&lt;/p&gt;
&lt;h3 id=&quot;min-slaves-to-write--min-slaves-max-lag&quot;&gt;min-slaves-to-write &amp;amp; min-slaves-max-lag&lt;/h3&gt;
&lt;p&gt;　则当不满足下列条件时，master 会拒绝写命令直至恢复：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;连接当前 master 的 slave 数量大于等于 &lt;strong&gt;min-slaves-to-write&lt;/strong&gt; 个节点连接正常&lt;/li&gt;
&lt;li&gt;连接正常的 slave 节点中不少于 &lt;strong&gt;min-slaves-to-write&lt;/strong&gt; 个节点的延迟时间小于 *&lt;strong&gt;min-slaves-max-lag&lt;/strong&gt; 秒&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　启用这两个选项后，写命令大概率能够被复制到 &lt;strong&gt;min-slaves-to-write&lt;/strong&gt; 个从节点中，减少了命令丢失的概率。&lt;/p&gt;&lt;p&gt;至此，对 redis 的主从同步分析完毕，后续将对 redis 的一些其他细节进行分享，感谢观看。&lt;/p&gt;
</description>
<pubDate>Thu, 11 Feb 2021 17:33:00 +0000</pubDate>
<dc:creator>buttercup</dc:creator>
<og:description>为了保证服务的可用性，现代数据库都提供了复制功能，同时在多个进程中维护一致的数据状态。 Redis 支持一主多从的复制架构，该功能被简化成了一条 SLAVEOF 命令，下面通过条命令来解析 Redis</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/buttercup/p/14017314.html</dc:identifier>
</item>
<item>
<title>浅谈浏览器实时构建 - 格子熊</title>
<link>http://www.cnblogs.com/karthuslorin/p/14398400.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/karthuslorin/p/14398400.html</guid>
<description>&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;在遥远的几个月前，还在上家公司的时候，老板突发奇想，想要搞个代码片段平台，类似于 &lt;a href=&quot;https://snipit.io/&quot; target=&quot;_blank&quot;&gt;snipit&lt;/a&gt;，实现代码片段的复用。本身这个需求并不难实现——简单的前端界面 + 简单的 node CURD，搞定收工，下班回家。&lt;/p&gt;
&lt;p&gt;但是，在实际使用中，发现了一个使用痛点——没有在线调试功能，所有代码只能 copy 到本地，在本地进行调试。本着发现痛点就要解决痛点的指导思想，我当时思考了一段时间，希望寻找一个合适的解决方案来完美的解决这个痛点。总体来说，分为两种方案：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;服务端构建方案：最常见也是最成熟的解决方案，每次修改代码时，将代码传给服务端，由服务端构建后，最终进行代码替换。由于是在服务端进行打包，所以被称为服务端构建方案。在前几年，客户端涉及到构建问题一般采用服务端构建方案。&lt;/li&gt;
&lt;li&gt;浏览器实时构建方案：当前前端最热门的方向之一，在浏览器端进行代码构建，基本不需要与服务端交互（具体分不同细分方案），所以被称为浏览器实时构建。目前各个大厂的 Web IDE 基本采用这种方案。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;相比于服务端构建方案，浏览器实时构建方案的优势在于：即时、高效以及最宝贵的——可离线运行（前提是做了合适的缓存方案）。&lt;/p&gt;
&lt;p&gt;最终，出于各种因素，最终我选择了浏览器实时构建方案。&lt;/p&gt;
&lt;h3 id=&quot;浏览器实时构建方案&quot;&gt;浏览器实时构建方案&lt;/h3&gt;
&lt;p&gt;浏览器实时构建是最近两年前端的热门方向，所以也涌现了一大批成熟的解决方案。&lt;/p&gt;
&lt;p&gt;个人总结为：bundle 方案以及 unbundle 方案两种。&lt;/p&gt;
&lt;h4 id=&quot;bundle-方案（类-codesandbox-方案）&quot;&gt;bundle 方案（类 CodeSandBox 方案）&lt;/h4&gt;
&lt;p&gt;大部分投入生产环境的浏览器实时构建方案都采用了该方案，该方案基本采用了 &lt;a href=&quot;https://github.com/codesandbox/codesandbox-client&quot; target=&quot;_blank&quot;&gt;codesandbox-client&lt;/a&gt; 的方案，所以我一般称之为类 CodeSandBox 方案。&lt;/p&gt;
&lt;p&gt;bundle 方案的核心在于在浏览器上实现一个打包工具，如 webpack，配合 indexDB 进行本地文件存储。当然，不仅仅是这么简单，由于在浏览器端做构建工作效率相对较低，所以需要大量的性能优化，比如 CodeSandBox 在浏览器端实现了一个线程池，当进行构建时，从线程池中取出线程，从而实现多线程打包。&lt;/p&gt;
&lt;p&gt;总的来说，bundle 方案依然没有跳出构建的思路，当项目较为复杂时，依然会出现构建工具遇到的那个问题——慢。针对 bundle 方案的缺点，业界推出了 unbundle 方案（当然最主要还得感谢浏览器的支持）。&lt;/p&gt;
&lt;h4 id=&quot;unbundle方案&quot;&gt;unbundle方案&lt;/h4&gt;
&lt;p&gt;unbundle 方案的出现，需要感谢 ESM。啥是 ESM 呢？ESM 全称为 ECMAScript modules，即浏览器原生支持模块化规范。效果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;script type=&quot;module&quot;&amp;gt;
  // 引用别的模块
  import { util } from './utils.js';
        // 使用别的模块中的函数
  util()
&amp;lt;/script&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当浏览器解析到 &lt;code&gt;import&lt;/code&gt; 语句时，会像开发态一样自动引入对应模块。得益于 ESM，我们可以不经过构建即可直接在浏览器端运行模块化代码。&lt;/p&gt;
&lt;p&gt;相比于 bundle 方案，unbundle 方案在各种意义上都快了许多，特别当项目复杂度上来以后，这个差异将会异常明显；另一方面，unbundle 不需要在浏览器端实现一个打包工具，对于快速实现浏览器实时构建也有着很大的意义。&lt;/p&gt;
&lt;p&gt;由于 unbundle 的各种优点，最终我选择了使用 unbundle 方案来实现浏览器实时构建。&lt;/p&gt;
&lt;h3 id=&quot;实现一个单文件浏览器实时构建&quot;&gt;实现一个单文件浏览器实时构建&lt;/h3&gt;
&lt;p&gt;接下来，到了实战环节，我们来尝试实现一个单文件浏览器实时构建。&lt;/p&gt;
&lt;p&gt;该系统分为两部分：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;客户端（浏览器实时构建）&lt;/li&gt;
&lt;li&gt;服务端（依赖服务器）&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;客户端&quot;&gt;客户端&lt;/h4&gt;
&lt;p&gt;首先是 UI 部分，UI 简单的分成三部分：代码编辑器（如：monaco editor），按钮（用于执行实时构建函数）以及构建结果展示部分，主要负责调试代码并展示结果。&lt;/p&gt;
&lt;p&gt;当点击按钮后，触发构建函数，开始执行构建逻辑，整个构建流程主要分为以下几步：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;将 Vue 文件拆分成 template、script 以及 style&lt;/li&gt;
&lt;li&gt;对 script 进行处理
&lt;ul&gt;&lt;li&gt;初始化 es-module-lexer，解析出所有导入语句（import）&lt;/li&gt;
&lt;li&gt;重写 import，将请求地址指向依赖服务器&lt;/li&gt;
&lt;li&gt;开始生成最终在浏览器中执行的代码，将重写后的 script 写入&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;解析模板，生成 render 函数，将 render 函数挂载到 script 上&lt;/li&gt;
&lt;li&gt;解析 style，更新样式有两种方案
&lt;/li&gt;
&lt;li&gt;最终，新建一个 script，去除原有的 script，插入最新的 script&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;总体思路其实和 vite 非常像，也可以认为是在浏览器端实现了一个小 vite。详细的代码可以参考 vite 源码，在此不再赘述。&lt;/p&gt;
&lt;h4 id=&quot;服务端&quot;&gt;服务端&lt;/h4&gt;
&lt;p&gt;服务端的功能非常简单，即接收请求，返回对应的依赖打包文件。由于 ESM 只支持 ESM 规范，所以，需要将各种模块规范（主要指的是 commonjs）统一转为 ESM。&lt;/p&gt;
&lt;p&gt;当依赖服务器接收到客户端的请求时，具体工作流程如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;服务端安装依赖&lt;/li&gt;
&lt;li&gt;通过 es-build 将依赖转为 esm&lt;/li&gt;
&lt;li&gt;将依赖返回给客户端&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;未来的路&quot;&gt;未来的路&lt;/h3&gt;
&lt;p&gt;通过上面的思路，我们就可以实现一个最简单的单文件浏览器实时构建了，但是其实有非常多的问题，比如：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;如何进行依赖版本控制？&lt;/li&gt;
&lt;li&gt;sourceMap 的问题怎么解决？&lt;/li&gt;
&lt;li&gt;服务端可以继续优化吗？&lt;/li&gt;
&lt;li&gt;可以纯浏览器实时构建（即没有服务端）吗？&lt;/li&gt;
&lt;li&gt;如何实现多文件浏览器实时构建？&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;本来我很想直接来一句：这些问题留作课后思考[doge]，但是怕被打，所以接下来就聊下我对这几个问题的看法吧。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;用户可以采用注释标注版本，解析时，使用正则或 babel 解析即可，思路类似于 magic comments&lt;/li&gt;
&lt;li&gt;多次映射即可解决&lt;/li&gt;
&lt;li&gt;依赖服务器优化的主要思路可以放在缓存管理上，试想，如果不做缓存处理，每次用户请求都需要重新下载、转换、打包依赖，当用户量增大时，服务器的压力该有多大？&lt;/li&gt;
&lt;li&gt;依赖请求使用 unpkg，不过，这个相当于从个人写的依赖服务器转换到了公司提供的 unpkg 服务器，只不过理论上确实不用自己写依赖服务器了[doge]。&lt;/li&gt;
&lt;li&gt;如果能够实现多文件浏览器实时构建，可以解决非常多单文件浏览器构建实现的问题，最直接的就是可以解决依赖版本问题。多文件浏览器实时构建复杂度相对于单文件浏览器实时构建高了不止一个数量级，所以这个问题我思考了非常久。最常见的方案就是之前说过的，CodeSandBox 方案，但是复杂度实在太高。所以要想降低复杂度，还需要使用 unbundle 方案。经过思考，我采用了 service worker，service worker 可以拦截所有请求，拦截后，判断是否请求的是本地文件，如果是本地文件，发消息给本地，如果是第三方依赖，请求依赖服务器。但是 service worker 有个致命的问题，第一次请求不能拦截，只有第二次之后的请求才能拦截（毕竟 service worker 本质是个缓存）。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;以上就是我的思路，如果大佬们有不同的思路，欢迎一起探讨。&lt;/p&gt;
&lt;h3 id=&quot;最后&quot;&gt;最后&lt;/h3&gt;
&lt;p&gt;按照惯例，发个招聘帖：&lt;/p&gt;
&lt;p&gt;字节跳动招人啦，HC 巨多，北上广深杭皆有坑位。&lt;/p&gt;
&lt;p&gt;团队详情见：&lt;a href=&quot;https://webinfra.org/about&quot; target=&quot;_blank&quot;&gt;https://webinfra.org/about&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;提供内推及面试辅导服务，目前我内推的几个同学皆通过了面试，欢迎咨询~&lt;/p&gt;
&lt;p&gt;暂时不看机会，之后有想法来字节试试的同学，也一样欢迎你加入 😁。&lt;/p&gt;
&lt;p&gt;有意者可发送邮件到 &lt;a href=&quot;mailto:hubin.gzx@bytedance.com&quot; target=&quot;_blank&quot;&gt;hubin.gzx@bytedance.com&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 11 Feb 2021 17:00:00 +0000</pubDate>
<dc:creator>格子熊</dc:creator>
<og:description>前言 在遥远的几个月前，还在上家公司的时候，老板突发奇想，想要搞个代码片段平台，类似于 snipit，实现代码片段的复用。本身这个需求并不难实现——简单的前端界面 + 简单的 node CURD，搞定</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/karthuslorin/p/14398400.html</dc:identifier>
</item>
<item>
<title>蓝牙通话链路和手机通话链路有区别么？ - c6000</title>
<link>http://www.cnblogs.com/c6000/p/14398318.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/c6000/p/14398318.html</guid>
<description>&lt;p&gt;近日友人推了一个博客：https://blog.csdn.net/david_tym/article/details/80963732&lt;/p&gt;
&lt;p&gt;作者对手机中通话链路进行了详细的分析。其中包括了经典的CP Call（运营商提供的电话业务）和流行的AP Call（VoIP等OTT业务）的链路，值得一看。&lt;/p&gt;
&lt;p&gt;不过在蓝牙耳机通话时，和手机有什么区别呢？首先我们以三星蓝牙耳机为例，先从芯片角度看一下：&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr&gt;&lt;td&gt; &lt;/td&gt;
&lt;td&gt;Buds+&lt;/td&gt;
&lt;td&gt;Buds Live&lt;/td&gt;
&lt;td&gt;Buds Pro&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;蓝牙音频芯片（主控芯片）&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;博通&lt;/td&gt;
&lt;td&gt;博通&lt;/td&gt;
&lt;td&gt;三星&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;智能音频处理芯片&lt;/td&gt;
&lt;td&gt;凌云逻辑&lt;/td&gt;
&lt;td&gt;恒玄&lt;/td&gt;
&lt;td&gt;凌云逻辑&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;*以上信息来自我爱音频网的三星耳机的拆解报告。 &lt;/p&gt;
&lt;p&gt;解释一下，智能音频处理芯片是语音识别和唤醒用的，也就是三星的Bixby使用的。蓝牙音频芯片包括蓝牙通话和听音乐的功能。&lt;/p&gt;
&lt;p&gt;如果只看蓝牙通话，就是跑在蓝牙音频芯片内。那么与普通的手机通话有什么不同呢？&lt;/p&gt;
&lt;p&gt;1. 通信协议不同&lt;/p&gt;
&lt;p&gt;手机上的CP Call是由我们常说的4G,5G协议来承载的，手机上的VoIP等OTT业务是用过TCP/UDP等协议来承载的。&lt;/p&gt;
&lt;p&gt;而蓝牙耳机通话，它和手机之间的通话是通过蓝牙物理链路SCO(Synchronous Connection Oriented)来承载的，主要用来传输对时间要求很高的数据通信,&lt;/p&gt;
&lt;p&gt;同步定向连接(SCO)，主要用于同步话音传送。 &lt;/p&gt;
&lt;p&gt;2. 语音编码器不同&lt;/p&gt;
&lt;p&gt;手机上的CP Call 采用的是AMR WB, EVS等3GPP组织定义的语音编码器，手机上的VoIP等OTT业务一般采用OPUS等开源语音编码器。&lt;/p&gt;
&lt;p&gt;而蓝牙耳机支持的编码器主要有：&lt;/p&gt;
&lt;p&gt;SBC （Sub-band coding，子带编码）&lt;/p&gt;
&lt;p&gt;ACC（Advanced Audio Coding，高级音频编码）&lt;/p&gt;
&lt;p&gt;aptX，是CSR公司的专利编码算法，在被高通收购后，APTX在安卓手机里面推广力度很大&lt;/p&gt;
&lt;p&gt;LDAC，很简单粗暴的提高了信道，在支持LDAC的设备上面，蓝牙的通信码率接近1M&lt;/p&gt;
&lt;p&gt;Samsung Scalable Codec，三星公司自研的蓝牙编码器，根据我爱音频网的评测，SSC编码器支持更远的传输距离。 &lt;/p&gt;
&lt;p&gt;3.语音增强链路的差别&lt;/p&gt;
&lt;p&gt;其实手机通话中的语音增强模块，耳机中的都需要，可谓小小麻雀，五藏俱全。&lt;/p&gt;
&lt;p&gt;但是由于耳机的佩戴方式和手机不同，以及耳机上资源更加受限，都导致耳机上的语音增强模块比手机的要求要高。&lt;/p&gt;
&lt;p&gt;我们从硬件拾音模块来看一下三星Buds Pro的结构：&lt;/p&gt;


&lt;p&gt;    &lt;img src=&quot;https://img2020.cnblogs.com/blog/152995/202102/152995-20210211232433709-1644265038.png&quot; alt=&quot;&quot; width=&quot;474&quot; height=&quot;249&quot; loading=&quot;lazy&quot;/&gt;    &lt;img src=&quot;https://img2020.cnblogs.com/blog/152995/202102/152995-20210211232257314-426901868.png&quot; alt=&quot;&quot; width=&quot;236&quot; height=&quot;131&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;图中的双麦克风，是朝向耳机外侧的两个麦克风，用这两个麦克风可以形成波束成形功能。&lt;/p&gt;
&lt;p&gt;蓝牙耳机的从业者应该都知道其中的内置麦克风和语音拾取单元的特点。&lt;/p&gt;
&lt;p&gt;内置麦克风，是朝向耳朵内侧的麦克风，它拾取到的信号是通过佩戴者的骨传导和耳道中的空气传到共同形成的，导致它只能拾取到2kHz以下的音频，&lt;/p&gt;
&lt;p&gt;但是由于耳机的物理隔绝，它基本拾取不到外部的噪声。&lt;/p&gt;
&lt;p&gt;语音拾取单元是通过感知佩戴者下颚的震动来拾取佩戴者的语音的，它只能拾取到1kHz以下的音频，同时也拾取不到外部的噪声。&lt;/p&gt;
&lt;p&gt;在Buds Pro 中由这个四个麦克风共同组成了蓝牙语音的增强链路的输入，相信每个蓝牙耳机厂商都有自己独特的解决方案。&lt;/p&gt;
&lt;p&gt;其中的麦克风网格主要是用来防风噪的，使得带着耳机跑步时，不再担心风噪对通话的干扰了。&lt;/p&gt;

&lt;p&gt;鉴于目前并没有蓝牙耳机厂商公布自己的语音增强链路的链路图，这里不好一一给出与手机语音增强链路的区别，&lt;/p&gt;
&lt;p&gt;但是相信蓝牙语音从业者的脑海里，都会清楚的有这样一张链路图的。&lt;/p&gt;
&lt;p&gt;使用了这四个麦克风，加麦克风网格的联合处理的语音增强链路，效果相信不会差，要不然他也不敢再发布会上重点宣传低噪声通话功能了。&lt;/p&gt;

</description>
<pubDate>Thu, 11 Feb 2021 15:46:00 +0000</pubDate>
<dc:creator>c6000</dc:creator>
<og:description>近日友人推了一个博客：https://blog.csdn.net/david_tym/article/details/80963732 作者对手机中通话链路进行了详细的分析。其中包括了经典的CP Ca</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/c6000/p/14398318.html</dc:identifier>
</item>
<item>
<title>kubernetes跑jenkins动态slave - 落魄运维</title>
<link>http://www.cnblogs.com/Dev0ps/p/14398329.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Dev0ps/p/14398329.html</guid>
<description>&lt;div readability=&quot;6&quot;&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;使用jenkins动态slave的优势：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;服务高可用&lt;/strong&gt;，当 Jenkins Master 出现故障时，Kubernetes 会自动创建一个新的 Jenkins Master 容器，并且将 Volume 分配给新创建的容器，保证数据不丢失，从而达到集群服务高可用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;动态伸缩&lt;/strong&gt;，合理使用资源，每次运行 Job 时，会自动创建一个 Jenkins Slave，Job 完成后，Slave 自动注销并删除容器，资源自动释放，而且 Kubernetes 会根据每个资源的使用情况，动态分配 Slave 到空闲的节点上创建，降低出现因某节点资源利用率高，还排队等待在该节点的情况。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;扩展性好&lt;/strong&gt;，当 Kubernetes 集群的资源严重不足而导致 Job 排队等待时，可以很容易的添加一个 Kubernetes Node 到集群中，从而实现扩展。&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;架构图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1271786/202102/1271786-20210211232254807-1222340523.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1、创建namespace&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
kubectl create ns kube-ops
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2、设置rba授权&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@node1 mingyang]# cat rbac.yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: jenkins
  &lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;: kube-&lt;span&gt;ops

&lt;/span&gt;---&lt;span&gt;
kind: ClusterRole
apiVersion: rbac.authorization.k8s.io&lt;/span&gt;/&lt;span&gt;v1beta1
metadata:
  name: jenkins
rules:
  &lt;/span&gt;- apiGroups: [&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;extensions&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;apps&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
    resources: [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;deployments&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
    verbs: [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;create&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;delete&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;watch&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;patch&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;update&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
  &lt;/span&gt;- apiGroups: [&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;]
    resources: [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;services&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
    verbs: [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;create&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;delete&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;watch&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;patch&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;update&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
  &lt;/span&gt;- apiGroups: [&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;]
    resources: [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pods&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
    verbs: [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;create&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;delete&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;patch&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;update&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;watch&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
  &lt;/span&gt;- apiGroups: [&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;]
    resources: [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pods/exec&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
    verbs: [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;create&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;delete&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;patch&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;update&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;watch&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
  &lt;/span&gt;- apiGroups: [&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;]
    resources: [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pods/log&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
    verbs: [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;watch&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
  &lt;/span&gt;- apiGroups: [&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;]
    resources: [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;secrets&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
    verbs: [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]

&lt;/span&gt;---&lt;span&gt;
apiVersion: rbac.authorization.k8s.io&lt;/span&gt;/&lt;span&gt;v1beta1
kind: ClusterRoleBinding
metadata:
  name: jenkins
  &lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;: kube-&lt;span&gt;ops
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: jenkins
subjects:
  &lt;/span&gt;-&lt;span&gt; kind: ServiceAccount
    name: jenkins
    &lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;: kube-ops
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3、创建jenkins deployment文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@node1 mingyang]# cat  jenkins.yaml
&lt;/span&gt;---&lt;span&gt;
apiVersion: apps&lt;/span&gt;/&lt;span&gt;v1
kind: Deployment
metadata:
  name: jenkins
  &lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;: kube-&lt;span&gt;ops
spec:
  selector:
     matchLabels:
       app: jenkins
  template:
    metadata:
      labels:
        app: jenkins
    spec:
      terminationGracePeriodSeconds: &lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;
      serviceAccount: jenkins
      containers:
      &lt;/span&gt;-&lt;span&gt; name: jenkins
        image: jenkins&lt;/span&gt;/&lt;span&gt;jenkins:lts
        imagePullPolicy: IfNotPresent
        ports:
        &lt;/span&gt;- containerPort: &lt;span&gt;8080&lt;/span&gt;&lt;span&gt;
          name: web
          protocol: TCP
        &lt;/span&gt;- containerPort: &lt;span&gt;50000&lt;/span&gt;&lt;span&gt;
          name: agent
          protocol: TCP
        resources:
          limits:
            cpu: 1000m
            memory: 1Gi
          requests:
            cpu: 500m
            memory: 512Mi
        livenessProbe:
          httpGet:
            path: &lt;/span&gt;/&lt;span&gt;login
            port: &lt;/span&gt;&lt;span&gt;8080&lt;/span&gt;&lt;span&gt;
          initialDelaySeconds: &lt;/span&gt;&lt;span&gt;60&lt;/span&gt;&lt;span&gt;
          timeoutSeconds: &lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;
          failureThreshold: &lt;/span&gt;&lt;span&gt;12&lt;/span&gt;&lt;span&gt;
        readinessProbe:
          httpGet:
            path: &lt;/span&gt;/&lt;span&gt;login
            port: &lt;/span&gt;&lt;span&gt;8080&lt;/span&gt;&lt;span&gt;
          initialDelaySeconds: &lt;/span&gt;&lt;span&gt;60&lt;/span&gt;&lt;span&gt;
          timeoutSeconds: &lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;
          failureThreshold: &lt;/span&gt;&lt;span&gt;12&lt;/span&gt;&lt;span&gt;
        volumeMounts:
        &lt;/span&gt;-&lt;span&gt; name: jenkinshome
          subPath: jenkins
          mountPath: &lt;/span&gt;/&lt;span&gt;var&lt;/span&gt;/&lt;span&gt;jenkins_home
        env:
        &lt;/span&gt;-&lt;span&gt; name: LIMITS_MEMORY
          valueFrom:
            resourceFieldRef:
              resource: limits.memory
              divisor: 1Mi
        &lt;/span&gt;-&lt;span&gt; name: JAVA_OPTS
          value: &lt;/span&gt;-Xmx$(LIMITS_MEMORY)m -XshowSettings:vm -Dhudson.slaves.NodeProvisioner.initialDelay=&lt;span&gt;0&lt;/span&gt; -Dhudson.slaves.NodeProvisioner.MARGIN=&lt;span&gt;50&lt;/span&gt; -Dhudson.slaves.NodeProvisioner.MARGIN0=&lt;span&gt;0.85&lt;/span&gt; -Duser.timezone=Asia/&lt;span&gt;Shanghai
      securityContext:
        fsGroup: &lt;/span&gt;&lt;span&gt;1000&lt;/span&gt;&lt;span&gt;
      volumes:
      &lt;/span&gt;-&lt;span&gt; name: jenkinshome
        hostPath:
          path: &lt;/span&gt;/data/&lt;span&gt;jenkins_home
          type: DirectoryOrCreate

&lt;/span&gt;---&lt;span&gt;
apiVersion: v1
kind: Service
metadata:
  name: jenkins
  &lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;: kube-&lt;span&gt;ops
  labels:
    app: jenkins
spec:
  selector:
    app: jenkins
  type: NodePort
  ports:
  &lt;/span&gt;-&lt;span&gt; name: web
    port: &lt;/span&gt;&lt;span&gt;8080&lt;/span&gt;&lt;span&gt;
    targetPort: web
    nodePort: &lt;/span&gt;&lt;span&gt;30002&lt;/span&gt;
  -&lt;span&gt; name: agent
    port: &lt;/span&gt;&lt;span&gt;50000&lt;/span&gt;&lt;span&gt;
    targetPort: agent&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4、给jenkins家目录授权&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
chown -R &lt;span&gt;1000&lt;/span&gt; /data/jenkins_home/
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;5、运行情况&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1271786/202102/1271786-20210211232519846-539495313.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 6、安装kubernetes插件Kubernetes plugin。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1271786/202102/1271786-20210211232546048-1299225044.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 7、配置kubernetes&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1271786/202102/1271786-20210211232619705-189799358.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;8、这一步是核心，添加pod templates。标签列表是到时编写pipeline要关联的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1271786/202102/1271786-20210211232648102-517864091.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;9、添加两个挂载卷 分别是docker及kubectl 工具&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1271786/202102/1271786-20210211232725170-987124724.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;10、测试pipeline&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
node(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;hejianlai&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) {
    stage(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Clone&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) {
      echo &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1.Clone Stage&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    }
    stage(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Test&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) {
      echo &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2.Test Stage&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    }
    stage(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Build&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) {
      echo &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;3.Build Docker Image Stage&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    }
    stage(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Push&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) {
      echo &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;4.Push Docker Image Stage&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    }
    stage(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;YAML&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) {
      echo &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;5. Change YAML File Stage&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    }
    stage(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Deploy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) {
      echo &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;6. Deploy Stage&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;11、运行结果，slave执行完任务之后自动销毁。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1271786/202102/1271786-20210211232854796-1506360568.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1271786/202102/1271786-20210211232940823-1927120172.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;





</description>
<pubDate>Thu, 11 Feb 2021 15:31:00 +0000</pubDate>
<dc:creator>落魄运维</dc:creator>
<og:description>使用jenkins动态slave的优势： 服务高可用，当 Jenkins Master 出现故障时，Kubernetes 会自动创建一个新的 Jenkins Master 容器，并且将 Volume</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Dev0ps/p/14398329.html</dc:identifier>
</item>
<item>
<title>WSL (Windows Subsystem for Linux) 的 VSLAM (Visual Simultaneous Localization and Mapping) 道路 - Optics_css</title>
<link>http://www.cnblogs.com/optics-css/p/14398226.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/optics-css/p/14398226.html</guid>
<description>&lt;p&gt;以 Windows Subsystem for Linux 闯入 Visual Simultaneous Localization and Mapping 世界的艰难道路... 这里包含各种各样的 WSL 中可能用到的包，美化方案，以及相关软件的一些使用小技巧，用于自己踩坑记录的同时，希望能够帮到同为使用 Windows 踩坑的 CVer 们... ...&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;351.53792784459&quot;&gt;

&lt;hr/&gt;&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;以 &lt;strong&gt;Windows Subsystem for Linux&lt;/strong&gt; 闯入 &lt;strong&gt;Visual Simultaneous Localization and Mapping&lt;/strong&gt; 世界的艰难道路... 这里包含各种各样的 WSL 中可能用到的包，美化方案，以及相关软件的一些使用小技巧，用于自己踩坑记录的同时，希望能够帮到同为使用 Windows 踩坑的 CVer 们... ...&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;安装好-windows-subsystem-for-linux-后要做的&quot;&gt;&lt;strong&gt;安装好 Windows Subsystem for Linux 后要做的&lt;/strong&gt;&lt;/h2&gt;
&lt;h3 id=&quot;卸载原装-vim&quot;&gt;&lt;strong&gt;卸载原装 Vim&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;一波强硬操作把好删的地方先咔嚓掉（让输密码就老实输，让确认就直接'Y'）：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;sudo apt-get remove vim
sudo apt-get remove vim-runtime
sudo apt-get remove vim -tiny
sudo apt-get remove vim-common
sudo apt-get remove vim-doc
sudo apt-get remove vim-scripts
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后检查还剩什么带 &quot;vim&quot; 字眼的还活着，输入：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;dpkg -l | grep vim
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;得到下面这三个东西：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;rc  vim-common        2:8.1.2269-1ubuntu5     all     Vi IMproved - Common files
rc  vim-runtime 2:8.1.2269-1ubuntu5     all     Vi IMproved - Runtime files
rc  vim-tiny    2:8.1.2269-1ubuntu5     amd64   Vi IMproved - enhanced vi editor - compact version
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;扯掉它最后的救命稻草，用：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;sudo dpkg -P vim-tiny vim-common vim-run
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;安装-nano&quot;&gt;&lt;strong&gt;安装 Nano&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;这样就成功 remove 了原装的 vim，下面用 apt-get 命令安装 nano，也是一种编辑器：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;sudo apt-get install nano
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;linux换源&quot;&gt;&lt;strong&gt;Linux换源&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;进入&lt;a href=&quot;https://developer.aliyun.com/mirror/ubuntu?spm=a2c6h.13651102.0.0.3e221b11ICRBHL&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;阿里云 Ubuntu 镜像&lt;/strong&gt;&lt;/a&gt;，选择 ubuntu 20.04 (focal) 配置所对应的源：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-css&quot;&gt;deb http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse
deb http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse
deb http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse
deb http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse
deb http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 source.list 文件中添加这些源并保存（按，Ctrl+K）：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;sudo nano /etc/apt/source.list # Use nano to edit the .list file
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;一些小型的-tips&quot;&gt;&lt;strong&gt;一些小型的 Tips&lt;/strong&gt;&lt;/h2&gt;
&lt;ul readability=&quot;31&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;“右键”在 WSL 中意味着 “Paste”；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;访问源列表中每个网址并读取&lt;strong&gt;软件列表&lt;/strong&gt;，最后把这个更新后的列表保存在本地电脑，用的命令为：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;sudo apt-get update
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;要想把本地已安装的&lt;strong&gt;软件&lt;/strong&gt;与软件列表中对应软件进行对比，发现需要更新的文件，用下面这个：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;sudo apt-get upgrade
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;回到 home 目录是用：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;cd ~
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;WSL 似乎不支持这东西&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# sudo apt-get install yum
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;21&quot;&gt;
&lt;p&gt;要想鉴定一个网站是否正常连接，使用如下的命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;ping XXX.com # &quot;Packet Internet Groper&quot;, as an example, use 'ping github.com'
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是工作在 TCP/IP 网络体系结构中应用层的一个服务命令， 主要是向特定的目的主机发送 ICMP（Internet Control Message Protocol 因特网报文控制协议）Echo 请求报文，测试目的站是否可达及了解其有关状态。&lt;/p&gt;
&lt;p&gt;等待一段时间后（你认为差不多到了统计的总时长了），使用以下命令停止：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;ctrl+C
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最终输出基本上是下面这个样子（github 有一定的丢包 a... ...）：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-css&quot;&gt;PING github.com (140.82.113.3) 56(84) bytes of data.
64 bytes from github.com (140.82.113.3): icmp_seq=1 ttl=47 time=565 ms
64 bytes from github.com (140.82.113.3): icmp_seq=2 ttl=47 time=1062 ms
64 bytes from github.com (140.82.113.3): icmp_seq=3 ttl=47 time=389 ms
64 bytes from github.com (140.82.113.3): icmp_seq=4 ttl=47 time=513 ms
64 bytes from github.com (140.82.113.3): icmp_seq=5 ttl=47 time=434 ms
64 bytes from github.com (140.82.113.3): icmp_seq=6 ttl=47 time=607 ms
64 bytes from github.com (140.82.113.3): icmp_seq=7 ttl=47 time=373 ms
64 bytes from github.com (140.82.113.3): icmp_seq=8 ttl=47 time=401 ms
^C
--- github.com ping statistics ---
9 packets transmitted, 8 received, 11.1111% packet loss, time 8026ms
rtt min/avg/max/mdev = 372.733/542.963/1062.033/212.073 ms, pipe 2
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;只有 g++ 不足以在 Linux 上面开心地做开发，最好在一切的开始先装一下 &lt;code&gt;build-essential&lt;/code&gt; 这个包，里面有很多依赖，能够使缺省的 Ubuntu 具备 C/C++ 的编译环境，运行：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;sudo apt-get install build-essential
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Node Package Manager（npm）能够加快下载软件包的速度（?）：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;sudo apt install npm
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;想要看看可以升级的软件以及它们的版本信息，使用：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;apt list --upgradable -a
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;直接 Kill 当前进程：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;ctrl+C
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;一种临时给予权限的方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;sudo chmod 777 /dev/ttyUSB*
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;相应的，如果想要给串口一个永久权限，使用：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;sudo usermod -a -G dialout user_name
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;寻找包的位置，&lt;code&gt;mlocate&lt;/code&gt; 可以用来定位软件包，使用 &lt;code&gt;locate&lt;/code&gt; 命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;sudo apt-get mlocate
sudo apt-get install mlocate
sudo updatedb
locate eigen3
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;就可以输出 &lt;code&gt;eigen3&lt;/code&gt; 的位置。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;doxygen 编译文档的方法，下载并 &lt;code&gt;make doc&lt;/code&gt; 就可以编译出一个 &lt;code&gt;doxygen&lt;/code&gt; 文档：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;sudo apt-get install doxygen
make doc
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;配置一个比较漂亮的shell&quot;&gt;&lt;strong&gt;配置一个比较漂亮的Shell&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;可以通过 &lt;code&gt;cat&lt;/code&gt; 来查看当前的 Linux 系统是否有可用的 shell：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;cat /etc/shells
sudo apt-get install zsh
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;安装完后，shells 中将出现 &lt;code&gt;zsh&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;# /etc/shells: valid login shells
/bin/sh
/bin/bash
/usr/bin/bash
/bin/rbash
/usr/bin/rbash
/bin/dash
/usr/bin/dash
/usr/bin/tmux
/usr/bin/screen
/bin/zsh
/usr/bin/zsh
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;emmmm... ... 要安装的就是叫做 zsh 的东西，可以把命令行弄得好看一些，&lt;s&gt;对于提高工作效率有很好的促进作用&lt;/s&gt;，安装步骤很简单，直接运行：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;sudo apt-get install zsh
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后切换当前 shell 至 zsh 就成功了：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;chsh -s /bin/zsh
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;更新后会输出一个：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# Updated process:[oh-my-zsh] Would you like to update? [Y/n] Y
Updating Oh My Zsh ...

remote: Enumerating objects: 154, done.
remote: Counting objects: 100% (154/154), done.
remote: Compressing objects: 100% (78/78), done.
remote: Total 116 (delta 69), reused 84 (delta 38), pack-reused 0
Receiving objects: 100% (116/116), 27.17 KiB | 11.00 KiB/s, done.
Resolving deltas: 100% (69/69), completed with 24 local objects.
From https://github.com/ohmyzsh/ohmyzsh
 * branch            master     -&amp;gt; FETCH_HEAD
   93c837f..c549387  master     -&amp;gt; origin/master
 README.md                                      |  61 +++---
 lib/functions.zsh                              |   4 +-
 lib/termsupport.zsh                            |  12 +-
 plugins/aws/aws.plugin.zsh                     |   1 -
 plugins/bgnotify/bgnotify.plugin.zsh           |   2 +-
 plugins/brew/README.md                         |   7 +-
 plugins/brew/brew.plugin.zsh                   |   1 +
 plugins/bundler/README.md                      |  79 +++++---
 plugins/bundler/bundler.plugin.zsh             | 116 ++++++-----
 plugins/compleat/compleat.plugin.zsh           |   7 +-
 plugins/composer/composer.plugin.zsh           |   2 +
 plugins/drush/drush.plugin.zsh                 |   2 -
 plugins/git/git.plugin.zsh                     |  14 +-
 plugins/ipfs/LICENSE                           |  22 ++
 plugins/ipfs/README.md                         |  17 ++
 plugins/ipfs/_ipfs                             | 717 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 plugins/laravel5/laravel5.plugin.zsh           |  19 +-
 plugins/minikube/minikube.plugin.zsh           |  10 +-
 plugins/pip/pip.plugin.zsh                     |   6 +-
 plugins/stack/stack.plugin.zsh                 |   1 -
 plugins/sublime-merge/README.md                |  17 ++
 plugins/sublime-merge/sublime-merge.plugin.zsh |  55 +++++
 plugins/terraform/README.md                    |   3 +-
 plugins/terraform/terraform.plugin.zsh         |   2 +
 plugins/wp-cli/wp-cli.plugin.zsh               |   1 -
 themes/agnoster.zsh-theme                      |   2 +-
 themes/avit.zsh-theme                          |   4 +-
 27 files changed, 1017 insertions(+), 167 deletions(-)
 create mode 100644 plugins/ipfs/LICENSE
 create mode 100644 plugins/ipfs/README.md
 create mode 100644 plugins/ipfs/_ipfs
 create mode 100644 plugins/sublime-merge/README.md
 create mode 100644 plugins/sublime-merge/sublime-merge.plugin.zsh
First, rewinding head to replay your work on top of it...
Fast-forwarded master to c549387745205d7fa8e91c1e6dcdae6901d9dd1d.
         __                                     __
  ____  / /_     ____ ___  __  __   ____  _____/ /_
 / __ \/ __ \   / __ `__ \/ / / /  /_  / / ___/ __ \
/ /_/ / / / /  / / / / / / /_/ /    / /_(__  ) / / /
\____/_/ /_/  /_/ /_/ /_/\__, /    /___/____/_/ /_/
                        /____/
Hooray! Oh My Zsh has been updated and/or is at the current version.
To keep up on the latest news and updates, follow us on Twitter: https://twitter.com/ohmyzsh
Want to get involved in the community? Join our Discord: https://discord.gg/ohmyzsh
Get your Oh My Zsh swag at: https://shop.planetargon.com/collections/oh-my-zsh
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;打开文件 &lt;code&gt;.zshrc&lt;/code&gt;，更改 &lt;code&gt;ZSH_THEME=&lt;/code&gt; 至 &lt;code&gt;ZSH_THEME=&quot;agnoster&quot;&lt;/code&gt;，打开的方法如下（用 Nano 编辑）：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;
nano ~/.zshrc
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实际上，此时 &lt;code&gt;reboot&lt;/code&gt; 后看到的是奇怪的样式，需要调整字体才能让它正常起来，进入官网下载相应的字体，直接双击安装后，在 WSL 命令行窗口直接 &lt;code&gt;右键-&amp;gt;属性-&amp;gt;字体&lt;/code&gt; 并更改字体的样式即可。&lt;/p&gt;
&lt;h2 id=&quot;输出文件树视图到txt（windows-版本）&quot;&gt;&lt;strong&gt;输出文件树视图到.txt（Windows 版本）&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;打开&quot;运行&quot;对话框（Win+R），输入 cmd，打开控制台命令窗口...&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;C:\Users\a1020&amp;gt;g:
G:\&amp;gt;cd \__BiBliOthèQuE__
G:\__BiBliOthèQuE__&amp;gt;tree /f &amp;gt; saved_names.txt
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Linux 中做这件事似乎需要下面这个东西：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;sudo apt-get install tree
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个弄出来也蛮好看的，在路径中输入：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;tree
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;得到了下面一棵很 happy 的树图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2137921/202102/2137921-20210211215839887-1386898562.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;借助-wsl-走进-vslam的世界&quot;&gt;&lt;strong&gt;借助 WSL 走进 VSLAM的世界&lt;/strong&gt;&lt;/h2&gt;
&lt;h3 id=&quot;wsl-挂载-windows文件&quot;&gt;&lt;strong&gt;WSL 挂载 Windows文件&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;WSL 是可以访问 Windows 中的文件的，除了软件要安装在根目录（?），其它的文件例如各种代码、数据文件什么的都希望可以放在别的地方，由此，可以切换路径到自己喜欢的目录里面：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;cd /mnt/c/Users/a1020/Desktop/Reinforcement_ELyou/Demolist/slamdemo
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;下载-slamdemo-文件、安装-cmake、hello-slam&quot;&gt;&lt;strong&gt;下载 SLAMdemo 文件、安装 cmake、Hello SLAM&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;从 Gitee 中把目标文件 clone 下来：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;git clone https://gitee.com/wenyawei/slambook.git
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;安装 cmake 的过程还是像以往一样：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;sudo apt-get install cmake
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;完事之后随便来一下 &lt;code&gt;cmake&lt;/code&gt; 命令，可以输出一些奇奇怪怪的东西：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;Usage

  cmake [options] &amp;lt;path-to-source&amp;gt;
  cmake [options] &amp;lt;path-to-existing-build&amp;gt;
  cmake [options] -S &amp;lt;path-to-source&amp;gt; -B &amp;lt;path-to-build&amp;gt;

Specify a source directory to (re-)generate a build system for it in the
current working directory.  Specify an existing build directory to
re-generate its build system.

Run 'cmake --help' for more information.
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来把路径切到 &lt;code&gt;slambook/ch2&lt;/code&gt;，用g++编译一下 &lt;code&gt;helloSLAM.cpp&lt;/code&gt;，并运行生成的可执行文件 &lt;code&gt;a.out&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;cd slambook/ch2
g++ helloSLAM.cpp
./a.out
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;得到如下所示 &lt;code&gt;Hello SLAM!&lt;/code&gt; 的输出：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2137921/202102/2137921-20210211215853342-1417613654.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;安装-eigen、检测是否成功&quot;&gt;&lt;strong&gt;安装 Eigen、检测是否成功&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;直接采用 &lt;code&gt;apt-get&lt;/code&gt; 安装：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;sudo apt-get install libeigen3-dev
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从前面的路径回退一位，并切换到 &lt;code&gt;ch3/useEigen&lt;/code&gt; 的路径：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;cd ..
cd ch3/useEigen
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用 &lt;code&gt;cmake&lt;/code&gt; 进行编译，并运行：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;cmake .
make
./eigenMatrix
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出为（...）：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;1 2 3
4 5 6
1       2       3
4       5       6
10
28
32
77
 0.680375   0.59688 -0.329554
-0.211234  0.823295  0.536459
 0.566198 -0.604897 -0.444451

 0.680375 -0.211234  0.566198
  0.59688  0.823295 -0.604897
-0.329554  0.536459 -0.444451
1.61307
1.05922
 6.80375   5.9688 -3.29554
-2.11234  8.23295  5.36459
 5.66198 -6.04897 -4.44451
-0.198521   2.22739    2.8357
  1.00605 -0.555135  -1.41603
 -1.62213   3.59308   3.28973
0.208598
Eigen values =
0.0242899
 0.992154
  1.80558
Eigen vectors =
-0.549013 -0.735943  0.396198
 0.253452 -0.598296 -0.760134
-0.796459  0.316906 -0.514998
time use in normal inverse is 0ms
time use in Qr decomposition is 0ms
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;安装-pangolin、检测是否成功&quot;&gt;&lt;strong&gt;安装 Pangolin、检测是否成功&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;详细安装步骤以及检测见我的 &lt;a href=&quot;https://www.cnblogs.com/optics-css/p/14374766.html&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;Pangolin Installation &amp;amp; Examination&lt;/strong&gt;&lt;/a&gt; 教程。&lt;/p&gt;
&lt;h3 id=&quot;安装-sophus、检测是否成功&quot;&gt;&lt;strong&gt;安装 Sophus、检测是否成功&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;和之前一样，直接切入软件包的目录进行编译，指令如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;cd /mnt/c/Users/a1020/Desktop/Reinforcement_ELyou/Demolist/slamdemo/slambook/3rdparty/Sophus
mkdir build
cd build
cmake ..
make
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后&lt;s&gt;开心地&lt;/s&gt;发现竟然有编译错误！！具体错误为：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;/mnt/c/Users/a1020/Desktop/Reinforcement_ELyou/Demolist/slamdemo/slambook/3rdparty/sophus/sophus/so2.cpp: In constructor ‘Sophus::SO2::SO2()’:
/mnt/c/Users/a1020/Desktop/Reinforcement_ELyou/Demolist/slamdemo/slambook/3rdparty/sophus/sophus/so2.cpp:32:26: error: lvalue required as left operand of assignment
   32 |   unit_complex_.real() = 1.;
      |                          ^~
/mnt/c/Users/a1020/Desktop/Reinforcement_ELyou/Demolist/slamdemo/slambook/3rdparty/sophus/sophus/so2.cpp:33:26: error: lvalue required as left operand of assignment
   33 |   unit_complex_.imag() = 0.;
      |                          ^~
make[2]: *** [CMakeFiles/Sophus.dir/build.make:66: CMakeFiles/Sophus.dir/sophus/so2.cpp.o] Error 1
make[2]: Leaving directory '/mnt/c/Users/a1020/Desktop/Reinforcement_ELyou/Demolist/slamdemo/slambook/3rdparty/sophus/build'
make[1]: *** [CMakeFiles/Makefile2:91: CMakeFiles/Sophus.dir/all] Error 2
make[1]: Leaving directory '/mnt/c/Users/a1020/Desktop/Reinforcement_ELyou/Demolist/slamdemo/slambook/3rdparty/sophus/build'
make: *** [Makefile:144: all] Error 2
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;于是去寻找路径下名为 &lt;code&gt;so2.cpp&lt;/code&gt; 的源文件，找到如下代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;SO2::SO2()
{
unit_complex_.real() = 1.;
unit_complex_.imag() = 0.;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;显然这种赋值方式是 XXX 的，应该用实参的形式赋值，也就是说，改成下面的形式：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;SO2::SO2()
{
//unit_complex_.real() = 1.;
//unit_complex_.imag() = 0.;
unit_complex_.real(1.);
unit_complex_.imag(0.);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后重新编译一下，就通过了：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;/usr/bin/cmake -E cmake_progress_start /mnt/c/Users/a1020/Desktop/Reinforcement_ELyou/Demolist/slamdemo/slambook/3rdparty/sophus/build/CMakeFiles 0
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接着的使用中会遇到的麻烦事是找不到 &lt;code&gt;Sophus&lt;/code&gt; 库，需要把 &lt;code&gt;CMakeLists.txt&lt;/code&gt; 里面写上你安装的 &lt;code&gt;Sophus&lt;/code&gt; 库的头文件路径以及共享库的路径：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cmake&quot;&gt;# Use the set(·) command to input the directories of Sophus
set(Sophus_INCLUDE_DIRS &quot;/mnt/c/Users/a1020/Desktop/Reinforcement_ELyou/Demolist/slamdemo/slambook/3rdparty/Sophus/sophus&quot;)
set(Sophus_LIBS &quot;/mnt/c/Users/a1020/Desktop/Reinforcement_ELyou/Demolist/slamdemo/slambook/3rdparty/Sophus/build/libSophus.so&quot;)
find_package(Sophus REQUIRED)
include_directories(
${Sophus_INCLUDE_DIRS}
)
target_link_libraries(useSophus ${Sophus_LIBRARIES})
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;咳咳，上面是非模板 &lt;code&gt;Sophus&lt;/code&gt; 的安装和使用，，下面才是模板库的，命令行如下（记得不要回滚）：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;git clone https://github.com/strasdat/Sophus.git
cd /mnt/c/Users/a1020/Desktop/Reinforcement_ELyou/Demolist/slamdemo/slambook/3rdparty/SophusTemplate
mkdir build
cd build
cmake ..
make
sudo make install
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;并没有任何编译错误，这样一下子安装下来就是只有头文件的 &lt;code&gt;Sophus&lt;/code&gt;，就像 &lt;code&gt;eigen3&lt;/code&gt; 一样的，它和非模板库的区别在于，这个里面的类型定义都是基于模板的，也就是说，有更强的泛化性能。&lt;/p&gt;
&lt;h3 id=&quot;安装-ceres、g2o、检测是否成功&quot;&gt;&lt;strong&gt;安装 Ceres、g2o、检测是否成功&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;同前，首先应当安装依赖：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;sudo apt-get install qt5-qmake qt5-default libqglviewer-dev-qt5        libsuitesparse-dev libcxsparse3 libcholmod3
sudo apt-get install liblapack-dev libsuitesparse-dev libcxsparse3 libgflags-dev libgoogle-glog-dev libgtest-dev
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后进入编译：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;git clone https://github.com/RainerKuemmerle/g2o.git
sudo apt-get install libsuitesparse-dev qtdeclarative5-dev qt5-qmake libqglviewer-dev-qt5
sudo su
cd g2o
mkdir build
cd build
cmake ../
make -j8
sudo make install
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;遇到了编译错误：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;/usr/lib/qt5/bin/uic: error while loading shared libraries: libQt5Core.so.5: cannot open shared object file: No such file or directory
make[2]: *** [g2o/apps/g2o_viewer/CMakeFiles/viewer_library.dir/build.make:62: g2o/apps/g2o_viewer/ui_base_main_window.h] Error 127
make[1]: *** [CMakeFiles/Makefile2:1580: g2o/apps/g2o_viewer/CMakeFiles/viewer_library.dir/all] Error 2
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查了一下，这个错误名为 &lt;code&gt;error while loading shared libraries: libQt5Core.so.5: cannot open shared object file: No such file or directory&lt;/code&gt;，还好还好，有个&lt;a href=&quot;https://github.com/dnschneid/crouton/wiki/Fix-error-while-loading-shared-libraries:-libQt5Core.so.5&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;解决思路&lt;/strong&gt;&lt;/a&gt;帮助我成功解决了这个问题，似乎为 WSL 特有的，运行如下语句后再进行编译就可以了：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;sudo strip --remove-section=.note.ABI-tag /usr/lib/x86_64-linux-gnu/libQt5Core.so.5
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;开了7个线程，花了得有接近 3~4 min 叭才弄完，但是完了就好完了就好，最后别忘了 &lt;code&gt;sudo make install&lt;/code&gt; 一下。&lt;/p&gt;
&lt;p&gt;用 &lt;code&gt;g2o_viewer&lt;/code&gt; run 一下 &lt;code&gt;sphere.g2o&lt;/code&gt; 来证明一下已经下载完成：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;./g2o/bin/g2o_viewer /mnt/c/Users/a1020/Desktop/Reinforcement_ELyou/Demolist/slamdemo/slambook/3rdparty/ch10/sphere.g2o
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一个需要注意的点是，最好别在别的位置编译 &lt;code&gt;g2o&lt;/code&gt; 库，可能会报错告诉你路径里有中文。&lt;/p&gt;
&lt;h3 id=&quot;安装-opencv44、检测是否成功&quot;&gt;&lt;strong&gt;安装 OpenCV4.4、检测是否成功&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;详细安装步骤以及检测见我的 &lt;a href=&quot;https://www.cnblogs.com/optics-css/p/14374694.html&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;OpenCV4.4.0 Installation &amp;amp; Examination&lt;/strong&gt;&lt;/a&gt; 教程。&lt;/p&gt;
&lt;h2 id=&quot;cmake、g&quot;&gt;&lt;strong&gt;Cmake、g++&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;在 WSL 中使用 g++ 打印虚表的操作如下，会自动写到一个文件里：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;g++ -fdump-class-hierarchy XXX.cpp
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用 g++ 导出继承结构的指令如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;g++ -fdump-class-hierarchy -c XXX.cpp
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;cmake-的简单用法&quot;&gt;&lt;strong&gt;Cmake 的简单用法&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;构建 CMakeList.txt 如下，注意一定要把保存的编码格式改成 &lt;code&gt;UTF8&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cmake&quot;&gt;# The lowest version required
cmake_minimum_required( VERSION 2.8 )
# Project name
project( HelloSLAM )
# The executable file addition
add_executable( helloSLAM helloSLAM.cpp )
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在终端输入：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# Path to slambook/ch2
cd /mnt/c/Users/a1020/Desktop/Reinforcement_ELyou/Demolist/slamdemo/slambook/ch2
# CMake, the current path
cmake .
make
# Run the executable file
./helloSLAM
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以通过新建并切换到 &lt;code&gt;build&lt;/code&gt; 文件夹，并对于上一个文件夹进行编译，就可以将 cmake 编译时产生的文件生成在 &lt;code&gt;build&lt;/code&gt; 里面，这样有利于源代码的发布：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;mkdir build
cd build
cmake ..
make
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意每次编译时都记得把以前的 Makefile 删除。&lt;/p&gt;
&lt;h2 id=&quot;python-的简单用例&quot;&gt;&lt;strong&gt;Python 的简单用例&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;学会用命令行调用 &lt;code&gt;Python&lt;/code&gt; 标准库的 &lt;code&gt;doctest&lt;/code&gt;，从而生成代码的分析文件，首先自然是切换到相应的路径：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;cd /mnt/c/Users/a1020/Desktop/Reinforcement_ELyou/#Pythonic/Fluent-Python/01-data-model
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行下面的指令，调用 &lt;code&gt;doctest&lt;/code&gt;，可以获得一个名为 &lt;code&gt;frenchdeck.doctest&lt;/code&gt; 的文件：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;python3 -m doctest frenchdeck.py
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;文件内容为代码的分析：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;&amp;gt;&amp;gt;&amp;gt; from frenchdeck import FrenchDeck, Card
&amp;gt;&amp;gt;&amp;gt; beer_card = Card('7', 'diamonds')
&amp;gt;&amp;gt;&amp;gt; beer_card
Card(rank='7', suit='diamonds')
&amp;gt;&amp;gt;&amp;gt; deck = FrenchDeck()
&amp;gt;&amp;gt;&amp;gt; len(deck)
52
&amp;gt;&amp;gt;&amp;gt; deck[:3]
[Card(rank='2', suit='spades'), Card(rank='3', suit='spades'), Card(rank='4', suit='spades')]
&amp;gt;&amp;gt;&amp;gt; deck[12::13]
[Card(rank='A', suit='spades'), Card(rank='A', suit='diamonds'), Card(rank='A', suit='clubs'), Card(rank='A', suit='hearts')]
&amp;gt;&amp;gt;&amp;gt; Card('Q', 'hearts') in deck
True
&amp;gt;&amp;gt;&amp;gt; Card('Z', 'clubs') in deck
False
&amp;gt;&amp;gt;&amp;gt; for card in deck:  # doctest: +ELLIPSIS
...   print(card)
Card(rank='2', suit='spades')
Card(rank='3', suit='spades')
Card(rank='4', suit='spades')
...
&amp;gt;&amp;gt;&amp;gt; for card in reversed(deck):  # doctest: +ELLIPSIS
...   print(card)
Card(rank='A', suit='hearts')
Card(rank='K', suit='hearts')
Card(rank='Q', suit='hearts')
...
&amp;gt;&amp;gt;&amp;gt; for n, card in enumerate(deck, 1):  # doctest: +ELLIPSIS
...   print(n, card)
1 Card(rank='2', suit='spades')
2 Card(rank='3', suit='spades')
3 Card(rank='4', suit='spades')
...
&amp;gt;&amp;gt;&amp;gt; suit_values = dict(spades=3, hearts=2, diamonds=1, clubs=0)
&amp;gt;&amp;gt;&amp;gt; def spades_high(card):
...     rank_value = FrenchDeck.ranks.index(card.rank)
...     return rank_value * len(suit_values) + suit_values[card.suit]

Rank test:

&amp;gt;&amp;gt;&amp;gt; spades_high(Card('2', 'clubs'))
0
&amp;gt;&amp;gt;&amp;gt; spades_high(Card('A', 'spades'))
51

&amp;gt;&amp;gt;&amp;gt; for card in sorted(deck, key=spades_high):  # doctest: +ELLIPSIS
...      print(card)
Card(rank='2', suit='clubs')
Card(rank='2', suit='diamonds')
Card(rank='2', suit='hearts')
...
Card(rank='A', suit='diamonds')
Card(rank='A', suit='hearts')
Card(rank='A', suit='spades')
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;</description>
<pubDate>Thu, 11 Feb 2021 14:00:00 +0000</pubDate>
<dc:creator>Optics_css</dc:creator>
<og:description>以 Windows Subsystem for Linux 闯入 Visual Simultaneous Localization and Mapping 世界的艰难道路... 这里包含各种各样的 W</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/optics-css/p/14398226.html</dc:identifier>
</item>
<item>
<title>给你的SpringBoot项目定制一个牛年专属banner吧 - 三分恶</title>
<link>http://www.cnblogs.com/three-fighter/p/14398203.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/three-fighter/p/14398203.html</guid>
<description>&lt;center&gt;&lt;span&gt;新春快乐，牛年大吉！&lt;/span&gt;&lt;/center&gt;
&lt;p&gt;新的一年是牛年，在SpringBoot项目里自定义了一个牛年相关的banner，看起来可真不错。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/sanfene/picgo/raw/master/image-20210211205052600.png&quot; alt=&quot;image-20210211205052600&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面是自己制作的一个banner，相关的ASCII字符在文末。&lt;/p&gt;
&lt;p&gt;SpringBoot项目自定义banner非常简单，通过在classpath下添加一个banner.txt或设置banner.location来指定相应的文件可以改变启动过程中打印的banner。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;如果想以编程的方式产生一个banner，可以使用SpringBootApplication.setBanner(…)方法。使用org.springframework.boot.Banner接口，实现你自己的printBanner()方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;好了，接下来我们来看看怎么一步步制作牛年的专属banner。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在resource目录下创建 &lt;code&gt;banner.txt&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/sanfene/picgo/raw/master/image-20210211205807631.png&quot; alt=&quot;image-20210211205807631&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用图片转ASCII&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;博主从网上找了一张图片&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/sanfene/picgo/raw/master/image-20210211210628625.png&quot; alt=&quot;image-20210211210628625&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用图片转ASCII的网站有很多，博主尝试了不少，觉得比较好用的有下面几个：&lt;/p&gt;
&lt;p&gt;✔ &lt;a href=&quot;https://www.twitchquotes.com/ascii-art-generator&quot; target=&quot;_blank&quot;&gt;https://www.twitchquotes.com/ascii-art-generator&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;✔ &lt;a href=&quot;https://codebeautify.org/image-to-ascii-art&quot; target=&quot;_blank&quot;&gt;https://codebeautify.org/image-to-ascii-art&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;✔ &lt;a href=&quot;https://www.fontke.com/tool/image2ascii/&quot; target=&quot;_blank&quot;&gt;https://www.fontke.com/tool/image2ascii/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;博主使用是： &lt;a href=&quot;https://www.twitchquotes.com/ascii-art-generator&quot; target=&quot;_blank&quot;&gt;https://www.twitchquotes.com/ascii-art-generator&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/sanfene/picgo/raw/master/image-20210211210348738.png&quot; alt=&quot;image-20210211210348738&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上传图片，就可以看到生成的ASCII，将生成的ASCII粘贴到 &lt;code&gt;banner.txt&lt;/code&gt;中，启动发现banner已经变：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/sanfene/picgo/raw/master/image-20210211210528858.png&quot; alt=&quot;image-20210211210528858&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;⭐ AnsiColor：用来设定字符的前景色；&lt;/p&gt;
&lt;p&gt;⭐ AnsiBackground：用来设定字符的背景色。&lt;/p&gt;
&lt;p&gt;⭐ AnsiStyle：用来控制加粗、斜体、下划线等等。&lt;/p&gt;
&lt;p&gt;我们通过&lt;code&gt;{AnsiColor.BRIGHT_RED}&lt;/code&gt; 将字符设置为红色&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/sanfene/picgo/raw/master/image-20210211211109089.png&quot; alt=&quot;image-20210211211109089&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;文字部分就没什么好说的，自行添加。就是后面的文本没对齐，博主搞了半天也没有搞定，大过年的，不想搞了😂&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;添加SpringBoot版本信息，通过&lt;code&gt;${spring-boot.version}&lt;/code&gt; 可以获取SpringBoot版本号&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;${AnsiColor.BRIGHT_YELLOW}Spring Boot 版本：${spring-boot.version}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是博主的自定义banner，右边的文字一直对不齐，有解决办法的请在评论区评论，谢谢！&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;${AnsiColor.BRIGHT_RED}                                  升职加薪
钱     ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠠⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀                                          ⠀⠀⠀⠀⠀⠀
多      ⠀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠠⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀              身
事      ⠸⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢙⢂⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀              强
少      ⢸⣱⢄⣀⣀⣀⣀⣀ ⢀⣀⣠⢀⡀⣤⠤⣚⣼⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀           体
干      ⠀⠒⠿⣊⣇⣧⣾⣟⣝⣝⣿⣿⣜⡵⠵⢼⣊⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀            健
的     ⠀⠀⠀⠐⠺⠿⣿⠻⢟⣿⢍⢍⢻⣿⣿⣧⡞⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀             进
爽      ⠀⠀⠀⠀⠀⠀⣿⢠⣿⣿  ⣿⣴⣿⣿⣟⢷⣦⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀            步
      ⠀⠀⠀⠀⠀⢸⢿⡿⢿⣿⣿⣿ ⢫⣿⠏⢤⣿⠩⣝⣷⣤⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀  ⣠⣄⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀             快
      ⠀⠀⠀⠀⠀⣏⡃⣘⣃⣿⠿⢛⣡⣿⠿⢶⣿⣿⣷⣬⣍⣼⡟⢻⣟⢟⠿⣿⠿⢛⣿⠿⣿⠿⢳⣶⣿⡿⠛⠛⠿⣷⣄⠀⠀⠀⠀⠀⠀⠀
      ⠀⠀⠀⠀⠀⠈⠉⠛⠛⠻⡿⡻⡉⠡⡀⣿⣿⣿⣿⣿⣿⣿⣷⣾⣬⣥⣴⣿⣗⣿⠡⣷⡗⣼⡷⠛⡻⣷⡀⠀⠀⠈⠻⣦⣀⠀⡔⠒⠲⡇
      ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢿⡷⣷⡷⡿⣿⣿⣿⣿⣿⣿⣿⡍⠛⢛⢍⣽⠏⣼⠻⣜⣻⢟⣵⣷⠿⣿⢜⣧⠀⠀⠀⠀⠀⠉⠉⠑⠒⠊⠀
      ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣮⣠⣠⣴⠿⣿⣿⣿⣿⣿⣿⣿⣾⣼⣾⡿⢧⣽⣎⠿⠻⣻⡵⢻⣿⠏⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
      ⠀⠀⠀⠀⠀⠀⠀⠀⢀⣀⣸⡟⢹⣗⣽⠿⣿⣿⣿⣿⣿⣿⡿⣆⣌⠐⣰⣿⣄⣛⣿⣻⠛⢍⣼⣋⣵⠣⡟⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
      ⠀⠀⠀⠀⡤⡲⣴⢄⣯⣬⣿⣷⣄⣹⠅⣱⣿⣿⣿⣿⣿⣿⠌⢽⣿⡟⠛⡋⣹⡝⣷⣉⣻⣏⣉⣲⣿⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
      ⠀⠀⠀⠀⢨⡪⡭⢸⣿⠃⠀⠉⠙⠛⠳⢼⣿⣿⣿⣿⢻⢊⣢⣽⣋⣿⣾⠾⣟⣯⣷⣿⡻⢿⣿⣿⣿⣿⣿⣦⡀⢠⣀⣤⠀⠀⠀⡀⠀⠀
      ⠀⠛⣠⣃⣬⣿⣁⠀⣿⣗⣤⠀⡀⠀⠀⣜⢿⣿⠏⠉⠋⠉⠉⠉⠉⠀⠀⠀⠙⠿⣿⣿⣧⠀⠈⠙⠛⠿⣿⣯⣼⠀⡃⣣⣧⣤⣾⣇⠀⠀
      ⢀⣀⣴⡿⣺⡏⢻⣆⡈⠓⠻⠃⡐⠀⠀⣷⣿⠋⠀⠀⠀⠀⠀⣼⣵⠇⡀⠀⠀⠀⣸⣿⡭⠃⠀⠀⠀⠀⠈⠻⣿⡄⠀⠿⣯⣖⡽⠃⠀⠀
      ⢨⣵⣭⣽⡗⡟⢿⣶⣿⡄⠀⠀⠀⠀⢠⣿⡇⠀⠀⠀⠙⡒⣥⣄⡘⠍⠀⢀⣠⣼⡿⠋⠀⠀⠀⠀⠀⠀⠀⠀⢹⣷⡀⠠⢵⠸⣤⣀⠀⠀
      ⠀⠉⢈⣋⣦⣴⡄⢉⣰⣲⡂⠀⠀⢰⣭⡽⠂⠀⠀⠀⠈⠀⠐⠻⢽⠿⡳⠶⡾⠛⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣯⣵⠣⣟⣆⡃⠧⣾⡅⠀
      ⠀⠀⠙⠻⠿⠛⠉⠑⠋⠉⠀⠀⠪⣀⣉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠚⠀⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠠⣱⣀⡁⠀⠀⠃
${AnsiColor.BRIGHT_YELLOW}Spring Boot 版本：${spring-boot.version}

&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;big&gt;&lt;strong&gt;参考：&lt;/strong&gt;&lt;/big&gt;&lt;/p&gt;
&lt;p&gt;【1】：&lt;a href=&quot;https://www.jianshu.com/p/a53f324c92f2&quot; target=&quot;_blank&quot;&gt;Spring Boot自定义Banner&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【2】：&lt;a href=&quot;https://doc.yonyoucloud.com/doc/Spring-Boot-Reference-Guide/IV.%20Spring%20Boot%20features/22.1.%20Customizing%20the%20Banner.html&quot; target=&quot;_blank&quot;&gt;22.1. 自定义Banner&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 11 Feb 2021 13:33:00 +0000</pubDate>
<dc:creator>三分恶</dc:creator>
<og:description>新春快乐，牛年大吉！ 新的一年是牛年，在SpringBoot项目里自定义了一个牛年相关的banner，看起来可真不错。 上面是自己制作的一个banner，相关的ASCII字符在文末。 SpringBo</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/three-fighter/p/14398203.html</dc:identifier>
</item>
<item>
<title>KafkaConsumer 简析  - buttercup</title>
<link>http://www.cnblogs.com/buttercup/p/14208062.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/buttercup/p/14208062.html</guid>
<description>&lt;p&gt;创建一个 KafkaConsumer 对象订阅主题并开始接收消息：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;  Properties properties = new Properties();
  properties.setProperty(&quot;bootstrap.servers&quot;, &quot;localhost:9092&quot;);
  properties.setProperty(&quot;key.deserializer&quot;, &quot;org.apache.kafka.common.serialization.StringDeserializer&quot;);
  properties.setProperty(&quot;value.deserializer&quot;, &quot;org.apache.kafka.common.serialization.StringDeserializer&quot;);
  properties.setProperty(&quot;enable.auto.commit&quot;, &quot;false&quot;); // 禁止自动提交
  properties.setProperty(&quot;group.id&quot;, &quot;my-group-id&quot;); // 设置消费者组群ID

  KafkaConsumer&amp;lt;String, String&amp;gt; consumer = new KafkaConsumer&amp;lt;&amp;gt;(properties);
  consumer.subscribe(Collections.singletonList(&quot;topic&quot;)); // 订阅主题
  try {
      while (! Thread.currentThread().isInterrupted()) {
          ConsumerRecords&amp;lt;String, String&amp;gt; records = consumer.poll(1000);
          records.forEach(System.out::println);
          consumer.commitAsync(); // 异步提交偏移量
      }
  } catch (WakeupException ignore) {
      // 忽略关闭异常
  } finally {
      try {
          consumer.commitSync(); // 同步提交偏移量
      } finally {
          consumer.close();
      }
  }

  Thread thread = Thread.currentThread();
  Runtime.getRuntime().addShutdownHook(new Thread(() -&amp;gt; {
      consumer.wakeup();
      try {
          thread.join();
      } catch (InterruptedException ignore) {}
  }));
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;为了实现横向扩展，应用程序需要创建一个消费者群组，然后往群组里添加消费者来提高处理效率，群组里的每个消费者只处理一部分消息：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/buttercup/1776821/o_201227141125kafka_consume_partition1.gif&quot; width=&quot;255&quot;/&gt;&lt;img src=&quot;data:image/bmp;base64,Qk1CAAAAAAAAAD4AAAAoAAAAAQAAAAEAAAABAAEAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP///wCAAAAA&quot; width=&quot;30&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/buttercup/1776821/o_201222150647kafka_consume_partition.gif&quot; width=&quot;255&quot;/&gt;&lt;img src=&quot;data:image/bmp;base64,Qk1CAAAAAAAAAD4AAAAoAAAAAQAAAAEAAAABAAEAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP///wCAAAAA&quot; width=&quot;30&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/buttercup/1776821/o_201227141312kafka_consume_partition3.gif&quot; width=&quot;215&quot;/&gt;&lt;/center&gt;
&lt;p&gt;一个群组里的消费者订阅的是同一个主题，每个消费者接收主题一部分分区的消息（&lt;strong&gt;左图&lt;/strong&gt;）。&lt;br/&gt;消费者无法跟上数据生成的速度，可以向组群内增加更多的消费者分担负载，是消费端横向伸缩的主要手段（&lt;strong&gt;中图&lt;/strong&gt;）。&lt;br/&gt;预先为主题预留的分区可以在负载增长时增加更多的消费者，不过当消费者的数量超过主题分区时，多余的消费者只会被闲置（&lt;strong&gt;右图&lt;/strong&gt;）。&lt;/p&gt;
&lt;p&gt;只要保证每个应用程序有独立的消费者群组，就可以让它们获取到主题所有的消息，而不只是其中的一部分：&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/buttercup/1776821/o_201222150659kafka_consume_partition2.gif&quot; width=&quot;255&quot;/&gt;&lt;/p&gt;

&lt;p&gt;为了保证调用&lt;code&gt;KafkaConsumer.poll()&lt;/code&gt;方法时总能返回未被被消费者读取过的记录，消费者需要维护每个分区中已读消息对应的&lt;strong&gt;偏移量&lt;/strong&gt;&lt;code&gt;offset&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;一旦消费者发生崩溃或者有新的消费者加入群组，就会触发&lt;strong&gt;再均衡&lt;/strong&gt;&lt;code&gt;rebalance&lt;/code&gt;，每个消费者可能分配到新的分区，而不是之前处理的那个。为了能够继续之前的工作，消费者需要知道每个分区的已读偏移量，然后从偏移量指定的地方继续处理。&lt;/p&gt;
&lt;p&gt;为了保证这些信息不丢失，消费者需要定期向一个名为 &lt;code&gt;_consumer_offset&lt;/code&gt; 的特殊主题发送消息，消息里包含每个分区的偏移量。Kafka 中将这一更新的操作称作&lt;strong&gt;提交&lt;/strong&gt;&lt;code&gt;commit&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;边界情况&quot;&gt;边界情况&lt;/h3&gt;
&lt;p&gt;如果提交的偏移量小于客户端处理的最后一个消息的偏移量，那么处于两个偏移量之间的消息就会被重复处理：&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/buttercup/1776821/o_201222150712kafka_consume_offset.gif&quot; width=&quot;400&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果提交的偏移量大于客户端处理的最后一个消息的偏移量，那么处于两个偏移量之间的消息将会丢失：&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/buttercup/1776821/o_201222150717kafka_consume_offset2.gif&quot; width=&quot;400&quot;/&gt;&lt;/p&gt;
&lt;p&gt;处理偏移量的方式对客户端会有很大的影响，下面分析几种常见的提交方式：&lt;/p&gt;
&lt;h3 id=&quot;自动提交&quot;&gt;自动提交&lt;/h3&gt;
&lt;p&gt;最简单的提交方式是让消费者自动提交偏移量：设置 &lt;code&gt;enable.auto.commit = true&lt;/code&gt;，那么每过 &lt;code&gt;auto.commit.interval.ms&lt;/code&gt;，消费者会自动把从&lt;code&gt;KafkaConsumer.poll()&lt;/code&gt;方法接收到的最大偏移量提交上去。&lt;/p&gt;
&lt;p&gt;自动提交是在轮询里进行的：&lt;strong&gt;消费者每次在进行轮询时会检查是否该提交偏移量，并且自动提交最近一次轮询返回的偏移量&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;不过，在使用这种简便的方式之前，需要知道它将会带来怎样的结果：&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;假设在两次提交间隔之间发生了再均衡，期间的消息会被重复处理。&lt;br/&gt;可以通过修改提交时间间隔来减小可能出现重复消息的时间窗，不过无法完全避免这种情况。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;每次调用轮询方法都会提交上一次调用返回的偏移量，而并不关心具体哪些消息已经被处理了。&lt;br/&gt;在再次调用之前，最好确保所有当前已返回消息都已经处理完毕（调用&lt;code&gt;KafkaConsumer.close()&lt;/code&gt; 前也会进行自动提交）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;手动提交&quot;&gt;手动提交&lt;/h3&gt;
&lt;p&gt;自动提交虽然方便，不过并没有为开发者留有余地来避免重复处理消息。为了提高可控性，开发者可以设置 &lt;code&gt;enable.auto.commit = false&lt;/code&gt;，让应用程序决定何时提交偏移量。&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;同步提交：使用 &lt;code&gt;KafkaConsumer.commitSync()&lt;/code&gt; 会提交最新偏移量并等待 broker 对提交请求作出回应。&lt;br/&gt;在成功提交或碰到无法恢复的错误之前会不断重试，会导致应用程序一直阻塞，限制了应用程序的吞吐量。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;异步提交：使用 &lt;code&gt;KafkaConsumer.commitAsync()&lt;/code&gt; 会提交最新偏移量但无需等待 broker 的响应并且不进行重试。&lt;br/&gt;不进行重试，是因为可能有一个更大的偏移量已经提交成功，重试可能会覆盖到最新的值，导致再均衡后出现重复消息。&lt;br/&gt;该方法在 broker 作出响应时会执行用户指定的回调，回调经常被用于记录提交错误或生成度量指标。&lt;br/&gt;不过如果要在其中进行重试，一定要注意提交的顺序。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;一般情况下，偶尔异步提交失败不会有太大问题，后续的提交总会有成功的。但在关闭消费者或再均衡前的最后一次提交，必须确保提交成功。为了保证可靠性与吞吐量，比较常见的方式是将两者组合使用（具体参考开头的代码示例）。&lt;/p&gt;
&lt;h3 id=&quot;提交特定偏移量&quot;&gt;提交特定偏移量&lt;/h3&gt;
&lt;p&gt;上面讨论的提交方式中，提交偏移量的频率与处理消息批次的频率是一样的，但某些场景需要在更细的粒度上控制提交：如果&lt;code&gt;KafkaConsumer.poll()&lt;/code&gt;方法返回一大批数据，为了避免因再均衡引起的重复处理整批消息，我们希望能在批次处理中间提交部分偏移量。&lt;/p&gt;
&lt;p&gt;此时，可以在调用&lt;code&gt;KafkaConsumer.commitSync()&lt;/code&gt;或&lt;code&gt;KafkaConsumer.commitAsync()&lt;/code&gt;时，通过参数指定具体的分区及其对应的偏移量，人为地控制提交内容。&lt;/p&gt;

&lt;p&gt;群组里的消费者共同读取主题的分区，消费过程中可能出现以下情况：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;新的消费者加入群组，它会被分配到一个原本由其他消费者读取的分区&lt;/li&gt;
&lt;li&gt;当前消费者离开群组，原本由它读取的分区将分配给群组里的其他消费者&lt;/li&gt;
&lt;li&gt;订阅主题发生变化时，比如管理员添加了新的分区，会发生分区重分配&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;分区的所有权从一个消费者转移到另一个消费者，这样的行为被称为&lt;strong&gt;再均衡&lt;/strong&gt;&lt;code&gt;rebalance&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;再均衡非常重要，它为消费者群组带来了高可用性和伸缩性（支持动态添加或移除消费者）。&lt;br/&gt;但是，再均衡整个群组会一小段时间不可用，期间消费者无法读取消息，在恢复之前会拖慢应用程序。&lt;/p&gt;
&lt;h3 id=&quot;消费者分代&quot;&gt;消费者分代&lt;/h3&gt;
&lt;p&gt;消费者组群可以进行任意次再均衡，为了更好地隔离已失效的状态（比如：避免僵尸实例提交过期的偏移量），Kafka 消费者端引入了&lt;strong&gt;分代&lt;/strong&gt;&lt;code&gt;generation&lt;/code&gt;的概念。&lt;/p&gt;
&lt;p&gt;消费者的分代信息是一个整数，每当组群进行一次 rebalance 操作，组内所有消费者的 generation 都会递增。当消费者提交偏移时会伴随着 generation 信息，当 broker 会据此判断消息是否来源于一个上一代的消费者，并拒绝过期的提交。&lt;/p&gt;
&lt;h3 id=&quot;在均衡监听器&quot;&gt;在均衡监听器&lt;/h3&gt;
&lt;p&gt;如果消费者想在再均衡前后做一些清理工作或准备工作，只需在调用 &lt;code&gt;KafkaConsumer.subscribe()&lt;/code&gt; 方法时传进去一个 &lt;code&gt;ConsumerRebalanceListener&lt;/code&gt; 实例即可：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;  private Map&amp;lt;TopicPartition, OffsetAndMetadata&amp;gt; offsets = new HashMap&amp;lt;&amp;gt;();

  KafkaConsumer&amp;lt;String, String&amp;gt; consumer = new KafkaConsumer&amp;lt;&amp;gt;(properties);

  // 订阅时注册再均衡监听器
  consumer.subscribe(Collections.singletonList(&quot;topic&quot;), new ConsumerRebalanceListener(){

      /** 方法会在重新分配分区之后和消费者开始读取消息之前被调用 */
      @Override
      public void onPartitionsAssigned(Collection&amp;lt;TopicPartition&amp;gt; partitions) {
          // 从特定的偏移量处开始读取消息
          offsets.entrySet().stream().
                  filter(e -&amp;gt; partitions.contains(e.getKey())).
                  forEach(e -&amp;gt; consumer.seek(e.getKey(), e.getValue().offset()));
      }

      /** 方法会在再均衡开始之前和消费者停止读取消息之后被调用 */
      @Override
      public void onPartitionsRevoked(Collection&amp;lt;TopicPartition&amp;gt; partitions) {
          consumer.commitSync(offsets); // 提交已经数据对应的偏移量
      }
  });

  ConsumerRecords&amp;lt;String, String&amp;gt; records = consumer.poll(1000);
  for (ConsumerRecord&amp;lt;String, String&amp;gt; record : records) {
      // 消息处理过程中，实时更新偏移量变化
      offsets.put(
              new TopicPartition(record.topic(), record.partition()),
              new OffsetAndMetadata(record.offset() + 1));
  }
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;消费者管理由两部分组成：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;成员管理&lt;/strong&gt;：管理组内所有 consumer 实例生命周期并负责下发分区分配方案到每个 consumer。&lt;br/&gt;该功能依赖于一个被选为组协调者&lt;code&gt;coordinator&lt;/code&gt;的 broker。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;分区分配&lt;/strong&gt;：根据指定的分区分配策略制定分配方案并上报 coordinator。&lt;br/&gt;该功能由一个 leader consumer 负责。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;分区分配的操作是在 consumer 端执行的好处主要有以下两点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;便于维护与升级: 调整分配策略时，无需重启整 broker 集群。&lt;/li&gt;
&lt;li&gt;便于实现自定义策略：代码实现更为灵活，可以依赖外部存储维护复杂策略，甚至实现机架感知。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;变更流程&quot;&gt;变更流程&lt;/h3&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://cwiki.apache.org/confluence/download/attachments/61312126/consumer.png?version=3&amp;amp;modificationDate=1443760073000&amp;amp;api=v2%20width=&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;初始化&quot;&gt;初始化&lt;/h4&gt;
&lt;div class=&quot;paper&quot; readability=&quot;8&quot;&gt;consumer 启动时，首先要确定组群 coordinator 所在的 broker 节点，并建立 socket 连接。选择 coordinator 的规则如下：
&lt;ul&gt;&lt;li&gt;根据 $\tiny \texttt{_consumer_offset}$ 主题的分区数量 $\tiny \texttt{n}$ 计算 $\tiny \texttt{hashmod(group.id, n)}$&lt;/li&gt;
&lt;li&gt;选择第 $\tiny \texttt{hashmod(group.id, n)}$ 个 $\tiny \texttt{_consumer_offset}$ 分区的 leader broker 作为 coordinator&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;h4 id=&quot;加入组群&quot;&gt;加入组群&lt;/h4&gt;
&lt;p&gt;所有 consumer 向 coordinator 发送&lt;code&gt;JoinGroup&lt;/code&gt;请求。&lt;br/&gt;coordinator 会从中选择一个组群 leader consumer，并把所有成员信息以及它们的订阅信息发送给这个 leader consumer。&lt;/p&gt;
&lt;h4 id=&quot;规划分配方案&quot;&gt;规划分配方案&lt;/h4&gt;
&lt;p&gt;leader consumer 根据用户指定的分配策略决定分区分配方案，并通过&lt;code&gt;SyncGroup&lt;/code&gt;请求将方案中发送给 coordinator。&lt;br/&gt;其他 consumer 也会向 coordinator 发送不包含分区方案的&lt;code&gt;SyncGroup&lt;/code&gt;请求，然后 coordinator 会将分区方案返回给这些 consumer。&lt;/p&gt;
&lt;h4 id=&quot;发送心跳&quot;&gt;发送心跳&lt;/h4&gt;
&lt;p&gt;consumer 会在轮询消息或提交偏移量时向 coordinator 发送&lt;code&gt;Heartbeat&lt;/code&gt;请求，维持它们和群组会话&lt;code&gt;session&lt;/code&gt;以及对分区的所有权。&lt;br/&gt;当 coordinator 长时间未接收到 consumer 的心请求时，会认为 consumer 已失效并触发一次再均衡。&lt;br/&gt;若 coordinator 在心跳响应中返回了 &lt;strong&gt;REBALANCE_IN_PROGRESS&lt;/strong&gt; 信息，意味着当前组群已经开启了新一轮的再均衡。&lt;/p&gt;
&lt;h4 id=&quot;离开组群&quot;&gt;离开组群&lt;/h4&gt;
&lt;p&gt;consumer 退出时会主动发送&lt;code&gt;LeaveGroup&lt;/code&gt;告知 coordinator 它将要离开群组，并立即触发一次再均衡，尽可能降低处理停顿。&lt;/p&gt;

&lt;h4 id=&quot;clientid&quot;&gt;&lt;strong&gt;client.id&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;　该属性可以是任意字符串，broker 用它来标识从客户端发送过来的消息，通常被用在日志、度量指标和配额里。&lt;/p&gt;
&lt;h4 id=&quot;groupid&quot;&gt;&lt;strong&gt;group.id&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;　标识消费者所属的消费者组群的唯一字符串。&lt;br/&gt;　如果消费者需要基于组群的对订阅进行管理，或基于 Kafka 管理偏移量时，需要指定此属性。&lt;/p&gt;
&lt;h4 id=&quot;bootstrapservers&quot;&gt;&lt;strong&gt;bootstrap.servers&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;　该属性指定 broker 的地址列表。&lt;br/&gt;　清单里不需要包含所有的 broker 地址，生产者会从给定的 broker 里查找到其他 broker 的信息。&lt;br/&gt;　不过建议至少要提供两个 broker 的信息，一旦其中一个宕机，生产者仍然能够连接到集群上。&lt;/p&gt;
&lt;h4 id=&quot;keydeserializer--valuedeserializer&quot;&gt;&lt;strong&gt;key.deserializer &amp;amp; value.deserializer&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;　这两个属性必须被设置为一个实现了&lt;code&gt;org.apache.kafka.common.serialization.Deserializer&lt;/code&gt;接口的类。&lt;br/&gt;　生产者会使用这个类把键值字节数组反序列化成对象。&lt;/p&gt;
&lt;h4 id=&quot;receivebufferbytes--sendbufferbytes&quot;&gt;&lt;strong&gt;receive.buffer.bytes &amp;amp; send.buffer.bytes&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;　设置 socket 读写数据时用到的 TCP 缓冲区大小。如果它们被设为 -1，就使用操作系统的默认值。&lt;br/&gt;　当生产者或消费者与 broker 处于不同的机房时，可以适当&lt;a href=&quot;https://www.cnblogs.com/buttercup/p/13812221.html#%E9%95%BF%E8%82%A5%E7%AE%A1%E9%81%93-lfn&quot; target=&quot;_blank&quot;&gt;增大这些值&lt;/a&gt;。&lt;/p&gt;
&lt;h4 id=&quot;fetchminbytes&quot;&gt;&lt;strong&gt;fetch.min.bytes&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;该属性指定了消费者从服务器获取记录的最小字节数。&lt;br/&gt;broker 在收到消费者的数据请求时，如果可用的数据量小于该配置，那么它会等到有足够的可用数据时一并返回给消费者。&lt;/p&gt;
&lt;p&gt;如果消费者的数量比较多，把该属性的值设置得大一点可以降低 broker 的工作负载。&lt;br/&gt;或当消费者订阅的主题不活跃时，消费者的 CPU 使用率却很高，可以适当调大该值。&lt;/p&gt;
&lt;h4 id=&quot;fetchmaxwaitms&quot;&gt;&lt;strong&gt;fetch.max.wait.ms&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;　该属性指定了可用数据量不足时 broker 的等待时间。&lt;br/&gt;　如果没有足够的数据流入 Kafka，消费者获取最小数据量的要求就得不到满足，最终导致&lt;code&gt;fetch.max.wait.ms&lt;/code&gt;的延迟。&lt;br/&gt;　如果要降低潜在的延迟（为了满足 SLA），可以把该参数值设置得小一些。&lt;/p&gt;
&lt;h4 id=&quot;maxpollrecords&quot;&gt;&lt;strong&gt;max.poll.records&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;　该属性用于控制单次调用&lt;code&gt;KafkaConsumer.poll()&lt;/code&gt;方法能够返回的记录数量。&lt;br/&gt;　可以借助该配置控制在轮询里需要处理的数据量。&lt;/p&gt;
&lt;h4 id=&quot;maxpartitionfetchbytes&quot;&gt;&lt;strong&gt;max.partition.fetch.bytes&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;　该属性指定了&lt;code&gt;KafkaConsumer.poll()&lt;/code&gt; 方法从每个分区里返回的最大字节数。&lt;br/&gt;　消费者需要保证 &lt;strong&gt;&lt;code&gt;max.partition.fetch.bytes&lt;/code&gt; * 消费分区数量&lt;/strong&gt; 可用内存来接收记录。&lt;br/&gt;　在为消费者分配内存时，可以给它们多分配一些，因为如果群组里有消费者发生崩溃，剩下的消费者需要处理更多的分区。&lt;/p&gt;
&lt;p&gt;　该值必须比 broker 能够接收的最大消息的字节数&lt;code&gt;max.message.size&lt;/code&gt;大，否则消费者可能无法读取这些消息，导致消费者一直挂起重试。&lt;/p&gt;
&lt;p&gt;　在设置该属性时，另一个需要考虑的因素是消费者处理数据的时间。&lt;/p&gt;
&lt;p&gt;　消费者需要频繁调用 &lt;code&gt;KafkaConsumer.poll()&lt;/code&gt; 方法来避免会话过期和发生分区再均衡，如果单次调用返回的数据太多，消费者需要更多的时间来处理，可能无法及时进行下一个轮询来避免会话过期。&lt;/p&gt;
&lt;p&gt;　如果出现这种情况，可以把该值改小，或者延长会话过期时间。&lt;/p&gt;
&lt;h4 id=&quot;sessiontimeoutms&quot;&gt;&lt;strong&gt;session.timeout.ms&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;　该属性指定了消费者在被认为下线之前可以与服务器断开连接的时间。&lt;/p&gt;
&lt;p&gt;　如果消费者没有在指定的时间内发送心跳给群组协调器，会被认为已经下线。&lt;br/&gt;　协调器就会触发再均衡，把它的分区分配给群组里的其他消费者。&lt;/p&gt;
&lt;p&gt;　该值越小，可以更快地检测和恢复崩溃的节点，但可能导致非预期的再均衡。&lt;br/&gt;　该值越大，可以减少意外的再均衡，不过检测节点崩溃需要更长的时间。&lt;/p&gt;
&lt;p&gt;　该属性与&lt;code&gt;heartbeat.interval.ms&lt;/code&gt;紧密相关：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;heartbeat.interval.ms&lt;/code&gt; 指定了 poll() 方法向协调器发送心跳的频率。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;session.timeout.ms&lt;/code&gt; 则指定了消费者可以多久不发送心跳。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　一般需要同时修改这两个属性，heartbeat.interval.ms 一般设置为 session.timeout.ms 的三分之一。&lt;/p&gt;
&lt;h4 id=&quot;autooffsetreset&quot;&gt;&lt;strong&gt;auto.offset.reset&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;　该属性指定了消费者在读取一个没有偏移量的分区或者偏移量失效时（包含偏移量的记录已过时并被删除）该作何处理。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;latest&lt;/code&gt; 在偏移量无效的情况下，消费者将从最新的记录开始读取数据（在消费者启动之后生成的记录）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;earliest&lt;/code&gt; 在偏移量无效的情况下，消费者将从起始位置读取分区的记录。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;enableautocommit&quot;&gt;&lt;strong&gt;enable.auto.commit&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;　该属性指定了消费者是否自动提交偏移量（可以通过配置&lt;code&gt;auto.commit.interval.ms&lt;/code&gt;来控制提交的频率）。&lt;br/&gt;　为了尽量避免出现重复数据和数据丢失，可以把它设为 false ，由自己控制何时提交偏移量。&lt;/p&gt;
&lt;h4 id=&quot;partitionassignmentstrategy&quot;&gt;&lt;strong&gt;partition.assignment.strategy&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;　这两个属性必须被设置为一个实现了&lt;code&gt;org.apache.kafka.clients.consumer.internals.PartitionAssignor&lt;/code&gt;接口的类。&lt;br/&gt;　消费协调者&lt;code&gt;ConsumerCoordinator&lt;/code&gt;会使用这个类，根据给定的消费者和主题，决定哪些分区应该被分配给哪个消费者。&lt;/p&gt;
&lt;p&gt;　Kafka 默认的分配策略：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;org.apache.kafka.clients.consumer.RangeAssignor&lt;/code&gt; &lt;strong&gt;把主题的若干个连续的分区分配给消费者&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;org.apache.kafka.clients.consumer.RoundRobinAssignor&lt;/code&gt; &lt;strong&gt;把主题的所有分区逐个分配给消费者&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;org.apache.kafka.clients.consumer.StickyAssignor&lt;/code&gt; &lt;strong&gt;尽可保证分配平衡的前提下减少再均衡造成的变更&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Thu, 11 Feb 2021 08:19:00 +0000</pubDate>
<dc:creator>buttercup</dc:creator>
<og:description>使用方式 创建一个 KafkaConsumer 对象订阅主题并开始接收消息： Properties properties = new Properties(); properties.setPrope</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/buttercup/p/14208062.html</dc:identifier>
</item>
<item>
<title>Java RMI 实现一个简单的GFS（谷歌文件系统）——介绍篇  - 晨星1032</title>
<link>http://www.cnblogs.com/maogen/p/gfs_0.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/maogen/p/gfs_0.html</guid>
<description>&lt;p&gt;本系列主要是使用Java RMI 实现一个简单的GFS（谷歌文件系统，google file system）。首先进行整体介绍，然后对背景进行描述以及对系统进行设计，同时实现系统，提供演示视频和源代码，望多多支持！&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;68.253080082136&quot;&gt;
&lt;p&gt;本系列主要是使用Java RMI实现一个简单的GFS（谷歌文件系统，google file system），首先整体简单介绍下该项目。&lt;/p&gt;
&lt;blockquote readability=&quot;3.6545454545455&quot;&gt;
&lt;p&gt;[为了更好的阅读以及查看其他篇章，请查看原文：&lt;a href=&quot;https://www.cnblogs.com/maogen/p/gfs_0.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/maogen/p/gfs_0.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;🏮祝大家除夕快乐！🏮&lt;/p&gt;
&lt;p&gt;✨新的一年，祝大家身体安康，得偿所愿，并拥有所有的晴天和美梦✨&lt;/p&gt;
&lt;p&gt;🌙 🌘 🌗 🌖 🌕ᵀᴴᴱ ᴮᴱˢᵀ ᴵˢ ᶠᴼᴿ ᵞᴼᵁ&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;系统&lt;strong&gt;背景和设计&lt;/strong&gt;、系统实现、&lt;strong&gt;演示视频&lt;/strong&gt;以及&lt;strong&gt;源代码&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;背景与设计篇：&lt;/code&gt;&lt;/strong&gt;待更新，请关注作者博客园&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;演示与实现篇：&lt;/code&gt;&lt;/strong&gt;待更新，请关注作者博客园&lt;/p&gt;
&lt;blockquote readability=&quot;2.5396825396825&quot;&gt;
&lt;p&gt;作者：晨星1032-博客园：&lt;a href=&quot;https://www.cnblogs.com/maogen/&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/maogen/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/maogen_ymg/img-host/raw/master/ppt_gfs_%201.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/maogen_ymg/img-host/raw/master/ppt_gfs_%202.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/maogen_ymg/img-host/raw/master/ppt_gfs_%203.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/maogen_ymg/img-host/raw/master/ppt_gfs_%204.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/maogen_ymg/img-host/raw/master/ppt_gfs_%205.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/maogen_ymg/img-host/raw/master/ppt_gfs_%206.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/maogen_ymg/img-host/raw/master/ppt_gfs_%207.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/maogen_ymg/img-host/raw/master/ppt_gfs_%208.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/maogen_ymg/img-host/raw/master/ppt_gfs_%209.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/maogen_ymg/img-host/raw/master/ppt_gfs_%2010.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;blockquote readability=&quot;2.5396825396825&quot;&gt;
&lt;p&gt;作者：晨星1032-博客园：&lt;a href=&quot;https://www.cnblogs.com/maogen/&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/maogen/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;系统&lt;strong&gt;背景和设计&lt;/strong&gt;、系统实现、&lt;strong&gt;演示视频&lt;/strong&gt;以及&lt;strong&gt;源代码&lt;/strong&gt;，尽在其他篇章：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;背景与设计篇：&lt;/code&gt;&lt;/strong&gt;待更新，请关注作者博客园&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;演示与实现篇：&lt;/code&gt;&lt;/strong&gt;待更新，请关注作者博客园&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Thu, 11 Feb 2021 07:36:00 +0000</pubDate>
<dc:creator>晨星1032</dc:creator>
<og:description>本系列主要是使用Java RMI 实现一个简单的GFS（谷歌文件系统，google file system）。首先进行整体介绍，然后对背景进行描述以及对系统进行设计，同时实现系统，提供演示视频和源代码</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/maogen/p/gfs_0.html</dc:identifier>
</item>
<item>
<title>设计模式（二十二）——状态模式（APP抽奖活动+借贷平台源码剖析） - 十四lin</title>
<link>http://www.cnblogs.com/linzm14/p/14394072.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/linzm14/p/14394072.html</guid>
<description>
&lt;h2&gt;24.1 APP 抽奖活动问题&lt;/h2&gt;

&lt;p&gt;&lt;span&gt;请编写程序完成&lt;/span&gt; APP &lt;span&gt;抽奖活动&lt;/span&gt; &lt;span&gt;具体要求如下&lt;/span&gt;:&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;1) &lt;span&gt;假如每参加一次这个活动要扣除用户&lt;/span&gt; 50 &lt;span&gt;积分，中奖概率是&lt;/span&gt; 10%&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;2) 奖品数量固定，抽完就不能抽奖&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;3) 活动有四个状态: 可以抽奖、不能抽奖、发放奖品和奖品领完&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;4) 活动的四个状态转换关系图(下图)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2257481/202102/2257481-20210209200023521-1326717358.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;24.1 状态模式基本介绍&lt;/h2&gt;
&lt;p&gt;基本介绍&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;1) 状态模式（&lt;strong&gt;State&lt;/strong&gt;&lt;strong&gt; &lt;/strong&gt;&lt;strong&gt;Pattern&lt;/strong&gt;）：它主要用来解决对象在多种状态转换时，需要对外输出不同的行为的问题。状态和行为是一一对应的，状态之间可以相互转换&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;2) 当一个对象的内在状态改变时，允许改变其行为，这个对象看起来像是改变了其类&lt;/p&gt;
&lt;h2&gt;24.2 状态模式的原理类图&lt;/h2&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/2257481/202102/2257481-20210209200113834-1787430638.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;ul&gt;&lt;li&gt;对原理类图的说明-即(状态模式的角色及职责)&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;15&quot;&gt;1) Context 类为环境角色,  &lt;span&gt;用于维护&lt;/span&gt; State 实例,这个实例定义当前状态&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;2) State 是抽象状态角色,&lt;span&gt;定义一个接口封装与&lt;/span&gt; Context  的一个特点接口相关行为&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;3) ConcreteState &lt;span&gt;具体的状态角色，每个子类实现一个与&lt;/span&gt; Context 的一个状态相关行为&lt;/p&gt;
&lt;h2&gt;24.1 &lt;span&gt;状态模式解决&lt;/span&gt; APP 抽奖问&lt;/h2&gt;
&lt;p class=&quot;15&quot;&gt;1) 应用实例要求&lt;/p&gt;
&lt;p&gt;&lt;span&gt;完成&lt;/span&gt; APP 抽奖活动项目，使用状态模式.&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;2) 思路分析和图解(类图)&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;定义出一个接口叫状态接口，每个状态都实现它。&lt;/li&gt;
&lt;li&gt;接口有扣除积分方法、抽奖方法、发放奖品方法&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2257481/202102/2257481-20210209173626128-621451376.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3)代码实现&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2257481/202102/2257481-20210209200245133-1613553894.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.lin.state;
    
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 状态抽象类
     * 
     * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Administrator
     *
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; State {

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 扣除积分 - 50&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; deductMoney();

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 是否抽中奖品&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; raffle();

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 发放奖品&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; dispensePrize();

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.lin.state;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 抽奖活动 //
 *
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Administrator
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RaffleActivity {

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; state 表示活动当前的状态，是变化&lt;/span&gt;
    State state = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 奖品数量&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; count = 0&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 四个属性，表示四种状态&lt;/span&gt;
    State noRafflleState = &lt;span&gt;new&lt;/span&gt; NoRaffleState(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
    State canRaffleState &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; CanRaffleState(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);

    State dispenseState &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; DispenseState(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
    State dispensOutState &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; DispenseOutState(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 构造器
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1. 初始化当前的状态为 noRafflleState（即不能抽奖的状态）
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2. 初始化奖品的数量&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; RaffleActivity(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; count) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.state =&lt;span&gt; getNoRafflleState();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.count =&lt;span&gt; count;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 扣分, 调用当前状态的 deductMoney&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; debuctMoney() {
        state.deductMoney();

    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 抽奖&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; raffle() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果当前的状态是抽奖成功&lt;/span&gt;

        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (state.raffle()) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 领取奖品state.dispensePrize();&lt;/span&gt;
&lt;span&gt;        }

    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; State getState() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; state;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setState(State state) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.state =&lt;span&gt; state;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这里请大家注意，每领取一次奖品，count--&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getCount() {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; curCount =&lt;span&gt; count;
        count&lt;/span&gt;--&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; curCount;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setCount(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; count) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.count =&lt;span&gt; count;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; State getNoRafflleState() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; noRafflleState;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setNoRafflleState(State noRafflleState) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.noRafflleState =&lt;span&gt; noRafflleState;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; State getCanRaffleState() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; canRaffleState;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setCanRaffleState(State canRaffleState) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.canRaffleState =&lt;span&gt; canRaffleState;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; State getDispenseState() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; dispenseState;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setDispenseState(State dispenseState) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.dispenseState =&lt;span&gt; dispenseState;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; State getDispensOutState() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; dispensOutState;

    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setDispensOutState(State dispensOutState) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.dispensOutState =&lt;span&gt; dispensOutState;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.lin.state;


    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
    *不能抽奖状态
    *&lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Administrator
    *
    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; NoRaffleState &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; State {

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始化时传入活动引用，扣除积分后改变其状态&lt;/span&gt;
&lt;span&gt;    RaffleActivity activity;


    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; NoRaffleState(RaffleActivity activity) { 
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.activity =&lt;span&gt; activity;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当前状态可以扣积分 , 扣除后，将状态设置成可以抽奖状态&lt;/span&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; deductMoney() {
        System.out.println(&lt;/span&gt;&quot;扣除 50 积分成功，您可以抽奖了&quot;&lt;span&gt;); activity.setState(activity.getCanRaffleState());
    }


    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当前状态不能抽奖&lt;/span&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; raffle() {
        System.out.println(&lt;/span&gt;&quot;扣了积分才能抽奖喔！&quot;); &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当前状态不能发奖品&lt;/span&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; dispensePrize() {
        System.out.println(&lt;/span&gt;&quot;不能发放奖品&quot;&lt;span&gt;);
    }
    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.lin.state;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 发放奖品的状态
     * 
     * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Administrator
     *
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; DispenseState &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; State {

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始化时传入活动引用，发放奖品后改变其状态&lt;/span&gt;
&lt;span&gt;    RaffleActivity activity;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; DispenseState(RaffleActivity activity) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.activity =&lt;span&gt; activity;
    }

    &lt;/span&gt;&lt;span&gt;//
&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; deductMoney() {
        System.out.println(&lt;/span&gt;&quot;不能扣除积分&quot;&lt;span&gt;);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; raffle() {
        System.out.println(&lt;/span&gt;&quot;不能抽奖&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;发放奖品 @Override&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; dispensePrize() {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (activity.getCount() &amp;gt; 0&lt;span&gt;) {
            System.out.println(&lt;/span&gt;&quot;恭喜中奖了&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 改变状态为不能抽奖&lt;/span&gt;
&lt;span&gt;            activity.setState(activity.getNoRafflleState());
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            System.out.println(&lt;/span&gt;&quot;很遗憾，奖品发送完了&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 改变状态为奖品发送完毕, 后面我们就不可以抽奖&lt;/span&gt;
&lt;span&gt;            activity.setState(activity.getDispensOutState());
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;System.out.println(&quot;抽奖活动结束&quot;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;System.exit(0);&lt;/span&gt;
&lt;span&gt;        }

    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.lin.state;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 奖品发放完毕状态 说明，当我们 activity 改变成 DispenseOutState， 抽奖活动结束
     * 
     * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Administrator
     *
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; DispenseOutState &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; State {

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始化时传入活动引用&lt;/span&gt;
&lt;span&gt;    RaffleActivity activity;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; DispenseOutState(RaffleActivity activity) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.activity =&lt;span&gt; activity;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; deductMoney() {
        System.out.println(&lt;/span&gt;&quot;奖品发送完了，请下次再参加&quot;&lt;span&gt;);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; raffle() {
        System.out.println(&lt;/span&gt;&quot;奖品发送完了，请下次再参加&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; dispensePrize() {
        System.out.println(&lt;/span&gt;&quot;奖品发送完了，请下次再参加&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.lin.state;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Random;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 可以抽奖的状态
 * 
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Administrator
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; CanRaffleState &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; State {

    RaffleActivity activity;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; CanRaffleState(RaffleActivity activity) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.activity =&lt;span&gt; activity;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 已经扣除了积分，不能再扣 @Override&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; deductMoney() {
        System.out.println(&lt;/span&gt;&quot;已经扣取过了积分&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 可以抽奖, 抽完奖后，根据实际情况，改成新的状态&lt;/span&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; raffle() {
        System.out.println(&lt;/span&gt;&quot;正在抽奖，请稍等！&quot;&lt;span&gt;);
        Random r &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Random();
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; num = r.nextInt(10&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 10%中奖机会&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (num == 0&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 改 变 活 动 状 态 为 发 放 奖 品 context &lt;/span&gt;
&lt;span&gt;            activity.setState(activity.getDispenseState());
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            System.out.println(&lt;/span&gt;&quot;很遗憾没有抽中奖品！&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 改变状态为不能抽奖&lt;/span&gt;
&lt;span&gt;            activity.setState(activity.getNoRafflleState());
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 不能发放奖品&lt;/span&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; dispensePrize() {
        System.out.println(&lt;/span&gt;&quot;没中奖，不能发放奖品&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.lin.state;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 状态模式测试类
     * 
     * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Administrator
     *
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Client {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建活动对象，奖品有 1 个奖品&lt;/span&gt;
        RaffleActivity activity = &lt;span&gt;new&lt;/span&gt; RaffleActivity(1&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 我们连续抽 300 次奖&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 40; i++&lt;span&gt;) {
            System.out.println(&lt;/span&gt;&quot;--------第&quot; + (i + 1) + &quot;次抽奖----------&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 参加抽奖，第一步点击扣除积分&lt;/span&gt;
&lt;span&gt;            activity.debuctMoney();

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第二步抽奖&lt;/span&gt;
&lt;span&gt;            activity.raffle();
        }
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;24.1 状态模式在实际项目-&lt;span&gt;借贷平台&lt;/span&gt; &lt;span&gt;源码剖析&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;16&quot;&gt;1) 借贷平台的订单，有审核-发布-&lt;span&gt;抢单&lt;/span&gt; &lt;span&gt;等等&lt;/span&gt; &lt;span&gt;步骤，随着操作的不同，会改变订单的状态&lt;/span&gt;, 项目中的这个模块实现就会使用到状态模式&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;2) &lt;span&gt;通常通过&lt;/span&gt; if/else 判断订单的状态，从而实现不同的逻辑，伪代码如下&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2257481/202102/2257481-20210209200450972-1012567609.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 3)代码实现&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2257481/202102/2257481-20210209194248521-1448738452.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.lin.state.project;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 状态接口
 * 
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Administrator
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; State {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 电 审
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; checkEvent(Context context);

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 电审失败
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; checkFailEvent(Context context);

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 定价发布
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; makePriceEvent(Context context);

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 接 单
     * 
     * 
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; acceptOrderEvent(Context context);

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 无人接单失效
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; notPeopleAcceptEvent(Context context);

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 付 款
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; payOrderEvent(Context context);

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 接单有人支付失效
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; orderFailureEvent(Context context);

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 反 馈
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; feedBackEvent(Context context);

    String getCurrentState();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.lin.state.project;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 状态枚举类
     * 
     * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Administrator
     *
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt;&lt;span&gt; StateEnum {

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;订单生成&lt;/span&gt;
    GENERATE(1, &quot;GENERATE&quot;&lt;span&gt;),

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;已审核&lt;/span&gt;
    REVIEWED(2, &quot;REVIEWED&quot;&lt;span&gt;),
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;已发布&lt;/span&gt;
    PUBLISHED(3, &quot;PUBLISHED&quot;&lt;span&gt;),

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;待付款&lt;/span&gt;
    NOT_PAY(4, &quot;NOT_PAY&quot;&lt;span&gt;),

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;已付款&lt;/span&gt;
    PAID(5, &quot;PAID&quot;&lt;span&gt;),

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;已完结&lt;/span&gt;
&lt;span&gt;
    FEED_BACKED(&lt;/span&gt;6, &quot;FEED_BACKED&quot;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; key;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String value;

    StateEnum(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; key, String value) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.key =&lt;span&gt; key;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.value =&lt;span&gt; value;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getKey() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; key;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getValue() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; value;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.lin.state.project;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; AbstractState &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; State {

    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; RuntimeException EXCEPTION = &lt;span&gt;new&lt;/span&gt; RuntimeException(&quot;操作流程不允许&quot;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;抽象类，默认实现了 State 接口的所有方法
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;该类的所有方法，其子类(具体的状态类)，可以有选择的进行重写&lt;/span&gt;
&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; checkEvent(Context context) {
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; EXCEPTION;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; checkFailEvent(Context context) {
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; EXCEPTION;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; makePriceEvent(Context context) {
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; EXCEPTION;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; acceptOrderEvent(Context context) {
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; EXCEPTION;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; notPeopleAcceptEvent(Context context) {
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; EXCEPTION;
    }

    @Override

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; payOrderEvent(Context context) {
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; EXCEPTION;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; orderFailureEvent(Context context) {
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; EXCEPTION;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; feedBackEvent(Context context) {
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; EXCEPTION;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.lin.state.project;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;环境上下文&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Context &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; AbstractState {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前的状态 state, 根据我们的业务流程处理，不停的变化&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; State state;

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; checkEvent(Context context) {
        state.checkEvent(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
        getCurrentState();
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; checkFailEvent(Context context) {
        state.checkFailEvent(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
        getCurrentState();
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; makePriceEvent(Context context) {
        state.makePriceEvent(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
        getCurrentState();
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; acceptOrderEvent(Context context) {
        state.acceptOrderEvent(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
        getCurrentState();
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; notPeopleAcceptEvent(Context context) {
        state.notPeopleAcceptEvent(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
        getCurrentState();
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; payOrderEvent(Context context) {
        state.payOrderEvent(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
        getCurrentState();
    }

    @Override

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; orderFailureEvent(Context context) {
        state.orderFailureEvent(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
        getCurrentState();
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; feedBackEvent(Context context) {
        state.feedBackEvent(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
        getCurrentState();
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; State getState() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; state;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setState(State state) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.state =&lt;span&gt; state;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getCurrentState() {
        System.out.println(&lt;/span&gt;&quot;当前状态 : &quot; +&lt;span&gt; state.getCurrentState());
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; state.getCurrentState();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.lin.state.project;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;各种具体状态类&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; FeedBackState &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; AbstractState {

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getCurrentState() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; StateEnum.FEED_BACKED.getValue();
    }
}

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; GenerateState &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; AbstractState {

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; checkEvent(Context context) {
        context.setState(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ReviewState());
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; checkFailEvent(Context context) {
        context.setState(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; FeedBackState());
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getCurrentState() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; StateEnum.GENERATE.getValue();
    }
}

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; NotPayState &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; AbstractState {

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; payOrderEvent(Context context) {
        context.setState(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; PaidState());
    }

    @Override

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; feedBackEvent(Context context) {
        context.setState(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; FeedBackState());
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getCurrentState() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; StateEnum.NOT_PAY.getValue();
    }
}

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; PaidState &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; AbstractState {

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; feedBackEvent(Context context) {
        context.setState(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; FeedBackState());
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getCurrentState() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; StateEnum.PAID.getValue();
    }
}

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; PublishState &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; AbstractState {

    @Override

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; acceptOrderEvent(Context context) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;把当前状态设置为    NotPayState。。。
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;至于应该变成哪个状态，有流程图来决定&lt;/span&gt;
        context.setState(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; NotPayState());
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; notPeopleAcceptEvent(Context context) {
        context.setState(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; FeedBackState());
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getCurrentState() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; StateEnum.PUBLISHED.getValue();
    }
}

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; ReviewState &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; AbstractState {

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; makePriceEvent(Context context) {
        context.setState(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; PublishState());
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getCurrentState() {

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; StateEnum.REVIEWED.getValue();
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.lin.state.project;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 测试类 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Client {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建 context 对象&lt;/span&gt;
        Context context = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Context();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将当前状态设置为 PublishState &lt;/span&gt;
        context.setState(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; PublishState());
        System.out.println(context.getCurrentState());

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;publish --&amp;gt; not pay &lt;/span&gt;
&lt;span&gt;        context.acceptOrderEvent(context);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;not pay --&amp;gt; paid &lt;/span&gt;
&lt;span&gt;        context.payOrderEvent(context);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 失败, 检测失败时，会抛出异常
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    try {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    context.checkFailEvent(context);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    System.out.println(&quot;流程正常..&quot;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    } catch (Exception e) {
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO: handle exception
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    System.out.println(e.getMessage());
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    }&lt;/span&gt;
&lt;span&gt;    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;24.1 状态模式的注意事项和细节&lt;/h2&gt;
&lt;p class=&quot;15&quot;&gt;1) 代码有很强的可读性。状态模式将每个状态的行为封装到对应的一个类中&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;2) &lt;span&gt;方便维护。将容易产生问题的&lt;/span&gt; if-else &lt;span&gt;语句删除了，如果把每个状态的行为都放到一个类中，每次调用方法时都要判断当前是什么状态，不但会产出很多&lt;/span&gt; if-else 语句，而且容易出错&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;3) 符合“开闭原则”。容易增删状态&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;4) 会产生很多类。每个状态都要一个对应的类，当状态过多时会产生很多类，加大维护难度&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;5) &lt;span&gt;应用场景：当一个事件或者对象有很多种状态，状态之间会相互转换，对不同的状态要求有不同的行为的时候，&lt;/span&gt; &lt;span&gt;可以考虑使用状态模式&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;仅供参考，有错误还请指出！&lt;/p&gt;
&lt;p&gt;有什么想法，评论区留言，互相指教指教。&lt;/p&gt;
&lt;p&gt;觉得不错的可以点一下右边的推荐哟！&lt;/p&gt;
</description>
<pubDate>Thu, 11 Feb 2021 07:05:00 +0000</pubDate>
<dc:creator>十四lin</dc:creator>
<og:description>24.1&amp;#160;APP 抽奖活动问题 请编写程序完成 APP 抽奖活动 具体要求如下: 1)&amp;#160;假如每参加一次这个活动要扣除用户 50 积分，中奖概率是 10% 2)&amp;#160;奖品数量固</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/linzm14/p/14394072.html</dc:identifier>
</item>
<item>
<title>Python 3的f-Strings：增强的字符串格式语法（指南） - 一个火星程序员</title>
<link>http://www.cnblogs.com/oklucas/p/14397672.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/oklucas/p/14397672.html</guid>
<description>&lt;p&gt;最近也在一个视频网站的爬虫，项目已经完成，中间有不少需要总结的经验。&lt;/p&gt;
&lt;p&gt;从Python 3.6开始，f-Strings是格式化字符串的一种很棒的新方法。与其他格式化方式相比，它们不仅更具可读性，更简洁且不易出错，而且速度更快！&lt;/p&gt;
&lt;h2 id=&quot;python中的老式字符串格式化&quot;&gt;Python中的“老式”字符串格式化&lt;/h2&gt;
&lt;p&gt;在Python 3.6之前，你有两种主要的方式，将Python表达式嵌入到字符串文字中进行格式化：％-formatting和&lt;code&gt;str.format()&lt;/code&gt;。本文将首先介绍如何使用它们以及它们的局限性。&lt;/p&gt;
&lt;h3 id=&quot;选项1：-formatting&quot;&gt;选项#1：%-formatting&lt;/h3&gt;
&lt;p&gt;这是Python格式化的OG，从一开始就存在于语言中。你可以在&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#printf-style-string-formatting&quot; target=&quot;_blank&quot;&gt;Python文档中&lt;/a&gt;阅读更多内容。请记住，文档不建议使用％格式，其中包含以下注意事项：&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;“这里描述的格式化操作表现出各种古怪问题，导致许多错误（例如未能正确显示元组和字典）。&lt;/p&gt;
&lt;p&gt;使用较新的格式化字符串文字或&lt;code&gt;str.format()&lt;/code&gt;方法有助于避免这些错误。这些替代方案还提供了更强大，灵活和可扩展的文本格式设置方法。”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;如何使用---formatting&quot;&gt;如何使用 %-formatting&lt;/h4&gt;
&lt;p&gt;字符串对象具有使用该&lt;code&gt;%&lt;/code&gt;运算符的内置操作，可用于格式化字符串。这是实际的情况：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;&amp;gt;&amp;gt;&amp;gt; name = &quot;Eric&quot;
&amp;gt;&amp;gt;&amp;gt; &quot;Hello, %s.&quot; % name
'Hello, Eric.'
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了插入多个变量，你必须使用这些变量的元组。这是你要执行的操作：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;&amp;gt;&amp;gt;&amp;gt; name = &quot;Eric&quot;
&amp;gt;&amp;gt;&amp;gt; age = 74
&amp;gt;&amp;gt;&amp;gt; &quot;Hello, %s. You are %s.&quot; % (name, age)
'Hello Eric. You are 74.'
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;为什么-formatting不好&quot;&gt;为什么%-formatting不好&lt;/h4&gt;
&lt;p&gt;上面看到的代码示例具有足够的可读性。但是，一旦开始使用多个参数和更长的字符串，你的代码将很快变得不那么易读。看起来有些混乱：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;&amp;gt;&amp;gt;&amp;gt; first_name = &quot;Eric&quot;
&amp;gt;&amp;gt;&amp;gt; last_name = &quot;Idle&quot;
&amp;gt;&amp;gt;&amp;gt; age = 74
&amp;gt;&amp;gt;&amp;gt; profession = &quot;comedian&quot;
&amp;gt;&amp;gt;&amp;gt; affiliation = &quot;Monty Python&quot;
&amp;gt;&amp;gt;&amp;gt; &quot;Hello, %s %s. You are %s. You are a %s. You were a member of %s.&quot; % (first_name, last_name, age, profession, affiliation)
'Hello, Eric Idle. You are 74. You are a comedian. You were a member of Monty Python.'
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种格式不是很好，因为它很冗长并且会导致错误，例如不能正确显示元组或字典。&lt;/p&gt;
&lt;h3 id=&quot;选项2：strformat&quot;&gt;选项#2：str.format()&lt;/h3&gt;
&lt;p&gt;Python 2.6中引入了这种完成工作的新方法。你可以查看&lt;a href=&quot;https://realpython.com/python-formatted-output/&quot; target=&quot;_blank&quot;&gt;《 Python字符串格式新手指南》以&lt;/a&gt;获取更多信息。&lt;/p&gt;
&lt;h4 id=&quot;如何使用strformat&quot;&gt;如何使用str.format()&lt;/h4&gt;
&lt;p&gt;str.format() 是对 %-formatting 的改进。它使用正常的函数调用语法，并且可以通过 &lt;strong&gt;format&lt;/strong&gt;() 方法对被转换为字符串的对象进行扩展。&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;str.format()&lt;/code&gt;，替换字段用花括号标记：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &quot;Hello, {}. You are {}.&quot;.format(name, age)
'Hello, Eric. You are 74.'
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你可以通过引用变量的索引以任何顺序引用它们：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &quot;Hello, {1}. You are {0}.&quot;.format(age, name)
'Hello, Eric. You are 74.'
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是，如果你插入变量名，则会获得以下额外的好处：能够传递对象，然后在花括号之间引用参数和方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;&amp;gt;&amp;gt;&amp;gt; person = {'name': 'Eric', 'age': 74}
&amp;gt;&amp;gt;&amp;gt; &quot;Hello, {name}. You are {age}.&quot;.format(name=person['name'], age=person['age'])
'Hello, Eric. You are 74.'
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你也可以使用&lt;code&gt;**&lt;/code&gt;字典来完成这个巧妙的技巧：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;&amp;gt;&amp;gt;&amp;gt; person = {'name': 'Eric', 'age': 74}
&amp;gt;&amp;gt;&amp;gt; &quot;Hello, {name}. You are {age}.&quot;.format(**person)
'Hello, Eric. You are 74.'
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;str.format()&lt;/code&gt; 与％格式相比绝对是一个升级。&lt;/p&gt;
&lt;h4 id=&quot;为什么-strformat-不好&quot;&gt;为什么 str.format() 不好&lt;/h4&gt;
&lt;p&gt;使用&lt;code&gt;str.format()&lt;/code&gt;代码比使用 %-formatting 的代码更容易阅读，但是&lt;code&gt;str.format()&lt;/code&gt;当你处理多个参数和更长的字符串时，代码仍然很冗长。看看这个：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;&amp;gt;&amp;gt;&amp;gt; first_name = &quot;Eric&quot;
&amp;gt;&amp;gt;&amp;gt; last_name = &quot;Idle&quot;
&amp;gt;&amp;gt;&amp;gt; age = 74
&amp;gt;&amp;gt;&amp;gt; profession = &quot;comedian&quot;
&amp;gt;&amp;gt;&amp;gt; affiliation = &quot;Monty Python&quot;
&amp;gt;&amp;gt;&amp;gt; print((&quot;Hello, {first_name} {last_name}. You are {age}. &quot; + 
&amp;gt;&amp;gt;&amp;gt;        &quot;You are a {profession}. You were a member of {affiliation}.&quot;) \
&amp;gt;&amp;gt;&amp;gt;        .format(first_name=first_name, last_name=last_name, age=age, \
&amp;gt;&amp;gt;&amp;gt;                profession=profession, affiliation=affiliation))
'Hello, Eric Idle. You are 74. You are a comedian. You were a member of Monty Python.'
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果你要&lt;code&gt;.format()&lt;/code&gt;在字典中传递变量，则可以将其解压缩&lt;code&gt;.format(**some_dict)&lt;/code&gt;并按字符串中的键引用值，但是必须有一种更好的方法来执行此操作。&lt;/p&gt;
&lt;h2 id=&quot;f-strings表达式：python中一种增强的格式化字符串的新方法&quot;&gt;f-Strings表达式：Python中一种增强的格式化字符串的新方法&lt;/h2&gt;
&lt;p&gt;f-Strings 表达式使格式化更容易。他们加入了Python 3.6。你可以在2015年8月由Eric V.Smith撰写的&lt;a href=&quot;https://www.python.org/dev/peps/pep-0498/&quot; target=&quot;_blank&quot;&gt;PEP 498中&lt;/a&gt;阅读全部内容。&lt;/p&gt;
&lt;p&gt;f-Strings 也称为“格式化的字符串文字”，是一种字符串文字，其开头是 f，后面是大括号，其中包含将被替换为其值的表达式。这些表达式在运行时被评估，然后使用 &quot;&lt;strong&gt;format&lt;/strong&gt;&quot; 协议进行格式化。当你想了解更多信息时，&lt;a href=&quot;https://docs.python.org/3/reference/lexical_analysis.html#f-strings&quot; target=&quot;_blank&quot;&gt;Python文档&lt;/a&gt;是你的朋友。&lt;/p&gt;
&lt;p&gt;下面是一些 f-strings 可以让你的生活更轻松的方法。&lt;/p&gt;
&lt;h3 id=&quot;简单语法&quot;&gt;简单语法&lt;/h3&gt;
&lt;p&gt;看看这是多么容易阅读：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;&amp;gt;&amp;gt;&amp;gt; name = &quot;Eric&quot;
&amp;gt;&amp;gt;&amp;gt; age = 74
&amp;gt;&amp;gt;&amp;gt; f&quot;Hello, {name}. You are {age}.&quot;
'Hello, Eric. You are 74.'
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用大写字母也是有效的&lt;code&gt;F&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;&amp;gt;&amp;gt;&amp;gt; F&quot;Hello, {name}. You are {age}.&quot;
'Hello, Eric. You are 74.'
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;任意表达&quot;&gt;任意表达&lt;/h3&gt;
&lt;p&gt;因为 f-strings 在运行时被评估，所以您可以在其中放入任何和所有有效的 Python 表达式。&lt;/p&gt;
&lt;p&gt;你可以做一些非常简单的事情，例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;&amp;gt;&amp;gt;&amp;gt; f&quot;{2 * 37}&quot;
'74'
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是你也可以调用函数。这是一个例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;&amp;gt;&amp;gt;&amp;gt; def to_lowercase(input):
...     return input.lower()

&amp;gt;&amp;gt;&amp;gt; name = &quot;Eric Idle&quot;
&amp;gt;&amp;gt;&amp;gt; f&quot;{to_lowercase(name)} is funny.&quot;
'eric idle is funny.'
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你还可以选择直接调用方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;&amp;gt;&amp;gt;&amp;gt; f&quot;{name.lower()} is funny.&quot;
'eric idle is funny.'
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你甚至可以使用从带有f-strings的类创建的对象：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;class Comedian:
    def __init__(self, first_name, last_name, age):
        self.first_name = first_name
        self.last_name = last_name
        self.age = age

    def __str__(self):
        return f&quot;{self.first_name} {self.last_name} is {self.age}.&quot;

    def __repr__(self):
        return f&quot;{self.first_name} {self.last_name} is {self.age}. Surprise!&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你执行以下操作：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;&amp;gt;&amp;gt;&amp;gt; new_comedian = Comedian(&quot;Eric&quot;, &quot;Idle&quot;, &quot;74&quot;)
&amp;gt;&amp;gt;&amp;gt; f&quot;{new_comedian}&quot;
'Eric Idle is 74.'
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该&lt;code&gt;__str__()&lt;/code&gt;和&lt;code&gt;__repr__()&lt;/code&gt;方法处理对象是如何呈现为字符串，所以你需要确保你包括你的类定义这些方法的至少一个。如果你必须选择一个，请继续使用，&lt;code&gt;__repr__()&lt;/code&gt;因为它可以代替使用&lt;code&gt;__str__()&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;返回的&lt;code&gt;__str__()&lt;/code&gt;字符串是对象的非正式字符串表示形式。返回的字符串&lt;code&gt;__repr__()&lt;/code&gt;是正式表示形式，应明确。调用&lt;code&gt;str()&lt;/code&gt;和&lt;code&gt;repr()&lt;/code&gt;比直接使用&lt;code&gt;__str__()&lt;/code&gt;和更可取&lt;code&gt;__repr__()&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;默认情况下，f字符串将使用&lt;code&gt;__str__()&lt;/code&gt;，但是如果你加入转换标志 !r，你可以确保它们使用&lt;code&gt;__repr__()&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;&amp;gt;&amp;gt;&amp;gt; f&quot;{new_comedian}&quot;
'Eric Idle is 74.'
&amp;gt;&amp;gt;&amp;gt; f&quot;{new_comedian!r}&quot;
'Eric Idle is 74. Surprise!'
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果你想阅读一些导致 f-Strings 支持完整Python表达式的对话，则可以在&lt;a href=&quot;https://mail.python.org/pipermail/python-ideas/2015-July/034726.html&quot; target=&quot;_blank&quot;&gt;此处进行&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;多行f-strings&quot;&gt;多行f-Strings&lt;/h3&gt;
&lt;p&gt;你可以使用多行字符串：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;&amp;gt;&amp;gt;&amp;gt; name = &quot;Eric&quot;
&amp;gt;&amp;gt;&amp;gt; profession = &quot;comedian&quot;
&amp;gt;&amp;gt;&amp;gt; affiliation = &quot;Monty Python&quot;
&amp;gt;&amp;gt;&amp;gt; message = (
...     f&quot;Hi {name}. &quot;
...     f&quot;You are a {profession}. &quot;
...     f&quot;You were in {affiliation}.&quot;
... )
&amp;gt;&amp;gt;&amp;gt; message
'Hi Eric. You are a comedian. You were in Monty Python.'
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是请记住，你需要在多行字符串的每一行前面放一个f。以下代码不起作用：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;&amp;gt;&amp;gt;&amp;gt; message = (
...     f&quot;Hi {name}. &quot;
...     &quot;You are a {profession}. &quot;
...     &quot;You were in {affiliation}.&quot;
... )
&amp;gt;&amp;gt;&amp;gt; message
'Hi Eric. You are a {profession}. You were in {affiliation}.'
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果你没有&lt;code&gt;f&lt;/code&gt;在每行的前面都放一个，那么你将只有规则的，古老的，花园风格的琴弦，而不是闪亮的，新颖的，奇特的f琴弦。&lt;/p&gt;
&lt;p&gt;如果你想将字符串分布在多行中，则还可以选择使用-转义字符 &lt;code&gt;\&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;&amp;gt;&amp;gt;&amp;gt; message = f&quot;Hi {name}. &quot; \
...           f&quot;You are a {profession}. &quot; \
...           f&quot;You were in {affiliation}.&quot;
...
&amp;gt;&amp;gt;&amp;gt; message
'Hi Eric. You are a comedian. You were in Monty Python.'
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是，如果使用以下方法，将会发生以下情况&lt;code&gt;&quot;&quot;&quot;&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;&amp;gt;&amp;gt;&amp;gt; message = f&quot;&quot;&quot;
...     Hi {name}. 
...     You are a {profession}. 
...     You were in {affiliation}.
... &quot;&quot;&quot;
...
&amp;gt;&amp;gt;&amp;gt; message
'\n    Hi Eric.\n    You are a comedian.\n    You were in Monty Python.\n'
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;阅读&lt;a href=&quot;https://pep8.org/&quot; target=&quot;_blank&quot;&gt;PEP 8中的&lt;/a&gt;缩进准则。&lt;/p&gt;
&lt;h3 id=&quot;速度&quot;&gt;速度&lt;/h3&gt;
&lt;p&gt;f-Strings 比 %-formatting 和 str.format() 都要快。如你所见，f-Strings 是在运行时求值的表达式，而不是常量值。以下摘自文档：&lt;/p&gt;
&lt;blockquote readability=&quot;7.8579881656805&quot;&gt;
&lt;p&gt;“f-Strings 提供了一种使用最小语法在字符串文字中嵌入表达式的方法。应当注意，f-Strings 实际上是在运行时评估的表达式，而不是常数。在Python源代码中，f-Strings 是文字字符串，前缀为&lt;code&gt;f&lt;/code&gt;，其中花括号内包含表达式。这些表达式将替换为其值。” （&lt;a href=&quot;https://www.python.org/dev/peps/pep-0498/#abstract&quot; target=&quot;_blank&quot;&gt;来源&lt;/a&gt;）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在运行时，大括号内的表达式在其自己的范围内求值，然后与 f-Strings 的字符串文字部分放在一起。然后返回结果字符串。这就是全部。&lt;/p&gt;
&lt;p&gt;这是速度比较：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;&amp;gt;&amp;gt;&amp;gt; import timeit
&amp;gt;&amp;gt;&amp;gt; timeit.timeit(&quot;&quot;&quot;name = &quot;Eric&quot;
... age = 74
... '%s is %s.' % (name, age)&quot;&quot;&quot;, number = 10000)
0.003324444866599663
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;&amp;gt;&amp;gt;&amp;gt; timeit.timeit(&quot;&quot;&quot;name = &quot;Eric&quot;
... age = 74
... '{} is {}.'.format(name, age)&quot;&quot;&quot;, number = 10000)
0.004242089427570761
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;&amp;gt;&amp;gt;&amp;gt; timeit.timeit(&quot;&quot;&quot;name = &quot;Eric&quot;
... age = 74
... f'{name} is {age}.'&quot;&quot;&quot;, number = 10000)
0.0024820892040722242
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如你所见，f-Strings 最快。&lt;/p&gt;
&lt;p&gt;但是，情况并非总是如此。首次实施时，它们存在一些&lt;a href=&quot;https://stackoverflow.com/questions/37365311/why-are-literal-formatted-strings-so-slow-in-python-3-6-alpha-now-fixed-in-3-6&quot; target=&quot;_blank&quot;&gt;速度问题&lt;/a&gt;，需要使其速度比更快&lt;code&gt;str.format()&lt;/code&gt;。引入了特殊的&lt;a href=&quot;https://bugs.python.org/issue27078&quot; target=&quot;_blank&quot;&gt;&lt;code&gt;BUILD_STRING&lt;/code&gt;操作码&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;python-f-strings：细节&quot;&gt;Python f-Strings：细节&lt;/h2&gt;
&lt;p&gt;既然你已经了解了为什么 f-Strings 很棒，我相信你一定要开始使用 f-Strings 。当你冒险进入这个勇敢的新世界时，请牢记以下一些细节。&lt;/p&gt;
&lt;h3 id=&quot;引号&quot;&gt;引号&lt;/h3&gt;
&lt;p&gt;你可以在表达式内使用各种类型的引号。只要确保你没有在表达式中使用与 f-Strings 相同的引号即可。&lt;/p&gt;
&lt;p&gt;该代码将起作用：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;&amp;gt;&amp;gt;&amp;gt; f&quot;{'Eric Idle'}&quot;
'Eric Idle'
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该代码也将起作用：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;&amp;gt;&amp;gt;&amp;gt; f'{&quot;Eric Idle&quot;}'
'Eric Idle'
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你还可以使用三引号：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;&amp;gt;&amp;gt;&amp;gt; f&quot;&quot;&quot;Eric Idle&quot;&quot;&quot;
'Eric Idle'
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;&amp;gt;&amp;gt;&amp;gt; f'''Eric Idle'''
'Eric Idle'
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果发现需要在字符串的内部和外部使用相同类型的引号，则可以使用 &lt;code&gt;\&lt;/code&gt; 命令进行转义：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;&amp;gt;&amp;gt;&amp;gt; f&quot;The \&quot;comedian\&quot; is {name}, aged {age}.&quot;
'The &quot;comedian&quot; is Eric Idle, aged 74.'
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;字典&quot;&gt;字典&lt;/h3&gt;
&lt;p&gt;说到引号，使用字典时要当心。如果要对字典的键使用单引号，请记住确保对包含键的 f-Strings 使用双引号。&lt;/p&gt;
&lt;p&gt;这将起作用：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;&amp;gt;&amp;gt;&amp;gt; comedian = {'name': 'Eric Idle', 'age': 74}
&amp;gt;&amp;gt;&amp;gt; f&quot;The comedian is {comedian['name']}, aged {comedian['age']}.&quot;
The comedian is Eric Idle, aged 74.
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但这是一个语法错误的情况：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;&amp;gt;&amp;gt;&amp;gt; comedian = {'name': 'Eric Idle', 'age': 74}
&amp;gt;&amp;gt;&amp;gt; f'The comedian is {comedian['name']}, aged {comedian['age']}.'
  File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1
    f'The comedian is {comedian['name']}, aged {comedian['age']}.'
                                    ^
SyntaxError: invalid syntax
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果在字典键周围使用与在f字符串外部相同的引号类型，则第一个字典键开头的引号将被解释为字符串的结尾。&lt;/p&gt;
&lt;h3 id=&quot;大括号&quot;&gt;大括号&lt;/h3&gt;
&lt;p&gt;为了使大括号出现在字符串中，必须使用双大括号：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;&amp;gt;&amp;gt;&amp;gt; f&quot;{{70 + 4}}&quot;
'{70 + 4}'
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;请注意，使用三重花括号将导致字符串中只有一个大括号：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;&amp;gt;&amp;gt;&amp;gt; f&quot;{{{70 + 4}}}&quot;
'{74}'
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是，如果使用的括号多于三个，则可以显示更多的括号：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;&amp;gt;&amp;gt;&amp;gt; f&quot;{{{{70 + 4}}}}&quot;
'{{70 + 4}}'
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;反斜杠&quot;&gt;反斜杠&lt;/h3&gt;
&lt;p&gt;如前所述，你可以在f-string的字符串部分使用反斜杠转义。但是，你不能在f-string的表达式部分使用反斜杠转义：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;&amp;gt;&amp;gt;&amp;gt; f&quot;{\&quot;Eric Idle\&quot;}&quot;
  File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1
    f&quot;{\&quot;Eric Idle\&quot;}&quot;
                      ^
SyntaxError: f-string expression part cannot include a backslash
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你可以通过预先计算表达式并在f字符串中使用结果来解决此问题：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;&amp;gt;&amp;gt;&amp;gt; name = &quot;Eric Idle&quot;
&amp;gt;&amp;gt;&amp;gt; f&quot;{name}&quot;
'Eric Idle'
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;内部注释&quot;&gt;内部注释&lt;/h3&gt;
&lt;p&gt;表达式中不应包含使用该 &lt;code&gt;#&lt;/code&gt; 符号的注释。下面代码，你会看到语法错误：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;&amp;gt;&amp;gt;&amp;gt; f&quot;Eric is {2 * 37 #Oh my!}.&quot;
  File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1
    f&quot;Eric is {2 * 37 #Oh my!}.&quot;
                                ^
SyntaxError: f-string expression part cannot include '#'
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;字符串格式化方法在很多项目里面都能用到，实用价值很高。&lt;/p&gt;
&lt;p&gt;请&lt;span&gt;&lt;strong&gt;订阅&lt;/strong&gt;&lt;/span&gt;并&lt;span&gt;&lt;strong&gt;继续关注&lt;/strong&gt;&lt;/span&gt;，以后会收到更多有趣的文章。&lt;/p&gt;
&lt;p&gt;欢迎关注我的&lt;a href=&quot;https://www.bianchengvip.com/&quot; target=&quot;_blank&quot;&gt;个人网站https://www.bianchengvip.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文为“一个火星程序员”原创文章，转载请标明出处&lt;/p&gt;
</description>
<pubDate>Thu, 11 Feb 2021 05:57:00 +0000</pubDate>
<dc:creator>一个火星程序员</dc:creator>
<og:description>最近也在一个视频网站的爬虫，项目已经完成，中间有不少需要总结的经验。 从Python 3.6开始，f-Strings是格式化字符串的一种很棒的新方法。与其他格式化方式相比，它们不仅更具可读性，更简洁且</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/oklucas/p/14397672.html</dc:identifier>
</item>
</channel>
</rss>