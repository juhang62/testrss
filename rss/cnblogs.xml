<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>性能篇（五）为电池寿命做优化——测试电源相关的问题 - 宋者为王</title>
<link>http://www.cnblogs.com/andy-songwei/p/10729998.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/andy-songwei/p/10729998.html</guid>
<description>&lt;p&gt;       发布于Android9(API等级为28)的电源管理特性影响了所有运行于该版本的应用，无论这些应用的目标版本是否为该版本。确保您应用在设备上恰当地运行是一件重要的事。&lt;/p&gt;
&lt;p&gt;       确保在各种条件下测试您应用的主要使用情况，来查看电源管理特性是如何与其它应用相互作用的。您可以使用【&lt;a href=&quot;https://developer.android.google.cn/studio/command-line/adb.html&quot; target=&quot;_blank&quot;&gt;Android Debug Bridge&lt;/a&gt;】命令来开启和关闭一些特性。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Android Debug Bridge 命令&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       您可以使用【&lt;a href=&quot;https://developer.android.google.cn/studio/command-line/adb.html&quot; target=&quot;_blank&quot;&gt;Android Debug Bridge&lt;/a&gt;】shell命令来测试几种电源管理特性。&lt;/p&gt;
&lt;p&gt;       关于使用ADB将您设备置于低电耗模式的信息，请查看【&lt;a href=&quot;https://developer.android.google.cn/training/monitoring-device-state/doze-standby.html&quot; target=&quot;_blank&quot;&gt;使用低电量模式和应用群组模式测试&lt;/a&gt;】。&lt;/p&gt;
&lt;p&gt;       应用待机群组&lt;/p&gt;
&lt;p&gt;       您可以使用ADB来手动分配您的应用到应用待机群组。为了改变应用的群组，首先使用如下命令模拟拔除设备：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$ adb shell dumpsys battery unplug
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;       然后使用如下命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$ adb shell am set-standby-bucket packagename active|working_set|frequent|rare
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;       您也可以使用如下命令一次设置多个包：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$ adb shell am set-standby-bucket package1 bucket1 package2 bucket2...
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;       要检查应用在哪个群组，请运行&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$ adb shell am get-standby-bucket [packagename]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;       如果您不传入packagename参数，该命令会列出所有应用的群组。应用也可以通过调用新方法UsageStatsManager.getAppStandbyBucket()找出它在运行时的群组。&lt;/p&gt;
&lt;p&gt;       &lt;strong&gt;后台限制&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       要手动应用后台限制，运行如下命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$ adb shell cmd appops set packagename RUN_ANY_IN_BACKGROUND ignore
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;       要移除后台限制，运行如下命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$ adb shell cmd appops set packagename RUN_ANY_IN_BACKGROUND allow
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;       &lt;strong&gt;电池节省器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       有几个命令来测试您的应用在低电量条件下是如何表现的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
★ 注意：您也可以使用设备“设置” &amp;gt; “电池节省器”界面来将设备置于电池节省模式。
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;       要模拟设备被拔除，使用命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$ adb shell dumpsys battery unplug
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;       要测试低电量条件下设备如何表现，使用命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$ adb shell settings put global low_power 1
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;       一旦您测试完成，您应该通过如下命令撤销手动的设备设置：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$ adb shell dumpsys battery reset
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;该系列其它文档&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;【&lt;a href=&quot;https://developer.android.google.cn/training/monitoring-device-state/doze-standby&quot; target=&quot;_blank&quot;&gt;对低电耗模式和应用待机模式进行针对性优化&lt;/a&gt;】：&lt;a href=&quot;https://developer.android.google.cn/training/monitoring-device-state/doze-standby&quot; target=&quot;_blank&quot;&gt;https://developer.android.google.cn/training/monitoring-device-state/doze-standby&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【&lt;a href=&quot;https://developer.android.google.cn/training/monitoring-device-state/battery-monitoring&quot; target=&quot;_blank&quot;&gt;监控电池电量和充电状态&lt;/a&gt;】：&lt;a href=&quot;https://developer.android.google.cn/training/monitoring-device-state/battery-monitoring&quot;&gt;https://developer.android.google.cn/training/monitoring-device-state/battery-monitoring&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【&lt;a href=&quot;https://developer.android.google.cn/training/monitoring-device-state/docking-monitoring&quot; target=&quot;_blank&quot;&gt;确定和监控插接状态和基座类型&lt;/a&gt;】：&lt;a href=&quot;https://developer.android.google.cn/training/monitoring-device-state/docking-monitoring&quot;&gt;https://developer.android.google.cn/training/monitoring-device-state/docking-monitoring&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【&lt;a href=&quot;https://developer.android.google.cn/training/monitoring-device-state/connectivity-monitoring&quot; target=&quot;_blank&quot;&gt;确定和监控连接状态&lt;/a&gt;】：&lt;a href=&quot;https://developer.android.google.cn/training/monitoring-device-state/connectivity-monitoring&quot;&gt;https://developer.android.google.cn/training/monitoring-device-state/connectivity-monitoring&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 18 Apr 2019 07:39:00 +0000</pubDate>
<dc:creator>宋者为王</dc:creator>
<og:description>发布于Android9(API等级为28)的电源管理特性影响了所有运行于该版本的应用，无论这些应用的目标版本是否为该版本。确保您应用在设备上恰当地运行是一件重要的事。Android Debug Bri</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/andy-songwei/p/10729998.html</dc:identifier>
</item>
<item>
<title>6.3 基于二分搜索树、链表的实现的集合Set复杂度分析 - WFaceBoss</title>
<link>http://www.cnblogs.com/wfaceboss/p/10729933.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wfaceboss/p/10729933.html</guid>
<description>&lt;p&gt;&lt;span&gt;在【6.1】节与【6.2】节中分别以二分搜索树和链表作为底层实现了集合&lt;code&gt;Set&lt;/code&gt;，在本节就两种集合类的复杂度分析进行分析：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;测试内容：&lt;code&gt;6.1&lt;/code&gt;节与&lt;code&gt;6.2&lt;/code&gt;节中使用的书籍。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;测试方法：测试两种集合类查找单词所用的时间&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个测试方法 Set&amp;lt;String&amp;gt; set:他们可以是实现了该接口的LinkedListSet和BSTSet对象&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; testSet(Set&amp;lt;String&amp;gt;&lt;span&gt; set, String filename) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;计算开始时间&lt;/span&gt;
        &lt;span&gt;long&lt;/span&gt; startTime =&lt;span&gt; System.nanoTime();
        System.out.println(&lt;/span&gt;&quot;Pride and Prejudice&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;新建一个ArrayList存放单词&lt;/span&gt;
        ArrayList&amp;lt;String&amp;gt; words1 = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过这个方法将书中所以单词存入word1中&lt;/span&gt;
&lt;span&gt;        FileOperation.readFile(filename, words1);
        System.out.println(&lt;/span&gt;&quot;Total words : &quot; +&lt;span&gt; words1.size());

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;增强for循环，定一个字符串word去遍历words
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;底层的话会把ArrayList words1中的值一个一个的赋值给word&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (String word : words1)
            set.add(word);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;不添加重复元素&lt;/span&gt;
        System.out.println(&quot;Total  different words : &quot; +&lt;span&gt; set.getSize());

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;计算结束时间&lt;/span&gt;
        &lt;span&gt;long&lt;/span&gt; endTime =&lt;span&gt; System.nanoTime();
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (endTime - startTime) / 1000000000.0;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;纳秒为单位&lt;/span&gt;
&lt;span&gt;    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;基于二分搜索的集合&lt;/span&gt;
        BSTSet&amp;lt;String&amp;gt; bstSet = &lt;span&gt;new&lt;/span&gt; BSTSet&amp;lt;&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; time1 = testSet(bstSet, &quot;pride-and-prejudice.txt&quot;&lt;span&gt;);
        System.out.println(&lt;/span&gt;&quot;BSTSet:&quot; + time1 + &quot;s&quot;&lt;span&gt;);
        System.out.println(&lt;/span&gt;&quot;————————————————————&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;基于链表实现的集合&lt;/span&gt;
        LinkedListSet&amp;lt;String&amp;gt; linkedListSet = &lt;span&gt;new&lt;/span&gt; LinkedListSet&amp;lt;&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; time2 = testSet(linkedListSet, &quot;pride-and-prejudice.txt&quot;&lt;span&gt;);
        System.out.println(&lt;/span&gt;&quot;linkedListSet:&quot; + time2 + &quot;s&quot;&lt;span&gt;);

    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;结果：BSTSet的速度比LinkedListed的速度快&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/860581/201904/860581-20190418153347546-1805440138.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h5&gt;1.链表情况&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/860581/201904/860581-20190418153420705-493127852.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;2.二叉搜索树的情况&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;在基于二叉搜索树的情况下，增加、查询、删除的与二叉搜索树的深度有关，每次操作均为从根节点到某一一支子树的叶子节点之间进行操作，时间复杂度为&lt;code&gt;0(h)&lt;/code&gt;,&lt;code&gt;h&lt;/code&gt;表示二叉搜索树的高度（层数）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/860581/201904/860581-20190418153432084-230511573.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;二叉搜索树复杂度如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/860581/201904/860581-20190418153439696-1095757737.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;2.1 探究链表情况下的n与二叉搜索树的h的关系&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/860581/201904/860581-20190418153446603-1501306842.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面对n与h关系进行推导：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.1.1 采用满二叉树的情况进行分析（最优情况）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;采用满二叉树（每个节点都有左右节点，除了叶子节点）来进行分析的原因为满二叉树是一种极端情况，如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/860581/201904/860581-20190418153512544-205907088.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;span&gt;从上图中关于&lt;code&gt;h层&lt;/code&gt;总共有多少个节点有如下推导：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/860581/201904/860581-20190418153520099-1227778431.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;假设节点个数为&lt;code&gt;n&lt;/code&gt;个则有如下关系：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/860581/201904/860581-20190418153527264-54672720.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;针对都是&lt;code&gt;log级别&lt;/code&gt;的关系，底数是多少不影响它是&lt;code&gt;log级别&lt;/code&gt;的则有：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/860581/201904/860581-20190418153534104-673728631.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.1.2 单个孩子情况----二叉搜索树最坏情况（节点数等于其高度）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如：下面这种二叉搜索树&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/860581/201904/860581-20190418153554566-1919647882.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;br/&gt;&lt;span&gt;对于这种只有单个孩子的情况，此时二叉搜索树退化成了链表，此时的时间复杂度为O(n)。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;2.2 两种集合复杂度统计&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/860581/201904/860581-20190418153612270-2049586317.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.2.1 logn和n的差距&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/860581/201904/860581-20190418153621847-1218344426.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;推荐是最好的支持，关注是最大的鼓励。亲爱的朋友，很荣幸在园子里遇到您。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/FelixBin/dataStructure/tree/master/src/SetAndMap&quot; target=&quot;_blank&quot;&gt;本节涉及的源码地址为  https://github.com/FelixBin/dataStructure/tree/master/src/SetAndMap&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 18 Apr 2019 07:38:00 +0000</pubDate>
<dc:creator>WFaceBoss</dc:creator>
<og:description>两种集合类的复杂度分析 在【6.1】节与【6.2】节中分别以二分搜索树和链表作为底层实现了集合Set，在本节就两种集合类的复杂度分析进行分析：测试内容：6.1节与6.2节中使用的书籍。测试方法：测试两</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wfaceboss/p/10729933.html</dc:identifier>
</item>
<item>
<title>HttpServletRequest 接口、HttpServletResponse 接口、请求转发与重定向 - chen_hao</title>
<link>http://www.cnblogs.com/java-chen-hao/p/10729903.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/java-chen-hao/p/10729903.html</guid>
<description>&lt;p&gt;上篇文章我们讲了servlet的基本原理，这章将讲一下剩余的部分。&lt;/p&gt;
&lt;h2&gt;HttpServletRequest 接口&lt;/h2&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　该接口是&lt;/span&gt; ServletRequest &lt;span&gt;接口的子接口，封装了&lt;/span&gt; HTTP &lt;span&gt;请求的相关信息，由&lt;/span&gt; Servlet 容器创建&lt;span&gt;其实现类对象并传入&lt;/span&gt; service(ServletRequest req, ServletResponse res)方法中。我们请求的详细&lt;span&gt;信息都可以通过&lt;/span&gt; HttpServletRequest 接口的实现类对象获取。这个实现类对象一般都是容器创建的，我们不需要管理。&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;strong&gt;HttpServletRequest 主要功能&lt;/strong&gt;&lt;/p&gt;
&lt;h3 align=&quot;justify&quot;&gt;获取请求参数&lt;/h3&gt;
&lt;p align=&quot;justify&quot;&gt;1）什么是请求参数？&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;请求参数就是浏览器向服务器提交的数据&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;2）浏览器向服务器如何发送数据&lt;/p&gt;
&lt;p&gt;　　a）附在 url 后面，如：&lt;span&gt;h&lt;/span&gt;&lt;span&gt;t&lt;/span&gt;&lt;span&gt;t&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;l&lt;/span&gt;&lt;span&gt;o&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;l&lt;/span&gt;&lt;span&gt;ho&lt;/span&gt;&lt;span&gt;s&lt;/span&gt;&lt;span&gt;t&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;89&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;M&lt;/span&gt;&lt;span&gt;y&lt;/span&gt;&lt;span&gt;S&lt;/span&gt;&lt;span&gt;e&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;v&lt;/span&gt;&lt;span&gt;l&lt;/span&gt;&lt;span&gt;e&lt;/span&gt;&lt;span&gt;t&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;M&lt;/span&gt;&lt;span&gt;y&lt;/span&gt;&lt;span&gt;H&lt;/span&gt;&lt;span&gt;tt&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;S&lt;/span&gt;&lt;span&gt;e&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;v&lt;/span&gt;&lt;span&gt;l&lt;/span&gt;&lt;span&gt;e&lt;/span&gt;&lt;span&gt;t&lt;/span&gt;&lt;span&gt;?&lt;/span&gt;&lt;span&gt;u&lt;/span&gt;&lt;span&gt;s&lt;/span&gt;&lt;span&gt;e&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;I&lt;/span&gt;&lt;span&gt;d&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　b）通过表单提交&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;form action=&quot;MyHttpServlet&quot; method=&quot;post&quot;&amp;gt;&lt;span&gt;
    你喜欢的足球队&lt;/span&gt;&amp;lt;br /&amp;gt;&amp;lt;br /&amp;gt;&lt;span&gt;
    巴西&lt;/span&gt;&amp;lt;input type=&quot;checkbox&quot; name=&quot;soccerTeam&quot; value=&quot;Brazil&quot; /&amp;gt;&lt;span&gt; 
    德国&lt;/span&gt;&amp;lt;input type=&quot;checkbox&quot; name=&quot;soccerTeam&quot; value=&quot;German&quot; /&amp;gt;&lt;span&gt;
    荷兰&lt;/span&gt;&amp;lt;input type=&quot;checkbox&quot; name=&quot;soccerTeam&quot; value=&quot;Holland&quot; /&amp;gt;
    &amp;lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&amp;gt;
&amp;lt;/form&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3）使用HttpServletRequest对象获取请求参数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; doGet(HttpServletRequest request, HttpServletResponse response) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ServletException, IOException {
　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;一个name对应一个值&lt;/span&gt;
　　String userId = request.getParameter(&quot;userId&quot;); &lt;br/&gt;　　System.out.println(&quot;userId=&quot;+&lt;span&gt;userId);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; doPost(HttpServletRequest request, HttpServletResponse response) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ServletException, IOException {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;一个name对应一组值&lt;/span&gt;
    String[] soccerTeams = request.getParameterValues(&quot;soccerTeam&quot;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; soccerTeams.length; i++&lt;span&gt;){
        System.out.println(&lt;/span&gt;&quot;team &quot;+i+&quot;=&quot;+&lt;span&gt;soccerTeams[i]);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;在请求域中保存数据&lt;/h3&gt;
&lt;p&gt;数据保存在请求域中，可以转发到其他Servlet或者jsp页面，这些Servlet或者jsp&lt;span&gt;页面就会&lt;/span&gt; 从请求中再取出数据&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; doGet(HttpServletRequest request, HttpServletResponse response) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ServletException, IOException {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将数据保存到request对象的属性域中request.setAttribute(&quot;attrName&quot;, &quot;attrValueInRequest&quot;);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;两个Servlet要想共享request对象中的数据，必须是转发的关系&lt;/span&gt;
    request.getRequestDispatcher(&quot;/ReceiveServlet&quot;&lt;span&gt;).forward(request, response);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; doGet(HttpServletRequest request, HttpServletResponse response) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ServletException, IOException {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从request属性域中获取数据&lt;/span&gt;
    Object attribute = request.getAttribute(&quot;attrName&quot;&lt;span&gt;); 
    System.out.println(&lt;/span&gt;&quot;attrValue=&quot;+&lt;span&gt;attribute);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;strong&gt;HttpServletResponse&lt;/strong&gt; 接口&lt;/h2&gt;
&lt;p&gt;HttpServletResponse &lt;span&gt;是&lt;/span&gt; ServletResponse &lt;span&gt;接口的子接口，封装了&lt;/span&gt; HTTP 响应的相关信息，由&lt;/p&gt;
&lt;p&gt;Servlet &lt;span&gt;容器创建其实现类对象并传入&lt;/span&gt; service(ServletRequest req, ServletResponse res)方法中。主要功能：&lt;/p&gt;
&lt;p&gt;1&lt;span&gt;）使用&lt;/span&gt; PrintWriter 对象向浏览器输出数据&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过PrintWriter对象向浏览器端发送响应信息&lt;/span&gt;
PrintWriter writer =&lt;span&gt; res.getWriter();
writer.write(&lt;/span&gt;&quot;Servlet response&quot;); writer.close();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2）实现请求重定向&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;请求转发与重定向&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;请求转发和重定向是&lt;/span&gt; web 应用页面跳转的主要手段，应用十分广泛，所以我们一定要搞清楚他们的区别。&lt;/p&gt;
&lt;h3&gt;请求转发：&lt;/h3&gt;
&lt;p align=&quot;justify&quot;&gt;　　1）&lt;span&gt;第一个&lt;/span&gt; Servlet 接收到了浏览器端的请求，进行了一定的处理，然后没有立即对请求进行响应，而是将请求“交给下一个 Servlet”继续处理，下一个 Servlet 处理完成之后对浏览器进行了响应。在服务器内部将请求“交给”其它组件继续处理就是请求的转发。对浏览器来说，一共只发了一次请求，服务器内部进行的“转发”浏览器感觉不到，同时浏览器地址栏中的地址不会变成“下一个 Servlet”的虚拟路径。&lt;/p&gt;
&lt;p&gt;　　2&lt;span&gt;）在转发的情况下，两个&lt;/span&gt; Servlet &lt;span&gt;可以共享&lt;/span&gt; Request 对象中保存的数据&lt;/p&gt;
&lt;p&gt;　　3&lt;span&gt;）转发的情况下，可以访问&lt;/span&gt; WEB-INF 下的资源&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;　　4）&lt;span&gt;当需要将后台获取的数据传送到&lt;/span&gt; JSP &lt;span&gt;上显示的时候，就可以先将数据存放到&lt;/span&gt; Request 对象中，再转发到 JSP 从属性域中获取。此时由于是“转发”，所以它们二者共享 Request 对象中的数据。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ForwardServlet &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; HttpServlet {
    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; doGet(HttpServletRequest request, HttpServletResponse response) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ServletException, IOException {
        System.out.println(&lt;/span&gt;&quot;forwardServlet  doGet&quot;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;请求的转发
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1.调用HTTPServletRequest 的getRequestDispatcher（）方法获取RequestDispatcher对象
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用getRequestDispatcher（）方法时需要传入转发的地址&lt;/span&gt;
        String path = &quot;testServlet&quot;&lt;span&gt;;

        RequestDispatcher requestDispatcher &lt;/span&gt;= request.getRequestDispatcher(&quot;/&quot;+&lt;span&gt;path);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2.调用调用HTTPServletRequest 的forward（request，response）进行请求的转发&lt;/span&gt;
&lt;span&gt;        requestDispatcher.forward(request,response);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;请求重定向：&lt;/h3&gt;
&lt;p align=&quot;justify&quot;&gt;　　1）&lt;span&gt;第一个&lt;/span&gt; Servlet 接收到了浏览器端的请求，进行了一定的处理，然后给浏览器一个特殊的响应消息，这个特殊的响应消息会通知浏览器去访问另外一个资源，这个动作是服务器和浏览器自动完成的，但是在浏览器地址栏里面能够看到地址的改变，会变成下一个资源的地址。&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;　　2）对浏览器来说，一共发送两个请求，所以用户是能够感知到变化的。&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;　　3&lt;span&gt;）在重定向的情况下，不能共享&lt;/span&gt; Request 对象中保存的数据。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; RedirectServlet &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; HttpServlet {
    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; doGet(HttpServletRequest request, HttpServletResponse response) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ServletException, IOException {
        System.out.println(&lt;/span&gt;&quot;RedirectServlet doGet&quot;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行请求的重定向,直接调用reponse.sendRedirect（path）方法
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;path为重定向的地址&lt;/span&gt;
        String path = &quot;testServlet&quot;&lt;span&gt;;
        response.sendRedirect(path);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 align=&quot;justify&quot;&gt;转发与重定向的区别：&lt;/h3&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;124&quot;&gt;
&lt;p class=&quot;15&quot;&gt; &lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;213&quot;&gt;
&lt;p class=&quot;15&quot;&gt;转发&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;189&quot;&gt;
&lt;p class=&quot;15&quot;&gt;重定向&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;124&quot;&gt;
&lt;p class=&quot;15&quot;&gt;浏览器地址栏&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;213&quot;&gt;
&lt;p class=&quot;15&quot;&gt;不会变化&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;189&quot;&gt;
&lt;p class=&quot;15&quot;&gt;会变化&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;124&quot;&gt;
&lt;p class=&quot;15&quot;&gt;Request&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;213&quot;&gt;
&lt;p class=&quot;15&quot;&gt;同一个请求&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;189&quot;&gt;
&lt;p class=&quot;15&quot;&gt;两次请求&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;124&quot;&gt;
&lt;p class=&quot;15&quot;&gt;API&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;213&quot;&gt;
&lt;p class=&quot;15&quot;&gt;Request 对象&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;189&quot;&gt;
&lt;p class=&quot;15&quot;&gt;Response 对象&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;124&quot;&gt;
&lt;p class=&quot;15&quot;&gt;位置&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;213&quot;&gt;
&lt;p class=&quot;15&quot;&gt;服务器内部完成&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;189&quot;&gt;
&lt;p class=&quot;15&quot;&gt;浏览器完成&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;124&quot;&gt;
&lt;p class=&quot;15&quot;&gt;WEB-INF&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;213&quot;&gt;
&lt;p class=&quot;15&quot;&gt;可以访问&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;189&quot;&gt;
&lt;p class=&quot;15&quot;&gt;不能访问&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;124&quot;&gt;
&lt;p class=&quot;15&quot;&gt;共享请求域数据&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;213&quot;&gt;
&lt;p class=&quot;15&quot;&gt;可以共享&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;189&quot;&gt;
&lt;p class=&quot;15&quot;&gt;不可以共享&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;124&quot;&gt;
&lt;p class=&quot;15&quot;&gt;目标资源&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;213&quot; readability=&quot;5&quot;&gt;
&lt;p class=&quot;15&quot;&gt;必须是当前 Web 应用中的资源&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;189&quot; readability=&quot;5&quot;&gt;
&lt;p class=&quot;15&quot;&gt;不局限于当前 Web 应用&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;&lt;br/&gt;图解转发和重定向&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1168971/201904/1168971-20190418152756629-1036111198.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 18 Apr 2019 07:31:00 +0000</pubDate>
<dc:creator>chen_hao</dc:creator>
<og:description>上篇文章我们讲了servlet的基本原理，这章将讲一下剩余的部分。 HttpServletRequest 接口 该接口是 ServletRequest 接口的子接口，封装了 HTTP</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/java-chen-hao/p/10729903.html</dc:identifier>
</item>
<item>
<title>vue axios封装以及API统一管理 - 小周sri的码农</title>
<link>http://www.cnblogs.com/zhoulifeng/p/10729883.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhoulifeng/p/10729883.html</guid>
<description>&lt;p&gt;在vue项目中，每次和后台交互的时候，经常用到的就是axios请求数据，它是基于promise的http库，可运行在浏览器端和node.js中。当项目越来越大的时候，接口的请求也会越来越多，怎么去管理这些接口?多人合作怎么处理?只有合理的规划，才能方便往后的维护以及修改，&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;安装&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;安装axios依赖包&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
cnpm install axios --save
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;引入&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一般会我会在项目src中新建一个untils目录,其中base用于管理接口域名，http处理请求拦截和响应拦截，user.js负责接口文件(接口文件可以自己新建一个文件夹，然后放对应的接口文件)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1188378/201904/1188378-20190418150734246-145178561.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1.在http.js文件中，用于处理axios中对请求拦截和响应拦截做处理，token处理，并引入element-ui加载动画。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
import axios from 'axios'&lt;span&gt;
import { Loading, Message } from 'element-ui'&lt;span&gt;
import router from '../router/index.js'&lt;span&gt;

let loading

function startLoading() {
    loading =&lt;span&gt; Loading.service({
        lock: true&lt;span&gt;,
        text: '加载中....'&lt;span&gt;,
        background: 'rgba(0, 0, 0, 0.7)'&lt;span&gt;
    })
}

function endLoading() {
    loading.close()
}

// 请求拦截
&lt;span&gt;axios.interceptors.request.use(
    (confing) =&amp;gt;&lt;span&gt; {
        startLoading()

        //设置请求头
        if&lt;span&gt; (localStorage.eToken) {
            confing.headers.Authorization =&lt;span&gt; localStorage.eToken
        }

        return&lt;span&gt; confing
    },
    (error) =&amp;gt;&lt;span&gt; {
        return&lt;span&gt; Promise.reject(error)
    }
)

//响应拦截
&lt;span&gt;
axios.interceptors.response.use(
    (response) =&amp;gt;&lt;span&gt; {
        endLoading()
        return&lt;span&gt; response
    },
    (error) =&amp;gt;&lt;span&gt; {
        Message.error(error.response.data)
        endLoading()

        // 获取状态码
        const { status } =&lt;span&gt; error.response

        if (status === 401&lt;span&gt;) {
            Message.error('请重新登录'&lt;span&gt;)
                //清楚token
            localStorage.removeItem('eToken'&lt;span&gt;)
                //跳转到登录页面
            router.push('/login'&lt;span&gt;)
        }
        return&lt;span&gt; Promise.reject(error)
    }
)
export default axios&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过创建一个axios实例然后export default方法导出，这样使用起来更灵活一些。&lt;/p&gt;
&lt;p&gt;2.在base.js文件中,用于管理我们请求接口的域名，极大的方便后期的维护和开发，如果以后更改域名地址或者增加域名，只需要修改这样就可以了、&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;域名统一管理&lt;/span&gt;

&lt;span&gt;const&lt;/span&gt; &lt;span&gt;base&lt;/span&gt; =&lt;span&gt; {
    url: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://localhost:5001/api&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
}
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; &lt;span&gt;base&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3.接口统一管理,每一个js文件都对应一个功能请求接口管理，在下面实现get,post的实例请求，并且引入qs序列化的处理，使用之前先安装qs&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;安装qs
cnpm install qs &lt;/span&gt;--save
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　3.1:更加模块化管理&lt;/p&gt;
&lt;p&gt;　　3.2:更方便多人开发，有效减少解决命名冲突&lt;/p&gt;
&lt;p&gt;　　3.3:处理接口域名有多个情况&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
import axios &lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;../untils/http&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
import QS &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;qs&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
import &lt;/span&gt;&lt;span&gt;base&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;./base&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;

&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * post方法，对应post请求
 * @desc注册请求
 * @param {String} url [请求的url地址]
 * @param {Object} params [请求时携带的参数]
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
export function &lt;span&gt;userRejister&lt;/span&gt;(data) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; axios({
        url: `${&lt;/span&gt;&lt;span&gt;base&lt;/span&gt;.url}/users/&lt;span&gt;register`,
        method: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;post&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        data: QS.stringify(data)
    })
}
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * get方法，对应get请求
 * @desc登录请求
 * @param {String} url [请求的url地址]
 * @param {Object} params [请求时携带的参数]
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
export function userInfo() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; axios({
        url: `${&lt;/span&gt;&lt;span&gt;base&lt;/span&gt;.url}/profile/&lt;span&gt;all`,
        method: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    })
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4.使用。以上工作做完之后，只需要在我们需要发送请求接口的文件，引入&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;本实例中引入案例
import { &lt;span&gt;userRejister&lt;/span&gt;} &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;../../untils/user.js&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;发送请求axios请求&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;async&lt;/span&gt;&lt;span&gt; submitForm(formName) {
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.$refs[formName].validate(valid =&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (valid) {
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;发送请求&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Promise((resolve, reject) =&amp;gt;&lt;span&gt; {
            &lt;span&gt;userRejister&lt;/span&gt;(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.registerUser)
              .then(response &lt;/span&gt;=&amp;gt;&lt;span&gt; {
                console.log(response);
                resolve();
              })
              .&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;(error =&amp;gt;&lt;span&gt; {
                reject(error);
              });
          });
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
          console.log(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;error submit!!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
          &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }
      });
    },&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上都是这篇文章所有的说明，如果喜欢，可以多多关注一下&lt;/p&gt;
</description>
<pubDate>Thu, 18 Apr 2019 07:28:00 +0000</pubDate>
<dc:creator>小周sri的码农</dc:creator>
<og:description>在vue项目中，每次和后台交互的时候，经常用到的就是axios请求数据，它是基于promise的http库，可运行在浏览器端和node.js中。当项目越来越大的时候，接口的请求也会越来越多，怎么去管理</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhoulifeng/p/10729883.html</dc:identifier>
</item>
<item>
<title>ES 18 - (底层原理) Elasticsearch写入索引数据的过程 以及优化写入过程 - 马瘦风</title>
<link>http://www.cnblogs.com/shoufeng/p/10729751.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shoufeng/p/10729751.html</guid>
<description>&lt;p&gt;&lt;strong&gt;Lucene将index数据分为segment(段)进行存储和管理.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Lucene中, 倒排索引一旦被创建就不可改变, 要添加或修改文档, 就需要重建整个倒排索引, 这就对一个index所能包含的数据量, 或index可以被更新的频率造成了很大的限制.&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;16&quot;&gt;
&lt;p&gt;为了在保留不变性的前提下实现倒排索引的更新, Lucene引入了一个新思路: 使用更多的索引, 也就是通过增加新的补充索引来反映最新的修改, 而不是直接重写整个倒排索引.&lt;/p&gt;
&lt;p&gt;—— 这样就能确保, 从最早的版本开始, 每一个倒排索引都会被查询到, 查询完之后再对结果进行合并.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;添加document的流程&quot;&gt;1.1 添加document的流程&lt;/h2&gt;
&lt;p&gt;① 将数据写入buffer(内存缓冲区);&lt;/p&gt;
&lt;p&gt;② 执行commit操作: buffer空间被占满, 其中的数据将作为新的 index segment 被commit到文件系统的cache(缓存)中;&lt;/p&gt;
&lt;p&gt;③ cache中的index segment通过&lt;code&gt;fsync&lt;/code&gt;强制flush到系统的磁盘上;&lt;/p&gt;
&lt;p&gt;④ 写入磁盘的所有segment将被记录到commit point(提交点)中, 并写入磁盘;&lt;/p&gt;
&lt;p&gt;④ 新的index segment被打开, 以备外部检索使用;&lt;/p&gt;
&lt;p&gt;⑤ 清空当前buffer缓冲区, 等待接收新的文档.&lt;/p&gt;
&lt;p&gt;说明:&lt;/p&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;(a) &lt;code&gt;fsync&lt;/code&gt;是一个Unix系统调用函数, 用来将内存缓冲区buffer中的数据存储到文件系统. 这里作了优化, 是指将文件缓存cache中的所有segment刷新到磁盘的操作.&lt;/p&gt;
&lt;p&gt;(b) &lt;strong&gt;每个Shard都有一个提交点(commit point), 其中保存了当前Shard成功写入磁盘的所有segment.&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;删除document的流程&quot;&gt;1.2 删除document的流程&lt;/h2&gt;
&lt;p&gt;① 提交删除操作, 先查询要删除的文档所属的segment;&lt;/p&gt;
&lt;p&gt;② commit point中包含一个&lt;code&gt;.del&lt;/code&gt;文件, 记录哪些segment中的哪些document被标记为&lt;code&gt;deleted&lt;/code&gt;了;&lt;/p&gt;
&lt;p&gt;③ 当&lt;code&gt;.del&lt;/code&gt;文件中存储的文档足够多时, ES将执行物理删除操作, 彻底清除这些文档.&lt;/p&gt;
&lt;ul readability=&quot;7.5&quot;&gt;&lt;li readability=&quot;8&quot;&gt;
&lt;p&gt;在删除过程中进行搜索操作:&lt;/p&gt;
&lt;p&gt;依次查询所有的segment, 取得结果后, 再根据&lt;code&gt;.del&lt;/code&gt;文件, 过滤掉标记为&lt;code&gt;deleted&lt;/code&gt;的文档, 然后返回搜索结果. —— 也就是被标记为delete的文档, 依然可以被查询到.&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;7&quot;&gt;
&lt;p&gt;在删除过程中进行更新操作:&lt;/p&gt;
&lt;p&gt;将旧文档标记为&lt;code&gt;deleted&lt;/code&gt;, 然后将新的文档写入新的index segment中. 执行查询请求时, 可能会匹配到旧版本的文档, 但由于&lt;code&gt;.del&lt;/code&gt;文件的存在, 不恰当的文档将被过滤掉.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;流程的改进思路&quot;&gt;2.1 流程的改进思路&lt;/h2&gt;
&lt;p&gt;(1) 现有流程的问题:&lt;/p&gt;
&lt;p&gt;插入的新文档必须等待&lt;code&gt;fsync&lt;/code&gt;操作将segment强制写入磁盘后, 才可以提供搜索.而 &lt;code&gt;fsync&lt;/code&gt;操作的代价很大, 使得搜索不够实时.&lt;/p&gt;
&lt;p&gt;(2) 改进写入流程:&lt;/p&gt;
&lt;p&gt;① 将数据写入buffer(内存缓冲区);&lt;/p&gt;
&lt;p&gt;② 不等buffer空间被占满, 而是每隔一定时间(默认1s), 其中的数据就作为新的index segment被commit到文件系统的cache(缓存)中;&lt;/p&gt;
&lt;p&gt;③ index segment 一旦被写入cache(缓存), 就立即打开该segment供搜索使用;&lt;/p&gt;
&lt;p&gt;④ 清空当前buffer缓冲区, 等待接收新的文档.&lt;/p&gt;
&lt;p&gt;—— 这里移除了&lt;code&gt;fsync&lt;/code&gt;操作, 便于后续流程的优化.&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;优化的地方: 过程②和过程③:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;segment进入操作系统的缓存中就可以提供搜索&lt;/strong&gt;, 这个写入和打开新segment的轻量过程被称为&lt;code&gt;refresh&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;设置refresh的间隔&quot;&gt;2.2 设置refresh的间隔&lt;/h2&gt;
&lt;p&gt;Elasticsearch中, 每个Shard每秒都会自动refresh一次, 所以ES是近实时的, 数据插入到可以被搜索的间隔默认是1秒.&lt;/p&gt;
&lt;p&gt;(1) 手动refresh —— 测试时使用, 正式生产中请减少使用:&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;# 刷新所有索引:
POST _refresh
# 刷新某一个索引: 
POST employee/_refresh&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;(2) 手动设置refresh间隔 —— 若要优化索引速度, 而不注重实时性, 可以降低刷新频率:&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;# 创建索引时设置, 间隔1分钟: 
PUT employee
{
    &quot;settings&quot;: {
        &quot;refresh_interval&quot;: &quot;1m&quot;
    }
}
# 在已有索引中设置, 间隔10秒: 
PUT employee/_settings
{
    &quot;refresh_interval&quot;: &quot;10s&quot;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;(3) 当你在生产环境中建立一个大的新索引时, 可以先关闭自动刷新, 要开始使用该索引时再改回来:&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;# 关闭自动刷新: 
PUT employee/_settings
{
    &quot;refresh_interval&quot;: -1 
} 
# 开启每秒刷新: 
PUT employee/_settings
{
    &quot;refresh_interval&quot;: &quot;1s&quot;
} &lt;/code&gt;
&lt;/pre&gt;


&lt;p&gt;&lt;strong&gt;Elasticsearch通过事务日志(&lt;code&gt;translog&lt;/code&gt;)来防止数据的丢失 —— durability持久化.&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;文档持久化到磁盘的流程&quot;&gt;3.1 文档持久化到磁盘的流程&lt;/h2&gt;
&lt;p&gt;① 索引数据在写入内存buffer(缓冲区)的同时, 也写入到translog日志文件中;&lt;/p&gt;
&lt;p&gt;② 每隔&lt;code&gt;refresh_interval&lt;/code&gt;的时间就执行一次refresh:&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;(a) 将buffer中的数据作为新的 index segment, 刷到文件系统的cache(缓存)中;&lt;/p&gt;
&lt;p&gt;(b) index segment一旦被写入文件cache(缓存), 就立即打开该segment供搜索使用;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;③ 清空当前内存buffer(缓冲区), 等待接收新的文档;&lt;/p&gt;
&lt;p&gt;④ 重复①~③, translog文件中的数据不断增加;&lt;/p&gt;
&lt;p&gt;⑤ &lt;strong&gt;每隔一定时间(默认30分钟), 或者当translog文件达到一定大小时, 发生flush操作, 并执行一次全量提交&lt;/strong&gt;:&lt;/p&gt;
&lt;blockquote readability=&quot;20&quot;&gt;
&lt;p&gt;(a) 将此时内存buffer(缓冲区)中的所有数据写入一个新的segment, 并commit到文件系统的cache中;&lt;/p&gt;
&lt;p&gt;(b) 打开这个新的segment, 供搜索使用;&lt;/p&gt;
&lt;p&gt;(c) 清空当前的内存buffer(缓冲区);&lt;/p&gt;
&lt;p&gt;(d) 将translog文件中的所有segment通过&lt;code&gt;fsync&lt;/code&gt;强制刷到磁盘上;&lt;/p&gt;
&lt;p&gt;(e) 将此次写入磁盘的所有segment记录到commit point中, 并写入磁盘;&lt;/p&gt;
&lt;p&gt;(f) 删除当前translog, 创建新的translog接收下一波创建请求.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;扩展: translog也可以被用来提供实时CRUD.&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;当通过id查询、更新、删除一个文档时, 从segment中检索之前, 先检查translog中的最新变化 —— ES总是能够实时地获取到文档的最新版本.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;共计：3599 个字&lt;/p&gt;
&lt;h2 id=&quot;基于translog和commit-point的数据恢复&quot;&gt;3.2 基于translog和commit point的数据恢复&lt;/h2&gt;
&lt;p&gt;(1) 关于translog的配置:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;kbd&gt;flush操作 = 将translog中的记录刷到磁盘上 + 更新commit point信息 + 清空translog文件&lt;/kbd&gt;.&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Elasticsearch默认: &lt;kbd&gt;每隔30分钟&lt;/kbd&gt;就flush一次;&lt;br/&gt;或者: 当translog文件的大小达到上限(默认为512MB)时主动触发flush.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;相关配置为:&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;# 发生多少次操作(累计多少条数据)后进行一次flush, 默认是unlimited: 
index.translog.flush_threshold_ops

# 当translog的大小达到此预设值时, 执行一次flush操作, 默认是512MB: 
index.translog.flush_threshold_size

# 每隔多长时间执行一次flush操作, 默认是30min:
index.translog.flush_threshold_period

# 检查translog、并执行一次flush操作的间隔. 默认是5s: ES会在5-10s之间进行一次操作: 
index.translog.interval&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;(2) 数据的故障恢复:&lt;/p&gt;
&lt;p&gt;① 增删改操作成功的标志: segment被成功刷新到Primary Shard和其对应的Replica Shard的磁盘上, 对应的操作才算成功.&lt;/p&gt;
&lt;p&gt;② &lt;strong&gt;translog文件中存储了上一次flush(即上一个commit point)到当前时间的所有数据的变更记录. —— 即translog中存储的是还没有被刷到磁盘的所有最新变更记录.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;③ ES发生故障, 或重启ES时, 将根据磁盘中的commit point去加载已经写入磁盘的segment, 并重做translog文件中的所有操作, 从而保证数据的一致性.&lt;/p&gt;
&lt;p&gt;(3) 异步刷新translog:&lt;/p&gt;
&lt;p&gt;为了保证不丢失数据, 就要保护translog文件的安全:&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;Elasticsearch 2.0之后, 每次写请求(如index、delete、update、bulk等)完成时, 都会触发&lt;code&gt;fsync&lt;/code&gt;将translog中的segment刷到磁盘, 然后才会返回&lt;code&gt;200 OK&lt;/code&gt;的响应;&lt;/p&gt;
&lt;p&gt;或者: 默认&lt;kbd&gt;每隔5s&lt;/kbd&gt;就将translog中的数据通过&lt;code&gt;fsync&lt;/code&gt;强制刷新到磁盘.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;—— 提高数据安全性的同时, 降低了一点性能.&lt;/p&gt;
&lt;p&gt;==&amp;gt; 频繁地执行&lt;code&gt;fsync&lt;/code&gt;操作, 可能会产生阻塞导致部分操作耗时较久. &lt;strong&gt;如果允许部分数据丢失, 可设置异步刷新translog来提高效率.&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;PUT employee/_settings
{
    &quot;index.translog.durability&quot;: &quot;async&quot;,
    &quot;index.translog.sync_interval&quot;: &quot;5s&quot;
}&lt;/code&gt;
&lt;/pre&gt;


&lt;h2 id=&quot;存在的问题&quot;&gt;4.1 存在的问题&lt;/h2&gt;
&lt;p&gt;由上述近实时性搜索的描述, 可知ES默认每秒都会产生一个新的segment文件, 而每次搜索时都要遍历所有的segment, 这非常影响搜索性能.&lt;/p&gt;
&lt;p&gt;为解决这一问题, ES会对这些零散的segment进行merge(归并)操作, 尽量让索引中只保有少量的、体积较大的segment文件.&lt;/p&gt;
&lt;p&gt;这个过程由独立的merge线程负责, 不会影响新segment的产生.&lt;/p&gt;
&lt;p&gt;同时, &lt;strong&gt;在merge段文件(segment)的过程中, 被标记为deleted的document也会被彻底物理删除.&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;merge操作的流程&quot;&gt;4.2 merge操作的流程&lt;/h2&gt;
&lt;p&gt;① 选择一些有相似大小的segment, merge成一个大的segment;&lt;br/&gt;② 将新的segment刷新到磁盘上;&lt;br/&gt;③ 更新commit文件: 写一个新的commit point, 包括了新的segment, 并删除旧的segment;&lt;br/&gt;④ 打开新的segment, 完成搜索请求的转移;&lt;br/&gt;⑤ 删除旧的小segment.&lt;/p&gt;
&lt;h2 id=&quot;优化merge的配置项&quot;&gt;4.3 优化merge的配置项&lt;/h2&gt;
&lt;p&gt;segment的归并是一个非常消耗系统CPU和磁盘IO资源的任务, 所以ES对归并线程提供了限速机制, 确保这个任务不会过分影响到其他任务.&lt;/p&gt;
&lt;p&gt;(1) 归并线程的速度限制:&lt;/p&gt;
&lt;p&gt;限速配置 &lt;code&gt;indices.store.throttle.max_bytes_per_sec&lt;/code&gt;的默认值是20MB, 这对写入量较大、磁盘转速较高的服务器来说明显过低.&lt;/p&gt;
&lt;p&gt;对ELK Stack应用, 建议将其调大到100MB或更高. 可以通过API设置, 也可以写在配置文件中:&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;PUT _cluster/settings
{
    &quot;persistent&quot; : {
        &quot;indices.store.throttle.max_bytes_per_sec&quot; : &quot;100mb&quot;
    }
}
// 响应结果如下: 
{
    &quot;acknowledged&quot;: true,
    &quot;persistent&quot;: {
        &quot;indices&quot;: {
            &quot;store&quot;: {
                &quot;throttle&quot;: {
                    &quot;max_bytes_per_sec&quot;: &quot;100mb&quot;
                }
            }
        }
    },
    &quot;transient&quot;: {}
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;(2) 归并线程的数目:&lt;/p&gt;
&lt;p&gt;推荐设置为CPU核心数的一半, 如果磁盘性能较差, 可以适当降低配置, 避免发生磁盘IO堵塞:&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;PUT employee/_settings
{
    &quot;index.merge.scheduler.max_thread_count&quot; : 8
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;(3) 其他策略:&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;# 优先归并小于此值的segment, 默认是2MB:
index.merge.policy.floor_segment

# 一次最多归并多少个segment, 默认是10个: 
index.merge.policy.max_merge_at_once

# 一次直接归并多少个segment, 默认是30个
index.merge.policy.max_merge_at_once_explicit

# 大于此值的segment不参与归并, 默认是5GB. optimize操作不受影响
index.merge.policy.max_merged_segment&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;optimize接口的使用&quot;&gt;4.4 optimize接口的使用&lt;/h2&gt;
&lt;p&gt;segment的默认大小是5GB, 在非常庞大的索引中, 仍然会存在很多segment, 这对文件句柄、内存等资源都是很大的浪费.&lt;/p&gt;
&lt;p&gt;但由于归并任务非常消耗资源, 所以一般不会选择加大 &lt;code&gt;index.merge.policy.max_merged_segment&lt;/code&gt; 配置, 而是在负载较低的时间段, 通过&lt;code&gt;optimize&lt;/code&gt;接口强制归并segment:&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;# 强制将segment归并为1个大的segment: 
POST employee/_optimize?max_num_segments=1

# 在终端中的操作方法: 
curl -XPOST http://ip:5601/employee/_optimize?max_num_segments=1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;optimize线程不会受到任何资源上的限制, 所以不建议对还在写入数据的热索引(动态索引)执行这个操作.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;实战建议: 对一些很少发生变化的老索引, 如日志信息, 可以将每个Shard下的segment合并为一个单独的segment, 节约资源, 还能提高搜索效率.&lt;/p&gt;
&lt;blockquote readability=&quot;0.58933333333333&quot;&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.51cto.com/tchuairen/1861603&quot;&gt;Elasticsearch 基础理论 &amp;amp; 配置调优&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.elastic.co/guide/cn/elasticsearch/guide/current/making-text-searchable.html&quot; class=&quot;uri&quot;&gt;https://www.elastic.co/guide/cn/elasticsearch/guide/current/making-text-searchable.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.elastic.co/guide/cn/elasticsearch/guide/current/near-real-time.html&quot; class=&quot;uri&quot;&gt;https://www.elastic.co/guide/cn/elasticsearch/guide/current/near-real-time.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.elastic.co/guide/cn/elasticsearch/guide/current/translog.html&quot; class=&quot;uri&quot;&gt;https://www.elastic.co/guide/cn/elasticsearch/guide/current/translog.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.elastic.co/guide/cn/elasticsearch/guide/current/merge-process.html&quot; class=&quot;uri&quot;&gt;https://www.elastic.co/guide/cn/elasticsearch/guide/current/merge-process.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;14.747826086957&quot;&gt;

&lt;p&gt;作者: &lt;a href=&quot;https://healchow.com&quot;&gt;马瘦风&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;出处: 博客园 &lt;a href=&quot;https://www.cnblogs.com/shoufeng&quot;&gt;马瘦风的博客&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;感谢阅读, 如果文章有帮助或启发到你, 点个👇[好文要顶] | [推荐] 👇吧😜&lt;/p&gt;
&lt;p&gt;本文版权归博主所有, 欢迎转载, 但请保留此段声明, 并在文章页面明显位置给出原文链接, 否则博主保留追究相关人员法律责任的权利.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Thu, 18 Apr 2019 07:12:00 +0000</pubDate>
<dc:creator>马瘦风</dc:creator>
<og:description>Elasticsearch是如何通过Lucene把索引数据写入磁盘的? 为了实现更快的实时性、更可靠的数据持久化, 以及更高效的大量segment文件的归并, 还能不能优化这个过程? 本片文章介绍一些</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shoufeng/p/10729751.html</dc:identifier>
</item>
<item>
<title>如何正确使用Java序列化？ - JJian</title>
<link>http://www.cnblogs.com/jian0110/p/10724765.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jian0110/p/10724765.html</guid>
<description>&lt;blockquote readability=&quot;15&quot;&gt;
&lt;p&gt;　　&lt;strong&gt;什么是序列化：将对象编码成一个字节流，这样一来就可以在通信中传递对象了。比如在一台虚拟机中被传递到另一台虚拟机中，或者字节流存储到磁盘上。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　“关于Java的序列化，无非就是简单的实现Serializable接口”这样的说法只能说明停留在会用的阶段，而我们想要走的更远往往就需要了解更多的东西，比如：&lt;strong&gt;为什么要实现序列化？序列化对程序的安全性有啥影响？如何避免多余的序列化？.....&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;本文主要参考资料《Effective Java》，其中代码除了只作部分说明，不能运行外，剩余代码都是亲自实践过的！&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr/&gt;


&lt;p&gt;虽然实现Serializable很简单，但是为了序列化而付出的长期开销往往是实实在在的。实现Serializable接口而付出的最大代价是，一旦一个类被发布，就大大降低了“改变这个类的实现”的灵活性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　问：这个灵活性具体是指什么呢？&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;　　即一旦类实现了Serializable接口，并且这个类被广泛地使用，往往必须永远支持这种序列化形式，如果使用默认的序列化形式，那么这种序列化形式将永远地束缚在该类最初的内部表示法上，换句话说，&lt;span&gt;&lt;strong&gt;一旦接受了默认的序列化形式，这个类中私有的和包级私有的实例域都变成导出的API的一部分，这显然是不符合的。这也就是实现序列化往往需要考虑到的几个代价，具体请往下看！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;1、可能会导致InvalidClassException异常&lt;/h3&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;如果没有显式声明序列版本UID，对对象的需求进行了改动，那么兼容性将会遭到破坏，在运行时导致InvalidClassException。&lt;/strong&gt;&lt;/span&gt;比如：增加一个不是很重要的工具方法，自动产生的序列版本UID也会发生变化，则会出现序列版本UID不一致的情况。所以最好还是显式的增加序列版本号UID。&lt;/p&gt;
&lt;p&gt;　　对User JavaBean实现Serializable接口，增加固定的序列版本号&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; User &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Serializable {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 显示增加序列版本UUID，自动生成UUID可能会导致InvalidClassException &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; serialVersionUID = 1L&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; User(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id, String name) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.id =&lt;span&gt; id;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; id;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getId() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; id;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setId(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.id =&lt;span&gt; id;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getName() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; name;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setName(String name) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;User{&quot; +
                &quot;id=&quot; + id +
                &quot;, name='&quot; + name + '\'' +
                '}'&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　使用ObjectOutputStream与ObjectInputStream流控制序列与反序列&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; jian
 * @date 2019/4/5
 * @description 测试序列化
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SeriablizableTest {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        User user &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; User(1, &quot;lijian&quot;&lt;span&gt;);
        serializeUser(user);
        deserializeUser();

    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 使用writeObject方法序列化
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; user
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; serializeUser(User user) {
        ObjectOutputStream outputStream &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建对象输出流, 包装一个其它类型目标输出流，如文件流&lt;/span&gt;
            outputStream = &lt;span&gt;new&lt;/span&gt; ObjectOutputStream(&lt;span&gt;new&lt;/span&gt; FileOutputStream(&quot;D:\\user.txt&quot;&lt;span&gt;));
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过对象输出流的writeObject方法将对象user写入流中&lt;/span&gt;
&lt;span&gt;            outputStream.writeObject(user);
            System.out.println(&lt;/span&gt;&quot;user序列化成功！&quot;&lt;span&gt;);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
            e.printStackTrace();
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (outputStream != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    outputStream.close();
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; deserializeUser() {
        User user &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        Employee employee &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        ObjectInputStream inputStream &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建对象输出流, 包装一个其它类型目标输出流，如文件流&lt;/span&gt;
            inputStream = &lt;span&gt;new&lt;/span&gt; ObjectInputStream(&lt;span&gt;new&lt;/span&gt; FileInputStream(&quot;D:\\user.txt&quot;&lt;span&gt;));
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过对象输出流的writeObject方法将对象user写入流中&lt;/span&gt;
            user =&lt;span&gt; (User)inputStream.readObject();
            System.out.println(&lt;/span&gt;&quot;user反序列化成功：&quot; +&lt;span&gt; user);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (ClassNotFoundException e) {
            e.printStackTrace();
        }  &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
            e.printStackTrace();
        }
        &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (inputStream != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    inputStream.close();
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
                    e.printStackTrace();
                }
            }
        }

    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出结果：先看user.txt文件中二进制文件流（因为txt打不开二进制流，所以是乱码）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1352849/201904/1352849-20190417164051824-843754233.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;之后再看控制台中，反序列化输出的User{id=1, name='lijian'}，说明整个过程序列化成功！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1352849/201904/1352849-20190417162749529-2068259607.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;之后去掉固定的序列版本号UID，让其自动生成，同时增加age属性（或者手动修改UID为2L）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; serialVersionUID = 2L;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;只进行反序列化将会报错： &lt;span class=&quot;cnblogs_code&quot;&gt;java.io.InvalidClassException&lt;/span&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        User user &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; User(1, &quot;lijian&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        serializeUser(user);&lt;/span&gt;
&lt;span&gt;        deserializeUser();

    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1352849/201904/1352849-20190417172441480-810988787.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;2、增加了出现Bug和安全漏洞的可能性&lt;/h3&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;序列化机制是一种语言之外的对象创建机制，反序列化机制都是一个“隐藏的构造器”&lt;/strong&gt;&lt;/span&gt;，具备与其他构造器相同的特点，正式因为反序列化中没有显式构造器，所以很容易就会忽略：不允许攻击者访问正在构造过程中的对象内部信息。&lt;span&gt;&lt;strong&gt;换句话说，序列化后的字节流可以被截取进行伪造，之后利用readObject方法反序列会不符合要求甚至不安全的实例。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1352849/201904/1352849-20190417170819758-1450049661.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;


&lt;h3&gt;3、随着类发行新的版本，测试负担也会增加。&lt;/h3&gt;
&lt;p&gt;　　一个可序列化的类被修订时，需要检查是否“在新版本中序列化一个实例，可以在旧版本中反序列化”，如果一个实现序列化的类有很多的子类或者是被修改时，就不得不加以测试。&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;1、序列化是保存对象的状态，也就是不会关心static静态域，静态域不会被序列化。如User中count静态域。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; User &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Serializable {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; serialVersionUID = 1L&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; count = 1&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; User(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id, String name) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 约束条件name不能为null&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (name == &lt;span&gt;null&lt;/span&gt; ||&lt;span&gt; StringUtils.isEmpty(name)) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; NullPointerException(&quot;name is null&quot;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.id =&lt;span&gt; id;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; User(){};

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; id;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getId() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; id;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setId(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.id =&lt;span&gt; id;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getName() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; name;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setName(String name) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getCount() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; count;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setCount(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; count) {
        User.count &lt;/span&gt;=&lt;span&gt; count;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;User{&quot; +
                &quot;id=&quot; + id +
                &quot;, name='&quot; + name + '\'' +
                &quot;, count=&quot; + count +
                '}'&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; readObject(ObjectInputStream inputStream)
            &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException, ClassNotFoundException {
        inputStream.defaultReadObject();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 约束条件name不能为null&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (name == &lt;span&gt;null&lt;/span&gt; ||&lt;span&gt; StringUtils.isEmpty(name)) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; NullPointerException(&quot;name is null&quot;&lt;span&gt;);
        }
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;赋值count为20：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        User user &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; User();
        user.setName(&lt;/span&gt;&quot;Lijian&quot;&lt;span&gt;);
        user.setId(&lt;/span&gt;1&lt;span&gt;);
        user.setCount(&lt;/span&gt;20&lt;span&gt;);
        serializeUser(user);
        deserializeUser();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;序列化-反序列化&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 使用writeObject方法序列化
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; user
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; serializeUser(User user) {
        ObjectOutputStream outputStream &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建对象输出流, 包装一个其它类型目标输出流，如文件流&lt;/span&gt;
            outputStream = &lt;span&gt;new&lt;/span&gt; ObjectOutputStream(&lt;span&gt;new&lt;/span&gt; FileOutputStream(&quot;D:\\user.txt&quot;&lt;span&gt;));
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过对象输出流的writeObject方法将对象user写入流中&lt;/span&gt;
&lt;span&gt;            outputStream.writeObject(user);
            System.out.println(&lt;/span&gt;&quot;user序列化成功！&quot;&lt;span&gt;);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
            e.printStackTrace();
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (outputStream != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    outputStream.close();
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; deserializeUser() {
        User user &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        ObjectInputStream inputStream &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建对象输出流, 包装一个其它类型目标输出流，如文件流&lt;/span&gt;
            inputStream = &lt;span&gt;new&lt;/span&gt; ObjectInputStream(&lt;span&gt;new&lt;/span&gt; FileInputStream(&quot;D:\\user.txt&quot;&lt;span&gt;));
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过对象输出流的writeObject方法将对象user写入流中&lt;/span&gt;
            user =&lt;span&gt; (User)inputStream.readObject();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; User静态变量初始化为0，不会被反序列化&lt;/span&gt;
            System.out.println(&quot;user反序列化成功！&quot;&lt;span&gt;);
            System.out.println(&lt;/span&gt;&quot;id：&quot; +&lt;span&gt; user.getId());
            System.out.println(&lt;/span&gt;&quot;name：&quot; +&lt;span&gt; user.getName());
            System.out.println(&lt;/span&gt;&quot;count：&quot; +&lt;span&gt; user.getCount());
        }  &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (ClassNotFoundException e) {
            e.printStackTrace();
        }  &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
            e.printStackTrace();
        }
        &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (inputStream != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    inputStream.close();
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
                    e.printStackTrace();
                }
            }
        }

    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;控制它输出：count明明被赋值为20，但是反序列化后输出为0，&lt;span&gt;&lt;strong&gt;说明static是不会参数序列化的，跟transient类似。最终在反序列化过程中会被初始化为默认值（基本数据类型为0，对象引用为null，boolean为false）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1352849/201904/1352849-20190418145734571-1058870622.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;2、在序列化对象时，如果该对象中有引用对象域名，那么也要要求该引用对象是可实例化的。&lt;/strong&gt;&lt;/span&gt;如序列化User实例，其中引用了Employee实例，那么也需要对Employee进行可序列化操作，否则会报错： &lt;span class=&quot;cnblogs_code&quot;&gt;java.io.NotSerializableException&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;User增加对Employee引用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 对外引用其它对象，如果序列化该实例，则该对象实例也必须能实例化（implement Serializable） &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; Employee employee = &lt;span&gt;new&lt;/span&gt; Employee(1, &quot;Java programmer&quot;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　Employee不实现序列化：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Employee&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; code;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String position;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getCode() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; code;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setCode(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; code) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.code =&lt;span&gt; code;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getPosition() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; position;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setPosition(String position) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.position =&lt;span&gt; position;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Employee(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; code, String position) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.code =&lt;span&gt; code;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.position =&lt;span&gt; position;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;Employee{&quot; +
                &quot;code=&quot; + code +
                &quot;, position='&quot; + position + '\'' +
                '}'&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; jian
 * @date 2019/4/5
 * @description 测试序列化
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SeriablizableTest {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        User user &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; User(1, &quot;lijian&quot;&lt;span&gt;);
        serializeUser(user);
        deserializeUser();

    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 使用writeObject方法序列化
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; user
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; serializeUser(User user) {
        ObjectOutputStream outputStream &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建对象输出流, 包装一个其它类型目标输出流，如文件流&lt;/span&gt;
            outputStream = &lt;span&gt;new&lt;/span&gt; ObjectOutputStream(&lt;span&gt;new&lt;/span&gt; FileOutputStream(&quot;D:\\user.txt&quot;&lt;span&gt;));
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过对象输出流的writeObject方法将对象user写入流中&lt;/span&gt;
&lt;span&gt;            outputStream.writeObject(user);
            System.out.println(&lt;/span&gt;&quot;user序列化成功！&quot;&lt;span&gt;);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (NotSerializableException e) {
            System.out.println(&lt;/span&gt;&quot;user引用employee对象域序列化失败&quot;&lt;span&gt;);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
            e.printStackTrace();
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (outputStream != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    outputStream.close();
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; deserializeUser() {
        User user &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        Employee employee &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; id = 0&lt;span&gt;;
        ObjectInputStream inputStream &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建对象输出流, 包装一个其它类型目标输出流，如文件流&lt;/span&gt;
            inputStream = &lt;span&gt;new&lt;/span&gt; ObjectInputStream(&lt;span&gt;new&lt;/span&gt; FileInputStream(&quot;D:\\user.txt&quot;&lt;span&gt;));
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过对象输出流的writeObject方法将对象user写入流中&lt;/span&gt;
            user =&lt;span&gt; (User)inputStream.readObject();
            System.out.println(&lt;/span&gt;&quot;user引用employee对象域反序列化成功&quot;&lt;span&gt;);
            System.out.println(&lt;/span&gt;&quot;user反序列化成功：&quot; +&lt;span&gt; user);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (WriteAbortedException e) {
            System.out.println(&lt;/span&gt;&quot;user引用employee对象域反序列化失败&quot;&lt;span&gt;);
        }  &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (ClassNotFoundException e) {
            e.printStackTrace();
        }  &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
            e.printStackTrace();
        }
        &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (inputStream != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    inputStream.close();
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
                    e.printStackTrace();
                }
            }
        }

    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;控制台输出结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1352849/201904/1352849-20190418091738684-1992954648.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;要解决这样的问题，要么将 &lt;span class=&quot;cnblogs_code&quot;&gt;Employee implement Serializable&lt;/span&gt; ，要么对Employee对象实例transient修饰： &lt;span class=&quot;cnblogs_code&quot;&gt;public transient Employee employee = new Employee(1, &quot;Java programmer&quot;);&lt;/span&gt; 。但是需要注意的是序列化过程会对transient修饰的域初始化为默认值（对象引用为null，基本数据类型为0，boolean为false）&lt;/strong&gt;&lt;/span&gt;，所以执行以上代码会出现 &lt;span class=&quot;cnblogs_code&quot;&gt;java.lang.NullPointerException&lt;/span&gt; &lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;3、默认序列化的过程可能消耗大量内存空间和时间，甚至可能会引起栈溢出：&lt;/strong&gt;&lt;/span&gt;因为第二条的原因，如果一个类中大量存在引用对象域，并且都需要实现序列化，那么整个序列化过程可能会很消耗时间，在通信传输过程中更是如此，同时序列化后的字节流需要足够大的内存。&lt;/p&gt;

&lt;h3&gt;1、编写readObject提供安全性与约束性&lt;/h3&gt;
&lt;p&gt;　　即使确定了默认的序列化形式是合适的，通常还必须提供一个readObject方法以保证约束关系和安全性。&lt;span&gt;&lt;strong&gt;readObject方法相当于另一个共有构造器（可以认为是用“字节流作为唯一参数”的构造器）&lt;/strong&gt;，&lt;strong&gt;跟其它构造器一样，它也要求同样的所有主要事项：构造器必须检查参数的有效性，必要时对参数进行保护性拷贝等。&lt;/strong&gt;&lt;/span&gt;readObject如果没有做到，那么对于攻击者来说违反这个类的约束条件相对就比较简单了，如果对一个人工仿造的字节流（人工修改从实例序列后的字节流）时，readObject产生的对象会违反所属类的约束条件。&lt;/p&gt;
&lt;p&gt;　&lt;span&gt;&lt;strong&gt;　1）&lt;/strong&gt;&lt;strong&gt;为了解决这个问题，User中需要提供了readObject方法，该方法首先调用defalutReadObject，然后检查被反序列化之后的对象的有效性，如果有效性检查失败，readObject方法就会抛出InvalidObjectException异常，使反序列过程不能成功。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; readObject(ObjectInputStream inputStream)
            &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException, ClassNotFoundException {
        inputStream.defaultReadObject();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　User中的构造器中已对参数name约束为不能为null&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; User(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id, String name) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 约束条件name不能为null或空&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (name == &lt;span&gt;null&lt;/span&gt; ||&lt;span&gt; StringUtils.isEmpty(name)) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; NullPointerException(&quot;name is null or empty&quot;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.id =&lt;span&gt; id;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;2）&lt;/strong&gt;&lt;strong&gt;那么readObject中也应该对其name进行约束，否则人工伪造的字节流很容易通过readObject构造出没有任何约束的对象实例，造成安全隐患。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; readObject(ObjectInputStream inputStream)
            &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException, ClassNotFoundException {
        inputStream.defaultReadObject();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 约束条件name不能为null或空&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (name == &lt;span&gt;null&lt;/span&gt; ||&lt;span&gt; StringUtils.isEmpty(name)) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; NullPointerException(&quot;name is null or empty&quot;&lt;span&gt;); &lt;br/&gt;　　　　 }&lt;br/&gt;} &lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　尽管以上两种修正已经有效地避免攻击者创建无效的User实例，但是还有一种情况通过伪造字节流可以创建可变的User实例：比如User中增加Date对象引用birthday私有域，然后通过附加伪造字节流指向该birthday引用，攻击者从ObjectInputStream中读取User实例，然后读取附加后面的恶意Date引用，通过该Date引用就可以能够访问User对象内部私有Date域所引用的对象，从而改变User实例。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1352849/201904/1352849-20190418112859686-1847005874.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MutableUser {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; User user;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Date birthday;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; MutableUser(){
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            ByteArrayOutputStream bos &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ByteArrayOutputStream();
            ObjectOutputStream out &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ObjectOutputStream(bos);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 字节流有效的User实例开头，然后附加额外的引用&lt;/span&gt;
            out.writeObject(&lt;span&gt;new&lt;/span&gt; User(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date()));
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 假设这是恶意的二进制，即附加恶意对象引用Date&lt;/span&gt;
            &lt;span&gt;byte&lt;/span&gt;[] ref = {0x71, 0, 0x7e, 0 ,5&lt;span&gt;};
            bos.write(ref);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 攻击者从ObjectInputStream中读取User实例，然后读取附加在后面的“恶意编制对象引用Date”&lt;/span&gt;
            ObjectInputStream in = &lt;span&gt;new&lt;/span&gt; ObjectInputStream(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ByteArrayInputStream(bos.toByteArray()));
            user &lt;/span&gt;=&lt;span&gt; (User) in.readObject();
            birthday &lt;/span&gt;=&lt;span&gt; (Date) in.readObject();

        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
　　　　　　
        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        MutableUser mutableUser &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MutableUser();
        User user &lt;/span&gt;=&lt;span&gt; mutableUser.user;
        Date birthday &lt;/span&gt;=&lt;span&gt; mutableUser.birthday;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 攻击者修改User内部birthday私有域，年份更改为2018&lt;/span&gt;
        birthday.setTime(2018&lt;span&gt;);
        System.out.println(user);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注：以上代码运行不了，只会加以解释说明而已，具体可以查看《Effective Java》中的代码举例&lt;/p&gt;
&lt;p&gt;为了解决此问题，提出第三个安全措施&lt;/p&gt;
&lt;p&gt;　&lt;span&gt;&lt;strong&gt;3）&lt;/strong&gt;&lt;strong&gt;当一个对象被反序列化时，客户端不应该拥有对象的引用，如果哪个域包含了这样的对象引用，如果包含了私有的域（组件），就必须要保护性拷贝（非final域）：&lt;/strong&gt;&lt;/span&gt;当User对象在客户端MutableUser反序列化时，客户端拥有 了不该拥有的User私有域Date引用birthday，所以应该在readObject对birthday进行拷贝：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; readObject(ObjectInputStream inputStream)
            &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException, ClassNotFoundException {
        inputStream.defaultReadObject();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 保护性拷贝birthday&lt;/span&gt;
        birthday = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date(birthday.getTime());
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 约束条件name不能为null&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (name == &lt;span&gt;null&lt;/span&gt; ||&lt;span&gt; StringUtils.isEmpty(name)) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; NullPointerException(&quot;name is null&quot;&lt;span&gt;);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;总结：&lt;/h2&gt;
&lt;p&gt;　　&lt;strong&gt;1）使用readObject其实就跟正常无参数的构造器一样，该满足的约束需要满足，同时必要时进行保护性拷贝。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　2）反序列化过程最终会调用readObject方法，如下是一个异常栈的调用关系（代码中故意让readObject方法抛异常）：deserialize----&amp;gt;ObjectInputStream.readObject-----&amp;gt;ObjectInputStream.readObject0-----&amp;gt;......User.readObject&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1352849/201904/1352849-20190418144108396-1100868226.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;2、使用readResolve增强单例&lt;/h3&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;但是如果Sinleton类实现了序列化，那么它不再是一个Singleton，无论该类使用了默认的序列化形式，还是自定义的序列化形式，还是是否提供显式的readObject方法都没关系&lt;/strong&gt;&lt;/span&gt;。任何一个readObject方法，不管是显式还是默认的，它都会返回一个新建的实例，这个新建的实例不同于该类初始化时创建的实例。&lt;/p&gt;
&lt;p&gt;　　简单的Singleton：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Singleton {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Singleton INSTANCE= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Singleton();
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Singleton(){};
　　.....&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;readResolve特性允许使用readObject创建实例代替另一个实例，如果一个类定义了readResolve方法，并且具备正确的声明，那么在反序列化的之后，新建的readResolve方法就会被调用，然后返回的对象引用将被返回，取代新建的对象。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Singleton &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Serializable {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Singleton INSTANCE= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Singleton();
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Singleton(){};
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Object readResolve(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; INSTANCE;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Thu, 18 Apr 2019 07:07:00 +0000</pubDate>
<dc:creator>JJian</dc:creator>
<og:description>前言 什么是序列化：将对象编码成一个字节流，这样一来就可以在通信中传递对象了。比如在一台虚拟机中被传递到另一台虚拟机中，或者字节流存储到磁盘上。 “关于Java的序列化，无非就是简单的实现Serial</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jian0110/p/10724765.html</dc:identifier>
</item>
<item>
<title>详解封装微信小程序组件及小程序坑(附带解决方案) - Mr.聂</title>
<link>http://www.cnblogs.com/pengfei-nie/p/10729694.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pengfei-nie/p/10729694.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;一、序&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　上一篇介绍了如何从零开发微信小程序，博客园审核变智障了，每次代码都不算篇幅，好好滴一篇原创，不到3分钟从首页移出来了。这篇介绍一下组件封装和我的踩坑历程。&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、封装微信小程序可复用组件&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　首先模块化的思想是通用的，在这不做过多解释了。直接上代码，然后解释代码：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; wxml&lt;/span&gt;
&amp;lt;view class=&quot;c-menu&quot;&amp;gt;
  &amp;lt;view wx:&lt;span&gt;for&lt;/span&gt;=&quot;{{menuList}}&quot; wx:key=&quot;{{item}}&quot; class=&quot;menuItem&quot;&amp;gt;
    &amp;lt;navigator url=&quot;/pages/my{{item.path}}&quot; class=&quot;navigator&quot;&amp;gt;
      &amp;lt;image class=&quot;imgIcon&quot; src=&quot;{{item.icon}}&quot;&amp;gt;&amp;lt;/image&amp;gt;
      &amp;lt;view class=&quot;navigator-text&quot; data-id=&quot;{{item.key}}&quot; bindtap=&quot;handleMenuTap&quot;&amp;gt;{{item.name}}&amp;lt;/view&amp;gt;
    &amp;lt;/navigator&amp;gt;
    &amp;lt;image class=&quot;imgGo&quot; src=&quot;../../image/youxiang.png&quot;&amp;gt;&amp;lt;/image&amp;gt;
  &amp;lt;/view&amp;gt;
&amp;lt;/view&amp;gt;



&lt;span&gt;//&lt;/span&gt;&lt;span&gt; js&lt;/span&gt;
&lt;span&gt;Component({
  properties: {
    menuList: {    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 菜单列表&lt;/span&gt;
&lt;span&gt;      type: Array,
      value: [],
    },
    menuEvent: {    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 菜单点击的自定义事件名称&lt;/span&gt;
&lt;span&gt;      type: String,
      value: &lt;/span&gt;''&lt;span&gt;,
    },
  },
  data: {
  },
  ready: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {

  },
  methods: {
    handleMenuTap:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
      const { menuEvent } &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.data
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (menuEvent) &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.triggerEvent(menuEvent, {})
    }
  }
})


&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;json &lt;/span&gt;
&lt;span&gt;{
  &lt;/span&gt;&quot;component&quot;: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;wxss&lt;/span&gt;
.c-&lt;span&gt;menu{
  width: &lt;/span&gt;100%&lt;span&gt;;
  background&lt;/span&gt;-&lt;span&gt;color: white;
  margin&lt;/span&gt;-&lt;span&gt;top: 10px;
}
.menuItem{
  position: relative;
  box&lt;/span&gt;-sizing: border-&lt;span&gt;box;
}
.navigator&lt;/span&gt;-&lt;span&gt;text{
  padding&lt;/span&gt;-&lt;span&gt;left: 65px;
}
.navigator{
  position: relative;
  box&lt;/span&gt;-sizing: border-&lt;span&gt;box;
  width: &lt;/span&gt;100%&lt;span&gt;;
  height: 60px;
  line&lt;/span&gt;-&lt;span&gt;height: 60px;
  border&lt;/span&gt;-&lt;span&gt;bottom: 2px solid #F7F7F7;
}
.imgGo{
  position: absolute;
  width: 18px;
  height: 18px;
  top: 22px;
  right: 15px;
}
.imgIcon{
 position: absolute;
 width: 29px;
 height: 29px;
 top: 15px;
 left: 18px;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　首先介绍思路：&lt;/p&gt;
&lt;p&gt;　　　　这是一个简单菜单组件；输入菜单数据 menuList ， 暴露出 菜单点击事件的回调  menuEvent。&lt;/p&gt;
&lt;p&gt;　　然后介绍一下小程序封装组件的特殊之处：&lt;/p&gt;
&lt;p&gt;　　　　1、json 配置文件需要配置   &quot;component&quot;: true  ,  表名这是个组件&lt;/p&gt;
&lt;p&gt;　　　　2、js 里面使用 Component({})方法构造组件&lt;/p&gt;
&lt;p&gt;　　　　3、properties  组件接收的属性在这里面声明，包括数据类型和默认值&lt;/p&gt;
&lt;p&gt;　　　　4、生命周期通常用 ready 代表其准备完毕。&lt;/p&gt;
&lt;p&gt;　　最后介绍一下组件使用的方法：&lt;/p&gt;
&lt;p&gt;　　　　1、在要用组件的json文件 &lt;/p&gt;
&lt;pre&gt;
　　　　　　　　&quot;usingComponents&quot;: {&lt;br/&gt;　　　　　　　　　　&quot;menu&quot;: &quot;/components/menu/index&quot;&lt;br/&gt;　　　　　　　　 }&lt;br/&gt;　　　　2、在wxml里面使用，并准备好组件需要的数据
&lt;/pre&gt;
&lt;pre&gt;
　　　　　　　　&amp;lt;menu menuList=&quot;{{menuList}}&quot;&amp;gt;&amp;lt;/menu&amp;gt;&lt;br/&gt;　　&lt;br/&gt;　　这就是微信小程序封装组件的大致流程。大同小异，只是给大家说一下他特殊的地方而已&lt;/pre&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、小程序的坑——小程序与其他web应用的不同之处&lt;/strong&gt;&lt;/span&gt;     ps： 这里只描述问题，并提供解决问题的方法，详细的了解请查官方文档&lt;/p&gt;
&lt;p&gt;　　1、问题： map 等原生组件的覆盖问题。 在小程序里面，原生组件默认展示层级最该，也就是video、map等组件会覆盖我们的标签，即便是定位调节 z-index 什么的都没用&lt;/p&gt;
&lt;p&gt;　　　  解决：用  cover-view   cover-image  包裹内容，就可以覆盖在原生组件之上了。注意 这2个标签内容不能嵌套view等标签，具体使用，请看官方文档。&lt;/p&gt;
&lt;p&gt;　　2、问题：wxss 无法使用本地资源，即 background-image 不能直接使用相对路径展示图片。&lt;/p&gt;
&lt;p&gt;　　　  解决：将图片转成base64展示，或者不使用背景图，直接使用图片。例： background-image: url(&quot;base64: .......&quot;)&lt;/p&gt;
&lt;p&gt;　　3、问题：大多数 js 插件无法使用&lt;/p&gt;
&lt;p&gt;　　　  原因：小程序用的是不完整的浏览器对象，大多数 BOM  DOM 对象的api无法使用，故：没办法的事情&lt;/p&gt;
&lt;p&gt;　　4、问题：使用npm包费劲&lt;/p&gt;
&lt;p&gt;　　　  解决：请看我上一篇博客，详解微信小程序开发&lt;/p&gt;
&lt;p&gt;　　5、问题：只支持到ES6，不支持ES7。像 async 等这些东西都用不了。&lt;/p&gt;
&lt;p&gt;　　　  解决：这个比较蛋疼了。（1）这里只提供解决的思路。引入 regenerator 这个包 ，或者其他包都行。（2）开发环境自己搭建gulp打包环境，自己把js代码转ES5，注意关闭小程序自带的转换。&lt;/p&gt;
&lt;p&gt;　　6、问题：获取用户信息改版了，wx.authorize 等api不好使&lt;/p&gt;
&lt;p&gt;　　　  解决：现在必须用button按钮  &amp;lt;button open-type=&quot;getUserInfo&quot; bindgetuserinfo=&quot;sweepCode&quot;&amp;gt;扫码&amp;lt;/button&amp;gt;&lt;/p&gt;
&lt;p&gt;　　7、问题：wx.request 请求，无法携带cookie，或者每次请求携带的都不一样&lt;/p&gt;
&lt;p&gt;　　　  解决：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;        header: {
              &lt;/span&gt;'content-type': 'application/json'&lt;span&gt;,
              &lt;/span&gt;'cookie': wx.getStorageSync(&quot;cookie&quot;&lt;span&gt;)
            },
            success: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (res) {
             
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (url === '/api/cdz/user/weixin/login'&lt;span&gt;) {
                  const cookie &lt;/span&gt;= res.header[&quot;set-cookie&quot;&lt;span&gt;];
                  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (cookie) wx.setStorageSync(&quot;cookie&quot;&lt;span&gt;, cookie);
                }
                resolve(res.data);
            },
            fail: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (res) {
              &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; fail调用接口失败&lt;/span&gt;
              &lt;span&gt;if&lt;/span&gt; (url === '/api/cdz/user/weixin/login'&lt;span&gt;) {
                const cookie &lt;/span&gt;= res.header[&quot;set-cookie&quot;&lt;span&gt;];
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (cookie) wx.setStorageSync(&quot;cookie&quot;&lt;span&gt;, cookie);
              }
              reject({ error: &lt;/span&gt;'网络错误', code: 0&lt;span&gt; });
            }    &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;　　8、问题：map 组件的使用，map是腾讯地图，和 百度、高德什么的，这些地图坐标系不同，经纬度的相互使用需要转化&lt;/p&gt;
&lt;p&gt;　　　  解决：用这个包  coordtransform 包很小，用法很简单&lt;/p&gt;
&lt;p&gt;　　9、问题：小程序伪类 ：active  不支持&lt;/p&gt;
&lt;p&gt;　　　  解决：&lt;em id=&quot;__mceDel&quot;&gt;view、button、navigator 这3个支持 hover-class 属性，用法和 active 一样&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　10、问题：上述问题，平时好用，但是如果按钮在原生组件上面的话，又不好使了&lt;/p&gt;
&lt;p&gt;　　　  解决：cover-view 无法嵌套普通标签。他又不支持 hover-class，所以只能js+wxss，自己写按钮激活事件了&lt;/p&gt;
&lt;p&gt;　　11、问题：小程序的事件点击不允许传参数。GoMy无法像vue react之类的一样写箭头函数直接传参&lt;/p&gt;
&lt;pre&gt;
　　　　　　&amp;lt;cover-view class=&quot;myCover&quot; data-id=&quot;my&quot; bindtap=&quot;goMy&quot;&amp;gt;&amp;lt;/cover-view&amp;gt;
&lt;/pre&gt;
&lt;p&gt;　　　    解决：通过data-id这个属性绑定关键参数，触发函数再去取出来&lt;/p&gt;

&lt;p&gt;　　以上就是我遇到的一些问题，后序再有，会再补充&lt;/p&gt;

</description>
<pubDate>Thu, 18 Apr 2019 07:06:00 +0000</pubDate>
<dc:creator>Mr.聂</dc:creator>
<og:description>一、序 上一篇介绍了如何从零开发微信小程序，博客园审核变智障了，每次代码都不算篇幅，好好滴一篇原创，不到3分钟从首页移出来了。这篇介绍一下组件封装和我的踩坑历程。 二、封装微信小程序可复用组件 首先模</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pengfei-nie/p/10729694.html</dc:identifier>
</item>
<item>
<title>基于STM8的IIC协议---STM8第五章 - 浩宇99✌</title>
<link>http://www.cnblogs.com/zhenghaoyu/p/10719233.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhenghaoyu/p/10719233.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;1. 综述&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　I&lt;sup&gt;2&lt;/sup&gt;C(IIC，Inter-Integrated Circuit)，两线式串行总线，由PHILIPS公司开发用于连接微控制器及其外围设备。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　它是由数据线SDA和时钟SCL构成的串行总线，可发送和接收数据。在CPU和被控IC之间、IC与IC之间进行双向传送，高速IIC总线一般可达400kbps以上。但在STM8中，400kHZ已经是最快速度了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2.关于STM8S103手册的TIM简介&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1545743/201904/1545743-20190416105724448-174423883.png&quot; alt=&quot;&quot; width=&quot;407&quot; height=&quot;334&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1545743/201904/1545743-20190417121719453-1089527366.png&quot; alt=&quot;&quot; width=&quot;536&quot; height=&quot;344&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;芯片手册中只对I&lt;sup&gt;2&lt;/sup&gt;C的特点进行了简单的讲解，但并未深入解析其中的过程。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3. I&lt;sup&gt;2&lt;/sup&gt;C详细解析&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　I&lt;sup&gt;2&lt;/sup&gt;C总共由五个核心函数，分别为：①起始信号②停止信号③应答信号④发送数据⑤接收数据，通过这五个核心基本函数就能于大多数的传感进行通信了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3.1 起始信号&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　当SCL为高电平期间，SDA由高电平到低电平的跳变过程；起始信号是一种电平跳变时序信号，而不是一个电平信号，如图虚线框所示。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3.2 停止信号&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　当SCL为高电平期间，SDA由低电平到高电平的跳变过程；停止信号也是一种电平跳变时序信号，而不是一个电平信号，如图虚线框所示。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1545743/201904/1545743-20190416125220461-523840479.png&quot; alt=&quot;&quot; width=&quot;967&quot; height=&quot;274&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; 3.3 应答信号&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　I&lt;sup&gt;2&lt;/sup&gt;C的数据字节定义为8位长，对于发送端每发送1个字节后，需要将数据线(SDA)释放，由接收端反馈一个应答信号(ACK)。应答信号为低电平时，则将其规定为有效信号(ACK简称应答位)，表示接收端已经成功接收了该字节；应答位为高电平时，规定为非应答位(NACK)，一般表示接收端没有成功接收该字节。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　对于反馈有效应答位ACK的要求是，接收端在第9个时钟脉冲之前的低电平期间将SDA线拉低，并且确保在该时钟的高电平期间为稳定的低电平。如果接收端是主机，则在它接收到最后一个字节后，发送一个NACK信号，以通知发送端结束数据发送，并释放SDA线，以便主机接收端发送一个停止信号。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1545743/201904/1545743-20190416170300796-296343248.png&quot; alt=&quot;&quot; width=&quot;965&quot; height=&quot;453&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3.4 发送数据&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在发送起始信号后开始通信，主机发送一个8位数据。然后，主机释放SDA线并等待从从机发出得确认信号(ACK)。详细过程请看4.3.7代码示例。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3.5 接收数据&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在发送起始信号后开始通信，主机发送一个8位数据。然后，从机收到数据返回一个确认信号(ACK)给主机,这时候主机才开始接收数据，待主机接收数据完成后，发送一个NACK信号给从机，以通知接收端结束数据接收。详细过程请看4.3.8代码示例。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3.6 数据有效性&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　I&lt;sup&gt;2&lt;/sup&gt;C总线进行数据传送时，时钟信号为高电平期间，数据线上的数据必须保持稳定，只有在时钟线上的信号为低电平期间，数据线上的高电平或低电平状态才允许变化。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3.7 I&lt;sup&gt;2&lt;/sup&gt;C通信总过程&lt;/span&gt;&lt;/strong&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1545743/201904/1545743-20190418144854935-1000199026.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;4. 例程&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-mce-=&quot;&quot;&gt;4.1 编译环境：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　我的编译环境是IAR，这款软件是现在STM8的主流平台，比较推荐。不过我打算等到STCubeMX更新出比较方便的版本后再去使用Keil5，因为我在用STM32的时候就是利用Keil5，的确很方便，你们也可以学着用一下。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-mce-=&quot;&quot;&gt;4.2 主芯片：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　我的主芯片是STM8S系列中的103，其中STM8S的003、005、和103、105，配置一样（外设和CPU频率，FLASH），在代码相同的情况下均可进行烧写。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;4.3 代码&amp;amp;解析&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;I&lt;sup&gt;2&lt;/sup&gt;C的基本函数代码我已经和传感的代码区隔开来，可以移植，几乎适用于市面上使用I2C驱动的传感器。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.3.1 GPIO设置&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　为了方便我们对SDA、SCL引角的GPIO进行一个调用，我将它们的GPIO写成结构体变量，调用结构体的参数便可完成操作，再对它们的电平进行宏定义。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　结构体参数解析：可见分为了SCL和SDA两个大类，我们用一个例子来解释可以更好的理解参数的意思，如单片机上的一个引角PB3，则Port即为B，Pin即为3。而uSDA_Mode_Pin_Position的话，我在下面再详细解释。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　宏定义解析：_HANDLE_即为所要创建的结构体变量，而后面对GPIO的寄存器操作暂不解释，详情可以察看相对应芯片的寄存器手册。STM8S103中的则在6.2小节中就有介绍。这里其实也可以使用库函数的GPIO读写函数去对SDA、SCL的引角进行一个控制，不过效率不太高，而直接操作寄存器的话可以减少一些不必要的麻烦，效率也就更高。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Struct --------------------------------------------------------------------&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; typedef &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; iic
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;具体信息：引脚 &lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;   GPIO_TypeDef * pSCL_Port;       　　　　　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt;SCL Gpio&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;   uint8_t        uSCL_Pin;        　　　　　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt;SCL Pin&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;   GPIO_TypeDef * pSDA_Port;       　　　　   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;SDA Gpio&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;   uint8_t        uSDA_Pin;        　　   　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt;SDA Pin&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;   
&lt;span&gt;11&lt;/span&gt;   uint8_t        uSDA_Mode_Pin_Position;　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt;SDA Mode&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;}IIC_HandleTypedef;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Define --------------------------------------------------------------------&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; IIC_SCL_1(_HANDLE_)  ( (_HANDLE_)-&amp;gt;pSCL_Port-&amp;gt;ODR |= ( (uint8_t)(_HANDLE_)-&amp;gt;uSCL_Pin))
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; IIC_SCL_0(_HANDLE_)  ( (_HANDLE_)-&amp;gt;pSCL_Port-&amp;gt;ODR &amp;amp;= (~(uint8_t)(_HANDLE_)-&amp;gt;uSCL_Pin))
&lt;span&gt;21&lt;/span&gt;                                   
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; IIC_SDA_1(_HANDLE_)  ( (_HANDLE_)-&amp;gt;pSDA_Port-&amp;gt;ODR |= ( (uint8_t)(_HANDLE_)-&amp;gt;uSDA_Pin))
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; IIC_SDA_0(_HANDLE_)  ( (_HANDLE_)-&amp;gt;pSDA_Port-&amp;gt;ODR &amp;amp;= (~(uint8_t)(_HANDLE_)-&amp;gt;uSDA_Pin))
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; IIC_SDA_R(_HANDLE_)  ( (BitStatus)(_HANDLE_)-&amp;gt;pSDA_Port-&amp;gt;IDR &amp;amp;  (_HANDLE_)-&amp;gt;uSDA_Pin)
&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; IIC_GPIO_MODE_Opt(_HANDLE_)  (_HANDLE_)-&amp;gt;pSDA_Port-&amp;gt;ODR |=    (uint8_t)1&amp;lt;&amp;lt;(_HANDLE_)-&amp;gt;uSDA_Mode_Pin_Position
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; IIC_GPIO_MODE_Ipt(_HANDLE_)  (_HANDLE_)-&amp;gt;pSDA_Port-&amp;gt;ODR &amp;amp;=  ~((uint8_t)1&amp;lt;&amp;lt;(_HANDLE_)-&amp;gt;uSDA_Mode_Pin_Position)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; 4.3.2 延时函数&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　延时函数顾名思义，就单纯的延时，延时时间可以根据芯片的速率调整，具体时间通过示波器或者可以观察到脉冲的仪器进行测量即可。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这里定义了两个延时函数目的是在SCL低电平期间先提前改变SDA的电平，待到SDA电平稳定时，再将SCL电平改变进行读取。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;******************************************************************************
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;* Function Name  : vIIC_Delay_4us
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;* Description    : 示波器实测4.02us
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;* Input          : None
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;* Output         : None
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;* Return         : None
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;****************************************************************************** &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; vIIC_Delay_4us(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)    
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;   uint8_t i=&lt;span&gt;3&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;   &lt;span&gt;while&lt;/span&gt;(i--&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;  {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     asm(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; NOP&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);asm(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; NOP&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);asm(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; NOP&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);asm(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; NOP&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;******************************************************************************
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;* Function Name  : vIIC_Delay_2us
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;* Description    : 示波器实测2.08us
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;* Input          : None
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;* Output         : None
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;* Return         : None
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;****************************************************************************** &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; vIIC_Delay_2us(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)    
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;   asm(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; NOP&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);asm(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; NOP&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);asm(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; NOP&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;4.3.3 I&lt;sup&gt;2&lt;/sup&gt;C结构体初始化&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　在这个函数里，我将结构体变量传进来，对该结构体的参数进行一个赋值。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;******************************************************************************
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;* Function Name  : vIIC_Handle_Init
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;* Description    : Initialization handle
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;* Input          : *hIICx,*pSCL_Port,uSCL_Pin,*pSDA_Port,uSDA_Pin&lt;br/&gt;&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;* Output         : None
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;* Return         : None
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;****************************************************************************** &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; vIIC_Handle_Init(IIC_HandleTypedef * hIICx,GPIO_TypeDef * pSCL_Port,uint8_t uSCL_Pin,GPIO_TypeDef *&lt;span&gt; pSDA_Port,uint8_t uSDA_Pin)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;引脚 Pin：&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;   hIICx-&amp;gt;pSCL_Port =&lt;span&gt; pSCL_Port;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;   hIICx-&amp;gt;uSCL_Pin  =&lt;span&gt; uSCL_Pin ;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;   hIICx-&amp;gt;pSDA_Port =&lt;span&gt; pSDA_Port;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;   hIICx-&amp;gt;uSDA_Pin  =&lt;span&gt; uSDA_Pin ;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     
&lt;span&gt;16&lt;/span&gt;     
&lt;span&gt;17&lt;/span&gt;   &lt;span&gt;switch&lt;/span&gt;&lt;span&gt;(uSDA_Pin)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;  {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;case&lt;/span&gt; GPIO_PIN_0 : hIICx-&amp;gt;uSDA_Mode_Pin_Position = &lt;span&gt;0&lt;/span&gt; ;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;case&lt;/span&gt; GPIO_PIN_1 : hIICx-&amp;gt;uSDA_Mode_Pin_Position = &lt;span&gt;2&lt;/span&gt; ;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;case&lt;/span&gt; GPIO_PIN_2 : hIICx-&amp;gt;uSDA_Mode_Pin_Position = &lt;span&gt;4&lt;/span&gt; ;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;case&lt;/span&gt; GPIO_PIN_3 : hIICx-&amp;gt;uSDA_Mode_Pin_Position = &lt;span&gt;6&lt;/span&gt; ;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;case&lt;/span&gt; GPIO_PIN_4 : hIICx-&amp;gt;uSDA_Mode_Pin_Position = &lt;span&gt;8&lt;/span&gt; ;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;case&lt;/span&gt; GPIO_PIN_5 : hIICx-&amp;gt;uSDA_Mode_Pin_Position = &lt;span&gt;10&lt;/span&gt;;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;case&lt;/span&gt; GPIO_PIN_6 : hIICx-&amp;gt;uSDA_Mode_Pin_Position = &lt;span&gt;12&lt;/span&gt;;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;case&lt;/span&gt; GPIO_PIN_7 : hIICx-&amp;gt;uSDA_Mode_Pin_Position = &lt;span&gt;14&lt;/span&gt;;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         
&lt;span&gt;28&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　该函数的调用方式为：先在主函数里定义一个结构体对象如 IIC_HandleTypedef  hIIC_Test；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　则直接调用即可，如 vIIC_Handle_Init(&amp;amp;hIIC_Test, pSCL_Port, uSCL_Pin, pSDA_Port, uSDA_Pin);  &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　而下半部分的switch选择则是通过判断SDA的Pin是哪一位，而通过通过操作的ODR，是按位操作的，具体如图，如想了解更多请到官方察看手册,。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1545743/201904/1545743-20190417180403185-421285678.png&quot; alt=&quot;&quot; width=&quot;728&quot; height=&quot;283&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　（这里就不帮你们翻译了，看不懂就去翻译或者直接找官方手册翻了）&lt;/p&gt;
&lt;p&gt;　　官方手册网址：&lt;a title=&quot;官方手册&quot; href=&quot;https://www.st.com/content/ccc/resource/technical/document/reference_manual/9a/1b/85/07/ca/eb/4f/dd/CD00190271.pdf/files/CD00190271.pdf/jcr:content/translations/en.CD00190271.pdf&quot; target=&quot;_blank&quot;&gt;https://www.st.com/content/ccc/resource/technical/document/reference_manual/9a/1b/85/07/ca/eb/4f/dd/CD00190271.pdf/files&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;4.3.4 起始信号&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这里与3.1讲解的操作有点不同，就是3.1中最后没有将SCL拉低包括在内，而为了发送数据的方便，我也将SCL在此函数中拉低了。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;******************************************************************************
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;* Function Name  : vIIC_Start_Signal
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;* Description    : Master Send Start Signal
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;* Input          : None
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;* Output         : None
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;* Return         : None
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;****************************************************************************** &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; vIIC_Start_Signal(IIC_HandleTypedef *&lt;span&gt; hIICx)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     
&lt;span&gt;11&lt;/span&gt;   IIC_SDA_1        (hIICx);                        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;拉高数据线    &lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;   IIC_SCL_1        (hIICx);                        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;拉高时钟线&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;   vIIC_Delay_4us   (     );                        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;延时&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;   IIC_SDA_0        (hIICx);                        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;拉低数据线&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;   vIIC_Delay_4us   (     );                        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;延时&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;   IIC_SCL_0        (hIICx);                        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;拉低时钟线&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;   vIIC_Delay_4us   (     );                        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;延时&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;     
&lt;span&gt;19&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1545743/201904/1545743-20190418132233282-1152242463.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;4.3.5 结束信号&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/strong&gt;这里与3.2讲解的操作也有所不同，因为在数据接收完或者是发送完成后，SDA的电平不能确定，有可能是高也有可能是低电平，但在结束信号的时候，SDA需要是低电平时候拉低SCL才能作为结束信号的开始。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;******************************************************************************
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;* Function Name  : vIIC_Stop_Signal
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;* Description    : Master Send Stop Signal
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;* Input          : None
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;* Output         : None
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;* Return         : None
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;****************************************************************************** &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; vIIC_Stop_Signal(IIC_HandleTypedef *&lt;span&gt; hIICx)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;   IIC_SDA_0        (hIICx);                        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;拉低数据线&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;   vIIC_Delay_4us   (     );                        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;延时&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;   IIC_SCL_1        (hIICx);                        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;拉高时钟线&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;   vIIC_Delay_4us   (     );                        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;延时&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;   IIC_SDA_1        (hIICx);                        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;拉高数据线&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;   vIIC_Delay_4us   (     );                        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;延时&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;     
&lt;span&gt;18&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1545743/201904/1545743-20190418134226920-753964923.png&quot; alt=&quot;&quot; width=&quot;79&quot; height=&quot;330&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1545743/201904/1545743-20190418134122586-668743398.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.3.6 应答信号(ACK)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　由于因为发送端和操作的不同，这里需要将ACK分成三种，①Ack(主动拉低SDA形成应答信号)  ②NAck(主动不拉低SDA不形成应答信号)  ③ReadAck(等待应答信号)。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　①Ack(主动拉低SDA形成应答信号)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　该信号在你没有读取到最后一个数据时由主机发送，使从机继续发送数据。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;******************************************************************************
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;* Function Name  : vIIC_Ack
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;* Description    : Master Send Acknowledge Single
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;* Input          : None
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;* Output         : None
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;* Return         : None
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;****************************************************************************** &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; vIIC_Ack(IIC_HandleTypedef *&lt;span&gt; hIICx)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;   IIC_SDA_0        (hIICx);                        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;拉低数据位&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;   vIIC_Delay_2us   (     );                        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;延时    &lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;   IIC_SCL_1        (hIICx);                        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;拉高时钟位&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;   vIIC_Delay_4us   (     );                        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;延时&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;   IIC_SCL_0        (hIICx);                        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;拉低时钟位&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;   vIIC_Delay_2us   (     );                        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;延时&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;     
&lt;span&gt;18&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　②NAck(主动不拉低SDA不形成应答信号) &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　该信号在你读取完最后一个数据时由主机发送，使从机停止发送数据。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;******************************************************************************
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;* Function Name  : vProto_IIC_NAck
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;* Description    : Master Not Send Acknowledge Single 
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;* Input          : None
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;* Output         : None
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;* Return         : None
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;****************************************************************************** &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; vIIC_NAck(IIC_HandleTypedef *&lt;span&gt; hIICx)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;{    
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     
&lt;span&gt;11&lt;/span&gt;   IIC_SDA_1        (hIICx);                        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;SDA拉高 不应答对方&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;  vIIC_Delay_2us   (     );　　　　　　　　　　　　　　 &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt;延时 &lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;  IIC_SCL_1        (hIICx);　　　　　　　　　　　　　　 &lt;span data-mce-=&quot;&quot;&gt;&lt;span&gt;//&lt;/span&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;span&gt;拉高时钟位&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;  vIIC_Delay_4us   (     );　　　　　　　　　　　　　　 &lt;span data-mce-=&quot;&quot;&gt;&lt;span&gt;//&lt;/span&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;span&gt;延时&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;  IIC_SCL_0        (hIICx);　　　　　　　　　　　　    &lt;span&gt;//拉低时钟线
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;  vIIC_Delay_2us   (     );　　　　　　　　　　　　　　&lt;span&gt; //延时
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     
&lt;span&gt;18&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　③ReadAck(等待应答信号)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　该信号在主机发送完数据后等待从机应答时候使用。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;******************************************************************************
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;* Function Name  : bIIC_ReadACK
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;* Description    : Master Reserive Slave Acknowledge Single
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;* Input          : None
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;* Output         : None
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;* Return         : None
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;****************************************************************************** &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; bIIC_ReadACK(IIC_HandleTypedef * hIICx) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回为:=1有ACK,=0无ACK&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;{                
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;   IIC_GPIO_SDA_MODE_Ipt  (hIICx);                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将SDA的模式改成输入模式&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;   IIC_SDA_1        　　　 (hIICx);                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;拉高数据线&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;   vIIC_Delay_2us         (     );                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;延时&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;   IIC_SCL_1        　　　 (hIICx);                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;拉高时钟线&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;   vIIC_Delay_2us         (     );                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;延时&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;   
&lt;span&gt;16&lt;/span&gt;   &lt;span&gt;if&lt;/span&gt;(IIC_SDA_R(hIICx))                            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断是否成功接收应答，如‘有’返回0，‘没有’则返回1&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;  {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     IIC_SCL_0            (hIICx);                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;拉低时钟线&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;     vIIC_Delay_2us       (     );                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;延时&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;     IIC_GPIO_SDA_MODE_Opt(hIICx);                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;接收完应答后，将SDA的模式改回输出模式&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; FALSE;                                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;没有应答&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;   &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;  {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     IIC_SCL_0            (hIICx);                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;拉低时钟线&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;     vIIC_Delay_2us       (     );                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;延时&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;     IIC_GPIO_SDA_MODE_Opt(hIICx);                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;接收完应答后，将SDA的模式改回输出模式&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; TRUE;                                  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;产生应答&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt; &lt;span&gt;  }    
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;                   
&lt;span&gt;31&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1545743/201904/1545743-20190418143847125-2033392459.png&quot; alt=&quot;&quot; width=&quot;67&quot; height=&quot;281&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1545743/201904/1545743-20190418143959423-2036826060.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;4.3.7 发送数据&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　所要发送的数据为8位，学过串口协议的应该知道按位发送，我们这里将要发送的数据进行由高到低位的一个顺序发送，具体操作如下，不懂的朋友可以将一下代码画出来，以方便理解。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;******************************************************************************
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;* Function Name  : vIIC_SendByte
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;* Description    : Master Send a Byte to Slave
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;* Input          : Will Send Date
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;* Output         : None
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;* Return         : None
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;****************************************************************************** &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; vIIC_SendByte(IIC_HandleTypedef *&lt;span&gt; hIICx,uint8_t uSendByte)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;{    
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;  uint8_t i;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     
&lt;span&gt;13&lt;/span&gt;   &lt;span&gt;for&lt;/span&gt; (i=&lt;span&gt;0&lt;/span&gt;; i&amp;lt;&lt;span&gt;8&lt;/span&gt;; i++)                                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;循环8次&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;  {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(uSendByte &amp;amp; &lt;span&gt;0X80&lt;/span&gt;)                             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将发送的数据最高位与1相与，若发送的数据最高位为1，则将SDA拉高，否则拉低&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;       IIC_SDA_1      (hIICx);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;       IIC_SDA_0      (hIICx);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     uSendByte &amp;lt;&amp;lt;= &lt;span&gt;1&lt;/span&gt;;                                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;数据左移1位&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;     vIIC_Delay_2us    (     );                       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;延时&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;     IIC_SCL_1         (hIICx);                       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;时钟线拉高&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;     vIIC_Delay_4us    (     );                       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;延时&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;     IIC_SCL_0         (hIICx);                       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;时钟线拉低&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;     vIIC_Delay_2us    (     );                       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;延时&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;                 
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         
&lt;span&gt;28&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;4.3.8 数据接收&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;/strong&gt;具体操作都写在注释部分，在SCL高电平时候去读取SDA的电平。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;******************************************************************************
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;* Function Name  : uIIC_RecvByte
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;* Description    : Master Receive a Byte From Slave
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;* Input          : None
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;* Output         : None
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;* Return         : Date From Slave 
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;****************************************************************************** &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; uint8_t uIIC_RecvByte(IIC_HandleTypedef *&lt;span&gt; hIICx)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;   uint8_t i,uReceiveByte = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;                                   
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     
&lt;span&gt;12&lt;/span&gt;   IIC_GPIO_SDA_MODE_Ipt (hIICx);                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将SDA的模式设置为输入模式&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;   IIC_SDA_1             (hIICx);                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;拉高数据线&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;   &lt;span&gt;for&lt;/span&gt;(i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;&lt;span&gt;8&lt;/span&gt;;i++)                                   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;进行8次的循环&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;  {   
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     uReceiveByte &amp;lt;&amp;lt;= &lt;span&gt;1&lt;/span&gt;;                              &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将接收到的数据左移&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;         
&lt;span&gt;18&lt;/span&gt;     vIIC_Delay_2us      (     );                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;延时&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;     IIC_SCL_1           (hIICx);                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;拉高时钟线&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;     vIIC_Delay_2us      (     );                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;延时&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;         
&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(IIC_SDA_R        (hIICx))                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;读取SDA电平&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         uReceiveByte |=&lt;span&gt;0x01&lt;/span&gt;;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;若SDA电平为高则将数据的最低位或上1，即为加1；若SDA电平为低，不进行该操作，则数据最低位为0&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;          
&lt;span&gt;27&lt;/span&gt;     vIIC_Delay_2us      (     );                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;延时&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;     IIC_SCL_0           (hIICx);                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;拉低时钟线&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;     vIIC_Delay_2us      (     );                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;延时&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;   IIC_GPIO_SDA_MODE_Opt (hIICx);                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将SDA的模式设置为输出模式&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;     
&lt;span&gt;33&lt;/span&gt;   &lt;span&gt;return&lt;/span&gt;&lt;span&gt; uReceiveByte;
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;     
&lt;span&gt;35&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;5.结尾 &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　I&lt;sup&gt;2&lt;/sup&gt;C协议核心基本函数为以上，将所有的核心函数结合起来便可与传感器设备进行通信了，但本博客只是单纯讲解了I&lt;sup&gt;2&lt;/sup&gt;C协议，并未与传感器进行通信，若理解完I&lt;sup&gt;2&lt;/sup&gt;C协议后可前往下一章博客进行与传感器通信的实践。　　　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　对STM8的I&lt;sup&gt;2&lt;/sup&gt;C协议讲解到这里结束，感谢各位看官的点击。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　如果觉得有所收获请点下推荐，若认为该博客中存在错误的说明或者对博客中某方面有疑问请留言。&lt;/span&gt;&lt;/p&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;27.609022556391&quot;&gt;
&lt;pre&gt;
作 者：浩宇99✌
出 处：&lt;a id=&quot;Editor_Edit_hlEntryLink&quot; title=&quot;view: 基于STM8的IIC协议&quot; href=&quot;https://www.cnblogs.com/zhenghaoyu/p/10719233.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/zhenghaoyu/p/10719233.html&lt;/a&gt;&lt;br/&gt;版权声明：本文原创发表于 博客园，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则视为侵权。
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Thu, 18 Apr 2019 06:50:00 +0000</pubDate>
<dc:creator>浩宇99✌</dc:creator>
<og:description>I2C(IIC，Inter-Integrated Circuit)，两线式串行总线，由PHILIPS公司开发用于连接微控制器及其外围设备。它是由数据线SDA和时钟SCL构成的串行总线，可发送和接收数据</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhenghaoyu/p/10719233.html</dc:identifier>
</item>
<item>
<title>asp.net core系列 57 IS4 使用混合流(OIDC+OAuth2.0)添加API访问 - 花阴偷移</title>
<link>http://www.cnblogs.com/MrHSR/p/10728476.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/MrHSR/p/10728476.html</guid>
<description>&lt;h3&gt;一.概述&lt;/h3&gt;
&lt;p&gt;　　在上篇中，探讨了交互式用户身份验证，使用的是OIDC协议。 在之前篇中对API访问使用的是OAuth2.0协议。这篇把这两个部分放在一起，OpenID Connect和OAuth 2.0组合的优点在于：可以使用单个协议和令牌服务，进行单次交换来实现这两者。&lt;/p&gt;
&lt;p&gt;　　上篇中使用了OpenID Connect隐式流程。在隐式流程中，所有令牌都通过浏览器传输，这对于身份令牌来说是完全正确的。现在我们还想要一个访问令牌。&lt;/p&gt;
&lt;p&gt;　　访问令牌比身份令牌更敏感，如果不需要，我们不希望将它们暴露给“外部”世界。OpenID Connect包含一个名为“Hybrid”的流程，它为我们提供了两全其美的优势，身份令牌通过浏览器渠道传输，因此客户端访问API时先进行身份验证。如果验证成功，客户端会打开令牌服务的反向通道以检索访问令牌。&lt;/p&gt;
&lt;p&gt;　　从&lt;a href=&quot;https://github.com/IdentityServer/IdentityServer4.Samples/tree/master/Quickstarts/5_HybridFlowAuthenticationWithApiAccess&quot; target=&quot;_blank&quot;&gt;Github&lt;/a&gt;中下载开源项目。该示例是在上篇示例的基础之上，做的一点修改。涉及到三个项目：IdentityServer、Api、MvcClient。&lt;/p&gt;

&lt;h3&gt;二. IdentityServer 项目&lt;/h3&gt;
&lt;p&gt;　　1.1 定义客户端配置&lt;/p&gt;
&lt;p&gt;　　　　允许客户端使用混合流Hybrid，添加一个客户端密钥ClientSecrets ，这将用于检索反向通道上的访问令牌。最后添加客户端访问offline_access范围 -这允许请求刷新令牌来进行长时间的API访问：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　　　public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IEnumerable&amp;lt;Client&amp;gt;&lt;span&gt; GetClients()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; List&amp;lt;Client&amp;gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Client
                {
                    ClientId &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;client&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,

                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; no interactive user, use the clientid/secret for authentication&lt;/span&gt;
                    AllowedGrantTypes =&lt;span&gt; GrantTypes.ClientCredentials,

                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; secret for authentication&lt;/span&gt;
                    ClientSecrets =&lt;span&gt;
                    {
                        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Secret(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;secret&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.Sha256())
                    },

                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; scopes that client has access to&lt;/span&gt;
                    AllowedScopes = { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;api1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; }
                },
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; resource owner password grant client&lt;/span&gt;
                &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Client
                {
                    ClientId &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ro.client&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    AllowedGrantTypes &lt;/span&gt;=&lt;span&gt; GrantTypes.ResourceOwnerPassword,

                    ClientSecrets &lt;/span&gt;=&lt;span&gt;
                    {
                        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Secret(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;secret&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.Sha256())
                    },
                    AllowedScopes &lt;/span&gt;= { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;api1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; }
                },
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; OpenID Connect hybrid flow client (MVC)&lt;/span&gt;
                &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Client
                {
                    ClientId &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mvc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    ClientName &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MVC Client&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;混合流&lt;/span&gt;
                    AllowedGrantTypes =&lt;span&gt; GrantTypes.Hybrid,

                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加客户端密钥&lt;/span&gt;
                    ClientSecrets =&lt;span&gt;
                    {
                        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Secret(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;secret&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.Sha256())
                    },

                    RedirectUris           &lt;/span&gt;= { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:5002/signin-oidc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; },
                    PostLogoutRedirectUris &lt;/span&gt;= { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:5002/signout-callback-oidc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; },

                    AllowedScopes &lt;/span&gt;=&lt;span&gt;
                    {
                        IdentityServerConstants.StandardScopes.OpenId,
                        IdentityServerConstants.StandardScopes.Profile,
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;api访问范围&lt;/span&gt;
                        &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;api1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
                    },
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;刷新令牌来进行长时间的API访问&lt;/span&gt;
                    AllowOfflineAccess = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;
                }
            };
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;三. API项目&lt;/h3&gt;
&lt;p&gt;　　&lt;span lang=&quot;EN-US&quot;&gt;API项目没有变动，可以考参上面的开源地址。也可以查看&lt;span lang=&quot;EN-US&quot;&gt;54篇。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;四. MvcClient客户端&lt;/h3&gt;
&lt;p&gt;　　&lt;strong&gt;4.1 启动类配置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　&lt;/strong&gt;在启动类Startup. ConfigureServices方法中，配置ClientSecret匹配IdentityServer的Secret。 添加offline_access和api1范围。并设置ResponseType为code id_token，意味着“使用混合流”。 将website  声明保留在我们的mvc客户端标识中，需要使用ClaimActions显示映射声明。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
       &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureServices(IServiceCollection services)
        {
            services.AddMvc();

            JwtSecurityTokenHandler.DefaultInboundClaimTypeMap.Clear();

            services.AddAuthentication(options &lt;/span&gt;=&amp;gt;&lt;span&gt;
                {
                    options.DefaultScheme &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Cookies&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                    options.DefaultChallengeScheme &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;oidc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                })
                .AddCookie(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Cookies&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                .AddOpenIdConnect(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;oidc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, options =&amp;gt;&lt;span&gt;
                {
                    options.SignInScheme &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Cookies&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;若不设置Authority，就必须指定MetadataAddress&lt;/span&gt;
                    options.Authority = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:5000&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                    options.RequireHttpsMetadata &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;客户端标识ID&lt;/span&gt;
                    options.ClientId = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mvc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;匹配IdentityServer的Secret&lt;/span&gt;
                    options.ClientSecret = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;secret&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

                    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
                      ResponseType:OAuth 2.0响应类型值，一次请求中可以同时获取Code和ID Token，使用的是混合流Hybrid Flow，
                      也可以使用OpenIdConnectResponseType枚举。
                      code:授权代码。当使用混合流时，总是返回这个值。
                      id_token:标识牌

                     下面是一个使用混合流响应示例：
                     HTTP / 1.1 302 Found
                     Location: &lt;/span&gt;&lt;span&gt;https://client.example.org/cb&lt;/span&gt;&lt;span&gt;#
                     code = SplxlOBeZQQYbYS6WxSbIA
                     &amp;amp; id_token = eyJ0...NiJ9.eyJ1c...I6IjIifX0.DeWt4Qu...ZXso
                     &amp;amp; state = af0ifjsldkj
                    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
                    options.ResponseType &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;code id_token&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否将Tokens保存到AuthenticationProperties中,最终到浏览器cookie中&lt;/span&gt;
                    options.SaveTokens = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;

                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否从UserInfoEndpoint获取Claims&lt;/span&gt;
                    options.GetClaimsFromUserInfoEndpoint = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;

                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加资源范围,访问api&lt;/span&gt;
                    options.Scope.Add(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;api1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;离线访问,此范围值请求发出OAuth 2.0刷新令牌，该令牌可用于获取访问令牌,
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;该令牌授予对最终用户的UserInfo端点的访问权，即使最终用户不存在(未登录)。&lt;/span&gt;
                    options.Scope.Add(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;offline_access&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;收集Claims&lt;/span&gt;
                    options.ClaimActions.MapJsonKey(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;website&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;website&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                });
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　Configure方法配置不变。　&lt;/p&gt;

&lt;p&gt;　　4.2 使用访问令牌&lt;/p&gt;
&lt;p&gt;　　　　在上面配置的OpenID Connect处理程序，会自动为我们保存令牌（在本案例中为identity身份，access 访问和refresh 刷新）。这就是SaveTokens设置的作用。令牌存储在cookie的properties部分中。访问它们的最简单方法是使用Microsoft.AspNetCore.Authentication命名空间中的扩展方法(GetTokenAsync)。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　//&lt;/span&gt;&lt;span&gt;例如：&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; accessToken = &lt;span&gt;await&lt;/span&gt; HttpContext.GetTokenAsync(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;access_token&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; refreshToken = &lt;span&gt;await&lt;/span&gt; HttpContext.GetTokenAsync(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;refresh_token&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;下面方法Home/CallAPI调用受保护的API，先获取访问令牌，再使用访问令牌调用API。&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;IActionResult&amp;gt;&lt;span&gt; CallApi()
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取访问令牌&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; accessToken = &lt;span&gt;await&lt;/span&gt; HttpContext.GetTokenAsync(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;access_token&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; client = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpClient();
            client.DefaultRequestHeaders.Authorization &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; AuthenticationHeaderValue(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Bearer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, accessToken);
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; content = &lt;span&gt;await&lt;/span&gt; client.GetStringAsync(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:5001/identity&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            ViewBag.Json &lt;/span&gt;=&lt;span&gt; JArray.Parse(content).ToString();
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; View(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt; 五. 测试&lt;/h3&gt;
&lt;p&gt;　　(1) 启动IdentityServer程序http://localhost:5000&lt;/p&gt;
&lt;p&gt;　　(2) 启动API程序http://localhost:5001。这二个程序属于服务端&lt;/p&gt;
&lt;p&gt;　　(3) 启动客户端MvcClient程序http://localhost:5002&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/151560/201904/151560-20190418115422644-1713800266.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　(4) 用户点击Secure，开始握手授权，重定向到IdentityServer站点的登录页&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;      [Authorize]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; IActionResult Secure()
        {
            ViewData[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Message&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Secure page.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; View();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/151560/201904/151560-20190418115455191-1356804124.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　(5) 输入用户的用户名和密码，登录成功。跳转到IdentityServer站点consent同意页面&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/151560/201904/151560-20190418115529141-637936956.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　上面的应用程序访问权限：MyAPI和Offline Access 是在客户端程序中配置的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
        options.Scope.Add(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;api1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        options.Scope.Add(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;offline_access&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　(6) 点击 yes allow后，跳回到客户端站点http://localhost:5002/Home/Secure，完成了交互式身份认证。&lt;/p&gt;
&lt;p&gt;　　(7) 调用http://localhost:5002/Home/CallAPI，获取访问令牌，请求受保护的api资源。调用CallAPI 时，是访问的api站点http://localhost:5001/identity。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/151560/201904/151560-20190418115654813-2038640180.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　参考文献&lt;/p&gt;
&lt;p&gt;　　　　&lt;a href=&quot;https://identityserver4.readthedocs.io/en/latest/quickstarts/5_hybrid_and_api_access.html&quot; target=&quot;_blank&quot;&gt;切换到混合流并添加API访问&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;https://openid.net/specs/openid-connect-core-1_0.html#HybridAuthRequest&quot; target=&quot;_blank&quot;&gt;OIDC使用混合流授权请求&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 18 Apr 2019 06:49:00 +0000</pubDate>
<dc:creator>花阴偷移</dc:creator>
<og:description>一.概述 在上篇中，探讨了交互式用户身份验证，使用的是OIDC协议。 在之前篇中对API访问使用的是OAuth2.0协议。这篇把这两个部分放在一起，OpenID Connect和OAuth 2.0组合</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/MrHSR/p/10728476.html</dc:identifier>
</item>
<item>
<title>python接口自动化（十八）--重定向（Location）（详解） - 北京-宏哥</title>
<link>http://www.cnblogs.com/du-hong/p/10728154.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/du-hong/p/10728154.html</guid>
<description>&lt;h2&gt;简介&lt;/h2&gt;
&lt;p&gt; 　　在实际工作中，有些接口请求完以后会重定向到别的url，而你却需要重定向前的url。URL主要是针对虚拟空间而言，因为不是自己独立管理的服务器，所以无法正常进行常规的操作。但是自己又不希望通过主域名的二级目录进行访问，而&lt;/p&gt;
&lt;p&gt;是希望通过主域名的二级域名进行访问。所以这个时候就会用到URL重定向。&lt;/p&gt;
&lt;p&gt;　　重定向过程好比有个绰号叫“浏览器”的人写信找张三借钱，张三回信说没有钱，让“浏览器”去找李四借，并将李四现在的通信地址告诉给了“浏览器 ”。于是，“浏览器”又按张三提供通信地址给李四写信借钱，李四收到信后就把钱汇给了“浏览&lt;/p&gt;
&lt;p&gt;器”。可见，“浏览器”一共发出了两封信和收到了两次回复，“ 浏览器”也知道他借到的钱出自李四之手。具体可以通过 HttpServletResponse.sendRedirect  实现。  &lt;/p&gt;
&lt;p&gt;　　RequestDispatcher.forward 方法在服务器端内部将请求转发给另外一个资源，浏览器只知道发出了请求并得到了响应结果，并不知道在服务器程序内部发生了转发行为。这个过程好比绰号叫“ 浏览器”的人写信找张三借钱，张三没有钱，于&lt;/p&gt;
&lt;p&gt;是张三找李四借了一些钱，甚至还可以加上自己的一些钱，然后再将这些钱汇给了“浏览器”。可见，“浏览器”只 发出了一封信和收到了一次回复，他只知道从张三那里借到了钱，并不知道有一部分钱出自李四之手。&lt;/p&gt;
&lt;p&gt;1、请求转发（requestDispatcher）&lt;/p&gt;
&lt;p&gt;该动作是服务器行为，在web容器中进行的，客户端对于跳转是不知道的，地址栏中显示的URL是不会变化的，因为请求转发中是一次请求，相同的request，可以在请求中设置属性对象（setAttribute()）来实现数据共享&lt;/p&gt;
&lt;p&gt;request.getRequestDispatcher(URL).forward(request,response);&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201904/1232840-20190418140151504-1990029865.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;2、请求重定向（sendRedirect，也称为间接的请求转发）&lt;/p&gt;
&lt;p&gt;该动作是客户端行为，服务器会向客户端返回一个301状态码并携带一个Location属性表名应请求的地址，然后客户端按照服务器返回的地址重新发送请求，地址栏中显示的URL是会变化的因为请求重定向中是两次不同的请求request，无法实&lt;/p&gt;
&lt;p&gt;现数据共享&lt;/p&gt;
&lt;p&gt;response.sendRedirect(URL);&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201904/1232840-20190418140123454-1172592501.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;重定向&lt;/h2&gt;
&lt;p&gt;　　URL重定向主要是指主域名主域名www.xusseo.com下的二级目录，如www.xusseo.com/wap，但是由于wap是一个新的站点，所以正确的域名应该是应该是wap.xusseo.com。但是访问的文件夹却是www.xusseo.com/wap，这种访问则被&lt;/p&gt;
&lt;p&gt;称之为重定向。&lt;/p&gt;
&lt;p&gt;常见的重定向分为301重定向和302重定向。重定向是一种比较特别的优化方式，因为需要通过代码来实现，从而变相提高&lt;a href=&quot;http://www.xusseo.com/seormjc/1116.html&quot;&gt;权重值&lt;/a&gt;。所以在特殊情况下，如果使用重定向过于严重，则会被搜索引擎判定为不是正当的优化。&lt;/p&gt;
&lt;p&gt;1、301重定向代表永久性转移(Permanently Moved)&lt;/p&gt;
&lt;p&gt;301重定向被称之为永久性重定向，主要是针对一些永久性更改的网站，而且这种重定向一旦做好，将会对网站的优化大有好处。&lt;/p&gt;
&lt;p&gt;2、302重定向代表暂时性转移(Temporarily Moved )&lt;/p&gt;
&lt;p&gt;302重定向的使用并不多见，它通常被称之为暂时性的转移。302重定向的使用常见于meta重定向和JavaScript重定向。而这种重定向是典型的不正当行为，很容易被搜索引擎发现，并将其重定向的网址定义为不合法网站，做出惩罚。&lt;/p&gt;
&lt;p&gt;3、以博客园举个简单的场景案例，先登录博客园打开我的博客首页，进入任意一个页面都可以，在这里进我的随笔编辑界面，记住这个地址：https://i.cnblogs.com/EditPosts.aspx?opt=1&lt;/p&gt;
&lt;p&gt;4.退出博客园登录，把刚才我的随笔这个地址https://i.cnblogs.com/EditPosts.aspx?opt=1输入浏览器回车，抓包会看到这个请求状态码是 302，浏览器地址栏瞬间刷新跳到登录首页去了&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201904/1232840-20190418131928361-1987747083.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;禁止重定向（allow_redirects）&lt;/h2&gt;
&lt;p&gt;1、用 get 方法请求：https://i.cnblogs.com/EditPosts.aspx?opt=1&lt;/p&gt;
&lt;p&gt;2、打印状态码是 200，这是因为 requets 库自动处理了重定向请求了，这里留作疑问。聪明的你一定或许猜到了，不知道的后边带你去解密，笔者就喜欢抽丝剥茧的那种感觉，带你一层一层揭开它神秘的面纱&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201904/1232840-20190418134231385-1387243876.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3、自动处理重定向地址后，我们就获取不到重定向后的 url 了，就无法走下一步，这里我们可以设置一个参数禁止重定向：allow_redirects=False（allow_redirects=True 是启动重定向），然后就可以看到 status_code 是 302 了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201904/1232840-20190418134845768-1575320002.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;获取重定向后地址&lt;/h2&gt;
&lt;p&gt;1、在第一个请求后，服务器会下发一个新的请求链接，在 response 的 headers 里，如下抓包：Location&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201904/1232840-20190418135307836-1627929577.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2、代码实现获取Location 地址&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201904/1232840-20190418135615930-1381445911.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3、参考代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; # coding:utf-&lt;span&gt;8&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import requests
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;# 请求头
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; headers =&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;User-Agent&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Mozilla/5.0 (Windows NT 10.0; WOW64; Trident/7.0; rv:11.0) like Gecko&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; s =&lt;span&gt; requests.session()
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;# 打开我的随笔
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; r = s.&lt;span&gt;get&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://i.cnblogs.com/EditPosts.aspx?opt=1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; headers=&lt;span&gt;headers,
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; allow_redirects=&lt;span&gt;False,
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; verify=&lt;span&gt;False)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;# 打印状态码，自动处理重定向请求
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;print (r.status_code)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; new_url = r.headers[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Location&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; print (new_url)
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt; 小结&lt;/h2&gt;
&lt;p&gt;　　在工作和学习中，我们不仅需要知其然，还必须知其所以然。前边留的疑问或许你已经查资料知道其原因了。我这里还是用老办法，&lt;span&gt;看源码！看源码！看源码！&lt;span&gt;重要的事说三遍。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&quot;hget&quot;&gt;1、从get方法入手&lt;/h4&gt;
&lt;p&gt;我们知道使用requests的get方法传入url就可以访问此网站，但是这个过程是怎么做的呢，今天就带着这个疑问对其进行进一步探究。&lt;/p&gt;
&lt;p&gt;打开pycharm，在pycharm中通过ctrl（command）+🖱️左键我们可以定位到方法的位置。&lt;/p&gt;
&lt;p&gt;我们首先进入sessions.py文件，看到get方法如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201904/1232840-20190418141625564-1079600140.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以发现该方法就两句话&lt;/p&gt;
&lt;p&gt;先看第一句，&lt;code&gt;kwargs.setdefault('allow_redirects', True)&lt;/code&gt;,下面我们来说说kwargs在这里的用处&lt;/p&gt;
&lt;h4 id=&quot;hkwargs&quot;&gt;2、kwargs&lt;/h4&gt;
&lt;p&gt;kwargs是字典类型，setdefault的作用是给字典键名allow_redirects赋值，如果该键不存在，赋给其默认值，也就是第二参数True。&lt;/p&gt;
&lt;p&gt;好了到此为止，就解决大家的疑问了，有兴趣的小伙伴可以继续往下分析。&lt;/p&gt;
</description>
<pubDate>Thu, 18 Apr 2019 06:36:00 +0000</pubDate>
<dc:creator>北京-宏哥</dc:creator>
<og:description>简介 在实际工作中，有些接口请求完以后会重定向到别的url，而你却需要重定向前的url。URL主要是针对虚拟空间而言，因为不是自己独立管理的服务器，所以无法正常进行常规的操作。但是自己又不希望通过主域</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/du-hong/p/10728154.html</dc:identifier>
</item>
</channel>
</rss>