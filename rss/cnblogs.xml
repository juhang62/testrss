<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Redis集群搭建很easy - Code综艺圈</title>
<link>http://www.cnblogs.com/zoe-zyq/p/14370730.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zoe-zyq/p/14370730.html</guid>
<description>&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;哨兵模式虽然让读写分离更加高可用，但单台服务器由于本身的内存和CPU瓶颈，对于高并发和大数据业务的应用场景还是远远不能满足；对于这种情况，有点经验的小伙伴会毫不犹豫的想到集群，搞他好几个节点，负载均衡再加上故障转移，岂不美哉。是的，就是这个理，接下来玩玩。&lt;/p&gt;
&lt;h3 id=&quot;正文&quot;&gt;正文&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;集群&lt;/strong&gt;，相信这个词小伙伴应该听的耳朵起茧子了吧；多搞几台服务器，让请求/命令平均分发到各个服务器，避免单台服务器承载过大压力；对于Redis集群来说，为了实现自动故障转移，还需要在每个主节点上增加一个或多个从节点，当主节点发生故障时，从节点自动补上，实现高可用。&lt;/p&gt;
&lt;p&gt;总的来说，Redis集群有以下作用：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;多主节点的实现可以&lt;strong&gt;应对高并发场景&lt;/strong&gt;，并发量增大，节点可以随时扩展满足需求；&lt;/li&gt;
&lt;li&gt;多主节点的实现可以&lt;strong&gt;存储更多的数据&lt;/strong&gt;，因为数据均匀分布到各个节点；&lt;/li&gt;
&lt;li&gt;多主节点搭配多从节点的实现让&lt;strong&gt;高可用更加稳定&lt;/strong&gt;，即当有主节点发生故障时，对应下面的从节点会升级为主节点，正常提供功能；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;老规矩不变，一边实操一边总结，接下来搭建一个3主3从的集群，这是最简单的。 &lt;strong&gt;Redis集群中最少需要3个主节点&lt;/strong&gt;，再加上为了实现高可用，每个主节点至少得跟一个从节点，不然一个主节点挂了，找不到完整的数据，整个集群就不能用了；至于为什么会找不到完整的数据，下面会聊到。&lt;/p&gt;
&lt;p&gt;接下来要搭建的集群环境如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/02/02/bLkpPJSuiGxRrFa.png&quot; alt=&quot;image-20210202112246300&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;简要说明：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;6370为主节点，6381为6370的从节点；&lt;/li&gt;
&lt;li&gt;6380为主节点，6391为6380的从节点；&lt;/li&gt;
&lt;li&gt;6390为主节点，6371为6390的从节点；&lt;/li&gt;
&lt;li&gt;在集群环境中主节点之间是相互通讯的(这里没有哨兵)，每一个节点都是数据节点；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里集群方案使用redis-cli自动指定主从关系(小伙伴的主从关系可能会和我这不一样哦)，也可以手动指定；反正思路都一样；&lt;/p&gt;
&lt;p&gt;以下演示在同一台机器上，通过端口区分各个节点；在实际开发中，一般都是用不同的服务器。&lt;/p&gt;
&lt;h4 id=&quot;案例演示&quot;&gt;案例演示&lt;/h4&gt;
&lt;ol readability=&quot;49&quot;&gt;&lt;li readability=&quot;22&quot;&gt;
&lt;p&gt;&lt;strong&gt;准备六个节点的配置文件，开启集群相关配置&lt;/strong&gt;；&lt;/p&gt;
&lt;p&gt;拷贝最初默认的配置文件，然后进行更改，主要更改以下项：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;port 6370 # 指定Redis节点端口
pidfile /var/run/redis_6370.pid # 指定对应进程文件
dbfilename dump6370.rdb # 每个节点的rdb持久化文件
cluster-enabled yes # 开启集群，这个比较重要
cluster-config-file nodes-6370.conf #指定每个节点的集群配置文件，这个比较重要
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上配置文件内容在其他节点(6370,6371,6380,6381,6390,6391)都需要进行修改，只是将其中6370改为对应节点的端口即可，目的就是为了不同节点使用不同端口并区分用到的不同文件即可；比如需要修改6371节点的配置文件如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;port 6371 # 指定Redis节点端口
pidfile /var/run/redis_6371.pid # 指定对应进程文件
dbfilename dump6371.rdb # 每个节点的rdb持久化文件
cluster-enabled yes # 开启集群，这个比较重要
cluster-config-file nodes-6371.conf #指定每个节点的集群配置文件，这个比较重要
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中&lt;strong&gt;cluster-enabled&lt;/strong&gt;和&lt;strong&gt;cluster-config-file&lt;/strong&gt;是集群配置的重点。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;13&quot;&gt;
&lt;p&gt;&lt;strong&gt;启动六个节点，刚开始各个节点是相互独立的&lt;/strong&gt;；&lt;/p&gt;
&lt;p&gt;准备好配置文件之后，就可以使用redis-server指定配置文件启动节点啦，如果节点多，小伙伴可以编写脚本哦；&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;./redis-server ZoeCluster/redis6370.conf # 启动6370节点
./redis-server ZoeCluster/redis6371.conf # 启动6371节点
./redis-server ZoeCluster/redis6380.conf # 启动6380节点
./redis-server ZoeCluster/redis6381.conf # 启动6381节点
./redis-server ZoeCluster/redis6390.conf # 启动6390节点
./redis-server ZoeCluster/redis6391.conf # 启动6391节点
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/02/02/ecQjWOD61u5EpPx.png&quot; alt=&quot;image-20210202110403525&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样只是将各个节点启动起来，集群关系还没创建呢，如果不信，可以使用redis-cli连接任意一个节点查看集群信息，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/02/01/JSEsbX54pQfO8WM.png&quot; alt=&quot;image-20210201232539758&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图，cluster-size为0，集群的关键，槽也还没有分配；那接下来肯定是要将各节点的集群关系搞起来；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;21&quot;&gt;
&lt;p&gt;&lt;strong&gt;建立节点集群关系&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于我使用的Redis版本是5.0，直接可以使用&lt;strong&gt;redis-cli&lt;/strong&gt;就可以进行集群搭建，在此版本之前都推荐使用redis-trib.rb进行相关操作，这个是一个Ruby脚本，需要安装相关环境，小伙伴可以下来尝试；&lt;/p&gt;
&lt;p&gt;使用命令如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;./redis-cli --cluster create --cluster-replicas 1 127.0.0.1:6370 127.0.0.1:6380 127.0.0.1:6390 127.0.0.1:6371 127.0.0.1:6381 127.0.0.1:6391
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参数简介：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;-- cluster&lt;/strong&gt; : 指定是用于创建集群环境；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;-a&lt;/strong&gt;：密码，即如果有密码，可以通过-a传参，这里没有设置密码；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;--cluster-replicas&lt;/strong&gt;：这里设置为1, 用于配置主节点上的从节点数，1就代表一主一从，2就代表一主二从，依次类推；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;后面的是节点IP:节点端口&lt;/strong&gt;，一般前面的是主节点，后面的是从节点；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/02/01/K2CwAvbzxTRNsoO.png&quot; alt=&quot;image-20210201233838902&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果同意集群方案，然后就开始进行相关操作，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/02/01/NPRIn6cYtagy7dx.png&quot; alt=&quot;image-20210201234435208&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;同样，可以连接到任意一个节点，查看集群情况，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/02/01/pzJGgNucFy92YVE.png&quot; alt=&quot;image-20210201235503407&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注：关于主从节点之间的主从复制过程就不在这说了，和之前说过的主从复制一样；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;演示访问操作&lt;/strong&gt;；&lt;/p&gt;
&lt;p&gt;使用redis-cli连接任意节点写入数据，如果不指定集群连接的话，会写入数据失败，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/02/02/F4DbVA5RMUItruf.png&quot; alt=&quot;image-20210202000216157&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由于集群环境下，数据的存储位置是根据Key来计算而来的(这里牵涉到一致性哈希算法)，使得数据可以均匀分配到各节点上，所以在redis-cli连接的时候需要指定集群模式，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/02/02/4xrSlDFkoRbaQgZ.png&quot; alt=&quot;image-20210202000548069&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，指定集群模式之后就可以正常存取了；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;27&quot;&gt;
&lt;p&gt;&lt;strong&gt;故障演示&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;既然集群环境，肯定少不了要好好测测；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;模拟从节点挂掉&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;找个从节点停掉试试，这里停掉6371节点，根据创建集群信息知道，它的主节点是6390；&lt;/p&gt;
&lt;p&gt;主节点显示从节点断开连接，看看它的主节点反应：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/02/02/cFTkdZNgefBhiHK.png&quot; alt=&quot;image-20210202001617324&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其他集群节点只是将从节点标记为failing状态，即下线状态，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/02/02/QC9okWOTe2ZVFiK.png&quot; alt=&quot;image-20210202001759260&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对于存取数据也不受影响，这里就不截图了，小伙伴自行尝试吧；&lt;/p&gt;
&lt;p&gt;当故障的从节点6371重新连上时，主节点恢复主从关系，并进行主从复制操作；其他集群节点会清除原来标记的下线状态，将其改为上线；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;模拟主节点挂掉&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里就手动将6390这个节点停掉，会有怎样的反应呢？&lt;/p&gt;
&lt;p&gt;自身从节点会&lt;strong&gt;每隔一秒检测连接&lt;/strong&gt;，如果超时(默认是15秒)，&lt;strong&gt;会选举从节点做为集群的主节点来提供服务&lt;/strong&gt;，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/02/02/hf6gsvXmZtMdQWa.png&quot; alt=&quot;image-20210202003020600&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;数据存取最终还是不受影响；&lt;/p&gt;
&lt;p&gt;对于其他集群节点，将故障节点标记为failing，让新上任的主节点提供服务，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/02/02/mZRfw4iGB9ku5MT.png&quot; alt=&quot;image-20210202003343926&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;存取数据也是不受影响的；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;挂掉的主节点6390如果恢复，那它只能变为6371的从节点啦，并进行相关主从复制操作&lt;/strong&gt;；而集群的其他节点只是将其原有的Fail状态清除，表示可以正常连接；&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Redis集群就是这样简单，只要思路对，就是手工活；小伙伴可以编写脚本自动执行哦；&lt;/p&gt;
&lt;p&gt;接下来说说集群数据的存储；&lt;/p&gt;
&lt;h4 id=&quot;数据存储简单分析&quot;&gt;数据存储简单分析&lt;/h4&gt;
&lt;p&gt;在Redis集群环境中，数据的存储位置是根据对Key的Hash计算进行指定的； Redis集群为了在节点改变时保证数据分布均匀，引入了槽(slot)作为迁移的基本单位，槽解耦了数据和实际节点的关系，使得实际节点数的改变对系统影响较小；&lt;/p&gt;
&lt;p&gt;在整个集群中，&lt;strong&gt;槽(slot)总共有16384，会将其均匀分配到集群的主节点上&lt;/strong&gt;，其中每一份槽对应一个存储空间(这里的存储空间可以理解为一个容器，是可以存很多数据的)，以上集群环境的槽分配如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/02/02/jFxTAygze3UK6XW.png&quot; alt=&quot;image-20210202114321655&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;存储数据的过程，如下：&lt;/p&gt;
&lt;p&gt;连接6380主节点，执行如下操作：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/02/02/k4HG5tcgREOBxAX.png&quot; alt=&quot;image-20210202124556921&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;具体过程如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/02/02/NLPbHT4acERe2U9.png&quot; alt=&quot;image-20210202124458975&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;简要说明：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;客户端发起命令；&lt;/li&gt;
&lt;li&gt;服务器将Key进行CRC16计算，并与总槽位计算出Key需要存储的位置；&lt;/li&gt;
&lt;li&gt;这里模拟的Key为zoe，计算出的槽位为14588，不在6380这个节点上，集群节点会将其重定向到对应槽位的节点上；&lt;/li&gt;
&lt;li&gt;然后找到6371上的14588槽位进行数据存储；（注，这里的6371已经是主节点了，因为上面做过一次故障转移模拟）；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;那集群节点是如何知道其他节点的槽范围和其他信息呢？&lt;/p&gt;
&lt;p&gt;那是因为各节点之间有通讯，通讯端口是对应的redis端口+10000，比如节点6371的集群通讯端口为16371（如果多台机器，别忘了防火墙放开这个端口哦），可以通过&lt;strong&gt;cluster nodes&lt;/strong&gt;看到，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/02/02/vWrANd63up1sxTV.png&quot; alt=&quot;image-20210202131533747&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;并且将各节点的信息保存在自己对应的集群配置文件中，这个集群文件名是通过配置项&lt;strong&gt;cluster-config-file&lt;/strong&gt;指定的，在集群节点启动时会检查该文件是否存在，如果不存在，会自动创建，如果存在，就加载里面的相关配置信息；里面有哪些信息，随便找个节点的配置文件看一下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/02/02/hyZo8bRNrJ5xLcd.png&quot; alt=&quot;image-20210202132412531&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，各节点的配置文件中记录了其他节点的主从关系，分配的槽位，各节点的状态；这样的话，集群关系就算重新启动也还存在。&lt;/p&gt;
&lt;h4 id=&quot;集群伸缩节点增删演示&quot;&gt;集群伸缩(节点增删)演示&lt;/h4&gt;
&lt;p&gt;在实际应用场景中，会根据业务需要，对集群进行伸缩，即节点的增删；业务并发大了加节点进行扩展， 节点需要调整时可能需要进节点删除；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;加节点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里进行节点扩展，加一个6360主节点，6361作为6360的从节点；参照以上集群搭建时配置文件更改，然后将其都启动，如下：&lt;/p&gt;
&lt;p&gt;6360节点&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;port 6360 # 指定Redis节点端口
pidfile /var/run/redis_6360.pid # 指定对应进程文件
dbfilename dump6360.rdb # 每个节点的rdb持久化文件
cluster-enabled yes # 开启集群，这个比较重要
cluster-config-file nodes-6360.conf #指定每个节点的集群配置文件，这个比较重要
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;6361节点&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;port 6361 # 指定Redis节点端口
pidfile /var/run/redis_6361.pid # 指定对应进程文件
dbfilename dump6361.rdb # 每个节点的rdb持久化文件
cluster-enabled yes # 开启集群，这个比较重要
cluster-config-file nodes-6361.conf #指定每个节点的集群配置文件，这个比较重要
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;两个节点都启动，然后将6360加入到集群主节点中，执行以下命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;./redis-cli --cluster add-node 127.0.0.1:6360 127.0.0.1:6370
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注：其中127.0.0.1:6360是需要加入的新增节点，127.0.0.1:6370是现有集群中的任意一个节点；&lt;/p&gt;
&lt;p&gt;可以通过以下命令检测集群状态，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;./redis-cli --cluster check 127.0.0.1:6370  # 后面的地址是任意的集群节点
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到6360已经加入到集群环境中，但现在还没有从节点和槽分配，所以接下来先将6361作为6360的从节点加入，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;./redis-cli --cluster add-node --cluster-slave --cluster-master-id eaa814dc56beb0d5edb6a4fbb14f1384e78d4764 127.0.0.1:6361 127.0.0.1:6370 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参数说明：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;--cluster-slave : 意思就是加入的是从节点；&lt;/li&gt;
&lt;li&gt;--cluster-master-id：后面紧跟主节点的id，这里就是6360的节点id；通过cluster nodes可以查看到节点id；&lt;/li&gt;
&lt;li&gt;127.0.0.1:6361：需要加入的从节点；&lt;/li&gt;
&lt;li&gt;127.0.0.1:6370：现有集群的任意主节点；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;现在还差槽分配了，如果需要直接将16384个槽平均分配到所有节点话，直接执行以下命令即可：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;./redis-cli --cluster rebalance --cluster-threshold 1 --cluster-use-empty-masters 127.0.0.1:6370
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用命令./redis-cli --cluster check 127.0.0.1:6370查看分配结果，如下图，只截了部分：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/02/02/8hbQmnIlqyFsGMw.png&quot; alt=&quot;image-20210202150530208&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果不想均匀分配，根据自定义需要进行配置，可以执行以下命令，会提示一步一步配置；&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;./redis-cli --cluster reshard 127.0.0.1:6360 #后面是新加入的主节点 
# 也可以执行以下指令直接配置想要的数据
./redis-cli --cluster reshard --cluster-from all --cluster-to 需要分配槽的节点id --cluster-slots 1000 --cluster-yes 127.0.0.1:6370 # 1000 指分配的槽数
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里就不截图演示了，留给小伙伴自己动手操作吧；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;删除节点&lt;/strong&gt;&lt;/p&gt;
&lt;ol readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;先对节点进行分片工作，防止数据丢失，即将指定节点上的槽分配到其他节点；&lt;br/&gt;&lt;code&gt;./redis-cli --cluster reshard 要删除节点ip:port&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;移除节点，推荐先删除从节点，再删除主节点；&lt;/p&gt;
&lt;p&gt;&lt;code&gt;./redis-cli --cluster del-node 节点ip:port 节点id&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;集群配置项&quot;&gt;集群配置项&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;cluster-enabled(是否开启集群模式)&lt;/strong&gt;：设置为yes，将该节点开启为集群模式；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;cluster-config-file(设置每个集群节点对应的配置文件名称)&lt;/strong&gt;：文件是自动生成的，不用手动创建；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;cluster-node-timeout(设置超时时间，即集群节点不可用的最大时间，如果超过这个时间就认为该节点不可用)&lt;/strong&gt;：默认为15000(以毫秒为单位)；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;cluster-migration-barrier(配置一个主机最少可用的从机的个数)&lt;/strong&gt;：默认是1,表示一个主机的从机迁移之后，至少得有一个从机可用，否则不进行节点迁移；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;cluster-require-full-coverage(配置集群服务的可用性)&lt;/strong&gt;：默认yes开启，即集群没完全覆盖所有slot，集群就挂了；设置为no，就算槽没有全分配，也能提供服务，需要自己保证槽分配；&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;到这集群的搭建就完啦，本来想着写着很简单的，没想到又干了4000字；对于集群，使用有一些限制，比如Keys命令只能针对当前节点，需要针对多节点的情况进行处理；集群中各节点只支持db0数据库，其他数据库不支持等等；所以使用要注意哦，后续抽时间单独整理一篇注意事项吧，篇幅有点长，不继续聊啦； 下篇说说熟悉的缓存穿透、缓存击穿、缓存雪崩吧；&lt;/p&gt;
&lt;p&gt;一个被程序搞丑的帅小伙，关注&quot;Code综艺圈&quot;，跟我一起学~~~&lt;/p&gt;
</description>
<pubDate>Thu, 04 Feb 2021 00:50:00 +0000</pubDate>
<dc:creator>Code综艺圈</dc:creator>
<og:description>前言 哨兵模式虽然让读写分离更加高可用，但单台服务器由于本身的内存和CPU瓶颈，对于高并发和大数据业务的应用场景还是远远不能满足；对于这种情况，有点经验的小伙伴会毫不犹豫的想到集群，搞他好几个节点，负</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zoe-zyq/p/14370730.html</dc:identifier>
</item>
<item>
<title>云原生项目实践DevOps(GitOps)+K8S+BPF+SRE，从0到1使用Golang开发生产级麻将游戏服务器—第2篇 - 为少</title>
<link>http://www.cnblogs.com/hacker-linner/p/14370734.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hacker-linner/p/14370734.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/436453/202102/436453-20210204084801104-2107763893.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;搭建游戏服务器脚手架--快速上手开发&quot;&gt;搭建游戏服务器脚手架 &amp;amp; 快速上手开发&lt;/h2&gt;
&lt;h3 id=&quot;系列文章&quot;&gt;系列文章&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/Jyq_A1vehrnMwv6AdOtQ1w&quot; target=&quot;_blank&quot;&gt;云原生项目实践DevOps(GitOps)+K8S+BPF+SRE，从0到1使用Golang开发生产级麻将游戏服务器—第1篇&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;介绍&quot;&gt;介绍&lt;/h3&gt;
&lt;p&gt;这将是一个完整的，完全践行 &lt;code&gt;DevOps/GitOps&lt;/code&gt; 与 &lt;code&gt;Kubernetes&lt;/code&gt; 上云流程的 Golang 游戏服务器开发的系列教程。&lt;/p&gt;
&lt;p&gt;这个系列教程是对开源项目 &lt;code&gt;Nanoserver&lt;/code&gt; 的完整拆解，旨在帮助大家快速上手 Golang（游戏）服务器后端开发。通过实践去理解 Golang 开发的精髓 —— &lt;code&gt;Share memory by communication(通过通信共享内存)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;同时这个项目可能还会涉及到 &lt;code&gt;Linux&lt;/code&gt; 性能调优（BPF相关的工具）和系统保障（SRE）的相关的工作。&lt;/p&gt;
&lt;h3 id=&quot;脚手架项目&quot;&gt;脚手架项目&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;脚手架是基于 &lt;code&gt;nanoserver&lt;/code&gt; 抽出来的，旨在帮助大家快速理解这个 &lt;code&gt;Mahjong Server&lt;/code&gt; 是如何搭出来的。&lt;/li&gt;
&lt;li&gt;我们先&lt;code&gt;单体架构&lt;/code&gt;理解整体业务 -&amp;gt; 然后再 &lt;code&gt;分布式 Nano Server&lt;/code&gt; + &lt;code&gt;微服务&lt;/code&gt; 改造（Step-by-Step）。&lt;/li&gt;
&lt;li&gt;Demo：&lt;a href=&quot;https://github.com/Hacker-Linner/go-mahjong-server&quot; target=&quot;_blank&quot;&gt;go-mahjong-server&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;基础回顾&quot;&gt;基础回顾&lt;/h2&gt;
&lt;h3 id=&quot;go-modules&quot;&gt;Go Modules&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;我的本地环境：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sh&quot;&gt;go version
# go version go1.14.14 darwin/amd64
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;go mod help&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Go mod&lt;/code&gt; 提供对 &lt;code&gt;modules&lt;/code&gt; 操作的访问。&lt;/p&gt;
&lt;p&gt;请注意，所有 &lt;code&gt;go&lt;/code&gt; 命令都内置了对 &lt;code&gt;modules&lt;/code&gt; 的支持，&lt;br/&gt;不只是&lt;code&gt;'go mod'&lt;/code&gt;。例如，日常的依赖关系添加(adding)，删除(removing)，升级(upgrading)和降级(downgrading)应该使用 &lt;code&gt;'go get'&lt;/code&gt; 完成。&lt;br/&gt;有关 &lt;code&gt;module&lt;/code&gt; 功能的概述，请参见 &lt;code&gt;'go help modules'&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;用法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sh&quot;&gt;go mod &amp;lt;command&amp;gt; [arguments]
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;download&lt;/code&gt; 将模块下载到本地缓存&lt;/li&gt;
&lt;li&gt;&lt;code&gt;edit&lt;/code&gt; 通过工具或脚本编辑 go.mod&lt;/li&gt;
&lt;li&gt;&lt;code&gt;graph&lt;/code&gt; 打印模块依赖图&lt;/li&gt;
&lt;li&gt;&lt;code&gt;init&lt;/code&gt; 在当前目录中初始化新模块&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tidy&lt;/code&gt; 添加缺少的内容并删除未使用的模块&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vendor&lt;/code&gt; 制作第三方依赖包（vendored）的依赖副本&lt;/li&gt;
&lt;li&gt;&lt;code&gt;verify&lt;/code&gt; 验证依赖项具有预期的内容&lt;/li&gt;
&lt;li&gt;&lt;code&gt;why&lt;/code&gt; 解释为什么需要软件包（packages）或模块（modules）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;使用 &lt;code&gt;“go help mod &amp;lt;命令&amp;gt;”&lt;/code&gt; 可获取有关命令的更多信息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/436453/202102/436453-20210204084832353-1060376699.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;脚手架基本结构&quot;&gt;脚手架基本结构&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sh&quot;&gt;├── configs # 配置文件
│   ├── config.toml
├── db # 数据库（xorm）相关
│   ├── model
│   │   ├── struct.go # database schema
│   ├── const.go
│   ├── logger.go
│   ├── model.go
├── internal
│   ├── game # 游戏服务器（Nano server）
│   │   ├── crypto.go
│   │   ├── game.go
│   │   ├── manager.go
│   ├── web # web 服务器（提供 API）
│   │   ├── web.go
├── pkg # 项目基础包
│   ├── algoutil # 常用工具函数
│   │   ├── algoutil.go 
│   ├── crypto # md5 rsa sha1 x509 base64 相关工具
│   │   ├── crypto.go
│   ├── errutil # 游戏服务器中错误码和错误信息统一管理
│   │   ├── code.go
│   │   ├── errutil.go
│   ├── whitelist # 白名单验证工具函数
│   │   ├── white_list.go
├── protocol # 协议（放所有游戏）
│   ├── web.go
├── main.go # 入口
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;mahjong-server-基础启动流程&quot;&gt;Mahjong Server 基础启动流程&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Everything start with &lt;code&gt;main.go&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;加载配置文件&quot;&gt;加载配置文件&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;configs/config.toml&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;core&lt;/code&gt; 核心基础配置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;webserver&lt;/code&gt; web 服务器配置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;game-server&lt;/code&gt; 游戏服务器配置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;database&lt;/code&gt; 数据库配置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;whitelist&lt;/code&gt; 白名单配置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;update&lt;/code&gt; 客户端更新配置&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;启动-game-server&quot;&gt;启动 Game Server&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;game.Startup()&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;根据配置&lt;code&gt;config.toml&lt;/code&gt;，打印相关启动信息：
&lt;ul&gt;&lt;li&gt;当前游戏服务器版本&lt;/li&gt;
&lt;li&gt;是否强制更新&lt;/li&gt;
&lt;li&gt;当前心跳时间间隔&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;业务功能配置（如：&lt;code&gt;房卡设置&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;注册游戏业务逻辑（Nano Components）
&lt;ul&gt;&lt;li&gt;玩家申请加入俱乐部&lt;/li&gt;
&lt;li&gt;创建一张桌子&lt;/li&gt;
&lt;li&gt;根据桌号返回牌桌数据&lt;/li&gt;
&lt;li&gt;设置桌号对应的牌桌数据&lt;/li&gt;
&lt;li&gt;检查登录玩家关闭应用之前是否正在游戏&lt;/li&gt;
&lt;li&gt;网络断开后, 重新连接网络&lt;/li&gt;
&lt;li&gt;网络断开后, 如果ReConnect后发现当前正在房间中, 则重新进入, 桌号是之前的桌号&lt;/li&gt;
&lt;li&gt;应用退出后重新进入房间&lt;/li&gt;
&lt;li&gt;理牌结束&lt;/li&gt;
&lt;li&gt;定缺&lt;/li&gt;
&lt;li&gt;有玩家请求解散房间&lt;/li&gt;
&lt;li&gt;玩家语音消息&lt;/li&gt;
&lt;li&gt;处理踢出玩家和重置玩家消息(来自http)&lt;/li&gt;
&lt;li&gt;……&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;注册游戏数据包加密管道
&lt;ul&gt;&lt;li&gt;&lt;code&gt;pipeline&lt;/code&gt;(&lt;code&gt;Inbound&lt;/code&gt; &amp;amp; &lt;code&gt;Outbound&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;根据设置，启动游戏服务器（Nano server）
&lt;ul&gt;&lt;li&gt;&lt;code&gt;WithPipeline&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;WithHeartbeatInterval&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;WithLogger&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;WithSerializer&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;WithComponents&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;……&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;启动-web-server&quot;&gt;启动 Web Server&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;web.Startup()&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;数据库设置(&lt;code&gt;XORM&lt;/code&gt;)
&lt;ul&gt;&lt;li&gt;&lt;code&gt;DSN&lt;/code&gt; 数据库连接字符串&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ShowSQL&lt;/code&gt; 是否显示生产的 Sql 语句&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MaxIdleConn&lt;/code&gt; 最大空闲连接&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MaxOpenConn&lt;/code&gt; 最大打开连接 &amp;lt; MaxIdleConn&lt;/li&gt;
&lt;li&gt;&lt;code&gt;syncSchema&lt;/code&gt; xorm 同步 model 到数据库表结构&lt;/li&gt;
&lt;li&gt;&lt;code&gt;async write channel&lt;/code&gt; 数据异步插入管道，持久化数据&lt;/li&gt;
&lt;li&gt;&lt;code&gt;async update channel&lt;/code&gt; 数据异步更新管道，持久化数据&lt;/li&gt;
&lt;li&gt;定时 &lt;code&gt;ping&lt;/code&gt; 数据库, 保持连接池连接&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;启用白名单（风控相关功能）&lt;/li&gt;
&lt;li&gt;API 服务注册（业务相关接口）
&lt;ul&gt;&lt;li&gt;登录&lt;/li&gt;
&lt;li&gt;注册人数&lt;/li&gt;
&lt;li&gt;活跃人数&lt;/li&gt;
&lt;li&gt;同时在线人、桌数&lt;/li&gt;
&lt;li&gt;留存&lt;/li&gt;
&lt;li&gt;房卡消耗&lt;/li&gt;
&lt;li&gt;重置玩家未完成房间状态&lt;/li&gt;
&lt;li&gt;设置房卡消耗&lt;/li&gt;
&lt;li&gt;消息广播&lt;/li&gt;
&lt;li&gt;踢人&lt;/li&gt;
&lt;li&gt;在线信息&lt;/li&gt;
&lt;li&gt;玩家充值&lt;/li&gt;
&lt;li&gt;玩家信息查询&lt;/li&gt;
&lt;li&gt;……&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;是否启用 &lt;code&gt;http.ListenAndServeTLS&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Graceful Shutdown(优雅退出，程序关闭前可做一下清理工作)
&lt;ul&gt;&lt;li&gt;&lt;code&gt;syscall.SIGINT&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;syscall.SIGQUIT&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;syscall.SIGKILL&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;同时，在 &lt;code&gt;kubernetes&lt;/code&gt; 中运行微服务时。我们需要处理 &lt;code&gt;kubernetes&lt;/code&gt; 发出的终止信号。这样做的正确方法是：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;监听 &lt;code&gt;SIGINT&lt;/code&gt;, &lt;code&gt;SIGTERM&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;收到信号后，将服务置于不健康模式（&lt;code&gt;/health&lt;/code&gt; 路由应返回状态码 &lt;code&gt;4xx&lt;/code&gt;，&lt;code&gt;5xx&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;在关闭之前添加宽限期，以允许 &lt;code&gt;kubernetes&lt;/code&gt; 将您的应用程序从负载均衡器中移除&lt;/li&gt;
&lt;li&gt;关闭服务器和所有打开的连接&lt;/li&gt;
&lt;li&gt;Shutdown&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;脑图&quot;&gt;脑图&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/436453/202102/436453-20210204084852837-138364759.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;快速上手开发&quot;&gt;快速上手开发&lt;/h2&gt;
&lt;h3 id=&quot;docker-compose-本地一键启动-mysql&quot;&gt;Docker Compose 本地一键启动 MySql&lt;/h3&gt;
&lt;p&gt;上篇已有详细介绍，这里就不赘述了哈。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/Jyq_A1vehrnMwv6AdOtQ1w&quot; target=&quot;_blank&quot;&gt;云原生项目实践DevOps(GitOps)+K8S+BPF+SRE，从0到1使用Golang开发生产级麻将游戏服务器—第1篇&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sh&quot;&gt;docker-compose -f docker-compose.mysql.5.7.yaml up # -d
docker-compose -f docker-compose.mysql.5.7.yaml down
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;使用-air-进行本地开发&quot;&gt;使用 Air 进行本地开发&lt;/h3&gt;
&lt;p&gt;☁️ Live reload for Go apps&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sh&quot;&gt;go get -u github.com/cosmtrek/air
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;开发（项目根目录）：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sh&quot;&gt;air
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/436453/202102/436453-20210204084912879-970283832.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;使用-vscode-go-插件调试程序&quot;&gt;使用 VSCode-Go 插件调试程序&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/golang/vscode-go/blob/master/docs/debugging.md&quot; target=&quot;_blank&quot;&gt;VSCode-Go Debugging&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;安装 &lt;code&gt;Delve&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;打开 &lt;code&gt;命令面板&lt;/code&gt;(Windows/Linux: Ctrl+Shift+P; OSX: Shift+Command+P)，&lt;br/&gt;选择 &lt;code&gt;Go: Install/Update Tools,&lt;/code&gt; 然后选择 &lt;code&gt;dlv&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;开始调试&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;打开你想要调试的 &lt;code&gt;package main&lt;/code&gt; 源文件(&lt;code&gt;source file&lt;/code&gt;)或测试文件(&lt;code&gt;test file&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;使用以下任何一种方式进行调试：
&lt;ul&gt;&lt;li&gt;打开 &lt;code&gt;命令面板&lt;/code&gt;, 选择 &lt;code&gt;Debug: Start Debugging&lt;/code&gt;，然后选择 &lt;code&gt;Go&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;打开调试窗口(Windows/Linux: Ctrl+Shift+D; OSX: Shift+Command+D)，然后点击 &lt;code&gt;Run and Debugs&lt;/code&gt;，然后选择 &lt;code&gt;Go&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;从主菜单选择 &lt;strong&gt;Run &amp;gt; Start Debugging&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/436453/202102/436453-20210204084928093-1521923726.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;我是为少
微信：uuhells123
公众号：黑客下午茶
加我微信（互相学习交流），关注公众号（获取更多学习资料~）
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Thu, 04 Feb 2021 00:50:00 +0000</pubDate>
<dc:creator>为少</dc:creator>
<og:description>搭建游戏服务器脚手架 &amp;amp;amp; 快速上手开发 系列文章 云原生项目实践DevOps(GitOps)+K8S+BPF+SRE，从0到1使用Golang开发生产级麻将游戏服务器—第1篇 介绍 这</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/hacker-linner/p/14370734.html</dc:identifier>
</item>
<item>
<title>推荐一个阅读代码、文档的利器：屏幕贴图工具 - sewain</title>
<link>http://www.cnblogs.com/sewain/p/14370694.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sewain/p/14370694.html</guid>
<description>&lt;br/&gt;&lt;center&gt;&lt;span&gt;这是道哥的第018篇原创&lt;/span&gt;&lt;/center&gt;&lt;br/&gt;&lt;h2 id=&quot;一、你是怎么阅读-pdf-文件的？&quot;&gt;一、你是怎么阅读 PDF 文件的？&lt;/h2&gt;
&lt;p&gt;作为已经软件开发人员，&lt;span&gt;阅读代码或者 PDF文件&lt;/span&gt;是家常便饭的事情。假设有这样一个场景：你在看第 &lt;span&gt;100&lt;/span&gt; 页的内容时，想回过头去看一下第 &lt;span&gt;20&lt;/span&gt; 页的图片，你一般是如何操作？&lt;/p&gt;
&lt;p&gt;这篇文章为你推荐一个利器：&lt;span&gt;Snipaste&lt;/span&gt;，如果你已经在使用这个非常顺手的工具软件了，下面的内容就可以不用看了，听听音乐享受人生去。&lt;/p&gt;
&lt;h2 id=&quot;二、几种可能的方法&quot;&gt;二、几种可能的方法&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;方法1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;用鼠标滚轮&lt;span&gt;回滚&lt;/span&gt;到 20 页，把图片理解一遍之后，再&lt;span&gt;回到&lt;/span&gt; 100 页继续看。这个方法是比较笨拙的，非常&lt;span&gt;浪费时间&lt;/span&gt;。如果看了几行内容还想再看一下图片怎么办？再滚动鼠标往回滚？想想就比较恐怖。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;缺点：操作不便，浪费时间。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;方法2：&lt;/p&gt;
&lt;p&gt;使用快捷键 &lt;span&gt;Win + Shift + s&lt;/span&gt; 截取相关的图片，此时截图已经放在系统的&lt;span&gt;剪贴板&lt;/span&gt;中了，然后通过画图等工具把剪贴板中的图片保存为图片文件，这样就可以同时看到 PDF 文件中的多个相关内容了。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;缺点：截图后需要借助画图工具，把剪贴板中的图片导出之后才能看到，而且画图工具只能处理一张图片。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;方法3：&lt;/p&gt;
&lt;p&gt;使用专门的&lt;span&gt;屏幕截图小工具&lt;/span&gt;，把需要的图片截图之后，保存为一个图片文件放在桌面上，例如下面这个小工具：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1440498/202102/1440498-20210204083115963-941887822.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://iottown.sewain100.cn/it18_2.pn&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个方法本质上与方法 2 是一样的，只不过是把截图和保存图片放在一个小工具中来完成，&lt;span&gt;省去了中间的剪贴板环节&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;缺点：仍然需要打开图片来看。&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;三、屏幕贴图神器-snipaste&quot;&gt;三、屏幕贴图神器 Snipaste&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;Step1: 按下 F1 键，截取需要的图片内容&lt;/span&gt; :&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1440498/202102/1440498-20210204083116760-1077839943.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Step2: 按下 F3 键，把截图转为屏幕贴图，此时图片四周出现淡蓝色的阴影&lt;/span&gt;:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1440498/202102/1440498-20210204083117099-1049524208.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时，你可以用鼠标把这个贴图&lt;span&gt;拖动到屏幕的任意地方&lt;/span&gt;，也可以通过滚轮来&lt;span&gt;放大或缩小&lt;/span&gt;贴图，如果需要多个图片、代码混合着学习，可能就是类似这样的桌面：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/news/1440498/202102/1440498-20210204083117606-1040657684.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以把所有相关部分的信息全部在一个屏幕上展示，不用来回切换，通过鼠标的滚轮来缩放也非常方便。如果某个贴图不用了，直接选中后按下 Esc 键即可丢弃。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果你没有试过这个贴图神器，强烈建议尝试一下。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;下图是 Snipaste 的菜单说明，你可以自己设置一些选项，其实默认的就已经够用了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1440498/202102/1440498-20210204083117966-116357876.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;四、总结&quot;&gt;四、总结&lt;/h2&gt;
&lt;p&gt;这里只介绍了 Snipaste 中我最常用的贴图功能，对于我来说这已经足够了！&lt;/p&gt;
&lt;p&gt;如果你也有私藏的、好用的神器，不妨也给大家分享一下！&lt;/p&gt;
&lt;hr/&gt;&lt;span&gt;不吹嘘，不炒作，不浮夸，认真写好每一篇文章！&lt;/span&gt;&lt;br/&gt;欢迎&lt;span&gt;转发、分享&lt;/span&gt;给身边的技术朋友，道哥在此表示衷心的感谢！ 转发的&lt;span&gt;推荐语&lt;/span&gt;已经帮您想好了：
&lt;p&gt;&lt;span&gt;道哥总结的这篇总结文章，写得很用心，对我的技术提升很有帮助。好东西，要分享！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;最后，祝您：面对代码，永无bug；面对生活，春暖花开！&lt;/p&gt;
&lt;hr/&gt;&lt;center&gt;&lt;span&gt;【原创声明】&lt;/span&gt;&lt;/center&gt;
&lt;br/&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;作者：道哥(公众号: &lt;span&gt;IOT物联网小镇&lt;/span&gt;)&lt;br/&gt;知乎：道哥&lt;br/&gt;B站：道哥分享&lt;br/&gt;掘金：道哥分享&lt;br/&gt;CSDN：道哥分享&lt;/p&gt;
&lt;/blockquote&gt;
&lt;center readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;span&gt;关注+星标公众号&lt;/span&gt;，不错过最新文章&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1440498/202102/1440498-20210204083118234-919465560.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/center&gt;
&lt;br/&gt;&lt;span&gt;转载：欢迎转载，但未经作者同意，必须保留此段声明，必须在文章中给出原文连接。&lt;/span&gt;
&lt;hr/&gt;&lt;br/&gt;&lt;span&gt;推荐阅读&lt;/span&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/rmBtH0h6Bu6Dasm6QeD62w&quot; target=&quot;_blank&quot;&gt;利用C语言中的setjmp和longjmp，来实现异常捕获和协程&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/TwDiDmApmsIVSIFh2h1osQ&quot; target=&quot;_blank&quot;&gt;C语言指针-从底层原理到花式技巧，用图文和代码帮你讲解透彻&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/xOdwQQHIjEobe4jR_2gDRQ&quot; target=&quot;_blank&quot;&gt;一步步分析-如何用C实现面向对象编程&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/oY2pF5ilk8UCq09022Tt6w&quot; target=&quot;_blank&quot;&gt;原来gdb的底层调试原理这么简单&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/boOSJ-dCaLYcCa_yY_2sIw&quot; target=&quot;_blank&quot;&gt;关于加密、证书的那些事&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/qJiEaVfivAbK89gv1itUhA&quot; target=&quot;_blank&quot;&gt;深入LUA脚本语言，让你彻底明白调试原理&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 04 Feb 2021 00:32:00 +0000</pubDate>
<dc:creator>sewain</dc:creator>
<og:description>这是道哥的第018篇原创 一、你是怎么阅读 PDF 文件的？ 作为已经软件开发人员，阅读代码或者 PDF文件是家常便饭的事情。假设有这样一个场景：你在看第 100 页的内容时，想回过头去看一下第 20</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/sewain/p/14370694.html</dc:identifier>
</item>
<item>
<title>jackson学习之七：常用Field注解 - 程序员欣宸</title>
<link>http://www.cnblogs.com/bolingcavalry/p/14370691.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bolingcavalry/p/14370691.html</guid>
<description>&lt;h3 id=&quot;欢迎访问我的github&quot;&gt;欢迎访问我的GitHub&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot; target=&quot;_blank&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;内容：所有原创文章分类汇总及配套源码，涉及Java、Docker、Kubernetes、DevOPS等；&lt;/p&gt;
&lt;h3 id=&quot;系列文章汇总&quot;&gt;系列文章汇总&lt;/h3&gt;
&lt;h3 id=&quot;本篇概览&quot;&gt;本篇概览&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;本文是《jackson学习》系列的第七篇，继续学习jackson强大的注解能力，本篇学习的是&lt;span&gt;常用的Field注解&lt;/span&gt;，并通过实例来加深印象，下图是常用Field注解的简介：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202102/485422-20210204082944663-673299222.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;接下来逐个学习；&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;不止是filed&quot;&gt;不止是Filed&lt;/h3&gt;
&lt;h3 id=&quot;源码下载&quot;&gt;源码下载&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;如果您不想编码，可以在GitHub下载所有源码，地址和链接信息如下表所示(&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot; target=&quot;_blank&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;)：&lt;/li&gt;
&lt;/ol&gt;&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;这个git项目中有多个文件夹，本章的应用在&lt;span&gt;jacksondemo&lt;/span&gt;文件夹下，如下图红框所示：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202102/485422-20210204082944932-184986521.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;3. jacksondemo是父子结构的工程，本篇的代码在&lt;span&gt;annotation&lt;/span&gt;子工程中，里面的&lt;span&gt;fieldannonation&lt;/span&gt;这个package下，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202102/485422-20210204082948387-1397180433.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;jsonproperty&quot;&gt;JsonProperty&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;JsonProperty可以作用在&lt;span&gt;成员变量和方法&lt;/span&gt;上，作用是在序列化和反序列化操作中指定json字段的名称；&lt;/li&gt;
&lt;li&gt;先来看序列化操作（JsonPropertySerialization.java），如下所示，JsonProperty修饰了私有成员变量&lt;span&gt;field0&lt;/span&gt;和公共方法&lt;span&gt;getField1&lt;/span&gt;，并且field0没有get和set方法，是通过构造方法设置的，另外还要注意JsonProperty注解的index属性，用来指定序列化结果中的顺序，这里故意将field1的顺序设置得比field0靠前：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    static class Test {

        @JsonProperty(value=&quot;json_field0&quot;, index = 1)
        private String field0;

        @JsonProperty(value=&quot;json_field1&quot;, index = 0)
        public String getField1() {
            return &quot;111&quot;;
        }

        public Test(String field0) {
            this.field0 = field0;
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;执行结果如下图红框所示，可见JsonProperty的value就是序列化后的属性名，另外带有JsonProperty注解的成员变量，即使是私有而且没有get和set方法，&lt;span&gt;也能被成功序列化&lt;/span&gt;，而且顺序也和index属性对应：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202102/485422-20210204082950916-1319475961.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;接下来看反序列化操作（JsonPropertyDeserialization.java），注解相关代码如下，field0是私有且没有get和set方法，另外setField1方法也有JsonProperty注解：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    static class Test {

        @JsonProperty(value = &quot;json_field0&quot;)
        private String field0;

        private String field1;

        @JsonProperty(value = &quot;json_field1&quot;)
        public void setField1(String field1) {
            this.field1 = field1;
        }

        @Override
        public String toString() {
            return &quot;Test{&quot; +
                    &quot;field0='&quot; + field0 + '\'' +
                    &quot;, field1='&quot; + field1 + '\'' +
                    '}';
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;5&quot;&gt;&lt;li&gt;用json字符串尝试反序列化，结果如下，可见field0和field1都能被正确赋值：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202102/485422-20210204082952690-1486776032.png&quot; alt=&quot;6.&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;jsonignore&quot;&gt;JsonIgnore&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;JsonIgnore好理解，作用在成员变量或者方法上，&lt;span&gt;指定被注解的变量或者方法不参与序列化和反序列化操作&lt;/span&gt;；&lt;/li&gt;
&lt;li&gt;先看序列化操作（JsonIgnoreSerialization.java），如下所示，Test类的field1字段和getField2方法都有JsonIgnore注解：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    static class Test {

        private String field0;

        @JsonIgnore
        private String field1;

        private String field2;

        public String getField0() { return field0; }
        public void setField0(String field0) { this.field0 = field0; }
        public String getField1() { return field1; }
        public void setField1(String field1) { this.field1 = field1; }
        public void setField2(String field2) { this.field2 = field2; }

        @JsonIgnore
        public String getField2() { return field2; }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;给field0、field1、field2三个字段都赋值，再看序列化结果，如下图，可见field0和field2都被忽略了：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202102/485422-20210204082955365-39990386.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;再来尝试JsonIgnore注解在反序列化场景的作用，注意反序列化的时候，JsonIgnore作用的方法应该是set了，如下图：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202102/485422-20210204082957650-1802099415.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;5&quot;&gt;&lt;li&gt;另外实测发现，反序列化的时候，JsonIgnore注解在get方法上也可以让对应字段被忽略；&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;jacksoninject&quot;&gt;JacksonInject&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;JacksonInject的作用是在反序列化的时候，将配置好的值注入被JacksonInject注解的字段；&lt;/li&gt;
&lt;li&gt;如下所示，Test类的field1和field2都有JacksonInject注解，不同的是field1指定了注入值的key为defaultField1，而field2由于没有指定key，只能按照类型注入：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    static class Test {
        private String field0;
        @JacksonInject(value = &quot;defaultField1&quot;)
        private String field1;
        @JacksonInject
        private String field2;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;注入时所需的数据来自哪里呢？如下所示，&lt;span&gt;通过代码配置的&lt;/span&gt;，可以指定key对应的注入值，也可以指定类型对应的注入值：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;        InjectableValues.Std injectableValues = new InjectableValues.Std();
        // 指定key为&quot;defaultField1&quot;对应的注入参数
        injectableValues.addValue(&quot;defaultField1&quot;,&quot;field1 default value&quot;);
        // 指定String类型对应的注入参数
        injectableValues.addValue(String.class,&quot;String type default value&quot;);
        ObjectMapper mapper = new ObjectMapper();        // 把注入参数的配置设置给mapper
        mapper.setInjectableValues(injectableValues);
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;反序列化结果如下图，可见field1和field2的值都是被注入的：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202102/485422-20210204082959235-248201029.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;jsonserialize&quot;&gt;JsonSerialize&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;JsonSerialize用于序列化场景，被此注解修饰的字段或者get方法会被用于序列化，&lt;span&gt;并且using属性指定了执行序列化操作的类&lt;/span&gt;；&lt;/li&gt;
&lt;li&gt;执行序列化操作的类，需要继承自&lt;span&gt;JsonSerializer&lt;/span&gt;，如下所示，Date2LongSerialize的作用是将Date类型转成long类型：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    static class Date2LongSerialize extends JsonSerializer&amp;lt;Date&amp;gt; {

        @Override
        public void serialize(Date value, JsonGenerator gen, SerializerProvider serializers) throws IOException {
            gen.writeNumber(value.getTime());
        }
    }

&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;Test类的field0字段是私有的，且没有get和set方法，但是&lt;span&gt;添加了注释JsonDeserialize就能被反序列化了&lt;/span&gt;，并且使用Date2LongSerialize类对将json中的long型转成field0所需的Date型：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    static class Test {
        @JsonDeserialize(using = Long2DateDeserialize.class)
        private Date field0;
        @Override
        public String toString() { return &quot;Test{&quot; + &quot;field0='&quot; + field0 + '\'' + '}'; }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;执行结果如下：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202102/485422-20210204083000109-2022091091.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;jsondeserialize&quot;&gt;JsonDeserialize&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;JsonDeserialize用于反序列化场景，被此注解修饰的字段或者set方法会被用于反序列化，并且using属性指定了执行反序列化操作的类；&lt;/li&gt;
&lt;li&gt;执行反序列化操作的类需要&lt;span&gt;继承自JsonDeserializer&lt;/span&gt;，如下所示，Long2DateDeserialize的作用是将Long类型转成field0字段对应的Date类型：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    static class Long2DateDeserialize extends JsonDeserializer&amp;lt;Date&amp;gt; {

        @Override
        public Date deserialize(JsonParser p, DeserializationContext ctxt) throws IOException, JsonProcessingException {

            if(null!=p &amp;amp;&amp;amp; null!=ctxt &amp;amp;&amp;amp; p.getLongValue()&amp;gt;0L ) {
                return new Date(p.getLongValue());
            }

            return null;
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;测试反序列化，结果如下：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202102/485422-20210204083001234-634802920.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;jsonrawvalue&quot;&gt;JsonRawValue&lt;/h3&gt;
&lt;p&gt;最后要介绍的是JsonRawValue，使用该注解的字段或者方法，都会被序列化，但是序列化结果是原始值，例如&lt;span&gt;字符串是不带双引号的&lt;/span&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202102/485422-20210204083002169-2101360396.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;至此，常用的Filed注解就操作完毕了，希望能带给您一些参考，助您更精确控制自己的序列化和反序列化操作；&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;你不孤单，欣宸原创一路相伴&quot;&gt;你不孤单，欣宸原创一路相伴&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105068742&quot; target=&quot;_blank&quot;&gt;Java系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086498&quot; target=&quot;_blank&quot;&gt;Spring系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086732&quot; target=&quot;_blank&quot;&gt;Docker系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086794&quot; target=&quot;_blank&quot;&gt;kubernetes系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086850&quot; target=&quot;_blank&quot;&gt;数据库+中间件系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086920&quot; target=&quot;_blank&quot;&gt;DevOps系列&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;欢迎关注公众号：程序员欣宸&quot;&gt;欢迎关注公众号：程序员欣宸&lt;/h3&gt;
&lt;blockquote readability=&quot;4.258064516129&quot;&gt;
&lt;p&gt;微信搜索「程序员欣宸」，我是欣宸，期待与您一同畅游Java世界...&lt;br/&gt;&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot; target=&quot;_blank&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Thu, 04 Feb 2021 00:30:00 +0000</pubDate>
<dc:creator>程序员欣宸</dc:creator>
<og:description>欢迎访问我的GitHub https://github.com/zq2599/blog_demos 内容：所有原创文章分类汇总及配套源码，涉及Java、Docker、Kubernetes、DevOPS</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/bolingcavalry/p/14370691.html</dc:identifier>
</item>
<item>
<title>Java 容器系列总结 - 暮夏有五</title>
<link>http://www.cnblogs.com/antoniopeng/p/14370679.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/antoniopeng/p/14370679.html</guid>
<description>&lt;h3 id=&quot;为什么要使用集合&quot;&gt;为什么要使用集合&lt;/h3&gt;
&lt;hr/&gt;&lt;p&gt;当我们需要保存一组类型相同的数据的时候，我们应该是用一个容器来保存，这个容器就是数组，但是，使用数组存储对象具有一定的弊端， 因为我们在实际开发中，存储的数据的类型是多种多样的，于是，就出现了“集合”，集合同样也是用来存储多个数据的。&lt;/p&gt;
&lt;p&gt;数组的缺点是一旦声明之后，长度就不可变了；同时，声明数组时的数据类型也决定了该数组存储的数据的类型；而且，数组存储的数据是有序的、可重复的，特点单一。 但是集合提高了数据存储的灵活性，Java 集合不仅可以用来存储不同类型不同数量的对象，还可以保存具有映射关系的数据。&lt;/p&gt;
&lt;h3 id=&quot;java-容器概述&quot;&gt;Java 容器概述&lt;/h3&gt;
&lt;hr/&gt;&lt;p&gt;从下图可以看出，在 Java 中除了以 &lt;code&gt;Map&lt;/code&gt; 结尾的类之外， 其他类都实现了 &lt;code&gt;Collection&lt;/code&gt; 接口。&lt;/p&gt;
&lt;p&gt;并且，以 &lt;code&gt;Map&lt;/code&gt; 结尾的类都实现了 &lt;code&gt;Map&lt;/code&gt; 接口。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://qiniuyun.antoniopeng.com/java%E5%AE%B9%E5%99%A8%E7%B3%BB%E5%88%9701.png-watermark&quot; alt=&quot;img&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;如何选用集合&quot;&gt;如何选用集合&lt;/h3&gt;
&lt;hr/&gt;&lt;p&gt;主要根据集合的特点来选用，比如我们需要根据键值获取到元素值时就选用 &lt;code&gt;Map&lt;/code&gt; 接口下的集合，需要排序时选择 &lt;code&gt;TreeMap&lt;/code&gt;,不需要排序时就选择 &lt;code&gt;HashMap&lt;/code&gt;,需要保证线程安全就选用 &lt;code&gt;ConcurrentHashMap&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;当我们只需要存放元素值时，就选择实现&lt;code&gt;Collection&lt;/code&gt; 接口的集合，需要保证元素唯一时选择实现 &lt;code&gt;Set&lt;/code&gt; 接口的集合比如 &lt;code&gt;TreeSet&lt;/code&gt; 或 &lt;code&gt;HashSet&lt;/code&gt;，不需要就选择实现 &lt;code&gt;List&lt;/code&gt; 接口的比如 &lt;code&gt;ArrayList&lt;/code&gt; 或 &lt;code&gt;LinkedList&lt;/code&gt;，然后再根据实现这些接口的集合的特点来选用。&lt;/p&gt;
&lt;h3 id=&quot;list、set、map-三者的区别&quot;&gt;List、Set、Map 三者的区别&lt;/h3&gt;
&lt;hr/&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;List&lt;/code&gt;(对付顺序的好帮手)： 存储的元素是有序的、可重复的。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Set&lt;/code&gt;(注重独一无二的性质): 存储的元素是无序的、不可重复的。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Map&lt;/code&gt;(用 Key 来搜索的专家): 使用键值对（kye-value）存储，类似于数学上的函数 y=f(x)，“x”代表 key，&quot;y&quot;代表 value，Key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;底层数据结构&quot;&gt;底层数据结构&lt;/h4&gt;
&lt;p&gt;先来看一下 &lt;code&gt;Collection&lt;/code&gt; 接口下面的集合。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. List&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Arraylist&lt;/code&gt;： &lt;code&gt;Object[]&lt;/code&gt;数组&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Vector&lt;/code&gt;：&lt;code&gt;Object[]&lt;/code&gt;数组&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LinkedList&lt;/code&gt;： 双向链表(JDK1.6 之前为循环链表，JDK1.7 取消了循环)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;2. Set&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;HashSet&lt;/code&gt;（无序，唯一）: 基于 &lt;code&gt;HashMap&lt;/code&gt; 实现的，底层采用 &lt;code&gt;HashMap&lt;/code&gt; 来保存元素&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LinkedHashSet&lt;/code&gt;：&lt;code&gt;LinkedHashSet&lt;/code&gt; 是 &lt;code&gt;HashSet&lt;/code&gt; 的子类，并且其内部是通过 &lt;code&gt;LinkedHashMap&lt;/code&gt; 来实现的。有点类似于我们之前说的 &lt;code&gt;LinkedHashMap&lt;/code&gt; 其内部是基于 &lt;code&gt;HashMap&lt;/code&gt; 实现一样，不过还是有一点点区别的&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TreeSet&lt;/code&gt;（有序，唯一）： 红黑树(自平衡的排序二叉树)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;3. Map&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;再来看看 &lt;code&gt;Map&lt;/code&gt; 接口下面的集合。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;HashMap&lt;/code&gt;： JDK1.8 之前 &lt;code&gt;HashMap&lt;/code&gt; 由数组+链表组成的，数组是 &lt;code&gt;HashMap&lt;/code&gt; 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LinkedHashMap&lt;/code&gt;： &lt;code&gt;LinkedHashMap&lt;/code&gt; 继承自 &lt;code&gt;HashMap&lt;/code&gt;，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，&lt;code&gt;LinkedHashMap&lt;/code&gt; 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。详细可以查看：&lt;a href=&quot;https://www.imooc.com/article/22931&quot; target=&quot;_blank&quot;&gt;《LinkedHashMap 源码详细分析（JDK1.8）》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Hashtable&lt;/code&gt;： 数组+链表组成的，数组是 &lt;code&gt;HashMap&lt;/code&gt; 的主体，链表则是主要为了解决哈希冲突而存在的&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TreeMap&lt;/code&gt;： 红黑树（自平衡的排序二叉树）&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;collection-子接口之-list&quot;&gt;Collection 子接口之 List&lt;/h3&gt;
&lt;hr/&gt;&lt;h4 id=&quot;arraylist-和-vector-的区别&quot;&gt;Arraylist 和 Vector 的区别&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;ArrayList&lt;/code&gt; 是 &lt;code&gt;List&lt;/code&gt; 的主要实现类，底层使用 &lt;code&gt;Object[ ]&lt;/code&gt;存储，适用于频繁的查找工作，线程不安全 ；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Vector&lt;/code&gt; 是 &lt;code&gt;List&lt;/code&gt; 的古老实现类，底层使用 &lt;code&gt;Object[ ]&lt;/code&gt; 存储，线程安全的。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;arraylist-与-linkedlist-区别&quot;&gt;Arraylist 与 LinkedList 区别&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;是否保证线程安全： &lt;code&gt;ArrayList&lt;/code&gt; 和 &lt;code&gt;LinkedList&lt;/code&gt; 都是不同步的，也就是不保证线程安全；&lt;/li&gt;
&lt;li&gt;底层数据结构： &lt;code&gt;Arraylist&lt;/code&gt; 底层使用的是 &lt;strong&gt;&lt;code&gt;Object&lt;/code&gt; 数组&lt;/strong&gt;；&lt;code&gt;LinkedList&lt;/code&gt; 底层使用的是 &lt;strong&gt;双向链表&lt;/strong&gt; 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）&lt;/li&gt;
&lt;li&gt;插入和删除是否受元素位置的影响： ① &lt;strong&gt;&lt;code&gt;ArrayList&lt;/code&gt; 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。&lt;/strong&gt; 比如：执行&lt;code&gt;add(E e)&lt;/code&gt;方法的时候， &lt;code&gt;ArrayList&lt;/code&gt; 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（&lt;code&gt;add(int index, E element)&lt;/code&gt;）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。 ② &lt;strong&gt;&lt;code&gt;LinkedList&lt;/code&gt; 采用链表存储，所以对于&lt;code&gt;add(E e)&lt;/code&gt;方法的插入，删除元素时间复杂度不受元素位置的影响，近似 O(1)，如果是要在指定位置&lt;code&gt;i&lt;/code&gt;插入和删除元素的话（&lt;code&gt;(add(int index, E element)&lt;/code&gt;） 时间复杂度近似为&lt;code&gt;o(n))&lt;/code&gt;因为需要先移动到指定位置再插入。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;是否支持快速随机访问： &lt;code&gt;LinkedList&lt;/code&gt; 不支持高效的随机元素访问，而 &lt;code&gt;ArrayList&lt;/code&gt; 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于&lt;code&gt;get(int index)&lt;/code&gt;方法)。&lt;/li&gt;
&lt;li&gt;内存空间占用： ArrayList 的空 间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;双向链表和双向循环链表&quot;&gt;双向链表和双向循环链表&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;双向链表：&lt;/strong&gt; 包含两个指针，一个 prev 指向前一个节点，一个 next 指向后一个节点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://qiniuyun.antoniopeng.com/java%E5%AE%B9%E5%99%A8%E7%B3%BB%E5%88%9702.png&quot; alt=&quot;img&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;双向循环链表：&lt;/strong&gt; 最后一个节点的 next 指向 head，而 head 的 prev 指向最后一个节点，构成一个环。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://qiniuyun.antoniopeng.com/java%E5%AE%B9%E5%99%A8%E7%B3%BB%E5%88%9703.png&quot; alt=&quot;img&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;collection-子接口之-set&quot;&gt;Collection 子接口之 Set&lt;/h3&gt;
&lt;hr/&gt;&lt;h4 id=&quot;comparable-和-comparator-的区别&quot;&gt;comparable 和 Comparator 的区别&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;comparable&lt;/code&gt; 接口实际上是出自&lt;code&gt;java.lang&lt;/code&gt;包 它有一个 &lt;code&gt;compareTo(Object obj)&lt;/code&gt;方法用来排序&lt;/li&gt;
&lt;li&gt;&lt;code&gt;comparator&lt;/code&gt;接口实际上是出自 java.util 包它有一个&lt;code&gt;compare(Object obj1, Object obj2)&lt;/code&gt;方法用来排序&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;一般我们需要对一个集合使用自定义排序时，我们就要重写&lt;code&gt;compareTo()&lt;/code&gt;方法或&lt;code&gt;compare()&lt;/code&gt;方法，当我们需要对某一个集合实现两种排序方式，比如一个 song 对象中的歌名和歌手名分别采用一种排序方法的话，我们可以重写&lt;code&gt;compareTo()&lt;/code&gt;方法和使用自制的&lt;code&gt;Comparator&lt;/code&gt;方法或者以两个 Comparator 来实现歌名排序和歌星名排序，第二种代表我们只能使用两个参数版的 &lt;code&gt;Collections.sort()&lt;/code&gt;.&lt;/p&gt;
&lt;h4 id=&quot;comparator-定制排序&quot;&gt;Comparator 定制排序&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;ArrayList&amp;lt;Integer&amp;gt; arrayList = new ArrayList&amp;lt;Integer&amp;gt;();
arrayList.add(-1);
arrayList.add(3);
arrayList.add(3);
arrayList.add(-5);
arrayList.add(7);
arrayList.add(4);
arrayList.add(-9);
arrayList.add(-7);
System.out.println(&quot;原始数组:&quot;);
System.out.println(arrayList);
// void reverse(List list)：反转
Collections.reverse(arrayList);
System.out.println(&quot;Collections.reverse(arrayList):&quot;);
System.out.println(arrayList);

// void sort(List list),按自然排序的升序排序
Collections.sort(arrayList);
System.out.println(&quot;Collections.sort(arrayList):&quot;);
System.out.println(arrayList);
// 定制排序的用法
Collections.sort(arrayList, new Comparator&amp;lt;Integer&amp;gt;() {

    @Override
    public int compare(Integer o1, Integer o2) {
        return o2.compareTo(o1);
    }
});
System.out.println(&quot;定制排序后：&quot;);
System.out.println(arrayList);Copy to clipboardErrorCopied
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输入如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sh&quot;&gt;原始数组:
[-1, 3, 3, -5, 7, 4, -9, -7]
Collections.reverse(arrayList):
[-7, -9, 4, 7, -5, 3, 3, -1]
Collections.sort(arrayList):
[-9, -7, -5, -1, 3, 3, 4, 7]
定制排序后：
[7, 4, 3, 3, -1, -5, -7, -9]Copy to clipboardErrorCopied
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;无序性和不可重复性的含义&quot;&gt;无序性和不可重复性的含义&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;什么是无序性：&lt;/strong&gt;无序性不等于随机性 ，无序性是指存储的数据在底层数组中并非按照数组索引的顺序添加 ，而是根据数据的哈希值决定的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;什么是不可重复性：&lt;/strong&gt;不可重复性是指添加的元素按照 equals()判断时 ，返回 false，需要同时重写 equals()方法和 HashCode()方法。&lt;/p&gt;
&lt;h4 id=&quot;hashset、linkedhashset、treeset-的区别&quot;&gt;HashSet、LinkedHashSet、TreeSet 的区别&lt;/h4&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;HashSet&lt;/code&gt; 是 &lt;code&gt;Set&lt;/code&gt; 接口的主要实现类 ，&lt;code&gt;HashSet&lt;/code&gt; 的底层是 &lt;code&gt;HashMap&lt;/code&gt;，线程不安全的，可以存储 null 值；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;LinkedHashSet&lt;/code&gt; 是 &lt;code&gt;HashSet&lt;/code&gt; 的子类，能够按照添加的顺序遍历；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;TreeSet&lt;/code&gt; 底层使用红黑树，能够按照添加元素的顺序进行遍历，排序的方式有自然排序和定制排序。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;map-接口&quot;&gt;Map 接口&lt;/h3&gt;
&lt;hr/&gt;&lt;h4 id=&quot;hashmap-和-hashtable-的区别&quot;&gt;HashMap 和 Hashtable 的区别&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;线程是否安全： &lt;code&gt;HashMap&lt;/code&gt; 是非线程安全的，&lt;code&gt;HashTable&lt;/code&gt; 是线程安全的,因为 &lt;code&gt;HashTable&lt;/code&gt; 内部的方法基本都经过&lt;code&gt;synchronized&lt;/code&gt; 修饰。（如果你要保证线程安全的话就使用 &lt;code&gt;ConcurrentHashMap&lt;/code&gt; 吧！）；&lt;/li&gt;
&lt;li&gt;效率： 因为线程安全的问题，&lt;code&gt;HashMap&lt;/code&gt; 要比 &lt;code&gt;HashTable&lt;/code&gt; 效率高一点。另外，&lt;code&gt;HashTable&lt;/code&gt; 基本被淘汰，不要在代码中使用它；&lt;/li&gt;
&lt;li&gt;对 Null key 和 Null value 的支持： &lt;code&gt;HashMap&lt;/code&gt; 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个；HashTable 不允许有 null 键和 null 值，否则会抛出 &lt;code&gt;NullPointerException&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;初始容量大小和每次扩充容量大小的不同 ： ① 创建时如果不指定容量初始值，&lt;code&gt;Hashtable&lt;/code&gt; 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。&lt;code&gt;HashMap&lt;/code&gt; 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。② 创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 &lt;code&gt;HashMap&lt;/code&gt; 会将其扩充为 2 的幂次方大小（&lt;code&gt;HashMap&lt;/code&gt; 中的&lt;code&gt;tableSizeFor()&lt;/code&gt;方法保证，下面给出了源代码）。也就是说 &lt;code&gt;HashMap&lt;/code&gt; 总是使用 2 的幂作为哈希表的大小,后面会介绍到为什么是 2 的幂次方。&lt;/li&gt;
&lt;li&gt;底层数据结构： JDK1.8 以后的 &lt;code&gt;HashMap&lt;/code&gt; 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;&lt;code&gt;HashMap&lt;/code&gt; 中带有初始容量的构造函数：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    public HashMap(int initialCapacity, float loadFactor) {
        if (initialCapacity &amp;lt; 0)
            throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +
                                               initialCapacity);
        if (initialCapacity &amp;gt; MAXIMUM_CAPACITY)
            initialCapacity = MAXIMUM_CAPACITY;
        if (loadFactor &amp;lt;= 0 || Float.isNaN(loadFactor))
            throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +
                                               loadFactor);
        this.loadFactor = loadFactor;
        this.threshold = tableSizeFor(initialCapacity);
    }
     public HashMap(int initialCapacity) {
        this(initialCapacity, DEFAULT_LOAD_FACTOR);
    }Copy to clipboardErrorCopied
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面这个方法保证了 &lt;code&gt;HashMap&lt;/code&gt; 总是使用 2 的幂作为哈希表的大小。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    /**
     * Returns a power of two size for the given target capacity.
     */
    static final int tableSizeFor(int cap) {
        int n = cap - 1;
        n |= n &amp;gt;&amp;gt;&amp;gt; 1;
        n |= n &amp;gt;&amp;gt;&amp;gt; 2;
        n |= n &amp;gt;&amp;gt;&amp;gt; 4;
        n |= n &amp;gt;&amp;gt;&amp;gt; 8;
        n |= n &amp;gt;&amp;gt;&amp;gt; 16;
        return (n &amp;lt; 0) ? 1 : (n &amp;gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
    }Copy to clipboardErrorCopied
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;hashmap-和-hashset-区别&quot;&gt;HashMap 和 HashSet 区别&lt;/h4&gt;
&lt;p&gt;如果你看过 &lt;code&gt;HashSet&lt;/code&gt; 源码的话就应该知道：&lt;code&gt;HashSet&lt;/code&gt; 底层就是基于 &lt;code&gt;HashMap&lt;/code&gt; 实现的。（&lt;code&gt;HashSet&lt;/code&gt; 的源码非常非常少，因为除了 &lt;code&gt;clone()&lt;/code&gt;、&lt;code&gt;writeObject()&lt;/code&gt;、&lt;code&gt;readObject()&lt;/code&gt;是 &lt;code&gt;HashSet&lt;/code&gt; 自己不得不实现之外，其他方法都是直接调用 &lt;code&gt;HashMap&lt;/code&gt; 中的方法。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/th&gt;
&lt;th&gt;&lt;code&gt;HashSet&lt;/code&gt;&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;4.5&quot;&gt;&lt;tr&gt;&lt;td&gt;实现了 &lt;code&gt;Map&lt;/code&gt; 接口&lt;/td&gt;
&lt;td&gt;实现 &lt;code&gt;Set&lt;/code&gt; 接口&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;存储键值对&lt;/td&gt;
&lt;td&gt;仅存储对象&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;调用 &lt;code&gt;put()&lt;/code&gt;向 map 中添加元素&lt;/td&gt;
&lt;td&gt;调用 &lt;code&gt;add()&lt;/code&gt;方法向 &lt;code&gt;Set&lt;/code&gt; 中添加元素&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;&lt;code&gt;HashMap&lt;/code&gt; 使用键（Key）计算 &lt;code&gt;hashcode&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;HashSet&lt;/code&gt; 使用成员对象来计算 &lt;code&gt;hashcode&lt;/code&gt; 值，对于两个对象来说 &lt;code&gt;hashcode&lt;/code&gt; 可能相同，所以 &lt;code&gt;equals()&lt;/code&gt;方法用来判断对象的相等性&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4 id=&quot;hashmap-和-treemap-区别&quot;&gt;HashMap 和 TreeMap 区别&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;TreeMap&lt;/code&gt; 和&lt;code&gt;HashMap&lt;/code&gt; 都继承自&lt;code&gt;AbstractMap&lt;/code&gt; ，但是需要注意的是&lt;code&gt;TreeMap&lt;/code&gt;它还实现了&lt;code&gt;NavigableMap&lt;/code&gt;接口和&lt;code&gt;SortedMap&lt;/code&gt; 接口。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://qiniuyun.antoniopeng.com/java%E5%AE%B9%E5%99%A8%E7%B3%BB%E5%88%9704.png-watermark&quot; alt=&quot;img&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;实现 &lt;code&gt;NavigableMap&lt;/code&gt; 接口让 &lt;code&gt;TreeMap&lt;/code&gt; 有了对集合内元素的搜索的能力。&lt;/p&gt;
&lt;p&gt;实现&lt;code&gt;SortMap&lt;/code&gt;接口让 &lt;code&gt;TreeMap&lt;/code&gt; 有了对集合中的元素根据键排序的能力。默认是按 key 的升序排序，不过我们也可以指定排序的比较器。示例代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * @author shuang.kou
 * @createTime 2020年06月15日 17:02:00
 */
public class Person {
    private Integer age;

    public Person(Integer age) {
        this.age = age;
    }

    public Integer getAge() {
        return age;
    }


    public static void main(String[] args) {
        TreeMap&amp;lt;Person, String&amp;gt; treeMap = new TreeMap&amp;lt;&amp;gt;(new Comparator&amp;lt;Person&amp;gt;() {
            @Override
            public int compare(Person person1, Person person2) {
                int num = person1.getAge() - person2.getAge();
                return Integer.compare(num, 0);
            }
        });
        treeMap.put(new Person(3), &quot;person1&quot;);
        treeMap.put(new Person(18), &quot;person2&quot;);
        treeMap.put(new Person(35), &quot;person3&quot;);
        treeMap.put(new Person(16), &quot;person4&quot;);
        treeMap.entrySet().stream().forEach(personStringEntry -&amp;gt; {
            System.out.println(personStringEntry.getValue());
        });
    }
}Copy to clipboardErrorCopied
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输入如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sh&quot;&gt;person1
person4
person2
person3Copy to clipboardErrorCopied
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看出，&lt;code&gt;TreeMap&lt;/code&gt; 中的元素已经是按照 &lt;code&gt;Person&lt;/code&gt; 的 age 字段的升序来排列了。&lt;/p&gt;
&lt;p&gt;上面，我们是通过传入匿名内部类的方式实现的，你可以将代码替换成 Lambda 表达式实现的方式：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;TreeMap&amp;lt;Person, String&amp;gt; treeMap = new TreeMap&amp;lt;&amp;gt;((person1, person2) -&amp;gt; {
  int num = person1.getAge() - person2.getAge();
  return Integer.compare(num, 0);
});Copy to clipboardErrorCopied
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;综上，相比于&lt;code&gt;HashMap&lt;/code&gt;来说 &lt;code&gt;TreeMap&lt;/code&gt; 主要多了对集合中的元素根据键排序的能力以及对集合内元素的搜索的能力。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;hashset-如何检查重复&quot;&gt;HashSet 如何检查重复&lt;/h4&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;当你把对象加入&lt;code&gt;HashSet&lt;/code&gt;时，&lt;code&gt;HashSet&lt;/code&gt; 会先计算对象的&lt;code&gt;hashcode&lt;/code&gt;值来判断对象加入的位置，同时也会与其他加入的对象的 &lt;code&gt;hashcode&lt;/code&gt; 值作比较，如果没有相符的 &lt;code&gt;hashcode&lt;/code&gt;，&lt;code&gt;HashSet&lt;/code&gt; 会假设对象没有重复出现。但是如果发现有相同 &lt;code&gt;hashcode&lt;/code&gt; 值的对象，这时会调用&lt;code&gt;equals()&lt;/code&gt;方法来检查 &lt;code&gt;hashcode&lt;/code&gt; 相等的对象是否真的相同。如果两者相同，&lt;code&gt;HashSet&lt;/code&gt; 就不会让加入操作成功。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;hashCode()&lt;/code&gt; 与 &lt;code&gt;equals()&lt;/code&gt; 的相关规定：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;如果两个对象相等，则 &lt;code&gt;hashcode&lt;/code&gt; 一定也是相同的&lt;/li&gt;
&lt;li&gt;两个对象相等,对两个 &lt;code&gt;equals()&lt;/code&gt; 方法返回 true&lt;/li&gt;
&lt;li&gt;两个对象有相同的 &lt;code&gt;hashcode&lt;/code&gt; 值，它们也不一定是相等的&lt;/li&gt;
&lt;li&gt;综上，&lt;code&gt;equals()&lt;/code&gt; 方法被覆盖过，则 &lt;code&gt;hashCode()&lt;/code&gt; 方法也必须被覆盖&lt;/li&gt;
&lt;li&gt;&lt;code&gt;hashCode()&lt;/code&gt; 的默认行为是对堆上的对象产生独特值。如果没有重写 &lt;code&gt;hashCode()&lt;/code&gt;，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;== 与 equals 的区别：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于基本类型来说，== 比较的是值是否相等；&lt;/p&gt;
&lt;p&gt;对于引用类型来说，== 比较的是两个引用是否指向同一个对象地址（两者在内存中存放的地址（堆内存地址）是否指向同一个地方）；&lt;/p&gt;
&lt;p&gt;对于引用类型（包括包装类型）来说，equals 如果没有被重写，对比它们的地址是否相等；如果 equals()方法被重写（例如 String），则比较的是地址里的内容。&lt;/p&gt;
&lt;h4 id=&quot;hashmap-的底层实现&quot;&gt;HashMap 的底层实现&lt;/h4&gt;
&lt;p&gt;JDK1.8 之前 &lt;code&gt;HashMap&lt;/code&gt; 底层是 &lt;strong&gt;数组和链表&lt;/strong&gt; 结合在一起使用也就是 &lt;strong&gt;链表散列&lt;/strong&gt;。&lt;strong&gt;HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过 (n - 1) &amp;amp; hash 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;JDK 1.8 的 hash 方法 相比于 JDK 1.7 hash 方法更加简化，但是原理不变。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    static final int hash(Object key) {
      int h;
      // key.hashCode()：返回散列值也就是hashcode
      // ^ ：按位异或
      // &amp;gt;&amp;gt;&amp;gt;:无符号右移，忽略符号位，空位都以0补齐
      return (key == null) ? 0 : (h = key.hashCode()) ^ (h &amp;gt;&amp;gt;&amp;gt; 16);
  }Copy to clipboardErrorCopied
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对比一下 JDK1.7 的 HashMap 中的 hash 方法源码.&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;static int hash(int h) {
    // This function ensures that hashCodes that differ only by
    // constant multiples at each bit position have a bounded
    // number of collisions (approximately 8 at default load factor).

    h ^= (h &amp;gt;&amp;gt;&amp;gt; 20) ^ (h &amp;gt;&amp;gt;&amp;gt; 12);
    return h ^ (h &amp;gt;&amp;gt;&amp;gt; 7) ^ (h &amp;gt;&amp;gt;&amp;gt; 4);
}Copy to clipboardErrorCopied
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;相比于 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能会稍差一点点，因为毕竟扰动了 4 次。&lt;/p&gt;
&lt;p&gt;所谓 &lt;strong&gt;“拉链法”&lt;/strong&gt; 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。&lt;/p&gt;
&lt;p&gt;相比于 JDK1.7 版本， JDK1.8 之后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://qiniuyun.antoniopeng.com/java%E5%AE%B9%E5%99%A8%E7%B3%BB%E5%88%9705.png-watermark&quot; alt=&quot;img&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;TreeMap、TreeSet 以及 JDK1.8 之后的 HashMap 底层都用到了红黑树。红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;hashmap-的长度为什么是-2-的幂次方&quot;&gt;HashMap 的长度为什么是 2 的幂次方&lt;/h4&gt;
&lt;p&gt;为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀。我们上面也讲到了过了，Hash 值的范围值-2147483648 到 2147483647，前后加起来大概 40 亿的映射空间，只要哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的。但问题是一个 40 亿长度的数组，内存是放不下的。所以这个散列值是不能直接拿来用的。用之前还要先做对数组的长度取模运算，得到的余数才能用来要存放的位置也就是对应的数组下标。这个数组下标的计算方法是“ &lt;code&gt;(n - 1) &amp;amp; hash&lt;/code&gt;”。（n 代表数组长度）。这也就解释了 HashMap 的长度为什么是 2 的幂次方。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这个算法应该如何设计呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们首先可能会想到采用%取余的操作来实现。但是，重点来了：&lt;strong&gt;“取余(%)操作中如果除数是 2 的幂次则等价于与其除数减一的与(&amp;amp;)操作（也就是说 hash%length==hash&amp;amp;(length-1)的前提是 length 是 2 的 n 次方；）。”&lt;/strong&gt; 并且 &lt;strong&gt;采用二进制位操作 &amp;amp;，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是 2 的幂次方。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;hashmap-多线程操作导致死循环问题&quot;&gt;HashMap 多线程操作导致死循环问题&lt;/h4&gt;
&lt;p&gt;主要原因在于并发下的 Rehash 会造成元素之间会形成一个循环链表。不过，jdk 1.8 后解决了这个问题，但是还是不建议在多线程下使用 HashMap,因为多线程下使用 HashMap 还是会存在其他问题比如数据丢失。并发环境下推荐使用 ConcurrentHashMap 。&lt;/p&gt;
&lt;h4 id=&quot;hashmap-常见的遍历方式&quot;&gt;HashMap 常见的遍历方式&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/Zz6mofCtmYpABDL1ap04ow&quot; target=&quot;_blank&quot;&gt;HashMap 的 7 种遍历方式与性能分析！&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;concurrenthashmap-和-hashtable-的区别&quot;&gt;ConcurrentHashMap 和 Hashtable 的区别&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;ConcurrentHashMap&lt;/code&gt; 和 &lt;code&gt;Hashtable&lt;/code&gt; 的区别主要体现在实现线程安全的方式上不同。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;底层数据结构：&lt;/strong&gt; JDK1.7 的 &lt;code&gt;ConcurrentHashMap&lt;/code&gt; 底层采用 &lt;strong&gt;分段的数组+链表&lt;/strong&gt; 实现，JDK1.8 采用的数据结构跟 &lt;code&gt;HashMap1.8&lt;/code&gt; 的结构一样，数组+链表/红黑二叉树。&lt;code&gt;Hashtable&lt;/code&gt; 和 JDK1.8 之前的 &lt;code&gt;HashMap&lt;/code&gt; 的底层数据结构类似都是采用 &lt;strong&gt;数组+链表&lt;/strong&gt; 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;实现线程安全的方式（重要）：&lt;/strong&gt; ① &lt;strong&gt;在 JDK1.7 的时候，&lt;code&gt;ConcurrentHashMap&lt;/code&gt;（分段锁）&lt;/strong&gt; 对整个桶数组进行了分割分段(&lt;code&gt;Segment&lt;/code&gt;)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。 &lt;strong&gt;到了 JDK1.8 的时候已经摒弃了 &lt;code&gt;Segment&lt;/code&gt; 的概念，而是直接用 &lt;code&gt;Node&lt;/code&gt; 数组+链表+红黑树的数据结构来实现，并发控制使用 &lt;code&gt;synchronized&lt;/code&gt; 和 CAS 来操作。（JDK1.6 以后 对 &lt;code&gt;synchronized&lt;/code&gt; 锁做了很多优化）&lt;/strong&gt; 整个看起来就像是优化过且线程安全的 &lt;code&gt;HashMap&lt;/code&gt;，虽然在 JDK1.8 中还能看到 &lt;code&gt;Segment&lt;/code&gt; 的数据结构，但是已经简化了属性，只是为了兼容旧版本；② &lt;strong&gt;&lt;code&gt;Hashtable&lt;/code&gt;(同一把锁)&lt;/strong&gt; :使用 &lt;code&gt;synchronized&lt;/code&gt; 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://qiniuyun.antoniopeng.com/java%E5%AE%B9%E5%99%A8%E7%B3%BB%E5%88%9706.png-watermark&quot; alt=&quot;img&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://qiniuyun.antoniopeng.com/java%E5%AE%B9%E5%99%A8%E7%B3%BB%E5%88%9707.png-watermark&quot; alt=&quot;img&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://qiniuyun.antoniopeng.com/java%E5%AE%B9%E5%99%A8%E7%B3%BB%E5%88%9708.png-watermark&quot; alt=&quot;img&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;JDK1.8 的 &lt;code&gt;ConcurrentHashMap&lt;/code&gt; 不在是 &lt;strong&gt;Segment 数组 + HashEntry 数组 + 链表&lt;/strong&gt;，而是 &lt;strong&gt;Node 数组 + 链表 / 红黑树&lt;/strong&gt;。不过，Node 只能用于链表的情况，红黑树的情况需要使用 &lt;strong&gt;&lt;code&gt;TreeNode&lt;/code&gt;&lt;/strong&gt;。当冲突链表达到一定长度时，链表会转换成红黑树。&lt;/p&gt;
&lt;h4 id=&quot;concurrenthashmap-线程安全的底层实现&quot;&gt;ConcurrentHashMap 线程安全的底层实现&lt;/h4&gt;
&lt;p&gt;上面有示意图。&lt;/p&gt;
&lt;ul readability=&quot;12&quot;&gt;&lt;li readability=&quot;17&quot;&gt;
&lt;p&gt;JDK 1.7 的 ConcurrentHashMap&lt;/p&gt;
&lt;p&gt;首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;ConcurrentHashMap&lt;/code&gt; 是由 &lt;code&gt;Segment&lt;/code&gt; 数组结构和 &lt;code&gt;HashEntry&lt;/code&gt; 数组结构组成&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;Segment 实现了 &lt;code&gt;ReentrantLock&lt;/code&gt;,所以 &lt;code&gt;Segment&lt;/code&gt; 是一种可重入锁，扮演锁的角色。&lt;code&gt;HashEntry&lt;/code&gt; 用于存储键值对数据。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;static class Segment&amp;lt;K,V&amp;gt; extends ReentrantLock implements Serializable {
}Copy to clipboardErrorCopied
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一个 &lt;code&gt;ConcurrentHashMap&lt;/code&gt; 里包含一个 &lt;code&gt;Segment&lt;/code&gt; 数组。&lt;code&gt;Segment&lt;/code&gt; 的结构和 &lt;code&gt;HashMap&lt;/code&gt; 类似，是一种数组和链表结构，一个 &lt;code&gt;Segment&lt;/code&gt; 包含一个 &lt;code&gt;HashEntry&lt;/code&gt; 数组，每个 &lt;code&gt;HashEntry&lt;/code&gt; 是一个链表结构的元素，每个 &lt;code&gt;Segment&lt;/code&gt; 守护着一个 &lt;code&gt;HashEntry&lt;/code&gt; 数组里的元素，当对 &lt;code&gt;HashEntry&lt;/code&gt; 数组的数据进行修改时，必须首先获得对应的 &lt;code&gt;Segment&lt;/code&gt; 的锁。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;7&quot;&gt;
&lt;p&gt;JDK 1.8 的 ConcurrentHashMap&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ConcurrentHashMap&lt;/code&gt; 取消了 &lt;code&gt;Segment&lt;/code&gt; 分段锁，采用 CAS 和 &lt;code&gt;synchronized&lt;/code&gt; 来保证并发安全。数据结构跟 HashMap1.8 的结构类似，数组+链表/红黑二叉树。Java 8 在链表长度超过一定阈值（8）时将链表（寻址时间复杂度为 O(N)）转换为红黑树（寻址时间复杂度为 O(log(N))）&lt;/p&gt;
&lt;p&gt;&lt;code&gt;synchronized&lt;/code&gt; 只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发，效率又提升 N 倍。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;collections-工具类&quot;&gt;Collections 工具类&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;排序&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;void reverse(List list)//反转
void shuffle(List list)//随机排序
void sort(List list)//按自然排序的升序排序
void sort(List list, Comparator c)//定制排序，由Comparator控制排序逻辑
void swap(List list, int i , int j)//交换两个索引位置的元素
void rotate(List list, int distance)//旋转。当distance为正数时，将list后distance个元素整体移到前面。当distance为负数时，将 list的前distance个元素整体移到后面Copy to clipboardErrorCopied
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;查找、替换操作&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;int binarySearch(List list, Object key)//对List进行二分查找，返回索引，注意List必须是有序的
int max(Collection coll)//根据元素的自然顺序，返回最大的元素。 类比int min(Collection coll)
int max(Collection coll, Comparator c)//根据定制排序，返回最大元素，排序规则由Comparatator类控制。类比int min(Collection coll, Comparator c)
void fill(List list, Object obj)//用指定的元素代替指定list中的所有元素。
int frequency(Collection c, Object o)//统计元素出现次数
int indexOfSubList(List list, List target)//统计target在list中第一次出现的索引，找不到则返回-1，类比int lastIndexOfSubList(List source, list target).
boolean replaceAll(List list, Object oldVal, Object newVal), 用新元素替换旧元素Copy to clipboardErrorCopied
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;2.5531914893617&quot;&gt;
&lt;p&gt;更多干货请移步：&lt;a href=&quot;https://antoniopeng.com&quot; target=&quot;_blank&quot;&gt;https://antoniopeng.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Thu, 04 Feb 2021 00:25:00 +0000</pubDate>
<dc:creator>暮夏有五</dc:creator>
<og:description>为什么要使用集合 当我们需要保存一组类型相同的数据的时候，我们应该是用一个容器来保存，这个容器就是数组，但是，使用数组存储对象具有一定的弊端， 因为我们在实际开发中，存储的数据的类型是多种多样的，于是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/antoniopeng/p/14370679.html</dc:identifier>
</item>
<item>
<title>数理统计6：泊松分布，泊松分布与指数分布的联系，离散分布参数估计 - 江景景景页</title>
<link>http://www.cnblogs.com/jy333/p/14370561.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jy333/p/14370561.html</guid>
<description>&lt;p&gt;泊松分布，泊松分布与指数分布的联系，离散分布参数估计。好短的篇幅。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;207.1217750258&quot;&gt;
&lt;p&gt;前两天对两大连续型分布：均匀分布和指数分布的点估计进行了讨论，导出了我们以后会用到的两大分布：&lt;span class=&quot;math inline&quot;&gt;\(\beta\)&lt;/span&gt;分布和&lt;span class=&quot;math inline&quot;&gt;\(\Gamma\)&lt;/span&gt;分布。今天，我们将讨论离散分布中的泊松分布。其实，最简单的离散分布应该是两点分布，但由于在上一篇文章的最后，提到了&lt;span class=&quot;math inline&quot;&gt;\(\Gamma\)&lt;/span&gt;分布和泊松分布的联系，因此本文从泊松分布出发。由于本系列为我独自完成的，缺少审阅，&lt;strong&gt;如果有任何错误，欢迎在评论区中指出，谢谢&lt;/strong&gt;！&lt;/p&gt;

&lt;h2 id=&quot;part-1：泊松分布简介&quot;&gt;Part 1：泊松分布简介&lt;/h2&gt;
&lt;p&gt;泊松分布是一种离散分布，先给出其概率分布列。若&lt;span class=&quot;math inline&quot;&gt;\(X\sim P(\lambda)\)&lt;/span&gt;，则&lt;/p&gt;
&lt;p&gt;\[\mathbb{P}(X=k)=\frac{\lambda^k}{k!}e^{-\lambda},\quad k=0,1,\cdots \]&lt;/p&gt;
&lt;p&gt;它的取值是无限可列的。&lt;/p&gt;
&lt;blockquote readability=&quot;29&quot;&gt;
&lt;p&gt;为什么泊松分布会与指数分布、&lt;span class=&quot;math inline&quot;&gt;\(\Gamma\)&lt;/span&gt;分布有联系呢？这是因为，它们三个都是随机事件发生的一种描述。&lt;/p&gt;
&lt;p&gt;实际上，指数分布的参数&lt;span class=&quot;math inline&quot;&gt;\(\lambda\)&lt;/span&gt;是一种速率的体现，它刻画了随机事件发生的速率。而指数分布随机变量的取值，就代表某一事件在一定的速率下发生的时刻距离计时原点的长度。&lt;span class=&quot;math inline&quot;&gt;\(Y\sim E(\lambda)\)&lt;/span&gt;，就代表&lt;span class=&quot;math inline&quot;&gt;\(Y\)&lt;/span&gt;对应的事件事件的发生速率是&lt;span class=&quot;math inline&quot;&gt;\(\lambda\)&lt;/span&gt;，所以平均发生时间就在在&lt;span class=&quot;math inline&quot;&gt;\(1/\lambda\)&lt;/span&gt;处。这也可以作为&lt;span class=&quot;math inline&quot;&gt;\(\mathbb{E}(Y)=1/\lambda\)&lt;/span&gt;的一种解释。&lt;/p&gt;
&lt;p&gt;指数分布具有&lt;strong&gt;无记忆性&lt;/strong&gt;，这与随机事件的发生相似，即已经发生历史事件对未来不产生影响，用数学语言说就是&lt;span class=&quot;math inline&quot;&gt;\(\mathbb{P}(Y&amp;gt;s+t|Y&amp;gt;s)=\mathbb{P}(Y&amp;gt;t)\)&lt;/span&gt;。这指的是，如果一个事件平均会在&lt;span class=&quot;math inline&quot;&gt;\(s\)&lt;/span&gt;时间后发生，但是目前经过了&lt;span class=&quot;math inline&quot;&gt;\(t\)&lt;/span&gt;时间还没有发生，则事件的平均发生时间就移动到&lt;span class=&quot;math inline&quot;&gt;\(t+s\)&lt;/span&gt;时间后。它不会因为你已经等了&lt;span class=&quot;math inline&quot;&gt;\(t\)&lt;/span&gt;时间，就会更快地发生。&lt;/p&gt;
&lt;p&gt;而如果把&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;个独立同分布于&lt;span class=&quot;math inline&quot;&gt;\(E(\lambda)\)&lt;/span&gt;指数分布随机变量相加，得到的自然就是恰好发生&lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt;个事件的平均时间，这个时间&lt;span class=&quot;math inline&quot;&gt;\(Z\sim \Gamma(n,\lambda)\)&lt;/span&gt;，本质还是一种时间的度量。但&lt;span class=&quot;math inline&quot;&gt;\(Z\)&lt;/span&gt;就不具有无记忆性了，这是因为，经过&lt;span class=&quot;math inline&quot;&gt;\(t\)&lt;/span&gt;时间后可能已经发生了&lt;span class=&quot;math inline&quot;&gt;\(n-1\)&lt;/span&gt;个事件就差最后一个没有发生，也可能一个事件都没发生还需要&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;个才能凑齐。&lt;/p&gt;
&lt;p&gt;泊松分布则刚好相反，指数分布和&lt;span class=&quot;math inline&quot;&gt;\(\Gamma\)&lt;/span&gt;分布都是限定了发生次数，对发生时间作度量；泊松分布则是限定了时间&lt;span class=&quot;math inline&quot;&gt;\(1\)&lt;/span&gt;，求随机事件在这一段时间内发生的次数服从的概率分布。因此，泊松分布和指数分布、&lt;span class=&quot;math inline&quot;&gt;\(\Gamma\)&lt;/span&gt;分布才会存在着这样的联系。&lt;/p&gt;
&lt;p&gt;以上结论，在随机过程中会有广泛的应用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;接下来要介绍泊松分布的一种实用性质：&lt;strong&gt;可加性&lt;/strong&gt;。若&lt;span class=&quot;math inline&quot;&gt;\(X_1\sim P(\lambda_1)\)&lt;/span&gt;，&lt;span class=&quot;math inline&quot;&gt;\(X_2\sim P(\lambda_2)\)&lt;/span&gt;且相互独立，则&lt;/p&gt;
&lt;p&gt;\[X_1+X_2\sim P(\lambda_1+\lambda_2). \]&lt;/p&gt;
&lt;p&gt;如果两个独立泊松变量的可加性成立，则自然可以推广到有限多个独立泊松变量，下面利用离散卷积公式给出证明。&lt;/p&gt;
&lt;p&gt;\[\begin{aligned} \mathbb{P}(X_1+X_2=k)&amp;amp;=\sum_{j=0}^{k}\mathbb{P}(X_1=j)\mathbb{P}(X_2=k-j)\\ &amp;amp;=\sum_{j=0}^k\frac{\lambda_1^j}{j!}e^{-\lambda_1}\cdot\frac{\lambda_2^{k-j}}{(k-j)!}e^{-\lambda_2}\\ &amp;amp;=\frac{e^{-(\lambda_1+\lambda_2)}}{k!}\sum_{j=0}^{k}\frac{k!}{j!(k-j)!}\lambda_1^j\lambda_2^{k-j}\\ &amp;amp;=\frac{(\lambda_1+\lambda_2)^{k}}{k!}e^{-(\lambda_1+\lambda_2)}. \end{aligned} \]&lt;/p&gt;
&lt;p&gt;这是泊松分布的概率分布列。&lt;/p&gt;
&lt;blockquote readability=&quot;16&quot;&gt;
&lt;p&gt;还可以利用泊松分布的特征函数来证明。设&lt;span class=&quot;math inline&quot;&gt;\(X\sim P(\lambda)\)&lt;/span&gt;，则&lt;/p&gt;
&lt;p&gt;\[\begin{aligned} \phi_X(t)&amp;amp;=\mathbb{E}(e^{\mathrm{i}tX})\\ &amp;amp;=\sum_{j=0}^{\infty}\frac{\lambda^j}{j!}e^{\mathrm{i}tj-\lambda}\\ &amp;amp;=e^{-\lambda}\sum_{j=0}^{\infty}\frac{(\lambda e^{\mathrm{i}t})^j}{j!}\\ &amp;amp;=e^{-\lambda(e^{{\rm i}t}-1)}. \end{aligned} \]&lt;/p&gt;
&lt;p&gt;所以当&lt;span class=&quot;math inline&quot;&gt;\(X_1\sim P(\lambda_1)\)&lt;/span&gt;，&lt;span class=&quot;math inline&quot;&gt;\(X_2\sim P(\lambda_2)\)&lt;/span&gt;且相互独立时，&lt;/p&gt;
&lt;p&gt;\[\phi_{X_1+X_2}(t)=e^{-(\lambda_1+\lambda_2)(e^{{\rm i}t}-1)}, \]&lt;/p&gt;
&lt;p&gt;即&lt;span class=&quot;math inline&quot;&gt;\(X_1+X_2\sim P(\lambda_1+\lambda_2)\)&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;知道了泊松分布具有可加性后，我们接下来讨论泊松分布的点估计就会很方便。&lt;/p&gt;
&lt;h2 id=&quot;part-2：泊松分布的点估计&quot;&gt;Part 2：泊松分布的点估计&lt;/h2&gt;
&lt;p&gt;对泊松分布的估计其实没有什么难点，无非是将因子分解定理用到了离散情况罢了。对于离散情况，要写出其联合概率分布：&lt;/p&gt;
&lt;p&gt;\[\begin{aligned} &amp;amp;\quad \mathbb{P}(X_1=x_1,\cdots,X_n=x_n)\\ &amp;amp;=\prod_{j=1}^n \frac{\lambda^{x_j}}{x_j!}e^{-\lambda}\\ &amp;amp;=e^{-n\lambda}\lambda^{\sum_{j=1}^n x_j}\cdot\frac{1}{\prod_{j=1}^n (x_j!)}\\ &amp;amp;\xlongequal{def}g\left(\sum_{j=1}^n x_j,\lambda \right)\cdot h(\boldsymbol{x}), \end{aligned} \]&lt;/p&gt;
&lt;p&gt;故&lt;span class=&quot;math inline&quot;&gt;\(T=\sum_{j=1}^n X_j\sim P(n\lambda)\)&lt;/span&gt;是&lt;span class=&quot;math inline&quot;&gt;\(\lambda\)&lt;/span&gt;的充分统计量，这说明&lt;span class=&quot;math inline&quot;&gt;\(\bar X\)&lt;/span&gt;也是充分统计量。又因为&lt;span class=&quot;math inline&quot;&gt;\(\mathbb{E}(X)=\lambda\)&lt;/span&gt;，所以&lt;span class=&quot;math inline&quot;&gt;\(\mathbb{E}(\bar X)=\lambda\)&lt;/span&gt;，证明了&lt;span class=&quot;math inline&quot;&gt;\(\bar X\)&lt;/span&gt;是无偏的，由强大数定律，&lt;span class=&quot;math inline&quot;&gt;\(\bar X\)&lt;/span&gt;还是强相合的。&lt;/p&gt;
&lt;p&gt;从这里得到的启示是，在写离散分布的概率密度函数时，要写&lt;/p&gt;
&lt;p&gt;\[\mathbb{P}(X_1=x_1,\cdots,X_n=x_n). \]&lt;/p&gt;
&lt;p&gt;这个表达式以后也会起到很大的作用。&lt;/p&gt;
&lt;p&gt;对于离散分布，有时会需要你用定义验证参数估计量的充分性（别说你已经把定义忘了），就是&lt;/p&gt;
&lt;p&gt;\[\mathbb{P}(X_1=x_1,\cdots,X_n=x_n|T=t) \]&lt;/p&gt;
&lt;p&gt;与参数的无关性。我们现在对泊松分布的充分估计量&lt;span class=&quot;math inline&quot;&gt;\(T=\sum_{j=1}^n X_j\)&lt;/span&gt;验证这一点，对于离散分布，步骤可能和连续分布略有不同，因为不使用Jacobi变换似乎更简单一些，特别是&lt;span class=&quot;math inline&quot;&gt;\(T\sim P(n\lambda)\)&lt;/span&gt;的分布已知时。&lt;/p&gt;
&lt;p&gt;\[\begin{aligned} &amp;amp;\quad \mathbb{P}(X_1=x_1,\cdots,X_{n}=x_n|T=t)\\ &amp;amp;=\frac{\mathbb{P}(X_1=x_1,\cdots,X_{n-1}=x_{n-1},X_n=T-\sum_{j=1}^{n-1}x_j)}{\mathbb{P}(T=t)}\\ &amp;amp;=\prod_{j=1}^{n-1}\left(\frac{\lambda^{x_j}}{x_j!}e^{-\lambda}\right)\cdot\frac{\lambda^{t-\sum_{j=1}^{n-1}x_j}}{(t-\sum_{j=1}^{n-1}x_j)!}e^{-\lambda}\bigg/\left(\frac{\lambda^t}{t!}e^{-n\lambda} \right)\\ &amp;amp;=\frac{t!}{(\prod_{j=1}^{n-1}x_j!)(t-\sum_{j=1}^{n-1}x_j)!}. \end{aligned} \]&lt;/p&gt;
&lt;p&gt;显然这个概率与&lt;span class=&quot;math inline&quot;&gt;\(\lambda\)&lt;/span&gt;无关，所以&lt;span class=&quot;math inline&quot;&gt;\(T\)&lt;/span&gt;是充分统计量。&lt;/p&gt;
&lt;h2 id=&quot;part-3：其他离散分布的点估计&quot;&gt;Part 3：其他离散分布的点估计&lt;/h2&gt;
&lt;p&gt;本来以为泊松分布能写的东西不少，结果大多笔墨花在了背景介绍上，关于泊松分布点估计却只写了短短几行。既然如此，本文就将常用离散分布的点估计全部给出。&lt;/p&gt;
&lt;p&gt;对于两点分布&lt;span class=&quot;math inline&quot;&gt;\(B(1,p)\)&lt;/span&gt;，注意到&lt;span class=&quot;math inline&quot;&gt;\(P(X=x)=p^x(1-p)^{1-x}\)&lt;/span&gt;，所以其联合概率函数是&lt;/p&gt;
&lt;p&gt;\[\mathbb{P}(X_1=x_1,\cdots,X_n=x_n)=p^{\sum_{j=1}^nx_j}(1-p)^{n-\sum_{j=1}^n x_j}, \]&lt;/p&gt;
&lt;p&gt;得到其充分统计量为&lt;span class=&quot;math inline&quot;&gt;\(T=\sum_{j=1}^n X_j\)&lt;/span&gt;，又&lt;span class=&quot;math inline&quot;&gt;\(T\sim B(n,p)\)&lt;/span&gt;，所以&lt;span class=&quot;math inline&quot;&gt;\(\mathbb{E}(T)=np\)&lt;/span&gt;，无偏充分估计量为&lt;/p&gt;
&lt;p&gt;\[\bar X=\frac{T}{n},\quad \mathbb{E}(\bar X)=p. \]&lt;/p&gt;
&lt;p&gt;可以用定义验证它是充分统计量。&lt;/p&gt;
&lt;p&gt;对于几何分布&lt;span class=&quot;math inline&quot;&gt;\(G(p)\)&lt;/span&gt;，注意到&lt;span class=&quot;math inline&quot;&gt;\(P(X=x)=(1-p)^{x-1}p\)&lt;/span&gt;，所以其联合概率函数是&lt;/p&gt;
&lt;p&gt;\[\mathbb{P}(X_1=x_1,\cdots,X_n=x_n)=p^{n}(1-p)^{\sum_{j=1}^n x_j-n}, \]&lt;/p&gt;
&lt;p&gt;所以其充分统计量依然是&lt;span class=&quot;math inline&quot;&gt;\(T=\sum_{j=1}^n X_j\)&lt;/span&gt;（这太常见了），而几何分布的均值是参数的倒数（就像指数分布一般），因此我们也要研究&lt;span class=&quot;math inline&quot;&gt;\(T\)&lt;/span&gt;的分布。&lt;/p&gt;
&lt;p&gt;从实际意义来探究可能会更好一些。如果把&lt;span class=&quot;math inline&quot;&gt;\(X\)&lt;/span&gt;看作一个连续多次二项分布的实验中，第一次成功所需实验的总次数，则&lt;span class=&quot;math inline&quot;&gt;\(X=k\)&lt;/span&gt;指的是前&lt;span class=&quot;math inline&quot;&gt;\(k-1\)&lt;/span&gt;次实验全部失败，第&lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt;次恰好成功。推广到&lt;span class=&quot;math inline&quot;&gt;\(T=\sum_{j=1}^n X_j\)&lt;/span&gt;，则&lt;span class=&quot;math inline&quot;&gt;\(T=k\)&lt;/span&gt;指的是前&lt;span class=&quot;math inline&quot;&gt;\(k-1\)&lt;/span&gt;次试验恰好有&lt;span class=&quot;math inline&quot;&gt;\(n-1\)&lt;/span&gt;次成功，第&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;次恰好又成功。基于此，我们可以给出&lt;span class=&quot;math inline&quot;&gt;\(T\)&lt;/span&gt;的概率分布列为&lt;/p&gt;
&lt;p&gt;\[\mathbb{P}(T=k)=C_{k-1}^{n-1}p^{n}(1-p)^{k-n},\quad k\ge n.\\ \sum_{k=n}^{\infty}C_{k-1}^{n-1}p^n(1-p)^{k-n}=1. \]&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;称具有如此分布列的随机变量&lt;span class=&quot;math inline&quot;&gt;\(T\)&lt;/span&gt;服从负二项分布&lt;span class=&quot;math inline&quot;&gt;\(T\sim NB(n,p)\)&lt;/span&gt;，又叫做帕斯卡分布。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;计算&lt;span class=&quot;math inline&quot;&gt;\(T\)&lt;/span&gt;的均值用到的trick与&lt;span class=&quot;math inline&quot;&gt;\(\Gamma\)&lt;/span&gt;分布时的一致，无非是&lt;span class=&quot;math inline&quot;&gt;\(\Gamma\)&lt;/span&gt;分布需要将&lt;span class=&quot;math inline&quot;&gt;\(\Gamma\)&lt;/span&gt;函数展开，这里将二项式系数展开罢了。但是&lt;span class=&quot;math inline&quot;&gt;\(1/T\)&lt;/span&gt;的均值却不好计算，所以难以得到其无偏估计。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;本文对离散型随机变量的参数估计作了小小的总结，可以看到离散型随机变量的参数估计与连续型随机变量的步骤大致相同，只是将联合密度函数写成了联合概率分布。我们也可以看到，对有些参数估计进行无偏调整比较容易，对有些参数估计则难以得到无偏估计。&lt;/p&gt;
&lt;p&gt;虽然我们已经讨论了常用的分布，但是分布是无穷无尽的，不可能对每种分布都详尽讨论；另外，即使是我们已经讨论过的分布，也可能衍生出奇奇怪怪的参数，比如均匀分布可能是&lt;span class=&quot;math inline&quot;&gt;\(U(\frac{1}{a},a)\)&lt;/span&gt;，对&lt;span class=&quot;math inline&quot;&gt;\(a\)&lt;/span&gt;作估计……等等。有什么方法可以对参数估计进行综合的讨论呢？下一篇文章将讨论常用的点估计方法。&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Wed, 03 Feb 2021 17:31:00 +0000</pubDate>
<dc:creator>江景景景页</dc:creator>
<og:description>泊松分布，泊松分布与指数分布的联系，离散分布参数估计。好短的篇幅。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jy333/p/14370561.html</dc:identifier>
</item>
<item>
<title>爬虫-selenium的使用 - Elite-Wang</title>
<link>http://www.cnblogs.com/Elite-Wang/p/14365056.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Elite-Wang/p/14365056.html</guid>
<description>&lt;p&gt;&lt;span&gt;Selenium是一个Web的自动化测试工具，最初是为网站自动化测试而开发的，可以按指定的命令自动操作，但是他需要与第三方浏览器结合在一起才能使用。如果我们把 Selenium和第三方浏览器（比如Chrome）结合在一起，就可以运行一个非常强大的网络爬虫了，这个爬虫可以处理 JavaScrip、Cookie、headers，以及任何我们真实用户需要做的事情。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;一、安装&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
sudo pip3 install selenium
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;二、快速入门&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; selenium &lt;span&gt;import&lt;/span&gt; webdriver &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 导入webdriver&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; selenium.webdriver.common.keys &lt;span&gt;import&lt;/span&gt; Keys &lt;span&gt;#&lt;/span&gt;&lt;span&gt;Keys`类提供键盘按键的支持，比如：RETURN, F1, ALT等&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; selenium.webdriver.chrome.options &lt;span&gt;import&lt;/span&gt; Options &lt;span&gt;#&lt;/span&gt;&lt;span&gt;导入Chrome浏览器配置选项类&lt;br/&gt;&lt;/span&gt;
options =&lt;span&gt; Options()
options.add_argument(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;--headless&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;无界面浏览器&lt;/span&gt;
options.add_argument(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;--disable-gpu&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 禁用gpu加速，规避bug&lt;/span&gt;
driver = webdriver.Chrome(options=options) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;创建浏览器对象&lt;/span&gt;
driver.get(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://www.baidu.com/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; get方法会打开一个页面&lt;/span&gt;
driver.implicitly_wait(10) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 通常打开页面后会等待一会，让页面加载&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt; (driver.title) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 打印页面标题 &quot;百度一下，你就知道&quot;&lt;/span&gt;
driver.save_screenshot(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;baidu.png&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 生成当前页面快照并保存&lt;/span&gt;
elem = driver.find_element_by_id(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;kw&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;根据id查找元素&lt;/span&gt;
elem.clear() &lt;span&gt;#&lt;/span&gt;&lt;span&gt;清空搜索框&lt;/span&gt;
elem.send_keys(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;中国&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;搜索中国&lt;/span&gt;
elem.send_keys(Keys.RETURN) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;按回车键&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(driver.page_source) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 打印网页渲染后的源代码&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(driver.get_cookies()) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取当前页面Cookie&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(driver.current_url) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取当前url&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; driver.close() 关闭当前页面，如果只有一个页面，会关闭浏览器&lt;/span&gt;
driver.quit() &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 关闭浏览器&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;三、查找元素&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h3&gt;查找单个元素（如果有多个匹配的元素，则返回第一个匹配到的元素）&lt;/h3&gt;
&lt;ul&gt;&lt;li readability=&quot;-2&quot;&gt;
&lt;h4&gt;find_element_by_id  通过id查找&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
login_form = driver.find_element_by_id(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;loginForm&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1.5&quot;&gt;
&lt;h4&gt;find_element_by_name  通过name查找&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
username = driver.find_element_by_name(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;username&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
password &lt;/span&gt;= driver.find_element_by_name(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;password&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;
&lt;h4&gt;find_element_by_xpath   通过xpath查找&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
login_form = driver.find_element_by_xpath(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//form[@id='loginForm']&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;
&lt;h4&gt;find_element_by_link_text   通过链接文本获取超链接元素&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
continue_link = driver.find_element_by_link_text(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Continue&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;
&lt;h4&gt;find_element_by_partial_link_text   通过部分链接文本获取超链接元素&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
continue_link = driver.find_element_by_partial_link_text(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Conti&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;
&lt;h4&gt;find_element_by_tag_name  通过标签名查找&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
heading1 = driver.find_element_by_tag_name(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;
&lt;h4&gt;find_element_by_class_name  通过类名查找&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
content = driver.find_element_by_class_name(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;content&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;
&lt;h4&gt;find_element_by_css_selector  通过css选择器查找&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
content = driver.find_element_by_css_selector(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;p.content&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) 
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;h3&gt;一次查找多个元素（返回的是元素列表）&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h4&gt;find_elements_by_name&lt;/h4&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h4&gt;find_elements_by_xpath&lt;/h4&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h4&gt;find_elements_by_link_text&lt;/h4&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h4&gt;find_elements_by_partial_link_text&lt;/h4&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h4&gt;find_elements_by_tag_name&lt;/h4&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h4&gt;find_elements_by_class_name&lt;/h4&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h4&gt;find_elements_by_css_selector&lt;/h4&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;h3&gt;此外还有两个私有方法find_element和find_elements&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; selenium.webdriver.common.by &lt;span&gt;import&lt;/span&gt;&lt;span&gt; By

driver.find_element(By.XPATH, &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;//button[text()=&quot;Some text&quot;]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
driver.find_elements(By.XPATH, &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;//button&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;By类的其他属性还包括：&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
ID = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
XPATH &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;xpath&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
LINK_TEXT &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;link text&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
PARTIAL_LINK_TEXT &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;partial link text&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
NAME &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
TAG_NAME &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tag name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
CLASS_NAME &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;class name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
CSS_SELECTOR &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;css selector&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;四、鼠标动作链&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;有些时候，我们需要再页面上模拟一些鼠标操作，比如双击、右击、拖拽甚至按住不动等，我们可以通过导入ActionChains 类来做到。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;五、页面下拉框处理&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;我们已经知道了怎样向文本框中输入文字，但是有时候我们会碰到&lt;code&gt;&amp;lt;select&amp;gt; &amp;lt;/select&amp;gt;&lt;/code&gt;标签的下拉框。直接点击下拉框中的选项不一定可行。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li readability=&quot;-0.5&quot;&gt;
&lt;h3&gt;WebDriver的支持类包括一个叫做 Select的类，他提供有用的方法处理这些内容:&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; selenium.webdriver.support.ui &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Select
select &lt;/span&gt;= Select(driver.find_element_by_name(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
select.select_by_index(index) &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;index索引从0开始&lt;/span&gt;
select.select_by_visible_text(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;text是在option标签文本的值，是显示在下拉框的值&lt;/span&gt;
select.select_by_value(value) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;value是option标签的一个属性值，并不是显示在下拉框中的值&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h3&gt;取消选择&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
select.deselect_all()
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;六、弹窗处理&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;Selenium WebDriver 内置了对处理弹出对话框的支持。在你的某些动作之后可能会触发弹出对话框，你可以像下面这样访问对话框:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
alert = driver.switch_to.alert() &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 切换进alert&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(alert.text())&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 打印alert文本内容&lt;/span&gt;
alert.accept()&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 关闭弹框(接受)&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; alert.dismiss() 关闭弹窗(拒绝)&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; alert.send_keys('selenium') 向弹窗里输入内容&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;七、页面切换&lt;/h2&gt;
&lt;h3&gt;浏览器一般会打开多个窗口，切换窗口的方法如下：&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
driver.switch_to.window(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;窗口名&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;或者你也可以在”switch_to_window()”中使用”窗口句柄”来打开它， 知道了这些，你就可以迭代所有已经打开的窗口了:&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;for&lt;/span&gt; handle &lt;span&gt;in&lt;/span&gt;&lt;span&gt; driver.window_handles:
    driver.switch_to_window(handle)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;八、访问浏览器历史记录&lt;/h2&gt;
&lt;ul&gt;&lt;li readability=&quot;-2&quot;&gt;
&lt;h3&gt;在浏览历史中前进和后退你可以使用:&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;driver.forward()
driver.back()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;九、cookies&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h3&gt;获取所有cookies&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
driver.get_cookies()
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;
&lt;h3&gt;删除某个cookie&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
driver.delete_cookie(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CookieName&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;
&lt;h3&gt;删除所有cookies&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
driver.delete_all_cookies()
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;十、页面等待(Waits)&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;现在的大多数的Web应用程序是使用Ajax技术。当一个页面被加载到浏览器时，该页面内的元素可以在不同的时间点被加载。这使得定位元素变得困难，如果元素不再页面之中，会抛出ElementNotVisibleException异常。使用 waits, 我们可以解决这个问题。waits提供了一些操作之间的时间间隔，主要是定位元素或针对该元素的任何其他操作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Selenium Webdriver 提供两种类型的waits：隐式和显式。显式等待会让WebDriver等待满足一定的条件以后再进一步的执行。而隐式等待让Webdriver等待一定的时间后再才是查找某元素。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h3&gt;显示等待&lt;/h3&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h3&gt;隐氏等待&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h4&gt;隐式等待比较简单，就是简单地设置一个等待时间，单位为秒。&lt;/h4&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;h4&gt;如果不设置，默认等待时间为0秒。&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; selenium &lt;span&gt;import&lt;/span&gt;&lt;span&gt; webdriver

driver &lt;/span&gt;=&lt;span&gt; webdriver.Firefox()
driver.implicitly_wait(&lt;/span&gt;10) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; seconds&lt;/span&gt;
driver.get(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://somedomain/url_that_delays_loading&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
myDynamicElement &lt;/span&gt;= driver.find_element_by_id(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;myDynamicElement&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;十一、执行JS&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;可以在加载完成的页面上使用execute_script方法执行js。 比如调用javascript API滚动页面到底部或页面的任何位置&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
driver.execute_script(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;window.scrollTo(0, document.body.scrollHeight);&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;十二、传文件到文件上传控件&lt;/h2&gt;
&lt;p&gt; &lt;span&gt;选择 &amp;lt;input type=&quot;file&quot;&amp;gt; 元素并且调用 send_keys() 方法传入要上传文件的路径，可以 是对于测试脚本的相对路径，也可以是绝对路径。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 03 Feb 2021 17:22:00 +0000</pubDate>
<dc:creator>Elite-Wang</dc:creator>
<og:description>Selenium是一个Web的自动化测试工具，最初是为网站自动化测试而开发的，可以按指定的命令自动操作，但是他需要与第三方浏览器结合在一起才能使用。如果我们把 Selenium和第三方浏览器（比如Ch</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Elite-Wang/p/14365056.html</dc:identifier>
</item>
<item>
<title>Python实现量子态采样 - 陆言君</title>
<link>http://www.cnblogs.com/dechinphy/p/state.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dechinphy/p/state.html</guid>
<description>&lt;p&gt;量子态是用于表征一个量子系统所处状态的物理量，在矩阵力学中我们可以将其视为一个普通的矢量，在概率学上我们又可以将其转换为概率分布函数。在获得一个概率分布函数之后，我们自然可以对其进行采样，这就完成了对一个量子系统进行模拟采样的过程。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;188.00983651981&quot;&gt;

&lt;p&gt;在前面一篇&lt;a href=&quot;https://www.cnblogs.com/dechinphy/p/magic.html&quot; target=&quot;_blank&quot;&gt;量子系统模拟的博客&lt;/a&gt;中，我们介绍了使用python去模拟一个量子系统演化的过程。当我们尝试理解量子态和量子门操作时，可以通过其矩阵形式的运算来描述量子态演化的过程：&lt;/p&gt;
&lt;p&gt;\[\left|\psi_t\right&amp;gt;=e^{-iHt}\left|\psi_0\right&amp;gt; \]&lt;/p&gt;
&lt;p&gt;这里的狄拉克标记符号和矩阵指数运算，在这篇&lt;a href=&quot;https://www.cnblogs.com/dechinphy/p/magic.html&quot; target=&quot;_blank&quot;&gt;博客&lt;/a&gt;中同样进行了介绍。我们可以简单的将该过程理解为：一个矩阵和一个矢量进行了一个点乘操作，得到了一个更新后的态矢量：&lt;/p&gt;
&lt;p&gt;\[\overrightarrow{x'}=\textbf{A}\overrightarrow{x} \]&lt;/p&gt;
&lt;p&gt;在量子计算的框架下，由于通用的量子门操作都是酉矩阵(Unitary)，因此不论是更新前还是更新后的操作，得到的态矢量总是归一化的：&lt;/p&gt;
&lt;p&gt;\[\left&amp;lt;\psi^*|\psi\right&amp;gt;=1 \]&lt;/p&gt;
&lt;p&gt;因此，在本文中考虑采样时，为了方便计算，我们将态矢量先转换为概率幅矢量，再进行采样。概率幅矢量的特征表现为：&lt;/p&gt;
&lt;p&gt;\[\sum_{i=0}^{2^n-1}p_i=1 \]&lt;/p&gt;
&lt;p&gt;这里的&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;就表示该量子系统的比特数，一个量子系统的量子态元素个数，或者是概率幅的元素个数是比特数的指数倍数(跟量子比特所占用的能级数有关，最常用的是两能级系统，因此为&lt;span class=&quot;math inline&quot;&gt;\(2^n\)&lt;/span&gt;个元素个数)。&lt;/p&gt;

&lt;p&gt;在上一个章节中所表述的是量子态的形式，在转换为概率幅矢量之后，其每一个元素都代表获取到当前二进制量子态的概率。这样我们获得一个量子态的态矢量或者概率幅矢量时，其实就是获得了该系统的概率分布。通过该概率分布，我们可以进行蒙特卡罗模拟：先在&lt;span class=&quot;math inline&quot;&gt;\([0,1)\)&lt;/span&gt;上面进行均匀随机撒点，同时将概率幅矢量转换为其对应的累积分布图，最后计算随机撒的点对应的累积分布图的位置，即可获得当前概率下的模拟采样，具体实现请参考如下示例。&lt;/p&gt;

&lt;p&gt;我们先假设一个概率幅的分布，再对其进行采样。&lt;/p&gt;
&lt;h2 id=&quot;给定一个指数下降的概率幅分布&quot;&gt;给定一个指数下降的概率幅分布&lt;/h2&gt;
&lt;p&gt;这里我们先给定一个&lt;span class=&quot;math inline&quot;&gt;\(e^{-x}\)&lt;/span&gt;的概率分布函数，注意我们采取的是概率幅，因此要对其进行归一化的话只需要计算&lt;span class=&quot;math inline&quot;&gt;\(y_i=\frac{y_i}{\sum_jy_j}\)&lt;/span&gt;即可。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;import numpy as np
import matplotlib.pyplot as plt

plt.figure()
x=[i for i in range(32)]
y=[np.exp(-i) for i in range(32)]
y/=sum(y)
plt.title('Distribution of Quantum States')
plt.xlabel('Quantum States')
plt.ylabel('Probabilities')
plt.xticks(x,('0'*(7-len(str(bin(i))))+str(bin(i)).split('b')[1] for i in range(32)),rotation=70)
plt.plot(x,y,color='black')
plt.show()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2277440/202102/2277440-20210203234912983-459534509.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;在这个案例中我们还使用了一些&lt;code&gt;matplotlib&lt;/code&gt;的特殊绘图技巧，这里我们不展开介绍，后续会单独写一篇文章来分析常用的matploblib画图姿势。&lt;/p&gt;
&lt;h2 id=&quot;均匀随机数&quot;&gt;均匀随机数&lt;/h2&gt;
&lt;p&gt;这里我们直接使用python的&lt;code&gt;random&lt;/code&gt;函数，就可以生成&lt;span class=&quot;math inline&quot;&gt;\([0,1)\)&lt;/span&gt;之间的均匀随机数，撒点数量越多，呈现的均匀分布的结果就越明显。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;import random
import matplotlib.pyplot as plt

x = [random.random() for i in range(1000)]
y = [random.random() for i in range(1000)]
plt.figure()
plt.plot(x,y,'.',color='red')
plt.show()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2277440/202102/2277440-20210203235627143-1247718895.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;累积分布函数&quot;&gt;累积分布函数&lt;/h2&gt;
&lt;p&gt;所谓的累积分布函数，其实就是将前面获取到的概率幅矢量做一个累积叠加的操作，对应的计算方法如下：&lt;/p&gt;
&lt;p&gt;\[y_i=\sum_{j&amp;lt;=i}y_j \]&lt;/p&gt;
&lt;p&gt;我们很容易可以预测，在累积分布函数的终点一定是1,这是因为前面所定义的&lt;span class=&quot;math inline&quot;&gt;\(\sum_{i=0}^{2^n-1}p_i=1\)&lt;/span&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;import numpy as np
import matplotlib.pyplot as plt

plt.figure()
x=[i for i in range(32)]
y=[np.exp(-i) for i in range(32)]
y/=sum(y)
for i in range(len(y)-1):
    y[i+1]+=y[i]
plt.title('Cumulative Distribution Function')
plt.xlabel('Quantum States')
plt.ylabel('Cumulative Probabilities')
plt.xticks(x,('0'*(7-len(str(bin(i))))+str(bin(i)).split('b')[1] for i in range(32)),rotation=70)
plt.plot(x,y,color='black')
plt.show()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2277440/202102/2277440-20210204000524576-500451471.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;量子态采样&quot;&gt;量子态采样&lt;/h2&gt;
&lt;p&gt;这里我们将概率分布函数和模拟采样结果直接放在一起进行对比：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;import numpy as np
import matplotlib.pyplot as plt
import random

plt.figure()
x=[i for i in range(32)]
y=[np.exp(-i) for i in range(32)]
y/=sum(y)
plt.plot(x,y,color='black',label='Real Distribution')
for i in range(len(y)-1):
    y[i+1]+=y[i]

sp=np.zeros(32)
for i in range(50):
    r = random.random()
    for j in range(32):
        if y[j]&amp;gt;r:
            sp[j]+=1/50
            break

plt.title('Sampling Results with 50 times')
plt.xlabel('Quantum States')
plt.ylabel('Probabilities')
plt.xticks(x,('0'*(7-len(str(bin(i))))+str(bin(i)).split('b')[1] for i in range(32)),rotation=70)
plt.plot(x,sp,color='red',label='Simulated Sampling')
plt.legend()
plt.show()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2277440/202102/2277440-20210204001535029-1364044933.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;这里我们可以看到结果已经是非常的接近了，如果我们继续提高采样次数，结果当然会更加接近真实分布：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2277440/202102/2277440-20210204001715791-1206325838.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;因此，在获得概率幅之后，我们可以根据场景对精度的要求，对该概率幅进行采样，到这里就完成了所有的功能实现。&lt;/p&gt;

&lt;p&gt;除了单调函数外，这里我们再考虑另外一种形式的分布：正弦概率分布函数：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;import numpy as np
import matplotlib.pyplot as plt

plt.figure()
x=[i for i in range(32)]
y=[np.sin(i/2)+1 for i in range(32)]
y/=sum(y)
plt.title('Distribution of Quantum States')
plt.xlabel('Quantum States')
plt.ylabel('Probabilities')
plt.xticks(x,('0'*(7-len(str(bin(i))))+str(bin(i)).split('b')[1] for i in range(32)),rotation=70)
plt.plot(x,y,color='black')
plt.show()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2277440/202102/2277440-20210204002125100-1681007589.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;由于上面一个示例我们已经介绍完成了基本的操作流程和原理，这里我们就不过多的赘述，直接展示累积分布函数和最终的模拟采样效果：&lt;/p&gt;
&lt;h2 id=&quot;累积分布函数-1&quot;&gt;累积分布函数&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;import numpy as np
import matplotlib.pyplot as plt

plt.figure()
x=[i for i in range(32)]
y=[np.sin(i/2)+1 for i in range(32)]
y/=sum(y)
for i in range(len(y)-1):
    y[i+1]+=y[i]
plt.title('Cumulative Distribution Function')
plt.xlabel('Quantum States')
plt.ylabel('Cumulative Probabilities')
plt.xticks(x,('0'*(7-len(str(bin(i))))+str(bin(i)).split('b')[1] for i in range(32)),rotation=70)
plt.plot(x,y,color='black')
plt.show()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2277440/202102/2277440-20210204002344662-1754440908.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;模拟采样结果&quot;&gt;模拟采样结果&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;import numpy as np
import matplotlib.pyplot as plt
import random

plt.figure()
x=[i for i in range(32)]
y=[np.sin(i/2)+1 for i in range(32)]
y/=sum(y)
plt.plot(x,y,color='black',label='Real Distribution')
for i in range(len(y)-1):
    y[i+1]+=y[i]

sp=np.zeros(32)
for i in range(3000):
    r = random.random()
    for j in range(32):
        if y[j]&amp;gt;r:
            sp[j]+=1/3000
            break

plt.title('Sampling Results with 3000 times')
plt.xlabel('Quantum States')
plt.ylabel('Probabilities')
plt.xticks(x,('0'*(7-len(str(bin(i))))+str(bin(i)).split('b')[1] for i in range(32)),rotation=70)
plt.plot(x,sp,color='red',label='Simulated Sampling')
plt.legend()
plt.show()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2277440/202102/2277440-20210204002538170-340387408.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;对一个量子态矢量进行采样的过程，主要可以分为三个步骤：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;计算量子态对应的概率分布函数(矢量);&lt;/li&gt;
&lt;li&gt;计算量子态对应的累积分布函数(矢量);&lt;/li&gt;
&lt;li&gt;均匀随机采样，映射到累积分布函数中所对应的量子态，在足够多的采样次数下就可以完整的模拟出原始的量子态分布。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;本文首发链接为：&lt;a href=&quot;https://www.cnblogs.com/dechinphy/p/state.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/dechinphy/p/state.html&lt;/a&gt;&lt;br/&gt;作者ID：DechinPhy&lt;br/&gt;更多原著文章请参考：&lt;a href=&quot;https://www.cnblogs.com/dechinphy/&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/dechinphy/&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Wed, 03 Feb 2021 16:31:00 +0000</pubDate>
<dc:creator>陆言君</dc:creator>
<og:description>量子态是用于表征一个量子系统所处状态的物理量，在矩阵力学中我们可以将其视为一个普通的矢量，在概率学上我们又可以将其转换为概率分布函数。在获得一个概率分布函数之后，我们自然可以对其进行采样，这就完成了对</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/dechinphy/p/state.html</dc:identifier>
</item>
<item>
<title>四. SpringCloud负载均衡与调用 - MPolaris</title>
<link>http://www.cnblogs.com/mpolaris/p/14370486.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mpolaris/p/14370486.html</guid>
<description>&lt;h4 id=&quot;1-ribbon概述&quot;&gt;1. Ribbon概述&lt;/h4&gt;
&lt;h5 id=&quot;11-ribbon是什么&quot;&gt;1.1 Ribbon是什么&lt;/h5&gt;
&lt;p&gt;SpringCloud Ribbon是基于Netflix Ribbon实现的一套客户端，是负载均衡的工具。&lt;/p&gt;
&lt;p&gt;Ribbon是Netflix发布的开源项目，主要功能是&lt;strong&gt;提供客户端的软件复杂均衡算法和服务调用&lt;/strong&gt;。Ribbon客户端组件提供一系列完整的配置项如连接超时、重试等。简单的说，就是在配置文件中列出Load Balancer（负载均衡简称LB）后面所有的机器，Ribbon会自动的帮助你基于某种规则（如简单轮询，随机连接等）去连接这些机器。也可以使用Ribbon实现自定义的负载均衡算法。&lt;/p&gt;
&lt;h5 id=&quot;12-ribbon能做什么&quot;&gt;1.2 Ribbon能做什么&lt;/h5&gt;
&lt;p&gt;主要是负载均衡（LB）：所谓负载均衡，简单的说就是将用户的请求平摊的分配到多个服务上，从而达到系统的HA（High Available高可用），常见的负载均衡有软件Nginx、LVS，硬件F5等。&lt;/p&gt;
&lt;p&gt;Ribbon本地负载均衡客户端和Nginx服务端负载均衡的区别：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Nginx是服务器负载均衡，客户端所有请求都会交给Nginx，然后由Nginx实现转发请求，即负载均衡是由服务端实现的。&lt;/li&gt;
&lt;li&gt;Ribbon是本地负载均衡，在调用微服务接口时候，会在注册中心上获取注册信息服务列表之后缓存到JVM本地，从而在本地实现RPC远程服务调用技术。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;负载均衡又分为两类，分别可以对应于Nginx和Ribbon：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;集中式LB：即在服务的消费方和提供方之间使用独立的LB设施（可以是硬件，如F5，也可以是软件，如Nginx），由该设施负责把访问请求通过某种策略转发至服务的提供方。&lt;/li&gt;
&lt;li&gt;进程内LB：将LB逻辑集成到消费方，消费方从服务注册中心获知有哪些地址可用，然后自己再从这些地址中选择出一个合适的服务器，&lt;span&gt;Ribbon就属于进程内LB，&lt;/span&gt;它只是一个类库，集成于消费方进程，消费方通过它来获取到服务提供方的地址。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Ribbon实际上就是&lt;span&gt;负载均衡 + RestTemplate调用&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&quot;2-ribbon使用案例&quot;&gt;2. Ribbon使用案例&lt;/h4&gt;
&lt;h5 id=&quot;21-架构说明&quot;&gt;2.1 架构说明&lt;/h5&gt;
&lt;p&gt;Ribbon其实就是一个负载均衡的客户端组件，他可以和其他所需请求的客户端结合使用，和eureka结合只是其中的一个实例。Ribbon在工作的时候分两步：&lt;/p&gt;
&lt;p&gt;其中Ribbon提供了多种的负载均衡策略，如轮询、随机和根据响应时间加强等。&lt;/p&gt;
&lt;img src=&quot;https://gitee.com/mp2333/blog-img/raw/master/SpringCloud/20210128235245.png&quot; alt=&quot;image-20210128235245749&quot;/&gt;&lt;h5 id=&quot;22-pomxml&quot;&gt;2.2 pom.xml&lt;/h5&gt;
&lt;p&gt;在POM文件中我们引入了如下依赖：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;!--eureka-client--&amp;gt;
&amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-eureka-client&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;点开该依赖的源码，我们发现事实上该依赖内部已经引入了Ribbon，其引入Ribbon的源码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-ribbon&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;2.2.1.RELEASE&amp;lt;/version&amp;gt;
    &amp;lt;scope&amp;gt;compile&amp;lt;/scope&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们在Maven的依赖中也可以看到，在引入 &lt;strong&gt;spring-cloud-starter-netflix-eureka-client&lt;/strong&gt; 的同时我们就已经引入了 **spring-cloud-starter-netflix-ribbon **，所以我们没必要单独添加Ribbon的依赖。&lt;/p&gt;
&lt;img src=&quot;https://gitee.com/mp2333/blog-img/raw/master/SpringCloud/20210128231400.png&quot; alt=&quot;image-20210128231128616&quot;/&gt;&lt;h5 id=&quot;13-resttemplate使用&quot;&gt;1.3 RestTemplate使用&lt;/h5&gt;
&lt;p&gt;RestTemplate官方说明可以在&lt;a href=&quot;https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/client/RestTemplate.html&quot; target=&quot;_blank&quot;&gt;RestTemplate官方API&lt;/a&gt;查看，下面简要说明其主要方法&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;getForObject方法&lt;/code&gt;：返回对象为响应体数据转化成的对象，基本上可以理解为Json对象。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;getForEntity方法&lt;/code&gt;：返回对象为ResponseEntity对象，包含了响应中的一些重要信息，比如响应头、响应状态码、响应体等。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@RestController
@Slf4j
@RequestMapping(&quot;/consumer&quot;)
public class OrderController {
    @Resource
    private RestTemplate restTemplate;

    // private static final String PAYMENT_URL = &quot;http://localhost:8001&quot;;
    private static final String PAYMENT_SRV = &quot;http://CLOUD-PAYMENT-SERVICE&quot;;

    @GetMapping(&quot;/payment/get/{id}&quot;)
    public CommonResult&amp;lt;Payment&amp;gt; getPayment(@PathVariable(&quot;id&quot;) Long id) {
        return restTemplate.getForObject(PAYMENT_SRV
                + &quot;/payment/get/&quot;
                + id, CommonResult.class);
    }

    @GetMapping(&quot;/payment/getForEntity/{id}&quot;)
    public CommonResult&amp;lt;Payment&amp;gt; getPayment2(@PathVariable(&quot;id&quot;) Long id) {
        ResponseEntity&amp;lt;CommonResult&amp;gt; entity =
                restTemplate.getForEntity(PAYMENT_SRV
                 + &quot;/payment/get/&quot; + id, CommonResult.class);
        if (entity.getStatusCode().is2xxSuccessful()) {
            log.info(&quot;===&amp;gt; &quot; + entity.getStatusCode()
                  + &quot;\t&quot; + entity.getHeaders());
            return entity.getBody(); //返回请求体
        } else {
            return new CommonResult&amp;lt;&amp;gt;(444, &quot;操作失败&quot;);
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在后台控制台也输出了状态码和请求头的如下日志：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;===&amp;gt; 200 OK        [Content-Type:&quot;application/json&quot;, Transfer-Encoding:&quot;chunked&quot;, Date:&quot;Thu, 28 Jan 2021 15:44:50 GMT&quot;, Keep-Alive:&quot;timeout=60&quot;, Connection:&quot;keep-alive&quot;]
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;3-ribbon核心组件irule接口&quot;&gt;3. Ribbon核心组件IRule接口&lt;/h4&gt;
&lt;h5 id=&quot;31-irule理解&quot;&gt;3.1 IRule理解&lt;/h5&gt;
&lt;p&gt;它可以根据特定算法从服务列表中选取一个要访问的服务&lt;/p&gt;
&lt;p&gt;IRule是一个接口，其源码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.netflix.loadbalancer;

/**
 * Interface that defines a &quot;Rule&quot; for a LoadBalancer. A Rule can be thought of
 * as a Strategy for loadbalacing. Well known loadbalancing strategies include
 * Round Robin, Response Time based etc.
 * 
 * @author stonse
 * 
 */
public interface IRule{
    /*
     * choose one alive server from lb.allServers or
     * lb.upServers according to key
     * 
     * @return choosen Server object. NULL is returned if none
     *  server is available 
     */

    public Server choose(Object key);
    
    public void setLoadBalancer(ILoadBalancer lb);
    
    public ILoadBalancer getLoadBalancer();    
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以下是IRule接口的部分实现，这些实现分别对应了若干负载均衡算法&lt;/p&gt;
&lt;img src=&quot;https://gitee.com/mp2333/blog-img/raw/master/SpringCloud/20210128235959.png&quot; alt=&quot;image-20210128235959015&quot;/&gt;&lt;p&gt;以下简要说明7种主要的负载均衡算法，这些负载均衡算法均是抽象类&lt;code&gt;com.netflix.loadbalancer.AbstractLoadBalancerRule&lt;/code&gt; 的实现，而给抽象类实现了IRule接口：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;com.netflix.loadbalancer.RoundRobinRule&lt;/code&gt;：轮询，为&lt;strong&gt;默认的负载均衡算法&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;com.netflix.loadbalancer.RandomRule&lt;/code&gt;：随机&lt;/li&gt;
&lt;li&gt;&lt;code&gt;com.netflix.loadbalancer.RetryRule&lt;/code&gt;：先按照RoundRobinRule（轮询）的策略获取服务，如果获取服务失败则在指定时间内进行重试，获取可用的服务&lt;/li&gt;
&lt;li&gt;&lt;code&gt;com.netflix.loadbalancer.WeightedResponseTimeRule&lt;/code&gt;：对RoundRobinRule的扩展，响应速度越快的实例选择权重越大，越容易被选择。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;com.netflix.loadbalancer.BestAvailableRule&lt;/code&gt;：先过滤掉由于多次访问故障而处于断路器跳闸状态的服务，然后选择一个并发量最小的服务&lt;/li&gt;
&lt;li&gt;&lt;code&gt;com.netflix.loadbalancer.AvailabilityFilteringRule&lt;/code&gt;：先过滤掉故障实例，再选择并发较小的实例&lt;/li&gt;
&lt;li&gt;&lt;code&gt;com.netflix.loadbalancer.ZoneAvoidanceRule&lt;/code&gt;：复合判断Server所在区域的性能和Server的可用性选择服务器&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;32-如何替换负载均衡算法&quot;&gt;3.2 如何替换负载均衡算法&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;服务消费者80添加轮询算法配置类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先我们应该明确是服务消费方采用轮询算法来访问同一服务提供方的不同微服务实例，所以我们应该在服务消费方80方的微服务中添加轮询算法配置类。&lt;/p&gt;
&lt;p&gt;在添加配置类时，有必须要注意的点，就是官方文档明确给出了警告：&lt;span&gt;这个自定义的轮询算法配置类不能放在&lt;code&gt;@ComponentScan&lt;/code&gt;注解所扫描的当前包下以及子包下，否则自定义的这个配置类就会被所有Ribbon客户端所共享，就达不到特殊化定制的目的了。&lt;/span&gt;换句话说，如果这个配置类我们能够被&lt;code&gt;@ComponentScan&lt;/code&gt;注解扫描到，那么访问所有的微服务提供方的具体实例时，我们都会采取配置类中的算法，如果要特殊化定制 - 即指定访问某些微服务提供方时采用配置的轮询算法，那么我们就应该使这个配置类让&lt;code&gt;@ComponentScan&lt;/code&gt;注解扫描不到，我们知道在主启动类的&lt;code&gt;@SpringBootApplication&lt;/code&gt;注解中，其实这个注解包含了&lt;code&gt;@SpringBootConfiguration&lt;/code&gt; 、&lt;code&gt;@EnableAutoConfiguration&lt;/code&gt;、&lt;code&gt;@ComponentScan&lt;/code&gt;这三个注解，所以我们写的轮询算法配置类不能和主启动类在同一个包下，所以我们需要建新的包，实现定制轮询算法的配置类：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.polaris.myrule;

/**
 * @author polaris
 */
@Configuration
public class MySelfRule {

    @Bean
    public IRule myRule() {
        return new RandomRule(); //定义随机负载均衡算法
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;包结构的内容如下，我们可以看到，轮询算法配置类在主启动类的&lt;code&gt;@ComponentScan&lt;/code&gt;扫描不到的包下：&lt;/p&gt;
&lt;img src=&quot;https://gitee.com/mp2333/blog-img/raw/master/SpringCloud/20210129000859.png&quot; alt=&quot;image-20210129000859823&quot;/&gt;&lt;p&gt;&lt;strong&gt;服务消费者80主启动类中添加&lt;code&gt;@RibbonClient&lt;/code&gt;注解&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@SpringBootApplication
@EnableEurekaClient
//访问的微服务为CLOUD-PAYMENT-SERVICE，采用配置文件中的轮询算法
@RibbonClient(name = &quot;CLOUD-PAYMENT-SERVICE&quot;, configuration = MySelfRule.class)
public class OrderMain {
    public static void main(String[] args) {
        SpringApplication.run(OrderMain80.class);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;测试发现我们用服务消费方访问服务提供方的微服务时，8001和8002不再交替轮询访问，而是随机访问。&lt;/p&gt;
&lt;h4 id=&quot;4-ribbon负载均衡算法&quot;&gt;4. Ribbon负载均衡算法&lt;/h4&gt;
&lt;h5 id=&quot;41-默认负载均衡算法（轮询）原理&quot;&gt;4.1 默认负载均衡算法（轮询）原理&lt;/h5&gt;
&lt;p&gt;轮询负载均衡算法原理：&lt;span&gt;Rest接口第几次请求数 % 服务器集群总数量 = 实际调用服务器位置下标，&lt;/span&gt; 每次服务重启后Rest接口计数从1开始。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;List&amp;lt;ServiceInstance&amp;gt; instances = discoveryClient.getInstances(&quot;CLOUD-PAYMENT-SERVICE&quot;)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;根据服务方的服务名，获取其所有实例，如有以下实例：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th/&gt;
&lt;th&gt;List[0]&lt;/th&gt;
&lt;th&gt;List[1]&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;服务名&lt;/td&gt;
&lt;td&gt;payment8001&lt;/td&gt;
&lt;td&gt;payment8002&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;服务地址&lt;/td&gt;
&lt;td&gt;127.0.0.1:8001&lt;/td&gt;
&lt;td&gt;127.0.0.1:8002&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;这两个实例组合成一个集群，共2台机器，集群总数为2，按照轮询负载均衡算法原理：&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;请求总数为1时，1 % 2 = 1，对应下标位置是1，获得服务地址127.0.0.1:8001&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;请求总数为2时，2 % 2 = 0，对应下标位置是0，获得服务地址127.0.0.1:8002&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;请求总数为3时，3 % 2 = 1，对应下标位置是1，获得服务地址127.0.0.1:8001&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;...&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;42-轮询源码分析&quot;&gt;4.2 轮询源码分析&lt;/h5&gt;
&lt;p&gt;将&lt;code&gt;com.netflix.loadbalancer.RoundRobinRule&lt;/code&gt;源码的负载均衡算法部分分析如下（代码中标注了中文注释）：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.netflix.loadbalancer;

/**
 * The most well known and basic load balancing strategy, i.e. Round Robin Rule.
 */
public class RoundRobinRule extends AbstractLoadBalancerRule {

        //...

    public Server choose(ILoadBalancer lb, Object key) {
        if (lb == null) {
            log.warn(&quot;no load balancer&quot;);
            return null;
        }

        Server server = null;
        int count = 0;
        while (server == null &amp;amp;&amp;amp; count++ &amp;lt; 10) {
            //获得还活着的健康的服务实例（机器）即可达的，也就是Status为up的实例
            List&amp;lt;Server&amp;gt; reachableServers = lb.getReachableServers();
            //获取所有服务实例，无论是死是活，只要注册进服务中心即可
            List&amp;lt;Server&amp;gt; allServers = lb.getAllServers();
            //Status为up的服务实例数量
            int upCount = reachableServers.size();
            //所有服务实例的数量，对应上述原理分析中的服务器集群总数量
            int serverCount = allServers.size();

            //如果没有可达的服务实例的话，直接报警告
            if ((upCount == 0) || (serverCount == 0)) {
                log.warn(&quot;No up servers available from load balancer: &quot; + lb);
                return null;
            }

            //调用服务器位置下标 = incrementAndGetModulo(服务器集群总数)
            int nextServerIndex = incrementAndGetModulo(serverCount);
            server = allServers.get(nextServerIndex);//根据下标获取服务实例

            if (server == null) {
                /* Transient. */
                Thread.yield();
                continue;
            }

            if (server.isAlive() &amp;amp;&amp;amp; (server.isReadyToServe())) {
                return (server);
            }

            // Next.
            server = null;
        }

        if (count &amp;gt;= 10) {
            log.warn(&quot;No available alive servers after 10 tries from load balancer: &quot;
                    + lb);
        }
        return server;
    }

    /**
     * Inspired by the implementation of {@link AtomicInteger#incrementAndGet()}.
     *
     * @param modulo The modulo to bound the value of the counter.
     * @return The next value.
     */
    private int incrementAndGetModulo(int modulo) {
        for (;;) {
            int current = nextServerCyclicCounter.get();
            int next = (current + 1) % modulo;
            if (nextServerCyclicCounter.compareAndSet(current, next))
                return next;
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;43-自己实现轮询负载均衡算法&quot;&gt;4.3 自己实现轮询负载均衡算法&lt;/h5&gt;
&lt;p&gt;首先我们将服务注册中心（7001/7002构成集群）启动，然后在&lt;strong&gt;服务提供方8001/8002中的Controller中添加功能&lt;/strong&gt;，用来一会儿测试服务消费方80来轮询访问&lt;strong&gt;CLOUD-PAYMENT-SERVICE&lt;/strong&gt;服务：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@GetMapping(&quot;/payment/lb&quot;)
public String getPaymentLB(){
        return serverPort;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;服务提供方的这个方法就是简单的在页面输出自己的端口号，也就是我们可以在页面区分访问的&lt;strong&gt;CLOUD-PAYMENT-SERVICE&lt;/strong&gt;服务到底对应的是8001实例还是8002实例。&lt;/p&gt;
&lt;p&gt;启动8001/8002，将两个服务实例注册进服务注册中心后，我们再改造服务消费方80服务，分为以下四步：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先我们先让RestTemplate失去Ribbon中的负载均衡能力，取消掉&lt;code&gt;@LoadBalanced&lt;/code&gt;注解即可：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Configuration
public class ApplicationContextConfig {
    @Bean
//    @LoadBalanced//使用该注解赋予RestTemplate负载均衡的能力
    public RestTemplate getRestTemplate() {
        return new RestTemplate();
    }
}
//applicationContext.xml &amp;lt;bean id=&quot;&quot; class=&quot;&quot;&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;然后编写自己的负载均衡接口：&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;给接口定义了方法&lt;code&gt;instances&lt;/code&gt;用于在服务提供方服务的所有服务实例中选择一个具体实例。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public interface LoadBalancer {
    /**
     * 从服务列表中用负载均衡算法选择出具体的实例
     * @param serviceInstances 服务列表
     * @return
     */
    ServiceInstance instances(List&amp;lt;ServiceInstance&amp;gt; serviceInstances);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;用轮询负载均衡算法实现负载均衡接口：&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;RoundRobinRule源码中用&lt;code&gt;for(;;)&lt;/code&gt;实现的自旋锁，这里我们用&lt;code&gt;do{} while();&lt;/code&gt;实现自旋锁。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Component
public class MyLB implements LoadBalancer {

    private AtomicInteger atomicInteger = new AtomicInteger(0);

    public final int getAndIncrement() {
        int current;
        int next;
        //自旋锁
        do {
            current = this.atomicInteger.get(); //初始值为0
            next = current &amp;gt;= 2147483647 ? 0 : current + 1; //最大整数
        } while (!this.atomicInteger.compareAndSet(current, next));
        System.out.println(&quot;===&amp;gt; 访问次数next:&quot; + next);
        return next;
    }

    /**
     * 从服务列表中用轮询负载均衡算法选择出具体的实例
     * Rest接口第几次请求数 % 服务器集群总数量 = 实际调用服务器位置下标
     *
     * @param serviceInstances 服务列表
     * @return
     */
    @Override
    public ServiceInstance instances(List&amp;lt;ServiceInstance&amp;gt; serviceInstances) {
        int index = getAndIncrement() % serviceInstances.size();
        return serviceInstances.get(index);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;最后我们在80服务的Controller中添加方法：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@RestController
@Slf4j
@RequestMapping(&quot;/consumer&quot;)
public class OrderController {
    @Resource
    private RestTemplate restTemplate;

    @Resource
    private LoadBalancer loadBalancer;

    @Resource
    private DiscoveryClient discoveryClient;

    @GetMapping(&quot;payment/lb&quot;)
    public String getPaymentLB() {
        //获取服务提供方所有的服务实例
        List&amp;lt;ServiceInstance&amp;gt; instances = discoveryClient.getInstances(&quot;CLOUD-PAYMENT-SERVICE&quot;);
        if (instances == null || instances.size() &amp;lt;= 0) {
            return null;
        }
        //采用自己实现的轮询负载均衡算法选择具体实例
        ServiceInstance serviceInstance = loadBalancer.instances(instances);
        URI uri = serviceInstance.getUri();
        return restTemplate.getForObject(uri + &quot;/payment/lb&quot;, String.class);
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在浏览器中输入http://localhost/consumer/payment/lb，也就是80端口的服务消费方采用我们自己编写的轮询负载均衡算法访问&lt;strong&gt;CLOUD-PAYMENT-SERVICE&lt;/strong&gt;服务的具体实例，测试成功，在服务消费方80服务的后端控制台也输出了的日志。&lt;/p&gt;
&lt;h4 id=&quot;5-openfeign概述&quot;&gt;5. OpenFeign概述&lt;/h4&gt;
&lt;h5 id=&quot;51-openfeign是什么？&quot;&gt;5.1 OpenFeign是什么？&lt;/h5&gt;
&lt;p&gt;Feign是一个声名式WebService客户端，使用Feign能让编写WebService客户端更加简单。它的使用方法是定义一个服务接口然后在上面添加注解。Feign也支持可拔插式的编码器和解码器。SpringCloud对Feign进行了封装，使其支持了Spring MVC标准注解和HttpMessageConverters。Feign可以与Eureka和Ribbon组合使用以支持负载均衡。&lt;/p&gt;
&lt;h5 id=&quot;52-feign能做什么？&quot;&gt;5.2 Feign能做什么？&lt;/h5&gt;
&lt;p&gt;Feign旨在使编写Java Http客户端变得更容易。之前我们使用Ribbon + RestTemplate时，利用RestTemplate对Http请求的封装处理，形成了一套模板化的调用方法。但是在实际开发中由于对服务依赖的调用可能不止一处，&lt;span&gt;往往一个接口会被多处调用，所以通常都会针对每个微服务自行封装一些客户端类来包装这些依赖服务的调用。&lt;/span&gt;所以Feign在此基础上做了进一步封装，由它来帮助定义和实现依赖服务接口的定义。在Feign的实现下，&lt;span&gt;只需要创建一个接口并使用注解的方式来配置它&lt;/span&gt;（例如以前是DAO接口上面标注Mapper注解，现在是一个微服务接口上面标注一个Feign注解），即可完成对服务提供方的接口绑定，简化了使用SpringCloud Ribbon时，自动封装服务调用客户端的开发量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Feign集成了Ribbon&lt;/strong&gt;：利用Ribbon维护服务提供方的服务列表信息，并且通过如轮询的算法实现了客户端的负载均衡。而与Ribbon不同的是，&lt;span&gt;通过Feign只需要定义服务绑定接口且以声明式的方式，&lt;/span&gt;优雅而简单的实现了服务调用。&lt;/p&gt;
&lt;h5 id=&quot;53-feign和openfeign的区别&quot;&gt;5.3 Feign和OpenFeign的区别&lt;/h5&gt;
&lt;p&gt;Feign已经停止维护，所以我们只需要关注OpenFeign的使用即可，我们现在学习的就是利用&lt;strong&gt;OpenFeign&lt;/strong&gt;实现我们之前用的&lt;strong&gt;Ribbon+RestTemplate&lt;/strong&gt;实现的功能。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th/&gt;
&lt;th&gt;Feign&lt;/th&gt;
&lt;th&gt;OpenFeign&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;6.5&quot;&gt;&lt;tr readability=&quot;9&quot;&gt;&lt;td&gt;特点&lt;/td&gt;
&lt;td&gt;Feign是SpringCloud组件中的一个轻量级RESTful的HTTP服务客户端，&lt;strong&gt;Feign内置了Ribbon&lt;/strong&gt;，用来做客户端的负载均衡，去调用服务注册中心的服务。Feign的使用方式是：使用Feign的注解定义接口，调用这个接口，就可以调用服务注册中心的服务。&lt;/td&gt;
&lt;td&gt;OpenFeign是SpringCloud在&lt;strong&gt;Feign的基础上支持了SpringMVC的注解&lt;/strong&gt;，如&lt;code&gt;@RequestMapping&lt;/code&gt; 等。OpenFeign的 &lt;code&gt;@FeignClient&lt;/code&gt; 可以解析SpringMVC的 &lt;code&gt;@RequestMapping&lt;/code&gt; 注解下的接口，并通过动态代理的方式产生实现类，实现类中做负载均衡并调用其他服务。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;启动器&lt;/td&gt;
&lt;td&gt;spring-cloud-starter-feign&lt;/td&gt;
&lt;td&gt;spring-cloud-starter-openfeign&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4 id=&quot;6-openfeign使用案例&quot;&gt;6. OpenFeign使用案例&lt;/h4&gt;
&lt;h5 id=&quot;61-接口注解，新建module&quot;&gt;6.1 接口+注解，新建Module&lt;/h5&gt;
&lt;p&gt;新建cloud-consumer-feign-order80作为服务消费方服务。&lt;/p&gt;
&lt;p&gt;在微服务调用的接口上添加注解&lt;strong&gt;&lt;code&gt;@FeignClient&lt;/code&gt;&lt;/strong&gt;，注意&lt;strong&gt;OpenFeign在服务消费方使用&lt;/strong&gt;。&lt;/p&gt;
&lt;h5 id=&quot;62-pomxml&quot;&gt;6.2 pom.xml&lt;/h5&gt;
&lt;p&gt;在POM中我们引入了OpenFeign的依赖以及Eureka客户端的依赖&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;dependencies&amp;gt;
    &amp;lt;!--openfeign--&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-cloud-starter-openfeign&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;!--eureka client--&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-eureka-client&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;!-- 引入自己定义的api通用包，可以使用Payment支付Entity --&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;com.polaris&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;cloud-api-common&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;${project.version}&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;!--web--&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-actuator&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;!--一般基础通用配置--&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-devtools&amp;lt;/artifactId&amp;gt;
        &amp;lt;scope&amp;gt;runtime&amp;lt;/scope&amp;gt;
        &amp;lt;optional&amp;gt;true&amp;lt;/optional&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.projectlombok&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;lombok&amp;lt;/artifactId&amp;gt;
        &amp;lt;optional&amp;gt;true&amp;lt;/optional&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
        &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
    &amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;63-yml配置文件&quot;&gt;6.3 yml配置文件&lt;/h5&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;由于80为服务消费方，只是调用服务提供方的服务，所以可以不讲自己注册到服务注册中心。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yml&quot;&gt;server:
  port: 80

eureka:
  client:
    register-with-eureka: false # 客户端就不注册入服务注册中心了
    service-url:
      defaultZone: http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;64-主启动类&quot;&gt;6.4 主启动类&lt;/h5&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意主启动类上需要添加 &lt;strong&gt;&lt;code&gt;@EnableFeignClients&lt;/code&gt;&lt;/strong&gt; 注解，这个注解声明80服务可以使用Feign来实现服务接口的调用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@SpringBootApplication
@EnableFeignClients //激活Feign功能
public class OrderFeignMain80 {
    public static void main(String[] args) {
        SpringApplication.run(OrderFeignMain80.class);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;65-业务类&quot;&gt;6.5 业务类&lt;/h5&gt;
&lt;p&gt;前面就提到过，在Feign的实现下，只需要创建一个接口并使用注解的方式来配置，这是什么意思呢，就是我们在服务消费方中的service中编写接口，并在该接口上使用 &lt;strong&gt;&lt;code&gt;@FeignClient&lt;/code&gt;&lt;/strong&gt; 注解，这样的话就能够实现对服务提供方的服务调用，首先我们看服务提供方8001中有如下的一个服务：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@RestController
@Slf4j
@RequestMapping(&quot;/payment&quot;)
public class PaymentController {
    //... 
    @GetMapping(&quot;/get/{id}&quot;)
    public CommonResult&amp;lt;Payment&amp;gt; getPaymentById(@PathVariable(&quot;id&quot;) Long id) {
        Payment paymentById = paymentService.getPaymentById(id);
        log.info(&quot;===&amp;gt; payment: &quot; + paymentById);
        if(paymentById != null) {
            return new CommonResult(200,
                                    &quot;查询成功,端口号：&quot; + serverPort,paymentById);
        }
        return new CommonResult(400,&quot;查询失败&quot;,null);
        }
    //... 
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在服务消费方80中编写如下的接口即可对服务提供方的服务进行调用：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Component
@FeignClient(&quot;CLOUD-PAYMENT-SERVICE&quot;)
public interface PaymentFeignService {
    @GetMapping(&quot;/payment/get/{id}&quot;)
    public CommonResult getPaymentById(@PathVariable(&quot;id&quot;) Long id);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;@FeignClient&lt;/code&gt;&lt;/strong&gt; 注解中的value值为要调用的服务名称，也就是8001/8002服务提供方注册到Eureka注册中心的服务名，这个注解就是告诉该接口调用哪个服务，而默认OpenFeign会使用轮训的负载均衡算法来调用具体的服务实例，在这个接口中我们需要使用服务提供方服务的哪个具体方法，将该方法作为接口方法写入接口中即可。&lt;/p&gt;
&lt;p&gt;然后编写80服务消费方的Controller：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@RestController
@Slf4j
@RequestMapping(&quot;/consumer&quot;)
public class OrderFeignController {

    @Autowired
    private PaymentFeignService paymentFeignService;

    @GetMapping(&quot;/payment/get/{id}&quot;)
    public CommonResult&amp;lt;Payment&amp;gt; getPaymentById(@PathVariable(&quot;id&quot;) Long id) {
        return paymentFeignService.getPaymentById(id);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;66-测试&quot;&gt;6.6 测试&lt;/h5&gt;
&lt;p&gt;我们先启动Eureka的集群注册中心，然后启动服务提供方8001/8002，再启动服务消费方80，访问http://localhost/consumer/payment/get/1，我们可以发现OpenFeign使用轮询的负载均衡算法实现了服务提供方服务接口的调用。&lt;/p&gt;
&lt;h5 id=&quot;67-总结&quot;&gt;6.7 总结&lt;/h5&gt;
&lt;p&gt;简言之就是&lt;span&gt;客户端的服务接口使用用 &lt;strong&gt;&lt;code&gt;@FeignClient&lt;/code&gt;&lt;/strong&gt; 注解根据服务名称去调用服务提供方的具体服务。&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&quot;7-openfeign超时控制&quot;&gt;7. OpenFeign超时控制&lt;/h4&gt;
&lt;h5 id=&quot;71-超时设置&quot;&gt;7.1 超时设置&lt;/h5&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;咱们这里故意设置超时演示出错情况&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;服务提供方8001故意写暂停程序&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@GetMapping(&quot;/feign/timeout&quot;)
public String paymentFeignTimeout() {
    //暂停几秒线程
    try {
        TimeUnit.SECONDS.sleep(3);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    return serverPort;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;服务消费方80service添加超时方法paymentFeignTimeout，controller添加超时接口paymentFeignTimeout&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Component
@FeignClient(&quot;CLOUD-PAYMENT-SERVICE&quot;)
public interface PaymentFeignService {
    @GetMapping(&quot;/payment/feign/timeout&quot;)
    String paymentFeignTimeout();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@RestController
@Slf4j
@RequestMapping(&quot;/consumer&quot;)
public class OrderFeignController {
    @Resource
    private PaymentFeignService paymentFeignService;

    @GetMapping(&quot;/payment/feign/timeout&quot;)
    public String paymentFeignTimeout() {
        //openfeign底层为ribbon，客户端一般默认等待1秒钟
        return paymentFeignService.paymentFeignTimeout();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试：&lt;a href=&quot;http://localhost/consumer/payment/feign/timeout&quot; target=&quot;_blank&quot;&gt;http://localhost/consumer/payment/feign/timeout&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;错误页面（OpenFeign默认等待1秒钟，超过后报错）&lt;/p&gt;
&lt;img src=&quot;https://gitee.com/mp2333/blog-img/raw/master/SpringCloud/20210203235306.png&quot; alt=&quot;image-20210203235305718&quot;/&gt;&lt;h5 id=&quot;72-开启openfeign客户端超时控制&quot;&gt;7.2 开启OpenFeign客户端超时控制&lt;/h5&gt;
&lt;p&gt;服务消费者80的yml配置文件中开启OpenFeign客户端超时控制&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yml&quot;&gt;server:
  port: 80

eureka:
  client:
    register-with-eureka: false # 客户端就不注册入服务注册中心了
    service-url:
      defaultZone: http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/
# 设置feign客户端超时时间(OpenFeign默认支持ribbon)
ribbon:
# 指的是建立连接所用的时间,适用于网络状态正常的情况下,两端连接所用的时间
ReadTimeout: 5000
# 指的是建立连接后从服务器读取到可用资源所用的时间
ConnectTimeout: 5000
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;8-openfeign日志打印&quot;&gt;8. OpenFeign日志打印&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;理解&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Feign提供了日志打印功能，我们可以通过配置来调整日志级别，从而了解 Fegin 中 Http 请求的细节。&lt;span&gt;说白了就是对Feign接口的调用情况进行监控和输出。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;日志级别&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;NONE&lt;/code&gt; 默认的，不显示任何日志&lt;/li&gt;
&lt;li&gt;BASIC 仅记录请求方法，URL，响应状态码及执行时间&lt;/li&gt;
&lt;li&gt;HEADERS 除了BASIC中定义的消息外，还有请求和响应的头信息&lt;/li&gt;
&lt;li&gt;FULL 除了 HEADERS 中定义的信息外，还有请求和响应的正文及元数据&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;配置日志Bean&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Configuration
public class FeignConfig {

    /**
     * feignClient配置日志级别
     * @return
     */
    @Bean
    public Logger.Level feignLoggerLevel() {
        // 请求和响应的头信息,请求和响应的正文及元数据
        return Logger.Level.FULL;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;yml配置文件中开启日志的Feign客户端&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yml&quot;&gt;server:
  port: 80
eureka:
  client:
    register-with-eureka: false
    fetch-registry: true
    service-url:
      defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka
ribbon:
  ReadTimeout: 5000
  ConnectTimeout: 5000
logging:
  level:
    # feign日志以什么级别监控哪个接口
    com.polaris.springcloud.service.PaymentFeignService: debug
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;后台日志查看&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&quot;https://gitee.com/mp2333/blog-img/raw/master/SpringCloud/20210204000730.png&quot; alt=&quot;image-20210204000730413&quot;/&gt;</description>
<pubDate>Wed, 03 Feb 2021 16:14:00 +0000</pubDate>
<dc:creator>MPolaris</dc:creator>
<og:description>1. Ribbon概述 1.1 Ribbon是什么 SpringCloud Ribbon是基于Netflix Ribbon实现的一套客户端，是负载均衡的工具。 Ribbon是Netflix发布的开源项</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mpolaris/p/14370486.html</dc:identifier>
</item>
<item>
<title>小心 Enum Parse 中的坑 - WeihanLi</title>
<link>http://www.cnblogs.com/weihanli/p/14370372.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/weihanli/p/14370372.html</guid>
<description>&lt;h2 id=&quot;intro&quot;&gt;Intro&lt;/h2&gt;
&lt;p&gt;最近使用枚举的时候，踩了一个小坑，分享一下，主要是枚举从 int 值转成枚举时可能会遇到&lt;/p&gt;
&lt;h2 id=&quot;sample&quot;&gt;Sample&lt;/h2&gt;
&lt;p&gt;来看下面的示例：&lt;/p&gt;
&lt;p&gt;首先定义一个枚举：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public enum Color : byte
{
    Red = 0,
    Green = 1,
    Blue = 2,
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;来看一下下面的代码，下面的代码会抛异常吗？&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;Console.WriteLine(((Color)10).ToString());
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再来看下面的代码，下面的代码又会怎么样呢，输出结果是什么？&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;var intValue = int.MaxValue;
Console.WriteLine(((Color)intValue).ToString());
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/489462/202102/489462-20210203233417088-1880427080.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上面的结果看得出来，从 int 值直接做转换的时候，结果可能并不是期望的，不会抛异常，那么又该如何处理呢？我们再来看一个示例&lt;/p&gt;
&lt;h2 id=&quot;parsesample&quot;&gt;ParseSample&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Enum&lt;/code&gt; 的 &lt;code&gt;Parse&lt;/code&gt; 方法不仅支持从 &lt;code&gt;Name&lt;/code&gt; 的字符串比如前面定义的枚举中的 &lt;code&gt;Red&lt;/code&gt;/&lt;code&gt;Green&lt;/code&gt;，还可以支持从 &lt;code&gt;int&lt;/code&gt; 的字符串也就是 &lt;code&gt;0&lt;/code&gt;/&lt;code&gt;1&lt;/code&gt;/&lt;code&gt;2&lt;/code&gt; ，来看下面的示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;if (Enum.TryParse(&quot;10&quot;, out Color color))
{
    Console.WriteLine(color.ToString());
}

if (Enum.TryParse(&quot;10&quot;, out Color color1)
    &amp;amp;&amp;amp; Enum.IsDefined(typeof(Color), color1))
{
    Console.WriteLine($&quot;Success, {color1}&quot;);
}
else
{
    Console.WriteLine(&quot;Can not match&quot;);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;来直接看输出结果吧：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/489462/202102/489462-20210203233416665-648669273.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;parse-from-name&quot;&gt;Parse from name&lt;/h2&gt;
&lt;p&gt;再来看一个从 Name 转换的一个示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;if (Enum.TryParse(&quot;Yellow&quot;, out Color color2))
{
    Console.WriteLine(color2.ToString());
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个不会有任何输出，&lt;code&gt;TryParse&lt;/code&gt; 会直接返回 &lt;code&gt;false&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;more&quot;&gt;More&lt;/h2&gt;
&lt;p&gt;当枚举从 int 值转换的时候，需要小心，即使 int 值在枚举中没有定义也会转换成功，如果要确保枚举中定义了对应的值时，应该使用 &lt;code&gt;IsDefined&lt;/code&gt; 来确保枚举定义了对应的值&lt;/p&gt;
&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
</description>
<pubDate>Wed, 03 Feb 2021 15:36:00 +0000</pubDate>
<dc:creator>WeihanLi</dc:creator>
<og:description>小心 Enum Parse 中的坑</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/weihanli/p/14370372.html</dc:identifier>
</item>
</channel>
</rss>