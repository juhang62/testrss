<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Telegraf和Grafana监控多平台上的SQL Server-自定义监控数据收集 - Joe.TJ</title>
<link>http://www.cnblogs.com/Joe-T/p/13026494.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Joe-T/p/13026494.html</guid>
<description>&lt;h2 id=&quot;问题&quot;&gt;问题&lt;/h2&gt;
&lt;p&gt;在&lt;a href=&quot;https://www.cnblogs.com/Joe-T/p/13026494.html&quot;&gt;上一篇文章&lt;/a&gt;中，我们使用Telegraf自带的Plugin配置好了的监控，但是自带的Plugin并不能完全覆盖我们想要的监控指标，就需要收集额外的自定义的监控数据，实现的方法有：&lt;/p&gt;
&lt;p&gt;此处收集的监控项不多，收集间隔也不是很频繁，所以我选择Telegraf预置的Inputs.exec plugin实现。它非常灵活，可以执行任意命令和脚本。在脚本中实现获取监控数据的逻辑，然后使用inputs.exec执行。获取数据之后，需要按&lt;a href=&quot;https://docs.influxdata.com/influxdb/v1.8/write_protocols/line_protocol_reference/&quot;&gt;InfluxDB Line Protocol&lt;/a&gt; 格式组织数据，才能写入到Influxdb。这种格式的组织方式：&lt;/p&gt;
&lt;h4 id=&quot;measurementtags-fields-timestamp&quot;&gt;&lt;strong&gt;[measurement],[tags] [fields] [timestamp]&lt;/strong&gt;&lt;/h4&gt;
&lt;ul readability=&quot;3&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;measurement，类似于SQL中表的概念，数据存放的容器&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;tags，K-V格式用于标记数据记录，一般它们的值不经常变化，如主机名。同时tags上会建立索引，查询效率会好一些.&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;fields，K-V格式，表示真正收集的不同时间点的数据项，如CPU Load&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;timestamp，UNIX 时间戳，Influxdb是时序数据库，所有数据都要与时间关联起来。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;measurement和tag之间用逗号分隔，fields 与它们用空格(whitespace)分隔&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;不管是运行在Linux还是Windows上的SQL，通常使用T-SQL查询实例内部的数据和使用操作系统脚本查询实例外部的数据以实现监控。接下来，以执行T-SQL获取自定义监控数据为例，看看在Windos和Linux上分别如何实现。&lt;/p&gt;
&lt;h2 id=&quot;解决方案&quot;&gt;解决方案&lt;/h2&gt;
&lt;p&gt;首先在被监控的实例上把相应的逻辑写成存储过程，然后通过inputs.exec调用之。&lt;/p&gt;
&lt;p&gt;例如我在目标实例的influx库中创建了一个存储过程influx.usp_getInstanceInfo获取一些实例的配置信息。然后需要在telegraf配置文件中启用inputs.exec调用这个存储过程。存储过程的输出数据如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;sqlserver_property,host=SQL19N1,sql_instance=SQL19N1 host_platform=&quot;Linux&quot;,host_distribution=&quot;CentOS Linux&quot;,host_release=7,edition=&quot;Developer Edition (64-bit)&quot;,product_version=&quot;15.0.4033.1&quot;,collation=&quot;SQL_Latin1_General_CP1_CI_AS&quot;,is_clustered=f,is_hadr=t,cpu_count=2,scheduler_count=2,physical_memory_kb=6523904,max_workers_count=512,max_dop=0,max_memmory=2147483647 1590915136000000000
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;数据写入到sqlserver_property,tags包括host,sql_instance,后面的全是fields。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h4 id=&quot;sql-on-linux&quot;&gt;SQL On Linux&lt;/h4&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;使用SQLCMD调用存储过程，把SQLCMD命令写到一个bash文件中/telegraf/get_sqlproperty.sh&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#!/bin/bash

/opt/mssql-tools/bin/sqlcmd -S SQL19N1 -U telegraf -P &amp;lt;yourpassword&amp;gt; -d influx -y 0 -Q &quot;EXEC influx.usp_getInstanceInfo&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改telegraf.conf中的inputs.exec, 然后重启telegraf生效：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;因为收集的是实例属性信息，收集间隔设置的比较长。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt; [[inputs.exec]]
#   ## Commands array
   commands = [
        &quot;/telegraf/get_sqlproperty.sh&quot;
        ]
        
   timeout = &quot;5s&quot;
   interval=&quot;24h&quot;
   data_format = &quot;influx&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h4 id=&quot;sql-on-windows&quot;&gt;SQL On Windows&lt;/h4&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Windows上首选使用PowerShell实现，把执行SQL的命令写到C:\Monitoring\scripts\get_sqlproperty.ps1。col_res是存储过程输出的列名。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;(Invoke-Sqlcmd -ServerInstance SQL17N1 -Username telegraf -Password &quot;&amp;lt;yourpassword&amp;gt;&quot; -Database influx -Query &quot;exec influx.usp_getInstanceInfo&quot; ).col_res
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改telegraf.conf中的inputs.exec, 然后重启telegraf生效.&lt;/p&gt;
&lt;p&gt;需要特别注意的问题：&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;指定文件路径时，要使用Linux路径表达的forward slash(/), 而不是Windows中的 back slash(\)&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;ps1文件路径使用单引号(single quote)&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;避免文件路径中有空格(whitespace)&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt; [[inputs.exec]]
#   ## Commands array
   commands = [
        &quot;powershell 'C:/Monitoring/scripts/get_sqlproperty.ps1' &quot;
        ]
        
   timeout = &quot;5s&quot;
   interval=&quot;24h&quot;
   data_format = &quot;influx&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配置完成后，看看measurement和数据：&lt;/p&gt;
&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/Joe-T/1774696/o_200601095410sqlserver_property.PNG&quot; height=&quot;50%&quot; width=&quot;50%&quot;/&gt;&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;ul readability=&quot;3&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;在inputs.exec中最好是调用脚本，而不是命令。这样当你需要变更数据收集逻辑，直接修改脚本即可，而不需要修改Telegraf的配置文件，避免重启服务和配置干扰&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;被调用的脚本的输出，要是stdout，才能被正确写入influxdb&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Windows 上文件路径和符号escape要特别注意&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;如果对收集性能特别敏感或者收集频率特别高时，使用Go自定义Plugin&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;本文内容仅代表个人观点，与任何公司和组织无关&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Thu, 11 Jun 2020 00:36:00 +0000</pubDate>
<dc:creator>Joe.TJ</dc:creator>
<og:description>问题 在上一篇文章中，我们使用Telegraf自带的Plugin配置好了的监控，但是自带的Plugin并不能完全覆盖我们想要的监控指标，就需要收集额外的自定义的监控数据，实现的方法有： 开发自己的Te</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Joe-T/p/13026494.html</dc:identifier>
</item>
<item>
<title>shell编程（一）：功能、执行、基础 - yq055783</title>
<link>http://www.cnblogs.com/yq055783/p/13091050.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yq055783/p/13091050.html</guid>
<description>&lt;p&gt;&lt;span&gt;（&lt;/span&gt;1&lt;span&gt;）自动化批量初始化系统：对&lt;/span&gt;&lt;span&gt;N&lt;/span&gt;&lt;span&gt;台系统初始化（装系统时对系统的时区、&lt;/span&gt;&lt;span&gt;yum&lt;/span&gt;&lt;span&gt;源、软件包的更新、安全的设置进行初始化）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;2&lt;span&gt;）自动化批量部署软件程序：（&lt;/span&gt;&lt;span&gt;LAMP/LNMP/Tomcat/LVS/Nginx&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;3&lt;span&gt;）写一些自动化的管理应用程序：（&lt;/span&gt;&lt;span&gt;KVM&lt;/span&gt;&lt;span&gt;虚拟化管理、集群的管理比如扩容、&lt;/span&gt;&lt;span&gt;mysql&lt;/span&gt;&lt;span&gt;的部署升级备份等）关键是管理命令而不是语法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;4&lt;span&gt;）日志的分析处理程序：（比如打印出当天网站的&lt;/span&gt;&lt;span&gt;PV&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;UV&lt;/span&gt;&lt;span&gt;量；&lt;/span&gt;&lt;span&gt;top100&lt;/span&gt;&lt;span&gt;；&lt;/span&gt;&lt;span&gt;tcp&lt;/span&gt;&lt;span&gt;的各个状态统计等）：用到比较多的命令是&lt;/span&gt;&lt;strong&gt;grep/awk&lt;span&gt;。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;5&lt;span&gt;）自动化备份、恢复程序：（&lt;/span&gt;&lt;span&gt;mysql&lt;/span&gt;&lt;span&gt;完全备份、增量备份）&lt;/span&gt; &lt;span&gt;Crond&lt;/span&gt;&lt;span&gt;计划任务（定时）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;6&lt;span&gt;）自动化管理程序（批量远程修改密码、配置更新）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;7&lt;span&gt;）自动化信息采集及监控程序（收集每个系统&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;应用的状态信息：如&lt;/span&gt;&lt;span&gt;cpu&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;mem&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;disk&lt;/span&gt;&lt;span&gt;使用和&lt;/span&gt;&lt;span&gt;tcp&lt;/span&gt;&lt;span&gt;状态等、&lt;/span&gt;&lt;span&gt;apache&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;mysql&lt;/span&gt;&lt;span&gt;的健康信息等）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;tcp&lt;span&gt;状态：&lt;/span&gt;&lt;span&gt;ss -an | grep :80    &lt;/span&gt;&lt;span&gt;过滤&lt;/span&gt;&lt;span&gt;80&lt;/span&gt;&lt;span&gt;端口的&lt;/span&gt;&lt;span&gt;tcp&lt;/span&gt;&lt;span&gt;连接的状态。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;8&lt;span&gt;）和其他程序搭配使用。&lt;/span&gt;&lt;span&gt;Zabbix&lt;/span&gt;&lt;span&gt;是用来收集各种健康状态、&lt;/span&gt;&lt;span&gt;cpu&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;mem&lt;/span&gt;&lt;span&gt;等信息（很直观）。自动化扩容（增加云服务器&lt;/span&gt;&lt;span&gt;----&amp;gt;&lt;/span&gt;&lt;span&gt;部署应用）：开始是利用&lt;/span&gt;&lt;span&gt;Zabbix&lt;/span&gt;&lt;span&gt;进行监控报警、手动增加服务器和上线业务，现可以&lt;/span&gt;&lt;span&gt;zabbix&lt;/span&gt;&lt;span&gt;监控（&lt;/span&gt;&lt;span&gt;python&lt;/span&gt;&lt;span&gt;开发的）（&lt;/span&gt;&lt;span&gt;cpu&amp;gt;80%&lt;/span&gt;&lt;span&gt;）报警，然后调用&lt;/span&gt;&lt;span&gt;python&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;api&lt;/span&gt;&lt;span&gt;实现对云主机的增加、减少，利用&lt;/span&gt;&lt;span&gt;shell&lt;/span&gt;&lt;span&gt;实现业务的上线。&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;（&lt;/span&gt;1&lt;span&gt;）一个简单的&lt;/span&gt;&lt;span&gt;shell&lt;/span&gt;&lt;span&gt;程序&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在&lt;/span&gt;ping01.sh&lt;span&gt;里写下：&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;ping&lt;/span&gt; -c1 www.qfedu.com &amp;amp;&amp;gt;/dev/&lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; &lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ok........&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; || &lt;span&gt;echo&lt;/span&gt; “not ok”
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;ping -c1&lt;/strong&gt; &lt;span&gt;代表&lt;/span&gt;ping1&lt;span&gt;次&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;每个命令执行完成后都有个返回值，执行成功返回&lt;/span&gt;0&lt;span&gt;，不成功为非&lt;/span&gt;&lt;span&gt;0.&lt;/span&gt;&lt;span&gt;返回值变量为&lt;/span&gt;&lt;span&gt;?&lt;/span&gt;&lt;span&gt;比如&lt;/span&gt;&lt;span&gt;echo $?  &lt;/span&gt;&lt;span&gt;（&lt;/span&gt;&lt;span&gt;$?&lt;/span&gt;&lt;span&gt;表示获取值）&lt;/span&gt; &lt;span&gt;echo $?&lt;/span&gt;&lt;span&gt;表示&lt;/span&gt;&lt;strong&gt;上个命令&lt;/strong&gt;&lt;span&gt;返回的值&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&amp;amp;&amp;amp;&lt;/strong&gt;:&lt;span&gt;逻辑判断。当前面执行成功（&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;），后面才会执行（注：分号；把两条命令隔开，但不具备逻辑判断，用于命令的排序。）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&amp;amp;&amp;gt;/dev/nul:&lt;/strong&gt; &lt;span&gt;不想要&lt;/span&gt;ping&lt;span&gt;的信息，就重定向到&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;中去（&lt;/span&gt;&lt;strong&gt;&amp;amp;&lt;/strong&gt;代表混合输出，包含标准输出和错误输出）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;执行：&lt;/strong&gt;bash ping01.sh &lt;span&gt;或者&lt;/span&gt;&lt;span&gt;sh ping01.sh&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;也可以通过绝对路径或者相对路径（&lt;/span&gt;./ping01.sh&lt;span&gt;）执行，但要执行权限。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;chmod&lt;/strong&gt; +x ping01.sh  &lt;span&gt;给文件加执行权限&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;#!/bin/bash&lt;/strong&gt;  &lt;span&gt;定义程序用哪个&lt;/span&gt;&lt;strong&gt;解释器&lt;/strong&gt;执行。当执行时&lt;strong&gt;没有明确指定解释器时&lt;/strong&gt;会生效（比如用相对路径执行脚本）。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;bash&lt;span&gt;、&lt;/span&gt;&lt;span&gt;sh&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;source&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;执行的区别：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;bash&lt;span&gt;、&lt;/span&gt;&lt;span&gt;sh&lt;/span&gt;&lt;span&gt;是在&lt;/span&gt;&lt;strong&gt;&lt;span&gt;子&lt;/span&gt;shell&lt;/strong&gt;&lt;span&gt;中执行。&lt;/span&gt;source&lt;span&gt;和&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;在&lt;/span&gt;&lt;strong&gt;&lt;span&gt;当前&lt;/span&gt;shell&lt;/strong&gt;执行。&lt;span&gt;当&lt;/span&gt;shell&lt;span&gt;文件里有切换目录命令时，用&lt;/span&gt;&lt;span&gt;./&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;bash&lt;/span&gt;&lt;span&gt;执行，不会切换目录（因为这两个是在&lt;/span&gt;&lt;span&gt;sub shell&lt;/span&gt;&lt;span&gt;子&lt;/span&gt;&lt;span&gt;shell&lt;/span&gt;&lt;span&gt;中执行。重新开了个&lt;/span&gt;&lt;span&gt;shell&lt;/span&gt;&lt;span&gt;，当前的&lt;/span&gt;&lt;span&gt;shell&lt;/span&gt;&lt;span&gt;就不会变）；而&lt;/span&gt; &lt;span&gt;.&lt;/span&gt; &lt;span&gt;或者&lt;/span&gt;&lt;span&gt;source&lt;/span&gt;&lt;span&gt;是在当前&lt;/span&gt;&lt;span&gt;shell&lt;/span&gt;&lt;span&gt;执行，就会切换当前的目录。&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;常规情况在子&lt;/span&gt;&lt;span&gt;shell&lt;/span&gt;&lt;span&gt;执行，但想要脚本中定义的一个变量就在当前&lt;/span&gt;&lt;span&gt;shell&lt;/span&gt;&lt;span&gt;中生效，就用&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;或者&lt;/span&gt;&lt;span&gt;source&lt;/span&gt;&lt;span&gt;。比如在&lt;/span&gt;&lt;span&gt;/root/.bashrc&lt;/span&gt;&lt;span&gt;下修改别名，重启也会生效，当通过&lt;/span&gt;&lt;span&gt;source /root/.bashrc&lt;/span&gt;&lt;span&gt;执行，就可以使用刚才定义的别名&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;（&lt;/span&gt;2&lt;span&gt;）程序语言执行&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;程序语言执行时是不一样的。&lt;/span&gt;c&lt;span&gt;程序写完后要编译，然后变成机器码（&lt;/span&gt;&lt;span&gt;cpu&lt;/span&gt;&lt;span&gt;可以执行的），所以&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;最快。&lt;/span&gt;&lt;span&gt;java&lt;/span&gt;&lt;span&gt;写完后也要编码，但没有&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;快，因为编译完后是字节码（只能被&lt;/span&gt;&lt;span&gt;java&lt;/span&gt;&lt;span&gt;的虚拟机执行），&lt;/span&gt;&lt;span&gt;cpu&lt;/span&gt;&lt;span&gt;不能直接识别。&lt;/span&gt;&lt;span&gt;java&lt;/span&gt;&lt;span&gt;移植性好，任何平台只要有&lt;/span&gt;&lt;span&gt;jdk&lt;/span&gt;&lt;span&gt;虚拟机就能执行，但&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;的话和&lt;/span&gt;&lt;span&gt;cpu&lt;/span&gt;&lt;span&gt;的指令集有关（&lt;/span&gt;&lt;span&gt;x86&lt;/span&gt;&lt;span&gt;复杂指令集、&lt;/span&gt;&lt;span&gt;Power&lt;/span&gt;&lt;span&gt;精简指令集）（&lt;/span&gt;&lt;span&gt;gcc&lt;/span&gt;&lt;span&gt;编译默认编译是当前平台的）。&lt;/span&gt;&lt;span&gt;python&lt;/span&gt;&lt;span&gt;有两种执行：解释执行和编译执行（编译成字节码：&lt;/span&gt;&lt;span&gt;python&lt;/span&gt;&lt;span&gt;虚拟机执行）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;程序由&lt;strong&gt;逻辑&lt;/strong&gt;和&lt;strong&gt;数据&lt;/strong&gt;&lt;span&gt;组成。程序执行方式有两种：编译和解释型。&lt;/span&gt;shell&lt;span&gt;不需要事先编译，执行时才去考虑逻辑关系（解释）。&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;语言在执行时逻辑已经考虑好了，直接拿代码执行，所以快。&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;一个脚本里既有&lt;/span&gt;shell&lt;span&gt;代码，又有&lt;/span&gt;&lt;span&gt;python&lt;/span&gt;&lt;span&gt;代码。在&lt;/span&gt;&lt;span&gt;python&lt;/span&gt;&lt;span&gt;那段代码前后写上&lt;/span&gt;&lt;strong&gt;EOF&lt;span&gt;重定向。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
#!/bin/&lt;span&gt;bash

&lt;/span&gt;&lt;span&gt;ping&lt;/span&gt; -c1 www.qfedu.com &amp;amp;&amp;gt;/dev/&lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; &lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ok........&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;|| &lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;not ok&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

 

/usr/bin/python &amp;lt;&amp;lt;-&lt;span&gt;EOF

print(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

EOF

&lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;hello bash&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;span&gt;将&lt;/span&gt;python&lt;span&gt;代码&lt;/span&gt;&lt;strong&gt;重定向&lt;/strong&gt;&lt;span&gt;给&lt;/span&gt;python&lt;span&gt;执行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
/usr/bin/&lt;span&gt;cat&lt;/span&gt; &amp;lt;&amp;lt;-&lt;span&gt;EOF

&lt;/span&gt;&lt;span&gt;111&lt;/span&gt;

&lt;span&gt;222&lt;/span&gt;&lt;span&gt;

EOF&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;也是让&lt;/span&gt;cat&lt;span&gt;执行中间的代码。（这个&lt;/span&gt;&lt;span&gt;EOF&lt;/span&gt;&lt;span&gt;可以是任何标识。通用 的是&lt;/span&gt;&lt;span&gt;EOF&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;python&lt;span&gt;文件中不能识别&lt;/span&gt;&lt;span&gt;shell&lt;/span&gt;&lt;span&gt;脚本。&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;内容：特性、变量、条件测试、数值运算、流程控制和循环&lt;/p&gt;

&lt;p&gt;1.login shell&lt;span&gt;和&lt;/span&gt;&lt;span&gt;nologin shell&lt;/span&gt;&lt;span&gt;区别：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;su&lt;span&gt;是切换用户。当&lt;/span&gt;&lt;span&gt;su - yq&lt;/span&gt; &lt;span&gt;是&lt;/span&gt;&lt;strong&gt;login shell&lt;/strong&gt;&lt;span&gt;登陆&lt;/span&gt;shell&lt;span&gt;，切换到用户&lt;/span&gt;&lt;span&gt;yq&lt;/span&gt;&lt;span&gt;的目录。而没有加&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;su yq&lt;/span&gt;&lt;span&gt;，叫&lt;/span&gt;&lt;span&gt;nologin shell&lt;/span&gt;&lt;span&gt;，没有加载新用户的&lt;/span&gt;&lt;span&gt;shell&lt;/span&gt;&lt;span&gt;环境，还是&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;的目录，但没有访问权限。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;shell&lt;span&gt;相关的文件：系统级别的&lt;/span&gt;&lt;strong&gt;/etc/profile&lt;span&gt;、&lt;/span&gt;&lt;span&gt;/etc/hashrc&lt;/span&gt;&lt;/strong&gt;和用户级别的家目录下的&lt;strong&gt;~/.bash-profile&lt;span&gt;、&lt;/span&gt;&lt;span&gt;~/.bashrc&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;/strong&gt;~/.bash_logout&lt;span&gt;和&lt;/span&gt;&lt;span&gt;~/.bash_history&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;前&lt;/span&gt;4&lt;span&gt;个是在登陆&lt;/span&gt;&lt;span&gt;shell&lt;/span&gt;&lt;span&gt;时执行。后面两个是在离开&lt;/span&gt;&lt;span&gt;shell&lt;/span&gt;&lt;span&gt;执行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;login shell&lt;span&gt;登陆时执行&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;个文件，&lt;/span&gt;&lt;span&gt;nologin shell&lt;/span&gt;&lt;span&gt;登陆时执行&lt;/span&gt;&lt;strong&gt;/etc/hashrc&lt;/strong&gt;和&lt;strong&gt;~/.bashrc&lt;/strong&gt;&lt;span&gt;，不执行&lt;/span&gt;profile&lt;span&gt;文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;rmp -qc bash &lt;span&gt;查看&lt;/span&gt;&lt;span&gt;bash&lt;/span&gt;&lt;span&gt;的配置文件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以要加&lt;/span&gt;-&lt;/p&gt;

&lt;p&gt;2.bash shell&lt;span&gt;特点&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;1&lt;span&gt;）命令和文件的自动补齐&lt;/span&gt; &lt;span&gt;tab&lt;/span&gt;&lt;span&gt;键&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;能补齐是因为安装了&lt;/span&gt;bash-com&lt;span&gt;软件&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
rpm -qa | &lt;span&gt;grep&lt;/span&gt; bash-completion
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(2)&lt;span&gt;历史记忆功能&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上下键、&lt;/span&gt;!number&lt;span&gt;（执行给定行号的历史命令）、&lt;/span&gt;&lt;span&gt;!string&lt;/span&gt;&lt;span&gt;（找到最近一个以&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;开头的命令） 、&lt;/span&gt;&lt;span&gt;!$&lt;/span&gt;&lt;span&gt;（代表上一个命令 的最后一个参数）、&lt;/span&gt;&lt;span&gt;!!&lt;/span&gt;&lt;span&gt;（上一个命令。脚本没有上下键）、&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;3&lt;span&gt;）别名功能&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;alias&lt;span&gt;（查看当前&lt;/span&gt;&lt;span&gt;shell&lt;/span&gt;&lt;span&gt;的别名）、&lt;/span&gt;&lt;span&gt;unalias&lt;/span&gt;&lt;span&gt;取消别名。或者执行时在别名前加&lt;/span&gt;&lt;span&gt;\&lt;/span&gt;&lt;span&gt;跳过别名&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;~/.bashrc&lt;span&gt;中定义别名（永久的）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;4&lt;span&gt;）快捷键&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;ctrl+r:&lt;span&gt;搜索一个历史命令&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;ctrl+d:&lt;span&gt;退出&lt;/span&gt;&lt;span&gt;shell&lt;/span&gt; &lt;span&gt;相当于&lt;/span&gt;&lt;span&gt;exit&lt;/span&gt;&lt;span&gt;或者&lt;/span&gt;&lt;span&gt;logout&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;ctrl+a&lt;span&gt;、&lt;/span&gt;&lt;span&gt;ctrl+e&lt;/span&gt;&lt;span&gt;：命令的编辑（&lt;/span&gt;&lt;span&gt;ctrl+a&lt;/span&gt;&lt;span&gt;将光标移动到最前面、&lt;/span&gt;&lt;span&gt;ctrl+e&lt;/span&gt;&lt;span&gt;：删除命令）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;ctrl+s&lt;span&gt;、&lt;/span&gt;&lt;span&gt;ctrl+q&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;span&gt;s&lt;/span&gt;&lt;span&gt;是锁住屏幕（输命令没反应），&lt;/span&gt;&lt;span&gt;q&lt;/span&gt;&lt;span&gt;是退出锁住的状态&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;5&lt;span&gt;）前后台作业控制&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&amp;amp;&lt;span&gt;：后台作业。比如&lt;/span&gt;&lt;span&gt;sleep 3000 &amp;amp;  &lt;/span&gt;&lt;span&gt;把睡&lt;/span&gt;&lt;span&gt;3000&lt;/span&gt;&lt;span&gt;秒放到后台作业。此时&lt;/span&gt;&lt;span&gt;grep aux|grep sleep&lt;/span&gt;&lt;span&gt;可以看到进程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;ctrl+z&lt;span&gt;：把正在做的作业放到后台&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;screen&lt;span&gt;：先装一个&lt;/span&gt;&lt;span&gt;yum -y install screen&lt;/span&gt;&lt;span&gt;。连上终端先输入&lt;/span&gt;&lt;span&gt;screen -S&lt;/span&gt; &lt;span&gt;会话名（定义会话名称）。然后输入其他命令。退出程序后，再重新进入可以&lt;/span&gt;&lt;span&gt;screen -list&lt;/span&gt;&lt;span&gt;查看到之前会话名的和会话名的数字。然后输入&lt;/span&gt;&lt;span&gt;screen -r&lt;/span&gt; &lt;span&gt;数字就可以回到退出前状态，识别上次会话（&lt;/span&gt;&lt;strong&gt;&lt;span&gt;连到远程的&lt;/span&gt;shell&lt;span&gt;的首选&lt;/span&gt;&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;ctrl+c&lt;span&gt;：只能杀掉前台进程（不能杀后台）。进程执行顺序：父进程&lt;/span&gt;&lt;span&gt;fork&lt;/span&gt;&lt;span&gt;一个子进程，子进程会占终端，父进程会&lt;/span&gt;&lt;span&gt;sleep&lt;/span&gt;&lt;span&gt;睡觉，只有子进程结束，通知父进程资源回收，释放掉所有资源，父进程就会回到终端。比如&lt;/span&gt;&lt;span&gt;sleep 80&lt;/span&gt;&lt;span&gt;对于&lt;/span&gt;&lt;span&gt;shell&lt;/span&gt;&lt;span&gt;来讲是个子进程，因此父进程就没办法工作，因此就将其放到后台去（加&lt;/span&gt;&lt;span&gt;&amp;amp;&lt;/span&gt;&lt;span&gt;或者按&lt;/span&gt;&lt;span&gt;ctrl+z&lt;/span&gt;&lt;span&gt;）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;jobs&lt;span&gt;：查看后台进程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;bg&lt;span&gt;或者&lt;/span&gt;&lt;span&gt;bg+&lt;/span&gt;&lt;span&gt;作业号：查看后台进程或者让某进程到后台工作&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;fg&lt;span&gt;或者&lt;/span&gt;&lt;span&gt;fg+&lt;/span&gt;&lt;span&gt;作业号：回到前台&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例子：&lt;/span&gt;vim /etc/hosts&lt;span&gt;做到一般，按&lt;/span&gt;&lt;span&gt;ctrl+z&lt;/span&gt;&lt;span&gt;将其放到后台，此时进入终端，执行其他命令，然后再按&lt;/span&gt;&lt;span&gt;fg&lt;/span&gt;&lt;span&gt;，就又将&lt;/span&gt;&lt;span&gt;vim&lt;/span&gt;&lt;span&gt;从后台调入前台，继续执行&lt;/span&gt;&lt;span&gt;vim&lt;/span&gt;&lt;span&gt;操作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;kill %3&lt;span&gt;给当前终端作业号为&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;的发信号。没有&lt;/span&gt;&lt;span&gt;%&lt;/span&gt;&lt;span&gt;就是杀死进程号为&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;的进程。因此&lt;/span&gt;&lt;span&gt;%&lt;/span&gt;&lt;span&gt;不能省&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;6&lt;span&gt;）重定向&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;每个进程打开一个文件，就有一个文件描述符&lt;/span&gt;fd&lt;span&gt;。（&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;代表输入的文件（默认是键盘）、&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;代表输出的文件（默认是屏幕）、&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;代表错误的文件）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;输出重定向：&lt;/span&gt;&amp;gt; &lt;span&gt;覆盖  &lt;/span&gt;&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;追加&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2&amp;gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;2&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;错误输出&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2&amp;gt;&amp;amp;1&lt;span&gt;：标准错误输出重定向到标准输出   &lt;/span&gt;&lt;span&gt;&amp;amp;&amp;gt;&lt;/span&gt;&lt;span&gt;：混合输出&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;cat &amp;lt; /etc/hosts &amp;gt; /etc/hosts1&lt;span&gt;相当于拷贝&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;cat&amp;lt;&amp;lt;EOF &lt;span&gt;把输入的内容给&lt;/span&gt;&lt;span&gt;cat&lt;/span&gt;&lt;span&gt;执行&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;cat &amp;lt;&amp;lt;EOF &amp;gt; file2 &lt;span&gt;将多行内容输入到&lt;/span&gt;&lt;span&gt;file2&lt;/span&gt;&lt;span&gt;文件中&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;7&lt;span&gt;）管道&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;一个命令的输出做下一个命令的输入&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
ip addr | &lt;span&gt;grep&lt;/span&gt; ‘inet’ | &lt;span&gt;grep&lt;/span&gt; eth0
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;tee&lt;span&gt;：复制一份到文件里&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
ip addr | &lt;span&gt;grep&lt;/span&gt; ‘inet’ | &lt;span&gt;tee&lt;/span&gt; test.txt |&lt;span&gt;grep&lt;/span&gt;&lt;span&gt; eth0   #覆盖

ip addr &lt;/span&gt;| &lt;span&gt;grep&lt;/span&gt; ‘inet’ | &lt;span&gt;tee&lt;/span&gt; -a test.txt |&lt;span&gt;grep&lt;/span&gt; eth0   #追加
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; date&amp;gt;a.txt &lt;span&gt;重定向到文件，但终端不显示了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;date | tee a.txt &lt;span&gt;会在终端显示，并且把显示输入到文件中&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;（&lt;/span&gt;8&lt;span&gt;）命令排序&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;分号；&lt;/span&gt; &lt;span&gt;不具备逻辑判断，一行输入多行命令。前面失败，后面照常执行&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&amp;amp;&amp;amp; : &lt;span&gt;前面成功后面才执行如&lt;/span&gt;&lt;span&gt;./configure &amp;amp;&amp;amp; make &amp;amp;&amp;amp; make install&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;|| &lt;span&gt;具备逻辑判断。前面失败，就执行后面的命令；前面成功，后面的命令不执行&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如&lt;/span&gt;ping -c1 10.10.10.2 &amp;amp;&amp;gt; /dev/null &amp;amp;&amp;amp; echo ‘ok’ || echo ‘no’  ping&lt;span&gt;成功执行&lt;/span&gt;&lt;span&gt;ok&lt;/span&gt;&lt;span&gt;，失败执行&lt;/span&gt;&lt;span&gt;no&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;true&lt;span&gt;永远返回为真。&lt;/span&gt;&lt;span&gt;echo $?&lt;/span&gt;&lt;span&gt;查看上条命令的返回值&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;注意：&lt;/p&gt;
&lt;p&gt;command &amp;amp;     &lt;span&gt;后台执行&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;command &amp;amp;&amp;gt; /dev/null   &lt;span&gt;混合输出（标准输出&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;和错误输出&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;command &amp;amp;&amp;amp; command2  &lt;span&gt;命令排序，逻辑判断。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;（&lt;/span&gt;9&lt;span&gt;）&lt;/span&gt;&lt;span&gt;shell&lt;/span&gt;&lt;span&gt;通配符（元字符）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;元字符就是符号表示的不是本意的符号。&lt;/span&gt;  &lt;span&gt;不同于正则（正则是前面）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;* &lt;span&gt;任意多个字符&lt;/span&gt; ls *.txt&lt;span&gt;或者&lt;/span&gt;&lt;span&gt;find / -iname&lt;/span&gt; ‘*-eth0’&lt;/p&gt;
&lt;p&gt;? 任意一个字符&lt;/p&gt;
&lt;p&gt;[] 匹配括号中的任意一个字符&lt;/p&gt;
&lt;p&gt;() &lt;span&gt;在子&lt;/span&gt;shell&lt;span&gt;中执行。例如（&lt;/span&gt;&lt;span&gt;umask 077; touch yq.txt&lt;/span&gt;&lt;span&gt;）开一个子&lt;/span&gt;&lt;span&gt;shell&lt;/span&gt;&lt;span&gt;去执行，否则&lt;/span&gt;&lt;span&gt;umask&lt;/span&gt;&lt;span&gt;会修改当前&lt;/span&gt;&lt;span&gt;shell&lt;/span&gt;&lt;span&gt;的权限设置。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注：&lt;/span&gt;umask&lt;span&gt;默认是&lt;/span&gt;&lt;span&gt;002&lt;/span&gt;&lt;span&gt;。用户创建文件的权限默认是&lt;/span&gt;&lt;span&gt;666&lt;/span&gt;&lt;span&gt;，创建目录的默认权限是&lt;/span&gt;&lt;span&gt;777&lt;/span&gt;&lt;span&gt;。但是由于&lt;/span&gt;&lt;span&gt;umask&lt;/span&gt;&lt;span&gt;会修改权限，即减少相应的数字，则最终文件权限是&lt;/span&gt;&lt;span&gt;664&lt;/span&gt;&lt;span&gt;，目录权限是&lt;/span&gt;&lt;span&gt;775&lt;/span&gt;&lt;span&gt;。可以通过&lt;/span&gt;&lt;span&gt;umask +&lt;/span&gt; &lt;span&gt;数字 修改。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;{} &lt;span&gt;集合&lt;/span&gt; &lt;span&gt;如&lt;/span&gt;touch file{1..9}&lt;/p&gt;
&lt;p&gt;\ &lt;span&gt;转义符&lt;/span&gt;   \&lt;span&gt;可以将换行的功能转义掉，就可以换行。只转义后面的第一个字符&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如&lt;/span&gt;echo -e ‘a\tb’  a&lt;span&gt;和&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;之间有个&lt;/span&gt;&lt;span&gt;tab&lt;/span&gt;&lt;span&gt;键&lt;/span&gt; &lt;span&gt;echo -e&lt;/span&gt;&lt;span&gt;是处理特殊字符&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;（&lt;/span&gt;10&lt;span&gt;）&lt;/span&gt;&lt;span&gt;echo&lt;/span&gt;&lt;span&gt;颜色输出&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;echo -e '\e[1;31mThis is a red text.\e[0m'&lt;/p&gt;
&lt;p&gt;\e[1; &lt;span&gt;是固定写法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;31m-37m&lt;span&gt;是字体的不同的&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;&lt;span&gt;个颜色&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;\e[0m &lt;span&gt;是将颜色恢复成正常颜色（颜色的重置）。不写这个，后面终端命令都会变成前面的颜色。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;注意文本和前面颜色的命令是紧挨着的。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;背景颜色：&lt;/span&gt;41m-47m&lt;/p&gt;
&lt;p&gt;echo -e '\e[1;41mThis is a red text.\e[0m'&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意：要有&lt;/span&gt;-e&lt;span&gt;才能识别特殊字符&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;printf&lt;span&gt;格式化输出，相比&lt;/span&gt;&lt;span&gt;echo&lt;/span&gt;&lt;span&gt;好。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 11 Jun 2020 00:35:00 +0000</pubDate>
<dc:creator>yq055783</dc:creator>
<og:description>1.shell的功能 （1）自动化批量初始化系统：对N台系统初始化（装系统时对系统的时区、yum源、软件包的更新、安全的设置进行初始化） （2）自动化批量部署软件程序：（LAMP/LNMP/Tomca</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yq055783/p/13091050.html</dc:identifier>
</item>
<item>
<title>实时标签开发——从零开始搭建实时用户画像(五) - 独孤风</title>
<link>http://www.cnblogs.com/tree1123/p/13091036.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tree1123/p/13091036.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1089984/202006/1089984-20200611082156851-918533310.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;​&lt;/p&gt;

&lt;p&gt;数据的接入可以通过将数据实时写入Kafka进行接入，不管是直接的写入还是通过oracle和mysql的实时接入方式，比如oracle的ogg，mysql的binlog&lt;/p&gt;
&lt;h4 id=&quot;ogg&quot;&gt;ogg&lt;/h4&gt;
&lt;p&gt;Golden Gate（简称OGG）提供异构环境下交易数据的实时捕捉、变换、投递。&lt;/p&gt;
&lt;p&gt;通过OGG可以实时的将oracle中的数据写入Kafka中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1089984/202006/1089984-20200611082218398-1570484911.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对生产系统影响小：实时读取交易日志，以低资源占用实现大交易量数据实时复制&lt;/p&gt;
&lt;p&gt;以交易为单位复制，保证交易一致性：只同步已提交的数据&lt;/p&gt;
&lt;p&gt;高性能&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;智能的交易重组和操作合并&lt;/li&gt;
&lt;li&gt;使用数据库本地接口访问&lt;/li&gt;
&lt;li&gt;并行处理体系&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;binlog&quot;&gt;binlog&lt;/h4&gt;
&lt;p&gt;MySQL 的二进制日志 binlog 可以说是 MySQL 最重要的日志，它记录了所有的 &lt;code&gt;DDL&lt;/code&gt; 和 &lt;code&gt;DML&lt;/code&gt; 语句（除了数据查询语句select、show等），&lt;strong&gt;以事件形式记录&lt;/strong&gt;，还包含语句所执行的消耗的时间，MySQL的二进制日志是事务安全型的。binlog 的主要目的是&lt;strong&gt;复制和恢复&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1089984/202006/1089984-20200611082313838-255265173.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过这些手段，可以将数据同步到kafka也就是我们的实时系统中来。&lt;/p&gt;
&lt;h4 id=&quot;flink接入kafka数据&quot;&gt;Flink接入Kafka数据&lt;/h4&gt;
&lt;p&gt;Apache Kafka Connector可以方便对kafka数据的接入。&lt;/p&gt;
&lt;p&gt;依赖&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;  &amp;lt;groupId&amp;gt;org.apache.flink&amp;lt;/groupId&amp;gt;  &amp;lt;artifactId&amp;gt;flink-connector-kafka_2.11&amp;lt;/artifactId&amp;gt;  &amp;lt;version&amp;gt;1.9.0&amp;lt;/version&amp;gt;&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;构建flinkkafkaconsumer&quot;&gt;构建FlinkKafkaConsumer&lt;/h5&gt;
&lt;p&gt;必须有的：&lt;/p&gt;
&lt;p&gt;1.topic名称&lt;/p&gt;
&lt;p&gt;2.用于反序列化Kafka数据的DeserializationSchema / KafkaDeserializationSchema&lt;/p&gt;
&lt;p&gt;3.配置参数：“bootstrap.servers” “group.id” （kafka0.8还需要 “zookeeper.connect”）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;val properties = new Properties()properties.setProperty(&quot;bootstrap.servers&quot;, &quot;localhost:9092&quot;)// only required for Kafka 0.8properties.setProperty(&quot;zookeeper.connect&quot;, &quot;localhost:2181&quot;)properties.setProperty(&quot;group.id&quot;, &quot;test&quot;)stream = env    .addSource(new FlinkKafkaConsumer[String](&quot;topic&quot;, new SimpleStringSchema(), properties))    .print()
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;时间戳和水印&quot;&gt;时间戳和水印&lt;/h5&gt;
&lt;p&gt;在许多情况下，记录的时间戳（显式或隐式）嵌入记录本身。另外，用户可能想要周期性地或以不规则的方式发出水印。&lt;/p&gt;
&lt;p&gt;我们可以定义好Timestamp Extractors / Watermark Emitters，通过以下方式将其传递给消费者&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;val env = StreamExecutionEnvironment.getExecutionEnvironment()val myConsumer = new FlinkKafkaConsumer[String](...)myConsumer.setStartFromEarliest()      // start from the earliest record possiblemyConsumer.setStartFromLatest()        // start from the latest recordmyConsumer.setStartFromTimestamp(...)  // start from specified epoch timestamp (milliseconds)myConsumer.setStartFromGroupOffsets()  // the default behaviour//指定位置//val specificStartOffsets = new java.util.HashMap[KafkaTopicPartition, java.lang.Long]()//specificStartOffsets.put(new KafkaTopicPartition(&quot;myTopic&quot;, 0), 23L)//myConsumer.setStartFromSpecificOffsets(specificStartOffsets)val stream = env.addSource(myConsumer)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;检查点&quot;&gt;检查点&lt;/h5&gt;
&lt;p&gt;启用Flink的检查点后，Flink Kafka Consumer将使用主题中的记录，并以一致的方式定期检查其所有Kafka偏移以及其他操作的状态。如果作业失败，Flink会将流式程序恢复到最新检查点的状态，并从存储在检查点中的偏移量开始重新使用Kafka的记录。&lt;/p&gt;
&lt;p&gt;如果禁用了检查点，则Flink Kafka Consumer依赖于内部使用的Kafka客户端的自动定期偏移提交功能。&lt;/p&gt;
&lt;p&gt;如果启用了检查点，则Flink Kafka Consumer将在检查点完成时提交存储在检查点状态中的偏移量。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;val env = StreamExecutionEnvironment.getExecutionEnvironment()env.enableCheckpointing(5000) // checkpoint every 5000 msecs
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Flink消费Kafka完整代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import org.apache.flink.api.common.serialization.SimpleStringSchema;import org.apache.flink.streaming.api.datastream.DataStream;import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;import org.apache.flink.streaming.connectors.kafka.FlinkKafkaConsumer;import java.util.Properties;public class KafkaConsumer {    public static void main(String[] args) throws Exception {        final StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();        Properties properties = new Properties();        properties.setProperty(&quot;bootstrap.servers&quot;, &quot;localhost:9092&quot;);        properties.setProperty(&quot;group.id&quot;, &quot;test&quot;);        //构建FlinkKafkaConsumer        FlinkKafkaConsumer&amp;lt;String&amp;gt; myConsumer = new FlinkKafkaConsumer&amp;lt;&amp;gt;(&quot;topic&quot;, new SimpleStringSchema(), properties);        //指定偏移量        myConsumer.setStartFromEarliest();        DataStream&amp;lt;String&amp;gt; stream = env                .addSource(myConsumer);        env.enableCheckpointing(5000);        stream.print();        env.execute(&quot;Flink Streaming Java API Skeleton&quot;);    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样数据已经实时的接入我们系统中，可以在Flink中对数据进行处理了，那么如何对标签进行计算呢？ 标签的计算过程极大的依赖于数据仓库的能力，所以拥有了一个好的数据仓库，标签也就很容易计算出来了。&lt;/p&gt;

&lt;p&gt;数据仓库是指一个面向主题的、集成的、稳定的、随时间变化的数据的集合，以用于支持管理决策的过程。&lt;/p&gt;
&lt;p&gt;（1）面向主题&lt;br/&gt;业务数据库中的数据主要针对事物处理任务，各个业务系统之间是各自分离的。而数据仓库中的数据是按照一定的主题进行组织的&lt;/p&gt;
&lt;p&gt;（2）集成&lt;br/&gt;数据仓库中存储的数据是从业务数据库中提取出来的，但并不是原有数据的简单复制，而是经过了抽取、清理、转换（ETL）等工作。&lt;br/&gt;业务数据库记录的是每一项业务处理的流水账，这些数据不适合于分析处理，进入数据仓库之前需要经过系列计算，同时抛弃一些分析处理不需要的数据。&lt;/p&gt;
&lt;p&gt;（3）稳定&lt;br/&gt;操作型数据库系统中一般只存储短期数据，因此其数据是不稳定的，记录的是系统中数据变化的瞬态。&lt;br/&gt;数据仓库中的数据大多表示过去某一时刻的数据，主要用于查询、分析，不像业务系统中数据库一样经常修改。一般数据仓库构建完成，主要用于访问&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1089984/202006/1089984-20200611082409696-811816869.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;OLTP 联机事务处理&lt;br/&gt;OLTP是传统关系型数据库的主要应用，主要用于日常事物、交易系统的处理&lt;br/&gt;1、数据量存储相对来说不大&lt;br/&gt;2、实时性要求高，需要支持事物&lt;br/&gt;3、数据一般存储在关系型数据库(oracle或mysql中)&lt;/p&gt;
&lt;p&gt;OLAP 联机分析处理&lt;br/&gt;OLAP是数据仓库的主要应用，支持复杂的分析查询，侧重决策支持&lt;br/&gt;1、实时性要求不是很高，ETL一般都是T+1的数据；&lt;br/&gt;2、数据量很大；&lt;br/&gt;3、主要用于分析决策；&lt;/p&gt;
&lt;p&gt;星形模型是最常用的数据仓库设计结构。由一个事实表和一组维表组成，每个维表都有一个维主键。&lt;br/&gt;该模式核心是事实表，通过事实表将各种不同的维表连接起来，各个维表中的对象通过事实表与另一个维表中的对象相关联，这样建立各个维表对象之间的联系&lt;br/&gt;维表：用于存放维度信息，包括维的属性和层次结构；&lt;br/&gt;事实表：是用来记录业务事实并做相应指标统计的表。同维表相比，事实表记录数量很多&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1089984/202006/1089984-20200611082417958-1020497555.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;雪花模型是对星形模型的扩展，每一个维表都可以向外连接多个详细类别表。除了具有星形模式中维表的功能外，还连接对事实表进行详细描述的维度，可进一步细化查看数据的粒度&lt;br/&gt;例如：地点维表包含属性集{location_id，街道，城市，省，国家}。这种模式通过地点维度表的city_id与城市维度表的city_id相关联，得到如{101，“解放大道10号”，“武汉”，“湖北省”，“中国”}、{255，“解放大道85号”，“武汉”，“湖北省”，“中国”}这样的记录。&lt;br/&gt;星形模型是最基本的模式，一个星形模型有多个维表，只存在一个事实表。在星形模式的基础上，用多个表来描述一个复杂维，构造维表的多层结构，就得到雪花模型&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1089984/202006/1089984-20200611082426180-1371664286.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1089984/202006/1089984-20200611082431179-2037875464.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;清晰数据结构：每一个数据分层都有它的作用域，这样我们在使用表的时候能更方便地定位和理解&lt;br/&gt;脏数据清洗：屏蔽原始数据的异常&lt;br/&gt;屏蔽业务影响：不必改一次业务就需要重新接入数据&lt;br/&gt;数据血缘追踪：简单来讲可以这样理解，我们最终给业务呈现的是能直接使用的一张业务表，但是它的来源有很多，如果有一张来源表出问题了，我们希望能够快速准确地定位到问题，并清楚它的危害范围。&lt;br/&gt;减少重复开发：规范数据分层，开发一些通用的中间层数据，能够减少极大的重复计算。&lt;br/&gt;把复杂问题简单化。将一个复杂的任务分解成多个步骤来完成，每一层只处理单一的步骤，比较简单和容易理解。便于维护数据的准确性，当数据出现问题之后，可以不用修复所有的数据，只需要从有问题的步骤开始修复。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1089984/202006/1089984-20200611082441396-1089088819.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;数据仓库的数据直接对接OLAP或日志类数据，&lt;br/&gt;用户画像只是站在用户的角度，对数据仓库数据做进一步的建模加工。因此每天画像标签相关数据的调度依赖上游数据仓库相关任务执行完成。&lt;/p&gt;
&lt;p&gt;在了解了数据仓库以后，我们就可以进行标签的计算了。在开发好标签的逻辑以后，将数据写入hive和druid中，完成实时与离线的标签开发工作。&lt;/p&gt;

&lt;h2 id=&quot;flink--hive&quot;&gt;flink hive&lt;/h2&gt;
&lt;p&gt;Flink从1.9开始支持集成Hive，不过1.9版本为beta版，不推荐在生产环境中使用。在最新版Flink1.10版本，标志着对 Blink的整合宣告完成，随着对 Hive 的生产级别集成，Hive作为数据仓库系统的绝对核心，承担着绝大多数的离线数据ETL计算和数据管理，期待Flink未来对Hive的完美支持。&lt;/p&gt;
&lt;p&gt;而 HiveCatalog 会与一个 Hive Metastore 的实例连接，提供元数据持久化的能力。要使用 Flink 与 Hive 进行交互，用户需要配置一个 HiveCatalog，并通过 HiveCatalog 访问 Hive 中的元数据。&lt;/p&gt;
&lt;h4 id=&quot;添加依赖&quot;&gt;添加依赖&lt;/h4&gt;
&lt;p&gt;要与Hive集成，需要在Flink的lib目录下添加额外的依赖jar包，以使集成在Table API程序或SQL Client中的SQL中起作用。或者，可以将这些依赖项放在文件夹中，并分别使用Table API程序或SQL Client 的&lt;code&gt;-C&lt;/code&gt; 或&lt;code&gt;-l&lt;/code&gt;选项将它们添加到classpath中。本文使用第一种方式，即将jar包直接复制到$FLINK_HOME/lib目录下。本文使用的Hive版本为2.3.4(对于不同版本的Hive，可以参照官网选择不同的jar包依赖)，总共需要3个jar包，如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;flink-connector-hive_2.11-1.10.0.jar&lt;/li&gt;
&lt;li&gt;flink-shaded-hadoop-2-uber-2.7.5-8.0.jar&lt;/li&gt;
&lt;li&gt;hive-exec-2.3.4.jar&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;添加maven依赖&quot;&gt;添加Maven依赖&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;&amp;lt;!-- Flink Dependency --&amp;gt;
&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;org.apache.flink&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;flink-connector-hive_2.11&amp;lt;/artifactId&amp;gt;
  &amp;lt;version&amp;gt;1.10.0&amp;lt;/version&amp;gt;
  &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt;
&amp;lt;/dependency&amp;gt;

&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;org.apache.flink&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;flink-table-api-java-bridge_2.11&amp;lt;/artifactId&amp;gt;
  &amp;lt;version&amp;gt;1.10.0&amp;lt;/version&amp;gt;
  &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt;
&amp;lt;/dependency&amp;gt;

&amp;lt;!-- Hive Dependency --&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.apache.hive&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;hive-exec&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;${hive.version}&amp;lt;/version&amp;gt;
    &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;实例代码&quot;&gt;实例代码&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;package com.flink.sql.hiveintegration;

import org.apache.flink.table.api.EnvironmentSettings;
import org.apache.flink.table.api.TableEnvironment;
import org.apache.flink.table.catalog.hive.HiveCatalog;


public class FlinkHiveIntegration {

    public static void main(String[] args) throws Exception {

        EnvironmentSettings settings = EnvironmentSettings
                .newInstance()
                .useBlinkPlanner() // 使用BlinkPlanner
                .inBatchMode() // Batch模式，默认为StreamingMode
                .build();

        //使用StreamingMode
       /* EnvironmentSettings settings = EnvironmentSettings
                .newInstance()
                .useBlinkPlanner() // 使用BlinkPlanner
                .inStreamingMode() // StreamingMode
                .build();*/

        TableEnvironment tableEnv = TableEnvironment.create(settings);

        String name = &quot;myhive&quot;;      // Catalog名称，定义一个唯一的名称表示
        String defaultDatabase = &quot;qfbap_ods&quot;;  // 默认数据库名称
        String hiveConfDir = &quot;/opt/modules/apache-hive-2.3.4-bin/conf&quot;;  // hive-site.xml路径
        String version = &quot;2.3.4&quot;;       // Hive版本号

        HiveCatalog hive = new HiveCatalog(name, defaultDatabase, hiveConfDir, version);

        tableEnv.registerCatalog(&quot;myhive&quot;, hive);
        tableEnv.useCatalog(&quot;myhive&quot;);
        // 创建数据库，目前不支持创建hive表
        String createDbSql = &quot;CREATE DATABASE IF NOT EXISTS myhive.test123&quot;;

        tableEnv.sqlUpdate(createDbSql);  

    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;flink--druid&quot;&gt;Flink Druid&lt;/h2&gt;
&lt;p&gt;可以将Flink分析好的数据写回kafka，然后在druid中接入数据，也可以将数据直接写入druid，以下为示例代码：&lt;/p&gt;
&lt;h4 id=&quot;依赖&quot;&gt;依赖&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;project xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;
    &amp;lt;parent&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;2.1.8.RELEASE&amp;lt;/version&amp;gt;
        &amp;lt;relativePath/&amp;gt; &amp;lt;!-- lookup parent from repository --&amp;gt;
    &amp;lt;/parent&amp;gt;
    &amp;lt;groupId&amp;gt;com.flinkdruid&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;FlinkDruid&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt;
    &amp;lt;name&amp;gt;FlinkDruid&amp;lt;/name&amp;gt;
    &amp;lt;description&amp;gt;Flink Druid Connection&amp;lt;/description&amp;gt;

    &amp;lt;properties&amp;gt;
        &amp;lt;java.version&amp;gt;1.8&amp;lt;/java.version&amp;gt;
    &amp;lt;/properties&amp;gt;

    &amp;lt;dependencies&amp;gt;

        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.apache.flink&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;flink-core&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;1.9.0&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.apache.flink&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;flink-clients_2.12&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;1.9.0&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;

    &amp;lt;/dependencies&amp;gt;

    &amp;lt;build&amp;gt;
        &amp;lt;plugins&amp;gt;
            &amp;lt;plugin&amp;gt;
                &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;
            &amp;lt;/plugin&amp;gt;
        &amp;lt;/plugins&amp;gt;
    &amp;lt;/build&amp;gt;

&amp;lt;/project&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;示例代码&quot;&gt;示例代码&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;@SpringBootApplication
public class FlinkDruidApp {


    private static String url = &quot;http://localhost:8200/v1/post/wikipedia&quot;;

    private static RestTemplate template;

    private static HttpHeaders headers;


    FlinkDruidApp() {

        template = new RestTemplate();
        headers = new HttpHeaders();
        headers.setAccept(Arrays.asList(MediaType.APPLICATION_JSON));
        headers.setContentType(MediaType.APPLICATION_JSON);

    }

    public static void main(String[] args) throws Exception {

        SpringApplication.run(FlinkDruidApp.class, args);

        // Creating Flink Execution Environment
        ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment();

        //Define data source
        DataSet&amp;lt;String&amp;gt; data = env.readTextFile(&quot;/wikiticker-2015-09-12-sampled.json&quot;);

        // Trasformation on the data 
        data.map(x -&amp;gt; {

            return httpsPost(x).toString();
        }).print();


    }

    // http post method to post data in Druid
    private static ResponseEntity&amp;lt;String&amp;gt; httpsPost(String json) {

        HttpEntity&amp;lt;String&amp;gt; requestEntity =
                new HttpEntity&amp;lt;&amp;gt;(json, headers);
        ResponseEntity&amp;lt;String&amp;gt; response =
                template.exchange(&quot;http://localhost:8200/v1/post/wikipedia&quot;, HttpMethod.POST, requestEntity,
                        String.class);

        return response;
    }

    @Bean
    public RestTemplate restTemplate() {
        return new RestTemplate();
    } 

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;标签的开发工作繁琐，需要不断的开发并且优化，但是如何将做好的标签提供出去产生真正的价值呢？ 下一章，我们将介绍用户画像产品化,未完待续~&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参考文献&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;《用户画像：方法论与工程化解决方案》&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;更多实时数据分析相关博文与科技资讯，欢迎关注 “实时流式计算”&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1089984/202005/1089984-20200511083216576-1437389309.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 11 Jun 2020 00:31:00 +0000</pubDate>
<dc:creator>独孤风</dc:creator>
<og:description>​ 数据接入 数据的接入可以通过将数据实时写入Kafka进行接入，不管是直接的写入还是通过oracle和mysql的实时接入方式，比如oracle的ogg，mysql的binlog ogg Golde</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tree1123/p/13091036.html</dc:identifier>
</item>
<item>
<title>akka-typed(6) - cluster：group router, cluster-load-balancing - 雪川大虫</title>
<link>http://www.cnblogs.com/tiger-xc/p/13091012.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tiger-xc/p/13091012.html</guid>
<description>&lt;p&gt;&lt;span&gt;先谈谈akka-typed的router actor。route 分pool router, group router两类。我们先看看pool-router的使用示范：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;      val pool = Routers.pool(poolSize = &lt;span&gt;4&lt;/span&gt;&lt;span&gt;)(
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; make sure the workers are restarted if they fail&lt;/span&gt;
&lt;span&gt;        Behaviors.supervise(WorkerRoutee()).onFailure[Exception](SupervisorStrategy.restart))
      val router &lt;/span&gt;= ctx.spawn(pool, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;worker-pool&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

      (&lt;/span&gt;&lt;span&gt;0&lt;/span&gt; to &lt;span&gt;10&lt;/span&gt;).&lt;span&gt;foreach&lt;/span&gt; { n =&amp;gt;&lt;span&gt;
        router &lt;/span&gt;! WorkerRoutee.DoLog(s&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;msg $n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;)&lt;/span&gt;
      }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;上面例子里的pool是个pool-router，意思是一个有4个routees的routee池。每个routee都是通过WorkerRoutee()构建的，意味着routee池中只有一个种类的actor。pool-router是通过工厂方法直接在本地（JVM）构建（spawn）所有的routee。也就是说所有routee都是router的子actor。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;再看看group-router的使用例子：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;val serviceKey = ServiceKey[Worker.Command](&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;log-worker&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; this would likely happen elsewhere - if we create it locally we
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; can just as well use a pool&lt;/span&gt;
      val workerRoutee = ctx.spawn(WorkerRoutee(), &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;worker-route&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
      ctx.system.receptionist &lt;/span&gt;!&lt;span&gt; Receptionist.Register(serviceKey, workerRoutee)

      val group &lt;/span&gt;=&lt;span&gt; Routers.group(serviceKey)
      val router &lt;/span&gt;= ctx.spawn(group, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;worker-group&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; the group router will stash messages until it sees the first listing of registered
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; services from the receptionist, so it is safe to send messages right away&lt;/span&gt;
      (&lt;span&gt;0&lt;/span&gt; to &lt;span&gt;10&lt;/span&gt;).&lt;span&gt;foreach&lt;/span&gt; { n =&amp;gt;&lt;span&gt;
        router &lt;/span&gt;! WorkerRoutee.DoLog(s&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;msg $n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
      }&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;group-router与pool-router有较多分别：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、routee是在router之外构建的，router是用一个key通过Receptionist获取同key的actor清单作为routee group的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、Receptionist是集群全局的。任何节点上的actor都可以发送注册消息在Receptionist上登记&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、没有size限制，任何actor一旦在Receptionist上登记即变成routee，接受router管理&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;应该说如果想把运算任务分配在集群里的各节点上并行运算实现load-balance效果，group-router是最合适的选择。不过对不同的运算任务需要多少routee则需要用户自行决定，不像以前akka-classic里通过cluster-metrics根据节点负载情况自动增减routee实例那么方便。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Receptionist: 既然说到，那么就再深入一点介绍Receptionist的应用：上面提到，Receptionist是集群全局的。就是说任何节点上的actor都可以在Receptonist上注册形成一个生存在集群中不同节点的actor清单。如果Receptionist把这个清单提供给一个用户，那么这个用户就可以把运算任务配置到各节点上，实现某种意义上的分布式运算模式。Receptionist的使用方式是：通过向本节点的Receptionist发送消息去登记ActorRef，然后通过Receptionist发布的登记变化消息即可获取最新的ActorRef清单：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  val WorkerServiceKey = ServiceKey[Worker.TransformText](&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Worker&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

  ctx.system.receptionist &lt;/span&gt;!&lt;span&gt; Receptionist.Register(WorkerServiceKey, ctx.self)

  ctx.system.receptionist &lt;/span&gt;! Receptionist.Subscribe(Worker.WorkerServiceKey, subscriptionAdapter)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;Receptionist的登记和清单获取是以ServiceKey作为关联的。那么获取的清单内应该全部是一种类型的actor，只不过它们的地址可能是跨节点的，但它们只能进行同一种运算。从另一个角度说，一项任务是分布在不同节点的actor并行进行运算的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在上篇讨论里提过：如果发布-订阅机制是在两个actor之间进行的，那么这两个actor也需要在规定的信息交流协议框架下作业：我们必须注意消息类型，提供必要的消息类型转换机制。下面是一个Receptionist登记示范：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;object&lt;/span&gt;&lt;span&gt; Worker {

  val WorkerServiceKey &lt;/span&gt;= ServiceKey[Worker.TransformText](&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Worker&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

  &lt;/span&gt;&lt;span&gt;sealed&lt;/span&gt;&lt;span&gt; trait Command
  final &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TransformText(text: String, replyTo: ActorRef[TextTransformed]) extends Command with CborSerializable
  final &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TextTransformed(text: String) extends CborSerializable

  def apply(): Behavior[Command] &lt;/span&gt;=&lt;span&gt;
    Behaviors.setup { ctx &lt;/span&gt;=&amp;gt;
      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; each worker registers themselves with the receptionist&lt;/span&gt;
      ctx.log.info(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Registering myself with receptionist&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
      ctx.system.receptionist &lt;/span&gt;!&lt;span&gt; Receptionist.Register(WorkerServiceKey, ctx.self)

      Behaviors.receiveMessage {
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; TransformText(text, replyTo) =&amp;gt;&lt;span&gt;
          replyTo &lt;/span&gt;!&lt;span&gt; TextTransformed(text.toUpperCase)
          Behaviors.same
      }
    }
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;Receptionist登记比较直接：登记者不需要Receptionist返回消息，所以随便用ctx.self作为消息的sender。注意TransformText的replyTo: ActorRef[TextTransformed]，代表sender是个可以处理TextTransformed消息类型的actor。实际上，在sender方是通过ctx.ask提供了TextTransformed的类型转换。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Receptionist.Subscribe需要Receptionist返回一个actor清单，所以是个request/response模式。那么发送给Receptionist消息中的replyTo必须是发送者能处理的类型，如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  def apply(): Behavior[Event] = Behaviors.setup { ctx =&amp;gt;&lt;span&gt;
    Behaviors.withTimers { timers &lt;/span&gt;=&amp;gt;
      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; subscribe to available workers&lt;/span&gt;
      val subscriptionAdapter =&lt;span&gt; ctx.messageAdapter[Receptionist.Listing] {
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; Worker.WorkerServiceKey.Listing(workers) =&amp;gt;&lt;span&gt;
          WorkersUpdated(workers)
      }
      ctx.system.receptionist &lt;/span&gt;!&lt;span&gt; Receptionist.Subscribe(Worker.WorkerServiceKey, subscriptionAdapter)

...
    }
  &lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;ctx.messageAdapter进行了一个从Receptionist.Listing返回类型到WorkersUpdated类型的转换机制登记：从Receptionist回复的List类型会被转换成WorkersUpdated类型，如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;...
   Behaviors.receiveMessage {
      &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; WorkersUpdated(newWorkers) =&amp;gt;&lt;span&gt;
        ctx.log.info(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;List of services registered with the receptionist changed: {}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, newWorkers)

...&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;另外，上面提过的TextTransformed转换如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;          ctx.ask[Worker.TransformText,Worker.TextTransformed](selectedWorker, Worker.TransformText(text, _)) {
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; Success(transformedText) =&amp;gt;&lt;span&gt; TransformCompleted(transformedText.text, text)
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; Failure(ex) =&amp;gt; JobFailed(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Processing timed out&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, text)
          }&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;ctx.ask将TextTransformed转换成TransformCompleted。完整的Behavior定义如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;object&lt;/span&gt;&lt;span&gt; Frontend {

  &lt;/span&gt;&lt;span&gt;sealed&lt;/span&gt;&lt;span&gt; trait Event
  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;case&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt; Tick extends Event
  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; final &lt;span&gt;case&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; WorkersUpdated(newWorkers: Set[ActorRef[Worker.TransformText]]) extends Event
  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; final &lt;span&gt;case&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TransformCompleted(originalText: String, transformedText: String) extends Event
  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; final &lt;span&gt;case&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; JobFailed(why: String, text: String) extends Event


  def apply(): Behavior[Event] &lt;/span&gt;= Behaviors.setup { ctx =&amp;gt;&lt;span&gt;
    Behaviors.withTimers { timers &lt;/span&gt;=&amp;gt;
      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; subscribe to available workers&lt;/span&gt;
      val subscriptionAdapter =&lt;span&gt; ctx.messageAdapter[Receptionist.Listing] {
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; Worker.WorkerServiceKey.Listing(workers) =&amp;gt;&lt;span&gt;
          WorkersUpdated(workers)
      }
      ctx.system.receptionist &lt;/span&gt;!&lt;span&gt; Receptionist.Subscribe(Worker.WorkerServiceKey, subscriptionAdapter)

      timers.startTimerWithFixedDelay(Tick, Tick, &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;.seconds)

      running(ctx, IndexedSeq.empty, jobCounter &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
    }
  }

  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; def running(ctx: ActorContext[Event], workers: IndexedSeq[ActorRef[Worker.TransformText]], jobCounter: Int): Behavior[Event] =&lt;span&gt;
    Behaviors.receiveMessage {
      &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; WorkersUpdated(newWorkers) =&amp;gt;&lt;span&gt;
        ctx.log.info(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;List of services registered with the receptionist changed: {}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, newWorkers)
        running(ctx, newWorkers.toIndexedSeq, jobCounter)
      &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; Tick =&amp;gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (workers.isEmpty) {
          ctx.log.warn(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Got tick request but no workers available, not sending any work&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
          Behaviors.same
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; how much time can pass before we consider a request failed&lt;/span&gt;
          &lt;span&gt;implicit&lt;/span&gt; val timeout: Timeout = &lt;span&gt;5&lt;/span&gt;&lt;span&gt;.seconds
          val selectedWorker &lt;/span&gt;= workers(jobCounter %&lt;span&gt; workers.size)
          ctx.log.info(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Sending work for processing to {}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, selectedWorker)
          val text &lt;/span&gt;= s&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello-$jobCounter&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
          ctx.ask[Worker.TransformText,Worker.TextTransformed](selectedWorker, Worker.TransformText(text, _)) {
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; Success(transformedText) =&amp;gt;&lt;span&gt; TransformCompleted(transformedText.text, text)
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; Failure(ex) =&amp;gt; JobFailed(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Processing timed out&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, text)
          }
          running(ctx, workers, jobCounter &lt;/span&gt;+ &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
        }
      &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; TransformCompleted(originalText, transformedText) =&amp;gt;&lt;span&gt;
        ctx.log.info(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Got completed transform of {}: {}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, originalText, transformedText)
        Behaviors.same

      &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; JobFailed(why, text) =&amp;gt;&lt;span&gt;
        ctx.log.warn(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Transformation of text {} failed. Because: {}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, text, why)
        Behaviors.same

    }&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;现在我们可以示范用group-router来实现某种跨节点的分布式运算。因为group-router是通过Receptionist来实现对routees管理的，而Receptionist是集群全局的，意味着如果我们在各节点上构建routee，然后向Receptionist登记，就会形成一个跨节点的routee ActorRef清单。如果把任务分配到这个清单上的routee上去运算，应该能实现集群节点负载均衡的效果。下面我们就示范这个loadbalancer。流程很简单：在一个接入点 （serviceActor）中构建workersRouter，然后3个workerRoutee并向Receptionist登记，把接到的任务分解成子任务逐个发送给workersRouter。每个workerRoutee完成任务后将结果发送给一个聚合器Aggregator，Aggregator在核对完成接收所有workerRoutee返回的结果后再把汇总结果返回serverActor。先看看这个serverActor：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;object&lt;/span&gt;&lt;span&gt; Service {
  val routerServiceKey &lt;/span&gt;= ServiceKey[WorkerRoutee.Command](&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;workers-router&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

  &lt;/span&gt;&lt;span&gt;sealed&lt;/span&gt;&lt;span&gt; trait Command extends CborSerializable

  &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ProcessText(text: String) extends Command {
    require(text.nonEmpty)
  }

  &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; WrappedResult(res: Aggregator.Response) extends Command

  def serviceBehavior(workersRouter: ActorRef[WorkerRoutee.Command]): Behavior[Command] &lt;/span&gt;= Behaviors.setup[Command] { ctx =&amp;gt;&lt;span&gt;
    val aggregator &lt;/span&gt;= ctx.spawn(Aggregator(), &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;aggregator&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    val aggregatorRef: ActorRef[Aggregator.Response] &lt;/span&gt;=&lt;span&gt; ctx.messageAdapter(WrappedResult)
    Behaviors.receiveMessage {
      &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; ProcessText(text) =&amp;gt;&lt;span&gt;
        ctx.log.info(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;******************** received ProcessText command: {} ****************&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,text)
        val words &lt;/span&gt;= text.split(&lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;).toIndexedSeq
        aggregator &lt;/span&gt;!&lt;span&gt; Aggregator.CountText(words.size, aggregatorRef)
        words.&lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; { word =&amp;gt;&lt;span&gt;
          workersRouter &lt;/span&gt;!&lt;span&gt; WorkerRoutee.Count(word, aggregator)
        }
        Behaviors.same
      &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; WrappedResult(msg) =&amp;gt;&lt;span&gt;
        msg match {
          &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; Aggregator.Result(res) =&amp;gt;&lt;span&gt;
            ctx.log.info(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;************** mean length of words = {} **********&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, res)
        }
        Behaviors.same
    }
  }

  def singletonService(ctx: ActorContext[Command], workersRouter: ActorRef[WorkerRoutee.Command]) &lt;/span&gt;=&lt;span&gt; {
    val singletonSettings &lt;/span&gt;=&lt;span&gt; ClusterSingletonSettings(ctx.system)
      .withRole(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;front&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    SingletonActor(
      Behaviors.supervise(
        serviceBehavior(workersRouter)
      ).onFailure(
        SupervisorStrategy
          .restartWithBackoff(minBackoff &lt;/span&gt;= &lt;span&gt;10&lt;/span&gt;.seconds, maxBackoff = &lt;span&gt;60&lt;/span&gt;.seconds, randomFactor = &lt;span&gt;0.1&lt;/span&gt;&lt;span&gt;)
          .withMaxRestarts(&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;)
          .withResetBackoffAfter(&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;.seconds)
      )
      , &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;singletonActor&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    ).withSettings(singletonSettings)
  }

  def apply(): Behavior[Command] &lt;/span&gt;= Behaviors.setup[Command] { ctx =&amp;gt;&lt;span&gt;
    val cluster &lt;/span&gt;=&lt;span&gt; Cluster(ctx.system)
    val workersRouter &lt;/span&gt;=&lt;span&gt; ctx.spawn(
      Routers.group(routerServiceKey)
        .withRoundRobinRouting(),
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;workersRouter&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    )
    (&lt;/span&gt;&lt;span&gt;0&lt;/span&gt; until &lt;span&gt;3&lt;/span&gt;).&lt;span&gt;foreach&lt;/span&gt; { n =&amp;gt;&lt;span&gt;
      val routee &lt;/span&gt;= ctx.spawn(WorkerRoutee(cluster.selfMember.address.toString), s&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;work-routee-$n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
      ctx.system.receptionist &lt;/span&gt;!&lt;span&gt; Receptionist.register(routerServiceKey, routee)
    }
    val singletonActor &lt;/span&gt;=&lt;span&gt; ClusterSingleton(ctx.system).init(singletonService(ctx, workersRouter))
    Behaviors.receiveMessage {
      &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; job@ProcessText(text) =&amp;gt;&lt;span&gt;
        singletonActor &lt;/span&gt;!&lt;span&gt; job
        Behaviors.same
    }
  }

}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;整体goup-router和routee的构建是在apply()里，并把接到的任务转发给singletonActor。singletonActor是以serviceBehavior为核心的一个actor。在servceBehavior里把收到的任务分解并分别发送给workersRouter。值得注意的是：serviceBehavior期望接收从Aggregator的回应，它们之间存在request/response模式信息交流，所以需要Aggregator.Response到WrappedResult的类型转换机制。还有：子任务是通过workersRoute发送给个workerRoutee的，我们需要各workerRoutee把运算结果返给给Aggregator,所以发送给workersRouter的消息包含了Aggregator的ActorRef，如：workersRouter ! WorkerRoutee.Count(cnt,aggregatorRef)。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Aggregator是个persistentActor, 如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;74&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;object&lt;/span&gt;&lt;span&gt; Aggregator {
  &lt;/span&gt;&lt;span&gt;sealed&lt;/span&gt;&lt;span&gt; trait Command
  &lt;/span&gt;&lt;span&gt;sealed&lt;/span&gt;&lt;span&gt; trait Event extends  CborSerializable
  &lt;/span&gt;&lt;span&gt;sealed&lt;/span&gt;&lt;span&gt; trait Response

  &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CountText(cnt: Int, replyTo: ActorRef[Response]) extends Command
  &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MarkLength(word: String, len: Int) extends Command
  &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TextCounted(cnt: Int) extends Event
  &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LengthMarked(word: String, len: Int) extends Event
  &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Result(meanWordLength: Double) extends Response

  &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; State(expectedNum: Int = &lt;span&gt;0&lt;/span&gt;, lens: List[Int] =&lt;span&gt; Nil)

  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; replyTo: ActorRef[Response] =&lt;span&gt; _

  def commandHandler: (State,Command) &lt;/span&gt;=&amp;gt; Effect[Event,State] = (st,cmd) =&amp;gt;&lt;span&gt; {
    cmd match {
      &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; CountText(cnt,&lt;span&gt;ref&lt;/span&gt;) =&amp;gt;&lt;span&gt;
        replyTo &lt;/span&gt;= &lt;span&gt;ref&lt;/span&gt;&lt;span&gt;
        Effect.persist(TextCounted(cnt))
      &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; MarkLength(word,len) =&amp;gt;&lt;span&gt;
        Effect.persist(LengthMarked(word,len))
    }
  }
  def eventHandler: (State, Event) &lt;/span&gt;=&amp;gt; State = (st,ev) =&amp;gt;&lt;span&gt; {
    ev match {
      &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; TextCounted(cnt) =&amp;gt;&lt;span&gt;
        st.copy(expectedNum &lt;/span&gt;= cnt, lens =&lt;span&gt; Nil)
      &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; LengthMarked(word,len) =&amp;gt;&lt;span&gt;
        val state &lt;/span&gt;= st.copy(lens =&lt;span&gt; len :: st.lens)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (state.lens.size &amp;gt;=&lt;span&gt; state.expectedNum) {
          val meanWordLength &lt;/span&gt;= state.lens.sum.toDouble /&lt;span&gt; state.lens.size
          replyTo &lt;/span&gt;!&lt;span&gt; Result(meanWordLength)
          State()
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; state
    }
  }
  val takeSnapShot: (State,Event,Long) &lt;/span&gt;=&amp;gt; Boolean = (st,ev,seq) =&amp;gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (st.lens.isEmpty) {
          &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (ev.isInstanceOf[LengthMarked])
            &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
          &lt;span&gt;else&lt;/span&gt;
            &lt;span&gt;false&lt;/span&gt;&lt;span&gt;
      } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;
         &lt;span&gt;false&lt;/span&gt;&lt;span&gt;
  }
  def apply(): Behavior[Command] &lt;/span&gt;=&lt;span&gt; Behaviors.supervise(
    Behaviors.setup[Command] { ctx &lt;/span&gt;=&amp;gt;&lt;span&gt;
      EventSourcedBehavior(
        persistenceId &lt;/span&gt;= PersistenceId(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2333&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),
        emptyState &lt;/span&gt;=&lt;span&gt; State(),
        commandHandler &lt;/span&gt;=&lt;span&gt; commandHandler,
        eventHandler &lt;/span&gt;=&lt;span&gt; eventHandler
      ).onPersistFailure(
        SupervisorStrategy
          .restartWithBackoff(minBackoff &lt;/span&gt;= &lt;span&gt;10&lt;/span&gt;.seconds, maxBackoff = &lt;span&gt;60&lt;/span&gt;.seconds, randomFactor = &lt;span&gt;0.1&lt;/span&gt;&lt;span&gt;)
          .withMaxRestarts(&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;)
          .withResetBackoffAfter(&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;.seconds)
      ).receiveSignal {
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; (state, RecoveryCompleted) =&amp;gt;&lt;span&gt;
          ctx.log.info(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;**************Recovery Completed with state: {}***************&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,state)
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; (state, SnapshotCompleted(meta))  =&amp;gt;&lt;span&gt;
          ctx.log.info(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;**************Snapshot Completed with state: {},id({},{})***************&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,state,meta.persistenceId, meta.sequenceNr)
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; (state,RecoveryFailed(err)) =&amp;gt;&lt;span&gt;
          ctx.log.error(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;*************recovery failed with: {}***************&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,err.getMessage)
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; (state,SnapshotFailed(meta,err)) =&amp;gt;&lt;span&gt;
          ctx.log.error(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;***************snapshoting failed with: {}*************&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,err.getMessage)
      }.snapshotWhen(takeSnapShot)
    }
  ).onFailure(
    SupervisorStrategy
      .restartWithBackoff(minBackoff &lt;/span&gt;= &lt;span&gt;10&lt;/span&gt;.seconds, maxBackoff = &lt;span&gt;60&lt;/span&gt;.seconds, randomFactor = &lt;span&gt;0.1&lt;/span&gt;&lt;span&gt;)
      .withMaxRestarts(&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;)
      .withResetBackoffAfter(&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;.seconds)
  )
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;注意这个takeSnapShot函数：这个函数是在EventSourcedBehavior.snapshotWhen(takeSnapShot)调用的。传入参数是（State,Event,seqenceNr)，我们需要对State,Event的当前值进行分析后返回true代表做一次snapshot。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;看看一部分显示就知道任务已经分配到几个节点上的routee：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;20&lt;/span&gt;:&lt;span&gt;06&lt;/span&gt;:&lt;span&gt;59.072&lt;/span&gt; [ClusterSystem-akka.actor.&lt;span&gt;default&lt;/span&gt;-dispatcher-&lt;span&gt;15&lt;/span&gt;] INFO com.learn.akka.WorkerRoutee$ - ************** processing [&lt;span&gt;this&lt;/span&gt;] on akka:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ClusterSystem@127.0.0.1:51182 ***********&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;:&lt;span&gt;06&lt;/span&gt;:&lt;span&gt;59.072&lt;/span&gt; [ClusterSystem-akka.actor.&lt;span&gt;default&lt;/span&gt;-dispatcher-&lt;span&gt;3&lt;/span&gt;] INFO com.learn.akka.WorkerRoutee$ - ************** processing [text] on akka:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ClusterSystem@127.0.0.1:51182 ***********&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;:&lt;span&gt;06&lt;/span&gt;:&lt;span&gt;59.072&lt;/span&gt; [ClusterSystem-akka.actor.&lt;span&gt;default&lt;/span&gt;-dispatcher-&lt;span&gt;36&lt;/span&gt;] INFO com.learn.akka.WorkerRoutee$ - ************** processing [be] on akka:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ClusterSystem@127.0.0.1:51182 ***********&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;:&lt;span&gt;06&lt;/span&gt;:&lt;span&gt;59.236&lt;/span&gt; [ClusterSystem-akka.actor.&lt;span&gt;default&lt;/span&gt;-dispatcher-&lt;span&gt;16&lt;/span&gt;] INFO com.learn.akka.WorkerRoutee$ - ************** processing [will] on akka:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ClusterSystem@127.0.0.1:51173 ***********&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;:&lt;span&gt;06&lt;/span&gt;:&lt;span&gt;59.236&lt;/span&gt; [ClusterSystem-akka.actor.&lt;span&gt;default&lt;/span&gt;-dispatcher-&lt;span&gt;26&lt;/span&gt;] INFO com.learn.akka.WorkerRoutee$ - ************** processing [&lt;span&gt;is&lt;/span&gt;] on akka:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ClusterSystem@127.0.0.1:25251 ***********&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;:&lt;span&gt;06&lt;/span&gt;:&lt;span&gt;59.236&lt;/span&gt; [ClusterSystem-akka.actor.&lt;span&gt;default&lt;/span&gt;-dispatcher-&lt;span&gt;13&lt;/span&gt;] INFO com.learn.akka.WorkerRoutee$ - ************** processing [the] on akka:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ClusterSystem@127.0.0.1:51173 ***********&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;:&lt;span&gt;06&lt;/span&gt;:&lt;span&gt;59.236&lt;/span&gt; [ClusterSystem-akka.actor.&lt;span&gt;default&lt;/span&gt;-dispatcher-&lt;span&gt;3&lt;/span&gt;] INFO com.learn.akka.WorkerRoutee$ - ************** processing [that] on akka:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ClusterSystem@127.0.0.1:25251 ***********&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;:&lt;span&gt;06&lt;/span&gt;:&lt;span&gt;59.236&lt;/span&gt; [ClusterSystem-akka.actor.&lt;span&gt;default&lt;/span&gt;-dispatcher-&lt;span&gt;3&lt;/span&gt;] INFO com.learn.akka.WorkerRoutee$ - ************** processing [analyzed] on akka:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ClusterSystem@127.0.0.1:25251 ***********&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这个例子的源代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;101&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package com.learn.akka

import akka.actor.typed._
import akka.persistence.typed._
import akka.persistence.typed.scaladsl._
import scala.concurrent.duration._
import akka.actor.typed.receptionist._
import akka.actor.typed.scaladsl.Behaviors
import akka.actor.typed.scaladsl._
import akka.cluster.typed.Cluster
import akka.cluster.typed.ClusterSingleton
import akka.cluster.typed.ClusterSingletonSettings
import akka.cluster.typed.SingletonActor
import com.typesafe.config.ConfigFactory

&lt;/span&gt;&lt;span&gt;object&lt;/span&gt;&lt;span&gt; WorkerRoutee {
  &lt;/span&gt;&lt;span&gt;sealed&lt;/span&gt;&lt;span&gt; trait Command extends CborSerializable
  &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Count(word: String, replyTo: ActorRef[Aggregator.Command]) extends Command

  def apply(nodeAddress: String): Behavior[Command] &lt;/span&gt;= Behaviors.setup {ctx =&amp;gt;&lt;span&gt;
    Behaviors.receiveMessage[Command] {
      &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; Count(word,replyTo) =&amp;gt;&lt;span&gt;
        ctx.log.info(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;************** processing [{}] on {} ***********&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,word,nodeAddress)
        replyTo &lt;/span&gt;!&lt;span&gt; Aggregator.MarkLength(word,word.length)
        Behaviors.same
    }
  }
}
&lt;/span&gt;&lt;span&gt;object&lt;/span&gt;&lt;span&gt; Aggregator {
  &lt;/span&gt;&lt;span&gt;sealed&lt;/span&gt;&lt;span&gt; trait Command
  &lt;/span&gt;&lt;span&gt;sealed&lt;/span&gt;&lt;span&gt; trait Event extends  CborSerializable
  &lt;/span&gt;&lt;span&gt;sealed&lt;/span&gt;&lt;span&gt; trait Response

  &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CountText(cnt: Int, replyTo: ActorRef[Response]) extends Command
  &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MarkLength(word: String, len: Int) extends Command
  &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TextCounted(cnt: Int) extends Event
  &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LengthMarked(word: String, len: Int) extends Event
  &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Result(meanWordLength: Double) extends Response

  &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; State(expectedNum: Int = &lt;span&gt;0&lt;/span&gt;, lens: List[Int] =&lt;span&gt; Nil)

  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; replyTo: ActorRef[Response] =&lt;span&gt; _

  def commandHandler: (State,Command) &lt;/span&gt;=&amp;gt; Effect[Event,State] = (st,cmd) =&amp;gt;&lt;span&gt; {
    cmd match {
      &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; CountText(cnt,&lt;span&gt;ref&lt;/span&gt;) =&amp;gt;&lt;span&gt;
        replyTo &lt;/span&gt;= &lt;span&gt;ref&lt;/span&gt;&lt;span&gt;
        Effect.persist(TextCounted(cnt))
      &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; MarkLength(word,len) =&amp;gt;&lt;span&gt;
        Effect.persist(LengthMarked(word,len))
    }
  }
  def eventHandler: (State, Event) &lt;/span&gt;=&amp;gt; State = (st,ev) =&amp;gt;&lt;span&gt; {
    ev match {
      &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; TextCounted(cnt) =&amp;gt;&lt;span&gt;
        st.copy(expectedNum &lt;/span&gt;= cnt, lens =&lt;span&gt; Nil)
      &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; LengthMarked(word,len) =&amp;gt;&lt;span&gt;
        val state &lt;/span&gt;= st.copy(lens =&lt;span&gt; len :: st.lens)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (state.lens.size &amp;gt;=&lt;span&gt; state.expectedNum) {
          val meanWordLength &lt;/span&gt;= state.lens.sum.toDouble /&lt;span&gt; state.lens.size
          replyTo &lt;/span&gt;!&lt;span&gt; Result(meanWordLength)
          State()
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; state
    }
  }
  val takeSnapShot: (State,Event,Long) &lt;/span&gt;=&amp;gt; Boolean = (st,ev,seq) =&amp;gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (st.lens.isEmpty) {
          &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (ev.isInstanceOf[LengthMarked])
            &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
          &lt;span&gt;else&lt;/span&gt;
            &lt;span&gt;false&lt;/span&gt;&lt;span&gt;
      } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;
         &lt;span&gt;false&lt;/span&gt;&lt;span&gt;
  }
  def apply(): Behavior[Command] &lt;/span&gt;=&lt;span&gt; Behaviors.supervise(
    Behaviors.setup[Command] { ctx &lt;/span&gt;=&amp;gt;&lt;span&gt;
      EventSourcedBehavior(
        persistenceId &lt;/span&gt;= PersistenceId(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2333&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),
        emptyState &lt;/span&gt;=&lt;span&gt; State(),
        commandHandler &lt;/span&gt;=&lt;span&gt; commandHandler,
        eventHandler &lt;/span&gt;=&lt;span&gt; eventHandler
      ).onPersistFailure(
        SupervisorStrategy
          .restartWithBackoff(minBackoff &lt;/span&gt;= &lt;span&gt;10&lt;/span&gt;.seconds, maxBackoff = &lt;span&gt;60&lt;/span&gt;.seconds, randomFactor = &lt;span&gt;0.1&lt;/span&gt;&lt;span&gt;)
          .withMaxRestarts(&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;)
          .withResetBackoffAfter(&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;.seconds)
      ).receiveSignal {
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; (state, RecoveryCompleted) =&amp;gt;&lt;span&gt;
          ctx.log.info(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;**************Recovery Completed with state: {}***************&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,state)
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; (state, SnapshotCompleted(meta))  =&amp;gt;&lt;span&gt;
          ctx.log.info(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;**************Snapshot Completed with state: {},id({},{})***************&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,state,meta.persistenceId, meta.sequenceNr)
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; (state,RecoveryFailed(err)) =&amp;gt;&lt;span&gt;
          ctx.log.error(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;*************recovery failed with: {}***************&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,err.getMessage)
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; (state,SnapshotFailed(meta,err)) =&amp;gt;&lt;span&gt;
          ctx.log.error(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;***************snapshoting failed with: {}*************&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,err.getMessage)
      }.snapshotWhen(takeSnapShot)
    }
  ).onFailure(
    SupervisorStrategy
      .restartWithBackoff(minBackoff &lt;/span&gt;= &lt;span&gt;10&lt;/span&gt;.seconds, maxBackoff = &lt;span&gt;60&lt;/span&gt;.seconds, randomFactor = &lt;span&gt;0.1&lt;/span&gt;&lt;span&gt;)
      .withMaxRestarts(&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;)
      .withResetBackoffAfter(&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;.seconds)
  )
}
&lt;/span&gt;&lt;span&gt;object&lt;/span&gt;&lt;span&gt; Service {
  val routerServiceKey &lt;/span&gt;= ServiceKey[WorkerRoutee.Command](&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;workers-router&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

  &lt;/span&gt;&lt;span&gt;sealed&lt;/span&gt;&lt;span&gt; trait Command extends CborSerializable

  &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ProcessText(text: String) extends Command {
    require(text.nonEmpty)
  }

  &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; WrappedResult(res: Aggregator.Response) extends Command

  def serviceBehavior(workersRouter: ActorRef[WorkerRoutee.Command]): Behavior[Command] &lt;/span&gt;= Behaviors.setup[Command] { ctx =&amp;gt;&lt;span&gt;
    val aggregator &lt;/span&gt;= ctx.spawn(Aggregator(), &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;aggregator&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    val aggregatorRef: ActorRef[Aggregator.Response] &lt;/span&gt;=&lt;span&gt; ctx.messageAdapter(WrappedResult)
    Behaviors.receiveMessage {
      &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; ProcessText(text) =&amp;gt;&lt;span&gt;
        ctx.log.info(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;******************** received ProcessText command: {} ****************&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,text)
        val words &lt;/span&gt;= text.split(&lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;).toIndexedSeq
        aggregator &lt;/span&gt;!&lt;span&gt; Aggregator.CountText(words.size, aggregatorRef)
        words.&lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; { word =&amp;gt;&lt;span&gt;
          workersRouter &lt;/span&gt;!&lt;span&gt; WorkerRoutee.Count(word, aggregator)
        }
        Behaviors.same
      &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; WrappedResult(msg) =&amp;gt;&lt;span&gt;
        msg match {
          &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; Aggregator.Result(res) =&amp;gt;&lt;span&gt;
            ctx.log.info(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;************** mean length of words = {} **********&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, res)
        }
        Behaviors.same
    }
  }

  def singletonService(ctx: ActorContext[Command], workersRouter: ActorRef[WorkerRoutee.Command]) &lt;/span&gt;=&lt;span&gt; {
    val singletonSettings &lt;/span&gt;=&lt;span&gt; ClusterSingletonSettings(ctx.system)
      .withRole(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;front&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    SingletonActor(
      Behaviors.supervise(
        serviceBehavior(workersRouter)
      ).onFailure(
        SupervisorStrategy
          .restartWithBackoff(minBackoff &lt;/span&gt;= &lt;span&gt;10&lt;/span&gt;.seconds, maxBackoff = &lt;span&gt;60&lt;/span&gt;.seconds, randomFactor = &lt;span&gt;0.1&lt;/span&gt;&lt;span&gt;)
          .withMaxRestarts(&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;)
          .withResetBackoffAfter(&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;.seconds)
      )
      , &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;singletonActor&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    ).withSettings(singletonSettings)
  }

  def apply(): Behavior[Command] &lt;/span&gt;= Behaviors.setup[Command] { ctx =&amp;gt;&lt;span&gt;
    val cluster &lt;/span&gt;=&lt;span&gt; Cluster(ctx.system)
    val workersRouter &lt;/span&gt;=&lt;span&gt; ctx.spawn(
      Routers.group(routerServiceKey)
        .withRoundRobinRouting(),
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;workersRouter&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    )
    (&lt;/span&gt;&lt;span&gt;0&lt;/span&gt; until &lt;span&gt;3&lt;/span&gt;).&lt;span&gt;foreach&lt;/span&gt; { n =&amp;gt;&lt;span&gt;
      val routee &lt;/span&gt;= ctx.spawn(WorkerRoutee(cluster.selfMember.address.toString), s&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;work-routee-$n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
      ctx.system.receptionist &lt;/span&gt;!&lt;span&gt; Receptionist.register(routerServiceKey, routee)
    }
    val singletonActor &lt;/span&gt;=&lt;span&gt; ClusterSingleton(ctx.system).init(singletonService(ctx, workersRouter))
    Behaviors.receiveMessage {
      &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; job@ProcessText(text) =&amp;gt;&lt;span&gt;
        singletonActor &lt;/span&gt;!&lt;span&gt; job
        Behaviors.same
    }
  }

}

&lt;/span&gt;&lt;span&gt;object&lt;/span&gt;&lt;span&gt; LoadBalance {
  def main(args: Array[String]): Unit &lt;/span&gt;=&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (args.isEmpty) {
      startup(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;compute&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;25251&lt;/span&gt;&lt;span&gt;)
      startup(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;compute&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;25252&lt;/span&gt;&lt;span&gt;)
      startup(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;compute&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;25253&lt;/span&gt;&lt;span&gt;)
      startup(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;front&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;25254&lt;/span&gt;&lt;span&gt;)
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
      require(args.size &lt;/span&gt;== &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Usage: role port&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
      startup(args(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;), args(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;).toInt)
    }
  }

  def startup(role: String, port: Int): Unit &lt;/span&gt;=&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Override the configuration of the port when specified as program argument&lt;/span&gt;
    val config =&lt;span&gt; ConfigFactory
      .parseString(s&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;
&lt;/span&gt;      akka.remote.artery.canonical.port=&lt;span&gt;$port
      akka.cluster.roles &lt;/span&gt;=&lt;span&gt; [$role]
      &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
      .withFallback(ConfigFactory.load(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cluster-persistence&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))

    val frontEnd &lt;/span&gt;= ActorSystem[Service.Command](Service(), &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ClusterSystem&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, config)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (role == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;front&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;) {
      println(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;*************** sending ProcessText command  ************&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
      frontEnd &lt;/span&gt;! Service.ProcessText(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;this is the text that will be analyzed&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    }

  }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;cluster-persistence.conf&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
akka.actor.allow-java-serialization =&lt;span&gt; on
akka {
  loglevel &lt;/span&gt;=&lt;span&gt; INFO
  actor {
    provider &lt;/span&gt;=&lt;span&gt; cluster
    serialization&lt;/span&gt;-&lt;span&gt;bindings {
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;com.learn.akka.CborSerializable&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; = jackson-&lt;span&gt;cbor
    }
  }
 remote {
    artery {
      canonical.hostname &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;127.0.0.1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
      canonical.port &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
    }
  }
  cluster {
    seed&lt;/span&gt;-nodes =&lt;span&gt; [
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;akka://ClusterSystem@127.0.0.1:25251&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;akka://ClusterSystem@127.0.0.1:25252&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
  }
  # use Cassandra to store both snapshots and the events of the persistent actors
  persistence {
    journal.plugin &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;akka.persistence.cassandra.journal&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    snapshot&lt;/span&gt;-store.plugin = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;akka.persistence.cassandra.snapshot&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
  }
}
akka.persistence.cassandra {
  # don&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;t use autocreate in production&lt;/span&gt;
  journal.keyspace = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;poc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
  journal.keyspace&lt;/span&gt;-autocreate =&lt;span&gt; on
  journal.tables&lt;/span&gt;-autocreate =&lt;span&gt; on
  snapshot.keyspace &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;poc_snapshot&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
  snapshot.keyspace&lt;/span&gt;-autocreate =&lt;span&gt; on
  snapshot.tables&lt;/span&gt;-autocreate =&lt;span&gt; on
}

datastax&lt;/span&gt;-java-&lt;span&gt;driver {
  basic.contact&lt;/span&gt;-points = [&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;192.168.11.189:9042&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
  basic.load&lt;/span&gt;-balancing-policy.local-datacenter = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;datacenter1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;build.sbt&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
name := &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;learn-akka-typed&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;

version :&lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0.1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;

scalaVersion :&lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2.13.1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
scalacOptions &lt;/span&gt;&lt;span&gt;in&lt;/span&gt; Compile ++= Seq(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-deprecation&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-feature&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-unchecked&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-Xlog-reflective-calls&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-Xlint&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
javacOptions &lt;/span&gt;&lt;span&gt;in&lt;/span&gt; Compile ++= Seq(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-Xlint:unchecked&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-Xlint:deprecation&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

val AkkaVersion &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2.6.5&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
val AkkaPersistenceCassandraVersion &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1.0.0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;


libraryDependencies &lt;/span&gt;++=&lt;span&gt; Seq(
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;com.typesafe.akka&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %% &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;akka-cluster-sharding-typed&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; AkkaVersion,
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;com.typesafe.akka&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %% &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;akka-persistence-typed&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; AkkaVersion,
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;com.typesafe.akka&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %% &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;akka-persistence-query&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; AkkaVersion,
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;com.typesafe.akka&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %% &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;akka-serialization-jackson&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; AkkaVersion,
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;com.typesafe.akka&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %% &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;akka-persistence-cassandra&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; AkkaPersistenceCassandraVersion,
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;com.typesafe.akka&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %% &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;akka-slf4j&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; AkkaVersion,
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ch.qos.logback&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;     % &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;logback-classic&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;             % &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1.2.3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Thu, 11 Jun 2020 00:24:00 +0000</pubDate>
<dc:creator>雪川大虫</dc:creator>
<og:description>先谈谈akka-typed的router actor。route 分pool router, group router两类。我们先看看pool-router的使用示范： val pool = Rout</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tiger-xc/p/13091012.html</dc:identifier>
</item>
<item>
<title>数据源管理 | Kafka集群环境搭建，消息存储机制详解 - 知了一笑</title>
<link>http://www.cnblogs.com/cicada-smile/p/13090989.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cicada-smile/p/13090989.html</guid>
<description>&lt;p&gt;本文源码：&lt;a href=&quot;https://github.com/cicadasmile/data-manage-parent&quot;&gt;GitHub·点这里&lt;/a&gt; || &lt;a href=&quot;https://gitee.com/cicadasmile/data-manage-parent&quot;&gt;GitEE·点这里&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;1、环境版本&quot;&gt;1、环境版本&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;版本：kafka2.11，zookeeper3.4
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：这里zookeeper3.4也是基于集群模式部署。&lt;/p&gt;
&lt;h2 id=&quot;2、解压重命名&quot;&gt;2、解压重命名&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;tar -zxvf kafka_2.11-0.11.0.0.tgz
mv kafka_2.11-0.11.0.0 kafka2.11
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建日志目录&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@en-master kafka2.11]# mkdir logs
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：以上操作需要同步到集群下其他服务上。&lt;/p&gt;
&lt;h2 id=&quot;3、添加环境变量&quot;&gt;3、添加环境变量&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;vim /etc/profile
export KAFKA_HOME=/opt/kafka2.11
export PATH=$PATH:$KAFKA_HOME/bin
source /etc/profile
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;4、修改核心配置&quot;&gt;4、修改核心配置&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;[root@en-master /opt/kafka2.11/config]# vim server.properties
-- 核心修改如下
# 唯一编号
broker.id=0
# 开启topic删除
delete.topic.enable=true
# 日志地址
log.dirs=/opt/kafka2.11/logs
# zk集群
zookeeper.connect=zk01:2181,zk02:2181,zk03:2181
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：broker.id安装集群服务个数编排即可，集群下不能重复。&lt;/p&gt;
&lt;h2 id=&quot;5、启动kafka集群&quot;&gt;5、启动kafka集群&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;# 启动命令
[root@node02 kafka2.11]# bin/kafka-server-start.sh -daemon config/server.properties
# 停止命令
[root@node02 kafka2.11]# bin/kafka-server-stop.sh
# 进程查看
[root@node02 kafka2.11]# jps
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：这里默认启动了zookeeper集群服务，并且集群下的kafka分别启动。&lt;/p&gt;
&lt;h2 id=&quot;6、基础管理命令&quot;&gt;6、基础管理命令&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;创建topic&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;bin/kafka-topics.sh --zookeeper zk01:2181 \
--create --replication-factor 3 --partitions 1 --topic one-topic
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参数说明：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;replication-factor 定义副本个数&lt;/li&gt;
&lt;li&gt;partitions 定义分区个数&lt;/li&gt;
&lt;li&gt;topic：定义topic名称&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;查看topic列表&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;bin/kafka-topics.sh --zookeeper zk01:2181 --list
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;修改topic分区&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;bin/kafka-topics.sh --zookeeper zk01:2181 --alter --topic one-topic --partitions 5
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;查看topic&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;bin/kafka-topics.sh --zookeeper zk01:2181 \
--describe --topic one-topic
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;发送消息&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;bin/kafka-console-producer.sh \
--broker-list 192.168.72.133:9092 --topic one-topic
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;消费消息&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;bin/kafka-console-consumer.sh \
--bootstrap-server 192.168.72.133:9092 --from-beginning --topic one-topic
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;删除topic&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;bin/kafka-topics.sh --zookeeper zk01:2181 \
--delete --topic first
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;7、zk集群用处&quot;&gt;7、Zk集群用处&lt;/h2&gt;
&lt;p&gt;Kafka集群中有一个broker会被选举为Controller，Controller依赖Zookeeper环境，管理集群broker的上下线，所有topic的分区副本分配和leader选举等工作。&lt;/p&gt;

&lt;h2 id=&quot;1、拦截器简介&quot;&gt;1、拦截器简介&lt;/h2&gt;
&lt;p&gt;Kafka中间件的Producer拦截器主要用于实现消息发送的自定义控制逻辑。用户可以在消息发送前以及回调逻辑执行前有机会对消息做一些自定义，比如消息修改等，发送状态监控等，用户可以指定多个拦截器按顺序执行拦截。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;核心方法&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;configure：获取配置信息和初始化数据时调用；&lt;/li&gt;
&lt;li&gt;onSend：消息被序列化以及和计算分区前调用该方法，可以对消息做操作；&lt;/li&gt;
&lt;li&gt;onAcknowledgement：消息发送到Broker之后，或发送过程失败时调用；&lt;/li&gt;
&lt;li&gt;close：关闭拦截器调用，执行一些资源清理工作；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：这里说的拦截器是针对消息发送流程。&lt;/p&gt;
&lt;h2 id=&quot;2、自定义拦截&quot;&gt;2、自定义拦截&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;定义方式&lt;/strong&gt;：实现ProducerInterceptor接口即可。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;拦截器一&lt;/strong&gt;：在onSend方法中，对拦截的消息进行修改。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Component
public class SendStartInterceptor implements ProducerInterceptor&amp;lt;String, String&amp;gt; {

    private final Logger LOGGER = LoggerFactory.getLogger(&quot;SendStartInterceptor&quot;);
    @Override
    public void configure(Map&amp;lt;String, ?&amp;gt; configs) {
        LOGGER.info(&quot;configs...&quot;);
    }
    @Override
    public ProducerRecord&amp;lt;String, String&amp;gt; onSend(ProducerRecord&amp;lt;String, String&amp;gt; record) {
        // 修改消息内容
        return new ProducerRecord&amp;lt;&amp;gt;(record.topic(), record.partition(),
                                    record.timestamp(), record.key(),
                              &quot;onSend：{&quot; + record.value()+&quot;}&quot;);
    }
    @Override
    public void onAcknowledgement(RecordMetadata metadata, Exception exception) {
        LOGGER.info(&quot;onAcknowledgement...&quot;);
    }
    @Override
    public void close() {
        LOGGER.info(&quot;SendStart close...&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;拦截器二&lt;/strong&gt;：在onAcknowledgement方法中，判断消息是否发送成功。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Component
public class SendOverInterceptor implements ProducerInterceptor&amp;lt;String, String&amp;gt; {

    private final Logger LOGGER = LoggerFactory.getLogger(&quot;SendOverInterceptor&quot;);
    @Override
    public void configure(Map&amp;lt;String, ?&amp;gt; configs) {
        LOGGER.info(&quot;configs...&quot;);
    }

    @Override
    public ProducerRecord&amp;lt;String, String&amp;gt; onSend(ProducerRecord&amp;lt;String, String&amp;gt; record) {
        LOGGER.info(&quot;record...{}&quot;, record.value());
        return record ;
    }

    @Override
    public void onAcknowledgement(RecordMetadata metadata, Exception exception) {
        if (exception != null){
            LOGGER.info(&quot;Send Fail...exe-msg&quot;,exception.getMessage());
        }
        LOGGER.info(&quot;Send success...&quot;);
    }

    @Override
    public void close() {
        LOGGER.info(&quot;SendOver close...&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;加载拦截器&lt;/strong&gt;：基于一个KafkaProducer配置Bean，加入拦截器。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Configuration
public class KafkaConfig {

    @Bean
    public Producer producer (){
        Properties props = new Properties();
        // 省略其他配置...
        // 添加拦截器
        List&amp;lt;String&amp;gt; interceptors = new ArrayList&amp;lt;&amp;gt;();
        interceptors.add(&quot;com.kafka.cluster.interceptor.SendStartInterceptor&quot;);
        interceptors.add(&quot;com.kafka.cluster.interceptor.SendOverInterceptor&quot;);
        props.put(ProducerConfig.INTERCEPTOR_CLASSES_CONFIG, interceptors);
        return new KafkaProducer&amp;lt;&amp;gt;(props) ;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;3、代码案例&quot;&gt;3、代码案例&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@RestController
public class SendMsgWeb {
    @Resource
    private KafkaProducer&amp;lt;String,String&amp;gt; producer ;
    @GetMapping(&quot;/sendMsg&quot;)
    public String sendMsg (){
        producer.send(new ProducerRecord&amp;lt;&amp;gt;(&quot;one-topic&quot;, &quot;msgKey&quot;, &quot;msgValue&quot;));
        return &quot;success&quot; ;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;基于上述自定义Bean类型，进行消息发送，关注拦截器中打印日志信息。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;：该过程基于上述案例producer.send方法追踪的源码执行流程，源码中的过程相对清楚，涉及的核心流程如下。&lt;/p&gt;
&lt;h2 id=&quot;1、消息生成过程&quot;&gt;1、消息生成过程&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1691717/202006/1691717-20200611073117984-959994369.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Producer发送消息采用的是异步发送的方式,消息发送过程如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Producer发送消息之后，经过拦截器，序列化，事务判断；&lt;/li&gt;
&lt;li&gt;流程执行后，消息内容放入容器中；&lt;/li&gt;
&lt;li&gt;容器在指定时间内如果装满(size),会唤醒Sender线程;&lt;/li&gt;
&lt;li&gt;容器如果在指定时间内没有装满，也会执行一次Sender线程唤醒；&lt;/li&gt;
&lt;li&gt;唤醒Sender线程之后，把容器数据拉取到topic中；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;絮叨一句&lt;/strong&gt;：读这些中间件的源码，不仅能开阔思维，也会让自己意识到平时写的代码可能真的叫搬砖。&lt;/p&gt;
&lt;h2 id=&quot;2、存储机制&quot;&gt;2、存储机制&lt;/h2&gt;
&lt;p&gt;Kafka中消息是以topic进行标识分类，生产者面向topic生产消息，topic分区(partition)是物理上的存储，基于消息日志文件的方式。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1691717/202006/1691717-20200611073103215-1967473714.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;每个partition对应于一个log文件,发送的消息不断追加到该log文件末端；&lt;/li&gt;
&lt;li&gt;log文件中存储的就是producer生产的消息数据，采用分片和索引机制；&lt;/li&gt;
&lt;li&gt;partition分为多个segment。每个segment对应两个(.index)和(.log)文件；&lt;/li&gt;
&lt;li&gt;index文件类型存储的索引信息；&lt;/li&gt;
&lt;li&gt;log文件存储消息的数据；&lt;/li&gt;
&lt;li&gt;索引文件中的元数据指向对应数据文件中message的物理偏移地址；&lt;/li&gt;
&lt;li&gt;消费者组中的每个消费者，都会实时记录消费的消息offset位置；&lt;/li&gt;
&lt;li&gt;当然消息消费出错时，恢复是从上次的记录位置继续消费；&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;3、事务控制机制&quot;&gt;3、事务控制机制&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1691717/202006/1691717-20200611073050339-2019109569.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Kafka支持消息的事务控制&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Producer事务&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;跨分区跨会话的事务原理，引入全局唯一的TransactionID，并将Producer获得的PID和TransactionID绑定。Producer重启后可以通过正在进行的TransactionID获得原来的PID。&lt;br/&gt;Kafka基于TransactionCoordinator组件管理Transaction，Producer通过和TransactionCoordinator交互获得TransactionID对应的任务状态。TransactionCoordinator将事务状态写入Kafka的内部Topic，即使整个服务重启，进行中的事务状态可以得到恢复。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Consumer事务&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Consumer消息消费，事务的保证强度很低，无法保证消息被精确消费，因为同一事务的消息可能会出现重启后已经被删除的情况。&lt;/p&gt;

&lt;pre&gt;
&lt;code&gt;GitHub·地址
https://github.com/cicadasmile/data-manage-parent
GitEE·地址
https://gitee.com/cicadasmile/data-manage-parent
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1691717/201908/1691717-20190823075428183-1996768914.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;推荐关联阅读：数据源管理系列&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 10 Jun 2020 23:51:00 +0000</pubDate>
<dc:creator>知了一笑</dc:creator>
<og:description>本文源码：GitHub&amp;amp;#183;点这里 || GitEE&amp;amp;#183;点这里 一、Kafka集群环境 1、环境版本 版本：kafka2.11，zookeeper3.4 注意：这里zoo</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cicada-smile/p/13090989.html</dc:identifier>
</item>
<item>
<title>Flutter实战】文本组件及五大案例 - 老孟Flutter</title>
<link>http://www.cnblogs.com/mengqd/p/13090863.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mengqd/p/13090863.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202006/467322-20200611072132652-387682408.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6.974358974359&quot;&gt;
&lt;p&gt;老孟导读：大家好，这是【Flutter实战】系列文章的第二篇，这一篇讲解文本组件，文本组件包括文本展示组件（Text和RichText）和文本输入组件（TextField），基础用法和五个案例助你快速掌握。&lt;br/&gt;第一篇链接：&lt;a href=&quot;https://juejin.im/post/5edec7c7f265da771b2fee5b&quot;&gt;【Flutter实战】移动技术发展史&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;text&quot;&gt;Text&lt;/h3&gt;
&lt;p&gt;Text是显示文本的组件，最常用的组件，没有之一。基本用法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;Text('老孟')
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202006/467322-20200611072133101-1559860358.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：Text组件一定要包裹在Scaffold组件下，否则效果如下：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202006/467322-20200611072133317-1012650688.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;文本的样式在&lt;code&gt;style&lt;/code&gt;中设置，类型为&lt;code&gt;TextStyle&lt;/code&gt;，&lt;code&gt;TextStyle&lt;/code&gt;中包含很多文本样式属性，下面介绍一些常用的。&lt;/p&gt;
&lt;p&gt;设置文本大小和颜色：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;Text('老孟',style: TextStyle(color: Colors.red,fontSize: 20),),
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202006/467322-20200611072133618-1971700812.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面黑色的字体为没有设置的效果，作为对比。&lt;/p&gt;
&lt;p&gt;设置字体粗细：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;Text('老孟',style: TextStyle(fontWeight: FontWeight.bold))
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202006/467322-20200611072133855-943356364.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;字体粗细共有9个级别，为&lt;code&gt;w100&lt;/code&gt;至&lt;code&gt;w900&lt;/code&gt;，&lt;strong&gt;FontWeight.bold&lt;/strong&gt;是&lt;code&gt;w700&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;设置斜体：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;Text('老孟',style: TextStyle(fontStyle: FontStyle.italic,))
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202006/467322-20200611072134115-11052481.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;设置自定义的字体：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;首先下载字体库（比如中华字体库）&lt;/li&gt;
&lt;li&gt;将字体文件拷贝的项目中，一般目录是：assets/fonts/，assets和fonts都需要手动创建，此目录不是必须的，而是约定俗成，资源一般都放在assets目录下。&lt;/li&gt;
&lt;li&gt;配置&lt;code&gt;pubspec.yaml&lt;/code&gt;：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;fonts:
  - family: maobi 
    fonts:
      - asset: assets/fonts/maobi.ttf
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;maobi：是自己对当前字体的命名，有意义即可。&lt;/p&gt;
&lt;p&gt;asset：字体文件的目录。&lt;/p&gt;
&lt;p&gt;使用：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;Text('老孟', style: TextStyle(fontFamily: 'maobi',)),
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202006/467322-20200611072134448-1950776673.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;设置对齐方式：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;Container(
  height: 100,
  width: 200,
  color: Colors.blue.withOpacity(.4),
  child: Text('老孟', textAlign: TextAlign.center),
),
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202006/467322-20200611072134900-1953534415.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;textAlign&lt;/code&gt;只是控制水平方向的对齐方式，值说明如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;left：左对齐&lt;/li&gt;
&lt;li&gt;right：右对齐&lt;/li&gt;
&lt;li&gt;center：居中&lt;/li&gt;
&lt;li&gt;justify：两端对齐，此属性中文存在bug（Flutter版本：1.17.3）也可以在&lt;a href=&quot;https://github.com/flutter/flutter/issues/35734&quot;&gt;官方issue中关注此问题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;start：前端对齐，和&lt;code&gt;TextDirection&lt;/code&gt;属性有关，如果设置&lt;code&gt;TextDirection.ltr&lt;/code&gt;，则左对齐，设置&lt;code&gt;TextDirection.rtl&lt;/code&gt;则右对齐。&lt;/li&gt;
&lt;li&gt;end：末端对齐，和&lt;code&gt;TextDirection&lt;/code&gt;属性有关，如果设置&lt;code&gt;TextDirection.ltr&lt;/code&gt;，则右对齐，设置&lt;code&gt;TextDirection.rtl&lt;/code&gt;则左对齐。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;设置文本自动换行：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;Container(
  height: 100,
  width: 200,
  color: Colors.blue.withOpacity(.4),
  child: Text('老孟，专注分享Flutter技术和应用实战',softWrap: true,),
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202006/467322-20200611072135174-387147946.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;文本超出范围时的处理：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;Container(
  height: 100,
  width: 200,
  color: Colors.blue.withOpacity(.4),
  child: Text('老孟，专注分享Flutter技术和应用实战',overflow: TextOverflow.ellipsis,),
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202006/467322-20200611072136025-391512219.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;溢出的处理方式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;clip：直接裁剪。&lt;/li&gt;
&lt;li&gt;fade：越来越透明。&lt;/li&gt;
&lt;li&gt;ellipsis：省略号结尾。&lt;/li&gt;
&lt;li&gt;visible：依然显示，此时将会溢出父组件。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;设置全局字体样式：&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;MaterialApp&lt;/code&gt;的&lt;code&gt;theme&lt;/code&gt;中设置如下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;MaterialApp(
  title: 'Flutter Demo',
  theme: ThemeData(
   ...
    textTheme: TextTheme(
        bodyText2: TextStyle(color: Colors.red,fontSize: 24),
    )
  ),
  home: Scaffold(
    body: TextDemo(),
  ),
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Text组件默认为红色，&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;Text('老孟'),

Text('老孟',style: TextStyle(color: Colors.blue,fontSize: 20),),
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202006/467322-20200611072136204-1897157196.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;richtext&quot;&gt;RichText&lt;/h3&gt;
&lt;p&gt;RichText的属性和Text基本一样，使用如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;RichText(
  text: TextSpan(
      style: DefaultTextStyle.of(context).style,
      children: &amp;lt;InlineSpan&amp;gt;[
        TextSpan(text: '老孟', style: TextStyle(color: Colors.red)),
        TextSpan(text: '，'),
        TextSpan(text: '专注分享Flutter技术和应用实战'),
      ]),
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202006/467322-20200611072136598-2077424361.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;textfield&quot;&gt;TextField&lt;/h3&gt;
&lt;p&gt;TextField是文本输入组件，即输入框，常用组件之一。基本用法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;TextField()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不需要任何参数，一个最简单的文本输入组件就出来了，效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202006/467322-20200611072136813-1618571128.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;decoration&lt;/code&gt;是TextField组件的装饰（外观）参数，类型是InputDecoration。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;icon&lt;/code&gt;显示在输入框的前面，用法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;TextField(
  decoration: InputDecoration(
    icon: Icon(Icons.person),
  ),
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202006/467322-20200611072137060-622938731.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当输入框是空而且没有焦点时，labelText显示在输入框上边，当获取焦点或者不为空时labelText往上移动一点，&lt;code&gt;labelStyle&lt;/code&gt;参数表示文本样式，具体参考&lt;code&gt;TextStyle&lt;/code&gt;， 用法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;TextField(
  decoration: InputDecoration(
    labelText: '姓名：',
    labelStyle: TextStyle(color:Colors.red)
  ),
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202006/467322-20200611072138190-1541952850.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;hasFloatingPlaceholder&lt;/code&gt;参数控制当输入框获取焦点或者不为空时是否还显示&lt;code&gt;labelText&lt;/code&gt;，默认为true，显示。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;helperText&lt;/code&gt;显示在输入框的左下部，用于提示用户，&lt;code&gt;helperStyle&lt;/code&gt;参数表示文本样式，具体参考&lt;code&gt;TextStyle&lt;/code&gt;用法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;TextField(
  decoration: InputDecoration(
    helperText: '用户名长度为6-10个字母',
    helperStyle: TextStyle(color: Colors.blue),
    helperMaxLines: 1
  ),
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202006/467322-20200611072138529-500348579.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;hintText&lt;/code&gt;是当输入框为空时的提示，不为空时不在显示，用法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;TextField(
  decoration: InputDecoration(
    hintText: '请输入用户名',
    hintStyle: TextStyle(color: Colors.grey),
    hintMaxLines: 1
  ),
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202006/467322-20200611072138930-502335574.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;errorText&lt;/code&gt;显示在输入框的左下部，默认字体为红色，用法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;TextField(
  decoration: InputDecoration(
    errorText: '用户名输入错误',
    errorStyle: TextStyle(fontSize: 12),
    errorMaxLines: 1,
    errorBorder: OutlineInputBorder(borderSide: BorderSide(color: Colors.red)),
  ),
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202006/467322-20200611072139139-454954972.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;prefix&lt;/code&gt;系列的组件是输入框前面的部分，用法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;TextField(
  decoration: InputDecoration(
    prefixIcon: Icon(Icons.person)
  ),
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202006/467322-20200611072139450-1916461773.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意prefix和icon的区别，icon是在输入框边框的外部，而prefix在里面。&lt;/p&gt;
&lt;p&gt;suffix和prefix相反，suffix在输入框的尾部，用法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;TextField(
  decoration: InputDecoration(
      suffixIcon: Icon(Icons.person)
  ),
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202006/467322-20200611072139666-2134564218.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;counter&lt;/code&gt;组件统计输入框文字的个数，counter仅仅是展示效果，不具备自动统计字数的功能， 自动统计字数代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;var _textFieldValue = '';
TextField(
  onChanged: (value){
    setState(() {
      _textFieldValue = value;
    });
  },
  decoration: InputDecoration(
    counterText: '${_textFieldValue.length}/32'
  ),
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202006/467322-20200611072143445-773911655.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;filled&lt;/code&gt;为true时，输入框将会被&lt;code&gt;fillColor&lt;/code&gt;填充，仿QQ登录输入框代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;Container(
  height: 60,
  width: 250,
  child: TextField(
    decoration: InputDecoration(
      fillColor: Color(0x30cccccc),
      filled: true,
      enabledBorder: OutlineInputBorder(
          borderSide: BorderSide(color: Color(0x00FF0000)),
          borderRadius: BorderRadius.all(Radius.circular(100))),
      hintText: 'QQ号/手机号/邮箱',
      focusedBorder: OutlineInputBorder(
          borderSide: BorderSide(color: Color(0x00000000)),
          borderRadius: BorderRadius.all(Radius.circular(100))),
    ),
  ),
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202006/467322-20200611072144011-578891466.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;controller&lt;/code&gt;是输入框文本编辑的控制器，可以获取TextField的内容、设置TextField的内容，下面将输入的英文变为大写：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;TextEditingController _controller;

@override
void initState() {
  super.initState();
  _controller = TextEditingController()
    ..addListener(() {
      //获取输入框的内容，变为大写
      _controller.text = _controller.text.toUpperCase();

    });
}

@override
Widget build(BuildContext context) {
  return TextField(
    controller: _controller,
  );
}

@override
dispose() {
  super.dispose();
  _controller.dispose();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有时输入框后面带有“清除”功能，需要controller来实现。如果需要2个TextField的内容进行同步，只需要给2个TextField设置同一个controller即可实现。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;keyboardType&lt;/code&gt;参数控制软键盘的类型，说明如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;text：通用键盘。&lt;/li&gt;
&lt;li&gt;multiline：当TextField为多行时（maxLines设置大于1），右下角的为“换行” 按键。&lt;/li&gt;
&lt;li&gt;number：数字键盘。&lt;/li&gt;
&lt;li&gt;phone：手机键盘，比数字键盘多&quot;*&quot;和 &quot;#&quot;。&lt;/li&gt;
&lt;li&gt;datetime：在ios上和text一样，在android上出现数字键盘、&quot;:&quot;和 &quot;-&quot;。&lt;/li&gt;
&lt;li&gt;emailAddress：邮箱键盘，有&quot;@&quot; 和 &quot;.&quot;按键。&lt;/li&gt;
&lt;li&gt;url：url键盘，有&quot;/&quot; 和 &quot;.&quot;按键。&lt;/li&gt;
&lt;li&gt;visiblePassword：既有字幕又有数字的键盘。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;textInputAction&lt;/code&gt;参数控制软键盘右下角的按键，说明如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;none：android上显示返回键，ios不支持。&lt;/li&gt;
&lt;li&gt;unspecified：让操作系统自己决定哪个合适，一般情况下，android显示“完成”或者“返回”。&lt;/li&gt;
&lt;li&gt;done：android显示代表“完成”的按钮，ios显示“Done”（中文：完成）。&lt;/li&gt;
&lt;li&gt;go：android显示表达用户去向目的地的图标，比如向右的箭头，ios显示“Go”（中文：前往）。&lt;/li&gt;
&lt;li&gt;search：android显示表达搜索的按钮，ios显示&quot;Search&quot;（中文：搜索）。&lt;/li&gt;
&lt;li&gt;send：android显示表达发送意思的按钮，比如“纸飞机”按钮，ios显示&quot;Send&quot;（中文：发送）。&lt;/li&gt;
&lt;li&gt;next：android显示表达“前进”的按钮，比如“向右的箭头”,ios显示&quot;Next&quot;（中文：下一项）。&lt;/li&gt;
&lt;li&gt;previous：android显示表达“后退”的按钮，比如“向左的箭头”,ios不支持。&lt;/li&gt;
&lt;li&gt;continueAction：android 不支持，ios仅在ios9.0+显示&quot;Continue&quot;（中文：继续）。&lt;/li&gt;
&lt;li&gt;join：Android和ios显示&quot;Join&quot;（中文：加入）。&lt;/li&gt;
&lt;li&gt;route：android 不支持，ios显示&quot;Route&quot;（中文：路线）。&lt;/li&gt;
&lt;li&gt;emergencyCall：android 不支持，ios显示&quot;Emergency Call&quot;（中文：紧急电话）。&lt;/li&gt;
&lt;li&gt;newline：android显示表达“换行”的按钮，ios显示”换行“。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;大家可能发现了，Android上显示的按钮大部分是不确定的，比如&lt;code&gt;next&lt;/code&gt;有的显示向右的箭头，有的显示前进，这是因为各大厂商对Android ROM定制引发的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;textCapitalization&lt;/code&gt;参数是配置键盘是大写还是小写，仅支持键盘模式为&lt;code&gt;text&lt;/code&gt;，其他模式下忽略此配置，说明如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;words：每一个单词的首字母大写。&lt;/li&gt;
&lt;li&gt;sentences：每一句话的首字母大写。&lt;/li&gt;
&lt;li&gt;characters：每个字母都大写&lt;/li&gt;
&lt;li&gt;none：都小写&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里仅仅是控制软键盘是大写模式还是小写模式，你也可以切换大小写，系统并不会改变输入框内的内容。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;textAlignVertical&lt;/code&gt;表示垂直方向的对齐方式，&lt;code&gt;textDirection&lt;/code&gt;表示文本方向，用法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;TextField(
  textAlignVertical: TextAlignVertical.center,
  textDirection: TextDirection.rtl,
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;toolbarOptions&lt;/code&gt;表示长按时弹出的菜单，有&lt;code&gt;copy&lt;/code&gt;、&lt;code&gt;cut&lt;/code&gt;、&lt;code&gt;paste&lt;/code&gt;、&lt;code&gt;selectAll&lt;/code&gt;，用法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;TextField(
  toolbarOptions: ToolbarOptions(
    copy: true,
    cut: true,
    paste: true,
    selectAll: true
  ),
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;cursor&lt;/code&gt;表示光标，用法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;TextField(
  showCursor: true,
  cursorWidth: 3,
  cursorRadius: Radius.circular(10),
  cursorColor: Colors.red,
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202006/467322-20200611072144324-1386330832.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;将输入框设置为密码框，只需&lt;code&gt;obscureText&lt;/code&gt;属性设置true即可，用法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;TextField(
  obscureText: true,
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过&lt;code&gt;inputFormatters&lt;/code&gt;可以限制用户输入的内容，比如只想让用户输入字符，设置如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;TextField(
  inputFormatters: [
    WhitelistingTextInputFormatter(RegExp(&quot;[a-zA-Z]&quot;)),
  ],
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这时用户是无法输入数字的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;onChanged&lt;/code&gt;是当内容发生变化时回调，&lt;code&gt;onSubmitted&lt;/code&gt;是点击回车或者点击软键盘上的完成回调，&lt;code&gt;onTap&lt;/code&gt;点击输入框时回调，用法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;TextField(
  onChanged: (value){
    print('onChanged:$value');
  },
  onEditingComplete: (){
    print('onEditingComplete');
  },
  
  onTap: (){
    print('onTap');
  },
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输入框右下角经常需要字数统计，除了使用上面介绍的方法外，还可以使用&lt;code&gt;buildCounter&lt;/code&gt;，建议使用此方法，用法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;TextField(
  maxLength: 100,
  buildCounter: (
    BuildContext context, {
    int currentLength,
    int maxLength,
    bool isFocused,
  }) {
    return Text(
      '$currentLength/$maxLength',
    );
  },
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;动态获取焦点&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;FocusScope.of(context).requestFocus(_focusNode);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;_focusNode&lt;/code&gt;为TextField的focusNode：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;_focusNode = FocusNode();

TextField(
        focusNode: _focusNode,
        ...
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;动态失去焦点&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;_focusNode.unfocus();
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;过渡颜色的文字&quot;&gt;过渡颜色的文字&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;Builder(
  builder: (BuildContext context) {
    RenderBox box = context.findRenderObject();
    final Shader linearGradient = LinearGradient(
      colors: &amp;lt;Color&amp;gt;[Colors.purple, Colors.blue],
    ).createShader(
        Rect.fromLTWH(0.0, 0.0, box?.size?.width, box?.size?.height));

    return Text(
      '老孟，专注分享Flutter技术和应用实战',
      style: new TextStyle(
          fontSize: 18.0,
          fontWeight: FontWeight.bold,
          foreground: Paint()..shader = linearGradient),
    );
  },
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202006/467322-20200611072144606-600856819.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Builder&lt;/code&gt;组件是为了计算当前Text组件大小，生成LinearGradient。&lt;/p&gt;
&lt;h3 id=&quot;带前后置标签的文本&quot;&gt;带前后置标签的文本&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;RichText(
  text: TextSpan(
      style: DefaultTextStyle.of(context).style,
      children: &amp;lt;InlineSpan&amp;gt;[
        WidgetSpan(
            child: Container(
              margin: EdgeInsets.only(right: 10),
              padding: EdgeInsets.symmetric(horizontal: 10),
              decoration: BoxDecoration(
                  shape: BoxShape.rectangle,
                  borderRadius: BorderRadius.all(Radius.circular(20)),
                  color: Colors.blue),
              child: Text(
                '判断题',
                style: TextStyle(color: Colors.white),
              ),
            )),
        TextSpan(text: '泡沫灭火器可用于带电灭火'),

      ]),
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202006/467322-20200611072144856-1040771826.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;服务协议&quot;&gt;“服务协议”&lt;/h3&gt;
&lt;p&gt;通常在登录页面的底部会出现&lt;strong&gt;登录即代表同意并阅读 《服务协议》&lt;/strong&gt;，其中&lt;strong&gt;《服务协议》&lt;/strong&gt;为蓝色且可点击：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;Text.rich(
  TextSpan(
      text: '登录即代表同意并阅读',
      style: TextStyle(fontSize: 11, color: Color(0xFF999999)),
      children: [
        TextSpan(
          text: '《服务协议》',
          style: TextStyle(color: Colors.blue, fontWeight: FontWeight.bold),
          recognizer: TapGestureRecognizer()
            ..onTap = () {
              print('onTap');
            },
        ),
      ]),
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202006/467322-20200611072145167-1444568377.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;登录密码输入框&quot;&gt;登录密码输入框&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;TextField(
  decoration: InputDecoration(
    fillColor: Color(0x30cccccc),
    filled: true,
    enabledBorder: OutlineInputBorder(
        borderSide: BorderSide(color: Color(0x00FF0000)),
        borderRadius: BorderRadius.all(Radius.circular(100))),
    hintText: '输入密码',
    focusedBorder: OutlineInputBorder(
        borderSide: BorderSide(color: Color(0x00000000)),
        borderRadius: BorderRadius.all(Radius.circular(100))),

  ),
  textAlign: TextAlign.center,
  obscureText: true,
  onChanged: (value) {

  },
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202006/467322-20200611072145364-1234819938.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;评论回复&quot;&gt;评论回复&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;Text.rich(
  TextSpan(
      text: '回复',
      style: TextStyle(fontSize: 11, color: Color(0xFF999999)),
      children: [
        TextSpan(
          text: '@老孟：',
          style: TextStyle(color: Colors.blue, fontWeight: FontWeight.bold),
          recognizer: TapGestureRecognizer()
            ..onTap = () {
              print('onTap');
            },
        ),
        TextSpan(
          text: '你好，想知道Flutter发展前景如何？',
        ),
      ]),
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202006/467322-20200611072145612-738009854.webp&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;交流&quot;&gt;交流&lt;/h2&gt;
&lt;p&gt;老孟Flutter博客地址（330个控件用法）：&lt;a href=&quot;http://laomengit.com&quot;&gt;http://laomengit.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎加入Flutter交流群（微信：laomengit）、关注公众号【老孟Flutter】：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th/&gt;
&lt;th/&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202006/467322-20200611072147023-2011163201.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/td&gt;
&lt;td&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202006/467322-20200611072147574-1996994392.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;</description>
<pubDate>Wed, 10 Jun 2020 23:22:00 +0000</pubDate>
<dc:creator>老孟Flutter</dc:creator>
<og:description>老孟导读：大家好，这是【Flutter实战】系列文章的第二篇，这一篇讲解文本组件，文本组件包括文本展示组件（Text和RichText）和文本输入组件（TextField），基础用法和五个案例助你快速</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mengqd/p/13090863.html</dc:identifier>
</item>
<item>
<title>谈谈Spring中的对象跟Bean，你知道Spring怎么创建对象的吗？ - 程序员DMZ</title>
<link>http://www.cnblogs.com/daimzh/p/13090856.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/daimzh/p/13090856.html</guid>
<description>&lt;blockquote readability=&quot;6.4166666666667&quot;&gt;
&lt;p&gt;&lt;strong&gt;本系列文章：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/qq_41907991/article/details/105667900&quot;&gt;读源码，我们可以从第一行读起&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/qq_41907991/article/details/105743462&quot;&gt;你知道Spring是怎么解析配置类的吗？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/qq_41907991/article/details/106008651&quot;&gt;配置类为什么要添加@Configuration注解？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;推荐阅读：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/qq_41907991/article/details/105502255&quot;&gt;Spring官网阅读 | 总结篇&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/qq_41907991/category_9808373.html&quot;&gt;Spring杂谈&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本系列文章将会带你一行行的将Spring的源码吃透，推荐阅读的文章是阅读源码的基础！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在开始探讨源码前，我们先思考两个问题：&lt;/p&gt;
&lt;h2 id=&quot;1、在spring中，什么是bean？跟对象有什么区别？&quot;&gt;1、在Spring中，什么是Bean？跟对象有什么区别？&lt;/h2&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;通过new关键字，反射，克隆等手段创建出来的就是对象。在Spring中，Bean一定是一个对象，但是对象不一定是一个Bean，一个被创建出来的对象要变成一个Bean要经过很多复杂的工序，例如需要被我们的&lt;code&gt;BeanPostProcessor&lt;/code&gt;处理，需要经过初始化，需要经过&lt;code&gt;AOP&lt;/code&gt;（&lt;code&gt;AOP&lt;/code&gt;本身也是由后置处理器完成的）等。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200515152019215.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;2、在创建对象前，spring还做了其它什么事情吗？&quot;&gt;2、在创建对象前，Spring还做了其它什么事情吗？&lt;/h2&gt;
&lt;p&gt;我们还是回到&lt;a href=&quot;https://www.processon.com/diagraming/5e022908e4b0250e8aee8bad&quot;&gt;流程图&lt;/a&gt;中，其中相关的步骤如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRlZS5jb20vd3hfY2MzNDdiZTY5Ni9ibG9nSW1hZ2UvcmF3L21hc3Rlci8xMjMucG5n?x-oss-process=image/format,png&quot; alt=&quot;123&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在前面的三篇文章中，我们已经分析到了第&lt;code&gt;3-5&lt;/code&gt;步的源码，而如果你对Spring源码稍有了解的话，就是知道创建对象以及将对象变成一个Bean的过程发生在第&lt;code&gt;3-11&lt;/code&gt;步骤中。中间的五步分别做了什么呢？&lt;/p&gt;
&lt;h3 id=&quot;1、registerbeanpostprocessors&quot;&gt;1、registerBeanPostProcessors&lt;/h3&gt;
&lt;p&gt;就像名字所说的那样，&lt;strong&gt;注册&lt;code&gt;BeanPostProcessor&lt;/code&gt;&lt;/strong&gt;，这段代码在&lt;a href=&quot;https://blog.csdn.net/qq_41907991/article/details/103867048&quot;&gt;Spring官网阅读（八）容器的扩展点（三）（BeanPostProcessor）&lt;/a&gt;已经分析过了，所以在本文就直接跳过了，如果你没有看过之前的文章也没有关系，你只需要知道，在这里Spring将所有的&lt;code&gt;BeanPostProcessor&lt;/code&gt;注册到了容器中&lt;/p&gt;
&lt;h3 id=&quot;2、initmessagesource&quot;&gt;2、initMessageSource&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;初始化容器中的&lt;code&gt;messageSource&lt;/code&gt;&lt;/strong&gt;，如果程序员没有提供，默认会创建一个&lt;code&gt;org.springframework.context.support.DelegatingMessageSource&lt;/code&gt;，&lt;a href=&quot;https://blog.csdn.net/qq_41907991/article/details/104890350&quot;&gt;Spring官网阅读（十一）ApplicationContext详细介绍（上）&lt;/a&gt; 已经介绍过了。&lt;/p&gt;
&lt;h3 id=&quot;3、initapplicationeventmulticaster&quot;&gt;3、initApplicationEventMulticaster&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;初始化事件分发器&lt;/strong&gt;，如果程序员没有提供，那么默认创建一个&lt;code&gt;org.springframework.context.event.ApplicationEventMulticaster&lt;/code&gt;,&lt;a href=&quot;https://blog.csdn.net/qq_41907991/article/details/104934770&quot;&gt;Spring官网阅读（十二）ApplicationContext详解（中）&lt;/a&gt;已经做过详细分析，不再赘述&lt;/p&gt;
&lt;h3 id=&quot;4、onrefresh&quot;&gt;4、onRefresh&lt;/h3&gt;
&lt;p&gt;留给子类复写扩展使用&lt;/p&gt;
&lt;h3 id=&quot;5、registerlisteners&quot;&gt;5、registerListeners&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;注册事件监听器&lt;/strong&gt;，就是将容器中所有实现了&lt;code&gt;org.springframework.context.ApplicationListener&lt;/code&gt;接口的对象放入到监听器的集合中。&lt;/p&gt;

&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;在完成了上面的一些准备工作后，Spring开始来创建Bean了，按照流程，首先被调用的就是&lt;code&gt;finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory)&lt;/code&gt;方法，我们就以这个方法为入口，一步步跟踪源码，看看Spring中的Bean到底是怎么创建出来的，当然，本文主要关注的是创建对象的这个过程，对象变成Bean的流程我们在后续文章中再分析&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1、finishbeanfactoryinitialization&quot;&gt;1、finishBeanFactoryInitialization&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) {
   // 初始化一个ConversionService用于类型转换，这个ConversionService会在实例化对象的时候用到
   if (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;amp;&amp;amp;
         beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) {
      beanFactory.setConversionService(
            beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));
   }

  // 添加一个StringValueResolver，用于处理占位符，可以看到，默认情况下就是使用环境中的属性值来替代占位符中的属性
   if (!beanFactory.hasEmbeddedValueResolver()) {
      beanFactory.addEmbeddedValueResolver(strVal -&amp;gt; getEnvironment().resolvePlaceholders(strVal));
   }

   // 创建所有的LoadTimeWeaverAware
   String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false);
   for (String weaverAwareName : weaverAwareNames) {
      getBean(weaverAwareName);
   }

   // 静态织入完成后将临时的类加载器设置为null,所以除了创建LoadTimeWeaverAware时可能会用到临时类加载器，其余情况下都为空
   beanFactory.setTempClassLoader(null);

   // 将所有的配置信息冻结
   beanFactory.freezeConfiguration();

   // 开始进行真正的创建
   beanFactory.preInstantiateSingletons();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的方法最终调用了&lt;code&gt;org.springframework.beans.factory.support.DefaultListableBeanFactory#preInstantiateSingletons&lt;/code&gt;来创建Bean。&lt;/p&gt;
&lt;p&gt;其源码如下：&lt;/p&gt;
&lt;h2 id=&quot;2、preinstantiatesingletons&quot;&gt;2、preInstantiateSingletons&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public void  preInstantiateSingletons() throws BeansException {
        // 所有bd的名称 
                List&amp;lt;String&amp;gt; beanNames = new ArrayList&amp;lt;&amp;gt;(this.beanDefinitionNames);
        // 遍历所有bd，一个个进行创建 
                for (String beanName : beanNames) {
            // 获取到指定名称对应的bd
                        RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);
            // 对不是延迟加载的单例的Bean进行创建
                        if (!bd.isAbstract() &amp;amp;&amp;amp; bd.isSingleton() &amp;amp;&amp;amp; !bd.isLazyInit()) {
                // 判断是否是一个FactoryBean
                                if (isFactoryBean(beanName)) {
                    // 如果是一个factoryBean的话，先创建这个factoryBean，创建factoryBean时，需要在beanName前面拼接一个&amp;amp;符号
                                        Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);
                                        if (bean instanceof FactoryBean) {
                                                final FactoryBean&amp;lt;?&amp;gt; factory = (FactoryBean&amp;lt;?&amp;gt;) bean;
                                                boolean isEagerInit;
                                                if (System.getSecurityManager() != null &amp;amp;&amp;amp; factory instanceof SmartFactoryBean) {
                                                        isEagerInit = AccessController.doPrivileged((PrivilegedAction&amp;lt;Boolean&amp;gt;)
                                                                                        ((SmartFactoryBean&amp;lt;?&amp;gt;) factory)::isEagerInit,
                                                                        getAccessControlContext());
                                                }
                                                else {
                            // 判断是否是一个SmartFactoryBean，并且不是懒加载的，就意味着，在创建了这个factoryBean之后要立马调用它的getObject方法创建另外一个Bean
                                                        isEagerInit = (factory instanceof SmartFactoryBean &amp;amp;&amp;amp;
                                                                        ((SmartFactoryBean&amp;lt;?&amp;gt;) factory).isEagerInit());
                                                }
                                                if (isEagerInit) {
                                                        getBean(beanName);
                                                }
                                        }
                                }
                                else {
                    // 不是factoryBean的话，我们直接创建就行了
                                        getBean(beanName);
                                }
                        }
                }
                // 在创建了所有的Bean之后，遍历
                for (String beanName : beanNames) {
            // 这一步其实是从缓存中获取对应的创建的Bean，这里获取到的必定是单例的 
                        Object singletonInstance = getSingleton(beanName);
            // 判断是否是一个SmartInitializingSingleton，最典型的就是我们之前分析过的EventListenerMethodProcessor，在这一步完成了对已经创建好的Bean的解析，会判断其方法上是否有    @EventListener注解，会将这个注解标注的方法通过EventListenerFactory转换成一个事件监听器并添加到监听器的集合中
                        if (singletonInstance instanceof SmartInitializingSingleton) {
                                final SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;
                                if (System.getSecurityManager() != null) {
                                        AccessController.doPrivileged((PrivilegedAction&amp;lt;Object&amp;gt;) () -&amp;gt; {
                                                smartSingleton.afterSingletonsInstantiated();
                                                return null;
                                        }, getAccessControlContext());
                                }
                                else {
                                        smartSingleton.afterSingletonsInstantiated();
                                }
                        }
                }
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面这段代码整体来说应该不难，不过它涉及到了一个点就是&lt;code&gt;factoryBean&lt;/code&gt;,如果你对它不够了解的话，请参考我之前的一篇文章：&lt;a href=&quot;https://blog.csdn.net/qq_41907991/article/details/103867036&quot;&gt;Spring官网阅读（七）容器的扩展点（二）FactoryBean&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;3、dogetbean&quot;&gt;3、doGetBean&lt;/h2&gt;
&lt;p&gt;从上面的代码分析中我们可以知道，Spring最终都会调用到&lt;code&gt;getBean&lt;/code&gt;方法，而&lt;code&gt;getBean&lt;/code&gt;并不是真正干活的，&lt;code&gt;doGetBean&lt;/code&gt;才是。另外&lt;code&gt;doGetBean&lt;/code&gt;可以分为两种情况&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;创建的是一个&lt;code&gt;FactoryBean&lt;/code&gt;，此时实际传入的&lt;code&gt;name = &amp;amp; + beanName&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;创建的是一个普通Bean，此时传入的&lt;code&gt;name = beanName&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;       protected &amp;lt;T&amp;gt; T doGetBean(final String name, @Nullable final Class&amp;lt;T&amp;gt; requiredType,
                        @Nullable final Object[] args, boolean typeCheckOnly) throws BeansException {
                // 前面我们说过了，传入的name可能时&amp;amp; + beanName这种形式，这里做的就是去除掉&amp;amp;，得到beanName
                final String beanName = transformedBeanName(name);
                Object bean;
                // 这个方法就很牛逼了，通过它解决了循环依赖的问题，不过目前我们只需要知道它是从单例池中获取已经创建的Bean即可，循环依赖后面我单独写一篇文章
        // 方法作用：已经创建的Bean会被放到单例池中，这里就是从单例池中获取
                Object sharedInstance = getSingleton(beanName);
        
                if (sharedInstance != null &amp;amp;&amp;amp; args == null) {
            // 如果直接从单例池中获取到了这个bean(sharedInstance),我们能直接返回吗？
            // 当然不能，因为获取到的Bean可能是一个factoryBean,如果我们传入的name是 &amp;amp; + beanName 这种形式的话，那是可以返回的，但是我们传入的更可能是一个beanName，那么这个时候Spring就还需要调用这个sharedInstance的getObject方法来创建真正被需要的Bean
                        bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);
                }
                else {
            // 在缓存中获取不到这个Bean
            // 原型下的循环依赖直接报错
                        if (isPrototypeCurrentlyInCreation(beanName)) {
                                throw new BeanCurrentlyInCreationException(beanName);
                        }
            
            // 核心要义，找不到我们就从父容器中再找一次
                        BeanFactory parentBeanFactory = getParentBeanFactory();
                        if (parentBeanFactory != null &amp;amp;&amp;amp; !containsBeanDefinition(beanName)) {
                                String nameToLookup = originalBeanName(name);
                                if (parentBeanFactory instanceof AbstractBeanFactory) {
                                        return ((AbstractBeanFactory) parentBeanFactory).doGetBean(
                                                        nameToLookup, requiredType, args, typeCheckOnly);
                                }
                                else if (args != null) {
                                        return (T) parentBeanFactory.getBean(nameToLookup, args);
                                }
                                else if (requiredType != null) {
                                        return parentBeanFactory.getBean(nameToLookup, requiredType);
                                }
                                else {
                                        return (T) parentBeanFactory.getBean(nameToLookup);
                                }
                        }
            
            // 如果不仅仅是为了类型推断，也就是代表我们要对进行实例化
            // 那么就将bean标记为正在创建中，其实就是将这个beanName放入到alreadyCreated这个set集合中
                        if (!typeCheckOnly) {
                                markBeanAsCreated(beanName);
                        }
                        try {
                
                                final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);
                
                // 检查合并后的bd是否是abstract,这个检查现在已经没有作用了，必定会通过
                                checkMergedBeanDefinition(mbd, beanName, args);

                                // @DependsOn注解标注的当前这个Bean所依赖的bean名称的集合，就是说在创建当前这个Bean前，必须要先将其依赖的Bean先完成创建
                                String[] dependsOn = mbd.getDependsOn();
                                if (dependsOn != null) {
                    // 遍历所有申明的依赖
                                        for (String dep : dependsOn) {
                        // 如果这个bean所依赖的bean又依赖了当前这个bean,出现了循环依赖，直接报错
                                                if (isDependent(beanName, dep)) {
                                                        throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                                                                        &quot;Circular depends-on relationship between '&quot; + beanName + &quot;' and '&quot; + dep + &quot;'&quot;);
                                                }
                        // 注册bean跟其依赖的依赖关系，key为依赖，value为依赖所从属的bean
                                                registerDependentBean(dep, beanName);
                                                try {
                            // 先创建其依赖的Bean
                                                        getBean(dep);
                                                }
                                                catch (NoSuchBeanDefinitionException ex) {
                                                        throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                                                                        &quot;'&quot; + beanName + &quot;' depends on missing bean '&quot; + dep + &quot;'&quot;, ex);
                                                }
                                        }
                                }
                                // 我们目前只分析单例的创建，单例看懂了，原型自然就懂了
                                if (mbd.isSingleton()) {
                    // 这里再次调用了getSingleton方法，这里跟方法开头调用的getSingleton的区别在于，这个方法多传入了一个ObjectFactory类型的参数，这个ObjectFactory会返回一个Bean
                                        sharedInstance = getSingleton(beanName, () -&amp;gt; {
                                                try {
                                                        return createBean(beanName, mbd, args);
                                                }
                                                catch (BeansException ex) {
                                                        destroySingleton(beanName);
                                                        throw ex;
                                                }
                                        });
                                        bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
                                }
                // 省略原型跟域对象的相关代码
                return (T) bean;
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配合注释看这段代码应该也不难吧，我们重点关注最后在调用的这段方法即可&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRlZS5jb20vd3hfY2MzNDdiZTY5Ni9ibG9nSW1hZ2UvcmF3L21hc3Rlci84ODgucG5n?x-oss-process=image/format,png&quot; alt=&quot;888&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;4、getsingletonbeannameobjectfactory&quot;&gt;4、getSingleton(beanName,ObjectFactory)&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public Object getSingleton(String beanName, ObjectFactory&amp;lt;?&amp;gt; singletonFactory) {
   Assert.notNull(beanName, &quot;Bean name must not be null&quot;);
   synchronized (this.singletonObjects) {
       // 从单例池中获取，这个地方肯定也获取不到
      Object singletonObject = this.singletonObjects.get(beanName);
      if (singletonObject == null) {
          // 工厂已经在销毁阶段了，这个时候还在创建Bean的话，就直接抛出异常
         if (this.singletonsCurrentlyInDestruction) {
            throw new BeanCreationNotAllowedException(beanName,
                  &quot;Singleton bean creation not allowed while singletons of this factory are in destruction &quot; +
                  &quot;(Do not request a bean from a BeanFactory in a destroy method implementation!)&quot;);
         }
         // 在单例创建前，记录一下正在创建的单例的名称，就是把beanName放入到singletonsCurrentlyInCreation这个set集合中去
         beforeSingletonCreation(beanName);
         boolean newSingleton = false;
         boolean recordSuppressedExceptions = (this.suppressedExceptions == null);
         if (recordSuppressedExceptions) {
            this.suppressedExceptions = new LinkedHashSet&amp;lt;&amp;gt;();
         }
         try {
             // 这里调用了singletonFactory的getObject方法，对应的实现就是在doGetBean中的那一段lambda表达式
            singletonObject = singletonFactory.getObject();
            newSingleton = true;
         }
        // 省略异常处理
         finally {
            if (recordSuppressedExceptions) {
               this.suppressedExceptions = null;
            }
             // 在单例完成创建后，将beanName从singletonsCurrentlyInCreation中移除
             // 标志着这个单例已经完成了创建
            afterSingletonCreation(beanName);
         }
         if (newSingleton) {
             // 添加到单例池中
            addSingleton(beanName, singletonObject);
         }
      }
      return singletonObject;
   }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;分析完上面这段代码，我们会发现，核心的创建Bean的逻辑就是在&lt;code&gt;singletonFactory.getObject()&lt;/code&gt;这句代码中，而其实现就是在&lt;code&gt;doGetBean&lt;/code&gt;方法中的那一段lambda表达式，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRlZS5jb20vd3hfY2MzNDdiZTY5Ni9ibG9nSW1hZ2UvcmF3L21hc3Rlci85OTkucG5n?x-oss-process=image/format,png&quot; alt=&quot;999&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;实际就是通过&lt;code&gt;createBean&lt;/code&gt;这个方法创建了一个Bean然后返回，&lt;code&gt;createBean&lt;/code&gt;又干了什么呢？&lt;/p&gt;
&lt;h2 id=&quot;5、createbean&quot;&gt;5、createBean&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;protected Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)
      throws BeanCreationException {

   RootBeanDefinition mbdToUse = mbd;
    
    // 解析得到beanClass，为什么需要解析呢？如果是从XML中解析出来的标签属性肯定是个字符串嘛
    // 所以这里需要加载类，得到Class对象
   Class&amp;lt;?&amp;gt; resolvedClass = resolveBeanClass(mbd, beanName);
   if (resolvedClass != null &amp;amp;&amp;amp; !mbd.hasBeanClass() &amp;amp;&amp;amp; mbd.getBeanClassName() != null) {
      mbdToUse = new RootBeanDefinition(mbd);
      mbdToUse.setBeanClass(resolvedClass);
   }
   // 对XML标签中定义的lookUp属性进行预处理，如果只能根据名字找到一个就标记为非重载的，这样在后续就不需要去推断到底是哪个方法了，对于@LookUp注解标注的方法是不需要在这里处理的，AutowiredAnnotationBeanPostProcessor会处理这个注解
   try {
      mbdToUse.prepareMethodOverrides();
   }
   // 省略异常处理...
   try {
       // 在实例化对象前，会经过后置处理器处理
       // 这个后置处理器的提供了一个短路机制，就是可以提前结束整个Bean的生命周期，直接从这里返回一个Bean
       // 不过我们一般不会这么做，它的另外一个作用就是对AOP提供了支持，在这里会将一些不需要被代理的Bean进行标记，就本文而言，你可以暂时理解它没有起到任何作用
      Object bean = resolveBeforeInstantiation(beanName, mbdToUse);
      if (bean != null) {
         return bean;
      }
   }
    // 省略异常处理...
   try {
       // doXXX方法，真正干活的方法，doCreateBean，真正创建Bean的方法
      Object beanInstance = doCreateBean(beanName, mbdToUse, args);
      if (logger.isDebugEnabled()) {
         logger.debug(&quot;Finished creating instance of bean '&quot; + beanName + &quot;'&quot;);
      }
      return beanInstance;
   }
  // 省略异常处理...
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;6、docreatebean&quot;&gt;6、doCreateBean&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;本文只探讨对象是怎么创建的，至于怎么从一个对象变成了Bean，在后面的文章我们再讨论，所以我们主要就关注下面这段代码&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 这个方法真正创建了Bean,创建一个Bean会经过 创建对象 &amp;gt; 依赖注入 &amp;gt; 初始化 这三个过程，在这个过程中，BeanPostPorcessor会穿插执行，本文主要探讨的是创建对象的过程，所以关于依赖注入及初始化我们暂时省略，在后续的文章中再继续研究
protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final @Nullable Object[] args)
      throws BeanCreationException {

   // Instantiate the bean.
   BeanWrapper instanceWrapper = null;
   if (mbd.isSingleton()) {
       // 这行代码看起来就跟factoryBean相关，这是什么意思呢？
       // 在下文我会通过例子介绍下，你可以暂时理解为，这个地方返回的就是个null
      instanceWrapper = this.factoryBeanInstanceCache.remove(beanName);
   }
   if (instanceWrapper == null) {
       // 这里真正的创建了对象
      instanceWrapper = createBeanInstance(beanName, mbd, args);
   }
   // 省略依赖注入，初始化
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里我先分析下&lt;code&gt;this.factoryBeanInstanceCache.remove(beanName)&lt;/code&gt;这行代码。这里需要说一句，我写的这个源码分析的系列非常的细节，之所以选择这样一个个扣细节是因为我自己在阅读源码过程中经常会被这些问题阻塞，那么借着这些文章将自己踩过的坑分享出来可以减少作为读者的你自己在阅读源码时的障碍，其次也能够提升自己阅读源码的能力。如果你对这些细节不感兴趣的话，可以直接跳过，能把握源码的主线即可。言归正传，我们回到这行代码&lt;code&gt;this.factoryBeanInstanceCache.remove(beanName)&lt;/code&gt;。什么时候&lt;code&gt;factoryBeanInstanceCache&lt;/code&gt;这个集合中会有值呢？这里我还是以示例代码来说明这个问题，示例代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Main {
        public static void main(String[] args) {
                AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(Config.class);
        }
}

// 没有做什么特殊的配置，就是扫描了需要的组件，测试时换成你自己的包名
@ComponentScan(&quot;com.dmz.source.instantiation&quot;)
@Configuration
public class Config {
}

// 这里申明了一个FactoryBean,并且通过@DependsOn注解申明了这个FactoryBean的创建要在orderService之后，主要目的是为了在DmzFactoryBean创建前让容器发生一次属性注入
@Component
@DependsOn(&quot;orderService&quot;)
public class DmzFactoryBean implements FactoryBean&amp;lt;DmzService&amp;gt; {
        @Override
        public DmzService getObject() throws Exception {
                return new DmzService();
        }

        @Override
        public Class&amp;lt;?&amp;gt; getObjectType() {
                return DmzService.class;
        }
}

// 没有通过注解的方式将它放到容器中，而是通过上面的DmzFactoryBean来管理对应的Bean
public class DmzService {
}

// OrderService中需要注入dmzService
@Component
public class OrderService {
        @Autowired
        DmzService dmzService;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这段代码中，因为我们明确的表示了&lt;code&gt;DmzFactoryBean&lt;/code&gt;是依赖于&lt;code&gt;orderService&lt;/code&gt;的，所以必定会先创建&lt;code&gt;orderService&lt;/code&gt;再创建&lt;code&gt;DmzFactoryBean&lt;/code&gt;，创建&lt;code&gt;orderService&lt;/code&gt;的流程如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200520204706905.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中的属性注入阶段，我们需要细化，也可以画图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200520204729119.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTA3OTkx,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为orderService进行属性注入可以分为这么几步&lt;/p&gt;
&lt;ol readability=&quot;5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;找到需要注入的注入点，也就是orderService中的dmzService字段&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;根据字段的类型以及名称去容器中查询符合要求的Bean&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;当遍历到一个FactroyBean时，为了确定其getObject方法返回的对象的类型需要创建这个FactroyBean（只会到对象级别），然后调用这个创建好的FactroyBean的getObjectType方法明确其类型并与注入点需要的类型比较，看是否是一个候选的Bean，在创建这个FactroyBean时就将其放入了&lt;code&gt;factoryBeanInstanceCache&lt;/code&gt;中。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;在确定了唯一的候选Bean之后，Spring就会对这个Bean进行创建，创建的过程又经过三个步骤&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;创建对象&lt;/li&gt;
&lt;li&gt;属性注入&lt;/li&gt;
&lt;li&gt;初始化&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在创建对象时，因为此时&lt;code&gt;factoryBeanInstanceCache&lt;/code&gt;已经缓存了这个Bean对应的对象，所以直接通过&lt;code&gt;this.factoryBeanInstanceCache.remove(beanName)&lt;/code&gt;这行代码就返回了，避免了二次创建对象。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;7、createbeaninstance&quot;&gt;7、createBeanInstance&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;protected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) {
   
   Class&amp;lt;?&amp;gt; beanClass = resolveBeanClass(mbd, beanName);
   // 省略异常
    
    // 通过bd中提供的instanceSupplier来获取一个对象
    // 正常bd中都不会有这个instanceSupplier属性，这里也是Spring提供的一个扩展点，但实际上不常用
   Supplier&amp;lt;?&amp;gt; instanceSupplier = mbd.getInstanceSupplier();
   if (instanceSupplier != null) {
      return obtainFromSupplier(instanceSupplier, beanName);
   }

   // bd中提供了factoryMethodName属性，那么要使用工厂方法的方式来创建对象，工厂方法又会区分静态工厂方法跟实例工厂方法
   if (mbd.getFactoryMethodName() != null) {
      return instantiateUsingFactoryMethod(beanName, mbd, args);
   }

   // 在原型模式下，如果已经创建过一次这个Bean了，那么就不需要再次推断构造函数了
   boolean resolved = false;  // 是否推断过构造函数
   boolean autowireNecessary = false;  // 构造函数是否需要进行注入
   if (args == null) {
      synchronized (mbd.constructorArgumentLock) {
         if (mbd.resolvedConstructorOrFactoryMethod != null) {
            resolved = true;
            autowireNecessary = mbd.constructorArgumentsResolved;
         }
      }
   }
   if (resolved) {
      if (autowireNecessary) {
         return autowireConstructor(beanName, mbd, null, null);
      }
      else {
         return instantiateBean(beanName, mbd);
      }
   }

   // 推断构造函数
   Constructor&amp;lt;?&amp;gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);
   if (ctors != null || mbd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR ||
         mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) {
      return autowireConstructor(beanName, mbd, ctors, args);
   }

   // 调用无参构造函数创建对象
   return instantiateBean(beanName, mbd);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面这段代码在&lt;a href=&quot;https://daimingzhi.blog.csdn.net/article/details/103589868&quot;&gt;Spring官网阅读（一）容器及实例化&lt;/a&gt; 已经分析过了，但是当时我们没有深究创建对象的细节，所以本文将详细探讨&lt;strong&gt;Spring中的这个对象到底是怎么创建出来的&lt;/strong&gt;，这也是本文的主题。&lt;/p&gt;
&lt;p&gt;在&lt;a href=&quot;https://daimingzhi.blog.csdn.net/article/details/103589868&quot;&gt;Spring官网阅读（一）容器及实例化&lt;/a&gt; 这篇文章中，我画了下面这么一张图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191217235508810.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTA3OTkx,size_16,color_FFFFFF,t_70&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上图中我们可以知道Spring在实例化对象的时候有这么几种方式&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;通过bd中的supplier属性&lt;/li&gt;
&lt;li&gt;通过bd中的factoryMethodName跟factoryBeanName&lt;/li&gt;
&lt;li&gt;通过构造函数&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;我们接下来就一一分析其中的细节：&lt;/p&gt;
&lt;h3 id=&quot;》通过bd中的supplier属性实例化对象&quot;&gt;》通过bd中的supplier属性实例化对象&lt;/h3&gt;
&lt;p&gt;在&lt;a href=&quot;https://daimingzhi.blog.csdn.net/article/details/103589868&quot;&gt;Spring官网阅读（一）容器及实例化&lt;/a&gt; 文中介绍过这种方式，因为这种方式我们基本不会使用，&lt;strong&gt;并不重要&lt;/strong&gt;，所以这里就不再赘述，我这里就直接给出一个使用示例，大家自行体会吧&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static void main(String[] args) {
                AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext();
    // 直接注册一个Bean,并且指定它的supplier就是Service::new
                ac.registerBean(&quot;service&quot;, Service.class,Service::new，zhe'sh);
                ac.refresh();
                System.out.println(ac.getBean(&quot;service&quot;));
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;》通过bd中的factorymethodname跟factorybeanname实例化对象&quot;&gt;》通过bd中的factoryMethodName跟factoryBeanName实例化对象&lt;/h3&gt;
&lt;p&gt;对应代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;protected BeanWrapper instantiateUsingFactoryMethod(
    String beanName, RootBeanDefinition mbd, @Nullable Object[] explicitArgs) {
    return new ConstructorResolver(this).instantiateUsingFactoryMethod(beanName, mbd, explicitArgs);
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面这段代码主要干了两件事&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;创建一个&lt;code&gt;ConstructorResolver&lt;/code&gt;对象，从类名来看，它是一个构造器解析器&lt;/li&gt;
&lt;li&gt;调用了这个构造器解析器的&lt;code&gt;instantiateUsingFactoryMethod&lt;/code&gt;方法，这个方法见名知意，使用&lt;code&gt;FactoryMethod&lt;/code&gt;来完成实例化&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;基于此，我们解决一个问题，&lt;code&gt;ConstructorResolver&lt;/code&gt;是什么？&lt;/p&gt;
&lt;h4 id=&quot;constructorresolver是什么？&quot;&gt;ConstructorResolver是什么？&lt;/h4&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;在要研究一个类前，我们最先应该从哪里入手呢？很多没有经验的同学可能会闷头看代码，但是实际上最好的学习方式是先阅读类上的javaDoc&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;ConstructorResolver上的javaDoc如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200520204544161.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面这段javaDoc翻译过来就是&lt;strong&gt;这个类就是用来解析构造函数跟工厂方法的代理者，并且它是通过参数匹配的方式来进行推断构造方法或者工厂方法&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;看到这里不知道小伙伴们是否有疑问，就是明明这个类不仅负责推断构造函数，还会负责推断工厂方法，那么为什么类名会叫做&lt;code&gt;ConstructorResolver&lt;/code&gt;呢？我们知道Spring的代码在业界来说绝对是最规范的，没有之一，这样来说的话，这个类最合适的名称应该是&lt;code&gt;ConstructorAndFactoryMethodResolver&lt;/code&gt;才对，因为它不仅负责推断了构造函数还负责推断了工厂方法嘛！&lt;/p&gt;
&lt;p&gt;这里我需要说一下我自己的理解。&lt;em&gt;对于一个Bean，它是通过构造函数完成实例化的，或者通过工厂方法实例化的，其实在这个Bean看来都没有太大区别，这两者都可以称之为这个Bean的构造器，因为通过它们都能构造出一个Bean。&lt;/em&gt;所以Spring就把两者统称为&lt;code&gt;构造器&lt;/code&gt;了，所以这个类名也就被称为&lt;code&gt;ConstructorResolver&lt;/code&gt;了。&lt;/p&gt;
&lt;p&gt;Spring在很多地方体现了这种实现，例如在XML配置的情况下，不论我们是使用构造函数创建对象还是使用工厂方法创建对象，其参数的标签都是使用&lt;code&gt;constructor-arg&lt;/code&gt;。比如下面这个例子&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-XML&quot;&gt;&amp;lt;bean id=&quot;dmzServiceGetFromStaticMethod&quot;
      factory-bean=&quot;factoryBean&quot;
      factory-method=&quot;getObject&quot;&amp;gt;
    &amp;lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;hello&quot; name=&quot;s&quot;/&amp;gt;
    &amp;lt;constructor-arg type=&quot;com.dmz.source.instantiation.service.DmzFactory&quot; ref=&quot;factoryBean&quot;/&amp;gt;
&amp;lt;/bean&amp;gt;

&amp;lt;!--测试静态工厂方法创建对象--&amp;gt;
&amp;lt;bean id=&quot;service&quot;
      class=&quot;com.dmz.official.service.MyFactoryBean&quot;
      factory-method=&quot;staticGet&quot;&amp;gt;
    &amp;lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;hello&quot;/&amp;gt;
&amp;lt;/bean&amp;gt;

&amp;lt;bean id=&quot;dmzService&quot; class=&quot;com.dmz.source.instantiation.service.DmzService&quot;&amp;gt;
    &amp;lt;constructor-arg name=&quot;s&quot; value=&quot;hello&quot;/&amp;gt;
&amp;lt;/bean&amp;gt;

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在对这个类有了大概的了解后，我们就需要来分析它的源码，这里我就不把它单独拎出来分析了，我们借着Spring的流程看看这个类干了什么事情&lt;/p&gt;
&lt;h4 id=&quot;instantiateusingfactorymethod方法做了什么？&quot;&gt;instantiateUsingFactoryMethod方法做了什么？&lt;/h4&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;核心目的：推断出要使用的factoryMethod以及调用这个FactoryMethod要使用的参数，然后反射调用这个方法实例化出一个对象&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这个方法的代码太长了，所以我们将它拆分成为一段一段的来分析&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;方法参数分析&quot;&gt;方法参数分析&lt;/h5&gt;
&lt;p&gt;在分析上面的代码之前，我们先来看看这个方法的参数都是什么含义&lt;/p&gt;
&lt;p&gt;方法上关于参数的介绍如图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200521202035984.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;beanName&lt;/code&gt;：当前要实例化的Bean的名称&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mbd&lt;/code&gt;：当前要实例化的Bean对应的BeanDefinition&lt;/li&gt;
&lt;li&gt;&lt;code&gt;explicitArgs&lt;/code&gt;：这个参数在容器启动阶段我们可以认定它就是null，只有显示的调用了getBean方法，并且传入了明确的参数，例如：&lt;code&gt;getBean(&quot;dmzService&quot;,&quot;hello&quot;)&lt;/code&gt;这种情况下才会不为null，&lt;strong&gt;我们分析这个方法的时候就直接认定这个参数为null即可&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;第一段&quot;&gt;第一段&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public BeanWrapper instantiateUsingFactoryMethod(
    String beanName, RootBeanDefinition mbd, @Nullable Object[] explicitArgs) {
    // 第一段代码：创建并初始话一个BeanWrapperImpl
    BeanWrapperImpl bw = new BeanWrapperImpl();
    this.beanFactory.initBeanWrapper(bw);
    // ......
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;BeanWrapperImpl是什么呢？如果你看过我之前的文章：&lt;a href=&quot;https://blog.csdn.net/qq_41907991/article/details/105214244&quot;&gt;Spring官网阅读（十四）Spring中的BeanWrapper及类型转换&lt;/a&gt;，那么你对这个类应该不会陌生，它就是对Bean进行了一层包装，并且在创建Bean的时候以及进行属性注入的时候能够进行类型转换。就算你没看过之前的文章也没关系，只要记住两点&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;BeanWrapperImpl包装了一个实例化好的对象&lt;/li&gt;
&lt;li&gt;BeanWrapperImpl能够对属性进行类型转换&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其层级关系如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200331082247233.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTA3OTkx,size_16,color_FFFFFF,t_70&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;回到我们的源码分析，我们先来看看&lt;code&gt;new BeanWrapperImpl()&lt;/code&gt;做了什么事情？&lt;/p&gt;
&lt;p&gt;对应代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 第一步：调用空参构造
public BeanWrapperImpl() {
    // 调用另外一个构造函数，表示要注册默认的属性编辑器
    this(true);
}

// 这个构造函数表明是否要注册默认编辑器，上面传入的值为true,表示需要注册
public BeanWrapperImpl(boolean registerDefaultEditors) {
    super(registerDefaultEditors);
}

// 调用到父类的构造函数，确定要使用默认的属性编辑器
protected AbstractNestablePropertyAccessor(boolean registerDefaultEditors) {
    if (registerDefaultEditors) {
        registerDefaultEditors();
    }
    // 对typeConverterDelegate进行初始化
    this.typeConverterDelegate = new TypeConverterDelegate(this);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;总的来说创建的过程非常简单。第一，确定要注册默认的属性编辑器；第二，对typeConverterDelegate属性进行初始化。&lt;/p&gt;
&lt;p&gt;紧接着，我们看看在初始化这个&lt;code&gt;BeanWrapper&lt;/code&gt;做了什么？&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 初始化BeanWrapper，主要就是将容器中配置的conversionService赋值到当前这个BeanWrapper上
// 同时注册定制的属性编辑器
protected void initBeanWrapper(BeanWrapper bw) {
    bw.setConversionService(getConversionService());
    registerCustomEditors(bw);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;还记得&lt;code&gt;conversionService&lt;/code&gt;在什么时候被放到容器中的吗?就是在&lt;a href=&quot;https://www.cnblogs.com/daimzh/p/13090856.html#finishBeanFactoryInitialization&quot;&gt;finishBeanFactoryInitialization&lt;/a&gt;的时候啦~！&lt;/p&gt;
&lt;p&gt;对&lt;code&gt;conversionService&lt;/code&gt;属性完成赋值后就开始注册定制的属性编辑器，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 传入的参数就是我们的BeanWrapper，它同时也是一个属性编辑器注册表
protected void registerCustomEditors(PropertyEditorRegistry registry) {
    PropertyEditorRegistrySupport registrySupport =
        (registry instanceof PropertyEditorRegistrySupport ? (PropertyEditorRegistrySupport) registry : null);
    if (registrySupport != null) {
        // 这个配置的作用就是在注册默认的属性编辑器时，可以增加对数组到字符串的转换功能
        // 默认就是通过&quot;,&quot;来切割字符串转换成数组，对应的属性编辑器就是StringArrayPropertyEditor
        registrySupport.useConfigValueEditors();
    }
    // 将容器中的属性编辑器注册到当前的这个BeanWrapper
    if (!this.propertyEditorRegistrars.isEmpty()) {
        for (PropertyEditorRegistrar registrar : this.propertyEditorRegistrars) {
            registrar.registerCustomEditors(registry);
            // 省略异常处理~
        }
    }
    // 这里我们没有添加任何的自定义的属性编辑器，所以肯定为空
    if (!this.customEditors.isEmpty()) {
        this.customEditors.forEach((requiredType, editorClass) -&amp;gt;
                                   registry.registerCustomEditor(requiredType, BeanUtils.instantiateClass(editorClass)));
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;第二段&quot;&gt;第二段&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public BeanWrapper instantiateUsingFactoryMethod(
    String beanName, RootBeanDefinition mbd, @Nullable Object[] explicitArgs) {

    // 省略已经分析的第一段代码，到这里已经得到了一个具有类型转换功能的BeanWrapper
        
    // 实例化这个Bean的工厂Bean
    Object factoryBean;
    // 工厂Bean的Class
    Class&amp;lt;?&amp;gt; factoryClass;
    // 静态工厂方法或者是实例化工厂方法
    boolean isStatic;
        
    /*下面这段代码就是为上面申明的这三个属性赋值*/ 
    String factoryBeanName = mbd.getFactoryBeanName();
    // 如果创建这个Bean的工厂就是这个Bean本身的话，那么直接抛出异常
    if (factoryBeanName != null) {
        if (factoryBeanName.equals(beanName)) {
            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,
                                                   &quot;factory-bean reference points back to the same bean definition&quot;);
        }
        // 得到创建这个Bean的工厂Bean
        factoryBean = this.beanFactory.getBean(factoryBeanName);
        if (mbd.isSingleton() &amp;amp;&amp;amp; this.beanFactory.containsSingleton(beanName)) {
            throw new ImplicitlyAppearedSingletonException();
        }
        factoryClass = factoryBean.getClass();
        isStatic = false;
    }
    else {
        // factoryBeanName为null,说明是通过静态工厂方法来实例化Bean的
        // 静态工厂进行实例化Bean，beanClass属性必须要是工厂的class,如果为空，直接报错
        if (!mbd.hasBeanClass()) {
            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,
                                                   &quot;bean definition declares neither a bean class nor a factory-bean reference&quot;);
        }
        factoryBean = null;
        factoryClass = mbd.getBeanClass();
        isStatic = true;
    }
    // 省略后续代码
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;小总结：&lt;/p&gt;
&lt;p&gt;这段代码很简单，就是确认实例化当前这个Bean的工厂方法是静态工厂还是实例工厂，如果是实例工厂，那么找出对应的工厂Bean。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;第三段&quot;&gt;第三段&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public BeanWrapper instantiateUsingFactoryMethod(
    String beanName, RootBeanDefinition mbd, @Nullable Object[] explicitArgs) {
    
    // 省略第一段，第二段代码
    
    // 到这里已经得到了一个BeanWrapper,明确了实例化当前这个Bean到底是静态工厂还是实例工厂
    // 并且已经确定了工厂Bean
    
    // 最终确定的要用来创建对象的方法
    Method factoryMethodToUse = null;
    ArgumentsHolder argsHolderToUse = null;
    Object[] argsToUse = null;
        
    // 参数分析时已经说过，explicitArgs就是null
    if (explicitArgs != null) {
        argsToUse = explicitArgs;
    }
    else {
        // 下面这段代码是什么意思呢？
        // 在原型模式下，我们会多次创建一个Bean,所以Spring对参数以及所使用的方法做了缓存
        // 在第二次创建原型对象的时候会进入这段缓存的逻辑
        // 但是这里有个问题，为什么Spring对参数有两个缓存呢？
        // 一：resolvedConstructorArguments
        // 二：preparedConstructorArguments
        // 这里主要是因为，直接使用解析好的构造的参数，因为这样会导致创建出来的所有Bean都引用同一个属性
        Object[] argsToResolve = null;
        synchronized (mbd.constructorArgumentLock) {
            factoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;
            // 缓存已经解析过的工厂方法或者构造方法
            if (factoryMethodToUse != null &amp;amp;&amp;amp; mbd.constructorArgumentsResolved) {
                // resolvedConstructorArguments跟preparedConstructorArguments都是对参数的缓存
                argsToUse = mbd.resolvedConstructorArguments;
                if (argsToUse == null) {
                    argsToResolve = mbd.preparedConstructorArguments;
                }
            }
        }
        if (argsToResolve != null) {
            // preparedConstructorArguments需要再次进行解析
            argsToUse = resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);
        }
    }
    // 省略后续代码
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;小总结：&lt;/p&gt;
&lt;p&gt;上面这段代码应该没什么大问题，其核心思想就是从缓存中取已经解析出来的方法以及参数，这段代码只会在原型模式下生效，因为单例的话对象只会创建一次嘛~！&lt;strong&gt;最大的问题在于，为什么在对参数进行缓存的时候使用了两个不同的集合，并且缓存后的参数还需要再次解析&lt;/strong&gt;，这个问题我们暂且放着，不妨带着这个问题往下看。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;p&gt;因为接下来要分析的代码就比较复杂了，所以为了让你彻底看到代码的执行流程，下面我会使用&lt;strong&gt;示例+流程图+文字&lt;/strong&gt;的方式来分析源码。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例代码如下（这个例子覆盖接下来要分析的所有流程）：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;配置文件：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
           xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
           xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;
           default-autowire=&quot;constructor&quot;&amp;gt;&amp;lt;!--这里开启自动注入，并且是通过构造函数进行自动注入--&amp;gt;

        &amp;lt;!--factoryObject 提供了创建对象的方法--&amp;gt;
        &amp;lt;bean id=&quot;factoryObject&quot; class=&quot;com.dmz.spring.first.instantiation.service.FactoryObject&quot;/&amp;gt;

        &amp;lt;!--提供一个用于测试自动注入的对象--&amp;gt;
        &amp;lt;bean class=&quot;com.dmz.spring.first.instantiation.service.OrderService&quot; id=&quot;orderService&quot;/&amp;gt;
        
    &amp;lt;!--主要测试这个对象的实例化过程--&amp;gt;
        &amp;lt;bean id=&quot;dmzService&quot; factory-bean=&quot;factoryObject&quot; factory-method=&quot;getDmz&quot; scope=&quot;prototype&quot;&amp;gt;
                &amp;lt;constructor-arg name=&quot;name&quot; value=&quot;dmz&quot;/&amp;gt;
                &amp;lt;constructor-arg name=&quot;age&quot; value=&quot;18&quot;/&amp;gt;
                &amp;lt;constructor-arg name=&quot;birthDay&quot; value=&quot;2020-05-23&quot;/&amp;gt;
        &amp;lt;/bean&amp;gt;
        
    &amp;lt;!--测试静态方法实例化对象的过程--&amp;gt;
        &amp;lt;bean id=&quot;indexService&quot; class=&quot;com.dmz.spring.first.instantiation.service.FactoryObject&quot;
                  factory-method=&quot;staticGetIndex&quot;/&amp;gt;
        
    &amp;lt;!--提供这个转换器,用于转换dmzService中的birthDay属性,从字符串转换成日期对象--&amp;gt;
        &amp;lt;bean class=&quot;org.springframework.context.support.ConversionServiceFactoryBean&quot; id=&quot;conversionService&quot;&amp;gt;
                &amp;lt;property name=&quot;converters&quot;&amp;gt;
                        &amp;lt;set&amp;gt;
                                &amp;lt;bean class=&quot;com.dmz.spring.first.instantiation.service.ConverterStr2Date&quot;/&amp;gt;
                        &amp;lt;/set&amp;gt;
                &amp;lt;/property&amp;gt;
        &amp;lt;/bean&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class FactoryObject {

        public DmzService getDmz(String name, int age, Date birthDay, OrderService orderService) {
                System.out.println(&quot;getDmz with &quot;+&quot;name,age,birthDay and orderService&quot;);
                return new DmzService();
        }

        public DmzService getDmz(String name, int age, Date birthDay) {
                System.out.println(&quot;getDmz with &quot;+&quot;name,age,birthDay&quot;);
                return new DmzService();
        }

        public DmzService getDmz(String name, int age) {
                System.out.println(&quot;getDmz with &quot;+&quot;name,age&quot;);
                return new DmzService();
        }

        public DmzService getDmz() {
                System.out.println(&quot;getDmz with empty arg&quot;);
                return new DmzService();
        }

        public static IndexService staticGetIndex() {
                return new IndexService();
        }
}

public class DmzService {
}

public class IndexService {
}

public class OrderService {
}

public class ConverterStr2Date implements Converter&amp;lt;String, Date&amp;gt; {
        @Override
        public Date convert(String source) {
                try {
                        return new SimpleDateFormat(&quot;yyyy-MM-dd&quot;).parse(source);
                } catch (ParseException e) {
                        return null;
                }
        }
}

/**
 * @author 程序员DMZ
 * @Date Create in 23:14 2020/5/21
 * @Blog https://daimingzhi.blog.csdn.net/
 */
public class Main {
        public static void main(String[] args) {
                ClassPathXmlApplicationContext cc = new ClassPathXmlApplicationContext();
                cc.setConfigLocation(&quot;application.xml&quot;);
                cc.refresh();
                cc.getBean(&quot;dmzService&quot;);
        // 两次调用，用于测试缓存的方法及参数
//              cc.getBean(&quot;dmzService&quot;);

        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行上面的代码会发现，程序打印：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;getDmz with name,age,birthDay and orderService&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;具体原因我相信你看了接下来的源码分析自然就懂了&lt;/p&gt;
&lt;h5 id=&quot;第四段&quot;&gt;第四段&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public BeanWrapper instantiateUsingFactoryMethod(
    String beanName, RootBeanDefinition mbd, @Nullable Object[] explicitArgs) {
//  第一段代码：到这里已经得到了一个BeanWrapper，并对这个BeanWrapper做了初始化
//  第二段代码：明确了实例化当前这个Bean到底是静态工厂还是实例工厂
//      第三段代码：以及从缓存中取过了对应了方法以及参数

// 进入第四段代码分析，执行到这段代码说明是第一次实例化这个对象
if (factoryMethodToUse == null || argsToUse == null) {
                        // 如果被cglib代理的话，获取父类的class
                        factoryClass = ClassUtils.getUserClass(factoryClass);
                        // 获取到工厂类中的所有方法，接下来要一步步从这些方法中筛选出来符合要求的方法
                        Method[] rawCandidates = getCandidateMethods(factoryClass, mbd);
                        List&amp;lt;Method&amp;gt; candidateList = new ArrayList&amp;lt;&amp;gt;();
                // 第一步筛选：之前 在第二段代码中已经推断了方法是静态或者非静态的
                // 所以这里第一个要求就是要满足静态/非静态这个条件
                // 第二个要求就是必须符合bd中定义的factoryMethodName的名称
                // 其中第二个要求请注意，如果bd是一个configurationClassBeanDefinition,也就是说是通过扫描@Bean注解产生的，那么在判断时还会添加是否标注了@Bean注解
                        for (Method candidate : rawCandidates) {
                                if (Modifier.isStatic(candidate.getModifiers()) == isStatic &amp;amp;&amp;amp; mbd.isFactoryMethod(candidate)) {
                                        candidateList.add(candidate);
                                }
                        }
                // 将之前得到的方法集合转换成数组
                // 到这一步得到的其实就是某一个方法的所有重载方法
                // 比如dmz(),dmz(String name),dmz(String name,int age)
                        Method[] candidates = candidateList.toArray(new Method[0]);
    
                // 排序，public跟参数多的优先级越高
                        AutowireUtils.sortFactoryMethods(candidates);
                        
                // 用来保存从配置文件中解析出来的参数
                        ConstructorArgumentValues resolvedValues = null;
            // 是否使用了自动注入，本段代码中没有使用到这个属性，但是在后面用到了
                        boolean autowiring = (mbd.getResolvedAutowireMode() == AutowireCapableBeanFactory.AUTOWIRE_CONSTRUCTOR);
                        int minTypeDiffWeight = Integer.MAX_VALUE;
                // 可能出现多个符合要求的方法，用这个集合保存，实际上如果这个集合有值，就会抛出异常了
                        Set&amp;lt;Method&amp;gt; ambiguousFactoryMethods = null;

                        int minNrOfArgs;
                // 必定为null,不考虑了
                        if (explicitArgs != null) {
                                minNrOfArgs = explicitArgs.length;
                        }
                        else {
                // 就是说配置文件中指定了要使用的参数，那么需要对其进行解析，解析后的值就存储在resolvedValues这个集合中
                                if (mbd.hasConstructorArgumentValues()) {
                    // 通过解析constructor-arg标签，将参数封装成了ConstructorArgumentValues
                    // ConstructorArgumentValues这个类在下文我们专门分析
                                        ConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();
                                        resolvedValues = new ConstructorArgumentValues();
                    // 解析标签中的属性，类似进行类型转换，后文进行详细分析
                                        minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);
                                }
                                else {
                    // 配置文件中没有指定要使用的参数，所以执行方法的最小参数个数就是0
                                        minNrOfArgs = 0;
                                }
                        }
        // 省略后续代码....
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;94&quot;&gt;
&lt;p&gt;小总结：&lt;/p&gt;
&lt;p&gt;因为在实例化对象前必定要先确定具体要使用的方法，所以这里先做的第一件事就是确定要在哪个范围内去推断要使用的factoryMethod呢？&lt;/p&gt;
&lt;p&gt;最大的范围就是这个factoryClass的所有方法，也就是源码中的&lt;code&gt;rawCandidates&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;其次需要在&lt;code&gt;rawCandidates&lt;/code&gt;中进一步做推断，因为在前面&lt;strong&gt;第二段代码&lt;/strong&gt;的时候已经确定了是静态方法还是非静态方法，并且&lt;code&gt;BeanDefinition&lt;/code&gt;也指定了factoryMethodName，那么基于这两个条件这里就需要对&lt;code&gt;rawCandidates&lt;/code&gt;进一步进行筛选，得到一个&lt;code&gt;candidateList&lt;/code&gt;集合。&lt;/p&gt;
&lt;p&gt;我们对示例的代码进行调试会发现&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRlZS5jb20vd3hfY2MzNDdiZTY5Ni9ibG9nSW1hZ2UvcmF3L21hc3Rlci9pbWFnZS0yMDIwMDUyMzIwNTg1NjY1NS5wbmc?x-oss-process=image/format,png&quot; alt=&quot;image-20200523205856655&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;确实如我们所料，&lt;code&gt;rawCandidates&lt;/code&gt;是factoryClass中的所有方法，&lt;code&gt;candidateList&lt;/code&gt;是所有getDmz的重载方法。&lt;/p&gt;
&lt;p&gt;在确定了推断factoryMethod的范围后，那么接下来要根据什么去确定到底使用哪个方法呢？换个问题，怎么区分这么些重载的方法呢？肯定是根据方法参数嘛！&lt;/p&gt;
&lt;p&gt;所以接下来要做的就是去解析要使用的参数了~&lt;/p&gt;
&lt;p&gt;对于Spring而言，方法的参数会分为两种&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;配置文件中指定的&lt;/li&gt;
&lt;li&gt;自动注入模式下，需要去容器中查找的&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;在上面的代码中，Spring就是将配置文件中指定的参数做了一次解析，对应方法就是&lt;code&gt;resolveConstructorArguments&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在查看这个方法的源码前，我们先看看&lt;code&gt;ConstructorArgumentValues&lt;/code&gt;这个类&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class ConstructorArgumentValues {
        // 通过下标方式指定的参数
        private final Map&amp;lt;Integer, ValueHolder&amp;gt; indexedArgumentValues = new LinkedHashMap&amp;lt;&amp;gt;();
        // 没有指定下标
        private final List&amp;lt;ValueHolder&amp;gt; genericArgumentValues = new ArrayList&amp;lt;&amp;gt;();
        // 省略无关代码.....
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在前文的注释中我们也说过了，它主要的作用就是封装解析&lt;code&gt;constructor-arg&lt;/code&gt;标签得到的属性，解析标签对应的方法就是&lt;code&gt;org.springframework.beans.factory.xml.BeanDefinitionParserDelegate#parseConstructorArgElement&lt;/code&gt;，这个方法我就不带大家看了，有兴趣的可以自行阅读。&lt;/p&gt;
&lt;p&gt;它主要有两个属性&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;indexedArgumentValues&lt;/li&gt;
&lt;li&gt;genericArgumentValues&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;对应的就是我们两种指定参数的方法，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;bean id=&quot;dmzService&quot; factory-bean=&quot;factoryObject&quot; factory-method=&quot;getDmz&quot; scope=&quot;prototype&quot;&amp;gt;
    &amp;lt;constructor-arg name=&quot;name&quot; value=&quot;dmz&quot;/&amp;gt;
    &amp;lt;constructor-arg name=&quot;age&quot; value=&quot;18&quot;/&amp;gt;
    &amp;lt;constructor-arg index=&quot;2&quot;  value=&quot;2020-05-23&quot;/&amp;gt;
    &amp;lt;!--             &amp;lt;constructor-arg name=&quot;birthDay&quot; value=&quot;2020-05-23&quot;/&amp;gt;--&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中的name跟age属性会被解析为&lt;code&gt;genericArgumentValues&lt;/code&gt;，而&lt;code&gt;index=2&lt;/code&gt;会被解析为&lt;code&gt;indexedArgumentValues&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在对&lt;code&gt;ConstructorArgumentValues&lt;/code&gt;有一定认知之后，我们再来看看&lt;code&gt;resolveConstructorArguments&lt;/code&gt;的代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 方法目的：解析配置文件中指定的方法参数
// beanName：bean名称
// mbd：beanName对应的beanDefinition
// bw：通过它进行类型转换
// ConstructorArgumentValues cargs：解析标签得到的属性，还没有经过解析（类型转换）
// ConstructorArgumentValues resolvedValues：已经经过解析的参数
// 返回值：返回方法需要的最小参数个数
private int resolveConstructorArguments(String beanName, RootBeanDefinition mbd, BeanWrapper bw,
                                        ConstructorArgumentValues cargs, ConstructorArgumentValues resolvedValues) {
        
    // 是否有定制的类型转换器，没有的话直接使用BeanWrapper进行类型转换
    TypeConverter customConverter = this.beanFactory.getCustomTypeConverter();
    TypeConverter converter = (customConverter != null ? customConverter : bw);
    
    // 构造一个BeanDefinitionValueResolver，专门用于解析constructor-arg中的value属性，实际上还包括ref属性，内嵌bean标签等等
    BeanDefinitionValueResolver valueResolver =
        new BeanDefinitionValueResolver(this.beanFactory, beanName, mbd, converter);
        
    // minNrOfArgs 记录执行方法要求的最小参数个数，一般情况下就是等于constructor-arg标签指定的参数数量
    int minNrOfArgs = cargs.getArgumentCount();

    for (Map.Entry&amp;lt;Integer, ConstructorArgumentValues.ValueHolder&amp;gt; entry : cargs.getIndexedArgumentValues().entrySet()) {
        int index = entry.getKey();
        if (index &amp;lt; 0) {
            throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                                            &quot;Invalid constructor argument index: &quot; + index);
        }
        // 这是啥意思呢？
        // 这个代码我认为是有问题的，并且我给Spring官方已经提了一个issue，官方将会在5.2.7版本中修复
        // 暂且你先这样理解
        // 假设A方法直接在配置文件中指定了index=3上要使用的参数，那么这个时候A方法至少需要4个参数
        // 但是其余的3个参数可能不是通过constructor-arg标签指定的，而是直接自动注入进来的，那么在配置文件中我们就只配置了index=3上的参数，也就是说 int minNrOfArgs = cargs.getArgumentCount()=1，这个时候 index=3,minNrOfArgs=1, 所以 minNrOfArgs = 3+1
        if (index &amp;gt; minNrOfArgs) {
            minNrOfArgs = index + 1;
        }
        ConstructorArgumentValues.ValueHolder valueHolder = entry.getValue();
        // 如果已经转换过了，直接添加到resolvedValues集合中
        if (valueHolder.isConverted()) {
            resolvedValues.addIndexedArgumentValue(index, valueHolder);
        }
        else {
            // 解析value/ref/内嵌bean标签等
            Object resolvedValue =
                valueResolver.resolveValueIfNecessary(&quot;constructor argument&quot;, valueHolder.getValue());
            // 将解析后的resolvedValue封装成一个新的ValueHolder，并将其source设置为解析constructor-arg得到的那个ValueHolder，后期会用到这个属性进行判断
            ConstructorArgumentValues.ValueHolder resolvedValueHolder =
                new ConstructorArgumentValues.ValueHolder(resolvedValue, valueHolder.getType(), valueHolder.getName());
            resolvedValueHolder.setSource(valueHolder);
            resolvedValues.addIndexedArgumentValue(index, resolvedValueHolder);
        }
    }
   // 对getGenericArgumentValues进行解析，代码基本一样，不再赘述
    return minNrOfArgs;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，最终的解析逻辑就在&lt;code&gt;resolveValueIfNecessary&lt;/code&gt;这个方法中，那么这个方法又做了什么呢？&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 这个方法的目的就是将解析constructor-arg标签得到的value值进行一次解析
// 在解析标签时ref属性会被封装为RuntimeBeanReference，那么在这里进行解析时就会去调用getBean
// 在解析value属性会会被封装为TypedStringValue，那么这里会尝试去进行一个转换
// 关于标签的解析大家有兴趣的话可以去看看org.springframework.beans.factory.xml.BeanDefinitionParserDelegate#parsePropertyValue
// 这里不再赘述了
public Object resolveValueIfNecessary(Object argName, @Nullable Object value) {
        
    // 解析constructor-arg标签中的ref属性，实际就是调用了getBean
    if (value instanceof RuntimeBeanReference) {
        RuntimeBeanReference ref = (RuntimeBeanReference) value;
        return resolveReference(argName, ref);
    }
    
    // ......
    
       /**  
                 * &amp;lt;constructor-arg&amp;gt;
                 *                      &amp;lt;set value-type=&quot;java.lang.String&quot;&amp;gt;
                 *                              &amp;lt;value&amp;gt;1&amp;lt;/value&amp;gt;
                 *                      &amp;lt;/set&amp;gt;
                 * &amp;lt;/constructor-arg&amp;gt;
                 * 通过上面set标签中的value-type属性对value进行类型转换,
                 * 如果value-type属性为空,那么这里不会进行类型转换
                 */
   else if (value instanceof TypedStringValue) {
                        TypedStringValue typedStringValue = (TypedStringValue) value;
                        Object valueObject = evaluate(typedStringValue);
                        try {
                                Class&amp;lt;?&amp;gt; resolvedTargetType = resolveTargetType(typedStringValue);
                                if (resolvedTargetType != null) {
                                        return this.typeConverter.convertIfNecessary(valueObject, resolvedTargetType);
                                }
                                else {
                                        return valueObject;
                                }
                        }
                        catch (Throwable ex) {
                                // Improve the message by showing the context.
                                throw new BeanCreationException(
                                                this.beanDefinition.getResourceDescription(), this.beanName,
                                                &quot;Error converting typed String value for &quot; + argName, ex);
                        }
                }
    // 省略后续代码....
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;就我们上面的例子而言，经过&lt;code&gt;resolveValueIfNecessary&lt;/code&gt;方法并不能产生实际的影响，因为在XML中我们没有配置ref属性或者value-type属性。&lt;/p&gt;
&lt;p&gt;画图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRlZS5jb20vd3hfY2MzNDdiZTY5Ni9ibG9nSW1hZ2UvcmF3L21hc3Rlci9pbWFnZS0yMDIwMDUyOTA3MTQyODE1NS5wbmc?x-oss-process=image/format,png&quot; alt=&quot;image-20200529071428155&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;第五段&quot;&gt;第五段&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public BeanWrapper instantiateUsingFactoryMethod(
    String beanName, RootBeanDefinition mbd, @Nullable Object[] explicitArgs) {
    //  第一段代码：到这里已经得到了一个BeanWrapper，并对这个BeanWrapper做了初始化
    //  第二段代码：明确了实例化当前这个Bean到底是静态工厂还是实例工厂
    //  第三段代码：以及从缓存中取过了对应了方法以及参数
    //  第四段代码：明确了方法需要的最小的参数数量并对配置文件中的标签属性进行了一次解析

    // 进入第五段代码分析
    
    // 保存在创建方法参数数组过程中发生的异常，如果最终没有找到合适的方法，那么将这个异常信息封装后抛出
    LinkedList&amp;lt;UnsatisfiedDependencyException&amp;gt; causes = null;
    
    // 开始遍历所有在第四段代码中查询到的符合要求的方法
    for (Method candidate : candidates) {
        // 方法的参数类型
        Class&amp;lt;?&amp;gt;[] paramTypes = candidate.getParameterTypes();
        // 候选的方法的参数必须要大于在第四段这推断出来的最小参数个数
        if (paramTypes.length &amp;gt;= minNrOfArgs) {
            ArgumentsHolder argsHolder;
            // 必定为null,不考虑
            if (explicitArgs != null) {
                // Explicit arguments given -&amp;gt; arguments length must match exactly.
                if (paramTypes.length != explicitArgs.length) {
                    continue;
                }
                argsHolder = new ArgumentsHolder(explicitArgs);
            }
            else {
                // Resolved constructor arguments: type conversion and/or autowiring necessary.
                try {
                    // 获取参数的具体名称
                    String[] paramNames = null;
                    ParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer();
                    if (pnd != null) {
                        paramNames = pnd.getParameterNames(candidate);
                    }
                    // 根据方法的参数名称以及配置文件中配置的参数创建一个参数数组用于执行工厂方法
                    argsHolder = createArgumentArray(
                        beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);
                }
                // 在创建参数数组的时候可能发生异常，这个时候的异常不能直接抛出，要确保所有的候选方法遍历完成，只要有一个方法符合要求即可，但是如果遍历完所有方法还是没找到合适的构造器，那么直接抛出这些异常
                catch (UnsatisfiedDependencyException ex) {
                    if (logger.isTraceEnabled()) {
                        logger.trace(&quot;Ignoring factory method [&quot; + candidate + &quot;] of bean '&quot; + beanName + &quot;': &quot; + ex);
                    }
                    // Swallow and try next overloaded factory method.
                    if (causes == null) {
                        causes = new LinkedList&amp;lt;&amp;gt;();
                    }
                    causes.add(ex);
                    continue;
                }
                // 计算类型差异
                // 首先判断bd中是宽松模式还是严格模式，目前看来只有@Bean标注的方法解析得到的Bean会使用严格模式来计算类型差异，其余都是使用宽松模式
                // 严格模式下，
                int typeDiffWeight = (mbd.isLenientConstructorResolution() ?
                                      argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));
                // 选择一个类型差异最小的方法
                if (typeDiffWeight &amp;lt; minTypeDiffWeight) {
                    factoryMethodToUse = candidate;
                    argsHolderToUse = argsHolder;
                    argsToUse = argsHolder.arguments;
                    minTypeDiffWeight = typeDiffWeight;
                    ambiguousFactoryMethods = null;
                }
        // 省略后续代码.......
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;40&quot;&gt;
&lt;p&gt;小总结：这段代码的核心思想就是根据&lt;code&gt;第四段&lt;/code&gt;代码从配置文件中解析出来的参数构造方法执行所需要的实际参数数组。如果构建成功就代表这个方法可以用于实例化Bean，然后计算实际使用的参数跟方法上申明的参数的”差异值“，并在所有符合要求的方法中选择一个差异值最小的方法&lt;/p&gt;
&lt;p&gt;接下来，我们来分析方法实现的细节&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;构建方法使用的参数数组，也就是&lt;code&gt;createArgumentArray&lt;/code&gt;方法，其源码如下：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/* beanName：要实例化的Bean的名称
 * mbd：对应Bean的BeanDefinition
 * resolvedValues：从配置文件中解析出来的并尝试过类型转换的参数
 * bw：在这里主要就是用作类型转换器
 * paramTypes：当前遍历到的候选的方法的参数类型数组
 * paramNames：当前遍历到的候选的方法的参数名称
 * executable：当前遍历到的候选的方法
 * autowiring：是否时自动注入
 */
private ArgumentsHolder createArgumentArray(
    String beanName, RootBeanDefinition mbd, @Nullable ConstructorArgumentValues resolvedValues,
                        BeanWrapper bw, Class&amp;lt;?&amp;gt;[] paramTypes, @Nullable String[] paramNames, Executable executable,
                        boolean autowiring) throws UnsatisfiedDependencyException {

                TypeConverter customConverter = this.beanFactory.getCustomTypeConverter();
                TypeConverter converter = (customConverter != null ? customConverter : bw);

                ArgumentsHolder args = new ArgumentsHolder(paramTypes.length);
                Set&amp;lt;ConstructorArgumentValues.ValueHolder&amp;gt; usedValueHolders = new HashSet&amp;lt;&amp;gt;(paramTypes.length);
                Set&amp;lt;String&amp;gt; autowiredBeanNames = new LinkedHashSet&amp;lt;&amp;gt;(4);
                // 遍历候选方法的参数，跟据方法实际需要的类型到resolvedValues中去匹配
                for (int paramIndex = 0; paramIndex &amp;lt; paramTypes.length; paramIndex++) {
                        Class&amp;lt;?&amp;gt; paramType = paramTypes[paramIndex];
                        String paramName = (paramNames != null ? paramNames[paramIndex] : &quot;&quot;);
                        
                        ConstructorArgumentValues.ValueHolder valueHolder = null;
                        if (resolvedValues != null) {
                // 首先，根据方法参数的下标到resolvedValues中找对应的下标的属性
                // 如果没找到再根据方法的参数名/类型去resolvedValues查找
                                valueHolder = resolvedValues.getArgumentValue(paramIndex, paramType, paramName, usedValueHolders);
                                // 如果都没找到
                // 1.是自动注入并且方法的参数长度正好跟配置中的参数数量相等
                // 2.不是自动注入
                // 那么按照顺序一次选取
                                if (valueHolder == null &amp;amp;&amp;amp; (!autowiring || paramTypes.length == resolvedValues.getArgumentCount())) {
                                        valueHolder = resolvedValues.getGenericArgumentValue(null, null, usedValueHolders);
                                }
                        }
                        // 也就是说在配置的参数中找到了合适的值可以应用于这个方法上
                        if (valueHolder != null) {
                                // 防止同一个参数被应用了多次
                                usedValueHolders.add(valueHolder);
                                Object originalValue = valueHolder.getValue();
                                Object convertedValue;
                // 已经进行过类型转换就不会需要再次进行类型转换
                                if (valueHolder.isConverted()) {
                                        convertedValue = valueHolder.getConvertedValue();
                                        args.preparedArguments[paramIndex] = convertedValue;
                                }
                                else {
                                        // 尝试将配置的值转换成方法参数需要的类型
                                        MethodParameter methodParam = MethodParameter.forExecutable(executable, paramIndex);
                                        try {
                        // 进行类型转换
                                                convertedValue = converter.convertIfNecessary(originalValue, paramType, methodParam);
                                        }
                                        catch (TypeMismatchException ex) {
                                                // 抛出UnsatisfiedDependencyException，在调用该方法处会被捕获
                                        }
                                        Object sourceHolder = valueHolder.getSource();
                    // 只要是valueHolder存在，到这里这个判断必定成立
                                        if (sourceHolder instanceof ConstructorArgumentValues.ValueHolder) {
                                                Object sourceValue = ((ConstructorArgumentValues.ValueHolder) sourceHolder).getValue();
                                                args.resolveNecessary = true;
                                                args.preparedArguments[paramIndex] = sourceValue;
                                        }
                                }

                                args.arguments[paramIndex] = convertedValue;
                                args.rawArguments[paramIndex] = originalValue;
                        }
                        else {
                // 方法执行需要参数，但是resolvedValues中没有提供这个参数，也就是说这个参数是要自动注入到Bean中的
                                MethodParameter methodParam = MethodParameter.forExecutable(executable, paramIndex);
                                // 不是自动注入，直接抛出异常
                                if (!autowiring) {
                                        // 抛出UnsatisfiedDependencyException，在调用该方法处会被捕获
                                }
                                try {
                    // 自动注入的情况下，调用getBean获取需要注入的Bean
                                        Object autowiredArgument =
                                                        resolveAutowiredArgument(methodParam, beanName, autowiredBeanNames, converter);
                    // 把getBean返回的Bean封装到本次方法执行时需要的参数数组中去
                                        args.rawArguments[paramIndex] = autowiredArgument;
                                        args.arguments[paramIndex] = autowiredArgument;
                    // 标志这个参数是自动注入的
                                        args.preparedArguments[paramIndex] = new AutowiredArgumentMarker();
                    // 自动注入的情况下，在第二次调用时，需要重新处理，不能直接缓存
                                        args.resolveNecessary = true;
                                }
                                catch (BeansException ex) {
                                        // 抛出UnsatisfiedDependencyException，在调用该方法处会被捕获
                                }
                        }
                }
                
        // 注册Bean之间的依赖关系
                for (String autowiredBeanName : autowiredBeanNames) {
                        this.beanFactory.registerDependentBean(autowiredBeanName, beanName);
                        if (logger.isDebugEnabled()) {
                                logger.debug(&quot;Autowiring by type from bean name '&quot; + beanName +
                                                &quot;' via &quot; + (executable instanceof Constructor ? &quot;constructor&quot; : &quot;factory method&quot;) +
                                                &quot; to bean named '&quot; + autowiredBeanName + &quot;'&quot;);
                        }
                }

                return args;
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面这段代码说难也难，说简单也简单，如果要彻底看懂它到底干了什么还是很有难度的。简单来说，它就是从第四段代码解析出来的参数中查找当前的这个候选方法需要的参数。如果找到了，那么尝试对其进行类型转换，将其转换成符合方法要求的类型，如果没有找到那么还需要判断当前方法的这个参数能不能进行自动注入，如果可以自动注入的话，那么调用getBean得到需要的Bean，并将其注入到方法需要的参数中。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;第六段&quot;&gt;第六段&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public BeanWrapper instantiateUsingFactoryMethod(
    String beanName, RootBeanDefinition mbd, @Nullable Object[] explicitArgs) {
    //  第一段代码：到这里已经得到了一个BeanWrapper，并对这个BeanWrapper做了初始化
    //  第二段代码：明确了实例化当前这个Bean到底是静态工厂还是实例工厂
    //  第三段代码：以及从缓存中取过了对应了方法以及参数
    //  第四段代码：明确了方法需要的最小的参数数量并对配置文件中的标签属性进行了一次解析
    //  第五段代码：到这里已经确定了可以使用来实例化Bean的方法是哪个
    
        // 省略抛出异常的代码，就是在对推断出来的方法做验证
    // 1.推断出来的方法不能为null
    // 2.推断出来的方法返回值不能为void
    // 3.推断出来的方法不能有多个
                
    // 对参数进行缓存
      if (explicitArgs == null &amp;amp;&amp;amp; argsHolderToUse != null) {
         argsHolderToUse.storeCache(mbd, factoryMethodToUse);
      }
   }

   try {
      Object beanInstance;

      if (System.getSecurityManager() != null) {
         final Object fb = factoryBean;
         final Method factoryMethod = factoryMethodToUse;
         final Object[] args = argsToUse;
         beanInstance = AccessController.doPrivileged((PrivilegedAction&amp;lt;Object&amp;gt;) () -&amp;gt;
               beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args),
               beanFactory.getAccessControlContext());
      }
      else {
          // 反射调用对应方法进行实例化
          // 1.获取InstantiationStrategy，主要就是SimpleInstantiationStrategy跟CglibSubclassingInstantiationStrategy，其中CglibSubclassingInstantiationStrategy主要是用来处理beanDefinition中的lookupMethod跟replaceMethod。通常来说我们使用的就是SimpleInstantiationStrateg
          // 2.SimpleInstantiationStrateg就是单纯的通过反射调用方法
         beanInstance = this.beanFactory.getInstantiationStrategy().instantiate(
               mbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);
      }
                // beanWrapper在这里对Bean进行了包装
      bw.setBeanInstance(beanInstance);
      return bw;
   }
   catch (Throwable ex) {
      throw new BeanCreationException(mbd.getResourceDescription(), beanName,
            &quot;Bean instantiation via factory method failed&quot;, ex);
   }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;上面这段代码的主要目的就是&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;缓存参数，原型可能多次创建同一个对象&lt;/li&gt;
&lt;li&gt;反射调用推断出来的factoryMethod&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;h3 id=&quot;》通过构造函数实例化对象&quot;&gt;》通过构造函数实例化对象&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;如果上面你对使用factoryMethd进行实例化对象已经足够了解的话，那么下面的源码分析基本没有什么很大区别，我们接着看看代码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;首先，我们回到&lt;code&gt;createBeanInstance&lt;/code&gt;方法中，&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;protected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) {
    // 上面的代码已经分析过了
    // 1.使用supplier来得到一个对象
    // 2.通过factotryMethod方法实例化一个对象
        
    // 看起来是不是有点熟悉，在使用factotryMethod创建对象时也有差不多这样的一段代码，看起来就是使用缓存好的方法直接创建一个对象
    boolean resolved = false;
    boolean autowireNecessary = false;
    
    // 不对这个参数进行讨论，就认为一直为null
    if (args == null) {
        synchronized (mbd.constructorArgumentLock) {
            // bd中的resolvedConstructorOrFactoryMethod不为空，说明已经解析过构造方法了
            if (mbd.resolvedConstructorOrFactoryMethod != null) {
                // resolved标志是否解析过构造方法
                resolved = true;
                autowireNecessary = mbd.constructorArgumentsResolved;
            }
        }
    }
    if (resolved) {
        // 构造函数已经解析过了，并且这个构造函数在调用时需要自动注入参数
        if (autowireNecessary) {
            // 此时部分解析好的参数已经存在了beanDefinition中，并且构造函数也在bd中
            // 那么在这里只会从缓存中去取构造函数以及参数然后反射调用
            return autowireConstructor(beanName, mbd, null, null);
        }
        else {
            // 这里就是直接反射调用空参构造
            return instantiateBean(beanName, mbd);
        }
    }
        // 推断出能够使用的需要参数的构造函数
    Constructor&amp;lt;?&amp;gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);
    // 在推断出来的构造函数中选取一个合适的方法来进行Bean的实例化
    // ctors不为null：说明存在1个或多个@Autowired标注的方法
    // mbd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR：说明是自动注入
    // mbd.hasConstructorArgumentValues()：配置文件中配置了构造函数要使用的参数
    // !ObjectUtils.isEmpty(args)：外部传入的参数，必定为null,不多考虑
    // 上面的条件只要满足一个就会进入到autowireConstructor方法
    // 第一个条件满足，那么通过autowireConstructor在推断出来的构造函数中再进一步选择一个差异值最小的，参数最长的构造函数
    // 第二个条件满足，说明没有@Autowired标注的方法，但是需要进行自动注入，那么通过autowireConstructor会去遍历类中申明的所有构造函数，并查找一个差异值最小的，参数最长的构造函数
    // 第三个条件满足，说明不是自动注入，那么要通过配置中的参数去类中申明的所有构造函数中匹配
    // 第四个必定为null,不考虑
    if (ctors != null || mbd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR ||
        mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) {
        return autowireConstructor(beanName, mbd, ctors, args);
    }
        
    // 反射调用空参构造
    return instantiateBean(beanName, mbd);
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为&lt;code&gt;autowireConstructor&lt;/code&gt;方法的执行逻辑跟&lt;code&gt;instantiateUsingFactoryMethod&lt;/code&gt;方法的执行逻辑基本一致，只是将&lt;code&gt;Method&lt;/code&gt;对象换成了&lt;code&gt;Constructor&lt;/code&gt;对象，所以对这个方法我不再做详细的分析。&lt;/p&gt;
&lt;p&gt;我们主要就看看&lt;code&gt;determineConstructorsFromBeanPostProcessors&lt;/code&gt;这个方法吧，这个方法的主要目的就是推断出候选的构造方法。&lt;/p&gt;
&lt;h4 id=&quot;determineconstructorsfrombeanpostprocessors方法做了什么？&quot;&gt;determineConstructorsFromBeanPostProcessors方法做了什么？&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 实际调用的就是AutowiredAnnotationBeanPostProcessor中的determineCandidateConstructors方法
// 这个方法看起来很长，但实际确很简单，就是通过@Autowired注解确定哪些构造方法可以作为候选方法，其实在使用factoryMethod来实例化对象的时候也有这种逻辑在其中，后续在总结的时候我们对比一下
public Constructor&amp;lt;?&amp;gt;[] determineCandidateConstructors(Class&amp;lt;?&amp;gt; beanClass, final String beanName)
                        throws BeanCreationException {

                // 这里做的事情很简单，就是将@Lookup注解标注的方法封装成LookupOverride添加到BeanDefinition中的methodOverrides属性中，如果这个属性不为空，在实例化对象的时候不能选用SimpleInstantiationStrateg,而要使用CglibSubclassingInstantiationStrategy，通过cglib代理给方法加一层拦截了逻辑
        // 避免重复检查
                if (!this.lookupMethodsChecked.contains(beanName)) {
                        try {
                                ReflectionUtils.doWithMethods(beanClass, method -&amp;gt; {
                                        Lookup lookup = method.getAnnotation(Lookup.class);
                                        if (lookup != null) {
                                                Assert.state(this.beanFactory != null, &quot;No BeanFactory available&quot;);                           // 将@Lookup注解标注的方法封装成LookupOverride
                                                LookupOverride override = new LookupOverride(method, lookup.value());
                                                try {
                            // 添加到BeanDefinition中的methodOverrides属性中
                                                        RootBeanDefinition mbd = (RootBeanDefinition)
                                                                        this.beanFactory.getMergedBeanDefinition(beanName);
                                                        mbd.getMethodOverrides().addOverride(override);
                                                }
                                                catch (NoSuchBeanDefinitionException ex) {
                                                        throw new BeanCreationException(beanName,
                                                                        &quot;Cannot apply @Lookup to beans without corresponding bean definition&quot;);
                                                }
                                        }
                                });
                        }
                        catch (IllegalStateException ex) {
                                throw new BeanCreationException(beanName, &quot;Lookup method resolution failed&quot;, ex);
                        }
                        this.lookupMethodsChecked.add(beanName);
                }
                
    // 接下来要开始确定到底哪些构造函数能被作为候选者
                
    // 先尝试从缓存中获取
                Constructor&amp;lt;?&amp;gt;[] candidateConstructors = this.candidateConstructorsCache.get(beanClass);
                if (candidateConstructors == null) {
                        // Fully synchronized resolution now...
                        synchronized (this.candidateConstructorsCache) {
                                candidateConstructors = this.candidateConstructorsCache.get(beanClass);、
                    // 缓存中无法获取到，进入正式的推断过程
                                if (candidateConstructors == null) {
                                        Constructor&amp;lt;?&amp;gt;[] rawCandidates;
                                        try {
                        // 第一步：先查询这个类所有的构造函数，包括私有的
                                                rawCandidates = beanClass.getDeclaredConstructors();
                                        }
                                        catch (Throwable ex) {
                                                // 省略异常信息
                                        }
                                        List&amp;lt;Constructor&amp;lt;?&amp;gt;&amp;gt; candidates = new ArrayList&amp;lt;&amp;gt;(rawCandidates.length);
                    // 保存添加了Autowired注解并且required属性为true的构造方法
                                        Constructor&amp;lt;?&amp;gt; requiredConstructor = null;
                    // 空参构造
                                        Constructor&amp;lt;?&amp;gt; defaultConstructor = null;
                    // 看方法注释上说明的，这里除非是kotlin的类，否则必定为null,不做过多考虑，我们就将其当作null
                                        Constructor&amp;lt;?&amp;gt; primaryConstructor = BeanUtils.findPrimaryConstructor(beanClass);
                                        int nonSyntheticConstructors = 0;
                    // 对类中的所有构造方法进行遍历
                                        for (Constructor&amp;lt;?&amp;gt; candidate : rawCandidates) {
                        // 非合成方法
                                                if (!candidate.isSynthetic()) {
                                                        nonSyntheticConstructors++;
                                                }
                                                else if (primaryConstructor != null) {
                                                        continue;
                                                }
                        // 查询方法上是否有Autowired注解
                                                AnnotationAttributes ann = findAutowiredAnnotation(candidate);
                                                if (ann == null) {
                            // userClass != beanClass说明这个类进行了cglib代理
                                                        Class&amp;lt;?&amp;gt; userClass = ClassUtils.getUserClass(beanClass);
                                                        if (userClass != beanClass) {
                                                                try {
                                    // 如果进行了cglib代理，那么在父类上再次查找Autowired注解
                                                                        Constructor&amp;lt;?&amp;gt; superCtor =
                                                                                        userClass.getDeclaredConstructor(candidate.getParameterTypes());
                                                                        ann = findAutowiredAnnotation(superCtor);
                                                                }
                                                                catch (NoSuchMethodException ex) {
                                                                        // Simply proceed, no equivalent superclass constructor found...
                                                                }
                                                        }
                                                }
                        // 说明当前的这个构造函数上有Autowired注解
                                                if (ann != null) {
                                                        if (requiredConstructor != null) {
                                                                // 省略异常抛出
                                                        }
                            // 获取Autowired注解中的required属性
                                                        boolean required = determineRequiredStatus(ann);
                                                        if (required) {
                                // 类中存在多个@Autowired标注的方法，并且某个方法的@Autowired注解上被申明了required属性要为true,那么直接报错
                                                                if (!candidates.isEmpty()) {
                                                                // 省略异常抛出
                                                                }
                                                                requiredConstructor = candidate;
                                                        }
                            // 添加到集合中，这个集合存储的都是被@Autowired注解标注的方法
                                                        candidates.add(candidate);
                                                }
                        // 空参构造函数
                                                else if (candidate.getParameterCount() == 0) {
                                                        defaultConstructor = candidate;
                                                }
                                        }
                                        if (!candidates.isEmpty()) {
                                                // 存在多个被@Autowired标注的方法
                        // 并且所有的required属性被设置成了false (默认为true)
                                                if (requiredConstructor == null) {
                            // 存在空参构造函数，注意，空参构造函数可以不被@Autowired注解标注
                                                        if (defaultConstructor != null) {
                                // 将空参构造函数也加入到候选的方法中去
                                                                candidates.add(defaultConstructor);
                                                        }
                                                        // 省略日志打印
                                                }
                        
                                                candidateConstructors = candidates.toArray(new Constructor&amp;lt;?&amp;gt;[0]);
                                        }
                    // 也就是说，类中只提供了一个构造函数，并且这个构造函数不是空参构造函数
                                        else if (rawCandidates.length == 1 &amp;amp;&amp;amp; rawCandidates[0].getParameterCount() &amp;gt; 0) {
                                                candidateConstructors = new Constructor&amp;lt;?&amp;gt;[] {rawCandidates[0]};
                                        }
                    // 省略中间两个判断，primaryConstructor必定为null，不考虑
                                        // .....
                                        }
                                        else {
                        // 说明无法推断出来
                                                candidateConstructors = new Constructor&amp;lt;?&amp;gt;[0];
                                        }
                                        this.candidateConstructorsCache.put(beanClass, candidateConstructors);
                                }
                        }
                }
                return (candidateConstructors.length &amp;gt; 0 ? candidateConstructors : null);
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;这里我简单总结下这个方法的作用&lt;/p&gt;
&lt;ol readability=&quot;2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;获取到类中的所有构造函数&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;查找到被&lt;code&gt;@Autowired&lt;/code&gt;注解标注的构造函数&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果存在多个被&lt;code&gt;@Autowired&lt;/code&gt;标注的构造函数，并且其required属性没有被设置为true，那么返回这些被标注的函数的集合（空参构造即使没有添加&lt;code&gt;@Autowired&lt;/code&gt;也会被添加到集合中）&lt;/li&gt;
&lt;li&gt;如果存在多个被&lt;code&gt;@Autowired&lt;/code&gt;标注的构造函数，并且其中一个的required属性被设置成了true，那么直接报错&lt;/li&gt;
&lt;li&gt;如果只有一个构造函数被&lt;code&gt;@Autowired&lt;/code&gt;标注，并且其required属性被设置成了true，那么直接返回这个构造函数&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如果没有被&lt;code&gt;@Autowired&lt;/code&gt;标注标注的构造函数，但是类中有且只有一个构造函数，并且这个构造函数不是空参构造函数，那么返回这个构造函数&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;上面的条件都不满足，那么&lt;code&gt;determineCandidateConstructors&lt;/code&gt;这个方法就无法推断出合适的构造函数了&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;可以看到，通过&lt;code&gt;AutowiredAnnotationBeanPostProcessor&lt;/code&gt;的&lt;code&gt;determineCandidateConstructors&lt;/code&gt;方法可以处理构造函数上的&lt;code&gt;@Autowired&lt;/code&gt;注解。&lt;/p&gt;
&lt;p&gt;但是，请注意，这个方法并不能决定到底使用哪个构造函数来创建对象（即使它只推断出来一个，也不一定能够使用），它只是通过&lt;code&gt;@Autowired&lt;/code&gt;注解来确定构造函数的候选者，在构造函数都没有添加&lt;code&gt;@Autowired&lt;/code&gt;注解的情况下，这个方法推断不出来任何方法。真正确定到底使用哪个构造函数是交由&lt;code&gt;autowireConstructor&lt;/code&gt;方法来决定的。前文已经分析过了&lt;code&gt;instantiateUsingFactoryMethod&lt;/code&gt;方法，&lt;code&gt;autowireConstructor&lt;/code&gt;的逻辑基本跟它一致，所以这里不再做详细的分析。&lt;/p&gt;
&lt;h2 id=&quot;factorymethod跟构造函数的比较&quot;&gt;factoryMethod跟构造函数的比较&lt;/h2&gt;
&lt;h3 id=&quot;整体逻辑比较&quot;&gt;整体逻辑比较&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRlZS5jb20vd3hfY2MzNDdiZTY5Ni9ibG9nSW1hZ2UvcmF3L21hc3Rlci9pbWFnZS0yMDIwMDYwMTA3NDgzMjgzNi5wbmc?x-oss-process=image/format,png&quot; alt=&quot;image-20200601074832836&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;从上图中可以看到，整体逻辑上它们并没有什么区别，只是查找的对象从factoryMethod换成了构造函数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;执行细节比较&quot;&gt;执行细节比较&lt;/h3&gt;
&lt;p&gt;细节的差异主要体现在推断方法上&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;推断factoryMethod&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRlZS5jb20vd3hfY2MzNDdiZTY5Ni9ibG9nSW1hZ2UvcmF3L21hc3Rlci9pbWFnZS0yMDIwMDYwMTIyMTQ0OTc4My5wbmc?x-oss-process=image/format,png&quot; alt=&quot;image-20200601221449783&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;推断构造函数&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRlZS5jb20vd3hfY2MzNDdiZTY5Ni9ibG9nSW1hZ2UvcmF3L21hc3Rlci9pbWFnZS0yMDIwMDYwMTIyNTYzMDgxNi5wbmc?x-oss-process=image/format,png&quot; alt=&quot;image-20200601225630816&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;它们之间的差异我已经在图中标识出来了，主要就是两点&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;通过构造函数实例化对象，多了一层处理，就是要处理构造函数上的@Autowired注解以及方法上的@LookUp注解（要决定选取哪一种实例化策略，&lt;code&gt;SimpleInstantiationStrategy&lt;/code&gt;/&lt;code&gt;CglibSubclassingInstantiationStrategy&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;在最终的选取也存在差异，对于facotyMehod而言，在宽松模式下（&lt;code&gt;除ConfigurationClassBeanDefinition&lt;/code&gt;外，也就是扫描@Bean得到的BeanDefinition，都是宽松模式），会选取一个最精准的方法，在严格模式下，会选取一个参数最长的方法&lt;/li&gt;
&lt;li&gt;对于构造函数而言，会必定会选取一个参数最长的方法&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;h2 id=&quot;关于计算类型差异的补充内容&quot;&gt;关于计算类型差异的补充内容&lt;/h2&gt;
&lt;p&gt;思考了很久，我还是决定再补充一些内容，就是关于上面两幅图的最后一步，对应的核心代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;int typeDiffWeight = (mbd.isLenientConstructorResolution() ?
                      argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));

if (typeDiffWeight &amp;lt; minTypeDiffWeight) {
    factoryMethodToUse = candidate;
    argsHolderToUse = argsHolder;
    argsToUse = argsHolder.arguments;
    minTypeDiffWeight = typeDiffWeight;
    ambiguousFactoryMethods = null;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol readability=&quot;42&quot;&gt;&lt;li readability=&quot;90&quot;&gt;
&lt;p&gt;判断bd是严格模式还是宽松模式，上面说过很多次了，bd默认就是宽松模式，只要在&lt;code&gt;ConfigurationClassBeanDefinition&lt;/code&gt;中使用严格模式，也就是扫描@Bean标注的方法注册的bd（对应的代码可以参考：&lt;code&gt;org.springframework.context.annotation.ConfigurationClassBeanDefinitionReader#loadBeanDefinitionsForBeanMethod&lt;/code&gt;方法）&lt;/p&gt;
&lt;p&gt;我们再看看严格模式跟宽松模式在计算差异值时的区别&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;宽松模式&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public int getTypeDifferenceWeight(Class&amp;lt;?&amp;gt;[] paramTypes) {
    // 计算实际使用的参数跟方法申明的参数的差异值
                        int typeDiffWeight = MethodInvoker.getTypeDifferenceWeight(paramTypes, this.arguments);
    // 计算没有经过类型转换的参数跟方法申明的参数的差异值
                        int rawTypeDiffWeight = MethodInvoker.getTypeDifferenceWeight(paramTypes, this.rawArguments) - 1024;
                        return (rawTypeDiffWeight &amp;lt; typeDiffWeight ? rawTypeDiffWeight : typeDiffWeight);
                }

public static int getTypeDifferenceWeight(Class&amp;lt;?&amp;gt;[] paramTypes, Object[] args) {
    int result = 0;
    for (int i = 0; i &amp;lt; paramTypes.length; i++) {
        // 在出现类型转换时，下面这个判断才会成立，也就是在比较rawArguments跟paramTypes的差异时才可能满足这个条件
        if (!ClassUtils.isAssignableValue(paramTypes[i], args[i])) {
            return Integer.MAX_VALUE;
        }
        if (args[i] != null) {
            Class&amp;lt;?&amp;gt; paramType = paramTypes[i];
            Class&amp;lt;?&amp;gt; superClass = args[i].getClass().getSuperclass();
            while (superClass != null) {
                // 如果我们传入的值是方法上申明的参数的子类，那么每多一层继承关系，差异值加2
                if (paramType.equals(superClass)) {
                    result = result + 2;
                    superClass = null;
                }
                else if (ClassUtils.isAssignable(paramType, superClass)) {
                    result = result + 2;
                    superClass = superClass.getSuperclass();
                }
                else {
                    superClass = null;
                }
            }
            // 判断方法的参数是不是一个接口，如果是，那么差异值加1
            if (paramType.isInterface()) {
                result = result + 1;
            }
        }
    }
    return result;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;严格模式（主要应用于@Bean标注的方法对应的BeanDefinition）&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public int getAssignabilityWeight(Class&amp;lt;?&amp;gt;[] paramTypes) {
    // 严格模式下，只有三种返回值
    // 1.Integer.MAX_VALUE，经过类型转换后还是不符合要求，返回最大的类型差异
    // 因为解析后的参数可能返回一个NullBean（创建对象的方法返回了null,Spring会将其包装成一个NullBean）,不过一般不会出现这种情况，所以我们可以当这种情况不存在
                        for (int i = 0; i &amp;lt; paramTypes.length; i++) {
                                if (!ClassUtils.isAssignableValue(paramTypes[i], this.arguments[i])) {
                                        return Integer.MAX_VALUE;
                                }
                        }
    // 2.Integer.MAX_VALUE - 512，进行过了类型转换才符合要求
                        for (int i = 0; i &amp;lt; paramTypes.length; i++) {
                                if (!ClassUtils.isAssignableValue(paramTypes[i], this.rawArguments[i])) {
                                        return Integer.MAX_VALUE - 512;
                                }
                        }
    // 3.Integer.MAX_VALUE - 1024，没有经过类型转换就已经符合要求了，返回最小的类型差异
                        return Integer.MAX_VALUE - 1024;
                }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先，不管是factoryMethod还是constructor，都是采用上面的两个方法来计算类型差异，但是正常来说，只有factoryMethod会采用到严格模式（除非程序员手动干预，比如通过Bean工厂后置处理器修改了bd中的属性，这样通常来说没有很大意义）&lt;/p&gt;
&lt;p&gt;所以我们分为三种情况讨论&lt;/p&gt;
&lt;h3 id=&quot;1、factorymethod宽松模式&quot;&gt;1、factoryMethod+宽松模式&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;这种情况下，会选取一个最精确的方法，同时方法的参数要尽量长&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;测试代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class FactoryObject {

        public DmzService getDmz() {
                System.out.println(0);
                return new DmzService();
        }

        public DmzService getDmz(OrderService indexService) {
                System.out.println(1);
                return new DmzService();
        }

        public DmzService getDmz(OrderService orderService, IndexService indexService) {
                System.out.println(2);
                return new DmzService();
        }

    public DmzService getDmz(OrderService orderService, IndexService indexService,IA ia) {
        System.out.println(3);
        return new DmzService();
    }
}

public class ServiceImpl implements IService {
}

public class IAImpl implements IA {
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-XML&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
           xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
           xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;
default-autowire=&quot;constructor&quot;&amp;gt;&amp;lt;!--必须要开启自动注入，并且是通过构造函数进行自动注入，否则选用无参构造--&amp;gt;

        &amp;lt;!--factoryObject 提供了创建对象的方法--&amp;gt;
        &amp;lt;bean id=&quot;factoryObject&quot; class=&quot;com.dmz.spring.instantiation.service.FactoryObject&quot;/&amp;gt;

        &amp;lt;bean class=&quot;com.dmz.spring.instantiation.service.OrderService&quot; id=&quot;orderService&quot;/&amp;gt;

        &amp;lt;bean id=&quot;dmzService&quot; factory-bean=&quot;factoryObject&quot; factory-method=&quot;getDmz&quot; /&amp;gt;

        &amp;lt;bean class=&quot;com.dmz.spring.instantiation.service.ServiceImpl&quot; id=&quot;iService&quot;/&amp;gt;

        &amp;lt;bean class=&quot;com.dmz.spring.instantiation.service.IndexService&quot; id=&quot;indexService&quot;/&amp;gt;

&amp;lt;/beans&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * @author 程序员DMZ
 * @Date Create in 23:59 2020/6/1
 * @Blog https://daimingzhi.blog.csdn.net/
 */
public class XMLMain {
        public static void main(String[] args) {
                ClassPathXmlApplicationContext cc =
                                new ClassPathXmlApplicationContext(&quot;application.xml&quot;);
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行程序发现，选用了第三个（&lt;code&gt;getDmz(OrderService orderService, IndexService indexService)&lt;/code&gt;）构造方法。虽然最后一个方法的参数更长，但是因为其方法申明的参数上存在接口，所以它的差异值会大于第三个方法，因为不会被选用&lt;/p&gt;
&lt;h3 id=&quot;2、factorymethod严格模式&quot;&gt;2、factoryMethod+严格模式&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;这种情况下，会选取一个参数尽量长的方法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;测试代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * @author 程序员DMZ
 * @Date Create in 6:28 2020/6/1
 * @Blog https://daimingzhi.blog.csdn.net/
 */
@ComponentScan(&quot;com.dmz.spring.instantiation&quot;)
@Configuration
public class Config {

        @Bean
        public DmzService dmzService() {
                System.out.println(0);
                return new DmzService();
        }
        @Bean
        public DmzService dmzService(OrderService indexService) {
                System.out.println(1);
                return new DmzService();
        }
        @Bean
        public DmzService dmzService(OrderService orderService, IndexService indexService) {
                System.out.println(2);
                return new DmzService();
        }
        @Bean
        public DmzService dmzService(OrderService orderService, IndexService indexService, IA ia) {
                System.out.println(&quot;config &quot; +3);
                return new DmzService();
        }

        @Bean
        public DmzService dmzService(OrderService orderService, IndexService indexService, IA ia, IService iService) {
                System.out.println(&quot;config &quot; +4);
                return new DmzService();
        }
}

/**
 * @author 程序员DMZ
 * @Date Create in 6:29 2020/6/1
 * @Blog https://daimingzhi.blog.csdn.net/
 */
public class Main {
        public static void main(String[] args) {
                AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext();
                ac.register(Config.class);
                ac.refresh();
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行程序，发现选用了最后一个构造函数，这是因为在遍历候选方法时，会先遍历参数最长的，而在计算类型差异时，因为严格模式下，上面所有方法的差异值都是一样的，都会返回&lt;code&gt;Integer.MAX_VALUE - 1024&lt;/code&gt;。实际上，在不进行手动干预的情况下，都会返沪这个值。&lt;/p&gt;
&lt;h3 id=&quot;3、构造函数宽松模式&quot;&gt;3、构造函数+宽松模式&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;这种情况下，也会选取一个参数尽量长的方法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;之所以会这样，主要是因为在&lt;code&gt;autowireConstructor&lt;/code&gt;方法中进行了一次短路判断，如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRlZS5jb20vd3hfY2MzNDdiZTY5Ni9ibG9nSW1hZ2UvcmF3L21hc3Rlci9pbWFnZS0yMDIwMDYwMjAwMjI1OTA5OS5wbmc?x-oss-process=image/format,png&quot; alt=&quot;image-20200602002259099&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在上图中，如果已经找到了合适的方法，那么直接就不会再找了，而在遍历的时候是从参数最长的方法开始遍历的，测试代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Component
public class DmzService {
        
    // 没有添加@Autowired注解，也会被当作候选方法
        public DmzService(){
                System.out.println(0);
        }

        @Autowired(required = false)
        public DmzService(OrderService orderService) {
                System.out.println(1);
        }

        @Autowired(required = false)
        public DmzService(OrderService orderService, IService iService) {
                System.out.println(2);
        }

        @Autowired(required = false)
        public DmzService(OrderService orderService, IndexService indexService, IService iService,IA ia) {
                System.out.println(&quot;DmzService &quot;+3);
        }
}

/**
 * @author 程序员DMZ
 * @Date Create in 6:29 2020/6/1
 * @Blog https://daimingzhi.blog.csdn.net/
 */
public class Main {
        public static void main(String[] args) {
                AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext();
                ac.register(Config.class);
                ac.refresh();
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这篇文章就到这里啦~~！&lt;/p&gt;
&lt;p&gt;文章很长，希望你耐心看完，码字不易，如果有帮助到你的话点个赞吧~！&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;扫描下方二维码，关注我的公众号，更多精彩文章在等您！~~&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRlZS5jb20vd3hfY2MzNDdiZTY5Ni9ibG9nSW1hZ2UvcmF3L21hc3Rlci8lRTUlODUlQUMlRTQlQkMlOTclRTUlOEYlQjcuanBn?x-oss-process=image/format,png&quot; alt=&quot;公众号&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 10 Jun 2020 23:04:00 +0000</pubDate>
<dc:creator>程序员DMZ</dc:creator>
<og:description>本系列文章： 读源码，我们可以从第一行读起 你知道Spring是怎么解析配置类的吗？ 配置类为什么要添加@Configuration注解？ 推荐阅读： Spring官网阅读 | 总结篇 Spring杂</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/daimzh/p/13090856.html</dc:identifier>
</item>
<item>
<title>小师妹学JavaIO之:NIO中Channel的妙用 - flydean</title>
<link>http://www.cnblogs.com/flydean/p/java-io-nio-channel.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/flydean/p/java-io-nio-channel.html</guid>
<description>&lt;p&gt;小师妹，你还记得我们使用IO和NIO的初心吗？&lt;/p&gt;
&lt;p&gt;小师妹：F师兄，使用IO和NIO不就是为了让生活更美好，世界充满爱吗？让我等程序员可以优雅的将数据从一个地方搬运到另外一个地方。利其器，善其事，才有更多的时间去享受生活呀。&lt;/p&gt;
&lt;p&gt;善，如果将数据比做人，IO，NIO的目的就是把人运到美国。&lt;/p&gt;
&lt;p&gt;小师妹：F师兄，为什么要运到美国呀，美国现在新冠太严重了，还是待在中国吧。中国是世界上最安全的国家！&lt;/p&gt;
&lt;p&gt;好吧，为了保险起见，我们要把人运到上海。人就是数据，怎么运过去呢？可以坐飞机，坐汽车，坐火车，这些什么飞机，汽车，火车就可以看做是一个一个的Buffer。&lt;/p&gt;
&lt;p&gt;最后飞机的航线，汽车的公路和火车的轨道就可以看做是一个个的channel。&lt;/p&gt;
&lt;p&gt;更多精彩内容且看：&lt;/p&gt;
&lt;p&gt;简单点讲，channel就是负责运送Buffer的通道。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200520145243522.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_0,text_aHR0cDovL3d3dy5mbHlkZWFuLmNvbQ==,size_35,color_8F8F8F,t_70&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;IO按源头来分，可以分为两种，从文件来的File IO，从Stream来的Stream IO。不管哪种IO，都可以通过channel来运送数据。&lt;/p&gt;

&lt;p&gt;虽然数据的来源只有两种，但是JDK中Channel的分类可不少，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200514143225602.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_0,text_aHR0cDovL3d3dy5mbHlkZWFuLmNvbQ==,size_35,color_8F8F8F,t_70&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;先来看看最基本的，也是最顶层的接口Channel：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public interface Channel extends Closeable {
    public boolean isOpen();
    public void close() throws IOException;

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最顶层的Channel很简单，继承了Closeable接口，需要实现两个方法isOpen和close。&lt;/p&gt;
&lt;p&gt;一个用来判断channel是否打开，一个用来关闭channel。&lt;/p&gt;
&lt;p&gt;小师妹：F师兄，顶层的Channel怎么这么简单，完全不符合Channel很复杂的人设啊。&lt;/p&gt;
&lt;p&gt;别急，JDK这么做其实也是有道理的，因为是顶层的接口，必须要更加抽象更加通用，结果，一通用就发现还真的就只有这么两个方法是通用的。&lt;/p&gt;
&lt;p&gt;所以为了应对这个问题，Channel中定义了很多种不同的类型。&lt;/p&gt;
&lt;p&gt;最最底层的Channel有5大类型，分别是：&lt;/p&gt;
&lt;h2 id=&quot;filechannel&quot;&gt;FileChannel&lt;/h2&gt;
&lt;p&gt;这5大channel中，和文件File有关的就是这个FileChannel了。&lt;/p&gt;
&lt;p&gt;FileChannel可以从RandomAccessFile, FileInputStream或者FileOutputStream中通过调用getChannel()来得到。&lt;/p&gt;
&lt;p&gt;也可以直接调用FileChannel中的open方法传入Path创建。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public abstract class FileChannel
    extends AbstractInterruptibleChannel
    implements SeekableByteChannel, GatheringByteChannel, ScatteringByteChannel
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们看下FileChannel继承或者实现的接口和类。&lt;/p&gt;
&lt;p&gt;AbstractInterruptibleChannel实现了InterruptibleChannel接口，interrupt大家都知道吧，用来中断线程执行的利器。来看一下下面一段非常玄妙的代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;protected final void begin() {
        if (interruptor == null) {
            interruptor = new Interruptible() {
                    public void interrupt(Thread target) {
                        synchronized (closeLock) {
                            if (closed)
                                return;
                            closed = true;
                            interrupted = target;
                            try {
                                AbstractInterruptibleChannel.this.implCloseChannel();
                            } catch (IOException x) { }
                        }
                    }};
        }
        blockedOn(interruptor);
        Thread me = Thread.currentThread();
        if (me.isInterrupted())
            interruptor.interrupt(me);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面这段代码就是AbstractInterruptibleChannel的核心所在。&lt;/p&gt;
&lt;p&gt;首先定义了一个Interruptible的实例，这个实例中有一个interrupt方法，用来关闭Channel。&lt;/p&gt;
&lt;p&gt;然后获得当前线程的实例，判断当前线程是否Interrupted，如果是的话，就调用Interruptible的interrupt方法将当前channel关闭。&lt;/p&gt;
&lt;p&gt;SeekableByteChannel用来连接Entry或者File。它有一个独特的属性叫做position，表示当前读取的位置。可以被修改。&lt;/p&gt;
&lt;p&gt;GatheringByteChannel和ScatteringByteChannel表示可以一次读写一个Buffer序列结合（Buffer Array）：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public long write(ByteBuffer[] srcs, int offset, int length)
        throws IOException;
public long read(ByteBuffer[] dsts, int offset, int length)
        throws IOException;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;selector和channel&quot;&gt;Selector和Channel&lt;/h2&gt;
&lt;p&gt;在讲其他几个Channel之前，我们看一个和下面几个channel相关的Selector：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200520142919874.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_0,text_aHR0cDovL3d3dy5mbHlkZWFuLmNvbQ==,size_35,color_8F8F8F,t_70&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里要介绍一个新的Channel类型叫做SelectableChannel，之前的FileChannel的连接是一对一的，也就是说一个channel要对应一个处理的线程。而SelectableChannel则是一对多的，也就是说一个处理线程可以通过Selector来对应处理多个channel。&lt;/p&gt;
&lt;p&gt;SelectableChannel通过注册不同的SelectionKey，实现对多个Channel的监听。后面我们会具体的讲解Selector的使用，敬请期待。&lt;/p&gt;
&lt;h2 id=&quot;datagramchannel&quot;&gt;DatagramChannel&lt;/h2&gt;
&lt;p&gt;DatagramChannel是用来处理UDP的Channel。它自带了Open方法来创建实例。&lt;/p&gt;
&lt;p&gt;来看看DatagramChannel的定义：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public abstract class DatagramChannel
    extends AbstractSelectableChannel
    implements ByteChannel, ScatteringByteChannel, GatheringByteChannel, MulticastChannel
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ByteChannel表示它同时是ReadableByteChannel也是WritableByteChannel，可以同时写入和读取。&lt;/p&gt;
&lt;p&gt;MulticastChannel代表的是一种多播协议。正好和UDP对应。&lt;/p&gt;
&lt;h2 id=&quot;socketchannel&quot;&gt;SocketChannel&lt;/h2&gt;
&lt;p&gt;SocketChannel是用来处理TCP的channel。它也是通过Open方法来创建的。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public abstract class SocketChannel
    extends AbstractSelectableChannel
    implements ByteChannel, ScatteringByteChannel, GatheringByteChannel, NetworkChannel
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;SocketChannel跟DatagramChannel的唯一不同之处就是实现的是NetworkChannel借口。&lt;/p&gt;
&lt;p&gt;NetworkChannel提供了一些network socket的操作，比如绑定地址等。&lt;/p&gt;
&lt;h2 id=&quot;serversocketchannel&quot;&gt;ServerSocketChannel&lt;/h2&gt;
&lt;p&gt;ServerSocketChannel也是一个NetworkChannel，它主要用在服务器端的监听。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public abstract class ServerSocketChannel
    extends AbstractSelectableChannel
    implements NetworkChannel
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;asynchronoussocketchannel&quot;&gt;AsynchronousSocketChannel&lt;/h2&gt;
&lt;p&gt;最后AsynchronousSocketChannel是一种异步的Channel：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public abstract class AsynchronousSocketChannel
    implements AsynchronousByteChannel, NetworkChannel
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为什么是异步呢？我们看一个方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public abstract Future&amp;lt;Integer&amp;gt; read(ByteBuffer dst);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到返回值是一个Future，所以read方法可以立刻返回，只在我们需要的时候从Future中取值即可。&lt;/p&gt;

&lt;p&gt;小师妹：F师兄，讲了这么多种类的Channel，看得我眼花缭乱，能不能讲一个Channel的具体例子呢？&lt;/p&gt;
&lt;p&gt;好的小师妹，我们现在讲一个使用Channel进行文件拷贝的例子，虽然Channel提供了transferTo的方法可以非常简单的进行拷贝，但是为了能够看清楚Channel的通用使用，我们选择一个更加常规的例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public void useChannelCopy() throws IOException {
        FileInputStream input = new FileInputStream (&quot;src/main/resources/www.flydean.com&quot;);
        FileOutputStream output = new FileOutputStream (&quot;src/main/resources/www.flydean.com.txt&quot;);
        try(ReadableByteChannel source = input.getChannel(); WritableByteChannel dest = output.getChannel()){
            ByteBuffer buffer = ByteBuffer.allocateDirect(1024);
            while (source.read(buffer) != -1)
            {
                // flip buffer,准备写入
                buffer.flip();
                // 查看是否有更多的内容
                while (buffer.hasRemaining())
                {
                    dest.write(buffer);
                }
                // clear buffer，供下一次使用
                buffer.clear();
            }
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的例子中我们从InputStream中读取Buffer，然后写入到FileOutputStream。&lt;/p&gt;

&lt;p&gt;今天讲解了Channel的具体分类，和一个简单的例子，后面我们会再体验一下Channel的其他例子，敬请期待。&lt;/p&gt;
&lt;p&gt;本文的例子&lt;a href=&quot;https://github.com/ddean2009/learn-java-io-nio&quot;&gt;https://github.com/ddean2009/learn-java-io-nio&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8.6231155778894&quot;&gt;
&lt;p&gt;本文作者：flydean程序那些事&lt;/p&gt;
&lt;p&gt;本文链接：&lt;a href=&quot;http://www.flydean.com/java-io-nio-channel/&quot;&gt;http://www.flydean.com/java-io-nio-channel/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文来源：flydean的博客&lt;/p&gt;
&lt;p&gt;欢迎关注我的公众号:程序那些事，更多精彩等着您！&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Wed, 10 Jun 2020 22:36:00 +0000</pubDate>
<dc:creator>flydean</dc:creator>
<og:description>简介 小师妹，你还记得我们使用IO和NIO的初心吗？ 小师妹：F师兄，使用IO和NIO不就是为了让生活更美好，世界充满爱吗？让我等程序员可以优雅的将数据从一个地方搬运到另外一个地方。利其器，善其事，才</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/flydean/p/java-io-nio-channel.html</dc:identifier>
</item>
<item>
<title>掌握SpringBoot-2.3的容器探针：实战篇 - zq2599</title>
<link>http://www.cnblogs.com/bolingcavalry/p/13090502.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bolingcavalry/p/13090502.html</guid>
<description>&lt;h3 id=&quot;欢迎访问我的github&quot;&gt;欢迎访问我的GitHub&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;内容：原创文章分类汇总，及配套源码，涉及Java、Docker、K8S、DevOPS等&lt;br/&gt;经过多篇知识积累终于来到实战章节，亲爱的读者们，请将装备就位，一起动手体验SpringBoot官方带给我们的最新技术；&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;关于《springboot-23容器化技术》系列&quot;&gt;关于《SpringBoot-2.3容器化技术》系列&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;《SpringBoot-2.3容器化技术》系列，旨在和大家一起学习实践2.3版本带来的最新容器化技术，让咱们的Java应用更加适应容器化环境，在云计算时代依旧紧跟主流，保持竞争力；&lt;/li&gt;
&lt;li&gt;全系列文章分为主题和辅助两部分，主题部分如下：&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/boling_cavalry/article/details/106597358&quot;&gt;《体验SpringBoot(2.3)应用制作Docker镜像(官方方案)》&lt;/a&gt;；&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/boling_cavalry/article/details/106598189&quot;&gt;《详解SpringBoot(2.3)应用制作Docker镜像(官方方案)》&lt;/a&gt;；&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/boling_cavalry/article/details/106605264&quot;&gt;《掌握SpringBoot-2.3的容器探针：基础篇》&lt;/a&gt;；&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/boling_cavalry/article/details/106606442&quot;&gt;《掌握SpringBoot-2.3的容器探针：深入篇》&lt;/a&gt;；&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/boling_cavalry/article/details/106607225&quot;&gt;《掌握SpringBoot-2.3的容器探针：实战篇》&lt;/a&gt;；&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;辅助部分是一些参考资料和备忘总结，如下：&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/boling_cavalry/article/details/106600620&quot;&gt;《SpringBoot-2.3镜像方案为什么要做多个layer》&lt;/a&gt;；&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/boling_cavalry/article/details/106590784&quot;&gt;《设置非root账号不用sudo直接执行docker命令》&lt;/a&gt;；&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/boling_cavalry/article/details/106594392&quot;&gt;《开发阶段，将SpringBoot应用快速部署到K8S》&lt;/a&gt;；&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;springboot-23容器探针知识点小结&quot;&gt;SpringBoot-2.3容器探针知识点小结&lt;/h3&gt;
&lt;p&gt;经过前面的知识积累，我们知道了SpringBoot-2.3新增的探针规范以及适用场景，这里做个简短的回顾：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;kubernetes要求业务容器提供一个名为&lt;span&gt;livenessProbe&lt;/span&gt;的地址，kubernetes会定时访问该地址，如果该地址的返回码不在200到400之间，kubernetes认为该容器不健康，&lt;span&gt;会杀死该容器重建新的容器&lt;/span&gt;，这个地址就是&lt;span&gt;存活探针&lt;/span&gt;；&lt;/li&gt;
&lt;li&gt;kubernetes要求业务容器提供一个名为&lt;span&gt;readinessProbe&lt;/span&gt;的地址，kubernetes会定时访问该地址，如果该地址的返回码不在200到400之间，kubernetes认为该容器无法对外提供服务，&lt;span&gt;不会把请求调度到该容器&lt;/span&gt;，这个地址就是&lt;span&gt;就绪探针&lt;/span&gt;；&lt;/li&gt;
&lt;li&gt;SpringBoot的2.3.0.RELEASE发布了两个新的actuator地址，&lt;span&gt;/actuator/health/liveness&lt;/span&gt;和&lt;span&gt;/actuator/health/readiness&lt;/span&gt;，前者用作存活探针，后者用作就绪探针，这两个地址的返回值来自两个新增的actuator：&lt;span&gt;Liveness State&lt;/span&gt;和&lt;span&gt;Readiness State&lt;/span&gt;；&lt;/li&gt;
&lt;li&gt;SpringBoot应用根据特殊环境变量是否存在来判定自己是否运行在容器环境，如果是，&lt;span&gt;/actuator/health/liveness&lt;/span&gt;和&lt;span&gt;/actuator/health/readiness&lt;/span&gt;这两个地址就有返回码，具体的值是和应用的状态有对应关系的，例如应用启动过程中，/actuator/health/readiness返回&lt;span&gt;503&lt;/span&gt;，启动成功后返回&lt;span&gt;200&lt;/span&gt;；&lt;/li&gt;
&lt;li&gt;业务应用可以通过Spring系统事件机制来读取&lt;span&gt;Liveness State&lt;/span&gt;和&lt;span&gt;Readiness State&lt;/span&gt;，也可以订阅这两个actuator的变更事件；&lt;/li&gt;
&lt;li&gt;业务应用可以通过Spring系统事件机制来修改&lt;span&gt;Liveness State&lt;/span&gt;和&lt;span&gt;Readiness State&lt;/span&gt;，此时/actuator/health/liveness和/actuator/health/readiness的返回值都会发生变更，从而影响kubernetes对此容器的行为（参照第一点和第二点），例如livenessProbe返回码变成503，导致kubernetes认为容器不健康，从而杀死容器；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;小结完毕，接下来开始实打实的编码和操作实战，验证上述理论；&lt;/p&gt;
&lt;h3 id=&quot;实战环境信息&quot;&gt;实战环境信息&lt;/h3&gt;
&lt;p&gt;本次实战有两个环境：开发和运行环境，其中开发环境信息如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;操作系统：Ubuntu 20.04 LTS 桌面版&lt;/li&gt;
&lt;li&gt;CPU ：2.30GHz × 4，内存：32G，硬盘：1T NVMe&lt;/li&gt;
&lt;li&gt;JDK：1.8.0_231&lt;/li&gt;
&lt;li&gt;MAVEN：3.6.3&lt;/li&gt;
&lt;li&gt;SpringBoot：2.3.0.RELEASE&lt;/li&gt;
&lt;li&gt;Docker：19.03.10&lt;/li&gt;
&lt;li&gt;开发工具：IDEA 2020.1.1 (Ultimate Edition)&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;运行环境信息如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;操作系统：CentOS Linux release 7.8.2003&lt;/li&gt;
&lt;li&gt;Kubernetes：1.15&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;事实证明，用Ubuntu桌面版作为开发环境是可行的，体验十分顺畅，IDEA、SubLime、SSH、Chrome、微信都能正常使用，下图是我的Ubuntu开发环境：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202006/485422-20200611000938666-900287336.jpg&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;实战内容简介&quot;&gt;实战内容简介&lt;/h3&gt;
&lt;p&gt;本次实战包括以下内容：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;开发SpringBoot应用，部署在kubernetes；&lt;/li&gt;
&lt;li&gt;检查应用状态和kubernetes的pod状态的关联变化；&lt;/li&gt;
&lt;li&gt;修改Readiness State，看kubernetes是否还会把请求调度到pod；&lt;/li&gt;
&lt;li&gt;修改Liveness State，看kubernetes会不是杀死pod；&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;源码下载&quot;&gt;源码下载&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;本次实战用到了一个普通的SpringBoot工程，源码可在GitHub下载到，地址和链接信息如下表所示(&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;)：&lt;/li&gt;
&lt;/ol&gt;&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;这个git项目中有多个文件夹，本章的应用在&lt;span&gt;probedemo&lt;/span&gt;文件夹下，如下图红框所示：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202006/485422-20200611000939032-1029123327.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;开发springboot应用&quot;&gt;开发SpringBoot应用&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;请在IDEA上安装lombok插件：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202006/485422-20200611000939444-1209966195.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;在IDEA上新建名为&lt;span&gt;probedemo&lt;/span&gt;的SpringBoot工程，版本选择&lt;span&gt;2.3.0&lt;/span&gt;：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202006/485422-20200611000939722-388229714.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;该工程的pom.xml内容如下，注意要有&lt;span&gt;spring-boot-starter-actuator&lt;/span&gt;和&lt;span&gt;lombok&lt;/span&gt;依赖，另外插件&lt;span&gt;spring-boot-maven-plugin&lt;/span&gt;也要增加&lt;span&gt;layers&lt;/span&gt;节点：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;
    &amp;lt;parent&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;2.3.0.RELEASE&amp;lt;/version&amp;gt;
        &amp;lt;relativePath/&amp;gt; &amp;lt;!-- lookup parent from repository --&amp;gt;
    &amp;lt;/parent&amp;gt;
    &amp;lt;groupId&amp;gt;com.bolingcavalry&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;probedemo&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt;
    &amp;lt;name&amp;gt;probedemo&amp;lt;/name&amp;gt;
    &amp;lt;description&amp;gt;Demo project for Spring Boot&amp;lt;/description&amp;gt;

    &amp;lt;properties&amp;gt;
        &amp;lt;java.version&amp;gt;1.8&amp;lt;/java.version&amp;gt;
    &amp;lt;/properties&amp;gt;

    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
            &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
            &amp;lt;exclusions&amp;gt;
                &amp;lt;exclusion&amp;gt;
                    &amp;lt;groupId&amp;gt;org.junit.vintage&amp;lt;/groupId&amp;gt;
                    &amp;lt;artifactId&amp;gt;junit-vintage-engine&amp;lt;/artifactId&amp;gt;
                &amp;lt;/exclusion&amp;gt;
            &amp;lt;/exclusions&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-actuator&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.projectlombok&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;lombok&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;

    &amp;lt;build&amp;gt;
        &amp;lt;plugins&amp;gt;
            &amp;lt;plugin&amp;gt;
                &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;2.3.0.RELEASE&amp;lt;/version&amp;gt;
                &amp;lt;!--该配置会在jar中增加layer描述文件，以及提取layer的工具--&amp;gt;
                &amp;lt;configuration&amp;gt;
                    &amp;lt;layers&amp;gt;
                        &amp;lt;enabled&amp;gt;true&amp;lt;/enabled&amp;gt;
                    &amp;lt;/layers&amp;gt;
                &amp;lt;/configuration&amp;gt;
            &amp;lt;/plugin&amp;gt;
        &amp;lt;/plugins&amp;gt;
    &amp;lt;/build&amp;gt;
&amp;lt;/project&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;应用启动类&lt;span&gt;ProbedemoApplication&lt;/span&gt;是个最普通的启动类：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.bolingcavalry.probedemo;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class ProbedemoApplication {
    public static void main(String[] args) {
        SpringApplication.run(ProbedemoApplication.class, args);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;5&quot;&gt;&lt;li&gt;增加一个监听类，可以监听存活和就绪状态的变化：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.bolingcavalry.probedemo.listener;

import lombok.extern.slf4j.Slf4j;
import org.springframework.boot.availability.AvailabilityChangeEvent;
import org.springframework.boot.availability.AvailabilityState;
import org.springframework.context.event.EventListener;
import org.springframework.stereotype.Component;

/**
 * description: 监听系统事件的类 &amp;lt;br&amp;gt;
 * date: 2020/6/4 下午12:57 &amp;lt;br&amp;gt;
 * author: willzhao &amp;lt;br&amp;gt;
 * email: zq2599@gmail.com &amp;lt;br&amp;gt;
 * version: 1.0 &amp;lt;br&amp;gt;
 */
@Component
@Slf4j
public class AvailabilityListener {

    /**
     * 监听系统消息，
     * AvailabilityChangeEvent类型的消息都从会触发此方法被回调
     * @param event
     */
    @EventListener
    public void onStateChange(AvailabilityChangeEvent&amp;lt;? extends AvailabilityState&amp;gt; event) {
        log.info(event.getState().getClass().getSimpleName() + &quot; : &quot; + event.getState());
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;6&quot;&gt;&lt;li&gt;增加名为&lt;span&gt;StateReader的Controller&lt;/span&gt;的Controller，用于获取存活和就绪状态：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.bolingcavalry.probedemo.controller;

import org.springframework.boot.availability.ApplicationAvailability;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import javax.annotation.Resource;
import java.util.Date;

@RestController
@RequestMapping(&quot;/statereader&quot;)
public class StateReader {

    @Resource
    ApplicationAvailability applicationAvailability;

    @RequestMapping(value=&quot;/get&quot;)
    public String state() {
        return &quot;livenessState : &quot; + applicationAvailability.getLivenessState()
               + &quot;&amp;lt;br&amp;gt;readinessState : &quot; + applicationAvailability.getReadinessState()
               + &quot;&amp;lt;br&amp;gt;&quot; + new Date();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;7&quot;&gt;&lt;li&gt;增加名为&lt;span&gt;StateWritter&lt;/span&gt;的Controller，用于设置存活和就绪状态：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.bolingcavalry.probedemo.controller;

import org.springframework.boot.availability.AvailabilityChangeEvent;
import org.springframework.boot.availability.LivenessState;
import org.springframework.boot.availability.ReadinessState;
import org.springframework.context.ApplicationEventPublisher;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import javax.annotation.Resource;
import java.util.Date;

/**
 * description: 修改状态的controller &amp;lt;br&amp;gt;
 * date: 2020/6/4 下午1:21 &amp;lt;br&amp;gt;
 * author: willzhao &amp;lt;br&amp;gt;
 * email: zq2599@gmail.com &amp;lt;br&amp;gt;
 * version: 1.0 &amp;lt;br&amp;gt;
 */
@RestController
@RequestMapping(&quot;/staterwriter&quot;)
public class StateWritter {

    @Resource
    ApplicationEventPublisher applicationEventPublisher;

    /**
     * 将存活状态改为BROKEN（会导致kubernetes杀死pod）
     * @return
     */
    @RequestMapping(value=&quot;/broken&quot;)
    public String broken(){
        AvailabilityChangeEvent.publish(applicationEventPublisher, StateWritter.this, LivenessState.BROKEN);
        return &quot;success broken, &quot; + new Date();
    }

    /**
     * 将存活状态改为CORRECT
     * @return
     */
    @RequestMapping(value=&quot;/correct&quot;)
    public String correct(){
        AvailabilityChangeEvent.publish(applicationEventPublisher, StateWritter.this, LivenessState.CORRECT);
        return &quot;success correct, &quot; + new Date();
    }

    /**
     * 将就绪状态改为REFUSING_TRAFFIC（导致kubernetes不再把外部请求转发到此pod）
     * @return
     */
    @RequestMapping(value=&quot;/refuse&quot;)
    public String refuse(){
        AvailabilityChangeEvent.publish(applicationEventPublisher, StateWritter.this, ReadinessState.REFUSING_TRAFFIC);
        return &quot;success refuse, &quot; + new Date();
    }

    /**
     * 将就绪状态改为ACCEPTING_TRAFFIC（导致kubernetes会把外部请求转发到此pod）
     * @return
     */
    @RequestMapping(value=&quot;/accept&quot;)
    public String accept(){
        AvailabilityChangeEvent.publish(applicationEventPublisher, StateWritter.this, ReadinessState.ACCEPTING_TRAFFIC);
        return &quot;success accept, &quot; + new Date();
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;8&quot;&gt;&lt;li&gt;增加名为&lt;span&gt;Hello&lt;/span&gt;的controller，此接口能返回当前pod的IP地址，在后面测试时会用到：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.bolingcavalry.probedemo.controller;

import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.net.Inet4Address;
import java.net.InetAddress;
import java.net.NetworkInterface;
import java.net.SocketException;
import java.util.ArrayList;
import java.util.Date;
import java.util.Enumeration;
import java.util.List;

/**
 * description: hello demo &amp;lt;br&amp;gt;
 * date: 2020/6/4 下午4:38 &amp;lt;br&amp;gt;
 * author: willzhao &amp;lt;br&amp;gt;
 * email: zq2599@gmail.com &amp;lt;br&amp;gt;
 * version: 1.0 &amp;lt;br&amp;gt;
 */
@RestController
public class Hello {

    /**
     * 返回的是当前服务器IP地址，在k8s环境就是pod地址
     * @return
     * @throws SocketException
     */
    @RequestMapping(value=&quot;/hello&quot;)
    public String hello() throws SocketException {
        List&amp;lt;Inet4Address&amp;gt; addresses = getLocalIp4AddressFromNetworkInterface();
        if(null==addresses || addresses.isEmpty()) {
            return  &quot;empty ip address, &quot; + new Date();
        }

        return addresses.get(0).toString() + &quot;, &quot; + new Date();
    }

    public static List&amp;lt;Inet4Address&amp;gt; getLocalIp4AddressFromNetworkInterface() throws SocketException {
        List&amp;lt;Inet4Address&amp;gt; addresses = new ArrayList&amp;lt;&amp;gt;(1);
        Enumeration e = NetworkInterface.getNetworkInterfaces();
        if (e == null) {
            return addresses;
        }
        while (e.hasMoreElements()) {
            NetworkInterface n = (NetworkInterface) e.nextElement();
            if (!isValidInterface(n)) {
                continue;
            }
            Enumeration ee = n.getInetAddresses();
            while (ee.hasMoreElements()) {
                InetAddress i = (InetAddress) ee.nextElement();
                if (isValidAddress(i)) {
                    addresses.add((Inet4Address) i);
                }
            }
        }
        return addresses;
    }

    /**
     * 过滤回环网卡、点对点网卡、非活动网卡、虚拟网卡并要求网卡名字是eth或ens开头
     * @param ni 网卡
     * @return 如果满足要求则true，否则false
     */
    private static boolean isValidInterface(NetworkInterface ni) throws SocketException {
        return !ni.isLoopback() &amp;amp;&amp;amp; !ni.isPointToPoint() &amp;amp;&amp;amp; ni.isUp() &amp;amp;&amp;amp; !ni.isVirtual()
                &amp;amp;&amp;amp; (ni.getName().startsWith(&quot;eth&quot;) || ni.getName().startsWith(&quot;ens&quot;));
    }

    /**
     * 判断是否是IPv4，并且内网地址并过滤回环地址.
     */
    private static boolean isValidAddress(InetAddress address) {
        return address instanceof Inet4Address &amp;amp;&amp;amp; address.isSiteLocalAddress() &amp;amp;&amp;amp; !address.isLoopbackAddress();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上就是该SpringBoot工程的所有代码了，请确保可以编译运行；&lt;/p&gt;
&lt;h3 id=&quot;制作docker镜像&quot;&gt;制作Docker镜像&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;在pom.xml所在目录创建文件Dockerfile，内容如下：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;# 指定基础镜像，这是分阶段构建的前期阶段
FROM openjdk:8u212-jdk-stretch as builder
# 执行工作目录
WORKDIR application
# 配置参数
ARG JAR_FILE=target/*.jar
# 将编译构建得到的jar文件复制到镜像空间中
COPY ${JAR_FILE} application.jar
# 通过工具spring-boot-jarmode-layertools从application.jar中提取拆分后的构建结果
RUN java -Djarmode=layertools -jar application.jar extract

# 正式构建镜像
FROM openjdk:8u212-jdk-stretch
WORKDIR application
# 前一阶段从jar中提取除了多个文件，这里分别执行COPY命令复制到镜像空间中，每次COPY都是一个layer
COPY --from=builder application/dependencies/ ./
COPY --from=builder application/spring-boot-loader/ ./
COPY --from=builder application/snapshot-dependencies/ ./
COPY --from=builder application/application/ ./
ENTRYPOINT [&quot;java&quot;, &quot;org.springframework.boot.loader.JarLauncher&quot;]
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;先编译构建工程，执行以下命令：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;mvn clean package -U -DskipTests 
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;编译成功后，通过&lt;span&gt;Dockerfile&lt;/span&gt;文件创建镜像：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;sudo docker build -t bolingcavalry/probedemo:0.0.1 .
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;镜像创建成功：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202006/485422-20200611000940062-376788787.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;SpringBoot的镜像准备完毕，接下来要让kubernetes环境用上这个镜像；&lt;/p&gt;
&lt;h3 id=&quot;将镜像加载到kubernetes环境&quot;&gt;将镜像加载到kubernetes环境&lt;/h3&gt;
&lt;p&gt;此时的镜像保存在开发环境的电脑上，可以有以下三种方式加载到kubernetes环境：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;push到私有仓库，kubernetes上使用时也从私有仓库获取；&lt;/li&gt;
&lt;li&gt;push到hub.docker.com，kubernetes上使用时也从hub.docker.com获取，&lt;span&gt;目前我已经将此镜像push到hub.docker.com，您在kubernetes直接使用即可&lt;/span&gt;，就像nginx、tomcat这些官方镜像一样下载；&lt;/li&gt;
&lt;li&gt;在开发环境执行&lt;span&gt;docker save bolingcavalry/probedemo:0.0.1 &amp;gt; probedemo.tar&lt;/span&gt;，可将此镜像另存为本地文件，再scp到kubernetes服务器，再在kubernetes服务器执行&lt;span&gt;docker load &amp;lt; /root/temp/202006/04/probedemo.tar&lt;/span&gt;就能加载到kubernetes服务器的本地docker缓存中；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;以上三种方法的优缺点整理如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;首推第一种，但是需要您搭建私有仓库；&lt;/li&gt;
&lt;li&gt;由于springboot-2.3官方对镜像构建作了优化，第二种方法也就执行第一次的时候上传和下载很耗时，之后修改java代码重新构建时，不论上传还是下载都很快（只上传下载某个layer）；&lt;/li&gt;
&lt;li&gt;在开发阶段，使用第三种方法最为便捷，但如果kubernetes环境有多台机器，就不合适了，因为镜像是存在指定机器的本地缓存的；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;我的kubernetes环境只有一台电脑，因此用的是方法三，参考命令如下(建议安装sshpass，就不用每次输入帐号密码了)：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;# 将镜像保存为tar文件
sudo docker save bolingcavalry/probedemo:0.0.1 &amp;gt; probedemo.tar

# scp到kubernetes服务器
sshpass -p 888888 scp ./probedemo.tar root@192.168.50.135:/root/temp/202006/04/ 
  
# 远程执行ssh命令，加载docker镜像
sshpass -p 888888 ssh root@192.168.50.135 &quot;docker load &amp;lt; /root/temp/202006/04/probedemo.tar&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;kubernetes部署deployment和service&quot;&gt;kubernetes部署deployment和service&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;在kubernetes创建名为&lt;span&gt;probedemo.yaml&lt;/span&gt;的文件，内容如下，注意pod副本数是&lt;span&gt;2&lt;/span&gt;，另外请关注livenessProbe和readinessProbe的参数配置：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-yaml&quot;&gt;apiVersion: v1
kind: Service
metadata:
  name: probedemo
spec:
  type: NodePort
  ports:
    - port: 8080
      nodePort: 30080
  selector:
    name: probedemo
---
apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  name: probedemo
spec:
  replicas: 2
  template:
    metadata:
      labels:
        name: probedemo
    spec:
      containers:
        - name: probedemo
          image: bolingcavalry/probedemo:0.0.1
          tty: true
          livenessProbe:
            httpGet:
              path: /actuator/health/liveness
              port: 8080
            initialDelaySeconds: 5
            failureThreshold: 10
            timeoutSeconds: 10
            periodSeconds: 5
          readinessProbe:
            httpGet:
              path: /actuator/health/readiness
              port: 8080
            initialDelaySeconds: 5
            timeoutSeconds: 10
            periodSeconds: 5
          ports:
            - containerPort: 8080
          resources:
            requests:
              memory: &quot;512Mi&quot;
              cpu: &quot;100m&quot;
            limits:
              memory: &quot;1Gi&quot;
              cpu: &quot;500m&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;执行命令&lt;span&gt;kubectl apply -f probedemo..yaml&lt;/span&gt;，即可创建deployment和service：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202006/485422-20200611000940348-359346027.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;这里要重点关注的是&lt;span&gt;livenessProbe&lt;/span&gt;的&lt;span&gt;initialDelaySeconds&lt;/span&gt;和&lt;span&gt;failureThreshold&lt;/span&gt;参数，initialDelaySeconds等于5，表示pod创建5秒后检查存活探针，如果10秒内应用没有完成启动，存活探针不返回200，就会重试10次(failureThreshold等于10)，如果重试10次后存活探针依旧无法返回200，该pod就会被kubernetes杀死重建，要是每次启动都耗时这么长，pod就会不停的被杀死重建；&lt;/li&gt;
&lt;li&gt;执行命令&lt;span&gt;kubectl apply -f probedemo.yaml&lt;/span&gt;，创建deployment和service，如下图，可见在第十秒的时候pod创建成功，但是此时还未就绪：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202006/485422-20200611000940866-1596854845.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;5&quot;&gt;&lt;li&gt;继续查看状态，创建一分钟后两个pod终于就绪：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202006/485422-20200611000941411-600171684.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;6&quot;&gt;&lt;li&gt;用&lt;span&gt;kubectl describe&lt;/span&gt;命令查看pod状态，事件通知显示存活和就绪探针都有失败情况，不过因为有重试，因此后来状态会变为成功：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202006/485422-20200611000942013-1135276185.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至此，从编码到部署都完成了，接下来验证SpringBoot-2.3.0.RELEASE的探针技术；&lt;/p&gt;
&lt;h3 id=&quot;验证springboot-230release的探针技术&quot;&gt;验证SpringBoot-2.3.0.RELEASE的探针技术&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;监听类&lt;span&gt;AvailabilityListener&lt;/span&gt;的作用是监听状态变化，看看pod日志，看AvailabilityListener的代码是否有效，如下图红框，在应用启动阶段AvailabilityListener被成功回调，打印了存活和就绪状态：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202006/485422-20200611000943404-1785725949.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;2&quot; readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;kubernetes所在机器的IP地址是&lt;span&gt;192.168.50.135&lt;/span&gt;，因此SpringBoot服务的访问地址是&lt;a href=&quot;http://192.168.50.135:30080/xxx&quot;&gt;&lt;span&gt;http://192.168.50.135:30080/xxx&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;访问地址&lt;a href=&quot;http://192.168.50.135:30080/actuator/health/liveness&quot;&gt;&lt;span&gt;http://192.168.50.135:30080/actuator/health/liveness&lt;/span&gt;&lt;/a&gt;，返回码如下图红框，可见存活探针已开启：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202006/485422-20200611000943951-71971531.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;就绪探针也正常：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202006/485422-20200611000944432-609705543.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;5&quot;&gt;&lt;li&gt;打开两个浏览器，都访问：&lt;a href=&quot;http://192.168.50.135:30080/hello&quot;&gt;&lt;span&gt;http://192.168.50.135:30080/hello&lt;/span&gt;&lt;/a&gt;，多次Ctrl+F5强刷，如下图，很快就能得到不同结果，证明响应来自不同的Pod：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202006/485422-20200611000944734-335831051.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;6&quot;&gt;&lt;li&gt;访问：&lt;a href=&quot;http://192.168.50.135:30080/statereader/get&quot;&gt;&lt;span&gt;http://192.168.50.135:30080/statereader/get&lt;/span&gt;&lt;/a&gt;，可以得到存活和就绪的状态，可见StateReader的代码已经生效，可以通过ApplicationAvailability接口取得状态：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202006/485422-20200611000944976-1320053991.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;7&quot;&gt;&lt;li&gt;修改就绪状态，访问：&lt;a href=&quot;http://192.168.50.135:30080/statewriter/refuse&quot;&gt;&lt;span&gt;http://192.168.50.135:30080/statewriter/refuse&lt;/span&gt;&lt;/a&gt;，如下图红框，可见收到请求的pod，其就绪状态已经出现了异常，证明&lt;span&gt;StateWritter.java中修改就绪状态后，可以让kubernetes感知到这个pod的异常&lt;/span&gt;：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202006/485422-20200611000945351-1486262008.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;8&quot;&gt;&lt;li&gt;用浏览器反复强刷hello接口，返回的Pod地址也只有一个，证明只有一个Pod在响应请求：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202006/485422-20200611000945672-1196008448.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;9&quot;&gt;&lt;li&gt;尝试恢复服务，注意请求要在服务器后台发送，而且IP地址要用刚才被设置为refuse的&lt;span&gt;pod地址&lt;/span&gt;：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;curl http://10.233.90.195:8080/statewriter/accept
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;10&quot;&gt;&lt;li&gt;如下图，状态已经恢复：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202006/485422-20200611000946136-458399652.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;11&quot;&gt;&lt;li&gt;最后再来试试将存活状态从&lt;span&gt;CORRECT&lt;/span&gt;改成&lt;span&gt;BROKEN&lt;/span&gt;，浏览器访问：&lt;a href=&quot;http://192.168.50.135:30080/statewriter/broken&quot;&gt;&lt;span&gt;http://192.168.50.135:30080/statewriter/broken&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;如下图红框，重启次数变成1，表示pod被杀死了一次，并且由于重启导致当前还未就绪，证明&lt;span&gt;在SpringBoot中修改了存活探针的状态，是会触发kubernetes杀死pod的&lt;/span&gt;：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202006/485422-20200611000946499-1250157465.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;13&quot;&gt;&lt;li&gt;等待pod重启、就绪探针正常后，一切恢复如初：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202006/485422-20200611000946875-9868558.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;14&quot;&gt;&lt;li&gt;强刷浏览器，如下图红框，两个Pod都能正常响应：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202006/485422-20200611000947256-126095586.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;官方忠告&quot;&gt;官方忠告&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;至此，《掌握SpringBoot-2.3的容器探针》系列就全部完成了，从理论到实践，咱们一起学习了SpringBoot官方带给我们的容器化技术，最后以一段官方忠告来结尾，大家一起将此忠告牢记在心：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202006/485422-20200611000947727-2055232416.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;我对以上内容的理解：选择外部系统的服务作为探针的时候要谨慎（外部系统可能是数据库，也可能是其他web服务），如果外部系统出现问题，会导致kubernetes杀死pod(存活探针问题)，或者导致kubernetes不再调度请求到pod(就绪探针问题)；（再请感谢大家容忍我的英语水平）&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;欢迎关注我的公众号：程序员欣宸&quot;&gt;欢迎关注我的公众号：程序员欣宸&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202006/485422-20200611000948080-40373597.jpg&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 10 Jun 2020 16:10:00 +0000</pubDate>
<dc:creator>zq2599</dc:creator>
<og:description>欢迎访问我的GitHub https://github.com/zq2599/blog_demos 内容：原创文章分类汇总，及配套源码，涉及Java、Docker、K8S、DevOPS等 经过多篇知识</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/bolingcavalry/p/13090502.html</dc:identifier>
</item>
<item>
<title>新基建下，智慧交通发展新规划：智慧隧道监控可视化系统 - xhload3d</title>
<link>http://www.cnblogs.com/xhload3d/p/13086799.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xhload3d/p/13086799.html</guid>
<description>&lt;div id=&quot;cnblogs_post_description&quot; readability=&quot;35&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496396/202006/1496396-20200610120706456-395514572.gif&quot; class=&quot;desc_img&quot;/&gt; 随着当代经济的发展，交通环境日益紧张，加上山区地区的交通运输的需求，隧道的交通建设开发方兴未艾。隧道交通的规划越来越完备，而对于隧道内监控管理维护却显得有些不足。而工业4.0的崛起，逐步进入了智能化的新时代，伴随着工业互联网的新兴力量，工控可视化系统应运而生，不仅能起到日常的监控管理维护，在发现事故或险情时能第一时间采取应急预案；还能通过实时数据的采集反馈，远程操控设备运行以及预测设备的优良性能，从而达到更立体更全面的工控系统的运行。介于 2D 组态和 3D 组态上，Hightopo（以下简称 HT ）的 HT for Web 产品上的有着丰富的组态化可供选择，本文将介绍如何运用 HT 丰富的 2/3D 组态搭建出一个隧道监控可视化系统的解决方案。&lt;/div&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;94.506812746788&quot;&gt;
&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;随着当代经济的发展，交通环境日益紧张，加上山区地区的交通运输的需求，隧道的交通建设开发方兴未艾。&lt;strong&gt;隧道交通&lt;/strong&gt;的规划越来越完备，而对于隧道内监控管理维护却显得有些不足。而&lt;strong&gt;工业4.0&lt;/strong&gt;的崛起，逐步进入了智能化的新时代，伴随着&lt;strong&gt;工业互联网&lt;/strong&gt;的新兴力量，工控可视化系统应运而生，不仅能起到日常的监控管理维护，在发现事故或险情时能第一时间采取&lt;strong&gt;应急预案&lt;/strong&gt;；还能通过实时数据的采集反馈，远程操控设备运行以及预测设备的优良性能，从而达到更立体更全面的工控系统的运行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HT for Web&lt;/strong&gt;&lt;span data-offset-key=&quot;5arpc-0-2&quot;&gt;&lt;strong&gt; &lt;/strong&gt;不止自主研发了强大的基于 HTML5 的 2D、3D 渲染引擎，为可视化提供了丰富的展示效果。介于&lt;strong&gt; 2D 组态&lt;/strong&gt;和 &lt;strong&gt;3D 组态&lt;/strong&gt;上，&lt;strong&gt;Hightopo&lt;/strong&gt;（以下简称 HT ）的 &lt;strong&gt;HT for Web&lt;/strong&gt; 产品上的有着丰富的组态化可供选择，本文将介绍如何运用 HT 丰富的 &lt;strong&gt;2/3D 组态&lt;/strong&gt;搭建出一个隧道监控可视化系统的解决方案&lt;span data-offset-key=&quot;dpd9k-0-1&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;&lt;span data-offset-key=&quot;dpd9k-0-2&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;&lt;span data-offset-key=&quot;dpd9k-0-3&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;&lt;span data-offset-key=&quot;dpd9k-0-4&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;&lt;span data-offset-key=&quot;dpd9k-0-5&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;&lt;span data-offset-key=&quot;dpd9k-0-6&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;监控隧道内的车道堵塞情况、隧道内的车祸现场，在隧道中显示当前车祸位置并在隧道口给予提示等功能都是非常有必要的。这个隧道监控可视化系统的主要内容包括：照明、风机、车道指示灯、交通信号灯、情报板、消防、火灾报警、车行横洞、风向仪、微波车检、隧道紧急逃生出口的控制以及事故模拟等等。&lt;/p&gt;

&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;strong&gt;界面简介及效果预览&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496396/202006/1496396-20200610120706456-395514572.gif&quot; alt=&quot;&quot; width=&quot;711&quot; height=&quot;366&quot;/&gt;&lt;/div&gt;

&lt;div&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496396/202006/1496396-20200610120955153-626531224.gif&quot; alt=&quot;&quot; width=&quot;718&quot; height=&quot;369&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;11.230559345157&quot;&gt;
&lt;p&gt;预览链接：&lt;a href=&quot;http://www.hightopo.com/demo/tunnel2/index.html&quot; target=&quot;_blank&quot;&gt;http://www.hightopo.com/demo/tunnel2/index.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;上图中的各种设备都可以双击，此时 camera 的位置会从当前位置移动到双击的设备的正前方；隧道入口的展示牌会自动轮播，出现事故时会展示牌中的内容会由“限速80，请开车灯”变为“超车道两车追尾，请减速慢行”；两隧道中间的逃生通道上方的指示牌是可以点击的，点击切换为蓝绿色激活状态，两旁的逃生通道门也会打开，再单击指示牌变为灰色，门关闭；还有一个事故现场模拟，双击两旁变压器中其中一个，在隧道内会出现一个“事故现场图标”，单击此图标，出现弹出框显示事故等等等等。&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;strong&gt;代码实现&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span data-mce-=&quot;&quot;&gt;一、场景搭建&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;整个隧道都是基于 3D 场景上绘制的，先来看看怎么搭建 3D 场景：&lt;/p&gt;
&lt;div readability=&quot;46.427309182356&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 数据容器
dm = &lt;span data-mce-=&quot;&quot;&gt;new&lt;span data-mce-=&quot;&quot;&gt; ht.DataModel();
&lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 3d 场景
g3d = &lt;span data-mce-=&quot;&quot;&gt;new&lt;span data-mce-=&quot;&quot;&gt; ht.graph3d.Graph3dView(dm);
&lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 将场景添加到 body 中
g3d.addToDOM();&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面代码中的 addToDOM 函数，是一个将组件添加到 body 体中的函数的封装，定义如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
addToDOM = &lt;span data-mce-=&quot;&quot;&gt;function&lt;span data-mce-=&quot;&quot;&gt;(){
    &lt;span data-mce-=&quot;&quot;&gt;var self = &lt;span data-mce-=&quot;&quot;&gt;this&lt;span data-mce-=&quot;&quot;&gt;,
         &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 获取组件的底层 div
         view =&lt;span data-mce-=&quot;&quot;&gt; self.getView(),
         style =&lt;span data-mce-=&quot;&quot;&gt; view.style;
    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 将组件底层div添加进body中
&lt;span data-mce-=&quot;&quot;&gt;    document.body.appendChild(view);
    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; ht 默认将所有的组件的position都设置为absolute绝对定位
    style.left = '0'&lt;span data-mce-=&quot;&quot;&gt;;
    style.right = '0'&lt;span data-mce-=&quot;&quot;&gt;;
    style.top = '0'&lt;span data-mce-=&quot;&quot;&gt;;
    style.bottom = '0'&lt;span data-mce-=&quot;&quot;&gt;;
    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 窗口大小改变事件，调用刷新函数
    window.addEventListener('resize', &lt;span data-mce-=&quot;&quot;&gt;function () { self.iv(); }, &lt;span data-mce-=&quot;&quot;&gt;false&lt;span data-mce-=&quot;&quot;&gt;);
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;strong&gt;二、JSON反序列化&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;整个场景是由名为 隧道1.json 的文件导出而成的，我只需要用代码将 json 文件中的内容转换为我需要的部分即可：&lt;/p&gt;
&lt;div readability=&quot;44&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; xhrLoad 函数是一个异步加载文件的函数
ht.Default.xhrLoad('./scenes/隧道1.json', &lt;span data-mce-=&quot;&quot;&gt;function&lt;span data-mce-=&quot;&quot;&gt;(text) {
    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 将 json 文件中的文本转为我们需要的 json 格式的内容
    &lt;span data-mce-=&quot;&quot;&gt;var json =&lt;span data-mce-=&quot;&quot;&gt; ht.Default.parse(text);
    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 反序列化数据容器，解析用于生成对应的Data对象并添加到数据容器 这里相当于把 json 文件中生成的 ht.Node 节点反序列化到数据容器中，这样数据容器中就有这个节点了
&lt;span data-mce-=&quot;&quot;&gt;    dm.deserialize(json);
});&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于 xhrLoad 函数是一个异步加载函数，所以如果 dm 数据容器反序列化未完成就直接调用了其中的节点，那么会造成数据获取不到的结果，所以一般来说我是将一些逻辑代码写在这个函数内部，或者给逻辑代码设置 timeout 错开时间差。&lt;/p&gt;
&lt;p&gt;首先，由于数据都是存储在 dm 数据容器中的（通过 dm.add(node) 添加的），所以我们要获取数据除了可以通过 id、tag 等独立的方式，还可以通过遍历数据容器来获取多个元素。由于这个场景比较复杂，模型的面也比较多，鉴于设备配置，我将能 Batch 批量的元素都进行了批量。&lt;/p&gt;
&lt;p&gt;批量是 HT 实现下的一种特有的机制，批量能提高性能的原理在于，当图元一个个独立绘制模型时性能较差，而当一批图元聚合成一个大模型进行一次性的绘制时， 则会极大提高 &lt;strong&gt;WebGL&lt;/strong&gt; 刷新性能，执行代码如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;74&quot;&gt;
&lt;pre&gt;
dm.each(&lt;span data-mce-=&quot;&quot;&gt;function&lt;span data-mce-=&quot;&quot;&gt;(data) {
    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 对“电话”进行批量
    &lt;span data-mce-=&quot;&quot;&gt;if (data.s('front.image') === 'assets/sos电话.png'&lt;span data-mce-=&quot;&quot;&gt;){
        data.s('batch', 'sosBatch'&lt;span data-mce-=&quot;&quot;&gt;);
    }
    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 逃生通道批量（透明度也会影响性能）
    &lt;span data-mce-=&quot;&quot;&gt;else &lt;span data-mce-=&quot;&quot;&gt;if (data.s('all.color') === 'rgba(222,222,222,0.18)'&lt;span data-mce-=&quot;&quot;&gt;) {
        data.s('batch', 'emergencyBatch'&lt;span data-mce-=&quot;&quot;&gt;);
    }
    &lt;span data-mce-=&quot;&quot;&gt;else &lt;span data-mce-=&quot;&quot;&gt;if (data.s('shape3d') === 'models/隧道/摄像头.json' || data.s('shape3d') === 'models/隧道/横洞.json' || data.s('shape3d') === 'models/隧道/卷帘门.json'&lt;span data-mce-=&quot;&quot;&gt;) {
        &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 个别摄像头染色了 不做批量
        &lt;span data-mce-=&quot;&quot;&gt;if(!data.s('shape3d.blend'&lt;span data-mce-=&quot;&quot;&gt;))
            &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 基础批量什么也不做
            data.s('batch', 'basicBatch'&lt;span data-mce-=&quot;&quot;&gt;);
    }
    &lt;span data-mce-=&quot;&quot;&gt;else &lt;span data-mce-=&quot;&quot;&gt;if (data.s('shape3d') === 'models/大型变压器/变压器.json'&lt;span data-mce-=&quot;&quot;&gt;) {    
        data.s('batch', 'tileBatch'&lt;span data-mce-=&quot;&quot;&gt;);
        data.setToolTip('单击漫游，双击车祸地点出现图标'&lt;span data-mce-=&quot;&quot;&gt;);
    }
    &lt;span data-mce-=&quot;&quot;&gt;else &lt;span data-mce-=&quot;&quot;&gt;if (data.getDisplayName() === '地面'&lt;span data-mce-=&quot;&quot;&gt;) {
        &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 设置隧道“地面”不可选中
        data.s('3d.selectable', &lt;span data-mce-=&quot;&quot;&gt;false&lt;span data-mce-=&quot;&quot;&gt;);
    }
    &lt;span data-mce-=&quot;&quot;&gt;else &lt;span data-mce-=&quot;&quot;&gt;if (data.s('shape3d') === 'models/隧道/排风.json'&lt;span data-mce-=&quot;&quot;&gt;) {
        &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 排风扇的模型比较复杂，所以做批量
        data.s('batch', 'fanBatch'&lt;span data-mce-=&quot;&quot;&gt;);
    }
    &lt;span data-mce-=&quot;&quot;&gt;else &lt;span data-mce-=&quot;&quot;&gt;if (data.getDisplayName() === 'arrow'&lt;span data-mce-=&quot;&quot;&gt;) {
        &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 隧道两旁的箭头路标
        &lt;span data-mce-=&quot;&quot;&gt;if (data.getTag() === 'arrowLeft') data.s('shape3d.image', 'displays/abc.png'&lt;span data-mce-=&quot;&quot;&gt;);
        &lt;span data-mce-=&quot;&quot;&gt;else data.s('shape3d.image', 'displays/abc2.png'&lt;span data-mce-=&quot;&quot;&gt;);
        data.s({
            'shape3d': 'billboard'&lt;span data-mce-=&quot;&quot;&gt;,
            &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 缓存，设置了 cache 的代价是需要设置 invalidateShape3dCachedImage
            'shape3d.image.cache': &lt;span data-mce-=&quot;&quot;&gt;true&lt;span data-mce-=&quot;&quot;&gt;,
            &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 设置这个值，图片上的锯齿就不会太明显了（若图片类型为 json，则设置 shape3d.dynamic.transparent)
            'shape3d.transparent': &lt;span data-mce-=&quot;&quot;&gt;true&lt;span data-mce-=&quot;&quot;&gt; 
        });
        g3d.invalidateShape3dCachedImage(data);
    }
    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 隧道入口处的情报板
    &lt;span data-mce-=&quot;&quot;&gt;else &lt;span data-mce-=&quot;&quot;&gt;if (data.getTag() === 'board' || data.getTag() === 'board1'&lt;span data-mce-=&quot;&quot;&gt;) {
        &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 业务属性，用来控制文本的位置[x,y,width,height]
        data.a('textRect', [0, 2, 244, 46&lt;span data-mce-=&quot;&quot;&gt;]); 
        &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 业务属性，设置文本内容
        data.a('limitText', '限速80，请开车灯'&lt;span data-mce-=&quot;&quot;&gt;);
        &lt;span data-mce-=&quot;&quot;&gt;var min = -245&lt;span data-mce-=&quot;&quot;&gt;;
        &lt;span data-mce-=&quot;&quot;&gt;var name = 'board' +&lt;span data-mce-=&quot;&quot;&gt; data.getId();
        window[name] = setInterval(&lt;span data-mce-=&quot;&quot;&gt;function&lt;span data-mce-=&quot;&quot;&gt;() {
            &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 设置情报板中的文字向左滚动，并且当文字全部显示时重复闪烁三次
&lt;span data-mce-=&quot;&quot;&gt;            circleFunc(data, window[name], min);
        }, 100&lt;span data-mce-=&quot;&quot;&gt;);
    }

    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt;给逃生通道上方的指示板 动态设置颜色
    &lt;span data-mce-=&quot;&quot;&gt;var infos = ['人行横洞1', '人行横洞2', '人行横洞3', '人行横洞4', '车行横洞1', '车行横洞2', '车行横洞3'&lt;span data-mce-=&quot;&quot;&gt;];
    infos.forEach(&lt;span data-mce-=&quot;&quot;&gt;function&lt;span data-mce-=&quot;&quot;&gt;(info) {
        &lt;span data-mce-=&quot;&quot;&gt;if(data.getDisplayName() ===&lt;span data-mce-=&quot;&quot;&gt; info) {
            data.a('emergencyColor', 'rgb(138, 138, 138)'&lt;span data-mce-=&quot;&quot;&gt;);
        }
    });

    infos = ['车道指示器', '车道指示器1', '车道指示器2', '车道指示器3'&lt;span data-mce-=&quot;&quot;&gt;];
    infos.forEach(&lt;span data-mce-=&quot;&quot;&gt;function&lt;span data-mce-=&quot;&quot;&gt;(info) {
        &lt;span data-mce-=&quot;&quot;&gt;if (data.getDisplayName() ===&lt;span data-mce-=&quot;&quot;&gt; info) {
            &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 考虑到性能问题 将六面体变换为 billboard 类型元素
            createBillboard(data, 'assets/车道信号-过.png', 'assets/车道信号-过.png'&lt;span data-mce-=&quot;&quot;&gt;, info);
        }
    });
});&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;上面有一处设置了 tooltip 文字提示信息，在 3d 中，要显示这个文字提示信息，就需要设置 g3d.enableToolTip() 函数，默认 3d 组件是关闭这个功能的。&lt;/p&gt;

&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;strong&gt;三、逻辑代码&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;strong&gt;情报板滚动条&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496396/202006/1496396-20200610114315359-992002557.gif&quot; alt=&quot;&quot; width=&quot;765&quot; height=&quot;394&quot;/&gt;&lt;/div&gt;
&lt;p&gt;我就直接按照上面代码中提到的方法进行解释，首先是 circleFunc 情报板文字循环移动的函数，在这个函数中我们用到了业务属性 limitText 设置情报板中的文字属性以及 textRect 设置情报板中文字的移动位置属性：&lt;/p&gt;
&lt;div readability=&quot;17.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
&lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 设置情报板中的文字向左滚动，并且当文字全部显示时重复闪烁三次
&lt;span data-mce-=&quot;&quot;&gt;function&lt;span data-mce-=&quot;&quot;&gt; circleFunc(data, timer, min) {
    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 获取当前业务属性 limitText 的内容
    &lt;span data-mce-=&quot;&quot;&gt;var text = data.a('limitText'&lt;span data-mce-=&quot;&quot;&gt;);
    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 设置业务属性 textRect 文本框的坐标和大小
    data.a('textRect', [data.a('textRect')[0]-5, 2, 244, 46&lt;span data-mce-=&quot;&quot;&gt;]); 
    &lt;span data-mce-=&quot;&quot;&gt;if (parseInt(data.a('textRect')) &amp;lt;=&lt;span data-mce-=&quot;&quot;&gt; parseInt(min)) {
        data.a('textRect', [255, 2, 244, 46&lt;span data-mce-=&quot;&quot;&gt;]);
    }
    &lt;span data-mce-=&quot;&quot;&gt;else &lt;span data-mce-=&quot;&quot;&gt;if (data.a('textRect')[0] === 0&lt;span data-mce-=&quot;&quot;&gt;) {
        clearInterval(timer);
        &lt;span data-mce-=&quot;&quot;&gt;var index = 0&lt;span data-mce-=&quot;&quot;&gt;;
        &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 设置多个 timer 是因为能够进入这个函数中的不止一个 data，如果在同一时间多个 data 设置同一个 timer，那肯定只会对最后一个节点进行动画。后面还有很多这种陷阱，要注意
        &lt;span data-mce-=&quot;&quot;&gt;var testName = 'testTimer' +&lt;span data-mce-=&quot;&quot;&gt; data.getId();
        window[testName] = setInterval(&lt;span data-mce-=&quot;&quot;&gt;function&lt;span data-mce-=&quot;&quot;&gt;() {
            index++&lt;span data-mce-=&quot;&quot;&gt;;
            &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 如果情报板中文本内容为空
            &lt;span data-mce-=&quot;&quot;&gt;if(data.a('limitText') === ''&lt;span data-mce-=&quot;&quot;&gt;) {
                setTimeout(&lt;span data-mce-=&quot;&quot;&gt;function&lt;span data-mce-=&quot;&quot;&gt;() {
                    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 设置为传入的 text 值
                    data.a('limitText'&lt;span data-mce-=&quot;&quot;&gt;, text);
                }, 100&lt;span data-mce-=&quot;&quot;&gt;);
            }
            &lt;span data-mce-=&quot;&quot;&gt;else&lt;span data-mce-=&quot;&quot;&gt; {
                setTimeout(&lt;span data-mce-=&quot;&quot;&gt;function&lt;span data-mce-=&quot;&quot;&gt;() {
                    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 若情报板中的文本内容不为空，则设置为空
                    data.a('limitText', ''&lt;span data-mce-=&quot;&quot;&gt;); 
                }, 100&lt;span data-mce-=&quot;&quot;&gt;);
            }
            &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 重复三次 
            &lt;span data-mce-=&quot;&quot;&gt;if(index === 11&lt;span data-mce-=&quot;&quot;&gt;) { 
                clearInterval(window[testName]);
                data.a('limitText'&lt;span data-mce-=&quot;&quot;&gt;, text);
            }
        }, 100&lt;span data-mce-=&quot;&quot;&gt;);

        setTimeout(&lt;span data-mce-=&quot;&quot;&gt;function&lt;span data-mce-=&quot;&quot;&gt;() {
            timer = setInterval(&lt;span data-mce-=&quot;&quot;&gt;function&lt;span data-mce-=&quot;&quot;&gt;() {
                &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 回调函数
&lt;span data-mce-=&quot;&quot;&gt;                circleFunc(data, timer, min);
            }, 100&lt;span data-mce-=&quot;&quot;&gt;);
        }, 1500&lt;span data-mce-=&quot;&quot;&gt;);
    }
} &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;由于 WebGL 对浏览器的要求不低，为了能尽量多的适应各大浏览器，我们将所有的“道路指示器” ht.Node 类型的六面体全部换成 billboard 类型的节点，性能能提升不少。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/591709/201803/591709-20180322180150108-1553868583.png&quot; alt=&quot;&quot; width=&quot;82&quot; height=&quot;80&quot;/&gt;&lt;/p&gt;

&lt;p&gt;设置 billboard 的方法很简单，获取当前的六面体节点，然后给这些节点设置：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span data-mce-=&quot;&quot;&gt;node.s({
    'shape3d': 'billboard'&lt;span data-mce-=&quot;&quot;&gt;,
    'shape3d.image'&lt;span data-mce-=&quot;&quot;&gt;: imageUrl,
    'shape3d.image.cache': &lt;span data-mce-=&quot;&quot;&gt;true&lt;span data-mce-=&quot;&quot;&gt;
});
&lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 还记得用 shape3d.image.cache 的代价么？
g3d.invalidateShape3dCachedImage(node); &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当然，因为 billboard 不能双面显示不同的图片，只是一个“面”，所以我们还得在这个节点的位置创建另一个节点，在这个节点的“背面”显示图片，并且跟这个节点的配置一模一样，不过位置要稍稍偏移一点。&lt;/p&gt;

&lt;div readability=&quot;11.5&quot;&gt;
&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;strong&gt;Camera 缓慢偏移&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496396/202006/1496396-20200610114732944-736913051.gif&quot; alt=&quot;&quot; width=&quot;781&quot; height=&quot;402&quot;/&gt;&lt;/div&gt;
&lt;p&gt;其他动画部分比较简单，我就不在这里多说了，这里有一个双击节点能将视线从当前 camera 位置移动到双击节点正前方的位置的动画我提一下。我封装了两个函数 setEye 和 setCenter，分别用来设置 camera 的位置和目标位置的：&lt;/p&gt;
&lt;div readability=&quot;24&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 设置“目标”位置
&lt;span data-mce-=&quot;&quot;&gt;function&lt;span data-mce-=&quot;&quot;&gt; setCenter(center, finish) {
    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 获取当前“目标”位置，为一个数组，而 getCenter 数组会在视线移动的过程中不断变化，所以我们先拷贝一份
    &lt;span data-mce-=&quot;&quot;&gt;var c = g3d.getCenter().slice(0&lt;span data-mce-=&quot;&quot;&gt;), 
        &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 当前x轴位置和目标位置的差值
        dx = center[0] - c[0&lt;span data-mce-=&quot;&quot;&gt;], 
        dy = center[1] - c[1&lt;span data-mce-=&quot;&quot;&gt;],
        dz = center[2] - c[2&lt;span data-mce-=&quot;&quot;&gt;];
    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 启动 500 毫秒的动画过度
&lt;span data-mce-=&quot;&quot;&gt;    ht.Default.startAnim({
        duration: 500&lt;span data-mce-=&quot;&quot;&gt;,
        action: &lt;span data-mce-=&quot;&quot;&gt;function&lt;span data-mce-=&quot;&quot;&gt;(v, t) {
            &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 将“目标”位置缓慢从当前位置移动到设置的位置处
&lt;span data-mce-=&quot;&quot;&gt;            g3d.setCenter([ 
                c[0] + dx *&lt;span data-mce-=&quot;&quot;&gt; v,
                c[1] + dy *&lt;span data-mce-=&quot;&quot;&gt; v,
                c[2] + dz *&lt;span data-mce-=&quot;&quot;&gt; v
            ]);
        }
    });
};

&lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 设置“眼睛”位置
&lt;span data-mce-=&quot;&quot;&gt;function&lt;span data-mce-=&quot;&quot;&gt; setEye(eye, finish) {
    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 获取当前“眼睛”位置，为一个数组，而 getEye 数组会在视线移动的过程中不断变化，所以我们先拷贝一份
    &lt;span data-mce-=&quot;&quot;&gt;var e = g3d.getEye().slice(0&lt;span data-mce-=&quot;&quot;&gt;),
        dx = eye[0] - e[0&lt;span data-mce-=&quot;&quot;&gt;],
        dy = eye[1] - e[1&lt;span data-mce-=&quot;&quot;&gt;],
        dz = eye[2] - e[2&lt;span data-mce-=&quot;&quot;&gt;];
    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 启动 500 毫秒的动画过度
&lt;span data-mce-=&quot;&quot;&gt;    ht.Default.startAnim({
        duration: 500&lt;span data-mce-=&quot;&quot;&gt;,
        &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 将 Camera 位置缓慢地从当前位置移动到设置的位置
        action: &lt;span data-mce-=&quot;&quot;&gt;function&lt;span data-mce-=&quot;&quot;&gt;(v, t) {
            g3d.setEye([
                e[0] + dx *&lt;span data-mce-=&quot;&quot;&gt; v,
                e[1] + dy *&lt;span data-mce-=&quot;&quot;&gt; v,
                e[2] + dz *&lt;span data-mce-=&quot;&quot;&gt; v
            ]);
        }
    });
};&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;后期我们要设置的时候就直接调用这两个函数，并设置参数为我们目标的位置即可。比如我这个场景中的各个模型，由于不同视角对应的各个模型的旋转角度也不同，我只能找几个比较有代表性的 0°，90°，180°以及360° 这四种比较典型的角度了。所以绘制 3D 场景的时候，我也尽量设置节点的旋转角度为这四个中的一种（而且对于我们这个场景来说，基本上只在 y 轴上旋转了）：&lt;/p&gt;
&lt;div readability=&quot;25.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 获取事件对象的三维坐标
&lt;span data-mce-=&quot;&quot;&gt;var p3 =&lt;span data-mce-=&quot;&quot;&gt; e.data.p3(), 
    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 获取事件对象的三维尺寸
    s3 =&lt;span data-mce-=&quot;&quot;&gt; e.data.s3(),
    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 获取事件对象的三维旋转值
    r3 =&lt;span data-mce-=&quot;&quot;&gt; e.data.r3();
&lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 设置“目标”位置为当前事件对象的三维坐标值
&lt;span data-mce-=&quot;&quot;&gt;setCenter(p3);
&lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 如果节点的 y 轴旋转值 不为 0
&lt;span data-mce-=&quot;&quot;&gt;if (r3[1] !== 0&lt;span data-mce-=&quot;&quot;&gt;) {
    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 浮点负数得做转换才能进行比值
    &lt;span data-mce-=&quot;&quot;&gt;if (parseFloat(r3[1].toFixed(5)) === parseFloat(-3.14159&lt;span data-mce-=&quot;&quot;&gt;)) { 
        &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 设置camera 的目标位置
        setEye([p3[0], p3[1]+s3[1], p3[2] * Math.abs(r3[1]*2.3/6)]);
&lt;span data-mce-=&quot;&quot;&gt;    }
    &lt;span data-mce-=&quot;&quot;&gt;else &lt;span data-mce-=&quot;&quot;&gt;if (parseFloat(r3[1].toFixed(4)) === parseFloat(-1.5708&lt;span data-mce-=&quot;&quot;&gt;)) {
        setEye([p3[0] * Math.abs(r3[1]/1.8), p3[1]+s3[1], p3[2]]);
&lt;span data-mce-=&quot;&quot;&gt;    }
    &lt;span data-mce-=&quot;&quot;&gt;else&lt;span data-mce-=&quot;&quot;&gt; {
        setEye([p3[0] *r3[1], p3[1]+s3[1], p3[2&lt;span data-mce-=&quot;&quot;&gt;]]);
    }
}
&lt;span data-mce-=&quot;&quot;&gt;else&lt;span data-mce-=&quot;&quot;&gt; {
    setEye([p3[0], p3[1]+s3[1]*2, p3[2]+1000&lt;span data-mce-=&quot;&quot;&gt;]);
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;strong&gt;事故模拟现场&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496396/202006/1496396-20200610114931391-974352027.gif&quot; alt=&quot;&quot; width=&quot;773&quot; height=&quot;398&quot;/&gt;&lt;/div&gt;
&lt;p&gt;最后来说说模拟的事故现场吧，这段还是比较接近实际项目的。操作流程如下：双击“变压器”--&amp;gt;隧道中间某个部分会出现一个“事故现场”图标--&amp;gt;单击图标，弹出对话框，显示当前事故信息--&amp;gt;点击确定，则事故现场之前的灯都显示为红色×，并且隧道入口的情报板上的文字显示为“超车道两车追尾，请减速慢行”--&amp;gt;再双击一次“变压器”，场景恢复事故之前的状态。&lt;/p&gt;
&lt;p&gt;在 HT 中，可通过 Graph3dView#addInteractorListener（简写为 mi）来监听交互过程：&lt;/p&gt;
&lt;div readability=&quot;26.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
g3d.addInteractorListener(&lt;span data-mce-=&quot;&quot;&gt;function&lt;span data-mce-=&quot;&quot;&gt;(e) {
    &lt;span data-mce-=&quot;&quot;&gt;if(e.kind === 'doubleClickData'&lt;span data-mce-=&quot;&quot;&gt;) {
        &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 有“事故”图标节点存在
        &lt;span data-mce-=&quot;&quot;&gt;if (e.data.getTag() === 'jam') &lt;span data-mce-=&quot;&quot;&gt;return&lt;span data-mce-=&quot;&quot;&gt;;
        &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 如果双击对象是变压器
        &lt;span data-mce-=&quot;&quot;&gt;if (e.data.s('shape3d') === 'models/大型变压器/变压器.json'&lt;span data-mce-=&quot;&quot;&gt;) {
            index++&lt;span data-mce-=&quot;&quot;&gt;;
            &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 通过唯一标识 tag 标签获取“事故”图标节点对象
            &lt;span data-mce-=&quot;&quot;&gt;var jam = dm.getDataByTag('jam'&lt;span data-mce-=&quot;&quot;&gt;);
            &lt;span data-mce-=&quot;&quot;&gt;if(index === 1&lt;span data-mce-=&quot;&quot;&gt;){
                &lt;span data-mce-=&quot;&quot;&gt;var jam = dm.getDataByTag('jam'&lt;span data-mce-=&quot;&quot;&gt;);
                jam.s({
                    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 设置节点在 3d 上可见
                    '3d.visible': &lt;span data-mce-=&quot;&quot;&gt;true&lt;span data-mce-=&quot;&quot;&gt;,
                    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 设置节点为 billboard 类型
                    'shape3d': 'billboard'&lt;span data-mce-=&quot;&quot;&gt;,
                    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 设置 billboard 的显示图片
                    'shape3d.image': 'assets/车祸.png'&lt;span data-mce-=&quot;&quot;&gt;, 
                    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 设置 billboard 图片是否缓存
                    'shape3d.image.cache': &lt;span data-mce-=&quot;&quot;&gt;true&lt;span data-mce-=&quot;&quot;&gt;,
                    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 是否始终面向镜头
                    'shape3d.autorotate': &lt;span data-mce-=&quot;&quot;&gt;true&lt;span data-mce-=&quot;&quot;&gt;,
                    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 默认保持图片原本大小，设置为数组模式则可以设置图片显示在界面上的大小
                    'shape3d.fixSizeOnScreen': [30, 30&lt;span data-mce-=&quot;&quot;&gt;],
                });
                &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; cache 的代价是节点需要设置这个函数
&lt;span data-mce-=&quot;&quot;&gt;                g3d.invalidateShape3dCachedImage(jam);
             }
             &lt;span data-mce-=&quot;&quot;&gt;else&lt;span data-mce-=&quot;&quot;&gt; {
                 jam.s({
                     &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 第二次双击变压器就将所有一切恢复“事故”之前的状态
                     '3d.visible': &lt;span data-mce-=&quot;&quot;&gt;false&lt;span data-mce-=&quot;&quot;&gt;
                });
                dm.each(&lt;span data-mce-=&quot;&quot;&gt;function&lt;span data-mce-=&quot;&quot;&gt;(data) {
                    &lt;span data-mce-=&quot;&quot;&gt;var p3 =&lt;span data-mce-=&quot;&quot;&gt; data.p3();
                    &lt;span data-mce-=&quot;&quot;&gt;if ((p3[2] &amp;lt; jam.p3()[2]) &amp;amp;&amp;amp; data.getDisplayName() === '车道指示器1'&lt;span data-mce-=&quot;&quot;&gt;) {
                        data.s('shape3d.image', 'assets/车道信号-过.png'&lt;span data-mce-=&quot;&quot;&gt;);
                    }
                    &lt;span data-mce-=&quot;&quot;&gt;if(data.getTag() === 'board1'&lt;span data-mce-=&quot;&quot;&gt;) {
                        data.a('limitText', '限速80，请开车灯'&lt;span data-mce-=&quot;&quot;&gt;);
                    }
                });
                index = 0&lt;span data-mce-=&quot;&quot;&gt;;
            }             
        }
    }
});&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;既然“事故”节点图标出现了，接着点击图标出现“事故信息弹出框”，监听事件同样是在 mi（addInteractorListener）中，但是这次监听的是单击事件，我们知道，监听双击事件时会触发一次单击事件，为了避免这种情况，我在单击事件里面做了演示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 点击图元
&lt;span data-mce-=&quot;&quot;&gt;else &lt;span data-mce-=&quot;&quot;&gt;if (e.kind === 'clickData'&lt;span data-mce-=&quot;&quot;&gt;){
    timer = setTimeout(&lt;span data-mce-=&quot;&quot;&gt;function&lt;span data-mce-=&quot;&quot;&gt;() {
        clearTimeout(timer);
        &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 如果是“事故”图标节点
        &lt;span data-mce-=&quot;&quot;&gt;if (e.data.getTag() === 'jam'&lt;span data-mce-=&quot;&quot;&gt;) {
            &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 创建一个对话框
&lt;span data-mce-=&quot;&quot;&gt;            createDialog(e.data);
        }
    }, 200&lt;span data-mce-=&quot;&quot;&gt;);
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在上面的双击事件中我没有 clearTimeout，怕顺序问题给大家造成困扰，要记得加一下。&lt;/p&gt;
&lt;p&gt;弹出框如下：&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/591709/201803/591709-20180322224048072-262159732.png&quot; alt=&quot;&quot; width=&quot;400&quot; height=&quot;154&quot;/&gt;&lt;/div&gt;
&lt;p&gt;这个弹出框是由两个 ht.widget.FormPane 表单构成的，左边的表单只有一行，行高为 140，右边的表单是由 5 行构成的，点击确定，则“事故”图标节点之前的道路指示灯都换成红色×的图标：&lt;/p&gt;
&lt;div readability=&quot;12&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 弹出框右边的表单
&lt;span data-mce-=&quot;&quot;&gt;function&lt;span data-mce-=&quot;&quot;&gt; createForm4(node, dialog) {
    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 表单组件
    &lt;span data-mce-=&quot;&quot;&gt;var form = &lt;span data-mce-=&quot;&quot;&gt;new&lt;span data-mce-=&quot;&quot;&gt; ht.widget.FormPane();
    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 设置表单组件的宽
    form.setWidth(200&lt;span data-mce-=&quot;&quot;&gt;);
    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 设置表单组件的高
    form.setHeight(200&lt;span data-mce-=&quot;&quot;&gt;);
    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 获取表单组件的底层 div 
    &lt;span data-mce-=&quot;&quot;&gt;var view =&lt;span data-mce-=&quot;&quot;&gt; form.getView();
    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 将表单组件添加到 body 中
&lt;span data-mce-=&quot;&quot;&gt;    document.body.appendChild(view);

    &lt;span data-mce-=&quot;&quot;&gt;var infos =&lt;span data-mce-=&quot;&quot;&gt; [
        '编辑框内容为：2辆'&lt;span data-mce-=&quot;&quot;&gt;,
        '编辑框内容为：客车-客车'&lt;span data-mce-=&quot;&quot;&gt;,
        '编辑框内容为：无起火'&lt;span data-mce-=&quot;&quot;&gt;,
        '编辑框内容为：超车道'&lt;span data-mce-=&quot;&quot;&gt;
    ];
    infos.forEach(&lt;span data-mce-=&quot;&quot;&gt;function&lt;span data-mce-=&quot;&quot;&gt;(info) {
        &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 向表单中添加行
&lt;span data-mce-=&quot;&quot;&gt;        form.addRow([ 
            info
        &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 第二个参数为行宽度，小于1的值为相对值
        ], [0.1&lt;span data-mce-=&quot;&quot;&gt;]);
    });
    
    form.addRow([
        {
            &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 添加一行的“确认”按钮
&lt;span data-mce-=&quot;&quot;&gt;            button: {
                label: '确认'&lt;span data-mce-=&quot;&quot;&gt;,
                &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 按钮点击事件触发
                onClicked: &lt;span data-mce-=&quot;&quot;&gt;function&lt;span data-mce-=&quot;&quot;&gt;() {
                    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 隐藏对话框
&lt;span data-mce-=&quot;&quot;&gt;                    dialog.hide();
                    dm.each(&lt;span data-mce-=&quot;&quot;&gt;function&lt;span data-mce-=&quot;&quot;&gt;(data) {
                        &lt;span data-mce-=&quot;&quot;&gt;var p3 =&lt;span data-mce-=&quot;&quot;&gt; data.p3();
                        &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 改变“车道指示器”的显示图片为红色×，这里我是根据“事故”图标节点的坐标来判断“车道显示器”是在前还是在后的
                        &lt;span data-mce-=&quot;&quot;&gt;if ((p3[2] &amp;lt; node.p3()[2]) &amp;amp;&amp;amp; data.getDisplayName() === '车道指示器1'&lt;span data-mce-=&quot;&quot;&gt;) {
                            data.s('shape3d.image', 'assets/车道信号-禁止.png'&lt;span data-mce-=&quot;&quot;&gt;);
                        }
                        &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 将隧道口的情报板上的文字替换
                        &lt;span data-mce-=&quot;&quot;&gt;if(data.getTag() === 'board1'&lt;span data-mce-=&quot;&quot;&gt;) {
                            data.a('limitText', '超车道两车追尾，请减速慢行'&lt;span data-mce-=&quot;&quot;&gt;);
                        }
                    });
                }
            }
        }
    ], [0.1&lt;span data-mce-=&quot;&quot;&gt;]);
    &lt;span data-mce-=&quot;&quot;&gt;return&lt;span data-mce-=&quot;&quot;&gt; form;
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;11.465346534653&quot;&gt;伴随着新基建的建设兴起，是以新发展理念为引领，以技术创新为驱动，以信息网络为基础，面向高质量发展需要，提供数字转型、智能升级、融合创新等服务的基础设施体系的完备，国家正迈入新时代的建设，也迎来了新时代的挑战与机遇。隧道交通的监控可以归纳为工控管理与智慧交通建设的产物，同样具有极为重要的意义。在众多行业上所积累的经验，HT 已经实现了许多不同领域建设的案例，例如&lt;a href=&quot;https://www.cnblogs.com/htdaydayup/p/12894998.html&quot; target=&quot;_blank&quot;&gt;路口监管可视化系统&lt;/a&gt;，有兴趣的话也可以了解一下！&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496396/202005/1496396-20200518110143690-220284770.gif&quot; alt=&quot;&quot; width=&quot;773&quot; height=&quot;337&quot;/&gt; &lt;/div&gt;


&lt;/div&gt;</description>
<pubDate>Wed, 10 Jun 2020 15:59:00 +0000</pubDate>
<dc:creator>xhload3d</dc:creator>
<og:description>前言 随着当代经济的发展，交通环境日益紧张，加上山区地区的交通运输的需求，隧道的交通建设开发方兴未艾。隧道交通的规划越来越完备，而对于隧道内监控管理维护却显得有些不足。而工业4.0的崛起，逐步进入了智</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xhload3d/p/13086799.html</dc:identifier>
</item>
</channel>
</rss>