<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>吃个快餐都能学到串行、并行、并发 - LieBrother</title>
<link>http://www.cnblogs.com/liebrother/p/11161609.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liebrother/p/11161609.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;http://www.liebrother.com/upload/32d6905049e44f53845989face15eb91_0066_01.jpg&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Java 多线程系列文章第 3 篇&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这篇文章继续来唠唠概念，讲这三兄弟：&lt;strong&gt;串行（Serial）&lt;/strong&gt;、&lt;strong&gt;并行（Parallel）&lt;/strong&gt;、&lt;strong&gt;并发（Concurrent）&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;吃快餐&quot;&gt;吃快餐&lt;/h2&gt;
&lt;p&gt;出门在外吃饭是一件头疼的事，用我大学舍友一句话形容：如果不是没吃饭不能活，他是不会吃饭的。不管学生还是工作者，吃饭都是一件需要揪心的事，有食堂的企业员工纠结要在公司食堂吃饭还是在外面吃饭，没食堂的企业员工则纠结是吃面还是吃米饭。每到饭点，和同事去吃饭都会问一句废话：吃啥？然后相视而笑，继续吃快餐。。。&lt;/p&gt;
&lt;p&gt;咱吃快餐也能学点知识，我来给大家一一道来。快餐有一个很明显的特点就是：&lt;strong&gt;排队！！！&lt;/strong&gt; 目前我见过的有下面几种排队方式，刚好和咱们今天要讲的&lt;strong&gt;串行&lt;/strong&gt;、&lt;strong&gt;并发&lt;/strong&gt;、&lt;strong&gt;并行&lt;/strong&gt;一一对应。&lt;/p&gt;
&lt;p&gt;现在我们公司附近的快餐，人少的时候，就是排一条队，如下图所示，每个人按顺序排，一直往前走，如果看到想吃的菜，就用手指一指，快餐员工就会给你打菜，这个应该是很多快餐店都采用的方式，容易管理，但是有一点需要强调的就是如果一个同学只想吃米饭和豆芽，他还是需要排一整队到最后的结账台结账。这其实就是咱们计算机世界里面的&lt;strong&gt;串行&lt;/strong&gt;，一条队伍，依次有序的执行着。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.liebrother.com/upload/c3c616eeb25d449f878e4683fdf91b40_0066_02.jpg&quot; alt=&quot;串行&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不过一到 12 点高峰期上面那种排队方式就撑不住了，分分钟排队排到外面晒太阳，这时为了提高效率，因为快餐店还有一片空地，所以又加了一套打菜装备和员工，这时很好的解决了一条队伍太长的问题，这时就是&lt;strong&gt;并行&lt;/strong&gt;了，2 套打菜装备和员工各自互不干涉，完全独立，每套装备能够解决每个顾客的点菜需求。当然这要求比较高，需要餐厅有足够的空间可以放下两套装备，并且需要雇佣多一倍的员工来为顾客打菜，这里就类似计算机的双核。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.liebrother.com/upload/7118115a2bb840e0a2997da658ab408b_0066_03.jpg&quot; alt=&quot;并行&quot;/&gt;&lt;/p&gt;
&lt;p&gt;除了上面的两种快餐排队方式，还见过下面这种的，只有一套打菜装备，但是却有很多个队，每个菜排一条队（现实中其实不止一个菜，而是多个菜，这里画图就简化成一个菜），每个人就只需要排自己想吃的菜的队伍，这一道道菜就像计算机的各个资源，比如 CPU、IO 等等，人就像一个一个进程，有些只需要 CPU 计算资源，有些还要 IO 资源，各取所需，这种方式就是&lt;strong&gt;并发&lt;/strong&gt;。这种打菜方式和上面第一种所需要的资源是一样的：一套打菜装备和员工。每个顾客最终都需要走到结账这个步骤，而结账只有一个，也就是类似计算机的单核。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.liebrother.com/upload/6476d21d571e496b8d3edde6593e8f5a_0066_04.jpg&quot; alt=&quot;并发&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;那么回归到计算机世界，这三者是什么东西呢？早期计算机只有一个 CPU，也就是所谓的单核计算机，只有一个 CPU 去执行任务，所以只能是一个任务一个任务的跑，每个任务跑完才让下一个任务跑，也就是&lt;strong&gt;串行&lt;/strong&gt;的，后面因为进程和线程概念的提出与实现，它们使得任务以进程的方式运行，拆分成多个时间片运行，而不是一次运行执行完任务，这样子在一个 CPU 运行中可以有多个任务在&lt;strong&gt;并发&lt;/strong&gt;执行，这时还是只有一个 CPU，一个时间点只有一个任务在执行，而&lt;strong&gt;并行&lt;/strong&gt;是因为 CPU 硬件的发展，出现多核 CPU，所以实现了真正的同一时间点能有多个任务在执行。&lt;/p&gt;
&lt;p&gt;上面用快餐排队现象给大家解释了&lt;strong&gt;串行&lt;/strong&gt;、&lt;strong&gt;并行&lt;/strong&gt;、&lt;strong&gt;并发&lt;/strong&gt;这三个概念，大家理解了么？如果不理解可能是我讲得不够透彻，可以留言跟我提一提建议；如果理解了，可否帮忙转发一下，多谢啦！&lt;/p&gt;
&lt;p&gt;&lt;code&gt;推荐阅读&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/yWqFw_S7suYpqszuJFDsGg&quot;&gt;泡一杯茶，学一学同异步&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/HJIVxnzyDesYPGGyJsaFyQ&quot;&gt;进程知多少？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/WiPwb7AyVlxyr1_kYXt96w&quot;&gt;设计模式看了又忘，忘了又看？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;后台回复『设计模式』可以获取《一故事一设计模式》电子书&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;觉得文章有用帮忙转发&amp;amp;点赞，多谢朋友们！&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.liebrother.com/upload/c50a23a8826d45a7b66b3be24c89205e_.jpg&quot; alt=&quot;LieBrother&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 10 Jul 2019 00:34:00 +0000</pubDate>
<dc:creator>LieBrother</dc:creator>
<og:description>Java 多线程系列文章第 3 篇</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/liebrother/p/11161609.html</dc:identifier>
</item>
<item>
<title>C++屌屌的观察者模式-同步回调和异步回调 - 朝十晚八</title>
<link>http://www.cnblogs.com/swarmbees/p/11155072.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/swarmbees/p/11155072.html</guid>
<description>&lt;p&gt;&lt;strong&gt;原文链接：&lt;/strong&gt;&lt;a href=&quot;https://www.cnblogs.com/swarmbees/p/11155072.html&quot;&gt;C++屌屌的观察者模式-同步回调和异步回调&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;一概述&quot;&gt;一、概述&lt;/h2&gt;
&lt;p&gt;说起观察者模式，也是比较简单的一种模式了，稍微工作有1年经验的同学，写起来都是666...&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;想看观察者模式的说明可以直接上&lt;a href=&quot;https://www.runoob.com/design-pattern/observer-pattern.html&quot;&gt;菜鸟教程|观察者模式&lt;/a&gt;这个地址去看。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本篇文章其实就是一个简单的观察者模式，只是使用了模板的方式，把我们的回调接口进行了参数化，这样有什么好处呢？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;好处当然是大大的有了。&lt;/strong&gt; 平时我们在不同业务逻辑之间写观察者模式呢，都得写好多个，大家有没有发现，所有的被观察者Subject其实很多操作都是一样的。&lt;/p&gt;
&lt;p&gt;本篇我们带来两种观察者模式：&lt;strong&gt;同步观察者和异步观察者&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;同步观察者&quot;&gt;1、同步观察者&lt;/h3&gt;
&lt;p&gt;顾名思义，同步观察者其实就是不管是谁，触发了Subject的Update操作，该操作都是同步进行的，他会调用所有的观察者(Observer)的OnUpdate接口，来通知Observer处理改变操作。&lt;/p&gt;
&lt;p&gt;如效果展示图中的第一个&lt;code&gt;单次拉取&lt;/code&gt;页签，当我们点击拉取按钮时，就相当于触发了一次Subject对象的Update操作&lt;/p&gt;
&lt;h3 id=&quot;异步观察者&quot;&gt;2、异步观察者&lt;/h3&gt;
&lt;p&gt;异步观察者模式上和同步观察者基本一样，只是在事件处理上有稍微不同&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;执行Update操作是由Subject自己去完成的&lt;/li&gt;
&lt;li&gt;调用Observer的OnUpdate回调接口时，处于工作线程中&lt;/li&gt;
&lt;li&gt;Subject所有的请求操作都是在工作现场中进行&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;如效果图所示，&lt;code&gt;定时拉取&lt;/code&gt;观察者模式，Subject启动了一个后台线程，3秒钟拉取一次数据，并回调到界面&lt;/p&gt;
&lt;h2 id=&quot;二效果展示&quot;&gt;二、效果展示&lt;/h2&gt;
&lt;p&gt;如下图所示，是一个简单的观察者模式事例。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;单次拉取&lt;/code&gt;：演示了同步观察者模式&lt;/p&gt;
&lt;p&gt;&lt;code&gt;定时拉取&lt;/code&gt;：演示了异步观察者模式&lt;/p&gt;
&lt;center&gt;
&lt;div&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/swarmbees/1454266/o_subject_syn_asyn.gif&quot;/&gt;&lt;/div&gt;
&lt;/center&gt;
&lt;p&gt;工程结构如图所示，这里只把头文件的目录展示出来了。&lt;/p&gt;
&lt;p&gt;实现文件的目录和头文件类似，为了截图方便所以做了隐藏操作。&lt;/p&gt;
&lt;center&gt;
&lt;div&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/swarmbees/1454266/o_subject_project.png&quot;/&gt;&lt;/div&gt;
&lt;/center&gt;
&lt;p&gt;Header Files目录下有2个虚拟文件夹，分别就是对&lt;code&gt;单次拉取&lt;/code&gt;和&lt;code&gt;定时拉取&lt;/code&gt;功能的实践&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;下面我们就来正式开始讲解这个屌屌的观察者模式&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;三同步观察者&quot;&gt;三、同步观察者&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1、首先就是定义一堆接口和回调参数&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;struct DataItem
{
    std::string     strID;  
    std::string     strName;        
};

typedef IUpdate1&amp;lt;DataItem&amp;gt;          ISignalObserver;

//单次回调
struct ISignal : public SubjectBase&amp;lt;ISignalObserver&amp;gt;
{
    virtual void RequestData() = 0;
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2、业务观察者&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里我定义了一个SignalResponse业务观察者，也就是我们在开发工程中的实际功能类。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class SignalResponse : public ISignal
{
public:
    SignalResponse();
    ~SignalResponse();

public:
    virtual void RequestData() override;

private:
    
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;*3、获取观察者指针**&lt;/p&gt;
&lt;p&gt;通过一个门面接口获取观察者指针&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;调用ISignal的Attach接口，就可以把自己添加到观察者列表。&lt;/li&gt;
&lt;li&gt;调用ISignal的RequestData接口，就可以拉取数据。&lt;/li&gt;
&lt;li&gt;调用ISignal的Detach接口，就可以把自己从观察者列表中移除。&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;ISignal * GetSignalCommon();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;4、UI界面&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;接下来就是写一个UI界面啦，当我们通过上一步调用拉取数据接口后，我们的UI上相应的OnUpdate接口就会被回调&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class SignalWidget : public QWidget, public ISignalObserver
{
    Q_OBJECT

public:
    SignalWidget(QWidget * parent = 0);
    ~SignalWidget();

protected:
    virtual void OnUpdate(const DataItem &amp;amp;) override;

private slots:
    void on_pushButton_clicked();

private:
    Ui::SignalWidget *ui;
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;通过以上四步，就可以很方便的实现一个现在业务中的观察者，是不是很简单呢&lt;/strong&gt;，编写过程中，需要完成这几个地方&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;需要定义我们回调函数的参数结构&lt;/li&gt;
&lt;li&gt;需要实例化一个被观察者接口类&lt;/li&gt;
&lt;li&gt;实例化一个业务观察者&lt;/li&gt;
&lt;li&gt;做一个UI界面，并集成第二步实例化的被观察者的模板参数(接口类)&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;注意看这里的ISignalObserver，是不是很眼熟，其实他就是我们的模板被观察者SubjectBase的模板参数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;讲到这里，大家是不是都很关心这个模板观察者到底是何方神圣，居然这么叼。那么接下来就是模板SubjectBase出场啦。。。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面我直接给出代码，学过C++的同学阅读起来应该都不难。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;觉着难了就多读几遍&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;template &amp;lt;typename T&amp;gt;
struct ISubject
{
    virtual void Attach(T * pObserver) = 0;
    virtual void Detach(T * pObserver) = 0;
};

template &amp;lt;typename P&amp;gt;
struct IUpdate1
{
    virtual void OnUpdate(const P&amp;amp; data) = 0;
};

template &amp;lt;typename P1, typename P2&amp;gt;
struct IUpdate2
{
    virtual void OnUpdate2(const P1 &amp;amp; p1, const P2 &amp;amp; p2) = 0;
};

template &amp;lt;typename P&amp;gt;
struct IUpdate1_P
{
    virtual void OnUpdate(const P * data) = 0;
};

template &amp;lt;typename T&amp;gt;
struct SubjectBase
{
public:
    virtual void Attach(T * pObserver)
    {
        std::lock_guard&amp;lt;std::mutex&amp;gt; lg(m_mutex);
#ifdef _DEBUG
        if (m_observers.end() != std::find(m_observers.begin(), m_observers.end(), pObserver))
        {
            assert(false);
        }
#endif // _DEBUG
        m_observers.push_back(pObserver);
    }

    virtual void Detach(T * pObserver)
    {
        std::lock_guard&amp;lt;std::mutex&amp;gt; lg(m_mutex);
        auto it = std::find(m_observers.begin(), m_observers.end(), pObserver);
        if (it != m_observers.end())
        {
            m_observers.erase(it);
        }
        else
        {
            assert(false);
        }
    }

    //protected:
    template &amp;lt;typename P&amp;gt;
    void UpdateImpl(const P &amp;amp; data)
    {
        std::lock_guard&amp;lt;mutex&amp;gt; lg(m_mutex);
        for (T * observer : m_observers)
        {
            observer-&amp;gt;OnUpdate(data);
        }
    }

    template &amp;lt;typename P&amp;gt;
    void UpdateImpl(P &amp;amp; data)
    {
        std::lock_guard&amp;lt;std::mutex&amp;gt; lg(m_mutex);
        for (T* observer : m_observers)
        {
            observer-&amp;gt;OnUpdate(data);
        }
    }

    template &amp;lt;typename P1, typename P2&amp;gt;
    void UpdateImpl(const P1&amp;amp; p1, const P2&amp;amp; p2)
    {
        std::lock_guard&amp;lt;mutex&amp;gt; lg(m_mutex);
        for (T* observer : m_observers)
        {
            observer-&amp;gt;OnUpdate2(p1, p2);
        }
    }

    template &amp;lt;typename P1, typename P2&amp;gt;
    void UpdateImpl(P1&amp;amp; p1, P2&amp;amp; p2)
    {
        std::lock_guard&amp;lt;mutex&amp;gt; lg(m_mutex);
        for (T* observer : m_observers)
        {
            observer-&amp;gt;OnUpdate2(p1, p2);
        }
    }

    template &amp;lt;typename P&amp;gt;
    void UpdateImpl(const P * data)
    {
        std::lock_guard&amp;lt;mutex&amp;gt; lg(m_mutex);
        for (T * observer : m_observers)
        {
            observer-&amp;gt;OnUpdate(data);
        }
    }

    template &amp;lt;typename P&amp;gt;
    void UpdateImpl(P * data)
    {
        std::lock_guard&amp;lt;mutex&amp;gt; lg(m_mutex);
        for (T* observer : m_observers)
        {
            observer-&amp;gt;OnUpdate(data);
        }
    }

protected:
    std::mutex      m_mutex;
    std::list&amp;lt;T *&amp;gt;  m_observers;
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;四异步观察者&quot;&gt;四、异步观察者&lt;/h2&gt;
&lt;p&gt;异步观察者的实现和同步观察者的结构基本一样，都是使用同样的套路，唯一有区别的地方就是，异步观察者所有的逻辑处理操作都是在工作线程中的。&lt;/p&gt;
&lt;p&gt;由于ITimerSubject和SubjectBase很多接口都是一样的，因此我这里就只把差异的部分贴出来。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、线程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ITimerSubject对象在构造时，就启动了一个线程，然后在线程中定时执行TimerNotify函数&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ITimerSubject()
{
    m_thread = std::thread(std::bind(&amp;amp;ITimerSubject::TimerNotify, this));
}

virtual ~ITimerSubject()
{
    m_thread.join();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再来看下定时处理任务这个函数，这个函数本身是用boost的库实现我的，我改成C++11的模式的，新城退出这块有些问题，我没有处理，这个也不是本篇文章的核心要讲解的东西。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;怎么优雅的退出std::thread，这个从网上查下资料吧，我能想到的也就是加一个标识，然后子线程去判断。如果大家有更好的办法的话可以私信我，或者在底部留言。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;void TimerNotify()
{
    for (;;)
    {
        //std::this_thread::interruption_point();

        bool bNotify = false;
        {
            std::lock_guard&amp;lt;std::mutex&amp;gt; lg(m_mutex);
            bNotify = m_sleeping_observers.size() &amp;lt; m_observers.size() ? true : false;
        }

        if (bNotify)
        {
            OnTimerNotify();
        }

        //std::this_thread::interruption_point();

        std::chrono::milliseconds timespan(GetTimerInterval() * 1000); // or whatever
        std::this_thread::sleep_for(timespan);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2、定义一堆接口和回调参数&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;struct TimerDataItem
{
    std::string     strID;
    std::string     strName;
};

typedef IUpdate1&amp;lt;TimerDataItem&amp;gt;     ITimerObserver;

//定时回调
struct ITimer : public ITimerSubject&amp;lt;ITimerObserver, std::string, TimerDataItem&amp;gt;{};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;3、业务观察者&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里我定义了一个TimerResponse业务观察者，也就是我们在开发工程中的实际功能类。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class TimerResponse : public ITimer
{
public:
    TimerResponse();
    ~TimerResponse();

protected:
    virtual void OnNotify() override;

private:
    
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;TimerResponse::OnNotify()这个接口的实现就像这样，&lt;strong&gt;这里需要注意的一点是，这个函数的执行位于工作线程中，也就意味着UI界面的回调函数也在工作线程中，操作UI界面时，一定需要抛事件到UI线程中。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void TimerResponse::OnNotify()
{
    static int id = 0;
    static std::string name = &quot;miki&quot;;
    id += 1;
    TimerDataItem item;

    std::stringstream ss;
    ss &amp;lt;&amp;lt; &quot;timer&quot; &amp;lt;&amp;lt; id;

    item.strID = ss.str();
    item.strName = name;

    UpdateImpl(item);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;OnNotify会定时被调用，然后去更新UI上的内容。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4、获取观察者指针&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过一个门面接口获取观察者指针，调用ITimer的Attach接口把自己添加到观察者列表，然后就可以定时获取到数据，反之也能把自己从观察者列表中移除，并停止接收到数据。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ITimer * GetTimerCommon();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;5、UI界面&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;定时回调功能测试界面&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;on_pushButton_clicked槽函数只是为了把当前线程唤醒，并定时回调&lt;/li&gt;
&lt;li&gt;OnUpdate属于定时回调接口&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;class TimerWidget : public QWidget, public ITimerObserver
{
    Q_OBJECT

public:
    TimerWidget(QWidget *parent = 0);
    ~TimerWidget();

protected:
    virtual void OnUpdate(const TimerDataItem &amp;amp;) override;

private slots:
    void on_pushButton_clicked();

signals:
    void RerfushData(TimerDataItem);

private:
    Ui::TimerWidget *ui;
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上边也强调过了，OnUpdate的执行是在工作线程中的，因此实现的时候，如果涉及到访问UI界面，一定要注意切换线程&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void TimerWidget::OnUpdate(const TimerDataItem &amp;amp; item)
{
    //注意这里的定时回调都在工作线程中 需要切换到主线程

    emit RerfushData(item);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;以上讲解就是我们观察者的实现了，如果有疑问欢迎提出&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;五相关文章&quot;&gt;五、相关文章&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.runoob.com/design-pattern/observer-pattern.html&quot;&gt;菜鸟教程|观察者模式&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;如果您觉得文章不错，不妨给个&lt;span&gt;打赏&lt;/span&gt;，写作不易，感谢各位的支持。您的支持是我最大的动力，谢谢！！！&lt;br/&gt;&lt;/p&gt;
&lt;br/&gt;&lt;center&gt;&lt;br/&gt;&lt;div&gt;&lt;table&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/swarmbees/1497876/o_weixin_reward.png&quot; border=&quot;0&quot;/&gt;&lt;/td&gt;
&lt;td&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/swarmbees/1497876/o_zhifubao_reward.png&quot; border=&quot;0&quot;/&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;&lt;br/&gt;&lt;/div&gt;
&lt;br/&gt;&lt;/center&gt;
&lt;br/&gt;&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;很重要--转载声明&lt;/strong&gt;&lt;/p&gt;
&lt;ol readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;本站文章无特别说明，皆为原创，版权所有，转载时请用链接的方式，给出原文出处。同时写上原作者：&lt;a href=&quot;https://www.cnblogs.com/swarmbees/&quot;&gt;朝十晚八&lt;/a&gt; or &lt;a href=&quot;https://www.jianshu.com/u/7673f8cfb4e6&quot;&gt;Twowords&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如要转载，请原文转载，如在转载时修改本文，请事先告知，谢绝在转载时通过修改本文达到有利于转载者的目的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;hr/&gt;</description>
<pubDate>Tue, 09 Jul 2019 23:47:00 +0000</pubDate>
<dc:creator>朝十晚八</dc:creator>
<og:description>[TOC] 原文链接： 'C++屌屌的观察者模式 同步回调和异步回调' 一、概述 说起观察者模式，也是比较简单的一种模式了，稍微工作有1年经验的同学，写起来都是666... 想看观察者模式的说明可以直</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/swarmbees/p/11155072.html</dc:identifier>
</item>
<item>
<title>Effective Java - 构造器私有、枚举和单例 - c旋儿</title>
<link>http://www.cnblogs.com/cxuanBlog/p/11161524.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cxuanBlog/p/11161524.html</guid>
<description>&lt;p&gt;Singleton 是指仅仅被实例化一次的类。Singleton代表了无状态的对象像是方法或者本质上是唯一的系统组件。使类称为Singleton 会使它的客户端测试变得十分困难。因为不可能给Singleton替换模拟实现。除非实现一个充当其类型的接口&lt;/p&gt;
&lt;h2 id=&quot;饿汉式单例&quot;&gt;饿汉式单例&lt;/h2&gt;
&lt;h3 id=&quot;静态常量&quot;&gt;静态常量&lt;/h3&gt;
&lt;p&gt;下面有两种方法实现一个单例，两者都基于保持构造器私有并且导出一个公有的静态成员提供一个唯访问该实例的入口。在第一种方法中，这个成员的属性是&lt;code&gt;final&lt;/code&gt;的&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 提供属性是公有的、唯一的单例
public class Elvis {
  public static final Elvis INSTANCE = new Elvis();
  private Elvis();
  
  public void leaveTheBuilding();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是一个饿汉式的实现。这个私有的构造器仅仅被调用一次，因为Elvis 是 &lt;code&gt;static final&lt;/code&gt;的，所以&lt;code&gt;INSTANCE&lt;/code&gt;是一个常量，编译期间进行初始化，并且值只能被初始化一次，致使&lt;code&gt;INSTANCE&lt;/code&gt;不能再指向任意其他的对象，没有任何客户端能够改变这个结果。但是需要注意一点：有特权的客户端能够使用反射中的&lt;code&gt;AccessibleObject.setAccessible&lt;/code&gt;访问私有的构造器。为了防御这种攻击，把构造器修改为在第二次实例化的时候抛出异常。见如下的例子&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Elvis {

    static boolean flag = false;
    private Elvis(){
        if(flag == false) {
            flag = !flag;
        }
        else {
            throw new RuntimeException(&quot;单例模式被侵犯！&quot;);
        }
    }

    public static class SingletonHolder {
        private static final Elvis INSTANCE = new Elvis();
    }

    public static Elvis getInstance(){
        return SingletonHolder.INSTANCE;
    }

    public static void main(String[] args) throws Exception {
        Class&amp;lt;Elvis&amp;gt; el = Elvis.class;
        // 获得无参数私有的构造器
        Constructor&amp;lt;Elvis&amp;gt; constructor = el.getDeclaredConstructor();
        // 暴力破解private 私有化
        constructor.setAccessible(true);
        // 生成新的实例
        Elvis elvis = constructor.newInstance();
        Elvis instance = Elvis.getInstance();
        System.out.println(elvis == instance);

    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Exception in thread &quot;main&quot; java.lang.ExceptionInInitializerError
    at effectiveJava.effective03.Elvis.getInstance(Elvis.java:22)
    at effectiveJava.effective03.Elvis.main(Elvis.java:33)
Caused by: java.lang.RuntimeException: 单例模式被侵犯！
    at effectiveJava.effective03.Elvis.&amp;lt;init&amp;gt;(Elvis.java:13)
    at effectiveJava.effective03.Elvis.&amp;lt;init&amp;gt;(Elvis.java:5)
    at effectiveJava.effective03.Elvis$SingletonHolder.&amp;lt;clinit&amp;gt;(Elvis.java:18)
    ... 2 more&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注释掉利用反射获取私有构造函数的代码，发现instance实例可以正常输出&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Elvis instance = Elvis.getInstance();
System.out.println(instance);&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;console: effectiveJava.effective03.Elvis@266474c2&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在实现Singleton 的第二种方法中，公有的成员是个静态方法&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class ElvisSingleton {

    private static final ElvisSingleton INSTANCE = new ElvisSingleton();
    private ElvisSingleton(){}
    public static ElvisSingleton newInstance(){
        return INSTANCE;
    }
    public void leaveBuilding(){}
    
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于静态方法&lt;code&gt;newInstance&lt;/code&gt;来说所有的调用，都会返回一个INSTANCE对象，所以，永远不会创建其他&lt;code&gt;ElvisSingleton&lt;/code&gt;实例&lt;/p&gt;
&lt;p&gt;公有属性最大的优势在于能够很清楚的描述类是单例的：公有的属性是final的，所以总是能够包含相同的对象引用。第二个优势就是就是比较简单。&lt;/p&gt;
&lt;h3 id=&quot;静态代码块&quot;&gt;静态代码块&lt;/h3&gt;
&lt;p&gt;静态代码块是静态常量的变种，就是把静态常量的初始化放在了静态代码块中解析，初始化。读者可能对这种方式产生疑惑，请详见&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;类加载机制 https://blog.csdn.net/ns_code/article/details/17881581&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class ElvisStaticBlock {

    private static final ElvisStaticBlock block;
    static {
        block = new ElvisStaticBlock();
    }

    private ElvisStaticBlock(){}
    public static ElvisStaticBlock newInstance(){
        return block;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;优点：这种写法比较简单，就是在类装载的时候就完成实例化。避免了线程同步问题。&lt;/p&gt;
&lt;p&gt;缺点：在类装载的时候就完成实例化，没有达到Lazy Loading的效果。如果从始至终从未使用过这个实例，则会造成内存的浪费。&lt;/p&gt;
&lt;h2 id=&quot;懒汉式单例&quot;&gt;懒汉式单例&lt;/h2&gt;
&lt;p&gt;与饿汉式对应的就是懒汉式，这两者都是属于单例模式的应用，懒汉式含有一层懒加载(lazy loading)的概念，也叫做惰性初始化。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class ElvisLazyLoading {

    private static ElvisLazyLoading instance;
    private ElvisLazyLoading(){}

    public static ElvisLazyLoading newInstance(){
        if(instance == null){
            instance = new ElvisLazyLoading();
        }
        return instance;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;初始的时候不会对INSTANCE进行初始化，它的默认值是null，在调用&lt;code&gt;newInstance&lt;/code&gt;方法时会判断，若INSTANCE为null，则会把INSTANCE的引用指向ElvisLazyLoading的构造方法。&lt;/p&gt;
&lt;p&gt;这种方式能够实现一个懒加载的思想，但是&lt;strong&gt;这种写法会存在并发问题&lt;/strong&gt;，由于多线程各自运行自己的执行路径，当同时执行到 INSTANCE = new ElvisLazyLoading() 代码时，各自的线程都认为自己应该创建一个新的ElvisLazyLoading对象，所以最后的结果可能会存在多个ElvisLazyLoading 实例，所以这种方式不推荐使用&lt;/p&gt;
&lt;h3 id=&quot;尝试加锁&quot;&gt;尝试加锁&lt;/h3&gt;
&lt;p&gt;很显然的，可以尝试对&lt;code&gt;newInstance()&lt;/code&gt;方法加锁来避免产生并发问题，但是这种方式不可能，由&lt;code&gt;synchronized&lt;/code&gt;加锁会导致整个方法开销太大，在遇见类似问题时，应该尝试换一种方式来解决，而不应该只通过简单粗暴的加锁来解决一切并发问题。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public synchronized static ElvisLazyLoading newInstance(){
  if(INSTANCE == null){
    INSTANCE = new ElvisLazyLoading();
  }
  return INSTANCE;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;同步代码块&quot;&gt;同步代码块&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;synchronized&lt;/code&gt;关键字不仅可以锁住方法的执行，也可以对方法中的某一块代码进行锁定，也叫做同步代码块&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Singleton {

    private static Singleton instance;

    private Singleton() {}

    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                instance = new Singleton();
            }
        }
        return instance;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不要觉得只要加锁了，就不会存在线程安全问题，线程是Java中很重要的一个课题，需要细细研究。这种同步代码块的方式也会存在线程安全问题，当多个线程同时判断自己的singleton 实例为null的时候，同样会创建多个实例。&lt;/p&gt;
&lt;h3 id=&quot;双重检查&quot;&gt;双重检查&lt;/h3&gt;
&lt;p&gt;Double-Check概念对于多线程开发者来说不会陌生，如代码中所示，我们进行了两次if (instance == null)检查，这样就可以保证线程安全了。这样，实例化代码只用执行一次，后面再次访问时，判断if (instance == null)，直接return实例化对象。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class ElvisDoubleCheck {

    private static volatile ElvisDoubleCheck instance;
    private ElvisDoubleCheck(){}

    public static ElvisDoubleCheck newInstance(){
        if(instance == null){
            synchronized (ElvisDoubleCheck.class){
                if (instance == null){
                    instance = new ElvisDoubleCheck();
                }
            }
        }
        return instance;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;优点：线程安全；延迟加载；效率较高。&lt;/p&gt;
&lt;h2 id=&quot;静态内部类单例&quot;&gt;静态内部类单例&lt;/h2&gt;
&lt;p&gt;静态内部类的单例与饿汉式采用的机制类似，但又有不同。两者都是采用了类装载的机制来保证初始化实例时只有一个线程。不同的地方在饿汉式方式是只要Elvis类被装载就会实例化，没有Lazy-Loading的作用，而静态内部类方式在ElvisStaticInnerClass类被装载时并不会立即实例化，而是在需要实例化时，调用newInstance方法，才会装载SingletonInstance类，从而完成ElvisStaticInnerClass的实例化。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class ElvisStaticInnerClass {

    private ElvisStaticInnerClass(){}

    private static class SingletonInstance{
        private static final ElvisStaticInnerClass instance = new ElvisStaticInnerClass();
    }

    public static ElvisStaticInnerClass newInstance(){
        return SingletonInstance.instance;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;优点：避免了线程不安全，延迟加载，效率高。&lt;/p&gt;
&lt;h2 id=&quot;枚举单例&quot;&gt;枚举单例&lt;/h2&gt;
&lt;p&gt;实现Singleton的第四种方法是声明一个包含单个元素的枚举类型&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public enum  ElvisEnum {

    INSTANCE;

    public void leaveTheBuilding(){}
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种方法在功能上与公有域方法相似，但更加简洁。无偿地提供了序列化机制，有效防止多次实例化，即使在面对复杂的序列化或者反射攻击的时候。&lt;strong&gt;单元素的枚举类型经常成为实现Singleton的最佳方法&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;: 系统内存中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;：当想实例化一个单例类的时候，必须要记住使用相应的获取对象的方法，而不是使用new，可能会给其他开发人员造成困扰，特别是看不到源码的时候。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;后记&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;看完本文，你是否对&lt;strong&gt;构造器私有、枚举和单例&lt;/strong&gt;这个主题有了新的认知呢？&lt;/p&gt;
&lt;p&gt;你至少应该了解：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;单例模式的几种写法及其优缺点分析&lt;/li&gt;
&lt;li&gt;为什么反射能够对私有构造器产生破坏？&lt;/li&gt;
&lt;li&gt;有哪几种比较好用的线程安全的单例模式？&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;公众号提供 优质Java资料 以及CSDN免费下载 权限，欢迎你关注我&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1515111/201907/1515111-20190710064903477-1847811093.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;p&gt;如何防止单例模式被JAVA反射攻击 https://blog.csdn.net/u013256816/article/details/50525335&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/zhaoyan001/p/6365064.html&quot;&gt;单例模式的八种写法比较&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;《Effective Java》&lt;/p&gt;
</description>
<pubDate>Tue, 09 Jul 2019 22:49:00 +0000</pubDate>
<dc:creator>c旋儿</dc:creator>
<og:description>[TOC] Singleton 是指仅仅被实例化一次的类。Singleton代表了无状态的对象像是方法或者本质上是唯一的系统组件。使类称为Singleton 会使它的客户端测试变得十分困难。因为不可能</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cxuanBlog/p/11161524.html</dc:identifier>
</item>
<item>
<title>我已经理解了并发和并行的区别 - 骏马金龙</title>
<link>http://www.cnblogs.com/f-ck-need-u/p/11161481.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/f-ck-need-u/p/11161481.html</guid>
<description>&lt;h2 id=&quot;理解并发并行的例子&quot;&gt;理解并发、并行的例子&lt;/h2&gt;
&lt;p&gt;先举例子来理解这2个概念的区别。&lt;/p&gt;
&lt;p&gt;老师让两个同学去办公室谈话。如果这两同学(进程)是并列跨过办公室门(CPU)的，那么就是并行。如果同学A先进同学B后进入(或者先B后A)，或者两人并列同时进入，但是在办公室外的路人甲(用户)看来，同学A和同学B同时都在办公室内，这是并发。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733013/201907/733013-20190710015617536-1379934859.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其实这个例子不合理，因为真正的并行是多核CPU下的概念，但上面这个简单的例子非常有助于理解。&lt;/p&gt;
&lt;p&gt;如果举例要精确一点，那么大概是这样的：进办公室有两个门(两CPU)，如果两同学分别从不同的门进入，不管先后性，两者互相独立，那么是并行；如果两同学不管以什么方式进入，在路人甲看来，他两同时都在办公室内，就是并发。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733013/201907/733013-20190710015852294-1375692973.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我不信到现在还不理解并发和并行。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733013/201907/733013-20190710014242808-1692789002.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;并发和并行的理论性解释&quot;&gt;并发和并行的理论性解释&lt;/h2&gt;
&lt;p&gt;为什么操作系统上可以同时运行多个程序而用户感觉不出来？&lt;/p&gt;
&lt;p&gt;这是因为无论是单CPU还是多CPU，操作系统都营造出了可以同时运行多个程序的&lt;strong&gt;假象&lt;/strong&gt;。实际的过程操作系统对进程的调度以及CPU的快速上下文切换实现的：&lt;strong&gt;每个进程执行一会就先停下来，然后CPU切换到下个被操作系统调度到的进程上使之运行&lt;/strong&gt;。因为切换的很快，使得用户认为操作系统一直在服务自己的程序。&lt;/p&gt;
&lt;p&gt;再来解释并发就容易理解多了。&lt;/p&gt;
&lt;p&gt;并发(concurrent)指的是多个程序可以同时运行的现象，更细化的是多进程可以同时运行或者多指令可以同时运行。但这不是重点，在描述并发的时候也不会去扣这种字眼是否精确，并发的重点在于它是一种现象。并发描述的是多进程同时运行的现象。但实际上，对于单核心CPU来说，同一时刻只能运行一个进程。所以，这里的&quot;同时运行&quot;表示的不是真的同一时刻有多个进程运行的现象，这是并行的概念，而是提供一种功能让用户看来多个程序同时运行起来了，但实际上这些程序中的进程不是一直霸占CPU的，而是执行一会停一会。&lt;/p&gt;
&lt;p&gt;所以，并发和并行的区别就很明显了。&lt;strong&gt;它们虽然都说是&quot;多个进程同时运行&quot;，但是它们的&quot;同时&quot;不是一个概念。并行的&quot;同时&quot;是同一时刻可以多个进程在运行(处于running)，并发的&quot;同时&quot;是经过上下文快速切换，使得看上去多个进程同时都在运行的现象，是一种OS欺骗用户的现象&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;再次注明，并发是一种现象，之所以能有这种现象的存在，和CPU的多少无关，而是和进程调度以及上下文切换有关的。&lt;/p&gt;
&lt;p&gt;理解了概念，再来深入扩展下。&lt;/p&gt;
&lt;h2 id=&quot;串行并行和并发&quot;&gt;串行、并行和并发&lt;/h2&gt;
&lt;h3 id=&quot;任务描述&quot;&gt;任务描述&lt;/h3&gt;
&lt;p&gt;如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733013/201907/733013-20190706105556726-1105878314.png&quot; alt=&quot;1559104246414&quot;/&gt;&lt;/p&gt;
&lt;p&gt;任务是将左边的一堆柴全部搬到右边烧掉，每个任务包括三个过程：取柴，运柴，放柴烧火。&lt;/p&gt;
&lt;p&gt;这三个过程分别对应一个函数：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func get { geting }
func carry { carrying }
func unload { unloading }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;串行模式&quot;&gt;串行模式&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;串行表示所有任务都一一按先后顺序进行。串行意味着必须先装完一车柴才能运送这车柴，只有运送到了，才能卸下这车柴，并且只有完成了这整个三个步骤，才能进行下一个步骤&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;和稍后所解释的并行相对比，&lt;strong&gt;串行是一次只能取得一个任务，并执行这个任务&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;假设这堆柴需要运送4次才能运完，那么当写下的代码类似于下面这种时，那么就是串行非并发的模式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;for(i=0;i&amp;lt;4;i++){
    get()
    carry()
    unload()
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或者，将三个过程的代码全部集中到一个函数中也是如此：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func task {
    geting
    carrying
    unloading
}

for(i=0;i&amp;lt;4;i++){
    task()
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这两种都是串行的代码模式。画图描述：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733013/201907/733013-20190706105550462-1158974849.png&quot; alt=&quot;1559105891580&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;并行模式&quot;&gt;并行模式&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;并行意味着可以同时取得多个任务，并同时去执行所取得的这些任务。并行模式相当于将长长的一条队列，划分成了多条短队列，所以并行缩短了任务队列的长度&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;正如前面所举的两同学进办公室的例子，串行的方式下，必须1个同学进入后第二个同学才进入，队列长度为2，而并行方式下可以同时进入，队列长度减半了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;并行的效率从代码层次上强依赖于多进程/多线程代码，从硬件角度上则依赖于多核CPU&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;对于单进程/单线程，由于只有一个进程/线程在执行，所以尽管同时执行所取得的多个任务，但实际上这个进程/线程是不断的在多任务之间切换，一会执行一下这个，一会执行一下那个，就像是一个人在不同地方之间来回奔波。所以，单进程/线程的并行，效率比串行更低。&lt;/p&gt;
&lt;p&gt;对于多进程/多线程，各进程/线程都可以执行各自所取得的任务，这是真正的并行。&lt;/p&gt;
&lt;p&gt;但是，还需要考虑硬件层次上CPU核心数，如果只有单核CPU，那么在硬件角度上这单核CPU一次也只能执行一个任务，上面多进程/多线程的并行也并非真正意义上的并行。只有多核CPU，并且多进程/多线程并行，才是真正意义上的并行。&lt;/p&gt;
&lt;p&gt;如下图，是多进程/多线程(2个工作者)的并行：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733013/201907/733013-20190706105539909-1099998886.png&quot; alt=&quot;1559106284586&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;并发&quot;&gt;并发&lt;/h3&gt;
&lt;p&gt;并发表示多个任务同时都要执行的现象，更详细的概念前面已经说面的够具体了。&lt;/p&gt;
&lt;p&gt;其实，很多场景下都会使用并发的概念。比如同时500个http请求涌向了web服务器，比如有时候说并发数是1000等。&lt;/p&gt;
&lt;p&gt;有时候也将并发当成任务，比如500并发数意味着500个任务，表示的是在一个特定的时间段内(约定俗成的大家认为是1秒)可以完成500个任务。这500个任务可以是单进程/单线程方式处理的，这时表示的是并发不并行的模式(coroutine就是典型的并发不并行)，即先执行完一个任务后才执行另一个任务，也可以是多进程/多线程方式处理的，这时表示的是并发且并行模式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;要解决大并发问题，通常是将大任务分解成多个小任务&lt;/strong&gt;。很典型的一个例子是处理客户端的请求任务，这个大任务里面包含了监听并建立客户端的连接、处理客户端的请求、响应客户端。但基本上所有这类程序，都将这3部分任务分开了：在执行任何一个小任务的时候，都可以通过一些手段使得可以执行其它小任务，比如在处理请求的时候，可以继续保持监听状态。&lt;/p&gt;
&lt;p&gt;由于操作系统对进程的调度是随机的，所以切分成多个小任务后，可能会从任一小任务处执行。这可能会出现一些现象：&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;可能出现一个小任务执行了多次，还没开始下个任务的情况。这时一般会采用队列或类似的数据结构来存放各个小任务的成果&lt;/strong&gt;。比如负责监听的进程已经执行了多次，建立了多个连接，但是还没有调度到处理请求的进程去处理任何一个请求。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可能出现还没准备好第一步就执行第二步的可能。这时，一般采用多路复用或异步的方式，比如只有准备好产生了事件通知才执行某个任务&lt;/strong&gt;。比如还没有和任何一个客户端建立连接时，就去执行了处理请求的进程。&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;可以多进程/多线程的方式并行执行这些小任务。也可以单进程/单线程执行这些小任务，这时很可能要配合多路复用才能达到较高的效率&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;看图非常容易理解：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733013/201907/733013-20190706105534243-1252460335.png&quot; alt=&quot;1559106934889&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图中将一个任务中的三个步骤取柴、运柴、卸柴划分成了独立的小任务，有取柴的老鼠，有运柴的老鼠，有卸柴烧火的老鼠。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果上图中所有的老鼠都是同一只，那么是串行并发的，如果是不同的多只老鼠，那么是并行并发的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733013/201907/733013-20190710014312939-1512504434.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;并行和串行：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;串行：一次只能取得一个任务并执行这一个任务&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;并行：可以同时通过多进程/多线程的方式取得多个任务，并以多进程或多线程的方式同时执行这些任务&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;注意点：
&lt;ul&gt;&lt;li&gt;如果是单进程/单线程的并行，那么效率比串行更差&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;如果只有单核cpu，多进程并行并没有提高效率&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;从任务队列上看，由于同时从队列中取得多个任务并执行，相当于将一个长任务队列变成了短队列&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;并发：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;并发是一种现象：同时运行多个程序或多个任务需要被处理的现象&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;这些任务可能是并行执行的，也可能是串行执行的，和CPU核心数无关，是操作系统进程调度和CPU上下文切换达到的结果&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;解决大并发的一个思路是将大任务分解成多个小任务：
&lt;ul&gt;&lt;li&gt;可能要使用一些数据结构来避免切分成多个小任务带来的问题&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;可以多进程/多线程并行的方式去执行这些小任务达到高效率&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;或者以单进程/单线程配合多路复用执行这些小任务来达到高效率&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Tue, 09 Jul 2019 17:43:00 +0000</pubDate>
<dc:creator>骏马金龙</dc:creator>
<og:description>理解并发、并行的例子 先举例子来理解这2个概念的区别。 老师让两个同学去办公室谈话。如果这两同学(进程)是并列跨过办公室门(CPU)的，那么就是并行。如果同学A先进同学B后进入(或者先B后A)，或者两</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/f-ck-need-u/p/11161481.html</dc:identifier>
</item>
<item>
<title>利用MAT分析JVM内存问题，从入门到精通（二） - javaadu</title>
<link>http://www.cnblogs.com/javaadu/p/11161380.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/javaadu/p/11161380.html</guid>
<description>&lt;p&gt;上一篇文章&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzIwMjA3MDE3MQ==&amp;amp;mid=2650737493&amp;amp;idx=1&amp;amp;sn=02ecb97bbfea07b3ea3b3402b3515f97&amp;amp;chksm=8eefeaa1b99863b78c996ecd4449825e3515abff15b1af1003bafe8c156fca9656c56d4ceae2&amp;amp;scene=21#wechat_redirect&quot;&gt;MAT入门到精通（一）&lt;/a&gt;介绍了MAT的使用场景和基本概念，这篇文章开始介绍MAT的基本功能，后面还有两篇，一篇是MAT的高级功能，另一篇是MAT实战案例分析。&lt;/p&gt;
&lt;h2 id=&quot;三欢迎页&quot;&gt;三、欢迎页&lt;/h2&gt;
&lt;p&gt;使用MAT打开一个heap dump文件，解析完成后，默认会进入欢迎页，欢迎页里包含了一些常见的分析：最大内存占用分析、常见的分析动作、常用的分析报告、MAT使用教程等等。&lt;/p&gt;
&lt;p&gt;我们看下下面这张图，可以看出MAT的主要结构和功能：&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/44770-6e2c5bd2946472f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;MAT的窗口布局&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;inspector：透视图，用于展示一个对象的详细信息，例如内存地址、加载器名称、包名、对象名称、对象所属的类的父类、对象所属的类的加载器对象、该对象的堆内存大小和保留大小，gc root信息。&lt;/li&gt;
&lt;li&gt;inspector窗口的下半部分是展示类的静态属性和值、对象的实例属性和值、对象所属的类的继承结构。&lt;/li&gt;
&lt;li&gt;Heap Dump History：用于列举最近分析过的文件&lt;/li&gt;
&lt;li&gt;常用功能栏，从左到右依次是：概览、类直方图、支配树、OQL查询、线程视图、报告相关、详细功能。其中概览就是在刚解析完后展示的这个页面，详细功能按钮则是提供了一些更细致的分析能力。&lt;/li&gt;
&lt;li&gt;概览中的饼图：该饼图用于展示retained size最大的对象&lt;/li&gt;
&lt;li&gt;常用的分析动作：类直方图、支配树、按照类和包路径获取消耗资源最多的对象、重名类。&lt;/li&gt;
&lt;li&gt;报告相关：Leak Suspects用于查找内存泄漏问题，以及系统概览&lt;/li&gt;
&lt;li&gt;Components Report：这个功能是一组功能的集合，用于分析某一类性的类的实例的问题，例如分析&lt;code&gt;java.util.*&lt;/code&gt;开头的类的实例对象的一些使用情况，例如：重复字符串、空集合、集合的使用率、软引用的统计、finalizer的统计、Map集合的碰撞率等等。&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/44770-f1eb9c87cf860cee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Component Report的功能&quot;/&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;四基本功能&quot;&gt;四、基本功能&lt;/h2&gt;
&lt;p&gt;关于概览页面，我们再上一节已经进行过分析，这里不再赘述。我们在这一小节，将重点放在功能栏那一栏，即类直方图、支配树、OQL查询、线程视图等功能。&lt;/p&gt;
&lt;h3 id=&quot;类直方图&quot;&gt;4.1 类直方图&lt;/h3&gt;
&lt;p&gt;堆直方图是从类的角度看哪些类及该类的实例对象占用着内存情况，默认是按照某个类的shallow heap大小从大到小排序。&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/44770-bce30b936e782368.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;类直方图&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Retained Heap这一列的值是空的，因为对于某个类的所有实例计算总的retained heap非常慢，因此使用者需要按需计算。&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/44770-73d38bb53ab79ec6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;retained size是按需计算&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在直方图页面，可以选择某个条目右键进行分析，例如对所有类的对象做一些分析动作。&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/44770-29787d35e393ecd9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在直方图页面，还有一个重要的特性——可以选择一些其他维度进行分类分析，例如superclass、class loader、package。&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/44770-62d4a88882b83102.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果选择按照package来分类，则可以看到下面这种视图&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/44770-79fec641a53c919a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;支配树&quot;&gt;4.2 支配树&lt;/h3&gt;
&lt;p&gt;支配树可以用于查看heap dump中占用内存最大的对象。在支配树中，对于某一层的节点来说，如果它们的parent节点没有被其他对象引用了，那么这写节点都会被垃圾收集器回收。&lt;/p&gt;
&lt;p&gt;支配树可以用来排查是哪些对象导致了其他对象无法被垃圾收集器回收，跟类直方图类似，支配树也从类加载器、package等角度来看。&lt;/p&gt;
&lt;p&gt;[图片上传失败...(image-ec386f-1550075801691)]&lt;/p&gt;
&lt;h3 id=&quot;oql查询&quot;&gt;4.3 OQL查询&lt;/h3&gt;
&lt;p&gt;MAT提供另一种类似SQL的对象查询语言——OQL，可以用类似SQL语句的方式查询heap dump中的对象。OQL和关系型数据库具备类似的数据模型：将某个类看作是一张表，将该类的实例对象看作是该表中的行，每个对象中的属性看作是构成行的列。&lt;/p&gt;
&lt;p&gt;OQL语言的语法结构如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SELECT *
FROM [ INSTANCEOF ] &amp;lt;class name=&quot;name&quot;&amp;gt;
[ WHERE &amp;lt;filter-expression&amp;gt; ]
&amp;lt;/filter-expression&amp;gt;&amp;lt;/class&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;OQL编辑器分为两个区域：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;上半部分的区域用于输入查询语句&lt;/li&gt;
&lt;li&gt;下半部分的区域用于展示查询语句执行的结果&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下图是查询当前堆里所有的String对象的语句和结果：&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/44770-4bcd794afb2ac8f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;线程视图&quot;&gt;4.4 线程视图&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/44770-aaf7ea1dc4debd55.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过上图中的那个按钮，可以查看线程视图，线程视图首先给出了在生成快照那个时刻，JVM中的Java线程对象列表。这个按钮的功能，等同于下图中的这个操作：&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/44770-d606c60e63a17253.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在线程视图这个表中，可以看到以下几个信息：线程对象的名字、线程名、线程对象占用的堆内存大小、线程对象的保留堆内存大小、线程的上下文加载器、是否为守护线程。&lt;/p&gt;
&lt;p&gt;选中某个线程对象展开，可以看到线程的调用栈和每个栈的局部变量，通过查看线程的调用栈和局部变量的内存大小，可以找到在哪个调用栈里分配了大量的内存。&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/44770-81735ea34c532fbd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因此，heap dump和MAT不仅仅用于排查内存相关的问题，也有助于排查线程相关的问题。&lt;/p&gt;
&lt;h3 id=&quot;问题分析&quot;&gt;4.5 问题分析&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/44770-05512c7ea94d9987.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;br/&gt;上图中的这个按钮，是MAT提供的一些常见的问题分析能力。因为这些问题特别常见，所以MAT就提供了对应的组合功能，帮用户快速定位常见问题。&lt;/p&gt;
&lt;ol readability=&quot;2&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;Heap Dump Overview&lt;br/&gt;Heap Dump Overview就是整个堆的概括情况，例如：堆内存大小、对象个数、类的个数、类加载器的个数、GC root的个数、堆内存文件的格式、文件的创建时间、位置等信息。这个页面还开一个看一些系统属性、线程概览、Top内存耗费组件、类直方图等信息。&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/44770-20f283767a3af82e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Leak Suspects&lt;br/&gt;如下图所示，这个功能用于排查潜在的内存泄漏问题。&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/44770-2f3cf0f7a3a2b9e0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Top Components&lt;br/&gt;针对那些占用堆内存超过整个堆内存1%大小的组件做一系列的分析，例如：Top Consumers、保留集合、潜在的内存浪费问题等其他问题。&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/44770-3abd6782c9b48859.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这一系列的分析，有很多层次，可以用下面这张思维导图理解：&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/44770-741ce3264b52432f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;对象查找&quot;&gt;4.6 对象查找&lt;/h3&gt;
&lt;p&gt;MAT支持根据对象的十六进制地址查找对象的outbound引用视图，如下图所示：&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/44770-3c845aab60b0d745.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个功能等同于在直方图中选中某个对象，然后右键列举该对象的outbound引用视图：&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/44770-86bf12b928abcca1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;本号专注于后端技术、JVM问题排查和优化、Java面试题、个人成长和自我管理等主题，为读者提供一线开发者的工作和成长经验，期待你能在这里有所收获。&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/44770-7daebe9e48739106.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;javaadu&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 09 Jul 2019 16:21:00 +0000</pubDate>
<dc:creator>javaadu</dc:creator>
<og:description>上一篇文章 'MAT入门到精通（一）' 介绍了MAT的使用场景和基本概念，这篇文章开始介绍MAT的基本功能，后面还有两篇，一篇是MAT的高级功能，另一篇是MAT实战案例分析。 三、欢迎页 使用MAT打</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/javaadu/p/11161380.html</dc:identifier>
</item>
<item>
<title>RABC权限控制(页面操作角色,权限和进行分配) - ~泪小白~</title>
<link>http://www.cnblogs.com/leixiaobai/p/11161102.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/leixiaobai/p/11161102.html</guid>
<description>&lt;p&gt;　上一节主要说的是如何通过url进行权限控制,这一节就说一下如何开发一个权限控制的界面,这样我们就能很方便的创建角色,并分配给用户不同角色和不同权限.&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.编写角色管理页面&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个编写较为简单,主要是通过modelform快速实现的,下面代码比较简单,我就不多说了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;效果图如下:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1064304/201907/1064304-20190709223829941-459276148.png&quot; alt=&quot;&quot; width=&quot;1255&quot; height=&quot;323&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;代码如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; role_list(request):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;角色列表&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    roles_list &lt;/span&gt;=&lt;span&gt; Role.objects.all()
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 分页&lt;/span&gt;
    current_page_num = request.GET.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;page&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    pagination &lt;/span&gt;=&lt;span&gt; MyPagination(current_page_num, roles_list.count(), request)
    roles_list &lt;/span&gt;=&lt;span&gt; roles_list[pagination.start:pagination.end]
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; render(request, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;rbac/role_list.html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;roles_list&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: roles_list, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;pagination&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:pagination})


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; role_operate(request, edit_id=&lt;span&gt;None):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;角色操作&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    role_obj &lt;/span&gt;= Role.objects.filter(pk=&lt;span&gt;edit_id).first()
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; request.method == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;POST&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
        role_form &lt;/span&gt;= RoleModelForm(request.POST, instance=&lt;span&gt;role_obj)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; role_form.is_valid():
            role_form.save()
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; redirect(reverse(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;rbac:role_list&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; render(request, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;rbac/role_operate.html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;role_form&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: role_form})
    role_form &lt;/span&gt;= RoleModelForm(instance=&lt;span&gt;role_obj)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; render(request, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;rbac/role_operate.html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;role_form&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: role_form, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;role_obj&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: role_obj})


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; role_del(request, del_id):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;删除角色&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    Role.objects.filter(pk&lt;/span&gt;=&lt;span&gt;del_id).delete()
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; redirect(reverse(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;rbac:role_list&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;))
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;RoleModelForm,这里就只有一个name字段,不给角色字段是创建完用户后到时再分配&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; RoleModelForm(forms.ModelForm):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;角色的modelform&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Meta:
        model &lt;/span&gt;=&lt;span&gt; Role
        fields &lt;/span&gt;= [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]

        error_messages &lt;/span&gt;=&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;required&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;角色名称不能为空&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}
        }
        widgets &lt;/span&gt;=&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: wid.TextInput(attrs={&lt;span&gt;'&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;form-control&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;})
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt; 2.编写菜单权限管理页面&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个也不是特别难,因为主要就是两张表在页面渲染的事情,效果图如下:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1064304/201907/1064304-20190709224308788-1148394422.png&quot; alt=&quot;&quot; width=&quot;1348&quot; height=&quot;636&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;代码如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; menu_list(request):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;菜单权限列表&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取所有的菜单&lt;/span&gt;
    menu_list =&lt;span&gt; Menu.objects.all()
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 菜单管理目前选择的菜单名称id&lt;/span&gt;
    mid = request.GET.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;mid&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如果mid有值则通过二级菜单中菜单id是一级菜单的和二级菜单下子权限id属于一级菜单的全部找出来显示,没有则显示全部菜单&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;&lt;span&gt; mid:
        permission_list &lt;/span&gt;= Permission.objects.filter(Q(parent__menu__id=mid) | Q(menu_id=&lt;span&gt;mid))
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        permission_list &lt;/span&gt;=&lt;span&gt; Permission.objects.all()
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查询出权限表中的所有字段&lt;/span&gt;
    all_permission_list = permission_list.values(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;url&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;url_name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
                                                 &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;menu_id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;parent_id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;menu__title&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 把所有菜单以字典形式保存在字典中&lt;/span&gt;
    all_permission_dict =&lt;span&gt; {}
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 第一次for循环将二级菜单加入字典中&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; permission &lt;span&gt;in&lt;/span&gt;&lt;span&gt; all_permission_list:
        menu_id &lt;/span&gt;= permission.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;menu_id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 有menu_id就证明是二级菜单,加入字典&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; menu_id:
            permission[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;children&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] =&lt;span&gt; []
            all_permission_dict[permission[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]] =&lt;span&gt; permission
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 第二次for循环将三级菜单(子权限)加入到二级菜单的children中&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; permission &lt;span&gt;in&lt;/span&gt;&lt;span&gt; all_permission_list:
        parent_id &lt;/span&gt;= permission.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;parent_id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; parent_id:
            all_permission_dict[parent_id][&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;children&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;].append(permission)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; render(request, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;rbac/menu_list.html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;menu_list&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: menu_list,
                                                   &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;all_permission_dict&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: all_permission_dict, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;mid&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: mid})


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; menu_operate(request, edit_id=&lt;span&gt;None):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;菜单管理操作&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    menu_obj &lt;/span&gt;= Menu.objects.filter(pk=&lt;span&gt;edit_id).first()
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; request.method == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;POST&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
        form_obj &lt;/span&gt;= MenuModelForm(request.POST, instance=&lt;span&gt;menu_obj)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; form_obj.is_valid():
            form_obj.save()
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; redirect(reverse(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;rbac:menu_list&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; render(request, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;rbac/menu_operate.html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;form_obj&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: form_obj})
    form_obj &lt;/span&gt;= MenuModelForm(instance=&lt;span&gt;menu_obj)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; render(request, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;rbac/menu_operate.html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;form_obj&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: form_obj, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;menu_obj&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: menu_obj})


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; menu_del(request, del_id):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;菜单管理删除&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    Menu.objects.filter(pk&lt;/span&gt;=&lt;span&gt;del_id).delete()
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; redirect(reverse(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;rbac:menu_list&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; permission_operate(request, edit_id=&lt;span&gt;None):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;权限管理操作&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    permission_obj &lt;/span&gt;= Permission.objects.filter(pk=&lt;span&gt;edit_id).first()
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; request.method == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;POST&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
        form_obj &lt;/span&gt;= PermissionModelForm(request.POST, instance=&lt;span&gt;permission_obj)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; form_obj.is_valid():
            form_obj.save()
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; redirect(reverse(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;rbac:menu_list&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; render(request, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;rbac/permission_operate.html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;form_obj&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: form_obj})
    form_obj &lt;/span&gt;= PermissionModelForm(instance=&lt;span&gt;permission_obj)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; render(request, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;rbac/permission_operate.html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;form_obj&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: form_obj, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;permission_obj&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: permission_obj})


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; permission_del(request, del_id):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;权限管理删除&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    Permission.objects.filter(pk&lt;/span&gt;=&lt;span&gt;del_id).delete()
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; redirect(reverse(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;rbac:menu_list&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;页面对上面两个数据的for循环展示(这也是最主要的数据展示部分)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{% for p_permission in all_permission_dict.values %}
                        &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tr &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;parent&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;{{ p_permission.id }}&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;title&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;i &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;fa fa-caret-down&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;i&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{ p_permission.title }}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{ p_permission.url }}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{ p_permission.url_name }}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;是&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{ p_permission.menu__title }}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;{% url 'rbac:permission_edit' p_permission.id %}&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;i &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;fa fa-edit&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;i&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;margin-left: 10px&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;{% url 'rbac:permission_del' p_permission.id %}&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;i
                                        &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;fa fa-trash-o text-danger&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;i&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
                        {% for c_permission in p_permission.children %}
                            &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tr &lt;/span&gt;&lt;span&gt;pid&lt;/span&gt;&lt;span&gt;=&quot;{{ c_permission.parent_id }}&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;padding-left: 20px&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{ c_permission.title }}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{ c_permission.url }}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{ c_permission.url_name }}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;{% url 'rbac:permission_edit' c_permission.id %}&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;i &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;fa fa-edit&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;i&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;margin-left: 10px&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;{% url 'rbac:permission_del' c_permission.id %}&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;i
                                            &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;fa fa-trash-o text-danger&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;i&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
                        {% endfor %}

                    {% endfor %}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;点击二级菜单显示和隐藏,这里巧妙的用到了二级菜单的id和子权限的parent_id相等去显示和隐藏,下面是显示隐藏的jquery代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&amp;lt;script&amp;gt;&lt;span&gt;
        $(&lt;/span&gt;'.permisson-area').on('click', 'tr .title', &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; caret = $(&lt;span&gt;this&lt;/span&gt;).find('i'&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; id = $(&lt;span&gt;this&lt;/span&gt;).parent().attr('id'&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (caret.hasClass('fa-caret-right'&lt;span&gt;)){
                caret.removeClass(&lt;/span&gt;'fa-caret-right').addClass('fa-caret-down'&lt;span&gt;);
               $(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;).parent().nextAll('tr[pid=&quot;' + id + '&quot;]').removeClass('hide'&lt;span&gt;);
            }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                caret.removeClass(&lt;/span&gt;'fa-caret-down').addClass('fa-caret-right'&lt;span&gt;);
                $(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;).parent().nextAll('tr[pid=' + id + ']').addClass('hide'&lt;span&gt;);
            }
        })
    &lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt; 3.分配权限管理页面编写(这个比较麻烦,主要是数据结构比较复杂,嵌套太多层,注意这还是二级菜单)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;实现的效果图如下:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1064304/201907/1064304-20190709230412066-943203329.png&quot; alt=&quot;&quot; width=&quot;1290&quot; height=&quot;430&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;代码如下,备注在代码中写了,详细请看代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;113&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; distribute_permissions(request):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;分配权限&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; uid是前端提交的用户id,rid是前端提交的角色id&lt;/span&gt;
    uid = request.GET.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;uid&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    rid &lt;/span&gt;= request.GET.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;rid&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 用户添加角色,由于有多个from表单所以给每个from表单一个postType&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; request.method == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;POST&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; request.POST.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;postType&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;role&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;and&lt;/span&gt;&lt;span&gt; uid:
        user &lt;/span&gt;= User.objects.filter(id=&lt;span&gt;uid).first()
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; user:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; HttpResponse(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;用户不存在&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 因为是多对多的关系,所以用set就可以直接更新数据了,记得set里面必须是可迭代对象,所以getlist&lt;/span&gt;
        user.roles.set(request.POST.getlist(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;roles&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 角色添加权限&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; request.method == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;POST&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; request.POST.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;postType&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;permission&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;and&lt;/span&gt;&lt;span&gt; rid:
        role &lt;/span&gt;= Role.objects.filter(id=&lt;span&gt;rid).first()
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; role:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; HttpResponse(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;角色不存在&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        role.permissions.set(request.POST.getlist(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;permissions&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 所有用户,界面用户展示&lt;/span&gt;
    user_list =&lt;span&gt; User.objects.all()
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 取得当前用户的所有角色&lt;/span&gt;
    user_has_roles = User.objects.filter(id=uid).values(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;roles&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取用户拥有的角色id,数据结构是{角色id: None},这种数据结构推荐,到时直接in就能判断了,效率高&lt;/span&gt;
    user_has_roles_dict = {item[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;roles&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]: None &lt;span&gt;for&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt;&lt;span&gt; user_has_roles}

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 角色列表(所有角色),界面用户展示&lt;/span&gt;
    role_list =&lt;span&gt; Role.objects.all()

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如过选中了角色,那么就根据角色id拿到所有的权限&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;&lt;span&gt; rid:
        role_has_permissions &lt;/span&gt;= Role.objects.filter(id=rid).values(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;permissions&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如果只选中了用户没有选择角色,那么就通过用户的角色去拿对应的所有权限&lt;/span&gt;
    &lt;span&gt;elif&lt;/span&gt; uid &lt;span&gt;and&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; rid:
        user &lt;/span&gt;= User.objects.filter(id=&lt;span&gt;uid).first()
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; user:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; HttpResponse(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;用户不存在&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        role_has_permissions &lt;/span&gt;= user.roles.values(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;permissions&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 都没选中,就是初始化状态,界面不勾选任何权限菜单&lt;/span&gt;
        role_has_permissions =&lt;span&gt; []

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取角色拥有的权限id,数据结构是{权限id: None}&lt;/span&gt;
    role_has_permissions_dict = {item[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;permissions&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]: None &lt;span&gt;for&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt;&lt;span&gt; role_has_permissions}

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 以列表形式存放所有的菜单信息&lt;/span&gt;
    all_menu_list =&lt;span&gt; []

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查询出所有菜单&lt;/span&gt;
    menu_queryset = Menu.objects.values(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 以字典形式存放所有的菜单信息&lt;/span&gt;
    menu_dict =&lt;span&gt; {}

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 这个for循环的作用是将一级菜单信息分别放入了menu_dict字典和all_menu_list列表中&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt;&lt;span&gt; menu_queryset:
        item[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;children&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = []   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 存放二级菜单(父权限)&lt;/span&gt;
        menu_dict[item[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]] = item    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 注意这里是将item对象赋值给了item['id'],所以menu_dict和all_menu_list是一起变化的&lt;/span&gt;
&lt;span&gt;        all_menu_list.append(item)

    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    下面是这两个的数据结构,字典套字典,然后children字段子菜单就是列表,然后反复这样嵌套
    menu_dict = {'menu_id': {'id':1, 'title': 'xxx', 'children': [
                {'id', 'title', 'menu_id', 'children': [
                    {'id', 'title', 'parent_id'}
                ]},
                ]},
                None: {'id': None, 'title': '其他', 'children': [{'id', 'title', 'parent_id'}]}
                }
    all_menu_list = [
        {'id':1, 'title': 'xxx', 'children': [
        {'id', 'title', 'menu_id', 'children': [
            {'id', 'title', 'parent_id'}
        ]},
        ]},
        {'id': None, 'title': '其他', 'children': [{'id', 'title', 'parent_id'}]}
    ]
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 像首页这些不属于任何一级菜单,所以可以归属于other下面&lt;/span&gt;
    other = {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: None, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;其他&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;children&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: []}
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 两个数据结构分别加入other&lt;/span&gt;
&lt;span&gt;    all_menu_list.append(other)
    menu_dict[None] &lt;/span&gt;=&lt;span&gt; other

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查询二级菜单的权限信息&lt;/span&gt;
    parent_permission = Permission.objects.filter(menu__isnull=False).values(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;menu_id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 二级菜单信息字典&lt;/span&gt;
    parent_permission_dict =&lt;span&gt; {}
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    parent_permission_dict = {父权限id: {'id', 'title', 'menu_id', 'children': [
        {'id', 'title', 'parent_id'}
    ]} }
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;

    &lt;span&gt;for&lt;/span&gt; per &lt;span&gt;in&lt;/span&gt;&lt;span&gt; parent_permission:
        per[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;children&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = []    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 存放子权限&lt;/span&gt;
        nid = per[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
        menu_id &lt;/span&gt;= per[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;menu_id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 以二级菜单id为键,二级菜单信息为值加入到二级菜单字典中&lt;/span&gt;
        parent_permission_dict[nid] =&lt;span&gt; per
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 一级菜单字典将二级菜单加入到children下,注意一级菜单列表数据结构也会跟着增加(py内存使用导致)&lt;/span&gt;
        menu_dict[menu_id][&lt;span&gt;'&lt;/span&gt;&lt;span&gt;children&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;].append(per)

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 类似上面的操作,将不是二级菜单的权限全部找出来,包括子权限和other&lt;/span&gt;
    node_permission = Permission.objects.filter(menu__isnull=True).values(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;parent_id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; per &lt;span&gt;in&lt;/span&gt;&lt;span&gt; node_permission:
        pid &lt;/span&gt;= per[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;parent_id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如果不是子权限,就将信息加入到other的children下&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; pid:
            menu_dict[None][&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;children&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;].append(per)
            &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 是子权限就加入到二级菜单的children下,因为menu_dict存放的是二级菜单的对象,所以此时menu_dict就有了各个层级的数据&lt;/span&gt;
        parent_permission_dict[pid][&lt;span&gt;'&lt;/span&gt;&lt;span&gt;children&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;].append(per)

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; render(request, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;rbac/distribute_permissions.html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
                  {
                      &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;user_list&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: user_list,
                      &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;role_list&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: role_list,
                      &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;user_has_roles_dict&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: user_has_roles_dict,
                      &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;role_has_permissions_dict&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: role_has_permissions_dict,
                      &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;all_menu_list&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: all_menu_list,
                      &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;uid&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: uid,
                      &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;rid&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: rid,
                  })&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;前端代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{% extends 'layout.html' %}
{% block css %}
    &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        .user-area ul &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
            padding-left&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 20px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;&lt;span&gt;

        .user-area li &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
            cursor&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; pointer&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
            padding&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 2px 0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;&lt;span&gt;

        .user-area li a &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
            display&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; block&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;&lt;span&gt;

        .user-area li.active &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
            font-weight&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; bold&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
            color&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; red&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;&lt;span&gt;

        .user-area li.active a &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
            color&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; red&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;&lt;span&gt;

        .role-area tr td a &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
            display&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; block&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;&lt;span&gt;

        .role-area tr.active &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
            background-color&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; #f1f7fd&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
            border-left&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 3px solid #fdc00f&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;&lt;span&gt;

        .permission-area tr.root &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
            background-color&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; #f1f7fd&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
            cursor&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; pointer&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;&lt;span&gt;

        .permission-area tr.root td i &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
            margin&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 3px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;&lt;span&gt;

        .permission-area .node &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;

        &lt;span&gt;}&lt;/span&gt;&lt;span&gt;

        .permission-area .node input[type='checkbox'] &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
            margin&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 0 5px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;&lt;span&gt;

        .permission-area .node .parent &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
            padding&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 5px 0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;&lt;span&gt;

        .permission-area .node label &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
            font-weight&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; normal&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
            margin-bottom&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
            font-size&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 12px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;&lt;span&gt;

        .permission-area .node .children &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
            padding&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 0 0 0 20px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;&lt;span&gt;

        .permission-area .node .children .child &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
            display&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; inline-block&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
            margin&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 2px 5px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;&lt;span&gt;

        table &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
            font-size&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 12px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;&lt;span&gt;

        .panel-body &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
            font-size&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 12px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;&lt;span&gt;

        .panel-body .form-control &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
            font-size&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 12px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
{% endblock %}
{% block content %}
    &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;container-fluid&quot;&lt;/span&gt;&lt;span&gt; style&lt;/span&gt;&lt;span&gt;=&quot;margin-top: 20px&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;col-sm-3 user-area&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;panel panel-default&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;panel-heading&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;i &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;fa fa-user&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;i&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 用户信息&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;panel-body&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
                        {% for user in user_list %}
                            &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;={% &lt;/span&gt;&lt;span&gt;if user.id|safe &lt;/span&gt;&lt;span&gt;== &lt;/span&gt;&lt;span&gt;uid %}&quot;active&quot;{% endif %}&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;?uid={{ user.id }}&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{ user.name }}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
                        {% endfor %}

                    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;col-sm-3 role-area&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form &lt;/span&gt;&lt;span&gt;action&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt; method&lt;/span&gt;&lt;span&gt;=&quot;post&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
                {% csrf_token %}
                &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;hidden&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;postType&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;role&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;panel panel-default&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;panel-heading&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;i &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;fa fa-book&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;i&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt; 角色
                        {% if uid %}
                            &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;submit&quot;&lt;/span&gt;&lt;span&gt; style&lt;/span&gt;&lt;span&gt;=&quot;padding: 2px 6px;position: relative;top: -3px;&quot;&lt;/span&gt;&lt;span&gt;
                                    class&lt;/span&gt;&lt;span&gt;=&quot;btn btn-success pull-right&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;i &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;margin-right: 2px&quot;&lt;/span&gt;&lt;span&gt;
                                                                          class&lt;/span&gt;&lt;span&gt;=&quot;fa fa-save&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;i&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt; 保存
                            &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
                        {% endif %}
                    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;panel-body&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;color: darkgray&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;提示:点击用户后才能为其分配角色&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;table &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;table table-hover&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;thead&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;th&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;角色&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;th&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;th&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;选择&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;th&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;thead&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tbody&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
                        {% load my_tag %}
                        {% for role in role_list %}
                            &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tr &lt;/span&gt;&lt;span&gt;{% if role.id|safe &lt;/span&gt;&lt;span&gt;== &lt;/span&gt;&lt;span&gt;rid %}class&lt;/span&gt;&lt;span&gt;=&quot;active&quot;&lt;/span&gt;&lt;span&gt;{% endif %}&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;?{% get_role_url request role.id %}&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{ role.name }}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
                                    {% if role.id in user_has_roles_dict %}
                                        &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;checkbox&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;roles&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;{{ role.id }}&quot;&lt;/span&gt;&lt;span&gt; checked&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
                                    {% else %}
                                        &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;checkbox&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;roles&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;{{ role.id }}&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
                                    {% endif %}
                                &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
                        {% endfor %}

                        &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tbody&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;table&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;form&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;col-sm-6 permission-area&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form &lt;/span&gt;&lt;span&gt;action&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt; method&lt;/span&gt;&lt;span&gt;=&quot;post&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
                {% csrf_token %}
                &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;hidden&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;postType&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;permission&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;panel panel-default&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;panel-heading&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;i &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;fa fa-reddit&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;i&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 权限分配&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
                    {% if rid %}
                        &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;submit&quot;&lt;/span&gt;&lt;span&gt;
                                style&lt;/span&gt;&lt;span&gt;=&quot;padding: 2px 6px;position: relative;top: -32px; margin-right: 10px;&quot;&lt;/span&gt;&lt;span&gt;
                                class&lt;/span&gt;&lt;span&gt;=&quot;btn btn-success pull-right&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;i &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;margin-right: 2px&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;fa fa-save&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;i&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
                            保存
                        &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
                    {% endif %}
                    &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;panel-body&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;color: darkgray&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;提示:点击角色后,才能为其分配权限&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;table &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;table&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tbody &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;permission-tbody&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
                        {% for item in all_menu_list %}
                            &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tr &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;root&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;i &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;fa fa-caret-down&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;i&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{ item.title }}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tr &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;node&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
                                    {% for node in item.children %}
                                        &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;parent&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
                                            {% if node.id in role_has_permissions_dict %}
                                                &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;permission_{{ node.id }}&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;permissions&quot;&lt;/span&gt;&lt;span&gt;
                                                       value&lt;/span&gt;&lt;span&gt;=&quot;{{ node.id }}&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;checkbox&quot;&lt;/span&gt;&lt;span&gt; checked&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
                                            {% else %}
                                                &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;permission_{{ node.id }}&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;permissions&quot;&lt;/span&gt;&lt;span&gt;
                                                       value&lt;/span&gt;&lt;span&gt;=&quot;{{ node.id }}&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;checkbox&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
                                            {% endif %}
                                            &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;label &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;=&quot;permission_{{ node.id }}&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{ node.title }}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                                        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;children&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
                                            {% for child in node.children %}
                                                &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;child&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
                                                    {% if child.id in role_has_permissions_dict %}
                                                        &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;permission_{{ child.id }}&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;permissions&quot;&lt;/span&gt;&lt;span&gt;
                                                               value&lt;/span&gt;&lt;span&gt;=&quot;{{ child.id }}&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;checkbox&quot;&lt;/span&gt;&lt;span&gt; checked&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
                                                    {% else %}
                                                        &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;permission_{{ child.id }}&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;permissions&quot;&lt;/span&gt;&lt;span&gt;
                                                               value&lt;/span&gt;&lt;span&gt;=&quot;{{ child.id }}&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;checkbox&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
                                                    {% endif %}
                                                    &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;label &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;=&quot;permission_{{ child.id }}&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{ child.title }}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                                                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
                                            {% endfor %}
                                        &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
                                    {% endfor %}
                                &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
                        {% endfor %}
                        &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tbody&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;table&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;form&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
{% endblock %}
{% block js %}
    &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        $(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.permission-tbody&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).on(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;click&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.root&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; caret &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; $(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;).find(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;i&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (caret.hasClass(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;fa-caret-right&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)) {
                caret.removeClass(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;fa-caret-right&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).addClass(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;fa-caret-down&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
                $(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;).next(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.node&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).removeClass(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;hide&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                caret.removeClass(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;fa-caret-down&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).addClass(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;fa-caret-right&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
                $(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;).next(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.node&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).addClass(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;hide&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
            }
        })
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;

{% endblock %}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;至此,页面大致开发完成,单独开发完成rbac之后,还得嵌入项目中去,大致也说一下迁移的过程:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;rbac应用于其他项目流程
&lt;/span&gt;1&lt;span&gt;.拷贝rbac到新项目
&lt;/span&gt;2&lt;span&gt;.在settings中注册rabc app
&lt;/span&gt;3&lt;span&gt;.数据库迁移
    首先先删除原有migrations下的文件,再执行数据库迁移命令
    python manage.py makemigrations
    python manage.py migrate
&lt;/span&gt;4&lt;span&gt;.在根目录下的urls.py中添加rbac相关的url
    re_path(r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;^rbac/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, include(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;rbac.urls&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, namespace=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;rbac&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;5&lt;span&gt;.layout.html的创建和编写,因为rbac中的模板都继承了这个
&lt;/span&gt;6&lt;span&gt;.录入权限信息
    角色管理
    权限管理
&lt;/span&gt;7&lt;span&gt;.分配权限
    先用户关联,原系统用户表一对一关联rbac用户表
    &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; rbac.models &lt;span&gt;import&lt;/span&gt;&lt;span&gt; User
    user &lt;/span&gt;= models.OneToOneField(User, null=True, blank=True, on_delete=&lt;span&gt;models.CASCADE)
    给用户分角色和权限
&lt;/span&gt;8&lt;span&gt;.登录应用权限
    登录成功后获取rbac的user_obj,然后初始化用户信息

    应用权限校验中间件
&lt;/span&gt;9&lt;span&gt;.注意模板layout内容和名称

&lt;/span&gt;10&lt;span&gt;.应用面包屑导航栏,中间会遇到很多样式js等不同,慢慢调试吧

&lt;/span&gt;11.权限控制到按钮级别
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Tue, 09 Jul 2019 15:33:00 +0000</pubDate>
<dc:creator>~泪小白~</dc:creator>
<og:description>上一节主要说的是如何通过url进行权限控制,这一节就说一下如何开发一个权限控制的界面,这样我们就能很方便的创建角色,并分配给用户不同角色和不同权限. 1.编写角色管理页面 这个编写较为简单,主要是通过</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/leixiaobai/p/11161102.html</dc:identifier>
</item>
<item>
<title>Unity3D热更新之LuaFramework篇[06]--Lua中是怎么实现脚本生命周期的 - 子非鱼`</title>
<link>http://www.cnblogs.com/imteach/p/11161214.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/imteach/p/11161214.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;blockquote readability=&quot;23&quot;&gt;
&lt;p&gt;用c#开发的时候，新建的脚本都默认继承自Monobehaviour, 因此脚本才有了自己的生命周期函数，如Awake,Start, Update, OnDestroy等。&lt;/p&gt;
&lt;p&gt;在相应的方法中实现游戏逻辑，引擎会适时调用。&lt;/p&gt;
&lt;p&gt;而Lua在这里做为c#的一个外延语言，自然是不受Unity管理的。&lt;/p&gt;
&lt;p&gt;不过，在前几篇文章中能看到，在XxxPanel和XxxCtrl中确实又有生命周期的影子，比如在MessagePanel.lua脚本中就存在MessagePanel.Awake和MessagePanel.OnDestroy方法。&lt;/p&gt;
&lt;p&gt;通过日志打印能知道，这些方法确实在相应的时候被执行了。&lt;/p&gt;
&lt;p&gt;那他是怎么实现的呢？&lt;/p&gt;
&lt;p&gt;这里就又要说到LuaBheavour脚本了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2&gt;LuaBehaviour实现的lua脚本生命周期&lt;/h2&gt;
&lt;blockquote readability=&quot;34&quot;&gt;
&lt;h3&gt;1、LuaBehaviour是一个c#脚本&lt;/h3&gt;
LuaBehaviour是一个c#脚本，在XxxPanel预制体被实例化的时候，被添加到了这个对象上，点击每一个实例化生成的窗口，都能看到这个脚本的存在。比如我们之前实现的LoginPanel，见下图：
&lt;p class=&quot;postTitle&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/634826/201907/634826-20190709225158461-1930434514.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;2、LuaBehaviour脚本的内容&lt;/h3&gt;
&lt;p&gt;打开这个脚本，能直接看到Awake方法和Star方法数，从方法名称就能猜到这个应该是Monobehaviour的生命周期函数，虽然这个脚本是继承的View。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/634826/201907/634826-20190709225740699-1634911674.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 打开View的定义，发现View继承Base&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/634826/201907/634826-20190709230113615-324057762.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;继续打开Base，能直到Base确实继承自MonoBehaviour&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/634826/201907/634826-20190709230207034-2127491748.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 显而易见的，LuaBehaviour中的Awake和Start是会被引擎调用的。而在Awake和Start中的调用语句：&lt;/p&gt;
&lt;p&gt;Util.CallMethod(name, &quot;Awake&quot;, gameObject);&lt;/p&gt;
&lt;p&gt;Util.CallMethod(name, &quot;Start&quot;);&lt;/p&gt;
&lt;p&gt;应该就是对Lua脚本XxxPanel中相应函数的调用。&lt;/p&gt;
&lt;p&gt;打开Util.CallMethod方法，能看到确实如此。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 执行Lua方法
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;[] CallMethod(&lt;span&gt;string&lt;/span&gt; module, &lt;span&gt;string&lt;/span&gt; func, &lt;span&gt;params&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt;[] args) {
            LuaManager luaMgr &lt;/span&gt;= AppFacade.Instance.GetManager&amp;lt;LuaManager&amp;gt;&lt;span&gt;(ManagerName.Lua);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (luaMgr == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; luaMgr.CallFunction(module + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; func, args);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3、LuaBehaviour是被谁绑定的&lt;/h3&gt;
&lt;p&gt;LuaFramework实现了很多的管理类，用于C#和Lua的对接工作，比如GameManager、LuaManager、NetworkManager等，以及PanelManager。&lt;/p&gt;
&lt;p&gt;在PanelManager里，我找到了用于实例化窗口的方法CreatePanel，也看到了绑定LuaBehaviour的语句。迷题解开。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/634826/201907/634826-20190709231848978-1439328716.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;/blockquote&gt;
&lt;h2&gt; 总结&lt;/h2&gt;
&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;1、PanelManager实例化窗口的时候，给窗口对象绑定LuaBehaviour脚本；&lt;/p&gt;
&lt;p&gt;2、LuaBehaviour脚本中的生命周期函数执行，从而驱动对应的Lua脚本中的生命周期函数执行。&lt;/p&gt;
&lt;p&gt;遗留问题：&lt;/p&gt;
&lt;p&gt;在XxxPanel中的和XxxCtrl中都存在Awake，那LuaBehaviour中的Awake到底调用的是哪一个脚本上的方法呢？&lt;/p&gt;
&lt;p&gt;这个应该需要研究一下LuaManager。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;感悟&lt;/h2&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;持续更新博客的计划总是失败，想了想，也许是前几篇文章都写得太长了吧。&lt;/p&gt;
&lt;p&gt;之前每写一篇，都要准备好久，写完总是到半夜，疲惫得不行。导致后来一想到写博，就有畏难情绪，就不想写了。&lt;/p&gt;
&lt;p&gt;从这篇开始，每篇少写一点。希望每周都有输出，不求多，但求坚持。&lt;/p&gt;
&lt;/blockquote&gt;

</description>
<pubDate>Tue, 09 Jul 2019 15:27:00 +0000</pubDate>
<dc:creator>子非鱼`</dc:creator>
<og:description>前言 用c#开发的时候，新建的脚本都默认继承自Monobehaviour, 因此脚本才有了自己的生命周期函数，如Awake,Start, Update, OnDestroy等。 在相应的方法中实现游戏</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/imteach/p/11161214.html</dc:identifier>
</item>
<item>
<title>Android 蓝牙开发（2）——低功耗蓝牙 - sydMobile</title>
<link>http://www.cnblogs.com/sydmobile/p/11161182.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sydmobile/p/11161182.html</guid>
<description>&lt;h3 id=&quot;低功耗蓝牙官方文档&quot;&gt;低功耗蓝牙官方文档&lt;/h3&gt;
&lt;p&gt;本文章是参考官网，然后加入自己实践中的理解完成！没有看上一篇的读者，可以先阅读一下前一篇，这是一个系列。&lt;br/&gt;官网地址：&lt;a href=&quot;https://developer.android.com/guide/topics/connectivity/bluetooth-le&quot; class=&quot;uri&quot;&gt;https://developer.android.com/guide/topics/connectivity/bluetooth-le&lt;/a&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1636493/201907/1636493-20190709231739157-1343476867.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Android 4.3 （API 18 ）引入了低功耗蓝牙，应用可以查询周围设备、查询设备的服务、传输信息。&lt;/p&gt;
&lt;h4 id=&quot;关键术语和概念&quot;&gt;关键术语和概念&lt;/h4&gt;
&lt;ul readability=&quot;10.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;通用属性配置文件（GATT Generic Attribute Profile）&lt;/p&gt;
&lt;p&gt;GATT 配置文件是一种传输数据规范，用于在 BLE 链路上发送和接受被称为属性的短数据的通用规范。目前所有低功耗应用配置文件基本都是基于 GATT&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;Bluetooth SIG (蓝牙技术联盟)&lt;/p&gt;
&lt;p&gt;是为低功耗设备定义了许多配置文件。配置文件是设备在特定应用程序中的工作方式的规范。设备可以实现多个配置文件。例如，设备可以包含心率监测器和电池水平检测器。&lt;/p&gt;
&lt;p&gt;定义规范的&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;属性协议（ATT Attribute Protocol）&lt;/p&gt;
&lt;p&gt;GATT 是建立在属性协议（ATT）之上的。也被称为 GATT/ATT 。ATT 经过优化，可在 BLE 设备上使用。为此，它使用了尽可能少的字节。每个属性由通用唯一标识符（UUID）来唯一标识。ATT 传输的属性被格式化为 &lt;strong&gt;特征&lt;/strong&gt; 和 &lt;strong&gt;服务&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;特征&lt;/p&gt;
&lt;p&gt;特征包含单个值和描述特征值的 0 ~ n 个描述符。特征值可以被称为类型。类似于类。（是在和 BLE 设备进行通信的时候主要的操作内容）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;描述符&lt;/p&gt;
&lt;p&gt;是用来定义特征值的已定义属性。用来描述特征值的。例如：描述符可以指定人类可读的描述，特征值的可接受范围或者特征值特定的度量单位&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;服务&lt;/p&gt;
&lt;p&gt;服务中包含一系列的特征值。例如，我们可以使用名为 “心率监测器”的服务，其中包括&quot;心率测量&quot;等特征。可以在 bluetooh.org 上找到基于 GATT 的现有配置文件的服务的列表。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;角色和责任&quot;&gt;角色和责任&lt;/h4&gt;
&lt;p&gt;Android 设备和 BLE 设备交互时应用的角色和职责&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;中央与外围设备。&lt;/li&gt;
&lt;li&gt;GATT 服务器和 GATT 客户端。确定了两个设备建立连接后如何进行相互通信&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;ble-权限&quot;&gt;BLE 权限&lt;/h4&gt;
&lt;p&gt;应用在使用蓝牙设备的时候必须要声明蓝牙权限 &lt;code&gt;BLUETOOTH&lt;/code&gt; 需要这个权限才可以进行蓝牙通信，例如：请求连接、接受连接、和传输数据。&lt;/p&gt;
&lt;p&gt;如果还需要发现或者操作蓝牙设置，则需要声明 &lt;code&gt;BLUETOOTH_ADMIN&lt;/code&gt; 权限。使用这个权限的前提是要有 &lt;code&gt;BLUETOOTH&lt;/code&gt; 权限。&lt;/p&gt;
&lt;p&gt;如果要声明我们的应用仅适用于支持 BLE 的设备，需要清单文件中做如下声明&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;uses-feature android:name = &quot;android.hardware.bluetooth_le&quot; android:required = true /&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果我们希望我们的应用程序在不支持 BLE 的设备上也可以运行的时候，只需要将 true 修改成 false 就可以了。&lt;/p&gt;
&lt;p&gt;还可以在代码中作出判断&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;if(!getPackageManager().hasSystemFeature(PackgeManger.FEATURE_BLUETOOTH_LE)){
    // 不支持 BLE 设备
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;BLE 通常和位置有关系，因此还需要声明位置权限 &lt;code&gt;ACCESS_COARSE_LOCATION&lt;/code&gt; 或者 &lt;code&gt;ACCESS_FINE_LOCATION&lt;/code&gt; 没有这些权限扫描将不会返回任何结果。&lt;/p&gt;
&lt;h4 id=&quot;设置-ble&quot;&gt;设置 BLE&lt;/h4&gt;
&lt;ol readability=&quot;9&quot;&gt;&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;获得 BluetoothAdapter&lt;/p&gt;
&lt;p&gt;BluetoothAdapter 代表设备自己的蓝牙适配器，整个系统只有一个蓝牙适配器，我们的应用程序可以使用此对象与其交互。&lt;/p&gt;
&lt;p&gt;这里的获取方法是通过 BluetoothManager 来获取的&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;BluetoothManager bluetoothManger = getSystemSerive(Context.BULETOOTH_SERVIcE);
BluetoothAdapter bluetoothAdapter = bluetoothManager.getAdapter();&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;启用蓝牙设备&lt;/p&gt;
&lt;p&gt;其实这些和普通蓝牙的启动都是一样的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;isEnable()&lt;/code&gt; 查看当前是否启用了蓝牙&lt;/p&gt;
&lt;p&gt;通过 BluetoothAdapter.ACTION_REQUEST_ENABLE 来启动&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;7&quot;&gt;
&lt;p&gt;查找 BLE 设备&lt;/p&gt;
&lt;p&gt;这一点和发现普通的蓝牙设备是不一样的&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 通过 Adapter 的 startLeScan(callBack); 方法来开启扫描
// 如果我们有指定的蓝牙设备可以使用
sartLeScan(UUID[],BluetoothAdapter.LeScanCallBakc) 通过 UUID 来指定 BLe
// 这个方法已经过时了，官方文档最新支持的扫描蓝牙的方法是通过一个专门的对象 BluetoothLeScanner 用来开启扫描低功耗蓝牙
BluetoothLeScanner scanner = bluetoothAdapter.getBluetoothLeScanner();
// 这个方法可以有参数，用来过滤要扫描的低功耗蓝牙的，具体的后面讲
scanner.startScan();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;只能单独扫描普通蓝牙设备或者 BLE 设备，没有方法同时执行&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;连接到-gatt-服务器&quot;&gt;连接到 GATT 服务器&lt;/h4&gt;
&lt;p&gt;与 BLE 设备通信，第一步就是要连接到它，就是连接到该设备的 GATT 服务。使用方法 &lt;code&gt;connectGatt()&lt;/code&gt;有三个参数：Context 对象 autoConnect （表示是否在可用的时候自己连接到 BLE 设备） 还有一个回调，所有的交互都在这个回调里面完成。&lt;/p&gt;
&lt;p&gt;调用这个方法会返回一个 &lt;code&gt;BluetoothGatt&lt;/code&gt;对象，通过这个对象进行和 BLE 设备的交互。交互的结果会在回调方法中触发。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class BluetoothLeService extends Service{
    private final static String TAG = BluetoothLeService.class.getSimpleName();
    private BluetoothManger bluetoothManger;
    private BluetoothAdapter bluetoothAdapter;
    private String bluetoothDeviceAddress;
    private BluetoothGatt bluetoothGatt;
    private int connectionState = STATE_DISCONNECTED;
    
    private static final int STATE_DISCONNECTED = 0;
    private static final int STATE_CONNETING = 1;
    private static final int STATE_CONNECTED = 2;
    
    public final static String ACTION_GATT_CONNECTED = &quot;com.example.bluetooth.le.ACTION_GATT_CONNECTED&quot;;
    public final static String ACTION_GATT_DISCONNECTED = &quot;com.example.bluetooth.le.ACTION_GATT_DISCONNECTED&quot;;
    public final static String ACTION_GATT_SERVICES_DISCOVERED = &quot;com.example.bluetooth.le.ACTION_GATT_SERVICES_DISCOVERED&quot;;
    public final satic String ACTION_DATA_AVAILABLE = &quot;com.example.bluetooth.le.ACTION_DATA_AVAILABLE&quot;;
    public final static String EXTRA_DATA = &quot;com.example.bluetooth.le.EXTRA_DATA&quot;;
    
    public final static UUID UUID_HEART_RATE_MEASUREMENT = UUID.formString(SampleGattAttributes.HEART_RATE_MEASURMENT);
    
    private final BluetoothGattCallback gattCallback = new BluetoothGattCallback(){
        // 你的中央设备连接上 ble 设备后，会回调这个这方法。
        @Override
        public viod onConnectionStateChange(BluetoothGatt gatt,int status,int newState){
            String intenAction;
            if(newState == BluetoothProfile.STATE_CONNECTED){
                intentaction = ACTION_GATT_CONNECTED;
                connectionState = STATE_CONNECTED;
                broadcastUpdate(intentAction);
                // 连接上后，紧接着就是要寻找里面 Service
                bluetoothGatt.discoverServices();
            }else if(newState = BluetoothProfile.STATE_STATE_DISCONNECTED{
                intentAction = ACTION_GATT_DISCONNECTED;
                connectionState = STATE_DISCONNECTED;
                broadcastUpdate(intentAction);
                
            }
           
        }
        @Override
        // service 发现后就会触发这个方法，然后你就需要找到你和 ble 约定好的 service
        public void onServicesDiscovered(BluetoothGatt gatt,int status){
            if(status == BluetoothGatt.GATT_SUCCESS){
                broadcastUpdate(ACTION_GATT_SERVICES_DISCOVERED);
            }            
        }
        
        public void onCharacteristicREad(。。。){
                         
        } 
        .......
                 
        
        
    }
    
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当触发特定的回调的时候，会调用适当的 broadcastUpdate() 辅助方法并向其传递操作。具体的数据解析格式是根据配置文件规范执行的（是你和你的BLE 设备共同约定好的规范）&lt;/p&gt;
&lt;p&gt;大体的过程中：开启连接，然后会触发对应的连接回调，然后发现服务，触发发现服务回调，获取服务内部的特征值，对其读写命令（和 BLE 共同约束的规范）。就是这么一个过程，很简单。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;读 BLE 属性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一旦我们的 Android 设备连接到了 GATT 服务器并发现了服务，我们就可以在支持的位置读取或者写入属性了。&lt;/p&gt;
&lt;p&gt;完成后要记得关闭设备 bluetoothGatt.close();&lt;/p&gt;
&lt;p&gt;关于蓝牙框架的一个库：https://github.com/Alex-Jerry/Android-BLE&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1636493/201907/1636493-20190709231856902-2141369405.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 09 Jul 2019 15:20:00 +0000</pubDate>
<dc:creator>sydMobile</dc:creator>
<og:description>低功耗蓝牙官方文档 本文章是参考官网，然后加入自己实践中的理解完成！没有看上一篇的读者，可以先阅读一下前一篇，这是一个系列。 官网地址： 'https://developer.android.com/</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/sydmobile/p/11161182.html</dc:identifier>
</item>
<item>
<title>每天学点node系列-fs文件系统 - 一半水一半冰</title>
<link>http://www.cnblogs.com/jingh/p/11161170.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jingh/p/11161170.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;好的代码像粥一样,都是用时间熬出来的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;概述&quot;&gt;概述&lt;/h2&gt;
&lt;p&gt;文件 I/O 是由简单封装的标准 POSIX 函数提供的。 通过 require('fs') 使用该模块。&lt;/p&gt;
&lt;p&gt;所有文件系统操作都具有同步和异步的形式。&lt;/p&gt;
&lt;p&gt;异步的形式总是将完成回调作为其最后一个参数。 传给完成回调的参数取决于具体方法，但第一个参数始终预留用于异常。 如果操作成功完成，则第一个参数将为 &lt;code&gt;null&lt;/code&gt; 或 &lt;code&gt;undefined&lt;/code&gt;。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// 异步示例
const fs = require('fs');

fs.unlink('/tmp/hello', (err) =&amp;gt; {
  if (err) throw err;
  console.log('已成功删除 /tmp/hello');
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用同步的操作发生的异常会立即抛出，可以使用 &lt;code&gt;try/catch&lt;/code&gt; 处理，也可以允许冒泡。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;//同步示例
const fs = require('fs');

try {
  fs.unlinkSync('/tmp/hello');
  console.log('已成功删除 /tmp/hello');
} catch (err) {
  // 处理错误
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在进程中，建议使用异步版本。 同步的版本将阻塞整个进程，直到它们完成（停止所有连接）。但是异步操作不保证执行顺序所以，所以在使用时请注意使用对象执行顺序。&lt;/p&gt;
&lt;h2 id=&quot;文件系统标志&quot;&gt;文件系统标志&lt;/h2&gt;
&lt;p&gt;flags可以是：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;'a' - 打开文件用于追加。如果文件不存在，则创建该文件。
'ax' - 与 'a' 相似，但如果路径已存在则失败。
'a+' - 打开文件用于读取和追加。如果文件不存在，则创建该文件。
'ax+' - 与 'a+' 相似，但如果路径已存在则失败。
'as' - 以同步模式打开文件用于追加。如果文件不存在，则创建该文件。
'as+' - 以同步模式打开文件用于读取和追加。如果文件不存在，则创建该文件。
'r' - 打开文件用于读取。如果文件不存在，则出现异常。
'r+' - 打开文件用于读取和写入。如果文件不存在，则出现异常。
'rs+' - 以同步模式打开文件用于读取和写入。指示操作系统绕过本地的文件系统缓存。
'w' - 打开文件用于写入。如果文件不存在则创建文件，如果文件已存在则截断文件。
'wx' - 与 'w' 相似，但如果路径已存在则失败。
'w+' - 打开文件用于读取和写入。如果文件不存在则创建文件，如果文件已存在则截断文件。
'wx+' - 与 'w+' 相似，但如果路径已存在则失败。&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;底层接口&quot;&gt;底层接口&lt;/h2&gt;
&lt;h3 id=&quot;打开文件&quot;&gt;打开文件&lt;/h3&gt;
&lt;h4 id=&quot;异步打开&quot;&gt;异步打开&lt;/h4&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// fs.open
path &amp;lt;string&amp;gt; | &amp;lt;Buffer&amp;gt; | &amp;lt;URL&amp;gt;
flags &amp;lt;string&amp;gt; | &amp;lt;number&amp;gt; 参阅支持的文件系统标志。
mode &amp;lt;integer&amp;gt; 默认值: 0o666（可读写）。
callback &amp;lt;Function&amp;gt;
  - err &amp;lt;Error&amp;gt;
  - fd &amp;lt;integer&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;var fs = require('fs')
fs.open('1.txt','r',function(err,fs){
    console.log(err)
    console.log(fs)
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;$ node 1.js
null
3&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意： 使用'rs+'模式不会使fs.open()进入同步阻塞调用。如果那是你想要的，则应该使用fs.openSync()&lt;/p&gt;
&lt;h4 id=&quot;同步打开&quot;&gt;同步打开&lt;/h4&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// fs.openSync
path &amp;lt;string&amp;gt; | &amp;lt;Buffer&amp;gt; | &amp;lt;URL&amp;gt;
flags &amp;lt;string&amp;gt; | &amp;lt;number&amp;gt; 参阅支持的文件系统标志。
mode &amp;lt;integer&amp;gt; 默认值: 0o666。
返回: &amp;lt;number&amp;gt;
返回表示文件描述符的整数。&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;var fs = require('fs');
var result = fs.openSync('1.txt','r');
console.log(result);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;$ node 1.js
3&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;读取文件&quot;&gt;读取文件&lt;/h3&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;fd &amp;lt;integer&amp;gt; 从 fd 指定的文件中读取数据。
buffer &amp;lt;Buffer&amp;gt; | &amp;lt;TypedArray&amp;gt; | &amp;lt;DataView&amp;gt; 数据将写入的缓冲区。
offset &amp;lt;integer&amp;gt; buffer 中开始写入的偏移量
length &amp;lt;integer&amp;gt; 是一个整数，指定要读取的字节数
position &amp;lt;integer&amp;gt; 参数指定从文件中开始读取的位置。 如果 position 为 null，则从当前文件位置读取数据，并更新文件位置。 如果 position 是整数，则文件位置将保持不变。
callback &amp;lt;Function&amp;gt;
- err &amp;lt;Error&amp;gt;
- bytesRead &amp;lt;integer&amp;gt;
- buffer &amp;lt;Buffer&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;var fs = require('fs');
fs.open('1.txt','r',function(err,fd){
    if(err){
        console.log('文件打开失败');
    }else{
        var bf = Buffer.alloc(5);
        fs.read(fd,bf,0,3,null,function(err,len,buffer){
            console.log(err);
            console.log(len);
            console.log(buffer);
        })
    }
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;$ node 1.js
null
3
&amp;lt;Buffer 68 65 6c 00 00&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;同步读取&quot;&gt;同步读取&lt;/h4&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;fd &amp;lt;integer&amp;gt;
buffer &amp;lt;Buffer&amp;gt; | &amp;lt;TypedArray&amp;gt; | &amp;lt;DataView&amp;gt;
offset &amp;lt;integer&amp;gt;
length &amp;lt;integer&amp;gt;
position &amp;lt;integer&amp;gt;
返回: &amp;lt;number&amp;gt;
返回 bytesRead 的数量。&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;var fs = require('fs');
var fd = fs.openSync('1.txt','r');
var bf = Buffer.alloc(5);
var result = fs.readSync(fd,bf,0,3,null);
console.log(result);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;$ node 1.js
3&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;写入文件&quot;&gt;写入文件&lt;/h3&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;fd &amp;lt;Integer&amp;gt;  文件标识
buffer &amp;lt;String&amp;gt; | &amp;lt;Buffer&amp;gt; 要将buffer中的数据写入到文件中
offset &amp;lt;Integer&amp;gt; buffer对象中要写入的数据的起始位置
length &amp;lt;Integer&amp;gt; length是一个整数，指定要写入的字节数
position &amp;lt;Integer&amp;gt; 指定从文件开始写入数据的位置的偏移量。 如果 typeof position !== 'number'，则数据从当前位置写入
callback &amp;lt;Function&amp;gt; 回调有三个参数(err, written, buffer)，其中written指定从buffer写入了多少字节&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;$ node 1.js
null
3
&amp;lt;Buffer 74 65 73 74&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;[注意]多次对同一文件使用fs.write且不等待回调，是不安全的。对于这种情况，强烈推荐使用 fs.createWriteStream　　当我们要对打开的文件进行写操作的时候，打开文件的模式应该是读写模式&lt;/p&gt;
&lt;h4 id=&quot;同步写入&quot;&gt;同步写入&lt;/h4&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;fd &amp;lt;integer&amp;gt;
buffer &amp;lt;Buffer&amp;gt; | &amp;lt;TypedArray&amp;gt; | &amp;lt;DataView&amp;gt;
offset &amp;lt;integer&amp;gt;
length &amp;lt;integer&amp;gt;
position &amp;lt;integer&amp;gt;
返回: &amp;lt;number&amp;gt; 写入的字节数。&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;var fs = require('fs');
var fd = fs.openSync('1.txt','r+');
var bf = Buffer.alloc(5);
var result = fs.writeSync(fd,bf,0,3,null);
console.log(result);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;$ node 1.js
3&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;关闭文件&quot;&gt;关闭文件&lt;/h3&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;fd - 通过 fs.open() 方法返回的文件描述符。
callback - 回调函数，没有参数。&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;var fs = require('fs');
fs.open('1.txt','r+',function(err,fd){
    if(err){
        console.log('文件打开失败');
    }else{
        fs.close(fd, function(err){
            if (err){
                console.log(err);
            } 
            console.log(&quot;文件关闭成功&quot;);
        });
    }
});&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;$ node 1.js
文件关闭成功&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;同步关闭&quot;&gt;同步关闭&lt;/h4&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;var fs = require('fs');
var fd = fs.openSync('1.txt','r+');
fs.closeSync(fd);&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;文件操作&quot;&gt;文件操作&lt;/h2&gt;
&lt;h3 id=&quot;文件读取&quot;&gt;文件读取&lt;/h3&gt;
&lt;h4 id=&quot;同步读取-1&quot;&gt;同步读取&lt;/h4&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;// fs.readFileSync
path &amp;lt;string&amp;gt; | &amp;lt;Buffer&amp;gt; | &amp;lt;URL&amp;gt;
options &amp;lt;string&amp;gt; | &amp;lt;Object&amp;gt;
    encoding &amp;lt;string&amp;gt; 默认值: 'utf8'。
    withFileTypes &amp;lt;boolean&amp;gt; 默认值: false。

返回: &amp;lt;string[]&amp;gt; | &amp;lt;Buffer[]&amp;gt; | &amp;lt;fs.Dirent[]&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;var fs = require('fs');
var data;

try{
    data = fs.readFileSync('./1.txt', 'utf8');
    console.log('文件内容: ' + data);
}catch(err){
    console.error('读取文件出错: ' + err.message);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果为：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;$ node 1.js
文件内容: hello rock&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;异步读取&quot;&gt;异步读取&lt;/h4&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;// fs.readFile
path &amp;lt;string&amp;gt; | &amp;lt;Buffer&amp;gt; | &amp;lt;URL&amp;gt;
options &amp;lt;string&amp;gt; | &amp;lt;Object&amp;gt;
    - encoding &amp;lt;string&amp;gt; 默认值: 'utf8'。
    - withFileTypes &amp;lt;boolean&amp;gt; 默认值: false。
callback &amp;lt;Function&amp;gt;
    - err &amp;lt;Error&amp;gt;
    - files &amp;lt;string[]&amp;gt; | &amp;lt;Buffer[]&amp;gt; | &amp;lt;fs.Dirent[]&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;var fs = require('fs');

fs.readFile('./1.txt', 'utf8', function(err, data){
    if(err){
        return console.error('读取文件出错: ' + err.message);
    }
    console.log('文件内容: ' + data);
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果也为：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;$ node 1.js
文件内容: hello rock&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;通过文件流读取&quot;&gt;通过文件流读取&lt;/h3&gt;
&lt;p&gt;适合读取大文件&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;path &amp;lt;string&amp;gt; | &amp;lt;Buffer&amp;gt; | &amp;lt;URL&amp;gt;
options &amp;lt;string&amp;gt; | &amp;lt;Object&amp;gt;
   - flags &amp;lt;string&amp;gt; 参阅支持的文件系统标志。默认值: 'r'。
   - encoding &amp;lt;string&amp;gt; 默认值: null。
   - fd &amp;lt;integer&amp;gt; 默认值: null。
   - mode &amp;lt;integer&amp;gt; 默认值: 0o666。
   - autoClose &amp;lt;boolean&amp;gt; 默认值: true。
   - start &amp;lt;integer&amp;gt;
   - end &amp;lt;integer&amp;gt; 默认值: Infinity。
   - highWaterMark &amp;lt;integer&amp;gt; 默认值: 64 * 1024。
返回: &amp;lt;fs.ReadStream&amp;gt; 参阅[可读流]。&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;var fs = require('fs');
var readStream = fs.createReadStream('./1.txt', 'utf8');

readStream
    .on('data', function(chunk) {
        console.log('读取数据: ' + chunk);
    })
    .on('error', function(err){
        console.log('出错: ' + err.message);
    })
    .on('end', function(){  // 没有数据了
        console.log('没有数据了');
    })
    .on('close', function(){  // 已经关闭，不会再有事件抛出
        console.log('已经关闭');
    });&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;$ node 1.js
读取数据: hello rock
没有数据了
已经关闭&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;文件写入&quot;&gt;文件写入&lt;/h3&gt;
&lt;h4 id=&quot;异步写入&quot;&gt;异步写入&lt;/h4&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// fs.writeFile
file &amp;lt;string&amp;gt; | &amp;lt;Buffer&amp;gt; | &amp;lt;URL&amp;gt; | &amp;lt;integer&amp;gt; 文件名或文件描述符。
data &amp;lt;string&amp;gt; | &amp;lt;Buffer&amp;gt; | &amp;lt;TypedArray&amp;gt; | &amp;lt;DataView&amp;gt;
options &amp;lt;Object&amp;gt; | &amp;lt;string&amp;gt;
  - encoding &amp;lt;string&amp;gt; | &amp;lt;null&amp;gt; 默认值: 'utf8'。
  - mode &amp;lt;integer&amp;gt; 默认值: 0o666。
  - flag &amp;lt;string&amp;gt; 参阅支持的文件系统标志。默认值: 'w'。
callback &amp;lt;Function&amp;gt;
  - err &amp;lt;Error&amp;gt;&amp;lt;/Error&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;var fs = require('fs');
fs.writeFile('./1.txt', 'hello rock', 'utf8', function(err){
    if(err) throw err;
    console.log('文件写入成功');
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;$ node 1.js
文件写入成功&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;同步写入-1&quot;&gt;同步写入&lt;/h4&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// fs.writeFileSync
file &amp;lt;string&amp;gt; | &amp;lt;Buffer&amp;gt; | &amp;lt;URL&amp;gt; | &amp;lt;integer&amp;gt; 文件名或文件描述符。
data &amp;lt;string&amp;gt; | &amp;lt;Buffer&amp;gt; | &amp;lt;TypedArray&amp;gt; | &amp;lt;DataView&amp;gt;
options &amp;lt;Object&amp;gt; | &amp;lt;string&amp;gt;
  - encoding &amp;lt;string&amp;gt; | &amp;lt;null&amp;gt; 默认值: 'utf8'。
  - mode &amp;lt;integer&amp;gt; 默认值: 0o666。
  - flag &amp;lt;string&amp;gt; 参阅支持的文件系统标志。默认值: 'w'。
  
返回 undefined。&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;var fs = require('fs');
try{
    fs.writeFileSync('./1.txt', 'hello rock', 'utf8');
    console.log('文件写入成功');
}catch(err){
    throw err;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;$ node 1.js
文件写入成功&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;通过文件流写入&quot;&gt;通过文件流写入&lt;/h4&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;path &amp;lt;string&amp;gt; | &amp;lt;Buffer&amp;gt; | &amp;lt;URL&amp;gt;
options &amp;lt;string&amp;gt; | &amp;lt;Object&amp;gt;
   - flags &amp;lt;string&amp;gt; 参阅支持的文件系统标志。默认值: 'w'。
   - encoding &amp;lt;string&amp;gt; 默认值: 'utf8'。
   - fd &amp;lt;integer&amp;gt; 默认值: null。
   - mode &amp;lt;integer&amp;gt; 默认值: 0o666。
   - autoClose &amp;lt;boolean&amp;gt; 默认值: true。
   - start &amp;lt;integer&amp;gt;
返回: &amp;lt;fs.WriteStream&amp;gt; 参阅可写流。&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;var fs = require('fs');
var writeStream = fs.createWriteStream('./1.txt', 'utf8');
writeStream
    .on('close', function(){ // 已经关闭，不会再有事件抛出
        console.log('已经关闭');
    });
writeStream.write('hello');
writeStream.write('rock');
writeStream.end('');&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;$ node 1.js
已经关闭&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;追加文件&quot;&gt;追加文件&lt;/h3&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;file - 文件名或文件描述符。
data - 要写入文件的数据，可以是 String(字符串) 或 Buffer(流) 对象。
options - 该参数是一个对象，包含 {encoding, mode, flag}。默认编码为 utf8, 模式为 0666 ， flag 为 'w'
callback - 回调函数，回调函数只包含错误信息参数(err)，在写入失败时返回。&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;var fs = require('fs');
var filename = '1.txt';
fs.appendFile(filename,' world',function(err){
    console.log(err);
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;$ node 1.js
null&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;同步追加&quot;&gt;同步追加&lt;/h4&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;var fs = require('fs');
var filename = '1.txt';
fs.appendFileSync(filename,' lalala');&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;删除文件&quot;&gt;删除文件&lt;/h3&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;path - 文件路径。
callback - 回调函数，没有参数。&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;var fs = require('fs');
var filename = '1.txt';
fs.unlink(filename, function(err) {
   if (err) {
       return console.log('删除失败');
   }
   console.log(&quot;删除成功&quot;);
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;$ node 1.js
删除成功&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;同步删除&quot;&gt;同步删除&lt;/h4&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;var fs = require('fs');
var filename = '1.txt';
fs.unlink(filename);&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;重命名&quot;&gt;重命名&lt;/h3&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;oldPath &amp;lt;String&amp;gt; | &amp;lt;Buffer&amp;gt;
newPath &amp;lt;String&amp;gt; | &amp;lt;Buffer&amp;gt;
callback &amp;lt;Function&amp;gt; 回调只有一个可能的异常参数&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;var fs = require('fs');
var filename = 'a.txt';
fs.rename(filename,'2.new.txt',function(err){
    console.log(err);
})&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;$ node 1.js
null&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;同步重命名&quot;&gt;同步重命名&lt;/h4&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;var fs = require('fs');
var filename = '2.new.txt';
var result = fs.renameSync(filename,'a.txt');&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;文件信息&quot;&gt;文件信息&lt;/h3&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;path &amp;lt;string&amp;gt; | &amp;lt;Buffer&amp;gt; | &amp;lt;URL&amp;gt;
options &amp;lt;Object&amp;gt;
bigint &amp;lt;boolean&amp;gt; 返回的 fs.Stats 对象中的数值是否应为 bigint 型。默认值: false。
callback &amp;lt;Function&amp;gt;
   - err &amp;lt;Error&amp;gt;
   - stats &amp;lt;fs.Stats&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;var fs = require('fs');
var filename = 'a.txt';
fs.stat(filename,function(err,stats){
    console.log(err);
    console.log(stats);
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;$ node 1.js
null
Stats {
  dev: 163689085,
  mode: 33206,
  nlink: 1,
  uid: 0,
  gid: 0,
  rdev: 0,
  blksize: undefined,
  ino: 9007199254854088,
  size: 0,
  blocks: undefined,
  atimeMs: 1562684836201.136,
  mtimeMs: 1562684836201.136,
  ctimeMs: 1562684998231.913,
  birthtimeMs: 1562684836201.136,
  atime: 2019-07-09T15:07:16.201Z,
  mtime: 2019-07-09T15:07:16.201Z,
  ctime: 2019-07-09T15:09:58.232Z,
  birthtime: 2019-07-09T15:07:16.201Z }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;stats类中的方法有&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;stats.isFile()  如果是文件返回 true，否则返回 false。
stats.isDirectory() 如果是目录返回 true，否则返回 false。
stats.isBlockDevice()   如果是块设备返回 true，否则返回 false。
stats.isCharacterDevice()   如果是字符设备返回 true，否则返回 false。
stats.isSymbolicLink()  如果是软链接返回 true，否则返回 false。
stats.isFIFO()  如果是FIFO，返回true，否则返回false。FIFO是UNIX中的一种特殊类型的命令管道。
stats.isSocket()    如果是 Socket 返回 true，否则返回 false。&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;var fs = require('fs');
var filename = 'a.txt';
fs.stat(filename,function(err,stats){
    console.log(stats.isFile());//true
});&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;监听&quot;&gt;监听&lt;/h3&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;filename &amp;lt;String&amp;gt; | &amp;lt;Buffer&amp;gt;
options &amp;lt;String&amp;gt; | &amp;lt;Object&amp;gt; 参数可选，如果options是一个字符串，则它指定了encoding。否则options应该以一个对象传入
    persistent &amp;lt;Boolean&amp;gt; 指明如果文件正在被监视，进程是否应该继续运行。默认为true
    recursive &amp;lt;Boolean&amp;gt; 指明是否全部子目录应该被监视，或只是当前目录。 适用于当一个目录被指定时，且只在支持的平台。默认为false
    encoding &amp;lt;String&amp;gt; 指定用于传给监听器的文件名的字符编码。默认为'utf8'
listener &amp;lt;Function&amp;gt; 回调函数有两个参数 (eventType, filename)。 eventType可以是'rename'或'change'，filename是触发事件的文件的名称&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;fs.watch('txt', (eventType, filename) =&amp;gt; {
  console.log(`事件类型是: ${eventType}`);
  if (filename) {
    console.log(`提供的文件名: ${filename}`);
  } else {
    console.log('未提供文件名');
  }
});&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;var fs = require('fs');
var filename = '1.txt';
fs.watch(filename,function(eventType, _filename){
    console.log(eventType);//change
    if(_filename){
        console.log(_filename + '发生了改变');//'1.txt发生了改变'
    }else{
        console.log('...');
    }
    
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;[注意]当一个文件出现或消失在一个目录里时，'rename'也会被触发&lt;/p&gt;
</description>
<pubDate>Tue, 09 Jul 2019 15:19:00 +0000</pubDate>
<dc:creator>一半水一半冰</dc:creator>
<og:description>好的代码像粥一样,都是用时间熬出来的。 概述 文件 I/O 是由简单封装的标准 POSIX 函数提供的。 通过 require('fs') 使用该模块。 所有文件系统操作都具有同步和异步的形式。 异步</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jingh/p/11161170.html</dc:identifier>
</item>
<item>
<title>微信小程序在ios下Echarts图表不能滑动的解决方案 - 韩子卢</title>
<link>http://www.cnblogs.com/vvjiang/p/11161103.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/vvjiang/p/11161103.html</guid>
<description>&lt;h2 id=&quot;问题现象&quot;&gt;问题现象&lt;/h2&gt;
&lt;p&gt;这个问题的现象说起来很简单。&lt;/p&gt;
&lt;p&gt;小程序页面中有一篇很长的文章，内部有一个Echarts图表，手指上下滑动观看内容。&lt;/p&gt;
&lt;p&gt;但是手指滑动区域在Echarts图表上时，页面却不能滑动了。&lt;/p&gt;
&lt;p&gt;如下图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/746209/201907/746209-20190709225842630-20357442.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;追踪问题原因&quot;&gt;追踪问题原因&lt;/h2&gt;
&lt;p&gt;因为在小程序上渲染图表用到的是&lt;a href=&quot;https://github.com/ecomfe/echarts-for-weixin/blob/master/pages/index/index.wxml&quot;&gt;echarts-for-weixin&lt;/a&gt;这个组件,而这个组件确实不支持一些Echarts功能。&lt;/p&gt;
&lt;p&gt;所以最开始我怀疑是这个组件的问题，认为它把我的滑动事件给吞了。&lt;/p&gt;
&lt;p&gt;为了确认这个问题，我直接在这个组件ec-canvas旁加了个兄弟节点view，然后用绝对定位将其覆盖在ec-canvas，这样滑动的时候就会滑动到我的view上而不是ec-canvas。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/746209/201907/746209-20190709225954060-928797710.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是结果在ios下，还是不能滑动。&lt;/p&gt;
&lt;p&gt;于是我给这个view的加了个背景色，在ios下的真机调试时发现，ec-canvas组件还是在view上面。&lt;/p&gt;
&lt;p&gt;不论是加大view上的z-index值，还是将absolute改为fixed，反正ec-canvas组件所渲染的图表就是在view上面，而没有被view遮挡。&lt;/p&gt;
&lt;p&gt;这个ec-canvas组件是如此出众，无论什么都遮盖不了它的风采。&lt;/p&gt;
&lt;p&gt;而导致它如此出众的原因就是：图表是一个canvas组件，而小程序中canvas是一个原生组件。&lt;/p&gt;
&lt;p&gt;接下来就让我们看看小程序中使用原生组件的限制。&lt;/p&gt;
&lt;h2 id=&quot;小程序的原生组件使用限制&quot;&gt;小程序的原生组件使用限制&lt;/h2&gt;
&lt;p&gt;这里先附上链接：&lt;a href=&quot;https://developers.weixin.qq.com/miniprogram/dev/component/native-component.html#%E5%8E%9F%E7%94%9F%E7%BB%84%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E9%99%90%E5%88%B6&quot;&gt;小程序原生组件使用限制&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;让我们看看关键的地方：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/746209/201907/746209-20190709230024288-885354952.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;也就是说canvas这类原生组件就是比view这种非原生的组件层级高。&lt;/p&gt;
&lt;h2 id=&quot;用cover-view来解决&quot;&gt;用cover-view来解决？&lt;/h2&gt;
&lt;p&gt;为了解决原生组件层级最高的限制。小程序专门提供了 cover-view 和 cover-image 组件，可以覆盖在部分原生组件上面。这两个组件也是原生组件。&lt;/p&gt;
&lt;p&gt;我将原来的兄弟view组件替换为了cover-view组件，然后希望达到可以滑动的效果。&lt;/p&gt;
&lt;p&gt;虽然此时cover-view组件已经可以覆盖在canvas上了，但是依然不能滑动。&lt;/p&gt;
&lt;p&gt;关于这个问题，我们可以认为小程序的所有组件都是放在webview中，而原生组件在webview中用的是占位符。&lt;/p&gt;
&lt;p&gt;在滚动时，获取原生组件占位符的位置，再改变原生组件的位置。（如果仔细观察，会发现这些原生组件有时会产生一些奇怪的抖动，这一点可以佐证这个论点。）&lt;/p&gt;
&lt;p&gt;所以ios下，我们手指在canvas和cover-view这类原生组件上滑动时，事件是不会传导到webview上的，页面也就不会滑动。&lt;/p&gt;
&lt;h2 id=&quot;最终解决方案&quot;&gt;最终解决方案&lt;/h2&gt;
&lt;p&gt;对于这个问题，因为我这边和echarts的交互比较少，所以我的解决方案就是在echarts渲染完毕后将它替换为一张图片。&lt;/p&gt;
&lt;p&gt;如果我更新了数据，那么就重新放出echarts，等它渲染完毕后，再次替换为一张图片。&lt;/p&gt;
&lt;p&gt;由于公司代码不适合放出，所以我搞了个简易版的代码放在这里。&lt;/p&gt;
&lt;p&gt;wxml文件关键代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;view class=&quot;echart-container&quot;&amp;gt;
  &amp;lt;image wx:if=&quot;{{echartImgSrc!==''}}&quot; src=&quot;{{echartImgSrc}}&quot; class='echart-img'&amp;gt;&amp;lt;/image&amp;gt;
  &amp;lt;ec-canvas wx:if=&quot;{{echartImgSrc===''}}&quot; id=&quot;mychart-dom-pie&quot; canvas-id=&quot;mychart-pie&quot; ec=&quot;{{ ec }}&quot; bind:init=&quot;echartInit&quot;&amp;gt;&amp;lt;/ec-canvas&amp;gt;
&amp;lt;/view&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;js文件关键代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Page({
  data: {
    ec: {
    },
    echartImgSrc: ''
  },
  initChart(canvas, width, height) {
    const chart = echarts.init(canvas, null, {
      width: width,
      height: height
    });
    canvas.setChart(chart);

    var option = {
      // ...
    };
    chart.on('finished', () =&amp;gt; {
      this.selectComponent('#mychart-dom-pie').canvasToTempFilePath({
        success: res =&amp;gt; {
          this.setData({
            echartImgSrc: res.tempFilePath
          })
        },
        fail: res =&amp;gt; console.log('转换图片失败', res)
      });
    })
    chart.setOption(option);
    return chart;
  },

  echartInit(e) {
    this.initChart(e.detail.canvas, e.detail.width, e.detail.height);
  }
});&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;总的来说，解决起来还算简单。&lt;/p&gt;
&lt;p&gt;但是对于和Echarts有很多交互的场景，这个方案就未必那么好实现了。&lt;/p&gt;
&lt;p&gt;从这个问题入手，我对微信小程序原生组件的玩法有了更多的认识。&lt;/p&gt;
&lt;p&gt;更深入一点的认识就是，微信小程序当下对原生组件的这种处理更像是在一件普通的布衣上贴上貂皮补丁。&lt;/p&gt;
&lt;p&gt;虽然考虑到了原生组件所带来的性能优势，但是同样也会引发大量的问题，对于这件衣服的整体表现而言这些貂皮补丁恐怕并不见得是件好事。&lt;/p&gt;
&lt;p&gt;希望以后小程序能从根本上解决这种问题吧。&lt;/p&gt;
</description>
<pubDate>Tue, 09 Jul 2019 15:16:00 +0000</pubDate>
<dc:creator>韩子卢</dc:creator>
<og:description>问题现象 这个问题的现象说起来很简单。 小程序页面中有一篇很长的文章，内部有一个Echarts图表，手指上下滑动观看内容。 但是手指滑动区域在Echarts图表上时，页面却不能滑动了。 如下图： 追踪</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/vvjiang/p/11161103.html</dc:identifier>
</item>
</channel>
</rss>