<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>死磕 java同步系列之zookeeper分布式锁 - 彤哥读源码</title>
<link>http://www.cnblogs.com/tong-yuan/p/11619006.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tong-yuan/p/11619006.html</guid>
<description>&lt;h2 id=&quot;问题&quot;&gt;问题&lt;/h2&gt;
&lt;p&gt;（1）zookeeper如何实现分布式锁？&lt;/p&gt;
&lt;p&gt;（2）zookeeper分布式锁有哪些优点？&lt;/p&gt;
&lt;p&gt;（3）zookeeper分布式锁有哪些缺点？&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;zooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，它可以为分布式应用提供一致性服务，它是Hadoop和Hbase的重要组件，同时也可以作为配置中心、注册中心运用在微服务体系中。&lt;/p&gt;
&lt;p&gt;本章我们将介绍zookeeper如何实现分布式锁运用在分布式系统中。&lt;/p&gt;
&lt;h2 id=&quot;基础知识&quot;&gt;基础知识&lt;/h2&gt;
&lt;h3 id=&quot;什么是znode&quot;&gt;什么是znode？&lt;/h3&gt;
&lt;p&gt;zooKeeper操作和维护的为一个个数据节点，称为 znode，采用类似文件系统的层级树状结构进行管理，如果 znode 节点包含数据则存储为字节数组（byte array）。&lt;/p&gt;
&lt;p&gt;而且，同一个节点多个客户同时创建【本篇文章由公众号“彤哥读源码”原创】，只有一个客户端会成功，其它客户端创建时将失败。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1648938/201910/1648938-20191003081037291-1231870954.png&quot; alt=&quot;zooKeeper&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;节点类型&quot;&gt;节点类型&lt;/h3&gt;
&lt;p&gt;znode 共有四种类型：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;持久（无序）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;持久有序&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;临时（无序）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;临时有序&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其中，持久节点如果不手动删除会一直存在，临时节点当客户端session失效就会自动删除节点。&lt;/p&gt;
&lt;h3 id=&quot;什么是watcher&quot;&gt;什么是watcher？&lt;/h3&gt;
&lt;p&gt;watcher（事件监听器），是zookeeper中的一个很重要的特性。&lt;/p&gt;
&lt;p&gt;zookeeper允许用户在指定节点上注册一些watcher，并且在一些特定事件触发的时候，zooKeeper服务端会将事件通知到感兴趣的客户端上去，该机制是Zookeeper实现分布式协调服务的&lt;strong&gt;重要特性&lt;/strong&gt;。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;11&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;SyncConnected（3）&lt;/td&gt;
&lt;td&gt;None（-1）&lt;/td&gt;
&lt;td&gt;客户端与服务端成功建立连接&lt;/td&gt;
&lt;td&gt;此时客户端和服务器处于连接状态&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;同上&lt;/td&gt;
&lt;td&gt;NodeCreated（1）&lt;/td&gt;
&lt;td&gt;Watcher监听的对应数据节点被创建&lt;/td&gt;
&lt;td&gt;同上&lt;/td&gt;
&lt;td&gt;Create&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;同上&lt;/td&gt;
&lt;td&gt;NodeDeleted（2）&lt;/td&gt;
&lt;td&gt;Watcher监听的对应数据节点被删除&lt;/td&gt;
&lt;td&gt;同上&lt;/td&gt;
&lt;td&gt;Delete/znode&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;同上&lt;/td&gt;
&lt;td&gt;NodeDataChanged（3）&lt;/td&gt;
&lt;td&gt;Watcher监听的对应数据节点的数据内容发生变更&lt;/td&gt;
&lt;td&gt;同上&lt;/td&gt;
&lt;td&gt;setDate/znode&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;同上&lt;/td&gt;
&lt;td&gt;NodeChildChanged（4）&lt;/td&gt;
&lt;td&gt;Wather监听的对应数据节点的子节点列表发生变更&lt;/td&gt;
&lt;td&gt;同上&lt;/td&gt;
&lt;td&gt;Create/child&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;Disconnected（0）&lt;/td&gt;
&lt;td&gt;None（-1）&lt;/td&gt;
&lt;td&gt;客户端与ZooKeeper服务器断开连接&lt;/td&gt;
&lt;td&gt;此时客户端和服务器处于断开连接状态&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Expired（-112）&lt;/td&gt;
&lt;td&gt;None（-1）&lt;/td&gt;
&lt;td&gt;会话超时&lt;/td&gt;
&lt;td&gt;此时客户端会话失效，通常同时也会受到SessionExpiredException异常&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;AuthFailed（4）&lt;/td&gt;
&lt;td&gt;None（-1）&lt;/td&gt;
&lt;td&gt;通常有两种情况，1：使用错误的schema进行权限检查 2：SASL权限检查失败&lt;/td&gt;
&lt;td&gt;通常同时也会收到AuthFailedException异常&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;原理解析&quot;&gt;原理解析&lt;/h2&gt;
&lt;h3 id=&quot;方案一&quot;&gt;方案一&lt;/h3&gt;
&lt;p&gt;既然，同一个节点只能创建一次，那么，加锁时检测节点是否存在，不存在则创建之，存在或者创建失败则监听这个节点的删除事件，这样，当释放锁的时候监听的客户端再次竞争去创建这个节点，成功的则获取到锁，不成功的则再次监听该节点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1648938/201910/1648938-20191003081037503-303705818.png&quot; alt=&quot;zooKeeper&quot;/&gt;&lt;/p&gt;
&lt;p&gt;比如，有三个客户端client1、client2、client3同时获取/locker/user_1这把锁，它们将按照如下步骤运行：&lt;/p&gt;
&lt;p&gt;（1）三者同时尝试创建/locker/user_1节点；&lt;/p&gt;
&lt;p&gt;（2）client1创建成功，它获取到锁；&lt;/p&gt;
&lt;p&gt;（3）client2和client3创建失败，它们监听/locker/user_1的删除事件；&lt;/p&gt;
&lt;p&gt;（4）client1执行锁内业务逻辑；&lt;/p&gt;
&lt;p&gt;（5）client1释放锁，删除节点/locker/user_1；&lt;/p&gt;
&lt;p&gt;（6）client2和client3都捕获到节点/locker/user_1被删除的事件，二者皆被唤醒；&lt;/p&gt;
&lt;p&gt;（7）client2和client3同时去创建/locker/user_1节点；&lt;/p&gt;
&lt;p&gt;（8）回到第二步，依次类推【本篇文章由公众号“彤哥读源码”原创】；&lt;/p&gt;
&lt;p&gt;不过，这种方案有个很严重的弊端——惊群效应。&lt;/p&gt;
&lt;p&gt;如果并发量很高，多个客户端同时监听同一个节点，释放锁时同时唤醒这么多个客户端，然后再竞争，最后还是只有一个能获取到锁，其它客户端又要沉睡，这些客户端的唤醒没有任何意义，极大地浪费系统资源，那么有没有更好的方案呢？答案是当然有，请看方案二。&lt;/p&gt;
&lt;h3 id=&quot;方案二&quot;&gt;方案二&lt;/h3&gt;
&lt;p&gt;为了解决方案一中的惊群效应，我们可以使用有序子节点的形式来实现分布式锁，而且为了规避客户端获取锁后突然断线的风险，我们有必要使用临时有序节点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1648938/201910/1648938-20191003081037694-346519158.png&quot; alt=&quot;zooKeeper&quot;/&gt;&lt;/p&gt;
&lt;p&gt;比如，有三个客户端client1、client2、client3同时获取/locker/user_1这把锁，它们将按照如下步骤运行：&lt;/p&gt;
&lt;p&gt;（1）三者同时在/locker/user_1/下面创建临时有序子节点；&lt;/p&gt;
&lt;p&gt;（2）三者皆创建成功，分别为/locker/user_1/0000000001、/locker/user_1/0000000003、/locker/user_1/0000000002；&lt;/p&gt;
&lt;p&gt;（3）检查自己创建的节点是不是子节点中最小的；&lt;/p&gt;
&lt;p&gt;（4）client1发现自己是最小的节点，它获取到锁；&lt;/p&gt;
&lt;p&gt;（5）client2和client3发现自己不是最小的节点，它们无法获取到锁；&lt;/p&gt;
&lt;p&gt;（6）client2创建的节点为/locker/user_1/0000000003，它监听其上一个节点/locker/user_1/0000000002的删除事件；&lt;/p&gt;
&lt;p&gt;（7）client3创建的节点为/locker/user_1/0000000002，它监听其上一个节点/locker/user_1/0000000001的删除事件；&lt;/p&gt;
&lt;p&gt;（8）client1执行锁内业务逻辑；&lt;/p&gt;
&lt;p&gt;（9）client1释放锁，删除节点/locker/user_1/0000000001；&lt;/p&gt;
&lt;p&gt;（10）client3监听到节点/locker/user_1/0000000001的删除事件，被唤醒；&lt;/p&gt;
&lt;p&gt;（11）client3再次检查自己是不是最小的节点，发现是，则获取到锁；&lt;/p&gt;
&lt;p&gt;（12）client3执行锁内业务逻辑【本篇文章由公众号“彤哥读源码”原创】；&lt;/p&gt;
&lt;p&gt;（13）client3释放锁，删除节点/locker/user_1/0000000002；&lt;/p&gt;
&lt;p&gt;（14）client2监听到节点/locker/user_1/0000000002的删除事件，被唤醒；&lt;/p&gt;
&lt;p&gt;（15）client2执行锁内业务逻辑；&lt;/p&gt;
&lt;p&gt;（16）client2释放锁，删除节点/locker/user_1/0000000003；&lt;/p&gt;
&lt;p&gt;（17）client2检查/locker/user_1/下是否还有子节点，没有了则删除/locker/user_1节点；&lt;/p&gt;
&lt;p&gt;（18）流程结束；&lt;/p&gt;
&lt;p&gt;这种方案相对于方案一来说，每次释放锁时只唤醒一个客户端，减少了线程唤醒的代价，提高了效率。&lt;/p&gt;
&lt;h2 id=&quot;zookeeper原生api实现&quot;&gt;zookeeper原生API实现&lt;/h2&gt;
&lt;h3 id=&quot;pom文件&quot;&gt;pom文件&lt;/h3&gt;
&lt;p&gt;pom中引入以下jar包：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.apache.zookeeper&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;zookeeper&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;3.5.5&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;locker接口&quot;&gt;Locker接口&lt;/h3&gt;
&lt;p&gt;定义一个Locker接口，与上一章mysql分布式锁使用同一个接口。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface Locker {
    void lock(String key, Runnable command);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;zookeeper分布式锁实现&quot;&gt;zookeeper分布式锁实现&lt;/h3&gt;
&lt;p&gt;这里通过内部类ZkLockerWatcher处理zookeeper的相关操作，需要注意以下几点：&lt;/p&gt;
&lt;p&gt;（1）zk连接建立完毕之前不要进行相关操作，否则会报ConnectionLoss异常，这里通过LockSupport.park();阻塞连接线程并在监听线程中唤醒处理；&lt;/p&gt;
&lt;p&gt;（2）客户端线程与监听线程不是同一个线程，所以可以通过LockSupport.park();及LockSupport.unpark(thread);来处理；&lt;/p&gt;
&lt;p&gt;（3）中间很多步骤不是原子的（坑），所以需要再次检测，详见代码中注释；&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Slf4j
@Component
public class ZkLocker implements Locker {
    @Override
    public void lock(String key, Runnable command) {
        ZkLockerWatcher watcher = ZkLockerWatcher.conn(key);
        try {
            if (watcher.getLock()) {
                command.run();
            }
        } finally {
            watcher.releaseLock();
        }
    }

    private static class ZkLockerWatcher implements Watcher {
        public static final String connAddr = &quot;127.0.0.1:2181&quot;;
        public static final int timeout = 6000;
        public static final String LOCKER_ROOT = &quot;/locker&quot;;

        ZooKeeper zooKeeper;
        String parentLockPath;
        String childLockPath;
        Thread thread;

        public static ZkLockerWatcher conn(String key) {
            ZkLockerWatcher watcher = new ZkLockerWatcher();
            try {
                ZooKeeper zooKeeper = watcher.zooKeeper = new ZooKeeper(connAddr, timeout, watcher);
                watcher.thread = Thread.currentThread();
                // 阻塞等待连接建立完毕
                LockSupport.park();
                // 根节点如果不存在，就创建一个（并发问题，如果两个线程同时检测不存在，两个同时去创建必须有一个会失败）
                if (zooKeeper.exists(LOCKER_ROOT, false) == null) {
                    try {
                        zooKeeper.create(LOCKER_ROOT, &quot;&quot;.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
                    } catch (KeeperException e) {
                        // 如果节点已存在，则创建失败，这里捕获异常，并不阻挡程序正常运行
                        log.info(&quot;创建节点 {} 失败&quot;, LOCKER_ROOT);
                    }
                }
                // 当前加锁的节点是否存在
                watcher.parentLockPath = LOCKER_ROOT + &quot;/&quot; + key;
                if (zooKeeper.exists(watcher.parentLockPath, false) == null) {
                    try {
                        zooKeeper.create(watcher.parentLockPath, &quot;&quot;.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
                    } catch (KeeperException e) {
                        // 如果节点已存在，则创建失败，这里捕获异常，并不阻挡程序正常运行
                        log.info(&quot;创建节点 {} 失败&quot;, watcher.parentLockPath);
                    }
                }

            } catch (Exception e) {
                log.error(&quot;conn to zk error&quot;, e);
                throw new RuntimeException(&quot;conn to zk error&quot;);
            }
            return watcher;
        }

        public boolean getLock() {
            try {
                // 创建子节点【本篇文章由公众号“彤哥读源码”原创】
                this.childLockPath = zooKeeper.create(parentLockPath + &quot;/&quot;, &quot;&quot;.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);
                // 检查自己是不是最小的节点，是则获取成功，不是则监听上一个节点
                return getLockOrWatchLast();
            } catch (Exception e) {
                log.error(&quot;get lock error&quot;, e);
                throw new RuntimeException(&quot;get lock error&quot;);
            } finally {
//                System.out.println(&quot;getLock: &quot; + childLockPath);
            }
        }

        public void releaseLock() {
            try {
                if (childLockPath != null) {
                    // 释放锁，删除节点
                    zooKeeper.delete(childLockPath, -1);
                }
                // 最后一个释放的删除锁节点
                List&amp;lt;String&amp;gt; children = zooKeeper.getChildren(parentLockPath, false);
                if (children.isEmpty()) {
                    try {
                        zooKeeper.delete(parentLockPath, -1);
                    } catch (KeeperException e) {
                        // 如果删除之前又新加了一个子节点，会删除失败
                        log.info(&quot;删除节点 {} 失败&quot;, parentLockPath);
                    }
                }
                // 关闭zk连接
                if (zooKeeper != null) {
                    zooKeeper.close();
                }
            } catch (Exception e) {
                log.error(&quot;release lock error&quot;, e);
                throw new RuntimeException(&quot;release lock error&quot;);
            } finally {
//                System.out.println(&quot;releaseLock: &quot; + childLockPath);
            }
        }

        private boolean getLockOrWatchLast() throws KeeperException, InterruptedException {
            List&amp;lt;String&amp;gt; children = zooKeeper.getChildren(parentLockPath, false);
            // 必须要排序一下，这里取出来的顺序可能是乱的
            Collections.sort(children);
            // 如果当前节点是第一个子节点，则获取锁成功
            if ((parentLockPath + &quot;/&quot; + children.get(0)).equals(childLockPath)) {
                return true;
            }

            // 如果不是第一个子节点，就监听前一个节点
            String last = &quot;&quot;;
            for (String child : children) {
                if ((parentLockPath + &quot;/&quot; + child).equals(childLockPath)) {
                    break;
                }
                last = child;
            }

            if (zooKeeper.exists(parentLockPath + &quot;/&quot; + last, true) != null) {
                this.thread = Thread.currentThread();
                // 阻塞当前线程
                LockSupport.park();
                // 唤醒之后重新检测自己是不是最小的节点，因为有可能上一个节点断线了
                return getLockOrWatchLast();
            } else {
                // 如果上一个节点不存在，说明还没来得及监听就释放了，重新检查一次
                return getLockOrWatchLast();
            }
        }

        @Override
        public void process(WatchedEvent event) {
            if (this.thread != null) {
                // 唤醒阻塞的线程（这是在监听线程，跟获取锁的线程不是同一个线程）
                LockSupport.unpark(this.thread);
                this.thread = null;
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;测试代码&quot;&gt;测试代码&lt;/h3&gt;
&lt;p&gt;我们这里起两批线程，一批获取user_1这个锁，一批获取user_2这个锁。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@RunWith(SpringRunner.class)
@SpringBootTest(classes = Application.class)
public class ZkLockerTest {

    @Autowired
    private Locker locker;

    @Test
    public void testZkLocker() throws IOException {
        for (int i = 0; i &amp;lt; 1000; i++) {
            new Thread(()-&amp;gt;{
                locker.lock(&quot;user_1&quot;, ()-&amp;gt; {
                    try {
                        System.out.println(String.format(&quot;user_1 time: %d, threadName: %s&quot;, System.currentTimeMillis(), Thread.currentThread().getName()));
                        Thread.sleep(500);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                });
            }, &quot;Thread-&quot;+i).start();
        }
        for (int i = 1000; i &amp;lt; 2000; i++) {
            new Thread(()-&amp;gt;{
                locker.lock(&quot;user_2&quot;, ()-&amp;gt; {
                    try {
                        System.out.println(String.format(&quot;user_2 time: %d, threadName: %s&quot;, System.currentTimeMillis(), Thread.currentThread().getName()));
                        Thread.sleep(500);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                });
            }, &quot;Thread-&quot;+i).start();
        }

        System.in.read();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;可以看到稳定在500ms左右打印两个锁的结果。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;user_1 time: 1568973299578, threadName: Thread-10
user_2 time: 1568973299579, threadName: Thread-1780
user_1 time: 1568973300091, threadName: Thread-887
user_2 time: 1568973300091, threadName: Thread-1542
user_1 time: 1568973300594, threadName: Thread-882
user_2 time: 1568973300594, threadName: Thread-1539
user_2 time: 1568973301098, threadName: Thread-1592
user_1 time: 1568973301098, threadName: Thread-799
user_1 time: 1568973301601, threadName: Thread-444
user_2 time: 1568973301601, threadName: Thread-1096
user_1 time: 1568973302104, threadName: Thread-908
user_2 time: 1568973302104, threadName: Thread-1574
user_2 time: 1568973302607, threadName: Thread-1515
user_1 time: 1568973302607, threadName: Thread-80
user_1 time: 1568973303110, threadName: Thread-274
user_2 time: 1568973303110, threadName: Thread-1774
user_1 time: 1568973303615, threadName: Thread-324
user_2 time: 1568973303615, threadName: Thread-1621&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;curator实现&quot;&gt;curator实现&lt;/h2&gt;
&lt;p&gt;上面的原生API实现更易于理解zookeeper实现分布式锁的逻辑，但是难免保证没有什么问题，比如不是重入锁，不支持读写锁等。&lt;/p&gt;
&lt;p&gt;下面我们一起看看现有的轮子curator是怎么实现的。&lt;/p&gt;
&lt;h3 id=&quot;pom文件-1&quot;&gt;pom文件&lt;/h3&gt;
&lt;p&gt;pom文件中引入以下jar包：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.apache.curator&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;curator-recipes&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;4.0.0&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.apache.curator&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;curator-framework&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;4.0.0&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;代码实现&quot;&gt;代码实现&lt;/h3&gt;
&lt;p&gt;下面是互斥锁的一种实现方案：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Component
@Slf4j
public class ZkCuratorLocker implements Locker {
    public static final String connAddr = &quot;127.0.0.1:2181&quot;;
    public static final int timeout = 6000;
    public static final String LOCKER_ROOT = &quot;/locker&quot;;

    private CuratorFramework cf;

    @PostConstruct
    public void init() {
        this.cf = CuratorFrameworkFactory.builder()
                .connectString(connAddr)
                .sessionTimeoutMs(timeout)
                .retryPolicy(new ExponentialBackoffRetry(1000, 3))
                .build();

        cf.start();
    }

    @Override
    public void lock(String key, Runnable command) {
        String path = LOCKER_ROOT + &quot;/&quot; + key;
        InterProcessLock lock = new InterProcessMutex(cf, path);
        try {
            // 【本篇文章由公众号“彤哥读源码”原创】
            lock.acquire();
            command.run();
        } catch (Exception e) {
            log.error(&quot;get lock error&quot;, e);
            throw new RuntimeException(&quot;get lock error&quot;, e);
        } finally {
            try {
                lock.release();
            } catch (Exception e) {
                log.error(&quot;release lock error&quot;, e);
                throw new RuntimeException(&quot;release lock error&quot;, e);
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;除了互斥锁，curator还提供了读写锁、多重锁、信号量等实现方式，而且他们是可重入的锁。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;（1）zookeeper中的节点有四种类型：持久、持久有序、临时、临时有序；&lt;/p&gt;
&lt;p&gt;（2）zookeeper提供了一种非常重要的特性——监听机制，它可以用来监听节点的变化；&lt;/p&gt;
&lt;p&gt;（3）zookeeper分布式锁是基于 临时有序节点 + 监听机制 实现的；&lt;/p&gt;
&lt;p&gt;（4）zookeeper分布式锁加锁时在锁路径下创建临时有序节点；&lt;/p&gt;
&lt;p&gt;（5）如果自己是第一个节点，则获得锁；&lt;/p&gt;
&lt;p&gt;（6）如果自己不是第一个节点，则监听前一个节点，并阻塞当前线程；&lt;/p&gt;
&lt;p&gt;（7）当监听到前一个节点的删除事件时，唤醒当前节点的线程，并再次检查自己是不是第一个节点；&lt;/p&gt;
&lt;p&gt;（8）使用临时有序节点而不是持久有序节点是为了让客户端无故断线时能够自动释放锁；&lt;/p&gt;
&lt;h2 id=&quot;彩蛋&quot;&gt;彩蛋&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;zookeeper分布式锁有哪些优点？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答：1）zookeeper本身可以集群部署，相对于mysql的单点更可靠；&lt;/p&gt;
&lt;p&gt;2）不会占用mysql的连接数，不会增加mysql的压力；&lt;/p&gt;
&lt;p&gt;3）使用监听机制，减少线程上下文切换的次数；&lt;/p&gt;
&lt;p&gt;4）客户端断线能够自动释放锁，非常安全；&lt;/p&gt;
&lt;p&gt;5）有现有的轮子curator可以使用；&lt;/p&gt;
&lt;p&gt;6）curator实现方式是可重入的，对现有代码改造成本小；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;zookeeper分布式锁有哪些缺点？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答：1）加锁会频繁地“写”zookeeper，增加zookeeper的压力；&lt;/p&gt;
&lt;p&gt;2）写zookeeper的时候会在集群进行同步，节点数越多，同步越慢，获取锁的过程越慢；&lt;/p&gt;
&lt;p&gt;3）需要另外依赖zookeeper，而大部分服务是不会使用zookeeper的，增加了系统的复杂性；&lt;/p&gt;
&lt;p&gt;4）相对于redis分布式锁，性能要稍微略差一些；&lt;/p&gt;
&lt;h2 id=&quot;推荐阅读&quot;&gt;推荐阅读&lt;/h2&gt;
&lt;p&gt;1、&lt;a href=&quot;https://mp.weixin.qq.com/s/gdQpO7kqnWT41gFd4vXTlQ&quot;&gt;死磕 java同步系列之开篇&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2、&lt;a href=&quot;https://mp.weixin.qq.com/s/0s-u-MysppIaIHVrshp9fA&quot;&gt;死磕 java魔法类之Unsafe解析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3、&lt;a href=&quot;https://mp.weixin.qq.com/s/jownTN--npu3o8B4c3sbeA&quot;&gt;死磕 java同步系列之JMM（Java Memory Model）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4、&lt;a href=&quot;https://mp.weixin.qq.com/s/TROZ4BhcDImwHvhAl_I_6w&quot;&gt;死磕 java同步系列之volatile解析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;5、&lt;a href=&quot;https://mp.weixin.qq.com/s/RT7VreIh9PU03HhE3WSLjg&quot;&gt;死磕 java同步系列之synchronized解析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;6、&lt;a href=&quot;https://mp.weixin.qq.com/s/1RU5jh7UcXGtKlae8tusVA&quot;&gt;死磕 java同步系列之自己动手写一个锁Lock&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;7、&lt;a href=&quot;https://mp.weixin.qq.com/s/nAqgec8GscULz6DkkYFINg&quot;&gt;死磕 java同步系列之AQS起篇&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;8、&lt;a href=&quot;https://mp.weixin.qq.com/s/52Ib23kbmqqkWAZtlZF-zA&quot;&gt;死磕 java同步系列之ReentrantLock源码解析（一）——公平锁、非公平锁&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;9、&lt;a href=&quot;https://mp.weixin.qq.com/s/iipAVWynBUZazhSvBwMB5g&quot;&gt;死磕 java同步系列之ReentrantLock源码解析（二）——条件锁&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;10、&lt;a href=&quot;https://mp.weixin.qq.com/s/o8ZFXDoKhj237SsrqGeJPQ&quot;&gt;死磕 java同步系列之ReentrantLock VS synchronized&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;11、&lt;a href=&quot;https://mp.weixin.qq.com/s/aOQwZ0S8at-64xIXo8fLfA&quot;&gt;死磕 java同步系列之ReentrantReadWriteLock源码解析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;12、&lt;a href=&quot;https://mp.weixin.qq.com/s/ft0_PU7Tgz7920yKy-xisQ&quot;&gt;死磕 java同步系列之Semaphore源码解析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;13、&lt;a href=&quot;https://mp.weixin.qq.com/s/QHFXKVybKz_iwgC8reGfPQ&quot;&gt;死磕 java同步系列之CountDownLatch源码解析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;14、&lt;a href=&quot;https://mp.weixin.qq.com/s/QHFXKVybKz_iwgC8reGfPQ&quot;&gt;死磕 java同步系列之AQS终篇&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;15、&lt;a href=&quot;https://mp.weixin.qq.com/s/6RaFax0ivM6UoDdo5qhtwQ&quot;&gt;死磕 java同步系列之StampedLock源码解析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;16、&lt;a href=&quot;https://mp.weixin.qq.com/s/liFpAAwzQF1PECWYUBVpCg&quot;&gt;死磕 java同步系列之CyclicBarrier源码解析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;17、&lt;a href=&quot;https://mp.weixin.qq.com/s/DytOAfQ9lSUcfHPxfgbZUw&quot;&gt;死磕 java同步系列之Phaser源码解析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;18、&lt;a href=&quot;https://mp.weixin.qq.com/s/Au-_hN-FcL30bIYQbLfZEQ&quot;&gt;死磕 java同步系列之mysql分布式锁&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;欢迎关注我的公众号“彤哥读源码”，查看更多源码系列文章, 与彤哥一起畅游源码的海洋。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1648938/201910/1648938-20191003081037996-1150202390.jpg&quot; alt=&quot;qrcode&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 03 Oct 2019 00:11:00 +0000</pubDate>
<dc:creator>彤哥读源码</dc:creator>
<og:description>问题 （1）zookeeper如何实现分布式锁？ （2）zookeeper分布式锁有哪些优点？ （3）zookeeper分布式锁有哪些缺点？ 简介 zooKeeper是一个分布式的，开放源码的分布式应</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tong-yuan/p/11619006.html</dc:identifier>
</item>
<item>
<title>.NetCore技术研究-.NET Core迁移前的准备工作 - Eric zhou</title>
<link>http://www.cnblogs.com/tianqing/p/11619005.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tianqing/p/11619005.html</guid>
<description>&lt;p&gt;前段时间迁移.NET Core做了大量的试水和评估，今天整理一下分享给大家。大致有以下几个部分：&lt;/p&gt;
&lt;p&gt;1. .NET Core的由来&lt;/p&gt;
&lt;p&gt;2. 为什么要迁移.NET Core&lt;/p&gt;
&lt;p&gt;3. .NET Core3.X主要特性&lt;/p&gt;
&lt;p&gt;4. .NET Standard和.NET Core&lt;/p&gt;
&lt;p&gt;5. .NET Core Roadmap&amp;amp;版本选择&lt;/p&gt;
&lt;p&gt;接下来，我们详细展开说吧。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、.NET Core的由来&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;   这个更像是科普的资料，因为团队的小伙伴有半路出家的，对.NET 的光辉历史不是非常了解，所以有必要带着大家看一遍.NETCore的由来：&lt;/p&gt;
&lt;p&gt;   说.NET Core，需要先说一下.NET. 当年Java刚刚兴起，如火如荼，微软也非常推崇Java，当时Windows平台的Java虚拟机就是微软按照JVM标准实现的，据说也是当时性能最好的Java虚拟机。但是微软也是有私心的，微软总想搞点Windows平台上的特性，有点想把Java绑定到Windows平台上的味道，另外Sun公司确实有点小心眼，于是Sun公司就跟微软闹掰了，然后微软就推出了 .NET，.NET从出生开始其实就借鉴了Java，然后又一步步在语言特性、窗体开发等方面实现了超越。Java在1.6版本以后发展缓慢，后面Java也在语言特性上借鉴了 .NET。&lt;/p&gt;
&lt;p&gt;   .NET虽然一直发展的不错，也有WPF、Unity3D这样具有竞争力框架的出现。但是.NET平台在一些较大的项目，不太受互联网公司的喜爱（虽然京东、当当、携程当年也是.NET技术路线）。但是因为.NET不是开源的框架，也不是可跨平台的框架，那就会带来以下问题：&lt;/p&gt;
&lt;p&gt;     成本：选择.NET就要选择Visual Studio，Windows Server，license是不可忽视的成本；&lt;/p&gt;
&lt;p&gt;     生态：没有来自于社区的贡献，那.NET没有诞生优秀框架的土壤，技术社区虽然有微软的特殊扶持，但是整体不太理想&lt;/p&gt;
&lt;p&gt;     人才：无法吸引一线公司优秀互联网工程师加入，因为他们用Java、Go等，但是.NET Core诞生之后会大为改观，腾讯、网易都有在使用。&lt;/p&gt;
&lt;p&gt;    纵使有Mono这么强大的框架，可以让 .NET 跑在Linux上，但是这还不够。毕竟Mono只能发挥.NET部分有限的能力。&lt;/p&gt;
&lt;p&gt;    同时，云计算的普及，跨平台需求势不可挡，Linux 作为Server的不二OS，.NET不支持Linux，比较尴尬！&lt;/p&gt;
&lt;p&gt;    另外，容器时代已经不可逆转，跟Windows的强依赖，如何上Docker？&lt;/p&gt;
&lt;p&gt;    总之，形式所迫，拥抱变化和未来，.NET Core应运而生。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、为什么要迁移.NET Core&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;   总结了以下几点，大家可以补充：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;.NET Core代表着未来.Net的发展方向&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;产品新特性、重点技术支持微软优先考虑在最新.NET Core版本上支持&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;更优的代码、更好的性能，社区大家都在贡献、优化代码&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;跨平台支持，支持部署在Linux，可以降低VM的成本&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Docker部署支持，更低的成本，更高的资源利用率，未来云原生的核心组成&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;面向现代互联网应用、微服务架构、和DevOps更好地集成&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;开源：https://github.com/dotnet/core&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;更好的生态和社区&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;三、 .NET Core3.X主要特性&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/23525/201910/23525-20191003075107610-855605328.png&quot; alt=&quot;&quot; width=&quot;808&quot; height=&quot;559&quot;/&gt;&lt;/p&gt;
&lt;p&gt;   同时支持Windows和Linux、MacOS，满足不同开发者的需求，对于Web开发提供了ASP.NET Core, 对于常用数据库访问，提供了EF Core，对于机器学习，提供了ML.NET。大家可以根据自己业务的需要，选择合适的技术。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;四、 .NET Standard和.NET Core&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 先说下事情的起源：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; .NET Framework从2002年起，一直在Release新版本，不支持跨平台&lt;/p&gt;
&lt;p&gt; .NET Core是为了支持跨平台产生的，类似的有Mono、Xamarin&lt;/p&gt;
&lt;p&gt;  这样，出现了两套代码、两套类库，对于开发者来说，要同时掌握两套SDK，会产生社区和技术的分裂。&lt;/p&gt;
&lt;p&gt;  因此，.NET 要统一类库标准，统一所有的API定义，这就是.NET Standard. 如下图：&lt;/p&gt;
&lt;p&gt;  &lt;img src=&quot;https://img2018.cnblogs.com/blog/23525/201910/23525-20191003075745073-631768734.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;.NET Standard的统一:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  .NET Standard定义了.NET平台，统一实现的一组API。实现.Net Standard API的平台都与目标.Net Standard库兼容；&lt;/p&gt;
&lt;p&gt;  .NET Framework和.NET Core都是.NET Standard的标准实现。 .NET Standard是二者的交集。&lt;/p&gt;
&lt;p&gt;   但是.NET Framework和.NET Core存在其个性化、扩展的类库，需要牺牲兼容性，即：&lt;/p&gt;
&lt;p&gt;   假如用.NET Framework的个性化SDK。例如注册表、Windows Service、Winform，这样只能部署在Windows中。&lt;/p&gt;
&lt;p&gt;   假如用.NET Core的个性化SDK，部署运行时，与Windows环境下.NET Framework不兼容。&lt;/p&gt;
&lt;p&gt;   所以，如果应用程序采用.NET Standard，同时支持.NET Framework和.NET Core，则可以实现两者的兼容。一套代码既支持运行在.NET Framework运行时下，又支持运行在.NET Core运行时下。&lt;/p&gt;
&lt;p&gt;   同时.NET Standard的版本对应.NET Core、.NET Framework、Mono、Xamarin等的版本，有个对照表：&lt;/p&gt;
&lt;p&gt;   &lt;img src=&quot;https://img2018.cnblogs.com/blog/23525/201910/23525-20191003080031124-409898779.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;   这张表非常重要。体现了一个规则：&lt;/p&gt;
&lt;p&gt;   假如程序的目标框架Targetframework 使用.NET Standard2.0, 则支持：&lt;/p&gt;
&lt;p&gt;   .NET Core 2.0版本的工程可以引用&lt;/p&gt;
&lt;p&gt;   .NET 4.6 版本的工程可以引用&lt;/p&gt;

&lt;p&gt;    但是低版本的.NET Core和.NET Framework则无法引用。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;五 .NET Core Roadmap&amp;amp;版本选择&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 先看一下.NET Core最新的Roadmap：&lt;/p&gt;
&lt;p&gt;  &lt;img src=&quot;https://img2018.cnblogs.com/blog/23525/201910/23525-20191003080432619-1939057448.png&quot; alt=&quot;&quot; width=&quot;886&quot; height=&quot;474&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 最新的.NET Core 3.1 将2019年11月发布，同时是LTS版本。如果大家现在开始迁移.NET Core，建议选择一个大版本、LTS版本。我们也将选择这个版本。&lt;/p&gt;

&lt;p&gt;周国庆&lt;/p&gt;
&lt;p&gt;2019/10/03&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;   &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 03 Oct 2019 00:07:00 +0000</pubDate>
<dc:creator>Eric zhou</dc:creator>
<og:description>前段时间迁移.NET Core做了大量的试水和评估，今天整理一下分享给大家。大致有以下几个部分： 1. .NET Core的由来 2. 为什么要迁移.NET Core 3. .NET Core3.X主</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tianqing/p/11619005.html</dc:identifier>
</item>
<item>
<title>Spring Cloud Config 配置中心实践过程中，你需要了解这些细节！ - Java爱好者社区</title>
<link>http://www.cnblogs.com/ldws/p/11618992.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ldws/p/11618992.html</guid>
<description>&lt;h4 id=&quot;本文导读&quot;&gt;本文导读：&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Spring Cloud Config 基本概念&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Spring Cloud Config 客户端加载流程&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Spring Cloud Config 基于消息总线配置&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Spring Cloud Config 中的占位符&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Spring Cloud Config 仓库最佳实践&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Spring Cloud Config 健康检查问题剖析&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;本文主要介绍 Spring Cloud Config 基本概念、实践过的配置及遇到的问题进行剖析。关于如何启动运行配置中心可以参考官方 Demo。&lt;/p&gt;
&lt;p&gt;本文使用的Spring Cloud 版本：Edgware.SR3&lt;/p&gt;
&lt;h4 id=&quot;spring-cloud-config-基本概念&quot;&gt;&lt;strong&gt;Spring Cloud Config 基本概念&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;Spring Cloud Config 用来为分布式系统中的基础设施和微服务应用提供集中化的外部配置支持。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;服务端：分布式配置中心，独立的微服务应用，用来连接配置仓库（GIT）并为客户端提供获取配置信息、加密/解密等访问接口。、&lt;/li&gt;
&lt;li&gt;客户端：微服务架构中各个微服务应用和基础设施，通过指定配置中心管理应用资源与业务相关的配置内容，启动时从配置中心获取和加载配置信息&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;SCC作用：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;实现了对服务端和客户端中环境变量和属性配置的抽象映射。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;SCC优势：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;默认采用 GIT 存储配置信息，天然支持对配置信息的版本管理。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Spring Cloud Config架构图:&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/836787/201910/836787-20191003074510303-999828217.png&quot; alt=&quot;精简架构图&quot;/&gt;&lt;/p&gt;
&lt;p&gt;基于消息总线的架构图:&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/836787/201910/836787-20191003074510757-1782699610.png&quot; alt=&quot;基于消息总线的架构图&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，架构图中的几个主要元素作用：&lt;br/&gt;远程 GIT 仓库:&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;用来存储配置文件的地方。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Config Server:&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;分布式配置中心，微服务中指定了连接仓库的位置以及账号密码等信息。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本地 GIT 仓库：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;在 Config Server 文件系统中，客户单每次请求获取配置信息时，Config Server 从 GIT 仓库获取最新配置到本地，然后在本地 GIT 仓库读取并返回。当远程仓库无法获取时，直接将本地仓库内容返回。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;ServerA/B：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;具体的微服务应用，他们指定了 Config Server 地址，从而实现外部化获取应用自己想要的配置信息。应用启动时会向 Config Server 发起请求获取配置信息进行加载。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;消息中心：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;上述第二个架构图是基于消息总线的方式，依赖的外部的 MQ 组件，目前支持 Kafka、Rabbitmq。通过 Config Server 配置中心提供的 /bus/refresh endpoint 作为生产者发送消息，客户端接受到消息通过http接口形式从 Config Server 拉取配置。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;服务注册中心：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;可以将 Config Server 注册到服务注册中心上比如 Eureka，然后客户端通过服务注册中心发现Config Server 服务列表，选择其中一台 Config Server 来完成健康检查以及获取远端配置信息。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;spring-cloud-config-客户端加载流程&quot;&gt;&lt;strong&gt;Spring Cloud Config 客户端加载流程&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;客户端应用从配置管理中获取配置执行流程：&lt;/p&gt;
&lt;p&gt;1）应用启动时，根据 bootstrap.yml 中配置的应用名 {application}、环境名 {profile}、分支名 {label}，向 Config Server 请求获取配置信息。&lt;/p&gt;
&lt;p&gt;2）Config Server 根据自己维护的 GIT 仓库信息与客户端传过来的配置定位去查找配置信息。&lt;/p&gt;
&lt;p&gt;3）通过 git clone 命令将找到的配置下载到 Config Server 的文件系统（本地GIT仓库）&lt;/p&gt;
&lt;p&gt;4）Config Server 创建 Spring 的 ApplicationContext 实例，并从 GIT 本地仓库中加载配置文件，最后读取这些配置内容返回给客户端应用。&lt;/p&gt;
&lt;p&gt;5）客户端应用在获取外部配置内容后加载到客户端的 ApplicationContext 实例，该配置内容优先级高于客户端 Jar 包内部的配置内容，所以在 Jar 包中重复的内容将不再被加载。&lt;/p&gt;
&lt;h4 id=&quot;spring-cloud-config-基于消息总线配置&quot;&gt;&lt;strong&gt;Spring Cloud Config 基于消息总线配置&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;Config Server 作为配置中心 pom.xml 引入：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
   &amp;lt;artifactId&amp;gt;spring-cloud-config-server&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
       &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-cloud-starter-bus-kafka&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
       &amp;lt;artifactId&amp;gt;spring-boot-starter-security&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;spring-boot-starter-actuator&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Config Server 配置文件（yml格式）：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;server:
  port: ${CONFIG_SERVER_PORT:8021}
spring:
  application:
    name: letv-mas-config
    # 配置了该项，访问/bus/refresh?destination=应用名:spring.application.index，如果未指定spring.application.index默认使用「应用名:server.port」
    index: ${CONFIG_SERVER_IP:127.0.0.1}
  cloud:
    config:
      server:
        git:
          # 基于 http 协议的单仓库，每一个应用创建一个目录，每个目录下创建配置文件
          uri: ${GIT_URI:http://xxxx/config.git}
          search-paths: '{application}'
          # 配置的 Git 仓库基于 http 协议的，必须配置用户名和密码
          username: ${GIT_USERNAME:config_server}
          password: ${GIT_PASSWORD:config@123}
          # 本地仓库目录设定
          basedir: /letv/app/mas/config/repos
          # 本地仓库如果有脏数据，则会强制拉取（默认是false）
          force-pull: true
          # 配置中心启动后从 GIT 仓库下载，如果uri配置中使用了 {application} 作为仓库名，这里要使用默认值false，否则启动报错.
          clone-on-start: false

management:
  security:
    enabled: false

# 用户认证，客户端应用接入时加入安全认证配置
security:
  user:
    name: config
    password: config2018
  basic:
    enabled: true
# 基于消息总线的 MQ 配置
spring:
  cloud:
    stream:
      kafka:
        binder:
          zk-nodes: ${ZK_NODES:localhost:2181}
          brokers: ${KAFKA_BROKERS:localhost:9092}
          requiredAcks: -1
          configuration:
            security:
              protocol: SASL_PLAINTEXT
            sasl:
              mechanism: PLAIN
          jaas:
            loginModule: org.apache.kafka.common.security.plain.PlainLoginModule
            options:
              username: test
              password: test-secret
    # 开启跟踪事件消息（默认是false）
    bus:
      trace:
        enabled: true
      # 自定义 topic 主题
      destination: test.springcloud.config&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Config Client 作为客户端 pom.xml 引入：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-cloud-starter-config&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
       &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-cloud-starter-bus-kafka&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
       &amp;lt;artifactId&amp;gt;spring-boot-starter-security&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;spring-boot-starter-actuator&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Config Client 配置文件（yml格式）：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;spring:
  application:
    name: letv-mas-client
    index: ${CLIENT_SERVER_IP:127.0.0.1}:${server.port}
  profiles:
    active: ${CLIENT_PROFILE:default}
    #include: busdev,streamdev
  cloud:
    config:
      uri: ${CONFIG_SERVER_DOMAIN:http://config.xxx.cn/}
      failFast: true #the client will halt with an Exception
      enabled: true
      # boostrap.yml 配置优先于启动参数变量 spring.profiles.active
      profile: ${spring.profiles.active:${CLIENT_PROFILE:default}}
      label: master
      # 访问配置中心，用户安全认证
      username: config
      password: config2018
      # 激活定时任务，当 GIT 版本发生变更后加载最新配置上下文
      watcher:
        enabled: true
security:
  user:
    name: config
    password: config2018

# 基于消息总线的 MQ 配置( Kakfa 队列)，如果zipkin中也使用 Kafka 队列，那么需要通过binder 形式配置做隔离，否则会互相影响，无法下发配置消息。
spring:
  cloud:
    stream:
      # 自定义开关
      enabled: true
      # 指定中间件
      default-binder: config-kafka
      binders:
        config-kafka:
          type: kafka
          environment:
            spring:
              cloud:
                stream:
                  kafka:
                    binder:
                      zkNodes: ${ZK_NODES:localhost:2181}
                      brokers: ${KAFKA_BROKERS:localhost:9092}
                      # 生产者确认，0、1、-1，默认为1。0为不确认，1为leader单确认，-1为同步副本确认。-1的情况下消息可靠性更高。
                      required-acks: -1
                      # 是否自动创建topic，默认为true。设为false的情况下，依赖手动配置broker相关topic&amp;gt;配置，如果topic不存在binder则无法启动。
                      auto-create-topics: true
                      configuration:
                        security:
                          protocol: SASL_PLAINTEXT
                        sasl:
                          mechanism: PLAIN
                      jaas:
                        loginModule: org.apache.kafka.common.security.plain.PlainLoginModule
                        options:
                          username: test
                          password: test-secret
    bus:
      # 是否启用bus
      enabled: true
      # Bus 使用的队列或 Topic，Kafka 中的 topic，Rabbitmq 中的 queue
      destination: test.springcloud.config
      trace:
        # 是否启用 Bus 事件跟踪，可以通过 /trace 页面查看
        enabled: true
      refresh:
        # 是否发送 refresh 事件，开启时支持基于 config 文件变更的动态配置
        enabled: true
      env:
        # 是否开启 env 事件，开启时支持直接动态配置相应环境变量，如 /bus/env?arg1=value1&amp;amp;arg2=value2
        enabled: true&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;spring-cloud-config-中的占位符&quot;&gt;&lt;strong&gt;Spring Cloud Config 中的占位符&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;占位符的使用：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;这里的 {application} 代表了应用名，当客户端向 Config Server 发起获取配置请求时，Config Server 会根据客户端的 spring.application.name 信息来填充 {application} 占位符以定位配置资源的存储位置。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;注意：{label} 参数很特别，如果 GIT 分支和标签包含 “/”，那么 {label} 参数在 HTTP 的 URL 中应用使用 “(_)” 替代，以避免改变了 URI 含义，指向到其他 URI 资源。&lt;/p&gt;
&lt;p&gt;为什么要有占位符?&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;当使用 GIT 作为配置中心来存储各个微服务应用的配置文件时，URI 中的占位符的使用可以帮助我们规划和实现通用的仓库配置。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;spring-cloud-config-仓库最佳实践&quot;&gt;&lt;strong&gt;Spring Cloud Config 仓库最佳实践&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;本地仓库：&lt;/strong&gt;&lt;br/&gt;Spring Cloud 的 D、E 版本中默认存储到 /var/folders/ml/9rww8x69519fwqlwlt5jrx700000gq/T/config-repo-2486127823875015066目录下。&lt;/p&gt;
&lt;p&gt;在 B 版本中，未实际测试过，存储到临时目录 /tmp/config-repo-随机数目录下。&lt;br/&gt;为了避免一些不可预知的问题，我们设置一个固定的本地GIT仓库目录。&lt;/p&gt;
&lt;p&gt;通过 &lt;code&gt;spring.cloud.config.server.git.basedir=${user.home}/local-config-repo&lt;/code&gt; 如果${user.home}目录下发现local-config-repo不存在，在Config Server启动后会自动创建，并从GIT远程仓库下载配置存储到这个位置。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;远程仓库实践：&lt;/strong&gt;&lt;br/&gt;单仓库目录：&lt;br/&gt;每一个项目对应一个仓库&lt;br/&gt;&lt;code&gt;spring.cloud.config.server.git.uri=https://gitee.com/ldwds/{application}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;多仓库目录：&lt;br/&gt;同一个仓库下，每个项目一个目录&lt;br/&gt;&lt;code&gt;spring.cloud.config.server.git.uri=https://gitee.com/ldwds/config-repo-demo.git&lt;/code&gt;&lt;br/&gt;&lt;code&gt;spring.cloud.config.server.git.search-paths='{application}'&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;1）单仓库目录注意事项：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;spring.cloud.config.server.git.uri=[https://gitee.com/ldwds/config-repo-demo/](https://gitee.com/ldwds/config-repo-demo/)  
spring.cloud.config.serversearch-paths:’{application}'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;客户端应用启动前，在 config-repo-demo 仓库下创建子目录，子目录名称就是配置中指定的spring.application.name 应用名。&lt;br/&gt;否则，工程中引用的属性找不到，会报如下错误：&lt;br/&gt;&lt;code&gt;Caused by: java.lang.IllegalArgumentException: Could not resolve placeholder 'from' in value &quot;${from}&quot;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;2）多仓库目录注意事项：&lt;br/&gt;这种方式不能设置参数&lt;br/&gt;&lt;code&gt;spring.cloud.config.server.git.force-pull=true&lt;/code&gt; 和 &lt;code&gt;spring.cloud.config.server.git.clone-on-start=true &lt;/code&gt;&lt;br/&gt;否则启动会报错，也很好理解因为使用了 {applicatoin} 作为占位符，没有指明具体的仓库名，所以无法强制拉取远程仓库配置。&lt;/p&gt;
&lt;p&gt;如果你设置了本地仓库目录比如 &lt;code&gt;spring.cloud.config.server.git.basedir=/data/config-repos/local-config-repo&lt;/code&gt; Config Server 启动后会自动创建 /data/config-repos 目录，并创建 config-repo-随机数命名的仓库名录，这个仓库下的内容来自于健康检查的默认仓库app。&lt;/p&gt;
&lt;p&gt;客户端应用启动后，会根据 {application} 应用名去查找该仓库，Config Server 从匹配 Git 仓库并 clone 到 config-repo-随机数的目录下。&lt;/p&gt;
&lt;p&gt;如果 Config Server 重启了，客户端应用通过 /bus/refresh 刷新配置，因为并没有缓存之前的仓库名，所以会自动创建一个 config-repo-随机数 的仓库目录并从 Git clone 数据。&lt;br/&gt;如果 Config Server 已有本地仓库，客户端重启或 /bus/refresh 刷新配置则 Config Server 不会重建新的仓库。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;配置中心本地仓库执行原理：&lt;/strong&gt;&lt;br/&gt;本地仓库是否存在根据 basedir 目录下是否包含.git 隐藏文件。如果本地仓库不存在，则从远端仓库 clone 数据到本地；如果本地仓库存在，则从远程仓库 fetch 最新数据到本地；然后 checkout 到指定 label，从远端仓库 merge 数据，并获取当前 label 分支最新的HEAD 版本，以及默认的应用名 app 作为环境信息返回。&lt;/p&gt;
&lt;h4 id=&quot;spring-cloud-config健康检查问题剖析&quot;&gt;&lt;strong&gt;Spring Cloud Config健康检查问题剖析&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;健康检查 pom.xml 中引入：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-actuator&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;添加上述依赖后，默认开启健康检查。如果不需要健康检查，可以通过 &lt;code&gt;spring.cloud.config.server.health.enabled=false&lt;/code&gt; 参数设定关闭。&lt;/p&gt;
&lt;p&gt;如果配置为: &lt;code&gt;spring.cloud.config.server.git.uri=[https://gitee.com/ldwds/config-repo-demo.git](https://gitee.com/ldwds/config-repo-demo.git)&lt;/code&gt;&lt;br/&gt;默认开启了健康检查，我开始认为默认检查应用名称为 app，profiles 为 default，label 为 null进行监控（源码中看到的）。&lt;/p&gt;
&lt;p&gt;但是 GIT 配置仓库下并没有 app 应用，此时访问 /health，监控状态仍然是 UP？&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
    &quot;status&quot;: &quot;UP&quot;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述理解是错误的，原因分析如下：&lt;/p&gt;
&lt;blockquote readability=&quot;11.573333333333&quot;&gt;
&lt;p&gt;这个主要跟配置中心指定的 GIT 仓库地址有关系，如果仓库地址指定的是 &lt;a href=&quot;https://gitee.com/ldwds/config-repo-demo/&quot;&gt;https://gitee.com/ldwds/&lt;/a&gt;{application} ，检查监视器会将 {application} 替换为默认应用名 app 作为仓库地址，此时会在 {user.home} 目录下创建 config-repo-随机数作为 {application} 应用的本地仓库（如：/Users/liudewei1228/config-repo-7949870192520306956）。&lt;/p&gt;
&lt;p&gt;即使设置了 &lt;code&gt;spring.config.server.git.basedir=${user.home}/local-config-repo/&lt;/code&gt; 也不会被使用到。&lt;br/&gt;为什么？因为 {application} 作为仓库，是个动态的，可能会有多个 {application} 项目仓库，所以不会使用 basedir 特定目录作为本地仓库。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如下参数设置健康检查的配置：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;spring.cloud.config.server.health.repositories.config-repo-demo.name=应用名
spring.cloud.config.server.health.repositories.config-repo-demo.label=分支
spring.cloud.config.server.health.repositories.config-repo-demo.profiles=环境变量&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;找到环境信息即显示状态 UP，此过程出现任何异常（如找不到仓库 NoSuchRespositoryException）就会显示 DOWN 状态。&lt;/p&gt;
&lt;p&gt;在uri中包含 {application} 作为仓库情况下，客户端应用在启用前需提前创建好spring.application.name=config-client应用名作为仓库，否则会导致无法启用。（因为 {application} 被认为是一个项目仓库，并不是一个目录）。&lt;/p&gt;
&lt;p&gt;源码详见：ConfigServerHealthIndicator.java 的 doHealthCheck 方法。&lt;br/&gt;配置正确仓库的 name、label、profiles，访问 /health 接口显示 sources，这个 sources 中的地址无法访问的，实际只是一个标识的作用。&lt;/p&gt;
&lt;p&gt;访问/health结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
        &quot;status&quot;: &quot;UP&quot;,
        &quot;repositories&quot;: [
                {
                        &quot;sources&quot;: [
                                &quot;https://gitee.com/ldwds/config-repo-demo/config-client/config-client.properties&quot;;            
            ],
                        &quot;name&quot;: &quot;config-client&quot;,
                        &quot;profiles&quot;: [
                                &quot;default&quot;            
            ],
                        &quot;label&quot;: &quot;master&quot;        
        }    
    ]
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;否则，找不到指定仓库的信息，只会显示如下信息：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
        &quot;status&quot;: &quot;UP&quot;,
        &quot;repositories&quot;: [
                {
                        &quot;name&quot;: &quot;config-client&quot;,
                        &quot;profiles&quot;: [
                                &quot;default&quot;            
            ],
                        &quot;label&quot;: &quot;master&quot;        
        }    
    ]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最新 Spring Cloud Config 改进了很多问题，大家可以结合官网进一步学习了解。&lt;/p&gt;
&lt;p&gt;本文对 Spring Cloud Config （Spring Cloud E 版本）的基本概念、基于消息总线的配置使用、仓库目录实践、健康检查的实践以及实践中遇到的问题进行了剖析，希望有使用到这个配置中心的朋友们有所帮助。&lt;/p&gt;
&lt;p&gt;目前微服务架构中选型时，推荐使用国内开源的配置中心：Apollo配置中心（携程开源）、Nacos注册&amp;amp;配置中心（阿里巴巴开源）。&lt;/p&gt;
&lt;p&gt;欢迎关注我的公众号，扫码关注，解锁更多精彩文章，与你一同成长~&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/836787/201909/836787-20190927212913687-1526930336.png&quot; alt=&quot;Java爱好者社区&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 02 Oct 2019 23:45:00 +0000</pubDate>
<dc:creator>Java爱好者社区</dc:creator>
<og:description>本文导读： Spring Cloud Config 基本概念 Spring Cloud Config 客户端加载流程 Spring Cloud Config 基于消息总线配置 Spring Cloud</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ldws/p/11618992.html</dc:identifier>
</item>
<item>
<title>Spring Environment的加载 - 啊驼</title>
<link>http://www.cnblogs.com/cxyAtuo/p/11618979.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cxyAtuo/p/11618979.html</guid>
<description>&lt;p&gt; 这节介绍environment，默认环境变量的加载以及初始化。&lt;/p&gt;
&lt;p&gt; 之前在介绍spring启动过程讲到，第一步进行环境准备时就会初始化一个StandardEnvironment。下图为Environment类图的接口，可以分为4块内容：&lt;/p&gt;
&lt;ol readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;ConversionService（蓝）：类型转换服务&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;PropertySource（绿）:键值对数据源&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;PropertyResolver（红）:键值对服务，包括类型转换&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Environment（紫）:环境配置数据服务&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1812801/201910/1812801-20191003070325259-1095997445.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;conversionservice&quot;&gt;1.ConversionService&lt;/h4&gt;
&lt;p&gt; 提供了类型转换服务，能将源目标转换为目标类型，同时提供了管理功能，内部维护了各类型转换映射关系。其实从ConversionService和ConverterRegistry接口就能看出该模块的功能，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1812801/201910/1812801-20191003070325595-296952592.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt; ConversionService接口为主要的对外功能接口，提供查询的能力。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1812801/201910/1812801-20191003070325828-1861373332.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt; ConverterRegistry接口为主要的管理接口，提供添加和删除的能力。而ConfigurableConversionService继承自上面二者，则提供了Converter的CRUD功能。结构上也延续了Spring固有的风格，将执行接口作为主要功能对外提供单一的接口，再通过继承的方式，以Configurable开头的子接口，扩展出管理功能，使得责任分离更加立体。&lt;/p&gt;
&lt;p&gt; 接下来是GenericConversionService类，该类提供了接口全部实现，下图展示了其主要实现:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1812801/201910/1812801-20191003070326162-1946144296.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt; GenericConversionService结构上可以说是一个小型的管理系统，内部维护了一个Converters对象，用于“底层”管理所有的GenericConverter。同时还维护了一个ConcurrentReferenceHashMap用于缓存常用的GenericConverter。&lt;/p&gt;
&lt;p&gt; Converters在存储GenericConverter时还进行了分类，如果GenericConverter有指定能够解析的类别（ConvertiablePair：包括SourceType和TargetType）时，则使用一个LinkedHashMap按Key Value进行存储，在存储时会遍历可解析的类别，将该GenericConverter追加到对应的Value列表末尾，因而可以看到该Map的Value是一个LinkedList。对应没有指定能解析的类别的GenericConverter，则直接放到LinkedHashSet维护的集合中。&lt;/p&gt;
&lt;p&gt; Converters在查询时会遍历源类型和目标类型的组合结果，以查找匹配的目标GenericConverter对象。如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1812801/201910/1812801-20191003070326514-1936596209.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 对于getRegisteredConverter方法，会先使用Key从LinkedHashMap中查找是否有匹配的Converter,再遍历相应的Value,查找到能处理的转换器。若Map中无法查到，则遍历LinkedHashSet，以查到到能处理的转换器。&lt;/p&gt;
&lt;p&gt; 由上知道，Converters在查找时存在多次遍历列表的过程，在频率过多时效率会比较低下，因而GenericConversionService内部维护了一个ConcurrentReferenceHashMap提供缓存的功能，该Map提供了同ConcurrentHashMap相同的功能，但是能够存储对应的软引用，从而能在内存不足时自动进行内存回收。在查到转换器时，会先试着从缓存中查找，如果获取不到，则会转而从Converters中查找，当从Converters中查找到后便会put到ConcurrentReferenceHashMap缓存中。&lt;/p&gt;
&lt;p&gt; DefaultConversionService是一个单例，继承自GenericConversionService，在初始化后自动添加了默认的转换器，包括Scalar相关的、集合相关的等转换器。&lt;/p&gt;
&lt;h4 id=&quot;propertysource&quot;&gt;2.PropertySource&lt;/h4&gt;
&lt;p&gt; PropertySource代表了一个包含键值对的数据源。从类定义上看，有一个表示数据源名字的name字段，还有一个表示具体数据源泛型T的source字段。而数据源的设置则是通过构造方法传入的，同时方法提供了通过键名获取键值的抽象方法getProperty。此外还有其他抽象方法，如containsProperty等。&lt;/p&gt;
&lt;p&gt; EnumerablePropertySource继承自PropertySource，增加了getPropertyNames方法，要求子类返回内存持有的键名列表。同时实现了containsProperty方法，通过判断所给的键名是否存在上述返回的键名列表中从而判断是否包含该键名。&lt;/p&gt;
&lt;p&gt; MapPropertySource继承自EnumerablePropertySource，顾名思义，内部通过Map维护各键值对内容。类似的还有PropertiesPropertySource，内部通过Properties维护各键值对内容。&lt;/p&gt;
&lt;p&gt; SystemEnvironmentPropertySource是MapPropertySource的装饰器，继承自MapPropertySource，为其添加了键名转换功能，以应对环境变量、shell参数的环境。在通过键名获取键值时，会先根据原键名进行查找，查找不到则通过对键进行转换再尝试查找，具体查找过程为：&lt;/p&gt;
&lt;ol readability=&quot;1&quot;&gt;&lt;li&gt;
&lt;p&gt;通过name查找&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;将name中的 . 转换为 _ 查找&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;将name中的 – 转换为 _ 查找&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;将name中的 . 和 _ 转换为 – 查找&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;将name转换为大写，再进行（1） - （4）的过程&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt; PropertySources的实现如下，扩展了PropertySource接口，将单个数据源的能力扩展到了多个。MutablePropertySources作为PropertySources的实现，内部维护了一个List对象，用以存储多个数据源，并将自身的行为封装为List。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1812801/201910/1812801-20191003070326789-2104359592.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;propertyresolver&quot;&gt;3.PropertyResolver&lt;/h4&gt;
&lt;p&gt; PropertyResolver定义了一系列接口，以提供了对外根据键名获取相应值的功能，同时提供了类型转换和占位符替换的功能，是ConversionService和PropertySource的结合。ConfigurablePropertyResolver接口继承自PropertyResolver接口，老规则，扩展了设置的功能，主要是设置类型转换器和占位符的相关属性。&lt;/p&gt;
&lt;p&gt; AbstractPropertyResolver提供了除PropertySource功能外的其余实现。使用DefaultConversionService作为默认的类型转换实现，使用 ${ 和 } 作为占位符的前后缀，使用:作为默认值分割符，同时引入PropertyPlaceholderHelper用于占位符的解析和替换。而getProperty的实现则留到了了子类PropertySourcesPropertyResolver中，其引入了PropertySources用以维护多个键值对数据源。获取指定属性值过程如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1812801/201910/1812801-20191003070327137-1385712600.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 通过遍历数据源的方式，查到对应的值后，会进行占位符的替换，替换完占位符后会进行类型的转换。类型转换直接用的DefaultConversionService，这个上面已经介绍过了，下面介绍占位符替换。&lt;/p&gt;
&lt;p&gt; 占位符替换的功能是在PropertyResolver接口中定义的，分为严格和不严格模式，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1812801/201910/1812801-20191003070327378-1893398871.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt; resolvePlaceholders为不严格模式，如果没法替换占位符，则直接忽略，resolveRequiredPlaceholders为严格模式，如果占位符没法替换则会抛出异常。如上面说的，AbstractPropertyResolver实现时都委托给PropertyPlaceholderHelper的replacePlaceholders方法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1812801/201910/1812801-20191003070327614-1323758561.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 如上，该方法要求传入一个源字符串，同时提供一个PlaceholderResolver数据源，一遍解析出占位符内容后能够从数据源中获取对应的值。为了保持类功能的单一职责，从而增加了一个内部接口PlaceholderResolver。上面提到，在这个模块中的键值对数据源都是由PropertySourcesPropertyResolver维护的，事实上上面方法截图的实现中，getPropertyAsRawString方法也确实是由PropertySourcesPropertyResolver提供实现的，下面看下占位符的解析。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1812801/201910/1812801-20191003070328003-1787185377.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 占位符的解析过程如上流程，主要过程为：&lt;/p&gt;
&lt;ol readability=&quot;8.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;根据${前缀得到startIndex&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;查找跟${前缀配对的}后缀，如${xxx${yy}z}，得到第二个}后缀的下标endIndex&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;截取${和}中间的内容得到placeholder&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;由于placeholder的内容可能也可能包含占位符，因而要递归处理placeholder，既占位符可以嵌套，内层的结果可以当做外层的Key使用&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;placeholder解析完后，将其作为Key从键值对源中获取对应的值propVal&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;如果propVal值为空，则判断是否存在:分割符，如果有分割符，则进行分割，并使用前端内容作为Key再次查找值。若该次查找结果不为空，则使用该次结果为propVal的值，否则使用第二段内容作为默认值&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;若第（5）/（6）步中propVal结果不为空，则判断从键值对源中获取的值是否也有占位符，若有占位符，则再次进行解析，若没有，则将结果替换回原字段中，更新startIndex，继续下次解析。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;若第（5）/（6）步中propVal结果不空，则会根据设置的解析模式来判断下一步行为，如果未不严格模式，则跳过该次内容，更新startIndex，继续下一次解析，若为严格模式，则抛出异常，流程结束。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt; 下面以一个例子进行演示，如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1812801/201910/1812801-20191003070328292-1602070338.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt;输出结果为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1812801/201910/1812801-20191003070328527-1938796859.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 若将解析模式设置为严格模式则会抛出异常&lt;/p&gt;
&lt;h4 id=&quot;environment&quot;&gt;4.Environment&lt;/h4&gt;
&lt;p&gt; Environment继承自PropertyResolver接口，增加了Profiles功能，即我们平时看到的，多环境特性，能够在不同环境下加载不同的配置。ConfigurableEnvironment继承自Environment，老规矩，又是添加了修改的扩展接口，同时增加了获取系统参数的接口。另外，该接口也继承自ConfigurablePropertyResolver，有了键值对数据源管理、获取和处理的能力，集合Environment接口的功能，能够达到在不同环境下通过加载不同配置源实现环境隔离的效果。&lt;/p&gt;
&lt;p&gt; AbstractEnvironment是ConfigurablePropertyResolver的实现，提供了默认的环境源default，同时内部组合使用PropertySourcesPropertyResolver作为PropertyResolver的实现。&lt;/p&gt;
&lt;p&gt; 它还维护了一个MutablePropertySources对象，用于存储多个数据源，在Context的父子上下文中，通过merge方法，能够将父上文中的环境变量内容添加进来（在AbstractApplicationContext设置父Context时，会将父Environment进行合并）。同时还有一个方法customizePropertySources，会在构造方法中进行调用，开放给子类添加默认的键值对源，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1812801/201910/1812801-20191003070328725-1852431328.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 最后是StandardEnvironment类，继承自AbstractEnvironment，重写了customizePropertySources方法，在该方法中添加了系统相关的属性和应用环境变量相关的属性的键值对源。如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1812801/201910/1812801-20191003070328977-1492419701.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 而这两个数据源来自于前面提到的PropertySource实现。其中，系统相关属性&lt;code&gt;SYSTEM_PROPERTIES_PROPERTY_SOURCE_NAME&lt;/code&gt;的数据源来源于&lt;code&gt;System.getProperties()&lt;/code&gt;，而应用环境变量相关属性&lt;code&gt;SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME&lt;/code&gt;则来源于&lt;code&gt;System.getenv()&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1812801/201910/1812801-20191003070329290-1767050127.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt;个人公众号：啊驼&lt;/p&gt;
</description>
<pubDate>Wed, 02 Oct 2019 23:04:00 +0000</pubDate>
<dc:creator>啊驼</dc:creator>
<og:description>&amp;emsp;这节介绍environment，默认环境变量的加载以及初始化。 &amp;emsp;之前在介绍spring启动过程讲到，第一步进行环境准备时就会初始化一个StandardEnvironment。下</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cxyAtuo/p/11618979.html</dc:identifier>
</item>
<item>
<title>Excel VBA入门（十）用户窗体开发 - 东围居士</title>
<link>http://www.cnblogs.com/wuzhiblog/p/vba_ten.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wuzhiblog/p/vba_ten.html</guid>
<description>&lt;p&gt;VBA 中的用户窗体就是指带 UI 的用户界面，在运行的时候会单独弹出一个窗口，类似于在 windows 系统中运行的一个可执行程序一样（这个说法不太严谨，因为可执行程序也可能是只有命令窗口而没有 UI 的）。再具体一点，就是一个窗口界面当中，有可能会包含有文本框、复选框、单选按钮、下拉列表，就如在网页中填写的表单一样。再具体一点，就是如下图这样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/983631/201910/983631-20191002214731114-1438812718.png&quot; alt=&quot;用户窗体示例&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;用户界面设计&quot;&gt;1. 用户界面设计&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/983631/201910/983631-20191002215135657-389921167.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图，UI 设计的部分其实是很简单的，微软的特色，直接拖拉拽就可以实现了。而每一个控件（或者称为元素，也即放进窗体中的各种按钮、输入框等等）的属性，可以在选中它之后，在默认位于左下角的 “属性” 列表框中进行设置，可设置项包含按钮的名字、前景色、背景色、显示出来的文本、宽度、高度、字体颜色、字号、距离左侧的距离、距离顶部的距离等等，很简单。如果这个 “属性” 框没有出现的话，可以在顶部菜单栏的 “视图” 中选择 “属性窗口”，它就会出现了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/983631/201910/983631-20191002215647148-596833378.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;用户交互&quot;&gt;2. 用户交互&lt;/h2&gt;
&lt;h3 id=&quot;按钮事件&quot;&gt;2.1 按钮事件&lt;/h3&gt;
&lt;p&gt;直接在窗体中双击放进去的按钮，就可以进入到按钮的事件开发界面，默认的是单击事件，如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/983631/201910/983631-20191002220122942-926378273.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;留意上图中的红框部分，左上角显示的是该按钮的名称，右上角显示的是该按钮的事件，这里是单击事件 &lt;code&gt;Click&lt;/code&gt;，这两个都是下拉选择框，分别点击它们右边的倒三角可以看到其它的控件和各控件对应的其它方法，如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/983631/201910/983631-20191002220330898-617933457.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/983631/201910/983631-20191002220321213-463734637.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果你选中了其它事件，则 VBE 会自动给你生成这个事件的函数签名，它是根据按钮的名称和事件名称来命名的，所以这个函数名字应该是不能改动的（我没有试过改）&lt;/p&gt;
&lt;p&gt;其它按钮的事件也类似，就不赘述了。&lt;/p&gt;
&lt;h3 id=&quot;获取控件的值&quot;&gt;2.2 获取控件的值&lt;/h3&gt;
&lt;p&gt;因为控件很多，就不能一一举例了，只举几具做为示例，其它也类似的，通常都是它在属性列表中叫什么，就能通过这个名字来取到它的值&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;文本框&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假设文本框名为 tbx，则通过 &lt;code&gt;tbx.Value&lt;/code&gt; 或者 &lt;code&gt;tbx.Text&lt;/code&gt; 都能得到输入到文本框中的内容&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;多选按钮&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假设多选按钮名为 cbx，则通过 &lt;code&gt;cbx.Value&lt;/code&gt; 可以得到这个多选按钮的值，如果它被选中了，则值为 True，否则为 False。通过 &lt;code&gt;cbx.Caption&lt;/code&gt; 可以得到这个多选按钮对应的文本&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;单选按钮&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假设单选按钮名为 obtn，则通过 &lt;code&gt;obtn.Value&lt;/code&gt; 可以得到这个多选按钮的值，如果它被选中了，则值为 True，否则为 False。通过 &lt;code&gt;cbx.Caption&lt;/code&gt; 可以得到这个多选按钮对应的文本&lt;/p&gt;
&lt;h2 id=&quot;历遍所有控件&quot;&gt;3. 历遍所有控件&lt;/h2&gt;
&lt;p&gt;比如一个窗体中，存在多个多选框，要一个个去判断它是否被选中，此时可以考虑历遍所有控件，通过判断控件类型的方法来获取多选框。&lt;/p&gt;
&lt;p&gt;先看如下代码：&lt;/p&gt;
&lt;pre class=&quot;vb&quot;&gt;
&lt;code&gt;orderStr = &quot;&quot;
For Each ctrls In Me.Controls
    If TypeName(ctrls) = &quot;CheckBox&quot; Then
        If ctrls.Value = True Then
            orderStr = orderStr &amp;amp; &quot;||&quot; &amp;amp; ctrls.Caption
        End If
    End If
Next ctrls&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Me.Controls&lt;/code&gt; 是一个固定的写法，&lt;code&gt;Me&lt;/code&gt; 代表当前窗体，而 &lt;code&gt;Controls&lt;/code&gt; 则表示窗体上的所有控件。用 &lt;code&gt;TypeName&lt;/code&gt; 函数来判断每个控件的类型，然后就可以对不同的控件执行不同的操作了&lt;/p&gt;
&lt;h2 id=&quot;动态生成控件&quot;&gt;4. 动态生成控件&lt;/h2&gt;
&lt;p&gt;即不再使用人工的方式来拖拉拽设置控件，而是在 VBA 代码中来根据条件来动态地添加控件到窗体中。&lt;/p&gt;
&lt;p&gt;先看代码：&lt;/p&gt;
&lt;pre class=&quot;vb&quot;&gt;
&lt;code&gt;For Each order In orderArr
    Set newCbk = form_combinedModel.Controls.Add(&quot;Forms.CheckBox.1&quot;)
    With newCbk
        .Left = 30
        .Top = y
        .Width = 80
        .Height = 18
        .Caption = order
    End With
    y = y + gap
    panelH = panelH + gap
Next order&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的 &lt;code&gt;orderArr&lt;/code&gt; 是一个数组，所以可以使用 &lt;code&gt;For Each&lt;/code&gt; 来历遍它。重点在于第 2 行，这里的 &lt;code&gt;form_combinedModel&lt;/code&gt; 是窗体的名字，通过它的 &lt;code&gt;.Controls.Add&lt;/code&gt; 方法就能够添加新控件。这个方法的参数是固定的，需要添加什么类型的控件就使用对应的参数，示例代码中添加的是多选框，对应的是 &lt;code&gt;Forms.CheckBox.1&lt;/code&gt;，这个参数可以在 &lt;a href=&quot;https://docs.microsoft.com/en-us/office/vba/language/reference/user-interface-help/add-method-microsoft-forms&quot;&gt;这里&lt;/a&gt; 找到。&lt;/p&gt;
&lt;p&gt;此外要注意的是，这个新添加的控件是一个对象，所以需要在变量前面使用 &lt;code&gt;Set&lt;/code&gt; 关键字。示例代码中接下来的 &lt;code&gt;With&lt;/code&gt; 语句，是用于设置这个新的控件的属性，这里设置了它的位置（左距、上距）、宽度、高度、显示文本&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;本系列教程其它文章&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/wuzhiblog/p/vba_zero.html&quot;&gt;Excel VBA 入门（零）&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://www.cnblogs.com/wuzhiblog/p/vba_one.html&quot;&gt;Excel VBA 入门（一）数据类型&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://www.cnblogs.com/wuzhiblog/p/vba_two.html&quot;&gt;Excel VBA 入门（二）数组和字典&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://www.cnblogs.com/wuzhiblog/p/vba_three.html&quot;&gt;Excel VBA 入门（三） 流程控制1－条件选择&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://www.cnblogs.com/wuzhiblog/p/vba_four.html&quot;&gt;Excel VBA 入门（四）流程控制2－循环控制&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://www.cnblogs.com/wuzhiblog/p/VBA_five.html&quot;&gt;Excel VBA 入门（五）Excel对象操作&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://www.cnblogs.com/wuzhiblog/p/vba_six.html&quot;&gt;Excel VBA 入门（六）过程和函数&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://www.cnblogs.com/wuzhiblog/p/vba_seven.html&quot;&gt;Excel VBA 入门（七）注释、宏按钮及错误处理&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://www.cnblogs.com/wuzhiblog/p/vba_eight.html&quot;&gt;Excel VBA 入门（八）单元格边框&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/wuzhiblog/p/vba_nine.html&quot;&gt;Excel VBA 入门（九）操作工作薄&lt;/a&gt;&lt;br/&gt;Excel VBA入门（十）用户窗体开发&lt;/p&gt;
</description>
<pubDate>Wed, 02 Oct 2019 14:41:00 +0000</pubDate>
<dc:creator>东围居士</dc:creator>
<og:description>VBA 中的用户窗体就是指带 UI 的用户界面，在运行的时候会单独弹出一个窗口，类似于在 windows 系统中运行的一个可执行程序一样（这个说法不太严谨，因为可执行程序也可能是只有命令窗口而没有 U</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wuzhiblog/p/vba_ten.html</dc:identifier>
</item>
<item>
<title>从二叉查找树到B+树中间的各种树 - 秃桔子</title>
<link>http://www.cnblogs.com/godoforange/p/11618643.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/godoforange/p/11618643.html</guid>
<description>&lt;p&gt;高强度训练第十八天总结:&lt;/p&gt;
&lt;h2 id=&quot;二叉查找树&quot;&gt;二叉查找树：&lt;/h2&gt;
&lt;p&gt;二叉查找树就是左结点小于根节点，右结点大于根节点的一种排序树，也叫二叉搜索树。也叫BST，英文Binary Sort Tree。&lt;br/&gt;就长下面这吊样&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1590876/201910/1590876-20191002205837061-345530396.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;查找步骤&quot;&gt;查找步骤&lt;/h3&gt;
&lt;p&gt;在二叉搜索树b中查找x的过程为：&lt;/p&gt;
&lt;p&gt;若b是空树，则搜索失败，否则：&lt;br/&gt;若x等于b的根节点的数据域之值，则查找成功；否则：&lt;br/&gt;若x小于b的根节点的数据域之值，则搜索左子树；否则：&lt;br/&gt;查找右子树。&lt;br/&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/422101/201609/422101-20160914180623367-268046051.gif&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;二叉搜索树的构造&quot;&gt;二叉搜索树的构造&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/422101/201609/422101-20160914180633648-1967343454.gif&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;往bst中插入元素&quot;&gt;往BST中插入元素&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/422101/201609/422101-20160914180644617-1773610852.gif&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;bst转成有序数组&quot;&gt;BST转成有序数组&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/422101/201609/422101-20160914180656633-354099265.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;二叉查找树比普通树查找更快，查找、插入、删除的时间复杂度为O（logN）。但是二叉查找树有一种极端的情况，就是会变成一种线性链表似的结构。此时时间复杂度就变味了O（N），为了解决这种情况，出现了二叉平衡树。&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;平衡二叉树&quot;&gt;平衡二叉树&lt;/h2&gt;
&lt;p&gt;平衡二叉树全称平衡二叉搜索树，也叫AVL树。是一种自平衡的树。&lt;/p&gt;
&lt;p&gt;AVL树也规定了左结点小于根节点，右结点大于根节点。并且还规定了左子树和右子树的高度差不得超过1。这样保证了它不会成为线性的链表。AVL树的查找稳定，查找、插入、删除的时间复杂度都为O（logN），但是由于要维持自身的平衡，所以进行插入和删除结点操作的时候，需要对结点进行频繁的旋转。&lt;/p&gt;
&lt;h3 id=&quot;一个有序数组被插入到平衡二叉树&quot;&gt;一个有序数组被插入到平衡二叉树&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1590876/201910/1590876-20191002210435169-165869052.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1590876/201910/1590876-20191002210802959-2128962408.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;右旋&quot;&gt;右旋&lt;/h3&gt;
&lt;p&gt;　我们知道，AVL树不仅是一颗二叉查找树，它还有其他的性质。如果我们按照一般的二叉查找树的插入方式可能会破坏AVL树的平衡性。同理，在删除的时候也有可能会破坏树的平衡性，所以我们要做一些特殊的处理，包括：单旋转和双旋转！&lt;/p&gt;
&lt;p&gt;　　AVL树的插入，单旋转的第一种情况---右旋：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1590876/201910/1590876-20191002211158860-752153638.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在插入之前树是一颗AVL树，而插入之后结点T的左右子树高度差的绝对值不再 &amp;lt; 1,此时AVL树的平衡性被破坏，我们要对其进行旋转。由上图可知我们是在结点T的左结点的左子树上做了插入元素的操作，我们称这种情况为左左情况，我们应该进行右旋转(只需旋转一次，故是单旋转)。具体旋转步骤是：&lt;/p&gt;
&lt;p&gt;　　T向右旋转成为L的右结点，同时，Y放到T的左孩子上。这样即可得到一颗新的AVL树，旋转过程图如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1590876/201910/1590876-20191002211249491-1202695680.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;另一个：&lt;/em&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1590876/201910/1590876-20191002211527801-1636786896.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以上就是插入操作时的单旋转情况！我们要注意的是：谁是T谁是L，谁是R还有谁是X,Y,Z!T始终是开始不平衡的左右子树的根节点。显然L是T的左结点，R是T的右节点。X、Y、Y是子树当然也可以为NULL.NULL归NULL，但不能破坏插入时我上面所说的左左情况或者右右情况。&lt;/p&gt;
&lt;h3 id=&quot;avl树的插入双旋转的第一种情况---左右先左后右旋&quot;&gt;AVL树的插入，双旋转的第一种情况---左右(先左后右)旋&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1590876/201910/1590876-20191002213300544-388860755.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们在T结点的左结点的右子树上插入一个元素时，会使得根为T的树的左右子树高度差的绝对值不再 &amp;lt; 1，如果只是进行简单的右旋，得到的树仍然是不平衡的。我们应该按照如下图所示进行二次旋转：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1590876/201910/1590876-20191002213506510-234655670.png&quot;/&gt;&lt;br/&gt;左右旋转&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1590876/201910/1590876-20191002213542415-73487612.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;avl树的插入双旋转的第二种情况---右左先右后左旋&quot;&gt;AVL树的插入，双旋转的第二种情况---右左(先右后左)旋：&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1590876/201910/1590876-20191002213623239-975413628.png&quot;/&gt;&lt;br/&gt;由上图可知，我们在T结点的右结点的左子树上插入一个元素时，会使得根为T的树的左右子树高度差的绝对值不再 &amp;lt; 1，如果只是进行简单的左旋，得到的树仍然是不平衡的。我们应该按照如下图所示进行二次旋转：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1590876/201910/1590876-20191002213706455-2002607346.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;AVL树每一个节点只能存放一个元素，并且每个节点只有两个子节点。当进行查找时，就需要多次磁盘IO，（数据是存放在磁盘中的，每次查询是将磁盘中的一页数据加入内存，树的每一层节点存放在一页中，不同层数据存放在不同页。）这样如果需要多层查询就需要多次磁盘IO。为了解决AVL树的这个问题，就出现了B树。但是在学B树之前，我们需要看一下多路查找树。&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;多路查找树&quot;&gt;多路查找树&lt;/h2&gt;
&lt;p&gt;多路查找树的每一个节点的孩子树可以多于两个，且每个节点处可以存储多个元素。多路查找树是一种特殊的查找树，所以其元素之间存在某种特定的排序关系。&lt;/p&gt;
&lt;h3 id=&quot;树&quot;&gt;2-3树&lt;/h3&gt;
&lt;p&gt;定义2-3树中每一个节点都具有两个孩子(我们称它为2节点)或三个孩子(我们称它为3节点)。&lt;/p&gt;
&lt;ol readability=&quot;2&quot;&gt;&lt;li&gt;一个2节点包含一个元素和两个孩子(只能包含两个孩子或没有孩子，不能出现有一个孩子的情况)，且与二叉排序树类似，左子树包含的元素小于该元素，右子树包含的元素大于该元素。&lt;/li&gt;
&lt;li readability=&quot;7&quot;&gt;
&lt;p&gt;一个3节点包含一小一大两个元素和三个孩子(只能包含三个孩子或没有孩子，不能出现有一个孩子或有两个孩子的情况)。如果某个3节点有孩子，左子树包含小于较小元素的元素，右子树包含大于较大元素的元素，中间子树包含介于两元素之间的元素。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1590876/201910/1590876-20191002215112617-722631505.png&quot;/&gt;&lt;br/&gt;一颗完美平衡的2-3查找树中的所有空链接到根结点的距离都是相同的。&lt;/p&gt;
&lt;h4 id=&quot;查找&quot;&gt;查找&lt;/h4&gt;
&lt;p&gt;要判断查找的键值是否在树中，我们先将它和根结点中的键比较。如果它和其中的任何一个相等，查找命中。否则我们就根据比较的结果找到指向相应区间的链接，并在其指向的子树中递归地继续查找。如果这是个空链接，查找未命中。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;树的插入实现&quot;&gt;2-3树的插入实现&lt;/h4&gt;
&lt;p&gt;要在2-3树中插入一个新结点，我们可以和二叉查找树一样先进行一次未命中的查找，然后把新结点挂在树的底部。但这样的话树无法保持完美平衡性。我们使用2-3树的主要原因就在于它能够在插入之后继续保持平衡。&lt;br/&gt;2-3树插入可以分为三种情况&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;对于空树，插入一个2节点即可&lt;/li&gt;
&lt;li&gt;插入节点到一个2节点的叶子上&lt;br/&gt;由于其本身只有一个元素，所以只需要将其升级为3节点即可。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1590876/201910/1590876-20191002215310437-170200138.png&quot;/&gt;&lt;/p&gt;
&lt;ol readability=&quot;1&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;往3节点中插入一个新数据&lt;br/&gt;因为3节点本省就是2-3树的最大容量(已经有两个元素)，因此需要拆分。分情况讨论如下所示：&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;只有一个3-结点的树，向其插入一个新键&lt;br/&gt;这棵树唯一的结点中已经没有可插入的空间了。我们又不能把新键插在其空结点上（破坏了完美平衡）。为了将新键插入，我们先临时将新键存入该结点中，使之成为一个4-结点。创建一个4-结点很方便，因为很容易将它转换为一颗由3个2-结点组成的2-3树（如图所示），这棵树既是一颗含有3个结点的二叉查找树，同时也是一颗完美平衡的2-3树，其中所有空链接到根结点的距离都相等&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1590876/201910/1590876-20191002215435908-255460861.png&quot;/&gt;&lt;/p&gt;
&lt;ol readability=&quot;2&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;向一个父节点为2节点的3节点中插入数据&lt;br/&gt;假设未命中的查找结束于一个3-结点，而它的父结点是一个2-结点。在这种情况下我们需要在维持树的完美平衡的前提下为新键腾出空间。&lt;br/&gt;我们先像刚才一样构造一个临时的4-结点并将其分解，但此时我们不会为中键创建一个新结点，而是将其移动至原来的父结点中。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1590876/201910/1590876-20191002215518583-748640074.png&quot;/&gt;&lt;br/&gt;这次转换并没有影响2-3树的主要性质，树仍然是有序的，因为中键被移动到父节点中去了。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;向一个父节点为3节点的3节点中插入数据&lt;br/&gt;假设未命中的查找结束于一个3-结点，而它的父结点是一个3-结点。&lt;br/&gt;我们再次和刚才一样构造一个临时的4-结点并分解它，然后将它的中键插入它的父结点中。但父结点也是一个3-结点，因此我们再用这个中键构造一个新的临时4-结点，然后在这个结点上进行相同的变换，即分解这个父结点并将它的中键插入到它的父结点中去。&lt;br/&gt;我们就这样一直向上不断分解临时的4-结点并将中键插入更高的父结点，直至遇到一个2-结点并将它替换为一个不需要继续分解的3-结点，或者是到达3-结点的根。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1590876/201910/1590876-20191002215557163-2136170546.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;b树blance-tree&quot;&gt;B树(Blance-Tree)&lt;/h2&gt;
&lt;p&gt;B树，在写法上通常是B-树，这不是减号的意思，只是一种表达方式，它是一种能够存储数据、对数据进行排序并允许以O(log n)的时间复杂度运行进行查找、顺序读取、插入和删除的数据结构。，概括来说是一个节点可以拥有多于2个节点的二叉查找树。&lt;/p&gt;
&lt;p&gt;一个m阶的B树具有如下特点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;B树根节点至少有两个节点，每个节点可以有多个子树&lt;/li&gt;
&lt;li&gt;每个中间节点都包含k-1个元素和k个子树，其中 m/2 ⇐ k ⇐ m&lt;/li&gt;
&lt;li&gt;所有的叶子结点都位于同一层&lt;/li&gt;
&lt;li&gt;每个节点中的元素从小到大排列，节点当中k-1个元素正好是k个孩子包含的元素的值域分划。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;看概念还是挺晦涩的，直接放张图看看正宗的B树&lt;/p&gt;
&lt;p&gt;5.每个节点中的元素从小到大排列，节点当中k-1个元素正好是k个孩子包含的元素的值域分划。&lt;br/&gt;&lt;img src=&quot;https://images0.cnblogs.com/blog/94031/201403/290047064066682.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;插入数据&quot;&gt;插入数据&lt;/h3&gt;
&lt;p&gt;插入的数据依次是6 10 4 14 5 11 15 3 2 12 1 7 8 8 6 3 6 21 5 15 15 6 32 23 45 65 7 8 6 5 4&lt;br/&gt;，效果图如下：&lt;br/&gt;&lt;img src=&quot;https://files.cnblogs.com/yangecnu/btreebuild.gif&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;b树&quot;&gt;B+树&lt;/h2&gt;
&lt;p&gt;B+树是对B树的一种变形树，它与B树的差异在于：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;有k个子结点的结点必然有k个关键码；&lt;/li&gt;
&lt;li&gt;非叶结点仅具有索引作用，跟记录有关的信息均存放在叶结点中。&lt;/li&gt;
&lt;li&gt;树的所有叶结点构成一个有序链表，可以按照关键码排序的次序遍历全部记录。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://images0.cnblogs.com/blog/94031/201403/290050048129679.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;插入数据如下所示：&lt;br/&gt;&lt;img src=&quot;https://files.cnblogs.com/yangecnu/Bplustreebuild.gif&quot;/&gt;&lt;br/&gt;B和B+树的区别在于，B+树的非叶子结点只包含导航信息，不包含实际的值，所有的叶子结点和相连的节点使用链表相连，便于区间查找和遍历。&lt;/p&gt;
&lt;p&gt;B+ 树的优点在于：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;由于B+树在内部节点上不好含数据信息，因此在内存页中能够存放更多的key。 数据存放的更加紧密，具有更好的空间局部性。因此访问叶子几点上关联的数据也具有更好的缓存命中率。&lt;/li&gt;
&lt;li&gt;B+树的叶子结点都是相链的，因此对整棵树的便利只需要一次线性遍历叶子结点即可。而且由于数据顺序排列并且相连，所以便于区间查找和搜索。而B树则需要进行每一层的递归遍历。相邻的元素可能在内存中不相邻，所以缓存命中性没有B+树好。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;但是B树也有优点，其优点在于，由于B树的每一个节点都包含key和value，因此经常访问的元素可能离根节点更近，因此访问也更迅速。下面是B 树和B+树的区别图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images0.cnblogs.com/blog/94031/201403/290050088914733.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为什么说B+树比B树更适合数据库索引？&lt;/p&gt;
&lt;ol readability=&quot;4.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;B+树的磁盘读写代价更低：B+树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对B树更小，如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，一次性读入内存的需要查找的关键字也就越多，相对IO读写次数就降低了。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;B+树的查询效率更加稳定：由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，所以通常B+树用于数据库索引。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;B树在提高了IO性能的同时并没有解决元素遍历的我效率低下的问题，正是为了解决这个问题，B+树应用而生。B+树只需要去遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作或者说效率太低。&lt;/p&gt;
&lt;h2 id=&quot;红黑树&quot;&gt;红黑树：&lt;/h2&gt;
&lt;p&gt;红黑树也叫RB树，RB-Tree。是一种自平衡的二叉查找树，它的节点的颜色为红色和黑色。它不严格控制左、右子树高度或节点数之差小于等于1。也是一种解决二叉查找树极端情况的数据结构。&lt;/p&gt;
&lt;p&gt;红黑树规定了：&lt;/p&gt;
&lt;ol readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;节点是红色或黑色。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;根节点是黑色。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;每个叶子节点都是黑色的空节点（NIL节点）。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;每个红色节点的两个子节点都是黑色。也就是说从每个叶子到根的所有路径上不能有两个连续的红色节点)。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1590876/201910/1590876-20191002220413840-395950627.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;红黑树在查找方面和AVL树操作几乎相同。但是在插入和删除操作上，AVL树每次插入删除会进行大量的平衡度计算，红黑树是牺牲了严格的高度平衡的优越条件为代价，它只要求部分地达到平衡要求，结合变色，降低了对旋转的要求，从而提高了性能。红黑树能够以O(log2 n)的时间复杂度进行搜索、插入、删除操作。此外，由于它的设计，任何不平衡都会在三次旋转之内解决。&lt;/p&gt;
&lt;p&gt;相比于BST，因为红黑树可以能确保树的最长路径不大于两倍的最短路径的长度，所以可以看出它的查找效果是有最低保证的。在最坏的情况下也可以保证O(logN)的，这是要好于二叉查找树的。因为二叉查找树最坏情况可以让查找达到O(N)。&lt;/p&gt;
&lt;p&gt;红黑树的算法时间复杂度和AVL相同，但统计性能比AVL树更高，所以在插入和删除中所做的后期维护操作肯定会比红黑树要耗时好多，但是他们的查找效率都是O(logN)，所以红黑树应用还是高于AVL树的. 实际上插入 AVL 树和红黑树的速度取决于你所插入的数据.如果你的数据分布较好,则比较宜于采用 AVL树(例如随机产生系列数),但是如果你想处理比较杂乱的情况,则红黑树是比较快的。&lt;/p&gt;
&lt;p&gt;红黑树广泛用于TreeMap、TreeSet，以及jdk1.8后的HashMap(hash冲突链表超过8就转换成红黑树)。&lt;/p&gt;
&lt;p&gt;参考：&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/jiqing9006/p/5873097.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/jiqing9006/p/5873097.html&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://blog.csdn.net/wanderlustLee/article/details/81297253&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/wanderlustLee/article/details/81297253&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/zhuwbox/p/3636783.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/zhuwbox/p/3636783.html&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/lishanlei/p/10707791.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/lishanlei/p/10707791.html&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/yangecnu/p/Introduce-B-Tree-and-B-Plus-Tree.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/yangecnu/p/Introduce-B-Tree-and-B-Plus-Tree.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 02 Oct 2019 14:11:00 +0000</pubDate>
<dc:creator>秃桔子</dc:creator>
<og:description>高强度训练第十八天总结: 二叉查找树： 二叉查找树就是左结点小于根节点，右结点大于根节点的一种排序树，也叫二叉搜索树。也叫BST，英文Binary Sort Tree。 就长下面这吊样 查找步骤 在二</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/godoforange/p/11618643.html</dc:identifier>
</item>
<item>
<title>免费下载 80多种的微软推出入门级 .NET视频 - 张善友</title>
<link>http://www.cnblogs.com/shanyou/p/11618564.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shanyou/p/11618564.html</guid>
<description>&lt;p&gt;.NET Core 3.0视频系列中宣布了80多个新的免费视频，这些视频同时放在Microsoft的Channel 9 和youtube上面。 在线观看由于跨洋网络效果不太好，下载到机器上慢慢上是最好的了。 所以Scott Hanselman 特别制作了一个页面 &lt;a href=&quot;http://dot.net/videos&quot;&gt;http://dot.net/videos&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;我把这个页面的链接重新组织了一下，去掉Youtube 的链接，下面介绍一下如何下载这80多个入门级视频：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;点击系列的链接，比如C# 101的链接进入到Channel 9的页面，角落里有一个链接，上面写着“ RSS”-这真的很简单！&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/510/201910/510-20191002213805176-1704549232.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/510/201910/510-20191002213805849-2111019174.png&quot; alt=&quot;image&quot; width=&quot;618&quot; height=&quot;447&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;右键单击你想要下载的哪个例如MP4 Low，然后选择 &lt;strong&gt;复制链接地址”。&lt;/strong&gt;现在，该链接在剪贴板中！&lt;/li&gt;
&lt;li&gt;接下来，下载 Scott Hanselman 制作&lt;a href=&quot;https://gist.github.com/shanselman/9a5f73071e41b46dfcf9585ed5e14085&quot;&gt;了一个小PowerShell脚本&lt;/a&gt; 到本地磁盘，并将其命名为&lt;strong&gt;DownloadVideos.ps1，注意要确保以* .ps1扩展名保存它，这是需要运行Powershell 来完成下载视频的。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;最后，在文本编辑器中打开PS1文件，并检查第2行和第3行。再次输入适合您计算机的路径，例如C：\ temp或您的下载文件夹。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;#CHECK THE PATH ON LINE 2 and the FEED on LINE 3&lt;br/&gt;cd &quot;G:\Build2019\dotnetconf2019&quot;&lt;br/&gt;$a = ([xml](new-object net.webclient).downloadstring(&quot;https://channel9.msdn.com/Series/CSharp-101/feed/mp4&lt;a href=&quot;https://channel9.msdn.com/Events/dotnetConf/NET-Conf-2019/RSS/mp4%22))&quot;&gt;&quot;))&lt;/a&gt;&lt;br/&gt;$a.rss.channel.item | foreach{ &lt;br/&gt;    $url = New-Object System.Uri($_.enclosure.url)&lt;br/&gt;    $file = $url.Segments[-1]&lt;br/&gt;    $file&lt;br/&gt;    if (!(test-path $file)) {&lt;br/&gt;        (New-Object System.Net.WebClient).DownloadFile($url, $file)&lt;br/&gt;     }&lt;br/&gt;}&lt;/p&gt;
&lt;p&gt;确保您上面上面复制的RSS链接在第3行上正确无误。我们需要一个本地存放视频的文件夹，还有我们需要下载的远程RSS链接。&lt;/p&gt;
&lt;p&gt;最后，从“开始”菜单打开计算机上的PowerShell，然后运行&lt;strong&gt;DownloadVideos.ps1。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://dotnet.microsoft.com/blob-assets/images/learn-content/csharp-101-videos-part1.jpg&quot; alt=&quot;视频缩略图&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://channel9.msdn.com/Series/CSharp-101/?WT.mc_id=DT-MVP-33797&quot; target=&quot;_blank&quot;&gt;C＃101&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在本视频系列中，Kendra Havens和Scott Hanselman通过现场编码演示探讨了C＃编程语言的概念和语法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://dotnet.microsoft.com/blob-assets/images/learn-content/dotnet-core-101-videos-part1.jpg&quot; alt=&quot;视频缩略图&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://channel9.msdn.com/Series/NET-Core-101/&quot; target=&quot;_blank&quot;&gt;.NET Core 101&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;与Microsoft的Scott Hanselman和Kendra Havens等专家一起探索.NET Core的世界。他们介绍了.NET的来龙去脉以及如何构建您的第一个应用程序。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/playlist?list=PLdo4fOcmZ0oW8nviYduHq7bmKode-p8Wy&quot;&gt;&lt;img src=&quot;https://dotnet.microsoft.com/blob-assets/images/learn-content/aspnet-core-101-videos-part1.jpg&quot; alt=&quot;视频缩略图&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://channel9.msdn.com/Series/NET-Core-101/?WT.mc_id=DT-MVP-33797&quot;&gt;ASP.NET Core 101&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Leslie Richardson和Scott Hanselman展示了如何利用ASP.NET来构建和部署可在Linux，macOS和Windows上运行的Web应用程序和服务。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/playlist?list=PLdo4fOcmZ0oU10SXt2W58pu2L0v2dOW-1&quot;&gt;&lt;img src=&quot;https://dotnet.microsoft.com/blob-assets/images/learn-content/xamarin-101-videos-part1.jpg&quot; alt=&quot;视频缩略图&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://channel9.msdn.com/Series/Xamarin-101/?WT.mc_id=DT-MVP-33797&quot;&gt;Xamarin 101&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在这个入门视频系列中，获得Xamarin的概述以及它如何使您能够为Android和iOS创建跨平台的移动应用程序。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://dotnet.microsoft.com/blob-assets/images/learn-content/desktop-101-videos-part1.jpg&quot; alt=&quot;视频缩略图&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://channel9.msdn.com/Series/Desktop-and-NET-Core-101/?WT.mc_id=DT-MVP-33797&quot;&gt;桌面和.NET Core 101&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;从这个用于在.NET Core中构建Window应用程序的入门视频系列中，学习如何为.NET Core创建第一个WinForms或WPF应用程序！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://dotnet.microsoft.com/blob-assets/images/learn-content/docker-101-videos-part1.jpg&quot; alt=&quot;视频缩略图&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://channel9.msdn.com/Series/Docker-and-NET-Core-101/?WT.mc_id=DT-MVP-33797&quot;&gt;容器简介（Docker）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;为什么要使用容器？Docker是一种打包和分发具有所有依赖关系的应用程序的方法。开始使用Docker，并在此介绍性视频系列中学习如何发布您的应用程序！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://dotnet.microsoft.com/blob-assets/images/learn-content/ef-101-videos-part1.jpg&quot; alt=&quot;视频缩略图&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://channel9.msdn.com/Series/Entity-Framework-Core-101/?WT.mc_id=DT-MVP-33797&quot;&gt;Enity Framework Core 101&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这个101级的视频系列将带您入门Entity Framework Core，它是一个对象关系映射器，它简化了关系数据库的工作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://dotnet.microsoft.com/blob-assets/images/learn-content/vs-101-videos-part1.jpg&quot; alt=&quot;视频缩略图&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://channel9.msdn.com/Series/Intro-to-Visual-Studio/?WT.mc_id=DT-MVP-33797&quot;&gt;Visual Studio简介&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在这个简短的视频系列中，Visual Studio专家Kendra Havens简要概述了Visual Studio，安装和一些出色的生产率提示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://dotnet.microsoft.com/blob-assets/images/learn-content/ml-dotnet-101-videos-part1.jpg&quot; alt=&quot;视频缩略图&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://channel9.msdn.com/Series/MLNET/?WT.mc_id=DT-MVP-33797&quot; target=&quot;_blank&quot;&gt;ML.NET&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎使用ML.NET进行机器学习！这个入门级的视频系列介绍了机器学习的概念，它可以做什么以及如何开始使用ML.NET。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://dotnet.microsoft.com/blob-assets/images/learn-content/spark-101-videos-part1.jpg&quot; alt=&quot;视频缩略图&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://channel9.msdn.com/Series/NET-for-Apache-Spark-101/?WT.mc_id=DT-MVP-33797&quot; target=&quot;_blank&quot;&gt;.NET for Apache Spark 101&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;通过有关Apache Spark的.NET入门视频系列，开始大数据分析之旅！了解有关适用于Apache Spark的.NET的全部知识，以及如何将大数据世界带入.NET生态系统。&lt;/p&gt;
</description>
<pubDate>Wed, 02 Oct 2019 13:38:00 +0000</pubDate>
<dc:creator>张善友</dc:creator>
<og:description>.NET Core 3.0视频系列中宣布了80多个新的免费视频，这些视频同时放在Microsoft的Channel 9 和youtube上面。 在线观看由于跨洋网络效果不太好，下载到机器上慢慢上是最好</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/shanyou/p/11618564.html</dc:identifier>
</item>
<item>
<title># C# 中的Task创建指南 - ChasingDreams</title>
<link>http://www.cnblogs.com/chasingdreams2017/p/11617985.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chasingdreams2017/p/11617985.html</guid>
<description>&lt;p&gt;&lt;strong&gt;本文还处于草稿阶段，难免还有错误修改改正，逻辑还不是很清晰，笔者会努力完善，长期更新！&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;[0000] 前言&lt;/h2&gt;
&lt;p&gt;标题起得有些&quot;大&quot;，意在集大家的力量，总结出来一份关于Task相对&quot;正确&quot;的知识总结，欢迎读者提出宝贵意见！本文内容来自于笔者在编码的时候种种疑问，来自于对异步编程在操作系统中实际运行过程的好奇。平时使用Task战战兢兢,既想提高效率，又怕它不受控制，到处乱来。与其这样，不如此时此刻一起来了解它神秘的面纱吧！Just do IT.&lt;/p&gt;
&lt;h2 id=&quot;为什么要编写异步代码&quot;&gt;[0001] 为什么要编写异步代码&lt;/h2&gt;
&lt;p&gt;新型应用广泛使用文件和网络 I/O。 默认情况下 I/O API 一般会阻塞，导致糟糕的用户体验和硬件利用率，除非希望学习和使用富有挑战的模式。 基于任务的异步 API 和语言级异步编程模型改变了这种模型，只需了解几个新概念就可默认进行异步执行。&lt;/p&gt;
&lt;p&gt;异步代码具有以下特点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;等待 I/O 请求返回的同时，可通过生成处理更多请求的线程，处理更多的服务器请求。&lt;/li&gt;
&lt;li&gt;等待 I/O 请求的同时生成 UI 交互线程，并通过将长时间运行的工作转换到其他 CPU 核心，让 UI 的响应速度更快。&lt;/li&gt;
&lt;li&gt;许多较新的 .NET APIs 都是异步的。&lt;/li&gt;
&lt;li&gt;在 .NET 中编写异步代码很简单！&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;来源: &lt;a href=&quot;https://docs.microsoft.com/zh-cn/dotnet/standard/async#why-write-async-code&quot;&gt;https://docs.microsoft.com&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;关于c中的异步编程模式&quot;&gt;[0010] 关于C#中的异步编程模式&lt;/h2&gt;
&lt;p&gt;.NET 提供了执行异步操作的三种模式：&lt;/p&gt;
&lt;ul readability=&quot;4.1428571428571&quot;&gt;&lt;li readability=&quot;1.8303341902314&quot;&gt;
&lt;p&gt;&lt;strong&gt;基于任务的异步模式 (TAP)&lt;/strong&gt; ，该模式使用单一方法表示异步操作的开始和完成。 TAP 是在 .NET Framework 4 中引入的。 &lt;strong&gt;这是在 .NET 中进行异步编程的推荐方法。&lt;/strong&gt; C# 中的 async 和 await 关键词以及 Visual Basic 中的 Async 和 Await 运算符为 TAP 添加了语言支持。 有关详细信息，请参阅&lt;a href=&quot;https://docs.microsoft.com/zh-cn/dotnet/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap&quot;&gt;基于任务的异步模式 (TAP)&lt;/a&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1.8272251308901&quot;&gt;
&lt;p&gt;基于事件的异步模式 (EAP) ，是提供异步行为的基于事件的旧模型。 这种模式需要后缀为 &lt;code&gt;Async&lt;/code&gt; 的方法，以及一个或多个事件、事件处理程序委托类型和 &lt;code&gt;EventArg&lt;/code&gt; 派生类型。 EAP 是在 .NET Framework 2.0 中引入的。 建议新开发中不再使用这种模式。 有关详细信息，请参阅&lt;a href=&quot;https://docs.microsoft.com/zh-cn/dotnet/standard/asynchronous-programming-patterns/event-based-asynchronous-pattern-eap&quot;&gt;基于事件的异步模式 (EAP)&lt;/a&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1.8670360110803&quot;&gt;
&lt;p&gt;异步编程模型 (APM) 模式（也称为 IAsyncResult 模式），这是使用 IAsyncResult 接口提供异步行为的旧模型。 在这种模式下，同步操作需要 &lt;code&gt;Begin&lt;/code&gt; 和 &lt;code&gt;End&lt;/code&gt; 方法（例如，&lt;code&gt;BeginWrite&lt;/code&gt; 和 &lt;code&gt;EndWrite&lt;/code&gt;以实现异步写入操作）。 不建议新的开发使用此模式。 有关详细信息，请参阅&lt;a href=&quot;https://docs.microsoft.com/zh-cn/dotnet/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm&quot;&gt;异步编程模型 (APM)&lt;/a&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;模式的比较&quot;&gt;模式的比较&lt;/h3&gt;
&lt;p&gt;为了快速比较这三种模式的异步操作方式，请考虑使用从指定偏移量处起将指定量数据读取到提供的缓冲区中的&lt;code&gt;Read&lt;/code&gt;方法：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class MyClass  
{  
    public int Read(byte [] buffer, int offset, int count);  
}  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此方法对应的 TAP 将公开以下单个 &lt;code&gt;ReadAsync&lt;/code&gt; 方法：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class MyClass  
{  
    public Task&amp;lt;int&amp;gt; ReadAsync(byte [] buffer, int offset, int count);  
}  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对应的 EAP 将公开以下类型和成员的集：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class MyClass  
{  
    public void ReadAsync(byte [] buffer, int offset, int count);  
    public event ReadCompletedEventHandler ReadCompleted;  
}  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对应的 APM 将公开 &lt;code&gt;BeginRead&lt;/code&gt; 和 &lt;code&gt;EndRead&lt;/code&gt; 方法：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class MyClass  
{  
    public IAsyncResult BeginRead(  
        byte [] buffer, int offset, int count,   
        AsyncCallback callback, object state);  
    public int EndRead(IAsyncResult asyncResult);  
}  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;来源: &lt;a href=&quot;https://docs.microsoft.com/zh-cn/dotnet/standard/asynchronous-programming-patterns/index&quot;&gt;https://docs.microsoft.com&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;分割线未完区域--------------------------------&quot;&gt;分割线，未完区域--------------------------------&lt;/h2&gt;
&lt;h2 id=&quot;实践&quot;&gt;[0011] 实践&lt;/h2&gt;
&lt;h3 id=&quot;使用async&quot;&gt;使用Async&lt;/h3&gt;
&lt;p&gt;请一路Async，否则会不可控。&lt;br/&gt;网络请求，文件读写时系统自带的Async方法不会创建多线程，而是使用完成端口，依靠中断来实现！&lt;br/&gt;线程池中的线程分为 WorkerThread 和 CompletionPortThread .&lt;br/&gt;平时我们使用的线程是WorkerThread，IO读写使用的是CompletionPortThread&lt;/p&gt;
&lt;h3 id=&quot;创建io密集型任务&quot;&gt;1. 创建IO密集型任务&lt;/h3&gt;
&lt;p&gt;以下代码不会创建&lt;strong&gt;多个线程（WorkerThread）&lt;/strong&gt;，代码会在当前线程工作，且不会堵塞哦。&lt;br/&gt;执行起来非常类似同步程序， 使用 &lt;strong&gt;await RunActionAsync(()=&amp;gt;{});&lt;/strong&gt;&lt;br/&gt;后，会立即执行程序&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public Task RunActionAsync(Action action)
{
    TaskCompletionSource&amp;lt;Task&amp;gt; source = new TaskCompletionSource&amp;lt;Task&amp;gt;(TaskCreationOptions.AttachedToParent);
    Task&amp;lt;Task&amp;gt; task = source.Task;

    try
    {
        action.Invoke();
    }
    catch (Exception ex)
    {
        source.SetException(ex);
    }

    source.SetResult(Task.CompletedTask);

    return task;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;计算密集型任务&quot;&gt;2. 计算密集型任务&lt;/h3&gt;
&lt;p&gt;以下代码会创建&lt;strong&gt;新线程（WorkerThread）&lt;/strong&gt;，位于线程池，线程池默认最小WorkerThread为CPU核心数,CompletionPortThread为1000（实际最小值依实际运行情况而定，可手工修改）&lt;br/&gt;运行时并不会立即执行Action，按照默认执行计划（TaskScheduler.Default执行，比如用&lt;strong&gt;for&lt;/strong&gt;循环一堆&lt;strong&gt;Task.Run(async ()=&amp;gt; {await httpgetAsync(); echo(i); )&lt;/strong&gt;任务，执行时你会发现&lt;strong&gt;i&lt;/strong&gt;都是最后一个值&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;await Task.Run(()=&amp;gt;{});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以下代码会创建&lt;strong&gt;新线程（WorkerThread）&lt;/strong&gt;，在不在ThreadPool关键在于&lt;strong&gt;TaskCreationOptions&lt;/strong&gt;枚举，如果为&lt;strong&gt;LongRunning&lt;/strong&gt;，则直接会创建一个非线程池的线程执行任务，如果不是，则会在线程池里寻找线程，如果没有，会在线程池里新申请线程（创建一个耗时一秒），执行任务。&lt;br/&gt;会立即执行Action&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Task.Factory.StartNew(_ =&amp;gt;
{
    action.Invoke();
},
    null,
    CancellationToken.None,
    TaskCreationOptions.LongRunning,
    TaskScheduler.Default)&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;一些坑&quot;&gt;3.一些坑&lt;/h3&gt;
&lt;p&gt;以下代码.NET Core不支持哦，请使用Task.Factory.StartNew代替&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Task.Factory.FromAsync(
    new Func&amp;lt;AsyncCallback, object, IAsyncResult&amp;gt;((cb, obj) =&amp;gt; action.BeginInvoke(biz, cb, obj)),
    new Action&amp;lt;IAsyncResult&amp;gt;(ar =&amp;gt; action.EndInvoke(ar)), null)&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://devblogs.microsoft.com/premier-developer/the-danger-of-taskcompletionsourcet-class/&quot;&gt;The danger of TaskCompletionSource class&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.walterlv.com/post/default-task-scheduler-and-thread-pool.html&quot;&gt;了解 .NET 的默认 TaskScheduler 和线程池（ThreadPool）设置，避免让 Task.Run 的性能急剧降低&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.walterlv.com/post/task-wait-may-cause-long-time-waiting.html&quot;&gt;.NET 中小心嵌套等待的 Task，它可能会耗尽你线程池的现有资源，出现类似死锁的情况&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.walterlv.com/post/use-task-completion-source-as-await-locker.html&quot;&gt;.NET 中使用 TaskCompletionSource 作为线程同步互斥或异步操作的事件&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.walterlv.com/post/abstract-awaitable-and-awaiter.html&quot;&gt;定义一组抽象的 Awaiter 的实现接口，你下次写自己的 await 可等待对象时将更加方便&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.walterlv.com/post/understand-and-write-custom-awaiter.html&quot;&gt;.NET 除了用 Task 之外，如何自己写一个可以 await 的对象？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.walterlv.com/post/what-is-an-awaiter.html&quot;&gt;.NET 中什么样的类是可使用 await 异步等待的？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://dschenkelman.github.io/2013/10/29/asynchronous-io-in-c-io-completion-ports/&quot;&gt;Asynchronous I/O in C#: I/O Completion Ports&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/dschenkelman/async-io-talk&quot;&gt;Asynchronous I/O in C#: I/O Completion Ports&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://devblogs.microsoft.com/dotnet/migrating-delegate-begininvoke-calls-for-net-core/&quot;&gt;Migrating Delegate.BeginInvoke Calls for .NET Core&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;声明&quot;&gt;声明&lt;/h2&gt;
&lt;p&gt;本文采用&lt;a href=&quot;https://creativecommons.org/licenses/by-nc-sa/2.5/cn/&quot;&gt;知识共享署名-非商业性使用-相同方式共享 2.5 中国大陆许可协议&lt;/a&gt;进行许可，发表在&lt;a href=&quot;https://blog.csdn.net/hatmen2&quot;&gt;CSDN&lt;/a&gt;和&lt;a href=&quot;http://www.cnblogs.com/chasingdreams2017/&quot;&gt;博客园&lt;/a&gt;，欢迎读者转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接！请读者/爬虫们尊重&lt;code&gt;版权&lt;/code&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 02 Oct 2019 10:40:00 +0000</pubDate>
<dc:creator>ChasingDreams</dc:creator>
<og:description>本文还处于草稿阶段，难免还有错误修改改正，逻辑还不是很清晰，笔者会努力完善，长期更新！ [0000] 前言 标题起得有些'大'，意在集大家的力量，总结出来一份关于Task相对'正确'的知识总结，欢迎读</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/chasingdreams2017/p/11617985.html</dc:identifier>
</item>
<item>
<title>Oracle 查询真实执行计划 - kingsleylam</title>
<link>http://www.cnblogs.com/kingsleylam/p/11617890.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kingsleylam/p/11617890.html</guid>
<description>&lt;h2 id=&quot;什么是真实执行计划&quot;&gt;什么是真实执行计划&lt;/h2&gt;
&lt;p&gt;获取Oracle的执行计划，有几种方式。（本文使用Oracle 11g XE版本，以及普通用户scott登录）&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;0&quot;&gt;explain plan for&lt;br/&gt;有两个步骤：
&lt;ul&gt;&lt;li&gt;explain plan for ${SQL}&lt;/li&gt;
&lt;li&gt;select * from table(dbms_xplan.display);&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这一个方法可以在PLSQLDev的cmd窗口和sql窗口执行，同时不需要给用户授权。&lt;br/&gt;示例：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/452847/201910/452847-20191002174933580-389938723.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;autotrace&lt;br/&gt;有两个步骤：
&lt;ul&gt;&lt;li&gt;set autot on&lt;/li&gt;
&lt;li&gt;执行${SQL}&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;但普通用户需要授权，才能执行。不了解授权过程，知道的同学可以留言。&lt;br/&gt;并且在我的PLSQLDev里无法执行，必须得到SqlPlus才能执行。&lt;br/&gt;示例：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/452847/201910/452847-20191002174957910-1472957497.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到多了一些统计信息，不过不是十分直观。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;但是，上面两种方法&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;使用AUTOTRACE或者EXPLAIN PLAN FOR 获取的执行计划来自于PLAN_TABLE。PLAN_TABLE是一个会话级的临时表，里面的执行计划并不是SQL真实的执行计划，它只是优化器估算出来的。真实的执行计划不应该是估算的，应该是真正执行过的。SQL执行过的执行计划存在于共享池中，具体存在于数据字典V$SQL_PLAN中，带有A-Time的执行计划来自于V$SQL_PLAN，是真实的执行计划，而通过AUTOTRACE、通过EXPLAIN PLAN FOR获取的执行计划只是优化器估算获得的执行计划。（注1）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里说的带有A-Time的执行计划，即是本文所说的真实执行计划。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;真实执行计划&lt;br/&gt;这种方法需要对普通用户授权，可用以下语句一次性授权。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;grant select any dictionary to scott;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种执行计划结果如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/452847/201910/452847-20191002182728696-1815638113.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到多了A-Rows、A-Time等字段。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;Starts 表示这个操作执行的次数&lt;br/&gt;E-Rows表示优化器估算的行数，就是普通执行计划中的Rows&lt;br/&gt;A-Rows表示真实的行数&lt;br/&gt;A-Time表示累加的总时间。与普通执行计划不同的是，普通执行计划中的Time是假的，而A-Time是真实的。&lt;br/&gt;Buffers表示累加的逻辑读&lt;br/&gt;Reads表示累加的物理读&lt;br/&gt;（注2）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Starts、A-Rows、A-Time这几个字段很直观，对于非数据库开发人员来说，容易理解。&lt;br/&gt;真实执行计划的获取方式 ，下面会介绍。&lt;/p&gt;
&lt;p&gt;需要注意的是，普通执行计划估算出来的行数，受直方图统计信息的影响，可能会使优化器对执行计划的选择产生误判（例如本该走HASH JOIN，结果变成NESTED LOOPS）。因此，直方图统计信息应该定期更新。这项工作在我司是DBA的日常工作。&lt;/p&gt;
&lt;h2 id=&quot;如何获取真实的执行计划&quot;&gt;如何获取真实的执行计划&lt;/h2&gt;
&lt;p&gt;首先要有访问动态性能视图的权限，可用以下语句授权&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;grant select any dictionary to scott;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有了权限之后，分以下几步走&lt;/p&gt;
&lt;p&gt;1.alter session set statistics_level = all;&lt;br/&gt;（这一步对当前会话窗口有效，可以不做，下面解释）&lt;/p&gt;
&lt;p&gt;2.执行语句;&lt;br/&gt;（如果上一步不做，则需要在语句中添加 /&lt;em&gt;+ gather_plan_statistics&lt;/em&gt; /。 例如：select /&lt;em&gt;+ gather_plan_statistics&lt;/em&gt; / * from dual; 但这样做比较麻烦 ，每条语句都要加上，不推荐）&lt;/p&gt;
&lt;p&gt;3.找出执行语句的SQL ID，例如：&lt;br/&gt;&lt;code&gt;select v.last_active_time, v.* from v$sql v where v.last_active_time &amp;gt; to_date('2019/10/02 17:00:00', 'yyyy/mm/dd hh24:mi:ss') and v.sql_text like 'select * from %' and v.parsing_schema_name = 'SCOTT' order by v.last_active_time desc;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;参数根据实际情况修改，越精确越好。&lt;br/&gt;可以得到如下计划，把SQL ID取出&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/452847/201910/452847-20191002180812520-1888879553.png&quot;/&gt;&lt;br/&gt;4.根据SQL ID查出执行计划&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select * from table(dbms_xplan.display_cursor('b8x994z12hax9',null,'allstats last'));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中第一个参数就是第3步获得的SQL ID。可得到执行计划&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/452847/201910/452847-20191002175037044-809799565.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;复制出来贴到notepad++&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/452847/201910/452847-20191002175112941-871285361.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到已经有了实际执行的信息。&lt;br/&gt;这个例子还比较简单，可以试试下面这个例子。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select d.dname, d.loc, e.empno, e.ename
  from emp e, dept d
 where e.deptno = d.deptno
 order by d.dname, e.empno;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行计划如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/452847/201910/452847-20191002175145244-2112953718.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面还有更多的信息，可以知道每一步操作的具体信息，比如两个表之间通过什么关联等。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;真实执行计划提供了SQL执行的真实信息，包括A-Time（真实时间）、A-Rows（真实行数）、Starts（步骤执行次数）等，对于非数据库开发人员来说，十分直观方便。我也借此在工作优化了10+ SQL，收获满满~&lt;br/&gt;在这里要推荐一本书《SQL 优化核心思想》，罗炳森 黄超 钟侥 著。本文的所有文字引用，均摘自此书。我没有完全看懂这本书，但目前在工作中，已经够用了。&lt;/p&gt;
</description>
<pubDate>Wed, 02 Oct 2019 10:04:00 +0000</pubDate>
<dc:creator>kingsleylam</dc:creator>
<og:description>什么是真实执行计划 获取Oracle的执行计划，有几种方式。（本文使用Oracle 11g XE版本，以及普通用户scott登录） explain plan for 有两个步骤： explain pl</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/kingsleylam/p/11617890.html</dc:identifier>
</item>
<item>
<title>中文分词 - 西多士NLP</title>
<link>http://www.cnblogs.com/sandwichnlp/p/11612503.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sandwichnlp/p/11612503.html</guid>
<description>&lt;p&gt;在上一篇文章中，我们了解了词向量的相关内容。对于英文语料来说，直接根据空格或者标点即可对词记性划分。而对于中文语料，分词的方法就十分复杂了。之前在概述里提到过，在中文自然语言处理领域，不同的分词方法将使得同一个句子有不同的含义，如：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;“乒乓球拍/卖了” 和 “乒乓球/拍卖/了”&lt;br/&gt;“南京市/长江/大桥” 和 “南京/市长/江大桥”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;笔者认为，分词算法主要有以下几个问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;歧义词&lt;/li&gt;
&lt;li&gt;分词的粒度&lt;/li&gt;
&lt;li&gt;分词标准或词的定义并不明确&lt;/li&gt;
&lt;li&gt;由于词表大小的限制，使得分词结果中的某些词不会出现在此表中，即OOV（out of bag）问题。这些不在词表中的词在训练过程中将统一被UNK字符代替，其语义信息也将被丢弃&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;首先，我们需要知道，在做自然语言处理的时候，为什么需要分词？什么时候需要分词？更深入一点的问题就是，对于深度学习这样一个端到端的模型，为什么不直接将最基础“字”输入模型，而要分词之后再输入模型呢？&lt;/p&gt;
&lt;p&gt;一方面，从直觉上来看，对于词，我们的做法是用一个向量将其在高维空间中进行表征，相当每一个语义有一个固定的表示，我们可以用其来计算他们之间的距离，或是余弦相似度，从而表示词与词之间的相似度。而对于单个汉字来说，通常是没有十分明确的语义的，这使得用向量来表征单个字是十分困难的。&lt;/p&gt;
&lt;p&gt;另一方面，大部分的机器学习算法都有一个假设：特征之间是相互独立的。显然，在字与字之间，这个假设是很难成立的，如&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;“自/然/语/言/处/理”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;每个字之间是有比较强的相关性的，而经过分词之后，如&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;“自然/语言/处理”&lt;br/&gt;“自然语言/处理”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;显然，词与词之间的相关性明显就弱得多了，这使得特征更接近我们的假设。&lt;/p&gt;
&lt;p&gt;但今年来越来越多的研究表明，分词并不是什么时候效果都比单字的效果要好，某些情况下单字模型反而能够得到更好的模型表现。这主要有以下几个原因：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;现阶段的深度学习模型开始越来越擅长处理长远距离依赖关系，并能够通过巨大的参数空间对字向量进行整合，使得模型能够理解以字为单元组成的句子的语义特征。&lt;/li&gt;
&lt;li&gt;由于分词算法具有一定的准确性，并且粒度标准难以确定，这将向模型引入一系列不必要的噪声。&lt;/li&gt;
&lt;li&gt;由于新词不断地被创建，一方面这使得我们的词表十分大，越大的词表意味着模型的参数空间就会十分大，巨大的参数空间使得模型的训练变得更加困难，其次这将出现很多新词，使得OOV问题更为严重。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;那么分词到底是否是有必要的呢？笔者认为这需要根据不同的任务来说。如果在下游任务数据量足够大的情况下，通常直接将单字输入模型，这样模型参数空间较小，不容易过拟合，易于训练。但是对于大部分场景来说，语料通常较少，这种情况下，我们可以在通用语料中训练合适的词向量，再在新任务中固定词向量来训练，提升将是非常大的。&lt;/p&gt;

&lt;p&gt;分词的主要方法有两种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;查表法&lt;/li&gt;
&lt;li&gt;序列标注法&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;查表法&quot;&gt;查表法&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1816627/201910/1816627-20191002172007908-800941755.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对于查表法，第一步都是根据给定的词表，将一句话中所有可能的词都匹配出来，将其构成一个有向无环图（DAG），在没有先验知识的前提下，每条边的权重都是1。这样，我们分词的过程其实就成为了一个求DAG最短路径的过程。对于匹配词表，如果匹配每一个字时都遍历整个词表，是十分耗时的。通常的做法是构造一个前缀树（Trie），Trie树由词的公共前缀构成节点，大大降低了存储空间，同时提升了查找效率，对于上述例句构造的Trie树如下图所示，详细的算法原理大家可以自行百度。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1816627/201910/1816627-20191002172013422-42535417.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;最大匹配算法&quot;&gt;最大匹配算法&lt;/h3&gt;
&lt;p&gt;最长匹配算法是一种贪心算法，包括正向/反向最大匹配算法，指从左到右/从右到左匹配句子中字，直到匹配到最长的词语为止。这种分词方法是最简单的，虽然其速度快，但是精度不高。比如之前给的例子，正向最长匹配算法的分词结果就是“他/说/的/的确/实在/理”。&lt;/p&gt;
&lt;h3 id=&quot;n-最短路径法&quot;&gt;N-最短路径法&lt;/h3&gt;
&lt;p&gt;Dijkstra算法是较为常用的最短路径方法，其算法原理在于以起始点为中心向外层层拓展（广度优先搜索思想），直到拓展到终点为止。N-最短路径算法每次均保留N条最短路径，最后求得最优解时回溯得到最短路径。如上面的例子，可以分为如下的步骤：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;从“0”到“2”的最短路径为2：0 -&amp;gt; 1 -&amp;gt; 2&lt;/li&gt;
&lt;li&gt;“0”到达“3”的最短路径为3：0 -&amp;gt; 1 -&amp;gt; 2 -&amp;gt; 3；同时“0”到达“4”的最短路径为3：0 -&amp;gt; 1 -&amp;gt; 2 -&amp;gt; 4（广度优先）&lt;/li&gt;
&lt;li&gt;“0”到达“5”的最短路径为4：0 -&amp;gt; 1 -&amp;gt; 2 -&amp;gt; 3 -&amp;gt; 5；“0”到达“6”的最短路径为4：0 -&amp;gt; 1 -&amp;gt; 2 -&amp;gt; 4 - &amp;gt; 6&lt;/li&gt;
&lt;li&gt;“0”到达“7”的最短路径为5：0 -&amp;gt; 1 -&amp;gt; 2 -&amp;gt; 4 -&amp;gt; 6 -&amp;gt; 7 或 0 -&amp;gt; 1 -&amp;gt; 2 -&amp;gt; 3 - &amp;gt; 5 -&amp;gt; 7&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;则可能的分词结果为“他/说/的确/实在/理”和“他/说/的/确实/在理”，可见效果还是优于最大匹配算法的。&lt;/p&gt;
&lt;h3 id=&quot;n-gram语言模型&quot;&gt;N-gram语言模型&lt;/h3&gt;
&lt;p&gt;由于实际的语料中，不同字之间的转移概率并不是相同的，因此，我们可以通过构建统计语言模型来构建新的有向无环图。对于统计语言模型还不了解的同学可以回去看我上一篇博客。根据我们的条件概率公式。&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[P(S)=P(w_1, w_2, ..., w_T)=\prod_{t=1}^Tp(w_t|w_1, w_2, ..., w_{t-1})\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我们用简单的bigram模型对上面的问题进行简单的建模，可以得到如下的DAG：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1816627/201910/1816627-20191002172022623-1173766665.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;每一条边的条件概率需要从额外的语料库中进行统计得到。这样一来，对新的DAG求最短路径，即可得到分词结果。&lt;/p&gt;
&lt;h2 id=&quot;序列标注法&quot;&gt;序列标注法&lt;/h2&gt;
&lt;p&gt;关于序列标注法，其实属于解决一类大问题的通用思想，其用于解决一系列对字符进行分类的问题。这一部分将在下一节进行统一介绍。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参考链接&lt;/strong&gt;&lt;br/&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/65865071&quot; class=&quot;uri&quot;&gt;https://zhuanlan.zhihu.com/p/65865071&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://kexue.fm/archives/3863&quot; class=&quot;uri&quot;&gt;https://kexue.fm/archives/3863&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.zhihu.com/question/42022652/answer/564538459&quot; class=&quot;uri&quot;&gt;https://www.zhihu.com/question/42022652/answer/564538459&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/66155616&quot; class=&quot;uri&quot;&gt;https://zhuanlan.zhihu.com/p/66155616&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/50444885&quot; class=&quot;uri&quot;&gt;https://zhuanlan.zhihu.com/p/50444885&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 02 Oct 2019 09:25:00 +0000</pubDate>
<dc:creator>西多士NLP</dc:creator>
<og:description>[TOC] 前言 在上一篇文章中，我们了解了词向量的相关内容。对于英文语料来说，直接根据空格或者标点即可对词记性划分。而对于中文语料，分词的方法就十分复杂了。之前在概述里提到过，在中文自然语言处理领域</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/sandwichnlp/p/11612503.html</dc:identifier>
</item>
</channel>
</rss>