<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>关于Nginx mmap(MAP_ANON|MAP_SHARED, 314572800)报错 - 飞翔码农</title>
<link>http://www.cnblogs.com/feixiangmanon/p/13655721.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/feixiangmanon/p/13655721.html</guid>
<description>&lt;h3 id=&quot;mmap-报错解决&quot;&gt;mmap 报错解决&lt;/h3&gt;
&lt;p&gt;今天修改了一下测试环境的Nginx的nginx.conf，然后做检测的时候报了一个错误&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;/usr/local/bin/nginx -c /usr/local/etc/openresty/conf/nginx.conf -t

nginx: [alert] mmap(MAP_ANON|MAP_SHARED, 314572800) failed (12: Cannot allocate memory)
nginx: configuration file /usr/local/etc/openresty/conf/nginx.conf test failed
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;报错提示很清楚，不能分配内存了。为什么不能分配内存了？基本上就是物理内存不够使用了，先查了下内存&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;free -m
              total        used        free      shared  buff/cache   available
Mem:            990         568          75          54         347         224
Swap:             0           0           0
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，真正可以被使用的内存大概就是224M。那就是Nginx此次检查的配置需要使用大于224M的内存。按理说，Nginx自身不需要多少内存。我们系统中大量使用openresty，首先怀疑可能openresty的某个引用申请内存过多了，然后查找了下配置，果然发现openresty的共享内存的使用。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;lua_shared_dict xxx 300m;
lua_shared_dict yyy 100m;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;总共需要400M内存，这两个共享内存该小点应该就可以了。改为&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;lua_shared_dict xxx 100m;
lua_shared_dict yyy 30m;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后检查通过&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/usr/local/bin/nginx -c /usr/local/etc/openresty/conf/nginx.conf -t
nginx: the configuration file /usr/local/etc/openresty/conf/nginx.conf syntax is ok
nginx: configuration file /usr/local/etc/openresty/conf/nginx.conf test is successful
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;检测是成功，reload Nginx成功生效。&lt;/p&gt;
&lt;h3 id=&quot;nginx-申请内存的模块&quot;&gt;Nginx 申请内存的模块&lt;/h3&gt;
&lt;p&gt;可能有的不一定是openresty共享内存的锅。Nginx配置需要配置内存的地方其实不多，一个个排查就可以做到。&lt;/p&gt;
&lt;h4 id=&quot;openresty-lua_shared_dict&quot;&gt;openresty lua_shared_dict&lt;/h4&gt;
&lt;p&gt;lua_shared_dict 定义在http模块。&lt;br/&gt;声明共享内存区，共享内存区始终由当前Nginx服务器实例中的所有Nginx进程共享。&lt;br/&gt;参数接受大小单位，比如K 和M 等等。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;http {
     lua_shared_dict dogs 10m;
     ...
 }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;proxy_cache_path&quot;&gt;proxy_cache_path&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;proxy_cache_path path [levels=levels] keys_zone=name:size
path 设置缓存的路径
levels 设置缓存文件的层级，当levels=1:2时，表示是两级目录，1和2表示用1位和2位16进制来命名目录名称。
keys_zone 设置共享内存的名称和大小，keys_zone=one:10m，表示共享内存名称是one，大小是10M，这里设置内存过高，就会出现开头的报警，mmap(MAP_ANON|MAP_SHARED, 314572800)
配置设置成这样
proxy_cache_path /data/nginx/cache levels=1:2 keys_zone=one:10m;
路径和层级就是下面的
/data/nginx/cache/c/29/b7f54b2df7773722d382f4809d65029c
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;limit_req_zone&quot;&gt;limit_req_zone&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;limit_req_zone key zone=name:size rate=rate
设置共享内存的限流参数
主要看下应用
limit_req_zone $binary_remote_addr zone=one:10m rate=1r/s;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用客户端的IP作为限流的key，共享内存分配了10M，共享内存的名称是one，速度是每个客户端IP每秒1个请求，超过1个请求可能会延迟或者直接拒绝，要看limit_req的配置。&lt;br/&gt;$binary_remote_addr变量的大小为4个字节。在64位平台上始终占据128字节。 一个1M的区域可以保留约约8000个客户端IP。所以10M大概可以准确存储8万个客户端IP。如果限流的客户端IP超过了8万个，就应该扩大共享内存。&lt;/p&gt;
&lt;h3 id=&quot;limit_conn_zone&quot;&gt;limit_conn_zone&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;limit_conn_zone key zone=name:size;
设置连接数限流的参数
limit_conn_zone $binary_remote_addr zone=addr:10m;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;连接数限流的参数跟请求数参数类似。&lt;br/&gt;使用客户端的IP作为限流的key，共享内存分配了10M，共享内存的名称是addr。10M可以存储8万个客户端IP。限流的具体数量限制是由limit_conn配置&lt;br/&gt;比如&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;limit_conn addr 1;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;就表示每个客户端IP同时只能有一个连接存在。&lt;/p&gt;
&lt;h3 id=&quot;总结nginx-mmap&quot;&gt;总结Nginx mmap&lt;/h3&gt;
&lt;p&gt;所以，如果以后遇到关于Nginx mmap(MAP_ANON|MAP_SHARED, 314572800)报错，首先应该检查可能分配大内存的配置，首要检查的就是这两个&lt;br/&gt;lua_shared_dict&lt;br/&gt;proxy_cache_path&lt;br/&gt;修改这两个参数就可以解决问题。&lt;/p&gt;
&lt;p&gt;一般&lt;br/&gt;limit_req_zone&lt;br/&gt;limit_conn_zone&lt;br/&gt;分配的内存很小，至多几十M，不会直接导致系统没有内存可分配。&lt;/p&gt;
</description>
<pubDate>Sat, 12 Sep 2020 00:01:00 +0000</pubDate>
<dc:creator>飞翔码农</dc:creator>
<og:description>mmap 报错解决 今天修改了一下测试环境的Nginx的nginx.conf，然后做检测的时候报了一个错误 /usr/local/bin/nginx -c /usr/local/etc/openres</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/feixiangmanon/p/13655721.html</dc:identifier>
</item>
<item>
<title>Java审计之XSS篇 - nice_0e3</title>
<link>http://www.cnblogs.com/nice0e3/p/13655552.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nice0e3/p/13655552.html</guid>
<description>&lt;h2 id=&quot;0x00-前言&quot;&gt;0x00 前言&lt;/h2&gt;
&lt;p&gt;继续 学习一波Java审计的XSS漏洞的产生过程和代码。&lt;/p&gt;
&lt;h2 id=&quot;0x01-java-中xss漏洞代码分析&quot;&gt;0x01 Java 中XSS漏洞代码分析&lt;/h2&gt;
&lt;h3 id=&quot;xss原理&quot;&gt;xss原理&lt;/h3&gt;
&lt;p&gt;xss产生过程：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;后台未对用户输入进行检查或过滤，直接把用户输入返回至前端。导致javascript代码在客户端任意执行。
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;xss代码分析&quot;&gt;XSS代码分析&lt;/h3&gt;
&lt;p&gt;在php里面会使用&lt;code&gt;echo&lt;/code&gt;对用户输入的参数进行直接输出，导致了xss漏洞的产生。而在Java里面会将接收到的未经过滤的参数共享到request域中，在jsp的页面里面使用EL表达式进行输出。&lt;/p&gt;
&lt;p&gt;这里编写一个serlvet来做一个演示&lt;/p&gt;
&lt;p&gt;xssservlet代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@WebServlet(&quot;/demo&quot;)
public class xssServlet extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        this.doGet(request,response);
    }

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {

        response.setContentType(&quot;text/html&quot;);// 设置响应类型
        String content = request.getParameter(&quot;content&quot;);  //获取content传参数据
        request.setAttribute(&quot;content&quot;, content);  //content共享到request域
        request.getRequestDispatcher(&quot;/WEB-INF/pages/xss.jsp&quot;).forward(request, response);  //转发到xxs.jsp页面中

    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;xss.jsp代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;
    ${requestScope.content}
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;

&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动tomcat，访问url：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;http://localhost:8080/untitled3_war_exploded/demo?content=1
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1993669/202009/1993669-20200912052356750-1650051896.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;传参一个1过去成功输入了，那么再来传一个xss的payload试试。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;http://localhost:8080/untitled3_war_exploded/demo?content=&amp;lt;script&amp;gt;alert(&quot;xss&quot;)&amp;lt;/script&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1993669/202009/1993669-20200912052416670-1317166702.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;成功的弹出了一个框&lt;/p&gt;
&lt;p&gt;在审计中需要关注的是参数是否可控，如果可控传入的参数是否会被过滤后共享到request域中，如果在可控和不被过滤的情况下，就很有可能存在xss漏洞。&lt;/p&gt;
&lt;h3 id=&quot;防御xss策略&quot;&gt;防御xss策略&lt;/h3&gt;
&lt;p&gt;我们需要防御xss漏洞的攻击，就需要添加一个方法，在传入前先调用该方法进行一次过滤，但是这样的方式比较繁琐，这时候就可以使用ESAPI来帮我们过滤。&lt;/p&gt;
&lt;p&gt;ESAPI介绍：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;企业安全API（ESAPI）项目是OWASP项目，可为每个Web平台创建简单的强大安全控件。安全控件并不容易构建。您可以在OWASP网站上了解无聊的开发人员的数百个陷阱。通过为开发人员提供一组强大的控件，我们旨在消除创建安全Web应用程序的某些复杂性。这可以在整个SDLC中节省大量成本。
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;据说可以应付大部分的web攻击漏洞。&lt;/p&gt;
&lt;p&gt;在pom.xml导入ESAPI坐标&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!-- https://mvnrepository.com/artifact/org.owasp.esapi/esapi --&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.owasp.esapi&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;esapi&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;2.2.1.1&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;servlet代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@WebServlet(&quot;/demo&quot;)
class xssServlet extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        this.doGet(request,response);
    }

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException, ServletException, IOException {

        response.setContentType(&quot;text/html&quot;);// 设置响应类型
        
        String content = request.getParameter(&quot;content&quot;);  //获取content传参数据
        String s = ESAPI.encoder().encodeForJavaScript(content);  //进行实体编码
        request.setAttribute(&quot;content&quot;, s);  //content共享到request域
        request.getRequestDispatcher(&quot;/WEB-INF/pages/xss.jsp&quot;).forward(request, response);  //转发到xxs.jsp页面中

    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参考该博客&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;https://blog.csdn.net/CHS007chs/article/details/86645450
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;0x02-cms-审计&quot;&gt;0x02 CMS 审计&lt;/h2&gt;
&lt;p&gt;这次还是拿上次搭建的环境来做一个演示。&lt;/p&gt;
&lt;p&gt;那么结合前面的内容，知道了xss的产生过程是使用request.setAttribute方法将请求到的数据未经过滤存储到request域中，然后在jsp页面里使用el表达式进行输出。&lt;/p&gt;
&lt;p&gt;在审计的时候我们可以直接来全局搜索 快捷键 `Ctrl+Shift+F&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1993669/202009/1993669-20200912052434510-194920860.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里就来找一下存储型xss，反射的xss意义并不大。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1993669/202009/1993669-20200912052442279-1024889064.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击选择一个文件来看看他的代码，这里直接就给共享到request域中了，但是这里只是我们的一个查询方法，我们需要找到他输入值的地方， 看到下面的addComment方法正好对应上了一个输出xss ，一个插入xss的地方。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1993669/202009/1993669-20200912052448998-1636836300.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;查看该方法 &lt;code&gt;commentService.addComment(comment);&lt;/code&gt; 调用addComment方法将值传入，不出意外的话传入的comment参数就是接收过来的一个实体类。我们来Ctrl+左键点击 Comment类进行跳转到该类去。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1993669/202009/1993669-20200912052454904-1255915854.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;主要关注变量为 String类型的变量，因为Java是强类型的语言。&lt;/p&gt;
&lt;p&gt;等会对这几个变量的地方进行插入xss代码。&lt;/p&gt;
&lt;p&gt;回到刚才的控制器代码&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1993669/202009/1993669-20200912052459389-1224952947.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击ctrl+左键点击addComment 追溯到CommentService 的接口&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1993669/202009/1993669-20200912052513779-402634169.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;同样的方式再追溯到CommentService的实现类&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1993669/202009/1993669-20200912052523741-919553467.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用的是commentDao调用addComment 传入参数进行添加数据。继续追溯上去&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1993669/202009/1993669-20200912052528261-1651803872.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在这里我们就看到了dao接口中的addcomment方法，dao接口中并没有myabtis的注解，说明是xml配置文件配置的。&lt;/p&gt;
&lt;p&gt;后面的直接开启全局搜索，搜索addComment指定xml文件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1993669/202009/1993669-20200912052535223-446343315.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击进去看到，我们的提交的内容会被插入数据库里面，也就是说这是个存储型xss&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1993669/202009/1993669-20200912052542298-409078038.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1993669/202009/1993669-20200912053124502-1479302059.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;逻辑这里其实已经很清晰了。&lt;/p&gt;
&lt;p&gt;具体的还得看实操，查看Controller获取路径。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1993669/202009/1993669-20200912053133286-1343511731.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1993669/202009/1993669-20200912053309731-1729571544.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;漏洞位置：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;http://127.0.0.1:82/web/comment/ajax/addcomment
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结合刚刚查看的Comment实体类，我们已经找到哪些地方可以去插xss了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;script&amp;gt;alert(&quot;1&quot;)&amp;lt;/script&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;访问一下漏洞地址&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1993669/202009/1993669-20200912053320864-645665446.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里还需要登录后才能访问，那就登录一下吧！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1993669/202009/1993669-20200912053330379-1863798830.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1993669/202009/1993669-20200912053337047-1675999062.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;系统错误，我。。。。。肯定又是上次那张表的问题，那几张表没建立好。&lt;/p&gt;
&lt;p&gt;算了，洗洗睡吧！！！&lt;/p&gt;
&lt;h2 id=&quot;0x03-结尾&quot;&gt;0x03 结尾&lt;/h2&gt;
&lt;p&gt;Java的xss审计都是自己琢磨，结合一下网上的文章，复现一下，很快就熟悉了。&lt;/p&gt;
</description>
<pubDate>Fri, 11 Sep 2020 21:34:00 +0000</pubDate>
<dc:creator>nice_0e3</dc:creator>
<og:description>Java审计之XSS篇 0x00 前言 继续 学习一波Java审计的XSS漏洞的产生过程和代码。 0x01 Java 中XSS漏洞代码分析 xss原理 xss产生过程： 后台未对用户输入进行检查或过滤</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/nice0e3/p/13655552.html</dc:identifier>
</item>
<item>
<title>数据结构之真别多想—树状数组 - Simon5ei</title>
<link>http://www.cnblogs.com/Simon5ei/p/13655398.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Simon5ei/p/13655398.html</guid>
<description>&lt;p&gt;&lt;span&gt;如何理解树状数组？&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;18&quot;&gt;
&lt;p&gt;&lt;img src=&quot;https://oi-wiki.org/ds/images/fenwick1.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个结构的思想和线段树有些类似：用一个大节点表示一些小节点的信息，进行查询的时候只需要查询一些大节点而不是更多的小节点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最下面的八个方块就代表存入 a 中的八个数，现在都是十进制。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;他们上面的参差不齐的剩下的方块就代表 a 的上级—— c 数组。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;很显然看出：&lt;/span&gt; &lt;span&gt;c2 管理的是 a1 &amp;amp; a2 ；&lt;/span&gt; &lt;span&gt;c4 管理的是 a1 &amp;amp; a2 &amp;amp; a3 &amp;amp; a4 ；&lt;/span&gt; &lt;span&gt;c6 管理的是 a5 &amp;amp; a6 ；c8 则管理全部 8 个数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以，如果你要算区间和的话，比如说要算 a51 ~ a91 的区间和，暴力算当然可以，那上百万的数，那就 TLE 喽。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;——————摘自oi-wiki.org&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;span&gt;初看这些文字，你可能会想：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;“啊这这这？？？你讲这些我们怎么听得懂啊，这树状数组是啥，咋用，我们还是懵的啊”&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;当然，为了解决问题而书写算法的话，我们不需要去理解这个结构的原理到底是啥，我们只需要知道这个东西&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;用在哪？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;怎么用？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;就足够了&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;用在哪？&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;我们都知道：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一般的普通数组&lt;/span&gt;&lt;strong&gt;&lt;span&gt;单点操作&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;的时间复杂度的&lt;/span&gt;&lt;strong&gt;&lt;span&gt;O(1)&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;、&lt;/span&gt;&lt;strong&gt;&lt;span&gt;区间操作&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;的时间复杂度是&lt;/span&gt;&lt;strong&gt;&lt;span&gt;O(n)&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而我们树状数组的和普通数组的区别就在于：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;单点操作和区间操作&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;的时间复杂度都是&lt;/span&gt;&lt;strong&gt;&lt;span&gt;O(log n)，&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;而且&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;单点修改和区间操作（加、求和）&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;都需要&lt;/span&gt;&lt;strong&gt;&lt;span&gt;用函数实现&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那么这么说我们大概能理解一点了，那就是：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;&lt;span&gt;&lt;span&gt;一旦遇到大规模使用区间求和的问题，我们就可以考虑使用树状数组。&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;怎么用？&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;总得来说就是三个函数：&lt;/span&gt;&lt;strong&gt;&lt;span&gt;lowbit、添加函数，求和函数&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;lowbit&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c++&quot; lang=&quot;c++&quot;&gt;int lowbit(int x) {
  /*
        算出x二进制的从右往左出现第一个1以及这个1之后的那些0组成数的二进制对应的十进制的数
    简单说就是用位运算改变了查找操作，以契合上述的时间复杂度
  */
  return x &amp;amp; -x;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;单点修改&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c++&quot; lang=&quot;c++&quot;&gt;void add(int x, int k) {  //在i位置加上k
  while (x &amp;lt;= n) {  // 不能越界
    c[x] = c[x] + k;
    x = x + lowbit(x);
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;区间求和&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c++&quot; lang=&quot;c++&quot;&gt;int sum(int x) {  // 返回a[1]……a[x]的和
  int ans = 0;
  while (x &amp;gt;= 1) {
    ans = ans + c[x];
    x = x - lowbit(x);
  }
  return ans;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;就这？？就这？？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;啊啊，看似就这，那我们来找一道&lt;/span&gt;&lt;strong&gt;&lt;span&gt;模板题&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;做一做，深化一下理解吧。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;例题：Acwing 788 逆序对的数量&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;题面&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;给定一个长度为n的整数数列，请你计算数列中的逆序对的数量。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;逆序对的定义如下：对于数列的第 i 个和第 j 个元素，如果满足 i &amp;lt; j 且 a[i] &amp;gt; a[j]，则其为一个逆序对；否则不是。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;输入&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一行包含整数n，表示数列的长度。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第二行包含 n 个整数，表示整个数列。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;输出&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;输出一个整数，表示逆序对的个数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;PS： 1≤n≤1000001≤n≤100000&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;输入样例：&lt;/span&gt;&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;6
2 3 4 5 6 1
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4&gt;&lt;span&gt;输出样例：&lt;/span&gt;&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;5
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3&gt;&lt;span&gt;解题过程&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;“逆序对”的计算需要用到大量的区间运算，在这个时候我们的树状数组就发挥了很大的用处了，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于这道题的核心思想，即是：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;用数组的值作为下标，每次出现逆序对则给该下标对应值加一，最后求和&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;代码如下&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
#include &amp;lt;iostream&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;cstdio&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;algorithm&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;cstring&amp;gt;

&lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;

typedef &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; LL;

&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; N = &lt;span&gt;100010&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; n;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; a[N];
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; tr[N];

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; lowbit(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; x) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; x &amp;amp; -&lt;span&gt;x;
}

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; add(&lt;span&gt;int&lt;/span&gt; x, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; k) {
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = x; i &amp;lt; N - &lt;span&gt;1&lt;/span&gt;; i += lowbit(i)) tr[i] +=&lt;span&gt; k; 
}

LL sum(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; x) {
    LL res &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = x; i; i -= lowbit(i)) res +=&lt;span&gt; tr[i];
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; res;
}

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main() {
    scanf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &amp;amp;&lt;span&gt;n);
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; n; i ++) scanf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &amp;amp;&lt;span&gt;a[i]);
    
    LL ans &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = n - &lt;span&gt;1&lt;/span&gt;; i &amp;gt;= &lt;span&gt;0&lt;/span&gt;; i --) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;倒序读入&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; t = a[i];&lt;span&gt;//&lt;/span&gt;&lt;span&gt;读入的值作为下标&lt;/span&gt;
        ans += sum(t - &lt;span&gt;1&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;若比a[i]小的值在其之前被读入,即出现了逆序对&lt;/span&gt;
        add(t, &lt;span&gt;1&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;记录逆序对&lt;/span&gt;
&lt;span&gt;    }
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%lld\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, ans);
    
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;emmm，样例过了，提交！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;诶怎么wa了，还是段错误？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2081880/202009/2081880-20200912030313256-1958851851.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;看了看测试数据，原来是我们将数据当作下标，而数据的大小超过了数组大小的限制，而且也造成了空间的冗余，这个时候，我们想到一个方法：&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;离散化&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;离散化，即是将对象之间的关系模糊化，在不改变数据相对大小的条件下，对数据进行相应的缩小。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;什么意思呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如说：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在｛ 1、 2、 99999、 3 ｝之间判断逆序对和在｛ 1、 2、 4、 3｝之间判断逆序对在基本流程上无差别，而如果不进行离散化，则花费了99999个空间，&lt;/span&gt;&lt;strong&gt;&lt;span&gt;为了节省空间，也为了消除数组越界的风险&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，我们使用离散化优化一下代码。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
#include &amp;lt;iostream&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;cstdio&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;algorithm&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;cstring&amp;gt;

&lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;

typedef &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; LL;

&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; N = &lt;span&gt;100010&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; n;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; a[N], backup[N];&lt;span&gt;//&lt;/span&gt;&lt;span&gt;backup即是离散化之后的序列&lt;/span&gt;
&lt;span&gt;LL tr[N];

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; lowbit(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; x) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; x &amp;amp; -&lt;span&gt;x;
}

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; add(&lt;span&gt;int&lt;/span&gt; x, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; k) {
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = x; i &amp;lt;= n; i += lowbit(i)) tr[i] +=&lt;span&gt; k; 
}

LL sum(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; x) {
    LL res &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = x; i; i -= lowbit(i)) res +=&lt;span&gt; tr[i];
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; res;
}

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; find(&lt;span&gt;int&lt;/span&gt; k) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;查找（利用了二分的思想）&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; l = &lt;span&gt;0&lt;/span&gt;, r = n - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (l &amp;lt;&lt;span&gt; r) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; mid = l + r + &lt;span&gt;1&lt;/span&gt; &amp;gt;&amp;gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (backup[mid] &amp;lt;= k) l =&lt;span&gt; mid;
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; r = mid - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; r + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;排好序存储进来的序列，其每个元素的对应下标就是其离散化之后的“大小”&lt;/span&gt;

&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main() {
    scanf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &amp;amp;&lt;span&gt;n);
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; n; i ++) scanf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &amp;amp;&lt;span&gt;a[i]);
    
    memcpy(backup, a, &lt;/span&gt;&lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt; a);
    sort(backup, backup &lt;/span&gt;+ n);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;进行排序&lt;/span&gt;
&lt;span&gt;    
    LL ans &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = n - &lt;span&gt;1&lt;/span&gt;; i &amp;gt;= &lt;span&gt;0&lt;/span&gt;; i --&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; t =&lt;span&gt; find(a[i]);
        ans &lt;/span&gt;+= sum(t - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
        add(t, &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
    }
    
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%lld\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, ans);
    
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;最后，我们得到了AC！！！&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;希望我的抛砖引玉能引起更多的思考！ 😄&lt;/span&gt; &lt;del&gt;&lt;span&gt;（蒟蒻鞠躬）&lt;/span&gt;&lt;/del&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 11 Sep 2020 19:05:00 +0000</pubDate>
<dc:creator>Simon5ei</dc:creator>
<og:description>瓶颈 如何理解树状数组？ 这个结构的思想和线段树有些类似：用一个大节点表示一些小节点的信息，进行查询的时候只需要查询一些大节点而不是更多的小节点。 最下面的八个方块就代表存入 a 中的八个数，现在都是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Simon5ei/p/13655398.html</dc:identifier>
</item>
<item>
<title>.NET Core使用NPOI将Excel中的数据批量导入到MySQL - 追逐时光者</title>
<link>http://www.cnblogs.com/Can-daydayup/p/12593165.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Can-daydayup/p/12593165.html</guid>
<description>&lt;h2&gt;前言：&lt;/h2&gt;
&lt;p&gt;　　在之前的几篇博客中写过.NET Core使用NPOI导出Word和Excel的文章，今天把同样我们日常开发中比较常用的使用Excel导入数据到MySQL数据库中的文章给安排上。与此同时还把&lt;a href=&quot;https://github.com/YSGStudyHards/NPOI-ExportWordAndExcel-ImportExcelData&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;&lt;strong&gt;NPOI-ExportWordAndExcel-ImportExcelData&lt;/strong&gt;&lt;/span&gt;&lt;/a&gt;这个开源项目升级到了.NET Core 3.1版本（注意之前一直是在.NET Core2.2的基础上开发的），升级的过程中遇到了不少坑，在项目中会有一些注释关于升级到.NET Core3.1需要修改的代码这里就不做详细的讲解了可以Clone项目，或者是直接查看官方文档.NET Core相关版本的迁移指南（&lt;a href=&quot;https://docs.microsoft.com/zh-cn/aspnet/core/migration/22-to-30?view=aspnetcore-3.1&amp;amp;tabs=visual-studio&quot; target=&quot;_blank&quot;&gt;https://docs.microsoft.com/zh-cn/aspnet/core/migration/22-to-30?view=aspnetcore-3.1&amp;amp;tabs=visual-studio&lt;/a&gt;）。&lt;/p&gt;
&lt;h2&gt;项目实现效果图：&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1336199/202009/1336199-20200909010339493-1716062953.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;一、引入NPOI NuGet：&lt;/h2&gt;
&lt;h3&gt;NPOI GitHub源码地址：&lt;/h3&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/tonyqus/npoi&quot;&gt;https://github.com/tonyqus/npoi&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;版本说明：&lt;/h3&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;　　NPOI 2.4.1 （注意不同版本可能使用的姿势有点小差别，注意有同学可能会问现在NPOI的最新稳定版不是2.5.1吗?为什么还是用2.4.1呢？因为2.5.1还有些属性与之前的2.4.1不是很兼容，因此我们这里还是继续使用2.4.1，功能上能够完全能够满足我们的需求）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;程序包管理器控制台输入一下命令安装：&lt;/h3&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
Install-Package NPOI -Version 2.4.1
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;通过NuGet管理解决方案安装：&lt;/h3&gt;
&lt;h4&gt;选择=&amp;gt;工具=&amp;gt;NuGet包管理器=&amp;gt;程序包管理器控制台：&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1336199/202003/1336199-20200316010608628-1137886985.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt; 搜索：NPOI进行安装：&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1336199/202003/1336199-20200316010732879-614926042.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;二、ASP.NET Core使用EF Core连接MySQL执行简单的CRUD操作：&lt;/h2&gt;
&lt;p&gt;　　因为该篇文章会涉及到MySQL数据库的操作，所以前提我们需要有一点的CRUD的基础。这里就不做详细的讲解了，可以参考之前写的一篇文章，ASP.NET Core MVC+Layui使用EF Core连接MySQL执行简单的CRUD操作：&lt;/p&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/Can-daydayup/p/12593599.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/Can-daydayup/p/12593599.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;三、使用NPOI获取Excel数据注意点：&lt;/h2&gt;
&lt;h3&gt;1、关于Excel的版本问题：&lt;/h3&gt;
&lt;p&gt;做过Excel相关工作的人应该都清楚Office Excel的格式有两种：&lt;/p&gt;
&lt;p&gt;a、一种是.XLS是03版的Office Excel，无法打开高版本的。&lt;/p&gt;
&lt;p&gt;a、一种是.XLSX是07版(或者07以上的)的Office Excel，可以打开低版本的。&lt;/p&gt;
&lt;p&gt;所以我们在使用NPOI导入数据时不同格式获取Excel工作簿对象也有所不同，如下代码所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
                //Workbook对象代表一个工作簿,首先定义一个Excel工作薄
                IWorkbook workbook;

                //XSSFWorkbook 适用XLSX格式，HSSFWorkbook 适用XLS格式
                #region 判断Excel版本
                switch (fileType)
                {
                    //.XLSX是07版(或者07以上的)的Office Excel
                    case &quot;.xlsx&quot;:
                        workbook = new XSSFWorkbook(stream);
                        break;
                    //.XLS是03版的Office Excel
                    case &quot;.xls&quot;:
                        workbook = new HSSFWorkbook(stream);
                        break;
                    default:
                        throw new Exception(&quot;Excel文档格式有误&quot;);
                }
                #endregion
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2、NPOI获取Excel单元格中不同类型的数据：&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;注意，咱们填写在Excel单元格中的数据可能为多种不同的数据类型，因此我们需要对单元格中的数据类型做判断然后在获取，否则程序会报异常。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
                            #region NPOI获取Excel单元格中不同类型的数据
                            //获取指定的单元格信息
                            var cell = row.GetCell(j);
                            switch (cell.CellType)
                            {
                                //首先在NPOI中数字和日期都属于Numeric类型
                                //通过NPOI中自带的DateUtil.IsCellDateFormatted判断是否为时间日期类型
                                case CellType.Numeric when DateUtil.IsCellDateFormatted(cell):
                                    dataRow[j] = cell.DateCellValue;
                                    break;
                                case CellType.Numeric:
                                    //其他数字类型
                                    dataRow[j] = cell.NumericCellValue;
                                    break;
                                //空数据类型
                                case CellType.Blank:
                                    dataRow[j] = &quot;&quot;;
                                    break;
                                //公式类型
                                case CellType.Formula:
                                {
                                    HSSFFormulaEvaluator eva = new HSSFFormulaEvaluator(workbook);
                                    dataRow[j] = eva.Evaluate(cell).StringValue;
                                    break;
                                }
                                //布尔类型
                                case CellType.Boolean:
                                    dataRow[j] = row.GetCell(j).BooleanCellValue;
                                    break;
                                //错误
                                case CellType.Error:
                                    dataRow[j] = HSSFErrorConstants.GetText(row.GetCell(j).ErrorCellValue);
                                    break;
                                //其他类型都按字符串类型来处理（未知类型CellType.Unknown，字符串类型CellType.String）
                                default:
                                    dataRow[j] = cell.StringCellValue;
                                    break;
                            }
                            #endregion
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;四、通用的NPOI Excel导入数据帮助类（NpoiExcelImportHelper）：&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * Author:追逐时光者
 * Description：Npoi数据导入帮助类
 * Description：2020年9月8日
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Data;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.IO;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; NPOI.HSSF.UserModel;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; NPOI.SS.UserModel;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; NPOI.XSSF.UserModel;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; YY_Utility
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; NpoiExcelImportHelper
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; NpoiExcelImportHelper _excelImportHelper;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; NpoiExcelImportHelper _
        {
            &lt;/span&gt;&lt;span&gt;get&lt;/span&gt; =&amp;gt; _excelImportHelper ?? (_excelImportHelper = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NpoiExcelImportHelper());
            &lt;/span&gt;&lt;span&gt;set&lt;/span&gt; =&amp;gt; _excelImportHelper =&lt;span&gt; value;
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 读取excel表格中的数据,将Excel文件流转化为dataTable数据源  
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 默认第一行为标题 
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;stream&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;excel文档文件流&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;fileType&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;文档格式&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;isSuccess&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;是否转化成功&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;resultMsg&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;转换结果消息&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; DataTable ExcelToDataTable(Stream stream, &lt;span&gt;string&lt;/span&gt; fileType, &lt;span&gt;out&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; isSuccess, &lt;span&gt;out&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; resultMsg)
        {
            isSuccess &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            resultMsg &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Excel文件流成功转化为DataTable数据源&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; excelToDataTable = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DataTable();

            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Workbook对象代表一个工作簿,首先定义一个Excel工作薄&lt;/span&gt;
&lt;span&gt;                IWorkbook workbook;

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;XSSFWorkbook 适用XLSX格式，HSSFWorkbook 适用XLS格式&lt;/span&gt;
                &lt;span&gt;#region&lt;/span&gt; 判断Excel版本
                &lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (fileType)
                {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;.XLSX是07版(或者07以上的)的Office Excel&lt;/span&gt;
                    &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.xlsx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
                        workbook &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; XSSFWorkbook(stream);
                        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;.XLS是03版的Office Excel&lt;/span&gt;
                    &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.xls&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
                        workbook &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HSSFWorkbook(stream);
                        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
                        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Exception(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Excel文档格式有误&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                }
                &lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt;

                &lt;span&gt;var&lt;/span&gt; sheet = workbook.GetSheetAt(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; rows =&lt;span&gt; sheet.GetRowEnumerator();

                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; headerRow = sheet.GetRow(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; cellCount = headerRow.LastCellNum;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;最后一行列数（即为总列数）

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取第一行标题列数据源,转换为dataTable数据源的表格标题名称&lt;/span&gt;
                &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; cellCount; j++&lt;span&gt;)
                {
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; cell =&lt;span&gt; headerRow.GetCell(j);
                    excelToDataTable.Columns.Add(cell.ToString());
                }

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取Excel表格中除标题以为的所有数据源，转化为dataTable中的表格数据源&lt;/span&gt;
                &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = (sheet.FirstRowNum + &lt;span&gt;1&lt;/span&gt;); i &amp;lt;= sheet.LastRowNum; i++&lt;span&gt;)
                {
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; dataRow =&lt;span&gt; excelToDataTable.NewRow();

                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; row =&lt;span&gt; sheet.GetRow(i);

                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (row == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;continue&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;没有数据的行默认是null　&lt;/span&gt;

                    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = row.FirstCellNum; j &amp;lt; cellCount; j++&lt;span&gt;)
                    {
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (row.GetCell(j) != &lt;span&gt;null&lt;/span&gt;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;单元格内容非空验证&lt;/span&gt;
&lt;span&gt;                        {
                            &lt;/span&gt;&lt;span&gt;#region&lt;/span&gt; NPOI获取Excel单元格中不同类型的数据
                            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取指定的单元格信息&lt;/span&gt;
                            &lt;span&gt;var&lt;/span&gt; cell =&lt;span&gt; row.GetCell(j);
                            &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (cell.CellType)
                            {
                                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;首先在NPOI中数字和日期都属于Numeric类型
                                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过NPOI中自带的DateUtil.IsCellDateFormatted判断是否为时间日期类型&lt;/span&gt;
                                &lt;span&gt;case&lt;/span&gt;&lt;span&gt; CellType.Numeric when DateUtil.IsCellDateFormatted(cell):
                                    dataRow[j] &lt;/span&gt;=&lt;span&gt; cell.DateCellValue;
                                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; CellType.Numeric:
                                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;其他数字类型&lt;/span&gt;
                                    dataRow[j] =&lt;span&gt; cell.NumericCellValue;
                                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;空数据类型&lt;/span&gt;
                                &lt;span&gt;case&lt;/span&gt;&lt;span&gt; CellType.Blank:
                                    dataRow[j] &lt;/span&gt;= &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;
                                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;公式类型&lt;/span&gt;
                                &lt;span&gt;case&lt;/span&gt;&lt;span&gt; CellType.Formula:
                                {
                                    HSSFFormulaEvaluator eva &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HSSFFormulaEvaluator(workbook);
                                    dataRow[j] &lt;/span&gt;=&lt;span&gt; eva.Evaluate(cell).StringValue;
                                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                                }
                                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;布尔类型&lt;/span&gt;
                                &lt;span&gt;case&lt;/span&gt;&lt;span&gt; CellType.Boolean:
                                    dataRow[j] &lt;/span&gt;=&lt;span&gt; row.GetCell(j).BooleanCellValue;
                                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;错误&lt;/span&gt;
                                &lt;span&gt;case&lt;/span&gt;&lt;span&gt; CellType.Error:
                                    dataRow[j] &lt;/span&gt;=&lt;span&gt; HSSFErrorConstants.GetText(row.GetCell(j).ErrorCellValue);
                                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;其他类型都按字符串类型来处理（未知类型CellType.Unknown，字符串类型CellType.String）&lt;/span&gt;
                                &lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
                                    dataRow[j] &lt;/span&gt;=&lt;span&gt; cell.StringCellValue;
                                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                            }
                            &lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt;&lt;span&gt;
                        }
                    }
                    excelToDataTable.Rows.Add(dataRow);
                }

                isSuccess &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e)
            {
                resultMsg &lt;/span&gt;=&lt;span&gt; e.Message;
            }

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; excelToDataTable;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;总结：&lt;/h2&gt;
&lt;p&gt;　　关于.NET Core 使用NPOI导入数据和导出Word，Excel数据的教程到这里就告一段落了，假如大家感兴趣的话或者对大家有帮助的话不要忘记了前往&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;https://github.com/YSGStudyHards/NPOI-ExportWordAndExcel-ImportExcelData&quot; target=&quot;_blank&quot;&gt;NPOI-ExportWordAndExcel-ImportExcelData &lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;项目中给我一个star哦，谢谢。&lt;/p&gt;
&lt;h2&gt;相关实例链接地址：&lt;/h2&gt;
&lt;h3&gt;&lt;strong&gt;GitHub完整实例地址：&lt;/strong&gt;&lt;/h3&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://github.com/YSGStudyHards/NPOI-ExportWordAndExcel-ImportExcelData&quot;&gt;https://github.com/YSGStudyHards/NPOI-ExportWordAndExcel-ImportExcelData&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;.NET Core使用NPOI导出复杂，美观的Excel详解：&lt;/h3&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/Can-daydayup/p/12501400.html&quot;&gt;https://www.cnblogs.com/Can-daydayup/p/12501400.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;.NET Core使用NPOI导出复杂Word详解：&lt;/h3&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/Can-daydayup/p/11588531.html&quot;&gt;https://www.cnblogs.com/Can-daydayup/p/11588531.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;.NET Core使用NPOI将Excel中的数据批量导入到MySQL：&lt;/h3&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/Can-daydayup/p/12593165.html&quot;&gt;https://www.cnblogs.com/Can-daydayup/p/12593165.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;ASP.NET Core MVC+Layui使用EF Core连接MySQL执行简单的CRUD操作：&lt;/h3&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/Can-daydayup/p/12593599.html%E3%80%80%E3%80%80&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/Can-daydayup/p/12593599.html&lt;br/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Fri, 11 Sep 2020 15:31:00 +0000</pubDate>
<dc:creator>追逐时光者</dc:creator>
<og:description>前言： 在之前的几篇博客中写过.NET Core使用NPOI导出Word和Excel的文章，今天把同样我们日常开发中比较常用的使用Excel导入数据到MySQL数据库中的文章给安排上。与此同时还把NP</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Can-daydayup/p/12593165.html</dc:identifier>
</item>
<item>
<title>通俗理解线性回归(Linear Regression) - xiaoxia0722</title>
<link>http://www.cnblogs.com/xiaoxia722/p/13654909.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaoxia722/p/13654909.html</guid>
<description>&lt;p&gt;线性回归, 最简单的机器学习算法, 当你看完这篇文章, 你就会发现, 线性回归是多么的简单.&lt;/p&gt;
&lt;p&gt;首先, 什么是线性回归. 简单的说, 就是在坐标系中有很多点, 线性回归的目的就是找到一条线使得这些点都在这条直线上或者直线的周围, 这就是&lt;strong&gt;线性回归(Linear Regression)&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;是不是有画面感了? 那么我们上图片:&lt;br/&gt;&lt;img src=&quot;https://xiaoxiablogs.top/usr/uploads/2020/09/2554413617.png&quot; alt=&quot;1.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么接下来, 就让我们来看看具体的线性回归吧&lt;/p&gt;
&lt;p&gt;首先, 我们以二维数据为例:&lt;br/&gt;我们有一组数据&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(y\)&lt;/span&gt;, 其中&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;是我们的特征, &lt;span class=&quot;math inline&quot;&gt;\(y\)&lt;/span&gt;就是我们的真实值(也就是每一个x对应的值), 我们需要找到一个&lt;span class=&quot;math inline&quot;&gt;\(w\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(b\)&lt;/span&gt;从而得到一条直线&lt;span class=&quot;math inline&quot;&gt;\(y=wx+b\)&lt;/span&gt;, 而这条直线的&lt;span class=&quot;math inline&quot;&gt;\(w\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(b\)&lt;/span&gt;就是我们线性回归所需要求的参数&lt;/p&gt;
&lt;p&gt;那么, &lt;span class=&quot;math inline&quot;&gt;\(w\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(b\)&lt;/span&gt;需要怎样求得呢? 那么我们需要先来了解一下他的机制&lt;/p&gt;
&lt;p&gt;如我们之前所说, 我们需要这条直线使得所有的点尽可能的在直线上或者直线的两边, 也就是说, 我们这些&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;在我们直线上对应的值与我们真实的值的差尽可能的小, 即&lt;span class=&quot;math inline&quot;&gt;\(|y-(wx+b)|\)&lt;/span&gt;尽可能的小, 因此就有了我们的&lt;strong&gt;损失函数&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;\[L=\frac1n\sum^n_{i=1}(y-(wx+b))^2 \]&lt;/p&gt;
&lt;p&gt;那么我们的目标就变成了使得&lt;span class=&quot;math inline&quot;&gt;\(L\)&lt;/span&gt;尽可能的小&lt;/p&gt;
&lt;p&gt;首先我们对损失函数求导:&lt;/p&gt;
&lt;p&gt;\[\frac{\partial L}{\partial\omega}=2\left(\omega\sum^n_{i=1}x_i^2-\sum^n_{i=1}(y_i-b)x_i\right)=0 \]&lt;/p&gt;
&lt;p&gt;\[\frac{\partial L}{\partial b}=2\left(nb-\sum^n_{i=1}(y_i-\omega x_i)\right)=0 \]&lt;/p&gt;
&lt;p&gt;求解以后可得:&lt;/p&gt;
&lt;p&gt;\[\omega=\frac{\sum^n_{i=1}y_i(x_i-\overline x)}{\sum^n_{i=1}x^2_i-\frac1m\left(\sum^m_{i=1}x_i\right)^2} \]&lt;/p&gt;
&lt;p&gt;\[b = \frac1m\sum^n_{i=1}(y_i-\omega x_i) \]&lt;/p&gt;
&lt;p&gt;其中&lt;span class=&quot;math inline&quot;&gt;\(\overline x=\frac1n\sum^n_{i=1}x_i\)&lt;/span&gt;即&lt;span class=&quot;math inline&quot;&gt;\(\overline x\)&lt;/span&gt;是&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;的均值&lt;/p&gt;
&lt;p&gt;而这就是我们的&lt;strong&gt;最小二乘法&lt;/strong&gt;, 求解得到的&lt;span class=&quot;math inline&quot;&gt;\(w\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(b\)&lt;/span&gt;就是我们拟合出来的直线的参数.&lt;/p&gt;
&lt;p&gt;那么就下来, 我们来看一看当&lt;span class=&quot;math inline&quot;&gt;\(X\)&lt;/span&gt;为多维的情况, 也就是&lt;strong&gt;多元线性回归&lt;/strong&gt;&lt;br/&gt;与上面的一样, 我们需要拟合一个直线&lt;span class=&quot;math inline&quot;&gt;\(w^TX+b\)&lt;/span&gt;使得大多数的点在直线上或者在直线周围, 不同的是, 现在我们的&lt;span class=&quot;math inline&quot;&gt;\(w\)&lt;/span&gt;是多维的, 而我们的损失函数也就变成了&lt;/p&gt;
&lt;p&gt;\[L=\frac1n\sum^n_{i=1}(y-(w^TX+b))^2 \]&lt;/p&gt;
&lt;p&gt;根据上面的经验, 我们需要对损失函数求偏导, 在这里就不赘述了, 大家可以参考&lt;a href=&quot;https://xiaoxiablogs.top/index.php/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/least-square-method.html&quot;&gt;https://xiaoxiablogs.top/index.php/机器学习/least-square-method.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;以上, 就是我们的线性回归以及使用最小二乘法求线性回归了&lt;/p&gt;
&lt;p&gt;本人博客&lt;a href=&quot;https://xiaoxiablogs.top&quot;&gt;https://xiaoxiablogs.top&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 11 Sep 2020 14:55:00 +0000</pubDate>
<dc:creator>xiaoxia0722</dc:creator>
<og:description>线性回归, 最简单的机器学习算法, 当你看完这篇文章, 你就会发现, 线性回归是多么的简单. 首先, 什么是线性回归. 简单的说, 就是在坐标系中有很多点, 线性回归的目的就是找到一条线使得这些点都在</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiaoxia722/p/13654909.html</dc:identifier>
</item>
<item>
<title>Linux下Python3.6的安装及避坑指南 - 良许Linux</title>
<link>http://www.cnblogs.com/yychuyu/p/13654664.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yychuyu/p/13654664.html</guid>
<description>&lt;h2 id=&quot;python3的安装&quot;&gt;Python3的安装&lt;/h2&gt;
&lt;h4 id=&quot;1安装依赖环境&quot;&gt;1.安装依赖环境&lt;/h4&gt;
&lt;p&gt;Python3在安装的过程中可能会用到各种依赖库，所以在正式安装Python3之前，需要将这些依赖库先行安装好。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;yum -y install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;2-下载python3源代码&quot;&gt;2. 下载Python3源代码&lt;/h4&gt;
&lt;p&gt;下载Python3的源代码有两种方式，一种是在它的官网下载，网址如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;https://www.python.org/downloads/source/
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;[图片]&lt;/p&gt;
&lt;p&gt;另外一种方式是通过wget直接下载，如以下命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;wget https://www.python.org/ftp/python/3.6.1/Python-3.6.1.tgz
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;3-创建安装目录&quot;&gt;3. 创建安装目录&lt;/h4&gt;
&lt;p&gt;安装目录可依个人喜好创建，比如在此创建在 &lt;code&gt;/usr/local/python3&lt;/code&gt; ：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mkdir -p /usr/local/python3
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;4-解压源码包&quot;&gt;4. 解压源码包&lt;/h4&gt;
&lt;p&gt;将第2步下载到的源码包进行解压，命令为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;tar -zxvf Python-3.6.1.tgz
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;5-编译源码&quot;&gt;5. 编译源码&lt;/h4&gt;
&lt;p&gt;先进入解压后源码包的目录，再进行配置：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cd Python-3.6.1
./configure --prefix=/usr/local/python3
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;之后再编译，然后再安装：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;make
make install
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;6-建立python3的软链接&quot;&gt;6. 建立Python3的软链接&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;ln -s /usr/local/python3/bin/python3 /usr/bin/python3
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;7--将usrlocalpython3bin加入path&quot;&gt;7. 将/usr/local/python3/bin加入PATH&lt;/h4&gt;
&lt;p&gt;编辑bash_profile进行修改环境变量：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;vim ~/.bash_profile
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在PATH变量下将Python3的启动目录添加进去：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;# .bash_profile

# Get the aliases and functions
if [ -f ~/.bashrc ]; then
        . ~/.bashrc
fi

# User specific environment and startup programs

PATH=$PATH:$HOME/bin:/usr/local/python3/bin

export PATH
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;改动完毕之后，按Esc，再输入:wq进行保存退出。&lt;/p&gt;
&lt;h4 id=&quot;8-检查python3及pip3是否正常可用&quot;&gt;8. 检查Python3及Pip3是否正常可用&lt;/h4&gt;
&lt;p&gt;执行如下命令（注意：V是大写的V），如果看到的结果一致的话，说明Python3已经成功安装。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;[alvin@VM_0_16_centos ~]$ python3 -V
Python 3.6.1
[alvin@VM_0_16_centos ~]$ pip3 -V
pip 9.0.1 from /usr/local/lib/python3.6/site-packages (python 3.6)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;避坑指南&quot;&gt;避坑指南&lt;/h2&gt;
&lt;p&gt;其实，对于Python3的安装，网络上有太多的帖子了，步骤其实都大同小异。但是，在真正动手安装之后，或多或少都会遇到一些麻烦，特别是对新手而言。下面良许就列举一些常见的坑：&lt;/p&gt;
&lt;h4 id=&quot;坑1：configure-error-no-acceptable-c-compiler-found-in-path&quot;&gt;坑1：configure: error: no acceptable C compiler found in $PATH&lt;/h4&gt;
&lt;p&gt;这个问题就比较简单，就是缺少gcc编译环境。将gcc安装上即可：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;yum install -y gcc
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然除此之外，采用源码安装的方式也可以。&lt;/p&gt;
&lt;h4 id=&quot;坑2：zipimportzipimporterror-cant-decompress-data&quot;&gt;坑2：zipimport.ZipImportError: can’t decompress data&lt;/h4&gt;
&lt;p&gt;这种问题就是因为缺少zlib 的相关工具包导致的，将相关依赖包装上即可：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;yum -y install zlib*
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;安装之后再重新编译源码，即可解决。&lt;/p&gt;
&lt;h4 id=&quot;坑3：pip3-cant-connect-to-https-url-because-the-ssl-module-is-not-available&quot;&gt;坑3：pip3: Can't connect to HTTPS URL because the SSL module is not available&lt;/h4&gt;
&lt;p&gt;这个问题是因为在./configure过程中，如果没有加上–with-ssl参数时，默认安装的软件涉及到ssl的功能不可用，刚好pip3过程需要ssl模块，而由于没有指定，所以该功能不可用。解决办法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cd Python-3.6.2
./configure --with-ssl
make
sudo make install
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;坑4：multilib-version-problems&quot;&gt;坑4：Multilib version problems&lt;/h4&gt;
&lt;p&gt;这个很明显了，就是同一个库有多个版本。把多余的版本删除了就好。&lt;/p&gt;
&lt;p&gt;首先查询已有的版本（以openssl为例，冲突哪个查哪个）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# rpm -qa | grep openssl
openssl-devel-1.0.0-27.el6_4.2.x86_64
openssl-1.0.0-27.el6_4.2.x86_64
openssl-1.0.0-27.el6_4.2.i686
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到系统里安装了openssl-1.0.0-27.el6_4.2.x86_64和openssl-1.0.0-27.el6_4.2.i686两个版本的openssl，我们留下x86的版本即可：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;rpm --erase --nodeps openssl-1.0.0-27.el6_4.2.i686
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再更新一下openssl：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# yum update &quot;openssl*&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再查询一下openssl，问题解决！&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# rpm -qa | grep openssl
openssl-devel-1.0.1e-16.el6_5.7.x86_64
openssl-1.0.1e-16.el6_5.7.x86_64
&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;p&gt;公众号：良许Linux&lt;/p&gt;
&lt;img src=&quot;https://pic.downk.cc/item/5e618d2f98271cb2b8f65fe8.jpg&quot;/&gt;&lt;h3 id=&quot;有收获？希望老铁们来个三连击，给更多的人看到这篇文章&quot;&gt;有收获？希望老铁们来个三连击，给更多的人看到这篇文章&lt;/h3&gt;
</description>
<pubDate>Fri, 11 Sep 2020 14:05:00 +0000</pubDate>
<dc:creator>良许Linux</dc:creator>
<og:description>Python3的安装 1.安装依赖环境 Python3在安装的过程中可能会用到各种依赖库，所以在正式安装Python3之前，需要将这些依赖库先行安装好。 yum -y install zlib-dev</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yychuyu/p/13654664.html</dc:identifier>
</item>
<item>
<title>RabbitMQ和Kafka的高可用集群原理 - H.U.C-王子</title>
<link>http://www.cnblogs.com/lm970585581/p/13652841.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lm970585581/p/13652841.html</guid>
<description>&lt;h3&gt; &lt;/h3&gt;
&lt;h3&gt;前言&lt;/h3&gt;
&lt;p&gt;小伙伴们，通过前边文章的阅读，相信大家已经对RocketMQ的基本原理有了一个比较深入的了解，那么大家对当前比较常用的RabbitMQ和Kafka是不是也有兴趣了解一些呢，了解的多一些也不是坏事，面试或者跟人聊技术的时候也会让你更有话语权嘛。&lt;/p&gt;
&lt;p&gt;那王子今天就跟大家聊一聊RabbitMQ和Kafka在处理高可用集群时的原理，看看它们与RocketMQ有什么不同。小伙伴们可以重新温习一下&lt;a href=&quot;https://mp.weixin.qq.com/s/9-nwO3sXU1EqRW3QTIbH8g&quot; target=&quot;_blank&quot;&gt;常见的消息中间件有哪些？你们是怎么进行技术选型的？&lt;/a&gt;这篇文章，了解一下他们之间的区别。&lt;/p&gt;

&lt;h3&gt;RabbitMQ的高可用&lt;/h3&gt;
&lt;p&gt;之前我们的文章讲过，RabbitMQ是ActiveMQ的一个很好的替代产品，它是基于主从实现的高可用集群，但它是非分布式的。&lt;/p&gt;
&lt;p&gt;RabbitMQ一共有三种模式：&lt;strong&gt;单机模式、普通集群模式、镜像集群模式&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;单机模式没什么可说的，自己开发练手玩玩就行，我们主要说一下两种集群模式的区别。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;普通集群模式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;普通集群模式，其实就是将RabbitMQ 部署到多台机器上，每个机器启动一个，它们之间进行消息通信。你创建的 queue，只会放在一个 RabbitMQ 的实例上，其他的实例会同步 queue 的元数据（元数据里包含有 queue 的一些配置信息，通过元数据，可以找到 queue 所在的位置）。你消费的时候，实际上如果连接到了另外一个实例，那么那个实例会通过元数据定位到 queue 所在的位置，然后访问queue所在的实例，拉取数据过来发送给消费者。&lt;/p&gt;
&lt;p&gt;整体过程见下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1140467/202009/1140467-20200911162351125-510884920.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这种方式很麻烦，只是一个普通的集群，而且数据并没有副本，只存储在了一台机器上，只要真实存储数据的机器宕机，系统直接崩溃，因为没有数据可以获取了。&lt;/p&gt;
&lt;p&gt;所以可以得出一个结论，这种模式的集群根本不能实现高可用，只能通过负载均衡提高一些MQ的吞吐量，生成环境下是不会使用的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;镜像集群模式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;那么真正用于生产环境，实现高可用的方式是什么呢？没错就是接下来要说的镜像集群模式。&lt;/p&gt;
&lt;p&gt;它和普通集群模式最大的区别在于，queue数据和原数据不再是单独存储在一台机器上，而是同时存储在多台机器上。也就是说每个RabbitMQ实例都有一份镜像数据（副本数据）。每次写入消息的时候都会自动把数据同步到多台实例上去，这样一旦其中一台机器发生故障，其他机器还有一份副本数据可以继续提供服务，也就实现了高可用。&lt;/p&gt;
&lt;p&gt;整个过程看下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1140467/202009/1140467-20200911163541995-1823909013.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;那么如何开启镜像集群模式呢？&lt;/p&gt;
&lt;p&gt;RabbitMQ是有强大的管理控制台的，通过管控台可以很容易的配置，具体操作自行百度吧，我们本篇的目的是弄懂原理。&lt;/p&gt;
&lt;p&gt;对于一般小型公司，小型项目来讲，这套架构已经可以支持了，但是对于海量大数据的要求，如果每台机器都要有一份镜像副本，而且互相之间还要不停的同步数据，它是很难支持的，因为它不是分布式的。所以我们还是使用RocketMQ吧。&lt;/p&gt;

&lt;h3&gt;Kafka的高可用&lt;/h3&gt;
&lt;p&gt;再来聊聊Kafka的高可用，再聊高可用之前，我们先要简单了解下它的基本架构。&lt;/p&gt;
&lt;p&gt;它是由多个Broker组成的，每个Broker都是一个节点，小伙伴们是不是想到了RocketMQ的Broker呢。当我们创建Topic的时候，这个Topic是会划分成多个partition的，每个partition又可以存在不同的Broker上，这里的每个partition都会放一部分数据，可以把它理解成一个分片。&lt;/p&gt;
&lt;p&gt;由此可见，&lt;strong&gt;Kafka是一个天然的分布式消息队列，它的Topic是分成多个partition分布到多个Broker上存储的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;既然讲到这里，可能有很多小伙伴会好奇RocketMQ的Topic是怎么存储的呢？难道RocketMQ的Topic就不会分片了吗？&lt;/p&gt;
&lt;p&gt;答案是否定的，RocketMQ也是借鉴了Kafka分片存储的机制，引入了一个新的概念ConsumeQueue用来代替partition，原先kafka，里面partition存储的是整个消息，但是现在ConsumeQueue里面是存储消息的存储地址，但是不存储消息了。现在每个ConsumeQueue存储的是每个消息在commitlog这个文件的地址，但是消息存在于commitlog中。&lt;br/&gt;也就是所有的消息体都写在了一个文件里面，每个ConsumeQueue只是存储这个消息在commitlog中地址。&lt;/p&gt;
&lt;p&gt;好了，有关RocketMQ的原理我们之后再单独讲解，现在我们继续看Kafka的高可用实现。&lt;/p&gt;
&lt;p&gt;Kafka 0.8 以后，才正式开始支持高可用的，它提供了 HA 机制，就是 replica（复制品） 副本机制。每个 partition 的数据都会同步到其它机器上，形成自己的多个 replica 副本。所有 replica 会选举一个 leader 出来，那么生产和消费都跟这个 leader 打交道，然后其他 replica 就是 follower。写的时候，leader 会负责把数据同步到所有 follower 上去，读的时候就直接读 leader 上的数据即可。只能读写 leader？很简单，要是你可以随意读写每个 follower，那么就要 考虑数据一致性的问题，系统复杂度太高，很容易出问题。Kafka 会均匀地将一个 partition 的所有 replica 分布在不同的机器上，这样才可以提高容错性。&lt;/p&gt;
&lt;p&gt;我们看一下下图，就是Kafka的高可用原理：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1140467/202009/1140467-20200911211906275-189343591.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这样的一套架构下，Kafka就实现高可用了。因为如果某个Broker挂掉了，他的partition在其他Broker中都有副本。如果挂掉的Broker上有某个 partition 的 leader，那么此时会从 follower 中重新选举一个新的 leader 出来，大家继续读写那个新的 leader 即可。这就有所谓的高可用性了。&lt;/p&gt;
&lt;p&gt;写数据的时候，生产者就向 leader写数据，然后 leader 将数据落地写本地磁盘，接着其他 follower 自己主动从 leader 来 pull 数据。一旦所有 follower 同步好数据了，就会发送 ack 给 leader，leader 收到所有 follower 的 ack 之后，就会返回写成功的消息给生产者。（当然，这只是其中一种模式，还可以适当调整这个行为）&lt;/p&gt;
&lt;p&gt;消费的时候，只会从 leader 去读，但是只有当一个消息已经被所有 follower 都同步成功返回 ack 的时候，这个消息才会被消费者读到。&lt;/p&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;h3&gt;总结&lt;/h3&gt;
&lt;p&gt;好了，说了这么多，我相信小伙伴们对于RabbitMQ和Kafka的高可用集群原理一定会有个很深的认识了吧。那王子给大家留下一个思考题，现在你能自己说出RabbitMQ、Kafka、RocketMQ的高可用集群有什么不同了吗？&lt;/p&gt;
&lt;p&gt;今天的分享就到这里，欢迎大家持续阅读王子的消息中间件专辑，一起闲谈消息中间件的里里外外吧。&lt;/p&gt;

&lt;p&gt;往期文章推荐：&lt;/p&gt;
&lt;p&gt;中间件专辑：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/8YQBWSEcYqP9OwqEDx9WSg&quot; target=&quot;_blank&quot;&gt;什么是消息中间件？主要作用是什么？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/9-nwO3sXU1EqRW3QTIbH8g&quot; target=&quot;_blank&quot;&gt;常见的消息中间件有哪些？你们是怎么进行技术选型的？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/9K6Ijo4Bgo5MCYg3mANXPA&quot; target=&quot;_blank&quot;&gt;你懂RocketMQ 的架构原理吗？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/hXvBbKzCDAPNB24MGlnqSQ&quot; target=&quot;_blank&quot;&gt;聊一聊RocketMQ的注册中心NameServer&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/bRPpqkPGKHZnyaoouSUqoA&quot; target=&quot;_blank&quot;&gt;Broker的主从架构是怎么实现的？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/96ydDrg3LuUmg02ARKCcww&quot; target=&quot;_blank&quot;&gt;RocketMQ生产部署架构如何设计&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;算法专辑：&lt;/p&gt;
&lt;p id=&quot;activity-name&quot; class=&quot;rich_media_title&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/6tP1vDJ5lQcA-xvUoKWIZA&quot; target=&quot;_blank&quot;&gt;和同事谈谈Flood Fill 算法&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;rich_media_title&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/Bge_Q20FIb6AZghL4UneGg&quot; target=&quot;_blank&quot;&gt;详解股票买卖算法的最优解(一)&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;rich_media_title&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/25M8TrKcCvLlLe2v7OSfBA&quot; target=&quot;_blank&quot;&gt;详解股票买卖算法的最优解(二)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1140467/202009/1140467-20200901142419527-2040845842.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 11 Sep 2020 13:38:00 +0000</pubDate>
<dc:creator>H.U.C-王子</dc:creator>
<og:description>前言 小伙伴们，通过前边文章的阅读，相信大家已经对RocketMQ的基本原理有了一个比较深入的了解，那么大家对当前比较常用的RabbitMQ和Kafka是不是也有兴趣了解一些呢，了解的多一些也不是坏事</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lm970585581/p/13652841.html</dc:identifier>
</item>
<item>
<title>LC算法技巧总结（二）：双指针和滑动窗口技巧 - RioTian</title>
<link>http://www.cnblogs.com/RioTian/p/13654412.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/RioTian/p/13654412.html</guid>
<description>&lt;p&gt;我把双指针技巧再分为两类，一类是「快慢指针」，一类是「左右指针」。前者解决主要解决链表中的问题，比如典型的判定链表中是否包含环；后者主要解决数组（或者字符串）中的问题，比如二分查找。&lt;/p&gt;
&lt;h2 id=&quot;一、快慢指针的常见算法&quot;&gt;一、快慢指针的常见算法&lt;/h2&gt;
&lt;p&gt;快慢指针一般都初始化指向链表的头结点 head，前进时快指针 fast 在前，慢指针 slow 在后，巧妙解决一些链表中的问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、判定链表中是否含有环&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这应该属于链表最基本的操作了，如果读者已经知道这个技巧，可以跳过。&lt;/p&gt;
&lt;p&gt;单链表的特点是每个节点只知道下一个节点，所以一个指针的话无法判断链表中是否含有环的。&lt;/p&gt;
&lt;p&gt;如果链表中不含环，那么这个指针最终会遇到空指针 null 表示链表到头了，这还好说，可以判断该链表不含环。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;boolean hasCycle(ListNode head) {
    while (head != null)
        head = head.next;
    return false;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是如果链表中含有环，那么这个指针就会陷入死循环，因为环形数组中没有 null 指针作为尾部节点。&lt;/p&gt;
&lt;p&gt;经典解法就是用两个指针，一个跑得快，一个跑得慢。如果不含有环，跑得快的那个指针最终会遇到 null，说明链表不含环；如果含有环，快指针最终会超慢指针一圈，和慢指针相遇，说明链表含有环。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;boolean hasCycle(ListNode head) {
    ListNode fast, slow;
    fast = slow = head;
    while (fast != null &amp;amp;&amp;amp; fast.next != null) {
        fast = fast.next.next;
        slow = slow.next;

        if (fast == slow) return true;
    }
    return false;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2、已知链表中含有环，返回这个环的起始位置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com//riotian/blogimage/raw/master/img/20200911211528.png&quot; alt=&quot;img&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个问题一点都不困难，有点类似脑筋急转弯，先直接看代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;ListNode detectCycle(ListNode head) {
    ListNode fast, slow;
    fast = slow = head;
    while (fast != null &amp;amp;&amp;amp; fast.next != null) {
        fast = fast.next.next;
        slow = slow.next;
        if (fast == slow) break;
    }
    // 上面的代码类似 hasCycle 函数
    slow = head;
    while (slow != fast) {
        fast = fast.next;
        slow = slow.next;
    }
    return slow;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，当快慢指针相遇时，让其中任一个指针指向头节点，然后让它俩以相同速度前进，再次相遇时所在的节点位置就是环开始的位置。这是为什么呢？&lt;/p&gt;
&lt;p&gt;第一次相遇时，假设慢指针 slow 走了 k 步，那么快指针 fast 一定走了 2k 步，也就是说比 slow 多走了 k 步（也就是环的长度）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com//riotian/blogimage/raw/master/img/20200911211536.png&quot; alt=&quot;img&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;设相遇点距环的起点的距离为 m，那么环的起点距头结点 head 的距离为 k - m，也就是说如果从 head 前进 k - m 步就能到达环起点。&lt;/p&gt;
&lt;p&gt;巧的是，如果从相遇点继续前进 k - m 步，也恰好到达环起点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com//riotian/blogimage/raw/master/img/20200911211614.png&quot; alt=&quot;img&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以，只要我们把快慢指针中的任一个重新指向 head，然后两个指针同速前进，k - m 步后就会相遇，相遇之处就是环的起点了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、寻找链表的中点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;类似上面的思路，我们还可以让快指针一次前进两步，慢指针一次前进一步，当快指针到达链表尽头时，慢指针就处于链表的中间位置。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;while (fast != null &amp;amp;&amp;amp; fast.next != null) {
    fast = fast.next.next;
    slow = slow.next;
}
// slow 就在中间位置
return slow;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当链表的长度是奇数时，slow 恰巧停在中点位置；如果长度是偶数，slow 最终的位置是中间偏右：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com//riotian/blogimage/raw/master/img/20200911211604.png&quot; alt=&quot;img&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;寻找链表中点的一个重要作用是对链表进行归并排序。&lt;/p&gt;
&lt;p&gt;回想数组的归并排序：求中点索引递归地把数组二分，最后合并两个有序数组。对于链表，合并两个有序链表是很简单的，难点就在于二分。&lt;/p&gt;
&lt;p&gt;但是现在你学会了找到链表的中点，就能实现链表的二分了。关于归并排序的具体内容本文就不具体展开了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4、寻找链表的倒数第 k 个元素&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们的思路还是使用快慢指针，让快指针先走 k 步，然后快慢指针开始同速前进。这样当快指针走到链表末尾 null 时，慢指针所在的位置就是倒数第 k 个链表节点（为了简化，假设 k 不会超过链表长度）：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-Java&quot;&gt;ListNode slow, fast;
slow = fast = head;
while (k-- &amp;gt; 0) 
    fast = fast.next;

while (fast != null) {
    slow = slow.next;
    fast = fast.next;
}
return slow;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;二、左右指针的常用算法&quot;&gt;二、左右指针的常用算法&lt;/h2&gt;
&lt;p&gt;左右指针在数组中实际是指两个索引值，一般初始化为 left = 0, right = nums.length - 1 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、二分查找&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以前写的《二分查找》有详细讲解，这里只写最简单的二分算法，旨在突出它的双指针特性：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;int binarySearch(int[] nums, int target) {
    int left = 0; 
    int right = nums.length - 1;
    while(left &amp;lt;= right) {
        int mid = (right + left) / 2;
        if(nums[mid] == target)
            return mid; 
        else if (nums[mid] &amp;lt; target)
            left = mid + 1; 
        else if (nums[mid] &amp;gt; target)
            right = mid - 1;
    }
    return -1;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2、两数之和&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;直接看一道 LeetCode 题目（经典Two Sum）吧：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com//riotian/blogimage/raw/master/img/20200911211657.png&quot; alt=&quot;img&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;只要数组有序，就应该想到双指针技巧。这道题的解法有点类似二分查找，通过调节 left 和 right 可以调整 sum 的大小：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-Java&quot;&gt;int[] twoSum(int[] nums, int target) {
    int left = 0, right = nums.length - 1;
    while (left &amp;lt; right) {
        int sum = nums[left] + nums[right];
        if (sum == target) {
            // 题目要求的索引是从 1 开始的
            return new int[]{left + 1, right + 1};
        } else if (sum &amp;lt; target) {
            left++; // 让 sum 大一点
        } else if (sum &amp;gt; target) {
            right--; // 让 sum 小一点
        }
    }
    return new int[]{-1, -1};
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;3、反转数组&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-Java&quot;&gt;void reverse(int[] nums) {
    int left = 0;
    int right = nums.length - 1;
    while (left &amp;lt; right) {
        // swap(nums[left], nums[right])
        int temp = nums[left];
        nums[left] = nums[right];Java
        nums[right] = temp;
        left++; right--;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;4、滑动窗口算法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这也许是双指针技巧的最高境界了，如果掌握了此算法，可以解决一大类子字符串匹配的问题，不过「滑动窗口」稍微比上述的这些算法复杂些。&lt;/p&gt;
&lt;p&gt;详情见下文（来自东哥的算法讲解的思路）&lt;/p&gt;
&lt;h2 id=&quot;三、滑动窗口技巧&quot;&gt;三、滑动窗口技巧&lt;/h2&gt;
&lt;p&gt;滑动窗口算法框架中，这里转自一首小诗来介绍。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com//riotian/blogimage/raw/master/img/20200911212036.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;本文就解决一类最难掌握的双指针技巧：滑动窗口技巧。总结出一套框架，可以保你闭着眼睛都能写出正确的解法。&lt;/p&gt;
&lt;p&gt;说起滑动窗口算法，很多读者都会头疼。这个算法技巧的思路非常简单，就是维护一个窗口，不断滑动，然后更新答案么。LeetCode 上有起码 10 道运用滑动窗口算法的题目，难度都是中等和困难。该算法的大致逻辑如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;int left = 0, right = 0;

while (right &amp;lt; s.size()) {`
    // 增大窗口
    window.add(s[right]);
    right++;

    while (window needs shrink) {
        // 缩小窗口
        window.remove(s[left]);
        left++;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个算法技巧的时间复杂度是 O(N)，比字符串暴力算法要高效得多。&lt;/p&gt;
&lt;p&gt;其实困扰大家的，不是算法的思路，而是各种细节问题。比如说如何向窗口中添加新元素，如何缩小窗口，在窗口滑动的哪个阶段更新结果。即便你明白了这些细节，也容易出 bug，找 bug 还不知道怎么找，真的挺让人心烦的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所以今天我就写一套滑动窗口算法的代码框架，我连再哪里做输出 debug 都给你写好了，以后遇到相关的问题，你就默写出来如下框架然后改三个地方就行，还不会出 bug&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;/* 滑动窗口算法框架 */
void slidingWindow(string s, string t) {
    unordered_map&amp;lt;char, int&amp;gt; need, window;
    for (char c : t) need[c]++;

    int left = 0, right = 0;
    int valid = 0; 
    while (right &amp;lt; s.size()) {
        // c 是将移入窗口的字符
        char c = s[right];
        // 右移窗口
        right++;
        // 进行窗口内数据的一系列更新
        ...

        /*** debug 输出的位置 ***/
        printf(&quot;window: [%d, %d)\n&quot;, left, right);
        /********************/

        // 判断左侧窗口是否要收缩
        while (window needs shrink) {
            // d 是将移出窗口的字符
            char d = s[left];
            // 左移窗口
            left++;
            // 进行窗口内数据的一系列更新
            ...
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;其中两处&lt;/strong&gt; &lt;strong&gt;&lt;code&gt;...&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;表示的更新窗口数据的地方，到时候你直接往里面填就行了&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;而且，这两个 &lt;code&gt;...&lt;/code&gt; 处的操作分别是右移和左移窗口更新操作，等会你会发现它们操作是完全对称的。&lt;/p&gt;
&lt;p&gt;说句题外话，我发现很多人喜欢执着于表象，不喜欢探求问题的本质。比如说有很多人评论我这个框架，说什么散列表速度慢，不如用数组代替散列表；还有很多人喜欢把代码写得特别短小，说我这样代码太多余，影响编译速度，LeetCode 上速度不够快。&lt;/p&gt;
&lt;p&gt;我服了。算法看的是时间复杂度，你能确保自己的时间复杂度最优，就行了。至于 LeetCode 所谓的运行速度，那个都是玄学，只要不是慢的离谱就没啥问题，根本不值得你从编译层面优化，不要舍本逐末……&lt;/p&gt;
</description>
<pubDate>Fri, 11 Sep 2020 13:23:00 +0000</pubDate>
<dc:creator>RioTian</dc:creator>
<og:description>我把双指针技巧再分为两类，一类是「快慢指针」，一类是「左右指针」。前者解决主要解决链表中的问题，比如典型的判定链表中是否包含环；后者主要解决数组（或者字符串）中的问题，比如二分查找。 一、快慢指针的常</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/RioTian/p/13654412.html</dc:identifier>
</item>
<item>
<title>通俗语言解释数据仓库、数据湖、数据中台 - 并不是触手</title>
<link>http://www.cnblogs.com/bbscs/p/13654309.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bbscs/p/13654309.html</guid>
<description>
&lt;p&gt;&lt;span&gt;如何理解数据仓库？举个简单的例子。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我现在打算学习大数据的内容，所以我看了CSDN，博客园，微信的大数据公众号，一些实体书等等，并且我在看某些这些东西的时候，有些不错的文章我都收藏了，储存在这些论坛的账号中，实体书我也做了很多标记，来标出那些对我有用的部分。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;看了好几个月之后，我打算来一次整体的复习，结果这个时候遇到了困难：&lt;span&gt;我收藏的文章太多了，我完全记不得到底哪些文章在哪里了，如果我要找某一篇文章，我可能要从头开始一个一个的翻找这些论坛的收藏夹，看看我要找的东西到底在哪里，况且还要实体书呢！也要翻一遍！&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  这工作量也太大了，而且我每找一次东西都要几乎从头开始找一次，太麻烦了，此时我想到，我为什么不把我收藏夹的那些东西都放到一个地方呢？这样我也不用登录很多账号找了，此时我就想到，我是不是可以用Word软件呢？把收藏夹里面的文章都复制到Word里不就可以了吗？而且Word软件还有查找功能，比这样翻找的快太多了！立马行动，我开始把一篇文章从标题到内容全都复制到Word文档里，实体书上的我也打字打进来，花了好几天时间，我终于把所有的东西都搬到Word文档上了，真是累死了！&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;  这个时候我又有了新的麻烦：&lt;span&gt;虽然我按照一篇文档一个文件来分开，但是这些文件非常多，而且标题都不明确，单从文件名字上来看根本就不知道内容是什么，如果要知道是什么内容，还是需要一个一个打开来看。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;  这样并不比之前的操作要轻松啊？我花了这么多的时间，结果也就省了一个打开网页的操作，反而又增加了一个打开Word文档的操作，这样似乎比之前更麻烦了，毕竟我的电脑打开网页还好，打开Word可慢多了，这要怎么办呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这时候我又想到了一个办法：把这些文档全部打开看看，然后把文件名字改好，改成我一眼就能看得懂的名字，这样就很便于查找了吧，毕竟看一眼名字就知道这个文件是不是我想要的，于是我又花了好几天的时间，把这些文档按照文章的内容，概括出来一个主题，把它当作文档的名字，当我完成之后我觉得目前就可以很轻松的通过Wrod自带的查找功能来找到我想要的文档来看了，我觉得我的整理工作以及结束了&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;  可是当我开始复习这些资料的时候，又发现了一个问题：&lt;span&gt;这些文档读起来很冗余，很多的地方都是重复的，而且有的几乎都全部重复了仅仅有一小部分才是不同的&lt;/span&gt;，比如什么Hadoop的定义啥的，这些很多文档都写了，而且都是一模一样的，每次打开文档都要看一遍，而且还很占用我的磁盘空间，而另外一些，比如Hadoop的版本解读，我搜集的这些文档，从1.0.x到3.0.x的版本解读都有，但是我想要从1.0到3.0的版本变化，这样的话的得把这些文档全部都打开，然后一个文档一个文档的看，每次这样翻我也很烦躁，我只想更懒一点，为什么没有一个文档整理了从1.0到3.0所有的版本变化呢？我在网上也没找到，哎，靠人不如靠自己，我还是自己来吧！&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;  这个时候我经过了前两次的整理经历之后我学聪明了，我没有一开始就着手整理，我想了一下，我现在到底需要整理成什么样子？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.不变的东西整理到一个文档里面去，上面写上xxxx定义 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.会变的东西，比如版本解读啥的，每个版本都会有一个文档，这些我也整理到一个文档里面去，这样我就不用到处翻来翻去了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.但是之前的这些东西我不能删掉，我自己合并的东西可能有的不全，或者是合并的有问题，我需要找原来的文档对比一下，如果我把之前的删掉，一旦我打错了字，我可能就会一直学了错的知识了&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;  好吧，我目前就想到这么多，那我就开始整理吧！于是我又花了好几天的时间，把原来的文档中的东西提取出来，重复的定义都合并到一起并且只留一份，不同的版本解读我放到一个文档里面去，然后我要保存之前的那些原始的文档，这俩东西不能都在一个都放在一个文件夹里面吧，这样也太乱了，于是我又打算吧这两个放在两个文件夹里面，我创建了两个文件夹，一个存放原始的文档，一个存放我整理好的文档，然后把这俩文件夹都放到&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一个叫知识库的文件夹里面，这样我的整理工作貌似真的已经完成了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;现在，我想看Hadoop相关的版本解读的话，我就打开版本解读文档就可以了，如果我想看Hadoop的定义和版本解读呢？我就打开这两个文档，一个放在屏幕左边，一个放在右边，这样看起来也很舒服，至此，我的整理工作真的算完成了。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;  然后我突然想到，&lt;span&gt;我X，我不就是在搭建数据仓库吗？？？&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  是的，大家看到这里，如果对数据仓库有了一些了解的话已经知道了数据仓库的一般流程了，把上文的一些名词换成数据仓库的名词：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;  各个论坛和实体书的文章 -&amp;gt;搭建数仓之前各个系统的数据源，比如MySQL，Oracle等传统关系型数据，还要一些业务日志和埋点日志（比如说你在某宝点击某个商品啊，浏览了某些商品啊，这些都是有记录的，也叫做埋点数据，前端已经在你点击进入这个商品的详情页的时候做了埋点，你点进去就会产生了一条数据，会记录你点击的商品记录和你这个用户的一般信息，这就叫做埋点日志）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  把这些不在同一个论坛，甚至在实体书上的文章，都统一放到Word文档上，并且稍微改个文件名 ---&amp;gt;利用一些数据导入工具，比如Sqoop，Flume，DataX（阿里云的产品，但已开源），把这些不同系统上面的数据，都导入到同一个框架里，这里大部分都是导入到Hive里，它利用HDFS存储，具有天然的容灾性，查询的引擎是MR（也可以使用Spark），对于这么大的数据量是再适合不过了。这种迁移数据的行为已经是搭建数仓的一部分了，这些迁移过来的数据作为数据仓库的ODS层（数据准备层），这一层是为加下来的数据层提供原始数据，我们尽量不做什么变动，只做一些数据按日期分表存储，把这些数据按照主题和逻辑划分好。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  把文章去重，把版本解读放到一起 ---&amp;gt;对应数据仓库的DW层，这一层的主要任务就是把原始数据进行ETL，把原始数据分为维度表和事实表（这种方法称为维度建模），把细粒度的数据聚合成粗粒的表，把一些维度退化，形成业务宽表等等&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  使用文档  ---&amp;gt;对应数据仓库的ADS层（也叫ST层），ST层面向用户应用和分析需求，包括前端报表、分析图表、KPI、仪表盘、OLAP、专题等分析，面向最终结果用户&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  这样，我们就完成了一个简单的数据仓库（三层），其中DW层还可以细分为DWD,DM等，这个就看实际情况了，灵活分层&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;至于数据湖和数据中台呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  我是这样理解数据湖的，上面的例子里，我们在把各种不同论坛的文章导入到Word文档中的时候，其实已经丢失掉了一层信息：来源&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;放到Word文档之后，你就无法知道某篇文章到底来自于哪个论坛的了 ，而数据湖呢？数据湖是尽力保持所有数据的原始面貌，不丢失任何信息，同样，也不会做任何的处理（因为你处理数据多多少少会丢失掉一部分信息），尽力保持数据的原汁原味，因为谁也不知道以后某些数据又拥有多达的价值，所以我们需要保持数据的原封原貌，而这个时候我们可以把数据仓库想象成一个在湖边的矿泉水加工厂，一边抽取湖中的水（数据），进行各种清洗消毒加工，最后生产出各种各样包装的矿泉水来，这就是这两个概念我自己理解。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  下面是维基百科上关于数据湖的定义：&lt;span&gt;数据湖（Data Lake）是一个存储企业的各种各样原始数据的大型仓库，其中的数据可供存取、处理、分析及传输。数据湖是以其自然格式存储的数据的系统或存储库，通常是对象blob或文件。数据湖通常是企业所有数据的单一存储，包括源系统数据的原始副本，以及用于报告、可视化、分析和机器学习等任务的转换数据。数据湖可以包括来自关系数据库（行和列）的结构化数据，半结构化数据（CSV，日志，XML，JSON），非结构化数据（电子邮件，文档，PDF）和二进制数据（图像，音频，视频）&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;至于数据中台呢？我们先来看下数据中台的定义：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;  数据中台是指通过企业内外部多源异构的数据采集、治理、建模、分析，应用，使数据对内优化管理提高业务，对外可以数据合作价值释放，成为企业数据资产管理中枢。数据中台建立后，会形成数据API，为企业和客户提供高效各种数据服务。&lt;/span&gt;（这个概念最早由阿里提出，实际上阿里云的一些云产品就是一个大的数据中台）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  又回到之前说的矿泉水加工厂的例子，如果我们只有一个加工厂，那肯定是仅仅不够的，因为我们不仅要喝水，还要喝的是安全健康的水，这个检测如果工厂内自己做，大家还是不太相信的，那么还是需要别人来检测，监管加工厂的质量和水质等安全问题，这些的监管检测机制，而且还有一个问题就是，加工厂缺少一个管账的，内部的财务状况很混乱， 因此，加工厂又请了另一家公司来为他们做财务管理，如此，再加上加工厂内部的更新换代，又增加了新技术来加工矿泉水（机器学习，数据挖掘等），加工厂是越来越大了，而包含兼管人员，财务管理和整个加工厂在内的，就是大家常说的数据中台了。&lt;/span&gt;&lt;/p&gt;

&lt;div&gt;&lt;span&gt;&lt;img src=&quot;https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/ZBjVrHIdkOmjpTzdkPiaxG1thv6u0CmUgntSf48ww6Wmg5ulOuzYyvBMLm5S9dYJsAt8S4MkRHMLXb98vskd7zA/640?wx_fmt=png&quot; width=&quot;1080&quot; height=&quot;476&quot;/&gt;&lt;/span&gt;&lt;/div&gt;



&lt;p&gt;&lt;span&gt;以上就是我自己理解的数据仓库、数据湖和数据中台的概念了，如果有错误，欢迎在评论区指正！&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 11 Sep 2020 13:10:00 +0000</pubDate>
<dc:creator>并不是触手</dc:creator>
<og:description>数据仓库 如何理解数据仓库？举个简单的例子。 我现在打算学习大数据的内容，所以我看了CSDN，博客园，微信的大数据公众号，一些实体书等等，并且我在看某些这些东西的时候，有些不错的文章我都收藏了，储存在</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/bbscs/p/13654309.html</dc:identifier>
</item>
<item>
<title>[业界方案]用Jaeger来学习分布式追踪系统Opentracing - 罗西的思考</title>
<link>http://www.cnblogs.com/rossiXYZ/p/13654065.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/rossiXYZ/p/13654065.html</guid>
<description>&lt;p&gt;笔者之前有过zipkin的经验，希望扩展到Opentracing，于是在学习Jaeger基础上总结出此文，与大家分享。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;600.16498493288&quot;&gt;


&lt;h2 id=&quot;0x00-摘要&quot;&gt;0x00 摘要&lt;/h2&gt;
&lt;p&gt;笔者之前有过zipkin的经验，希望扩展到Opentracing，于是在学习Jaeger基础上总结出此文，与大家分享。&lt;/p&gt;
&lt;h2 id=&quot;0x01-缘由--问题&quot;&gt;0x01 缘由 &amp;amp; 问题&lt;/h2&gt;
&lt;h3 id=&quot;11-选择jaeger&quot;&gt;1.1 选择Jaeger&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Jaeger&lt;/code&gt; 是 &lt;code&gt;Uber&lt;/code&gt; 开发的一款调用链服务端产品，开发语言为 &lt;code&gt;golang&lt;/code&gt; ，能够兼容接收 &lt;code&gt;OpenTracing&lt;/code&gt; 格式的数据。根据其发展历史，可以说是 &lt;code&gt;Zipkin&lt;/code&gt; 的升级版。另外，其基于 &lt;code&gt;udp&lt;/code&gt; （也可以 &lt;code&gt;http&lt;/code&gt; ）的传输协议，更加定位了其高效、迅速的特点。&lt;/p&gt;
&lt;p&gt;在前文 &lt;a href=&quot;https://www.cnblogs.com/rossiXYZ/p/13641637.html&quot;&gt;[业界方案] 用SOFATracer学习分布式追踪系统Opentracing&lt;/a&gt; ，我们使用SOFATracer来进行学习，本次我们选择了Jaeger，这又是什么原因？具体如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Jaeger是Opentracing官方推荐的。&lt;/li&gt;
&lt;li&gt;Jaeger支持Opentracing高版本。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;而且我们正好可以和SOFATracer进行对比印证。&lt;/p&gt;
&lt;h3 id=&quot;12-问题&quot;&gt;1.2 问题&lt;/h3&gt;
&lt;p&gt;让我们用问题来引导阅读。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Jaeger 和 SOFATracer 对比如何？&lt;/li&gt;
&lt;li&gt;spanId是怎么生成的，有什么规则?&lt;/li&gt;
&lt;li&gt;traceId是怎么生成的，有什么规则？&lt;/li&gt;
&lt;li&gt;客户端哪里生成的Span？&lt;/li&gt;
&lt;li&gt;ParentSpan 从哪儿来？&lt;/li&gt;
&lt;li&gt;ChildSpan由ParentSpan创建，那么什么时候创建？&lt;/li&gt;
&lt;li&gt;Trace信息怎么传递？&lt;/li&gt;
&lt;li&gt;服务器接收到请求之后做什么？&lt;/li&gt;
&lt;li&gt;SpanContext在服务器端怎么处理？&lt;/li&gt;
&lt;li&gt;链路信息如何搜集？&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;13-本文讨论范围&quot;&gt;1.3 本文讨论范围&lt;/h3&gt;
&lt;h4 id=&quot;131-jaeger构成&quot;&gt;1.3.1 Jaeger构成&lt;/h4&gt;
&lt;p&gt;Jaeger主要由以下几部分组成：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Jaeger Client： 为了不同语言实现了符合OpenTracing标准的SDK。应用程序通过API写入数据， client library把trace信息按照应用程序制定的采样策略传递给jaeger-agent。&lt;/li&gt;
&lt;li&gt;Agent： 他是一个监听在UDP端口上接收span数据的网络守护进程，它会将数据批量发送给collector。他被设计成一个基础组件，部署到所有的宿主机上。Agent将client library和collector解耦，为client library屏蔽了路由和发现collector的细节。&lt;/li&gt;
&lt;li&gt;Collector：接收jaeger-agent发送来的数据，然后将数据写入后端存储。Collector被设计成无状态的组件，因此用户可以运行任意数量的Collector。&lt;/li&gt;
&lt;li&gt;Data Store：后端存储被设计成一个可插拔的组件，支持数据写入cassandra， elastic search。&lt;/li&gt;
&lt;li&gt;Query：接收查询请求，然后从后端存储系统中检索tarce并通过UI进行展示。Query是无状态的，可以启动多个实例。把他们部署在nginx这样的负载均衡器后面。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;u&gt;本文只讨论 Jaeger Client 功能&lt;/u&gt;。&lt;/p&gt;
&lt;h4 id=&quot;132-全链路跟踪&quot;&gt;1.3.2 全链路跟踪&lt;/h4&gt;
&lt;p&gt;全链路跟踪分成三个跟踪级别：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;跨进程跟踪 (cross-process)(调用另一个微服务)&lt;/li&gt;
&lt;li&gt;数据库跟踪&lt;/li&gt;
&lt;li&gt;进程内部的跟踪 (in-process)(在一个函数内部的跟踪)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;u&gt;本文只讨论 跨进程跟踪 (cross-process)&lt;/u&gt;，因为跨进程跟踪是最简单的 ^_^。对于跨进程跟踪，你可以编写拦截器或过滤器来跟踪每个请求，它只需要编写极少的代码。&lt;/p&gt;
&lt;h2 id=&quot;0x02-背景知识&quot;&gt;0x02 背景知识&lt;/h2&gt;
&lt;p&gt;因为前文已经对背景知识做了较详细的介绍，本文只是提一下几个必要概念。&lt;/p&gt;
&lt;p&gt;分布式追踪系统发展很快，种类繁多，但核心步骤一般有三个：&lt;strong&gt;代码埋点，数据存储、查询展示&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在数据采集过程，需要侵入用户代码做埋点，不同系统的API不兼容会导致切换追踪系统需要做很大的改动。为了解决这个问题，诞生了opentracing 规范。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-ruby&quot;&gt;   +-------------+  +---------+  +----------+  +------------+
   | Application |  | Library |  |   OSS    |  |  RPC/IPC   |
   |    Code     |  |  Code   |  | Services |  | Frameworks |
   +-------------+  +---------+  +----------+  +------------+
          |              |             |             |
          |              |             |             |
          v              v             v             v
     +-----------------------------------------------------+
     | · · · · · · · · · · OpenTracing · · · · · · · · · · |
     +-----------------------------------------------------+
       |               |                |               |
       |               |                |               |
       v               v                v               v
 +-----------+  +-------------+  +-------------+  +-----------+
 |  Tracing  |  |   Logging   |  |   Metrics   |  |  Tracing  |
 | System A  |  | Framework B |  | Framework C |  | System D  |
 +-----------+  +-------------+  +-------------+  +-----------+
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;大多数分布式追踪系统的思想模型都来自Google's Dapper论文，&lt;strong&gt;OpenTracing&lt;/strong&gt;也使用相似的&lt;strong&gt;术语&lt;/strong&gt;。有几个基本概念我们需要提前了解清楚：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Trace(追踪) ：Dapper 将一个调用过程构建成一棵调用树(称为Tracer)，Tracer树中的每个节点表示链路调用中的一个模块或系统。 通过一个全局唯一的 traceId 来标识一个请求调用链。&lt;u&gt;在广义上，一个trace代表了一个事务或者流程在（分布式）系统中的执行过程&lt;/u&gt;。在OpenTracing标准中，trace是多个span组成的一个有向无环图（DAG），每一个span代表trace中被命名并计时的连续性的执行片段。&lt;/li&gt;
&lt;li&gt;Span(跨度) ：&lt;u&gt;一个span代表系统中具有开始时间和执行时长的逻辑运行单元，即应用中的一个逻辑操作&lt;/u&gt;。span之间通过嵌套或者顺序排列建立逻辑因果关系。一个span可以被理解为一次方法调用，一个程序块的调用，或者一次RPC/数据库访问，只要是一个具有完整时间周期的程序访问，都可以被认为是一个span。&lt;u&gt;Dapper中&lt;/u&gt;，一个span 包含以下阶段（不同软件可能有不同的实现 ，比如有的会细分为 Client Span 和 Server Span）：
&lt;ul&gt;&lt;li&gt;Start: 发起调用&lt;/li&gt;
&lt;li&gt;cleint send(cs): 客户端发送请求&lt;/li&gt;
&lt;li&gt;Server Recv(sr)：服务端收到请求&lt;/li&gt;
&lt;li&gt;Server Send(ss): 服务端发送响应&lt;/li&gt;
&lt;li&gt;Client Recv(cr) : 客户端收到服务端响应&lt;/li&gt;
&lt;li&gt;End： 整个链路完成。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;     Client                             Server

+--------------+     Request        +--------------+
| Client Send  | +----------------&amp;gt; |Server Receive|
+------+-------+                    +------+-------+
       |                                   |
       |                                   v
       |                            +------+--------+
       |                            |Server Business|
       |                            +------+--------+
       |                                   |
       |                                   |
       v                                   v
+------+--------+    Response       +------+-------+
|Client Receive | &amp;lt;---------------+ |Server Send   |
+------+--------+                   +------+-------+
       |                                   |
       |                                   |
       v                                   v
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;Logs ：每个span可以进行多次Logs操作，每一次Logs操作，都需要一个带时间戳的时间名称，以及可选的任意大小的存储结构。比较适合记录日志、异常栈等一些和时间相关的信息。&lt;/li&gt;
&lt;li&gt;Tags ：每个span可以有多个键值对（key ：value）形式的Tags，Tags是没有时间戳的，支持简单的对span进行注解和补充。记录的信息适用于span从创建到完成的任何时刻。再说直白点就是记录和时间点无关的信息，这个主要是和下面的Logs作区分。&lt;/li&gt;
&lt;li&gt;Baggage Items：这个主要是用于跨进程全局传输数据&lt;/li&gt;
&lt;li&gt;SpanContext ：&lt;code&gt;SpanContext&lt;/code&gt;更像是一个“概念”，而不是通用 OpenTracing 层的有用功能。在创建&lt;code&gt;Span&lt;/code&gt;、向传输协议&lt;code&gt;Inject&lt;/code&gt;（注入）和从传输协议中&lt;code&gt;Extract&lt;/code&gt;（提取）调用链信息时，&lt;code&gt;SpanContext&lt;/code&gt;发挥着重要作用。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;0x03-示例代码&quot;&gt;0x03 示例代码&lt;/h2&gt;
&lt;h3 id=&quot;31-代码&quot;&gt;3.1 代码&lt;/h3&gt;
&lt;p&gt;代码全部来自 &lt;a href=&quot;https://github.com/yurishkuro/opentracing-tutorial&quot;&gt;https://github.com/yurishkuro/opentracing-tutorial&lt;/a&gt;，大家可以自己去下载。&lt;/p&gt;
&lt;p&gt;这里的tracer使用的是 JaegerTracer。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Hello {

    private final Tracer tracer;
    private final OkHttpClient client;

    private Hello(Tracer tracer) {
        this.tracer = tracer;
        this.client = new OkHttpClient();
    }

    private String getHttp(int port, String path, String param, String value) {
        try {
            HttpUrl url = new HttpUrl.Builder().scheme(&quot;http&quot;).host(&quot;localhost&quot;).port(port).addPathSegment(path)
                    .addQueryParameter(param, value).build();
            Request.Builder requestBuilder = new Request.Builder().url(url);
            
            Span activeSpan = tracer.activeSpan();
            Tags.SPAN_KIND.set(activeSpan, Tags.SPAN_KIND_CLIENT);
            Tags.HTTP_METHOD.set(activeSpan, &quot;GET&quot;);
            Tags.HTTP_URL.set(activeSpan, url.toString());
            tracer.inject(activeSpan.context(), Format.Builtin.HTTP_HEADERS, Tracing.requestBuilderCarrier(requestBuilder));

            Request request = requestBuilder.build();
            Response response = client.newCall(request).execute();

            Tags.HTTP_STATUS.set(activeSpan, response.code());
            if (response.code() != 200) {
                throw new RuntimeException(&quot;Bad HTTP result: &quot; + response);
            }
            return response.body().string();
        } catch (Exception e) {
            Tags.ERROR.set(tracer.activeSpan(), true);
            tracer.activeSpan().log(ImmutableMap.of(Fields.EVENT, &quot;error&quot;, Fields.ERROR_OBJECT, e));
            throw new RuntimeException(e);
        }
    }

    private void sayHello(String helloTo, String greeting) {
        Span span = tracer.buildSpan(&quot;say-hello&quot;).start();
        try (Scope scope = tracer.scopeManager().activate(span)) {
            span.setTag(&quot;hello-to&quot;, helloTo);
            span.setBaggageItem(&quot;greeting&quot;, greeting);

            String helloStr = formatString(helloTo);
            printHello(helloStr);
        } finally {
            span.finish();
        }
    }

    private String formatString(String helloTo) {
        Span span = tracer.buildSpan(&quot;formatString&quot;).start();
        try (Scope scope = tracer.scopeManager().activate(span)) {
            String helloStr = getHttp(8081, &quot;format&quot;, &quot;helloTo&quot;, helloTo);
            span.log(ImmutableMap.of(&quot;event&quot;, &quot;string-format&quot;, &quot;value&quot;, helloStr));
            return helloStr;
        } finally {
            span.finish();
        }
    }

    private void printHello(String helloStr) {
        Span span = tracer.buildSpan(&quot;printHello&quot;).start();
        try (Scope scope = tracer.scopeManager().activate(span)) {
            getHttp(8082, &quot;publish&quot;, &quot;helloStr&quot;, helloStr);
            span.log(ImmutableMap.of(&quot;event&quot;, &quot;println&quot;));
        } finally {
            span.finish();
        }
    }

    public static void main(String[] args) {
        try (JaegerTracer tracer = Tracing.init(&quot;hello-world&quot;)) {
            new Hello(tracer).sayHello(&quot;helloTo&quot;, &quot;greeting&quot;);
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;32-dropwizard&quot;&gt;3.2 dropwizard&lt;/h3&gt;
&lt;p&gt;此处虽然不是SOFATracer和Jaeger的本质区别，但是也挺有趣，即&lt;u&gt;SOFATracer是使用SprintBoot来做示例代码，而此处是使用dropwizard来做示例&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;可能有人对dropwizard不熟悉，现在大致讲解如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Dropwizard是&lt;code&gt;Coda Hale&lt;/code&gt;在&lt;code&gt;Yammer&lt;/code&gt;公司时创立的，它旨在提升公司分布式系统的架构（现在叫：微服务）。虽然它最早被用来构建REST Web 服务，而现在它具备了越来越多的功能，但是它的目标始终是作为轻量化、为生产环境准备且容易使用的web框架。&lt;/li&gt;
&lt;li&gt;Dropwizard与Spring Boot类似，也是构建微服务可选的工具，但是它显得比Spring Boot更加规范一些。它使用的组件一般不会做可选替换，而好处是可以不需要那么多的修饰，比如写基于REST的web服务。&lt;/li&gt;
&lt;li&gt;Dropwizard默认也不具备依赖注入的容器（像Spring或者CDI），你当然可以自行添加，但是Dropwizard推荐你把微服务弄的简单一些，不需要这些额外的组件。&lt;/li&gt;
&lt;li&gt;就像Spring Boot一样，Dropwizard推荐将整个工程打包成一个可执行的jar，通过这种方式开发人员不用在担心程序运行的应用服务器是什么，需要什么额外的配置，应用再也不需要被构建成war包了，而且也不会有那么多复杂层级的类加载器了。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Dropwizard在优秀的三方库协助下，提供了不错的抽象层，使之更有效率，更简单的编写生产用途的微服务。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Servlet容器使用&lt;code&gt;Jetty&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;REST/JAX-RS实现使用&lt;code&gt;Jersey&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;JSON序列化使用&lt;code&gt;Jackson&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;集成&lt;code&gt;Hibernate Validator&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Guava&lt;/li&gt;
&lt;li&gt;Metrics&lt;/li&gt;
&lt;li&gt;SLF4J + Logback&lt;/li&gt;
&lt;li&gt;数据访问层上使用&lt;code&gt;JDBI&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Dropwizard偏执的认为框架就是用来写代码的，因此对于框架的底层技术栈的调整，原则上Dropwizard是拒绝的。正因为它这么做，使得Dropwizard开发起代码来更快，而且配置更加容易。&lt;/p&gt;
&lt;p&gt;对于我们的示例代码，对Dropwizard使用举例如下，即使用 Dropwizard 建立了两个服务和一个测试client。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;io.dropwizard.Application

public class Formatter extends Application&amp;lt;Configuration&amp;gt; {

    private final Tracer tracer;

    private Formatter(Tracer tracer) {
        this.tracer = tracer;
    }

    @Path(&quot;/format&quot;)
    @Produces(MediaType.TEXT_PLAIN)
    public class FormatterResource {

        @GET
        public String format(@QueryParam(&quot;helloTo&quot;) String helloTo, @Context HttpHeaders httpHeaders) {
            Span span = Tracing.startServerSpan(tracer, httpHeaders, &quot;format&quot;);
            try (Scope scope = tracer.scopeManager().activate(span)) {
                String greeting = span.getBaggageItem(&quot;greeting&quot;);
                if (greeting == null) {
                    greeting = &quot;Hello&quot;;
                }
                String helloStr = String.format(&quot;%s, %s!&quot;, greeting, helloTo);
                span.log(ImmutableMap.of(&quot;event&quot;, &quot;string-format&quot;, &quot;value&quot;, helloStr));
                return helloStr;
            } finally {
                span.finish();
            }
        }
    }

    @Override
    public void run(Configuration configuration, Environment environment) throws Exception {
        environment.jersey().register(new FormatterResource());
    }

    public static void main(String[] args) throws Exception {
        System.setProperty(&quot;dw.server.applicationConnectors[0].port&quot;, &quot;8081&quot;);
        System.setProperty(&quot;dw.server.adminConnectors[0].port&quot;, &quot;9081&quot;);
        try (JaegerTracer tracer = Tracing.init(&quot;formatter&quot;)) {
            new Formatter(tracer).run(&quot;server&quot;);
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;0x04-链路逻辑&quot;&gt;0x04 链路逻辑&lt;/h2&gt;
&lt;p&gt;对于一个组件来说，一次处理过程一般是产生一个 Span；这个 Span 的生命周期是从接收到请求到返回响应这段过程。&lt;/p&gt;
&lt;p&gt;这里需要考虑的问题是如何与上下游链路关联起来呢？在 Opentracing 规范中，可以在 Tracer 中 extract 出一个跨进程传递的 SpanContext 。然后通过这个 SpanContext 所携带的信息将当前节点关联到整个 Tracer 链路中去，当然有提取（extract）就会有对应的注入（inject）。&lt;/p&gt;
&lt;p&gt;链路的构建一般是 client-server-client-server 这种模式的，那这里就很清楚了，就是会在 client 端进行注入（inject），然后再 server 端进行提取（extract），反复进行，然后一直传递下去。&lt;/p&gt;
&lt;p&gt;在拿到 SpanContext 之后，此时当前的 Span 就可以关联到这条链路中了，那么剩余的事情就是收集当前组件的一些数据；整个过程大概分为以下几个阶段：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;从请求中提取 spanContext&lt;/li&gt;
&lt;li&gt;构建 Span，并将当前 Span 存入当前 tracer上下文中（SofaTraceContext.push(Span)） 。&lt;/li&gt;
&lt;li&gt;设置一些信息到 Span 中&lt;/li&gt;
&lt;li&gt;返回响应&lt;/li&gt;
&lt;li&gt;Span 结束&amp;amp;上报&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;0x05-数据模型&quot;&gt;0x05 数据模型&lt;/h2&gt;
&lt;h3 id=&quot;51-tracer--jaegertracer&quot;&gt;5.1 Tracer &amp;amp; JaegerTracer&lt;/h3&gt;
&lt;p&gt;Jaeger中的Tracer控制了一个完整的服务的追踪，包括注册服务名（serviceName），发送span（reporter），采样（sampler），对span的序列化与反序列化以及传输（registry的injector,extractor），统计追踪系统的信息（metrics，如发送span成功数量等）。&lt;/p&gt;
&lt;p&gt;因此opentracing建议每个服务使用一个Tracer，除此之外Tracer还担负构造span，获取当前span以及获取scopeManager的功能。&lt;/p&gt;
&lt;p&gt;通过opentracing的规范亦可以看出，opentracing对Tracer的功能描述为：Tracer is a simple, thin interface for Span creation and propagation across arbitrary transports。而jaeger只是在其基础上增加了其他功能。&lt;/p&gt;
&lt;p&gt;Tracer是opentracing给出的接口。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package io.opentracing;
public interface Tracer extends Closeable {
    ScopeManager scopeManager();
    Span activeSpan();
    Scope activateSpan(Span var1);
    Tracer.SpanBuilder buildSpan(String var1);
    &amp;lt;C&amp;gt; void inject(SpanContext var1, Format&amp;lt;C&amp;gt; var2, C var3);
    &amp;lt;C&amp;gt; SpanContext extract(Format&amp;lt;C&amp;gt; var1, C var2);
    void close();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;JaegerTracer 实现了 io.opentracing.Tracer。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class JaegerTracer implements Tracer, Closeable {
    private final String version;
    private final String serviceName;
    private final Reporter reporter;
    private final Sampler sampler;
    private final Map&amp;lt;String, ?&amp;gt; tags;
    private final boolean zipkinSharedRpcSpan;
    private final boolean expandExceptionLogs;
    private final boolean useTraceId128Bit;
    private final PropagationRegistry registry;
    private final Clock clock;
    private final Metrics metrics;
    private final ScopeManager scopeManager;
    private final BaggageSetter baggageSetter;
    private final JaegerObjectFactory objectFactory;
    private final int ipv4;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;52-span--jaegerspan&quot;&gt;5.2 Span &amp;amp; JaegerSpan&lt;/h3&gt;
&lt;p&gt;io.opentracing.Span 是 Opentracing 给出的概念。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public interface Span {
    SpanContext context();
    Span setTag(String var1, String var2);
    Span setTag(String var1, boolean var2);
    Span setTag(String var1, Number var2);
    &amp;lt;T&amp;gt; Span setTag(Tag&amp;lt;T&amp;gt; var1, T var2);
    Span setBaggageItem(String var1, String var2);
    String getBaggageItem(String var1);
    Span setOperationName(String var1);
    void finish();
    void finish(long var1);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;JaegerSpan 实现了 io.opentracing.SPan。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class JaegerSpan implements Span {
  private final JaegerTracer tracer;
  private final long startTimeMicroseconds;
  private final long startTimeNanoTicks;
  private final boolean computeDurationViaNanoTicks;
  private final Map&amp;lt;String, Object&amp;gt; tags;
  private long durationMicroseconds; // span durationMicroseconds
  private String operationName;
  private final List&amp;lt;Reference&amp;gt; references;
  private JaegerSpanContext context;
  private List&amp;lt;LogData&amp;gt; logs;
  private boolean finished = false; // to prevent the same span from getting reported multiple times
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在jaeger的实现中，&lt;code&gt;Span&lt;/code&gt;的信息分为如下几方面：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;span核心信息，如：traceId，spanId，parentId，baggage等&lt;/li&gt;
&lt;li&gt;log信息 与tag的区别是带有时间戳&lt;/li&gt;
&lt;li&gt;tag信息&lt;/li&gt;
&lt;li&gt;span的其他信息，如：startTime,duration&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;u&gt;其中span的核心信息存储在&lt;code&gt;SpanContext&lt;/code&gt;中&lt;/u&gt;。&lt;/p&gt;
&lt;h3 id=&quot;53-spancontext--jaegerspancontext&quot;&gt;5.3 SpanContext &amp;amp; JaegerSpanContext&lt;/h3&gt;
&lt;p&gt;JaegerSpanContext 实现了 io.opentracing.SpanContext&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public interface SpanContext {
    String toTraceId();
    String toSpanId();
    Iterable&amp;lt;Entry&amp;lt;String, String&amp;gt;&amp;gt; baggageItems();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class JaegerSpanContext implements SpanContext {
  protected static final byte flagSampled = 1;
  protected static final byte flagDebug = 2;
  private final long traceIdLow;
  private final long traceIdHigh;
  private final long spanId;
  private final long parentId;
  private final byte flags;
  private final Map&amp;lt;String, String&amp;gt; baggage;
  private final String debugId;
  private final JaegerObjectFactory objectFactory;
  private final String traceIdAsString;
  private final String spanIdAsString;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;span的核心信息存储在&lt;code&gt;SpanContext&lt;/code&gt;中，在构建span时候就会创建，为了防止用户擅自修改核心信息，spanContext中的所有成员都是final修饰的。&lt;/p&gt;
&lt;p&gt;根据opentracing的规范， &lt;code&gt;SpanContext&lt;/code&gt; &lt;em&gt;represents Span state that must propagate to descendant Spans and across process boundaries. SpanContext is logically divided into two pieces:&lt;br/&gt;(1) the user-level &quot;Baggage&quot; that propagates across Span boundaries and&lt;br/&gt;(2) any Tracer-implementation-specific fields that are needed to identify or otherwise contextualize the associated Span instance (e.g., a tuple).&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;上面是说SpanContext代表的是span中必须传递的信息，在逻辑上分为两部分，一分部分是普通的traceId，spanId等信息，另一部分是baggage这种用户自定义需要传递的信息。&lt;/p&gt;
&lt;p&gt;&lt;u&gt;JaegerSpanContext这里只是保存了上下文环境应有的信息，与 SofaTraceContext 不同，SofaTraceContext 里面还存有Span，但是在 Jaeger，这个功能是在 ScopeManager中完成的&lt;/u&gt;。&lt;/p&gt;
&lt;h3 id=&quot;54-reporter&quot;&gt;5.4 Reporter&lt;/h3&gt;
&lt;p&gt;默认的 RemoteReporter 实现了 Reporter，功能就是我们在前文中所说的发送报告。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class RemoteReporter implements Reporter {
  private static final int DEFAULT_CLOSE_ENQUEUE_TIMEOUT_MILLIS = 1000;
  public static final int DEFAULT_FLUSH_INTERVAL_MS = 1000;
  public static final int DEFAULT_MAX_QUEUE_SIZE = 100;

  private final Sender sender;
  private final int closeEnqueueTimeout;

  @ToString.Exclude private final BlockingQueue&amp;lt;Command&amp;gt; commandQueue;
  @ToString.Exclude private final Timer flushTimer;
  @ToString.Exclude private final Thread queueProcessorThread;
  @ToString.Exclude private final QueueProcessor queueProcessor;
  @ToString.Exclude private final Metrics metrics;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;55-scope&quot;&gt;5.5 Scope&lt;/h3&gt;
&lt;p&gt;OpenTracing 抽象了&lt;strong&gt;Scope&lt;/strong&gt;(active span) 和 &lt;strong&gt;ScopeManager&lt;/strong&gt;(设置Scope与获取当前Scope)概念。简单来说，OpenTracing-Java的实现中， 用&lt;strong&gt;Scope&lt;/strong&gt;和&lt;strong&gt;ScopeManager&lt;/strong&gt; 来处理了OpenTracing中的上下文 （即：get_current_span 过程）；&lt;/p&gt;
&lt;p&gt;为什么要抽象出Scope的概念？直接使用ThreadLocal 存储Span不就可以了吗？&lt;/p&gt;
&lt;blockquote readability=&quot;19&quot;&gt;
&lt;p&gt;&lt;strong&gt;答&lt;/strong&gt;： 首先理解Scope是什么？Scope 是Active Span的一个容器， Scope 代表着当前活跃的Span; 是对当前活跃Span的一个抽象， 代表了当前上下文所处于的一个过程；&lt;/p&gt;
&lt;p&gt;另外， &lt;strong&gt;ThreadLocalScope&lt;/strong&gt; 还记录了 &lt;strong&gt;toRestore Span&lt;/strong&gt;, 这样结束时，可以恢复到上一个Span的状态；&lt;/p&gt;
&lt;p&gt;我理解如果只是 get_current_span() 逻辑的话，直接把 span 塞到 ThreadLocal里就可以在线程内传递了；但是ScopeManager看代码是这样实现的，ScopeManager 包含一个 Scope, Scope 又包含了 当前Span, recover Scope；我理解它的好处是： 这样就保证了，如果开启一个子Span（子span 会产生孙子span）， 这样 子span 结束后，还可以回到 父span （这样可以继续产生以 父span 为基础的兄弟span）, 如果只是ThreadLocal 里塞一个当前span的话，是解决不了这种情况的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;或者说&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;在多线程环境下&lt;code&gt;ScopeManager&lt;/code&gt;管理着各个线程的&lt;code&gt;Scope&lt;/code&gt;，而每个线程中的&lt;code&gt;Scope&lt;/code&gt;管理着该线程中的&lt;code&gt;Span&lt;/code&gt;。这样当某个线程需要获取其线程中当前 &lt;em&gt;活动的&lt;/em&gt; span时，可以通过&lt;code&gt;ScopeManager&lt;/code&gt;找到对应该线程的&lt;code&gt;Scope&lt;/code&gt;，并从&lt;code&gt;Scope&lt;/code&gt;中取出该线程 &lt;em&gt;活动的&lt;/em&gt; span。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Scope 对象是 Active Span的容器；通过Scope能拿到当前上下文内的Active Span;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;io.opentracing.util.ThreadLocalScope&lt;/strong&gt; 是Scope的一个实现，通过ThreadLocal 来存储；&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;构造函数就是把目前Span暂存，然后把传入的参数Span设置为当前Span。即 将之前活动的scope作为当前scope的属性&lt;code&gt;toRestore&lt;/code&gt;来存储，并将当前scope设置到scopeManager中作为当前线程最新的scope。&lt;/li&gt;
&lt;li&gt;在操作当span操作完成（span.finish）时，需要调用scope.close方法做恢复，触发关联新的激活span，否则调用链条会出错。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;具体定义如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class ThreadLocalScope implements Scope {
    private final ThreadLocalScopeManager scopeManager;
    private final Span wrapped; // 当前 Active Span
    private final ThreadLocalScope toRestore; // 上一Active Span,wrapped 结束时，会恢复到此Span

    ThreadLocalScope(ThreadLocalScopeManager scopeManager, Span wrapped) {
        this.scopeManager = scopeManager;
        this.wrapped = wrapped;
        // 这两句设置了当前活动Scope
        this.toRestore = scopeManager.tlsScope.get();
        scopeManager.tlsScope.set(this);
    }

    @Override
    public void close() {
        if (scopeManager.tlsScope.get() != this) {
            // This shouldn't happen if users call methods in the expected order. Bail out.
            return;
        }
        scopeManager.tlsScope.set(toRestore);
    }

    Span span() {
        return wrapped;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;56-scopemanager&quot;&gt;5.6 ScopeManager&lt;/h3&gt;
&lt;p&gt;Scope是站在CPU角度激活或者失效Span。ScopeManager管理Scope。一个Scope里可以有多个span，但是只有一个激活的span。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;在多线程环境下&lt;code&gt;ScopeManager&lt;/code&gt;管理着各个线程的&lt;code&gt;Scope&lt;/code&gt;，而每个线程中的&lt;code&gt;Scope&lt;/code&gt;管理着该线程中的&lt;code&gt;Span&lt;/code&gt;。这样当某个线程需要获取其线程中当前&lt;em&gt;活动的&lt;/em&gt; span时，可以通过&lt;code&gt;ScopeManager&lt;/code&gt;找到对应该线程的&lt;code&gt;Scope&lt;/code&gt;，并从&lt;code&gt;Scope&lt;/code&gt;中取出该线程 &lt;em&gt;活动的&lt;/em&gt; span。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;有了ScopeManager， 我们就可以通过 &lt;code&gt;scopeManager.activeSpan()&lt;/code&gt; 方法获取到当前Span， 并且通过&lt;code&gt;scopeManager().activate(span)&lt;/code&gt; 方法设置当前上下文&lt;strong&gt;active span&lt;/strong&gt;;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;io.opentracing.util.ThreadLocalScopeManager&lt;/strong&gt; 是opentracing提供的ScopeManager的实现，Jaeger并没有自己重写一个新类，而是直接使用ThreadLocalScopeManager。&lt;/p&gt;
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;activate 函数的作用是 激活当前 Span。返回Scope（可以理解为 代表当前 Span 活跃的一个阶段）。即调用&lt;code&gt;ThreadLocalScope&lt;/code&gt;的构造方法，将传入的span激活为 &lt;em&gt;当前活动的&lt;/em&gt; span。我们看一下ThreadLocalScope构造函数就能发现，与其说是激活传入的span倒不如说是激活&lt;strong&gt;包裹(wrapped)该span的scope&lt;/strong&gt;为 &lt;em&gt;当前活动的&lt;/em&gt; scope。&lt;/p&gt;
&lt;p&gt;Span 活跃期结束后，需要关闭 Scope, 推荐使用 try-with-resources 关闭。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;activeSpan函数则是返回当前 激活（active）状态Span, 无则返回null。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class ThreadLocalScopeManager implements ScopeManager {
    // 使用原始的ThreadLocal 来存储 Active Span; ScopeManager中仅包含一个 Scope( Active Span)， 即当前上下文中的 active span
    final ThreadLocal&amp;lt;ThreadLocalScope&amp;gt; tlsScope = new ThreadLocal&amp;lt;ThreadLocalScope&amp;gt;();

    // 可以看到，activate 函数就是把span放进一个新生成的 ThreadLocalScope 中，其实就是tlsScope 成员变量中。
    @Override
    public Scope activate(Span span) {
        return new ThreadLocalScope(this, span);
    }

    @Override
    public Span activeSpan() { 
        ThreadLocalScope scope = tlsScope.get();
        return scope == null ? null : scope.span();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Jaeger使用scopeManager来处理管理了上下文，可以从 scopeManager中拿到当前上下文Span；那具体是在哪里设置的父子关系呢？&lt;/p&gt;
&lt;p&gt;在OpenTracing-Java实现中， 是在 &lt;code&gt;tracer.start()&lt;/code&gt; 方法中处理的；&lt;code&gt;start()&lt;/code&gt; 方法中通过 scopeManager 判断是存在active span，若存在则生成CHILD_OF关系的上下文， 如果不存在则createNewContext;&lt;/p&gt;
&lt;p&gt;&lt;u&gt;这点和SOFATtacer不同，SOFATtacer把这个上下文管理功能放在了SofaTraceContext之中，确实在分析代码时候感到有些许混乱。&lt;/u&gt;&lt;/p&gt;
&lt;h3 id=&quot;57-spanid--traceid&quot;&gt;5.7 SpanID &amp;amp; TraceID&lt;/h3&gt;
&lt;p&gt;SpanId 和 TraceID 都是在构建SpanContext 时候生成的。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private JaegerSpanContext createNewContext() {
  String debugId = getDebugId();
  long spanId = Utils.uniqueId();  // span
  long traceIdLow = spanId;  // trace
  long traceIdHigh = isUseTraceId128Bit() ? Utils.uniqueId() : 0;
        ......
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;具体规则如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static long uniqueId() {
  long val = 0;
  while (val == 0) {
    val = Java6CompatibleThreadLocalRandom.current().nextLong();
  }
  return val;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后是调用到了ThreadLocalRandom # current。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static Random current() {
  if (threadLocalRandomPresent) {
    return ThreadLocalRandomAccessor.getCurrentThreadLocalRandom();
  } else {
    return threadLocal.get();
  }
}

static class ThreadLocalRandomAccessor {
    @IgnoreJRERequirement
    private static Random getCurrentThreadLocalRandom() {
      return ThreadLocalRandom.current();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后格式如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;context = {JaegerSpanContext@1701} &quot;c29c9e0f4a0a681c:36217443515fc248:c29c9e0f4a0a681c:1&quot;
 traceIdLow = -4423486945480775652
 traceIdHigh = 0
 spanId = 3900526584756421192
 parentId = -4423486945480775652
 flags = 1
 baggage = {HashMap@1693}  size = 1
 debugId = null
 objectFactory = {JaegerObjectFactory@1673} 
 traceIdAsString = &quot;c29c9e0f4a0a681c&quot;
 spanIdAsString = &quot;36217443515fc248&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;0x06-启动&quot;&gt;0x06 启动&lt;/h2&gt;
&lt;h3 id=&quot;61-手动埋点&quot;&gt;6.1 手动埋点&lt;/h3&gt;
&lt;p&gt;要通过Jaeger将Java应用数据上报至链路追踪控制台，首先需要完成埋点工作。&lt;u&gt;本示例为手动埋点&lt;/u&gt;。&lt;/p&gt;
&lt;h3 id=&quot;62-pom配置&quot;&gt;6.2 pom配置&lt;/h3&gt;
&lt;p&gt;pom.xml中添加了对Jaeger客户端的依赖。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;io.jaegertracing&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;jaeger-client&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;${jaeger.version}&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;63-启动&quot;&gt;6.3 启动&lt;/h3&gt;
&lt;p&gt;示例代码并没有使用注入的组件，而是手动启动，具体启动/初始化代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public final class Tracing {
    private Tracing() { }
    
    public static JaegerTracer init(String service) {
        SamplerConfiguration samplerConfig = SamplerConfiguration.fromEnv()
                .withType(ConstSampler.TYPE)
                .withParam(1);

        ReporterConfiguration reporterConfig = ReporterConfiguration.fromEnv()
                .withLogSpans(true);

        // 这里启动
        Configuration config = new Configuration(service)
                .withSampler(samplerConfig)
                .withReporter(reporterConfig);

        return config.getTracer();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;示例中启动的 io.dropwizard.Application 都会调用init进行初始化。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;try (JaegerTracer tracer = Tracing.init(&quot;publisher&quot;)) {
    new Publisher(tracer).run(&quot;server&quot;);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;具体启动逻辑都是在 io.jaegertracing.Configuration 中完成的。我们可以看到&lt;u&gt;其中实现了众多配置和一个tracer&lt;/u&gt;。&lt;/p&gt;
&lt;h3 id=&quot;64-构建tracer&quot;&gt;6.4 构建Tracer&lt;/h3&gt;
&lt;p&gt;上节代码中有 &lt;code&gt;config.getTracer();&lt;/code&gt; ，这就是 jaeger采用builder模式来构建&lt;code&gt;Tracer&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Configuration {
    private String serviceName;
    private Configuration.SamplerConfiguration samplerConfig;
    private Configuration.ReporterConfiguration reporterConfig;
    private Configuration.CodecConfiguration codecConfig;
    private MetricsFactory metricsFactory;
    private Map&amp;lt;String, String&amp;gt; tracerTags;
    private boolean useTraceId128Bit;
    private JaegerTracer tracer;
  
    public synchronized JaegerTracer getTracer() {
      if (tracer != null) {
        return tracer;
      }

      tracer = getTracerBuilder().build(); // 构建
      return tracer;
    }
  
    ......
}  
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;build()&lt;/code&gt;方法最终完成了&lt;code&gt;Tracer&lt;/code&gt;对象的构造。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;默认使用&lt;code&gt;RemoteReporter&lt;/code&gt;来report &lt;code&gt;Span&lt;/code&gt;到agent，&lt;/li&gt;
&lt;li&gt;采样默认使用&lt;code&gt;RemoteControlledSampler&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;共同使用的&lt;code&gt;metrics&lt;/code&gt;是在Builder内部类中的有默认值的成员变量&lt;code&gt;metrics&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public JaegerTracer build() {
  if (reporter == null) {
    reporter = new RemoteReporter.Builder()
        .withMetrics(metrics)
        .build();
  }
  if (sampler == null) {
    sampler = new RemoteControlledSampler.Builder(serviceName)
        .withMetrics(metrics)
        .build();
  }
  return createTracer();
}

protected JaegerTracer createTracer() {
      return new JaegerTracer(this);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Tracer对象可以用来创建Span对象以便记录分布式操作时间、通过Extract/Inject方法跨机器透传数据、或设置当前Span。Tracer对象还配置了上报数据的网关地址、本机IP地址、采样率、服务名等数据。用户可以通过调整采样率来减少因上报数据产生的开销。&lt;/p&gt;
&lt;p&gt;在启动之后，用户得到 Tracer 来进行后续手动埋点。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;JaegerTracer tracer = Tracing.init(&quot;hello-world&quot;)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;0x07-客户端发送&quot;&gt;0x07 客户端发送&lt;/h2&gt;
&lt;p&gt;下面都是手动埋点。&lt;/p&gt;
&lt;h3 id=&quot;71-构建span&quot;&gt;7.1 构建Span&lt;/h3&gt;
&lt;p&gt;构造&lt;code&gt;Span&lt;/code&gt;对象是一件很简单的事情，通过opentracing对&lt;code&gt;Tracer&lt;/code&gt;接口的规定可知&lt;code&gt;Span&lt;/code&gt;是由&lt;code&gt;Tracer&lt;/code&gt;负责构造的，如下我们“启动”了一个&lt;code&gt;Span&lt;/code&gt;（实际上只是构造了该对象而已）：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Span span = tracer.buildSpan(&quot;printHello&quot;).start();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Tracer中的start方法(&lt;strong&gt;开启一个Span&lt;/strong&gt;) 使用了scopeManager 来获取上下文，从而来处理父子关系；&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public JaegerSpan start() {
      // 此处从ScopeManager获取上下文（线程）中，获取到激活的Span, 而后创建父子关系
      if (this.references.isEmpty() &amp;amp;&amp;amp; !this.ignoreActiveSpan &amp;amp;&amp;amp; null != JaegerTracer.this.scopeManager.activeSpan()) {
                this.asChildOf(JaegerTracer.this.scopeManager.activeSpan());
      }

      JaegerSpanContext context;
      if (!this.references.isEmpty() &amp;amp;&amp;amp; ((Reference)this.references.get(0)).getSpanContext().hasTrace()) {
                context = this.createChildContext();
      } else {
                context = this.createNewContext();
      }
      ...
      return jaegerSpan;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;72-parent-span&quot;&gt;7.2 Parent Span&lt;/h3&gt;
&lt;p&gt;本示例中会涉及到两个Span：Parent Span 和 Child Span。我们首先介绍 Parent Span。&lt;/p&gt;
&lt;p&gt;其大致策略是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;调用 tracer.buildSpan(&quot;say-hello&quot;).start() 生成Span
&lt;ul&gt;&lt;li&gt;asChildOf(scopeManager.activeSpan()); 这里构建了Span之间的关系，即本 span在初始化时就先构建了与之前span的关系。&lt;/li&gt;
&lt;li&gt;createNewContext() 或者 createChildContext()。如果是root span就随机生成id作为traceId与spanId，如果不是root span则使用&lt;code&gt;reference&lt;/code&gt;属性中找到该span的parent span（根据是否为child_of的关系来判断）获取其traceId作为自己的traceId，获取其spanId作为自己的parentId。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;调用 tracer.scopeManager().activate 函数就是把span放进一个新生成的 ThreadLocalScope 中，其实就是 tlsScope 成员变量中。 结果是后续可以通过tracer.scopeManager.activeSpan();获取span信息。&lt;/li&gt;
&lt;li&gt;setTag&lt;/li&gt;
&lt;li&gt;setBaggageItem&lt;/li&gt;
&lt;li&gt;最后finish&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;具体代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private void sayHello(String helloTo, String greeting) {
        Span span = tracer.buildSpan(&quot;say-hello&quot;).start();
        try (Scope scope = tracer.scopeManager().activate(span)) {
            span.setTag(&quot;hello-to&quot;, helloTo);
            span.setBaggageItem(&quot;greeting&quot;, greeting);
            String helloStr = formatString(helloTo);
            printHello(helloStr);
        } finally {
            span.finish();
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;得到的运行时Span如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;span = {JaegerSpan@1685} 
 startTimeMicroseconds = 1598707136698000
 startTimeNanoTicks = 1018098763618500
 computeDurationViaNanoTicks = true
 tags = {HashMap@1700}  size = 2
 durationMicroseconds = 0
 operationName = &quot;say-hello&quot;
 references = {ArrayList@1701}  size = 0
 context = {JaegerSpanContext@1666} &quot;c8b87cc5fb01ef31:c8b87cc5fb01ef31:0:1&quot;
  traceIdLow = -3983296680647594191
  traceIdHigh = 0
  spanId = -3983296680647594191
  parentId = 0
  flags = 1
  baggage = {Collections$EmptyMap@1704}  size = 0
  debugId = null
  objectFactory = {JaegerObjectFactory@994} 
  traceIdAsString = &quot;c8b87cc5fb01ef31&quot;
  spanIdAsString = &quot;c8b87cc5fb01ef31&quot;
 logs = null
 finished = false
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;73-child-span&quot;&gt;7.3 Child Span&lt;/h3&gt;
&lt;p&gt;示例代码然后在 formatString 中会：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;生成一个子 Span&lt;/li&gt;
&lt;li&gt;加入了Tag&lt;/li&gt;
&lt;li&gt;调用Inject方法传入Context信息。&lt;/li&gt;
&lt;li&gt;并且会调用http请求。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;具体代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private String getHttp(int port, String path, String param, String value) {
                HttpUrl url = new HttpUrl.Builder().scheme(&quot;http&quot;).host(&quot;localhost&quot;).port(port).addPathSegment(path)
                    .addQueryParameter(param, value).build();
                Request.Builder requestBuilder = new Request.Builder().url(url);
  
        Span activeSpan = tracer.activeSpan();

    Tags.SPAN_KIND.set(activeSpan, Tags.SPAN_KIND_CLIENT);
    Tags.HTTP_METHOD.set(activeSpan, &quot;GET&quot;);
    Tags.HTTP_URL.set(activeSpan, url.toString());

    tracer.inject(activeSpan.context(), Format.Builtin.HTTP_HEADERS, 
                  Tracing.requestBuilderCarrier(requestBuilder));

    Request request = requestBuilder.build();
    Response response = client.newCall(request).execute();
}  
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;74-inject&quot;&gt;7.4 Inject&lt;/h3&gt;
&lt;p&gt;上文中的 tracer.inject 函数，是用来把 SpanContext 的信息序列化到 Request.Builder 之中。这样后续操作就可以把序列化之后的信息转换到 Header之中。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;tracer.inject(activeSpan.context(), Format.Builtin.HTTP_HEADERS, 
              Tracing.requestBuilderCarrier(requestBuilder));
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;具体序列化代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public void inject(JaegerSpanContext spanContext, TextMap carrier) {
  carrier.put(contextKey, encodedValue(contextAsString(spanContext)));
  for (Map.Entry&amp;lt;String, String&amp;gt; entry : spanContext.baggageItems()) {
    carrier.put(keys.prefixedKey(entry.getKey(), baggagePrefix), encodedValue(entry.getValue()));
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;75-finish&quot;&gt;7.5 Finish&lt;/h3&gt;
&lt;p&gt;&lt;u&gt;当服务端返回之后，在Client端，jaeger会进行后续操作：finish，report&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;调用&lt;code&gt;span.finish()&lt;/code&gt;方法标志着span的结束。finish方法应该是对应span实例的最后一个调用的方法。在span中finish方法还只是校验和记录的作用，真正发送span的就是开头提到的tracer，tracer包含了sampler、report等全局的功能，因此在finish中调用了&lt;code&gt;tracer.report(span)&lt;/code&gt;方法。而tracer中的report方法是使用其成员&lt;code&gt;report&lt;/code&gt;的report方法，上面讲过默认实现是&lt;code&gt;RemoteReporter&lt;/code&gt;，它默认使用的是&lt;code&gt;UdpSender&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;span.finish会触发span上报。调用了 JaegerSpan.finishWithDuration。其中会判断本次Trace是否采样。如果是采样了，就会上报。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;  @Override
  public void finish(long finishMicros) {
    finishWithDuration(finishMicros - startTimeMicroseconds);
  }

  private void finishWithDuration(long durationMicros) {
    synchronized (this) {
      if (finished) {
        log.warn(&quot;Span has already been finished; will not be reported again.&quot;);
        return;
      }
      finished = true;

      this.durationMicroseconds = durationMicros;
    }

    if (context.isSampled()) {
      tracer.reportSpan(this);
    }
  }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;76-reporter&quot;&gt;7.6 Reporter&lt;/h3&gt;
&lt;p&gt;上报是在 RemoteReporter 中。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;RemoteReporter&lt;/code&gt;中有一个&lt;code&gt;BlockingQueue&lt;/code&gt;队列其作用是接收Command接口的实现类，其长度可在构造方法中传入。在&lt;code&gt;RemoteReporter&lt;/code&gt;的构造函数中开启了两个守护线程。一个线程定时往&lt;code&gt;BlockingQueue&lt;/code&gt;队列中添加flush命令，另外一个线程不停的从&lt;code&gt;BlockingQueue&lt;/code&gt;队列中take数据，然后执行Command.excute()方法。而report(span)方法就是往&lt;code&gt;BlockingQueue&lt;/code&gt;队列中添加&lt;code&gt;AppendCommand&lt;/code&gt;类。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;  @Override
  public void report(JaegerSpan span) {
    // Its better to drop spans, than to block here
    boolean added = commandQueue.offer(new AppendCommand(span));

    if (!added) {
      metrics.reporterDropped.inc(1);
    }
  }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到如果返回的added变量为false，也就是队列满了无法再加入数据，就会抛弃该span的，最终该span的信息不会发送到agent中。因此队列的长度也是有一定的影响。&lt;/p&gt;
&lt;p&gt;而&lt;code&gt;AppendCommand&lt;/code&gt;类的excute()方法为：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;class AppendCommand implements Command {
    private final Span span;

    public AppendCommand(Span span) {
      this.span = span;
    }

    @Override
    public void execute() throws SenderException {
      sender.append(span);
    }
  }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以，我们看到，execute()方法并不是真正的发送span了，而只是把span添加到sender中去，由sender实现span的发送，reporter类只负责发送刷新与发送的命令。&lt;/p&gt;
&lt;p&gt;如果我们继续深入下去，会发现&lt;code&gt;UdpSender&lt;/code&gt;是抽象类&lt;code&gt;ThriftSender&lt;/code&gt;的实现类，&lt;code&gt;sender.append(span)&lt;/code&gt;方法调用的是&lt;code&gt;ThriftSender&lt;/code&gt;的&lt;code&gt;append(Span)&lt;/code&gt;方法，而该方法又会调用&lt;code&gt;ThriftSender&lt;/code&gt;的&lt;code&gt;flush()&lt;/code&gt;方法，最后这个&lt;code&gt;flush()&lt;/code&gt;方法会调用抽象类&lt;code&gt;ThriftSender&lt;/code&gt;的抽象方法&lt;code&gt;send(Process process, List spans)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;Jaeger中其他Reporter如下 ：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;CompositeReporter&lt;/code&gt;顾名思义就是将各个reporter组合起来，内部有一个list，它所实现的接口的 &lt;code&gt;report(Span span)&lt;/code&gt;方法也只是把list中的所有reporter依次调用&lt;code&gt;report(Span span)&lt;/code&gt;方法而已。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;InMemoryReporter&lt;/code&gt;类是将&lt;code&gt;Span&lt;/code&gt;存到内存中，该类含有一个list用于存储span，该类中的report方法即为将span通过add方法添加到list中，通过&lt;code&gt;getSpans()&lt;/code&gt;方法获取到list，同时有&lt;code&gt;clear()&lt;/code&gt;方法清除list数据。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LoggingReporter&lt;/code&gt;类作用是将span作为日志内容打印出来，其report方法即为&lt;code&gt;log.info()&lt;/code&gt;打印span的内容。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NoopReporter&lt;/code&gt;是一个实现了&lt;code&gt;Reporter&lt;/code&gt;接口但是实现方法为空的一个类，表示使用该类report span将毫无影响。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;0x08-服务端接受&quot;&gt;0x08 服务端接受&lt;/h2&gt;
&lt;h3 id=&quot;81-手动埋点&quot;&gt;8.1 手动埋点&lt;/h3&gt;
&lt;p&gt;服务端也是手动埋点。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class FormatterResource {
    @GET
    public String format(@QueryParam(&quot;helloTo&quot;) String helloTo, @Context HttpHeaders httpHeaders) {
        Span span = Tracing.startServerSpan(tracer, httpHeaders, &quot;format&quot;);
        try (Scope scope = tracer.scopeManager().activate(span)) {
            String greeting = span.getBaggageItem(&quot;greeting&quot;);
            if (greeting == null) {
                greeting = &quot;Hello&quot;;
            }
            String helloStr = String.format(&quot;%s, %s!&quot;, greeting, helloTo);
            span.log(ImmutableMap.of(&quot;event&quot;, &quot;string-format&quot;, &quot;value&quot;, helloStr));
            return helloStr;
        } finally {
            span.finish();
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;82-业务逻辑&quot;&gt;8.2 业务逻辑&lt;/h3&gt;
&lt;p&gt;业务逻辑在 startServerSpan 之中：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;调用Extract方法解析Context信息。&lt;/li&gt;
&lt;li&gt;根据是否有Parent Context 来进行Span构建，其中会用到SpanContext。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;具体代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static Span startServerSpan(Tracer tracer, javax.ws.rs.core.HttpHeaders httpHeaders, String operationName) {
        // format the headers for extraction
        MultivaluedMap&amp;lt;String, String&amp;gt; rawHeaders = httpHeaders.getRequestHeaders();
        final HashMap&amp;lt;String, String&amp;gt; headers = new HashMap&amp;lt;String, String&amp;gt;();
        for (String key : rawHeaders.keySet()) {
            headers.put(key, rawHeaders.get(key).get(0));
        }

        Tracer.SpanBuilder spanBuilder;
        try {
            SpanContext parentSpanCtx = tracer.extract(Format.Builtin.HTTP_HEADERS, new TextMapAdapter(headers));
            if (parentSpanCtx == null) {
                spanBuilder = tracer.buildSpan(operationName);
            } else {
                spanBuilder = tracer.buildSpan(operationName).asChildOf(parentSpanCtx);
            }
        } catch (IllegalArgumentException e) {
            spanBuilder = tracer.buildSpan(operationName);
        }
        // TODO could add more tags like http.url
        return spanBuilder.withTag(Tags.SPAN_KIND.getKey(), Tags.SPAN_KIND_SERVER).start();
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;83-解析context&quot;&gt;8.3 解析Context&lt;/h3&gt;
&lt;p&gt;解析代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public JaegerSpanContext extract(TextMap carrier) {
  JaegerSpanContext context = null;
  Map&amp;lt;String, String&amp;gt; baggage = null;
  String debugId = null;
  for (Map.Entry&amp;lt;String, String&amp;gt; entry : carrier) {
    // TODO there should be no lower-case here
    String key = entry.getKey().toLowerCase(Locale.ROOT);
    if (key.equals(contextKey)) {
      context = contextFromString(decodedValue(entry.getValue()));
    } else if (key.equals(Constants.DEBUG_ID_HEADER_KEY)) {
      debugId = decodedValue(entry.getValue());
    } else if (key.startsWith(baggagePrefix)) {
      if (baggage == null) {
        baggage = new HashMap&amp;lt;String, String&amp;gt;();
      }
      baggage.put(keys.unprefixedKey(key, baggagePrefix), decodedValue(entry.getValue()));
    } else if (key.equals(Constants.BAGGAGE_HEADER_KEY)) {
      baggage = parseBaggageHeader(decodedValue(entry.getValue()), baggage);
    }
  }
  if (debugId == null &amp;amp;&amp;amp; baggage == null) {
    return context;
  }
  return objectFactory.createSpanContext(
    context == null ? 0L : context.getTraceIdHigh(),
    context == null ? 0L : context.getTraceIdLow(),
    context == null ? 0L : context.getSpanId(),
    context == null ? 0L : context.getParentId(),
    context == null ? (byte)0 : context.getFlags(),
    baggage,
    debugId);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;0x09-问题解答&quot;&gt;0x09 问题解答&lt;/h2&gt;
&lt;ul readability=&quot;7&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Jaeger 和 SOFATracer 对比如何？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Jaeger对OpenTracing支持的更完备，版本更高。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;spanId是怎么生成的，有什么规则?&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;traceId是怎么生成的，有什么规则？&lt;/p&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;最终都是调用到 ThreadLocalRandom # current # nextLong 完成，举例如下：&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt; traceIdLow = -4423486945480775652
 traceIdHigh = 0
 spanId = 3900526584756421192
 parentId = -4423486945480775652
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;客户端哪里生成的Span？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;本示例代码是手动调用 tracer.buildSpan(&quot;say-hello&quot;).start() 生成Span。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;ParentSpan 从哪儿来？&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;ChildSpan由ParentSpan创建，那么什么时候创建？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在OpenTracing-Java实现中， 是在 &lt;code&gt;tracer.start()&lt;/code&gt; 方法中处理的；&lt;code&gt;start()&lt;/code&gt; 方法中通过 scopeManager 判断是存在active span ，若存在则生成CHILD_OF关系的上下文， 如果不存在则createNewContext;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Trace信息怎么传递？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;把 SpanContext 的信息序列化到 Request.Builder 之中。后续操作把序列化之后的信息转换到 Header之中，然后就可以传递。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;服务器接收到请求之后做什么？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;调用Extract方法解析Context信息。&lt;/li&gt;
&lt;li&gt;根据是否有Parent Context 来进行Span构建，其中会用到SpanContext。&lt;/li&gt;
&lt;li&gt;进行具体其他业务。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;SpanContext在服务器端怎么处理？见上问题回答。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;链路信息如何搜集？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;采样是对于整条链路来说的，也就是说从 RootSpan 被创建开始，就已经决定了当前链路数据是否会被记录了。&lt;/li&gt;
&lt;li&gt;如果已经确定本次Trace被采样，就会发送报告。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;0xff-参考&quot;&gt;0xFF 参考&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/83654617&quot;&gt;分布式追踪系统 -- Opentracing&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/yunqiinsight/article/details/80134045&quot;&gt;开放分布式追踪（OpenTracing）入门与 Jaeger 实现&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/7a08e7c1835c&quot;&gt;OpenTracing 语义说明&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/71024024&quot;&gt;分布式追踪系统概述及主流开源系统对比&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/41252484&quot;&gt;Skywalking分布式追踪与监控：起始篇&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/82cd923191fb&quot;&gt;分布式全链路监控 -- opentracing小试&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/170290448&quot;&gt;opentracing实战&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/79419529&quot;&gt;Go微服务全链路跟踪详解&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://niyanchun.com/opentracing-java-library-tutorial-3.html&quot;&gt;OpenTracing Java Library教程(3)——跨服务传递SpanContext&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://niyanchun.com/opentracing-java-library-tutorial-1.html&quot;&gt;OpenTracing Java Library教程(1)——trace和span入门&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.sofastack.tech/blog/sofa-tracer-overview/&quot;&gt;蚂蚁金服分布式链路跟踪组件 SOFATracer 总览|剖析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.sofastack.tech/blog/sofa-tracer-unvarnished-transmission-slf4j-mdc/&quot;&gt;蚂蚁金服开源分布式链路跟踪组件 SOFATracer 链路透传原理与SLF4J MDC 的扩展能力剖析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.sofastack.tech/blog/sofa-tracer-sampling-tracking-deep-dive/&quot;&gt;蚂蚁金服开源分布式链路跟踪组件 SOFATracer 采样策略和源码剖析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/sofastack-guides/sofa-tracer-guides&quot;&gt;https://github.com/sofastack-guides/sofa-tracer-guides&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://opentracing.io/specification/&quot;&gt;The OpenTracing Semantic Specification&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://niyanchun.com/opentracing-java-library-tutorial-2.html&quot;&gt;OpenTracing Java Library教程(2)——进程间传递SpanContext&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://niyanchun.com/opentracing-java-library-tutorial-4.html&quot;&gt;OpenTracing Java Library教程(4)——Baggage介绍&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/yurishkuro/opentracing-tutorial&quot;&gt;https://github.com/yurishkuro/opentracing-tutorial&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/95d9f9f3fdc5&quot;&gt;微服务系统架构之分布式traceId追踪参考实现&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/47bc00a07eb4&quot;&gt;监控之traceid&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/2f5d5638b8b0&quot;&gt;jaeger代码阅读思路整理&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/tong-yuan/p/12128796.html&quot;&gt;分布式系统中如何优雅地追踪日志（原理篇）traceid&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000007219902&quot;&gt;sky-walking的traceId生成&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/4f12f5bfe2dc&quot;&gt;分布式链路追踪系列番外篇一（jaeger异步批量发送span）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/e26c5a9b5261&quot;&gt;分布式链路追踪系列番外篇二（Spark Job优化记）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/85068093f9ac&quot;&gt;Jaeger服务端埋点分析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.alibabacloud.com/help/zh/doc-detail/90501.html&quot;&gt;通过Jaeger上报Java应用数据&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/102298986&quot;&gt;OpenTracing(Jaeger) 遭遇多线程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/shuai_wy/article/details/107744631&quot;&gt;OpenTracing-Java Scope与ScopeManager&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/shuai_wy/article/details/107743925&quot;&gt;OpenTracing-Java实现的灵魂十问&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/shuai_wy/article/details/107447779&quot;&gt;OpenTracing实现思路（附OpenTracing-Jaeger-Java实例）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/hanjiangxue1006/article/details/105626862&quot;&gt;OpenTracing API 自动埋点调研&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/85068093f9ac&quot;&gt;Jaeger服务端埋点分析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/102298986&quot;&gt;OpenTracing(Jaeger) 遭遇多线程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/edi-kai/p/9779932.html&quot;&gt;jaegeropentracing的Java-client完整分布式追踪链&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/fbedfcdea606&quot;&gt;基于opentracing + jaeger 实现全链路追踪&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/2f5d5638b8b0&quot;&gt;jaeger代码阅读思路整理&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Fri, 11 Sep 2020 12:42:00 +0000</pubDate>
<dc:creator>罗西的思考</dc:creator>
<og:description>笔者之前有过zipkin的经验，希望扩展到Opentracing，于是在学习Jaeger基础上总结出此文，与大家分享。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/rossiXYZ/p/13654065.html</dc:identifier>
</item>
</channel>
</rss>