<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Python数据可视化之Matplotlib实现各种图表 - summer哥</title>
<link>http://www.cnblogs.com/airnew/p/10262686.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/airnew/p/10262686.html</guid>
<description>&lt;p&gt;数据分析就是将数据以各种图表的形式展现给领导，供领导做决策用，因此熟练掌握饼图、柱状图、线图等图表制作是一个数据分析师必备的技能。Python有两个比较出色的图表制作框架，分别是Matplotlib和Pyechart。本文主要讲述使用Matplotlib制作各种数据图表。&lt;/p&gt;
&lt;p&gt;Matplotlib是最流行的用于绘制2D数据图表的Python库，能够在各种平台上使用，可以绘制散点图、柱状图、饼图等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、柱状图&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;是一种以长方形或长方体的高度为变量的表达图形的统计报告图，由一系列高度不等的纵向条纹表示数据分布的情况，用来比较两个或以上的价值（不同时间或者不同条件），只有一个变量，通常利用于较小的数据集分析。柱状图可以用来比较数据之间的多少，可以用来观察某一事件的变化趋势，柱状图亦可横向排列，或用多维方式表达。&lt;br/&gt;实现代码：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 导入绘图模块
import matplotlib.pyplot as plt
# 构建数据
sales = [7125,12753,13143,8635]

# 中文乱码的处理，rcParams也可以用于设置图的分辨率，大小等信息
plt.rcParams['font.sans-serif'] =['SimHei']
plt.rcParams['axes.unicode_minus'] = False

# 绘图,第一个参数是x轴的数据，第二个参数是y轴的数据，第三个参数是柱子的大小，默认值是1（值在0到1之间），color是柱子的颜色，alpha是柱子的透明度
plt.bar(range(4), sales, 0.4,color='r', alpha = 0.8)
# 添加轴标签
plt.ylabel('销量')
# 添加标题
plt.title('水果2018年度销量')
# 添加刻度标签
plt.xticks(range(4),['苹果','香蕉','梨','猕猴桃'])
# 设置Y轴的刻度范围
plt.ylim([5000,15000])

# 为每个条形图添加数值标签
for x,y in enumerate(sales):
    plt.text(x,y+100,'%s' %y,ha='center')

# 显示图形
plt.show()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果图：&lt;br/&gt;&lt;img src=&quot;http://www.bigdata17.com/assets/images/matplotlib_bar1.png&quot; title=&quot;Matplotlib&quot; alt=&quot;Matplotlib&quot;/&gt;&lt;/p&gt;
&lt;p&gt;只需绘制柱状图的函数bar()改成barh()就可以将柱状图长方形或长方体从垂直方向变为水平方向。&lt;br/&gt;实现代码：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 导入绘图模块
import matplotlib.pyplot as plt
# 构建数据
sales = [7125,12753,13143,8635]

# 中文乱码的处理
plt.rcParams['font.sans-serif'] =['SimHei']
plt.rcParams['axes.unicode_minus'] = False

x = ['苹果','香蕉','梨','猕猴桃']
# 绘图
plt.barh(range(4), sales, 0.4,color='r', alpha = 0.8)
# 添加轴标签
plt.ylabel('销量')
# 添加标题
plt.title('水果2018年度销量')
# 添加刻度标签
plt.yticks(range(4),['苹果','香蕉','梨','猕猴桃'])
# 设置Y轴的刻度范围
plt.xlim([5000,15000])

# 为每个条形图添加数值标签
for x,y in enumerate(sales):
    plt.text(y+0.2,x,'%s' %y,va='center')

# 显示图形
plt.show()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果图：&lt;br/&gt;&lt;img src=&quot;http://www.bigdata17.com/assets/images/matplotlib_bar2.png&quot; title=&quot;Matplotlib&quot; alt=&quot;Matplotlib&quot;/&gt;&lt;br/&gt;除了bar()函数变成barh()之外。还有其他几个地方要做修改，在给每个条形图添加数值标签时，将ha='center'改为va='center'，将添加x轴标签的方法从xlabel改为ylabel。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;柱状图和折线图混合使用&lt;/strong&gt;&lt;br/&gt;柱状图可以和折线图混合使用，用来表示某一个数据的变化趋势，下面是例子的柱状图表示水果的年度销量，折线图表示水果1月份的销量。&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 导入绘图模块
import matplotlib.pyplot as plt

jan_sales = [3010,4029,5021,3056]
# 构建数据
sales = [7125,12753,13143,8635]


# 中文乱码的处理
plt.rcParams['font.sans-serif'] =['SimHei']
plt.rcParams['axes.unicode_minus'] = False

x = ['苹果','香蕉','梨','猕猴桃']

plt.plot(x,jan_sales,'r')# 折线 1 x 2 y 3 color
plt.plot(x,jan_sales,'g',lw=5)# 4 line w

# 绘图
plt.bar(range(4), sales, 0.4,color='b', alpha = 0.8)
# 添加轴标签
plt.ylabel('销量')
# 添加标题
plt.title('水果2018年度销量')
# 添加刻度标签
plt.xticks(range(4),['苹果','香蕉','梨','猕猴桃'])
# 设置Y轴的刻度范围
plt.ylim([2000,15000])

# 为每个条形图添加数值标签
for x,y in enumerate(sales):
    plt.text(x,y+100,'%s' %y,ha='center')

# 显示图形
plt.show()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果图：&lt;br/&gt;&lt;img src=&quot;http://www.bigdata17.com/assets/images/matplotlib_bar_line.png&quot; title=&quot;Matplotlib&quot; alt=&quot;Matplotlib&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、折线图&lt;/strong&gt;&lt;br/&gt;折线图主要用于表示数据变化的趋势。折线图是直线将不同的点连接起来。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 导入绘图模块
import matplotlib.pyplot as plt

#构建数据
jan_sales = [3010,4029,5021,3056]


# 中文乱码的处理
plt.rcParams['font.sans-serif'] =['SimHei']
plt.rcParams['axes.unicode_minus'] = False

x = ['苹果','香蕉','梨','猕猴桃']

#第一个参数是x轴，第二参数时y轴数据，第三个参数是线的颜色，第二个参数是线条的粗细
plt.plot(x,jan_sales,'r',lw=5)# 4 line w

# 添加标题
plt.title('水果2018年度1月份销量图')
plt.ylim([2000,15000])

# 为每个点添加数值标签
for x,y in enumerate(jan_sales):
    plt.text(x,y+100,'%s' %y,ha='center')

# 显示图形
plt.show()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果图：&lt;br/&gt;&lt;img src=&quot;http://www.bigdata17.com/assets/images/matplotlib_line.png&quot; title=&quot;Matplotlib&quot; alt=&quot;Matplotlib&quot;/&gt;&lt;/p&gt;
&lt;p&gt;折线图通过调用plot()方法绘制。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、饼图&lt;/strong&gt;&lt;br/&gt;饼图主要是用来表示数据的占比，给人一眼就可以看出数据的占比大小。饼图使用pie()函数绘制。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import matplotlib.pyplot as plt

# 设置绘图的主题风格（不妨使用R中的ggplot分隔）
plt.style.use('ggplot')

# 构造数据
edu = [0.2515,0.3724,0.3336,0.0368,0.0057]
labels = ['苹果','香蕉','梨','猕猴桃','桔子']

explode = [0,0.1,0,0,0] # 用于突出显示大专学历人群
colors=['#FEB748','#EDD25D','#FE4F54','#51B4FF','#dd5555'] # 自定义颜色

# 中文乱码和坐标轴负号的处理
plt.rcParams['font.sans-serif'] = ['SimHei']
plt.rcParams['axes.unicode_minus'] = False

# 将横、纵坐标轴标准化处理，保证饼图是一个正圆，否则为椭圆
plt.axes(aspect='equal')

# 控制x轴和y轴的范围
plt.xlim(0,4)
plt.ylim(0,4)

# 绘制饼图
plt.pie(x = edu,# 绘图数据
    explode=explode, # 突出显示香蕉人群
    labels=labels, # 添加水果销量水平标签
    colors=colors, # 设置饼图的自定义填充色
    autopct='%.1f%%', # 设置百分比的格式，这里保留一位小数
    pctdistance=0.8,# 设置百分比标签与圆心的距离
    labeldistance = 1.15, # 设置销量水平标签与圆心的距离
    startangle = 180, # 设置饼图的初始角度
    radius = 1.5, # 设置饼图的半径
    counterclock = False, # 是否逆时针，这里设置为顺时针方向
    wedgeprops = {'linewidth': 1.5, 'edgecolor':'green'},# 设置饼图内外边界的属性值
    textprops = {'fontsize':12, 'color':'k'}, # 设置文本标签的属性值
    center = (1.8,1.8), # 设置饼图的原点
    frame = 1)# 是否显示饼图的图框，这里设置显示

# 删除x轴和y轴的刻度
plt.xticks(())
plt.yticks(())
# 添加图标题
plt.title('2018年水果销量分析')

# 显示图形
plt.show()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果图：&lt;br/&gt;&lt;img src=&quot;http://www.bigdata17.com/assets/images/matplotlib_pie.png&quot; title=&quot;Matplotlib&quot; alt=&quot;Matplotlib&quot;/&gt;&lt;/p&gt;
&lt;p&gt;简单介绍下pie函数参数：&lt;br/&gt;x: 指定绘图的数据&lt;br/&gt;explode:指定饼图某些部分的突出显示，即呈现爆炸式&lt;br/&gt;labels：为饼图添加标签说明，类似于图例说明&lt;br/&gt;colors：指定饼图的填充色&lt;br/&gt;autopct：设置百分比格式，如'%.1f%%'为保留一位小数&lt;br/&gt;shadow：是否添加饼图的阴影效果&lt;br/&gt;pctdistance:设置百分比标签与圆心的距离&lt;br/&gt;labeldistance：设置各扇形标签（图例）与圆心的距离；&lt;br/&gt;startangle：设置饼图的初始摆放角度, 180为水平；&lt;br/&gt;radius：设置饼图的半径大小；&lt;br/&gt;counterclock：是否让饼图按逆时针顺序呈现, True / False；&lt;br/&gt;wedgeprops：设置饼图内外边界的属性，如边界线的粗细、颜色等, 如wedgeprops = {'linewidth': 1.5, 'edgecolor':'green'}&lt;br/&gt;textprops：设置饼图中文本的属性，如字体大小、颜色等；&lt;br/&gt;center：指定饼图的中心点位置，默认为原点&lt;br/&gt;frame：是否要显示饼图背后的图框，如果设置为True的话，需要同时控制图框x轴、y轴的范围和饼图的中心位置；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4、散点图&lt;/strong&gt;&lt;br/&gt;散点图主要的作用是判断两个变量之间关系的强弱或者是否存在关系。&lt;/p&gt;
&lt;p&gt;散点图由scatter()方法绘制。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import numpy as np
import matplotlib.pyplot as plt

# 数据个数
n = 50
# 均值为0, 方差为1的随机数
x = np.random.normal(0, 1, n)
y = np.random.normal(0, 1, n)

# 计算颜色值
color = np.arctan2(y, x)
# 绘制散点图
plt.scatter(x, y, s = 75, c = color, alpha = 0.5)
# 设置坐标轴范围
plt.xlim((-1.5, 1.5))
plt.ylim((-1.5, 1.5))

# 不显示坐标轴的值
plt.xticks(([-1,0,1,2,3,4]))
plt.yticks(([-1,0,1,2,3,4]))

plt.show()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果图：&lt;br/&gt;&lt;img src=&quot;http://www.bigdata17.com/assets/images/matplotlib_scatter.png&quot; title=&quot;Matplotlib&quot; alt=&quot;Matplotlib&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5、箱线图&lt;/strong&gt;&lt;br/&gt;箱线图一般用来展现数据大小、占比、趋势等等的呈现，其包含一些统计学的均值、分位数、极值等等统计量，因此，该图信息量较大，不仅能够分析不同类别数据平均水平差异（需在箱线图中加入均值点），还能揭示数据间离散程度、异常值、分布差异等等。&lt;/p&gt;
&lt;p&gt;使用boxplot()方法绘制。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
np.random.seed(2)  #设置随机种子
df = pd.DataFrame(np.random.rand(5,4),
columns=['A', 'B', 'C', 'D'])#先生成0-1之间的5*4维度数据，再装入4列DataFrame中
df.boxplot() #也可用plot.box()
plt.show()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果图：&lt;br/&gt;&lt;img src=&quot;http://www.bigdata17.com/assets/images/matplotlib_boxplot.png&quot; title=&quot;Matplotlib&quot; alt=&quot;Matplotlib&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6、雷达图&lt;/strong&gt;&lt;br/&gt;雷达图可以用来显示一个周期数值的变化，也可以用来展示对个对象/维度之间的关系&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import numpy as np
import matplotlib.pyplot as plt

#标签
labels = np.array(['语文','数学','英语','生物','物理','化学'])
#数据个数
dataLenth = 6
#数据
data = np.array([7,4,3,6,4,8])

angles = np.linspace(0, 2*np.pi, dataLenth, endpoint=False)
data = np.concatenate((data, [data[0]])) # 闭合
angles = np.concatenate((angles, [angles[0]])) # 闭合

fig = plt.figure()
ax = fig.add_subplot(111, polar=True)# polar参数！！
ax.plot(angles, data, 'bo-', linewidth=2)# 画线
ax.fill(angles, data, facecolor='r', alpha=0.25)# 填充
ax.set_thetagrids(angles * 180/np.pi, labels, fontproperties=&quot;SimHei&quot;)
ax.set_title(&quot;matplotlib雷达图&quot;, va='bottom', fontproperties=&quot;SimHei&quot;)
ax.set_rlim(0,10)
ax.grid(True)
plt.show()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果图：&lt;br/&gt;&lt;img src=&quot;http://www.bigdata17.com/assets/images/matplotlib_leida.png&quot; title=&quot;Matplotlib&quot; alt=&quot;Matplotlib&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;7、气泡图&lt;/strong&gt;&lt;br/&gt;气泡图用于判断3个变量之间是否存在某种关系。它跟散点图有点类似，只不过气泡图以气泡大小作为新的维度&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import pandas as pd
import matplotlib.pyplot as plt
import pandas as pd

d = {&quot;时间&quot;:pd.Series([2006,2007,2008,2009,2010]),
     &quot;数量&quot;:pd.Series([10,200,120,150,300]),
     &quot;大小&quot;:pd.Series([50,130,40,50,160]),
     &quot;分类&quot;:pd.Series([1,2,0,1,2]),
     &quot;判断&quot;:pd.Series([True,True,True,True,True])}

df=pd.DataFrame(d)

#先定义气泡大小，rank 函数将大小列进行大小分配，越大的值分配结果也越高
#n 为倍数，用来调节气泡的大小，且看后头

size=df['大小'].rank()
n=20

#定义一个字典，将颜色跟对应的分类进行绑定

color={0:'red',1:'blue',2:'orange'}

#增加color的参数，用列表解析式将data分类中的每个数据的数字映射到前面color的颜色中

plt.scatter(df['数量'],df['大小'],color=[color[i] for i in df['分类']],s=size*n,alpha=0.6)
plt.show()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果图：&lt;br/&gt;&lt;img src=&quot;http://www.bigdata17.com/assets/images/matplotlib_qipaotu.png&quot; title=&quot;Matplotlib&quot; alt=&quot;Matplotlib&quot;/&gt;&lt;/p&gt;
&lt;p&gt;气泡图用也是scatter方法绘制，和散点图一样。差别在于点的大小不一样，散点图的点都是一样的，而气泡图点的大小不一样。&lt;/p&gt;
&lt;p&gt;以上就是柱状图、散点图、气泡图、折线图的实现方式。希望给大伙带来帮助。&lt;/p&gt;
</description>
<pubDate>Sun, 13 Jan 2019 07:29:00 +0000</pubDate>
<dc:creator>summer哥</dc:creator>
<og:description>数据分析就是将数据以各种图表的形式展现给领导，供领导做决策用，因此熟练掌握饼图、柱状图、线图等图表制作是一个数据分析师必备的技能。Python有两个比较出色的图表制作框架，分别是Matplotlib和</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/airnew/p/10262686.html</dc:identifier>
</item>
<item>
<title>夯实基础系列四：Linux 知识总结 - 花永伦</title>
<link>http://www.cnblogs.com/huayonglun/p/10262564.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huayonglun/p/10262564.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;前三节内容传送门：&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/huayonglun/p/9678205.html&quot;&gt;夯实基础系列一：Java 基础总结&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/huayonglun/p/9683910.html&quot;&gt;夯实基础系列二：网络知识总结&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/huayonglun/p/9696579.html&quot;&gt;夯实基础系列三：数据库知识总结&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;现在很多公司项目部署都使用的是 Linux 服务器，互联网公司更是如此。对于大一些的互联网公司，系统可能会非常复杂，本地无法启动，一般都会采用专门的开发机给开发人员开发测试使用。我实习期间接触的项目没一个可以在本地启动的，都需要写好代码，把代码更新到开发机上，然后编译部署，并查看部署过程中是否有错误或是查看访问这台机器的日志。而这些操作，都需要对基本的 Linux 命令熟悉。&lt;/p&gt;
&lt;p&gt;今天总结下 Linux 的相关概念和基本操作，如果想了解更多，可以去看看《鸟哥的私房菜》。同时希望大家多动手实践，这样理解得更深刻。&lt;/p&gt;
&lt;h2 id=&quot;概要&quot;&gt;概要&lt;/h2&gt;
&lt;p&gt;Linux 知识总结以下部分内容：Linux 常见概念、Linux 常用命令、vi 操作和一个最简单的 shell 脚本。&lt;/p&gt;
&lt;h2 id=&quot;细节&quot;&gt;细节&lt;/h2&gt;
&lt;h3 id=&quot;linux-常见概念&quot;&gt;1. Linux 常见概念&lt;/h3&gt;
&lt;h5 id=&quot;linux-与-windows-的不同&quot;&gt;1.1 Linux 与 Windows 的不同&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;Linux 严格区分大小写&lt;/li&gt;
&lt;li&gt;Linux 中所有内容以文件形式保存，包括硬件。一切内容皆文件。&lt;/li&gt;
&lt;li&gt;Linux 不靠扩展名区分文件类型，靠权限区分文件类型。带后缀的文件名是约定俗成，方便管理&lt;/li&gt;
&lt;li&gt;Windows下的程序不能在Linux中安装和运行&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;linux-采用字符界面有什么优势&quot;&gt;1.2 Linux 采用字符界面有什么优势&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;字符界面占用的系统资源更少&lt;/li&gt;
&lt;li&gt;字符界面减少了出错、被攻击的可能性&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;分区类型&quot;&gt;1.3 分区类型&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;主分区：最多只能有 4 个。&lt;/li&gt;
&lt;li&gt;扩展分区
&lt;ul&gt;&lt;li&gt;最多只能有 1 个&lt;/li&gt;
&lt;li&gt;主分区加扩展分区最多有 4 个&lt;/li&gt;
&lt;li&gt;不能写入数据，只能包含逻辑分区&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;逻辑分区&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;挂载&quot;&gt;1.4 挂载&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;必须分区
&lt;ul&gt;&lt;li&gt;/ (根分区)&lt;/li&gt;
&lt;li&gt;swap 分区（交换分区，内存 2 倍，不超过 2GB）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;推荐分区
&lt;ul&gt;&lt;li&gt;/boot（启动分区，200 MB）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;常见目录的作用&quot;&gt;1.5 常见目录的作用&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;/ 根目录&lt;/li&gt;
&lt;li&gt;/bin 命令保存目录(普通用户就可以读取的命令)&lt;/li&gt;
&lt;li&gt;/boot 启动目录，启动相关文件&lt;/li&gt;
&lt;li&gt;/dev 设备文件保存目录&lt;/li&gt;
&lt;li&gt;/etc 配置文件保存目录&lt;/li&gt;
&lt;li&gt;/home 普通用户的家目录&lt;/li&gt;
&lt;li&gt;/lib 系统库保存目录&lt;/li&gt;
&lt;li&gt;/mnt 系统挂载目录&lt;/li&gt;
&lt;li&gt;/media 挂载目录&lt;/li&gt;
&lt;li&gt;/root 超级用户的家目录&lt;/li&gt;
&lt;li&gt;/tmp 临时目录&lt;/li&gt;
&lt;li&gt;/sbin 命令保存目录(超级用户才能使用的目录)&lt;/li&gt;
&lt;li&gt;/proc 直接写入内存的&lt;/li&gt;
&lt;li&gt;/sys&lt;/li&gt;
&lt;li&gt;/usr 系统软件资源目录
&lt;ul&gt;&lt;li&gt;/usr/bin/ 系统命令(普通用户)&lt;/li&gt;
&lt;li&gt;/usr/sbin/ 系统命令(超级用户)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;/var 系统相关文档内容&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;根目录下的 bin 和 sbin，usr 目录下的bin 和 sbin,这四个目录都是用来保存系统命令的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;proc 和 sys 目录不能直接操作，这两个目录保存的是内存的过载点。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;linux-常用命令&quot;&gt;2. Linux 常用命令&lt;/h3&gt;
&lt;h5 id=&quot;命令基本格式&quot;&gt;2.1 命令基本格式&lt;/h5&gt;
&lt;blockquote&gt;
&lt;p&gt;命令 [选项][参数]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;查询目录中内容&quot;&gt;2.2 查询目录中内容&lt;/h5&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;ls [选项][文件或目录]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;选项：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;-a：显示所有文件，包括隐藏文件&lt;/li&gt;
&lt;li&gt;-l：显示详细信息&lt;/li&gt;
&lt;li&gt;-d：查看目录属性&lt;/li&gt;
&lt;li&gt;-h：人性化显示文件大小&lt;/li&gt;
&lt;li&gt;-i：显示 inode&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;目录处理命令&quot;&gt;2.3 目录处理命令&lt;/h5&gt;
&lt;blockquote&gt;
&lt;p&gt;mkdir -p [目录名]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;-p 递归创建&lt;/p&gt;
&lt;p&gt;命令英文原意：&lt;strong&gt;make directories&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;cd [目录]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;命令英文原意：&lt;strong&gt;change directory&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;简化操作&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;cd ~ 进入当前用户的家目录&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;cd&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;cd - 进入上次目录&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;cd .. 进入上一级目录&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;cd . 进入当前目录&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;查询所在目录位置：pwd&lt;/p&gt;
&lt;p&gt;命令英文原意：&lt;strong&gt;print working directory&lt;/strong&gt;&lt;/p&gt;
&lt;h5 id=&quot;删除文件或目录&quot;&gt;2.4 删除文件或目录&lt;/h5&gt;
&lt;blockquote&gt;
&lt;p&gt;rm -rf [文件或目录]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;选项：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;-r：删除目录&lt;/li&gt;
&lt;li&gt;-f：强制&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;复制命令&quot;&gt;2.5 复制命令&lt;/h5&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;cp [选项][源文件或目录] [目标目录]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;选项：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;-r：复制目录&lt;/li&gt;
&lt;li&gt;-p：连带文件属性复制&lt;/li&gt;
&lt;li&gt;-d：若源文件是链接文件，则复制链接属性&lt;/li&gt;
&lt;li&gt;-a：相当于 -pdr&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;剪切或改名命令&quot;&gt;2.6 剪切或改名命令&lt;/h5&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;mv [原文件或目录][目标目录]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;链接命令&quot;&gt;2.7 链接命令&lt;/h5&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;ln -s [原文件][目标文件]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;生成链接文件&lt;/p&gt;
&lt;p&gt;选项：-s 创建软链接&lt;/p&gt;
&lt;p&gt;硬链接特征：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;拥有相同的i节点和存储block块，可以看做是同一个文件&lt;/li&gt;
&lt;li&gt;可通过i节点识别&lt;/li&gt;
&lt;li&gt;不能跨分区&lt;/li&gt;
&lt;li&gt;不能针对目录使用&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;软链接特征：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;类似 Windows 快捷方式&lt;/li&gt;
&lt;li&gt;软链接拥有自己的i节点和block块，但是数据块中只保存原文件的文件名和i节点号，并没有实际的文件数据&lt;/li&gt;
&lt;li&gt;lrwxrwxrwx表示软链接，软链接文件权限都为rwxrwxrwx&lt;/li&gt;
&lt;li&gt;修改任意文件，另一个都改变&lt;/li&gt;
&lt;li&gt;删除原文件，软链接不能使用&lt;/li&gt;
&lt;li&gt;软链接如果目标文件和源文件不在同一目录下，源文件必须写绝对路径&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;文件搜索命令&quot;&gt;2.8 文件搜索命令&lt;/h5&gt;
&lt;blockquote&gt;
&lt;p&gt;locate 文件名&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在后台数据库中按文件名搜索，搜索速度更快&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;/var/lib/mlocate&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;locate 命令所搜索的后台数据库&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;updatedb&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;更新数据库。默认一天一更新。快。缺点：只能按文件名来搜索&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;find [搜索范围][搜索条件]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;搜索文件&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;find / -name install.log&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;避免大范围搜索，会非常耗费系统资源&lt;/p&gt;
&lt;p&gt;find 是在系统当中搜索符合条件的文件名。如果需要匹配，使用通配符匹配，通配符是完全匹配。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;*   匹配任意内容
?   匹配任意一个字符
[]  匹配任意一个中括号内的字符&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;find /root -iname install.log&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不区分大小写&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;find /root -user root&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;按照所有者搜索&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;find /root -nouser&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;查找没有所有者的文件&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;find /var/log -mtime +10&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;查找10天前修改的文件&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;find . -size 25k&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;查找文件大小是 25KB 的文件&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;find . -inum 262422&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;查找i结点是 262422 的文件&lt;/p&gt;
&lt;h5 id=&quot;搜索命令的命令&quot;&gt;2.9 搜索命令的命令&lt;/h5&gt;
&lt;blockquote&gt;
&lt;p&gt;whereis 命令名&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;搜索命令所在路径及帮助文档所在位置&lt;/p&gt;
&lt;p&gt;选项：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;-b：只查找可执行文件&lt;/li&gt;
&lt;li&gt;-m：只查找帮助文件&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;which 命令能看到目录和别名&lt;/p&gt;
&lt;h5 id=&quot;搜索字符串命令&quot;&gt;2.10 搜索字符串命令&lt;/h5&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;grep [选项] 字符串 文件名&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在文件当中匹配符合条件的字符串&lt;/p&gt;
&lt;p&gt;选项：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;-i：忽略大小写&lt;/li&gt;
&lt;li&gt;-v：排除指定字符串&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;帮助命令&quot;&gt;2.11 帮助命令&lt;/h5&gt;
&lt;blockquote&gt;
&lt;p&gt;man 命令&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;命令 --help&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;help shell内部命令&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;info 命令&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;压缩命令&quot;&gt;2.12 压缩命令&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;zip 格式压缩&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;zip 压缩文件名 源文件&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;压缩文件&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;zip -r 压缩文件名 源目录&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;压缩目录&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;zip格式解压缩&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;unzip 压缩文件&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;gz 格式压缩&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;gzip 源文件&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;压缩为.gz 格式的压缩文件，源文件会消失&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;gzip -c 源文件 &amp;gt; 压缩文件&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;压缩为.gz 格式，源文件保留&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;gzip -r 目录&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;压缩目录下所有的子文件，但是不能压缩目录&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;gz 格式解压缩&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;gzip -d 压缩文件&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;解压缩文件&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;gunzip 压缩文件&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;解压缩文件&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;bz2 格式压缩&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;bzip2 源文件&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;压缩为.bz2格式，不保留源文件&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;bzip2 -k 源文件&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;压缩之后保留源文件&lt;/p&gt;
&lt;p&gt;bzip2命令不能压缩目录&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;打包命令tar&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;tar -cvf 打包文件名 源文件&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;解打包命令&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;tar -xvf 打包文件名&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;.tar.gz压缩格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;其实.tar.gz 格式是先打包为.tar格式，再压缩为.gz格式&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;tar -zcvf 压缩包名.tar.gz 源文件&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;.tar.gz 解压缩&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;tar -zxvf 压缩包名.tar.gz&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;.tar.bz2压缩格式&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;tar -jcvf 压缩包名.tar.bz2 源文件&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;.tar.bz2 解压缩&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;tar -jxvf 压缩包名.tar.bz2&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;关机命令&quot;&gt;2.13 关机命令&lt;/h5&gt;
&lt;blockquote&gt;
&lt;p&gt;shutdown [选项] 时间&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;选项：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;-c：取消前一个关机命令&lt;/li&gt;
&lt;li&gt;-h：关机&lt;/li&gt;
&lt;li&gt;-r：重启&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote&gt;
&lt;p&gt;halt&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;poweroff&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;init 0&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;重启&quot;&gt;2.14 重启&lt;/h5&gt;
&lt;blockquote&gt;
&lt;p&gt;reboot&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;init 6&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;系统运行级别&quot;&gt;2.15 系统运行级别&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;0：关机&lt;/li&gt;
&lt;li&gt;1：单用户&lt;/li&gt;
&lt;li&gt;2：不完全多用户，不含NFS服务&lt;/li&gt;
&lt;li&gt;3：完全多用户&lt;/li&gt;
&lt;li&gt;4：未分配&lt;/li&gt;
&lt;li&gt;5：图形界面&lt;/li&gt;
&lt;li&gt;6：重启&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote&gt;
&lt;p&gt;cat /etc/inittab&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;修改系统默认运行级别&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;runlevel&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;查询系统运行级别&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;logout&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;退出登录&lt;/p&gt;
&lt;h5 id=&quot;挂载命令&quot;&gt;2.16 挂载命令&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;查询与自动挂载&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote&gt;
&lt;p&gt;mount&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;查询系统中已经挂载的设备&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;mount -a&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;依据配置文件/etc/fstab 的内容，自动挂载&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;挂载命令格式&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;mount [-t 文件系统][-o 特殊选项] 设备文件名 挂载点&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;挂载光盘&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote&gt;
&lt;p&gt;mkdir /mnt/cdrom&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;建立挂载点&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;mount -t iso9660 /dev/cdrom /mnt/cdrom/&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;挂载光盘&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;卸载命令&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;umount 设备文件名或挂载点&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;umount /mnt/cdrom&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;查看登录用户信息&quot;&gt;2.17 查看登录用户信息&lt;/h5&gt;
&lt;blockquote&gt;
&lt;p&gt;w 用户名&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;命令输出：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;USER：登录的用户名&lt;/li&gt;
&lt;li&gt;TTY：登录终端&lt;/li&gt;
&lt;li&gt;FROM：从哪个IP地址登录&lt;/li&gt;
&lt;li&gt;LOGIN@：登录时间&lt;/li&gt;
&lt;li&gt;IDLE：用户闲置时间&lt;/li&gt;
&lt;li&gt;JCPU：和该终端连接的所有进程占用的时间&lt;/li&gt;
&lt;li&gt;PCPU：当前进程所占用的时间&lt;/li&gt;
&lt;li&gt;WHAT：当前正在运行的命令&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote&gt;
&lt;p&gt;who 用户名&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;查询当前登录和过去登录的用户信息&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote&gt;
&lt;p&gt;last&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;查看所有用户的最后一次登录时间&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote&gt;
&lt;p&gt;lastlog&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;历史命令&quot;&gt;2.18 历史命令&lt;/h5&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;history [选项][历史命令保存文件]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;选项&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;-c：清空历史命令&lt;/li&gt;
&lt;li&gt;-w：把缓存中的历史命令写入历史命令保存文件 ~/.bash_history&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;历史命令默认会保存 1000 条，可以在环境变量配置文件 /etc/profile 中进行修改&lt;/p&gt;
&lt;h5 id=&quot;统计&quot;&gt;2.19 统计&lt;/h5&gt;
&lt;blockquote&gt;
&lt;p&gt;wc [选项][文件名]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;选项&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;-c：统计字节数&lt;/li&gt;
&lt;li&gt;-w：统计单词数&lt;/li&gt;
&lt;li&gt;-l：统计行数&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;管道符&quot;&gt;2.20 管道符&lt;/h5&gt;
&lt;p&gt;分页查看输出内容&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ls -l /etc | more&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;netstat -an | grep ESTABLISHED&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;用户和用户组&quot;&gt;2.21 用户和用户组&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;用户：使用操作系统的人&lt;/li&gt;
&lt;li&gt;用户组：具有相同系统权限的一组用户&lt;/li&gt;
&lt;li&gt;/etc/group：存储当前系统中所有用户组信息
&lt;ul&gt;&lt;li&gt;组名称&lt;/li&gt;
&lt;li&gt;组密码占位符&lt;/li&gt;
&lt;li&gt;组编号&lt;/li&gt;
&lt;li&gt;组中用户名列表&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;/etc/gshadow：存储当前系统中用户组的密码信息
&lt;ul&gt;&lt;li&gt;组名称&lt;/li&gt;
&lt;li&gt;组密码&lt;/li&gt;
&lt;li&gt;组管理者&lt;/li&gt;
&lt;li&gt;组中用户名列表&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;/etc/passwd：存储当前系统中所有用户的信息
&lt;ul&gt;&lt;li&gt;用户名&lt;/li&gt;
&lt;li&gt;密码占位符&lt;/li&gt;
&lt;li&gt;用户编号&lt;/li&gt;
&lt;li&gt;用户组编号&lt;/li&gt;
&lt;li&gt;用户注释信息&lt;/li&gt;
&lt;li&gt;用户主目录&lt;/li&gt;
&lt;li&gt;shell 类型&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;/etc/shadow 存储当前系统中所有用户的密码信息
&lt;ul&gt;&lt;li&gt;用户名&lt;/li&gt;
&lt;li&gt;密码&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;vi-操作&quot;&gt;3. vi 操作&lt;/h3&gt;
&lt;h5 id=&quot;操作模式&quot;&gt;3.1 操作模式&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;Command Mode：命令模式&lt;/li&gt;
&lt;li&gt;Insert Mode：输入模式&lt;/li&gt;
&lt;li&gt;Last Line Mode：底行模式&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;常用指令&quot;&gt;3.2 常用指令&lt;/h5&gt;
&lt;blockquote&gt;
&lt;p&gt;vim + abc&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;打开文件并把光标定位到最后一行&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;vim +2 abc&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;第二行&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;vim +/xxx abc&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;跳到指定字符串第一次出现的地方&lt;br/&gt;同时打开多个文件 可用n N prev来切换&lt;/p&gt;
&lt;h5 id=&quot;底行模式常用指令&quot;&gt;3.3 底行模式常用指令&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;:w
&lt;ul&gt;&lt;li&gt;保存文件，但不退出vi&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;:q
&lt;/li&gt;
&lt;li&gt;:!
&lt;ul&gt;&lt;li&gt;强制执行&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;/xxx
&lt;ul&gt;&lt;li&gt;向下查找, 按n查找下一个, N查找上一个,这个跟less命令的查找使用方式是一样的&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;?xxx
&lt;ul&gt;&lt;li&gt;往前查找, 按n查找下一个, N查找上一个&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;命令模式常用指令&quot;&gt;3.4 命令模式常用指令&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;h：光标左移&lt;/li&gt;
&lt;li&gt;j：光标下移&lt;/li&gt;
&lt;li&gt;k：光标上移&lt;/li&gt;
&lt;li&gt;l：光标右移&lt;/li&gt;
&lt;li&gt;ctrl+f：向下翻页&lt;/li&gt;
&lt;li&gt;ctrl+b：向上翻页&lt;/li&gt;
&lt;li&gt;ctrl+d：向下翻半页&lt;/li&gt;
&lt;li&gt;ctrl+f：向上翻半页&lt;/li&gt;
&lt;li&gt;dd：删除光标所在行&lt;/li&gt;
&lt;li&gt;o：在光标所在处的下方插入一行并切换到输入模式&lt;/li&gt;
&lt;li&gt;yy：复制光标所在的行&lt;/li&gt;
&lt;li&gt;p：在光标所在行的下方粘贴&lt;/li&gt;
&lt;li&gt;P：在光标所在行的上方粘贴&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;shell-基础&quot;&gt;3. Shell 基础&lt;/h3&gt;
&lt;h5 id=&quot;shell-是什么&quot;&gt;3.1 Shell 是什么&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;命令行解释器，可启动、挂起、停止或编写程序&lt;/li&gt;
&lt;li&gt;编程语言，可直接调用Linux 系统命令&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;输出命令&quot;&gt;3.2 输出命令&lt;/h5&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;echo [选项][输出内容]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;脚本编写&quot;&gt;3.3 脚本编写&lt;/h5&gt;
&lt;p&gt;首行&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;#!/bin/bash&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;echo &quot;hello world&quot;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;赋予执行权限，直接运行&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;chmod 755 hello.sh&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;./hello.sh&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;通过bash 执行脚本&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;bash hello.sh&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;欢迎关注微信公众号，技术，思维，心理，带给你认知的全方位成长。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/006tNbRwgy1fvibc07tuqj30hs07q0u7.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;你的关注，就是对我最大的肯定，我会努力产出的，我们一起成长~&lt;/p&gt;
&lt;p&gt;本文由 &lt;strong&gt;永伦的小屋&lt;/strong&gt; 原创。&lt;br/&gt;转载请&lt;strong&gt;注明作者及出处&lt;/strong&gt;,本文作者为 永伦的小屋。&lt;/p&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;http://huayonglun.com/2016/09/01/%E5%A4%AF%E5%AE%9E%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97/%E5%A4%AF%E5%AE%9E%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E5%9B%9B%EF%BC%9ALinux%20%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/&quot;&gt;夯实基础系列四：Linux 知识总结&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 13 Jan 2019 06:55:00 +0000</pubDate>
<dc:creator>花永伦</dc:creator>
<og:description>现在很多公司项目部署都使用的是 Linux 服务器，互联网公司更是如此。对于大一些的互联网公司，系统可能会非常复杂，本地无法启动，一般都会采用专门的开发机给开发人员开发测试使用。我实习期间接触的项目没</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/huayonglun/p/10262564.html</dc:identifier>
</item>
<item>
<title>istio-opentracing链路追踪方案 - mathli</title>
<link>http://www.cnblogs.com/mathli/p/10262553.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mathli/p/10262553.html</guid>
<description>&lt;p&gt;istio-opentracing链路追踪主要是由sidecar(envoy)支持的，istio只是在上层进行配置的修改。&lt;/p&gt;
&lt;h2 id=&quot;envoy链路追踪&quot;&gt;envoy链路追踪&lt;/h2&gt;
&lt;p&gt;envoy主要用三个功能来支撑系统范围内的跟踪&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;生成Request ID: envoy会在需要的时候生成UUID，并操作名为[x-request-id]的HTTP Header。应用可以转发这个Header用于统一的记录和追踪。&lt;/li&gt;
&lt;li&gt;集成外部追踪服务： envoy支持可插件的外部跟踪可视化服务。目前支持&lt;a href=&quot;https://lightstep.com/&quot;&gt;LightStep&lt;/a&gt;、&lt;a href=&quot;https://zipkin.io/&quot;&gt;zipkin&lt;/a&gt;或者Zipkin兼容的后端(例如:&lt;a href=&quot;https://www.jaegertracing.io/docs/1.8/&quot;&gt;jaeger&lt;/a&gt;)．另外可自己添加其它的追踪服务。&lt;/li&gt;
&lt;li&gt;客户端跟踪ID连接： &lt;a href=&quot;http://www.servicemesher.com/envoy/configuration/http_conn_man/headers.html#x-client-trace-id&quot;&gt;x-client-trace-id&lt;/a&gt; Header 可以用来把不信任的请求 ID 连接到受信的 x-request-id Header 上。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;初始化追踪&quot;&gt;初始化追踪&lt;/h3&gt;
&lt;p&gt;有多种途劲初始化追踪&lt;/p&gt;
&lt;h3 id=&quot;跟踪上下文信息&quot;&gt;跟踪上下文信息&lt;/h3&gt;
&lt;p&gt;不管使用的是哪个跟踪服务，都应该传播x-request-id，这样在被调用服务中启动相关性的记录。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果使用了 LightStep 跟踪器，在发送 HTTP 请求到其他服务，Envoy 依赖这个服务来传播 x-ot-span-context Header。&lt;/li&gt;
&lt;li&gt;如果使用的是 Zipkin，Envoy 要传播的是 B3 Header．（x-b3-traceid， x-b3-spanid, x-b3-parentspanid， x-b3-sampled，以及 x-b3-flags）也可以由外部客户端提出，用来启用或者禁用某个服务的跟踪请求。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;istio链路追踪&quot;&gt;istio链路追踪&lt;/h2&gt;
&lt;h3 id=&quot;链路追踪参数&quot;&gt;链路追踪参数&lt;/h3&gt;
&lt;p&gt;istio链路追踪提供了全局配置zipkinAddress。istio的sidecar流量拦截后上报到链路系统，envoy的上报地址通过proxy_init的--zipkinAddress参数传入。由上面可知envoy的链路追踪主要的原生支持是jaeger。&lt;/p&gt;
&lt;p&gt;istio的链路追踪并不能在sidecar中全部处理，是有侵入性的。业务需要存储几个特殊字段，在要调用下个服务时，把这几个字段带上。这样才能把整条链路串起来。具体可看上面的跟踪上下文信息，&lt;a href=&quot;https://istio.io/docs/tasks/telemetry/distributed-tracing/&quot;&gt;istio链路追踪&lt;/a&gt;例子。&lt;/p&gt;
&lt;p&gt;mix模块中的telemetry和policy这两个的链路追踪是通过参数--trace_zipkin_url=&lt;a href=&quot;http://zipkin:9411/api/v1/spans&quot; class=&quot;uri&quot;&gt;http://zipkin:9411/api/v1/spans&lt;/a&gt; 来配置的。&lt;/p&gt;
&lt;h3 id=&quot;采样率&quot;&gt;采样率&lt;/h3&gt;
&lt;p&gt;链路的采样率istio中只提供了一个全局的配置，通过配置pilot的参数PILOT_TRACE_SAMPLING来控制，其范围是0.0-100.0，最小可配参数0.01，默认100。&lt;/p&gt;
&lt;p&gt;修改方式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;helm安装时参数选项：&lt;a href=&quot;https://istio.io/docs%E9%80%9A%E8%BF%87kubectl%20-n%20Istio-system%20edit%20deploy%20Istio-pilot%E4%BF%AE%E6%94%B9PILOT_TRACE_SAMPLING%E5%8F%98%E9%87%8F%E3%80%82/reference/config/installation-options/&quot;&gt;pilot.traceSampling&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;生成的yaml文件中修改PILOT_TRACE_SAMPLING变量，重新apply。&lt;/li&gt;
&lt;li&gt;通过kubectl -n Istio-system edit deploy Istio-pilot修改PILOT_TRACE_SAMPLING变量。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;jaeger&quot;&gt;jaeger&lt;/h2&gt;
&lt;p&gt;istio的tracing默认使用&lt;a href=&quot;https://www.jaegertracing.io/&quot;&gt;jaeger&lt;/a&gt;来实现日志追踪的发送，存储，查询。&lt;br/&gt;先来看jaeger的架构图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1531082/201901/1531082-20190113145052305-1350567886.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;jaeger主要由以下几部分组成&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;jaeger-client为不同语言实现的OpenTracing标准的SDK．应用程序通过API写入数据，然后按照指定策略把trace传递给jaeger-agent．&lt;/li&gt;
&lt;li&gt;agent是一个UDP中转服务，它将数据批量发送给collector．它是一个基础组件，布在所有机器上．&lt;/li&gt;
&lt;li&gt;collector接收agent发送来的数据，然后将数据写入后端．collector是一个无状态组件，可以建任意数量．&lt;/li&gt;
&lt;li&gt;data-store后端存储被设计成一个可插拔的组件．支持&lt;a href=&quot;https://www.jaegertracing.io/docs/1.7/deployment/#cassandra&quot;&gt;Cassandra&lt;/a&gt;和&lt;a href=&quot;https://www.jaegertracing.io/docs/1.7/deployment#elasticsearch&quot;&gt;ElasticSearch&lt;/a&gt;．&lt;/li&gt;
&lt;li&gt;query从存储中提取数据并通过UI展示．&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;istio中jaeger现状&quot;&gt;istio中jaeger现状&lt;/h3&gt;
&lt;p&gt;istio目前官方自带的是all-in-one的镜像，所有的组件都包含在一个镜像中．数据的存储是存在内存中，pod删除或重启，所有的数据就全没有了．这没法线上使用．&lt;/p&gt;
&lt;p&gt;为此，我们需要考虑将数据存储为指定的存储服务，采用官方自带的肯定不行，需要自己重新部署一套jaeger。&lt;/p&gt;
&lt;h3 id=&quot;jaeger持久化存储&quot;&gt;jaeger持久化存储&lt;/h3&gt;
&lt;h4 id=&quot;k8s部署jaeger&quot;&gt;k8s部署jaeger&lt;/h4&gt;
&lt;p&gt;根据&lt;a href=&quot;https://github.com/jaegertracing/jaeger-kubernetes&quot;&gt;官方文档&lt;/a&gt;部署基于k8s的Jaeger的生产环境下的容器，这个要采用Production这个生成的部署方式。&lt;/p&gt;
&lt;p&gt;这种方式的部署比较麻烦，需要对jaeger有一定的理解，对存储服务如ES都需要有一定的研究。因此这种试不推荐。&lt;/p&gt;
&lt;h4 id=&quot;接入自己的es服务&quot;&gt;接入自己的ES服务&lt;/h4&gt;
&lt;p&gt;istio的链路追踪通过zipkin直接传输到jaeger-collector，jaeger-collector将数据发送到自己现有的ES集群进行存储，jaeger-query直接去现有ES集群查询。&lt;/p&gt;
&lt;h5 id=&quot;链路追踪发送到jaeger-collector&quot;&gt;链路追踪发送到jaeger-collector&lt;/h5&gt;
&lt;p&gt;如果不在同个namespace下，需要修改zipkin地址为jaeger的zipkin收集地址。envoy这个proxy会默认使用环境变量来设置zipkinAddress地址，默认地址是zipkin.istio-system:9411。可在yaml下查找zipkinAddress来修改，然后更新就可以。如果后继有helm update更新，需要去修改charts，在&lt;code&gt;install/kubernetes/helm/istio//templates/configmap.yaml&lt;/code&gt; 和 &lt;code&gt;install/kubernetes/helm/istio//charts/mixer/templates&lt;/code&gt; 这两个下面的zipkin地址。 mix相关的trace_zipkin_url的zipkin也要改成对应的地址。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;修改istio的zipkin地址需要重新启动pod。&lt;/li&gt;
&lt;li&gt;jaeger-agent这个服务,因为我们是直接配置到jaeger-collector因些不需要。&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;jaeger-collector到es集群&quot;&gt;jaeger-collector到ES集群&lt;/h5&gt;
&lt;p&gt;这个官方的jaeger是支持发送到kafka,但由于jaeger会生成3个index(jaeger-span,jaeger-service,jager-dependencies)，而kafka发送到ES时，要区分有点麻烦。暂时先直接发送到ES。&lt;/p&gt;
&lt;h5 id=&quot;jaeger-query&quot;&gt;jaeger-query&lt;/h5&gt;
&lt;p&gt;这个配置只需将查询地址改为ES的地址。&lt;/p&gt;
&lt;p&gt;jaeger-query的dependencies服务生成图需要自己配置&lt;a href=&quot;https://github.com/jaegertracing/spark-dependencies&quot;&gt;spark-dependencies&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;线上例子&quot;&gt;线上例子&lt;/h4&gt;
&lt;p&gt;jaeger-collector的ES配置参数可通过下面来查看，jaeger-query的参数也是一样的&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker run \
  -e SPAN_STORAGE_TYPE=elasticsearch \
  jaegertracing/jaeger-collector:1.8 \
  --help&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;k8s jaeger的configmap&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;apiVersion: v1
kind: ConfigMap
metadata:
  name: jaeger-configuration
  namespace: istio-system
  labels:
    app: jaeger
    jaeger-infra: configuration
data:
  span-storage-type: elasticsearch
  collector: |
    es:
      server-urls: http://example1.com:9200,http://example2.com:9200
      index-prefix: online-opentracing 
    collector:
      zipkin:
        http-port: 9411
  query: |
    es:
      server-urls: http://example1.com:9200,http://example2.com:9200
      index-prefix: online-opentracing&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;k8s jaeger-collector和jaeger-query&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;apiVersion: v1
kind: List
items:
- apiVersion: extensions/v1beta1
  kind: Deployment
  metadata:
    name: jaeger-collector
    namespace: istio-system
    labels:
      app: jaeger
      jaeger-infra: collector-deployment
  spec:
    replicas: 3
    strategy:
      type: Recreate
    template:
      metadata:
        labels:
          app: jaeger
          jaeger-infra: collector-pod
        annotations:
          prometheus.io/scrape: &quot;true&quot;
          prometheus.io/port: &quot;14268&quot;
      spec:
        containers:
        - image: jaegertracing/jaeger-collector:1.8.2
          name: jaeger-collector
          args: [&quot;--config-file=/conf/collector.yaml&quot;]
          ports:
          - containerPort: 14267
            protocol: TCP
          - containerPort: 14268
            protocol: TCP
          - containerPort: 9411
            protocol: TCP
          readinessProbe:
            httpGet:
              path: &quot;/&quot;
              port: 14269
          volumeMounts:
          - name: jaeger-configuration-volume
            mountPath: /conf
          env:
          - name: SPAN_STORAGE_TYPE
            valueFrom:
              configMapKeyRef:
                name: jaeger-configuration
                key: span-storage-type
        volumes:
          - configMap:
              name: jaeger-configuration
              items:
                - key: collector
                  path: collector.yaml
            name: jaeger-configuration-volume
- apiVersion: v1
  kind: Service
  metadata:
    name: jaeger-collector
    namespace: istio-system
    labels:
      app: jaeger
      jaeger-infra: collector-service
  spec:
    ports:
    - name: jaeger-collector-tchannel
      port: 14267
      protocol: TCP
      targetPort: 14267
    - name: jaeger-collector-http
      port: 14268
      protocol: TCP
      targetPort: 14268
    - name: jaeger-collector-zipkin
      port: 9411
      protocol: TCP
      targetPort: 9411
    selector:
      jaeger-infra: collector-pod
    type: ClusterIP
- apiVersion: v1
  kind: Service
  metadata:
    name: zipkin
    namespace: istio-system
    labels:
      app: jaeger
      jaeger-infra: zipkin-service
  spec:
    ports:
    - name: jaeger-collector-zipkin
      port: 9411
      protocol: TCP
      targetPort: 9411
    selector:
      jaeger-infra: collector-pod
    type: ClusterIP
- apiVersion: extensions/v1beta1
  kind: Deployment
  metadata:
    name: jaeger-query
    namespace: istio-system
    labels:
      app: jaeger
      jaeger-infra: query-deployment
  spec:
    replicas: 1
    strategy:
      type: Recreate
    template:
      metadata:
        labels:
          app: jaeger
          jaeger-infra: query-pod
        annotations:
          prometheus.io/scrape: &quot;true&quot;
          prometheus.io/port: &quot;16686&quot;
      spec:
        containers:
        - image: jaegertracing/jaeger-query:1.8.2
          name: jaeger-query
          args: [&quot;--config-file=/conf/query.yaml&quot;]
          ports:
          - containerPort: 16686
            protocol: TCP
          readinessProbe:
            httpGet:
              path: &quot;/&quot;
              port: 16687
          volumeMounts:
          - name: jaeger-configuration-volume
            mountPath: /conf
          env:
          - name: SPAN_STORAGE_TYPE
            valueFrom:
              configMapKeyRef:
                name: jaeger-configuration
                key: span-storage-type
        volumes:
          - configMap:
              name: jaeger-configuration
              items:
                - key: query
                  path: query.yaml
            name: jaeger-configuration-volume
- apiVersion: v1
  kind: Service
  metadata:
    name: jaeger-query
    namespace: istio-system
    labels:
      app: jaeger
      jaeger-infra: query-service
  spec:
    type: NodePort
    ports:
    - name: jaeger-query
      port: 80
      protocol: TCP
      targetPort: 16686
      nodePort: 32686
    selector:
      jaeger-infra: query-pod
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参考文档：&lt;/p&gt;
</description>
<pubDate>Sun, 13 Jan 2019 06:54:00 +0000</pubDate>
<dc:creator>mathli</dc:creator>
<og:description>istio opentracing链路追踪方案 istio opentracing链路追踪主要是由sidecar(envoy)支持的，istio只是在上层进行配置的修改。 envoy链路追踪 envo</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mathli/p/10262553.html</dc:identifier>
</item>
<item>
<title>MySQL主从复制架构使用方法 - 听风。</title>
<link>http://www.cnblogs.com/huchong/p/10253522.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huchong/p/10253522.html</guid>
<description>&lt;p&gt;数据库服务器存在单点问题&lt;br/&gt;数据库服务器资源无法满足增长的读写请求&lt;br/&gt;高峰时数据库连接数经常超过上限&lt;/p&gt;

&lt;p&gt;增加额外的数据库服务器，组建数据库集群&lt;/p&gt;
&lt;p&gt;同一集群中的数据库服务器需要具有相同的数据&lt;/p&gt;
&lt;p&gt;集群中的任一服务器宕机后，其它服务器可以取代宕机服务器&lt;/p&gt;

&lt;h2 id=&quot;主库将变更写入到主库的binlog中&quot;&gt;1. 主库将变更写入到主库的binlog中&lt;/h2&gt;
&lt;p&gt;一些MySQL版本并不会开启二进制日志，所以一定要检查是否开启&lt;br/&gt;如果刚开始没有开启，后面再进行开启的话，需要重启数据库才能生效，而且数据库的重启往往会对业务造成很大的影响&lt;br/&gt;尽管二进制日志对性能有稍许的影响，所以还是建议大家无论是否使用复制功能，都要开启Mysql二进制日志，因为&lt;strong&gt;增量备份也需要二进制日志&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;从库的io线程在指定位置读取主库binlog内容存储到本地的中继日志relay-log中&quot;&gt;2. 从库的IO线程在指定位置读取主库binlog内容存储到本地的中继日志（Relay Log）中&lt;/h2&gt;
&lt;p&gt;要完成二进制日志的传输过程，MySQL会在从服务器上启动一个工作线程，称为IO线程，这个IO线程会跟主数据库建立一个普通的客户端连接，然后在主服务器上启动一个特殊的二进制转储线程称为binlogdown线程&lt;br/&gt;从库上的IO线程通过这个二进制转储线程来读取主库上的二进制事件，如果该事件追赶上主库，则会进入sleep状态，直到主库发起信号通知有新事件产生时，才会被唤醒，relay log的格式和binlog格式是完全相同的，&lt;br/&gt;可以使用mysqlbinlog 来读取relay log中的内容&lt;/p&gt;
&lt;h2 id=&quot;从库的sql线程读取relay-log日志中的内容并在从库中重放&quot;&gt;3. 从库的SQL线程读取Relay Log日志中的内容，并在从库中重放&lt;/h2&gt;
&lt;p&gt;sql线程所执行的事件，我们可以通过配置选项来决定是否要写入到从服务器的二进制日志中&lt;/p&gt;
&lt;h2 id=&quot;目前mysql支持两种复制类型&quot;&gt;目前mysql支持两种复制类型&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;基于二进制日志点的复制&lt;/li&gt;
&lt;li&gt;基于GTID的复制（Mysql&amp;gt;=5.7推荐使用）&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;配置主从数据库服务器参数&quot;&gt;1. 配置主从数据库服务器参数&lt;/h2&gt;
&lt;p&gt;有些参数配置后需要数据库重启才能生效，为了不影响数据库的正常使用，我们最好在服务器上线的同时就把参数都配置好&lt;br/&gt;特别是master服务器的参数，更应该作为服务器初始参数来进行配置&lt;/p&gt;
&lt;h3 id=&quot;master服务器&quot;&gt;master服务器&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;log_bin  = /data/mysql/sql_log/mysql-bin    # 指定mysql的binlog的存放路径 /data/mysql/sql_log，以及日志文件名前缀mysql-bin ,
                                                                    # 如果只是为了启用binlog，可以不指定存放路径，默认会存放到mysql的data目录下，也就是会把日志和数据文件存放在一起
                                                                    # 之所以指定路径分开存放，是为了提高IO性能，所以还是建议日志文件和数据文件分开存放
server_id = 100    # mysql的复制集群中通过server_id的值区分不同的服务器，建议使用服务器ip的后一段或后两段的值进行配置，比如192.168.2.100,就设置为100或2100

&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;slave-服务器&quot;&gt;slave 服务器&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;log_bin  = /data/mysql/sql_log/mysql-bin 
server_id = 101

relay_log = /data/mysql/sql_log/relay-bin    # 指定relay_log日志的存放路径和文件前缀 ，不指定的话默认以主机名作为前缀

read_only = on    #    使所有没有server权限的用户，在从服务器上不能执行写操作，不论这个用户是否拥有写权限 （mysql5.7 可以使用 super_read_only = on ，限制super用户也不能在从服务器上执行写操作）

skip_slave_start = on    # 在slave服务器重启时，不会自动启动复制链路。默认情况下slave服务器重启后，mysql会自动启动复制链路，如果这个时候存在问题，则主从链路会中断，所以正常情况下，我们应该在服务器重启后检查是否存在问题，然后再手动启动复制链路

# 下面两个参数是把主从复制信息存储到innodb表中，默认情况下主从复制信息是存储到文件系统中的，如果从服务器宕机，很容易出现文件记录和实际同步信息不同的情况，存储到表中则可以通过innodb的崩溃恢复机制来保证数据记录的一致性
master_info_repository = TABLE
relay_log_info_repository = TABLE&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;在master服务器上创建用于复制的数据库账号&quot;&gt;2. 在master服务器上创建用于复制的数据库账号&lt;/h2&gt;
&lt;p&gt;用于IO线程连接master服务器获取binlog日志&lt;br/&gt;需要* REPLICATION SLAVE** 权限&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    create user 'repl'@'ip段' identified by 'password';
    grant replication slave on *.* to 'repl'@'ip段';&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;备份master服务器上的数据并初始化-slave服务器数据&quot;&gt;3. 备份master服务器上的数据并初始化 slave服务器数据&lt;/h2&gt;
&lt;p&gt;建议主从数据库服务器采用相同的MySQL版本&lt;br/&gt;建议使用全库备份的方式初始化slave数据&lt;/p&gt;
&lt;p&gt;采用相同版本的好处&lt;br/&gt;我们可以使用全备的方式来初始化slave数据，还可以避免不同版本之间的差异造成数据库同步失败的问题&lt;/p&gt;
&lt;p&gt;如果我们使用的主从复制的服务器mysql版本不同，则一定要注意master上的版本一定要低于slave服务器，不然同步的时候就可能出现错误&lt;/p&gt;
&lt;p&gt;由于我们演示过程中的mysql服务器都是使用的mysql5.7&lt;br/&gt;所以我们可以使用全备的方式进行&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysqldump --master-data=2 -uroot -p -A --single-transaction -R --triggers&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;启动基于日志点的复制链路&quot;&gt;4. 启动基于日志点的复制链路&lt;/h2&gt;
&lt;p&gt;在slave服务器上运行&lt;/p&gt;
&lt;p&gt;mysql命令&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;CHANGE MASTER TO
MASTER_HOST= 'master_host_ip',
MASTER_USER= 'repl',
MASTER_PASSWORD = 'password',
MASTER_LOG_FILE='mysql_log_file_name',
MASTER_LOG_POS=xxxxxx;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;启动基于gtid的复制链路&quot;&gt;5. 启动基于GTID的复制链路&lt;/h2&gt;
&lt;p&gt;GTID：全局事务ID&lt;br/&gt;GTID可以保证每一个在主上提交的事务，在复制集群中可以生成一个唯一的ID值，要使用基于GTID的复制，我们要在主从复制的配置文件中同时加入以下配置项&lt;/p&gt;
&lt;p&gt;mysql配置&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;gtid_mode=on # 是否启动gtid模式，启动了此模式会在二进制日志中会额外记录每个事务的GTID标识符
enforce-gtid-consistency    # 强制gtid一致性，用于保证启动gtid后事务的安全
log-slave-updates = on    # mysql5.6一定要启用参数，5.7可以不启用
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;mysql命令&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;CHANGE MASTER TO
MASTER_HOST= 'master_host_ip',
MASTER_USER= 'repl',
MASTER_PASSWORD = 'password',
MASTER_AUTO_POSITION=1;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;gtid复制的限制&quot;&gt;GTID复制的限制&lt;/h3&gt;
&lt;p&gt;无法再使用create table ... select 语句建立表，只能先create表，再insert 数据&lt;br/&gt;无法在事务中使用create temporary table 建立临时表&lt;br/&gt;无法使用关联更新同时更新事务表和非事务表&lt;/p&gt;
&lt;h2 id=&quot;和5中选一个执行即可&quot;&gt;4和5中选一个执行即可&lt;/h2&gt;

&lt;h2 id=&quot;先对主服务器进行配置&quot;&gt;1. 先对主服务器进行配置&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;[client]
port  = 3306     # 客户端端口号为3306
socket = /home/mysql/data/mysql.sock

[mysqld]

# skip #
skip_name_resolve = 1
skip-external-locking =1

# GENERAL #
user = mysql   # MySQL启动用户
default_storage_engine = InnoDB  # 新数据表的默认数据表类型
character-set-server = utf8      #     #服务端默认编码（数据库级别）
socket = /home/mysql/data/mysql.sock
pid_file =  /home/mysql/data/mysqld.pid
basedir = /home/mysql    #使用该目录作为根目录（Mysql安装目录）；

port = 3306
bind-address = 0.0.0.0
log_error_verbosity = 3
explicit_defaults_for_timestamp = off
#sql_mode = NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES
#sql_mode = NO_ENGINE_SUBSTITUTION

# undo log
# innodb_undo_directory = /home.mysql/undo
# innodb_undo_tablespaces = 32

# MyISAM #
key_buffer_size =32M

# SAFETY #
max_allowed_packet    = 100M
max_connect_errors    = 1000000
sysdate_is_now    =1
#innodb = FORCE
#innodb_strict_mode = 1  

# Replice #
server-id = 100
relay_log =  /home/mysql/sql_log/mysqld-relay-bin 

#plugin-load = semisync_master.so
log_slave_updates = on
master_info_repository = TABLE
relay_log_info_repository =TABLE
# gtid_mode = on
# enforce_gtid_consistency =on
# skip-slave-start =1
#rpl_semi_sync_master_enabled = 1
#rpl_semi_sync_master_timeout=200    # 0.2 second
master_info_respository = TABLE
# gtid_mode= on
# enforce_gtid_consistency = on
# skip-slave-start = 1

# DATA STORAGE #

datadir = /home/mysql/data     #mysql 数据文件存放的目录
tmpdir = /tmp    # MySQL存放临时文件的目录

# BINARY LOGGING #

log_bin = /home/mysql/sql_log/mysql-bin
max_binlog_size  = 1000M
binlog_format = row
expire_log_days = 7
sync_binlog = 1

# CACHES AND LIMITS #

tmp_table_size = 32M
max_heap_table_size = 32M
query_cache_type = 0    
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于主服务器一直在运行着，在生产环境中主服务器是很少会重启的，如果主服务器重启，会造成正常的业务访问的中断，所以在服务器启动之前就启动了二进制日志&lt;br/&gt;这里不需要重启主服务器了，由于主服务器的默认server_id=1，我们虽然在配置文件中更改了它的值 ，但实际运行环境中并没有改变&lt;/p&gt;
&lt;p&gt;我们可以查看一下当前server_id&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; show variables like '%server_id%';&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以通过以下命令动态的进行修改&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; set global server_id = 100;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;再对从服务器进行配置&quot;&gt;2. 再对从服务器进行配置&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;[client]
port  = 3306     # 客户端端口号为3306
socket = /home/mysql/data/mysql.sock

[mysqld]

# skip #
skip_name_resolve = 1
skip-external-locking =1

# GENERAL #
user = mysql   # MySQL启动用户
default_storage_engine = InnoDB  # 新数据表的默认数据表类型
character-set-server = utf8      #     #服务端默认编码（数据库级别）
socket = /home/mysql/data/mysql.sock
pid_file =  /home/mysql/data/mysqld.pid
basedir = /home/mysql    #使用该目录作为根目录（Mysql安装目录）；

port = 3306
bind-address = 0.0.0.0
log_error_verbosity = 3
explicit_defaults_for_timestamp = off
#sql_mode = NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES
#sql_mode = NO_ENGINE_SUBSTITUTION
read_only = on

# undo log
# innodb_undo_directory = /home.mysql/undo
# innodb_undo_tablespaces = 32

# MyISAM #
key_buffer_size =32M

# SAFETY #
max_allowed_packet    = 100M
max_connect_errors    = 1000000
sysdate_is_now    =1
#innodb = FORCE
#innodb_strict_mode = 1  

# Replice #
server-id = 101
relay_log =  /home/mysql/sql_log/mysqld-relay-bin 

#plugin-load = semisync_master.so
log_slave_updates = on
master_info_repository = TABLE
relay_log_info_repository =TABLE
# gtid_mode = on
# enforce_gtid_consistency =on
# skip-slave-start =1
#rpl_semi_sync_master_enabled = 1
#rpl_semi_sync_master_timeout=200    # 0.2 second
master_info_respository = TABLE
# gtid_mode= on
# enforce_gtid_consistency = on
# skip-slave-start = 1

# DATA STORAGE #

datadir = /home/mysql/data     #mysql 数据文件存放的目录
tmpdir = /tmp    # MySQL存放临时文件的目录

# BINARY LOGGING #

log_bin = /home/mysql/sql_log/mysql-bin
max_binlog_size  = 1000M
binlog_format = row
expire_log_days = 7
sync_binlog = 1

# CACHES AND LIMITS #

tmp_table_size = 32M
max_heap_table_size = 32M
query_cache_type = 0    
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改完从服务器配置后，重启mysql服务器&lt;/p&gt;
&lt;p&gt;如果使用的是mysql5.7版本的需要注意&lt;br/&gt;mysql5.7增加了server-uuid值，默认情况下载auto.cnf文件中，如果是使用的镜像的方式安装，可能大家的uuid一样 ，所以需要把auto.cnf文件删除掉。mysql重启后会自动重新生成uuid的值，这样就可以保证不同服务器上的mysql实例的uuid的值是不一样的&lt;/p&gt;
&lt;p&gt;如果server-uuid的值相同，主从复制会出现问题&lt;/p&gt;
&lt;p&gt;以上我们就完成了主从复制的配置，接下来我们要在主服务器上建立复制账号&lt;/p&gt;
&lt;h2 id=&quot;在mysql主服务器上建立mysql复制账号&quot;&gt;3. 在mysql主服务器上建立mysql复制账号&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; create user 'dba_repl'@'192.168.2.%' identified by '123456';

mysql&amp;gt; grant replication slave on *.* to 'dba_repl'@'192.168.2.%';&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;建立好复制账号以后&lt;/p&gt;
&lt;h2 id=&quot;通过mysql主服务器上的全备初始化从服务器上数据&quot;&gt;4. 通过mysql主服务器上的全备初始化从服务器上数据&lt;/h2&gt;
&lt;p&gt;进行全备&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@localhost data]# cd /data/db_backup/
[root@localhost db_backup]#  mysqldump -uroot -p --master-data=1 --single-transaction --routines --triggers --events  --all-databases &amp;gt; all.sql
Enter password: &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将其拷贝到从服务器上&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@localhost db_backup]# scp all.sql root@192.168.2.101:/root&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在从服务器上恢复备份进行初始化&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@Node2 ~]# mysql -uroot -p &amp;lt; all.sql&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;初始化完成后，准备&lt;/p&gt;
&lt;h2 id=&quot;从服务器进行基于日志点的复制链路的配置&quot;&gt;5. 从服务器进行基于日志点的复制链路的配置&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; change master to master_host='192.168.2.100',
        -&amp;gt; master_user='dba_repl',
        -&amp;gt; master_password='123456',
        -&amp;gt;MASTER_LOG_FILE='mysql-bin.000017',MASTER_LOG_POS=663;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;MASTER_LOG_FILE和MASTER_LOG_POS的值从全备文件中的CHANGE MASTER中获取&lt;/p&gt;
&lt;p&gt;以上复制链路的配置完成&lt;/p&gt;
&lt;p&gt;启动slave&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; start slave;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;检查是否启动成功状态&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; show slave status \G&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;显示&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Relay_Master_Log_File: mysql-bin.000017
Slave_IO_Running：Yes
Slave_SQL_Running: Yes&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;说明启动成功了，可以在主服务器上插入数据，在从服务上查看数据是否同步过来了&lt;/p&gt;

&lt;p&gt;虽然主从复制，增加了一个数据库副本，从数据库和主数据库的数据最终会是一致的&lt;br/&gt;之所以说是最终一致，因为mysql复制是异步的，正常情况下主从复制数据之间会有一个微小的延迟&lt;br/&gt;通过这个数据库副本看似解决了数据库单点问题，但并不完美&lt;br/&gt;因为这种架构下，如果主服务器宕机，需要手动切换从服务器，业务中断不能忍受，不能满足应用高可用的要求&lt;/p&gt;
&lt;p&gt;如果才能解决当master服务器宕机后，前端应用自动切换链接呢？&lt;/p&gt;
&lt;p&gt;下节再进行学习&lt;/p&gt;
</description>
<pubDate>Sun, 13 Jan 2019 06:08:00 +0000</pubDate>
<dc:creator>听风。</dc:creator>
<og:description>一. 单个数据库服务器的缺点 数据库服务器存在单点问题 数据库服务器资源无法满足增长的读写请求 高峰时数据库连接数经常超过上限 二. 如何解决单点问题 增加额外的数据库服务器，组建数据库集群 同一集群</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/huchong/p/10253522.html</dc:identifier>
</item>
<item>
<title>一个Python开源项目-哈勃沙箱源码剖析（下） - 七夜的故事</title>
<link>http://www.cnblogs.com/qiyeboy/p/10262441.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qiyeboy/p/10262441.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;在&lt;a href=&quot;https://www.cnblogs.com/qiyeboy/p/10222084.html&quot; target=&quot;_blank&quot;&gt;上一篇&lt;/a&gt;中，我们讲解了哈勃沙箱的技术点，详细分析了静态检测和动态检测的流程。本篇接着对动态检测的关键技术点进行分析，&lt;strong&gt;包括&lt;/strong&gt;&lt;strong&gt;strace，sysdig，volatility&lt;/strong&gt;。volatility的介绍不会太深入，内存取证这部分的研究还需要继续。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;&lt;strong&gt;strace机制&lt;/strong&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;上一篇讲到了strace和ltrace都是基于ptrace机制，但是对ptrace机制和strace/ltrace是如何利用ptrace监控系统调用，没有进行详细的讲解。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;那什么是ptrace机&lt;/strong&gt;&lt;strong&gt;制呢？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;ptrace机制是操作系统提供了一种标准的服务来让程序员实现对底层硬件和服务的控制。&lt;/p&gt;

&lt;p&gt;当一个程序需要作系统调用的时候，它将相关参数放进系统调用相关的寄存器，&lt;strong&gt;然后&lt;/strong&gt;&lt;strong&gt;调用软中断&lt;/strong&gt;&lt;strong&gt;0x80&lt;/strong&gt;，这个中断就像一个让程序得以接触到内核模式的窗口，&lt;strong&gt;程序将参数和系统调用号交给内核&lt;/strong&gt;，&lt;strong&gt;内核来完成系统调用的执行。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;br/&gt;ptrace会在什么时候出现呢？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在执行系统调用之前，内核会先检查当前进程是否处于被“跟踪”(traced)的状态。如果是的话，&lt;strong&gt;内核暂停当前进程&lt;/strong&gt;&lt;strong&gt;并将控制权交给跟踪进程&lt;/strong&gt;，使跟踪进程得以察看或者修改被跟踪进程的寄存器。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;strace&lt;/strong&gt;监控系统调用&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面就以strace为例，如下图所示,在第2步和第3步是关键。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/899843/201901/899843-20190113135716740-1690147290.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;strace使用ptrace机制来检测目标进程并“监听”该进程的系统调用，strace可以在&lt;/strong&gt;&lt;strong&gt;每次调用系统调用时中断跟踪的进程，捕获调用，解码它，然后继续执行跟踪的进程&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;大家可能知道，每次调用系统调用（例如，打开，读取，写入，关闭）时，都需要从用户级别到内核级别的转换 - 这称为上下文切换。这取决于CPU系列和型号，以不同的方式实现，但它往往复杂且相对较慢。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;sysdig机制&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;sysdig&lt;/strong&gt;&lt;strong&gt;是一个开源系统发掘工具&lt;/strong&gt;，用于系统级别的勘察和排障，可以看作system（系统）+dig（挖掘）的组合。我们可以把它看作一系列传统的 unix 系统工具的组合，主要包括：&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;4.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;strace：追踪某个进程产生和接收的系统调用。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;tcpdump：分析网络数据，监控原始网络通信。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;lsof：  列出打开的文件。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;top：监控系统性能工具。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;htop ：交互式的进程浏览器，可以用来替换 top 命令。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;iftop ：主要用来显示本机网络流量情况及各相互通信的流量集合。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;lua：一个小巧的脚本语言。该语言的设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;sysdig工作方式分成用户空间和内核空间两个部分，结构如下图所示（&lt;strong&gt;附件画图画的&lt;/strong&gt;）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/899843/201901/899843-20190113135819096-158177010.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;数据的捕获流程分为如下5部分&lt;/strong&gt;：&lt;/p&gt;
&lt;ol class=&quot;list-paddingleft-2&quot; readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;在内核有一个组件叫 sysdig-probe,也可以把它称为数据探头，它通过跟踪 linux 内核来进行数据抓获。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;事件缓冲器（event buffer）用来把存储器映射到用户空间。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;scap 组件：用来进行捕获控制和转储文件，以及数据的状态采集。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;sinsp 组件：用来进行事件分析、执行凿子（chisel），设置过滤和输出格式化。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;最后 sysdig 工具在命令行解析采集的数据。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;从整体架构上来看，&lt;strong&gt;sysdig与libpcap / tcpdump / wireshark的架构非常相似&lt;/strong&gt;，都是先捕获大量的数据，然后使用过滤器获取自己想要的数据。&lt;/p&gt;

&lt;p&gt;希望大家注意到一个问题， sysdig-probe从内核捕获的数据会非常大的，&lt;strong&gt;用户空间里的&lt;/strong&gt;&lt;strong&gt;scap&lt;/strong&gt;，&lt;strong&gt;sinsp&lt;/strong&gt;，&lt;strong&gt;sysdig组件能处理过来吗？假如处理不过来，sysdig会采用什么机制呢？sysdig会像strace一样放慢程序速度吗？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;答案是否定的。在这种情况下，事件缓冲区填满，sysdig-probe开始丢弃传入的事件。因此，将丢失一些跟踪信息，但机器上运行的其他进程不会减慢速度，这是sysdig架构的关键优势,&lt;strong&gt;意味着跟踪开销可预测&lt;/strong&gt;。既然sysdig这么强大，下面讲解一下sysdig的基本用法。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;sysdig 基本用法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我以ubuntu系统中的操作为例，直接在shell输入sudo sysdig 就能开始捕获系统信息，执行后你会看到终端有持续不断的输出流。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;$ sudo sysdig&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;因为系统每时每刻都有大量的系统调用产生，这样是没办法看清更无法分析输出信息的，可以先使用 ctrl + c 来退出命令。输出如下图所示：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/899843/201901/899843-20190113135853622-1762764258.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;先来解释一下它的输出格式：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/899843/201901/899843-20190113135934337-306520849.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;所有的输入都是按照行来分割的，每行都是一条记录，由多个列组成，默认的格式是：&lt;/p&gt;

&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;%evt.num %evt.outputtime %evt.cpu %proc.name (%thread.tid) %evt.dir %evt.type %evt.info&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;各个字段的含义如下&lt;/strong&gt;：&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;5.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;evt.num： 递增的事件号&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;evt.time： 事件发生的时间&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;evt.cpu： 事件被捕获时所在的 CPU，也就是系统调用是在哪个 CPU 执行的。比较上面的例子中，值 0 代表机器的第一个 CPU&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;proc.name： 生成事件的进程名字，也就是哪个进程在运行&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;thread.tid： 线程的 id，如果是单线程的程序，这也是进程的 pid&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;evt.dir： 事件的方向（direction），&amp;gt; 代表进入事件，&amp;lt; 代表退出事件&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;evt.type： 事件的名称，比如 open、stat等，一般是系统调用&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;evt.args： 事件的参数。如果是系统调用，这些对应着系统调用的参数&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;过滤&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;完整的 sysdig 使用方法：&lt;/p&gt;

&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;sysdig [option]...  [filter]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;sysdig 的过滤功能很强大，不仅支持的过滤项很多，而且还能够自由地进行逻辑组合。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;过滤项&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;sysdig 的过滤器也是分成不同类别的，比如:&lt;/p&gt;

&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;4&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;fd: 对文件描述符（file descriptor）进行过滤，比如 fd 标号（fd.num）、fd 名字（fd.name）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;process: 进程信息的过滤，比如进程 id（proc.id）、进程名（proc.name）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;evt: 事件信息的过滤，比如事件编号、事件名&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;user: 用户信息的过滤，比如用户 id、用户名、用户 home 目录、用户的登录 shell（user.shell）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;syslog: 系统日志的过滤，比如日志的严重程度、日志的内容&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;fdlist: poll event 的文件描述符的过滤&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;完整的过滤器列表可以使用&lt;strong&gt;sysdig -l&lt;/strong&gt;来查看，比如可以&lt;strong&gt;查看&lt;/strong&gt;&lt;strong&gt;建立 TCP 连接&lt;/strong&gt;&lt;strong&gt;的事件&lt;/strong&gt;：&lt;/p&gt;

&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;sudo sysdig evt.type=accept&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;过滤器组合&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;过滤器除了直接的相等比较之外，还有其他操作符，包括&lt;strong&gt;=、!=、&amp;gt;=、&amp;gt;、&amp;lt;、&amp;lt;=、contains、in 和 exists&lt;/strong&gt;，&lt;/p&gt;
&lt;p&gt;比如：&lt;/p&gt;

&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;$ sysdig fd.name contains /etc&lt;/p&gt;
&lt;p&gt;$ sysdig &quot;evt.type in ( 'select', 'poll' )&quot;&lt;/p&gt;
&lt;p&gt;$ sysdig proc.name exists&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;多个过滤条件还可以通过 and、or 和 not 进行逻辑组合，比如：&lt;/p&gt;

&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;$ sysdig &quot;not (fd.name contains /proc or fd.name contains /dev)&quot;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;volatility简单描述&lt;/h2&gt;
&lt;p&gt; 到这发现已经写了4千多字，volatility这里简要描述一下，详细的分析，等我之后对内存取证有了一个整体的框架再说。&lt;/p&gt;

&lt;p&gt; Volatility是一个Python编写的跨平台,用于内存分析的法证工具,其目的是为了在数据犯罪中提取易失性数据 ,也可以用来进行Rootkit的检测和协助清除。Volatility分析主要依赖的是profile文件，profile文件是由两部分合成。以linux为例，大致如下：&lt;/p&gt;

&lt;ol class=&quot;list-paddingleft-2&quot; readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt; Linux的System.map文件列出了详细的系统调用（syscall）,而kernel-header源码通过dwarfdump生成的module.dwarf文件中会包含很多内核数据结构,将以上2个文件打包为profile文件。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;再用这个profile文件解析dump下来的物理内存,就很容易找到植入Rootkit的机器活动时的进程(linux_psaux)、网络通信(linux_netstat)、活动文件(linux_lsof)、驱动模块(linux_lsmod)等等&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;div id=&quot;cnblogs_post_body&quot; class=&quot;blogpost-body cnblogs-markdown&quot; readability=&quot;57&quot;&gt;
&lt;h2 id=&quot;最后&quot;&gt;最后&lt;/h2&gt;
&lt;p&gt;关注公众号：&lt;strong&gt;七夜安全博客&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/899843/201604/899843-20160412112303145-1979448153.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;回复【1】：领取 Python数据分析 教程大礼包&lt;/li&gt;
&lt;li&gt;回复【2】：领取 Python Flask 全套教程&lt;/li&gt;
&lt;li&gt;回复【3】：领取 某学院 机器学习 教程&lt;/li&gt;
&lt;li&gt;回复【4】：领取 爬虫 教程&lt;/li&gt;
&lt;li&gt;回复【5】：领取 编译原理 教程 &lt;/li&gt;
&lt;li&gt;回复【6】：领取 渗透测试 教程 &lt;/li&gt;
&lt;li&gt;回复【7】：领取 人工智能数学基础 教程&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;p&gt;本文章属于原创作品,欢迎大家转载分享，禁止修改文章的内容。尊重原创,转载请注明来自:七夜的故事 http://www.cnblogs.com/qiyeboy/&lt;/p&gt;

</description>
<pubDate>Sun, 13 Jan 2019 06:03:00 +0000</pubDate>
<dc:creator>七夜的故事</dc:creator>
<og:description>前言 在上一篇中，我们讲解了哈勃沙箱的技术点，详细分析了静态检测和动态检测的流程。本篇接着对动态检测的关键技术点进行分析，包括strace，sysdig，volatility。volatility的介</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qiyeboy/p/10262441.html</dc:identifier>
</item>
<item>
<title>iOS自动化探索（六）自动化测试框架pytest - fixtures - 周希</title>
<link>http://www.cnblogs.com/zhouxihi/p/10254554.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhouxihi/p/10254554.html</guid>
<description>&lt;h3&gt;Fixture介绍&lt;/h3&gt;
&lt;div readability=&quot;10&quot;&gt;
&lt;p&gt;fixture是pytest特有的功能，它用pytest.fixture标识，定义在函数前面。在编写测试函数的时候，可以将此函数名称做为传入参数，pytest将会以依赖注入方式，将该函数的返回值作为测试函数的传入参数。&lt;br/&gt;fixture有明确的名字，在其他函数，模块，类或整个工程调用它时会被激活。&lt;br/&gt;fixture是基于模块来执行的，每个fixture的名字就可以触发一个fixture的函数，它自身也可以调用其他的fixture。&lt;br/&gt;我们可以把fixture看做是资源，在你的测试用例执行之前需要去配置这些资源，执行完后需要去释放资源。比如module类型的fixture，适合于那些许多测试用例都只需要执行一次的操作。&lt;br/&gt;fixture还提供了参数化功能，根据配置和不同组件来选择不同的参数。&lt;br/&gt;fixture主要的目的是为了提供一种可靠和可重复性的手段去运行那些最基本的测试内容。比如在测试网站的功能时，每个测试用例都要登录和退出，利用fixture就可以只做一次，否则每个测试用例都要做这两步也是冗余。&lt;/p&gt;
&lt;/div&gt;

&lt;div readability=&quot;27.5&quot;&gt;
&lt;h3&gt;Fixture基础实例&lt;/h3&gt;
&lt;p&gt;把一个函数定义为Fixture很简单，只要在函数声明之前加上“@pytest.fixture”。其他函数要来调用这个Fixture，只用把它当做一个输入的参数即可。&lt;br/&gt;演示代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import pytest

@pytest.fixture()
def before():
    print &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\nBefore each test&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;

def test_1(before):
    print &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test_1()&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;

def test_2(before):
    print &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test_2()&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    assert &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;    # For test purpose
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
(wda_python) bash-&lt;span&gt;3.2&lt;/span&gt;$ pytest -&lt;span&gt;q test_smtpsimple.py 
.F                                                                                                                                 [&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;%&lt;span&gt;]
&lt;/span&gt;================================================================ FAILURES ================================================================&lt;span&gt;
_________________________________________________________________ test_2 _________________________________________________________________

before &lt;/span&gt;=&lt;span&gt; None

    def test_2(before):
        print &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test_2()&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&amp;gt;       assert &lt;span&gt;0&lt;/span&gt;&lt;span&gt;    # For test purpose
E       assert &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;

test_smtpsimple.py:&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;&lt;span&gt;: AssertionError
&lt;/span&gt;--------------------------------------------------------- Captured stdout setup ----------------------------------------------------------&lt;span&gt;

Before each test
&lt;/span&gt;---------------------------------------------------------- Captured stdout call ----------------------------------------------------------&lt;span&gt;
test_2()
&lt;/span&gt;&lt;span&gt;1&lt;/span&gt; failed, &lt;span&gt;1&lt;/span&gt; passed &lt;span&gt;in&lt;/span&gt; &lt;span&gt;0.09&lt;/span&gt;&lt;span&gt; seconds
(wda_python) bash&lt;/span&gt;-&lt;span&gt;3.2&lt;/span&gt;$ 
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;调用fixture的三种方式&lt;/h3&gt;
&lt;h4&gt;1. 在测试用例中直接调用它，例如上面的基础实例&lt;/h4&gt;
&lt;h4&gt;2. 用fixture decorator调用fixture&lt;/h4&gt;
&lt;p&gt;可以用以下三种不同的方式来写，我只变化了函数名字和类名字，内容没有变。第一种是每个函数前声明，第二种是封装在类里，类里的每个成员函数声明，第三种是封装在类里在前声明。在可以看到3中不同方式的运行结果都是一样。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import pytest

@pytest.fixture()
def before():
    print &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\nBefore each test&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;

@pytest.mark.usefixtures(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;before&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
def test_1():
    print &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test_1()&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;

@pytest.mark.usefixtures(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;before&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
def test_2():
    print &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test_2()&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;

&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test1:
    @pytest.mark.usefixtures(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;before&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    def test_3(self):
        print &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test_3()&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;

    @pytest.mark.usefixtures(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;before&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    def test_4(self):
        print &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test_4()&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;

@pytest.mark.usefixtures(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;before&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test2:
    def test_5(self):
        print &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test_5()&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;

    def test_6(self):
        print &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test_6()&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们用“pytest -v -s test_module.py”运行详细模式测试并打印输出，运行结果:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
================================================== test session starts ===================================================&lt;span&gt;
platform darwin &lt;/span&gt;-- Python &lt;span&gt;2.7&lt;/span&gt;.&lt;span&gt;15&lt;/span&gt;, pytest-&lt;span&gt;4.1&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;, py-&lt;span&gt;1.7&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;, pluggy-&lt;span&gt;0.8&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt; -- /Users/jackey/Documents/iOS/code/iOS-Auto/MyPyEnv/wda_python/bin/python2.&lt;span&gt;7&lt;/span&gt;&lt;span&gt;
cachedir: .pytest_cache
rootdir: &lt;/span&gt;/Users/jackey/Documents/iOS/code/iOS-Auto/&lt;span&gt;Agent_Test, inifile:
collected &lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt; items                                                                                                        

test_smtpsimple.py::test_1 
Before each test
test_1()
PASSED
test_smtpsimple.py::test_2 
Before each test
test_2()
PASSED
test_smtpsimple.py::Test1::test_3 
Before each test
test_3()
PASSED
test_smtpsimple.py::Test1::test_4 
Before each test
test_4()
PASSED
test_smtpsimple.py::Test2::test_5 
Before each test
test_5()
PASSED
test_smtpsimple.py::Test2::test_6 
Before each test
test_6()
PASSED

&lt;/span&gt;================================================ &lt;span&gt;6&lt;/span&gt; passed &lt;span&gt;in&lt;/span&gt; &lt;span&gt;0.06&lt;/span&gt; seconds ================================================&lt;span&gt;
(wda_python) bash&lt;/span&gt;-&lt;span&gt;3.2&lt;/span&gt;$ 
&lt;/pre&gt;&lt;/div&gt;
&lt;div readability=&quot;11&quot;&gt;
&lt;h4&gt; &lt;/h4&gt;
&lt;div readability=&quot;30&quot;&gt;
&lt;h4&gt;3. pytest fixture scope&lt;/h4&gt;
&lt;p&gt;fixture在创建的时候有一个关键字参数scope: &lt;/p&gt;
&lt;p&gt;&lt;code&gt;scope='session'&lt;/code&gt;，它将只运行一次，不管它在哪里定义。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;scope='class'&lt;/code&gt;表示每个类会运行一次。&lt;/p&gt;
&lt;p&gt;scope='module'表示每个module的所有test只运行一次。&lt;/p&gt;
&lt;p&gt;scope='function'表示每个test都运行， scope的默认值&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1048098/201901/1048098-20190113114155072-824174086.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;实例代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import pytest
import time

@pytest.fixture(scope&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;module&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
def mod_header(request):
    print &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n------------------&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    print &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;module   : %s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; request.module.__name__
    print &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;-------------------&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;

@pytest.fixture(scope&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
def func_header(request):
    print &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n------------------&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    print &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;function:    %s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; request.module.__name__
    print &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;time:        %s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; time.asctime()
    print &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;-------------------&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;

def test_1(mod_header,func_header):
    print &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;in test_1()&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;

def test_2(mod_header,func_header):
    print &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;in test_2()&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
================================================== test session starts ===================================================&lt;span&gt;
platform darwin &lt;/span&gt;-- Python &lt;span&gt;2.7&lt;/span&gt;.&lt;span&gt;15&lt;/span&gt;, pytest-&lt;span&gt;4.1&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;, py-&lt;span&gt;1.7&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;, pluggy-&lt;span&gt;0.8&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt; -- /Users/jackey/Documents/iOS/code/iOS-Auto/MyPyEnv/wda_python/bin/python2.&lt;span&gt;7&lt;/span&gt;&lt;span&gt;
cachedir: .pytest_cache
rootdir: &lt;/span&gt;/Users/jackey/Documents/iOS/code/iOS-Auto/&lt;span&gt;Agent_Test, inifile:
collected &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt; items                                                                                                        

test_smtpsimple.py::test_1 
&lt;/span&gt;------------------&lt;span&gt;
module   : test_smtpsimple
&lt;/span&gt;-------------------

------------------&lt;span&gt;
function:    test_smtpsimple
time:        Sun Jan &lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;12&lt;/span&gt;:&lt;span&gt;19&lt;/span&gt;:&lt;span&gt;25&lt;/span&gt; &lt;span&gt;2019&lt;/span&gt;
-------------------
&lt;span&gt;in&lt;/span&gt;&lt;span&gt; test_1()
PASSED
test_smtpsimple.py::test_2 
&lt;/span&gt;------------------&lt;span&gt;
function:    test_smtpsimple
time:        Sun Jan &lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;12&lt;/span&gt;:&lt;span&gt;19&lt;/span&gt;:&lt;span&gt;25&lt;/span&gt; &lt;span&gt;2019&lt;/span&gt;
-------------------
&lt;span&gt;in&lt;/span&gt;&lt;span&gt; test_2()
PASSED

&lt;/span&gt;================================================ &lt;span&gt;2&lt;/span&gt; passed &lt;span&gt;in&lt;/span&gt; &lt;span&gt;0.04&lt;/span&gt; seconds ================================================&lt;span&gt;
(wda_python) bash&lt;/span&gt;-&lt;span&gt;3.2&lt;/span&gt;$ 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到module在整个module中只执行了一次&lt;/p&gt;

&lt;h4&gt;4. 用autos调用fixture&lt;/h4&gt;
&lt;div readability=&quot;13&quot;&gt;
&lt;p&gt;ixture decorator一个optional的参数是autouse, 默认设置为False。&lt;br/&gt;当默认为False，就可以选择用上面两种方式来试用fixture。&lt;br/&gt;当设置为True时，在一个session内的所有的test都会自动调用这个fixture。&lt;br/&gt;权限大，责任也大，所以用该功能时也要谨慎小心。&lt;/p&gt;
比如上面的例子，我们可以这样写效果也是一样的：&lt;/div&gt;
&lt;div readability=&quot;13&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import pytest
import time

@pytest.fixture(scope&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;module&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, autouse=&lt;span&gt;True)
def mod_header(request):
    print &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n------------------&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    print &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;module   : %s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; request.module.__name__
    print &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;-------------------&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;

@pytest.fixture(scope&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, autouse=&lt;span&gt;True)
def func_header(request):
    print &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n------------------&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    print &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;function:    %s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; request.module.__name__
    print &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;time:        %s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; time.asctime()
    print &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;-------------------&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;

def test_1():
    print &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;in test_1()&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;

def test_2():
    print &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;in test_2()&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
================================================== test session starts ===================================================&lt;span&gt;
platform darwin &lt;/span&gt;-- Python &lt;span&gt;2.7&lt;/span&gt;.&lt;span&gt;15&lt;/span&gt;, pytest-&lt;span&gt;4.1&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;, py-&lt;span&gt;1.7&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;, pluggy-&lt;span&gt;0.8&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt; -- /Users/jackey/Documents/iOS/code/iOS-Auto/MyPyEnv/wda_python/bin/python2.&lt;span&gt;7&lt;/span&gt;&lt;span&gt;
cachedir: .pytest_cache
rootdir: &lt;/span&gt;/Users/jackey/Documents/iOS/code/iOS-Auto/&lt;span&gt;Agent_Test, inifile:
collected &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt; items                                                                                                        

test_smtpsimple.py::test_1 
&lt;/span&gt;------------------&lt;span&gt;
module   : test_smtpsimple
&lt;/span&gt;-------------------

------------------&lt;span&gt;
function:    test_smtpsimple
time:        Sun Jan &lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;12&lt;/span&gt;:&lt;span&gt;34&lt;/span&gt;:&lt;span&gt;59&lt;/span&gt; &lt;span&gt;2019&lt;/span&gt;
-------------------
&lt;span&gt;in&lt;/span&gt;&lt;span&gt; test_1()
PASSED
test_smtpsimple.py::test_2 
&lt;/span&gt;------------------&lt;span&gt;
function:    test_smtpsimple
time:        Sun Jan &lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;12&lt;/span&gt;:&lt;span&gt;34&lt;/span&gt;:&lt;span&gt;59&lt;/span&gt; &lt;span&gt;2019&lt;/span&gt;
-------------------
&lt;span&gt;in&lt;/span&gt;&lt;span&gt; test_2()
PASSED

&lt;/span&gt;================================================ &lt;span&gt;2&lt;/span&gt; passed &lt;span&gt;in&lt;/span&gt; &lt;span&gt;0.04&lt;/span&gt; seconds ================================================&lt;span&gt;
(wda_python) bash&lt;/span&gt;-&lt;span&gt;3.2&lt;/span&gt;$ 
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;5. fixture 返回值&lt;/h3&gt;
&lt;/div&gt;
&lt;div readability=&quot;18&quot;&gt;
&lt;div readability=&quot;12&quot;&gt;
&lt;p&gt;在上面的例子中，fixture返回值都是默认None，我们可以选择让fixture返回我们需要的东西。如果你的fixture需要配置一些数据，读个文件，或者连接一个数据库，那么你可以让fixture返回这些数据或资源。&lt;/p&gt;
&lt;p&gt;如何带参数，可以把参数赋值给params，默认是None。对于param里面的每个值，fixture都会去调用执行一次，就像执行for循环一样把params里的值遍历一次。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import pytest

@pytest.fixture(&lt;/span&gt;&lt;span&gt;params&lt;/span&gt;=[&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;&lt;span&gt;])
def test_data(request):
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; request.param

def test_not_2(test_data):
    print &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test_data: %s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; test_data
    assert test_data &lt;/span&gt;!= &lt;span&gt;2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
========================================================== test session starts ===========================================================&lt;span&gt;
platform darwin &lt;/span&gt;-- Python &lt;span&gt;2.7&lt;/span&gt;.&lt;span&gt;15&lt;/span&gt;, pytest-&lt;span&gt;4.1&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;, py-&lt;span&gt;1.7&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;, pluggy-&lt;span&gt;0.8&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt; -- /Users/jackey/Documents/iOS/code/iOS-Auto/MyPyEnv/wda_python/bin/python2.&lt;span&gt;7&lt;/span&gt;&lt;span&gt;
cachedir: .pytest_cache
rootdir: &lt;/span&gt;/Users/jackey/Documents/iOS/code/iOS-Auto/&lt;span&gt;Agent_Test, inifile:
collected &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt; items                                                                                                                        

test_smtpsimple.py::test_not_2[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;] test_data: &lt;span&gt;1&lt;/span&gt;&lt;span&gt;
PASSED
test_smtpsimple.py::test_not_2[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;] test_data: &lt;span&gt;2&lt;/span&gt;&lt;span&gt;
FAILED
test_smtpsimple.py::test_not_2[&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;] test_data: &lt;span&gt;3&lt;/span&gt;&lt;span&gt;
PASSED

&lt;/span&gt;================================================================ FAILURES ================================================================&lt;span&gt;
_____________________________________________________________ test_not_2[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;] ______________________________________________________________

test_data &lt;/span&gt;= &lt;span&gt;2&lt;/span&gt;&lt;span&gt;

    def test_not_2(test_data):
        print &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test_data: %s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; test_data
&lt;/span&gt;&amp;gt;       assert test_data != &lt;span&gt;2&lt;/span&gt;&lt;span&gt;
E       assert &lt;/span&gt;&lt;span&gt;2&lt;/span&gt; != &lt;span&gt;2&lt;/span&gt;&lt;span&gt;

test_smtpsimple.py:&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;&lt;span&gt;: AssertionError
&lt;/span&gt;=================================================== &lt;span&gt;1&lt;/span&gt; failed, &lt;span&gt;2&lt;/span&gt; passed &lt;span&gt;in&lt;/span&gt; &lt;span&gt;0.09&lt;/span&gt; seconds ===================================================&lt;span&gt;
(wda_python) bash&lt;/span&gt;-&lt;span&gt;3.2&lt;/span&gt;$ 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到test_not_2里面把用test_data里面定义的3个参数运行里三次。&lt;/p&gt;


&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Sun, 13 Jan 2019 05:45:00 +0000</pubDate>
<dc:creator>周希</dc:creator>
<og:description>Fixture介绍 fixture是pytest特有的功能，它用pytest.fixture标识，定义在函数前面。在编写测试函数的时候，可以将此函数名称做为传入参数，pytest将会以依赖注入方式，将</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhouxihi/p/10254554.html</dc:identifier>
</item>
<item>
<title>003.Keepalived搭建LVS高可用集群 - 木二</title>
<link>http://www.cnblogs.com/itzgr/p/10262402.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/itzgr/p/10262402.html</guid>
<description>&lt;h2 align=&quot;left&quot;&gt;一 基础环境&lt;/h2&gt;
&lt;h3 align=&quot;left&quot;&gt;1.1 IP规划&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;OS：CentOS 6.8 64位&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;table&gt;&lt;colgroup&gt;&lt;col width=&quot;142&quot;/&gt;&lt;col width=&quot;169&quot;/&gt;&lt;col width=&quot;179&quot;/&gt;&lt;col width=&quot;70&quot;/&gt;&lt;/colgroup&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td align=&quot;center&quot; data-cell-id=&quot;8064-1513237250546-cell-0-0&quot;&gt;
&lt;p&gt;&lt;span&gt;节点类型&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot; data-cell-id=&quot;8064-1513237250546-cell-0-1&quot;&gt;
&lt;p&gt;&lt;span&gt;IP规划&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot; data-cell-id=&quot;8064-1513237250546-cell-0-2&quot;&gt;
&lt;p&gt;&lt;span&gt;主机名&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot; data-cell-id=&quot;8064-1513237250546-cell-0-3&quot;&gt;
&lt;p&gt;&lt;span&gt;类型&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td rowspan=&quot;3&quot; colspan=&quot;1&quot; align=&quot;center&quot; data-cell-id=&quot;8064-1513237250546-cell-1-0&quot;&gt;
&lt;p&gt;&lt;span&gt;主 Director Server&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot; data-cell-id=&quot;8064-1513237250546-cell-1-1&quot;&gt;
&lt;p&gt;&lt;span&gt;eth0：172.24.8.10&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot; data-cell-id=&quot;8064-1513237250546-cell-1-2&quot;&gt;
&lt;p&gt;&lt;span&gt;DR1&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot; data-cell-id=&quot;8064-1513237250546-cell-1-3&quot;&gt;
&lt;p&gt;&lt;span&gt;公共IP&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;center&quot; data-cell-id=&quot;8064-1513237250546-cell-2-1&quot;&gt;
&lt;p&gt;&lt;span&gt;eth1：192.168.56.100&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot; data-cell-id=&quot;8064-1513237250546-cell-2-2&quot;&gt;
&lt;p&gt;&lt;span&gt;心跳&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot; data-cell-id=&quot;8064-1513237250546-cell-2-3&quot;&gt;
&lt;p&gt;&lt;span&gt;私有IP&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;center&quot; data-cell-id=&quot;8064-1513237250546-cell-3-1&quot;&gt;
&lt;p&gt;&lt;span&gt;eth0:0：172.24.8.100&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot; data-cell-id=&quot;8064-1513237250546-cell-3-2&quot;&gt;
&lt;p&gt;&lt;span&gt;无&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot; data-cell-id=&quot;8064-1513237250546-cell-3-3&quot;&gt;
&lt;p&gt;&lt;span&gt;虚拟IP&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td rowspan=&quot;2&quot; colspan=&quot;1&quot; align=&quot;center&quot; data-cell-id=&quot;8064-1513237250546-cell-4-0&quot;&gt;
&lt;p&gt;&lt;span&gt;主 Director Server&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot; data-cell-id=&quot;8064-1513237250546-cell-4-1&quot;&gt;
&lt;p&gt;&lt;span&gt;eth0：172.24.8.11&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot; data-cell-id=&quot;8064-1513237250546-cell-4-2&quot;&gt;
&lt;p&gt;&lt;span&gt;DR2&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot; data-cell-id=&quot;8064-1513237250546-cell-4-3&quot;&gt;
&lt;p&gt;&lt;span&gt;公共IP&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;center&quot; data-cell-id=&quot;8064-1513237250546-cell-5-1&quot;&gt;
&lt;p&gt;&lt;span&gt;eth1：192.168.56.101&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot; data-cell-id=&quot;8064-1513237250546-cell-5-2&quot;&gt;
&lt;p&gt;&lt;span&gt;心跳&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot; data-cell-id=&quot;8064-1513237250546-cell-5-3&quot;&gt;
&lt;p&gt;&lt;span&gt;私有IP&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td rowspan=&quot;2&quot; colspan=&quot;1&quot; align=&quot;center&quot; data-cell-id=&quot;8064-1513237250546-cell-6-0&quot;&gt;
&lt;p&gt;&lt;span&gt;Real Server 1&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot; data-cell-id=&quot;8064-1513237250546-cell-6-1&quot;&gt;
&lt;p&gt;&lt;span&gt;eth0：172.24.8.12&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot; data-cell-id=&quot;8064-1513237250546-cell-6-2&quot;&gt;
&lt;p&gt;&lt;span&gt;rs1&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot; data-cell-id=&quot;8064-1513237250546-cell-6-3&quot;&gt;
&lt;p&gt;&lt;span&gt;公共IP&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;center&quot; data-cell-id=&quot;8064-1513237250546-cell-7-1&quot;&gt;
&lt;p&gt;&lt;span&gt;lo:0：172.24.8.100&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot; data-cell-id=&quot;8064-1513237250546-cell-7-2&quot;&gt;
&lt;p&gt;&lt;span&gt;无&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot; data-cell-id=&quot;8064-1513237250546-cell-7-3&quot;&gt;
&lt;p&gt;&lt;span&gt;虚拟IP&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td rowspan=&quot;2&quot; colspan=&quot;1&quot; align=&quot;center&quot; data-cell-id=&quot;8064-1513237250546-cell-8-0&quot;&gt;
&lt;p&gt;&lt;span&gt;Real Server 1&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot; data-cell-id=&quot;8064-1513237250546-cell-8-1&quot;&gt;
&lt;p&gt;&lt;span&gt;eth0：172.24.8.13&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot; data-cell-id=&quot;8064-1513237250546-cell-8-2&quot;&gt;
&lt;p&gt;&lt;span&gt;rs2&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot; data-cell-id=&quot;8064-1513237250546-cell-8-3&quot;&gt;
&lt;p&gt;&lt;span&gt;公共IP&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;center&quot; data-cell-id=&quot;8064-1513237250546-cell-9-1&quot;&gt;
&lt;p&gt;&lt;span&gt;lo:0：172.24.8.100&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot; data-cell-id=&quot;8064-1513237250546-cell-9-2&quot;&gt;
&lt;p&gt;&lt;span&gt;无&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot; data-cell-id=&quot;8064-1513237250546-cell-9-3&quot;&gt;
&lt;p&gt;&lt;span&gt;虚拟IP&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;h3 align=&quot;left&quot;&gt;1.2 架构规划&lt;/h3&gt;
&lt;div align=&quot;left&quot;&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/680719/201901/680719-20190113133827171-750346518.png&quot;&gt;&lt;img title=&quot;01&quot; src=&quot;https://img2018.cnblogs.com/blog/680719/201901/680719-20190113133828275-507287338.png&quot; alt=&quot;01&quot; width=&quot;518&quot; height=&quot;414&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;h2 align=&quot;left&quot;&gt;二 高可用LVS负载均衡集群部署&lt;/h2&gt;
&lt;h3 align=&quot;left&quot;&gt;2.1 NTP部署&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;操作略，具体可参考N01.1.1-常见服务《NTP》。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;注意：为了保证集群的稳定性，强烈建议在所有节点均部署NTP同步服务，保证所有时钟一致。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;2.2 部署httpd集群&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; [root@RServer01 ~]# yum -y install httpd
&lt;span&gt;  2&lt;/span&gt; [root@RServer01 ~]# service iptables stop
&lt;span&gt;  3&lt;/span&gt; [root@RServer01 ~]# chkconfig iptables off
&lt;span&gt;  4&lt;/span&gt; [root@RServer01 ~]# vi /etc/selinux/config
&lt;span&gt;  5&lt;/span&gt; SELINUX=disabled
&lt;span&gt;  6&lt;/span&gt; [root@master ~]# setenforce 0                                   #关闭SELinux及防火墙
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;注意：后端所有Real服务器节点都需要安装，用于模拟测试。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;建议：为了测试方便，建议所有节点关闭防火墙和SELinux，若未关闭防火墙也可通过下列方式放通：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; firewall-cmd --permanent–-add-service=keepalived
&lt;span&gt;  2&lt;/span&gt; firewall-cmd --reload
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 align=&quot;left&quot;&gt;2.3 安装Keepalived&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; [root@lvsmaster ~]# yum -y install gcc gcc-c++ make kernel-devel kernel-tools kernel-tools-libs kernel libnl libnl-devel libnfnetlink-devel openssl-devel wget openssh-clients            #安装基础环境及依赖
&lt;span&gt;  2&lt;/span&gt; [root@lvsmaster ~]# ln -s /usr/src/kernels/`uname -r` /usr/src/linux
&lt;span&gt;  3&lt;/span&gt; [root@lvsmaster ~]# wget http://www.keepalived.org/software/keepalived-1.3.6.tar.gz
&lt;span&gt;  4&lt;/span&gt; [root@lvsmaster ~]# tar -zxvf keepalived-1.3.6.tar.gz          #编译安装Keepalived
&lt;span&gt;  5&lt;/span&gt; [root@lvsmaster ~]# cd keepalived-1.3.6/
&lt;span&gt;  6&lt;/span&gt; [root@lvsmaster keepalived-1.3.6]# ./configure --prefix=/usr/local/keepalived
&lt;span&gt;  7&lt;/span&gt; [root@Master keepalived-1.3.9]# make &amp;amp;&amp;amp; make install
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;注意：CentOS6.8安装高于1.3.6版本会出现未知错误。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;2.4 添加启动相关服务&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; [root@lvsmaster ~]# mkdir /etc/keepalived
&lt;span&gt;  2&lt;/span&gt; [root@lvsmaster ~]# cp /usr/local/keepalived/etc/keepalived/keepalived.conf /etc/keepalived/
&lt;span&gt;  3&lt;/span&gt; [root@lvsmaster ~]# cp /usr/local/keepalived/etc/sysconfig/keepalived /etc/sysconfig/
&lt;span&gt;  4&lt;/span&gt; [root@lvsmaster ~]# cp /usr/local/keepalived/sbin/keepalived /usr/sbin/
&lt;span&gt;  5&lt;/span&gt; [root@lvsmaster ~]# vi /etc/init.d/keepalived          #创建Keepalived启动脚本，如附件
&lt;span&gt;  6&lt;/span&gt; #!/bin/sh
&lt;span&gt;  7&lt;/span&gt; #
&lt;span&gt;  8&lt;/span&gt; # keepalived   High Availability monitor built upon LVS and VRRP
&lt;span&gt;  9&lt;/span&gt; #
&lt;span&gt; 10&lt;/span&gt; # chkconfig:   - 86 14
&lt;span&gt; 11&lt;/span&gt; # description: Robust keepalive facility to the Linux Virtual Server project \
&lt;span&gt; 12&lt;/span&gt; #              with multilayer TCP/IP stack checks.
&lt;span&gt; 13&lt;/span&gt; 
&lt;span&gt; 14&lt;/span&gt; ### BEGIN INIT INFO
&lt;span&gt; 15&lt;/span&gt; # Provides: keepalived
&lt;span&gt; 16&lt;/span&gt; # Required-Start: $local_fs $network $named $syslog
&lt;span&gt; 17&lt;/span&gt; # Required-Stop: $local_fs $network $named $syslog
&lt;span&gt; 18&lt;/span&gt; # Should-Start: smtpdaemon httpd
&lt;span&gt; 19&lt;/span&gt; # Should-Stop: smtpdaemon httpd
&lt;span&gt; 20&lt;/span&gt; # Default-Start:
&lt;span&gt; 21&lt;/span&gt; # Default-Stop: 0 1 2 3 4 5 6
&lt;span&gt; 22&lt;/span&gt; # Short-Description: High Availability monitor built upon LVS and VRRP
&lt;span&gt; 23&lt;/span&gt; # Description:       Robust keepalive facility to the Linux Virtual Server
&lt;span&gt; 24&lt;/span&gt; #                    project with multilayer TCP/IP stack checks.
&lt;span&gt; 25&lt;/span&gt; ### END INIT INFO
&lt;span&gt; 26&lt;/span&gt; 
&lt;span&gt; 27&lt;/span&gt; # Source function library.
&lt;span&gt; 28&lt;/span&gt; . /etc/rc.d/init.d/functions
&lt;span&gt; 29&lt;/span&gt; 
&lt;span&gt; 30&lt;/span&gt; exec=&quot;/usr/sbin/keepalived&quot;
&lt;span&gt; 31&lt;/span&gt; prog=&quot;keepalived&quot;
&lt;span&gt; 32&lt;/span&gt; config=&quot;/etc/keepalived/keepalived.conf&quot;
&lt;span&gt; 33&lt;/span&gt; 
&lt;span&gt; 34&lt;/span&gt; [ -e /etc/sysconfig/$prog ] &amp;amp;&amp;amp; . /etc/sysconfig/$prog
&lt;span&gt; 35&lt;/span&gt; 
&lt;span&gt; 36&lt;/span&gt; lockfile=/var/lock/subsys/keepalived
&lt;span&gt; 37&lt;/span&gt; 
&lt;span&gt; 38&lt;/span&gt; start() {
&lt;span&gt; 39&lt;/span&gt;     [ -x $exec ] || exit 5
&lt;span&gt; 40&lt;/span&gt;     [ -e $config ] || exit 6
&lt;span&gt; 41&lt;/span&gt;     echo -n $&quot;Starting $prog: &quot;
&lt;span&gt; 42&lt;/span&gt;     daemon $exec $KEEPALIVED_OPTIONS
&lt;span&gt; 43&lt;/span&gt;     retval=$?
&lt;span&gt; 44&lt;/span&gt;     echo
&lt;span&gt; 45&lt;/span&gt;     [ $retval -eq 0 ] &amp;amp;&amp;amp; touch $lockfile
&lt;span&gt; 46&lt;/span&gt;     return $retval
&lt;span&gt; 47&lt;/span&gt; }
&lt;span&gt; 48&lt;/span&gt; 
&lt;span&gt; 49&lt;/span&gt; stop() {
&lt;span&gt; 50&lt;/span&gt;     echo -n $&quot;Stopping $prog: &quot;
&lt;span&gt; 51&lt;/span&gt;     killproc $prog
&lt;span&gt; 52&lt;/span&gt;     retval=$?
&lt;span&gt; 53&lt;/span&gt;     echo
&lt;span&gt; 54&lt;/span&gt;     [ $retval -eq 0 ] &amp;amp;&amp;amp; rm -f $lockfile
&lt;span&gt; 55&lt;/span&gt;     return $retval
&lt;span&gt; 56&lt;/span&gt; }
&lt;span&gt; 57&lt;/span&gt; 
&lt;span&gt; 58&lt;/span&gt; restart() {
&lt;span&gt; 59&lt;/span&gt;     stop
&lt;span&gt; 60&lt;/span&gt;     start
&lt;span&gt; 61&lt;/span&gt; }
&lt;span&gt; 62&lt;/span&gt; 
&lt;span&gt; 63&lt;/span&gt; reload() {
&lt;span&gt; 64&lt;/span&gt;     echo -n $&quot;Reloading $prog: &quot;
&lt;span&gt; 65&lt;/span&gt;     killproc $prog -1
&lt;span&gt; 66&lt;/span&gt;     retval=$?
&lt;span&gt; 67&lt;/span&gt;     echo
&lt;span&gt; 68&lt;/span&gt;     return $retval
&lt;span&gt; 69&lt;/span&gt; }
&lt;span&gt; 70&lt;/span&gt; 
&lt;span&gt; 71&lt;/span&gt; force_reload() {
&lt;span&gt; 72&lt;/span&gt;     restart
&lt;span&gt; 73&lt;/span&gt; }
&lt;span&gt; 74&lt;/span&gt; 
&lt;span&gt; 75&lt;/span&gt; rh_status() {
&lt;span&gt; 76&lt;/span&gt;     status $prog
&lt;span&gt; 77&lt;/span&gt; }
&lt;span&gt; 78&lt;/span&gt; 
&lt;span&gt; 79&lt;/span&gt; rh_status_q() {
&lt;span&gt; 80&lt;/span&gt;     rh_status &amp;amp;&amp;gt;/dev/null
&lt;span&gt; 81&lt;/span&gt; }
&lt;span&gt; 82&lt;/span&gt; 
&lt;span&gt; 83&lt;/span&gt; 
&lt;span&gt; 84&lt;/span&gt; case &quot;$1&quot; in
&lt;span&gt; 85&lt;/span&gt;     start)
&lt;span&gt; 86&lt;/span&gt;         rh_status_q &amp;amp;&amp;amp; exit 0
&lt;span&gt; 87&lt;/span&gt;         $1
&lt;span&gt; 88&lt;/span&gt;         ;;
&lt;span&gt; 89&lt;/span&gt;     stop)
&lt;span&gt; 90&lt;/span&gt;         rh_status_q || exit 0
&lt;span&gt; 91&lt;/span&gt;         $1
&lt;span&gt; 92&lt;/span&gt;         ;;
&lt;span&gt; 93&lt;/span&gt;     restart)
&lt;span&gt; 94&lt;/span&gt;         $1
&lt;span&gt; 95&lt;/span&gt;         ;;
&lt;span&gt; 96&lt;/span&gt;     reload)
&lt;span&gt; 97&lt;/span&gt;         rh_status_q || exit 7
&lt;span&gt; 98&lt;/span&gt;         $1
&lt;span&gt; 99&lt;/span&gt;         ;;
&lt;span&gt;100&lt;/span&gt;     force-reload)
&lt;span&gt;101&lt;/span&gt;         force_reload
&lt;span&gt;102&lt;/span&gt;         ;;
&lt;span&gt;103&lt;/span&gt;     status)
&lt;span&gt;104&lt;/span&gt;         rh_status
&lt;span&gt;105&lt;/span&gt;         ;;
&lt;span&gt;106&lt;/span&gt;     condrestart|try-restart)
&lt;span&gt;107&lt;/span&gt;         rh_status_q || exit 0
&lt;span&gt;108&lt;/span&gt;         restart
&lt;span&gt;109&lt;/span&gt;         ;;
&lt;span&gt;110&lt;/span&gt;     *)
&lt;span&gt;111&lt;/span&gt;         echo $&quot;Usage: $0 {start|stop|status|restart|condrestart|try-restart|reload|force-reload}&quot;
&lt;span&gt;112&lt;/span&gt;         exit 2
&lt;span&gt;113&lt;/span&gt; esac
&lt;span&gt;114&lt;/span&gt; exit $
&lt;span&gt;115&lt;/span&gt; [root@lvsmaster ~]# chmod u+x /etc/rc.d/init.d/keepalived
&lt;span&gt;116&lt;/span&gt; [root@lvsmaster ~]# vi /etc/keepalived/keepalived.conf
&lt;span&gt;117&lt;/span&gt; ! Configuration File for keepalived
&lt;span&gt;118&lt;/span&gt; ……
&lt;span&gt;119&lt;/span&gt;    smtp_connect_timeout 30
&lt;span&gt;120&lt;/span&gt;    router_id LVS_Master                #表示运行Keepalived服务器的一个标识
&lt;span&gt;121&lt;/span&gt; }
&lt;span&gt;122&lt;/span&gt; 
&lt;span&gt;123&lt;/span&gt; vrrp_instance VI_1 {
&lt;span&gt;124&lt;/span&gt;     state MASTER                       #指定Keepalived的角色
&lt;span&gt;125&lt;/span&gt;     interface eth0                     #指定HA监测网络的接口
&lt;span&gt;126&lt;/span&gt;     virtual_router_id 51            #同一个vrrp实例使用唯一的标识，即同一个vrrp_instance下，Master和Backup必须是一致的
&lt;span&gt;128&lt;/span&gt;     priority 100                       #定义优先级，数值越大，优先级越高
&lt;span&gt;129&lt;/span&gt;     advert_int 1                       #设定Mater和Backup负载均衡器之间同步检查时间间隔
&lt;span&gt;130&lt;/span&gt;     authentication {
&lt;span&gt;131&lt;/span&gt;         auth_type PASS
&lt;span&gt;132&lt;/span&gt;         auth_pass 1111
&lt;span&gt;133&lt;/span&gt;     }
&lt;span&gt;134&lt;/span&gt;     virtual_ipaddress {
&lt;span&gt;135&lt;/span&gt;         172.24.8.100           #设置虚拟IP地址
&lt;span&gt;136&lt;/span&gt;     }
&lt;span&gt;137&lt;/span&gt; }
&lt;span&gt;138&lt;/span&gt; 
&lt;span&gt;139&lt;/span&gt; virtual_server 172.24.8.100 80 {
&lt;span&gt;140&lt;/span&gt;     delay_loop 6                       #运行情况检查时间
&lt;span&gt;141&lt;/span&gt;     lb_algo rr                 #设置负载均衡算法
&lt;span&gt;142&lt;/span&gt;     lb_kind DR                 #设置LVS实现负载均衡的机制，有NAT/DR/TUN
&lt;span&gt;143&lt;/span&gt;     persistence_timeout 50             #会话保持时间
&lt;span&gt;144&lt;/span&gt;     protocol TCP                       #指定转发类型
&lt;span&gt;145&lt;/span&gt; 
&lt;span&gt;146&lt;/span&gt;     real_server 172.24.8.12 80 {
&lt;span&gt;147&lt;/span&gt;         weight 1                       #服务节点的权值，数值越大，权值越高
&lt;span&gt;148&lt;/span&gt;         TCP_CHECK {
&lt;span&gt;149&lt;/span&gt;         connect_timeout 5              #表示无响应超时时间，单位是秒
&lt;span&gt;150&lt;/span&gt;         nb_get_retry 3         #表示重试次数
&lt;span&gt;151&lt;/span&gt;         delay_before_retry 3   #表示重试间隔
&lt;span&gt;152&lt;/span&gt;         }
&lt;span&gt;153&lt;/span&gt;     }
&lt;span&gt;154&lt;/span&gt; real_server 172.24.8.13 80 {
&lt;span&gt;155&lt;/span&gt;         weight 1
&lt;span&gt;156&lt;/span&gt;         TCP_CHECK {
&lt;span&gt;157&lt;/span&gt;         connect_timeout 5
&lt;span&gt;158&lt;/span&gt;         nb_get_retry 3
&lt;span&gt;159&lt;/span&gt;         delay_before_retry 3
&lt;span&gt;160&lt;/span&gt;      }
&lt;span&gt;161&lt;/span&gt; }
&lt;span&gt;162&lt;/span&gt; }
&lt;span&gt;163&lt;/span&gt; [root@lvsmaster ~]# scp /etc/keepalived/keepalived.conf 172.24.8.11:/etc/keepalived/keepalived.conf
&lt;span&gt;164&lt;/span&gt; [root@lvsbackup ~]# vi /etc/keepalived/keepalived.conf
&lt;span&gt;165&lt;/span&gt; state BACKUP
&lt;span&gt;166&lt;/span&gt; priority 80
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;注意；备用Director Server上需要修改状态为BACKUP和priority优先级。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;2.5 安装IPVS管理工具&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; [root@lvsmaster ~]# yum -y install ipvsadm
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 align=&quot;left&quot;&gt;2.6 配置Real Server节点&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;在LVS的DR和TUN模式下，用户访问请求到大Real Server后，Real Server的响应报文直接返回给用户，而不需经过Director Server。因此，需要在每个Real Server上配置虚拟VIP地址。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;注意：回环接口绑定vip，且禁止arp请求等操作，可通过以下脚本实现：脚本可留言索要。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; [root@RServer01 ~]# vi /etc/init.d/lvsrs
&lt;span&gt;  2&lt;/span&gt; [root@RServer01 ~]# chmod u+x /etc/init.d/lvsrs
&lt;/pre&gt;&lt;/div&gt;

&lt;h3 align=&quot;left&quot;&gt;2.7 启动集群&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; [root@RServer01 ~]# service httpd start
&lt;span&gt;  2&lt;/span&gt; [root@RServer01 ~]# chkconfig httpd on
&lt;span&gt;  3&lt;/span&gt; [root@RServer02 ~]# service httpd start
&lt;span&gt;  4&lt;/span&gt; [root@RServer02 ~]# chkconfig httpd on
&lt;span&gt;  5&lt;/span&gt; 
&lt;span&gt;  6&lt;/span&gt; [root@lvsmaster ~]# service keepalived start
&lt;span&gt;  7&lt;/span&gt; [root@lvsmaster ~]# chkconfig keepalived on
&lt;span&gt;  8&lt;/span&gt; [root@lvsbackup ~]# service keepalived start
&lt;span&gt;  9&lt;/span&gt; [root@lvsbackup ~]# chkconfig keepalived on
&lt;span&gt; 10&lt;/span&gt; 
&lt;span&gt; 11&lt;/span&gt; [root@RServer01 ~]# service lvsrs start
&lt;span&gt; 12&lt;/span&gt; [root@RServer02 ~]# service lvsrs start
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 align=&quot;left&quot;&gt;三 测试集群&lt;/h2&gt;
&lt;h3 align=&quot;left&quot;&gt;3.1 高可用功能测试&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;停止主Director Server服务器的Keepalived，观察/var/log/messages日志，可知备机会立刻变为MASTER，并且接管主机的虚拟ip资源。重启主Director Server服务器的Keepalived，备机会重新恢复为BACKUP角色。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;具体测试略。&lt;/span&gt;&lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;3.2 负载均衡测试&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; [root@RServer01 ~]# echo 'This is Real Server01!' &amp;gt;&amp;gt;/var/www/html/index.html
&lt;span&gt;  2&lt;/span&gt; [root@RServer01 ~]# echo 'This is Real Server02!' &amp;gt;&amp;gt;/var/www/html/index.html
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;然后浏览器访问：http://172.24.8.100，并不断的刷新，能分别看到Server01和Server02即可。&lt;/span&gt;&lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;3.3 故障切换测试&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; [root@RServer01 ~]# service httpd stop
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/680719/201901/680719-20190113133829235-1794846064.png&quot;&gt;&lt;img title=&quot;02&quot; src=&quot;https://img2018.cnblogs.com/blog/680719/201901/680719-20190113133831189-25571595.png&quot; alt=&quot;02&quot; width=&quot;890&quot; height=&quot;190&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;当关掉其中一个Real Server时，访问VIP，只会显示还处于集群中的web节点。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/680719/201901/680719-20190113133832172-1755040127.png&quot;&gt;&lt;img title=&quot;03&quot; src=&quot;https://img2018.cnblogs.com/blog/680719/201901/680719-20190113133832366-1033935235.png&quot; alt=&quot;03&quot; width=&quot;982&quot; height=&quot;51&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 13 Jan 2019 05:39:00 +0000</pubDate>
<dc:creator>木二</dc:creator>
<og:description>一 基础环境 1.1 IP规划 OS：CentOS 6.8 64位 节点类型 IP规划 主机名 类型 主 Director Server eth0：172.24.8.10 DR1 公共IP eth1：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/itzgr/p/10262402.html</dc:identifier>
</item>
<item>
<title>数据挖掘学习 - QQ_990814268</title>
<link>http://www.cnblogs.com/kaiping23/p/10262362.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kaiping23/p/10262362.html</guid>
<description>&lt;ul&gt;&lt;li&gt;完成数据挖掘基础阶段的所有环境安装&lt;/li&gt;
&lt;li&gt;应用jupyter notebook完成代码编写运行&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;学习目标&quot;&gt;学习目标&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;目标
&lt;ul&gt;&lt;li&gt;搭建好数据挖掘基础阶段的环境&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;应用
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;整个数据挖掘基础阶段会用到Matplotlib、Numpy、Pandas、Ta-Lib等库，为了统一版本号在环境中使用，将所有的库及其版本放到了文件requirements.txt当中，然后统一安装&lt;/p&gt;
&lt;p&gt;新建一个用于人工智能环境的虚拟环境&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mkvirtualenv -p /user/local/bin/python3 ai
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;lang-python&quot;&gt;matplotlib==&lt;span class=&quot;hljs-number&quot;&gt;2.2&lt;span class=&quot;hljs-number&quot;&gt;.2
numpy==&lt;span class=&quot;hljs-number&quot;&gt;1.14&lt;span class=&quot;hljs-number&quot;&gt;.2
pandas==&lt;span class=&quot;hljs-number&quot;&gt;0.20&lt;span class=&quot;hljs-number&quot;&gt;.3
TA-Lib==&lt;span class=&quot;hljs-number&quot;&gt;0.4&lt;span class=&quot;hljs-number&quot;&gt;.16
tables==&lt;span class=&quot;hljs-number&quot;&gt;3.4&lt;span class=&quot;hljs-number&quot;&gt;.2
jupyter==&lt;span class=&quot;hljs-number&quot;&gt;1.0&lt;span class=&quot;hljs-number&quot;&gt;.0
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Ta-Lib安装会出现问题，需要先安装依赖库，按照以下步骤安装：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;lang-python&quot;/&gt;
&lt;/pre&gt;
&lt;p&gt;使用pip命令安装&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;pip install -r requirements.txt&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;学习目标&quot;&gt;学习目标&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;目标
&lt;ul&gt;&lt;li&gt;学会使用Jupyter Notebook编写运行代码&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;应用
&lt;ul&gt;&lt;li&gt;创建文件&lt;/li&gt;
&lt;li&gt;操作cell&lt;/li&gt;
&lt;li&gt;运行操作&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;121-jupyter-notebook介绍&quot;&gt;1.2.1 Jupyter Notebook介绍&lt;/h2&gt;
&lt;p&gt;Jupyter项目是一个非盈利的开源项目，源于2014年的ipython项目，因为它逐渐发展为支持跨所有编程语言的交互式数据科学和科学计算&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Jupyter Notebook，原名IPython Notbook，是IPython的加强网页版，一个开源Web应用程序&lt;/li&gt;
&lt;li&gt;名字源自Julia、Python 和 R（数据科学的三种开源语言）&lt;/li&gt;
&lt;li&gt;是一款程序员和科学工作者的编程/文档/笔记/展示软件&lt;/li&gt;
&lt;li&gt;.ipynb文件格式是用于计算型叙述的JSON文档格式的正式规范&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1485681/201901/1485681-20190113130650433-1441856736.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;122-为什么使用jupyter-notebook&quot;&gt;1.2.2 为什么使用Jupyter Notebook?&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;传统软件开发：工程／目标明确
&lt;ul&gt;&lt;li&gt;需求分析，设计架构，开发模块，测试&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;数据挖掘：艺术／目标不明确
&lt;ul&gt;&lt;li&gt;目的是具体的洞察目标，而不是机械的完成任务&lt;/li&gt;
&lt;li&gt;通过执行代码来理解问题&lt;/li&gt;
&lt;li&gt;迭代式地改进代码来改进解决方法&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;实时运行的代码、叙事性的文本和可视化被整合在一起，方便使用代码和数据来讲述故事&lt;/p&gt;
&lt;p&gt;对比Jupyter Notebook和Pycharm&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1485681/201901/1485681-20190113130730507-107040500.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1485681/201901/1485681-20190113130748503-797714749.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;123-jupyter-notebook的使用helloworld&quot;&gt;1.2.3 Jupyter Notebook的使用-helloworld&lt;/h2&gt;
&lt;h3 id=&quot;1-界面启动、创建文件&quot;&gt;1 界面启动、创建文件&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;界面启动&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;环境搭建好后，本机输入jupyter notebook命令，会自动弹出浏览器窗口打开Jupyter Notebook&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
# 进入虚拟环境
workon ai
# 输入命令
jupyter notebook
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;本地notebook的默认URL为：&lt;a href=&quot;http://localhost:8888/&quot; target=&quot;_blank&quot;&gt;http://localhost:8888&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;想让notebook打开指定目录，只要进入此目录后执行命令即可&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1485681/201901/1485681-20190113130847789-1931275287.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;新建notebook文档&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;notebook的文档格式是&lt;code&gt;.ipynb&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1485681/201901/1485681-20190113130913115-1789612836.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;内容界面操作-helloworld&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1485681/201901/1485681-20190113130940250-923031383.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;标题栏：点击标题（如Untitled）修改文档名 菜单栏&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;导航-File-Download as，另存为其他格式&lt;/li&gt;
&lt;li&gt;导航-Kernel
&lt;ul&gt;&lt;li&gt;Interrupt，中断代码执行（程序卡死时）&lt;/li&gt;
&lt;li&gt;Restart，重启Python内核（执行太慢时重置全部资源）&lt;/li&gt;
&lt;li&gt;Restart &amp;amp; Clear Output，重启并清除所有输出&lt;/li&gt;
&lt;li&gt;Restart &amp;amp; Run All，重启并重新运行所有代码&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;2-cell操作&quot;&gt;2 cell操作&lt;/h3&gt;
&lt;p&gt;什么是cell？&lt;/p&gt;
&lt;p&gt;cell：一对In Out会话被视作一个代码单元，称为cell&lt;/p&gt;
&lt;p&gt;Jupyter支持两种模式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;编辑模式（Enter）
&lt;ul&gt;&lt;li&gt;命令模式下&lt;code&gt;回车Enter&lt;/code&gt;或&lt;code&gt;鼠标双击&lt;/code&gt;cell进入编辑模式&lt;/li&gt;
&lt;li&gt;可以操作cell内文本或代码，剪切／复制／粘贴移动等操作&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;命令模式（Esc）
&lt;ul&gt;&lt;li&gt;按&lt;code&gt;Esc&lt;/code&gt;退出编辑，进入命令模式&lt;/li&gt;
&lt;li&gt;可以操作cell单元本身进行剪切／复制／粘贴／移动等操作&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;1）鼠标操作&quot;&gt;1）鼠标操作&lt;/h4&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1485681/201901/1485681-20190113131213902-985425993.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;2）快捷键操作&quot;&gt;2）快捷键操作&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;两种模式通用快捷键
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Shift+Enter&lt;/code&gt;，执行本单元代码，并跳转到下一单元&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ctrl+Enter&lt;/code&gt;，执行本单元代码，留在本单元&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;cell行号前的 * ，表示代码正在运行&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;命令模式：按ESC进入
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Y&lt;/code&gt;，cell切换到Code模式&lt;/li&gt;
&lt;li&gt;&lt;code&gt;M&lt;/code&gt;，cell切换到Markdown模式&lt;/li&gt;
&lt;li&gt;&lt;code&gt;A&lt;/code&gt;，在当前cell的上面添加cell&lt;/li&gt;
&lt;li&gt;&lt;code&gt;B&lt;/code&gt;，在当前cell的下面添加cell&lt;/li&gt;
&lt;li&gt;&lt;code&gt;双击D&lt;/code&gt;：删除当前cell&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Z&lt;/code&gt;，回退&lt;/li&gt;
&lt;li&gt;&lt;code&gt;L&lt;/code&gt;，为当前cell加上行号 &amp;lt;!--&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ctrl+Shift+P&lt;/code&gt;，对话框输入命令直接运行&lt;/li&gt;
&lt;li&gt;快速跳转到首个cell，&lt;code&gt;Crtl+Home&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;快速跳转到最后一个cell，&lt;code&gt;Crtl+End&lt;/code&gt; --&amp;gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;编辑模式：按Enter进入
&lt;ul&gt;&lt;li&gt;多光标操作：&lt;code&gt;Ctrl键点击鼠标&lt;/code&gt;（Mac:CMD+点击鼠标）&lt;/li&gt;
&lt;li&gt;回退：&lt;code&gt;Ctrl+Z&lt;/code&gt;（Mac:CMD+Z）&lt;/li&gt;
&lt;li&gt;重做：&lt;code&gt;Ctrl+Y&lt;/code&gt;（Mac:CMD+Y)&lt;/li&gt;
&lt;li&gt;补全代码：变量、方法后跟&lt;code&gt;Tab键&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;为一行或多行代码添加/取消注释：&lt;code&gt;Ctrl+/&lt;/code&gt;（Mac:CMD+/）&lt;/li&gt;
&lt;li&gt;屏蔽自动输出信息：可在最后一条语句之后加一个分号&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;3-markdown演示&quot;&gt;3 markdown演示&lt;/h3&gt;
&lt;p&gt;掌握标题和缩进即可&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1485681/201901/1485681-20190113131259240-1670399514.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;二级标题&quot;&gt;二级标题&lt;/h2&gt;
&lt;h3 id=&quot;三级标题&quot;&gt;三级标题&lt;/h3&gt;
&lt;h4 id=&quot;四级标题&quot;&gt;四级标题&lt;/h4&gt;
&lt;h5 id=&quot;五级标题&quot;&gt;五级标题&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;缩进
&lt;ul&gt;&lt;li&gt;二级缩进
&lt;ul&gt;&lt;li&gt;三级缩进&lt;/li&gt;
&lt;li/&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Sun, 13 Jan 2019 05:15:00 +0000</pubDate>
<dc:creator>QQ_990814268</dc:creator>
<og:description>数据挖掘基础环境安装与使用 完成数据挖掘基础阶段的所有环境安装 应用jupyter notebook完成代码编写运行 1.1 库的安装 学习目标 目标 搭建好数据挖掘基础阶段的环境 应用 无 搭建好数</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kaiping23/p/10262362.html</dc:identifier>
</item>
<item>
<title>任务队列和异步接口的正确打开方式(.NET Core版本) - 李国宝</title>
<link>http://www.cnblogs.com/liguobao/p/10262356.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liguobao/p/10262356.html</guid>
<description>&lt;h2 id=&quot;什么是异步接口&quot;&gt;什么是异步接口?&lt;/h2&gt;
&lt;h2 id=&quot;asynchronous-operations&quot;&gt;Asynchronous Operations&lt;/h2&gt;
&lt;p&gt;Certain types of operations might require processing of the request in an asynchronous manner (e.g. validating a bank account, processing an image, etc.) in order to avoid long delays on the client side and prevent long-standing open client connections waiting for the operations to complete. For such use cases, APIs MUST employ the following pattern:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;For &lt;code&gt;POST&lt;/code&gt; requests&lt;/em&gt;:&lt;/strong&gt;&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li&gt;Return the &lt;code&gt;202 Accepted&lt;/code&gt; HTTP response code.&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;In the response body, include one or more URIs as hypermedia links, which could include:
&lt;ul&gt;&lt;li&gt;The final URI of the resource where it will be available in future if the ID and path are already known. Clients can then make an HTTP &lt;code&gt;GET&lt;/code&gt; request to that URI in order to obtain the completed resource. Until the resource is ready, the final URI SHOULD return the HTTP status code &lt;code&gt;404 Not Found&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;{ &quot;rel&quot;: &quot;self&quot;, &quot;href&quot;: &quot;/v1/namespace/resources/{resource_id}&quot;, &quot;method&quot;: &quot;GET&quot; }&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;A temporary request queue URI where the status of the operation may be obtained via some temporary identifier. Clients SHOULD make an HTTP &lt;code&gt;GET&lt;/code&gt; request to obtain the status of the operation which MAY include such information as completion state, ETA, and final URI once it is completed.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;{ &quot;rel&quot;: &quot;self&quot;, &quot;href&quot;: &quot;/v1/queue/requests/{request_id}, &quot;method&quot;: &quot;GET&quot; }&quot;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;For &lt;code&gt;PUT&lt;/code&gt;/&lt;code&gt;PATCH&lt;/code&gt;/&lt;code&gt;DELETE&lt;/code&gt;/&lt;code&gt;GET&lt;/code&gt; requests&lt;/em&gt;:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Like &lt;code&gt;POST&lt;/code&gt;, you can support PUT/&lt;code&gt;PATCH&lt;/code&gt;/&lt;code&gt;DELETE&lt;/code&gt;/&lt;code&gt;GET&lt;/code&gt; to be asynchronous. The behaviour would be as follows:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Return the &lt;code&gt;202 Accepted&lt;/code&gt; HTTP response code.&lt;/li&gt;
&lt;li&gt;In the response body, include one or more URIs as hypermedia links, which could include:
&lt;ul&gt;&lt;li&gt;A temporary request queue URI where the status of the operation may be obtained via some temporary identifier. Clients SHOULD make an HTTP &lt;code&gt;GET&lt;/code&gt; request to obtain the status of the operation which MAY include such information as completion state, ETA, and final URI once it is completed.&lt;/li&gt;
&lt;/ul&gt;&lt;code&gt;{ &quot;rel&quot;: &quot;self&quot;, &quot;href&quot;: &quot;/v1/queue/requests/{request_id}, &quot;method&quot;: &quot;GET&quot; }&quot;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;APIs that support both synchronous and asynchronous processing for an URI&lt;/em&gt;:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;APIs that support both synchronous and asynchronous operations for a particular URI and an HTTP method combination, MUST recognize the &lt;a href=&quot;http://www.cnblogs.com/liguobao/p/index.md#http-standard-headers&quot;&gt;&lt;code&gt;Prefer&lt;/code&gt;&lt;/a&gt; header and exhibit following behavior:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;If the request contains a &lt;code&gt;Prefer=respond-async&lt;/code&gt; header, the service MUST switch the processing to asynchronous mode.&lt;/li&gt;
&lt;li&gt;If the request doesn't contain a &lt;code&gt;Prefer=respond-async&lt;/code&gt; header, the service MUST process the request synchronously.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;It is desirable that all APIs that implement asynchronous processing, also support &lt;a href=&quot;https://en.wikipedia.org/wiki/Webhook&quot;&gt;webhooks&lt;/a&gt; as a mechanism of pushing the processing status to the client.&lt;/p&gt;
&lt;p&gt;资料引自:&lt;a href=&quot;https://github.com/paypal/api-standards/blob/master/patterns.md#asynchronous-operations&quot;&gt;paypal/API Design Patterns And Use Cases:asynchronous-operations&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;用人话来说&quot;&gt;用人话来说&lt;/h3&gt;
&lt;ul readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;简单来说就是请求过来,直接返回对应的resourceId/request_id,然后可以通过resourceId/request_id查询处理结果&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;处理过程可能是队列,也可能直接是异步操作&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;如果还没完成处理,返回404,如果处理完成,正常返回对应数据&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;好像也没什么讲了....&lt;/p&gt;
&lt;p&gt;全文结束吧.&lt;/p&gt;
&lt;h2 id=&quot;样例代码部分啦&quot;&gt;样例代码部分啦&lt;/h2&gt;
&lt;h3 id=&quot;实现逻辑&quot;&gt;实现逻辑&lt;/h3&gt;
&lt;ul readability=&quot;7.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;创建任务,生成&quot;request-id&quot;存储到对应redis zset队列中&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;同时往redis channel发出任务消息, 后台任务处理服务自行处理此消息(生产者-消费者模式)&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;任务处理服务处理完消息之后,将处理结果写入redis,request-id为key,结果为value,然后从从redis zset从移除对应的&quot;request-id&quot;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;获取request-id处理结果时:如果request-id能查询到对应的任务处理结果,直接返回处理完的数据; 如果request-id还在sortset队列则直接返回404 + 对应的位置n,表示还在处理中,前面还有n个请求;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;时序图大概长这样:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/64d1e863gy1fz3r5m9x0ij20v80q277b.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;喜闻乐见代码时间&quot;&gt;喜闻乐见代码时间&lt;/h3&gt;
&lt;p&gt;RequestService.cs&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;// RequestService.cs

using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using CorrelationId;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using Newtonsoft.Json.Linq;
using StackExchange.Redis;
using static StackExchange.Redis.RedisChannel;

namespace MTQueue.Service
{
    public class RequestService
    {


        private readonly ICorrelationContextAccessor _correlationContext;

        private readonly ConnectionMultiplexer _redisMultiplexer;

        private readonly IServiceProvider _services;

        private readonly ILogger&amp;lt;RequestService&amp;gt; _logger;

        public RequestService(ICorrelationContextAccessor correlationContext,
        ConnectionMultiplexer redisMultiplexer, IServiceProvider services,
        ILogger&amp;lt;RequestService&amp;gt; logger)
        {
            _correlationContext = correlationContext;
            _redisMultiplexer = redisMultiplexer;
            _services = services;
            _logger = logger;
        }

        public long? AddRequest(JToken data)
        {
            var requestId = _correlationContext.CorrelationContext.CorrelationId;
            var redisDB = _redisMultiplexer.GetDatabase(CommonConst.DEFAULT_DB);
            var index = redisDB.SortedSetRank(CommonConst.REQUESTS_SORT_SETKEY, requestId);
            if (index == null)
            {
                data[&quot;requestId&quot;] = requestId;
                redisDB.SortedSetAdd(CommonConst.REQUESTS_SORT_SETKEY, requestId, GetTotalSeconds());
                PushRedisMessage(data.ToString());
            }
            return redisDB.SortedSetRank(CommonConst.REQUESTS_SORT_SETKEY, requestId);
        }

        public static long GetTotalSeconds()
        {
            return (long)(DateTime.Now.ToLocalTime() - new DateTime(1970, 1, 1).ToLocalTime()).TotalSeconds;
        }

        private void PushRedisMessage(string message)
        {
            Task.Run(() =&amp;gt;
            {
                try
                {
                    using (var scope = _services.CreateScope())
                    {
                        var multiplexer = scope.ServiceProvider.GetRequiredService&amp;lt;ConnectionMultiplexer&amp;gt;();
                        multiplexer.GetSubscriber().PublishAsync(CommonConst.REQUEST_CHANNEL, message);
                    }
                }
                catch (Exception ex)
                {
                    _logger.LogError(-1, ex, message);
                }
            });
        }

        public Tuple&amp;lt;JToken, long?&amp;gt; GetRequest(string requestId)
        {
            var redisDB = _redisMultiplexer.GetDatabase(CommonConst.DEFAULT_DB);
            var keyIndex = redisDB.SortedSetRank(CommonConst.REQUESTS_SORT_SETKEY, requestId);
            var response = redisDB.StringGet(requestId);
            if (response.IsNull)
            {
                return Tuple.Create&amp;lt;JToken, long?&amp;gt;(default(JToken), keyIndex);
            }
            return Tuple.Create&amp;lt;JToken, long?&amp;gt;(JToken.Parse(response), keyIndex);
        }

    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;
// RedisMQListener.cs

using System;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using MTQueue.Model;
using MTQueue.Service;
using Newtonsoft.Json.Linq;
using StackExchange.Redis;
using static StackExchange.Redis.RedisChannel;

namespace MTQueue.Listener
{
    public class RedisMQListener : IHostedService
    {
        private readonly ConnectionMultiplexer _redisMultiplexer;

        private readonly IServiceProvider _services;

        private readonly ILogger&amp;lt;RedisMQListener&amp;gt; _logger;

        public RedisMQListener(IServiceProvider services, ConnectionMultiplexer redisMultiplexer,
        ILogger&amp;lt;RedisMQListener&amp;gt; logger)
        {
            _services = services;
            _redisMultiplexer = redisMultiplexer;
            _logger = logger;
        }

        public Task StartAsync(CancellationToken cancellationToken)
        {
            Register();
            return Task.CompletedTask;
        }


        public virtual bool Process(RedisChannel ch, RedisValue message)
        {
            _logger.LogInformation(&quot;Process start,message: &quot; + message);
            var redisDB = _services.GetRequiredService&amp;lt;ConnectionMultiplexer&amp;gt;()
            .GetDatabase(CommonConst.DEFAULT_DB);
            var messageJson = JToken.Parse(message);
            var requestId = messageJson[&quot;requestId&quot;]?.ToString();
            if (string.IsNullOrEmpty(requestId))
            {
                _logger.LogWarning(&quot;requestId not in message.&quot;);
                return false;
            }
            var mtAgent = _services.GetRequiredService&amp;lt;ZhihuClient&amp;gt;();
            var text = mtAgent.GetZhuanlan(messageJson);
            redisDB.StringSet(requestId, text.ToString(), CommonConst.RESPONSE_TS);
            _logger.LogInformation(&quot;Process finish,requestId:&quot; + requestId);
            redisDB.SortedSetRemove(CommonConst.REQUESTS_SORT_SETKEY, requestId);
            return true;
        }


        public void Register()
        {
            var sub = _redisMultiplexer.GetSubscriber();
            var channel = CommonConst.REQUEST_CHANNEL;
            sub.SubscribeAsync(channel, (ch, value) =&amp;gt;
            {
                Process(ch, value);
            });
        }

        public void DeRegister()
        {
            // this.connection.Close();
        }


        public Task StopAsync(CancellationToken cancellationToken)
        {
            // this.connection.Close();
            return Task.CompletedTask;
        }
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;
// RequestsController.cs

using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using CorrelationId;
using Microsoft.AspNetCore.Mvc;
using MTQueue.Service;
using Newtonsoft.Json.Linq;

namespace MTQueue.Controllers
{
    [Route(&quot;v1/[controller]&quot;)]
    [ApiController]
    public class RequestsController : ControllerBase
    {

        private readonly ICorrelationContextAccessor _correlationContext;

        private readonly RequestService _requestService;

        private readonly ZhihuClient _mtAgentClient;

        public RequestsController(ICorrelationContextAccessor correlationContext,
         RequestService requestService, ZhihuClient mtAgentClient)
        {
            _correlationContext = correlationContext;
            _requestService = requestService;
            _mtAgentClient = mtAgentClient;
        }



        [HttpGet(&quot;{requestId}&quot;)]
        public IActionResult Get(string requestId)
        {
            var result = _requestService.GetRequest(requestId);
            var resource = $&quot;/v1/requests/{requestId}&quot;;
            if (result.Item1 == default(JToken))
            {
                return NotFound(new { rel = &quot;self&quot;, href = resource, method = &quot;GET&quot;, index = result.Item2 });
            }
            return Ok(result.Item1);
        }

        [HttpPost]
        public IActionResult Post([FromBody] JToken data, [FromHeader(Name = &quot;Prefer&quot;)]string prefer)
        {
            if (!string.IsNullOrEmpty(prefer) &amp;amp;&amp;amp; prefer == &quot;respond-async&quot;)
            {
                var index = _requestService.AddRequest(data);
                var requestId = _correlationContext.CorrelationContext.CorrelationId;
                var resource = $&quot;/v1/requests/{requestId}&quot;;
                return Accepted(resource, new { rel = &quot;self&quot;, href = resource, method = &quot;GET&quot;, index = index });
            }
            return Ok(_mtAgentClient.GetZhuanlan(data));
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;完整代码见:&lt;a href=&quot;https://github.com/liguobao/TaskQueueSample&quot; class=&quot;uri&quot;&gt;https://github.com/liguobao/TaskQueueSample&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 13 Jan 2019 05:13:00 +0000</pubDate>
<dc:creator>李国宝</dc:creator>
<og:description>任务队列和异步接口的正确打开方式 什么是异步接口? Asynchronous Operations Certain types of operations might require processi</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liguobao/p/10262356.html</dc:identifier>
</item>
<item>
<title>2019个税计算公式（附最新个税计算器） - 林砖头</title>
<link>http://www.cnblogs.com/wy99/p/10262164.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wy99/p/10262164.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;新个人所得税法改革亮点&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、起征点由3500调整为5000；&lt;/p&gt;
&lt;p&gt;2、启用新的税率，对工资薪金、劳务报酬、稿酬以及特许权使用费4项收入，按年计税；&lt;/p&gt;
&lt;p&gt;3、新设了子女教育、继续教育、大病医疗、住房贷款利息、住房租金、赡养老人六项专项附加扣除。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;六项专项附件扣除的具体享受条件、扣除标准、享受扣除起止时间和备查资料可以下载&lt;/span&gt;PPT查看。&lt;a href=&quot;https://pan.baidu.com/s/1kePMgZAA2r1cgnRiIKwTtA&quot; target=&quot;_blank&quot;&gt;点击下载最新个人所得税新政策指引&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;新个人所得税&lt;/span&gt;&lt;span&gt;计算公式&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1. 累计预扣法具体公式：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;累计预扣预缴应纳税所得额&lt;/span&gt;=累计收入-累计免税收入-累计减除费用-累计专项扣除-累计专项附加扣除-累计依法确定的其他扣除&lt;/p&gt;
&lt;p&gt;2.本期应预扣预缴税额具体公式：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本期应预扣预缴税额&lt;/span&gt;=（累计预扣预缴应纳税所得额×预扣率-速算扣除数)-累计已预扣预缴税额&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1556523/201901/1556523-20190113115810145-1409714034.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p align=&quot;justify&quot;&gt;如果还是没看懂的话，我们来做两道题弄懂它。&lt;/p&gt;

&lt;p&gt;1、&lt;span&gt;某员工&lt;/span&gt;2015&lt;span&gt;年入职，&lt;/span&gt;&lt;span&gt;2019&lt;/span&gt;&lt;span&gt;年每月应发工资均为&lt;/span&gt;&lt;span&gt;10000&lt;/span&gt;&lt;span&gt;元，每月减除费用&lt;/span&gt;&lt;span&gt;5000&lt;/span&gt;&lt;span&gt;元，“三险一金”等专项扣除为&lt;/span&gt;&lt;span&gt;1500&lt;/span&gt;&lt;span&gt;元，从&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;月起享受一名子女教育专项附加扣除，没有减免收入及减免税额等情况，以前三个月为例，员工每月应当预扣预缴的税额是多少呢？&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;答案：&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;1&lt;span&gt;月份：&lt;/span&gt;&lt;span&gt;(10000-5000-1500-1000&lt;/span&gt;&lt;span&gt;）×&lt;/span&gt;&lt;span&gt;3% =75&lt;/span&gt;&lt;span&gt;元&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;2&lt;span&gt;月份：&lt;/span&gt;&lt;span&gt;(10000&lt;/span&gt;&lt;span&gt;×&lt;/span&gt;&lt;span&gt;2-5000&lt;/span&gt;&lt;span&gt;×&lt;/span&gt;&lt;span&gt;2-1500&lt;/span&gt;&lt;span&gt;×&lt;/span&gt;&lt;span&gt;2-1000&lt;/span&gt;&lt;span&gt;×&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;）×&lt;/span&gt;&lt;span&gt;3%-75 =75&lt;/span&gt;&lt;span&gt;元&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;3&lt;span&gt;月份：&lt;/span&gt;&lt;span&gt;(10000&lt;/span&gt;&lt;span&gt;×&lt;/span&gt;&lt;span&gt;3-5000&lt;/span&gt;&lt;span&gt;×&lt;/span&gt;&lt;span&gt;3-1500&lt;/span&gt;&lt;span&gt;×&lt;/span&gt;&lt;span&gt;3-1000&lt;/span&gt;&lt;span&gt;×&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;）×&lt;/span&gt;&lt;span&gt;3%-75-75 =75&lt;/span&gt;&lt;span&gt;元&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;2&lt;span&gt;、某员工&lt;/span&gt;&lt;span&gt;2015&lt;/span&gt;&lt;span&gt;年入职，&lt;/span&gt;&lt;span&gt;2019&lt;/span&gt;&lt;span&gt;年每月应发工资均为&lt;/span&gt;&lt;span&gt;30000&lt;/span&gt;&lt;span&gt;元，每月减除费用&lt;/span&gt;&lt;span&gt;5000&lt;/span&gt;&lt;span&gt;元，“三险一金”等专项扣除为&lt;/span&gt;&lt;span&gt;4500&lt;/span&gt;&lt;span&gt;元，享受子女（&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;人）教育、赡养老人（&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;人）两项专项附加扣除共计&lt;/span&gt;&lt;span&gt;2000&lt;/span&gt;&lt;span&gt;元，没有减免收入及减免税额等情况，以前三个月为例，员工每月应当预扣预缴的税额是多少呢？&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;答案：&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;1&lt;span&gt;月份：&lt;/span&gt;&lt;span&gt;(30000&lt;/span&gt;&lt;span&gt;–&lt;/span&gt;&lt;span&gt;5000-4500-2000&lt;/span&gt;&lt;span&gt;）×&lt;/span&gt;&lt;span&gt;3% = 555&lt;/span&gt;&lt;span&gt;元&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;2&lt;span&gt;月份：&lt;/span&gt;&lt;span&gt;(30000&lt;/span&gt;&lt;span&gt;×&lt;/span&gt;&lt;span&gt;2-5000&lt;/span&gt;&lt;span&gt;×&lt;/span&gt;&lt;span&gt;2-4500&lt;/span&gt;&lt;span&gt;×&lt;/span&gt;&lt;span&gt;2-2000&lt;/span&gt;&lt;span&gt;×&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;）×&lt;/span&gt;&lt;span&gt;10% -2520 -555 =625&lt;/span&gt;&lt;span&gt;元&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;3&lt;span&gt;月份：&lt;/span&gt;&lt;span&gt;(30000&lt;/span&gt;&lt;span&gt;×&lt;/span&gt;&lt;span&gt;3-5000&lt;/span&gt;&lt;span&gt;×&lt;/span&gt;&lt;span&gt;3-4500&lt;/span&gt;&lt;span&gt;×&lt;/span&gt;&lt;span&gt;3-2000&lt;/span&gt;&lt;span&gt;×&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;）×&lt;/span&gt;&lt;span&gt;10% -2520 -555-625 =1850&lt;/span&gt;&lt;span&gt;元&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;一个月一个月算太麻烦的话，我附上刚开发的个税计算器。如发现有bug，私信或评论告诉我，及时修复。&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;预览地址：&lt;a href=&quot;https://ll527563266.github.io/income-tax-calculation-view&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://ll527563266.github.io/income-tax-calculation-view&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;源码地址：&lt;a href=&quot;https://github.com/ll527563266/income-tax-calculation&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://github.com/ll527563266/income-tax-calculation&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;最后感谢我司的人事部经理做的&lt;/span&gt;PPT&lt;span&gt;，谢谢！&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 13 Jan 2019 04:03:00 +0000</pubDate>
<dc:creator>林砖头</dc:creator>
<og:description>新个人所得税法改革亮点： 1、起征点由3500调整为5000； 2、启用新的税率，对工资薪金、劳务报酬、稿酬以及特许权使用费4项收入，按年计税； 3、新设了子女教育、继续教育、大病医疗、住房贷款利息、</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wy99/p/10262164.html</dc:identifier>
</item>
</channel>
</rss>