<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>数据结构和算法躬行记（5）——回溯算法 - 咖啡机（K.F.J）</title>
<link>http://www.cnblogs.com/strick/p/13384038.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/strick/p/13384038.html</guid>
<description>&lt;p&gt;　　回溯算法（backtracking）是一个类似枚举的搜索尝试过程，在寻找问题解的过程中，当发现不满足求解条件时，就退回一步，尝试其它路径，该算法的时间复杂度都不会低于 O(N!)，复杂的例题包括&lt;span&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/regular-expression-matching/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;正则表达式匹配&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;、&lt;span&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/sudoku-solver/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;解数独&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;等。&lt;/p&gt;
&lt;p&gt;　　在《&lt;span&gt;&lt;a href=&quot;https://labuladong.gitbook.io/algo/di-ling-zhang-bi-du-xi-lie/hui-su-suan-fa-xiang-jie-xiu-ding-ban&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;回溯算法详解&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;》一文中提到，解决一个回溯问题，实际上就是一个决策树的遍历过程，需要思考三个问题：&lt;/p&gt;
&lt;p&gt;　　（1）路径：已经做出的选择。&lt;/p&gt;
&lt;p&gt;　　（2）选择列表：当前可以做的选择。&lt;/p&gt;
&lt;p&gt;　　（3）结束条件：到达决策树底层，无法再做选择的条件。&lt;/p&gt;
&lt;p&gt;　　下面是改编过的算法通用结构。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; backtrack(路径, 选择列表):
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; 满足结束条件
        console.log(路径)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt;&lt;span&gt; 选择 of 选择列表
        做选择
        backtrack(路径, 选择列表)
        撤销选择&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　面试题12 &lt;span&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;矩阵路径&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;和面试题13 &lt;span&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;机器人运动范围&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;。在二维方格或矩阵的运动可用回溯法解决。&lt;/p&gt;

&lt;p&gt;　　&lt;span&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/n-queens/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;N皇后&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;是一道经典的回溯算法题，将 n 个皇后放置在 n×n 的棋盘上，使皇后彼此之间不能相互攻击，即每个棋子所在的行、列、对角线都不能有另一个棋子。&lt;/p&gt;
&lt;p&gt;　　在下面的&lt;span&gt;&lt;a href=&quot;https://codepen.io/strick/pen/JjGzMed&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;示例&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;中，N是皇后的数量，backtrack()函数是回溯过程（如下所列），isValid()函数判断是否符合选中条件。&lt;/p&gt;
&lt;p&gt;　　（1）从第一个 row=0 开始。&lt;/p&gt;
&lt;p&gt;　　（2）循环列并且试图在每个 column 中放置皇后。&lt;/p&gt;
&lt;p&gt;　　（3）如果方格 (row, column) 在攻击范围内，那么跳过。&lt;/p&gt;
&lt;p&gt;　　（4）在 (row, column) 方格上放置皇后，继续寻找下一个位置。&lt;/p&gt;
&lt;p&gt;　　（5）判断 row 是否和皇后数量相同。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
const N = 4&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; backtrack(route, row) {
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (row == N) {                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;结束条件&lt;/span&gt;
&lt;span&gt;    console.log(route);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
  }
  &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (let column = 0; column &amp;lt; N; column++&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;isValid(route, row, column))
      &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
    route[row] &lt;/span&gt;= column;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;做选择&lt;/span&gt;
    backtrack(route, row + 1);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;下一步&lt;/span&gt;
    route[row] = &lt;span&gt;null&lt;/span&gt;;          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;撤销选择（可省略）&lt;/span&gt;
&lt;span&gt;  }
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从下往上 判断row行column列放置是否合适&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; isValid(route, row, column) {
  let leftup &lt;/span&gt;= column - 1&lt;span&gt;,
    rightup &lt;/span&gt;= column + 1&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (let i = row - 1; i &amp;gt;= 0; i--) {        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 逐行往上考察每一行&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (route[i] == column)                   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第i行的column列有棋子&lt;/span&gt;
      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;     
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (leftup &amp;gt;= 0&lt;span&gt;) {            
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (route[i] == leftup)                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 考察左上对角线：第i行leftup列有棋子&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (rightup &amp;lt;&lt;span&gt; N) {
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (route[i] == rightup)                &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 考察右上对角线：第i行rightup列有棋子&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }
    leftup&lt;/span&gt;--&lt;span&gt;;
    rightup&lt;/span&gt;++&lt;span&gt;;
  }
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　有一个背包，背包总的承载重量是 Wkg。现在有 n 个物品，假设每个物品的重量都不相等，并且不可分割。期望选择几件物品，装载到背包中。在不超过背包容量的前提下，如何让背包中物品的总重量最大？&lt;/p&gt;
&lt;p&gt;　　把物品依次排列，对于物品选择装或不装，然后递归余下的物品，&lt;span&gt;&lt;a href=&quot;https://codepen.io/strick/pen/dyGrmzw&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;如下所示&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
let max =&lt;span&gt; Number.MIN_VALUE,
    W &lt;/span&gt;= 100&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; backtrack(route, goods) {
  let weight &lt;/span&gt;= route.length ? route.reduce((acc, cur) =&amp;gt; acc += cur) : 0&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (weight == W || route.length == goods.length) {    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;结束条件&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (weight &amp;gt; max &amp;amp;&amp;amp; weight &amp;lt;=&lt;span&gt; W) {
      max &lt;/span&gt;=&lt;span&gt; weight;
    }
    console.log(route);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
  }
  &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (let i = 0; i &amp;lt; goods.length; i++&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(weight + goods[i] &amp;gt; W || route.indexOf(goods[i]) &amp;gt; -1&lt;span&gt;)
      &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
    route.push(goods[i]);            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;做选择&lt;/span&gt;
&lt;span&gt;    backtrack(route, goods);
    route.pop();                     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;撤销选择&lt;/span&gt;
&lt;span&gt;  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　&lt;span&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/permutations/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;全排列&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;是指输出给定数字序列的全部可能的排列，假设序列中的数字都是唯一的，利用回溯算法枚举出所有排列，&lt;span&gt;&lt;a href=&quot;https://codepen.io/strick/pen/VweNBKd&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;如下所示&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; backtrack(route, nums) {
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (route.length == nums.length) {        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;结束条件&lt;/span&gt;
&lt;span&gt;    console.log(route);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
  }
  &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (let i = 0; i &amp;lt; nums.length; i++&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (route.indexOf(nums[i]) &amp;gt; -1&lt;span&gt;)
      &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
    route.push(nums[i]);        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;做选择&lt;/span&gt;
&lt;span&gt;    backtrack(route, nums);
    route.pop();                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;撤销选择&lt;/span&gt;
&lt;span&gt;  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　面试题17 &lt;span&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;打印从 1~n 位的数&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;。将问题转换成数字排列，用递归实现。&lt;/p&gt;

</description>
<pubDate>Tue, 22 Sep 2020 00:33:00 +0000</pubDate>
<dc:creator>咖啡机（K.F.J）</dc:creator>
<og:description>回溯算法（backtracking）是一个类似枚举的搜索尝试过程，在寻找问题解的过程中，当发现不满足求解条件时，就退回一步，尝试其它路径，该算法的时间复杂度都不会低于 O(N!)，复杂的例题包括正则表</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/strick/p/13384038.html</dc:identifier>
</item>
<item>
<title>知识全聚集 .Net Core 技术突破 | 如何实现一个模块化方案二 - 初久的私房菜</title>
<link>http://www.cnblogs.com/MrChuJiu/p/13708035.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/MrChuJiu/p/13708035.html</guid>
<description>&lt;p&gt;开讲第二篇，本篇代码并非Copy的ABP,只是参考ABP的功能，进行的实现方案，让代码更加通俗易懂。代码的讲解思路和上一篇一样，但是不引用上篇的写法。&lt;/p&gt;

&lt;h3 id=&quot;第一步-基本操作&quot;&gt;第一步 基本操作&lt;/h3&gt;
&lt;p&gt;还是老样子，我们新建一个模块化接口类&lt;br/&gt;新建接口 IAppModule (ps:项目中起的类名和方法名尽量对标ABP)&lt;br/&gt;&lt;img src=&quot;https://git.imweb.io/hdong/ImageBed/raw/master/StartModularImages/QQ20200918101729.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;   /// &amp;lt;summary&amp;gt;
    /// 应用模块接口定义
    /// &amp;lt;/summary&amp;gt;
    public interface IAppModule
    {
        /// &amp;lt;summary&amp;gt;
        /// 配置服务前
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;context&quot;&amp;gt;&amp;lt;/param&amp;gt;
        void OnPreConfigureServices();
        /// &amp;lt;summary&amp;gt;
        /// 配置服务
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;context&quot;&amp;gt;配置上下文&amp;lt;/param&amp;gt;
        void OnConfigureServices();
        /// &amp;lt;summary&amp;gt;
        /// 配置服务后
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;context&quot;&amp;gt;&amp;lt;/param&amp;gt;
        void OnPostConfigureServices();
        /// &amp;lt;summary&amp;gt;
        /// 应用启动前
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;context&quot;&amp;gt;&amp;lt;/param&amp;gt;
        void OnPreApplicationInitialization();
        /// &amp;lt;summary&amp;gt;
        /// 应用启动
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;context&quot;&amp;gt;&amp;lt;/param&amp;gt;
        void OnApplicationInitialization();
        /// &amp;lt;summary&amp;gt;
        /// 应用启动后
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;context&quot;&amp;gt;&amp;lt;/param&amp;gt;
        void OnPostApplicationInitialization();
        /// &amp;lt;summary&amp;gt;
        /// 应用停止
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;context&quot;&amp;gt;&amp;lt;/param&amp;gt;
        void OnApplicationShutdown();
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;新建类 AppModule 继承 IAppModule&lt;br/&gt;&lt;img src=&quot;https://git.imweb.io/hdong/ImageBed/raw/master/StartModularImages/QQ20200918101837.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;   public abstract class AppModule : IAppModule
    {
        public virtual void OnPreConfigureServices()
        {

        }

        public virtual void OnConfigureServices()
        {

        }

        public virtual void OnPostConfigureServices()
        {

        }

        public virtual void OnPreApplicationInitialization()
        {

        }

        public virtual void OnApplicationInitialization()
        {

        }

        public virtual void OnPostApplicationInitialization()
        {

        }
        public virtual void OnApplicationShutdown()
        {

        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;第二步-预准备&quot;&gt;第二步 预准备&lt;/h3&gt;
&lt;p&gt;这一步来完成ABP的DependsOnAttribute，通过特性进行引入模块，&lt;br/&gt;这里参数 params Type[] 因为一个模块会依赖多个模块&lt;br/&gt;新建类 DependsOnAttribute 继承 Attribute&lt;br/&gt;&lt;img src=&quot;https://git.imweb.io/hdong/ImageBed/raw/master/StartModularImages/QQ20200918104236.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
    /// 模块依赖的模块
    /// &amp;lt;/summary&amp;gt;
    [AttributeUsage(AttributeTargets.Class, AllowMultiple = true)]
    public class DependsOnAttribute : Attribute
    {
        /// &amp;lt;summary&amp;gt;
        /// 依赖的模块类型
        /// &amp;lt;/summary&amp;gt;
        public Type[] DependModuleTypes { get; private set; }

        public DependsOnAttribute(params Type[] dependModuleTypes)
        {
            DependModuleTypes = dependModuleTypes ?? new Type[0];
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;既然一个模块会包含多个模块的引用，那么就应该有一个存储的方式&lt;br/&gt;新建类 ModuleDescriptor 该类来存储 自身和引用的其他模块&lt;br/&gt;&lt;img src=&quot;https://git.imweb.io/hdong/ImageBed/raw/master/StartModularImages/QQ20200918102403.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    /// &amp;lt;summary&amp;gt;
    /// 模块描述
    /// &amp;lt;/summary&amp;gt;
    public class ModuleDescriptor
    {
        private object _instance;

        /// &amp;lt;summary&amp;gt;
        /// 模块类型
        /// &amp;lt;/summary&amp;gt;
        public Type ModuleType { get; private set; }

        /// &amp;lt;summary&amp;gt;
        /// 依赖项
        /// &amp;lt;/summary&amp;gt;
        public ModuleDescriptor[] Dependencies { get; private set; }

        /// &amp;lt;summary&amp;gt;
        /// 实例
        /// &amp;lt;/summary&amp;gt;
        public object Instance
        {
            get
            {
                if (this._instance == null)
                {
                    this._instance = Activator.CreateInstance(this.ModuleType);
                }
                return this._instance;
            }
        }

        public ModuleDescriptor(Type moduleType, params ModuleDescriptor[] dependencies)
        {
            this.ModuleType = moduleType;
            // 如果模块依赖 为空给一个空数组
            this.Dependencies = dependencies ?? new ModuleDescriptor[0];
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;第三步-模块管理器&quot;&gt;第三步 模块管理器&lt;/h3&gt;
&lt;p&gt;来到核心步骤，这里我们写模块管理器，白话就是存储模块和模块操作方法的一个类(同上一篇的StartupModulesOptions)&lt;br/&gt;第一步肯定是模块的启动&lt;br/&gt;我们新建 IModuleManager接口&lt;br/&gt;&lt;img src=&quot;https://git.imweb.io/hdong/ImageBed/raw/master/StartModularImages/QQ20200918101837.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; public interface IModuleManager : IDisposable
    {
        /// &amp;lt;summary&amp;gt;
        /// 启动模块
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;typeparam name=&quot;TModule&quot;&amp;gt;&amp;lt;/typeparam&amp;gt;
        void StartModule&amp;lt;TModule&amp;gt;(IServiceCollection services)
            where TModule : IAppModule;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;紧跟新建类 ModuleManager 继承 IModuleManager， StartModule 先放在一边&lt;br/&gt;这里的思路是：模块是从一个入口的根模块开始的慢慢的形成一个树状的引用关系，我们首先需要拿到所有的模块引用，并把他们从树叶为起点排列起来，依次注入。&lt;br/&gt;(理解为A=&amp;gt;B=&amp;gt;C 那么注入的顺序应该是 C=&amp;gt;B=&amp;gt;A)&lt;/p&gt;
&lt;h5 id=&quot;1先来实现根绝入口递归获取所有的引用关系-我已经在方法中将每一步的注释都写上了&quot;&gt;1.先来实现根绝入口递归获取所有的引用关系 我已经在方法中将每一步的注释都写上了&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://git.imweb.io/hdong/ImageBed/raw/master/StartModularImages/QQ20200921181020.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
        /// 获取模块依赖树
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;moduleType&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        protected virtual List&amp;lt;ModuleDescriptor&amp;gt; VisitModule(Type moduleType) {

            var moduleDescriptors = new List&amp;lt;ModuleDescriptor&amp;gt;();
            // 是否必须被重写|是否是接口|是否为泛型类型|是否是一个类或委托
            if (moduleType.IsAbstract || moduleType.IsInterface || moduleType.IsGenericType || !moduleType.IsClass) {
                return moduleDescriptors;
            }

            // 过滤没有实现IRModule接口的类
            var baseInterfaceType = moduleType.GetInterface(_moduleInterfaceTypeFullName, false);
            if (baseInterfaceType == null)
            {
                return moduleDescriptors;
            }

            // 得到当前模块依赖了那些模块
            var dependModulesAttribute = moduleType.GetCustomAttribute&amp;lt;DependsOnAttribute&amp;gt;();
            // 依赖属性为空
            if (dependModulesAttribute == null)
            {
                moduleDescriptors.Add(new ModuleDescriptor(moduleType));
            }
            else {
                // 依赖属性不为空,递归获取依赖
                var dependModuleDescriptors = new List&amp;lt;ModuleDescriptor&amp;gt;();
                foreach (var dependModuleType in dependModulesAttribute.DependModuleTypes)
                {
                    dependModuleDescriptors.AddRange(
                        VisitModule(dependModuleType)
                    );
                }
                // 创建模块描述信息,内容为模块类型和依赖类型
                moduleDescriptors.Add(new ModuleDescriptor(moduleType, dependModuleDescriptors.ToArray()));
            }

            return moduleDescriptors;
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;补：-_moduleinterfacetypefullname-定义&quot;&gt;补： _moduleInterfaceTypeFullName 定义&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;        /// &amp;lt;summary&amp;gt;
        /// 模块接口类型全名称
        /// &amp;lt;/summary&amp;gt;
        public static string _moduleInterfaceTypeFullName = typeof(IAppModule).FullName;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;2拿到依赖关系通过拓扑排序进行顺序处理-ps：拓扑排序地址-httpswwwcnblogscommyzonyp9201768html&quot;&gt;2.拿到依赖关系通过拓扑排序进行顺序处理 (ps：拓扑排序地址 &lt;a href=&quot;https://www.cnblogs.com/myzony/p/9201768.html&quot;&gt;https://www.cnblogs.com/myzony/p/9201768.html&lt;/a&gt;)&lt;/h5&gt;
&lt;p&gt;新建类 Topological 这块没啥特别要讲的根据链接去看下就好了&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    /// &amp;lt;summary&amp;gt;
    /// 拓扑排序工具类
    /// &amp;lt;/summary&amp;gt;
    public static class Topological
    {
        public static List&amp;lt;T&amp;gt; Sort&amp;lt;T&amp;gt;(IEnumerable&amp;lt;T&amp;gt; source, Func&amp;lt;T, IEnumerable&amp;lt;T&amp;gt;&amp;gt; getDependencies) {

            var sorted = new List&amp;lt;T&amp;gt;();
            var visited = new Dictionary&amp;lt;T, bool&amp;gt;();

            foreach (var item in source)
            {
                Visit(item, getDependencies, sorted, visited);
            }

            return sorted;
        }

        static void Visit&amp;lt;T&amp;gt;(T item, Func&amp;lt;T, IEnumerable&amp;lt;T&amp;gt;&amp;gt; getDependencies, List&amp;lt;T&amp;gt; sorted, Dictionary&amp;lt;T, bool&amp;gt; visited)
        {
            bool inProcess;
            var alreadyVisited = visited.TryGetValue(item, out inProcess);

            // 如果已经访问该顶点，则直接返回
            if (alreadyVisited)
            {
                // 如果处理的为当前节点，则说明存在循环引用
                if (inProcess)
                {
                    throw new ArgumentException(&quot;模块出现循环依赖.&quot;);
                }
            }
            else
            {
                // 正在处理当前顶点
                visited[item] = true;

                // 获得所有依赖项
                var dependencies = getDependencies(item);
                // 如果依赖项集合不为空，遍历访问其依赖节点
                if (dependencies != null)
                {
                    foreach (var dependency in dependencies)
                    {
                        // 递归遍历访问
                        Visit(dependency, getDependencies, sorted, visited);
                    }
                }

                // 处理完成置为 false
                visited[item] = false;
                sorted.Add(item);
            }
        }

    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;回到 ModuleManager 新建方法 ModuleSort&lt;br/&gt;&lt;img src=&quot;https://git.imweb.io/hdong/ImageBed/raw/master/StartModularImages/QQ20200921181427.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; /// &amp;lt;summary&amp;gt;
        /// 模块排序
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;typeparam name=&quot;TModule&quot;&amp;gt;&amp;lt;/typeparam&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        public virtual List&amp;lt;ModuleDescriptor&amp;gt; ModuleSort&amp;lt;TModule&amp;gt;() where TModule : IAppModule
        {
            // 得到模块树依赖
            var moduleDescriptors = VisitModule(typeof(TModule));
            // 因为现在得到的数据是从树根开始到树叶 - 实际的注入顺序应该是从树叶开始 所以这里需要对模块进行排序
            return Topological.Sort(moduleDescriptors, o =&amp;gt; o.Dependencies);
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;补：modulesort本来是个私有方法-后为了让模块使用者可以实现重写，请在-imodulemanager-加入&quot;&gt;补：ModuleSort本来是个私有方法 后为了让模块使用者可以实现重写，请在 IModuleManager 加入&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;        /// &amp;lt;summary&amp;gt;
        /// 模块排序
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;typeparam name=&quot;TModule&quot;&amp;gt;启动模块类型&amp;lt;/typeparam&amp;gt;
        /// &amp;lt;returns&amp;gt;排序结果&amp;lt;/returns&amp;gt;
        List&amp;lt;ModuleDescriptor&amp;gt; ModuleSort&amp;lt;TModule&amp;gt;()
            where TModule : IAppModule;

&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;3模块已经可以通过方法拿到了就来实现--startmodule-方法-筛选去重-依次进行注入，-并最终保存到全局对象中&quot;&gt;3.模块已经可以通过方法拿到了就来实现 StartModule 方法 筛选去重 依次进行注入， 并最终保存到全局对象中&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://git.imweb.io/hdong/ImageBed/raw/master/StartModularImages/QQ20200921181804.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;        /// &amp;lt;summary&amp;gt;
        /// 模块明细和实例
        /// &amp;lt;/summary&amp;gt;
        public virtual IReadOnlyList&amp;lt;ModuleDescriptor&amp;gt; ModuleDescriptors { get; protected set; }

        /// &amp;lt;summary&amp;gt;
        /// 入口 StartModule 
        /// 我们通过传递泛型进来的 TModule 为起点
        /// 查找他的依赖树
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;typeparam name=&quot;TModule&quot;&amp;gt;&amp;lt;/typeparam&amp;gt;
        /// &amp;lt;param name=&quot;services&quot;&amp;gt;&amp;lt;/param&amp;gt;
        public void StartModule&amp;lt;TModule&amp;gt;(IServiceCollection services) where TModule : IAppModule
        {

            var moduleDescriptors = new List&amp;lt;ModuleDescriptor&amp;gt;();

            var moduleDescriptorList = this.ModuleSort&amp;lt;TModule&amp;gt;();
            // 去除重复的引用 进行注入
            foreach (var item in moduleDescriptorList)
            {
                if (moduleDescriptors.Any(o =&amp;gt; o.ModuleType.FullName == item.ModuleType.FullName))
                {
                    continue;
                }
                moduleDescriptors.Add(item);
                services.AddSingleton(item.ModuleType, item.Instance);
            }
            ModuleDescriptors = moduleDescriptors.AsReadOnly();
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;4moduledescriptors既然存储着我们的所有模块，那么我们怎么执行模块的方法呢&quot;&gt;4.ModuleDescriptors既然存储着我们的所有模块，那么我们怎么执行模块的方法呢&lt;/h5&gt;
&lt;p&gt;入口通过调用下面的方法进行模块的方法调用&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;        /// &amp;lt;summary&amp;gt;
        /// 进行模块的  ConfigurationService 方法调用
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;services&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;configuration&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        public IServiceCollection ConfigurationService(IServiceCollection services, IConfiguration configuration) {

            foreach (var module in ModuleDescriptors)
            {
                (module.Instance as IAppModule)?.OnPreConfigureServices();
            }

            foreach (var module in ModuleDescriptors)
            {
                (module.Instance as IAppModule)?.OnConfigureServices();
            }

            foreach (var module in ModuleDescriptors)
            {
                (module.Instance as IAppModule)?.OnPostConfigureServices();
            }

            return services;
        }
        /// &amp;lt;summary&amp;gt;
        /// 进行模块的  Configure 方法调用
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;serviceProvider&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        public IServiceProvider ApplicationInitialization(IServiceProvider serviceProvider)
        {
            foreach (var module in ModuleDescriptors)
            {
                (module.Instance as IAppModule)?.OnPreApplicationInitialization();
            }

            foreach (var module in ModuleDescriptors)
            {
                (module.Instance as IAppModule)?.OnApplicationInitialization();
            }

            foreach (var module in ModuleDescriptors)
            {
                (module.Instance as IAppModule)?.OnPostApplicationInitialization();
            }

            return serviceProvider;
        }
        /// &amp;lt;summary&amp;gt;
        /// 模块销毁
        /// &amp;lt;/summary&amp;gt;
        public void ApplicationShutdown()
        {
            // todo我觉得这里有点问题问 易大师
            //var modules = ModuleDescriptors.Reverse().ToList();

            foreach (var module in ModuleDescriptors)
            {
                (module.Instance as IAppModule)?.OnApplicationShutdown();
            }
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然还漏了一个模块销毁,该方法在主模块被销毁的时候调用（ps: 我个人思路应该是从树叶开始进行，但是ABP对模块顺序进行了反转从根开始进行销毁，所以这里同上）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;        /// &amp;lt;summary&amp;gt;
        /// 主模块销毁的时候 销毁子模块
        /// &amp;lt;/summary&amp;gt;
        public void Dispose()
        {
            this.Dispose(true);
        }

        protected virtual void Dispose(bool state)
        {
            this.ApplicationShutdown();

        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;第四步--extensions&quot;&gt;第四步 Extensions&lt;/h3&gt;
&lt;p&gt;模块管理器写完了，那么这个方法如何调用呢来写我们的 Extensions&lt;br/&gt;新建 RivenModuleServiceCollectionExtensions 类，让其完成ConfigurationService方法的模块调用&lt;br/&gt;&lt;img src=&quot;https://git.imweb.io/hdong/ImageBed/raw/master/StartModularImages/QQ20200921185426.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; /// &amp;lt;summary&amp;gt;
    /// 模块服务扩展
    /// &amp;lt;/summary&amp;gt;
    public static class RivenModuleServiceCollectionExtensions
    {
        /// &amp;lt;summary&amp;gt;
        /// 添加Riven模块服务
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;typeparam name=&quot;TModule&quot;&amp;gt;&amp;lt;/typeparam&amp;gt;
        /// &amp;lt;param name=&quot;services&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;configuration&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        public static IServiceCollection AddRivenModule&amp;lt;TModule&amp;gt;(this IServiceCollection services, IConfiguration configuration)
            where TModule : IAppModule
        {
            var moduleManager = new ModuleManager();
            // 将模块都查询排序好
            moduleManager.StartModule&amp;lt;TModule&amp;gt;(services);
            // 调用模块 和 子模块的ConfigurationService方法
            moduleManager.ConfigurationService(services, configuration);
            // 注入全局的  IModuleManager
            services.TryAddSingleton&amp;lt;IModuleManager&amp;gt;(moduleManager);
            return services;
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;新建 RivenModuleIApplicationBuilderExtensions 类 ，让其完成Configuration方法的模块调用&lt;br/&gt;&lt;img src=&quot;https://git.imweb.io/hdong/ImageBed/raw/master/StartModularImages/QQ20200921185511.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; public static class RivenModuleIApplicationBuilderExtensions
    {
        /// &amp;lt;summary&amp;gt;
        /// 使用RivenModule
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;serviceProvider&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        public static IServiceProvider UseRivenModule(this IServiceProvider serviceProvider)
        {
            var moduleManager = serviceProvider.GetService&amp;lt;IModuleManager&amp;gt;();

            return moduleManager.ApplicationInitialization(serviceProvider);
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;第五步-测试&quot;&gt;第五步 测试&lt;/h3&gt;
&lt;p&gt;新建一个测试项目，引入写好的模块化类库，在 ConfigureServices 中调用&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;services.AddRivenModule&amp;lt;MyAppStartupModule&amp;gt;(Configuration);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Configure 中调用&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; app.ApplicationServices.UseRivenModule();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;模块销毁演示(ps:这个是演示效果、实际是在项目停止的时候进行。)&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; app.Map(&quot;/ApplicationShutdown&quot;, _ =&amp;gt;
            {
                _.Run((context) =&amp;gt;
                {
                    var moduleManager = app.ApplicationServices.GetService&amp;lt;IModuleManager&amp;gt;();
                    moduleManager.ApplicationShutdown();
                    return Task.FromResult(0);
                });
            });
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://git.imweb.io/hdong/ImageBed/raw/master/StartModularImages/QQ20200921185836.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;补：&quot;&gt;补：&lt;/h5&gt;
&lt;p&gt;新建 MyAppStartupModule、TestModuleA、TestModuleB 继承AppModule。&lt;br/&gt;MyAppStartupModule作为入口模块 引用 A =&amp;gt; B 然后在模块方法中打印 Console.WriteLine 看效果&lt;br/&gt;&lt;img src=&quot;https://git.imweb.io/hdong/ImageBed/raw/master/StartModularImages/QQ20200921190156.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;补充-给模块传递参数&quot;&gt;补充 给模块传递参数&lt;/h3&gt;
&lt;p&gt;新建 ApplicationInitializationContext 类&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class ApplicationInitializationContext
    {
        public IServiceProvider ServiceProvider { get; }

        public IConfiguration Configuration { get; }

        public ApplicationInitializationContext([NotNull] IServiceProvider serviceProvider, [NotNull] IConfiguration configuration)
        {
            ServiceProvider = serviceProvider;
            Configuration = configuration;
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;新建 ApplicationShutdownContext 类&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; public class ApplicationShutdownContext
    {
        public IServiceProvider ServiceProvider { get; }

        public ApplicationShutdownContext([NotNull] IServiceProvider serviceProvider)
        {
            ServiceProvider = serviceProvider;
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;新建 ServiceConfigurationContext 类&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; public class ServiceConfigurationContext
    {
        public IServiceCollection Services { get; protected set; }

        public IConfiguration Configuration { get; protected set; }


        public ServiceConfigurationContext(IServiceCollection services, IConfiguration configuration)
        {
            Services = services;
            Configuration = configuration;
        }

    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改 IAppModule 接口, 模块和实现都自己手动都同步一下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    /// &amp;lt;summary&amp;gt;
    /// 应用模块接口定义
    /// &amp;lt;/summary&amp;gt;
    public interface IAppModule
    {
        /// &amp;lt;summary&amp;gt;
        /// 配置服务前
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;context&quot;&amp;gt;&amp;lt;/param&amp;gt;
        void OnPreConfigureServices(ServiceConfigurationContext context);

        /// &amp;lt;summary&amp;gt;
        /// 配置服务
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;context&quot;&amp;gt;配置上下文&amp;lt;/param&amp;gt;
        void OnConfigureServices(ServiceConfigurationContext context);

        /// &amp;lt;summary&amp;gt;
        /// 配置服务后
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;context&quot;&amp;gt;&amp;lt;/param&amp;gt;
        void OnPostConfigureServices(ServiceConfigurationContext context);

        /// &amp;lt;summary&amp;gt;
        /// 应用启动前
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;context&quot;&amp;gt;&amp;lt;/param&amp;gt;
        void OnPreApplicationInitialization(ApplicationInitializationContext context);

        /// &amp;lt;summary&amp;gt;
        /// 应用启动
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;context&quot;&amp;gt;&amp;lt;/param&amp;gt;
        void OnApplicationInitialization(ApplicationInitializationContext context);

        /// &amp;lt;summary&amp;gt;
        /// 应用启动后
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;context&quot;&amp;gt;&amp;lt;/param&amp;gt;
        void OnPostApplicationInitialization(ApplicationInitializationContext context);

        /// &amp;lt;summary&amp;gt;
        /// 应用停止
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;context&quot;&amp;gt;&amp;lt;/param&amp;gt;
        void OnApplicationShutdown(ApplicationShutdownContext context);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改 ModuleManager的 ConfigurationService、ApplicationInitialization、ApplicationShutdown 方法给调用传递对应参数&lt;br/&gt;这部分代码我就不贴了，会的大佬都能自己写，想看的去我的github直接下载源码看吧，麻烦老板们给点个星星！！！&lt;/p&gt;

&lt;h3 id=&quot;知识全聚集，逐个击破：-httpsgithubcommrchujiueasycoreflow&quot;&gt;知识全聚集，逐个击破： &lt;a href=&quot;https://github.com/MrChuJiu/Easy.Core.Flow&quot;&gt;https://github.com/MrChuJiu/Easy.Core.Flow&lt;/a&gt;&lt;/h3&gt;

&lt;h3 id=&quot;玩双截棍的熊猫&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/staneee/&quot;&gt;玩双截棍的熊猫&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;源地址：httpsgithubcomrivenfxmodular&quot;&gt;源地址：&lt;a href=&quot;https://github.com/rivenfx/Modular&quot;&gt;https://github.com/rivenfx/Modular&lt;/a&gt;&lt;/h3&gt;
</description>
<pubDate>Tue, 22 Sep 2020 00:29:00 +0000</pubDate>
<dc:creator>初久的私房菜</dc:creator>
<og:description>简介 开讲第二篇，本篇代码并非Copy的ABP,只是参考ABP的功能，进行的实现方案，让代码更加通俗易懂。代码的讲解思路和上一篇一样，但是不引用上篇的写法。 开始 第一步 基本操作 还是老样子，我们新</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/MrChuJiu/p/13708035.html</dc:identifier>
</item>
<item>
<title>Apache Hudi和Presto的前世今生 - leesf</title>
<link>http://www.cnblogs.com/leesf456/p/13710005.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/leesf456/p/13710005.html</guid>
<description>&lt;p&gt;一篇由Apache Hudi PMC &lt;a href=&quot;https://www.linkedin.com/in/bhasudha&quot;&gt;Bhavani Sudha Saktheeswaran&lt;/a&gt;和AWS Presto团队工程师&lt;a href=&quot;https://www.linkedin.com/in/brandon-scheller-a00851ab&quot;&gt;Brandon Scheller&lt;/a&gt;分享Apache Hudi和Presto集成的一篇文章。&lt;/p&gt;
&lt;h2 id=&quot;1-概述&quot;&gt;1. 概述&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://hudi.apache.org/&quot;&gt;Apache Hudi&lt;/a&gt; 是一个快速迭代的数据湖存储系统，可以帮助企业构建和管理PB级数据湖，Hudi通过引入&lt;code&gt;upserts&lt;/code&gt;、&lt;code&gt;deletes&lt;/code&gt;和增量查询等原语将流式能力带入了批处理。这些特性使得统一服务层可提供更快、更新鲜的数据。Hudi表可存储在Hadoop兼容的分布式文件系统或者云上对象存储中，并且很好的集成了 &lt;a href=&quot;https://prestodb.io/&quot;&gt;Presto&lt;/a&gt;, &lt;a href=&quot;https://hive.apache.org/&quot;&gt;Apache Hive&lt;/a&gt;, &lt;a href=&quot;https://spark.apache.org/&quot;&gt;Apache Spark&lt;/a&gt; 和&lt;a href=&quot;https://impala.apache.org/&quot;&gt;Apache Impala&lt;/a&gt;。Hudi开创了一种新的模型（数据组织形式），该模型将文件写入到一个更受管理的存储层，该存储层可以与主流查询引擎进行互操作，同时在项目演变方面有了一些有趣的经验。&lt;/p&gt;
&lt;p&gt;本博客讨论Presto和Hudi集成的演变，同时讨论Presto-Hudi查询即将到来的文件Listing和查询计划优化。&lt;/p&gt;
&lt;h2 id=&quot;2-apache-hudi&quot;&gt;2. Apache Hudi&lt;/h2&gt;
&lt;p&gt;Apache Hudi（简称Hudi）提供在DFS上存储超大规模数据集，同时使得流式处理如果批处理一样，该实现主要是通过如下两个原语实现。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Update/Delete记录&lt;/strong&gt;: Hudi支持更新/删除记录，使用文件/记录级别索引，同时对写操作提供事务保证。查询可获取最新提交的快照来产生结果。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Change Streams&lt;/strong&gt;: Hudi也支持增量获取表中所有更新/插入/删除的记录，从指定时间点开始进行增量查询。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/616953/202009/616953-20200922074118607-1661651663.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图说明了Hudi的原语，配合这些原语可以直接在DFS抽象之上解锁流/增量处理功能。这和直接从Kafka Topic消费事件，然后使用状态存储来增量计算临时结果类似，该架构有很多优点。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;提升效率&lt;/strong&gt;: 摄取数据经常需要处理更新（例如CDC），删除（法律隐私条例）以及强制主键约束来确保数据质量。然而由于缺乏标准工具，数据工程师往往需要使用批处理作业来重新处理整天的事件或者每次运行时重新加载上游所有数据，这会导致浪费大量的资源。由于Hudi支持记录级别更新，只需要重新处理表中更新/删除的记录，大大提升了处理效率，而无需重写表的所有分区或事件。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;更快的ETL/派生管道&lt;/strong&gt;: 还有一种普遍情况，即一旦从外部源摄取数据，就使用Apache Spark/Apache Hive或任何其他数据处理框架构建派生的数据管道，以便为各种用例（如数据仓库、机器学习功能提取，甚至仅仅是分析）构建派生数据管道。通常该过程再次依赖于以代码或SQL表示的批处理作业，批量处理所有输入数据并重新计算所有输出结果。通过使用增量查询（而不是常规快照查询）查询一个或多个输入表，从而只处理来自上游表的增量更改，然后对目标派生表执行upsert或delete操作，可以显著加快这种数据管道的速度，如第一个图所示。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;更新鲜的数据访问&lt;/strong&gt;: 通常我们会添加更多的资源（例如内存）来提高性能指标（例如查询延迟）。Hudi从根本上改变了数据集的传统管理方式，这可能是大数据时代出现以来的第一次。增量地进行批处理可以使得管道运行时间少得多。相比以前的数据湖，现在数据可更快地被查询。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;统一存储&lt;/strong&gt;: 基于以上三个优点，在现有数据湖上进行更快、更轻的处理意味着不需要仅为了获得接近实时数据的访问而使用专门存储或数据集市。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;21-hudi表和查询类型&quot;&gt;2.1 Hudi表和查询类型&lt;/h3&gt;
&lt;h4 id=&quot;211-表类型&quot;&gt;2.1.1 表类型&lt;/h4&gt;
&lt;p&gt;Hudi支持如下两种类型表&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Copy On Write (COW)&lt;/strong&gt;: 使用列式存储格式（如parquet）存储数据，在写入时同步更新版本/重写数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Merge On Read (MOR)&lt;/strong&gt;: 使用列式存储格式（如parquet）+ 行存（如Avro）存储数据。更新被增量写入delta文件，后续会进行同步/异步压缩产生新的列式文件版本。&lt;/p&gt;
&lt;p&gt;下表总结了两种表类型的trade-off。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Trade-off&lt;/th&gt;
&lt;th&gt;CopyOnWrite&lt;/th&gt;
&lt;th&gt;MergeOnRead&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr&gt;&lt;td&gt;数据延迟&lt;/td&gt;
&lt;td&gt;更高&lt;/td&gt;
&lt;td&gt;更低&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;更新开销 (I/O)&lt;/td&gt;
&lt;td&gt;高(重写整个parquet文件)&lt;/td&gt;
&lt;td&gt;更低 (写入增量日志文件)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Parquet文件大小&lt;/td&gt;
&lt;td&gt;更小(高update (I/0) 开销)&lt;/td&gt;
&lt;td&gt;更大 (低updaet开销)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;写放大&lt;/td&gt;
&lt;td&gt;更低 (决定与Compaction策略)&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4 id=&quot;212-查询类型&quot;&gt;2.1.2 查询类型&lt;/h4&gt;
&lt;p&gt;Hudi支持如下查询类型&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;快照查询&lt;/strong&gt;: 查询给定commit/compaction的表的最新快照。对于Merge-On-Read表，通过合并基础文件和增量文件来提供近实时数据（分钟级）；对于Copy-On-Write表，对现有Parquet表提供了一个可插拔替换，同时提供了upsert/delete和其他特性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;增量查询&lt;/strong&gt;: 查询给定commit/compaction之后新写入的数据，可为增量管道提供变更流。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;读优化查询&lt;/strong&gt;: 查询给定commit/compaction的表的最新快照。只提供最新版本的基础/列式数据文件，并可保证与非Hudi表相同的列式查询性能。&lt;/p&gt;
&lt;p&gt;下表总结了不同查询类型之间的trade-off。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Trade-off&lt;/th&gt;
&lt;th&gt;快照&lt;/th&gt;
&lt;th&gt;读优化&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr&gt;&lt;td&gt;数据延迟&lt;/td&gt;
&lt;td&gt;更低&lt;/td&gt;
&lt;td&gt;更高&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;查询延迟&lt;/td&gt;
&lt;td&gt;&lt;em&gt;COW&lt;/em&gt;: 与parquet表相同。&lt;em&gt;MOR&lt;/em&gt;: 更高 (合并基础/列式文件和行存增量文件)&lt;/td&gt;
&lt;td&gt;与COW快照查询有相同列式查询性能&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;下面动画简单演示了插入/更新如何存储在COW和MOR表中的步骤，以及沿着时间轴的查询结果。其中X轴表示每个查询类型的时间轴和查询结果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/616953/202009/616953-20200922074133185-165208053.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意，作为写操作的一部分，表的commit被完全合并到表中。对于更新，包含该记录的文件将使用所有已更改记录的新值重新写入。对于插入，优先会将记录写入到每个分区路径中最小文件，直到它达到配置的最大大小。其他剩余的记录都将写入新的文件id组中，会保证再次满足大小要求。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/616953/202009/616953-20200922074144878-362310362.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;MOR和COW在摄取数据方面经历了相同步骤。更新将写入属于最新文件版本的最新日志（delta）文件，而不进行合并。对于插入，Hudi支持2种模式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;写入log文件 - 当Hudi表可索引日志文件（例如HBase索引和即将到来的记录级别索引）。&lt;/li&gt;
&lt;li&gt;写入parquet文件 - 当Hudi表不能索引日志文件（例如布隆索引）。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;增量日志文件后面通过时间轴中的压缩（compaction）操作与基础parquet文件合并。这种表类型是最通用、高度高级的，为写入提供很大灵活性（指定不同的压缩策略、处理突发性写入流量等）和查询提供灵活性（例如权衡数据新鲜度和查询性能）。&lt;/p&gt;
&lt;h2 id=&quot;3-presto&quot;&gt;3. Presto&lt;/h2&gt;
&lt;h3 id=&quot;31-早期presto集成方案&quot;&gt;3.1 早期Presto集成方案&lt;/h3&gt;
&lt;p&gt;Hudi设计于2016年中后期。那时我们就着手与Hadoop生态系统中的查询引擎集成。为了在Presto中实现这一点，正如社区建议的那样，我们引入了一个自定义注解&lt;code&gt;@UseFileSplitsFromInputFormat&lt;/code&gt;。任何注册的Hive表（如果有此注解）都将通过调用相应的inputformat的&lt;code&gt;getSplits()&lt;/code&gt;方法（而不是Presto Hive原生切片加载逻辑）来获取切片。通过Presto查询的Hudi表，只需简单调用&lt;code&gt;HoodieParquetInputFormat.getSplits()&lt;/code&gt;. 集成非常简单只，需将相应的Hudi jar包放到&lt;code&gt;&amp;lt;presto_install&amp;gt;/plugin/hive-hadoop2/&lt;/code&gt;目录下。它支持查询COW Hudi表，并读取MOR Hudi表的优化查询（只从压缩的基本parquet文件中获取数据）。在Uber，这种简单的集成已经支持每天超过100000次的Presto查询，这些查询来自使用Hudi管理的HDFS中的100PB的数据（原始数据和模型表）。&lt;/p&gt;
&lt;h3 id=&quot;32-移除inputformatgetsplits&quot;&gt;3.2 移除InputFormat.getSplits()&lt;/h3&gt;
&lt;p&gt;调用&lt;code&gt;inputformat.getSplits()&lt;/code&gt;是个简单的集成，但是可能会导致对NameNode的大量RPC调用，以前的集成方法有几个缺点。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;从Hudi返回的InputSplits不够。Presto需要知道每个InputSplit返回的文件状态和块位置。因此，对于每次切片乘以加载的分区数，这将增加2个额外的NameNode RPC调用。有时，NameNode承受很大的压力，会观察到背压。&lt;/li&gt;
&lt;li&gt;此外对于Presto Split计算中加载的每个分区（每个&lt;code&gt;loadPartition()&lt;/code&gt;调用），&lt;code&gt;HoodieParquetInputFormat.getSplits()&lt;/code&gt;将被调用。这导致了冗余的Hudi表元数据Listing，其实可以被属于从查询扫描的表的所有分区复用。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们开始重新思考Presto-Hudi的整合方案。在Uber，我们通过在Hudi上添加一个编译时依赖项来改变这个实现，并在&lt;code&gt;BackgroundHiveSplitLoader&lt;/code&gt;构造函数中实例化&lt;code&gt;HoodieTableMetadata&lt;/code&gt;一次。然后我们利用Hudi Api过滤分区文件，而不是调用&lt;code&gt;HoodieParquetInputFormat.getSplits()&lt;/code&gt;，这大大减少了该路径中NameNode调用次数。&lt;/p&gt;
&lt;p&gt;为了推广这种方法并使其可用于Presto-Hudi社区，我们在Presto的&lt;code&gt;DirectoryLister&lt;/code&gt;接口中添加了一个新的API，它将接受&lt;code&gt;PathFilter&lt;/code&gt;对象。对于Hudi表，我们提供了这个PathFilter对象&lt;code&gt;HoodieROTablePathFilter&lt;/code&gt;，它将负责过滤为查询Hudi表而预先列出的文件，并获得与Uber内部解决方案相同的结果。&lt;/p&gt;
&lt;p&gt;这一变化是从&lt;strong&gt;0.233&lt;/strong&gt;版本的Presto开始提供，依赖Hudi版本为0.5.1-incubating。由于Hudi现在是一个编译时依赖项，因此不再需要在plugin目录中提供Hudi jar文件。&lt;/p&gt;
&lt;h3 id=&quot;33-presto支持查询hudi-mor表&quot;&gt;3.3 Presto支持查询Hudi MOR表&lt;/h3&gt;
&lt;p&gt;我们看到社区有越来越多人对使用Presto支持Hudi MOR表的快照查询感兴趣。之前Presto只支持查询Hudi表读优化查询（纯列式数据）。随着该PR &lt;a href=&quot;https://github.com/prestodb/presto/pull/14795%E8%A2%AB%E5%90%88%E5%85%A5%EF%BC%8C%E7%8E%B0%E5%9C%A8Presto%EF%BC%88&quot;&gt;https://github.com/prestodb/presto/pull/14795被合入，现在Presto（&lt;/a&gt;&lt;strong&gt;0.240及后面版本&lt;/strong&gt;）已经支持查询MOR表的快照查询，这将通过在读取时合并基本文件（parquet数据）和日志文件（avro数据）使更新鲜的数据可用于查询。&lt;/p&gt;
&lt;p&gt;在Hive中，这可以通过引入一个单独的&lt;code&gt;InputFormat&lt;/code&gt;类来实现，该类提供了处理切片的方法，并引入了一个新的&lt;code&gt;RecordReader&lt;/code&gt;类，该类可以扫描切片以获取记录。对于使用Hive查询MOR Hudi表，在Hudi中已经有类似类可用：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;InputFormat&lt;/code&gt; - &lt;code&gt;org.apache.hudi.hadoop.realtime.HoodieParquetRealtimeInputFormat&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;InputSplit&lt;/code&gt; - &lt;code&gt;org.apache.hudi.hadoop.realtime.HoodieRealtimeFileSplit&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RecordReader&lt;/code&gt; - &lt;code&gt;org.apache.hudi.hadoop.realtime.HoodieRealtimeRecordReader&lt;/code&gt; 在Presto中支持这一点需要理解Presto如何从Hive表中获取记录，并在该层中进行必要的修改。因为Presto使用其原生的&lt;code&gt;ParquetPageSource&lt;/code&gt;而不是InputFormat的记录读取器，Presto将只显示基本Parquet文件，而不显示来自Hudi日志文件的实时更新，后者是avro数据（本质上与普通的读优化Hudi查询相同）。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;为了让Hudi实时查询正常工作，我们确定并进行了以下必要更改：&lt;/p&gt;
&lt;ul readability=&quot;7&quot;&gt;&lt;li readability=&quot;7&quot;&gt;
&lt;p&gt;向可序列化HiveSplit添加额外的元数据字段以存储Hudi切片信息。Presto-Hive将其拆分转换为可序列化的HiveSplit以进行传递。因为它需要标准的切片，所以它将丢失从FileSplit扩展的复杂切片中包含的任何额外信息的上下文。我们的第一个想法是简单地添加整个切片作为&lt;code&gt;HiveSplit&lt;/code&gt;的一个额外的字段。但这并不起作用，因为复杂的切片不可序列化，而且还会复制基本切片数据。&lt;/p&gt;
&lt;p&gt;相反我们添加了一个&lt;code&gt;CustomSplitConverter&lt;/code&gt;接口。它接受一个自定义切片并返回一个易于序列化的String-&amp;gt;String Map，其中包含来自自定义切片的额外数据。为了实现这点，我们还将此Map作为一个附加字段添加到Presto的HiveSplit中。我们创建了&lt;code&gt;HudiRealtimeSplitConverter&lt;/code&gt;来实现用于Hudi实时查询的&lt;code&gt;CustomSplitConverter&lt;/code&gt;接口。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;从HiveSplit的额外元数据重新创建Hudi切片。现在我们已经掌握了HiveSplit中包含的自定义切片的完整信息，我们需要在读取切片之前识别并重新创建&lt;code&gt;HoodieRealtimeFileSplit&lt;/code&gt;。&lt;code&gt;CustomSplitConverter&lt;/code&gt;接口还有另一个方法，它接受普通的FileSplit和额外的split信息映射，并返回实际复杂的FileSplit，在本例中是&lt;code&gt;HudiRealtimeFileSplit&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;使用&lt;code&gt;HoodieParquetRealtimeInputFormat&lt;/code&gt;中的&lt;code&gt;HoodieRealtimeRecordReader&lt;/code&gt;读取重新创建的&lt;code&gt;HoodieRealtimeFileSplit&lt;/code&gt;。Presto需要使用新的记录读取器来正确处理&lt;code&gt;HudiRealtimeFileSplit&lt;/code&gt;中的额外信息。为此，我们引入了与第一个注释类似的另一个注解&lt;code&gt;@UseRecordReaderFromInputFormat&lt;/code&gt;。这指示Presto使用Hive记录光标（使用&lt;code&gt;InputFormat&lt;/code&gt;的记录读取器）而不是&lt;code&gt;PageSource&lt;/code&gt;。Hive记录光标可以理解重新创建的自定义切片，并基于自定义切片设置其他信息/配置。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;有了这些变更，Presto用户便可查询Hudi MOR表中更新鲜的数据了。&lt;/p&gt;
&lt;h2 id=&quot;4-下一步计划&quot;&gt;4. 下一步计划&lt;/h2&gt;
&lt;p&gt;下面是一些很有意思的工作（&lt;a href=&quot;https://cwiki.apache.org/confluence/display/HUDI/RFC+Process&quot;&gt;RFCs&lt;/a&gt;)，可能也需要在Presto中支持。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://cwiki.apache.org/confluence/display/HUDI/RFC+-+12+%3A+Efficient+Migration+of+Large+Parquet+Tables+to+Apache+Hudi&quot;&gt;RFC-12: Bootstrapping Hudi tables efficiently&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ApacheHudi维护每个记录的元数据，使我们能够提供记录级别的更新、唯一的键语义和类似数据库的更改流。然而这意味着，要利用Hudi的upsert和增量处理能力，用户需要重写整个数据集，使其成为Hudi表。这个RFC提供了一种机制来高效地迁移他们的数据集，而不需要重写整个数据集，同时还提供了Hudi的全部功能。&lt;/p&gt;
&lt;p&gt;这将通过在新的引导Hudi表中引用外部数据文件（来自源表）的机制来实现。由于数据可能驻留在外部位置（引导数据）或Hudi表的basepath（最近的数据）下，FileSplits将需要在这些位置上存储更多的元数据。这项工作还将利用并建立在我们当前添加的Presto MOR查询支持之上。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/HUDI-887&quot;&gt;支持Hudi表增量和时间点时间旅行查询&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;增量查询允许我们从源Hudi表中提取变更日志。时间点查询允许在时间T1和T2之间获取Hudi表的状态。这些已经在Hive和Spark中得到支持。我们也在考虑在Presto中支持这个特性。&lt;/p&gt;
&lt;p&gt;在Hive中，通过在&lt;code&gt;JobConf&lt;/code&gt;中设置一些配置来支持增量查询，例如-query mode设置为&lt;code&gt;INCREMENTAL&lt;/code&gt;、启动提交时间和要使用的最大提交数。在Spark中有一个特定的实现来支持增量查询—&lt;code&gt;IncrementalRelation&lt;/code&gt;。为了在Presto中支持这一点，我们需要一种识别增量查询的方法。如果Presto不向hadoop Configuration对象传递会话配置，那么最初的想法是在metastore中将同一个表注册为增量表。然后使用查询谓词获取其他详细信息，如开始提交时间、最大提交时间等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://cwiki.apache.org/confluence/display/HUDI/RFC+-+15%3A+HUDI+File+Listing+and+Query+Planning+Improvements&quot;&gt;RFC-15: 查询计划和Listing优化&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Hudi write client和Hudi查询需要对文件系统执行&lt;code&gt;listStatus&lt;/code&gt;操作以获得文件系统的当前视图。在Uber，HDFS基础设施为Listing做了大量优化，但对于包含数千个分区的大型数据集以及每个分区在云/对象存储上有数千个文件的大型数据集来说，这可能是一个昂贵的操作。上面的RFC工作旨在消除Listing操作，提供更好的查询性能和更快的查找，只需将Hudi的时间轴元数据逐渐压缩到表状态的快照中。&lt;/p&gt;
&lt;p&gt;该方案旨在解决：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;存储和维护最新文件的元数据&lt;/li&gt;
&lt;li&gt;维护表中所有列的统计信息，以帮助在扫描之前有效地修剪文件，这可以在引擎的查询规划阶段使用。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;为此，Presto也需要一些变更。我们正在积极探索在查询规划阶段利用这些元数据的方法。这将是对Presto-Hudi集成的重要补充，并将进一步降低查询延迟。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://cwiki.apache.org/confluence/display/HUDI/RFC+-+08+%3A+Record+level+indexing+mechanisms+for+Hudi+datasets&quot;&gt;记录级别索引&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Upsert是Hudi表上一种流行的写操作，它依赖于索引将传入记录标记为Upsert。&lt;code&gt;HoodieIndex&lt;/code&gt;在分区或非分区数据集中提供记录id到文件id的映射，实现有BloomFilters/Key ranges（用于临时数据）和Apache HBase（用于随机更新）支持。许多用户发现Apache HBase（或任何类似的key-value-store-backed索引）很昂贵，并且增加了运维开销。该工作试图提出一种新的索引格式，用于记录级别的索引，这是在Hudi中实现的。Hudi将存储和维护记录级索引（有HFile、RocksDB等可插拔存储实现支持）。这将被writer（摄取）和reader（摄取/查询）使用，并将显著提高upsert性能，而不是基于join的方法，或者是用于支持随机更新工作负载的布隆索引。这是查询引擎在列出文件之前修剪文件时可以利用这些信息的另一个领域。我们也在考虑一种在查询时利用Presto中的元数据的方法。&lt;/p&gt;
&lt;h2 id=&quot;5-总结&quot;&gt;5. 总结&lt;/h2&gt;
&lt;p&gt;像Presto这样的查询引擎是用户了解Hudi优势的入口。随着不断增长的社区和活跃的开发路线图，Hudi中有许多有趣的工作，由于Hudi在上面的工作上投入了大量精力，因此只需要与Presto这样的系统进行深度集成。为此，我们期待着与Presto社区合作。我们欢迎您的建议反馈，并鼓励您作出&lt;a href=&quot;https://github.com/apache/hudi/issues&quot;&gt;贡献&lt;/a&gt; ，与&lt;a href=&quot;https://hudi.apache.org/community.html&quot;&gt;我们&lt;/a&gt;联系。&lt;/p&gt;
&lt;p&gt;英文链接：&lt;a href=&quot;https://prestodb.io/blog/2020/08/04/prestodb-and-hudi&quot;&gt;https://prestodb.io/blog/2020/08/04/prestodb-and-hudi&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 21 Sep 2020 23:42:00 +0000</pubDate>
<dc:creator>leesf</dc:creator>
<og:description>一篇由Apache Hudi PMC Bhavani Sudha Saktheeswaran和AWS Presto团队工程师Brandon Scheller分享Apache Hudi和Presto集成</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/leesf456/p/13710005.html</dc:identifier>
</item>
<item>
<title>Jackson精解第4篇-@JacksonInject与@JsonAlias注解 - 字母哥博客</title>
<link>http://www.cnblogs.com/zimug/p/13709986.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zimug/p/13709986.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1815316/202009/1815316-20200922071701004-1976783452.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Jackson是Spring Boot(SpringBoot)默认的JSON数据处理框架，但是其并不依赖于任何的Spring 库。有的小伙伴以为Jackson只能在Spring框架内使用，其实不是的，没有这种限制。它提供了很多的JSON数据处理方法、注解，也包括&lt;strong&gt;流式API、树模型、数据绑定&lt;/strong&gt;，以及复杂数据类型转换等功能。它虽然简单易用，但绝对不是小玩具，&lt;strong&gt;更多的内容我会写成一个系列，5-10篇文章，请您继续关注我。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本节继续为大家介绍在JSON反序列化过程中，如何使用&lt;code&gt;@JacksonInject&lt;/code&gt;注解和&lt;code&gt;@JsonAlias&lt;/code&gt;注解&lt;/p&gt;
&lt;h2 id=&quot;一、jacksoninject注解&quot;&gt;一、&lt;code&gt;@JacksonInject&lt;/code&gt;注解&lt;/h2&gt;
&lt;p&gt;在使用JSON格式进行反序列化的时候，我们经常有这样一些需求。我们从客户端或者其他渠道获取了一个JSON格式的数据对象，该对象包含若干个属性。但是我们在将JSON字符串反序列化的时候，需要给它加上一些默认数据，比如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;responseTime数据响应时间，赋值为当前时间即可；&lt;/li&gt;
&lt;li&gt;数据反序列化的操作人，赋值为系统当前用户等&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;客户端返回给我们的数据本身不会携带这些附加信息，这个时候我们就可以使用JacksonInject注解，在JSON字符串反序列化为对象的时候，加上这些附加信息。下面是JacksonInject使用方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Data
public class PlayerStar {

  private String name;
  private Integer age;
  private String[] hobbies;    //业余爱好,数组
  private List&amp;lt;String&amp;gt; friends;   //  朋友
  private Map&amp;lt;String, BigDecimal&amp;gt; salary; //年收入 Map

  @JacksonInject(&quot;responseTime&quot;)      //注意这里
  private LocalDateTime responseTime;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们来测试一下反序列化的过程，需要注意的是下文中的jsonInString中并不携带responseTime信息，是我们自己在反序列化的时候注入到java对象中的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Test
void testJSON2Object() throws IOException {
  //为responseTime赋值为当前值
  InjectableValues.Std iv = new InjectableValues.Std();
  iv.addValue(&quot;responseTime&quot;, LocalDateTime.now());

  ObjectMapper mapper = new ObjectMapper();
  mapper.setInjectableValues(iv);       //将可插入值，在反序列化过程中赋值给对象
  
  //将JSON字符串反序列化为java对象
  String jsonInString = &quot;{\&quot;name\&quot;:\&quot;乔丹\&quot;,\&quot;age\&quot;:45,\&quot;hobbies\&quot;:[\&quot;高尔夫球\&quot;,\&quot;棒球\&quot;]}&quot;;
  PlayerStar jordan = mapper.readValue(jsonInString, PlayerStar.class);

  System.out.println(jordan);

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最终的反序列化结果,java 对象的toString()方法输出结果如下，可以看到多出一个responseTime赋值属性，值为当前时间&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;PlayerStar(name=乔丹, age=45, hobbies=[高尔夫球, 棒球], friends=null, salary=null, responseTime=2020-09-22T06:41:09.192)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;二、按照数据类型type进行数据注入&quot;&gt;二、按照数据类型type进行数据注入&lt;/h2&gt;
&lt;p&gt;在上文的代码中，JSON字符串反序列化为对象，使用的是属性id的方法进行注入的&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  @JacksonInject(&quot;responseTime&quot;)      //注意这里responseTime为属性id
  private LocalDateTime responseTime;
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;  InjectableValues.Std iv = new InjectableValues.Std();
  iv.addValue(&quot;responseTime&quot;, LocalDateTime.now());  //注意这里responseTime为属性id，而这要统一
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;除了可以按照属性id进行数据的注入，还可以使用java type数据类型进行数据注入。这种方法在一个java 类中，多个成员变量数据类型重复的时候，比如定义多个LocalDateTime成员变量，用起来就不太方便了。所以还是建议大家使用属性id的方法进行注入数据注入。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  @JacksonInject
  private LocalDateTime responseTime;
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;  InjectableValues.Std iv = new InjectableValues.Std();
  iv.addValue(LocalDateTime.class, LocalDateTime.now());  //注意这里LocalDateTime.class
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;当我们在开发过程中，可能在v1.0的版本中我们定义的PlayerStar类(上文)包含name属性，但是我们用着用着发现name这个单词太通用了，在很多的地方都是系统关键字；我们希望在v2.0版本中，给这个成员变量换一个名字，叫做starName，或者playerName。但是我们不希望用户废弃v1.0的接口。&lt;br/&gt;也就是说我们希望做到多版本兼容，客户端传送过来的JSON字符串，可以是name、可以是playerName、可以是starName。我们该怎么做？答案是使用&lt;code&gt;@JsonAlias&lt;/code&gt;注解&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Data
public class PlayerStar {

  @JsonAlias({&quot;starName&quot;, &quot;playerName&quot; })
  private String name;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面三种JSON格式数据都可以被正确的反序列化为PlayerStar对象，并为name成员变量赋值&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;String jsonInString = &quot;{\&quot;name\&quot;:\&quot;乔丹\&quot;,\&quot;age\&quot;:45,\&quot;hobbies\&quot;:[\&quot;高尔夫球\&quot;,\&quot;棒球\&quot;]}&quot;;
String jsonInString = &quot;{\&quot;starName\&quot;:\&quot;乔丹\&quot;,\&quot;age\&quot;:45,\&quot;hobbies\&quot;:[\&quot;高尔夫球\&quot;,\&quot;棒球\&quot;]}&quot;;
String jsonInString = &quot;{\&quot;playerName\&quot;:\&quot;乔丹\&quot;,\&quot;age\&quot;:45,\&quot;hobbies\&quot;:[\&quot;高尔夫球\&quot;,\&quot;棒球\&quot;]}&quot;;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;欢迎关注我的博客，里面有很多精品合集&quot;&gt;欢迎关注我的博客，里面有很多精品合集&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;本文转载注明出处（必须带连接，不能只转文字）：&lt;a href=&quot;http://www.zimug.com&quot;&gt;字母哥博客&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;觉得对您有帮助的话，帮我点赞、分享！您的支持是我不竭的创作动力！&lt;/strong&gt; 。另外，笔者最近一段时间输出了如下的精品内容，期待您的关注。&lt;/p&gt;
</description>
<pubDate>Mon, 21 Sep 2020 23:17:00 +0000</pubDate>
<dc:creator>字母哥博客</dc:creator>
<og:description>Jackson是Spring Boot(SpringBoot)默认的JSON数据处理框架，但是其并不依赖于任何的Spring 库。有的小伙伴以为Jackson只能在Spring框架内使用，其实不是的，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zimug/p/13709986.html</dc:identifier>
</item>
<item>
<title>鼠标修复升级记录（下） - jerry_fuyi</title>
<link>http://www.cnblogs.com/jerry-fuyi/p/13709721.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jerry-fuyi/p/13709721.html</guid>
<description>&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/jerry-fuyi/p/13653507.html&quot; target=&quot;_blank&quot;&gt;上回&lt;/a&gt;写到要解决噪音问题。尽管实测青轴比微动吵得多，但静音微动买都买了，还是给换上吧。&lt;/p&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/1734552/202009/1734552-20200922023630386-632856814.jpg&quot; width=&quot;400&quot;/&gt;&lt;p&gt;原来的微动是3脚的，新买的静音微动是2脚的，它们是否兼容呢？我们注意到3脚微动上标有&lt;code&gt;C&lt;/code&gt;、&lt;code&gt;NO&lt;/code&gt;和&lt;code&gt;NC&lt;/code&gt;字样，意为微动未被按下时&lt;code&gt;C&lt;/code&gt;和&lt;code&gt;NC&lt;/code&gt;连接，按下时&lt;code&gt;C&lt;/code&gt;和&lt;code&gt;NO&lt;/code&gt;连接。按键显然是按下时两引脚连接，这样看来这两个引脚的连接没有问题。那么还有一个空余的呢？首先从功能上说没有必要使用，其次我观察PCB发现它并没有连接，所以就放心换上。&lt;/p&gt;
&lt;p&gt;我有拆焊台，就不需要电热吸锡器之类的了。先用热风枪300度最小风吹，发现吹不化，升到350依然如此。我就抹了点助焊膏，用电烙铁先化一下，然后就容易吹下来了。另一个微动我想换种方法拆，就用尖头横着同时加热3个焊盘，有点别扭但也取下来了。之后就先空心针，再插入新的器件，最后焊上就好了。&lt;/p&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/1734552/202009/1734552-20200922023636987-354359359.jpg&quot; width=&quot;400&quot;/&gt;&lt;p&gt;这还没有结束。还记得当初第一次拆开它时的惊艳：无需很复杂的电路和机械结构就能实现许多普通鼠标没有的功能；部件之间严丝合缝，十分精巧，至少相比于我自己做的项目来说是这样。&lt;/p&gt;
&lt;p&gt;从电源看起吧。整个鼠标的电源都来自一节5号电池，其插座并不是网上可以买到的那种电池座，而是由外壳上的位置和焊在PCB上的电极组成的（图见上篇）。&lt;/p&gt;
&lt;p&gt;1.5V啥都干不了。我一看那黑色的电感和两个尺寸显著超出其余元件的电容就知道这部分是一个升压电路。升压芯片丝印VUAI，反查得型号为TLV61220，是常见的TI升压芯片。用万用表测得输出电压约为2.2V，差不多刚好够LED用。&lt;/p&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/1734552/202009/1734552-20200922023643495-269699596.jpg&quot; width=&quot;400&quot;/&gt;&lt;p&gt;我认为这升压电路并不是专为LED准备的。如果1.5V电池直接给主控供电，在假设主控能在1.5V下工作的前提下，点亮LED可以用很简单的电荷泵，由于LED就开机后亮几秒，这种方案的平均功耗会更低。然而问题在于5号电池的电压并不一直是1.5V，只有全新的时候才是，放电过程中有一半的容量都在1.3V以下，很可能难以支持主控运行。而在升压电路的方案下，鼠标可以在电池电压低于1V时工作，反而是更高效地利用了电池。&lt;/p&gt;
&lt;p&gt;唯一的缺点是它耗电太慢了。我积攒了很多别的设备中淘汰下来的电池，电压都在1V以上，但是根本用不完。&lt;/p&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/1734552/202009/1734552-20200922023650253-273591926.png&quot; width=&quot;400&quot;/&gt;&lt;p&gt;↑5号碱性电池的典型放电曲线，图源&lt;a href=&quot;https://www.ti.com/lit/an/slva194/slva194.pdf&quot; target=&quot;_blank&quot;&gt;SLVA194&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;鼠标的主控是NRF31512，网上找不到datasheet，只知道它是个一次性编程的控制器。这种芯片省去了动辄10k次擦写的flash，降低了成本，适合于产品的设计。&lt;/p&gt;
&lt;p&gt;鼠标是无线的，主控是个射频芯片，天线就画在板上。&lt;/p&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/1734552/202009/1734552-20200922023656249-826825380.jpg&quot; width=&quot;400&quot;/&gt;&lt;p&gt;光电鼠标中检测移动的器件是光学感应器。一个LED发出的光经过镜面反射和鼠标下方材质的漫反射后进入传感器，高速捕获材质表面的图像，用DSP计算出移动的距离。论计算，它的性能应该比前面的主控强吧。&lt;/p&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/1734552/202009/1734552-20200922023702171-857436236.png&quot; width=&quot;400&quot;/&gt;&lt;p&gt;↑光学感应器的结构，图源Google&lt;/p&gt;
&lt;p&gt;这里的光学感应器是由两块PCB和若干塑料件组成的整体，我没敢拆。下面的PCB通过半孔接到主板上，上面的是给红外LED供电用的。&lt;/p&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/1734552/202009/1734552-20200922023709750-1577882954.jpg&quot; width=&quot;400&quot;/&gt;&lt;p&gt;滚轮带有3个键，上篇中修的就是它的左右键。滚轮卡在透明塑料壳中，塑料壳前端固定在底座上，后部可以摆动，摆动时触发左右按键。按下为中键，靠一根小弹簧回弹。&lt;/p&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/1734552/202009/1734552-20200922023715159-959366897.jpg&quot; width=&quot;400&quot;/&gt;&lt;p&gt;一些低端的鼠标用的滚轮是用机械方式把旋转动作转换成电信号，本质上就是&lt;a href=&quot;https://www.cnblogs.com/jerry-fuyi/p/12051753.html&quot; target=&quot;_blank&quot;&gt;旋转编码器&lt;/a&gt;。手头这个作为大品牌中端鼠标当然不能用这么廉价的方案（而且我感觉旋转编码器与滚轮左右键无法共存）。滚轮的结构就像小车的测速码盘一样，有分布均匀的辐条，可以挡住一边的光电传感器接收到另一边发出的红外光。与旋转编码器一样，一个光电门只能检测速度，要两个才能检测方向，下图中光电门的3个引脚证明了这一点。我敢断言两个光电传感器接收到信号的相位差接近90°，尽管我不知如何测量，好像还涉及到一些几何。&lt;/p&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/1734552/202009/1734552-20200922023720792-1995316055.jpg&quot; width=&quot;400&quot;/&gt;&lt;p&gt;主板通过2根线连接到侧键的那块PCB。我没有合适的工具拆下螺丝，但是观察发现板上没有电阻，不知是如何用2根线检测2个按键的（多按键接ADC需要合适的电阻）。&lt;/p&gt;
&lt;p&gt;主板上有个红绿双色的LED，装好后正好位于上盖导光柱的下方，LED发出的光经由导光柱高效地传出。&lt;/p&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/1734552/202009/1734552-20200922023727973-866414130.jpg&quot; width=&quot;400&quot;/&gt;&lt;p&gt;写这篇文章就当科普了吧，至少我是挺有收获的。&lt;/p&gt;
</description>
<pubDate>Mon, 21 Sep 2020 18:39:00 +0000</pubDate>
<dc:creator>jerry_fuyi</dc:creator>
<og:description>上回写到要解决噪音问题。尽管实测青轴比微动吵得多，但静音微动买都买了，还是给换上吧。 原来的微动是3脚的，新买的静音微动是2脚的，它们是否兼容呢？我们注意到3脚微动上标有C、NO和NC字样，意为微动未</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jerry-fuyi/p/13709721.html</dc:identifier>
</item>
<item>
<title>WPF 从 .net core 3.1到 .net 5.0 - WeihanLi</title>
<link>http://www.cnblogs.com/weihanli/p/migrate-wpf-to-netcore5-from-netcore3_1.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/weihanli/p/migrate-wpf-to-netcore5-from-netcore3_1.html</guid>
<description>&lt;h2 id=&quot;intro&quot;&gt;Intro&lt;/h2&gt;
&lt;p&gt;昨天更新了一个简单的 asp.net core webapi 项目，从 3.1 更新到了 5.0，今天更新一个 WPF 应用到 net 5.0&lt;/p&gt;
&lt;h2 id=&quot;项目文件更新&quot;&gt;项目文件更新&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;首先项目文件中的 SDK 发生了变化，原来是 &lt;code&gt;Microsoft.NET.Sdk.WindowsDesktop&lt;/code&gt; 更新后变为 &lt;code&gt;Microsoft.NET.Sdk&lt;/code&gt;，和普通的 Console 应用以及类库应用的 SDK 保持一致&lt;/li&gt;
&lt;li&gt;项目目标框架修改，从原来的 &lt;code&gt;netcoreapp3.1&lt;/code&gt; 变为 &lt;code&gt;net5.0-windows&lt;/code&gt;，WPF 中有很多API 都是 Windows 上才可以用的&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;在以前的 .NET Core 版本中，WinForms 和 WPF 应用使用单独的项目 SDK (Microsoft.NET.Sdk.WindowsDesktop)。 从 .NET 5.0 开始，WinForms 和 WPF SDK 已与 .NET SDK (Microsoft.NET.Sdk) 统一。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/489462/202009/489462-20200921232934049-961730686.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;持续集成配置更新&quot;&gt;持续集成配置更新&lt;/h2&gt;
&lt;p&gt;我目前使用的是 Azure DevOps 来做持续集成的，需要更新持续集成配置以保证 build 不会失败&lt;/p&gt;
&lt;p&gt;原来使用的是 dotnet core sdk 3.1，现在更新成 net 5.0 sdk 也需要更新，需要注意的是默认不适用预览版 sdk，而 5.0 还未正式发布，所以需要配置使用预览版 sdk，安装 SDK 是使用的微软封装的一个 Task，详细可以参考文档 &lt;a href=&quot;https://docs.microsoft.com/en-us/azure/devops/pipelines/tasks/tool/dotnet-core-tool-installer?view=azure-devops&quot;&gt;https://docs.microsoft.com/en-us/azure/devops/pipelines/tasks/tool/dotnet-core-tool-installer?view=azure-devops&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;修改如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/489462/202009/489462-20200921233154940-182226935.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;more&quot;&gt;More&lt;/h2&gt;
&lt;p&gt;我测试了一下，WPF 项目 Target 设置为 &lt;code&gt;net5.0&lt;/code&gt; 也可以的，可能微软是想特别表示只能运行在 windows 上吧&lt;/p&gt;
&lt;p&gt;于是尝试把项目设置为 &lt;code&gt;net5.0&lt;/code&gt;，但是 Azure 上的持续集成失败了，test 的项目需要是 &lt;code&gt;net5.0-windows&lt;/code&gt;，看起来是可以检测目标平台的，索性直接都改成了 &lt;code&gt;net5.0-windows&lt;/code&gt; 了，有兴趣的童鞋可以自己尝试一下&lt;/p&gt;
&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
</description>
<pubDate>Mon, 21 Sep 2020 15:45:00 +0000</pubDate>
<dc:creator>WeihanLi</dc:creator>
<og:description>WPF 从 .netcore3.1 到 .net5</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/weihanli/p/migrate-wpf-to-netcore5-from-netcore3_1.html</dc:identifier>
</item>
<item>
<title>【性能优化】面试官：Java中的对象都是在堆上分配的吗？ - 冰河团队</title>
<link>http://www.cnblogs.com/binghe001/p/13709476.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/binghe001/p/13709476.html</guid>
<description>&lt;h2 id=&quot;写在前面&quot;&gt;写在前面&lt;/h2&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;从开始学习Java的时候，我们就接触了这样一种观点：Java中的对象是在堆上创建的，对象的引用是放在栈里的，那这个观点就真的是正确的吗？如果是正确的，那么，面试官为啥会问：“Java中的对象就一定是在堆上分配的吗？”这个问题呢？看来，我们从接触Java就被灌输的这个观点值得我们怀疑。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;关于面试题&quot;&gt;关于面试题&lt;/h2&gt;
&lt;p&gt;标题中的面试题为：Java中的对象都是在堆上分配的吗？&lt;/p&gt;
&lt;p&gt;面试官这样问，有些小伙伴心里会想：我从一开始学习Java时，就知道了：Java中的对象是在堆上创建的，对象的引用是存储到栈中的，那Java中的对象是在堆上分配的啊！难道不是吗？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200921233555767.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果你这样回答，就会被直接Pass掉。&lt;/p&gt;
&lt;p&gt;或许有些小伙伴还是不太明白，那我们继续往下看。&lt;/p&gt;
&lt;h2 id=&quot;面试题答案&quot;&gt;面试题答案&lt;/h2&gt;
&lt;p&gt;首先，我们先给出这个题目的答案，这里我先简短的回答下这个面试题，后续我们会进行相关分析。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;你可以这样回答：Java中的对象不一定是在堆上分配的，因为JVM通过逃逸分析，能够分析出一个新对象的使用范围，并以此确定是否要将这个对象分配到堆上。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里，我们接触了一个新名词：逃逸分析。相信很多小伙伴不是很明白，那我们继续往下看。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200921233609611.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;逃逸分析&quot;&gt;逃逸分析&lt;/h2&gt;
&lt;h3 id=&quot;逃逸分析的概念&quot;&gt;逃逸分析的概念&lt;/h3&gt;
&lt;p&gt;先以官方的形式来说下什么是逃逸分析。逃逸分析就是：一种确定指针动态范围的静态分析，它可以分析在程序的哪些地方可以访问到指针。&lt;/p&gt;
&lt;p&gt;在JVM的即时编译语境下，逃逸分析将判断新建的对象是否逃逸。即时编译判断对象是否逃逸的依据：一种是对象是否被存入堆中（静态字段或者堆中对象的实例字段），另一种就是对象是否被传入未知代码。&lt;/p&gt;
&lt;p&gt;直接说这些概念，确实有点晕啊，那我们就来两个示例。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200921233622197.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;对象逃逸示例&quot;&gt;对象逃逸示例&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;一种典型的对象逃逸就是：对象被复制给成员变量或者静态变量，可能被外部使用，此时变量就发生了逃逸。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们可以用下面的代码来表示这个现象。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * @author binghe
 * @description 对象逃逸示例1
 */
public class ObjectEscape{
    private User user;
    public void init(){
        user = new User();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在ObjectEscape类中，存在一个成员变量user，我们在init()方法中，创建了一个User类的对象，并将其赋值给成员变量user。此时，对象被复制给了成员变量，可能被外部使用，此时的变量就发生了逃逸。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;另一种典型的场景就是：对象通过return语句返回。如果对象通过return语句返回了，此时的程序并不能确定这个对象后续会不会被使用，外部的线程可以访问到这个变量，此时对象也发生了逃逸。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们可以用下面的代码来表示这个现象。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * @author binghe
 * @description 对象逃逸示例2
 */
public class ObjectReturn{
    public User createUser(){
        User user = new User();
        return user;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;给出两个示例，相信小伙伴们对JVM的逃逸分析多少有点了解了吧，没错，JVM通过逃逸分析，能够分析出新对象的使用范围，从而决定新对象是否要在堆上进行分配。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200921233635206.jpg#pic_center&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;还没完，我们继续看下逃逸分析的优点，以便于小伙伴们能够更好的理解逃逸分析。&lt;/p&gt;
&lt;h3 id=&quot;逃逸分析的优点&quot;&gt;逃逸分析的优点&lt;/h3&gt;
&lt;p&gt;逃逸分析的优点总体上来说可以分为三个：对象可能分配在栈上、分离对象或标量替换、消除同步锁。我们可以使用下图来表示。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200921233655382.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对象可能分配在栈上&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;JVM通过逃逸分析，分析出新对象的使用范围，就可能将对象在栈上进行分配。栈分配可以快速地在栈帧上创建和销毁对象，不用再将对象分配到堆空间，可以有效地减少 JVM 垃圾回收的压力。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分离对象或标量替换&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当JVM通过逃逸分析，确定要将对象分配到栈上时，即时编译可以将对象打散，将对象替换为一个个很小的局部变量，我们将这个打散的过程叫做标量替换。将对象替换为一个个局部变量后，就可以非常方便的在栈上进行分配了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;同步锁消除&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果JVM通过逃逸分析，发现一个对象只能从一个线程被访问到，则访问这个对象时，可以不加同步锁。如果程序中使用了synchronized锁，则JVM会将synchronized锁消除。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这里，需要注意的是：这种情况针对的是synchronized锁，而对于Lock锁，则JVM并不能消除。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;要开启同步消除，需要加上 -XX:+EliminateLocks 参数。因为这个参数依赖逃逸分析，所以同时要打开 -XX:+DoEscapeAnalysis 选项。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所以，并不是所有的对象和数组，都是在堆上进行分配的，由于即时编译的存在，如果JVM发现某些对象没有逃逸出方法，就很有可能被优化成在栈上分配。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;重磅福利&quot;&gt;重磅福利&lt;/h2&gt;
&lt;p&gt;微信搜一搜【冰河技术】微信公众号，关注这个有深度的程序员，每天阅读超硬核技术干货，公众号内回复【PDF】有我准备的一线大厂面试资料和我原创的超硬核PDF技术文档，以及我为大家精心准备的多套简历模板（不断更新中），希望大家都能找到心仪的工作，学习是一条时而郁郁寡欢，时而开怀大笑的路，加油。如果你通过努力成功进入到了心仪的公司，一定不要懈怠放松，职场成长和新技术学习一样，不进则退。如果有幸我们江湖再见！&lt;/p&gt;
&lt;p&gt;另外，我开源的各个PDF，后续我都会持续更新和维护，感谢大家长期以来对冰河的支持！！&lt;/p&gt;
&lt;h2 id=&quot;写在最后&quot;&gt;写在最后&lt;/h2&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;如果你觉得冰河写的还不错，请微信搜索并关注「 &lt;strong&gt;冰河技术&lt;/strong&gt; 」微信公众号，跟冰河学习高并发、分布式、微服务、大数据、互联网和云原生技术，「 &lt;strong&gt;冰河技术&lt;/strong&gt; 」微信公众号更新了大量技术专题，每一篇技术文章干货满满！不少读者已经通过阅读「 &lt;strong&gt;冰河技术&lt;/strong&gt; 」微信公众号文章，吊打面试官，成功跳槽到大厂；也有不少读者实现了技术上的飞跃，成为公司的技术骨干！如果你也想像他们一样提升自己的能力，实现技术能力的飞跃，进大厂，升职加薪，那就关注「 &lt;strong&gt;冰河技术&lt;/strong&gt; 」微信公众号吧，每天更新超硬核技术干货，让你对如何提升技术能力不再迷茫！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200906013715889.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 21 Sep 2020 15:42:00 +0000</pubDate>
<dc:creator>冰河团队</dc:creator>
<og:description>写在前面 从开始学习Java的时候，我们就接触了这样一种观点：Java中的对象是在堆上创建的，对象的引用是放在栈里的，那这个观点就真的是正确的吗？如果是正确的，那么，面试官为啥会问：“Java中的对象</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/binghe001/p/13709476.html</dc:identifier>
</item>
<item>
<title>J.U.C之Executor框架入门指引 - 这是个坑</title>
<link>http://www.cnblogs.com/oxf5deb3/p/13709466.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/oxf5deb3/p/13709466.html</guid>
<description>&lt;h5 id=&quot;1、executor接口&quot;&gt;1、Executor接口&lt;/h5&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;pre&gt;
&lt;code&gt;This interface provides a way of decoupling task submission from the mechanics of how each task will be run, including details of thread use, scheduling, etc.  An {@code Executor} is normally used instead of explicitly creating threads. 
For example, rather than invoking {@code new Thread(new(RunnableTask())).start()} for each of a set of tasks
&lt;/code&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt;executor框架是jdk1.5时引入的一个接口，主要目的是解耦任务的创建和任务的执行，在jdk1.5之前，我们用线程创建一个任务时，通常是这样 new Thread(new(RunnableTask())).start() ，当引入executor后我们这样来创建执行任务:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Executor executor = anExecutor;
executor.execute(new RunnableTask1());
executor.execute(new RunnableTask2());
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但由于executor接口只定义了方法void execute(Runnable command) 而没有定义具体的实现，因而对于executor的不同实现，execute可能是创建一个新的线程并立即启动，有可能是使用已有的工作线程运行，或者可能将任务放入等待队列等待可用的工作线程。比如:&lt;/p&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;同步执行&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;class DirectExecutor implements Executor {
   public void execute(Runnable r) {
     r.run();
   }
 }}
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;异步执行&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;class ThreadPerTaskExecutor implements Executor {
   public void execute(Runnable r) {
     new Thread(r).start();
   }
 }}
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;排队执行&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;class SerialExecutor implements Executor {
   final Queue&amp;lt;Runnable&amp;gt; tasks = new ArrayDeque&amp;lt;Runnable&amp;gt;();
   final Executor executor;
   Runnable active;

   SerialExecutor(Executor executor) {
     this.executor = executor;
   }

   public synchronized void execute(final Runnable r) {
     tasks.offer(new Runnable() {
       public void run() {
         try {
           r.run();
         } finally {
           scheduleNext();
         }
       }
     });
     if (active == null) {
       scheduleNext();
     }
   }

   protected synchronized void scheduleNext() {
     if ((active = tasks.poll()) != null) {
       executor.execute(active);
     }
   }
 }}
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;2、executorservice接口&quot;&gt;2、ExecutorService接口&lt;/h5&gt;
&lt;p&gt;除了继承Executor接口的功能外，还提供了关闭执行器的方法，更加通用的submit方法(除了可以接收runnable接口任务还可以接收callable接口任务,&lt;strong&gt;使用callable接口任务通常是需要获取执行结果的任务，它通过返回的Future来获取callable任务的执行结果&lt;/strong&gt;)和批量运行Callable接口任务。&lt;/p&gt;
&lt;h5 id=&quot;3、scheduledexecutorservice接口&quot;&gt;3、ScheduledExecutorService接口&lt;/h5&gt;
&lt;p&gt;除了继承ExecutorService接口功能外，还提供了延时执行和间隔执行的功能(scheduleWithFixedDelay,scheduleAtFixedRate)&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;class BeeperControl {
   private final ScheduledExecutorService scheduler =
     Executors.newScheduledThreadPool(1);

   public void beepForAnHour() {
     final Runnable beeper = new Runnable() {
       public void run() { System.out.println(&quot;beep&quot;); }
     };
     final ScheduledFuture&amp;lt;?&amp;gt; beeperHandle =
       scheduler.scheduleAtFixedRate(beeper, 10, 10, SECONDS);
     scheduler.schedule(new Runnable() {
       public void run() { beeperHandle.cancel(true); }
     }, 60 * 60, SECONDS);
   }
 }}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;4、executors-工厂&quot;&gt;4、Executors 工厂&lt;/h5&gt;
&lt;p&gt;对于上述3个接口,jdk1.5 都提供了默认的实现，但是如果用户自己去创建这些个默认实现的实例，就必须要了解这些默认实例的实现细节，而Executors 相当于就是一个简单工厂，通过提供一些简单的参数就可以创建出来我们想要的执行器。Executors为我们提供了五类执行器的创建:&lt;/p&gt;
&lt;ul readability=&quot;12.5&quot;&gt;&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;创建固定线程数的Executor,返回ThreadPoolExecutor类型实例&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static ExecutorService newFixedThreadPool(int nThreads)
public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory)
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;单个线程的Executor,返回FinalizableDelegatedExecutorService或DelegatedScheduledExecutorService类型实例&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static ExecutorService newSingleThreadExecutor() 
public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory)
public static ScheduledExecutorService newSingleThreadScheduledExecutor()
public static ScheduledExecutorService newSingleThreadScheduledExecutor(ThreadFactory threadFactory)
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;可缓存的Executor&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static ExecutorService newCachedThreadPool()
public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory)
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;延时、周期性的Executor&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize)
public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize, ThreadFactory threadFactory)
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;fork/join Executor,返回ForkJoinPool类实例&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static ExecutorService newWorkStealingPool(int parallelism)//并行级别
public static ExecutorService newWorkStealingPool()
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Mon, 21 Sep 2020 15:40:00 +0000</pubDate>
<dc:creator>这是个坑</dc:creator>
<og:description>1、Executor接口 This interface provides a way of decoupling task submission from the mechanics of how e</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/oxf5deb3/p/13709466.html</dc:identifier>
</item>
<item>
<title>深度学习一：深度前馈网络 - JYRoy</title>
<link>http://www.cnblogs.com/jyroy/p/13709302.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jyroy/p/13709302.html</guid>
<description>&lt;ul&gt;&lt;li&gt;&lt;strong&gt;深度前馈网络(deep feedforward network)&lt;/strong&gt;, 又叫&lt;strong&gt;前馈神经网络(feedforward neural network)&lt;/strong&gt;和&lt;strong&gt;多层感知机(multilayer perceptron, MLP)&lt;/strong&gt; .&lt;/li&gt;
&lt;li&gt;深度前馈网络之所以被称为&lt;strong&gt;网络&lt;/strong&gt;(network)，因为它们通常由许多不同的符合函数组合在一起来表示。&lt;/li&gt;
&lt;li&gt;由&lt;strong&gt;输入层&lt;/strong&gt;(input layer)、&lt;strong&gt;隐藏层&lt;/strong&gt;(hidden layer)、&lt;strong&gt;输出层&lt;/strong&gt;(output layer)构成。&lt;/li&gt;
&lt;li&gt;隐藏层的维数决定了模型的&lt;strong&gt;宽度&lt;/strong&gt;(width)。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如图，这是一个经典的&lt;strong&gt;二层神经网络模型(Two-Layer Neural Network)&lt;/strong&gt;。通常输入层和输出层神经元的个数是固定的，我们需要选择和调整隐藏层的层数和每一层神经元的个数等。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1378215/202009/1378215-20200915115346979-121496520.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注：我们可以利用矩阵乘法来迅速计算神经网络的输出，后面不会提及。可以参考Python神经网络编程(拉希德著)这本书，写的非常简洁。&lt;/p&gt;

&lt;p&gt;所有数据样本是线性可分的，即满足一个形如 &lt;span class=&quot;math inline&quot;&gt;\(w_0+w_1x_1+w_2x_2\)&lt;/span&gt;的线性方程的划分&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1378215/202009/1378215-20200914231637698-1555295359.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;线性分类问题的局限&quot;&gt;线性分类问题的局限&lt;/h2&gt;
&lt;p&gt;我们引入经典的逻辑运算来推理线性分类问题的局限。&lt;/p&gt;
&lt;p&gt;如图所示，分别为线性模型来表示 AND，OR 逻辑，那么XOR要怎么表示呢？&lt;/p&gt;
&lt;p&gt;由图可知：我们可以利用线性模型拟合出一个直线来表示 AND、OR、NOR 的逻辑运算，但是没有办法用一条直线表示 xor 异或逻辑，这就是一个经典的&lt;strong&gt;非线性问题&lt;/strong&gt;！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1378215/202009/1378215-20200914232532187-118658381.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;注：黑色点是positive(1)的点，白色点是negative(0)的点&lt;/p&gt;
&lt;p&gt;从逻辑运算的视角来看：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;逻辑&lt;/th&gt;
&lt;th&gt;1 1&lt;/th&gt;
&lt;th&gt;0 1&lt;/th&gt;
&lt;th&gt;1 0&lt;/th&gt;
&lt;th&gt;0 0&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;AND&lt;/td&gt;
&lt;td&gt;1 AND 1 = 1&lt;/td&gt;
&lt;td&gt;0 AND 1 = 0&lt;/td&gt;
&lt;td&gt;1 AND 0 = 0&lt;/td&gt;
&lt;td&gt;0 AND 0 = 0&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;OR&lt;/td&gt;
&lt;td&gt;1 OR 1 = 1&lt;/td&gt;
&lt;td&gt;0 OR 1 = 1&lt;/td&gt;
&lt;td&gt;1 OR 0 = 1&lt;/td&gt;
&lt;td&gt;0 OR 0 = 0&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;NOR&lt;/td&gt;
&lt;td&gt;1 NOR 1 = 0&lt;/td&gt;
&lt;td&gt;0 NOR 1 = 0&lt;/td&gt;
&lt;td&gt;1 NOR 0 = 0&lt;/td&gt;
&lt;td&gt;0 XOR 0 = 1&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;XOR&lt;/td&gt;
&lt;td&gt;1 XOR 1 = 0&lt;/td&gt;
&lt;td&gt;0 XOR 1 = 1&lt;/td&gt;
&lt;td&gt;1 XOR 0 = 1&lt;/td&gt;
&lt;td&gt;0 XOR 0 = 0&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;我们可以利用如下图所示的一个神经元的感知机来表示一个逻辑 and/or/nor，即每一个神经元可以拟合出一条直线：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1378215/202009/1378215-20200915113622057-1575418551.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;解决线性问题的局限&quot;&gt;解决线性问题的局限&lt;/h2&gt;
&lt;p&gt;这里涉及感知机(perceptron)的基本思想：多个神经元拟合多条直线，将这些直线组合在一起来划分一个非线性的边界。&lt;br/&gt;我们来看上面的XOR逻辑，作为一个简单的例子，发现&lt;/p&gt;
&lt;p&gt;\[I_1 XOR I_2 \]&lt;/p&gt;
&lt;p&gt;可以表示为&lt;/p&gt;
&lt;p&gt;\[(I_1 AND I_2) NOR (I_1 NOR I_2)。 \]&lt;/p&gt;
&lt;p&gt;根据上述公式和图，我们可以画出如下的多层感知机，来实现非线性划分数据表示XOR逻辑关系。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1378215/202009/1378215-20200915112648907-1654260240.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;特征非线性&quot;&gt;特征非线性&lt;/h2&gt;
&lt;p&gt;引入非线性的特征来处理非线性问题。&lt;br/&gt;例如：输入节点有表示平方的节点等。&lt;/p&gt;
&lt;h2 id=&quot;模型非线性&quot;&gt;模型非线性&lt;/h2&gt;
&lt;p&gt;引入非线性的激活函数来处理非线性问题。&lt;/p&gt;

&lt;p&gt;激活函数(activation function)又叫转移函数(transfer function)，用来增加神经网络模型的非线性。&lt;/p&gt;
&lt;p&gt;\[activation_i = g(s_i) = g(\sum_{j}w_{ij}x_j) \]&lt;/p&gt;
&lt;p&gt;下图是只有一个神经元的示意图：g函数是非线性的激活函数。由图中可以看出，当神经元计算出线性方程的结果s之后，传入激活函数g中进行处理，最终得到神经元的输出g(s)，从而实现非线性。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1378215/202009/1378215-20200915001523231-348033473.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;常用的激活函数&quot;&gt;常用的激活函数&lt;/h2&gt;
&lt;h3 id=&quot;sigmoid&quot;&gt;Sigmoid&lt;/h3&gt;
&lt;p&gt;S型激活函数又叫挤压函数，可以把任意的大小的x挤压到(0,1)之间的y, 在x增大或者减小的过程中会逐渐出现饱和(无限趋近于0或者1)。&lt;br/&gt;在二分类问题中，可以以0.5为阈值，小于0.5为一个类别，大于0.5为另一个类别。&lt;/p&gt;
&lt;p&gt;\[f(x) = \frac{1}{1 + e^{-x}} \]&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1378215/202009/1378215-20200915003558723-1493341173.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;存在饱和现象，会导致梯度消失。&lt;/li&gt;
&lt;li&gt;优化路径存在zig zag问题。&lt;/li&gt;
&lt;li&gt;函数使用指数运算，运算量比较大。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;tanh&quot;&gt;Tanh&lt;/h3&gt;
&lt;p&gt;双曲正切函数，与sigmoid函数相似，也会出现梯度饱和，但是tanh的值域为(-1,1)。&lt;/p&gt;
&lt;p&gt;\[tanh(x) = \frac{e^x-e^{-x}}{e^x+e^{-x}} \]&lt;/p&gt;
&lt;h3 id=&quot;relu&quot;&gt;Relu&lt;/h3&gt;
&lt;p&gt;线性整流函数(Rectified Linear Unit，ReLU)，又称修正线性单元。当x&amp;lt;0时，y为0；当x&amp;gt;0时，y=x。没有饱和现象，y可以取到无穷大。&lt;/p&gt;
&lt;p&gt;\[f(x) = max(0,x) \]&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1378215/202009/1378215-20200915004258331-1008149439.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;运算速度比较快。&lt;/li&gt;
&lt;li&gt;不会出现饱和现象。&lt;/li&gt;
&lt;li&gt;收敛迅速。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;当x&amp;lt;0，y也为0，梯度为0。即当x&amp;lt;0，是没有办法进行学习的。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;elu&quot;&gt;ELU&lt;/h3&gt;
&lt;p&gt;指数线性单元(Exponential Linear Unit)也是ReLU激活函数的变体。&lt;/p&gt;
&lt;p&gt;\[f(x) = \begin{cases} x &amp;amp; x\geq0 \\ α*(e^x-1) &amp;amp; x&amp;lt;0 \end{cases} \]&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1378215/202009/1378215-20200915110920337-789961203.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;当x&amp;lt;0时，曲线也有变化，不会停止学习。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;指数运算的计算量比较大。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;leaky-relu&quot;&gt;Leaky ReLU&lt;/h3&gt;
&lt;p&gt;带泄露修正线性单元(Leaky ReLU)函数是ReLU激活函数的变体。当x&amp;lt;0时，y=0.1x；当x&amp;gt;0时，y=x。&lt;/p&gt;
&lt;p&gt;\[f(x) = max(αx,x) \]&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1378215/202009/1378215-20200915111315861-1537596354.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;当x&amp;lt;0时，曲线也有变化，不会停止学习。&lt;/li&gt;
&lt;li&gt;计算量比ELU小很多&lt;/li&gt;
&lt;li&gt;x&amp;lt;0的斜率α可以自己设置&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;链式求导&quot;&gt;链式求导&lt;/h2&gt;
&lt;p&gt;链式求导是反向传播利用的主要数学技巧，因此先来看链式求导。&lt;/p&gt;
&lt;p&gt;我们假设&lt;/p&gt;
&lt;p&gt;\[y = y(u)\\ u = u(x) \]&lt;/p&gt;
&lt;p&gt;即&lt;/p&gt;
&lt;p&gt;\[\frac{∂y}{∂x} =\frac{∂y}{∂u}\frac{∂u}{∂x} \]&lt;/p&gt;
&lt;p&gt;利用链式求导法则可以有效的求出偏导数。注：应用在神经网络中损失函数必须是可微的（differentiable），例如 Sigmod 或者 Tanh 等&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Sigmod：
&lt;ul&gt;&lt;li&gt;if $$z(s) = \frac{1}{1+e^-s}$$ , then $$z'(s) = z(1-z)$$&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Tanh:
&lt;ul&gt;&lt;li&gt;if $$z(s) = tanh(s)$$ , then $$z'(s) = 1-z^2$$&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;反向传播-backpropagation&quot;&gt;反向传播 Backpropagation&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;反向传播(back propagation, 简称backprop)&lt;/strong&gt;。是梯度下降法在深度网络上的具体实现方式。在传统的前馈神经网络中，信息通过网络向前流动，输入x提供初始值，然后传播到每一层的隐藏单元，最终产生输出y。这个流程被称为前向传播(forward propagation)。而反向传播允许来自代价函数的信息通过网络向后流动，以便计算梯度、调整参数。&lt;/p&gt;
&lt;p&gt;如图，这是一个前向传播网络的示意图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1378215/202009/1378215-20200915121153095-190817598.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中 E 表示计算出的误差，这个例子中利用的是最小均方误差。&lt;/p&gt;
&lt;p&gt;我们为了减小误差，使模型的输出接近我们想要的值，就要利用反向传播的办法来调整模型中的参数。将误差信号沿着原来的路线返回，即要从输出到输入做偏导，修改神经元的权值和偏置值，使误差 E 最小。&lt;/p&gt;
&lt;h3 id=&quot;反向传播中的核心方程&quot;&gt;反向传播中的核心方程&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1378215/202009/1378215-20200921230417411-228011048.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;根据上述的方程，我们可以来更新权重，&lt;span class=&quot;math inline&quot;&gt;\(w = w - η \frac{∂E}{∂w}\)&lt;/span&gt;, 其中 &lt;span class=&quot;math inline&quot;&gt;\(η\)&lt;/span&gt; 是学习率&lt;/p&gt;
&lt;p&gt;注：这个地方可能用计算图理解比较清晰。大家可以去查一些相关资料。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;损失函数（Loss Function）又称误差函数（Error Function）和代价函数（Cost Function）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1378215/202009/1378215-20200921230349493-1388171860.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在神经网络中，我们的目标是找到一组权重，使误差最小化，即到达图中的 Global Minimum 点&lt;/p&gt;
&lt;h2 id=&quot;均方误差-mse&quot;&gt;均方误差 MSE&lt;/h2&gt;
&lt;p&gt;处理回归问题常用的损失函数&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;均方误差（Mean Square Error， MSE）&lt;/strong&gt;是真实值与预测值的差值的平方然后求和平均。&lt;/p&gt;
&lt;p&gt;\[E = \frac{1}{2}(z_i-t_i)^2 \]&lt;/p&gt;
&lt;p&gt;其中，&lt;span class=&quot;math inline&quot;&gt;\(z_i\)&lt;/span&gt; 是实际输出值，&lt;span class=&quot;math inline&quot;&gt;\(t_i\)&lt;/span&gt; 是目标输出值。前面加 &lt;span class=&quot;math inline&quot;&gt;\(\frac{1}{2}\)&lt;/span&gt; 的原因是为了求导时候消去导数上移下来的数字2.&lt;/p&gt;
&lt;p&gt;存在的问题：对于均方误差函数，在处理分类问题的时候不太合适。当 MSE 配合 Sigmoid 函数使用时，MSE 在求导过程中要用到 Sigmoid 函数的导数&lt;span class=&quot;math inline&quot;&gt;\(z'(s)\)&lt;/span&gt;，会因为梯度消失而导致模型权重学习的很慢。如图&lt;/p&gt;
&lt;p&gt;\[\frac{\delta E}{\delta w} = \frac{\delta E}{\delta z} \frac{\delta z}{\delta s} \frac{\delta s}{\delta w} = (z_i-t_i)·z_i'(s)·x_i \]&lt;/p&gt;
&lt;p&gt;而交叉熵损失函数可以很好的避免这个问题。&lt;/p&gt;
&lt;h2 id=&quot;交叉熵损失函数-cee&quot;&gt;交叉熵损失函数 CEE&lt;/h2&gt;
&lt;p&gt;处理分类问题常用的损失函数&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;交叉熵损失函数（Cross Entropy， CE）或称交叉熵误差（Cross Entropy Error， CEE）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;\[E = -\sum_kt_klog(z_k) \]&lt;/p&gt;
&lt;p&gt;在01二分类问题中，公式形式为&lt;/p&gt;
&lt;p&gt;\[E = -tlog(z)-(1-t)log(1-z) \]&lt;/p&gt;

&lt;h2 id=&quot;用python手写反向传播神经网络&quot;&gt;用Python手写反向传播神经网络&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/JYRoy/MachineLearning/tree/master/NN&quot;&gt;源码已上传Github, 点击跳转&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;激活函数的作用&quot;&gt;激活函数的作用&lt;/h2&gt;
&lt;h2 id=&quot;神经网络中的激活函数有哪些&quot;&gt;神经网络中的激活函数有哪些&lt;/h2&gt;
&lt;h2 id=&quot;神经网络为什么用交叉熵&quot;&gt;神经网络为什么用交叉熵&lt;/h2&gt;
&lt;h2 id=&quot;交叉熵公式&quot;&gt;交叉熵公式&lt;/h2&gt;
&lt;h2 id=&quot;loss-function有哪些，怎么用？&quot;&gt;Loss Function有哪些，怎么用？&lt;/h2&gt;
&lt;h2 id=&quot;线性回归的表达式，损失函数&quot;&gt;线性回归的表达式，损失函数&lt;/h2&gt;
</description>
<pubDate>Mon, 21 Sep 2020 15:06:00 +0000</pubDate>
<dc:creator>JYRoy</dc:creator>
<og:description>简述 深度前馈网络(deep feedforward network), 又叫前馈神经网络(feedforward neural network)和多层感知机(multilayer perceptro</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jyroy/p/13709302.html</dc:identifier>
</item>
<item>
<title>《Head First 设计模式》：状态模式 - 惊却一目</title>
<link>http://www.cnblogs.com/jingqueyimu/p/13709241.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jingqueyimu/p/13709241.html</guid>
<description>&lt;h2 id=&quot;一、定义&quot;&gt;一、定义&lt;/h2&gt;
&lt;p&gt;状态模式允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;要点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;状态模式允许一个对象基于内部状态而拥有不同的行为。&lt;/li&gt;
&lt;li&gt;状态模式将状态封装成为独立的类，并将动作委托到代表当前状态的对象。&lt;/li&gt;
&lt;li&gt;通过将每个状态封装进一个类，我们把以后需要做的任何改变局部化了。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;二、实现步骤&quot;&gt;二、实现步骤&lt;/h2&gt;
&lt;h3 id=&quot;1、创建状态接口&quot;&gt;1、创建状态接口&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * 状态接口
 */
public interface State {
    
    /**
     * 根据状态进行处理的方法
     */
    public void handle();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;2、在持有状态的类中，将请求委托给状态类&quot;&gt;2、在持有状态的类中，将请求委托给状态类&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * 持有状态的上下文类
 */
public class Context {
    
    private State state;
    
    public State getState() {
        return state;
    }

    public void setState(State state) {
        this.state = state;
    }
    
    /**
     * 接收请求，并将请求委托给状态类
     */
    public void request() {
        state.handle();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;3、创建具体的状态，并实现状态接口&quot;&gt;3、创建具体的状态，并实现状态接口&lt;/h3&gt;
&lt;h4 id=&quot;（1）具体状态a&quot;&gt;（1）具体状态A&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * 具体状态A
 */
public class ConcreteStateA implements State {
    
    Context context;
    
    public ConcreteStateA() {
        context = new Context();
    }

    @Override
    public void handle() {
        // 实现该状态下相应的行为
        System.out.println(&quot;Context is in A state, and start to do something...&quot;);
        context.setState(this);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;（2）具体状态b&quot;&gt;（2）具体状态B&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * 具体状态B
 */
public class ConcreteStateB implements State {
    
    Context context;
    
    public ConcreteStateB() {
        context = new Context();
    }

    @Override
    public void handle() {
        // 实现该状态下相应的行为
        System.out.println(&quot;Context is in B state, and start to do something...&quot;);
        context.setState(this);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;4、通过改变状态，来改变上下文类的行为&quot;&gt;4、通过改变状态，来改变上下文类的行为&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;public class Test {

    public static void main(String[] args) {
        // 上下文
        Context context = new Context();
        // 状态
        State stateA = new ConcreteStateA();
        State stateB = new ConcreteStateB();
        // 通过状态改变行为
        context.setState(stateA);
        context.request();
        context.setState(stateB);
        context.request();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;三、举个栗子&quot;&gt;三、举个栗子&lt;/h2&gt;
&lt;h3 id=&quot;1、背景&quot;&gt;1、背景&lt;/h3&gt;
&lt;p&gt;万能糖果公司打算使用 Java 来实现糖果机的控制器。他们希望设计能够尽量有弹性而且好维护，因为将来可能要为糖果机增加更多的行为。&lt;/p&gt;
&lt;p&gt;糖果机的工作流程如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1613877/202009/1613877-20200921224355099-3738421.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;2、实现&quot;&gt;2、实现&lt;/h3&gt;
&lt;h4 id=&quot;（1）创建状态接口，并定义相应的糖果机行为&quot;&gt;（1）创建状态接口，并定义相应的糖果机行为&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * 状态接口
 */
public interface State {
    
    /**
     * 投入25分钱
     */
    public void insertQuarter();
    
    /**
     * 退回25分钱
     */
    public void ejectQuarter();
    
    /**
     * 转动曲柄
     */
    public void turnCrank();
    
    /**
     * 发放糖果
     */
    public void dispense();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;（2）创建糖果机&quot;&gt;（2）创建糖果机&lt;/h4&gt;
&lt;p&gt;将传递给糖果机的请求，委托给状态类。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * 糖果机
 */
public class GumballMachine {

    State soldOutState;
    State noQuarterState;
    State hasQuarterState;
    State soldState;
    
    State state = soldOutState;
    int gumballCount = 0;
    
    public GumballMachine(int initGumballCount) {
        soldOutState = new SoldOutState(this);
        noQuarterState = new NoQuarterState(this);
        hasQuarterState = new HasQuarterState(this);
        soldState = new SoldState(this);
        // 初始化糖果数量
        this.gumballCount = initGumballCount;
        // 初始化糖果机状态
        if (initGumballCount &amp;gt; 0) {
            state = noQuarterState;
        } else {
            state = soldOutState;
        }
    }
    
    /**
     * 投入25分钱
     */
    public void insertQuarter() {
        state.insertQuarter();
    }
    
    /**
     * 退回25分钱
     */
    public void ejectQuarter() {
        state.ejectQuarter();
    }
    
    /**
     * 转动曲柄
     */
    public void turnCrank() {
        state.turnCrank();
        state.dispense();
    }
    
    /**
     * 发放糖果
     */
    public void releaseBall() {
        System.out.println(&quot;A gumball comes rolling out the slot...&quot;);
        if (gumballCount &amp;gt; 0) {
            gumballCount = gumballCount -1;
        }
    }
    
    public void setState(State state) {
        this.state = state;
    }
    
    public int getGumballCount() {
        return gumballCount;
    }

    public State getSoldOutState() {
        return soldOutState;
    }

    public State getNoQuarterState() {
        return noQuarterState;
    }

    public State getHasQuarterState() {
        return hasQuarterState;
    }

    public State getSoldState() {
        return soldState;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;（3）创建具体的状态，并实现状态接口&quot;&gt;（3）创建具体的状态，并实现状态接口&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * 未投入25分钱状态
 */
public class NoQuarterState implements State {

    GumballMachine gumballMachine;

    public NoQuarterState(GumballMachine gumballMachine) {
        this.gumballMachine = gumballMachine;
    }
    
    @Override
    public void insertQuarter() {
        // 投入25分钱，并转到已投入25分钱状态
        System.out.println(&quot;You inserted a quarter&quot;);
        gumballMachine.setState(gumballMachine.getHasQuarterState());
    }

    @Override
    public void ejectQuarter() {
        // 当前为未投入25分钱状态，不能退回25分钱
        System.out.println(&quot;You haven't inserted a quarter&quot;);
    }

    @Override
    public void turnCrank() {
        // 当前为未投入25分钱状态，不能转动曲柄
        System.out.println(&quot;You truned, but there's no quarter&quot;);
    }

    @Override
    public void dispense() {
        // 当前为未投入25分钱状态，不能发放糖果
        System.out.println(&quot;You need to pay first&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * 已投入25分钱状态
 */
public class HasQuarterState implements State {
    
    GumballMachine gumballMachine;

    public HasQuarterState(GumballMachine gumballMachine) {
        this.gumballMachine = gumballMachine;
    }
    
    @Override
    public void insertQuarter() {
        // 当前为已投入25分钱状态，不能再次投入
        System.out.println(&quot;You can't insert another quarter&quot;);
    }

    @Override
    public void ejectQuarter() {
        // 退回25分钱，并将状态转到未投入25分钱状态
        System.out.println(&quot;Quarter returned&quot;);
        gumballMachine.setState(gumballMachine.getNoQuarterState());
    }

    @Override
    public void turnCrank() {
        // 转动曲柄，并将状态转为售出状态
        System.out.println(&quot;You turned...&quot;);
        gumballMachine.setState(gumballMachine.getSoldState());
    }

    @Override
    public void dispense() {
        // 当前为已投入25分钱状态，还未转动曲柄，不能发放糖果
        System.out.println(&quot;No gumball dispensed&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * 售出状态
 */
public class SoldState implements State {

    GumballMachine gumballMachine;

    public SoldState(GumballMachine gumballMachine) {
        this.gumballMachine = gumballMachine;
    }
    
    @Override
    public void insertQuarter() {
        // 当前为售出状态，不能再次投入25分钱
        System.out.println(&quot;Please wait, we're already giving you a gumball&quot;);
    }

    @Override
    public void ejectQuarter() {
        // 当前为售出状态，不能退回25分钱
        System.out.println(&quot;Sorry, you already truned the crank&quot;);
    }

    @Override
    public void turnCrank() {
        // 当前为售出状态，不能再次转动曲柄
        System.out.println(&quot;Turning twice doesn't get you another gumball!&quot;);
    }

    @Override
    public void dispense() {
        // 发放糖果
        gumballMachine.releaseBall();
        if (gumballMachine.getGumballCount() &amp;gt; 0) {
            gumballMachine.setState(gumballMachine.getNoQuarterState());
        } else {
            System.out.println(&quot;Oops, out of gumballs!&quot;);
            gumballMachine.setState(gumballMachine.getSoldOutState());
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * 售罄状态
 */
public class SoldOutState implements State {

    GumballMachine gumballMachine;

    public SoldOutState(GumballMachine gumballMachine) {
        this.gumballMachine = gumballMachine;
    }
    
    @Override
    public void insertQuarter() {
        // 当前为售罄状态，不能投入25分钱
        System.out.println(&quot;You can't insert a quarter, the machine is sold out&quot;);
    }

    @Override
    public void ejectQuarter() {
        // 当前为售罄状态，不能要求退回25分钱
        System.out.println(&quot;You can't eject, you haven't inserted a quarter yet&quot;);
    }

    @Override
    public void turnCrank() {
        // 当前为售罄状态，不能转动曲柄
        System.out.println(&quot;You turned, but there are no gumballs&quot;);
    }

    @Override
    public void dispense() {
        // 当前为售罄状态，不能发放糖果
        System.out.println(&quot;No gumball dispensed&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;（4）操作糖果机&quot;&gt;（4）操作糖果机&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;public class Test {
    
    public static void main(String[] args) {
        // 糖果机
        GumballMachine gumballMachine = new GumballMachine(5);
        // 正常操作
        gumballMachine.insertQuarter();
        gumballMachine.turnCrank();
        System.out.println(&quot;-----------------------&quot;);
        // 异常操作
        gumballMachine.insertQuarter();
        gumballMachine.ejectQuarter();
        gumballMachine.turnCrank();
    }
}
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Mon, 21 Sep 2020 14:44:00 +0000</pubDate>
<dc:creator>惊却一目</dc:creator>
<og:description>正文 一、定义 状态模式允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。 要点： 状态模式允许一个对象基于内部状态而拥有不同的行为。 状态模式将状态封装成为独立的类，并将动作委托到代</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jingqueyimu/p/13709241.html</dc:identifier>
</item>
</channel>
</rss>