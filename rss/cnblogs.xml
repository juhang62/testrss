<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>万字超强图文讲解AQS以及ReentrantLock应用（建议收藏） - 日拱一兵</title>
<link>http://www.cnblogs.com/FraserYu/p/13035284.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/FraserYu/p/13035284.html</guid>
<description>&lt;p&gt;| &lt;strong&gt;好看请赞，养成习惯&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;你有一个思想，我有一个思想，我们交换后，一个人就有两个思想&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;If you can NOT explain it simply, you do NOT understand it well enough&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;现陆续将Demo代码和技术文章整理在一起 &lt;a href=&quot;https://github.com/FraserYu/learnings&quot;&gt;Github实践精选&lt;/a&gt; ，方便大家阅读查看，本文同样收录在此，觉得不错，还请Star&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202006/1583165-20200603085605352-1980178551.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;写在前面&quot;&gt;写在前面&lt;/h2&gt;
&lt;p&gt;进入源码阶段了，写了十几篇的 &lt;a href=&quot;https://dayarch.top/categories/Coding/Java-Concurrency/&quot;&gt;并发系列&lt;/a&gt; 知识铺垫终于要派上用场了。相信很多人已经忘了其中的一些理论知识，别担心，我会在源码环节带入相应的理论知识点帮助大家回忆，做到理论与实践相结合，另外这是超长图文，建议收藏，如果对你有用还请点赞让更多人看到&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202006/1583165-20200603085605715-1325471841.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;java-sdk-为什么要设计-lock&quot;&gt;Java SDK 为什么要设计 Lock&lt;/h2&gt;
&lt;p&gt;曾几何时幻想过，如果 Java 并发控制只有 synchronized 多好，只有下面三种使用方式，简单方便&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class ThreeSync {

        private static final Object object = new Object();

        public synchronized void normalSyncMethod(){
                //临界区
        }

        public static synchronized void staticSyncMethod(){
                //临界区
        }

        public void syncBlockMethod(){
                synchronized (object){
                        //临界区
                }
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果在 Java 1.5之前，确实是这样，自从 1.5 版本 Doug Lea 大师就重新造了一个轮子 Lock&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202006/1583165-20200603085605869-1116619274.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们常说：“避免重复造轮子”，如果有了轮子还是要坚持再造个轮子，那么肯定传统的轮子在某些应用场景中不能很好的解决问题&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202006/1583165-20200603085606255-1117439137.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不知你是否还记得 &lt;a href=&quot;https://dayarch.top/p/java-concurrency-dead-lock.html#Coffman-%E6%9D%A1%E4%BB%B6&quot;&gt;Coffman 总结的四个可以发生死锁的情形&lt;/a&gt; ，其中【不可剥夺条件】是指：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;线程已经获得资源，在未使用完之前，不能被剥夺，只能在使用完时自己释放&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;要想破坏这个条件，&lt;strong&gt;就需要具有申请不到进一步资源就释放已有资源的能力&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;很显然，这个能力是 synchronized 不具备的，使用 synchronized ，如果线程申请不到资源就会进入阻塞状态，我们做什么也改变不了它的状态，这是 synchronized 轮子的致命弱点，这就强有力的给了重造轮子 Lock 的理由&lt;/p&gt;
&lt;h2 id=&quot;显式锁-lock&quot;&gt;显式锁 Lock&lt;/h2&gt;
&lt;p&gt;旧轮子有弱点，新轮子就要解决这些问题，所以要具备不会阻塞的功能，下面的三个方案都是解决这个问题的好办法（看下面表格描述你就明白三个方案的含义了）&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;特性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th&gt;API&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;5.2017353579176&quot;&gt;&lt;tr readability=&quot;2.6590909090909&quot;&gt;&lt;td&gt;能响应中断&lt;/td&gt;
&lt;td&gt;如果不能自己释放，那可以响应中断也是很好的。&lt;a href=&quot;https://dayarch.top/p/java-concurrency-interrupt-mechnism.html&quot;&gt;Java多线程中断机制&lt;/a&gt; 专门描述了中断过程，目的是通过中断信号来跳出某种状态，比如阻塞&lt;/td&gt;
&lt;td&gt;lockInterruptbly()&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;非阻塞式的获取锁&lt;/td&gt;
&lt;td&gt;尝试获取，获取不到不会阻塞，直接返回&lt;/td&gt;
&lt;td&gt;tryLock()&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;支持超时&lt;/td&gt;
&lt;td&gt;给定一个时间限制，如果一段时间内没获取到，不是进入阻塞状态，同样直接返回&lt;/td&gt;
&lt;td&gt;tryLock(long time, timeUnit)&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;好的方案有了，但鱼和熊掌不可兼得，Lock 多了 synchronized 不具备的特性，自然不会像 synchronized 那样一个关键字三个玩法走遍全天下，在使用上也相对复杂了一丢丢&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202006/1583165-20200603085606495-114681795.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;lock-使用范式&quot;&gt;Lock 使用范式&lt;/h3&gt;
&lt;p&gt;synchronized 有标准用法，这样的优良传统咱 Lock 也得有，相信很多人都知道使用 Lock 的一个&lt;strong&gt;范式&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Lock lock = new ReentrantLock();
lock.lock();
try{
        ...
}finally{
        lock.unlock();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;既然是范式（没事不要挑战更改写法的那种），肯定有其理由，我们来看一下&lt;/p&gt;
&lt;h4 id=&quot;标准1finally-中释放锁&quot;&gt;标准1—finally 中释放锁&lt;/h4&gt;
&lt;p&gt;这个大家应该都会明白，在 finally 中释放锁，目的是保证在获取到锁之后，&lt;strong&gt;最终&lt;/strong&gt;能被释放&lt;/p&gt;
&lt;h4 id=&quot;标准2在-try-外面获取锁&quot;&gt;标准2—在 try{} 外面获取锁&lt;/h4&gt;
&lt;p&gt;不知道你有没有想过，为什么会有标准 2 的存在，我们通常是“喜欢” try 住所有内容，生怕发生异常不能捕获的&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;try{}&lt;/code&gt; 外获取锁主要考虑两个方面：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;如果没有获取到锁就抛出异常，最终释放锁肯定是有问题的，因为还未曾拥有锁谈何释放锁呢&lt;/li&gt;
&lt;li&gt;如果在获取锁时抛出了异常，也就是当前线程并未获取到锁，但执行到 finally 代码时，如果恰巧别的线程获取到了锁，则会被释放掉（无故释放）&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;不同锁的实现方式略有不同，范式的存在就是要避免一切问题的出现，所以大家尽量遵守范式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202006/1583165-20200603085606714-2092058256.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;lock-是怎样起到锁的作用呢？&quot;&gt;Lock 是怎样起到锁的作用呢？&lt;/h3&gt;
&lt;p&gt;如果你熟悉 synchronized，你知道程序编译成 CPU 指令后，在临界区会有 &lt;code&gt;moniterenter&lt;/code&gt; 和 &lt;code&gt;moniterexit&lt;/code&gt; 指令的出现，可以理解成进出临界区的标识&lt;/p&gt;
&lt;p&gt;从范式上来看：&lt;/p&gt;
&lt;p&gt;那 Lock 是怎么做到的呢？&lt;/p&gt;
&lt;p&gt;这里先简单说明一下，这样一会到源码分析时，你可以远观设计轮廓，近观实现细节，会变得越发轻松&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202006/1583165-20200603085606991-1163931726.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;其实很简单，比如在 ReentrantLock 内部维护了一个 volatile 修饰的变量 state，通过 CAS 来进行读写（最底层还是交给硬件来保证原子性和可见性），如果CAS更改成功，即获取到锁，线程进入到 try 代码块继续执行；如果没有更改成功，线程会被【挂起】，不会向下执行&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;但 Lock 是一个接口，里面根本没有 state 这个变量的存在：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202006/1583165-20200603085607261-635602458.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;它怎么处理这个 state 呢？很显然需要一点设计的加成了，接口定义行为，具体都是需要实现类的&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Lock 接口的实现类基本都是通过【聚合】了一个【队列同步器】的子类完成线程访问控制的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那什么是队列同步器呢？ （这应该是你见过的最强标题党，聊了半个世纪才入正题，评论区留言骂我）&lt;/p&gt;
&lt;h2 id=&quot;队列同步器-aqs&quot;&gt;队列同步器 AQS&lt;/h2&gt;
&lt;p&gt;队列同步器 （AbstractQueuedSynchronizer），简称同步器或AQS，就是我们今天的主人公&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;问：&lt;/strong&gt;为什么你分析 JUC 源码，要从 AQS 说起呢？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;答：&lt;/strong&gt;看下图&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202006/1583165-20200603085607739-1487959799.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;相信看到这个截图你就明白一二了，你听过的，面试常被问起的，工作中常用的&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;ReentrantLock&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ReentrantReadWriteLock&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Semaphore(信号量)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CountDownLatch&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;公平锁&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;非公平锁&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ThreadPoolExecutor&lt;/code&gt; (关于线程池的理解，可以查看 &lt;a href=&quot;https://dayarch.top/p/why-we-need-to-use-threadpool.html&quot;&gt;为什么要使用线程池?&lt;/a&gt; )&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;都和 AQS 有直接关系，所以了解 AQS 的抽象实现，在此基础上再稍稍查看上述各类的实现细节，很快就可以全部搞定，不至于查看源码时一头雾水，丢失主线&lt;/p&gt;
&lt;p&gt;上面提到，在锁的实现类中会聚合同步器，然后利同步器实现锁的语义，那么问题来了：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;为什么要用聚合模式，怎么进一步理解锁和同步器的关系呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202006/1583165-20200603085608115-598093590.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们绝大多数都是在使用锁，实现锁之后，其核心就是要使用方便&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202006/1583165-20200603085608442-1664738097.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从 AQS 的类名称和修饰上来看，这是一个抽象类，所以从设计模式的角度来看同步器一定是基于【模版模式】来设计的，使用者需要继承同步器，实现自定义同步器，并重写指定方法，随后将同步器组合在自定义的同步组件中，并调用同步器的模版方法，而这些模版方法又回调用使用者重写的方法&lt;/p&gt;
&lt;p&gt;我不想将上面的解释说的这么抽象，其实想理解上面这句话，我们只需要知道下面两个问题就好了&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;哪些是自定义同步器可重写的方法？&lt;/li&gt;
&lt;li&gt;哪些是抽象同步器提供的模版方法？&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;同步器可重写的方法&quot;&gt;同步器可重写的方法&lt;/h3&gt;
&lt;p&gt;同步器提供的可重写方法只有5个，这大大方便了锁的使用者：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202006/1583165-20200603085608928-1527947078.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;按理说，需要重写的方法也应该有 abstract 来修饰的，为什么这里没有？原因其实很简单，上面的方法我已经用颜色区分成了两类：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;独占式&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;共享式&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;自定义的同步组件或者锁不可能既是独占式又是共享式，为了避免强制重写不相干方法，所以就没有 abstract 来修饰了，但要抛出异常告知不能直接使用该方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    protected boolean tryAcquire(int arg) {
        throw new UnsupportedOperationException();
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;暖暖的很贴心（如果你有类似的需求也可以仿照这样的设计）&lt;/p&gt;
&lt;p&gt;表格方法描述中所说的&lt;code&gt;同步状态&lt;/code&gt;就是上文提到的有 volatile 修饰的 state，所以我们在&lt;code&gt;重写&lt;/code&gt;上面几个方法时，还要通过同步器提供的下面三个方法（AQS 提供的）来获取或修改同步状态：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202006/1583165-20200603085609217-706272998.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而独占式和共享式操作 state 变量的区别也就很简单了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202006/1583165-20200603085609446-400697483.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以你看到的 &lt;code&gt;ReentrantLock&lt;/code&gt; &lt;code&gt;ReentrantReadWriteLock&lt;/code&gt; &lt;code&gt;Semaphore(信号量)&lt;/code&gt; &lt;code&gt;CountDownLatch&lt;/code&gt; 这几个类其实仅仅是在实现以上几个方法上略有差别，其他的实现都是通过同步器的模版方法来实现的，到这里是不是心情放松了许多呢？我们来看一看模版方法：&lt;/p&gt;
&lt;h3 id=&quot;同步器提供的模版方法&quot;&gt;同步器提供的模版方法&lt;/h3&gt;
&lt;p&gt;上面我们将同步器的实现方法分为独占式和共享式两类，模版方法其实除了提供以上两类模版方法之外，只是多了&lt;code&gt;响应中断&lt;/code&gt;和&lt;code&gt;超时限制&lt;/code&gt; 的模版方法供 Lock 使用，来看一下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202006/1583165-20200603085610077-107101444.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;先不用记上述方法的功能，目前你只需要了解个大概功能就好。另外，相信你也注意到了：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;上面的方法都有 final 关键字修饰，说明子类不能重写这个方法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;看到这你也许有点乱了，我们稍微归纳一下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202006/1583165-20200603085611003-1569550888.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;程序员还是看代码心里踏实一点，我们再来用代码说明一下上面的关系（注意代码中的注释，以下的代码并不是很严谨，只是为了简单说明上图的代码实现）：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package top.dayarch.myjuc;

import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.AbstractQueuedSynchronizer;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;

/**
 * 自定义互斥锁
 *
 * @author tanrgyb
 * @date 2020/5/23 9:33 PM
 */
public class MyMutex implements Lock {

        // 静态内部类-自定义同步器
        private static class MySync extends AbstractQueuedSynchronizer{
                @Override
                protected boolean tryAcquire(int arg) {
                        // 调用AQS提供的方法，通过CAS保证原子性
                        if (compareAndSetState(0, arg)){
                                // 我们实现的是互斥锁，所以标记获取到同步状态（更新state成功）的线程，
                                // 主要为了判断是否可重入（一会儿会说明）
                                setExclusiveOwnerThread(Thread.currentThread());
                                //获取同步状态成功，返回 true
                                return true;
                        }
                        // 获取同步状态失败，返回 false
                        return false;
                }

                @Override
                protected boolean tryRelease(int arg) {
                        // 未拥有锁却让释放，会抛出IMSE
                        if (getState() == 0){
                                throw new IllegalMonitorStateException();
                        }
                        // 可以释放，清空排它线程标记
                        setExclusiveOwnerThread(null);
                        // 设置同步状态为0，表示释放锁
                        setState(0);
                        return true;
                }

                // 是否独占式持有
                @Override
                protected boolean isHeldExclusively() {
                        return getState() == 1;
                }

                // 后续会用到，主要用于等待/通知机制，每个condition都有一个与之对应的条件等待队列，在锁模型中说明过
                Condition newCondition() {
                        return new ConditionObject();
                }
        }

  // 聚合自定义同步器
        private final MySync sync = new MySync();


        @Override
        public void lock() {
                // 阻塞式的获取锁，调用同步器模版方法独占式，获取同步状态
                sync.acquire(1);
        }

        @Override
        public void lockInterruptibly() throws InterruptedException {
                // 调用同步器模版方法可中断式获取同步状态
                sync.acquireInterruptibly(1);
        }

        @Override
        public boolean tryLock() {
                // 调用自己重写的方法，非阻塞式的获取同步状态
                return sync.tryAcquire(1);
        }

        @Override
        public boolean tryLock(long time, TimeUnit unit) throws InterruptedException {
                // 调用同步器模版方法，可响应中断和超时时间限制
                return sync.tryAcquireNanos(1, unit.toNanos(time));
        }

        @Override
        public void unlock() {
                // 释放锁
                sync.release(1);
        }

        @Override
        public Condition newCondition() {
                // 使用自定义的条件
                return sync.newCondition();
        }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果你现在打开 IDE， 你会发现上文提到的 &lt;code&gt;ReentrantLock&lt;/code&gt; &lt;code&gt;ReentrantReadWriteLock&lt;/code&gt; &lt;code&gt;Semaphore(信号量)&lt;/code&gt; &lt;code&gt;CountDownLatch&lt;/code&gt; 都是按照这个结构实现，所以我们就来看一看 AQS 的模版方法到底是怎么实现锁&lt;/p&gt;
&lt;h2 id=&quot;aqs实现分析&quot;&gt;AQS实现分析&lt;/h2&gt;
&lt;p&gt;从上面的代码中，你应该理解了&lt;code&gt;lock.tryLock()&lt;/code&gt; 非阻塞式获取锁就是调用自定义同步器重写的 &lt;code&gt;tryAcquire()&lt;/code&gt; 方法，通过 CAS 设置state 状态，不管成功与否都会马上返回；那么 lock.lock() 这种阻塞式的锁是如何实现的呢？&lt;/p&gt;
&lt;p&gt;有阻塞就需要排队，实现排队必然需要队列&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;CLH：Craig、Landin and Hagersten 队列，是一个单向链表，AQS中的队列是CLH变体的虚拟双向队列（FIFO）——概念了解就好，不要记&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;队列中每个排队的个体就是一个 Node，所以我们来看一下 Node 的结构&lt;/p&gt;
&lt;h3 id=&quot;node-节点&quot;&gt;Node 节点&lt;/h3&gt;
&lt;p&gt;AQS 内部维护了一个同步队列，用于管理同步状态。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当线程获取同步状态失败时，就会将当前线程以及等待状态等信息构造成一个 Node 节点，将其加入到同步队列中尾部，阻塞该线程&lt;/li&gt;
&lt;li&gt;当同步状态被释放时，会唤醒同步队列中“首节点”的线程获取同步状态&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;为了将上述步骤弄清楚，我们需要来看一看 Node 结构 （如果你能打开 IDE 一起看那是极好的）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202006/1583165-20200603085611312-2120888150.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;乍一看有点杂乱，我们还是将其归类说明一下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202006/1583165-20200603085611873-1847886670.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面这几个状态说明有个印象就好，有了Node 的结构说明铺垫，你也就能想象同步队列的接本结构了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202006/1583165-20200603085612218-1685838416.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;前置知识基本铺垫完毕，我们来看一看独占式获取同步状态的整个过程&lt;/p&gt;
&lt;h3 id=&quot;独占式获取同步状态&quot;&gt;独占式获取同步状态&lt;/h3&gt;
&lt;p&gt;故事要从范式lock.lock() 开始&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public void lock() {
        // 阻塞式的获取锁，调用同步器模版方法，获取同步状态
        sync.acquire(1);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;进入AQS的模版方法 acquire()&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public final void acquire(int arg) {
  // 调用自定义同步器重写的 tryAcquire 方法
        if (!tryAcquire(arg) &amp;amp;&amp;amp;
                acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
                selfInterrupt();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先，也会尝试非阻塞的获取同步状态，如果获取失败（tryAcquire返回false），则会调用 &lt;code&gt;addWaiter&lt;/code&gt; 方法构造 Node 节点（Node.EXCLUSIVE 独占式）并安全的（CAS）加入到同步队列【尾部】&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    private Node addWaiter(Node mode) {
        // 构造Node节点，包含当前线程信息以及节点模式【独占/共享】
        Node node = new Node(Thread.currentThread(), mode);
        // 新建变量 pred 将指针指向tail指向的节点
        Node pred = tail;
        // 如果尾节点不为空
        if (pred != null) {
                // 新加入的节点前驱节点指向尾节点
            node.prev = pred;

                // 因为如果多个线程同时获取同步状态失败都会执行这段代码
            // 所以，通过 CAS 方式确保安全的设置当前节点为最新的尾节点
            if (compareAndSetTail(pred, node)) {
                // 曾经的尾节点的后继节点指向当前节点
                pred.next = node;
                // 返回新构建的节点
                return node;
            }
        }
        // 尾节点为空，说明当前节点是第一个被加入到同步队列中的节点
        // 需要一个入队操作
        enq(node);
        return node;
    }

    private Node enq(final Node node) {
        // 通过“死循环”确保节点被正确添加，最终将其设置为尾节点之后才会返回，这里使用 CAS 的理由和上面一样
        for (;;) {
            Node t = tail;
                // 第一次循环，如果尾节点为 null
            if (t == null) { // Must initialize
                // 构建一个哨兵节点，并将头部指针指向它
                if (compareAndSetHead(new Node()))
                        // 尾部指针同样指向哨兵节点
                    tail = head;
            } else {
                // 第二次循环，将新节点的前驱节点指向t
                node.prev = t;
                // 将新节点加入到队列尾节点
                if (compareAndSetTail(t, node)) {
                        // 前驱节点的后继节点指向当前新节点，完成双向队列
                    t.next = node;
                    return t;
                }
            }
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你可能比较迷惑 enq() 的处理方式，进入该方法就是一个“死循环”，我们就用图来描述它是怎样跳出循环的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202006/1583165-20200603085612686-1807417578.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;有些同学可能会有疑问，为什么会有哨兵节点？&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;哨兵，顾名思义，是用来解决国家之间边界问题的，不直接参与生产活动。同样，计算机科学中提到的哨兵，也用来解决边界问题，如果没有边界，指定环节，按照同样算法可能会在边界处发生异常，比如要继续向下分析的 &lt;code&gt;acquireQueued()&lt;/code&gt; 方法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    final boolean acquireQueued(final Node node, int arg) {
        boolean failed = true;
        try {
            boolean interrupted = false;
                // &quot;死循环&quot;，尝试获取锁，或者挂起
            for (;;) {
                // 获取当前节点的前驱节点
                final Node p = node.predecessor();
                // 只有当前节点的前驱节点是头节点，才会尝试获取锁
                // 看到这你应该理解添加哨兵节点的含义了吧
                if (p == head &amp;amp;&amp;amp; tryAcquire(arg)) {
                        // 获取同步状态成功，将自己设置为头
                    setHead(node);
                        // 将哨兵节点的后继节点置为空，方便GC
                    p.next = null; // help GC
                    failed = false;
                        // 返回中断标识
                    return interrupted;
                }
                // 当前节点的前驱节点不是头节点
                //【或者】当前节点的前驱节点是头节点但获取同步状态失败
                if (shouldParkAfterFailedAcquire(p, node) &amp;amp;&amp;amp;
                    parkAndCheckInterrupt())
                    interrupted = true;
            }
        } finally {
            if (failed)
                cancelAcquire(node);
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;获取同步状态成功会返回可以理解了，但是如果失败就会一直陷入到“死循环”中浪费资源吗？很显然不是，&lt;code&gt;shouldParkAfterFailedAcquire(p, node)&lt;/code&gt; 和 &lt;code&gt;parkAndCheckInterrupt()&lt;/code&gt; 就会将线程获取同步状态失败的线程挂起，我们继续向下看&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {
        // 获取前驱节点的状态
        int ws = pred.waitStatus;
        // 如果是 SIGNAL 状态，即等待被占用的资源释放，直接返回 true
        // 准备继续调用 parkAndCheckInterrupt 方法
        if (ws == Node.SIGNAL)
            return true;
        // ws 大于0说明是CANCELLED状态，
        if (ws &amp;gt; 0) {
            // 循环判断前驱节点的前驱节点是否也为CANCELLED状态，忽略该状态的节点，重新连接队列
            do {
                node.prev = pred = pred.prev;
            } while (pred.waitStatus &amp;gt; 0);
            pred.next = node;
        } else {
                // 将当前节点的前驱节点设置为设置为 SIGNAL 状态，用于后续唤醒操作
                // 程序第一次执行到这返回为false，还会进行外层第二次循环，最终从代码第7行返回
            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);
        }
        return false;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;到这里你也许有个问题：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;这个地方设置前驱节点为 SIGNAL 状态到底有什么作用？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;保留这个问题，我们陆续揭晓&lt;/p&gt;
&lt;p&gt;如果前驱节点的 waitStatus 是 SIGNAL状态，即 shouldParkAfterFailedAcquire 方法会返回 true ，程序会继续向下执行 &lt;code&gt;parkAndCheckInterrupt&lt;/code&gt; 方法，用于将当前线程挂起&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    private final boolean parkAndCheckInterrupt() {
        // 线程挂起，程序不会继续向下执行
        LockSupport.park(this);
        // 根据 park 方法 API描述，程序在下述三种情况会继续向下执行
        //      1. 被 unpark 
        //      2. 被中断(interrupt)
        //      3. 其他不合逻辑的返回才会继续向下执行
        
        // 因上述三种情况程序执行至此，返回当前线程的中断状态，并清空中断状态
        // 如果由于被中断，该方法会返回 true
        return Thread.interrupted();
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;被唤醒的程序会继续执行 &lt;code&gt;acquireQueued&lt;/code&gt; 方法里的循环，如果获取同步状态成功，则会返回 &lt;code&gt;interrupted = true&lt;/code&gt; 的结果&lt;/p&gt;
&lt;p&gt;程序继续向调用栈上层返回，最终回到 AQS 的模版方法 &lt;code&gt;acquire&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public final void acquire(int arg) {
        if (!tryAcquire(arg) &amp;amp;&amp;amp;
                acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
                selfInterrupt();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你也许会有疑惑:&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;程序已经成功获取到同步状态并返回了，怎么会有个自我中断呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;static void selfInterrupt() {
    Thread.currentThread().interrupt();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202006/1583165-20200603085613030-499686487.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果你不能理解中断，强烈建议你回看 &lt;a href=&quot;https://dayarch.top/p/java-concurrency-interrupt-mechnism.html&quot;&gt;Java多线程中断机制&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;到这里关于获取同步状态我们还遗漏了一条线，acquireQueued 的 finally 代码块如果你仔细看你也许马上就会有疑惑:&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;到底什么情况才会执行 if(failed) 里面的代码 ？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;if (failed)
  cancelAcquire(node);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段代码被执行的条件是 failed 为 true，正常情况下，如果跳出循环，failed 的值为false，如果不能跳出循环貌似怎么也不能执行到这里，所以只有不正常的情况才会执行到这里，也就是会发生异常，才会执行到此处&lt;/p&gt;
&lt;p&gt;查看 try 代码块，只有两个方法会抛出异常：&lt;/p&gt;
&lt;p&gt;先看前者：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202006/1583165-20200603085613513-1274351304.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;很显然，这里抛出的异常不是重点，那就以 ReentrantLock 重写的 tryAcquire() 方法为例&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202006/1583165-20200603085613919-75729732.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;另外，上面分析 &lt;code&gt;shouldParkAfterFailedAcquire&lt;/code&gt; 方法还对 CANCELLED 的状态进行了判断，那么&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;什么时候会生成取消状态的节点呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;答案就在 &lt;code&gt;cancelAcquire&lt;/code&gt; 方法中， 我们来看看 cancelAcquire到底怎么设置/处理 CANNELLED 的&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;       private void cancelAcquire(Node node) {
        // 忽略无效节点
        if (node == null)
            return;
                                // 将关联的线程信息清空
        node.thread = null;

        // 跳过同样是取消状态的前驱节点
        Node pred = node.prev;
        while (pred.waitStatus &amp;gt; 0)
            node.prev = pred = pred.prev;

        // 跳出上面循环后找到前驱有效节点，并获取该有效节点的后继节点
        Node predNext = pred.next;

        // 将当前节点的状态置为 CANCELLED
        node.waitStatus = Node.CANCELLED;

        // 如果当前节点处在尾节点，直接从队列中删除自己就好
        if (node == tail &amp;amp;&amp;amp; compareAndSetTail(node, pred)) {
            compareAndSetNext(pred, predNext, null);
        } else {
            int ws;
                // 1. 如果当前节点的有效前驱节点不是头节点，也就是说当前节点不是头节点的后继节点
            if (pred != head &amp;amp;&amp;amp;
                // 2. 判断当前节点有效前驱节点的状态是否为 SIGNAL
                ((ws = pred.waitStatus) == Node.SIGNAL ||
                 // 3. 如果不是，尝试将前驱节点的状态置为 SIGNAL
                 (ws &amp;lt;= 0 &amp;amp;&amp;amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;amp;&amp;amp;
                // 判断当前节点有效前驱节点的线程信息是否为空
                pred.thread != null) {
                // 上述条件满足
                Node next = node.next;
                // 将当前节点有效前驱节点的后继节点指针指向当前节点的后继节点
                if (next != null &amp;amp;&amp;amp; next.waitStatus &amp;lt;= 0)
                    compareAndSetNext(pred, predNext, next);
            } else {
                // 如果当前节点的前驱节点是头节点，或者上述其他条件不满足，就唤醒当前节点的后继节点
                unparkSuccessor(node);
            }
                                                
            node.next = node; // help GC
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看到这个注释你可能有些乱了，其核心目的就是从等待队列中移除 CANCELLED 的节点，并重新拼接整个队列，总结来看，其实设置 CANCELLED 状态节点只是有三种情况，我们通过画图来分析一下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202006/1583165-20200603085614274-1369002054.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202006/1583165-20200603085614841-1077927841.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202006/1583165-20200603085615230-1291531068.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至此，获取同步状态的过程就结束了，我们简单的用流程图说明一下整个过程&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202006/1583165-20200603085616132-393799618.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;获取锁的过程就这样的结束了，先暂停几分钟整理一下自己的思路。我们上面还没有说明 SIGNAL 的作用， SIGNAL 状态信号到底是干什么用的？这就涉及到锁的释放了，我们来继续了解，整体思路和锁的获取是一样的， 但是释放过程就相对简单很多了&lt;/p&gt;
&lt;h3 id=&quot;独占式释放同步状态&quot;&gt;独占式释放同步状态&lt;/h3&gt;
&lt;p&gt;故事要从 unlock() 方法说起&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;       public void unlock() {
                // 释放锁
                sync.release(1);
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;调用 AQS 模版方法 release，进入该方法&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    public final boolean release(int arg) {
        // 调用自定义同步器重写的 tryRelease 方法尝试释放同步状态
        if (tryRelease(arg)) {
                // 释放成功，获取头节点
            Node h = head;
                // 存在头节点，并且waitStatus不是初始状态
                // 通过获取的过程我们已经分析了，在获取的过程中会将 waitStatus的值从初始状态更新成 SIGNAL 状态
            if (h != null &amp;amp;&amp;amp; h.waitStatus != 0)
                // 解除线程挂起状态
                unparkSuccessor(h);
            return true;
        }
        return false;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查看 unparkSuccessor 方法，实际是要唤醒头节点的后继节点&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    private void unparkSuccessor(Node node) {      
        // 获取头节点的waitStatus
        int ws = node.waitStatus;
        if (ws &amp;lt; 0)
                // 清空头节点的waitStatus值，即置为0
            compareAndSetWaitStatus(node, ws, 0);
      
        // 获取头节点的后继节点
        Node s = node.next;
        // 判断当前节点的后继节点是否是取消状态，如果是，需要移除，重新连接队列
        if (s == null || s.waitStatus &amp;gt; 0) {
            s = null;
                // 从尾节点向前查找，找到队列第一个waitStatus状态小于0的节点
            for (Node t = tail; t != null &amp;amp;&amp;amp; t != node; t = t.prev)
                // 如果是独占式，这里小于0，其实就是 SIGNAL
                if (t.waitStatus &amp;lt;= 0)
                    s = t;
        }
        if (s != null)
                // 解除线程挂起状态
            LockSupport.unpark(s.thread);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有同学可能有疑问：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;为什么这个地方是从队列尾部向前查找不是 CANCELLED 的节点？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;原因有两个：&lt;/p&gt;
&lt;p&gt;第一，先回看节点加入队列的情景：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    private Node addWaiter(Node mode) {
        Node node = new Node(Thread.currentThread(), mode);
        // Try the fast path of enq; backup to full enq on failure
        Node pred = tail;
        if (pred != null) {
            node.prev = pred;
            if (compareAndSetTail(pred, node)) {
                pred.next = node;
                return node;
            }
        }
        enq(node);
        return node;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;节点入队并不是原子操作，代码第6、7行&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;node.prev = pred; 
compareAndSetTail(pred, node) 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这两个地方可以看作是尾节点入队的原子操作，如果此时代码还没执行到 pred.next = node; 这时又恰巧执行了unparkSuccessor方法，就没办法从前往后找了，因为后继指针还没有连接起来，所以需要从后往前找&lt;/p&gt;
&lt;p&gt;第二点原因，在上面图解产生 CANCELLED 状态节点的时候，先断开的是 Next 指针，Prev指针并未断开，因此这也是必须要从后往前遍历才能够遍历完全部的Node&lt;/p&gt;
&lt;p&gt;同步状态至此就已经成功释放了，之前获取同步状态被挂起的线程就会被唤醒，继续从下面代码第 3 行返回执行：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    private final boolean parkAndCheckInterrupt() {
        LockSupport.park(this);
        return Thread.interrupted();
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;继续返回上层调用栈, 从下面代码15行开始执行，重新执行循环，再次尝试获取同步状态&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    final boolean acquireQueued(final Node node, int arg) {
        boolean failed = true;
        try {
            boolean interrupted = false;
            for (;;) {
                final Node p = node.predecessor();
                if (p == head &amp;amp;&amp;amp; tryAcquire(arg)) {
                    setHead(node);
                    p.next = null; // help GC
                    failed = false;
                    return interrupted;
                }
                if (shouldParkAfterFailedAcquire(p, node) &amp;amp;&amp;amp;
                    parkAndCheckInterrupt())
                    interrupted = true;
            }
        } finally {
            if (failed)
                cancelAcquire(node);
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;到这里，关于独占式获取/释放锁的流程已经闭环了，但是关于 AQS 的另外两个模版方法还没有介绍&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;响应中断&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;超时限制&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202006/1583165-20200603085616446-495506814.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;独占式响应中断获取同步状态&quot;&gt;独占式响应中断获取同步状态&lt;/h3&gt;
&lt;p&gt;故事要从lock.lockInterruptibly() 方法说起&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;       public void lockInterruptibly() throws InterruptedException {
                // 调用同步器模版方法可中断式获取同步状态
                sync.acquireInterruptibly(1);
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有了前面的理解，理解独占式可响应中断的获取同步状态方式，真是一眼就能明白了：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    public final void acquireInterruptibly(int arg)
            throws InterruptedException {
        if (Thread.interrupted())
            throw new InterruptedException();
        // 尝试非阻塞式获取同步状态失败，如果没有获取到同步状态，执行代码7行
        if (!tryAcquire(arg))
            doAcquireInterruptibly(arg);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;继续查看 &lt;code&gt;doAcquireInterruptibly&lt;/code&gt; 方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    private void doAcquireInterruptibly(int arg)
        throws InterruptedException {
        final Node node = addWaiter(Node.EXCLUSIVE);
        boolean failed = true;
        try {
            for (;;) {
                final Node p = node.predecessor();
                if (p == head &amp;amp;&amp;amp; tryAcquire(arg)) {
                    setHead(node);
                    p.next = null; // help GC
                    failed = false;
                    return;
                }
                if (shouldParkAfterFailedAcquire(p, node) &amp;amp;&amp;amp;
                    parkAndCheckInterrupt())
                        // 获取中断信号后，不再返回 interrupted = true 的值，而是直接抛出 InterruptedException 
                    throw new InterruptedException();
            }
        } finally {
            if (failed)
                cancelAcquire(node);
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;没想到 JDK 内部也有如此相近的代码，可响应中断获取锁没什么深奥的，就是被中断抛出 InterruptedException 异常（代码第17行），这样就逐层返回上层调用栈捕获该异常进行下一步操作了&lt;/p&gt;
&lt;p&gt;趁热打铁，来看看另外一个模版方法：&lt;/p&gt;
&lt;h3 id=&quot;独占式超时限制获取同步状态&quot;&gt;独占式超时限制获取同步状态&lt;/h3&gt;
&lt;p&gt;这个很好理解，就是给定一个时限，在该时间段内获取到同步状态，就返回 true， 否则，返回 false。好比线程给自己定了一个闹钟，闹铃一响，线程就自己返回了，这就不会使自己是阻塞状态了&lt;/p&gt;
&lt;p&gt;既然涉及到超时限制，其核心逻辑肯定是计算时间间隔，因为在超时时间内，肯定是多次尝试获取锁的，每次获取锁肯定有时间消耗，所以计算时间间隔的逻辑就像我们在程序打印程序耗时 log 那么简单&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;nanosTimeout = deadline - System.nanoTime()&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;故事要从 &lt;code&gt;lock.tryLock(time, unit)&lt;/code&gt; 方法说起&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;       public boolean tryLock(long time, TimeUnit unit) throws InterruptedException {
                // 调用同步器模版方法，可响应中断和超时时间限制
                return sync.tryAcquireNanos(1, unit.toNanos(time));
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;来看 tryAcquireNanos 方法&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    public final boolean tryAcquireNanos(int arg, long nanosTimeout)
            throws InterruptedException {
        if (Thread.interrupted())
            throw new InterruptedException();
        return tryAcquire(arg) ||
            doAcquireNanos(arg, nanosTimeout);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;是不是和上面 &lt;code&gt;acquireInterruptibly&lt;/code&gt; 方法长相很详细了，继续查看来 doAcquireNanos 方法，看程序, 该方法也是 throws InterruptedException，我们在中断文章中说过，方法标记上有 &lt;code&gt;throws InterruptedException&lt;/code&gt; 说明该方法也是可以响应中断的，所以你可以理解超时限制是 &lt;code&gt;acquireInterruptibly&lt;/code&gt; 方法的加强版，具有超时和非阻塞控制的双保险&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    private boolean doAcquireNanos(int arg, long nanosTimeout)
            throws InterruptedException {
        // 超时时间内，为获取到同步状态，直接返回false
        if (nanosTimeout &amp;lt;= 0L)
            return false;
        // 计算超时截止时间
        final long deadline = System.nanoTime() + nanosTimeout;
        // 以独占方式加入到同步队列中
        final Node node = addWaiter(Node.EXCLUSIVE);
        boolean failed = true;
        try {
            for (;;) {
                final Node p = node.predecessor();
                if (p == head &amp;amp;&amp;amp; tryAcquire(arg)) {
                    setHead(node);
                    p.next = null; // help GC
                    failed = false;
                    return true;
                }
                // 计算新的超时时间
                nanosTimeout = deadline - System.nanoTime();
                // 如果超时，直接返回 false
                if (nanosTimeout &amp;lt;= 0L)
                    return false;
                if (shouldParkAfterFailedAcquire(p, node) &amp;amp;&amp;amp;
                                // 判断是最新超时时间是否大于阈值 1000    
                    nanosTimeout &amp;gt; spinForTimeoutThreshold)
                        // 挂起线程 nanosTimeout 长时间，时间到，自动返回
                    LockSupport.parkNanos(this, nanosTimeout);
                if (Thread.interrupted())
                    throw new InterruptedException();
            }
        } finally {
            if (failed)
                cancelAcquire(node);
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的方法应该不是很难懂，但是又同学可能在第 27 行上有所困惑&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;为什么 nanosTimeout 和 自旋超时阈值1000进行比较？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;    /**
     * The number of nanoseconds for which it is faster to spin
     * rather than to use timed park. A rough estimate suffices
     * to improve responsiveness with very short timeouts.
     */
    static final long spinForTimeoutThreshold = 1000L;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其实 doc 说的很清楚，说白了，1000 nanoseconds 时间已经非常非常短暂了，没必要再执行挂起和唤醒操作了，不如直接当前线程直接进入下一次循环&lt;/p&gt;
&lt;p&gt;到这里，我们自定义的 MyMutex 只差 Condition 没有说明了，不知道你累了吗？我还在坚持&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202006/1583165-20200603085616707-360885392.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;condition&quot;&gt;Condition&lt;/h3&gt;
&lt;p&gt;如果你看过之前写的 &lt;a href=&quot;https://dayarch.top/p/waiting-notification-mechanism.html&quot;&gt;并发编程之等待通知机制&lt;/a&gt; ，你应该对下面这个图是有印象的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202006/1583165-20200603085617602-837282469.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果当时你理解了这个模型，再看 Condition 的实现，根本就不是问题了，首先 Condition 还是一个接口，肯定也是需要有实现类的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202006/1583165-20200603085618194-1537186448.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那故事就从 &lt;code&gt;lock.newnewCondition&lt;/code&gt; 说起吧&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;       public Condition newCondition() {
                // 使用自定义的条件
                return sync.newCondition();
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;自定义同步器重封装了该方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;               Condition newCondition() {
                        return new ConditionObject();
                }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ConditionObject 就是 Condition 的实现类，该类就定义在了 AQS 中，只有两个成员变量：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/** First node of condition queue. */
private transient Node firstWaiter;
/** Last node of condition queue. */
private transient Node lastWaiter;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以，我们只需要来看一下 ConditionObject 实现的 await / signal 方法来使用这两个成员变量就可以了&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;        public final void await() throws InterruptedException {
            if (Thread.interrupted())
                throw new InterruptedException();
                // 同样构建 Node 节点，并加入到等待队列中
            Node node = addConditionWaiter();
                // 释放同步状态
            int savedState = fullyRelease(node);
            int interruptMode = 0;
            while (!isOnSyncQueue(node)) {
                // 挂起当前线程
                LockSupport.park(this);
                if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)
                    break;
            }
            if (acquireQueued(node, savedState) &amp;amp;&amp;amp; interruptMode != THROW_IE)
                interruptMode = REINTERRUPT;
            if (node.nextWaiter != null) // clean up if cancelled
                unlinkCancelledWaiters();
            if (interruptMode != 0)
                reportInterruptAfterWait(interruptMode);
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里注意用词，在介绍获取同步状态时，addWaiter 是加入到【同步队列】，就是上图说的入口等待队列，这里说的是【等待队列】，所以 addConditionWaiter 肯定是构建了一个自己的队列：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;        private Node addConditionWaiter() {
            Node t = lastWaiter;
            
            if (t != null &amp;amp;&amp;amp; t.waitStatus != Node.CONDITION) {
                unlinkCancelledWaiters();
                t = lastWaiter;
            }
                // 新构建的节点的 waitStatus 是 CONDITION，注意不是 0 或 SIGNAL 了
            Node node = new Node(Thread.currentThread(), Node.CONDITION);
                // 构建单向同步队列
            if (t == null)
                firstWaiter = node;
            else
                t.nextWaiter = node;
            lastWaiter = node;
            return node;
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里有朋友可能会有疑问：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;为什么这里是单向队列，也没有使用CAS 来保证加入队列的安全性呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因为 await 是 Lock 范式 try 中使用的，说明已经获取到锁了，所以就没必要使用 CAS 了，至于是单向，因为这里还不涉及到竞争锁，只是做一个条件等待队列&lt;/p&gt;
&lt;p&gt;在 Lock 中可以定义多个条件，每个条件都会对应一个 条件等待队列，所以将上图丰富说明一下就变成了这个样子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202006/1583165-20200603085618993-1154735239.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;线程已经按相应的条件加入到了条件等待队列中，那如何再尝试获取锁呢？signal / signalAll 方法就已经排上用场了&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;        public final void signal() {
            if (!isHeldExclusively())
                throw new IllegalMonitorStateException();
            Node first = firstWaiter;
            if (first != null)
                doSignal(first);
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Signal 方法通过调用 doSignal 方法，只唤醒条件等待队列中的第一个节点&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;        private void doSignal(Node first) {
            do {
                if ( (firstWaiter = first.nextWaiter) == null)
                    lastWaiter = null;
                first.nextWaiter = null;
                // 调用该方法，将条件等待队列的线程节点移动到同步队列中
            } while (!transferForSignal(first) &amp;amp;&amp;amp;
                     (first = firstWaiter) != null);
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;继续看 &lt;code&gt;transferForSignal&lt;/code&gt; 方法&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    final boolean transferForSignal(Node node) {       
        if (!compareAndSetWaitStatus(node, Node.CONDITION, 0))
            return false;

        // 重新进行入队操作
        Node p = enq(node);
        int ws = p.waitStatus;
        if (ws &amp;gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))
                // 唤醒同步队列中该线程
            LockSupport.unpark(node.thread);
        return true;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以我们再用图解一下唤醒的整个过程&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202006/1583165-20200603085619552-648881093.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;到这里，理解 signalAll 就非常简单了，只不过循环判断是否还有 nextWaiter，如果有就像 signal 操作一样，将其从条件等待队列中移到同步队列中&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;        private void doSignalAll(Node first) {
            lastWaiter = firstWaiter = null;
            do {
                Node next = first.nextWaiter;
                first.nextWaiter = null;
                transferForSignal(first);
                first = next;
            } while (first != null);
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不知你还是否记得，我在&lt;a href=&quot;https://dayarch.top/p/waiting-notification-mechanism.html&quot;&gt;并发编程之等待通知机制&lt;/a&gt; 中还说过一句话&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;没有特殊原因尽量用 signalAll 方法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;什么时候可以用 signal 方法也在其中做了说明，请大家自行查看吧&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202006/1583165-20200603085619826-82766649.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里我还要多说一个细节，从条件等待队列移到同步队列是有时间差的，所以使用 await() 方法也是范式的， 同样在该文章中做了解释&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202006/1583165-20200603085620349-1518626595.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;有时间差，就会有公平和不公平的问题，想要全面了解这个问题，我们就要走近 ReentrantLock 中来看了，除了了解公平/不公平问题，查看 ReentrantLock 的应用还是要反过来验证它使用的AQS的，我们继续吧&lt;/p&gt;
&lt;h2 id=&quot;reentrantlock-是如何应用的aqs&quot;&gt;ReentrantLock 是如何应用的AQS&lt;/h2&gt;
&lt;p&gt;独占式的典型应用就是 ReentrantLock 了，我们来看看它是如何重写这个方法的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202006/1583165-20200603085620779-1309366205.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;乍一看挺奇怪的，怎么里面自定义了三个同步器：其实 NonfairSync，FairSync 只是对 Sync 做了进一步划分：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202006/1583165-20200603085621068-265706269.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从名称上你应该也知道了，这就是你听到过的 &lt;code&gt;公平锁/非公平锁&lt;/code&gt;了&lt;/p&gt;
&lt;h3 id=&quot;何为公平锁非公平锁？&quot;&gt;何为公平锁/非公平锁？&lt;/h3&gt;
&lt;p&gt;生活中，排队讲求先来后到视为公平。程序中的公平性也是符合请求锁的绝对时间的，其实就是 FIFO，否则视为不公平&lt;/p&gt;
&lt;p&gt;我们来对比一下 ReentrantLock 是如何实现公平锁和非公平锁的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202006/1583165-20200603085621719-204749508.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其实没什么大不了，公平锁就是判断同步队列是否还有先驱节点的存在，只有没有先驱节点才能获取锁；而非公平锁是不管这个事的，能获取到同步状态就可以，就这么简单，那问题来了：&lt;/p&gt;
&lt;h3 id=&quot;为什么会有公平锁非公平锁的设计？&quot;&gt;为什么会有公平锁/非公平锁的设计？&lt;/h3&gt;
&lt;p&gt;考虑这个问题，我们需重新回忆上面的锁获取实现图了，其实上面我已经透露了一点&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202006/1583165-20200603085619552-648881093.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;主要有两点原因：&lt;/p&gt;
&lt;h4 id=&quot;原因一：&quot;&gt;原因一：&lt;/h4&gt;
&lt;p&gt;恢复挂起的线程到真正锁的获取还是有时间差的，从人类的角度来看这个时间微乎其微，但是从CPU的角度来看，这个时间差存在的还是很明显的。所以非公平锁能更充分的利用 CPU 的时间片，尽量减少 CPU 空闲状态时间&lt;/p&gt;
&lt;h4 id=&quot;原因二：&quot;&gt;原因二：&lt;/h4&gt;
&lt;p&gt;不知你是否还记得我在 &lt;a href=&quot;https://dayarch.top/p/how-many-threads-should-be-created.html&quot;&gt;面试问，创建多少个线程合适？&lt;/a&gt; 文章中反复提到过，使用多线程很重要的考量点是线程切换的开销，想象一下，如果采用非公平锁，当一个线程请求锁获取同步状态，然后释放同步状态，因为不需要考虑是否还有前驱节点，所以刚释放锁的线程在此刻再次获取同步状态的几率就变得非常大，所以就减少了线程的开销&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202006/1583165-20200603085622638-1643617207.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;相信到这里，你也就明白了，为什么 ReentrantLock 默认构造器用的是非公平锁同步器&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    public ReentrantLock() {
        sync = new NonfairSync();
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看到这里，感觉非公平锁 perfect，非也，有得必有失&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;使用公平锁会有什么问题？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;公平锁保证了排队的公平性，非公平锁霸气的忽视这个规则，所以就有可能导致排队的长时间在排队，也没有机会获取到锁，这就是传说中的 &lt;strong&gt;“饥饿”&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;如何选择公平锁非公平锁？&quot;&gt;如何选择公平锁/非公平锁？&lt;/h3&gt;
&lt;p&gt;相信到这里，答案已经在你心中了，如果为了更高的吞吐量，很显然非公平锁是比较合适的，因为节省很多线程切换时间，吞吐量自然就上去了，否则那就用公平锁还大家一个公平&lt;/p&gt;
&lt;p&gt;我们还差最后一个环节，真的要挺住&lt;/p&gt;
&lt;h3 id=&quot;可重入锁&quot;&gt;可重入锁&lt;/h3&gt;
&lt;p&gt;到这里，我们还没分析 ReentrantLock 的名字，JDK 起名这么有讲究，肯定有其含义，直译过来【可重入锁】&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;为什么要支持锁的重入？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;试想，如果是一个有 synchronized 修饰的递归调用方法，程序第二次进入被自己阻塞了岂不是很大的笑话，所以 synchronized 是支持锁的重入的&lt;/p&gt;
&lt;p&gt;Lock 是新轮子，自然也要支持这个功能，其实现也很简单，请查看公平锁和非公平锁对比图，其中有一段代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 判断当前线程是否和已占用锁的线程是同一个
else if (current == getExclusiveOwnerThread())
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;仔细看代码， 你也许发现，我前面的一个说明是错误的，我要重新解释一下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202006/1583165-20200603085622944-208848547.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;重入的线程会一直将 state + 1， 释放锁会 state - 1直至等于0，上面这样写也是想帮助大家快速的区分&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;本文是一个长文，说明了为什么要造 Lock 新轮子，如何标准的使用 Lock，AQS 是什么，是如何实现锁的，结合 ReentrantLock 反推 AQS 中的一些应用以及其独有的一些特性&lt;/p&gt;
&lt;p&gt;独占式获取锁就这样介绍完了，我们还差 AQS 共享式 &lt;code&gt;xxxShared&lt;/code&gt; 没有分析，结合共享式，接下来我们来阅读一下 Semaphore，ReentrantReadWriteLock 和 CountLatch 等&lt;/p&gt;
&lt;p&gt;最后，也欢迎大家的留言，如有错误之处还请指出。我的手酸了，眼睛干了，我去准备撸下一篇.....&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202006/1583165-20200603085623206-360747118.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;灵魂追问&quot;&gt;灵魂追问&lt;/h2&gt;
&lt;ol readability=&quot;3&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;为什么更改 state 有 setState() , compareAndSetState() 两种方式，感觉后者更安全，但是锁的视线中有好多地方都使用了 setState()，安全吗？&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;下面代码是一个转账程序，是否存在死锁或者锁的其他问题呢？&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;
class Account {
  private int balance;
  private final Lock lock
          = new ReentrantLock();
  // 转账
  void transfer(Account tar, int amt){
    while (true) {
      if(this.lock.tryLock()) {
        try {
          if (tar.lock.tryLock()) {
            try {
              this.balance -= amt;
              tar.balance += amt;
            } finally {
              tar.lock.unlock();
            }
          }//if
        } finally {
          this.lock.unlock();
        }
      }//if
    }//while
  }//transfer
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;Java 并发实战&lt;/li&gt;
&lt;li&gt;Java 并发编程的艺术&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html&quot;&gt;https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Wed, 03 Jun 2020 00:56:00 +0000</pubDate>
<dc:creator>日拱一兵</dc:creator>
<og:description>| 好看请赞，养成习惯 你有一个思想，我有一个思想，我们交换后，一个人就有两个思想 If you can NOT explain it simply, you do NOT understand it</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/FraserYu/p/13035284.html</dc:identifier>
</item>
<item>
<title>居然还有人这样解说mybatis运行原理 - 烟花散尽13141</title>
<link>http://www.cnblogs.com/zhangxinhua/p/13035241.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangxinhua/p/13035241.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;mybatis运行分为两部分，第一部分读取配置文件缓存到Configuration对象中。用以创建SqlSessionFactory，第二部分是SqlSession的执行过程。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;动态代理&quot;&gt;动态代理&lt;/h2&gt;
&lt;ul readability=&quot;3&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;之前我们知道Mapper仅仅是一个接口，而不是一个逻辑实现类。但是在Java中接口是无法执行逻辑的。这里Mybatis就是通过动态代理实现的。关于动态代理我们常用的有Jdk动态代理和cglib动态代理。两种却别这里不做赘述。关于CGLIB代理在框架中使用的比较多。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;关于动态代理就是所有的请求有一个入口，由这个入口进行分发。在开发领域的一个用途就是【负载均衡】&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;关于Mybatis的动态代理是使用了两种的结合。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;下面看看JDK和cglib两种实现&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;jdk实现&quot;&gt;JDK实现&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;首先我们需要提供一个接口 , 这个接口是对我们程序员的一个抽象。 拥有编码和改BUG的本领&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;
public interface Developer {

    /**
     * 编码
     */
    void code();

    /**
     * 解决问题
     */
    void debug();
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;关于这两种本领每个人处理方式不同。这里我们需要一个具体的实例对象&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;
public class JavaDeveloper implements Developer {
    @Override
    public void code() {
        System.out.println(&quot;java code&quot;);
    }

    @Override
    public void debug() {
        System.out.println(&quot;java debug&quot;);
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;我们传统的调用方式是通过java提供的new 机制创造一个JavaDeveloper对象出来。而通过动态代理是通过&lt;code&gt;java.lang.reflect.Proxy&lt;/code&gt;对象创建对象调用实际方法的。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;通过&lt;code&gt;newProxyInstance&lt;/code&gt;方法获取接口对象的。而这个方法需要三个参数&lt;br/&gt;ClassLoader loader ： 通过实际接口实例对象获取ClassLoader&lt;br/&gt;Class&amp;lt;?&amp;gt;[] interfaces : 我们抽象的接口&lt;br/&gt;InvocationHandler h ： 对我们接口对象方法的调用。在调用节点我们可以进行我们的业务拦截&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;
JavaDeveloper jDeveloper = new JavaDeveloper();
Developer developer = (Developer) Proxy.newProxyInstance(jDeveloper.getClass().getClassLoader(), jDeveloper.getClass().getInterfaces(), (proxy, method, params) -&amp;gt; {
    if (method.getName().equals(&quot;code&quot;)) {
        System.out.println(&quot;我是一个特殊的人，code之前先分析问题&quot;);
        return method.invoke(jDeveloper, params);
    }
    if (method.getName().equals(&quot;debug&quot;)) {
        System.out.println(&quot;我没有bug&quot;);

    }
    return null;
});
developer.code();
developer.debug();

&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;cglib动态代理&quot;&gt;CGLIB动态代理&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;cglib动态代理优点在于他不需要我们提前准备接口。他代理的实际的对象。这对于我们开发来说就很方便了。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;
public class HelloService {
    public HelloService() {
        System.out.println(&quot;HelloService构造&quot;);
    }

    final public String sayHello(String name) {
        System.out.println(&quot;HelloService:sayOthers&amp;gt;&amp;gt;&quot;+name);
        return null;
    }

    public void sayHello() {
        System.out.println(&quot;HelloService:sayHello&quot;);
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;下面我们只需要实现cglib提供的MethodInterceptor接口，在初始化设置cglib的时候加载这个实例化对象就可以了&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;
public class MyMethodInterceptor implements MethodInterceptor {

    @Override
    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
        System.out.println(&quot;======插入前置通知======&quot;);
        Object object = methodProxy.invokeSuper(o, objects);
        System.out.println(&quot;======插入后者通知======&quot;);
        return object;
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;下面我们就来初始化设置cglib&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;
public static void main(String[] args) {
    //代理类class文件存入本地磁盘方便我们反编译查看源代码
    System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, &quot;/root/code&quot;);
    //通过CGLIB动态代理获取代理对象过程
    Enhancer enhancer = new Enhancer();
    //设置enhancer对象的父类
    enhancer.setSuperclass(HelloService.class);
    // 设置enhancer的回调对象
    enhancer.setCallback(new MyMethodInterceptor());
    //创建代理对象
    HelloService helloService = (HelloService) enhancer.create();
    //通过代理对象调用目标方法
    helloService.sayHello();
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;仔细看看cglib和spring的aop特别像。针对切点进行切面拦截控制。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;通过对比两种动态代理我们很容易发现，mybatis就是通过JDK代理实现Mapper调用的。我们Mapper接口实现通过代理到xml中对应的sql执行逻辑&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;反射&quot;&gt;反射&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;相信有一定经验的Java工程师都对反射或多或少有一定了解。其实从思想上看不惯哪种语言都是有反射的机制的。&lt;/li&gt;
&lt;li&gt;通过反射我们就摆脱了对象的限制我们调用方法不再需要通过对象调用了。可以通过Class对象获取方法对象。从而通过invoke方法进行方法的调用了。&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;&lt;li&gt;Configuration对象存储了所有Mybatis的配置。主要初始化一下参数
&lt;ul&gt;&lt;li&gt;properties&lt;/li&gt;
&lt;li&gt;settings&lt;/li&gt;
&lt;li&gt;typeAliases&lt;/li&gt;
&lt;li&gt;typeHandler&lt;/li&gt;
&lt;li&gt;ObjectFactory&lt;/li&gt;
&lt;li&gt;plugins&lt;/li&gt;
&lt;li&gt;environment&lt;/li&gt;
&lt;li&gt;DatabaseIdProvider&lt;/li&gt;
&lt;li&gt;Mapper映射器&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://oytmxyuek.bkt.clouddn.com/20200603001.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul readability=&quot;10.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;BoundSql提供三个主要的属性 parameterMappings 、parameterObject、sql&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;parameterObject参数本身。我们可以传递java基本类型、POJO、Map或者@Param标注的参数。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;当我们传递的是java基本类型mybatis会转换成对应的包装对象 int -&amp;gt; Integer&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;如果我们传递POJO、Map。就是对象本身&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;我们传递多个参数且没有@Param指定变量名则parameterObject 类似&lt;br/&gt;{&quot;1&quot;:p1,&quot;2&quot;:p2,&quot;param1&quot;:p1,&quot;param2&quot;:p2}&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;我们传递多个参数且@Param指定变量名 则parameterObject类似&lt;br/&gt;{&quot;key1&quot;:p1,&quot;key2&quot;:p2,&quot;param1&quot;:p1,&quot;param2&quot;:p2}&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;parameterMapping 是记录属性、名称、表达式、javaType,jdbcType、typeHandler这些信息&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;sql 属性就是我们映射器中的一条sql. 正常我们在常见中对sql进行校验。正常不需要修改sql。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;&lt;li&gt;首先我们看看我们平时开发的Mapper接口是如何动态代理的。这就需要提到&lt;code&gt;MapperProxyFactory&lt;/code&gt;这个类了。该类中的&lt;code&gt;newInstance&lt;/code&gt;方法&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;
protected T newInstance(MapperProxy&amp;lt;T&amp;gt; mapperProxy) {
    return (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), new Class[] { mapperInterface }, mapperProxy);
  }

&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;通过上满代码及上述对jdk动态代理的表述。我们可以知道mapperProxy是我们代理的重点。&lt;/li&gt;
&lt;li&gt;MapperProxy是InvocationHandler的实现类。他重写的invoke方法就是代理对象执行的方法入口。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;
@Override
public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
try {
    if (Object.class.equals(method.getDeclaringClass())) {
    return method.invoke(this, args);
    } else if (isDefaultMethod(method)) {
    return invokeDefaultMethod(proxy, method, args);
    }
} catch (Throwable t) {
    throw ExceptionUtil.unwrapThrowable(t);
}
final MapperMethod mapperMethod = cachedMapperMethod(method);
return mapperMethod.execute(sqlSession, args);
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;
private boolean isDefaultMethod(Method method) {
return (method.getModifiers()
    &amp;amp; (Modifier.ABSTRACT | Modifier.PUBLIC | Modifier.STATIC)) == Modifier.PUBLIC
    &amp;amp;&amp;amp; method.getDeclaringClass().isInterface();
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;通过源码发现。invoke内部首先判断对象是否是类 。 通过打断点发现最终会走到cacheMapperMethod这个方法去创建MapperMethod对象。&lt;/li&gt;
&lt;li&gt;继续查看MapperMethod中execute方法我们可以了解到内部实现其实是一个命令行模式开发。通过判断命令从而执行不同的语句。判断到具体执行语句然后将参数传递给sqlsession进行sql调用并获取结果。到了sqlsession就和正常jdbc开发sql进行关联了。sqlsession中&lt;code&gt;Executor&lt;/code&gt;、&lt;code&gt;StatementHandler&lt;/code&gt;、&lt;code&gt;ParameterHandler&lt;/code&gt;、&lt;code&gt;Resulthandler&lt;/code&gt;四大天王&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;executor&quot;&gt;Executor&lt;/h2&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;顾名思义他就是一个执行器。将java提供的sql提交到数据库。Mybatis提供了三种执行器。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;Configuration.class&lt;/code&gt;中&lt;code&gt;newExecutor&lt;/code&gt;源码&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://oytmxyuek.bkt.clouddn.com/20200603002.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;根据uml我们不难看出mybatis中提供了三类执行器分别SimpleExecutor、ReuseExecutor、BatchExecutor&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;
public SqlSession openSession() {
  return openSessionFromDataSource(configuration.getDefaultExecutorType(), null, false);
}

private SqlSession openSessionFromDataSource(ExecutorType execType, TransactionIsolationLevel level, boolean autoCommit) {
    Transaction tx = null;
    try {
      // 得到configuration 中的environment
      final Environment environment = configuration.getEnvironment();
      // 得到configuration 中的事务工厂
      final TransactionFactory transactionFactory = getTransactionFactoryFromEnvironment(environment);
      tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);
      // 获取执行器
      final Executor executor = configuration.newExecutor(tx, execType);
      // 返回默认的SqlSession
      return new DefaultSqlSession(configuration, executor, autoCommit);
    } catch (Exception e) {
      closeTransaction(tx); // may have fetched a connection so lets call close()
      throw ExceptionFactory.wrapException(&quot;Error opening session.  Cause: &quot; + e, e);
    } finally {
      ErrorContext.instance().reset();
    }
  }

&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;通过上述源码我们知道在sqlsession获取一个数据库session对象时我们或根据我们的settings配置加载一个Executor对象。在settings中配置也很简单&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;
&amp;lt;settings&amp;gt;
&amp;lt;!--取值范围 SIMPLE, REUSE, BATCH --&amp;gt;
        &amp;lt;setting name=&quot;defaultExecutorType&quot; value=&quot;SIMPLE&quot;/&amp;gt;
&amp;lt;/settings&amp;gt;

&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;我们也可以通过java代码设置&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;
factory.openSession(ExecutorType.BATCH);

&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;statementhandler&quot;&gt;StatementHandler&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;顾名思义，StatementHandler就是专门处理数据库回话的。这个对象的创建还是在Configuration中管理的。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;
public StatementHandler newStatementHandler(Executor executor, MappedStatement mappedStatement, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) {
    StatementHandler statementHandler = new RoutingStatementHandler(executor, mappedStatement, parameterObject, rowBounds, resultHandler, boundSql);
    statementHandler = (StatementHandler) interceptorChain.pluginAll(statementHandler);
    return statementHandler;
  }

&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;很明显Mybatis中StatementHandler使用的是RoutingStatementHandler这个class&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://oytmxyuek.bkt.clouddn.com/20200603003.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;关于StatementHandler和RoutingStatementHandler之间的关系我们通过源码可以看出这里和Executor一样都是适配器模式。采用这种模式的好处是方便我们对这些对象进行代理。这里读者可以猜测一下是使用了哪种动态代理。给点提示 这里使用了接口哦&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://oytmxyuek.bkt.clouddn.com/20200603004.jpg&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;http://oytmxyuek.bkt.clouddn.com/20200603005.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;在查看BaseStatementHandler结构我们会发现和Executor一模一样。同样的Mybatis在构造RoutingStatementHandler的时候会根据setting中配置来加载不同的具体子类。这些子类都是继承了BaseStatementHandler.&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;前一节我们跟踪了Executor。 我们知道Mybatis默认的是SimpleExecutor。 StatementHandler我们跟踪了Mybaits默认的是PrePareStatementHandler。在SimpleExecutor执行查询的源码如下&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://oytmxyuek.bkt.clouddn.com/20200603006.jpg&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;http://oytmxyuek.bkt.clouddn.com/20200603007.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;我们发现在executor查询钱会先让statementHandler构建一个Statement对象。最终就是StatementHandler中prepare方法。这个方法在抽象类BaseStatmentHandler中已经封装好了。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://oytmxyuek.bkt.clouddn.com/20200603008.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;这个方法的逻辑是初始化statement和设置连接超时等一些辅助作用&lt;/li&gt;
&lt;li&gt;然后就是设置一些参数等设置。最后就走到了执行器executor的doquery&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://oytmxyuek.bkt.clouddn.com/20200603009.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;PrepareStatement在我们jdbc开发时是常见的一个类 。 这个方法执行execute前我们需要设置sql语句，设置参数进行编译。这一系列步骤就是刚才我们说的流程也是PrepareStatementHandler.prepareStatement帮我们做的事情。那么剩下的我们也很容易想到就是我们对数据结果的封装。正如代码所示下马就是resultSetHandler帮我们做事情了。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;结果处理器resultsethandler&quot;&gt;结果处理器(ResultSetHandler)&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;
@Override
  public List&amp;lt;Object&amp;gt; handleResultSets(Statement stmt) throws SQLException {
    ErrorContext.instance().activity(&quot;handling results&quot;).object(mappedStatement.getId());

    final List&amp;lt;Object&amp;gt; multipleResults = new ArrayList&amp;lt;&amp;gt;();

    int resultSetCount = 0;
    ResultSetWrapper rsw = getFirstResultSet(stmt);

    List&amp;lt;ResultMap&amp;gt; resultMaps = mappedStatement.getResultMaps();
    int resultMapCount = resultMaps.size();
    validateResultMapsCount(rsw, resultMapCount);
    while (rsw != null &amp;amp;&amp;amp; resultMapCount &amp;gt; resultSetCount) {
      ResultMap resultMap = resultMaps.get(resultSetCount);
      handleResultSet(rsw, resultMap, multipleResults, null);
      rsw = getNextResultSet(stmt);
      cleanUpAfterHandlingResultSet();
      resultSetCount++;
    }

    String[] resultSets = mappedStatement.getResultSets();
    if (resultSets != null) {
      while (rsw != null &amp;amp;&amp;amp; resultSetCount &amp;lt; resultSets.length) {
        ResultMapping parentMapping = nextResultMaps.get(resultSets[resultSetCount]);
        if (parentMapping != null) {
          String nestedResultMapId = parentMapping.getNestedResultMapId();
          ResultMap resultMap = configuration.getResultMap(nestedResultMapId);
          handleResultSet(rsw, resultMap, null, parentMapping);
        }
        rsw = getNextResultSet(stmt);
        cleanUpAfterHandlingResultSet();
        resultSetCount++;
      }
    }

    return collapseSingleResultList(multipleResults);
  }

&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;这个方法我们可以导出来是结果xml中标签配置对结果的一个封装。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;总结-2&quot;&gt;总结&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;SqlSession在一个查询开启的时候会先通过CacheExecutor查询缓存。击穿缓存后会通过BaseExector子类的SimpleExecutor创建StatementHandler。PrepareStatementHandler会基于PrepareStament执行数据库操作。并针对返回结果通过ResultSetHandler返回结果数据&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://oytmxyuek.bkt.clouddn.com/20200603010.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://oytmxyuek.bkt.clouddn.com/20200603jdbc.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 03 Jun 2020 00:42:00 +0000</pubDate>
<dc:creator>烟花散尽13141</dc:creator>
<og:description>mybatis运行分为两部分，第一部分读取配置文件缓存到Configuration对象中。用以创建SqlSessionFactory，第二部分是SqlSession的执行过程。 Mybatis基本认识</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhangxinhua/p/13035241.html</dc:identifier>
</item>
<item>
<title>和付费网盘说再见，跟着本文自己起个网盘（Java 开源项目） - 削微寒</title>
<link>http://www.cnblogs.com/xueweihan/p/13033501.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xueweihan/p/13033501.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;本文适合有 Java 基础知识的人群，跟着本文可学习和运行 &lt;code&gt;Java&lt;/code&gt; 网盘项目。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202006/759200-20200602201350245-709468592.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;本文作者：HelloGitHub-&lt;strong&gt;秦人&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;HelloGitHub 推出的&lt;a href=&quot;https://github.com/HelloGitHub-Team/Article&quot;&gt;《讲解开源项目》&lt;/a&gt;系列。&lt;/p&gt;
&lt;p&gt;今天给大家带来一款开源 Java 版网盘项目—— &lt;a href=&quot;https://github.com/KOHGYLW/kiftd-source&quot;&gt;kiftd-source&lt;/a&gt;，本文将用 3 分钟带大家搭建一个个人网盘，技术便利生活，你值得拥有～&lt;/p&gt;
&lt;blockquote readability=&quot;1.3888888888889&quot;&gt;
&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/KOHGYLW/kiftd-source&quot;&gt;https://github.com/KOHGYLW/kiftd-source&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一、项目介绍&quot;&gt;一、项目介绍&lt;/h2&gt;
&lt;p&gt;kiftd 是一款开源、使用简单、功能完整的 Java 网盘/云盘系统。支持在线视频播放、文档在线预览、音乐播放、图片查看等功能的文件云存储平台。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;技术栈&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;JDK 版本：1.8.0_131&lt;/li&gt;
&lt;li&gt;项目管理框架：Maven（m2e 1.8.0 for Eclipse）&lt;/li&gt;
&lt;li&gt;Archetype：mavem-archetype-quickstart 1.1&lt;/li&gt;
&lt;li&gt;Spring Boot：SpringBoot 基于 Spring 开发，旨在提高微服务的开发效率。&lt;/li&gt;
&lt;li&gt;MyBatis：一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。&lt;/li&gt;
&lt;li&gt;H2 DB：一款开源的嵌入式数据库引擎，采用 Java 语言编写，不受平台的限制。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;二、网盘搭建&quot;&gt;二、网盘搭建&lt;/h2&gt;
&lt;h3 id=&quot;21-windows-环境运行&quot;&gt;2.1 Windows 环境运行&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;2.1.1 下载安装包&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;直接从官网下载最新的安装包，安装地址：&lt;a href=&quot;https://kohgylw.gitee.io/&quot;&gt;https://kohgylw.gitee.io/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;项目比较温馨，支持三种下载方式：Github、阿里云、Gitee 下载。如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202006/759200-20200602201413972-318753039.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.1.2 检查配置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里主要检查一下本地 &lt;code&gt;JDK&lt;/code&gt; 是否已安装，在命令行窗口执行 &lt;code&gt;java -version&lt;/code&gt; 查看 &lt;code&gt;Java&lt;/code&gt; 版本。如下所示表示已安装，就可以进行下一步操作。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;java version &quot;1.8.0_181&quot;
Java(TM) SE Runtime Environment (build 1.8.0_181-b13)
Java HotSpot(TM) 64-Bit Server VM (build 25.181-b13, mixed mode)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2.1.3 运行 jar&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;双击 &lt;code&gt;kiftd-1.0.29-RELEASE.jar&lt;/code&gt;，或者在命令行执行 &lt;code&gt;java -jar kiftd-1.0.29-RELEASE.jar&lt;/code&gt; 命令都运行可以&lt;code&gt;jar&lt;/code&gt; 文件，会弹出安装的界面，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202006/759200-20200602201425671-1967168068.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个界面的这几个按钮说明一下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;开启（Start）：运行网盘服务，初次启动的端口默认是 &lt;code&gt;8080&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;文件（Files）：这个按钮菜单中主要有网盘文件导入，导出，删除，刷新功能。&lt;/li&gt;
&lt;li&gt;设置（Setting）：设置功能主要可以设置网盘的服务端口，网盘的物理存储路径等信息。&lt;/li&gt;
&lt;li&gt;退出（Exit）：关闭网盘系统。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;点击 &lt;code&gt;开启(Start)&lt;/code&gt; 按钮即可运行网盘，这里我设置的端口是 &lt;code&gt;8090&lt;/code&gt;，在浏览器访问: &lt;code&gt;localhost:8090&lt;/code&gt;，运行效果如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202006/759200-20200602201437322-1587352271.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;项目是运行了，发现一个问题无法上传文件？因为我们忘了登录这个操作。点击系统 &lt;code&gt;登录按钮&lt;/code&gt;，填入账号和密码即可登录。那么登录密码在哪里呢？这里我直接告诉大家，用户信息在 &lt;code&gt;conf/account.properties&lt;/code&gt;，文件内容如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;#&amp;lt;This is the default kiftd account setting file. &amp;gt;
#Sun May 10 21:56:28 CST 2020
admin.pwd=000000  #用户名.密码=000000
authOverall=l
admin.auth=cudrm
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;用户名：admin&lt;/li&gt;
&lt;li&gt;密码：000000&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这样登录之后就可以使用网盘的所有功能了。&lt;/p&gt;
&lt;h3 id=&quot;22-linux-环境运行&quot;&gt;2.2 Linux 环境运行&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;2.2.1 安装 Screen 工具&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Screen 工具能够虚拟出一个终端并执行相应的操作。因为本篇所讲的网盘需要一个终端。执行如下命令安装 &lt;code&gt;Screen&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;yum install screen
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2.2.2 &lt;code&gt;Screen&lt;/code&gt; 常用命令&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;screen -S myScreen #创建虚拟终端
java -jar kiftd-1.0.29-RELEASE.jar -console #在虚拟终端中以命令模式启动 kiftd
screen -r myScreen #返回之前的虚拟终端并继续操作 kiftd。
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2.2.3 命令行操作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;Linux&lt;/code&gt; 环境上使用 &lt;code&gt;console&lt;/code&gt; 模式启动的效果是这样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202006/759200-20200602201645839-1685798966.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;命令行输入 &lt;code&gt;-start&lt;/code&gt; 即可运行项目。例如输入 &lt;code&gt;-files&lt;/code&gt; 控制台显示是这样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202006/759200-20200602201656523-1645061946.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其实和 &lt;code&gt;Windows&lt;/code&gt; 上一样，包括文件导入，导出，删除功能，多了几个命令是查看文件，切换目录等功能。&lt;/p&gt;
&lt;h2 id=&quot;三、开发环境运行&quot;&gt;三、开发环境运行&lt;/h2&gt;
&lt;h3 id=&quot;31-下载项目&quot;&gt;3.1 下载项目&lt;/h3&gt;
&lt;p&gt;两种方式下载项目，使用 &lt;code&gt;GitBash&lt;/code&gt; 下载项目：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;git clone https://github.com/KOHGYLW/kiftd-source.git
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;另外一种方式直接下载 &lt;code&gt;zip&lt;/code&gt; 压缩包，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202006/759200-20200602201708882-1392584937.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;32-运行&quot;&gt;3.2 运行&lt;/h3&gt;
&lt;p&gt;打开 &lt;code&gt;kohgylw.kiftd.mc.MC&lt;/code&gt; 类，进行测试运行。注意：本文使用 &lt;code&gt;Eclipse&lt;/code&gt; 工具打开。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202006/759200-20200602201730773-466609693.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;33-阅读代码&quot;&gt;3.3 阅读代码&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;3.3.1 前台请求&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;就以创建目录这个功能为例。我们先看前端功能。点击“操作”-&amp;gt;“新建文件夹”，填写文件夹名称，点击保存如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202006/759200-20200602201807595-1294065143.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们知道前台 &lt;code&gt;新建文件夹&lt;/code&gt; 功能调用的后台接口是 &lt;code&gt;newFolder.ajax&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.3.2 后端接口&lt;/strong&gt;&lt;br/&gt;通过前台请求可知调用的后台接口为 &lt;code&gt;homeController/newFolder.ajax&lt;/code&gt;。打开代码实现，我们会看到下面这个方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public String newFolder(final HttpServletRequest request) {
                
        ...
        //参数校验的部分代码已省略
                Folder f = new Folder();
                f.setFolderId(UUID.randomUUID().toString());
                f.setFolderName(folderName);
                f.setFolderCreationDate(ServerTimeUtil.accurateToDay());
                if (account != null) {
                        f.setFolderCreator(account);
                } else {
                        f.setFolderCreator(&quot;匿名用户&quot;);
                }
                f.setFolderParent(parentId);
                int i = 0;
                while (true) {
                        try {
                // 数据库插入新建文件夹的数据
                                final int r = this.fm.insertNewFolder(f);
                                if (r &amp;gt; 0) {
                                        if (fu.isValidFolder(f)) {
                                                this.lu.writeCreateFolderEvent(request, f);
                                                return &quot;createFolderSuccess&quot;;
                                        } else {
                                                return &quot;cannotCreateFolder&quot;;
                                        }
                                }
                                break;
                        } catch (Exception e) {
                                f.setFolderId(UUID.randomUUID().toString());
                                i++;
                        }
                        if (i &amp;gt;= 10) {
                                break;
                        }
                }
                return &quot;cannotCreateFolder&quot;;
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;四、功能说明&quot;&gt;四、功能说明&lt;/h2&gt;
&lt;h3 id=&quot;41-上传&quot;&gt;4.1 上传&lt;/h3&gt;
&lt;ol readability=&quot;-1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;点击 &lt;code&gt;操作&lt;/code&gt;，可以上传文件和上传文件夹，如下图：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202006/759200-20200602201822804-353882534.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;将本地需要上传的文件，拖拽网盘页面也可以上传此文件。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;42-视频音频播放&quot;&gt;4.2 视频/音频播放&lt;/h3&gt;
&lt;ol readability=&quot;-1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;上传视频到网盘，网盘也支持在线视频播放，效果如下图：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202006/759200-20200602201832542-1393032258.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;上传音频，例如我最喜欢 &lt;code&gt;周杰伦&lt;/code&gt; 的歌曲，可以在线播放了。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202006/759200-20200602201844123-2010399529.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;43-快捷键使用&quot;&gt;4.3 快捷键使用&lt;/h3&gt;
&lt;p&gt;网盘还对一些常用功能添加了快捷键。功能和快捷键参照如下：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;功能&lt;/th&gt;
&lt;th&gt;快捷键&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;上传文件夹&lt;/td&gt;
&lt;td&gt;Shift +U&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;上传文件&lt;/td&gt;
&lt;td&gt;Shift +F&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;新建文件&lt;/td&gt;
&lt;td&gt;Shift +N&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;复制&lt;/td&gt;
&lt;td&gt;Shift +C&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;剪切&lt;/td&gt;
&lt;td&gt;Shift +X&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;删除&lt;/td&gt;
&lt;td&gt;Shift +D&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;44-配置文件修改&quot;&gt;4.4 配置文件修改&lt;/h3&gt;
&lt;p&gt;配置文件在项目 &lt;code&gt;conf&lt;/code&gt; 目录，包括两个配置文件：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;account.properties&lt;/code&gt;：配置账号信息，权限信息&lt;/li&gt;
&lt;li&gt;&lt;code&gt;server.properties&lt;/code&gt;：服务器的配置文件，可配置服务器端口，缓冲文件大小等&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;45-在线预览&quot;&gt;4.5 在线预览&lt;/h3&gt;
&lt;p&gt;网盘支持文档 &lt;code&gt;txt&lt;/code&gt;、&lt;code&gt;pdf&lt;/code&gt;、&lt;code&gt;docx&lt;/code&gt;、&lt;code&gt;ppt&lt;/code&gt; 在线预览功能，支持图片的在线预览。图片预览效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202006/759200-20200602201902030-1074477634.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;pdf&lt;/code&gt; 文件预览效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202006/759200-20200602201917394-1775678391.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;46-分享下载链接&quot;&gt;4.6 分享下载链接&lt;/h3&gt;
&lt;p&gt;网盘也考虑文件的分享，它可以生成下载链接，浏览器访问下载链接就可以直接下载文件。选择需要下载的文件，点击 &lt;code&gt;下载&lt;/code&gt; 按钮，选择 &lt;code&gt;下载链接+&lt;/code&gt;，既可以生成文件下载链接。如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202006/759200-20200602201928553-925064274.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;五、最后&quot;&gt;五、最后&lt;/h2&gt;
&lt;p&gt;教程至此已经结束，你自己的网盘跑起来了吗？网盘是不是还不错？而且搭建也特别简单。一些重要的东西就可以存放到自己的网盘啦！说到底，编程语言只是工具，我们只要很好的使用工具，再加上自己天马行空的思想，我想会创造出更多不可思议的项目。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Java&lt;/code&gt; 语言为什么经久不衰，因为它能做的事情太多了，而且生态也特别丰富。如果你也有兴趣那就加入 &lt;code&gt;Javaer&lt;/code&gt; 开发者的大家庭吧！开源分享让我们彼此认识，有了开源项目让我们看到编程语言的绚丽多彩。&lt;/p&gt;
&lt;p&gt;教程至此，你应该也能快速运行个人网盘了。编程是不是也特别有意思呢？先下载安装包给自己部署一套网盘系统吧。对源码感兴趣的朋友可以开始学习项目源码了～&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202006/759200-20200602202102433-190224743.jpg&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;strong&gt;关注公众号加入交流群&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 03 Jun 2020 00:40:00 +0000</pubDate>
<dc:creator>削微寒</dc:creator>
<og:description>本文适合有 Java 基础知识的人群，跟着本文可学习和运行 Java 网盘项目。 本文作者：HelloGitHub-秦人 HelloGitHub 推出的《讲解开源项目》系列。 今天给大家带来一款开源</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xueweihan/p/13033501.html</dc:identifier>
</item>
<item>
<title>Python编程思想（3）：数字及其相关运算 - 银河使者</title>
<link>http://www.cnblogs.com/nokiaguy/p/13035231.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nokiaguy/p/13035231.html</guid>
<description>&lt;p&gt;Python 提供了三种数值类型：int（整型），float（浮点型）和complex（复数）。 int：通常被称为整型或者整数，如200、299、10都属于整型； float：浮点数包含整数和小数部分，如3.1415926，2.71828都属于浮点数； complex：复数包含实数部分和虚数部分，形如 a+bj，其实部和虚部都是浮点类型；&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;118&quot;&gt;
&lt;p&gt;Python 提供了三种数值类型：int（整型），float（浮点型）和complex（复数）。&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;int：通常被称为整型或者整数，如200、299、10都属于整型；&lt;/li&gt;
&lt;li&gt;float：浮点数包含整数和小数部分，如3.1415926，2.71828都属于浮点数；&lt;/li&gt;
&lt;li&gt;complex：复数包含实数部分和虚数部分，形如 a+bj，其实部和虚部都是浮点类型；&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;p&gt;需要注意的是，Python3 已经废弃了 Python2 的 Long（长整型），在 Python3 中，int 的大小没有限制，可以作为 Long 使用。这也是为什么Python非常适合科学计算的原因，因为Python可以处理无限大的整数。在Python中进行数值运算，并不需要考虑溢出问题，因为Python的数值永远不会溢出。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. 数值类型之间的转换&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Python 的三种数值类型可以进行相互转换，转换方式为：数字类型+圆括号，如下实例：&lt;/p&gt;
&lt;div id=&quot;9860-1588428034946&quot; data-theme=&quot;default&quot; data-language=&quot;javascript&quot; readability=&quot;9.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
a = 456&lt;span&gt;
b &lt;/span&gt;= 2.71828
&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;int(b)=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,int(b))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;float(a)=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,float(a))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;complex(a)=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,complex(a))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;complex(a,b)=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,complex(a,b))
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;执行结果如下图所示：&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/src/AB3E2D6A76BC424EBC261C9BCFAEC2DC&quot; alt=&quot;&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;
&lt;div&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/32818/202006/32818-20200603082822794-1831962527.png&quot; alt=&quot;&quot; width=&quot;691&quot; height=&quot;239&quot;/&gt; &lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2. 常用的数学函数&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Python 提供了丰富的数学函数以降低编程实现的难度，本问将介绍一些常用的函数。&lt;/p&gt;
&lt;div id=&quot;2193-1588428122003&quot; data-theme=&quot;default&quot; data-language=&quot;javascript&quot; readability=&quot;14.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; math
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;求绝对值:abs(x)&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;abs(-200)=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,abs(-200&lt;span&gt;))

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;向上取整:ceil(x)&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ceil(3.1415)=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,math.ceil(3.1415&lt;span&gt;))

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;向下取整:floor(x)&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;floor(3.678)=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,math.floor(3.678&lt;span&gt;))

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;四舍五入:round(x)&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;round(3.678)=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,round(3.678&lt;span&gt;))

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;乘方运算:pow(x,y),x的y次方&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pow(3,4)=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,pow(3,4&lt;span&gt;))

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;求平方根:sqrt(x)&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sqrt(144)=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,math.sqrt(144))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行结果如下图所示：&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/32818/202006/32818-20200603082914741-27651126.png&quot; alt=&quot;&quot; width=&quot;932&quot; height=&quot;627&quot;/&gt;&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/src/E52C7A0754A74E3FABB2F6032CA16ED4&quot; alt=&quot;&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;3. 运算符&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;计算机的最基本用途之一就是执行数学运算，作为一门计算机编程语言，Python 也提供了一套丰富的运算符来满足各种运算需求。&lt;/p&gt;
&lt;p&gt;Python 运算符主要可以分为6种：算术运算符、比较运算符、赋值运算符、逻辑运算符、位运算符和成员运算符。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（1）算术运算符&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于算术运算，大家并不陌生，常用的加减乘除就是算术运算。不过，在编程语言里，算术运算符特殊一些，Python 中的算术运算有7种：加（+）、减（-）、乘（ * ）、除（/）、取模（%）、幂运算（ ** ）和取整预算（//）。以下通过实例演示算术运算符的用法。&lt;/p&gt;
&lt;div id=&quot;6539-1588429609840&quot; data-theme=&quot;default&quot; data-language=&quot;javascript&quot; readability=&quot;10.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;初始化测试数据&lt;/span&gt;
x = 30&lt;span&gt;
y &lt;/span&gt;= 24&lt;span&gt;
z &lt;/span&gt;= 12
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;分别进行7种算术运算&lt;/span&gt;
z = x +&lt;span&gt; y
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;x + y =&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, z)
z &lt;/span&gt;= x -&lt;span&gt; y
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;x - y =&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, z)
z &lt;/span&gt;= x *&lt;span&gt; y
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;x * y =&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, z)
z &lt;/span&gt;= x /&lt;span&gt; y
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;x / y =&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, z)
z &lt;/span&gt;= x %&lt;span&gt; y
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;x % y =&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, z)
z &lt;/span&gt;= x **&lt;span&gt; y
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;x ** y =&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, z)
z &lt;/span&gt;= x //&lt;span&gt; y
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;x // y =&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, z)
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;执行结果如下图所示：&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/32818/202006/32818-20200603083011058-329278017.png&quot; alt=&quot;&quot; width=&quot;658&quot; height=&quot;270&quot;/&gt;
&lt;p&gt;  &lt;strong&gt;（2）比较运算符&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;比较无处不在，大于、小于、等于、不等于……和 C/C++、Java 等编程语言一样，Python 也提供了6种比较运算符：&amp;gt;（大于），&amp;lt;（小于），==（等于），！=（不等于)，&amp;gt;=（大于等于），&amp;lt;=（小于等于）。比较运算的结果是一个布尔值，True 或者 False，看下面的案例代码：&lt;/p&gt;
&lt;div id=&quot;6065-1588429801650&quot; data-theme=&quot;default&quot; data-language=&quot;javascript&quot; readability=&quot;10&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 初始化变量&lt;/span&gt;
x = 12&lt;span&gt;
y &lt;/span&gt;= 7
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;分别进行6种比较运算&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;x == y:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, x ==&lt;span&gt; y)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;x != y:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, x !=&lt;span&gt; y)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;x &amp;gt; y:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, x &amp;gt;&lt;span&gt; y)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;x &amp;lt; y:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, x &amp;lt;&lt;span&gt; y)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;x &amp;gt;= y:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, x &amp;gt;=&lt;span&gt; y)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;x &amp;lt;= y:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, x &amp;lt;= y)
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;执行结果如下图所示：&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/32818/202006/32818-20200603083107758-1177712224.png&quot; alt=&quot;&quot; width=&quot;811&quot; height=&quot;669&quot;/&gt;&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/src/05D63B91821049A7A7D74AE0D9F70338&quot; alt=&quot;&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;（3）赋值运算符&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;其实在前面的代码中已经用到赋值运算，如 x = 12，就是一个最简单的赋值运算，“=”就是最简单的赋值运算符。将简单的赋值运算与算术运算结合，Python 形成了更丰富的赋值运算符：+=、-=、=、/=、%=、*=、//=。看下面的案例代码：&lt;/p&gt;
&lt;div id=&quot;7253-1588430012339&quot; data-theme=&quot;default&quot; data-language=&quot;javascript&quot; readability=&quot;14&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;初始化变量&lt;/span&gt;
x = 12&lt;span&gt;
y &lt;/span&gt;= 21
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;分别进行7种赋值运算&lt;/span&gt;
y =&lt;span&gt; x
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;y = x, y =&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, y)
y &lt;/span&gt;+=&lt;span&gt; x
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;y += x, y =&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, y)
y &lt;/span&gt;-=&lt;span&gt; x
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;y -= x, y =&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, y)
y &lt;/span&gt;*=&lt;span&gt; x
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;y *= x, y =&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, y)
y &lt;/span&gt;/=&lt;span&gt; x
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;y /= x, y =&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, y)
y &lt;/span&gt;**=&lt;span&gt; x
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;y **= x, y =&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, y)
y &lt;/span&gt;//=&lt;span&gt; x
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;y //= x, y =&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, y)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/32818/202006/32818-20200603083153969-1367979757.png&quot; alt=&quot;&quot; width=&quot;718&quot; height=&quot;399&quot;/&gt;&lt;/p&gt;


&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;（4）逻辑运算符&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所谓逻辑运算，就是：与、或、非。Python 中的3种逻辑运算符分别为：and（与），or（或），not（非），逻辑运算的结果是布尔值：True 或者 False。&lt;/p&gt;
&lt;div&gt;
&lt;ol&gt;&lt;li&gt;A and B：当A和B有一个为False时，结果就为False，只有A和B都为True时，结果才为True；&lt;/li&gt;
&lt;li&gt;A or B：只有当A和B都是False时，结果才为False，只要有一个为True，结果就为True；&lt;/li&gt;
&lt;li&gt;not A：当 A 为 True 时，返回 False，否则返回 True。&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;
&lt;p&gt;看下面的案例：&lt;/p&gt;
&lt;div id=&quot;2195-1588430248646&quot; data-theme=&quot;default&quot; data-language=&quot;javascript&quot; readability=&quot;12.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;初始化变量&lt;/span&gt;
a = 2&lt;span&gt;
b &lt;/span&gt;= 3&lt;span&gt;
c &lt;/span&gt;= 5
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;分别执行3种逻辑运算&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a&amp;gt;b and a&amp;lt;c :&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, a&amp;gt;b &lt;span&gt;and&lt;/span&gt; a&amp;lt;&lt;span&gt;c)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a&amp;lt;b and c :&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, a&amp;lt;b &lt;span&gt;and&lt;/span&gt;&lt;span&gt; c)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a&amp;gt;b or c :&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, a&amp;gt;b &lt;span&gt;or&lt;/span&gt; a&amp;lt;&lt;span&gt;c)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a&amp;lt;b or c :&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, a&amp;lt;b &lt;span&gt;or&lt;/span&gt;&lt;span&gt; c)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a or a&amp;lt;c :&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, a &lt;span&gt;or&lt;/span&gt; a&amp;lt;&lt;span&gt;c)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;not a :&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;not&lt;/span&gt;&lt;span&gt; a)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;not a&amp;lt;b :&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;not&lt;/span&gt; a&amp;lt;b)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行结果如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/32818/202006/32818-20200603083249219-336864506.png&quot; alt=&quot;&quot; width=&quot;987&quot; height=&quot;668&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/src/02B3543310274919AA3B9B378CA5E936&quot; alt=&quot;&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;（5）位运算符&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;程序中的所有数值在计算机内存中都是以二进制的形式储存的。位运算就是直接对整数在内存中的二进制位进行操作。Python 中有6种位运算符：&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;&amp;amp;：按位与，参与运算的两个值，如果两个相应位都为1，则该位的结果为1，否则为0；&lt;/li&gt;
&lt;li&gt;|：按位或，只要对应的2个二进位有一个为1时，结果位就为1；&lt;/li&gt;
&lt;li&gt;^：按位异或，当两对应的二进位相异时，结果为1；&lt;/li&gt;
&lt;li&gt;~：按位取反，对数据的每个二进制位取反，即把1变为0，把0变为1；&lt;/li&gt;
&lt;li&gt;&amp;gt;&amp;gt;：按位右移，将&amp;gt;&amp;gt;左侧的数按位向右移动&amp;gt;&amp;gt;右边的数指定的位；&lt;/li&gt;
&lt;li&gt;&amp;lt;&amp;lt;：按位左移，将&amp;lt;&amp;lt;左侧的数按位向左移动&amp;lt;&amp;lt;右边的数指定的位；&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;p&gt;看下面的案例代码：&lt;/p&gt;
&lt;div readability=&quot;11.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
a = 21&lt;span&gt;
b &lt;/span&gt;= 6
&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a &amp;amp; b = &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,a &amp;amp;&lt;span&gt; b)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a | b = &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,a |&lt;span&gt; b)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a ^ b = &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,a ^&lt;span&gt; b)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;~a = &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,~&lt;span&gt;a)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a &amp;lt;&amp;lt; 2 = &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,a &amp;lt;&amp;lt; 2&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a &amp;gt;&amp;gt; 2 = &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,a &amp;gt;&amp;gt; 2)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行结果如下图所示：&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/src/55C1988E591340CEB16E99700B50566E&quot; alt=&quot;&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;7&quot;&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/32818/202006/32818-20200603083343249-1257833066.png&quot; alt=&quot;&quot; width=&quot;596&quot; height=&quot;405&quot;/&gt;
&lt;p&gt; 这里讲a=21，b=6，转换为二进制如下：&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
a = 0001 0101&lt;span&gt;
b &lt;/span&gt;= 0000 0110&lt;span&gt;

a&lt;/span&gt;&amp;amp;b = 0000 0100&lt;span&gt;
a&lt;/span&gt;|b = 0001 0111&lt;span&gt;
a&lt;/span&gt;^b = 0001 0011
~a = 1110 1010&lt;span&gt;
a&lt;/span&gt;&amp;lt;&amp;lt;2 = 01010100&lt;span&gt;
a&lt;/span&gt;&amp;gt;&amp;gt;2 = 0000 0101
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;（6）成员运算符&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;除了前面介绍的5种运算符，Python 还支持成员运算符。介绍成员运算符之前，我们需要提前了解一个概念：数据结构，如字符串、列表、元组、字典。在接下来的文章中我们将详细介绍这些基础的数据结构。字符串、列表、字典，它们就像一个集合，其中包含若干元素，这些元素就是集合的成员；对于一个给定的元素，它有可能在一个给定的集合中，也可能不在，Python 中采用成员运算符来判断元素是否属于成员，成员运算的结果为布尔值，True 或者 False。&lt;/p&gt;
&lt;p&gt;看下面的代码：&lt;/p&gt;
&lt;div readability=&quot;10.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;初始化字符串和列表&lt;/span&gt;
temp1 = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;abcdefg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
temp2 &lt;/span&gt;= [4,2,3,5,8,9&lt;span&gt;]
a &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cdf&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
b &lt;/span&gt;= 5&lt;span&gt;
c &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cde&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a in temp1?&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, a &lt;span&gt;in&lt;/span&gt;&lt;span&gt; temp1)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;b in temp2?&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, b &lt;span&gt;in&lt;/span&gt;&lt;span&gt; temp2)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;c in temp1?&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, c &lt;span&gt;in&lt;/span&gt; temp1)
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;执行结果如下图所示：&lt;/p&gt;

&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/src/38E5A5D21BDF46AB982011AFF1187CFC&quot; alt=&quot;&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;
&lt;div&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/32818/202006/32818-20200603083451261-1022181216.png&quot; alt=&quot;&quot; width=&quot;456&quot; height=&quot;203&quot;/&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/32818/202006/32818-20200603083948298-1321204404.png&quot; alt=&quot;&quot; width=&quot;578&quot; height=&quot;321&quot;/&gt;&lt;/p&gt;


&lt;/div&gt;


&lt;/div&gt;</description>
<pubDate>Wed, 03 Jun 2020 00:40:00 +0000</pubDate>
<dc:creator>银河使者</dc:creator>
<og:description>Python 提供了三种数值类型：int（整型），float（浮点型）和complex（复数）。 int：通常被称为整型或者整数，如200、299、10都属于整型； float：浮点数包含整数和小数部</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/nokiaguy/p/13035231.html</dc:identifier>
</item>
<item>
<title>面向对象编程中的封装、抽象、继承、多态特性以及应用 - IT文艺男</title>
<link>http://www.cnblogs.com/appsucc/p/13034645.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/appsucc/p/13034645.html</guid>
<description>&lt;p&gt;理解面向对象编程及面向对象编程语言的关键就是理解其四大特性：封装、抽象、继承、多态。不过，对于这四大特性，光知道它们的定义是不够的，我们还要知道每个特性存在的意义和目的，以及它们能解决哪些编程问题&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;249&quot;&gt;
&lt;p&gt;理解面向对象编程及面向对象编程语言的关键就是理解其四大特性：封装、抽象、继承、多态。不过，对于这四大特性，光知道它们的定义是不够的，我们还要知道每个特性存在的意义和目的，以及它们能解决哪些编程问题。&lt;/p&gt;
&lt;h2 id=&quot;封装（encapsulation）&quot;&gt;封装（Encapsulation）&lt;/h2&gt;
&lt;p&gt;首先，我们来看封装特性。封装也叫作信息隐藏或者数据访问保护。类通过暴露有限的访问接口，授权外部仅能通过类提供的方式（或者叫函数）来访问内部信息或者数据。这句话怎么理解呢？我们通过一个简单的例子来解释一下。下面这段代码是金融系统中一个简化版的虚拟钱包的代码实现。在金融系统中，我们会给每个用户创建一个虚拟钱包，用来记录用户在我们的系统中的虚拟货币量。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Wallet {
  private String id;
  private long createTime;
  private BigDecimal balance;
  private long balanceLastModifiedTime;
  // ...省略其他属性...

  public Wallet() {
     this.id = IdGenerator.getInstance().generate();
     this.createTime = System.currentTimeMillis();
     this.balance = BigDecimal.ZERO;
     this.balanceLastModifiedTime = System.currentTimeMillis();
  }

  public String getId() { return this.id; }
  public long getCreateTime() { return this.createTime; }
  public BigDecimal getBalance() { return this.balance; }
  public long getBalanceLastModifiedTime() { return this.balanceLastModifiedTime;  }

  public void increaseBalance(BigDecimal increasedAmount) {
    if (increasedAmount.compareTo(BigDecimal.ZERO) &amp;lt; 0) {
      throw new InvalidAmountException(&quot;...&quot;);
    }
    this.balance.add(increasedAmount);
    this.balanceLastModifiedTime = System.currentTimeMillis();
  }

  public void decreaseBalance(BigDecimal decreasedAmount) {
    if (decreasedAmount.compareTo(BigDecimal.ZERO) &amp;lt; 0) {
      throw new InvalidAmountException(&quot;...&quot;);
    }
    if (decreasedAmount.compareTo(this.balance) &amp;gt; 0) {
      throw new InsufficientAmountException(&quot;...&quot;);
    }
    this.balance.subtract(decreasedAmount);
    this.balanceLastModifiedTime = System.currentTimeMillis();
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从代码中，我们可以发现，Wallet 类主要有四个属性（也可以叫作成员变量），也就是我们前面定义中提到的信息或者数据。其中，id 表示钱包的唯一编号，createTime 表示钱包创建的时间，balance 表示钱包中的余额，balanceLastModifiedTime 表示上次钱包余额变更的时间。&lt;/p&gt;
&lt;p&gt;我们参照封装特性，对钱包的这四个属性的访问方式进行了限制。调用者只允许通过下面这六个方法来访问或者修改钱包里的数据。&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li&gt;
&lt;p&gt;String getId()&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;long getCreateTime()&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;BigDecimal getBalance()&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;long getBalanceLastModifiedTime()&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;void increaseBalance(BigDecimal increasedAmount)&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;void decreaseBalance(BigDecimal decreasedAmount)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;之所以这样设计，是因为从业务的角度来说，id、createTime 在创建钱包的时候就确定好了，之后不应该再被改动，所以，我们并没有在 Wallet 类中，暴露 id、createTime 这两个属性的任何修改方法，比如 set 方法。而且，这两个属性的初始化设置，对于 Wallet 类的调用者来说，也应该是透明的，所以，我们在 Wallet 类的构造函数内部将其初始化设置好，而不是通过构造函数的参数来外部赋值。&lt;/p&gt;
&lt;p&gt;对于钱包余额 balance 这个属性，从业务的角度来说，只能增或者减，不会被重新设置。所以，我们在 Wallet 类中，只暴露了 increaseBalance() 和 decreaseBalance() 方法，并没有暴露 set 方法。对于 balanceLastModifiedTime 这个属性，它完全是跟 balance 这个属性的修改操作绑定在一起的。只有在 balance 修改的时候，这个属性才会被修改。所以，我们把 balanceLastModifiedTime 这个属性的修改操作完全封装在了 increaseBalance() 和 decreaseBalance() 两个方法中，不对外暴露任何修改这个属性的方法和业务细节。这样也可以保证 balance 和 balanceLastModifiedTime 两个数据的一致性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;封装特性的定义讲完了，我们再来看一下，封装的意义是什么？它能解决什么编程问题？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果我们对类中属性的访问不做限制，那任何代码都可以访问、修改类中的属性，虽然这样看起来更加灵活，但从另一方面来说，过度灵活也意味着不可控，属性可以随意被以各种奇葩的方式修改，而且修改逻辑可能散落在代码中的各个角落，势必影响代码的可读性、可维护性。比如某个同事在不了解业务逻辑的情况下，在某段代码中“偷偷地”重设了 wallet 中的 balanceLastModifiedTime 属性，这就会导致 balance 和 balanceLastModifiedTime 两个数据不一致。&lt;/p&gt;
&lt;p&gt;除此之外，类仅仅通过有限的方法暴露必要的操作，也能提高类的易用性。如果我们把类属性都暴露给类的调用者，调用者想要正确地操作这些属性，就势必要对业务细节有足够的了解。而这对于调用者来说也是一种负担。相反，如果我们将属性封装起来，暴露少许的几个必要的方法给调用者使用，调用者就不需要了解太多背后的业务细节，用错的概率就减少很多。这就好比，如果一个冰箱有很多按钮，你就要研究很长时间，还不一定能操作正确。相反，如果只有几个必要的按钮，比如开、停、调节温度，你一眼就能知道该如何来操作，而且操作出错的概率也会降低很多。&lt;/p&gt;
&lt;h2 id=&quot;抽象（abstraction&quot;&gt;抽象（Abstraction)&lt;/h2&gt;
&lt;p&gt;讲完了封装特性，我们再来看抽象特性。封装主要讲的是如何隐藏信息、保护数据，而抽象讲的是如何隐藏方法的具体实现，让调用者只需要关心方法提供了哪些功能，并不需要知道这些功能是如何实现的。&lt;/p&gt;
&lt;p&gt;在面向对象编程中，我们常借助编程语言提供的接口类（比如 Java 中的 interface 关键字语法）或者抽象类（比如 Java 中的 abstract 关键字语法）这两种语法机制，来实现抽象这一特性。&lt;/p&gt;
&lt;p&gt;对于抽象这个特性，我举一个例子来进一步解释一下。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public interface IPictureStorage {
  void savePicture(Picture picture);
  Image getPicture(String pictureId);
  void deletePicture(String pictureId);
  void modifyMetaInfo(String pictureId, PictureMetaInfo metaInfo);
}

public class PictureStorage implements IPictureStorage {
  // ...省略其他属性...
  @Override
  public void savePicture(Picture picture) { ... }
  @Override
  public Image getPicture(String pictureId) { ... }
  @Override
  public void deletePicture(String pictureId) { ... }
  @Override
  public void modifyMetaInfo(String pictureId, PictureMetaInfo metaInfo) { ... }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在上面的这段代码中，我们利用 Java 中的 interface 接口语法来实现抽象特性。调用者在使用图片存储功能的时候，只需要了解 IPictureStorage 这个接口类暴露了哪些方法就可以了，不需要去查看 PictureStorage 类里的具体实现逻辑。&lt;/p&gt;
&lt;p&gt;实际上，抽象这个特性是非常容易实现的，并不需要非得依靠接口类或者抽象类这些特殊语法机制来支持。换句话说，并不是说一定要为实现类（PictureStorage）抽象出接口类（IPictureStorage），才叫作抽象。即便不编写 IPictureStorage 接口类，单纯的 PictureStorage 类本身就满足抽象特性。&lt;/p&gt;
&lt;p&gt;之所以这么说，那是因为，类的方法是通过编程语言中的“函数”这一语法机制来实现的。通过函数包裹具体的实现逻辑，这本身就是一种抽象。调用者在使用函数的时候，并不需要去研究函数内部的实现逻辑，只需要通过函数的命名、注释或者文档，了解其提供了什么功能，就可以直接使用了。比如，我们在使用 C 语言的 malloc() 函数的时候，并不需要了解它的底层代码是怎么实现的。&lt;/p&gt;
&lt;p&gt;抽象有时候会被排除在面向对象的四大特性之外，当时我卖了一个关子，现在我就来解释一下为什么。&lt;/p&gt;
&lt;p&gt;抽象这个概念是一个非常通用的设计思想，并不单单用在面向对象编程中，也可以用来指导架构设计等。而且这个特性也并不需要编程语言提供特殊的语法机制来支持，只需要提供“函数”这一非常基础的语法机制，就可以实现抽象特性、所以，它没有很强的“特异性”，有时候并不被看作面向对象编程的特性之一。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;抽象特性的定义讲完了，我们再来看一下，抽象的意义是什么？它能解决什么编程问题？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;实际上，如果上升一个思考层面的话，抽象及其前面讲到的封装都是人类处理复杂性的有效手段。在面对复杂系统的时候，人脑能承受的信息复杂程度是有限的，所以我们必须忽略掉一些非关键性的实现细节。而抽象作为一种只关注功能点不关注实现的设计思路，正好帮我们的大脑过滤掉许多非必要的信息。&lt;/p&gt;
&lt;p&gt;除此之外，抽象作为一个非常宽泛的设计思想，在代码设计中，起到非常重要的指导作用。很多设计原则都体现了抽象这种设计思想，比如基于接口而非实现编程、开闭原则（对扩展开放、对修改关闭）、代码解耦（降低代码的耦合性）等。我们在讲到后面的内容的时候，会具体来解释。&lt;/p&gt;
&lt;p&gt;换一个角度来考虑，我们在定义（或者叫命名）类的方法的时候，也要有抽象思维，不要在方法定义中，暴露太多的实现细节，以保证在某个时间点需要改变方法的实现逻辑的时候，不用去修改其定义。举个简单例子，比如 getAliyunPictureUrl() 就不是一个具有抽象思维的命名，因为某一天如果我们不再把图片存储在阿里云上，而是存储在私有云上，那这个命名也要随之被修改。相反，如果我们定义一个比较抽象的函数，比如叫作 getPictureUrl()，那即便内部存储方式修改了，我们也不需要修改命名。&lt;/p&gt;
&lt;h2 id=&quot;继承（inheritance&quot;&gt;继承（Inheritance)&lt;/h2&gt;
&lt;p&gt;学习完了封装和抽象两个特性，我们再来看继承特性。如果你熟悉的是类似 Java、C++ 这样的面向对象的编程语言，那你对继承这一特性，应该不陌生了。继承是用来表示类之间的 is-a 关系，比如猫是一种哺乳动物。从继承关系上来讲，继承可以分为两种模式，单继承和多继承。单继承表示一个子类只继承一个父类，多继承表示一个子类可以继承多个父类，比如猫既是哺乳动物，又是爬行动物。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;继承特性的定义讲完了，我们再来看，继承存在的意义是什么？它能解决什么编程问题？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;继承最大的一个好处就是代码复用。假如两个类有一些相同的属性和方法，我们就可以将这些相同的部分，抽取到父类中，让两个子类继承父类。这样，两个子类就可以重用父类中的代码，避免代码重复写多遍。不过，这一点也并不是继承所独有的，我们也可以通过其他方式来解决这个代码复用的问题，比如利用组合关系而不是继承关系。&lt;/p&gt;
&lt;p&gt;如果我们再上升一个思维层面，去思考继承这一特性，可以这么理解：我们代码中有一个猫类，有一个哺乳动物类。猫属于哺乳动物，从人类认知的角度上来说，是一种 is-a 关系。我们通过继承来关联两个类，反应真实世界中的这种关系，非常符合人类的认知，而且，从设计的角度来说，也有一种结构美感。&lt;/p&gt;
&lt;p&gt;继承的概念很好理解，也很容易使用。不过，过度使用继承，继承层次过深过复杂，就会导致代码可读性、可维护性变差。为了了解一个类的功能，我们不仅需要查看这个类的代码，还需要按照继承关系一层一层地往上查看“父类、父类的父类……”的代码。还有，子类和父类高度耦合，修改父类的代码，会直接影响到子类。&lt;/p&gt;
&lt;p&gt;所以，继承这个特性也是一个非常有争议的特性。很多人觉得继承是一种反模式。我们应该尽量少用，甚至不用。关于这个问题，在后面讲到“多用组合少用继承”这种设计思想的时候，我会非常详细地再讲解，这里暂时就不展开讲解了。&lt;/p&gt;
&lt;h2 id=&quot;多态（polymorphism）&quot;&gt;多态（Polymorphism）&lt;/h2&gt;
&lt;p&gt;学习完了封装、抽象、继承之后，我们再来看面向对象编程的最后一个特性，多态。多态是指，子类可以替换父类，在实际的代码运行过程中，调用子类的方法实现。对于多态这种特性，纯文字解释不好理解，我们还是看一个具体的例子。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class DynamicArray {
  private static final int DEFAULT_CAPACITY = 10;
  protected int size = 0;
  protected int capacity = DEFAULT_CAPACITY;
  protected Integer[] elements = new Integer[DEFAULT_CAPACITY];
  
  public int size() { return this.size; }
  public Integer get(int index) { return elements[index];}
  //...省略n多方法...
  
  public void add(Integer e) {
    ensureCapacity();
    elements[size++] = e;
  }
  
  protected void ensureCapacity() {
    //...如果数组满了就扩容...代码省略...
  }
}

public class SortedDynamicArray extends DynamicArray {
  @Override
  public void add(Integer e) {
    ensureCapacity();
    int i;
    for (i = size-1; i&amp;gt;=0; --i) { //保证数组中的数据有序
      if (elements[i] &amp;gt; e) {
        elements[i+1] = elements[i];
      } else {
        break;
      }
    }
    elements[i+1] = e;
    ++size;
  }
}

public class Example {
  public static void test(DynamicArray dynamicArray) {
    dynamicArray.add(5);
    dynamicArray.add(1);
    dynamicArray.add(3);
    for (int i = 0; i &amp;lt; dynamicArray.size(); ++i) {
      System.out.println(dynamicArray.get(i));
    }
  }
  
  public static void main(String args[]) {
    DynamicArray dynamicArray = new SortedDynamicArray();
    test(dynamicArray); // 打印结果：1、3、5
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;多态这种特性也需要编程语言提供特殊的语法机制来实现。在上面的例子中，我们用到了三个语法机制来实现多态。&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;第一个语法机制是编程语言要支持父类对象可以引用子类对象，也就是可以将 SortedDynamicArray 传递给 DynamicArray。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;第二个语法机制是编程语言要支持继承，也就是 SortedDynamicArray 继承了 DynamicArray，才能将 SortedDyamicArray 传递给 DynamicArray。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;第三个语法机制是编程语言要支持子类可以重写（override）父类中的方法，也就是 SortedDyamicArray 重写了 DynamicArray 中的 add() 方法。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;通过这三种语法机制配合在一起，我们就实现了在 test() 方法中，子类 SortedDyamicArray 替换父类 DynamicArray，执行子类 SortedDyamicArray 的 add() 方法，也就是实现了多态特性。&lt;/p&gt;
&lt;p&gt;接下来，我们先来看如何利用接口类来实现多态特性。我们还是先来看一段代码&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public interface Iterator {
  String hasNext();
  String next();
  String remove();
}

public class Array implements Iterator {
  private String[] data;
  
  public String hasNext() { ... }
  public String next() { ... }
  public String remove() { ... }
  //...省略其他方法...
}

public class LinkedList implements Iterator {
  private LinkedListNode head;
  
  public String hasNext() { ... }
  public String next() { ... }
  public String remove() { ... }
  //...省略其他方法... 
}

public class Demo {
  private static void print(Iterator iterator) {
    while (iterator.hasNext()) {
      System.out.println(iterator.next());
    }
  }
  
  public static void main(String[] args) {
    Iterator arrayIterator = new Array();
    print(arrayIterator);
    
    Iterator linkedListIterator = new LinkedList();
    print(linkedListIterator);
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;多态特性讲完了，我们再来看，多态特性存在的意义是什么？它能解决什么编程问题？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;多态特性能提高代码的可扩展性和复用性。为什么这么说呢？我们回过头去看讲解多态特性的时候，举的第二个代码实例（Iterator 的例子）。在那个例子中，我们利用多态的特性，仅用一个 print() 函数就可以实现遍历打印不同类型（Array、LinkedList）集合的数据。当再增加一种要遍历打印的类型的时候，比如 HashMap，我们只需让 HashMap 实现 Iterator 接口，重新实现自己的 hasNext()、next() 等方法就可以了，完全不需要改动 print() 函数的代码。所以说，多态提高了代码的可扩展性。&lt;/p&gt;
&lt;p&gt;如果我们不使用多态特性，我们就无法将不同的集合类型（Array、LinkedList）传递给相同的函数（print(Iterator iterator) 函数）。我们需要针对每种要遍历打印的集合，分别实现不同的 print() 函数，比如针对 Array，我们要实现 print(Array array) 函数，针对 LinkedList，我们要实现 print(LinkedList linkedList) 函数。而利用多态特性，我们只需要实现一个 print() 函数的打印逻辑，就能应对各种集合数据的打印操作，这显然提高了代码的复用性。&lt;/p&gt;
&lt;p&gt;除此之外，多态也是很多设计模式、设计原则、编程技巧的代码实现基础，比如策略模式、基于接口而非实现编程、依赖倒置原则、里式替换原则、利用多态去掉冗长的 if-else 语句等等。关于这点，在学习后面的章节中，你慢慢会有更深的体会。&lt;/p&gt;
&lt;h2 id=&quot;重点回顾&quot;&gt;重点回顾&lt;/h2&gt;
&lt;p&gt;今天的内容就讲完了，我们来一起总结回顾一下，你需要重点掌握的几个知识点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、关于封装特性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;封装也叫作信息隐藏或者数据访问保护。类通过暴露有限的访问接口，授权外部仅能通过类提供的方式来访问内部信息或者数据。它需要编程语言提供权限访问控制语法来支持，例如 Java 中的 private、protected、public 关键字。封装特性存在的意义，一方面是保护数据不被随意修改，提高代码的可维护性；另一方面是仅暴露有限的必要接口，提高类的易用性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、关于抽象特性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;封装主要讲如何隐藏信息、保护数据，那抽象就是讲如何隐藏方法的具体实现，让使用者只需要关心方法提供了哪些功能，不需要知道这些功能是如何实现的。抽象可以通过接口类或者抽象类来实现，但也并不需要特殊的语法机制来支持。抽象存在的意义，一方面是提高代码的可扩展性、维护性，修改实现不需要改变定义，减少代码的改动范围；另一方面，它也是处理复杂系统的有效手段，能有效地过滤掉不必要关注的信息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、关于继承特性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;继承是用来表示类之间的 is-a 关系，分为两种模式：单继承和多继承。单继承表示一个子类只继承一个父类，多继承表示一个子类可以继承多个父类。继承主要是用来解决代码复用的问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4、关于多态特性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;多态是指子类可以替换父类，在实际的代码运行过程中，调用子类的方法实现。多态可以提高代码的扩展性和复用性，是很多设计模式、设计原则、编程技巧的代码实现基础。&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Tue, 02 Jun 2020 23:56:00 +0000</pubDate>
<dc:creator>IT文艺男</dc:creator>
<og:description>理解面向对象编程及面向对象编程语言的关键就是理解其四大特性：封装、抽象、继承、多态。不过，对于这四大特性，光知道它们的定义是不够的，我们还要知道每个特性存在的意义和目的，以及它们能解决哪些编程问题</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/appsucc/p/13034645.html</dc:identifier>
</item>
<item>
<title>面试官问我会不会Elasticsearch，我语塞了... - 龙跃十二</title>
<link>http://www.cnblogs.com/zhonglongbo/p/13035144.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhonglongbo/p/13035144.html</guid>
<description>&lt;p&gt;Elasticsearch是目前使用非常广泛的一个中间件，也是一门专门的技术，有专门的的岗位叫搜索引擎工程师&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;97.551691129547&quot;&gt;
&lt;section id=&quot;nice&quot; data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; readability=&quot;90.79068283344&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;少点代码，多点头发&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文已经收录至我的GitHub,欢迎大家踊跃star 和 issues。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;https://github.com/midou-tech/articles&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从今天开始准备给大家带来全新的一系列文章，Elasticsearch系列&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;新系列肯定会有很多疑惑，先为大家答疑解惑，下面是今天要讲的问题&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1gevalbk9kkj30yc0u0tcr.jpg&quot; alt=&quot;&quot;/&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;为什么写Elasticsearch系列文章？&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之前在文章中也陆陆续续的提到过，龙叔是做搜索引擎的。搜索引擎技术属于商业技术，大家耳熟能详的百度搜索，Google搜索，这可都是因为把握核心搜索技术，从而诞生了商业帝国。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每个互联网大厂都想去分一杯搜索的羹，360搜索、神马、头条、搜狗搜索等等，由此可见搜索技术的商业作用和机密性了。&lt;/p&gt;
&lt;blockquote data-tool=&quot;mdnice编辑器&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;搜索把握用户的入口&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;蘑菇街的搜索引擎是一款使用C++开发、完全自研、没有开源的搜索引擎，没有开源就是不能随便写出来的。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是现在不一样了&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一、我离职了，离开了意味着不在持有那些商业机密了，就算不讲出来我也没啥心理负担(但还是不能讲的，离职协议写的很清楚，不能&lt;strong&gt;泄露公司商业机密&lt;/strong&gt;)。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二、去新的公司还是在搜索领域，他们用Es Elasticsearch是一个开源搜索，开源的东西可以随便说，但还是不能说公司的&lt;strong&gt;商业数据&lt;/strong&gt;。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;自己一直在搜索领域做，输出搜索相关的文章，第一个可以让自己更好的学习和总结，第二个可以让粉丝们了解到搜索这个神秘的技术，增加大家自身的核心竞争力。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;后面会说到，Elasticsearch是搜索引擎，但不简单只能使用在搜索领域，他可以作用的场景非常多。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;Elasticsearch是什么？&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Elasticsearch 是一个分布式的开源&lt;strong&gt;搜索&lt;/strong&gt;和&lt;strong&gt;分析&lt;/strong&gt;引擎，适用于所有类型的数据，包括文本、数字、地理空间、结构化和非结构化数据。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Elasticsearch 在 Apache Lucene 的基础上开发而成，Elasticsearch 以其简单的 REST 风格 API、分布式特性、速度和可扩展性而闻名，是 Elastic Stack 的核心组件。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Elastic Stack 是适用于数据采集、充实、存储、分析和可视化的一组开源工具。人们通常将 Elastic Stack 称为 ELK Stack（代指 Elasticsearch、Logstash 和 Kibana），目前 Elastic Stack 包括一系列丰富的轻量型数据采集代理，这些代理统称为 Beats，可用来向 Elasticsearch 发送数据。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Elasticsearch 的实现原理主要分为以下几个步骤，首先用户将数据提交到Elasticsearch 数据中心，再通过分词控制器去将对应的数据分词，将其权重和分词结果一并存入数据，当用户搜索数据时候，再根据权重将结果排名，打分，再将返回结果呈现给用户。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;是什么差不多搞清楚了，再说说ES都哪些成熟的应用以及在哪些领域使用。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;Elasticsearch在哪些领域使用？&lt;/span&gt;&lt;/h3&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;应用程序搜索&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;网站搜索&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;企业搜索&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;日志处理和分析&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;基础设施指标和容器监测&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;应用程序性能监测&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;地理空间数据分析和可视化&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;安全分析&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;业务分析&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;Elasticsearch有哪些特点？&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Elasticsearch 很快。&lt;/strong&gt; 由于 Elasticsearch 是在 Lucene 基础上构建而成的，所以在全文本搜索方面表现十分出色。Elasticsearch 同时还是一个近实时的搜索平台，这意味着从文档索引操作到文档变为可搜索状态之间的延时很短，一般只有一秒。因此，Elasticsearch 非常适用于对时间有严苛要求的用例，例如安全分析和基础设施监测。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Elasticsearch 具有分布式的本质特征。&lt;/strong&gt; Elasticsearch 中存储的文档分布在不同的容器中，这些容器称为&lt;em&gt;分片&lt;/em&gt;，可以进行复制以提供数据冗余副本，以防发生硬件故障。Elasticsearch 的分布式特性使得它可以扩展至数百台（甚至数千台）服务器，并处理 PB 量级的数据。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Elasticsearch 包含一系列广泛的功能。&lt;/strong&gt; 除了速度、可扩展性和弹性等优势以外，Elasticsearch 还有大量强大的内置功能（例如数据汇总和索引生命周期管理），可以方便用户更加高效地存储和搜索数据。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Elastic Stack 简化了数据采集、可视化和报告过程。&lt;/strong&gt; 通过与 Beats 和 Logstash 进行集成，用户能够在向 Elasticsearch 中索引数据之前轻松地处理数据。同时，Kibana 不仅可针对 Elasticsearch 数据提供实时可视化，同时还提供 UI 以便用户快速访问应用程序性能监测 (APM)、日志和基础设施指标等数据。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;学习Elasticsearch能提高哪些竞争力？&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看到Elasticsearch在这么多的领域在使用，特点也这么明显。看到这里估计都不用在说什么核心竞争力，你已经意识到了。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Elastic 于 2018 年 6 月 29 日正式推出 Elastic Certified Engineer 认证考试，认证通过可以获得官方颁发的证书和徽章，title就是 &lt;strong&gt;Elastic认证工程师&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1gevbch7lomj30u80u0zrz.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体认证的细节和含金量，没有具体研究过，但是可以很明显的感受到官方出了这样一个认证，表明社会需要大量这样的人才，而这方面人才的培养和考核指标还欠缺。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;有没有必要一定要考这个认证？&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;个人觉得，和英语四六级一样，通过了再说没用。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你是学生，可以考虑去考一个认证，因为你很难有业务场景驱使你去做这方面的成长，认证一定是有难度的，一个一个的困难会驱使你成长，最终这个认证也会成为招聘时一个非常大的亮点。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;这个认证会有哪些帮助？&lt;/strong&gt;&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li readability=&quot;-2&quot;&gt;
&lt;section readability=&quot;2&quot;&gt;&lt;p&gt;对于快速的构建知识体系帮助。&lt;/p&gt;
&lt;/section&gt;&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;
&lt;section readability=&quot;2&quot;&gt;&lt;p&gt;对于全面的熟悉官方文档帮助。&lt;/p&gt;
&lt;/section&gt;&lt;/li&gt;
&lt;li readability=&quot;-1.5&quot;&gt;
&lt;section readability=&quot;3&quot;&gt;&lt;p&gt;对于实战解决线上问题帮助。（遇到了相关技术问题基本上不需要再求助于社区，80%以上的问题自己基本就能解决。）&lt;/p&gt;
&lt;/section&gt;&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;
&lt;section readability=&quot;2&quot;&gt;&lt;p&gt;对于增强信心、克服英文恐惧帮助。&lt;/p&gt;
&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;Elasticsearch 支持哪些编程语言？&lt;/span&gt;&lt;/h3&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;Java&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;JavaScript (Node.js)&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;Go&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;.NET (C#)&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;PHP&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;Perl&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;Python&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;Ruby&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;哪里可以找到有关 Elasticsearch 的更多信息？&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我是龙叔，一个分享互联网技术和心路历程的star。&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1gev88f8kfvj30p00dw0tn.jpg&quot; alt=&quot;&quot;/&gt;&lt;/section&gt;&lt;/div&gt;</description>
<pubDate>Tue, 02 Jun 2020 23:40:00 +0000</pubDate>
<dc:creator>龙跃十二</dc:creator>
<og:description>Elasticsearch是目前使用非常广泛的一个中间件，也是一门专门的技术，有专门的的岗位叫搜索引擎工程师</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhonglongbo/p/13035144.html</dc:identifier>
</item>
<item>
<title>计算机网络——开篇　概述 - ~小黑</title>
<link>http://www.cnblogs.com/king0/p/13034674.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/king0/p/13034674.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1600185/202006/1600185-20200603000528518-431091485.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;-计算机网络在信息时代的作用&quot;&gt;🍺 计算机网络在信息时代的作用&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;常见的网络 : 电信网络，有线电视网，计算机网络，随着时代的发展，三网合一&lt;/li&gt;
&lt;li&gt;互联网的基本特征: 联通性(设备之间传递信息)和共享&lt;/li&gt;
&lt;li&gt;互联网是世界上最大的计算机网络，连接的设备亿为单位&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;-互联网概述&quot;&gt;🍺 互联网概述&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;计算网络:由若干的节点 和连接这些的链路组成，节点可以是(计算机 集线器 交换机 和路由器) 链路可以是网线&lt;br/&gt;例如:一个教室的计算机通过交换机，实现共享信息&lt;/li&gt;
&lt;li&gt;互连网(注意这里是连) 指的是上面的网络通过路由互连起来，构成了一个更大的计算机网络。 也可以成为成为&lt;code&gt;网络的网络&lt;/code&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1600185/202006/1600185-20200603000541326-2129898772.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;图中蓝色的就是路由&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;因特网 全球最大的互联网，使用TCP/IP 协议进行交流。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;互联网基本结构发展的三个阶段&quot;&gt;互联网基本结构发展的三个阶段&lt;/h3&gt;
&lt;h4 id=&quot;第一阶段&quot;&gt;第一阶段&lt;/h4&gt;
&lt;p&gt;单个网络ARPANET（阿帕网）向互联网的发展 (上世纪60年代到80年代中期)分组交换的方法就是ARPANET上的网络直接与就近的节点交换机连接。(并不是一个互连的网络)类似有上面提到的教室通过交换机来连接共享信息。 网络并不是开放的。　&lt;br/&gt;　交换机最著名的类型就是路由器和链路交换机&lt;br/&gt;&lt;a href=&quot;https://baike.baidu.com/item/arpanet&quot;&gt;ARPANET的介绍&lt;/a&gt;&lt;br/&gt;1983集提出TCP/IP协议。 最初没有考虑安全性问题。IPv6考虑的安全性问题&lt;/p&gt;
&lt;h4 id=&quot;第二阶段&quot;&gt;第二阶段&lt;/h4&gt;
&lt;p&gt;1985提出三级结构的Internet网络。 学校网-&amp;gt;地区网-&amp;gt;主干网 -&amp;gt;主干网大小45M&lt;/p&gt;
&lt;h4 id=&quot;第三阶段&quot;&gt;第三阶段&lt;/h4&gt;
&lt;p&gt;多层次的ISP结构的互联网 。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ISP(internet Service Provider )互联网服务提供商 ，例如电信，移动&lt;br/&gt;简单说 会联网主机只有IP地址才能上网，IP地址相当于一个门牌号，数据才能找到地址。 而IP地址是由Ip管理结构管理。 ISP申请到IP地址(很对，普通人不能申请到单个IP) ，用户通过租赁ISP手中的IP地址，实现上网。&lt;/li&gt;
&lt;li&gt;ISP可以分为 主干ISP 地区ISP 和本地ISP。&lt;br/&gt;本地ISP连接地区ISP，地区ISP连接主干ISP。&lt;br/&gt;也就是所 A主机到B注意必须进过三个层次。 从本地-&amp;gt;地区-&amp;gt;主干-&amp;gt;地区本地&lt;br/&gt;三个层次&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1600185/202006/1600185-20200603000552398-901824924.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果某个地区到某个地区流量比较的大，我们就直接地区-&amp;gt;地区，不通过主干。 这就是IXP(互联网交换点 Internet eXchange Point) 直接在两个地区之间使用 高速链路对等地交分组。&lt;/p&gt;
&lt;h2 id=&quot;-互联网的组成&quot;&gt;🍺 互联网的组成&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;互联网的主机成为端系统&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1600185/202006/1600185-20200603000607006-252552372.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1600185/202006/1600185-20200603000624738-1673681013.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;服务器也是互联网的边缘部分，服务器只是一个比较快的主机。只是互联网的使用者，而不是运行维护互联网。&lt;/p&gt;
&lt;h3 id=&quot;互联网的边缘部分&quot;&gt;互联网的边缘部分&lt;/h3&gt;
&lt;p&gt;主机之间的通行方式&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;客户端服务器方式(C/S) 客户端请求服务器&lt;/li&gt;
&lt;li&gt;对等方式(P2P) 每个计算机都是客户端也是服务器。例如迅雷。占用上传宽带 。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;计算机网络的核心部分&quot;&gt;计算机网络的核心部分&lt;/h3&gt;
&lt;h4 id=&quot;电路交换&quot;&gt;电路交换&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1600185/202006/1600185-20200602233311845-2044490565.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;座机使用电路连接。 理论使用两个线就可以实现端对端。但是座机多了，自然就是实现通过交换机来实现。交换机就是实现接线的过程。 电路交换适合于数据量很大的实时性传输。&lt;br/&gt;端到端三个步骤: 建立连接(占用通信资源)-&amp;gt;通话-&amp;gt;释放连接(归还资源)&lt;br/&gt;明显: 计算机对于这种连接比较的慢。 计算机发送数据不像打电话，且速度快。&lt;/p&gt;
&lt;h4 id=&quot;分组交换&quot;&gt;分组交换&lt;/h4&gt;
&lt;p&gt;分组交换采用的是存储转发技术。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;发送的数据被称为报文&lt;br/&gt;将报文划分为比较小的数据段，每个段在加上必要的描述信息构成一个分组。&lt;br/&gt;一般分组的首部包含了目的地址和源地址等重要的控制信息。&lt;/li&gt;
&lt;li&gt;主机一般是用户信息的处理。而路由器则用来转发分组的，进行分组交换。 路由器接受一个分组，先暂时存储一下，检查其首部得到目的地址，找的合适的接口转发出去。一步一步进过很多的路由代目的地。 首先，自然产生疑问，路由器是怎么知道转发的接口。其实路由器之间必须经常掌握的路由信息。以便创建和维护路由器中的转发表。 路由中存储的只是报表，真正的数据在内存中。 通过协议来实现数据的准确性&lt;/li&gt;
&lt;/ul&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;优点&lt;/th&gt;
&lt;th&gt;所采用的手段&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;4.5&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;高效&lt;/td&gt;
&lt;td&gt;在分组传输中动态分配宽带，对通信链路是逐段栈用&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;灵活&lt;/td&gt;
&lt;td&gt;为每个分组独立的选择最适合的转发路线。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;迅速&lt;/td&gt;
&lt;td&gt;以分组为单位， 可以不建立就能向其他分组分组&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;可靠&lt;/td&gt;
&lt;td&gt;保证可靠性的网络协议，分布式多路由分组交换网，使得网络有很好的生存型&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;问题:&lt;br/&gt;可能产生较大的时延&lt;/p&gt;
&lt;h4 id=&quot;报文交换&quot;&gt;报文交换&lt;/h4&gt;
&lt;p&gt;类似于分组交换，但是传输的数据是一个整体。&lt;/p&gt;
&lt;p&gt;很明显报文交换是最慢的。报文交换类似于一条流水线完成所有的工作。 分组交换相当于每个公司负责一部分，在组装，类似并行。&lt;/p&gt;
&lt;h2 id=&quot;-其他一些计算器网络的分类&quot;&gt;🍺 其他一些计算器网络的分类&lt;/h2&gt;
&lt;h3 id=&quot;按照网络的作用范围分类&quot;&gt;按照网络的作用范围分类&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;广域网 (远程网) 是互联网的核心部分，用来连接国家。使用高速链路。具有较大的通行容量&lt;/li&gt;
&lt;li&gt;城域网(Metropolitan Area NetWork) 用来连接城市。5-50km。为共有设施。 城域网采用的以太网技术&lt;/li&gt;
&lt;li&gt;局域网(LAN) 类型企业网，校园网 速度10M/S以上。&lt;br/&gt;+个人区域网(PAN) 10m左右，一般使用无线技术来连接。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;按照网络的使用分类&quot;&gt;按照网络的使用分类&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;公用网 电信公司出资建造的大型网络&lt;/li&gt;
&lt;li&gt;专用网 部门的特殊要求&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;计算机网络的性能指标&quot;&gt;🍺计算机网络的性能指标&lt;/h2&gt;
&lt;h4 id=&quot;速率&quot;&gt;速率&lt;/h4&gt;
&lt;p&gt;网络中速率指的是:计算机网络上的主机在数字信道上传输数据位数的速率。 (信道指的是你到ISP服务器的一个通道。 同样的服务器到对应的ISP提供商的又是另一个信道)&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;bit/s&lt;/li&gt;
&lt;li&gt;Mbit/s&lt;/li&gt;
&lt;li&gt;MB/s 和Mbit/s的区别&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;带宽&quot;&gt;带宽&lt;/h4&gt;
&lt;p&gt;在计算机网络中，宽带用来表示网络中&lt;code&gt;某信道传输数据的能力&lt;/code&gt;。也就是数字信道传送的最高数据率单位应该是 b/s kb/s Mb/s Gb/s。&lt;br/&gt;一般电信，联通说的宽带是用的是b而不是bit，8b=1bit。所以我们实际的速度要除以8。 100M宽带对应的速率 为100/8M/s&lt;/p&gt;
&lt;h4 id=&quot;吞吐量&quot;&gt;吞吐量&lt;/h4&gt;
&lt;p&gt;表示在待你我时间内通过某个网络(或通道，接口)的实际的数据量。一般这种吞吐量以Gbit/s 为单位&lt;/p&gt;
&lt;h4 id=&quot;时延&quot;&gt;时延&lt;/h4&gt;
&lt;p&gt;就是网络存一个端口带内一个端口花费的时间。这是一个比较重要的指标。有时称为延迟或者迟延&lt;br/&gt;时延是由3个部分组成:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;发送时延 是主机或路由发送数据帧所需要的的时间。就是从第一个bit算起，到最后一个bit。发送完毕需要的时间。 简单一点就是火车出站需要的时间&lt;br/&gt;发送时延= (数据块的长度 比特) / 信道宽度(bit/s)&lt;/li&gt;
&lt;li&gt;传播时延 电磁波在信道中传播一定距离需要的时间 ，计算公式:&lt;br/&gt;传播时延: 信道长度(m)/ 电磁波在信道上的传播速率(m/s)&lt;br/&gt;发送时延时数据准备花费的时间(一般发生在网络适配器中)，传播时延时传播过程花费的时间&lt;/li&gt;
&lt;li&gt;处理时延&lt;br/&gt;主机或路由在接受到分组要花费一定的时间进行处理。例如分析首部，从分组中提取数据，检验，寻找适合的路由。&lt;/li&gt;
&lt;li&gt;排队时延 在网络传输过程中，经过许多的路由器，但是进入路由器之后要在输入队列中等待被处理花费的时间。&lt;br/&gt;总的花费时间就是 总时延= 发送时延+ 传播时延+ 处理时延+ 排队时延。&lt;br/&gt;光纤的传播时延为20。5万公路，铜线的传播距离为23。5万公里。&lt;br/&gt;还有一些其他的指标&lt;/li&gt;
&lt;li&gt;时延带宽积&lt;/li&gt;
&lt;li&gt;往返时间RTT&lt;/li&gt;
&lt;li&gt;利用率&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;计算器网络体系的结构&quot;&gt;🍺计算器网络体系的结构&lt;/h2&gt;
&lt;p&gt;同样计算机网络也有着程序设计的思想 模块化， 低耦合。&lt;br/&gt;开放系统互联基本参考模型(OSI/RM) (Open Systems Interconnection Reference Model) 这是一个抽象的概念。在1983年形成了ORM的正式文件ISO 7498 国际标准。一共划分了7层&lt;br/&gt;但是现在使用的是TCP/IP协议。 虽然是非国际标准，但是已经成为事实上的国际标准。TCP/IP协议没有使用OSI标准。&lt;br/&gt;OSI失败的原因:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;OSI 专家缺乏实际的经验，在完成OSI标准是缺乏商业动力&lt;/li&gt;
&lt;li&gt;实现太过复杂&lt;/li&gt;
&lt;li&gt;指定的周期太长，设备无法及时的进入市场&lt;/li&gt;
&lt;li&gt;OSI的划分层次不合理，功能造多个层次中出现&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;osi的和tcpip的具体划分&quot;&gt;OSI的和TCP/IP的具体划分&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1600185/202006/1600185-20200603000713046-1281494778.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;具体每一层的划分，而且并不是所有的程序或者设备遵守协议。&lt;br/&gt;计算机网络如同计算机的其他学科也是极为复杂的，那么进行一些抽象，简单化是必要的。 早在最初的APRANET就提出了分层的概念。再到后来&lt;code&gt;1977&lt;/code&gt;年成立了专门的机构来研究该问题。试图提出一个各种计算机体系都可以互连在世界访问内互连成为网络的标准架构。 及就是&lt;code&gt;开放系统互连基本参考模型&lt;/code&gt; OSI/RM(Open System Interconnection Reference Model)简称为OSI。&lt;/p&gt;
&lt;p&gt;虽然这种体系将复杂的网络分解为若干的问题。但是基于TCP/IP的的互联网已经大范围在世界中使用。 OSI的七层协议体系概念非常的清晰，但是太过复杂不实用。所以TCP/IP使用了四层协议&lt;/p&gt;
&lt;p&gt;这里我使用一个5层协议来讲述计算机网络&lt;/p&gt;
&lt;h4 id=&quot;应用层&quot;&gt;应用层&lt;/h4&gt;
&lt;p&gt;应用层是体系结构中的最高层。应用层的任务主要是通过应用进程间的交互来完成特定的网络应用。应用层定义了应用进进程通信和交互的规则，例如(HTTP协议，支持电子邮件的SMTP等等)，我们把应用层的数据单元成为报文&lt;/p&gt;
&lt;h4 id=&quot;运输层&quot;&gt;运输层&lt;/h4&gt;
&lt;p&gt;运输层的任务主要是负责两台主机中进程之间的通信&lt;code&gt;提供``通用&lt;/code&gt;的数据传输服务。应用层利用该服务传送应用层的报文。 这种通用的是指，并不是针对某个具体的应用服务，而是多个应用服务可以同时使用一个运输层服务。一个主机可以同时运行多个进程，因此运输层有复用和分用的功能。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;复用: 多个应用层程序可以使用同一个运输层&lt;/li&gt;
&lt;li&gt;分用: 运输层把收到的信息，分别交付到应用层中的相应的进程中。&lt;br/&gt;运输层主要使用的两个协议:&lt;/li&gt;
&lt;li&gt;传输控制协议TCP(Transmission Control Protocol) 提供面向连接的，可靠的数据传输服务，其数据传输的单位的&lt;code&gt;报文段&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;用户数据协议UDP (User Datagram Protocol) 提供无连接的，尽最大努力的数据传输服务(不保证数据的可靠性)，其数据传输的单位是 &lt;code&gt;用户数据报&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;网络层&quot;&gt;网络层&lt;/h4&gt;
&lt;p&gt;网络层负责为分组交换网上的不同主机提供通信服务。在TCp/IP协议中，由于网络层使用的是IP协议，因此分组也叫IP数据报。 IP层或者网际层指的也是该层 路由器应该属于这一层。它确定了数据发送的源地址，目标地址，以及进过的路由。其中路由表中的条目，可以是人工添加，也可以是自动获取。&lt;/p&gt;
&lt;h4 id=&quot;数据链路层data-linker-layer&quot;&gt;数据链路层(data linker layer)&lt;/h4&gt;
&lt;p&gt;也称为链路层， 两台主机在线路上传输，是一段一段的传输的，所以需要使用专门的协议。在两个相邻的节点之间传输数据是，数据链路层把网络层交下来的IP数据组装成帧(Framing)，在加上一些同步信息，地址信息。差错信息。等。&lt;br/&gt;在接受到数据后，就可以提取出数据交给网络层。同时该层还会检测帧中是否有错误发现有差错的，丢弃或者改正。&lt;/p&gt;
&lt;h4 id=&quot;物理层&quot;&gt;物理层&lt;/h4&gt;
&lt;p&gt;在物理层中传输的单位是bit，发送0还是1，物理层一般使用高低电压来代替逻辑0和1。通常物理层会定义电缆的插头，已经引脚。还有一些实际的电缆，无线网，光缆来具体的传递信息，并不是网络协议的内容。那就是通信工程的任务。 这个可以是第0层。&lt;/p&gt;
&lt;p&gt;通常我们说的TCP/IP并不是单指的是者两个协议，而是往往值得是互联网使用的TCP/IP协议族。&lt;/p&gt;
&lt;p&gt;在计算机网络中必须考虑特殊的情况，把不利的条件都要考虑进去。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;个人的理解&lt;/li&gt;
&lt;li&gt;应用层 : 就是定义了交互的方式规则，认为我和另一个程序在交互，不管操作系统，等等的差异。就像在一台计算机中，不同的进程在交互。&lt;/li&gt;
&lt;li&gt;运输层: 把数据分组，包装每个分组的源地址，目标地址，顺便选择一个最短路径，重点它描述了收货地址。&lt;/li&gt;
&lt;li&gt;网络接口层:黑箱操作，扔进去数据得到我们想要的结果，或者有点类似于Java的JDBC规范等。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1600185/202006/1600185-20200603000246746-1234503286.gif&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Tue, 02 Jun 2020 16:04:00 +0000</pubDate>
<dc:creator>~小黑</dc:creator>
<og:description>✏️概述 &amp;amp;#127866; 计算机网络在信息时代的作用 常见的网络 : 电信网络，有线电视网，计算机网络，随着时代的发展，三网合一 互联网的基本特征: 联通性(设备之间传递信息)和共享 互联</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/king0/p/13034674.html</dc:identifier>
</item>
<item>
<title>初窥Ansible playbook - ^_^果冻^_^</title>
<link>http://www.cnblogs.com/vipygd/p/13034739.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/vipygd/p/13034739.html</guid>
<description>&lt;blockquote readability=&quot;6.3785046728972&quot;&gt;
&lt;p&gt;Ansible是一个系列文章，我会尽量以通俗易懂、诙谐幽默的总结方式给大家呈现这些枯燥的知识点，让学习变的有趣一些。&lt;br/&gt;Ansible系列博文直达链接：&lt;a href=&quot;https://www.jellythink.com/tool-tutorials/ansible&quot;&gt;Ansible入门系列&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在上一篇文章中说到Ansible有两种玩法，一种是Ansible Ad-Hoc，另一种是就是这里要说的playbook。playbook是Ansible进行配置管理的组件，虽然Ansible的日常Ad-Hoc命令功能很强大，能完成一些基本的配置管理工作，但是Ad-Hoc命令无法支撑复杂环境的配置管理工作。在我们实际使用Ansible的工作中，大部分时间都是在编写playbook，接下来就重点说说如何玩转这个playbook。&lt;/p&gt;

&lt;p&gt;我们都是按照yaml语法规则来编写playbook，至于yaml怎么玩，后面的文章我会总结一下的。在我们按照要求编写好了yaml文件后，如何来执行这个yaml文件呢？&lt;/p&gt;
&lt;p&gt;Ansible提供了一个单独的命令：&lt;code&gt;ansible-playbook&lt;/code&gt;命令，我们可以通过这个命令来执行yaml脚本。常见的&lt;code&gt;ansible-playbook&lt;/code&gt;的使用方法如下：&lt;/p&gt;
&lt;p&gt;最简单的使用方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ansible-playbook copyDemo.yaml
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们还可以使用以下命令查看输出的细节：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ansible-playbook copyDemo.yaml --verbose
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们也可以使用以下命令查看该yaml脚本将影响的主机列表：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ansible-playbook copyDemo.yaml --list-hosts
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;还可以使用以下命令检查yaml脚本语法是否正确：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ansible-playbook copyDemo.yaml --syntax-check
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的几种使用方法基本就涵盖了我们日常工作中80%的场景了，剩余的20%场景，比如并行、异步等，很少用到，等真正用到的时候再去查阅相关资料也来的及。而工作中，更多的时候，我们不是在编写playbook，就是在编写playbook的路上。所以，接下来我重点说说如何写这个playbook，也就是playbook的基本语法。&lt;/p&gt;

&lt;p&gt;最基本的playbook脚本分为三个部分：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;在哪些机器上以什么身份执行&lt;/li&gt;
&lt;li&gt;执行的任务有哪些&lt;/li&gt;
&lt;li&gt;善后任务有哪些&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;我们在编写playbook脚本的时候，总是离不开上面的三个部分的。下面先来一个稍微有点复杂的playbook脚本，让大家先有一个整体的认识。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;---
- hosts: server1
  user: root
  vars:
    http_port: 80
    max_clients: 200

  tasks:
    - name: Write apache config file
      template: src=/home/test1/httpd.j2 dest=/home/test2/httpd.conf
      notify:
        - restart apache
    - name: Ensure apache is running
      service: name=httpd state=started

  handlers:
    - name: restart apache
      service: name=httpd state=restarted
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在就对上述三部分稍作详细总结。&lt;/p&gt;

&lt;p&gt;上面的yaml脚本，我们一开始就会看到&lt;code&gt;hosts&lt;/code&gt;、&lt;code&gt;user&lt;/code&gt;和&lt;code&gt;vars&lt;/code&gt;，其中&lt;code&gt;vars&lt;/code&gt;在后面的文章进行专门总结。而这里的&lt;code&gt;hosts&lt;/code&gt;和&lt;code&gt;user&lt;/code&gt;就是表示我们这个yaml将要在哪些主机上用哪个用户身份去操作。而这里的深一层次的关系如下表所示：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;key&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;hosts&lt;/td&gt;
&lt;td&gt;为主机的IP，或者主机组名，或者关键字all&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;user&lt;/td&gt;
&lt;td&gt;在远程以哪个身份执行&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;become&lt;/td&gt;
&lt;td&gt;切换成其他用户身份执行，值为yes或者no&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;become_method&lt;/td&gt;
&lt;td&gt;与become一起使用，值可以为&lt;code&gt;sudo&lt;/code&gt;/&lt;code&gt;su&lt;/code&gt;等&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;become_user&lt;/td&gt;
&lt;td&gt;与become一起使用，可以是root或者其它用户名&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;在实际工作中，如果我们不指定&lt;code&gt;user&lt;/code&gt;时，则默认使用连接远程主机的用户进行操作，如果指定了执行用户而与&lt;code&gt;ansible_ssh_user&lt;/code&gt;指定用户不一致时，则需要开启&lt;code&gt;become&lt;/code&gt;操作，这里的&lt;code&gt;become&lt;/code&gt;配置与ansible.cfg中配置将相互配合完成工作，yaml中的become优先级高于ansible.cfg中配置中的优先级。&lt;/p&gt;

&lt;p&gt;任务列表是整个playbook的核心，对于任务列表，我们首先需要知道以下三点内容：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;任务是从上到下顺序执行的，如果中间发生错误，那么整个playbook会中止；&lt;/li&gt;
&lt;li&gt;每一个任务都是对模块的一次调用，只是使用不同的参数和变量而已；&lt;/li&gt;
&lt;li&gt;每一个任务最好有一个name属性，这样在执行yaml脚本时，可以看到执行进度信息。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对于任务的参数有两种不同的写法，我们在编写yaml脚本时，可以按照自己的喜好进行选择。&lt;/p&gt;
&lt;p&gt;写法一：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;- name: Write apache config file
  template: src=/home/test1/httpd.j2 dest=/home/test2/httpd.conf
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;写法二：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;- name: Write apache config file
  template: 
    src: /home/test1/httpd.j2
    dest: /home/test2/httpd.conf
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这两种写法都是OK的，我一般喜欢第二种写法。&lt;/p&gt;
&lt;p&gt;最后，对于任务我们还需要特别一个点，那就是任务的执行状态。我们在执行Ansible Ad-Hoc或者ansible-playbook的时候，在输出中都会有一个&lt;code&gt;changed&lt;/code&gt;字段，比如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;192.168.1.3                : ok=2    changed=0    unreachable=0    failed=0  
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或者&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;192.168.1.3                : ok=2    changed=1    unreachable=0    failed=0
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的这个&lt;code&gt;changed&lt;/code&gt;就是人物的执行状态，但是它为什么一会是0，一会有是1呢？这就要说到Ansible中一个叫做“幂等性”的概念。&lt;/p&gt;

&lt;p&gt;幂等性是数学和计算机科学上一个常见的概念，多次执行产生的结果不会发生改变，这样的特性就被成为幂等性。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;大多数的Ansible模块在设计时保证了幂等性，幂等性保证了Ansible脚本多次执行情况下的相同结果，尽可能的避免使用那些不能满足幂等性的模块。比如我们经常使用的&lt;code&gt;shell&lt;/code&gt;模块就是非幂等性的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们要明白Ansible是以“结果为导向的”，我们指定了一个“目标状态”，Ansible会自动判断“当前状态”是否与“目标状态”一致，如果一致，则不进行任何操作；如果不一致，那么就将“当前状态”变成“目标状态”，这就是“幂等性”，“幂等性”可以保证我们重复的执行同一项操作时，得到的结果是一样的。&lt;/p&gt;
&lt;p&gt;那这个幂等性与上面的&lt;code&gt;changed&lt;/code&gt;又有什么关系呢？且听我下面慢慢道来！&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当&lt;code&gt;changed&lt;/code&gt;为false或者0时，表示Ansible没有进行任何操作，没有“改变什么”；&lt;/li&gt;
&lt;li&gt;当&lt;code&gt;changed&lt;/code&gt;为true或者大于0时，表示Ansible执行了操作，“当前状态”已经被Ansible改变成了“目标状态”。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;拿&lt;code&gt;copy&lt;/code&gt;这个模块来举例子说明，当我们准备将一个文件通过Ansible拷贝到远程主机时，&lt;code&gt;copy&lt;/code&gt;模块首先检查远程是否已经存在了该文件，如果不存在，则把文件拷贝过去，返回&lt;code&gt;changed&lt;/code&gt;为大于0；如果存在时，则开始比对两个文件的md5值，如果md5值一致，则说明两个文件是一样的，则不需要拷贝，此时&lt;code&gt;copy&lt;/code&gt;模块则什么都不干，返回&lt;code&gt;changed&lt;/code&gt;为0。&lt;/p&gt;

&lt;p&gt;通过三篇文章总结了Ansible中的常用模块、Ansible Ad-Hoc和ansible-playbook的一些惯用用法，从我的实际学习经验来说，学到这里，你可以将这三块内容结合起来使用了，至少可以在你们生产环境鼓捣一下了。生来就是折腾，更何况我们这么拼命、努力的学习呢！&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jellythink.com&quot;&gt;果冻想&lt;/a&gt;，认真玩技术的地方。&lt;/p&gt;
&lt;p&gt;2019年5月18日，于内蒙古呼和浩特。&lt;/p&gt;
</description>
<pubDate>Tue, 02 Jun 2020 15:48:00 +0000</pubDate>
<dc:creator>^_^果冻^_^</dc:creator>
<og:description>Ansible是一个系列文章，我会尽量以通俗易懂、诙谐幽默的总结方式给大家呈现这些枯燥的知识点，让学习变的有趣一些。 Ansible系列博文直达链接：Ansible入门系列 前言 在上一篇文章中说到A</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/vipygd/p/13034739.html</dc:identifier>
</item>
<item>
<title>学习源码的第八个月，我成了Spring的开源贡献者 - 程序员DMZ</title>
<link>http://www.cnblogs.com/daimzh/p/13034515.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/daimzh/p/13034515.html</guid>
<description>&lt;p&gt;@&lt;/p&gt;


&lt;p&gt;关注我的朋友都知道，&lt;strong&gt;关注&lt;/strong&gt;两个字划重点，要考！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1547369/202006/1547369-20200602230748221-3366733.jpg&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我最近一直在写Spring的文章，而且仅仅是&lt;code&gt;Spring FrameWork&lt;/code&gt;的文章 ,从最开始的官网入门到现在源码的深度分析。主要就是三个系列&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;官网入门系列&lt;/strong&gt;，&lt;a href=&quot;https://blog.csdn.net/qq_41907991/category_9601507.html&quot;&gt;Spring官网读书笔记&lt;/a&gt;，这一系列的文章是入门Spring的不二之选，也是后续源码阅读的基础&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;杂谈系列&lt;/strong&gt;，&lt;a href=&quot;https://blog.csdn.net/qq_41907991/category_9808373.html&quot;&gt;Spring杂谈&lt;/a&gt;，这主要是一些补充内容，可以帮助大家更全面学习到Spring中的各个知识点，同时也会分享一些源码阅读技巧，个人学习心得之类的，杂谈嘛，就是不知道放哪里的文章都打算放这里，比如这篇文章。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1547369/202006/1547369-20200602230748564-1447607729.jpg&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;源码分析系列&lt;/strong&gt;，&lt;a href=&quot;https://blog.csdn.net/qq_41907991/category_9907747.html&quot;&gt;Spring源码解析&lt;/a&gt;，该专栏目前正在创作中，相对而言学习难度比较大，而且因为笔者写的比较细，估计大部分同学看起来会很费劲，不过如果你能认真看完，收获绝对巨大！当然有不懂得地方也可以给笔者留言，或者关注文章末尾的公众号。&lt;/p&gt;
&lt;p&gt;本文的主要目的是&lt;strong&gt;教（zhuang）学（bi）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1547369/202006/1547369-20200602230748856-1028194915.jpg&quot; alt=&quot;image-20200602071958918&quot;/&gt;&lt;/p&gt;
&lt;p&gt;就是从笔者的实际经验出发，谈一谈怎么成为一个&lt;strong&gt;开源项目的贡献者&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;我先说说我自己的经历吧，在创作&lt;a href=&quot;https://www.cnblogs.com/daimzh/p/13034515.html&quot;&gt;上篇文章&lt;/a&gt;的时候，笔者发现Spring在实例化对象的时候有这么一段代码，在&lt;code&gt;org.springframework.beans.factory.support.ConstructorResolver#resolveConstructorArguments&lt;/code&gt;方法中&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 本文不探讨技术细节，只是为了简单说明这个问题，所以省略无关代码     
private int resolveConstructorArguments(String beanName, RootBeanDefinition mbd, BeanWrapper bw,
                        ConstructorArgumentValues cargs, ConstructorArgumentValues resolvedValues) {

      // ....
                for (Map.Entry&amp;lt;Integer, ConstructorArgumentValues.ValueHolder&amp;gt; entry : cargs.getIndexedArgumentValues().entrySet()) {
                        int index = entry.getKey();
                        if (index &amp;lt; 0) {
                                throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                                                &quot;Invalid constructor argument index: &quot; + index);
                        }
            // 问题就出在这里
                        if (index &amp;gt; minNrOfArgs) {
                                minNrOfArgs = index + 1;
                        }
       // ..... 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述代码中，&lt;code&gt;minNrOfArgs&lt;/code&gt;这个变量就是保存方法需要的最小参数个数，但是&lt;code&gt;index&lt;/code&gt;是下标索引，&lt;strong&gt;索引是从0开始的&lt;/strong&gt;，如果有下标为n的元素，那么最小的参数个数应该是n+1嘛，所以if中的逻辑是没有问题的，但是if这个判断是有问题的，正确的做法应该是&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;if (index+1 &amp;gt; minNrOfArgs) {
    minNrOfArgs = index + 1;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当发现这个问题的时候，第一反应就是肯定是我的姿势不对，错的怎么可能是代码，肯定是我！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1547369/202006/1547369-20200602230749402-1516297956.jpg&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来，我就对这段代码进行了惨无人道的调试，在无数次&lt;code&gt;debug&lt;/code&gt;后，我发现，这个地方确实有问题！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1547369/202006/1547369-20200602230750087-544929490.jpg&quot; alt=&quot;image-20200602203349414&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在确认了这个问题之后，我要思考的就是怎么把自己的想法反馈给Spring，换而言之，怎么为伟大的开源来做贡献呢？正常来要达到这个目的有两个方式&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;提交issue&lt;/li&gt;
&lt;li&gt;直接在GitHub上提交PR（pull request）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对应的就是在&lt;a href=&quot;https://github.com/spring-projects/spring-framework&quot;&gt;GitHub&lt;/a&gt;上点击下图红框选中的两个位置&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1547369/202006/1547369-20200602230750581-265016075.jpg&quot; alt=&quot;image-20200602204827377&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果是使用提交issue的方式，相当于给官方团队提交了一个议题，这个议题可能是你发现代码中的某个bug，也可能是你觉得官方的做法不够好，你有更好的想法等等。感兴趣的话，大家可以去看看Spring中现在有哪些还未关闭的issue，说不定其中一个你就能解决呢~！&lt;/p&gt;
&lt;p&gt;如果要采用提交PR的方式的话，首先你得将代码fork到自己的GitHub中，然后在从自己的GitHub检出到本地，在本地做完修改后，提交到GitHub仓库中，最后从自己的GitHub向Spring官方仓库发起一个PR。&lt;/p&gt;
&lt;p&gt;像我的话很早就已经将代码fork到了自己GitHub&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1547369/202006/1547369-20200602230751813-359985992.jpg&quot; alt=&quot;image-20200602211528302&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图中的第一个红框，说明我这个仓库是从Spring官方fork过来的，第二个红框就是可以从这里向Spring官方提交一个PR。关于详细的如何提交PR，大家可以自行百度，这里不做详细的介绍了。&lt;/p&gt;
&lt;p&gt;另外，说了这么多，先给大家看下我提交的issue吧。&lt;/p&gt;
&lt;p&gt;issue链接：&lt;a href=&quot;https://github.com/spring-projects/spring-framework/issues/25130&quot;&gt;https://github.com/spring-projects/spring-framework/issues/25130&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;因为内容也不长，所以我这里把原文就直接放到下面了&lt;/p&gt;
&lt;blockquote readability=&quot;45&quot;&gt;
&lt;p&gt;In &lt;code&gt;ConstructorResolver&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private int resolveConstructorArguments(String beanName, RootBeanDefinition mbd, BeanWrapper bw,
                        ConstructorArgumentValues cargs, ConstructorArgumentValues resolvedValues) {
                TypeConverter customConverter = this.beanFactory.getCustomTypeConverter();
                // ...

                for (Map.Entry&amp;lt;Integer, ConstructorArgumentValues.ValueHolder&amp;gt; entry : cargs.getIndexedArgumentValues().entrySet()) {
                        int index = entry.getKey();
                        if (index &amp;lt; 0) {
                                throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                                                &quot;Invalid constructor argument index: &quot; + index);
                        }
                        if (index &amp;gt; minNrOfArgs) {
                                minNrOfArgs = index + 1;
                        }
                        // ....
                }
// ....
 return minNrOfArgs;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;I assume that method &lt;code&gt;resolveConstructorArguments&lt;/code&gt; is to resolve contructor arguments in the XML file and return the minimum number of parameters required by contructor 。but if the first parameter is autowired , the second parameter is config by XML file，the method will not work well。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;example&lt;/strong&gt;:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class FactoryObject {
        
 public DmzService getDmz(String name, int age, Date birthDay, OrderService orderService) {

        public DmzService getDmz(OrderService orderService,String name) {
                
                return new DmzService(orderService,name);
        }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
           xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
           xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;
           default-autowire=&quot;constructor&quot;&amp;gt;
        &amp;lt;bean id=&quot;factoryObject&quot; class=&quot;com.dmz.spring.first.instantiation.service.FactoryObject&quot;/&amp;gt;

        &amp;lt;bean class=&quot;com.dmz.spring.first.instantiation.service.OrderService&quot; id=&quot;orderService&quot;/&amp;gt;

        &amp;lt;bean id=&quot;dmzService&quot; factory-bean=&quot;factoryObject&quot; factory-method=&quot;getDmz&quot;&amp;gt;
                &amp;lt;constructor-arg index=&quot;1&quot;  value=&quot;dmz&quot;/&amp;gt;
        &amp;lt;/bean&amp;gt;

&amp;lt;/beans&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;the &lt;code&gt;resolveConstructorArguments&lt;/code&gt; method will return 1,but correct answer is 2。&lt;/p&gt;
&lt;p&gt;I think the problem arises because of this judgment:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;if (index &amp;gt; minNrOfArgs) {
 minNrOfArgs = index + 1;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;It might be better to change it to look like this&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;if (index + 1 &amp;gt; minNrOfArgs) {
 minNrOfArgs = index + 1;
}s
&lt;/code&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt;我在提交issue时主要是按照这种思路&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;首先摆出有问题的代码&lt;/li&gt;
&lt;li&gt;描述具体的问题，我是直接通过一个例子来描述的&lt;/li&gt;
&lt;li&gt;说出自己的建议&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这几天我又多看了看别人提交的issue，对比起来，我觉得至少应该还要添加一点&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;应该要明确的指出具体哪个版本上出现的问题&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1、担心闹乌龙&quot;&gt;1、担心闹乌龙&lt;/h2&gt;
&lt;p&gt;虽然在之前我已经调试过了无数次代码，但是心里还是没谱啊。毕竟我这么谨（cai）慎（ji）的一个人，万一被人喷了怎么办？不知道你会不会这么想，反正我当时就是这么想的，如果你是这么想的，建议你去看看别人提交的issue。搜索条件如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1547369/202006/1547369-20200602230752283-1180007219.jpg&quot; alt=&quot;image-20200602221719579&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;is:closed label:&quot;status: invalid&quot;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我觉得你看几个，自然就有信心了！&lt;/p&gt;
&lt;h2 id=&quot;2、不知道要怎么提交&quot;&gt;2、不知道要怎么提交&lt;/h2&gt;
&lt;p&gt;每个开源的项目，只要作者希望这个项目越来越好的话，都会详细的说明如何给这个项目做开源贡献，Spring肯定也不例外，这里还是以提交issue为例，当你点击New issue的时候会出现下面这张图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1547369/202006/1547369-20200602230752583-1029261430.jpg&quot; alt=&quot;image-20200602222421975&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在上图左边的框里很明确的告诉了你提交issue应该要注意什么&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先，你应该要去Stack Overflow提问&lt;/li&gt;
&lt;li&gt;如果是bug，你应该要指明版本以及你想要做什么&lt;/li&gt;
&lt;li&gt;如果是一个增强的话，要提供上下文并且描述清楚问题&lt;/li&gt;
&lt;li&gt;同一个问题，issue跟PR最好只提交一个，因为GitHub认为它们是一样的，如果你还不能确定的话，先提交一个issue&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;而右上角还有更加详细的文档可供参考。&lt;/p&gt;
&lt;h2 id=&quot;3、英文&quot;&gt;3、英文&lt;/h2&gt;
&lt;p&gt;大家应该看到了，整个issue都是用英文写的，那么英文不好怎么办呢？这个时候就要掏出我们的神器了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1547369/202006/1547369-20200602230753283-1681332228.jpg&quot; alt=&quot;image-20200602214339837&quot;/&gt;&lt;/p&gt;
&lt;p&gt;嗯，就是词典，笔者习惯是使用有道词典。我建议英文不好的同学可以这样，先将整个issue用中文写好，如果你真的英文一窍不通的话，可以直接通过翻译软件逐句翻译，然后粘贴到GitHub上。但是千万千万不要使用中文，就像下面这个哥们&lt;/p&gt;
&lt;p&gt;issue链接：&lt;a href=&quot;https://github.com/spring-projects/spring-framework/pull/25127&quot;&gt;https://github.com/spring-projects/spring-framework/pull/25127&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1547369/202006/1547369-20200602230753985-433423442.jpg&quot; alt=&quot;image-20200602215146927&quot;/&gt;&lt;/p&gt;
&lt;p&gt;像这种issue是会被直接打上invalid（不合格）标签的，你就想想吧，你学不会英文，你指望我们的外国朋友能看懂中文嘛？是我中华上线五千年的文化不够博大精深吗？&lt;/p&gt;
&lt;h2 id=&quot;4、担心问题描述的不清楚&quot;&gt;4、担心问题描述的不清楚&lt;/h2&gt;
&lt;p&gt;其实这个问题就是因为英文不好衍生出来的。因为英文不好，自然就会担心我写的东西他能不能看懂呢？我的建议就是，结合你测试的代码去描述问题。你不用去担心别人看不懂你写的代码，就以我那个issue的处理流程为例吧。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1547369/202006/1547369-20200602230754307-70671019.jpg&quot; alt=&quot;image-20200602215944850&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在你刚刚提交issue时，有专门的&lt;code&gt;issuemaster&lt;/code&gt;（issue管理员）会给你提交的issue打上一个wait-for-triage的标签，标志这个issue是待处理的。&lt;/p&gt;
&lt;p&gt;随后我提交的这个issue，就被指派给了&lt;code&gt;jhoeller&lt;/code&gt;。你要担心他看不懂代码吗？给你看两个东西吧&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1547369/202006/1547369-20200602230754567-1670929037.jpg&quot; alt=&quot;image-20200602220527438&quot;/&gt;&lt;/p&gt;
&lt;p&gt;你知道那个红框是啥意思吗？就是说我发现的那个有问题代码的类的作者就是他。&lt;/p&gt;
&lt;p&gt;再看一张&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1547369/202006/1547369-20200602230755394-830944080.jpg&quot; alt=&quot;image-20200602220833491&quot;/&gt;&lt;/p&gt;
&lt;p&gt;就是说，&lt;code&gt;jhoeller&lt;/code&gt;从2003年开始就已经是Spring这个项目的管理者以及发布经理了。2003年，我还是一个小学生........&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1547369/202006/1547369-20200602230755627-351736298.jpg&quot; alt=&quot;菜&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以啊，只要你稍微正常点，基本上人家都能get到你的点。&lt;/p&gt;

&lt;p&gt;其实笔者从发现这个问题到最终提交issue大概经过了一周时间，期间一直在犹豫要不要提交issue，就是因为上面提到的几个问题，一直踌躇不前。但是等我下定决心要去做这件事的时候总共就花了几个小时的时间。包括研究issue提交的规则以及写一篇英文版的issue。并且我提交issue的第二天就马上被处理了，并且&lt;code&gt;jhoeller&lt;/code&gt;在 &lt;a href=&quot;https://github.com/spring-projects/spring-framework/commit/f9aae8dd5a9a325fa9cb3f1a3b5e9081bbe91e65&quot;&gt;f9aae8d&lt;/a&gt; 这个commit中已经接受我的建议。&lt;/p&gt;
&lt;p&gt;所以我要说的就是，&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;真正动手的话，不管什么问题总能找到解决方案&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;而只是停留在空想，在踌躇，你永远有一堆问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;临渊羡鱼，不如退而结网&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以此文与君共勉！&lt;/p&gt;
&lt;p&gt;如果本文对你由帮助的话，记得点个赞吧！也欢迎关注我的公众号，微信搜索：程序员DMZ，或者扫描下方二维码，跟着我一起认认真真学Java,踏踏实实做一个coder。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1547369/202006/1547369-20200602230755804-1098131393.jpg&quot; alt=&quot;公众号&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我叫DMZ，一个在学习路上匍匐前行的小菜鸟！&lt;/p&gt;
&lt;blockquote readability=&quot;4.3661971830986&quot;&gt;
&lt;p&gt;本文由博客群发一文多发等运营工具平台 &lt;a href=&quot;https://openwrite.cn?from=article_bottom&quot;&gt;OpenWrite&lt;/a&gt; 发布&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Tue, 02 Jun 2020 15:08:00 +0000</pubDate>
<dc:creator>程序员DMZ</dc:creator>
<og:description>@(目录) 我的经历 关注我的朋友都知道，关注两个字划重点，要考！ 我最近一直在写Spring的文章，而且仅仅是Spring FrameWork的文章 ,从最开始的官网入门到现在源码的深度分析。主要就</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/daimzh/p/13034515.html</dc:identifier>
</item>
<item>
<title>带你学够浪：Go语言基础系列-环境配置和 Hello world - 柠檬橙1024</title>
<link>http://www.cnblogs.com/NanoDragon/p/12930177.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/NanoDragon/p/12930177.html</guid>
<description>&lt;p&gt;现在很多互联网公司都在转向 Golang 开发，所以打算写一写有关 Go 语言学习的系列文章，目标是从 Go 基础到进阶输出一系列文章，沉淀下这些知识同时也给大家做参考，力求做到通俗易懂，即使你是 `Golang` 小白也能看懂，如果你是老手也能温故知新。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;205.94566741447&quot;&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;文章每周持续更新，原创不易，「三连」让更多人看到是对我最大的肯定。可以微信搜索公众号「 后端技术学堂 」第一时间阅读（一般比博客早更新一到两篇）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;前面几周陆陆续续写了一些后端技术的文章，包括数据库、微服务、内存管理等等，我比较倾向于成体系的学习，所以数据库和微服务还有后续系列文章补充。&lt;/p&gt;
&lt;p&gt;最近工作上比较多的 Golang 编程，现在很多互联网公司都在转向 Golang 开发，所以打算写一写有关 Go 语言学习的系列文章，目标是从 Go 基础到进阶输出一系列文章，沉淀下这些知识同时也给大家做参考，力求做到通俗易懂，即使你是 &lt;code&gt;Golang&lt;/code&gt; 小白也能看懂，如果你是老手也能温故知新。&lt;/p&gt;
&lt;p&gt;本文将要和你分享 linux 下安装 Golang 环境，并且讲解如何通过配置 VSCode 远程开发调试 Golang 程序。&lt;/p&gt;
&lt;h2 id=&quot;下载源码&quot;&gt;下载源码&lt;/h2&gt;
&lt;p&gt;你可以用系统自带的包管理工具比如 &lt;code&gt;yum&lt;/code&gt; 或 &lt;code&gt;apt-get&lt;/code&gt; 来安装Golang开发环境。不过，为了通用性，我选择通过源码的方式来安装和讲解，在官网下载源码，下载地址 &lt;a href=&quot;https://golang.org/dl/&quot;&gt;https://golang.org/dl/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy83ODQyNDY0LTdiZDE4ZDMwZDNkOTJiODEucG5n?x-oss-process=image/format,png&quot; alt=&quot;官方下载界面.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;手动安装&quot;&gt;手动安装&lt;/h2&gt;
&lt;h3 id=&quot;解压安装&quot;&gt;解压安装&lt;/h3&gt;
&lt;p&gt;我这里下载下来的源码包 &lt;code&gt;go1.14.2.linux-amd64.tar.gz&lt;/code&gt; 放到远程 Linux 服务器目录下。执行以下命令安装到 /usr/local 目录。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;tar -zxvf -C /usr/local/ `go1.14.2.linux-amd64.tar.gz`
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;创建工作空间&quot;&gt;创建工作空间&lt;/h3&gt;
&lt;p&gt;工作空间是你Go项目的「工作目录」，挑选一个合适目录，执行下面操作：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;mkdir GoPath
mkdir -p GoPath/src
mkdir -p GoPath/bin
mkdir -p GoPath/pkg
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;三个目录含义：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-css&quot;&gt;  src: 源码路径（例如：.go、.c、.h、.s 等）
  pkg: 编译包时，生成的.a文件存放路径
  bin: 编译生成的可执行文件路径
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;配置环境变量&quot;&gt;配置环境变量&lt;/h3&gt;
&lt;p&gt;安装过程中有这么几个环境变量需要配置，先来了解一下：&lt;/p&gt;
&lt;p&gt;GOROOT：Go的安装路径，也就是前面我们解压到的目录 &lt;code&gt;/usr/local/go&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;GOBIN：Go项目的二进制文件存放目录。&lt;/p&gt;
&lt;p&gt;GOPATH：Go的工作空间。前面有介绍的工作空间目录。&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;/etc/profile&lt;/code&gt; 文件追加以下内容完成设置。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;export GOROOT=/usr/local/go
export GOPATH=/yourpath/GoPath # 设置你自己的GoPath路径 
export GOBIN=$GOPATH/bin
export PATH=$PATH:$GOROOT/bin  # 加入到PATH环境变量
export PATH=$PATH:$GOPATH/bin
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;# source /etc/profile #立即生效
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;验证安装&quot;&gt;验证安装&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;# go version  #检查版本
# go version go1.14.2 linux/amd64 # 输出版本号
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果看到版本信息就代表安装成功了！&lt;/p&gt;
&lt;h2 id=&quot;远程开发&quot;&gt;远程开发&lt;/h2&gt;
&lt;p&gt;上面我们在 Linux 环境下安装好了 Golang 开发环境，但我不想每次打开终端登录服务器编写调试程序，怎么才能在本地PC开发调试Golang程序呢？&lt;/p&gt;
&lt;p&gt;看过我上一篇Vscode远程开发的小伙伴应该能想到方法，我们就要用Vscode搭建Golang远程开发环境。具体的远程开发配置可以查看我的另一篇文章。&lt;/p&gt;
&lt;h3 id=&quot;golang开发插件&quot;&gt;Golang开发插件&lt;/h3&gt;
&lt;p&gt;首先安装官方推荐的 Go 开发插件，如下，点他安装。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy83ODQyNDY0LTEwZWRiNmEwODIzZTYzZDUucG5n?x-oss-process=image/format,png&quot; alt=&quot;Go插件&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接着还会出现如下的提示，是因为缺少其他 Go 开发相关插件，点 &lt;code&gt;install all&lt;/code&gt; 全都装上就行。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy83ODQyNDY0LTljZGRiYjE0YWY5YTFiNDMucG5n?x-oss-process=image/format,png&quot; alt=&quot;安装所有插件&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;hello-world&quot;&gt;Hello World&lt;/h2&gt;
&lt;p&gt;编程界有个惯例，什么语言开始学习都是从 Hello World 开始。现在，我们就用 Golang 编写第一个 &lt;code&gt;HelloWorld&lt;/code&gt; 程序吧。&lt;/p&gt;
&lt;p&gt;上代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;package main // 所有Go程序从main包开始运行

import &quot;fmt&quot; // 导入fmt包

func main() {
        fmt.Print(&quot;hello world&quot;, &quot; i am ready to go :)\n&quot;)
        fmt.Println(&quot;hello world&quot;, &quot;i am ready to go :)&quot;)
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;格式化-包&quot;&gt;格式化 包&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;fmt&lt;/code&gt; 实现了类似 C++/C 语言的格式IO库功能。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Print&lt;/code&gt; 和 &lt;code&gt;Println&lt;/code&gt; 都可用于打印输出，但是功能略有不同。可以看到我在&lt;code&gt;Print&lt;/code&gt; 函数中，对后一个字符串加了空格和换行符，这样两个打印出来的结果是相同的。&lt;/p&gt;
&lt;h3 id=&quot;print&quot;&gt;Print&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;func Print(a ...interface{}) (n int, err error)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Print采用默认格式将其参数格式化并写入标准输出。如果两个相邻的参数都不是字符串，会在它们的输出之间添加空格。返回写入的字节数和遇到的任何错误。&lt;/p&gt;
&lt;h3 id=&quot;println&quot;&gt;Println&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;func Println(a ...interface{}) (n int, err error)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Println采用默认格式将其参数格式化并写入标准输出。总是会在相邻参数的输出之间添加空格并在输出结束后添加换行符。返回写入的字节数和遇到的任何错误。&lt;/p&gt;
&lt;h2 id=&quot;调试&quot;&gt;调试&lt;/h2&gt;
&lt;h3 id=&quot;终端调试&quot;&gt;终端调试&lt;/h3&gt;
&lt;p&gt;在终端命令行源码所在目录输入&lt;code&gt;go run&lt;/code&gt; 运行程序。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;
# go run HelloWorld.go 
//输出
hello world i am ready to go :)
hello world i am ready to go :)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也可以先编译&lt;code&gt;go build&lt;/code&gt; 得到可执行文件后再运行。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;# go build HelloWorld.go 
# ls
HelloWorld  HelloWorld.go
# ./HelloWorld 
hello world i am ready to go :)
hello world i am ready to go :)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;vscode调试&quot;&gt;Vscode调试&lt;/h3&gt;
&lt;p&gt;按&lt;code&gt;F5&lt;/code&gt;启动调试，编辑与调试控制台输出如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy83ODQyNDY0LTFhNDBlZTFhODZmYjM0ZTIucG5n?x-oss-process=image/format,png&quot; alt=&quot;Vscode调试&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;命令行参数获取&quot;&gt;命令行参数获取&lt;/h2&gt;
&lt;p&gt;命令行参数可以通过&lt;code&gt;os&lt;/code&gt; 包的 &lt;code&gt;Args&lt;/code&gt; 函数获取，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;package main

import (
        &quot;fmt&quot;
        &quot;os&quot;
        &quot;strconv&quot;
)

func main() {
        // 命令行参数获取，os.Args第一个参数是程序自身
        fmt.Println(os.Args)
        for idx, args := range os.Args {
                fmt.Println(&quot;参数&quot;+strconv.Itoa(idx)+&quot;:&quot;, args)
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;终端设置&quot;&gt;终端设置&lt;/h3&gt;
&lt;p&gt;以下是带参数argv1 argv2 运行golang程序和输出。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;# go run basic.go argv1 argv2 

# 输出
[/tmp/go-build441686724/b001/exe/basic argv1 argv2]
参数0: /tmp/go-build441686724/b001/exe/basic
参数1: argv1
参数2: argv2
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;vscode设置&quot;&gt;VSCode设置&lt;/h3&gt;
&lt;p&gt;launch.json文件的 &lt;code&gt;args&lt;/code&gt; 属性配置可以设置程序启动调试的参数。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy83ODQyNDY0LWIwMDEzODhhNzAyZWIwOWYucG5n?x-oss-process=image/format,png&quot; alt=&quot;vscode命令行参数设置&quot;/&gt;&lt;/p&gt;
&lt;p&gt;设置之后，按&lt;code&gt;F5&lt;/code&gt; 启动调试，就会在调试控制台输出配置的参数。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy83ODQyNDY0LTRlM2QxMzJjMzQzMzc4ZmUucG5n?x-oss-process=image/format,png&quot; alt=&quot;vscode带参数调试输出&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;环境变量获取&quot;&gt;环境变量获取&lt;/h2&gt;
&lt;p&gt;命令行参数可以通过&lt;code&gt;os&lt;/code&gt; 包的 &lt;code&gt;Getenv&lt;/code&gt; 函数获取，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;package main

import (
        &quot;fmt&quot;
        &quot;os&quot;
)

func main() {
        // 获取环境变量
        fmt.Println(os.Getenv(&quot;type&quot;), os.Getenv(&quot;name&quot;), os.Getenv(&quot;GOROOT&quot;))
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;vscode设置环境变量&quot;&gt;VSCode设置环境变量&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;launch.json&lt;/code&gt; 文件的 &lt;code&gt;args&lt;/code&gt; 属性配置可以设置 VSCode 调试的 Golang 程序环境变量。&lt;/p&gt;
&lt;p&gt;设置的格式是：name:vaule 形式，注意都是字符串。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy83ODQyNDY0LWNlNWUxY2ZlZWUzOTZhMjQucG5n?x-oss-process=image/format,png&quot; alt=&quot;vscode环境变量设置&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;终端设置环境变量&quot;&gt;终端设置环境变量&lt;/h3&gt;
&lt;p&gt;终端的环境变量设置就是可以用 Linux 的 &lt;code&gt;export&lt;/code&gt; 命令设置，之后就可以用 &lt;code&gt;os.Getenv&lt;/code&gt; 函数读取。&lt;/p&gt;
&lt;p&gt;比如我们最初设置 &lt;code&gt;GOROOT&lt;/code&gt; 环境变量的命令&lt;/p&gt;
&lt;p&gt;&lt;code&gt;export GOROOT=/usr/local/go&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;就可以用 &lt;code&gt;os.Getenv(&quot;GOROOT&quot;)&lt;/code&gt; 读取，比较简单，这里就不多说了。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;现在，你有了一个可以远程开发调试 Golang 的环境，赶紧去写个 &lt;code&gt;hello world&lt;/code&gt; 体验一下吧！今天的分享就到这，下一篇文章讲解基础语法。&lt;/p&gt;
&lt;p&gt;老规矩，感谢各位的阅读，文章的目的是分享对知识的理解，技术类文章我都会反复求证以求最大程度保证准确性，若文中出现明显纰漏也欢迎指出，我们一起在探讨中学习。今天的技术分享就到这里，我们下期再见。&lt;/p&gt;
&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://studygolang.com/articles/17598&quot;&gt;设置GOPATH&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/acktomas/article/details/102851702&quot;&gt;Visual Studio Code变量参考&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://studygolang.com/articles/3387&quot;&gt;Golang 获取系统环境变量&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://studygolang.com/articles/21438&quot;&gt;os库获取命令行参数&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;原创不易，不想被白票，如果在我这有收获，就动动手指「点赞」和「转发」是对我持续创作的最大支持。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;可以微信搜索公众号「 后端技术学堂 」回复「资料」「1024」有我给你准备的各种编程学习资料。文章每周持续更新，我们下期见！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;</description>
<pubDate>Tue, 02 Jun 2020 15:04:00 +0000</pubDate>
<dc:creator>柠檬橙1024</dc:creator>
<og:description>现在很多互联网公司都在转向 Golang 开发，所以打算写一写有关 Go 语言学习的系列文章，目标是从 Go 基础到进阶输出一系列文章，沉淀下这些知识同时也给大家做参考，力求做到通俗易懂，即使你是 `</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/NanoDragon/p/12930177.html</dc:identifier>
</item>
</channel>
</rss>