<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>tomcat编译超过64k大小的jsp文件报错原因 - javahih</title>
<link>http://www.cnblogs.com/mzq123/p/10140889.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mzq123/p/10140889.html</guid>
<description>&lt;p&gt;今天遇到一个问题，首先是在tomcat中间件上跑的web项目，一个jsp文件，因为代码行数实在是太多了，更新了几个版本之后编译报错了，页面打开都是报500的错误，500的报错，知道http协议返回码的都知道，这是服务端的报错。&lt;/p&gt;
&lt;p&gt;jsp编译过程是先编译为servlet，然后再通过类加载器编译为.class文件，再执行为Servlet实例。这就是jsp的编译过程。所以jsp报500错误也可以理解，属于服务端的报错没什么好怀疑的。&lt;/p&gt;
&lt;p&gt;服务端报错，肯定就是去console拿日志了。从CONSOLE拿到日志关键信息：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;The code of method _jspService(HttpServletRequest, HttpServletResponse) is exceeding the 65535 bytes limit&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个报错意思大概是超过字节限制。通过网上资料搜索，很多地方都是给出了一个解决方法，不过大部分都没说明为什么。&lt;br/&gt;网上一大堆差不多的博客，都是这样说的，在tomcat的conf文件夹里，找到web.xml，然后在JspServlet的servlet配置里，加上mappedfile参数&lt;br/&gt;修改后的代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;servlet&amp;gt;
        &amp;lt;servlet-name&amp;gt;jsp&amp;lt;/servlet-name&amp;gt;
        &amp;lt;servlet-class&amp;gt;org.apache.jasper.servlet.JspServlet&amp;lt;/servlet-class&amp;gt;
        &amp;lt;init-param&amp;gt;
            &amp;lt;param-name&amp;gt;fork&amp;lt;/param-name&amp;gt;
            &amp;lt;param-value&amp;gt;false&amp;lt;/param-value&amp;gt;
        &amp;lt;/init-param&amp;gt;
        &amp;lt;init-param&amp;gt;
            &amp;lt;param-name&amp;gt;xpoweredBy&amp;lt;/param-name&amp;gt;
            &amp;lt;param-value&amp;gt;false&amp;lt;/param-value&amp;gt;
        &amp;lt;/init-param&amp;gt;
        &amp;lt;init-param&amp;gt;  
            &amp;lt;param-name&amp;gt;mappedfile&amp;lt;/param-name&amp;gt;  
            &amp;lt;param-value&amp;gt;false&amp;lt;/param-value&amp;gt;  
        &amp;lt;/init-param&amp;gt; 
        &amp;lt;load-on-startup&amp;gt;3&amp;lt;/load-on-startup&amp;gt;
    &amp;lt;/servlet&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其实也就是加上&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;init-param&amp;gt;  
           &amp;lt;param-name&amp;gt;mappedfile&amp;lt;/param-name&amp;gt;  
           &amp;lt;param-value&amp;gt;false&amp;lt;/param-value&amp;gt;  
 &amp;lt;/init-param&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;大部分博客并没有给出原因。不过还是可以解决问题的。不过网上所说的这种方法并不是很好的方法，只能说是暂缓之策。&lt;/p&gt;
&lt;p&gt;首先要从jsp的编译说起，jsp经过tomcat编译后，文件会保存在哪里？&lt;br/&gt;下面介绍一下，一般路径都会在${TOMCAT_HOME}\work\Catalina\localhost\项目名称\org\apache\jsp文件夹下面。&lt;br/&gt;假如新建了一个index.jsp，经过编译之后，都会在该路径下面生成index_jsp.java文件和index_jsp.class文件，index_jsp.java文件是什么？其实可以理解为tomcat编译生成的servlet类，index_jsp.class呢？当然就是servlet类编译之后生成的.class文件了。&lt;br/&gt;随便找个index_jsp.java文件，拿代码来看看：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/*
 * Generated by the Jasper component of Apache Tomcat
 * Version: Apache Tomcat/7.0.32
 * Generated at: 2016-11-19 03:26:12 UTC
 * Note: The last modified time of this file was set to
 *       the last modified time of the source file after
 *       generation to assist with modification tracking.
 */
package org.apache.jsp;

import javax.servlet.*;
import javax.servlet.http.*;
import javax.servlet.jsp.*;
import java.util.*;

public final class index_jsp extends org.apache.jasper.runtime.HttpJspBase
    implements org.apache.jasper.runtime.JspSourceDependent {

  private static final javax.servlet.jsp.JspFactory _jspxFactory =
          javax.servlet.jsp.JspFactory.getDefaultFactory();

  private static java.util.Map&amp;lt;java.lang.String,java.lang.Long&amp;gt; _jspx_dependants;

  private javax.el.ExpressionFactory _el_expressionfactory;
  private org.apache.tomcat.InstanceManager _jsp_instancemanager;

  public java.util.Map&amp;lt;java.lang.String,java.lang.Long&amp;gt; getDependants() {
    return _jspx_dependants;
  }

  public void _jspInit() {
    _el_expressionfactory = _jspxFactory.getJspApplicationContext(getServletConfig().getServletContext()).getExpressionFactory();
    _jsp_instancemanager = org.apache.jasper.runtime.InstanceManagerFactory.getInstanceManager(getServletConfig());
  }

  public void _jspDestroy() {
  }

  public void _jspService(final javax.servlet.http.HttpServletRequest request, final javax.servlet.http.HttpServletResponse response)
        throws java.io.IOException, javax.servlet.ServletException {

    final javax.servlet.jsp.PageContext pageContext;
    javax.servlet.http.HttpSession session = null;
    final javax.servlet.ServletContext application;
    final javax.servlet.ServletConfig config;
    javax.servlet.jsp.JspWriter out = null;
    final java.lang.Object page = this;
    javax.servlet.jsp.JspWriter _jspx_out = null;
    javax.servlet.jsp.PageContext _jspx_page_context = null;


    try {
      response.setContentType(&quot;text/html;charset=UTF-8&quot;);
      pageContext = _jspxFactory.getPageContext(this, request, response,
                null, true, 8192, true);
      _jspx_page_context = pageContext;
      application = pageContext.getServletContext();
      config = pageContext.getServletConfig();
      session = pageContext.getSession();
      out = pageContext.getOut();
      _jspx_out = out;

      out.write('\r');
      out.write('\n');
      if (true) {
        _jspx_page_context.forward(&quot;/login_toLogin&quot;);
        return;
      }
      out.write('\r');
      out.write('\n');
    } catch (java.lang.Throwable t) {
      if (!(t instanceof javax.servlet.jsp.SkipPageException)){
        out = _jspx_out;
        if (out != null &amp;amp;&amp;amp; out.getBufferSize() != 0)
          try { out.clearBuffer(); } catch (java.io.IOException e) {}
        if (_jspx_page_context != null) _jspx_page_context.handlePageException(t);
        else throw new ServletException(t);
      }
    } finally {
      _jspxFactory.releasePageContext(_jspx_page_context);
    }
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从代码可以看出，类继承于HttpJspBase类实现JspSourceDependent接口，先看一下HttpJspBase类，这个类从哪来的呢？HttpJspBase是tomcat库提供的，所以拿tomcat库的源码来看看，在${TOMCAT_HOME}/lib里找到价包jasper.jar,反编译代码，找到HttpJspBase类&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package org.apache.jasper.runtime;

import java.io.IOException;
import javax.servlet.ServletConfig;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.jsp.HttpJspPage;
import org.apache.jasper.compiler.Localizer;

public abstract class HttpJspBase extends HttpServlet
  implements HttpJspPage
{
  private static final long serialVersionUID = 1L;

  public final void init(ServletConfig config)
    throws ServletException
  {
    super.init(config);
    jspInit();
    _jspInit();
  }

  public String getServletInfo()
  {
    return Localizer.getMessage(&quot;jsp.engine.info&quot;);
  }

  public final void destroy()
  {
    jspDestroy();
    _jspDestroy();
  }

  public final void service(HttpServletRequest request, HttpServletResponse response)
    throws ServletException, IOException
  {
    _jspService(request, response);
  }

  public void jspInit()
  {
  }

  public void _jspInit()
  {
  }

  public void jspDestroy()
  {
  }

  protected void _jspDestroy()
  {
  }

  public abstract void _jspService(HttpServletRequest paramHttpServletRequest, HttpServletResponse paramHttpServletResponse)
    throws ServletException, IOException;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码并不是说多复杂，HttpJspBase类继承HttpServlet类，实现HttpJspPage接口，也就是说HttpJspBase重写了HttpServlet的service(),init()等等方法，HttpServlet，我们就很熟悉了。HttpJspPage又是什么?看它的包名，马上知道它是jdk提供的接口，马上找到它的代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/*
 * The contents of this file are subject to the terms
 * of the Common Development and Distribution License
 * (the &quot;License&quot;).  You may not use this file except
 * in compliance with the License.
 *
 * You can obtain a copy of the license at
 * glassfish/bootstrap/legal/CDDLv1.0.txt or
 * https://glassfish.dev.java.net/public/CDDLv1.0.html.
 * See the License for the specific language governing
 * permissions and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL
 * HEADER in each file and include the License file at
 * glassfish/bootstrap/legal/CDDLv1.0.txt.  If applicable,
 * add the following below this CDDL HEADER, with the
 * fields enclosed by brackets &quot;[]&quot; replaced with your
 * own identifying information: Portions Copyright [yyyy]
 * [name of copyright owner]
 *
 * Copyright 2005 Sun Microsystems, Inc. All rights reserved.
 *
 * Portions Copyright Apache Software Foundation.
 */
 
package javax.servlet.jsp;

import javax.servlet.*;
import javax.servlet.http.*;
import java.io.IOException;

/**
 * The HttpJspPage interface describes the interaction that a JSP Page
 * Implementation Class must satisfy when using the HTTP protocol.
 *
 * &amp;lt;p&amp;gt;
 * The behaviour is identical to that of the JspPage, except for the signature
 * of the _jspService method, which is now expressible in the Java type
 * system and included explicitly in the interface.
 * 
 * @see JspPage
 */

public interface HttpJspPage extends JspPage {

    /** The _jspService()method corresponds to the body of the JSP page. This
     * method is defined automatically by the JSP container and should never
     * be defined by the JSP page author.
     * &amp;lt;p&amp;gt;
     * If a superclass is specified using the extends attribute, that
     * superclass may choose to perform some actions in its service() method
     * before or after calling the _jspService() method.  See using the extends
     * attribute in the JSP_Engine chapter of the JSP specification.
     *
     * @param request Provides client request information to the JSP.
     * @param response Assists the JSP in sending a response to the client.
     * @throws ServletException Thrown if an error occurred during the 
     *     processing of the JSP and that the container should take 
     *     appropriate action to clean up the request.
     * @throws IOException Thrown if an error occurred while writing the
     *     response for this page.
     */
    public void _jspService(HttpServletRequest request,
                            HttpServletResponse response)
       throws ServletException, IOException;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;**很关键的方法名：_jspService，不就是刚才CONSOLE报错提示的方法名？&lt;br/&gt;也就是说jdk提供接口，然后tomcat对接口进行实现，我们知道Java内存模型(JMM)规定了一个方法的大小只能是64k，所以，从刚才的报错，我们简单从源码分析了一下，报错的原因其实就是jsp反编译为Servlet之后，代码要经过_jspService这个方法，这个方法超过了64k，导致报错。**&lt;/p&gt;
&lt;p&gt;查看一下tomcat7官方给出的文档：http://tomcat.apache.org/tomcat-7.0-doc/jasper-howto.html#Configuration&lt;br/&gt;找到mappedfile属性的意思&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;mappedfile - 我们是否应该为每个输入行生成一个print语句的静态内容，以便于调试？ true或者false，默认true。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;现在分析一下具体原因。代码报错的原因就是因为jsp编译为Servlet之后，经过_jspService这个方法，方法超过64k导致报错。然后通过设置mappedfile参数的原因是尽量减少print代码，暂时使代码不超过，也就是说只是一种暂缓的方法。网上资料说通过&lt;/p&gt;
</description>
<pubDate>Tue, 18 Dec 2018 15:46:00 +0000</pubDate>
<dc:creator>javahih</dc:creator>
<og:description>今天遇到一个问题，首先是在tomcat中间件上跑的web项目，一个jsp文件，因为代码行数实在是太多了，更新了几个版本之后编译报错了，页面打开都是报500的错误，500的报错，知道http协议返回码的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mzq123/p/10140889.html</dc:identifier>
</item>
<item>
<title>.net core 的图片处理及二维码的生成及解析 - 如兹</title>
<link>http://www.cnblogs.com/ruzi/p/10140754.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ruzi/p/10140754.html</guid>
<description>&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ImageHelper
&lt;/span&gt;&lt;span&gt;  2&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;  3&lt;/span&gt;         &lt;span&gt;static&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; maxLength = &lt;span&gt;10485760&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;10*1024*1024&lt;/span&gt;
&lt;span&gt;  4&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; SkiaSharp.SKEncodedImageFormat GetImageFormatBySuffix(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; suffix)
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; format =&lt;span&gt; SkiaSharp.SKEncodedImageFormat.Jpeg;
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrEmpty(suffix))
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; format;
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (suffix[&lt;span&gt;0&lt;/span&gt;] == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt;                 suffix = suffix.Substring(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrEmpty(suffix))
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; format;
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt;             suffix =&lt;span&gt; suffix.ToUpper();
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt;             &lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (suffix)
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;PNG&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt;                     format =&lt;span&gt; SkiaSharp.SKEncodedImageFormat.Png;
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;GIF&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt;                     format =&lt;span&gt; SkiaSharp.SKEncodedImageFormat.Gif;
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;BMP&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt;                     format =&lt;span&gt; SkiaSharp.SKEncodedImageFormat.Bmp;
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ICON&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt;                     format =&lt;span&gt; SkiaSharp.SKEncodedImageFormat.Ico;
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ICO&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt;                     format =&lt;span&gt; SkiaSharp.SKEncodedImageFormat.Ico;
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DNG&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt;                     format =&lt;span&gt; SkiaSharp.SKEncodedImageFormat.Dng;
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;WBMP&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt;                     format =&lt;span&gt; SkiaSharp.SKEncodedImageFormat.Wbmp;
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;WEBP&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt;                     format =&lt;span&gt; SkiaSharp.SKEncodedImageFormat.Webp;
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;PKM&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt;                     format =&lt;span&gt; SkiaSharp.SKEncodedImageFormat.Pkm;
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;KTX&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt;                     format =&lt;span&gt; SkiaSharp.SKEncodedImageFormat.Ktx;
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ASTC&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt;                     format =&lt;span&gt; SkiaSharp.SKEncodedImageFormat.Astc;
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; format;
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; SkiaSharp.SKEncodedImageFormat GetImageFormatByPath(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; path)
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; suffix = &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (System.IO.Path.HasExtension(path))
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt;                 suffix =&lt;span&gt; System.IO.Path.GetExtension(path);
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; GetImageFormatBySuffix(suffix);
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Tuple&amp;lt;&lt;span&gt;int&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;, &lt;span&gt;long&lt;/span&gt;, SkiaSharp.SKEncodedImageFormat&amp;gt; GetImageInfo(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; path)
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrEmpty(path))
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt;                 &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Exception(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;路径不能为空&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;System.IO.File.Exists(path))
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt;                 &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Exception(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;文件不存在&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; fileStream = &lt;span&gt;new&lt;/span&gt; System.IO.FileStream(path, System.IO.FileMode.Open, System.IO.FileAccess.Read, System.IO.FileShare.Read); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;fileInfo.OpenRead();&lt;/span&gt;
&lt;span&gt; 78&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; fileLength =&lt;span&gt; fileStream.Length;
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (fileLength &amp;gt;&lt;span&gt; maxLength)
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt; &lt;span&gt;                fileStream.Dispose();
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt;                 &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Exception(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;文件过大&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; sKManagedStream = &lt;span&gt;new&lt;/span&gt; SkiaSharp.SKManagedStream(fileStream, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; sKBitmap =&lt;span&gt; SkiaSharp.SKBitmap.Decode(sKManagedStream);
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt; &lt;span&gt;            sKManagedStream.Dispose();
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt; 
&lt;span&gt; 88&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (sKBitmap.IsEmpty)
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt; &lt;span&gt;                sKBitmap.Dispose();
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt;                 &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Exception(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;文件无效&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; w =&lt;span&gt; sKBitmap.Width;
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; h =&lt;span&gt; sKBitmap.Height;
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Tuple&amp;lt;&lt;span&gt;int&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;, &lt;span&gt;long&lt;/span&gt;, SkiaSharp.SKEncodedImageFormat&amp;gt;&lt;span&gt;(w, h, fileLength, GetImageFormatByPath(path));
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; ImageMaxCutByCenter(&lt;span&gt;string&lt;/span&gt; path, &lt;span&gt;string&lt;/span&gt; savePath, &lt;span&gt;int&lt;/span&gt; saveWidth, &lt;span&gt;int&lt;/span&gt; saveHeight, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; quality)
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; bytes =&lt;span&gt; ImageMaxCutByCenter(path, saveWidth, saveHeight, quality);
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (bytes == &lt;span&gt;null&lt;/span&gt; || bytes.Length &amp;lt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt;             &lt;span&gt;string&lt;/span&gt; saveDirPath =&lt;span&gt; System.IO.Path.GetDirectoryName(savePath);
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;System.IO.Directory.Exists(saveDirPath))
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt; &lt;span&gt;                System.IO.Directory.CreateDirectory(saveDirPath);
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt;             System.IO.FileStream fs = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; System.IO.FileStream(savePath, System.IO.FileMode.OpenOrCreate, System.IO.FileAccess.Write, System.IO.FileShare.None);
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt;             fs.Write(bytes, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, bytes.Length);
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt; &lt;span&gt;            fs.Close();
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[] ImageMaxCutByCenter(&lt;span&gt;string&lt;/span&gt; path, &lt;span&gt;int&lt;/span&gt; saveWidth, &lt;span&gt;int&lt;/span&gt; saveHeight, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; quality)
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;115&lt;/span&gt;             &lt;span&gt;byte&lt;/span&gt;[] bytes = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;116&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;System.IO.File.Exists(path))
&lt;/span&gt;&lt;span&gt;117&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;118&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; bytes;
&lt;/span&gt;&lt;span&gt;119&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;120&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; fileStream = &lt;span&gt;new&lt;/span&gt; System.IO.FileStream(path, System.IO.FileMode.Open, System.IO.FileAccess.Read, System.IO.FileShare.Read); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;fileInfo.OpenRead();&lt;/span&gt;
&lt;span&gt;121&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (fileStream.Length &amp;gt;&lt;span&gt; maxLength)
&lt;/span&gt;&lt;span&gt;122&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;123&lt;/span&gt; &lt;span&gt;                fileStream.Dispose();
&lt;/span&gt;&lt;span&gt;124&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; bytes;
&lt;/span&gt;&lt;span&gt;125&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;126&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; sKManagedStream = &lt;span&gt;new&lt;/span&gt; SkiaSharp.SKManagedStream(fileStream, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;127&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; sKBitmap =&lt;span&gt; SkiaSharp.SKBitmap.Decode(sKManagedStream);
&lt;/span&gt;&lt;span&gt;128&lt;/span&gt; &lt;span&gt;            sKManagedStream.Dispose();
&lt;/span&gt;&lt;span&gt;129&lt;/span&gt; 
&lt;span&gt;130&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (sKBitmap.IsEmpty)
&lt;/span&gt;&lt;span&gt;131&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;132&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; bytes;
&lt;/span&gt;&lt;span&gt;133&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;134&lt;/span&gt; 
&lt;span&gt;135&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (saveWidth &amp;lt; &lt;span&gt;1&lt;/span&gt;) { saveWidth = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt;136&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (saveHeight &amp;lt; &lt;span&gt;1&lt;/span&gt;) { saveHeight = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt;137&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (quality &amp;lt; &lt;span&gt;1&lt;/span&gt;) { quality = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt;138&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (quality &amp;gt; &lt;span&gt;100&lt;/span&gt;) { quality = &lt;span&gt;100&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt;139&lt;/span&gt; 
&lt;span&gt;140&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; oW =&lt;span&gt; sKBitmap.Width;
&lt;/span&gt;&lt;span&gt;141&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; oH =&lt;span&gt; sKBitmap.Height;
&lt;/span&gt;&lt;span&gt;142&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; cutW =&lt;span&gt; saveWidth;
&lt;/span&gt;&lt;span&gt;143&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; cutH =&lt;span&gt; saveHeight;
&lt;/span&gt;&lt;span&gt;144&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; ratio = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;145&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (cutW &amp;gt;&lt;span&gt; oW)
&lt;/span&gt;&lt;span&gt;146&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;147&lt;/span&gt;                 ratio = (&lt;span&gt;double&lt;/span&gt;)oW / (&lt;span&gt;double&lt;/span&gt;&lt;span&gt;)cutW;
&lt;/span&gt;&lt;span&gt;148&lt;/span&gt;                 cutH = Convert.ToInt32((&lt;span&gt;double&lt;/span&gt;)cutH *&lt;span&gt; ratio);
&lt;/span&gt;&lt;span&gt;149&lt;/span&gt;                 cutW =&lt;span&gt; oW;
&lt;/span&gt;&lt;span&gt;150&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (cutH &amp;gt;&lt;span&gt; oH)
&lt;/span&gt;&lt;span&gt;151&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;152&lt;/span&gt;                     ratio = (&lt;span&gt;double&lt;/span&gt;)oH / (&lt;span&gt;double&lt;/span&gt;&lt;span&gt;)cutH;
&lt;/span&gt;&lt;span&gt;153&lt;/span&gt;                     cutW = Convert.ToInt32((&lt;span&gt;double&lt;/span&gt;)cutW *&lt;span&gt; ratio);
&lt;/span&gt;&lt;span&gt;154&lt;/span&gt;                     cutH =&lt;span&gt; oH;
&lt;/span&gt;&lt;span&gt;155&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;156&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;157&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (cutW &amp;lt;&lt;span&gt; oW)
&lt;/span&gt;&lt;span&gt;158&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;159&lt;/span&gt;                 ratio = (&lt;span&gt;double&lt;/span&gt;)oW / (&lt;span&gt;double&lt;/span&gt;&lt;span&gt;)cutW;
&lt;/span&gt;&lt;span&gt;160&lt;/span&gt;                 cutH = Convert.ToInt32(Convert.ToDouble(cutH) *&lt;span&gt; ratio);
&lt;/span&gt;&lt;span&gt;161&lt;/span&gt;                 cutW =&lt;span&gt; oW;
&lt;/span&gt;&lt;span&gt;162&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (cutH &amp;gt;&lt;span&gt; oH)
&lt;/span&gt;&lt;span&gt;163&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;164&lt;/span&gt;                     ratio = (&lt;span&gt;double&lt;/span&gt;)oH / (&lt;span&gt;double&lt;/span&gt;&lt;span&gt;)cutH;
&lt;/span&gt;&lt;span&gt;165&lt;/span&gt;                     cutW = Convert.ToInt32((&lt;span&gt;double&lt;/span&gt;)cutW *&lt;span&gt; ratio);
&lt;/span&gt;&lt;span&gt;166&lt;/span&gt;                     cutH =&lt;span&gt; oH;
&lt;/span&gt;&lt;span&gt;167&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;168&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;169&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;170&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;171&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (cutH &amp;gt;&lt;span&gt; oH)
&lt;/span&gt;&lt;span&gt;172&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;173&lt;/span&gt;                     ratio = (&lt;span&gt;double&lt;/span&gt;)oH / (&lt;span&gt;double&lt;/span&gt;&lt;span&gt;)cutH;
&lt;/span&gt;&lt;span&gt;174&lt;/span&gt;                     cutW = Convert.ToInt32((&lt;span&gt;double&lt;/span&gt;)cutW *&lt;span&gt; ratio);
&lt;/span&gt;&lt;span&gt;175&lt;/span&gt;                     cutH =&lt;span&gt; oH;
&lt;/span&gt;&lt;span&gt;176&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;177&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;178&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; startX = oW &amp;gt; cutW ? (oW / &lt;span&gt;2&lt;/span&gt; - cutW / &lt;span&gt;2&lt;/span&gt;) : (cutW / &lt;span&gt;2&lt;/span&gt; - oW / &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;179&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; startY = oH &amp;gt; cutH ? (oH / &lt;span&gt;2&lt;/span&gt; - cutH / &lt;span&gt;2&lt;/span&gt;) : (cutH / &lt;span&gt;2&lt;/span&gt; - oH / &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;180&lt;/span&gt; 
&lt;span&gt;181&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; sKBitmap2 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SkiaSharp.SKBitmap(saveWidth, saveHeight);
&lt;/span&gt;&lt;span&gt;182&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; sKCanvas = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SkiaSharp.SKCanvas(sKBitmap2);
&lt;/span&gt;&lt;span&gt;183&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; sKPaint = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SkiaSharp.SKPaint
&lt;/span&gt;&lt;span&gt;184&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;185&lt;/span&gt;                 FilterQuality =&lt;span&gt; SkiaSharp.SKFilterQuality.Medium,
&lt;/span&gt;&lt;span&gt;186&lt;/span&gt;                 IsAntialias = &lt;span&gt;true&lt;/span&gt;
&lt;span&gt;187&lt;/span&gt; &lt;span&gt;            };
&lt;/span&gt;&lt;span&gt;188&lt;/span&gt; &lt;span&gt;            sKCanvas.DrawBitmap(
&lt;/span&gt;&lt;span&gt;189&lt;/span&gt; &lt;span&gt;                sKBitmap,
&lt;/span&gt;&lt;span&gt;190&lt;/span&gt;                 &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SkiaSharp.SKRect
&lt;/span&gt;&lt;span&gt;191&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;192&lt;/span&gt;                     Location = &lt;span&gt;new&lt;/span&gt; SkiaSharp.SKPoint { X = startX, Y =&lt;span&gt; startY },
&lt;/span&gt;&lt;span&gt;193&lt;/span&gt;                     Size = &lt;span&gt;new&lt;/span&gt; SkiaSharp.SKSize { Height = cutH, Width =&lt;span&gt; cutW }
&lt;/span&gt;&lt;span&gt;194&lt;/span&gt; &lt;span&gt;                },
&lt;/span&gt;&lt;span&gt;195&lt;/span&gt;                 &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SkiaSharp.SKRect
&lt;/span&gt;&lt;span&gt;196&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;197&lt;/span&gt;                     Location = &lt;span&gt;new&lt;/span&gt; SkiaSharp.SKPoint { X = &lt;span&gt;0&lt;/span&gt;, Y = &lt;span&gt;0&lt;/span&gt;&lt;span&gt; },
&lt;/span&gt;&lt;span&gt;198&lt;/span&gt;                     Size = &lt;span&gt;new&lt;/span&gt; SkiaSharp.SKSize { Height = saveHeight, Width =&lt;span&gt; saveWidth }
&lt;/span&gt;&lt;span&gt;199&lt;/span&gt; &lt;span&gt;                }, sKPaint);
&lt;/span&gt;&lt;span&gt;200&lt;/span&gt; &lt;span&gt;            sKCanvas.Dispose();
&lt;/span&gt;&lt;span&gt;201&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; sKImage2 =&lt;span&gt; SkiaSharp.SKImage.FromBitmap(sKBitmap2);
&lt;/span&gt;&lt;span&gt;202&lt;/span&gt; &lt;span&gt;            sKBitmap2.Dispose();
&lt;/span&gt;&lt;span&gt;203&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; data =&lt;span&gt; sKImage2.Encode(GetImageFormatByPath(path), quality);
&lt;/span&gt;&lt;span&gt;204&lt;/span&gt; &lt;span&gt;            sKImage2.Dispose();
&lt;/span&gt;&lt;span&gt;205&lt;/span&gt;             bytes =&lt;span&gt; data.ToArray();
&lt;/span&gt;&lt;span&gt;206&lt;/span&gt; &lt;span&gt;            data.Dispose();
&lt;/span&gt;&lt;span&gt;207&lt;/span&gt; 
&lt;span&gt;208&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; bytes;
&lt;/span&gt;&lt;span&gt;209&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;210&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; ImageScalingToRange(&lt;span&gt;string&lt;/span&gt; path, &lt;span&gt;string&lt;/span&gt; savePath, &lt;span&gt;int&lt;/span&gt; maxWidth, &lt;span&gt;int&lt;/span&gt; maxHeight, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; quality)
&lt;/span&gt;&lt;span&gt;211&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;212&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; bytes =&lt;span&gt; ImageScalingToRange(path, maxWidth, maxHeight, quality);
&lt;/span&gt;&lt;span&gt;213&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (bytes == &lt;span&gt;null&lt;/span&gt; || bytes.Length &amp;lt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;214&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;215&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;216&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;217&lt;/span&gt;             &lt;span&gt;string&lt;/span&gt; saveDirPath =&lt;span&gt; System.IO.Path.GetDirectoryName(savePath);
&lt;/span&gt;&lt;span&gt;218&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;System.IO.Directory.Exists(saveDirPath))
&lt;/span&gt;&lt;span&gt;219&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;220&lt;/span&gt; &lt;span&gt;                System.IO.Directory.CreateDirectory(saveDirPath);
&lt;/span&gt;&lt;span&gt;221&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;222&lt;/span&gt;             System.IO.FileStream fs = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; System.IO.FileStream(savePath, System.IO.FileMode.OpenOrCreate, System.IO.FileAccess.Write, System.IO.FileShare.None);
&lt;/span&gt;&lt;span&gt;223&lt;/span&gt;             fs.Write(bytes, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, bytes.Length);
&lt;/span&gt;&lt;span&gt;224&lt;/span&gt; &lt;span&gt;            fs.Close();
&lt;/span&gt;&lt;span&gt;225&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;226&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[] ImageScalingToRange(&lt;span&gt;string&lt;/span&gt; path, &lt;span&gt;int&lt;/span&gt; maxWidth, &lt;span&gt;int&lt;/span&gt; maxHeight, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; quality)
&lt;/span&gt;&lt;span&gt;227&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;228&lt;/span&gt;             &lt;span&gt;byte&lt;/span&gt;[] bytes = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;229&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;System.IO.File.Exists(path))
&lt;/span&gt;&lt;span&gt;230&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;231&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; bytes;
&lt;/span&gt;&lt;span&gt;232&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;233&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; fileStream = &lt;span&gt;new&lt;/span&gt; System.IO.FileStream(path, System.IO.FileMode.Open, System.IO.FileAccess.Read, System.IO.FileShare.Read); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;fileInfo.OpenRead();&lt;/span&gt;
&lt;span&gt;234&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (fileStream.Length &amp;gt;&lt;span&gt; maxLength)
&lt;/span&gt;&lt;span&gt;235&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;236&lt;/span&gt; &lt;span&gt;                fileStream.Dispose();
&lt;/span&gt;&lt;span&gt;237&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; bytes;
&lt;/span&gt;&lt;span&gt;238&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;239&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; sKManagedStream = &lt;span&gt;new&lt;/span&gt; SkiaSharp.SKManagedStream(fileStream, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;240&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; sKBitmap =&lt;span&gt; SkiaSharp.SKBitmap.Decode(sKManagedStream);
&lt;/span&gt;&lt;span&gt;241&lt;/span&gt; &lt;span&gt;            sKManagedStream.Dispose();
&lt;/span&gt;&lt;span&gt;242&lt;/span&gt; 
&lt;span&gt;243&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (sKBitmap.IsEmpty)
&lt;/span&gt;&lt;span&gt;244&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;245&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; bytes;
&lt;/span&gt;&lt;span&gt;246&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;247&lt;/span&gt; 
&lt;span&gt;248&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (maxWidth &amp;lt; &lt;span&gt;1&lt;/span&gt;) { maxWidth = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt;249&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (maxHeight &amp;lt; &lt;span&gt;1&lt;/span&gt;) { maxHeight = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt;250&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (quality &amp;lt; &lt;span&gt;1&lt;/span&gt;) { quality = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt;251&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (quality &amp;gt; &lt;span&gt;100&lt;/span&gt;) { quality = &lt;span&gt;100&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt;252&lt;/span&gt; 
&lt;span&gt;253&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; oW =&lt;span&gt; sKBitmap.Width;
&lt;/span&gt;&lt;span&gt;254&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; oH =&lt;span&gt; sKBitmap.Height;
&lt;/span&gt;&lt;span&gt;255&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; nW =&lt;span&gt; oW;
&lt;/span&gt;&lt;span&gt;256&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; nH =&lt;span&gt; oH;
&lt;/span&gt;&lt;span&gt;257&lt;/span&gt; 
&lt;span&gt;258&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (nW &amp;lt; maxWidth &amp;amp;&amp;amp; nH &amp;lt; maxHeight)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;放大&lt;/span&gt;
&lt;span&gt;259&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;260&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (nW &amp;lt;&lt;span&gt; maxWidth)
&lt;/span&gt;&lt;span&gt;261&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;262&lt;/span&gt;                     &lt;span&gt;var&lt;/span&gt; r = (&lt;span&gt;double&lt;/span&gt;)maxWidth / (&lt;span&gt;double&lt;/span&gt;&lt;span&gt;)nW;
&lt;/span&gt;&lt;span&gt;263&lt;/span&gt;                     nW =&lt;span&gt; maxWidth;
&lt;/span&gt;&lt;span&gt;264&lt;/span&gt;                     nH = (&lt;span&gt;int&lt;/span&gt;)Math.Floor((&lt;span&gt;double&lt;/span&gt;)nH *&lt;span&gt; r);
&lt;/span&gt;&lt;span&gt;265&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;266&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (nH &amp;lt;&lt;span&gt; maxHeight)
&lt;/span&gt;&lt;span&gt;267&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;268&lt;/span&gt;                     &lt;span&gt;var&lt;/span&gt; r = (&lt;span&gt;double&lt;/span&gt;)maxHeight / (&lt;span&gt;double&lt;/span&gt;&lt;span&gt;)nH;
&lt;/span&gt;&lt;span&gt;269&lt;/span&gt;                     nH =&lt;span&gt; maxHeight;
&lt;/span&gt;&lt;span&gt;270&lt;/span&gt;                     nW = (&lt;span&gt;int&lt;/span&gt;)Math.Floor((&lt;span&gt;double&lt;/span&gt;)nW *&lt;span&gt; r);
&lt;/span&gt;&lt;span&gt;271&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;272&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;273&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;限制超出(缩小)&lt;/span&gt;
&lt;span&gt;274&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (nW &amp;gt;&lt;span&gt; maxWidth)
&lt;/span&gt;&lt;span&gt;275&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;276&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; r = (&lt;span&gt;double&lt;/span&gt;)maxWidth / (&lt;span&gt;double&lt;/span&gt;&lt;span&gt;)nW;
&lt;/span&gt;&lt;span&gt;277&lt;/span&gt;                 nW =&lt;span&gt; maxWidth;
&lt;/span&gt;&lt;span&gt;278&lt;/span&gt;                 nH = (&lt;span&gt;int&lt;/span&gt;)Math.Floor((&lt;span&gt;double&lt;/span&gt;)nH *&lt;span&gt; r);
&lt;/span&gt;&lt;span&gt;279&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;280&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (nH &amp;gt;&lt;span&gt; maxHeight)
&lt;/span&gt;&lt;span&gt;281&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;282&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; r = (&lt;span&gt;double&lt;/span&gt;)maxHeight / (&lt;span&gt;double&lt;/span&gt;&lt;span&gt;)nH;
&lt;/span&gt;&lt;span&gt;283&lt;/span&gt;                 nH =&lt;span&gt; maxHeight;
&lt;/span&gt;&lt;span&gt;284&lt;/span&gt;                 nW = (&lt;span&gt;int&lt;/span&gt;)Math.Floor((&lt;span&gt;double&lt;/span&gt;)nW *&lt;span&gt; r);
&lt;/span&gt;&lt;span&gt;285&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;286&lt;/span&gt; 
&lt;span&gt;287&lt;/span&gt; 
&lt;span&gt;288&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; sKBitmap2 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SkiaSharp.SKBitmap(nW, nH);
&lt;/span&gt;&lt;span&gt;289&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; sKCanvas = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SkiaSharp.SKCanvas(sKBitmap2);
&lt;/span&gt;&lt;span&gt;290&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; sKPaint = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SkiaSharp.SKPaint
&lt;/span&gt;&lt;span&gt;291&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;292&lt;/span&gt;                 FilterQuality =&lt;span&gt; SkiaSharp.SKFilterQuality.Medium,
&lt;/span&gt;&lt;span&gt;293&lt;/span&gt;                 IsAntialias = &lt;span&gt;true&lt;/span&gt;
&lt;span&gt;294&lt;/span&gt; &lt;span&gt;            };
&lt;/span&gt;&lt;span&gt;295&lt;/span&gt; &lt;span&gt;            sKCanvas.DrawBitmap(
&lt;/span&gt;&lt;span&gt;296&lt;/span&gt; &lt;span&gt;                sKBitmap,
&lt;/span&gt;&lt;span&gt;297&lt;/span&gt;                 &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SkiaSharp.SKRect
&lt;/span&gt;&lt;span&gt;298&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;299&lt;/span&gt;                     Location = &lt;span&gt;new&lt;/span&gt; SkiaSharp.SKPoint { X = &lt;span&gt;0&lt;/span&gt;, Y = &lt;span&gt;0&lt;/span&gt;&lt;span&gt; },
&lt;/span&gt;&lt;span&gt;300&lt;/span&gt;                     Size = &lt;span&gt;new&lt;/span&gt; SkiaSharp.SKSize { Height = oH, Width =&lt;span&gt; oW }
&lt;/span&gt;&lt;span&gt;301&lt;/span&gt; &lt;span&gt;                },
&lt;/span&gt;&lt;span&gt;302&lt;/span&gt;                 &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SkiaSharp.SKRect
&lt;/span&gt;&lt;span&gt;303&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;304&lt;/span&gt;                     Location = &lt;span&gt;new&lt;/span&gt; SkiaSharp.SKPoint { X = &lt;span&gt;0&lt;/span&gt;, Y = &lt;span&gt;0&lt;/span&gt;&lt;span&gt; },
&lt;/span&gt;&lt;span&gt;305&lt;/span&gt;                     Size = &lt;span&gt;new&lt;/span&gt; SkiaSharp.SKSize { Height = nH, Width =&lt;span&gt; nW }
&lt;/span&gt;&lt;span&gt;306&lt;/span&gt; &lt;span&gt;                }, sKPaint);
&lt;/span&gt;&lt;span&gt;307&lt;/span&gt; &lt;span&gt;            sKCanvas.Dispose();
&lt;/span&gt;&lt;span&gt;308&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; sKImage2 =&lt;span&gt; SkiaSharp.SKImage.FromBitmap(sKBitmap2);
&lt;/span&gt;&lt;span&gt;309&lt;/span&gt; &lt;span&gt;            sKBitmap2.Dispose();
&lt;/span&gt;&lt;span&gt;310&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; data =&lt;span&gt; sKImage2.Encode(GetImageFormatByPath(path), quality);
&lt;/span&gt;&lt;span&gt;311&lt;/span&gt; &lt;span&gt;            sKImage2.Dispose();
&lt;/span&gt;&lt;span&gt;312&lt;/span&gt;             bytes =&lt;span&gt; data.ToArray();
&lt;/span&gt;&lt;span&gt;313&lt;/span&gt; &lt;span&gt;            data.Dispose();
&lt;/span&gt;&lt;span&gt;314&lt;/span&gt; 
&lt;span&gt;315&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; bytes;
&lt;/span&gt;&lt;span&gt;316&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;317&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; ImageScalingByOversized(&lt;span&gt;string&lt;/span&gt; path, &lt;span&gt;string&lt;/span&gt; savePath, &lt;span&gt;int&lt;/span&gt; maxWidth, &lt;span&gt;int&lt;/span&gt; maxHeight, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; quality)
&lt;/span&gt;&lt;span&gt;318&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;319&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; bytes =&lt;span&gt; ImageScalingByOversized(path, maxWidth, maxHeight, quality);
&lt;/span&gt;&lt;span&gt;320&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (bytes == &lt;span&gt;null&lt;/span&gt; || bytes.Length &amp;lt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;321&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;322&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;323&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;324&lt;/span&gt;             &lt;span&gt;string&lt;/span&gt; saveDirPath =&lt;span&gt; System.IO.Path.GetDirectoryName(savePath);
&lt;/span&gt;&lt;span&gt;325&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;System.IO.Directory.Exists(saveDirPath))
&lt;/span&gt;&lt;span&gt;326&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;327&lt;/span&gt; &lt;span&gt;                System.IO.Directory.CreateDirectory(saveDirPath);
&lt;/span&gt;&lt;span&gt;328&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;329&lt;/span&gt;             System.IO.FileStream fs = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; System.IO.FileStream(savePath, System.IO.FileMode.OpenOrCreate, System.IO.FileAccess.Write, System.IO.FileShare.None);
&lt;/span&gt;&lt;span&gt;330&lt;/span&gt;             fs.Write(bytes, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, bytes.Length);
&lt;/span&gt;&lt;span&gt;331&lt;/span&gt; &lt;span&gt;            fs.Close();
&lt;/span&gt;&lt;span&gt;332&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;333&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[] ImageScalingByOversized(&lt;span&gt;string&lt;/span&gt; path, &lt;span&gt;int&lt;/span&gt; maxWidth, &lt;span&gt;int&lt;/span&gt; maxHeight, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; quality)
&lt;/span&gt;&lt;span&gt;334&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;335&lt;/span&gt;             &lt;span&gt;byte&lt;/span&gt;[] bytes = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;336&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;System.IO.File.Exists(path))
&lt;/span&gt;&lt;span&gt;337&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;338&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; bytes;
&lt;/span&gt;&lt;span&gt;339&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;340&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; fileStream = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; System.IO.FileStream(path, System.IO.FileMode.Open, System.IO.FileAccess.Read, System.IO.FileShare.Read);
&lt;/span&gt;&lt;span&gt;341&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (fileStream.Length &amp;gt;&lt;span&gt; maxLength)
&lt;/span&gt;&lt;span&gt;342&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;343&lt;/span&gt; &lt;span&gt;                fileStream.Dispose();
&lt;/span&gt;&lt;span&gt;344&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; bytes;
&lt;/span&gt;&lt;span&gt;345&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;346&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; sKManagedStream = &lt;span&gt;new&lt;/span&gt; SkiaSharp.SKManagedStream(fileStream, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;347&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; sKBitmap =&lt;span&gt; SkiaSharp.SKBitmap.Decode(sKManagedStream);
&lt;/span&gt;&lt;span&gt;348&lt;/span&gt; &lt;span&gt;            sKManagedStream.Dispose();
&lt;/span&gt;&lt;span&gt;349&lt;/span&gt; 
&lt;span&gt;350&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (sKBitmap.IsEmpty)
&lt;/span&gt;&lt;span&gt;351&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;352&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; bytes;
&lt;/span&gt;&lt;span&gt;353&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;354&lt;/span&gt; 
&lt;span&gt;355&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (maxWidth &amp;lt; &lt;span&gt;1&lt;/span&gt;) { maxWidth = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt;356&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (maxHeight &amp;lt; &lt;span&gt;1&lt;/span&gt;) { maxHeight = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt;357&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (quality &amp;lt; &lt;span&gt;1&lt;/span&gt;) { quality = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt;358&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (quality &amp;gt; &lt;span&gt;100&lt;/span&gt;) { quality = &lt;span&gt;100&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt;359&lt;/span&gt; 
&lt;span&gt;360&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; oW =&lt;span&gt; sKBitmap.Width;
&lt;/span&gt;&lt;span&gt;361&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; oH =&lt;span&gt; sKBitmap.Height;
&lt;/span&gt;&lt;span&gt;362&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; nW =&lt;span&gt; oW;
&lt;/span&gt;&lt;span&gt;363&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; nH =&lt;span&gt; oH;
&lt;/span&gt;&lt;span&gt;364&lt;/span&gt; 
&lt;span&gt;365&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (oW &amp;gt; maxWidth || oH &amp;gt;&lt;span&gt; maxHeight)
&lt;/span&gt;&lt;span&gt;366&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;367&lt;/span&gt;                 nW =&lt;span&gt; maxWidth;
&lt;/span&gt;&lt;span&gt;368&lt;/span&gt;                 nH =&lt;span&gt; maxHeight;
&lt;/span&gt;&lt;span&gt;369&lt;/span&gt;                 &lt;span&gt;double&lt;/span&gt; ratio = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;370&lt;/span&gt; 
&lt;span&gt;371&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (nW &amp;gt; &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; nH &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;372&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;373&lt;/span&gt;                     ratio = (&lt;span&gt;double&lt;/span&gt;)nW /&lt;span&gt; oW;
&lt;/span&gt;&lt;span&gt;374&lt;/span&gt;                     nH = Convert.ToInt32(oH *&lt;span&gt; ratio);
&lt;/span&gt;&lt;span&gt;375&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (maxHeight &amp;lt;&lt;span&gt; nH)
&lt;/span&gt;&lt;span&gt;376&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;377&lt;/span&gt;                         ratio = (&lt;span&gt;double&lt;/span&gt;)maxHeight /&lt;span&gt; nH;
&lt;/span&gt;&lt;span&gt;378&lt;/span&gt;                         nW = Convert.ToInt32(nW *&lt;span&gt; ratio);
&lt;/span&gt;&lt;span&gt;379&lt;/span&gt;                         nH =&lt;span&gt; maxHeight;
&lt;/span&gt;&lt;span&gt;380&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;381&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;382&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (nW &amp;lt; &lt;span&gt;1&lt;/span&gt; &amp;amp;&amp;amp; nH &amp;lt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;383&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;384&lt;/span&gt;                     nW =&lt;span&gt; oW;
&lt;/span&gt;&lt;span&gt;385&lt;/span&gt;                     nH =&lt;span&gt; oH;
&lt;/span&gt;&lt;span&gt;386&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;387&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (nW &amp;lt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;388&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;389&lt;/span&gt;                     ratio = (&lt;span&gt;double&lt;/span&gt;)nH /&lt;span&gt; oH;
&lt;/span&gt;&lt;span&gt;390&lt;/span&gt;                     nW = Convert.ToInt32(oW *&lt;span&gt; ratio);
&lt;/span&gt;&lt;span&gt;391&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;392&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (nH &amp;lt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;393&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;394&lt;/span&gt;                     ratio = (&lt;span&gt;double&lt;/span&gt;)nW /&lt;span&gt; oW;
&lt;/span&gt;&lt;span&gt;395&lt;/span&gt;                     nH = Convert.ToInt32(oH *&lt;span&gt; ratio);
&lt;/span&gt;&lt;span&gt;396&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;397&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; sKBitmap2 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SkiaSharp.SKBitmap(nW, nH);
&lt;/span&gt;&lt;span&gt;398&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; sKCanvas = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SkiaSharp.SKCanvas(sKBitmap2);
&lt;/span&gt;&lt;span&gt;399&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; sKPaint = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SkiaSharp.SKPaint
&lt;/span&gt;&lt;span&gt;400&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;401&lt;/span&gt;                     FilterQuality =&lt;span&gt; SkiaSharp.SKFilterQuality.Medium,
&lt;/span&gt;&lt;span&gt;402&lt;/span&gt;                     IsAntialias = &lt;span&gt;true&lt;/span&gt;
&lt;span&gt;403&lt;/span&gt; &lt;span&gt;                };
&lt;/span&gt;&lt;span&gt;404&lt;/span&gt; &lt;span&gt;                sKCanvas.DrawBitmap(
&lt;/span&gt;&lt;span&gt;405&lt;/span&gt; &lt;span&gt;                    sKBitmap,
&lt;/span&gt;&lt;span&gt;406&lt;/span&gt;                     &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SkiaSharp.SKRect
&lt;/span&gt;&lt;span&gt;407&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;408&lt;/span&gt;                         Location = &lt;span&gt;new&lt;/span&gt; SkiaSharp.SKPoint { X = &lt;span&gt;0&lt;/span&gt;, Y = &lt;span&gt;0&lt;/span&gt;&lt;span&gt; },
&lt;/span&gt;&lt;span&gt;409&lt;/span&gt;                         Size = &lt;span&gt;new&lt;/span&gt; SkiaSharp.SKSize { Height = oH, Width =&lt;span&gt; oW }
&lt;/span&gt;&lt;span&gt;410&lt;/span&gt; &lt;span&gt;                    },
&lt;/span&gt;&lt;span&gt;411&lt;/span&gt;                     &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SkiaSharp.SKRect
&lt;/span&gt;&lt;span&gt;412&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;413&lt;/span&gt;                         Location = &lt;span&gt;new&lt;/span&gt; SkiaSharp.SKPoint { X = &lt;span&gt;0&lt;/span&gt;, Y = &lt;span&gt;0&lt;/span&gt;&lt;span&gt; },
&lt;/span&gt;&lt;span&gt;414&lt;/span&gt;                         Size = &lt;span&gt;new&lt;/span&gt; SkiaSharp.SKSize { Height = nH, Width =&lt;span&gt; nW }
&lt;/span&gt;&lt;span&gt;415&lt;/span&gt; &lt;span&gt;                    }, sKPaint);
&lt;/span&gt;&lt;span&gt;416&lt;/span&gt; &lt;span&gt;                sKCanvas.Dispose();
&lt;/span&gt;&lt;span&gt;417&lt;/span&gt; &lt;span&gt;                sKBitmap.Dispose();
&lt;/span&gt;&lt;span&gt;418&lt;/span&gt;                 sKBitmap =&lt;span&gt; sKBitmap2;
&lt;/span&gt;&lt;span&gt;419&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;420&lt;/span&gt; 
&lt;span&gt;421&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; sKImage =&lt;span&gt; SkiaSharp.SKImage.FromBitmap(sKBitmap);
&lt;/span&gt;&lt;span&gt;422&lt;/span&gt; &lt;span&gt;            sKBitmap.Dispose();
&lt;/span&gt;&lt;span&gt;423&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; data =&lt;span&gt; sKImage.Encode(GetImageFormatByPath(path), quality);
&lt;/span&gt;&lt;span&gt;424&lt;/span&gt; &lt;span&gt;            sKImage.Dispose();
&lt;/span&gt;&lt;span&gt;425&lt;/span&gt;             bytes =&lt;span&gt; data.ToArray();
&lt;/span&gt;&lt;span&gt;426&lt;/span&gt; &lt;span&gt;            data.Dispose();
&lt;/span&gt;&lt;span&gt;427&lt;/span&gt; 
&lt;span&gt;428&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; bytes;
&lt;/span&gt;&lt;span&gt;429&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;430&lt;/span&gt; 
&lt;span&gt;431&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;432&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 生成二维码(320*320)
&lt;/span&gt;&lt;span&gt;433&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;434&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;text&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;文本内容&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;435&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;savePath&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;保存路径&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;436&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;logoPath&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;Logo图片路径(缩放到真实二维码区域尺寸的1/6)&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;437&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;keepWhiteBorderPixelVal&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;白边处理(负值表示不做处理，最大值不超过真实二维码区域的1/10)&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;438&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; QRCoder(&lt;span&gt;string&lt;/span&gt; text, &lt;span&gt;string&lt;/span&gt; savePath, &lt;span&gt;string&lt;/span&gt; logoPath = &lt;span&gt;&quot;&quot;&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt; keepWhiteBorderPixelVal = -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;439&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;440&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; format =&lt;span&gt; GetImageFormatByPath(savePath);
&lt;/span&gt;&lt;span&gt;441&lt;/span&gt;             &lt;span&gt;byte&lt;/span&gt;[] bytesLogo = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;442&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;string&lt;/span&gt;.IsNullOrEmpty(logoPath) &amp;amp;&amp;amp;&lt;span&gt; System.IO.File.Exists(logoPath))
&lt;/span&gt;&lt;span&gt;443&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;444&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; fsLogo = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; System.IO.FileStream(logoPath, System.IO.FileMode.Open, System.IO.FileAccess.Read, System.IO.FileShare.Read);
&lt;/span&gt;&lt;span&gt;445&lt;/span&gt;                 System.IO.MemoryStream ms = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; System.IO.MemoryStream();
&lt;/span&gt;&lt;span&gt;446&lt;/span&gt; &lt;span&gt;                fsLogo.CopyTo(ms);
&lt;/span&gt;&lt;span&gt;447&lt;/span&gt; &lt;span&gt;                fsLogo.Dispose();
&lt;/span&gt;&lt;span&gt;448&lt;/span&gt;                 bytesLogo =&lt;span&gt; ms.ToArray();
&lt;/span&gt;&lt;span&gt;449&lt;/span&gt; &lt;span&gt;                ms.Dispose();
&lt;/span&gt;&lt;span&gt;450&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;451&lt;/span&gt; 
&lt;span&gt;452&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; bytes =&lt;span&gt; QRCoder(text, format, bytesLogo, keepWhiteBorderPixelVal);
&lt;/span&gt;&lt;span&gt;453&lt;/span&gt; 
&lt;span&gt;454&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (bytes == &lt;span&gt;null&lt;/span&gt; || bytes.Length &amp;lt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;455&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;456&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;457&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;458&lt;/span&gt; 
&lt;span&gt;459&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; saveDirPath =&lt;span&gt; System.IO.Path.GetDirectoryName(savePath);
&lt;/span&gt;&lt;span&gt;460&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;System.IO.Directory.Exists(saveDirPath))
&lt;/span&gt;&lt;span&gt;461&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;462&lt;/span&gt; &lt;span&gt;                System.IO.Directory.CreateDirectory(saveDirPath);
&lt;/span&gt;&lt;span&gt;463&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;464&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; fs = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; System.IO.FileStream(savePath, System.IO.FileMode.OpenOrCreate, System.IO.FileAccess.Write, System.IO.FileShare.None);
&lt;/span&gt;&lt;span&gt;465&lt;/span&gt;             fs.Write(bytes, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, bytes.Length);
&lt;/span&gt;&lt;span&gt;466&lt;/span&gt; &lt;span&gt;            fs.Close();
&lt;/span&gt;&lt;span&gt;467&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;468&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;469&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 生成二维码(320*320)
&lt;/span&gt;&lt;span&gt;470&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;471&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;text&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;文本内容&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;472&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;format&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;保存格式&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;473&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;logoImgae&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;Logo图片(缩放到真实二维码区域尺寸的1/6)&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;474&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;keepWhiteBorderPixelVal&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;白边处理(负值表示不做处理，最大值不超过真实二维码区域的1/10)&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;475&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt;476&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[] QRCoder(&lt;span&gt;string&lt;/span&gt; text, SkiaSharp.SKEncodedImageFormat format, &lt;span&gt;byte&lt;/span&gt;[] logoImgae = &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt; keepWhiteBorderPixelVal = -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;477&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;478&lt;/span&gt;             &lt;span&gt;byte&lt;/span&gt;[] reval = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;479&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; width = &lt;span&gt;320&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;480&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; height = &lt;span&gt;320&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;481&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; qRCodeWriter = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ZXing.QrCode.QRCodeWriter();
&lt;/span&gt;&lt;span&gt;482&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; hints = &lt;span&gt;new&lt;/span&gt; Dictionary&amp;lt;ZXing.EncodeHintType, &lt;span&gt;object&lt;/span&gt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;483&lt;/span&gt;             hints.Add(ZXing.EncodeHintType.CHARACTER_SET, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;484&lt;/span&gt;             hints.Add(ZXing.EncodeHintType.QR_VERSION, &lt;span&gt;8&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;485&lt;/span&gt; &lt;span&gt;            hints.Add(ZXing.EncodeHintType.ERROR_CORRECTION, ZXing.QrCode.Internal.ErrorCorrectionLevel.Q);
&lt;/span&gt;&lt;span&gt;486&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; bitMatrix =&lt;span&gt; qRCodeWriter.encode(text, ZXing.BarcodeFormat.QR_CODE, width, height, hints);
&lt;/span&gt;&lt;span&gt;487&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; w =&lt;span&gt; bitMatrix.Width;
&lt;/span&gt;&lt;span&gt;488&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; h =&lt;span&gt; bitMatrix.Height;
&lt;/span&gt;&lt;span&gt;489&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; sKBitmap = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SkiaSharp.SKBitmap(w, h);
&lt;/span&gt;&lt;span&gt;490&lt;/span&gt; 
&lt;span&gt;491&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; blackStartPointX = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;492&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; blackStartPointY = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;493&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; blackEndPointX =&lt;span&gt; w;
&lt;/span&gt;&lt;span&gt;494&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; blackEndPointY =&lt;span&gt; h;
&lt;/span&gt;&lt;span&gt;495&lt;/span&gt; 
&lt;span&gt;496&lt;/span&gt;             &lt;span&gt;#region&lt;/span&gt; --绘制二维码(同时获取真实的二维码区域起绘点和结束点的坐标)--
&lt;span&gt;497&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; sKCanvas = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SkiaSharp.SKCanvas(sKBitmap);
&lt;/span&gt;&lt;span&gt;498&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; sKColorBlack = SkiaSharp.SKColor.Parse(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;000000&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;499&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; sKColorWihte = SkiaSharp.SKColor.Parse(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ffffff&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;500&lt;/span&gt; &lt;span&gt;            sKCanvas.Clear(sKColorWihte);
&lt;/span&gt;&lt;span&gt;501&lt;/span&gt;             &lt;span&gt;bool&lt;/span&gt; blackStartPointIsNotWriteDown = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;502&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; y = &lt;span&gt;0&lt;/span&gt;; y &amp;lt; h; y++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;503&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;504&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; x = &lt;span&gt;0&lt;/span&gt;; x &amp;lt; w; x++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;505&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;506&lt;/span&gt;                     &lt;span&gt;var&lt;/span&gt; flag =&lt;span&gt; bitMatrix[x, y];
&lt;/span&gt;&lt;span&gt;507&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (flag)
&lt;/span&gt;&lt;span&gt;508&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;509&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (blackStartPointIsNotWriteDown)
&lt;/span&gt;&lt;span&gt;510&lt;/span&gt; &lt;span&gt;                        {
&lt;/span&gt;&lt;span&gt;511&lt;/span&gt;                             blackStartPointX =&lt;span&gt; x;
&lt;/span&gt;&lt;span&gt;512&lt;/span&gt;                             blackStartPointY =&lt;span&gt; y;
&lt;/span&gt;&lt;span&gt;513&lt;/span&gt;                             blackStartPointIsNotWriteDown = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;514&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;515&lt;/span&gt;                         blackEndPointX =&lt;span&gt; x;
&lt;/span&gt;&lt;span&gt;516&lt;/span&gt;                         blackEndPointY =&lt;span&gt; y;
&lt;/span&gt;&lt;span&gt;517&lt;/span&gt; &lt;span&gt;                        sKCanvas.DrawPoint(x, y, sKColorBlack);
&lt;/span&gt;&lt;span&gt;518&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;519&lt;/span&gt;                     &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;520&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;521&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;sKCanvas.DrawPoint(x, y, sKColorWihte);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;不用绘制(背景是白色的)&lt;/span&gt;
&lt;span&gt;522&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;523&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;524&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;525&lt;/span&gt; &lt;span&gt;            sKCanvas.Dispose();
&lt;/span&gt;&lt;span&gt;526&lt;/span&gt;             &lt;span&gt;#endregion&lt;/span&gt;
&lt;span&gt;527&lt;/span&gt; 
&lt;span&gt;528&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; qrcodeRealWidth = blackEndPointX -&lt;span&gt; blackStartPointX;
&lt;/span&gt;&lt;span&gt;529&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; qrcodeRealHeight = blackEndPointY -&lt;span&gt; blackStartPointY;
&lt;/span&gt;&lt;span&gt;530&lt;/span&gt; 
&lt;span&gt;531&lt;/span&gt;             &lt;span&gt;#region&lt;/span&gt; -- 处理白边 --
&lt;span&gt;532&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (keepWhiteBorderPixelVal &amp;gt; -&lt;span&gt;1&lt;/span&gt;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;指定了边框宽度&lt;/span&gt;
&lt;span&gt;533&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;534&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; borderMaxWidth = (&lt;span&gt;int&lt;/span&gt;)Math.Floor((&lt;span&gt;double&lt;/span&gt;)qrcodeRealWidth / &lt;span&gt;10&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;535&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (keepWhiteBorderPixelVal &amp;gt;&lt;span&gt; borderMaxWidth)
&lt;/span&gt;&lt;span&gt;536&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;537&lt;/span&gt;                     keepWhiteBorderPixelVal =&lt;span&gt; borderMaxWidth;
&lt;/span&gt;&lt;span&gt;538&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;539&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; nQrcodeRealWidth = width - keepWhiteBorderPixelVal -&lt;span&gt; keepWhiteBorderPixelVal;
&lt;/span&gt;&lt;span&gt;540&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; nQrcodeRealHeight = height - keepWhiteBorderPixelVal -&lt;span&gt; keepWhiteBorderPixelVal;
&lt;/span&gt;&lt;span&gt;541&lt;/span&gt; 
&lt;span&gt;542&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; sKBitmap2 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SkiaSharp.SKBitmap(width, height);
&lt;/span&gt;&lt;span&gt;543&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; sKCanvas2 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SkiaSharp.SKCanvas(sKBitmap2);
&lt;/span&gt;&lt;span&gt;544&lt;/span&gt; &lt;span&gt;                sKCanvas2.Clear(sKColorWihte);
&lt;/span&gt;&lt;span&gt;545&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;二维码绘制到临时画布上时无需抗锯齿等处理(避免文件增大)&lt;/span&gt;
&lt;span&gt;546&lt;/span&gt; &lt;span&gt;                sKCanvas2.DrawBitmap(
&lt;/span&gt;&lt;span&gt;547&lt;/span&gt; &lt;span&gt;                    sKBitmap,
&lt;/span&gt;&lt;span&gt;548&lt;/span&gt;                     &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SkiaSharp.SKRect
&lt;/span&gt;&lt;span&gt;549&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;550&lt;/span&gt;                         Location = &lt;span&gt;new&lt;/span&gt; SkiaSharp.SKPoint { X = blackStartPointX, Y =&lt;span&gt; blackStartPointY },
&lt;/span&gt;&lt;span&gt;551&lt;/span&gt;                         Size = &lt;span&gt;new&lt;/span&gt; SkiaSharp.SKSize { Height = qrcodeRealHeight, Width =&lt;span&gt; qrcodeRealWidth }
&lt;/span&gt;&lt;span&gt;552&lt;/span&gt; &lt;span&gt;                    },
&lt;/span&gt;&lt;span&gt;553&lt;/span&gt;                     &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SkiaSharp.SKRect
&lt;/span&gt;&lt;span&gt;554&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;555&lt;/span&gt;                         Location = &lt;span&gt;new&lt;/span&gt; SkiaSharp.SKPoint { X = keepWhiteBorderPixelVal, Y =&lt;span&gt; keepWhiteBorderPixelVal },
&lt;/span&gt;&lt;span&gt;556&lt;/span&gt;                         Size = &lt;span&gt;new&lt;/span&gt; SkiaSharp.SKSize { Width = nQrcodeRealWidth, Height =&lt;span&gt; nQrcodeRealHeight }
&lt;/span&gt;&lt;span&gt;557&lt;/span&gt; &lt;span&gt;                    });
&lt;/span&gt;&lt;span&gt;558&lt;/span&gt; 
&lt;span&gt;559&lt;/span&gt;                 blackStartPointX =&lt;span&gt; keepWhiteBorderPixelVal;
&lt;/span&gt;&lt;span&gt;560&lt;/span&gt;                 blackStartPointY =&lt;span&gt; keepWhiteBorderPixelVal;
&lt;/span&gt;&lt;span&gt;561&lt;/span&gt;                 qrcodeRealWidth =&lt;span&gt; nQrcodeRealWidth;
&lt;/span&gt;&lt;span&gt;562&lt;/span&gt;                 qrcodeRealHeight =&lt;span&gt; nQrcodeRealHeight;
&lt;/span&gt;&lt;span&gt;563&lt;/span&gt; 
&lt;span&gt;564&lt;/span&gt; &lt;span&gt;                sKCanvas2.Dispose();
&lt;/span&gt;&lt;span&gt;565&lt;/span&gt; &lt;span&gt;                sKBitmap.Dispose();
&lt;/span&gt;&lt;span&gt;566&lt;/span&gt;                 sKBitmap =&lt;span&gt; sKBitmap2;
&lt;/span&gt;&lt;span&gt;567&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;568&lt;/span&gt;             &lt;span&gt;#endregion&lt;/span&gt;
&lt;span&gt;569&lt;/span&gt; 
&lt;span&gt;570&lt;/span&gt;             &lt;span&gt;#region&lt;/span&gt; -- 绘制LOGO --
&lt;span&gt;571&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (logoImgae != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; logoImgae.Length &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;572&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;573&lt;/span&gt;                 SkiaSharp.SKBitmap sKBitmapLogo =&lt;span&gt; SkiaSharp.SKBitmap.Decode(logoImgae);
&lt;/span&gt;&lt;span&gt;574&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;sKBitmapLogo.IsEmpty)
&lt;/span&gt;&lt;span&gt;575&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;576&lt;/span&gt;                     &lt;span&gt;var&lt;/span&gt; sKPaint2 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SkiaSharp.SKPaint
&lt;/span&gt;&lt;span&gt;577&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;578&lt;/span&gt;                         FilterQuality =&lt;span&gt; SkiaSharp.SKFilterQuality.None,
&lt;/span&gt;&lt;span&gt;579&lt;/span&gt;                         IsAntialias = &lt;span&gt;true&lt;/span&gt;
&lt;span&gt;580&lt;/span&gt; &lt;span&gt;                    };
&lt;/span&gt;&lt;span&gt;581&lt;/span&gt;                     &lt;span&gt;var&lt;/span&gt; logoTargetMaxWidth = (&lt;span&gt;int&lt;/span&gt;)Math.Floor((&lt;span&gt;double&lt;/span&gt;)qrcodeRealWidth / &lt;span&gt;6&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;582&lt;/span&gt;                     &lt;span&gt;var&lt;/span&gt; logoTargetMaxHeight = (&lt;span&gt;int&lt;/span&gt;)Math.Floor((&lt;span&gt;double&lt;/span&gt;)qrcodeRealHeight / &lt;span&gt;6&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;583&lt;/span&gt;                     &lt;span&gt;var&lt;/span&gt; qrcodeCenterX = (&lt;span&gt;int&lt;/span&gt;)Math.Floor((&lt;span&gt;double&lt;/span&gt;)qrcodeRealWidth / &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;584&lt;/span&gt;                     &lt;span&gt;var&lt;/span&gt; qrcodeCenterY = (&lt;span&gt;int&lt;/span&gt;)Math.Floor((&lt;span&gt;double&lt;/span&gt;)qrcodeRealHeight / &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;585&lt;/span&gt;                     &lt;span&gt;var&lt;/span&gt; logoResultWidth =&lt;span&gt; sKBitmapLogo.Width;
&lt;/span&gt;&lt;span&gt;586&lt;/span&gt;                     &lt;span&gt;var&lt;/span&gt; logoResultHeight =&lt;span&gt; sKBitmapLogo.Height;
&lt;/span&gt;&lt;span&gt;587&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (logoResultWidth &amp;gt;&lt;span&gt; logoTargetMaxWidth)
&lt;/span&gt;&lt;span&gt;588&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;589&lt;/span&gt;                         &lt;span&gt;var&lt;/span&gt; r = (&lt;span&gt;double&lt;/span&gt;)logoTargetMaxWidth /&lt;span&gt; logoResultWidth;
&lt;/span&gt;&lt;span&gt;590&lt;/span&gt;                         logoResultWidth =&lt;span&gt; logoTargetMaxWidth;
&lt;/span&gt;&lt;span&gt;591&lt;/span&gt;                         logoResultHeight = (&lt;span&gt;int&lt;/span&gt;)Math.Floor(logoResultHeight *&lt;span&gt; r);
&lt;/span&gt;&lt;span&gt;592&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;593&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (logoResultHeight &amp;gt;&lt;span&gt; logoTargetMaxHeight)
&lt;/span&gt;&lt;span&gt;594&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;595&lt;/span&gt;                         &lt;span&gt;var&lt;/span&gt; r = (&lt;span&gt;double&lt;/span&gt;)logoTargetMaxHeight /&lt;span&gt; logoResultHeight;
&lt;/span&gt;&lt;span&gt;596&lt;/span&gt;                         logoResultHeight =&lt;span&gt; logoTargetMaxHeight;
&lt;/span&gt;&lt;span&gt;597&lt;/span&gt;                         logoResultWidth = (&lt;span&gt;int&lt;/span&gt;)Math.Floor(logoResultWidth *&lt;span&gt; r);
&lt;/span&gt;&lt;span&gt;598&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;599&lt;/span&gt;                     &lt;span&gt;var&lt;/span&gt; pointX = qrcodeCenterX - (&lt;span&gt;int&lt;/span&gt;)Math.Floor((&lt;span&gt;double&lt;/span&gt;)logoResultWidth / &lt;span&gt;2&lt;/span&gt;) +&lt;span&gt; blackStartPointX;
&lt;/span&gt;&lt;span&gt;600&lt;/span&gt;                     &lt;span&gt;var&lt;/span&gt; pointY = qrcodeCenterY - (&lt;span&gt;int&lt;/span&gt;)Math.Floor((&lt;span&gt;double&lt;/span&gt;)logoResultHeight / &lt;span&gt;2&lt;/span&gt;) +&lt;span&gt; blackStartPointY;
&lt;/span&gt;&lt;span&gt;601&lt;/span&gt; 
&lt;span&gt;602&lt;/span&gt;                     &lt;span&gt;var&lt;/span&gt; sKCanvas3 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SkiaSharp.SKCanvas(sKBitmap);
&lt;/span&gt;&lt;span&gt;603&lt;/span&gt;                     &lt;span&gt;var&lt;/span&gt; sKPaint = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SkiaSharp.SKPaint
&lt;/span&gt;&lt;span&gt;604&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;605&lt;/span&gt;                         FilterQuality =&lt;span&gt; SkiaSharp.SKFilterQuality.Medium,
&lt;/span&gt;&lt;span&gt;606&lt;/span&gt;                         IsAntialias = &lt;span&gt;true&lt;/span&gt;
&lt;span&gt;607&lt;/span&gt; &lt;span&gt;                    };
&lt;/span&gt;&lt;span&gt;608&lt;/span&gt; &lt;span&gt;                    sKCanvas3.DrawBitmap(
&lt;/span&gt;&lt;span&gt;609&lt;/span&gt; &lt;span&gt;                        sKBitmapLogo,
&lt;/span&gt;&lt;span&gt;610&lt;/span&gt;                         &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SkiaSharp.SKRect
&lt;/span&gt;&lt;span&gt;611&lt;/span&gt; &lt;span&gt;                        {
&lt;/span&gt;&lt;span&gt;612&lt;/span&gt;                             Location = &lt;span&gt;new&lt;/span&gt; SkiaSharp.SKPoint { X = &lt;span&gt;0&lt;/span&gt;, Y = &lt;span&gt;0&lt;/span&gt;&lt;span&gt; },
&lt;/span&gt;&lt;span&gt;613&lt;/span&gt;                             Size = &lt;span&gt;new&lt;/span&gt; SkiaSharp.SKSize { Height = sKBitmapLogo.Height, Width =&lt;span&gt; sKBitmapLogo.Width }
&lt;/span&gt;&lt;span&gt;614&lt;/span&gt; &lt;span&gt;                        },
&lt;/span&gt;&lt;span&gt;615&lt;/span&gt;                         &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SkiaSharp.SKRect
&lt;/span&gt;&lt;span&gt;616&lt;/span&gt; &lt;span&gt;                        {
&lt;/span&gt;&lt;span&gt;617&lt;/span&gt;                             Location = &lt;span&gt;new&lt;/span&gt; SkiaSharp.SKPoint { X = pointX, Y =&lt;span&gt; pointY },
&lt;/span&gt;&lt;span&gt;618&lt;/span&gt;                             Size = &lt;span&gt;new&lt;/span&gt; SkiaSharp.SKSize { Height = logoResultHeight, Width =&lt;span&gt; logoResultWidth }
&lt;/span&gt;&lt;span&gt;619&lt;/span&gt; &lt;span&gt;                        }, sKPaint);
&lt;/span&gt;&lt;span&gt;620&lt;/span&gt; &lt;span&gt;                    sKCanvas3.Dispose();
&lt;/span&gt;&lt;span&gt;621&lt;/span&gt; &lt;span&gt;                    sKPaint.Dispose();
&lt;/span&gt;&lt;span&gt;622&lt;/span&gt; &lt;span&gt;                    sKBitmapLogo.Dispose();
&lt;/span&gt;&lt;span&gt;623&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;624&lt;/span&gt;                 &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;625&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;626&lt;/span&gt; &lt;span&gt;                    sKBitmapLogo.Dispose();
&lt;/span&gt;&lt;span&gt;627&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;628&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;629&lt;/span&gt;             &lt;span&gt;#endregion&lt;/span&gt;
&lt;span&gt;630&lt;/span&gt; 
&lt;span&gt;631&lt;/span&gt;             SkiaSharp.SKImage sKImage =&lt;span&gt; SkiaSharp.SKImage.FromBitmap(sKBitmap);
&lt;/span&gt;&lt;span&gt;632&lt;/span&gt; &lt;span&gt;            sKBitmap.Dispose();
&lt;/span&gt;&lt;span&gt;633&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; data = sKImage.Encode(format, &lt;span&gt;75&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;634&lt;/span&gt; &lt;span&gt;            sKImage.Dispose();
&lt;/span&gt;&lt;span&gt;635&lt;/span&gt;             reval =&lt;span&gt; data.ToArray();
&lt;/span&gt;&lt;span&gt;636&lt;/span&gt; &lt;span&gt;            data.Dispose();
&lt;/span&gt;&lt;span&gt;637&lt;/span&gt; 
&lt;span&gt;638&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; reval;
&lt;/span&gt;&lt;span&gt;639&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;640&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; QRDecoder(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; qrCodeFilePath)
&lt;/span&gt;&lt;span&gt;641&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;642&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;System.IO.File.Exists(qrCodeFilePath))
&lt;/span&gt;&lt;span&gt;643&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;644&lt;/span&gt;                 &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Exception(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;文件不存在&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;645&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;646&lt;/span&gt; 
&lt;span&gt;647&lt;/span&gt;             System.IO.FileStream fileStream = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; System.IO.FileStream(qrCodeFilePath, System.IO.FileMode.Open, System.IO.FileAccess.Read, System.IO.FileShare.Read);
&lt;/span&gt;&lt;span&gt;648&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (fileStream.Length &amp;gt;&lt;span&gt; maxLength)
&lt;/span&gt;&lt;span&gt;649&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;650&lt;/span&gt; &lt;span&gt;                fileStream.Dispose();
&lt;/span&gt;&lt;span&gt;651&lt;/span&gt;                 &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Exception(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;图片文件太大&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;652&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;653&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; QRDecoder(fileStream);
&lt;/span&gt;&lt;span&gt;654&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;655&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; QRDecoder(&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[] qrCodeBytes)
&lt;/span&gt;&lt;span&gt;656&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;657&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(qrCodeBytes==&lt;span&gt;null&lt;/span&gt;|| qrCodeBytes.Length&amp;lt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;658&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;659&lt;/span&gt;                 &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Exception(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;参数qrCodeBytes不存在&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;660&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;661&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (qrCodeBytes.Length &amp;gt;&lt;span&gt; maxLength)
&lt;/span&gt;&lt;span&gt;662&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;663&lt;/span&gt;                 &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Exception(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;图片文件太大&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;664&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;665&lt;/span&gt;             System.IO.MemoryStream ms = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; System.IO.MemoryStream(qrCodeBytes);
&lt;/span&gt;&lt;span&gt;666&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; QRDecoder(ms);
&lt;/span&gt;&lt;span&gt;667&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;668&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; QRDecoder(System.IO.Stream qrCodeFileStream)
&lt;/span&gt;&lt;span&gt;669&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;670&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; sKManagedStream = &lt;span&gt;new&lt;/span&gt; SkiaSharp.SKManagedStream(qrCodeFileStream, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;671&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; sKBitmap =&lt;span&gt; SkiaSharp.SKBitmap.Decode(sKManagedStream);
&lt;/span&gt;&lt;span&gt;672&lt;/span&gt; &lt;span&gt;            sKManagedStream.Dispose();
&lt;/span&gt;&lt;span&gt;673&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (sKBitmap.IsEmpty)
&lt;/span&gt;&lt;span&gt;674&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;675&lt;/span&gt; &lt;span&gt;                sKBitmap.Dispose();
&lt;/span&gt;&lt;span&gt;676&lt;/span&gt;                 &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Exception(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;未识别的图片文件&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;677&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;678&lt;/span&gt; 
&lt;span&gt;679&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; w =&lt;span&gt; sKBitmap.Width;
&lt;/span&gt;&lt;span&gt;680&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; h =&lt;span&gt; sKBitmap.Height;
&lt;/span&gt;&lt;span&gt;681&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; ps = w *&lt;span&gt; h;
&lt;/span&gt;&lt;span&gt;682&lt;/span&gt;             &lt;span&gt;byte&lt;/span&gt;[] bytes = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[ps * &lt;span&gt;3&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;683&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; byteIndex = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;684&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; x = &lt;span&gt;0&lt;/span&gt;; x &amp;lt; w; x++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;685&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;686&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; y = &lt;span&gt;0&lt;/span&gt;; y &amp;lt; h; y++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;687&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;688&lt;/span&gt;                     &lt;span&gt;var&lt;/span&gt; color =&lt;span&gt; sKBitmap.GetPixel(x, y);
&lt;/span&gt;&lt;span&gt;689&lt;/span&gt;                     bytes[byteIndex + &lt;span&gt;0&lt;/span&gt;] =&lt;span&gt; color.Red;
&lt;/span&gt;&lt;span&gt;690&lt;/span&gt;                     bytes[byteIndex + &lt;span&gt;1&lt;/span&gt;] =&lt;span&gt; color.Green;
&lt;/span&gt;&lt;span&gt;691&lt;/span&gt;                     bytes[byteIndex + &lt;span&gt;2&lt;/span&gt;] =&lt;span&gt; color.Blue;
&lt;/span&gt;&lt;span&gt;692&lt;/span&gt;                     byteIndex += &lt;span&gt;3&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;693&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;694&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;695&lt;/span&gt; &lt;span&gt;            sKBitmap.Dispose();
&lt;/span&gt;&lt;span&gt;696&lt;/span&gt; 
&lt;span&gt;697&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; qRCodeReader = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ZXing.QrCode.QRCodeReader();
&lt;/span&gt;&lt;span&gt;698&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; rGBLuminanceSource = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ZXing.RGBLuminanceSource(bytes, w, h);
&lt;/span&gt;&lt;span&gt;699&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; hybridBinarizer = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ZXing.Common.HybridBinarizer(rGBLuminanceSource);
&lt;/span&gt;&lt;span&gt;700&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; binaryBitmap = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ZXing.BinaryBitmap(hybridBinarizer);
&lt;/span&gt;&lt;span&gt;701&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; hints = &lt;span&gt;new&lt;/span&gt; Dictionary&amp;lt;ZXing.DecodeHintType, &lt;span&gt;object&lt;/span&gt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;702&lt;/span&gt;             hints.Add(ZXing.DecodeHintType.CHARACTER_SET, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;703&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; result =&lt;span&gt; qRCodeReader.decode(binaryBitmap, hints);
&lt;/span&gt;&lt;span&gt;704&lt;/span&gt; 
&lt;span&gt;705&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; result != &lt;span&gt;null&lt;/span&gt; ? result.Text : &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;706&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;707&lt;/span&gt;     }
&lt;/pre&gt;</description>
<pubDate>Tue, 18 Dec 2018 15:38:00 +0000</pubDate>
<dc:creator>如兹</dc:creator>
<og:description>在 .net core 中采用 SkiaSharp 来做图片处理，顺便采用 ZXing.Net 来处理二维码的生成和解析。用 ZXing.Net 生成的二维码默认是有一定比例的白边的，但是在实际的应用</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ruzi/p/10140754.html</dc:identifier>
</item>
<item>
<title>基于Arduino的音乐动感节奏灯 - zutterhao</title>
<link>http://www.cnblogs.com/zutterhao/p/10140172.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zutterhao/p/10140172.html</guid>
<description>&lt;h2&gt;1、音乐动感节奏灯是个什么东西？&lt;/h2&gt;
&lt;p&gt;　　前段时间听音乐觉得无聊，便想着音乐光听也没意思啊，能不能 “看见” 音乐呢？于是谷歌了一番，发现还真有人做了将音乐可视化的东西，那就是音乐节奏灯。说的简单点就是LED灯光颜色亮度等随着音乐的节奏而发生变化，看了下他们的实现方法有很多，不过大都比较复杂，而且灯只能够做节奏灯也比较浪费，于是我便动手做了一个既可以当作普通台灯使用，又可以随着音乐而闪烁的动感节奏灯，一举两得。&lt;/p&gt;
&lt;h2&gt;2、做这个东西需要准备哪些材料？&lt;/h2&gt;
&lt;p&gt;　　工欲善其事，必先利其器。那么做这样一个音乐动感节奏等需要准备哪些材料呢？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;　　Arduino UNO 开发板&lt;/li&gt;
&lt;li&gt;       声音传感器（最好买Arduino专用的）&lt;/li&gt;
&lt;li&gt;       BLE蓝牙4.0模块&lt;/li&gt;
&lt;li&gt;       WS2812B彩色灯带&lt;/li&gt;
&lt;li&gt;       灯罩&lt;/li&gt;
&lt;li&gt;       3D打印底座&lt;/li&gt;
&lt;li&gt;       电源线和杜邦线若干&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以上材料可以在淘宝买到，灯罩和3D打印的底座可以按照自己的实际需求来进行自己选择，为了防止打广告的嫌疑我就不放购买链接了，可以自行设计打印~&lt;/p&gt;
&lt;h2&gt;3、做这个东西需该怎么做？&lt;/h2&gt;
&lt;p&gt;　　准备好上述的材料之后，我们就可以开始进行灯的制作啦~，节奏灯的主要结构如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1228291/201812/1228291-20181218205857333-623092014.png&quot; alt=&quot;&quot; width=&quot;800&quot; height=&quot;408&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们使用Arduino UNO作为主要的计算和处理模块，蓝牙4.0模块和手机进行通信，利用手机APP来选择模式（后续会讲），在节奏灯的模式下，通过声音传感器来采集声音，通过得到的声音来控制灯带的颜色和闪烁，在彩色灯的模式下，利用手机来控制灯的颜色，理论上的有160万可调颜色。接下来介绍下详细的步骤。&lt;/p&gt;
&lt;h3&gt;3.1 安装开发环境&lt;/h3&gt;
&lt;p&gt;　　Arduino UNO 开发的环境为Arduino IDE,软件下载地址为 https://www.arduino.cn/thread-5838-1-1.html ，默认安装为最新版即可。安装完IDE之后还需要安装第三方的库。&lt;/p&gt;
&lt;p&gt;　　1） WS2812B的库 FastLED, 选择 &lt;strong&gt;项目-&amp;gt;加载库-&amp;gt;管理库，&lt;/strong&gt;然后在输入栏输入FastLED,选择最新的版本安装,FastLED库的更多使用方法可以参考 &lt;a href=&quot;http://www.taichi-maker.com/homepage/reference-index/arduino-library-index/fastled-library/&quot;&gt;http://www.taichi-maker.com/homepage/reference-index/arduino-library-index/fastled-library/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;                                      &lt;img src=&quot;https://img2018.cnblogs.com/blog/1228291/201812/1228291-20181218211335004-1697280679.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　2)  物联网开发平台库 Blinker, 在Blinker 官网&lt;a href=&quot;https://doc.blinker.app&quot;&gt;https://doc.blinker.app&lt;/a&gt; 页面下载最新的Blinker库，然后：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　Window&lt;/strong&gt;&lt;strong&gt;：&lt;/strong&gt;将下载好的blinker库解压到 &lt;strong&gt;我的电脑&amp;gt;文档&amp;gt;Arduino&amp;gt;libraries&lt;/strong&gt; 文件夹中&lt;br/&gt;　　　　&lt;strong&gt;Mac OS&lt;/strong&gt;&lt;strong&gt;：&lt;/strong&gt;将下载好的blinker库解压到 &lt;strong&gt;文稿&amp;gt;Arduino&amp;gt;libraries&lt;/strong&gt; 文件夹中&lt;/p&gt;
&lt;p&gt;　　　　可以在&lt;strong&gt;文件-&amp;gt;示例&lt;/strong&gt; 查看库是否安装成功。&lt;/p&gt;
&lt;h3&gt;3.2 连接线路&lt;/h3&gt;
&lt;p&gt;　　具体的线路图由于时间原因没有画，所以直接按照后续的代码可以找到每个模块的连接方式，当然这些连接方式都可以自定义，然后在代码内做简单修改即可。需要注意的是蓝牙模块采用软串口连接，即RX,TX连接在ARDUINO UNO的2 和 3 号脚，而不是0和1 号脚，这个在BLINKER的网站上会说明，如果你代码烧录不了，查查是不是这个原因。&lt;/p&gt;
&lt;h3&gt;3.3 代码编写&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;106&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; BLINKER_PRINT Serial
&lt;span&gt;  2&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; BLINKER_BLE
&lt;span&gt;  3&lt;/span&gt; 
&lt;span&gt;  4&lt;/span&gt; #include &amp;lt;FastLED.h&amp;gt;
&lt;span&gt;  5&lt;/span&gt; #include &amp;lt;Blinker.h&amp;gt;
&lt;span&gt;  6&lt;/span&gt; 
&lt;span&gt;  7&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;* BASIC CONFIGURATION  *&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;  8&lt;/span&gt; 
&lt;span&gt;  9&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;The amount of LEDs in the setup&lt;/span&gt;
&lt;span&gt; 10&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; NUM_LEDS 100
&lt;span&gt; 11&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;The pin that controls the LEDs&lt;/span&gt;
&lt;span&gt; 12&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; LED_PIN 6
&lt;span&gt; 13&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;The pin that we read sensor values form&lt;/span&gt;
&lt;span&gt; 14&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; ANALOG_READ 0
&lt;span&gt; 15&lt;/span&gt; 
&lt;span&gt; 16&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Confirmed microphone low value, and max value&lt;/span&gt;
&lt;span&gt; 17&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; MIC_LOW 0.0
&lt;span&gt; 18&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; MIC_HIGH 300.0
&lt;span&gt; 19&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;* Other macros &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 20&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;How many previous sensor values effects the operating average?&lt;/span&gt;
&lt;span&gt; 21&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; AVGLEN 5
&lt;span&gt; 22&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;How many previous sensor values decides if we are on a peak/HIGH (e.g. in a song)&lt;/span&gt;
&lt;span&gt; 23&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; LONG_SECTOR 20
&lt;span&gt; 24&lt;/span&gt; 
&lt;span&gt; 25&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Mneumonics&lt;/span&gt;
&lt;span&gt; 26&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; HIGH 3
&lt;span&gt; 27&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; NORMAL 2
&lt;span&gt; 28&lt;/span&gt; 
&lt;span&gt; 29&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;How long do we keep the &quot;current average&quot; sound, before restarting the measuring&lt;/span&gt;
&lt;span&gt; 30&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; CYCLES 30 * 1000
&lt;span&gt; 31&lt;/span&gt; 
&lt;span&gt; 32&lt;/span&gt; 
&lt;span&gt; 33&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; fscale( &lt;span&gt;float&lt;/span&gt; originalMin, &lt;span&gt;float&lt;/span&gt; originalMax, &lt;span&gt;float&lt;/span&gt; newBegin, &lt;span&gt;float&lt;/span&gt; newEnd, &lt;span&gt;float&lt;/span&gt; inputValue, &lt;span&gt;float&lt;/span&gt;&lt;span&gt; curve);
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; insert(&lt;span&gt;int&lt;/span&gt; val, &lt;span&gt;int&lt;/span&gt; *avgs, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; len);
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; compute_average(&lt;span&gt;int&lt;/span&gt; *avgs, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; len);
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; visualize_music();
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt; 
&lt;span&gt; 38&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;How many LEDs to we display&lt;/span&gt;
&lt;span&gt; 39&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; curshow =&lt;span&gt; NUM_LEDS;
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt; 
&lt;span&gt; 41&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;Not really used yet. Thought to be able to switch between sound reactive
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt; &lt;span&gt;mode, and general gradient pulsing/static color&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 43&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; mode = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt; 
&lt;span&gt; 45&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Showing different colors based on the mode.&lt;/span&gt;
&lt;span&gt; 46&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; songmode =&lt;span&gt; NORMAL;
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt; 
&lt;span&gt; 48&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Average sound measurement the last CYCLES&lt;/span&gt;
&lt;span&gt; 49&lt;/span&gt; unsigned &lt;span&gt;long&lt;/span&gt;&lt;span&gt; song_avg;
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt; 
&lt;span&gt; 51&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;The amount of iterations since the song_avg was reset&lt;/span&gt;
&lt;span&gt; 52&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; iter = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt; 
&lt;span&gt; 54&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;The speed the LEDs fade to black if not relit&lt;/span&gt;
&lt;span&gt; 55&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; fade_scale = &lt;span&gt;1.2&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt; 
&lt;span&gt; 57&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Led array&lt;/span&gt;
&lt;span&gt; 58&lt;/span&gt; &lt;span&gt;CRGB leds[NUM_LEDS];
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt; 
&lt;span&gt; 60&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;Short sound avg used to &quot;normalize&quot; the input values.
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt; &lt;span&gt;We use the short average instead of using the sensor input directly &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 62&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; avgs[AVGLEN] = {-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;};
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt; 
&lt;span&gt; 64&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Longer sound avg&lt;/span&gt;
&lt;span&gt; 65&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; long_avg[LONG_SECTOR] = {-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;};
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt; 
&lt;span&gt; 67&lt;/span&gt; 
&lt;span&gt; 68&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; LED Model 1/Music LED 2/Color LED&lt;/span&gt;
&lt;span&gt; 69&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; LED_Model = &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt; 
&lt;span&gt; 71&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Keeping track how often, and how long times we hit a certain mode&lt;/span&gt;
&lt;span&gt; 72&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; time_keeping {
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt;   unsigned &lt;span&gt;long&lt;/span&gt;&lt;span&gt; times_start;
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt;   &lt;span&gt;short&lt;/span&gt;&lt;span&gt; times;
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt; &lt;span&gt;};
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt; 
&lt;span&gt; 77&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;How much to increment or decrement each color every cycle&lt;/span&gt;
&lt;span&gt; 78&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; color {
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt;   &lt;span&gt;int&lt;/span&gt;&lt;span&gt; r;
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt;   &lt;span&gt;int&lt;/span&gt;&lt;span&gt; g;
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt;   &lt;span&gt;int&lt;/span&gt;&lt;span&gt; b;
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt; &lt;span&gt;};
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt; 
&lt;span&gt; 84&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; time_keeping high;
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; color Color; 
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; when you use the MusicLED as a Color LED&lt;/span&gt;
&lt;span&gt; 87&lt;/span&gt; CRGB LEDColor(&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);    
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt; uint8_t Bright = &lt;span&gt;255&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt; 
&lt;span&gt; 90&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; declare the button&lt;/span&gt;
&lt;span&gt; 91&lt;/span&gt; BlinkerRGB RGB1(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;RGBKey&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt; BlinkerButton Button1(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt; 
&lt;span&gt; 94&lt;/span&gt; 
&lt;span&gt; 95&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; rgb1_callback&lt;/span&gt;
&lt;span&gt; 96&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; rgb1_callback(uint8_t r_value, uint8_t g_value, uint8_t b_value, uint8_t bright_value)
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; change the color of strip by your set on Blinker&lt;/span&gt;
&lt;span&gt; 99&lt;/span&gt;       LEDColor.r =&lt;span&gt; r_value;
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;       LEDColor.g =&lt;span&gt; g_value;
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt;       LEDColor.b =&lt;span&gt; b_value;
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt;       Bright =&lt;span&gt; bright_value;
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt; &lt;span&gt;      fill_solid(leds,NUM_LEDS,LEDColor);
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt;   
&lt;span&gt;105&lt;/span&gt; &lt;span&gt;  FastLED.show();
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt; 
&lt;span&gt;108&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; button1_callback(&lt;span&gt;const&lt;/span&gt; String &amp;amp;&lt;span&gt; state) {
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt;   &lt;span&gt;if&lt;/span&gt;(LED_Model == &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt; &lt;span&gt;  {
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt;     LEDColor.r = &lt;span&gt;255&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt;     LEDColor.g = &lt;span&gt;255&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt;     LEDColor.b = &lt;span&gt;255&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt;     Bright = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;115&lt;/span&gt; &lt;span&gt;    fill_solid(leds,NUM_LEDS,LEDColor);
&lt;/span&gt;&lt;span&gt;116&lt;/span&gt;     BLINKER_LOG2(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;strip_state: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;OFF&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;117&lt;/span&gt;     LED_Model = &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;118&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;119&lt;/span&gt;   &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(LED_Model == &lt;span&gt;2&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;120&lt;/span&gt; &lt;span&gt;  {
&lt;/span&gt;&lt;span&gt;121&lt;/span&gt;     LED_Model = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;122&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;123&lt;/span&gt; &lt;span&gt;  FastLED.show();
&lt;/span&gt;&lt;span&gt;124&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;125&lt;/span&gt; 
&lt;span&gt;126&lt;/span&gt; 
&lt;span&gt;127&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setup() {
&lt;/span&gt;&lt;span&gt;128&lt;/span&gt;   Serial.begin(&lt;span&gt;9600&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;129&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Set all lights to make sure all are working as expected&lt;/span&gt;
&lt;span&gt;130&lt;/span&gt;   FastLED.addLeds&amp;lt;NEOPIXEL, LED_PIN&amp;gt;&lt;span&gt;(leds, NUM_LEDS);
&lt;/span&gt;&lt;span&gt;131&lt;/span&gt;   &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; NUM_LEDS; i++&lt;span&gt;) 
&lt;/span&gt;&lt;span&gt;132&lt;/span&gt;     leds[i] = CRGB(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;255&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;133&lt;/span&gt; &lt;span&gt;  FastLED.show(); 
&lt;/span&gt;&lt;span&gt;134&lt;/span&gt;   delay(&lt;span&gt;1000&lt;/span&gt;&lt;span&gt;);  
&lt;/span&gt;&lt;span&gt;135&lt;/span&gt; 
&lt;span&gt;136&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;bootstrap average with some low values&lt;/span&gt;
&lt;span&gt;137&lt;/span&gt;   &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; AVGLEN; i++&lt;span&gt;) {  
&lt;/span&gt;&lt;span&gt;138&lt;/span&gt;     insert(&lt;span&gt;250&lt;/span&gt;&lt;span&gt;, avgs, AVGLEN);
&lt;/span&gt;&lt;span&gt;139&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;140&lt;/span&gt; 
&lt;span&gt;141&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Initial values&lt;/span&gt;
&lt;span&gt;142&lt;/span&gt;   high.times = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;143&lt;/span&gt;   high.times_start =&lt;span&gt; millis();
&lt;/span&gt;&lt;span&gt;144&lt;/span&gt;   Color.r = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;  
&lt;/span&gt;&lt;span&gt;145&lt;/span&gt;   Color.g = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;146&lt;/span&gt;   Color.b = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;147&lt;/span&gt; 
&lt;span&gt;148&lt;/span&gt; &lt;span&gt;    Blinker.begin();
&lt;/span&gt;&lt;span&gt;149&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;attach the RGB1 SlidersRGB&lt;/span&gt;
&lt;span&gt;150&lt;/span&gt; &lt;span&gt;    RGB1.attach(rgb1_callback);
&lt;/span&gt;&lt;span&gt;151&lt;/span&gt; &lt;span&gt;    Button1.attach(button1_callback);
&lt;/span&gt;&lt;span&gt;152&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;153&lt;/span&gt; 
&lt;span&gt;154&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;With this we can change the mode if we want to implement a general 
&lt;/span&gt;&lt;span&gt;155&lt;/span&gt; &lt;span&gt;lamp feature, with for instance general pulsing. Maybe if the
&lt;/span&gt;&lt;span&gt;156&lt;/span&gt; &lt;span&gt;sound is low for a while? &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;157&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; loop() {
&lt;/span&gt;&lt;span&gt;158&lt;/span&gt; &lt;span&gt;  Blinker.run();
&lt;/span&gt;&lt;span&gt;159&lt;/span&gt;   
&lt;span&gt;160&lt;/span&gt;   &lt;span&gt;if&lt;/span&gt;(LED_Model == &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;161&lt;/span&gt; &lt;span&gt;    visualize_music();
&lt;/span&gt;&lt;span&gt;162&lt;/span&gt;    
&lt;span&gt;163&lt;/span&gt;   delay(&lt;span&gt;1&lt;/span&gt;);       &lt;span&gt;//&lt;/span&gt;&lt;span&gt; delay in between reads for stability&lt;/span&gt;
&lt;span&gt;164&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;165&lt;/span&gt; 
&lt;span&gt;166&lt;/span&gt; 
&lt;span&gt;167&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*Funtion to check if the lamp should either enter a HIGH mode,
&lt;/span&gt;&lt;span&gt;168&lt;/span&gt; &lt;span&gt;or revert to NORMAL if already in HIGH. If the sensors report values
&lt;/span&gt;&lt;span&gt;169&lt;/span&gt; &lt;span&gt;that are higher than 1.1 times the average values, and this has happened
&lt;/span&gt;&lt;span&gt;170&lt;/span&gt; &lt;span&gt;more than 30 times the last few milliseconds, it will enter HIGH mode. 
&lt;/span&gt;&lt;span&gt;171&lt;/span&gt; &lt;span&gt;TODO: Not very well written, remove hardcoded values, and make it more
&lt;/span&gt;&lt;span&gt;172&lt;/span&gt; &lt;span&gt;reusable and configurable.  &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;173&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; check_high(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; avg) {
&lt;/span&gt;&lt;span&gt;174&lt;/span&gt;   &lt;span&gt;if&lt;/span&gt; (avg &amp;gt; (song_avg/iter * &lt;span&gt;1.1&lt;/span&gt;&lt;span&gt;))  {
&lt;/span&gt;&lt;span&gt;175&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (high.times != &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;176&lt;/span&gt;       &lt;span&gt;if&lt;/span&gt; (millis() - high.times_start &amp;gt; &lt;span&gt;200.0&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;177&lt;/span&gt;         high.times = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;178&lt;/span&gt;         songmode =&lt;span&gt; NORMAL;
&lt;/span&gt;&lt;span&gt;179&lt;/span&gt;       } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;180&lt;/span&gt;         high.times_start =&lt;span&gt; millis();  
&lt;/span&gt;&lt;span&gt;181&lt;/span&gt;         high.times++&lt;span&gt;; 
&lt;/span&gt;&lt;span&gt;182&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt;183&lt;/span&gt;     } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;184&lt;/span&gt;       high.times++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;185&lt;/span&gt;       high.times_start =&lt;span&gt; millis();
&lt;/span&gt;&lt;span&gt;186&lt;/span&gt; 
&lt;span&gt;187&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;188&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;189&lt;/span&gt;   &lt;span&gt;if&lt;/span&gt; (high.times &amp;gt; &lt;span&gt;30&lt;/span&gt; &amp;amp;&amp;amp; millis() - high.times_start &amp;lt; &lt;span&gt;50.0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;190&lt;/span&gt;     songmode =&lt;span&gt; HIGH;
&lt;/span&gt;&lt;span&gt;191&lt;/span&gt;   &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (millis() - high.times_start &amp;gt; &lt;span&gt;200&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;192&lt;/span&gt;     high.times = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;193&lt;/span&gt;     songmode =&lt;span&gt; NORMAL;
&lt;/span&gt;&lt;span&gt;194&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;195&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;196&lt;/span&gt; 
&lt;span&gt;197&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Main function for visualizing the sounds in the lamp&lt;/span&gt;
&lt;span&gt;198&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; visualize_music() {
&lt;/span&gt;&lt;span&gt;199&lt;/span&gt;   &lt;span&gt;int&lt;/span&gt;&lt;span&gt; sensor_value, mapped, avg, longavg;
&lt;/span&gt;&lt;span&gt;200&lt;/span&gt;   
&lt;span&gt;201&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Actual sensor value&lt;/span&gt;
&lt;span&gt;202&lt;/span&gt;   sensor_value =&lt;span&gt; analogRead(ANALOG_READ);
&lt;/span&gt;&lt;span&gt;203&lt;/span&gt; &lt;span&gt;  Serial.println(sensor_value);
&lt;/span&gt;&lt;span&gt;204&lt;/span&gt;   
&lt;span&gt;205&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;If 0, discard immediately. Probably not right and save CPU.&lt;/span&gt;
&lt;span&gt;206&lt;/span&gt;   &lt;span&gt;if&lt;/span&gt; (sensor_value == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;207&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;208&lt;/span&gt; 
&lt;span&gt;209&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Discard readings that deviates too much from the past avg.&lt;/span&gt;
&lt;span&gt;210&lt;/span&gt;   mapped = (&lt;span&gt;float&lt;/span&gt;)fscale(MIC_LOW, MIC_HIGH, MIC_LOW, (&lt;span&gt;float&lt;/span&gt;)MIC_HIGH, (&lt;span&gt;float&lt;/span&gt;)sensor_value, &lt;span&gt;2.0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;211&lt;/span&gt;   avg =&lt;span&gt; compute_average(avgs, AVGLEN);
&lt;/span&gt;&lt;span&gt;212&lt;/span&gt; 
&lt;span&gt;213&lt;/span&gt;   &lt;span&gt;if&lt;/span&gt; (((avg - mapped) &amp;gt; avg*&lt;span&gt;0.8&lt;/span&gt;)) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;|| ((avg - mapped) &amp;lt; -avg*0.8))&lt;/span&gt;
&lt;span&gt;214&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;215&lt;/span&gt;   
&lt;span&gt;216&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Insert new avg. values&lt;/span&gt;
&lt;span&gt;217&lt;/span&gt; &lt;span&gt;  insert(mapped, avgs, AVGLEN); 
&lt;/span&gt;&lt;span&gt;218&lt;/span&gt; &lt;span&gt;  insert(avg, long_avg, LONG_SECTOR); 
&lt;/span&gt;&lt;span&gt;219&lt;/span&gt; 
&lt;span&gt;220&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Compute the &quot;song average&quot; sensor value&lt;/span&gt;
&lt;span&gt;221&lt;/span&gt;   song_avg +=&lt;span&gt; avg;
&lt;/span&gt;&lt;span&gt;222&lt;/span&gt;   iter++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;223&lt;/span&gt;   &lt;span&gt;if&lt;/span&gt; (iter &amp;gt;&lt;span&gt; CYCLES) {  
&lt;/span&gt;&lt;span&gt;224&lt;/span&gt;     song_avg = song_avg /&lt;span&gt; iter;
&lt;/span&gt;&lt;span&gt;225&lt;/span&gt;     iter = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;226&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;227&lt;/span&gt;     
&lt;span&gt;228&lt;/span&gt;   longavg =&lt;span&gt; compute_average(long_avg, LONG_SECTOR);
&lt;/span&gt;&lt;span&gt;229&lt;/span&gt; 
&lt;span&gt;230&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Check if we enter HIGH mode &lt;/span&gt;
&lt;span&gt;231&lt;/span&gt; &lt;span&gt;  check_high(longavg);  
&lt;/span&gt;&lt;span&gt;232&lt;/span&gt; 
&lt;span&gt;233&lt;/span&gt;   &lt;span&gt;if&lt;/span&gt; (songmode ==&lt;span&gt; HIGH) {
&lt;/span&gt;&lt;span&gt;234&lt;/span&gt;     fade_scale = &lt;span&gt;3&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;235&lt;/span&gt;     Color.r = &lt;span&gt;5&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;236&lt;/span&gt;     Color.g = &lt;span&gt;3&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;237&lt;/span&gt;     Color.b = -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;238&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;239&lt;/span&gt;   &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (songmode ==&lt;span&gt; NORMAL) {
&lt;/span&gt;&lt;span&gt;240&lt;/span&gt;     fade_scale = &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;241&lt;/span&gt;     Color.r = -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;242&lt;/span&gt;     Color.b = &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;243&lt;/span&gt;     Color.g = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;244&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;245&lt;/span&gt; 
&lt;span&gt;246&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Decides how many of the LEDs will be lit&lt;/span&gt;
&lt;span&gt;247&lt;/span&gt;   curshow = fscale(MIC_LOW, MIC_HIGH, &lt;span&gt;0.0&lt;/span&gt;, (&lt;span&gt;float&lt;/span&gt;)NUM_LEDS, (&lt;span&gt;float&lt;/span&gt;)avg, -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;248&lt;/span&gt; 
&lt;span&gt;249&lt;/span&gt;   &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;Set the different leds. Control for too high and too low values.
&lt;/span&gt;&lt;span&gt;250&lt;/span&gt; &lt;span&gt;          Fun thing to try: Dont account for overflow in one direction, 
&lt;/span&gt;&lt;span&gt;251&lt;/span&gt; &lt;span&gt;    some interesting light effects appear! &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;252&lt;/span&gt;   &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; NUM_LEDS; i++&lt;span&gt;) 
&lt;/span&gt;&lt;span&gt;253&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;The leds we want to show&lt;/span&gt;
&lt;span&gt;254&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (i &amp;lt;&lt;span&gt; curshow) {
&lt;/span&gt;&lt;span&gt;255&lt;/span&gt;       &lt;span&gt;if&lt;/span&gt; (leds[i].r + Color.r &amp;gt; &lt;span&gt;255&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;256&lt;/span&gt;         leds[i].r = &lt;span&gt;255&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;257&lt;/span&gt;       &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (leds[i].r + Color.r &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;258&lt;/span&gt;         leds[i].r = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;259&lt;/span&gt;       &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;260&lt;/span&gt;         leds[i].r = leds[i].r +&lt;span&gt; Color.r;
&lt;/span&gt;&lt;span&gt;261&lt;/span&gt;           
&lt;span&gt;262&lt;/span&gt;       &lt;span&gt;if&lt;/span&gt; (leds[i].g + Color.g &amp;gt; &lt;span&gt;255&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;263&lt;/span&gt;         leds[i].g = &lt;span&gt;255&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;264&lt;/span&gt;       &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (leds[i].g + Color.g &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;265&lt;/span&gt;         leds[i].g = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;266&lt;/span&gt;       &lt;span&gt;else&lt;/span&gt; 
&lt;span&gt;267&lt;/span&gt;         leds[i].g = leds[i].g +&lt;span&gt; Color.g;
&lt;/span&gt;&lt;span&gt;268&lt;/span&gt; 
&lt;span&gt;269&lt;/span&gt;       &lt;span&gt;if&lt;/span&gt; (leds[i].b + Color.b &amp;gt; &lt;span&gt;255&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;270&lt;/span&gt;         leds[i].b = &lt;span&gt;255&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;271&lt;/span&gt;       &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (leds[i].b + Color.b &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;272&lt;/span&gt;         leds[i].b = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;273&lt;/span&gt;       &lt;span&gt;else&lt;/span&gt; 
&lt;span&gt;274&lt;/span&gt;         leds[i].b = leds[i].b +&lt;span&gt; Color.b;  
&lt;/span&gt;&lt;span&gt;275&lt;/span&gt;       
&lt;span&gt;276&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;All the other LEDs begin their fading journey to eventual total darkness&lt;/span&gt;
&lt;span&gt;277&lt;/span&gt;     } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;278&lt;/span&gt;       leds[i] = CRGB(leds[i].r/fade_scale, leds[i].g/fade_scale, leds[i].b/&lt;span&gt;fade_scale);
&lt;/span&gt;&lt;span&gt;279&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;280&lt;/span&gt; &lt;span&gt;  FastLED.show(); 
&lt;/span&gt;&lt;span&gt;281&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;282&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Compute average of a int array, given the starting pointer and the length&lt;/span&gt;
&lt;span&gt;283&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; compute_average(&lt;span&gt;int&lt;/span&gt; *avgs, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; len) {
&lt;/span&gt;&lt;span&gt;284&lt;/span&gt;   &lt;span&gt;int&lt;/span&gt; sum = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;285&lt;/span&gt;   &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; len; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;286&lt;/span&gt;     sum +=&lt;span&gt; avgs[i];
&lt;/span&gt;&lt;span&gt;287&lt;/span&gt; 
&lt;span&gt;288&lt;/span&gt;   &lt;span&gt;return&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt;)(sum /&lt;span&gt; len);
&lt;/span&gt;&lt;span&gt;289&lt;/span&gt; 
&lt;span&gt;290&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;291&lt;/span&gt; 
&lt;span&gt;292&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Insert a value into an array, and shift it down removing
&lt;/span&gt;&lt;span&gt;293&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;the first value if array already full &lt;/span&gt;
&lt;span&gt;294&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; insert(&lt;span&gt;int&lt;/span&gt; val, &lt;span&gt;int&lt;/span&gt; *avgs, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; len) {
&lt;/span&gt;&lt;span&gt;295&lt;/span&gt;   &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; len; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;296&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (avgs[i] == -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;297&lt;/span&gt;       avgs[i] =&lt;span&gt; val;
&lt;/span&gt;&lt;span&gt;298&lt;/span&gt;       &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;299&lt;/span&gt; &lt;span&gt;    }  
&lt;/span&gt;&lt;span&gt;300&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;301&lt;/span&gt; 
&lt;span&gt;302&lt;/span&gt;   &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt; len; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;303&lt;/span&gt;     avgs[i - &lt;span&gt;1&lt;/span&gt;] =&lt;span&gt; avgs[i];
&lt;/span&gt;&lt;span&gt;304&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;305&lt;/span&gt;   avgs[len - &lt;span&gt;1&lt;/span&gt;] =&lt;span&gt; val;
&lt;/span&gt;&lt;span&gt;306&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;307&lt;/span&gt; 
&lt;span&gt;308&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Function imported from the arduino website.
&lt;/span&gt;&lt;span&gt;309&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Basically map, but with a curve on the scale (can be non-uniform).&lt;/span&gt;
&lt;span&gt;310&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; fscale( &lt;span&gt;float&lt;/span&gt; originalMin, &lt;span&gt;float&lt;/span&gt; originalMax, &lt;span&gt;float&lt;/span&gt; newBegin, &lt;span&gt;float&lt;/span&gt;
&lt;span&gt;311&lt;/span&gt;     newEnd, &lt;span&gt;float&lt;/span&gt; inputValue, &lt;span&gt;float&lt;/span&gt;&lt;span&gt; curve){
&lt;/span&gt;&lt;span&gt;312&lt;/span&gt; 
&lt;span&gt;313&lt;/span&gt;   &lt;span&gt;float&lt;/span&gt; OriginalRange = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;314&lt;/span&gt;   &lt;span&gt;float&lt;/span&gt; NewRange = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;315&lt;/span&gt;   &lt;span&gt;float&lt;/span&gt; zeroRefCurVal = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;316&lt;/span&gt;   &lt;span&gt;float&lt;/span&gt; normalizedCurVal = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;317&lt;/span&gt;   &lt;span&gt;float&lt;/span&gt; rangedValue = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;318&lt;/span&gt;   boolean invFlag = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;319&lt;/span&gt; 
&lt;span&gt;320&lt;/span&gt; 
&lt;span&gt;321&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; condition curve parameter
&lt;/span&gt;&lt;span&gt;322&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; limit range&lt;/span&gt;
&lt;span&gt;323&lt;/span&gt; 
&lt;span&gt;324&lt;/span&gt;   &lt;span&gt;if&lt;/span&gt; (curve &amp;gt; &lt;span&gt;10&lt;/span&gt;) curve = &lt;span&gt;10&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;325&lt;/span&gt;   &lt;span&gt;if&lt;/span&gt; (curve &amp;lt; -&lt;span&gt;10&lt;/span&gt;) curve = -&lt;span&gt;10&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;326&lt;/span&gt; 
&lt;span&gt;327&lt;/span&gt;   curve = (curve * -.&lt;span&gt;1&lt;/span&gt;) ; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; - invert and scale - this seems more intuitive - postive numbers give more weight to high end on output &lt;/span&gt;
&lt;span&gt;328&lt;/span&gt;   curve = pow(&lt;span&gt;10&lt;/span&gt;, curve); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; convert linear scale into lograthimic exponent for other pow function
&lt;/span&gt;&lt;span&gt;329&lt;/span&gt; 
&lt;span&gt;330&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Check for out of range inputValues&lt;/span&gt;
&lt;span&gt;331&lt;/span&gt;   &lt;span&gt;if&lt;/span&gt; (inputValue &amp;lt;&lt;span&gt; originalMin) {
&lt;/span&gt;&lt;span&gt;332&lt;/span&gt;     inputValue =&lt;span&gt; originalMin;
&lt;/span&gt;&lt;span&gt;333&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;334&lt;/span&gt;   &lt;span&gt;if&lt;/span&gt; (inputValue &amp;gt;&lt;span&gt; originalMax) {
&lt;/span&gt;&lt;span&gt;335&lt;/span&gt;     inputValue =&lt;span&gt; originalMax;
&lt;/span&gt;&lt;span&gt;336&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;337&lt;/span&gt; 
&lt;span&gt;338&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Zero Refference the values&lt;/span&gt;
&lt;span&gt;339&lt;/span&gt;   OriginalRange = originalMax -&lt;span&gt; originalMin;
&lt;/span&gt;&lt;span&gt;340&lt;/span&gt; 
&lt;span&gt;341&lt;/span&gt;   &lt;span&gt;if&lt;/span&gt; (newEnd &amp;gt;&lt;span&gt; newBegin){ 
&lt;/span&gt;&lt;span&gt;342&lt;/span&gt;     NewRange = newEnd -&lt;span&gt; newBegin;
&lt;/span&gt;&lt;span&gt;343&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;344&lt;/span&gt;   &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;345&lt;/span&gt; &lt;span&gt;  {
&lt;/span&gt;&lt;span&gt;346&lt;/span&gt;     NewRange = newBegin -&lt;span&gt; newEnd; 
&lt;/span&gt;&lt;span&gt;347&lt;/span&gt;     invFlag = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;348&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;349&lt;/span&gt; 
&lt;span&gt;350&lt;/span&gt;   zeroRefCurVal = inputValue -&lt;span&gt; originalMin;
&lt;/span&gt;&lt;span&gt;351&lt;/span&gt;   normalizedCurVal  =  zeroRefCurVal / OriginalRange;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; normalize to 0 - 1 float
&lt;/span&gt;&lt;span&gt;352&lt;/span&gt; 
&lt;span&gt;353&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Check for originalMin &amp;gt; originalMax  - the math for all other cases i.e. negative numbers seems to work out fine &lt;/span&gt;
&lt;span&gt;354&lt;/span&gt;   &lt;span&gt;if&lt;/span&gt; (originalMin &amp;gt;&lt;span&gt; originalMax ) {
&lt;/span&gt;&lt;span&gt;355&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;356&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;357&lt;/span&gt; 
&lt;span&gt;358&lt;/span&gt;   &lt;span&gt;if&lt;/span&gt; (invFlag == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;359&lt;/span&gt;     rangedValue =  (pow(normalizedCurVal, curve) * NewRange) +&lt;span&gt; newBegin;
&lt;/span&gt;&lt;span&gt;360&lt;/span&gt; 
&lt;span&gt;361&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;362&lt;/span&gt;   &lt;span&gt;else&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; invert the ranges&lt;/span&gt;
&lt;span&gt;363&lt;/span&gt; &lt;span&gt;  {   
&lt;/span&gt;&lt;span&gt;364&lt;/span&gt;     rangedValue =  newBegin - (pow(normalizedCurVal, curve) *&lt;span&gt; NewRange); 
&lt;/span&gt;&lt;span&gt;365&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;366&lt;/span&gt; 
&lt;span&gt;367&lt;/span&gt;   &lt;span&gt;return&lt;/span&gt;&lt;span&gt; rangedValue;
&lt;/span&gt;&lt;span&gt;368&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上述代码编译无误后上传到Arduino UNO即可。&lt;/p&gt;
&lt;h3&gt;3.4 下载并使用Blinker软件连接&lt;/h3&gt;
&lt;p&gt;　　Blinker软件的安装包可以在官网上找到：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1228291/201812/1228291-20181218212641568-1083291784.png&quot; alt=&quot;&quot; width=&quot;600&quot;/&gt;&lt;/p&gt;
&lt;p&gt;安装好之后注册账号，登陆，在主页面右上角选择--&amp;gt;添加设备--&amp;gt;Arduino--&amp;gt;蓝牙接入，然后会自动发现我们的蓝牙，连接上之后，如图。&lt;/p&gt;
&lt;p&gt;                                                                                           &lt;img src=&quot;https://img2018.cnblogs.com/blog/1228291/201812/1228291-20181218213104043-408136393.png&quot; alt=&quot;&quot; width=&quot;200&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面表示是否已经连接，现在表示已连接。然后添加上面的两个组件，编辑组件参数如下：&lt;/p&gt;


&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1228291/201812/1228291-20181218213234008-640513673.png&quot; alt=&quot;&quot; width=&quot;200&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1228291/201812/1228291-20181218213301712-116209402.png&quot; alt=&quot;&quot; width=&quot;200&quot;/&gt;&lt;/p&gt;
&lt;p&gt;完成之后便可以通过RGB滑条来控制颜色，通过模式按钮来控制灯的模式。&lt;/p&gt;
&lt;h3&gt;3.5 灯的组装&lt;/h3&gt;
&lt;p&gt; 　　我是自己在网上买的灯罩，然后根据自己的需求3D打印的底座，大家可以发挥自己的想象力来创作出不一样的外观~&lt;/p&gt;
&lt;p&gt;　然后来一波安装完成的照片：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1228291/201812/1228291-20181218213623344-518095696.png&quot; alt=&quot;&quot; width=&quot;400&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后更新一波实测视频（由于不能同时录像和控制，所以只放了节奏灯效果）：&lt;/p&gt;
&lt;p&gt;地址：https://www.bilibili.com/video/av38471827/&lt;/p&gt;









</description>
<pubDate>Tue, 18 Dec 2018 15:12:00 +0000</pubDate>
<dc:creator>zutterhao</dc:creator>
<og:description>Arduino 音乐节奏灯</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zutterhao/p/10140172.html</dc:identifier>
</item>
<item>
<title>作为IT，你的价值在哪里？ - SAP梦心</title>
<link>http://www.cnblogs.com/saper/p/10140736.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/saper/p/10140736.html</guid>
<description>&lt;p&gt;也许最近是真的被无穷无尽的数据整理、导入、再整理、再导入给恶心到了。&lt;/p&gt;

&lt;p&gt;业务部提交的数据只是一个非常初始的数据，IT还得在这个基础上七整八整，对导出的结果还要再做二次导入三次导入，不仅要帮业务部批导生成销售订单，连着交货、交货过账都得一并处理。十多万笔的数据要在年底之前全部导入系统中，做到分毫不差，而且完成之后还要校验数据的正确性。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/41253/201812/41253-20181218232139639-552380252.jpg&quot; alt=&quot;&quot; width=&quot;636&quot; height=&quot;424&quot;/&gt; &lt;/p&gt;

&lt;p&gt; 看着SAP系统在忙碌得转着转着，拼命导入数据。等待之余，&lt;strong&gt;我在想，作为IT，你的价值在哪里？为什么会陷入数据整理的茫茫大海中没有方向？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;想起几年前在KB公司供职的情形，那边的信息化比较落后。每个月员工食堂的消费数据都是IT从在一卡通系统中下载汇聚到总公司的数据库，然后再导出来到本地，在Excel里经过汇总加工，利用公式得出每个人当月的消费数据，然后再提供给人资去做工资扣款。因为数据非常庞大，再加上公司网络环境比较差，收集整理消费数据就占用掉了IT非常多的时间，导致处理人员每个月前后十天都很忙。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/41253/201812/41253-20181218232152372-346670016.jpg&quot; alt=&quot;&quot; width=&quot;626&quot; height=&quot;334&quot;/&gt;&lt;/p&gt;

&lt;p&gt;但是，&lt;strong&gt;他们很乐于陷入这种毫无意义而且重复性高的数据收集整理的工作当中，只是看起来很忙而已，在我看来这种工作毫无价值&lt;/strong&gt;。更可怕的是人的固有思维导致他们根本没有意识问题，意识到该去改善这种繁杂的事务。&lt;/p&gt;

&lt;p&gt;后来一卡通经过我一系列的程序处理和流程优化，工作效率直接从之前的10天处理时间变成0，IT从此不需要再关心它。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/41253/201812/41253-20181218232206116-230080433.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;参看当初的博文：&lt;/p&gt;
&lt;p&gt;https://www.cnblogs.com/saper/p/5625289.html &lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我想说的是，作为IT，&lt;strong&gt;我们的价值就应该体现在能够根据企业的业务发展和管理需求的变化而制定出合理可执行的信息化解决方案&lt;/strong&gt;&lt;strong&gt;，改善用户的操作效率和体验，使系统使用更加顺畅，使数据更加精准&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;如果IT整天在帮业务部门收集、整理业务数据和擦屁股，惯着业务部门做着自己不擅长的工作，做着不是自己份内的事情，活生生把自己培养成业务部的保姆或下手，整天看起来很忙的样子，不仅丝毫没有价值，而且还吃力不讨好。&lt;/p&gt;

&lt;p&gt;最后：从审计的角度来说，&lt;strong&gt;IT是不能在系统中创建和修改业务数据的，这不符合审计要求（系统上线导入期初数据的情况除外）。而且，IT不能对要批导的业务数据做加工处理，也没办法对业务数据的准确性负责&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/41253/201812/41253-20181218232216566-509691714.jpg&quot; alt=&quot;&quot; width=&quot;686&quot; height=&quot;457&quot;/&gt;&lt;/p&gt;





&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/41253/201812/41253-20181218232315480-245803825.png&quot; alt=&quot;&quot; width=&quot;718&quot; height=&quot;381&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 18 Dec 2018 15:05:00 +0000</pubDate>
<dc:creator>SAP梦心</dc:creator>
<og:description>也许最近是真的被无穷无尽的数据整理、导入、再整理、再导入给恶心到了。 业务部提交的数据只是一个非常初始的数据，IT还得在这个基础上七整八整，对导出的结果还要再做二次导入三次导入，不仅要帮业务部批导生成</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/saper/p/10140736.html</dc:identifier>
</item>
<item>
<title>【.NET Core项目实战-统一认证平台】第十一章 授权篇-密码授权模式 - 金焰的世界</title>
<link>http://www.cnblogs.com/jackcao/p/10140688.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jackcao/p/10140688.html</guid>
<description>&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;上篇文章介绍了基于&lt;code&gt;Ids4&lt;/code&gt;客户端授权的原理及如何实现自定义的客户端授权，并配合网关实现了统一的授权异常返回值和权限配置等相关功能，本篇将介绍密码授权模式，从使用场景、源码剖析到具体实现详细讲解密码授权模式的相关应用。&lt;/p&gt;
&lt;p&gt;.netcore项目实战交流群（637326624），有兴趣的朋友可以在群里交流讨论。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一使用场景&quot;&gt;一、使用场景？&lt;/h2&gt;
&lt;p&gt;由于密码授权模式需要用户在业务系统输入账号密码，为了安全起见，对于使用密码模式的业务系统，我们认为是绝对可靠的，不存在泄漏用户名和密码的风险，所以使用场景定位为公司内部系统或集团内部系统或公司内部app等内部应用，非内部应用，尽量不要开启密码授权模式，防止用户账户泄漏。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;这种模式适用于用户对应用程序高度信任的情况。比如是用户系统的一部分。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;二ids4密码模式的默认实现剖析&quot;&gt;二、Ids4密码模式的默认实现剖析&lt;/h2&gt;
&lt;p&gt;在我们使用密码授权模式之前，我们需要理解密码模式是如何实现的，在上一篇中，我介绍了客户端授权的实现及源码剖析，相信我们已经对&lt;code&gt;Ids4&lt;/code&gt;客户端授权已经熟悉，今天继续分析密码模式是如何获取到令牌的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Ids4&lt;/code&gt;的所有授权都在&lt;code&gt;TokenEndpoint&lt;/code&gt;方法中，密码模式授权也是先校验客户端授权，如果客户端校验失败，直接返回删除信息，如果客户端校验成功，继续校验用户名和密码，详细实现代码如下。&lt;/p&gt;
&lt;ul readability=&quot;61&quot;&gt;&lt;li readability=&quot;16&quot;&gt;
&lt;p&gt;1、校验是否存在&lt;code&gt;grantType&lt;/code&gt;，然后根据不同的类型启用不同的校验方式。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;// TokenRequestValidator.cs
public async Task&amp;lt;TokenRequestValidationResult&amp;gt; ValidateRequestAsync(NameValueCollection parameters, ClientSecretValidationResult clientValidationResult)
{
  _logger.LogDebug(&quot;Start token request validation&quot;);

  _validatedRequest = new ValidatedTokenRequest
  {
      Raw = parameters ?? throw new ArgumentNullException(nameof(parameters)),
      Options = _options
  };

  if (clientValidationResult == null) throw new ArgumentNullException(nameof(clientValidationResult));

  _validatedRequest.SetClient(clientValidationResult.Client, clientValidationResult.Secret, clientValidationResult.Confirmation);

  /////////////////////////////////////////////
  // check client protocol type
  /////////////////////////////////////////////
  if (_validatedRequest.Client.ProtocolType != IdentityServerConstants.ProtocolTypes.OpenIdConnect)
  {
      LogError(&quot;Client {clientId} has invalid protocol type for token endpoint: expected {expectedProtocolType} but found {protocolType}&quot;,
               _validatedRequest.Client.ClientId,
               IdentityServerConstants.ProtocolTypes.OpenIdConnect,
               _validatedRequest.Client.ProtocolType);
      return Invalid(OidcConstants.TokenErrors.InvalidClient);
  }

  /////////////////////////////////////////////
  // check grant type
  /////////////////////////////////////////////
  var grantType = parameters.Get(OidcConstants.TokenRequest.GrantType);
  if (grantType.IsMissing())
  {
      LogError(&quot;Grant type is missing&quot;);
      return Invalid(OidcConstants.TokenErrors.UnsupportedGrantType);
  }

  if (grantType.Length &amp;gt; _options.InputLengthRestrictions.GrantType)
  {
      LogError(&quot;Grant type is too long&quot;);
      return Invalid(OidcConstants.TokenErrors.UnsupportedGrantType);
  }

  _validatedRequest.GrantType = grantType;

  switch (grantType)
  {
      case OidcConstants.GrantTypes.AuthorizationCode:
          return await RunValidationAsync(ValidateAuthorizationCodeRequestAsync, parameters);
      case OidcConstants.GrantTypes.ClientCredentials:
          return await RunValidationAsync(ValidateClientCredentialsRequestAsync, parameters);
      case OidcConstants.GrantTypes.Password:  //1、密码授权模式调用方法
          return await RunValidationAsync(ValidateResourceOwnerCredentialRequestAsync, parameters);
      case OidcConstants.GrantTypes.RefreshToken:
          return await RunValidationAsync(ValidateRefreshTokenRequestAsync, parameters);
      default:
          return await RunValidationAsync(ValidateExtensionGrantRequestAsync, parameters);
  }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;22&quot;&gt;
&lt;p&gt;2、启用密码授权模式校验规则，首先校验传输的参数和&lt;code&gt;scope&lt;/code&gt;是否存在，然后校验用户名密码是否准确，最后校验用户是否可用。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;private async Task&amp;lt;TokenRequestValidationResult&amp;gt; ValidateResourceOwnerCredentialRequestAsync(NameValueCollection parameters)
{
    _logger.LogDebug(&quot;Start resource owner password token request validation&quot;);

    /////////////////////////////////////////////
    // 校验授权模式
    /////////////////////////////////////////////
    if (!_validatedRequest.Client.AllowedGrantTypes.Contains(GrantType.ResourceOwnerPassword))
    {
        LogError(&quot;{clientId} not authorized for resource owner flow, check the AllowedGrantTypes of client&quot;, _validatedRequest.Client.ClientId);
        return Invalid(OidcConstants.TokenErrors.UnauthorizedClient);
    }

    /////////////////////////////////////////////
    // 校验客户端是否允许这些scope
    /////////////////////////////////////////////
    if (!(await ValidateRequestedScopesAsync(parameters)))
    {
        return Invalid(OidcConstants.TokenErrors.InvalidScope);
    }

    /////////////////////////////////////////////
    // 校验参数是否为定义的用户名或密码参数
    /////////////////////////////////////////////
    var userName = parameters.Get(OidcConstants.TokenRequest.UserName);
    var password = parameters.Get(OidcConstants.TokenRequest.Password);

    if (userName.IsMissing() || password.IsMissing())
    {
        LogError(&quot;Username or password missing&quot;);
        return Invalid(OidcConstants.TokenErrors.InvalidGrant);
    }

    if (userName.Length &amp;gt; _options.InputLengthRestrictions.UserName ||
        password.Length &amp;gt; _options.InputLengthRestrictions.Password)
    {
        LogError(&quot;Username or password too long&quot;);
        return Invalid(OidcConstants.TokenErrors.InvalidGrant);
    }

    _validatedRequest.UserName = userName;


    /////////////////////////////////////////////
    // 校验用户名和密码是否准确
    /////////////////////////////////////////////
    var resourceOwnerContext = new ResourceOwnerPasswordValidationContext
    {
        UserName = userName,
        Password = password,
        Request = _validatedRequest
    };
    //默认使用的是 TestUserResourceOwnerPasswordValidator
    await _resourceOwnerValidator.ValidateAsync(resourceOwnerContext);

    if (resourceOwnerContext.Result.IsError)
    {
        if (resourceOwnerContext.Result.Error == OidcConstants.TokenErrors.UnsupportedGrantType)
        {
            LogError(&quot;Resource owner password credential grant type not supported&quot;);
            await RaiseFailedResourceOwnerAuthenticationEventAsync(userName, &quot;password grant type not supported&quot;);

            return Invalid(OidcConstants.TokenErrors.UnsupportedGrantType, customResponse: resourceOwnerContext.Result.CustomResponse);
        }

        var errorDescription = &quot;invalid_username_or_password&quot;;

        if (resourceOwnerContext.Result.ErrorDescription.IsPresent())
        {
            errorDescription = resourceOwnerContext.Result.ErrorDescription;
        }

        LogInfo(&quot;User authentication failed: {error}&quot;, errorDescription ?? resourceOwnerContext.Result.Error);
        await RaiseFailedResourceOwnerAuthenticationEventAsync(userName, errorDescription);

        return Invalid(resourceOwnerContext.Result.Error, errorDescription, resourceOwnerContext.Result.CustomResponse);
    }

    if (resourceOwnerContext.Result.Subject == null)
    {
        var error = &quot;User authentication failed: no principal returned&quot;;
        LogError(error);
        await RaiseFailedResourceOwnerAuthenticationEventAsync(userName, error);

        return Invalid(OidcConstants.TokenErrors.InvalidGrant);
    }

    /////////////////////////////////////////////
    // 设置用户可用,比如用户授权后被锁定，可以通过此方法实现 默认实现 TestUserProfileService
    /////////////////////////////////////////////
    var isActiveCtx = new IsActiveContext(resourceOwnerContext.Result.Subject, _validatedRequest.Client, IdentityServerConstants.ProfileIsActiveCallers.ResourceOwnerValidation);
    await _profile.IsActiveAsync(isActiveCtx);

    if (isActiveCtx.IsActive == false)
    {
        LogError(&quot;User has been disabled: {subjectId}&quot;, resourceOwnerContext.Result.Subject.GetSubjectId());
        await RaiseFailedResourceOwnerAuthenticationEventAsync(userName, &quot;user is inactive&quot;);

        return Invalid(OidcConstants.TokenErrors.InvalidGrant);
    }

    _validatedRequest.UserName = userName;
    _validatedRequest.Subject = resourceOwnerContext.Result.Subject;

    await RaiseSuccessfulResourceOwnerAuthenticationEventAsync(userName, resourceOwnerContext.Result.Subject.GetSubjectId());
    _logger.LogDebug(&quot;Resource owner password token request validation success.&quot;);
    return Valid(resourceOwnerContext.Result.CustomResponse);
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;13&quot;&gt;
&lt;p&gt;3、运行自定义上下文验证&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;private async Task&amp;lt;TokenRequestValidationResult&amp;gt; RunValidationAsync(Func&amp;lt;NameValueCollection, Task&amp;lt;TokenRequestValidationResult&amp;gt;&amp;gt; validationFunc, NameValueCollection parameters)
{
    // 执行步骤2验证
    var result = await validationFunc(parameters);
    if (result.IsError)
    {
        return result;
    }

    // 运行自定义验证，Ids4 默认有个 DefaultCustomTokenRequestValidator 实现，如果需要扩充其他验证，可以集成ICustomTokenRequestValidator单独实现。
    _logger.LogTrace(&quot;Calling into custom request validator: {type}&quot;, _customRequestValidator.GetType().FullName);

    var customValidationContext = new CustomTokenRequestValidationContext { Result = result };
    await _customRequestValidator.ValidateAsync(customValidationContext);

    if (customValidationContext.Result.IsError)
    {
        if (customValidationContext.Result.Error.IsPresent())
        {
            LogError(&quot;Custom token request validator error {error}&quot;, customValidationContext.Result.Error);
        }
        else
        {
            LogError(&quot;Custom token request validator error&quot;);
        }

        return customValidationContext.Result;
    }

    LogSuccess();
    return customValidationContext.Result;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过源码剖析可以发现，&lt;code&gt;Ids4&lt;/code&gt;给了我们很多的验证方式，并且默认也实现的验证和自定义的扩展，这样如果我们需要使用密码授权模式，就可以重写&lt;code&gt;IResourceOwnerPasswordValidator&lt;/code&gt;来实现系统内部用户系统的验证需求。如果需要确认用户在登录以后是否被注销时，可以重写&lt;code&gt;IProfileService&lt;/code&gt;接口实现，这个验证主要是生成token校验时检查。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;24&quot;&gt;
&lt;p&gt;4、最终生成Token&lt;/p&gt;
&lt;p&gt;根据不同的授权模式，生成不同的token记录。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// Processes the response.
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;param name=&quot;request&quot;&amp;gt;The request.&amp;lt;/param&amp;gt;
/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
public virtual async Task&amp;lt;TokenResponse&amp;gt; ProcessAsync(TokenRequestValidationResult request)
{
    switch (request.ValidatedRequest.GrantType)
    {
        case OidcConstants.GrantTypes.ClientCredentials:
            return await ProcessClientCredentialsRequestAsync(request);
        case OidcConstants.GrantTypes.Password: //生成密码授权模式token
            return await ProcessPasswordRequestAsync(request);
        case OidcConstants.GrantTypes.AuthorizationCode:
            return await ProcessAuthorizationCodeRequestAsync(request);
        case OidcConstants.GrantTypes.RefreshToken:
            return await ProcessRefreshTokenRequestAsync(request);
        default:
            return await ProcessExtensionGrantRequestAsync(request);
    }
}

/// &amp;lt;summary&amp;gt;
/// Creates the response for a password request.
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;param name=&quot;request&quot;&amp;gt;The request.&amp;lt;/param&amp;gt;
/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
protected virtual Task&amp;lt;TokenResponse&amp;gt; ProcessPasswordRequestAsync(TokenRequestValidationResult request)
{
    Logger.LogTrace(&quot;Creating response for password request&quot;);

    return ProcessTokenRequestAsync(request);
}

/// &amp;lt;summary&amp;gt;
/// Creates the response for a token request.
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;param name=&quot;validationResult&quot;&amp;gt;The validation result.&amp;lt;/param&amp;gt;
/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
protected virtual async Task&amp;lt;TokenResponse&amp;gt; ProcessTokenRequestAsync(TokenRequestValidationResult validationResult)
{
    (var accessToken, var refreshToken) = await CreateAccessTokenAsync(validationResult.ValidatedRequest);
    var response = new TokenResponse
    {
        AccessToken = accessToken,
        AccessTokenLifetime = validationResult.ValidatedRequest.AccessTokenLifetime,
        Custom = validationResult.CustomResponse
    };

    if (refreshToken.IsPresent())
    {
        response.RefreshToken = refreshToken;
    }

    return response;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;根据请求的&lt;code&gt;scope&lt;/code&gt;判断是否生成&lt;code&gt;refreshToken&lt;/code&gt;，如果标记了&lt;code&gt;offline_access&lt;/code&gt;，则生成&lt;code&gt;refreshToken&lt;/code&gt;，否则不生成。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// Creates the access/refresh token.
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;param name=&quot;request&quot;&amp;gt;The request.&amp;lt;/param&amp;gt;
/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
/// &amp;lt;exception cref=&quot;System.InvalidOperationException&quot;&amp;gt;Client does not exist anymore.&amp;lt;/exception&amp;gt;
protected virtual async Task&amp;lt;(string accessToken, string refreshToken)&amp;gt; CreateAccessTokenAsync(ValidatedTokenRequest request)
{
    TokenCreationRequest tokenRequest;
    bool createRefreshToken;
  //授权码模式
    if (request.AuthorizationCode != null)
    {//是否包含RefreshToken
        createRefreshToken = request.AuthorizationCode.RequestedScopes.Contains(IdentityServerConstants.StandardScopes.OfflineAccess);

        // load the client that belongs to the authorization code
        Client client = null;
        if (request.AuthorizationCode.ClientId != null)
        {
            client = await Clients.FindEnabledClientByIdAsync(request.AuthorizationCode.ClientId);
        }
        if (client == null)
        {
            throw new InvalidOperationException(&quot;Client does not exist anymore.&quot;);
        }

        var resources = await Resources.FindEnabledResourcesByScopeAsync(request.AuthorizationCode.RequestedScopes);

        tokenRequest = new TokenCreationRequest
        {
            Subject = request.AuthorizationCode.Subject,
            Resources = resources,
            ValidatedRequest = request
        };
    }
    else
    {//是否包含RefreshToken
        createRefreshToken = request.ValidatedScopes.ContainsOfflineAccessScope;

        tokenRequest = new TokenCreationRequest
        {
            Subject = request.Subject,
            Resources = request.ValidatedScopes.GrantedResources,
            ValidatedRequest = request
        };
    }

    var at = await TokenService.CreateAccessTokenAsync(tokenRequest);
    var accessToken = await TokenService.CreateSecurityTokenAsync(at);

    if (createRefreshToken)
    {
        var refreshToken = await RefreshTokenService.CreateRefreshTokenAsync(tokenRequest.Subject, at, request.Client);
        return (accessToken, refreshToken);
    }

    return (accessToken, null);
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;38&quot;&gt;
&lt;p&gt;5、RefreshToken持久化&lt;/p&gt;
&lt;p&gt;当我们使用了&lt;code&gt;offline_access&lt;/code&gt;时，就需要生成&lt;code&gt;RefreshToken&lt;/code&gt;并进行持久化，详细的实现代码如下。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public virtual async Task&amp;lt;string&amp;gt; CreateRefreshTokenAsync(ClaimsPrincipal subject, Token accessToken, Client client)
{
    _logger.LogDebug(&quot;Creating refresh token&quot;);

    int lifetime;
    if (client.RefreshTokenExpiration == TokenExpiration.Absolute)
    {
        _logger.LogDebug(&quot;Setting an absolute lifetime: &quot; + client.AbsoluteRefreshTokenLifetime);
        lifetime = client.AbsoluteRefreshTokenLifetime;
    }
    else
    {
        _logger.LogDebug(&quot;Setting a sliding lifetime: &quot; + client.SlidingRefreshTokenLifetime);
        lifetime = client.SlidingRefreshTokenLifetime;
    }

    var refreshToken = new RefreshToken
    {
        CreationTime = Clock.UtcNow.UtcDateTime,
        Lifetime = lifetime,
        AccessToken = accessToken
    };
  //存储RefreshToken并返回值
    var handle = await RefreshTokenStore.StoreRefreshTokenAsync(refreshToken);
    return handle;
}

/// &amp;lt;summary&amp;gt;
/// 存储RefreshToken并返回
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;param name=&quot;refreshToken&quot;&amp;gt;The refresh token.&amp;lt;/param&amp;gt;
/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
public async Task&amp;lt;string&amp;gt; StoreRefreshTokenAsync(RefreshToken refreshToken)
{
    return await CreateItemAsync(refreshToken, refreshToken.ClientId, refreshToken.SubjectId, refreshToken.CreationTime, refreshToken.Lifetime);
}

/// &amp;lt;summary&amp;gt;
/// 创建Item
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;param name=&quot;item&quot;&amp;gt;The item.&amp;lt;/param&amp;gt;
/// &amp;lt;param name=&quot;clientId&quot;&amp;gt;The client identifier.&amp;lt;/param&amp;gt;
/// &amp;lt;param name=&quot;subjectId&quot;&amp;gt;The subject identifier.&amp;lt;/param&amp;gt;
/// &amp;lt;param name=&quot;created&quot;&amp;gt;The created.&amp;lt;/param&amp;gt;
/// &amp;lt;param name=&quot;lifetime&quot;&amp;gt;The lifetime.&amp;lt;/param&amp;gt;
/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
protected virtual async Task&amp;lt;string&amp;gt; CreateItemAsync(T item, string clientId, string subjectId, DateTime created, int lifetime)
{
    var handle = await HandleGenerationService.GenerateAsync(); //生成随机值
    await StoreItemAsync(handle, item, clientId, subjectId, created, created.AddSeconds(lifetime)); //存储
    return handle;
}

/// &amp;lt;summary&amp;gt;
/// 存储RefreshToken
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;param name=&quot;key&quot;&amp;gt;The key.&amp;lt;/param&amp;gt;
/// &amp;lt;param name=&quot;item&quot;&amp;gt;The item.&amp;lt;/param&amp;gt;
/// &amp;lt;param name=&quot;clientId&quot;&amp;gt;The client identifier.&amp;lt;/param&amp;gt;
/// &amp;lt;param name=&quot;subjectId&quot;&amp;gt;The subject identifier.&amp;lt;/param&amp;gt;
/// &amp;lt;param name=&quot;created&quot;&amp;gt;The created.&amp;lt;/param&amp;gt;
/// &amp;lt;param name=&quot;expiration&quot;&amp;gt;The expiration.&amp;lt;/param&amp;gt;
/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
protected virtual async Task StoreItemAsync(string key, T item, string clientId, string subjectId, DateTime created, DateTime? expiration)
{
    key = GetHashedKey(key);

    var json = Serializer.Serialize(item);

    var grant = new PersistedGrant
    {
        Key = key,
        Type = GrantType,
        ClientId = clientId,
        SubjectId = subjectId,
        CreationTime = created,
        Expiration = expiration,
        Data = json
    };

    await Store.StoreAsync(grant);
}

//IPersistedGrantStore 我们在dapper持久化时已经实现了StoreAsync方式，是不是都关联起来了。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;至此，我们整个密码授权模式全部讲解完成，相信大家跟我一样完全掌握了授权的整个流程，如果需要持久化如何进行持久化流程。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;理解了完整的密码授权模式流程后，使用自定义的用户体系就得心应手了，下面就开始完整的实现自定义帐户授权。&lt;/p&gt;
&lt;h2 id=&quot;三设计自定义的账户信息并应用&quot;&gt;三、设计自定义的账户信息并应用&lt;/h2&gt;
&lt;p&gt;为了演示方便，我这里就设计简单的用户帐户信息，作为自定义的哦帐户基础，如果正式环境中使用，请根据各自业务使用各自的帐户体系即可。&lt;/p&gt;
&lt;pre class=&quot;mssql&quot;&gt;
&lt;code&gt;-- 创建用户表
CREATE TABLE CzarUsers
(
    Uid INT IDENTITY(1,1),            --用户主键    
    uAccount varchar(11),             --用户账号
    uPassword varchar(200),           --用户密码
    uNickName varchar(50),            --用户昵称
    uMobile varchar(11),              --用户手机号
    uEmail varchar(100),              --用户邮箱
    uStatus int not null default(1)   -- 用户状态 1 正常 0 不可用
)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;添加用户实体代码如下所示。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// 授权用户信息
/// &amp;lt;/summary&amp;gt;
public class CzarUsers
{
    public CzarUsers() { }

    public int Uid { get; set; }
    public string uAccount { get; set; }
    public string uPassword { get; set; }
    public string uNickName { get; set; }
    public string uMobile { get; set; }
    public string uEmail { get; set; }
    public string uStatus { get; set; }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面开始密码授权模式开发，首先需要重新实现&lt;code&gt;IResourceOwnerPasswordValidator&lt;/code&gt;接口，使用我们定义的用户表来验证请求的用户名和密码信息。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// 金焰的世界
/// 2018-12-18
/// 自定义用户名密码校验
/// &amp;lt;/summary&amp;gt;
public class CzarResourceOwnerPasswordValidator : IResourceOwnerPasswordValidator
    {
        private readonly ICzarUsersServices _czarUsersServices;
        public CzarResourceOwnerPasswordValidator(ICzarUsersServices czarUsersServices)
        {
            _czarUsersServices = czarUsersServices;
        }
        /// &amp;lt;summary&amp;gt;
        /// 验证用户身份
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;context&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        public Task ValidateAsync(ResourceOwnerPasswordValidationContext context)
        {
            var user = _czarUsersServices.FindUserByuAccount(context.UserName, context.Password);
            if (user != null)
            {
                context.Result = new GrantValidationResult(
                    user.Uid.ToString(),
                    OidcConstants.AuthenticationMethods.Password, 
                    DateTime.UtcNow);
            }
            return Task.CompletedTask;
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;编写完自定义校验后，我们需要注入到具体的实现，详细代码如下。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public void ConfigureServices(IServiceCollection services)
{
    services.AddSingleton(Configuration);
    services.Configure&amp;lt;CzarConfig&amp;gt;(Configuration.GetSection(&quot;CzarConfig&quot;));
    services.AddIdentityServer(option=&amp;gt; {
        option.PublicOrigin = Configuration[&quot;CzarConfig:PublicOrigin&quot;];
    })
        .AddDeveloperSigningCredential()
        .AddDapperStore(option =&amp;gt;
                        {
                            option.DbConnectionStrings = Configuration[&quot;CzarConfig:DbConnectionStrings&quot;];
                        })
        //使用自定义的密码校验
        .AddResourceOwnerValidator&amp;lt;CzarResourceOwnerPasswordValidator&amp;gt;()
        ;
    //  .UseMySql();


    services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_1);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;剩下的就是把&lt;code&gt;ICzarUsersServices&lt;/code&gt;接口实现并注入即可。详细代码如下。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// 金焰的世界
/// 2018-12-18
/// 用户服务接口
/// &amp;lt;/summary&amp;gt;
public interface ICzarUsersServices
{
    /// &amp;lt;summary&amp;gt;
    /// 根据账号密码获取用户实体
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;uaccount&quot;&amp;gt;账号&amp;lt;/param&amp;gt;
    /// &amp;lt;param name=&quot;upassword&quot;&amp;gt;密码&amp;lt;/param&amp;gt;
    /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
    CzarUsers FindUserByuAccount(string uaccount, string upassword);

    /// &amp;lt;summary&amp;gt;
    /// 根据用户主键获取用户实体
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;sub&quot;&amp;gt;用户标识&amp;lt;/param&amp;gt;
    /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
    CzarUsers FindUserByUid(string sub);
}

/// &amp;lt;summary&amp;gt;
/// 金焰的世界
/// 2018-12-18
/// 用户服务实现
/// &amp;lt;/summary&amp;gt;
public class CzarUsersServices : ICzarUsersServices
    {
        private readonly ICzarUsersRepository _czarUsersRepository;
        public CzarUsersServices(ICzarUsersRepository czarUsersRepository)
        {
            _czarUsersRepository = czarUsersRepository;
        }

        /// &amp;lt;summary&amp;gt;
        /// 根据账号密码获取用户实体
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;uaccount&quot;&amp;gt;账号&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;upassword&quot;&amp;gt;密码&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        public CzarUsers FindUserByuAccount(string uaccount, string upassword)
        {
            return _czarUsersRepository.FindUserByuAccount(uaccount, upassword);
        }

        /// &amp;lt;summary&amp;gt;
        /// 根据用户主键获取用户实体
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;sub&quot;&amp;gt;用户标识&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        public CzarUsers FindUserByUid(string sub)
        {
            return _czarUsersRepository.FindUserByUid(sub);
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后我们实现仓储接口和方法，即可完成校验流程。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// 金焰的世界
/// 2018-12-18
/// 用户仓储接口
/// &amp;lt;/summary&amp;gt;
public interface ICzarUsersRepository
{
    /// &amp;lt;summary&amp;gt;
    /// 根据账号密码获取用户实体
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;uaccount&quot;&amp;gt;账号&amp;lt;/param&amp;gt;
    /// &amp;lt;param name=&quot;upassword&quot;&amp;gt;密码&amp;lt;/param&amp;gt;
    /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
    CzarUsers FindUserByuAccount(string uaccount, string upassword);

    /// &amp;lt;summary&amp;gt;
    /// 根据用户主键获取用户实体
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;sub&quot;&amp;gt;用户标识&amp;lt;/param&amp;gt;
    /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
    CzarUsers FindUserByUid(string sub);
}

/// &amp;lt;summary&amp;gt;
/// 金焰的世界
/// 2018-12-18
/// 用户实体基于SQLSERVER的实现
/// &amp;lt;/summary&amp;gt;
public class CzarUsersRepository : ICzarUsersRepository
    {
        private readonly string DbConn = &quot;&quot;;
        public CzarUsersRepository(IOptions&amp;lt;CzarConfig&amp;gt; czarConfig)
        {
            DbConn = czarConfig.Value.DbConnectionStrings;
        }
        /// &amp;lt;summary&amp;gt;
        /// 根据账号密码获取用户实体
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;uaccount&quot;&amp;gt;账号&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;upassword&quot;&amp;gt;密码&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        public CzarUsers FindUserByuAccount(string uaccount, string upassword)
        {
            using (var connection = new SqlConnection(DbConn))
            {
                string sql = @&quot;SELECT * from CzarUsers where uAccount=@uaccount and uPassword=upassword and uStatus=1&quot;;
                var result = connection.QueryFirstOrDefault&amp;lt;CzarUsers&amp;gt;(sql, new { uaccount, upassword = SecretHelper.ToMD5(upassword) });
                return result;
            }
        }

        /// &amp;lt;summary&amp;gt;
        /// 根据用户主键获取用户实体
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;sub&quot;&amp;gt;用户标识&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        public CzarUsers FindUserByUid(string sub)
        {
            using (var connection = new SqlConnection(DbConn))
            {
                string sql = @&quot;SELECT * from CzarUsers where uid=@uid&quot;;
                var result = connection.QueryFirstOrDefault&amp;lt;CzarUsers&amp;gt;(sql, new { uid=sub });
                return result;
            }
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在万事俱备，之前注入和插入测试用户数据进行测试了，为了方便注入，我们采用&lt;code&gt;autofac&lt;/code&gt;程序集注册。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// 金焰的世界
/// 2018-12-18
/// 使用程序集注册
/// &amp;lt;/summary&amp;gt;
public class CzarModule : Autofac.Module
    {
        protected override void Load(ContainerBuilder builder)
        {
            //注册Repository程序集
            builder.RegisterAssemblyTypes(typeof(CzarUsersRepository).GetTypeInfo().Assembly).AsImplementedInterfaces().InstancePerLifetimeScope();
            //注册Services程序集
            builder.RegisterAssemblyTypes(typeof(CzarUsersServices).GetTypeInfo().Assembly).AsImplementedInterfaces().InstancePerLifetimeScope();
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后需要修改&lt;code&gt;ConfigureServices&lt;/code&gt;代码如下,就完成了仓储和服务层的注入。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public IServiceProvider ConfigureServices(IServiceCollection services)
{
    services.AddSingleton(Configuration);
    services.Configure&amp;lt;CzarConfig&amp;gt;(Configuration.GetSection(&quot;CzarConfig&quot;));
    services.AddIdentityServer(option=&amp;gt; {
        option.PublicOrigin = Configuration[&quot;CzarConfig:PublicOrigin&quot;];
    })
        .AddDeveloperSigningCredential()
        .AddDapperStore(option =&amp;gt;
                        {
                            option.DbConnectionStrings = Configuration[&quot;CzarConfig:DbConnectionStrings&quot;];
                        })
        .AddResourceOwnerValidator&amp;lt;CzarResourceOwnerPasswordValidator&amp;gt;()
        ;
    //  .UseMySql();


    services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_1);

    //使用Autofac进行注入
    var container = new ContainerBuilder();
    container.RegisterModule(new CzarModule());
    container.Populate(services);
    return new AutofacServiceProvider(container.Build());
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了验证密码授权模式信息，这里需要往数据库插入测试的用户数据，插入脚本如下。&lt;/p&gt;
&lt;pre class=&quot;mssql&quot;&gt;
&lt;code&gt;--密码123456  MD5加密结果
INSERT INTO CzarUsers VALUES('13888888888','E10ADC3949BA59ABBE56E057F20F883E','金焰的世界','13888888888','541869544@qq.com',1); &lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;四测试密码授权模式&quot;&gt;四、测试密码授权模式&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;注意：测试密码授权模式之前，我们需要对测试的客户端&lt;code&gt;ClientGrantTypes&lt;/code&gt;表添加&lt;code&gt;password&lt;/code&gt;授权方式。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;打开我们的测试神器&lt;code&gt;Postman&lt;/code&gt;,然后开始调试密码授权模式，测试结果如下图所示。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1529926/201812/1529926-20181218225012340-16337323.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;是不是很完美，得到了我们想要的授权结果，那我们查看下这个access_token是什么信息，可以使用&lt;a href=&quot;https://jwt.io/&quot; class=&quot;uri&quot;&gt;https://jwt.io/&lt;/a&gt;查看到详细的内容，发现除了客户端信息和用户主键无其他附加信息，那如何添加自定义的Claim信息呢？&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1529926/201812/1529926-20181218225028816-853023018.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;先修改下&lt;code&gt;CzarUsers&lt;/code&gt;实体，增加如下代码，如果有其他属性可自行扩展。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public List&amp;lt;Claim&amp;gt; Claims
        {
            get
            {
                return new List&amp;lt;Claim&amp;gt;() {
                    new Claim(&quot;nickname&quot;,uNickName??&quot;&quot;),
                    new Claim(&quot;email&quot;,uEmail??&quot;&quot;),
                    new Claim(&quot;mobile&quot;,uMobile??&quot;&quot;)
                };
            }
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再修改校验方法，增加&lt;code&gt;Claim&lt;/code&gt;输出，&lt;code&gt;CzarResourceOwnerPasswordValidator&lt;/code&gt;修改代码如下。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// 验证用户身份
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;param name=&quot;context&quot;&amp;gt;&amp;lt;/param&amp;gt;
/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
public Task ValidateAsync(ResourceOwnerPasswordValidationContext context)
{
    var user = _czarUsersServices.FindUserByuAccount(context.UserName, context.Password);
    if (user != null)
    {
        context.Result = new GrantValidationResult(
            user.Uid.ToString(),
            OidcConstants.AuthenticationMethods.Password, 
            DateTime.UtcNow,
            user.Claims);
    }
    return Task.CompletedTask;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后需要把用户的claims应用到Token，这里我们需要重写&lt;code&gt;IProfileService&lt;/code&gt;，然后把用户的claim输出，实现代码如下。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class CzarProfileService : IProfileService
    {
        public Task GetProfileDataAsync(ProfileDataRequestContext context)
        {
            //把用户返回的Claims应用到返回
            context.IssuedClaims = context.Subject.Claims.ToList();
            return Task.CompletedTask;
        }

        /// &amp;lt;summary&amp;gt;
        /// 验证用户是否有效
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;context&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        public Task IsActiveAsync(IsActiveContext context)
        {
            context.IsActive = true;
            return Task.CompletedTask;
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后别忘了注入&lt;code&gt;.AddProfileService&amp;lt;CzarProfileService&amp;gt;()&lt;/code&gt;，好了现在我们再次测试下授权，最终得到的结果如下所示。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1529926/201812/1529926-20181218225048444-1876304490.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;奈斯，得到了我们预期授权结果。&lt;/p&gt;
&lt;p&gt;那如何获取&lt;code&gt;refresh_token&lt;/code&gt;呢？通过前面的介绍，我们需要增加&lt;code&gt;scope&lt;/code&gt;为&lt;code&gt;offline_access&lt;/code&gt;，并且需要设置客户端支持，因此&lt;code&gt;AllowOfflineAccess&lt;/code&gt;属性需要设置为&lt;code&gt;True&lt;/code&gt;，现在来测试下获取的授权结果。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1529926/201812/1529926-20181218225103752-1081408298.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最终完成了&lt;code&gt;refresh_token&lt;/code&gt;的获取，至此整个密码授权模式全部讲解并实现完成。&lt;/p&gt;
&lt;h2 id=&quot;五总结及思考&quot;&gt;五、总结及思考&lt;/h2&gt;
&lt;p&gt;本篇文章我们从密码授权模式使用场景、源码剖析、自定义用户授权来讲解了密码授权模式的详细思路和代码实现，从中不难发现&lt;code&gt;Ids4&lt;/code&gt;设计的巧妙，在默认实现的同时也预留了很多自定义扩展，本篇的自定义用户体系也是重新实现接口然后注入就完成集成工作。本篇主要难点就是要理解&lt;code&gt;Ids4&lt;/code&gt;的实现思路和数据库的相关配置，希望通过本篇的讲解让我们熟练掌握密码验证的流程，便于应用到实际生产环境。&lt;/p&gt;
&lt;p&gt;上篇的客户端授权模式和本篇的密码授权模式都讲解完可能有人会存在以下几个疑问。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1、如何校验令牌信息的有效性？&lt;/li&gt;
&lt;li&gt;2、如何强制有效令牌过期？&lt;/li&gt;
&lt;li&gt;3、如何实现单机登录？&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下篇文章我将会从这3个疑问出发，来详细讲解下这三个问题的实现思路和代码。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1529926/201812/1529926-20181218225122662-109340743.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 18 Dec 2018 14:52:00 +0000</pubDate>
<dc:creator>金焰的世界</dc:creator>
<og:description></og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jackcao/p/10140688.html</dc:identifier>
</item>
<item>
<title>Java集合-06Vector源码解析及使用实例 - Jzedy</title>
<link>http://www.cnblogs.com/JzedyBlogs/p/10140642.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/JzedyBlogs/p/10140642.html</guid>
<description>&lt;h2 id=&quot;vector简介&quot;&gt;Vector简介&lt;/h2&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;Vector (矢量类)实现了动态数组的功能，如同数组，它可以通过角标访问数据，&lt;br/&gt;不过Vector被创建后在添加或移除时候能适应性的增加或者减少。继承AbstractCollection类，实现了List、RandomAccess、Cloneable、Serialization接口&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;构造方法&quot;&gt;构造方法&lt;/h2&gt;
&lt;ol readability=&quot;-1.5&quot;&gt;&lt;li&gt;public Vector()&lt;/li&gt;
&lt;li&gt;public Vector(int initialCapacity)&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;public Vector(int initialCapacity, int capacityIncrement)&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;Vector包含三个构造函数，第一种默认构造函数，此时初始容量为10，&lt;br/&gt;第二种指定容量大小的构造函数，此时capacityIncrement等于0，扩容时候成倍增加，&lt;br/&gt;第三种指定容量大小和增量，扩容时候增加capacityIncrement大小&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;重要属性&quot;&gt;重要属性&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;protected Object[] elementData;//用于保存Vector数据的数组&lt;/li&gt;
&lt;li&gt;protected int elementCount;//Vector中数据个数&lt;/li&gt;
&lt;li&gt;protected int capacityIncrement;//Vector容器的增量&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;Vector的方法和ArrayList类似,不过它的增删改查方法前都添加&lt;em&gt;synchronized&lt;/em&gt;修饰，保证线程安全，也就是说Vector是线程同步的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;vector源码分析&quot;&gt;Vector源码分析&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;public synchronized boolean add(E e) {
        modCount++;//fail-fast判断机制
        ensureCapacityHelper(elementCount + 1);//确保Vector容量足够，跳转到下一个方法
        elementData[elementCount++] = e;//对应位置复制
        return true;//返回布尔类型
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;1.9148936170213&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/JzedyBlogs/p/10136772.html&quot;&gt;fail-fast(快速失败)机制&lt;/a&gt;见上一篇博客&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;private void ensureCapacityHelper(int minCapacity) {
        // overflow-conscious code
        if (minCapacity - elementData.length &amp;gt; 0)
            grow(minCapacity);//判断容量大小和包含元素个数，决定是否扩容
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;private void grow(int minCapacity) {
        // overflow-conscious code
        int oldCapacity = elementData.length;
        int newCapacity = oldCapacity + ((capacityIncrement &amp;gt; 0) ?
                                         capacityIncrement : oldCapacity);//如果增量大于0，扩容后的大小为原来容量与增量的和，否则扩容为原来容量的一倍
        if (newCapacity - minCapacity &amp;lt; 0)
            newCapacity = minCapacity;
        if (newCapacity - MAX_ARRAY_SIZE &amp;gt; 0)
            newCapacity = hugeCapacity(minCapacity);
        elementData = Arrays.copyOf(elementData, newCapacity);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;public synchronized E remove(int index) {
        modCount++;//fail-fast
        if (index &amp;gt;= elementCount)
            throw new ArrayIndexOutOfBoundsException(index);//数组角标过界异常
        E oldValue = elementData(index);//获取当前角标位置的元素数据

        int numMoved = elementCount - index - 1;
        if (numMoved &amp;gt; 0)
            System.arraycopy(elementData, index+1, elementData, index,numMoved);//复制数组(复制源数组,复制源数组开始位置,复制数组，复制数组开始位置，复制长度)
        elementData[--elementCount] = null; // Let gc do its work

        return oldValue;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;vector遍历方式&quot;&gt;Vector遍历方式&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Vector&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;迭代器遍历
&lt;/li&gt;
&lt;li&gt;forEach遍历
&lt;/li&gt;
&lt;li&gt;RandomAccess遍历
&lt;/li&gt;
&lt;li&gt;Enumeration遍历
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;vector使用实例&quot;&gt;Vector使用实例&lt;/h2&gt;
&lt;blockquote readability=&quot;4&quot;&gt;
&lt;p&gt;使用实例代码在&lt;a href=&quot;https://github.com/Jzedy/Z-books/blob/master/src/main/java/collection/VectorTest.java&quot;&gt;Github&lt;/a&gt;上&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Tue, 18 Dec 2018 14:42:00 +0000</pubDate>
<dc:creator>Jzedy</dc:creator>
<og:description>Vector简介 Vector (矢量类)实现了动态数组的功能，如同数组，它可以通过角标访问数据， 不过Vector被创建后在添加或移除时候能适应性的增加或者减少。继承AbstractCollecti</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/JzedyBlogs/p/10140642.html</dc:identifier>
</item>
<item>
<title>Audio Bandwidth Extension - 凌逆战</title>
<link>http://www.cnblogs.com/LXP-Never/p/10129271.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/LXP-Never/p/10129271.html</guid>
<description>&lt;p&gt;&lt;span&gt;论文和代码都在这个&lt;a href=&quot;https://github.com/SomeshGanesh94/Audio-Bandwidth-Extension&quot; target=&quot;_blank&quot;&gt;地址&lt;/a&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;作者：Somesh Ganesh；单位：Georgia Tech Center for Music Technology，Georgia Institute of Technology；Email:someshg94@gatech.edu&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　音频带宽扩展是一种利用各种音频编解码器提高有限频带音频感知质量的技术。本文提出了几种音频带宽扩展的方法，并通过听力测试对其进行了评估。比较了半波校正和全波校正，以及子带滤波的应用。结果表明，采用子带滤波的半波校正是测试算法中的最佳技术。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　在当今世界里有很多频带受限的音频，这主要是由于以下原因。信号的数字化要求对模拟信号进行采样。当模拟到数字转换器中的采样率不高时，就会产生混叠现象。为了避免这一点，反混叠滤波实现作为预处理步骤。这些滤波器基本上是低通滤波器，限制着信号的带宽。存在大量带宽被限音频的另一个原因是因为音频编解码器实现的算法，&lt;/span&gt;&lt;span&gt;为了增加存储，音频编解码器利用这样的事实：与低频分量相比，人类对高频分量不太敏感，因此舍去了音频文件的高频分量。这样的做法可以提高存储量，并能显著提高比特率。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　频带限制降低了音频的质量。因此，需要开发一种音频带宽扩展算法来恢复原始音频质量。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　让我们首先把相关工作分为两大类：盲源频带扩展和非盲源频带扩展。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;A、非盲源带宽扩展&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　非盲带宽扩展是指利用特定的编码和解码技术重建缺失频谱的过程。这包括一些时域或频率信息、噪声水平或在对信号进行编码时缺失的频率分量以及低频分量有关的任何其他相关信息。最著名的非盲源带宽扩展算法之一是频谱折叠(SBR)&lt;sup&gt;[1]&lt;/sup&gt;。该方法有自己的编解码器，其工作原理是假设低频分量与高频分量有很强的相关性。利用逆滤波、自适应加噪和正弦再生等技术，对相关系数较低的信号进行了分析。&lt;sup&gt;[2]&lt;/sup&gt;提出了一种利用分形自相似模型(FSSM)对音频信号进行修正离散余弦变换(MDCT)表示的算法。&lt;/span&gt;&lt;span&gt;该方法用于多种音频信号，并对缺失频谱进行了细节的重建。[3]引入精确谱替换(ASR)技术，对缺失频谱中的色调分量和谐波结构进行重建。&lt;sup&gt;[4]&lt;/sup&gt;使用[2]和[3]中的概念，并将它们应用于信号的高频分辨率表示，如MDCT。它还包括“多波段时域幅度编码”(Mbtac)，用于重构高频分量的时间整形。&lt;span&gt;这些方法的问题在于，该过程需要额外的信道资源来传输有关缺失频谱的信息&lt;/span&gt;。当对比特率和存储有限制时，这是不可取的。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;B、盲源带宽扩展&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　盲源带宽扩展是指在没有任何缺失频谱的前提情况下进行重建的过程。&lt;sup&gt;[5]&lt;/sup&gt;提出了一种基于半波整流的盲源带宽扩展算法。该方法对带限信号中的最高倍频程采用半波整流法，产生高频谱。这个新的频谱通过增益因子进行缩放，并被添加到延迟输入信号中。[6]通过提出一种不同的过滤最高倍频程的方法来优化这一过程以实现实时应用。该方法还包括作为预处理步骤的带宽检测模块和作为后处理步骤的自适应增益。[7]和[8]建议采用线性外推法求出高频谱的包络并进行重构。文[9]中的算法是基于相位空间重构(PSR)的方法。这里，PSR被用来将宽带音频的低频MDCT系数转换成多维空间。高频频谱根据听者的感知进行调整。这包括线性和非线性预测。[10]提出了基于混沌预测理论的算法，并建议根据音频产生原理和人耳知觉生成高频信息。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　本论文所使用的算法是一种盲带宽扩展算法。这是因为目前频带受限的音频数据集很大并且没有原始音频。在这种情况下，非盲源频带扩展不会有多大作用。首先&lt;/span&gt;&lt;span&gt;让我们简要地看一下图一中实现的系统。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1433301/201812/1433301-20181218163249342-1527418028.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图1：算法概述&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;A、滤波器1&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　这一部分包括对频带受限音频进行的滤波操作。在此过程中，提取信号的最高倍频程。假设信号中的最高频率分量是$f_{hf}$。现在，假设信号中的采样频率$fs≥4*f_{hf}$，这可以通过采样作为预处理步骤。信号中的最高倍频程在$\frac{f_{hf}}{2}-f_{hf}$之间。使用非线性设备在下一模块中用滤波后的信号来生成缺失的高频谱。&lt;/span&gt;&lt;span&gt;非线性器件产生互调失真(在下一节中定义)。为了研究这种失真对系统质量的影响，我们设计了两个不同版本的该模块。&lt;/span&gt;&lt;span&gt;第一版本是一个简单的IIR(无限脉冲响应)带通滤波器，它允许$\frac{f_{hf}}{2}-f_{hf}$范围的频率通过。&lt;/span&gt;&lt;span&gt;互调失真随频率分量的增加而增加。因此，第二个版本是两个IIR带通滤波器的组合，其中第一个滤除信号中最高倍频程的一半，而另一个滤除另一半。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;B、非线性设备 Non-Linear Device(NLD)&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　该部分由非线性设备组成，该设备利用来自向前模块滤波后的信号产生高频谱。这部分产生信号的高频谐波。&lt;/span&gt;&lt;span&gt;在这里，我们使用了两个非线性设备。一个是半波整流器，另一个是全波整流器。&lt;/span&gt;&lt;span&gt;我们选择了整改，因为这是一个均匀的过程。整流器的输出主要是输入频率的二次谐波，二次谐波的衰减为12dB每倍频程。&lt;/span&gt;&lt;span&gt;半波整流输出的频谱由原始输入频率和所有谐波组成。另一方面，全波整流输出的频谱仅由输入频率的谐波组成。&lt;/span&gt;&lt;span&gt;我们对谐波的产生感兴趣，&lt;/span&gt;&lt;span&gt;我们感兴趣的是产生下一次谐波，即$f_{hf}-2*f_{hf}$之间的频谱。接下来，让我们来定义互调失真(IMD)。当一个频率分量由两个或两个以上的频率分量组成，经过非线性设备运算时，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当一个由两个或多个频率分量组成的信号经过非线性运算时，输出不仅包含这些频率分量，而且还包含几个不理想的分量，这些分量基本上是输入分量的总和差。输出中的这种失真称为互调失真。本文研究了半波互调失真和全波整流对重建音频信号主观质量的影响。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;C、滤波器2&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　这一部分在非线性设备模块后面，我们之前的模块仅关注高频谱的生成，经过前一步的整流之后，&lt;/span&gt;&lt;span&gt;高频分量将主要包含输入频率分量的二次谐波。由于互调失真，会出现低于$f_{hf}$和高于$2*f_{hf}$的不良成分。这些分量需要消除。因此，目标信号将位于$f_{hf}$和$2*f_{hf}$之间。在这个阶段，这些边界之间的信号将被过滤掉。类似于滤波器1模块，这个模块我们有来两个版本。第一个版本将包含一个简单的IIR带通滤波器，它将滤除$f_{hf}$和$2*f_{hf}$之间的信号。第二个版本包含两个独立的IIR带通滤波器。当使用第二版本的滤波器1时，再使用这个版本的滤波器。第一个滤波器将会滤除第二版本滤波器1的输入频率的二次谐波&lt;/span&gt;&lt;span&gt;。第二滤波器将会滤除滤波器1中第二版本的第二滤波器输入频率产生的二次谐波&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;这样可以增加这两个滤波器的输出，使我们得到完整的重构高频谱。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　最后，将产生的高频频谱添加到输入中，输入延迟的量相当于产生频谱所需的时间。因此，我们最终有频带扩展的信号。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;A、试验方法与技术&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　在评估方面，进行听力测试来证明带宽扩展音频的主观质量。实验数据集是用一个简单的IIR低通滤波器生成的。五首歌来自不同的流派-电子，摇滚，电子屋，声学和世界音乐。所有音频文件的采样频率都为44.1kHz，带宽限制为7 kHz。每个文件都有20秒长。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　对于听力测试，进行了MUSHRA[11]样试验。首先让参与者听到原始的音频文件(参考)，然后是带宽受限的音频文件。之后，他们按随机顺序听到五个音频文件，其中包括一个隐藏的参考音频。另外四个音频文件是使用上述算法经过频带扩展的音频文件。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;半波整流;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;基于子带滤波的半波校正&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;全波整流;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;基于子带滤波的全波校正&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;然后对这些音频文件的评分按1到10划分等级，&lt;/span&gt;&lt;span&gt;1是感知质量的最差的等级，10是感知质量的最好的等级。重复播放这5首歌，&lt;/span&gt;&lt;span&gt;所有音频文件的响度均方值标准化为0.7。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　其中一首歌曲的所有5个音频文件的频谱图图以及频带受限信号如下图2所示。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1433301/201812/1433301-20181217000019385-2056188127.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图2a，原始语音信号(参考信号)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1433301/201812/1433301-20181217000049754-380266220.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图2b：频带受限语音信号&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1433301/201812/1433301-20181217000247648-1732939561.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图2c：半波整流重建后的信号&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1433301/201812/1433301-20181217000617779-67617014.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图2d：半波整流和子带滤波重建信号&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1433301/201812/1433301-20181217000637069-410966795.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图2e：全波整流重建信号&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1433301/201812/1433301-20181217000657850-104201475.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图2f：全波整流和子带滤波重建信号&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;B、结果&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　测试有6名参与者。记录结果，计算评分均值。这些数字列于表1。&lt;/span&gt;&lt;span&gt;　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1433301/201812/1433301-20181217000925502-980263652.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;表1：评估方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　从结果可以看出，原始音频文件(参考)获得最高的评分。这就告诉我们，参与者给出的评分是真实的，是可以考虑的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1433301/201812/1433301-20181217001147022-2069259279.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图3：评估方法的柱形图&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　从图3中的条形图中，我们可以看到原始音频文件比带宽扩展后的音频文件具有更好的质量。我们还可以看到，在算法中使用子带滤波对音频文件的主观质量有积极的影响。使用简单的全波整流做音频扩展得到的音频文件中发现，在所有音频文件中，感知质量的得分最少。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　首先，对本文提出的算法和实验结果进行了讨论。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　结果表明，采用子带滤波可以降低重建输出的互调失真，因此具有较高的主观的得分。我们还可以得出结论，与全波整流相比，半波整流是一种更好的方法。根据所收到的评分，我们可以根据感知质量的得分对算法进行排序。&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;基于子带滤波的半波整流&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;基于子带滤波的全波整流&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;半波整流;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;全波整流;&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;　　这些结果验证了文献[6]所提出的方法，即子带滤波的使用预期具有较高的感知质量，但是未与文献[5]中使用的一般滤波技术相比较。本文还比较了半波整流与全波整流对感知质量的影响。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　接下来，让我们来讨论一下本文提出的算法和实验的缺点：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1、该算法只有当频带限制音频信号$f_{hf}=\frac{f_s}{4}$中存在最高频率的情况下，才能将频谱重构到最大极限$\frac{fs}{2}$。如果$f_{hf}&amp;lt;\frac{f_s}{4}$，如图2所示，我们无法在最大范围内重建高频频谱。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2、所进行的实验只有很少的参与者和一个很小的数据集。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　本文可作为今后音频带宽扩展工作的基本框架。以下是本文算法和实验的改进和扩展。&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;高频谱的重建可以独立于频带受限音频中的最高频率。这将允许适当的重建，即使信号中的最高频率很低，即在5-7kHz的范围内。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;在本文中由于在非线性设备模块中只使用了两种不同的整流器，因此可以对不同的非线性设备(如积分器)进行进一步的研究。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;整个系统可以进一步优化，以更好地实时工作。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;span&gt;　　本文对不同的音频带宽扩展方法进行了比较，并通过听力测试对结果进行了评价。实验结果表明，半波整流作为一种非线性设备，其校正效果优于全波整流，采用子带滤波可以提高带宽扩展信号的感知质量。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;[1] P. Ekstrand, “Bandwidth extension of audio signals by spectral band replication,” in Proceedings of the 1st IEEE Benelux Workshop on Model Based Processing and Coding of Audio (MPCA ’02, 2002.)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;[2] Deepen Sinha, Anibal Ferreira, and, Deep Sen “A Fractal Self-Similarity Model for the Spectral Representation of Audio Signals,” 118th Convention of the Audio Engineering Society, May 2005, Paper 6467.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;[3] Anibal J. S. Ferreira and Deepen Sinha, “Accurate Spectral Replacement,” 118th Convention of the Audio Engineering Society, May 2005, Paper 6383.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;[4] H. E. V., A. J. S. Ferreira, and D. Sinha, “A Novel Integrated Audio Bandwidth Extension Toolkit (ABET),” presented at the Audio Engineering Society Convention 120, 2006.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;[5] E. Larsen, R. M. Aarts, and M. Danessis, “Efficient High-frequency Bandwidth Extension of Music and Speech,” presented at the Audio Engineering Society Convention 112, 2002.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;[6] M. Arora, J. Lee, and S. Park, “High Quality Blind Bandwidth Extension of Audio for Portable Player Applications,” presented at the Audio Engineering Society Convention 120, 2006.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;[7] C.-M. Liu, W.-C. Lee, and H.-W. Hsu, “High Frequency Reconstruction for Band-Limited Audio Signals,” in Proceedings of the 6th International Conference on Digital Audio Effects (DAFX-03), 2003.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;[8] “AES E-Library » High Frequency Reconstruction by Linear Extrapolation.” [Online]. Available: http://www.aes.org/elib/browse.cfm?elib=12426.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;[9] C.-C. Bao, X. Liu, Y.-T. Sha, and X.-T. Zhang, “A blind bandwidth extension method for audio signals based on phase space reconstruction,” EURASIP Journal on Audio, Speech, and Music Processing, vol. 2014, no. 1, p. 1, 2014.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;[10] Y. T Sha, C. C Bao, M. S Jia, and X. Liu, “High frequency reconstruction of audio signal based on chaotic prediction theory,” in 2010 IEEE International Conference on Acoustics, Speech and Signal Processing, 2010, pp. 381–384.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;[11] The MUSHRA audio subjective test method - BBC R&amp;amp;D, 2002.&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 18 Dec 2018 14:12:00 +0000</pubDate>
<dc:creator>凌逆战</dc:creator>
<og:description>论文和代码都在这个地址。 作者：Somesh Ganesh；单位：Georgia Tech Center for Music Technology，Georgia Institute of Techn</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/LXP-Never/p/10129271.html</dc:identifier>
</item>
<item>
<title>JavaScript原型链及继承 - 学习编程的小菜鸟</title>
<link>http://www.cnblogs.com/zhuangshq/p/10140507.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhuangshq/p/10140507.html</guid>
<description>&lt;p&gt;在JavaScript中，所有的东西都是对象，但是JavaScript中的面向对象并不是面向类，而是面向原型的，这是与C++、Java等面向对象语言的区别，比较容易混淆，因此把我自己学习的过程记录下来。&lt;/p&gt;
&lt;p&gt;首先说，原型链有什么用？在Java中，继承都是基于类的，在JavaScript中继承都是基于原型链的。也就是说在JavaScript中，原型链是实现继承的基础，想要掌握好JavaScript中的面向对象编程，必须对原型链有一定的了解。&lt;/p&gt;
&lt;p&gt;要理解原型链，必须先了解两个对象，一个是 &lt;span class=&quot;cnblogs_code&quot;&gt;prototype&lt;/span&gt; ，另一个是 &lt;span class=&quot;cnblogs_code&quot;&gt;__proto__&lt;/span&gt; 。当前只需要记住名字，下面会仔细说明。&lt;/p&gt;
&lt;p&gt;首先是 &lt;span class=&quot;cnblogs_code&quot;&gt;prototype&lt;/span&gt; ： &lt;span class=&quot;cnblogs_code&quot;&gt;prototype&lt;/span&gt; ，或者叫原型对象，是函数特有的一个属性，其类型是 &lt;span class=&quot;cnblogs_code&quot;&gt;Object&lt;/span&gt; ，因此也常常被称作函数的原型对象。虽然每个函数都拥有自己的原型对象，但只有用作构造函数时，这个属性才会发挥作用，关于构造函数的知识这里不说。原型对象其实很简单，他就是一个普通的 &lt;span class=&quot;cnblogs_code&quot;&gt;Object&lt;/span&gt; ，当其作为构造函数时默认有一个 &lt;span class=&quot;cnblogs_code&quot;&gt;constructor&lt;/span&gt; 。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 举个简单的例子&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; fn() { }
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; 
&lt;span&gt;4&lt;/span&gt; console.log(fn.prototype);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; {}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们可以给原型对象添加一些方法或属性，就可以被其子类继承：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 后面会讲怎么继承&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; fn() { }
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 添加一个方法&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; fn.prototype.sayHello = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     alert('hello'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;};
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 添加一个属性&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; fn.prototype.name = 'my_fn';
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 上面就完成了对原型对象的介绍，接下来是 &lt;span class=&quot;cnblogs_code&quot;&gt;__proto__&lt;/span&gt; ，这是一个所有对象都拥有的属性。其实 &lt;span class=&quot;cnblogs_code&quot;&gt;__proto__&lt;/span&gt; 与原型对象密不可分，因为一个对象的 &lt;span class=&quot;cnblogs_code&quot;&gt;__proto__&lt;/span&gt; 就是指向其构造函数的原型对象。需要注意的是 &lt;span class=&quot;cnblogs_code&quot;&gt;__proto__&lt;/span&gt; 并不是JavaScript的规范，只是大多数浏览器都实现了，从ECMAScript 6开始，应该用Object.getPrototypeOf()和Object.setPrototypeOf()来访问这个属性。看一个例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; fn() { }
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; 
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; f = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; fn();
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; console.log(f.__proto__ === fn.prototype);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 从上面的代码，应该就可以明白这二者的关系了，如果能理解这一点，接下来就可以开始分析继承的实现原理了。&lt;/p&gt;
&lt;p&gt;开头说过，继承是基于原型链实现的，那么什么是原型链呢？首先我们看几个例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; fn() { }
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 首先记住，一个对象的__proto__指向它的构造函数的原型对象&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; f = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; fn();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; console.log(f &lt;span&gt;instanceof&lt;/span&gt; Object);   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; true，说明此时f是一个Object&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; console.log(f.__proto__ === fn.prototype);   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; true，没毛病，因为f的构造函数就是fn&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; obj = fn.prototype; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 我们看看fn的原型对象是什么类型？肯定是对象！&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; console.log(obj.__proto__ === Object.prototype);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; true，那对象就是Object，它的构造函数就是Object&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; obj = Object.prototype; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 那Object的原型对象应该也是个对象吧&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; console.log(obj.__proto__ === &lt;span&gt;null&lt;/span&gt;);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; true，为什么是null？这是JavaScript设计的，因为如果不是null，就会无限循环&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上的例子说明了f的构造函数的原型，f的构造函数的原型的原型，f的构造函数的原型的原型的原型，用图形表示就是：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
f.__proto__ ---&amp;gt; f.__proto__.__proto__ ---&amp;gt; f.__proto__.__proto__.__proto__
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;那么上面这条“链”就是我们所说的原型链了！这个过程理解了可以继续往下。&lt;/p&gt;
&lt;p&gt;那么原型链是如何实现继承的？在JavaScript中，你对一个对象调用一个方法或者获取一个属性，它就会自动的在原型链上面寻找，一直到找到或者原型对象为null。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 再举个例子&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; fn() {}
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; f = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; fn();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 此时fn并没有方法toString&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; console.log(f.toString()); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输出[object Object]&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 为什么？&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 按照刚刚分析的原型链，它会现在fn.prototype中寻找&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; console.log(fn.prototype);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; fn {}，没有&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 再在fn.prototype.__proto__(Object.prototype)中寻找&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; console.log(fn.prototype.__proto__);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/867017/201812/867017-20181218215019004-752448219.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面这个例子说明，f的 &lt;span class=&quot;cnblogs_code&quot;&gt;toString&lt;/span&gt; 方法其实是从 &lt;span class=&quot;cnblogs_code&quot;&gt;Object.prototype&lt;/span&gt; 继承而来的。&lt;/p&gt;
&lt;p&gt;如果上面这些都能明白，那我们就可以自己实现继承了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 回到前面的例子&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; SuperClass() {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.time = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date().toLocaleString();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; // 添加一个方法&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; SuperClass.prototype.sayHello = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     console.log('hello'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;};
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; // 添加一个属性&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; SuperClass.prototype.name = 'super'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 定义一个子类继承SuperClass&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; SubClass() {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在子类的构造函数中调用父类的构造函数&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;     SuperClass.call(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt; SubClass.prototype = Object.create(SuperClass.prototype);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 继承父类的属性和方法&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; SubClass.prototype = SuperClass.prototype;  // 不能直接赋值！因为JavaScript中的对象赋值都是浅复制，有副作用，也就是说修改子类的原型也会修改父类&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; SubClass.prototype = new SuperClass();   // 也不要这样做，因为这样会实例化一个SuperClass，假如SuperClass的构造函数中定义了一个很大的对象，就会造成内存浪费！&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; SubClass.constructor = SubClass;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 上一行代码会把子类的构造函数给覆盖了，这里把它恢复了。注意：constructor会影响instanceof运算符的结果&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt; SubClass.prototype.subfn = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     console.log('this is a sub func'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; sc = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SubClass();
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; console.log(sc.time);   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2018-12-18 22:02:09&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt; sc.sayHello();  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; hello&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt; sc.subfn(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; this is a sub func&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 上面就是一个简单的继承，要实现多重继承也是类似的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在上面的代码修改&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 另一个父类&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; SuperClassB() {}
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; SuperClassB.prototype.anotherfn = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     console.log('another super'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 定义一个子类继承SuperClass&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; SubClass() {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在子类的构造函数中调用父类的构造函数&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;     SuperClass.call(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     SuperClassB.call(&lt;span&gt;this&lt;/span&gt;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 添加&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; prototype = Object.create(SuperClass.prototype);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 继承父类的属性和方法&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; prototype = Object.assign(prototype, SuperClassB.prototype);　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 合并两个父类的原型对象&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; SubClass.prototype = prototype  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 继承父类的属性和方法&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt; sc.anotherfn(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; another super&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Tue, 18 Dec 2018 14:11:00 +0000</pubDate>
<dc:creator>学习编程的小菜鸟</dc:creator>
<og:description>在JavaScript中，所有的东西都是对象，但是JavaScript中的面向对象并不是面向类，而是面向原型的，这是与C++、Java等面向对象语言的区别，比较容易混淆，因此把我自己学习的过程记录下来</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhuangshq/p/10140507.html</dc:identifier>
</item>
<item>
<title>Elasticsearch 通关教程（二）： 索引映射Mapping问题 - JaJian</title>
<link>http://www.cnblogs.com/jajian/p/10134164.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jajian/p/10134164.html</guid>
<description>&lt;p&gt;数据库建表的时候，我们的DDL语句一般都会指定每个字段的存储类型，例如：varchar，int，datetime等等，目的很明确，就是更精确的存储数据，防止数据类型格式混乱。&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;CREATE TABLE `shop_` (
  `id_` varchar(36) NOT NULL COMMENT 'id',
  `shop_name_` varchar(50) DEFAULT NULL COMMENT '商品名称',
  `shop_integral_` int(11) DEFAULT NULL COMMENT '兑换所需积分',
  `shop_money_` decimal(10,0) DEFAULT NULL COMMENT '劵面金额',
  `start_time_` datetime DEFAULT NULL COMMENT '有效开始时间',
  `end_time_` datetime DEFAULT NULL COMMENT '有效结束时间',
  `is_delete_` int(1) DEFAULT '1' COMMENT '是否删除-1：有效，0：删除',
  PRIMARY KEY (`id_`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 Elasticsearch中也是这样，创建索引的时候一般也需要指定索引的字段类型，这种方式成为映射(Mapping)。&lt;/p&gt;

&lt;p&gt;映射(Mapping)针对的是文档的字段，数据库中有varchar，int，datetime等数据类型，那么我们ElasticSearch中又有哪些字段类型，每个字段类型都代表什么意思呢？&lt;/p&gt;
&lt;p&gt;ElasticSearch更新频繁，以下内容是针对6.x版本的，对于5.x版本以及之前的版本可能有所不同，未来7.x版本也许也会有所改变，本篇不能做到面面俱到，所以大家可以针对自己的版本查阅官方文档。&lt;/p&gt;
&lt;p&gt;Elasticsearch支持文档字段的多种不同数据类型，根据官方文档的分类，可以划分为以下几个类别：&lt;br/&gt;&lt;strong&gt;核心数据类型&lt;/strong&gt;，&lt;strong&gt;复杂数据类型&lt;/strong&gt;，&lt;strong&gt;Geo(地理)数据类型&lt;/strong&gt;，&lt;strong&gt;专用数据类型&lt;/strong&gt;和&lt;strong&gt;多字段&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;核心数据类型&quot;&gt;核心数据类型&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;字符串类型&lt;br/&gt;主要包括：text 和 keyword。&lt;/li&gt;
&lt;li&gt;数字类型&lt;br/&gt;主要包括：long, integer, short, byte, double, float, half_float, scaled_float&lt;/li&gt;
&lt;li&gt;日期类型&lt;/li&gt;
&lt;li&gt;布尔类型&lt;/li&gt;
&lt;li&gt;二进制类型&lt;/li&gt;
&lt;li&gt;范围数据类型&lt;br/&gt;integer_range, float_range, long_range, double_range, date_range&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;这里我们重点介绍下 text 和 keyword 的区别&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/6.5/text.html&quot;&gt;text&lt;/a&gt; 用于索引全文值的字段，例如电子邮件正文或产品说明。这些字段是analyzed，它们通过分词器传递 ，以在被索引之前将字符串转换为单个术语的列表。分析过程允许Elasticsearch搜索单个单词中 每个完整的文本字段。文本字段不用于排序，很少用于聚合（尽管 重要的文本聚合 是一个值得注意的例外）。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/6.5/keyword.html&quot;&gt;keyword&lt;/a&gt; 用于索引结构化内容的字段，例如电子邮件地址，主机名，状态代码，邮政编码或标签。它们通常用于过滤，排序，和聚合。keyword字段只能按其确切值进行搜索。如果您需要索引电子邮件正文或产品说明等全文内容，则可能应该使用text字段。&lt;/p&gt;
&lt;p&gt;有时候一个字段同时拥有全文类型（text）和关键字类型（keyword）是有用的：一个用于全文搜索，另一个用于聚合和排序。这可以通过&lt;strong&gt;多字段&lt;/strong&gt;类型来实现。&lt;/p&gt;
&lt;h2 id=&quot;复杂数据类型&quot;&gt;复杂数据类型&lt;/h2&gt;
&lt;h2 id=&quot;geo数据类型&quot;&gt;Geo数据类型&lt;/h2&gt;
&lt;h2 id=&quot;专用数据类型&quot;&gt;专用数据类型&lt;/h2&gt;
&lt;h2 id=&quot;多字段&quot;&gt;多字段&lt;/h2&gt;
&lt;p&gt;有时候单纯的一个字段类型满足不了我们复杂的需求，为了不同的目的，以不同的方式索引同一个字段通常很有用。多字段也是ES的一种数据类型，只不过结合了更多的功能。&lt;/p&gt;
&lt;p&gt;例如，对于字符串字段，我们既可以将它映射为text类型用于全文搜索，亦可以将它映射为keyword类型用于排序或聚合，或者，还可以使用标准分词器、英语分词器和其他语言分词器索引文本字段。&lt;/p&gt;
&lt;p&gt;大多数数据类型都通过&lt;code&gt;fields&lt;/code&gt;参数支持多字段。例如对于城市名称的多字段映射，可以这样写：&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;PUT my_index
{
  &quot;mappings&quot;: {
    &quot;_doc&quot;: {
      &quot;properties&quot;: {
        &quot;cityName&quot;: {
          &quot;type&quot;: &quot;text&quot;,
          &quot;fields&quot;: {
            &quot;raw&quot;: { 
              &quot;type&quot;:  &quot;keyword&quot;
            }
          }
        }
      }
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Elasticsearch的字段类型讲解完了，我们接下来正式介绍 ES的映射，ES是如何将索引文档和数据类型进行关联的，创建索引前是否必须制定索引文档的数据类型呢？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;映射&lt;/strong&gt;是定义一个文档及其包含的字段如何存储和索引的过程。例如，使用映射来定义：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;应将哪些字符串字段视为全文字段。&lt;/li&gt;
&lt;li&gt;哪些字段包含数字，日期或地理位置。&lt;/li&gt;
&lt;li&gt;是否应将文档中所有字段的值索引到catch-all _all字段中。&lt;/li&gt;
&lt;li&gt;日期值的格式。&lt;/li&gt;
&lt;li&gt;自定义规则以控制动态添加字段的映射。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其实在 ElasticSearch中可以不需要事先定义映射（Mapping），文档写入ElasticSearch时，会根据文档字段自动识别类型，但是通过这种自动识别的字段不是很精确，对于一些复杂的需要分词的就不适合了。&lt;/p&gt;
&lt;p&gt;根据是否自动识别映射类型，我们可以将映射分为&lt;strong&gt;动态映射&lt;/strong&gt;和&lt;strong&gt;静态映射&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;动态映射&lt;/strong&gt;，即不事先指定映射类型(Mapping)，文档写入ElasticSearch时，ES会根据文档字段自动识别类型，这种机制称之为动态映射。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;静态映射&lt;/strong&gt;，即人为事先定义好映射，包含文档的各个字段及其类型等，这种方式称之为静态映射，亦可称为显示映射。&lt;/p&gt;

&lt;p&gt;Elasticsearch最重要的功能之一是它试图摆脱你的方式，让你尽快开始探索你的数据。Elasticsearch试图让你成功安装环境之后就可以直接使用。要索引文档，您不必首先创建索引、定义映射类型和定义字段，其实您只需索引一个文档数据，然后索引、类型和字段将自动生效。&lt;/p&gt;
&lt;p&gt;索引一个图书的文档：&lt;/p&gt;
&lt;pre class=&quot;http&quot;&gt;
&lt;code&gt;PUT /library/book/1
{
  &quot;bookId&quot;:1,
  &quot;bookName&quot;:&quot;Java核心技术 卷I&quot;,
  &quot;publishDate&quot;:&quot;2014-03-12&quot;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;返回结果如下，表示成功&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
  &quot;_index&quot;: &quot;library&quot;,
  &quot;_type&quot;: &quot;book&quot;,
  &quot;_id&quot;: &quot;1&quot;,
  &quot;_version&quot;: 1,
  &quot;result&quot;: &quot;created&quot;,
  &quot;_shards&quot;: {
    &quot;total&quot;: 2,
    &quot;successful&quot;: 1,
    &quot;failed&quot;: 0
  },
  &quot;_seq_no&quot;: 0,
  &quot;_primary_term&quot;: 1
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们看下mapping映射信息&lt;/p&gt;
&lt;pre class=&quot;http&quot;&gt;
&lt;code&gt;GET library/_mapping&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;得到如下映射信息，重点关注mapping节点的内容&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
  &quot;library&quot;: {
    &quot;mappings&quot;: {
      &quot;book&quot;: {
        &quot;properties&quot;: {
          &quot;bookId&quot;: {
            &quot;type&quot;: &quot;long&quot;
          },
          &quot;bookName&quot;: {
            &quot;type&quot;: &quot;text&quot;,
            &quot;fields&quot;: {
              &quot;keyword&quot;: {
                &quot;type&quot;: &quot;keyword&quot;,
                &quot;ignore_above&quot;: 256
              }
            }
          },
          &quot;publishDate&quot;: {
            &quot;type&quot;: &quot;date&quot;
          }
        }
      }
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，我们并没有创建索引映射，Elasticsearch自动根据文档数据为我们映射了字段类型，bookId的映射类型为long，bookName的映射类型为多字段的即为text，同时也为keyword，publishDate的映射类型为date。可以看到ES的动态映射功能还是蛮强大的。&lt;/p&gt;
&lt;p&gt;默认情况下，当在文档中找到以前未见过的字段时，Elasticsearch会自动将这个新字段添加到类型映射中。我们可以在文档和object级别禁用这项功能，具体操作方式就是通过将&lt;code&gt;dynamic&lt;/code&gt;参数设置为&lt;code&gt;false&lt;/code&gt;或&lt;code&gt;strict&lt;/code&gt;，&lt;strong&gt;设为false是忽略新字段，而设为strict是如果遇到未知字段，就抛出异常&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;假设启用了动态字段映射功能，则使用一些简单的规则来确定字段应具有的数据类型：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;2.5&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;null&lt;/td&gt;
&lt;td&gt;没有字段添加&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;true or false&lt;/td&gt;
&lt;td&gt;boolean&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;integer&lt;/td&gt;
&lt;td&gt;long&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;object&lt;/td&gt;
&lt;td&gt;object&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;array&lt;/td&gt;
&lt;td&gt;依赖于数组中首个非空值&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;string&lt;/td&gt;
&lt;td&gt;可以是日期字段、double或long字段，也可以是带有关键字子字段的文本字段。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;上面这些是可以动态检测到的字段数据类型，而其他的以外的字段必须要显式映射数据类型了。&lt;/p&gt;
&lt;p&gt;对于string字符串字段，动态映射的结果会有多种，可能映射为日期类型，也可能映射为double或long类型，也可能映射为带有关键字的text类型，具体结果要看配置的检测类型，是日期检测还是数字检测。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;日期检测&lt;/strong&gt;&lt;br/&gt;如果&lt;code&gt;date_detection&lt;/code&gt;启用（默认），则检查新字符串字段以查看其内容是否与&lt;code&gt;dynamic_date_formats&lt;/code&gt;指定的任何日期模式匹配 。如果找到匹配项，那么则添加为具有对应格式的date新字段。&lt;/p&gt;
&lt;p&gt;默认值为&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;dynamic_date_formats：[ &quot;strict_date_optional_time&quot;，&quot;yyyy/MM/dd HH:mm:ss Z||yyyy/MM/dd Z&quot;]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;PUT my_index/_doc/1
{
  &quot;create_date&quot;: &quot;2015/09/02&quot;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过&lt;code&gt;GET my_index/_mapping&lt;/code&gt;得到的结果为：&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
  &quot;my_index&quot;: {
    &quot;mappings&quot;: {
      &quot;_doc&quot;: {
        &quot;properties&quot;: {
          &quot;city&quot;: {
            &quot;type&quot;: &quot;text&quot;,
            &quot;fields&quot;: {
              &quot;raw&quot;: {
                &quot;type&quot;: &quot;keyword&quot;
              }
            }
          },
          &quot;create_date&quot;: {
            &quot;type&quot;: &quot;date&quot;,
            &quot;format&quot;: &quot;yyyy/MM/dd HH:mm:ss||yyyy/MM/dd||epoch_millis&quot;
          }
        }
      }
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;动态日期检测可以通过设置&lt;code&gt;date_detection&lt;/code&gt;为&lt;code&gt;false&lt;/code&gt;来禁用:&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;PUT my_index
{
  &quot;mappings&quot;: {
    &quot;_doc&quot;: {
      &quot;date_detection&quot;: false
    }
  }
}

PUT my_index/_doc/1 
{
  &quot;create&quot;: &quot;2015/09/02&quot;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;禁用之后，重新获取映射类型，得到如下结果：&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
  &quot;my_index&quot;: {
    &quot;mappings&quot;: {
      &quot;_doc&quot;: {
        &quot;date_detection&quot;: false,
        &quot;properties&quot;: {
          &quot;create&quot;: {
            &quot;type&quot;: &quot;text&quot;,
            &quot;fields&quot;: {
              &quot;keyword&quot;: {
                &quot;type&quot;: &quot;keyword&quot;,
                &quot;ignore_above&quot;: 256
              }
            }
          }
        }
      }
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这时，create_date字段已被添加为文本字段。我们也可以自定义检测到的日期格式，通过&lt;code&gt;dynamic_date_formats&lt;/code&gt;可以自定义以支持您自己的日期格式:&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;PUT my_index 
{ 
  &quot;mappings&quot;：{ 
    &quot;_ doc&quot;：{ 
      &quot;dynamic_date_formats&quot;：[&quot;MM / dd / yyyy&quot;] 
    } 
  } 
} &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;数字检测&lt;/strong&gt;&lt;br/&gt;虽然JSON支持本机浮点和整数数据类型，但某些应用程序或语言有时可能将数字呈现为字符串。通常，正确的解决方案是显式映射这些字段，但可以启用数字检测（默认情况下禁用）以自动执行此操作：&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;PUT my_index 
{ 
  &quot;mappings&quot;：{ 
    &quot;_ doc&quot;：{ 
      &quot;numeric_detection&quot;：true 
    } 
  } 
} 

PUT my_index / _doc / 1 
{ 
  &quot;my_float&quot;：&quot;1.0&quot;，
  &quot;my_integer&quot;：&quot;1&quot; 
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中my_float字段将添加为float字段，my_integer字段将添加为long字段。&lt;/p&gt;
&lt;p&gt;除了上面列出的选项外，还可以进一步自定义动态字段映射规则&lt;code&gt;dynamic_templates&lt;/code&gt;，动态模板允许您定义可应用于动态添加字段的自定义映射，具体取决于：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Elasticsearch检测到 的数据类型match_mapping_type。&lt;/li&gt;
&lt;li&gt;字段的名称，带match和unmatch或match_pattern。&lt;/li&gt;
&lt;li&gt;字段的完整虚线路径，带path_match和path_unmatch。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;更多具体内容可参考官方文档，&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/6.5/dynamic-templates.html&quot;&gt;Dynamic templates一章&lt;/a&gt;这里就不多叙述了。&lt;/p&gt;

&lt;p&gt;动态映射的自动类型推测功能并不是100%正确的，这就需要静态映射机制。静态映射与关系数据库中创建表语句类型，需要事先指定字段类型。相对于动态映射，静态映射可以添加更加详细字段类型、更精准的配置信息等。&lt;/p&gt;
&lt;p&gt;既然可以自定义映射字段类型，那么那些复杂的字段类型和分词器我们都可以根据自己需求添加了，以提供了字段映射使用的各种映射参数的详细说明，这些映射参数对于某些或所有字段数据类型是通用的，内容太多，这里感兴趣的读者可以点击具体链接阅读。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;8.9266666666667&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/6.5/analyzer.html&quot;&gt;analyzer&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;分析器&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4.8987854251012&quot;&gt;&lt;td&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/6.5/normalizer.html&quot;&gt;normalizer&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;在 Elasticsearch 中处理字符串类型的数据时，如果我们想把整个字符串作为一个完整的 term 存储，我们通常会将其类型 type 设定为 keyword。但有时这种设定又会给我们带来麻烦，比如同一个数据再写入时由于没有做好清洗，导致大小写不一致，比如 apple、Apple两个实际都是 apple，但当我们去搜索 apple时却无法返回 Apple的文档。要解决这个问题，就需要 Normalizer出场了。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;1.8550724637681&quot;&gt;&lt;td&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/6.5/mapping-boost.html&quot;&gt;boost&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;单个字段可以自动提升以计数更多的相关性得分&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4.9109792284866&quot;&gt;&lt;td&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/6.5/coerce.html&quot;&gt;coerce&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;强制尝试清除脏值以适合字段的数据类型。数据并不总是干净的，根据它的生成方式，数字可能会在JSON正文中呈现为真正的JSON数字，例如5，但它也可能呈现为字符串，例如&quot;5&quot;。或者，应该是整数的数字可以替代地呈现为浮点，例如5.0，或甚至 &quot;5.0&quot;。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2.8695652173913&quot;&gt;&lt;td&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/6.5/copy-to.html&quot;&gt;copy_to&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;copy_to参数允许您创建自定义 _all字段，可以将多个字段的值复制到组字段中，然后可以将其作为单个字段进行查询。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/6.5/doc-values.html&quot;&gt;doc_values&lt;/a&gt;&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/6.5/dynamic.html&quot;&gt;dynamic&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;设置动态映射&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2.827868852459&quot;&gt;&lt;td&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/6.5/enabled.html&quot;&gt;enabled&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;enabled设置只能应用于映射类型和 object字段，导致Elasticsearch完全跳过对字段内容的解析&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/6.5/fielddata.html&quot;&gt;fielddata&lt;/a&gt;&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/6.5/eager-global-ordinals.html&quot;&gt;eager_global_ordinals&lt;/a&gt;&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/6.5/mapping-date-format.html&quot;&gt;format&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;格式化日期&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/6.5/ignore-above.html&quot;&gt;ignore_above&lt;/a&gt;&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/6.5/ignore-malformed.html&quot;&gt;ignore_malformed&lt;/a&gt;&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/6.5/index-options.html&quot;&gt;index_options&lt;/a&gt;&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/6.5/mapping-index.html&quot;&gt;index&lt;/a&gt;&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/6.5/multi-fields.html&quot;&gt;fields&lt;/a&gt;&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/6.5/norms.html&quot;&gt;norms&lt;/a&gt;&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2.7744360902256&quot;&gt;&lt;td&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/6.5/null-value.html&quot;&gt;null_value&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;当字段设置为null，（或空数组或null值数组）时，它被视为该字段没有值。不能被索引或搜索&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/6.5/position-increment-gap.html&quot;&gt;position_increment_gap&lt;/a&gt;&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/6.5/properties.html&quot;&gt;properties&lt;/a&gt;&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/6.5/search-analyzer.html&quot;&gt;search_analyzer&lt;/a&gt;&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/6.5/similarity.html&quot;&gt;similarity&lt;/a&gt;&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/6.5/mapping-store.html&quot;&gt;store&lt;/a&gt;&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/6.5/term-vector.html&quot;&gt;term_vector&lt;/a&gt;&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;</description>
<pubDate>Tue, 18 Dec 2018 13:51:00 +0000</pubDate>
<dc:creator>JaJian</dc:creator>
<og:description>数据库建表的时候，我们的DDL语句一般都会指定每个字段的存储类型，例如：varchar，int，datetime等等，目的很明确，就是更精确的存储数据，防止数据类型格式混乱。 sql CREATE T</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jajian/p/10134164.html</dc:identifier>
</item>
<item>
<title>ASP.NET Core 实战：使用 ASP.NET Core Web API 和 Vue.js 搭建前后端分离项目 - 墨墨墨墨小宇</title>
<link>http://www.cnblogs.com/danvic712/p/10124871.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/danvic712/p/10124871.html</guid>
<description>&lt;h3&gt;&lt;strong&gt; 一、前言&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt; 　　这几年前端的发展速度就像坐上了火箭，各种的框架一个接一个的出现，需要学习的东西越来越多，分工也越来越细，作为一个 .NET Web 程序猿，多了解了解行业的发展，让自己扩展出新的技能树，对自己的职业发展还是很有帮助的。毕竟，现在都快到9102年了，如果你还是只会 Web Form，或许还是能找到很多的工作机会，可是，这真的不再适应未来的发展了。如果你准备继续在 .NET 平台下进行开发，适时开始拥抱开源，拥抱 ASP.NET Core，即使，现在工作中可能用不到。&lt;br/&gt;　　雪崩发生时，没有一片雪花是无辜的，你也不会知道那片雪花，会引起最后的雪崩。有些自说自话，见谅。&lt;/p&gt;
&lt;p&gt;　　系列目录地址：&lt;a title=&quot;ASP.NET Core 项目实战&quot; href=&quot;https://www.cnblogs.com/danvic712/p/10124831.html&quot;&gt;ASP.NET Core 项目实战&lt;/a&gt;&lt;br/&gt;　　仓储地址：&lt;a title=&quot;https://github.com/Lanesra712/Grapefruit.VuCore&quot; href=&quot;https://github.com/Lanesra712/Grapefruit.VuCore&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;https://github.com/Lanesra712/Grapefruit.VuCore&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt; 二、Step by Step&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　在整个的开发过程中，后端应用使用 Visual Studio 2017 进行开发，对于前端项目，则是使用 Visual Studio Code 进行开发，嗯，使用专业的工具做相应的事。对于前端的 Vue 项目，我采用的是 Vue CLI 来进行构建的，当然，巨硬也为我们准备了一套 Vue 的模板，如何使用的方法可以在附录中进行查看。&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;　　1、项目开发环境搭建&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;　　1.1、安装 .NET Core&lt;/p&gt;
&lt;p&gt;　　.NET Core 与之前的 .NET Framework 不一样，它不再紧紧的耦合在 Windows 系统上了，因此，我们可以在支持的操作系统上以安装软件的形式安装我们的 .NET Core 开发环境。&lt;/p&gt;
&lt;p&gt;　　打开官网的下载页面（&lt;a title=&quot;.NET Downloads&quot; href=&quot;https://dotnet.microsoft.com/download&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;.NET Downloads&lt;/a&gt;），找到 .NET Core，这里因为我们需要在当前环境进行开发，所以需要安装 .NET Core SDK，下载完成后，一路 Next 即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1310859/201812/1310859-20181218211729883-1884180707.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　当我们安装完成后，打开控制台，输入命令，则会显示出我们本机安装的 .NET Core 版本。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
dotnet --&lt;span&gt;info&lt;/span&gt; ## 或者使用 dotnet --version 查看本机安装的 .NET Core 版本信息
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1310859/201812/1310859-20181218211814679-98388532.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　在 .NET Core 中为我们提供了 .NET Core CLI 这一工具使我们使用命令行的方式创建我们的 .NET Core 应用，这里我们还是使用 VS 来创建我们的应用，有兴趣的朋友，可以看看园子里的这篇文章 =》&lt;a title=&quot;.NET Core dotnet 命令大全&quot; href=&quot;http://www.cnblogs.com/linezero/p/dotnet.html&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;.NET Core dotnet 命令大全&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　1.2、安装 Node.js &amp;amp; Vue CLI&lt;/p&gt;
&lt;p&gt;　　在整个前后端分离的项目的搭建中，前端的 Vue 项目，是使用 Vue CLI 3 进行搭建的脚手架项目，而 Vue CLI 本质上是一个全局安装的 npm 包，通过安装这一 npm 包可以为我们提供终端里的 vue 命令，因此我们需要使用这一脚手架工具的前提，则是需要我们安装 Node.js 环境。&lt;br/&gt;　　打开 Node.js 官网（&lt;a title=&quot;Node.js&quot; href=&quot;https://nodejs.org/zh-cn/&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;Node.js&lt;/a&gt;），选择长期支持版下载，之后一路 Next 下去即可。目前的 Node.js 安装包中已经包含了 npm，因此，我们安装好 Node.js 即可。npm 可以类比于我们 .NET 平台的 Nuget，而默认我们安装的全局组件和缓存默认是在 C:\Users\用户名\AppData\Roaming 下，如果你想修改缓存的地址或者全局安装的包地址则需要自己配置环境，具体可参考 =》&lt;a title=&quot;Node.js安装及环境配置之Windows篇&quot; href=&quot;https://www.jianshu.com/p/03a76b2e7e00&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;Node.js安装及环境配置之Windows篇&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　PS：Vue CLI 3 需要 Node.js 8.9 或更高版本 (推荐 8.11.0+)。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1310859/201812/1310859-20181218212032872-891708189.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　当 Node 环境安装好之后，我们就可以安装 Vue CLI 3 脚手架工具了，如果你之前已经全局安装了旧版本的 vue-cli (1.x 或 2.x)，则需要先卸载旧版本的 Vue CLI。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
npm uninstall vue-cli -g ## 卸载 vue-cli (&lt;span&gt;1&lt;/span&gt;.x or &lt;span&gt;2&lt;/span&gt;&lt;span&gt;.x)
npm &lt;/span&gt;&lt;span&gt;install&lt;/span&gt; -g @vue/cli
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　安装之后，我们就可以在命令行中使用 vue 命令。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;vue ## 查看 vue 相关帮助信息
vue &lt;/span&gt;--version ## 查看安装的 vue cli 版本信息
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1310859/201812/1310859-20181218212212069-752930932.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　1.3、安装 Git&lt;/p&gt;
&lt;p&gt;　　为代码添加版本控制是必须的，它可以详细的记录你的每一次操作，以及当你的某次作死导致的环境出错时，你可以很快的恢复环境。经常作死的表示，这个巨需要。&lt;br/&gt;        Git 作为一个分布式的版本控制系统，与 SVN 这种集中式的版本控制系统不同，我们的本地仓库不仅包含了我们的代码，还包含了每个人对代码的操作历史 log，而 SVN 的历史操作记录只存在于中央仓库中。&lt;br/&gt;        这样有什么好处呢？假如，某天中央仓库出错了需要重新创建，因为我们本地的代码不包含操作历史 log，你只能把代码重新放置到中央仓库，而文件的历史版本却丢失了。如果使用 Git 进行版本控制的话，因为我们本地的仓库是一个完整的包含历史操作记录的仓库，我们就可以毫无差别的重新搭建一个中央仓库。&lt;br/&gt;        Git 方面的学习教程，可以看看廖雪峰大神写的这一系列的教程 =》&lt;a title=&quot;Git 教程&quot; href=&quot;https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;Git 教程&lt;/a&gt;&lt;br/&gt;        打开 Git 官网（&lt;a title=&quot;Git&quot; href=&quot;https://git-scm.com/&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;Git&lt;/a&gt;）下载安装包安装，一路 Next 即可。安装完成后，开始菜单里出现 Git Bash 这个应用，则说明我们的 Git 已经安装成功了。安装 Git 之后，我们需要设置我们的名字以及 Email，从而表明我们的身份，这里使用 Git Bash 设置即可。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
git config --global user.name &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Your Name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; ## 全局设置用户名
git config &lt;/span&gt;--global user.email &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;email@example.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; ## 全局设置邮箱
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;&lt;strong&gt;　　2、应用整体框架搭建&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;当我们安装好项目开发的环境之后就可以搭建我们的项目框架了，这里我选择将前后端的项目放到同一个 Git 仓储中，你也可以根据你自己的喜好放到多个 Git 仓储中。&lt;br/&gt;　　新建一个文件夹作为仓储，在创建好的文件夹路径下打开 Git Bash，初始化我们的仓储。如果你勾选了显示隐藏文件夹，则会发现，当我们执行好初始化的命令之后，则会在当前文件夹下创建一个 .git 文件夹。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1310859/201812/1310859-20181218212455810-778036970.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　当然，你也可以使用 VS 进行创建 Git 仓储，使用 VS 创建仓储后会自动帮我们创建 .gitignore 和 .gitattributes 文件，同样的，后续对于该仓储的任何 Git 操作，我们也可以通过 VS 进行。&lt;br/&gt;　　gitignore 文件表示我们需要忽略的文件或目录，而 gitattribute 则用于设置非文本文件的对比方式，这里我们使用 VS 创建 Git 仓储后生成的 gitignore 文件默认会添加 .NET 项目需要忽略提交的文件和目录。因为，前端的项目我是使用 VS Code 进行开发的，这里，我需要将一些 VS Code 生成的文件也添加到 gitignore 文件中。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
.vscode&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
!.vscode/settings.json
!.vscode/tasks.json
!.vscode/launch.json
!.vscode/extensions.json&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1310859/201812/1310859-20181218212556766-736071874.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　创建 ASP.NET Core Web API 的具体过程就不演示了，这里采用的就是基础的多层架构，当我们创建好项目之后，可以看到 VS 右下角铅笔 icon 处会显示我们未做提交的修改。点击 icon ，输入我们的提交信息后，就可以将我们的修改提交到仓储中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1310859/201812/1310859-20181218212616353-418755490.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　后端的 API 接口应用创建好了，现在我们使用 Vue CLI 来构建我们前端的 Vue 项目。这里，我选择在解决方案的根目录创建我们的前端项目。&lt;br/&gt;　　在 Vue CLI 3 中，我们不仅可以使用 vue create 命令来创建我们的项目，而且可以使用图形化的页面创建我们的应用。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
vue create project-&lt;span&gt;name ## 使用命令行的形式创建
vue ui ## 使用图形化的方式创建&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1310859/201812/1310859-20181218212654878-486894289.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　当使用 vue ui 命令后会自动打开创建项目的页面，可以看到，这个路径下，并没有创建好的项目，你可以选择从别的路径下导入，或者是直接创建新的项目。如果你有使用过 Vue CLI 之前的版本，使用大写字母创建项目时是会报错的，但是在 Vue CLI 3 版本中没有出现这种问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1310859/201812/1310859-20181218212717671-797272083.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　因为我将前端项目与后端的项目放到同一个仓储中，所以这里就不需要再进行初始化 git 仓库了，对于项目的配置，这里就采用默认的配置。点击创建之后就会自动搭建我们的项目。如何启动这个脚手架项目，可以按照生成的 README 文件中的步骤执行。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1310859/201812/1310859-20181218212740042-335613260.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　到这里，基础的 Vue 脚手架项目就已经搭建完成了，对于添加插件之类的内容，放到我们后面的内容中。另外，虽然我们在创建项目时并没有勾选初始化 Git 仓储，但是 Vue CLI 还是创建了一个 gitignore 文件，如果你和我一样，是将前后端项目放到一个仓储的话，可以把这个文件里的内容复制到项目根目录中的 gitignore 文件中，然后把这个文件删除。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt; 三、附录&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt; 　　微软官方有提供一套 Vue 的 SPA 应用模板，不过并没有显示在我们使用 VS 创建项目的页面中，而且需要我们添加一个插件之后，使用 .NET Core CLI 的方式创建。因为自己并没有详细了解这块的内容，这里只列出创建的方法，详细的介绍请查看微软的官方文档（&lt;a title=&quot;Building Single Page Applications on ASP.NET Core with JavaScriptServices&quot; href=&quot;https://blogs.msdn.microsoft.com/webdev/2017/02/14/building-single-page-applications-on-asp-net-core-with-javascriptservices/&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;Building Single Page Applications on ASP.NET Core with JavaScriptServices &lt;/a&gt;）。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;## 安装 SPA 模板
dotnet new &lt;/span&gt;--&lt;span&gt;install&lt;/span&gt; Microsoft.AspNetCore.SpaTemplates::*
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1310859/201812/1310859-20181218212821565-2074661167.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　当你安装好模板之后，可以看到，多了使用 Aurelia、Vue、Knockout 创建 SPA 模板的选项，这时我们就可以使用 dotnet new 命令来创建包含 Vue 的模板应用。模板创建完成后需要安装依赖的包。加载完依赖的包之后，我们就可以通过 VS 或 VS Code 开发调试我们的项目。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;dotnet new vue ## 创建 Vue SPA 项目
npm &lt;/span&gt;&lt;span&gt;install&lt;/span&gt; ## 还原依赖的 npm 包
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1310859/201812/1310859-20181218212911541-574355686.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt; 四、总结&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt; 　　这一章没有包含很多的内容，主要就是如何搭建我们的 .NET Core 和 Vue 的开发环境，以及创建我们的项目架构，在后面的文章中则会慢慢的阐述整个项目的开发过程，希望可以能对你有一丢丢的帮助。&lt;/p&gt;
</description>
<pubDate>Tue, 18 Dec 2018 13:41:00 +0000</pubDate>
<dc:creator>墨墨墨墨小宇</dc:creator>
<og:description>一、前言 这几年前端的发展速度就像坐上了火箭，各种的框架一个接一个的出现，需要学习的东西越来越多，分工也越来越细，作为一个 .NET Web 程序猿，多了解了解行业的发展，让自己扩展出新的技能树，对自</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/danvic712/p/10124871.html</dc:identifier>
</item>
</channel>
</rss>