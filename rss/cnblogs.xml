<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>.NET Core实战项目之CMS 第十章 设计篇-系统开发框架设计 - 依乐祝</title>
<link>http://www.cnblogs.com/yilezhu/p/10094357.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yilezhu/p/10094357.html</guid>
<description>&lt;p&gt;这两天比较忙，周末也在加班，所以更新的就慢了一点，不过没关系，今天我们就进行千呼万唤的系统开发框架的设计。不知道上篇关于架构设计的文章大家有没有阅读，如果阅读后相信一定对架构设计有了更近一部的理解，如果你没有阅读也希望大家能好好阅读一下！其实说白了，架构是为了应对软件系统复杂度而提出的一个解决方案，架构设计的最终目的也就是为了让复杂的问题简单化！今天我们就结合架构设计的思想来进行我们的CMS实战项目的架构设计，接着再设计下开发框架吧。如果你有其他看法或者见解欢迎加入我们的实战项目交流群637326624 跟大伙共同交流！&lt;/p&gt;
&lt;blockquote readability=&quot;2.36&quot;&gt;
&lt;p&gt;本文已收录至《&lt;a href=&quot;https://www.cnblogs.com/yilezhu/p/9977862.html&quot;&gt;.NET Core实战项目之CMS 第一章 入门篇-开篇及总体规划&lt;/a&gt;》&lt;/p&gt;
&lt;p&gt;作者：依乐祝&lt;/p&gt;
&lt;p&gt;原文地址：&lt;a href=&quot;https://www.cnblogs.com/yilezhu/p/10094357.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/yilezhu/p/10094357.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;写在前面&quot;&gt;写在前面&lt;/h2&gt;
&lt;p&gt;仔细想想我们的这个极简CMS系统，可以说很简单，简单到都无须进行特殊的架构设计，只需按照你所熟悉的编码方式直接进行快速的编码实现即可，如果做得好的话，访问量上来了你再加一个缓存处理完全能够支撑一定的并发！如下图所示：我们前期先进行单体架构的实现，等后期分布式系列实战课程的时候再讲解如何进行分布式微服务架构的实现。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1377250/201812/1377250-20181210001550067-428779802.png&quot; alt=&quot;1544359198075&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看到没有，标准的单体架构，只是在数据库层之前加了一个缓存的设计来应对一些并发的情况！既然架构设计确定了，那么我们就进行开发框架的搭建吧！如果架构的复杂点的话，可能涉及到数据库集群，站点集群及负载均衡，可是我们完全没必要那样玩！一个阶段设计一个阶段的架构，要知道天猫也不是刚开始就架构的这么完善支持这么高的并发的！而是经过这么多次双十一的考验之后慢慢完成到今天这个能够支持每秒这么次并发的！说白了，架构是一个演变的过程，而并非设计的越复杂，越完善就表示架构设计的就越好的（有点拗口，自己理解下），而要结合实际，让需求来驱动架构。在分析设计阶段，需要考虑一定的人力与时间去&quot;跳出代码，总揽全局&quot;，为业务和IT技术之间搭建一座&quot;桥梁&quot;。&lt;/p&gt;
&lt;h2 id=&quot;cms系统开发框架&quot;&gt;CMS系统开发框架&lt;/h2&gt;
&lt;p&gt;话不多数，先看下我的项目结构截图吧！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1377250/201812/1377250-20181210001549491-1518736627.png&quot; alt=&quot;1544368326507&quot;/&gt;&lt;/p&gt;
&lt;p&gt;本来想进行很复杂的框架的实现的，仿照DDD的思想进行开发框架的搭建，后来想想何必呢，这么简单的系统搞得那么复杂，严重影响开发效率，反而得不尝试。后来经过深思熟虑后精简精简再精简，斟酌斟酌再斟酌后就有了上面这样的项目结构。乍一看10个项目，是不是吓得马上就要关闭网页了呢？下面我会给你详细讲解每一个项目的作用以及所要实现的功能。&lt;/p&gt;
&lt;p&gt;其实明眼人一看这个结构就已经知道了每个模块所要实现的功能了，这样的分层设计可谓简单的都不需要我过多介绍，你都能明白每一个项目是用来干什么的（明白人也可以进行项目的再度融合，甚至简单粗暴的合并到一个项目里面，不过本人更喜欢这种分层的设计感觉结构更清晰）。可是我这里还是要啰嗦两句给你介绍下：&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;既然微软已经在前两天将正式版的.NET Core SDK升级到了2.2的版本，那么我们的CMS系统就用.NET Core2.2进行搭建吧！当然，你在练习的时候也可以使用2.1进行，没有强制要求。&lt;/p&gt;
&lt;p&gt;注意：ASP.NET Core2.2对VisualStudio有一定的要求必须是2017的高版本才能用。其目前的版本是15.8.4 总之尽量不要低于我这个版本，我正准备升级呢！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol readability=&quot;10.125742574257&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;UI&lt;/p&gt;
&lt;p&gt;用户UI层：这个就是我们CMS系统所要呈现的用户界面，而我们得CMS系统又包含后台管理模块以及前台网站模块，因此这个解决方案文件夹下面有两个ASP.NET Core网站项目，留个思考题给你吧，猜猜看哪个项目是后台管理模块，哪个项目是前台网站模块呢？把你的答案写在留言区或者加群跟大伙讨论下吧！&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;Application&lt;/p&gt;
&lt;p&gt;应用层：这个层提供对用户界面的接口访问，用户界面层的两个模块如果想跟数据库交互都需要通过这个层来进行。这个应用层起到用户界面跟数据库操作进行解耦的作用。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;Repositonry&lt;/p&gt;
&lt;p&gt;仓储层：这个层主要就是跟数据库的交互了，任何跟数据库有关的操作都在这层来进行实现，看了上面的图相信你已经猜到了，前期我只是实现SqlServer的仓储实现，至于其他数据库的实现你只需要再建一个Czar.Cms.Repository.数据库名 的仓储实现就可以了！这里我们也是采用依赖抽象而不依赖具体实现所以方便后期的扩展。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1.8163265306122&quot;&gt;
&lt;p&gt;Entity&lt;/p&gt;
&lt;p&gt;实体对象层：这个层感觉有点多余，完全可以把这个界面融合到其他层，但是我并没有这样做，目的也是让结构更清晰，更容易理解。这里有两个项目，相信一路看教程过来的朋友一定还记得我的第二篇文章《&lt;a href=&quot;https://www.cnblogs.com/yilezhu/p/9985451.html&quot;&gt;.NET Core实战项目之CMS 第二章 入门篇-快速入门ASP.NET Core看这篇就够了&lt;/a&gt; 》中用的是ViewModel而不是直接用实体对象了！因为实际引用中可能我们页面中需要的数据跟我们数据库中的数据并不完全一样的，而且，有时候我们页面中可能包含了更多地信息，这时候我们怎么往视图中传递数据呢？这时候我们就有了ViewModel的概念。比方说：我们的有一个订单详细页要同时显示订单的信息，以及订单对应的商品列表，这时候怎么办呢？我们用一个ViewModel包含了订单实体，并且包含了商品的列表就可以更方便的把数据传递到视图里面了！&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;Infrastructure&lt;/p&gt;
&lt;p&gt;基础设施层：这个层也是我们代码的核心层了，我们会在这里实现很多我们通用的方法，比方说帮助类，对字符串String进行一些扩展，序列化与反序列化，HTTP请求，过滤器，日志功能，中间件的扩展等等。总之这个里面包含了Czar.Cms的所有核心。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Test&lt;/p&gt;
&lt;p&gt;测试层：这个层不用多说了吧，就是对系统进行测试的！里面包含单元测试以及集成测试！&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;相信通过我上面的介绍你一定会感觉到这个CMS系统的开发框架的层次非常清晰了吧！其实作为新手时期的我也是，看到项目太多的话就从心里面害怕，其实大伙大可不必，看到让你害怕的事情就要勇敢的面对它，战胜它，一定要跳出自己的舒适区。&lt;/p&gt;
&lt;h2 id=&quot;github与码云上的项目开源地址&quot;&gt;GitHub与码云上的项目开源地址&lt;/h2&gt;
&lt;p&gt;今天我们搭建的这个项目的结构我已经同步更新到Github以及码云上了，有兴趣的朋友可以下载查看！觉得不错的欢迎Star&lt;br/&gt;GitHub：&lt;a href=&quot;https://github.com/yilezhu/Czar.Cms&quot; class=&quot;uri&quot;&gt;https://github.com/yilezhu/Czar.Cms&lt;/a&gt;&lt;br/&gt;码云：&lt;a href=&quot;https://gitee.com/yilezhu/Czar.Cms&quot; class=&quot;uri&quot;&gt;https://gitee.com/yilezhu/Czar.Cms&lt;/a&gt;&lt;br/&gt;如果你觉得这个系列对您有所帮助的话，欢迎以各种方式进行支持，最简单有效的就是博客园给个推荐，GitHub给个Star。同时今天我申请了一个DotNetCore实战的订阅号，有兴趣的朋友可以微信关注下：&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/yilezhu/1359617/o_qrcode_for_gh_3d7593c84946_258.jpg&quot; alt=&quot;DotNetCore实战公众号&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;本文我首先带着大家理解了一下架构设计的目的，以及架构设计的演变性。接着对我们这个ASP.NET Core的CMS实战项目进行了开发框架的设计。并对每个项目的所要实现的功能以及各自的职责进行了相关的介绍！相信你已经能够清楚的明白了这个架构的思想！到此，设计篇已经结束，接下来就让我们进行真正的项目开发吧即开发篇的开始！&lt;/p&gt;
</description>
<pubDate>Sun, 09 Dec 2018 16:38:00 +0000</pubDate>
<dc:creator>依乐祝</dc:creator>
<og:description>这两天比较忙，周末也在加班，所以更新的就慢了一点，不过没关系，今天我们就进行千呼万唤的系统开发框架的设计。不知道上篇关于架构设计的文章大家有没有阅读，如果阅读后相信一定对架构设计有了更近一部的理解，如</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yilezhu/p/10094357.html</dc:identifier>
</item>
<item>
<title>react源码总览(翻译) - 大~熊</title>
<link>http://www.cnblogs.com/floor/p/10094323.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/floor/p/10094323.html</guid>
<description>&lt;blockquote readability=&quot;14.479768786127&quot;&gt;
&lt;p&gt;用react也有段时间了, 是时候看看人家源码了. 看源码之前看到&lt;a href=&quot;https://reactjs.org/docs/codebase-overview.html&quot;&gt;官方文档&lt;/a&gt; 有这么篇文章介绍其代码结构了, 为了看源码能顺利些, 遂决定将其翻译来看看, 小弟英语也是半瓢水, 好多单词得查词典, 不当之处请批评. 直接从字面翻译的, 后面看源码后可能会在再修改下.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;p&gt;下面是翻译&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;这部分将给你介绍下react代码的基本结构, 代码约定和它的基本实现.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果你想为react贡献代码的话, 我们希望这篇指南能让你写代码更加舒服.&lt;/p&gt;
&lt;p&gt;我们不推荐将这些约定用在react应用中, 因为这些约定大多是基于一些历史原因存在的, 随着时间推移可能会发生变化.&lt;/p&gt;
&lt;h2 id=&quot;外部依赖&quot;&gt;外部依赖&lt;/h2&gt;
&lt;p&gt;react 几乎没有外部依赖. 通常&lt;code&gt;require()&lt;/code&gt;指向的是react自己代码库的一个文件. 但是也有一些例外.&lt;/p&gt;
&lt;p&gt;由于react想要通过库共享一些诸如&lt;code&gt;Relay&lt;/code&gt;的小工具, 所以存在&lt;code&gt;fbjs repository&lt;/code&gt;, 而且我们让他们是同步的. 我们没有依赖任何node生态系统下的小模块, 因为我们希望facebook的工程师的能能再任何必要的时候修改他们. fbjs中的任何工具都不能被认为是公共api, 并且他们只是为Facebook的一些工程使用, 比如react.&lt;/p&gt;
&lt;h2 id=&quot;一级目录&quot;&gt;一级目录&lt;/h2&gt;
&lt;p&gt;克隆了react的仓库后你会发现在里边有几个一级目录.&lt;/p&gt;
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;code&gt;packages&lt;/code&gt;目录包括一些元数据(如package.json)和react库提供的所有包的源码(&lt;code&gt;src&lt;/code&gt;的下面), 如果你想修改代码, &lt;code&gt;src&lt;/code&gt;下面就是你要花时间最多的地方.&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;fixtures&lt;/code&gt;目录包括了为贡献者准备的一些小的react的测试应用&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;code&gt;build&lt;/code&gt;是react打包输出的目录. 他不在代码库管理范畴, 但是当你第一次打包后就会生成.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;文档是放在和react不同的另一个仓库管理的.&lt;/p&gt;
&lt;p&gt;还有一些其他一级目录, 他们大多是工具层面的, 在你贡献代码时可能不会用到他们能.&lt;/p&gt;
&lt;h2 id=&quot;共同测试colocated-tests&quot;&gt;共同测试(Colocated Tests)&lt;/h2&gt;
&lt;p&gt;我们没有搞个一级目录来做单元测试. 我们把它放在了被测试文件相邻的被称为&lt;code&gt;__tests__&lt;/code&gt;的目录.&lt;/p&gt;
&lt;p&gt;举个例子, 对于&lt;code&gt;setInnerHTML.js&lt;/code&gt;这个文件的测试被放在与他同级的&lt;code&gt;__tests__/setInnerHTML-test.js&lt;/code&gt;这个里边.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;这个词不知道怎么翻译&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;warnings-and-invariants&quot;&gt;Warnings and Invariants&lt;/h2&gt;
&lt;p&gt;react中使用&lt;code&gt;warning&lt;/code&gt;模块显示警告信息.&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;var warning = require('warning');

warning(
  2 + 2 === 4,
  'Math is not working today.'
);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;当警告条件是false的时候会展示警告信息&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以这么理解, 条件应该指示正常的情况, 而不是异常的情况. 就是说第一个参数是true表示的是正常, false是异常.&lt;/p&gt;
&lt;p&gt;最好避免使用console取代warnings.&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;var warning = require('warning');

var didWarnAboutMath = false;
if (!didWarnAboutMath) {
  warning(
    2 + 2 === 4,
    'Math is not working today.'
  );
  didWarnAboutMath = true;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;警告只会在开发模式被开启. 生产环境下被去掉了. 如果你想阻止某些代码块的执行, 那么你可以用&lt;code&gt;invariant&lt;/code&gt;模块.&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;var invariant = require('invariant');

invariant(
  2 + 2 === 4,
  'You shall not pass!'
);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;当条件为false时, 这个方法会直接抛出异常.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;“Invariant” 就是说这个条件为真, 你可以认为他就是做了个断言.&lt;/p&gt;
&lt;p&gt;保持开发环境和生产环境一致是很重要的, 因此&lt;code&gt;invariant&lt;/code&gt;在生产环境和开发环境都可以抛出异常. 生产环境下的错误消息被自动替换成错误码, 以防增加代码体积.&lt;/p&gt;
&lt;h2 id=&quot;development-and-production&quot;&gt;Development and Production&lt;/h2&gt;
&lt;p&gt;你可以使用&lt;code&gt;__DEV__&lt;/code&gt;这个为全局变量指定仅仅在开发环境才执行的代码块.&lt;/p&gt;
&lt;p&gt;他是在编译过程中工作的, 他是在commonjs编译的时候检查&lt;code&gt;process.env.NODE_ENV !== 'production'&lt;/code&gt;这个值.&lt;/p&gt;
&lt;p&gt;单独编译的时候, 他在未压缩版是true, 在压缩版直接被去掉了.&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;if (__DEV__) {
  // 这里边的代码只会带开发环境执行
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;flow&quot;&gt;Flow&lt;/h2&gt;
&lt;p&gt;我们最近开始引入&lt;code&gt;flow&lt;/code&gt;做静态类型检查, 在文件头的注释里标注了&lt;code&gt;@flow&lt;/code&gt;的使用了类型检查.&lt;/p&gt;
&lt;p&gt;我们接受在现有代码加入flow类型检查的pull request (不错哎, 可以试着提个pull request哦). Flow的签名类似下面这样.&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;ReactRef.detachRefs = function(
  instance: ReactInstance,
  element: ReactElement | string | number | null | false,
): void {
  // ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;时机成熟的时候, 新代码要用Flow 签名, 你可以在本地运行&lt;code&gt;yarn flow&lt;/code&gt;用Flow检查你的代码.&lt;/p&gt;
&lt;h2 id=&quot;动态植入&quot;&gt;动态植入&lt;/h2&gt;
&lt;p&gt;react在一些模块使用了动态植入. 但是这个东西不太好, 因为他让代码比较难理解了. 他存在的理由是react一开始只把支持dom作为目标的. 但是后来杀出了个React Native, 他是基于react的, 我们不得不加入动态植入好让react native 重载一些行为.&lt;/p&gt;
&lt;p&gt;你可能会看到模块像下面这样声明它的动态依赖&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// Dynamically injected
var textComponentClass = null;

// Relies on dynamically injected value
function createInstanceForText(text) {
  return new textComponentClass(text);
}

var ReactHostComponent = {
  createInstanceForText,

  // Provides an opportunity for dynamic injection
  injection: {
    injectTextComponentClass: function(componentClass) {
      textComponentClass = componentClass;
    },
  },
};

module.exports = ReactHostComponent;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注入的部分没有以任何方式特殊处理. 但是规定, 它的意思是这个模块想在运行时有一些依赖(可能是平台特定的)被注入进去.&lt;/p&gt;
&lt;p&gt;代码里边有几个注入的入口. 未来, 我们将废弃掉这种动态植入的机制, 方案是在编译时以静态方式处理他们.&lt;/p&gt;
&lt;h2 id=&quot;多包&quot;&gt;多包&lt;/h2&gt;
&lt;p&gt;react是个&lt;code&gt;monorepo&lt;/code&gt;, 他的仓库包含了多个独立的包, 因此他们的修改可以合在一起, 而且issues也可以放在一个地方.&lt;/p&gt;
&lt;h2 id=&quot;react核心&quot;&gt;React核心&lt;/h2&gt;
&lt;p&gt;react的核心是所有顶级api, 包括:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;React.createElement()&lt;/li&gt;
&lt;li&gt;React.Component&lt;/li&gt;
&lt;li&gt;React.Children&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;react核心只包括定义组件必要的api, 并不包括&lt;code&gt;reconciliation&lt;/code&gt;算法和平台特定代码. React DOM和React Native都使用了他们.&lt;/p&gt;
&lt;p&gt;react核心的相关代码在&lt;code&gt;packages/react&lt;/code&gt;里边. npm使用时在react这个包里边, 浏览器版的是react.js, 他挂载一个被称为React的全局变量.&lt;/p&gt;
&lt;h2 id=&quot;renderers&quot;&gt;Renderers&lt;/h2&gt;
&lt;p&gt;react起初是为DOM创造的, 但是后台通过RN被用来支持原生环境了. 这里介绍加react内部的“renderers”的理念.&lt;/p&gt;
&lt;p&gt;“renderers”管理了react树如何变成平台可调用的东西.&lt;/p&gt;
&lt;p&gt;Renderers也在&lt;code&gt;packages&lt;/code&gt;里边&lt;/p&gt;
&lt;ul readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;&lt;code&gt;React DOM Renderer&lt;/code&gt; 把react 组件渲染进 DOM. 他实现了顶级的&lt;code&gt;ReactDOM APIs&lt;/code&gt;, 在&lt;code&gt;react-dom&lt;/code&gt;这个npm包里被暴露出来. 浏览器版叫react-dom.js, 通过ReactDOM这个全局变量暴露出来.&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;React Native Renderer&lt;/code&gt;把react组件渲染到原生视图层里. 他被RN内部使用.&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;code&gt;React Test Renderer&lt;/code&gt; 把react组件渲染成JSON树, 他被&lt;code&gt;Jest&lt;/code&gt;的一个特性&lt;code&gt;Snapshot Testing&lt;/code&gt;使用, 在&lt;code&gt;react-test-renderer&lt;/code&gt;这个npm包里可用.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;另一个官方唯一支持的渲染器是&lt;code&gt;react-art&lt;/code&gt;, 他曾经是个独立的库, 现在被移进来了.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;技术上&lt;code&gt;react-native-renderer&lt;/code&gt;是很薄的一层, 只是用来和RN的实现相互配合, 真正的平台相关代码是RN库里一些native view.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;reconcilers协调器&quot;&gt;Reconcilers(协调器)&lt;/h2&gt;
&lt;p&gt;相当多的渲染器, 如Reat DOM, React Native 需要共享一套逻辑. 尤其reconciliation算法需要足够的相似, 以便让rendering, 自定义组件, 状态, 生命周期函数和refs能跨平台工作.&lt;/p&gt;
&lt;p&gt;为了解决这个问题, 不同的渲染器共用一些代码. 我们把React 中的这个部分叫做&quot;reconciler&quot;. 当一个更新比如setState要执行了,Reconcilers就去在组件上调用render(), 然后mounts, updates, 或者unmounts他们.&lt;/p&gt;
&lt;p&gt;Reconcilers没有独立成包, 因为他现在还没有公共API. 相反, 他仅仅是在渲染器被使用, 比如React DOM , React Native.&lt;/p&gt;
&lt;h2 id=&quot;stack-reconciler&quot;&gt;Stack Reconciler&lt;/h2&gt;
&lt;p&gt;Stack Reconciler 是在react15之前实现使用的, 现在已经不用了, 但是下一部分的文档还会有详细的介绍.&lt;/p&gt;
&lt;h2 id=&quot;fiber-reconciler&quot;&gt;Fiber Reconciler&lt;/h2&gt;
&lt;p&gt;&quot;Fiber&quot;是为了解决stack reconciler固有问题和修复长期存在的bug所做的努力, 他从react16开始成为默认的Reconciler.&lt;/p&gt;
&lt;p&gt;他的主要目标是:&lt;/p&gt;
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;在chunks里分离可中断的工作&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;在过程中重建, 重用work或者改变他的优先级(瞎翻译的)的能力&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;在父子组件前进或回退以只是react中的布局的能力&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;在render方法里返回多个元素的能力&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;更好的支持错误边际&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;你可在&lt;a href=&quot;https://github.com/acdlite/react-fiber-architecture&quot;&gt;这里&lt;/a&gt;和&lt;a href=&quot;https://blog.ag-grid.com/index.php/2018/11/29/inside-fiber-in-depth-overview-of-the-new-reconciliation-algorithm-in-react&quot;&gt;这里&lt;/a&gt;阅读更多关于Fiber架构的相关信息. 但是React16对他做了封装, 默认不支持异步特性了.&lt;/p&gt;
&lt;p&gt;他的源码在&lt;code&gt;packages/react-reconciler&lt;/code&gt;里边.&lt;/p&gt;
&lt;h2 id=&quot;事件系统&quot;&gt;事件系统&lt;/h2&gt;
&lt;p&gt;react实现了一个对renders透明的事件系统, 这个系统被用于react dom 和react native. 源码在&lt;code&gt;packages/events&lt;/code&gt;;&lt;/p&gt;
&lt;p&gt;这里有个视频&lt;a href=&quot;https://www.youtube.com/watch?v=dRo_egw7tBc&quot; class=&quot;uri&quot;&gt;https://www.youtube.com/watch?v=dRo_egw7tBc&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 09 Dec 2018 16:31:00 +0000</pubDate>
<dc:creator>大~熊</dc:creator>
<og:description>用react也有段时间了, 是时候看看人家源码了. 看源码之前看到官方文档有这么篇文章介绍其代码结构了, 为了看源码能顺利些, 遂决定将其翻译来看看, 小弟英语也是半瓢水, 好多单词得查词典, 不当之</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/floor/p/10094323.html</dc:identifier>
</item>
<item>
<title>蒙特卡洛积分与重要性采样详解 - 烈日行者</title>
<link>http://www.cnblogs.com/time-flow1024/p/10094293.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/time-flow1024/p/10094293.html</guid>
<description>&lt;p&gt;最近在看有关蒙特卡洛积分的内容，发现网上很多博主写的证明过程跳步较为严重，而且过程晦涩，不太容易理解。我在自己阅读国外相关教材附录后发现证明蒙特卡洛积分方法并不难，利用的仅是概率论的基本知识，现整理下来与大家分享。&lt;/p&gt;
&lt;p&gt;那么什么是蒙特卡洛积分？简而言之就是，在求积分时，如果找不到被积函数的原函数，那么利用经典积分方法是得不到积分结果的，但是蒙特卡洛积分方法告诉我们，利用一个随机变量对被积函数进行采样，并将采样值进行一定的处理，那么当采样数量很高时，得到的结果可以很好的近似原积分的结果。这样一来，我们就不用去求原函数的形式，就能求得积分的近似结果。&lt;/p&gt;
&lt;p&gt;一、前提知识：&lt;/p&gt;
&lt;p&gt;由概率论基本知识，假设一连续型随机变量$X$的样本空间为$D$，其概率密度分布函数为$p(x)$，则其数学期望为&lt;/p&gt;
&lt;p&gt;\begin{equation}&lt;br/&gt;E\left[X\right]=\int_D {xp(x){\rm{d}}x}&lt;br/&gt;\end{equation}&lt;/p&gt;
&lt;p&gt;若另一连续随机变量Y满足$Y=f(X)$，则$Y$的数学期望$E[Y]$可由下式给出&lt;br/&gt;\begin{equation}&lt;br/&gt;E\left[Y\right]=\int_D {f(x)p(x){\rm{d}}x}&lt;br/&gt;\end{equation}&lt;/p&gt;
&lt;p&gt;二、蒙特卡洛积分与重要性采样&lt;/p&gt;
&lt;p&gt;根据以上叙述，假设这里我们要计算一个一维积分式&lt;br/&gt;\begin{equation}&lt;br/&gt;A=\int_a^b {f(x){\rm{d}}x}&lt;br/&gt;\end{equation}&lt;br/&gt;根据经典的方法，我们需要求得$f(x)$的原函数$F(x)$，才能解出这个积分结果，但如果$f(x)$的原函数形式复杂，或者根本求不出来，总之在不知道$F(x)$的具体形式的情况下，如果我们还想计算这个积分，怎么办？这时候我们就需要借助蒙特卡洛积分(Monte Carlo Integration)方法。蒙特卡洛积分方法告诉我们，为求得积分结果，可以构造&lt;br/&gt;\begin{equation}&lt;br/&gt;\label{eq:FN}&lt;br/&gt;F_N = \frac{{b - a}}{N}\sum\limits_{i = 1}^N {f(X_i )}&lt;br/&gt;\end{equation}&lt;br/&gt;其中的每一个$X_i(i=1,2,3,...,N)$为$[a,b]$之间的均匀连续随机变量，所有的$X_i$组成一个随机变量集合。下面证明，$F_N$的数学期望即为我们要求的结果$A$。&lt;br/&gt;\begin{equation}&lt;br/&gt;\begin{split}&lt;br/&gt;\label{eq:proof1}&lt;br/&gt;E\left[ {F_N } \right] &amp;amp;= E\left[ {\frac{{b - a}}{N}\sum\limits_{i = 1}^N {f(X_i )} } \right] \\&lt;br/&gt;&amp;amp;=\frac{{b - a}}{N}\sum\limits_{i = 1}^N {E\left[ {f(X_i )} \right]} \\&lt;br/&gt;&amp;amp;= \frac{{b - a}}{N}\sum\limits_{i = 1}^N {\int_a^b {f(x)p(x){\rm{d}}x} } \\&lt;br/&gt;&amp;amp;= \frac{{b - a}}{N}\sum\limits_{i = 1}^N {\int_a^b {f(x)\frac{1}{{b - a}}{\rm{d}}x} } \\&lt;br/&gt;&amp;amp;= \frac{{b - a}}{N}\frac{1}{{b - a}}\sum\limits_{i = 1}^N {\int_a^b {f(x){\rm{d}}x} } \\&lt;br/&gt;&amp;amp;= \frac{1}{N}\sum\limits_{i = 1}^N {\int_a^b {f(x){\rm{d}}x} } \\&lt;br/&gt;&amp;amp;= \int_a^b {f(x){\rm{d}}x}&lt;br/&gt;\end{split}&lt;br/&gt;\end{equation}&lt;br/&gt;以上证明过程表明，若我们根据式(\ref{eq:FN})来构造一个新的随机变量$F_N$，则$F_N$的期望就是积分$\int_a^b{f(x){\rm{d}}x}$的结果，随着$N$的增加，$F_N$就越逼近理论上$A$的值，即$F_N$是$A$的一个无偏估计。这样我们实际上就避开了求$f(x)$的原函数$F(x)$的过程。整个求积分近似值的过程则可以用文字描述如下：首先从区间$[a,b]$上对均匀分布的随机变量$X$连续取样$N$次，得到$N$个取样值$\{x_1,x_2,x_3,...,x_N\}$，对每个取样值$x_i(i=1,2,3,...,N)$计算$f(x_i)$得到$\{f(x_1),f(x_2),f(x_3),...,f(x_N)\}$，再计算它们的和$\sum\limits_{i=1}^{N}{f(x_i)}$，最后乘系数$\frac{b-a}{N}$即可得到对理论值的一个估计。&lt;/p&gt;
&lt;p&gt;进一步对上述过程分析，我们发现这里的$X$被规定为与原积分区间相同的均匀分布随机变量。那么对于与原积分区间相同，但却不是均匀分布的一般随机变量，上述结论是否仍成立？结论是，如果这里的随机变量$X$的概率密度分布函数已知，那么上述结论还是成立的。假设其概率密度分布函数为$p(x)$，证明如下&lt;/p&gt;
&lt;p&gt;类似式(\ref{eq:FN})，这次我们构造&lt;br/&gt;\begin{equation}&lt;br/&gt;\label{eq:FN2}&lt;br/&gt;F_N = \frac{1}{N}\sum\limits_{i = 1}^N {\frac{{f(X_i )}}{{p(X_i )}}}&lt;br/&gt;\end{equation}&lt;br/&gt;再构造随机变量&lt;br/&gt;$$Y=\frac{f(X)}{p(X)}$$&lt;br/&gt;式(\ref{eq:FN2})的所有量都是已知的。则$F_N$的数学期望$E\left[F_N\right]$即为&lt;/p&gt;
&lt;p&gt;\begin{equation}&lt;br/&gt;\begin{split}&lt;br/&gt;\label{eq:proof2}&lt;br/&gt;E\left[ {F_N } \right] &amp;amp;= E\left[ {\frac{1}{N}\sum\limits_{i = 1}^N {\frac{{f(X_i )}}{{p(X_i )}}} } \right] \\&lt;br/&gt;&amp;amp;= \frac{1}{N}\sum\limits_{i = 1}^N {E\left[ {\frac{{f(X_i )}}{{p(X_i )}}} \right]} \\&lt;br/&gt;&amp;amp;= \frac{1}{N}\sum\limits_{i = 1}^N {E\left[ {Y_i } \right]} \\&lt;br/&gt;&amp;amp;= \frac{1}{N}\sum\limits_{i = 1}^N {\int_a^b {\left[ {\frac{{f(x)}}{{p(x)}}} \right]p(x){\rm{d}}x} } \\&lt;br/&gt;&amp;amp;= \frac{1}{N}\sum\limits_{i = 1}^N {\int_a^b {f(x){\rm{d}}x} } \\&lt;br/&gt;&amp;amp;= \int_a^b {f(x){\rm{d}}x}&lt;br/&gt;\end{split}&lt;br/&gt;\end{equation}&lt;/p&gt;
&lt;p&gt;我们发现式(5)其实是式(7)的特殊形式。与之前的要求不同，这里仅要求随机变量$X$的概率密度分布函数$p(x)$已知且在$X$的样本空间内$p(x)\ne0$。综合上述叙述，我们可以得到蒙特卡洛积分方法如下&lt;br/&gt;\begin{equation}&lt;br/&gt;\int_D {f(x){\rm{d}}x} = \mathop {\lim }\limits_{N \to \infty } \frac{1}{N}\sum\limits_{i = 1}^N {\frac{{f(X_i )}}{{p(X_i )}}}&lt;br/&gt;\end{equation}&lt;/p&gt;
&lt;p&gt;我们可以进一步地将求解一维积分的方法扩展到求解高维积分中去。考虑求解如下积分&lt;/p&gt;
&lt;p&gt;\begin{equation}&lt;br/&gt;\int_{z_1 }^{z_2 } {\int_{y_1 }^{y_2 } {\int_{x_1 }^{x_2 } {f(x,y,z){\rm{d}}x{\rm{d}}y{\rm{d}}z} } }&lt;br/&gt;\end{equation}&lt;/p&gt;
&lt;p&gt;只需要在积分域$\int_{z_1 }^{z_2 } {\int_{y_1 }^{y_2 } {\int_{x_1 }^{x_2 } } } $定义的盒型区域内选取概率密度分布为&lt;br/&gt;$$&lt;br/&gt;p(x) = \frac{1}{{\left( {x_2 - x_1 } \right)\left( {y_2 - y_1 } \right)\left( {z_2 - z_1 } \right)}}&lt;br/&gt;$$&lt;br/&gt;的均匀随机变量$X$，则积分结果为&lt;br/&gt;$$&lt;br/&gt;\frac{{\left( {x_2 - x_1 } \right)\left( {y_2 - y_1 } \right)\left( {z_2 - z_1 } \right)}}{N}\sum\limits_{i = 1}^N {f\left( {X_i } \right)}&lt;br/&gt;$$&lt;/p&gt;
&lt;p&gt;现在我们分析一下随着样本数量$N$的增加，估计值$F_N$的方差$\sigma ^2 \left[ {F_N } \right]$的变化情况，以便得出蒙特卡洛积分方法的收敛速度特性。在式(7)的基础上，我们继续计算$\sigma ^2 \left[ {F_N } \right]$如下&lt;/p&gt;
&lt;p&gt;\begin{equation}&lt;br/&gt;\begin{split}&lt;br/&gt;\label{eq:proof3}&lt;br/&gt;\sigma ^2 \left[ {F_N } \right] &amp;amp;= \sigma ^2 \left[ {\frac{1}{N}\sum\limits_{i = 1}^N {\frac{{f(X_i )}}{{p(X_i )}}} } \right] \\&lt;br/&gt;&amp;amp;= \frac{1}{{N^2 }}\sum\limits_{i = 1}^N {\sigma ^2 \left[ {\frac{{f(X_i )}}{{p(X_i )}}} \right]} \\&lt;br/&gt;&amp;amp;= \frac{1}{{N^2 }}\sum\limits_{i = 1}^N {\sigma ^2 \left[ {Y_i } \right]} \\&lt;br/&gt;&amp;amp;= \frac{1}{{N^2 }}\left( {N\sigma ^2 \left[ Y \right]} \right) \\&lt;br/&gt;&amp;amp;= \frac{1}{N}\sigma ^2 \left[ Y \right]&lt;br/&gt;\end{split}&lt;br/&gt;\end{equation}&lt;br/&gt;所以&lt;br/&gt;\begin{equation}&lt;br/&gt;\sigma \left[ {F_N } \right] = \frac{1}{{\sqrt N }}\sigma \left[ Y \right]&lt;br/&gt;\end{equation}&lt;br/&gt;上式告诉我们，估计值的不稳定来源于随机变量$Y$的取值不稳定。换句话说，如果$\frac{{f(X_i )}}{{p(X_i )}}$因不同$X_i$的取值变化地越剧烈，就会造成$Y$的方差较大，则会造成估计值的收敛速度越慢。这启示我们，若$p(x)$的形状越接近$f(x)$，则有益于最终结果的收敛。上述思想即为“重要性采样”方法，即对积分值有重要贡献($f(x)$较大)的被积函数区间，我们以较大概率生成处于这个区间附近的随机变量，用于快速逼近理论值。这也就是为什么我们要引入任意分布随机变量的蒙特卡洛积分方法，而不满足于利用均匀分布随机变量来求蒙特卡洛积分的原因。&lt;/p&gt;
&lt;p&gt;利用蒙特卡洛方法，我们可以得到任意一个积分的结果，但是代价就是我们得不到其理论值，我们得到的只是一个对理论值的估计，估计值与理论值之间的误差可以通过增加样本数来减小，但收敛速率仅为$O\left( {\sqrt N } \right)$，也就是说，若想将误差降为现在的一半，我们需要再多计算$4$倍的计算量才可以达到。即便如此，原始的蒙特卡洛积分方法也不失为是一种经典有效的方法。&lt;/p&gt;

</description>
<pubDate>Sun, 09 Dec 2018 16:25:00 +0000</pubDate>
<dc:creator>烈日行者</dc:creator>
<og:description>最近在看有关蒙特卡洛积分的内容，发现网上很多博主写的证明过程跳步较为严重，而且过程晦涩，不太容易理解。我在自己阅读国外相关教材附录后发现证明蒙特卡洛积分方法并不难，利用的仅是概率论的基本知识，现整理下</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/time-flow1024/p/10094293.html</dc:identifier>
</item>
<item>
<title>STL源码分析之内存池 - 倔强的铃铛</title>
<link>http://www.cnblogs.com/0xfffffff0/p/10094241.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/0xfffffff0/p/10094241.html</guid>
<description>&lt;h4 id=&quot;前言&quot;&gt;前言&lt;/h4&gt;
&lt;p&gt;上一节只分析了第二级配置器是由多个链表来存放相同内存大小, 当没有空间的时候就向内存池索取就行了, 却没有具体分析内存池是怎么保存空间的, 是不是内存池真的有用不完的内存, 本节我们就具体来分析一下&lt;/p&gt;
&lt;h4 id=&quot;内存池&quot;&gt;内存池&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;static data template的初始化&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;template &amp;lt;bool threads, int inst&amp;gt;
char *__default_alloc_template&amp;lt;threads, inst&amp;gt;::start_free = 0;  // 内存池的首地址
template &amp;lt;bool threads, int inst&amp;gt;
char *__default_alloc_template&amp;lt;threads, inst&amp;gt;::end_free = 0;    // 内存池的结束地址
template &amp;lt;bool threads, int inst&amp;gt;
size_t __default_alloc_template&amp;lt;threads, inst&amp;gt;::heap_size = 0;  // 多次调用内存池, 就会更多的是给链表分配内存, 这就是一个增量.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里代码注释写的很清楚了, 我就提取出来分析一下吧&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;内存池的大小大于需要的空间, 直接返回起始地址(nobjs默认设置为20, 所以每次调用都会给链表额外的19个内存块)&lt;/li&gt;
&lt;li&gt;内存池的内存不足以马上分配那么多内存, 但是还能满足分配一个即以上的大小, 那就全部分配出去&lt;/li&gt;
&lt;li&gt;如果一个对象的大小都已经提供不了了, 先将零碎的内存块给一个小内存的链表来保存, 然后就准备调用malloc申请40块+额外大小的内存块(额外内存块就由heap_size决定), 如果申请失败跳转到步骤4, 成功跳转到步骤6&lt;/li&gt;
&lt;li&gt;充分利用更大内存的链表, 通过递归来调用他们的内存块&lt;/li&gt;
&lt;li&gt;如果还是没有内存块, 直接调用一级配置器来申请内存, 还是失败就抛出异常, 成功申请就继续执行&lt;/li&gt;
&lt;li&gt;重新修改内存起始地址和结束地址为当前申请的地址块, 重新调用chunk_alloc分配内存&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// 内存池
template &amp;lt;bool threads, int inst&amp;gt;
char* __default_alloc_template&amp;lt;threads, inst&amp;gt;::chunk_alloc(size_t size, int&amp;amp; nobjs)
{
    char * result;
    size_t total_bytes = size * nobjs;            // 链表需要申请的内存大小
    size_t bytes_left = end_free - start_free;    // 内存池里面总共还有多少内存空间

      // 内存池的大小大于需要的空间, 直接返回起始地址
    if (bytes_left &amp;gt;= total_bytes) 
    {
        result = start_free;
        start_free += total_bytes;  // 内存池的首地址往后移
        return(result);
    }
    // 内存池的内存不足以马上分配那么多内存, 但是还能满足分配一个即以上的大小, 那就按对齐方式全部分配出去
    else if (bytes_left &amp;gt;= size) 
    {
        nobjs = bytes_left/size;
        total_bytes = size * nobjs;
        result = start_free;
        start_free += total_bytes;  // 内存池的首地址往后移
        return(result);
    } 
    else 
    { 
        // 如果一个对象的大小都已经提供不了了, 那就准备调用malloc申请两倍+额外大小的内存
        size_t bytes_to_get = 2 * total_bytes + ROUND_UP(heap_size &amp;gt;&amp;gt; 4);
        // Try to make use of the left-over piece.
        // 内存池还剩下的零头内存分给给其他能利用的链表, 也就是绝不浪费一点.
        if (bytes_left &amp;gt; 0) 
        {
            // 链表指向申请内存的地址
            obj * __VOLATILE * my_free_list = free_list + FREELIST_INDEX(bytes_left);
            ((obj *)start_free) -&amp;gt; free_list_link = *my_free_list;
            *my_free_list = (obj *)start_free;
        }
        start_free = (char *)malloc(bytes_to_get);
        // 内存不足了
        if (0 == start_free) 
        {
            int i;
            obj * __VOLATILE * my_free_list, *p;
            // 充分利用剩余链表的内存, 通过递归来申请
            for (i = size; i &amp;lt;= __MAX_BYTES; i += __ALIGN) 
            {   
                my_free_list = free_list + FREELIST_INDEX(i);
                p = *my_free_list;
                if (0 != p) 
                {
                    *my_free_list = p -&amp;gt; free_list_link;
                    start_free = (char *)p;
                    end_free = start_free + i;
                    return(chunk_alloc(size, nobjs));
                }
            }
            // 如果一点内存都没有了的话, 就只有调用一级配置器来申请内存了, 并且用户没有设置处理例程就抛出异常
            end_free = 0;   // In case of exception.
            start_free = (char *)malloc_alloc::allocate(bytes_to_get);
        }
            // 申请内存成功后重新修改内存起始地址和结束地址, 重新调用chunk_alloc分配内存
            heap_size += bytes_to_get;
            end_free = start_free + bytes_to_get;
            return(chunk_alloc(size, nobjs));
    }   
}&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h4 id=&quot;总结&quot;&gt;总结&lt;/h4&gt;
&lt;p&gt;内存池的存在就是为了能快速的提供我们做需要的内存并且保存多余的空间, 让STL分配空间不再每次都进行malloc和free的操作, 效率又很有保障. 有时用户申请的块更小, 我们也能充分的利用起来. 唯一可能不足的是我们每次只申请&lt;code&gt;char&lt;/code&gt;个大小, 但是内存池获得的确是8字节的大小.&lt;/p&gt;
</description>
<pubDate>Sun, 09 Dec 2018 15:59:00 +0000</pubDate>
<dc:creator>倔强的铃铛</dc:creator>
<og:description>前言 上一节只分析了第二级配置器是由多个链表来存放相同内存大小, 当没有空间的时候就向内存池索取就行了, 却没有具体分析内存池是怎么保存空间的, 是不是内存池真的有用不完的内存, 本节我们就具体来分析</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/0xfffffff0/p/10094241.html</dc:identifier>
</item>
<item>
<title>vue的.vue文件是怎么run起来的(vue-loader) - 薛小白</title>
<link>http://www.cnblogs.com/yangyangxxb/p/10094180.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yangyangxxb/p/10094180.html</guid>
<description>&lt;h2&gt;vue的.vue文件是怎么run起来的(vue-loader)&lt;/h2&gt;
&lt;p&gt;引子：vue的.vue文件是怎么跑起来的？&lt;/p&gt;
&lt;p&gt;　　　答：通过vue-loader，解析.vue文件，在webpack解析，拆解vue组件&lt;/p&gt;

&lt;p&gt;1、vue-loader做了什么？&lt;/p&gt;
&lt;p&gt;vue-loader是一个webpack加载器，这是vue组件的格式：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;template&amp;gt;&lt;span&gt;
    ...
&lt;/span&gt;&amp;lt;/template&amp;gt;
&amp;lt;script&amp;gt;&lt;span&gt;
    ...
&lt;/span&gt;&amp;lt;/script&amp;gt;
&amp;lt;style&amp;gt;&lt;span&gt;
    ...
&lt;/span&gt;&amp;lt;/style&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;它可以把这样的vue组件转化为JS模块，这其中最值得关注的是，它生成了 &lt;span&gt;render function code&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;render function&lt;/span&gt;&lt;span&gt;&lt;span&gt; code&lt;/span&gt; 
是从模板编译而来（可以并且应该预编译）的组件核心渲染方法，
在每一次组件的 Render 过程中，
通过注入的数据执行可生成虚拟 Dom&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;hr/&gt;

&lt;p&gt;2、vue核心执行过程&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1459163/201812/1459163-20181209230145607-875801588.png&quot; alt=&quot;&quot; width=&quot;300&quot; height=&quot;656&quot;/&gt;&lt;/p&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;vue核心的执行过程主要分为这几个阶段：&lt;br/&gt;&lt;/span&gt;1&lt;span&gt;） 编译模板，
生成可复用的render &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; code，
这一步在vue实例的整个生命周期中只会执行一次甚至零次，
因为我们可以在打包的时候可以预编译&lt;br/&gt;&lt;/span&gt;2&lt;span&gt;） 生成watcher等核心渲染监听，
在整个vue实例的生命过程中持续发生着作用，
对view和modal进行双向绑定&lt;br/&gt;&lt;/span&gt;3&lt;span&gt;） 虚拟dom的diff比较，
当watcher监听到data的变更的时候，
就会根据注入新的data执行render &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; code，
生成新的虚拟dom，
跟老的虚拟dom（第一次执行的时候可能为空）进行diff比对，
不同的部分将写入真实的dom&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sun, 09 Dec 2018 15:49:00 +0000</pubDate>
<dc:creator>薛小白</dc:creator>
<og:description>vue的.vue文件是怎么run起来的(vue-loader) 引子：vue的.vue文件是怎么跑起来的？ 答：通过vue-loader，解析.vue文件，在webpack解析，拆解vue组件 1、v</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yangyangxxb/p/10094180.html</dc:identifier>
</item>
<item>
<title>消息队列中间件（一）介绍 - 雪漫士兵</title>
<link>http://www.cnblogs.com/niumoo/p/10094082.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/niumoo/p/10094082.html</guid>
<description>&lt;h2 id=&quot;消息队列介绍&quot;&gt;消息队列介绍&lt;/h2&gt;
&lt;p&gt;消息队列中间件是大型系统中的重要组件，已经逐渐成为企业系统内部通信的核心手段。它具有松耦合、异步消息、流量削峰、可靠投递、广播、流量控制、最终一致性等一系列功能，已经成为异步RPC的主要手段之一。&lt;br/&gt;目前常见的消息中间件有ActiveMQ、RabbitMQ、ZeroMQ、Kafka、MetaMQ、RocketMQ等。&lt;br/&gt;&lt;/p&gt;
&lt;h2 id=&quot;消息队列应用场景&quot;&gt;消息队列应用场景&lt;/h2&gt;
&lt;p&gt;消息队列在实际中常见的应用场景有应用解耦、异步处理、流量错峰与流控、日志处理等等。&lt;/p&gt;
&lt;h3 id=&quot;应用解耦&quot;&gt;应用解耦&lt;/h3&gt;
&lt;p&gt;消息中间件顾名思义是用于消息存放的中间件。拿支付订单流程举例，在没有中间件的情况下，流程大致如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;用户支付订单，更新订单状态&lt;/li&gt;
&lt;li&gt;调用库存服务，完成响应功能&lt;/li&gt;
&lt;li&gt;调用积分服务，完成响应功能&lt;/li&gt;
&lt;li&gt;调用短信服务，发送短信通知&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这个过程是顺序执行的，如果库存和积分或者短信服务没有及时响应，或者短信服务处理堵塞，客户端用户收到响应的时间将会延长，体验变差。&lt;br/&gt;其实我们知道对于订单流程，只有订单处理才是核心服务，其他依赖系统不是那么重要，可以通知到即可。所以可以使用消息中间件，我们在处理完毕订单之后放入中间件立刻返回，然后后续服务从中间件中拿到数据进行后续的处理。&lt;/p&gt;
&lt;h3 id=&quot;异步处理&quot;&gt;异步处理&lt;/h3&gt;
&lt;p&gt;异步处理是使用消息中间件的一个重要功能，拿用户注册来说，如果没有消息中间件，流程大致如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;提交注册信息，保存注册信息①&lt;/li&gt;
&lt;li&gt;发送注册通知邮件②&lt;/li&gt;
&lt;li&gt;发送短信验证码③&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这个过程是顺序的，很明显在发送邮件或短信时候有可能因为网络等原因发送有一定延迟，这时候响应时间变长。时间为①+②+③。&lt;br/&gt;在不使用中间件的情况下我们可以稍微改进，可以在注册信息记录完毕之后同时调用发送通知邮件和发送短信验证码的程序。时间为①+（max(②，③)）。虽然改进，但是因为使用了并行处理，由于CPU的并行处理能力有限，瓶颈很快就会到来。&lt;br/&gt;可以继续改进，注册信息记录完毕之后写入中间件，立即返回。短信服务和邮件服务从中间件中取出信息发送通知，时间为①+写入中间件时间。&lt;/p&gt;
&lt;h3 id=&quot;流量错峰&quot;&gt;流量错峰&lt;/h3&gt;
&lt;p&gt;在类似于秒杀这样的场景中会在某个时间流量突增，大量的请求同时到达服务端，无疑对后端的压力会大大增加，如果都等着处理完成可能会堵死后续的请求。这时候可以使用消息中间件把需要处理的信息先存储在中间件，也可以控制活动的参与人数。在后续服务程序有能力时再拿出信息进行处理，就可以削平流量峰值。保证处理程序的正常运行。&lt;/p&gt;
&lt;h3 id=&quot;日志处理&quot;&gt;日志处理&lt;/h3&gt;
&lt;p&gt;在生产环境中，为了监控日志，会有大量的日志需要传输存储检索，现在比较有名的日志处理架构有ELK，在分布式应用中由于日志的数量级越来越大，存储起来对速度的要求也越快越快。这时候需要使用中间件解决大量日志传输的问题，比如Kafka。&lt;br/&gt;下图是一个常见的日志处理架构：&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/5408072-740536a1cb700d27.jpg?imageMogr2/auto-orient/&quot;/&gt;&lt;/p&gt;
&lt;ol readability=&quot;2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Kafka：接收用户日志的消息队列。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Logstash：做日志解析，统一成JSON输出给Elasticsearch。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Elasticsearch：实时日志分析服务的核心技术，一个schemaless，实时的数据存储服务，通过index组织数据，兼具强大的搜索和统计功能。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Kibana：基于Elasticsearch的数据可视化组件，超强的数据可视化能力是众多公司选择ELK stack的重要原因。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;jms消息服务&quot;&gt;JMS消息服务&lt;/h2&gt;
&lt;p&gt;JMS是Java消息服务（Java Message Service）应用程序接口，是一个Java平台中关于面向消息中间件（MOM）的API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。Java消息服务是一个与具体平台无关的API，绝大多数MOM提供商都对JMS提供支持。ActiveMQ就是JMS接口的实现。&lt;/p&gt;
&lt;h3 id=&quot;jms消息模式&quot;&gt;JMS消息模式&lt;/h3&gt;
&lt;p&gt;大部分的消息队列都有两种通信模式。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;点对点（Point-to-Point Messaging Domain）&lt;/li&gt;
&lt;li&gt;发布-订阅（Publish/Subscribe Messaging Domain）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;JMS也不例外的定义了这两种消息发送模型的规范，但是并没有给予实现,实现JMS接口的消息中间件(MOM)称为JMS Provider。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;点对点&lt;/strong&gt;&lt;br/&gt;消息到达消息系统，被保留在消息队列中，然后由一个或者多个消费者消费队列中的消息，一个消息只能被一个消费者消费，然后就会被移除。例如订单处理系统。&lt;br/&gt;&lt;strong&gt;发布-订阅&lt;/strong&gt;&lt;br/&gt;消息发送时指定主题（或者说通道），消息被保留在指定的主题中，消费者可以订阅多个主题，并使用主题中的所有的消息，例如现实中的电视与电视频道。所有客户端包括发布者和订阅者，主题中的消息可以被所有的订阅者消费，消费者只能消费订阅之后发送到主题中的消息。&lt;/p&gt;
&lt;h3 id=&quot;jms编码接口&quot;&gt;JMS编码接口&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;ConnectionFactory 用于创建连接到消费中间件的连接工厂&lt;/li&gt;
&lt;li&gt;Connection 代表了应用程序和消息服务器之间通信的线路&lt;/li&gt;
&lt;li&gt;Destination 指消息发布和接收的地点，包括队列和主题&lt;/li&gt;
&lt;li&gt;Session 表示一个单线程的上下文，用于发送和接收消息&lt;/li&gt;
&lt;li&gt;MessageConsumer 由会话创建，用于接收发送到目标的消息&lt;/li&gt;
&lt;li&gt;MessageProducer 由会话创建，用于发送消息到目标&lt;/li&gt;
&lt;li&gt;Message 是消费者在生产者之间传送的对象，消息头，一组消息属性，消息体&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&amp;lt;完&amp;gt;&lt;br/&gt;本文原发于个人博客：&lt;a href=&quot;https://www.codingme.net/&quot; class=&quot;uri&quot;&gt;https://www.codingme.net&lt;/a&gt; 转载请注明出处&lt;br/&gt;本文原文链接：&lt;a href=&quot;https://www.codingme.net/2018/11/io/mq-introduction/&quot; class=&quot;uri&quot;&gt;https://www.codingme.net/2018/11/io/mq-introduction/&lt;/a&gt;&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2626549-e1b06fdf782b78e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 09 Dec 2018 15:36:00 +0000</pubDate>
<dc:creator>雪漫士兵</dc:creator>
<og:description>消息队列介绍 消息队列中间件是大型系统中的重要组件，已经逐渐成为企业系统内部通信的核心手段。它具有松耦合、异步消息、流量削峰、可靠投递、广播、流量控制、最终一致性等一系列功能，已经成为异步RPC的主要</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/niumoo/p/10094082.html</dc:identifier>
</item>
<item>
<title>day81_淘淘商城项目_14_项目发布 + Linux下安装mysql + tomcat热部署 + 数据库分库分表 + Mycat学习_匠心笔记 - 黑泽君</title>
<link>http://www.cnblogs.com/chenmingjun/p/10094085.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenmingjun/p/10094085.html</guid>
<description>&lt;div id=&quot;output_wrapper_id&quot; readability=&quot;241.212136997&quot;&gt;
&lt;p&gt;第十四天：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;1、Linux上mysql的安装&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;2、系统的部署&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;3、mycat的介绍&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;4、项目总结&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;5、面试中的问题&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;h1&quot;&gt;&lt;span&gt;&lt;strong&gt;1、开发流程浅解&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/12/09/50gKbA.png&quot; alt=&quot;&quot;/&gt;&lt;h2 id=&quot;h2&quot;&gt;&lt;span&gt;&lt;strong&gt;2、项目发布前的准备&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1、测试&lt;/strong&gt;&lt;br/&gt;  a) 本地单元测试&lt;br/&gt;  b) 测试环境测试(1，2，3，4，5)&lt;br/&gt;  c) 用户测试(仿真环境：UAT环境)&lt;br/&gt;&lt;strong&gt;2、确认服务器的资源&lt;/strong&gt;&lt;br/&gt;  a) 硬件资源(CPU、内存、硬盘)&lt;br/&gt;  b) 软件资源(Linux、Windows)&lt;br/&gt;  c) 网络资源(宽带、机房、云服务器)&lt;br/&gt;&lt;strong&gt;3、相关参与的人员确认&lt;/strong&gt;&lt;br/&gt;  a) 测试人员&lt;br/&gt;  b) 开发人员&lt;br/&gt;&lt;strong&gt;4、数据库脚本的准备&lt;/strong&gt;&lt;br/&gt;  a) 初始化数据的sql脚本(DBA、运维)&lt;br/&gt;  b) 权限的sql脚本等&lt;br/&gt;&lt;strong&gt;5、编写发布的文档&lt;/strong&gt;&lt;br/&gt;  a) 开发人员编写各自负责的功能模块的&lt;code&gt;发布文档&lt;/code&gt;信息&lt;br/&gt;  b) 测试的文档(测试用例)&lt;br/&gt;  c) 全员参与&lt;br/&gt;&lt;strong&gt;6、打包&lt;/strong&gt;&lt;br/&gt;  a) 专门负责的人员进行打包处理(运维)&lt;br/&gt;&lt;strong&gt;7、准备&lt;code&gt;回滚方案&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;h3&quot;&gt;&lt;span&gt;&lt;strong&gt;3、项目部署&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;h3 id=&quot;h31linuxmysql&quot;&gt;&lt;span&gt;&lt;strong&gt;3.1、Linux下安装mysql&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;第一步：&lt;/strong&gt;查看mysql是否安装。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs nginx&quot;&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;rpm&lt;/span&gt; -qa | grep mysql&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;第二步：&lt;/strong&gt;如果mysql的版本不是想要的版本。需要把原来的mysql卸载。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs cs&quot;&gt;yum &lt;span class=&quot;hljs-keyword&quot;&gt;remove&lt;/span&gt; mysql mysql-server mysql-libs mysql-common&lt;br/&gt;rm -rf /&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt;/lib/mysql&lt;br/&gt;rm -f /etc/my.cnf&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  使用yum命令，因为yum命令可以自动删除与mysql相关的依赖；如果使用rpm命令，则还需要手动去删除和mysql相关的文件。&lt;br/&gt;&lt;strong&gt;第三步：&lt;/strong&gt;安装mysql。需要使用yum命令安装。在安装mysql之前需要安装mysql的下载源。需要从oracle的官方网站下载。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs css&quot;&gt;1）下载&lt;span class=&quot;hljs-selector-tag&quot;&gt;mysql&lt;/span&gt;的源包：&lt;br/&gt;我们是&lt;span class=&quot;hljs-selector-tag&quot;&gt;centos6&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.4&lt;/span&gt;对应的&lt;span class=&quot;hljs-selector-tag&quot;&gt;rpm&lt;/span&gt;包为：&lt;span class=&quot;hljs-selector-tag&quot;&gt;mysql-community-release-el6-5&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.noarch&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.rpm&lt;/span&gt;&lt;br/&gt;2）安装&lt;span class=&quot;hljs-selector-tag&quot;&gt;mysql&lt;/span&gt;下载源：&lt;br/&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;yum&lt;/span&gt; &lt;span class=&quot;hljs-selector-tag&quot;&gt;localinstall&lt;/span&gt; &lt;span class=&quot;hljs-selector-tag&quot;&gt;mysql-community-release-el6-5&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.noarch&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.rpm&lt;/span&gt;&lt;br/&gt;3）在线安装社区版的&lt;span class=&quot;hljs-selector-tag&quot;&gt;mysql&lt;/span&gt;：&lt;br/&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;yum&lt;/span&gt; &lt;span class=&quot;hljs-selector-tag&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;hljs-selector-tag&quot;&gt;mysql-community-server&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  rpm包位置：&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/12/09/50gUD9.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;strong&gt;第四步：&lt;/strong&gt;启动mysql。
&lt;pre&gt;
&lt;code class=&quot;hljs nginx&quot;&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;service&lt;/span&gt; mysqld start&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;第五步：&lt;/strong&gt;需要给root用户设置密码。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot;&gt;/usr/bin/mysqladmin -u root password &lt;span class=&quot;hljs-string&quot;&gt;'new-password'&lt;/span&gt;　　&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;第六步：&lt;/strong&gt;登录mysql。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs coffeescript&quot;&gt;[root@localhost temp]&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;第七步：&lt;/strong&gt;需要先登录到mysql，远程连接授权。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs sql&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;GRANT&lt;/span&gt; ALL &lt;span class=&quot;hljs-keyword&quot;&gt;PRIVILEGES&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;ON&lt;/span&gt; *.* &lt;span class=&quot;hljs-keyword&quot;&gt;TO&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;'myuser'&lt;/span&gt;@&lt;span class=&quot;hljs-string&quot;&gt;'%'&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;IDENTIFIED&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;BY&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;'mypassword'&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;WITH&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;GRANT&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;OPTION&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　注意：&lt;/strong&gt;&lt;/span&gt;&lt;code&gt;'myuser'&lt;/code&gt;、&lt;code&gt;'mypassword'&lt;/code&gt; 需要替换成实际的用户名和密码。&lt;br/&gt;　　mysql安装好了之后，启动服务，建立连接，导入taotao数据库文件。&lt;br/&gt;　　Linux上安装mysq链接：xxxxxxxxxxxxxxxxxxx后续补上&lt;/p&gt;
&lt;h3 id=&quot;h32&quot;&gt;&lt;span&gt;&lt;strong&gt;3.2、项目架构讲解&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/12/09/50gLNu.png&quot; alt=&quot;&quot;/&gt;&lt;h3 id=&quot;h33&quot;&gt;&lt;span&gt;&lt;strong&gt;3.3、系统功能介绍&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/12/09/50gEZN.png&quot; alt=&quot;&quot;/&gt;&lt;h3 id=&quot;h34&quot;&gt;&lt;span&gt;&lt;strong&gt;3.4、网络拓扑图&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/12/09/50g1KO.png&quot; alt=&quot;&quot;/&gt;&lt;h3 id=&quot;h35&quot;&gt;&lt;span&gt;&lt;strong&gt;3.5、系统部署&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;h4 id=&quot;h351&quot;&gt;&lt;span&gt;&lt;strong&gt;3.5.1、部署分析&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;工程共13个，如下所示，本着高可用的原则，每个工程至少有两台服务器。13个工程至少需要26台服务器。&lt;br/&gt;  taotao-manager&lt;br/&gt;  taotao-manager-web&lt;br/&gt;  taotao-content&lt;br/&gt;  taotao-portal-web&lt;br/&gt;  taotao-search&lt;br/&gt;  taotao-search-web&lt;br/&gt;  taotao-item-web&lt;br/&gt;  taotao-sso&lt;br/&gt;  taotao-sso-web&lt;br/&gt;  taotao-order&lt;br/&gt;  taotao-order-web&lt;br/&gt;  taotao-cart&lt;br/&gt;  taotao-cart-web&lt;br/&gt;  即淘淘商城在真实环境中要部署的话需要&lt;strong&gt;26&lt;/strong&gt;台服务器。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;服务&lt;/th&gt;
&lt;th&gt;服务器个数&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;Mysql&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Solr&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Redis&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;图片服务器&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Nginx&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;zookeeper 注册中心&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Activemq&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;  总共需要26+24=&lt;strong&gt;50&lt;/strong&gt;台服务器。但我们都知道，一般的小公司是绝不可能弄这么多服务器的，太昂贵了，比较可行的是采用&lt;strong&gt;&lt;code&gt;伪分布式&lt;/code&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&quot;h352&quot;&gt;&lt;span&gt;&lt;strong&gt;3.5.2、服务器规划&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;如下图所示，搭建服务原来需要&lt;strong&gt;24&lt;/strong&gt;台服务器，现在只需要&lt;strong&gt;7&lt;/strong&gt;台即可。&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/12/09/50g6We.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;搭建工程规划使用&lt;strong&gt;5&lt;/strong&gt;台服务器便可，如下图所示：&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/12/09/50gAnq.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;  这样规划的话，我们只需要7+5=&lt;strong&gt;12&lt;/strong&gt;台服务器即可。当然了，&lt;strong&gt;12&lt;/strong&gt;台服务器在一般的公司来说，也是达不到的，那么我们便可以进一步&lt;span&gt;&lt;strong&gt;压缩&lt;/strong&gt;&lt;/span&gt;，&lt;strong&gt;把更多的服务合并到一台服务器上，把更多的工程合并到一台服务器上&lt;/strong&gt;。&lt;br/&gt;　　我们&lt;code&gt;将服务精简成一台服务器&lt;/code&gt;：&lt;code&gt;192.168.25.133&lt;/code&gt;&lt;br/&gt;内存至少给2G以上。&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/12/09/50gIrd.png&quot; alt=&quot;&quot;/&gt;&lt;h4 id=&quot;h353&quot;&gt;&lt;span&gt;&lt;strong&gt;3.5.3、工程规划&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;工程规划表：&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/12/09/50gNiR.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;tomcat端口更新映射表：&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/12/09/50glmr.png&quot; alt=&quot;&quot;/&gt;&lt;h4 id=&quot;h354&quot;&gt;&lt;span&gt;&lt;strong&gt;3.5.4、域名规划&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;域名规划表：&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/12/09/50g8hY.png&quot; alt=&quot;&quot;/&gt;&lt;h4 id=&quot;h355tomcat&quot;&gt;&lt;span&gt;&lt;strong&gt;3.5.5、tomcat热部署&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;  可以使用maven的tomcat插件实现tomcat热部署。即&lt;code&gt;tomcat启动时部署工程&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;  tomcat有个&lt;code&gt;后台管理功能&lt;/code&gt;，可以实现工程热部署。部署完成后，我们不需要启动tomcat了，tomcat会自动把war包解压到ROOT目录下。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;tomcat后台管理功能&lt;/strong&gt;有两种方式可以访问，第一种是通过`&lt;strong&gt;图形化界面&lt;/strong&gt;`的方式，第二种是通过`&lt;strong&gt;命令行&lt;/strong&gt;`的方式，这两种方式需要&lt;strong&gt;配置相应的权限&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　第一种方式需要将工程打成war包，再手动上传，稍微有一些麻烦，第二种方式相对简单些。我们下面演示的是&lt;strong&gt;第二种方式&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;这里仅以taotao-content及taotao-portal-web为例子演示：&lt;/code&gt;&lt;/strong&gt;&lt;br/&gt;  在Linux下，我们新建有13个tomcat放置12工程：&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/12/09/50giDy.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;  先启动服务：启动redis，启动zookeeper，启动activemq，启动solr，启动mysql。&lt;br/&gt;配置方法：&lt;br/&gt;  先部署服务层工程，再部署表现层工程。&lt;br/&gt;&lt;hr/&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;code&gt;a) 部署taotao-content&lt;/code&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;linux系统上的配置：&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;第一步：&lt;/strong&gt;需要修改linux系统中对应的tomcat9002的conf/tomcat-users.xml配置文件。添加用户名、密码、权限。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs xml&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;role&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;rolename&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;manager-gui&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;role&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;rolename&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;manager-script&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;user&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;username&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;tomcat&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;password&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;tomcat&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;roles&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;manager-gui, manager-script&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  我们要将war包放在对应的tomcat9002中的webapps目录下的ROOT目录下，所以我们先在webapps目录下创建ROOT目录：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs coffeescript&quot;&gt;[root@localhost webapps]&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;第二步：&lt;/strong&gt;重新启动对应的tomcat9002。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs perl&quot;&gt;[root@localhost ~]&lt;br/&gt;/usr/&lt;span class=&quot;hljs-keyword&quot;&gt;local&lt;/span&gt;/taotao-projects/tomcat9002/bin&lt;br/&gt;[root@localhost bin]&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;第三步：&lt;/strong&gt;查看tomcat9002的启动日志。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs coffeescript&quot;&gt;[root@localhost tomcat9002]&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;开发机器上（windows系统）的配置：&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;第一步&lt;/strong&gt;：修改配置文件。&lt;br/&gt;  修改taotao-content工程中的相应的配置文件&lt;code&gt;db.properties&lt;/code&gt;中数据库的ip地址、端口、实例名、用户名、密码。修改&lt;code&gt;applicationContenxt-redis.xml&lt;/code&gt;中的ip地址、端口。（即：将原来的localhost修改为mysql所在的服务器的IP地址。）修改taotao-content工程中的发布服务的配置文件&lt;code&gt;applicationContenxt-service.xml&lt;/code&gt;中注册中心的地址，改成linux系统中的zookeeper的地址&lt;code&gt;192.168.25.133&lt;/code&gt;以及暴露服务的端口。&lt;br/&gt;&lt;strong&gt;第二步&lt;/strong&gt;：配置maven的tomcat插件，需要修改taotao-content工程的pom.xml文件。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs xml&quot;&gt;    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;build&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;plugins&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;plugin&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.apache.tomcat.maven&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;tomcat7-maven-plugin&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;configuration&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;port&lt;/span&gt;&amp;gt;&lt;/span&gt;8083&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;port&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;path&lt;/span&gt;&amp;gt;&lt;/span&gt;/&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;path&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;url&lt;/span&gt;&amp;gt;&lt;/span&gt;http://192.168.25.133:9002/manager/text&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;url&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;username&lt;/span&gt;&amp;gt;&lt;/span&gt;tomcat&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;username&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;password&lt;/span&gt;&amp;gt;&lt;/span&gt;tomcat&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;password&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;configuration&lt;/span&gt;&amp;gt;&lt;/span&gt;        &lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;plugin&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;plugins&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;build&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  &lt;span&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/span&gt;添加了三行配置，&lt;code&gt;&amp;lt;url&amp;gt;&lt;/code&gt;里面的tomcat热部署地址的端口号有所变化，现在是9002。大家可能会有疑问，&lt;code&gt;&amp;lt;url&amp;gt;&lt;/code&gt;配置上面的那个&lt;code&gt;&amp;lt;port&amp;gt;8083&amp;lt;/port&amp;gt;&lt;/code&gt;有什么用？会不会对部署产生坏的影响。这个其实不用担心，这个&lt;code&gt;port&lt;/code&gt;对热部署来说，没有用，这里之所以没有把它删掉是因为我们在&lt;code&gt;Windows系统下开发&lt;/code&gt;的时候给这个工程规划的端口是&lt;code&gt;8083&lt;/code&gt;，如果需要&lt;code&gt;在Windows系统下启动该工程的&lt;/code&gt;话，这个port就是有用的，因此这个&lt;code&gt;&amp;lt;port&amp;gt;8083&amp;lt;/port&amp;gt;&lt;/code&gt;配置我们不必理会，搁那儿就行。&lt;br/&gt;&lt;strong&gt;第三步&lt;/strong&gt;：使用maven命令进行部署。&lt;br/&gt;  选中taotao-content工程，右键 --&amp;gt; Run As --&amp;gt; Maven build…&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot;&gt;tomcat7:deploy      &lt;br/&gt;tomcat7:redeploy    &lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  部署的路径是&lt;code&gt;“/”&lt;/code&gt;会把系统部署到&lt;code&gt;webapps/ROOT目录下&lt;/code&gt;。&lt;br/&gt;  部署工程&lt;code&gt;跳过测试&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs css&quot;&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;clean&lt;/span&gt; &lt;span class=&quot;hljs-selector-tag&quot;&gt;tomcat7&lt;/span&gt;&lt;span class=&quot;hljs-selector-pseudo&quot;&gt;:redeploy&lt;/span&gt; &lt;span class=&quot;hljs-selector-tag&quot;&gt;-DskipTests&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;第四步&lt;/strong&gt;：在Linux下查看toamcat9002的日志&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs coffeescript&quot;&gt;[root@localhost tomcat9002]&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;日志输出内容如下图所示：&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/12/09/50gxpX.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/span&gt;每次&lt;code&gt;部署完服务后&lt;/code&gt;，都会停在如上图所示的位置上，需要我们&lt;code&gt;重新启动tomcat9002&lt;/code&gt;。暂时不知道为什么。&lt;br/&gt;&lt;strong&gt;第五步&lt;/strong&gt;：重新启动tomcat9002。&lt;br/&gt;&lt;strong&gt;第六步&lt;/strong&gt;：查看dubbo监控中心。&lt;br/&gt;  部署完服务层工程taotao-content后，我们到&lt;code&gt;dubbo服务治理&lt;/code&gt;--&amp;gt;&lt;code&gt;服务页面&lt;/code&gt;，发现多了两个服务，分别是com.taotao.content.service.ContentCategoryService和com.taotao.content.service.ContentService。说明我们的taotao-content工程部署成功。&lt;br/&gt;&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;&lt;code&gt;b) 部署taotao-portal-web&lt;/code&gt;&lt;/strong&gt;&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/span&gt;首先要确保新的服务器&lt;code&gt;192.168.25.133&lt;/code&gt;上安装的jdk是否与Eclipse开发时所用的jdk版本一致，我Eclipse开发时用的jdk1.7，因此服务器上的安装的jdk版本也要是1.7才行。不然会出现问题！！！&lt;strong&gt;（是个坑）&lt;/strong&gt;&lt;br/&gt;  Linux上安装jdk过程链接：&lt;a href=&quot;https://www.cnblogs.com/chenmingjun/p/9931593.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/chenmingjun/p/9931593.html&lt;/a&gt;&lt;br/&gt;&lt;strong&gt;linux系统上的配置：&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;第一步&lt;/strong&gt;：需要修改linux系统中对应的tomcat9003的conf/tomcat-users.xml配置文件。添加用户名、密码、权限。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs xml&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;role&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;rolename&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;manager-gui&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;role&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;rolename&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;manager-script&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;user&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;username&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;tomcat&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;password&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;tomcat&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;roles&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;manager-gui, manager-script&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  我们要将war包放在对应的tomcat9003中的webapps目录下的ROOT目录下，所以我们先在webapps目录下创建ROOT目录：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs coffeescript&quot;&gt;[root@localhost webapps]&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;第二步&lt;/strong&gt;：重新启动对应的tomcat9003。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs perl&quot;&gt;[root@localhost ~]&lt;br/&gt;/usr/&lt;span class=&quot;hljs-keyword&quot;&gt;local&lt;/span&gt;/taotao-projects/tomcat9003/bin&lt;br/&gt;[root@localhost bin]&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;第三步&lt;/strong&gt;：查看tomcat9003的启动日志。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs coffeescript&quot;&gt;[root@localhost tomcat9003]&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;开发机器上（windows系统）的配置：&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;第一步&lt;/strong&gt;：修改配置文件。&lt;br/&gt;  修改taotao-portal-web工程中的引用服务的配置文件springmvc.xml中注册中心的地址，改成linux系统中的zookeeper的ip地址&lt;code&gt;192.168.25.133&lt;/code&gt;。&lt;br/&gt;&lt;strong&gt;第二步&lt;/strong&gt;：配置maven的tomcat插件，需要修改taotao-portal-web工程的pom.xml文件。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs xml&quot;&gt;    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;build&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;plugins&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;plugin&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.apache.tomcat.maven&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;tomcat7-maven-plugin&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;configuration&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;port&lt;/span&gt;&amp;gt;&lt;/span&gt;8082&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;port&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;path&lt;/span&gt;&amp;gt;&lt;/span&gt;/&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;path&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;url&lt;/span&gt;&amp;gt;&lt;/span&gt;http://192.168.25.133:9003/manager/text&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;url&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;username&lt;/span&gt;&amp;gt;&lt;/span&gt;tomcat&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;username&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;password&lt;/span&gt;&amp;gt;&lt;/span&gt;tomcat&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;password&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;configuration&lt;/span&gt;&amp;gt;&lt;/span&gt;        &lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;plugin&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;plugins&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;build&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;第三步&lt;/strong&gt;：使用maven命令进行部署。&lt;br/&gt;  选中taotao-portal-web工程，右键 --&amp;gt; Run As --&amp;gt; Maven build…&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot;&gt;tomcat7:deploy      &lt;br/&gt;tomcat7:redeploy    &lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  部署的路径是&lt;code&gt;“/”&lt;/code&gt;会把系统部署到webapps/ROOT目录下。&lt;br/&gt;  部署工程&lt;code&gt;跳过测试&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs css&quot;&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;clean&lt;/span&gt; &lt;span class=&quot;hljs-selector-tag&quot;&gt;tomcat7&lt;/span&gt;&lt;span class=&quot;hljs-selector-pseudo&quot;&gt;:redeploy&lt;/span&gt; &lt;span class=&quot;hljs-selector-tag&quot;&gt;-DskipTests&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;第四步&lt;/strong&gt;：在Linux下查看toamcat9003的日志&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs coffeescript&quot;&gt;[root@localhost tomcat9003]&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;第五步&lt;/strong&gt;：重新启动tomcat9003。&lt;br/&gt;&lt;strong&gt;第六步&lt;/strong&gt;：查看dubbo监控中心。&lt;br/&gt;  部署完服务层工程taotao-portal-web后，我们到&lt;code&gt;dubbo服务治理&lt;/code&gt; --&amp;gt; &lt;code&gt;应用页面&lt;/code&gt;，发现多了两个应用，分别是taotao-content和taotao-portal-web。说明我们的taotao-portal-web工程部署成功。&lt;/p&gt;
&lt;h4 id=&quot;h356&quot;&gt;&lt;span&gt;&lt;strong&gt;3.5.6、其他工程部署&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;  同上 &lt;strong&gt;&lt;code&gt;a) 部署taotao-content&lt;/code&gt;&lt;/strong&gt; 和 &lt;strong&gt;&lt;code&gt;b) 部署taotao-portal-web&lt;/code&gt;&lt;/strong&gt; 步骤。&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;注意1：&lt;/strong&gt;&lt;/span&gt;在工程部署之前需要启动所有的服务：zookeeper、solr、redis、mysql、activemq&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;注意2：&lt;/strong&gt;&lt;/span&gt;每个工程运行在不同的tomcat上，需要修改tomcat的端口号。&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;注意3：&lt;/strong&gt;&lt;/span&gt;先部署服务层工程，再部署表现层工程。&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;注意4：&lt;/strong&gt;&lt;/span&gt;当部署使用到activemq的工程时，需要将原来的pom.xml文件的activemq的依赖配置项修改为新的，如下：&lt;br/&gt;原来的：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs xml&quot;&gt;    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.apache.activemq&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;activemq-all&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;新的：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs xml&quot;&gt;    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.apache.activemq&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;activemq-core&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果不修改成新的在部署的时候会报错，但是在开发使用原来的没有问题。（&lt;code&gt;这是一个坑&lt;/code&gt;）&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;部署大致步骤如下：&lt;br/&gt;&lt;strong&gt;第一步：&lt;/strong&gt;修改工程中的服务器的地址都改为192.168.25.133（在所有的jsp和xml中）&lt;br/&gt;&lt;strong&gt;第二步：&lt;/strong&gt;修改所有localhost对应正确的域名&lt;br/&gt;  例如：http://localhost:8088 --&amp;gt; http://sso.taotao.com&lt;br/&gt;&lt;strong&gt;第三步：&lt;/strong&gt;修改所有db.properties中的&lt;code&gt;localhost:3306/taotao&lt;/code&gt;为&lt;code&gt;192.168.25.133:3306/taotao&lt;/code&gt;，以及用户名和密码。&lt;br/&gt;&lt;strong&gt;第四步：&lt;/strong&gt;如果在数据库中没有创建taotao，需要创建一个，再导入数据。&lt;br/&gt;&lt;strong&gt;第五步：&lt;/strong&gt;反向代理配置如下&lt;code&gt;3.6、反向代理的配置&lt;/code&gt;所示：&lt;br/&gt;&lt;strong&gt;第六步：&lt;/strong&gt;测试，需要先将本地hosts切换为如下图所示配置：&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/12/09/50gSNi.png&quot; alt=&quot;&quot;/&gt;&lt;h3 id=&quot;h36&quot;&gt;&lt;span&gt;&lt;strong&gt;3.6、反向代理的配置&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;linux系统上的配置：&lt;/strong&gt;&lt;br/&gt;Linux系统上nginx配置反向代理，反向代理配置的是&lt;code&gt;表现层工程对应的端口&lt;/code&gt;，注意：配置upstream时不要有空格。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs perl&quot;&gt;[root@localhost conf]&lt;br/&gt;/usr/&lt;span class=&quot;hljs-keyword&quot;&gt;local&lt;/span&gt;/nginx/conf&lt;br/&gt;[root@localhost conf]&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;nginx.conf&lt;/p&gt;
&lt;pre readability=&quot;18.5&quot;&gt;
&lt;code class=&quot;hljs nginx&quot; readability=&quot;31&quot;&gt;&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;worker_processes&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;&lt;p&gt;&lt;span class=&quot;hljs-section&quot;&gt;events&lt;/span&gt; {&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;worker_connections&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;1024&lt;/span&gt;;&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-section&quot;&gt;http&lt;/span&gt; {&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;include&lt;/span&gt;       mime.types;&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;default_type&lt;/span&gt;  application/octet-stream;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;sendfile&lt;/span&gt;        &lt;span class=&quot;hljs-literal&quot;&gt;on&lt;/span&gt;;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;keepalive_timeout&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;65&lt;/span&gt;;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;upstream&lt;/span&gt; manager.taotao.com {&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;server&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;192.168.25.133:9001&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;upstream&lt;/span&gt; www.taotao.com {&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;server&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;192.168.25.133:9003&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;upstream&lt;/span&gt; search.taotao.com {&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;server&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;192.168.25.133:9005&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;upstream&lt;/span&gt; item.taotao.com {&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;server&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;192.168.25.133:9006&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;upstream&lt;/span&gt; sso.taotao.com {&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;server&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;192.168.25.133:9008&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;upstream&lt;/span&gt; order.taotao.com {&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;server&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;192.168.25.133:9010&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;upstream&lt;/span&gt; cart.taotao.com {&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;server&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;192.168.25.133:9012&lt;/span&gt;;&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-section&quot;&gt;server&lt;/span&gt; {&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;listen&lt;/span&gt;       &lt;span class=&quot;hljs-number&quot;&gt;80&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;server_name&lt;/span&gt;  manager.taotao.com;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;location&lt;/span&gt; / {&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;proxy_pass&lt;/span&gt;   http://manager.taotao.com;&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;index&lt;/span&gt;  index.html index.htm;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-section&quot;&gt;server&lt;/span&gt; {&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;listen&lt;/span&gt;       &lt;span class=&quot;hljs-number&quot;&gt;80&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;server_name&lt;/span&gt;  www.taotao.com;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;location&lt;/span&gt; / {&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;proxy_pass&lt;/span&gt;   http://www.taotao.com;&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;index&lt;/span&gt;  index.html index.htm;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-section&quot;&gt;server&lt;/span&gt; {&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;listen&lt;/span&gt;       &lt;span class=&quot;hljs-number&quot;&gt;80&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;server_name&lt;/span&gt;  search.taotao.com;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;location&lt;/span&gt; / {&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;proxy_pass&lt;/span&gt;   http://search.taotao.com;&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;index&lt;/span&gt;  index.html index.htm;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-section&quot;&gt;server&lt;/span&gt; {&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;listen&lt;/span&gt;       &lt;span class=&quot;hljs-number&quot;&gt;80&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;server_name&lt;/span&gt;  item.taotao.com;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;location&lt;/span&gt; / {&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;proxy_pass&lt;/span&gt;   http://item.taotao.com;&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;index&lt;/span&gt;  index.html index.htm;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-section&quot;&gt;server&lt;/span&gt; {&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;listen&lt;/span&gt;       &lt;span class=&quot;hljs-number&quot;&gt;80&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;server_name&lt;/span&gt;  sso.taotao.com;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;location&lt;/span&gt; / {&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;proxy_pass&lt;/span&gt;   http://sso.taotao.com;&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;index&lt;/span&gt;  index.html index.htm;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-section&quot;&gt;server&lt;/span&gt; {&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;listen&lt;/span&gt;       &lt;span class=&quot;hljs-number&quot;&gt;80&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;server_name&lt;/span&gt;  order.taotao.com;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;location&lt;/span&gt; / {&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;proxy_pass&lt;/span&gt;   http://order.taotao.com;&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;index&lt;/span&gt;  index.html index.htm;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-section&quot;&gt;server&lt;/span&gt; {&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;listen&lt;/span&gt;       &lt;span class=&quot;hljs-number&quot;&gt;80&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;server_name&lt;/span&gt;  cart.taotao.com;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;location&lt;/span&gt; / {&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;proxy_pass&lt;/span&gt;   http://cart.taotao.com;&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;index&lt;/span&gt;  index.html index.htm;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　注意：&lt;/strong&gt;&lt;/span&gt;修改好之后，需要&lt;code&gt;重新加载(reload)nginx的配置文件&lt;/code&gt;。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;开发机器上（windows系统）的配置：&lt;/strong&gt;&lt;br/&gt;测试时使用域名访问网站，需要修改&lt;code&gt;本地电脑(windows)hosts&lt;/code&gt;文件。&lt;br/&gt;所有的域名应该指向&lt;code&gt;反向代理服务器nginx&lt;/code&gt;。&lt;br/&gt;配置hosts文件，内容如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs css&quot;&gt;192&lt;span class=&quot;hljs-selector-class&quot;&gt;.168&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.25&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.133&lt;/span&gt; &lt;span class=&quot;hljs-selector-tag&quot;&gt;manager&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.taotao&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.com&lt;/span&gt;&lt;br/&gt;192&lt;span class=&quot;hljs-selector-class&quot;&gt;.168&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.25&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.133&lt;/span&gt; &lt;span class=&quot;hljs-selector-tag&quot;&gt;www&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.taotao&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.com&lt;/span&gt;&lt;br/&gt;192&lt;span class=&quot;hljs-selector-class&quot;&gt;.168&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.25&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.133&lt;/span&gt; &lt;span class=&quot;hljs-selector-tag&quot;&gt;search&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.taotao&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.com&lt;/span&gt;&lt;br/&gt;192&lt;span class=&quot;hljs-selector-class&quot;&gt;.168&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.25&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.133&lt;/span&gt; &lt;span class=&quot;hljs-selector-tag&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.taotao&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.com&lt;/span&gt;&lt;br/&gt;192&lt;span class=&quot;hljs-selector-class&quot;&gt;.168&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.25&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.133&lt;/span&gt; &lt;span class=&quot;hljs-selector-tag&quot;&gt;sso&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.taotao&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.com&lt;/span&gt;&lt;br/&gt;192&lt;span class=&quot;hljs-selector-class&quot;&gt;.168&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.25&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.133&lt;/span&gt; &lt;span class=&quot;hljs-selector-tag&quot;&gt;cart&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.taotao&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.com&lt;/span&gt;&lt;br/&gt;192&lt;span class=&quot;hljs-selector-class&quot;&gt;.168&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.25&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.133&lt;/span&gt; &lt;span class=&quot;hljs-selector-tag&quot;&gt;order&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.taotao&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.com&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以使用一个软件来配置本地电脑(windows)hosts文件，以管理员身份运行SwitchHosts软件：&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/12/09/50g2Kl.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;以上都配置好后，我们就可以进行测试访问。
&lt;h3 id=&quot;h37&quot;&gt;&lt;span&gt;&lt;strong&gt;3.7、数据库的读写分离与分库分表&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;  &lt;strong&gt;项目中：&lt;/strong&gt;执行查询的命令要比修改、删除、这些命令要多的多。所以为了保证数据库的&lt;code&gt;读写性能&lt;/code&gt;和数据库的&lt;code&gt;完整性&lt;/code&gt;。需要做&lt;code&gt;读写分离&lt;/code&gt;。&lt;br/&gt;&lt;strong&gt;什么是读写分离？&lt;/strong&gt;&lt;br/&gt;  通俗的讲就是读取的命令在一个数据库中，而写入的命令在另外一个库中。两个库中的数据必须&lt;code&gt;同步&lt;/code&gt;。&lt;br/&gt;Mysql提供的解决方案：&lt;code&gt;使用binlog进行数据库同步&lt;/code&gt;。需要配置mysql。&lt;br/&gt;&lt;strong&gt;代码中实现读写分类：&lt;/strong&gt;&lt;br/&gt;  1、可以使用aop实现一个切面。动态切换数据源。需要编程实现。&lt;br/&gt;  2、使用数据库中间件实现读写分离，&lt;code&gt;分库分表&lt;/code&gt;。（学习这个）&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/12/09/50ggdB.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;strong&gt;什么是分库分表？&lt;/strong&gt;&lt;br/&gt;  当数据库的表中数据非常大的时候例如上千万条数据。查询性能非常低。可以把一张表数据保存到不同的数据库中的不同表中。根据经验&lt;code&gt;mysql 2000万以上&lt;/code&gt;和 &lt;code&gt;oracle11G 1亿以上&lt;/code&gt;时需要分库分表。&lt;br/&gt;  可以使用一个&lt;code&gt;数据库中间件Mycat&lt;/code&gt;。国产开源项目，前身是&lt;code&gt;cobar项目&lt;/code&gt;。&lt;/div&gt;&lt;div readability=&quot;68.085756169069&quot;&gt;
&lt;h2 id=&quot;h4mycat&quot;&gt;&lt;span&gt;&lt;strong&gt;4、Mycat的学习&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;h3 id=&quot;h41mycat&quot;&gt;&lt;span&gt;&lt;strong&gt;4.1、Mycat的介绍&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/12/09/50g7oJ.png&quot; alt=&quot;&quot;/&gt;&lt;h3 id=&quot;h42mycat&quot;&gt;&lt;span&gt;&lt;strong&gt;4.2、什么是Mycat&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;简单的说，Mycat就是：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;一个彻底开源的，面向企业应用开发的“大数据库集群”&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;支持事务、ACID(4种特新)、可以替代Mysql的加强版数据库&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;一个可以视为“Mysql”集群的企业级数据库，用来替代昂贵的Oracle集群&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;一个融合内存缓存技术、Nosql技术、HDFS大数据的新型SQL Server&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;结合传统数据库和新型分布式数据仓库的新一代企业级数据库产品&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;一个新颖的数据库中间件产品&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Mycat的目标是：&lt;/strong&gt;&lt;/span&gt;低成本的将现有的单机数据库和应用&lt;code&gt;平滑迁移&lt;/code&gt;到“云”端，解决数据存储和业务规模迅速增长情况下的&lt;code&gt;数据瓶颈&lt;/code&gt;问题。&lt;/p&gt;
&lt;h3 id=&quot;h43mycat&quot;&gt;&lt;span&gt;&lt;strong&gt;4.3、Mycat的关键特性&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;支持 SQL 92标准&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;支持Mysql集群，可以作为Proxy使用&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;支持JDBC连接ORACLE、DB2、SQL Server，将其模拟为MySQL Server使用&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;支持galera for mysql集群，percona-cluster 或者 mariadb cluster，提供高可用性数据分片集群&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;自动故障切换，高可用性&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;支持读写分离，支持Mysql双主多从，以及一主多从的模式&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;支持全局表，数据自动分片到多个节点，用于高效表关联查询&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;支持独有的基于E-R 关系的分片策略，实现了高效的表关联查询&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;多平台支持，部署和实施简单&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;h44mycat&quot;&gt;&lt;span&gt;&lt;strong&gt;4.4、Mycat对多数据库的支持&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/12/09/50gnr6.png&quot; alt=&quot;&quot;/&gt;&lt;h2 id=&quot;h5mycat&quot;&gt;&lt;span&gt;&lt;strong&gt;5、Mycat的下载及安装&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;h3 id=&quot;h51mycat&quot;&gt;&lt;span&gt;&lt;strong&gt;5.1、下载Mycat&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;官方网站：&lt;br/&gt;  &lt;a href=&quot;http://www.mycat.org.cn/&quot; target=&quot;_blank&quot;&gt;http://www.mycat.org.cn/&lt;/a&gt;&lt;br/&gt;github地址：&lt;br/&gt;  &lt;a href=&quot;https://github.com/MyCATApache&quot; target=&quot;_blank&quot;&gt;https://github.com/MyCATApache&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;h52&quot;&gt;&lt;span&gt;&lt;strong&gt;5.2、环境准备&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;数据库准备，准备三个MySQL数据库实例。&lt;br/&gt;在Linux上安装一个MySQL数据库进行模拟，再设置三个数据库，作为集群中的库进行使用。&lt;br/&gt;&lt;strong&gt;分片规则：&lt;/strong&gt;&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/12/09/50gwz3.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;实现这个效果：需要在mycat中做一个配置。
&lt;h3 id=&quot;h53mycat&quot;&gt;&lt;span&gt;&lt;strong&gt;5.3、Mycat安装&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;h4 id=&quot;h531mycatlinux&quot;&gt;&lt;span&gt;&lt;strong&gt;5.3.1、第一步：上传mycat的文件到linux中&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/12/09/50goxp.png&quot; alt=&quot;&quot;/&gt;&lt;h4 id=&quot;h532usrlocal&quot;&gt;&lt;span&gt;&lt;strong&gt;5.3.2、第二步：移动并解压缩到/usr/local目录下&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs perl&quot;&gt;[root@localhost ~]&lt;br/&gt;[root@localhost ~]&lt;br/&gt;[root@localhost &lt;span class=&quot;hljs-keyword&quot;&gt;local&lt;/span&gt;]&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;h533mycat&quot;&gt;&lt;span&gt;&lt;strong&gt;5.3.3、第三步：配置Mycat实现分片&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;创建3个数据库实例&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/12/09/50n3hK.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;查看mycat的conf目录：
&lt;pre&gt;
&lt;code class=&quot;hljs perl&quot;&gt;[root@localhost &lt;span class=&quot;hljs-keyword&quot;&gt;local&lt;/span&gt;]&lt;br/&gt;[root@localhost conf]&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;文件内容详解如下图：&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/12/09/50n5kG.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;配置server.xml，配置的是逻辑库的名称和连接该库的用户名和密码
&lt;pre&gt;
&lt;code class=&quot;hljs coffeescript&quot;&gt;[root@localhost conf]&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配置内容如下：&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/12/09/50nDDn.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;配置逻辑库的时候注意：&lt;br/&gt;  注意：若是LINUX版本的MYSQL，则需要&lt;code&gt;设置为MySQL对大小写不敏感&lt;/code&gt;，否则可能会发生表找不到的问题。&lt;br/&gt;在MySQL的配置文件中/etc/my.cnf 中增加一行代码：
&lt;pre&gt;
&lt;code class=&quot;hljs ini&quot;&gt;&lt;span class=&quot;hljs-attr&quot;&gt;lower_case_table_names&lt;/span&gt; = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配置schema.xml，配置的是物理数据库的节点信息，包括：ip地址、端口、数据库名称、分片规则&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs coffeescript&quot;&gt;[root@localhost conf]&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配置内容如下：&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/12/09/50nF1Q.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;配置rule.xml，配置的是具体的分片规则
&lt;pre&gt;
&lt;code class=&quot;hljs coffeescript&quot;&gt;[root@localhost conf]&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配置内容如下：&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/12/09/50nBpE.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;查找分片算法&lt;br/&gt;配置的分片规则算法，可以参考以下源码：&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/12/09/50nHo2.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;源码位置：Mycat-server-1.4-RELEASE-sources.jar\org\opencloudb\route\function&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/12/09/50nmCz.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;配置分片算法&lt;br/&gt;根据分配片的java代码，继续在&lt;code&gt;rule.xml&lt;/code&gt;配置分片算法&lt;br/&gt;按下图方式配置分片规则算法：&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/12/09/50nXda.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;添加并编辑auto-id.txt文件，可以参考autopartition-long.txt文件
&lt;pre&gt;
&lt;code class=&quot;hljs coffeescript&quot;&gt;[root@localhost conf]&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;文件内容如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs ini&quot;&gt;&lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;0-127&lt;/span&gt;=&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;128-255&lt;/span&gt;=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;256-511&lt;/span&gt;=&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;h54mycat&quot;&gt;&lt;span&gt;&lt;strong&gt;5.4、Mycat测试&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;h4 id=&quot;h541mysql&quot;&gt;&lt;span&gt;&lt;strong&gt;5.4.1、第一步：连接mysql数据库&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/12/09/50nzxS.png&quot; alt=&quot;&quot;/&gt;&lt;h4 id=&quot;h5423&quot;&gt;&lt;span&gt;&lt;strong&gt;5.4.2、第二步：创建3个数据库实例&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;创建3个数据库实例，要求和mycat配置的schema.xml中的3个实例名称一致。&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/12/09/50nYzh.png&quot; alt=&quot;&quot;/&gt;&lt;h4 id=&quot;h543mycat&quot;&gt;&lt;span&gt;&lt;strong&gt;5.4.3.第三步：启动mycat&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;启动命令：./mycat start&lt;br/&gt;停止命令：./mycat stop&lt;br/&gt;重启命令：./mycat restart&lt;br/&gt;具体操作：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs coffeescript&quot;&gt;[root@localhost ~]&lt;br/&gt;[root@localhost bin]&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;内容如下：&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/12/09/50nQkN.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;查看启动日志
&lt;pre&gt;
&lt;code class=&quot;hljs coffeescript&quot;&gt;[root@localhost logs]&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;h544mycatserver&quot;&gt;&lt;span&gt;&lt;strong&gt;5.4.4、第四步：连接mycat server&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/span&gt;可以使用mysql的客户端直接连接&lt;strong&gt;mycat服务&lt;/strong&gt;。默认服务端口为&lt;strong&gt;8066&lt;/strong&gt;&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/12/09/50n0vH.png&quot; alt=&quot;&quot;/&gt;&lt;h4 id=&quot;h545&quot;&gt;&lt;span&gt;&lt;strong&gt;5.4.5、测试&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;  在mycat中创建数据库表，发现使用的三个库都创建了表。&lt;br/&gt;  在mycat中插入数据，发现按照规则给三个数据库分别插入了数据。&lt;/p&gt;
&lt;h2 id=&quot;h6&quot;&gt;&lt;span&gt;&lt;strong&gt;6、参考文章&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;  &lt;a href=&quot;https://blog.csdn.net/u012453843/article/details/73694543&quot; target=&quot;_blank&quot;&gt;https://blog.csdn.net/u012453843/article/details/73694543&lt;/a&gt;&lt;br/&gt;  &lt;a href=&quot;https://blog.csdn.net/u012453843/article/details/73656590&quot; target=&quot;_blank&quot;&gt;https://blog.csdn.net/u012453843/article/details/73656590&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Sun, 09 Dec 2018 15:27:00 +0000</pubDate>
<dc:creator>黑泽君</dc:creator>
<og:description>第十四天： 1、Linux上mysql的安装 2、系统的部署 3、mycat的介绍 4、项目总结 5、面试中的问题 1、开发流程浅解 2、项目发布前的准备 1、测试 a) 本地单元测试 b) 测试环境</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenmingjun/p/10094085.html</dc:identifier>
</item>
<item>
<title>如何發佈一個完整Node.js Module - KingJaja</title>
<link>http://www.cnblogs.com/KingJaja/p/9697427.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/KingJaja/p/9697427.html</guid>
<description>
&lt;p&gt;本文會透過以下幾個段落，讓各位一步一步學習如何寫一個自已的Node.js Module並且發佈到npm package上&lt;/p&gt;
&lt;p&gt;Node.js Module 結構&lt;/p&gt;
&lt;p&gt;我們先建立一個 NodeModuleDemo 的資料夾 ，接下來利用 npm init 進行初始化&lt;/p&gt;
&lt;p&gt;(這裡不用特別設置，一路按 Enter 到底即可)&lt;/p&gt;
&lt;p&gt;Tips. 這裡可以簡單的利用VSCode 熱鍵 Ctrl + ` 開啟命令視窗&lt;a href=&quot;https://img2018.cnblogs.com/blog/830852/201810/830852-20181004235156464-940328204.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/830852/201810/830852-20181004235157177-1746013498.png&quot; alt=&quot;image&quot; width=&quot;452&quot; height=&quot;359&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;初始化完成的畫面如上&lt;/p&gt;
&lt;p&gt;接下來我們會先建立好相關的資料夾用來分類我們的程式碼&lt;/p&gt;
&lt;p&gt;其中 lib 資料夾是我們要寫的原始程式碼，test 資料夾則專門放我們的測試程式&lt;/p&gt;
&lt;p&gt;最後 benchmark 資料夾裡面是用來做我們效能測試的程式&lt;/p&gt;
&lt;p&gt;因我們這次會利用 ES6 的 Class 語法來寫我們的模組程式，所以這裡也需要加入 babel 的設定&lt;/p&gt;
&lt;p&gt;再來為了讓我們的程式碼可以有統一的風格，我們也會加入 eslint 的設定&lt;/p&gt;
&lt;p&gt;( babel 與 eslint 我通常會裝成全域的package ，各位可以自已選擇要安裝的目標)&lt;/p&gt;
&lt;p&gt;先來安裝 babel 與 eslint 吧！&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/830852/201810/830852-20181013171515589-1466141479.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/830852/201810/830852-20181013171516407-672991999.png&quot; alt=&quot;image&quot; width=&quot;650&quot; height=&quot;292&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;安裝完後，可以像上圖中，透過 –version 來確認安裝的狀況&lt;/p&gt;
&lt;p&gt;這裡可以看到我們的 babel 版本為 6.26.0 而 eslint 則為 5.7.0&lt;/p&gt;
&lt;p&gt;再來我們下一步先建立 babel 的設定檔，檔名為 .babelrc 放置在我們的根目錄下&lt;/p&gt;
&lt;p&gt;內容直接設為&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;&quot;presets&quot;: [&quot;env&quot;]&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;eslint 的部分則更簡單了，只需要在命令視窗輸入 eslint –init 選擇想要的範本即可，在我們的練習中，我們選擇&lt;/p&gt;
&lt;p&gt;standard 。最後會自動在根目錄產出 .eslintrc.js 檔 ，相關的操作如下圖 (黃字標示處)&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/830852/201810/830852-20181013172319155-703345657.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/830852/201810/830852-20181013172319869-1444113976.png&quot; alt=&quot;image&quot; width=&quot;650&quot; height=&quot;292&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最後，因為我們希望 eslint 只檢查我們 lib 主程式目錄，所以這裡需要加入一個 .eslintignore 檔&lt;/p&gt;
&lt;p&gt;將我們的 test 、benchmark 及輸出的 dist 資料夾做排除的動作，話不多說請看下圖&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/830852/201810/830852-20181013172441394-307346674.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/830852/201810/830852-20181013172441825-1070354282.png&quot; alt=&quot;image&quot; width=&quot;563&quot; height=&quot;307&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;整個 Node.js Module 的目錄架構會像下圖這樣 ( formatter 、output 、index.js 可以先建立起來)&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/830852/201810/830852-20181013172442248-2010277364.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/830852/201810/830852-20181013172442740-71218685.png&quot; alt=&quot;image&quot; width=&quot;501&quot; height=&quot;499&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;再來我們就開始動手寫我們的模組程式吧！&lt;/p&gt;
&lt;p&gt;我們這次要做一個很簡單的文字轉換程式，輸出效果大致如下&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/830852/201810/830852-20181014195346747-1061055064.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/830852/201810/830852-20181014195347252-210944986.png&quot; alt=&quot;image&quot; width=&quot;650&quot; height=&quot;144&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;首先我們先來寫做轉換的主程式，大致如下&lt;/p&gt;
&lt;blockquote readability=&quot;15&quot;&gt;
&lt;p&gt;export default class MyTextOutput {&lt;/p&gt;
&lt;p&gt;constructor (formatter = null) {&lt;/p&gt;
&lt;p&gt;  this.formatter = formatter&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;getResult (text) {&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;  if (!this.formatter) {&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;    throw new Error('Text Formatter is required')&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;  }&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;   let result = this.formatter.getFormatterText(text)&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;    return result&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;首先 MyTextOutput 類需要在建立時指定要用的 formatter , 最後再透過 getResult 取得轉換後的內容&lt;/p&gt;
&lt;p&gt;而這裡我們就簡單的寫一個 SimpleFormatter 做到一個簡易的轉換效果&lt;/p&gt;
&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;export default class SimpleFormatter {&lt;/p&gt;
&lt;p&gt;getFormatterText (text) {&lt;/p&gt;
&lt;p&gt;let trans = {&lt;/p&gt;
&lt;p&gt;'a': 'Ä',&lt;/p&gt;
&lt;p&gt;'b': 'ß',&lt;/p&gt;
&lt;p&gt;'c': 'Ć'&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;let outPutTxt = ''&lt;/p&gt;
&lt;p&gt;for (let index = 0; index &amp;lt; text.length; index++) {&lt;/p&gt;
&lt;p&gt;      const ele = text[index]&lt;/p&gt;
&lt;p&gt;    outPutTxt += trans[ele.toLowerCase()]&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;    return outPutTxt&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;加入測試&lt;/p&gt;
&lt;p&gt;在我們完成程式之後，通常會寫一段測試程式來保護你的程式。 當然，如果是採用 TDD 開發方式的話，則是先寫完你的測試程式，再寫你的主程式。但我們這裡先不介紹 TDD , 單純的來介紹一下你的測試程式該怎麼寫&lt;/p&gt;
&lt;p&gt;在寫我們的測試程式之前，我們需要先安裝相關的套件，在這個範例中我們會用到 mocha 與 chai 這兩個套件&lt;/p&gt;
&lt;p&gt;安裝方式如下圖&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/830852/201810/830852-20181014195347746-390324414.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/830852/201810/830852-20181014195348359-1771090198.png&quot; alt=&quot;image&quot; width=&quot;650&quot; height=&quot;238&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;再來就是我們的測試程式了，我們這次會簡單的寫兩個案例&lt;/p&gt;
&lt;p&gt;一個是忘記指定要使用的formatter 另一個則是我們輸入文字 abc 應該要出現我們預期的結果&lt;/p&gt;
&lt;p&gt;完整的案例如下&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/830852/201810/830852-20181014204846276-2002164700.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/830852/201810/830852-20181014204847172-1929127493.png&quot; alt=&quot;image&quot; width=&quot;650&quot; height=&quot;499&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;要運行上述的測試案例 我們需要在 package.json 裡添加相關的 script ，參考下圖&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/830852/201811/830852-20181114235148838-584641793.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/830852/201811/830852-20181114235149851-1671508172.png&quot; alt=&quot;image&quot; width=&quot;650&quot; height=&quot;314&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;接下來運行 npm run test 時便可自動的進行測試案例執行&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/830852/201811/830852-20181114235150466-879633841.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/830852/201811/830852-20181114235151121-328579248.png&quot; alt=&quot;image&quot; width=&quot;650&quot; height=&quot;163&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3.加入typing.d.ts&lt;/p&gt;
&lt;p&gt;這裡加入 typing 檔其實是為了讓使用者用 VSCode 在開發時，能夠擁有 Intellisense 的效果&lt;/p&gt;
&lt;p&gt;在這裡我們透過微軟提供的 dts-gen 來產生 typeing 檔案。首先我們需要先安裝 dts-gen 這個套件&lt;/p&gt;
&lt;p&gt;接下來比較麻煩的是，依照文件上說明，我們需要先透過 npm 安裝我們的套件，才可以產生 typing 檔&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;pre&gt;
npm install -g dts-gen
&lt;/pre&gt;
&lt;pre&gt;
npm install –g nodedemomodule
&lt;/pre&gt;
&lt;pre&gt;
dts-gen --dt --name nodedemomodule --template module
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt;不過在我實作的過程中發現到， dts-gen  在產生的時候會少掉主程式的定義，變成我們主程式這個部分需要手動加入。最後產生出來的 typing 檔如下。其中 MyTextOutput 這裡面的定義是我手動加入的&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/830852/201812/830852-20181209213920997-1026376754.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/830852/201812/830852-20181209213921752-1788018657.png&quot; alt=&quot;image&quot; width=&quot;640&quot; height=&quot;473&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;再來就是在 package.json 設定發佈時要將 typing 檔上傳&lt;/p&gt;
&lt;p&gt;這猚可以看到我們的 typing 檔檔名是叫 index.d.ts ，並且是放在根目錄底下&lt;/p&gt;
&lt;p&gt;原因是 VSCode 這裡在搜尋 typing 檔時，預設會從根目錄開始搜尋，並且優先比對 index.d.ts&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/830852/201812/830852-20181209230430401-1147443701.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/830852/201812/830852-20181209230431125-2027210195.png&quot; alt=&quot;image&quot; width=&quot;628&quot; height=&quot;378&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最後的效果圖如下，可以看到 getFormatterText 是一個方法，並且相關參數的說明跟我們  typing 檔一樣&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/830852/201812/830852-20181209213922459-1829132388.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/830852/201812/830852-20181209213923684-1995207449.png&quot; alt=&quot;image&quot; width=&quot;650&quot; height=&quot;244&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;從下圖可以見到在還沒加入 typing 檔時，是不會有上面這樣的效果的&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/830852/201812/830852-20181209213924750-1067124100.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/830852/201812/830852-20181209213925348-149032156.png&quot; alt=&quot;image&quot; width=&quot;650&quot; height=&quot;225&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4.加入Code Coverage&lt;/p&gt;
&lt;p&gt;接下來我們要做的是 Code Coverage 的設定 ， Code Coverage 其實是用來呈現你目前 測試案例完整的程度&lt;/p&gt;
&lt;p&gt;幫助你了解是否測試已經足夠，還有那些方法測試不足&lt;/p&gt;
&lt;p&gt;在這個部分我們為了能容易結合 TravisCI ，採用 nyc 與 coveralls 這兩個套件&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;npm install nyc –D&lt;/p&gt;
&lt;p&gt;npm install coveralls –D&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;接下來我們設定一 package.json 裡面執行的命令&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/830852/201812/830852-20181209230432144-222036347.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/830852/201812/830852-20181209230432764-2101583906.png&quot; alt=&quot;image&quot; width=&quot;650&quot; height=&quot;198&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最後簡單執行&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;npm run coveralls&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;就會在目錄底下看到 .nyc_ouput 資料夾產生&lt;/p&gt;
&lt;p&gt;再來呢！ 我們需要到 &lt;a title=&quot;https://coveralls.io/sign-in&quot; href=&quot;https://coveralls.io/sign-in&quot;&gt;https://coveralls.io/sign-in&lt;/a&gt; 這個網站進行註冊與設定的動作&lt;/p&gt;
&lt;p&gt;因為我這裡直接選擇 github 登入。所以可以看到我在 ADD REPO 這裡，可以很容易選擇我想要呈現 code coverage 數據的 REPO&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/830852/201812/830852-20181209230433488-996564900.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/830852/201812/830852-20181209230434220-1854105318.png&quot; alt=&quot;image&quot; width=&quot;650&quot; height=&quot;206&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/830852/201812/830852-20181209230435039-1566125317.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/830852/201812/830852-20181209230436047-1023607520.png&quot; alt=&quot;image&quot; width=&quot;650&quot; height=&quot;456&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我們在這裡找到練習用的這個 REPO (如果在裡面沒有看到預計要使用的 REPO 的話，右上角有一個 SYNC REPOS 按下去後會進行同步的動作)&lt;/p&gt;
&lt;p&gt;接下來只要按一下 REPO 前面的那個 OFF 圖示，讓他變成 ON 就行了&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/830852/201812/830852-20181209230436816-1654115395.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/830852/201812/830852-20181209230437413-1792342064.png&quot; alt=&quot;image&quot; width=&quot;614&quot; height=&quot;251&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;再來我們需要移到 TravicsCI 做相關的設定，這樣 coveralls 才能收到相關的數據&lt;/p&gt;
&lt;p&gt;5.結合TravisCI 自動編譯與呈現Code Testing coverage&lt;/p&gt;
&lt;p&gt;同樣的，我們需要先在 TravisCI 上註冊一組我們的帳號，這裡為了求方便我一樣使用 GitHub 登入&lt;/p&gt;
&lt;p&gt;一進來的畫面如下，因為我先前已經有使用 TravisCI 來建置我的 REPO ，所以會看到有一個專案叫 HtmlSEO&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/830852/201812/830852-20181209230438495-1299507189.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/830852/201812/830852-20181209230439058-685695715.png&quot; alt=&quot;image&quot; width=&quot;650&quot; height=&quot;233&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;但我們這次要建立我們練習用的專案來讓 TravisCI 做自動建置，所以我們選一下圖中紅框處的 + 號&lt;/p&gt;
&lt;p&gt;接下來直接搜尋我們要使用的 REPO ，這裡就是我練習用的 nodedemomodule 了。&lt;/p&gt;
&lt;p&gt;並把 REPO 旁邊的 X 按下去，成功後就會呈現打勾的狀態&lt;/p&gt;
&lt;p&gt;(如果沒有出現想使用的 REPO 在左方有一個 Sync account 按下去後就會同步重整了)&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/830852/201812/830852-20181209232228129-49106333.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/830852/201812/830852-20181209232228626-915560916.png&quot; alt=&quot;image&quot; width=&quot;650&quot; height=&quot;276&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最後回到我們的專案底下設定 TravisCI 專用的設定檔  .travis.yml ，這個檔案一般也都會放在根目錄底下&lt;/p&gt;
&lt;p&gt;設定完成的圖如下&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/830852/201812/830852-20181209232229336-1343646489.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/830852/201812/830852-20181209232230117-565776172.png&quot; alt=&quot;image&quot; width=&quot;627&quot; height=&quot;404&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可以看到，我們首先要告知 TravisCI 我們的建置環境是 node_js 與 nodejs 的版本為 8&lt;/p&gt;
&lt;p&gt;再來則是需要安裝那些要全域執行的套件，最後就是常用的 npm install 還原我們專案所使用到的套件&lt;/p&gt;
&lt;p&gt;安裝完成後則進行建置的動作，最後再額外產生我們的 code coverage 檔案&lt;/p&gt;
&lt;p&gt;當這個檔案設定完成後，就可以進行 git commit 與 push 的動作！&lt;br/&gt;接下來就可以看到 TravisCI 幫忙你做建置的畫面囉！&lt;/p&gt;
&lt;p&gt;下圖就是 TravisCI 發現 REPO 有更新時自動觸發建置的畫面&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/830852/201812/830852-20181209232230750-1613418955.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/830852/201812/830852-20181209232231356-435680123.png&quot; alt=&quot;image&quot; width=&quot;650&quot; height=&quot;386&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最後當 npm run coveralls 執行完成時 ，回到 coervalls.io 就可以看到我們的 code coverage 比率了 (如下圖)&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/830852/201812/830852-20181209232231971-1094024576.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/830852/201812/830852-20181209232232701-428455933.png&quot; alt=&quot;image&quot; width=&quot;650&quot; height=&quot;693&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;coveralls.io 上的 code coverage 結果&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/830852/201812/830852-20181209232233516-2040592571.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/830852/201812/830852-20181209232234373-1131221866.png&quot; alt=&quot;image&quot; width=&quot;650&quot; height=&quot;314&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最後你可以利用以下這幾個連結，放在你的 README 裡讓其它人知道你這個套件的狀態&lt;/p&gt;
&lt;p&gt;&amp;lt;a href=&lt;a href=&quot;https://badge.fury.io/js/%7B%E6%8F%9B%E6%88%90%E4%BD%A0%E7%9A%84%E5%A5%97%E4%BB%B6%E5%90%8D%E7%A8%B1%7D&quot;&gt;https://badge.fury.io/js/{換成你的套件名稱}&lt;/a&gt;&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;img src=&quot;https://badge.fury.io/js/{換成你的套件名稱}.svg&quot; alt=&quot;npm version&quot; height=&quot;18&quot;&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/a&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;a href=&quot;https://travis-ci.org/{換成你的travisCI帳號}/{換成你的套件名稱}&quot;&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;img src=&quot;https://travis-ci.org/{換成你的travisCI帳號}/{換成你的套件名稱}.svg?branch=master&quot; alt=&quot;Travis CI&quot; /&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/a&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;a href='https://coveralls.io/github/{換成你的github帳號}/{換成你的套件名稱}?branch=master'&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;img src='https://coveralls.io/repos/github/{換成你的github帳號}/{換成你的套件名稱}/badge.svg?branch=master' alt='Coverage Status' /&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/a&amp;gt;&lt;/p&gt;
&lt;p&gt;成功的話就會看到下面這樣的圖示&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/830852/201812/830852-20181209232234860-1384209087.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/830852/201812/830852-20181209232235324-1937184636.png&quot; alt=&quot;image&quot; width=&quot;650&quot; height=&quot;96&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;以上就是一個比較完成發佈 node module 的流程了！其它像 React 、 Vue 、Angular 其實都大同小異&lt;/p&gt;
&lt;p&gt;如果有任何問題再請留言讓我知道&lt;/p&gt;
&lt;p&gt;謝謝大家&lt;/p&gt;
</description>
<pubDate>Sun, 09 Dec 2018 15:23:00 +0000</pubDate>
<dc:creator>KingJaja</dc:creator>
<og:description>本文會透過以下幾個段落，讓各位一步一步學習如何寫一個自已的Node.js Module並且發佈到npm package上 Node.js Module 結構 我們先建立一個 NodeModuleDem</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/KingJaja/p/9697427.html</dc:identifier>
</item>
<item>
<title>RabbitMQ 消息确认机制 以及 原理解析 - 残剑今生</title>
<link>http://www.cnblogs.com/DBGzxx/p/10091070.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/DBGzxx/p/10091070.html</guid>
<description>&lt;ul&gt;&lt;li&gt;一、场景&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;当消息的投送方把消息投递出去，却不知道消息是否投递成功了。如果消息投送方不管的话，势必对系统的造成可靠性的影响。&lt;/li&gt;
&lt;li&gt;可是如果要保证系统的可靠性，消息投靠方，如何知道消息是否投放成功了呢？&lt;/li&gt;
&lt;li&gt;这个就需要消息的确认机制，我们来看下rabbitMQ的消息去人机制是如何做的。&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;二、原理：上图&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1366148/201812/1366148-20181209141813371-1360392310.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;三、原理解析&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;消息的确认分两部分：rabbitMQ确认生产者投递的消息 和 消费者确认 rabbitMQ服务器的消息&lt;/li&gt;
&lt;li&gt;首先说RabbitMQ对生产者的确认，总共分为两种模式分别为 &lt;span&gt;同步模式&lt;/span&gt; 与 &lt;span&gt;&lt;span readability=&quot;2.5&quot;&gt;&lt;span readability=&quot;5&quot;&gt;异步模式&lt;span&gt;。&lt;/span&gt;&lt;p&gt;&lt;span&gt;(1)  同步模式分为 &lt;span&gt;单条消息确认&lt;/span&gt; 与 &lt;span&gt;批量确认&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;　　①  单条消息确认： channel.waitForConfirms() 普通发送方确认模式；&lt;span&gt;消息到达&lt;/span&gt;交换器，&lt;span&gt;就会返回&lt;/span&gt;true&lt;span&gt;。&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　②  批量消息确认： &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;channel.waitForConfirmsOrDie()&lt;span&gt;批量确认模式；使用同步方式等所有的消息发送之后才会执行后面代码，只要有一个消息未&lt;/span&gt;&lt;span&gt;到达&lt;/span&gt;&lt;span&gt;交换器就会抛出&lt;/span&gt;IOException&lt;span&gt;异常。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;　　　 (2) 异步模式为生产者 &lt;span&gt;异步监听消息确认&lt;span&gt;。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　　　　　异步监听消息确认：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;channel.addConfirmListener()&lt;span&gt;异步监听发送方确认模式；&lt;/span&gt;&lt;span&gt;如何使用，参见代码&lt;/span&gt;no-spring&lt;span&gt;模块&lt;/span&gt;&lt;span&gt;包&lt;/span&gt;cn.enjoyedu. producerconfirm&lt;span&gt;中&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;　　  3. 其次说下消费者对RabbitMQ 消息确认。总共分为两种方式 分别为 手动确认 和 自动确认。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　消费者收到的每一条消息都必须进行确认。消息确认后，&lt;/span&gt;RabbitMQ&lt;span&gt;才会从队列删除这条消息，&lt;/span&gt;&lt;span&gt;RabbitMQ&lt;/span&gt;&lt;span&gt;不会为未确认的消息设置超时时间，它判断此消息是否需要重新投递给消费者的唯一依据是消费该消的消费者连接是否已经断开。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　这么设计的原因是RabbitMQ允许消费者消费一条消息的时间可以很久很久。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　(1)　自动确认：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　消费者在声明队列时，可以指定&lt;/span&gt;autoAck&lt;span&gt;参数，当&lt;/span&gt;&lt;span&gt;autoAck=true&lt;/span&gt;&lt;span&gt;时，一旦消费者接收到了消息，就视为自动确认了消息。如果消费者在处理消息的过程中，出了错，就没有什么办法重新处理这条消息，所以我们很多时候，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;需要在消息处理成功后，再确认消息，这就需要手动确认。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  (2)  手动确认：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　 ①当&lt;/span&gt;autoAck=false&lt;span&gt;时，&lt;/span&gt;&lt;span&gt;RabbitMQ&lt;/span&gt;&lt;span&gt;会等待消费者显式发回&lt;/span&gt;&lt;span&gt;ack&lt;/span&gt;&lt;span&gt;信号后才从内存&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;和磁盘，如果是持久化消息的话&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;中移去消息。否则，&lt;/span&gt;&lt;span&gt;RabbitMQ&lt;/span&gt;&lt;span&gt;会在队列中消息被消费后立即删除它。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　　　　　　　 ②采用消息确认机制后，只要令&lt;/span&gt;autoAck=false&lt;span&gt;，消费者就有足够的时间处理消息&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;任务&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;，不用担心处理消息过程中消费者进程挂掉后消息丢失的问题，因为&lt;/span&gt;&lt;span&gt;RabbitMQ&lt;/span&gt;&lt;span&gt;会一直持有消息直到消费者显式调用&lt;/span&gt;&lt;span&gt;basicAck&lt;/span&gt;&lt;span&gt;为止。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　③当&lt;/span&gt;autoAck=false&lt;span&gt;时，对于&lt;/span&gt;&lt;span&gt;RabbitMQ&lt;/span&gt;&lt;span&gt;服务器端而言，队列中的消息分成了两部分：一部分是等待投递给消费者的消息；一部分是已经投递给消费者，但是还没有收到消费者&lt;/span&gt;&lt;span&gt;ack&lt;/span&gt;&lt;span&gt;信号的消息。如果服务器端一直没有收到消费&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;者的&lt;/span&gt;&lt;span&gt;ack&lt;/span&gt;&lt;span&gt;信号，并且消费此消息的消费者已经断开连接，则服务器端会安排该消息重新进入队列，等待投递给下一个消费者（也可能还是原来的那个消费者）。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;   ④通过运行程序，启动两个消费者&lt;/span&gt;A&lt;span&gt;、&lt;/span&gt;&lt;span&gt;B&lt;/span&gt;&lt;span&gt;，都可以收到消息，但是其中有一个消费者&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;不会对消息进行确认，当把这个消费者&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;关闭后，消费者&lt;/span&gt;&lt;span&gt;B&lt;/span&gt;&lt;span&gt;又会收到本来发送给消费者&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;的消息。所以我们一般使用手动确认的方法是，将消息的处理放在&lt;/span&gt;&lt;span&gt;try/catch&lt;/span&gt;&lt;span&gt;语句块中，成功处理了，就给&lt;/span&gt;&lt;span&gt;RabbitMQ&lt;/span&gt;&lt;span&gt;一个确认应答，如果处理异常了，就在&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;中，进行消息的拒绝&lt;/span&gt;&lt;/p&gt;



&lt;ul&gt;&lt;li&gt;如果有什么不足欢迎讨论！&lt;/li&gt;
&lt;/ul&gt;

</description>
<pubDate>Sun, 09 Dec 2018 15:20:00 +0000</pubDate>
<dc:creator>残剑今生</dc:creator>
<og:description>一、场景 二、原理：上图 三、原理解析 (2) 异步模式为生产者 异步监听消息确认。 异步监听消息确认：channel.addConfirmListener()异步监听发送方确认模式；如何使用，参见代</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/DBGzxx/p/10091070.html</dc:identifier>
</item>
<item>
<title>搞懂Python的类和对象名称空间 - 骏马金龙</title>
<link>http://www.cnblogs.com/f-ck-need-u/p/10094021.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/f-ck-need-u/p/10094021.html</guid>
<description>&lt;h2 id=&quot;代码块的分类&quot;&gt;代码块的分类&lt;/h2&gt;
&lt;p&gt;python中分几种代码块类型，它们都有自己的作用域，或者说名称空间：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;文件或模块整体是一个代码块，名称空间为全局范围&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;函数代码块，名称空间为函数自身范围，是本地作用域，在全局范围的内层
&lt;ul&gt;&lt;li&gt;函数内部可嵌套函数，嵌套函数有更内一层的名称空间&lt;br/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;类代码块，&lt;strong&gt;名称空间为类自身&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;类中可定义函数，类中的函数有自己的名称空间，在类的内层&lt;/strong&gt;&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;类的实例对象有自己的名称空间，和类的名称空间独立&lt;/strong&gt;&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;类可继承父类，可以链接至父类名称空间&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;正是这一层层隔离又连接的名称空间将变量、类、对象、函数等等都组织起来，使得它们可以拥有某些属性，可以进行属性查找。&lt;/p&gt;
&lt;p&gt;本文详细解释类和对象涉及的名称空间，属于纯理论类的内容，有助于理解python面向对象的细节。期间会涉及全局和本地变量作用域的查找规则，如有不明白之处，可先看文章：&lt;a href=&quot;https://www.cnblogs.com/f-ck-need-u/p/9925021.html&quot;&gt;Python作用域详述&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;一个概括全文的示例&quot;&gt;一个概括全文的示例&lt;/h2&gt;
&lt;p&gt;以下是一个能在一定程度上概括全文的示例代码段：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;x = 11           # 全局变量x

def f():         # 全局变量f
    print(x)     # 引用全局变量x

def g():         # 全局变量g
    x = 22       # 定义本地变量x
    print(x)     # 引用本地变量x

class supcls():      # 全局变量supcls
    x = 33           # 类变量x
    def m(self):     # 类变量m，类内函数变量self
        x = 44       # 类内函数变量x
        self.x = 55  # 对象变量x

class cls(supcls):   # 全局变量cls
    x = supcls.x     # 引用父类属性x，并定义cls类属性x
    def n(self):     # 类变量n
        self.x = 66  # 对象变量x&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果能理解上面的每个x属于哪个作用域、哪个名称空间，本文内容基本上就理解了。&lt;/p&gt;

&lt;h2 id=&quot;类的名称空间&quot;&gt;类的名称空间&lt;/h2&gt;
&lt;p&gt;下面有一个类，类中有类属性x、y，有类方法m和n。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class supcls():
    x = 3
    y = 4

    def m(self):
        x = 33
        self.x = 333
        self.y = 444
        self.z = 555

    def n(self):
        return self.x, self.y, self.z&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当python解释到supcls代码块后，知道这是一个类，类有自己的名称空间。所以，当知道了这个类里面有x、y、m、n后，这几个属性都会放进类supcls的名称空间中。&lt;/p&gt;
&lt;p&gt;如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733013/201812/733013-20181208154257036-590968626.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在上图中，类的名称空间中有属性x、y、m和n，&lt;strong&gt;它们都称为类属性&lt;/strong&gt;。需要说明的是，在python中，函数变量m、n和普通变量没什么区别，仅仅只是它保存了指向函数体的地址，函数体即上图中用func m和func n所表示的对象。&lt;/p&gt;
&lt;p&gt;因为&lt;strong&gt;有名称空间，可以直接使用完全限定名称去访问这个名称空间中的内容&lt;/strong&gt;。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;print(supcls.x)
print(supcls.y)
print(supcls.m)
print(supcls.n)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;3
4
&amp;lt;function supcls.m at 0x02B83738&amp;gt;
&amp;lt;function supcls.n at 0x02B836F0&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为函数m和n也是类的属性，它们也可以直接通过类名来访问执行。例如，新加入一个函数，但不用self参数了，然后执行它。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class testcls():
    z = 3
    def a():
        x = 1
        print(x)
        # print(z)     # 这是错的

testcls.a()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是需要注意，&lt;strong&gt;类方法代码块中看不见类变量&lt;/strong&gt;。虽然类和类方法的作用域关系类似于全局作用域和函数本地作用域，但并不总是等价。例如，方法a()中无法直接访问类变量z。这就像类内部看不到全局变量一样。&lt;/p&gt;
&lt;p&gt;上面全都是使用&lt;code&gt;类名.属性&lt;/code&gt;这种完全限定名称去访问类中的属性的。如果生成类的对象，则可以通过对象去访问相关对象属性，因为对象有自己的名称空间，且部分属性来源于类。&lt;/p&gt;

&lt;h2 id=&quot;对象名称空间&quot;&gt;对象名称空间&lt;/h2&gt;
&lt;p&gt;类就像一个模板，可以根据这个模板大量生成具有自己特性的对象。在Python中，只需像调用函数一样直接调用类就可以创建对象。&lt;/p&gt;
&lt;p&gt;例如，下面创建了两个cls类的对象o1和o2，创建类的时候可以传递参数给类，这个参数可以传递给类的构造函数&lt;code&gt;__init__()&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;o1 = cls()
o2 = cls(&quot;some args&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对象有自己的名称空间。因为对象是根据类来创建的，类是它们的模板，所以对象名称空间中包含所有类属性，但是对象名称空间中这些属性的值不一定和类名称空间属性的值相同。&lt;/p&gt;
&lt;p&gt;现在根据supcls类构造两个对象s1和s2：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class supcls():
    x = 3
    y = 4
    def m(self):
        x = 33
        self.x = 333
        self.y = 444
        self.z = 555
    def n(self):
        return self.x, self.y, self.z

s1 = supcls()
s2 = supcls()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么它们的名称空间，以及类的名称空间的关系如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733013/201812/733013-20181208154345461-1835886668.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在仅仅只是对象s1、s2连接到了类supcls，对象s1和s2有自己的名称空间。但因为类supcls中没有构造方法&lt;code&gt;__init__()&lt;/code&gt;初始化对象属性，所以它们的名称空间中除了python内部设置的一些&quot;其它&quot;属性，没有任何属于自己的属性。&lt;/p&gt;
&lt;p&gt;但因为s1、s2连接到了supcls类，所以可以进行对象属性查找，如果对象中没有，将会向上找到supcls。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;print(s1.x)    # 输出3，搜索到类名称空间
print(s1.y)    # 输出4，搜索到类名称空间
# print(s1.z)  # 这是错的&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面不再是通过完全限定的名称去访问类中的属性，而是通过对象属性查找的方式搜索到了类属性。但上面访问z属性将报错，因为还没有调用m方法。&lt;/p&gt;
&lt;p&gt;当调用m方法后，将会通过&lt;code&gt;self.xxx&lt;/code&gt;的方式设置完全属于对象自身的属性，包括x、y、z。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;s1.m()
s2.m()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在，它们的名称空间以及类的名称空间的关系如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733013/201812/733013-20181208154418490-2021528879.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在对象名称空间中有x、y和z共3个属性(不考虑其它python内部设置的属性)，再通过对象名去访问对象属性，仍然会查找属性，但对于这3个属性的搜索不会进一步搜索到类的名称空间。但如果访问对象中没有的属性，比如m和n，它们不存在于对象的名称空间中，所以会搜索到类名称空间。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;print(s1.x)  # 对象属性333，搜索到对象名称空间
print(s1.y)  # 对象属性444，搜索到对象名称空间
print(s1.z)  # 对象属性555，搜索到对象名称空间
s1.m()       # 搜索到类名称空间
s1.n()       # 搜索到类名称空间&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对象与对象之间的名称空间是完全隔离的，对象与类之间的名称空间存在连接关系。所以，s1和s2中的x和y和z是互不影响的，谁也看不见谁。&lt;/p&gt;
&lt;p&gt;但现在想要访问类变量x、y，而不是对象变量，该怎么办？直接通过类名的完全限定方式即可：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;print(s1.x)      # 输出333，对象属性，搜索到对象名称空间
print(supcls.x)  # 输出3，类属性，搜索到类名称空间&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为对象有了自己的名称空间，就可以直接向这个名称空间添加属性或设置属性。例如，下面为s1对象添加一个新的属性，但并不是在类内部设置，而是在类的外部设置：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;s1.x = 3333       # 在外部设置已有属性x
s1.var1 = &quot;aaa&quot;   # 在外部添加新属性var1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;新属性var1将只存在于s1，不存在于s2和类supcls中。&lt;/p&gt;

&lt;h3 id=&quot;类属性和对象属性&quot;&gt;类属性和对象属性&lt;/h3&gt;
&lt;p&gt;属于类的属性称为类属性，即那些存在于类名称空间的属性。类属性分为类变量和类方法。有些类方法无法通过对象来调用，这类方法称为称为静态方法。&lt;/p&gt;
&lt;p&gt;类似的，属于对象名称空间的属性称为对象属性。对象属性脱离类属性，和其它对象属性相互隔离。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class cls:
    x=3
    def f():
        y=4
        print(y)
    def m(self):
        self.z=3&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的x、f、m都是类属性，x是类变量，f和m是类方法，z是对象属性。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;x可以通过类名和对象名来访问。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;f没有参数，不能通过对象来调用(通过对象调用时默认会传递对象名作为方法的第一个参数)，只能通过类名来调用，所以f属于静态方法。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;m可以通过对象名来调用，也可以通过类名来调用(但这很不伦不类，因为你要传递一个本来应该是实例名称的参数)。&lt;/li&gt;
&lt;li&gt;z通过self设置，独属于每个self参数代表的对象，所以是对象属性。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;子类继承时的名称空间&quot;&gt;子类继承时的名称空间&lt;/h2&gt;
&lt;p&gt;子类和父类之间有继承关系，它们的名称空间也通过一种特殊的方式进行了连接：子类可以继承父类的属性。&lt;/p&gt;
&lt;p&gt;例如下面的例子，子类&lt;code&gt;class childcls(supcls)&lt;/code&gt;表示childcls继承了父类supcls。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class supcls():
    x = 3
    y = 4
    def m(self):
        x = 33
        self.x = 333
        self.y = 444
        self.z = 555
    def n(self):
        return self.x, self.y, self.z

class childcls(supcls):
    y = supcls.y + 1    # 通过类名访问父类属性
    def n(self):
        self.z = 5555&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当python解释完这两段代码块时，初始时的名称空间结构图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733013/201812/733013-20181208110306402-1510693632.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当执行完&lt;code&gt;class childcls(supcls)&lt;/code&gt;代码块之后，子类childcls就有了自己的名称空间。初始时，这个名称空间中除了连接到父类supcls外，还有自己的类变量y和方法n()，子类中的方法n()重写了父类supcls的方法n()。&lt;/p&gt;
&lt;p&gt;因为&lt;strong&gt;有自己的名称空间，所以可以访问类属性。当访问的属性不存在于子类中时，将自动向上搜索到父类&lt;/strong&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;print(childcls.x)   # 父类属性，搜索到父类名称空间
print(childcls.y)   # 子类自身属性，搜索到子类名称空间
print(childcls.z)   # 错误，子类和父类都没有该属性&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当创建子类对象的时候，子类对象的变量搜索规则：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;子类对象自身名称空间&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;子类的类名称空间&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;父类的类名称空间&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;例如，创建子类对象c1，并调用子类的方法n()：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;c1 = childcls()
c1.n()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在，子类对象c1、子类childcls和父类supcls的关系如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733013/201812/733013-20181208114724999-1426718700.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过前面的说明，想必已经不用过多解释。&lt;/p&gt;

&lt;h3 id=&quot;多重继承时的名称空间&quot;&gt;多重继承时的名称空间&lt;/h3&gt;
&lt;p&gt;python支持多重继承，只需将需要继承的父类放进子类定义的括号中即可。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class cls1():
    ...

class cls2():
    ...

class cls3(cls1,cls2):
    ...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面cls3继承了cls1和cls2，它的名称空间将连接到两个父类名称空间，也就是说只要cls1或cls2拥有的属性，cls3构造的对象就拥有(注意，cls3类是不拥有的，只有cls3类的对象才拥有)。&lt;/p&gt;
&lt;p&gt;但多重继承时，如果cls1和cls2都具有同一个属性，比如cls1.x和cls2.x，那么cls3的对象c3.x取哪一个？会取cls1中的属性x，因为规则是按照(括号中)从左向右的方式搜索父类。&lt;/p&gt;
&lt;p&gt;再考虑一个问题，如果cls1中没有属性x，但它继承自cls0，而cls0有x属性，那么，c3.x取哪个属性。&lt;/p&gt;
&lt;p&gt;在python中，父类属性的搜索规则是&lt;strong&gt;先左后右，先深度后广度，搜索到了就停止&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733013/201812/733013-20181208122532459-806005001.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一般不建议使用多重继承，甚至不少语言根本就不支持多重继承，因为很容易带来属性混乱的问题。&lt;/p&gt;

&lt;h2 id=&quot;类自身就是一个全局属性&quot;&gt;类自身就是一个全局属性&lt;/h2&gt;
&lt;p&gt;在python中，类并没有什么特殊的，它存在于模块文件中，是全局名称空间中的一个属性。&lt;/p&gt;
&lt;p&gt;例如，在模块文件中定义了一个类cls，那么这个cls就是一个全局变量，只不过这个变量中保存的地址是类代码块所在数据对象。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 模块文件顶层
class cls():
    n = 3&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;而模块本身是一个对象，有自己的模块对象名称空间(即全局名称空间)，所以类是这个模块对象名称空间中的一个属性，仅此而已&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;另外需要注意的是，类代码块和函数代码块不一样，&lt;strong&gt;涉及到类代码块中的变量搜索时，只会根据对象与类的连接、子类与父类的继承连接进行搜索&lt;/strong&gt;。不会像全局变量和函数一样，函数内可以向上搜索全局变量、嵌套函数可以搜索外层函数。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 全局范围
x = 3
def f():
    print(x)   # 搜索到全局变量x

class sup():
    # print(x)   # 这是错的，不会搜索全局变量
    y = 3
    print(y)     # 这是对的，存在类属性y
    def m(self):
        # print(y)   # 这是错的，不会搜索到类变量
        self.z = 4

class childcls(sup):
    # print(y)      # 这是错的，不会搜索到父类&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其实很容易理解为什么面向对象要有自己的搜索规则。对象和类之间是&lt;code&gt;is a&lt;/code&gt;的关系，子类和父类也是&lt;code&gt;is a&lt;/code&gt;的关系，这两个&lt;code&gt;is a&lt;/code&gt;是面向对象时名称空间之间的连接关系，在搜索属性的时候可以顺着&quot;这根树&quot;不断向上爬，直到搜索到属性。&lt;/p&gt;

&lt;h2 id=&quot;dict__就是名称空间&quot;&gt;__dict__就是名称空间&lt;/h2&gt;
&lt;p&gt;前面一直说名称空间，这个抽象的东西用来描述作用域，比如全局作用域、本地作用域等等。&lt;/p&gt;
&lt;p&gt;在其他语言中可能很难直接查看名称空间，但是在python中非常容易，因为只要是数据对象，只要有属性，就有自己的&lt;code&gt;__dict__&lt;/code&gt;属性，它是一个字典，表示的就是名称空间。&lt;code&gt;__dict__&lt;/code&gt;内的所有东西，都可以直接通过点&quot;.&quot;的方式去访问、设置、删除，还可以直接向&lt;code&gt;__dict__&lt;/code&gt;中增加属性。&lt;/p&gt;
&lt;p&gt;例如:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class supcls():
    x=3

class childcls(supcls):
    y=4
    def f(self):
        self.z=5

&amp;gt;&amp;gt;&amp;gt; c=childcls()
&amp;gt;&amp;gt;&amp;gt; c.__dict__.keys()
dict_keys([])

&amp;gt;&amp;gt;&amp;gt; c.f()
&amp;gt;&amp;gt;&amp;gt; c.__dict__
{'z': 5}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以直接去增、删、改这个dict，所作的修改都会直接对名称空间起作用。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; c.newkey = &quot;NEWKEY&quot;
&amp;gt;&amp;gt;&amp;gt; c.__dict__[&quot;hello&quot;] = &quot;world&quot;
&amp;gt;&amp;gt;&amp;gt; c.__dict__
{'z': 5, 'newkey': 'NEWKEY', 'hello': 'world'}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意，&lt;code&gt;__dict__&lt;/code&gt;表示的是名称空间，所以不会显示类的属性以及父类的属性。正如上面刚创建childcls的实例时，dict中是空的，只有在c.f()之后才设置独属于对象的属性。&lt;/p&gt;
&lt;p&gt;如果要显示类以及继承自父类的属性，可以使用&lt;code&gt;dir()&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; c1 = childcls()
&amp;gt;&amp;gt;&amp;gt; c1.__dict__
{}
&amp;gt;&amp;gt;&amp;gt; dir(c1)
['__class__', '__delattr__', '__dict__',
......
'f', 'x', 'y']&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;关于&lt;code&gt;__dict__&lt;/code&gt;和dir()的详细说明和区别，参见&lt;a href=&quot;https://www.cnblogs.com/f-ck-need-u/p/10087696.html&quot;&gt;dir()和__dict__的区别&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&quot;class__和__base__&quot;&gt;__class__和__base__&lt;/h2&gt;
&lt;p&gt;前面多次提到对象和类之间有连接关系，子类与父类也有连接关系。但是到底是怎么连接的？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;对象与类之间，通过&lt;code&gt;__class__&lt;/code&gt;进行连接&lt;/strong&gt;：对象的&lt;code&gt;__class__&lt;/code&gt;的值为所属类的名称&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;子类与父类之间，通过&lt;code&gt;__bases__&lt;/code&gt;进行连接&lt;/strong&gt;：子类的&lt;code&gt;__bases__&lt;/code&gt;的值为父类的名称&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class supcls():
    x=3

class childcls(supcls):
    y=4
    def f(self):
        self.z=5

c = childcls()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;c是childcls类的一个实例对象：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; c.__class__
&amp;lt;class '__main__.childcls'&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;childcls继承自父类supcls，父类supcls继承自祖先类object：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; childcls.__bases__
(&amp;lt;class '__main__.supcls'&amp;gt;,)

&amp;gt;&amp;gt;&amp;gt; supcls.__bases__
(&amp;lt;class 'object'&amp;gt;,)&lt;/code&gt;
&lt;/pre&gt;

&lt;h3 id=&quot;查看类的继承层次&quot;&gt;查看类的继承层次&lt;/h3&gt;
&lt;p&gt;下面通过&lt;code&gt;__class__&lt;/code&gt;和&lt;code&gt;__bases__&lt;/code&gt;属性来查看对象所在类的继承树结构。&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def classtree(cls, indent):
    print(&quot;.&quot; * indent + cls.__name__)
    for supcls in cls.__bases__:
        classtree(supcls, indent + 3)


def objecttree(obj):
    print(&quot;Tree for %s&quot; % obj)
    classtree(obj.__class__, 3)


class A: pass
class B(A): pass
class C(A): pass
class D(B, C): pass
class E: pass
class F(D, E): pass

objecttree(B())
print(&quot;==============&quot;)
objecttree(F())&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Tree for &amp;lt;__main__.B object at 0x037D1630&amp;gt;
...B
......A
.........object
==============
Tree for &amp;lt;__main__.F object at 0x037D1630&amp;gt;
...F
......D
.........B
............A
...............object
.........C
............A
...............object
......E
.........object&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sun, 09 Dec 2018 15:13:00 +0000</pubDate>
<dc:creator>骏马金龙</dc:creator>
<og:description>代码块的分类 python中分几种代码块类型，它们都有自己的作用域，或者说名称空间： 文件或模块整体是一个代码块，名称空间为全局范围 函数代码块，名称空间为函数自身范围，是本地作用域，在全局范围的内层</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/f-ck-need-u/p/10094021.html</dc:identifier>
</item>
</channel>
</rss>