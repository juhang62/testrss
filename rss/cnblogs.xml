<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>ASP.NET Core 共享第三方依赖库部署的正常打开方式 - 路过秋天</title>
<link>http://www.cnblogs.com/cyq1162/p/10625151.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cyq1162/p/10625151.html</guid>
<description>&lt;p&gt;写了一篇：&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/cyq1162/p/10542832.html&quot;&gt;ASP.Net Core on Linux (CentOS7) 共享第三方依赖库部署&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;当第二次想做相同的事，却遇上了Bug，于是有了第二篇：&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/cyq1162/p/10612508.html&quot;&gt;ASP.NET Core 共享第三方依赖库部署的Bug(*.deps.json on 2.2.0 or 4.6.0 版本)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;就报告到Github上去了，来来回回和人家交涉了几天：&lt;/p&gt;

&lt;p&gt;截几个图，给大伙学习一下英文：&lt;/p&gt;
&lt;p&gt;我以强悍的中英文双版提交了问题：&lt;/p&gt;
&lt;h2&gt;Steps to reproduce&lt;/h2&gt;
&lt;p&gt;I try to put the Microsoft.&lt;em&gt;.dll and System.&lt;/em&gt;.dll togather to a new folder.&lt;br/&gt;以便把(第三方或）系统的和应用的dll分开。&lt;br/&gt;之前花了很长的一段时间研究之后：&lt;br/&gt;I find xxx.deps.json can make it work.&lt;br/&gt;之后我还特意写了篇文章介绍它：&lt;a href=&quot;https://www.cnblogs.com/cyq1162/p/10542832.html&quot; rel=&quot;nofollow&quot;&gt;https://www.cnblogs.com/cyq1162/p/10542832.html&lt;/a&gt;&lt;br/&gt;but today,when i update the Microsoft. Aspnetcore to 2.2.0 version.&lt;br/&gt;it dose not work, and make me crazy.&lt;/p&gt;
&lt;p&gt;because it always show me the msg like this:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;F:\Code\OpenSource\Aries-GitHub\trunk\Aries.DevFramework\Web.UI_NetCore\bin\Rele ase\PublishOutput&amp;gt;dotnet Web.UI.dll Error: **An assembly specified in the application dependencies manifest (Web.UI.deps.js on) was not found**: package: 'Microsoft.AspNetCore.Authentication.Abstractions', version: '2.2.0 ' path: 'lib/netstandard2.0/Microsoft.AspNetCore.Authentication.Abstractions.d ll'&lt;/code&gt;&lt;br/&gt;and the json like this:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&quot;Microsoft.AspNetCore.Authentication.Abstractions/2.2.0&quot;: {
        &quot;dependencies&quot;: {
          &quot;Microsoft.AspNetCore.Http.Abstractions&quot;: &quot;2.2.0&quot;,
          &quot;Microsoft.Extensions.Logging.Abstractions&quot;: &quot;2.2.0&quot;,
          &quot;Microsoft.Extensions.Options&quot;: &quot;2.2.0&quot;
        },
        &quot;runtime&quot;: {
          &quot;lib/netstandard2.0/Microsoft.AspNetCore.Authentication.Abstractions.dll&quot;: {
            &quot;fileVersion&quot;: &quot;2.2.0.18316&quot;
          }
        }
      }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我花了N长的时间在检测配置和确定路径的正确性，但结果，却依旧很悲催。&lt;br/&gt;it take me much time to find out the question what it's.&lt;br/&gt;when i try to maike it like this:&lt;br/&gt;Microsoft.AspNetCore.Authentication.Abstractions&lt;br/&gt;Microsoft.AspNetCore.Authentication.Abstractions/2.2.xxx&lt;br/&gt;it work.&lt;br/&gt;就是这样，只要版本号不是2.2.0，它就一切正常。&lt;br/&gt;之后又几次测试，发现版本号是4.6.0也同样有问题。&lt;br/&gt;and then i find the version on /4.6.0 ,it does not work also.&lt;br/&gt;就是这样，版本号三位数，尾数是0的，就提示找不到dll。&lt;br/&gt;how ugly this bug it's.&lt;/p&gt;
&lt;p&gt;中英文双语版汇报之后，老外回消息了，它估计看到中文就头大：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/17408/201903/17408-20190330044450156-2000437026.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我看了半天，也是一脸头大，于是，我努力再描述一下问题，并打算用截图说明问题：&lt;/p&gt;
&lt;p&gt;ok,i try it again.&lt;br/&gt;1、I have a mvc website：&lt;a href=&quot;http://mvc.taurus.cyqdata.com/&quot; rel=&quot;nofollow&quot;&gt;http://mvc.taurus.cyqdata.com&lt;/a&gt;, it run on CentOS7，at first it deploy like this :&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://camo.githubusercontent.com/2a951962b186abf491a1a5e39695d5163b1675bf/68747470733a2f2f696d67323031382e636e626c6f67732e636f6d2f626c6f672f31373430382f3230313930332f31373430382d32303139303332383138353533313238382d39373131363638302e706e67&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://camo.githubusercontent.com/2a951962b186abf491a1a5e39695d5163b1675bf/68747470733a2f2f696d67323031382e636e626c6f67732e636f6d2f626c6f672f31373430382f3230313930332f31373430382d32303139303332383138353533313238382d39373131363638302e706e67&quot; alt=&quot;&quot; data-canonical-src=&quot;https://img2018.cnblogs.com/blog/17408/201903/17408-20190328185531288-97116680.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;and now it make it like this by *.deps.json:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://camo.githubusercontent.com/b0c11b9cbfc3319a153b9236092ad644e30959c7/68747470733a2f2f696d67323031382e636e626c6f67732e636f6d2f626c6f672f31373430382f3230313930332f31373430382d32303139303332383138353035323539382d323037383838343138382e706e67&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://camo.githubusercontent.com/b0c11b9cbfc3319a153b9236092ad644e30959c7/68747470733a2f2f696d67323031382e636e626c6f67732e636f6d2f626c6f672f31373430382f3230313930332f31373430382d32303139303332383138353035323539382d323037383838343138382e706e67&quot; alt=&quot;&quot; data-canonical-src=&quot;https://img2018.cnblogs.com/blog/17408/201903/17408-20190328185052598-2078884188.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;I put the Microsoft.xxx.dll or System.xxx.dll to another folder like package.&lt;br/&gt;how I do that ? I replace all the path lib/netstardardxxxx to my path.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://camo.githubusercontent.com/713d2d9a613b672624216ba19f9ac394b9e78bb2/68747470733a2f2f696d67323031382e636e626c6f67732e636f6d2f626c6f672f31373430382f3230313930332f31373430382d32303139303332383139303735343139322d3730383838313338392e706e67&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://camo.githubusercontent.com/713d2d9a613b672624216ba19f9ac394b9e78bb2/68747470733a2f2f696d67323031382e636e626c6f67732e636f6d2f626c6f672f31373430382f3230313930332f31373430382d32303139303332383139303735343139322d3730383838313338392e706e67&quot; alt=&quot;&quot; data-canonical-src=&quot;https://img2018.cnblogs.com/blog/17408/201903/17408-20190328190754192-708881389.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;so it work well at Microsoft.AspNetCore.All 2.0.3 version.&lt;br/&gt;but my question is ：when i update to 2.2.0 version，it dose not work.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://camo.githubusercontent.com/7a662bc172d68cb9afe705aed043304f49a77657/68747470733a2f2f696d67323031382e636e626c6f67732e636f6d2f626c6f672f31373430382f3230313930332f31373430382d32303139303332383139303932303233382d313637323630323732382e706e67&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://camo.githubusercontent.com/7a662bc172d68cb9afe705aed043304f49a77657/68747470733a2f2f696d67323031382e636e626c6f67732e636f6d2f626c6f672f31373430382f3230313930332f31373430382d32303139303332383139303932303233382d313637323630323732382e706e67&quot; alt=&quot;&quot; data-canonical-src=&quot;https://img2018.cnblogs.com/blog/17408/201903/17408-20190328190920238-1672602728.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;if i change the version to anything like 2.2.x,it will work well.&lt;br/&gt;I find it have the same bug on linux and windows. now ,you kown what i say ?&lt;/p&gt;
&lt;p&gt;忙碌中，对方又回了一条消息：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/17408/201903/17408-20190330044641735-1586855358.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;他说他随便折腾一下，没发现问题啊。&lt;/p&gt;
&lt;p&gt;我能怎么办？只能把demo双手奉上：&lt;/p&gt;
&lt;p&gt;OK，I try it again.&lt;br/&gt;I make a SourceCode and Demo,you can download on (5M) : &lt;a href=&quot;http://mvc.taurus.cyqdata.com/WebPublish.rar&quot; rel=&quot;nofollow&quot;&gt;http://mvc.taurus.cyqdata.com/WebPublish.rar&lt;/a&gt;&lt;br/&gt;unrar and &quot;dotnet Taurus.View.dll&quot; on cmd，you will get the error message like:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://camo.githubusercontent.com/31e6c3a5637ac8c38afcdb264bb0e32a6e1ae6d9/68747470733a2f2f696d67323031382e636e626c6f67732e636f6d2f626c6f672f31373430382f3230313930332f31373430382d32303139303332383232333630383232372d323037323531323936382e706e67&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://camo.githubusercontent.com/31e6c3a5637ac8c38afcdb264bb0e32a6e1ae6d9/68747470733a2f2f696d67323031382e636e626c6f67732e636f6d2f626c6f672f31373430382f3230313930332f31373430382d32303139303332383232333630383232372d323037323531323936382e706e67&quot; alt=&quot;&quot; data-canonical-src=&quot;https://img2018.cnblogs.com/blog/17408/201903/17408-20190328223608227-2072512968.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;and you replace 2.2.0 to 2.2.1 at Taurus.View.deps.json like this,and run again,it will be ok.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://camo.githubusercontent.com/98df0acbb4447bd17bd2b439ddae125dbb8c13de/68747470733a2f2f696d67323031382e636e626c6f67732e636f6d2f626c6f672f31373430382f3230313930332f31373430382d32303139303332383232333832303834332d323032343139323339342e706e67&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://camo.githubusercontent.com/98df0acbb4447bd17bd2b439ddae125dbb8c13de/68747470733a2f2f696d67323031382e636e626c6f67732e636f6d2f626c6f672f31373430382f3230313930332f31373430382d32303139303332383232333832303834332d323032343139323339342e706e67&quot; alt=&quot;&quot; data-canonical-src=&quot;https://img2018.cnblogs.com/blog/17408/201903/17408-20190328223820843-2024192394.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;you you need the source code for building, you can download on (917K) : http://mvc.taurus.cyqdata.com/SourceCode.rar&lt;/p&gt;
&lt;p&gt; 对方告诉我，没啥问题，本来就是找不到路径文件，另外至于改版本号就变好了的问题，可能真是个bug，然后给我推荐升级到2.2版本：&lt;/p&gt;
&lt;p&gt;Thanks a lot.&lt;/p&gt;
&lt;p&gt;The immediate failure is caused by a missing file. The &lt;code&gt;Microsoft.AspNetCore.Authentication.Abstraction.dll&lt;/code&gt; is in fact not there. So it fails correctly.&lt;/p&gt;
&lt;p&gt;If you change the version you effectively corrupt the &lt;code&gt;.deps.json&lt;/code&gt;. The entire string &lt;code&gt;Microsoft.AspNetCore.Authentication.Abstraction/2.2.0&lt;/code&gt; is a package identifier, which should exist in the &lt;code&gt;libraries&lt;/code&gt; section near the end of the &lt;code&gt;.deps.json&lt;/code&gt; file. As is the package section exists. If you change the version it won't find the package. I guess it's a bug that it won't fail in that case, in fact it simply ignores the assembly if it can't find the matching package section. This is definitely not expected, but I doubt we can fix it (if somebody relies on this behavior we would break them).&lt;/p&gt;
&lt;p&gt;The app runs without the assembly just fine, at least the startup as I assume it doesn't need it. If it would run into code which needs it, it would fail at runtime.&lt;/p&gt;
&lt;p&gt;Note that when I built it from source, it worked without any modifications (as the file was present).&lt;/p&gt;
&lt;p&gt;As for the number of additional files in the app. I took your solution, changed all projects to target netcoreapp2.2 (since you're trying to use ASP.NET Core 2.2, it makes sense to target 2.2 for everything). And then I added this line to the &lt;code&gt;Taurus.View_NetCore.csproj&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;highlight highlight-text-xml&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
  &amp;lt;&lt;span class=&quot;pl-ent&quot;&gt;ItemGroup&amp;gt;
    &amp;lt;&lt;span class=&quot;pl-ent&quot;&gt;PackageReference &lt;span class=&quot;pl-e&quot;&gt;Include=&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;Microsoft.AspNetCore.App&lt;span class=&quot;pl-pds&quot;&gt;&quot; /&amp;gt;
  &amp;lt;/&lt;span class=&quot;pl-ent&quot;&gt;ItemGroup&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now when I publish the solution, I get only about 20 files in the output. Basically just the application plus 2 additional System.* assemblies.&lt;/p&gt;
&lt;p&gt;我感觉它没发现我说的重点，于是用翻译快速上了一段文字：&lt;/p&gt;
&lt;p&gt;To facilitate the presentation of the problem,&lt;br/&gt;I put Microsoft. AspNetCore. Authentication. Abstraction. dll in the Lib directory, and then the path of the configuration file was modified to point to it, so the file is supposed to exist, even if it is not used in the project, but the direction of the path is right, I don't know if you notice it.&lt;/p&gt;
&lt;p&gt;Version number is no problem, after all, it is automatically generated by the system.&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;In addition, the 2.2.0 I mentioned above refers to the Nuget version package of ASPNET Core. It is not. NetApp version upgraded to 2.2. App version is still using 2.1.&lt;/p&gt;
&lt;p&gt;对方开始慒B了，说了一堆，然后还是推荐我上2.2版本：&lt;/p&gt;
&lt;p&gt;I'm sorry - I don't understand your comment about the version number not being a problem. It is by design that the run fails if &lt;code&gt;.deps.json&lt;/code&gt; refers to a file which it can't find, so in your repro, the fact that it fails is expected.&lt;br/&gt;I do agree that the fact that if the version number is changed (and thus doesn't match the package in the libraries section) the run will simply ignore the problem and the file and just continue is a bug. I have my doubts we would fix it though as it might break people.&lt;br/&gt;By doing this the &lt;code&gt;.deps.json&lt;/code&gt; becomes invalid, and the current error checking is somewhat simplistic on &lt;code&gt;.deps.json&lt;/code&gt; - this is basically expected, as the &lt;code&gt;.deps.json&lt;/code&gt; is not meant to be used by humans - it is meant to be machine generated, and thus it's reasonable to expect correct input.&lt;/p&gt;
&lt;p&gt;As for ASPNET Core versioning - I'm honestly surprised you can even run ASP.NET 2.2 on .NET Core 2.1, but I'm no expert in ASP.NET deployment.&lt;/p&gt;
&lt;p&gt;To explain why you get so many files in the output:&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;Normally .NET Core apps rely on &quot;shared frameworks&quot; which live in the global installed location. These are referenced from the &lt;code&gt;.runtimeconfig.json&lt;/code&gt;. You can see that your app references &lt;code&gt;Microsoft.NETCore.App&lt;/code&gt; there, which is the root framework (contains CoreCLR and CoreFX).&lt;/li&gt;
&lt;li&gt;ASP.NET itself contains lot of assemblies. Again by default this will be recognized as a &quot;shared framework&quot; and you would get a reference to &lt;code&gt;Microsoft.AspNet.Core.App&lt;/code&gt; in your &lt;code&gt;.runtimeconfig.json&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;If one of the referenced shared frameworks contains the required assembly, then that assembly is not included in the output of the app. So by default you don't get pretty much any &quot;Microsoft.&lt;em&gt;&quot; or &quot;System.&lt;/em&gt;&quot; assemblies in the app as those are all in the shared frameworks.&lt;/li&gt;
&lt;li&gt;In your case I can only assume the build system is confused a bit - you require ASPNET Core 2.2 on .NET Core 2.1. Since no such shared framework exists, it probably just brings all the ASP.NET assemblies into the app. By migrating all projects to .NET Core 2.2 you give the build system a way to rely on shared frameworks instead. For some reason the PackageReference to ASPNET also has to be in the main project for this to work (no idea why).&lt;/li&gt;
&lt;li&gt;Once that is done, your app should have a reference to &lt;code&gt;Microsoft.AspNet.Core.App&lt;/code&gt; version 2.2 which in turn has a reference to &lt;code&gt;Microsoft.NETCore.App&lt;/code&gt; version 2.2. And so the build system will be able to avoid all the system assemblies in the app and solely rely on the shared frameworks.&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;p&gt;我感觉这问题似乎要无解，又要重新描述问题了：&lt;/p&gt;
&lt;p&gt;i mean,when you down from &lt;a href=&quot;http://mvc.taurus.cyqdata.com/WebPublish.rar&quot; rel=&quot;nofollow&quot;&gt;http://mvc.taurus.cyqdata.com/WebPublish.rar&lt;/a&gt;&lt;br/&gt;and unrar , you will find lib/Microsoft. AspNetCore. Authentication. Abstraction. dll and this dll version is 2.2.0. the file is exists.&lt;br/&gt;and the Taurus.View.deps.json , you look,it point to the same path.&lt;br/&gt;&lt;a href=&quot;https://camo.githubusercontent.com/98df0acbb4447bd17bd2b439ddae125dbb8c13de/68747470733a2f2f696d67323031382e636e626c6f67732e636f6d2f626c6f672f31373430382f3230313930332f31373430382d32303139303332383232333832303834332d323032343139323339342e706e67&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://camo.githubusercontent.com/98df0acbb4447bd17bd2b439ddae125dbb8c13de/68747470733a2f2f696d67323031382e636e626c6f67732e636f6d2f626c6f672f31373430382f3230313930332f31373430382d32303139303332383232333832303834332d323032343139323339342e706e67&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;br/&gt;so,tell me ,why can't find it ,the related path is error ? &lt;/p&gt;
&lt;p&gt;这此，对方终于知道我要表达或关注点在什么地方了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/17408/201903/17408-20190330045621608-233630530.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不过它始终没Get到我的点，或者我没有Get到它的点，我只能强调，我上一版本V2.0.3是OK的，要不要弄个正常的Demo过去？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/17408/201903/17408-20190330045807192-1444795170.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;它想让我把正常的.runtimeconfig.json文件发给它看看&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/17408/201903/17408-20190330045908286-137491800.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;于是，我转身向服务器走去，我Down下了2.0.3那个运行正常的runtimeconfig.json文件，打开一看，what X，什么时候多了一行：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/17408/201903/17408-20190330050124362-772790316.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这不是我当年研究失败时留下的东西么，难道它是关键？&lt;/p&gt;
&lt;p&gt;于是通过把这个属性加上和关掉，重新运行了一下，XYZ，还真是它的问题，&lt;span&gt;&lt;strong&gt;只有配置了这个路径，deps.json上的路径才能生效&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;

&lt;p&gt;感觉要分手了，给它回了最后一段话：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/17408/201903/17408-20190330050342432-2033732094.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;好聚好散，但它还是坚持让我升级到NetCore 2.2版本：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/17408/201903/17408-20190330050432221-1169776643.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 交涉地址：&lt;a href=&quot;https://github.com/dotnet/core-setup/issues/5588&quot;&gt;https://github.com/dotnet/core-setup/issues/5588&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最后，发现在Github留下问题，还是有点乐趣的~~~&lt;/p&gt;
</description>
<pubDate>Fri, 29 Mar 2019 21:16:00 +0000</pubDate>
<dc:creator>路过秋天</dc:creator>
<og:description>通过在Github上几天的交流，这个Bug的问题，终于找到关键的点了，今天就给大伙说说~~~</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cyq1162/p/10625151.html</dc:identifier>
</item>
<item>
<title>关于socket.io的使用 - Jeff.Zhong</title>
<link>http://www.cnblogs.com/edwardloveyou/p/10625152.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/edwardloveyou/p/10625152.html</guid>
<description>&lt;p&gt;这段时间学习了&lt;strong&gt;socket.io&lt;/strong&gt;，用它写了小项目，在此总结下它的基本使用方式和一些要点。&lt;br/&gt;&lt;strong&gt;socket.io&lt;/strong&gt;是基于&lt;strong&gt;Node.js&lt;/strong&gt;和&lt;strong&gt;WebSocket&lt;/strong&gt;协议的实时通信开源框架，它包括客户端的JavaScript和服务器端的Node.js。&lt;/p&gt;
&lt;h2 id=&quot;服务端&quot;&gt;服务端&lt;/h2&gt;
&lt;p&gt;这里后端使用的框架是&lt;strong&gt;koa2&lt;/strong&gt;，&lt;strong&gt;socket.io&lt;/strong&gt;将自身绑定到koa的进程到中去，其中最重要的事件就是 &lt;strong&gt;connection&lt;/strong&gt; 和 &lt;strong&gt;disconnect&lt;/strong&gt;。它们是框架本身定义的系统事件，也就意味着它是自然就存在的不需要我们自定义，当然还有其它系统事件，但很少会用得到。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;const koa = require('koa')
const app = new koa()
const server = require('http').createServer(app.callback())
const io = require('socket.io')(server)

//监听connect事件
io.on('connection', socket =&amp;gt; {
  socket.emit('open');//通知客户端已连接
  console.log('connected');
  
  //监听disconnect事件
  socket.on('disconnect', () =&amp;gt; {
    console.log('disconnect')
  }
});
server.listen(3001);&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;客户端&quot;&gt;客户端&lt;/h2&gt;
&lt;p&gt;web端直接传入url地址即可，其中这里监听的 &lt;strong&gt;open&lt;/strong&gt; 事件是用户自定义的，对应服务端的则是发送&lt;strong&gt;open&lt;/strong&gt;事件。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;import io from 'socket.io-client';

//建立websocket连接
const socket = io('http://127.0.0.1:3001');

//收到server的连接确认
socket.on('open', () =&amp;gt; {
    showTip('socket io is open !');
    init();
});&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;emit-和-on&quot;&gt;emit 和 on&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;emit&lt;/strong&gt; 和 &lt;strong&gt;on&lt;/strong&gt; 是最重要的两个api，分别对应 &lt;strong&gt;发送&lt;/strong&gt; 和 &lt;strong&gt;监听&lt;/strong&gt; 事件。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;socket.emit(eventName[, ...args])&lt;/strong&gt;：发射（触发）一个事件&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;socket.on(eventName, callback)&lt;/strong&gt;：监听一个 emit 发射的事件&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们可以非常自由的在服务端定义并发送一个事件&lt;strong&gt;emit&lt;/strong&gt;，然后在客户端监听 &lt;strong&gt;on&lt;/strong&gt;，反过来也一样。&lt;/p&gt;
&lt;p&gt;发送的内容格式也非常自由，既可以是基本数据类型 &lt;strong&gt;Number&lt;/strong&gt;，&lt;strong&gt;String&lt;/strong&gt;，&lt;strong&gt;Boolean&lt;/strong&gt; 等，也可以是 &lt;strong&gt;Object&lt;/strong&gt;，&lt;strong&gt;Array&lt;/strong&gt; 类型，甚至还可以是函数。而用回调函数的方式则可以进行更便携的交互。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;/*** 服务端 **/
socket.on('message',data =&amp;gt;{
  console.log(data)
});

socket.emit('send','hello everybody');

/*** 客户端 **/
socket.emit('message',{id:'1',txt:'hello'});

socket.on('send',data =&amp;gt;{
  console.log(data);
});

//回调函数
/*** 服务端 **/
socket.on('sayit', (word, callback)=&amp;gt; {
  callback('say ' + word);
});

/*** 客户端 **/
socket.emit('sayit', 'wow', data =&amp;gt; { 
  console.log(data); // say wow
});
 &lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;broadcast-广播&quot;&gt;broadcast 广播&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;broadcast&lt;/strong&gt; 默认是向所有的socket连接进行广播，但是不包括发送者自身，如果自己也打算接收消息的话，需要给自己单独发送。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;/*** 服务端 **/
io.on('connection', socket =&amp;gt; {
 const data= {
   txt:'new user login',
   time:new Date()
 }
 //广播向所有socket连接
 socket.broadcast.emit('userin',data);
 //给自己也发一份
 socket.emit('userin',data);
});&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;namespace-命名空间&quot;&gt;namespace 命名空间&lt;/h2&gt;
&lt;p&gt;如果你想隔离作用域，或者划分业务模块，&lt;strong&gt;namespace&lt;/strong&gt; 是个有效的法子。&lt;strong&gt;namespace&lt;/strong&gt; 相当于建立新的频道，你可以在一个 &lt;strong&gt;socket.io&lt;/strong&gt; 服务上面隔离不同的连接，事件和中间件。&lt;/p&gt;
&lt;p&gt;默认的连接也是有&lt;strong&gt;namespace&lt;/strong&gt;的，那就是 &lt;strong&gt;/&lt;/strong&gt;；&lt;br/&gt;使用命名空间的方式一：直接在链接后面加子域名，这种其实用的还是同一个 sokcet 连接，可以看成是软隔离吧。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;/*** 客户端 **/
import io from 'socket.io-client';

//默认的namespace
const socket = io('http://127.0.0.1:3001');
// mypath
const socket = io('http://127.0.0.1:3001/mypath', { forceNew: true });

/*** 服务端 **/
//默认的namespace
io.on('connection', socket =&amp;gt; {
});
// mypath
io.of('/mypath').on('connection', socket =&amp;gt; {
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用命名空间的方式二： path 参数，这种就是实打实的重新起了一个 socket 服务了。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;/*** 客户端 **/
const socket = io('http://localhost', {
  path: '/mypath'
});

/*** 服务端 **/
// 另外重新起socket服务
const io = require('socket.io')({
  path: '/mypath'
});&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;middleware-中间件&quot;&gt;middleware 中间件&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;socket.io&lt;/strong&gt; 的中间件 和 kao2 的非常相似，这意味着我们可以在变动很小的情况下，将koa2的中间件改造为 &lt;strong&gt;socket.io&lt;/strong&gt; 所用。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;const mypath = io.of('/mypath').on('connection', socket =&amp;gt; {
    socket.on('message', data =&amp;gt; {
    });
});

//中间件
const auth = (socket, next) =&amp;gt; {
    const data = socket.request;
  if(!verify(data)){
    throw new Error('not verify');
  }
  next();
}
// mypath 这个 namespace 注册中间件
mypath.use(auth);&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;rooms&quot;&gt;rooms&lt;/h2&gt;
&lt;p&gt;每一个socket连接都会有一个独一无二的标志，那就是 socket.id，我们就是通过id来区分不同连接的。除此之外，socket.id 本身也是房间 &lt;strong&gt;room&lt;/strong&gt; 的标志，通俗讲，每个socket 连接自身都拥有一间房 &lt;strong&gt;room&lt;/strong&gt;。那么我们就可以给这个 &lt;strong&gt;room&lt;/strong&gt; 发送消息，还有如果你加入了房间，就能接受到房间里的广播信息。当然你可以自定义 &lt;strong&gt;room&lt;/strong&gt; ，让socket连接加入或离开。如果 socket 连接 disconnect 之后，会自动离开 room。&lt;/p&gt;
&lt;p&gt;而这就是实现 &lt;em&gt;单独聊天&lt;/em&gt; 和 &lt;em&gt;群组聊天&lt;/em&gt; 的基础，来看一下对应的api。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;socket.join(rooms[, callback])&lt;/strong&gt;：加入房间&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;socket.leave(room[, callback])&lt;/strong&gt; ：离开房间&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;socket.to(room)&lt;/strong&gt;： 给房间发送消息&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// 自定义room
io.on('connection', socket =&amp;gt;{    
  socket.join('some room')); // 加入房间
  socket.leave('some room'); // 离开房间
}); 

// 向房间里的所有客户端发送消息
io.to('some room').emit('some event'); 

// 默认房间（每一个id一个room）
socket.on('say to someone', (id, msg) =&amp;gt; {    
    socket.broadcast.to(id).emit('my message', msg); 
}); &lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;相信有了以上介绍的基础知识，再加上官网对应的文档，要开发聊天室或者其他 实时通信 的项目，是一件易如反掌的事情&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://socket.io/&quot;&gt;socket.io官网&lt;/a&gt; 里面有对 api 非常详细的讲解和用例。&lt;/p&gt;
</description>
<pubDate>Fri, 29 Mar 2019 21:08:00 +0000</pubDate>
<dc:creator>Jeff.Zhong</dc:creator>
<og:description>这段时间学习了 socket.io ，用它写了小项目，在此总结下它的基本使用方式和一些要点。 socket.io 是基于 Node.js 和 WebSocket 协议的实时通信开源框架，它包括客户端的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/edwardloveyou/p/10625152.html</dc:identifier>
</item>
<item>
<title>记录使用 Cake 进行构建并制作 nuget 包 - h82258652</title>
<link>http://www.cnblogs.com/h82258652/p/10625036.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/h82258652/p/10625036.html</guid>
<description>&lt;p&gt;书接上一回（&lt;a href=&quot;https://www.cnblogs.com/h82258652/p/4898983.html&quot;&gt;https://www.cnblogs.com/h82258652/p/4898983.html&lt;/a&gt;）？[手动狗头]&lt;/p&gt;
&lt;p&gt;前段时间折腾了一下，总算是把我自己的图片缓存控件（&lt;a href=&quot;https://github.com/h82258652/HN.Controls.ImageEx&quot;&gt;https://github.com/h82258652/HN.Controls.ImageEx&lt;/a&gt;）发布到了 nuget 上，目前已经进入一个比较稳定的版本了，基本没有很严重的 bug 了。其实核心代码早就写完了，后期主要都在折腾持续集成以及自动构建（包含制作 nuget 包）。持续集成使用了 appveyor，园子里也有不少相关的资料，这里我就不说了。&lt;/p&gt;
&lt;p&gt;在制作 nuget 包的过程中，我折腾了很久，最开始打算直接用 appveyor 的自动打包功能，但是在打包 UWP 的包时，打包出来的版本号一直都是 1.0.0，而 WPF 的就没这问题（这个已确认是 appveyor 的 bug，然而好久都还没有修复(lll￢ω￢)）。另外包里的 dll 的版本号也不好统一控制，我发一次版本需要发 3 个 nuget 包，每个 nuget 包都有一个 dll，手动折腾版本号那不切实际的。&lt;/p&gt;
&lt;p&gt;在经过一番调研之后，我终于发现了一个能满足我需求的工具，Cake，也叫 C# Make，是一个专门用来进行 .net 项目构建的工具。官方网站在此：&lt;a href=&quot;https://cakebuild.net/&quot;&gt;https://cakebuild.net/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;接下来就按着教程开始吧。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/484187/201903/484187-20190330011242340-42320048.png&quot;&gt;&lt;img title=&quot;Snipaste_2019-03-29_23-00-45&quot; src=&quot;https://img2018.cnblogs.com/blog/484187/201903/484187-20190330011243396-1751442903.png&quot; alt=&quot;Snipaste_2019-03-29_23-00-45&quot; width=&quot;1389&quot; height=&quot;602&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这个是我项目的根目录。接下来我们在此目录运行 Powershell（可以通过左上角的文件 –&amp;gt; 打开 Windows Powershell 来打开）。然后输入以下命令。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
Invoke-WebRequest https://cakebuild.net/download/bootstrapper/windows -OutFile build.ps1
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后敲下回车，稍微等待之后，我们的目录下就会出现一个叫 build.ps1 的文件。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/484187/201903/484187-20190330011244127-1039693102.png&quot;&gt;&lt;img title=&quot;Snipaste_2019-03-29_23-07-34&quot; src=&quot;https://img2018.cnblogs.com/blog/484187/201903/484187-20190330011245053-1466397096.png&quot; alt=&quot;Snipaste_2019-03-29_23-07-34&quot; width=&quot;1328&quot; height=&quot;568&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;接下来我们在该目录创建一个叫 build.cake 的空白文件，这个文件主要就是执行构建的逻辑。&lt;/p&gt;
&lt;p&gt;然后在宇宙最强的 IDE，Visual Studio 中进行编写脚本吧，在这里，建议各位看官先安装一个插件：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/484187/201903/484187-20190330011245684-2068712325.png&quot;&gt;&lt;img title=&quot;Snipaste_2019-03-29_23-13-08&quot; src=&quot;https://img2018.cnblogs.com/blog/484187/201903/484187-20190330011246745-475265942.png&quot; alt=&quot;Snipaste_2019-03-29_23-13-08&quot; width=&quot;968&quot; height=&quot;244&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;安装之后，Visual Studio 就具备对 .cake 脚本的语法高亮能力（可惜还是没法有语法提示功能/(ㄒoㄒ)/~~）。&lt;/p&gt;
&lt;p&gt;使用 Visual Studio 打开 build.cake 之后，先编写个 Hello world 热热身：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
var target = Argument(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;target&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Default&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

Task(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Default&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
  .Does(() &lt;/span&gt;=&amp;gt;&lt;span&gt;
{
  Information(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hello World!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
});

RunTarget(target);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后保存并运行刚才的 build.ps1。（Powershell 里输入 &lt;strong&gt;&lt;span&gt;.\build.ps1&lt;/span&gt;&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;如果运气好的话，那么你应该和我一样碰到了这样的情况：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/484187/201903/484187-20190330011247466-519218422.png&quot;&gt;&lt;img title=&quot;Snipaste_2019-03-29_23-23-33&quot; src=&quot;https://img2018.cnblogs.com/blog/484187/201903/484187-20190330011248023-498326435.png&quot; alt=&quot;Snipaste_2019-03-29_23-23-33&quot; width=&quot;2206&quot; height=&quot;409&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这是由于执行 Powershell 脚本是一直比较危险的操作，所以需要更改权限。&lt;/p&gt;
&lt;p&gt;输入如下的脚本：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/484187/201903/484187-20190330011248641-652208093.png&quot;&gt;&lt;img title=&quot;Snipaste_2019-03-29_23-26-39&quot; src=&quot;https://img2018.cnblogs.com/blog/484187/201903/484187-20190330011250042-559069703.png&quot; alt=&quot;Snipaste_2019-03-29_23-26-39&quot; width=&quot;2206&quot; height=&quot;370&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;或者可以参考微软的官方文档来修改权限：&lt;a href=&quot;https://docs.microsoft.com/zh-cn/powershell/module/microsoft.powershell.core/about/about_execution_policies?view=powershell-6&quot;&gt;https://docs.microsoft.com/zh-cn/powershell/module/microsoft.powershell.core/about/about_execution_policies?view=powershell-6&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;接着再次执行脚本，应该就可以看见如下信息。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/484187/201903/484187-20190330011250820-1491191846.png&quot;&gt;&lt;img title=&quot;Snipaste_2019-03-29_23-29-22&quot; src=&quot;https://img2018.cnblogs.com/blog/484187/201903/484187-20190330011251389-444883170.png&quot; alt=&quot;Snipaste_2019-03-29_23-29-22&quot; width=&quot;980&quot; height=&quot;641&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我们的 Hello world 终于跑起来了，热身完毕，接下来开始编写构建脚本。&lt;/p&gt;
&lt;p&gt;Cake 脚本是由一个个 Task 串联起来的，我们先定义一些变量和一个叫 Build 的 Task，用于执行构建。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
var target = Argument(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;target&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Default&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
var configuration &lt;/span&gt;= Argument(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;configuration&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Release&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
var verbosity &lt;/span&gt;= Argument(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;verbosity&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, Verbosity.Minimal);

var solution &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;./HN.Controls.ImageEx.sln&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

Task(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Build&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    .Does(() &lt;/span&gt;=&amp;gt;&lt;span&gt;
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(IsRunningOnWindows())
    {
        &lt;/span&gt;//&lt;span&gt; Use MSBuild
        MSBuild(solution, configurator &lt;/span&gt;=&amp;gt;&lt;span&gt;
            configurator.SetConfiguration(configuration)
                .SetVerbosity(verbosity));
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
    {
        &lt;/span&gt;//&lt;span&gt; Use XBuild
        XBuild(solution, configurator &lt;/span&gt;=&amp;gt;&lt;span&gt;
            configurator.SetConfiguration(configuration)
                .SetVerbosity(verbosity));
    }
});


Task(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Default&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    .IsDependentOn(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Build&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

RunTarget(target);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里定义了一些变量，configuration 定义为 Release，在 Build Task 里用到，设置为使用 Release 模式。verbosity 表示编译时的信息输入，这里设置为 Minimal，以免输出过多的信息。solution 表示解决方案的路径。然后运行：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/484187/201903/484187-20190330011252228-43541805.png&quot;&gt;&lt;img title=&quot;Snipaste_2019-03-29_23-53-38&quot; src=&quot;https://img2018.cnblogs.com/blog/484187/201903/484187-20190330011253080-2114083600.png&quot; alt=&quot;Snipaste_2019-03-29_23-53-38&quot; width=&quot;2011&quot; height=&quot;1027&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这样一执行就把这个解决方案构建了一遍。&lt;/p&gt;
&lt;p&gt;然后我们开始编写打包的 Task，命名为 Package。修改脚本如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
var target = Argument(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;target&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Default&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
var configuration &lt;/span&gt;= Argument(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;configuration&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Release&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
var verbosity &lt;/span&gt;= Argument(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;verbosity&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, Verbosity.Minimal);
var version &lt;/span&gt;= Argument(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1.0.0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

var solution &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;./HN.Controls.ImageEx.sln&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

Task(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Build&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    .Does(() &lt;/span&gt;=&amp;gt;&lt;span&gt;
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(IsRunningOnWindows())
    {
        &lt;/span&gt;//&lt;span&gt; Use MSBuild
        MSBuild(solution, configurator &lt;/span&gt;=&amp;gt;&lt;span&gt;
            configurator.SetConfiguration(configuration)
                .SetVerbosity(verbosity));
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
    {
        &lt;/span&gt;//&lt;span&gt; Use XBuild
        XBuild(solution, configurator &lt;/span&gt;=&amp;gt;&lt;span&gt;
            configurator.SetConfiguration(configuration)
                .SetVerbosity(verbosity));
    }
});

Task(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Package&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    .IsDependentOn(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Build&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    .Does(() &lt;/span&gt;=&amp;gt;&lt;span&gt;
{
    var nuGetPackSettings &lt;/span&gt;=&lt;span&gt; new NuGetPackSettings
    {
        Version &lt;/span&gt;=&lt;span&gt; version
    };

    var nuspecFiles &lt;/span&gt;= GetFiles(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;./src/*/*.nuspec&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    NuGetPack(nuspecFiles, nuGetPackSettings);
});

Task(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Default&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    .IsDependentOn(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Package&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

RunTarget(target);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这里我加了一个 version 的变量，在下面打包 nuget 包的时候会用到，统一每个 nuget 包的版本号。GetFiles(&quot;./src/*/*.nuspec&quot;) 这个则获取了源文件夹下面的项目下的 nuspec 文件（我这里一个 nuspec 对应一个 csproj，就放到同一个文件夹下了），这个文件的作用是用于描述 nuget 包如何进行打包，具体可以参考本文开头指向的上一篇文章。&lt;/p&gt;
&lt;p&gt;执行之后，我们会得到些 nuget 包（当然对于看官你们的项目需要有 nuspec 才行啦）：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/484187/201903/484187-20190330011253612-407821978.png&quot;&gt;&lt;img title=&quot;Snipaste_2019-03-30_00-06-51&quot; src=&quot;https://img2018.cnblogs.com/blog/484187/201903/484187-20190330011254376-1046641970.png&quot; alt=&quot;Snipaste_2019-03-30_00-06-51&quot; width=&quot;586&quot; height=&quot;128&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;编译、打包都说完了。最后就是版本号的问题。nuget 包的版本在上面已经解决了，现在就是 dll 的版本号比较棘手。在我这三个项目中，WPF 和 UWP 都是传统的项目，都是有一个 AssemblyInfo.cs 的文件，然后里面通过 AssemblyVersionAttribute 来设置 dll 的版本号的。但是我这个 Core 的项目是新类型的项目，并没有 AssemblyInfo.cs 文件，版本号是在 csproj 里设置的。这难道没办法了么，最后通过万能的 Google 和 StackOverflow，我还是找到了办法。编辑 csproj 文件，并添加下面一节。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/484187/201903/484187-20190330011255115-1252501317.png&quot;&gt;&lt;img title=&quot;Snipaste_2019-03-30_00-19-52&quot; src=&quot;https://img2018.cnblogs.com/blog/484187/201903/484187-20190330011256100-2123457476.png&quot; alt=&quot;Snipaste_2019-03-30_00-19-52&quot; width=&quot;1418&quot; height=&quot;567&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这样，这个项目的版本号等信息就不会从 csproj 里面读取。我们可以添加自己的 AssemblyInfo.cs 文件进行版本号管理。&lt;/p&gt;
&lt;p&gt;现在情况就是每个项目都有自己的 AssemblyInfo.cs 了，如何统一使用一个 AssemblyInfo.cs 文件来管理这几个项目呢？还记得 Visual Studio 有一个添加引用文件的功能么？&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/484187/201903/484187-20190330011256810-1176286032.png&quot;&gt;&lt;img title=&quot;Snipaste_2019-03-30_00-33-34&quot; src=&quot;https://img2018.cnblogs.com/blog/484187/201903/484187-20190330011257486-1477919978.png&quot; alt=&quot;Snipaste_2019-03-30_00-33-34&quot; width=&quot;876&quot; height=&quot;789&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这样几个项目都通过这种方式引用同一个 AssemblyInfo.cs 文件就行了。&lt;/p&gt;
&lt;p&gt;最后的问题就是如何将 AssemblyInfo.cs 里的版本号跟 build.cake 脚本里的版本号保持一致。在查阅 Cake 的官方文档后，我发现有一个能生成 AssemblyInfo 的功能。修改我们的 build.cake 脚本：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
var target = Argument(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;target&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Default&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
var configuration &lt;/span&gt;= Argument(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;configuration&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Release&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
var verbosity &lt;/span&gt;= Argument(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;verbosity&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, Verbosity.Minimal);
var version &lt;/span&gt;= Argument(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1.0.0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

var solution &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;./HN.Controls.ImageEx.sln&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

Task(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Version&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    .Does(() &lt;/span&gt;=&amp;gt;&lt;span&gt;
{
    var file &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;./src/SolutionInfo.cs&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    CreateAssemblyInfo(file, new AssemblyInfoSettings
    {
        Version &lt;/span&gt;=&lt;span&gt; version,
        FileVersion &lt;/span&gt;=&lt;span&gt; version,
        InformationalVersion &lt;/span&gt;=&lt;span&gt; version
    });
});

Task(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Build&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    .IsDependentOn(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Version&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    .Does(() &lt;/span&gt;=&amp;gt;&lt;span&gt;
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(IsRunningOnWindows())
    {
        &lt;/span&gt;//&lt;span&gt; Use MSBuild
        MSBuild(solution, configurator &lt;/span&gt;=&amp;gt;&lt;span&gt;
            configurator.SetConfiguration(configuration)
                .SetVerbosity(verbosity));
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
    {
        &lt;/span&gt;//&lt;span&gt; Use XBuild
        XBuild(solution, configurator &lt;/span&gt;=&amp;gt;&lt;span&gt;
            configurator.SetConfiguration(configuration)
                .SetVerbosity(verbosity));
    }
});

Task(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Package&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    .IsDependentOn(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Build&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    .Does(() &lt;/span&gt;=&amp;gt;&lt;span&gt;
{
    var nuGetPackSettings &lt;/span&gt;=&lt;span&gt; new NuGetPackSettings
    {
        Version &lt;/span&gt;=&lt;span&gt; version
    };

    var nuspecFiles &lt;/span&gt;= GetFiles(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;./src/*/*.nuspec&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    NuGetPack(nuspecFiles, nuGetPackSettings);
});

Task(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Default&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    .IsDependentOn(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Package&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

RunTarget(target);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在 Version Task 中，会生成一个 SolutionInfo.cs 的文件，也就相当于前面的 AssemblyInfo.cs。那现在所有的项目都引用这个文件来进行统一的版本管理就行了。&lt;/p&gt;

&lt;p&gt;这样就已经实现了统一版本、构建、打包的一件脚本化了。后续还可以添加上构建完之后执行单元测试以及打包后自动发布到 nuget 的功能，但我自己比较习惯打包完之后本地也测试一下（毕竟 nuget 发了就不能删），所以就暂时不折腾这功能了。&lt;/p&gt;
&lt;p&gt;博主图片缓存控件项目的 build.cake 脚本可以参考这里：&lt;a href=&quot;https://github.com/h82258652/HN.Controls.ImageEx/blob/master/build.cake&quot;&gt;https://github.com/h82258652/HN.Controls.ImageEx/blob/master/build.cake&lt;/a&gt;，虽然配置好了 xunit，但是没有写单元测试就是了，ε=ε=ε=┏(゜ロ゜;)┛&lt;/p&gt;
&lt;p&gt;这篇博文主要记录操作步骤，方便以后自己（我还有个微博的库的坑想要填……）。但也希望看完这篇博文的各位，制作一个 nuget 包并不是一件难事，马上行动把珍藏都弄一份 nuget 包，让各位 .net 开发者也机会用上吧。&lt;/p&gt;
</description>
<pubDate>Fri, 29 Mar 2019 17:13:00 +0000</pubDate>
<dc:creator>h82258652</dc:creator>
<og:description>书接上一回（https://www.cnblogs.com/h82258652/p/4898983.html）？[手动狗头] 前段时间折腾了一下，总算是把我自己的图片缓存控件（https://gith</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/h82258652/p/10625036.html</dc:identifier>
</item>
<item>
<title>Maven把项目依赖的所有jar包都打到同一个jar中 - 马瘦风</title>
<link>http://www.cnblogs.com/shoufeng/p/10624968.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shoufeng/p/10624968.html</guid>
<description>&lt;p&gt;(1) 在项目的&lt;code&gt;pom.xml&lt;/code&gt;文件中加入如下插件:&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;    &amp;lt;build&amp;gt;
        &amp;lt;plugins&amp;gt;
            &amp;lt;!-- Maven Shade Plugin --&amp;gt;
            &amp;lt;plugin&amp;gt;
                &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;maven-shade-plugin&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;3.2.0&amp;lt;/version&amp;gt;
                &amp;lt;configuration&amp;gt;
                    &amp;lt;createDependencyReducedPom&amp;gt;true&amp;lt;/createDependencyReducedPom&amp;gt;
                &amp;lt;/configuration&amp;gt;
                &amp;lt;executions&amp;gt;
                    &amp;lt;execution&amp;gt;
                        &amp;lt;phase&amp;gt;package&amp;lt;/phase&amp;gt;
                        &amp;lt;goals&amp;gt;
                            &amp;lt;goal&amp;gt;shade&amp;lt;/goal&amp;gt;
                        &amp;lt;/goals&amp;gt;
                        &amp;lt;configuration&amp;gt;
                            &amp;lt;transformers&amp;gt;
                                &amp;lt;transformer implementation=&quot;org.apache.maven.plugins.shade.resource.ManifestResourceTransformer&quot;&amp;gt;
                                    &amp;lt;!-- 主类的全限定名 --&amp;gt;
                                    &amp;lt;mainClass&amp;gt;com.healchow.consumer.Main&amp;lt;/mainClass&amp;gt;
                                &amp;lt;/transformer&amp;gt;
                            &amp;lt;/transformers&amp;gt;
                        &amp;lt;/configuration&amp;gt;
                    &amp;lt;/execution&amp;gt;
                &amp;lt;/executions&amp;gt;
            &amp;lt;/plugin&amp;gt;
        &amp;lt;/plugins&amp;gt;
    &amp;lt;/build&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;(2) 然后使用Maven的&lt;code&gt;package&lt;/code&gt;命令打包项目;&lt;/p&gt;
&lt;p&gt;(3) 打包完成后, 即可在项目的&lt;code&gt;target&lt;/code&gt;目录下看到生成的jar包;&lt;/p&gt;
&lt;p&gt;(4) 不出差错的话, 使用&lt;code&gt;java -jar xxxx.jar&lt;/code&gt;命令即可运行此jar包.&lt;/p&gt;
&lt;p&gt;说明: 此方法在Mac OS系统下的IDEA中实施, 在&lt;code&gt;jar/META-INF/&lt;/code&gt;目录下有时会出现:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ECLIPSEF.SF ECLIPSE.RSA&lt;/code&gt;等文件, 并在运行&lt;code&gt;java -jar xxx.jar&lt;/code&gt;时, 会抛出如下错误:&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;Error: A JNI error has occurred, please check your installation and try again
Exception in thread &quot;main&quot; java.lang.SecurityException: Invalid signature file digest for Manifest main attributes
        at sun.security.util.SignatureFileVerifier.processImpl(SignatureFileVerifier.java:330)
        at sun.security.util.SignatureFileVerifier.process(SignatureFileVerifier.java:263)
        at java.util.jar.JarVerifier.processEntry(JarVerifier.java:318)
        at java.util.jar.JarVerifier.update(JarVerifier.java:230)
        at java.util.jar.JarFile.initializeVerifier(JarFile.java:383)
        at java.util.jar.JarFile.getInputStream(JarFile.java:450)
        at sun.misc.URLClassPath$JarLoader$2.getInputStream(URLClassPath.java:977)
        at sun.misc.Resource.cachedInputStream(Resource.java:77)
        at sun.misc.Resource.getByteBuffer(Resource.java:160)
        at java.net.URLClassLoader.defineClass(URLClassLoader.java:454)
        at java.net.URLClassLoader.access$100(URLClassLoader.java:73)
        at java.net.URLClassLoader$1.run(URLClassLoader.java:368)
        at java.net.URLClassLoader$1.run(URLClassLoader.java:362)
        at java.security.AccessController.doPrivileged(Native Method)
        at java.net.URLClassLoader.findClass(URLClassLoader.java:361)
        at java.lang.ClassLoader.loadClass(ClassLoader.java:424)
        at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:335)
        at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
        at sun.launcher.LauncherHelper.checkAndLoadMain(LauncherHelper.java:495)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;解决办法是: 手动删除jar包中&lt;code&gt;META-INF/*.RSA META-INF/*.DSA META-INF/*.SF&lt;/code&gt;这些文件, 然后就可行了.&lt;/p&gt;

&lt;p&gt;(1) 在项目的&lt;code&gt;pom.xml&lt;/code&gt;文件中加入如下插件:&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;     &amp;lt;build&amp;gt;
        &amp;lt;plugins&amp;gt;
            &amp;lt;!-- Maven Assembly Plugin --&amp;gt;
            &amp;lt;plugin&amp;gt;
                &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;maven-assembly-plugin&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;2.4.1&amp;lt;/version&amp;gt;
                &amp;lt;configuration&amp;gt;
                    &amp;lt;!-- get all project dependencies --&amp;gt;
                    &amp;lt;descriptorRefs&amp;gt;
                        &amp;lt;descriptorRef&amp;gt;jar-with-dependencies&amp;lt;/descriptorRef&amp;gt;
                    &amp;lt;/descriptorRefs&amp;gt;
                    &amp;lt;!-- MainClass in mainfest make a executable jar --&amp;gt;
                    &amp;lt;archive&amp;gt;
                        &amp;lt;manifest&amp;gt;
                            &amp;lt;mainClass&amp;gt;com.healchow.consumer.Main&amp;lt;/mainClass&amp;gt;
                        &amp;lt;/manifest&amp;gt;
                    &amp;lt;/archive&amp;gt;
                &amp;lt;/configuration&amp;gt;
                &amp;lt;executions&amp;gt;
                    &amp;lt;!-- 配置执行器 --&amp;gt;
                    &amp;lt;execution&amp;gt;
                        &amp;lt;id&amp;gt;make-assembly&amp;lt;/id&amp;gt;
                        &amp;lt;!-- 绑定到package命令的生命周期上 --&amp;gt;
                        &amp;lt;phase&amp;gt;package&amp;lt;/phase&amp;gt;
                        &amp;lt;goals&amp;gt;
                            &amp;lt;!-- 只运行一次 --&amp;gt;
                            &amp;lt;goal&amp;gt;single&amp;lt;/goal&amp;gt;
                        &amp;lt;/goals&amp;gt;
                    &amp;lt;/execution&amp;gt;
                &amp;lt;/executions&amp;gt;
            &amp;lt;/plugin&amp;gt;
         &amp;lt;/plugins&amp;gt;
     &amp;lt;/build&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;(2) 然后使用Maven的&lt;code&gt;package&lt;/code&gt;命令打包项目;&lt;/p&gt;
&lt;p&gt;(3) 打包完成后, 即可在项目的&lt;code&gt;target&lt;/code&gt;目录下看到生成的jar包, 其中&lt;code&gt;xxx-jar-with-dependencies.jar&lt;/code&gt;是包含依赖jar包的jar文件, 另一个不包含依赖jar包;&lt;/p&gt;
&lt;p&gt;(4) 使用&lt;code&gt;java -jar xxxx.jar&lt;/code&gt;命令即可运行此jar包.&lt;/p&gt;

&lt;p&gt;命令如下:&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;mvn install:install-file -Dfile=base-util-1.0.RELEASE.jar -DgroupId=com.healchow -DartifactId=base-util -Dversion=1.0.RELEASE -Dpackaging=jar
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其他命令, 参考这篇博客: &lt;a href=&quot;https://www.cnblogs.com/wkrbky/p/6352188.html&quot;&gt;Maven常用命令&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;创建可执行 jar 包的关键在于：让&lt;code&gt;java -jar&lt;/code&gt;命令知道 jar 包中的主方法属于哪个类 —— 要配置主类的全限定名.&lt;/p&gt;
&lt;p&gt;步骤如下:&lt;/p&gt;
&lt;p&gt;(1) 打包指定的项目:&lt;/p&gt;
&lt;p&gt;进入项目所在的根目录, 以Linux系统为例:&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;项目名是&lt;code&gt;java-test&lt;/code&gt;, 其所在的目录是&lt;code&gt;/data/project/java-test&lt;/code&gt;;&lt;/p&gt;
&lt;p&gt;main方法所属的类的全限定名是&lt;code&gt;com.healchow.test.Main&lt;/code&gt;:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;# 进入项目所在的根目录:
cd /data/project
# 运行打包命令: 
jar  cvfe  test.jar  java-test.com.healchow.test.Main  java-test &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述命令说明: 将&lt;code&gt;java-test&lt;/code&gt;目录下的所有文件打包到&lt;code&gt;test.jar&lt;/code&gt;中, 并指定主类的全限定名称, 这里要指明主类所在的文件夹.&lt;/p&gt;
&lt;blockquote readability=&quot;14&quot;&gt;
&lt;p&gt;&lt;strong&gt;关于&lt;code&gt;jar&lt;/code&gt;命令的其他用法, 参考如下:&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;# 用法: jar {ctxui}[vfmn0PMe] [jar-file] [manifest-file] [entry-point] [-C dir] files ...
# 选项:
 -c  创建新档案
 -t  列出档案目录
 -x  从档案中提取指定的 (或所有) 文件
 -u  更新现有档案
 -v  在标准输出中生成详细输出
 -f  指定档案文件名
 -m  包含指定清单文件中的清单信息
 -n  创建新档案后执行 Pack200 规范化
 -e  为捆绑到可执行 jar 文件的独立应用程序指定应用程序入口点
 -0  仅存储; 不使用任何 ZIP 压缩
 -P  保留文件名中的前导 '/' (绝对路径) 和 &quot;..&quot; (父目录) 组件
 -M  不创建条目的清单文件
 -i  为指定的 jar 文件生成索引信息
 -C  更改为指定的目录并包含以下文件
# 如果任何文件为目录, 则对其进行递归处理。
# 清单文件名, 档案文件名和入口点名称的指定顺序 与 'm', 'f' 和 'e' 标记的指定顺序相同。

示例 1: 将两个类文件归档到一个名为 classes.jar 的档案中: 
    jar cvf classes.jar Foo.class Bar.class 
示例 2: 使用现有的清单文件 'mymanifest' 并将 foo/ 目录中的所有文件归档到 'classes.jar' 中: 
    jar cvfm classes.jar mymanifest -C foo/ .&lt;/code&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt;(2) 运行jar包:&lt;/p&gt;
&lt;p&gt;用解压软件打开上一步生成的jar包, 查看&lt;code&gt;META-INF/MANIFEST.MF&lt;/code&gt;文件, 里面如果有&lt;code&gt;Main-Class: com.healchow.test.Main&lt;/code&gt;, 说明打包成功.&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;# 在当前目录下, 运行jar包: 
java -jar test.jar&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;阻塞式方式&quot;&gt;5.1 阻塞式方式&lt;/h2&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;java -jar xxx.jar&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;特点: 当前终端的会话窗口被阻塞, 可按&lt;code&gt;CTRL + C&lt;/code&gt;中断程序的运行, 或者直接关闭会话窗口 —— 此时jar程序将终止.&lt;/p&gt;
&lt;h2 id=&quot;后台运行方式&quot;&gt;5.2 后台运行方式&lt;/h2&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;# 通过&quot;&amp;amp;&quot;符号实现后台运行: 
java -jar xxx.jar &amp;amp;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;特点: 当前终端的会话窗口不会被阻塞, 但是如果关闭当前窗口, 程序将终止运行.&lt;/p&gt;
&lt;h2 id=&quot;后台持续运行方式&quot;&gt;5.3 后台持续运行方式&lt;/h2&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;# 通过&quot;nohup&quot;命令实现后台运行: 
nohup java -jar xxx.jar &amp;amp;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;nohup&lt;/code&gt;命令是不挂断运行命令的意思.&lt;/p&gt;
&lt;p&gt;特点: 当用户退出或终端关闭时, 程序的运行不受影响.&lt;/p&gt;
&lt;p&gt;说明: 用&lt;code&gt;nohup&lt;/code&gt;命令运行任务时, 默认情况下这个任务的所有输出都将被重定向到&lt;code&gt;nohup.out&lt;/code&gt;文件中, 除非另外指定输出文件. 指定输出文件方式为:&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;# 将输出重定向到xxx.log文件中: 
nohup java -jar xxx.jar &amp;gt; xxx.log &amp;amp;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;&amp;gt;&lt;/code&gt; 符号是重定向符, 实现: 把它之前命令的所有输出信息重定向到后面的文件中, 而不是显示到屏幕上.&lt;/p&gt;
&lt;h2 id=&quot;其他命令扩展&quot;&gt;5.4 其他命令扩展&lt;/h2&gt;
&lt;p&gt;① 通过&lt;code&gt;jobs&lt;/code&gt;命令可以查看后台运行任务, 会给每个任务指定一个编号.&lt;br/&gt;② 通过&lt;code&gt;fg&lt;/code&gt;命令可以把指定编号的后台任务调回到前台控制, 如: &lt;code&gt;fg 10&lt;/code&gt; —— 把10号任务调回前台.&lt;br/&gt;③ 查看占用某个端口的进程:&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;netstat -nlp | grep 2181
# 下述结果说明进程号pid=18434的java进程占用了2181端口
tcp        0      0 :::2181          :::*           LISTEN      18434/java&lt;/code&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote readability=&quot;0.83333333333333&quot;&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/hafiz/p/6538332.html&quot;&gt;使用Maven的assembly插件实现自定义打包&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/dzblog/p/6913809.html&quot;&gt;Maven构建可执行的jar包(包含依赖jar包)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/kedarui/p/6135895.html&quot;&gt;linux下利用nohup后台运行jar文件包程序&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;16.040752351097&quot;&gt;

&lt;p&gt;作者: ma_shoufeng(马瘦风)&lt;/p&gt;
&lt;p&gt;出处: 博客园 &lt;a href=&quot;https://www.cnblogs.com/shoufeng&quot;&gt;马瘦风的博客&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;您的支持是对博主的极大鼓励, 感谢您的阅读.&lt;/p&gt;
&lt;p&gt;本文版权归博主所有, 欢迎转载, 但请保留此段声明, 并在文章页面明显位置给出原文链接, 否则博主保留追究相关人员法律责任的权利.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Fri, 29 Mar 2019 16:20:00 +0000</pubDate>
<dc:creator>马瘦风</dc:creator>
<og:description>Maven生成jar包时, 怎样把项目中依赖的jar包也包括进去? 这里介绍2种方式: 使用 shade插件, 和使用 assembly插件. 另外扩展Maven安装本地jar包到本地仓库的方法、手动</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shoufeng/p/10624968.html</dc:identifier>
</item>
<item>
<title>设计模式--简单工厂模式之在springboot中使用简单工厂模式 - 那个男孩很坏</title>
<link>http://www.cnblogs.com/boychen/p/10624935.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/boychen/p/10624935.html</guid>
<description>&lt;p&gt;1.前言：&lt;/p&gt;
&lt;p&gt;不了解简单工厂模式请先移步：&lt;a href=&quot;https://www.cnblogs.com/boychen/p/10618868.html&quot; target=&quot;_blank&quot;&gt;在商城中使用简单工厂&lt;/a&gt;。在这里主要是对springboot中使用简单工厂模式进行解析。&lt;/p&gt;

&lt;p&gt;2.问题：&lt;/p&gt;
&lt;p&gt;什么是简单工厂：它的实现方式是由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类（这些产品类继承自一个父类或接口）的实例。&lt;/p&gt;
&lt;p&gt;然而在Spring中，在启动容器对时候会通过beanFactory先创建初始化我们要用的类。&lt;/p&gt;
&lt;p&gt;一个是要在使用的时候去创建一个产品类，一个是预先已经加载好了我们要使用的对象，那我们要如何解决这个问题呢？&lt;/p&gt;

&lt;p&gt;3.场景：在一个商城系统中，用户可以选择三种支付方式，微信支付，支付宝支付，余额支付。&lt;/p&gt;

&lt;p&gt;4:方法：&lt;/p&gt;
&lt;p&gt;我们只要将要用到的支付方式注入到容器中，我们便可以根据bean到名字去容器中获取。当然只要是很不灵活的。&lt;/p&gt;
&lt;p&gt;其次，我们只要再注入一个支付工厂，每次去支付工厂拿自己想要的支付方式。这样我们就可以像之前那样，在自己想要的地方，只需要注入一个支付工厂即可。&lt;/p&gt;

&lt;p&gt;5.实现：&lt;/p&gt;
&lt;p&gt; 步骤1.创建接口类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; PaymentMethod {
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; pay();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;步骤2.实现接口类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;没有指定value，注入的bean默认首字母小写&lt;/span&gt;
&lt;span&gt;@Service
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Alipay &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; PaymentMethod {
    
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; pay() {
        System.out.println(&lt;/span&gt;&quot;支付宝支付&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Service
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; BalancePay &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; PaymentMethod {
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; pay() {
        System.out.println(&lt;/span&gt;&quot;余额支付&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Service
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; WechatPay &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; PaymentMethod {
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; pay() {
        System.out.println(&lt;/span&gt;&quot;微信支付&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;步骤3.直接在容器中，根据bean的名字获取需要的对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@SpringBootApplication
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SpringBootSimpleFactoryApplication {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {

        ConfigurableApplicationContext context &lt;/span&gt;= SpringApplication.run(SpringBootSimpleFactoryApplication.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, args);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        String[] beans = context.getBeanDefinitionNames();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        for (String bean:beans) {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;            System.out.println(&quot;bean:&quot;+bean);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;然而在实际开发中，是不可能经常通过context获取bean的&lt;/span&gt;
        PaymentMethod paymentMethod = (PaymentMethod) context.getBean(&quot;alipay&quot;&lt;span&gt;);
        paymentMethod.pay();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;步骤4.创建一个工厂，根据所要给定的信息返回相应的bean&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Service
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; PayFactory {

    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Alipay alipay;
    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; BalancePay balancePay;
    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; WechatPay wechatPay;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; PaymentMethod pay(String payType){

        &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (payType){

            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &quot;balancePay&quot;&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; balancePay;
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &quot;alipay&quot;&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; alipay;
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &quot;wechatPay&quot;&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; wechatPay;

            &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
                System.out.println(&lt;/span&gt;&quot;支付方式错误&quot;&lt;span&gt;);

        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;步骤5.在controller层调用支付工厂。(找不到ResponseResult类，请移步&lt;a href=&quot;https://www.cnblogs.com/boychen/p/10624816.html&quot; target=&quot;_blank&quot;&gt;单例模式之饿汉模式&lt;/a&gt;中获取)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@RestController
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; PayController {

    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; PayFactory payFactory;

    @RequestMapping(&lt;/span&gt;&quot;pay&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ResponseResult pay(String payType){

        ResponseResult responseResult &lt;/span&gt;=&lt;span&gt; ResponseResult.getInstance();

        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            PaymentMethod paymentMethod &lt;/span&gt;=&lt;span&gt; payFactory.pay(payType);
            paymentMethod.pay();
            responseResult.setMsg(&lt;/span&gt;&quot;操作成功&quot;&lt;span&gt;);
            responseResult.setCode(&lt;/span&gt;0&lt;span&gt;);
        }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e){
            e.printStackTrace();
            responseResult.setMsg(&lt;/span&gt;&quot;支付类型错误&quot;&lt;span&gt;);
            responseResult.setCode(&lt;/span&gt;1&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; responseResult;
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;源码：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/littleStone-chan/design-patternsIn-mall/tree/master/spring-boot-simple-factory&quot; target=&quot;_blank&quot;&gt;在springboot中使用简单工厂模式&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;在工作中，不能灵活的时候设计模式。希望通过这次的学习，可以加深对设计模式对理解。&lt;/p&gt;
&lt;p&gt;接下来会继续整理出自己在工作对时候可以使用对设计模式，不对望指点。如果文章对您有帮助，github给个start吧。&lt;/p&gt;

</description>
<pubDate>Fri, 29 Mar 2019 16:05:00 +0000</pubDate>
<dc:creator>那个男孩很坏</dc:creator>
<og:description>1.前言： 不了解简单工厂模式请先移步：在商城中使用简单工厂。在这里主要是对springboot中使用简单工厂模式进行解析。 2.问题： 什么是简单工厂：它的实现方式是由一个工厂类根据传入的参数，动态</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/boychen/p/10624935.html</dc:identifier>
</item>
<item>
<title>B+树 -- Java实现 - 冰魄秋雨</title>
<link>http://www.cnblogs.com/skyice/p/10624876.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/skyice/p/10624876.html</guid>
<description>&lt;h3 id=&quot;一b树定义&quot;&gt;一、B+树定义&lt;/h3&gt;
&lt;p&gt;B+树定义：关键字个数比孩子结点个数小1的树。&lt;/p&gt;
&lt;p&gt;除此之外B+树还有以下的要求：&lt;/p&gt;
&lt;ol readability=&quot;5.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;B+树包含2种类型的结点：内部结点（也称索引结点）和叶子结点。根结点本身即可以是内部结点，也可以是叶子结点。根结点的关键字个数最少可以只有1个。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;B+树与B树最大的不同是内部结点不保存数据，只用于索引，所有数据（或者说记录）都保存在叶子结点中。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;m阶B+树表示了内部结点最多有m-1个关键字（或者说内部结点最多有m个子树），阶数m同时限制了叶子结点最多存储m-1个记录。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;内部结点中的key都按照从小到大的顺序排列，对于内部结点中的一个key，左树中的所有key都小于它，右子树中的key都大于等于它。叶子结点中的记录也按照key的大小排列。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;每个叶子结点都存有相邻叶子结点的指针，叶子结点本身依关键字的大小自小而大顺序链接。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;二b树的插入操作&quot;&gt;二、B+树的插入操作&lt;/h3&gt;
&lt;p&gt;1）若为空树，创建一个叶子结点，然后将记录插入其中，此时这个叶子结点也是根结点，插入操作结束。&lt;/p&gt;
&lt;p&gt;2）针对叶子类型结点：根据key值找到叶子结点，向这个叶子结点插入记录。插入后，若当前结点key的个数小于等于m-1，则插入结束。否则将这个叶子结点分裂成左右两个叶子结点，左叶子结点包含前m/2个记录，右结点包含剩下的记录，将第m/2+1个记录的key进位到父结点中（父结点一定是索引类型结点），进位到父结点的key左孩子指针向左结点,右孩子指针向右结点。将当前结点的指针指向父结点，然后执行第3步。&lt;/p&gt;
&lt;p&gt;3）针对索引类型结点：若当前结点key的个数小于等于m-1，则插入结束。否则，将这个索引类型结点分裂成两个索引结点，左索引结点包含前(m-1)/2个key，右结点包含m-(m-1)/2个key，将第m/2个key进位到父结点中，进位到父结点的key左孩子指向左结点, 进位到父结点的key右孩子指向右结点。将当前结点的指针指向父结点，然后重复第3步。&lt;/p&gt;
&lt;p&gt;下面是一颗5阶B树的插入过程，5阶B数的结点最少2个key，最多4个key。&lt;/p&gt;
&lt;p&gt;a）空树中插入5&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://note.youdao.com/yws/api/personal/sync?method=download&amp;amp;fileId=WEB69417233afdac409cff5f28ed6a0cfbf&amp;amp;version=9753&amp;amp;cstk=jwUTY30k&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;b）依次插入8，10，15&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://note.youdao.com/yws/api/personal/file/WEB8b39763e6a1e6c1bf793a7c2764c0170?method=getImage&amp;amp;version=9754&amp;amp;cstk=jwUTY30k&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;c）插入16&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://note.youdao.com/yws/api/personal/file/WEB0176103c39d55fa36a4470c50bd0934b?method=getImage&amp;amp;version=9760&amp;amp;cstk=jwUTY30k&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;插入16后超过了关键字的个数限制，所以要进行分裂。在叶子结点分裂时，分裂出来的左结点2个记录，右边3个记录，中间key成为索引结点中的key，分裂后当前结点指向了父结点（根结点）。结果如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://note.youdao.com/yws/api/personal/file/WEBfcad9aead5a65ecf48e2b8ae5c64c31d?method=getImage&amp;amp;version=9766&amp;amp;cstk=jwUTY30k&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当然我们还有另一种分裂方式，给左结点3个记录，右结点2个记录，此时索引结点中的key就变为15。&lt;/p&gt;
&lt;p&gt;d）插入17&lt;br/&gt;&lt;img src=&quot;https://note.youdao.com/yws/api/personal/file/WEB05ccdcdab8ed106b5e22314c2d07c714?method=getImage&amp;amp;version=9771&amp;amp;cstk=jwUTY30k&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;e）插入18，插入后如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://note.youdao.com/yws/api/personal/file/WEBbda428484f3d2f4a0f9667046d90a151?method=getImage&amp;amp;version=9778&amp;amp;cstk=jwUTY30k&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当前结点的关键字个数大于5，进行分裂。分裂成两个结点，左结点2个记录，右结点3个记录，关键字16进位到父结点（索引类型）中，将当前结点的指针指向父结点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://note.youdao.com/yws/api/personal/file/WEB468f92fcf64c01e47660719a34bf704d?method=getImage&amp;amp;version=9776&amp;amp;cstk=jwUTY30k&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当前结点的关键字个数满足条件，插入结束&lt;/p&gt;
&lt;p&gt;f）插入若干数据后&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://note.youdao.com/yws/api/personal/file/WEB7cfc8c9ab4baeb20e1668a35c566beac?method=getImage&amp;amp;version=9785&amp;amp;cstk=jwUTY30k&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;g）在上图中插入7，结果如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://note.youdao.com/yws/api/personal/file/WEB9f1b4057948b1c3a02b272aa41cb240f?method=getImage&amp;amp;version=9784&amp;amp;cstk=jwUTY30k&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当前结点的关键字个数超过4，需要分裂。左结点2个记录，右结点3个记录。分裂后关键字7进入到父结点中，将当前结点的指针指向父结点，结果如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://note.youdao.com/yws/api/personal/file/WEB06e90ae0254fc57762f916910d48a087?method=getImage&amp;amp;version=9796&amp;amp;cstk=jwUTY30k&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当前结点的关键字个数超过4，需要继续分裂。左结点2个关键字，右结点2个关键字，关键字16进入到父结点中，将当前结点指向父结点，结果如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://note.youdao.com/yws/api/personal/file/WEBb39299a37fb01331ca3b5c9092d628d1?method=getImage&amp;amp;version=9797&amp;amp;cstk=jwUTY30k&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当前结点的关键字个数满足条件，插入结束。&lt;/p&gt;
&lt;h3 id=&quot;三b树的删除操作&quot;&gt;三、B+树的删除操作&lt;/h3&gt;
&lt;p&gt;如果叶子结点中没有相应的key，则删除失败。否则执行下面的步骤&lt;/p&gt;
&lt;p&gt;1）删除叶子结点中对应的key。删除后若结点的key的个数大于等于Math.ceil(m-1)/2 – 1，删除操作结束,否则执行第2步。&lt;/p&gt;
&lt;p&gt;2）若兄弟结点key有富余（大于Math.ceil(m-1)/2 – 1），向兄弟结点借一个记录，同时用借到的key替换父结（指当前结点和兄弟结点共同的父结点）点中的key，删除结束。否则执行第3步。&lt;/p&gt;
&lt;p&gt;3）若兄弟结点中没有富余的key,则当前结点和兄弟结点合并成一个新的叶子结点，并删除父结点中的key（父结点中的这个key两边的孩子指针就变成了一个指针，正好指向这个新的叶子结点），将当前结点指向父结点（必为索引结点），执行第4步（第4步以后的操作和B树就完全一样了，主要是为了更新索引结点）。&lt;/p&gt;
&lt;p&gt;4）若索引结点的key的个数大于等于Math.ceil(m-1)/2 – 1，则删除操作结束。否则执行第5步&lt;/p&gt;
&lt;p&gt;5）若兄弟结点有富余，父结点key下移，兄弟结点key上移，删除结束。否则执行第6步&lt;/p&gt;
&lt;p&gt;6）当前结点和兄弟结点及父结点下移key合并成一个新的结点。将当前结点指向父结点，重复第4步。&lt;/p&gt;
&lt;p&gt;注意，通过B+树的删除操作后，索引结点中存在的key，不一定在叶子结点中存在对应的记录。&lt;/p&gt;
&lt;p&gt;下面是一颗5阶B树的删除过程，5阶B数的结点最少2个key，最多4个key。&lt;/p&gt;
&lt;p&gt;a）初始状态&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://note.youdao.com/yws/api/personal/file/WEBd09055c76e49190a39bf26b90d8f6e0f?method=getImage&amp;amp;version=9811&amp;amp;cstk=jwUTY30k&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;b）删除22,删除后结果如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://note.youdao.com/yws/api/personal/file/WEBa2c4ee274e6f352e4a91471609730809?method=getImage&amp;amp;version=9812&amp;amp;cstk=jwUTY30k&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;删除后叶子结点中key的个数大于等于2，删除结束&lt;/p&gt;
&lt;p&gt;c）删除15，删除后的结果如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://note.youdao.com/yws/api/personal/file/WEB55c41bbd4dff0cd1112fc895f5dcc41a?method=getImage&amp;amp;version=9821&amp;amp;cstk=jwUTY30k&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;删除后当前结点只有一个key,不满足条件，而兄弟结点有三个key，可以从兄弟结点借一个关键字为9的记录,同时更新将父结点中的关键字由10也变为9，删除结束。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://note.youdao.com/yws/api/personal/file/WEB984fd82dc2e151c1fdc9f2ac66c5b164?method=getImage&amp;amp;version=9822&amp;amp;cstk=jwUTY30k&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;d）删除7，删除后的结果如下图所示&lt;br/&gt;&lt;img src=&quot;https://note.youdao.com/yws/api/personal/file/WEB75c91e97e17197a5c2c949b07781ce64?method=getImage&amp;amp;version=9829&amp;amp;cstk=jwUTY30k&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当前结点关键字个数小于2，（左）兄弟结点中的也没有富余的关键字（当前结点还有个右兄弟，不过选择任意一个进行分析就可以了，这里我们选择了左边的），所以当前结点和兄弟结点合并，并删除父结点中的key，当前结点指向父结点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://note.youdao.com/yws/api/personal/file/WEB0dd0d2c9cf0f73ab5dd3997790c07c5a?method=getImage&amp;amp;version=9831&amp;amp;cstk=jwUTY30k&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时当前结点的关键字个数小于2，兄弟结点的关键字也没有富余，所以父结点中的关键字下移，和两个孩子结点合并，结果如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://note.youdao.com/yws/api/personal/file/WEBcc70db94ec9198064abbe1a99edbcee9?method=getImage&amp;amp;version=9834&amp;amp;cstk=jwUTY30k&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;四java代码实现&quot;&gt;四、Java代码实现&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;public class BTreeNode {

    public BTreeNode parent;//父节点

    /*以升序方式存储.*/
    public List&amp;lt;Integer&amp;gt; keys;
    /*孩子*/
    public List&amp;lt;BTreeNode&amp;gt; children;

    public boolean leaf;//是否是子节点

    /*子节点中指向下一个节点.*/
    public BTreeNode next;

    public BTreeNode() {
        keys = new ArrayList&amp;lt;&amp;gt;();
        children = new ArrayList&amp;lt;&amp;gt;();
        leaf = false;
    }

    /*返回关键字个数*/
    public int size() {
        return keys.size();
    }

    //该节点中存储的索引是否包含该key值，包含则返回当前索引值，否则返回小于key值的索引
    public SearchResult searchKey(Integer key) {
        int index = Collections.binarySearch(keys, key);
        if (index &amp;gt;= 0) {
            return new SearchResult(index, true);
        } else {
            return new SearchResult(Math.abs(index + 1), false);
        }
    }

    //keys集合是升序排序，这里做了排序的动作，可以直接添加，然后对集合重新排序
    public void addKey(Integer key) {
        SearchResult searchResult = searchKey(key);
        if (!searchResult.found) {
            List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;&amp;gt;(size() + 1);
            for (int i = 0; i &amp;lt; searchResult.index; i++) {
                list.add(keys.get(i));
            }
            list.add(key);
            for (int i = searchResult.index; i &amp;lt; keys.size(); i++) {
                list.add(keys.get(i));
            }
            keys = list;
        }
    }

    //从集合中移除索引
    public void removeKey(Integer key) {
        keys.remove(key);
    }

    //获取子孩子
    public BTreeNode childAt(int index) {
        if (leaf) {
            throw new UnsupportedOperationException(&quot;Leaf node doesn't have children.&quot;);
        } else {
            return children.get(index);
        }
    }
    
    //将子孩子添加到集合末尾
    public void addChild(BTreeNode node) {
        children.add(node);
    }

    public void removeChild(int index) {
        children.remove(index);
    }

    //某个位置上的子孩子添加
    public void addChild(BTreeNode child, int index) {
        List&amp;lt;BTreeNode&amp;gt; newChildren = new ArrayList&amp;lt;&amp;gt;();
        int i = 0;
        for (; i &amp;lt; index; ++i) {
            newChildren.add(children.get(i));
        }
        newChildren.add(child);
        for (; i &amp;lt; children.size(); ++i) {
            newChildren.add(children.get(i));
        }
        children = newChildren;
    }
}

public class SearchResult {

    public int index;//索引所在集合的位置

    public boolean found;//是否找到索引

    public SearchResult() {

    }

    public SearchResult(int index, boolean found) {
        this.index = index;
        this.found = found;
    }
}

public class Result extends SearchResult {

    public BTreeNode node;//当前节点，索引值没有找到，则为要插入的节点
    
    public int parentIndex;//当前节点在父级节点的位置
     
    public Result(BTreeNode node, int index, int parentIndex, boolean found) {
        super(index, found);
        this.node = node;
        this.parentIndex = parentIndex;
    }

    public Result(BTreeNode node, int parentIndex, SearchResult searchResult) {
        super(searchResult.index, searchResult.found);
        this.node = node;
        this.parentIndex = parentIndex;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的基本定义则描述了一个节点包括其索引集合，还包括其子孩子，并且在BTreeNode中封装了一些方法，供后续调用&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class BTree {

    private static final int DEFAULT_T = 2;
    public BTreeNode root;
    /* 根据B树的定义，B树的每个非根节点的关键字数n满足(t - 1) &amp;lt;= n &amp;lt;= (2t - 1) */
    private int t = DEFAULT_T;
    /* 非根节点中最小的键值数 */
    private int minKeySize;
    /* 非根节点中最大的键值数 */
    private int maxKeySize;

    public BTree(int t /*传入b树的阶数*/) {
        this();
        this.t = t;
        minKeySize = t / 2;
        maxKeySize = t - 1;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;封装方法，找到当前索引的位置，没有找到时，则返回索引所在的节点中集合的位置，&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public Result searchLeafNode(BTreeNode node, int parentIndex, Integer key) {
        SearchResult searchResult = node.searchKey(key);
        if (node.leaf) {//子节点
            return new Result(node, parentIndex, searchResult);
        } else {
            if (searchResult.found) {
                searchResult.index++;
            }
            return searchLeafNode(node.children.get(searchResult.index), searchResult.index, key);
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;插入思路：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;找到关键字的位置，找到该节点一定是子节点。&lt;/li&gt;
&lt;li&gt;添加了关键字的节点，判断是否满了，满了则进行分裂&lt;/li&gt;
&lt;li&gt;子节点分裂时，选取中间值上升为父节点中值，但不从子节点中移除，因为子节点保存关键字的值，非子节点保存仅仅是索引&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;    public boolean insert(Integer key) {
        // 找到子节点
        Result result = searchLeafNode(root, 0, key);
        if (result.found) {//找到该节点,不操作
            return false;
        }
        BTreeNode node = result.node;
        node.addKey(key);
        //判断节点是否满了，满了则进行分割
        if (isFull(node)) {
            split(node.parent, result.parentIndex, node);
        }
        return true;
    }
    
    //进行分割
    public void split(BTreeNode parentNode, int parentIndex, BTreeNode childNode) {
        //将当前节点一份为二，小的部分将放入到新节点中，自身则成为右节点
        int mid = childNode.size() / 2;
        Integer key = null;
        boolean unLeaf = childNode.children.isEmpty();
        //判断是否为子节点，如果是子节点，索引会放入到右节点中，否则会放入到父节点中
        if (unLeaf) {
            key = childNode.keys.get(mid);
        } else {
            key = childNode.keys.remove(mid);
        }
        //分裂出左节点形成新的节点
        List&amp;lt;Integer&amp;gt; keys = new ArrayList&amp;lt;&amp;gt;();
        for (int i = 0; i &amp;lt; mid; i++) {
            Integer k = childNode.keys.remove(0);
            keys.add(k);
        }
        BTreeNode node = new BTreeNode();
        node.parent = parentNode;
        node.leaf = childNode.children.isEmpty();
        node.keys.addAll(keys);
        node.next = childNode;//节点下一个
        //将孩子节点部分也移动到新节点中
        if (!unLeaf) {
            mid = childNode.children.size() / 2;
            for (int i = 0; i &amp;lt; mid; i++) {
                BTreeNode bTreeNode = childNode.children.remove(0);
                bTreeNode.parent = node;
                node.addChild(bTreeNode);
            }
        }
        //父节点为空时，需要产生一个新节点
        if (parentNode == null) {
            root = new BTreeNode();
            root.leaf = false;
            parentNode = root;
            childNode.parent = parentNode;
            node.parent = parentNode;
            parentNode.children.add(childNode);
        }

        int index = parentNode.addKey(key);
        //前一个指针的下一个指针重新定向
        BTreeNode preNode = parentNode.children.get(parentIndex);
        preNode.next = node;
        //将节点添加到列表中
        parentNode.addChild(node, index);
        if (isFull(parentNode)) {//父节点终索引是否满了，满了，则继续分裂
            split(parentNode.parent, 0, parentNode);
        }
    }
    
    private boolean isFull(BTreeNode node) {
        return node.size() &amp;gt; maxKeySize;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;删除关键字思路：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;找到该节点，如果是为找到，直接返回&lt;/li&gt;
&lt;li&gt;找到该节点，出现一定是在子节点中，移除掉后，判断子节点的索引值是否大于最小数，大于则返回，否则需要进行合并。移除的当前节点如果出现在父节点中，也需要移除。会从子节点中选择一个节点进行补充&lt;/li&gt;
&lt;li&gt;删除后小于最小数，则先从兄弟节点借，如果兄弟节点借不出，则进行合并&lt;/li&gt;
&lt;li&gt;子节点进行合并，不需要移动子孩子&lt;/li&gt;
&lt;li&gt;父节点进行合并，需要将孩子节点移动&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;    //删除节点
    public boolean delete(Integer key) {
        //找到该节点
        Result result = searchLeafNode(root, 0, key);
        if (!result.found) {//未找到
            return false;
        }
        //删除的节点数量大于
        BTreeNode node = result.node;
        node.removeKey(key);
        if (node.keys.size() &amp;gt;= minKeySize) {
            if (node.parent.keys.contains(key)) {//父节点中包含该节点
                Integer min = node.keys.get(0);
                node.parent.removeKey(key);
                node.parent.addKey(min);
            }
            return true;
        }
        //删除节点后，不满足情况，则找兄弟节点借
        BTreeNode parent = node.parent;
        if (result.parentIndex != 0 &amp;amp;&amp;amp; parent.children.get(result.parentIndex - 1).keys.size() &amp;gt; minKeySize) {//左节点有富余可以借
            BTreeNode left = parent.children.get(result.parentIndex - 1);
            Integer max = left.keys.remove(left.keys.size() - 1);
            //替换节点
            if (parent.keys.contains(key)) {
                parent.removeKey(key);
                parent.addKey(max);
                node.addKey(max);
            } else {
                Integer min = node.keys.get(0);
                parent.removeKey(min);
                parent.addKey(max);
                node.addKey(max);
            }
        } else if (result.parentIndex &amp;lt; parent.children.size() - 1 &amp;amp;&amp;amp; parent.children.get(result.parentIndex - 1).keys.size() &amp;gt; minKeySize) {//右节点有富余可以借
            BTreeNode right = parent.children.get(result.parentIndex + 1);
            Integer min = right.keys.remove(0);
            //替换节点
            if (parent.keys.contains(key)) {
                parent.removeKey(key);
                parent.addKey(min);
                node.addKey(min);
            } else {
                Integer max = node.keys.get(node.keys.size() - 1);
                parent.removeKey(max);
                parent.addKey(min);
                node.addKey(min);
            }
        } else {
            //兄弟节点也没有，则进行合并
            node.parent.removeKey(key);
            node.parent.removeKey(node.keys.get(0));
            union(node, result.parentIndex);
        }
        return true;
    }

    public void union(BTreeNode node, int parentIndex) {
        int ch = 0;
        if (parentIndex == 0) {//当前节点是最左节点，则只能找右节点
            ch = 1;
        } else {//否则找左节点
            ch = parentIndex - 1;
        }
        BTreeNode parent = node.parent;
        if (parent == null) {
            return;
        }
        BTreeNode kNode = parent.children.get(ch);
        for (int i = 0; i &amp;lt; node.size(); i++) {
            kNode.addKey(node.keys.get(i));
        }
        parent.removeChild(parentIndex);//移除节点
        //判断上级节点
        if (parent.keys.size() &amp;lt; minKeySize) {
            union(parent);
        }
    }


    public void union(BTreeNode node) {
        if (node.parent == null) {
            return;
        }
        Integer min = node.keys.get(0);
        BTreeNode parent = node.parent;
        //找到当前节点的位置
        Integer index = -1;
        for (int i = parent.keys.size() - 1; i &amp;gt;= 0; i--) {
            if (min &amp;gt; parent.keys.get(i)) {
                index = i;
                break;
            }
        }
        Integer parentValue = null;
        if (index != -1) {
            parentValue = parent.keys.get(index);
        } else {//没有找到则表示当前节点为最左节点
            parentValue = parent.keys.get(index + 1);
        }
        if (index != -1 &amp;amp;&amp;amp; parent.children.get(index).keys.size() &amp;gt; minKeySize) {
            //判断左节点是否富余
            BTreeNode left = parent.children.get(index);
            Integer max = left.keys.get(left.size() - 1);
            parent.keys.add(index, max);
            node.addKey(parentValue);
            node.addChild(left.children.get(left.children.size() - 1), 0);
        } else if ((index == -1 &amp;amp;&amp;amp; parent.children.get(index + 2).keys.size() &amp;gt; minKeySize) || (index &amp;lt; parent.keys.size() - 1 &amp;amp;&amp;amp; parent.children.get(index + 1).keys.size() &amp;gt; minKeySize)) {
            //判断右节点是否富余
            BTreeNode right = parent.children.get(index + 1);
            Integer m = right.keys.get(0);
            parent.keys.add(index, m);
            node.addKey(parentValue);
            node.addChild(right.children.get(0));
        } else {
            //合并
            if (index == -1) {
                //合并到右节点
                BTreeNode right = parent.children.get(index + 2);
                Integer pa = parent.keys.remove(index + 1);
                right.addKey(pa);
                for (int i = 0; i &amp;lt; node.keys.size(); i++) {
                    right.addKey(node.keys.get(i));
                }
                List&amp;lt;BTreeNode&amp;gt; bTreeNodes = new ArrayList&amp;lt;&amp;gt;();
                for (int i = 0; i &amp;lt; node.children.size(); i++) {
                    bTreeNodes.add(node.children.get(i));
                }
                for (int i = 0; i &amp;lt; right.children.size(); i++) {
                    bTreeNodes.add(right.children.get(i));
                }
                right.children = bTreeNodes;
                parent.children.remove(index + 1);//移除该节点
                if (parent.keys.isEmpty()) {//节点为空
                    root = right;
                    return;
                }
            } else {
                //合并到左节点
                //找到父级节点下沉,并将该节点所有添加到左节点中
                BTreeNode left = parent.children.get(index);
                Integer max = parent.keys.remove(index.intValue());
                left.addKey(max);
                for (int i = 0; i &amp;lt; node.keys.size(); i++) {
                    left.addKey(node.keys.get(i));
                }
                for (int i = 0; i &amp;lt; node.children.size(); i++) {
                    left.children.add(node.children.get(i));
                }
                parent.children.remove(index + 1);//移除该节点
                if (parent.keys.isEmpty()) {//节点为空
                    root = left;
                    return;
                }
            }
        }
        //判断上级节点
        if (parent.keys.size() &amp;lt; minKeySize) {
            union(parent);
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;打印输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private void outPut(BTreeNode node, int index) {
        if (node.leaf) {
            List&amp;lt;Integer&amp;gt; kes = node.keys;
            System.out.println(&quot;叶子节点，层级：&quot; + index + &quot;,keys:&quot; + kes);
        } else {
            List&amp;lt;Integer&amp;gt; kes = node.keys;
            System.out.println(&quot;层级：&quot; + index + &quot;,keys:&quot; + kes);
            for (int i = 0; i &amp;lt; node.children.size(); i++) {
                outPut(node.children.get(i), index + 1);
            }
        }
    }

    public static void main(String[] args) {
        BTree tree = new BTree(5);
        tree.insert(5);
        tree.insert(8);
        tree.insert(10);
        tree.insert(15);
        tree.insert(16);
        tree.insert(17);
        tree.insert(6);
        tree.insert(9);
        tree.insert(18);
        tree.insert(19);
        tree.insert(20);
        tree.insert(21);
        tree.insert(22);
        tree.insert(7);
        tree.outPut(tree.root, 0);

        System.out.println(&quot;---------------------------------------------&quot;);

        tree.delete(22);
        tree.delete(15);
        tree.outPut(tree.root, 0);
        System.out.println(&quot;---------------------------------------------&quot;);
        tree.delete(7);
        tree.outPut(tree.root, 0);
        System.out.println(&quot;---------------------------------------------&quot;);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后的结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;层级：0,keys:[16]
层级：1,keys:[7, 10]
叶子节点，层级：2,keys:[5, 6]
叶子节点，层级：2,keys:[7, 8, 9]
叶子节点，层级：2,keys:[10, 15]
层级：1,keys:[18, 20]
叶子节点，层级：2,keys:[16, 17]
叶子节点，层级：2,keys:[18, 19]
叶子节点，层级：2,keys:[20, 21, 22]
---------------------------------------------
层级：0,keys:[16]
层级：1,keys:[7, 9]
叶子节点，层级：2,keys:[5, 6]
叶子节点，层级：2,keys:[7, 8]
叶子节点，层级：2,keys:[9, 10]
层级：1,keys:[18, 20]
叶子节点，层级：2,keys:[16, 17]
叶子节点，层级：2,keys:[18, 19]
叶子节点，层级：2,keys:[20, 21]
---------------------------------------------
层级：0,keys:[9, 16, 18, 20]
叶子节点，层级：1,keys:[5, 6, 8]
叶子节点，层级：1,keys:[9, 10]
叶子节点，层级：1,keys:[16, 17]
叶子节点，层级：1,keys:[18, 19]
叶子节点，层级：1,keys:[20, 21]&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 29 Mar 2019 15:43:00 +0000</pubDate>
<dc:creator>冰魄秋雨</dc:creator>
<og:description>一、B+树定义 B+树定义：关键字个数比孩子结点个数小1的树。 除此之外B+树还有以下的要求： 1. B+树包含2种类型的结点：内部结点（也称索引结点）和叶子结点。根结点本身即可以是内部结点，也可以是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/skyice/p/10624876.html</dc:identifier>
</item>
<item>
<title>node 中的 stream - 刘哇勇</title>
<link>http://www.cnblogs.com/Wayou/p/node_stream.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Wayou/p/node_stream.html</guid>
<description>&lt;h3&gt;什么是 stream&lt;/h3&gt;
&lt;p&gt;Stream 借鉴自 Unix 编程哲学中的 pipe。&lt;/p&gt;
&lt;p&gt;Unix shell 命令中觉的管道流式操作 &lt;code&gt;|&lt;/code&gt; 将上一个命令的输出作为下一个命令的输入。node stream 中则是通过 &lt;code&gt;.pip()&lt;/code&gt; 方法来进行的。&lt;/p&gt;
&lt;p&gt;一个 stream 的运用场景。从服务器读取文件并返回给页面。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;朴素的实现：&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;12&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; http &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;http&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;);
&lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; fs &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;fs&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;);

&lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; server &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;http&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;createServer&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;pl-smi&quot;&gt;req&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;res&lt;/span&gt;) {
    &lt;span class=&quot;pl-smi&quot;&gt;fs&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;readFile&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;__dirname&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;/data.txt&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;pl-smi&quot;&gt;err&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;data&lt;/span&gt;) {
        &lt;span class=&quot;pl-smi&quot;&gt;res&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;end&lt;/span&gt;(data);
    });
});
&lt;span class=&quot;pl-smi&quot;&gt;server&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;listen&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;8000&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;stream&lt;/code&gt; 实现：&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; http &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;http&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;);
&lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; fs &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;fs&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;);

&lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; server &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;http&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;createServer&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;pl-smi&quot;&gt;req&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;res&lt;/span&gt;) {
    &lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; stream &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;fs&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;createReadStream&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;__dirname&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;/data.txt&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;);
    &lt;span class=&quot;pl-smi&quot;&gt;stream&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;pipe&lt;/span&gt;(res);
});
&lt;span class=&quot;pl-smi&quot;&gt;server&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;listen&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;8000&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;好处：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;代码更加简洁&lt;/li&gt;
&lt;li&gt;可自由组合各种模块处理数据&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;stream 的种类&lt;/h3&gt;
&lt;p&gt;分五种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;readable&lt;/li&gt;
&lt;li&gt;writable&lt;/li&gt;
&lt;li&gt;duplex&lt;/li&gt;
&lt;li&gt;transform&lt;/li&gt;
&lt;li&gt;classic&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;readable&lt;/h4&gt;
&lt;p&gt;readable 类型的流产生数据，可通过 &lt;code&gt;.pip()&lt;/code&gt; 输送到能够消费流数据的地方，比如 writable,transform,duplex&lt;/p&gt;
&lt;p&gt;一个 readable stream 示例：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; Readable &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;stream&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;).&lt;span class=&quot;pl-smi&quot;&gt;Readable&lt;/span&gt;;

&lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; rs &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Readable&lt;/span&gt;;
&lt;span class=&quot;pl-smi&quot;&gt;rs&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;push&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;beep &lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;);
&lt;span class=&quot;pl-smi&quot;&gt;rs&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;push&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;boop&lt;span class=&quot;pl-cce&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;);
&lt;span class=&quot;pl-smi&quot;&gt;rs&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;push&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;null&lt;/span&gt;);

&lt;span class=&quot;pl-smi&quot;&gt;rs&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;pipe&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;process&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;stdout&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
$ node read0.js
beep boop
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;&lt;code&gt;_read&lt;/code&gt; 方法与按需输出&lt;/h4&gt;
&lt;p&gt;上面 &lt;code&gt;rs.push(null)&lt;/code&gt; 表示没有更多数据了。&lt;/p&gt;
&lt;p&gt;上面从代码直接将数据塞入到 readable 流中，然后被缓冲起来，直到被消费。因为消费者有可能并不能立即消费这些内容，直接 &lt;code&gt;push&lt;/code&gt; 数据后消耗不必要的资源。&lt;/p&gt;
&lt;p&gt;更好的做法是，让 readable 流只在消费者需要数据的时候再 &lt;code&gt;push&lt;/code&gt;。这是通过定义能 raedable 对象定义 &lt;code&gt;._read&lt;/code&gt; 方法来完成的。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; Readable &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;stream&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;).&lt;span class=&quot;pl-smi&quot;&gt;Readable&lt;/span&gt;;
&lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; rs &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Readable&lt;/span&gt;();

&lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; c &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;97&lt;/span&gt;;
&lt;span class=&quot;pl-smi&quot;&gt;rs&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;_read&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; () {
    &lt;span class=&quot;pl-smi&quot;&gt;rs&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;push&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;String&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;fromCharCode&lt;/span&gt;(c&lt;span class=&quot;pl-k&quot;&gt;++&lt;/span&gt;));
    &lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; (c &lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;z&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;charCodeAt&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt;)) &lt;span class=&quot;pl-smi&quot;&gt;rs&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;push&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;null&lt;/span&gt;);
};

&lt;span class=&quot;pl-smi&quot;&gt;rs&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;pipe&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;process&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;stdout&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
$ node &lt;span class=&quot;pl-smi&quot;&gt;read1&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;js&lt;/span&gt;
abcdefghijklmnopqrstuvwxyz
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这种方式下，定义了 readable 流产生数据的方法 &lt;code&gt;._read&lt;/code&gt;，但并没有马上执行并输出数据，而是在 &lt;code&gt;process.stdout&lt;/code&gt; 读取时，才调用输出的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;_read&lt;/code&gt; 方法可动态接收一个可选的 &lt;code&gt;size&lt;/code&gt; 参数，由消费方指定一次读取想要多少字节的数据，当然，&lt;code&gt;_read&lt;/code&gt; 方法的实现中是可以忽略这个入参的。&lt;/p&gt;
&lt;p&gt;下面的示例可证明 &lt;code&gt;_read&lt;/code&gt; 方法是消费方调用的时候才执行的，而不是主动执行。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;13&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; Readable &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;stream&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;).&lt;span class=&quot;pl-smi&quot;&gt;Readable&lt;/span&gt;;
&lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; rs &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Readable&lt;/span&gt;();

&lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; c &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;97&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;;

&lt;span class=&quot;pl-smi&quot;&gt;rs&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;_read&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; () {
    &lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; (c &lt;span class=&quot;pl-k&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;z&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;charCodeAt&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt;)) &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;rs&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;push&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;null&lt;/span&gt;);
    
    &lt;span class=&quot;pl-c1&quot;&gt;setTimeout&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; () {
        &lt;span class=&quot;pl-smi&quot;&gt;rs&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;push&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;String&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;fromCharCode&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;++&lt;/span&gt;c));
    }, &lt;span class=&quot;pl-c1&quot;&gt;100&lt;/span&gt;);
};

&lt;span class=&quot;pl-smi&quot;&gt;rs&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;pipe&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;process&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;stdout&lt;/span&gt;);

&lt;span class=&quot;pl-c1&quot;&gt;process&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;on&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;exit&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; () {
    &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;error&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;pl-cce&quot;&gt;\n&lt;/span&gt;_read() called &lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;+&lt;/span&gt; (c &lt;span class=&quot;pl-k&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;97&lt;/span&gt;) &lt;span class=&quot;pl-k&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt; times&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;);
});
&lt;span class=&quot;pl-c1&quot;&gt;process&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;stdout&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;on&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;error&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;process&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;exit&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;输出任意数据&lt;/h4&gt;
&lt;p&gt;上面展示的是输出简单字符串，如果需要输出其他复杂数据，初始化时设置上正确的 &lt;code&gt;objectMode&lt;/code&gt; 参数，&lt;code&gt;Readable({ objectMode: true })&lt;/code&gt;&lt;/p&gt;
&lt;h4&gt;消费 readable 流产生的数据&lt;/h4&gt;
&lt;p&gt;&lt;em&gt;这一段没看太懂&lt;/em&gt;&lt;/p&gt;
&lt;h3&gt;writable 流&lt;/h3&gt;
&lt;p&gt;writable 流可作为 &lt;code&gt;.pip()&lt;/code&gt; 的对象。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-smi&quot;&gt;src&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;pipe&lt;/span&gt;(writableStream)
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;创建 writable 流&lt;/h4&gt;
&lt;p&gt;需要实现 &lt;code&gt;._write(chunk, enc, next)&lt;/code&gt; 方法，其中：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;chunk&lt;/code&gt; 为接收到的数据&lt;/li&gt;
&lt;li&gt;&lt;code&gt;enc&lt;/code&gt; 当 &lt;code&gt;opts.decodeString&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; 且收到的数据这字符串时，它表示字符串的编码&lt;/li&gt;
&lt;li&gt;&lt;code&gt;next(err)&lt;/code&gt; 数据处理后的回调，可传递一个错误信息以表示数据处理失败&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;默认情况下，获取到的字符串数据会转为 &lt;code&gt;Buffer&lt;/code&gt;，可设置 &lt;code&gt;Writable({ decodeStrings: false })&lt;/code&gt; 来获取字符串数据。&lt;/p&gt;
&lt;p&gt;一个 writable 示例：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; Writable &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;stream&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;).&lt;span class=&quot;pl-smi&quot;&gt;Writable&lt;/span&gt;;
&lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; ws &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Writable&lt;/span&gt;();
&lt;span class=&quot;pl-smi&quot;&gt;ws&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;_write&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;pl-smi&quot;&gt;chunk&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;enc&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;next&lt;/span&gt;) {
    &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;dir&lt;/span&gt;(chunk);
    &lt;span class=&quot;pl-en&quot;&gt;next&lt;/span&gt;();
};

&lt;span class=&quot;pl-c1&quot;&gt;process&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;stdin&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;pipe&lt;/span&gt;(ws);
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;向 writable 流写入数据&lt;/h4&gt;
&lt;p&gt;通过调用 writable 流的 &lt;code&gt;write&lt;/code&gt; 方法来写入。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-c1&quot;&gt;process&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;stdout&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;write&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;beep boop&lt;span class=&quot;pl-cce&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过调用 &lt;code&gt;end()&lt;/code&gt; 来结束数据的写入。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; fs &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;fs&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;);
&lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; ws &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;fs&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;createWriteStream&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;message.txt&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;);

&lt;span class=&quot;pl-smi&quot;&gt;ws&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;write&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;beep &lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;);

&lt;span class=&quot;pl-c1&quot;&gt;setTimeout&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; () {
    &lt;span class=&quot;pl-smi&quot;&gt;ws&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;end&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;boop&lt;span class=&quot;pl-cce&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;);
}, &lt;span class=&quot;pl-c1&quot;&gt;1000&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;duplex&lt;/h3&gt;
&lt;p&gt;双工类型的流，同时具有 writable 和 readable 流的功能。node 内建的 &lt;code&gt;zlib&lt;/code&gt;,&lt;code&gt;TCP sockets&lt;/code&gt; 以及 &lt;code&gt;crypto&lt;/code&gt; 都是双工类型的。&lt;/p&gt;
&lt;p&gt;所以可对双工类型的流进行如下操作：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-smi&quot;&gt;a&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;pip&lt;/span&gt;(b).&lt;span class=&quot;pl-en&quot;&gt;pip&lt;/span&gt;(a)
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;transform&lt;/h3&gt;
&lt;p&gt;一种特殊类型的双工流，区别在于 transform 类型其输出是输入的转换。跟它的名字一样，这里面对数据进行一些转换后输出。比如，通过 &lt;code&gt;zlib.createGzip&lt;/code&gt; 来对数据进行 gzip 的压缩。有时候也将这种类型的流称为 &lt;code&gt;through steam&lt;/code&gt;。&lt;/p&gt;
&lt;h3&gt;classic stream&lt;/h3&gt;
&lt;p&gt;这里指使用旧版 api 的流。当一个流身上绑定了 &lt;code&gt;data&lt;/code&gt; 事件的监听时，便会回退为经典旧版的流。&lt;/p&gt;
&lt;h4&gt;classic readable stream&lt;/h4&gt;
&lt;p&gt;当有数据时它会派发 &lt;code&gt;data&lt;/code&gt; 事件，数据输出结束时派发 &lt;code&gt;end&lt;/code&gt; 事件给消费者。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;.pipe()&lt;/code&gt; 通过检查 &lt;code&gt;stream.readable&lt;/code&gt; 以判断该流是否是 readable 类型。&lt;/p&gt;
&lt;h4&gt;classic readable 流的创建&lt;/h4&gt;
&lt;p&gt;一个 classic readable 流的创建示例：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;11&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; Stream &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;stream&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;);
&lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; stream &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Stream&lt;/span&gt;;
&lt;span class=&quot;pl-smi&quot;&gt;stream&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;readable&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;true&lt;/span&gt;;

&lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; c &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;64&lt;/span&gt;;
&lt;span class=&quot;pl-k&quot;&gt;var&lt;/span&gt; iv &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;setInterval&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; () {
    &lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;pl-k&quot;&gt;++&lt;/span&gt;c &lt;span class=&quot;pl-k&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;75&lt;/span&gt;) {
        &lt;span class=&quot;pl-c1&quot;&gt;clearInterval&lt;/span&gt;(iv);
        &lt;span class=&quot;pl-smi&quot;&gt;stream&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;emit&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;end&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;);
    }
    &lt;span class=&quot;pl-k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;stream&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;emit&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;data&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class=&quot;pl-c1&quot;&gt;String&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;fromCharCode&lt;/span&gt;(c));
}, &lt;span class=&quot;pl-c1&quot;&gt;100&lt;/span&gt;);

&lt;span class=&quot;pl-smi&quot;&gt;stream&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;pipe&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;process&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;stdout&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;从 classic readable 流读取数据&lt;/h4&gt;
&lt;p&gt;数据读取是通过监听流上的 &lt;code&gt;data&lt;/code&gt; 与 &lt;code&gt;end&lt;/code&gt; 事件。&lt;/p&gt;
&lt;p&gt;一个从 classic readable 流读取数据的示例：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-c1&quot;&gt;process&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;stdin&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;on&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;data&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;pl-smi&quot;&gt;buf&lt;/span&gt;) {
    &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(buf);
});
&lt;span class=&quot;pl-c1&quot;&gt;process&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;stdin&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;on&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;end&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; () {
    &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;__END__&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;);
});
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;一般不建议通过这种方式来操作，一旦给流绑定 &lt;code&gt;data&lt;/code&gt; 事件处理器，即回退到旧的 api 来使用流。如果真的有兼容操作旧版流的需求，应该通过 &lt;a href=&quot;https://www.npmjs.com/package/through&quot; rel=&quot;nofollow&quot;&gt;through&lt;/a&gt; 或 &lt;a href=&quot;https://npmjs.org/package/concat-stream&quot; rel=&quot;nofollow&quot;&gt;concat-stream&lt;/a&gt; 来进行。&lt;/p&gt;
&lt;h4&gt;classic writable stream&lt;/h4&gt;
&lt;p&gt;只需要实现 &lt;code&gt;.write(buf)&lt;/code&gt;, &lt;code&gt;.end(buf)&lt;/code&gt; 及 &lt;code&gt;.destroy()&lt;/code&gt; 方法即可，比较简单。&lt;/p&gt;
&lt;h3&gt;内建的流对象&lt;/h3&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;https://user-images.githubusercontent.com/3783096/51087824-f1266480-1792-11e9-9736-e86055590997.png&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/3783096/51087824-f1266480-1792-11e9-9736-e86055590997.png&quot; alt=&quot;image&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;总结&lt;/h3&gt;
&lt;p&gt;本质上，所有流都是 &lt;code&gt;EventEmitter&lt;/code&gt;，通过事件可写入和读取数据。但通过新的 stream api，可方便地通过 &lt;code&gt;.pipe()&lt;/code&gt; 方法来使用流而不是事件的方式。&lt;/p&gt;
&lt;h3&gt;参考&lt;/h3&gt;
</description>
<pubDate>Fri, 29 Mar 2019 15:30:00 +0000</pubDate>
<dc:creator>刘哇勇</dc:creator>
<og:description>什么是 stream Stream 借鉴自 Unix 编程哲学中的 pipe。 Unix shell 命令中觉的管道流式操作 | 将上一个命令的输出作为下一个命令的输入。node stream 中则是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Wayou/p/node_stream.html</dc:identifier>
</item>
<item>
<title>C#并行编程（4）：基于任务的并行 - LayShun</title>
<link>http://www.cnblogs.com/chenbaoshun/p/10621819.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenbaoshun/p/10621819.html</guid>
<description>&lt;h2 id=&quot;c中的任务task&quot;&gt;C#中的任务&lt;code&gt;Task&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;在C#编程中，实现并行可以直接使用线程，但使用起来很繁琐；也可以使用线程池，线程池很大程度上简化了线程的使用，但是也有着一些局限，比如我们不知道作业什么时候完成，也取不到作业的返回值；解决线程池局限性的方案是使用&lt;code&gt;任务&lt;/code&gt;。本文将总结C#中&lt;code&gt;Task&lt;/code&gt;的使用。&lt;/p&gt;
&lt;p&gt;类似于线程池工作项对异步操作的封装，任务是对异步操作的另一种形式的封装，这种封装抽象层次更高，让我们能够对异步操作进行更多的控制。&lt;/p&gt;
&lt;p&gt;任务启动后，通过任务调度器&lt;code&gt;TaskScheduler&lt;/code&gt;来调度。.NET中提供两种任务调度器，一种是线程池任务调度器，也是默认调度器，它会将任务派发给线程池工作者线程；另一种是上下文同步任务调度器，它会将任务派发给当前上下文线程，例如GUI线程。此外，我们也能自定义任务调度器，例如可以将异步IO任务派发给线程池IO线程。&lt;/p&gt;
&lt;h2 id=&quot;task的使用方法&quot;&gt;Task的使用方法&lt;/h2&gt;
&lt;h3 id=&quot;隐式使用&quot;&gt;隐式使用&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Parallel&lt;/code&gt;静态类除了提供并行循环的各种重载，还提供了一个方法&lt;code&gt;Parallel.Invoke&lt;/code&gt;。这个方法可以创建并执行一个或多个异步任务，使用方法如下：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// 任务模拟
/// &amp;lt;/summary&amp;gt;
private static void DoWork(int workId = 0)
{
    Console.WriteLine($&quot;{DateTime.Now}=&amp;gt; Thread[{Thread.CurrentThread.ManagedThreadId}] started work[{workId}].&quot;);
    Thread.Sleep(3000);
    Console.WriteLine($&quot;{DateTime.Now}=&amp;gt; Thread[{Thread.CurrentThread.ManagedThreadId}] done work[{workId}].&quot;);
}

/// &amp;lt;summary&amp;gt;
/// 任务的隐式使用
/// &amp;lt;/summary&amp;gt;
public static void ImplicitUsingOfTask()
{
    Parallel.Invoke(()=&amp;gt;DoWork(1),()=&amp;gt;DoWork(2),() =&amp;gt; DoWork(3));
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上例的运行结果如下：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;2019/3/27 20:40:18=&amp;gt; Thread[9] started work[1].&lt;br/&gt;2019/3/27 20:40:18=&amp;gt; Thread[12] started work[3].&lt;br/&gt;2019/3/27 20:40:18=&amp;gt; Thread[10] started work[2].&lt;br/&gt;2019/3/27 20:40:21=&amp;gt; Thread[9] done work[1].&lt;br/&gt;2019/3/27 20:40:21=&amp;gt; Thread[12] done work[3].&lt;br/&gt;2019/3/27 20:40:21=&amp;gt; Thread[10] done work[2].&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于简单的多任务并行，使用上述的方式很方便，但是这种方式与线程池一样，我们不能控制任务的执行或者获取任务返回值。&lt;/p&gt;
&lt;h3 id=&quot;显式使用&quot;&gt;显式使用&lt;/h3&gt;
&lt;p&gt;相对于使用&lt;code&gt;Parallel.Invoke&lt;/code&gt;执行并行操作，更常用的是使用&lt;code&gt;Task&lt;/code&gt;和&lt;code&gt;Task&amp;lt;T&amp;gt;&lt;/code&gt;提供的方法进行异步和并行处理。下面是任务最基本的使用：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;Task.Run(() =&amp;gt;
{
    //TODO
});
Task.Factory.StartNew(() =&amp;gt;
{
    //TODO
});&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;任务的常用操作&quot;&gt;任务的常用操作&lt;/h2&gt;
&lt;h3 id=&quot;获取任务的返回值&quot;&gt;获取任务的返回值&lt;/h3&gt;
&lt;p&gt;具有返回值的任务使用&lt;code&gt;Task&amp;lt;T&amp;gt;&lt;/code&gt;,&lt;code&gt;T&lt;/code&gt;可根据我们的需求指定，下面是获取任务返回值的方法。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;Task&amp;lt;int&amp;gt; task = Task&amp;lt;int&amp;gt;.Factory.StartNew(() =&amp;gt;
{
    Thread.Sleep(3000);//模拟操作用时
    return DateTime.Now.Day;
});
int day = task.Result;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要说明的是，获取任务的结果会阻塞当前线程。&lt;/p&gt;
&lt;h3 id=&quot;等待任务完成&quot;&gt;等待任务完成&lt;/h3&gt;
&lt;p&gt;有时候，我们需要等待一些任务全部完成后才能执行后续操作，有时候只要多个任务中的一个完成了，就可以执行后续操作。&lt;code&gt;Task&lt;/code&gt;提供了&lt;code&gt;Wait&lt;/code&gt;、&lt;code&gt;WaitAll&lt;/code&gt;和&lt;code&gt;WaitAny&lt;/code&gt;等方法满足我们的需求。下面的例子展示了各种等待方法的使用。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// 任务等待测试
/// &amp;lt;/summary&amp;gt;
public static void TaskWait()
{
    Stopwatch watch = new Stopwatch();

    #region 场景1：等待一个任务完成
    Task task = Task.Run(() =&amp;gt; DoWorkOfTask(1000));
    Console.WriteLine(&quot;start wait. work duration: 1000&quot;);
    watch.Start();
    task.Wait();//等待1秒左右
    watch.Stop();
    Console.WriteLine($&quot;end wait. time: {watch.ElapsedMilliseconds}&quot;);
    #endregion

    #region 场景2：等待多个任务完成
    Task[] tasks = new Task[3]
    {
        Task.Run(() =&amp;gt; DoWorkOfTask(1000)),
        Task.Run(() =&amp;gt; DoWorkOfTask(2000)),
        Task.Run(() =&amp;gt; DoWorkOfTask(3000)),
    };

    Console.WriteLine(&quot;start wait all. work duration: min 1000 max 3000.&quot;);
    watch.Restart();
    Task.WaitAll(tasks);//等待3秒左右
    watch.Stop();
    Console.WriteLine($&quot;end wait. time: {watch.ElapsedMilliseconds}&quot;);
    #endregion

    #region 场景3：等待某个任务完成
    tasks = new Task[3]
    {
        Task.Run(() =&amp;gt; DoWorkOfTask(1000)),
        Task.Run(() =&amp;gt; DoWorkOfTask(2000)),
        Task.Run(() =&amp;gt; DoWorkOfTask(3000)),
    };
    Console.WriteLine(&quot;start wait any. work duration: min 1000 max 3000.&quot;);
    watch.Restart();
    Task.WaitAny(tasks);//等待1秒左右
    watch.Stop();
    Console.WriteLine($&quot;end wait. time: {watch.ElapsedMilliseconds}&quot;);
    #endregion
}

/// &amp;lt;summary&amp;gt;
/// 做任务
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;param name=&quot;workDuration&quot;&amp;gt;任务时长&amp;lt;/param&amp;gt;
private static void DoWorkOfTask(int workDuration)
{
    Console.WriteLine($&quot;{DateTime.Now}=&amp;gt; Thread[{Thread.CurrentThread.ManagedThreadId}] started task[{Task.CurrentId}].&quot;);
    Thread.Sleep(workDuration);
    Console.WriteLine($&quot;{DateTime.Now}=&amp;gt; Thread[{Thread.CurrentThread.ManagedThreadId}] completed task[{Task.CurrentId}].&quot;);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用&lt;code&gt;Wait&lt;/code&gt;、&lt;code&gt;WaitAll&lt;/code&gt;和&lt;code&gt;WaitAny&lt;/code&gt;方法时，我们可以设置超时时间或者传入取消Token，以控制等待时间。但这些方法返回布尔值，只能表明是否等待成功；假如我们需要知道所等待的任务返回值，则可以使用&lt;code&gt;WhenAll&lt;/code&gt;或&lt;code&gt;WhenAny&lt;/code&gt;方法，这两个方法不能控制等待时间，但会返回一个完成的任务。如下例：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;Task&amp;lt;int&amp;gt;[] tasks = new Task&amp;lt;int&amp;gt;[3]
{
    Task&amp;lt;int&amp;gt;.Factory.StartNew(() =&amp;gt;
    {
        Console.WriteLine($&quot;task #{Task.CurrentId} run&quot;);
        Thread.Sleep(100);
        Console.WriteLine($&quot;task #{Task.CurrentId} done&quot;);
        return 100;
    }),
    Task&amp;lt;int&amp;gt;.Factory.StartNew(() =&amp;gt;
    {
        Console.WriteLine($&quot;task #{Task.CurrentId} run&quot;);
        Thread.Sleep(500);
        Console.WriteLine($&quot;task #{Task.CurrentId} done&quot;);
        return 1000;
    }),
    Task&amp;lt;int&amp;gt;.Factory.StartNew(() =&amp;gt;
    {
        Console.WriteLine($&quot;task #{Task.CurrentId} run&quot;);
        Thread.Sleep(1000);
        Console.WriteLine($&quot;task #{Task.CurrentId} done&quot;);
        return 10000;
    }),
};

//int[] results = Task.WhenAll(tasks).Result;
//Console.WriteLine($&quot;[{string.Join(&quot;,&quot;,results)}]&quot;);

Task&amp;lt;int&amp;gt; task = Task.WhenAny(tasks).Result;
Console.WriteLine($&quot;task #{task.Id}. result {task.Result}&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Task.WhenAll&lt;/code&gt; 和&lt;code&gt;Task.WhenAny&lt;/code&gt;在等待结束时，都会创建一个完成状态的任务，&lt;code&gt;WhenAll&lt;/code&gt;将等待的所有已完成任务的结果放入创建任务的结果中，&lt;code&gt;WhenAny&lt;/code&gt;则将等待的已完成任务放到创建任务的结果中。&lt;/p&gt;
&lt;h3 id=&quot;任务延续&quot;&gt;任务延续&lt;/h3&gt;
&lt;p&gt;有时候，我们需要在一个任务完成时开始另一个任务。对于这种需求，我们可以使用&lt;code&gt;Task&lt;/code&gt;的&lt;code&gt;ContinueWith&lt;/code&gt;等方法来处理。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;Task task = Task.Run(() =&amp;gt; DoWorkOfTask(3000));
task.ContinueWith(t =&amp;gt; DoWorkOfTask(1000));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;2019/3/27 21:25:09=&amp;gt; Thread[10] started task[1].&lt;/p&gt;&lt;p&gt;2019/3/27 21:25:12=&amp;gt; Thread[10] completed task[1].&lt;/p&gt;&lt;p&gt;2019/3/27 21:25:12=&amp;gt; Thread[11] started task[2].&lt;/p&gt;&lt;p&gt;2019/3/27 21:25:13=&amp;gt; Thread[11] completed task[2].&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们还可以通过&lt;code&gt;TaskContinuationOptions&lt;/code&gt;指定延续任务的执行条件，如任务取消时或者任务出现异常时才执行，等。&lt;/p&gt;
&lt;h3 id=&quot;子任务的使用&quot;&gt;子任务的使用&lt;/h3&gt;
&lt;p&gt;有时候，我们要在一个任务里面创建一些其他任务，并且还要在任务里面等待创建的任务完成，此时我们可以使用子任务。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;Task parent = Task.Factory.StartNew(() =&amp;gt;
{
    Console.WriteLine($&quot;parent task #{Task.CurrentId} run.&quot;);
    for (int i = 0; i &amp;lt; 10; i++)
    {
        Task.Factory.StartNew(() =&amp;gt;
        {
            Console.WriteLine($&quot;child task #{Task.CurrentId} run.&quot;);
            Thread.Sleep(1000);
            Console.WriteLine($&quot;child task #{Task.CurrentId} done.&quot;);
        }, TaskCreationOptions.AttachedToParent);
    }
});
parent.Wait();
Console.WriteLine($&quot;parent task #{parent.Id} done.&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在一个任务中创建的新任务，默认情况下与父级任务是分离的，各自的运行不受影响，除非在创建任务时显式附加到父级任务中。例如，上例中如果不指定&lt;code&gt;TaskCreationOptions.AttachedToParent&lt;/code&gt;,&lt;code&gt;parent.Wait()&lt;/code&gt;就不会持续到所有子任务都执行完成。&lt;/p&gt;
&lt;h3 id=&quot;任务的取消&quot;&gt;任务的取消&lt;/h3&gt;
&lt;p&gt;我们在启动任务时，传入取消令牌&lt;code&gt;CancellationToken&lt;/code&gt;，当收到取消请求时，抛出取消异常并在等待任务完成时捕获异常&lt;code&gt;TaskCanceledException&lt;/code&gt;。我们通过这种方式控制任务的取消。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// 任务取消
/// &amp;lt;/summary&amp;gt;
public static void TaskCancle()
{
    Console.WriteLine(&quot;Press any key to begin. Press 'c' to cancel. &quot;);
    Console.ReadKey(true);
    Console.WriteLine();

    CancellationTokenSource tokenSource = new CancellationTokenSource();
    ConcurrentBag&amp;lt;Task&amp;gt; tasks = new ConcurrentBag&amp;lt;Task&amp;gt;();
    //单任务取消
    Task task1 = Task.Factory.StartNew(() =&amp;gt; DoWorkOfTask(5000, tokenSource.Token), tokenSource.Token);
    tasks.Add(task1);

    //嵌套任务取消
    Task task2 = Task.Factory.StartNew(() =&amp;gt;
    {
        for (int i = 0; i &amp;lt; 10; i++)
        {
            int duration = 1000 * i;
            tasks.Add(Task.Factory.StartNew(()=&amp;gt;DoWorkOfTask(duration, tokenSource.Token), tokenSource.Token));
        }
        DoWorkOfTask(5000,tokenSource.Token);
    }, tokenSource.Token);
    tasks.Add(task2);

    char ch = Console.ReadKey().KeyChar;
    if (ch == 'c' || ch == 'C')
    {
        tokenSource.Cancel();
        Console.WriteLine($&quot;{DateTime.Now}=&amp;gt; Task cancellation requested.&quot;);
    }

    try
    {
        Task.WaitAll(tasks.ToArray());
    }
    catch (AggregateException ae)
    {
        foreach (Exception ex in ae.InnerExceptions)
        {//任务取消通过抛出TaskCanceledException实现
            TaskCanceledException tce = ex as TaskCanceledException;
            string cancelledTask = tce == null ? string.Empty : $&quot;Task #{tce.Task.Id}&quot;;
            Console.WriteLine($&quot;Exception: {ex.GetType().Name}. {cancelledTask}&quot;);
        }
    }
    finally
    {
        tokenSource.Dispose();
    }

    Console.WriteLine();
    //显示任务状态
    foreach (Task task in tasks)
    {
        Console.WriteLine($&quot;Task: #{task.Id} now is {task.Status}&quot;);
    }
}

/// &amp;lt;summary&amp;gt;
/// 带取消令牌的作业
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;param name=&quot;workDuration&quot;&amp;gt;作业时长&amp;lt;/param&amp;gt;
/// &amp;lt;param name=&quot;cancleToken&quot;&amp;gt;取消令牌&amp;lt;/param&amp;gt;
private static void DoWorkOfTask(int workDuration, CancellationToken cancleToken)
{
    if (cancleToken.IsCancellationRequested)
    {//开始之前取消
        Console.WriteLine($&quot;{DateTime.Now}=&amp;gt; Task #{Task.CurrentId} was cancelled before it got started.&quot;);
        cancleToken.ThrowIfCancellationRequested();
    }

    Console.WriteLine($&quot;{DateTime.Now}=&amp;gt; Thread[{Thread.CurrentThread.ManagedThreadId}] started task #{Task.CurrentId}.&quot;);
    Thread.Sleep(workDuration);

    if (cancleToken.IsCancellationRequested)
    {//开始之后取消
        Console.WriteLine($&quot;{DateTime.Now}=&amp;gt; Task #{Task.CurrentId} was cancelled.&quot;);
        cancleToken.ThrowIfCancellationRequested();
    }
    Console.WriteLine($&quot;{DateTime.Now}=&amp;gt; Thread[{Thread.CurrentThread.ManagedThreadId}] completed task #{Task.CurrentId}.&quot;);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;任务的异常处理&quot;&gt;任务的异常处理&lt;/h2&gt;
&lt;p&gt;上面提到通过取消令牌抛出&lt;code&gt;TaskCanceledException&lt;/code&gt;的方式控制任务的取消，实际上，Task会把自身执行过程中的所有异常都包装到一个&lt;code&gt;AggregateException&lt;/code&gt;中,并传回调用线程。我们在主线程中通过捕获&lt;code&gt;AggregateException&lt;/code&gt;来进行异常处理。&lt;/p&gt;
&lt;h3 id=&quot;简单的处理方式&quot;&gt;简单的处理方式&lt;/h3&gt;
&lt;p&gt;我们可以在任务的调用线程捕获并遍历&lt;code&gt;AggregateException&lt;/code&gt;的内部异常，或者使用&lt;code&gt;AggregateException&lt;/code&gt;提供的Handle方法进行处理，如下：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;Task task = Task.Run(() =&amp;gt;
{
    throw new Exception($&quot;Task #{Task.CurrentId} thrown an exception&quot;);
});
try
{
    task.Wait();
}
catch (AggregateException ae)
{
    //处理方式1：遍历内部异常进行处理
    foreach (Exception ex in ae.InnerExceptions)
    {
        Console.WriteLine($&quot;foreach: {ex.Message}&quot;);
    }

    //处理方式2：使用AggregateException的Handle方法
    ae.Handle(ex=&amp;gt;
    {
        Console.WriteLine($&quot;handle: {ex.Message}&quot;);
        return true ;
    });
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;使用延续任务处理任务的异常&quot;&gt;使用延续任务处理任务的异常&lt;/h3&gt;
&lt;p&gt;有时候，我们可以给任务附加一个任务异常时才会执行的延续任务，并在延续任务中进行异常处理。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;Task.Run(() =&amp;gt; { throw new Exception($&quot;Task #{Task.CurrentId} thrown an exception&quot;); })
    .ContinueWith(t =&amp;gt;
    {
        Console.WriteLine($&quot;{t.Exception?.InnerException?.Message}&quot;);
    }, TaskContinuationOptions.OnlyOnFaulted);&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;嵌套任务的异常处理&quot;&gt;嵌套任务的异常处理&lt;/h3&gt;
&lt;p&gt;下面是一个3层嵌套的任务。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;Task parent = Task.Factory.StartNew(() =&amp;gt;
{//父级任务
    for (int i = 0; i &amp;lt; 10; i++)
    {
        Task.Factory.StartNew(() =&amp;gt;
        {//1代子任务
            for (int j = 0; j &amp;lt; 10; j++)
            {
                Task.Factory.StartNew(() =&amp;gt;
                {//2代子任务
                    throw new Exception($&quot;Task #{Task.CurrentId} thrown an exception. &quot;);
                }/*, TaskCreationOptions.AttachedToParent*/);
            }

            throw new Exception($&quot;Task #{Task.CurrentId} thrown an exception. &quot;);
        }/*, TaskCreationOptions.AttachedToParent*/);
    }

    throw new Exception($&quot;Task #{Task.CurrentId} thrown an exception. &quot;);
});
try
{
    parent.Wait();
}
catch (AggregateException ae)
{
    ae.Flatten().Handle(ex =&amp;gt;
    {
        Console.WriteLine(ex.Message);
        return true;
    });
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行上面的代码只会得到一行输出：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Task #1 thrown an exception.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;看起来有点奇怪，为什么只捕获到一个异常呢？其实也是在情理之中的：&lt;strong&gt;任务默认只会把自身异常传递到它自己的调用线程&lt;/strong&gt;，子任务是在父任务中调用的，其异常只会传递到父任务的执行线程，所以我们在父任务的调用线程，也就是我们的主线程中是捕获不到子任务的异常的。&lt;/p&gt;
&lt;p&gt;取消上面代码的两处&lt;code&gt;/*, TaskCreationOptions.AttachedToParent*/&lt;/code&gt;，就会捕获到所有异常。&lt;/p&gt;
&lt;h2 id=&quot;任务调度器&quot;&gt;任务调度器&lt;/h2&gt;
&lt;h3 id=&quot;net提供的任务调度器&quot;&gt;.NET提供的任务调度器&lt;/h3&gt;
&lt;p&gt;任务是由&lt;code&gt;TaskScheduler&lt;/code&gt;调度的，启动任务时，默认使用线程池任务调度器，任务将会被派发到线程池工作线程。线程池的调度前面已经总结过，这里不再展开。.NET提供的另一种任务调度器是同步上下文调度器，用&lt;code&gt;TaskScheduler.FromCurrentSynchronizationContext()&lt;/code&gt;获取，这个调度器会把任务派发给当前的上下文线程，常用在GUI应用程序中。&lt;/p&gt;
&lt;p&gt;例如，我们在一个窗体中新建一个ListBox,新建几个任务向其中添加项，代码如下：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;this.lbxMsg.Items.Add($&quot;{DateTime.Now:O}=&amp;gt;Current thread is thread #{Thread.CurrentThread.ManagedThreadId} .&quot;);
for (int i = 0; i &amp;lt; 10; i++)
{
    new Task(() =&amp;gt;
    {
        for (int j = 0; j &amp;lt; 3; j++)
        {
            this.lbxMsg.Items.Add($&quot;{DateTime.Now:O}=&amp;gt; Task #{Task.CurrentId} add an item with thread #{Thread.CurrentThread.ManagedThreadId}.&quot;);
        }
                        
    }).Start(TaskScheduler.FromCurrentSynchronizationContext());
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行上面的代码可以发现创建的任务都是由界面线程执行的。这里如果使用默认的任务调度器将产生&lt;strong&gt;&quot;线程间操作无效&quot;&lt;/strong&gt;的异常。&lt;/p&gt;
&lt;p&gt;实际使用时，可以给一个异步任务添加延续任务，来处理异步任务的结果或者异常等。如下：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;Task.Run(() =&amp;gt;
{
    Thread.Sleep(3000); // 模拟操作过程
    return 1000; // 模拟结果
}).ContinueWith(t =&amp;gt;
{
    this.lbxMsg.Items.Add(t.Result); // 在界面呈现结果或做其他处理
}, TaskScheduler.FromCurrentSynchronizationContext());&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;自定义任务调度器&quot;&gt;自定义任务调度器&lt;/h3&gt;
&lt;p&gt;除了使用.NET提供的调度器外，我们能够继承类&lt;code&gt;TaskScheduler&lt;/code&gt;来实现自己的任务调度器。这里不再展开，需要了解的可以参考&lt;a href=&quot;https://code.msdn.microsoft.com/Samples-for-Parallel-b4b76364&quot; title=&quot;.NET Framework并行编程示例&quot;&gt;Samples for Parallel Programming with the .NET Framework&lt;/a&gt;。&lt;/p&gt;
</description>
<pubDate>Fri, 29 Mar 2019 14:40:00 +0000</pubDate>
<dc:creator>LayShun</dc:creator>
<og:description>C 中的任务 在C 编程中，实现并行可以直接使用线程，但使用起来很繁琐；也可以使用线程池，线程池很大程度上简化了线程的使用，但是也有着一些局限，比如我们不知道作业什么时候完成，也取不到作业的返回值；解</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenbaoshun/p/10621819.html</dc:identifier>
</item>
<item>
<title>Spring Boot 解决方案 - 会话 - 霖哲煌</title>
<link>http://www.cnblogs.com/linzhehuang/p/10624634.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/linzhehuang/p/10624634.html</guid>
<description>&lt;p&gt;使用 HTTP 的连接是无状态的，因此为了应对需要状态的服务例如用户登录，诞生了适合保存状态的设计-会话（session），本文就来探讨一下会话。&lt;/p&gt;

&lt;p&gt;Spring Mvc 中使用会话很简单，在控制器类的方法参数列表中，直接编写 &lt;code&gt;HttpSession&lt;/code&gt; 类型的参数，或者参数列表中编写 &lt;code&gt;HttpServletRequest&lt;/code&gt; 类，然后使用 &lt;code&gt;getSession()&lt;/code&gt; 方法获取会话。&lt;/p&gt;
&lt;p&gt;下面是使用会话的简单例子，第一次访问时会创建一个无数据的会话，因此获取到的 &lt;code&gt;access&lt;/code&gt; 属性为 null ，而当不是第一次访问时，由于属性不为 null 会得到 &quot;NOT THE FIRST TIME ACCESS&quot; 。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@RestController
public class DemoController {
    private static final String ACCESS = &quot;access&quot;;
    @RequestMapping(&quot;/&quot;)
    public String index(HttpSession session) { // or `index(HttpServletRequest req)`
        // then `HttpSession session = request.getSession();`
        if (session.getAttribute(ACCESS) == null) {
            session.setAttribute(ACCESS, true);
            return &quot;FIRST TIME ACCESS&quot;;
        }
        return &quot;NOT THE FIRST TIME ACCESS&quot;;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：由于用 Mock Mvc 测试获取不到第一次请求 Cookies，因此无法模拟得到正确结果，请使用浏览器或者请求工具测试。&lt;/p&gt;
&lt;h2 id=&quot;常用方法&quot;&gt;常用方法&lt;/h2&gt;
&lt;p&gt;上面例子展示了会话的简单使用，其中 &lt;code&gt;HttpSession&lt;/code&gt; 接口是 servlet 的标准，而 Spring Mvc 中的会话默认使用 Tomcat 的实现。下面来介绍几个常用方法，更多方法使用请参考这篇&lt;a href=&quot;https://www.cnblogs.com/haimishasha/p/5609261.html#a2.15&quot;&gt;文章&lt;/a&gt;。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Object getAttribute(String)&lt;/code&gt; 方法用来获取会话的属性，若不存在则返回 null&lt;/li&gt;
&lt;li&gt;&lt;code&gt;void setAttribute(String, Object)&lt;/code&gt; 方法用来设置会话的属性&lt;/li&gt;
&lt;li&gt;&lt;code&gt;void removeAttribute(String)&lt;/code&gt; 方法用来删除会话的属性&lt;/li&gt;
&lt;li&gt;&lt;code&gt;void setMaxInactiveInterval(int)&lt;/code&gt; 方法用来设置会话失效时间，单位为秒，设置小于等于零的数则会话永不过期&lt;/li&gt;
&lt;li&gt;&lt;code&gt;void invalidate()&lt;/code&gt; 手动使会话失效并清理会话数据&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;会话的生命周期分别为创建、失效和创建与失效之间，而会话监听器是为了满足会话生命周期中触发相应事件的需要，&lt;code&gt;HttpSessionListener&lt;/code&gt; 和 &lt;code&gt;HttpSessionBindingListener&lt;/code&gt; 两个监听器接口分别满足了会话的各个生命周期。使用监听器只需实现这些接口然后标注 &lt;code&gt;@WebListener&lt;/code&gt; 注解即可，下面会有实现的例子。&lt;/p&gt;
&lt;h2 id=&quot;针对会话的监听器&quot;&gt;针对会话的监听器&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;HttpSessionListener&lt;/code&gt; 接口可以算是针对会话的监听器接口，因为它的两个方法分别在会话创建和失效时调用，下面为一个简单的例子，参数列表中 &lt;code&gt;HttpSessionEvent&lt;/code&gt; 类可以用 &lt;code&gt;getSession&lt;/code&gt; 获取会话。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@WebListener
public class SessionListener implements HttpSessionListener {
    public void sessionCreated(HttpSessionEvent event) {
        // ...
    }
    public void sessionDestroyed(HttpSessionEvent event) {
        // ...
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;针对会话属性的监听器&quot;&gt;针对会话属性的监听器&lt;/h2&gt;
&lt;p&gt;与 &lt;code&gt;HttpSessionListener&lt;/code&gt; 监听器接口接管会话生命周期的创建与失效不同，&lt;code&gt;HttpSessionBindingListener&lt;/code&gt; 监听器接口负责&lt;strong&gt;会话属性的创建与销毁&lt;/strong&gt;，下面为该监听器的简单例子，参数列表中 &lt;code&gt;HttpSessionBindingEvent&lt;/code&gt; 类除了可以用 &lt;code&gt;getSession&lt;/code&gt; 获取会话，最主要的是可用 &lt;code&gt;getName&lt;/code&gt; 和 &lt;code&gt;getValue&lt;/code&gt; 分别获取属性的名字和值。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@WebListener
public class SessionListener implements HttpSessionBindingListener {
    public void valueBound(HttpSessionBindingEvent event) {
        // ...
    }
    
    public void valueUnbound(HttpSessionBindingEvent event) {
        // ...
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;使监听器生效&quot;&gt;使监听器生效&lt;/h2&gt;
&lt;p&gt;上面的例子只是编写了监听器的实现，为了使得监听器在项目里生效，还必须在启动类或者配置类上标注 &lt;code&gt;@ServletComponentScan&lt;/code&gt; 来扫描这些&lt;strong&gt;属于 servlet 组件的监听器&lt;/strong&gt;，例如下面在配置类上启动 servlet 组件扫描。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Configuration
@ServletComponentScan  // enable scan servlet component
public class ApplicationConf {
    // ...
}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;若是有多台 Web 服务器提供不同的服务，且要求属于同一会话，上面的单机会话例子就无法满足要求，于是就有了分布式会话即可以共享会话数据。&lt;/p&gt;
&lt;p&gt;利用 Spring Session 就可以实现分布式会话，而 Spring Session 的实现可依赖关系数据库或内存数据库，下面例子为 Spring Boot 中导入基于 Redis 实现的 Spring Session 的依赖。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-data-redis&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.session&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-session-data-redis&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;redis.clients&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;jedis&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接着在 Spring Boot 的属性配置文件中，添加如下的属性即可，而对于会话的使用&lt;strong&gt;和单机会话操作是一样的&lt;/strong&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;spring:
  session:
    store-type: redis
  redis:
    host: 127.0.0.1
    port: 6379&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;关于会话安全问题，由于了解知识尚浅，暂且不做探讨，后续会补充该部分。&lt;/p&gt;
</description>
<pubDate>Fri, 29 Mar 2019 14:32:00 +0000</pubDate>
<dc:creator>霖哲煌</dc:creator>
<og:description>连接无状态 使用 HTTP 的连接是无状态的，因此为了应对需要状态的服务例如用户登录，诞生了适合保存状态的设计 会话（session），本文就来探讨一下会话。 会话的使用 Spring Mvc 中使用</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/linzhehuang/p/10624634.html</dc:identifier>
</item>
<item>
<title>第二章spring boot简单入门 - 吊儿郎当小少年</title>
<link>http://www.cnblogs.com/cxyyh/p/10624065.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cxyyh/p/10624065.html</guid>
<description>&lt;p&gt;&lt;span&gt;   &lt;img src=&quot;https://img2018.cnblogs.com/blog/1114349/201903/1114349-20190329211114224-2108431995.png&quot; alt=&quot;&quot; width=&quot;323&quot; height=&quot;234&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1114349/201903/1114349-20190329211245121-644375531.png&quot; alt=&quot;&quot; width=&quot;340&quot; height=&quot;239&quot;/&gt;&lt;/p&gt;


&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;56&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
    &amp;lt;!--引入父依赖--&amp;gt;
    &amp;lt;parent&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;2.0.1.RELEASE&amp;lt;/version&amp;gt;
    &amp;lt;/parent&amp;gt;
    &amp;lt;dependencies&amp;gt;
        &amp;lt;!--SpringBoot web 组件 --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;
    &amp;lt;!--这个插件，可以将应用打包成一个可执行的jar包 可选--&amp;gt;
    &amp;lt;build&amp;gt;
        &amp;lt;plugins&amp;gt;
            &amp;lt;plugin&amp;gt;
                &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;
            &amp;lt;/plugin&amp;gt;
        &amp;lt;/plugins&amp;gt;
    &amp;lt;/build&amp;gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;spring-boot-starter-parent&lt;/strong&gt;&lt;strong&gt;作用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;  在&lt;/span&gt;pom.xml中引入spring-boot-start-parent,spring官方的解释叫什么stater poms,它可以提供dependency management,也就是说依赖管理，引入以后在申明其它dependency的时候就不需要version了，后面可以看到。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;spring-boot-starter-web&lt;/strong&gt;&lt;strong&gt;作用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;     springweb&lt;/strong&gt; &lt;strong&gt;核心&lt;/strong&gt;&lt;strong&gt;组件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;spring-boot-maven-plugin&lt;/strong&gt;&lt;strong&gt;作用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;    &lt;/strong&gt;&lt;strong&gt;&lt;span&gt;如果我们要直接&lt;/span&gt;Main启动spring，那么以下plugin必须要添加，否则是无法启动的。如果使用maven&lt;/strong&gt;&lt;strong&gt; &lt;/strong&gt;&lt;strong&gt;&lt;span&gt;的&lt;/span&gt;spring-boot:run的话是不需要此配置的。（我在测试的时候，如果不配置下面的plugin也是直接在Main中运行的。）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;将这个应用打成&lt;/span&gt;jar包，直接使用java -jar的命令进行执行； &lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@RestController
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HelloConotroller {

    @RequestMapping(&lt;/span&gt;&quot;/index&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String index(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;hell world&quot;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;



&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * @SpringBootApplication 来标注一个主程序类，说明这是一个Spring Boot应用
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@SpringBootApplication
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HellStartMain {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;spring启动起来&lt;/span&gt;
        SpringApplication.run(HellStartMain.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;



&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1114349/201903/1114349-20190329214606931-1150361792.png&quot; alt=&quot;&quot; width=&quot;426&quot; height=&quot;145&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;!--这个插件，可以将应用打包成一个可执行的jar包 可选--&amp;gt;
    &amp;lt;build&amp;gt;
        &amp;lt;plugins&amp;gt;
            &amp;lt;plugin&amp;gt;
                &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;
            &amp;lt;/plugin&amp;gt;
        &amp;lt;/plugins&amp;gt;
    &amp;lt;/build&amp;gt;&lt;br/&gt;将这个应用打成jar包，直接使用java -jar的命令进行执行；
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;    1、 @RestController&lt;/h2&gt;
&lt;p&gt;              在上加上RestController 表示修饰该Controller所有的方法返回JSON格式,直接可以编写Restful接口&lt;/p&gt;
&lt;h2&gt;     2、&lt;strong&gt;@EnableAutoConfiguration&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;           注解:作用在于让 Spring Boot   根据应用所声明的依赖来对 Spring 框架进行自动配置 这个注解告诉Spring Boot根据添加的jar依赖猜测你想如何配置Spring。&lt;/p&gt;
&lt;p&gt;             由于spring-boot-starter-web添加了Tomcat和 Spring MVC，所以auto-configuration将假定你正在开发一个web应用并相应地对Spring进行设置。&lt;/p&gt;
&lt;p&gt;           @ComponentScan(basePackages = &quot;com.yehui&quot;)控制器扫包范围&lt;/p&gt;

&lt;h2&gt;        1、 SpringBoot启动&lt;span&gt;方式&lt;/span&gt;1&lt;/h2&gt;
&lt;p&gt;                spring boot默认端口是8080&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@RestController
@EnableAutoConfiguration
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HelloController {
    @RequestMapping(&lt;/span&gt;&quot;/hello&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String index() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;Hello World&quot;&lt;span&gt;;
    }    
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        SpringApplication.run(HelloController.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, args);
    }
}&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;启动主程序，打开浏览器访问&lt;/span&gt;http://localhost:8080/index，可以看到页面输出Hello World&lt;/p&gt;
&lt;/div&gt;

&lt;h2&gt;        2、&lt;strong&gt;S&lt;/strong&gt;&lt;strong&gt;pringBoot&lt;/strong&gt;&lt;strong&gt;启动&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;方式&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;p&gt;@ComponentScan(basePackages = &quot;com.itmayiedu.controller&quot;)---控制器&lt;span&gt;扫包&lt;/span&gt;范围&lt;/p&gt;
&lt;pre&gt;
@ComponentScan(basePackages = &quot;com.itmayiedu.controller&quot;&lt;span&gt;)
@EnableAutoConfiguration
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; App {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        SpringApplication.run(App.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, args);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;       3、SpringBoot启动方式3&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@SpringBootApplication

@SpringBootApplication 被 @Configuration、@EnableAutoConfiguration、@ComponentScan 注解所修饰，换言之 Springboot 提供了统一的注解来替代以上三个注解
扫包范围：在启动类上加上@SpringBootApplication注解,当前包下或者子包下所有的类都可以扫到。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Fri, 29 Mar 2019 13:34:00 +0000</pubDate>
<dc:creator>吊儿郎当小少年</dc:creator>
<og:description>1、创建mave工程（jar） 2、pom文件引入依赖 spring-boot-starter-parent作用 在pom.xml中引入spring-boot-start-parent,spring官</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cxyyh/p/10624065.html</dc:identifier>
</item>
</channel>
</rss>