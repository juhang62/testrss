<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>解读算法「时间」与「空间」复杂度——冰与火之歌 - 五分钟学算法</title>
<link>http://www.cnblogs.com/fivestudy/p/10137699.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fivestudy/p/10137699.html</guid>
<description>&lt;p&gt;算法（Algorithm）是指用来操作数据、解决程序问题的一组方法。对于同一个问题，使用不同的算法，也许最终得到的结果是一样的，比如排序就有前面的十大经典排序和几种奇葩排序，虽然结果相同，但在过程中消耗的资源和时间却会有很大的区别，比如快速排序与猴子排序：）。&lt;/p&gt;
&lt;p&gt;那么我们应该如何去衡量不同算法之间的优劣呢？&lt;/p&gt;
&lt;p&gt;主要还是从算法所占用的「时间」和「空间」两个维度去考量。&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;时间维度：是指执行当前算法所消耗的时间，我们通常用「时间复杂度」来描述。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;空间维度：是指执行当前算法需要占用多少内存空间，我们通常用「空间复杂度」来描述。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;h&quot;&gt;冰之哀伤：时间复杂度&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;时间的流逝宛若寒冰的融化，散发着恐惧。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;ho&quot;&gt;大O符号表示法&lt;/h3&gt;
&lt;p&gt;大O表示法：算法的时间复杂度通常用大O符号表述，定义为 **T[n] = O(f(n)) **。称函数T(n)以f(n)为界或者称T(n)受限于f(n)。&lt;/p&gt;
&lt;p&gt;如果一个问题的规模是n，解这一问题的某一算法所需要的时间为T(n)。T(n)称为这一算法的“时间复杂度”。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;上面公式中用到的 Landau符号是由德国数论学家保罗·巴赫曼（Paul Bachmann）在其1892年的著作《解析数论》首先引入，由另一位德国数论学家艾德蒙·朗道（Edmund Landau）推广。Landau符号的作用在于用简单的函数来描述复杂函数行为，给出一个上或下（确）界。在计算算法复杂度时一般只用到大O符号，Landau符号体系中的小o符号、Θ符号等等比较不常用。这里的O，最初是用大写希腊字母，但现在都用大写英语字母O；小o符号也是用小写英语字母o，Θ符号则维持大写希腊字母Θ。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;大O符号是一种算法「复杂度」的「相对」「表示」方式。&lt;/p&gt;
&lt;p&gt;这个句子里有一些重要而严谨的用词：&lt;/p&gt;
&lt;ul readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;相对(relative)：你只能比较相同的事物。你不能把一个做算数乘法的算法和排序整数列表的算法进行比较。但是，比较2个算法所做的算术操作（一个做乘法，一个做加法）将会告诉你一些有意义的东西；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;表示(representation)：大O(用它最简单的形式)把算法间的比较简化为了一个单一变量。这个变量的选择基于观察或假设。例如，排序算法之间的对比通常是基于比较操作(比较2个结点来决定这2个结点的相对顺序)。这里面就假设了比较操作的计算开销很大。但是，如果比较操作的计算开销不大，而交换操作的计算开销很大，又会怎么样呢？这就改变了先前的比较方式；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;复杂度(complexity)：如果排序10,000个元素花费了我1秒，那么排序1百万个元素会花多少时间？在这个例子里，复杂度就是相对其他东西的度量结果。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;h-1&quot;&gt;常见的时间复杂度量级&lt;/h3&gt;
&lt;p&gt;我们先从常见的时间复杂度量级进行大O的理解：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;常数阶O(1)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;线性阶O(n)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;平方阶O(n²)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对数阶O(logn)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;线性对数阶O(nlogn)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181212211132.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;ho1&quot;&gt;O(1)&lt;/h4&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181212213809.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;无论代码执行了多少行，其他区域不会影响到操作，这个代码的时间复杂度都是O(1)&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs cpp&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;1&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;swapTwoInts&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int &amp;amp;a, &lt;span class=&quot;hljs-keyword&quot;&gt;int &amp;amp;b){&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;2  &lt;span class=&quot;hljs-keyword&quot;&gt;int temp = a;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;3  a = b;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;4  b = temp;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;5}&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;hon&quot;&gt;O(n)&lt;/h4&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181212214121.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在下面这段代码，for循环里面的代码会执行 n 遍，因此它消耗的时间是随着 n 的变化而变化的，因此可以用O(n)来表示它的时间复杂度。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs cpp&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;1&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int &lt;span class=&quot;hljs-title&quot;&gt;sum &lt;span class=&quot;hljs-params&quot;&gt;( &lt;span class=&quot;hljs-keyword&quot;&gt;int n ){&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;2   &lt;span class=&quot;hljs-keyword&quot;&gt;int ret = &lt;span class=&quot;hljs-number&quot;&gt;0;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;3   &lt;span class=&quot;hljs-keyword&quot;&gt;for ( &lt;span class=&quot;hljs-keyword&quot;&gt;int i = &lt;span class=&quot;hljs-number&quot;&gt;0 ; i &amp;lt;= n ; i ++){&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;4      ret += i;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;5   }&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;6   &lt;span class=&quot;hljs-keyword&quot;&gt;return ret;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;7}&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;特别一提的是 c * O(n) 中的 c 可能小于 1 ，比如下面这段代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs cpp&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;1&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;reverse &lt;span class=&quot;hljs-params&quot;&gt;( &lt;span class=&quot;hljs-built_in&quot;&gt;string &amp;amp;s ) {&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;2    &lt;span class=&quot;hljs-keyword&quot;&gt;int n = s.size();&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;3    &lt;span class=&quot;hljs-keyword&quot;&gt;for (&lt;span class=&quot;hljs-keyword&quot;&gt;int i = &lt;span class=&quot;hljs-number&quot;&gt;0 ; i &amp;lt; n/&lt;span class=&quot;hljs-number&quot;&gt;2 ; i++){&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;4      swap ( s[i] , s[n&lt;span class=&quot;hljs-number&quot;&gt;-1-i]);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;5    }&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;6}&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;hon-1&quot;&gt;O(n²)&lt;/h4&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181212214350.gif&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;当存在双重循环的时候，即把 O(n) 的代码再嵌套循环一遍，它的时间复杂度就是 O(n²) 了。&lt;/p&gt;

&lt;pre&gt;
&lt;code class=&quot;hljs cpp&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 1&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;selectionSort&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int arr[],&lt;span class=&quot;hljs-keyword&quot;&gt;int n){&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 2   &lt;span class=&quot;hljs-keyword&quot;&gt;for(&lt;span class=&quot;hljs-keyword&quot;&gt;int i = &lt;span class=&quot;hljs-number&quot;&gt;0; i &amp;lt; n ; i++){&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 3     &lt;span class=&quot;hljs-keyword&quot;&gt;int minIndex = i;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 4     &lt;span class=&quot;hljs-keyword&quot;&gt;for (&lt;span class=&quot;hljs-keyword&quot;&gt;int j = i + &lt;span class=&quot;hljs-number&quot;&gt;1; j &amp;lt; n ; j++ )&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 5       &lt;span class=&quot;hljs-keyword&quot;&gt;if (arr[j] &amp;lt; arr[minIndex])&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 6           minIndex = j;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 7&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 8     swap ( arr[i], arr[minIndex]);&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 9   }&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;10}&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里简单的推导一下&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当 i = 0 时，第二重循环需要运行 (n - 1) 次&lt;/li&gt;
&lt;li&gt;当 i = 1 时，第二重循环需要运行 (n - 2) 次&lt;/li&gt;
&lt;li&gt;。。。。。。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;不难得到公式：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs r&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;1(n - &lt;span class=&quot;hljs-number&quot;&gt;1) + (n - &lt;span class=&quot;hljs-number&quot;&gt;2) + (n - &lt;span class=&quot;hljs-number&quot;&gt;3) + &lt;span class=&quot;hljs-keyword&quot;&gt;... + &lt;span class=&quot;hljs-number&quot;&gt;0&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;2= (&lt;span class=&quot;hljs-number&quot;&gt;0 + n - &lt;span class=&quot;hljs-number&quot;&gt;1) * n / &lt;span class=&quot;hljs-number&quot;&gt;2&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;3= O (n ^&lt;span class=&quot;hljs-number&quot;&gt;2)&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然并不是所有的双重循环都是 O(n²)，比如下面这段输出 30n 次 &lt;code&gt;Hello,五分钟学算法：）&lt;/code&gt;的代码。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs cpp&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;1&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;printInformation &lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int n ){&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;2   &lt;span class=&quot;hljs-keyword&quot;&gt;for (&lt;span class=&quot;hljs-keyword&quot;&gt;int i = &lt;span class=&quot;hljs-number&quot;&gt;1 ; i &amp;lt;= n ; i++)&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;3        &lt;span class=&quot;hljs-keyword&quot;&gt;for (&lt;span class=&quot;hljs-keyword&quot;&gt;int j = &lt;span class=&quot;hljs-number&quot;&gt;1 ; j &amp;lt;= &lt;span class=&quot;hljs-number&quot;&gt;30 ; j ++)&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;4           &lt;span class=&quot;hljs-built_in&quot;&gt;cout&amp;lt;&amp;lt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;Hello,五分钟学算法：）&quot;&amp;lt;&amp;lt; &lt;span class=&quot;hljs-built_in&quot;&gt;endl;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;5}&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;hologn&quot;&gt;O(logn)&lt;/h4&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181212214425.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs vbscript&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 1&lt;span class=&quot;hljs-built_in&quot;&gt;int binarySearch( &lt;span class=&quot;hljs-built_in&quot;&gt;int arr[], &lt;span class=&quot;hljs-built_in&quot;&gt;int n , &lt;span class=&quot;hljs-built_in&quot;&gt;int target){&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 2  &lt;span class=&quot;hljs-built_in&quot;&gt;int l = &lt;span class=&quot;hljs-number&quot;&gt;0, r = n - &lt;span class=&quot;hljs-number&quot;&gt;1;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 3  &lt;span class=&quot;hljs-keyword&quot;&gt;while ( l &amp;lt;= r) {&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 4    &lt;span class=&quot;hljs-built_in&quot;&gt;int &lt;span class=&quot;hljs-built_in&quot;&gt;mid = l + (r - l) / &lt;span class=&quot;hljs-number&quot;&gt;2;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 5    &lt;span class=&quot;hljs-keyword&quot;&gt;if (arr[&lt;span class=&quot;hljs-built_in&quot;&gt;mid] == target) return &lt;span class=&quot;hljs-built_in&quot;&gt;mid;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 6    &lt;span class=&quot;hljs-keyword&quot;&gt;if (arr[&lt;span class=&quot;hljs-built_in&quot;&gt;mid] &amp;gt; target ) r = &lt;span class=&quot;hljs-built_in&quot;&gt;mid - &lt;span class=&quot;hljs-number&quot;&gt;1;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 7    &lt;span class=&quot;hljs-keyword&quot;&gt;else l = &lt;span class=&quot;hljs-built_in&quot;&gt;mid + &lt;span class=&quot;hljs-number&quot;&gt;1;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 8  }&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 9  return &lt;span class=&quot;hljs-number&quot;&gt;-1;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;10}&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在二分查找法的代码中，通过while循环，成 2 倍数的缩减搜索范围，也就是说需要经过 log2^n 次即可跳出循环。&lt;/p&gt;
&lt;p&gt;同样的还有下面两段代码也是 O(logn) 级别的时间复杂度。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs dart&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 1  &lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs cpp&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;1&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;hello &lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int n ) {&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;2   &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;honlogn&quot;&gt;O(nlogn)&lt;/h4&gt;
&lt;p&gt;将时间复杂度为O(logn)的代码循环N遍的话，那么它的时间复杂度就是 n * O(logn)，也就是了O(nlogn)。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs cpp&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;1&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;hello &lt;span class=&quot;hljs-params&quot;&gt;(){&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;2  &lt;span class=&quot;hljs-keyword&quot;&gt;for( m = &lt;span class=&quot;hljs-number&quot;&gt;1 ; m &amp;lt; n ; m++){&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;3    i = &lt;span class=&quot;hljs-number&quot;&gt;1;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;4    &lt;span class=&quot;hljs-keyword&quot;&gt;while( i &amp;lt; n ){&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;5        i = i * &lt;span class=&quot;hljs-number&quot;&gt;2;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;6    }&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;7   }&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;8}&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;h-2&quot;&gt;不常见的时间复杂度&lt;/h3&gt;
&lt;p&gt;下面来分析一波另外几种复杂度： 递归算法的时间复杂度（recursive algorithm time complexity），最好情况时间复杂度（best case time complexity）、最坏情况时间复杂度（worst case time complexity）、平均时间复杂度（average case time complexity）和均摊时间复杂度（amortized time complexity）。&lt;/p&gt;
&lt;h4 id=&quot;h-3&quot;&gt;递归算法的时间复杂度&lt;/h4&gt;
&lt;p&gt;如果递归函数中，只进行一次递归调用，递归深度为depth；&lt;/p&gt;
&lt;p&gt;在每个递归的函数中，时间复杂度为T；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;则总体的时间复杂度为O(T * depth)&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在前面的学习中，归并排序 与 快速排序 都带有递归的思想，并且时间复杂度都是O(nlogn) ，但并不是有递归的函数就一定是 O(nlogn) 级别的。从以下两种情况进行分析。&lt;/p&gt;
&lt;h5 id=&quot;h-4&quot;&gt;① 递归中进行一次递归调用的复杂度分析&lt;/h5&gt;
&lt;h6 id=&quot;h-5&quot;&gt;二分查找法&lt;/h6&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181212214425.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs cpp&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 1&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int &lt;span class=&quot;hljs-title&quot;&gt;binarySearch&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int arr[], &lt;span class=&quot;hljs-keyword&quot;&gt;int l, &lt;span class=&quot;hljs-keyword&quot;&gt;int r, &lt;span class=&quot;hljs-keyword&quot;&gt;int target){&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 2    &lt;span class=&quot;hljs-keyword&quot;&gt;if( l &amp;gt; r ) &lt;span class=&quot;hljs-keyword&quot;&gt;return &lt;span class=&quot;hljs-number&quot;&gt;-1;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 3&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 4    &lt;span class=&quot;hljs-keyword&quot;&gt;int mid = l + (r-l)/&lt;span class=&quot;hljs-number&quot;&gt;2; &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 5    &lt;span class=&quot;hljs-keyword&quot;&gt;if( arr[mid] == target ) &lt;span class=&quot;hljs-keyword&quot;&gt;return mid;  &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 6    &lt;span class=&quot;hljs-keyword&quot;&gt;else &lt;span class=&quot;hljs-keyword&quot;&gt;if( arr[mid] &amp;gt; target ) &lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 7    &lt;span class=&quot;hljs-keyword&quot;&gt;return binarySearch(arr, l, mid&lt;span class=&quot;hljs-number&quot;&gt;-1, target);    &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;比如在这段二分查找法的代码中，每次在 [ l , r ] 范围中去查找目标的位置，如果中间的元素 &lt;code&gt;arr[mid]&lt;/code&gt; 不是 &lt;code&gt;target&lt;/code&gt;，那么判断 &lt;code&gt;arr[mid]&lt;/code&gt;是比 &lt;code&gt;target&lt;/code&gt; 大 还是 小 ，进而再次调用 &lt;code&gt;binarySearch&lt;/code&gt;这个函数。&lt;/p&gt;
&lt;p&gt;在这个递归函数中，每一次没有找到&lt;code&gt;target&lt;/code&gt;时，要么调用 左边 的 &lt;code&gt;binarySearch&lt;/code&gt;函数，要么调用 右边 的 &lt;code&gt;binarySearch&lt;/code&gt;函数。也就是说在此次递归中，最多调用了一次递归调用而已。根据数学知识，需要log2n次才能递归到底。因此，二分查找法的时间复杂度为 O(logn)。&lt;/p&gt;
&lt;h6 id=&quot;h-6&quot;&gt;求和&lt;/h6&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181213154801.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs cpp&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;1&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int &lt;span class=&quot;hljs-title&quot;&gt;sum &lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int n) {&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;2  &lt;span class=&quot;hljs-keyword&quot;&gt;if (n == &lt;span class=&quot;hljs-number&quot;&gt;0) &lt;span class=&quot;hljs-keyword&quot;&gt;return &lt;span class=&quot;hljs-number&quot;&gt;0;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;3  &lt;span class=&quot;hljs-keyword&quot;&gt;return n + sum( n - &lt;span class=&quot;hljs-number&quot;&gt;1 )&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;4}&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这段代码中比较容易理解递归深度随输入 n 的增加而线性递增，因此时间复杂度为 O (n)。&lt;/p&gt;
&lt;h6 id=&quot;h-7&quot;&gt;求幂&lt;/h6&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181215131813.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs cpp&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;1&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;递归深度为 &lt;code&gt;logn&lt;/code&gt;，因为是求需要除以 2 多少次才能到底。&lt;/p&gt;
&lt;h5 id=&quot;h-8&quot;&gt;② 递归中进行多次递归调用的复杂度分析&lt;/h5&gt;
&lt;p&gt;递归算法中比较难计算的是多次递归调用。&lt;/p&gt;
&lt;p&gt;先看下面这段代码，有两次递归调用。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs cpp&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;1&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181212213008.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;递归树中节点数就是代码计算的调用次数。&lt;/p&gt;
&lt;p&gt;比如 当 &lt;code&gt;n = 3&lt;/code&gt; 时，调用次数计算公式为&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1 + 2 + 4 + 8 = 15&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一般的，调用次数计算公式为&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;2^0 + 2^1 + 2^2 + …… + 2^n&lt;br/&gt;= 2^(n+1) - 1&lt;br/&gt;= O(2^n)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181215133249.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;与之有所类似的是 归并排序 的递归树，区别点在于&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1. 上述例子中树的深度为 &lt;code&gt;n&lt;/code&gt;，而 归并排序 的递归树深度为&lt;code&gt;logn&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;2. 上述例子中每次处理的数据规模是一样的，而在 归并排序 中每个节点处理的数据规模是逐渐缩小的&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;因此，在如 归并排序 等排序算法中，每一层处理的数据量为 O(n) 级别，同时有 &lt;code&gt;logn&lt;/code&gt; 层，时间复杂度便是 O(nlogn)。&lt;/p&gt;
&lt;h4 id=&quot;h-9&quot;&gt;最好、最坏情况时间复杂度&lt;/h4&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181215142013.gif&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;最好、最坏情况时间复杂度指的是特殊情况下的时间复杂度。&lt;/p&gt;

&lt;p&gt;动图表明的是在数组 array 中寻找变量 x 第一次出现的位置，若没有找到，则返回 -1；否则返回位置下标。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs cpp&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;1&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int &lt;span class=&quot;hljs-title&quot;&gt;find&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int[] &lt;span class=&quot;hljs-built_in&quot;&gt;array, &lt;span class=&quot;hljs-keyword&quot;&gt;int n, &lt;span class=&quot;hljs-keyword&quot;&gt;int x) {&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;2  &lt;span class=&quot;hljs-keyword&quot;&gt;for (  &lt;span class=&quot;hljs-keyword&quot;&gt;int i = &lt;span class=&quot;hljs-number&quot;&gt;0 ; i &amp;lt; n; i++) {&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;3    &lt;span class=&quot;hljs-keyword&quot;&gt;if (&lt;span class=&quot;hljs-built_in&quot;&gt;array[i] == x) {&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;4        &lt;span class=&quot;hljs-keyword&quot;&gt;return i;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;5        &lt;span class=&quot;hljs-keyword&quot;&gt;break;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;6    }&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;7  }&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;8  &lt;span class=&quot;hljs-keyword&quot;&gt;return &lt;span class=&quot;hljs-number&quot;&gt;-1;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt;9}&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这里当数组中第一个元素就是要找的 x 时，时间复杂度是 O(1)；而当最后一个元素才是 x 时，时间复杂度则是 O(n)。&lt;/p&gt;
&lt;p&gt;最好情况时间复杂度就是在最理想情况下执行代码的时间复杂度，它的时间是最短的；最坏情况时间复杂度就是在最糟糕情况下执行代码的时间复杂度，它的时间是最长的。&lt;/p&gt;
&lt;h4 id=&quot;h-10&quot;&gt;平均情况时间复杂度&lt;/h4&gt;
&lt;p&gt;最好、最坏时间复杂度反应的是极端条件下的复杂度，发生的概率不大，不能代表平均水平。那么为了更好的表示平均情况下的算法复杂度，就需要引入平均时间复杂度。&lt;/p&gt;
&lt;p&gt;平均情况时间复杂度可用代码在所有可能情况下执行次数的加权平均值表示。&lt;/p&gt;
&lt;p&gt;还是以 &lt;code&gt;find&lt;/code&gt; 函数为例，从概率的角度看， x 在数组中每一个位置的可能性是相同的，为 1 / n。那么，那么平均情况时间复杂度就可以用下面的方式计算：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;((1 + 2 + … + n) / n + n) / 2 = (3n + 1) / 4&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;find&lt;/code&gt; 函数的平均时间复杂度为 O(n)。&lt;/p&gt;
&lt;h4 id=&quot;h-11&quot;&gt;均摊复杂度分析&lt;/h4&gt;
&lt;p&gt;我们通过一个动态数组的 &lt;code&gt;push_back&lt;/code&gt; 操作来理解 &lt;strong&gt;均摊复杂度&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181215140128.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs cpp&quot;&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 1&lt;span class=&quot;hljs-keyword&quot;&gt;template &amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;typename T&amp;gt;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 2&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;MyVector{&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 3&lt;span class=&quot;hljs-keyword&quot;&gt;private:&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 4    T* data;&lt;br/&gt;&lt;span class=&quot;linenum hljs-number&quot;&gt; 5    &lt;span class=&quot;hljs-keyword&quot;&gt;int size;       &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;push_back&lt;/code&gt;实现的功能是往数组的末尾增加一个元素，如果数组没有满，直接往后面插入元素；如果数组满了，即 &lt;code&gt;size == capacity&lt;/code&gt; ，则将数组扩容一倍，然后再插入元素。&lt;/p&gt;
&lt;p&gt;例如，数组长度为 n，则前 n 次调用 &lt;code&gt;push_back&lt;/code&gt; 复杂度都为 O(1) 级别；在第 n + 1 次则需要先进行 n 次元素转移操作，然后再进行 1 次插入操作，复杂度为 O(n)。&lt;/p&gt;
&lt;p&gt;因此，平均来看：对于容量为 n 的动态数组，前面添加元素需要消耗了 1 * n 的时间，扩容操作消耗 n 时间 ，&lt;br/&gt;总共就是 2 * n 的时间，因此均摊时间复杂度为 O(2n / n) = O(2)，也就是 O(1) 级别了。&lt;/p&gt;
&lt;p&gt;可以得出一个比较有意思的结论：一个相对比较耗时的操作，如果能保证它不会每次都被触发，那么这个相对比较耗时的操作，它所相应的时间是可以分摊到其它的操作中来的。&lt;/p&gt;
&lt;h2 id=&quot;h-12&quot;&gt;火之晨曦：空间复杂度&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;🔥🔥🔥🔥，到处都是🔥&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一个程序的空间复杂度是指运行完一个程序所需内存的大小。利用程序的空间复杂度，可以对程序的运行所需要的内存多少有个预先估计。一个程序执行时除了需要存储空间和存储本身所使用的指令、常数、变量和输入数据外，还需要一些对数据进行操作的工作单元和存储一些为现实计算所需信息的辅助空间。程序执行时所需存储空间包括以下两部分：&lt;/p&gt;
&lt;p&gt;(1) 固定部分，这部分空间的大小与输入/输出的数据的个数多少、数值无关。主要包括指令空间（即代码空间）、数据空间（常量、简单变量）等所占的空间。这部分属于静态空间。&lt;/p&gt;
&lt;p&gt;(2) 可变空间，这部分空间的主要包括动态分配的空间，以及递归栈所需的空间等。这部分的空间大小与算法有关。&lt;/p&gt;
&lt;p&gt;一个算法所需的存储空间用f(n)表示。S(n)=O(f(n))，其中n为问题的规模，S(n)表示空间复杂度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;空间复杂度可以理解为除了原始序列大小的内存，在算法过程中用到的额外的存储空间。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以二叉查找树为例，举例说明二叉排序树的查找性能。&lt;/p&gt;
&lt;h3 id=&quot;h-13&quot;&gt;平衡二叉树&lt;/h3&gt;
&lt;p&gt;如果二叉树的是以红黑树等平衡二叉树实现的，则 n 个节点的二叉排序树的高度为 log2n+1 ，其查找效率为O(Log2n)，近似于折半查找。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181216214208.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;h-14&quot;&gt;列表二叉树&lt;/h3&gt;
&lt;p&gt;如果二叉树退变为列表了，则 n 个节点的高度或者说是长度变为了n，查找效率为O(n)，变成了顺序查找。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181216214554.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;h-15&quot;&gt;一般二叉树&lt;/h3&gt;
&lt;p&gt;介于「列表二叉树」与「平衡二叉树」之间，查找性能也在O(Log2n)到O(n)之间。&lt;/p&gt;
&lt;h2 id=&quot;h-16&quot;&gt;冰火交融&lt;/h2&gt;
&lt;p&gt;对于一个算法，其时间复杂度和空间复杂度往往是相互影响的。&lt;/p&gt;
&lt;p&gt;比如说，要判断某某年是不是闰年：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1. 可以编写一个算法来计算，这也就意味着，每次给一个年份，都是要通过计算得到是否是闰年的结果。&lt;/li&gt;
&lt;li&gt;2. 还有另一个办法就是，事先建立一个有 5555 个元素的数组（年数比现实多就行），然后把所有的年份按下标的数字对应，如果是闰年，此数组项的值就是1，如果不是值为0。这样，所谓的判断某一年是否是闰年，就变成了查找这个数组的某一项的值是多少的问题。此时，我们的运算是最小化了，但是硬盘上或者内存中需要存储这 5555 个 0 和 1 。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这就是典型的使用空间换时间的概念。&lt;/p&gt;
&lt;p&gt;当追求一个较好的时间复杂度时，可能会使空间复杂度的性能变差，即可能导致占用较多的存储空间；&lt;br/&gt;反之，求一个较好的空间复杂度时，可能会使时间复杂度的性能变差，即可能导致占用较长的运行时间。&lt;/p&gt;
&lt;p&gt;另外，算法的所有性能之间都存在着或多或少的相互影响。因此，当设计一个算法(特别是大型算法)时，要综合考虑算法的各项性能，算法的使用频率，算法处理的数据量的大小，算法描述语言的特性，算法运行的机器系统环境等各方面因素，才能够设计出比较好的算法。&lt;/p&gt;

&lt;p&gt;更多内容：&lt;a href=&quot;https://github.com/MisterBooo/LeetCodeAnimation&quot;&gt;https://github.com/MisterBooo/LeetCodeAnimation&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 18 Dec 2018 07:56:00 +0000</pubDate>
<dc:creator>五分钟学算法</dc:creator>
<og:description>算法（Algorithm）是指用来操作数据、解决程序问题的一组方法。对于同一个问题，使用不同的算法，也许最终得到的结果是一样的，比如排序就有前面的十大经典排序和几种奇葩排序，虽然结果相同，但在过程中消</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fivestudy/p/10137699.html</dc:identifier>
</item>
<item>
<title>初识中间件Kafka - SimpleWu</title>
<link>http://www.cnblogs.com/SimpleWu/p/10137494.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/SimpleWu/p/10137494.html</guid>
<description>&lt;blockquote&gt;
&lt;p&gt;Author：SimplelWu&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;什么是消息中间件&quot;&gt;什么是消息中间件？&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;非底层操作系统软件，非业务应用软件，不是直接给最终用户使用的，不能直接给客户带来价值的软件统称为中间件&lt;/li&gt;
&lt;li&gt;关注于数据的发送和接收，利用高效可靠的异步消息传递机制集成分布式系统。&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;什么是kafka&quot;&gt;什么是Kafka？&lt;/h5&gt;
&lt;p&gt;Kafka是一种高吞吐量的分布式发布订阅消息系统，是一个分布式的、分区的、可靠的分布式日志存储服务。它通过一种独一无二的设计提供了一个消息系统的功能。&lt;/p&gt;
&lt;p&gt;kafka官方：&lt;a href=&quot;http://kafka.apache.org/&quot; class=&quot;uri&quot;&gt;http://kafka.apache.org/&lt;/a&gt;&lt;/p&gt;
&lt;h5 id=&quot;kafka作为一个分布式的流平台这到底意味着什么&quot;&gt;Kafka作为一个分布式的流平台，这到底意味着什么？&lt;/h5&gt;
&lt;p&gt;我们认为，一个流处理平台具有三个关键能力：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;发布和订阅消息（流），在这方面，它类似于一个消息队列或企业消息系统。&lt;/li&gt;
&lt;li&gt;以&lt;code&gt;容错&lt;/code&gt;的方式存储消息（流）。&lt;/li&gt;
&lt;li&gt;在消息流发生时处理它们。&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;什么是kakfa的优势&quot;&gt;什么是kakfa的优势?&lt;/h5&gt;
&lt;p&gt;它应用于2大类应用：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;构建实时的流数据管道，可靠地获取系统和应用程序之间的数据。&lt;/li&gt;
&lt;li&gt;构建实时流的应用程序，对数据流进行转换或反应。&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;kafka有四个核心api&quot;&gt;kafka有四个核心API&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;应用程序使用 &lt;code&gt;Producer API&lt;/code&gt; 发布消息到1个或多个topic（主题）。&lt;/li&gt;
&lt;li&gt;应用程序使用 &lt;code&gt;Consumer API&lt;/code&gt; 来订阅一个或多个topic，并处理产生的消息。&lt;/li&gt;
&lt;li&gt;应用程序使用 &lt;code&gt;Streams API&lt;/code&gt; 充当一个流处理器，从1个或多个topic消费输入流，并生产一个输出流到1个或多个输出topic，有效地将输入流转换到输出流。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Connector API&lt;/code&gt;允许构建或运行可重复使用的生产者或消费者，将topic连接到现有的应用程序或数据系统。例如，一个关系数据库的连接器可捕获每一个变化。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://img.orchome.com:8888/group1/M00/00/01/KmCudlf7DXiAVXBMAAFScKNS-Og538.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Client和Server之间的通讯，是通过一条简单、高性能并且和开发语言无关的&lt;a href=&quot;https://kafka.apache.org/protocol.html&quot;&gt;TCP协议&lt;/a&gt;。并且该协议保持与老版本的兼容。Kafka提供了Java Client（客户端）。除了Java Client外，还有非常多的&lt;a href=&quot;https://cwiki.apache.org/confluence/display/KAFKA/Clients&quot;&gt;其它编程语言的Client&lt;/a&gt;。&lt;/p&gt;
&lt;h5 id=&quot;主流消息中间件比较&quot;&gt;主流消息中间件比较&lt;/h5&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;11&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;跨语言&lt;/td&gt;
&lt;td&gt;支持（Java优先）&lt;/td&gt;
&lt;td&gt;语言无关&lt;/td&gt;
&lt;td&gt;支持（Java优先）&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;支持协议&lt;/td&gt;
&lt;td&gt;OpenWire，Stomp， XMPP，AMQP&lt;/td&gt;
&lt;td&gt;AMQP&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;6&quot;&gt;&lt;td&gt;优点&lt;/td&gt;
&lt;td&gt;遵循JMS规范，安装部署方便。&lt;/td&gt;
&lt;td&gt;继承Erlang天生的并发性，最初用于金融行业，稳定性，安全性有保障。&lt;/td&gt;
&lt;td&gt;依赖zk，可动态扩展节点，高性能，高吞吐量，无线扩容消息可指定追溯。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;8&quot;&gt;&lt;td&gt;缺点&lt;/td&gt;
&lt;td&gt;根据其他用户反馈，会莫名丢失消息，目前重心在下一代的apolle上，目前社区不活跃，对5.X维护较少。&lt;/td&gt;
&lt;td&gt;Erlang语言难度较大，不支持动态扩展。&lt;/td&gt;
&lt;td&gt;严格的顺序机制，不支持消息优先级，不支持标准的消息协议，不利于平台迁移。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;6&quot;&gt;&lt;td&gt;综合评价&lt;/td&gt;
&lt;td&gt;适合中小企业消息应用场景，不适合上千个队列的应用场景。&lt;/td&gt;
&lt;td&gt;适合对稳定性要求较高的企业应用。&lt;/td&gt;
&lt;td&gt;一般应用在大数据日志处理或对实时性，可靠性要求稍低的场景。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h5 id=&quot;kafka好处&quot;&gt;Kafka好处&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;可靠性&lt;/strong&gt; - Kafka是分布式，分区，复制和容错的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可扩展性&lt;/strong&gt; - Kafka消息传递系统轻松缩放，无需停机。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;耐用性&lt;/strong&gt; - Kafka使用分布式提交日志，这意味着消息会尽可能快地保留在磁盘上，因此它是持久的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;性能&lt;/strong&gt; - Kafka对于发布和订阅消息都具有高吞吐量。 即使存储了许多TB的消息，它也保持稳定的性能。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Kafka非常快，并保证零停机和零数据丢失。&lt;/p&gt;
&lt;h5 id=&quot;应用场景&quot;&gt;&lt;strong&gt;应用场景&lt;/strong&gt;&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;指标&lt;/strong&gt; - Kafka通常用于操作监控数据。 这涉及聚合来自分布式应用程序的统计信息，以产生操作数据的集中馈送。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;日志聚合解决方案&lt;/strong&gt; - Kafka可用于跨组织从多个服务收集日志，并使它们以标准格式提供给多个服务器。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;流处理&lt;/strong&gt; - 流行的框架(如Storm和Spark Streaming)从主题中读取数据，对其进行处理，并将处理后的数据写入新主题，供用户和应用程序使用。 Kafka的强耐久性在流处理的上下文中也非常有用。&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;kafka相关术语&quot;&gt;&lt;strong&gt;Kafka相关术语&lt;/strong&gt;&lt;/h5&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;17&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Topics（主题）&lt;/strong&gt;属于特定类别的消息流称为主题。 数据存储在主题中。主题被拆分成分区。 对于每个主题，Kafka保存一个分区的数据。 每个这样的分区包含不可变有序序列的消息。 分区被实现为具有相等大小的一组分段文件。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Partition（分区）&lt;/strong&gt;主题可能有许多分区，因此它可以处理任意数量的数据。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Partition offset（分区偏移）&lt;/strong&gt;每个分区消息具有称为 offset 的唯一序列标识。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Replicas of partition（分区备份）&lt;/strong&gt;副本只是一个分区的备份。 副本从不读取或写入数据。 它们用于防止数据丢失。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;5&quot;&gt;&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Brokers（经纪人）&lt;/strong&gt;代理是负责维护发布数据的简单系统。 每个代理中的每个主题可以具有零个或多个分区。 假设，如果在一个主题和N个代理中有N个分区，每个代理将有一个分区。假设在一个主题中有N个分区并且多于N个代理(n + m)，则第一个N代理将具有一个分区，并且下一个M代理将不具有用于该特定主题的任何分区。假设在一个主题中有N个分区并且小于N个代理(n-m)，每个代理将在它们之间具有一个或多个分区共享。 由于代理之间的负载分布不相等，不推荐使用此方案。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Kafka Cluster（Kafka集群）&lt;/strong&gt;Kafka有多个代理被称为Kafka集群。 可以扩展Kafka集群，无需停机。 这些集群用于管理消息数据的持久性和复制。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;5&quot;&gt;&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Producers（生产者）&lt;/strong&gt;生产者是发送给一个或多个Kafka主题的消息的发布者。 生产者向Kafka经纪人发送数据。 每当生产者将消息发布给代理时，代理只需将消息附加到最后一个段文件。 实际上，该消息将被附加到分区。 生产者还可以向他们选择的分区发送消息。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Consumers（消费者）Consumers&lt;/strong&gt;从经纪人处读取数据。 消费者订阅一个或多个主题，并通过从代理中提取数据来使用已发布的消息。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Leader（领导者）&lt;/strong&gt; Leader 是负责给定分区的所有读取和写入的节点。每个分区都有一个服务器充当&lt;strong&gt;Leader&lt;/strong&gt; 。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Follower（追随者）&lt;/strong&gt;跟随领导者指令的节点被称为&lt;strong&gt;Follower&lt;/strong&gt;。 如果领导失败，一个追随者将自动成为新的领导者。 跟随者作为正常消费者，拉取消息并更新其自己的数据存储。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h5 id=&quot;使用kafka&quot;&gt;使用Kafka&lt;/h5&gt;
&lt;ol&gt;&lt;li&gt;安装jdk&lt;/li&gt;
&lt;li&gt;安装zookepper 官方：&lt;a href=&quot;http://zookeeper.apache.org/&quot; class=&quot;uri&quot;&gt;http://zookeeper.apache.org/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;安装kafka&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;我这里jdk是已经安装好的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;安装zookepper：&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;tar -zxvf zookeeper-3.4.13.tar.gz #解压
cd zookeeper-3.4.13/config #进入配置目录
#zookeeper运行需要config里有config文件。但是解压后默认只有zoo_sample.cfg，我们将名字修改下即可
mv zoo_sample.cfg zoo.cfg #修改配置文件名字&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动zookeper，来到bin目录：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;./zkServer.sh start #启动zookepper&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;停止zookeper，来到bin目录：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;./zkServer.sh start #停止zookepper&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;kafka下载：&lt;a href=&quot;https://www.apache.org/dyn/closer.cgi?path=/kafka/0.9.0.0/kafka_2.11-0.9.0.0.tgz&quot; class=&quot;uri&quot;&gt;https://www.apache.org/dyn/closer.cgi?path=/kafka/0.9.0.0/kafka_2.11-0.9.0.0.tgz&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用Kafka&lt;/strong&gt;，&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;tar -zxvf kafka_2.11-2.1.0.tgz #解压kafka&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动zookpper服务,来到kafka的bin目录：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;./zookeeper-server-start.sh config/zookeeper.properties #启动服务&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动kafka服务：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;./kafka-server-start.sh config/server.properties #启动kafka服务&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建一个主题:&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic test #topic_name&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;topic_name：主题的名字'test'。&lt;/p&gt;
&lt;p&gt;创建好后查看主题:&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;kafka-topics.sh --list --zookeeper localhost:2181&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Kafka提供了一个命令行的工具，可以从输入文件或者命令行中读取消息并发送给Kafka集群。每一行是一条消息。&lt;br/&gt;运行producer（生产者）,然后在控制台输入几条消息到服务器。&lt;/p&gt;
&lt;p&gt;发送消息：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;./kafka-console-producer.sh --broker-list localhost:9092 --topic test #主题为test&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;进入之后就可发送消息！！！&lt;/p&gt;
&lt;p&gt;Kafka也提供了一个消费消息的命令行工具，将存储的信息输出出来。&lt;/p&gt;
&lt;p&gt;消费消息：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;#topic主题需要与被消费的主题对应上
./kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic test --from-beginning&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;kafka常用命令&quot;&gt;Kafka常用命令&lt;/h5&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;#查看所有主题列表
kafka-topics.sh --zookeeper localhost:2181 --list
#查看指定topic信息
kafka-topics.sh --zookeeper localhost:2181 --describe --topic topic_name
#控制台向topic生产数据
kafka-console-producer.sh --broker-list localhost:9092 --topic topic_name 
#控制台消费topic的数据
kafka-console-consumer.sh  --zookeeper localhost:2181  --topic topic_name --from-beginning 
#查看topic某分区偏移量最大（小）值
kafka-run-class.sh kafka.tools.GetOffsetShell --topic hive-mdatabase-hostsltable  --time -1 --broker-list localhost:9092 --partitions 0 
#增加topic分区数
kafka-topics.sh --zookeeper localhost:2181  --alter --topic topic_name --partitions 10
#删除topic，慎用，只会删除zookeeper中的元数据，消息文件须手动删除
kafka-run-class.sh kafka.admin.DeleteTopicCommand --zookeeper localhost:2181 --topic topic_name&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Tue, 18 Dec 2018 07:36:00 +0000</pubDate>
<dc:creator>SimpleWu</dc:creator>
<og:description>初识中间件Kafka Author：SimplelWu 什么是消息中间件？ 非底层操作系统软件，非业务应用软件，不是直接给最终用户使用的，不能直接给客户带来价值的软件统称为中间件 关注于数据的发送和接</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/SimpleWu/p/10137494.html</dc:identifier>
</item>
<item>
<title>Java并发（十七）：ConcurrentHashMap - 那股泥石流</title>
<link>http://www.cnblogs.com/hexinwei1/p/10000779.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hexinwei1/p/10000779.html</guid>
<description>&lt;h3 class=&quot;article-title&quot;&gt;先做总结：&lt;/h3&gt;
&lt;h4 class=&quot;article-title&quot;&gt;1、HashMap HashTable ConcurrentHashMap&lt;/h4&gt;
&lt;p class=&quot;article-title&quot;&gt;HashMap：线程不安全&lt;/p&gt;
&lt;p class=&quot;article-title&quot;&gt;HashTable：线程安全，每个方法都加了 synchronized 修饰。类似 Collections.synchronizedMap(hashMap)&lt;/p&gt;
&lt;p class=&quot;article-title&quot;&gt;　　　　　  对读写加锁，独占式，一个线程在读时其他线程必须等待，吞吐量较低，性能较为低下。&lt;/p&gt;
&lt;p class=&quot;article-title&quot;&gt;ConcurrentHashMap：利用CAS+Synchronized来保证并发的安全性。数据结构同HashMap。&lt;/p&gt;
&lt;h4 class=&quot;article-title&quot;&gt;2、ConcurrentHashMap如何实现线程安全？&lt;/h4&gt;
&lt;p class=&quot;article-title&quot;&gt;（1）get()方法使用tabAt(Node&amp;lt;K, V&amp;gt;[], int)方法&lt;/p&gt;
&lt;p class=&quot;article-title&quot;&gt;　　　　调用Unsafe的native方法 getObjectVolatile(Object obj, long offset);&lt;/p&gt;
&lt;p class=&quot;article-title&quot;&gt;　　　　// 获取obj对象中offset偏移地址对应的object型field的值，支持volatile load语义，即：让缓存中的数据失效，重新从主内存加载数据&lt;/p&gt;
&lt;p class=&quot;article-title&quot;&gt;（2）put()方法&lt;/p&gt;
&lt;p class=&quot;article-title&quot;&gt;　　①需要获取数组上的Node时同样使用tabAt()方法&lt;/p&gt;
&lt;p class=&quot;article-title&quot;&gt;　　②设置数组上Node是使用casTabAt() 方法，&lt;/p&gt;
&lt;p class=&quot;article-title&quot;&gt;　　　　casTabAt()调用Unsafe的native方法compareAndSwapObject()，CAS操作&lt;/p&gt;
&lt;p class=&quot;article-title&quot;&gt;　　③哈希冲突之后，需要操作改hash值对应的链表/红黑树，此时synchronized(该链表第一个Node)&lt;/p&gt;
&lt;p class=&quot;article-title&quot;&gt;　　　　保证线程安全的基础上，减小了锁的粒度。&lt;/p&gt;
&lt;h4 class=&quot;article-title&quot;&gt;3、线程安全的容器只能保证自身的数据不被破坏，但无法保证业务的行为是否正确。&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; demo1() {
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Map&amp;lt;String, Integer&amp;gt; count = &lt;span&gt;new&lt;/span&gt; ConcurrentHashMap&amp;lt;&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; CountDownLatch endLatch = &lt;span&gt;new&lt;/span&gt; CountDownLatch(2&lt;span&gt;);
        Runnable task &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 5; i++&lt;span&gt;) {
                    Integer value &lt;/span&gt;= count.get(&quot;a&quot;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;null&lt;/span&gt; ==&lt;span&gt; value) {
                        count.put(&lt;/span&gt;&quot;a&quot;, 1&lt;span&gt;);
                    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                        count.put(&lt;/span&gt;&quot;a&quot;, value + 1&lt;span&gt;);
                    }
                }
                endLatch.countDown();
            }
        };
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(task).start();
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(task).start();
 
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            endLatch.await();
            System.out.println(count);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            e.printStackTrace();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; demo1是两个线程操作ConcurrentHashMap，意图将value变为10。但是，因为多个线程用相同的key调用时，很可能会覆盖相互的结果，造成记录的次数比实际出现的次数少。&lt;/p&gt;
&lt;p&gt;当然可以用锁解决这个问题，但是也可以使用ConcurrentMap定义的方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;V putIfAbsent(K key, V value)
   如果key对应的value不存在，则put进去，返回null。否则不put，返回已存在的value。
 
&lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; remove(Object key, Object value)
   如果key对应的值是value，则移除K&lt;/span&gt;-&lt;span&gt;V，返回true。否则不移除，返回false。
 
&lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; replace(K key, V oldValue, V newValue)
   如果key对应的当前值是oldValue，则替换为newValue，返回true。否则不替换，返回false。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;修改：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; demo1() {
    &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Map&amp;lt;String, Integer&amp;gt; count = &lt;span&gt;new&lt;/span&gt; ConcurrentHashMap&amp;lt;&amp;gt;&lt;span&gt;();
    &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; CountDownLatch endLatch = &lt;span&gt;new&lt;/span&gt; CountDownLatch(2&lt;span&gt;);
    Runnable task &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
            Integer oldValue, newValue;
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 5; i++&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;) {
                    oldValue &lt;/span&gt;= count.get(&quot;a&quot;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;null&lt;/span&gt; ==&lt;span&gt; oldValue) {
                        newValue &lt;/span&gt;= 1&lt;span&gt;;
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (count.putIfAbsent(&quot;a&quot;, newValue) == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                        }
                    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                        newValue &lt;/span&gt;= oldValue + 1&lt;span&gt;;
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (count.replace(&quot;a&quot;&lt;span&gt;, oldValue, newValue)) {
                            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                        }
                    }
                }
            }
            endLatch.countDown();
        }
    };
    &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(task).start();
    &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(task).start();
 
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
        endLatch.await();
        System.out.println(count);
    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
        e.printStackTrace();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于ConcurrentMap中不能保存value为null的值，所以需要处理不存在和已存在两种情况，不过可以使用AtomicInteger来替代。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; demo1() {
    &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Map&amp;lt;String, AtomicInteger&amp;gt; count = &lt;span&gt;new&lt;/span&gt; ConcurrentHashMap&amp;lt;&amp;gt;&lt;span&gt;();
    &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; CountDownLatch endLatch = &lt;span&gt;new&lt;/span&gt; CountDownLatch(2&lt;span&gt;);
    Runnable task &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
            AtomicInteger oldValue;
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 5; i++&lt;span&gt;) {
                oldValue &lt;/span&gt;= count.get(&quot;a&quot;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;null&lt;/span&gt; ==&lt;span&gt; oldValue) {
                    AtomicInteger zeroValue &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; AtomicInteger(0&lt;span&gt;);
                    oldValue &lt;/span&gt;= count.putIfAbsent(&quot;a&quot;&lt;span&gt;, zeroValue);
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;null&lt;/span&gt; ==&lt;span&gt; oldValue) {
                        oldValue &lt;/span&gt;=&lt;span&gt; zeroValue;
                    }
                }
                oldValue.incrementAndGet();
            }
            endLatch.countDown();
        }
    };
    &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(task).start();
    &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(task).start();
 
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
        endLatch.await();
        System.out.println(count);
    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
        e.printStackTrace();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 class=&quot;article-title&quot;&gt;一、属性&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 最大容量：2^30=1073741824&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; MAXIMUM_CAPACITY = 1 &amp;lt;&amp;lt; 30&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 默认初始值，必须是2的幕数&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; DEFAULT_CAPACITY = 16&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;//
&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;//
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; DEFAULT_CONCURRENCY_LEVEL = 16&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;//
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; LOAD_FACTOR = 0.75f&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 链表转红黑树阀值,&amp;gt; 8 链表转换为红黑树&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; TREEIFY_THRESHOLD = 8&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;树转链表阀值，小于等于6（tranfer时，lc、hc=0两个计数器分别++记录原bin、新binTreeNode数量，&amp;lt;=UNTREEIFY_THRESHOLD 则untreeify(lo)）&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; UNTREEIFY_THRESHOLD = 6&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;//
&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; MIN_TREEIFY_CAPACITY = 64&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;//
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; MIN_TRANSFER_STRIDE = 16&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;//
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; RESIZE_STAMP_BITS = 16&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2^15-1，help resize的最大线程数&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; MAX_RESIZERS = (1 &amp;lt;&amp;lt; (32 - RESIZE_STAMP_BITS)) - 1&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 32-16=16，sizeCtl中记录size大小的偏移量&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; RESIZE_STAMP_SHIFT = 32 -&lt;span&gt; RESIZE_STAMP_BITS;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; forwarding nodes的hash值&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; MOVED     = -1&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 树根节点的hash值&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; TREEBIN   = -2&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ReservationNode的hash值&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; RESERVED  = -3&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 可用处理器数量&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; NCPU = Runtime.getRuntime().availableProcessors();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;几个很重要的概念：&lt;/p&gt;
&lt;p&gt;（1）table：用来存放Node节点数据的，默认为null，默认大小为16的数组，每次扩容时大小总是2的幂次方；&lt;/p&gt;
&lt;p&gt;（2）nextTable：扩容时新生成的数据，数组为table的两倍；&lt;/p&gt;
&lt;p&gt;（3）Node：节点，保存key-value的数据结构；&lt;/p&gt;
&lt;p&gt;（4）ForwardingNode：一个特殊的Node节点，hash值为-1，其中存储nextTable的引用。只有table发生扩容的时候，ForwardingNode才会发挥作用，作为一个占位符放在table中表示当前节点为null或则已经被移动&lt;/p&gt;
&lt;p&gt;（5）sizeCtl：控制标识符，用来控制table初始化和扩容操作的，在不同的地方有不同的用途，其值也不同，所代表的含义也不同&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;负数代表正在进行初始化或扩容操作&lt;/li&gt;
&lt;li&gt;-1代表正在初始化&lt;/li&gt;
&lt;li&gt;-N 表示有N-1个线程正在进行扩容操作&lt;/li&gt;
&lt;li&gt;正数或0代表hash表还没有被初始化，这个数值表示初始化或下一次进行扩容的大小&lt;/li&gt;
&lt;/ol&gt;&lt;h3 class=&quot;article-title&quot;&gt;二、构造&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ConcurrentHashMap() {
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ConcurrentHashMap(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; initialCapacity) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (initialCapacity &amp;lt; 0&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalArgumentException();
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; cap = ((initialCapacity &amp;gt;= (MAXIMUM_CAPACITY &amp;gt;&amp;gt;&amp;gt; 1)) ?&lt;span&gt;
                   MAXIMUM_CAPACITY :
                   tableSizeFor(initialCapacity &lt;/span&gt;+ (initialCapacity &amp;gt;&amp;gt;&amp;gt; 1) + 1&lt;span&gt;));
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.sizeCtl =&lt;span&gt; cap;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ConcurrentHashMap(Map&amp;lt;? &lt;span&gt;extends&lt;/span&gt; K, ? &lt;span&gt;extends&lt;/span&gt; V&amp;gt;&lt;span&gt; m) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.sizeCtl =&lt;span&gt; DEFAULT_CAPACITY;
        putAll(m);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ConcurrentHashMap(&lt;span&gt;int&lt;/span&gt; initialCapacity, &lt;span&gt;float&lt;/span&gt;&lt;span&gt; loadFactor) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;(initialCapacity, loadFactor, 1&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ConcurrentHashMap(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; initialCapacity,
                             &lt;/span&gt;&lt;span&gt;float&lt;/span&gt; loadFactor, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; concurrencyLevel) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!(loadFactor &amp;gt; 0.0f) || initialCapacity &amp;lt; 0 || concurrencyLevel &amp;lt;= 0&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalArgumentException();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (initialCapacity &amp;lt; concurrencyLevel)   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Use at least as many bins&lt;/span&gt;
            initialCapacity = concurrencyLevel;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; as estimated threads&lt;/span&gt;
        &lt;span&gt;long&lt;/span&gt; size = (&lt;span&gt;long&lt;/span&gt;)(1.0 + (&lt;span&gt;long&lt;/span&gt;)initialCapacity /&lt;span&gt; loadFactor);
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; cap = (size &amp;gt;= (&lt;span&gt;long&lt;/span&gt;)MAXIMUM_CAPACITY) ?&lt;span&gt;
            MAXIMUM_CAPACITY : tableSizeFor((&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)size);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.sizeCtl =&lt;span&gt; cap;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;&lt;span id=&quot;_initTable&quot;&gt;初始化： initTable()&lt;/span&gt;&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Node&amp;lt;K,V&amp;gt;&lt;span&gt;[] initTable() {
    Node&lt;/span&gt;&amp;lt;K,V&amp;gt;[] tab; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; sc;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; ((tab = table) == &lt;span&gt;null&lt;/span&gt; || tab.length == 0&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始化的&quot;功劳&quot;被其他线程&quot;抢去&quot;了&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; ((sc = sizeCtl) &amp;lt; 0&lt;span&gt;)
            Thread.yield(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; lost initialization race; just spin
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; CAS 一下，将 sizeCtl 设置为 -1，代表抢到了锁&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (U.compareAndSwapInt(&lt;span&gt;this&lt;/span&gt;, SIZECTL, sc, -1&lt;span&gt;)) {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((tab = table) == &lt;span&gt;null&lt;/span&gt; || tab.length == 0&lt;span&gt;) {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; DEFAULT_CAPACITY 默认初始容量是 16&lt;/span&gt;
                    &lt;span&gt;int&lt;/span&gt; n = (sc &amp;gt; 0) ?&lt;span&gt; sc : DEFAULT_CAPACITY;
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始化数组，长度为 16 或初始化时提供的长度&lt;/span&gt;
                    Node&amp;lt;K,V&amp;gt;[] nt = (Node&amp;lt;K,V&amp;gt;[])&lt;span&gt;new&lt;/span&gt; Node&amp;lt;?,?&amp;gt;&lt;span&gt;[n];
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将这个数组赋值给 table，table 是 volatile 的&lt;/span&gt;
                    table = tab =&lt;span&gt; nt;
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果 n 为 16 的话，那么这里 sc = 12
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 其实就是 0.75 * n&lt;/span&gt;
                    sc = n - (n &amp;gt;&amp;gt;&amp;gt; 2&lt;span&gt;);
                }
            } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置 sizeCtl 为 sc，我们就当是 12 吧&lt;/span&gt;
                sizeCtl =&lt;span&gt; sc;
            }
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        }
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; tab;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 class=&quot;article-title&quot;&gt;三、put()&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; V put(K key, V value) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; putVal(key, value, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
}

&lt;/span&gt;&lt;span&gt;final&lt;/span&gt; V putVal(K key, V value, &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; onlyIfAbsent) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (key == &lt;span&gt;null&lt;/span&gt; || value == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NullPointerException();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 得到 hash 值&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; hash =&lt;span&gt; spread(key.hashCode());
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 用于记录相应链表的长度&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; binCount = 0&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Node&amp;lt;K,V&amp;gt;[] tab =&lt;span&gt; table;;) {
        Node&lt;/span&gt;&amp;lt;K,V&amp;gt; f; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n, i, fh;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果数组&quot;空&quot;，进行数组初始化&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (tab == &lt;span&gt;null&lt;/span&gt; || (n = tab.length) == 0&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始化数组，后面会详细介绍&lt;/span&gt;
            tab =&lt;span&gt; initTable();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 找该 hash 值对应的数组下标，得到第一个节点 f&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; ((f = tabAt(tab, i = (n - 1) &amp;amp; hash)) == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果数组该位置为空，
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    用一次 CAS 操作将这个新值放入其中即可，这个 put 操作差不多就结束了，可以拉到最后面了
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;          如果 CAS 失败，那就是有并发操作，进到下一个循环就好了&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (casTabAt(tab, i, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;,
                         &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Node&amp;lt;K,V&amp;gt;(hash, key, value, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)))
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;;                   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; no lock when adding to empty bin&lt;/span&gt;
&lt;span&gt;        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; hash 居然可以等于 MOVED，这个需要到后面才能看明白，不过从名字上也能猜到，肯定是因为在扩容&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; ((fh = f.hash) ==&lt;span&gt; MOVED)
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 帮助数据迁移，这个等到看完数据迁移部分的介绍后，再理解这个就很简单了&lt;/span&gt;
            tab =&lt;span&gt; helpTransfer(tab, f);

        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 到这里就是说，f 是该位置的头结点，而且不为空&lt;/span&gt;
&lt;span&gt;
            V oldVal &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取数组该位置的头结点的监视器锁&lt;/span&gt;
            &lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt; (f) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (tabAt(tab, i) ==&lt;span&gt; f) {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (fh &amp;gt;= 0) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 头结点的 hash 值大于 0，说明是链表
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 用于累加，记录链表的长度&lt;/span&gt;
                        binCount = 1&lt;span&gt;;
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 遍历链表&lt;/span&gt;
                        &lt;span&gt;for&lt;/span&gt; (Node&amp;lt;K,V&amp;gt; e = f;; ++&lt;span&gt;binCount) {
                            K ek;
                            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果发现了&quot;相等&quot;的 key，判断是否要进行值覆盖，然后也就可以 break 了&lt;/span&gt;
                            &lt;span&gt;if&lt;/span&gt; (e.hash == hash &amp;amp;&amp;amp;&lt;span&gt;
                                ((ek &lt;/span&gt;= e.key) == key ||&lt;span&gt;
                                 (ek &lt;/span&gt;!= &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; key.equals(ek)))) {
                                oldVal &lt;/span&gt;=&lt;span&gt; e.val;
                                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;onlyIfAbsent)
                                    e.val &lt;/span&gt;=&lt;span&gt; value;
                                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                            }
                            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 到了链表的最末端，将这个新值放到链表的最后面&lt;/span&gt;
                            Node&amp;lt;K,V&amp;gt; pred =&lt;span&gt; e;
                            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((e = e.next) == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                                pred.next &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Node&amp;lt;K,V&amp;gt;&lt;span&gt;(hash, key,
                                                          value, &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
                                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                            }
                        }
                    }
                    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (f &lt;span&gt;instanceof&lt;/span&gt; TreeBin) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 红黑树&lt;/span&gt;
                        Node&amp;lt;K,V&amp;gt;&lt;span&gt; p;
                        binCount &lt;/span&gt;= 2&lt;span&gt;;
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用红黑树的插值方法插入新节点&lt;/span&gt;
                        &lt;span&gt;if&lt;/span&gt; ((p = ((TreeBin&amp;lt;K,V&amp;gt;&lt;span&gt;)f).putTreeVal(hash, key,
                                                       value)) &lt;/span&gt;!= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                            oldVal &lt;/span&gt;=&lt;span&gt; p.val;
                            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;onlyIfAbsent)
                                p.val &lt;/span&gt;=&lt;span&gt; value;
                        }
                    }
                }
            }

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (binCount != 0&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断是否要将链表转换为红黑树，临界值和 HashMap 一样，也是 8&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (binCount &amp;gt;=&lt;span&gt; TREEIFY_THRESHOLD)
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这个方法和 HashMap 中稍微有一点点不同，那就是它不是一定会进行红黑树转换，
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果当前数组的长度小于 64，那么会选择进行数组扩容，而不是转换为红黑树
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    具体源码我们就不看了，扩容部分后面说&lt;/span&gt;
&lt;span&gt;                    treeifyBin(tab, i);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (oldVal != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; oldVal;
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            }
        }
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt; 
    addCount(1L&lt;span&gt;, binCount);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;按照上面的源码，我们可以确定put整个流程如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;判空；ConcurrentHashMap的key、value都不允许为null&lt;/li&gt;
&lt;li&gt;计算hash。利用方法计算hash值。&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;遍历table，进行节点插入操作，过程如下：
&lt;ul&gt;&lt;li&gt;如果table为空，则表示ConcurrentHashMap还没有初始化，则进行初始化操作：initTable()&lt;/li&gt;
&lt;li&gt;根据hash值获取节点的位置i，若该位置为空，则直接插入，这个过程是不需要加锁的。计算f位置：i=(n – 1) &amp;amp; hash&lt;/li&gt;
&lt;li&gt;如果检测到fh = f.hash == -1，则f是ForwardingNode节点，表示有其他线程正在进行扩容操作，则帮助线程一起进行扩容操作&lt;/li&gt;
&lt;li&gt;如果f.hash &amp;gt;= 0 表示是链表结构，则遍历链表，如果存在当前key节点则替换value，否则插入到链表尾部。如果f是TreeBin类型节点，则按照红黑树的方法更新或者增加节点&lt;/li&gt;
&lt;li&gt;若链表长度 &amp;gt; TREEIFY_THRESHOLD(默认是8)，则将链表转换为红黑树结构&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;调用addCount方法，ConcurrentHashMap的size + 1&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里整个put操作已经完成。&lt;/p&gt;
&lt;h3 class=&quot;article-title&quot;&gt;四、get()&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; V get(Object key) {
        Node&lt;/span&gt;&amp;lt;K,V&amp;gt;[] tab; Node&amp;lt;K,V&amp;gt; e, p; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n, eh; K ek;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 计算hash&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; h =&lt;span&gt; spread(key.hashCode());
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((tab = table) != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; (n = tab.length) &amp;gt; 0 &amp;amp;&amp;amp;&lt;span&gt;
                (e &lt;/span&gt;= tabAt(tab, (n - 1) &amp;amp; h)) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 搜索到的节点key与传入的key相同且不为null,直接返回这个节点&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; ((eh = e.hash) ==&lt;span&gt; h) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((ek = e.key) == key || (ek != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; key.equals(ek)))
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; e.val;
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 树&lt;/span&gt;
            &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (eh &amp;lt; 0&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (p = e.find(h, key)) != &lt;span&gt;null&lt;/span&gt; ? p.val : &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 链表，遍历&lt;/span&gt;
            &lt;span&gt;while&lt;/span&gt; ((e = e.next) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (e.hash == h &amp;amp;&amp;amp;&lt;span&gt;
                        ((ek &lt;/span&gt;= e.key) == key || (ek != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; key.equals(ek))))
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; e.val;
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;get操作：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;计算hash值&lt;/li&gt;
&lt;li&gt;判断table是否为空，如果为空，直接返回null&lt;/li&gt;
&lt;li&gt;根据hash值获取table中的Node节点（tabAt(tab, (n – 1) &amp;amp; h)），然后根据链表或者树形方式找到相对应的节点，返回其value值。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 class=&quot;article-title&quot;&gt;五、扩容&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 首先要说明的是，方法参数 size 传进来的时候就已经翻了倍了&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; tryPresize(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; size) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; c：size 的 1.5 倍，再加 1，再往上取最近的 2 的 n 次方。&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; c = (size &amp;gt;= (MAXIMUM_CAPACITY &amp;gt;&amp;gt;&amp;gt; 1)) ?&lt;span&gt; MAXIMUM_CAPACITY :
        tableSizeFor(size &lt;/span&gt;+ (size &amp;gt;&amp;gt;&amp;gt; 1) + 1&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; sc;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; ((sc = sizeCtl) &amp;gt;= 0&lt;span&gt;) {
        Node&lt;/span&gt;&amp;lt;K,V&amp;gt;[] tab = table; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这个 if 分支和之前说的初始化数组的代码基本上是一样的，在这里，我们可以不用管这块代码&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (tab == &lt;span&gt;null&lt;/span&gt; || (n = tab.length) == 0&lt;span&gt;) {
            n &lt;/span&gt;= (sc &amp;gt; c) ?&lt;span&gt; sc : c;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (U.compareAndSwapInt(&lt;span&gt;this&lt;/span&gt;, SIZECTL, sc, -1&lt;span&gt;)) {
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (table ==&lt;span&gt; tab) {
                        @SuppressWarnings(&lt;/span&gt;&quot;unchecked&quot;&lt;span&gt;)
                        Node&lt;/span&gt;&amp;lt;K,V&amp;gt;[] nt = (Node&amp;lt;K,V&amp;gt;[])&lt;span&gt;new&lt;/span&gt; Node&amp;lt;?,?&amp;gt;&lt;span&gt;[n];
                        table &lt;/span&gt;=&lt;span&gt; nt;
                        sc &lt;/span&gt;= n - (n &amp;gt;&amp;gt;&amp;gt; 2); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 0.75 * n&lt;/span&gt;
&lt;span&gt;                    }
                } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
                    sizeCtl &lt;/span&gt;=&lt;span&gt; sc;
                }
            }
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (c &amp;lt;= sc || n &amp;gt;=&lt;span&gt; MAXIMUM_CAPACITY)
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (tab ==&lt;span&gt; table) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 我没看懂 rs 的真正含义是什么，不过也关系不大&lt;/span&gt;
            &lt;span&gt;int&lt;/span&gt; rs =&lt;span&gt; resizeStamp(n);

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (sc &amp;lt; 0&lt;span&gt;) {
                Node&lt;/span&gt;&amp;lt;K,V&amp;gt;&lt;span&gt;[] nt;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((sc &amp;gt;&amp;gt;&amp;gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||&lt;span&gt;
                    sc &lt;/span&gt;== rs + MAX_RESIZERS || (nt = nextTable) == &lt;span&gt;null&lt;/span&gt; ||&lt;span&gt;
                    transferIndex &lt;/span&gt;&amp;lt;= 0&lt;span&gt;)
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2. 用 CAS 将 sizeCtl 加 1，然后执行 transfer 方法
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    此时 nextTab 不为 null&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (U.compareAndSwapInt(&lt;span&gt;this&lt;/span&gt;, SIZECTL, sc, sc + 1&lt;span&gt;))
                    transfer(tab, nt);
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1. 将 sizeCtl 设置为 (rs &amp;lt;&amp;lt; RESIZE_STAMP_SHIFT) + 2)
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     我是没看懂这个值真正的意义是什么？不过可以计算出来的是，结果是一个比较大的负数
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  调用 transfer 方法，此时 nextTab 参数为 null&lt;/span&gt;
            &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (U.compareAndSwapInt(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, SIZECTL, sc,
                                         (rs &lt;/span&gt;&amp;lt;&amp;lt; RESIZE_STAMP_SHIFT) + 2&lt;span&gt;))
                transfer(tab, &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个方法的核心在于 sizeCtl 值的操作，首先将其设置为一个负数，然后执行 transfer(tab, null)，再下一个循环将 sizeCtl 加 1，并执行 transfer(tab, nt)，之后可能是继续 sizeCtl 加 1，并执行 transfer(tab, nt)。&lt;/p&gt;
&lt;p&gt;所以，可能的操作就是执行 1 次 transfer(tab, null) + 多次 transfer(tab, nt)，这里怎么结束循环的需要看完 transfer 源码才清楚。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;99&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; transfer(Node&amp;lt;K,V&amp;gt;[] tab, Node&amp;lt;K,V&amp;gt;&lt;span&gt;[] nextTab) {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; n =&lt;span&gt; tab.length, stride;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; stride 在单核下直接等于 n，多核模式下为 (n&amp;gt;&amp;gt;&amp;gt;3)/NCPU，最小值是 16
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; stride 可以理解为”步长“，有 n 个位置是需要进行迁移的，
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;   将这 n 个任务分为多个任务包，每个任务包有 stride 个任务&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; ((stride = (NCPU &amp;gt; 1) ? (n &amp;gt;&amp;gt;&amp;gt; 3) / NCPU : n) &amp;lt;&lt;span&gt; MIN_TRANSFER_STRIDE)
        stride &lt;/span&gt;= MIN_TRANSFER_STRIDE; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; subdivide range

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果 nextTab 为 null，先进行一次初始化
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    前面我们说了，外围会保证第一个发起迁移的线程调用此方法时，参数 nextTab 为 null
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;       之后参与迁移的线程调用此方法时，nextTab 不会为 null&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (nextTab == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 容量翻倍&lt;/span&gt;
            Node&amp;lt;K,V&amp;gt;[] nt = (Node&amp;lt;K,V&amp;gt;[])&lt;span&gt;new&lt;/span&gt; Node&amp;lt;?,?&amp;gt;[n &amp;lt;&amp;lt; 1&lt;span&gt;];
            nextTab &lt;/span&gt;=&lt;span&gt; nt;
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt; (Throwable ex) {      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; try to cope with OOME&lt;/span&gt;
            sizeCtl =&lt;span&gt; Integer.MAX_VALUE;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; nextTable 是 ConcurrentHashMap 中的属性&lt;/span&gt;
        nextTable =&lt;span&gt; nextTab;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; transferIndex 也是 ConcurrentHashMap 的属性，用于控制迁移的位置&lt;/span&gt;
        transferIndex =&lt;span&gt; n;
    }

    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; nextn =&lt;span&gt; nextTab.length;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ForwardingNode 翻译过来就是正在被迁移的 Node
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这个构造方法会生成一个Node，key、value 和 next 都为 null，关键是 hash 为 MOVED
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 后面我们会看到，原数组中位置 i 处的节点完成迁移工作后，
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    就会将位置 i 处设置为这个 ForwardingNode，用来告诉其他线程该位置已经处理过了
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    所以它其实相当于是一个标志。&lt;/span&gt;
    ForwardingNode&amp;lt;K,V&amp;gt; fwd = &lt;span&gt;new&lt;/span&gt; ForwardingNode&amp;lt;K,V&amp;gt;&lt;span&gt;(nextTab);


    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; advance 指的是做完了一个位置的迁移工作，可以准备做下一个位置的了&lt;/span&gt;
    &lt;span&gt;boolean&lt;/span&gt; advance = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; finishing = &lt;span&gt;false&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; to ensure sweep before committing nextTab&lt;/span&gt;

    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
     * 下面这个 for 循环，最难理解的在前面，而要看懂它们，应该先看懂后面的，然后再倒回来看
     * 
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; i 是位置索引，bound 是边界，注意是从后往前&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0, bound = 0&lt;span&gt;;;) {
        Node&lt;/span&gt;&amp;lt;K,V&amp;gt; f; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; fh;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 下面这个 while 真的是不好理解
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; advance 为 true 表示可以进行下一个位置的迁移了
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;   简单理解结局：i 指向了 transferIndex，bound 指向了 transferIndex-stride&lt;/span&gt;
        &lt;span&gt;while&lt;/span&gt;&lt;span&gt; (advance) {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; nextIndex, nextBound;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (--i &amp;gt;= bound ||&lt;span&gt; finishing)
                advance &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将 transferIndex 值赋给 nextIndex
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这里 transferIndex 一旦小于等于 0，说明原数组的所有位置都有相应的线程去处理了&lt;/span&gt;
            &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; ((nextIndex = transferIndex) &amp;lt;= 0&lt;span&gt;) {
                i &lt;/span&gt;= -1&lt;span&gt;;
                advance &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (U.compareAndSwapInt
                     (&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, TRANSFERINDEX, nextIndex,
                      nextBound &lt;/span&gt;= (nextIndex &amp;gt; stride ?&lt;span&gt;
                                   nextIndex &lt;/span&gt;- stride : 0&lt;span&gt;))) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 看括号中的代码，nextBound 是这次迁移任务的边界，注意，是从后往前&lt;/span&gt;
                bound =&lt;span&gt; nextBound;
                i &lt;/span&gt;= nextIndex - 1&lt;span&gt;;
                advance &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            }
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (i &amp;lt; 0 || i &amp;gt;= n || i + n &amp;gt;=&lt;span&gt; nextn) {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; sc;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (finishing) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 所有的迁移操作已经完成&lt;/span&gt;
                nextTable = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将新的 nextTab 赋值给 table 属性，完成迁移&lt;/span&gt;
                table =&lt;span&gt; nextTab;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 重新计算 sizeCtl：n 是原数组长度，所以 sizeCtl 得出的值将是新数组长度的 0.75 倍&lt;/span&gt;
                sizeCtl = (n &amp;lt;&amp;lt; 1) - (n &amp;gt;&amp;gt;&amp;gt; 1&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 之前我们说过，sizeCtl 在迁移前会设置为 (rs &amp;lt;&amp;lt; RESIZE_STAMP_SHIFT) + 2
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 然后，每有一个线程参与迁移就会将 sizeCtl 加 1，
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这里使用 CAS 操作对 sizeCtl 进行减 1，代表做完了属于自己的任务&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (U.compareAndSwapInt(&lt;span&gt;this&lt;/span&gt;, SIZECTL, sc = sizeCtl, sc - 1&lt;span&gt;)) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 任务结束，方法退出&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; ((sc - 2) != resizeStamp(n) &amp;lt;&amp;lt;&lt;span&gt; RESIZE_STAMP_SHIFT)
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 到这里，说明 (sc - 2) == resizeStamp(n) &amp;lt;&amp;lt; RESIZE_STAMP_SHIFT，
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 也就是说，所有的迁移任务都做完了，也就会进入到上面的 if(finishing){} 分支了&lt;/span&gt;
                finishing = advance = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                i &lt;/span&gt;= n; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; recheck before commit&lt;/span&gt;
&lt;span&gt;            }
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果位置 i 处是空的，没有任何节点，那么放入刚刚初始化的 ForwardingNode ”空节点“&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; ((f = tabAt(tab, i)) == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            advance &lt;/span&gt;= casTabAt(tab, i, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;, fwd);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 该位置处是一个 ForwardingNode，代表该位置已经迁移过了&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; ((fh = f.hash) ==&lt;span&gt; MOVED)
            advance &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; already processed&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对数组该位置处的结点加锁，开始处理数组该位置处的迁移工作&lt;/span&gt;
            &lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt; (f) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (tabAt(tab, i) ==&lt;span&gt; f) {
                    Node&lt;/span&gt;&amp;lt;K,V&amp;gt;&lt;span&gt; ln, hn;
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 头结点的 hash 大于 0，说明是链表的 Node 节点&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; (fh &amp;gt;= 0&lt;span&gt;) {
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 下面这一块和 Java7 中的 ConcurrentHashMap 迁移是差不多的，
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 需要将链表一分为二，
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;   找到原链表中的 lastRun，然后 lastRun 及其之后的节点是一起进行迁移的
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;   lastRun 之前的节点需要进行克隆，然后分到两个链表中&lt;/span&gt;
                        &lt;span&gt;int&lt;/span&gt; runBit = fh &amp;amp;&lt;span&gt; n;
                        Node&lt;/span&gt;&amp;lt;K,V&amp;gt; lastRun =&lt;span&gt; f;
                        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Node&amp;lt;K,V&amp;gt; p = f.next; p != &lt;span&gt;null&lt;/span&gt;; p =&lt;span&gt; p.next) {
                            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; b = p.hash &amp;amp;&lt;span&gt; n;
                            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (b !=&lt;span&gt; runBit) {
                                runBit &lt;/span&gt;=&lt;span&gt; b;
                                lastRun &lt;/span&gt;=&lt;span&gt; p;
                            }
                        }
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (runBit == 0&lt;span&gt;) {
                            ln &lt;/span&gt;=&lt;span&gt; lastRun;
                            hn &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                        }
                        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                            hn &lt;/span&gt;=&lt;span&gt; lastRun;
                            ln &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                        }
                        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Node&amp;lt;K,V&amp;gt; p = f; p != lastRun; p =&lt;span&gt; p.next) {
                            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; ph = p.hash; K pk = p.key; V pv =&lt;span&gt; p.val;
                            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((ph &amp;amp; n) == 0&lt;span&gt;)
                                ln &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Node&amp;lt;K,V&amp;gt;&lt;span&gt;(ph, pk, pv, ln);
                            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                                hn &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Node&amp;lt;K,V&amp;gt;&lt;span&gt;(ph, pk, pv, hn);
                        }
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 其中的一个链表放在新数组的位置 i&lt;/span&gt;
&lt;span&gt;                        setTabAt(nextTab, i, ln);
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 另一个链表放在新数组的位置 i+n&lt;/span&gt;
                        setTabAt(nextTab, i +&lt;span&gt; n, hn);
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将原数组该位置处设置为 fwd，代表该位置已经处理完毕，
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    其他线程一旦看到该位置的 hash 值为 MOVED，就不会进行迁移了&lt;/span&gt;
&lt;span&gt;                        setTabAt(tab, i, fwd);
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; advance 设置为 true，代表该位置已经迁移完毕&lt;/span&gt;
                        advance = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                    }
                    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (f &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; TreeBin) {
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 红黑树的迁移&lt;/span&gt;
                        TreeBin&amp;lt;K,V&amp;gt; t = (TreeBin&amp;lt;K,V&amp;gt;&lt;span&gt;)f;
                        TreeNode&lt;/span&gt;&amp;lt;K,V&amp;gt; lo = &lt;span&gt;null&lt;/span&gt;, loTail = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                        TreeNode&lt;/span&gt;&amp;lt;K,V&amp;gt; hi = &lt;span&gt;null&lt;/span&gt;, hiTail = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; lc = 0, hc = 0&lt;span&gt;;
                        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Node&amp;lt;K,V&amp;gt; e = t.first; e != &lt;span&gt;null&lt;/span&gt;; e =&lt;span&gt; e.next) {
                            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; h =&lt;span&gt; e.hash;
                            TreeNode&lt;/span&gt;&amp;lt;K,V&amp;gt; p = &lt;span&gt;new&lt;/span&gt; TreeNode&amp;lt;K,V&amp;gt;&lt;span&gt;
                                (h, e.key, e.val, &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
                            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((h &amp;amp; n) == 0&lt;span&gt;) {
                                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((p.prev = loTail) == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                                    lo &lt;/span&gt;=&lt;span&gt; p;
                                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                                    loTail.next &lt;/span&gt;=&lt;span&gt; p;
                                loTail &lt;/span&gt;=&lt;span&gt; p;
                                &lt;/span&gt;++&lt;span&gt;lc;
                            }
                            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((p.prev = hiTail) == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                                    hi &lt;/span&gt;=&lt;span&gt; p;
                                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                                    hiTail.next &lt;/span&gt;=&lt;span&gt; p;
                                hiTail &lt;/span&gt;=&lt;span&gt; p;
                                &lt;/span&gt;++&lt;span&gt;hc;
                            }
                        }
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果一分为二后，节点数少于 8，那么将红黑树转换回链表&lt;/span&gt;
                        ln = (lc &amp;lt;= UNTREEIFY_THRESHOLD) ?&lt;span&gt; untreeify(lo) :
                            (hc &lt;/span&gt;!= 0) ? &lt;span&gt;new&lt;/span&gt; TreeBin&amp;lt;K,V&amp;gt;&lt;span&gt;(lo) : t;
                        hn &lt;/span&gt;= (hc &amp;lt;= UNTREEIFY_THRESHOLD) ?&lt;span&gt; untreeify(hi) :
                            (lc &lt;/span&gt;!= 0) ? &lt;span&gt;new&lt;/span&gt; TreeBin&amp;lt;K,V&amp;gt;&lt;span&gt;(hi) : t;

                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将 ln 放置在新数组的位置 i&lt;/span&gt;
&lt;span&gt;                        setTabAt(nextTab, i, ln);
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将 hn 放置在新数组的位置 i+n&lt;/span&gt;
                        setTabAt(nextTab, i +&lt;span&gt; n, hn);
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将原数组该位置处设置为 fwd，代表该位置已经处理完毕，
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    其他线程一旦看到该位置的 hash 值为 MOVED，就不会进行迁移了&lt;/span&gt;
&lt;span&gt;                        setTabAt(tab, i, fwd);
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; advance 设置为 true，代表该位置已经迁移完毕&lt;/span&gt;
                        advance = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                    }
                }
            }
        }
    }
}&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;article-title&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;article-title&quot;&gt; &lt;/p&gt;
&lt;h4 class=&quot;article-title&quot;&gt;参考资料 / 相关推荐：&lt;/h4&gt;
&lt;p class=&quot;article-title&quot;&gt;&lt;a href=&quot;http://cmsblogs.com/?p=2283&quot;&gt;【死磕Java并发】—–J.U.C之Java并发容器：ConcurrentHashMap&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;article-title&quot;&gt;&lt;a href=&quot;https://my.oschina.net/mononite/blog/144329&quot; target=&quot;_blank&quot;&gt;ConcurrentHashMap使用示例 &lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;article-title&quot;&gt;&lt;a href=&quot;https://blog.csdn.net/zero__007/article/details/49833819&quot; target=&quot;_blank&quot;&gt;ConcurrentHashMap使用示例&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;article-title&quot;&gt;&lt;a href=&quot;https://javadoop.com/post/hashmap#Java8%20HashMap&quot; target=&quot;_blank&quot;&gt;Java7/8 中的 HashMap 和 ConcurrentHashMap 全解析&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;ui teal label horizontal&quot; data-tooltip=&quot;原创&quot;&gt; &lt;/p&gt;
</description>
<pubDate>Tue, 18 Dec 2018 07:36:00 +0000</pubDate>
<dc:creator>那股泥石流</dc:creator>
<og:description>先做总结： 1、HashMap HashTable ConcurrentHashMap HashMap：线程不安全 HashTable：线程安全，每个方法都加了 synchroni</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hexinwei1/p/10000779.html</dc:identifier>
</item>
<item>
<title>dnSpy 强大的.Net反编译软件 - .NET西安社区</title>
<link>http://www.cnblogs.com/xiandnc/p/10132491.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiandnc/p/10132491.html</guid>
<description>&lt;blockquote&gt;
&lt;p&gt;作者：D.泡沫&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一说起.net的反编译软件，大家首先想到的就是Reflector，ILSpy，dotPeek等等。而dnSpy同样是一款优秀的反编译软件，同时它是开源免费的。官方的描述是: dnSpy是一个调试器和.NET组件编辑器。 即使您没有任何可用的源代码，也可以使用它来编辑和调试程序集。&lt;br/&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/xiandnc/1364492/o_dnSpy_P1.png&quot; alt=&quot;此处输入图片的描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个是官方的图片，可以看出和VS的风格还是很像的，使用起来也有很多相似的地方，善于用VS的人，可以很快的上手这个软件。当然除了这个深色的主题以外，还有浅色主题可以切换。&lt;br/&gt;dnSpy使用ILSpy反编译器引擎和Roslyn（C＃/ Visual Basic）编译器以及许多其他开源库，可以编译.Net Framework, .Net Core和Unity游戏部件，不需要源码。今天将给大家演示一下，dnSpy强大的调试和编辑应用程序的功能。&lt;/p&gt;
&lt;h3 id=&quot;debug外部引用的dll文件&quot;&gt;1. Debug外部引用的Dll文件&lt;/h3&gt;
&lt;p&gt;首先准备一个简单的程序，期待的结果是输入人数得到促销后的总价，界面如下：&lt;br/&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/xiandnc/1364492/o_dnSpy_P2.png&quot; alt=&quot;此处输入图片的描述&quot;/&gt;&lt;br/&gt;看一下程序，其实就是简单的取得输入的人数，然后调用第三方类库的方法，得到结果：&lt;br/&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/xiandnc/1364492/o_dnSpy_P3.png&quot; alt=&quot;此处输入图片的描述&quot;/&gt;&lt;br/&gt;这里的Calculator.GetAmountByPromotion方法是_3rdCalculator的第三方类库提供的，我们无法直接确定其内部实现。&lt;/p&gt;
&lt;p&gt;输入一下测试数据：&lt;br/&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/xiandnc/1364492/o_dnSpy_P4.png&quot; alt=&quot;此处输入图片的描述&quot;/&gt;&lt;br/&gt;再输入一下新的测试数据：&lt;br/&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/xiandnc/1364492/o_dnSpy_P5.png&quot; alt=&quot;此处输入图片的描述&quot;/&gt;&lt;br/&gt;会发现很难推测出内部的逻辑。这个时候就可以进行debug了。&lt;br/&gt;打开dnSpy.exe。这个时候请注意，由于这个项目用的是.net core并且是publish的，所以可以直接用dnSpy直接打开publish目录下的要debug的dll文件。&lt;br/&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/xiandnc/1364492/o_dnSpy_P6.png&quot; alt=&quot;此处输入图片的描述&quot;/&gt;&lt;br/&gt;在需要的地方打上断点，然后使用attach的快捷键Ctrl+Alt+P，在弹出的列表里选择&lt;br/&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/xiandnc/1364492/o_dnSpy_P7.png&quot; alt=&quot;此处输入图片的描述&quot;/&gt;&lt;br/&gt;再点击页面的提交按钮触发事件：&lt;br/&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/xiandnc/1364492/o_dnSpy_P8.png&quot; alt=&quot;此处输入图片的描述&quot;/&gt;&lt;br/&gt;这个时候可以看到结果显示在下面Locals的窗口里面。&lt;br/&gt;需要注意的是，如果是不需要publish的，而是直接把整个代码放在IIS下，然后每次编译就是一次发布的情况，不要直接使用代码下面的bin目录里的dll文件，因为IIS会把build出来的dll文件，动态生成一份出来，存到类似于\Windows\Microsoft.NET\Framework64\v4.0.30319\Temporary ASP.NET Files\root\c8367e31\abdb5fb1\assembly\dl3下面的目录里，这个时候要先搜索到你想debug的方法在哪个dll文件里，然后搜索到这个文件位置，再用dnSpy打开它，dnSpy会自动加载和这个dll有关联的所有dll文件，然后启动网站，这个再附加到w3p.exe上就可以了。&lt;/p&gt;
&lt;h3 id=&quot;调试应用程序&quot;&gt;2. 调试应用程序&lt;/h3&gt;
&lt;ol readability=&quot;1.9827089337176&quot;&gt;&lt;li readability=&quot;6.9394812680115&quot;&gt;
&lt;p&gt;调试应用程序&lt;br/&gt;还是以上一个例子为例，这次生成一个exe的文件。&lt;br/&gt;代码如下&lt;br/&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/xiandnc/1364492/o_dnSpy_P9.png&quot; alt=&quot;此处输入图片的描述&quot;/&gt;&lt;br/&gt;运行，窗口如下：&lt;br/&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/xiandnc/1364492/o_dnSpy_P10.png&quot; alt=&quot;此处输入图片的描述&quot;/&gt;&lt;br/&gt;打开dnSpy，找到exe文件的位置，打开要调试的dll文件：&lt;br/&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/xiandnc/1364492/o_dnSpy_P11.png&quot; alt=&quot;此处输入图片的描述&quot;/&gt;&lt;br/&gt;在需要的地方打上断点，点击上面的Start开始调试：&lt;br/&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/xiandnc/1364492/o_dnSpy_P12.png&quot; alt=&quot;此处输入图片的描述&quot;/&gt;&lt;br/&gt;弹出的窗口设置保持默认就可以，程序执行，输入人数后，进入断点，就可以正常调试了：&lt;br/&gt;[此处输入图片的描述][13]&lt;br/&gt;注意，一般dnSpy会把相关的dll都自动加入进来，但是如果是不在一个地方，工具检测不到的，但是有依赖的，必须手动加入进来。&lt;/p&gt;
&lt;h3 id=&quot;修改exe文件的内容&quot;&gt;3. 修改exe文件的内容&lt;/h3&gt;
&lt;p&gt;dnSpy编辑dll文件的功能很方便，不用其他插件或者辅助，就可以进行修改。例如上面的例子，我想把计算逻辑增加超过10个人的时候，优惠更高，那么我可以直接修改dll里面的方法。&lt;br/&gt;首先找到要修改的方法，然后在方法上点击右键：&lt;br/&gt;[此处输入图片的描述][14]&lt;br/&gt;在弹出的新窗口上直接修改方法：&lt;br/&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/xiandnc/1364492/o_dnSpy_P15.png&quot; alt=&quot;此处输入图片的描述&quot;/&gt;&lt;br/&gt;编辑结束后，点击下面的Compile. 然后点击保存所有。继续点OK。&lt;br/&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/xiandnc/1364492/o_dnSpy_P16.png&quot; alt=&quot;此处输入图片的描述&quot;/&gt;&lt;br/&gt;这个时候点击exe文件，输入人数，会发现比10个人的时候还要便宜了很多，就是代码生效了：&lt;br/&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/xiandnc/1364492/o_dnSpy_P17.png&quot; alt=&quot;此处输入图片的描述&quot;/&gt;&lt;br/&gt;以上就是比较常用的功能，当然dnSpy还有很多贴心和有用的功能，有待大家去发现。附上&lt;a href=&quot;https://github.com/0xd4d/dnSpy&quot;&gt;官方地址&lt;/a&gt;，请大家自己去挖掘了。谢谢大家。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Tue, 18 Dec 2018 07:27:00 +0000</pubDate>
<dc:creator>.NET西安社区</dc:creator>
<og:description>作者：D.泡沫 一说起.net的反编译软件，大家首先想到的就是Reflector，ILSpy，dotPeek等等。而dnSpy同样是一款优秀的反编译软件，同时它是开源免费的。官方的描述是: dnSpy</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiandnc/p/10132491.html</dc:identifier>
</item>
<item>
<title>搭建SpringCloud-Eureka 注册中心以及服务提供与调用 - 队长给我球。</title>
<link>http://www.cnblogs.com/JJJ1990/p/10137384.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/JJJ1990/p/10137384.html</guid>
<description>&lt;p&gt;纸上得来终觉浅，绝知此事要躬行啊~果然看着很easy，自己搞起来就是各种坑~各位看官，容我慢慢道来~&lt;/p&gt;
&lt;p&gt;关于springcloud是什么我就不废话了~&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;Eureka &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Eureka（原来以为是缩写，原来就是一个单词，翻译为：我发现了，我找到了！0.0）是Netflix开源的一款提供服务注册和发现的产品，它提供了完整的Service Registry和Service Discovery实现。也是springcloud体系中最重要最核心的组件之一。&lt;/p&gt;
&lt;p&gt;这个东西通俗的理解就像是一个淘宝，你是卖家也好，还是买家也好，你要交易，你得在我这先注册一个账号。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1，先新建一个maven工程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2，在pom文件中引入相关jar包&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;学习大佬的教程，结果用大佬的demo直接报错，启动程序一直提示：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Caused by: java.lang.ClassNotFoundException: com.sun.jersey.api.core.DefaultResourceConfig&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;郁闷，查看spring-cloud-starter-eureka-server   jar包&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1063420/201812/1063420-20181218152028070-1275846195.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;发现其中引入的jersey的jar是1.19.1，然后自己研究，发现1.19可以使用，遂在pom文件中引入，按照我的理解1.19.1肯定比1.19版本高的，怎么反而不行了？&lt;/p&gt;
&lt;p&gt;再启动，然后这个错误是消失了，结果后面又报错，又出来一个servo 包下的类找不到，mmp~又是版本问题，再引入 servo包，ok了~&lt;/p&gt;
&lt;p&gt;最终形成如下的pom配置文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &amp;lt;parent&amp;gt;
&lt;span&gt; 2&lt;/span&gt;        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
&lt;span&gt; 3&lt;/span&gt;        &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;
&lt;span&gt; 4&lt;/span&gt;        &amp;lt;version&amp;gt;1.5.8.RELEASE&amp;lt;/version&amp;gt;
&lt;span&gt; 5&lt;/span&gt;    &amp;lt;/parent&amp;gt;
&lt;span&gt; 6&lt;/span&gt;    
&lt;span&gt; 7&lt;/span&gt;    &amp;lt;dependencies&amp;gt;
&lt;span&gt; 8&lt;/span&gt;     &amp;lt;dependency&amp;gt;
&lt;span&gt; 9&lt;/span&gt;         &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
&lt;span&gt;10&lt;/span&gt;         &amp;lt;artifactId&amp;gt;spring-cloud-starter&amp;lt;/artifactId&amp;gt;
&lt;span&gt;11&lt;/span&gt;     &amp;lt;/dependency&amp;gt;
&lt;span&gt;12&lt;/span&gt;     &amp;lt;dependency&amp;gt;
&lt;span&gt;13&lt;/span&gt;         &amp;lt;groupId&amp;gt;com.sun.jersey&amp;lt;/groupId&amp;gt;
&lt;span&gt;14&lt;/span&gt;            &amp;lt;artifactId&amp;gt;jersey-bundle&amp;lt;/artifactId&amp;gt;
&lt;span&gt;15&lt;/span&gt;              &amp;lt;version&amp;gt;1.19&amp;lt;/version&amp;gt;
&lt;span&gt;16&lt;/span&gt;          &amp;lt;/dependency&amp;gt;
&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;         &amp;lt;dependency&amp;gt;
&lt;span&gt;19&lt;/span&gt;             &amp;lt;groupId&amp;gt;com.netflix.servo&amp;lt;/groupId&amp;gt;
&lt;span&gt;20&lt;/span&gt;             &amp;lt;artifactId&amp;gt;servo-core&amp;lt;/artifactId&amp;gt;
&lt;span&gt;21&lt;/span&gt;             &amp;lt;version&amp;gt;0.12.7&amp;lt;/version&amp;gt;
&lt;span&gt;22&lt;/span&gt;         &amp;lt;/dependency&amp;gt;
&lt;span&gt;23&lt;/span&gt;        &amp;lt;dependency&amp;gt;
&lt;span&gt;24&lt;/span&gt;         &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
&lt;span&gt;25&lt;/span&gt;         &amp;lt;artifactId&amp;gt;spring-cloud-starter-eureka-server&amp;lt;/artifactId&amp;gt;
&lt;span&gt;26&lt;/span&gt; 　       &amp;lt;/dependency&amp;gt;
&lt;span&gt;27&lt;/span&gt;    &amp;lt;/dependencies&amp;gt;
&lt;span&gt;28&lt;/span&gt;    &amp;lt;dependencyManagement&amp;gt;
&lt;span&gt;29&lt;/span&gt;     &amp;lt;dependencies&amp;gt;
&lt;span&gt;30&lt;/span&gt;       &amp;lt;dependency&amp;gt;
&lt;span&gt;31&lt;/span&gt;         &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
&lt;span&gt;32&lt;/span&gt;         &amp;lt;artifactId&amp;gt;spring-cloud-dependencies&amp;lt;/artifactId&amp;gt;
&lt;span&gt;33&lt;/span&gt;         &amp;lt;version&amp;gt;Dalston.RC1&amp;lt;/version&amp;gt;
&lt;span&gt;34&lt;/span&gt;         &amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt;
&lt;span&gt;35&lt;/span&gt;         &amp;lt;scope&amp;gt;&lt;span&gt;import&lt;/span&gt;&amp;lt;/scope&amp;gt;
&lt;span&gt;36&lt;/span&gt;       &amp;lt;/dependency&amp;gt;
&lt;span&gt;37&lt;/span&gt;     &amp;lt;/dependencies&amp;gt;
&lt;span&gt;38&lt;/span&gt;   &amp;lt;/dependencyManagement&amp;gt;
&lt;span&gt;39&lt;/span&gt;    &amp;lt;repositories&amp;gt;
&lt;span&gt;40&lt;/span&gt;     &amp;lt;repository&amp;gt;
&lt;span&gt;41&lt;/span&gt;       &amp;lt;id&amp;gt;spring-milestones&amp;lt;/id&amp;gt;
&lt;span&gt;42&lt;/span&gt;       &amp;lt;name&amp;gt;Spring Milestones&amp;lt;/name&amp;gt;
&lt;span&gt;43&lt;/span&gt;       &amp;lt;url&amp;gt;https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;repo.spring.io/milestone&amp;lt;/url&amp;gt;&lt;/span&gt;
&lt;span&gt;44&lt;/span&gt;       &amp;lt;snapshots&amp;gt;
&lt;span&gt;45&lt;/span&gt;         &amp;lt;enabled&amp;gt;&lt;span&gt;false&lt;/span&gt;&amp;lt;/enabled&amp;gt;
&lt;span&gt;46&lt;/span&gt;       &amp;lt;/snapshots&amp;gt;
&lt;span&gt;47&lt;/span&gt;     &amp;lt;/repository&amp;gt;
&lt;span&gt;48&lt;/span&gt;   &amp;lt;/repositories&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;3，编写启动类代码&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;@SpringBootApplication
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;@EnableEurekaServer
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; App {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; 
&lt;span&gt;5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;         SpringApplication.run(App.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, args);
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意添加EnableEurekaServer注解&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4，添加配置文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于这个配置文件的添加有2种格式，一种是application.properties 另外一种是 application.yaml。对于2种格式的区别，我们不做比较。但是对于这个文件的位置，我还是纳闷了一会，最后经过尝试，如图所示位置&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1063420/201812/1063420-20181218121822081-1464819913.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 并且需要注意文件名称一个字母都不能少0.0，我就是由于没注意少写个字母，也报错了。。。。&lt;/p&gt;
&lt;p&gt;application.properties 格式，文件内容如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; spring.application.name=spring-cloud-&lt;span&gt;eureka
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; server.port=8000
&lt;span&gt;3&lt;/span&gt; eureka.client.register-with-eureka=&lt;span&gt;false&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; eureka.client.fetch-registry=&lt;span&gt;false&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt; eureka.client.serviceUrl.defaultZone=http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;localhost:${server.port}/eureka/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意第3 行默认是true也就是如果你不加上这个false，启动就会报错，因为他会想把自己注册到自己上面！！！第4行默认也是true，意思是他要不要获取注册到服务中心的信息 &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5，启动注册中心&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在浏览器输入 localhost：8000，查看注册中心是否正常启动，出现如下截图，说明已经ok&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1063420/201812/1063420-20181218144248924-2047748582.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;有了注册中心，我们在接着搞一个服务提供者，和服务消费者。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;服务提供者&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1，新建maven工程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2，在pom文件中引入和注册中心服务一样的jar包。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3，编写application.properties&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;内容如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; spring.application.name=spring-cloud-&lt;span&gt;producer
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; server.port=9000
&lt;span&gt;3&lt;/span&gt; eureka.client.serviceUrl.defaultZone=http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;localhost:8000/eureka/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第一行是给自己的服务命名，第二行设置自己的访问端口，第三行设置自己要注册到那个注册中心，因为我们在上面设置了eureka注册中心是本地的8000端口，所以就写这个地址&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4，编写启动类代码&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;@SpringBootApplication
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;@EnableDiscoveryClient
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; App 
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main( String[] args )
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;         SpringApplication.run(App.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, args);
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意添加 EnableDiscoveryClient 注解&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5，编写服务控制器类代码&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;@RestController
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HelloController {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     
&lt;span&gt;4&lt;/span&gt;     @RequestMapping(&quot;/hello&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String hello(@RequestParam String name) {
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &quot;hello &quot;+name+&quot;，nice to meet you!&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 到这里 服务提供者完成，启动程序，无报错即可，刷新注册中心的页面，会看到Application中当前注册的服务。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;服务调用者&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1，新建maven工程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2，同样在pom文件中引入和之前一样的内容。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3，编写application.properties&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; spring.application.name=spring-cloud-&lt;span&gt;consumer
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; server.port=9001
&lt;span&gt;3&lt;/span&gt; eureka.client.serviceUrl.defaultZone=http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;localhost:8000/eureka/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第一行也是给当前服务起名字，第二行设置端口，第三行设置注册中心url。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4，编写启动类代码&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;@SpringBootApplication
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;@EnableDiscoveryClient
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;@EnableFeignClients
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; App 
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main( String[] args )
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         SpringApplication.run(App.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, args);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意这个启动类，比服务提供者多了一个EnableFeignClients注解，这个注解的作用就是启用feign进行远程调用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5，编写feign调用实现&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; @FeignClient(name= &quot;spring-cloud-producer&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; HelloRemote {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     @RequestMapping(value = &quot;/hello&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; String hello(@RequestParam(value = &quot;name&quot;&lt;span&gt;) String name);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意这是一个接口，上面的注解参数name，就是指定你当前要调用的服务提供者名称。另外还要注意方法中的参数name 和服务提供者中的参数保持一致&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6，编写服务调用者控制器类&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;@RestController
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ConsumerController {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    @Autowired
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    HelloRemote HelloRemote;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     
&lt;span&gt; 7&lt;/span&gt;     @RequestMapping(&quot;/hello/{name}&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; String hello(@PathVariable(&quot;name&quot;&lt;span&gt;) String name) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; HelloRemote.hello(name);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在当前类中引入HelloRemote 接口，通过调用本地hello方法，然后再调用HelloRemote 接口中的方法&lt;/p&gt;
&lt;p&gt;启动程序，无报错即可。&lt;/p&gt;

&lt;p&gt;刷新注册中心这个时候应该可以看到2个服务已经注册&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1063420/201812/1063420-20181218144846549-618369374.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;测试验证&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 打开浏览器输入 :  http://localhost:9001/hello/JJ&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1063420/201812/1063420-20181218145035352-1943042512.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图正常返回结果，说明整个服务调用和提供者ok！！！&lt;/p&gt;

</description>
<pubDate>Tue, 18 Dec 2018 07:26:00 +0000</pubDate>
<dc:creator>队长给我球。</dc:creator>
<og:description>纸上得来终觉浅，绝知此事要躬行啊~果然看着很easy，自己搞起来就是各种坑~各位看官，容我慢慢道来~ 关于springcloud是什么我就不废话了~ Eureka Eureka（原来以为是缩写，原来就</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/JJJ1990/p/10137384.html</dc:identifier>
</item>
<item>
<title>从Client应用场景介绍IdentityServer4（二） - 烟花易冷人憔悴</title>
<link>http://www.cnblogs.com/FireworksEasyCool/p/10137011.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/FireworksEasyCool/p/10137011.html</guid>
<description>&lt;p&gt;&lt;span&gt;本节介绍Client的&lt;span&gt;ClientCredentials&lt;/span&gt;客户端授权模式，先看下画的草图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1508611/201812/1508611-20181218151938102-888316947.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;一、在Server上添加动态新增Client的API 接口。&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;为了方便测试，在Server服务端中先添加swagger，添加流程可参考：&lt;a href=&quot;https://www.cnblogs.com/suxinlcq/p/6757556.html&quot;&gt;https://www.cnblogs.com/suxinlcq/p/6757556.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;在ValuesController控制器中注入ConfigurationDbContext上下文，此上下文可用来加载或配置IdentityServer4.EntityFramework的Client、身份信息、API资源信息或CORS数据等。&lt;/p&gt;
&lt;p&gt;在ValuesController中实添加以下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;        private&lt;/span&gt;&lt;span&gt; ConfigurationDbContext _context;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ValuesController(ConfigurationDbContext context)
        {
            _context &lt;/span&gt;=&lt;span&gt; context;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;添加动态新增Client的API接口：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;        [HttpPost]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; IActionResult Post([FromBody] IdentityServer4.EntityFramework.Entities.Client client)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; res =&lt;span&gt; _context.Clients.Add(client);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(_context.SaveChanges() &amp;gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Ok(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt; Ok(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;控制器代码如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1508611/201812/1508611-20181218140841685-797647901.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;h3&gt;&lt;span&gt;二、对Server上的API进行保护&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;（1）&lt;strong&gt;安装IdentityServer4.AccessTokenValidation包&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（2）在startup.cs中ConfigureServices方法添加如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;            //&lt;/span&gt;&lt;span&gt;protect API&lt;/span&gt;
&lt;span&gt;            services.AddMvcCore()
            .AddAuthorization()
            .AddJsonFormatters();

            services.AddAuthentication(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Bearer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                .AddIdentityServerAuthentication(options &lt;/span&gt;=&amp;gt;&lt;span&gt;
                {
                    options.Authority &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:5000&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                    options.RequireHttpsMetadata &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

                    options.ApiName &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;api1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;AddAuthentication&lt;/span&gt;把Bearer配置成默认模式，将身份认证服务添加到DI中。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;AddIdentityServerAuthentication&lt;/span&gt;把IdentityServer的access token添加到DI中，供身份认证服务使用。&lt;/p&gt;
&lt;p&gt;（3）在startup.cs中Configure方法添加如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
      &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Configure(IApplicationBuilder app, IHostingEnvironment env)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;if (env.IsDevelopment())
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    app.UseDeveloperExceptionPage();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;}

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;AddSwagger&lt;/span&gt;
&lt;span&gt;            app.UseSwagger();
            app.UseSwaggerUI(c &lt;/span&gt;=&amp;gt;&lt;span&gt;
            {
                c.SwaggerEndpoint(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/swagger/v1/swagger.json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Server接口文档&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            });

            InitializeDatabase(app);
            app.UseAuthentication();
            app.UseIdentityServer();
            app.UseMvc();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;UseAuthentication&lt;/span&gt;将身份验证中间件添加到管道中，以便在每次调用主机时自动执行身份验证。&lt;/p&gt;
&lt;p&gt;（4）在ValuesController控制器中添加&lt;span&gt;[Authorize]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1508611/201812/1508611-20181218141446312-831513910.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;（5）在项目属性-&amp;gt;调试 中，启动浏览器，并设成swagger，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1508611/201812/1508611-20181218141526997-1688345644.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（6）启动项目，并调用第一个Get接口。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1508611/201812/1508611-20181218141604422-987008210.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;显示Unauthorized（未授权），证明&lt;span&gt;[Authorize]&lt;/span&gt;起作用了。&lt;/p&gt;
&lt;hr/&gt;
&lt;h3&gt;&lt;span&gt;三、搭建Client客户端&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;（1）新建一个控制台程序，&lt;strong&gt;安装IdentityModel包&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;（2）添加类IDSHelper.cs，添加客户端请求API接口代码。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; IDSHelper
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task MainAsync()
        {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                DiscoveryResponse disco &lt;/span&gt;= &lt;span&gt;await&lt;/span&gt; DiscoveryClient.GetAsync(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:5000&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (disco.IsError)
                {
                    Console.WriteLine(disco.Error);
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
                }

                TokenClient tokenClient &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; TokenClient(disco.TokenEndpoint, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Client&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;secret&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; tokenResponse = &lt;span&gt;await&lt;/span&gt; tokenClient.RequestClientCredentialsAsync(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;api1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (tokenResponse.IsError)
                {
                    Console.WriteLine(tokenResponse.Error);
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
                }
                Console.WriteLine(tokenResponse.Json);
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; client = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpClient();
                client.SetBearerToken(tokenResponse.AccessToken);
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; response = &lt;span&gt;await&lt;/span&gt; client.GetAsync(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:5000/api/values/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;response.IsSuccessStatusCode)
                {
                    Console.WriteLine(response.StatusCode);
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                {
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; content = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; response.Content.ReadAsStringAsync();
                    Console.WriteLine(content);
                }
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
            {

            }
        }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（3）修改Program.cs代码，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
       &lt;/span&gt;=&amp;gt;&lt;span&gt; IDSHelper.MainAsync().GetAwaiter().GetResult();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（4）按Ctrl+F5，可以获取到access token和接口返回值&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1508611/201812/1508611-20181218141920471-395229309.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;复制token，用postman调用，成功获取到了接口返回值。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1508611/201812/1508611-20181218141957877-1260672693.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;h3&gt;&lt;span&gt;四、测试动态新增Client接口&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;安装IdentityServer4&lt;/strong&gt;&lt;strong&gt;包。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;安装IdentityServer4.EntityFramework&lt;/strong&gt;&lt;strong&gt;包。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在IDSHelper.cs类中添加Post方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task Post()
        {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                DiscoveryResponse disco &lt;/span&gt;= &lt;span&gt;await&lt;/span&gt; DiscoveryClient.GetAsync(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:5000&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (disco.IsError)
                {
                    Console.WriteLine(disco.Error);
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
                }

                TokenClient tokenClient &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; TokenClient(disco.TokenEndpoint, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Client&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;secret&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; tokenResponse = &lt;span&gt;await&lt;/span&gt; tokenClient.RequestClientCredentialsAsync(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;api1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (tokenResponse.IsError)
                {
                    Console.WriteLine(tokenResponse.Error);
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
                }
                Console.WriteLine(tokenResponse.Json);
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; client = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpClient();
                client.SetBearerToken(tokenResponse.AccessToken);

                Client c1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Client
                {
                    ClientId &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Test&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    AllowedGrantTypes &lt;/span&gt;=&lt;span&gt; GrantTypes.ClientCredentials,
                    ClientSecrets &lt;/span&gt;=&lt;span&gt;
                    {
                        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Secret(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;secret&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.Sha256())
                    },
                    AllowedScopes &lt;/span&gt;= { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;api1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; }
                };
                &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; strJson =&lt;span&gt; JsonConvert.SerializeObject(c1 .ToEntity());
                HttpContent content &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringContent(strJson);
                content.Headers.ContentType &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; System.Net.Http.Headers.MediaTypeHeaderValue(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;application/json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;由HttpClient发出Post请求&lt;/span&gt;
                Task&amp;lt;HttpResponseMessage&amp;gt; response = client.PostAsync(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:5000/api/values/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, content);

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (response.Result.StatusCode !=&lt;span&gt; System.Net.HttpStatusCode.OK)
                {
                    Console.WriteLine(response.Result.StatusCode);
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                {
                    Console.WriteLine(response.Result.Content.ReadAsStringAsync().Result);
                }
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
            {

            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;顺便把main中改成对Post调用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)

       &lt;/span&gt;=&amp;gt; IDSHelper.Post().GetAwaiter().GetResult();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;按Ctrl+F5，调用新增Client的接口，并成功返回true。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1508611/201812/1508611-20181218142129630-242009466.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;同时可以在数据库中的Client表找到相关记录。需要注意的是，不能添加相同&lt;span&gt;Client ID&lt;/span&gt;的Client。&lt;/p&gt;
&lt;hr/&gt;
&lt;h3&gt;&lt;span&gt;五、在Client中添加Claim信息，并在API接口中对Claim信息进行验证。&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;关于Claim的介绍可以看这篇文章：&lt;a href=&quot;http://www.cnblogs.com/stulzq/p/8726002.html&quot;&gt;http://www.cnblogs.com/stulzq/p/8726002.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这里把Claim简单当做用户的身份信息使用，修改Post方法里面的Client：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
                Client c1 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Client
                {
                    ClientId &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;superAdmin&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    AllowedGrantTypes &lt;/span&gt;=&lt;span&gt; GrantTypes.ClientCredentials,
                    ClientSecrets &lt;/span&gt;=&lt;span&gt;
                    {
                        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Secret(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;secret&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.Sha256())
                    },
                    AllowedScopes &lt;/span&gt;= { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;api1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; },
                    Claims &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; List&amp;lt;Claim&amp;gt;&lt;span&gt;
                    {
                        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Claim(JwtClaimTypes.Role, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;admin&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                    }
                };&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看出，Claims为List，可以是很多个角色，这里只添加一个。&lt;/p&gt;
&lt;p&gt;Ctrl+F5，运行成功添加superAdmin Client。&lt;/p&gt;

&lt;p&gt;现在，需要对Server服务端的新增Client接口进行Claim身份验证，添加如下代码：&lt;/p&gt;
&lt;p&gt;   &lt;span&gt;[Authorize(Roles =&quot;admin&quot;)]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1508611/201812/1508611-20181218142452641-892861467.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后再客户端修改授权的账号为superadmin。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;TokenClient tokenClient = new TokenClient(disco.TokenEndpoint, &quot;superAdmin&quot;, &quot;secret&quot;);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Ctrl+F5运行&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1508611/201812/1508611-20181218142541923-1706882202.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;问题出现了，返回了Forbidden，没有权限进行访问。&lt;/p&gt;
&lt;p&gt;这时候我们上官网查阅了资料，发现在添加Client的Claim时候，IdentityServer EntityFramework会为Claim的role添加一个默认前缀，为&lt;span&gt;client_。&lt;/span&gt;所以，实际上它为&lt;span&gt;client_role&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;而服务端只能对&lt;span&gt;role&lt;/span&gt;进行验证。&lt;/p&gt;
&lt;p&gt;此时我们需要把Claim的默认前缀去掉，设置为空&lt;span&gt;ClientClaimsPrefix = &quot;&quot;&lt;/span&gt; 。&lt;/p&gt;

&lt;p&gt;去掉Server的Role验证，添加形如下面代码的Client。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
Client c1 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Client
                {
                    ClientId &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;adminClient&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    AllowedGrantTypes &lt;/span&gt;=&lt;span&gt; GrantTypes.ClientCredentials,
                    ClientSecrets &lt;/span&gt;=&lt;span&gt;
                    {
                        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Secret(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;secret&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.Sha256())
                    },
                    AllowedScopes &lt;/span&gt;= { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;api1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; },
                    Claims &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; List&amp;lt;Claim&amp;gt;&lt;span&gt;
                    {
                        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Claim(JwtClaimTypes.Role, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;admin&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                    },
                    ClientClaimsPrefix &lt;/span&gt;= &lt;span&gt;&quot;&quot;&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;把client_ 前缀去掉&lt;/span&gt;
                };
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; Ctrl+F5，运行成功添加adminClient Client，这次的是Role为admin。&lt;/p&gt;
&lt;p&gt;然后重新再Server服务端加上&lt;span&gt;[Authorize(Roles =&quot;admin&quot;)]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;同时修改验证账号为adminClient。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;TokenClient tokenClient = new TokenClient(disco.TokenEndpoint, &quot;adminClient&quot;, &quot;secret&quot;);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;最后运行程序，成功地在&lt;span&gt;[Authorize(Roles =&quot;admin&quot;)]&lt;/span&gt;权限下访问并新增了Client。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1508611/201812/1508611-20181218142822107-434277514.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;h3&gt;&lt;span&gt;六、需要注意的问题&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;（1）新增Client到数据库时候，这里需要接收&lt;span&gt;IdentityServer4.EntityFramework.Entities.Client&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;而不是&lt;span&gt;IdentityServer4.Models.Client&lt;/span&gt;，否则API接口在接收和转化Client模型的时候会报错。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1508611/201812/1508611-20181218143007416-1679763811.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（2）此外，本节介绍的&lt;span&gt;Client的AllowedGrantTypes&lt;/span&gt; 都为 &lt;span&gt;GrantTypes.ClientCredentials&lt;/span&gt;，相应的，客户端请求是，需要用&lt;span&gt;RequestClientCredentialsAsync&lt;/span&gt;方法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1508611/201812/1508611-20181218143102208-1981668333.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后再次提下，ClientCredentials模式的适用场景：&lt;span&gt;用于和用户无关，服务与服务之间直接交互访问资源&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;Server服务端源码地址：https://github.com/Bingjian-Zhu/Server&lt;/p&gt;
&lt;p&gt;Client客户端源码地址：https://github.com/Bingjian-Zhu/Client&lt;/p&gt;
&lt;p&gt;文中如有错漏，欢迎指正。&lt;/p&gt;
</description>
<pubDate>Tue, 18 Dec 2018 06:51:00 +0000</pubDate>
<dc:creator>烟花易冷人憔悴</dc:creator>
<og:description>本节介绍Client的ClientCredentials客户端授权模式，先看下画的草图： 一、在Server上添加动态新增Client的API 接口。 为了方便测试，在Server服务端中先添加swa</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/FireworksEasyCool/p/10137011.html</dc:identifier>
</item>
<item>
<title>探究 CSS 混合模式\滤镜导致 CSS 3D 失效问题 - ChokCoco</title>
<link>http://www.cnblogs.com/coco1s/p/10137045.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/coco1s/p/10137045.html</guid>
<description>&lt;p&gt;&lt;span&gt;今天在写一个小的 CSS Demo，一个关于 3d 球的旋转动画，关于 CSS 3D，少不了会使用下面这几个属性：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:css;gutter:true;&quot;&gt;
{
    transform-style: preserve-3d;
    perspective: 1000;
    transform: translate3d();
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这个 Demo 你可以戳这里，大概是这样：&lt;a href=&quot;https://codepen.io/Chokcoco/pen/JwdvmJ&quot; rel=&quot;nofollow&quot;&gt;CodePen Demo - 3D ball&lt;/a&gt;:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://user-images.githubusercontent.com/8554143/50084389-cf889a80-0231-11e9-9f76-483375136a2c.gif&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/8554143/50084389-cf889a80-0231-11e9-9f76-483375136a2c.gif&quot; alt=&quot;3dball&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;嗯，大概到了这个效果，想到了 CSS 混合模式 &lt;code&gt;mix-blend-mode&lt;/code&gt;，寻思着，利用混合模式，是否能让效果更上一层楼或者碰撞出一些其他火花。&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;mix-blend-mode&lt;/code&gt;：我们通常称之为混合模式，利用混合模式将多个图层混合可以得到一个新的效果，&lt;code&gt;mix-blend-mode&lt;/code&gt; 描述了元素的内容应该与元素的直系父元素的内容和元素的背景如何混合。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;2.0506329113924&quot;&gt;
&lt;p&gt;&lt;span&gt;关于混合模式的一些使用可以看这里：&lt;a href=&quot;https://github.com/chokcoco/iCSS/issues/31&quot; data-hovercard-type=&quot;issue&quot; data-hovercard-url=&quot;/chokcoco/iCSS/issues/31/hovercard&quot;&gt;不可思议的混合模式 background-blend-mode (二)&lt;/a&gt;、&lt;a href=&quot;https://github.com/chokcoco/iCSS/issues/16&quot; data-hovercard-type=&quot;issue&quot; data-hovercard-url=&quot;/chokcoco/iCSS/issues/16/hovercard&quot;&gt;不可思议的混合模式 background-blend-mode&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;

&lt;p&gt;&lt;span&gt;然而，给元素加上了一个混合模式之后，神奇的事情发生了，3D 效果消失了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;也就是在每个光点的 CSS 元素代码中添加这样一句：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:css;gutter:true;&quot;&gt;
{
    mix-blend-mode: lighten;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://user-images.githubusercontent.com/8554143/50085117-19728000-0234-11e9-9184-218fb907fb88.gif&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/8554143/50085117-19728000-0234-11e9-9184-218fb907fb88.gif&quot; alt=&quot;3dball2&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;效果从 CSS 3D 变成了 2D。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://user-images.githubusercontent.com/8554143/50085220-5f2f4880-0234-11e9-9885-85de933da654.png&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/8554143/50085220-5f2f4880-0234-11e9-9885-85de933da654.png&quot; alt=&quot;qq 20181217194534&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这就很蹊跷了，预想中的混合并没有发生，取而代之的是 3D 的失效。我想，也许与内核有关，上面的效果是在 chrome 65.0.3325.181 试验得到的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;是否与浏览器内核有关？&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;带着这样的疑问，我又测试了下其他几个内核：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;firefox 64.0 -- 这次更加诡异，整个图案都不会再被渲染出来&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Safari 12.0.2 -- 渲染正常&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;Safari 是可以正常展示的，只能初略的认为，应该是与内核有关系的。那应该也有很多人遇到过同样的问题，带着这个疑惑，google 一下。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;爆栈网也有同学提出类似的疑惑：&lt;a href=&quot;https://stackoverflow.com/questions/32932966/mix-blend-mode-is-broken-by-3d-transformations-on-page&quot; rel=&quot;nofollow&quot;&gt;StackOverflow -- mix-blend-mode is broken by 3D transformations on page&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://user-images.githubusercontent.com/8554143/50085960-9bfc3f00-0236-11e9-9057-f629bc1ed4ea.png&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/8554143/50085960-9bfc3f00-0236-11e9-9057-f629bc1ed4ea.png&quot; alt=&quot;image&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;随后，在 chromium bug 提交网站上，找到了 15 年的一个 bug 单，也是对这个问题的疑问：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://bugs.chromium.org/p/chromium/issues/detail?id=543445&quot; rel=&quot;nofollow&quot;&gt;BUG -CSS mix-blend-mode turns off CSS perspective.&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最终在 bug 单的最下面找到了可能靠谱的回答：&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span&gt;When we have mix-blend-mode, the closest ancestor that creates stacking context will isolate blending. We create a render surface at the root of this isolated group and because render surfaces don't support preserve-3d(because they render into separate FBO), we see a flattened result.&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;ajuma@ suggested that this bug maybe much easier to fix after Slimming paint v2 if we can somehow disentangle transforms from layers.&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;翻译一下，意思大概是：当我们使用 CSS 混合模式的时候，堆叠上下文会重新对这个使用了混合模式的元素的根节点处创建一个独立的渲染平面，但是很可惜，这个渲染平面是不支持 preserve-3d 的(因为它们渲染到单独的FBO中)，所以我们看到是一个 2D 的平面效果。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;验证 Layer borders&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;上面的那句话应该已经可以作为结论，我再使用 chrome 提供的工具验证一下，打开开发者工具的 Rendering -&amp;gt; Layer borders：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://user-images.githubusercontent.com/8554143/50087913-7eca6f00-023c-11e9-9858-eb8c637f11d7.png&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/8554143/50087913-7eca6f00-023c-11e9-9858-eb8c637f11d7.png&quot; alt=&quot;image&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;黄色代表 CSS 渲染时候的 GraphicsLayer 层， 蓝色网格表示瓦片(tile)，你可以把它们当作是层的单元（并不是层），Chrome 内核可以将它们作为一个大层的部分上传给 GPU 进行渲染加速。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;正常 3D 模式下，开启 Layer borders 效果：&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://user-images.githubusercontent.com/8554143/50088210-4ecf9b80-023d-11e9-8e57-4afe95724a50.gif&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/8554143/50088210-4ecf9b80-023d-11e9-8e57-4afe95724a50.gif&quot; alt=&quot;balllayer&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;添加了 &lt;code&gt;mix-blend-mode&lt;/code&gt; 的 3D 模式下，开启 Layer borders 效果：&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://user-images.githubusercontent.com/8554143/50088230-5bec8a80-023d-11e9-8f5d-6ddabc877515.gif&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/8554143/50088230-5bec8a80-023d-11e9-8f5d-6ddabc877515.gif&quot; alt=&quot;balllayer2&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以看到，在 &lt;code&gt;mix-blend-mode&lt;/code&gt; 的 3D 模式下，确实在整个球形元素之外，又多了一层蓝色 tile。也就是上文提到的独立的渲染平面，也就是因为这个渲染平面不支持 preserve-3d 的原因，我们最终得到了一个 2D 平面图形。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;滤镜也会导致 CSS 3D 失效&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;完了吗？没有。不是吧，这谁顶得住啊。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://user-images.githubusercontent.com/8554143/50129854-e5d83a00-02b5-11e9-8491-5b8006e73a5c.png&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/8554143/50129854-e5d83a00-02b5-11e9-8491-5b8006e73a5c.png&quot; alt=&quot;qq 20181218111248&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那么如果是因为 &lt;code&gt;mix-blend-mode&lt;/code&gt; 多生成了一个独立渲染平面导致的 3D 失效，那么是否有其他元素也会导致同样的结果呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;带着疑惑，去掉了 &lt;code&gt;mix-blend-mode&lt;/code&gt;，我又给设置了 3d 的元素添加了一个滤镜：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:css;gutter:true;&quot;&gt;
{
-    mix-blend-mode: lighten;
+    filter: blur(1px);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;果然，出现了同样的问题，3D 失效：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://user-images.githubusercontent.com/8554143/50088811-0d3ff000-023f-11e9-8e16-48c9a7bafd06.gif&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/8554143/50088811-0d3ff000-023f-11e9-8e16-48c9a7bafd06.gif&quot; alt=&quot;balllayer3&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;总结一下&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;嗯。那么应该可以初步得到一个结论就是所有这些在渲染时候需要再独立生成一个渲染平面，且包含了 preserve-3d 的属性，都会导致内部的 CSS 3D 失效。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;暂时我发现的有下述几个属性，都会导致 CSS 3D 失效：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;code&gt;mix-blend-mode&lt;/code&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;code&gt;background-blend-mode&lt;/code&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;code&gt;filter&lt;/code&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;
&lt;h2&gt;&lt;span&gt;其他问题&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;这个 bug 有什么影响&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;额，通常来说，很少会有人在使用 CSS 3D 的同时使用混合模式或者滤镜，这两个属性更多的锦上添花的作用，所以大部分时候，不使用它们就不会有问题， 所以影响不是很大。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;上文中的 FBO 是什么？&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;上文的 &lt;code&gt;FBO&lt;/code&gt; 准确而言是什么我也无法 100% 确定，推测应该是 Frame Buffer Object，帧缓存对象，存在于显存中。帧缓存是一些二维数组和 OpenGL 所使用的存储区的集合：颜色缓存、深度缓存、模板缓存和累计缓存。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;各种三维场景现在渲染到屏幕上都是先放到一个 FBO 中，可以理解为一张离屛图片，用于加速渲染。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;Bug 何时会被修复&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;在 chromium bugs 网站，上述 bug 被合并到 &lt;a href=&quot;https://bugs.chromium.org/p/chromium/issues/detail?id=575099&quot; rel=&quot;nofollow&quot;&gt;issue 575099&lt;/a&gt;，并且最终状态是 Untriaged，表示尚未分配优先级，意思是等待某人确定哪个人应该认领并修复该特定错误。所以，短期内可能无望解决。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;
&lt;h2&gt;&lt;span&gt;最后&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;感谢耐心读完。更多精彩 CSS 技术文章汇总在我的 &lt;a href=&quot;https://github.com/chokcoco/iCSS&quot;&gt;Github -- iCSS&lt;/a&gt; ，持续更新，欢迎点个 star 订阅收藏。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;好了，本文到此结束，希望对你有帮助 :)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果还有什么疑问或者建议，可以多多交流，原创文章，文笔有限，才疏学浅，文中若有不正之处，万望告知。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 18 Dec 2018 06:47:00 +0000</pubDate>
<dc:creator>ChokCoco</dc:creator>
<og:description>今天在写一个小的 CSS Demo，一个关于 3d 球的旋转动画，关于 CSS 3D，少不了会使用下面这几个属性： 这个 Demo 你可以戳这里，大概是这样：CodePen Demo - 3D bal</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/coco1s/p/10137045.html</dc:identifier>
</item>
<item>
<title>深入学习决策树算法原理 - 战争热诚</title>
<link>http://www.cnblogs.com/wj-1314/p/9428494.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wj-1314/p/9428494.html</guid>
<description>&lt;p&gt;　　分类技术（或分类法）是一种根据输入数据建立分类模型的系统方法，分类法的例子包括决策分类法，基于规则的分类法，神经网络，支持向量机和朴素贝叶斯分类法。这些技术都使用一种学习算法（learning algorithm）确定分类模型，该模型能够很好的拟合输入数据中类标号和属性集之间的联系，学习算法得到的模型不仅要很好地拟合输入数据，还要能够正确的预测未知样本的类标号。因此，训练算法的主要目标就是建立具有很好泛化能力模型，即建立能够准确的预测未知样本类标号的模型。&lt;/p&gt;
&lt;p&gt;　　那我们首先说一下分类与回归的区别。&lt;/p&gt;
&lt;h3&gt;回归（regression）&lt;/h3&gt;
&lt;p&gt;　　回归问题的应用场景（预测的结果是连续的，例如预测明天的温度：23,24,25度等等）&lt;/p&gt;
&lt;p&gt;　　所以说回归问题通常是用来预测一个值，如预测房价，未来的天气情况等等，例如一个产品的实际价格为500元，通过回归分析预测值为501元，我们认为这是一个比较好的回归分析。一个比较常见的回归算法是线性回归算法（LR）。另外，回归分析用在神经网络上，其最上层是不需要softmax函数的，而是直接对前一层累加即可。回归是对真实值的一种逼近预测。&lt;/p&gt;
&lt;h3&gt;分类（classification）&lt;/h3&gt;
&lt;p&gt;　　分类问题的应用场景（预测的结果是离散的，例如预测明天天气：阴，晴，雨等等）&lt;/p&gt;
&lt;p&gt;　　例如判断一幅图片上的动物是一只猫还是一只狗，分类通常是建立在回归之上，分类的最后一层通常要使用softmax函数进行判断其所属类别。分类并没有逼近的概念，最终正确结果只有一个，错误的就是错误的，不会有相近的概念。最常见的分类方法是逻辑回归，或者叫逻辑分类。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201812/1226410-20181213115240279-767945433.png&quot; alt=&quot;&quot; width=&quot;599&quot; height=&quot;119&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;如何选择模型呢?（我们借助别人的图来选择分类，回归，聚类，降维）&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201812/1226410-20181213111956082-148247245.png&quot; alt=&quot;&quot; width=&quot;592&quot; height=&quot;370&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　决策数(Decision Tree)在机器学习中也是比较常见的一种算法，属于监督学习中的一种。看字面意思应该也比较容易理解，相比其他算法比如支持向量机(SVM)或神经网络，似乎决策树感觉“亲切”许多。&lt;/p&gt;
&lt;h2&gt;决策树算法思想&lt;/h2&gt;
&lt;p&gt;　　决策树（decision tree）是一个树结构（可以是二叉树或者非二叉树）。决策树分为分类树和回归树两种，分类树对离散变量做决策树，回归树对连续变量做决策树。&lt;/p&gt;
&lt;p&gt;　　其中每个非叶节点表示一个特征属性上的测试，每个分支代表这个特征属性在某个值域上的输出，而每个叶节点存放在一个类别。&lt;/p&gt;
&lt;p&gt;　　使用决策树进行决策的过程就是从根节点开始，测试待分类项中相应的特征属性，并按照其值选择输出分支，知道到达叶子节点，将叶子节点存放的类别作为决策结果。&lt;/p&gt;
&lt;h3&gt;决策树学习算法主要由三部分构成&lt;/h3&gt;
&lt;h4&gt;特征选择&lt;/h4&gt;
&lt;p&gt;　　特征选择是指从训练数据中众多的特征中选择一个特征作为当前节点的分裂标准，如何选择特征有着很多不同量化评估标准，从而衍生出不同的决策树算法。&lt;/p&gt;
&lt;h4&gt;决策树生成&lt;/h4&gt;
&lt;p&gt;　　根据选择的特征评估标准，从上至下递归地生成子节点，直到数据集不可分则停止决策树停止生长。树结构来说，递归结构是最容易理解的方式。&lt;/p&gt;
&lt;h4&gt;决策树的剪枝&lt;/h4&gt;
&lt;p&gt;　　决策树容易过拟合，一般来需要剪枝，缩小树结构规则，缓解过拟合，剪枝技术有预剪枝和后剪枝两种。&lt;/p&gt;
&lt;h3&gt; 决策实例一&lt;/h3&gt;
&lt;p&gt;决策树表示如下（借用周志华老师西瓜书的图）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201812/1226410-20181217105657009-1297850715.png&quot; alt=&quot;&quot; width=&quot;583&quot; height=&quot;345&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　假如我现在告诉你，我买了一个西瓜，它的特点是纹理是清晰，根蒂是硬挺的瓜，你来给我判断一下是好瓜还是坏瓜，恰好，你构建了一颗决策树，告诉他，没问题，我马上告诉你是好瓜，还是坏瓜？&lt;/p&gt;
&lt;p&gt;　　判断步骤如下：&lt;/p&gt;
&lt;p&gt;　　根据纹理特征，已知是清晰，那么走下面这条路，红色标记：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201812/1226410-20181217110614191-1289435636.png&quot; alt=&quot;&quot; width=&quot;574&quot; height=&quot;340&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　好了，现在到了第二层，这个时候，由决策树的图，我们可以看到，我们需要知道根蒂的特征时什么了？，对时硬挺，于是我们继续走，如下蓝色的图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201812/1226410-20181217110739257-1549500577.png&quot; alt=&quot;&quot; width=&quot;576&quot; height=&quot;342&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　此时，我们到达叶子结点了，根据上面总结的店，可知，叶子结点代表一种类别，我们从如上决策树中可以知道，这是一个坏瓜！！&lt;/p&gt;
&lt;p&gt;　　所以根据上面的例子，非常直观容易的得到了一个实例的类别判断，只要你告诉我各个特征的具体值，决策树的判定过程就相当于树中从跟节点到某一个叶子节点的遍历，每一步如何遍历是由数据各个特征的具体特征属性决定。&lt;/p&gt;
&lt;p&gt;　　好了，可能有人要问了，说了这么多，给你训练数据，你的决策树是怎么构建的呢？没有树，谈何遍历，谈何分类？&lt;/p&gt;
&lt;p&gt;　　于是构建决策树也就成了最重要的工作！！&lt;/p&gt;
&lt;p&gt;　　比如，给我下面的训练数据，我们如何构建出决策树？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201812/1226410-20181217111241480-2032624640.png&quot; alt=&quot;&quot; width=&quot;598&quot; height=&quot;373&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　我们可以从上面的决策树看出，每一次子结点的产生，是由于我在当前层数选择了不同的特征来作为我的分裂因素造成的，比如下面红色三角形表示选择的特征：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201812/1226410-20181217111427602-1570649599.png&quot; alt=&quot;&quot; width=&quot;590&quot; height=&quot;349&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　每一层选择了指定的特征之后，我们就可以继续由该特征的不同属性值进行划分，依次一直到叶子节点。&lt;/p&gt;
&lt;p&gt;　　看起来一切很顺利，但是，细心地小伙伴可能会问了，为什么在第一次选择特征分裂的时候，不选择触感呢？而是选择纹理，比如如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201812/1226410-20181217111732438-217925843.png&quot; alt=&quot;&quot; width=&quot;613&quot; height=&quot;363&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　不换成抽干，或者是其他特征呢？为什么选择的是纹理，这是以什么标准来选择特征的？这个问题先留着，让我们再看一个例子&lt;/p&gt;
&lt;h3&gt;决策实例二&lt;/h3&gt;
&lt;p&gt;　　一天，老师问了个问题，只根据头发和声音怎么判断一位同学的性别。 &lt;br/&gt;　　为了解决这个问题，同学们马上简单的统计了7位同学的相关特征，数据如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1226410/201808/1226410-20180806101127181-228435581.png&quot; alt=&quot;&quot; width=&quot;554&quot; height=&quot;276&quot;/&gt;&lt;/p&gt;
&lt;p&gt;机智的同学A想了想，先根据头发判断，若判断不出，再根据声音判断，于是画了一幅图，如下： &lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://img-blog.csdn.net/20170325232900261?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY3NxYXp3c3hlZGM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;同学A&quot; width=&quot;587&quot; height=&quot;317&quot;/&gt; &lt;br/&gt;　　于是，一个简单、直观的决策树就这么出来了。头发长、声音粗就是男生；头发长、声音细就是女生；头发短、声音粗是男生；头发短、声音细是女生。 &lt;br/&gt;　　&lt;br/&gt;　　这时又蹦出个同学B，想先根据声音判断，然后再根据头发来判断，如是大手一挥也画了个决策树： &lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://img-blog.csdn.net/20170325231929573?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY3NxYXp3c3hlZGM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;同学B&quot;/&gt; &lt;br/&gt;　　同学B的决策树：首先判断声音，声音细，就是女生；声音粗、头发长是男生；声音粗、头发长是女生。&lt;/p&gt;
&lt;p&gt;　　那么问题来了：同学A和同学B谁的决策树好些？计算机做决策树的时候，面对多个特征，该如何选哪个特征为最佳的划分特征？下面我们就要说一下决策树的特征选择了。&lt;/p&gt;
&lt;h3&gt;决策树的特征选择&lt;/h3&gt;
&lt;p&gt;　　&lt;strong&gt;划分数据集的大原则是：将无序的数据变得更加有序。 &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;　　我们可以使用多种方法划分数据集，但是每种方法都有各自的优缺点。于是我们这么想，如果我们能测量数据的复杂度，对比按不同特征分类后的数据复杂度，若按某一特征分类后复杂度减少的更多，那么这个特征即为最佳分类特征。 &lt;br/&gt;　　Claude Shannon 定义了熵（entropy）和信息增益(information gain)。 下面先介绍一下概念：&lt;/p&gt;
&lt;h3&gt;熵（entropy）&lt;/h3&gt;
&lt;p&gt;　　在信息论与概率论中，熵（entropy）用于表示“随机变量不确定性的度量”&lt;/p&gt;
&lt;p&gt;　　在决策树的算法中，熵是一个非常非常重要的概念，一件事发生的概率越小，我们说它蕴含的信息量越大，比如：我们听到女人怀孕了，是不是不奇怪，但是某天听到那个男人怀孕了，是不是？？？？&lt;/p&gt;
&lt;p&gt;　　所以下面我们说一下信息量熵的定义。&lt;/p&gt;
&lt;p&gt;　　设X是一个有限状态的离散型随机变量，其概率分布为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201812/1226410-20181217113823341-290526621.png&quot; alt=&quot;&quot; width=&quot;279&quot; height=&quot;48&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　则随机变量X的熵定义为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201812/1226410-20181217113857074-2010580133.png&quot; alt=&quot;&quot; width=&quot;222&quot; height=&quot;70&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　熵越大，则随机变量的不确定性越大。&lt;/p&gt;
&lt;p&gt;　　当随机变量只有0和1两种取值的时候，假设P（X=1）=p，则有：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201812/1226410-20181217114016728-839679991.png&quot; alt=&quot;&quot; width=&quot;293&quot; height=&quot;44&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　从而有：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201812/1226410-20181217114238987-1938641219.png&quot; alt=&quot;&quot; width=&quot;199&quot; height=&quot;68&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　从而可知，当p=0.5时，熵取值最大，随机变量不确定性最大。如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201812/1226410-20181217114458540-419108768.png&quot; alt=&quot;&quot; width=&quot;447&quot; height=&quot;382&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;条件熵（conditional entropy）&lt;/h3&gt;
&lt;p&gt;　　随机变量X给定的条件下，Y的条件概率分布的熵对X的数学期望，其数学推导如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201812/1226410-20181217160231715-1958718494.png&quot; alt=&quot;&quot; width=&quot;311&quot; height=&quot;138&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　随机变量Y的条件熵H（Y|X）定义为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201812/1226410-20181217114825494-826482734.png&quot; alt=&quot;&quot; width=&quot;242&quot; height=&quot;57&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　其中：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201812/1226410-20181217114849959-970139871.png&quot; alt=&quot;&quot; width=&quot;138&quot; height=&quot;36&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　条件熵H(Y|X)表示在已知随机变量X的条件下随机变量Y的不确定性。注意一下，条件熵中X也是一个变量，意思是在一个变量X的条件下（变量X的每个值都会取到），另一个变量Y的熵对X的期望。&lt;/p&gt;
&lt;h3&gt;信息增益（information gain）&lt;/h3&gt;
&lt;p&gt;　　信息增益表示的是：得知特征X的信息而使得类Y的信息的不确定性减少的程度。简单说，就是当我们用另一个变量X对原变量Y分类后，原变量Y的不确定性就会减少了（即熵值减少）。而熵就是不确定性，不确定程度减少了多少其实就是信息增益，这就是信息增益的由来。&lt;/p&gt;
&lt;p&gt;　　所以信息增益的具体定义如下：&lt;/p&gt;
&lt;p&gt;　　特征A对训练数据集D的信息增益g(D，A）定义为集合D的经验熵H（D）与特征A给定条件下D的经验条件熵H（D/A）之差，即：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201812/1226410-20181217115552832-437744762.png&quot; alt=&quot;&quot; width=&quot;231&quot; height=&quot;48&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　一般地，熵H(Y)与条件熵H(Y|X)之差成为互信息（mutual information）。&lt;/p&gt;
&lt;p&gt;　　根据信息增益准则而进行特征选择的方法是：对训练数据集D，计算其每个特征的信息增益，并比他们大小，从而选择信息增益最大的特征。&lt;/p&gt;
&lt;p&gt;　　假设训练数据集为D，样本容量为|D|，由k个类别C&lt;sub&gt;k&lt;/sub&gt;，|C&lt;sub&gt;k&lt;/sub&gt;|为类别C&lt;sub&gt;k&lt;/sub&gt;的样本个数，某一特征A由n个不同的取值a1,a2,a3,.....an。根据特征A的取值可将数据集D划分为n个子集D1，D2.....D&lt;sub&gt;n&lt;/sub&gt;，|D&lt;sub&gt;i&lt;/sub&gt;|为D&lt;sub&gt;i&lt;/sub&gt;的样本个数，并记子集Di中属于类C&lt;sub&gt;k&lt;/sub&gt;，的样本的集合为D&lt;sub&gt;ik，&lt;/sub&gt;|D&lt;sub&gt;ik&lt;/sub&gt;|为D&lt;sub&gt;ik&lt;/sub&gt;的样本个数。&lt;/p&gt;
&lt;p&gt;　　则信息增益的算法如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;-输入：训练数据集D和特征A&lt;/li&gt;
&lt;li&gt;-输出：特征A对训练数据集D的信息增益g(D,A)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;（1） 计算数据集D的经验熵H(D)。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201812/1226410-20181217135434802-2015368600.png&quot; alt=&quot;&quot; width=&quot;214&quot; height=&quot;71&quot;/&gt;&lt;/p&gt;
&lt;p&gt; （2）计算特征A对数据集D的经验条件H（D|A）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201812/1226410-20181217135903234-268637025.png&quot; alt=&quot;&quot; width=&quot;381&quot; height=&quot;60&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（3）计算信息增益&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201812/1226410-20181217135936103-1919027735.png&quot; alt=&quot;&quot; width=&quot;246&quot; height=&quot;47&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;信息增益比（information gain ratio）&lt;/h3&gt;
&lt;p&gt;　　以信息增益作为特征选择准则，会存在偏向于选择取值较多的特征的问题，可以采用信息增益比对这个问题进行校正。&lt;/p&gt;
&lt;p&gt;　　特征A对训练数据集D的信息增益比定义为其信息增益与训练集D关于特征A的值的熵之比，即：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201812/1226410-20181217140155048-449742908.png&quot; alt=&quot;&quot; width=&quot;190&quot; height=&quot;70&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201812/1226410-20181217140224575-1596053114.png&quot; alt=&quot;&quot; width=&quot;252&quot; height=&quot;58&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;计算实例二的信息增益值&lt;/h3&gt;
&lt;p&gt;　　首先计算未分类前的熵，总共有8位同学，男生3位，女生5位。 &lt;/p&gt;
&lt;ul&gt;&lt;li&gt;熵（总）=-3/8*log2(3/8)-5/8*log2(5/8)=0.9544 &lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　接着分别计算同学A和同学B分类后信息熵。 &lt;/p&gt;
&lt;p&gt;&lt;br/&gt;　　同学A首先按头发分类，分类后的结果为：长头发中有1男3女。短头发中有2男2女。 &lt;/p&gt;
&lt;ul&gt;&lt;li&gt;熵（同学A长发）=-1/4*log2(1/4)-3/4*log2(3/4)=0.8113 &lt;/li&gt;
&lt;li&gt;熵（同学A短发）=-2/4*log2(2/4)-2/4*log2(2/4)=1 &lt;/li&gt;
&lt;li&gt;熵（同学A）=4/8*0.8113+4/8*1=0.9057 &lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;信息增益（同学A）=熵（总）-熵（同学A）=0.9544-0.9057=0.0487 &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;　　同理，按同学B的方法，首先按声音特征来分，分类后的结果为：声音粗中有3男3女。声音细中有0男2女。 &lt;/p&gt;
&lt;ul&gt;&lt;li&gt;熵（同学B声音粗）=-3/6*log2(3/6)-3/6*log2(3/6)=1 &lt;/li&gt;
&lt;li&gt;熵（同学B声音粗）=-2/2*log2(2/2)=0 &lt;/li&gt;
&lt;li&gt;熵（同学B）=6/8*1+2/8*0=0.75 &lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;信息增益（同学B）=熵（总）-熵（同学A）=0.9544-0.75=0.2087&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　按同学B的方法，先按声音特征分类，信息增益更大，区分样本的能力更强，更具有代表性。 &lt;br/&gt;以上就是决策树ID3算法的核心思想。 &lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
def uniquecounts(rows):
    '''
        对y的各种可能取值出现的个数进行计数
        其他函数利用该函数来计算数据集和的混杂程序
        :param rows:
        :return:
        '''
    results  = {}
    for row in rows:
        # 计算结果在最后一列
        r = rows[len(rows)-1]
        if r not in results:
            results[r] = 0
        results[r] += 1
    # 返回 一个字典
    return results

def entropy(rows):
    # 计算熵
    from math import log
    log2 = lambda x:log(x)/log(2)
    results = uniquecounts(rows)
    # 开始计算熵的值
    ent = 0.0
    for r in results.keys():
        p = float(results[r]/len(rows))
        ent = ent - p*log2(p)
    return ent
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;决策树的生成算法介绍&lt;/h2&gt;
&lt;p&gt;　　划分数据集的最大原则是：使无序的数据变的有序。如果一个训练数据中有20个特征，那么选取哪个做划分依据？这就必须采用量化的方法来判断，量化划分方法有多重，其中一项就是“信息论度量信息分类”。基于信息论的决策树算法有ID3、CART和C4.5等算法，其中C4.5和CART两种算法从ID3算法中衍生而来。&lt;/p&gt;
&lt;p&gt;　　决策树的生成算法由很多变形，这里简单说一下几种经典的实现算法：ID3算法，C4.5算法和CART算法。这些算法的主要区别在于分类结点熵特征选择的选取标准不同，下面了解一下算法的具体实现过程。&lt;/p&gt;

&lt;h3&gt;一：ID3算法&lt;/h3&gt;
&lt;p&gt;　　ID3算法所采用的度量标准就是我们前面提到的“信息增益”。当属性a的信息增益最大时，则意味着用a属性划分，其所获得的“纯度”提升最大，我们所要做的，就是找到信息增益最大的属性。&lt;/p&gt;
&lt;p&gt;　　ID3算法的核心是在决策树的各个节点上应用信息增益准则进行特征选择，具体的做法是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;从根节点上开始，对结点计算所有可能特征的信息增益，选择信息增益最大的特征作为结点的特征，并由该特征的不同取值构建子节点；&lt;/li&gt;
&lt;li&gt;对于子节点递归的调用以上方法，构建决策树；&lt;/li&gt;
&lt;li&gt;直到所有特征的信息增益均很小或者没有特征可选择的时候为止。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;ID3算法存在的缺点： &lt;/p&gt;
&lt;p&gt;　　1. ID3算法在选择根节点和内部节点中的分支属性时，采用信息增益作为评价标准。信息增益的缺点是倾向于选择取值较多是属性，在有些情况下这类属性可能不会提供太多有价值的信息。 &lt;br/&gt;　　2. ID3算法只能对描述属性为离散型属性的数据集构造决策树 。&lt;/p&gt;
&lt;p&gt;　　为了改进决策树，又提出了ID4.5算法和CART算法。&lt;/p&gt;
&lt;h3&gt;二：C4.5算法&lt;/h3&gt;
&lt;p&gt;　　C4.5算法与ID3算法的区别主要是在于它在生产决策树的过程中，使用信息增益比来进行特征选择。&lt;/p&gt;
&lt;p&gt;　　实际上，信息增益准则对于可取值数目较多的属性会有所偏好，为了减少这种偏好可能带来的不利影响，C4.5决策树算法不直接使用信息增益，而是使用“信息增益率”来选择最优划分属性，信息增益率定义为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201812/1226410-20181217162226825-1694255814.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　其中，分子为信息增益，分母为属性X的熵。&lt;/p&gt;
&lt;p&gt;　　需要注意的是，增益率准则对可取值数目较少的属性有所偏好。&lt;/p&gt;
&lt;p&gt;　　所以一般这样选取划分属性：先从候选属性中找到信息增益高于平均水平的属性，再从中选择增益率最高的。&lt;/p&gt;

&lt;h3&gt;三：CART算法&lt;/h3&gt;
&lt;p&gt;　　分类与回归树（classification and regression tree,CART）与C4.5算法一样，由ID3算法演化而来。CART假设决策树是一个二叉树，它通过递归地二分每个特征，将特征空间划分为有限个单元，并在这些单元上确定预测的概率分布。&lt;/p&gt;
&lt;p&gt;　　CART算法中，对于回归树，采用的是平方误差最小化准则；对于分类树，采用基尼指数最小化准则。&lt;/p&gt;
&lt;h4&gt;平方误差最小化&lt;/h4&gt;
&lt;p&gt;　　假设已将输入空间划分为M个单元R1，R2......Rm，并且在每个单元Rm上有一个固定的输出值Cm，于是回归树可以表示为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201812/1226410-20181217150808236-1907585606.png&quot; alt=&quot;&quot; width=&quot;189&quot; height=&quot;70&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　当输入空间的划分确定时，可以用平方误差&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201812/1226410-20181217150852681-1868415561.png&quot; alt=&quot;&quot; width=&quot;98&quot; height=&quot;39&quot;/&gt;来表示回归树对于训练数据的预测误差。&lt;/p&gt;
&lt;h4&gt;基尼指数&lt;/h4&gt;
&lt;p&gt;　　分类问题中，假设有K个类别，样本点属于第k类的概率为pk，则概率分布的基尼指数定义为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201812/1226410-20181217151014946-496182411.png&quot; alt=&quot;&quot; width=&quot;309&quot; height=&quot;71&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226410/201812/1226410-20181217151028068-1457675641.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt; 决策树的优缺点分析&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;易于理解和解释，甚至比线性回归更直观；&lt;/li&gt;
&lt;li&gt;与人类做决策思考的思维习惯契合；&lt;/li&gt;
&lt;li&gt;模型可以通过树的形式进行可视化展示；&lt;/li&gt;
&lt;li&gt;可以直接处理非数值型数据，不需要进行哑变量的转换，甚至可以直接处理含有缺失值的数据；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对于有大量数值型输入和输出的问题，决策树未必是一个好的选择；&lt;/li&gt;
&lt;li&gt;特别是当数值型变量之间存在许多错综复杂的关系，如金融数据分析；&lt;/li&gt;
&lt;li&gt;决策分类的因素取决于更多变量的复杂组合时；&lt;/li&gt;
&lt;li&gt;模型不够稳健，某一个节点的小小变化可能导致整个树会有很大的不同&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;接下来用python代码来实现ID3算法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;73&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
from math import log
import operator

def calcShannonEnt(dataSet):  # 计算数据的熵(entropy)
    numEntries=len(dataSet)  # 数据条数
    labelCounts={}
    for featVec in dataSet:
        currentLabel=featVec[-1] # 每行数据的最后一个字（类别）
        if currentLabel not in labelCounts.keys():
            labelCounts[currentLabel]=0
        labelCounts[currentLabel]+=1  # 统计有多少个类以及每个类的数量
    shannonEnt=0
    for key in labelCounts:
        prob=float(labelCounts[key])/numEntries # 计算单个类的熵值
        shannonEnt-=prob*log(prob,2) # 累加每个类的熵值
    return shannonEnt

def createDataSet1():    # 创造示例数据
    dataSet = [['长', '粗', '男'],
               ['短', '粗', '男'],
               ['短', '粗', '男'],
               ['长', '细', '女'],
               ['短', '细', '女'],
               ['短', '粗', '女'],
               ['长', '粗', '女'],
               ['长', '粗', '女']]
    labels = ['头发','声音']  #两个特征
    return dataSet,labels

def splitDataSet(dataSet,axis,value): # 按某个特征分类后的数据
    retDataSet=[]
    for featVec in dataSet:
        if featVec[axis]==value:
            reducedFeatVec =featVec[:axis]
            reducedFeatVec.extend(featVec[axis+1:])
            retDataSet.append(reducedFeatVec)
    return retDataSet

def chooseBestFeatureToSplit(dataSet):  # 选择最优的分类特征
    numFeatures = len(dataSet[0])-1
    baseEntropy = calcShannonEnt(dataSet)  # 原始的熵
    bestInfoGain = 0
    bestFeature = -1
    for i in range(numFeatures):
        featList = [example[i] for example in dataSet]
        uniqueVals = set(featList)
        newEntropy = 0
        for value in uniqueVals:
            subDataSet = splitDataSet(dataSet,i,value)
            prob =len(subDataSet)/float(len(dataSet))
            newEntropy +=prob*calcShannonEnt(subDataSet)  # 按特征分类后的熵
        infoGain = baseEntropy - newEntropy  # 原始熵与按特征分类后的熵的差值
        if (infoGain&amp;gt;bestInfoGain):   # 若按某特征划分后，熵值减少的最大，则次特征为最优分类特征
            bestInfoGain=infoGain
            bestFeature = i
    return bestFeature

def majorityCnt(classList):    #按分类后类别数量排序，比如：最后分类为2男1女，则判定为男；
    classCount={}
    for vote in classList:
        if vote not in classCount.keys():
            classCount[vote]=0
        classCount[vote]+=1
    sortedClassCount = sorted(classCount.items(),key=operator.itemgetter(1),reverse=True)
    return sortedClassCount[0][0]

def createTree(dataSet,labels):
    classList=[example[-1] for example in dataSet]  # 类别：男或女
    if classList.count(classList[0])==len(classList):
        return classList[0]
    if len(dataSet[0])==1:
        return majorityCnt(classList)
    bestFeat=chooseBestFeatureToSplit(dataSet) #选择最优特征
    bestFeatLabel=labels[bestFeat]
    myTree={bestFeatLabel:{}} #分类结果以字典形式保存
    del(labels[bestFeat])
    featValues=[example[bestFeat] for example in dataSet]
    uniqueVals=set(featValues)
    for value in uniqueVals:
        subLabels=labels[:]
        myTree[bestFeatLabel][value]=createTree(splitDataSet\
                            (dataSet,bestFeat,value),subLabels)
    return myTree


if __name__=='__main__':
    dataSet, labels=createDataSet1()  # 创造示列数据
    print(createTree(dataSet, labels))  # 输出决策树模型结果
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;输出结果为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
{'声音': {'细': '女', '粗': {'头发': {'短': '男', '长': '女'}}}}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　这个结果的意思是：首先按声音分类，声音细为女生；然后再按头发分类：声音粗，头发短为男生；声音粗，头发长为女生。 &lt;br/&gt;　　这个结果也正是同学B的结果。 &lt;br/&gt;　　补充说明：判定分类结束的依据是，若按某特征分类后出现了最终类（男或女），则判定分类结束。使用这种方法，在数据比较大，特征比较多的情况下，很容易造成过拟合，于是需进行决策树枝剪，一般枝剪方法是当按某一特征分类后的熵小于设定值时，停止分类。&lt;/p&gt;


&lt;p&gt;参考： &lt;br/&gt;- &lt;a href=&quot;https://book.douban.com/subject/6962285/&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;Machine Learning in Action&lt;/a&gt; &lt;br/&gt;- &lt;a href=&quot;https://book.douban.com/subject/10590856/&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;统计学习方法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;https://zhuanlan.zhihu.com/p/26703300&lt;/p&gt;
&lt;pre name=&quot;code&quot; class=&quot;prettyprint&quot;&gt;
&lt;/pre&gt;


&lt;pre name=&quot;code&quot; class=&quot;prettyprint&quot;&gt;
&lt;/pre&gt;</description>
<pubDate>Tue, 18 Dec 2018 06:45:00 +0000</pubDate>
<dc:creator>战争热诚</dc:creator>
<og:description>分类技术（或分类法）是一种根据输入数据建立分类模型的系统方法，分类法的例子包括决策分类法，基于规则的分类法，神经网络，支持向量机和朴素贝叶斯分类法。这些技术都使用一种学习算法（learning alg</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wj-1314/p/9428494.html</dc:identifier>
</item>
<item>
<title>HBase之CF持久化系列(续3——完结篇) - letsfly</title>
<link>http://www.cnblogs.com/letsfly/p/10135024.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/letsfly/p/10135024.html</guid>
<description>&lt;p&gt;　　相信大家在看了该系列的前两篇文章就已经对其中的持久化有比较深入的了解。相对而言，本节内容只是对前两节的一个巩固。与持久化相对应的是打开文件并将其内容读入到内存变量中。而在本节，我就来介绍这一点。&lt;/p&gt;
&lt;p&gt;　　本节我从方法HStore.validateStoreFile开始分析。在本节的末尾，我将会为大家带来CF目录下某个文件的文件结构。也算是本系列的一个完整结尾。&lt;/p&gt;
&lt;p&gt;　　在该方法内部调用了方法createStoreFileAndReader。如下图所示。这里首先构造了StoreFileInfo。在构造StoreFileInfo时，由于我们这里的path既非HFileLink，亦非HStoreFile reference，仅仅是HFile，因此，其成员变量link与reference值都为null。&lt;/p&gt;
&lt;p&gt;　　如下图所示。在构造了StoreFileInfo后，将其作为入参，调用了同名方法。&lt;/p&gt;
&lt;p&gt;　　1.构造了HStoreFile，在构造HStoreFile中，入参有fileInfo&lt;/p&gt;
&lt;div readability=&quot;12&quot;&gt;　　2.调用了storeFile.initReader，该方法比较复杂，也是本节的重点。我在后面将会详细介绍。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181218083046725-796213726.png&quot; alt=&quot;&quot;/&gt;　　下面，让我们来到HStoreFile.initReader。在该方法中仅仅调用了方法open。接着，在open方法内部，调用了fileInfo.open，这里的fileInfo实际类型为StoreFileInfo，也就是上图所介绍的。&lt;/div&gt;
&lt;p&gt;　　接下来让我们来到StoreFileInfo.open，该方法比较长，为了突出重点，我只将方法中比较重要的地方截图并做了简单标示。如下图所示。&lt;/p&gt;
&lt;p&gt;　　1.这里构造FSDataInputStreamWrapper用来初始化变量in。在后面，我会简单介绍一下FSDataInputStreamWrapper的构造方法。&lt;/p&gt;
&lt;div readability=&quot;8&quot;&gt;　　2.将初始化好的in作为入参用来构造StoreFileReader，并将其赋给变量reader，然后返回。这里是重点，我在后面会详细介绍。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181218083104060-1143461632.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　首先，让我们来到FSDataInputStreamWrapper的构造方法中。&lt;/p&gt;
&lt;p&gt;　　1.这里首先判断入参fs类型是否为HFileSystem，如果不是，则使用HFileSystem将其封装并用来初始化成员变量hfs。&lt;/p&gt;
&lt;p&gt;　　2.这里的入参link值为null，因此，其调用hfs.open，获得入参path的输入流。&lt;/p&gt;
&lt;div readability=&quot;8&quot;&gt;　　也就是说，这里，我们已经拿到了指定文件的输入流，也就是我在上一节提到的持久化的文件。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181218083128628-394874149.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;8&quot;&gt;　　接下来让我们来到StoreFileReader的构造方法中。如下图所示，这里调用了HFile.createReader。该方法间接调用了方法openReader。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181218083201720-1269032325.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　让我们来到方法openReader，如下图所示。&lt;/p&gt;
&lt;p&gt;　　1.调用FixedFileTrailer.readFromStream。这里首先调用fsdis.getStream获得我们在上面打开的输入流。然后调用FixedFileTrailer.readFromStream，将输入流中的内容用来构造FFT，也就是FixedFileTrailer。该方法比较重要，我将在后面详细分析。&lt;/p&gt;
&lt;div readability=&quot;9&quot;&gt;　　2.由于我这里使用的是3.0版本，因此，接下来构造了HFileReaderImpl。该方法将我在上一节提到的索引信息等等都用来初始化HFileReaderImpl的成员变量，也是我在本节主要讲解的内容。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181218083229873-1159631029.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　我们首先来到FixedFileTrailer.readFromStream，如下图所示。这里实现了将输入流中的信息用来构造FixedFileTrailer，作为本节的第一个内存化类型，还是值得详细了解的。&lt;/p&gt;
&lt;p&gt;　　在介绍下图的标示之前，我先介绍一下FixedFileTrailer的功能，以便大家能够更好的理解后面的内容。其实根据其名称我们就可以猜个大概，FixedFileTrailer 也就是 fixed trailer of a file。就是文件中的固定长度的，用来存放文件基本元数据的信息。trailer硬译过来预告片的意思，这里我们可以理解为文件信息的预知。由于我这里是3.0的版本，这里的MAX_TRAILER_SIZE也就是固定长度4096。&lt;/p&gt;
&lt;p&gt;　　1.通过公式seekPoint = fileSize - bufferSize，获得了文件中除去固定长度后的内容，也就是非FFT的长度。&lt;/p&gt;
&lt;p&gt;　　2.调用HFileUtil.seekOnMultipleSources将istream中的pos指向seekPoint，也就是说，从这里开始读，读到的内容都持久化的FFT的信息。&lt;/p&gt;
&lt;p&gt;　　3.分配空间，并且调用istream.readFully将其中的信息都写到刚刚分配的buf中。&lt;/p&gt;
&lt;p&gt;　　4.调用buf.position，将其pos定位到最后四个字节，以便解析其majorVersion与minorVersion&lt;/p&gt;
&lt;p&gt;　　5.将解析后的majorVersion与minorVersion用来构造FixedFileTrailer&lt;/p&gt;
&lt;p&gt;　　6.调用fft.deserialize，解析buf中的内容，并且将其中的内容初始化FixedFileTrailer的成员变量。&lt;/p&gt;
&lt;p&gt;　　这里大家可能对下面的一个公式比较模糊buf.arrayOffset() + bufferSize - trailerSize。由于我这是3.0的版本，我就当前版本为大家简单介绍一下。&lt;/p&gt;
&lt;div readability=&quot;10&quot;&gt;　　从ByteBuffer.allocate的调用初始化buf，一直到后面fft.deserialize的调用，这里的buf.arrayOffset() 都没有改变，一直是0。另外，上面bufferSize初始化时为MAX_TRAILER_SIZE = 4096，而且通过调用getTrailerSize返回的trailerSize = 4096，所以，上面的公式其实为0。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181218083447362-1334156888.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　接下来，让我们来到FixedFileTrailer.deserialize，如下图所示。&lt;/p&gt;
&lt;p&gt;　　1.调用BlockType.TRAILER.readAndCheck，将8个字节的magic值读入到8个字节的buf中，并进行校验&lt;/p&gt;
&lt;p&gt;　　2.然后调用deserializeFromPB，将PB序列化后的信息反序列化，置于相应的成员变量中，并且，将输入流中的pos置于getTrailerSize() - NOT_PB_SIZE - size(这里我在上一节内容提到过，这一节就不赘述了)。&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;　　3.读取最后4个字节的version信息，并且进行校验对比。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181218083644447-1178181862.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　关于方法deserializeFromPB，虽然比较简单，不过，我在这里还是简单介绍一下。&lt;/p&gt;
&lt;p&gt;　　1.首先，我们需要意识到，这里的入参inputStream在上面已经将magic信息读出，因此相比一开始，这里的inputStream.available少了8个字节&lt;/p&gt;
&lt;p&gt;　　2.然后调用HFileProtos.FileTrailerProto.PARSER.parseDelimitedFrom将inputStream中的内容反序列化。&lt;/p&gt;
&lt;p&gt;　　3.公式getTrailerSize() - NOT_PB_SIZE - size比较费解。我来为大家一一解析。首先getTrailerSize返回4096，然后NOT_PB_SIZE = 12，再然后size = 4096 - 8 - FileTrailerProto.size。首先，inputStream.pos = 8，start = 4096 - 8。然后调用方法HFileProtos.FileTrailerProto.PARSER后，inputStream.pos = 8 + FileTrailerProto.size，size = FileTrailerProto.size。&lt;/p&gt;
&lt;div readability=&quot;10&quot;&gt;　　这里我们就可以得到pos + 4096 - 12 - FileTrailerProto.size = 8 + FileTrailerProto.size + 4096 - 12 - FileTrailerProto.size = 4096 - 12 + 8 = 4092。也就是说调用完方法inputStream.skip后，inputStrem.pos = 4092。这样，也就解释了上图中调用inputStream.readInt中，为什么读取到的是version。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181218083704714-1196271644.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　介绍完FFT，让我们来到构造方法HFileReaderImpl，这里是本节的重中之重，希望大家耐心看完。如下图所示。HFileReaderImpl的构造方法比较长，但是关键流程并不多，所以大家没有必要慌。&lt;/p&gt;
&lt;p&gt;　　这里我就比较关键的调用做一个简介，关于其中比较重要的流程，我将在后面一一讲解。&lt;/p&gt;
&lt;p&gt;　　1.调用HFileBlock.FSReaderImpl构造方法初始化成员变量fsBlockReader，需要注意的是，这里的入参有fsdis。这里将fsdis.stream关闭，重新打开流，并用来初始化其streamNoFsChecksum。这里我会在后面的流程中详细讲到。&lt;/p&gt;
&lt;p&gt;　　2.分别初始化成员变量dataBlockIndexReader与metaBlockIndexReader，这里只是调用了其构造方法，并没有对其中的成员变量进行初始化。&lt;/p&gt;
&lt;p&gt;　　3.调用fsBlockReader.blockRange构造了用于迭代获取信息的HFileBlock.BlockIterator，方便后面从流中获取信息。&lt;/p&gt;
&lt;p&gt;　　4.调用blockIter.nextBlockWithBlockType将从文件中读取到的信息封装到HFileBlock，然后调用dataBlockIndexReader.readMultiLevelIndexRoot将其中的信息读取出来用于初始化其成员变量。&lt;/p&gt;
&lt;p&gt;　　5.调用metaBlockIndexReader.readRootIndex，与上面的处理流程类似。&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;　　6.调用fileInfo.read将文件中的信息用来初始化fileInfo的成员变量&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181218141151936-252116174.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　这里，我首先介绍HFileBlock.FSReaderImpl。首先让我们来到FSReaderImpl的构造方法中。这里我可能介绍的比较啰嗦，但为了讲解的尽可能清楚，还请大家谅解。如下图所示。&lt;/p&gt;
&lt;p&gt;　　1.将入参stream赋给成员变量streamWrapper&lt;/p&gt;
&lt;div readability=&quot;8&quot;&gt;　　2.调用streamWrapper.prepareForBlockReader，也就是FSDataInputStreamWrapper.prepareForBlockReader。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181218141225444-984924098.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　接下来，让我们来到FSDataInputStreamWrapper.prepareForBlockReader，如下图所示。我在下图做了两个标示。&lt;/p&gt;
&lt;p&gt;　　1.调用fsNc.open，将文件重新打开，并赋给成员变量streamNoFsChecksum&lt;/p&gt;
&lt;p&gt;　　2.将之前使用的stream流关闭。&lt;/p&gt;
&lt;div readability=&quot;9&quot;&gt;　　也就是说，由于我们在这里不依赖hdfs的checksum，而依赖hbase自己计算填充的checksum，因此，其成员变量streamNoFsChecksum得以初始化。这里也就是说，从这里以后的流程所要调用的有stream更换为streamNoFsChecksum。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181218141250635-534888066.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　接下来，让我们来看一下方法blockIter.nextBlockWithBlockType，也就是HFileBlock.BlockIterator.nextBlockWithBlockType。&lt;/p&gt;
&lt;p&gt;　　首先让我们来看一下方法fsBlockReader.blockRange。如下图所示。&lt;/p&gt;
&lt;p&gt;　　1.这里将入参中的两个值都保存在了匿名类中。&lt;/p&gt;
&lt;p&gt;　　2.方法nextBlockWithBlockType主要调用了方法nextBlock&lt;/p&gt;
&lt;p&gt;　　3.方法nextBlock调用readBlockData从上面打开的输入流中读取数据并且将其封装到HFileBlock&lt;/p&gt;
&lt;p&gt;　　4.记录偏移量与长度&lt;/p&gt;
&lt;div readability=&quot;8&quot;&gt;　　然后，我们大概就明白了HFileBlock.BlockIterator.nextBlockWithBlockType的大致调用流程。虽然其关键方法readBlockData的调用我们还没有讲到。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181218141319984-439953148.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　在方法readBlockData方法中，比较重要的只是调用了方法readBlockDataInternal，因此，我在这里就不贴方法readBlockData的图。而专注于本节中最为重要的方法readBlockDataInternal。大家看了该方法可能会被吓到，没有关系。我会为大家一一讲解。只要大家耐心看下去，就会发现，其内容并不难。&lt;/p&gt;
&lt;p&gt;　　1.调用方法getCachedHeader。由于这里的是第一次调用，因此，这里返回的值为null。至于其中的流程，我会在后面为大家详细介绍。&lt;/p&gt;
&lt;p&gt;　　2.在第一次调用的时候入参onDiskSizeWithHeaderL = -1。也就是说onDiskSizeWithHeader = -1。因此这里的判断onDiskSizeWithHeader &amp;lt;= 0 为true。其代码块中的逻辑也得以执行。&lt;/p&gt;
&lt;p&gt;　　我在这里就其代码块中的逻辑简单描述一下，至于其中比较重要的方法，我将放在后面来讲解。&lt;/p&gt;
&lt;p&gt;　　这里首先调用ByteBuffer.allocate分配了33个字节。因为默认情况下使用的是含checksum的header。&lt;/p&gt;
&lt;p&gt;　　接下来调用readAtOffset。这里将入参is指定偏移量offset长度hdrSize写入到headerBuf.array中。&lt;/p&gt;
&lt;p&gt;　　然后，调用getOnDiskSizeWithHeader获得当前要读取的块的大小，含header与checksum。&lt;/p&gt;
&lt;p&gt;　　3.分配onDiskSizeWithHeader + hdrSize长度个字节用来存放当前block与下一个header，赋给变量onDiskBlock。&lt;/p&gt;
&lt;p&gt;　　4.接着调用方法readAtOffset，这里是将当前block与下一个header写入到onDiskBlock，关于其入参，由于上面已经提到过，我这里就不再赘述了。这里的返回值为下一个block块所占用的大小。&lt;/p&gt;
&lt;p&gt;　　5.然后调用System.arraycopy将我们第一次调用方法readAtOffset读到的信息写入到变量onDiskBlock中。&lt;/p&gt;
&lt;p&gt;　　6.调用方法ByteBuffer.wrap将变量onDiskBlock中的信息封装为ByteBuffer类型。&lt;/p&gt;
&lt;p&gt;　　7.将刚刚初始化的onDiskBlockByteBuffer作为入参，用来构造HFileBlock，最后用于返回。&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;　　8.调用cacheNextBlockHeader缓存下一个block的header。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181218141408086-1452349575.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　这里我们首先来介绍方法readAtOffset。如下图所示。这个方法比较长，我只截取其中比较关键的部分。&lt;/p&gt;
&lt;p&gt;　　1.调用HFileUtil.seekOnMultipleSources，其内部调用了istream.seek将当前istream.pos值为入参fileOffset。&lt;/p&gt;
&lt;p&gt;　　2.调用IOUtils.readFully将istream.pos起，长度为size的数据copy到dest中。&lt;/p&gt;
&lt;p&gt;　　3.调用readWithExtra(该方法与上面的方法不会同时调用，我这里只是将二者放在了一起讲解)。&lt;/p&gt;
&lt;p&gt;　　如果该方法将长度为size + hdrSize全部写入到了dest，则返回值为true。否则，返回false。&lt;/p&gt;
&lt;div readability=&quot;9&quot;&gt;　　4.调用Bytes.toInt(dest, destOffset + size + BlockType.MAGIC_LENGTH) + hdrSize获取下一个block长度。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181218141442066-714223563.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　接下来让我们来到HFileBlock的构造方法中。这里虽然不是很难，却也是一个知识点。如下图所示。这里标示的东西比较多。大家看了这里的方法可能会比较懵逼，这里的Header中的各个静态量是什么意思。没有关系，让我们接着往下走。&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;　　这里，我们需要注意的是，其入参buf用于初始化其成员变量buf。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181218141459310-883566207.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　如下图所示，这里是Header中的各个静态量。这里中也有注释。不过，我还是再简单介绍一下。&lt;/p&gt;
&lt;p&gt;　　1.首先是8个字节的MAGIC值，其实也就是枚举BlockType中的值。BlockType的每个枚举类型中的magic值都是8个字节。&lt;/p&gt;
&lt;p&gt;　　2.接下来就是4个字节不含header的block大小，这里是block压缩后的大小。注意，这里包含checksum。&lt;/p&gt;
&lt;p&gt;　　3.然后是4个字节的没有压缩后的大小。这里不包含header，也不包含checksum。&lt;/p&gt;
&lt;p&gt;　　4.然后是8个字节相同类型的前一个block的偏移量。他主要用于导航到上一个块而无需转到块索引。&lt;/p&gt;
&lt;p&gt;　　5.1个字节表示checksum type，其对应的类型为枚举ChecksumType&lt;/p&gt;
&lt;p&gt;　　6.然后是4个字节每个校验和值的字节数&lt;/p&gt;
&lt;p&gt;　　7.最后4个字节是包括header，但是不包含checksums的block大小。&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;　　相信有了这里的了解，大家就对于HFileBlock的构造方法就不再迷惑了。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181218141532348-28049386.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　到此为止，相信大家对于HFileBlock.BlockIterator.nextBlockWithBlockType方法调用的流程已经有了一个清晰的了解。&lt;/p&gt;
&lt;p&gt;　　接下来，我以dataBlockIndexReader.readMultiLevelIndexRoot为例，简单说明一下这里如何将入参HFileBlock用来初始化其中的成员变量。&lt;/p&gt;
&lt;p&gt;　　在dataBlockIndexReader.readMultiLevelIndexRoot方法中，主要调用了方法readRootIndex。如下图所示。&lt;/p&gt;
&lt;p&gt;　　1.调用blk.getByteStream，这里虽然不太复杂，但还是值得我简单讲解一下。&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;　　2.调用用来填充其成员变量。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181218141559897-1358802957.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　接下来，让我们首先来到方法HFileBlock.getByteStream。&lt;/p&gt;
&lt;p&gt;　　1.调用buf.duplicate，这里buf的实际类型为SingleByteBuff，因此，其调用了SingleByteBuff.duplicate。&lt;/p&gt;
&lt;p&gt;　　2.将返回的dup的pos定到33，也就是header后的第一个字节&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;　　3.将其中dup封装为DataInputStream并返回&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181218141618771-1754780652.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;9&quot;&gt;　　关于方法SingleByteBuff.duplicate的调用，我在这里简单截图说明一下。如下图所示。这里的buf类型为java.nio.ByteBuffer。调用其duplicate方法并将其封装为一个新的对象返回。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181218141636363-491104750.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;11&quot;&gt;　　然后，让我们来到方法readRootIndex，这里完成了root index的读取。相信看过上一篇博文《HBase之CF持久化系列(续2)》的大家应该能够理解这里的内容，因为当时写入的逻辑与现在读入的逻辑是一样的，我在这里就不赘述了。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181218141651038-826777122.png&quot; alt=&quot;&quot;/&gt;　　接下来，让我们来到方法fileInfo.read。如下图所示。&lt;/div&gt;
&lt;p&gt;　　1.分配4个字节用来存放其magic值。这里的magic为PBUF&lt;/p&gt;
&lt;p&gt;　　2.将输入流中的值写入到刚刚初始化的pbuf中&lt;/p&gt;
&lt;p&gt;　　3.调用方法HFileProtos.FileInfoProto.parseDelimitedFrom将输入流中的信息反序列化&lt;/p&gt;
&lt;div readability=&quot;8&quot;&gt;　　4.调用方法parsePB将其中的入参HFileProtos.FileInfoProto类型的值用来填充其成员变量map&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181218141708853-504942530.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　然后，就是loadOnOpenBlocks成员变量完成其值的添加了。这里只是调用了blockIter.nextBlock，该方法在上面已经介绍过，我在这里就不赘述了。&lt;/p&gt;
&lt;p&gt;　　到此为止，本节的内容就介绍完了。&lt;/p&gt;
&lt;div readability=&quot;8&quot;&gt;　　下面，我画一个图简单描述一下文件存放的各种信息。如果不对，还希望大家指正。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181218141728999-776018838.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　到这里，该系列——CF持久化系列就画上了句号，希望大家喜欢。&lt;/p&gt;
</description>
<pubDate>Tue, 18 Dec 2018 06:23:00 +0000</pubDate>
<dc:creator>letsfly</dc:creator>
<og:description>相信大家在看了该系列的前两篇文章就已经对其中的持久化有比较深入的了解。相对而言，本节内容只是对前两节的一个巩固。与持久化相对应的是打开文件并将其内容读入到内存变量中。而在本节，我就来介绍这一点。 本节</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/letsfly/p/10135024.html</dc:identifier>
</item>
<item>
<title>Java集合-05fail-fast(快速失败)机制原理及解决方法 - Jzedy</title>
<link>http://www.cnblogs.com/JzedyBlogs/p/10136772.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/JzedyBlogs/p/10136772.html</guid>
<description>&lt;h2 id=&quot;fail-fast简介&quot;&gt;fail-fast简介&lt;/h2&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;fail-fast(快速失败)，是Java集合的一种错误检测机制。当在遍历集合的过程中该集合在结构(改变集合大小)上发生变化时候，&lt;br/&gt;有可能发生fail-fast，抛出java.util.ConcurrentModificationException异常。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;fail-fast出现场景&quot;&gt;fail-fast出现场景&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;单线程场景
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    public class FailFastSingleThreadTest {
        public static void main(String[] args) {
            List&amp;lt;String&amp;gt; lists = new ArrayList&amp;lt;&amp;gt;(10);
            for (int i = 0; i &amp;lt; 4; i++){
                lists.add(String.valueOf(i));
            }

            //fail-fast
            for (String list : lists) {
                lists.remove(3);
            }
        }
    }
//output:Exception in thread &quot;main&quot; java.util.ConcurrentModificationException&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;多线程场景
&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;11&quot;&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;  public class FailFastMultiThread  {
      private static List&amp;lt;String&amp;gt; lists = new ArrayList&amp;lt;&amp;gt;(10);
      static {
          for (int i = 0; i &amp;lt; 4; i++){
              lists.add(String.valueOf(i));
          }
      }
      public static void main(String[] args) {
          new Thread(new ForEachThread()).start();
          new Thread(new EditThread()).start();
      }

      //用于遍历
      static class ForEachThread implements Runnable{
          @Override
          public void run() {
              Iterator&amp;lt;String&amp;gt; iterator = lists.iterator();
              while (iterator.hasNext()){
                  System.out.println(iterator.next());
                  try {
                      Thread.sleep(100);//为了另外的线程加入，也是为了结合在遍历时候修改结构
                  } catch (InterruptedException e) {
                      e.printStackTrace();
                  }
              }

          }
      }

      //用于修改结构
      static class EditThread implements Runnable{
          @Override
          public void run() {
              lists.add(&quot;8&quot;);
          }
      }

  }
  //output:Exception in thread &quot;Thread-0&quot; java.util.ConcurrentModificationException&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;产生原因&quot;&gt;产生原因&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;集合能够遍历是因为迭代器的原因，而Iterator接口只是定义了具体的方法，集合需要实现该接口方法，&lt;br/&gt;查看ArrayList中具体的实现方法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;  //省略部分方法
  private class Itr implements Iterator&amp;lt;E&amp;gt; {
      int cursor;       // index of next element to return
      int lastRet = -1; // index of last element returned; -1 if no such
      int expectedModCount = modCount;

      @SuppressWarnings(&quot;unchecked&quot;)
      public E next() {
          checkForComodification();
          int i = cursor;
          if (i &amp;gt;= size)
              throw new NoSuchElementException();
          Object[] elementData = ArrayList.this.elementData;
          if (i &amp;gt;= elementData.length)
              throw new ConcurrentModificationException();
          cursor = i + 1;
          return (E) elementData[lastRet = i];
      }

      public void remove() {
          if (lastRet &amp;lt; 0)
              throw new IllegalStateException();
          checkForComodification();

          try {
              ArrayList.this.remove(lastRet);
              cursor = lastRet;
              lastRet = -1;
              expectedModCount = modCount;
          } catch (IndexOutOfBoundsException ex) {
              throw new ConcurrentModificationException();
          }
      }



      final void checkForComodification() {
          if (modCount != expectedModCount)
              throw new ConcurrentModificationException();
      }
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;可以看出在Itr是ArrayList的一个内部类，迭代器操作通过这个内部类，Itr有个expectedModCount属性，这个属性判断是否与modCount相等，如果不相等抛出异常，modCount记录list结构上发生变化的次数，可以看出在迭代时候checkForComodification()方法检测两个的值不相等就抛出异常&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;解决方法&quot;&gt;解决方法&lt;/h2&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;单线程
&lt;ul&gt;&lt;li&gt;使用迭代器的remove方法&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;  public class NoFailFastSingleThread {
      public static void main(String[] args) {
          List&amp;lt;String&amp;gt; lists = new ArrayList&amp;lt;&amp;gt;(10);
          for (int i = 0; i &amp;lt; 4; i++){
              lists.add(String.valueOf(i));
          }

          Iterator&amp;lt;String&amp;gt; iterator = lists.iterator();
          while (iterator.hasNext()){
              String next = iterator.next();
              if (next != null){
                  iterator.remove();
              }
          }

      }
  }&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;多线程
&lt;ul&gt;&lt;li&gt;使用java并发包下的类来代替对应的集合,如CopyOnWriteArrayList代替ArrayList，&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Tue, 18 Dec 2018 06:11:00 +0000</pubDate>
<dc:creator>Jzedy</dc:creator>
<og:description>fail fast简介 fail fast(快速失败)，是Java集合的一种错误检测机制。当在遍历集合的过程中该集合在结构(改变集合大小)上发生变化时候， 有可能发生fail fast，抛出java.</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/JzedyBlogs/p/10136772.html</dc:identifier>
</item>
</channel>
</rss>