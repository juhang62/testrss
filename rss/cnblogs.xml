<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Linux的内存分页管理 - Tomorrow1</title>
<link>http://www.cnblogs.com/qq_841161825/p/10288025.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qq_841161825/p/10288025.html</guid>
<description>&lt;p&gt;内存是计算机的主存储器。内存为进程开辟出进程空间，让进程在其中保存数据。我将从内存的物理特性出发，深入到内存管理的细节，特别是了解虚拟内存和内存分页的概念。&lt;/p&gt;

&lt;h3&gt;内存&lt;/h3&gt;
&lt;p&gt;简单地说，内存就是一个数据货架。内存有一个最小的存储单位，大多数都是一个字节。内存用内存地址（memory address）来为每个字节的数据顺序编号。因此，内存地址说明了数据在内存中的位置。内存地址从0开始，每次增加1。这种线性增加的存储器地址称为线性地址（linear address）。为了方便，我们用十六进制数来表示内存地址，比如0x00000003、0x1A010CB0。这里的“0x”用来表示十六进制。“0x”后面跟着的，就是作为内存地址的十六进制数。&lt;/p&gt;
&lt;p&gt;内存地址的编号有上限。地址空间的范围和地址总线（address bus）的位数直接相关。CPU通过地址总线来向内存说明想要存取数据的地址。以英特尔32位的80386型CPU为例，这款CPU有32个针脚可以传输地址信息。每个针脚对应了一位。如果针脚上是高电压，那么这一位是1。如果是低电压，那么这一位是0。32位的电压高低信息通过地址总线传到内存的32个针脚，内存就能把电压高低信息转换成32位的二进制数，从而知道CPU想要的是哪个位置的数据。用十六进制表示，32位地址空间就是从0x00000000 到0xFFFFFFFF。&lt;/p&gt;
&lt;p&gt;内存的存储单元采用了随机读取存储器（RAM， Random Access Memory）。所谓的“随机读取”，是指存储器的读取时间和数据所在位置无关。与之相对，很多存储器的读取时间和数据所在位置有关。就拿磁带来说，我们想听其中的一首歌，必须转动带子。如果那首歌是第一首，那么立即就可以播放。如果那首歌恰巧是最后一首，我们快进到可以播放的位置就需要花很长时间。我们已经知道，进程需要调用内存中不同位置的数据。如果数据读取时间和位置相关的话，计算机就很难把控进程的运行时间。因此，随机读取的特性是内存成为主存储器的关键因素。&lt;/p&gt;
&lt;p&gt;内存提供的存储空间，除了能满足内核的运行需求，还通常能支持运行中的进程。即使进程所需空间超过内存空间，内存空间也可以通过少量拓展来弥补。换句话说，内存的存储能力，和计算机运行状态的数据总量相当。内存的缺点是不能持久地保存数据。一旦断电，内存中的数据就会消失。因此，计算机即使有了内存这样一个主存储器，还是需要硬盘这样的外部存储器来提供持久的储存空间。&lt;/p&gt;

&lt;h3&gt;虚拟内存&lt;/h3&gt;
&lt;p&gt;内存的一项主要任务，就是存储进程的相关数据。我们之前已经看到过进程空间的程序段、全局数据、栈和堆，以及这些这些存储结构在进程运行中所起到的关键作用。有趣的是，尽管进程和内存的关系如此紧密，但进程并不能直接访问内存。在Linux下，进程不能直接读写内存中地址为0x1位置的数据。进程中能访问的地址，只能是虚拟内存地址（virtual memory address）。操作系统会把虚拟内存地址翻译成真实的内存地址。这种内存管理方式，称为虚拟内存（virtual memory）。&lt;/p&gt;
&lt;p&gt;每个进程都有自己的一套虚拟内存地址，用来给自己的进程空间编号。进程空间的数据同样以字节为单位，依次增加。从功能上说，虚拟内存地址和物理内存地址类似，都是为数据提供位置索引。进程的虚拟内存地址相互独立。因此，两个进程空间可以有相同的虚拟内存地址，如0x10001000。虚拟内存地址和物理内存地址又有一定的对应关系，如图1所示。对进程某个虚拟内存地址的操作，会被CPU翻译成对某个具体内存地址的操作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/413416/201807/413416-20180718150754636-308113815.png&quot; alt=&quot;&quot; width=&quot;420&quot; height=&quot;206&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图1 虚拟内存地址和物理内存地址的对应&lt;/p&gt;
&lt;p&gt;应用程序来说对物理内存地址一无所知。它只可能通过虚拟内存地址来进行数据读写。程序中表达的内存地址，也都是虚拟内存地址。进程对虚拟内存地址的操作，会被操作系统翻译成对某个物理内存地址的操作。由于翻译的过程由操作系统全权负责，所以应用程序可以在全过程中对物理内存地址一无所知。因此，C程序中表达的内存地址，都是虚拟内存地址。比如在C语言中，可以用下面指令来打印变量地址：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
int v = 0;
printf(&quot;%p&quot;, (void*)&amp;amp;v);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;本质上说，虚拟内存地址剥夺了应用程序自由访问物理内存地址的权利。进程对物理内存的访问，必须经过操作系统的审查。因此，掌握着内存对应关系的操作系统，也掌握了应用程序访问内存的闸门。借助虚拟内存地址，操作系统可以保障进程空间的独立性。只要操作系统把两个进程的进程空间对应到不同的内存区域，就让两个进程空间成为“老死不相往来”的两个小王国。两个进程就不可能相互篡改对方的数据，进程出错的可能性就大为减少。&lt;/p&gt;
&lt;p&gt;另一方面，有了虚拟内存地址，内存共享也变得简单。操作系统可以把同一物理内存区域对应到多个进程空间。这样，不需要任何的数据复制，多个进程就可以看到相同的数据。内核和共享库的映射，就是通过这种方式进行的。每个进程空间中，最初一部分的虚拟内存地址，都对应到物理内存中预留给内核的空间。这样，所有的进程就可以共享同一套内核数据。共享库的情况也是类似。对于任何一个共享库，计算机只需要往物理内存中加载一次，就可以通过操纵对应关系，来让多个进程共同使用。IPO中的共享内存，也有赖于虚拟内存地址。&lt;/p&gt;

&lt;h3&gt;内存分页&lt;/h3&gt;
&lt;p&gt;虚拟内存地址和物理内存地址的分离，给进程带来便利性和安全性。但虚拟内存地址和物理内存地址的翻译，又会额外耗费计算机资源。在多任务的现代计算机中，虚拟内存地址已经成为必备的设计。那么，操作系统必须要考虑清楚，如何能高效地翻译虚拟内存地址。&lt;/p&gt;
&lt;p&gt;记录对应关系最简单的办法，就是把对应关系记录在一张表中。为了让翻译速度足够地快，这个表必须加载在内存中。不过，这种记录方式惊人地浪费。如果树莓派1GB物理内存的每个字节都有一个对应记录的话，那么光是对应关系就要远远超过内存的空间。由于对应关系的条目众多，搜索到一个对应关系所需的时间也很长。这样的话，会让树莓派陷入瘫痪。&lt;/p&gt;
&lt;p&gt;因此，Linux采用了分页（paging）的方式来记录对应关系。所谓的分页，就是以更大尺寸的单位页（page）来管理内存。在Linux中，通常每页大小为4KB。如果想要获取当前树莓派的内存页大小，可以使用命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
$getconf PAGE_SIZE
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;得到结果，即内存分页的字节数：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;4096&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;返回的4096代表每个内存页可以存放4096个字节，即4KB。Linux把物理内存和进程空间都分割成页。&lt;/p&gt;
&lt;p&gt;内存分页，可以极大地减少所要记录的内存对应关系。我们已经看到，以字节为单位的对应记录实在太多。如果把物理内存和进程空间的地址都分成页，内核只需要记录页的对应关系，相关的工作量就会大为减少。由于每页的大小是每个字节的4000倍。因此，内存中的总页数只是总字节数的四千分之一。对应关系也缩减为原始策略的四千分之一。分页让虚拟内存地址的设计有了实现的可能。&lt;/p&gt;
&lt;p&gt;无论是虚拟页，还是物理页，一页之内的地址都是连续的。这样的话，一个虚拟页和一个物理页对应起来，页内的数据就可以按顺序一一对应。这意味着，虚拟内存地址和物理内存地址的末尾部分应该完全相同。大多数情况下，每一页有4096个字节。由于4096是2的12次方，所以地址最后12位的对应关系天然成立。我们把地址的这一部分称为偏移量（offset）。偏移量实际上表达了该字节在页内的位置。地址的前一部分则是页编号。操作系统只需要记录页编号的对应关系。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/413416/201807/413416-20180718150907259-1604778032.png&quot; alt=&quot;&quot; width=&quot;532&quot; height=&quot;402&quot;/&gt;&lt;br/&gt;图2 地址翻译过程&lt;/p&gt;

&lt;h3&gt;多级分页表&lt;/h3&gt;
&lt;p&gt;内存分页制度的关键，在于管理进程空间页和物理页的对应关系。操作系统把对应关系记录在分页表（page table）中。这种对应关系让上层的抽象内存和下层的物理内存分离，从而让Linux能灵活地进行内存管理。由于每个进程会有一套虚拟内存地址，那么每个进程都会有一个分页表。为了保证查询速度，分页表也会保存在内存中。分页表有很多种实现方式，最简单的一种分页表就是把所有的对应关系记录到同一个线性列表中，即如图2中的“对应关系”部分所示。&lt;/p&gt;
&lt;p&gt;这种单一的连续分页表，需要给每一个虚拟页预留一条记录的位置。但对于任何一个应用进程，其进程空间真正用到的地址都相当有限。我们还记得，进程空间会有栈和堆。进程空间为栈和堆的增长预留了地址，但栈和堆很少会占满进程空间。这意味着，如果使用连续分页表，很多条目都没有真正用到。因此，Linux中的分页表，采用了多层的数据结构。多层的分页表能够减少所需的空间。&lt;/p&gt;
&lt;p&gt;我们来看一个简化的分页设计，用以说明Linux的多层分页表。我们把地址分为了页编号和偏移量两部分，用单层的分页表记录页编号部分的对应关系。对于多层分页表来说，会进一步分割页编号为两个或更多的部分，然后用两层或更多层的分页表来记录其对应关系，如图3所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/413416/201807/413416-20180718151003294-400375060.png&quot; alt=&quot;&quot; width=&quot;369&quot; height=&quot;444&quot;/&gt;&lt;br/&gt;图3 多层分页表&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;在图3的例子中，页编号分成了两级。第一级对应了前8位页编号，用2个十六进制数字表示。第二级对应了后12位页编号，用3个十六进制编号。二级表记录有对应的物理页，即保存了真正的分页记录。二级表有很多张，每个二级表分页记录对应的虚拟地址前8位都相同。比如二级表0x00，里面记录的前8位都是0x00。翻译地址的过程要跨越两级。我们先取地址的前8位，在一级表中找到对应记录。该记录会告诉我们，目标二级表在内存中的位置。我们再在二级表中，通过虚拟地址的后12位，找到分页记录，从而最终找到物理地址。&lt;/p&gt;
&lt;p&gt;多层分页表就好像把完整的电话号码分成区号。我们把同一地区的电话号码以及对应的人名记录同通一个小本子上。再用一个上级本子记录区号和各个小本子的对应关系。如果某个区号没有使用，那么我们只需要在上级本子上把该区号标记为空。同样，一级分页表中0x01记录为空，说明了以0x01开头的虚拟地址段没有使用，相应的二级表就不需要存在。正是通过这一手段，多层分页表占据的空间要比单层分页表少了很多。&lt;br/&gt;多层分页表还有另一个优势。单层分页表必须存在于连续的内存空间。而多层分页表的二级表，可以散步于内存的不同位置。这样的话，操作系统就可以利用零碎空间来存储分页表。还需要注意的是，这里简化了多层分页表的很多细节。最新Linux系统中的分页表多达3层，管理的内存地址也比本章介绍的长很多。不过，多层分页表的基本原理都是相同。&lt;/p&gt;

&lt;p&gt;综上，我们了解了内存以页为单位的管理方式。在分页的基础上，虚拟内存和物理内存实现了分离，从而让内核深度参与和监督内存分配。应用进程的安全性和稳定性因此大为提高。&lt;/p&gt;
</description>
<pubDate>Fri, 18 Jan 2019 07:48:00 +0000</pubDate>
<dc:creator>Tomorrow1</dc:creator>
<og:description>内存是计算机的主存储器。内存为进程开辟出进程空间，让进程在其中保存数据。我将从内存的物理特性出发，深入到内存管理的细节，特别是了解虚拟内存和内存分页的概念。 内存 简单地说，内存就是一个数据货架。内存</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qq_841161825/p/10288025.html</dc:identifier>
</item>
<item>
<title>Webdriver之API详解(3) - linux超</title>
<link>http://www.cnblogs.com/linuxchao/p/linuxchao-selenium-apith.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/linuxchao/p/linuxchao-selenium-apith.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;前两篇API链接&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/linuxchao/p/linuxchao-selenium-apione.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/linuxchao/p/linuxchao-selenium-apione.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/linuxchao/p/linuxchao-selenium-apitwo.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/linuxchao/p/linuxchao-selenium-apitwo.html&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;①操作多选的选择列表&lt;/h2&gt;
&lt;p&gt;被测HTML代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;en&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;操作多选列表&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;select &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;fruit&quot;&lt;/span&gt;&lt;span&gt; size&lt;/span&gt;&lt;span&gt;=&quot;6&quot;&lt;/span&gt;&lt;span&gt; multiple&lt;/span&gt;&lt;span&gt;=true&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;option &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;peach&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;taozi&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;桃子&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;option &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;watermelon&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;xigua&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;西瓜&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;option &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;orange&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;juzi&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;橘子&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;option &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;kiwifruit&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;nihoutao&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;猕猴桃&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;option &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;maybush&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;shanzha&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;山楂&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;option &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;litchi&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;lizhi&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;荔枝&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;调用API实例代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('986ffa59-7a93-4239-a156-eadca003a373')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_986ffa59-7a93-4239-a156-eadca003a373&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_986ffa59-7a93-4239-a156-eadca003a373&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('986ffa59-7a93-4239-a156-eadca003a373',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_986ffa59-7a93-4239-a156-eadca003a373&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; testMultipleOptions(self):
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;from&lt;/span&gt; selenium.webdriver.support.ui &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Select
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         self.driver.get(r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;file:///C:/Users/v-xug/Desktop/multipleOptions.html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         select_element = Select(self.driver.find_element_by_xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;//select&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 通过序号选择第一个元素&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        select_element.select_by_index(0)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 通过文本选择山楂&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;         select_element.select_by_visible_text(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;山楂&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 通过选项的value属性值选择value=猕猴桃&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;         select_element.select_by_value(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;nihoutao&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 打印所有选中文本&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; option &lt;span&gt;in&lt;/span&gt;&lt;span&gt; select_element.all_selected_options:
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(option.text)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 再次选中3个选项&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;         select_element.select_by_index(1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         select_element.select_by_value(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;juzi&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         select_element.select_by_visible_text(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;荔枝&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 取消3个选项&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        select_element.deselect_by_index(0)
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         select_element.deselect_by_value(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;nihoutao&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         select_element.deselect_by_visible_text(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;山楂&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;实例代码&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('8309cf39-1bb9-4027-b4dc-58f44bad9d6d')&quot; readability=&quot;31.5&quot;&gt;&lt;img id=&quot;code_img_closed_8309cf39-1bb9-4027-b4dc-58f44bad9d6d&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_8309cf39-1bb9-4027-b4dc-58f44bad9d6d&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('8309cf39-1bb9-4027-b4dc-58f44bad9d6d',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_8309cf39-1bb9-4027-b4dc-58f44bad9d6d&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;桃子
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;猕猴桃
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;山楂
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;.
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; ----------------------------------------------------------------------
&lt;span&gt; 6&lt;/span&gt; Ran 1 test &lt;span&gt;in&lt;/span&gt; 10&lt;span&gt;.988s
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;OK
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; Process finished with exit code 0
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;输出&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;说明：运行这段代码看到的效果是，先选择3个选项并打印被选择的选项的文本值，再次选中3个选项并取消之前被选中的3个选项，对于可以多选的操作列表，上面的几个方法是很实用的，当然实际中可能遇见各种不同的情况，还需多积累经验对不同问题用不同方法。&lt;/p&gt;
&lt;h2&gt;②操作可以输入的下拉列表（输入的同时模拟按键）&lt;/h2&gt;
&lt;p&gt;被测HTML代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;en&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;操作可输入下拉列表，输入的同时模拟按键&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;position:relative;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt;=&quot;pasta&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;select&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;datalist &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;pasta&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Bavette&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Rigatoni&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Fiorentine&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Gnocchi&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Tagliatelle&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Penne lisce&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Pici&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Pappardelle&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Spaghetti&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Cannelloni&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Cancl&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;datalist&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;调用API实例代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('f04980ab-6f88-42de-9112-a021abf38492')&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_f04980ab-6f88-42de-9112-a021abf38492&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_f04980ab-6f88-42de-9112-a021abf38492&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('f04980ab-6f88-42de-9112-a021abf38492',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_f04980ab-6f88-42de-9112-a021abf38492&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; testInputSelect(self):
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         self.driver.get(r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;file:///C:/Users/v-xug/Desktop/inputselect.html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;from&lt;/span&gt; selenium.webdriver.common.keys &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Keys
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         inputselect = self.driver.find_element_by_id(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;        inputselect.clear()
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         time.sleep(1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 输入的同时按下箭头键&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;         inputselect.send_keys(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, Keys.ARROW_DOWN)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         time.sleep(1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        inputselect.send_keys(Keys.ARROW_DOWN)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         time.sleep(1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        inputselect.send_keys(Keys.ENTER)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         time.sleep(3)
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;操作可输入下拉列表&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;说明：运行这段代码可以看到输入框输入c的同时下拉选项会筛选出数据，且选中筛选出的第一项，但是在某些浏览器中不会看到效果(我写完运行时看到的效果就没有)。keys模块提供了很多其他的模拟按键，可以通过dir()查看Keys的功能&lt;/p&gt;
&lt;h2&gt;③操作单选框&lt;/h2&gt;
&lt;p&gt;被测HTML代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;en&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;操作单选框&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;radio&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;fruit&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;berry&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;草莓&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;input&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br &lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;radio&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;fruit&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;watermelon&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;西瓜&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;input&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br &lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;radio&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;fruit&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;orange&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;橙子&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;input&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;form&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;调用API实例代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('e69596ee-fcde-440f-babe-b4b9c5c332ee')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_e69596ee-fcde-440f-babe-b4b9c5c332ee&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_e69596ee-fcde-440f-babe-b4b9c5c332ee&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('e69596ee-fcde-440f-babe-b4b9c5c332ee',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_e69596ee-fcde-440f-babe-b4b9c5c332ee&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; testRadio(self):
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         self.driver.get(r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;file:///C:/Users/v-xug/Desktop/radio.html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 定位到草莓选项&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;         time.sleep(2&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         berry = self.driver.find_element_by_xpath(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//input[@value='berry']&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        berry.click()
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 断言是否被选中&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        self.assertTrue(berry.is_selected())
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; berry.is_selected():
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如果被选中了重新选择西瓜选项&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;             watermelon = self.driver.find_element_by_xpath(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//input[@value='watermelon']&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;            watermelon.click()
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 断言草莓未被选中&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;            self.assertFalse(berry.is_selected())
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查找所有的选项&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;             options = self.driver.find_elements_by_xpath(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//input[@name='fruit']&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 遍历所有的选项，如果找到orange且未被选中，那么就选中这项&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; option &lt;span&gt;in&lt;/span&gt;&lt;span&gt; options:
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; option.get_attribute(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)==&lt;span&gt;'&lt;/span&gt;&lt;span&gt;orange&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; option.is_selected():
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                         option.click()
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;实例代码&lt;/span&gt;&lt;/div&gt;
&lt;h2&gt;④操作复选框&lt;/h2&gt;
&lt;p&gt;被测HTML代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;en&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;操作复选框&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;form1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;checkbox&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;fruit&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;berry&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;草莓&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;input&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;checkbox&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;fruit&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;watermelon&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;西瓜&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;input&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;checkbox&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;fruit&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;orange&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;橙子&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;input&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;form&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;调用API实例代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('bd609d55-4e9c-4dce-8155-2bcd6e055f9f')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_bd609d55-4e9c-4dce-8155-2bcd6e055f9f&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_bd609d55-4e9c-4dce-8155-2bcd6e055f9f&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('bd609d55-4e9c-4dce-8155-2bcd6e055f9f',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_bd609d55-4e9c-4dce-8155-2bcd6e055f9f&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; testCheckBox(self):
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         self.driver.get(r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;file:///C:/Users/v-xug/Desktop/checkbox.html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 选中一个选项并取消&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;         berry = self.driver.find_element_by_xpath(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//input[@value='berry']&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;        berry.click()
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 断言是否被选中&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        self.assertTrue(berry.is_selected())
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 取消选中&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; berry.is_selected():
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;            berry.click()
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 遍历所有的选项并选中所有的选项&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;         options = self.driver.find_elements_by_xpath(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//input[@name='fruit']&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; option &lt;span&gt;in&lt;/span&gt;&lt;span&gt; options:
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; option.is_selected():
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                 option.click()
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;实例代码&lt;/span&gt;&lt;/div&gt;
&lt;h2&gt;⑤断言页面源码中的关键字&lt;/h2&gt;
&lt;p&gt;被测地址&lt;/p&gt;
&lt;p&gt;http://www.baidu.com&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('ea2de9e3-7dc8-4ab5-9436-c6e3cfe0f2e5')&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_ea2de9e3-7dc8-4ab5-9436-c6e3cfe0f2e5&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_ea2de9e3-7dc8-4ab5-9436-c6e3cfe0f2e5&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('ea2de9e3-7dc8-4ab5-9436-c6e3cfe0f2e5',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_ea2de9e3-7dc8-4ab5-9436-c6e3cfe0f2e5&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; testAssertIn(self):
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         self.driver.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://www.baidu.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         self.driver.find_element_by_id(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;kw&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).send_keys(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;linux超&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         self.driver.find_element_by_id(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;su&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).click()
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;         &lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;         time.sleep(4&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;         self.assertIn(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;linux超&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, self.driver.page_source, msg=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;页面源码中不存在该关键字&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;实例代码&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;说明：有时候会出现页面存在要断言的关键字，但是结果仍然断言失败， 这有可能是由于页面没有加载完全就开始断言语句， 导致要断言的内容在页面源码中找不到。&lt;/p&gt;
&lt;h2&gt;⑥对当前浏览器窗口截屏&lt;/h2&gt;
&lt;p&gt;被测地址&lt;/p&gt;
&lt;p&gt;http://www.baidu.com&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('c9f86c94-ebe5-408e-a0d7-937bb1ad0cf2')&quot; readability=&quot;32&quot;&gt;&lt;img id=&quot;code_img_closed_c9f86c94-ebe5-408e-a0d7-937bb1ad0cf2&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_c9f86c94-ebe5-408e-a0d7-937bb1ad0cf2&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('c9f86c94-ebe5-408e-a0d7-937bb1ad0cf2',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_c9f86c94-ebe5-408e-a0d7-937bb1ad0cf2&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; testScreenShot(self):
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         self.driver.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://www.baidu.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 使用get_screenshot_as_file(filename)方法，对浏览器当前打开的页面截图，并保存在当前目录下&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt;             self.driver.get_screenshot_as_file(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;baidu.png&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;         &lt;span&gt;except&lt;/span&gt;&lt;span&gt; IOError as e:
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;(e)
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;实例代码&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;截图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1421063/201901/1421063-20190118132631093-1813048429.png&quot; alt=&quot;&quot; width=&quot;597&quot; height=&quot;342&quot;/&gt;&lt;/p&gt;
&lt;p&gt;说明：调用截屏函数get_screenshot_as_file()截图成功后会返回True，如果发生了IOError异常，会返回False。函数中传递的参数可以是绝对路径也可以是相对路径；当自动化测试过程中，未实现预期结果，可以将页面截图保存，方便更快速地定位问题。&lt;/p&gt;
&lt;h2&gt;⑦拖拽页面元素&lt;/h2&gt;
&lt;p&gt;被测HTML地址&lt;/p&gt;
&lt;p&gt;http://jqueryui.com/resources/demos/draggable/scroll.html&lt;/p&gt;
&lt;p&gt;调用API实例代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('ebef7cf7-f6ce-42fc-b0ec-047cc565ebcb')&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_ebef7cf7-f6ce-42fc-b0ec-047cc565ebcb&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_ebef7cf7-f6ce-42fc-b0ec-047cc565ebcb&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('ebef7cf7-f6ce-42fc-b0ec-047cc565ebcb',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_ebef7cf7-f6ce-42fc-b0ec-047cc565ebcb&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; testDragDrop(self):
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         self.driver.get(r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://jqueryui.com/resources/demos/draggable/scroll.html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         element1 = self.driver.find_element_by_id(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;draggable&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         element2 = self.driver.find_element_by_id(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;draggable2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         element3 = self.driver.find_element_by_id(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;draggable3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;from&lt;/span&gt; selenium.webdriver &lt;span&gt;import&lt;/span&gt;&lt;span&gt; ActionChains
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         action =&lt;span&gt; ActionChains(self.driver)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 把第一个元素拖拽到第二个元素的位置&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        action.drag_and_drop(element1, element2).perform()
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 把第三个元素拖拽10个像素，拖拽2次&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(2&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             action.drag_and_drop_by_offset(element3,10,10&lt;span&gt;).perform()
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             time.sleep(2&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         action.release()
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;实例代码&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;说明：ActionChains模块在前面已经涉及到过了，所有的和鼠标操作有关的动作都需要使用此模块模拟&lt;/p&gt;
&lt;h2&gt;⑧模拟键盘单个按键操作&lt;/h2&gt;
&lt;p&gt;被测HTML地址&lt;/p&gt;
&lt;p&gt;http://www.sogou.com&lt;/p&gt;
&lt;p&gt;调用API实例代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('575c7330-352a-488e-bd25-01d91be20581')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_575c7330-352a-488e-bd25-01d91be20581&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_575c7330-352a-488e-bd25-01d91be20581&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('575c7330-352a-488e-bd25-01d91be20581',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_575c7330-352a-488e-bd25-01d91be20581&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; testSingleKey(self):
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         self.driver.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://www.sogou.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         query = self.driver.find_element_by_id(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;query&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 导入模拟按键模块&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;from&lt;/span&gt; selenium.webdriver.common.keys &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Keys
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 输入框发送一个f12按键&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        query.send_keys(Keys.F12)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         time.sleep(2&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 输入框中输入搜索内容并按下回车键&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;         query.send_keys(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;selenium&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        query.send_keys(Keys.ENTER)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         time.sleep(2)
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;实例代码&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;说明：有些电脑运行这个代码可能看不到效果，因为有的电脑的F12键 是需要和Fn组合才能生效的。&lt;/p&gt;
&lt;p&gt;总结：今天的整理到此结束，说实话我不知道对读到我文章的人帮助有多大，但是对我个人而言是又经历了一次知识的梳理。把之前忘记的也都慢慢的想起来了，虽然每个实例看着都挺简单的，其实耗费了我很多精力和时间，因为我想让读到我博客的人只看一次代码只运行一次实例就能知道实现的是什么功能，能把这个功能应用到复杂的测试场景中。其实这也是我自己的一次自我总结把！（最后说一句，我之前是想把每个实例运行的现象用视频记录下来，但是当我记录完之后，并嵌入到文章后视频根本不显示，也不知道什么原因，我是有js权限的。有人知道什么原因的话，给我留言或者加我qq教我一下，非常感谢！）&lt;/p&gt;
</description>
<pubDate>Fri, 18 Jan 2019 07:35:00 +0000</pubDate>
<dc:creator>linux超</dc:creator>
<og:description>前言 前两篇API链接 https://www.cnblogs.com/linuxchao/p/linuxchao-selenium-apione.html https://www.cnblogs.c</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/linuxchao/p/linuxchao-selenium-apith.html</dc:identifier>
</item>
<item>
<title>Linux 下如何调试 Python？ - hoxis</title>
<link>http://www.cnblogs.com/hoxis/p/10287903.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hoxis/p/10287903.html</guid>
<description>&lt;p&gt;一般开发者都是在 IDE 中进行程序的调试，当然，有 IDE 的话，当然首选 IDE 进行调试。&lt;/p&gt;
&lt;p&gt;但是，有时我们的业务场景，限制只能在 Linux 命令行模式进行调试。&lt;/p&gt;
&lt;p&gt;这时该怎么办呢？&lt;/p&gt;
&lt;p&gt;今天，就给大家介绍一个 Linux 下调试 Python 程序的工具。&lt;/p&gt;

&lt;p&gt;pdb 调试器是 Python 标准库提供的，因此最为方便，不需要安装其他组件，直接 import 后就能使用。&lt;/p&gt;
&lt;p&gt;pdb 调试器提供了调试所需的大多数功能，如断点、单行步进、堆栈帧的检查等等。&lt;/p&gt;

&lt;pre&gt;
&lt;code&gt;l # 查看运行到哪行代码 
n # 单步运行，跳过函数 
s # 单步运行，可进入函数 
p 变量 # 查看变量值 
b 行号 # 断点设置到第几行 
b # 显示所有断点列表 
cl 断点号 # 删除某个断点 
cl # 删除所有断点 
c # 跳到下一个断点 
r # return 当前函数 
exit # 退出&lt;/code&gt;
&lt;/pre&gt;

&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;本文 Python 环境：Python 3.5.2&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们先准备一小段演示程序：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# -*- coding: utf-8 -*-

def add(a, b):
    return a + b

if __name__ == '__main__':
    print(&quot;===start===&quot;)
    c = add(1, 3)
    print(&quot;===end===&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;使用方法 1&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;运行 pdb 的最简单方法是从命令行，将程序作为参数传递来调试。&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ python -m pdb test_pdb.py&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这时，就开始单步执行了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blog-1254259578.cos.ap-shanghai.myqcloud.com/picgo/20190109161704.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这种方法对代码没有侵入性，但是每次都需要设置断点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用方法 2&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;在代码头部引入 pdb，然后可以在代码里，通过 &lt;code&gt;pdb.set_trace()&lt;/code&gt; 来设置断点：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# -*- coding: utf-8 -*-
import pdb

def add(a, b):
    pdb.set_trace()
    return a + b

if __name__ == '__main__':
        print(&quot;===start===&quot;)
        pdb.set_trace()
        c = add(1, 3)
        print(&quot;===end===&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时，运行程序，就会自动跳转到设置的断点处：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blog-1254259578.cos.ap-shanghai.myqcloud.com/picgo/20190109165557.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;没了图形化页面，调试只能这么来了，不过还好，pdb 使用看着不难吧。&lt;/p&gt;
&lt;p&gt;其实还有一些增强的调试器，比如 IPython 的 ipdb 和 pdb++，它们一般都提供了更好的用户体验，添加了有用的额外功能，例如语法突出高亮、更好的回溯和自省。&lt;/p&gt;
&lt;p&gt;后面有机会再给大家分享吧！&lt;/p&gt;
</description>
<pubDate>Fri, 18 Jan 2019 07:32:00 +0000</pubDate>
<dc:creator>hoxis</dc:creator>
<og:description>一般开发者都是在 IDE 中进行程序的调试，当然，有 IDE 的话，当然首选 IDE 进行调试。 但是，有时我们的业务场景，限制只能在 Linux 命令行模式进行调试。 这时该怎么办呢？ &lt;! mor</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hoxis/p/10287903.html</dc:identifier>
</item>
<item>
<title>初识Pyhon之准备环境 - Stupid_Sparrow</title>
<link>http://www.cnblogs.com/hcf-fcl/p/10287702.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hcf-fcl/p/10287702.html</guid>
<description>&lt;p&gt;安装成功python的运行环境之后，你可能要迫不及待大展身手了&lt;/p&gt;
&lt;p&gt;如果你有一定的语言基础，那么基础这一块儿就可以简单的看看就可以了，但是你是一个编程语言的初学者。不着急，慢慢往下看&lt;/p&gt;
&lt;p&gt;打开pycharm创建一个python工程&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1342270/201901/1342270-20190118145919907-912192309.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;创建Python文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1342270/201901/1342270-20190118150335678-133047603.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 至此，创建出了一个简单的Python'脚本文件，之后我们还会涉及到项目的搭建&lt;/p&gt;
&lt;p&gt;搭建环境&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1342270/201901/1342270-20190118151328197-918747720.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;路径一定要对。一定要使用自己安装的Python包&lt;/p&gt;
&lt;p&gt;第一个程序&lt;/p&gt;
&lt;p&gt;print(&quot;Hello Python world!&quot;)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1342270/201901/1342270-20190118151110345-103836956.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1342270/201901/1342270-20190118151245225-1257835645.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 18 Jan 2019 07:06:00 +0000</pubDate>
<dc:creator>Stupid_Sparrow</dc:creator>
<og:description>安装成功python的运行环境之后，你可能要迫不及待大展身手了 如果你有一定的语言基础，那么基础这一块儿就可以简单的看看就可以了，但是你是一个编程语言的初学者。不着急，慢慢往下看 打开pycharm创</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hcf-fcl/p/10287702.html</dc:identifier>
</item>
<item>
<title>我是李玉宝，我是个程序员！ - 李玉宝</title>
<link>http://www.cnblogs.com/yubaolee/p/10287643.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yubaolee/p/10287643.html</guid>
<description>&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/42655/201901/42655-20190118145628670-244289173.jpg&quot;&gt;&lt;img title=&quot;微信截图_20190118145159&quot; src=&quot;https://img2018.cnblogs.com/blog/42655/201901/42655-20190118145631358-1985983773.jpg&quot; alt=&quot;微信截图_20190118145159&quot; width=&quot;244&quot; height=&quot;150&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;听说今天我的名字很火，那我也来凑个热闹。在2015年的时候，我做过一次人生总结，当时写了：&lt;a href=&quot;https://www.cnblogs.com/yubaolee/p/4652772.html&quot; target=&quot;_blank&quot;&gt;为了理想，我放弃了一切！&lt;/a&gt;  转眼到了2019年，说说这3年多的一些事情吧！&lt;/p&gt;
&lt;h2&gt;做的好的！&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;坚持把&lt;a href=&quot;http://openauth.me/&quot; target=&quot;_blank&quot;&gt;OpenAuth.Net&lt;/a&gt;做了下来，star数已经1800+。在开源中国这个java横行的地方为.NET赚点颜面。&lt;/li&gt;
&lt;li&gt;成功的把OpenAuth.Net转成.net core版本（&lt;a href=&quot;https://gitee.com/yubaolee/OpenAuth.Core&quot; target=&quot;_blank&quot;&gt;OpenAuth.Core&lt;/a&gt;），并成功的部署在centos + docker + jenkins。现在每次发新版再也不会绞尽脑汁想我的服务器到底是哪个IP地址了。&lt;/li&gt;
&lt;li&gt;前端技术栈从jquery成功过度到vue。不得不说在学vue的过程中，见识到了javascript以前从没用过的神一般的操作。比如三点运算符。&lt;/li&gt;
&lt;li&gt;认认真真的折腾了一下java，把自己的主站（&lt;a title=&quot;http://openauth.me/&quot; href=&quot;http://openauth.me/&quot;&gt;http://openauth.me/&lt;/a&gt; ）全部重构为springboot。&lt;/li&gt;
&lt;li&gt;深入学习了大型集团的商业流程，也就是ERP那套。不可否认他们的技术很落后，但他们的业务是无比的复杂，比学习技术要投入更大的精力。而且一旦熟悉业务，可以保持长久的竞争力。&lt;/li&gt;
&lt;li&gt;陪家人出了一次国，省外自驾游2次。希望今年有钱坚持。&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;做的不好的！&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;买了一堆的书，一半没开封。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/42655/201901/42655-20190118145633885-783333168.jpg&quot;&gt;&lt;img title=&quot;微信图片_20190118145129&quot; src=&quot;https://img2018.cnblogs.com/blog/42655/201901/42655-20190118145634476-2064033976.jpg&quot; alt=&quot;微信图片_20190118145129&quot; width=&quot;363&quot; height=&quot;273&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对需求沟通还是存在问题，不能理解复杂业务的本质。以前在私企业和互联网行业，业务都比价简单，对于复杂的商业流程，通常不能理解客户和同事所说的问题，更严重的是，在倾听的过程中容易走神！！！&lt;/li&gt;
&lt;li&gt;没能把写博客的习惯坚持下来，这个新的一年必须改善。&lt;/li&gt;
&lt;li&gt;管理能力没有半点提高。感觉项目管理的各个环节自己都胸有成竹，但感觉就是做的不够好。看了一大堆的管理书籍，管理心得，但没有质的升华。&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;做技术的一些心得&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;我不明白为什么学docker需要看一本几百页的书。我们作为一门技术的使用者，除非你要去开发一个docker。&lt;strong&gt;&lt;span&gt;真正认识它，一句话就够了：轻量级虚拟机&lt;/span&gt;&lt;/strong&gt;。这样一句话就能让一个从事开发10几年的人，意识到它的作用，而不是docker入门系列XXXXX，现在很多的技术作者都试图用一大堆废话去解释一个简单的问题，包括博客园部分写系列文章的。&lt;/li&gt;
&lt;li&gt;语言真的不是问题，&lt;span&gt;&lt;strong&gt;用好c#的同样可以用好java&lt;/strong&gt;&lt;/span&gt;。我在使用java的过程中，给公司的几个JAVA老顽固强推了lambd表达式，他们像发现新大陆一样。&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;做事情的一些心得&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;只要想做，没有什么做不下来的。好奇心才能让我们活下去！在我做openauth.core的时候，很多朋友和我描述过，我已经用.net很多年了，没必要再折腾.net core了。还不都一样可以完成工作。是啊！这么多年了，我们从ASP折腾起，还折腾这些做什么。&lt;span&gt;&lt;strong&gt;别忘了，我们是做的什么行业，这个行业最需要的就是好奇心，需要的就是对新东西的探索欲。这些到死都不能放弃！&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span&gt;如果想要活的自由，那么多学技术。如果想要在一家公司走的更远，那就好好研究公司业务！&lt;/span&gt;&lt;/strong&gt;在一个小公司，你可以让老板跪倒在你绚烂的技术之下，但在大型外企或上市公司，精通业务才是王道。一个不懂业务的技术是不可能走的太远，领导们开会你话都接不上。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span&gt;正确的认识自己。做技术的，一旦把自己定位成中产，往往就悲剧了。&lt;/span&gt;&lt;/strong&gt;我认识一些技术人员，觉得写程序是神一般的事情，其他人的工作都是狗屎。其实我们日常的开发，也只是各种工具的使用，各种三方插件的使用，是需要一些技术，但远没有搞科研那么尖端。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最后：我是李玉宝，我是个程序员，不要问我啥是佩奇&lt;img class=&quot;wlEmoticon wlEmoticon-winkingsmile&quot; src=&quot;https://img2018.cnblogs.com/blog/42655/201901/42655-20190118145812697-913242432.png&quot; alt=&quot;Winking smile&quot;/&gt;&lt;img class=&quot;wlEmoticon wlEmoticon-winkingsmile&quot; src=&quot;https://img2018.cnblogs.com/blog/42655/201901/42655-20190118145812697-913242432.png&quot; alt=&quot;Winking smile&quot;/&gt;&lt;img class=&quot;wlEmoticon wlEmoticon-winkingsmile&quot; src=&quot;https://img2018.cnblogs.com/blog/42655/201901/42655-20190118145812697-913242432.png&quot; alt=&quot;Winking smile&quot;/&gt;&lt;img class=&quot;wlEmoticon wlEmoticon-winkingsmile&quot; src=&quot;https://img2018.cnblogs.com/blog/42655/201901/42655-20190118145812697-913242432.png&quot; alt=&quot;Winking smile&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/42655/201901/42655-20190118145634985-902185607.jpg&quot;&gt;&lt;img title=&quot;微信图片_20190118145118&quot; src=&quot;https://img2018.cnblogs.com/blog/42655/201901/42655-20190118145635536-1771128454.jpg&quot; alt=&quot;微信图片_20190118145118&quot; width=&quot;499&quot; height=&quot;233&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 18 Jan 2019 07:00:00 +0000</pubDate>
<dc:creator>李玉宝</dc:creator>
<og:description>听说今天我的名字很火，那我也来凑个热闹。在2015年的时候，我做过一次人生总结，当时写了：为了理想，我放弃了一切！ 转眼到了2019年，说说这3年多的一些事情吧！ 做的好的！ 坚持把OpenAuth.</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yubaolee/p/10287643.html</dc:identifier>
</item>
<item>
<title>Java并发基础10：原子性操作类的使用 - 程序员私房菜</title>
<link>http://www.cnblogs.com/eson15/p/10287670.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/eson15/p/10287670.html</guid>
<description>&lt;p&gt;在 java5 以后，我们接触到了线程原子性操作，也就是在修改时我们只需要保证它的那个瞬间是安全的即可，经过相应的包装后可以再处理对象的并发修改，本文总结一下Atomic系列的类的使用方法，其中包含：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;基本类型&lt;/td&gt;
&lt;td&gt;AtomicInteger&lt;/td&gt;
&lt;td&gt;AtomicLong&lt;/td&gt;
&lt;td&gt;AtomicBoolean&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;数组类型&lt;/td&gt;
&lt;td&gt;AtomicIntegerArray&lt;/td&gt;
&lt;td&gt;AtomicLongArray&lt;/td&gt;
&lt;td&gt;AtomicReferenceArray&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;属性原子修改器&lt;/td&gt;
&lt;td&gt;AtomicIntegerFieldUpdater&lt;/td&gt;
&lt;td&gt;AtomicLongFieldUpdater&lt;/td&gt;
&lt;td&gt;AtomicReferenceFieldUpdater&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;基本类型的使用&quot;&gt;1. 基本类型的使用&lt;/h2&gt;
&lt;p&gt;首先看一下AtomicInteger的使用，AtomicInteger主要是针对整数的修改的，看一下示例代码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class AtomicIntegerDemo {

    /**
     * 常见的方法列表
     * @see AtomicInteger#get()             直接返回值
     * @see AtomicInteger#getAndAdd(int)    增加指定的数据，返回变化前的数据
     * @see AtomicInteger#getAndDecrement() 减少1，返回减少前的数据
     * @see AtomicInteger#getAndIncrement() 增加1，返回增加前的数据
     * @see AtomicInteger#getAndSet(int)    设置指定的数据，返回设置前的数据
     * 
     * @see AtomicInteger#addAndGet(int)    增加指定的数据后返回增加后的数据
     * @see AtomicInteger#decrementAndGet() 减少1，返回减少后的值
     * @see AtomicInteger#incrementAndGet() 增加1，返回增加后的值
     * @see AtomicInteger#lazySet(int)      仅仅当get时才会set
     * 
     * @see AtomicInteger#compareAndSet(int, int) 尝试新增后对比，若增加成功则返回true否则返回false
     */
    public final static AtomicInteger TEST_INTEGER = new AtomicInteger(1);
    
    public static void main(String []args) {

         for(int i = 0 ; i &amp;lt; 10 ; i++) { //开启10个线程

             new Thread() {
                 public void run() {
                     try {
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    int now = TEST_INTEGER.incrementAndGet(); //自增
                    System.out.println(Thread.currentThread().getName() + &quot; get value : &quot; + now);
                 }
             }.start();
         }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看一下结果：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;Thread-3 get value : 4&lt;br/&gt;Thread-7 get value : 5&lt;br/&gt;Thread-9 get value : 9&lt;br/&gt;Thread-4 get value : 6&lt;br/&gt;Thread-0 get value : 3&lt;br/&gt;Thread-1 get value : 8&lt;br/&gt;Thread-5 get value : 11&lt;br/&gt;Thread-8 get value : 7&lt;br/&gt;Thread-2 get value : 10&lt;br/&gt;Thread-6 get value : 2&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以看出，10个线程之间是线程安全的，并没有冲突。也就是说，我们使用原子性操作类去操作基本类型int就可以解决线程安全问题，一个线程在操作的时候，会对其它线程进行排斥，不用我们手动去使用synchronized实现互斥操作了。AtomicLong和AtomicBoolean类似，就不举例子了。&lt;/p&gt;
&lt;h2 id=&quot;数组类型的使用&quot;&gt;2. 数组类型的使用&lt;/h2&gt;
&lt;p&gt;下面要开始说Atomic的数组用法，Atomic的数组要求不允许修改长度等，不像集合类那么丰富的操作，不过它可以让数组上每个元素的操作绝对安全的，也就是它细化的力度还是到数组上的元素，做了二次包装，虽然是数组类型的，但是最后还是操作数组中存的数，所以会了上面的基本类型的话，数组类型也很好理解。这里主要看一下AtomicIntegerArray的使用，其它的类似。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class AtomicIntegerArrayTest {

    /**
     * 常见的方法列表
     * @see AtomicIntegerArray#addAndGet(int, int) 执行加法，第一个参数为数组的下标，第二个参数为增加的数量，返回增加后的结果
     * @see AtomicIntegerArray#compareAndSet(int, int, int) 对比修改，参数1：数组下标，参数2：原始值，参数3，修改目标值，修改成功返回true否则false
     * @see AtomicIntegerArray#decrementAndGet(int) 参数为数组下标，将数组对应数字减少1，返回减少后的数据
     * @see AtomicIntegerArray#incrementAndGet(int) 参数为数组下标，将数组对应数字增加1，返回增加后的数据
     * 
     * @see AtomicIntegerArray#getAndAdd(int, int) 和addAndGet类似，区别是返回值是变化前的数据
     * @see AtomicIntegerArray#getAndDecrement(int) 和decrementAndGet类似，区别是返回变化前的数据
     * @see AtomicIntegerArray#getAndIncrement(int) 和incrementAndGet类似，区别是返回变化前的数据
     * @see AtomicIntegerArray#getAndSet(int, int) 将对应下标的数字设置为指定值，第二个参数为设置的值，返回是变化前的数据
     */
    private final static AtomicIntegerArray ATOMIC_INTEGER_ARRAY = new AtomicIntegerArray(new int[]{1,2,3,4,5,6,7,8,9,10});
    
    public static void main(String []args) throws InterruptedException {
        Thread []threads = new Thread[10];
        for(int i = 0 ; i &amp;lt; 10 ; i++) {
            final int index = i;
            final int threadNum = i;
            threads[i] = new Thread() {
                public void run() {
                    int result = ATOMIC_INTEGER_ARRAY.addAndGet(index, index + 1);
                    System.out.println(&quot;线程编号为：&quot; + threadNum + &quot; , 对应的原始值为：&quot; + (index + 1) + &quot;，增加后的结果为：&quot; + result);
                }
            };
            threads[i].start();
        }
        for(Thread thread : threads) {
            thread.join();
        }
        System.out.println(&quot;=========================&amp;gt;\n执行已经完成，结果列表：&quot;);
        for(int i = 0 ; i &amp;lt; ATOMIC_INTEGER_ARRAY.length() ; i++) {
            System.out.println(ATOMIC_INTEGER_ARRAY.get(i));
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果是给每个数组元素加上相同的值，它们之间互不影响。&lt;/p&gt;
&lt;h2 id=&quot;作为类属性的使用&quot;&gt;3. 作为类属性的使用&lt;/h2&gt;
&lt;p&gt;当某个数据类型是某个类中的一个属性的时候，然后我们要操作该数据，就需要使用属性原子修改器了，这里还是以Integer为例，即：AtomicIntegerFieldUpdater。示例代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class AtomicIntegerFieldUpdaterTest {  
      
    static class A {  
        volatile int intValue = 100;  
    }  
      
    /** 
     * 可以直接访问对应的变量，进行修改和处理 
     * 条件：要在可访问的区域内，如果是private或挎包访问default类型以及非父亲类的protected均无法访问到 
     * 其次访问对象不能是static类型的变量（因为在计算属性的偏移量的时候无法计算），也不能是final类型的变量（因为根本无法修改），必须是普通的成员变量 
     *  
     * 方法（说明上和AtomicInteger几乎一致，唯一的区别是第一个参数需要传入对象的引用） 
     * @see AtomicIntegerFieldUpdater#addAndGet(Object, int) 
     * @see AtomicIntegerFieldUpdater#compareAndSet(Object, int, int) 
     * @see AtomicIntegerFieldUpdater#decrementAndGet(Object) 
     * @see AtomicIntegerFieldUpdater#incrementAndGet(Object) 
     *  
     * @see AtomicIntegerFieldUpdater#getAndAdd(Object, int) 
     * @see AtomicIntegerFieldUpdater#getAndDecrement(Object) 
     * @see AtomicIntegerFieldUpdater#getAndIncrement(Object) 
     * @see AtomicIntegerFieldUpdater#getAndSet(Object, int) 
     */  
    public final static AtomicIntegerFieldUpdater&amp;lt;A&amp;gt; ATOMIC_INTEGER_UPDATER = AtomicIntegerFieldUpdater.newUpdater(A.class, &quot;intValue&quot;);  
      
    public static void main(String []args) {  
        final A a = new A();  
        for(int i = 0 ; i &amp;lt; 10 ; i++) {  

            new Thread() {  
                public void run() {  
                    if(ATOMIC_INTEGER_UPDATER.compareAndSet(a, 100, 120)) {  
                        System.out.println(Thread.currentThread().getName() + &quot; 对对应的值做了修改！&quot;);  
                    }  
                }  
            }.start();  
        }  
    }  
}  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，这里需要将类和类属性传进去才行，传进去后其实跟前面操作Integer没什么不同了，本质都一样的，运行一下，结果只有一个线程能对其进行修改。&lt;/p&gt;
&lt;p&gt;线程的原子性操作类的使用就简单总结到这，其他的操作类原理都相似，可以参考 JDK 的文档，可以很容易写出相应的测试代码。&lt;/p&gt;
&lt;p&gt;原子性操作类的使用就分享这么多，如有错误之处，欢迎指正，我们一同进步~&lt;/p&gt;
</description>
<pubDate>Fri, 18 Jan 2019 07:00:00 +0000</pubDate>
<dc:creator>程序员私房菜</dc:creator>
<og:description>在 java5 以后，我们接触到了线程原子性操作，也就是在修改时我们只需要保证它的那个瞬间是安全的即可，经过相应的包装后可以再处理对象的并发修改，本文总结一下Atomic系列的类的使用方法，其中包含：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/eson15/p/10287670.html</dc:identifier>
</item>
<item>
<title>Kafka、ActiveMQ、RabbitMQ、RocketMQ 区别以及高可用原理 - 2货我怕谁</title>
<link>http://www.cnblogs.com/jay-wu/p/10287636.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jay-wu/p/10287636.html</guid>
<description>&lt;h3&gt;为什么使用消息队列&lt;/h3&gt;
&lt;p&gt;其实就是问问你消息队列都有哪些使用场景，然后你项目里具体是什么场景，说说你在这个场景里用消息队列是什么？&lt;/p&gt;
&lt;p&gt;面试官问你这个问题，期望的一个回答是说，你们公司有个什么业务场景，这个业务场景有个什么技术挑战，如果不用 MQ 可能会很麻烦，但是你现在用了 MQ 之后带给了你很多的好处。&lt;/p&gt;
&lt;p&gt;先说一下消息队列常见的使用场景吧，其实场景有很多，但是比较核心的有 3 个：解耦、异步、削峰。&lt;/p&gt;
&lt;h4&gt;解耦&lt;/h4&gt;
&lt;p&gt;看这么个场景。A 系统发送数据到 BCD 三个系统，通过接口调用发送。如果 E 系统也要这个数据呢？那如果 C 系统现在不需要了呢？A 系统负责人几乎崩溃......&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/doocs/advanced-java/raw/master/images/mq-1.png&quot; alt=&quot;mq-1&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在这个场景中，A 系统跟其它各种乱七八糟的系统严重耦合，A 系统产生一条比较关键的数据，很多系统都需要 A 系统将这个数据发送过来。A 系统要时时刻刻考虑 BCDE 四个系统如果挂了该咋办？要不要重发，要不要把消息存起来？头发都白了啊！&lt;/p&gt;
&lt;p&gt;如果使用 MQ，A 系统产生一条数据，发送到 MQ 里面去，哪个系统需要数据自己去 MQ 里面消费。如果新系统需要数据，直接从 MQ 里消费即可；如果某个系统不需要这条数据了，就取消对 MQ 消息的消费即可。这样下来，A 系统压根儿不需要去考虑要给谁发送数据，不需要维护这个代码，也不需要考虑人家是否调用成功、失败超时等情况。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/doocs/advanced-java/raw/master/images/mq-2.png&quot; alt=&quot;mq-2&quot;/&gt;&lt;/p&gt;
&lt;p&gt;总结：通过一个 MQ，Pub/Sub 发布订阅消息这么一个模型，A 系统就跟其它系统彻底解耦了。&lt;/p&gt;
&lt;p&gt;面试技巧：你需要去考虑一下你负责的系统中是否有类似的场景，就是一个系统或者一个模块，调用了多个系统或者模块，互相之间的调用很复杂，维护起来很麻烦。但是其实这个调用是不需要直接同步调用接口的，如果用 MQ 给它异步化解耦，也是可以的，你就需要去考虑在你的项目里，是不是可以运用这个 MQ 去进行系统的解耦。在简历中体现出来这块东西，用 MQ 作解耦。&lt;/p&gt;
&lt;h4&gt;异步&lt;/h4&gt;
&lt;p&gt;再来看一个场景，A 系统接收一个请求，需要在自己本地写库，还需要在 BCD 三个系统写库，自己本地写库要 3ms，BCD 三个系统分别写库要 300ms、450ms、200ms。最终请求总延时是 3 + 300 + 450 + 200 = 953ms，接近 1s，用户感觉搞个什么东西，慢死了慢死了。用户通过浏览器发起请求，等待个 1s，这几乎是不可接受的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/doocs/advanced-java/raw/master/images/mq-3.png&quot; alt=&quot;mq-3&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一般互联网类的企业，对于用户直接的操作，一般要求是每个请求都必须在 200 ms 以内完成，对用户几乎是无感知的。&lt;/p&gt;
&lt;p&gt;如果使用 MQ，那么 A 系统连续发送 3 条消息到 MQ 队列中，假如耗时 5ms，A 系统从接受一个请求到返回响应给用户，总时长是 3 + 5 = 8ms，对于用户而言，其实感觉上就是点个按钮，8ms 以后就直接返回了，爽！网站做得真好，真快！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/doocs/advanced-java/raw/master/images/mq-4.png&quot; alt=&quot;mq-4&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;削峰&lt;/h4&gt;
&lt;p&gt;每天 0:00 到 12:00，A 系统风平浪静，每秒并发请求数量就 50 个。结果每次一到 12:00 ~ 13:00 ，每秒并发请求数量突然会暴增到 5k+ 条。但是系统是直接基于 MySQL 的，大量的请求涌入 MySQL，每秒钟对 MySQL 执行约 5k 条 SQL。&lt;/p&gt;
&lt;p&gt;一般的 MySQL，扛到每秒 2k 个请求就差不多了，如果每秒请求到 5k 的话，可能就直接把 MySQL 给打死了，导致系统崩溃，用户也就没法再使用系统了。&lt;/p&gt;
&lt;p&gt;但是高峰期一过，到了下午的时候，就成了低峰期，可能也就 1w 的用户同时在网站上操作，每秒中的请求数量可能也就 50 个请求，对整个系统几乎没有任何的压力。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/doocs/advanced-java/raw/master/images/mq-5.png&quot; alt=&quot;mq-5&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果使用 MQ，每秒 5k 个请求写入 MQ，A 系统每秒钟最多处理 2k 个请求，因为 MySQL 每秒钟最多处理 2k 个。A 系统从 MQ 中慢慢拉取请求，每秒钟就拉取 2k 个请求，不要超过自己每秒能处理的最大请求数量就 ok，这样下来，哪怕是高峰期的时候，A 系统也绝对不会挂掉。而 MQ 每秒钟 5k 个请求进来，就 2k 个请求出去，结果就导致在中午高峰期（1 个小时），可能有几十万甚至几百万的请求积压在 MQ 中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/doocs/advanced-java/raw/master/images/mq-6.png&quot; alt=&quot;mq-6&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个短暂的高峰期积压是 ok 的，因为高峰期过了之后，每秒钟就 50 个请求进 MQ，但是 A 系统依然会按照每秒 2k 个请求的速度在处理。所以说，只要高峰期一过，A 系统就会快速将积压的消息给解决掉。&lt;/p&gt;
&lt;h3&gt;消息队列有什么优缺点&lt;/h3&gt;
&lt;p&gt;优点上面已经说了，就是在特殊场景下有其对应的好处，解耦、异步、削峰。&lt;/p&gt;
&lt;p&gt;缺点有以下几个：&lt;/p&gt;
&lt;ul readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;系统可用性降低&lt;br/&gt;系统引入的外部依赖越多，越容易挂掉。本来你就是 A 系统调用 BCD 三个系统的接口就好了，人 ABCD 四个系统好好的，没啥问题，你偏加个 MQ 进来，万一 MQ 挂了咋整，MQ 一挂，整套系统崩溃的，你不就完了？如何保证消息队列的高可用&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;系统复杂度提高&lt;br/&gt;硬生生加个 MQ 进来，你怎么保证消息没有重复消费？怎么处理消息丢失的情况？怎么保证消息传递的顺序性？头大头大，问题一大堆，痛苦不已。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;一致性问题&lt;br/&gt;A 系统处理完了直接返回成功了，人都以为你这个请求就成功了；但是问题是，要是 BCD 三个系统那里，BD 两个系统写库成功了，结果 C 系统写库失败了，咋整？你这数据就不一致了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所以消息队列实际是一种非常复杂的架构，你引入它有很多好处，但是也得针对它带来的坏处做各种额外的技术方案和架构来规避掉，做好之后，你会发现，妈呀，系统复杂度提升了一个数量级，也许是复杂了 10 倍。但是关键时刻，用，还是得用的。&lt;/p&gt;
&lt;h3&gt;Kafka、ActiveMQ、RabbitMQ、RocketMQ 有什么优缺点？&lt;/h3&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;特性&lt;/th&gt;
&lt;th&gt;ActiveMQ&lt;/th&gt;
&lt;th&gt;RabbitMQ&lt;/th&gt;
&lt;th&gt;RocketMQ&lt;/th&gt;
&lt;th&gt;Kafka&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;19&quot;&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td&gt;单机吞吐量&lt;/td&gt;
&lt;td&gt;万级，比 RocketMQ、Kafka 低一个数量级&lt;/td&gt;
&lt;td&gt;同 ActiveMQ&lt;/td&gt;
&lt;td&gt;10 万级，支撑高吞吐&lt;/td&gt;
&lt;td&gt;10 万级，高吞吐，一般配合大数据类的系统来进行实时数据计算、日志采集等场景&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;9&quot;&gt;&lt;td&gt;topic 数量对吞吐量的影响&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;topic 可以达到几百/几千的级别，吞吐量会有较小幅度的下降，这是 RocketMQ 的一大优势，在同等机器下，可以支撑大量的 topic&lt;/td&gt;
&lt;td&gt;topic 从几十到几百个时候，吞吐量会大幅度下降，在同等机器下，Kafka 尽量保证 topic 数量不要过多，如果要支撑大规模的 topic，需要增加更多的机器资源&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;时效性&lt;/td&gt;
&lt;td&gt;ms 级&lt;/td&gt;
&lt;td&gt;微秒级，这是 RabbitMQ 的一大特点，延迟最低&lt;/td&gt;
&lt;td&gt;ms 级&lt;/td&gt;
&lt;td&gt;延迟在 ms 级以内&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td&gt;可用性&lt;/td&gt;
&lt;td&gt;高，基于主从架构实现高可用&lt;/td&gt;
&lt;td&gt;同 ActiveMQ&lt;/td&gt;
&lt;td&gt;非常高，分布式架构&lt;/td&gt;
&lt;td&gt;非常高，分布式，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;消息可靠性&lt;/td&gt;
&lt;td&gt;有较低的概率丢失数据&lt;/td&gt;
&lt;td&gt;基本不丢&lt;/td&gt;
&lt;td&gt;经过参数优化配置，可以做到 0 丢失&lt;/td&gt;
&lt;td&gt;同 RocketMQ&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;9&quot;&gt;&lt;td&gt;功能支持&lt;/td&gt;
&lt;td&gt;MQ 领域的功能极其完备&lt;/td&gt;
&lt;td&gt;基于 erlang 开发，并发能力很强，性能极好，延时很低&lt;/td&gt;
&lt;td&gt;MQ 功能较为完善，还是分布式的，扩展性好&lt;/td&gt;
&lt;td&gt;功能较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及日志采集被大规模使用&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;综上，各种对比之后，有如下建议：&lt;/p&gt;
&lt;p&gt;一般的业务系统要引入 MQ，最早大家都用 ActiveMQ，但是现在确实大家用的不多了，没经过大规模吞吐量场景的验证，社区也不是很活跃，所以大家还是算了吧，我个人不推荐用这个了；&lt;/p&gt;
&lt;p&gt;后来大家开始用 RabbitMQ，但是确实 erlang 语言阻止了大量的 Java 工程师去深入研究和掌控它，对公司而言，几乎处于不可控的状态，但是确实人家是开源的，比较稳定的支持，活跃度也高；&lt;/p&gt;
&lt;p&gt;不过现在确实越来越多的公司，会去用 RocketMQ，确实很不错（阿里出品），但社区可能有突然黄掉的风险，对自己公司技术实力有绝对自信的，推荐用 RocketMQ，否则回去老老实实用 RabbitMQ 吧，人家有活跃的开源社区，绝对不会黄。&lt;/p&gt;
&lt;p&gt;所以中小型公司，技术实力较为一般，技术挑战不是特别高，用 RabbitMQ 是不错的选择；大型公司，基础架构研发实力较强，用 RocketMQ 是很好的选择。&lt;/p&gt;
&lt;p&gt;如果是大数据领域的实时计算、日志采集等场景，用 Kafka 是业内标准的，绝对没问题，社区活跃度很高，绝对不会黄，何况几乎是全世界这个领域的事实性规范&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;如何保证消息队列的高可用？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h3&gt;RabbitMQ 的高可用性&lt;/h3&gt;

&lt;p&gt;RabbitMQ 是比较有代表性的，因为是基于主从（非分布式）做高可用性的，我们就以 RabbitMQ 为例子讲解第一种 MQ 的高可用性怎么实现。&lt;/p&gt;

&lt;p&gt;RabbitMQ 有三种模式：单机模式、普通集群模式、镜像集群模式。&lt;/p&gt;

&lt;h4&gt;单机模式&lt;/h4&gt;

&lt;p&gt;单机模式，就是 Demo 级别的，一般就是你本地启动了玩玩儿的&lt;img class=&quot;emoji&quot; src=&quot;https://github.githubassets.com/images/icons/emoji/unicode/1f604.png&quot; alt=&quot;smile&quot; width=&quot;20&quot; height=&quot;20&quot;/&gt;，没人生产用单机模式。&lt;/p&gt;

&lt;h4&gt;普通集群模式（无高可用性）&lt;/h4&gt;

&lt;p&gt;普通集群模式，意思就是在多台机器上启动多个 RabbitMQ 实例，每个机器启动一个。你创建的 queue，只会放在一个 RabbitMQ 实例上，但是每个实例都同步 queue 的元数据（元数据可以认为是 queue 的一些配置信息，通过元数据，可以找到 queue 所在实例）。你消费的时候，实际上如果连接到了另外一个实例，那么那个实例会从 queue 所在实例上拉取数据过来。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/doocs/advanced-java/blob/master/images/mq-7.png&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://github.com/doocs/advanced-java/raw/master/images/mq-7.png&quot; alt=&quot;mq-7&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这种方式确实很麻烦，也不怎么好，没做到所谓的分布式，就是个普通集群。因为这导致你要么消费者每次随机连接一个实例然后拉取数据，要么固定连接那个 queue 所在实例消费数据，前者有数据拉取的开销，后者导致单实例性能瓶颈。&lt;/p&gt;

&lt;p&gt;而且如果那个放 queue 的实例宕机了，会导致接下来其他实例就无法从那个实例拉取，如果你开启了消息持久化，让 RabbitMQ 落地存储消息的话，消息不一定会丢，得等这个实例恢复了，然后才可以继续从这个 queue 拉取数据。&lt;/p&gt;

&lt;p&gt;所以这个事儿就比较尴尬了，这就没有什么所谓的高可用性，这方案主要是提高吞吐量的，就是说让集群中多个节点来服务某个 queue 的读写操作。&lt;/p&gt;

&lt;h4&gt;镜像集群模式（高可用性）&lt;/h4&gt;

&lt;p&gt;这种模式，才是所谓的 RabbitMQ 的高可用模式。跟普通集群模式不一样的是，在镜像集群模式下，你创建的 queue，无论元数据还是 queue 里的消息都会存在于多个实例上，就是说，每个 RabbitMQ 节点都有这个 queue 的一个完整镜像，包含 queue 的全部数据的意思。然后每次你写消息到 queue 的时候，都会自动把消息同步到多个实例的 queue 上。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/doocs/advanced-java/blob/master/images/mq-8.png&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://github.com/doocs/advanced-java/raw/master/images/mq-8.png&quot; alt=&quot;mq-8&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;那么如何开启这个镜像集群模式呢？其实很简单，RabbitMQ 有很好的管理控制台，就是在后台新增一个策略，这个策略是镜像集群模式的策略，指定的时候是可以要求数据同步到所有节点的，也可以要求同步到指定数量的节点，再次创建 queue 的时候，应用这个策略，就会自动将数据同步到其他的节点上去了。&lt;/p&gt;

&lt;p&gt;这样的话，好处在于，你任何一个机器宕机了，没事儿，其它机器（节点）还包含了这个 queue 的完整数据，别的 consumer 都可以到其它节点上去消费数据。坏处在于，第一，这个性能开销也太大了吧，消息需要同步到所有机器上，导致网络带宽压力和消耗很重！第二，这么玩儿，不是分布式的，就没有扩展性可言了，如果某个 queue 负载很重，你加机器，新增的机器也包含了这个 queue 的所有数据，并没有办法线性扩展你的 queue。你想，如果这个 queue 的数据量很大，大到这个机器上的容量无法容纳了，此时该怎么办呢？&lt;/p&gt;

&lt;h3&gt;Kafka 的高可用性&lt;/h3&gt;

&lt;p&gt;Kafka 一个最基本的架构认识：由多个 broker 组成，每个 broker 是一个节点；你创建一个 topic，这个 topic 可以划分为多个 partition，每个 partition 可以存在于不同的 broker 上，每个 partition 就放一部分数据。&lt;/p&gt;

&lt;p&gt;这就是天然的分布式消息队列，就是说一个 topic 的数据，是分散放在多个机器上的，每个机器就放一部分数据。&lt;/p&gt;

&lt;p&gt;实际上 RabbmitMQ 之类的，并不是分布式消息队列，它就是传统的消息队列，只不过提供了一些集群、HA(High Availability, 高可用性) 的机制而已，因为无论怎么玩儿，RabbitMQ 一个 queue 的数据都是放在一个节点里的，镜像集群下，也是每个节点都放这个 queue 的完整数据。&lt;/p&gt;

&lt;p&gt;Kafka 0.8 以前，是没有 HA 机制的，就是任何一个 broker 宕机了，那个 broker 上的 partition 就废了，没法写也没法读，没有什么高可用性可言。&lt;/p&gt;

&lt;p&gt;比如说，我们假设创建了一个 topic，指定其 partition 数量是 3 个，分别在三台机器上。但是，如果第二台机器宕机了，会导致这个 topic 的 1/3 的数据就丢了，因此这个是做不到高可用的。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/doocs/advanced-java/blob/master/images/kafka-before.png&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://github.com/doocs/advanced-java/raw/master/images/kafka-before.png&quot; alt=&quot;kafka-before&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Kafka 0.8 以后，提供了 HA 机制，就是 replica（复制品） 副本机制。每个 partition 的数据都会同步到其它机器上，形成自己的多个 replica 副本。所有 replica 会选举一个 leader 出来，那么生产和消费都跟这个 leader 打交道，然后其他 replica 就是 follower。写的时候，leader 会负责把数据同步到所有 follower 上去，读的时候就直接读 leader 上的数据即可。只能读写 leader？很简单，要是你可以随意读写每个 follower，那么就要 care 数据一致性的问题，系统复杂度太高，很容易出问题。Kafka 会均匀地将一个 partition 的所有 replica 分布在不同的机器上，这样才可以提高容错性。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/doocs/advanced-java/blob/master/images/kafka-after.png&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://github.com/doocs/advanced-java/raw/master/images/kafka-after.png&quot; alt=&quot;kafka-after&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这么搞，就有所谓的高可用性了，因为如果某个 broker 宕机了，没事儿，那个 broker上面的 partition 在其他机器上都有副本的，如果这上面有某个 partition 的 leader，那么此时会从 follower 中重新选举一个新的 leader 出来，大家继续读写那个新的 leader 即可。这就有所谓的高可用性了。&lt;/p&gt;

&lt;p&gt;写数据的时候，生产者就写 leader，然后 leader 将数据落地写本地磁盘，接着其他 follower 自己主动从 leader 来 pull 数据。一旦所有 follower 同步好数据了，就会发送 ack 给 leader，leader 收到所有 follower 的 ack 之后，就会返回写成功的消息给生产者。（当然，这只是其中一种模式，还可以适当调整这个行为）&lt;/p&gt;

&lt;p&gt;消费的时候，只会从 leader 去读，但是只有当一个消息已经被所有 follower 都同步成功返回 ack 的时候，这个消息才会被消费者读到。&lt;/p&gt;

&lt;p&gt;看到这里，相信你大致明白了 Kafka 是如何保证高可用机制的了，对吧？不至于一无所知，现场还能给面试官画画图。要是遇上面试官确实是 Kafka 高手，深挖了问，那你只能说不好意思，太深入的你没研究过。&lt;/p&gt;

</description>
<pubDate>Fri, 18 Jan 2019 06:56:00 +0000</pubDate>
<dc:creator>2货我怕谁</dc:creator>
<og:description>为什么使用消息队列 其实就是问问你消息队列都有哪些使用场景，然后你项目里具体是什么场景，说说你在这个场景里用消息队列是什么？ 面试官问你这个问题，期望的一个回答是说，你们公司有个什么业务场景，这个业务</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jay-wu/p/10287636.html</dc:identifier>
</item>
<item>
<title>运维利器：钉钉机器人脚本告警（Linux Python 篇） - Dy1an</title>
<link>http://www.cnblogs.com/Dy1an/p/10287615.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Dy1an/p/10287615.html</guid>
<description>&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/979767/201807/979767-20180704173144908-703671786.png&quot; alt=&quot;&quot; width=&quot;217&quot; height=&quot;134&quot;/&gt;&lt;/p&gt;

&lt;p&gt;写在前面的话&lt;/p&gt;

&lt;p&gt;在前面的博客中已经具体提到了如何获取对的机器人的 &lt;span&gt;&lt;strong&gt;Token&lt;/strong&gt;&lt;/span&gt; 等操作，不清楚的可以参考之前写的 &lt;a href=&quot;https://www.cnblogs.com/Dy1an/p/9264691.html&quot; target=&quot;_blank&quot;&gt;【运维利器：钉钉机器人脚本告警（Linux Shell 篇）】&lt;/a&gt;这篇博客的前部分。&lt;/p&gt;
&lt;p&gt;本文主要给出的 Python 脚本的实现，我记得网上很多脚本给的好像是 go 语言写的。&lt;/p&gt;
&lt;p&gt;虽然现在 go 超级火，运维 docker 和 k8s 以及性能的原因在自动化运维上可能即将取代 Python。&lt;/p&gt;
&lt;p&gt;但不可忽视，Python 写脚本还是挺不错的，且 Linux 自带 Python，可以省去很多麻烦！&lt;/p&gt;
&lt;p&gt;闲话少说，直接上代码：&lt;/p&gt;



&lt;p&gt;安装依赖&lt;/p&gt;

&lt;p&gt;我用的 CentOS 7，自带的是 Python 2.7， 不清楚的可以使用命令查看：&lt;/p&gt;


&lt;p&gt;其中存在两个问题，一个是自带的 Python 没有 &lt;span&gt;&lt;strong&gt;pip&lt;/strong&gt;&lt;/span&gt;，需要安装，二是没有 &lt;span&gt;&lt;strong&gt;requests&lt;/strong&gt;&lt;/span&gt; 模块，安装方法如下：&lt;/p&gt;
&lt;p&gt;【1】安装 pip：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
curl &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://bootstrap.pypa.io/get-pip.py&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; -o &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;get-pip.py&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
python get&lt;/span&gt;-pip.py
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;【2】安装 requests 模块：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
pip &lt;span&gt;install&lt;/span&gt; requests
&lt;/pre&gt;&lt;/div&gt;



&lt;p&gt;发送脚本&lt;/p&gt;

&lt;p&gt;【1】脚本内容：我的脚本名称（ &lt;strong&gt;&lt;span&gt;SendDingMessage.py&lt;/span&gt;&lt;/strong&gt; ）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;!/usr/bin/python2&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; -*- coding: utf-8 -*-&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; requests
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; json
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; sys
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; os
 
headers &lt;/span&gt;= {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Content-Type&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;application/json;charset=utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}
api_url &lt;/span&gt;= &lt;span&gt;&quot;xxxxxxxxxxxxxxxxxxxxxxx 这里是你的钉钉机器人 Token xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

&lt;span&gt;def&lt;/span&gt;&lt;span&gt; msg(text, subject):
    json_text&lt;/span&gt;=&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;actionCard&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: subject, 
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: text, 
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hideAvatar&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, 
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;btnOrientation&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, 
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;btns&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: [
                {
                    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: subject[:12&lt;span&gt;], 
                    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;actionURL&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;
                }
            ]
        }, 
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;msgtype&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;actionCard&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    }
        
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(requests.post(api_url,json.dumps(json_text),headers=&lt;span&gt;headers).content)

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    text &lt;/span&gt;= sys.argv[1&lt;span&gt;]
    text &lt;/span&gt;= text.replace(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    subject &lt;/span&gt;= sys.argv[2&lt;span&gt;]
    msg(text, subject)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;【2】测试发送： &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
python SendDingMessage.py  &lt;span&gt;'&lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;hahahahah&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;【3】效果图： &lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/979767/201901/979767-20190118144248531-174661540.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;【4】Zabbix 配置告警媒介：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/979767/201901/979767-20190118144347536-1469907810.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;【5】告警效果： &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/979767/201901/979767-20190118145855730-1359183897.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;小结&lt;/p&gt;

&lt;p&gt;最近特别忙，快过年了，之前给自己定了很多小目标还没有实现呢，比如 VUE + DRF 学习，结果中途窜出来了 LayUI，Docker K8S 等等。&lt;/p&gt;
&lt;p&gt;Zabbix 系列也没时间更新，因为个人对于排版要求很严，注定没法高产。&lt;/p&gt;
&lt;p&gt;前段时间学了点 Bootstrap + JQuery，第一件事就是把这个博客园的主题自己重写了，然后现在在做自己的一个个人博客。&lt;/p&gt;
&lt;p&gt;现在线上是以前没学前端时候的版本，前端代码稀烂，正在重构中。感兴趣的可以关注一下。&lt;/p&gt;
&lt;p&gt;最后就是，博客园别忘了点个 &lt;span&gt;&lt;strong&gt;推荐&lt;/strong&gt;&lt;/span&gt; 再走，给点动力也行啊！&lt;/p&gt;
&lt;p&gt;最后的最后，又是右上角 QQ 扫码！&lt;/p&gt;

</description>
<pubDate>Fri, 18 Jan 2019 06:53:00 +0000</pubDate>
<dc:creator>Dy1an</dc:creator>
<og:description>写在前面的话 在前面的博客中已经具体提到了如何获取对的机器人的 Token 等操作，不清楚的可以参考之前写的 【运维利器：钉钉机器人脚本告警（Linux Shell 篇）】这篇博客的前部分。 本文主要</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Dy1an/p/10287615.html</dc:identifier>
</item>
<item>
<title>企业网盘之分片上传组件 - 苏晗夜</title>
<link>http://www.cnblogs.com/shawnyung/p/9716911.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shawnyung/p/9716911.html</guid>
<description>&lt;h2&gt;效果展示&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1211091/201809/1211091-20180927111809719-575178803.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt; 包含技术点&lt;/h2&gt;
&lt;p&gt;1、分片上传。&lt;/p&gt;
&lt;p&gt;2、文件秒传。&lt;/p&gt;
&lt;p&gt;3、文件夹上传&lt;/p&gt;
&lt;p&gt;4、文件续传。&lt;/p&gt;
&lt;p&gt;5、文件拖拽上传。&lt;/p&gt;
&lt;h2&gt;组件目录&lt;/h2&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1211091/201811/1211091-20181105151841724-1544131332.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;实现分析&lt;/h2&gt;
&lt;h3&gt;分片上传&lt;/h3&gt;
&lt;p&gt;通过H5 FileUpload对象可以实现文件上传， mutiple属性可以支持文件多选。拿到文件对象后，调用完整的分片上传流程：计算MD5-添加文件-获取鉴权信息-递归上传分片-上传完成。&lt;/p&gt;
&lt;p&gt;如何切割文件分片？&lt;/p&gt;
&lt;p&gt;方法介绍：blob.slice(); 属于Blob对象的一个方法,而File对象是继承Blob对象的,因此File对象也含有slice方法。&lt;/p&gt;
&lt;p&gt;如何计算进度？&lt;br/&gt;通过文件大小及分片计算算法，算出分片大小和分片数目以后，通过当前上传的分片数目除以总共分片数目得到进度信息。&lt;/p&gt;
&lt;p&gt;如何计算上传速度？&lt;/p&gt;
&lt;p&gt;每上传一个分片，记录分片上传请求的时间，通过分片的大小除以请求时间得到速度信息。&lt;/p&gt;
&lt;p&gt;上传分片的代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  上传分片&lt;/span&gt;
  const uploadPart = (resolve, reject) =&amp;gt;&lt;span&gt; {
    let blob &lt;/span&gt;= file.slice((params.PartNumber - 1) * chunkSize, params.PartNumber *&lt;span&gt; chunkSize);
    let begin &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date().getTime();
    params[&lt;/span&gt;'Body'] =&lt;span&gt; blob;
    s3.uploadPart(params, &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (err, data) {
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (err || item.status !== 'uploading'&lt;span&gt;) {
        reject(err &lt;/span&gt;||&lt;span&gt; item.status);
      } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        item.percentage &lt;/span&gt;= Math.round(params.PartNumber * 100 / frameNum); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 进度&lt;/span&gt;
        let spend = (&lt;span&gt;new&lt;/span&gt; Date().getTime() - begin) / 1000;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 消耗时间&lt;/span&gt;
        item.speed = Math.round(blob.size / spend) * 1.3;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 速度&lt;/span&gt;
        log_content.frameSeq =&lt;span&gt; params.PartNumber;
        l_params.logContent &lt;/span&gt;=&lt;span&gt; JSON.stringify(log_content);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; debugger;&lt;/span&gt;
        log(l_params).then(() =&amp;gt;&lt;span&gt; {
          &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (params.PartNumber &amp;lt;&lt;span&gt; frameNum) {
            params.PartNumber &lt;/span&gt;+= 1&lt;span&gt;;
            uploadPart(resolve, reject);
          } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            item.status &lt;/span&gt;= 'success'&lt;span&gt;;
            resolve();
          }
        }).&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;((err) =&amp;gt;&lt;span&gt; {
          reject(err);
        });
      }
    });
  };&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;文件秒传&lt;/h3&gt;
&lt;p&gt;秒传是将上传的文件与服务器中的文件进行比对，若云端存在相同文件，则将直接把文件秒速保存到你的网盘。调用“添加文件”接口，若服务端返回文件ID，表明云端已存储相同文件，新的文件会存储为源文件的一份索引。&lt;/p&gt;
&lt;h3&gt;文件夹上传&lt;/h3&gt;
&lt;p&gt;chrome的私有属性webkitdiretory可以支持文件夹上传。分片上传流程需要增加递归创建文件夹：递归创建文件夹-计算MD5-添加文件-获取鉴权信息-递归上传分片-上传完成。&lt;/p&gt;
&lt;p&gt;判断文件为文件夹上传？&lt;/p&gt;
&lt;p&gt;file.webkitRelativePath属性。&lt;/p&gt;
&lt;p&gt;判断文件是否一次上传？&lt;/p&gt;
&lt;p&gt;这里要处理的场景是，一个文件夹上传两次，第二次需要对文件夹重命名。如何判断一批文件是一次上传的，还是同名文件夹上传多次。可以通过上传框change的时候，构造文件对象增加时间戳属性，同一批文件的时间戳相同。&lt;/p&gt;
&lt;p&gt;HTML：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;ref&lt;/span&gt;&lt;span&gt;=&quot;folder&quot;&lt;/span&gt;&lt;span&gt; @change&lt;/span&gt;&lt;span&gt;='handleChange' &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;folderInput&quot;&lt;/span&gt;&lt;span&gt; multiple&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt; webkitdirectory&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt; accept&lt;/span&gt;&lt;span&gt;=&quot;*/*&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;file&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;递归创建文件夹可参考Node算法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
const mkdirs = (dirname, callback, errback) =&amp;gt;&lt;span&gt; {
  fs.stat(dirname, (err, stats) &lt;/span&gt;=&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (err) {
      mkdirs(path.dirname(dirname), () &lt;/span&gt;=&amp;gt;&lt;span&gt; {
        fs.mkdir(dirname, callback)
      }, errback)
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (stats.isDirectory()) {
          callback()
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
          errback()
        }
    }
  })
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;文件续传&lt;/h3&gt;
&lt;p&gt;大文件在上传过程中进行中断网络或刷新浏览器等操作，重新登录可断点上传。后台记录文件上传的分片信息，当上传过程被终止以后，重新登录查询当前用户未上传成功的续传列表。存储那边会保留已上传的分片，断点上传从未上传的分片开始，可大大减少大文件上传终止需重新上传的时间。&lt;/p&gt;
&lt;h3&gt;文件拖拽上传&lt;/h3&gt;
&lt;p&gt;H5新特性可实现文件拖拽上传。其中，与拖拽文件相关的事件有&lt;code&gt;dragover(文件拖拽在悬浮)&lt;/code&gt;、&lt;code&gt;dragleave(文件拖拽离开)&lt;/code&gt;、&lt;code&gt;drop(文件拖拽放下)。在事件对象中，一个&lt;/code&gt;e.dataTransfer这样的属性，它是一个&lt;code&gt;DataTransfer&lt;/code&gt;类型的数据，有如下的属性&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;属性&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;类型&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;说明&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;files&lt;/td&gt;
&lt;td&gt;FileList&lt;/td&gt;
&lt;td&gt;拖拽的文件列表&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;items&lt;/td&gt;
&lt;td&gt;DataTransferItemList&lt;/td&gt;
&lt;td&gt;拖拽的数据(有可能是字符串)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;types&lt;/td&gt;
&lt;td&gt;Array&lt;/td&gt;
&lt;td&gt;拖拽的数据类型 该属性在Safari下比较混乱&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;完整的组件代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&amp;lt;template&amp;gt;
  &amp;lt;&lt;span&gt;div
    class&lt;/span&gt;=&quot;uploadMask&quot;&lt;span&gt;
    style&lt;/span&gt;=&quot;position: fixed&quot;&lt;span&gt;
    :class&lt;/span&gt;=&quot;&lt;span&gt;{
      'is-dragover': dragover
    }&lt;/span&gt;&quot;&lt;span&gt;
    v&lt;/span&gt;-show=&quot;dragover&quot;&lt;span&gt;
    @drop.prevent&lt;/span&gt;=&quot;onDrop&quot;&lt;span&gt;
    @dragover.prevent&lt;/span&gt;=&quot;onDragover&quot;&lt;span&gt;
    @dragleave.prevent&lt;/span&gt;=&quot;dragover = false&quot;
  &amp;gt;
    &amp;lt;slot&amp;gt;&amp;lt;/slot&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;script&amp;gt;&lt;span&gt;
  export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; {
    name: &lt;/span&gt;'ElUploadDrag'&lt;span&gt;,
    props: {
      disabled: Boolean
    },
    data() {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
        dragover: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
      };
    },
    methods: {
      onDragover() {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.disabled) {
          &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.dragover = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }
      },
      &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;eslint-disable&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
      onDrop(e) {
        let _this &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.disabled) {
          let event &lt;/span&gt;= e ||&lt;span&gt; window.event;
          &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.dragover = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
          let df &lt;/span&gt;= event.dataTransfer;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 拖曳操作的过程中，我们可以用过dataTransfer对象来传输数据，以便在拖曳操作结束的时候对数据进行其他的操作;&lt;/span&gt;
          let len =&lt;span&gt; df.files.length;
          let dealFileCnt &lt;/span&gt;= 0; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 读取文件是个异步的过程，需要记录处理了多少个文件了&lt;/span&gt;
          let files =&lt;span&gt; [];

          &lt;/span&gt;&lt;span&gt;function&lt;/span&gt; callback (files) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 抛出文件数组&lt;/span&gt;
            _this.$emit('file'&lt;span&gt;, files);
          }

          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 检测是否已经把所有的文件都遍历过了&lt;/span&gt;
          &lt;span&gt;function&lt;/span&gt;&lt;span&gt; checkDropFinish () {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ( dealFileCnt === len - 1&lt;span&gt; ) {
              console.log(&lt;/span&gt;'ie'&lt;span&gt;);
              callback(files); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  所有的文件都遍历过了emit 出去&lt;/span&gt;
&lt;span&gt;            }
            dealFileCnt&lt;/span&gt;++&lt;span&gt;;
          }

          &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (df.items) {  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 有dataTransfer项目列表时&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt; (let i = 0; i &amp;lt; len; i++&lt;span&gt;) {
              let entry &lt;/span&gt;= df.items[i].webkitGetAsEntry(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 读取拖拽元素信息&lt;/span&gt;
              &lt;span&gt;if&lt;/span&gt; (entry.isFile &amp;amp;&amp;amp; !entry.isDirectory) {  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; isDirectory是否是文件夹&lt;/span&gt;
&lt;span&gt;                files.push(df.files[i]);
              }
            }
            callback(files);
          } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; {  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ie浏览器&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt; (let i = 0; i &amp;lt; len; i++&lt;span&gt;) {
              let dropFile &lt;/span&gt;=&lt;span&gt; df.files[i];
              &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (dropFile.type) {
                files.push(dropFile);
                checkDropFinish()
              } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; fileReader = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FileReader();
                  fileReader.readAsDataURL(dropFile.slice(&lt;/span&gt;0, 3&lt;span&gt;));

                  fileReader.addEventListener(&lt;/span&gt;'load', &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (e) {
                    console.log(e, &lt;/span&gt;'load'&lt;span&gt;);
                    files.push(dropFile);
                    checkDropFinish();
                  }, &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);

                  fileReader.addEventListener(&lt;/span&gt;'error', &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (e) {
                    console.log(e, &lt;/span&gt;'error，不可以上传文件夹'&lt;span&gt;);
                    checkDropFinish();
                  }, &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (e) {
                  console.log(e, &lt;/span&gt;'catch error，不可以上传文件夹'&lt;span&gt;);
                  checkDropFinish();
                }
              }
            }
          }
        }
      }
    },
    mounted() {
      let app &lt;/span&gt;= document.getElementsByClassName('app')[0&lt;span&gt;];
      app.ondragstart &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt; (e) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 拖拽开始&lt;/span&gt;
        e.preventDefault();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;取消默认的链接元素和图片元素拖拽会触发拖拽上传&lt;/span&gt;
&lt;span&gt;      };
      app.addEventListener(&lt;/span&gt;'dragover', (e) =&amp;gt; {  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 拖拽到另一个容器是促发&lt;/span&gt;
&lt;span&gt;        e.preventDefault();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.onDragover();
      });
    }
  };
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt; 参照文章&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000013298317&quot; target=&quot;_blank&quot;&gt;https://segmentfault.com/a/1190000013298317&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 18 Jan 2019 06:45:00 +0000</pubDate>
<dc:creator>苏晗夜</dc:creator>
<og:description>效果展示 包含技术点 1、分片上传。 2、文件秒传。 3、文件夹上传 4、文件续传。 5、文件拖拽上传。 组件目录 实现分析 分片上传 通过H5 FileUpload对象可以实现文件上传， </og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shawnyung/p/9716911.html</dc:identifier>
</item>
<item>
<title>asp.net core 系列 11 配置configuration (下) - 花阴偷移</title>
<link>http://www.cnblogs.com/MrHSR/p/10285906.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/MrHSR/p/10285906.html</guid>
<description>&lt;h3&gt;四. 文件配置提供程序AddIniFile、 AddXmlFile、AddJsonFile&lt;/h3&gt;
&lt;p&gt;　　FileConfigurationProvider 是从文件系统加载配置的基类。 以下配置提供程序专用于特定文件类型：&lt;/p&gt;
&lt;p&gt;　　　　(1) INI 配置提供程序 IniConfigurationProvider: FileConfigurationProvider&lt;/p&gt;
&lt;p&gt;　　　　(2) JSON 配置提供程序 JsonConfigurationProvider: FileConfigurationProvider&lt;/p&gt;
&lt;p&gt;　　　　(3) XML 配置提供程序 XmlConfigurationProvider: FileConfigurationProvider&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;　　4.1  INI 配置提供程序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　IniConfigurationProvider 在运行时从 INI 文件键值对加载配置,若要激活 INI 文件配置，请在 ConfigurationBuilder 的实例上调用 AddIniFile 扩展方法。冒号可用作 INI 文件配置中的节分隔符。下面是一个ini配置文件通用示例:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    [section0]
    key0&lt;/span&gt;=&lt;span&gt;value
    key1&lt;/span&gt;=&lt;span&gt;value

    [section1]
    subsection:key&lt;/span&gt;=&lt;span&gt;value

    [section2:subsection0]
    key&lt;/span&gt;=&lt;span&gt;value

    [section2:subsection1]
    key&lt;/span&gt;=value
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;下面是获取各节点中的value值，需要加载的键。&lt;/span&gt;
&lt;span&gt;    section0:key0
    section0:key1
    section1:subsection:key
    section2:subsection0:key
    section2:subsection1:key&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　下面示例是使用config.AddIniFile方法加载一个config.ini文件，该方法重载允许指定:(1) optional文件是否可选,（2）reloadOnChange如果文件更改，是否重载配置。IFileProvider只读该文件。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    config.SetBasePath(Directory.GetCurrentDirectory());
    config.AddIniFile(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;config.ini&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, optional: &lt;span&gt;true&lt;/span&gt;, reloadOnChange: &lt;span&gt;true&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;OtherPages/Page1页面访问，val 值value&lt;/span&gt;
     &lt;span&gt;string&lt;/span&gt; val=  Configuration.GetSection(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;section0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).GetSection(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;key0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).Value;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/151560/201901/151560-20190118104120540-1569819350.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;4.2 JSON 配置提供程序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　JsonConfigurationProvider 在运行时期间从 JSON 文件键值对加载配置。若要激活 JSON 文件配置，请在 ConfigurationBuilder 的实例上调用 AddJsonFile 扩展方法。下面是使用config. AddJsonFile方法加载一个config.json文件,具体格式可参考appsettings.json&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;      config.SetBasePath(Directory.GetCurrentDirectory());
      config.AddJsonFile(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;config.json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, optional: &lt;span&gt;true&lt;/span&gt;, reloadOnChange: &lt;span&gt;true&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　效果就不再具体演示，重点讲下注意事项：&lt;span&gt;使用 CreateDefaultBuilder 初始化新的 WebHostBuilder 时，会自动调用 AddJsonFile 两次。 调用该方法来从以下文件加载配置：(1)appsettings.json – 首先读取此文件。(2) appsettings.{Environment}.json。也就是说调用二次AddJsonFile后，AddJsonFile才会调用上面显示指定的config.json.&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　&lt;strong&gt;　4.3 XML 配置提供程序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　XmlConfigurationProvider 在运行时从 XML 文件键值对加载配置。若要激活 XML 文件配置，请在 ConfigurationBuilder 的实例上调用 AddXmlFile 扩展方法。XML文件创建配置键值对时，将忽略配置文件的根节点。 不要在文件中指定文档类型定义 (DTD) 或命名空间。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    config.SetBasePath(Directory.GetCurrentDirectory());
    config.AddXmlFile(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;config.xml&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, optional: &lt;span&gt;true&lt;/span&gt;, reloadOnChange: &lt;span&gt;true&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　(1)下面是一个xml配置文件通用示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
　　　　&amp;lt;?xml version=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1.0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; encoding=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;?&amp;gt;
　　　　&amp;lt;configuration&amp;gt;
  　　　　&amp;lt;section0&amp;gt;
   　　　　 &amp;lt;key0&amp;gt;value&amp;lt;/key0&amp;gt;
   　　　　 &amp;lt;key1&amp;gt;value&amp;lt;/key1&amp;gt;
  　　　　&amp;lt;/section0&amp;gt;
 　　 　　&amp;lt;section1&amp;gt;
   　　　　 &amp;lt;key0&amp;gt;value&amp;lt;/key0&amp;gt;
    　　　　&amp;lt;key1&amp;gt;value&amp;lt;/key1&amp;gt;
  　　　　&amp;lt;/section1&amp;gt;
　　　　&amp;lt;/configuration&amp;gt;&lt;br/&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;下面是获取各节点中的value值，需要加载的键。&lt;/span&gt;
&lt;span&gt;    section0:key0
    section0:key1
    section1:key0
    section1:key1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　(2) 如果使用 name 属性来区分元素，则使用相同元素名称的重复元素可以正常工作：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
　　　　&amp;lt;?xml version=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1.0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; encoding=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;?&amp;gt;
　　　　&amp;lt;configuration&amp;gt;
 　　　　 &amp;lt;section name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;section0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
   　　　　 &amp;lt;key name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;key0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;value&amp;lt;/key&amp;gt;
   　　　　 &amp;lt;key name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;key1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;value&amp;lt;/key&amp;gt;
  　　　　&amp;lt;/section&amp;gt;
  　　　　&amp;lt;section name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;section1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    　　　　&amp;lt;key name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;key0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;value&amp;lt;/key&amp;gt;
    　　　　&amp;lt;key name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;key1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;value&amp;lt;/key&amp;gt;
 　　　　 &amp;lt;/section&amp;gt;
　　　　&amp;lt;/configuration&amp;gt;

    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;下面是获取各节点中的value值，需要加载的键。&lt;/span&gt;
&lt;span&gt;    section:section0:key:key0
    section:section0:key:key1
    section:section1:key:key0
    section:section1:key:key1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　(3) 属性可用于提供值&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &amp;lt;?xml version=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1.0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; encoding=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;?&amp;gt;
    &amp;lt;configuration&amp;gt;
      &amp;lt;key attribute=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
      &amp;lt;section&amp;gt;
        &amp;lt;key attribute=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
      &amp;lt;/section&amp;gt;
    &amp;lt;/configuration&amp;gt;

    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;下面是获取各属性中的value值，需要加载的键。&lt;/span&gt;
&lt;span&gt;    key:attribute
    section:key:attribute&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;五. Key-per-file 配置提供程序 AddKeyPerFile&lt;/h3&gt;
&lt;p&gt;　　KeyPerFileConfigurationProvider 使用目录的文件作为配置键值对。 该键是文件名。 该值包含文件的内容。 Key-per-file 配置提供程序用于 Docker 托管方案。若要激活 Key-per-file 配置，请在 ConfigurationBuilder 的实例上调用 AddKeyPerFile 扩展方法。 文件的 directoryPath 必须是绝对路径。&lt;/p&gt;
&lt;p&gt;　　下面示例是使用config.AddKeyPerFile方法加载一个目录文件，在使用Docker 托管时具体参考官方文档。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;       config.SetBasePath(Directory.GetCurrentDirectory());
       &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; path = Path.Combine(Directory.GetCurrentDirectory(), &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;path/to/files&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        config.AddKeyPerFile(directoryPath: path, optional: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt; 六. 内存配置提供程序AddInMemoryCollection&lt;/h3&gt;
&lt;p&gt; 　　MemoryConfigurationProvider 使用内存中集合作为配置键值对。若要激活内存中集合配置，请在 ConfigurationBuilder 的实例上调用 AddInMemoryCollection 扩展方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
       &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 构建内存对象的键值对
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt; _dict =
         &lt;span&gt;new&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;
        {
            {&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MemoryCollectionKey1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;},
            {&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MemoryCollectionKey2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;}
        };

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IWebHostBuilder CreateWebHostBuilder(&lt;span&gt;string&lt;/span&gt;[] args) =&amp;gt;&lt;span&gt;
   WebHost.CreateDefaultBuilder(args)
       .ConfigureAppConfiguration((hostingContext, config) &lt;/span&gt;=&amp;gt;&lt;span&gt;
       {
           config.AddInMemoryCollection(_dict);
       })
       .UseStartup&lt;/span&gt;&amp;lt;Startup&amp;gt;();
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
 　　 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;OtherPages/Page1页面访问，val 值value&lt;/span&gt;
  　　&lt;span&gt;string&lt;/span&gt; val=Configuration.GetSection(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MemoryCollectionKey1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).Value
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/151560/201901/151560-20190118111130902-1420559567.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;七. 读取GetValue、GetSection、GetChildren 和 Exists&lt;/h3&gt;
&lt;p&gt;　&lt;strong&gt;　7.1 GetValue&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 　　　　ConfigurationBinder.GetValue&amp;lt;T&amp;gt; 从具有指定键的配置中提取一个值，并将其转换为指定类型。 如果未找到该键，则重载允许你提供默认值。以下示例使用键 NumberKey 从配置中提取字符串值，键入该值作为 int，并将值存储在变量 intValue 中。 如果在配置键中找不到 NumberKey，则 intValue 会接收 99 的默认值。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;var&lt;/span&gt; intValue = config.GetValue&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;NumberKey&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;99&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　&lt;strong&gt;　7.2 GetSection&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　IConfiguration.GetSection 使用指定的子节键提取配置子节。GetSection 永远不会返回 null。 如果找不到匹配的节，则返回空 IConfigurationSection。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; { 
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;section0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;key0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;key1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
  },
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;section1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;key0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;key1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
  },
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;section2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;subsection0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; : {
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;key0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;key1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    },
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;subsection1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; : {
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;key0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;key1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    }
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回仅包含 section1 中键值对的 IConfigurationSection 对象&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; configSection = _config.GetSection(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;section1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取 section2:subsection0 中键的值&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; configSection = _config.GetSection(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;section2:subsection0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　&lt;strong&gt;　7.3 GetChildren&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;在上面的json结构中，获取section2下面的子节点&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; configSection = _config.GetSection(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;section2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; children = configSection.GetChildren();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;strong&gt;7.4 Exists&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　//&lt;/span&gt;&lt;span&gt;在上面的json结构中，确定配置节是否存在, 为false，是因为配置数据中没有 section2:subsection2 节点&lt;/span&gt;
　　&lt;span&gt;var&lt;/span&gt; sectionExists = _config.GetSection(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;section2:subsection2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).Exists();
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;八. 绑定到类&lt;/h3&gt;
&lt;p&gt; 　　使用GetSection方法调用 Bind 可以构造 POCO 对象。POCO就是简单CLR对象（Plain Old CLR Object），这种类不继承于任何对象（或者说直接继承于Object），示例应用包含 Starship 模型 (Models/Starship.cs)。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;     config.SetBasePath(Directory.GetCurrentDirectory());&lt;/span&gt;
     config.AddJsonFile(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;starship.json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;false&lt;/span&gt;,&lt;span&gt;true&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　Starship实体对应JSON的 &lt;code&gt;starship&lt;/code&gt; 节点&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　{
  　　&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;starship&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
    　　&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;USS Enterprise&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
   　　 &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;registry&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;NCC-1701&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
   　　 &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Constitution&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
   　　 &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;length&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;304.8&lt;/span&gt;&lt;span&gt;,
   　　 &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;commissioned&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;false&lt;/span&gt;&lt;span&gt;
  　　},
  　　&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;trademark&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Paramount Pictures Corp. http://www.paramount.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
　　}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; OtherPages/Page1页面绑定starship 节点到Starship实体中&lt;/span&gt;
       &lt;span&gt;var&lt;/span&gt; starship = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Models.Starship();
       Configuration.GetSection(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;starship&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).Bind(starship);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/151560/201901/151560-20190118114834522-643474276.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　总结:&lt;/p&gt;
&lt;p&gt;　　　　Configuration配置的其它知识点如：将数组绑定至类、自定义配置提供程序、在启动期间访问配置、在 Razor Pages 页或 MVC 视图中访问配置等等, 请参考官方文档。&lt;/p&gt;
&lt;p&gt;　　　　在Configuration配置的上下二篇中，讲到了Configuration对不同配置来源的加载和读取方法，Microsoft.Extensions.Configuration.IConfiguration中全是以Get开头的只读方法，并没有涉及到对配置来源（如json或xml文件）的增删改操作。像配置的xml文件，是否需要引入System.Xml.Linq来操作xml文件的增删改操呢？带着这个疑问在以后章节再了解。&lt;/p&gt;

&lt;p&gt;参考文献&lt;/p&gt;
&lt;p&gt;官方资料:&lt;a href=&quot;https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/configuration/?view=aspnetcore-2.2#file-configuration-provider&quot; target=&quot;_blank&quot;&gt;asp.net core 配置&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 18 Jan 2019 06:06:00 +0000</pubDate>
<dc:creator>花阴偷移</dc:creator>
<og:description>四. 文件配置提供程序AddIniFile、 AddXmlFile、AddJsonFile FileConfigurationProvider 是从文件系统加载配置的基类。 以下配置提供程序专用于特定</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/MrHSR/p/10285906.html</dc:identifier>
</item>
</channel>
</rss>