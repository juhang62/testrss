<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>如何基于匹配预设句式，动态提取用户评价标签 - 马蜂窝技术</title>
<link>http://www.cnblogs.com/mfwtech/p/10517106.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mfwtech/p/10517106.html</guid>
<description>&lt;p&gt;网络经济的发展使我们的消费渠道早已不止于实体场景。来自于用户的线上评价，成为如今影响我们消费行为决策的重要因素。&lt;/p&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt;背景&lt;/h2&gt;
&lt;p&gt;在网上购物时，即使你已经浏览了商家对于商品的描述，你还是不会立即决定购买它，因为你不确定这些描述是否准确。这时你会寻找其他购买过此商品的用户评论，这些评论可能才会最终说服你。&lt;/p&gt;
&lt;p&gt;购买旅行类产品也是一样。每天都有大量用户在马蜂窝平台用“评论”的方式，记录和评价他们在旅行中的感受和体验。而基于对评论内容深度挖掘产生的标签，则用一种更为简洁、直观的方式汇总评论信息中的重要内容，展示给更多的用户作为参考依据。&lt;/p&gt;
&lt;p&gt;因此，如何在保证标签内容准确性的同时，体现出更符合用户语言习惯、让用户更容易理解的标签含义，对于提升用户在马蜂窝平台的体验，做出更符合自身需求的旅行决策，以及提升平台转化率、更好地监管商家服务品质等方面，都有很大价值。&lt;/p&gt;
&lt;p&gt;从评价中提取标签的方式有很多，但在实际应用中存在一些问题，比如：&lt;/p&gt;
&lt;h4&gt;1. 预设标签&lt;/h4&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;做法&lt;/strong&gt;：预先定义好一些固定标签，由用户在发表点评时自主选择。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;不足&lt;/strong&gt;：固定标签数量受限，无法覆盖用户全部需求，并且标签和用户内容可能不匹配。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;2. 句法分析&lt;/h4&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;做法&lt;/strong&gt;：对用户发布的点评内容进行解构，提取主题词和描述词组合后作为标签。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;不足&lt;/strong&gt;：在评价量非常大的时候，这种方法会产生大量标签，对计算性能要求高，并且维护不便。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;3.多层级标签定义&lt;/h4&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;做法&lt;/strong&gt;：预先定义标签大类，在逐级细分，最后产生具体标签。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;不足&lt;/strong&gt;：产生大量维护工作。并且定义的层级灵活性欠佳，而且匹配的标签是关键词加指标词，不能很好地表达用户的言语习惯。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;为了解决以上问题，马蜂窝推荐和搜索研发团队提出了一种通过匹配预设句式的模式，灵活、动态提取用户评论标签的方式，将每个预设句式归宿到固定标签分类，在分类显示中动态地采用最大数标签作为整个分类标签的显示方式，极大减少了固定标签的数量，并且每个句式是任意的多个词组联合组成，使最终提取的标签内容在更符合用户语言习惯的同时，更好地体现了不同评论内容标签的个性化和差异化。&lt;/p&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt;基于匹配预设句式模板动态提取用户评价标签 &lt;/h2&gt;
&lt;p&gt;首先和大家解释几个关键的概念。&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：标签可以理解成对一个给定信息进行的具体描述。比如“离望京地铁站近”、“步行到大望路地铁站 1 分钟”等；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;句式&lt;/strong&gt;：这里，我们可以先简单理解成是对同一类型标签的集合，可以理解成“评价方式”，比如上句关于标签的举例，都是对“离地铁站近”的评价；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;标签类别&lt;/strong&gt;：同样，我们先简单理解成是对同一类句式，也就是一类“评价”的集合，比如上述句式包含在“交通方便”这类评价里。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;三者关系可以描述为，一个标签类别包含了 m 个句式；一个句式会产生 n 个标签，所以一个标签类别最多会对应 m*n 个标签。&lt;/p&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;h3&gt;标签系统总体结构&lt;/h3&gt;
&lt;p&gt;系统主要有两部分内容：标签句式的定义和自动化的句式生成。今天主要介绍第一部分&lt;strong&gt;关于如何定义句式和产生标签&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/bcc9b3c296d654414931ac640ced2234f56.jpg&quot; alt=&quot;&quot; width=&quot;807&quot; height=&quot;369&quot; data-cke-saved-src=&quot;https://oscimg.oschina.net/oscnet/bcc9b3c296d654414931ac640ced2234f56.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;图1 - 标签系统结构&lt;/strong&gt;&lt;/p&gt;

&lt;h3&gt; &lt;/h3&gt;
&lt;h3&gt;具体做法和实施步骤&lt;/h3&gt;
&lt;h4&gt;一、建立句式库&lt;/h4&gt;
&lt;p&gt;顾名思义，句式库是对所有预设句式的集合。接下来我们会具体讲解如何定义句式和产生标签。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/8538b5c1d47b9d7fcc88b7689ddf320ba33.jpg&quot; alt=&quot;&quot; width=&quot;866&quot; height=&quot;349&quot; data-cke-saved-src=&quot;https://oscimg.oschina.net/oscnet/8538b5c1d47b9d7fcc88b7689ddf320ba33.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;图2 - 句式库示意&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. 建立词库 &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;词库是由词组以及其包含的词语组成的。每个词组和词语分别具有唯一标识；词组是&lt;strong&gt;对其包含的词语的概括和汇总&lt;/strong&gt;；词语为表示该词组的近义词、俗语、舶来词、英语、缩写等。例如：&lt;/p&gt;
&lt;p&gt;• &lt;strong&gt;词组&lt;/strong&gt;：表示“班车”的名称集合&lt;/p&gt;
&lt;p&gt;• &lt;strong&gt;词语&lt;/strong&gt;：班车，摆渡车，接泊车，shuttlebus 等是词组中的词语&lt;/p&gt;
&lt;p&gt;词组也可以&lt;strong&gt;表示一类描述信息&lt;/strong&gt;，比如：&lt;/p&gt;
&lt;p&gt;  &lt;img src=&quot;https://oscimg.oschina.net/oscnet/db86997d2884be537dc3b92396414f16bbf.jpg&quot; alt=&quot;&quot; width=&quot;866&quot; height=&quot;380&quot; data-cke-saved-src=&quot;https://oscimg.oschina.net/oscnet/db86997d2884be537dc3b92396414f16bbf.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;图3 - 词库示意&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;  &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/0640ba688ef59d4e7d4bd79727f7f576972.jpg&quot; alt=&quot;&quot; width=&quot;866&quot; height=&quot;281&quot; data-cke-saved-src=&quot;https://oscimg.oschina.net/oscnet/0640ba688ef59d4e7d4bd79727f7f576972.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;图4 - 词组示意&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;另外还会建立&lt;strong&gt;排除词库&lt;/strong&gt;。排除词库中，以后不对这些词进行处理，排除词库大部分是无具体意义词，比如“我们”，“他们”之类的代词、“呀”“耶”“哦”之类的语气助词，“之后”“然后”“所以”这样没有转折意义的连词等等。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2．对句式分类，得到标签类别 &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;标签类别为用户点评信息的概括和归类，将同一类型的句式归类为一个标签类别，每个标签类别代表了一类相近评价内容。&lt;/p&gt;
&lt;p&gt;比如“服务好”类，代表所有描述服务好的评价信息，该标签类别由多个句式组成，例如“{老板}{热情}”，“{前台}{专业}”，表示的都是关于酒店和民宿服务这一类评价的句式，则这些句式产生的标签都会归属到相同的类型上，但不同业务的 UGC 产生的具体标签会各具特色。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/746d10ea911c457edcf7e16feaa20532330.jpg&quot; alt=&quot;&quot; width=&quot;1&quot; height=&quot;1&quot; data-cke-saved-src=&quot;https://oscimg.oschina.net/oscnet/746d10ea911c457edcf7e16feaa20532330.jpg&quot;/&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/d7c5c407b509c2cbc222747cffeba59e499.jpg&quot; alt=&quot;&quot; width=&quot;866&quot; height=&quot;485&quot; data-cke-saved-src=&quot;https://oscimg.oschina.net/oscnet/d7c5c407b509c2cbc222747cffeba59e499.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;图5 - 句式分类示意&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.基于词组进行句式组合&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;每个句式表示一种逻辑语义，通过词组之间的组合定义句式，表达不同内容，并具有唯一标识。&lt;/p&gt;
&lt;p&gt;每个句式的词组中用具体的词语组合得到的结果定义为其产生的标签，如“距离牡丹园地铁站近”“离牡丹园地铁站很近”等均为{离}{地铁站}{近}句式产生的标签。&lt;/p&gt;
&lt;p&gt;参与句式组合的词组分为四类，分别是&lt;strong&gt;普通词组、独立词组、POI、固定文字&lt;/strong&gt;。构建句式时，并列关系的词组之间用 OR 表示，可减少句式的定义数量。例如：&lt;/p&gt;
&lt;ul readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;句式&lt;/strong&gt;：{提供}[{地铁站}OR{码头}OR{公交站}OR{火车站}OR{机场}OR{市中心}]{班车}&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;普通词组&lt;/strong&gt;：“提供”、“班车”&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;独立词组&lt;/strong&gt;：当匹配到该句式的独立性词组时，均需要单独显示，突出标签的特色性。即“地铁站”“码头”等。&lt;/p&gt;
&lt;p&gt;当匹配到“提供-地铁站-班车”以及“提供-码头-班车”时，其表示的是不同含义或者特别含义，虽然都在提供班车同一个标签分类下，但需要单独显示。同理匹配到POI（感兴趣点，为目的地下的一些景点、地点等,如故宫、泰山、火车站、公交站、医院等）中的任意一条记录，则该标签均需要单独显示。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;&lt;strong&gt;二．句式匹配，生成标签&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;1. 生成标签&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从 UGC 内容中提取一条评价文本，按照常用标点符号加用户常用符号为拆分依据，得到若干子句。&lt;img src=&quot;https://oscimg.oschina.net/oscnet/29afb3b0e66b154722eb74f0645a2af021c.jpg&quot; alt=&quot;&quot; width=&quot;1&quot; height=&quot;1&quot; data-cke-saved-src=&quot;https://oscimg.oschina.net/oscnet/29afb3b0e66b154722eb74f0645a2af021c.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/d0c4d2b6a4c2a92367af40a5b94a05b8982.jpg&quot; alt=&quot;&quot; width=&quot;866&quot; height=&quot;435&quot; data-cke-saved-src=&quot;https://oscimg.oschina.net/oscnet/d0c4d2b6a4c2a92367af40a5b94a05b8982.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;图6 - UGC 评价原文&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1). 依次匹配 &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;标签类别库中的每个句式从第一个词组开始，用词组中的每个词语按长度排序后依次与子句进行匹配。&lt;/p&gt;
&lt;p&gt;如果某一个句式中的词语与子句中的相匹配，则记录该词语及这个词语在子句中的位置，之后按句式的词组顺序，继续匹配下一个词组中的词语，且匹配的开始位置是上次匹配词语的结束位置的后一位，继续逐个匹配词组中的词语信息，依此类推，不断循环这个过程，直到这个句式的每个词组中的一个词语匹配成功，则记录的每个词组中的匹配词语组合就是这个句式匹配的标签。&lt;/p&gt;
&lt;p&gt;比如句式{服务}{好}，第一个词语 {服务}匹配到的词语是词组中的“酒店服务”，第二个词组{好}匹配到的词语是“不错”，则生成标签“酒店服务不错”。在另外一个子句中可能匹配到的标签是“酒店服务好”。虽然他们表现形式为不同的标签，但都是由一个句式产生的同一类型的标签。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2). 顺序匹配 &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;比如“机场有班车去酒店”，和“酒店有班车去机场”虽然包含的汉字完全一样，但表达的却是不同含义。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3). 词距阈值&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在匹配的过程中，如果相邻两个词组距离大于一定的阈值，则认为不匹配。&lt;/p&gt;
&lt;p&gt;例如句式是“{房间}{大}”，评价子句是“酒店房间里有一幅画着蓝天和大海的油画”。如果没有词距的判断，则该评价子句将匹配到“{房间}{大}”的参考句式，但是该评价子句的意思与“房间大”这一标签表达的意思明显不同。假设将第二预定阈值设置为三个字的词距，评价子句中“房间”与“大”之间的词距超过了三个字，就可以判断参考句式与评价子句不相匹配，避免了错误匹配。&lt;/p&gt;
&lt;p&gt;由于句式中的词语之间可能有一定的位置相关性，通过判断匹配词之间的距离是否符合阈值，剔除那些子句中成功匹配到的词语但是并不表示符合句式含义的内容。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4).一“否”即否&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当一个句式匹配到一个标签时，则判断该句子和句式是否存在否定关系，如果有则认为不匹配。比如饭菜不好吃，则匹配不到{包含饭菜的词组}{包含好吃的词组}这样的句式上。&lt;/p&gt;
&lt;p&gt;正确匹配之后，记录这个子句和标签的对应关系，并找到该句式在标签类别库中对应的标签类别号，建立被匹配的子句与所属的标签类别之间的关系。如果子句没有成功匹配到对应的句式，则保存到未匹配的子句存储中，之后用来继续挖掘可用标签信息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关于匹配方式这里，有一些经验和大家分享：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于&lt;strong&gt;容易混淆&lt;/strong&gt;的词语，应首先建立好一个混淆词语库，比如“好”这个词语，对应的混淆库的词语有“好像”，“好似”等等。在匹配到一个词语时发现它是易混淆词，则查看该词语对应的混淆词是否在这个词语的位置上，如果成立则认为不匹配，比如饭菜好像是之前的。则匹配不到{包含饭菜的词组}{包含好吃的词组}这样的句式上。&lt;/p&gt;
&lt;p&gt;对于一些&lt;strong&gt;繁体字&lt;/strong&gt;的点评先转成简体汉字，之后进行匹配。&lt;/p&gt;
&lt;p&gt;之前，我们对一些其他匹配方式也进行了调研。比如子句先分词，之后用每个词去发现句式中的词语是否存在，这样的效率是比较高，因为用哈希方式查找。&lt;/p&gt;
&lt;p&gt;但这样要依赖分词的准确性，也无法满足用户个性化的需求，尤其在评价语句中，有大量的不符合语法的，口语化的表达和网络词语使用，所以分词很难做到非常准确，最后得到的标签匹配效果也不理想。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/df08f7cd440b5d089596b154c75f00c010a.jpg&quot; alt=&quot;&quot; width=&quot;866&quot; height=&quot;775&quot; data-cke-saved-src=&quot;https://oscimg.oschina.net/oscnet/df08f7cd440b5d089596b154c75f00c010a.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;图7 - 产生的标签&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2. 确定显示标签&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在不同的目标下，会有不同评价方式，展示出来的标签也应该体现出相应的个性化和差异化。我们根据该目标所有评论对应的标签类别号，统计每个标签类别中所有句式产生的标签出现频次，将出现频次最高的标签作为该标签类别的显示名称。&lt;/p&gt;
&lt;p&gt;例如标签类别“性价比好”有三个句式{性价比}{很好}，{性价比}{高}，{价格}{便宜}，在某个目标下的评价统计中标签“性价比不错”“性价比高”“价格实惠”分别出现了 5 次，10 次，7 次，那么关于这个标签类别显示的标签为“性价比高”。&lt;/p&gt;
&lt;p&gt;这里有一种特殊情况：如果在同一个标签类别下一个句式定义中，有需要独立显示的标签，则该句式产生的标签不会和其他句式标签合并，而是独立显示该句式中频次最高的标签。&lt;/p&gt;
&lt;p&gt;比如句式{提供}{去}[{火车站}OR{飞机场}]{班车}，其中设定{火车站}和{飞机场}是需要独立显示的标签，则最后这两个词语对应产生的频次最高的标签的结果是“提供去车站班车”和“提供到机场的班车”，这两个标签不会和该类别（提供班车）下的其他频次最高标签合并，比如“去车站方便”，而是作为两个标签独立显示。&lt;/p&gt;
&lt;p&gt;再如，标签类别“位置好”中包含了两个句式，{离}{POI}{近}和{POI}{步行}{3}{分钟}，因为POI是被设定需要独立显示的类别，若产生的标签“离故宫近”的频次为 10，“离景山近”的频次是 15，“故宫步行 3 分钟”的频次是 17，则在“位置好”标签类别下，分别显示标签“故宫步行 3 分钟”和“离景山近”。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3. 对未匹配子句分词处理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于未被匹配的子句进行自动产生句式处理，使用内容分类，句法分析，依存分析，词义分析等方法自动产生标签分类和每个分类下的句式，用户可以对这些标签句式审核和调整。并可对已有词组推荐近义词等，丰富词组的词语数量。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4.定位子句&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为之前已经保存了标签和被匹配子句之间的关系，当点击标签时，会高亮显示对应的子句。&lt;/p&gt;

&lt;h2&gt;小结&lt;/h2&gt;
&lt;p&gt;本文介绍的关于预设句式模板定义，通过灵活的词组的组合方式，可以动态的匹配大量标签，很好的解决了标签定义量大的问题。&lt;/p&gt;
&lt;p&gt;由于句式的定义符合用户对目标的评价习惯，所以能覆盖更多的用户点评，提高了召回率，且模板产生的标签更符合评价语言的表达方式。&lt;/p&gt;
&lt;p&gt;由于文章篇幅所限，后期我们会再介绍自动的句式生产。大家可以&lt;strong&gt;订阅马蜂窝技术公众号&lt;/strong&gt;持续关注。谢谢。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;本文作者：&lt;/strong&gt;乔志军，马蜂窝搜索与推荐研发团队内容挖掘工程师。 &lt;/p&gt;

&lt;p&gt;关注马蜂窝技术（微信ID：mfwtech），找到更多你想要的内容。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1614086/201903/1614086-20190312154745425-724856888.jpg&quot; alt=&quot;&quot; width=&quot;271&quot; height=&quot;271&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 12 Mar 2019 07:40:00 +0000</pubDate>
<dc:creator>马蜂窝技术</dc:creator>
<og:description>如何在保证标签内容准确性的同时，体现出更符合用户语言习惯、让用户更容易理解的标签含义，对于提升用户在马蜂窝平台的体验，做出更符合自身需求的旅行决策，以及提升平台转化率、更好地监管商家服务品质等方面，都</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mfwtech/p/10517106.html</dc:identifier>
</item>
<item>
<title>ASP.NET Core 项目简单实现身份验证及鉴权 - Ant</title>
<link>http://www.cnblogs.com/wiseant/p/10515842.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wiseant/p/10515842.html</guid>
<description>&lt;p&gt;&lt;strong&gt;目录&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;环境&quot;&gt;环境&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;VS 2017&lt;/li&gt;
&lt;li&gt;ASP.NET Core 2.2&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;目标&quot;&gt;目标&lt;/h2&gt;
&lt;p&gt;　　以相对简单优雅的方式实现用户身份验证和鉴权，解决以下两个问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;无状态的身份验证服务，使用请求头附加访问令牌，几乎适用于手机、网页、桌面应用等所有客户端&lt;/li&gt;
&lt;li&gt;基于功能点的权限访问控制，可以将任意功能点权限集合授予用户或角色，无需硬编码角色权限，非常灵活&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;项目准备&quot;&gt;项目准备&lt;/h2&gt;
&lt;ol readability=&quot;5.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;创建一个ASP.NET Core Web应用程序&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用ASP.NET Core 2.2&lt;/li&gt;
&lt;li&gt;模板选[空]&lt;/li&gt;
&lt;li&gt;不启用HTTPS&lt;/li&gt;
&lt;li&gt;不进行身份验证&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;通过NuGet安装&lt;code&gt;Swashbuckle.AspNetCore&lt;/code&gt;程序包，并在Startup类中启用Swagger支持&lt;/p&gt;
&lt;p&gt;&lt;em&gt;因为这个示例项目不打算编写前端网页，所以直接使用Swagger来调试，真的很方便。&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;添加一个空的MVC控制器(HomeController)和一个空的API控制器(AuthController)&lt;/p&gt;
&lt;p&gt;&lt;code&gt;HomeController.Index()&lt;/code&gt;方法中只写一句简单的跳转代码即可：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;return new RedirectResult(&quot;~/swagger&quot;);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;AuthController&lt;/code&gt;类中随便写一两个骨架方法，方便看效果。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;运行项目，会自动打开浏览器并跳转到Swagger页面。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;身份验证&quot;&gt;身份验证&lt;/h2&gt;
&lt;h3 id=&quot;定义基本类型和接口&quot;&gt;定义基本类型和接口&lt;/h3&gt;
&lt;ol readability=&quot;8&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;ClaimTypes 定义一些常用的声明类型常量&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;IClaimsSession 表示当前会话信息的接口&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;ClaimsSession 会话信息实现类&lt;br/&gt;根据声明类型从ClaimsPrincipal.ClaimsIdentity属性中读取用户ID、用户名等信息。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;实际项目中可从此类继承或完全重新实现自己的Session类，以添加更多的会话信息(例如工作部门)&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;IToken 登录令牌接口&lt;br/&gt;包含访问令牌、刷新令牌、令牌时效等令牌&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;IIdentity 身份证明接口&lt;br/&gt;包含用户基本信息及令牌信息&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;IAuthenticationService 验证服务接口&lt;br/&gt;抽象出来的验证服务接口，仅规定了四个身份验证相关的方法，如需扩展可定义由此接口派生的接口。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;7.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;5&quot;&gt;&lt;td&gt;Login(userName, password)&lt;/td&gt;
&lt;td&gt;IIdentity&lt;/td&gt;
&lt;td&gt;根据用户名及密码验证其身份，成功则返回身份证明&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Logout()&lt;/td&gt;
&lt;td&gt;void&lt;/td&gt;
&lt;td&gt;注销本次登录，即使未登录也不报错&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;RefreshToken(refreshToken)&lt;/td&gt;
&lt;td&gt;Token&lt;/td&gt;
&lt;td&gt;刷新登录令牌，如果当前用户未登录则报错&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;ValidateToken(accessToken)&lt;/td&gt;
&lt;td&gt;IIdentity&lt;/td&gt;
&lt;td&gt;验证访问令牌，成功则返回身份证明&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;SimpleToken 登录令牌的简化实现&lt;/p&gt;
&lt;p&gt;&lt;em&gt;这个类提不提供都可以，实际项目中大家生成Token的算法肯定是各不相同的，提供简单实现仅用于演示&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;编写验证处理器&quot;&gt;编写验证处理器&lt;/h3&gt;
&lt;ol readability=&quot;10.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;BearerDefaults 定义了一些与身份验证相关的常量&lt;/p&gt;
&lt;p&gt;如：AuthenticationScheme&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;BearerOptions 身份验证选项类&lt;/p&gt;
&lt;p&gt;从&lt;code&gt;AuthenticationSchemeOptions&lt;/code&gt;继承而来&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;BearerValidatedContext 验证结果上下文&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;BearerHandler 身份验证处理器 &amp;lt;= &lt;strong&gt;关键类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;覆盖了&lt;code&gt;HandleAuthenticateAsync()&lt;/code&gt;方法，实现自定义的身份验证逻辑，简述如下：&lt;/p&gt;
&lt;ol readability=&quot;8&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;获取访问令牌。从请求头中获取&lt;code&gt;authorization&lt;/code&gt;信息，如果没有则从请求的参数中获取&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如果访问令牌为空，则终止验证，但不报错，直接返回&lt;code&gt;AuthenticateResult.NoResult()&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;调用从构造函数注入的&lt;code&gt;IAuthenticationService&lt;/code&gt;实例的&lt;code&gt;ValidateToken()&lt;/code&gt;方法，验证访问令牌是否有效，如果该方法触发异常(例如令牌过期)则捕获后通过&lt;code&gt;AuthenticateResult.Fail()&lt;/code&gt;返回错误信息，如果该方法返回值为空(例如访问令牌根本不存在)则返回&lt;code&gt;AuthenticateResult.NoResult()&lt;/code&gt;，不报错。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;到这一步说明身份验证已经通过，而且拿到身份证明信息，根据该信息创建&lt;code&gt;Claim&lt;/code&gt;数组，然后再创建一个包含这些&lt;code&gt;Claim&lt;/code&gt;数据的&lt;code&gt;ClaimsPrincipal&lt;/code&gt;实例，并将Thread.CurrentPrincipal设置为该实例。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;重点：&lt;/strong&gt;其实，&lt;code&gt;HttpContext.User&lt;/code&gt;属性的类型正是&lt;code&gt;CurrentPrincipal&lt;/code&gt;，而其值应该就是来自于&lt;code&gt;Thread.CurrentPrincipal&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;构造&lt;code&gt;BearerValidatedContext&lt;/code&gt;实例，并将其&lt;code&gt;Principal&lt;/code&gt;属性赋值为上面创建的&lt;code&gt;ClaimsPrincipal&lt;/code&gt;实例，然后调用&lt;code&gt;Success()&lt;/code&gt;方法，表示验证成功。最后返回该实例的&lt;code&gt;Result&lt;/code&gt;属性值。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li readability=&quot;10&quot;&gt;
&lt;p&gt;BearerExtensions 包含一些扩展方法，提供使用便利&lt;/p&gt;
&lt;p&gt;重点在于&lt;code&gt;AddBearer()&lt;/code&gt;方法内调用&lt;code&gt;builder.AddScheme&amp;lt;TOptions,THandler&amp;gt;()&lt;/code&gt;泛型方法时，分别使用了前面编写的&lt;code&gt;BearerOptions&lt;/code&gt;、&lt;code&gt;BearerHandler&lt;/code&gt;类作为泛型参数。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public static AuthenticationBuilder AddBearer(...)
{
    return builder.AddScheme&amp;lt;BearerOptions, BearerHandler&amp;gt;(...);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;如果想要自己实现&lt;code&gt;BearerHandler&lt;/code&gt;类的验证逻辑，可以抛弃此类，重新编写使用新Handler类的扩展方法&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;实现用户身份验证&quot;&gt;实现用户身份验证&lt;/h3&gt;
&lt;h4 id=&quot;说明&quot;&gt;说明&lt;/h4&gt;
&lt;p&gt;　　这部分是身份验证的落地，实际项目中应该将上面两步(定义基本类型和接口、编写验证处理器)的代码抽象出来，成为独立可复用的软件包，利用该软件包进行身份验证的实现逻辑可参照此示例代码。&lt;/p&gt;
&lt;h4 id=&quot;实现步骤&quot;&gt;实现步骤&lt;/h4&gt;
&lt;ol readability=&quot;9&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Identity 身份证明实现类&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;SampleAuthenticationService 验证服务的简单实现&lt;/p&gt;
&lt;p&gt;&lt;em&gt;出于演示方便，固化了三个用户(admin/123456、user/123、tester/123)&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;AuthController 通过HTTP向前端提供验证服务的控制器类&lt;/p&gt;
&lt;p&gt;&lt;em&gt;提供了用户登录、令牌刷新、令牌验证等方法。&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;11&quot;&gt;
&lt;p&gt;还需要修改项目中&lt;code&gt;Startup.cs&lt;/code&gt;文件，添加依赖注入规则、身份验证，并启用身份验证中间件。&lt;br/&gt;在&lt;code&gt;ConfigureServices&lt;/code&gt;方法内添加代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//添加依赖注入规则
services.AddScoped&amp;lt;IClaimsSession, ClaimsSession&amp;gt;();
services.AddScoped&amp;lt;IAuthenticationService, SampleAuthenticationService&amp;gt;();
//添加身份验证
services.AddAuthentication(options =&amp;gt;
{
 options.DefaultAuthenticateScheme = BearerDefaults.AuthenticationScheme;
    options.DefaultChallengeScheme = BearerDefaults.AuthenticationScheme;
}).AddBearer();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在&lt;code&gt;Configure()&lt;/code&gt;方法内添加代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//启用身份验证中间件
app.UseAuthentication();&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;通过swagger测试&quot;&gt;通过Swagger测试&lt;/h4&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;测试登录功能&lt;/p&gt;
&lt;p&gt;启动项目，自动进入[Swagger UI]界面，点击&lt;code&gt;/api/Auth/Login&lt;/code&gt;方法，不修改输入框中的内容直接点击[Execute]按钮，可以见到返回401错误码。&lt;/p&gt;
&lt;p&gt;在输入框中输入&lt;code&gt;{&quot;userName&quot;: &quot;admin&quot;, &quot;password&quot;: &quot;123456&quot;}&lt;/code&gt;，然后点击[Execute]按钮，系统验证成功并返回身份证明信息。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/19184/201903/19184-20190312150721993-2124207382.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;记下访问令牌&lt;code&gt;2ad43df2c11d48a18a88441adbf4994a&lt;/code&gt;和刷新令牌&lt;code&gt;9bbaf811ed8b4d29b638777d4f89238e&lt;/code&gt;&lt;/em&gt;&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;测试刷新登录令牌&lt;/p&gt;
&lt;p&gt;点击&lt;code&gt;/api/Auth/Refresh&lt;/code&gt;方法，在输入框中输入上面获取到的刷新令牌&lt;code&gt;9bbaf811ed8b4d29b638777d4f89238e&lt;/code&gt;，然后点击[Execute]按钮，返回401错误码。原因是因为我们并未提供访问令牌。&lt;/p&gt;
&lt;p&gt;点击方法名右侧的[锁]图标，在弹出框中输入之前获取的访问令牌&lt;code&gt;2ad43df2c11d48a18a88441adbf4994a&lt;/code&gt;并点击[Authorize]按钮后关闭对话框，重新点击[Execute]按钮，成功获取到新的登录令牌。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/19184/201903/19184-20190312150846449-1823703499.png&quot;/&gt;&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;测试验证访问令牌&lt;/p&gt;
&lt;p&gt;点击&lt;code&gt;/api/Auth/Validate&lt;/code&gt;方法，在输入框中输入第一次获取的到访问令牌&lt;code&gt;2ad43df2c11d48a18a88441adbf4994a&lt;/code&gt;，然后点击[Execute]按钮，返回400错误码，表明发起的请求参数有误。&lt;em&gt;因为此方法是支持匿名访问的，所以错误码不会是401.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;将输入框内容修改为新的访问令牌&lt;code&gt;f37542e162ed4855921ddf26b05c3f25&lt;/code&gt;，然后点击[Execute]按钮，验证成功，返回了对应的用户身份证明信息。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/19184/201903/19184-20190312150905894-626492096.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;权限鉴定&quot;&gt;权限鉴定&lt;/h2&gt;
&lt;p&gt;　　在ASP.NET Core项目中实现基于角色的授权很容易，在一些权限管理并不复杂的项目中，采取这种方式来实现权限鉴定简单可行。有兴趣可以参考这篇博文&lt;a href=&quot;https://www.cnblogs.com/RainingNight/p/authorization-in-asp-net-core.html&quot;&gt;ASP.NET Core 认证与授权5:初识授权&lt;/a&gt;&lt;br/&gt;　　但是，对于稍微复杂一些的项目，权限划分又细又多，如果采用这种方式，要覆盖到各种各样的权限组合，需要在代码中定义相当多的角色，大大增加项目维护工作，并且很不灵活。&lt;br/&gt;　　这里借鉴&lt;a href=&quot;https://aspnetboilerplate.com/&quot;&gt;ABP框架&lt;/a&gt;中权限鉴定的一些思想，来实现&lt;strong&gt;基于功能点&lt;/strong&gt;的权限访问控制。&lt;br/&gt;　　非常感谢ASP.NET Core和ABP等诸多优秀的开源项目，向你们致敬！&lt;br/&gt;　　&lt;em&gt;不得不说ABP框架非常优秀，但是我并不喜欢使用它，因为我没有能力和精力搞清楚它的详细设计思路，而且很多功能我根本不需要。&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&quot;思路&quot;&gt;思路&lt;/h3&gt;
&lt;p&gt;　　ASP.NET Core提供了一个&lt;code&gt;IAuthorizationFilter&lt;/code&gt;接口，如果在控制器类上添加[授权过滤]特性，相应的AuthorizationFilter类的&lt;code&gt;OnAuthorization()&lt;/code&gt;方法会在控制器的&lt;code&gt;Action&lt;/code&gt;之前运行，如果在该方法中设置AuthorizationFilterContext.Result为一个错误的response，&lt;code&gt;Action&lt;/code&gt;将不会被调用。&lt;/p&gt;
&lt;p&gt;基于这个思路，我们设计了以下方案：&lt;/p&gt;
&lt;ol readability=&quot;4&quot;&gt;&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;编写一个Attribute(特性)类，包含以下两个属性：&lt;/p&gt;
&lt;p&gt;Permissions：需要检查的权限数组&lt;/p&gt;
&lt;p&gt;RequireAllPermissions：是否需要拥有数组中全部权限，如果为否则拥有任一权限即可&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;定义一个&lt;code&gt;IPermissionChecker&lt;/code&gt;接口，在接口中定义&lt;code&gt;IsGrantedAsync()&lt;/code&gt;方法，用于执行权限鉴定逻辑&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;编写一个AuthorizationFilterAttribute特性类(应用目标为class)，通过属性注入&lt;code&gt;IPermissionChecker&lt;/code&gt;实例。然后在&lt;code&gt;OnAuthorization()&lt;/code&gt;方法内调用&lt;code&gt;IPermissionChecker&lt;/code&gt;实例的&lt;code&gt;IsGrantedAsync()&lt;/code&gt;方法，如果该方法返回值为false，则返回403错误，否则正常放行。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;编写过滤器类及相关接口&quot;&gt;编写过滤器类及相关接口&lt;/h3&gt;
&lt;ol readability=&quot;6.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;ApiAuthorizeAttribute类&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;    [AttributeUsage(AttributeTargets.Method)]
    public class ApiAuthorizeAttribute : Attribute, IFilterMetadata
    {
        public string[] Permissions { get; }

        public bool RequireAllPermissions { get; set; }

        public ApiAuthorizeAttribute(params string[] permissions)
        {
            Permissions = permissions;
        }
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;IPermissionChecker接口定义&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;    public interface IPermissionChecker
    {
        Task&amp;lt;bool&amp;gt; IsGrantedAsync(string permissionName);
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;AuthorizationFilterAttribute类&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;    [AttributeUsage(AttributeTargets.Class)]
    public class AuthorizationFilterAttribute : Attribute, IAuthorizationFilter
    {
        [Injection] //属性注入
        public IPermissionChecker PermissionChecker { get; set; } = NullPermissionChecker.Instance;

        public void OnAuthorization(AuthorizationFilterContext context)
        {
            if(存在[AllowAnonymous]特性) return;
            var authorizeAttribute = 从context.Filters中析出ApiAuthorizeAttribute
            foreach (var permission in authorizeAttribute.Permissions)
            {
             //检查各项权限
             var granted = PermissionChecker.IsGrantedAsync(permission).Result;
            }
            if(检查未通过)
             context.Result = new ObjectResult(&quot;未授权&quot;) { StatusCode = 403 };
        }
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;配合属性注入提供NullPermissionChecker类，在&lt;code&gt;IsGrantedAsync()&lt;/code&gt;方法内直接返回true。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;实现属性注入&quot;&gt;实现属性注入&lt;/h3&gt;
&lt;p&gt;　　做好上面的准备，我们应该可以开始着手在项目内应用权限鉴定功能了，不过ASP.NET Core内置的DI框架并不支持属性注入，所以还得添加属性注入的功能。&lt;/p&gt;
&lt;ol readability=&quot;9&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;定义InjectionAttribute类，用于显式声明应用了此特性的属性将使用依赖注入&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// 在属性上添加此特性，以声明该属性需要使用依赖注入
/// &amp;lt;/summary&amp;gt;
[AttributeUsage(AttributeTargets.Property)]
public class InjectionAttribute : Attribute { }&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;9&quot;&gt;
&lt;p&gt;添加一个&lt;code&gt;PropertiesAutowiredFilterProvider&lt;/code&gt;类，从&lt;code&gt;DefaultFilterProvider&lt;/code&gt;类派生&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class PropertiesAutowiredFilterProvider : DefaultFilterProvider
{
    private static IDictionary&amp;lt;string, IEnumerable&amp;lt;PropertyInfo&amp;gt;&amp;gt; _publicPropertyCache = new Dictionary&amp;lt;string, IEnumerable&amp;lt;PropertyInfo&amp;gt;&amp;gt;();

    public override void ProvideFilter(FilterProviderContext context, FilterItem filterItem)
    {
        base.ProvideFilter(context, filterItem); //在调用基类方法之前filterItem变量不会有值
        var filterType = filterItem.Filter.GetType();
        if (!_publicPropertyCache.ContainsKey(filterType.FullName))
        {
            var ps=filterType.GetProperties(BindingFlags.Public|BindingFlags.Instance)
                .Where(c =&amp;gt; c.GetCustomAttribute&amp;lt;InjectionAttribute&amp;gt;() != null);
            _publicPropertyCache[filterType.FullName] = ps;
        }

        var injectionProperties = _publicPropertyCache[filterType.FullName];
        if (injectionProperties?.Count() == 0)
            return;
        //下面是注入属性实例的关键代码
        var serviceProvider = context.ActionContext.HttpContext.RequestServices;
        foreach (var item in injectionProperties)
        {
            var service = serviceProvider.GetService(item.PropertyType);
            if (service == null)
            {
                throw new InvalidOperationException($&quot;Unable to resolve service for type '{item.PropertyType.FullName}' while attempting to activate '{filterType.FullName}'&quot;);
            }
            item.SetValue(filterItem.Filter, service);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;还有非常关键的一步，在&lt;code&gt;Startup.ConfigureServices()&lt;/code&gt;中添加下面的代码，替换&lt;code&gt;IFilterProvider&lt;/code&gt;接口的实现类为上面编写的&lt;code&gt;PropertiesAutowiredFilterProvider&lt;/code&gt;类&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;services.Replace(ServiceDescriptor.Singleton&amp;lt;Microsoft.AspNetCore.Mvc.Filters.IFilterProvider, PropertiesAutowiredFilterProvider&amp;gt;());&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;实现用户权限鉴定&quot;&gt;实现用户权限鉴定&lt;/h3&gt;
&lt;p&gt;　　终于，我们可以在项目内应用权限鉴定功能了。&lt;/p&gt;
&lt;h4 id=&quot;编码&quot;&gt;编码&lt;/h4&gt;
&lt;ol readability=&quot;19.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;首先，我们定义一些功能点权限常量&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public static class PermissionNames
{
    public const string TestAdd = &quot;Test.Add&quot;;
    public const string TestEdit = &quot;Test.Edit&quot;;
    public const string TestDelete = &quot;Test.Delete&quot;;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;11&quot;&gt;
&lt;p&gt;接着，添加一个新的用于测试的控制器类&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;    [AuthorizationFilter]
    [Route(&quot;api/[controller]&quot;)]
    [ApiController]
    public class TestController : ControllerBase
    {
        [Injection]
        public IClaimsSession Session { get; set; }

        [HttpGet]
        [Route(&quot;[action]&quot;)]
        public IActionResult CurrentUser() =&amp;gt; Ok(Session?.UserName);

        [ApiAuthorize]
        [HttpGet(&quot;{id}&quot;)]
        public IActionResult Get(int id)=&amp;gt; Ok(id);

        [ApiAuthorize(PermissionNames.TestAdd)]
        [HttpPost]
        [Route(&quot;[action]&quot;)]
        public IActionResult Create()=&amp;gt; Ok();

        [ApiAuthorize(PermissionNames.TestEdit, RequireAllPermissions = false)]
        [HttpPost]
        [Route(&quot;[action]&quot;)]
        public IActionResult Update()=&amp;gt; Ok();

        [ApiAuthorize(PermissionNames.TestAdd, PermissionNames.TestEdit, RequireAllPermissions = false)]
        [HttpPost]
        [Route(&quot;[action]&quot;)]
        public IActionResult Patch() =&amp;gt; Ok();

        [ApiAuthorize(PermissionNames.TestDelete)]
        [HttpDelete(&quot;{id}&quot;)]
        public IActionResult Delete(int id) =&amp;gt; Ok();
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在控制器类上添加了[AuthorizationFilter]特性，除了&lt;code&gt;CurrentUser()&lt;/code&gt;方法以外，都添加了[ApiAuthorize]特性，所需的权限各不相同，为简化测试所有的&lt;code&gt;Action&lt;/code&gt;都直接返回&lt;code&gt;OkResult&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;13&quot;&gt;
&lt;p&gt;实现一个用于演示的权限检查器类&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class SamplePermissionChecker : IPermissionChecker
{
    private readonly Dictionary&amp;lt;long, string[]&amp;gt; userPermissions = new Dictionary&amp;lt;long, string[]&amp;gt;
    {
        //Id=1的用户具有Test模块的全部功能
        { 1, new[] { PermissionNames.TestAdd, PermissionNames.TestEdit, PermissionNames.TestDelete } },
        //Id=2的用户具有Test模块的编辑和删除功能
        { 2, new[] { PermissionNames.TestEdit, PermissionNames.TestDelete } }
    };

    public IClaimsSession Session { get; }

    //通过构造函数注入IClaimsSession实例，以便在权限鉴定方法中获取用户信息
    public SamplePermissionChecker(IClaimsSession session)
    {
        this.Session = session;
    }

    public Task&amp;lt;bool&amp;gt; IsGrantedAsync(string permissionName)
    {
        if(!userPermissions.Any(p =&amp;gt; p.Key == Session.UserId))
            return Task.FromResult(false);
        var up = userPermissions.Where(p =&amp;gt; p.Key == Session.UserId).First();
        var granted = up.Value.Any(permission =&amp;gt; permission.Equals(permissionName, StringComparison.InvariantCultureIgnoreCase));
        return Task.FromResult(granted);
    }

}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;7&quot;&gt;
&lt;p&gt;最后还需要修改项目中&lt;code&gt;Startup.cs&lt;/code&gt;文件，添加依赖注入规则&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;services.AddSingleton&amp;lt;IPermissionChecker, SamplePermissionChecker&amp;gt;();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为SamplePermissionChecker类中并没有需要进程间隔离的数据，所以使用单例模式注册就可以了。不过这样一来，因为该类通过构造函数注入了&lt;code&gt;IClaimsSession&lt;/code&gt;接口实例，在构建Checker类实例时将触发异常。考虑到&lt;code&gt;CliamsSession&lt;/code&gt;类中只有方法没有数据 ，改为单例也并无妨，于是将该接口也改为单例模式注册。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;通过swagger测试-1&quot;&gt;通过Swagger测试&lt;/h4&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;测试未登录时仅可访问&lt;code&gt;/api/Test/CurrentUser&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;测试以用户user登录，可以访问&lt;code&gt;/api/Test/CurrentUser&lt;/code&gt;和GET请求&lt;code&gt;/api/Test/{id}&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;测试以用户admin登录，可以访问除&lt;code&gt;/api/Test/Add&lt;/code&gt;以外的接口&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;测试&quot;&gt;测试&lt;/h2&gt;
&lt;p&gt;编写了命令行程序，用来测试前面实现的Web API服务。&lt;/p&gt;
&lt;h3 id=&quot;测试不同用户同时访问时session是否正确&quot;&gt;测试不同用户同时访问时Session是否正确&lt;/h3&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;测试方法&lt;/p&gt;
&lt;p&gt;同时运行三个测试程序，都选择[测试身份验证]，然后分别输入不同的用户身份序号，快速切换三个程序并按下回车键，三个测试程序会各自发起100次请求，每次请求间隔100毫秒。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;例如同时打开三个命令行终端执行：dotnet .\CustomAuthorization.test.dll&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;测试结果&lt;/p&gt;
&lt;p&gt;三个测试程序从后台服务所获取到的当前用户信息完成匹配。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/19184/201903/19184-20190312150938001-366760239.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;测试以不同用户身份访问需要权限的接口&quot;&gt;测试以不同用户身份访问需要权限的接口&lt;/h3&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;测试方法&lt;/p&gt;
&lt;p&gt;预设的权限为：admin=&amp;gt;全部权限，user=&amp;gt;除&lt;code&gt;Test.Add&lt;/code&gt;以外权限，tester=&amp;gt;无。&lt;/p&gt;
&lt;p&gt;分别以admin、user、tester三个用户身份请求&lt;code&gt;/api/test&lt;/code&gt;下的所有接口，并模拟令牌过期的场景。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;测试结果&lt;/p&gt;
&lt;p&gt;可以见到，以过期的令牌发起请求时，后台返回的状态为Unauthorized，当用户未获得足够的授权时后台返回的状态为Forbidden。&lt;/p&gt;
&lt;p&gt;测试通过！&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/19184/201903/19184-20190312150959365-319178246.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;最后&quot;&gt;最后&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://gitee.com/xant77/CustomAuthorization.WebApi&quot;&gt;源代码托管在gitee.com&lt;/a&gt;&lt;br/&gt;&lt;strong&gt;欢迎转载，请在明显位置给出出处及链接&lt;/strong&gt;。&lt;/p&gt;
</description>
<pubDate>Tue, 12 Mar 2019 07:21:00 +0000</pubDate>
<dc:creator>Ant</dc:creator>
<og:description>ASP.NET Core 身份验证及鉴权 目录 + 项目准备 + 身份验证 定义基本类型和接口 编写验证处理器 实现用户身份验证 + 权限鉴定 思路 编写过滤器类及相关接口 实现属性注入 实现用户权限</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wiseant/p/10515842.html</dc:identifier>
</item>
<item>
<title>面向对象之七大基本原则（javaScript） - Aaron-攻城狮</title>
<link>http://www.cnblogs.com/aaron---blog/p/10516730.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/aaron---blog/p/10516730.html</guid>
<description>&lt;blockquote&gt;
&lt;h4 id=&quot;前言&quot;&gt;1. 前言&lt;/h4&gt;
&lt;/blockquote&gt;
&lt;p&gt;面向对象编程有自己的特性与原则，如果对于面向对象有一些了解的话，面向对象三大特征，封装、继承、多态，如果对面向对这三个概念不太了解，请参考&lt;a href=&quot;https://www.cnblogs.com/aaron---blog/p/10412059.html&quot;&gt;面向对象之三个基本特征（javaScript）&lt;/a&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;h4 id=&quot;单一职责&quot;&gt;2. 单一职责&lt;/h4&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果我们在编写程序的时候，一类或者一个方法里面包含了太多方法，对于代码的可读性来说，无非是一场灾难，对于我们来说。所以为了解决这个问题，出现了单一职责。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;什么是单一职责&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://baike.baidu.com/item/%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99/9456515&quot;&gt;单一职责&lt;/a&gt;：又称单一功能原则，面向对象五个基本原则（SOLID）之一。它规定一个类应该只有一个发生变化的原因。(节选自百度百科)&lt;/p&gt;
&lt;p&gt;按照上面说的，就是对一个类而言，应该仅有一个引起它变化的原因。换句话说，一个类的功能要单一，只做与它相关的事情。在类的设计过程中要按职责进行设计，彼此保持正交，互不干涉。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;单一职责的好处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;&lt;li&gt;类的复杂性降低，实现什么职责都有清晰明确的定义&lt;/li&gt;
&lt;li&gt;可读性提高，复杂性降低，那当然可读性提高了&lt;/li&gt;
&lt;li&gt;可维护性提高，可读性提高，那当然更容易维护了&lt;/li&gt;
&lt;li&gt;变更引起的风险降低，变更是必不可少的，如果接口的单一职责做得好，一个接口修改只对相应的实现类有影响，对其他的接口无影响，这对系统的扩展性、维护性都有非常大的帮助。&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote&gt;
&lt;p&gt;实例&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;class ShoppinCar {
    constructor(){
        this.goods = [];
    }
    addGoods(good){
        this.goods = [good];
    }
    getGoodsList(){
        return this.goods;
    }
}
class Settlement {
    constructor(){
        this.result = 0; 
    }
    calculatePrice(list,key){
        let allPrice = 0;
        list.forEach((el) =&amp;gt; {
            allPrice += el[key];
        })
        this.result = allPrice;
    }
    getAllPrice(){
        return this.result;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;用上面的代码来说&lt;code&gt;ShoppinCar&lt;/code&gt;类存在两个方法&lt;code&gt;addGoods&lt;/code&gt;和&lt;code&gt;getGoodsList&lt;/code&gt;,分别是添加商品和获取商品列表。&lt;code&gt;Settlement&lt;/code&gt;类中存在两个方法&lt;code&gt;calculatePrice&lt;/code&gt;和&lt;code&gt;getAllPrice&lt;/code&gt;分别做的事情是计算价钱与获取总价钱。&lt;code&gt;ShoppinCar&lt;/code&gt;与&lt;code&gt;Settlement&lt;/code&gt;都是在做自己的事情。添加商品与计算价格，虽然在业务上是相互依赖的，但是在代码中分别用两个类，然他们自己做自己的事情。其中任何一个类更改不会对另一个类进行更改。&lt;/p&gt;
&lt;blockquote&gt;
&lt;h4 id=&quot;开闭原则&quot;&gt;3. 开闭原则&lt;/h4&gt;
&lt;/blockquote&gt;
&lt;p&gt;在一个类中暴露出去的方法，若这个方法变更了，则会产生很大的后果，可能导致其他依赖于这个方法且有不需要变更的业务造成大面积瘫痪。为了解决这个问题，可以单独再写一个方法，若这个方法与这个类中的其他方法相互依赖。&lt;/p&gt;
&lt;p&gt;解决办法：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;把其中依赖的代码copy一份到新的类中。&lt;/li&gt;
&lt;li&gt;在新类中引用旧类中的方法。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;两种方法都不是最好的解决方案。&lt;/p&gt;
&lt;p&gt;第一种方法会导致代码大量的重复，第二种方法会导致类与类之间互相依赖。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;什么是开闭原则&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://baike.baidu.com/item/%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99/2828775?fr=aladdin&quot;&gt;开闭原则&lt;/a&gt;：“软件中的对象（类，模块，函数等等）应该对于扩展是开放的，但是对于修改是封闭的”，这意味着一个实体是允许在不改变它的源代码的前提下变更它的行为。(节选自百度百科)&lt;/p&gt;
&lt;p&gt;开闭原则对扩展开放,对修改关闭,并不意味着不做任何修改,底层模块的变更,必然要有高层模块进行耦合,否则就是一个孤立无意义的代码片段。开闭原则是一个最基本的原则,另外六个原则都是开闭原则的具体形态,是指导设计的工具和方法,而开闭原则才是精神领袖.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;开闭原则好处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;&lt;li&gt;开闭原则有利于进行单元测试&lt;/li&gt;
&lt;li&gt;开闭原则可以提高复用性&lt;/li&gt;
&lt;li&gt;开闭原则可以提高可维护性&lt;/li&gt;
&lt;li&gt;面向对象开发的要求&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote&gt;
&lt;p&gt;实例&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;class Drag {
    down(){
        //  ...
    }   
    move(){
        //  ...
        // 对拖拽没有做任何限制可以随意拖拽
    }   
    up(){
        //  ...
    }  
}
class LimitDrag extends Drag {
    move(){
        //  ...
        //  重写该方法对拖拽进行限制处理
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在&lt;code&gt;LimitDrag&lt;/code&gt;中重写了&lt;code&gt;move&lt;/code&gt;方法，若修改了可以满足两种需求，一种是限制型拖拽，一种是不限制型拖拽，任何一个更改了另外一个还是可以正常运行。&lt;/p&gt;
&lt;blockquote&gt;
&lt;h4 id=&quot;里氏替换&quot;&gt;4. 里氏替换&lt;/h4&gt;
&lt;/blockquote&gt;
&lt;p&gt;每个开发人员在使用别人的组件时，只需知道组件的对外裸露的接口，那就是它全部行为的集合，至于内部到底是怎么实现的，无法知道，也无须知道。所以，对于使用者而言，它只能通过接口实现自己的预期，如果组件接口提供的行为与使用者的预期不符，错误便产生了。里氏替换原则就是在设计时避免出现派生类与基类不一致的行为。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;什么是里氏替换&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://baike.baidu.com/item/%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99/3744239?fr=aladdin&quot;&gt;里氏替换原则&lt;/a&gt;：OCP作为OO的高层原则，主张使用“抽象(Abstraction)”和“多态(Polymorphism)”将设计中的静态结构改为动态结构，维持设计的封闭性。“抽象”是语言提供的功能。“多态”由继承语义实现。(节选自百度百科)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;里氏替换好处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;&lt;li&gt;代码共享，减少创建类的工作量，每个子类都拥有父类的方法和属性&lt;/li&gt;
&lt;li&gt;提高代码的重用性&lt;/li&gt;
&lt;li&gt;子类可以形似父类，但是又异于父类。&lt;/li&gt;
&lt;li&gt;提高代码的可扩展性，实现父类的方法就可以了。许多开源框架的扩展接口都是通过继承父类来完成。&lt;/li&gt;
&lt;li&gt;提高产品或项目的开放性&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote&gt;
&lt;p&gt;实例&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;//  抽象枪类
class AbstractGun {
    shoot(){
        throw &quot;Abstract methods cannot be called&quot;;
    }
}
//  步枪
class Rifle extends AbstractGun {
    shoot(){
        console.log(&quot;步枪射击...&quot;);
    }
}
//  狙击枪
class AUG extends Rifle {
    zoomOut(){
        console.log(&quot;通过放大镜观察&quot;);
    }
    shoot(){
        console.log(&quot;AUG射击...&quot;);
    }
}
//  士兵
class Soldier {
    constructor(){
        this.gun = null;
    }
    setGun(gun){
        this.gun = gun;
    }
    killEnemy(){
        if(!this.gun){
            throw &quot;需要给我一把枪&quot;;
            return;
        }
        console.log(&quot;士兵开始射击...&quot;);
        this.gun.shoot();
    }
}
//  狙击手
class Snipper extends Soldier {
    killEnemy(aug){
        if(!this.gun){
            throw &quot;需要给我一把枪&quot;;
            return;
        }
        this.gun.zoomOut();
        this.gun.shoot();
    }
}
let soldier = new Soldier();
soldier.setGun(new Rifle());
soldier.killEnemy();

let snipper = new Snipper();
//  分配狙击枪
snipper.setGun(new AUG());
snipper.killEnemy();

snipper.setGun(new Rifle());
// snipper.killEnemy();  //  this.gun.zoomOut is not a function&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上述代码中可以看出，子类和父类之间关系，子类方法一定是等于或大于父类的方法。子类能够出现的父类不一定能出现，但是父类出现的地方子类一定能够出现。&lt;/p&gt;
&lt;blockquote&gt;
&lt;h4 id=&quot;依赖倒置&quot;&gt;5. 依赖倒置&lt;/h4&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果方法与方法之间或类与类之间，存在太多的依赖关系会导致代码可读性以及可维护性很差。依赖倒置原则能够很好的解决这些问题。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;什么是依赖倒置&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://baike.baidu.com/item/%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99/6189149&quot;&gt;依赖倒置原则&lt;/a&gt;：程序要依赖于抽象接口，不要依赖于具体实现。简单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。(节选自百度百科)&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;高层模块不应该依赖低层模块，两者都应该依赖其抽象&lt;/li&gt;
&lt;li&gt;抽象不应该依赖细节&lt;/li&gt;
&lt;li&gt;细节应该依赖抽象&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote&gt;
&lt;p&gt;依赖倒置好处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;&lt;li&gt;通过依赖于接口，隔离了具体实现类&lt;/li&gt;
&lt;li&gt;低一层的变动并不会导致高一层的变动&lt;/li&gt;
&lt;li&gt;提高了代码的容错性、扩展性和易于维护&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote&gt;
&lt;p&gt;实例&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;//  抽象枪类
class AbstractGun {
    shoot(){
        throw &quot;Abstract methods cannot be called&quot;;
    }
}
//  步枪
class Rifle extends AbstractGun {
    shoot(){
        console.log(&quot;步枪射击...&quot;);
    }
}
//  狙击枪
class AUG extends AbstractGun {
    shoot(){
        console.log(&quot;AUG射击...&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上面的代码可以看出，步枪与狙击枪的&lt;code&gt;shoot&lt;/code&gt;全部都是依赖于&lt;code&gt;AbstractGun&lt;/code&gt;抽象的枪类，上述编程满足了依赖倒置原则。&lt;/p&gt;
&lt;blockquote&gt;
&lt;h4 id=&quot;接口隔离&quot;&gt;6. 接口隔离&lt;/h4&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;什么是接口隔离&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://baike.baidu.com/item/%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99/3104602?fr=aladdin&quot;&gt;接口隔离&lt;/a&gt;：客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。(节选自百度百科)&lt;/p&gt;
&lt;p&gt;接口隔离原则与单一职责原则的审视角度不相同。单一职责原则要求是类和接口的职责单一，注重的职责，这是业务逻辑上的划分。接口隔离原则要求接口的方法尽量少。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;接口隔离好处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;&lt;li&gt;避免接口污染&lt;/li&gt;
&lt;li&gt;提高灵活性&lt;/li&gt;
&lt;li&gt;提供定制服务&lt;/li&gt;
&lt;li&gt;实现高内聚&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote&gt;
&lt;p&gt;实例&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;function mix(...mixins) {
  class Mix {}
  for (let mixin of mixins) {
    copyProperties(Mix, mixin);
    copyProperties(Mix.prototype, mixin.prototype);
  }
  return Mix;
}
function copyProperties(target, source) {
  for (let key of Reflect.ownKeys(source)) {
    if ( key !== &quot;constructor&quot;&amp;amp;&amp;amp; key !== &quot;prototype&quot;&amp;amp;&amp;amp; key !== &quot;name&quot;) {
      let desc = Object.getOwnPropertyDescriptor(source, key);
      Object.defineProperty(target, key, desc);
    }
  }
}
class Behavior {
    eat(){
        throw &quot;Abstract methods cannot be used&quot;;
    }   
    call(){
        throw &quot;Abstract methods cannot be used&quot;;
    }
}
class Action {
    climbTree(){
        throw &quot;Abstract methods cannot be used&quot;;
    }
}
class Dog extends Behavior{
    eat(food){
        console.log(`狗正在吃${food}`);
    }
    hungry(){
        console.log(&quot;汪汪汪,我饿了&quot;)
    }
}
const CatMin = mix(Behavior,Action);
class Cat extends CatMin{
    eat(food){
        console.log(`猫正在吃${food}`);
    }
    hungry(){
        console.log(&quot;喵喵喵,我饿了&quot;)
    }
    climbTree(){
        console.log(&quot;爬树很开心哦~&quot;)
    }
}
let dog = new Dog();
dog.eat(&quot;骨头&quot;);
dog.hungry();
let cat = new Cat();
cat.eat(&quot;鱼&quot;);
cat.hungry();
cat.climbTree();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;大家一定要好好分析一下上面的代码，共有两个抽象类，分别对应不同的行为，&lt;code&gt;Cat&lt;/code&gt;与&lt;code&gt;Dog&lt;/code&gt;类拥有共同的行为，但是&lt;code&gt;Cat&lt;/code&gt;又拥有其自己单独的行为，使用抽象(即接口)继承其方法，使用接口隔离使其完成各自的工作，各司其职。&lt;/p&gt;
&lt;blockquote&gt;
&lt;h4 id=&quot;迪米特法则&quot;&gt;7. 迪米特法则&lt;/h4&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://baike.baidu.com/item/%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99&quot;&gt;迪米特法则&lt;/a&gt;:最少知识原则（Least Knowledge Principle 简写LKP），就是说一个对象应当对其他对象有尽可能少的了解,不和陌生人说话。英文简写为: LoD.(节选自百度百科)&lt;/p&gt;
&lt;p&gt;迪米特法则的做法观念就是类间解耦，弱耦合，只有弱耦合了以后，类的复用率才可以提高。一个类应该对其他对象保持最少的了解。通俗来讲，就是一个类对自己依赖的类知道的越少越好。因为类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;迪米特法则好处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;&lt;li&gt;减少对象之间的耦合性&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote&gt;
&lt;p&gt;实例&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;class ISystem {
    close(){
        throw &quot;Abstract methods cannot be used&quot;;
    }
}
class System extends ISystem{
    saveCurrentTask(){
        console.log(&quot;saveCurrentTask&quot;)
    }
    closeService(){
        console.log(&quot;closeService&quot;)
    }
    closeScreen(){
        console.log(&quot;closeScreen&quot;)
    }
    closePower(){
        console.log(&quot;closePower&quot;)
    }
    close(){
        this.saveCurrentTask();
        this.closeService();
        this.closeScreen();
        this.closePower();
    }
}
class IContainer{
    sendCloseCommand(){
        throw &quot;Abstract methods cannot be used&quot;;
    }
}
class Container extends IContainer{
    constructor(){
        super()
        this.system = new System();
    }
    sendCloseCommand(){
        this.system.close();
    }
}
class Person extends IContainer{
    constructor(){
        super();
        this.container = new Container();
    }
    clickCloseButton(){
       this.container.sendCloseCommand();
    }
}
let person = new Person();
person.clickCloseButton();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面代码中&lt;code&gt;Container&lt;/code&gt;作为媒介，其调用类不知道其内部是如何实现，用户去触发按钮，&lt;code&gt;Container&lt;/code&gt;把消息通知给计算机，计算机去执行相对应的命令。&lt;/p&gt;
&lt;blockquote&gt;
&lt;h4 id=&quot;组合聚合复用原则&quot;&gt;8. 组合/聚合复用原则&lt;/h4&gt;
&lt;/blockquote&gt;
&lt;p&gt;聚合（Aggregation）表示一种弱的‘拥有’关系，体现的是A对象可以包含B对象但B对象不是A对象的一部分。&lt;/p&gt;
&lt;p&gt;合成（Composition）则是一种强的'拥有'关系，体现了严格的部分和整体关系，部分和整体的生命周期一样。&lt;/p&gt;
&lt;p&gt;组合/聚合：是通过获得其他对象的引用，在运行时刻动态定义的，也就是在一个对象中保存其他对象的属性，这种方式要求对象有良好定义的接口，并且这个接口也不经常发生改变，而且对象只能通过接口来访问，这样我们并不破坏封装性，所以只要类型一致，运行时还可以通过一个对象替换另外一个对象。&lt;/p&gt;
&lt;p&gt;优先使用对象的合成/聚合将有助于你保持每个类被封装，并被集中在单个任务上，这样类和类继承层次会保持较小规模，而且不太可能增长为不可控制的庞然大物。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;组合/聚合复用原则好处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;&lt;li&gt;新的实现较为容易，因为超类的大部分功能可通过继承关系自动进入子类；&lt;/li&gt;
&lt;li&gt;修改或扩展继承而来的实现较为容易。&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote&gt;
&lt;p&gt;实例&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;function mix(...mixins) {
  class Mix {}
  for (let mixin of mixins) {
    copyProperties(Mix, mixin);
    copyProperties(Mix.prototype, mixin.prototype);
  }
  return Mix;
}
function copyProperties(target, source) {
  for (let key of Reflect.ownKeys(source)) {
    if ( key !== &quot;constructor&quot;&amp;amp;&amp;amp; key !== &quot;prototype&quot;&amp;amp;&amp;amp; key !== &quot;name&quot;) {
      let desc = Object.getOwnPropertyDescriptor(source, key);
      Object.defineProperty(target, key, desc);
    }
  }
}
class Savings {
    saveMoney(){
        console.log(&quot;存钱&quot;);
    }
    withdrawMoney(){
        console.log(&quot;取钱&quot;);
    }
}
class Credit {
    overdraft(){
        console.log(&quot;透支&quot;)
    }
}
const CarMin = mix(Savings,Credit);
class UserCar extends CarMin {
    constructor(num,carUserName){
        super();
        console.log()
        this.carNum = num;
        this.carUserName = carUserName;
    }
    getCarNum(){
        return this.carNum;
    }
    getCarUserName(){
        return this.carUserName;
    }
}
let myCar = new UserCar(123456798,&quot;Aaron&quot;);
console.log(myCar.getCarNum());
console.log(myCar.getCarUserName());
myCar.saveMoney();
myCar.withdrawMoney();
myCar.overdraft();&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;h4 id=&quot;总结&quot;&gt;9. 总结&lt;/h4&gt;
&lt;/blockquote&gt;
&lt;p&gt;这些原则在设计模式中体现的淋淋尽致，设计模式就是实现了这些原则，从而达到了代码复用、增强了系统的扩展性。所以设计模式被很多人奉为经典。我们可以通过好好的研究设计模式，来慢慢的体会这些设计原则。&lt;/p&gt;
</description>
<pubDate>Tue, 12 Mar 2019 06:58:00 +0000</pubDate>
<dc:creator>Aaron-攻城狮</dc:creator>
<og:description>'1. 前言' '2. 单一职责' '3. 开闭原则' '4. 里氏替换' '5. 依赖倒置' '6. 接口隔离' '7. 迪米特法则' '8. 组合聚合复用原则' '9. 总结' 1. 前言 面向对</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/aaron---blog/p/10516730.html</dc:identifier>
</item>
<item>
<title>不一样的go语言-gopher - Laud</title>
<link>http://www.cnblogs.com/laud/p/gopher.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/laud/p/gopher.html</guid>
<description>&lt;h4 id=&quot;前言&quot;&gt;前言&lt;/h4&gt;
&lt;p&gt;  gopher原意地鼠，在golang 的世界里解释为&lt;strong&gt;地道的go程序员&lt;/strong&gt;。在其他语言的世界里也有PHPer，Pythonic的说法，反而Java是个例外。虽然也有Javaer之类的说法，但似乎并不被认可。而&lt;strong&gt;地道&lt;/strong&gt;或者说&lt;strong&gt;道地&lt;/strong&gt;，说的是gopher写的代码无不透露出go的独特气息，比如项目结构、命名方式、代码格式、编码风格、构建方式等等。用gopher的话说，用go编写代码就像是在画一幅中国山水画，成品美不胜收，心旷神怡。&lt;/p&gt;
&lt;h4 id=&quot;环境变量&quot;&gt;环境变量&lt;/h4&gt;
&lt;p&gt;  gopher第一条：把东西放对地方。&lt;/p&gt;
&lt;p&gt;  go程序的运行，需要依赖于两个基础的环境变量，GOROOT与GOPATH。环境变量几乎在各类编程语言中都存在，比如java的JAVA_HOME，其实也就是编译器及相关工具或标准库所在目录。但go除了GOROOT之外，还增加了GOPATH，它指的是go程序依赖的第三方库或自有库所在目录，以指示编译器从这些地方找到依赖。GOPATH支持多个目录，通常一个目录就是一个项目，并且GOPATH目录按约定由src、pkg、bin三个目录组成。gopher们的做法是定义Global GOPATH、Project GOPATH，而更大的项目还会定义Module GOPATH。当使用go get下载依赖时，会选择GOPATH环境变量中的第一个目录存放依赖包。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;GOROOT&lt;/td&gt;
&lt;td&gt;go运行环境根目录&lt;/td&gt;
&lt;td&gt;通常指go sdk安装目录，包含编译器、官方工具及标准库&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;GOPATH&lt;/td&gt;
&lt;td&gt;工作环境目录列表&lt;/td&gt;
&lt;td&gt;通常指第三方库、自有库及项目目录&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h5 id=&quot;gopath&quot;&gt;GOPATH&lt;/h5&gt;
&lt;ol&gt;&lt;li&gt;src: 源代码目录&lt;/li&gt;
&lt;li&gt;pkg: 编译时中间文件所在目录&lt;/li&gt;
&lt;li&gt;bin: 编译后生成可执行文件所在目录&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;├── src
|   └── eventer.com
|       └── test
|           └── main.go
├── pkg
└── bin
|   └── test.bin&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;global-gopath&quot;&gt;Global GOPATH&lt;/h5&gt;
&lt;p&gt;  全局GOPATH，通常将第三方库的代码保存至此处，便于所有项目引用，而不用重复下载。因此在GOPATH中，建议将global gopath放在最前面。&lt;/p&gt;
&lt;h5 id=&quot;project-gopath&quot;&gt;Project GOPATH&lt;/h5&gt;
&lt;p&gt;  如果项目比较简单的话，可以采用global GOPATH与project GOPATH的组合，即GOPATH设置为global GOPATH与project OGPATH两个目录。比如引用了需要对源码稍作修改的开源项目时，开源项目可以跟当前项目一起放在src目录下。&lt;/p&gt;
&lt;h5 id=&quot;module-gopath&quot;&gt;Module GOPATH&lt;/h5&gt;
&lt;p&gt;  在比较复杂的项目中，如果划分的模块比较多，则可以采用global, project, module三种GOPATH组合的方式，即即GOPATH设置为global GOPATH、project OGPATH、module GOPATH三个目录。&lt;/p&gt;
&lt;p&gt;  最后请注意，global GOPATH、project GOPATH、module GOPATH不是go语言中的概念，go要求的只有GOPATH。而因为GOPATH是一个目录列表，所以我只是在实践中将GOPATH细分为上述三者，同时便于讲述GOPATH的概念。&lt;/p&gt;
&lt;h4 id=&quot;项目结构&quot;&gt;项目结构&lt;/h4&gt;
&lt;p&gt;  gopher第二条：按东西放在约定的地方。&lt;/p&gt;
&lt;p&gt;  不同复杂度的项目，大致可以有两种类型的项目结构，第一种是依赖较少、较简单的项目，如下图所示，其中mydriver项目是假设要引用的开源项目，但要在当前项目的使用中稍修改，因此与当前项目的源码放在一起。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;├── src
|   ├── github.com
|       └── eventer
|           └── mydriver
|               └── driver.go
|   └── eventer.com
|       └── test
|           └── main.go
├── pkg
└── bin&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  第二种是依赖较多、模块划分较细、较复杂的项目，如下图所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;├── src
|   └── eventer.com
|           └── test
|               └── main.go
├── pkg
├── bin
├── module1
|   ├── src
|       └── eventer.com
|           └── lib
|               └── lib1.go
|   ├── pkg
|   └── bin
├── module2
|   ├── src
|       └── eventer.com
|           └── lib
|               └── lib2.go
|   ├── pkg
|   └── bin
└── module3
|   ├── src
|       └── eventer.com
|           └── lib
|               └── lib3.go
|   ├── pkg
|   └── bin&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  其中的module1，module2，module3是基础模块，被主项目依赖。这个时候除了将主项目路径放在GOPATH外，还应当将基础模块路径放在GOPATH中。这样的项目结构不仅让项目清晰，还可以做不同的分工。&lt;/p&gt;
&lt;h4 id=&quot;命名规范&quot;&gt;命名规范&lt;/h4&gt;
&lt;p&gt;  gopher第三条：把名字起得go一点。&lt;/p&gt;
&lt;p&gt;  go语言的命名与其他语言最大的不同在于首字母的大小写。大写代表公开（导出，可以在其他包内访问）；小写代表私有（不导出，只能在包内访问）。除此之外，与其他语言并无二致，比如不能以数字开头。而由于关键字、保留字的减少，因而减少了一些命名上的忌讳。更为突出的是，go语言有一些建议性的命名规范，这也是gophers的圣经，理应严格遵守。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;15&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;驼峰命名法&lt;/td&gt;
&lt;td&gt;全局&lt;/td&gt;
&lt;td&gt;统一使用驼峰命名法&lt;/td&gt;
&lt;td&gt;var isLive = false&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;大小写一致&lt;/td&gt;
&lt;td&gt;缩写短语，惯用词&lt;/td&gt;
&lt;td&gt;如HTML，CSS, HTTP等&lt;/td&gt;
&lt;td&gt;htmlEscape，HTMLEscape&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;简短命名法&lt;/td&gt;
&lt;td&gt;局部变量&lt;/td&gt;
&lt;td&gt;方法内、循环等使用的局部变量可以使用简短命名&lt;/td&gt;
&lt;td&gt;比如for循环中的i，buf代表buffer等&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;7&quot;&gt;&lt;td&gt;参数命名法&lt;/td&gt;
&lt;td&gt;函数参数、返回值、方法接收者&lt;/td&gt;
&lt;td&gt;如果参数类型能说明含义，则参数名可以简短，否则应该采用有文档说明能力的命名&lt;/td&gt;
&lt;td&gt;比如d Duration，t Time&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;通用命名法&lt;/td&gt;
&lt;td&gt;作用域越大或者使用的地方离声明的地方太远，则应采用清晰有意义的命名&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;7&quot;&gt;&lt;td&gt;导出命名法&lt;/td&gt;
&lt;td&gt;导出变量、函数、结构等&lt;/td&gt;
&lt;td&gt;包名与导出名意义不要重复，同时包的命名要与导出的内容相关，不要使用宽泛的名字，如common，util&lt;/td&gt;
&lt;td&gt;bytes.Buffer比bytes.ByteBuffer要好&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;5&quot;&gt;&lt;td&gt;文件命名&lt;/td&gt;
&lt;td&gt;go文件，单元测试文件&lt;/td&gt;
&lt;td&gt;go文件名尽量以一个单词来命名，多个单词使用下线划分隔，单元测试文件以对应go文件名加_test结尾&lt;/td&gt;
&lt;td&gt;proto_test&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;包命名&lt;/td&gt;
&lt;td&gt;包&lt;/td&gt;
&lt;td&gt;包的一级名称应是顶级域名，二级名称则应是项目名称，项目名称单词间以-分隔&lt;/td&gt;
&lt;td&gt;github.com/mysql&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4 id=&quot;代码格式&quot;&gt;代码格式&lt;/h4&gt;
&lt;p&gt;  gopher第四条：按统一的格式来。&lt;/p&gt;
&lt;p&gt;  在多人协作团队中，统一的代码格式化模板是第一要义。在Java语言中，检验新人经验的一大法宝就是他有没有主动索要代码模板。而在go语言中，则没有这个必要了。因为go已经有默认的代码格式化工具了，而且代码格式化在go语言中是强制规范。所以这使得所有go程序员写出来的代码格式都是一样的。&lt;/p&gt;
&lt;p&gt;  go默认的代码格式化工具是gofmt。另外还有一个增强工具goimport，在gofmt的基础上增加了自动删除和引入依赖包。而行长则以不超过80个字符为佳，超过请主动以多行展示。&lt;/p&gt;
&lt;h4 id=&quot;编码风格&quot;&gt;编码风格&lt;/h4&gt;
&lt;p&gt;  gopher第五条：请学会约定&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;10&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;import&lt;/td&gt;
&lt;td&gt;按标准库、内部包、第三方包的顺序导入包&lt;/td&gt;
&lt;td&gt;只引一个包时使用单行模式，否则使用多行模式&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;变量声明&lt;/td&gt;
&lt;td&gt;如果连续声明多个变量，应放在一起&lt;/td&gt;
&lt;td&gt;参见例子&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;5&quot;&gt;&lt;td&gt;错误处理&lt;/td&gt;
&lt;td&gt;不要忽略每一个error，即使只是打一行日志&lt;/td&gt;
&lt;td&gt;go的error处理方式与C同出一辙，通过返回值来标明错误或异常，引来的争议也很多，甚至官方已经开始酝酿在go2解决这个问题&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;长语句打印&lt;/td&gt;
&lt;td&gt;使用格式化方式打印&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;7&quot;&gt;&lt;td&gt;注释规范&lt;/td&gt;
&lt;td&gt;变量、方法、结构等的注释直接加上声明前，并且不要加空行。废弃方法加Deprecated:即可&lt;/td&gt;
&lt;td&gt;其中的第一行注释会被godoc识别为简短介绍，第二行开始则被认为是注释详情。注释对godoc的生成至关重要，因此关于注释会有一些技巧，我将在后面用专门的章节探讨&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;多变量声明&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;var (
    name string
    age int
)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注释规范&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;// Add 两数相加
// 两个整数相加，并返回和。
func Add(n1, n2 int)int{
    return n1 + n2
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;依赖管理&quot;&gt;依赖管理&lt;/h4&gt;
&lt;p&gt;  gopher第六条：使用依赖管理工具管理自有依赖与第三方依赖&lt;/p&gt;
&lt;p&gt;  一个语言的生态是否完善甚至是否强大，除了github上面的开源项目数量之外，还有一大特征就是是否有优秀的依赖管理工具。依赖管理工具在业界已经是无处不在，yum、maven、gradle、pip、npm、cargo这些工具的大名如雷贯耳。那么go有什么呢？&lt;/p&gt;
&lt;p&gt;  早期go的依赖是混乱的，因为没有一个工具能得到普遍认可，而官方又迟迟不出来解决问题。历数存在的工具包括godep、glide、govender等等。甚至早期还需要使用GOPATH来管理依赖，即项目的所有依赖都通过go get下载到指定的GOPATH中去。当然这种方案还可以撑大多数时间，但随着时间的流逝，随着开发人员的变动，这种管理依赖的弊端就慢慢显现出来。其实这些老路早期的java也走过，曾几何时，每个java项目里面都会有一个叫lib或libs的目录，这里放的就是当前项目依赖的包。当GO采用GOPATH来管理依赖时，开发人员只能被倒逼着用java的方式在源码库中自行管理依赖。这样相当于给依赖包做了隔离，同时又具备了版本管理（因为放在源码库）。&lt;/p&gt;
&lt;p&gt;  后来在go1.5的时候，官方引入了vender的概念，其实这也没改变多少，只是官方让大家存放依赖包的目录名称不要乱起了，统一叫vender吧。这个方案我觉得比依赖GOPATH还糟糕，因为vendor目录脱离了版本管理，导致更换依赖包版本很困难，在当前项目对依赖包的版本更新可能会影响其他项目的使用（如果新版本的依赖包有较大变动的话），同时如何将依赖包放到vendor下呢？等等。当然官方做出的这些变动可能是想像maven那样，推动社区来完成这件事，因而直接推动了上文提到的基于vendor的依赖管理工具的诞生。直至后来官方默认的社区做出来dep，这下安静了，尽管刚开始时也不怎么好用，但有总比没有好。&lt;/p&gt;
&lt;p&gt;  go1.11在vgo的基础上，官方推出了go module。在发布前，官方与社区的大神们还为此开吵，认为官方太不厚道且独断专行。完全忽视dep社区的存在，无视dep在go语言中的地位与贡献。喜欢八卦的朋友们，可搜索《关于Go Module的争吵》一览大神是怎么吵架的，也可从中学习他们的思想。&lt;/p&gt;
&lt;p&gt;  作为dep与module的亲身实践者，还是乖乖地用dep吧。除非你有足够的热情去折腾，比如弄个高速的科学上网工具，或者搭建Go module proxy。开源的go module proxy比如athens，goproxy。《Hello，Go module proxy》一文详细介绍了go module的幸福与烦恼，反正我是没有感到幸福。此文很全面地介绍go module后遗症，goproxy可以解决科学上网的问题，然后也有了athens这样的工具出现，go的依赖管理是朝着越来越好的方向发展。dep与module的争议在于respect and free，至少目前看来，两者是可以共存的，特别是在国内。&lt;/p&gt;
&lt;p&gt;  相对于java的依赖管理工具maven或gradle来说，gradle是maven的升级版，同时带来了DSL与元编程的特性，这无疑使得gradle异常地强大。但gradle.io在国内的可达情况也不尽如人意，好就好在其与maven仓库标准的兼容，使得从maven转到gradle几乎没有额外的成本及阻力。&lt;/p&gt;
&lt;p&gt;  扯了这么多，依赖管理对于一门语言是必不可少的。c有cmake，java有maven、gradle，rust有cargo，那么go的dep或者module就用起来吧，看完大神吵架之后，喜欢哪个就选哪个。是不可能产生一个能满足所有人要求的依赖管理工具的，就连号称最牛逼的cargo也不例外。在一般的项目中，能用到的依赖管理功能也就那常用的几个而已，对大多数项目来说，适用好用就行。&lt;/p&gt;
&lt;h4 id=&quot;构建方式&quot;&gt;构建方式&lt;/h4&gt;
&lt;p&gt;  gopher第七条：按需构建&lt;/p&gt;
&lt;p&gt;  构建的目标是让代码成为可运行程序。构建的过程应该是低成本并且让人愉悦的，显然C在这一方面让人抓狂，而go确实做得不错。并且能在任何平台下编译出另外一个平台的可执行程序。不管你的go程序是CLI、GUI、WEB或者其他形式的网络通讯程序，在go的世界里都只需要一个命令构建成可执行程序（依赖也一并被打包），即可在目标系统上运行。在这一点上，java是望尘莫及了。&lt;/p&gt;
&lt;p&gt;下面是用来构建go程序常用的参数，其他参数可通过go help environment命令查看。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;5.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;CGO_ENABLED&lt;/td&gt;
&lt;td&gt;0 or 1&lt;/td&gt;
&lt;td&gt;是否支持cgo命令，如果go代码中有c代码，需要设置为1&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;7&quot;&gt;&lt;td&gt;GOOS&lt;/td&gt;
&lt;td&gt;darwin, freebsd, linux, windows&lt;/td&gt;
&lt;td&gt;可执行程序运行的目标操作系统&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;GOARCH&lt;/td&gt;
&lt;td&gt;386, amd64, arm&lt;/td&gt;
&lt;td&gt;可执行程序运行的目标操作系统架构&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;# Linux下编译Mac 64位可执行程序
CGO_ENABLED=0 GOOS=darwin GOARCH=amd64 go build main.go

# Linux下编译windows 64位可执行程序
CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build main.go

# 如果想减少二进制程序的大小，可以加上-ldflags &quot;-s -w&quot;，但同时会丢掉调试信息，即不能用gdb调试了。
# 如果想更进一步减少程序大小，可以使用加壳工具，比如upx&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Tue, 12 Mar 2019 06:24:00 +0000</pubDate>
<dc:creator>Laud</dc:creator>
<og:description>gopher成长记</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/laud/p/gopher.html</dc:identifier>
</item>
<item>
<title>React 精要面试题讲解(二) 组件间通信详解 - 散场丶丶</title>
<link>http://www.cnblogs.com/sanchang/p/10516067.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sanchang/p/10516067.html</guid>
<description>&lt;h3 id=&quot;单向数据流与组件间通信&quot;&gt;单向数据流与组件间通信&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt; 上文我们已经讲述过，react 单向数据流的原理和简单模拟实现。结合上文中的代码，我们来进行这节面试题的讲解: react中的组件间通信。

 那么，首先我们把看上文中的原生js代码：&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;        function child(props){
           this.props = props;
        }
       function parent(props){ 
           this.props = props              
           this.state = '这是父函数的一个状态'
           this.childNodes  = new child(this.state); 
        }
       console.log(new parent('这是一个属性'));&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt; ok，经过运行，我们发现打印结果的结构 和 react父子组件的关系结构是极为类似的,子函数通过props形参接受到父函数的state。
 这个好理解吧？那么在说react组件通信之前，我们基于原生继续模拟父子组件间的通信。
 如上文代码所示，我们已经实现了父函数通过props这个形参向子函数传递数据——是的，相对而言，在react中，父组件通过props(规定了只能通过props传递及获取)向子组件进行数据传递。换句话讲，props这个实例属性，表面唯一的作用就是参数传值…&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;那么我们接来下要思考一个问题如何在上述代码中实现-子函数向父函数传递数据&quot;&gt;那么，我们接来下要思考一个问题，如何在上述代码中实现 子函数向父函数传递数据？&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt; 如果我们把函数玩的够熟练，那么很容易会思考到以下实现方式：&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;        function child(props){
           this.data = '我是子函数中的data'
           props.getChildData(this.data);
           this.props = props;
        }
       function parent(props){ 
           this.props = props;             
           this.dataFromChild = null;
           this.getChildData = (data)=&amp;gt;{
                console.log('这个函数被运行了，我们拿到了传过来的参数:'+data);
                this.dataFromChild = data;
           }
           this.childNodes  = new child({
                getChildData:this.getChildData
            }); 
        }
       console.log(new parent('这是一个属性'));   &lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;(别偷懒！f12，复制上述代码到控制台运行！)
好的，简单说下上述代码做出的更改： 
1  父函数中定义了一个函数，通过参数对象(实则就是props啊)传递给了子函数;
2  这个函数一旦被执行，会把参数data赋值给父函数中的实例属性data;
3  子函数通过props接收到了这个函数，运行了它，并且把自己的data作为参数传递了进去;

ok，那么我们经过运行，发现控制台打印的内容：&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1425733/201903/1425733-20190312124250879-1414392937.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;哦！！！于是我们明白了，我们写原生js的时候，就是通过：&lt;br/&gt;&lt;em&gt;在父函数中定义方法，通过参数传递给子函数，子函数调用这个方法并且把自己数据作为参数，那么父函数就可以通过形参拿到了~&lt;/em&gt;&lt;br/&gt;什么？有点绕？那么说的再简单点：&lt;br/&gt;&lt;em&gt;父函数的方法传递给子函数，被子函数传参调用。&lt;/em&gt;&lt;br/&gt;那么赶紧用内存不足的大脑思考思考react中是不是也可以啊？&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;        class Child extends React.Component{
            data =  '我是子组件中的data'
            render(){
                this.props.getChildData(this.data);
                return &amp;lt;div&amp;gt;我是Child组件&amp;lt;/div&amp;gt;
            }
        }
       class Parent extends React.Component{
            childData=null
            getChildData = (data)=&amp;gt;{
                this.childData = data;
                 console.log(data);
            }
            render(){
                return &amp;lt;Child getChildData = { this.getChildData }  /&amp;gt;
            }
        }
    console.log(&amp;lt;Parent  /&amp;gt;)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt; 上面的代码够简练了吧(比中指)！
 那么我们运行上述代码发现——乖乖，真的拿到了~~这不还是一样吗？我们玩的不是react吗？怎么成原生js 了啊？啥啊谁啊我在哪啊？？&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1425733/201903/1425733-20190312131421631-577877090.png&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; 实则所有单向数据流的js框架都可以通过上述的方式进行子组件向父组件的通信。
 非常好，现在我们来整理一下react的父子组件间通信规则： 
 *父传子：  父组件通过props传参呗……*
 *子传父 ： 父组件通过props传参呗……*
 啥？ 我写重了？ 
 (哼哼一声我露出了鄙视的微笑，并在下面多写了一行)
 ***子传父完整版： 父组件中定义函数，通过props传递给子组件，子组件调用这个函数并传参。***
嗯…经过思考，我们得出了这样一个结论： 子传父这样的逆向通信，实际也是符合单向数据流的概念。无非就是把函数当做参数传递下去而已啊！！！(重点是这句啊~~~react中的逆向通信的方式和单向数据流完全不冲突啊~)&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h3 id=&quot;子传父逆向通信的其他方式&quot;&gt;子传父(逆向通信)的其他方式&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;  除开上面讲过的 父组件中定义函数传递给子组件并被其调用 这种js通用方式，在react中我们还可以怎样玩？
  在Vue，React中都有ref 这样一个特殊的实例属性。
  react中 ref 具备两种作用： 
  1   标记dom的话，能获取dom实例;
  2    标记子组件的话，能获取子组件实例的所有数据(包括子组件的props，state，定义的方法，实例…)。
  那么也就是说，父组件通过this.ref就拿到子组件的任何数据了…就这么简单啊。
  当然，依照react的尿性，文档中特意提到了一点：不要轻易用这玩意啊，危险啊，别冲动啊小伙子们~
  事实上，经过react的版本变化，ref赋值目前有三种方式 ：  字符串、回调、 CreateRef() //这个是16.3后的新增api
  迭代维护做的都很到位啊~ 凭啥只用在表单控件里啊~
  当然，关于ref的花式玩法我们会在本系列后面内容讲到。&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h3 id=&quot;远亲组件的通信&quot;&gt;远亲组件的通信&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;  其实无论做react还是vue或者其他项目，我们必须要明确，写的还是js。(这也是为什么我一直把原生和react放在一起讲)
  那么远亲组件的通信，我们即时对react毫无了解，也能至少说出一万种方式…
 例如： 
      1   通过缓存  ：  组件A把数据存到缓存中，组件B就可以从中取出; 
      2   通过url  ：  通过location对象拿到…； 
      3   通过与后端配合： 组件A把数据扔到接口里去，组件B可以从中拿到…；
  以上方式，我称之为通过第三方媒介的形式。
  (插一句： 有木有觉得redux中store共享跟session级别缓存很类似？)
  也就是说，远亲组件的通信，我们抛开react去思考得出一个结论：
  ——通过第三方媒介作为一个存储地点，实现数据共享。
 
   ok我们把话题转回来。react中，同系远亲的话(太太爷爷到重重孙子)，完全可以通过context嘛(上一篇有讲，后面也会出context的专章)…
   至于不是很远的关系， 利用props一层一层往内传啊。 (例如爷爷传到孙子)
   
   逆向： 子调用爷爷的函数并传参就实现了子传爷爷；
   同级 ： 子1传父，父传子2 ； 
   很远关系： 1 context(自己实现试试啊~)  2 通过第三方媒介共享( 缓存，url，服务端，以及后面我们会讲到的redux，react-redux，dva等全局状态存储管理插件);
   我们发现，就单单react的话，传来传去还是 父传子 子传父啊……最多特殊情况用到context(无论多远的关系，最终肯定有个统一的祖宗啊&amp;lt;App ==!/&amp;gt;)而已啊~&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;   这章讲述了react的基础必面的面试题：
   如何在react项目中实现组件间的通信。
   也可能会引发一些react与项目与原生的思考(这是我想要的)。
   

   如果本章内容对您有帮助，请点个推荐哦~&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Tue, 12 Mar 2019 05:54:00 +0000</pubDate>
<dc:creator>散场丶丶</dc:creator>
<og:description>React 精要面试题讲解(二) 组件间通信</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sanchang/p/10516067.html</dc:identifier>
</item>
<item>
<title>ML.NET 发布0.11版本：.NET中的机器学习，为TensorFlow和ONNX添加了新功能 - 张善友</title>
<link>http://www.cnblogs.com/shanyou/p/10516224.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shanyou/p/10516224.html</guid>
<description>&lt;p&gt;&lt;span&gt;微软发布了其最新版本的机器学习框架：ML.NET 0.11带来了新功能和突破性变化。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img alt=&quot;ML.NET 0.11发布：.NET中的机器学习，具有TensorFlow和ONNX的新功能&quot; src=&quot;https://entwickler.de/wp-content/uploads/2019/03/shutterstock_1154457493-900x450.jpg&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;新版本的机器学习开源框架为TensorFlow和ONNX添加了新功能，但也包括一些重大变化, 这也是发布RC版本之前的最后一个预览版，这个月底将发布0.12版本，也就是RC1。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;ML.NET的创新0.11&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;0.11 版本的ML.NET现在还支持 TensorFlowTransformer组件中的文本输入数据。TensorFlow模型不仅可用于图像，还可用于文本分析。这在&lt;/span&gt;&lt;a href=&quot;https://devblogs.microsoft.com/dotnet/announcing-ml-net-0-11-machine-learning-for-net/&quot;&gt;&lt;span&gt;.NET博客&lt;/span&gt;&lt;/a&gt;&lt;span&gt;的代码示例中进行了说明，该&lt;/span&gt;&lt;a href=&quot;https://devblogs.microsoft.com/dotnet/announcing-ml-net-0-11-machine-learning-for-net/&quot;&gt;&lt;span&gt;博客&lt;/span&gt;&lt;/a&gt;&lt;span&gt;使用TensorFlow模型进行情感分析：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&lt;span&gt;public class TensorFlowSentiment&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;{&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;public string Sentiment_Text;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;[VectorType(600)]&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;public int[] Features;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;[VectorType(2)]&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;public float[] Prediction;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;}&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;[TensorFlowFact]&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;public void TensorFlowSentimentClassificationTest()&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;{&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;var mlContext = new MLContext(seed: 1, conc: 1);&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;var data = new[] { new TensorFlowSentiment() { Sentiment_Text = &quot;this film was just brilliant casting location scenery story direction everyone's really suited the part they played and you could just imagine being there robert  is an amazing actor and now the same being director  father came from the same scottish island as myself so i loved the fact there was a real connection with this film the witty remarks throughout the film were great it was just brilliant so much that i bought the film as soon as it was released for  and would recommend it to everyone to watch and the fly fishing was amazing really cried at the end it was so sad and you know what they say if you cry at a film it must have been good and this definitely was also  to the two little boy's that played the  of norman and paul they were just brilliant children are often left out of the  list i think because the stars that play them all grown up are such a big profile for the whole film but these children are amazing and should be praised for what they have done don't you think the whole story was so lovely because it was true and was someone's life after all that was shared with us all&quot; } };&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;var dataView = mlContext.Data.ReadFromEnumerable(data);&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;var lookupMap = mlContext.Data.ReadFromTextFile(@&quot;sentiment_model/imdb_word_index.csv&quot;,&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;columns: new[]&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;{&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;new TextLoader.Column(&quot;Words&quot;, DataKind.TX, 0),&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;new TextLoader.Column(&quot;Ids&quot;, DataKind.I4, 1),&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;},&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;separatorChar: ','&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;);&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;var estimator = mlContext.Transforms.Text.TokenizeWords(&quot;TokenizedWords&quot;, &quot;Sentiment_Text&quot;)&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;.Append(mlContext.Transforms.Conversion.ValueMap(lookupMap, &quot;Words&quot;, &quot;Ids&quot;, new[] { (&quot;Features&quot;, &quot;TokenizedWords&quot;) }));&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;var dataPipe = estimator.Fit(dataView)&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;.CreatePredictionEngine&amp;lt;TensorFlowSentiment, TensorFlowSentiment&amp;gt;(mlContext);&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;string modelLocation = @&quot;sentiment_model&quot;;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;var tfEnginePipe = mlContext.Transforms.ScoreTensorFlowModel(modelLocation, new[] { &quot;Prediction/Softmax&quot; }, new[] { &quot;Features&quot; })&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;.Append(mlContext.Transforms.CopyColumns((&quot;Prediction&quot;, &quot;Prediction/Softmax&quot;)))&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;.Fit(dataView)&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;.CreatePredictionEngine&amp;lt;TensorFlowSentiment, TensorFlowSentiment&amp;gt;(mlContext);&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;//Predict the sentiment for the sample data&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;var processedData = dataPipe.Predict(data[0]);&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;Array.Resize(ref processedData.Features, 600);&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;var prediction = tfEnginePipe.Predict(processedData);&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;}&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;还为MLContext目录添加了其他机器学习组件。这应该可以更容易地找到类和操作。该图显示了基于智能提示的用户体验。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://entwickler.de/wp-content/uploads/2019/03/mlContext2.png&quot;&gt;&lt;span&gt;&lt;img width=&quot;631&quot; height=&quot;310&quot; alt=&quot;&quot; src=&quot;https://entwickler.de/wp-content/uploads/2019/03/mlContext2.png&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;该ONNX组件还进行了重构：&lt;em&gt;Microsoft.ML.ONNX  更改为&lt;/em&gt; &lt;em&gt;Microsoft.ML.ONNXConverter&lt;/em&gt; 和&lt;em&gt;Microsoft.ML.ONNXTrans .&lt;/em&gt;&lt;em&gt;F&lt;/em&gt;&lt;em&gt;ORM更改为&lt;/em&gt;&lt;em&gt;Microsoft.ML.ONNXTransformer&lt;/em&gt; 。这更清晰的表达ONNX转换和转换之间的区别。ONNX是一种开放且可互操作的模型格式，允许您在框架中训练模型，以及在另一个框架中使用。例如：Scikit-learn 或TensorFlow 训练的模型放到 在ML.NET中使用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;与之前版本的ML.NET 0.10相比，ML.NET 0.11包含一些重大更改，包括删除&lt;em&gt;Microsoft.ML.Core&lt;/em&gt;命名空间。&lt;/span&gt;&lt;a href=&quot;https://github.com/dotnet/machinelearning-samples/blob/master/docs/migrations/breaking-changes-0.11.md&quot;&gt;破坏性性更改&lt;/a&gt; &lt;span&gt;列表已发布在GitHub上。有关ML.NET 0.11中的新功能的更详细信息参见&lt;/span&gt; &lt;a href=&quot;https://devblogs.microsoft.com/dotnet/announcing-ml-net-0-11-machine-learning-for-net/&quot;&gt;.NET博客文章：&lt;/a&gt;&lt;a title=&quot;https://devblogs.microsoft.com/dotnet/announcing-ml-net-0-11-machine-learning-for-net/&quot; href=&quot;https://devblogs.microsoft.com/dotnet/announcing-ml-net-0-11-machine-learning-for-net/&quot;&gt;https://devblogs.microsoft.com/dotnet/announcing-ml-net-0-11-machine-learning-for-net/&lt;/a&gt; &lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 12 Mar 2019 05:50:00 +0000</pubDate>
<dc:creator>张善友</dc:creator>
<og:description>微软发布了其最新版本的机器学习框架：ML.NET 0.11带来了新功能和突破性变化。新版本的机器学习开源框架为TensorFlow和ONNX添加了新功能，但也包括一些重大变化, 这也是发布RC版本之前</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shanyou/p/10516224.html</dc:identifier>
</item>
<item>
<title>彻底搞懂单例模式如何安全的实现 - 余同学的开发之路</title>
<link>http://www.cnblogs.com/YJK923/p/10516178.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/YJK923/p/10516178.html</guid>
<description>&lt;p&gt;单例设计模式，意味着整个系统中只能存在一个实例，比方说像日志对象这种。我们常说的有饿汉式和懒汉式这两种模式来创建单例对象，今天就拓展一下思维，多看几种。&lt;/p&gt;

&lt;p&gt;首先我们若是想一个类只有一个对象，那肯定先要私有化构造器，断了在其它的类中使用构造器创建实例的念头。其它的类中不能创建，我们就只能在类中自己创建一个私有实例，另外还要提供一个共有的方法使其它对象获取到实例。所以，第一版出现了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1 【饿汉式 V1】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在类加载的时候就创建实例&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
@ThreadSafe
public class SingletonExample2 {
    // 私有化构造器
    private SingletonExample2(){}
    // 提供一个实例
    private static SingletonExample2 instance = new SingletonExample2();
    // 提供共有的方法返回实例
    public static SingletonExample2 getInstance(){
        return instance;
    }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;不要忘了在多线程环境中还有关注线程是否安全，我这里都会打上注解，@ThreadSafe 表示线程安全，@NotThreadSafe 表示线程不安全。&lt;/p&gt;

&lt;p&gt;上面这种方式就是比较简单的，也是最容易想到的方式，就有一个缺点，若是不使用这个对象，那就有点浪费资源了，这个对象不一定会被使用，但是我们已经创建好了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2 【饿汉式 V2】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这种方式是借助于 &quot;静态代码块只会被加载一次&quot; 来实现单例的创建，很简单，也很好理解，问题和饿汉式一样，不一定就会使用到这个对象，所以可能会出现浪费资源的情况。&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
@ThreadSafe
public class SingletonExample6 {
    // 私有化构造器
    private SingletonExample6(){}

    private static SingletonExample6 instance = null;

    static {
        instance = new SingletonExample6();
    }
    // 提供共有的方法返回实例
    public static SingletonExample6 getInstance(){
        return instance;
    }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;3 【懒汉式 V1】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在对象使用的时候才创建实例&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
@NotThreadSafe
public class SingletonExample1 {
    // 私有化构造器
    private SingletonExample1(){}
    // 提供一个实例
    private static SingletonExample1 instance = null;
    // 提供共有的方法返回实例
    public static SingletonExample1 getInstance(){
        if(instance == null){
            return new SingletonExample1();
        }
        return instance;
    }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这种方式在单线程的时候是没有问题的，但是在多线程时就会出现问题，假如线程 A 进入 if 之后暂停执行，此时又来一个线程 B 还是可以进入 if 并返回一个实例，此时 A 再次获得执行时，返回的是另一个实例了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4 【懒汉式 V2】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在共有方法上添加 synchronized 关键字，同步该方法。可行，但是不推荐使用，因为 synchronized 修饰方法之后，在同一时刻只能有一个线程执行该方法，一旦有线程获得方法，其它线程需要等待，这样会浪费大量时间，系统运行效率降低。&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
@ThreadSafe
@NotRecommend
public class SingletonExample3 {
    // 私有化构造器
    private SingletonExample3(){}
    // 提供一个实例
    private static SingletonExample3 instance = null;
    // 提供共有的方法返回实例
    public static synchronized SingletonExample3 getInstance(){
        if(instance == null){
            return new SingletonExample3();
        }
        return instance;
    }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;5 【懒汉式 V3】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这种方式使用双重检测 + 防止指令重排的方式来保证线程安全，首先需要注意的是在 getInstance 方法中，我们需要双层检测并使用同步代码块将创建对象的过程同步起来。&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
@NotThreadSafe
public class SingletonExample4 {
    // 私有化构造器
    private SingletonExample4(){}
    // 提供一个实例
    private static SingletonExample4 instance = null;
    // 提供共有的方法返回实例
    public static SingletonExample4 getInstance(){
        // 线程 B 判断，发现 instance 不为空，直接返回，而实际上 instance 还没有初始化。
        if(instance == null){  // 双重检测机制
            synchronized (SingletonExample4.class) {  // 同步锁
                if(instance == null){
                    // 线程 A 执行到重排后的指令 3 ,此时 instance 已经有地址值了。但是没有初始化
                    return new SingletonExample4(); // 这里是重点!!
                }
            }
        }
        return instance;
    }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;因为在 new SingletonExample4() 的过程中，并不是一个原子操作，是可以进一步拆分为：&lt;/p&gt;

&lt;p&gt;1、分配对象内存空间&lt;/p&gt;
&lt;p&gt;memory = allocate()&lt;/p&gt;
&lt;p&gt;2、初始化对象&lt;/p&gt;
&lt;p&gt;initInstance()&lt;/p&gt;
&lt;p&gt;3、设置 instance 指向刚分配的内存&lt;/p&gt;
&lt;p&gt;instance = memory&lt;/p&gt;

&lt;p&gt;在多线程的情况下，上面 3 个指令会存在指令重排序的情况。【JVM 和 CPU 指令优化】重排后的结果可能为：&lt;/p&gt;

&lt;p&gt;memory = allocate()&lt;/p&gt;
&lt;p&gt;instance = memory&lt;/p&gt;
&lt;p&gt;initInstance()&lt;/p&gt;

&lt;p&gt;此时可能会存在线程 A 在内层 if 执行到指令重排后的第 3 步，但并未初始化，只是存在了地址值，线程 B 在外层 if 判断时，会直接 return 实例，而这个实例是一个只有地址值而没有被初始化的实例。&lt;/p&gt;

&lt;p&gt;为了防止指令重排带来的问题呢，我们就可以使用 volatile 关键字防止指令重排。这样就是线程安全的了。只需在上一版的基础上使用 volatile 修饰 instance 实例即可。&lt;/p&gt;

&lt;p&gt;volatile 的语义就是添加内存屏障和防止指令重排，这在前面已经分析过了。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;    &lt;span&gt;private &lt;span&gt;static &lt;span&gt;volatile SingletonExample4 instance = &lt;span&gt;null;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;6 【使用枚举类实现单例模式】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这是推荐使用的方法，因为它比懒汉式的线程安全更容易保证，比饿汉式的性能高，它只有在调用的时候才实例对象。&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
@ThreadSafe
@Recommend
public class SingletonSpecial {
    private SingletonSpecial(){}

    public static SingletonSpecial getInstance(){
        return Singleton.INSTANCE.getInstance();
    }

    private enum Singleton{
        INSTANCE;
        // public static final Singleton INSTANCE;

        private SingletonSpecial singleton;

        // JVM 来保证这个构造方法只会调用一次
        Singleton(){
            singleton = new SingletonSpecial();
        }

        public SingletonSpecial getInstance(){
            return singleton;
        }
    }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;7 【使用静态内部类】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这种方式在 Singleton 类被装载时并不会立即实例化，而是在需要实例化时，调用getInstance方法，才会加载 SingletonInstance 类，从而完成 Singleton 的实例化。&lt;/p&gt;

&lt;p&gt;使用 static final 修饰之后 JVM 就会保证 instance 只会初始化一次且不会改变。&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
@ThreadSafe
@Recommend
public class SingletonExample7 {

    private SingletonExample7(){}

    private static class SingletonInstance{
        private static final SingletonExample7 instance = new SingletonExample7();
    }

    public static SingletonExample7 getInstance(){
        return SingletonInstance.instance;
    }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;总结一下，今天主要说了单例模式的实现，并且在这中间，复习了一下前面说的线程安全的应用。若是对线程安全的原理以及实现有不懂的可以回头看看前面几篇文章。&lt;/p&gt;
</description>
<pubDate>Tue, 12 Mar 2019 05:40:00 +0000</pubDate>
<dc:creator>余同学的开发之路</dc:creator>
<og:description>单例设计模式，意味着整个系统中只能存在一个实例，比方说像日志对象这种。我们常说的有饿汉式和懒汉式这两种模式来创建单例对象，今天就拓展一下思维，多看几种。 首先我们若是想一个类只有一个对象，那肯定先要私</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/YJK923/p/10516178.html</dc:identifier>
</item>
<item>
<title>C#串口通讯概念以及简单实现 - 张子浩</title>
<link>http://www.cnblogs.com/ZaraNet/p/10510014.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ZaraNet/p/10510014.html</guid>
<description>&lt;p&gt;　　最近在研究串口通讯，其中有几个比较重要的概念，RS-232这种适配于上位机和PC端进行连接，RS-232只限于PC串口和设备间点对点的通信。它很简单的就可以进行连接，由于串口通讯是异步的，也就是说你可以同时向两端或者更多进行数据发送，它们之间的传输数据类型是byte，串口通信最重要的参数是波特率、数据位、停止位和奇偶校验。对于两个进行通信的端口，这些参数必须匹配。&lt;/p&gt;
&lt;p&gt;　　听大佬说的几个关于串口通讯的术语，啥？啥，这是啥？&lt;/p&gt;
&lt;p&gt;　　就让我这个“小白”给你说说：第一个波特率，这个东西在不同领域都有涉及，在串口通讯中两个串口之间通讯之间的信号单元叫做码元，每分钟传递的信号（码元）也就是波特率；&lt;/p&gt;
&lt;p&gt;　　第二个数据位、停止位：这个听名字就知道是啥意思了，在传递数据过程之前，机器会识别你的数据是个啥，然后根据这个类型，去调整不同的起始位、停止位。&lt;/p&gt;
&lt;p&gt;　　第三个奇偶校验：就是想知道你这个数据有多大，多长，因为传输都是1 和 0 ，具体校验方法如下：&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;奇校验：就是让原有数据序列中（包括你要加上的一位）1的个数为奇数     ----     1000110（0）你必须添0这样原来有3个1已经是奇数了所以你添上0之后1的个数还是奇数个。&lt;/p&gt;
&lt;p&gt;偶校验：就是让原有数据序列中（包括你要加上的一位）1的个数为偶数     ----      1000110（1）你就必须加1了这样原来有3个1要想1的个数为偶数就只能添1了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　如果想要在C#中玩转串口通讯或者模拟串口，你必须先搞个硬件，当然我们是在模拟，那你就弄个模拟的工具呗，这个我给大家准备好了，自己去下载吧&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;链接：https://pan.baidu.com/s/1TcdgIWMY0i9BiKVGDxnAzQ &lt;em id=&quot;__mceDel&quot;&gt;提取码：9uap &lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　安装好了之后，桌面会有图标，然后打开，添加一个串口，具体请看下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1366751/201903/1366751-20190312130319572-1826354679.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　下面我们就开始代码的实现了，创建一个.NET Fwk的 Winform 项目，然后开始我们的代码！&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
SerialPort sp1 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SerialPort();
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Form1()
        {
            InitializeComponent();
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Form1_Load(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, EventArgs e)
        {
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;[] strCom =&lt;span&gt; SerialPort.GetPortNames();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (strCom == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                MessageBox.Show(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;本机没有串口！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Error&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }&lt;/span&gt;
            &lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt; com &lt;span&gt;in&lt;/span&gt;&lt;span&gt; System.IO.Ports.SerialPort.GetPortNames())
            {
                cbCom.Items.Add(com);
            }
            cbCom.SelectedIndex &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
            sp1.BaudRate &lt;/span&gt;= &lt;span&gt;9600&lt;/span&gt;&lt;span&gt;;
            Control.CheckForIllegalCrossThreadCalls &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            sp1.DataReceived &lt;/span&gt;+=&lt;span&gt; Sp1_DataReceived;

            sp1.DtrEnable &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;;
            sp1.RtsEnable = &lt;span&gt;true&lt;/span&gt;;
            sp1.ReadTimeout = &lt;span&gt;1000&lt;/span&gt;&lt;span&gt;;
            sp1.Close();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在窗体加载中，我们尝试获取了本机的所有串口，通过 &lt;span class=&quot;cnblogs_code&quot;&gt;SerialPort.GetPortNames()&lt;/span&gt; 方法，会返回一个字符串数组，如果没有就返回null，在其中，我们还设置了波特率，通过SerialPort类下的 &lt;span class=&quot;cnblogs_code&quot;&gt;DataReceived&lt;/span&gt; 方法，来监听我们的数据回传，还启用了DTR\DTS请求方式，通过 &lt;span class=&quot;cnblogs_code&quot;&gt;ReadTimeOut&lt;/span&gt; 对数据读取超时进行了控制。　&lt;/p&gt;
&lt;p&gt; 　　既然我们监听了数据回传，那么在这个方法中，通过 &lt;span class=&quot;cnblogs_code&quot;&gt;ReadTimeOut.Read&lt;/span&gt; 进行了读取，直接从0到最后，截取完毕。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Sp1_DataReceived(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, SerialDataReceivedEventArgs e)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (sp1.IsOpen)     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断是否打开串口&lt;/span&gt;
&lt;span&gt;            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出当前时间&lt;/span&gt;
                DateTime dt =&lt;span&gt; DateTime.Now;
                txtReceived.Text &lt;/span&gt;+= dt.GetDateTimeFormats(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;f&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)[&lt;span&gt;0&lt;/span&gt;].ToString() + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
                Byte[] receivedData &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Byte[sp1.BytesToRead];        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建接收字节数组&lt;/span&gt;
                sp1.Read(receivedData, &lt;span&gt;0&lt;/span&gt;, receivedData.Length);         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;读取数据&lt;/span&gt;
                AddContent(&lt;span&gt;new&lt;/span&gt; UTF8Encoding().GetString(receivedData));&lt;span&gt;
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                MessageBox.Show(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请打开某个串口&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;错误提示&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; AddContent(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; v)
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.BeginInvoke(&lt;span&gt;new&lt;/span&gt; MethodInvoker(&lt;span&gt;delegate&lt;/span&gt;&lt;span&gt;
            {
                txtReceived.AppendText(v);
                txtReceived.AppendText(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }));
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当然以上的操作都必须在打开串口之后才能进行，打开串口这个还是比较费劲的，因为要设置各种参数，也就是我刚才说的那几个概念，如果不对，你让其他的端口来访问就找不到了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; button2_Click(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, EventArgs e)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;sp1.IsOpen)
            {
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
                { 
                    &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; serialName =&lt;span&gt; cbCom.SelectedItem.ToString();
                    sp1.PortName &lt;/span&gt;=&lt;span&gt; serialName;
                    &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; strBaudRate =&lt;span&gt; cbBaudRate.Text;
                    &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; strDateBits =&lt;span&gt; cbDataBits.Text;
                    &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; strStopBits =&lt;span&gt; cbStop.Text;
                    Int32 iBaudRate &lt;/span&gt;=&lt;span&gt; Convert.ToInt32(strBaudRate);
                    Int32 iDateBits &lt;/span&gt;=&lt;span&gt; Convert.ToInt32(strDateBits);
                    sp1.BaudRate &lt;/span&gt;= iBaudRate;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;波特率&lt;/span&gt;
                    sp1.DataBits = iDateBits;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;数据位&lt;/span&gt;
                    &lt;span&gt;switch&lt;/span&gt; (cbStop.Text)            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;停止位&lt;/span&gt;
&lt;span&gt;                    {
                        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
                            sp1.StopBits &lt;/span&gt;=&lt;span&gt; StopBits.One;
                            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1.5&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
                            sp1.StopBits &lt;/span&gt;=&lt;span&gt; StopBits.OnePointFive;
                            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
                            sp1.StopBits &lt;/span&gt;=&lt;span&gt; StopBits.Two;
                            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                        &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
                            MessageBox.Show(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Error：参数不正确!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Error&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                    }
                    &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt; (cbCheck.Text)             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;校验位&lt;/span&gt;
&lt;span&gt;                    {
                        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;无&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
                            sp1.Parity &lt;/span&gt;=&lt;span&gt; Parity.None;
                            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;奇校验&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
                            sp1.Parity &lt;/span&gt;=&lt;span&gt; Parity.Odd;
                            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;偶校验&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
                            sp1.Parity &lt;/span&gt;=&lt;span&gt; Parity.Even;
                            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                        &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
                            MessageBox.Show(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Error：参数不正确!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Error&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                    }

                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (sp1.IsOpen == &lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
                    {
                        sp1.Close();
                    }

                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置必要控件不可用&lt;/span&gt;
                    cbCom.Enabled = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                    cbBaudRate.Enabled &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                    cbDataBits.Enabled &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                    cbStop.Enabled &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                    cbCheck.Enabled &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                    sp1.Open();     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;打开串口&lt;/span&gt;
                    button2.Text = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;关闭串口&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                }
                &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (System.Exception ex)
                {
                    MessageBox.Show(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Error:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + ex.Message, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Error&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
                }
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                cbCom.Enabled &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                cbBaudRate.Enabled &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                cbDataBits.Enabled &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                cbStop.Enabled &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                cbCheck.Enabled &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                sp1.Close();                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭串口&lt;/span&gt;
                button2.Text = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;打开串口&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后也就是发送了，刚才我们接收使用Read，发送也当然很简单，是Write...&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; button1_Click(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, EventArgs e)
        {
            &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] sendData = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!sp1.IsOpen) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果没打开&lt;/span&gt;
&lt;span&gt;            {
                MessageBox.Show(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请先打开串口！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Error&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }
            String strSend &lt;/span&gt;=&lt;span&gt; txtSendStr.Text;
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                sendData &lt;/span&gt;=&lt;span&gt; Encoding.UTF8.GetBytes(txtSendStr.Text.Trim());
                sp1.Write(sendData, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;, sendData.Length);
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
            {
                MessageBox.Show(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Error:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + ex.Message, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Error&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }

        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;还是非常简单的。&lt;/p&gt;
</description>
<pubDate>Tue, 12 Mar 2019 05:27:00 +0000</pubDate>
<dc:creator>张子浩</dc:creator>
<og:description>最近在研究串口通讯，其中有几个比较重要的概念，RS-232这种适配于上位机和PC端进行连接，RS-232只限于PC串口和设备间点对点的通信。它很简单的就可以进行连接，由于串口通讯是异步的，也就是说你可</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ZaraNet/p/10510014.html</dc:identifier>
</item>
<item>
<title>上下文切换，你确定了解吗？ - 腾讯云+社区</title>
<link>http://www.cnblogs.com/qcloud1001/p/10515714.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qcloud1001/p/10515714.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;本文由云+社区发表&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;作者：cocoding&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;听到上下文切换，大家第一反应肯定是：一定要减少这货出现的次数。确实上下文切换对性能的影响显而易见，但有时又无法完全避免，这就要求我们对上下文性能损耗了然于胸，才能更准确地评估系统性能。另外，现在云厂商提供的机器种类如此之多，虚拟机在这方面是否有区别。以上都需要有科学的方法来衡量上下文的耗时，进而帮助系统评估以及机型选择。&lt;/p&gt;
&lt;p&gt;本文将从这以下两个方面来展开&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;上下文切换有哪些类型以及可能出现的场景&lt;/li&gt;
&lt;li&gt;衡量各场景上下文切换耗时&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;上下文切换类型及场景&quot;&gt;&lt;strong&gt;1， 上下文切换类型及场景&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;上下文大体上可以分为两类&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;进程上下文&lt;/li&gt;
&lt;li&gt;中断上下文&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;进程上下文具体包括：&lt;/p&gt;
&lt;p&gt;（1）用户级上下文: 正文、数据、用户堆栈以及共享存储区；&lt;/p&gt;
&lt;p&gt;（2）寄存器上下文: 通用寄存器、程序寄存器(IP)、处理器状态寄存器(EFLAGS)、栈指针(ESP)；&lt;/p&gt;
&lt;p&gt;（3）系统级上下文: 进程控制块task_struct、内存管理信息(mm_struct、vm_area_struct、pgd、pte)、内核栈。&lt;/p&gt;
&lt;p&gt;中断上下文具体包括：&lt;/p&gt;
&lt;p&gt;（1）硬件传递过来的参数&lt;/p&gt;
&lt;p&gt;因此上下文切换可以分为以下几类：&lt;/p&gt;
&lt;p&gt;（1）进程之间的上下文切换：A进程切换到B进程&lt;/p&gt;
&lt;p&gt;（2）进程和中断之间的上下文切换：进程A被中断打断&lt;/p&gt;
&lt;p&gt;（3）中断之间的上下文切换：低级别中断被高级别中断打断&lt;/p&gt;
&lt;p&gt;其中第一种上下文切换最为常见，第二种次之，第三种最少见，因此本文接下来主要讨论前面两种上下文切换的耗时。&lt;/p&gt;
&lt;h3 id=&quot;模式切换&quot;&gt;&lt;strong&gt;模式切换&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;这是要说一种特殊的上下文切换：模式切换，即进程A从用户态因为系统调用进入内核态，这种切换之所以特殊，是因为它并没有经过完整的上下文切换，只是寄存器上下文进行了切换，所以模式切换的耗时相对完整进程上下文更低。&lt;/p&gt;
&lt;p&gt;虽然模式切换较完整上下文切换耗少，但仍不能小觑，在物理机上，一次系统调用（以SYS_gettid为例）在&lt;strong&gt;50~60ns&lt;/strong&gt;。（本文所有数据均是Intel(R) Xeon(R) V4和V5 CPU上得到）而在虚拟机上，一次系统调用更是可能达到&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;240ns&lt;/strong&gt; ，从perf来看，system_call_after_swapgs函数消耗CPU较物理机多很多，&lt;a href=&quot;https://stackoverflow.com/questions/49402637/system-call-after-swapgs-where-is-my-code-spending-most-of-the-time&quot;&gt;网上&lt;/a&gt;有人说可能是为了解决Spectre漏洞，在每次系统调 用返回用户空间时，会清理一次BTB（branch target buffer），需要进一步确认。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1178126/qkyb29un5c.png?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;1.png&lt;/p&gt;
&lt;p&gt;因此，我们在代码里面也要尽量减少系统调用，常见的优化方法有：每次读写磁盘时，使用buffer减少read/write调用次数等。&lt;/p&gt;
&lt;h2 id=&quot;上下文切换性能评估&quot;&gt;&lt;strong&gt;2，上下文切换性能评估&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;测试上下文切换性能的工具有&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/kdlucas/byte-unixbench&quot;&gt;unixbench&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/tsuna/contextswitch&quot;&gt;tsuna/contextswitch&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;两个工具的原理类似，都是创建两个进程，然后互相唤醒：&lt;/p&gt;
&lt;p&gt;（1） unixbench是创建两个进程，两个进程之间创建两个管道（pipe），通过管道来互相读写数据，结果是10s内完成的切换次数。&lt;/p&gt;
&lt;p&gt;（2） contextswitch同样是创建两个进程，通过futex（快速用户区互斥）来互相唤醒，结果是循环500000次的耗时&lt;/p&gt;
&lt;h3 id=&quot;进程之间的上下文切换&quot;&gt;&lt;strong&gt;进程之间的上下文切换&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;使用这两个工具在测试进程上下文时，需要注意一点：把两个进程绑定到同一个核上运行，否则可能测试的就不仅仅是进程上下文切换了，下面会介绍不绑核的情况。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;unixbench&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;taskset -c 1 ./Run -c 1 context1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;对于contextswitch&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;taskset -c 1 ./timectxsw&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或者直接运行make或者./cpubench.sh&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1178126/5g9u244jyw.png?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;2.png&lt;/p&gt;
&lt;p&gt;从上图可以看到，一次ctx的耗时在&lt;strong&gt;1012~1263ns&lt;/strong&gt; ，但其实perf看，绑核情况下，运行timectxsw实际的ctx是在300w次（这里一次循环需要6次ctx），所以实际的ctx应该是&lt;strong&gt;674~842ns&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1178126/99blmgg4pv.png?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;3.png&lt;/p&gt;
&lt;h3 id=&quot;进程和中断上下文切换&quot;&gt;&lt;strong&gt;进程和中断上下文切换&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;上文提到如果要测试进程上下文切换耗时就一定要绑核，否则测试的很可能会包含进程和中断上下文切换的耗时，因为默认内核会把测试程序产生的进程调度到不同的核上，进程之间的唤醒，需要先发送IPI中断，对方CPU在收到IPI中断之后，会完成一次中断上下文切换，执行中断函数，进而再唤醒相应进程。所以在不绑核的情况下，测试的就包含了进程-中断上下文以及中断处理函数的耗时。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1178126/9peqpvkg4r.png?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;4.png&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;unixbench&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果使用unixbench在腾讯云上，默认调度到1个核上，这样就测试的进程上下文切换，所以需要手动修改代码绑核，或者用git上的&lt;a href=&quot;https://github.com/qcsuper/byte-unixbench&quot;&gt;unixbench-fix&lt;/a&gt;，强制将两个进程放到不同的核上&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1178126/5aonrgayuk.png?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;5.png&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;contextswitch&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;contextswitch这里还增加了在同一个NUMA上的测试，从测试数据看，两个进程如果调度到同一个NUMA上时，耗时会更短。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1178126/w1zjn1vm3q.png?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;6.png&lt;/p&gt;
&lt;p&gt;从测试数据看：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;如果两个进程跨NUMA，一次上下文切换的耗时在2500ns&lt;/li&gt;
&lt;li&gt;如果两个进程在同NUMA，一次上下文切换的耗时在1500ns&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;在虚拟机里面，跨核的上下文切换会更大，因为vcpu无法处理IPI中断，需要退出的宿主机上处理，从而增加了上下文切换的耗时，总体上虚拟机跨核ctx的耗时是宿主机的2~3倍。&lt;/p&gt;
&lt;h2 id=&quot;下一篇文章我们会对ipi中断的测试方法以及虚拟化之后可能的优化方法进行介绍欢迎订阅及时查看&quot;&gt;下一篇文章我们会对IPI中断的测试方法以及虚拟化之后可能的优化方法进行介绍，欢迎订阅，及时查看。&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1178126/ty73tmglux.png?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;此文已由腾讯云+社区在各渠道发布&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;获取更多新鲜技术干货，可以关注我们&lt;a href=&quot;https://www.zhihu.com/org/teng-xun-yun-ji-zhu-she-qu/activities&quot;&gt;腾讯云技术社区-云加社区官方号及知乎机构号&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 12 Mar 2019 03:44:00 +0000</pubDate>
<dc:creator>腾讯云+社区</dc:creator>
<og:description>本文由云+社区发表 作者：cocoding 前言 听到上下文切换，大家第一反应肯定是：一定要减少这货出现的次数。确实上下文切换对性能的影响显而易见，但有时又无法完全避免，这就要求我们对上下文性能损耗了</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qcloud1001/p/10515714.html</dc:identifier>
</item>
<item>
<title>记一次Weblogic发布Springboot遇到的坑 - cooldamon</title>
<link>http://www.cnblogs.com/cooldamon/p/10515099.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cooldamon/p/10515099.html</guid>
<description>&lt;p&gt;项目使用的是Springboot，之前直接使用JAR包的方式发布，但在客户这边实施发布的时候，客户使用的容器是weblogic，版本为 10.3.6。  痛苦就此开始！&lt;/p&gt;
&lt;p&gt;不过项目组还有另外一个也同样使用了Springboot，他们已经顺利发布了，嗯~ 再百度一下， 哈哈哈，这还不是简简单单！&lt;/p&gt;
&lt;p&gt;这个事情，随手扔给下面的技术人员搞定就ok的嘛~   结果一周过去了，跟我说项目启不来。没任何反应 。   我？？？&lt;/p&gt;
&lt;p&gt;这么简单的事情都搞不定，我要你们何用？  于是我就大发慈悲，来帮帮你们吧~   我仿佛看到了 轻轻松松搞定后，他们对我投来的崇拜目光~&lt;/p&gt;

&lt;p&gt;先把之前看到的那片文章找出来，认真研究一下。  这里感谢【&lt;a id=&quot;uid&quot; href=&quot;https://blog.csdn.net/qq_32734365&quot; target=&quot;_blank&quot;&gt;书上有云&lt;/a&gt;】的这篇文章【https://blog.csdn.net/qq_32734365/article/details/79295535】，帮助很大！&lt;/p&gt;
&lt;p&gt;简单说梳理一下思路，需要做如下事情：&lt;/p&gt;
&lt;p&gt;1、将项目web调整为 servlet 2.5 ，并在pom.xml添加对应的支持依赖；&lt;/p&gt;
&lt;p&gt;2、排除了自身的Tomcat，如果需要本地测试，则添加到provide中；&lt;/p&gt;
&lt;p&gt;3、新增web.xml， contextConfigLocation 配置启动类，新增weblogic.xml；&lt;/p&gt;
&lt;p&gt;4、启动类需要继承SpringBootServletInitializer、实现WebApplicationInitializer接口，重写configure方法；&lt;/p&gt;
&lt;p&gt;5、在pom.xml中，将打包方式从jar改成war。&lt;/p&gt;

&lt;p&gt;一切就绪，war成功编译，然而发布到weblogic，还是启动失败！  what?   肿么不对呢？&lt;/p&gt;
&lt;p&gt;只有一个醒目的错误：Caused By: java.lang.NoClassDefFoundError: javax/servlet/MultipartConfigElement&lt;/p&gt;

&lt;p&gt;回想可以先在本地用Tomcat6 试试，于是就先开始用Tomcat6本地调试一下。&lt;/p&gt;
&lt;p&gt;继续把war包扔到Tomcat的webapp下面，启动ing。。。。似乎没有反应，查看log&lt;/p&gt;
&lt;p&gt;严重: Exception sending context initialized event to listener instance of class org.springframework.boot.legacy.context.web.SpringBootContextLoaderListener&lt;br/&gt;java.lang.NoClassDefFoundError: javax/servlet/MultipartConfigElement&lt;/p&gt;

&lt;p&gt;棒棒哒！ 最起码问题复现了，其实这个问题好解决，Springboot默认版本是3.0，在pom.xml中添加 servlet的包，变成2.5 就行了。  ok！ 问题1消灭！！！&lt;/p&gt;
&lt;p&gt;重新打包，Tomcat完美运行，美滋滋~&lt;/p&gt;

&lt;p&gt;再次扔到weblogic上面，又出来一个新的玩意：&lt;/p&gt;
&lt;p&gt;Caused By:java.lang.ClassNotFoundException: org.osjava.sj.SimpleContextFactory&lt;/p&gt;

&lt;p&gt;这是什么鬼？ 似乎没见过呀，百度一下，似乎就一个人提到这个问题，回答的也是敷衍没实质作用。&lt;/p&gt;
&lt;p&gt;嗯，还出了一个问题，weblogic控制台没法进了。登录就弹出这个提示：&lt;/p&gt;
&lt;p&gt;已禁用所需的MBean服务器，这将阻止WebLogic管理控制台的正常操作，&lt;/p&gt;
&lt;p&gt;请在该域的配置中启用 DomainRuntimeMBean 服务器和 Edit MBean 服务器。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1197471/201903/1197471-20190312110608346-1191237112.png&quot; alt=&quot;&quot; width=&quot;812&quot; height=&quot;154&quot;/&gt;&lt;/p&gt;
&lt;p&gt;氮素，我重启Weblogic服务后，居然神奇的可以访问到项目了，这是什么骚操作。 一脸懵逼zzz？&lt;/p&gt;

&lt;p&gt;可是这个问题不正常呀，清理到应用，重启WebLogic，控制台又能顺利进去了，再发布应用，却怎么也启不来。就开始不停地：&lt;/p&gt;
&lt;p&gt;Caused By:java.lang.ClassNotFoundException: org.osjava.sj.SimpleContextFactory&lt;/p&gt;
&lt;p&gt;于是就只能回归项目代码了，应该是代码里面写了什么或者用了什么神奇的东西。 &lt;/p&gt;
&lt;p&gt;找到了这个类，原来是 simple-jndi jar包， 项目里面用kettle来实现数据同步，方便调整数据库，便用到了这个jar包，采用jndi方式配置数据源。&lt;/p&gt;

&lt;p&gt;新的曙光已经出现，怎么能够停滞不前！  这个问题来来回回折腾好几天了，是时候把它解决了！&lt;/p&gt;
&lt;p&gt;又研究半天代码，发现网上在写kettle使用jndi方式里面，用的System的属性定义， 感觉就是这个鬼了。&lt;/p&gt;
&lt;p&gt; System.setProperty(&quot;java.naming.factory.initial&quot;, &quot;org.osjava.sj.SimpleContextFactory&quot;);&lt;/p&gt;
&lt;p&gt;然后又去找了一下Java调用 WebLogic的JNDI，不同的容器使用的Context.INITIAL_CONTEXT_FACTORY是不一样的，Weblogic需要用到如下：&lt;/p&gt;
&lt;p&gt;System.setProperty(&quot;java.naming.factory.initial&quot;,   &quot;weblogic.jndi.WLInitialContextFactory&quot;);&lt;/p&gt;
&lt;p&gt;这样，一切都明朗了！  我只需要配置weblogic的jndi，并且把simple-jndi的替换掉就OK了。&lt;/p&gt;
&lt;p&gt;调整完毕，配置好JNDI，再部署应用，到此结束！ &lt;/p&gt;

&lt;p&gt;其实，只要认真仔细分析，问题都有解决的办法！  有相同或类似问题，欢迎留言探讨~&lt;/p&gt;
</description>
<pubDate>Tue, 12 Mar 2019 03:34:00 +0000</pubDate>
<dc:creator>cooldamon</dc:creator>
<og:description>项目使用的是Springboot，之前直接使用JAR包的方式发布，但在客户这边实施发布的时候，客户使用的容器是weblogic，版本为 10.3.6。 痛苦就此开始！ 不过项目组还有另外一个也同样使用</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cooldamon/p/10515099.html</dc:identifier>
</item>
</channel>
</rss>