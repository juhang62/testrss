<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Kubernetes 网络排错指南 - 民工哥</title>
<link>http://www.cnblogs.com/youkanyouxiao/p/10267067.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/youkanyouxiao/p/10267067.html</guid>
<description>&lt;p&gt;本文介绍各种常见的网络问题以及排错方法，包括 Pod 访问异常、Service 访问异常以及网络安全策略异常等。&lt;/p&gt;
&lt;p&gt;说到 Kubernetes 的网络，其实无非就是以下三种情况之一&lt;/p&gt;
&lt;p&gt;当然，以上每种情况还都分别包括本地访问和跨主机访问两种场景，并且一般情况下都是通过 Service 间接访问 Pod。&lt;/p&gt;
&lt;p&gt;排查网络问题基本上也是从这几种情况出发，定位出具体的网络异常点，再进而寻找解决方法。网络异常可能的原因比较多，常见的有：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CNI 网络插件配置错误，导致多主机网络不通，比如&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;list-paddingleft-2&quot;&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;IP 网段与现有网络冲突&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;插件使用了底层网络不支持的协议&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;忘记开启 IP 转发等&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Pod 网络路由丢失，比如&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;list-paddingleft-2&quot;&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;kubenet 要求网络中有 podCIDR 到主机 IP 地址的路由，这些路由如果没有正确配置会导致 Pod 网络通信等问题&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;在公有云平台上，kube-controller-manager 会自动为所有 Node 配置路由，但如果配置不当（如认证授权失败、超出配额等），也有可能导致无法配置路由&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;

&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt;&lt;strong&gt;Flannel Pods 一直处于 Init:CrashLoopBackOff 状态&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;Flannel 网络插件非常容易部署，只要一条命令即可&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;kubectl apply -f &lt;span&gt;https:/&lt;span&gt;/raw.githubusercontent.com/coreos&lt;span&gt;/flannel/master&lt;span&gt;/Documentation/kube-flannel.ymlubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然而，部署完成后，Flannel Pod 有可能会碰到初始化失败的错误&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ kubectl -n kube-&lt;span&gt;system &lt;span&gt;get pod&lt;br/&gt;NAME                  READY     STATUS             RESTARTS   AGE&lt;br/&gt;kube-flannel-&lt;span&gt;ds-ckfdc  &lt;span&gt;0/&lt;span&gt;1   Ini&lt;span&gt;t:CrashLoopBackOff   &lt;span&gt;4         &lt;span&gt;2&lt;span&gt;m&lt;br/&gt;kube-flannel-&lt;span&gt;ds-jpp96  &lt;span&gt;0/&lt;span&gt;1   Ini&lt;span&gt;t:CrashLoopBackOff   &lt;span&gt;4         &lt;span&gt;2&lt;span&gt;m&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查看日志会发现&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ kubectl -n kube-&lt;span&gt;system logs kube-flannel-&lt;span&gt;ds-jpp96 -&lt;span&gt;c install-cni&lt;br/&gt;&lt;span&gt;cp: can&lt;span&gt;'t create '/etc/cni/net.d/&lt;span&gt;10-flannel.conflist&lt;span&gt;': Permission denied&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这一般是由于 SELinux 开启导致的，关闭 SELinux 既可解决。有两种方法：&lt;/p&gt;
&lt;h2&gt;Pod 无法解析 DNS&lt;/h2&gt;
&lt;p&gt;如果 Node 上安装的 Docker 版本大于 1.12，那么 Docker 会把默认的 iptables FORWARD 策略改为 DROP。这会引发 Pod 网络访问的问题。解决方法则在每个 Node 上面运行 &lt;code&gt;iptables -P FORWARD ACCEPT&lt;/code&gt;，比如&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span&gt;echo &lt;span&gt;&quot;ExecStartPost=/sbin/iptables -P FORWARD ACCEPT&quot; &amp;gt;&amp;gt; /etc/systemd/&lt;span&gt;system/docker.service.d/exec_start.&lt;span&gt;conf&lt;br/&gt;systemctl daemon-reload&lt;br/&gt;systemctl restart docker&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果使用了 flannel/weave 网络插件，更新为最新版本也可以解决这个问题。&lt;/p&gt;
&lt;p&gt;DNS 无法解析也有可能是 kube-dns 服务异常导致的，可以通过下面的命令来检查 kube-dns 是否处于正常运行状态&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ kubectl &lt;span&gt;get pods --&lt;span&gt;namespace=kube-system -l k8s-app=kube-dns&lt;br/&gt;NAME               READY     STATUS    RESTARTS   AGE&lt;br/&gt;...&lt;br/&gt;kube-dns-v19-ezo1y  &lt;span&gt;3/&lt;span&gt;3       Running   &lt;span&gt;0           &lt;span&gt;1h&lt;br/&gt;...&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果 kube-dns 处于 CrashLoopBackOff 状态，那么可以参考 Kube-dns/Dashboard CrashLoopBackOff 排错 来查看具体排错方法。&lt;/p&gt;
&lt;p&gt;如果 kube-dns Pod 处于正常 Running 状态，则需要进一步检查是否正确配置了 kube-dns 服务：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ kubectl &lt;span&gt;get svc kube-dns --namespace=kube-&lt;span&gt;system&lt;br/&gt;NAME      CLUSTER-IP   EXTERNAL-IP   PORT(S)        AGE&lt;br/&gt;kube-dns  &lt;span&gt;10.0.&lt;span&gt;0.10    &lt;span&gt;&amp;lt;none&amp;gt;     &lt;span&gt;53/UDP,&lt;span readability=&quot;2&quot;&gt;53/TCP     &lt;span readability=&quot;4&quot;&gt;1h&lt;p&gt;$ kubectl &lt;span&gt;get ep kube-dns --namespace=kube-&lt;span&gt;system&lt;br/&gt;NAME       ENDPOINTS                       AGE&lt;br/&gt;kube-dns   &lt;span&gt;10.180.&lt;span&gt;3.17:&lt;span&gt;53,&lt;span&gt;10.180.&lt;span&gt;3.17:&lt;span&gt;53    &lt;span&gt;1h&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果 kube-dns service 不存在，或者 endpoints 列表为空，则说明 kube-dns service 配置错误，可以重新创建 kube-dns service，比如&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;apiVersion: v1
kind: Service
metadata:
 name: kube-dns
 namespace: kube-system
 labels:
   k8s-app: kube-dns
   kubernetes.io/cluster-service: &quot;true&quot;
   kubernetes.io/name: &quot;KubeDNS&quot;
spec:
 selector:
   k8s-app: kube-dns
 clusterIP: 10.0.0.10
 ports:
 - name: dns
   port: 53
   protocol: UDP
 - name: dns-tcp
   port: 53
   protocol: TCP&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;Service 无法访问&lt;/h2&gt;
&lt;p&gt;访问 Service ClusterIP 失败时，可以首先确认是否有对应的 Endpoints&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;kubectl get endpoints &amp;lt;service-name&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果该列表为空，则有可能是该 Service 的 LabelSelector 配置错误，可以用下面的方法确认一下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 查询 Service 的 LabelSelector
kubectl get svc &amp;lt;service-name&amp;gt; -o jsonpath='{.spec.selector}'
# 查询匹配 LabelSelector 的 Pod
kubectl get pods -l key1=value1,key2=value2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果 Endpoints 正常，可以进一步检查&lt;/p&gt;
&lt;p&gt;再进一步，即使上述配置都正确无误，还有其他的原因会导致 Service 无法访问，比如&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Pod 内的容器有可能未正常运行或者没有监听在指定的 containerPort 上&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;CNI 网络或主机路由异常也会导致类似的问题&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;kube-proxy 服务有可能未启动或者未正确配置相应的 iptables 规则，比如正常情况下名为 &lt;code&gt;hostnames&lt;/code&gt;的服务会配置以下 iptables 规则&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;$ iptables-save | grep hostnames&lt;br/&gt;-A KUBE-SEP-57KPRZ3JQVENLNBR -s 10.244.3.6/32 -m &lt;span&gt;comment &lt;span&gt;--comment &quot;default/hostnames:&quot; -j MARK --set-xmark 0x00004000/0x00004000&lt;br/&gt;-A KUBE-SEP&lt;span&gt;-57KPRZ3JQVENLNBR -p tcp -m &lt;span&gt;comment &lt;span&gt;--comment &quot;default/hostnames:&quot; -m tcp -j DNAT --to-destination 10.244.3.6:9376&lt;br/&gt;-A KUBE-SEP-WNBA2IHDGP2BOBGZ -s &lt;span&gt;10.244&lt;span&gt;.1.7/&lt;span&gt;32 -m &lt;span&gt;comment &lt;span&gt;--comment &quot;default/hostnames:&quot; -j MARK --set-xmark 0x00004000/0x00004000&lt;br/&gt;-A KUBE-SEP-WNBA2IHDGP2BOBGZ -p tcp -m &lt;span&gt;comment &lt;span&gt;--comment &quot;default/hostnames:&quot; -m tcp -j DNAT --to-destination 10.244.1.7:9376&lt;br/&gt;-A KUBE-SEP-X3P2623AGDH6CDF3 -s &lt;span&gt;10.244&lt;span&gt;.2.3/&lt;span&gt;32 -m &lt;span&gt;comment &lt;span&gt;--comment &quot;default/hostnames:&quot; -j MARK --set-xmark 0x00004000/0x00004000&lt;br/&gt;-A KUBE-SEP-X3P2623AGDH6CDF3 -p tcp -m &lt;span&gt;comment &lt;span&gt;--comment &quot;default/hostnames:&quot; -m tcp -j DNAT --to-destination 10.244.2.3:9376&lt;br/&gt;-A KUBE-SERVICES -d &lt;span&gt;10.0&lt;span&gt;.1&lt;span&gt;.175/&lt;span&gt;32 -p tcp -m &lt;span&gt;comment &lt;span&gt;--comment &quot;default/hostnames: cluster IP&quot; -m tcp --dport 80 -j KUBE-SVC-NWV5X2332I4OT4T3&lt;br/&gt;-A KUBE-SVC-NWV5X2332I4OT4T3 -m &lt;span&gt;comment &lt;span&gt;--comment &quot;default/hostnames:&quot; -m statistic --mode random --probability 0.33332999982 -j KUBE-SEP-WNBA2IHDGP2BOBGZ&lt;br/&gt;-A KUBE-SVC-NWV5X2332I4OT4T3 -m &lt;span&gt;comment &lt;span&gt;--comment &quot;default/hostnames:&quot; -m statistic --mode random --probability 0.50000000000 -j KUBE-SEP-X3P2623AGDH6CDF3&lt;br/&gt;-A KUBE-SVC-NWV5X2332I4OT4T3 -m &lt;span&gt;comment &lt;span&gt;--comment &quot;default/hostnames:&quot; -j KUBE-SEP-57KPRZ3JQVENLNBR&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;Pod 无法通过 Service 访问自己&lt;/h2&gt;
&lt;p&gt;这通常是 hairpin 配置错误导致的，可以通过 Kubelet 的 &lt;code&gt;--hairpin-mode&lt;/code&gt; 选项配置，可选参数包括 &quot;promiscuous-bridge&quot;、&quot;hairpin-veth&quot; 和 &quot;none&quot;（默认为&quot;promiscuous-bridge&quot;）。&lt;/p&gt;
&lt;p&gt;对于 hairpin-veth 模式，可以通过以下命令来确认是否生效&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ for intf in /sys/devices/virtual/net/cbr0/brif/*; do cat $intf/hairpin_mode; done
1
1
1
1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而对于 promiscuous-bridge 模式，可以通过以下命令来确认是否生效&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ ifconfig cbr0 |grep PROMISC
UP BROADCAST RUNNING PROMISC MULTICAST  MTU:1460  Metric:1&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;无法访问 Kubernetes API&lt;/h2&gt;
&lt;p&gt;很多扩展服务需要访问 Kubernetes API 查询需要的数据（比如 kube-dns、Operator 等）。通常在 Kubernetes API 无法访问时，可以首先通过下面的命令验证 Kubernetes API 是正常的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ kubectl run curl  --image=appropriate/curl -i -t  --restart=Never --command -- sh&lt;br/&gt;If you don't see a command prompt, &lt;span&gt;try pressing enter.&lt;br/&gt;/ #&lt;br/&gt;/ # KUBE_TOKEN=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)&lt;br/&gt;/ # curl -sSk -H &lt;span&gt;&quot;Authorization: Bearer $KUBE_TOKEN&quot; https:&lt;span&gt;//$KUBERNETES_SERVICE_HOST:$KUBERNETES_SERVICE_PORT/api/v1/namespaces/default/pods&lt;br/&gt;{&lt;br/&gt;&lt;span&gt;&quot;kind&quot;: &lt;span&gt;&quot;PodList&quot;,&lt;br/&gt;&lt;span&gt;&quot;apiVersion&quot;: &lt;span&gt;&quot;v1&quot;,&lt;br/&gt;&lt;span&gt;&quot;metadata&quot;: {&lt;br/&gt;&lt;span&gt;&quot;selfLink&quot;: &lt;span&gt;&quot;/api/v1/namespaces/default/pods&quot;,&lt;br/&gt;&lt;span&gt;&quot;resourceVersion&quot;: &lt;span&gt;&quot;2285&quot;&lt;br/&gt;},&lt;br/&gt;&lt;span&gt;&quot;items&quot;: [&lt;br/&gt;...&lt;br/&gt;]&lt;br/&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果出现超时错误，则需要进一步确认名为 &lt;code&gt;kubernetes&lt;/code&gt; 的服务以及 endpoints 列表是正常的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ kubectl get service kubernetes
NAME         TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE
kubernetes   ClusterIP   10.96.0.1    &amp;lt;none&amp;gt;        443/TCP   25m
$ kubectl get endpoints kubernetes
NAME         ENDPOINTS          AGE
kubernetes   172.17.0.62:6443   25m&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后可以直接访问 endpoints 查看 kube-apiserver 是否可以正常访问。无法访问时通常说明 kube-apiserver 未正常启动，或者有防火墙规则阻止了访问。&lt;/p&gt;
&lt;p&gt;但如果出现了 &lt;code&gt;403 - Forbidden&lt;/code&gt; 错误，则说明 Kubernetes 集群开启了访问授权控制（如 RBAC），此时就需要给 Pod 所用的 ServiceAccount 创建角色和角色绑定授权访问所需要的资源。比如 CoreDNS 就需要创建以下 ServiceAccount 以及角色绑定：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span&gt;# 1. service account&lt;br/&gt;&lt;span&gt;apiVersion: v1&lt;br/&gt;&lt;span&gt;kind: ServiceAccount&lt;br/&gt;&lt;span&gt;metadata:&lt;br/&gt;name: coredns&lt;br/&gt;namespace: kube-system&lt;br/&gt;labels:&lt;br/&gt;kubernetes.io/cluster-service: &lt;span&gt;&quot;true&quot;&lt;br/&gt;addonmanager.kubernetes.io/mode: Reconcile&lt;br/&gt;---&lt;br/&gt;&lt;span&gt;# 2. cluster role&lt;br/&gt;&lt;span&gt;apiVersion: rbac.authorization.k8s.io/v1&lt;br/&gt;&lt;span&gt;kind: ClusterRole&lt;br/&gt;&lt;span&gt;metadata:&lt;br/&gt;labels:&lt;br/&gt;kubernetes.io/bootstrapping: rbac-defaults&lt;br/&gt;addonmanager.kubernetes.io/mode: Reconcile&lt;br/&gt;name: system:coredns&lt;br/&gt;&lt;span&gt;rules:&lt;br/&gt;- apiGroups:&lt;br/&gt;- &lt;span&gt;&quot;&quot;&lt;br/&gt;resources:&lt;br/&gt;- endpoints&lt;br/&gt;- services&lt;br/&gt;- pods&lt;br/&gt;- namespaces&lt;br/&gt;verbs:&lt;br/&gt;- list&lt;br/&gt;- watch&lt;br/&gt;---&lt;br/&gt;&lt;span&gt;# 3. cluster role binding&lt;br/&gt;&lt;span&gt;apiVersion: rbac.authorization.k8s.io/v1&lt;br/&gt;&lt;span&gt;kind: ClusterRoleBinding&lt;br/&gt;&lt;span&gt;metadata:&lt;br/&gt;annotations:&lt;br/&gt;rbac.authorization.kubernetes.io/autoupdate: &lt;span&gt;&quot;true&quot;&lt;br/&gt;labels:&lt;br/&gt;kubernetes.io/bootstrapping: rbac-defaults&lt;br/&gt;addonmanager.kubernetes.io/mode: EnsureExists&lt;br/&gt;name: system:coredns&lt;br/&gt;&lt;span&gt;roleRef:&lt;br/&gt;apiGroup: rbac.authorization.k8s.io&lt;br/&gt;kind: ClusterRole&lt;br/&gt;name: system:coredns&lt;br/&gt;&lt;span&gt;subjects:&lt;br/&gt;- kind: ServiceAccount&lt;br/&gt;name: coredns&lt;br/&gt;namespace: kube-system&lt;br/&gt;---&lt;br/&gt;&lt;span&gt;# 4. use created service account&lt;br/&gt;&lt;span&gt;apiVersion: extensions/v1beta1&lt;br/&gt;&lt;span&gt;kind: Deployment&lt;br/&gt;&lt;span&gt;metadata:&lt;br/&gt;name: coredns&lt;br/&gt;namespace: kube-system&lt;br/&gt;labels:&lt;br/&gt;k8s-app: coredns&lt;br/&gt;kubernetes.io/cluster-service: &lt;span&gt;&quot;true&quot;&lt;br/&gt;addonmanager.kubernetes.io/mode: Reconcile&lt;br/&gt;kubernetes.io/name: &lt;span&gt;&quot;CoreDNS&quot;&lt;br/&gt;&lt;span&gt;spec:&lt;br/&gt;replicas: 2&lt;br/&gt;selector:&lt;br/&gt;matchLabels:&lt;br/&gt;k8s-app: coredns&lt;br/&gt;template:&lt;br/&gt;metadata:&lt;br/&gt;labels:&lt;br/&gt;k8s-app: coredns&lt;br/&gt;spec:&lt;br/&gt;serviceAccountName: coredns&lt;br/&gt;...&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;原文链接：&lt;/p&gt;
&lt;p&gt;https://zhuanlan.zhihu.com/p/34558421&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;看到这里，相信很多小伙伴也已经了解了K8S常见的网络问题及排错方法，其实，对于任何一门技术点的学习，其理论基础的掌握是第一步，继而实践操作是第二步，然后再自我总结方可全面掌握，那么，今天民工哥给大家带来好书福利了，且看下面的精彩介绍。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;送书福利：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;今天给大家带来的是由马哥教育的创始人、CEO马哥亲自操刀撰写的又一巨作，渐进式讲解，手把手示范 ，大量实操案例，随时动手验证 是本书的特色。&lt;/p&gt;
&lt;p&gt;本书致力于帮助容器编排技术的初级和中级用户循序渐进地理解与使用Kubernetes系统，因此本书的编写充分考虑到初学者进入新知识领域时的茫然，采用由浅入深、提纲挈领、再由点到面的方式讲解每一个知识细节。 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/tuSaKc6SfPoBXAd0G0XB03lftlaLUpibJwTHkGPibRMEoM5VEfBKgQ3gPhUicZM78UfmYYoyw3hIibuQGqMVK80vhQ/640?wx_fmt=png&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;1.085144927536232&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/tuSaKc6SfPoBXAd0G0XB03lftlaLUpibJwTHkGPibRMEoM5VEfBKgQ3gPhUicZM78UfmYYoyw3hIibuQGqMVK80vhQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;552&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;划重点：此次一共送出5本书，重点是好书+&lt;/strong&gt;&lt;strong&gt;马哥亲笔签名&lt;/strong&gt;&lt;strong&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;送书规则：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、仅限公众号读者参与，活动截止时间&lt;strong&gt;2019年1月17号12:30&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;2、留言分享你在&lt;strong&gt;学习K8S中的趣事、踩过的坑或需要此书的理由&lt;/strong&gt;，在精选留言中随机抽取&lt;strong&gt;2名留言最走心&lt;/strong&gt;的读者各送一本。&lt;/p&gt;
&lt;p&gt;3、在精选留言中随机抽取&lt;strong&gt;1名一直支持、关注&lt;/strong&gt;公众号的读者各送出一本。&lt;/p&gt;
&lt;p&gt;4、新规则：从&lt;strong&gt;点文章后面“好看”的读者中 [ &lt;/strong&gt;小技巧先加民工哥微信好友再点好看可以大大提高中奖率哦，一般人我不告诉他 &lt;strong&gt;] 随机抽取2名&lt;/strong&gt;名送出一本。&lt;/p&gt;
&lt;p&gt;5、所有中奖者会在活动结束后【&lt;strong&gt;1月18号推文中&lt;/strong&gt;】&lt;strong&gt;公布中奖者名单&lt;/strong&gt;，请中奖者于一个工作日内&lt;strong&gt;加民工哥微信ken_chu1985&lt;/strong&gt;，发送详细收货地址 [ 格式：姓名+联系方式+详细地址 ]，逾期视为放弃。&lt;/p&gt;
&lt;p&gt;最后，没能获奖的小伙伴也不要灰心哦，《Kubernetes进阶实战》现已上架京东，扫描二维码即可享受&lt;strong&gt;8.2折&lt;/strong&gt;价格购买！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/tuSaKc6SfPoBXAd0G0XB03lftlaLUpibJKJ11YDCTZWposYSwPbTbe4QDib5RJSeqzCZDNKaPK58gubAPzMTyxFA/640?wx_fmt=png&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/tuSaKc6SfPoBXAd0G0XB03lftlaLUpibJKJ11YDCTZWposYSwPbTbe4QDib5RJSeqzCZDNKaPK58gubAPzMTyxFA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;260&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;- MORE | 往期精彩文章 -&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;如果你喜欢本文&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;请长按二维码关注&lt;/strong&gt;&lt;strong&gt;民工哥技术之路&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/tuSaKc6SfPria1cKL66Pc1sJlVK9hzIbQzpsC28YMFgQosWDibUEXGL9skdseEgPSsAke5lsicGFd5ibT0WIlkb7pQ/640?tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;&quot; width=&quot;auto&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.5555555555555556&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;900&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/tuSaKc6SfPria1cKL66Pc1sJlVK9hzIbQzpsC28YMFgQosWDibUEXGL9skdseEgPSsAke5lsicGFd5ibT0WIlkb7pQ/640?&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;转发朋友圈，是对我最大的支持。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/tuSaKc6SfPoHDJbPz3g7Kic6hdYnbBc4ZbJibyMQdYLkCn94rGc9DibFv4PMvhCFOfkuSKZRR3MeJo6uuUWz5jx5Q/640?tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/tuSaKc6SfPoHDJbPz3g7Kic6hdYnbBc4ZDRQqHeFmr1ZMibl4PjJkBUqfiaX3EaIxPvC7ic4vJPtUzDYEGdgzgw35g/0?wx_fmt=png&quot; data-cropx1=&quot;447.4429824561404&quot; data-cropx2=&quot;695.1622807017544&quot; data-cropy1=&quot;0&quot; data-cropy2=&quot;249.26754385964912&quot; data-ratio=&quot;1.0040322580645162&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;248&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/tuSaKc6SfPoHDJbPz3g7Kic6hdYnbBc4ZbJibyMQdYLkCn94rGc9DibFv4PMvhCFOfkuSKZRR3MeJo6uuUWz5jx5Q/640?&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;扫码加群交流&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 14 Jan 2019 07:31:00 +0000</pubDate>
<dc:creator>民工哥</dc:creator>
<og:description>本文介绍各种常见的网络问题以及排错方法，包括 Pod 访问异常、Service 访问异常以及网络安全策略异常等。 说到 Kubernetes 的网络，其实无非就是以下三种情况之一 Pod 访问容器外部</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/youkanyouxiao/p/10267067.html</dc:identifier>
</item>
<item>
<title>SSE图像算法优化系列二十六:和时间赛跑之优化高斯金字塔建立的计算过程。 - Imageshop</title>
<link>http://www.cnblogs.com/Imageshop/p/10263676.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Imageshop/p/10263676.html</guid>
<description>&lt;p&gt;&lt;span&gt;　　图像金字塔技术在很多层面上都有着广泛的应用，很多开源的工具也都有对他们的建立写了专门的函数，比如IPP，比如OpenCV等等，这方面的理论文章特别多，我不需要赘述，但是我发现大部多分开源的代码的实现都不是严格意义上的金字塔，而是做了一定的变通，这种变通常常为了快捷的实现类似的效果，虽然这种变通不太会影响金字塔的效果，但是我这里希望从严格意义上对该算法进行优化，比如简要贴一下下面的某个高斯金字塔的代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Mat[] build(Mat img, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; level) {
        Mat[] gaussPyr &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Mat[level];
        Mat mask &lt;/span&gt;=&lt;span&gt; filterMask(img);
        Mat tmp &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Mat();
        Imgproc.filter2D(img, tmp, &lt;/span&gt;-1&lt;span&gt;, mask);
        gaussPyr[&lt;/span&gt;0] =&lt;span&gt; tmp.clone();
        Mat tmpImg &lt;/span&gt;=&lt;span&gt; img.clone();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 1; i &amp;lt; level; i++&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; resize image&lt;/span&gt;
            Imgproc.resize(tmpImg, tmpImg, &lt;span&gt;new&lt;/span&gt; Size(), 0.5, 0.5&lt;span&gt;, Imgproc.INTER_LINEAR);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; blur image&lt;/span&gt;
            tmp = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Mat();
            Imgproc.filter2D(tmpImg, tmp, &lt;/span&gt;-1&lt;span&gt;, mask);
            gaussPyr[i] &lt;/span&gt;=&lt;span&gt; tmp.clone();
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; gaussPyr;
    }
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Mat filterMask(Mat img) {
        &lt;/span&gt;&lt;span&gt;double&lt;/span&gt;[] h = { 1.0 / 16.0, 4.0 / 16.0, 6.0 / 16.0, 4.0 / 16.0, 1.0 / 16.0&lt;span&gt; };
        Mat mask &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Mat(h.length, h.length, img.type());
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; h.length; i++&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = 0; j &amp;lt; h.length; j++&lt;span&gt;) {
                mask.put(i, j, h[i] &lt;/span&gt;*&lt;span&gt; h[j]);
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; mask;
    }&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　上面的过程是对原图线进行双线性的下采样插值，然后再对采样后的图进行一定的高斯模糊。我们说这样做未尝不可，而真正的高斯金字塔的建立过程是：对上一级的数据进行高斯模糊（5x5)得到结果T，然后删除T的奇数行和奇数列数据作为下一级的结果（以0为下标起点的行列）。在此过程中使用到的高斯模糊的权重矩阵的形式如下所示：  &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        &lt;img src=&quot;https://img2018.cnblogs.com/blog/349293/201901/349293-20190113195551329-1072863504.png&quot; alt=&quot;&quot; width=&quot;450&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　应该说，上面的过程用伪代码表示应该是:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Imgproc.filter2D(tmpImg, tmp, -1&lt;span&gt;, mask);
Imgproc.resize(tmp, tmp, &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Size(), 0.5, 0.5, Imgproc.INTER_NEARESTNEIGHBOR);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;　即先高斯模糊，然后在使用最近领插值缩小一半，和上面代码中的先双性缩小一半，再进行高斯模糊还是有区别的。&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;  　从编程优化的角度考虑，我们没有必要完整的对上一级进行高斯模糊，而只需要进行偶数行和偶数列的计算，然后赋值到下一层数据中，而进一步考虑上述矩阵的特殊性，可以通过减少重复计算以及合并相同系数项等手段来优化。对于边缘（2行2列）的像素，把他单独提取出来，减少中间数据的边缘判断可进一步提高速度。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　再提出第一版C语言代码之前，我们来要看下各层金字塔的大小问题，如果上一层的大小位偶数，则下一层直接就除以2，但是如果是奇数，则除2时需要向上取整，比如宽某层的宽度尺寸为101，则之后的各层依次为101-&amp;gt;51-&amp;gt;26-&amp;gt;13-&amp;gt;7-&amp;gt;4-&amp;gt;2-&amp;gt;1。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　再看看前面权重矩阵的式子最右边那个乘法，那表示这个权重矩阵是行列可分离的，我们可以先计算行的加权，然后再利用这个加权值计算列的加权，也可以先计算列然后再计算行，这样原本每个像素处的25个乘法和多24次加法就可以减少为10次乘法和9次加法。对于沿着宽度方向的更新计算，我们还可以充分利用列方向的重叠累计信息，减少计算量，一个可行的简单的代码如下所示：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;87&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;int&lt;/span&gt; IM_DownSample8U_C1(unsigned &lt;span&gt;char&lt;/span&gt; *Src, unsigned &lt;span&gt;char&lt;/span&gt; *Dest, &lt;span&gt;int&lt;/span&gt; SrcW, &lt;span&gt;int&lt;/span&gt; SrcH, &lt;span&gt;int&lt;/span&gt; StrideS, &lt;span&gt;int&lt;/span&gt; DstW, &lt;span&gt;int&lt;/span&gt; DstH, &lt;span&gt;int&lt;/span&gt; StrideD, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; Channel)
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((Channel != &lt;span&gt;1&lt;/span&gt;) &amp;amp;&amp;amp; (Channel != &lt;span&gt;3&lt;/span&gt;) &amp;amp;&amp;amp; (Channel != &lt;span&gt;4&lt;/span&gt;))        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; IM_STATUS_NOTSUPPORTED;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (DstW != ((SrcW + &lt;span&gt;1&lt;/span&gt;) &amp;gt;&amp;gt; &lt;span&gt;1&lt;/span&gt;) || DstH != ((SrcH + &lt;span&gt;1&lt;/span&gt;) &amp;gt;&amp;gt; &lt;span&gt;1&lt;/span&gt;)) &lt;span&gt;return&lt;/span&gt; IM_STATUS_INVALIDPARAMETER;            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    尺寸匹配&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; Status =&lt;span&gt; IM_STATUS_OK;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (Channel == &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; Sum1, Sum2, Sum3, Sum4, Sum5;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; Y = &lt;span&gt;1&lt;/span&gt;; Y &amp;lt; DstH - &lt;span&gt;1&lt;/span&gt;; Y++)                        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    不处理边缘部分数据&lt;/span&gt;
&lt;span&gt;        {
            unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *LinePD = Dest + Y *&lt;span&gt; StrideD ;
            unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *P1 = Src + (Y * &lt;span&gt;2&lt;/span&gt; - &lt;span&gt;2&lt;/span&gt;) *&lt;span&gt; StrideS;
            unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *P2 = P1 +&lt;span&gt; StrideS;
            unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *P3 = P2 +&lt;span&gt; StrideS;
            unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *P4 = P3 +&lt;span&gt; StrideS;
            unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *P5 = P4 +&lt;span&gt; StrideS;
            Sum3 &lt;/span&gt;= P1[&lt;span&gt;0&lt;/span&gt;] + ((P2[&lt;span&gt;0&lt;/span&gt;] + P4[&lt;span&gt;0&lt;/span&gt;]) &amp;lt;&amp;lt; &lt;span&gt;2&lt;/span&gt;) + P3[&lt;span&gt;0&lt;/span&gt;] * &lt;span&gt;6&lt;/span&gt; + P5[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];
            Sum4 &lt;/span&gt;= P1[&lt;span&gt;1&lt;/span&gt;] + ((P2[&lt;span&gt;1&lt;/span&gt;] + P4[&lt;span&gt;1&lt;/span&gt;]) &amp;lt;&amp;lt; &lt;span&gt;2&lt;/span&gt;) + P3[&lt;span&gt;1&lt;/span&gt;] * &lt;span&gt;6&lt;/span&gt; + P5[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
            Sum5 &lt;/span&gt;= P1[&lt;span&gt;2&lt;/span&gt;] + ((P2[&lt;span&gt;2&lt;/span&gt;] + P4[&lt;span&gt;2&lt;/span&gt;]) &amp;lt;&amp;lt; &lt;span&gt;2&lt;/span&gt;) + P3[&lt;span&gt;2&lt;/span&gt;] * &lt;span&gt;6&lt;/span&gt; + P5[&lt;span&gt;2&lt;/span&gt;&lt;span&gt;];
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; X = &lt;span&gt;1&lt;/span&gt;; X &amp;lt; DstW - &lt;span&gt;1&lt;/span&gt;; X++&lt;span&gt;)
            {
                Sum1 &lt;/span&gt;= Sum3;    Sum2 = Sum4;    Sum3 =&lt;span&gt; Sum5;
                Sum4 &lt;/span&gt;= P1[&lt;span&gt;3&lt;/span&gt;] + ((P2[&lt;span&gt;3&lt;/span&gt;] + P4[&lt;span&gt;3&lt;/span&gt;]) &amp;lt;&amp;lt; &lt;span&gt;2&lt;/span&gt;) + P3[&lt;span&gt;3&lt;/span&gt;] * &lt;span&gt;6&lt;/span&gt; + P5[&lt;span&gt;3&lt;/span&gt;&lt;span&gt;];
                Sum5 &lt;/span&gt;= P1[&lt;span&gt;4&lt;/span&gt;] + ((P2[&lt;span&gt;4&lt;/span&gt;] + P4[&lt;span&gt;4&lt;/span&gt;]) &amp;lt;&amp;lt; &lt;span&gt;2&lt;/span&gt;) + P3[&lt;span&gt;4&lt;/span&gt;] * &lt;span&gt;6&lt;/span&gt; + P5[&lt;span&gt;4&lt;/span&gt;&lt;span&gt;];
                LinePD[X] &lt;/span&gt;= (Sum1 + ((Sum2 + Sum4) &amp;lt;&amp;lt; &lt;span&gt;2&lt;/span&gt;) + Sum3 * &lt;span&gt;6&lt;/span&gt; + Sum5 + &lt;span&gt;128&lt;/span&gt;) &amp;gt;&amp;gt; &lt;span&gt;8&lt;/span&gt;;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    注意四舍五入&lt;/span&gt;&lt;span&gt;
                P1 &lt;/span&gt;+= &lt;span&gt;2&lt;/span&gt;;    P2 += &lt;span&gt;2&lt;/span&gt;;    P3 += &lt;span&gt;2&lt;/span&gt;;    P4 += &lt;span&gt;2&lt;/span&gt;;    P5 += &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
            }
        }
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (Channel == &lt;span&gt;3&lt;/span&gt;&lt;span&gt;)
    {
&lt;/span&gt;&lt;span&gt;
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (Channel == &lt;span&gt;4&lt;/span&gt;&lt;span&gt;)
    {
&lt;/span&gt;&lt;span&gt;
    }

    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; X = &lt;span&gt;0&lt;/span&gt;; X &amp;lt; DstW; X++&lt;span&gt;)
    {
        //IM_DownSamplePerPixel8U(Src, Dest, SrcW, SrcH, StrideS, DstW, DstH, StrideD, Channel, X, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;);                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    第一行及最后一行&lt;/span&gt;
        //IM_DownSamplePerPixel8U(Src, Dest, SrcW, SrcH, StrideS, DstW, DstH, StrideD, Channel, X, DstH - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; Y = &lt;span&gt;1&lt;/span&gt;; Y &amp;lt; DstH - &lt;span&gt;1&lt;/span&gt;; Y++&lt;span&gt;)
    {
        //IM_DownSamplePerPixel8U(Src, Dest, SrcW, SrcH, StrideS, DstW, DstH, StrideD, Channel, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;, Y);                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    第一列及最后一列&lt;/span&gt;
        //IM_DownSamplePerPixel8U(Src, Dest, SrcW, SrcH, StrideS, DstW, DstH, StrideD, Channel, DstW - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;, Y);
    }&lt;br/&gt;　　return IM_STATUS_OK;
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; 　　注意到，在单通道的示例里，我们用了5个中间变量，分别记录了某个位置5列像素的累加和，在移动到下一个目标像素时，由于我们是隔行隔列采样的，因此移动到下一个像素时只有3个位置时重叠的，也就是说只有3个分量可以重复利用，另外两个必须重新计算。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 　　上面的代码是先计算列方向，然后在计算行方向的，基本上不需要额外的内存，我们再来试下先计算行方向的累积值，再处理列方向的方案：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;105&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;int&lt;/span&gt; IM_DownSample8U_C2(unsigned &lt;span&gt;char&lt;/span&gt; *Src, unsigned &lt;span&gt;char&lt;/span&gt; *Dest, &lt;span&gt;int&lt;/span&gt; SrcW, &lt;span&gt;int&lt;/span&gt; SrcH, &lt;span&gt;int&lt;/span&gt; StrideS, &lt;span&gt;int&lt;/span&gt; DstW, &lt;span&gt;int&lt;/span&gt; DstH, &lt;span&gt;int&lt;/span&gt; StrideD, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; Channel)
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((Channel != &lt;span&gt;1&lt;/span&gt;) &amp;amp;&amp;amp; (Channel != &lt;span&gt;3&lt;/span&gt;) &amp;amp;&amp;amp; (Channel != &lt;span&gt;4&lt;/span&gt;))        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; IM_STATUS_NOTSUPPORTED;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (DstW != ((SrcW + &lt;span&gt;1&lt;/span&gt;) &amp;gt;&amp;gt; &lt;span&gt;1&lt;/span&gt;) || DstH != ((SrcH + &lt;span&gt;1&lt;/span&gt;) &amp;gt;&amp;gt; &lt;span&gt;1&lt;/span&gt;)) &lt;span&gt;return&lt;/span&gt; IM_STATUS_INVALIDPARAMETER;            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    尺寸匹配&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; Status =&lt;span&gt; IM_STATUS_OK;
    unsigned &lt;/span&gt;&lt;span&gt;short&lt;/span&gt; *Sum0 = (unsigned &lt;span&gt;short&lt;/span&gt; *)malloc(DstW * Channel * &lt;span&gt;sizeof&lt;/span&gt;(unsigned &lt;span&gt;short&lt;/span&gt;&lt;span&gt;));
    unsigned &lt;/span&gt;&lt;span&gt;short&lt;/span&gt; *Sum1 = (unsigned &lt;span&gt;short&lt;/span&gt; *)malloc(DstW * Channel * &lt;span&gt;sizeof&lt;/span&gt;(unsigned &lt;span&gt;short&lt;/span&gt;&lt;span&gt;));
    unsigned &lt;/span&gt;&lt;span&gt;short&lt;/span&gt; *Sum2 = (unsigned &lt;span&gt;short&lt;/span&gt; *)malloc(DstW * Channel * &lt;span&gt;sizeof&lt;/span&gt;(unsigned &lt;span&gt;short&lt;/span&gt;&lt;span&gt;));
    unsigned &lt;/span&gt;&lt;span&gt;short&lt;/span&gt; *Sum3 = (unsigned &lt;span&gt;short&lt;/span&gt; *)malloc(DstW * Channel * &lt;span&gt;sizeof&lt;/span&gt;(unsigned &lt;span&gt;short&lt;/span&gt;&lt;span&gt;));
    unsigned &lt;/span&gt;&lt;span&gt;short&lt;/span&gt; *Sum4 = (unsigned &lt;span&gt;short&lt;/span&gt; *)malloc(DstW * Channel * &lt;span&gt;sizeof&lt;/span&gt;(unsigned &lt;span&gt;short&lt;/span&gt;&lt;span&gt;));
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((Sum0 == NULL) || (Sum1 == NULL) || (Sum2 == NULL) || (Sum3 == NULL) || (Sum4 ==&lt;span&gt; NULL))
    {
        Status &lt;/span&gt;=&lt;span&gt; IM_STATUS_OUTOFMEMORY;
        &lt;/span&gt;&lt;span&gt;goto&lt;/span&gt;&lt;span&gt; FreeMemroy;
    }
    
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; Y = &lt;span&gt;1&lt;/span&gt;; Y &amp;lt; DstH - &lt;span&gt;1&lt;/span&gt;; Y++)                        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    不处理边缘部分数据&lt;/span&gt;
&lt;span&gt;    {
        unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *LinePD = Dest + Y *&lt;span&gt; StrideD;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (Y == &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
        {
            IM_DownSampleLine8U_C(Src &lt;/span&gt;+ &lt;span&gt;0&lt;/span&gt; *&lt;span&gt; StrideS, Sum0, DstW, Channel);
            IM_DownSampleLine8U_C(Src &lt;/span&gt;+ &lt;span&gt;1&lt;/span&gt; *&lt;span&gt; StrideS, Sum1, DstW, Channel);
            IM_DownSampleLine8U_C(Src &lt;/span&gt;+ &lt;span&gt;2&lt;/span&gt; *&lt;span&gt; StrideS, Sum2, DstW, Channel);
            IM_DownSampleLine8U_C(Src &lt;/span&gt;+ &lt;span&gt;3&lt;/span&gt; *&lt;span&gt; StrideS, Sum3, DstW, Channel);
            IM_DownSampleLine8U_C(Src &lt;/span&gt;+ &lt;span&gt;4&lt;/span&gt; *&lt;span&gt; StrideS, Sum4, DstW, Channel);
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        {
            unsigned &lt;/span&gt;&lt;span&gt;short&lt;/span&gt; *Temp1 = Sum0, *Temp2 =&lt;span&gt; Sum1;
            Sum0 &lt;/span&gt;= Sum2;    Sum1 = Sum3;    Sum2 =&lt;span&gt; Sum4;
            Sum3 &lt;/span&gt;= Temp1;    Sum4 =&lt;span&gt; Temp2;
            IM_DownSampleLine8U_C(Src &lt;/span&gt;+ (Y * &lt;span&gt;2&lt;/span&gt; + &lt;span&gt;1&lt;/span&gt;) *&lt;span&gt; StrideS, Sum3, DstW, Channel);
            IM_DownSampleLine8U_C(Src &lt;/span&gt;+ (Y * &lt;span&gt;2&lt;/span&gt; + &lt;span&gt;2&lt;/span&gt;) *&lt;span&gt; StrideS, Sum4, DstW, Channel);
        }
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; X = Channel; X &amp;lt; (DstW - &lt;span&gt;1&lt;/span&gt;) * Channel; X++&lt;span&gt;)
        {
            LinePD[X] &lt;/span&gt;= (Sum0[X] + ((Sum1[X] + Sum3[X]) &amp;lt;&amp;lt; &lt;span&gt;2&lt;/span&gt;) + Sum2[X] * &lt;span&gt;6&lt;/span&gt; + Sum4[X] + &lt;span&gt;127&lt;/span&gt;) &amp;gt;&amp;gt; &lt;span&gt;8&lt;/span&gt;&lt;span&gt;;
        }
    }

    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; X = &lt;span&gt;0&lt;/span&gt;; X &amp;lt; DstW; X++&lt;span&gt;)
    {
        //IM_DownSamplePerPixel8U(Src, Dest, SrcW, SrcH, StrideS, DstW, DstH, StrideD, Channel, X, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;);                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    第一行及最后一行&lt;/span&gt;
        //IM_DownSamplePerPixel8U(Src, Dest, SrcW, SrcH, StrideS, DstW, DstH, StrideD, Channel, X, DstH - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; Y = &lt;span&gt;1&lt;/span&gt;; Y &amp;lt; DstH - &lt;span&gt;1&lt;/span&gt;; Y++&lt;span&gt;)
    {
        //IM_DownSamplePerPixel8U(Src, Dest, SrcW, SrcH, StrideS, DstW, DstH, StrideD, Channel, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;, Y);                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    第一列及最后一列&lt;/span&gt;
        //IM_DownSamplePerPixel8U(Src, Dest, SrcW, SrcH, StrideS, DstW, DstH, StrideD, Channel, DstW - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;, Y);
    }

FreeMemroy:
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (Sum0 !=&lt;span&gt; NULL)        free(Sum0);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (Sum1 !=&lt;span&gt; NULL)        free(Sum1);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (Sum2 !=&lt;span&gt; NULL)        free(Sum2);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (Sum3 !=&lt;span&gt; NULL)        free(Sum3);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (Sum4 !=&lt;span&gt; NULL)        free(Sum4);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Status;
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　其中IM_DownSampleLine8U_C函数如下所示：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    一行像素的下取样算法，权重系数为1 4 6 4 1，并且是隔列取样&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; IM_DownSampleLine8U_C(unsigned &lt;span&gt;char&lt;/span&gt; *Src, unsigned &lt;span&gt;short&lt;/span&gt; *Dest, &lt;span&gt;int&lt;/span&gt; DstLen, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; Channel)
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    只处理中间有效范围内的数，第一个和最后一个不处理&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (Channel == &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; Y = &lt;span&gt;1&lt;/span&gt;, Index = &lt;span&gt;2&lt;/span&gt;; Y &amp;lt; DstLen - &lt;span&gt;1&lt;/span&gt;; Y++, Index += &lt;span&gt;2&lt;/span&gt;&lt;span&gt;)
        {
            Dest[Y] &lt;/span&gt;= Src[Index - &lt;span&gt;2&lt;/span&gt;] + ((Src[Index - &lt;span&gt;1&lt;/span&gt;] + Src[Index + &lt;span&gt;1&lt;/span&gt;] ) &amp;lt;&amp;lt; &lt;span&gt;2&lt;/span&gt;) + Src[Index] * &lt;span&gt;6&lt;/span&gt; + Src[Index + &lt;span&gt;2&lt;/span&gt;&lt;span&gt;];
        }
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (Channel == &lt;span&gt;3&lt;/span&gt;)            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    一个load语句可以包含5个完整像素，可以处理1个目标像素，3个分量占6个字节，不好保存，因此，一次性处理2个目标像素就好保存了&lt;/span&gt;
&lt;span&gt;    {
        
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (Channel == &lt;span&gt;4&lt;/span&gt;)        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    4个通道的一次性只处理一个像素的，需要访问源图像20个字节范围&lt;/span&gt;
&lt;span&gt;    {
        
    }
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　注意到上述代码在结构上和第一版本其实差不多，不过多了5行临时内存，在更新行权重的时候也是只需要更新2行的，而无需整体更新。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 　  我们对这两种方案进行了速度测试，由于本身这个的执行速度就比较块，因此我们对算法进行了100次计算，对于第一级为1920*1080大小的灰度图，下一级的高斯金字塔大小为960*540像素，算法C1测试的结果为267ms，算法C2的执行速度约为256ms，这说明他们本质上不存在大的速度差异（这里的时间都不包括处理边缘像素的，后面还要讨论，并且高斯金字塔也是采用unsigned char类型数据来保存的）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       在某些场合，我们还需要加快这个过程的速度，因此我考虑使用SSE优化他，考虑以上两种实现方式，哪一种更有利于SSE的处理呢，由于第一种方式前后的依赖比较强，用SSE做不是不可以，但估计效率不会有提升，需要太多次数据重组了，而第二种方式的由中间数据计算最后的结果很明显可以使用SSE处理，即下面的这三行代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; X = Channel; X &amp;lt; (DstW - &lt;span&gt;1&lt;/span&gt;) * Channel; X++&lt;span&gt;)
{
     LinePD[X] &lt;/span&gt;= (Sum0[X] + ((Sum1[X] + Sum3[X]) &amp;lt;&amp;lt; &lt;span&gt;2&lt;/span&gt;) + Sum2[X] * &lt;span&gt;6&lt;/span&gt; + Sum4[X] + &lt;span&gt;127&lt;/span&gt;) &amp;gt;&amp;gt; &lt;span&gt;8&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　这里的Sum是16位的，LinePD是8位的。替换的代码如下所示：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;int&lt;/span&gt; BlockSize = &lt;span&gt;8&lt;/span&gt;, Block = (DstW - &lt;span&gt;1&lt;/span&gt; - &lt;span&gt;1&lt;/span&gt;) * Channel /&lt;span&gt; BlockSize;
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; X = Channel; X &amp;lt; Block * BlockSize + Channel; X +=&lt;span&gt; BlockSize)
{
    __m128i S0 &lt;/span&gt;= _mm_loadu_si128((__m128i *)(Sum0 +&lt;span&gt; X));
    __m128i S1 &lt;/span&gt;= _mm_loadu_si128((__m128i *)(Sum1 +&lt;span&gt; X));
    __m128i S2 &lt;/span&gt;= _mm_loadu_si128((__m128i *)(Sum2 +&lt;span&gt; X));
    __m128i S3 &lt;/span&gt;= _mm_loadu_si128((__m128i *)(Sum3 +&lt;span&gt; X));
    __m128i S4 &lt;/span&gt;= _mm_loadu_si128((__m128i *)(Sum4 +&lt;span&gt; X));
    __m128i Sum &lt;/span&gt;= _mm_add_epi16(_mm_add_epi16(_mm_add_epi16(_mm_add_epi16(S0, S4), _mm_slli_epi16(_mm_add_epi16(S1, S3), &lt;span&gt;2&lt;/span&gt;)), _mm_mullo_epi16(S2, _mm_set1_epi16(&lt;span&gt;6&lt;/span&gt;))), _mm_set1_epi16(&lt;span&gt;127&lt;/span&gt;&lt;span&gt;));
    _mm_storel_epi64((__m128i &lt;/span&gt;*)(LinePD + X), _mm_packus_epi16(_mm_srli_epi16(Sum, &lt;span&gt;8&lt;/span&gt;&lt;span&gt;), _mm_setzero_si128()));
}
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; X = Block * BlockSize + Channel; X &amp;lt; (DstW - &lt;span&gt;1&lt;/span&gt;) * Channel; X++&lt;span&gt;)
{
    LinePD[X] = (Sum0[X] + ((Sum1[X] + Sum3[X]) &amp;lt;&amp;lt; 2) + Sum2[X] * 6 + Sum4[X] + 127) &amp;gt;&amp;gt; 8;&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　这么个简单的改动，速度大概到了180ms。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　  有点麻烦的是IM_DownSampleLine8U_C这个函数的优化，其核心代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; Y = &lt;span&gt;1&lt;/span&gt;, Index = &lt;span&gt;2&lt;/span&gt;; Y &amp;lt; DstLen - &lt;span&gt;1&lt;/span&gt;; Y++, Index += &lt;span&gt;2&lt;/span&gt;&lt;span&gt;)
  {
 　　Dest[Y] &lt;/span&gt;= Src[Index - &lt;span&gt;2&lt;/span&gt;] + ((Src[Index - &lt;span&gt;1&lt;/span&gt;] + Src[Index + &lt;span&gt;1&lt;/span&gt;] ) &amp;lt;&amp;lt; &lt;span&gt;2&lt;/span&gt;) + Src[Index] * &lt;span&gt;6&lt;/span&gt; + Src[Index + &lt;span&gt;2&lt;/span&gt;&lt;span&gt;];
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　最简单的SSE处理方式是加载5次不同位置的Src值，然后将数据转换为16位，再进行加法和乘法计算。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; ValidLen = DstLen - &lt;span&gt;2&lt;/span&gt;;                                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    -2是因为第一和最后一个点的部分取样值是不在有效范围内的&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; BlockSize = &lt;span&gt;8&lt;/span&gt;, Block = ValidLen /&lt;span&gt; BlockSize;
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; Y = &lt;span&gt;1&lt;/span&gt;; Y &amp;lt; Block * BlockSize + &lt;span&gt;1&lt;/span&gt;; Y +=&lt;span&gt; BlockSize)
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; Index = (Y - &lt;span&gt;1&lt;/span&gt;) * &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
    __m128i SrcV0 &lt;/span&gt;= _mm_cvtepu8_epi16(_mm_loadl_epi64((__m128i *)(Src +&lt;span&gt; Index)));
    __m128i SrcV1 &lt;/span&gt;= _mm_cvtepu8_epi16(_mm_loadl_epi64((__m128i *)(Src + Index + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)));
    __m128i SrcV2 &lt;/span&gt;= _mm_cvtepu8_epi16(_mm_loadl_epi64((__m128i *)(Src + Index + &lt;span&gt;2&lt;/span&gt;&lt;span&gt;)));
    __m128i SrcV3 &lt;/span&gt;= _mm_cvtepu8_epi16(_mm_loadl_epi64((__m128i *)(Src + Index + &lt;span&gt;3&lt;/span&gt;&lt;span&gt;)));
    __m128i SrcV4 &lt;/span&gt;= _mm_cvtepu8_epi16(_mm_loadl_epi64((__m128i *)(Src + Index + &lt;span&gt;4&lt;/span&gt;&lt;span&gt;)));
    _mm_storeu_si128((__m128i &lt;/span&gt;*)(Dest + Y), _mm_add_epi16(_mm_add_epi16(SrcV0, SrcV1), _mm_add_epi16(_mm_slli_epi16(_mm_add_epi16(SrcV1, SrcV3), &lt;span&gt;2&lt;/span&gt;), _mm_mullo_epi16(SrcV2, _mm_set1_epi16(&lt;span&gt;6&lt;/span&gt;&lt;span&gt;)))));
}
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; Y = Block * BlockSize + &lt;span&gt;1&lt;/span&gt;; Y &amp;lt; DstLen - &lt;span&gt;1&lt;/span&gt;; Y++&lt;span&gt;)
{
    Dest[Y] &lt;/span&gt;= Src[Y * &lt;span&gt;2&lt;/span&gt; - &lt;span&gt;2&lt;/span&gt;] + Src[Y * &lt;span&gt;2&lt;/span&gt; - &lt;span&gt;1&lt;/span&gt;] * &lt;span&gt;4&lt;/span&gt; + Src[Y * &lt;span&gt;2&lt;/span&gt;] * &lt;span&gt;6&lt;/span&gt; + Src[Y * &lt;span&gt;2&lt;/span&gt; + &lt;span&gt;1&lt;/span&gt;] * &lt;span&gt;4&lt;/span&gt; + Src[Y * &lt;span&gt;2&lt;/span&gt; + &lt;span&gt;2&lt;/span&gt;&lt;span&gt;];
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　一次性处理8个像素，需要多次加载内存，原以为速度会有问题，结果一测，速度居然飙升到40ms，单次只需要0.4ms了。真的很高兴。&lt;/p&gt;
&lt;p&gt;　　但是和普通的C比较一下，似乎结果不对啊，仔细分析，原来是因为这个对Src取样计算时每次是隔一个点取一个样的，而上述代码侧连续采样的，那怎么办呢？&lt;/p&gt;
&lt;p&gt;　　也很简单，我们使用_mm_loadu_si128一次性加载16个字节，然后每隔一个像素就置0，这样就相当于把剩下的8个像素的值直接变为了16位数据了，一举两得。如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;int&lt;/span&gt; ValidLen = DstLen - &lt;span&gt;2&lt;/span&gt;;                                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    -2是因为第一和最后一个点的部分取样值是不在有效范围内的&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; BlockSize = &lt;span&gt;8&lt;/span&gt;, Block = ValidLen /&lt;span&gt; BlockSize;
        __m128i Mask &lt;/span&gt;= _mm_setr_epi8(&lt;span&gt;255&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;255&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;255&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;255&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;255&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;255&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;255&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;255&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; Y = &lt;span&gt;1&lt;/span&gt;; Y &amp;lt; Block * BlockSize + &lt;span&gt;1&lt;/span&gt;; Y +=&lt;span&gt; BlockSize)
        {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; Index = (Y - &lt;span&gt;1&lt;/span&gt;) * &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
            __m128i SrcV0 &lt;/span&gt;= _mm_and_si128(_mm_loadu_si128((__m128i *)(Src + Index + &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)), Mask);
            __m128i SrcV1 &lt;/span&gt;= _mm_and_si128(_mm_loadu_si128((__m128i *)(Src + Index + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)), Mask);
            __m128i SrcV2 &lt;/span&gt;= _mm_and_si128(_mm_loadu_si128((__m128i *)(Src + Index + &lt;span&gt;2&lt;/span&gt;&lt;span&gt;)), Mask);
            __m128i SrcV3 &lt;/span&gt;= _mm_and_si128(_mm_loadu_si128((__m128i *)(Src + Index + &lt;span&gt;3&lt;/span&gt;&lt;span&gt;)), Mask);
            __m128i SrcV4 &lt;/span&gt;= _mm_and_si128(_mm_loadu_si128((__m128i *)(Src + Index + &lt;span&gt;4&lt;/span&gt;&lt;span&gt;)), Mask);
            _mm_storeu_si128((__m128i &lt;/span&gt;*)(Dest + Y), _mm_add_epi16(_mm_add_epi16(SrcV0, SrcV4), _mm_add_epi16(_mm_slli_epi16(_mm_add_epi16(SrcV1, SrcV3), &lt;span&gt;2&lt;/span&gt;), _mm_mullo_epi16(SrcV2, _mm_set1_epi16(&lt;span&gt;6&lt;/span&gt;&lt;span&gt;)))));
        }
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; Y = Block * BlockSize + &lt;span&gt;1&lt;/span&gt;; Y &amp;lt; DstLen - &lt;span&gt;1&lt;/span&gt;; Y++&lt;span&gt;)
        {
            Dest[Y] &lt;/span&gt;= Src[Y * &lt;span&gt;2&lt;/span&gt; - &lt;span&gt;2&lt;/span&gt;] + Src[Y * &lt;span&gt;2&lt;/span&gt; - &lt;span&gt;1&lt;/span&gt;] * &lt;span&gt;4&lt;/span&gt; + Src[Y * &lt;span&gt;2&lt;/span&gt;] * &lt;span&gt;6&lt;/span&gt; + Src[Y * &lt;span&gt;2&lt;/span&gt; + &lt;span&gt;1&lt;/span&gt;] * &lt;span&gt;4&lt;/span&gt; + Src[Y * &lt;span&gt;2&lt;/span&gt; + &lt;span&gt;2&lt;/span&gt;&lt;span&gt;];
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　我们上面用的and运算来将有关位置0，当然还可以使用 shuffle指令来得到同样的结果，速度大概也就稍微慢一点，大概再45ms。&lt;/p&gt;
&lt;p&gt;　　实际上，在这里的由于权重有一些特殊性，比如有2个1，2个4，4还可以用移位实现，如果是一些其他不太有规律的权重，比如 3 7 9 7 3这种，我们实际上还有一种优化方式来处理，因为在SSE里还有一个_mm_maddubs_epi16这个指令，他可以一次性实现16个字节数*16个signed char，然后再两两相加保存到8个short类型中去，比如上面的代码也可以用下面的方式实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;121&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;int&lt;/span&gt; ValidLen = DstLen - &lt;span&gt;2&lt;/span&gt;;                                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    -2是因为第一和最后一个点的部分取样值是不在有效范围内的&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; BlockSize = &lt;span&gt;6&lt;/span&gt;, Block = ValidLen /&lt;span&gt; BlockSize;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    Src     S0    S1    S2    S3    S4    S5    S6    S7    S8    S9    S10    S11    S12    S13    S14    S15                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    16个像素    
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    Dst                D1        D2        D3        D4        D5        D6                            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    有效位置的只有6个结果

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    1   4   6   4   1   4   6   4   1   4   6   4   1   4   6   4&lt;/span&gt;
        __m128i Cof = _mm_setr_epi8(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;, &lt;span&gt;6&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;, &lt;span&gt;6&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;, &lt;span&gt;6&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;, &lt;span&gt;6&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    用同一个系数不影响，因为后面反正抛弃了后半部分的累加        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;__m128i Cof1 = _mm_setr_epi8(1, 4, 6, 4, 1, 4, 6, 4, 1, 4, 6, 4, 1, 4, 6, 4);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    1   4   6   4   1   4   6   4   1   4   6   4   1   4   6   4
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;__m128i Cof2 = _mm_setr_epi8(1, 4, 6, 4, 1, 4, 6, 4, 0, 0, 0, 0, 0, 0, 0, 0);&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; Y = &lt;span&gt;1&lt;/span&gt;; Y &amp;lt; Block * BlockSize + &lt;span&gt;1&lt;/span&gt;; Y +=&lt;span&gt; BlockSize)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    S0    S1    S2    S3    S4    S5    S6    S7    S8    S9    S10    S11    S12    S13    S14    S15&lt;/span&gt;
            __m128i SrcV = _mm_loadu_si128((__m128i *)(Src + (Y - &lt;span&gt;1&lt;/span&gt;) * &lt;span&gt;2&lt;/span&gt;&lt;span&gt;));
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    S0    S1    S2    S3    S2    S3    S4    S5  S4    S5    S6    S7    S6    S7    S8    S9&lt;/span&gt;
            __m128i Src1 = _mm_shuffle_epi8(SrcV, _mm_setr_epi8(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;, &lt;span&gt;6&lt;/span&gt;, &lt;span&gt;7&lt;/span&gt;, &lt;span&gt;6&lt;/span&gt;, &lt;span&gt;7&lt;/span&gt;, &lt;span&gt;8&lt;/span&gt;, &lt;span&gt;9&lt;/span&gt;&lt;span&gt;));
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    S8    S9    S10    S11    S10    S11    S12    S13 S4    S6    S8    S10    S12    S14    0    0&lt;/span&gt;
            __m128i Src2 = _mm_shuffle_epi8(SrcV, _mm_setr_epi8(&lt;span&gt;8&lt;/span&gt;, &lt;span&gt;9&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;, &lt;span&gt;11&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;, &lt;span&gt;11&lt;/span&gt;, &lt;span&gt;12&lt;/span&gt;, &lt;span&gt;13&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;, &lt;span&gt;6&lt;/span&gt;, &lt;span&gt;8&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;, &lt;span&gt;12&lt;/span&gt;, &lt;span&gt;14&lt;/span&gt;, -&lt;span&gt;1&lt;/span&gt;, -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;));
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    S0 + S1 * 4        S2 * 6 + S3 * 4        S2 + S3 * 4        S4 * 6 + S5 * 4        S4 + S5 * 4        S6 * 6 + S7 * 4  S6 + S7 * 4        S8 * 6 + S9 * 4&lt;/span&gt;
            __m128i Dst1 = _mm_maddubs_epi16(Src1, Cof);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     _mm_maddubs_epi16(Src1, Cof1);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    S8 + S9 * 4        S10 * 6 + S11 * 4    S10 + S11 * 4    S12 * 6 + S13 * 4        0        0        0        0        0        0        0        0&lt;/span&gt;
            __m128i Dst2 = _mm_maddubs_epi16(Src2, Cof);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     _mm_maddubs_epi16(Src1, Cof2);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    S0 + S1 * 4    + S2 * 6 + S3 * 4        S2 + S3 * 4    + S4 * 6 + S5 * 4        S4 + S5 * 4    + S6 * 6 + S7 * 4    S6 + S7 * 4    + S8 * 6 + S9 * 4        S8 + S9 * 4    + S10 * 6 + S11 * 4        S10 + S11 * 4 + S12 * 6 + S13 * 4&lt;/span&gt;
            __m128i Dst12 =&lt;span&gt; _mm_hadd_epi16(Dst1, Dst2);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    S0 + S1 * 4    + S2 * 6 + S3 * 4 + S4        S2 + S3 * 4    + S4 * 6 + S5 * 4 + S6        S4 + S5 * 4    + S6 * 6 + S7 * 4+ S8    S6 + S7 * 4    + S8 * 6 + S9 * 4 + S10        S8 + S9 * 4    + S10 * 6 + S11 * 4    + S12    S10 + S11 * 4 + S12 * 6 + S13 * 4 + S14&lt;/span&gt;
            __m128i Dst =&lt;span&gt; _mm_add_epi16(Dst12, _mm_unpackhi_epi8(Src2, _mm_setzero_si128()));

            _mm_storeu_epi96((__m128i &lt;/span&gt;*)(Dest +&lt;span&gt; Y), Dst);
        }
        
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; Y = Block * BlockSize + &lt;span&gt;1&lt;/span&gt;; Y &amp;lt; DstLen - &lt;span&gt;1&lt;/span&gt;; Y++&lt;span&gt;)
        {
            Dest[Y] &lt;/span&gt;= Src[Y * &lt;span&gt;2&lt;/span&gt; - &lt;span&gt;2&lt;/span&gt;] + Src[Y * &lt;span&gt;2&lt;/span&gt; - &lt;span&gt;1&lt;/span&gt;] * &lt;span&gt;4&lt;/span&gt; + Src[Y * &lt;span&gt;2&lt;/span&gt;] * &lt;span&gt;6&lt;/span&gt; + Src[Y * &lt;span&gt;2&lt;/span&gt; + &lt;span&gt;1&lt;/span&gt;] * &lt;span&gt;4&lt;/span&gt; + Src[Y * &lt;span&gt;2&lt;/span&gt; + &lt;span&gt;2&lt;/span&gt;&lt;span&gt;];
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在本例中，上述代码执行100次要50几毫秒，比前面的慢了，但是这里的组合确实是蛮有味道的，各种数据的灵活应用也是值得参考的。我反而更欣赏这段代码。&lt;/p&gt;
&lt;p&gt; 　  以上谈及的均是单通道的算法，如果是BGR 3个通道或者BGRA 4个通道的图像数据，情况就会复杂一些，但是同样的道理，可以使用shuffle来调整位置，然后使用类似的方式处理。&lt;/p&gt;
&lt;p&gt;　　我们来谈谈浮点版本的高斯金字塔，这个再很多情况下也有需求，毕竟有很多算法是再浮点上进行处理的，那浮点版本的普通C的代码其实和C语言是差不多的，只需要将有关数据类型改为浮点就可以了，那对于其核心的DownSampleLine函数，也是我们优化的关键和难点，由于SSE一次性只能加载4个浮点数，如果还是和刚才处理字节数据那样，隔一个数取一个数，那么利用SSE一次性只能处理2个像素，而我们通过下面的美好的优化方式，一次性就能处理4个像素了，而且代码也很优美，我很是喜欢。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; IM_DownSampleLine32F(&lt;span&gt;float&lt;/span&gt; *Src, &lt;span&gt;float&lt;/span&gt; *Dest, &lt;span&gt;int&lt;/span&gt; DstLen, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; Channel)
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    只处理中间有效范围内的数，第一个和最后一个不处理&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (Channel == &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; ValidLen = DstLen - &lt;span&gt;2&lt;/span&gt;;                                                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    -2是因为第一和最后一个点的部分取样值是不在有效范围内的&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; BlockSize = &lt;span&gt;4&lt;/span&gt;, Block = ValidLen /&lt;span&gt; BlockSize;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    Src    S0    S1    S2    S3    S4    S5    S6    S7    S8    S9    S10    S11   　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    12个数据    
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    Dst                D1           D2          D3         D4                            　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    有效位置的只有4个结果

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    1   4   6   4  &lt;/span&gt;
        __m128 Cof = _mm_setr_ps(&lt;span&gt;1.0f&lt;/span&gt;, &lt;span&gt;4.0f&lt;/span&gt;, &lt;span&gt;6.0f&lt;/span&gt;, &lt;span&gt;4.0f&lt;/span&gt;&lt;span&gt;);      
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; Y = &lt;span&gt;1&lt;/span&gt;; Y &amp;lt; Block * BlockSize + &lt;span&gt;1&lt;/span&gt;; Y +=&lt;span&gt; BlockSize)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    S0    S1    S2    S3&lt;/span&gt;
            __m128 SrcV0 = _mm_loadu_ps(Src + (Y - &lt;span&gt;1&lt;/span&gt;) * &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    S4    S5    S6    S7&lt;/span&gt;
            __m128 SrcV1 = _mm_loadu_ps(Src + (Y - &lt;span&gt;1&lt;/span&gt;) * &lt;span&gt;2&lt;/span&gt; + &lt;span&gt;4&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    S8    S9    S10    S11&lt;/span&gt;
            __m128 SrcV2 = _mm_loadu_ps(Src + (Y - &lt;span&gt;1&lt;/span&gt;) * &lt;span&gt;2&lt;/span&gt; + &lt;span&gt;8&lt;/span&gt;);            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    下一次加载时的SrcV0和本次的SrcV2时相同的，测试过用变量赋值，结果区别不大
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    S0    S1 * 4  S2 * 6  S3 * 4&lt;/span&gt;
            __m128 Sum0 =&lt;span&gt; _mm_mul_ps(SrcV0, Cof);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    S2  S3 * 4  S4 * 6  S5 * 4&lt;/span&gt;
            __m128 Sum1 = _mm_mul_ps(_mm_shuffle_ps(SrcV0, SrcV1, _MM_SHUFFLE(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;)), Cof);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    S4  S5 * 4  S6 * 6  S7 * 4&lt;/span&gt;
            __m128 Sum2 =&lt;span&gt; _mm_mul_ps(SrcV1, Cof);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    S6  S7 * 4  S8 * 6  S9 * 4&lt;/span&gt;
            __m128 Sum3 = _mm_mul_ps(_mm_shuffle_ps(SrcV1, SrcV2, _MM_SHUFFLE(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;)), Cof);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    S0 + S1 * 4 + S2 * 6 + S3 * 4            S2 + S3 * 4 + S4 * 6 + S5 * 4        S4 + S5 * 4 + S6 * 6 + S7 * 4        S6 + S7 * 4 + S8 * 6 + S9 * 4&lt;/span&gt;
            __m128 Dst =&lt;span&gt; _mm_hadd_ps(_mm_hadd_ps(Sum0, Sum1), _mm_hadd_ps(Sum2, Sum3));
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    S0 + S1 * 4 + S2 * 6 + S3 * 4 + S4            S2 + S3 * 4 + S4 * 6 + S5 * 4 + S6        S4 + S5 * 4 + S6 * 6 + S7 * 4 + S8        S6 + S7 * 4 + S8 * 6 + S9 * 4 + S10&lt;/span&gt;
            Dst = _mm_add_ps(Dst, _mm_shuffle_ps(SrcV1, SrcV2, _MM_SHUFFLE(&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)));
            _mm_storeu_ps(Dest &lt;/span&gt;+&lt;span&gt; Y, Dst);
        }
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; Y = Block * BlockSize + &lt;span&gt;1&lt;/span&gt;; Y &amp;lt; DstLen - &lt;span&gt;1&lt;/span&gt;; Y++&lt;span&gt;)
        {
            Dest[Y] &lt;/span&gt;= Src[Y * &lt;span&gt;2&lt;/span&gt; - &lt;span&gt;2&lt;/span&gt;] + Src[Y * &lt;span&gt;2&lt;/span&gt; - &lt;span&gt;1&lt;/span&gt;] * &lt;span&gt;4&lt;/span&gt; + Src[Y * &lt;span&gt;2&lt;/span&gt;] * &lt;span&gt;6&lt;/span&gt; + Src[Y * &lt;span&gt;2&lt;/span&gt; + &lt;span&gt;1&lt;/span&gt;] * &lt;span&gt;4&lt;/span&gt; + Src[Y * &lt;span&gt;2&lt;/span&gt; + &lt;span&gt;2&lt;/span&gt;&lt;span&gt;];
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　具体的每句代码的意思根据我上面的注释应该很容易能弄懂的，我就不加解释了。&lt;/p&gt;
&lt;p&gt;　　最后，我们来关注下边缘的处理，边缘部分由于取样时会超出图像边界，因此，需要做判断，一种合理的方式是采用镜像数据，此时可以保证权重一定是256，我做了一个简单的函数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;80&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; IM_DownSamplePerPixel8U(unsigned &lt;span&gt;char&lt;/span&gt; *Src, unsigned &lt;span&gt;char&lt;/span&gt; *Dest, &lt;span&gt;int&lt;/span&gt; SrcW, &lt;span&gt;int&lt;/span&gt; SrcH, &lt;span&gt;int&lt;/span&gt; StrideS, &lt;span&gt;int&lt;/span&gt; DstW, &lt;span&gt;int&lt;/span&gt; DstH, &lt;span&gt;int&lt;/span&gt; StrideD, &lt;span&gt;int&lt;/span&gt; Channel, &lt;span&gt;int&lt;/span&gt; X, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; Y)
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((Channel != &lt;span&gt;1&lt;/span&gt;) &amp;amp;&amp;amp; (Channel != &lt;span&gt;3&lt;/span&gt;) &amp;amp;&amp;amp; (Channel != &lt;span&gt;4&lt;/span&gt;))        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; IM_STATUS_NOTSUPPORTED;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (X &amp;lt; &lt;span&gt;0&lt;/span&gt; || X &amp;gt;= DstW || Y &amp;lt; &lt;span&gt;0&lt;/span&gt; || Y &amp;gt;= DstH)                &lt;span&gt;return&lt;/span&gt;&lt;span&gt; IM_STATUS_INVALIDPARAMETER;

    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; Sum, SumB, SumG, SumR, SumA;
    &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Kernel[&lt;span&gt;25&lt;/span&gt;] =&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;, &lt;span&gt;6&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;4&lt;/span&gt;, &lt;span&gt;16&lt;/span&gt;, &lt;span&gt;24&lt;/span&gt;, &lt;span&gt;16&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;6&lt;/span&gt;, &lt;span&gt;24&lt;/span&gt;, &lt;span&gt;36&lt;/span&gt;, &lt;span&gt;24&lt;/span&gt;, &lt;span&gt;6&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;4&lt;/span&gt;, &lt;span&gt;16&lt;/span&gt;, &lt;span&gt;24&lt;/span&gt;, &lt;span&gt;16&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;, &lt;span&gt;6&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt; };                                                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    高斯卷积核&lt;/span&gt;
&lt;span&gt;
    Sum &lt;/span&gt;= SumB = SumG = SumR = SumA = &lt;span&gt;128&lt;/span&gt;;                                        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     128是用于四舍五入的&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; J = -&lt;span&gt;2&lt;/span&gt;; J &amp;lt;= &lt;span&gt;2&lt;/span&gt;; J++&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; YY = IM_GetMirrorPos_Ex(SrcH, Y * &lt;span&gt;2&lt;/span&gt; + J);                            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    YY = Clamp(Y * 2 + J, 0, SrcH - 1);        在上一级中的Y坐标要乘以2, 使用Clamp速度会稍微慢一点&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; I = -&lt;span&gt;2&lt;/span&gt;; I &amp;lt;= &lt;span&gt;2&lt;/span&gt;; I++&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; Weight = Kernel[(J + &lt;span&gt;2&lt;/span&gt;) * &lt;span&gt;5&lt;/span&gt; + (I + &lt;span&gt;2&lt;/span&gt;)];                        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    严格的按照卷积公式进行计算，没必要用中间变量去优化他了&lt;/span&gt;
            &lt;span&gt;int&lt;/span&gt; XX = IM_GetMirrorPos_Ex(SrcW, X * &lt;span&gt;2&lt;/span&gt; + I);                        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    XX = Clamp(X * 2 + I, 0, SrcW - 1); 用EX这个版本的保证边缘的部分不会有重复的像素，不然取样就不对了&lt;/span&gt;
            unsigned &lt;span&gt;char&lt;/span&gt; *Sample = Src + YY * StrideS + XX *&lt;span&gt; Channel;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (Channel == &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
            {
                Sum &lt;/span&gt;+= Sample[&lt;span&gt;0&lt;/span&gt;] *&lt;span&gt; Weight;
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (Channel == &lt;span&gt;3&lt;/span&gt;&lt;span&gt;)
            {

            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (Channel == &lt;span&gt;4&lt;/span&gt;&lt;span&gt;)
            {

            }
        }
    }
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; Index = Y * StrideD + X *&lt;span&gt; Channel;

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (Channel == &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
    {
        Dest[Index] &lt;/span&gt;= Sum &amp;gt;&amp;gt; &lt;span&gt;8&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (Channel == &lt;span&gt;3&lt;/span&gt;&lt;span&gt;)
    {

    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (Channel == &lt;span&gt;4&lt;/span&gt;&lt;span&gt;)
    {
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; IM_STATUS_OK;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　为了程序完整，我们最后再加上周边像素的处理，然而我们发现一个严重的问题，再没有处理四周的函数中，我们运行100次SSE的耗时大约是45ms,一旦加入边缘像素的处理，这个耗时我们发现75ms，而普通C语言版本里由原来的260ms变为290ms，我们可能感受不到大的区别，但SSE的优化后，边缘部分居然占用了40%的耗时，因此，此时边缘特殊像素的处理就成了核心的事情了。&lt;/p&gt;
&lt;p&gt;　　一种可行的优化方式就是类似于我前面做的Sobel边缘检测时方式，先对数据进行扩展，然后对扩展后的数据进行处理，此时边缘部分的处理已经被包括到SSE里去了，我尚未实践此方案的可行性和速度效果，相信应该不成问题。&lt;/p&gt;
&lt;p&gt;　　附本文相关工程代码供参考：&lt;a href=&quot;https://files.cnblogs.com/files/Imageshop/GaussPyramid.rar&quot; target=&quot;_blank&quot;&gt;https://files.cnblogs.com/files/Imageshop/GaussPyramid.rar&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/349293/201901/349293-20190114151443587-648000164.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 14 Jan 2019 07:22:00 +0000</pubDate>
<dc:creator>Imageshop</dc:creator>
<og:description>图像金字塔技术在很多层面上都有着广泛的应用，很多开源的工具也都有对他们的建立写了专门的函数，比如IPP，比如OpenCV等等，这方面的理论文章特别多，，但是大部多分开源的代码的实现都不是严格意义上的金</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Imageshop/p/10263676.html</dc:identifier>
</item>
<item>
<title>2018年终总结 - 阿星Plus</title>
<link>http://www.cnblogs.com/meowv/p/10266954.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/meowv/p/10266954.html</guid>
<description>&lt;p&gt;&lt;span&gt;不知不觉中，已经2019了，今天来写写我迟到的年终总结。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;时间真是个好东西啊，每个人每天都拥有短短的24小时，转眼间从毕业实习到正式工作都过去差不多两年了。如此多的24小时，真是值得回味呢！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;依稀记得，2018年2月19大年初四爸妈不舍的神情，因为路途遥远加上初七就要上班，不得不提前离开老家返程回到上海。路上我就在想，今年一定要努力工作，攒点钱孝敬孝敬父母，他们的年纪慢慢也大了，而我也老大不小了……&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;今年，利于闲暇时间看完了以下6本书，以及在读的就不列出了。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;《马伯庸笑翻中国简史》 ——马伯庸&lt;/span&gt;&lt;br/&gt;&lt;span&gt;《腾讯传》 ——吴晓波&lt;/span&gt;&lt;br/&gt;&lt;span&gt;《白说》 ——白岩松&lt;/span&gt;&lt;br/&gt;&lt;span&gt;《没事别随便思考人生》 ——鬼脚七&lt;/span&gt;&lt;br/&gt;&lt;span&gt;《看见》 ——柴静&lt;/span&gt;&lt;br/&gt;&lt;span&gt;《三体》 ——刘慈欣&lt;/span&gt;&lt;br/&gt;&lt;span&gt;读书，是我一直想做却一直没时间没坚持下去的一件事。现在是利用晚上睡觉前的时间进行阅读。书中的内容总是让人放松，可以领略作者笔下的世界。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我所在的公司还是老传统的WebForm开发模式，框架甚至还停留在.NET Framework 4，所有的系统软件都只能运行在Windows上面。所以自己今年系统学习了一下微软开源框架.NET Core的开发和使用，还利用周末，下班时间做了几个外包项目。了解并会简单使用开源监控软件Zabbix，利用Zabbix API二次开发获取数据与现有后台进行通信、结合百度开源图表神器ECharts，展示大屏报表数据、学会如何将开发的网站部署至Linux以及简单的Linux命令行学习、开发了一个具有多语言的内网穿透管理系统，充分体验了.NET Core的优越和便利。by the way，希望在以后的工作中，可以找.NET Core开发的相关工作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;工作上，一个项目接着一个项目的做着，需求是源源不断的，你会发现当你做完一件事情，总会有另外一件事情等着你的，公司是不可能让你闲下来，毕竟不养闲人嘛。以往的我总是焦虑，烦躁。现在的我则不会了。因为懂得了一个道理，事情总是源源不断的，不必去纠结烦恼，没有什么事是解决不了的，只要你静下心去想一想，思考一下解决办法，时间总是会证明这一切都是可以解决。在做项目写代码的时候也是一样的道理，没有解决不了的bug，没有完成不了的任务。不断去学习、思考，可以解决一切麻烦事。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在上海的一年又过去了，这一年没有回过一次家，所以向公司申请了四天年假买了1月28号的火车票想早一点回家多陪陪家人(请年假的这件事，期间出现了很多不愉快，之前V2EX社区闹得沸沸扬扬的帖子就是本人，详见：https://www.v2ex.com/t/522131，好在最后请假顺利)。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;写着写着，脑海出现了两首歌，《这个年纪》、《像我这样的人》。不是因为歌好听而是觉得歌词写得像自己。&lt;/p&gt;
&lt;p&gt;所以，加油吧少年，美好未来在明天。&lt;/p&gt;
</description>
<pubDate>Mon, 14 Jan 2019 07:20:00 +0000</pubDate>
<dc:creator>阿星Plus</dc:creator>
<og:description>不知不觉中，已经2019了，今天来写写我迟到的年终总结。 时间真是个好东西啊，每个人每天都拥有短短的24小时，转眼间从毕业实习到正式工作都过去差不多两年了。如此多的24小时，真是值得回味呢！</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/meowv/p/10266954.html</dc:identifier>
</item>
<item>
<title>ReentrantLock源码探究1:非公平锁的获取和释放 - LearnAndGet</title>
<link>http://www.cnblogs.com/LearnAndGet/p/10266581.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/LearnAndGet/p/10266581.html</guid>
<description>&lt;p&gt;​ Sync是ReentrantLock的一个内部类，它继承了AbstractQueuedSynchronizer，即AQS，在CountDownLatch、FutureTask、Semaphore、ReentrantLock等源码中，我们都能看到它们的身影，足见其重要性。此处我们需要先了解下AQS才能更愉悦地阅读源码。&lt;/p&gt;
&lt;p&gt;​ AQS中是基于FIFO队列的实现，那么它必然包含队列中元素的定义，在这里它是Node：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;12.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Node SHARED = new Node()&lt;/td&gt;
&lt;td&gt;表示Node处于共享模式&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Node EXCLUSIVE = null&lt;/td&gt;
&lt;td&gt;表示Node处于独占模式&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;int CANCELLED = 1&lt;/td&gt;
&lt;td&gt;因为超时或者中断，Node被设置为取消状态，被取消的Node不应该去竞争锁，只能保持取消状态不变，不能转换为其他状态，处于这种状态的Node会被踢出队列，被GC回收&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;int SIGNAL = -1&lt;/td&gt;
&lt;td&gt;表示这个Node的继任Node被阻塞了，到时需要通知它&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;int CONDITION = -2&lt;/td&gt;
&lt;td&gt;表示这个Node在条件队列中，因为等待某个条件而被阻塞&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;int PROPAGATE = -3&lt;/td&gt;
&lt;td&gt;使用在共享模式头Node有可能处于这种状态， 表示锁的下一次获取可以无条件传播&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;int waitStatus&lt;/td&gt;
&lt;td&gt;0，新Node会处于这种状态&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Node prev&lt;/td&gt;
&lt;td&gt;队列中某个Node的前驱Node&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Node next&lt;/td&gt;
&lt;td&gt;队列中某个Node的后继Node&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Thread thread&lt;/td&gt;
&lt;td&gt;这个Node持有的线程，表示等待锁的线程&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Node nextWaiter&lt;/td&gt;
&lt;td&gt;表示下一个等待condition的Node&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;AQS中包含的方法有&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;32.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;5&quot;&gt;&lt;td&gt;Thread exclusiveOwnerThread&lt;/td&gt;
&lt;td&gt;这个是AQS父类AbstractOwnableSynchronizer的属性，表示独占模式同步器的当前拥有者&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Node&lt;/td&gt;
&lt;td&gt;上面已经介绍过了，FIFO队列的基本单位&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Node head&lt;/td&gt;
&lt;td&gt;FIFO队列中的头Node&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;Node tail&lt;/td&gt;
&lt;td&gt;FIFO队列中的尾Node&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;int state&lt;/td&gt;
&lt;td&gt;同步状态，0表示未锁&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;int getState()&lt;/td&gt;
&lt;td&gt;获取同步状态&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;setState(int newState)&lt;/td&gt;
&lt;td&gt;设置同步状态&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td&gt;boolean compareAndSetState(int expect, int update)&lt;/td&gt;
&lt;td&gt;利用CAS进行State的设置&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;long spinForTimeoutThreshold = 1000L&lt;/td&gt;
&lt;td&gt;线程自旋等待的时间&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;Node enq(final Node node)&lt;/td&gt;
&lt;td&gt;插入一个Node到FIFO队列中&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;Node addWaiter(Node mode)&lt;/td&gt;
&lt;td&gt;为当前线程和指定模式创建并扩充一个等待队列&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;void setHead(Node node)&lt;/td&gt;
&lt;td&gt;设置队列的头Node&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;void unparkSuccessor(Node node)&lt;/td&gt;
&lt;td&gt;如果存在的话，唤起Node持有的线程&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;void doReleaseShared()&lt;/td&gt;
&lt;td&gt;共享模式下做释放锁的动作&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;void cancelAcquire(Node node)&lt;/td&gt;
&lt;td&gt;取消正在进行的Node获取锁的尝试&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td&gt;boolean shouldParkAfterFailedAcquire(Node pred, Node node)&lt;/td&gt;
&lt;td&gt;在尝试获取锁失败后是否应该禁用当前线程并等待&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;void selfInterrupt()&lt;/td&gt;
&lt;td&gt;中断当前线程本身&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;boolean parkAndCheckInterrupt()&lt;/td&gt;
&lt;td&gt;禁用当前线程进入等待状态并中断线程本身&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;5&quot;&gt;&lt;td&gt;boolean acquireQueued(final Node node, int arg)&lt;/td&gt;
&lt;td&gt;队列中的线程获取锁&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;tryAcquire(int arg)&lt;/td&gt;
&lt;td&gt;尝试获得锁（&lt;strong&gt;由AQS的子类实现它&lt;/strong&gt;）&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;tryRelease(int arg)&lt;/td&gt;
&lt;td&gt;尝试释放锁（&lt;strong&gt;由AQS的子类实现它&lt;/strong&gt;）&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;isHeldExclusively()&lt;/td&gt;
&lt;td&gt;是否独自持有锁&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;acquire(int arg)&lt;/td&gt;
&lt;td&gt;获取锁&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;release(int arg)&lt;/td&gt;
&lt;td&gt;释放锁&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;compareAndSetHead(Node update)&lt;/td&gt;
&lt;td&gt;利用CAS设置头Node&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;compareAndSetTail(Node expect, Node update)&lt;/td&gt;
&lt;td&gt;利用CAS设置尾Node&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;6&quot;&gt;&lt;td&gt;compareAndSetWaitStatus(Node node, int expect, int update)&lt;/td&gt;
&lt;td&gt;利用CAS设置某个Node中的等待状态&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;另外在源码中多处使用了CAS，有关CAS的内容，可查看：&lt;/strong&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/LearnAndGet/p/9768795.html&quot;&gt;乐观锁的一种实现方式:CAS&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;假设有两个线程：线程1和线程2尝试获取同一个锁（非公平锁），过程如下&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;线程1调用lock方法&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    final void lock() {
        if (compareAndSetState(0, 1))   //使用CAS将同步状态设置为1
            setExclusiveOwnerThread(Thread.currentThread());//成功则设置线程1为当前锁的独占线程
        else
            acquire(1); //设置失败时，尝试获取锁
    }
//上述代码正常情况下执行完毕后，线程1成为了独占线程。&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;线程2此时也尝试获取锁，调用lock方法，此时CAS设置时会失败，进入acquire方法。&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public final void acquire(int arg) {
    if (!tryAcquire(arg) &amp;amp;&amp;amp;
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt(); //重新获取锁失败且线程发生了中断，自行中断
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;这里面，会首先调用tryAcquire方法尝试再次获取锁，因为我们演示的是非公平锁，因此调用的方法是nonfairTryAcquire。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    final boolean nonfairTryAcquire(int acquires) {
        final Thread current = Thread.currentThread();  //current指向当前线程2
        int c = getState();      //若线程1未释放锁，则c&amp;gt;0，若线程1已经释放锁，则c=0
        if (c == 0) {            //线程1已经释放了锁
            if (compareAndSetState(0, acquires)) {  //使用CAS将state设置为1
                setExclusiveOwnerThread(current);   //并设置线程2为独占线程
                return true;    //返回true，获取锁成功
            }
        }
        //判断该线程是否是重入，即之前已经获取到了锁
        else if (current == getExclusiveOwnerThread()) {
            int nextc = c + acquires; //每重入一次，将state+1。
            if (nextc &amp;lt; 0) // overflow //state+1&amp;lt;0，说明原state为负数，抛出异常
                throw new Error(&quot;Maximum lock count exceeded&quot;);
            setState(nextc);    //设置state为新值
            return true;        //返回true，获取重入锁成功。
        }
        return false;           //返回flase，获取锁失败
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;此时线程2使用tryAcquire方法获取锁，如果也是失败，那么，会调用addWaiter(Node.EXCLUSIVE)方法&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private Node addWaiter(Node mode) {  //此处mode为独占模式
    Node node = new Node(Thread.currentThread(), mode);//将当前线程(此处为线程2)绑定到新节点node上，并设置为独占模式
    // Try the fast path of enq; backup to full enq on failure
    Node pred = tail;   //获取原队列的尾节点pred
    if (pred != null) { //若原尾节点pred非空，则说明已经存在一个队列
        node.prev = pred;   //设置新节点node的前置为pred
        if (compareAndSetTail(pred, node)) {//使用CAS设置新的尾节点为node
            pred.next = node;   //设置pred的后置为node，建立双向链接
            return node;        //返回node
        }
    }
    enq(node);      //进入此处说明原队列不存在，需要初始化队列
    return node;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private Node enq(final Node node) { //此处传入的参数node是绑定了线程2的节点
    for (;;) {
        Node t = tail;      //获取原队列的尾节点t
        if (t == null) { // Must initialize //若尾节点为空，说明队列尚未形成
            if (compareAndSetHead(new Node())) //设置一个空的，未绑定任何线程的节点为新队列的头节点
                tail = head;    //新队列只有一个节点，既是头也是尾
        } else {        //若t非空，说明队列已经形成
            node.prev = t;  //将node的前置设为t
            if (compareAndSetTail(t, node)) { //CAS设置新的尾节点为node
                t.next = node;  //设置t的后继为node，建立双向链接
                return t;       //返回t
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;现在看外层方法acquireQueued，此时传入的参数node是线程2所在节点，该方法的作用是在等待队列中，当有其他线程释放了资源，那么队列中在等待的线程就可以开始行动&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;final boolean acquireQueued(final Node node, int arg) {
    boolean failed = true; //是否获取到资源
    try {
        boolean interrupted = false; //等待过程中是否被中断
        //自旋，维护等待队列中线程的执行。
        for (;;) {
            final Node p = node.predecessor(); //获取node的前置p
            if (p == head &amp;amp;&amp;amp; tryAcquire(arg)) { //若前置p为头结点并且重新获取锁成功
                setHead(node);                  //设置新的头节点为node
                p.next = null; // help GC       //取消p和链表的链接
                failed = false;                 //获取资源未失败
                return interrupted;             //等待过程未被中断
            }
            if (shouldParkAfterFailedAcquire(p, node) &amp;amp;&amp;amp;  //若前置节点是Node.SIGNAL状态
                parkAndCheckInterrupt())        //将节点设置为Waitting状态
                interrupted = true;   //此时线程中断状态为true
        }
    } finally { 
        if (failed)                   //如果获取资源成功那么取消获取过程
            cancelAcquire(node);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {
        int ws = pred.waitStatus;    //获取前置节点的等待状态
        if (ws == Node.SIGNAL)      //Node.SIGNAL表示继任者线程需要被唤醒，那么就可以直接返回；
            /*
             * This node has already set status asking a release
             * to signal it, so it can safely park.
             */
            return true;
        if (ws &amp;gt; 0) {       //若ws&amp;gt;0，说明前驱被取消，那么执行循环往前一直查找，知道找到未被取消的，将node排在它的后面。
            /*
             * Predecessor was cancelled. Skip over predecessors and
             * indicate retry.
             */
            do {
                node.prev = pred = pred.prev;
            } while (pred.waitStatus &amp;gt; 0);
            pred.next = node;
        } else {   //进入else，说明ws=0或者Node.PROPAGATE
            /*
             * waitStatus must be 0 or PROPAGATE.  Indicate that we
             * need a signal, but don't park yet.  Caller will need to
             * retry to make sure it cannot acquire before parking.
             */
            //使用CAS设置前置的节点状态为Node.SIGNAL
            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);
        }
        return false;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该部分代码可以用现实中排队办理业务的情况来说明：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;假设你排队去办理业务，队伍很长，因此除了当前正在办理业务的人，其他所有排队的人都在低头玩手机，且每个排队的人有以下三种状态：①.正常排队，且办完业务后会通知后面的人别玩手机了可以开始办理业务了。②.发现队伍过长，不排队了，走了。③.正常排队，办完业务后不通知后面的人，直接走。
   此时你进入该队伍的尾部开始排队。
1.第一步，判断排队在你前面的人是否会通知你，如果会通知，那么我们就可以不用关心其他问题，在队列中待着玩手机即可。
2.第二步，如果发现排在你前面的人不排队了，要走了，那么此时我们就得往前走一位，并开始不断询问前面的人是不是也准备不排队了，直到我们排在了一个确定不会走的人后面。
3.第三步，排在你前面的人不是准备走的，但是他也不会通知你，那么你就要告诉他，一定得在办完业务后通知你。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当我们确定我们已经在队列中待好后(前置会通知我们)，那么我们就可以开始休息。parkAndCheckInterrupt方法让我们的线程进入等待的状态，即休息状态。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private final boolean parkAndCheckInterrupt() {
    LockSupport.park(this);  //调用park()使线程进入waiting状态
    return Thread.interrupted(); //如果被唤醒，查看自己是不是被中断的。   
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1084627/201901/1084627-20190114144151712-2108346834.png&quot;/&gt;&lt;/p&gt;

&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void unlock() {
    sync.release(1);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public final boolean release(int arg) {
    if (tryRelease(arg)) {  //若tryRelease后无人占用锁
        Node h = head;      //获取队列的头结点h
        if (h != null &amp;amp;&amp;amp; h.waitStatus != 0) //若h非空，且h的waitStatus不为0
            unparkSuccessor(h);     //唤醒后继
        return true;
    }
    return false;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    protected final boolean tryRelease(int releases) {
        int c = getState() - releases;  //当前state-1，得到c
        if (Thread.currentThread() != getExclusiveOwnerThread()) //执行releas的不是获取锁的独占线程，抛出异常
            throw new IllegalMonitorStateException();
        boolean free = false;   //free用来标记锁是否可获取状态
        if (c == 0) {           //若state=0
            free = true;        //那么当前锁是可获取的
            setExclusiveOwnerThread(null);  //设置当前锁的独占线程为null
        }
        setState(c);            //设置当前state为c
        return free;            //返回锁是否是可获取状态
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt; private void unparkSuccessor(Node node) {
        /*
         * If status is negative (i.e., possibly needing signal) try
         * to clear in anticipation of signalling.  It is OK if this
         * fails or if status is changed by waiting thread.
         */
        int ws = node.waitStatus; //获取当前线程对应节点的waitStatus
        if (ws &amp;lt; 0)              //将当前线程对应节点waitStatus置为0
            compareAndSetWaitStatus(node, ws, 0);

        /*
         * Thread to unpark is held in successor, which is normally
         * just the next node.  But if cancelled or apparently null,
         * traverse backwards from tail to find the actual
         * non-cancelled successor.
         */
        Node s = node.next;     //获取当前线程对应节点的后继节点s
        if (s == null || s.waitStatus &amp;gt; 0) { //若s为空或s的状态是canceled
            s = null;                        //将s设置为null。
            for (Node t = tail; t != null &amp;amp;&amp;amp; t != node; t = t.prev)
                if (t.waitStatus &amp;lt;= 0)  //此处从尾到头进行遍历，找到队列最前列的节点且状态不是Canceled，将其设置为s。但此处为何从尾部开始遍历尚未弄清楚。
                    s = t;
        }
        if (s != null)      //若上述遍历找到的s非空
            LockSupport.unpark(s.thread);  //调用lockSupport.unpark唤醒s对应的线程
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;release方法的逻辑仍然可以用一个办理完业务的人的后续动作来进行说明：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1.若A办理业务后无其他业务需要办理，那么表示当前业务窗口是free的。
2.A将自己的等待状态置为0，相当于退出队列。然后检查自己后面的人是否是空或者取消排队的状态。若为真，将后置设为空。
3.从队列的尾部遍历到头部，直到找到队列最前头的那个，且它的等待状态不是取消状态，那么将其唤醒，告知他可以开始办理业务了。&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;本文中部分源码本人暂时也尚未能理解，希望各位大佬不吝赐教&lt;/strong&gt;，主要有以下一些问题：&lt;br/&gt;1.在unparkSuccessor方法中，找到队列下一个节点并将其唤醒时，为什么从尾到头遍历&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;        if (s == null || s.waitStatus &amp;gt; 0) { //若s为空或s的状态是canceled
            s = null;                        //将s设置为null。
            for (Node t = tail; t != null &amp;amp;&amp;amp; t != node; t = t.prev)
                if (t.waitStatus &amp;lt;= 0)    //倒序遍历？
                    s = t;
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.在acquireQueued方法中，自旋结束后的finally代码块的作用。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;final boolean acquireQueued(final Node node, int arg) {
    boolean failed = true; //是否获取到资源
    try {
        boolean interrupted = false; //等待过程中是否被中断
        //自旋，维护等待队列中线程的执行。
        for (;;) {
            final Node p = node.predecessor(); //获取node的前置p
            if (p == head &amp;amp;&amp;amp; tryAcquire(arg)) { //若前置p为头结点并且重新获取锁成功
                setHead(node);                  //设置新的头节点为node
                p.next = null; // help GC       //取消p和链表的链接
                failed = false;                 //获取资源未失败
                return interrupted;             //等待过程未被中断
            }
            if (shouldParkAfterFailedAcquire(p, node) &amp;amp;&amp;amp;  //若前置节点是Node.SIGNAL状态
                parkAndCheckInterrupt())        //将节点设置为Waitting状态
                interrupted = true;   //此时线程中断状态为true
        }
    } finally { 
        if (failed)                       //如果自旋结束，那么说明failed = false已经执行了，那么这个canclAcquire方法什么情况下会执行？
            cancelAcquire(node);
    }
}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Mon, 14 Jan 2019 07:13:00 +0000</pubDate>
<dc:creator>LearnAndGet</dc:creator>
<og:description>1.AQS简单介绍 ​ Sync是ReentrantLock的一个内部类，它继承了AbstractQueuedSynchronizer，即AQS，在CountDownLatch、FutureTask、</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/LearnAndGet/p/10266581.html</dc:identifier>
</item>
<item>
<title>不懂区块链？先来看一下这篇 - crawl+</title>
<link>http://www.cnblogs.com/crawl/p/10253564.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/crawl/p/10253564.html</guid>
<description>&lt;p&gt;原创播客，如需转载请注明出处。原文地址：&lt;a href=&quot;https://www.cnblogs.com/crawl/p/10253564.html&quot;&gt;&lt;span&gt;https://www.cnblogs.com/crawl/p/10253564.html&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;----------------------------------------------------------------------------------------------------------------------------------------------------------&lt;/p&gt;
&lt;p&gt;笔记中提供了必要的代码示例，需要说明的是，大部分代码示例都是本人所敲代码并进行测试，不足之处，请大家指正~&lt;/p&gt;
&lt;p&gt;本博客中所有言论仅代表博主本人观点，若有疑惑或者需要本系列分享中的资料工具，敬请联系 &lt;span&gt;qingqing_crawl@163.com&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;-----------------------------------------------------------------------------------------------------------------------------------------------------------&lt;/p&gt;
&lt;p&gt;      从最初开始学习 JavaEE，到自学大数据，现在实习在做区块链方面的东西，也算是一边实习，一边学习。忙完了一阵工作，总结一下实习四个月来所学到的知识，希望能够对自己和别人有所帮助。&lt;/p&gt;
&lt;p&gt;      要说区块链，我想先从从比特币说起……&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一、比特币的基本信息&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. 什么是比特币&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;  1）比特币系统：一个软件，每个人都可以下载运行，大家都维护一个版本&lt;/p&gt;
&lt;p&gt;  2）比特币：比特币系统所维护账本上的交易数字（为了完成支付功能而产生的交易数字）&lt;/p&gt;
&lt;p&gt;  3）区块链：（简单提一下区块链）一个数字账本，记录各种交易数字，是伴随比特币在系统中流通而产生的概念&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;2. 比特币和区块链的关系&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;1）&lt;span&gt;比特币是区块链技术的落地应用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2）区块链是比特币的底层&lt;span&gt;支撑系统&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3）区块链是从比特币中抽离出来的概念&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;二、比特币区块链使用的基本技术&lt;/p&gt;
&lt;p&gt;1. &lt;span&gt;Hash 算法&lt;/span&gt;（用于工作量的证明）&lt;/p&gt;
&lt;blockquote readability=&quot;14&quot;&gt;
&lt;p&gt;1）作用：将任意长度的输入格式化为固定长度的 16 进制字符串&lt;/p&gt;
&lt;p&gt;2）主流算法：MD5（128位）、sha256（256位）&lt;/p&gt;
&lt;p&gt;3）性质&lt;/p&gt;
&lt;p&gt;  ① &lt;span&gt;抗碰撞性&lt;/span&gt;：当知道一个 x，无法求出一个 y，使 x 和 y 的 Hash 值相同&lt;/p&gt;
&lt;p&gt;  ② &lt;span&gt;原&lt;/span&gt;&lt;span&gt;像不可逆性&lt;/span&gt;：根据 x 的 Hash 值无法求出 x&lt;/p&gt;
&lt;p&gt;  ③ &lt;span&gt;谜&lt;/span&gt;&lt;span&gt;题友好性&lt;/span&gt;：计算 Hash 的时候，没有捷径可走，若想计算出预定的 Hash 值，只能一次次的尝试 （这是 &lt;span&gt;pow 共识机制的基础&lt;/span&gt;）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;2. &lt;span&gt;&lt;span&gt;密&lt;/span&gt;&lt;span&gt;码学&lt;/span&gt;&lt;/span&gt;（用于资产所有权和交易的验证）&lt;/p&gt;
&lt;blockquote readability=&quot;20&quot;&gt;
&lt;p&gt;1）对称加密：A、B 双方使用同一把秘钥&lt;/p&gt;
&lt;p&gt;2）&lt;span&gt;非对称加密&lt;/span&gt;（生成公私钥）&lt;/p&gt;
&lt;p&gt;  ① 介绍：公钥和私钥一一对应，&lt;span&gt;公钥负责加密对外公开；私钥用于解密和签名&lt;/span&gt;，决不能外露&lt;/p&gt;
&lt;p&gt;  ② 公钥：用对方的公钥加密，对方用自己的私钥解密，因为私钥自己持有，且公钥无法解密，可以保证安全&lt;/p&gt;
&lt;p&gt;  ③ 私钥：签名，保证数据来源，保证数据未被篡改，但不能保证数据安全&lt;/p&gt;
&lt;p&gt;  ④ 常用算法：RSA、ECC&lt;/p&gt;
&lt;p&gt;  ⑤ 特点：安全性高、加解密复杂、效率低&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;3. 编码（用于网络传输、生成地址等）&lt;/p&gt;
&lt;p&gt;  区块链底层较为常用的编码方式是 &lt;span&gt;base64&lt;/span&gt; 编码&lt;/p&gt;
&lt;p&gt;4. &lt;span&gt;p2p 网络&lt;/span&gt;（点对点、端对端）&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;1）介绍：&lt;span&gt;点对点技术&lt;/span&gt;，&lt;span&gt;无中心的服务器&lt;/span&gt;，依靠用户群交换信息的互联网体系&lt;/p&gt;
&lt;p&gt;2）特点：耐攻击、高容错、地位平等&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;5. 默克尔树（用于快速交易验证）&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;1）介绍：Merkle Tree，通常也被称为 Hash Tree，是&lt;span&gt;存储 Hash&lt;/span&gt; 值的一棵树，Merkle Tree 的&lt;span&gt;叶子是数据块的 Hash 值&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2）特点：二叉树&lt;/p&gt;
&lt;p&gt;3）应用：可快速检索，由其是在数量猛增时，搜索效率高（&lt;span&gt;比特币中可以用来校验某一笔交易是否存在某个区块中&lt;/span&gt;）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;6. &lt;span&gt;工作量证明&lt;/span&gt;（Proof Of Work）&lt;/p&gt;
&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;1）比特币的 POW 要求运行一个 Hash 算法（sha256），&lt;span&gt;找到一个符合要求的 Block Hash&lt;/span&gt;（Block Hash = sha256（区块信息+&lt;span&gt;随机值n&lt;/span&gt;）），该 Hash 值由 n 个前导 0 构成，&lt;span&gt;零的个数取决于网络的难度值&lt;/span&gt;。要找到合理的 Block Hash 需要经过大量的尝试计算，计算时间取决于机器的 Hash 运算速度。&lt;/p&gt;
&lt;p&gt;2）工作量证明的过程：生成 Coinbase 交易，并&lt;span&gt;与其他所有准备打包进区块的交易组成交易列表&lt;/span&gt;，通过 Merkle Tree 算法生成 Merkle Tree Hash，把 Merkle Tree Hash 及其他相关字段组装成区块头，将区块头的 80 字节数据（Block Header）作为工作量证明的输入不停的变更区块头中的随机数即 nonce 值，并对每次变更够的区块头做双重 SHA256 运算（即 SHA256（SHA256（Block_Header））），将结果与当前网络的目标值做对比，如果小于目标值，则解题成功，工作量证明完成&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;三、比特币的区块结构&lt;/p&gt;
&lt;p&gt;1. 区块结构&lt;/p&gt;
&lt;p&gt;比特币的区块结构由&lt;span&gt;区块大小、区块头、交易计数器、交易&lt;/span&gt;组成&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/1105175/201901/1105175-20190114095338354-1295848913.png&quot;&gt;&lt;img title=&quot;1&quot; src=&quot;https://img2018.cnblogs.com/blog/1105175/201901/1105175-20190114095339270-1497943252.png&quot; alt=&quot;1&quot; width=&quot;616&quot; height=&quot;211&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2. 区块头&lt;/p&gt;
&lt;p&gt;区块头的信息主要包括&lt;span&gt;版本、父区块头的哈希值、Merkle根、时间戳、难度目标、Nonce&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/1105175/201901/1105175-20190114100114295-628546436.png&quot;&gt;&lt;img title=&quot;2&quot; src=&quot;https://img2018.cnblogs.com/blog/1105175/201901/1105175-20190114100115079-2019423955.png&quot; alt=&quot;2&quot; width=&quot;613&quot; height=&quot;256&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3. 区块体（交易）&lt;/p&gt;
&lt;p&gt;1）&lt;span&gt;Coinbase 交易&lt;/span&gt;：&lt;span&gt;第一条交易、挖矿交易&lt;/span&gt;（没有支付人，只有收款人，即矿工）；每一个区块都有一个 Coinbase 交易&lt;/p&gt;
&lt;p&gt;2）普通转账交易：每笔交易包括付款方、收款方、付款金额、手续费等&lt;/p&gt;
&lt;p&gt;4. 完整结构图&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/1105175/201901/1105175-20190114100115830-529216460.png&quot;&gt;&lt;img title=&quot;3&quot; src=&quot;https://img2018.cnblogs.com/blog/1105175/201901/1105175-20190114100116575-437572875.png&quot; alt=&quot;3&quot; width=&quot;624&quot; height=&quot;386&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;四、交易&lt;/p&gt;
&lt;p&gt;&lt;span&gt;UTXO&lt;/span&gt;（unspent transaction output）：&lt;span&gt;未消费输出&lt;/span&gt;，是比特币交易中最小的支付单元，不可分割，每一个 UTXO 必须一次性消耗完，然后形成新的 UTXO，存放在比特币网络的 UTXO 池中&lt;/p&gt;
&lt;p&gt;一、区块链的基本信息&lt;/p&gt;
&lt;p&gt;1. 什么是区块链&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;伴随比特币而生，是一个&lt;span&gt;分布式数据库&lt;/span&gt;（本质）；一种&lt;span&gt;网络底层协议&lt;/span&gt;（抽象）；&lt;span&gt;存储引擎、计算引擎&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;2. 区块链的特点&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;1）&lt;span&gt;去中心化&lt;/span&gt;：所有参与其中的网络节点共同维护，无需中心节点控制&lt;/p&gt;
&lt;p&gt;2）&lt;span&gt;不可篡改&lt;/span&gt;：一旦发出交易便不可再修改和删除，每笔交易和每个区块都有时间戳&lt;/p&gt;
&lt;p&gt;3）匿名性：私钥和地址是使用网络的所有条件，无需身份验证&lt;/p&gt;
&lt;p&gt;4）可追溯性&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;二、区块链协议&lt;/p&gt;
&lt;p&gt;区块链是一种网络底层协议，可以分为数据层、网络层、共识层、激励层、合约层、应用层&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/1105175/201901/1105175-20190114113252305-49741558.png&quot;&gt;&lt;img title=&quot;4&quot; src=&quot;https://img2018.cnblogs.com/blog/1105175/201901/1105175-20190114113253244-2119100765.png&quot; alt=&quot;4&quot; width=&quot;633&quot; height=&quot;454&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;1. 数据层&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;区块链数据、链式结构、哈希函数、Merkel树、非对称加密、时间戳。数据层需要突破的是区块容量的问题&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;2. 网络层&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;P2P 网络、传播机制、验证机制（自组网）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;3. &lt;span&gt;共识层&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;共识机制：&lt;span&gt;可以使所有的节点对某一状态达成一致的方式，有共识机制去中心化才有意义，才具备可信度，否则只是数据共享&lt;/span&gt;。目前主流的共识机制有：&lt;span&gt;POW&lt;/span&gt;、POS、DPOS、&lt;span&gt;PBFT&lt;/span&gt;等&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;54&quot;&gt;
&lt;p&gt;1）&lt;span&gt;POW&lt;/span&gt;（Proof of Work）：工作量证明&lt;/p&gt;
&lt;p&gt;  特点：算一道很难的谜题，系统给予挖矿奖励；多劳多得&lt;/p&gt;
&lt;p&gt;  优点：&lt;/p&gt;
&lt;p&gt;     ① 所有节点均可参与，记账权公平的分派到每个节点，去中心化&lt;/p&gt;
&lt;p&gt;     ② 多劳多得，矿工的积极性高&lt;/p&gt;
&lt;p&gt;     ③ 安全性高，欺诈成本高，如果能够欺诈成功，那么做诚实节点收益更大&lt;/p&gt;
&lt;p&gt;  缺点：&lt;/p&gt;
&lt;p&gt;     ① 主流矿池垄断严重，存在51%算力攻击风险&lt;/p&gt;
&lt;p&gt;     ② 浪费资源严重（2018年底消耗全球0.5%的电量）&lt;/p&gt;
&lt;p&gt;     ③ 持币人没有话语权，算力决定一切&lt;/p&gt;
&lt;p&gt;     ④ &lt;span&gt;网络性能低，共识时间长&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;  项目：比特币、以太坊、比原链等&lt;/p&gt;
&lt;p&gt;2）POS（Proof of Stake）：股权证明，根据持有货币的量和时间来发利息（币天销毁）&lt;/p&gt;
&lt;p&gt;  特点：&lt;/p&gt;
&lt;p&gt;     ① 不挖矿，依靠币龄（持币数量 * 持有天数）决定记账权，利息即为奖励&lt;/p&gt;
&lt;p&gt;     ② 按钱分配，钱生钱&lt;/p&gt;
&lt;p&gt;  优点：&lt;/p&gt;
&lt;p&gt;     ① 在一定程度上缩短了共识打成的时间&lt;/p&gt;
&lt;p&gt;     ② 节约资源&lt;/p&gt;
&lt;p&gt;     ③ 防作弊，币龄越大，获得记账权几率越大、避免51%攻击，因为攻击会使自己的权益受损&lt;/p&gt;
&lt;p&gt;  缺点：数字货币过于集中化，富有者越来越富有，散户参与积极性低&lt;/p&gt;
&lt;p&gt;3）DPOS（Delegated Proof of Stake）：委托权益证明&lt;/p&gt;
&lt;p&gt;  让每一个持有币的人进行投票，由此产生 n 个代表，可以理解为 n 个超级节点或矿池，这 n 个超级节点彼此的权利是完全相等的&lt;/p&gt;
&lt;p&gt;  特点：不挖矿，每年按比例增发代币，奖励超级节点&lt;/p&gt;
&lt;p&gt;  优点：高效、扩展性强&lt;/p&gt;
&lt;p&gt;  缺点：非去中心化，而是多中心化&lt;/p&gt;
&lt;p&gt;  项目：EOS&lt;/p&gt;
&lt;p&gt;4）&lt;span&gt;PBFT&lt;/span&gt; 后期会单独讲解&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;4. 激励层：发行机制，分配机制&lt;/p&gt;
&lt;p&gt;5. 合约层&lt;/p&gt;
&lt;blockquote readability=&quot;29&quot;&gt;
&lt;p&gt;&lt;span&gt;智能合约&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;  定义：一个智能合约是一套以数字形式定义的承诺，包括参与方可以在上面执行这些承诺的协议&lt;/p&gt;
&lt;p&gt;  本质：数字化合同&lt;/p&gt;
&lt;p&gt;  特点：代码代替人仲裁和执行合同，同时能够触发支付&lt;/p&gt;
&lt;p&gt;  1）构建：&lt;span&gt;本地构建&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;     智能合约由区块链内的多个用户共同参与制定，可用于用户之间的任何交易行为。协议种明确了双方的权利和义务，开发人员将这些权利和义务以电子化的方式进行编程，代码中包含会触发合约自动执行的条件&lt;/p&gt;
&lt;p&gt;  2）存储：&lt;span&gt;链上存储&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;     一旦编码完成，这份智能合约就被上传到区块链网络上，即全网验证节点都会收到你和对方的合约&lt;/p&gt;
&lt;p&gt;  3）执行：&lt;span&gt;EVM 中执行&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;     ① 智能合约会定期检查是否存在相关事件和触发条件，满足条件的事件将会推送到待验证的队列中&lt;/p&gt;
&lt;p&gt;     ② 区块链上的验证节点先对该事件进行验证签名，以确保其有效性；等大多数验证节点对该事件达成共识后，智能合约将成功执行，并通知用户&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;6. 应用层：业务逻辑&lt;/p&gt;
&lt;p&gt;三、区块链的分类&lt;/p&gt;
&lt;p&gt;按应用场景可分为：&lt;/p&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;1）&lt;span&gt;公有链&lt;/span&gt;：所有人都可以随时加入和退出，每个节点平等，都有权交易和记账，属于开放式      代表：比特币、以太坊等&lt;/p&gt;
&lt;p&gt;2）&lt;span&gt;联盟链&lt;/span&gt;：仅部分人参与，加入和退出需要授权，选定某些节点为记账人，其他人可以交易，但无记账权，属于半封闭式     代表：R3CEV、IBM Farbric&lt;/p&gt;
&lt;p&gt;3）&lt;span&gt;私有链&lt;/span&gt;：公司内部使用，可实现更好的权限控制，管理和审计，属于半封闭式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;四、区块链的相关概念&lt;/p&gt;
&lt;blockquote readability=&quot;44&quot;&gt;
&lt;p&gt;1. 矿工：由运行比特币客户端的节点充当，竞争记账权，从而获得奖励&lt;/p&gt;
&lt;p&gt;2. 矿机：CPU挖矿 —&amp;gt; GPU挖矿 –&amp;gt; FPGA挖矿 –&amp;gt; ASIC挖矿（专业矿机）&lt;/p&gt;
&lt;p&gt;3. 挖矿&lt;/p&gt;
&lt;p&gt;   1）矿场：集中矿机设备的场所&lt;/p&gt;
&lt;p&gt;   2）矿池：一个软件，矿场和普通矿工接入，矿池负责打包，接入的设备负责挖矿，按照贡献算力的比例来分配收益&lt;/p&gt;
&lt;p&gt;4. 算力：即计算能力，表明一个矿工挖矿的能力，算力越大算出 Hash 值的概率就越高&lt;/p&gt;
&lt;p&gt;5. 分叉：代码升级时不同社区意见发生分歧时的结果，出现重大 bug 修复会分叉&lt;/p&gt;
&lt;p&gt;   1）软分叉：旧节点接收新协议产生的区块，毫无感知，新老协议共同维护一条链&lt;/p&gt;
&lt;p&gt;   2）硬分叉：旧节点拒绝接收新节点创造的区块，从此分裂为两条独立的链（以太坊分叉）&lt;/p&gt;
&lt;p&gt;6. 叔块（孤块）&lt;/p&gt;
&lt;p&gt;在同一时间出现两个矿工同时挖出矿的情况，此时出现临时的分叉，区块链会同时保留两条链，并等待新生成的区块，新区块选择连接的链就是最长链，即主链，那么另外一个区块就被称为叔块（以太坊中的叔块是有奖励的，比特币中的叔块无奖励）。&lt;/p&gt;
&lt;p&gt;7. 节点&lt;/p&gt;
&lt;p&gt;    1）轻节点SPV（Simplifed Payment Verification）：手机端钱包，只同步所有区块头信息以及和自己相关的交易数据&lt;/p&gt;
&lt;p&gt;    2）全节点：包含账本的节点&lt;/p&gt;
&lt;p&gt;    联盟链中还可以细分为&lt;span&gt;共识节点、交易节点、账本节点、钱包节点、托管节点&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;8. 代币（Token）：创建交易以及运行智能合约运行的燃料，以太坊代币为 eth，燃料为 gas，最小单位为 wei&lt;/p&gt;
&lt;p&gt;9. 钱包：创建公私钥，保存私钥，相当于钱包，可以存放多个地址&lt;/p&gt;
&lt;p&gt;    种类：PC 钱包、手机钱包、轻节点钱包&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Mon, 14 Jan 2019 06:50:00 +0000</pubDate>
<dc:creator>crawl+</dc:creator>
<og:description>区块链基础知识总结</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/crawl/p/10253564.html</dc:identifier>
</item>
<item>
<title>如何打通CMDB，实现就近访问 - 阿里云云栖社区</title>
<link>http://www.cnblogs.com/yunqishequ/p/10266700.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yunqishequ/p/10266700.html</guid>
<description>&lt;p data-spm-anchor-id=&quot;a2c4e.11153940.blogcont684178.i0.259d17baFKDY1d&quot;&gt;CMDB在企业中，一般用于存放与机器设备、应用、服务等相关的元数据。当企业的机器及应用达到一定规模后就需要这样一个系统来存储和管理它们的元数据。有一些广泛使用的属性，例如机器的IP、主机名、机房、应用、region等，这些数据一般会在机器部署时录入到CMDB，运维或者监控平台会使用这些数据进行展示或者相关的运维操作。&lt;/p&gt;
&lt;p&gt;在服务进行多机房或者多地域部署时，跨地域的服务访问往往延迟较高，一个城市内的机房间的典型网络延迟在1ms左右，而跨城市的网络延迟，例如上海到北京大概为30ms。此时自然而然的一个想法就是能不能让服务消费者和服务提供者进行同地域访问。我们在集团内部的实践中，这样的需求是通过和CMDB打通来实现的。在Nacos的服务发现组件中，对接CMDB，然后通过配置的访问规则，来实现服务消费者到服务提供者的同地域优先。&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;image.png | center | 448x330&quot; src=&quot;https://cdn.nlark.com/lark/0/2018/png/15356/1544702277705-0bbfca60-6629-477c-92bb-1a690e68f9cd.png&quot; alt=&quot;image.png | center | 448x330&quot;/&gt;&lt;/p&gt;

&lt;div readability=&quot;7&quot;&gt;&lt;p&gt;图1 服务的同地域优先访问&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;这实际上就是一种负载均衡策略，在Nacos的规划中，丰富的服务端的可配置负载均衡策略是我们的重要发展方向，这与当前已有的注册中心产品不太一样。在设计如何在开源的场景中，支持就近访问的时候，与企业自带的CMDB集成是我们考虑的一个核心问题。除此之外，我们也在考虑将Nacos自身扩展为一个实现基础功能的CMDB。无论如何，我们都需要能够从某个地方获取IP的环境信息，这些信息要么是从企业的CMDB中查询而来，要么是从自己内置的存储中查询而来。&lt;/p&gt;
&lt;h2 id=&quot;1&quot;&gt;CMDB插件机制&lt;/h2&gt;
&lt;p&gt;先不考虑如何将CMDB的数据应用于负载均衡，我们需要首先在Nacos里将CMDB的数据通过某种方法获取。在实际使用中，基本上每个公司都会通过购买或者自研搭建自己的CMDB，那么为了能够解耦各个企业的CMDB具体实现，一个比较好的策略是使用SPI机制，约定CMDB的抽象调用接口，由各个企业添加自己的CMDB插件，无需任何代码上的重新构建，即可在运行状态下对接上企业的CMDB。&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;image.png | center | 295x394&quot; src=&quot;https://cdn.nlark.com/lark/0/2018/png/15356/1544842539697-cca20e3d-0f78-45b8-92b9-3b7559e838b2.png&quot; alt=&quot;image.png | center | 295x394&quot;/&gt;&lt;/p&gt;

&lt;div readability=&quot;7&quot;&gt;&lt;p&gt;图2 Nacos CMDB SPI机制原理&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;如图2所示，Nacos定义了一个SPI接口，里面包含了与第三方CMDB约定的一些方法。用户依照约定实现了相应的SPI接口后，将实现打成jar包放置到Nacos安装目录下，重启Nacos即可让Nacos与CMDB的数据打通。整个流程并不复杂，但是理解CMDB SPI接口里方法和相应概念的含义不太简单。在这里对CMDB机制的相关概念和接口含义做一个详细说明。&lt;/p&gt;
&lt;h2 id=&quot;2&quot;&gt;CMDB抽象概念&lt;/h2&gt;
&lt;h3 id=&quot;3&quot;&gt;实体（Entity）&lt;/h3&gt;
&lt;p&gt;实体是作为CMDB里数据的承载方，在一般的CMDB中，一个实体可以指一个IP、应用或者服务。而这个实体会有很多属性，例如IP的机房信息，服务的版本信息等。&lt;/p&gt;
&lt;h3 id=&quot;4&quot;&gt;实体类型（Entity Type）&lt;/h3&gt;
&lt;p&gt;我们并不限定实体一定是IP、应用或者服务，这取决于实际的业务场景。Nacos有计划在未来支持不同的实体类型，不过就目前来说，服务发现需要的实体类型是IP。&lt;/p&gt;
&lt;h3 id=&quot;5&quot;&gt;标签（Label）&lt;/h3&gt;
&lt;p&gt;Label是我们抽象出的Entity属性，Label定义为一个描述Entity属性的K-V键值对。Label的key和value的取值范围一般都是预先定义好的，当需要对Label进行变更，如增加新的key或者value时，需要调用单独的接口并触发相应的事件。一个常见的Label的例子是IP的机房信息，我们认为机房（site）是Label的key，而机房的集合（site1, site2, site3）是Label的value，这个Label的定义就是：site: {site1, site2, site3}。&lt;/p&gt;
&lt;h3 id=&quot;6&quot;&gt;实体事件（Entity Event）&lt;/h3&gt;
&lt;p&gt;实体的标签的变更事件。当CMDB的实体属性发生变化，需要有一个事件机制来通知所有订阅方。为了保证实体事件携带的变更信息是最新准确的，这个事件里只会包含变更的实体的标识以及变更事件的类型，不会包含变更的标签的值。&lt;/p&gt;
&lt;h2 id=&quot;7&quot;&gt;CMDB约定接口&lt;/h2&gt;
&lt;p&gt;在设计与CMDB交互接口的时候，我们参考了内部对CMDB的访问接口，并与若干个外部客户进行了讨论。我们最终确定了以下要求第三方CMDB插件必须实现的接口：&lt;/p&gt;
&lt;h3 id=&quot;8&quot;&gt;获取标签列表&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;java hljs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;Set&amp;lt;String&amp;gt; &lt;span class=&quot;hljs-title&quot;&gt;getLabelNames&lt;span class=&quot;hljs-params&quot;&gt;();&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个方法将返回CMDB中需要被Nacos识别的标签名集合，CMDB插件可以按需决定返回什么标签个Nacos。不在这个集合的标签将会被Nacos忽略，即使这个标签出现在实体的属性里。我们允许这个集合会在运行时动态变化，Nacos会定时去调用这个接口刷新标签集合。&lt;/p&gt;
&lt;h3 id=&quot;9&quot;&gt;获取实体类型&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;java hljs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;Set&amp;lt;String&amp;gt; &lt;span class=&quot;hljs-title&quot;&gt;getEntityTypes&lt;span class=&quot;hljs-params&quot;&gt;();&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;获取CMDB里的实体的类型集合，不在这个集合的实体类型会被Nacos忽略。服务发现模块目前需要的实体类似是ip，如果想要通过打通CMDB数据来实现服务的高级负载均衡，请务必在返回集合里包含“ip”。&lt;/p&gt;
&lt;h3 id=&quot;10&quot;&gt;获取标签详情&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;java hljs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;Label &lt;span class=&quot;hljs-title&quot;&gt;getLabel&lt;span class=&quot;hljs-params&quot;&gt;(String labelName);&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;获取标签的详细信息。返回的Label类里包含标签的名字和标签值的集合。如果某个实体的这个标签的值不在标签值集合里，将会被视为无效。&lt;/p&gt;
&lt;h3 id=&quot;11&quot;&gt;查询实体的标签值&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;java hljs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;String &lt;span class=&quot;hljs-title&quot;&gt;getLabelValue&lt;span class=&quot;hljs-params&quot;&gt;(String entityName, String entityType, String labelName);
&lt;span class=&quot;hljs-function&quot;&gt;Map&amp;lt;String, String&amp;gt; &lt;span class=&quot;hljs-title&quot;&gt;getLabelValues&lt;span class=&quot;hljs-params&quot;&gt;(String entityName, String entityType);&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里包含两个方法，一个是获取实体某一个标签名对应的值，一个是获取实体所有标签的键值对。参数里包含实体的值和实体的类型。注意，这个方法并不会在每次在Nacos内部触发查询时去调用，Nacos内部有一个CMDB数据的缓存，只有当这个缓存失效或者不存在时，才会去访问CMDB插件查询数据。为了让CMDB插件的实现尽量简单，我们在Nacos内部实现了相应的缓存和刷新逻辑。&lt;/p&gt;
&lt;h3 id=&quot;12&quot;&gt;查询实体&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;java hljs&quot;&gt;Map&amp;lt;String, Map&amp;lt;String, Entity&amp;gt;&amp;gt; getAllEntities();
&lt;span class=&quot;hljs-function&quot;&gt;Entity &lt;span class=&quot;hljs-title&quot;&gt;getEntity&lt;span class=&quot;hljs-params&quot;&gt;(String entityName, String entityType);&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查询实体包含两个方法：查询所有实体和查询单个实体。查询单个实体目前其实就是查询这个实体的所有标签，不过我们将这个方法与获取所有标签的方法区分开来，因为查询单个实体方法后面可能会进行扩展，比查询所有标签获取的信息要更多。&lt;/p&gt;
&lt;p&gt;查询所有实体则是一次性将CMDB的所有数据拉取过来，该方法可能会比较消耗性能，无论是对于Nacos还是CMDB。Nacos内部调用该方法的策略是通过可配置的定时任务周期来定时拉取所有数据，在实现该CMDB插件时，也请关注CMDB服务本身的性能，采取合适的策略。&lt;/p&gt;
&lt;h3 id=&quot;13&quot;&gt;查询实体事件&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;java hljs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;List&amp;lt;EntityEvent&amp;gt; &lt;span class=&quot;hljs-title&quot;&gt;getEntityEvents&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;long timestamp);&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个方法意在获取最近一段时间内实体的变更消息，增量的去拉取变更的实体。因为Nacos不会实时去访问CMDB插件查询实体，需要这个拉取事件的方法来获取实体的更新。参数里的timestamp为上一次拉取事件的时间，CMDB插件可以选择使用或者忽略这个参数。&lt;/p&gt;
&lt;h2 id=&quot;14&quot;&gt;CMDB插件开发流程&lt;/h2&gt;
&lt;p&gt;参考 https://github.com/nacos-group/nacos-examples，这里已经给出了一个示例plugin实现。&lt;br/&gt;具体步骤如下：&lt;/p&gt;
&lt;ol readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;新建一个maven工程，引入依赖nacos-api:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;plain&quot;&gt;        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.alibaba.nacos&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;nacos-api&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;0.7.0&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;引入打包插件：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;plain&quot;&gt;            &amp;lt;plugin&amp;gt;
                &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;maven-assembly-plugin&amp;lt;/artifactId&amp;gt;
                &amp;lt;configuration&amp;gt;
                    &amp;lt;descriptorRefs&amp;gt;
                        &amp;lt;descriptorRef&amp;gt;jar-with-dependencies&amp;lt;/descriptorRef&amp;gt;
                    &amp;lt;/descriptorRefs&amp;gt;
                &amp;lt;/configuration&amp;gt;
            &amp;lt;/plugin&amp;gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;定义实现类，继承com.alibaba.nacos.api.cmdb.CmdbService，并实现相关方法。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img title=&quot;image.png | center | 585x116&quot; src=&quot;https://cdn.nlark.com/lark/0/2018/png/15356/1543916500193-213df77a-096d-4fd9-a283-85241a856fbf.png&quot; alt=&quot;image.png | center | 585x116&quot;/&gt;&lt;/p&gt;
&lt;ol readability=&quot;-2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;在src/main/resource/目录下新建目录：META-INF/services&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img title=&quot;image.png | center | 379x96&quot; src=&quot;https://cdn.nlark.com/lark/0/2018/png/15356/1543916595978-fd322205-16c1-4a95-9cdc-4a6292ee3b66.png&quot; alt=&quot;image.png | center | 379x96&quot;/&gt;&lt;/p&gt;
&lt;ol readability=&quot;-1.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;在src/main/resources/META-INF/services目录下新建文件com.alibaba.nacos.api.cmdb.CmdbService，并在文件里将第三步中创建的实现类全名写入该文件:&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img title=&quot;image.png | left | 719x136&quot; src=&quot;https://cdn.nlark.com/lark/0/2018/png/15356/1545036650034-75d11aee-8738-485f-9426-52e560b059cd.png&quot; alt=&quot;image.png | left | 719x136&quot;/&gt;&lt;/p&gt;
&lt;ol readability=&quot;3&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;代码自测完成后，执行命令进行打包：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;plain&quot;&gt;mvn package assembly:single -Dmaven.test.skip=true&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;将target目录下的包含依赖的jar包上传到nacos CMDB插件目录：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;plain&quot;&gt;{nacos.home}/plugins/cmdb&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;在nacos的application.properties里打开加载插件开关：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;plain&quot;&gt;nacos.cmdb.loadDataAtStart=true&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;重启nacos Server，即可加载到您实现的nacos-cmdb插件获取您的CMDB数据。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;15&quot;&gt;使用Selector实现同机房优先访问&lt;/h2&gt;
&lt;p&gt;在拿到CMDB的数据之后，就可以运用CMDB数据的强大威力来实现多种灵活的负载均衡策略了，下面举例来说明如何使用CMDB数据和Selector来实现就近访问。&lt;/p&gt;
&lt;p&gt;假设目前Nacos已经通过CMDB拿到了一些IP的机房信息，且它们对应的标签信息如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;plain&quot;&gt;11.11.11.11
    site: x11

22.22.22.22
    site: x12

33.33.33.33
    site: x11

44.44.44.44
    site: x12

55.55.55.55
    site: x13&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;11.11.11.11、22.22.22.22、33.33.33.33、44.44.44.44和55.55.55.55.55都包含了标签site，且它们对应的值分别为x11、x12、x11、x12、x13。我们先注册一个服务，下面挂载IP11.11.11.11和22.22.22.22。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;image.png | left | 747x307&quot; src=&quot;https://cdn.nlark.com/lark/0/2018/png/15356/1545035855381-5d9dcfad-75ab-43ad-a084-8ae4a65f914c.png&quot; alt=&quot;image.png | left | 747x307&quot;/&gt;&lt;/p&gt;

&lt;div&gt;&lt;p&gt;图3 服务详情&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;然后我们修改服务的“服务路由类型”，并配置为基于同site优先的服务路由：&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;image.png | center | 610x499&quot; src=&quot;https://cdn.nlark.com/lark/0/2018/png/15356/1545035973200-497c0649-b652-4c36-bf6c-7cddfc5b75c6.png&quot; alt=&quot;image.png | center | 610x499&quot;/&gt;&lt;/p&gt;

&lt;div readability=&quot;7&quot;&gt;&lt;p&gt;图4 编辑服务路由类型&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;这里我们将服务路由类型选择为标签，然后输入标签的表达式：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;plain&quot;&gt;CONSUMER.label.site = PROVIDER.label.site&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个表达式的格式和我们抽象的Selector机制有关，具体将会在另外一篇文章中介绍。在这里您需要记住的就是，任何一个如下格式的表达式：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;plain&quot;&gt;CONSUMER.label.labelName = PROVIDER.label.labelName&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将能够实现基于同labelName优先的负载均衡策略。&lt;/p&gt;
&lt;p&gt;然后假设服务消费者的IP分别为33.33.33.33、44.44.44.44和55.55.55.55，它们在使用如下接口查询服务实例列表：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs css&quot;&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;naming&lt;span class=&quot;hljs-selector-class&quot;&gt;.selectInstances(&quot;&lt;span class=&quot;hljs-selector-tag&quot;&gt;nacos&lt;span class=&quot;hljs-selector-class&quot;&gt;.test&lt;span class=&quot;hljs-selector-class&quot;&gt;.1&quot;, &lt;span class=&quot;hljs-selector-tag&quot;&gt;true)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么不同的消费者，将获取到不同的实例列表。33.33.33.33获取到11.11.11.11，44.44.44.44将获取到22.22.22.22，而55.55.55.55将同时获取到11.11.11.11和22.22.22.22。&lt;/p&gt;
&lt;p data-spm-anchor-id=&quot;a2c4e.11153940.blogcont684178.i1.259d17baFKDY1d&quot;&gt;以上，便是我们在Nacos中通过打通CMDB，实现就近访问的实践。&lt;/p&gt;
&lt;p data-spm-anchor-id=&quot;a2c4e.11153940.blogcont684178.i1.259d17baFKDY1d&quot;&gt; &lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;a href=&quot;https://yq.aliyun.com/articles/684178?utm_content=g_1000037425&quot; target=&quot;_blank&quot;&gt;原文链接&lt;/a&gt;&lt;br/&gt;本文为云栖社区原创内容，未经允许不得转载。&lt;/p&gt;
</description>
<pubDate>Mon, 14 Jan 2019 06:48:00 +0000</pubDate>
<dc:creator>阿里云云栖社区</dc:creator>
<og:description>CMDB在企业中，一般用于存放与机器设备、应用、服务等相关的元数据。当企业的机器及应用达到一定规模后就需要这样一个系统来存储和管理它们的元数据。有一些广泛使用的属性，例如机器的IP、主机名、机房、应用</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yunqishequ/p/10266700.html</dc:identifier>
</item>
<item>
<title>sql注入篇2 - windy_2</title>
<link>http://www.cnblogs.com/aWxvdmVseXc0/p/10266186.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/aWxvdmVseXc0/p/10266186.html</guid>
<description>&lt;p&gt;一、前言&lt;/p&gt;
&lt;p&gt;　　上一篇：&lt;a href=&quot;https://www.cnblogs.com/aWxvdmVseXc0/p/10255140.html&quot; target=&quot;_blank&quot;&gt;sql注入篇1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;二、基于回显的注入类型判断&lt;/p&gt;
&lt;p&gt;　　1、有结果的注入&lt;/p&gt;
&lt;p&gt;　　　　例如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1416477/201901/1416477-20190114124723614-174883086.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（sqlllab less-1）可以看到有正常结果返回，对于的利用方式就是老套路了，先order by查询出当前语句查询的列数，在使用union查询一一爆数据，当然，也可以使用脚本直接脱库。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1416477/201901/1416477-20190114125236594-2092832299.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1416477/201901/1416477-20190114125549853-1856145434.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　2、基于布尔值的注入&lt;/p&gt;
&lt;p&gt;　　　　通俗来说，就是盲注，回显的页面不会出现任何有关数据的结果，但会显示一些特殊的显示，可以判断我们猜测正确与否。例如下图（sqllab less-5）:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1416477/201901/1416477-20190114125943074-1719309026.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1416477/201901/1416477-20190114130035488-1871339216.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面两张截图中，第一张id=1,第二张id=-1，但在数据库中id这个参数是没有-1这个值的，所以第二张截图中，页面返回空（之所以出现sql语句，是我更改了源码显示在页面，方便研究学习用的），而在第一张截图中id=1,结果为真，页面返回来you are in....这个特殊的标志，我们可以理解为出现you are in...为真，反之，页面不返回任何东西为假。基于此，我们可以猜测出整个数据库中的数据（一般直接跑sqlmap 或者写脚本跑，下图是sqlmap结果）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1416477/201901/1416477-20190114130953388-1790559060.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当然，我们也可以手动注入，在手动注入之前，先介绍一下一些用于注入的相关函数，常用于基于布尔注入的函数有mid,substr,length等等，更多的就不在这里说了，想要了解更多的或者想要了解其用法的可以百度或者谷歌，个人觉得&lt;a href=&quot;https://blog.csdn.net/qq_41306131/article/details/84799049&quot; target=&quot;_blank&quot;&gt;这篇文章&lt;/a&gt;写得挺好的，感兴趣可以去看一下或者百度。&lt;/p&gt;
&lt;p&gt;　　　　介绍完相关函数后，针对sqllab less-5这一关，我们可以实际动手来尝试一下手动注入：&lt;/p&gt;
&lt;p&gt;利用http://127.0.0.1:9001/sqllab/Less-5/?id=1%27%20and%20mid(database(),1,1)=%27s%27%23猜测出当前正在使用的数据库名字第一个字母为s（当然，这里只是演示，一般常规注入步骤是先猜解出数据库名字长度，在一一猜解出来），剩下的常规的漫长道路了，当然，这种需要大量手动数据猜测的，建议使用自动化的工具，如sqlmap或者动手能力强的直接写脚本爆破（笔者的脚本不知道丢到哪里去了，所以以后找到了或者重新写一次之后再放出来吧）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1416477/201901/1416477-20190114132324309-1334053515.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　3、基于报错的注入&lt;/p&gt;
&lt;p&gt;　　　通俗来说，就是页面不回显任何有关数据的结果，包括真假值，但是通过使用一些函数会显示报错信息，从而暴露了数据库的相关信息。&lt;/p&gt;
&lt;p&gt;　　　a、floor注入&lt;/p&gt;
&lt;p&gt;　　　　（1）、原理&lt;/p&gt;
&lt;p&gt;　　　　　　原理讲解语文水平能力不行（逃。。。），这里附上一遍文章&lt;a href=&quot;https://blog.csdn.net/he_and/article/details/80455884&quot; target=&quot;_blank&quot;&gt;链接&lt;/a&gt;，对floor报错注入原理讲得非常清楚。&lt;/p&gt;
&lt;p&gt;　　　　（2）、利用&lt;/p&gt;
&lt;p&gt;　　　　　poc: select * from users where id=1 and(select 1 from (select count(*) ,concat(database(),floor(rand(0)*2))x from users group by x)a)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1416477/201901/1416477-20190114135238128-2076684217.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　b、extractvalue()报错注入&lt;/p&gt;
&lt;p&gt;　　　　（1）、原理&lt;/p&gt;
&lt;p&gt;　　　　　　EXTRACTVALUE (XML_document, XPath_string);&lt;br/&gt;　　　　　　第一个参数：XML_document是String格式，为XML文档对象的名称，文中为Doc&lt;br/&gt;　　　　　　第二个参数：XPath_string (Xpath格式的字符串) ，如果不了解Xpath语法，可以在网上查找教程。&lt;br/&gt;　　　　　　作用：从目标XML中返回包含所查询值的字符串&lt;br/&gt;　　　　　　函数的XPath_string必须满足Xpath语法，否则就会报错，这样我们就可以利用此报错来爆出我们想要的信息。&lt;/p&gt;
&lt;p&gt;　　　　（2）、利用&lt;/p&gt;
&lt;p&gt;　　　　　　以wuzhicms为例，poc: http://192.168.116.129/index.php?m=promote&amp;amp;f=index&amp;amp;v=search&amp;amp;_su=wuzhicms&amp;amp;fieldtype=place&amp;amp;keywords=%27%20and+extractvalue(1,concat(0x7e,(select database())))%23(192.168.116.129是笔者自己搭建用作搭载wuzhicms的虚拟机服务器)，如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1416477/201901/1416477-20190114140448106-1138832049.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;成功爆出当前数据库wuzhicms。（更多有关wuzhicms（cve-2018-14515）参见笔者的&lt;a href=&quot;https://www.cnblogs.com/aWxvdmVseXc0/p/10188374.html&quot; target=&quot;_blank&quot;&gt;这篇文章&lt;/a&gt;）更多有关extractvalue()报错注入可以参见&lt;a href=&quot;https://blog.csdn.net/zpy1998zpy/article/details/80631036&quot; target=&quot;_blank&quot;&gt;这篇文章&lt;/a&gt;，这篇博客写得挺详细的。&lt;/p&gt;
&lt;p&gt;　　　　c、UpdateXml报错注入&lt;/p&gt;
&lt;p&gt;　　　　（1）、原理&lt;/p&gt;
&lt;p&gt;　　　　　　UPDATEXML (XML_document, XPath_string, new_value);&lt;br/&gt;　　　　　　第一个参数：XML_document是String格式，为XML文档对象的名称，文中为Doc&lt;br/&gt;　　　　　　第二个参数：XPath_string (Xpath格式的字符串) ，如果不了解Xpath语法，可以在网上查找教程。&lt;br/&gt;　　　　　　第三个参数：new_value，String格式，替换查找到的符合条件的数据&lt;br/&gt;　　　　　　作用：改变文档中符合条件的节点的值&lt;br/&gt;　　　　　　参数Xpath_string的要求与EXTRACTVALUE函数相同。&lt;/p&gt;
&lt;p&gt;　　　　（2）、利用&lt;/p&gt;
&lt;p&gt;　　　　　　updatexml函数使用语法和extractvalue()差不多，这里就不在讲了。&lt;/p&gt;
&lt;p&gt;　　　　d、关于爆错注入其实远不止这上面所说的三种，还有很多，这里只写了常见的三种，对其余报错注入有兴趣的可以自己去百度。&lt;/p&gt;
&lt;p&gt;　　4、基于时间的注入&lt;/p&gt;
&lt;p&gt;　　　　基于时间注入通过判读页面返回时间长短来得到数据。常用的函数有sleep()、benchmark().&lt;/p&gt;
&lt;p&gt;　　　　(1)、sleep()&lt;/p&gt;
&lt;p&gt;　　　　以sqllab less-9为例，poc如下：http://127.0.0.1:9001/sqllab/Less-9/?id=1%27%20and%20if((mid(database(),1,1)=%27s%27),sleep(5),1)%23（poc解释：如果当前数据库名字第一个字母为s，执行sleep(5),否则执行1）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1416477/201901/1416477-20190114142921440-125806503.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从截图返回的结果中，我们可以看到返回时间为6.03秒，说明当前数据库名字第一个字母为s,其余数据查询也一样，这里不再做过多说明。&lt;/p&gt;
&lt;p&gt;　　　　（2）、benchamark()&lt;/p&gt;
&lt;p&gt;　　　　benchmark()有两个参数，第一个是执行次数，第二个是要执行的表达式，这里还是以sqllab less-9为例，poc如下：http://127.0.0.1:9001/sqllab/Less-9/?id=1%27%20and%20if((mid(database(),1,1)=%27s%27),benchmark(10000000,md5(123)),1)%23（poc解释：如果当前数据库名字第一个字母为s，执行benchamark函数，执行1000000次md5(123),否则执行1），截图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1416477/201901/1416477-20190114143709050-1047665526.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;可以看见页面返回时间为3.31秒，说明当前数据库名字第一个字母为s（如果返回时间不明显，可以增加benchmark函数中执行次数的量级），其余数据的猜测就是常规操作了，这里不再讲解。&lt;/p&gt;
&lt;p&gt;三、结束语&lt;/p&gt;
&lt;p&gt;　　对sql注入的讲解就到这里，sql注入的知识其实远不止这些，感兴趣的可以百度或者谷歌，如果上述有不对的地方，还请谅解，毕竟作者还是一菜鸟，完结，撒花。&lt;/p&gt;
&lt;p&gt;&lt;img id=&quot;uploading_image_53009&quot; src=&quot;https://common.cnblogs.com/images/loading.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 14 Jan 2019 06:43:00 +0000</pubDate>
<dc:creator>windy_2</dc:creator>
<og:description>一、前言 上一篇：sql注入篇1 二、基于回显的注入类型判断 1、有结果的注入 例如下图： （sqlllab less-1）可以看到有正常结果返回，对于的利用方式就是老套路了，先order by查询出</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/aWxvdmVseXc0/p/10266186.html</dc:identifier>
</item>
<item>
<title>Redux进阶（像VUEX一样使用Redux） - 菜的黑人牙膏</title>
<link>http://www.cnblogs.com/Darlietoothpaste/p/10266572.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Darlietoothpaste/p/10266572.html</guid>
<description>&lt;h2 id=&quot;redux的问题&quot;&gt;redux的问题&lt;/h2&gt;
&lt;p&gt;之前在&lt;a href=&quot;https://www.cnblogs.com/Darlietoothpaste/p/10135285.html&quot;&gt;另外一篇文章Redux基础&lt;/a&gt;中，就有提到以下这些问题&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;纯净&lt;/strong&gt;。Redux只支持同步，让状态可预测，方便测试。 但不处理异步、副作用的情况，而把这个丢给了其他中间件，诸如redux-thunk\redux-promise\redux-saga等等，选择多也容易造成混乱~&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;啰嗦&lt;/strong&gt;。那么写过Redux的人，都知道action\reducer\以及你的业务代码非常啰嗦，模板代码非常多。但是~，这也是为了让数据的流动清晰明了。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;性能&lt;/strong&gt;。粗暴地、级联式刷新视图（使用react-redux优化)。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;分型&lt;/strong&gt;。原生 Redux-react 没有分形结构，中心化 store&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;里面除了性能这一块可以利用react-redux进行优化，其他的都是开发者不得不面对的问题，对于代码有洁癖的人，啰嗦这一点确实是无法忍受的。&lt;/p&gt;
&lt;h2 id=&quot;方案目标&quot;&gt;方案目标&lt;/h2&gt;
&lt;p&gt;如果你使用过VUEX的话， 那么对于它的API肯定会相对喜欢很多，当然，vuex不是immutable，所以对于时间旅行这种业务不太友好。不过，我们可以自己实现一个具有vuex的简洁语法和immutable属性的redux-x（瞎命名）。&lt;/p&gt;
&lt;p&gt;先看一下我们想要的目标是什么样的？&lt;br/&gt;首先， 我们再./models里面定义每个子state树，里面带有&lt;strong&gt;namespace、state、reducers、effects&lt;/strong&gt;等属性， 如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;export default {
  // 命名空间
  namespace: 'common',
  // 初始化state
  state: {
    loading: false,
  },
  // reducers 同步更新 类似于vuex的mutations
  reducers: {
    updateLoadingStatus(state, action) {
      return {
        ...state,
        loading: action.payload
      }
    },
  },
  // reducers 异步更新 类似于vuex的actions
  efffects: {
    someEffect(action, store) {
      // some effect code
      ...
      ... 
      // 将结果返回
      return result
    }
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过上面的实现，我们基本解决了Redux本身的一些瑕疵&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1.在effects中存放的方法用于解决不支持异步、副作用的问题  

2.通过合并reducer和action， 将模板代码大大减少  

3.具有分型结构（namespace），并且中心化处理&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;如何实现&quot;&gt;如何实现&lt;/h2&gt;
&lt;h3 id=&quot;暴露的接口redux-x&quot;&gt;暴露的接口redux-x&lt;/h3&gt;
&lt;p&gt;首先，我们只是&lt;strong&gt;在外层封装了一层API方便使用&lt;/strong&gt;，那么说到底，传给redux的combineReducers还是一个redux对象。另外一个则是要处理副作用的话，那就必须使用到了中间件，所以最后我们暴露出来的函数的返回值应该具有上面两个属性，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import reduxSimp from '../utils/redux-simp' // 内部实现
import common from './common' // models文件下common的状态管理
import user from './user' // models文件下user的状态管理
import rank from './rank' // models文件下rank的状态管理

const reduxX = reduxSimp({
  common,
  user,
  rank
})
export default reduxX&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;const store = createStore(
  combineReducers(reduxX.reducers),  // reducers树
  {},
  applyMiddleware(reduxX.effectMiddler)  //  处理副作用中间件
)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第一步， 我们先实现一个暴露出来的函数reduxSimp，通过他对model里面各个属性进行加工，大概的代码如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;const reductionReducer = function() { // somecode }
const reductionEffects = function() { // somecode }
const effectMiddler = function() { // somecode }
/**
 * @param {Object} models
 */
const simplifyRedux = (models) =&amp;gt; {
  // 初始化一个reducers 最后传给combinReducer的值 也是最终还原的redux
  const reducers = {}
  // 遍历传入的model
  const modelArr = Object.keys(models)
  modelArr.forEach((key) =&amp;gt; {
    const model = models[key]
    // 还原effect
    reductionEffects(model)
    // 还原reducer，同时通过namespace属性处理命名空间
    const reducer = reductionReducer(model)
    reducers[model.namespace] = reducer
  })
  // 返回一个reducers和一个专门处理副作用的中间件
  return {
    reducers,
    effectMiddler
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;还原effects&quot;&gt;还原effects&lt;/h3&gt;
&lt;p&gt;对于effects， 使用的时候如下（没什么区别）：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;props.dispatch({
  type: 'rank/fundRankingList_fetch',
  payload: {
    fundType: props.fundType,
    returnType: props.returnType,
    pageNo: fund.pageNo,
    pageSize: 20
  }
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;还原effects的思路大概就是先将每一个model下的effect收集起来，同时加上命名空间作为前缀，将副作用的key即type 和相对应的方法value分开存放在两个数组里面，然后定义一个中间件，每当有一个dispatch的时候，检查key数组中是否有符合的key，如果有，则调用对应的value数组里面的方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 常量 分别存放副作用的key即type 和相对应的方法
const effectsKey = []
const effectsMethodArr = []  
/**
 * 还原effects的函数
 * @param {Object} model
 */
const reductionEffects = (model) =&amp;gt; {
  const {
    namespace,
    effects
  } = model
  const effectsArr = Object.keys(effects || {})

  effectsArr.forEach((effect) =&amp;gt; {
    // 存放对应effect的type和方法
    effectsKey.push(namespace + '/' + effect)
    effectsMethodArr.push(model.effects[effect])
  })
}

/**
 * 处理effect的中间件 具体参考redux中间件
 * @param {Object} store
 */
const effectMiddler = store =&amp;gt; next =&amp;gt; (action) =&amp;gt; {
  next(action)
  // 如果存在对应的effect， 调用其方法
  const index = effectsKey.indexOf(action.type)
  if (index &amp;gt; -1) {
    return effectsMethodArr[index](action, store)
  }
  return action
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;还原reducers&quot;&gt;还原reducers&lt;/h3&gt;
&lt;p&gt;reducers的应用也是和原来没有区别：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;props.dispatch({ type: 'common/updateLoadingStatus', payload: true })&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码实现的思路就是最后返回一个函数，也就是我们通常写的redux函数，函数内部遍历对应命名空间的reducer，找到匹配的reducer执行后返回结果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * 还原reducer的函数
 * @param {Object} model 传入的model对象
 */
const reductionReducer = (model) =&amp;gt; {
  const {
    namespace,
    reducers
  } = model

  const initState = model.state
  const reducerArr = Object.keys(reducers || {})

  // 该函数即redux函数
  return (state = initState, action) =&amp;gt; {
    let result = state
    reducerArr.forEach((reducer) =&amp;gt; {
      // 返回匹配的action
      if (action.type === `${namespace}/${reducer}`) {
        result = model.reducers[reducer](state, action)
      }
    })
    return result
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;最终代码&quot;&gt;最终代码&lt;/h3&gt;
&lt;p&gt;最终的代码如下，加上了一些错误判断：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 常量 分别存放副作用的key即type 和相对应的方法
const effectsKey = []
const effectsMethodArr = []

/**
 * 还原reducer的函数
 * @param {Object} model 传入的model对象
 */
const reductionReducer = (model) =&amp;gt; {
  if (typeof model !== 'object') {
    throw Error('Model must be object!')
  }

  const {
    namespace,
    reducers
  } = model

  if (!namespace || typeof namespace !== 'string') {
    throw Error(`The namespace must be a defined and non-empty string! It is ${namespace}`)
  }

  const initState = model.state
  const reducerArr = Object.keys(reducers || {})

  reducerArr.forEach((reducer) =&amp;gt; {
    if (typeof model.reducers[reducer] !== 'function') {
      throw Error(`The reducer must be a function! In ${namespace}`)
    }
  })

  // 该函数即redux函数
  return (state = initState, action) =&amp;gt; {
    let result = state
    reducerArr.forEach((reducer) =&amp;gt; {
      // 返回匹配的action
      if (action.type === `${namespace}/${reducer}`) {
        result = model.reducers[reducer](state, action)
      }
    })
    return result
  }
}

/**
 * 还原effects的函数
 * @param {Object} model
 */
const reductionEffects = (model) =&amp;gt; {
  const {
    namespace,
    effects
  } = model
  const effectsArr = Object.keys(effects || {})

  effectsArr.forEach((effect) =&amp;gt; {
    if (typeof model.effects[effect] !== 'function') {
      throw Error(`The effect must be a function! In ${namespace}`)
    }
  })
  effectsArr.forEach((effect) =&amp;gt; {
    // 存放对应effect的type和方法
    effectsKey.push(namespace + '/' + effect)
    effectsMethodArr.push(model.effects[effect])
  })
}

/**
 * 处理effect的中间件 具体参考redux中间件
 * @param {Object} store
 */
const effectMiddler = store =&amp;gt; next =&amp;gt; (action) =&amp;gt; {
  next(action)
  // 如果存在对应的effect， 调用其方法
  const index = effectsKey.indexOf(action.type)
  if (index &amp;gt; -1) {
    return effectsMethodArr[index](action, store)
  }
  return action
}

/**
 * @param {Object} models
 */
const simplifyRedux = (models) =&amp;gt; {
  if (typeof models !== 'object') {
    throw Error('Models must be object!')
  }
  // 初始化一个reducers 最后传给combinReducer的值 也是最终还原的redux
  const reducers = {}
  // 遍历传入的model
  const modelArr = Object.keys(models)
  modelArr.forEach((key) =&amp;gt; {
    const model = models[key]
    // 还原effect
    reductionEffects(model)
    // 还原reducer，同时通过namespace属性处理命名空间
    const reducer = reductionReducer(model)
    reducers[model.namespace] = reducer
  })
  // 返回一个reducers和一个专门处理副作用的中间件
  return {
    reducers,
    effectMiddler
  }
}

export default simplifyRedux&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;思考&quot;&gt;思考&lt;/h2&gt;
&lt;p&gt;如何结合Immutable.js使用？&lt;/p&gt;
</description>
<pubDate>Mon, 14 Jan 2019 06:28:00 +0000</pubDate>
<dc:creator>菜的黑人牙膏</dc:creator>
<og:description>'更好的阅度体验' 前言 redux的问题 方案目标 如何实现 思考 前言 Redux是一个非常实用的状态管理库，对于大多数使用React库的开发者来说，Redux都是会接触到的。在使用Redux享受</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Darlietoothpaste/p/10266572.html</dc:identifier>
</item>
<item>
<title>【必知必会】深入解析强引用、软引用、弱引用、幻象引用 - 夏雪冬日</title>
<link>http://www.cnblogs.com/heyonggang/p/10254372.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/heyonggang/p/10254372.html</guid>
<description>
&lt;p&gt;&lt;span&gt;关于强引用、软引用、弱引用、幻象引用的区别，在BAT这样大公司的面试题中也经常出现，可能有些小伙伴觉得这个知识点比较冷门，但其实大家在开发中经常用到，如new一个对象的时候就是强引用的应用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在java语言中，除了原始数据类型（boolean、byte、short、char、int、float、double、long）的变量，其他所有都是所谓的引用类型，指向各种不同的对象。理解这些引用的区别，对于掌握java对象生命周期和JVM内部相关机制非常有帮助。也有助于更深刻的理解底层对象生命周期、垃圾收集机制等，对设计可靠的缓存框架、诊断应用OOM等问题也大有裨益。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这四种应用主要的区别体现在对象不同的可达性状态和对垃圾收集的影响，他们之间的可达性状态可以参看下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/478153/201901/478153-20190114095833124-78893018.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;1.强引用（strong reference）&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;强引用就是我们最常见的普通对象引用（如new 一个对象），只要还有强引用指向一个对象，就表明此对象还“活着”。在强引用面前，即使JVM内存空间不足，JVM宁愿抛出OutOfMemoryError运行时错误（OOM），让程序异常终止，也不会靠回收强引用对象来解决内存不足的问题。对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为null，就意味着此对象可以被垃圾收集了。但要注意的是，并不是赋值为null后就立马被垃圾回收，具体的回收时机还是要看垃圾收集策略的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如Object obj = new Object();&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;2.软引用（soft reference）&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;软引用相对强引用要弱化一些，&lt;strong&gt;可以让对象豁免一些垃圾收集&lt;/strong&gt;。&lt;strong&gt;当内存空间足够的时候，垃圾回收器不会回收它&lt;/strong&gt;。只有当JVM认定内存空间不足时才会去回收软引用指向的对象。JVM会确保在抛出OOM前清理软引用指向的对象，而且JVM是很聪明的，会尽可能优先回收长时间闲置不用的软引用指向的对象，对那些刚构建的或刚使用过的软引用指向的对象尽可能的保留。基于软引用的这些特性，&lt;strong&gt;软引用可以用来实现很多内存敏感点的缓存场景&lt;/strong&gt;，即如果内存还有空闲，可以暂时缓存一些业务场景所需的数据，当内存不足时就可以清理掉，等后面再需要时，可以重新获取并再次缓存。这样就确保在使用缓存提升性能的同时，不会导致耗尽内存。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;软引用通常可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，java虚拟机就会把这个软引用加入到与之关联的引用队列中。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
Object obj = new Object();
SoftReference&amp;lt;Object&amp;gt; sf = new SoftReference&amp;lt;Object&amp;gt;(obj);
obj = null;
//有时候会返回null
sf.get();　　
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;通过上面的代码可以看出sf是对obj的一个软引用，当sf对象还没有被销毁前，sf.get()可以获取到这个对象，如果已被销毁，则返回null。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;正确使用软引用的示例代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
SoftReference&amp;lt;List&amp;lt;Foo&amp;gt;&amp;gt; ref = new SoftReference&amp;lt;List&amp;lt;Foo&amp;gt;&amp;gt;(new LinkedList&amp;lt;Foo&amp;gt;());

// somewhere else in your code, you create a Foo that you want to add to the list
List&amp;lt;Foo&amp;gt; list = ref.get();
if (list != null)
{
    list.add(foo);
}
else
{
    // list is gone; do whatever is appropriate
}　
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;在使用软引用的时候必须检查引用是否为null。因为垃圾收集器可能在任意时刻回收软引用，如果不做是否null的判断，可能会出现NullPointerException的异常。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;3.弱引用（weak reference）&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;弱引用指向的对象是一种十分临近finalize状态的情况&lt;/strong&gt;，当弱引用被清除的时候，就符合finalize的条件了。弱引用与软引用最大的区别就是弱引用比软引用的生命周期更短暂。垃圾回收器会扫描它所管辖的内存区域的过程中，只要发现弱引用的对象，不管内存空间是否有空闲，都会立刻回收它。如同前面我说过的，具体的回收时机还是要看垃圾回收策略的，因此那些弱引用的对象并不是说只要达到弱引用状态就会立马被回收。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;基于弱引用的这些特性，弱引用同样可以应用在很多需要缓存的场景。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
Object obj = new Object();
WeakReference&amp;lt;Object&amp;gt; wf = new WeakReference&amp;lt;Object&amp;gt;(obj);
obj = null;
//有时候会返回null
wf.get();
//返回是否被垃圾回收器标记为即将回收的垃圾
wf.isEnQueued();
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;4.幻象引用（phantom reference）&lt;/span&gt;　　&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;幻象引用，也有被说成是虚引用或幽灵引用。幻象引用并不会决定对象的生命周期。即如果一个对象仅持有虚引用，就相当于没有任何引用一样，在任何时候都可能被垃圾回收器回收。不能通过它访问对象，幻象引用仅仅是提供了一种确保对象被finalize以后，做某些事情的机制（如做所谓的Post-Mortem清理机制），也有人利用幻象引用监控对象的创建和销毁。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
Object obj = new Object();
PhantomReference&amp;lt;Object&amp;gt; pf = new PhantomReference&amp;lt;Object&amp;gt;(obj);
obj=null;
//永远返回null
pf.get();
//返回是否从内存中已经删除
pf.isEnQueued();　　
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;幻象引用的get方法永远返回null，主要用于检查对象是否已经从内测中删除。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通过上面对四种引用类型的分析，你可能发现&lt;strong&gt;对象的可达性是JVM垃圾收集器决定如何处理对象的一个重要考虑指标&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所有引用类型都是抽象类java.lang.ref.Reference的子类，子类里提供了get()方法。通过上面的分析中可以得知，&lt;strong&gt;除了幻象引用（因为get永远返回null），如果对象还没有被销毁，都可以通过get方法获取原有对象&lt;/strong&gt;。其实有个非常关键的注意点，&lt;strong&gt;利用软引用和弱引用，我们可以将访问到的对象，重新指向强引用，也就是人为的改变了对象的可达性状态&lt;/strong&gt;。所以对于软引用、弱引用之类，垃圾收集器可能会存在&lt;span&gt;&lt;strong&gt;二次确认&lt;/strong&gt;&lt;/span&gt;的问题，以确保处于弱引用状态的对象没有改变为强引用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是有个问题，如果我们错误的保持了强引用（比如，赋值给了static变量），那么对象可能就没有机会变回类似弱引用的可达性状态了，就会产生内存泄露。所以，检查弱引用指向对象是否被垃圾收集，也是诊断是否有特定内存泄露的一个思路，我们的框架使用到弱引用又怀疑有内存泄露，就可以从这个角度检查。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于软引用、弱引用、幻象引用可以配合引用队列（ReferenceQueue）来使用，特别是幻象引用，get方法只返回null，如果再不指定引用队列，基本就没有任何意义了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上面分析了四种引用类型的使用，熟悉这几种应用类型对深入理解JVM也大有裨益。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;参考：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.kdgregory.com/index.php?page=java.refobj&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;http://www.kdgregory.com/index.php?page=java.refobj&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;极客时间《Java核心技术36讲》&lt;/p&gt;

</description>
<pubDate>Mon, 14 Jan 2019 06:22:00 +0000</pubDate>
<dc:creator>夏雪冬日</dc:creator>
<og:description>关于强引用、软引用、弱引用、幻象引用的区别，在BAT这样大公司的面试题中也经常出现，可能有些小伙伴觉得这个知识点比较冷门，但其实大家在开发中经常用到，如new一个对象的时候就是强引用的应用。 在jav</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/heyonggang/p/10254372.html</dc:identifier>
</item>
<item>
<title>JDBC设计理念浅析  JDBC简介（一） - noteless</title>
<link>http://www.cnblogs.com/noteless/p/10265236.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/noteless/p/10265236.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;JDBC是J2EE的标准规范之一，J2EE就是为了规范JAVA解决企业级应用开发制定的一系列规范，JDBC也不例外。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;JDBC是用于Java编程语言和数据库之间的数据库无关连接的标准Java API。&lt;/p&gt;
&lt;p&gt;换句话说，使用JAVA语言连接数据库进行操作，就需要使用JDBC API。&lt;/p&gt;
&lt;p&gt;统一的JDBC API接口，屏蔽了底层数据库的细节，可以使用一致性的编码（跨数据库）对数据库进行操作。&lt;/p&gt;
&lt;p&gt;通过JDBC将JAVA应用于数据库访问连接进行解耦，可以相互独立发展，又能够结合使用。&lt;/p&gt;
&lt;div&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201901/897393-20190114092752270-661205610.png&quot;&gt;&lt;img title=&quot;image_5c3be495_6ef5&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201901/897393-20190114092753298-1285249270.png&quot; alt=&quot;image_5c3be495_6ef5&quot; width=&quot;404&quot; height=&quot;328&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;简言之，&lt;span&gt;&lt;strong&gt;JDBC就是对于java编码来说，在应用程序和数据库之间的一个中间层 API&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;有了中间层JDBC，你就可以面向JDBC API进行编程，不需要关注底层数据库细节。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;可以认为JDBC代理了对于数据库的操作与访问，也可以认为JDBC将数据库的访问适配成一致性的访问接口，也可以理解成JDBC是对数据库访问的一层封装&lt;/p&gt;
&lt;p&gt;不管怎么理解，他就是那么一套API的存在。&lt;/p&gt;
&lt;p&gt;官方文档：&lt;/p&gt;
&lt;p&gt;https://www.oracle.com/technetwork/java/javase/jdbc/index.html&lt;/p&gt;
&lt;div&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201901/897393-20190114092753495-673409738.png&quot;&gt;&lt;img title=&quot;image_5c3be495_394d&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201901/897393-20190114092754346-74190365.png&quot; alt=&quot;image_5c3be495_394d&quot; width=&quot;607&quot; height=&quot;172&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;Java数据库连接(JDBC) API是Java编程语言和一系列SQL数据库以及其他表格数据源，比如电子表格或文本文件之间的一个数据库连接的行业标准。&lt;/p&gt;
&lt;div readability=&quot;12&quot;&gt;
&lt;p&gt;&lt;span&gt;JDBC API为基于sql的数据库访问提供了一个调用级API。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;JDBC技术允许您使用Java编程语言为需要访问企业数据的应用程序开发“一次编写，到处运行”的功能。&lt;/p&gt;
&lt;p&gt;使用启用JDBC技术的驱动程序，您甚至可以在异构环境中连接所有企业数据&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;更详细的官方文档：&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;JDBC功能核心&lt;/span&gt;&lt;/h3&gt;
&lt;h4&gt;&lt;span&gt;数据库查询&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;下图为windows cmd登录MYSQL查询数据的过程，主要是三个步骤：&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;连接数据库&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;执行SQL&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;cmd打印结果&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201901/897393-20190114092756261-64580542.png&quot;&gt;&lt;img title=&quot;image_5c3be495_63dc&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201901/897393-20190114092759273-627669946.png&quot; alt=&quot;image_5c3be495_63dc&quot; width=&quot;801&quot; height=&quot;867&quot; border=&quot;0&quot;/&gt;&lt;/a&gt; &lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;JDBC用于JAVA应用程序与数据库的连接访问，是应用程序与数据库的中间层&lt;/p&gt;
&lt;p&gt;但是不管怎样，他仍旧是要操作数据库，所以也需要连接和查询&lt;/p&gt;
&lt;p&gt;cmd 作为客户端进行查询时，仅仅将信息打印出来就好了，这就是对cmd对数据库结果的处理&lt;/p&gt;
&lt;p&gt;JDBC需要为JAVA应用程序服务，需要将结果交付到应用程序中，所以JDBC还需要对返回的数据进行处理。&lt;/p&gt;

&lt;p&gt;所以JDBC连接数据库进行查询也是大致三个步骤&lt;/p&gt;
&lt;div&gt;
&lt;div&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;连接数据库&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;执行SQL&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;处理返回结果&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201901/897393-20190114092801259-495339978.png&quot;&gt;&lt;img title=&quot;image_5c3be495_249e&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201901/897393-20190114092802290-318943914.png&quot; alt=&quot;image_5c3be495_249e&quot; width=&quot;744&quot; height=&quot;547&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;JDBC架构设计&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;JDBC主要包括两类接口：&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;提供了一套纯粹的JAVA API给应用程序开发者 &lt;/li&gt;
&lt;li&gt;提供了一套低级别的JDBC driver API给数据库驱动开发者&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;应用程序开发者借助于API用于开发可以访问数据库的程序；&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;驱动开发者借助于API进而提供服务到JDBC；&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201901/897393-20190114092802542-2128134166.png&quot;&gt;&lt;img title=&quot;image_5c3be496_497b&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201901/897393-20190114092803371-2028399241.png&quot; alt=&quot;image_5c3be496_497b&quot; width=&quot;460&quot; height=&quot;341&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;而&lt;span&gt;&lt;strong&gt;提供给数据库驱动开发者的API则正好是为了实现提供给应用程序开发者的这套API&lt;/strong&gt;&lt;/span&gt;，这句话有些令人迷惑&lt;/p&gt;
&lt;p&gt;JDBC是对数据库操作访问的薄层封装，应用程序开发者借助于JDBC可以实现对数据库的操作访问，但是，最终提供的服务仍旧是数据库&lt;/p&gt;
&lt;p&gt;是具体的数据库实现了具体SQL的执行&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;所以JDBC提供给应用程序开发者的API就是开发者使用JDBC访问数据库的接口&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;而提供给数据库驱动开发者的API则恰恰是为了让数据库驱动开发者来提供服务&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;接口与实现分离，是一种桥接模式的思想（可以参阅本人的桥接模式的文章）&lt;/p&gt;
&lt;p&gt;理解了桥接模式就可以很好的理解这种“面向接口”的编程思维，将接口与实现进行分离。&lt;/p&gt;
&lt;p&gt;接口提供出来用于应用程序开发者使用，数据库或者工具厂商负责提供实现。&lt;/p&gt;

&lt;p&gt;JDBC的接口与实现之间，通过Driver Manager 进行联结&lt;/p&gt;
&lt;p&gt;JDBC API从Driver Manager获取服务，Driver Manager用来管理驱动程序，驱动程序可以很方便的注册到管理器中&lt;/p&gt;
&lt;div&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201901/897393-20190114092803677-610975688.png&quot;&gt;&lt;img title=&quot;image_5c3be496_6c2e&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201901/897393-20190114092804304-1954022238.png&quot; alt=&quot;image_5c3be496_6c2e&quot; width=&quot;517&quot; height=&quot;382&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;JDBC API&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;JDBC基本步骤有三个：连接、执行SQL、处理结果&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;另外还需要驱动管理器对注册的驱动程序进行管理&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;既然是代码，必然可能出现异常，所以还需要对相关异常进行处理&lt;/p&gt;
&lt;p&gt;为了能够更好地将SQL类型数据映射到应用程序还提供了更丰富的映射&lt;/p&gt;
&lt;p&gt;有的时候不仅仅是应用程序对数据库数据集进行检索，可能还需要数据库自身的相关信息（元数据 ）&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ps：数据是指普通文件中的实际数据，而元数据指用来描述一个文件的特征的系统数据，诸如访问权限、文件拥有者以及文件数据块的分布信息(inode...)等等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在JAVA中一切皆为对象，所以这些所有的元素，都被抽象为对象&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;连接、语句、结果、映射、元数据、异常、驱动管理器&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;https://docs.oracle.com/javase/8/docs/technotes/guides/jdbc/&lt;/p&gt;
&lt;p&gt;https://docs.oracle.com/javase/8/docs/api/java/sql/package-summary.html&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;官方相关介绍&lt;/span&gt;&lt;/h4&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;What the  &lt;code&gt;java.sql&lt;/code&gt; Package Contains&lt;/span&gt;&lt;/p&gt;
&lt;span&gt;&lt;span&gt;The &lt;/span&gt; &lt;code&gt;java.sql&lt;/code&gt;&lt;span&gt; package contains API for the following:&lt;/span&gt;&lt;/span&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;Making a connection with a database via the  &lt;code&gt;DriverManager&lt;/code&gt; facility   通过驱动管理器工具与数据库建立连接&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;code&gt;&lt;strong&gt;DriverManager&lt;/strong&gt;&lt;/code&gt;&lt;span&gt; &lt;/span&gt;class 类 -- makes a connection with a driver 与驱动程序建立连接&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;code&gt;&lt;strong&gt;SQLPermission&lt;/strong&gt;&lt;/code&gt;&lt;span&gt; &lt;/span&gt;class 类-- provides permission when code running within a Security Manager, such as an applet, attempts to set up a logging stream through the&lt;span&gt; &lt;/span&gt; &lt;code&gt;DriverManager&lt;/code&gt;&lt;span&gt;在安全管理器(如applet)中运行的代码试图通过驱动程序管理器设置日志流时，提供权限&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;code&gt;&lt;strong&gt;Driver&lt;/strong&gt;&lt;/code&gt;&lt;span&gt; &lt;/span&gt;interface 接口 -- provides the API for registering and connecting drivers based on JDBC technology (&quot;JDBC drivers&quot;); generally used only by the&lt;span&gt; &lt;/span&gt; &lt;code&gt;DriverManager&lt;/code&gt;&lt;span&gt; &lt;/span&gt;class提供基于JDBC技术的驱动程序注册和连接API(“JDBC驱动程序”);通常只被DriverManager类使用&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;code&gt;&lt;strong&gt;DriverPropertyInfo&lt;/strong&gt;&lt;/code&gt;&lt;span&gt; &lt;/span&gt;class 类 -- provides properties for a JDBC driver; not used by the general user 为JDBC驱动程序提供属性;一般用户不使用&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Sending SQL statements to a database  向数据库发送SQL语句&lt;/span&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;&lt;strong&gt;Statement&lt;/strong&gt;&lt;/code&gt;&lt;span&gt; &lt;/span&gt;-- used to send basic SQL statements  执行对象，用于发送基本的SQL语句&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;strong&gt;PreparedStatement&lt;/strong&gt;&lt;/code&gt;&lt;span&gt; &lt;/span&gt;-- used to send prepared statements or basic SQL statements (derived from&lt;span&gt; &lt;/span&gt; &lt;code&gt;Statement&lt;/code&gt;)  用于发送准备好的语句或基本SQL语句(从Statement派生)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;strong&gt;CallableStatement&lt;/strong&gt;&lt;/code&gt;&lt;span&gt; &lt;/span&gt;-- used to call database stored procedures (derived from&lt;span&gt; &lt;/span&gt; &lt;code&gt;PreparedStatement&lt;/code&gt; )  用于调用数据库存储过程(从PreparedStatement 派生) &lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;strong&gt;Connection&lt;/strong&gt;&lt;/code&gt;&lt;span&gt; &lt;/span&gt;interface 接口 -- provides methods for creating statements and managing connections and their properties  提供用于创建语句和管理连接及其属性的方法&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&lt;strong&gt;Savepoint&lt;/strong&gt;&lt;/code&gt;&lt;span&gt; &lt;/span&gt;-- provides savepoints in a transaction  在事务中提供Savepoint保存点&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Retrieving and updating the results of a query   检索和更新查询的结果&lt;/span&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;&lt;strong&gt;ResultSet&lt;/strong&gt;&lt;/code&gt;&lt;span&gt; &lt;/span&gt;interface 接口&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;Standard mappings&lt;/strong&gt; &lt;span&gt;&lt;span&gt;for SQL types to classes and interfaces in the Java programming language   SQL类型到Java编程语言中的类和接口的标准映射&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Array&lt;/code&gt;&lt;span&gt; &lt;/span&gt;interface 接口-- mapping for SQL&lt;span&gt; &lt;/span&gt; &lt;code&gt;ARRAY   SQL ARRAY映射&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Blob&lt;/code&gt;&lt;span&gt; &lt;/span&gt;interface 接口-- mapping for SQL&lt;span&gt; &lt;/span&gt; &lt;code&gt;BLOB     SQL BLOB映射&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Clob&lt;/code&gt;&lt;span&gt; &lt;/span&gt;interface接口 -- mapping for SQL&lt;span&gt; &lt;/span&gt; &lt;code&gt;CLOB     SQL CLOB 映射&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Date&lt;/code&gt;&lt;span&gt; &lt;/span&gt;class 类-- mapping for SQL&lt;span&gt; &lt;/span&gt; &lt;code&gt;DATE&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NClob&lt;/code&gt;&lt;span&gt; &lt;/span&gt;interface 接口 -- mapping for SQL&lt;span&gt; &lt;/span&gt; &lt;code&gt;NCLOB&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ref&lt;/code&gt;&lt;span&gt; &lt;/span&gt;interface 接口-- mapping for SQL&lt;span&gt; &lt;/span&gt; &lt;code&gt;REF&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RowId&lt;/code&gt;&lt;span&gt; &lt;/span&gt;interface 接口-- mapping for SQL&lt;span&gt; &lt;/span&gt; &lt;code&gt;ROWID&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Struct&lt;/code&gt;&lt;span&gt; &lt;/span&gt;interface 接口-- mapping for SQL&lt;span&gt; &lt;/span&gt; &lt;code&gt;STRUCT&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SQLXML&lt;/code&gt;&lt;span&gt; &lt;/span&gt;interface 接口-- mapping for SQL&lt;span&gt; &lt;/span&gt; &lt;code&gt;XML&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Time&lt;/code&gt;&lt;span&gt; &lt;/span&gt;class 类-- mapping for SQL&lt;span&gt; &lt;/span&gt; &lt;code&gt;TIME&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Timestamp&lt;/code&gt;&lt;span&gt; &lt;/span&gt;class 类-- mapping for SQL&lt;span&gt; &lt;/span&gt; &lt;code&gt;TIMESTAMP&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Types&lt;/code&gt;&lt;span&gt; &lt;/span&gt;class 类-- provides constants for SQL types        为SQL类型提供常量&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;Custom mapping&lt;/strong&gt; &lt;span&gt;&lt;span&gt;an SQL user-defined type (UDT) to a class in the Java programming language   自定义将SQL用户定义类型(UDT)映射到Java编程语言中的类&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;SQLData&lt;/code&gt;&lt;span&gt; &lt;/span&gt;interface -- specifies the mapping of a UDT to an instance of this class     指定UDT到该类实例的映射&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SQLInput&lt;/code&gt;&lt;span&gt; &lt;/span&gt;interface -- provides methods for reading UDT attributes from a stream    提供从流中读取UDT属性的方法&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SQLOutput&lt;/code&gt;&lt;span&gt; &lt;/span&gt;interface -- provides methods for writing UDT attributes back to a stream     提供将UDT属性写回流的方法&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;Metadata&lt;/strong&gt;&lt;span&gt;&lt;span&gt;     元数据&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;DatabaseMetaData&lt;/code&gt;&lt;span&gt; &lt;/span&gt;interface -- provides information about the database       提供有关数据库的信息&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ResultSetMetaData&lt;/code&gt;&lt;span&gt; &lt;/span&gt;interface -- provides information about the columns of a&lt;span&gt; &lt;/span&gt; &lt;code&gt;ResultSet&lt;/code&gt;&lt;span&gt; &lt;/span&gt;object      提供有关ResultSet对象的列的信息&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ParameterMetaData&lt;/code&gt;&lt;span&gt; &lt;/span&gt;interface -- provides information about the parameters to&lt;span&gt; &lt;/span&gt; &lt;code&gt;PreparedStatement&lt;/code&gt;&lt;span&gt; &lt;/span&gt;commands    为PreparedStatement命令提供有关参数的信息&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;Exceptions&lt;/strong&gt;   异常&lt;/span&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;code&gt;&lt;strong&gt;SQLException&lt;/strong&gt;&lt;/code&gt;&lt;span&gt; &lt;/span&gt;-- thrown by most methods when there is a problem accessing data and by some methods for other reasons   当访问数据存在问题时大多数方法都会抛出这个异常，还有一些方法是其他原因抛出这个异常。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;code&gt;&lt;strong&gt;SQLWarning&lt;/strong&gt;&lt;/code&gt;&lt;span&gt; &lt;/span&gt;-- thrown to indicate a warning   抛出以表示警告&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;code&gt;&lt;strong&gt;DataTruncation&lt;/strong&gt;&lt;/code&gt;&lt;span&gt; &lt;/span&gt;-- thrown to indicate that data may have been truncated  抛出以指示数据可能已被截断&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;code&gt;&lt;strong&gt;BatchUpdateException&lt;/strong&gt;&lt;/code&gt;&lt;span&gt; &lt;/span&gt;-- thrown to indicate that not all commands in a batch update executed successfully  抛出以指示批处理更新中并非所有命令都已成功执行&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;h4&gt;&lt;span&gt;核心&lt;/span&gt;&lt;/h4&gt;
&lt;div&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201901/897393-20190114092805298-64757098.png&quot;&gt;&lt;img title=&quot;image_5c3be496_3c25&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201901/897393-20190114092806415-722179424.png&quot; alt=&quot;image_5c3be496_3c25&quot; width=&quot;668&quot; height=&quot;183&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;驱动管理器&lt;/strong&gt;&lt;/span&gt; &lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;DriverManager 管理一组JDBC驱动程序的基本服务。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;连接&lt;/strong&gt;&lt;/span&gt; &lt;/p&gt;
&lt;div readability=&quot;10.5&quot;&gt;
&lt;p&gt;Connection 与特定数据库的连接（会话）。在连接上下文中执行 SQL 语句并返回结果。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;执行对象&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;Statement  用于执行静态 SQL 语句并返回它所生成结果的对象。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;结果集&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;p&gt;ResultSet 表示数据库结果集的数据表，通常通过执行查询数据库的语句生成。&lt;/p&gt;

&lt;/div&gt;
&lt;h4&gt;&lt;span&gt;一般流程&lt;/span&gt;&lt;/h4&gt;
&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201901/897393-20190114092807336-244086515.png&quot;&gt;&lt;img title=&quot;image_5c3be496_203c&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201901/897393-20190114092807670-3681863.png&quot; alt=&quot;image_5c3be496_203c&quot; width=&quot;211&quot; height=&quot;521&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;第一个JDBC示例&lt;/span&gt;&lt;/h3&gt;
&lt;h4&gt;&lt;span&gt;准备&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;以MYSQL为例，需要MYSQL驱动&lt;/p&gt;
&lt;div&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201901/897393-20190114092808234-657830566.png&quot;&gt;&lt;img title=&quot;image_5c3be496_4374&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201901/897393-20190114092808599-613737438.png&quot; alt=&quot;image_5c3be496_4374&quot; width=&quot;246&quot; height=&quot;41&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;数据库表、数据准备，本地安装了MYSQL，有数据库sampledb，内有表student，内容如下图&lt;/p&gt;
&lt;div&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201901/897393-20190114092808945-591686055.png&quot;&gt;&lt;img title=&quot;image_5c3be496_4908&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201901/897393-20190114092809316-2038602540.png&quot; alt=&quot;image_5c3be496_4908&quot; width=&quot;546&quot; height=&quot;344&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;h4&gt;&lt;span&gt;导包&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;比如在IDEA中，我的操作如下&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201901/897393-20190114092809557-1677709950.png&quot;&gt;&lt;img title=&quot;image_5c3be496_1185&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201901/897393-20190114092810353-569809098.png&quot; alt=&quot;image_5c3be496_1185&quot; width=&quot;1285&quot; height=&quot;691&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;h4&gt;&lt;span&gt;示例代码&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;此示例代码只为最基本查询，并不完善&lt;/p&gt;
&lt;div readability=&quot;18.115916955017&quot;&gt;
&lt;div readability=&quot;10&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; jdbc.jdbc;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.sql.Connection;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.sql.DriverManager;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.sql.ResultSet;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.sql.Statement;
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
* 第一个JDBC
* &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; noteless
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FirstJDBC {
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1、注册驱动&lt;/span&gt;
    Class.forName(&quot;com.mysql.jdbc.Driver&quot;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;数据库连接所需参数&lt;/span&gt;
    String user = &quot;root&quot;&lt;span&gt;;
    String password &lt;/span&gt;= &quot;123456&quot;&lt;span&gt;;
    String url &lt;/span&gt;= &quot;jdbc:mysql://localhost:3306/sampledb?useUnicode=true&amp;amp;characterEncoding=utf-8&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2、获取连接对象&lt;/span&gt;
    Connection conn =&lt;span&gt; DriverManager.getConnection(url, user, password);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置sql语句&lt;/span&gt;
    String sql = &quot;select * from student&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3、获得sql语句执行对象&lt;/span&gt;
    Statement stmt =&lt;span&gt; conn.createStatement();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;4、执行sql并保存结果集&lt;/span&gt;
    ResultSet rs =&lt;span&gt; stmt.executeQuery(sql);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;5、处理结果集&lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt;&lt;span&gt; (rs.next()) {
        System.out.print(&lt;/span&gt;&quot;id:&quot; + rs.getInt(1&lt;span&gt;));
        System.out.print(&lt;/span&gt;&quot;,姓名:&quot; + rs.getString(2&lt;span&gt;));
        System.out.print(&lt;/span&gt;&quot;,年龄:&quot; + rs.getInt(3&lt;span&gt;));
        System.out.println(&lt;/span&gt;&quot;,性别:&quot; + rs.getString(4&lt;span&gt;));
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;6、资源关闭&lt;/span&gt;
&lt;span&gt;    rs.close();
    stmt.close();
    conn.close();
}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;h4&gt;&lt;span&gt;结果&lt;/span&gt;&lt;/h4&gt;
&lt;div&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201901/897393-20190114092811259-1428301574.png&quot;&gt;&lt;img title=&quot;image_5c3be496_7793&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201901/897393-20190114092811424-2112882185.png&quot; alt=&quot;image_5c3be496_7793&quot; width=&quot;533&quot; height=&quot;162&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;div readability=&quot;16&quot;&gt;
&lt;h3&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;JDBC就是JAVA语言开发需要连接数据库的应用程序 ，所需要使用的JAVA API&lt;/p&gt;
&lt;p&gt;提供了数据库驱动程序的管理，连接，语句执行，以及结果返回等工作，是应用程序与数据库之间的薄层封装&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;JDBC的理念遵循依赖倒置原则，面向抽象进行编程，通过桥接模式将抽象与实现继续分离&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;即保证了应用程序开发者通过JDBC对数据库访问操作的一致性，又可以使得数据库独立发展&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;通过驱动管理器驱动程序可以方便的注册进来进而通过JDBC提供服务。&lt;/p&gt;
&lt;p&gt;JDBC简化了对数据库访问操作的复杂度，屏蔽了应用程序对底层数据库的依赖，将数据库的操作访问过程进行抽象分步，只需要按照既有的模块化流程就可以完成操作。&lt;/p&gt;
&lt;p&gt;JDBC的核心内容就是与数据库建立连接，发送SQL语句，处理结果。  &lt;/p&gt;

&lt;/div&gt;
</description>
<pubDate>Mon, 14 Jan 2019 05:55:00 +0000</pubDate>
<dc:creator>noteless</dc:creator>
<og:description>JDBC是很多人认为“”无用“”的东西，但是，你不直接用，并不是无用，但凡任何Java语言本身操纵数据库，本质上都离不开JDBC，所以如果你做Java，就应该稍微了解下，因为这相当于是Java语言层面</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/noteless/p/10265236.html</dc:identifier>
</item>
</channel>
</rss>