<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>深入理解gradle中的task - flydean</title>
<link>http://www.cnblogs.com/flydean/p/14403220.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/flydean/p/14403220.html</guid>
<description>&lt;p&gt;深入理解gradle中的task&lt;/p&gt;

&lt;p&gt;在之前的文章中，我们讲到了如何使用gradle创建一个简单的task，以及task之间怎么依赖，甚至使用了程序来创建task。在本文中，我们会更加深入的去了解一下gradle中的task。&lt;/p&gt;

&lt;p&gt;定义一个task可以有很多种方式，比如下面的使用string作为task的名字：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;task('hello') {
    doLast {
        println &quot;hello&quot;
    }
}

task('copy', type: Copy) {
    from(file('srcDir'))
    into(buildDir)
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;还可以使用tasks容器来创建：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;tasks.create('hello') {
    doLast {
        println &quot;hello&quot;
    }
}

tasks.create('copy', Copy) {
    from(file('srcDir'))
    into(buildDir)
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的例子中，我们使用tasks.create方法，将新创建的task加到tasks集合中。&lt;/p&gt;
&lt;p&gt;我们还可以使用groovy特有的语法来定义一个task：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;task(hello) {
    doLast {
        println &quot;hello&quot;
    }
}

task(copy, type: Copy) {
    from(file('srcDir'))
    into(buildDir)
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;上面我们在创建task的时候，使用了tasks集合类来创建task。&lt;/p&gt;
&lt;p&gt;实际上，tasks集合类是一个非常有用的工具类，我们可以使用它来做很多事情。&lt;/p&gt;
&lt;p&gt;直接在build文件中使用tasks，实际上是引用了TaskContainer的一个实例对象。我们还可以使用 &lt;code&gt;Project.getTasks()&lt;/code&gt; 来获取这个实例对象。&lt;/p&gt;
&lt;p&gt;我们看下TaskContainer的定义：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public interface TaskContainer extends TaskCollection&amp;lt;Task&amp;gt;, PolymorphicDomainObjectContainer&amp;lt;Task&amp;gt; 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从定义上，我们可以看出TaskContainer是一个task的集合和域对象的集合。&lt;/p&gt;
&lt;p&gt;taskContainer中有四类非常重要的方法：&lt;/p&gt;
&lt;p&gt;第一类是定位task的方法，有个分别是findByPath和getByPath。两个方法的区别就是findByPath如果没找到会返回null，而getByPath没找到的话会抛出UnknownTaskException。&lt;/p&gt;
&lt;p&gt;看下怎么使用：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;task hello

println tasks.getByPath('hello').path
println tasks.getByPath(':hello').path
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;:hello
:hello
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第二类是创建task的方法create，create方法有多种实现，你可以直接通过名字来创建一个task：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;task('hello') {
    doLast {
        println &quot;hello&quot;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也可以创建特定类型的task：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;task('copy', type: Copy) {
    from(file('srcDir'))
    into(buildDir)
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;还可以创建带参数的构造函数的task：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;class CustomTask extends DefaultTask {
    final String message
    final int number

    @Inject
    CustomTask(String message, int number) {
        this.message = message
        this.number = number
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面我们为CustomTask创建了一个带参数的构造函数，注意，这里需要带上@javax.inject.Inject注解，表示我们后面可以传递参数给这个构造函数。&lt;/p&gt;
&lt;p&gt;我们可以这样使用：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;tasks.create('myTask', CustomTask, 'hello', 42)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也可以这样使用：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;task myTask(type: CustomTask, constructorArgs: ['hello', 42])
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第三类是register，register也是用来创建新的task的，不过register执行的是延迟创建。也就是说只有当task被需要使用的时候才会被创建。&lt;/p&gt;
&lt;p&gt;我们先看一个register方法的定义：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;TaskProvider&amp;lt;Task&amp;gt; register​(String name,
                            Action&amp;lt;? super Task&amp;gt; configurationAction)
                     throws InvalidUserDataException 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到register返回了一个TaskProvider，有点像java多线程中的callable,当我们调用Provider.get()获取task值的时候，才会去创建这个task。&lt;/p&gt;
&lt;p&gt;或者我们调用TaskCollection.getByName(java.lang.String)的时候也会创建对应的task。&lt;/p&gt;
&lt;p&gt;最后一类是replace方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Task replace​(String name)
&amp;lt;T extends Task&amp;gt; T replace​(String name,
                           Class&amp;lt;T&amp;gt; type)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;replace的作用就是创建一个新的task，并且替换掉同样名字的老的task。&lt;/p&gt;

&lt;p&gt;task之间的依赖关系是通过task name来决定的。我们可以在同一个项目中做task之间的依赖：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;task hello {
    doLast {
        println 'Hello www.flydean.com!'
    }
}
task intro {
    dependsOn hello
    doLast {
        println &quot;I'm flydean&quot;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也可以跨项目进行task的依赖，如果是跨项目的task依赖的话，需要制定task的路径：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;project('project-a') {
    task taskX {
        dependsOn ':project-b:taskY'
        doLast {
            println 'taskX'
        }
    }
}

project('project-b') {
    task taskY {
        doLast {
            println 'taskY'
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或者我们可以在定义好task之后，再处理task之间的依赖关系：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;task taskX {
    doLast {
        println 'taskX'
    }
}

task taskY {
    doLast {
        println 'taskY'
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;还可以动态添加依赖关系：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;task taskX {
    doLast {
        println 'taskX'
    }
}

// Using a Groovy Closure
taskX.dependsOn {
    tasks.findAll { task -&amp;gt; task.name.startsWith('lib') }
}

task lib1 {
    doLast {
        println 'lib1'
    }
}

task lib2 {
    doLast {
        println 'lib2'
    }
}

task notALib {
    doLast {
        println 'notALib'
    }
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;有时候我们的task之间是有执行顺序的，我们称之为对task的排序ordering。&lt;/p&gt;
&lt;p&gt;先看一下ordering和dependency有什么区别。dependency表示的是一种强依赖关系，如果taskA依赖于taskB，那么执行taskA的时候一定要先执行taskB。&lt;/p&gt;
&lt;p&gt;而ordering则是一种并不太强列的顺序关系。表示taskA需要在taskB之后执行，但是taskB不执行也可以。&lt;/p&gt;
&lt;p&gt;在gradle中有两种order：分别是must run after和should run after。&lt;/p&gt;
&lt;p&gt;taskA.mustRunAfter(taskB)表示必须遵守的顺序关系，而taskA.shouldRunAfter(taskB)则不是必须的，在下面两种情况下可以忽略这样的顺序关系：&lt;br/&gt;第一种情况是如果shouldRunAfter引入了order循环的时候。&lt;/p&gt;
&lt;p&gt;第二种情况是如果在并行执行的情况下，task所有的依赖关系都已经满足了，那么也会忽略这个顺序。&lt;/p&gt;
&lt;p&gt;我们看下怎么使用：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;task taskX {
    doLast {
        println 'flydean.com'
    }
}
task taskY {
    doLast {
        println 'hello'
    }
}
taskY.mustRunAfter taskX
//taskY.shouldRunAfter taskX
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;我们可以给task一些描述信息，这样我们在执行gradle tasks的时候，就可以查看到：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;task copy(type: Copy) {
   description 'Copies the resource directory to the target directory.'
   from 'resources'
   into 'target'
   include('**/*.txt', '**/*.xml', '**/*.properties')
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;有时候我们需要根据build文件中的某些属性来判断是否执行特定的task，我们可以使用onlyIf ：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;task hello {
    doLast {
        println 'www.flydean.com'
    }
}

hello.onlyIf { !project.hasProperty('skipHello') }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或者我们可以抛出StopExecutionException异常，如果遇到这个异常，那么task后面的任务将不会被执行：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;task compile {
    doLast {
        println 'We are doing the compile.'
    }
}

compile.doFirst {
    if (true) { throw new StopExecutionException() }
}
task myTask {
    dependsOn('compile')
    doLast {
        println 'I am not affected'
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们还可以启动和禁用task：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;myTask.enabled = false
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后我们还可以让task超时，当超时的时候，执行task的线程将会被中断，并且task将会被标记为failed。&lt;/p&gt;
&lt;p&gt;如果我们想继续执行，那么可以使用 --continue。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注意， 只有能够响应中断的task，timeout才有用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;task hangingTask() {
    doLast {
        Thread.sleep(100000)
    }
    timeout = Duration.ofMillis(500)
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;如果我们想要给某些task定义一些规则，那么可以使用tasks.addRule：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;tasks.addRule(&quot;Pattern: ping&amp;lt;ID&amp;gt;&quot;) { String taskName -&amp;gt;
    if (taskName.startsWith(&quot;ping&quot;)) {
        task(taskName) {
            doLast {
                println &quot;Pinging: &quot; + (taskName - 'ping')
            }
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上我们定义了一个rule，如果taskName是以ping开头的话，那么将会输出对应的内容。&lt;/p&gt;
&lt;p&gt;看下运行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;&amp;gt; gradle -q pingServer1
Pinging: Server1
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我还可以将这些rules作为依赖项引入：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;task groupPing {
    dependsOn pingServer1, pingServer2
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;和java中的finally一样，task也可以指定对应的finalize task：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;task taskX {
    doLast {
        println 'taskX'
    }
}
task taskY {
    doLast {
        println 'taskY'
    }
}

taskX.finalizedBy taskY

&amp;gt; gradle -q taskX
taskX
taskY
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;finalize task是一定会被执行的，即使上面的taskX中抛出了异常。&lt;/p&gt;

&lt;p&gt;以上就是gradle中task的详解，希望大家能够喜欢。&lt;/p&gt;
&lt;blockquote readability=&quot;9.064&quot;&gt;
&lt;p&gt;本文已收录于 &lt;a href=&quot;http://www.flydean.com/gradle-task-in-depth/&quot; target=&quot;_blank&quot;&gt;http://www.flydean.com/gradle-task-in-depth/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最通俗的解读，最深刻的干货，最简洁的教程，众多你不知道的小技巧等你来发现！&lt;/p&gt;
&lt;p&gt;欢迎关注我的公众号:「程序那些事」,懂技术，更懂你！&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Mon, 15 Feb 2021 00:57:00 +0000</pubDate>
<dc:creator>flydean</dc:creator>
<og:description>深入理解gradle中的task 简介 在之前的文章中，我们讲到了如何使用gradle创建一个简单的task，以及task之间怎么依赖，甚至使用了程序来创建task。在本文中，我们会更加深入的去了解一</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/flydean/p/14403220.html</dc:identifier>
</item>
<item>
<title>Vue3（四）从jQuery 转到 Vue工程化 的捷径 - 金色海洋（jyk）</title>
<link>http://www.cnblogs.com/jyk/p/14403214.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jyk/p/14403214.html</guid>
<description>&lt;p&gt;熟悉jQuery开发的，学习vue的简单使用是没用啥问题的，但是学习vue的工程化开发方式，往往会遇到各种问题，比如：&lt;/p&gt;
&lt;p&gt;webpack、node、npm、cnpm、yarn、脚手架、开发环境、测试环境、生产环境、各种安装、各种创建。&lt;br/&gt;好在 vue3 不容易报错了，想当初 vue2.x 的时候各种报错，看到错误就只能干瞪眼，这都是啥？好像是webpack的报错。&lt;br/&gt;当初学 vue2 就卡在了建立项目上，各种尝试居然一个项目都没跑起来。&lt;/p&gt;
&lt;p&gt;如果能像jQuery那样，直接开鲁那多好呀！&lt;/p&gt;
&lt;p&gt;各种阴差阳错+机缘巧合的情况下，弄出来了这种在 CND 模式下仿工程化开发的方式。一开始只是想方便我做在线演示，后来各种完善，发现还是应该有点搞头了。再加上大神在弄vite，似乎也是对webpack比较头疼。。。&lt;/p&gt;
&lt;p&gt;好了不墨迹了，开始说我的做法。&lt;/p&gt;

&lt;p&gt;这个很传统了，官方也支持。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;  &amp;lt;script src=&quot;https://unpkg.com/vue@3.0.5/dist/vue.global.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
  &amp;lt;script src=&quot;https://unpkg.com/vue-router@4.0.3/dist/vue-router.global.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
  &amp;lt;script src=&quot;https://unpkg.com/vuex@4.0.0-rc.2/dist/vuex.global.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
  &amp;lt;link href=&quot;https://unpkg.com/element-plus@1.0.2-beta.30/lib/theme-chalk/index.css&quot; rel=&quot;stylesheet&quot;&amp;gt;
  &amp;lt;script src=&quot;https://unpkg.com/element-plus@1.0.2-beta.30/lib/index.full.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
  &amp;lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;浏览器会对js文件做缓存，第一次有点慢，后缓存后就快了。&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/25078225-731592f3977b49a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;001下载js.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;某网站有时候会卡一下，不卡的话还是很快的。&lt;/p&gt;

&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;&amp;lt;script type=&quot;module&quot; src=&quot;src/main.js?v=4&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;听说vite也是这么加载的。好吧就是从vite建立的项目里copy来的。&lt;br/&gt;要加上 type=&quot;module&quot; 否则加载不了。&lt;/p&gt;

&lt;p&gt;文件夹当然是把工程化的拿过来之间用了，挺简洁明了的。&lt;br/&gt;因为浏览器也支持 import 的方式加载js，那么也就是说，CDN方式下也可以用import加载。那么js代码方面也不会有太大的差别。&lt;br/&gt;我们来对比一下：&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/25078225-78846b6b96f2774c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;002文件夹对比.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;左面是CND的项目，右面是工程化的项目。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;文件夹结构完全一致，&lt;/li&gt;
&lt;li&gt;js文件都能对应上&lt;/li&gt;
&lt;li&gt;vue文件拆分成 html + js 两个文件（app.vue除外）&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;mainjs&quot;&gt;main.js&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;/*
import store from './store/index.js?v=1'
import router from './router/index.js?v=1'
import App from './app.js?v=1'

// 创建vue3的实例
const app = Vue.createApp(App)
  .use(store) 
  .use(router)
  .use(ElementPlus)
  .mount('#app')
*/

const ver = window.__ver || ''
Promise.all([
  import('./store/index.js' + ver),
  import('./router/index.js' + ver),
  import('./app.js' + ver),
]).then((res) =&amp;gt; {
  // 创建vue3的实例
  const app = Vue.createApp(res[2].default)
    .use(res[0].default) // 挂载vuex
    .use(res[1].default) // 挂载路由
    .use(ElementPlus) // 加载ElementPlus
    .mount('#app') // 挂载Vue的app实例
})
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注释掉的代码，和工程化里的代码是一致的，只是这种方式只支持常量，所以想把版本加在url地址上面就比较麻烦。&lt;br/&gt;所以改为了这种异步的方式，这样可以把版本号给拼接上去。这样更新浏览器的js缓存就方便多了。&lt;/p&gt;
&lt;h2 id=&quot;appjs&quot;&gt;app.js&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;export default {
  name: 'app',
  setup() {
    do something...
  
    return {
    }
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;工程化项目里面是App.vue，对应的是网页里 id=“app” 的div。&lt;br/&gt;这里改成纯js文件的形式，因为模板就是index.html的div。&lt;br/&gt;好吧，其实是main.js里面的加载方式不知道要怎么改。。。&lt;/p&gt;
&lt;h2 id=&quot;router&quot;&gt;router&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;
const routes = [
  {
    path: '/',
    name: 'Home',
    component: () =&amp;gt; myImport('views/home')
  },
  {
    path: '/About',
    name: 'About',
    component: () =&amp;gt; myImport('views/About')
  },
  {
    path: '/component',
    name: 'component',
    component: () =&amp;gt; myImport('views/component')
  },
  {
    path: '/store',
    name: 'store',
    component: () =&amp;gt; myImport('views/store')
  }
]

const router = VueRouter.createRouter({
  history: VueRouter.createWebHistory(),
  routes
})

export default router
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;动态路由&lt;br/&gt;这里采用动态路由的方式，另外换成了我自己封装的函数，可以加载html和js文件，然后变成动态组件的方式，这样组件就可以被路由加载了。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;路径设置问题&lt;br/&gt;本来想把html和js文件放在一个文件夹里面，就可以用同一个url加载了，结果和我想的不一样。&lt;br/&gt;由于加载 html 和加载 js 的路径规则不太一样，再加上路由导航的原因，&lt;br/&gt;所以只好用 src 作为分隔标识，统一从src开始计算路径。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;myimport&quot;&gt;myImport&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;// 直接放在Window里面好了。。。
window.myImport = (url) =&amp;gt; {
  return new Promise((resolve, reject) =&amp;gt; {
    const ver = window.__ver || ''
    const baseUrl = window.__basrUrl || '/src/'
    // 先加载js
    import(baseUrl + url + '.js' + ver).then((resjs) =&amp;gt; {
      const js = resjs.default
      if (js.template === '') {
        // 如果模板是空的，表示需要加载html作为模板
        axios.get(baseUrl + url + '.html' + ver).then((resHTML) =&amp;gt; {
          js.template = resHTML.data
          resolve(js)
        })
      } else {
        // 否则直接使用js注册组件
        resolve(js)
      }
    })
  })
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一开始还想做个插件挂到vue上面，后来试了半天没成功。&lt;br/&gt;然后觉得自己挺傻的，cnd环境，一个静态函数，直接挂在Window上面不就行了吗。&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;加载 js 和 html&lt;br/&gt;先用 import 异步加载 js，目的是便于拼接url，然后判断是否有template。&lt;br/&gt;如果有的话，就不加载html了。&lt;br/&gt;如果没有的话，在用axios加载html，然后设置给template，这样就变成了一个标准的js组件。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;是否会重复加载？&lt;br/&gt;组件自带缓存机制，第一次会加载，以后就不会重复加载了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;store&quot;&gt;store&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;import { Set_Count } from './mutation-types.js'

export default Vuex.createStore({
  state: {
    count: 0,
    myObject: {
      time: '现在的时间：'
    },
    myArray: [1,2,2,3,4]
  },
  getters: {
    getAddCount: (state) =&amp;gt; {
      return state.count + 1
    } 
  },
  mutations: {
    // 计数器
    setCount(state, num = 1) {
      state.count += num
    },
    [Set_Count](state, num = 1) {
      state.count += num
    }
  },
  actions: {
  },
  modules: {
  }
})
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;基本上没啥区别。&lt;/p&gt;
&lt;h2 id=&quot;如何方便的写模板&quot;&gt;如何方便的写模板&lt;/h2&gt;
&lt;p&gt;直接看图，更清晰一些。&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/25078225-91b7ca07f659df30.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;003组件.png&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;一边写js代码，另一边写模板。这样也是很方便的。&lt;/p&gt;
&lt;p&gt;一开始想在浏览器里面直接加载vue文件，然后处理成js组件。&lt;br/&gt;想了半天，理论上应该可以，但是我这水平估计够呛，所以采用了这种折中的方式。&lt;/p&gt;
&lt;h2 id=&quot;组件里面加载组件&quot;&gt;组件里面加载组件&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/25078225-e442e82dee73434b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;004组件加组件.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;defineAsyncComponent&lt;br/&gt;这个是Vue提供的异步组件，如果在工程化里面，可以直接加载vue文件。&lt;br/&gt;我在cnd里面试了一下，没成功。所以只好用纯js组件的方式。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;动态路由不需要套这个，但是异步组件就要套上，否则没有效果。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这样做项目和 jQuery 的风格挺像的，文件copy过来，建立个网站就可以开鲁了。&lt;/p&gt;
&lt;p&gt;同时代码编写方式又采用工程化的方式，熟悉之后可以方便的切换的工程化的开发方式。&lt;/p&gt;
&lt;p&gt;就好像在 jQuery 与 vue 的工程化直接搭了一个梯子，应该大概可以方便我们翻过去吧。&lt;/p&gt;


&lt;p&gt;缓存是个好东东，避免我们重复加载js文件，加快页面显示速度，但是如果我们的js改了，浏览器却还是在用缓存怎么办？&lt;/p&gt;
&lt;p&gt;我们可以设置一个版本号，加载文件后面就可以。当更新的时候，改一下版本号，就可以重新加载了。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/naturefwvue/nf-vue-cnd/tree/main/cnd/project-template&quot; target=&quot;_blank&quot;&gt;https://github.com/naturefwvue/nf-vue-cnd/tree/main/cnd/project-template&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://naturefwvue.github.io/nf-vue-cnd/cnd/project-template/&quot; target=&quot;_blank&quot;&gt;https://naturefwvue.github.io/nf-vue-cnd/cnd/project-template/&lt;/a&gt;&lt;br/&gt;一开始可能会有的卡，第一次点导航会加载文件，所以会慢一点，以后就好了。好像应该加一个加载中的状态。&lt;/p&gt;
</description>
<pubDate>Mon, 15 Feb 2021 00:32:00 +0000</pubDate>
<dc:creator>金色海洋（jyk）</dc:creator>
<og:description>不会 webpack 还想学 vue 工程化开发 的福音 熟悉jQuery开发的，学习vue的简单使用是没用啥问题的，但是学习vue的工程化开发方式，往往会遇到各种问题，比如： webpack、nod</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jyk/p/14403214.html</dc:identifier>
</item>
<item>
<title>Java 对象的哈希值是每次 hashCode() 方法调用重计算么？ - 干货满满张哈希</title>
<link>http://www.cnblogs.com/zhxdick/p/14403204.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhxdick/p/14403204.html</guid>
<description>&lt;p&gt;如果没有覆盖 &lt;code&gt;hashCode()&lt;/code&gt; 方法，那么哈希值为底层 JDK C++ 源码实现，实例每次调用&lt;code&gt;hashcode()&lt;/code&gt;方法，只有&lt;strong&gt;第一次&lt;/strong&gt;计算哈希值，之后哈希值会存储在对象头的 &lt;strong&gt;标记字（MarkWord）&lt;/strong&gt; 中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://zhxhash-blog.oss-cn-beijing.aliyuncs.com/Java%20GC%E8%AF%A6%E8%A7%A3/1.%20%E5%AF%B9%E8%B1%A1%E7%BB%93%E6%9E%84/Picture3.png&quot; alt=&quot;image&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果进入&lt;strong&gt;各种锁&lt;/strong&gt;状态，那么会缓存在其他地方，一般是&lt;strong&gt;获取锁的线程里面存储&lt;/strong&gt;，恢复无锁（即释放锁）会&lt;strong&gt;改回原有的哈希值&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;对应源码&lt;a href=&quot;https://github.com/openjdk/jdk/blob/master/src/hotspot/share/runtime/synchronizer.cpp&quot; target=&quot;_blank&quot;&gt;&lt;code&gt;synchronizer.cpp&lt;/code&gt;&lt;/a&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//如果是无锁状态
if (mark.is_neutral()) {          
  hash = mark.hash();
  //如果hash不等于0，证明计算过，直接返回
  if (hash != 0) {              
    return hash;
  }
  //否则，计算hash值
  hash = get_next_hash(self, obj);  // get a new hash
  //拷贝到Header中记录
  temp = mark.copy_set_hash(hash); 
  test = obj-&amp;gt;cas_set_mark(temp, mark);
  //可能有并发，而且不同默认哈希值计算方法，可能每次哈希值不一样，只有 CAS 成功的才是最后的哈希值
  //默认的哈希值计算，不论计算多少次，都不会变
  if (test == mark) {             
    return hash;
  }
} else if (mark.has_monitor()) {
  //如果是有 monitor 锁状态（重量级锁），则获取其 monitor，哈希值会记录在monitor的头部
  monitor = mark.monitor();
  temp = monitor-&amp;gt;header();
  assert(temp.is_neutral(), &quot;invariant: header=&quot; INTPTR_FORMAT, temp.value());
  hash = temp.hash();
  if (hash != 0) {
    OrderAccess::loadload_for_IRIW();
    if (monitor-&amp;gt;is_being_async_deflated()) {
      monitor-&amp;gt;install_displaced_markword_in_object(obj);
      continue;
    }
    return hash;
  }
} else if (self-&amp;gt;is_lock_owned((address)mark.locker())) {
  // 如果是轻量级锁状态，获取轻量锁，其中也记录着之前计算的哈希值
  temp = mark.displaced_mark_helper();
  assert(temp.is_neutral(), &quot;invariant: header=&quot; INTPTR_FORMAT, temp.value());
  hash = temp.hash();
  if (hash != 0) {                  // if it has a hash, just return it
    return hash;
  }
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;对于已经覆盖&lt;code&gt;hashCode()&lt;/code&gt;方法的对象，则每次都会重新调用&lt;code&gt;hashCode()&lt;/code&gt;方法重新计算哈希值。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;微信搜索“我的编程喵”关注公众号，每日一刷，轻松提升技术，斩获各种offer：&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://zhxhash-blog.oss-cn-beijing.aliyuncs.com/qr-code.jpg&quot; alt=&quot;image&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Mon, 15 Feb 2021 00:16:00 +0000</pubDate>
<dc:creator>干货满满张哈希</dc:creator>
<og:description>对于没有覆盖hashCode()方法的对象 如果没有覆盖 hashCode() 方法，那么哈希值为底层 JDK C++ 源码实现，实例每次调用hashcode()方法，只有第一次计算哈希值，之后哈希值</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhxdick/p/14403204.html</dc:identifier>
</item>
<item>
<title>Dockfile搭建极简LNMP环境 - freephp</title>
<link>http://www.cnblogs.com/freephp/p/14403058.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/freephp/p/14403058.html</guid>
<description>&lt;p&gt;最近才发现ThinkPHP6.0和CI4.x都要求php版本为7.1以上了，本机的php版本还停留在7.0.3x，又懒得升级，于是考虑使用Docker来运行一个lnmp环境。&lt;/p&gt;
&lt;p&gt;常规环境搭建的方式有两种，一种是把php、mysql、nginx分别编写一个Dockerfile，然后再使用docker-compose.yml来编写一个容器互连的配置，使用docker-compose来管理和生成容器。另外一种方式是把php、nginx、mysql都安装到一个镜像里面，简单粗暴。根据目的和可维护性来看，如果是想长期维护且对各个软件的版本要求比较灵活的话，使用docker-compose方式生成的容器和镜像更加方便。但是如果只是搭建本地环境（个人开发者，非团队），不是很频繁地调整环境，我宁愿使用第二种简单的方式。&lt;br/&gt;安装专业的说法，第一种编写方式生成的容器叫thin container（瘦容器），第二种方式生成的容器叫fat container（胖容器）。fat container五脏俱全，不用再使用docker-compose去将多个容器进行配置和互连。&lt;br/&gt;我由于更熟悉ubuntu，且ubuntu系统的源更加丰富和更新及时，所以考虑使用ubuntu作为容器系统。用到的系统和软件版本整理如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ubuntu 18.04 (长期支持版本)
php  7.4.15 (7.4.x中维护的最新版本)
mysql 5.7.33 （ubuntu18.04下默认版本）
nginx 1.18.0 （ubuntu18.04下默认版本）
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;根据实践，编写了Dockerfile，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;FROM ubuntu:18.04

MAINTAINER freephp &quot;fightforphp@gmail.com&quot;

RUN apt-get update
RUN apt-get install -y vim curl gcc
# 添加php7.4的源
RUN apt-get -y install software-properties-common
RUN add-apt-repository ppa:ondrej/php
RUN apt-get update
RUN ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime &amp;amp;&amp;amp; echo 'Asia/Shanghai' &amp;gt;/etc/timezone
RUN apt-get install -y php7.4
RUN apt-get install -y php7.4-curl php7.4-fpm php7.4-gd php7.4-mysqlnd php7.4-mbstring php7.4-ldap php7.4-soap php7.4-mongod php7.4-soap php7.4-sqlite3 \
php7.4-xml \
php7.4-zip \
php7.4-intl \
php7.4-imagick \
php7.4-xdebug

# 安装composer
RUN curl -sS https://getcomposer.org/installer | php
RUN mv composer.phar /usr/local/bin/composer
# 设置composer源为阿里云
RUN composer config -g repo.packagist composer https://mirrors.aliyun.com/composer/

# 安装mysql
RUN apt-get install -y mysql-server mysql-client
# 添加nginx配置
RUN  add-apt-repository ppa:ondrej/nginx
RUN apt-get update
RUN apt-get install -y nginx

# 配置nginx
COPY ./default /etc/nginx/sites-available/default

# 添加启动脚本
ADD ./start.sh /start.sh
RUN chmod 755 /start.sh


CMD /start.sh &amp;amp;&amp;amp; tail -f

# 暴露端口
EXPOSE 3306
EXPOSE 80
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后使用如下命令进行编译：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker build -t freephp/mylnmp:v2 .
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样就得到了想要的lnmp镜像了，后面可以根据自己的需求去运行一个容器即可，例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker run -id -p 80:80 -v /Users/tony/www/myphp:/var/www/html --name mylnmp2 freephp/mylnmp:v2
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在Dockerfile中还有关于nginx的配置和启动脚本,其完整内容可以参考我开源在gitee上的项目&lt;a href=&quot;https://gitee.com/freemannow/lnmpdocker&quot; target=&quot;_blank&quot;&gt;lnmpdocker&lt;/a&gt;。&lt;/p&gt;
</description>
<pubDate>Sun, 14 Feb 2021 16:06:00 +0000</pubDate>
<dc:creator>freephp</dc:creator>
<og:description>最近才发现ThinkPHP6.0和CI4.x都要求php版本为7.1以上了，本机的php版本还停留在7.0.3x，又懒得升级，于是考虑使用Docker来运行一个lnmp环境。 常规环境搭建的方式有两种</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/freephp/p/14403058.html</dc:identifier>
</item>
<item>
<title>CNN可视化技术总结（三）--类可视化 - 仿佛若有光157</title>
<link>http://www.cnblogs.com/wxkang/p/14403038.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wxkang/p/14403038.html</guid>
<description>&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzkyMDE2OTA3Mw==&amp;amp;mid=2247484970&amp;amp;idx=1&amp;amp;sn=5031cd5c13bde6d9d67c02039c2afdc8&amp;amp;chksm=c197b934f6e030220bafa4823e2accca6e5a719e323e0c9050aac2a2466c0cb3872244b32954&amp;amp;token=941760363&amp;amp;lang=zh_CN#rd&quot;&gt;CNN可视化技术总结(一)-特征图可视化&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzkyMDE2OTA3Mw==&amp;amp;mid=2247484987&amp;amp;idx=1&amp;amp;sn=d48f6267fe336d46ff26473abd052f89&amp;amp;chksm=c197b925f6e03033282196c4e883db5716f86fca934edecc487c0287e058eb21aa09d228ab29&amp;amp;token=941760363&amp;amp;lang=zh_CN#rd&quot;&gt;CNN可视化技术总结（二）--卷积核可视化&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;导言：&lt;/p&gt;
&lt;p&gt;    前面我们介绍了两种可视化方法，特征图可视化和卷积核可视化，这两种方法在论文中都比较常见，这两种更多的是用于分析模型在某一层学习到的东西。在理解这两种可视化方法，很容易理解图像是如何经过神经网络后得到识别分类。&lt;/p&gt;

&lt;p&gt;    然而，上次我在知乎看到一个通过yolov3做跌倒检测，希望加上人脸识别进行多任务学习从而提高准确率的提问。这明显提问者并不理解神经网络是如何对这种带有时间维度的视频进行分析从而实现行为识别，从本质上来讲，这其实是不理解神经网络具体是如何识别一个类的。因此，当在这一点上理解错误后，所进行的模型选择、方案设计和改进，就都是不合理的。&lt;/p&gt;
&lt;p&gt;    （我在知乎上回答了这个问题正确的跌倒检测思路应该是什么，感兴趣的可以去看看，我的知乎id是仿佛若有光）&lt;/p&gt;

&lt;p&gt;    因此，在本文中，我们将介绍一种对于不同的类，如何知道模型根据哪些信息来识别的方法，即对类进行可视化，通俗一点来说就是热力图。这个方法主要是CAM系列，目前有CAM, Grad-CAM, Grad-CAM++。&lt;/p&gt;

&lt;h3&gt;CAM（Class Activation Map）&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/f9ff3e3b5e58d0be14ec371520ff1f41.png&quot; alt=&quot;图片&quot; width=&quot;784&quot; height=&quot;365&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，CAM的结构由CNN特征提取网络，全局平均池化GAP，全连接层和Softmax组成。&lt;/p&gt;

&lt;p&gt;实现原理：一张图片在经过CNN特征提取网络后得到feature maps, 再对每一个feature map进行全局平均池化，变成一维向量，再经过全连接层与softmax得到类的概率。&lt;/p&gt;

&lt;p&gt;假定在GAP前是n个通道，则经过GAP后得到的是一个长度为1x n的向量，假定类别数为m，则全连接层的权值为一个n x m的张量。（注：这里先忽视batch-size）&lt;/p&gt;

&lt;p&gt;对于某一个类别C, 现在想要可视化这个模型对于识别类别C，原图像的哪些区域起主要作用，换句话说模型是根据哪些信息得到该图像就是类别C。&lt;/p&gt;

&lt;p&gt;做法是取出全连接层中得到类别C的概率的那一维权值，用W表示，即上图的下半部分。然后对GAP前的feature map进行加权求和，由于此时feature map不是原图像大小，在加权求和后还需要进行上采样，即可得到Class Activation Map。&lt;/p&gt;

&lt;p&gt;用公式表示如下：（k表示通道，c表示类别，fk(x,y)表示feature map）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/09333567f300e0b1c4d63da2c88835ed.png&quot; alt=&quot;图片&quot;/&gt;&lt;/p&gt;
&lt;p&gt;效果图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/f3486f541043d602863b30355a13eec0.png&quot; alt=&quot;图片&quot;/&gt;&lt;/p&gt;


&lt;p&gt;CAM的分析&lt;/p&gt;
&lt;p&gt;CAM有个很致命的缺陷，它的结构是由CNN + GAP + FC + Softmax组成，也就是说如果想要可视化某个现有的模型，但大部分现有的模型没有GAP这个操作，此时想要可视化便需要修改原模型结构，并重新训练，相当麻烦，且如果模型很大，在修改后重新训练不一定能达到原效果，可视化也就没有意义了。&lt;/p&gt;
&lt;p&gt;因此，针对这个缺陷，其后续有了改进版Grad-CAM。&lt;/p&gt;

&lt;h3&gt;Grad-CAM&lt;/h3&gt;

&lt;p&gt;Grad-CAM的最大特点就是不再需要修改现有的模型结构了，也不需要重新训练了，直接在原模型上即可可视化。&lt;/p&gt;

&lt;p&gt;原理：同样是处理CNN特征提取网络的最后一层feature maps。Grad-CAM对于想要可视化的类别C，使最后输出的类别C的概率值通过反向传播到最后一层feature maps，得到类别C对该feature maps的每个像素的梯度值，对每个像素的梯度值取全局平均池化，即可得到对feature maps的加权系数alpha，论文中提到这样获取的加权系数跟CAM中的系数几乎是等价的。接下来对特征图加权求和，使用ReLU进行修正，再进行上采样。&lt;/p&gt;

&lt;p&gt;使用ReLU的原因是对于那些负值，可认为与识别类别C无关，这些负值可能是与其他类别有关，而正值才是对识别C有正面影响的。&lt;/p&gt;

&lt;p&gt;用公式表示如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/072e89ed53efc0b741ba08e46ad71b60.png&quot; alt=&quot;图片&quot; width=&quot;361&quot; height=&quot;142&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/e7689b40c8c46a0caca38853f990f553.png&quot; alt=&quot;图片&quot; width=&quot;342&quot; height=&quot;96&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/d7ddec11140ca356b69eb15dea259b9e.png&quot; alt=&quot;图片&quot; width=&quot;617&quot; height=&quot;304&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Grad-CAM的结构图如上图所示，对于Guided Backpropagation不了解的读者，可看CNN可视化技术总结的第一篇文章。&lt;/p&gt;
&lt;p&gt;效果图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/ab04bf47b6559844485b63f917cc2251.png&quot; alt=&quot;图片&quot; width=&quot;707&quot; height=&quot;437&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Grad-CAM后续还有改进版Grad-CAM++，其主要的改进效果是定位更准确，更适合同类多目标的情况，所谓同类多目标是指一张图像中对于某个类出现多个目标，例如七八个人。&lt;/p&gt;
&lt;p&gt;改进方法是对加权系数的获取提出新的方法，该方法复杂到不忍直视。因此这里就不介绍了，感兴趣的读者可通过文章末尾的链接获取该论文。&lt;/p&gt;
&lt;p&gt;  下一篇将对所有的一些可视化工具进行总结。内容将放在CV技术总结部分。&lt;/p&gt;
&lt;p&gt;CAM:  https://arxiv.org/pdf/1512.04150.pdf&lt;br/&gt;Grad-CAM:  https://arxiv.org/pdf/1610.02391v1.pdf&lt;br/&gt;Grad-CAM++:  https://arxiv.org/pdf/1710.11063.pdf&lt;/p&gt;
&lt;p&gt;参考论文：&lt;/p&gt;
&lt;p&gt;1. Learning Deep Features for Discriminative Localization&lt;/p&gt;
&lt;p&gt;2.Grad-CAM: Why did you say that?Visual Explanations from Deep Networks via Gradient-based Localization&lt;/p&gt;
&lt;p&gt;3. Grad-cam++: Generalized gradient-based visual explanations for deep convolutional networks&lt;/p&gt;
&lt;p&gt;本文来源于公众号《CV技术指南》的技术总结部分，更多相关技术总结请扫描文末二维码关注公众号。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210113232737343.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tBTkcxNTc=,size_16,color_FFFFFF,t_70&quot; alt=&quot;&quot; width=&quot;313&quot; height=&quot;310&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 14 Feb 2021 15:46:00 +0000</pubDate>
<dc:creator>仿佛若有光157</dc:creator>
<og:description>CNN可视化技术总结(一)-特征图可视化 CNN可视化技术总结（二）--卷积核可视化 导言： 前面我们介绍了两种可视化方法，特征图可视化和卷积核可视化，这两种方法在论文中都比较常见，这两种更多的是用于</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wxkang/p/14403038.html</dc:identifier>
</item>
<item>
<title>云原生系列1 pod基础 - 李福春</title>
<link>http://www.cnblogs.com/snidget/p/14403037.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/snidget/p/14403037.html</guid>
<description>&lt;br/&gt;成组资源调度问题的解决。
&lt;p&gt;mesos采用的资源囤积策略容易出现死锁和调度效率低下问题；&lt;br/&gt;google采用的乐观调度技术难度非常大；&lt;/p&gt;&lt;p&gt;而k8s使用pod优雅的解决了这个问题。&lt;/p&gt;&lt;p&gt;pod的出现解决了两个问题。&lt;/p&gt;&lt;p&gt;第一：解决了超亲密关系的进程协作；&lt;/p&gt;&lt;p&gt;第二：容器设计模式sidecar应用的载体；&lt;/p&gt;

&lt;p&gt;pod是逻辑概念，在linux操作系统中并不存在，对应了容器组，是k8s中原子调度单位，物理结构如下图：&lt;/p&gt;&lt;p&gt;![image.png](https://img2020.cnblogs.com/other/268922/202102/268922-20210214234357945-337352592.png)&lt;/p&gt;&lt;p&gt;infra容器是一个使用编译语言编写的轻量级程序，其它业务容器共享了infra容器的network namespace，即pod的所有网络流量都是通过infra容器来处理的，永远处于暂停状态，跟pod同生命周期。&lt;/p&gt;&lt;p&gt;pod里的容器共享volumn ;&lt;/p&gt;&lt;p&gt;物理结构决定了它非常适合用来处理超亲密关系的容器或者说程序。&lt;/p&gt;
&lt;p&gt;共享volumn:的两个容器&lt;br/&gt;&lt;/p&gt;&lt;pre&gt;
&lt;code class=&quot;language-yaml&quot;&gt;apiVersion: v1
kind: pod
metadata:
  name: two-container
spec:
  restartPolicy: Never
  volumes:
    - name: shared-data
      hostPath:
        path: /data
  containers:
    - name: nginx-container
      image: nginx
      volumeMounts:
        - name: shared-data
          mountPath: /usr/share/nginx/html
    - name: debian-container
      image: debian
      volumeMounts:
        - name: shared-data
          mountPath: /pod-data
      command: [&quot;/bin/sh&quot;]
      args: [&quot;-c&quot;,&quot;echo hello from  &amp;gt; /pod-data/index.html&quot;]

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;sidecar模式应用例子：(javaweb程序采用sidecar模式共享volumn，是的war跟tomcat独立更新和演进)&lt;br/&gt;&lt;/p&gt;&lt;pre&gt;
&lt;code class=&quot;language-yaml&quot;&gt;apiVersion: v1
kind: Pod
metadata:
    name: javaweb
spec:
  initContainers:
  - image: war:v2
    name: war
    command: [&quot;cp&quot;, &quot;/sample.war&quot;,&quot;app&quot;]
    volumeMounts:
    - mountPath: /app
      name: app-volunn
  containers:
  - image: tomcat
    name: tomcat
    command: [&quot;sh&quot;,&quot;-c&quot;,&quot;startup.sh&quot;]
    volumeMounts:
      - mountPath: /app
          name: app-volunn
    volumes:
    - name: app-volumn
      emptyDir: {}
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;pod的物理结构决定了它非常适合处理超亲密关系的一组容器，也是sidecar即服务网格的基础。&lt;/p&gt;&lt;p&gt;![pod.png](https://img2020.cnblogs.com/other/268922/202102/268922-20210214234358709-1363172180.png)
&lt;/p&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;原创不易，关注诚可贵，转发价更高！转载请注明出处，让我们互通有无，共同进步，欢迎沟通交流。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sun, 14 Feb 2021 15:44:00 +0000</pubDate>
<dc:creator>李福春</dc:creator>
<og:description>POD解决了什么问题？ 成组资源调度问题的解决。 mesos采用的资源囤积策略容易出现死锁和调度效率低下问题；google采用的乐观调度技术难度非常大； 而k8s使用pod优雅的解决了这个问题。 po</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/snidget/p/14403037.html</dc:identifier>
</item>
<item>
<title>Spring应用上下文生命周期 - Gouden</title>
<link>http://www.cnblogs.com/gouden/p/14402955.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/gouden/p/14402955.html</guid>
<description>&lt;p&gt;Spring应用上下文生命周期整体分成四个阶段&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ConfigurableApplicationContext#refresh，加载或者刷新持久化配置&lt;/li&gt;
&lt;li&gt;ConfigurableApplicationContext#start，启动应用上下文&lt;/li&gt;
&lt;li&gt;ConfigurableApplicationContext#stop，停止应用上下文&lt;/li&gt;
&lt;li&gt;ConfigurableApplicationContext#close，关闭应用上下文，释放锁定资源&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;实际上refresh执行完成后Spring应用上下文从广义上来说已经启动了，start回调用LifeCycleProcessors的start方法，可以理解refresh处理Spring应用上下文启动需要的东西，start相当于是一个扩展，close和stop是和refresh和close类似的逆向操作。&lt;/p&gt;
&lt;div readability=&quot;10.5&quot;&gt;
&lt;p&gt;因此Spring应用上下文生命周期重头戏是refresh和close两个方法对应的实现。&lt;/p&gt;
&lt;div readability=&quot;12&quot;&gt;
&lt;h2&gt;refresh-刷新应用上下文&lt;/h2&gt;
&lt;p&gt;整个refresh阶段代码如下所示:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1340552/202102/1340552-20210214170859533-982272419.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1340552/202102/1340552-20210214170948727-354488411.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从代码可以看出，refresh整体分为以下几个阶段:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;准备刷新阶段: prepareRefresh&lt;/li&gt;
&lt;li&gt;BeanFactory创建阶段: obtainFreshBeanFactory&lt;/li&gt;
&lt;li&gt;BeanFactory准备阶段: prepareBeanFactory&lt;/li&gt;
&lt;li&gt;BeanFactory后置处理阶段: postProcessBeanFactory、invokeBeanFactoryPostProcessors&lt;/li&gt;
&lt;li&gt;BeanFactory注册BeanPostProcessor阶段: registerBeanPostProcessors&lt;/li&gt;
&lt;li&gt;初始化内建Bean: initMessageSource、initApplicationEventMulticaster&lt;/li&gt;
&lt;li&gt;Spring应用上下文刷新阶段: onRefresh&lt;/li&gt;
&lt;li&gt;Spring事件监听器注册阶段: registerListener&lt;/li&gt;
&lt;li&gt;BeanFactory初始化完成阶段: finishBeanFactoryInitialization&lt;/li&gt;
&lt;li&gt;Spring应用上下文刷新完成阶段: finishRefresh&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;准备刷新阶段&lt;/h3&gt;
&lt;p&gt;prepareRefresh方法注释如下所示，可以看出，这个方法主要做了三件事来准备上下文刷新:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;设置启动时间&lt;/li&gt;
&lt;li&gt;设置激活标&lt;/li&gt;
&lt;li&gt;执行任何初始化属性来源&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1340552/202102/1340552-20210214172238169-1131852505.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; prepareRefresh() {
        &lt;/span&gt;&lt;span&gt;//设置启动时间、激活标&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.startupDate =&lt;span&gt; System.currentTimeMillis();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.closed.set(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.active.set(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (logger.isDebugEnabled()) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (logger.isTraceEnabled()) {
                logger.trace(&lt;/span&gt;&quot;Refreshing &quot; + &lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                logger.debug(&lt;/span&gt;&quot;Refreshing &quot; +&lt;span&gt; getDisplayName());
            }
        }

        &lt;/span&gt;&lt;span&gt;//初始化属性源，扩展用&lt;/span&gt;
&lt;span&gt;        initPropertySources();

        &lt;/span&gt;&lt;span&gt;//校验必要属性&lt;/span&gt;
&lt;span&gt;        getEnvironment().validateRequiredProperties();

        &lt;/span&gt;&lt;span&gt;//创建存储早期applicationListeners容器&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.earlyApplicationListeners == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.earlyApplicationListeners = &lt;span&gt;new&lt;/span&gt; LinkedHashSet&amp;lt;&amp;gt;(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.applicationListeners);
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.applicationListeners.clear();
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.applicationListeners.addAll(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.earlyApplicationListeners);
        }

        &lt;/span&gt;&lt;span&gt;//创建存储早期applicationEvents容器，存储早期Spring Application事件，用于后面applicationEventMulticaster发布事件用&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.earlyApplicationEvents = &lt;span&gt;new&lt;/span&gt; LinkedHashSet&amp;lt;&amp;gt;&lt;span&gt;();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;BeanFactory创建阶段&lt;/h3&gt;
&lt;p&gt;在AbstractRefreshableApplicationContext的refreshBeanFactory实现里，会对这个应用上下文的底层BeanFactory做一个刷新，如果之前有BeanFactory，会先停止，再初始化一个新的BeanFactory&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1340552/202102/1340552-20210214173942269-1295449109.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; refreshBeanFactory() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; BeansException {&lt;br/&gt;　　　　 //如果有BeanFactory，先关掉这个BeanFactory　　
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (hasBeanFactory()) {
            destroyBeans();
            closeBeanFactory();
        }
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {&lt;br/&gt;　　　　　　  //创建新的BeanFactory
            DefaultListableBeanFactory beanFactory &lt;/span&gt;=&lt;span&gt; createBeanFactory();&lt;br/&gt;　　　　　　  //设置BeanFactory的id
            beanFactory.setSerializationId(getId());&lt;br/&gt;　　　　　　  //设置是否允许BeanDefinition覆盖、是否允许循环依赖
            customizeBeanFactory(beanFactory);&lt;br/&gt;　　　　　　  //加载BeanDefinition
            loadBeanDefinitions(beanFactory);&lt;br/&gt;　　　　　　  //设置新的BeanFactory为当前应用上下文IoC容器
            &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.beanFactoryMonitor) {
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.beanFactory =&lt;span&gt; beanFactory;
            }
        }
        &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException ex) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ApplicationContextException(&quot;I/O error parsing bean definition source for &quot; +&lt;span&gt; getDisplayName(), ex);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;BeanFactory准备阶段&lt;/h3&gt;
&lt;p&gt;配置容器上下文特征，例如上下文的ClassLoader和后置处理器。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1340552/202102/1340552-20210214175231733-418553357.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) {
        &lt;/span&gt;&lt;span&gt;//设置容器使用的类加载器: ClassLoader，默认是线程上下文类设置的加载器&lt;/span&gt;
&lt;span&gt;        beanFactory.setBeanClassLoader(getClassLoader());&lt;br/&gt;　　　　 //设置Bean表达式处理器，指定bean definition中的表达是值的解析策略
        beanFactory.setBeanExpressionResolver(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));&lt;br/&gt;　　　　 //添加PropertyEditorRegistrar实现，存储ResourceLoader和PropertyResolver
        beanFactory.addPropertyEditorRegistrar(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; ResourceEditorRegistrar(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, getEnvironment()));

        &lt;/span&gt;&lt;span&gt;//添加BeanPostProcessor实现，用于处理ApplicationContext的Aware回调&lt;/span&gt;
        beanFactory.addBeanPostProcessor(&lt;span&gt;new&lt;/span&gt; ApplicationContextAwareProcessor(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;));&lt;br/&gt;　　　　 //忽略指定接口作为依赖注入接口
        beanFactory.ignoreDependencyInterface(EnvironmentAware.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        beanFactory.ignoreDependencyInterface(ResourceLoaderAware.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        beanFactory.ignoreDependencyInterface(MessageSourceAware.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        beanFactory.ignoreDependencyInterface(ApplicationContextAware.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;//注册ResolvableDependency，这部分可以被依赖注入但不能被依赖查找&lt;/span&gt;
        beanFactory.registerResolvableDependency(BeanFactory.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, beanFactory);
        beanFactory.registerResolvableDependency(ResourceLoader.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
        beanFactory.registerResolvableDependency(ApplicationEventPublisher.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
        beanFactory.registerResolvableDependency(ApplicationContext.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;//注册ApplicationListener探测器，如果一个Bean实现了ApplicationListener接口会被当作ApplicationListener注册到Publisher&lt;/span&gt;
        beanFactory.addBeanPostProcessor(&lt;span&gt;new&lt;/span&gt; ApplicationListenerDetector(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;));

        &lt;/span&gt;&lt;span&gt;//注册动态织入后置处理器&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {
            beanFactory.addBeanPostProcessor(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; LoadTimeWeaverAwareProcessor(beanFactory));
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Set a temporary ClassLoader for type matching.&lt;/span&gt;
            beanFactory.setTempClassLoader(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));
        }

        &lt;/span&gt;&lt;span&gt;//注册环境Bean单例对象&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) {
            beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) {
            beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) {
            beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;BeanFactory后置处理阶段&lt;/h3&gt;
&lt;p&gt;postProcessBeanFactory和invokeBeanFactoryPostProcessors都是Spring提供的扩展方式。&lt;/p&gt;
&lt;p&gt;postProcessBeanFactory在AbstractApplicationContext里没有实际实现，postProcessBeanFactory注释如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1340552/202102/1340552-20210214210135822-11211786.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 可以看出这时Spring应用上下文内部BeanFactory已经标准初始化完成，这时所有Bean的BeanDefinition已经被加载进来，但是还没有被实例化，这时允许继承类注册特殊的BeanPostProcessors等内容。&lt;/p&gt;
&lt;p&gt;invokeBeanFactoryPostProcessors方法注释如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1340552/202102/1340552-20210214210609539-1708034934.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 这个方法会实例化并且执行所有被注册的BeanFactoryPostProcessor的Bean，如果给定显示顺序，按显示顺序执行，invokeBeanFactoryPostProcessors代码如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) {&lt;br/&gt;　　　　 //处理BeanFactoryPostProcessors，这里细节挺多的，要按一定顺序执行BeanDefinitionRegistryPostProcessor#postProcessBeanDefinitionRegistry和BeanFactoryPostProcessor#postProcessBeanFactory
        PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());

        &lt;/span&gt;&lt;span&gt;//添加LoadTimeWeaverAwareProcessor&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (beanFactory.getTempClassLoader() == &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {
            beanFactory.addBeanPostProcessor(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; LoadTimeWeaverAwareProcessor(beanFactory));
            beanFactory.setTempClassLoader(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;BeanFactory注册BeanPostProcessor&lt;/h3&gt;
&lt;p&gt;registerBeanPostProcessors方法注释如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1340552/202102/1340552-20210214213040444-767379046.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 这个方法的作用就是实例化并且注册所有BeanPostProcessor的Bean，会按给定顺序注册。&lt;/p&gt;
&lt;p&gt;这里注册的顺序是:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;先注册实现PriorityOrdered的BeanPostProcessor的Bean&lt;/li&gt;
&lt;li&gt;再注册实现Ordered的BeanPostProcessor的Bean&lt;/li&gt;
&lt;li&gt;然后注册普通的BeanPostProcessor的Bean&lt;/li&gt;
&lt;li&gt;后面注册MergedBeanDefinitionPostProcess的Bean&lt;/li&gt;
&lt;li&gt;最后注册ApplicationListenerDetector的Bean&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt; 初始化内建Bean&lt;/h3&gt;
&lt;p&gt;初始化内建Bean会初始化两个Bean: MessageSource和ApplicationEventMulticaster。&lt;/p&gt;
&lt;p&gt;这两个实现比较类似，都是判断当前BeanFactory(不判断父BeanFactory)是否包含对应Bean，如果不包含，就创建并且用registerSingleton方法注册到BeanFactory。&lt;/p&gt;
&lt;h3&gt;Spring应用上下文刷新阶段&lt;/h3&gt;
&lt;p&gt;onRefresh方法注释如下所示:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1340552/202102/1340552-20210214214817920-524737277.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  onRefresh方法是个可以被子类覆盖的模板方法，可以在实例化单例前初始化特殊的Bean。&lt;/p&gt;
&lt;h3&gt;Spring事件监听器注册阶段&lt;/h3&gt;
&lt;p&gt;registerListeners方法注释如下所示:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1340552/202102/1340552-20210214221056706-1719206449.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  registerListeners方法会把实现ApplicationListener的Bean和非Bean对象注册到ApplicationEventMulticaster。&lt;/p&gt;
&lt;p&gt;registerListeners方法代码如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; registerListeners() {
        &lt;/span&gt;&lt;span&gt;//注册非Bean的ApplicationListener实现类的对象&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; (ApplicationListener&amp;lt;?&amp;gt;&lt;span&gt; listener : getApplicationListeners()) {
            getApplicationEventMulticaster().addApplicationListener(listener);
        }

        &lt;/span&gt;&lt;span&gt;//注册ApplicationListener实现类对应的Bean&lt;/span&gt;
        String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.&lt;span&gt;class&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (String listenerBeanName : listenerBeanNames) {
            getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);
        }

        &lt;/span&gt;&lt;span&gt;//发送早期ApplicationEvent事件&lt;/span&gt;
        Set&amp;lt;ApplicationEvent&amp;gt; earlyEventsToProcess = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.earlyApplicationEvents;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.earlyApplicationEvents = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (earlyEventsToProcess != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (ApplicationEvent earlyEvent : earlyEventsToProcess) {
                getApplicationEventMulticaster().multicastEvent(earlyEvent);
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;BeanFactory初始化完成阶段&lt;/h3&gt;
&lt;p&gt;finishBeanFactoryInitialization方法注释如下所示:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1340552/202102/1340552-20210214222021544-250719355.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 这个方法会结束Spring应用上下文的BeanFactory的初始化，初始化所有剩余的单例Bean。&lt;/p&gt;
&lt;p&gt;finishBeanFactoryInitialization方法代码如下所示:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) {
        &lt;/span&gt;&lt;span&gt;//如果BeanFactory有ConversionService对象，关联到BeanFactory&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;amp;&amp;amp;&lt;span&gt;
                beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)) {
            beanFactory.setConversionService(
                    beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;));
        }

        &lt;/span&gt;&lt;span&gt;//添加StringValueResolver对象&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;beanFactory.hasEmbeddedValueResolver()) {
            beanFactory.addEmbeddedValueResolver(strVal &lt;/span&gt;-&amp;gt;&lt;span&gt; getEnvironment().resolvePlaceholders(strVal));
        }

        &lt;/span&gt;&lt;span&gt;//依赖查找LoadTimeWeaverAware的Bean&lt;/span&gt;
        String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.&lt;span&gt;class&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (String weaverAwareName : weaverAwareNames) {
            getBean(weaverAwareName);
        }

        &lt;/span&gt;&lt;span&gt;//BeanFactory临时ClassLoader置为null&lt;/span&gt;
        beanFactory.setTempClassLoader(&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;//BeanFactory冻结配置&lt;/span&gt;
&lt;span&gt;        beanFactory.freezeConfiguration();

        &lt;/span&gt;&lt;span&gt;//实例化所有不是懒加载的单例对象&lt;/span&gt;
&lt;span&gt;        beanFactory.preInstantiateSingletons();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Spring应用上下文刷新完成阶段&lt;/h3&gt;
&lt;p&gt;finishRefresh方法注释如下所示:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1340552/202102/1340552-20210214223355096-628623322.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  finishRefresh方法结束Spring应用上下文刷新，调用LifecycleProcessor#onRefresh方法并且发送ContextRefreshedEvent。&lt;/p&gt;
&lt;p&gt;finishRefresh方法代码如下所示:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; finishRefresh() {
        &lt;/span&gt;&lt;span&gt;//清除ResourceLoader缓存&lt;/span&gt;
&lt;span&gt;        clearResourceCaches();

        &lt;/span&gt;&lt;span&gt;//初始化LifecycleProcessor对象&lt;/span&gt;
&lt;span&gt;        initLifecycleProcessor();

        &lt;/span&gt;&lt;span&gt;//调用LifecycleProcessor#onRefresh方法&lt;/span&gt;
&lt;span&gt;        getLifecycleProcessor().onRefresh();

        &lt;/span&gt;&lt;span&gt;//发布Spring应用上下文已刷新事件&lt;/span&gt;
        publishEvent(&lt;span&gt;new&lt;/span&gt; ContextRefreshedEvent(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;));

        &lt;/span&gt;&lt;span&gt;//向MBeanServer托管Live Bean&lt;/span&gt;
        LiveBeansView.registerApplicationContext(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;start-启动应用上下文&lt;/h2&gt;
&lt;p&gt;start方法代码如下所示:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; start() {&lt;br/&gt;　　　　 //启动LifecycleProcessor
        getLifecycleProcessor().start();&lt;br/&gt;　　　　 //发布应用上下文启动事件
        publishEvent(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; ContextStartedEvent(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;));
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;stop-停止应用上下文&lt;/h2&gt;
&lt;p&gt;stop方法代码如下所示:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; stop() {&lt;br/&gt;　　　　 //停止LifecycleProcessor
        getLifecycleProcessor().stop();&lt;br/&gt;　　　　 //发布应用上下文停止事件
        publishEvent(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; ContextStoppedEvent(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;));
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;close-关闭应用上下文&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; doClose() {
        &lt;/span&gt;&lt;span&gt;//检查激活标&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.active.get() &amp;amp;&amp;amp; &lt;span&gt;this&lt;/span&gt;.closed.compareAndSet(&lt;span&gt;false&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;)) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (logger.isDebugEnabled()) {
                logger.debug(&lt;/span&gt;&quot;Closing &quot; + &lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
            }
　　　　　　  //Live Bean注销托管
            LiveBeansView.unregisterApplicationContext(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;//发布Spring应用上下文已关闭事件&lt;/span&gt;
                publishEvent(&lt;span&gt;new&lt;/span&gt; ContextClosedEvent(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;));
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable ex) {
                logger.warn(&lt;/span&gt;&quot;Exception thrown from ApplicationListener handling ContextClosedEvent&quot;&lt;span&gt;, ex);
            }

            &lt;/span&gt;&lt;span&gt;//关闭LifecycleProcessor&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.lifecycleProcessor != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.lifecycleProcessor.onClose();
                }
                &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable ex) {
                    logger.warn(&lt;/span&gt;&quot;Exception thrown from LifecycleProcessor on context close&quot;&lt;span&gt;, ex);
                }
            }

            &lt;/span&gt;&lt;span&gt;//销毁Spring Bean&lt;/span&gt;
&lt;span&gt;            destroyBeans();

            &lt;/span&gt;&lt;span&gt;//关闭BeanFactory&lt;/span&gt;
&lt;span&gt;            closeBeanFactory();

            &lt;/span&gt;&lt;span&gt;//回调onClose&lt;/span&gt;
&lt;span&gt;            onClose();

            &lt;/span&gt;&lt;span&gt;//重置本地监听者&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.earlyApplicationListeners != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.applicationListeners.clear();
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.applicationListeners.addAll(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.earlyApplicationListeners);
            }

            &lt;/span&gt;&lt;span&gt;//激活标设置为没激活&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;.active.set(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Sun, 14 Feb 2021 15:08:00 +0000</pubDate>
<dc:creator>Gouden</dc:creator>
<og:description>Spring应用上下文生命周期整体分成四个阶段 ConfigurableApplicationContext#refresh，加载或者刷新持久化配置 ConfigurableApplicationCo</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/gouden/p/14402955.html</dc:identifier>
</item>
<item>
<title>痞子衡嵌入式：超级下载算法(RT-UFL)开发笔记（4） - 轮询Flash配置参数 - 痞子衡</title>
<link>http://www.cnblogs.com/henjay724/p/14402901.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/henjay724/p/14402901.html</guid>
<description>&lt;p&gt;本篇是开发笔记第四篇，咱们就重点聊聊如何让超级下载算法适用不同厂商生产的不同属性串行NOR Flash。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;147.47307916182&quot;&gt;
&lt;hr/&gt;&lt;p&gt;　　大家好，我是痞子衡，是正经搞技术的痞子。今天痞子衡给大家介绍的是&lt;strong&gt;超级下载算法开发笔记(4)之轮询Flash配置参数&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　文接上篇 &lt;a href=&quot;https://www.cnblogs.com/henjay724/p/14401262.html&quot; target=&quot;_blank&quot;&gt;《超级下载算法(RT-UFL)开发笔记（3） - 统一FlexSPI驱动访问》&lt;/a&gt;，现在超级下载算法中已经集成了BootROM版本的统一FlexSPI驱动，原则上BootROM能支持启动的所有串行NOR Flash型号，超级下载算法都可以对其进行擦写操作。BootROM虽然可以支持很多种不同的Flash，但其需要依赖用户提供一个名为FDCB的配置结构体放置在Flash固定偏移处，BootROM先配置FlexSPI为1bit SDR低速模式去访问Flash获取到FDCB，然后从FDCB中得到当前Flash的全部属性再去重新初始化FlexSPI外设。然而超级下载算法没法从用户处获取到Flash的信息，只能自力更生，使用轮询的方法去不断尝试，直到试出合适的配置参数。&lt;/p&gt;
&lt;p&gt;　　本篇是开发笔记第四篇，咱们就重点聊聊如何让超级下载算法适用不同厂商生产的不同属性串行NOR Flash。&lt;/p&gt;
&lt;h3 id=&quot;一、bootrom对flash的支持（fdcb）&quot;&gt;一、BootROM对Flash的支持（FDCB）&lt;/h3&gt;
&lt;p&gt;　　前言里讲了BootROM对Flash的支持是靠不同的FDCB结构体配置值来实现的，这个FDCB一共512bytes，原型及各byte定义在i.MXRT1xxx参考手册System Boot章节里 &lt;strong&gt;Serial NOR configuration block (512 bytes)&lt;/strong&gt; 一小节有详细介绍。这个FDCB主要是用于配置FlexSPI外设的，咱们超级下载算法的 flexspi_nor_flash_init() 函数的一个主要参数 flexspi_nor_config_t 其实就是FDCB。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C&quot;&gt;status_t flexspi_nor_flash_init(uint32_t instance, flexspi_nor_config_t *config);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　关于这个FDCB具体如何赋值，恩智浦官网有一些应用笔记，这些应用笔记介绍了一些典型的Flash型号应该匹配什么样的FDCB值，从这些应用笔记里我们可以大概了解FDCB用法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/cnblogs/RT-UFL_DevNote4_ANs.PNG&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　上面的应用笔记里列举了一些BootROM支持的Flash型号，这些型号仅仅是恩智浦工程师验证过的型号，而客户在实际项目中用到的Flash型号远远不止这些。从Flash型号本身角度来看，不同厂商的不同型号是独特且唯一的，但从FDCB角度而言，很多同类型Flash型号其实是一样的配置值。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/cnblogs/RT-UFL_DevNote4_QSPI_Flashs.PNG&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/cnblogs/RT-UFL_DevNote4_Octal_Flashs.PNG&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;二、快速生成fdcb的方法（config-option）&quot;&gt;二、快速生成FDCB的方法（config option）&lt;/h3&gt;
&lt;p&gt;　　那么我们现在是不是直接在超级下载算法中穷举不同的FDCB值去轮询呢？要知道FDCB有512bytes，这是个不小的结构体，轮询一遍太费时且低效了。我们需要进一步提炼FDCB，将其精简一下，只轮询那些跟Flash类型紧密相关的参数。这个工作其实也不需要我们做了，恩智浦ROM研发小组已经做好了，那便是8bytes的config option配置结构体，这个配置结构体也是超级下载算法的 flexspi_nor_get_config() 函数的一个主要参数 serial_nor_config_option_t。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C&quot;&gt;status_t flexspi_nor_get_config(uint32_t instance, flexspi_nor_config_t *config, serial_nor_config_option_t *option);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　其实这个神奇的8bytes的config option配置结构体不止一次地出现过痞子衡之前的文章里：&lt;a href=&quot;https://www.cnblogs.com/henjay724/p/13602259.html&quot; target=&quot;_blank&quot;&gt;《导致串行NOR Flash在i.MXRT下无法正常下载/启动的常见因素之SFDP》&lt;/a&gt;、&lt;a href=&quot;https://www.cnblogs.com/henjay724/p/13614684.html&quot; target=&quot;_blank&quot;&gt;《导致串行NOR Flash在i.MXRT下无法正常下载/启动的常见因素之QE bit》&lt;/a&gt;、&lt;a href=&quot;https://www.cnblogs.com/henjay724/p/13125636.html&quot; target=&quot;_blank&quot;&gt;《FlexSPI NOR启动时间(RT1170)》&lt;/a&gt;、&lt;a href=&quot;https://www.cnblogs.com/henjay724/p/12984020.html&quot; target=&quot;_blank&quot;&gt;《MCUBootUtility v2.3发布，这次不再放过任何一款Flash》&lt;/a&gt;，它非常精炼地概括了市面上主要的串行NOR Flash特性（都要符合JESD216规范），只要你提供config option，经过 flexspi_nor_get_config() 函数执行后便可以自动生成相对应的完整FDCB。&lt;/p&gt;
&lt;p&gt;　　在i.MXRTxxx参考手册Non-Secure Boot ROM章节里你可以找到如下典型Flash型号对应的参考config option值：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/cnblogs/RT-UFL_DevNote4_config_options.PNG&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;三、利用config-option来做轮询&quot;&gt;三、利用config option来做轮询&lt;/h3&gt;
&lt;p&gt;　　直接利用512bytes的FDCB去轮询太难，但利用8bytes的config option去轮询就简单多了。我们顺着上文中提及的ufl_target_desc_t结构体，在其中新增几个成员（FlexSPI外设编号/基址/映射地址，config option），其中轮询主要跟config option有关。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C&quot;&gt;typedef struct _target_desc
{
    uint32_t imxrtChipId;
    uint32_t flexspiInstance;                 // 新增
    uint32_t flexspiBaseAddr;                 // 新增
    uint32_t flashBaseAddr;                   // 新增
    serial_nor_config_option_t configOption;  // 新增
    flexspi_nor_flash_driver_t flashDriver;
    flexspi_bsp_driver_t flexspiBsp;
} ufl_target_desc_t;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　然后我们定义一个config option型的数组 s_flashConfigOpt[]，里面存放一些经典的config option值。当前痞子衡的设计是仅轮询这些经典的config option值，并没有穷举config option，这也是从超级下载算法的执行效率角度考虑，这些经典的config option值足以覆盖80%以上的Flash型号了（后期如果要提高Flash覆盖率，会考虑转到穷举法的）。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C&quot;&gt;static const serial_nor_config_option_t s_flashConfigOpt[] = {
    // For Normal Quad, eg. IS25LP064A, GD25LB256E
    {.option0.U = 0xc0000001, .option1.U = 0x00000000},

    // For Normal Octal, eg. MX25UM51345G
    {.option0.U = 0xc0403001, .option1.U = 0x00000000},
    {.option0.U = 0xc1503051, .option1.U = 0x20000014},

    // For Normal HyperBus, eg. S26KS512S, IS26KS512S
    {.option0.U = (0xc0233000 + kSerialNorCfgOption_MaxFreq), .option1.U = 0x00000000},

    // For Normal Octal, eg. MX25UM51245G
    {.option0.U = 0xc0403031, .option1.U = 0x00000000},

    // For Normal Octal, eg. MT35X
    {.option0.U = 0xc0603001, .option1.U = 0x00000000},
    // For Normal Octal, eg. ATXP032
    {.option0.U = 0xc0803001, .option1.U = 0x00000000},

    // For Normal 1-bit SDR
    {.option0.U = FLASH_CONFIG_OPT_1BIT_SDR, .option1.U = 0x00000000},
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　关于具体轮询操作，源码在 &lt;a href=&quot;https://github.com/JayHeng/RT-UFL&quot; target=&quot;_blank&quot;&gt;RT-UFL&lt;/a&gt; 项目中的ufl_auto_probe_flash.c 文件里，痞子衡就不再贴出了，只讲一下几个要点：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;要点 1: 对于一些SIP版本的i.MXRT型号，没有必要再轮询了，直接给预设的config option值即可。&lt;/li&gt;
&lt;li&gt;要点 2: config option参数轮询成功的判断标准是，执行初始化-&amp;gt;擦-&amp;gt;写操作均正常（或许还要加入回读校验）。&lt;/li&gt;
&lt;li&gt;要点 3: 当前config option参数轮询失败进到下一个option值前需要对FlexSPI外设进行复位（有条件的话还要对Flash进行复位）。&lt;/li&gt;
&lt;li&gt;要点 4: 不同Flash型号支持的最大速度不同，轮询时总是先从最低速开始，慢慢增速到最大支持的速度（当前是100MHz，后期会调整）。&lt;/li&gt;
&lt;li&gt;要点 5: 为了照顾没有SFDP表的Flash（或不符合JESD216规范），轮询过程里增加了一个1bit SDR属性的FDCB表作为最后一个保底轮询。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;　　至此，超级下载算法开发笔记(4)之轮询Flash配置参数痞子衡便介绍完毕了，掌声在哪里~~~&lt;/p&gt;
&lt;h3 id=&quot;欢迎订阅&quot;&gt;欢迎订阅&lt;/h3&gt;
&lt;p&gt;文章会同时发布到我的 &lt;a href=&quot;https://www.cnblogs.com/henjay724/&quot; target=&quot;_blank&quot;&gt;博客园主页&lt;/a&gt;、&lt;a href=&quot;https://blog.csdn.net/henjay724&quot; target=&quot;_blank&quot;&gt;CSDN主页&lt;/a&gt;、&lt;a href=&quot;https://www.zhihu.com/people/henjay724&quot; target=&quot;_blank&quot;&gt;知乎主页&lt;/a&gt;、&lt;a href=&quot;http://weixin.sogou.com/weixin?type=1&amp;amp;query=%E7%97%9E%E5%AD%90%E8%A1%A1%E5%B5%8C%E5%85%A5%E5%BC%8F&quot; target=&quot;_blank&quot;&gt;微信公众号&lt;/a&gt; 平台上。&lt;/p&gt;
&lt;p&gt;微信搜索&quot;&lt;strong&gt;痞子衡嵌入式&lt;/strong&gt;&quot;或者扫描下面二维码，就可以在手机上第一时间看了哦。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/github/pzhMcu_qrcode_258x258.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Sun, 14 Feb 2021 14:45:00 +0000</pubDate>
<dc:creator>痞子衡</dc:creator>
<og:description>本篇是开发笔记第四篇，咱们就重点聊聊如何让超级下载算法适用不同厂商生产的不同属性串行NOR Flash。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/henjay724/p/14402901.html</dc:identifier>
</item>
<item>
<title>Kafka 博文索引 - buttercup</title>
<link>http://www.cnblogs.com/buttercup/p/14402878.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/buttercup/p/14402878.html</guid>
<description>&lt;p&gt;数据是系统的燃料，系统的效率高低很大程度取决于数据流转是否及时：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;将数据从生产源头移动到分析处理终端，这个过程完成得越快，组织的反应就越敏捷。&lt;/li&gt;
&lt;li&gt;移动工具越是简单易用，花费在数据移动上的精力就越少，开发者就越能专注于核心业务。&lt;/li&gt;
&lt;/ul&gt;&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;data:image/png;base64,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&quot; width=&quot;300&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Kafka 是一款为数据整合而生的基于发布与订阅的消息系统&lt;code&gt;Messaging System&lt;/code&gt;，方便用户在多系统间实现松散耦合的异步数据传输。&lt;/p&gt;
&lt;p&gt;Kafka 为消息提供顺序持久化保存，可按需读取。并通过集群部署与冗余副本保障数据安全并提供性能伸缩能力。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/buttercup/1776821/o_201222145303kafka_ecosystem.gif&quot; width=&quot;400&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;核心概念&quot;&gt;核心概念&lt;/h2&gt;
&lt;ul readability=&quot;5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;消息&lt;code&gt;message&lt;/code&gt;：最基本的数据单元，由字节数组组成。消息可以有一个可选的键&lt;code&gt;key&lt;/code&gt;，键也是一个字节数组。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;主题&lt;code&gt;topic&lt;/code&gt;：消息通过主题进行分类。主题就好比数据库的表，或者文件系统里的文件夹。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;分区&lt;code&gt;partition&lt;/code&gt;：一个提交日志，主题可以被分为若干个分区。消息以追加的方式写入分区尾部，然后以先入先出的顺序读取。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;偏移&lt;code&gt;offset&lt;/code&gt;：一个不断递增的整数值，在创建消息时指定。同个分区中每个消息的偏移量都是唯一的。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;生产者&lt;code&gt;producer&lt;/code&gt;：创建消息并将其发布到一个特定的主题上。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;消费者&lt;code&gt;consumer&lt;/code&gt;：订阅主题并按照消息生成的顺序读取消息。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;br/&gt;&lt;h2 id=&quot;消息分区&quot;&gt;消息分区&lt;/h2&gt;
&lt;p&gt;Kafka 通过分区来实现 &lt;strong&gt;数据冗余&lt;/strong&gt; 和 &lt;strong&gt;可伸缩性&lt;/strong&gt;：分区可以分布在不同的服务器上，一个主题可以横跨多个服务器，以此来提供比单个服务器更强大的性能。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/buttercup/1776821/o_201222145337kafka_topic_partition.gif&quot; width=&quot;450&quot;/&gt;&lt;/p&gt;
&lt;p&gt;要注意，由于一个主题一般包含几个分区，因此无法在整个主题范围内保证消息的顺序。生产者在默认情况下，会把消息均衡地分布到主题的所有分区上，而并不关心特定消息会被写到哪个分区。&lt;/p&gt;
&lt;p&gt;为了保证消息顺序可控，可以为同类消息指定相同的键，然后生产者会根据键的 &lt;strong&gt;hashmod&lt;/strong&gt; 结果选取分区，从而保证具有相同键的消息总会被写到相同的分区上。&lt;/p&gt;
&lt;br/&gt;&lt;h2 id=&quot;消费者组&quot;&gt;消费者组&lt;/h2&gt;
&lt;p&gt;每个分区只能被分配给一个消费者，然后消费者会按照消息生成的顺序读取它们。&lt;/p&gt;
&lt;p&gt;过程中，消费者会记录已读消息的偏移量，避免重复消费同一条消息。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/buttercup/1776821/o_201222145345kafka_topic_partition2.gif&quot; width=&quot;450&quot;/&gt;&lt;/p&gt;
&lt;p&gt;消息系统中常见的通信模型有两种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;消息队列&lt;code&gt;message queue&lt;/code&gt;：&lt;strong&gt;点对点&lt;/strong&gt;&lt;code&gt;point to point&lt;/code&gt;的排他通信，每条消息只会被消费一次。&lt;/li&gt;
&lt;li&gt;发布/订阅&lt;code&gt;pub/sub&lt;/code&gt;：类似广播通信，每条消息可能会被消费多次。&lt;/li&gt;
&lt;/ul&gt;&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/buttercup/1776821/o_201225165004msg_model.png&quot; width=&quot;450&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为了同时支持这两种模式，Kafka 在消费者端引入了 &lt;strong&gt;消费者组群&lt;/strong&gt;&lt;code&gt;counsumer group&lt;/code&gt;这一逻辑概念：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;不同的消费者组群之间彼此互不相关，两者消费到的消息是一致的，此时相当于实现了&lt;strong&gt;发布/订阅&lt;/strong&gt;模型。&lt;/li&gt;
&lt;li&gt;而同个组群的消费者之间存在互斥关系，每个消费者只能消费部分数据，此时相当于实现了&lt;strong&gt;消息队列&lt;/strong&gt;模型。&lt;/li&gt;
&lt;/ul&gt;&lt;br/&gt;&lt;h2 id=&quot;集群&quot;&gt;集群&lt;/h2&gt;
&lt;p&gt;一个独立的 Kafka 服务器被称为 broker，其主要职责有两个：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;接收来自生产者的消息，为消息设置偏移量，并提交消息到磁盘保存。&lt;/li&gt;
&lt;li&gt;为消费者提供服务，对读取分区的请求作出响应，返回已经提交到磁盘上的消息。&lt;/li&gt;
&lt;/ul&gt;&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/buttercup/1776821/o_201222150308kafka_replica.gif&quot; width=&quot;450&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为保证可用性，broker 以集群的方式部署。每个集群会自动选举出一个 controller 负责管理工作，包括将分区分配给 broker 和监控 broker。&lt;/p&gt;
&lt;p&gt;一个分区从属于一个 broker，该 broker 被称为分区的 leader。&lt;/p&gt;
&lt;p&gt;如果分区允许多副本&lt;code&gt;replica&lt;/code&gt;，这些副本会分布在多个 broker 上，此时会发生分区复制&lt;code&gt;replication&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这种复制机制为分区提供了消息冗余，当 leader 失效时分区会被其他 broker 接管，相关的消费者和生产者都会重连新的 leader。&lt;/p&gt;
&lt;br/&gt;&lt;h2 id=&quot;优势&quot;&gt;优势&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;系统解耦：异构系统可以通过 Kafka 进行通信，减少系统之间协调与开发成本。&lt;/li&gt;
&lt;li&gt;模型丰富：通过消费者组的概念，一份数据可以同时支持不同的通信模型，同能够满足不同的应用需求&lt;/li&gt;
&lt;li&gt;磁盘存储：Kafka 会将消息持久化到磁盘，允许消息积压并保证数据不会丢失，无需担心生产与消费速率不匹配的问题。&lt;/li&gt;
&lt;li&gt;横向扩展：Kafka 通过集群与分区的方式实现了横向扩展，并且可以在线对集群进行扩容。&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Sun, 14 Feb 2021 14:31:00 +0000</pubDate>
<dc:creator>buttercup</dc:creator>
<og:description>博文索引 KafkaBroker 简析 KafkaConsumer 简析 KafkaProducer 简析 KafkaMirrorMaker 的不足以及一些改进 Kafka 简介 数据是系统的燃料，系</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/buttercup/p/14402878.html</dc:identifier>
</item>
<item>
<title>浅谈WEB前端规范化标准之ESlint - メSerendipity</title>
<link>http://www.cnblogs.com/websiteblogs/p/14402773.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/websiteblogs/p/14402773.html</guid>
<description>&lt;p&gt;&lt;strong&gt;规范化标准&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;软件开发需要多人开发,不同的开发者具有不同的编码习惯和喜好,不同的喜好增加项目的维护成本，所以需要明确统一的标准,决定&lt;/p&gt;
&lt;p&gt;了项目的可维护性,人为的约定不可靠,所以需要专门的工具进行约束，并且可以配合自动化工具进行检查，这种专门的工具称为lint,&lt;/p&gt;
&lt;p&gt;前端接触最多的是ESLint，下面我们看下如何使用这些工具落实前端规范化操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ESLint介绍&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;目前最主流的JavaScript Lint工具 监测JS代码质量 ,统一开发者的编码风格,同时ESLint可以帮助开发者提升编码能力作用的一款工&lt;/p&gt;
&lt;p&gt;具,是npm的一个模块。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ESLint安装&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;yarn init --y&lt;/p&gt;
&lt;p&gt;yarn add eslint --save-dev&lt;/p&gt;
&lt;p&gt;yarn eslint --init （各种提示问题,我选择的检查语法,代码不合理，风格不统一等所有的规范,根据自己情况填写完成后生成.eslintrc.js&lt;/p&gt;
&lt;p&gt;配置文件）//项目初始化&lt;/p&gt;
&lt;p&gt;如下图所示可以写一些问题代码&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2257600/202102/2257600-20210214211934962-1250184879.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;运行yarn eslint xxx(上文定义的js文件)，会有很多错误提示，运行--fix可以自动帮我们解决大部分问题（样式问题）&lt;/p&gt;
&lt;p&gt;yarn  eslint xx --fix&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2257600/202102/2257600-20210214212346016-966021082.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;运行之后的结果提示有一个未使用的变量,还有一个未使用的方法，手动去掉之后，再次运行eslint --fix 结果无异常&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2257600/202102/2257600-20210214212410476-275087648.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ESlint 配置文件.eslintrc.js解析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;正常情况下,我们不需要手动配置，但是如果我们开启或者关闭某些校验规则的时候，就需要用到这个配置文件一般情况下,JavaScri-&lt;/p&gt;
&lt;p&gt;pt在不同的运行环境中是有不同的api可以被调用,很多都是以全局成员的形式提供出来,一旦开启代表所有的定义的成员都会被全局使&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt;用。&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;例如window和document对象是运行在浏览器环境中,而在node.js环境中不存在这些对象,如下图所示env的作用就是标记不同的运&lt;/p&gt;
&lt;p&gt;行环境,ESlint会根据成员信息判断环境是否是可用的。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;em&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2257600/202102/2257600-20210214212526463-597359028.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;如上图所示的env中如果把Browser设置为false,发现还是可以使用window和document还是可以使用这是因为在node_modules文件夹 &lt;/p&gt;
&lt;p&gt;下文件夹下的eslint-config-standard（yarn eslint --init初始化中选择使用standard规范）中的eslintrc.json中globals中设置了document&lt;/p&gt;
&lt;p&gt;等为全局只读成员,所以.eslintrc.js中无论设置true和false都会导致失效。&lt;/p&gt;
&lt;p&gt;extends:继承共享配置&lt;/p&gt;
&lt;p&gt;parserOptions:设置js的版本，代码低于该版本会无法执行&lt;/p&gt;
&lt;p&gt;rules:[]//配置ESLint中每个规则的开启或者关闭，属性为内置属性，属性value值为off warn error&lt;/p&gt;
&lt;p&gt;globals&lt;em&gt;:&lt;/em&gt;定义另外的全局变量,比如jquery，这样就可以使用jquery,也不会报错&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ESlint配置注释&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Eslint只是一个规则,总有一两个地方不适用的时候,这时候就可以通过注释的方式,让eslint跳过这行代码不解析,下面举一个小小的例子&lt;/p&gt;
&lt;p&gt;具体可以去看eslint文档看更多的注释方法。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;em&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2257600/202102/2257600-20210214212820003-371150690.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ESlint 结合webpack&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;Webpack&lt;/em&gt;打包之前是把遇到的模块交给对应的loader进行处理,eslint会通过loader的形式去集成到webpack中,这样通过打包之前校验代&lt;/p&gt;
&lt;p&gt;码,具体配置如下:&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;em&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2257600/202102/2257600-20210214212903094-507583677.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;对于react解析jsx语法则需要一些额外的配置&lt;/p&gt;
&lt;p&gt;yarn add eslint-plugin-react&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2257600/202102/2257600-20210214212933664-1341082877.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ESlint检查TypeScript&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;.eslintrc中需要配置针对ts的语法解析器,原因ts的很多语法是不同于js的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2257600/202102/2257600-20210214212958907-1704835005.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;stylelint的使用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;eslint是监测JS代码质量的工具,stylelint是检测css及less,sass代码质量的工具。&lt;/p&gt;
&lt;p&gt;yarn add stylelint --dev&lt;/p&gt;
&lt;p&gt;yarn add stylelint-config-standard //安装共享配置模块&lt;/p&gt;
&lt;p&gt;yarn add stylelint-config-sass-guidelines --dev 针对sass模块的检测&lt;/p&gt;
&lt;p&gt;与eslint不同的是.stylelintrc.js 不是通过初始化创建的 而是需要手动创建,stylelint配置如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2257600/202102/2257600-20210214213048809-893697199.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;prettier简介&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;prettier是目前最流行的一款修改代码样式格式统一的工具,针对多种css,js,vue等文件的格式&lt;/p&gt;
&lt;p&gt;yarn add prettier --dev&lt;/p&gt;
&lt;p&gt;yarn prettier . --write 即可覆盖原代码&lt;/p&gt;
&lt;p&gt;Git hooks工作机制（简单介绍）&lt;/p&gt;
&lt;p&gt;很多时候多人合作开发的项目中,或许有人忘记使用lint工具检测代码,就提交到git仓库,可能会引发后续问题,有一种结合git仓库的lint工&lt;/p&gt;
&lt;p&gt;具,在提交代码前进行代码检测。&lt;/p&gt;
&lt;p&gt;首先新建个文件夹,git init后点击.git文件夹里面的hooks文件夹,复制pre-commit.sample文件,改名为pre-commit,可以在里面测试下写下&lt;/p&gt;
&lt;p&gt;shell脚本语句输出内容&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;em&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2257600/202102/2257600-20210214213206065-611875706.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;touch demo.txt //新建测试文件&lt;/p&gt;
&lt;p&gt;vim demo.txt //填充demo文件&lt;/p&gt;
&lt;p&gt;git add .&lt;/p&gt;
&lt;p&gt;git commit -m &quot;xxxxx&quot;&lt;/p&gt;
&lt;p&gt;执行完上步操作之后,我们可以看到before code打印到控制台当中,说明已经工作了,我们就可以想办法在提交代码之前做lint操作。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;em&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2257600/202102/2257600-20210214213309572-1497542651.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;ESLint 结合Git Hooks的使用&lt;/p&gt;
&lt;p&gt;很多情况下,很多前端开发者不太擅长shell脚本开发一些功能,而有些功能必须要使用的，所以有人开发了一个npm的工作模块Husky&lt;/p&gt;
&lt;p&gt;可以实现Git Hooks的使用需求,下面来测试下Husky与一些相关配置的组合使用（需要把上文中测试创建的pre-commit文件删除掉）&lt;/p&gt;
&lt;p&gt;yarn add husky --dev 首先安装husky模块&lt;/p&gt;
&lt;p&gt;package.json中定义不同的任务&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2257600/202102/2257600-20210214213407159-1509905529.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;配置好后,再次执行commit操作,会先进行检查,如果 有问题会阻止提交代码操作,如果想检查出问题之后添加格式化的功能，需要添加l&lt;/p&gt;
&lt;p&gt;int-staged模块配合husky使用。&lt;/p&gt;
&lt;p&gt;yarn add lint-staged --dev&lt;/p&gt;
&lt;p&gt;package.json配置完成后再次执行commit操作，不但会对代码进行检查,还会执行代码初始化的操作&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;em&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2257600/202102/2257600-20210214213500557-86801570.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt;/**************************************************************************************************************************************************/&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2021,砥砺前行，加油！&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 14 Feb 2021 13:39:00 +0000</pubDate>
<dc:creator>メSerendipity</dc:creator>
<og:description>规范化标准 软件开发需要多人开发,不同的开发者具有不同的编码习惯和喜好,不同的喜好增加项目的维护成本，所以需要明确统一的标准,决定 了项目的可维护性,人为的约定不可靠,所以需要专门的工具进行约束，并且</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/websiteblogs/p/14402773.html</dc:identifier>
</item>
</channel>
</rss>