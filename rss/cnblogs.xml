<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>利用FlubuCore用C#来写DevOps脚本 - Savorboard</title>
<link>http://www.cnblogs.com/savorboard/p/flubucore.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/savorboard/p/flubucore.html</guid>
<description>&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;随着近些年微服务的流行，有越来越多的开发者和团队所采纳和使用，它的确提供了很多的优势也解决了很多的问题，但是我们也知道也并不是银弹，提供优势的同时它也给我们的开发人员和团队也带来了很多的挑战。&lt;/p&gt;
&lt;p&gt;为了迎接或者采用这些新技术，开发团队需要更加注重一些流程或工具的使用，这样才能更好的适应这些新技术所带来的一些问题。 对于流程行问题，敏捷的Scrum能够很好的提升产品开发团队之间的协作问题，那么对于应用变的越来越复杂这种情况，它最直接的问题就是带来了开发运维的复杂性，这个时候我们就需要使用工具来解决了。&lt;/p&gt;
&lt;h3 id=&quot;开发运维的复杂性&quot;&gt;开发运维的复杂性&lt;/h3&gt;
&lt;p&gt;从字面意思可以看出开发运维的复杂性指的是开发的复杂以及运维的复杂，然后我们具体来说一下到底是怎么复杂的。&lt;/p&gt;
&lt;p&gt;我们先说开发的复杂性, 应用由单体变成分布式，需要处理分布式系统遇到的所有问题。 我在之前的&lt;a href=&quot;http://www.cnblogs.com/savorboard/p/aspnetcore-microservice2.html&quot;&gt;博客&lt;/a&gt;里面大致都说过遇到的一些挑战，感兴趣的同学可以跳过去看下。&lt;/p&gt;
&lt;p&gt;除此之外就是遇到的另外一个也会导致变得复杂就是应用的构建和发布以及部署，因为涉及到的服务特别多就带来了很多的问题，所以遇到的这些问题你可以认为应该开发处理也可以认为应该运维处理，那么就合在一起叫开发运维问题吧。&lt;/p&gt;
&lt;p&gt;针对这种开发运维问题，业内提出了DevOps支持。&lt;/p&gt;
&lt;h3 id=&quot;devops&quot;&gt;DevOps&lt;/h3&gt;
&lt;p&gt;DevOps (Development和Operations的组合词)，他是一组过程、方法与系统的统称，用于促进开发（应用程序/软件工程）、技术运营和质量保障（QA）部门之间的沟通、协作与整合。&lt;/p&gt;
&lt;p&gt;这种整合在微服务团队变得尤其重要，在整合的过程中需要用到很多的一些工具来解决遇到的问题，总之一图胜千言。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/250417/202007/250417-20200703232504912-71992785.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上图可以看出在 Build 和 CI/CD 阶段需要用到很多的工具，我们需要写脚本对这些工具进行调用以便于让他们能够协同工作，通常我们会使用 shell 脚本，然后来调用这些工具提供的 cli 命令行，然后由构建平台来触发，比如 Jenkins 或者 GitLab CI, Team City 等等。&lt;/p&gt;
&lt;p&gt;那么对于不熟悉 shell 的同学，或者觉得使用 shell 效率太低又不方便维护有没有其他的工具可以使用呢，最好是C#可以直接写？ 答案当然是有的，今天就给大家强烈推荐一款利器 FlubuCore.&lt;/p&gt;
&lt;h3 id=&quot;flubucore-是什么&quot;&gt;FlubuCore 是什么?&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/250417/202007/250417-20200705184811194-1452831041.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/dotnetcore/FlubuCore&quot;&gt;FlubuCore&lt;/a&gt; 是一个跨平台的自动化构建和部署系统，用于使用C#代码构建项目和执行部署脚本。&lt;/p&gt;
&lt;p&gt;Github: &lt;a href=&quot;https://github.com/dotnetcore/FlubuCore&quot;&gt;https://github.com/dotnetcore/FlubuCore&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;文档：&lt;a href=&quot;https://flubucore-zh.dotnetcore.xyz/&quot;&gt;https://flubucore-zh.dotnetcore.xyz/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;FlubuCore 基于 MIT 协议开源，目前已经是 .NET Foundation 基金会项目成员，作者（&lt;a href=&quot;https://github.com/mzorec&quot;&gt;Marko Zorec&lt;/a&gt;）也是我们 NCC 的核心项目成员之一。&lt;/p&gt;
&lt;p&gt;现在你可以利用 C# 去编写构建和部署脚本，同时支持 .NET Framework 和 .NET Core，不需要再去学习其他工具或语言了，而且 FlubuCore 提供了一套 Fluent 式的 API，让你写起来根本停不下来。 看图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/250417/202007/250417-20200703234648492-1628969500.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;香不香？ 快去 &lt;a href=&quot;https://github.com/dotnetcore/FlubuCore&quot;&gt;Github&lt;/a&gt; 点个 Star 支持一下吧，你的一个小小的 Star 也是对整个 .NET 生态的贡献。&lt;/p&gt;
&lt;h3 id=&quot;flubucore-getting-started&quot;&gt;FlubuCore Getting Started&lt;/h3&gt;
&lt;p&gt;虽然 FlubuCore 提供的有&lt;a href=&quot;https://github.com/dotnetcore/FlubuCore/tree/master/lang/chinese&quot;&gt;中文的 Readme&lt;/a&gt;，不过我还是简单的带大家入个门吧。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 安装全局命令行工具&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;打开 CMD 执行一下命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;dotnet tool install --global FlubuCore.GlobalTool
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个命令的主要作用是安装一个全局的命令行工具，持续集成的平台后续就可以利用 &lt;code&gt;flube&lt;/code&gt; 这个命令行工具来执行C#自定义的脚本。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 新建一个空的解决方案&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mkdir FlubuTest
cd FlubuTest
dotnet new sln
mkdir src
cd src
mkdir mywebapp
cd mywebapp
dotnet new webapp
dotnet sln ../../FlubuTest.sln add ./mywebapp.csproj
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;觉得麻烦的，Visual Studio 直接新建就可以搞定了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 添加 Flubucore 构建项目&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;先切换到第2步的解决方案根目录 &lt;code&gt;cd ../../&lt;/code&gt;，然后创建build的入口项目：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;dotnet new -i FlubuCore.Template
dotnet new FlubuCore
dotnet sln FlubuTest.sln add ./BuildScript/BuildScript.csproj
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将 FlubuCore 添加到解决方案主要是后续编写脚本的方便，借助于 VisualStudio 的智能提示等就像编写C#代码一样了，实际上就是C#代码， 当然也可以选择不添加到项目中。&lt;/p&gt;
&lt;p&gt;最后的文件夹结构大概是这个样子的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;│──FlubuTest.sln
│
└──BuildScript
│      │  BuildScript.cs
│      │  BuildScript.csproj
└─src
    └─mywebapp
        │  appsettings.Development.json
        │  appsettings.json
        │  mywebapp.csproj
        │  Program.cs
        │  Startup.cs
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;4. 修改 BuildScript.cs 文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;打开 &lt;code&gt;BuildScript/BuildScript.cs&lt;/code&gt; 然后将&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;context.Properties.Set(BuildProps.SolutionFileName, &quot;Todo&quot;);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Todo 修改为解决方案的名字&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;context.Properties.Set(BuildProps.SolutionFileName, &quot;FlubeTest.sln&quot;);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;BuildProps&lt;/code&gt; 这个对象主要提供了在构建的过程中一些上下文信息，通过设置此对象你可以给flubu 提供更多信息以便于后续的使用等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5. 开始使用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在项目根目录打开 cmd， 然后使用下面的命令来编译你的项目。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;flubu compile
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中 &lt;code&gt;compile&lt;/code&gt; 就是文件 &lt;code&gt;_Build/BuildScript/BuildScript.cs&lt;/code&gt; 的这段代码里面的 compile，你可以随意更改，只需要和命令保持一致。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;protected override void ConfigureTargets(ITaskContext context)
{
    var compile = context.CreateTarget(&quot;compile&quot;)
        .SetDescription(&quot;Compiles the solution.&quot;)
        .AddCoreTask(x =&amp;gt; x.Build());
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;后面基本上你需要的构建的所有的东西都可以写到 &lt;code&gt;ConfigureTargets&lt;/code&gt; 里面了。&lt;/p&gt;
&lt;p&gt;最后的输出:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;D:\FlubuTest&amp;gt;flubu compile
Flubu v.4.3.5.0
Build script file name was not explicitly specified, searching the default locations:
Found it, using the build script file 'BuildScript/BuildScript.cs'.
Executing target compile
Executing task DotnetBuildTask
   Running program 'C:\Program Files\dotnet\dotnet.exe':(work.dir='',args=' build FlubuTest.sln')
   用于 .NET Core 的 Microsoft (R) 生成引擎版本 16.6.0+5ff7b0c9e
   版权所有(C) Microsoft Corporation。保留所有权利。
     正在确定要还原的项目…
     所有项目均是最新的，无法还原。
     BuildScript -&amp;gt; D:\FlubuTest\BuildScript\bin\Debug\netcoreapp2.1\BuildScript.dll
     mywebapp -&amp;gt; D:\FlubuTest\src\mywebapp\bin\Debug\netcoreapp3.1\mywebapp.dll
     mywebapp -&amp;gt; D:\FlubuTest\src\mywebapp\bin\Debug\netcoreapp3.1\mywebapp.Views.dll
   已成功生成。
       0 个警告
       0 个错误
   已用时间 00:00:02.51
compile finished (took 3 seconds)

BUILD SUCCESSFUL
Build finish time: 2020/7/4 0:47
Build duration: 00:00:03 (3 seconds)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可能有人会问，这和我用 &lt;code&gt;dotnet build FlubuTest.sln&lt;/code&gt; 有区别吗？&lt;br/&gt;针对这个示例而言，是没区别，但是你可以自己扩展啊，扩展后不就有区别了。比如你想build之前先清理文件夹之类的，可以这么写。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; var compile = context.CreateTarget(&quot;compile&quot;)
                .SetDescription(&quot;Compiles the solution.&quot;)
                .AddCoreTask(x =&amp;gt; x.Clean())
                .AddCoreTask(x =&amp;gt; x.Build());
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;借助于 flubu 提供的能力，可以在 CI/CD 界面解决很多复杂的构建问题。&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;上面的仅仅是一个入门，如果你觉得你们项目刚好需要那么你可以去官方的文档去查看，里面有更加详细的使用指南，当然也可以在这个博客下面留言或者去GitHub提交issue询问。&lt;/p&gt;
&lt;p&gt;GitHub: &lt;a href=&quot;https://github.com/dotnetcore/FlubuCore&quot;&gt;https://github.com/dotnetcore/FlubuCore&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;FlubuCore 给我们提供了一种可以快速编写 DevOps 脚本的能力，利用这种能力可以让DevOps变得更加简单和高效，从而提高效率节约时间。&lt;/p&gt;
&lt;p&gt;如果你觉得本篇文章对您有帮助的话，感谢您的【推荐】。&lt;/p&gt;
&lt;hr/&gt;&lt;blockquote readability=&quot;1.7032967032967&quot;&gt;
&lt;p&gt;本文地址：&lt;a href=&quot;http://www.cnblogs.com/savorboard/p/flubucore.html&quot;&gt;http://www.cnblogs.com/savorboard/p/flubucore.html&lt;/a&gt;&lt;br/&gt;作者博客：&lt;a href=&quot;http://www.cnblogs.com/savorboard&quot;&gt;Savorboard&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Mon, 06 Jul 2020 00:51:00 +0000</pubDate>
<dc:creator>Savorboard</dc:creator>
<og:description>前言 随着近些年微服务的流行，有越来越多的开发者和团队所采纳和使用，它的确提供了很多的优势也解决了很多的问题，但是我们也知道也并不是银弹，提供优势的同时它也给我们的开发人员和团队也带来了很多的挑战。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/savorboard/p/flubucore.html</dc:identifier>
</item>
<item>
<title>曹工说面试：当应用依赖jar包的A版本，中间件jar包依赖B版本，两个版本不兼容，这还怎么玩？ - 三国梦回</title>
<link>http://www.cnblogs.com/grey-wolf/p/13253014.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/grey-wolf/p/13253014.html</guid>
<description>&lt;p&gt;大一点的公司，可能有一些组，专门做中间件的；假设，某中间件小组，给你提供了一个jar包，你需要集成到你的应用里。假设，它依赖了一个日期类，版本是v1；我们应用也依赖了同名的一个日期类，版本是v2.&lt;/p&gt;
&lt;p&gt;两个版本的日期类，方法逻辑的实现，有一些差异。&lt;/p&gt;
&lt;p&gt;举个例子，中间件提供的jar包中，依赖如下工具包：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;com.example&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;common-v1&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该版本中，包含了com.example.date.util.CommonDateUtil这个类。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.example.date.util;

import lombok.extern.slf4j.Slf4j;

@Slf4j
public class CommonDateUtil {

    public static String format(String date) {
        // 1
        String s = date + &quot;- v1&quot;;
        log.info(&quot;v1 result:{}&quot;, s);
        return s;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;应用中，依赖如下jar包：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;&amp;lt;dependency&amp;gt;
   &amp;lt;groupId&amp;gt;com.example&amp;lt;/groupId&amp;gt;
   &amp;lt;artifactId&amp;gt;common-v2&amp;lt;/artifactId&amp;gt;
   &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该jar包中，包含同名的class，但里面的方法实现不一样：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Slf4j
public class CommonDateUtil {

    public static String format(String date) {
        String s = date + &quot;- v2&quot;;
        log.info(&quot;v2 result:{}&quot;, s);
        return s;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ok，那假设我们是一个spring boot应用，当中间件小组的哥们找到你，让你集成，你可能就愉快地弄进去了；但是，有个问题时，你的jar包、和中间件小哥的jar包，都是放在fatjar的lib目录的（我这里解压了，方便查看）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/519126/202007/519126-20200704175428182-1431868800.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;请问，最终加载的CommonDateUtil类，到底是common-v1的，还是commonv2中的呢？因为spring boot加载BOOT-INF/lib时，肯定都是同一个类加载器，同一个类加载器，对于一个包名和类名都相同的类，只会加载一次；那么，加载了v1，就不可能再加载V2；反之亦然。&lt;/p&gt;
&lt;p&gt;那这就出问题了。我们应用要用V2；中间件要用V1，水火不容啊，这可怎么办？&lt;/p&gt;

&lt;p&gt;首先，我们要重写spring boot的启动类，这是毋庸置疑的，启动类是哪个呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/519126/202007/519126-20200704180004136-1888872542.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为什么要重写这个？因为，我们问题分析里说了，当打成fat jar运行时，其结构如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;[root@mini2 temp]# tree 
.
├── BOOT-INF
│   ├── classes
│   │   ├── application.properties
│   │   ├── application.yml
│   │   └── com
│   │       └── example
│   │           └── demo
│   │               ├── CustomMiddleWareClassloader.class
│   │               └── OrderServiceApplication.class
│   └── lib
│       ├── classmate-1.4.0.jar
│       ├── common-v1-0.0.1-SNAPSHOT.jar
│       ├── common-v2-0.0.1-SNAPSHOT.jar
│       ├── hibernate-validator-6.0.17.Final.jar
│       ├── jackson-annotations-2.9.0.jar
│       ├── jackson-core-2.9.9.jar
│       ├── jackson-databind-2.9.9.jar
│       ├── jackson-datatype-jdk8-2.9.9.jar
│       ├── jackson-datatype-jsr310-2.9.9.jar
│       ├── jackson-module-parameter-names-2.9.9.jar
│       ├── javax.annotation-api-1.3.2.jar
│       ├── jboss-logging-3.3.2.Final.jar
│       ├── jul-to-slf4j-1.7.26.jar
│       ├── log4j-api-2.11.2.jar
│       ├── log4j-to-slf4j-2.11.2.jar
│       ├── logback-classic-1.2.3.jar
│       ├── logback-core-1.2.3.jar
│       ├── lombok-1.18.10.jar
│       ├── middle-ware-0.0.1-SNAPSHOT.jar
│       ├── middle-ware-api-0.0.1-SNAPSHOT.jar
│       ├── slf4j-api-1.7.26.jar
│       ├── snakeyaml-1.23.jar
│       ├── spring-aop-5.1.9.RELEASE.jar
│       ├── spring-beans-5.1.9.RELEASE.jar
│       ├── spring-boot-2.1.7.RELEASE.jar
│       ├── spring-boot-autoconfigure-2.1.7.RELEASE.jar
│       ├── spring-boot-loader-2.1.7.RELEASE.jar
│       ├── spring-boot-starter-2.1.7.RELEASE.jar
│       ├── spring-boot-starter-json-2.1.7.RELEASE.jar
│       ├── spring-boot-starter-logging-2.1.7.RELEASE.jar
│       ├── spring-boot-starter-tomcat-2.1.7.RELEASE.jar
│       ├── spring-boot-starter-web-2.1.7.RELEASE.jar
│       ├── spring-context-5.1.9.RELEASE.jar
│       ├── spring-core-5.1.9.RELEASE.jar
│       ├── spring-expression-5.1.9.RELEASE.jar
│       ├── spring-jcl-5.1.9.RELEASE.jar
│       ├── spring-web-5.1.9.RELEASE.jar
│       ├── spring-webmvc-5.1.9.RELEASE.jar
│       ├── tomcat-embed-core-9.0.22.jar
│       ├── tomcat-embed-el-9.0.22.jar
│       ├── tomcat-embed-websocket-9.0.22.jar
│       └── validation-api-2.0.1.Final.jar
├── META-INF
│   ├── MANIFEST.MF
│   └── maven
│       └── com.example
│           └── web-application
│               ├── pom.properties
│               └── pom.xml
└── org
    └── springframework
        └── boot
            └── loader
                ├── archive
                │   ├── Archive.class
                │   ├── Archive$Entry.class
                │   ├── Archive$EntryFilter.class
                │   ├── ExplodedArchive$1.class
                │   ├── ExplodedArchive.class
                │   ├── ExplodedArchive$FileEntry.class
                │   ├── ExplodedArchive$FileEntryIterator.class
                │   ├── ExplodedArchive$FileEntryIterator$EntryComparator.class
                │   ├── JarFileArchive.class
                │   ├── JarFileArchive$EntryIterator.class
                │   └── JarFileArchive$JarFileEntry.class
                ├── data
                │   ├── RandomAccessData.class
                │   ├── RandomAccessDataFile$1.class
                │   ├── RandomAccessDataFile.class
                │   ├── RandomAccessDataFile$DataInputStream.class
                │   └── RandomAccessDataFile$FileAccess.class
                ├── ExecutableArchiveLauncher.class
                ├── jar
                │   ├── AsciiBytes.class
                │   ├── Bytes.class
                │   ├── CentralDirectoryEndRecord.class
                │   ├── CentralDirectoryFileHeader.class
                │   ├── CentralDirectoryParser.class
                │   ├── CentralDirectoryVisitor.class
                │   ├── FileHeader.class
                │   ├── Handler.class
                │   ├── JarEntry.class
                │   ├── JarEntryFilter.class
                │   ├── JarFile$1.class
                │   ├── JarFile$2.class
                │   ├── JarFile.class
                │   ├── JarFileEntries$1.class
                │   ├── JarFileEntries.class
                │   ├── JarFileEntries$EntryIterator.class
                │   ├── JarFile$JarFileType.class
                │   ├── JarURLConnection$1.class
                │   ├── JarURLConnection.class
                │   ├── JarURLConnection$JarEntryName.class
                │   ├── StringSequence.class
                │   └── ZipInflaterInputStream.class
                ├── JarLauncher.class
                ├── LaunchedURLClassLoader.class
                ├── LaunchedURLClassLoader$UseFastConnectionExceptionsEnumeration.class
                ├── Launcher.class
                ├── MainMethodRunner.class
                ├── PropertiesLauncher$1.class
                ├── PropertiesLauncher$ArchiveEntryFilter.class
                ├── PropertiesLauncher.class
                ├── PropertiesLauncher$PrefixMatchingArchiveFilter.class
                ├── util
                │   └── SystemPropertyUtils.class
                └── WarLauncher.class
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;BOOT-INF/lib下，是由同一个类加载器去加载的，而我们的V1和V2的jar包，全部混在这个目录下。&lt;/p&gt;
&lt;p&gt;我们要想同时加载V1和V2的jar包，必须用两个类加载器来做隔离。&lt;/p&gt;
&lt;p&gt;即，应用类加载器，不能加载V1；而中间件类加载器，只管加载V2，其他一概不能加载。&lt;/p&gt;
&lt;h2 id=&quot;spring-boot-的启动类&quot;&gt;spring boot 的启动类&lt;/h2&gt;
&lt;p&gt;前面我们提到，启动类是org.springframework.boot.loader.JarLauncher，这个是在BOOT-INF/MANIFEST中指定了的。&lt;/p&gt;
&lt;p&gt;这个类在哪里呢，一般在如下这个依赖中：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;dependency&amp;gt;
   &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
   &amp;lt;artifactId&amp;gt;spring-boot-loader&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该依赖，会在打包阶段，由maven插件，打到我们的fat jar中：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;        &amp;lt;build&amp;gt;
                &amp;lt;plugins&amp;gt;
                        &amp;lt;plugin&amp;gt;
                                &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
                                &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;
                        &amp;lt;/plugin&amp;gt;
                &amp;lt;/plugins&amp;gt;
        &amp;lt;/build&amp;gt;

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个jar包，打到哪里去了呢？实际是解压后，放到fat jar的如下路径了，可以再去上面看看那个fat jar结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/519126/202007/519126-20200704181219009-649276928.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面那个启动类，就是在这个里面。&lt;/p&gt;
&lt;h2 id=&quot;启动类简单解析&quot;&gt;启动类简单解析&lt;/h2&gt;
&lt;p&gt;先来看看uml：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/519126/202007/519126-20200704181514254-261436609.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;先看看JarLauncher：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class JarLauncher extends ExecutableArchiveLauncher {

   static final String BOOT_INF_CLASSES = &quot;BOOT-INF/classes/&quot;;

   static final String BOOT_INF_LIB = &quot;BOOT-INF/lib/&quot;;

   public JarLauncher() {
   }

   protected JarLauncher(Archive archive) {
      super(archive);
   }

   @Override
   protected boolean isNestedArchive(Archive.Entry entry) {
      if (entry.isDirectory()) {
         return entry.getName().equals(BOOT_INF_CLASSES);
      }
      return entry.getName().startsWith(BOOT_INF_LIB);
   }

   public static void main(String[] args) throws Exception {
      // 1
      new JarLauncher().launch(args);
   }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里1处，new了自身，然后调用launch。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public abstract class Launcher {

   /**
    * Launch the application. This method is the initial entry point that should be
    * called by a subclass {@code public static void main(String[] args)} method.
    * @param args the incoming arguments
    * @throws Exception if the application fails to launch
    */
   protected void launch(String[] args) throws Exception {
      JarFile.registerUrlProtocolHandler();
      // 1
      ClassLoader classLoader = createClassLoader(getClassPathArchives());
      // 2
      launch(args, getMainClass(), classLoader);
   }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;1处这里，就是创建类加载器了，期间，先调用了getClassPathArchives。&lt;/p&gt;
&lt;p&gt;我们看看：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;org.springframework.boot.loader.Launcher#getClassPathArchives
protected abstract List&amp;lt;Archive&amp;gt; getClassPathArchives() throws Exception;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是个抽象方法，此处使用了模板方法设计模式，在如下类中实现了：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;org.springframework.boot.loader.ExecutableArchiveLauncher#getClassPathArchives
    
@Override
protected List&amp;lt;Archive&amp;gt; getClassPathArchives() throws Exception {
    // 1
   List&amp;lt;Archive&amp;gt; archives = new ArrayList&amp;lt;&amp;gt;(this.archive.getNestedArchives(this::isNestedArchive));
    
   postProcessClassPathArchives(archives);
   return archives;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此处的1处，不用深究，就是获取类加载器的classpath集合。我们这里打个断点，直接看下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/519126/202007/519126-20200704182115582-877251991.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里面细节就先不看了，主要就是拿到BOOT-INF/lib下的每个jar包。&lt;/p&gt;
&lt;p&gt;然后我们继续之前的：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;   protected void launch(String[] args) throws Exception {
      JarFile.registerUrlProtocolHandler();
      // 1
      ClassLoader classLoader = createClassLoader(getClassPathArchives());
      // 2
      launch(args, getMainClass(), classLoader);
   }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在getClassPathArchives已经ok了，接着就调用createClassLoader来创建类加载器了。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;       protected ClassLoader createClassLoader(List&amp;lt;Archive&amp;gt; archives) throws Exception {
                List&amp;lt;URL&amp;gt; urls = new ArrayList&amp;lt;&amp;gt;(archives.size());
                for (Archive archive : archives) {
                        urls.add(archive.getUrl());
                }
        // 1
                return createClassLoader(urls.toArray(new URL[0]));
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;1处，继续调用内层函数，传入了url数组。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;protected ClassLoader createClassLoader(URL[] urls) throws Exception {
   return new LaunchedURLClassLoader(urls, getClass().getClassLoader());
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里new了一个LaunchedURLClassLoader，参数就是url数组。我们看看这个类：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class LaunchedURLClassLoader extends URLClassLoader {

   static {
      ClassLoader.registerAsParallelCapable();
   }

   /**
    * Create a new {@link LaunchedURLClassLoader} instance.
    * @param urls the URLs from which to load classes and resources
    * @param parent the parent class loader for delegation
    */
   public LaunchedURLClassLoader(URL[] urls, ClassLoader parent) {
      super(urls, parent);
   }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个类，继承了URLClassLoader，所以，大家如果对类加载器有一定了解，就知道，URLClassLoader就是接收一堆的url，然后loadClass的时候，遵从双亲委派，双亲加载不了，就交给它，它就去url数组里，去加载class。&lt;/p&gt;
&lt;h2 id=&quot;思路分析&quot;&gt;思路分析&lt;/h2&gt;
&lt;p&gt;我的打算是，修改fat jar中的启动类，为我们自定义的启动类。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-properties&quot;&gt;Manifest-Version: 1.0
Implementation-Title: web-application
Implementation-Version: 0.0.1-SNAPSHOT
Start-Class: com.example.demo.OrderServiceApplication
Spring-Boot-Classes: BOOT-INF/classes/
Spring-Boot-Lib: BOOT-INF/lib/
Build-Jdk-Spec: 1.8
Spring-Boot-Version: 2.1.7.RELEASE
Created-By: Maven Archiver 3.4.0
// 1
Main-Class: com.example.demo.CustomJarLauncher
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;1处，指定我们自定义的class，这个class，我们会在打好fat jar后，手动拷贝进去。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/519126/202007/519126-20200704183332111-1190461581.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后，我们自定义启动类里面要干啥呢？&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class CustomJarLauncher extends JarLauncher {



    public static void main(String[] args) throws Exception {
        new CustomJarLauncher().launch(args);
    }


    @Override
    protected void launch(String[] args) throws Exception {
        JarFile.registerUrlProtocolHandler();
        // 1
        List&amp;lt;Archive&amp;gt; classPathArchives = getClassPathArchives();
        /**
         * 2
         */
        List&amp;lt;URL&amp;gt; allURLs = classPathArchives.stream().map(entries -&amp;gt; {
            try {
                return entries.getUrl();
            } catch (MalformedURLException e) {
                return null;
            }
        }).filter(Objects::nonNull).collect(Collectors.toList());

                // 3
        List&amp;lt;URL&amp;gt; middleWareClassPathArchives = new ArrayList&amp;lt;&amp;gt;();
        for (URL url : allURLs) {
            String urlPath = url.getPath();
            if (urlPath == null) {
                continue;
            }
            boolean isMiddleWareJar = urlPath.contains(&quot;common-v1&quot;)
                    || urlPath.contains(&quot;middle-ware&quot;);
            if (isMiddleWareJar) {
                if (urlPath.contains(&quot;middle-ware-api&quot;)) {
                    continue;
                }
                middleWareClassPathArchives.add(url);
            }
        }


        /**
         * 4 从全部的应用lib目录，移除中间件需要的jar包，但是，中间件的api不能移除
         */
        allURLs.removeAll(middleWareClassPathArchives);

                // 5
        CustomLaunchedURLClassLoader loader =
                new CustomLaunchedURLClassLoader(allURLs.toArray(new URL[0]),
                getClass().getClassLoader());
        loader.setMiddleWareClassPathArchives(middleWareClassPathArchives);

        launch(args, getMainClass(), loader);
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;1处，获取fat jar的lib目录下的全部包&lt;/li&gt;
&lt;li&gt;2处，将1处得到的集合，转为url集合&lt;/li&gt;
&lt;li&gt;3处，筛选出中间件的包，复制到单独的集合中，我这边有2个，直接写死了（毕竟是demo）&lt;/li&gt;
&lt;li&gt;4处，将原集合中，移除中间件的jar包&lt;/li&gt;
&lt;li&gt;5处，创建一个自定义的classloader，主要是方便我们存放中间件相关jar包集合&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;5处自定义的classloader，这里可以看下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class CustomLaunchedURLClassLoader extends LaunchedURLClassLoader {
        // 中间件jar包
        List&amp;lt;URL&amp;gt; middleWareClassPathArchives;

        /**
         * Create a new {@link LaunchedURLClassLoader} instance.
         *
         * @param urls   the URLs from which to load classes and resources
         * @param parent the parent class loader for delegation
         */
        public CustomLaunchedURLClassLoader(URL[] urls, ClassLoader parent) {
                super(urls, parent);
        }


        public List&amp;lt;URL&amp;gt; getMiddleWareClassPathArchives() {
                return middleWareClassPathArchives;
        }

        public void setMiddleWareClassPathArchives(List&amp;lt;URL&amp;gt; middleWareClassPathArchives) {
                this.middleWareClassPathArchives = middleWareClassPathArchives;
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最终，在我们的业务代码，要怎么去写呢？&lt;/p&gt;
&lt;p&gt;我们现在自定义了一个类加载器，那么，后续业务代码都会由这个类加载器去加载。&lt;/p&gt;
&lt;p&gt;我们再想想标题说的问题，我们是需要：加载中间件代码时，不能用这个类加载器去加载，因为这个类加载器中，已经排除了中间件相关jar包，是加载不到的。&lt;/p&gt;
&lt;p&gt;此时，我们需要自定义一个classloader，去如下类中的middleWareClassPathArchives这个地方加载：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class CustomLaunchedURLClassLoader extends LaunchedURLClassLoader {
        // 中间件jar包
        List&amp;lt;URL&amp;gt; middleWareClassPathArchives;
    ...
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;只有当它加载不到之后，才丢给应用类加载器去加载。&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@SpringBootApplication
@RestController
@Slf4j
public class OrderServiceApplication {
        /**
         * 中间件使用的classloader
         */
        static ClassLoader delegatingClassloader;

        public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {
        // 1
                ClassLoader loader = Thread.currentThread().getContextClassLoader();
                Method method = loader.getClass().getMethod(&quot;getMiddleWareClassPathArchives&quot;);
                List&amp;lt;URL&amp;gt; middleWareUrls = (List&amp;lt;URL&amp;gt;) method.invoke(loader);
                // 2
                delegatingClassloader = new CustomMiddleWareClassloader(middleWareUrls.toArray(new URL[0]), loader);
                // 3
                SpringApplication.run(OrderServiceApplication.class, args);
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;1，这里，我们要通过当前线程，拿到我们的类加载器，此时拿到的，肯定就是我们的自定义类加载器；然后通过反射方法，拿到中间件url集合，其实这里自己去拼这个url也可以，我们这里为了省事，所以就这么写；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;2处，创建一个类加载器，主要就是给中间件代码使用，进行类加载器隔离。&lt;/p&gt;
&lt;p&gt;注意，这里，我们把当前应用的类加载器，传给了这个中间件类加载器。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Data
@Slf4j
public class CustomMiddleWareClassloader extends URLClassLoader {
    ClassLoader classLoader;

    public CustomMiddleWareClassloader(URL[] urls, ClassLoader parent) {
        super(urls);
        classLoader = parent;
    }

    @Override
    public Class&amp;lt;?&amp;gt; loadClass(String name) throws ClassNotFoundException {
        /**
         * 先自己来加载中间件相关jar包，这里调用findClass，就会去中间件那几个jar包加载class
         */
        try {
            Class&amp;lt;?&amp;gt; clazz = findClass(name);
            if (clazz != null) {
                return clazz;
            }
            throw new ClassNotFoundException(name);
        } catch (Exception e) {
            /**
             * 在中间件自己的jar包里找不到，就交给自己的parent，此处即应用类加载器
             */
            return classLoader.loadClass(name);
        }
    }


}
&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;中间件整体模块概览&quot;&gt;中间件整体模块概览&lt;/h2&gt;
&lt;p&gt;在继续之前，有必要说下代码结构。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/519126/202007/519126-20200704185639983-1439623996.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;中间件总共三个jar包：&lt;/p&gt;
&lt;p&gt;common-v1，middle-ware，middle-ware-api。&lt;/p&gt;
&lt;p&gt;其中，middle-ware的pom如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;中间件api模块&quot;&gt;中间件api模块&lt;/h2&gt;
&lt;p&gt;该模块无任何依赖，就是个接口&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public interface IGisUtilInterface {

    String getFormattedDate(String date);

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该模块是很有必要的，该api模块必须由应用的类加载器加载，没错，是应用类加载器。&lt;/p&gt;
&lt;p&gt;类似于servlet-api吧。&lt;/p&gt;
&lt;p&gt;大家可以暂时这么记着，至于原因，那就有点长了。&lt;/p&gt;
&lt;p&gt;可以参考：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/grey-wolf/p/11084379.html&quot;&gt;不吹不黑，关于 Java 类加载器的这一点，市面上没有任何一本图书讲到&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;中间件实现模块&quot;&gt;中间件实现模块&lt;/h2&gt;
&lt;p&gt;实现模块的pom：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;groupId&amp;gt;com.example&amp;lt;/groupId&amp;gt;
&amp;lt;artifactId&amp;gt;middle-ware&amp;lt;/artifactId&amp;gt;
&amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt;
&amp;lt;name&amp;gt;middle-ware&amp;lt;/name&amp;gt;
    
&amp;lt;dependencies&amp;gt;
   &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;com.example&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;middle-ware-api&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt;
   &amp;lt;/dependency&amp;gt;
   &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;com.example&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;common-v1&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt;
   &amp;lt;/dependency&amp;gt;

&amp;lt;/dependencies&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;里面只有一个类，就是实现api模块的接口。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Slf4j
public class GisUtilImpl implements IGisUtilInterface{

    @Override
    public  String getFormattedDate(String date) {
        String v1 = CommonDateUtil.format(date);
        log.info(&quot;invoke common v1,get result:{}&quot;, v1);

        return v1;
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;spring-boot-的自定义loader模块&quot;&gt;spring boot 的自定义loader模块&lt;/h2&gt;
&lt;p&gt;这部分和业务关系不大，主要就是自定义我们前面的那个fat jar启动类。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;groupId&amp;gt;com.example&amp;lt;/groupId&amp;gt;
&amp;lt;artifactId&amp;gt;custom-jar-launch&amp;lt;/artifactId&amp;gt;
&amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt;
&amp;lt;name&amp;gt;custom-jar-launch&amp;lt;/name&amp;gt;
&amp;lt;description&amp;gt;Demo project for Spring Boot&amp;lt;/description&amp;gt;

&amp;lt;properties&amp;gt;
   &amp;lt;java.version&amp;gt;1.8&amp;lt;/java.version&amp;gt;
   &amp;lt;spring-cloud.version&amp;gt;Greenwich.SR3&amp;lt;/spring-cloud.version&amp;gt;
&amp;lt;/properties&amp;gt;

&amp;lt;dependencies&amp;gt;

   &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;org.projectlombok&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;lombok&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;1.18.10&amp;lt;/version&amp;gt;
   &amp;lt;/dependency&amp;gt;
   &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;spring-boot-loader&amp;lt;/artifactId&amp;gt;
   &amp;lt;/dependency&amp;gt;

&amp;lt;/dependencies&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里有个特别的依赖：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;dependency&amp;gt;
   &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
   &amp;lt;artifactId&amp;gt;spring-boot-loader&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该模块，主要包含：&lt;/p&gt;
&lt;p&gt;com.example.demo.CustomJarLauncher&lt;/p&gt;
&lt;p&gt;com.example.demo.CustomLaunchedURLClassLoader&lt;/p&gt;
&lt;h2 id=&quot;应用程序&quot;&gt;应用程序&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;&amp;lt;groupId&amp;gt;com.example&amp;lt;/groupId&amp;gt;
&amp;lt;artifactId&amp;gt;web-application&amp;lt;/artifactId&amp;gt;
&amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt;
&amp;lt;name&amp;gt;web-application&amp;lt;/name&amp;gt;
&amp;lt;description&amp;gt;Demo project for Spring Boot&amp;lt;/description&amp;gt;


&amp;lt;dependencies&amp;gt;
   &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;com.example&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;common-v2&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt;
   &amp;lt;/dependency&amp;gt;

   &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;com.example&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;middle-ware-api&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt;
   &amp;lt;/dependency&amp;gt;
   &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;com.example&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;middle-ware&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt;
   &amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;模拟jar包冲突场景，此时，我们已经同时依赖了v1和v2了。&lt;/p&gt;
&lt;p&gt;其测试代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class OrderServiceApplication {
        /**
         * 中间件使用的classloader
         */
        static ClassLoader delegatingClassloader;
    
@RequestMapping(&quot;/&quot;)
public  void test() throws ClassNotFoundException, IllegalAccessException {
   // 1
   Class&amp;lt;?&amp;gt; middleWareImplClass = delegatingClassloader.loadClass(&quot;com.example.demo.GisUtilImpl&quot;);
    // 2
   IGisUtilInterface iGisUtilInterface = (IGisUtilInterface) middleWareImplClass.newInstance();
    // 3
   String middleWareResult = iGisUtilInterface.getFormattedDate(&quot;version:&quot;);

   log.info(&quot;middle ware result:{}&quot;,middleWareResult);
        
    // 4
   String result = CommonDateUtil.format(&quot;version:&quot;);
   log.info(&quot;application result:{}&quot;,result);

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;3.2633663366337&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;1处，类似于servlet，也是把servlet实现类写死在web.xml的，我们这里也一样，把中间件的实现类写死了。&lt;/p&gt;
&lt;p&gt;可能有更好的方式，暂时先这样。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1.3111111111111&quot;&gt;
&lt;p&gt;2处，将实现类（中间件类加载器加载），转换为接口类（应用类加载器加载）。之所以要定义接口，这里很关键。&lt;/p&gt;
&lt;p&gt;可以再仔细看看：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/grey-wolf/p/11084379.html&quot;&gt;不吹不黑，关于 Java 类加载器的这一点，市面上没有任何一本图书讲到&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;3处，调用中间件代码&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;4处，调用应用代码&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;效果展示&quot;&gt;效果展示&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;2020-05-22 06:37:13.481  INFO 6676 --- [nio-8082-exec-1] com.example.demo.GisUtilImpl             : invoke common v1,get result:version:- v1
2020-05-22 06:37:13.481  INFO 6676 --- [nio-8082-exec-1] c.example.demo.OrderServiceApplication   : middle ware result:version:- v1
2020-05-22 06:37:13.482  INFO 6676 --- [nio-8082-exec-1] com.example.date.util.CommonDateUtil     : v2 result:version:- v2
2020-05-22 06:37:13.482  INFO 6676 --- [nio-8082-exec-1] c.example.demo.OrderServiceApplication   : application result:version:- v2
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以发现，中间件那里，是v1；而调用应用的方法，则是v2。&lt;/p&gt;
&lt;p&gt;说明我们成功了。&lt;/p&gt;
&lt;p&gt;我这里用arthas分析了下这个类：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/519126/202007/519126-20200704191637082-1437869440.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个类，还在下面出现：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/519126/202007/519126-20200704191723971-966612789.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个是中间件加载的。&lt;/p&gt;
&lt;p&gt;所以，大家平安无事地继续生活在了一起。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://gitee.com/ckl111/all-simple-demo-in-work-1/tree/master/jar-conflict&quot;&gt;https://gitee.com/ckl111/all-simple-demo-in-work-1/tree/master/jar-conflict&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;该源码怎么使用？&lt;/p&gt;
&lt;p&gt;先正常打包应用为fat jar，然后将custom-jar-launch中的class，拷进fat jar，然后修改META-INF/MANIFEST文件的启动类。&lt;/p&gt;
&lt;p&gt;然后调用接口：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt; curl  localhost:8082
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;希望对大家有所启发，谢谢。&lt;/p&gt;
</description>
<pubDate>Mon, 06 Jul 2020 00:33:00 +0000</pubDate>
<dc:creator>三国梦回</dc:creator>
<og:description>背景 大一点的公司，可能有一些组，专门做中间件的；假设，某中间件小组，给你提供了一个jar包，你需要集成到你的应用里。假设，它依赖了一个日期类，版本是v1；我们应用也依赖了同名的一个日期类，版本是v2</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/grey-wolf/p/13253014.html</dc:identifier>
</item>
<item>
<title>遵守这些原则让你开发效率提高一倍 - Jlion</title>
<link>http://www.cnblogs.com/jlion/p/13246527.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jlion/p/13246527.html</guid>
<description>&lt;p&gt;在园子里面有很多关于各种技术细节的研究文章，都是比较牛逼的框架研究；但是一直没有看到关于怎么样提高开发效率的文章，大多提高开发效率的文章都是关于自动化等方面的辅助工具类型的，而不是开发中的一些小技巧；今天从编码规范、编码技巧、开发思想、设计模式等各方面的经验来分享如何提高开发效率。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;127&quot;&gt;
&lt;h3 id=&quot;一、概述&quot;&gt;一、概述&lt;/h3&gt;
&lt;p&gt;在园子里面有很多关于各种技术细节的研究文章，都是比较牛逼的框架研究；但是一直没有看到关于怎么样提高开发效率的文章，大多提高开发效率的文章都是关于自动化等方面的辅助工具类型的，而不是开发中的一些小技巧；今天从编码规范、编码技巧、开发思想、设计模式等各方面的经验来分享如何提高开发效率。&lt;/p&gt;
&lt;h3 id=&quot;二、实际场景&quot;&gt;二、实际场景&lt;/h3&gt;
&lt;p&gt;在这个前后端分离盛行的开发年代，分工比较明确，开发者分前端开发者和后端开发者，然而感到欣慰的是.net 开发者大多是担任着全栈开发的职责，有经验的开发者都是从前端走过来的，说白了前端业务代码对后端开发者来说那都不是事。&lt;br/&gt;&lt;code&gt;前后端分离前&lt;/code&gt;：几年前前后端还未分离的时候，各种前端框架还未流行的时候，开发者的效率算是比较低下，后端干前端的活，甚至前端和后端夹杂工作，导致了工作开发容易乱，需要相互依赖，不能完全并行工作，这导致了开发效率底的一个极大的原因，同时开发出来的东西体验也是很差。&lt;br/&gt;&lt;code&gt;前后端分离&lt;/code&gt;：职责分明，后端专注后端的开发，前端专注前端的开发；相互依赖关系很弱，后端可以先定义开发接口，前端页面及mock 接口对接，最后联调测试时间前后端打通过；前后端完全可以并行开发，开发周期缩短一倍时间；不过这也就会导致了一个致命的问题，大多开发者只管自己的那一部分，不会以全局考虑，导致的一个问题就是联调测试时间代价太大,遇到问题相互甩锅。&lt;/p&gt;
&lt;p&gt;前后端都存在的问题，会再联调测试时间全部暴漏出来，这也是为什么联调测试时间会花费那么长时间，甚至晚上加班加点再处理问题的原因，总结如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;开发过程中不够谨慎，全是空异常问题&lt;/li&gt;
&lt;li&gt;代码不规范，代码逻辑嵌套层次太深，&lt;code&gt;牵一发而动全身&lt;/code&gt;，以至于修改这里，爆露出那边的问题出来，不会适当的解耦&lt;/li&gt;
&lt;li&gt;后端接口返回的字段含义不明确，不清晰，甚至完全跟字段含义违背，比如数据库中有一个int 类型的Type字段，而前端需要类型的中文名称，后端开发者偷懒直接用Type 字段返回字段中文名称，后面前端需要int 类型的Type 有不知道加什么字段为好，导致修修改改，影响效率，下面我会具体分享细节。&lt;/li&gt;
&lt;li&gt;眼观不足，不会考虑后续的需求变更扩展&lt;/li&gt;
&lt;li&gt;没有设计模式思想，导致维护成本变大&lt;br/&gt;下面从几个方面点来具体分析&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;三、空异常&quot;&gt;三、空异常&lt;/h3&gt;
&lt;h4 id=&quot;11-不可信原则&quot;&gt;1.1 不可信原则&lt;/h4&gt;
&lt;p&gt;作为开发者，你都可以把自己作为方法调用者的第三方，不需要去关注方法的实现，只需要关注调用方法我应该得到什么结果；然而作为调用者第三方，你都需要认为实现者的方法都是不可信状态，只需要秉承该原则，基本上你就跟空异常没有缘分了.&lt;/p&gt;
&lt;h4 id=&quot;12--（null条件运算符）&quot;&gt;1.2 ?. （null条件运算符）&lt;/h4&gt;
&lt;p&gt;先来看一下以下代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  [HttpGet]
   public async Task&amp;lt;DataResponse&amp;lt;bool&amp;gt;&amp;gt; GetTest()
   {
        var list = GetList();//获取List 列表
        if (list?.Count &amp;lt;= 0)
        {
            return DataResponse&amp;lt;bool&amp;gt;.AsError(&quot;没有获取到数据&quot;);
        }
        //TODO 更新操作
        return DataResponse&amp;lt;bool&amp;gt;.AsSuccess(true);
   }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面代码很多人可能会这么写，实际上是存在问题的list?.Count &amp;lt;=0 实际上在list 为空的时候就成了null&amp;lt;=0 判断了，则也是false，不符合预期结果，正确的代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; [HttpGet]
   public async Task&amp;lt;DataResponse&amp;lt;bool&amp;gt;&amp;gt; GetTest()
   {
        var list = GetList();//获取List 列表
        if ((list?.Count??0) &amp;lt;= 0)
        {
            return DataResponse&amp;lt;bool&amp;gt;.AsError(&quot;没有获取到数据&quot;);
        }
        //TODO 更新操作
        return DataResponse&amp;lt;bool&amp;gt;.AsSuccess(true);
   }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里就引用了?? 运算符（空合并运算符）&lt;/p&gt;
&lt;h4 id=&quot;13--（空合并运算符）&quot;&gt;1.3 ?? （空合并运算符）&lt;/h4&gt;
&lt;p&gt;MSDN上面的解释：?? 运算符称为 null 合并运算符，用于定义可以为 null 值的类型和引用类型的默认值。如果左操作数不为 null，则此返回左操作数；否则当左操作数为 null，返回右操作数。&lt;/p&gt;
&lt;h4 id=&quot;14-如何远离空异常？&quot;&gt;1.4 如何远离空异常？&lt;/h4&gt;
&lt;p&gt;秉承原则：&lt;code&gt;不可信原则&lt;/code&gt;，什么是不可信原则呢？你调用方法都任务改方法是不可信的，包括自己写的方法；这在敏捷快速开发中更明显，特别是调用团队中别人开发的微服务api ，你不需要关注方法的实现，只需要关注方法的结果即可，但是也不能太过于相信它；所有的返回结果你都需要判断是否是null 的结果数据，多结合?. 和?? 运算符进行合理的逻辑处理，可以让你的项目从此远离空异常。&lt;/p&gt;
&lt;h3 id=&quot;二、if-else-解套&quot;&gt;二、If else 解套&lt;/h3&gt;
&lt;p&gt;先来看一看比较有趣的网络上的图片&lt;/p&gt;
&lt;h4 id=&quot;21-取反原则&quot;&gt;2.1 取反原则&lt;/h4&gt;
&lt;p&gt;对于上面的if else 嵌套业务大家是不是经常遇到，看到这种代码会非常的头疼，难于维护，影响开发效率，同时也容易出现bug。&lt;br/&gt;有经验的开发者必定会对上面这段代码进行优化，我的经验是取反原则。&lt;br/&gt;什么是取反原则呢？把不符合的条件先 return 下去，到最后留下符合条件的逻辑，这就是取反原则，一眼看下来就只有一层嵌套，不会存在多层嵌套。&lt;br/&gt;我们来看下我遇到的实际场景代码，源代码大体如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;if (condition)
{
    if (condition1)
    {
        if(condition2)
        {
            if (condition3)
            {
                if (condition4)
                {
                    // do something
                }
                else
                {
                    // do something
                }
            }
            else
            {
                // do something
            }
        }
        else
        {
            // do something
        }
    }
    else
    {
        // do something
    }
}
else
{
    // do something
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;取反原则优化后的代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; if (!condition)
  {
     // do someting
      return;
  }
  if (!condition1)
  {
     // do someting
      return;
  }
  if (!condition2)
  {
     // do someting
      return;
  }
  if(!condition3)
  {
     // do someting
      return;
  }
  if(!condition4)
  {
     // do someting
      return;
  }
  // do someting
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;三、必要的设计模式&lt;br/&gt;开发过程中不要一个链路写到底，需要把某块业务先想好，定位明确，该业务是应该属于哪一块，哪一类业务，后续可能会出现哪些方面的业务变动，适当的引入设计模式，那么多的设计模式，总有一个适合你当时开发的场景；&lt;br/&gt;设计模式的选取需要对该模块的作用及定义清晰，多思考，多归类，自然而然心中就有了合适的设计模式的考量。&lt;/p&gt;
&lt;p&gt;四、必要的单元测试&lt;br/&gt;做到每个方法单元测试，最好是全路径覆盖到每一条分支的单元测试，先从小的方法单元测试，底层的方法单元测试通过后，再通过postman或者其他工具来进行对外API接口层面的测试，做到全路径覆盖的测试，往往开发人员有一个思维就是测试正常的业务流程，异常流程往往一概不考虑测试；然而出问题的都是那些异常的流程，单元测试需要遵守的原则如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;尽可能的全路径覆盖测试&lt;/li&gt;
&lt;li&gt;抛弃自己写的代码思维，当一个小白进行单元测试&lt;/li&gt;
&lt;li&gt;关注异常路径的单元测试&lt;/li&gt;
&lt;li&gt;摒弃依赖思想，不要依赖联调测试时间来进行测试，往往你开发只管开发，不管正确率，到后续测试联调时间那就的疯狂加班加点去赶进度了，还不能保证最佳的产品质量。&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</description>
<pubDate>Mon, 06 Jul 2020 00:10:00 +0000</pubDate>
<dc:creator>Jlion</dc:creator>
<og:description>在园子里面有很多关于各种技术细节的研究文章，都是比较牛逼的框架研究；但是一直没有看到关于怎么样提高开发效率的文章，大多提高开发效率的文章都是关于自动化等方面的辅助工具类型的，而不是开发中的一些小技巧；</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jlion/p/13246527.html</dc:identifier>
</item>
<item>
<title>项目经理面试的六个维度 - doubleicon</title>
<link>http://www.cnblogs.com/doubleicon/p/13252641.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/doubleicon/p/13252641.html</guid>
<description>&lt;p&gt;  项目经理本身在项目中并不产生价值，而是通过协调各种资源来使项目进行的更加高效，项目经理是通过团队实现项目目标的人，如果项目团队没有人管理，每个人按照各自的理解进行工作，产出的产物经常经常完全无法组合在一起，项目失败的概率极大，因此一个好的项目经理，能够团队团队成员向一个方向去努力，能大大提高项目成功的概率，尤其是在越大的项目团队中，体现的越明显，对于一个项目过程越复杂，参与人数越多的项目，项目经理的位置就越重要。&lt;/p&gt;

&lt;p&gt;  下面我们就来聊一聊如何面试项目经理，我认为可以从以下几个维度对候选项目经理进行面试评价，首先是项目管理概念、团队管理、技术技能、过往业绩、职业素养、价值观六个方面来对项目经理进行评价。&lt;/p&gt;
&lt;h2&gt;  1.项目管理概念&lt;/h2&gt;
&lt;p&gt;  首先对项目管理有一个基本的认识，对项目管理的五大过程组及十大管理过程有基本的了解；对项目的进度、成本、质量、范围四个管理过程有较深的理解，懂得如何控制成本、保证质量、保证进度、处理好范围蔓延、项目镀金等影响项目成功的关键因素，懂得如何规避变更、交涉变更等；另外一部分就是会议管理，包括晨会、日志；周例会、周报，月例会、月报，专题会等。&lt;/p&gt;
&lt;h2&gt;  2.人员管理&lt;/h2&gt;
&lt;p&gt;  人员管理，我认为可以分为两方面，包括自己团队管理及客户管理；团队管理包括包括选人、用人、育人、留人、团队冲突管理、团队绩效管理等。客户管理包括管理客户预期、如何委婉的拒绝客户、如何说服客户等。&lt;/p&gt;
&lt;h2&gt;  3.技术技能&lt;/h2&gt;
&lt;p&gt;  技术技能可以从售前支撑、需求调研、实施开发、项目测试四个维度来考虑，其中售前支撑包括如何给客户宣讲、如果给客户报价，需要调研包括调研方法论、分析能力、原型设计工具等；实施开发包括对前后端框架的了解、如何处理代码规划、如何对设计进行评审等及是否做过架构设计，采用技术、为什么，解决了那些问题；项目测试包括测试用户、压力测试、用户验收测试及Bug处理等。&lt;/p&gt;
&lt;h2&gt;  4.过往业绩&lt;/h2&gt;
&lt;p&gt;  过往管理项目的金额、工期、管理多少人员，做那个行业,做过哪些成绩，取得这些成绩的原因是什么？有过哪些失败案例，失败的原因是什么？&lt;/p&gt;
&lt;h2&gt;  5.职业素养&lt;/h2&gt;
&lt;p&gt;  如何理解项目管理；作为管理者，你觉得最需要的素质是什么？沟通能力如何、是否是一个善于总结反思的人、是否乐于学习、是否有大局观及组织能力、是否善于引导客户等。&lt;/p&gt;
&lt;h2&gt;  6.价值观&lt;/h2&gt;
&lt;p&gt;  你的理想是什么，你认为什么样的人是人才，你认为自己最引以为傲的素养是什么?，你对未来自己规划，如何来保证可以达成自己的目标，你怎么评价自己等。&lt;/p&gt;

&lt;p&gt;  如果你在所的的公司是一个小公司，人员相对较少，需要的是技术顶尖的管理者，顺便管理一下项目，那么面试的时候技术技能的权重可以占比更高一些；如果你是大中型的公司，更多的是进行项目管理、团队管理，那在面试时就需要在项目管理、团队建设的权重就要占比更高一些。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/651968/202007/651968-20200705235807480-475659726.jpg&quot; alt=&quot;&quot; width=&quot;1027&quot; height=&quot;1282&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/651968/202007/651968-20200706000512296-1831033872.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 06 Jul 2020 00:04:00 +0000</pubDate>
<dc:creator>doubleicon</dc:creator>
<og:description>一、概述 项目经理本身在项目中并不产生价值，而是通过协调各种资源来使项目进行的更加高效，项目经理是通过团队实现项目目标的人，如果项目团队没有人管理，每个人按照各自的理解进行工作，产出的产物经常经常完全</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/doubleicon/p/13252641.html</dc:identifier>
</item>
<item>
<title>什么是DevOps?该如何正确的在企业内进行实践 - 字母哥博客</title>
<link>http://www.cnblogs.com/zimug/p/13252985.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zimug/p/13252985.html</guid>
<description>&lt;p&gt;传统IT技术团队中通常都有多个独立的组织-开发团队、测试团队和运维团队。开发团队进行软件开发、测试团队进行软件测试，运维团队致力于部署，负载平衡和发布管理。 他们之间的职能有时重叠、有时依赖、有时候会冲突。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1815316/202007/1815316-20200706080030142-1818611723.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因为衔接与沟通问题，有时会导致开发-测试-发布的周期太长了，特别是对于互联网公司，时间就是生命。从而需要建立一支由开发，质量保证和运营组成的混合专业知识的团队的需求，并引入了DevOps来弥合团队之间的鸿沟，帮助他们快速而可靠地操作和开发应用程序。&lt;/p&gt;
&lt;h2 id=&quot;一、什么是devops？&quot;&gt;一、什么是DevOps？&lt;/h2&gt;
&lt;p&gt;顾名思义，Devops是“开发”与“运维”的缩写。它定义了一组流程，这些流程通过在开发和运维团队之间进行协作带来组织文化上的转变。它包含四个关键组件：协作，实践，文化和工具。&lt;/p&gt;
&lt;h2 id=&quot;二、为什么我们需要devops？&quot;&gt;二、为什么我们需要DevOps？&lt;/h2&gt;
&lt;p&gt;DevOps带来更高水平的协作和速度，使组织提高生产力，降低运营成本以有效地为客户提供服务并保持市场竞争力。它还有助于更快地发布产品，管理计划外的工作，更快地捕获和解决关键问题。&lt;/p&gt;
&lt;h2 id=&quot;三、devops实践&quot;&gt;三、DevOps实践&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1815316/202007/1815316-20200706080030537-334575345.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;独立devops团队&lt;/strong&gt;&lt;br/&gt;DevOps使用各种工具，例如docker、k8s、Jenkins，Terraform，Nagios，Grafana，Prometheus或Splunk等，组织应建立一个集中部门来创建和操作这些工具。这个集中管理部门负责开发团队中的敏捷实践设置，该团队将研究新的工具并坚持使用，并提供指导程序和培训以实施DevOps。&lt;strong&gt;该部门核心工作内容是追求测试、集成、部署的自动化，减少人员参与、降低沟通成本、弥合技术团队之间的鸿沟。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;持续集成（CI）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;CI是一种软件开发实践，可改善团队之间的协作并有助于构建高质量的软件。开发团队会定期检入存储库中的代码更改，CI会执行自动构建和测试以验证代码质量。持续集成所采用的实践可以在早期阶段快速检测出软件开发生命周期（SDLC）的挑战，从而有助于开发团队在开发阶段本身解决问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;持续交付/部署（CD）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;部署过程具有不同的阶段，例如开发→构建→验证→构建版本控制→部署→后部署等。持续部署过程的思想是，在构建通过QA阶段的所有阶段后，将已开发的代码自动部署到生产环境中。 -beta，Integration，UAT等。有一些可用的工具，例如Spinnaker，Jenkins，Harness，Ansible，Chef，Puppet等，使DevOps团队可以建立自动化管道，以最少的人工干预就可以在多个环境中进行部署。&lt;/p&gt;
&lt;p&gt;持续交付是DevOps的一种实践，其中新的代码库由QA团队在自动和手动QA周期的不同阶段进行测试。如果代码库通过了QA周期并得到QA团队的批准，则它将部署到生产环境中。通过这种方式，DevOps将团队划分为较短的周期，从而使团队能够更快，更频繁地构建，测试和发布代码库。这使组织能够提供更多版本，减少手动部署，并将生产中的故障风险降至最低。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;配置管理（CM）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;配置和变更管理是DevOps周期的重要组成部分。配置管理是对基础结构和系统的所有实体（例如服务器，应用程序，存储，网络和所有托管服务）进行配置，监视，管理和维护的自动化。也有许多的集中配置管理工具可以使用，比如：nacos、apollo等。&lt;/p&gt;
&lt;p&gt;配置管理带来了许多优势，例如简化了新环境的设置，降低了生产配置的风险，并节省了软件开发的大量时间，而无需花费时间和精力来使用基础结构即代码实践从头开始新服务。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;变更管理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;变更管理是一个请求，计划，实施和评估满足新要求所需的变更的过程。在配置管理过程中，如果现有系统和基础架构中需要进行任何更改，那么此时就要考虑更改管理。运营团队需要提供他们的意见，更改的原因，以及可能在更大范围内产生的后果，包括可能受到新更改影响的其他系统。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;测试自动化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;每个代码库的自动测试有助于运行更多测试，提高测试频率，并节省手动QA上花费的时间。此过程可及早发现错误，修复错误，并提高整体软件质量。有几种工具可以与DevOps工具集成，例如Selenium，RobotFramework，Appium，XCUITest，JUnit等，以实现自动化的测试。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;持续监控（CM）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;持续监控建议使用几种工具，仪表板和警报来监视所有系统和基础架构，包括对影响软件的不同指标的实时洞察，例如系统性能，测试次数，成功和失败率，部署状态，错误日志以及所有信息以图形，表格和详细报告格式显示。为了完成这样的监视，DevOps团队可以设置一些工具，例如Prometheus，Grafana，Nagios，Appdynamics，NewRelic，Splunk，Logstash，以及市场上可用的更多工具。&lt;/p&gt;
&lt;h2 id=&quot;欢迎关注我的博客，里面有很多精品合集&quot;&gt;欢迎关注我的博客，里面有很多精品合集&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;本文转载注明出处（必须带连接，不能只转文字）：&lt;a href=&quot;http://www.zimug.com&quot;&gt;字母哥博客&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;觉得对您有帮助的话，帮我点赞、分享！您的支持是我不竭的创作动力！&lt;/strong&gt; 。另外，笔者最近一段时间输出了如下的精品内容，期待您的关注。&lt;/p&gt;
</description>
<pubDate>Mon, 06 Jul 2020 00:01:00 +0000</pubDate>
<dc:creator>字母哥博客</dc:creator>
<og:description>传统IT技术团队中通常都有多个独立的组织-开发团队、测试团队和运维团队。开发团队进行软件开发、测试团队进行软件测试，运维团队致力于部署，负载平衡和发布管理。&amp;amp;#160;他们之间的职能有时重叠、</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zimug/p/13252985.html</dc:identifier>
</item>
<item>
<title>HotSpot的类模型（3）  - HotSpot-Researcher</title>
<link>http://www.cnblogs.com/mazhimazhi/p/13252983.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mazhimazhi/p/13252983.html</guid>
<description>&lt;p&gt;上一篇 &lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13237631.html&quot; target=&quot;_blank&quot;&gt;HotSpot的类模型（2）&lt;/a&gt; 介绍了类模型的基础类Klass的重要属性及方法，这一篇介绍一下InstanceKlass及InstanceKlass的子类。&lt;/p&gt;
&lt;h3&gt;2、&lt;strong&gt;InstanceKlass类&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;每个InstanceKlass对象表示一个具体的Java类（这里的Java类不包括Java数组）。InstanceKlass类及重要属性的定义如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;69&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
class InstanceKlass: public Klass {
 ...

 protected:
  // Annotations for this class
  Annotations*       _annotations;
  // Array classes holding elements of this class.
  Klass*             _array_klasses;
  // Constant pool for this class.
  ConstantPool*     _constants;
  // The InnerClasses attribute and EnclosingMethod attribute. The
  // _inner_classes is an array of shorts. If the class has InnerClasses
  // attribute, then the _inner_classes array begins with 4-tuples of shorts
  // [inner_class_info_index, outer_class_info_index,
  // inner_name_index, inner_class_access_flags] for the InnerClasses
  // attribute. If the EnclosingMethod attribute exists, it occupies the
  // last two shorts [class_index, method_index] of the array. If only
  // the InnerClasses attribute exists, the _inner_classes array length is
  // number_of_inner_classes * 4. If the class has both InnerClasses
  // and EnclosingMethod attributes the _inner_classes array length is
  // number_of_inner_classes * 4 + enclosing_method_attribute_size.
  Array&amp;lt;jushort&amp;gt;*   _inner_classes;
 
  // Array name derived from this class which needs unreferencing
  // if this class is unloaded.
  Symbol*           _array_name;
 
  // Number of heapOopSize words used by non-static fields in this klass
  // (including inherited fields but after header_size()).
  int               _nonstatic_field_size;
  int               _static_field_size;    // number words used by static fields (oop and non-oop) in this klass
  // Constant pool index to the utf8 entry of the Generic signature,
  // or 0 if none.
  u2                _generic_signature_index;
  // Constant pool index to the utf8 entry for the name of source file
  // containing this klass, 0 if not specified.
  u2                _source_file_name_index;
  u2                _static_oop_field_count;// number of static oop fields in this klass
  u2                _java_fields_count;    // The number of declared Java fields
  int               _nonstatic_oop_map_size;// size in words of nonstatic oop map blocks
 

  u2                _minor_version;  // minor version number of class file
  u2                _major_version;  // major version number of class file
  Thread*           _init_thread;    // Pointer to current thread doing initialization (to handle recusive initialization)
  int               _vtable_len;     // length of Java vtable (in words)
  int               _itable_len;     // length of Java itable (in words)
  OopMapCache*      volatile _oop_map_cache;   // OopMapCache for all methods in the klass (allocated lazily)
  JNIid*            _jni_ids;              // First JNI identifier for static fields in this class
  jmethodID*        _methods_jmethod_ids;  // jmethodIDs corresponding to method_idnum, or NULL if none
  nmethodBucket*    _dependencies;         // list of dependent nmethods
  nmethod*          _osr_nmethods_head;    // Head of list of on-stack replacement nmethods for this class

 
  // Class states are defined as ClassState (see above).
  // Place the _init_state here to utilize the unused 2-byte after
  // _idnum_allocated_count.
  u1                _init_state;                    // state of class
  u1                _reference_type;                // reference type
 

  // Method array.
  Array&amp;lt;Method*&amp;gt;*   _methods;
  // Default Method Array, concrete methods inherited from interfaces
  Array&amp;lt;Method*&amp;gt;*   _default_methods;
  // Interface (Klass*s) this class declares locally to implement.
  Array&amp;lt;Klass*&amp;gt;*    _local_interfaces;
  // Interface (Klass*s) this class implements transitively.
  Array&amp;lt;Klass*&amp;gt;*    _transitive_interfaces;

  // Int array containing the vtable_indices for default_methods
  // offset matches _default_methods offset
  Array&amp;lt;int&amp;gt;*       _default_vtable_indices;
 
  // Instance and static variable information, starts with 6-tuples of shorts
  // [access, name index, sig index, initval index, low_offset, high_offset]
  // for all fields, followed by the generic signature data at the end of
  // the array. Only fields with generic signature attributes have the generic
  // signature data set in the array. The fields array looks like following:
  //
  // f1: [access, name index, sig index, initial value index, low_offset, high_offset]
  // f2: [access, name index, sig index, initial value index, low_offset, high_offset]
  //      ...
  // fn: [access, name index, sig index, initial value index, low_offset, high_offset]
  //     [generic signature index]
  //     [generic signature index]
  //     ...
  Array&amp;lt;u2&amp;gt;*        _fields;
 
  // embedded Java vtable follows here
  // embedded Java itables follows here
  // embedded static fields follows here
  // embedded nonstatic oop-map blocks follows here
  // embedded implementor of this interface follows here
  //   The embedded implementor only exists if the current klass is an
  //   iterface. The possible values of the implementor fall into following
  //   three cases:
  //     NULL: no implementor.
  //     A Klass* that's not itself: one implementor.
  //     Itsef: more than one implementors.
  // embedded host klass follows here
  //   The embedded host klass only exists in an anonymous class for
  //   dynamic language support (JSR 292 enabled). The host class grants
  //   its access privileges to this class also. The host class is either
  //   named, or a previously loaded anonymous class. A non-anonymous class
  //   or an anonymous class loaded through normal classloading does not
  //   have this embedded field.
  
  ...
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;重要属性的介绍如下表所示。&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;31&quot;&gt;&lt;tr&gt;&lt;td&gt;字段名&lt;/td&gt;
&lt;td&gt;作用&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;_annotations&lt;/td&gt;
&lt;td&gt;Annotations类型的指针，保存该类使用的所有注解&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6.5&quot;&gt;&lt;td&gt;_array_klasses&lt;/td&gt;
&lt;td readability=&quot;8&quot;&gt;
&lt;p&gt;数组元素为该类的数组Klass指针，例如ObjArrayKlass是对象数组且元素类型为Object，&lt;/p&gt;
&lt;p&gt;那么表示Object类的InstanceKlass对象的_array_klasses就是指向ObjArrayKlass的指针&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;_array_name&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;以该类为数组元素的数组的名字，如&quot;[Ljava/lang/Object;&quot;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;_constants&lt;/td&gt;
&lt;td&gt;ConstantPool类型的指针，用来保存类的常量池信息&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;_inner_classes&lt;/td&gt;
&lt;td&gt;用一个jushort数组保存当前类的InnerClasses属性和EnclosingMethod属性&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;_nonstatic_field_size&lt;/td&gt;
&lt;td&gt;非静态字段需要占用的内存大小 ，以字为单位&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;_static_field_size&lt;/td&gt;
&lt;td&gt;静态字段需要占用的内存大小 ，以字为单位&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;_generic_signature_index&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;保存此类的Generic signature在常量池中的索引&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;_source_file_name_index&lt;/td&gt;
&lt;td&gt;保存此类的源文件名在常量池中索引&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;_static_oop_field_count&lt;/td&gt;
&lt;td&gt;此类包含的静态引用类型字段的数量&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;_java_fields_count&lt;/td&gt;
&lt;td&gt;字段总数量&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;_nonstatic_oop_map_size&lt;/td&gt;
&lt;td&gt;非静态的oop map block的内存大小，以字为单位&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;_minor_version&lt;/td&gt;
&lt;td&gt;类的次版本号&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;_major_version&lt;/td&gt;
&lt;td&gt;类的主版本号&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;_init_thread&lt;/td&gt;
&lt;td&gt;执行此类初始化的Thread指针&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;_vtable_len&lt;/td&gt;
&lt;td&gt;Java虚函数表（vtable）所占用的内存大小，以字为单位&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;_itable_len&lt;/td&gt;
&lt;td&gt;Java接口函数表（itable）所占用的内存大小，以字为单位&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;_oop_map_cache&lt;/td&gt;
&lt;td&gt;OopMapCache指针，该类的所有方法的OopMapCache&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;_jni_ids/_methods_jmethod_ids&lt;/td&gt;
&lt;td&gt;JNIid指针与jmethodID指针，这2个指针对于JNI方法操作属性和方法非常重要，在介绍JNI时会详细介绍。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;_dependencies&lt;/td&gt;
&lt;td&gt;nmethodBucket指针，依赖的本地方法，以根据其_next属性获取下一个nmethod&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;_osr_nmethods_head&lt;/td&gt;
&lt;td&gt;栈上替换的本地方法链表的头元素&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;_init_state&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;表示类的状态，为枚举类型ClassState，定义了如下常量值：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;allocated（已分配内存）&lt;/li&gt;
&lt;li&gt;loaded（从class文件读取加载到内存中）&lt;/li&gt;
&lt;li&gt;linked（已经成功链接和校验）&lt;/li&gt;
&lt;li&gt;being_initialized（正在初始化）&lt;/li&gt;
&lt;li&gt;fully_initialized（已经完成初始化）&lt;/li&gt;
&lt;li&gt;initialization_error（初始化异常）&lt;/li&gt;
&lt;/ul&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;_reference_type&lt;/td&gt;
&lt;td&gt;引用类型&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;_methods&lt;/td&gt;
&lt;td&gt;保存方法的指针数组&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;_default_methods&lt;/td&gt;
&lt;td&gt;保存方法的指针数组，从接口继承的默认方法&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;_local_interfaces&lt;/td&gt;
&lt;td&gt;保存接口的指针数组，直接实现的接口Klass&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;_transitive_interfaces&lt;/td&gt;
&lt;td&gt;保存接口的指针数组，包含_local_interfaces和通过继承间接实现的接口&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;_default_vtable_indices&lt;/td&gt;
&lt;td&gt;默认方法在虚函数表中的索引&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;11&quot;&gt;&lt;td&gt;_fields&lt;/td&gt;
&lt;td readability=&quot;13&quot;&gt;
&lt;p&gt;类的字段属性，每个字段的6个属性access,、name index、sig index、initial value index、low_offset、high_offset组成一个元组，&lt;/p&gt;
&lt;p&gt;access表示访问控制属性，根据name index可以获取属性名，根据initial value index可以获取初始值，根据low_offset与&lt;/p&gt;
&lt;p&gt;high_offset可以获取该属性在内存中的偏移量。另外保存完所有属性之后还可能会保存泛型签名信息。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;有了InstanceKlass与Klass中定义的这些属性足够用来保存Java类元信息。在后续的类解析中会看到对相关变量的属性填充操作。除了保存类元信息外，此类还有另外一个重要的功能，即支持方法分派，主要是通过Java虚方法表和Java接口函数表来完成的，不过C++并不像Java一样，保存信息时非要在类中定义出相关属性，C++只是在分配内存时为要存储的信息分配好特定的内存，然后直接通过内存偏移来操作即可。&lt;/p&gt;
&lt;p&gt;接下来几个属性是没有对应的属性名，只能通过指针和偏移量的方式访问：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Java vtable：Java虚函数表，大小等于_vtable_len；&lt;/li&gt;
&lt;li&gt;Java itables：Java接口函数表，大小等于 _itable_len；&lt;/li&gt;
&lt;li&gt;非静态oop-map blocks ，大小等于_nonstatic_oop_map_size；&lt;/li&gt;
&lt;li&gt;接口的实现类，只有当前类表示一个接口时存在。如果接口没有任何实现类则为NULL；如果只有一个实现类则为该实现类的Klass指针；如果有多个实现类，为当前类本身；&lt;/li&gt;
&lt;li&gt;host klass，只在匿名类中存在，为了支持JSR 292中的动态语言特性，会给匿名类生成一个host klass。 &lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;HotSpot在解析一个类时会调用InstanceKlass::allocate_instance_klass()方法分配内存，而分配多大的内存则是通过调用InstanceKlass::size()计算出来的，调用语句如下： &lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
  int size = InstanceKlass::size(vtable_len,
                                                                 itable_len,
                                                                 nonstatic_oop_map_size,
                                         isinterf,
                                                                 is_anonymous);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;调用的size()方法的实现如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
static int size(int vtable_length,
                          int itable_length,
                  int nonstatic_oop_map_size,
                  bool is_interface,
                                  bool is_anonymous
  ){
    return align_object_size(header_size()    +  // header_size()为55
           align_object_offset(vtable_length) +
           align_object_offset(itable_length) +
           (
                  (is_interface || is_anonymous) ?
                  align_object_offset(nonstatic_oop_map_size) :
                  nonstatic_oop_map_size
                   ) +
           (
                           is_interface ? (int)sizeof(Klass*)/HeapWordSize : 0
           ) +
           (
                           is_anonymous ? (int)sizeof(Klass*)/HeapWordSize : 0)
                   );
  }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到除了会为类中本身的属性分配内存，也会为vtable与itable等分配内存。调用的header_size()方法就是计算此类的对象所占用的内存大小，实现如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
// Sizing (in words) 
static int header_size(){ 
  return align_object_offset(sizeof(InstanceKlass)/HeapWordSize); // 以HeapWordSize为单位，64位一个字为8字节，所以值为8 
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;调用的align_object_offset()方法是进行内存对齐，这是一块非常重要的C++知识点，后面会专门进行讲解。 &lt;/p&gt;
&lt;h3&gt;3、&lt;strong&gt;InstanceKlass类的子类&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;InstanceKlass共有3个直接子类，这3个子类用来表示一些特殊的类，下面简单介绍一下这3个子类：&lt;/p&gt;
&lt;p&gt;（1）&lt;strong&gt;InstanceRefKlass&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;java/lang/ref/Reference的子类需要使用InstanceRefKlass类来表示，因为这些类需要垃圾回收器特殊处理 ，在后续讲解强引用、弱引用、虚引用以及幽灵引用时在详细介绍。&lt;/p&gt;
&lt;p&gt;（2）&lt;strong&gt;InstanceMirrorKlass&lt;/strong&gt;&lt;strong&gt;类&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;用于表示特殊的java.lang.Class类，我们需要分清相关类的表示方法，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1236123/202007/1236123-20200703075947445-1426454356.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;java.lang.Class对象是通过对应的Oop对象来保存类的静态属性，因此他们的实例大小不同，需要特殊的方式来计算他们的大小以及属性遍历。&lt;/p&gt;
&lt;p&gt;Klass的属性_java_mirror就指向保存该类静态字段的Oop对象，可通过该属性访问类的静态字段。 Oop是HotSpot的对象表示模型，在后面会详细介绍。&lt;/p&gt;
&lt;p&gt; （3）&lt;strong&gt;InstanceClassLoaderKlass&lt;/strong&gt;&lt;strong&gt;类&lt;/strong&gt;　&lt;/p&gt;
&lt;p&gt;没有添加新的字段，增加了新的oop遍历方法，主要用于类加载器依赖遍历使用。  &lt;/p&gt;
&lt;p&gt;创建InstanceKlass实例会调用InstanceKlass::allocate_instance_klass()方法。在创建时，会涉及到C++new运算符的重载，通过重载new运算符来分配对象的内存空间，也就是调用InstanceKlass::size()方法得到的大小，然后再调用对应类的构造函数初始化相应的属性。方法的实现如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;83&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
InstanceKlass* InstanceKlass::allocate_instance_klass(
                                              ClassLoaderData* loader_data,
                                              int vtable_len,
                                              int itable_len,
                                              int static_field_size,
                                              int nonstatic_oop_map_size,
                                              ReferenceType rt,
                                              AccessFlags access_flags,
                                              Symbol* name,
                                              Klass* super_klass,
                                              bool is_anonymous,
                                              TRAPS) {
  bool isinterf = access_flags.is_interface();
  int size = InstanceKlass::size(vtable_len,
                                                                 itable_len,
                                                                 nonstatic_oop_map_size,
                                         isinterf,
                                                                 is_anonymous);

  // Allocation
  InstanceKlass* ik;
  ///////////////////////////////////////////////////////////////////////
  if (rt == REF_NONE) {
    if (name == vmSymbols::java_lang_Class()) {
      ik = new (loader_data, size, THREAD) InstanceMirrorKlass(
                       vtable_len,
                                           itable_len,
                                           static_field_size,
                                           nonstatic_oop_map_size,
                                           rt,
                       access_flags, is_anonymous);
    } else if (
          name == vmSymbols::java_lang_ClassLoader() ||
          (
             SystemDictionary::ClassLoader_klass_loaded() &amp;amp;&amp;amp;
             super_klass != NULL &amp;amp;&amp;amp;
             super_klass-&amp;gt;is_subtype_of(SystemDictionary::ClassLoader_klass()) // ClassLoader_klass为java_lang_ClassLoader
                  )
    ){
      ik = new (loader_data, size, THREAD) InstanceClassLoaderKlass(
                       vtable_len,
                                           itable_len,
                                           static_field_size,
                                           nonstatic_oop_map_size,
                                           rt,
                       access_flags, is_anonymous);
    } else {
      // normal class
      ik = new (loader_data, size, THREAD) InstanceKlass(
                                vtable_len, itable_len,
                                static_field_size,
                                nonstatic_oop_map_size,
                                rt,
                                access_flags, is_anonymous);
    }
  }
  ///////////////////////////////////////////////////////////////////////
  else {
    // reference klass
    ik = new (loader_data, size, THREAD) InstanceRefKlass(
                                vtable_len, itable_len,
                                static_field_size,
                                nonstatic_oop_map_size,
                                rt,
                                access_flags, is_anonymous);
  }
  ///////////////////////////////////////////////////////////////////////

  // 添加所有类型到我们内部类加载器列表中，包括在根加载器中的类
  // Add all classes to our internal class loader list here,
  // including classes in the bootstrap (NULL) class loader.
  // loader_data的类型为ClassLoaderData*,通过ClassLoaderData中的_klasses保持通过InstanceKlass._next_link属性保持的列表
  loader_data-&amp;gt;add_class(ik);

  return ik;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;方法的实现比较简单，当rt等于REF_NONE时，也就是为非Reference类型时，会根据类名创建对应C++类的对象。Class类创建InstanceMirrorKlass、ClassLoader类或ClassLoader的子类创建InstanceClassLoaderKlass类、普通类通过InstanceKlass来表示。当rt不为REF_NONE时，会创建InstanceRefKlass对象。REF_NONE枚举常量的定义如下： &lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
// ReferenceType is used to distinguish between java/lang/ref/Reference subclasses

enum ReferenceType {
  REF_NONE,      // Regular class
  REF_OTHER,     // Subclass of java/lang/ref/Reference, but not subclass of one of the classes below
  REF_SOFT,      // Subclass of java/lang/ref/SoftReference
  REF_WEAK,      // Subclass of java/lang/ref/WeakReference
  REF_FINAL,     // Subclass of java/lang/ref/FinalReference
  REF_PHANTOM    // Subclass of java/lang/ref/PhantomReference
};
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到，所有的Reference及子类都会用InstanceRefKlass来表示。当无法判断到底是哪个子类时，会将Reference设置为REF_OTHER。　　&lt;/p&gt;

&lt;p&gt;相关文章的链接如下：&lt;/p&gt;
&lt;p&gt;1、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13215548.html&quot; target=&quot;_blank&quot;&gt;在Ubuntu 16.04上编译OpenJDK8的源代码&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;2、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13217159.html&quot; target=&quot;_blank&quot;&gt;调试HotSpot源代码&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13222664.html&quot; target=&quot;_blank&quot;&gt;HotSpot项目结构&lt;/a&gt;　&lt;/p&gt;
&lt;p&gt;4、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13228157.html&quot; target=&quot;_blank&quot;&gt;HotSpot的启动过程&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;5、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13233607.html&quot; target=&quot;_blank&quot;&gt;HotSpot二分模型 （1）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;6、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13237631.html&quot; target=&quot;_blank&quot;&gt;HotSpot的类模型（2）&lt;/a&gt;  &lt;/p&gt;

</description>
<pubDate>Mon, 06 Jul 2020 00:00:00 +0000</pubDate>
<dc:creator>HotSpot-Researcher</dc:creator>
<og:description>上一篇 HotSpot的类模型（2）&amp;#160;介绍了类模型的基础类Klass的重要属性及方法，这一篇介绍一下InstanceKlass及InstanceKlass的子类。 2、InstanceKla</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mazhimazhi/p/13252983.html</dc:identifier>
</item>
<item>
<title>机器学习回顾篇（16）：蒙特卡洛算法 - 奥辰</title>
<link>http://www.cnblogs.com/chenhuabin/p/13252971.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenhuabin/p/13252971.html</guid>
<description>&lt;pre&gt;
&lt;span class=&quot;c1&quot;&gt;# 重大新闻类型随机需求量&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;important_env_pro&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;40&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.03&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;50&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.05&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;60&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.15&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;70&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;80&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.35&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;90&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.15&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.07&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)]&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;important_env_list&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;random_envent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;important_env_pro&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# 一般新闻类型随机需求量&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;common_env_pro&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;40&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;50&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.18&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;60&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;70&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;80&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.08&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;90&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.04&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)]&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;common_env_list&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;random_envent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;common_env_pro&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# 平淡新闻类型随机需求量&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;dull_env_pro&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;40&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.44&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;50&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.22&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;60&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;70&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.12&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;80&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.06&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;90&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)]&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;dull_env_list&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;random_envent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dull_env_pro&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/pre&gt;</description>
<pubDate>Sun, 05 Jul 2020 23:51:00 +0000</pubDate>
<dc:creator>奥辰</dc:creator>
<og:description>蒙特卡罗（MC，Monte Carlo）方法是一种随机采样模拟求解的方法，又被称统计试验方法或者统计模拟方法。起初，蒙特卡罗方法的提出是20世纪40年代冯·诺伊曼，斯塔尼斯拉夫·乌拉姆和尼古拉斯·梅特</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/chenhuabin/p/13252971.html</dc:identifier>
</item>
<item>
<title>3dTiles 数据规范详解[3] 内嵌在瓦片文件中的两大数据表 - 秋意正寒</title>
<link>http://www.cnblogs.com/onsummer/p/13200906.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/onsummer/p/13200906.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;转载请声明出处：全网@秋意正寒&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;说实话，我很纠结是先介绍瓦片的二进制数据文件结构，还是先介绍这两个重要的表。思前想后，我决定还是先介绍这两个数据表。&lt;/p&gt;
&lt;p&gt;因为这两个表不先给读者灌输，那么介绍到瓦片的二进制数据文件结构时，就满嘴“晦涩难懂”啦。&lt;/p&gt;
&lt;h2 id=&quot;数据与模型&quot;&gt;数据与模型&lt;/h2&gt;
&lt;p&gt;上文介绍到，瓦片的三维模型实际上是由gltf承担起来的（作为glb格式嵌入到瓦片二进制文件中），那么，除了模型数据，肯定模型自己本身也有属性数据的。&lt;/p&gt;
&lt;p&gt;就比如，门有长宽高、密度、生产日期等信息，楼栋模型有建筑面积、楼层数等信息。&lt;/p&gt;
&lt;p&gt;所以，“属性数据” 和 “模型” 是如何产生联系的呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1097074/202007/1097074-20200706030812366-821642538.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;早在我的博客《&lt;a href=&quot;https://www.cnblogs.com/onsummer/p/12082568.html&quot;&gt;聊聊GIS数据的四个分层与GIS服务&lt;/a&gt;》中有提及，只需把模型的几何数据作为一个属性，写入属性数据中，即把属性数据和几何数据并列，就可以了。&lt;/p&gt;
&lt;p&gt;但是，在3dTiles中，模型数据是以glb的形式嵌入在瓦片文件中的（点云直接就写xyz和颜色信息了），模糊了二维中“要素”的概念，而且gltf规范看起来并没有所谓的“要素”的概念，仅仅是对GPU友好的vertex、normal、texture等信息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如何让gltf模型的每一个模型，甚至每一个三角面，甚至每一个顶点打上“我属于哪个模型”的印记呢？&lt;/strong&gt;我们本篇稍稍晚一些介绍。&lt;/p&gt;
&lt;p&gt;再回忆一个重要的 3dTiles 理念：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;3dTiles 规范本身不包含模型数据的定义，它仅仅记录模型变成瓦片后的空间组织关系、模型与其属性数据之间的关系。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以，3dTiles 规范在瓦片二进制数据文件中，使用了两个重要的表来记录这种 ”模型与属性“ 的联系：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;FeatureTable（要素表）&lt;/li&gt;
&lt;li&gt;BatchTable（批量表）&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;瓦片二进制数据文件的大致字节布局结构&quot;&gt;瓦片二进制数据文件的大致字节布局结构&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1097074/202007/1097074-20200706030856186-92035005.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上一篇简单提过，瓦片引用的二进制文件有4种，即：b3dm、i3dm、pnts、cmpt。&lt;/p&gt;
&lt;p&gt;除去cmpt这个复合类型不谈，前三种的大致布局见上图。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;每一种瓦片二进制数据文件都有一个记录该瓦片的文件头信息，文件头包括若干个因瓦片不同而不太一致的数据信息，紧随其后的是两大数据表：FeatureTable（我翻译其为：要素表）、BatchTable（我翻译其为：批量表）。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这两个表既然是二进制的数据，尽管它名字里带“表”，但是却不是二维表格，它更多的是一些 &lt;strong&gt;键值&lt;/strong&gt; 信息。&lt;/p&gt;
&lt;p&gt;关于不同瓦片二进制文件的这两个表的结构，在后续博文会详细介绍。&lt;/p&gt;

&lt;p&gt;在 b3dm 瓦片中，要素表记录这个批量模型瓦片中模型的个数，这个模型单体在人类逻辑上不可再分。&lt;/p&gt;
&lt;p&gt;（在房屋级别来看，房子并不是单体，构造它的门、门把、窗户、屋顶、墙等才是模型单体；但是在模型壳子的普通表面建模数据中，房子就是一个简单的模型）&lt;/p&gt;
&lt;p&gt;要素表还可以记录当前瓦片的中心坐标，以便gltf使用相对坐标，压缩顶点坐标数字的数据量。&lt;/p&gt;
&lt;p&gt;官方给的定义是：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;要素表记录的是与渲染有关的数据。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;直球！听不懂！&lt;/p&gt;
&lt;p&gt;我来“翻译”一下好了：&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;要素表，记录的是整个瓦片渲染相关的数据，而不是渲染所需的数据。&lt;/p&gt;
&lt;p&gt;渲染相关，即有多少个模型，坐标是相对的话相对于哪个中心，如果是点云的话颜色信息是什么以及坐标如何等；&lt;/p&gt;
&lt;p&gt;渲染所需，例如顶点信息、法线贴图材质信息均有glb部分完成。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们以pnts（点云瓦片）举例，它的要素表允许有两大类数据（看不懂没关系，之后的博客还会继续介绍四种瓦片文件的结构）：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;em&gt;点属性：记录每个点云点的信息&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;属性名&lt;/th&gt;
&lt;th&gt;数据类型&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;6&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;POSITION&lt;/td&gt;
&lt;td&gt;float32 * 3&lt;/td&gt;
&lt;td&gt;直角坐标的点&lt;/td&gt;
&lt;td&gt;是，除非下面的属性存在&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;POSITION_QUANTIZED&lt;/td&gt;
&lt;td&gt;uint16 * 3&lt;/td&gt;
&lt;td&gt;量化的直角坐标点&lt;/td&gt;
&lt;td&gt;是，除非上面的属性存在&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;RGBA&lt;/td&gt;
&lt;td&gt;uint8 * 4&lt;/td&gt;
&lt;td&gt;四通道颜色&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;RGB&lt;/td&gt;
&lt;td&gt;uint8 * 3&lt;/td&gt;
&lt;td&gt;RGB颜色&lt;/td&gt;
&lt;td&gt;/&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;RGB565&lt;/td&gt;
&lt;td&gt;uint16&lt;/td&gt;
&lt;td&gt;有损压缩颜色，红5绿6蓝5，即65536种颜色&lt;/td&gt;
&lt;td&gt;/&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;NORMAL&lt;/td&gt;
&lt;td&gt;float32 *3&lt;/td&gt;
&lt;td&gt;法线&lt;/td&gt;
&lt;td&gt;/&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;NORMAL_OCT16P&lt;/td&gt;
&lt;td&gt;uint8 * 2&lt;/td&gt;
&lt;td&gt;点的法线，10进制单位向量，有16bit精度&lt;/td&gt;
&lt;td&gt;/&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;BATCH_ID&lt;/td&gt;
&lt;td&gt;uint8/uint16(默认)/uint32&lt;/td&gt;
&lt;td&gt;从BatchTable种检索元数据的id&lt;/td&gt;
&lt;td&gt;/&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;ul&gt;&lt;li&gt;&lt;em&gt;全局属性：记录整个点云瓦片的信息&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;属性名&lt;/th&gt;
&lt;th&gt;数据类型&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th&gt;是否必须&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;8.5&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;POINTS_LENGTH&lt;/td&gt;
&lt;td&gt;uint32&lt;/td&gt;
&lt;td&gt;瓦片中点的数量。所有的点属性的长度必须与这个一样。&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;RTC_CENTER&lt;/td&gt;
&lt;td&gt;float32 * 3&lt;/td&gt;
&lt;td&gt;如果所有点是相对于某个点定位的，那么这个属性就是这个相对的点的坐标。&lt;/td&gt;
&lt;td&gt;/&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;QUANTIZED_VOLUME_OFFSET&lt;/td&gt;
&lt;td&gt;float32 * 3&lt;/td&gt;
&lt;td&gt;量化偏移值（不知道是什么）&lt;/td&gt;
&lt;td&gt;与下面的属性必须同时存在&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;QUANTIZED_VOLUME_SCALE&lt;/td&gt;
&lt;td&gt;float32 * 3&lt;/td&gt;
&lt;td&gt;量化缩放比例（不知道是什么）&lt;/td&gt;
&lt;td&gt;与上面的属性必须同时存在&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;CONSTANT_RGBA&lt;/td&gt;
&lt;td&gt;uint8 * 4&lt;/td&gt;
&lt;td&gt;为所有点定义同一个颜色&lt;/td&gt;
&lt;td&gt;/&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;BATCH_LENGTH&lt;/td&gt;
&lt;td&gt;uint32&lt;/td&gt;
&lt;td&gt;BATCH_ID的个数&lt;/td&gt;
&lt;td&gt;与点属性中的BATCH_ID必须同时存在&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;简略一瞥，可以看出点云因为没有使用gltf模型（也没必要），把点云要渲染到屏幕上所需的坐标、法线、颜色等信息写在了要素表中。&lt;/p&gt;
&lt;p&gt;如果还是不能理解何为“渲染相关”，那么请阅读后续四种瓦片文件格式的详细介绍，相信你会有所收获——有可能是我表达比较菜。&lt;/p&gt;
&lt;p&gt;要说明一个“业界黑话”：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;在一个瓦片中，一个三维&lt;strong&gt;要素&lt;/strong&gt;（GIS中的通常叫法）= 一个&lt;strong&gt;模型&lt;/strong&gt;（图形学、工业建模叫法） = 一个&lt;strong&gt;BATCH&lt;/strong&gt;（3dtiles叫法）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;然后，我向读者隆重介绍要素表的简单结构，因为要素表、批量表都是以 &lt;strong&gt;二进制&lt;/strong&gt; 形式存储，所以了解每一种瓦片的二进制数据布局十分重要。&lt;/p&gt;
&lt;h2 id=&quot;要素表的结构：json描述信息要素表数据体&quot;&gt;要素表的结构：JSON描述信息+要素表数据体&lt;/h2&gt;
&lt;p&gt;要素表紧随在若干个字节的文件头后，它本身还可以再分为 &lt;code&gt;二进制的JSON文本头&lt;/code&gt; + &lt;code&gt;二进制的数据体&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1097074/202007/1097074-20200706030915964-1222127388.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;有迫不及待的读者希望更进一步了解要素表了，不要急，后续篇章一定展开，例如如何读取要素表和其中的数据等。&lt;/p&gt;
&lt;p&gt;接下来，是另一个数据表：批量表。&lt;/p&gt;

&lt;p&gt;如果把批量表删除，那么3dTiles数据还能正常渲染。&lt;/p&gt;
&lt;p&gt;是的，批量表就是所谓的模型属性表，批量表中每个属性数组的个数，就等于模型的个数，因为有多少个模型就对应多少个属性嘛！&lt;/p&gt;
&lt;p&gt;（嘿嘿，其实也有例外的情况，我们到后续聊3dtiles数据规范的扩展能力时，再把这个坑填上，不然怎么说3dtiles很灵 [keng] 活 [die] 呢）&lt;/p&gt;
&lt;p&gt;批量表相对比较自由，只要能与模型对得上号，想写啥就写啥。&lt;/p&gt;
&lt;h2 id=&quot;批量表中的属性数据--模型的关联&quot;&gt;批量表中的属性数据 ↔ 模型的关联&lt;/h2&gt;
&lt;p&gt;假定读者在阅读此 3dtiles 博客之前，已经对 gltf 数据规范有一定的了解。&lt;/p&gt;
&lt;p&gt;gltf 数据有三层逻辑：Node ← Mesh ← Primitive。&lt;/p&gt;
&lt;p&gt;其中，Primitive 即 gltf 数据规范中最小的图形单位，其顶点定义由其下的 &lt;code&gt;attributes&lt;/code&gt; 对象下 &lt;code&gt;POSITION&lt;/code&gt; 属性来寻找访问器（&lt;code&gt;Accessor&lt;/code&gt;），从而获取到数据。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-JSON&quot;&gt;{
    ...
    &quot;meshes&quot;: [
       {
           &quot;primitives&quot;: [
               {
                   &quot;attributes&quot;: {
                       &quot;POSITION&quot;: 0,
                       &quot;TEXTURE_0&quot;: 2
                       ...
                   },
                   &quot;indices&quot;: 1,
                   &quot;mode&quot;: 4,
                   &quot;material&quot;: 0
               }
           ]
       } 
    ],
    ...
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;获取到 &lt;code&gt;POSITION&lt;/code&gt; 、&lt;code&gt;indices&lt;/code&gt; 对应的访问器、缓存视图、缓存文件后，即可获取 gltf 模型的所有顶点，即几何模型，即三维要素的几何数据。&lt;/p&gt;
&lt;p&gt;现在问题来了，如何将这些顶点 “打” 上一个印记呢？就像检疫的猪肉一样，打个印记，说明猪是健康的。&lt;/p&gt;
&lt;p&gt;Cesium团队在设计 3dtiles 规范的时候充分利用了 gltf 规范的特点：开源。因此，每一个 &lt;code&gt;primitive&lt;/code&gt; 被在其 &lt;code&gt;attributes&lt;/code&gt; 中添加了额外的访问器：&lt;code&gt;_BATCHID&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-JSON&quot;&gt;&quot;primitives&quot;: [
    {
        &quot;attributes&quot;: {
            &quot;POSITION&quot;: 0,
            &quot;_BATCHID&quot;: 3,
            &quot;TEXTURE_0&quot;: 2
            ...
        },
        &quot;indices&quot;: 1,
        &quot;mode&quot;: 4,
        &quot;material&quot;: 0
    }
]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它与 &lt;code&gt;POSITION&lt;/code&gt; 等没什么两样，同样会占用一部分数据。聪明的读者应该能想到了，如果每一个顶点都有一个所谓的 &lt;code&gt;_BATCHID&lt;/code&gt; 对应，那么我随便给个点，我不就知道这个点的 &lt;code&gt;_BATCHID&lt;/code&gt;，从而就知道这个点属于哪一个 &lt;code&gt;BATCH&lt;/code&gt; 了吗？&lt;/p&gt;
&lt;p&gt;翻翻前面的 “黑话”，GIS的读者更容易关联起来：&lt;/p&gt;
&lt;p&gt;一个 &lt;code&gt;BATCH&lt;/code&gt; （即三维要素）用自己的 &lt;code&gt;BATCHID&lt;/code&gt; 与几何数据一一对应，属性数据也与这个 &lt;code&gt;BATCHID&lt;/code&gt; 一一对应，由传递关系，那么三维的几何数据 (gltf) 也就能和 属性数据 (批量表) 一一对应了。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;不过遗憾的是，并不是所有的瓦片都有 gltf 模型，例如pnts瓦片。&lt;/p&gt;
&lt;p&gt;所以这个 几何 与 属性 两大数据如何关联，在之后的博文再具体问题具体分析。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;em&gt;关于这个模型和属性的关联，在b3dm瓦片的博文中要重点介绍。&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;批量表的结构：json描述信息批量表数据本体&quot;&gt;批量表的结构：JSON描述信息+批量表数据本体&lt;/h2&gt;
&lt;p&gt;与 要素表 很像，批量表也是由： &lt;code&gt;二进制的JSON文本头&lt;/code&gt; + &lt;code&gt;二进制的数据体&lt;/code&gt; 构成的。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1097074/202007/1097074-20200706030933431-346302156.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;关于两个表的更深层次的数据内容，例如如何承载模型与模型之间的逻辑关系，如何记录使用 Google 压缩算法的模型数据，那就是后续文章的内容了。&lt;/p&gt;

&lt;p&gt;本篇没有特定的数据作为说明，写得不太好，因为是第一次尝试用自己的语言表达这两大数据表，谋篇布局能力不太行，还请读者包涵。&lt;/p&gt;
&lt;p&gt;这两个数据表真正的内容，还要等到接下来的四篇对瓦片二进制文件的重点介绍中，才能细细讲完，本篇仅仅作为接下来四篇博客的 “总结”，也可以说是 “介绍”。&lt;/p&gt;
&lt;h2 id=&quot;附：cesiumjs-api-如何查询瓦片的批量表&quot;&gt;附：CesiumJS API 如何查询瓦片的批量表&lt;/h2&gt;
&lt;p&gt;我们通常在Cesium中使用 点击 事件，来获取一个 &lt;code&gt;BATCH&lt;/code&gt;，即三维要素。在Cesium API中，这个被叫做：Cesium3DTileFeature。&lt;/p&gt;
&lt;p&gt;那么，这个 Cesium3DTileFeature 就能访问到它自己的批量表中的属性数据：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-JS&quot;&gt;const handler = new Cesium.ScreenSpaceEventHandler(viewer.canvas);
handler.setInputAction(function(movement) {
    let feature = scene.pick(movement.endPosition);
    if (feature instanceof Cesium.Cesium3DTileFeature) {
        let propertyNames = feature.getPropertyNames();
        let length = propertyNames.length;
        for (var i = 0; i &amp;lt; length; ++i) {
            let propertyName = propertyNames[i];
            console.log(propertyName + ': ' + feature.getProperty(propertyName));
        }
    }
}, Cesium.ScreenSpaceEventType.LEFT_CLICK);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;用到了 &lt;code&gt;Cesium3DTileFeature.getPropertyNames()&lt;/code&gt; 方法获取批量表中所有属性名，用了 &lt;code&gt;Cesium3DTileFeature.getProperty(string Name)&lt;/code&gt; 来获取对应属性名的属性值。更多 API 见官方文档。&lt;/p&gt;
</description>
<pubDate>Sun, 05 Jul 2020 19:10:00 +0000</pubDate>
<dc:creator>秋意正寒</dc:creator>
<og:description>转载请声明出处：全网@秋意正寒 零、本篇前言 说实话，我很纠结是先介绍瓦片的二进制数据文件结构，还是先介绍这两个重要的表。思前想后，我决定还是先介绍这两个数据表。 因为这两个表不先给读者灌输，那么介绍</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/onsummer/p/13200906.html</dc:identifier>
</item>
<item>
<title>Flv.js文档使用随记 - 之乏</title>
<link>http://www.cnblogs.com/zhifa/p/13252838.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhifa/p/13252838.html</guid>
<description>&lt;p&gt;&lt;span&gt;关键字：Flv.js | Flv js | Flv-js | HTML5 FLV Player |&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;0x001: 前言&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;以下涉及到 &lt;a href=&quot;https://github.com/bilibili/flv.js&quot; target=&quot;_blank&quot;&gt;flv.js&lt;/a&gt; 所有内容均是V1.5.0版本内的，如方法、属性、常量、监听等等，不讨论视频编解码，只陈述官方文档内容。采用文字+图片形式，单文字描述怕不好理解，单图片模式又怕将来哪天会挂掉，现在很多年份久的博文就有这情况，也不是没遇到过。非前端工作者，部分术语可能描述不得当，望理解。纯手码字一下午，只是为了时间久后遗忘再回来看一下。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;0x002: 架构图&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1516215/202007/1516215-20200706001317581-1716943373.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;0x003: API文档相关内容&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;flvjs.isSupported()&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;// 查看当前浏览器是否支持flv.js，返回类型为布尔值&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;flvjs.createPlayer(mediaDataSource: MediaDataSource, config?: Config)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;/* 创建一个Player实例，它接收一个MediaDataSource(必选), 一个Config(可选)，如：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;        var flvPlayer = flvjs.createPlayer({&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;            type: 'flv',&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;            url: 'http://example.com/flv/video.flv'&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;        }); */&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;MediaDataSource的字段列表如下，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1516215/202007/1516215-20200706003330312-325000885.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这里说下最后一个segments字段（其余字段都很简单），它接收一个数组，类型为MediaSegment，MediaSegment的字段列表如下，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1516215/202007/1516215-20200706003400574-247659967.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果segments字段存在，transmuxer将把此MediaDataSource视为多片段源。在多片段模式下，将忽略MediaDataSource结构中的duration filesize url字段。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;什么个意思呢，用白话说就是如果指定了segments字段那么之前指定的duration filesize url字段就不再生效了，将标志这是一个多片段合成一个的视频，进度条的总时长就等于各片段相加的和，所以每个片段的duration filesize一定要指定准确。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;Config字段很多，就不一一介绍了，如下&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1516215/202007/1516215-20200706003658119-2029801664.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;flvjs.getFeatureList()&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;// 返回一些功能特性列表，比如是否支持FLV直播流、H264 MP4 视频文件等等，如下&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1516215/202007/1516215-20200706003816978-699660997.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;flvjs.FlvPlayer(mediaDataSource, optionalConfig)&lt;br/&gt;&lt;span&gt;flvjs.NativePlayer(mediaDataSource, optionalConfig)&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;// 这两个方法都继承自 &lt;strong&gt;Player抽象接口&lt;/strong&gt;，一个是创建适用于FLV的Player实例，一个是适用于MP4的Player实例，如下&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1516215/202007/1516215-20200706004035715-1383957599.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;span&gt;　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其实 &lt;strong&gt;flvjs.createPlayer(略)&lt;/strong&gt; 内部就是根据 type 分别创建不同的Player实例，自己去看看源码就知道了。如下&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1516215/202007/1516215-20200706004136560-470163601.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;interface Player (abstract)&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;// 它里面的每个方法或属性其实就是你自己创建出来Player实例的部分方法或属性，可直接调用。如下&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1516215/202007/1516215-20200706004345314-233161637.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;flvjs.LoggingControl&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;span&gt;// 一个全局接口，用于设置 flv.js 的日志级别。如下&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1516215/202007/1516215-20200706004424946-1821469226.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;举几个简单的例子：&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;flvjs.LoggingControl.getConfig()　　&lt;/span&gt;&lt;/strong&gt; &lt;span&gt;&lt;span&gt;//&lt;/span&gt; &lt;span&gt;&lt;span&gt;获取当前日志项的配置情况，如&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;enableCallback: true&lt;br/&gt;&lt;span&gt;enableDebug: true&lt;br/&gt;&lt;span&gt;enableError: true&lt;br/&gt;&lt;span&gt;enableInfo: true&lt;br/&gt;&lt;span&gt;enableVerbose: true&lt;br/&gt;&lt;span&gt;enableWarn: true&lt;br/&gt;&lt;span&gt;forceGlobalTag: true&lt;br/&gt;&lt;span&gt;globalTag: &quot;flv.js&quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;flvjs.LoggingControl.enableVerbose&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;span&gt;/* 输出详细调试信息，默认为true，页面加载后会在控制台打印一些解码日志信息，如forceGlobalTag例子中的日志那样。&lt;br/&gt;&lt;span&gt;设置 false; 控制台不再打印。*/&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;flvjs.LoggingControl.forceGlobalTag&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;span&gt;// 默认false；&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;未设置之前的log打印是这样&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;span&gt;[MSEController] &amp;gt; MediaSource onSourceOpen&lt;br/&gt;&lt;span&gt;[FLVDemuxer] &amp;gt; Parsed onMetaData&lt;br/&gt;&lt;span&gt;[FLVDemuxer] &amp;gt; Parsed AVCDecoderConfigurationRecord&lt;br/&gt;&lt;span&gt;[FLVDemuxer] &amp;gt; Parsed AudioSpecificConfig&lt;br/&gt;&lt;span&gt;[MSEController] &amp;gt; Received Initialization Segment, mimeType: video/mp4;codecs=avc1.640028&lt;br/&gt;&lt;span&gt;[MSEController] &amp;gt; Received Initialization Segment, mimeType: audio/mp4;codecs=mp4a.40.5&lt;br/&gt;&lt;span&gt;[FlvPlayer] &amp;gt; Maximum buffering duration exceeded, suspend transmuxing task&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;设置 true; 后是这样&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;span&gt;[flv.js] &amp;gt; MediaSource onSourceOpen&lt;br/&gt;&lt;span&gt;[flv.js] &amp;gt; Parsed onMetaData&lt;br/&gt;&lt;span&gt;[flv.js] &amp;gt; Parsed AVCDecoderConfigurationRecord&lt;br/&gt;&lt;span&gt;[flv.js] &amp;gt; Parsed AudioSpecificConfig&lt;br/&gt;&lt;span&gt;[flv.js] &amp;gt; Received Initialization Segment, mimeType: video/mp4;codecs=avc1.640028&lt;br/&gt;&lt;span&gt;[flv.js] &amp;gt; Received Initialization Segment, mimeType: audio/mp4;codecs=mp4a.40.5&lt;br/&gt;&lt;span&gt;[flv.js] &amp;gt; Maximum buffering duration exceeded, suspend transmuxing task&lt;br/&gt;&lt;span&gt;[flv.js] &amp;gt; MediaSource onSourceEnded&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;flvjs.Events&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;span&gt;// 可以与Player.on（）/ Player.off（）一起使用的一系列常量。需要使用前缀flvjs.Events。如下&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1516215/202007/1516215-20200706005450598-614745635.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;flvjs.ErrorTypes&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;flvjs.ErrorDetails&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;span&gt;// 是几个错误类型以及相应类型对应的错误详情，可以用来做些判断。也需要使用前缀flvjs.Events。如下&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1516215/202007/1516215-20200706005715883-2112909664.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;0x004: 直播播放 文档相关内容&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;　　&lt;br/&gt;&lt;span&gt;您需要在MediaDataSource中提供一个实时流URL（可以是HTTP 或 WebSocket），并指示isLive：true。如下&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span&gt;        var flvPlayer = flvjs.createPlayer({&lt;br/&gt;&lt;span&gt;            type: &quot;flv&quot;,&lt;br/&gt;&lt;span&gt;            &lt;strong&gt;isLive: true,&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;            url: &quot;http://127.0.0.1:8080/live/livestream.flv&quot;&lt;br/&gt;&lt;span&gt;        });&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1516215/202007/1516215-20200706010201878-1431982699.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;0x005: 多段播放 文档相关内容&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;br/&gt;&lt;span&gt;多片段配置示例，需注意的是文档强调：您必须为每个细分提供准确的持续时间。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1516215/202007/1516215-20200706010414193-172451227.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;0x006: 使用记录&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;可以在播放前指定MediaDataSource参数，hasAudio（是否有音频）及hasVideo（是否有视频），单独指定单独有，都指定则都有。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;SeekTo功能 或 player.currentTime属性 接收的值类型是Number，如78或108.999，单位秒&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;0x007: 问题记录&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;　　Q1：点击进度条的未缓冲区域时，不会跳转到对应时间处继续播放，而是无响应。比如6分钟MV，当前播放到3分0秒，当前缓冲到5分0秒，如果点击进度条到5分01秒或之后播放器就无响应了。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　A1：目前用户层的解决办法只能先点击到离缓冲区最近的时长，如4分59秒，播放器才会自动缓冲接下来未缓冲的片段。小文件基本无感，大文件才会有体现。&lt;/span&gt;&lt;span&gt;（点播，视频源类型flv，H264+AAC，大小111 MB ）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　QN：...........&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;0x008: 完结&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 05 Jul 2020 17:55:00 +0000</pubDate>
<dc:creator>之乏</dc:creator>
<og:description>关键字：Flv.js | Flv js | Flv-js | HTML5 FLV Player | 0x001: 前言以下涉及到 flv.js 所有内容均是V1.5.0版本内的，如方法、属性、常量、监</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhifa/p/13252838.html</dc:identifier>
</item>
<item>
<title>独在异乡为异客，每逢佳节倍思亲 - 小熊的进阶之路</title>
<link>http://www.cnblogs.com/xiaoxiong2015/p/13193668.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaoxiong2015/p/13193668.html</guid>
<description>&lt;p&gt;&lt;span&gt;　　 &lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;独在异乡为异客，每逢佳节倍思亲 &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　今天是21世纪三个最晚端午节中的一个端午节。也是第一次体会到了这句诗的含义。在与家人视频之后，不免令人思考，身处异乡，远离家人，孑然一身，意义何在？&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;端午起了个头，然后被发版、上线计划等各种事务拖到今天才写完。上半年悄无声息地溜走了，转眼到了七月份。也是时候做一个半年性总结了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　从职业生涯的发展路程上来看，思考背井离乡的意义，从原始需求出发，俗了点就是为了赚钱。那么怎么赚更多的钱，当然是需要好好学习，继续加深巩固专业知识，同时扩展视野，保持对其他行业的热情与关注。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;&lt;strong&gt;如何加深在专业领域的研究？&lt;/strong&gt;&lt;/span&gt;比较庆幸的是，目前所在的项目，规模较大，技术栈很多。只要自身有对学习新事物的热情，以及对技术成长路线的研究，可以在实践中成长。比如最近测试、开发环境部署在客户PaaS平台的微服务总是unhealthy，导致lb判断服务不可用，直接返回请求503。通过分析判断，dump出服务在unhealthy时的内存快照，发现我们服务其实是处于健康状态的。那么分析健康检查的机制：两秒钟请求一次后端接口，三次失败即判断服务不健康。总结下来分析原因是：微服务部署所在机器可能因为资源有限，导致服务暂时的无响应不可用。被健康检查检查到后即判定为不健康，503下线服务。临时解决方法是：增加健康检查的阈值，五秒钟判断一次，十次判断不健康才判定为unhealthy。同时设置在不健康时自动重启。根本解决方法是：还是得增加机器配置，迁移到更好的环境上面去。通过上面这个例子，在年初定的学习jvm层面的知识，有了一次实践性的操作。dump出内存分析，heap总大小才800M，其中大多数都是字符串常量。很正常的内存分布。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;&lt;strong&gt;如何提高交流沟通水平？&lt;/strong&gt;&lt;/span&gt;在最近的聚餐、发布会中发现：对于技术人员，总是比较理性，讲道理一点。所以会造成一种局面，在演讲，或聊天的过程中，理性的讲话大于情商考虑的讲话。不像销售那样，不懂原理细节，可以毫无心理负担的向客户夸夸其谈。开发人员则会有无形心理压力，是要对自己做出的承诺负责任的。排除夸大产品这方面，另外一方面在交谈的过程中也是需要一些交流技巧的。那么这方面尽可能的在提高自身阅读数量上成长。潜移默化地增加知识储备，谈资自然而来。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;&lt;span&gt;向什么方向发展？&lt;/span&gt;&lt;/strong&gt;近期正值年中冲刺，端午休两天，然后上半个月的班。996的作息经历了一段时间，感悟到身体确实是革命的本钱。不禁让人思考，35岁如果还是这样，那恐怕确实是要中年危机了。看着周围30左右的程序员，一位因不善言谈，虽饱读诗书，却也仍是干着和我们一样的活。一位也埋头苦干，但在技术领域钻研比较深刻，目前是4C架构师。与他同级的另外一位4C，则转型做项目管理。每天与人打交道，向上级汇报，向同级部门扯皮，向下级安排工作。技术路线的几种方向，同时也需要公司提供平台给你发展，提供适当的岗位给你发挥。也是需要天时地利的。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;&lt;span&gt;奔着财务自由而努力奋斗&lt;/span&gt;&lt;/strong&gt; 前几天字节跳动的郭宇28岁实现财务自由，不免让人感叹。时机的把握很重要，但自身的实力也需要锤炼。另一方面财富的积累速度，与本金的多少也有着很大的关系。最近疫情影响带来的一波行情，到现在赚了差不多50个点左右。但苦于本金太少，感叹富人赚钱易，穷人积累难。要是本金1000000，目前就有1500000了。所以财富也是遵从28理论的，多数的财富，总是在少部分的人手中，且他们会越来越有钱。加油吧，后浪！&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 05 Jul 2020 17:11:00 +0000</pubDate>
<dc:creator>小熊的进阶之路</dc:creator>
<og:description>独在异乡为异客，每逢佳节倍思亲 今天是21世纪三个最晚端午节中的一个端午节。也是第一次体会到了这句诗的含义。在与家人视频之后，不免令人思考，身处异乡，远离家人，孑然一身，意义何在？ 端午起了个头，然后</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiaoxiong2015/p/13193668.html</dc:identifier>
</item>
</channel>
</rss>