<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>#2 Python面向对象（一） - MinuteSheep</title>
<link>http://www.cnblogs.com/minutesheep/p/10394293.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/minutesheep/p/10394293.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;对于萌新来说，面向对象，这是一个很陌生的词语。如果你接触过Linux，你一定知道“一切皆文件”，也就是说，在Linux中所有都是文件，鼠标是文件、键盘是文件、目录是文件等等一切都是文件；Python设计时就是一门面向对象的语言，在Python中，秉承“一切皆对象”，也就是说，在Python中见到的一切都是对象。面向对象是一个很抽象的概念，来一点一点剖析它！&lt;/p&gt;
&lt;h3&gt;一、程序编程典范&lt;/h3&gt;
&lt;p&gt;在编程中，想要实现同样的功能，可能会有好多种编写方法，毕竟条条大路通罗马，随着编写方法的不断聚类，出现了三种主要的程序编程典范，分别是：面向过程编程、函数式编程、面向对象编程。这三种编程典范各有千秋，比较一下便知。&lt;/p&gt;
&lt;h4&gt;1.1 面向过程编程&lt;/h4&gt;
&lt;p&gt;面向过程编程的思想是让程序从头到尾一步步执行，环环相扣。对于小程序和小脚本来说，面向过程是最方便的。但是面向过程也有这致命的缺点，代码的重复利用率极低，假如程序中有十次需要拿到列表里数字元素的最小值，那就要重复编写十次这个代码，很烦对不对，突然需求变了，不要最小值了，要最大值，那就要更改程序十次，更烦😡&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; list1 = [1, 2, 3, 4, 5, 6, 7&lt;span&gt;]
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; list2 = [2, 3, 1, 5, 5, 3, 1&lt;span&gt;]
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; list3 = [23, 456, 134, 45&lt;span&gt;]
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; max_num =&lt;span&gt; list1[0]
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; list1:
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; max_num &amp;lt;&lt;span&gt; i:
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     ¦   max_num =&lt;span&gt; i
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(max_num)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; max_num =&lt;span&gt; list2[0]
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; list2:
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; max_num &amp;lt;&lt;span&gt; i:
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     ¦   max_num =&lt;span&gt; i
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(max_num)
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt; max_num =&lt;span&gt; list3[0]
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; list3:
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; max_num &amp;lt;&lt;span&gt; i:
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     ¦   max_num =&lt;span&gt; i
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(max_num)
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 可以看到每次都要写一遍代码，重复利用率极低&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;1.2 函数式编程&lt;/h4&gt;
&lt;p&gt;于是函数便应运而生了，函数的出现大大增加了代码的重复利用率，并且修改起来也特别方便，程序也容易扩展。将上面的需求编写为一个函数即可，每次使用时调用函数即可，当需求变了以后，直接修改函数的代码块就可以解决。这就是函数式编程，听起来超级方便是不是，以上就是函数式编程的优点。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; maxNum(nums):
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;'''&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    返回nums中的最大数字
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;'''&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     max_num =&lt;span&gt; nums[0]
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; nums:
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     ¦   &lt;span&gt;if&lt;/span&gt; max_num &amp;lt;&lt;span&gt; i:
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     ¦   ¦   max_num =&lt;span&gt; i
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(max_num)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; list1 = [1, 2, 3, 4, 5, 6, 7&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; list2 = [2, 3, 1, 5, 5, 3, 1&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; list3 = [23, 456, 134, 45&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;maxNum(list1)
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;maxNum(list2)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;maxNum(list3)
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 使用函数极大的提高了代码的重复利用率&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;1.3 面向对象编程&lt;/h4&gt;
&lt;p&gt;但但但但但是，函数式编程就没有缺点了吗？当然有，要不然就不会出现面向对象编程了。&lt;/p&gt;
&lt;p&gt;假如现在有三个角色，分别是张三、李四、王二麻子，他们的职业分别是老师、医生、建造师，需要实现的功能是吃饭、说话、教书、治疗、建造。按照函数式编程的思想，这些功能就是函数嘛，搞起：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; eat(name):
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;pass&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; talk(name):
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;pass&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; teach(name):
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;pass&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; treat(name):
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;pass&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; build(name):
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;pass&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 三个人都能吃&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; eat(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;张三&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; eat(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;李四&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; eat(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;王二麻子&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 三个人都能说话&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; talk(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;张三&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; talk(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;李四&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; talk(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;王二麻子&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 只有张三可以教书&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; teach(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;张三&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 只有李四可以治疗&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt; treat(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;李四&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 只有王二麻子可以建造&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt; build(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;王二麻子&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的代码看起来实现了要有的功能，但是有一个致命的问题，那就是张三好像也可以治疗和建造、李四也可以教书和建造、王二麻子也可以教书和治疗，无非不过传递参数的时候换一个人名，这明显是不允许的！要是可以做出限制就好了，教师只能去教书，不能去治疗和建造，这就是面向对象编程的思想。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1443622/201902/1443622-20190218130714661-465643835.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;二、面向对象简介&lt;/h3&gt;
&lt;p&gt;从上图可以看出，对象来自于类，对象能干的事只有类里的方法，现在又稀里糊涂多了一个更加陌生的新名词：类&lt;/p&gt;
&lt;h4&gt;2.1 面向对象核心&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;类（class）：用来描述属性和方法的集合。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方法：类中定义的函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对象：类的实例化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;「解释」面向对象编程就是物以类聚，人以群分。有一个职业叫做医生（类），这是一个抽象的存在；李四（对象）是一个医生，这是一个具体而真实的存在；因为医生（类）可以吃饭、说话、治疗，不可以教书，那么张三（对象）就可以吃饭、说话、治疗，不可以教书。&lt;/p&gt;
&lt;p&gt;这就是面向对象编程，尤其对于游戏开发及其重要，比如英雄联盟，所有英雄都可以使用召唤师技能（点燃、闪现等），不同英雄又有着各自不同的技能&lt;/p&gt;
&lt;h4&gt;2.2 一切皆对象&lt;/h4&gt;
&lt;p&gt;Python在设计之初就是一门面向对象编程语言，特点就是：一切皆对象。字符串、列表、字典等这些都是类，每当你创建一个具体的字符串，就相当于类的实例化对象，这个具体的对象就可以使用字符串类里的方法，这也就是为什么不同数据类型拥有不同的方法 &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
In [2]: &lt;span&gt;print&lt;/span&gt;(type(&lt;span&gt;''&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&amp;lt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;str&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;gt;&lt;span&gt;

In [&lt;/span&gt;3]: &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(type([]))
&lt;/span&gt;&amp;lt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;gt;&lt;span&gt;

In [&lt;/span&gt;4]: &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(type({}))
&lt;/span&gt;&amp;lt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;dict&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;gt;&lt;span&gt;

In [&lt;/span&gt;5]: &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(type(()))
&lt;/span&gt;&amp;lt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;tuple&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;gt;


&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 可以看到这些数据类型都是类&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;三、类的创建和实例化&lt;/h3&gt;
&lt;h4&gt;3.1 基本语法&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;「创建」&lt;/strong&gt;说了这么多，相信你已经明白了面向对象编程的思想。那么接下来就要开始创建类了。基本语法如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; 类名:
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
    类的帮助信息
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
    类的代码块（可以是语句、函数、类）&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到类的定义和函数的定义差不多，举几个例子吧：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Doctor:
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
    创建一个医生类
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; eat(self):
    ¦   &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;我喜欢吃&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; talk(self):
    ¦   &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;我喜欢说话&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; treat(self):
    ¦   &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;我喜欢治疗病人&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Teacher:
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
    创建一个老师类
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; eat(self):
    ¦   &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;我喜欢吃&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; talk(self):
    ¦   &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;我喜欢说话&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    ¦
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; teach(self):
    ¦   &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;我喜欢教书&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;「实例化」&lt;/strong&gt;类的实例化其实很简单，只需要 &lt;span class=&quot;cnblogs_code&quot;&gt;对象 = 类()&lt;/span&gt; 即可，举例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
zhangsan = Teacher()  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 将Teacher类实例化为对象张三&lt;/span&gt;
&lt;span&gt;
lisi &lt;/span&gt;= Doctor()   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 将Doctor类实例化为对象李四&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;「属性访问」&lt;/strong&gt;使用 &lt;span class=&quot;cnblogs_code&quot;&gt;实例化对象.方法()&lt;/span&gt; 即可，例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;zhangsan.eat()
zhangsan.teach()
lisi.talk()
lisi.treat()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 运行结果&lt;/span&gt;
&lt;span&gt;
我喜欢吃
我喜欢教书
我喜欢说话
我喜欢治疗病人&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;3.2 self参数&lt;/h4&gt;
&lt;p&gt;细心的小伙伴已经发现类里的每一个函数都有一个默认参数self，这个self是什么呢？我们先来打印一下看看：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Teacher:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; eat(self):
    ¦   &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(self)   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 打印self&lt;/span&gt;
&lt;span&gt;

lisi &lt;/span&gt;=&lt;span&gt; Teacher()

lisi.eat()


&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 运行结果&lt;/span&gt;
&amp;lt;&lt;span&gt;__main__&lt;/span&gt;.Teacher object at 0x1014b12e8&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到self是Teacher object，object的中文意思为对象，也就是说，self是类的实例化对象，也就是lisi。&lt;/p&gt;
&lt;p&gt;类中函数的第一个参数是固定表示对象的，与叫什么无关，self是大家约定俗成的叫法而已，换成其他名称也是可以的，比如换成sb&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Teacher:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; eat(sb):
    ¦   &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(sb)


lisi &lt;/span&gt;=&lt;span&gt; Teacher()

lisi.eat()


&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 运行结果：&lt;/span&gt;
&amp;lt;&lt;span&gt;__main__&lt;/span&gt;.Teacher object at 0x104034320&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;不是特殊需要尽量不要改变self的名称啦🐷&lt;/p&gt;
&lt;h2&gt;小结&lt;/h2&gt;
&lt;p&gt;关于面向对象第一小节就记录这么多，主要是理解面向对象的思想以及简单类的创建。之后会讲解类的各种变量、类的传参、类的性质、类的各种方法。今天就肝到这里&lt;/p&gt;
</description>
<pubDate>Mon, 18 Feb 2019 07:32:00 +0000</pubDate>
<dc:creator>MinuteSheep</dc:creator>
<og:description>本篇博文主要记录Python面向对象的知识，重点分析了面向对象编程的思想和简单类的创建</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/minutesheep/p/10394293.html</dc:identifier>
</item>
<item>
<title>asp.net core系列 26 EF模型配置(实体关系) - 花阴偷移</title>
<link>http://www.cnblogs.com/MrHSR/p/10393861.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/MrHSR/p/10393861.html</guid>
<description>&lt;h3 align=&quot;left&quot;&gt;一.概述&lt;/h3&gt;
&lt;p&gt;　　EF实体关系定义了两个实体互相关联起来(主体实体和依赖实体的关系，对应数据库中主表和子表关系)。 在关系型数据库中，这种表示是通过外键约束来体现。&lt;span&gt;本篇主要讲一对多的关系&lt;/span&gt;。先了解下描述关系的术语。&lt;/p&gt;
&lt;p&gt;　　(1) 依赖实体： 这是包含外键属性的实体(子表)。有时称为 child 。&lt;/p&gt;
&lt;p&gt;　　(2) 主体实体： 这是包含主/备用键属性的实体(主表)。 有时称为 parent。&lt;/p&gt;
&lt;p&gt;　　(3) 外键：依赖实体(子表)中的属性，用于存储主表的主键属性的值。&lt;/p&gt;
&lt;p&gt;　　(4) 主键： 唯一标识的主体实体(主表)的属性。 这可能是 primary key 或备用键。&lt;/p&gt;
&lt;p&gt;　　(5) 导航属性： 包含对相关实体引用,在的主体和或依赖实体上定义的属性。&lt;/p&gt;
&lt;p&gt;　　　　集合导航属性： 一个导航属性，对多个相关实体的引用。&lt;/p&gt;
&lt;p&gt;　　　　引用导航属性： 一个导航属性，对单个相关实体的引用。&lt;/p&gt;

&lt;p&gt;         下面示例代码来说明Blog和Post之间的一对多关系。其中 &lt;code&gt;Post&lt;/code&gt; 是依赖实体；&lt;code&gt;Blog&lt;/code&gt; 是主体实体；&lt;code&gt;Post.BlogId&lt;/code&gt; 是外键；&lt;code&gt;Blog.BlogId&lt;/code&gt; 是主键；Post.Blog引用导航属性；Blog.Posts集合导航属性。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Blog
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; BlogId { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Url { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;Post&amp;gt; Posts { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Post
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; PostId { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Title { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Content { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; BlogId { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Blog Blog { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;二.约定&lt;/h3&gt;
&lt;p&gt;　　按照约定，当在实体类型上发现导航属性时，将创建关系。如果属性所指向的类型不能被当前数据库提供程序映射为标量类型，则将其视为导航属性。下面用三个示例来说明通过约定创建的主从实体关系。&lt;/p&gt;

&lt;p&gt;　&lt;strong&gt;　2.1 完全定义的关系&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;span&gt;关系最常见的模式是在关系的两端定义导航属性，并在依赖实体类中定义外键属性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　(1)如果两个类型之间找到一对导航属性，则它们将被配置为同一关系的反转导航属性。&lt;/p&gt;
&lt;p&gt;　　　　(2)如果依赖实体包含名为的属性&lt;code&gt;&amp;lt;primary key property name&amp;gt;&lt;/code&gt;， &lt;code&gt;&amp;lt;navigation property name&amp;gt;&amp;lt;primary key property name&amp;gt;&lt;/code&gt;，或&lt;code&gt;&amp;lt;principal entity name&amp;gt;&amp;lt;primary key property name&amp;gt;&lt;/code&gt;然后它将配置为外键。&lt;/p&gt;
&lt;p&gt;　　　　下面代码示例是完全定义的关系的实体，通过约定来创建主从实体关系。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Blog
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; BlogId { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Url { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;反转导航属性&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; List&amp;lt;Post&amp;gt; Posts { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Post
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; PostId { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Title { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Content { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过约定(&amp;lt;primary key property name&amp;gt;)创建外键&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; BlogId { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;反转导航属性&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; Blog Blog { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　使用EF基于数据模型(Blog和Post实体)创建数据库。生成后，查看数据表的关系映射，如下图所示:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/151560/201902/151560-20190218100609671-2070455753.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;2.2  没有外键属性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;span&gt;虽然建议在依赖实体类中定义外键属性&lt;/span&gt;，但这不是必需的。如果没有找到外键属性，那么将引入一个名为&amp;lt;navigation property name&amp;gt; &amp;gt; principal key property name&amp;gt;的隐藏外键属性(上篇有介绍)。在下面代码中，依赖实体Post中没有显示定义外键BlogId。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Post
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; PostId { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Title { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Content { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Blog Blog { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 　　&lt;strong&gt;2.3 单一导航属性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 　　　　仅包含一个导航属性(没有反转导航属性，也没有外键属性)就足以拥有约定定义的关系。还可以有一个导航属性和一个外键属性。代码如下所示产：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Blog
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; BlogId { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Url { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;Post&amp;gt; Posts { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Post
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; PostId { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Title { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Content { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;&lt;strong&gt; 三. 数据注释&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt; 　　有两个数据注释可用于配置关系，[ForeignKey]和[InverseProperty]。&lt;/p&gt;
&lt;p&gt;　　3.1 ForeignKey可以将指定属性设置为外键属性。 &lt;span&gt;这种设置通常是外键属性不被约定发现时，显示设置&lt;/span&gt;。如下面代码示例, 在依赖实体Post中将BlogForeignKey指定为外键。代码中生成的主从实体关系与上面的约定示例是一样的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Blog
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; BlogId { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Url { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;Post&amp;gt; Posts { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Post
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; PostId { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Title { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Content { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; BlogForeignKey { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

    [ForeignKey(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;BlogForeignKey&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Blog Blog { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　下面使用EF基于数据模型(Blog和Post实体)创建数据库。生成后，查看数据表的关系映射，如下图所示:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/151560/201902/151560-20190218135943425-758560931.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　3.2 InverseProperty配置依赖实体和主体实体上的导航属性如何配对。当两个实体类型之间有一对以上的导航属性时，通常会这样做。如下面代码示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Post
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; PostId { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Title { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Content { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Blog Blog { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;public User Author { get; set; }

        public User Contributor { get; set&lt;/span&gt;&lt;span&gt;&lt;span&gt;; }&lt;/span&gt;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; User
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; UserId { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; FirstName { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; LastName { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

&lt;span&gt;        [InverseProperty(&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&quot;Author&quot;)]
        public List&amp;lt;Post&amp;gt; AuthoredPosts { get; set; }

        [InverseProperty(&quot;Contributor&quot;)]
        public List&amp;lt;Post&amp;gt; ContributedToPosts { get; set&lt;/span&gt;&lt;span&gt;&lt;span&gt;; }&lt;/span&gt;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　下面使用EF基于数据模型(User和Post实体)创建数据库。生成后，查看数据表的关系映射，如下图所示:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/151560/201902/151560-20190218135524860-1048870917.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;四. Fluent API&lt;/h3&gt;
&lt;p&gt; 　　要在Fluent API中配置关系，首先要确定组成关系的导航属性。HasOne或HasMany标识开始配置的实体类型上的导航属性。然后调用&lt;code&gt;WithOne&lt;/code&gt;或&lt;code&gt;WithMany&lt;/code&gt;来标识反导航。HasOne/WithOne用于引用导航属性，而HasMany/WithMany用于集合导航属性。&lt;/p&gt;
&lt;p&gt;　　在EF基于现有数据库进行反向工程时，根据数据库将自动生成DbContext上下文类，里面重写了OnConfiguring方法。下面示例是一个MyContext上下文类，在OnModelCreating方法中确定了实体的关系。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;4.1 完全定义的关系&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyContext : DbContext
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DbSet&amp;lt;Blog&amp;gt; Blogs { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DbSet&amp;lt;Post&amp;gt; Posts { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnModelCreating(ModelBuilder modelBuilder)
    {
        modelBuilder.Entity&lt;/span&gt;&amp;lt;Post&amp;gt;&lt;span&gt;()
            .HasOne(p &lt;/span&gt;=&amp;gt; p.Blog) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Post类有一个Blog引用导航属性&lt;/span&gt;
            .WithMany(b =&amp;gt; b.Posts);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Blog类有一个Posts反导航集合&lt;/span&gt;
&lt;span&gt;    }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Blog
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; BlogId { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Url { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;反导航集合&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; List&amp;lt;Post&amp;gt; Posts { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Post
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; PostId { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Title { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Content { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;引用导航属性&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; Blog Blog { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　&lt;strong&gt;4.2 单一导航属性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　如果只有一个导航属性，那么就会出现无参数重载的WithOne以及WithMany。这表明在关系的另一端有一个概念上的引用或集合，但是实体类中不包含导航属性。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyContext : DbContext
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DbSet&amp;lt;Blog&amp;gt; Blogs { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DbSet&amp;lt;Post&amp;gt; Posts { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnModelCreating(ModelBuilder modelBuilder)
    {
   &lt;span&gt;     modelBuilder.Entity&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&amp;lt;Blog&amp;gt;()
            .HasMany(b =&amp;gt; b.Posts)//blog类有一个集合导航属性
&lt;/span&gt;&lt;span&gt;&lt;span&gt;            .WithOne();&lt;/span&gt;
    }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Blog
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; BlogId { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Url { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;Post&amp;gt; Posts { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Post
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; PostId { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Title { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Content { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　下面使用EF基于数据模型(User和Post实体)创建数据库。生成后，查看数据表的关系映射，如下图所示:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/151560/201902/151560-20190218143420616-290037714.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;4.3 外键&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　可以使用 Fluent API 配置哪些属性应用作给定关系外键属性。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyContext : DbContext
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DbSet&amp;lt;Blog&amp;gt; Blogs { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DbSet&amp;lt;Post&amp;gt; Posts { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnModelCreating(ModelBuilder modelBuilder)
    {
        modelBuilder.Entity&lt;/span&gt;&amp;lt;Post&amp;gt;&lt;span&gt;()
            .HasOne(p &lt;/span&gt;=&amp;gt;&lt;span&gt; p.Blog)
            .WithMany(b &lt;/span&gt;=&amp;gt;&lt;span&gt; b.Posts)
           &lt;span&gt; .HasForeignKey(p &lt;/span&gt;&lt;/span&gt;&lt;span&gt;=&amp;gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; p.BlogForeignKey);&lt;/span&gt;
    }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Blog
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; BlogId { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Url { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;Post&amp;gt; Posts { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Post
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; PostId { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Title { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Content { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

    &lt;/span&gt;&lt;span&gt;public int BlogForeignKey { get; set; }
    public Blog Blog { get; set&lt;/span&gt;&lt;span&gt;&lt;span&gt;; }&lt;/span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　以下代码列表演示如何配置复合外键。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyContext : DbContext
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DbSet&amp;lt;Car&amp;gt; Cars { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnModelCreating(ModelBuilder modelBuilder)
    {
&lt;span&gt;        modelBuilder.Entity&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&amp;lt;Car&amp;gt;()
            .HasKey(c =&amp;gt; new { c.State, c.LicensePlate });

        modelBuilder.Entity&amp;lt;RecordOfSale&amp;gt;()
            .HasOne(s =&amp;gt; s.Car)
            .WithMany(c =&amp;gt; c.SaleHistory)
            .HasForeignKey(s =&amp;gt; new&lt;/span&gt;&lt;span&gt;&lt;span&gt; { s.CarState, s.CarLicensePlate });&lt;/span&gt;
    }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Car
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; State { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; LicensePlate { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Make { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Model { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;RecordOfSale&amp;gt; SaleHistory { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RecordOfSale
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; RecordOfSaleId { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DateTime DateSold { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;decimal&lt;/span&gt; Price { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

    &lt;/span&gt;&lt;span&gt;public string CarState { get; set; }
    public string CarLicensePlate { get; set; }
    public Car Car { get; set&lt;/span&gt;&lt;span&gt;&lt;span&gt;; }&lt;/span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　总结：关于实体关系，还讲到了“必需和可选的关系”、“级联删除”。以及关系模式中的“一对一关系”、“多对多关系&quot;，这些以后用到再参考文档。 个人认为在传统开发中，以建库建表优先的情况下，不会去设置数据表的外键关系，这种关系是由编程去控制。 这样对数据库进行反向工程时，也不会生成有关系的主从实体模型。&lt;/p&gt;

&lt;p&gt;　参考文献：&lt;/p&gt;
&lt;p&gt;　　　　官方文档：&lt;a href=&quot;https://docs.microsoft.com/zh-cn/ef/core/modeling/relationships&quot; target=&quot;_blank&quot;&gt;EF 实体关系&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 18 Feb 2019 07:18:00 +0000</pubDate>
<dc:creator>花阴偷移</dc:creator>
<og:description>一.概述 EF实体关系定义了两个实体互相关联起来(主体实体和依赖实体的关系，对应数据库中主表和子表关系)。 在关系型数据库中，这种表示是通过外键约束来体现。本篇主要讲一对多的关系。先了解下描</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/MrHSR/p/10393861.html</dc:identifier>
</item>
<item>
<title>第三方支付(一):概述、起源 | PayPal、支付宝诞生的故事 - 纯洁的微笑</title>
<link>http://www.cnblogs.com/ityouknow/p/10395748.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ityouknow/p/10395748.html</guid>
<description>&lt;p&gt;你知道第三方支付是如何由来的吗？&lt;/p&gt;
&lt;h2 id=&quot;第三方支付概述&quot;&gt;第三方支付概述&lt;/h2&gt;
&lt;p&gt;说起第三方支付，好像大家都知道，天天不是用支付宝和微信吗？支付宝和微信支付确实是行业内非常具有代表的第三方支付公司，但现在他们已经不完全是一家第三方支付公司，都可以称为金融集团。其实第三方支付，远远不止支付宝和微信支付还有更多产品类型和支付场景。&lt;/p&gt;
&lt;p&gt;维基百科：&lt;strong&gt;第三方支付&lt;/strong&gt;（英语：Third-Party Payment）指的是由第三方业者居中于买卖家之间进行收付款作业的交易方式。此名词首先出现于中国，在中国从事第三方支付业务必须申请第三方支付牌照（支付业务许可证）。&lt;/p&gt;
&lt;p&gt;之所以称“第三方”，是因为这些平台并不涉及资金的所有权，而只是起到中转作用。它原本是用来解决不同银行卡的网上银行对接以及异常交易带来的信用缺失问题，通过提供线上和线下支付渠道，完成从消费者到商户以及金融机构间的货币支付、资金清算、查询统计等系列过程。&lt;/p&gt;
&lt;p&gt;在中国第三方支付是受到中国中国人民银行所监管。中国人民银行所颁布的《非银行支付机构网络支付业务管理办法》中对第三方支付运营机构的定义为：办理&lt;strong&gt;互联网支付、移动电话支付、固定电话支付、数字电视支付&lt;/strong&gt;等网络支付业务的非银行机构。第三方支付被称为网络支付业务，是指收款人或付款人通过计算机、移动终端等电子设备，依托公共网络信息系统远程发起支付指令，且付款人电子设备不与收款人特定专属设备交互，由支付机构为收付款人提供货币资金转移服务的活动。&lt;/p&gt;
&lt;p&gt;根据央行2010年在&lt;strong&gt;《非金融机构支付服务管理办法》&lt;/strong&gt;中给出的非金融机构支付服务的定义，从广义上讲第三方支付是&lt;strong&gt;指非金融机构作为收、付款人的支付中介所提供的网络支付、预付卡发行与受理、银行卡收单以及中国人民银行确定的其他支付服务。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为什么需要第三方支付&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;1.第三方支付平台提供一系列的应用接口程序，将多种银行卡支付方式整合到一个界面上，负责交易结算中与银行的对接，使网上购物更加快捷、便利。第三方支付整合了后端各大银行的不同支付接口，对外提供统一的接入平台，方便商户接入。&lt;/p&gt;
&lt;p&gt;2.银行商业系统安全等级的要求，支付体验相对较差，利用第三方支付平台进行支付操作更加简单而易于接受。第三方支付激烈的竞争中，为了争夺更多的用户，在商户接入，用户体验，产品易用性等方面做了大量优化，方便用户、商户支付体验。&lt;/p&gt;
&lt;p&gt;3.第三方支付平台本身依附于大型的门户网站，且以与其合作的银行的信用作为信用依托，因此第三方支付平台能够较好地突破网上交易中的信用问题，有利于推动电子商务的快速发展。&lt;/p&gt;
&lt;p&gt;4.从成本来说，第三方支付平台降低了企业直连银行的成本，从而满足企业发展在线业务的收付要求。第三方支付平台更加简化了支付上的转账，从而对降低转账所需时间。第三方支付平台避免与服务企业上的竞争，只作为中间的服务层。而第三方支付平台的多样性，为被服务的市场订制个性化的结算服务。&lt;/p&gt;
&lt;h2 id=&quot;第三方支付起源&quot;&gt;第三方支付起源&lt;/h2&gt;
&lt;p&gt;第三方支付最早源于美国的独立销售组织制度 （Independent Salesorganization， ISO），指收单机构和交易处理商委托 ISO 做中小商户的发展、服务和管理工作的一种机制。 1996 年，全球第一家第三方支付公司在美国诞生，随后逐渐涌现出 Amazon Payments、 Yahoo!PayDirect、 PayPal 等一批第三方支付公司，其中以 PayPal 最为突出，其发展历程基本代表了北美第三方支付市场的发展缩影。&lt;/p&gt;
&lt;h3 id=&quot;paypal&quot;&gt;PayPal&lt;/h3&gt;
&lt;p&gt;世界第一家支付公司是 PayPal，现在也是世界上使用范围最广的第三方支付公司。PayPal 支持200多个国家和地区，全球活跃用户接近2亿，通用货币涵盖加元，欧元，英镑，美元，日元，澳元等24种。&lt;/p&gt;
&lt;p&gt;1998年在美国的斯坦福，一位叫马克斯·列夫琴（Max Rafael Levchi）的程序员被一场名为“市场全球化和政治自由之间的联系”的演讲而大为所动，演讲结束后马克斯主动找到演讲者彼得·蒂尔（Peter Thiel）交流互动。他与马克斯研讨了当前支付领域的种种痛点，尝试用一种新的技术（数字钱包）来代替现金，实现个人对个人的支付。&lt;/p&gt;
&lt;p&gt;一家名叫康菲尼迪（Confinity）的支付公司就这样在两位年轻人此次简短交流和几次午餐的思想碰撞后诞生。产品的初衷是提供一个方便客户和商家进行网上金钱交易的工具。&lt;/p&gt;
&lt;p&gt;2000年，埃隆·马斯克为解决在网上快捷转账业务上的竞争，将 X.com 公司与彼得·蒂尔和麦克斯·拉夫琴创办的 Confinity 公司合并，这家新公司于次年2月更名为贝宝（PayPal）。&lt;/p&gt;
&lt;p&gt;2002年10月，全球最大拍卖网站 eBay 以15亿美元收购 PayPal，PayPal 便成为了 eBay 的主要付款途径之一。2005年，PayPal 的中国大陆网站开通，名称是“贝宝”，但是 PayPal 和贝宝实际上是两个相互独立的账户，因为贝宝使用人民币作为唯一的支付货币。&lt;/p&gt;
&lt;p&gt;有趣的是, PayPal 自2002年以15亿美元出售给 eBay 之后，大部分重要员工纷纷离职创业，PayPal 也因此一举成为硅谷史上创造创业者群体最多的一家公司，这些人被誉为 PayPal 黑帮。&lt;/p&gt;
&lt;p&gt;“Paypal 黑帮”这个组织并不是特指某几个联合创始人，而是指早期带领 Paypal 跑马圈地、离开 Paypal 后依旧驰骋科技领域的一群科技达人。这群从 Paypal 走出来的科技达人在各自领域所开拓的疆土。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.itmind.net/assets/images/2019/payment/paypal.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;早在1999年成立的北京首信和上海环迅两个企业是中国最早的第三方支付企业，由于电子商务在中国的缓慢发展，其影响力一直不大。直到2004年12月阿里巴巴公司支付宝的推出，在淘宝购物平台的强大影响下，其业务取得了突飞猛进的发展，第三方支付的交易规模也呈飞速增长趋势，仅用4年时间便以超过2亿使用用户的绝对优势胜过美国的 PayPal，成为全球最大的第三方支付平台。&lt;/p&gt;
&lt;h3 id=&quot;支付宝&quot;&gt;支付宝&lt;/h3&gt;
&lt;p&gt;支付宝是中国最大的第三方支付公司。支付宝最初是为了解决淘宝网络交易安全所设的一个功能，该功能首先使用“第三方担保交易模式”。&lt;/p&gt;
&lt;p&gt;在淘宝网创办之初，团队士气高涨，大家拼劲儿十足，整个网站也很活跃，有很多用户在论坛上发帖，用户咨询业务也很热情，但奇葩的是没有交易，因为淘宝初期的交易方式无非就两种：要么同城交易见面;要么远程交易汇款。在中国人传统的商业思维中，“一手交钱，一手交货”是天经地义的事情，而在网上交易中，这种传统的交易模式没有先例，淘宝的成长也随之陷入困境。&lt;/p&gt;
&lt;p&gt;碰巧的是，淘宝的创始人孙彤宇一次在逛淘宝网论坛时发现，关于支付信任问题，不仅淘宝网团队为此头疼，淘宝社区中的买家和卖家也在讨论这个问题，他就主动发帖和这些用户讨论。一来二去，他的思路越来越清晰。孙彤宇想，既然用户最关心的是钱，那么只要保证资金安全，用户就敢用淘宝网了。因此，如果能在淘宝网推出一种基于担保交易的支付工具，问题就解决了。&lt;/p&gt;
&lt;p&gt;在2003-2005年，中国的金融行业还是以国有企业为主，电子支付牌照也并没有放开，自己建立一个支付系统既面临法律的风险，也面临技术的难题。当时国内的大多银行觉得：每一笔交易才5块钱、10块钱，完成一笔交易赚的钱都不够我们银行的成本。&lt;/p&gt;
&lt;p&gt;银行觉得利润很低不值得去做，民企没有支付牌照却面临着法律风险，正在团队犹豫之际，马云对团队说：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.itmind.net/assets/images/2019/payment/mayun.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;想要了解这段经历可以点击链接查看视频：&lt;a href=&quot;https://mp.weixin.qq.com/s/rUlsZweOyP8wRwnaAcu-ww&quot;&gt;《马云讲 Honor |视频》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2003年10月18日，淘宝网首次推出支付宝服务。&lt;/p&gt;
&lt;p&gt;2004年，支付宝从淘宝网分拆独立，逐渐向更多的合作方提供支付服务，发展成为中国最大的第三方支付平台。&lt;/p&gt;
&lt;p&gt;2008年1月1日起更名为“支付宝（中国）网络技术有限公司”。&lt;/p&gt;
&lt;p&gt;2017年11月11日凌晨，天猫双11全球狂欢节刚开场5分22秒，支付峰值达到创纪录的25.6万笔／秒，比去年增长超过1.1倍，数据库处理峰值也创下新纪录，达到4200万次／秒，这个数据全球第一。&lt;/p&gt;
&lt;p&gt;2018年天猫双11全球狂欢节，根据现场实时数据，双11开场2分05秒破百亿，26分03秒破500亿，1小时47分26秒破千亿。数据显示，2018年双11每秒订单创建峰值达到49.1万笔，其它技术的各种峰值数据也将再次打破全球记录。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;目前支付宝已经成为全球交易量最大的第三方支付服务公司。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在国内支付宝是一直引领行业创新之路，从最开始的第三方担保交易模式，到后来的快捷支付，二维码支付、余额宝、VR 支付等诸多全球首创。支付宝已经从最初的支付工具，变成现在的蚂蚁金服。&lt;/p&gt;
&lt;p&gt;支付宝在最初期发展的时候很痛苦，因为很多银行都没有对外提供标准的接口，支付宝就开始一家一家的谈，直到最后覆盖了中国绝大多数的银行。支付宝在快速发展的过程中，特别是双十一的推出给支付宝和银行系统都造成了很大的压力，不少银行在双十一的初期因为访问量太大而崩溃。&lt;/p&gt;
&lt;p&gt;后期随着双十一的规模不断上涨，支付宝联合各大银行对系统进行升级才保障了后续业务的大规模发展。从某种程度上讲，支付宝间接的提升了很多银行系统的支撑能力。&lt;/p&gt;
&lt;p&gt;本篇是第三方支付系列文章的第一篇，后续会有更多关于第三方支付的系列文章，敬请期待。&lt;/p&gt;
</description>
<pubDate>Mon, 18 Feb 2019 07:11:00 +0000</pubDate>
<dc:creator>纯洁的微笑</dc:creator>
<og:description>你知道第三方支付是如何诞生的吗？</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ityouknow/p/10395748.html</dc:identifier>
</item>
<item>
<title>MaxCompute在高德大数据上的应用 - 阿里云云栖社区</title>
<link>http://www.cnblogs.com/yunqishequ/p/10395541.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yunqishequ/p/10395541.html</guid>
<description>&lt;p data-spm-anchor-id=&quot;a2c4e.11153940.blogcont689240.i0.17bb4175oIcLAN&quot;&gt;2019年1月18日，由阿里巴巴 &lt;a href=&quot;https://www.aliyun.com/product/odps&quot;&gt;MaxCompute &lt;/a&gt;开发者社区和阿里云栖社区联合主办的“阿里云栖开发者沙龙大数据技术专场”走近北京联合大学，本次技术沙龙上，高德数据技术专家苗翌辰为大家分享了高德如何应用MaxCompute来管理数据架构，开发易用、高效以及弹性的高德应用，为用户提供更优质的出行服务。&lt;/p&gt;
&lt;p&gt;以下内容根据演讲视频以及PPT整理而成&lt;/p&gt;
&lt;p&gt;一、高德的业务和数据&lt;/p&gt;&lt;p&gt;地图描绘需要很多支撑数据，包括现实中的道路信息、路形以及路况等。下面的轨迹热力图展示了高德地图显示的北京联合大学的周边路况，描绘了点、线和面三种信息。通过地图信息和轨迹数据叠加形成区域热力。其中，不同颜色的轨迹展示了该区域一天内不同时间段的路况。&lt;br/&gt;&lt;img title=&quot;image&quot; src=&quot;https://yqfile.alicdn.com/3de6b7d7a84b37d1a5945f5f3bb28734a8162022.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p data-spm-anchor-id=&quot;a2c4e.11153940.blogcont689240.i2.17bb4175oIcLAN&quot;&gt;下面展示了高德的一些业务场景。第一个场景是大家日常使用的高德APP。高德地图是苹果中国的战略合作伙伴，第二个场景展示了高德为苹果提供的出行服务。高德向整个互联网行业开放了其生态能力，第三个场景是高德为APP应用开放者提供的位置服务接口，目前使用该接口进行开发的移动应用包括手机淘宝、今日头条和小米运动等。另外，第四个场景是高德为车载设备提供的完善的位置服务方案。&lt;/p&gt;&lt;p&gt;&lt;img title=&quot;image&quot; src=&quot;https://yqfile.alicdn.com/73b54de7dd2a275352e2e7b4f39a9740929862a3.png&quot; alt=&quot;image&quot; data-spm-anchor-id=&quot;a2c4e.11153940.blogcont689240.i3.17bb4175oIcLAN&quot;/&gt;&lt;/p&gt;
&lt;p&gt;高德地图的业务架构可以用“442阵型”来形容，即分为客户端、中间层、服务引擎以及基础地理信息等4层，同时包含AppleMaps、高德App、第三方App以及车载设备等4个业务入口。另外，数字“2”是指高德地图依赖于两个数据源，即自采数据、行业合作数据组成的基础地理信息和轨迹数据、行车数据等服务引擎产生的数据。“442阵型”的业务架构给高德的发展带来了质的飞跃。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;image&quot; src=&quot;https://yqfile.alicdn.com/d693b75e60650631e6dc514aa92c2dfc3c39ea2d.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下图是高德总裁刘振飞先生正在庆祝高德十一DAU突破一个亿的历史时刻。十一期间，高德为全网用户提供导航的总里程超过135亿公里，相当于在太阳和地球之间往返45次。高德提供海量服务的背后是高德强大的大数据计算能力、超过数千台的高德集群节点和承载超过百 PB数据的集群存储容量。&lt;br/&gt;&lt;img title=&quot;image&quot; src=&quot;https://yqfile.alicdn.com/f7bc968da6ab1f839532a5ef8ed17988ec04165a.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;&lt;p&gt;二、如何管好数据&lt;/p&gt;&lt;p&gt;SPA架构&lt;/p&gt;
&lt;p&gt;高德的数据架构称为“SPA架构”。“S”指代Source，即数据源层，收容了高德内部所有的位置、地图和图像数据。“P”指代Platform，即数据平台，提供了数据仓库、数据适配和数据挖掘能力来支撑上层的数据应用层，也就是Application(“A”)。在“SPA架构”中，高德最关注获取数据的权限，即要求所有数据操作都应该符合安全规范。此外，高德还要求所有部门都明确其开发目标，并且使用统一的平台工具进行开发。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;image&quot; src=&quot;https://yqfile.alicdn.com/0e6e3350f89c9b4a1cff9e9eeb55c93882e6bc3a.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;数据研发&lt;/p&gt;
&lt;p&gt;数据研发的全链路过程包括数据集成、数据开发、运维中心、数据质量、数据地图、数据安全以及数据服务等。高德对数据平台的要求不仅仅是以上全链路都 All in One，还希望都能以可视化的方式进行用户交互，以提高开发效率。以运维中心为例，希望所使用的工具能够将调度节点可视化，并方便进行不同时间粒度的任务依赖。同时，我们还希望拥有可视化的数据地图用于管理元数据信息，方便上下游即时查看。MaxCompute正是符合高德数据业务诉求的给力产品。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;image&quot; src=&quot;https://yqfile.alicdn.com/294d32d6c176b9c0ef96d1601b16c9255090294e.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;MaxCompute平台特点&lt;/p&gt;
&lt;p&gt;高德使用的MaxCompute平台具有以下三个特点：&lt;br/&gt;第一， 易用性，具有零学习成本和完善的IDE等优势。&lt;br/&gt;第二， 效率，高德内部迄今为止最大的公共项目“魔方”就是运用阿里云和MaxCompute实现的。&lt;br/&gt;第三， 弹性，高德于十一期间的流量远远超出想象。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;image&quot; src=&quot;https://yqfile.alicdn.com/ed87820463d547a1d44c5061c5a4b87987872409.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;易用-上云&lt;/p&gt;
&lt;p&gt;2014年，高德的数据架构依赖Flume进行数据采集，依赖一个仅含几百台机器的hadoop集群和Hive等软件实现数据处理。2014年9月份高德内部提出“上云”，即将数据迁移到阿里云，使非流程化的作业得到流程化的管理。与其他复杂的数据迁移工作相比，2014年高德实现了“一键”上云，将源数据的同步从Flume切换成TimeTunnel，后续再可配置化地切换数据。此外，迁移还伴随着代码修改，2014年高德“上云”仅修改了非常少的代码，比如修改老版本M2中的接口等。上方的数据存储层将数据介质替换成OTS等云端产品，以支持更加稳定的前台应用。高德将所有集群数据都迁移到“云上”仅花了两个月时间。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;image&quot; src=&quot;https://yqfile.alicdn.com/5c13b4e7fc25d0713f5beeb1b74de9419a865b89.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;“上云”为高德带来的收益不可估量。图1展示了“上云”后由云端管理所有代码；图2展示了一键式运维管理；图3展示了可计量的计算资源管理，量化地显示各个任务的资源使用情况；图4展示了流程化的可视化安全审批操作。从2014年“上云”到如今2018年，高德经历了飞速的发展，同时也暴露出了一些问题。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;image&quot; src=&quot;https://yqfile.alicdn.com/55845c5f899636de2bc7f7da024736bebe6ef770.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;效率-魔方&lt;/p&gt;
&lt;p&gt;烟囱过多是数据仓库中比较麻烦的问题，高德同样存在该问题。数据使用者可能需要花费一个月寻找数据所在部门、数据的相关产品负责人以及研发人员以索要数据。2017年高德盘点数据仓库时发现，高德内部存在二十个数据仓库项目，并且各个数据仓库间的数据冗余度高达百分之三十，严重影响了团队工作效率。此外，高德数据仓库还存在高时延缺点，核心数据无法保证每天“7点产出”。基于以上两个问题，高德发起了“魔方”项目，将二十个仓库合并成一个以实现全集团的数据治理。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;image&quot; src=&quot;https://yqfile.alicdn.com/d3fac7677514244347f817ace3dec727813b33f2.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;显而易见，要实现全集团的数据治理项目存在严峻的挑战。首先，数据量非常大，“魔方”项目要求实现百PB级数据的全域数据治理。其次，参与人员众多，“魔方”项目涉及到高德全产线的所有数据开发人员，项目团队超过百人。最后，排期紧，为了使数据架构升级不影响正常业务，高德要求“魔方”项目的主体开发工作应在两个半月内完成。此外，数据迁移工作在越短时间内完成对企业的收益就越大，因此高德要求“魔方”项目应在尽量短的时间内完成。应对这几个挑战的主体思路就是引入高效率的研发工具，在规范化的流程中实现协同开发，提高团队的工作效率。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;image&quot; src=&quot;https://yqfile.alicdn.com/e4d3628a6b0b6960932f5c2587b0b9de28abb280.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为此，高德首先统一了工具平台，引入了MaxCompute，下图蓝色部分皆为MaxCompute 为我们带来的业务收益。在数百人的团队中统一规范无疑是困难的，而MaxCompute提供了代码编写规范、调度配置规范以及研发自测规范等规范化模块。其中，代码编写规范模块使用 SQL Scan 工具自动化地检查代码是否符合规范，调度配置规范模块提供了完善的用户手册及各种模板辅助开发人员完成配置。统一流程要求实现定制化地管理数据开发流程，包括研发测试、开发自测、调度测试、QA测试以及最后的上线部署等流程。此外，统一建模和语言、统一数据核定标准也非常重要。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;image&quot; src=&quot;https://yqfile.alicdn.com/58abff3c801aba2ce38351c36896b6043b8388f5.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;阿里云提供了一些优秀工具以构建规范化流程。第一，提供了数据血缘可视化工具，帮助数据开发团队及时地跟踪源数据、数据的上游和下游等信息。第二，提供了开发/测试流程并行的能力，以支持完善的协同开发和高效运转的工作。第三，提供了代码云端版本管理工具，允许实时查看代码变更、代码管理状态并支持回滚。第四，提供了一键数据探查工具，允许数据开发人员通过简单的配置探查海量数据的字段空值率，有效值率，表重复率等信息，极大地提高了数据开发人员的工作效率。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;image&quot; src=&quot;https://yqfile.alicdn.com/dd7813aed6727eb93eb3435d2e1d6b7ca07aabbd.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在规范化的流程以及众多效率工具的帮助下，高德在规定时间内完成了“魔方”项目开发，得到了一致好评。高德最终统一了数据仓库，将内部所有百P级数据的月增速降低了40%，同时数据计算效率提升了30%。即使在2018年十一的流量轰炸时期，高德仍然实现了核心数据的“5点产出”目标（5点到7点需完成核心数据计算任务）。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;image&quot; src=&quot;https://yqfile.alicdn.com/17e16756c3b6628428fa9f035083574aba551a1c.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;&lt;p&gt;弹性-十一&lt;/p&gt;
&lt;p&gt;2018年十一期间，高德的数据处理量随业务快速增长，数据计算任务的性能和平台的稳定性都受到了极大的考验。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;image&quot; src=&quot;https://yqfile.alicdn.com/0da8e4a91ab12c6dd9e19ae42d07facba4026f0a.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;数据血缘可视化工具允许数据开发人员可视化地查看系统资源配置，下图展示了高德在2018年9月2日的系统实际使用计算水位，其中，蓝线是系统配额水位，黄线是系统的实际计算水位。阿里云提供的弹性计算能力允许在一定弹性数据量范围内保证系统资源的正常计算和输出。此外，阿里云还提供了稳定的计算环境，保证计算任务高效地运转，同时避免资源竞争问题。另外，为了更好地利用系统计算资源，高德团队提出了“提高蓝线、打散黄线”方案，申请扩大集群资源配额提升算力空间，通过调度错峰打散实际资源水位。在扩容方面，MaxCompute为高德带来了一键资源扩容能力，使得集群扩容在小时级别的时间内完成。最后，高德还实现了计算优化，提供了人员在线值守等保障。下图同时展示了高德在2018年10月2日的系统计算水位，蓝线代表的“系统配额水位”远高于9月2日的，说明集群扩容工作已顺利完成。同时，黄色代表的“实际资源配额水位”已完全被蓝线cover，更好地保障了资源计算任务。此外，黄色高峰被明显打散，一些重要非核心数据被错峰调度到7点，说明计算资源的错峰调度工作也已顺利完成。阿里云提供的一键运维调度工具能够保证系统方便的进行调度错峰，节省人力。MaxCompute为高德带来的弹性能力使得高德于2018年10月2日实现了核心数据“3点产出”的骄人成果。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;image&quot; src=&quot;https://yqfile.alicdn.com/f11085fe65b45599aae50d9a42049b3084067efb.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;业务成果&lt;/p&gt;
&lt;p&gt;下图展示了中国的路网覆盖图，华东、华北和华南地区基本实现了道路全网覆盖，西部等偏远地区的道路交通还不够发达，许多道路仍在建设。路网覆盖对高德而言非常重要，高德需要用尽可能少的成本自动地发掘新路和过期路。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;image&quot; src=&quot;https://yqfile.alicdn.com/1423a7e9005adee2e1fe87c08f555a25153c09c4.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;高德将轨迹数据资产和地图建设能力结合起来构建轨迹热力图，辅以现有路网和数据挖掘算法以自动化地发现新路和过期路。此外，高德还结合区域通车流量和该区域相关的用户上报事件来动态地发现封路、交通事件，更好地实现路网挖掘。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;image&quot; src=&quot;https://yqfile.alicdn.com/3fb7888ba5addbd3db069fc7d87fef65b1ea08f8.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;路况预测是高德的另一个重要业务，即实时预测道路的通车状况、道路是否拥堵等。左图展示了高德对右图路段从早到晚的平均车速预测，红线表示数据累计得到的历史均值，蓝线表示模型预测值，黑线表示真实数据值。蓝线和黑线基本重合，有力地说明了高德应用的数据挖掘能力和统一数据仓库建设取得的成果。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;image&quot; src=&quot;https://yqfile.alicdn.com/5cbf019eda4d1ba0ff11fe628b9623d1375ba9f1.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此外，高德还面向全网用户开放了一个城市级数据产品，允许用户随时查看城市的道路拥堵状况和城市拥堵指数等相关数据，该产品可在&lt;a href=&quot;http://report.amap.com/&quot;&gt;http://report.amap.com/&lt;/a&gt; 页面访问。下图显示了该产品给出的北京北二环某路段一周内的拥堵状况。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;image&quot; src=&quot;https://yqfile.alicdn.com/5bbc4a41e53e2eb581c62d764a44a803d0f635aa.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;三、未来展望&lt;/p&gt;
&lt;p&gt;技“数”高德表达了高德的未来规划。作为一家数据公司，高德致力于丰富数据源、优化SPA数据结构，得到更强大的数据平台，为用户提供更优秀的出现工具。从企业责任出发，高德希望能通过自身努力，帮助社会智能化地解决交通拥堵问题。从应用生态出发，高德希望能够帮助生态建立更加场景化的LBS服务，共同打造更专业的位置服务应用。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;image&quot; src=&quot;https://yqfile.alicdn.com/b3e4453502878d1c2f725e6525f90427c862da22.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p data-spm-anchor-id=&quot;a2c4e.11153940.blogcont689240.i1.17bb4175oIcLAN&quot;&gt;高德致力于在未来继续联手阿里云，实现“连接真实世界，让出行更美好！”的行业愿景。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;a href=&quot;https://yq.aliyun.com/articles/689240?utm_content=g_1000041593#&quot; target=&quot;_blank&quot;&gt;原文链接&lt;/a&gt;&lt;br/&gt;本文为云栖社区原创内容，未经允许不得转载。&lt;/p&gt;
</description>
<pubDate>Mon, 18 Feb 2019 06:42:00 +0000</pubDate>
<dc:creator>阿里云云栖社区</dc:creator>
<og:description>2019年1月18日，由阿里巴巴 MaxCompute 开发者社区和阿里云栖社区联合主办的“阿里云栖开发者沙龙大数据技术专场”走近北京联合大学，本次技术沙龙上，高德数据技术专家苗翌</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yunqishequ/p/10395541.html</dc:identifier>
</item>
<item>
<title>定时器2的使用 - 一个人的朝圣</title>
<link>http://www.cnblogs.com/juzige/p/10394976.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/juzige/p/10394976.html</guid>
<description>&lt;h2 id=&quot;h&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;52单片机比51单片机不只是在容量上提升，还多一个定时器2。定时器 T2的功能比 T1、T0都强大，但描述它的资料不多， 可能是使用得比较少的缘故吧。但好用的东西怎样放过，下面来盘盘定时器2。&lt;/p&gt;
&lt;h2 id=&quot;h-1&quot;&gt;概述&lt;/h2&gt;
&lt;p&gt;定时器 T2是一个 16 位的具有自动重装和捕获能力的定时 / 计数器，它的计数时钟源可以是内部的机器周期，也可以是 P1.0 输入的外部时钟脉冲。它由两个寄存器控制，他们是寄存器 T2CON,寄存器T2MOD。内部还有一个陷阱寄存器（ RCAPXL,PXAPXH）与之相关。T2定时器有三种工作模式，分别是捕获，自动重装和波特率发生器。&lt;/p&gt;
&lt;h2 id=&quot;h-2&quot;&gt;寄存器介绍&lt;/h2&gt;
&lt;h3 id=&quot;h2t2con&quot;&gt;定时器2控制寄存器T2CON&lt;/h3&gt;
&lt;p&gt;定时器2控制寄存器T2CON是定时器2的设置寄存器，用来设定与定时器2的一些相关操作。字节地址位C8H，可位寻址。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;定时器2控制寄存器T2CON&quot; src=&quot;https://img-blog.csdnimg.cn/20190216161406463.png&quot; alt=&quot;定时器2控制寄存器T2CON&quot;/&gt;定时器2控制寄存器T2CON&lt;br/&gt;&lt;strong&gt;TF2&lt;/strong&gt;：定时/ 计数器 2 溢出标志，T2溢出时置位， 并申请中断。 &lt;strong&gt;只能用软件清除&lt;/strong&gt;&lt;br/&gt;但 T2 作为波特率发生器使用的时候， ( 即 RCLK=1或 TCLK=1),T2溢出时不对 TF2置位。&lt;br/&gt;&lt;strong&gt;EXF2&lt;/strong&gt;：当 EXEN2=1时，且 T2EX引脚（P1.0）出现负跳变而造成 T2的捕获或重装&lt;br/&gt;的时候， EXF2置位并申请中断。 &lt;strong&gt;EXF2也是只能通过软件来清除的&lt;/strong&gt;。&lt;br/&gt;&lt;strong&gt;RCLK&lt;/strong&gt;：串行接收时钟标志， 只能通过软件的置位或清除； 用来选择 T1（RCLK=0 ）还是 T2（RCLK=1 ）来作为串行接收的波特率产生器&lt;br/&gt;&lt;strong&gt;TCLK&lt;/strong&gt;：串行发送时钟标志， 只能通过软件的置位或清除； 用来选择 T1（TCLK=0 ）&lt;br/&gt;还是 T2（TCLK=1 ）来作为串行发送的波特率产生器&lt;br/&gt;&lt;strong&gt;EXEN2&lt;/strong&gt; ：T2的外部允许标志，只能通过软件的置位或清除； EXEN2=0 ：禁止外部&lt;br/&gt;时钟触发 T2；EXEN2=1 ：当 T2未用作串行波特率发生器时，允许外部时钟触发 T2，当 T2EX引脚输入一个负跳变的时候，将引起 T2的捕获或重装，并置位 EXF2，申请中断。&lt;br/&gt;&lt;strong&gt;TR2&lt;/strong&gt;：T2的启动控制标志； TR2=0：停止 T2；TR2=1：启动 T2&lt;br/&gt;&lt;strong&gt;C/T2&lt;/strong&gt;：T2 的定时方式或计数方式选择位。 只能通过软件的置位或清除； C/T2=0 ：&lt;br/&gt;选择 T2 为定时器方式； C/T2=1 ：选择 T2 为计数器方式， 下降沿触发。&lt;br/&gt;&lt;strong&gt;CP/RT2&lt;/strong&gt; ：捕获/重装载标志，只能通过软件的置位或清除。 CP/RT2=0 时，选择重装载方式，这时若 T2 溢出（ EXEN2=0 时）或者 T2EX 引脚（P1.0）出现负跳变（EXEN2=1 时），将会引起 T2 重装载； CP/RT2=1 时，选择捕获方式，这时若 T2EX 引脚（ P1.0）出现负跳变（ EXEN2=1 时），将会引起 T2 捕获操作。但是如果 RCLK=1 或 TCLK=1 时，CP/RT2 控制位不起作用的，被强制工作于定时器溢出自动重装载模式。&lt;/p&gt;

&lt;p&gt;工作模式设置图如下，x表示无效，无论高低电平。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;工作模式设置&quot; src=&quot;https://img-blog.csdnimg.cn/20190216161857729.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQyNTU0NA==,size_16,color_FFFFFF,t_70&quot; alt=&quot;工作模式设置&quot;/&gt;工作模式设置&lt;/p&gt;
&lt;h3 id=&quot;h2t2mod&quot;&gt;定时器2控制寄存器T2MOD&lt;/h3&gt;
&lt;p&gt;定时器2控制寄存器T2MOD用来设定定时器2自动重转模式递增或递减模式，字节地址为C9H, &lt;strong&gt;不可位寻址，且可能在头文件没有定义，需要自行定义。&lt;/strong&gt;--表示保留未使用。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;定时器2控制寄存器T2MOD&quot; src=&quot;https://img-blog.csdnimg.cn/20190216162234433.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQyNTU0NA==,size_16,color_FFFFFF,t_70&quot; alt=&quot;定时器2控制寄存器T2MOD&quot;/&gt;定时器2控制寄存器T2MOD&lt;br/&gt;&lt;strong&gt;T2OE&lt;/strong&gt; ：T2 输出允许位，当 T2OE=1 的时候，允许时钟输出到 P1.0。（仅对&lt;br/&gt;80C54/80C58 有效）&lt;br/&gt;&lt;strong&gt;DCEN&lt;/strong&gt;：向下计数允许位。 DCEN=1 是允许 T2 向下计数，否则向上计数。&lt;/p&gt;

&lt;h2 id=&quot;h-3&quot;&gt;自动重装模式&lt;/h2&gt;
&lt;p&gt;这个工作模式与8位自动重装一样，只是定时器2是16位。还有功能更加强大。可以是正常的递增计数，也可以是递减计数。递增递减控制位位于寄存器T2MOD的DCEN位。下图是自动重装模式逻辑图。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;自动重装模式&quot; src=&quot;https://img-blog.csdnimg.cn/20190216180206973.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQyNTU0NA==,size_16,color_FFFFFF,t_70&quot; alt=&quot;自动重装模式&quot;/&gt;自动重装模式&lt;br/&gt;TH2,TL2构成16位加1计数器&lt;br/&gt;RCAP2H,RCAP2L构成16位初值寄存器&lt;br/&gt;T2EX引脚即P1.0引脚&lt;br/&gt;当定时器 2 工作于 16 位自动重装载方式时，能对其编程为向上或向下计数方式， 这个功能可通过特殊功能寄存器 T2MOD的 DCEN 位（允许向下计数）来选择的。复位时， DCEN 位置“ 0”，定时器 2 默认设置为向上计数。(递增计数)当 DCEN置位时，定时器 2 既可向上计数也可向下计数，这取决于 T2EX （P1.1）引脚的值。当 DCEN=0 时，定时器 2 自动设置为向上计数，在这种方式下， T2CON 中的 EXEN2 控制位有两种选择，若 EXEN2=0，定时器 2 为向上计数至 0FFFFH （65535）溢出，置位 TF2 激活中断，同时把 16 位计数寄存器 RCAP2H 和 RCAP2L重装载， RCAP2H 和 RCAP2L 的值&lt;strong&gt;软件预置&lt;/strong&gt;。若 EXEN2=1，定时器 2 的 16 位重装载由溢出或外部输入端 T2EX 从 1 至0 的下降沿触发。这个脉冲使 EXF2 置位，如果中断允许，同样产生中断。&lt;br/&gt;当 DCEN=1 时，允许定时器 2 向上或向下计数，这种方式下， T2EX 引脚控制计数器方向。 T2EX 引脚为逻辑“ 1”时，定时器向上计数，当计数 0FFFFH 向上溢出时，置位 TF2，同时把 16 位计数寄存器RCAP2H 和 RCAP2L重装载到 TH2 和 TL2 中。 T2EX 引脚为逻辑“ 0”时，定时器 2 向下计数， 当 TH2 和 TL2 中的数值等于 RCAP2H 和RCAP2L中的值时，计数溢出，置位 TF2，同时将 0FFFFH 数值重新装入定时寄存器中。&lt;br/&gt;当定时 / 计数器 2 向上溢出或向下溢出时，&lt;strong&gt;置位 EXF2 位&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;寄存器，原理都说完，只差实战。&lt;/p&gt;
&lt;h2 id=&quot;h-4&quot;&gt;示例&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs cpp&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-meta-keyword&quot;&gt;include&lt;span class=&quot;hljs-meta-string&quot;&gt;&amp;lt;reg52.h&amp;gt;&lt;br/&gt;sbit led=P1^&lt;span class=&quot;hljs-number&quot;&gt;1;        &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;本程序讲解定时器2，16位自动重装模式，只是简单示范如何操作，更多其他功能就不展示，希望能融会贯通，解锁更多新技能。&lt;/p&gt;
&lt;h2 id=&quot;h-5&quot;&gt;捕获模式&lt;/h2&gt;
&lt;p&gt;介绍捕获模式前，先看一下捕获的意思。&lt;strong&gt;捕获&lt;/strong&gt; ，就是捕捉某一瞬间的值。这个模式通常是用来测量外部某个脉冲的的宽度或周期。使用捕获功能可以非常准确测量出脉冲宽度或周期。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;捕获模式&quot; src=&quot;https://img-blog.csdnimg.cn/201902162135315.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQyNTU0NA==,size_16,color_FFFFFF,t_70&quot; alt=&quot;捕获模式&quot;/&gt;捕获模式&lt;/p&gt;
&lt;h3 id=&quot;h-6&quot;&gt;工作原理&lt;/h3&gt;
&lt;p&gt;在捕获模式下，定时器计数，当与捕获功能相关的引脚产生负跳变时（P1.1），捕获会会立即将计数器寄存器中的数值准确的获取，并且存入陷阱寄存器（RCAPXH,RCAPXL），同时向CPU申请中断，方便软件记录。当该引脚产生下一次负跳变，便会产生另一个捕获，再次向CPU申请中断，软件记录两次数据，便可得出脉冲周期。&lt;/p&gt;
&lt;h3 id=&quot;h-7&quot;&gt;使用&lt;/h3&gt;
&lt;p&gt;在捕获方式下，通过 T2CON 控制位 EXEN2 来选择两种方式。如果EXEN2=0，定时器 2 是一个 16 位定时器或计数器， 计数溢出时， 对 T2CON 的溢出标志 TF2 置位，同时激活中断。如果 EXEN2=1，定时器 2 完成相同的操作，而当 T2EX(P1.1) 引脚外部输入信号发生 1 至 0 负跳变时，也出现 TH2 和TL2 中的值分别被捕获到 RCAP2H 和 RCAP2L 中。另外， T2EX 引脚信号的跳变使得 T2CON 中的 EXF2 置位，与 TF2 相仿， EXF2 也会激活中断。&lt;/p&gt;
&lt;h3 id=&quot;h-8&quot;&gt;示例&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs cs&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#include&amp;lt;reg52.h&amp;gt;&lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-meta-keyword&quot;&gt;define uchar unsigned char &lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-meta-keyword&quot;&gt;define uint unsigned int&lt;br/&gt;uchar flag=&lt;span class=&quot;hljs-number&quot;&gt;0;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;uint high,low,&lt;span class=&quot;hljs-keyword&quot;&gt;value;      &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;h-9&quot;&gt;波特率发生器模式&lt;/h2&gt;
&lt;p&gt;&lt;img title=&quot;波特率发生器模式逻辑结构&quot; src=&quot;https://img-blog.csdnimg.cn/20190218113946933.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQyNTU0NA==,size_16,color_FFFFFF,t_70&quot; alt=&quot;波特率发生器模式逻辑结构&quot;/&gt;波特率发生器模式逻辑结构&lt;br/&gt;当 T2CON 中的 TCLK 和 RCLK 置位时，定时 / 计数器 2 作为 波特率发生器使用。如果定时 / 计数器 2 作为发送器或接收器，其发送和接收的波特率&lt;strong&gt;可以是不同的&lt;/strong&gt;。&lt;br/&gt;TCLK 置位，则定时器 2 工作于 波特率发生器 方式。波特率发生器的方式与自动重装载方式相仿，在此方式下， TH2 翻转使定时器 2 的寄存器用 RCAP2H 和 RCAP2L 中的 16 位数值重新装载，&lt;strong&gt;该数值由软件设置。&lt;/strong&gt;&lt;br/&gt;当定时器配置为计数方式时，外部时钟信号由T2引脚进入。在方式 1 和方式 3 中，波特率由定时器 2 的溢出速率根据下式确定：&lt;br/&gt;&lt;strong&gt;方式 1 和 3 的波特率 =定时器的溢出率 /16&lt;/strong&gt;&lt;img title=&quot;波特率&quot; src=&quot;https://img-blog.csdnimg.cn/20190218120247277.png&quot; alt=&quot;波特率&quot;/&gt;波特率&lt;br/&gt;定时器既能工作于定时方式也能工作于计数方式，在大多数的应用中，是工作在定时方式（ C/T2=0）。定时器 2 作为波特率发生器时，与作为定时器的操作是不同的，通常作为定时器时，在每个机器周期（ 1/12 振荡频率）寄存器的值加 1，而作为波特率发生器使用时， 在每个状态时间 （1/2 振荡频率）寄存器的值加 1。波特率的计算公式如下：&lt;br/&gt;方式 1 和 3 的波特率 =振荡频率 /{32*[65536-(RCP2H,RCP2L)]}&lt;img title=&quot;波特率&quot; src=&quot;https://img-blog.csdnimg.cn/20190218120434208.png&quot; alt=&quot;波特率&quot;/&gt;波特率&lt;br/&gt;式中（RCAP2H ，RCAP2L）是 RCAP2H和 RCAP2L中的 &lt;strong&gt;16 位无符号数&lt;/strong&gt;。&lt;br/&gt;T2CON 中的RCLK 或 TCLK=1 时，波特率工作方式才有效。 在波特率发生器工作方式中，TH2 翻转不能使 TF2 置位，故而不产生中断。 但若 EXEN2 置位，且 T2EX 端产生由 1 至 0 的负跳变，则会使 EXF2 置位，此时并不能将 （RCAP2H，RCAP2L）的内容重新装入 TH2 和 TL2 中。所以，当定时器 2 作为波特率发生器使用时，T2EX 可作为附加的外部中断源来使用。&lt;br/&gt;&lt;strong&gt;需要注意的是&lt;/strong&gt;，当定时器 2 工作于波特率器时，作为定时器运行（ TR2=1）时，并不能访问 TH2 和 TL2。因为此时每个状态 时间定时器 都会加 1，对其读写将得到一个不确定的数值。然而，对 RCAP2 则可读而不可写，因为写入操作将是重新装载，写入操作可能令写和 / 或重装载出错。在访问定时器 2 或 RCAP2 寄存器之前，应将&lt;strong&gt;定时器关闭（清除 TR2）&lt;/strong&gt;。&lt;br/&gt;## 示例&lt;/p&gt;

&lt;pre&gt;
&lt;code class=&quot;hljs cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;UartInit&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;void)        &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;贴出波特率发生器模式初始化代码，需要什么功能自行添加。&lt;/p&gt;
&lt;h2 id=&quot;h-10&quot;&gt;结束语&lt;/h2&gt;
&lt;p&gt;定时器2的讲解结束，确实使用比定时器0，1稍微困难，但它功能强大，能解决很多问题。在定时器不够用的情况下，定时器2不失为一个好的备用方案。&lt;/p&gt;
</description>
<pubDate>Mon, 18 Feb 2019 04:58:00 +0000</pubDate>
<dc:creator>一个人的朝圣</dc:creator>
<og:description>前言 52单片机比51单片机不只是在容量上提升，还多一个定时器2。定时器 T2的功能比 T1、T0都强大，但描述它的资料不多， 可能是使用得比较少的缘故吧。但好用的东西怎样放过，下面来盘盘定时器2。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/juzige/p/10394976.html</dc:identifier>
</item>
<item>
<title>JavaScript与WebAssembly进行比较 - 腾讯云+社区</title>
<link>http://www.cnblogs.com/qcloud1001/p/10394744.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qcloud1001/p/10394744.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;本文由云+社区发表&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;作者：QQ音乐前端团队&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在识别和描述核心元素的过程中，我们分享了构建SessionStack时使用的一些经验法则，这是一个轻量级但健壮且高性能的JavaScript应用程序，以帮助用户实时查看和重现其Web应用程序的缺陷。&lt;/p&gt;
&lt;p&gt;这次我们来分析WebAssembly的工作原理，以及在如下几个方面和JavaScript进行比较：加载时间，执行速度，垃圾回收，内存使用情况，平台API访问，调试，多线程和可移植性。&lt;/p&gt;
&lt;h2 id=&quot;webassembly的功能&quot;&gt;WebAssembly的功能&lt;/h2&gt;
&lt;p&gt;WebAssembly（又名wasm）是一种高效的，低级别的编程语言。 它让我们能够使用JavaScript以外的语言（例如C，C ++，Rust或其他）编写程序，然后将其编译成WebAssembly，进而生成一个加载和执行速度非常快的Web应用程序。&lt;/p&gt;
&lt;h2 id=&quot;加载时间&quot;&gt;加载时间&lt;/h2&gt;
&lt;p&gt;为了加载JavaScript，浏览器必须加载所有.js文本文件。 WebAssembly在浏览器中加载速度更快，因为只有已编译的wasm文件才通过互联网传输。并且wasm是一种非常简洁的二进制格式的低级汇编语言，文件更小。&lt;/p&gt;
&lt;h2 id=&quot;执行&quot;&gt;执行&lt;/h2&gt;
&lt;p&gt;目前Wasm 比本地代码执行速度慢20％。这倒是一个令人吃惊的结果，不过，这是一种编译到沙盒环境中的格式并且在很多约束条件下运行，以确保它没有安全漏洞或者很难攻防这个漏洞。与真实的本地代码相比，其实速度下降很小。但是，未来它会更快。&lt;/p&gt;
&lt;p&gt;更好的是，它与浏览器无关 - 所有主要引擎都增加了对WebAssembly的支持，并且现在提供类似的执行时间。我们来看看简单看看V8中发生了什么：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/1034093/wlil93ajlu.jpeg?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;v8-approach-lazy-compilation&quot;&gt;V8 Approach: lazy compilation&lt;/h3&gt;
&lt;p&gt;在左边，我们有一些JavaScript源代码，包含JavaScript函数。它首先需要进行分析，以便将所有字符串转换为标记并生成抽象语法树（AST）。AST是JavaScript程序逻辑的内存表示。一旦生成这种表示，V8直接转到机器码。一般来说，只需要遍历树，生成机器代码，便生成了编译好的函数。从这个过程可以看出，这个阶段并没有编译速度的优势。 现在，我们来看看V8管道在下一阶段的功能：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/1034093/7gfd7ra84h.png?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;v8管道设计&quot;&gt;V8管道设计&lt;/h3&gt;
&lt;p&gt;这次我们有TurboFan，V8的优化编译器之一。当您的JavaScript应用程序正在运行时，很多代码在V8中运行。TurboFan可以监控运行缓慢的内容，是否存在瓶颈和热点以优化它们。它将它们推送到后端，这是一个优化的JIT，它可以优化那些非常耗cpu的代码。 虽然它解决了上述问题，但是新的问题在于：分析代码并决定优化哪些内容的过程也会消耗CPU。这反过来又意味着更高的电池消耗，特别是在移动设备上。 然而，wasm不一样在于，它会被插入工作流程中，如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/1034093/rkzo4jgavg.jpeg?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;内存模型&quot;&gt;内存模型&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/1034093/q0ib2jlgqb.jpeg?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;WebAssembly可信和不可信状态 例如，编译成WebAssembly的C ++程序的内存是连续的内存块，其中没有“漏洞”。有助于提高安全性的wasm的特性之一是执行堆栈与线性内存分离的概念。在一个C ++程序中，你有一个内存堆，你从堆的底部分配，然后从堆顶增涨堆大小。这便产生一个很多恶意软件利用的漏洞：用一个指针就可以在堆栈内存中查找数据从而更改变量，而这些数据本是你不应该访问到的。&lt;/p&gt;
&lt;p&gt;WebAssembly采用完全不同的模型。执行堆栈与WebAssembly程序本身是分开的，因此您无法在其中修改并更改变量等内容。而且，这些函数使用整数偏移而不是指针。函数指向一个间接函数表。然后这些直接计算的数字跳转到模块内部的函数中。它是以这种方式构建的，以便您可以同时加载多个wasm模块，形成多个索引列表，并且一切正常。 有关JavaScript中内存模型和管理的更多信息，可以查看关于该主题的非常详细的帖子。&lt;/p&gt;
&lt;h2 id=&quot;垃圾回收&quot;&gt;垃圾回收&lt;/h2&gt;
&lt;p&gt;您已经知道JavaScript的内存管理是使用垃圾回收器处理的。&lt;/p&gt;
&lt;p&gt;WebAssembly的情况有点不同。它支持手动管理内存的语言。您可以自定义在WASM上的垃圾回收模块，但是这个比较复杂。&lt;/p&gt;
&lt;p&gt;目前，WebAssembly是围绕C ++和RUST用例设计的。由于wasm是非常低级的，因此只有汇编语言上一步的编程语言才易于编译。C可以使用普通的malloc，C ++可以使用智能指针，Rust使用完全不同的模式（完全不同的主题）。这些语言不使用GC，因此它们不需要所有复杂的运行时内容来跟踪内存。WebAssembly对他们来说是天作之合。&lt;/p&gt;
&lt;p&gt;另外，这些语言并不是100％设计用于调用复杂的JavaScript事物，如DOM。在C ++中编写整个HTML应用程序是没有意义的，因为C ++不是为它设计的。在大多数情况下，当工程师编写C ++或Rust时，他们的目标是WebGL或高度优化的库（例如重数学计算）。&lt;/p&gt;
&lt;p&gt;但是，将来WebAssembly将支持不附带GC的语言。&lt;/p&gt;
&lt;h2 id=&quot;平台api访问&quot;&gt;平台API访问&lt;/h2&gt;
&lt;p&gt;取决于执行JavaScript的运行时，可以通过你的JavaScript应用程序来访问平台相关的API。例如，如果您在浏览器中运行JavaScript，则您有一组Web APIs，Web应用程序可以调用它来控制Web浏览器/设备功能并访问DOM, CSSOM, WebGL, IndexedDB, Web Audio API等。&lt;/p&gt;
&lt;p&gt;然而，WebAssembly模块无法访问任何平台API。一切都是由JavaScript调用的。如果您想访问WebAssembly模块中的某些平台特定的API，则必须通过JavaScript调用它。&lt;/p&gt;
&lt;p&gt;例如，如果你想console.log，你必须通过JavaScript来调用它，而不是你的C ++代码。这些JavaScript调用的成本有所降低。&lt;/p&gt;
&lt;p&gt;这并不总是如此。该规范将在未来为平台API提供wasm，并且您将能够在没有JavaScript的情况下发布您的应用程序。&lt;/p&gt;
&lt;h2 id=&quot;source-maps&quot;&gt;Source maps&lt;/h2&gt;
&lt;p&gt;当您精简JavaScript源代码时，您需要一种正确方式调试它。这就需要Source Maps。基本上， Source Maps 是一种将组合/缩小文件映射回未建立状态的方法。当您为生产而构建时，同时缩小和组合您的JavaScript文件，您将生成一个包含原始文件信息的源映射。当您在生成的JavaScript中查询某一行和列号时，可以在返回原始位置的源地图中执行查找。&lt;/p&gt;
&lt;p&gt;WebAssembly目前不支持source maps，因为没有规范，但最终会支持（可能很快）。 当您在C ++代码中设置断点时，您将看到C ++代码而不是WebAssembly。&lt;/p&gt;
&lt;h2 id=&quot;多线程&quot;&gt;多线程&lt;/h2&gt;
&lt;p&gt;JavaScript在单个线程上运行。有很多方法可以利用Event Loop并利用异步编程。&lt;/p&gt;
&lt;p&gt;JavaScript也使用Web Workers，但他们有一个非常具体的用例 - 基本上，可能阻塞主UI线程的任何CPU密集计算都可以进入到Web Worker中来提高性能。但是，Web Workers无法访问DOM。&lt;/p&gt;
&lt;p&gt;WebAssembly目前不支持多线程。但是，这可能是未来的事情。Wasm将更接近本地线程（例如C ++样式线程）。拥有“真实”的线程将在浏览器中创造出许多新的机会。当然，这将打开更多滥用可能性的大门。&lt;/p&gt;
&lt;h2 id=&quot;可移植性&quot;&gt;可移植性&lt;/h2&gt;
&lt;p&gt;如今，JavaScript几乎可以在任何地方运行，从浏览器到服务器端甚至嵌入式系统。&lt;/p&gt;
&lt;p&gt;WebAssembly被设计为安全和便携。就像JavaScript一样。它将运行在支持主机的每个环境中（例如每个浏览器）。就像当年的Java的Applets，WebAssembly有相同的可移植性的愿景。&lt;/p&gt;
&lt;h2 id=&quot;哪些场景更合适使用wa&quot;&gt;哪些场景更合适使用WA&lt;/h2&gt;
&lt;p&gt;在WebAssembly的第一个版本中，主要关注CPU占用大的计算（例如处理数学）。想到的最主流的用途是游戏 - 那里有大量的像素操作。您可以使用您习惯的OpenGL在C ++ / Rust中编写您的应用程序，并将其编译为wasm。它会在浏览器中运行。 看看这个（在Firefox中运行）&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://s3.amazonaws.com/mozilla-games/tmp/2017-02-21-SunTemple/SunTemple.html&quot; class=&quot;uri&quot;&gt;http://s3.amazonaws.com/mozilla-games/tmp/2017-02-21-SunTemple/SunTemple.html&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;这是 Unreal engine.。&lt;/p&gt;
&lt;p&gt;另一种使用WebAssembly（性能方面）可能有意义的情况是实现一些库，这是一个CPU密集型工作。例如，一些图像处理。&lt;/p&gt;
&lt;p&gt;如前所述，由于大多数处理步骤都是在编译期间提前完成的，因此wasm可以减少移动设备上的电池消耗（取决于引擎）。&lt;/p&gt;
&lt;p&gt;将来，即使您实际上没有编写编译代码，您也可以使用WASM二进制文件。您可以在NPM中找到开始使用此方法的项目。&lt;/p&gt;
&lt;p&gt;对于DOM操作和沉重的平台API使用，使用JavaScript确实很有意义，因为它不会增加额外的开销，并且具有本地提供的API。&lt;/p&gt;
&lt;p&gt;在SessionStack中，我们不断增强JavaScript的性能，以编写高度优化且高效的代码。我们的解决方案需要提供超快的性能，因为我们不能阻碍客户应用的性能。将SessionStack集成到生产Web应用程序或网站后，它会开始记录所有内容：所有DOM更改，用户交互，JavaScript异常，堆栈跟踪，失败的网络请求和调试数据。所有这些都在您的生产环境中进行，而不会影响产品的任何UX和性能。我们需要大量优化我们的代码并尽可能使其异步。&lt;/p&gt;
&lt;p&gt;不仅仅是库文件，当在SessionStack中重放用户回话时，我们会渲染用户浏览器中发生的所有事件，并且我们必须重构整个状态，允许您在会话时间线中来回跳转。因为没有更好的选择，为了做到这一点，我们大量使用了JavaScript提供的异步机会。&lt;/p&gt;
&lt;p&gt;借助WebAssembly，我们将能够将一些最繁重的处理和渲染转换为更适合作业的语言，并将数据收集和DOM操作保留为JavaScript。&lt;/p&gt;
&lt;p&gt;如果你想尝试下SessionStack，你可以免费开始。有一个免费的计划)，每月提供1000个会话。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/1034093/0c04dxwr43.jpeg?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;参考:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;此文已由腾讯云+社区在各渠道发布&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;获取更多新鲜技术干货，可以关注我们&lt;a href=&quot;https://www.zhihu.com/org/teng-xun-yun-ji-zhu-she-qu/activities&quot;&gt;腾讯云技术社区-云加社区官方号及知乎机构号&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 18 Feb 2019 03:51:00 +0000</pubDate>
<dc:creator>腾讯云+社区</dc:creator>
<og:description>本文由云+社区发表 作者：QQ音乐前端团队 在识别和描述核心元素的过程中，我们分享了构建SessionStack时使用的一些经验法则，这是一个轻量级但健壮且高性能的JavaScript应用程序，以帮助</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qcloud1001/p/10394744.html</dc:identifier>
</item>
<item>
<title>如何为ASP.NET Core设置客户端IP白名单验证 - LamondLu</title>
<link>http://www.cnblogs.com/lwqlun/p/10394688.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lwqlun/p/10394688.html</guid>
<description>&lt;blockquote readability=&quot;2.7222222222222&quot;&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;https://docs.microsoft.com/en-us/aspnet/core/security/ip-safelist?view=aspnetcore-2.2&quot;&gt;Client IP safelist for ASP.NET Core&lt;/a&gt;&lt;br/&gt;作者：&lt;a href=&quot;https://twitter.com/damien_bod&quot;&gt;Damien Bowden&lt;/a&gt; and &lt;a href=&quot;https://github.com/tdykstra&quot;&gt;Tom Dykstra&lt;/a&gt;&lt;br/&gt;译者：Lamond Lu&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201902/65831-20190218114153911-847402652.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;本篇博文中展示了如何在ASP.NET Core应用程序中设置IP白名单验证的3种方式。&lt;/p&gt;
&lt;p&gt;你可以使用一下3种方式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用中间件检查每个请求的远程IP地址&lt;/li&gt;
&lt;li&gt;使用Action过滤器为指定的Controller或action方法添加针对远程IP地址的检查&lt;/li&gt;
&lt;li&gt;使用IPageFilter为Razor Pages应用添加针对远程IP地址的检查&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/aspnet/Docs/tree/master/aspnetcore/security/ip-safelist/samples/2.x/ClientIpAspNetCore&quot;&gt;查看项目源代码&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这里为了简化代码，我们将IP白名单列表放置在配置文件appSettings.json中，每个IP之间使用分号分隔。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;正式项目中，可以将这个列表保存在数据库中，便于管理&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
  &quot;AdminSafeList&quot;: &quot;127.0.0.1;192.168.1.5;::1&quot;,
  &quot;Logging&quot;: {
    &quot;IncludeScopes&quot;: false,
    &quot;LogLevel&quot;: {
      &quot;Default&quot;: &quot;Debug&quot;,
      &quot;System&quot;: &quot;Information&quot;,
      &quot;Microsoft&quot;: &quot;Information&quot;
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;这里我们首先添加一个中间件&lt;code&gt;AdminSafeListMiddleware&lt;/code&gt;。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class AdminSafeListMiddleware
{
    private readonly RequestDelegate _next;
    private readonly ILogger&amp;lt;AdminSafeListMiddleware&amp;gt; _logger;
    private readonly string _adminSafeList;

    public AdminSafeListMiddleware(
        RequestDelegate next, 
        ILogger&amp;lt;AdminSafeListMiddleware&amp;gt; logger, 
        string adminSafeList)
    {
        _adminSafeList = adminSafeList;
        _next = next;
        _logger = logger;
    }

    public async Task Invoke(HttpContext context)
    {
        if (context.Request.Method != &quot;GET&quot;)
        {
            var remoteIp = context.Connection.RemoteIpAddress;
            _logger.LogDebug($&quot;Request from Remote IP address: {remoteIp}&quot;);

            string[] ip = _adminSafeList.Split(';');

            var bytes = remoteIp.GetAddressBytes();
            var badIp = true;
            foreach (var address in ip)
            {
                var testIp = IPAddress.Parse(address);
                if(testIp.GetAddressBytes().SequenceEqual(bytes))
                {
                    badIp = false;
                    break;
                }
            }

            if(badIp)
            {
                _logger.LogInformation(
                    $&quot;Forbidden Request from Remote IP address: {remoteIp}&quot;);
                context.Response.StatusCode = (int)HttpStatusCode.Forbidden;
                return;
            }
        }

        await _next.Invoke(context);

    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;代码解释：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;这里在&lt;code&gt;AdminSafeListMiddleware&lt;/code&gt;的构造函数中，我们传入了从配置文件中读取的IP白名单列表&lt;/li&gt;
&lt;li&gt;当请求进入当前中间件时，我们使用当前请求上下文的&lt;code&gt;context.Connection.RemoteIpAddress&lt;/code&gt;获取到了客户端的IP&lt;/li&gt;
&lt;li&gt;如果客户端IP存在于IP白名单列表中，就运行下一个中间件，否则就直接返回401状态码。&lt;/li&gt;
&lt;li&gt;这里源代码中，只过滤了非GET请求，如果针对GET请求也需要启动IP白名单，可以去掉这个判断。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;然后我们需要在Startup.cs文件的&lt;code&gt;Configure&lt;/code&gt;方法中将中间件添加到ASP.NET Core的中间件管道中。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public void Configure(
    IApplicationBuilder app, 
    IHostingEnvironment env, 
    ILoggerFactory loggerFactory)
{
    loggerFactory.AddNLog();

    app.UseStaticFiles();

    app.UseMiddleware&amp;lt;AdminSafeListMiddleware&amp;gt;(
        Configuration[&quot;AdminSafeList&quot;]);
    app.UseMvc();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意： 这里我们在注册中间件的时候，传入了从配置文件中读取的IP白名单。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如果你只是希望为某些特性的Controller或Action方法添加IP白名单，你可以使用Action过滤器。&lt;/p&gt;
&lt;p&gt;这里我们首先添加一个新类&lt;code&gt;ClientIdCheckFilter&lt;/code&gt;, 它继承自&lt;code&gt;ActionFilterAttribute&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt; public class ClientIdCheckFilter : ActionFilterAttribute
    {
        private readonly ILogger _logger;
        private readonly string _safelist;

        public ClientIdCheckFilter
            (ILoggerFactory loggerFactory, IConfiguration configuration)
        {
            _logger = loggerFactory.CreateLogger(&quot;ClientIdCheckFilter&quot;);
            _safelist = configuration[&quot;AdminSafeList&quot;];
        }

        public override void OnActionExecuting(ActionExecutingContext context)
        {
            _logger.LogInformation(
                $&quot;Remote IpAddress: {context.HttpContext.Connection.RemoteIpAddress}&quot;);

            var remoteIp = context.HttpContext.Connection.RemoteIpAddress;
            _logger.LogDebug($&quot;Request from Remote IP address: {remoteIp}&quot;);

            string[] ip = _safelist.Split(';');

            var bytes = remoteIp.GetAddressBytes();
            var badIp = true;
            foreach (var address in ip)
            {
                var testIp = IPAddress.Parse(address);
                if (testIp.GetAddressBytes().SequenceEqual(bytes))
                {
                    badIp = false;
                    break;
                }
            }

            if (badIp)
            {
                _logger.LogInformation(
                    $&quot;Forbidden Request from Remote IP address: {remoteIp}&quot;);
                context.Result = new StatusCodeResult(401);
                return;
            }

            base.OnActionExecuting(context);
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;这里代码逻辑和前面中间的基本一样，主要的区别是&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;这里我们是从IP白名单，我们是从&lt;code&gt;IConfiguration&lt;/code&gt;对象中手动获取的&lt;/li&gt;
&lt;li&gt;这里我们复写了&lt;code&gt;OnActionExecuting&lt;/code&gt;方法，如果当前客户端 IP存在于白名单中，我们就调用基类&lt;code&gt;OnActionExecuting&lt;/code&gt;方法，执行当前Action请求，否则就返回一个401状态码&lt;/li&gt;
&lt;li&gt;这里没有针对请求类型的判断，所以指定当前过滤器的Action，GET请求也会受到白名单的限制&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;第二步，我们需要将这action过滤器添加到服务容器中。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public void ConfigureServices(IServiceCollection services)
{
    services.AddScoped&amp;lt;ClientIdCheckFilter&amp;gt;();

    services.AddMvc(options =&amp;gt;
    {
        options.Filters.Add
            (new ClientIdCheckPageFilter
                (_loggerFactory, Configuration));
    }).SetCompatibilityVersion(CompatibilityVersion.Version_2_1);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第三步，我们可以在Action方法声明处添加&lt;code&gt;ServiceFilter&lt;/code&gt;特性，传入的参数是我们之前定义好的&lt;code&gt;ClientIdCheckFilter&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;[ServiceFilter(typeof(ClientIdCheckFilter))]
[HttpGet]
public IEnumerable&amp;lt;string&amp;gt; Get()&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;Razor Pages应用是ASP.NET Core 2.0中新引入的功能，它是ASP.NET Core Mvc的一个子集。&lt;/p&gt;
&lt;p&gt;如果希望Razor Pages应用支持IP白名单，我们需要创建一个新类&lt;code&gt;ClientIdCheckPageFilter&lt;/code&gt;, 它实现了&lt;code&gt;IPageFilter&lt;/code&gt;接口.&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class ClientIdCheckPageFilter : IPageFilter
    {
        private readonly ILogger _logger;
        private readonly string _safelist;

        public ClientIdCheckPageFilter
            (ILoggerFactory loggerFactory, IConfiguration configuration)
        {
            _logger = loggerFactory.CreateLogger(&quot;ClientIdCheckPageFilter&quot;);
            _safelist = configuration[&quot;AdminSafeList&quot;];
        }

        public void OnPageHandlerExecuting(PageHandlerExecutingContext context)
        {
            _logger.LogInformation(
                $&quot;Remote IpAddress: {context.HttpContext.Connection.RemoteIpAddress}&quot;);

            var remoteIp = context.HttpContext.Connection.RemoteIpAddress;
            _logger.LogDebug($&quot;Request from Remote IP address: {remoteIp}&quot;);

            string[] ip = _safelist.Split(';');

            var bytes = remoteIp.GetAddressBytes();
            var badIp = true;
            foreach (var address in ip)
            {
                var testIp = IPAddress.Parse(address);
                if (testIp.GetAddressBytes().SequenceEqual(bytes))
                {
                    badIp = false;
                    break;
                }
            }

            if (badIp)
            {
                _logger.LogInformation(
                    $&quot;Forbidden Request from Remote IP address: {remoteIp}&quot;);
                context.Result = new StatusCodeResult(401);
                return;
            }
        }

        public void OnPageHandlerExecuted(PageHandlerExecutedContext context)
        {
        }

        public void OnPageHandlerSelected(PageHandlerSelectedContext context)
        {
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;这里的代码实现和IActionFilter的实现基本一样，唯一的区别是代码放在了&lt;code&gt;OnPageHandlerExecuting&lt;/code&gt;的实现中。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;第二步，我们还是需要将&lt;code&gt;ClientIdCheckPageFilter&lt;/code&gt;添加到MVC的过滤器集合中。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public void ConfigureServices(IServiceCollection services)
{
    services.AddScoped&amp;lt;ClientIdCheckFilter&amp;gt;();

    services.AddMvc(options =&amp;gt;
    {
        options.Filters.Add
            (new ClientIdCheckPageFilter
                (_loggerFactory, Configuration));
    }).SetCompatibilityVersion(CompatibilityVersion.Version_2_1);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;本篇我们讲解了在ASP.NET Core中启用IP白名单验证的3种方式&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用中间件检查每个请求的远程IP地址&lt;/li&gt;
&lt;li&gt;使用Action过滤器为指定的Controller或action方法添加针对远程IP地址的检查&lt;/li&gt;
&lt;li&gt;使用IPageFilter为Razor Pages应用添加针对远程IP地址的检查&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Mon, 18 Feb 2019 03:42:00 +0000</pubDate>
<dc:creator>LamondLu</dc:creator>
<og:description>本篇博文中展示了如何在ASP.NET Core应用程序中设置IP白名单验证的3种方式。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lwqlun/p/10394688.html</dc:identifier>
</item>
<item>
<title>通用查询设计思想 - lex-wu</title>
<link>http://www.cnblogs.com/lex-wu/p/10389236.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lex-wu/p/10389236.html</guid>
<description>&lt;p&gt;　　一般来说所有的系统都离不开查询，通俗点说就是前后端交互。我们的系统无非都是通过实体的属性作为条件进行查询，那我们有什么方法可以拼装成类似sql中的where条件呢？在.Net的体系中，有个很好的东西叫做表达式（Expression），借助它我们可以将查询参数转化为表达式进行查询。&lt;/p&gt;
&lt;p&gt;　　为简单易懂，我这里简单创建一个产品类Product来说明：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Product
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Id {&lt;span&gt;get&lt;/span&gt;;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;;}
        
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Name {&lt;span&gt;get&lt;/span&gt;;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;;} 
         
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;decimal&lt;/span&gt; Price {&lt;span&gt;get&lt;/span&gt;;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;;}          

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;库存&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Stock {&lt;span&gt;get&lt;/span&gt;;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;;}
        
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Status Status {&lt;span&gt;get&lt;/span&gt;;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;;}
        
　　　　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建时间&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; DateTime CreationTime {&lt;span&gt;get&lt;/span&gt;;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;;} 
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt;&lt;span&gt; Status
    {
　　　　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在售&lt;/span&gt;
        OnSale = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;,

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;下架&lt;/span&gt;
        OffSale = &lt;span&gt;2&lt;/span&gt;&lt;span&gt;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　我们页面需要通过商品名，库存范围，状态和创建时间范围来作为条件查询指定的商品，这里我们先定义我们的查询类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ProductQuery&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Name {&lt;span&gt;get&lt;/span&gt;;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;;} 
         
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;最小库存&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; MinStock {&lt;span&gt;get&lt;/span&gt;;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;;}
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;最大库存&lt;/span&gt;        
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; MaxStock {&lt;span&gt;get&lt;/span&gt;;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;;}
        

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Status Status {&lt;span&gt;get&lt;/span&gt;;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;;}
        
　　　　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建开始时间&lt;/span&gt;        
        &lt;span&gt;public&lt;/span&gt; DateTime CreationStartTime {&lt;span&gt;get&lt;/span&gt;;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;;} 
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建结束时间&lt;/span&gt;        
        &lt;span&gt;public&lt;/span&gt; DateTime CreationEndTime {&lt;span&gt;get&lt;/span&gt;;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;;} 
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　有了查询类，一般的思想是通过if ...else... 来拼装条件进行查询，试想一下，如果查询条件很多的话，那我们岂不是要写很长的代码？这种流水式的代码正是我们要避免的。如何抽象化实现我们需要的功能呢？抓住我们开头说的重点，无非就是通过代码生成我们想要的表达式即可。如何生成，首先我们定义一个查询接口和它的实现&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　 ///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 定义查询参数
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;typeparam name=&quot;TEntity&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;要查询的实体类型&lt;/span&gt;&lt;span&gt;&amp;lt;/typeparam&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; IQuery&amp;lt;TEntity&amp;gt;
        &lt;span&gt;where&lt;/span&gt; TEntity : &lt;span&gt;class&lt;/span&gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 获取查询条件
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        Expression&amp;lt;Func&amp;lt;TEntity, &lt;span&gt;bool&lt;/span&gt;&amp;gt;&amp;gt;&lt;span&gt; GenerateExpression();
    }


    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 定义查询参数
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;typeparam name=&quot;TEntity&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;要查询的实体类型&lt;/span&gt;&lt;span&gt;&amp;lt;/typeparam&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Query&amp;lt;TEntity&amp;gt; : IQuery&amp;lt;TEntity&amp;gt;
        &lt;span&gt;where&lt;/span&gt; TEntity : &lt;span&gt;class&lt;/span&gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 指定查询条件
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;protected&lt;/span&gt; Expression&amp;lt;Func&amp;lt;TEntity, &lt;span&gt;bool&lt;/span&gt;&amp;gt;&amp;gt;&lt;span&gt; _expression;

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 创建一个新的 &lt;/span&gt;&lt;span&gt;&amp;lt;see cref=&quot;Query{TEntity}&quot;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Query()
        {
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 创建一个指定查询条件的&lt;/span&gt;&lt;span&gt;&amp;lt;see cref=&quot;Query{TEntity}&quot;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;expression&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;指定的查询条件&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; Query(Expression&amp;lt;Func&amp;lt;TEntity, &lt;span&gt;bool&lt;/span&gt;&amp;gt;&amp;gt;&lt;span&gt; expression)
        {
            _expression &lt;/span&gt;=&lt;span&gt; expression;
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 获取查询条件
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; Expression&amp;lt;Func&amp;lt;TEntity, &lt;span&gt;bool&lt;/span&gt;&amp;gt;&amp;gt;&lt;span&gt; GenerateExpression()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; _expression.And(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;GenerateQueryExpression&lt;/span&gt;()); &lt;br/&gt;　　　　 } &lt;br/&gt;　　}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　我们这个接口主要作用是对TEntity的属性生成想要的表达式，来看核心的GenerateQueryExpression方法实现         &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;74&quot;&gt;
&lt;pre&gt;
&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;　　/// &amp;lt;summary&amp;gt; 生成查询表达式&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;  &amp;lt;/summary&amp;gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;        &lt;br/&gt;&lt;span&gt;　　///&lt;/span&gt; &lt;span&gt;&amp;lt;typeparam name=&quot;TEntity&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;要查询的实体类型&lt;/span&gt;&lt;span&gt;&amp;lt;/typeparam&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Expression&amp;lt;Func&amp;lt;TEntity, &lt;span&gt;bool&lt;/span&gt;&amp;gt;&amp;gt; GenerateQueryExpression&amp;lt;TEntity&amp;gt;(&lt;span&gt;this&lt;/span&gt; IQuery&amp;lt;TEntity&amp;gt;&lt;span&gt; query)
            &lt;/span&gt;&lt;span&gt;where&lt;/span&gt; TEntity : &lt;span&gt;class&lt;/span&gt;&lt;span&gt;
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (query == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; queryType =&lt;span&gt; query.GetType();
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; param = Expression.Parameter(&lt;span&gt;typeof&lt;/span&gt;(TEntity), &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;m&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            Expression body &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (PropertyInfo property &lt;span&gt;in&lt;/span&gt;&lt;span&gt; queryType.GetProperties())
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; value =&lt;span&gt; property.GetValue(query);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (value &lt;span&gt;is&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;)
                {
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; str = ((&lt;span&gt;string&lt;/span&gt;&lt;span&gt;)value).Trim();
                    value &lt;/span&gt;= &lt;span&gt;string&lt;/span&gt;.IsNullOrEmpty(str) ? &lt;span&gt;null&lt;/span&gt;&lt;span&gt; : str;
                }

                Expression sub &lt;/span&gt;=&lt;/em&gt;&lt;/em&gt;&lt;/em&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
　　　　　　　　　　&lt;br/&gt;　　　　　　　　　　&lt;br/&gt;　　　　　　　　//针对QueryMode特性获取我们指定要查询的路径
                &lt;/span&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; attribute &lt;span&gt;in&lt;/span&gt; property.GetAttributes&amp;lt;&lt;span&gt;QueryModeAttribute&lt;/span&gt;&amp;gt;&lt;span&gt;())
                {
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; propertyPath =&lt;span&gt; attribute.PropertyPath;
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (propertyPath == &lt;span&gt;null&lt;/span&gt; || propertyPath.Length == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
                        propertyPath &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt;[] { property.Name };

                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; experssion =&lt;span&gt;&lt;span&gt; CreateQueryExpression&lt;/span&gt;(param, value, propertyPath, attribute.Compare);
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (experssion != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                    {
                        sub &lt;/span&gt;= sub == &lt;span&gt;null&lt;/span&gt; ?&lt;span&gt; experssion : Expression.Or(sub, experssion);
                    }
                }

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (sub != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                {
                    body &lt;/span&gt;= body == &lt;span&gt;null&lt;/span&gt; ?&lt;span&gt; sub : Expression.And(body, sub);
                }
            }

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (body != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Expression.Lambda&amp;lt;Func&amp;lt;TEntity, &lt;span&gt;bool&lt;/span&gt;&amp;gt;&amp;gt;&lt;span&gt;(body, param);

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }            

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 生成对应的表达式
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;        
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Expression &lt;span&gt;CreateQueryExpression&lt;/span&gt;(Expression param, &lt;span&gt;object&lt;/span&gt; value, &lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] propertyPath, QueryCompare compare)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; member =&lt;span&gt; CreatePropertyExpression(param, propertyPath);

            &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (compare)
            {
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; QueryCompare.Equal:
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; CreateEqualExpression(member, value);
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; QueryCompare.NotEqual:
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; CreateNotEqualExpression(member, value);
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; QueryCompare.Like:
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; CreateLikeExpression(member, value);
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; QueryCompare.NotLike:
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; CreateNotLikeExpression(member, value);
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; QueryCompare.StartWidth:
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; CreateStartsWithExpression(member, value);
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; QueryCompare.LessThan:
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; CreateLessThanExpression(member, value);
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; QueryCompare.LessThanOrEqual:
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; CreateLessThanOrEqualExpression(member, value);
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; QueryCompare.GreaterThan:
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; CreateGreaterThanExpression(member, value);
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; QueryCompare.GreaterThanOrEqual:
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; CreateGreaterThanOrEqualExpression(member, value);
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; QueryCompare.Between:
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; CreateBetweenExpression(member, value);
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; QueryCompare.GreaterEqualAndLess:
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; CreateGreaterEqualAndLessExpression(member, value);
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; QueryCompare.Include:
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; CreateIncludeExpression(member, value);
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; QueryCompare.NotInclude:
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; CreateNotIncludeExpression(member, value);
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; QueryCompare.IsNull:
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; CreateIsNullExpression(member, value);
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; QueryCompare.HasFlag:
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; CreateHasFlagExpression(member, value);
                &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            }
        }

     　　&lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 生成MemberExpression 
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    　　&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; MemberExpression CreatePropertyExpression(Expression param, &lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] propertyPath)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; expression = propertyPath.Aggregate(param, Expression.Property) &lt;span&gt;as&lt;/span&gt;&lt;span&gt; MemberExpression;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; expression;
        }

   　　 &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 生成等于的表达式
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    　　&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Expression CreateEqualExpression(MemberExpression member, &lt;span&gt;object&lt;/span&gt;&lt;span&gt; value)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (value == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; val =&lt;span&gt; Expression.Constant(ChangeType(value, member.Type), member.Type);

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Expression.Equal(member, val);
        }

    　　&lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    　　&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 生成Sql中的like（contain）表达式
    　　&lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    　　&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Expression CreateLikeExpression(MemberExpression member, &lt;span&gt;object&lt;/span&gt;&lt;span&gt; value)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (value == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (member.Type != &lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;))
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ArgumentOutOfRangeException(nameof(member), $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Member '{member}' can not use 'Like' compare&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; str =&lt;span&gt; value.ToString();
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; val =&lt;span&gt; Expression.Constant(str);

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Expression.Call(member, nameof(&lt;span&gt;string&lt;/span&gt;.Contains), &lt;span&gt;null&lt;/span&gt;&lt;span&gt;, val);
        }

其他条件的表达式暂时忽略。。。。&lt;/span&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 　　从这两个核心的方法中我们可以看出，主要是通过自定义的这个QueryModeAttribute来获取需要比较的属性和比较方法，看一下它的定义&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 查询字段
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    [AttributeUsage(AttributeTargets.Property, AllowMultiple = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;)]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; QueryModeAttribute : Attribute
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 比较方式
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;QueryCompare&lt;/span&gt; Compare { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 对应属性路径
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;[] PropertyPath { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 查询字段
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; QueryModeAttribute(&lt;span&gt;params&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] propertyPath)
        {
            PropertyPath &lt;/span&gt;=&lt;span&gt; propertyPath;
        }
        
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 查询字段
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; QueryModeAttribute(QueryCompare compare, &lt;span&gt;params&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] propertyPath)
        {
            PropertyPath &lt;/span&gt;=&lt;span&gt; propertyPath;
            Compare &lt;/span&gt;=&lt;span&gt; compare;
        }
    }

    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 查询比较方式
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt;&lt;span&gt; QueryCompare
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 等于
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        [Display(Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;等于&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        Equal,

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 不等于
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        [Display(Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;不等于&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        NotEqual,

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 模糊匹配
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        [Display(Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;模糊匹配&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        Like,

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 不包含模糊匹配
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        [Display(Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;不包含模糊匹配&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        NotLike,

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 以...开头
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        [Display(Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;以...开头&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        StartWidth,

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 小于
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        [Display(Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;小于&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        LessThan,

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 小于等于
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        [Display(Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;小于等于&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        LessThanOrEqual,

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 大于
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        [Display(Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;大于&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        GreaterThan,

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 大于等于
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        [Display(Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;大于等于&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        GreaterThanOrEqual,

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 在...之间，属性必须是一个集合（或逗号分隔的字符串），取第一和最后一个值。
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        [Display(Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;在...之间&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        Between,

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 大于等于起始，小于结束，属性必须是一个集合（或逗号分隔的字符串），取第一和最后一个值。
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        [Display(Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;大于等于起始，小于结束&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        GreaterEqualAndLess,

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 包含，属性必须是一个集合（或逗号分隔的字符串）
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        [Display(Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;包含&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        Include,

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 不包含，属性必须是一个集合（或逗号分隔的字符串）
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        [Display(Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;不包含&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        NotInclude,

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 为空或不为空，可以为 bool类型，或可空类型。
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        [Display(Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;为空或不为空&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        IsNull,

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 是否包含指定枚举
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        [Display(Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;是否包含指定枚举&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        HasFlag,
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　好的，那我们如何使用呢？很简单，只需在我们的查询类中继承并且指定通过何种方式比较和比较的是哪个属性即可&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ProductQuery : Query&amp;lt;Product&amp;gt;&lt;span&gt;
    {
　　　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;指定查询的属性是Name,且条件是Like&lt;/span&gt;
&lt;span&gt;        [QueryMode(QueryCompare.Like,nameof(Product.Name))]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Name {&lt;span&gt;get&lt;/span&gt;;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;;} 
         
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;最小库存
　　　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;指定查询的属性是Stock，且条件是大于等与&lt;/span&gt;
&lt;span&gt;        [QueryMode(QueryCompare.GreaterThanOrEqual,nameof(Product.Stock))]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; MinStock {&lt;span&gt;get&lt;/span&gt;;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;;}
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;最大库存
　　　　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;指定查询条件是Stock，且条件是小于等于&lt;/span&gt;
&lt;span&gt;        [QueryMode(QueryCompare.LessThanOrEqual,nameof(Product.Stock))]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; MaxStock {&lt;span&gt;get&lt;/span&gt;;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;;}
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;指定查询条件是Status，且条件是等于&lt;/span&gt;
&lt;span&gt;        [QueryMode(QueryCompare.Equal,nameof(Product.Status))]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Status Status {&lt;span&gt;get&lt;/span&gt;;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;;}
        
　　　　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建开始时间
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;指定查询条件是CreationTime，且条件是大于等与&lt;/span&gt;
&lt;span&gt;        [QueryMode(QueryCompare.GreaterThanOrEqual,nameof(Product.CreationTime))]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DateTime CreationStartTime {&lt;span&gt;get&lt;/span&gt;;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;;} 
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建结束时间
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;指定查询条件是CreationTime，且条件是小于等于&lt;/span&gt;
&lt;span&gt;        [QueryMode(QueryCompare.LessThanOrEqual,nameof(Product.CreationTime))]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DateTime CreationEndTime {&lt;span&gt;get&lt;/span&gt;;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;;} 
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在使用Linq方法查询时，比如调用基于IQueryable的Where方法时，我们可以封装自己的Where方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    　　&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 查询指定条件的数据
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;typeparam name=&quot;TEntity&quot;&amp;gt;&amp;lt;/typeparam&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;source&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;query&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IQueryable&amp;lt;TEntity&amp;gt; &lt;span&gt;Where&lt;/span&gt;&amp;lt;TEntity&amp;gt;(&lt;span&gt;this&lt;/span&gt; IQueryable&amp;lt;TEntity&amp;gt; source, IQuery&amp;lt;TEntity&amp;gt;&lt;span&gt; query)
            &lt;/span&gt;&lt;span&gt;where&lt;/span&gt; TEntity : &lt;span&gt;class&lt;/span&gt;&lt;span&gt;
        {&lt;br/&gt;　　　　　　　　//获取表达式
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; filter = query?&lt;span&gt;.&lt;span&gt;GenerateExpression&lt;/span&gt;();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (filter != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                source &lt;/span&gt;=&lt;span&gt; source.Where(filter);

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; source;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　这样在我们的Controller里面这样写&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    　　[HttpPost]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;JsonResult&amp;gt;&lt;span&gt; SearchProductList(ProductQuery query)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; data = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; _productService.GetSpecifyProductListAsync(query);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Json(result);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　我们的service层这样实现GetSpecifyProductListAsync&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    　　&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 获取指定条件的商品
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;typeparam name=&quot;TEntity&quot;&amp;gt;&amp;lt;/typeparam&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;query&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
　　　　&lt;span&gt;public&lt;/span&gt; Task&amp;lt;List&amp;lt;Product&amp;gt;&amp;gt; GetSpecifyProductListAsync&amp;lt;Product&amp;gt;(IQuery&amp;lt;Product&amp;gt; query = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) 
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; _productRepository.AsNoTracking().&lt;span&gt;Where&lt;/span&gt;(query).ToListAsync();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这样在前端传过来的条件，都会自动通过我们核心的方法GenerateExpression生成的表达式作为条件进行查询进而返回实体列表。当然，还可以有更高级的方法，比如返回的是分页的数据，或者返回的是指定的类型（直接返回实体是不安全的），后续我们都会针对更高级的开发思想来讲解到这些情况。&lt;/p&gt;

&lt;p&gt;　　总结一下：&lt;/p&gt;
&lt;p&gt;　　1. 创建我们的查询实体（ProductQuery），指定我们的查询属性（Name, Status...）和查询条件（QueryCompare）&lt;/p&gt;
&lt;p&gt;　　2. 继承我们的查询实体Query，并且指定该次查询是针对哪个数据实体（Query&amp;lt;Product&amp;gt;）&lt;/p&gt;
&lt;p&gt;　　3. 封装基于Linq的方法Where方法，这里调用我们的核心方法GenerateExpression生成表达式&lt;/p&gt;

&lt;p&gt;　　如果有更好的想法，欢迎探讨。&lt;/p&gt;
</description>
<pubDate>Mon, 18 Feb 2019 03:33:00 +0000</pubDate>
<dc:creator>lex-wu</dc:creator>
<og:description>一般来说所有的系统都离不开查询，通俗点说就是前后端交互。我们的系统无非都是通过实体的属性作为条件进行查询，那我们有什么方法可以拼装成类似sql中的where条件呢？在.Net的体系中，有个很好的东西叫</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lex-wu/p/10389236.html</dc:identifier>
</item>
<item>
<title>MySQL高可用复制管理工具 —— Orchestrator介绍 - jyzhou</title>
<link>http://www.cnblogs.com/zhoujinyi/p/10387581.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhoujinyi/p/10387581.html</guid>
<description>&lt;pre&gt;
        Debug:                                      &lt;span&gt;false&lt;/span&gt;,  --&lt;span&gt;设置debug模式
        EnableSyslog:                               &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;, --&lt;span&gt; 是否把日志输出到系统日志里
        ListenAddress:                              &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:3000&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, --&lt;span&gt; web http tpc 监听端口
        ListenSocket:                               &lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;, --&lt;span&gt; 套接字文件，默认空，和ListenAddress互斥。
        HTTPAdvertise:                              &lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;, --&lt;span&gt;可选，为raft设置。通知相关http信息
        AgentsServerPort:                           &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:3001&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,--&lt;span&gt;回调接口
        StatusEndpoint:                             &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/api/status&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,--状态查看，默认为&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/ api / status&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        StatusOUVerify:                             &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;,--&lt;span&gt;如果为true，请尝试在Mutual TLS打开时验证OU。 默认为false
        BackendDB:                                  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mysql&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,--&lt;span&gt;后端数据库类型，可选mysql或则sqlite3
        SQLite3DataFile:                            &lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;, --&lt;span&gt;sqlite3的数据文件
        SkipOrchestratorDatabaseUpdate:             &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;,--&lt;span&gt; 如果为true，不检查后端数据库模式，也不尝试更新它。 当运行多个版本的orchestrator时很有用
        PanicIfDifferentDatabaseDeploy:             &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;, --&lt;span&gt;如果为true，此进程发现协调器后端的数据库由不同版本配置，则发生混乱
        RaftBind:                                   &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;127.0.0.1:10008&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        RaftAdvertise:                              &lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;,
        RaftDataDir:                                &lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;,
        DefaultRaftPort:                            &lt;/span&gt;&lt;span&gt;10008&lt;/span&gt;, --&lt;span&gt;如果RaftNodes未指定端口，使用此端口
        RaftNodes:                                  []&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;{}, --&lt;span&gt;raft初始化连接
        ExpectFailureAnalysisConcensus:             &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
        MySQLOrchestratorMaxPoolConnections:        &lt;/span&gt;&lt;span&gt;128&lt;/span&gt;, --&lt;span&gt;限制后端数据库的并发数
        MySQLOrchestratorPort:                      &lt;/span&gt;&lt;span&gt;3306&lt;/span&gt;, --&lt;span&gt;后端数据库端口
        MySQLTopologyUseMutualTLS:                  &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;,--&lt;span&gt;是否启用TLS身份验证
        MySQLTopologyUseMixedTLS:                   &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;,--&lt;span&gt;是否混合TLS和非TLS身份验证
        MySQLOrchestratorUseMutualTLS:              &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;,--&lt;span&gt;是否为Orchestrator MySQL实例启用TLS身份验证
        MySQLConnectTimeoutSeconds:                 &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;,--&lt;span&gt;数据库连接超时时间，秒。
        MySQLOrchestratorReadTimeoutSeconds:        &lt;/span&gt;&lt;span&gt;30&lt;/span&gt;,--&lt;span&gt;读操作超时
        MySQLDiscoveryReadTimeoutSeconds:           &lt;/span&gt;&lt;span&gt;10&lt;/span&gt;,--&lt;span&gt;发现查询的超时
        MySQLTopologyReadTimeoutSeconds:            &lt;/span&gt;&lt;span&gt;600&lt;/span&gt;,--&lt;span&gt;发现查询之外查询的超时
        MySQLConnectionLifetimeSeconds:             &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;,--&lt;span&gt;活跃状态的的时间
        DefaultInstancePort:                        &lt;/span&gt;&lt;span&gt;3306&lt;/span&gt;,--&lt;span&gt;数据库默认端口
        TLSCacheTTLFactor:                          &lt;/span&gt;&lt;span&gt;100&lt;/span&gt;,--&lt;span&gt;为TLS信息缓存到期的InstancePollSeconds的因子
        InstancePollSeconds:                        &lt;/span&gt;&lt;span&gt;5&lt;/span&gt;,--&lt;span&gt;实例之间读取间隔
        InstanceWriteBufferSize:                    &lt;/span&gt;&lt;span&gt;100&lt;/span&gt;,--&lt;span&gt;实例写入缓冲区大小
        BufferInstanceWrites:                       &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;,--在后端表上设置为“&lt;span&gt;true&lt;/span&gt;&lt;span&gt;”以进行写入优化，写入可能过时并覆盖非陈旧数据
        InstanceFlushIntervalMilliseconds:          &lt;/span&gt;&lt;span&gt;100&lt;/span&gt;,--&lt;span&gt;实例写入缓冲区刷新之间的最大间隔时间
        SkipMaxScaleCheck:                          &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;,--如果没有MaxScale BinlogServer，请将其设置为“&lt;span&gt;true&lt;/span&gt;&lt;span&gt;”以保存一些无意义的查询
        UnseenInstanceForgetHours:                  &lt;/span&gt;&lt;span&gt;240&lt;/span&gt;,--&lt;span&gt;忽略不可见的实例的小时数
        SnapshotTopologiesIntervalHours:            &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;,--快照拓扑调用之间的小时间隔。 默认值：&lt;span&gt;0&lt;/span&gt;&lt;span&gt;（禁用）
        DiscoverByShowSlaveHosts:                   &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;,--&lt;span&gt;在PROCESSLIST之前尝试SHOW SLAVE HOSTS
        UseSuperReadOnly:                           &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;,--&lt;span&gt;每当它设置read_only时，orchestrator应该是super_read_only
        DiscoveryMaxConcurrency:                    &lt;/span&gt;&lt;span&gt;300&lt;/span&gt;,--&lt;span&gt;实例发现时go的最大进程数量。
        DiscoveryQueueCapacity:                     &lt;/span&gt;&lt;span&gt;100000&lt;/span&gt;,--&lt;span&gt;发现队列的缓冲区大小。 应该大于发现的数据库实例的数量
        DiscoveryQueueMaxStatisticsSize:            &lt;/span&gt;&lt;span&gt;120&lt;/span&gt;,--&lt;span&gt;发现队列的第二次统计数据的最大数量
        DiscoveryCollectionRetentionSeconds:        &lt;/span&gt;&lt;span&gt;120&lt;/span&gt;,--&lt;span&gt;保留发现集合信息的秒数
        InstanceBulkOperationsWaitTimeoutSeconds:   &lt;/span&gt;&lt;span&gt;10&lt;/span&gt;,--&lt;span&gt;在进行批量操作时等待单个实例的时间
        HostnameResolveMethod:                      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        MySQLHostnameResolveMethod:                 &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;@@hostname&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        SkipBinlogServerUnresolveCheck:             &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;, --&lt;span&gt;跳过检查未解析的主机名是否解析为binlog服务器的相同主机名
        ExpiryHostnameResolvesMinutes:              &lt;/span&gt;&lt;span&gt;60&lt;/span&gt;, --&lt;span&gt;主机名解析到期之前的分钟数
        RejectHostnameResolvePattern:               &lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;,--&lt;span&gt;不接受解析主机名的正则表达式。 这样做是为了避免因网络故障而存储错误
        ReasonableReplicationLagSeconds:            &lt;/span&gt;&lt;span&gt;10&lt;/span&gt;,--&lt;span&gt;复制延迟高于该值表示异常
        ProblemIgnoreHostnameFilters:               []&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;{},--&lt;span&gt;将与给定的regexp过滤器匹配的主机名最小化问题
        VerifyReplicationFilters:                   &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;, --&lt;span&gt;在拓扑重构之前检查复制筛选器
        ReasonableMaintenanceReplicationLagSeconds: &lt;/span&gt;&lt;span&gt;20&lt;/span&gt;,--&lt;span&gt;高于此值会上移和下移
        CandidateInstanceExpireMinutes:             &lt;/span&gt;&lt;span&gt;60&lt;/span&gt;,--&lt;span&gt;该时间之后，使用实例作为候选副本的建议已过期。
        AuditLogFile:                               &lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;, --&lt;span&gt;审计操作的日志文件名。 空的时候禁用。
        AuditToSyslog:                              &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;, --&lt;span&gt;审计日志是否写入到系统日志
        AuditToBackendDB:                           &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;, --&lt;span&gt;审计日志是否入库，表为audit，默认true
        RemoveTextFromHostnameDisplay:              &lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;,--去除群集/&lt;span&gt;群集页面上的主机名的文本
        ReadOnly:                                   &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
        AuthenticationMethod:                       &lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;,--&lt;span&gt;身份验证类型。可选值有：
&lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; none, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;basic&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;for&lt;/span&gt;&lt;span&gt; BasicAuth,
&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;multi&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;for&lt;/span&gt;&lt;span&gt; advanced BasicAuth, 
&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;proxy&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;for&lt;/span&gt;&lt;span&gt; forwarded credentials via reverse proxy, 通过反向代理转发凭证
&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;token&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;for&lt;/span&gt;&lt;span&gt; token based access

        HTTPAuthUser:                               &lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;, --&lt;span&gt;HTTP基本身份验证的用户名，空表示禁用身份验证
        HTTPAuthPassword:                           &lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;, --&lt;span&gt;HTTP基本身份验证的密码，空表示禁用密码
        AuthUserHeader:                             &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;X-Forwarded-User&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,--&lt;span&gt;当AuthenticationMethod为“proxy”时，HTTP标头指示auth用户
        PowerAuthUsers:                             []&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;{&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;},--在AuthenticationMethod ==&lt;span&gt;“proxy”上，可以更改的用户列表。 所有其他都是只读的
        PowerAuthGroups:                            []&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;{},--&lt;span&gt;经过身份验证的用户必须是unix组列表成员
        AccessTokenUseExpirySeconds:                &lt;/span&gt;&lt;span&gt;60&lt;/span&gt;,--&lt;span&gt;必须使用已颁发token的时间
        AccessTokenExpiryMinutes:                   &lt;/span&gt;&lt;span&gt;1440&lt;/span&gt;,--&lt;span&gt;访问的到期的时间
        ClusterNameToAlias:                         &lt;/span&gt;&lt;span&gt;make&lt;/span&gt;(map[&lt;span&gt;string&lt;/span&gt;]&lt;span&gt;string&lt;/span&gt;&lt;span&gt;),
        DetectClusterAliasQuery:                    &lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;,--&lt;span&gt;可选查询（在拓扑实例上执行），返回集群的别名
        DetectClusterDomainQuery:                   &lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;,--可选查询（在拓扑实例上执行），返回此集群主服务器的VIP / CNAME /别名/&lt;span&gt;任何域名
        DetectInstanceAliasQuery:                   &lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;,--&lt;span&gt;可选查询（在拓扑实例上执行），返回实例的别名
        DetectPromotionRuleQuery:                   &lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;,--&lt;span&gt;可选查询（在拓扑实例上执行），返回实例的提升规则
        DataCenterPattern:                          &lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;, --&lt;span&gt;一个组的正则表达式模式，从主机名中提取数据中心名称
        PhysicalEnvironmentPattern:                 &lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;,--&lt;span&gt;一个组的正则表达式模式，从主机名中提取物理环境信息
        DetectDataCenterQuery:                      &lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;,--&lt;span&gt;可选查询（在拓扑实例上执行），返回实例的数据中心，覆盖DataCenterPattern，对无法通过主机名推断DC非常有用
        DetectPhysicalEnvironmentQuery:      &lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;,--&lt;span&gt;可选查询（在拓扑实例上执行），返回实例的物理环境。覆盖PhysicalEnvironmentPattern，对无法通过主机名推断出env非常有用
        DetectSemiSyncEnforcedQuery:                &lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;,--&lt;span&gt;可选查询（在拓扑实例上执行）以确定是否对主写入完全强制执行半同步
        SupportFuzzyPoolHostnames:                  &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;,--应该“submit-pool-instances”命令能够传递模糊实例列表（模糊意味着非fqdn，但足够独特，可以识别）。 默认值为“&lt;span&gt;true&lt;/span&gt;&lt;span&gt;”，表示后端数据库上有更多查询
        InstancePoolExpiryMinutes:                  &lt;/span&gt;&lt;span&gt;60&lt;/span&gt;,--&lt;span&gt;database_instance_pool的过期的时间
        PromotionIgnoreHostnameFilters:             []&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;{},--&lt;span&gt;不使用主机名匹配模式来提升副本
        ServeAgentsHttp:                            &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;,--产生另一个专用于orchestrator-&lt;span&gt;agent的HTTP接口
        AgentsUseSSL:                               &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;,--当“&lt;span&gt;true&lt;/span&gt;&lt;span&gt;”orchestrator将使用SSL侦听代理端口以及通过SSL连接到代理时
        AgentsUseMutualTLS:                         &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;,--当“&lt;span&gt;true&lt;/span&gt;&lt;span&gt;”时，使用相互TLS服务器与代理通信
        AgentSSLValidOUs:                           []&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;{},--&lt;span&gt;使用相互TLS与代理进行通信
        AgentSSLSkipVerify:                         &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;,--&lt;span&gt;为代理使用SSL
        AgentSSLPrivateKeyFile:                     &lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;,
        AgentSSLCertFile:                           &lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;,
        AgentSSLCAFile:                             &lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;,
        UseSSL:                                     &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;,--&lt;span&gt;在Web端口上使用SSL
        UseMutualTLS:                               &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;,--“&lt;span&gt;true&lt;/span&gt;&lt;span&gt;”时使用TLS作为服务器的Web和API连接
        SSLValidOUs:                                []&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;{},--&lt;span&gt;使用TLS交互
        SSLSkipVerify:                              &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;,--&lt;span&gt;使用SSL时，是否应忽略SSL认证错误
        SSLPrivateKeyFile:                          &lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;,
        SSLCertFile:                                &lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;,
        SSLCAFile:                                  &lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;,
        AgentPollMinutes:                           &lt;/span&gt;&lt;span&gt;60&lt;/span&gt;,--&lt;span&gt;代理轮询的分钟数
        UnseenAgentForgetHours:                     &lt;/span&gt;&lt;span&gt;6&lt;/span&gt;,--&lt;span&gt;忘记不可见的代理的小时数
        StaleSeedFailMinutes:                       &lt;/span&gt;&lt;span&gt;60&lt;/span&gt;,--&lt;span&gt;过时（无进展）被视为失败的分钟数
        SeedAcceptableBytesDiff:                    &lt;/span&gt;&lt;span&gt;8192&lt;/span&gt;,--&lt;span&gt;种子源和目标数据大小之间的字节差异仍被视为成功复制
        SeedWaitSecondsBeforeSend:                  &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;,--&lt;span&gt;在代理上开始发送数据命令之前等待的秒数
        AutoPseudoGTID:                             &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;, --是否自动将Pseudo-&lt;span&gt;GTID条目注入主服务器
        PseudoGTIDPattern:                          &lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;,--&lt;span&gt;在二进制日志中查找的模式，用于创建唯一条目（伪GTID）。 为空时，禁用基于伪GTID的重构。
        PseudoGTIDPatternIsFixedSubstring:          &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;,--&lt;span&gt;如为true，则PseudoGTIDPattern不被视为正则表达式而是固定子字符串
        PseudoGTIDMonotonicHint:                    &lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;,--Pseudo-GTID条目中的子字符串，表示Pseudo-&lt;span&gt;GTID条目预计会单调递增
        DetectPseudoGTIDQuery:                      &lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;,--&lt;span&gt;可选查询，用于确定是否在实例上启用了伪gtid
        BinlogEventsChunkSize:                      &lt;/span&gt;&lt;span&gt;10000&lt;/span&gt;,--SHOW BINLOG |&lt;span&gt; RELAYLOG EVENTS LIMIT的块大小。 较小意味着更少的锁定和工作要做
        SkipBinlogEventsContaining:                 []&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;{},--扫描/比较Pseudo-&lt;span&gt;GTID的binlog时，跳过包含给定文本的条目。 这些不是正则表达式（扫描binlog时会消耗太多的CPU），只需查找子字符串。
        ReduceReplicationAnalysisCount:             &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;,--&lt;span&gt;如果为true，则复制分析将报告可能首先处理问题的可能性的实例。 如果为false，则为每个已知实例提供一个条目
        FailureDetectionPeriodBlockMinutes:         &lt;/span&gt;&lt;span&gt;60&lt;/span&gt;,--&lt;span&gt;实例的故障发现保持“活动”的时间，以避免实例失败的并发“发现”; 如果有的话，这会在任何恢复过程之前。
        RecoveryPeriodBlockMinutes:                 &lt;/span&gt;&lt;span&gt;60&lt;/span&gt;,--&lt;span&gt;实例的恢复保持“活动”的时间，以避免并发恢复
        RecoveryPeriodBlockSeconds:                 &lt;/span&gt;&lt;span&gt;3600&lt;/span&gt;, --&lt;span&gt;实例的恢复保持“活动”的时间，以避免并发恢复
        RecoveryIgnoreHostnameFilters:              []&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;{},--&lt;span&gt;恢复分析将完全忽略与给定模式匹配的主机
        RecoverMasterClusterFilters:                []&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;{},--只对匹配这些正则表达式模式的集群进行主恢复（“*&lt;span&gt;”模式匹配所有）
        RecoverIntermediateMasterClusterFilters:    []&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;{},--只对匹配这些正则表达式模式的集群进行恢复（“*&lt;span&gt;”模式匹配所有内容）
        ProcessesShellCommand:                      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bash&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,--&lt;span&gt;执行命令脚本的Shell
        OnFailureDetectionProcesses:                []&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;{},--&lt;span&gt;检测故障转移方案时执行（在决定是否进行故障转移之前）。 可以并且应该使用其中一些占位符{failureType}，{failureDescription}，{command}，{failedHost}，{failureCluster}，{failureClusterAlias}，{failureClusterDomain}，{failedPort}，{successorHost}，{successorPort}，{ successorAlias}，{countReplicas}，{replicaHosts}，{isDowntimed}，{autoMasterRecovery}，{autoIntermediateMasterRecovery}
        PreGracefulTakeoverProcesses:      []&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;{},--&lt;span&gt;在主变为只读之前立即执行。 可以并且应该使用其中一些占位符：{failureType}，{failureDescription}，{command}，{failedHost}，{failureCluster}，{failureClusterAlias}，{failureClusterDomain}，{failedPort}，{successorHost}，{successorPort}，{ successorAlias}，{countReplicas}，{replicaHosts}，{isDowntimed}
        PreFailoverProcesses:                       []&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;{},--&lt;span&gt;在执行恢复操作之前立即执行。任何这些进程的失败（非零退出代码）都会中止恢复。提示：这使您有机会根据系统的某些内部状态中止恢复。 可以并且应该使用其中一些占位符：{failureType}，{failureDescription}，{command}，{failedHost}，{failureCluster}，{failureClusterAlias}，{failureClusterDomain}，{failedPort}，{successorHost}，{successorPort}，{ successorAlias}，{countReplicas}，{replicaHosts}，{isDowntimed}
        PostMasterFailoverProcesses:                []&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;{},--&lt;span&gt;在主恢复成功结束时执行（未定义的执行顺序）。 使用与PostFailoverProcesses相同的占位符
        PostIntermediateMasterFailoverProcesses:    []&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;{},--&lt;span&gt;在成功的中间主恢复结束时执行（未定义的执行顺序）。 使用与PostFailoverProcesses相同的占位符
        PostFailoverProcesses:                      []&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;{},--&lt;span&gt;在成功恢复结束时执行（包括并添加到上述两个）。 可以并且应该使用其中一些占位符：{failureType}，{failureDescription}，{command}，{failedHost}，{failureCluster}，{failureClusterAlias}，{failureClusterDomain}，{failedPort}，{successorHost}，{successorPort}，{ successorAlias}，{countReplicas}，{replicaHosts}，{isDowntimed}，{isSuccessful}，{lostReplicas}
        PostUnsuccessfulFailoverProcesses:          []&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;{},--&lt;span&gt;在任何不成功的恢复结束时执行。（未定义的执行顺序）。 可以并且应该使用其中一些占位符：{failureType}，{failureDescription}，{command}，{failedHost}，{failureCluster}，{failureClusterAlias}，{failureClusterDomain}，{failedPort}，{successorHost}，{successorPort}，{ successorAlias}，{countReplicas}，{replicaHosts}，{isDowntimed}，{isSuccessful}，{lostReplicas}
        PostGracefulTakeoverProcesses:              []&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;{},--&lt;span&gt;在旧主位于新晋升的主之后执行。 使用与PostFailoverProcesses相同的占位符
        CoMasterRecoveryMustPromoteOtherCoMaster:   &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;,--当&lt;span&gt;'&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;时，任何都可以得到提升（候选人比其他人更受欢迎）。 当&lt;span&gt;'&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;时，将促进其他共同主人或否则失败
        DetachLostSlavesAfterMasterFailover(DetachLostReplicasAfterMasterFailover):        &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;,--恢复过程中可能会丢失一些副本。如果为true，将通过detach-&lt;span&gt;replica命令强制中断其复制，以确保没有人认为它们完全正常运行。
        ApplyMySQLPromotionAfterMasterFailover:     &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;,--将重置slave all并在提升的master上设置read_only = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;，默认true。
        PreventCrossDataCenterMasterFailover:       &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;,--如果为true（默认值：&lt;span&gt;false&lt;/span&gt;&lt;span&gt;），则不允许跨DC主故障转移，orchestrator将尽其所能仅在同一DC内进行故障转移，否则不进行故障转移。
        MasterFailoverLostInstancesDowntimeMinutes: &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;,--&lt;span&gt;在主故障转移（包括失败的主副本和丢失的副本）之后丢失的任何服务器停机的分钟数。 0表示禁用
        MasterFailoverDetachSlaveMasterHost(MasterFailoverDetachReplicaMasterHost):        &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;,--orchestrator是否应该在新升级的master上发出detach-replica-master-host（这样可以确保新master不会尝试复制旧的master，如果它恢复生命）。 默认为&lt;span&gt;'&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;。 如果ApplyMySQLPromotionAfterMasterFailover为&lt;span&gt;'&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;则无意义。

        FailMasterPromotionIfSQLThreadNotUpToDate:  &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;,--&lt;span&gt;如果为true，并且发生主故障转移，如果候选主服务器未消耗所有中继日志（延迟），则中止并显示错误
        PostponeSlaveRecoveryOnLagMinutes（PostponeReplicaRecoveryOnLagMinutes）:          &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;,--在崩溃恢复时，滞后超过给定分钟的副本仅在主/&lt;span&gt; IM被选出并执行进程后才在恢复过程的后期复活。 值为0将禁用此功能
        RemoteSSHForMasterFailover:                 &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;,--orchestrator是否应该在主故障转移时尝试远程-shsh relaylog-&lt;span&gt;synching？ 需要RemoteSSHCommand
        RemoteSSHCommand:                           &lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;,--一个`&lt;span&gt;ssh&lt;/span&gt;`命令，由恢复进程用于读取/应用relaylogs。 如果提供，则此变量必须包含文本“{&lt;span&gt;hostname&lt;/span&gt;}”。 远程SSH登录必须具有读/写中继日志的权限。 示例：“setuidgid remoteuser &lt;span&gt;ssh&lt;/span&gt; {&lt;span&gt;hostname&lt;/span&gt;&lt;span&gt;}”
        RemoteSSHCommandUseSudo:                    &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;,--是否orchestrator应该在SSH命令下在远程主机上应用&lt;span&gt;'&lt;/span&gt;&lt;span&gt;sudo&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        OSCIgnoreHostnameFilters:                   []&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;{},--&lt;span&gt;建议将忽略与给定模式匹配的副本主机名
        GraphiteAddr:                               &lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;,
        GraphitePath:                               &lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;,
        GraphiteConvertHostnameDotsToUnderscores:   &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
        GraphitePollSeconds:                        &lt;/span&gt;&lt;span&gt;60&lt;/span&gt;&lt;span&gt;,
        URLPrefix:                                  &lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;,
        DiscoveryIgnoreReplicaHostnameFilters: []&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;{},
        ConsulAddress:                         &lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;,
        ConsulAclToken:                        &lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;,
        ZkAddress:                             &lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;,
        KVClusterMasterPrefix:                 &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mysql/master&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        WebMessage:                            &lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;,
&lt;/pre&gt;</description>
<pubDate>Mon, 18 Feb 2019 03:21:00 +0000</pubDate>
<dc:creator>jyzhou</dc:creator>
<og:description>背景 在MySQL高可用架构中，目前使用比较多的是Percona的PXC，Galera以及MySQL 5.7之后的MGR等，其他的还有的MHA，今天介绍另一个比较好用的MySQL高可用复制管理工具：O</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhoujinyi/p/10387581.html</dc:identifier>
</item>
<item>
<title>Java并发编程：CountDownLatch、CyclicBarrier和 Semaphore - 华丽D转身</title>
<link>http://www.cnblogs.com/snake23/p/10394499.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/snake23/p/10394499.html</guid>
<description>&lt;p&gt;在java 1.5中，提供了一些非常有用的辅助类来帮助我们进行并发编程，比如CountDownLatch，CyclicBarrier和Semaphore，今天我们就来学习一下这三个辅助类的用法。&lt;/p&gt;
&lt;p&gt;以下是本文目录大纲：&lt;/p&gt;
&lt;p&gt;一.CountDownLatch用法&lt;/p&gt;
&lt;p&gt;二.CyclicBarrier用法&lt;/p&gt;
&lt;p&gt;三.Semaphore用法&lt;/p&gt;
&lt;h2&gt;一.CountDownLatch用法&lt;/h2&gt;
&lt;p&gt;CountDownLatch类位于java.util.concurrent包下，利用它可以实现类似计数器的功能。比如有一个任务A，它要等待其他4个任务执行完毕之后才能执行，此时就可以利用CountDownLatch来实现这种功能了。&lt;/p&gt;
&lt;p&gt;CountDownLatch类只提供了一个构造器：&lt;/p&gt;
&lt;div&gt;
&lt;div id=&quot;highlighter_726591&quot; class=&quot;syntaxhighlighter notranslate java&quot;&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;4&quot;&gt;
&lt;div class=&quot;container&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;code class=&quot;java keyword&quot;&gt;public&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;CountDownLatch(&lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;int&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;count) {  }; &lt;/code&gt; &lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;然后下面这3个方法是CountDownLatch类中最重要的方法：&lt;/p&gt;
&lt;div&gt;
&lt;div id=&quot;highlighter_902326&quot;&gt;
&lt;div&gt;
&lt;div id=&quot;highlighter_121399&quot; class=&quot;syntaxhighlighter notranslate java&quot;&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;container&quot; readability=&quot;12&quot;&gt;
&lt;p&gt;&lt;code class=&quot;java keyword&quot;&gt;public&lt;/code&gt; &lt;code class=&quot;java keyword&quot;&gt;void&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;await()&lt;/code&gt; &lt;code class=&quot;java keyword&quot;&gt;throws&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;InterruptedException { };  &lt;/code&gt; &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java keyword&quot;&gt;public&lt;/code&gt; &lt;code class=&quot;java keyword&quot;&gt;boolean&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;await(&lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;long&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;timeout, TimeUnit unit)&lt;/code&gt; &lt;code class=&quot;java keyword&quot;&gt;throws&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;InterruptedException { }; &lt;/code&gt; &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java keyword&quot;&gt;public&lt;/code&gt; &lt;code class=&quot;java keyword&quot;&gt;void&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;countDown() { }; &lt;/code&gt; &lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;下面看一个例子大家就清楚CountDownLatch的用法了：&lt;/p&gt;
&lt;div&gt;
&lt;div id=&quot;highlighter_335238&quot; class=&quot;syntaxhighlighter notranslate java&quot;&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr readability=&quot;8&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;p&gt;5&lt;/p&gt;
&lt;p&gt;6&lt;/p&gt;
&lt;p&gt;7&lt;/p&gt;
&lt;p&gt;8&lt;/p&gt;
&lt;p&gt;9&lt;/p&gt;
&lt;p&gt;10&lt;/p&gt;
&lt;p&gt;11&lt;/p&gt;
&lt;p&gt;12&lt;/p&gt;
&lt;p&gt;13&lt;/p&gt;
&lt;p&gt;14&lt;/p&gt;
&lt;p&gt;15&lt;/p&gt;
&lt;p&gt;16&lt;/p&gt;
&lt;p&gt;17&lt;/p&gt;
&lt;p&gt;18&lt;/p&gt;
&lt;p&gt;19&lt;/p&gt;
&lt;p&gt;20&lt;/p&gt;
&lt;p&gt;21&lt;/p&gt;
&lt;p&gt;22&lt;/p&gt;
&lt;p&gt;23&lt;/p&gt;
&lt;p&gt;24&lt;/p&gt;
&lt;p&gt;25&lt;/p&gt;
&lt;p&gt;26&lt;/p&gt;
&lt;p&gt;27&lt;/p&gt;
&lt;p&gt;28&lt;/p&gt;
&lt;p&gt;29&lt;/p&gt;
&lt;p&gt;30&lt;/p&gt;
&lt;p&gt;31&lt;/p&gt;
&lt;p&gt;32&lt;/p&gt;
&lt;p&gt;33&lt;/p&gt;
&lt;p&gt;34&lt;/p&gt;
&lt;p&gt;35&lt;/p&gt;
&lt;p&gt;36&lt;/p&gt;
&lt;p&gt;37&lt;/p&gt;
&lt;p&gt;38&lt;/p&gt;
&lt;p&gt;39&lt;/p&gt;
&lt;p&gt;40&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;37&quot;&gt;
&lt;div class=&quot;container&quot; readability=&quot;73&quot;&gt;
&lt;p&gt;&lt;code class=&quot;java keyword&quot;&gt;public&lt;/code&gt; &lt;code class=&quot;java keyword&quot;&gt;class&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;Test {&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;     &lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;public&lt;/code&gt; &lt;code class=&quot;java keyword&quot;&gt;static&lt;/code&gt; &lt;code class=&quot;java keyword&quot;&gt;void&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;main(String[] args) {  &lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;         &lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;final&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;CountDownLatch latch =&lt;/code&gt; &lt;code class=&quot;java keyword&quot;&gt;new&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;CountDownLatch(&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;2&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;);&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;         &lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;new&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;Thread(){&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;             &lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;public&lt;/code&gt; &lt;code class=&quot;java keyword&quot;&gt;void&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;run() {&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;                 &lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;try&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;{&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;                     &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;System.out.println(&lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;&quot;子线程&quot;&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;+Thread.currentThread().getName()+&lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;&quot;正在执行&quot;&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;                    &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;Thread.sleep(&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;3000&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;                    &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;System.out.println(&lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;&quot;子线程&quot;&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;+Thread.currentThread().getName()+&lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;&quot;执行完毕&quot;&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;                    &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;latch.countDown();&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;                &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;}&lt;/code&gt; &lt;code class=&quot;java keyword&quot;&gt;catch&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;(InterruptedException e) {&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;                    &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;e.printStackTrace();&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;                &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;             &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;};&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;         &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;}.start();&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;         &lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;new&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;Thread(){&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;             &lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;public&lt;/code&gt; &lt;code class=&quot;java keyword&quot;&gt;void&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;run() {&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;                 &lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;try&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;{&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;                     &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;System.out.println(&lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;&quot;子线程&quot;&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;+Thread.currentThread().getName()+&lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;&quot;正在执行&quot;&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;                     &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;Thread.sleep(&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;3000&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;                     &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;System.out.println(&lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;&quot;子线程&quot;&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;+Thread.currentThread().getName()+&lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;&quot;执行完毕&quot;&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;                     &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;latch.countDown();&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;                &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;}&lt;/code&gt; &lt;code class=&quot;java keyword&quot;&gt;catch&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;(InterruptedException e) {&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;                    &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;e.printStackTrace();&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;                &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;             &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;};&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;         &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;}.start();&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;         &lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;try&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;{&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;             &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;System.out.println(&lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;&quot;等待2个子线程执行完毕...&quot;&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;            &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;latch.await();&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;            &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;System.out.println(&lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;&quot;2个子线程已经执行完毕&quot;&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;            &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;System.out.println(&lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;&quot;继续执行主线程&quot;&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;}&lt;/code&gt; &lt;code class=&quot;java keyword&quot;&gt;catch&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;(InterruptedException e) {&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;            &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;e.printStackTrace();&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;     &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;}&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;执行结果：&lt;/p&gt;
&lt;div&gt;
&lt;div&gt;
&lt;div id=&quot;highlighter_54275&quot; class=&quot;syntaxhighlighter notranslate java&quot;&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;1.5&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;p&gt;5&lt;/p&gt;
&lt;p&gt;6&lt;/p&gt;
&lt;p&gt;7&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;9&quot;&gt;
&lt;div class=&quot;container&quot; readability=&quot;17&quot;&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;线程Thread-&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;0&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;正在执行&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;线程Thread-&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;1&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;正在执行&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;等待&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;2&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;个子线程执行完毕...&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;线程Thread-&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;0&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;执行完毕&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;线程Thread-&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;1&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;执行完毕&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java value&quot;&gt;2&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;个子线程已经执行完毕&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;继续执行主线程&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h2&gt;二.CyclicBarrier用法&lt;/h2&gt;
&lt;p&gt;字面意思回环栅栏，通过它可以实现让一组线程等待至某个状态之后再全部同时执行。叫做回环是因为当所有等待线程都被释放以后，CyclicBarrier可以被重用。我们暂且把这个状态就叫做barrier，当调用await()方法之后，线程就处于barrier了。&lt;/p&gt;
&lt;p&gt;CyclicBarrier类位于java.util.concurrent包下，CyclicBarrier提供2个构造器：&lt;/p&gt;
&lt;div&gt;
&lt;div id=&quot;highlighter_163358&quot;&gt;
&lt;div&gt;
&lt;div id=&quot;highlighter_244800&quot; class=&quot;syntaxhighlighter notranslate java&quot;&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;p&gt;5&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;5.5&quot;&gt;
&lt;div class=&quot;container&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;code class=&quot;java keyword&quot;&gt;public&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;CyclicBarrier(&lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;int&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;parties, Runnable barrierAction) {&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;}&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;java keyword&quot;&gt;public&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;CyclicBarrier(&lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;int&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;parties) {&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;}&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;参数parties指让多少个线程或者任务等待至barrier状态；参数barrierAction为当这些线程都达到barrier状态时会执行的内容。&lt;/p&gt;
&lt;p&gt;然后CyclicBarrier中最重要的方法就是await方法，它有2个重载版本：&lt;/p&gt;
&lt;div&gt;
&lt;div id=&quot;highlighter_902723&quot; class=&quot;syntaxhighlighter notranslate java&quot;&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;3.5&quot;&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;container&quot; readability=&quot;14&quot;&gt;
&lt;p&gt;&lt;code class=&quot;java keyword&quot;&gt;public&lt;/code&gt; &lt;code class=&quot;java keyword&quot;&gt;int&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;await()&lt;/code&gt; &lt;code class=&quot;java keyword&quot;&gt;throws&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;InterruptedException, BrokenBarrierException { };&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java keyword&quot;&gt;public&lt;/code&gt; &lt;code class=&quot;java keyword&quot;&gt;int&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;await(&lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;long&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;timeout, TimeUnit unit)&lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;throws&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;InterruptedException,BrokenBarrierException,TimeoutException { };&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;第一个版本比较常用，用来挂起当前线程，直至所有线程都到达barrier状态再同时执行后续任务；&lt;/p&gt;
&lt;p&gt;第二个版本是让这些线程等待至一定的时间，如果还有线程没有到达barrier状态就直接让到达barrier的线程执行后续任务。&lt;/p&gt;
&lt;p&gt;下面举几个例子就明白了：&lt;/p&gt;
&lt;p&gt;假若有若干个线程都要进行写数据操作，并且只有所有线程都完成写数据操作之后，这些线程才能继续做后面的事情，此时就可以利用CyclicBarrier了：&lt;/p&gt;
&lt;div&gt;
&lt;div id=&quot;highlighter_291504&quot; class=&quot;syntaxhighlighter notranslate java&quot;&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;3.5&quot;&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;p&gt;5&lt;/p&gt;
&lt;p&gt;6&lt;/p&gt;
&lt;p&gt;7&lt;/p&gt;
&lt;p&gt;8&lt;/p&gt;
&lt;p&gt;9&lt;/p&gt;
&lt;p&gt;10&lt;/p&gt;
&lt;p&gt;11&lt;/p&gt;
&lt;p&gt;12&lt;/p&gt;
&lt;p&gt;13&lt;/p&gt;
&lt;p&gt;14&lt;/p&gt;
&lt;p&gt;15&lt;/p&gt;
&lt;p&gt;16&lt;/p&gt;
&lt;p&gt;17&lt;/p&gt;
&lt;p&gt;18&lt;/p&gt;
&lt;p&gt;19&lt;/p&gt;
&lt;p&gt;20&lt;/p&gt;
&lt;p&gt;21&lt;/p&gt;
&lt;p&gt;22&lt;/p&gt;
&lt;p&gt;23&lt;/p&gt;
&lt;p&gt;24&lt;/p&gt;
&lt;p&gt;25&lt;/p&gt;
&lt;p&gt;26&lt;/p&gt;
&lt;p&gt;27&lt;/p&gt;
&lt;p&gt;28&lt;/p&gt;
&lt;p&gt;29&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;26.5&quot;&gt;
&lt;div class=&quot;container&quot; readability=&quot;52&quot;&gt;
&lt;p&gt;&lt;code class=&quot;java keyword&quot;&gt;public&lt;/code&gt; &lt;code class=&quot;java keyword&quot;&gt;class&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;Test {&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;public&lt;/code&gt; &lt;code class=&quot;java keyword&quot;&gt;static&lt;/code&gt; &lt;code class=&quot;java keyword&quot;&gt;void&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;main(String[] args) {&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;int&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;N =&lt;/code&gt; &lt;code class=&quot;java value&quot;&gt;4&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;CyclicBarrier barrier  =&lt;/code&gt; &lt;code class=&quot;java keyword&quot;&gt;new&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;CyclicBarrier(N);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;for&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;(&lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;int&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;i=&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;0&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;;i&amp;lt;N;i++)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;            &lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;new&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;Writer(barrier).start();&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;static&lt;/code&gt; &lt;code class=&quot;java keyword&quot;&gt;class&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;Writer&lt;/code&gt; &lt;code class=&quot;java keyword&quot;&gt;extends&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;Thread{&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;private&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;CyclicBarrier cyclicBarrier;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;public&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;Writer(CyclicBarrier cyclicBarrier) {&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;            &lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;this&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;.cyclicBarrier = cyclicBarrier;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;}&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;java color1&quot;&gt;@Override&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;public&lt;/code&gt; &lt;code class=&quot;java keyword&quot;&gt;void&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;run() {&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;            &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;System.out.println(&lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;&quot;线程&quot;&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;+Thread.currentThread().getName()+&lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;&quot;正在写入数据...&quot;&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;            &lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;try&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;{&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;                &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;Thread.sleep(&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;5000&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;);     &lt;/code&gt; &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;                &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;System.out.println(&lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;&quot;线程&quot;&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;+Thread.currentThread().getName()+&lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;&quot;写入数据完毕，等待其他线程写入完毕&quot;&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;                &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;cyclicBarrier.await();&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;            &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;}&lt;/code&gt; &lt;code class=&quot;java keyword&quot;&gt;catch&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;(InterruptedException e) {&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;                &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;e.printStackTrace();&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;            &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;}&lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;catch&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;(BrokenBarrierException e){&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;                &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;e.printStackTrace();&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;            &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;            &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;System.out.println(&lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;&quot;所有线程写入完毕，继续处理其他任务...&quot;&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;}&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;执行结果：&lt;/p&gt;
&lt;div&gt;
&lt;div&gt;
&lt;div id=&quot;highlighter_179884&quot; class=&quot;syntaxhighlighter notranslate java&quot;&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;3.5&quot;&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;p&gt;5&lt;/p&gt;
&lt;p&gt;6&lt;/p&gt;
&lt;p&gt;7&lt;/p&gt;
&lt;p&gt;8&lt;/p&gt;
&lt;p&gt;9&lt;/p&gt;
&lt;p&gt;10&lt;/p&gt;
&lt;p&gt;11&lt;/p&gt;
&lt;p&gt;12&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;15&quot;&gt;
&lt;div class=&quot;container&quot; readability=&quot;29&quot;&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;线程Thread-&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;0&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;正在写入数据...&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;线程Thread-&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;3&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;正在写入数据...&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;线程Thread-&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;2&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;正在写入数据...&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;线程Thread-&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;1&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;正在写入数据...&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;线程Thread-&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;2&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;写入数据完毕，等待其他线程写入完毕&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;线程Thread-&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;0&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;写入数据完毕，等待其他线程写入完毕&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;线程Thread-&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;3&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;写入数据完毕，等待其他线程写入完毕&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;线程Thread-&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;1&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;写入数据完毕，等待其他线程写入完毕&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;所有线程写入完毕，继续处理其他任务...&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;所有线程写入完毕，继续处理其他任务...&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;所有线程写入完毕，继续处理其他任务...&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;所有线程写入完毕，继续处理其他任务...&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;从上面输出结果可以看出，每个写入线程执行完写数据操作之后，就在等待其他线程写入操作完毕。&lt;/p&gt;
&lt;p&gt;当所有线程线程写入操作完毕之后，所有线程就继续进行后续的操作了。&lt;/p&gt;
&lt;p&gt;如果说想在所有线程写入操作完之后，进行额外的其他操作可以为CyclicBarrier提供Runnable参数：&lt;/p&gt;
&lt;div&gt;
&lt;div id=&quot;highlighter_445047&quot; class=&quot;syntaxhighlighter notranslate java&quot;&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr readability=&quot;8&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;p&gt;5&lt;/p&gt;
&lt;p&gt;6&lt;/p&gt;
&lt;p&gt;7&lt;/p&gt;
&lt;p&gt;8&lt;/p&gt;
&lt;p&gt;9&lt;/p&gt;
&lt;p&gt;10&lt;/p&gt;
&lt;p&gt;11&lt;/p&gt;
&lt;p&gt;12&lt;/p&gt;
&lt;p&gt;13&lt;/p&gt;
&lt;p&gt;14&lt;/p&gt;
&lt;p&gt;15&lt;/p&gt;
&lt;p&gt;16&lt;/p&gt;
&lt;p&gt;17&lt;/p&gt;
&lt;p&gt;18&lt;/p&gt;
&lt;p&gt;19&lt;/p&gt;
&lt;p&gt;20&lt;/p&gt;
&lt;p&gt;21&lt;/p&gt;
&lt;p&gt;22&lt;/p&gt;
&lt;p&gt;23&lt;/p&gt;
&lt;p&gt;24&lt;/p&gt;
&lt;p&gt;25&lt;/p&gt;
&lt;p&gt;26&lt;/p&gt;
&lt;p&gt;27&lt;/p&gt;
&lt;p&gt;28&lt;/p&gt;
&lt;p&gt;29&lt;/p&gt;
&lt;p&gt;30&lt;/p&gt;
&lt;p&gt;31&lt;/p&gt;
&lt;p&gt;32&lt;/p&gt;
&lt;p&gt;33&lt;/p&gt;
&lt;p&gt;34&lt;/p&gt;
&lt;p&gt;35&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;31.5&quot;&gt;
&lt;div class=&quot;container&quot; readability=&quot;62&quot;&gt;
&lt;p&gt;&lt;code class=&quot;java keyword&quot;&gt;public&lt;/code&gt; &lt;code class=&quot;java keyword&quot;&gt;class&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;Test {&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;public&lt;/code&gt; &lt;code class=&quot;java keyword&quot;&gt;static&lt;/code&gt; &lt;code class=&quot;java keyword&quot;&gt;void&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;main(String[] args) {&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;int&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;N =&lt;/code&gt; &lt;code class=&quot;java value&quot;&gt;4&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;CyclicBarrier barrier  =&lt;/code&gt; &lt;code class=&quot;java keyword&quot;&gt;new&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;CyclicBarrier(N,&lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;new&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;Runnable() {&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;            &lt;/code&gt;&lt;code class=&quot;java color1&quot;&gt;@Override&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;            &lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;public&lt;/code&gt; &lt;code class=&quot;java keyword&quot;&gt;void&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;run() {&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;                &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;System.out.println(&lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;&quot;当前线程&quot;&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;+Thread.currentThread().getName());  &lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;            &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;});&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;for&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;(&lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;int&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;i=&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;0&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;;i&amp;lt;N;i++)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;            &lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;new&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;Writer(barrier).start();&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;static&lt;/code&gt; &lt;code class=&quot;java keyword&quot;&gt;class&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;Writer&lt;/code&gt; &lt;code class=&quot;java keyword&quot;&gt;extends&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;Thread{&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;private&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;CyclicBarrier cyclicBarrier;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;public&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;Writer(CyclicBarrier cyclicBarrier) {&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;            &lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;this&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;.cyclicBarrier = cyclicBarrier;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;}&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;java color1&quot;&gt;@Override&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;public&lt;/code&gt; &lt;code class=&quot;java keyword&quot;&gt;void&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;run() {&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;            &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;System.out.println(&lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;&quot;线程&quot;&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;+Thread.currentThread().getName()+&lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;&quot;正在写入数据...&quot;&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;            &lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;try&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;{&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;                &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;Thread.sleep(&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;5000&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;);     &lt;/code&gt; &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;                &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;System.out.println(&lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;&quot;线程&quot;&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;+Thread.currentThread().getName()+&lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;&quot;写入数据完毕，等待其他线程写入完毕&quot;&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;                &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;cyclicBarrier.await();&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;            &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;}&lt;/code&gt; &lt;code class=&quot;java keyword&quot;&gt;catch&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;(InterruptedException e) {&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;                &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;e.printStackTrace();&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;            &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;}&lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;catch&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;(BrokenBarrierException e){&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;                &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;e.printStackTrace();&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;            &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;            &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;System.out.println(&lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;&quot;所有线程写入完毕，继续处理其他任务...&quot;&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;}&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;div&gt;
&lt;div&gt;
&lt;div id=&quot;highlighter_777361&quot; class=&quot;syntaxhighlighter notranslate java&quot;&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;3.5&quot;&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;p&gt;5&lt;/p&gt;
&lt;p&gt;6&lt;/p&gt;
&lt;p&gt;7&lt;/p&gt;
&lt;p&gt;8&lt;/p&gt;
&lt;p&gt;9&lt;/p&gt;
&lt;p&gt;10&lt;/p&gt;
&lt;p&gt;11&lt;/p&gt;
&lt;p&gt;12&lt;/p&gt;
&lt;p&gt;13&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;15&quot;&gt;
&lt;div class=&quot;container&quot; readability=&quot;29&quot;&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;线程Thread-&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;0&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;正在写入数据...&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;线程Thread-&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;1&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;正在写入数据...&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;线程Thread-&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;2&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;正在写入数据...&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;线程Thread-&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;3&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;正在写入数据...&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;线程Thread-&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;0&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;写入数据完毕，等待其他线程写入完毕&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;线程Thread-&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;1&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;写入数据完毕，等待其他线程写入完毕&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;线程Thread-&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;2&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;写入数据完毕，等待其他线程写入完毕&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;线程Thread-&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;3&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;写入数据完毕，等待其他线程写入完毕&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;当前线程Thread-&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;3&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;所有线程写入完毕，继续处理其他任务...&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;所有线程写入完毕，继续处理其他任务...&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;所有线程写入完毕，继续处理其他任务...&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;所有线程写入完毕，继续处理其他任务...&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;从结果可以看出，当四个线程都到达barrier状态后，会从四个线程中选择一个线程去执行Runnable。&lt;/p&gt;
&lt;p&gt;下面看一下为await指定时间的效果：&lt;/p&gt;
&lt;div&gt;
&lt;div id=&quot;highlighter_988321&quot; class=&quot;syntaxhighlighter notranslate java&quot;&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;4.5&quot;&gt;&lt;tr readability=&quot;9&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;p&gt;5&lt;/p&gt;
&lt;p&gt;6&lt;/p&gt;
&lt;p&gt;7&lt;/p&gt;
&lt;p&gt;8&lt;/p&gt;
&lt;p&gt;9&lt;/p&gt;
&lt;p&gt;10&lt;/p&gt;
&lt;p&gt;11&lt;/p&gt;
&lt;p&gt;12&lt;/p&gt;
&lt;p&gt;13&lt;/p&gt;
&lt;p&gt;14&lt;/p&gt;
&lt;p&gt;15&lt;/p&gt;
&lt;p&gt;16&lt;/p&gt;
&lt;p&gt;17&lt;/p&gt;
&lt;p&gt;18&lt;/p&gt;
&lt;p&gt;19&lt;/p&gt;
&lt;p&gt;20&lt;/p&gt;
&lt;p&gt;21&lt;/p&gt;
&lt;p&gt;22&lt;/p&gt;
&lt;p&gt;23&lt;/p&gt;
&lt;p&gt;24&lt;/p&gt;
&lt;p&gt;25&lt;/p&gt;
&lt;p&gt;26&lt;/p&gt;
&lt;p&gt;27&lt;/p&gt;
&lt;p&gt;28&lt;/p&gt;
&lt;p&gt;29&lt;/p&gt;
&lt;p&gt;30&lt;/p&gt;
&lt;p&gt;31&lt;/p&gt;
&lt;p&gt;32&lt;/p&gt;
&lt;p&gt;33&lt;/p&gt;
&lt;p&gt;34&lt;/p&gt;
&lt;p&gt;35&lt;/p&gt;
&lt;p&gt;36&lt;/p&gt;
&lt;p&gt;37&lt;/p&gt;
&lt;p&gt;38&lt;/p&gt;
&lt;p&gt;39&lt;/p&gt;
&lt;p&gt;40&lt;/p&gt;
&lt;p&gt;41&lt;/p&gt;
&lt;p&gt;42&lt;/p&gt;
&lt;p&gt;43&lt;/p&gt;
&lt;p&gt;44&lt;/p&gt;
&lt;p&gt;45&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;41&quot;&gt;
&lt;div class=&quot;container&quot; readability=&quot;81&quot;&gt;
&lt;p&gt;&lt;code class=&quot;java keyword&quot;&gt;public&lt;/code&gt; &lt;code class=&quot;java keyword&quot;&gt;class&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;Test {&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;public&lt;/code&gt; &lt;code class=&quot;java keyword&quot;&gt;static&lt;/code&gt; &lt;code class=&quot;java keyword&quot;&gt;void&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;main(String[] args) {&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;int&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;N =&lt;/code&gt; &lt;code class=&quot;java value&quot;&gt;4&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;CyclicBarrier barrier  =&lt;/code&gt; &lt;code class=&quot;java keyword&quot;&gt;new&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;CyclicBarrier(N);&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;for&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;(&lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;int&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;i=&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;0&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;;i&amp;lt;N;i++) {&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;            &lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;if&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;(i&amp;lt;N-&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;1&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;                &lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;new&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;Writer(barrier).start();&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;            &lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;else&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;{&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;                &lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;try&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;{&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;                    &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;Thread.sleep(&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;5000&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;                &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;}&lt;/code&gt; &lt;code class=&quot;java keyword&quot;&gt;catch&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;(InterruptedException e) {&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;                    &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;e.printStackTrace();&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;                &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;                &lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;new&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;Writer(barrier).start();&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;            &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;static&lt;/code&gt; &lt;code class=&quot;java keyword&quot;&gt;class&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;Writer&lt;/code&gt; &lt;code class=&quot;java keyword&quot;&gt;extends&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;Thread{&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;private&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;CyclicBarrier cyclicBarrier;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;public&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;Writer(CyclicBarrier cyclicBarrier) {&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;            &lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;this&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;.cyclicBarrier = cyclicBarrier;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;}&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;java color1&quot;&gt;@Override&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;public&lt;/code&gt; &lt;code class=&quot;java keyword&quot;&gt;void&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;run() {&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;            &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;System.out.println(&lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;&quot;线程&quot;&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;+Thread.currentThread().getName()+&lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;&quot;正在写入数据...&quot;&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;            &lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;try&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;{&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;                &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;Thread.sleep(&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;5000&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;);     &lt;/code&gt; &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;                &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;System.out.println(&lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;&quot;线程&quot;&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;+Thread.currentThread().getName()+&lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;&quot;写入数据完毕，等待其他线程写入完毕&quot;&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;                &lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;try&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;{&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;                    &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;cyclicBarrier.await(&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;2000&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;, TimeUnit.MILLISECONDS);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;                &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;}&lt;/code&gt; &lt;code class=&quot;java keyword&quot;&gt;catch&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;(TimeoutException e) {&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;                    &lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;                    &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;e.printStackTrace();&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;                &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;            &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;}&lt;/code&gt; &lt;code class=&quot;java keyword&quot;&gt;catch&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;(InterruptedException e) {&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;                &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;e.printStackTrace();&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;            &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;}&lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;catch&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;(BrokenBarrierException e){&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;                &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;e.printStackTrace();&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;            &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;            &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;System.out.println(Thread.currentThread().getName()+&lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;&quot;所有线程写入完毕，继续处理其他任务...&quot;&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;}&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;执行结果：&lt;/p&gt;
&lt;div&gt;
&lt;div&gt;
&lt;div id=&quot;highlighter_171626&quot; class=&quot;syntaxhighlighter notranslate java&quot;&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;3.5&quot;&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;p&gt;5&lt;/p&gt;
&lt;p&gt;6&lt;/p&gt;
&lt;p&gt;7&lt;/p&gt;
&lt;p&gt;8&lt;/p&gt;
&lt;p&gt;9&lt;/p&gt;
&lt;p&gt;10&lt;/p&gt;
&lt;p&gt;11&lt;/p&gt;
&lt;p&gt;12&lt;/p&gt;
&lt;p&gt;13&lt;/p&gt;
&lt;p&gt;14&lt;/p&gt;
&lt;p&gt;15&lt;/p&gt;
&lt;p&gt;16&lt;/p&gt;
&lt;p&gt;17&lt;/p&gt;
&lt;p&gt;18&lt;/p&gt;
&lt;p&gt;19&lt;/p&gt;
&lt;p&gt;20&lt;/p&gt;
&lt;p&gt;21&lt;/p&gt;
&lt;p&gt;22&lt;/p&gt;
&lt;p&gt;23&lt;/p&gt;
&lt;p&gt;24&lt;/p&gt;
&lt;p&gt;25&lt;/p&gt;
&lt;p&gt;26&lt;/p&gt;
&lt;p&gt;27&lt;/p&gt;
&lt;p&gt;28&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;31&quot;&gt;
&lt;div class=&quot;container&quot; readability=&quot;61&quot;&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;线程Thread-&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;0&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;正在写入数据...&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;线程Thread-&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;2&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;正在写入数据...&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;线程Thread-&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;1&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;正在写入数据...&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;线程Thread-&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;2&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;写入数据完毕，等待其他线程写入完毕&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;线程Thread-&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;0&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;写入数据完毕，等待其他线程写入完毕&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;线程Thread-&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;1&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;写入数据完毕，等待其他线程写入完毕&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;线程Thread-&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;3&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;正在写入数据...&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;java.util.concurrent.TimeoutException&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;Thread-&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;1&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;所有线程写入完毕，继续处理其他任务...&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;Thread-&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;0&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;所有线程写入完毕，继续处理其他任务...&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;at java.util.concurrent.CyclicBarrier.dowait(Unknown Source)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;at java.util.concurrent.CyclicBarrier.await(Unknown Source)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;at com.cxh.test1.Test$Writer.run(Test.java:&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;58&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;java.util.concurrent.BrokenBarrierException&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;at java.util.concurrent.CyclicBarrier.dowait(Unknown Source)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;at java.util.concurrent.CyclicBarrier.await(Unknown Source)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;at com.cxh.test1.Test$Writer.run(Test.java:&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;58&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;java.util.concurrent.BrokenBarrierException&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;at java.util.concurrent.CyclicBarrier.dowait(Unknown Source)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;at java.util.concurrent.CyclicBarrier.await(Unknown Source)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;at com.cxh.test1.Test$Writer.run(Test.java:&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;58&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;Thread-&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;2&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;所有线程写入完毕，继续处理其他任务...&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;java.util.concurrent.BrokenBarrierException&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;线程Thread-&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;3&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;写入数据完毕，等待其他线程写入完毕&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;at java.util.concurrent.CyclicBarrier.dowait(Unknown Source)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;at java.util.concurrent.CyclicBarrier.await(Unknown Source)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;at com.cxh.test1.Test$Writer.run(Test.java:&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;58&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;Thread-&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;3&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;所有线程写入完毕，继续处理其他任务...&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;上面的代码在main方法的for循环中，故意让最后一个线程启动延迟，因为在前面三个线程都达到barrier之后，等待了指定的时间发现第四个线程还没有达到barrier，就抛出异常并继续执行后面的任务。&lt;/p&gt;
&lt;p&gt;另外CyclicBarrier是可以重用的，看下面这个例子：&lt;/p&gt;
&lt;div&gt;
&lt;div id=&quot;highlighter_12205&quot; class=&quot;syntaxhighlighter notranslate java&quot;&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr readability=&quot;8&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;p&gt;5&lt;/p&gt;
&lt;p&gt;6&lt;/p&gt;
&lt;p&gt;7&lt;/p&gt;
&lt;p&gt;8&lt;/p&gt;
&lt;p&gt;9&lt;/p&gt;
&lt;p&gt;10&lt;/p&gt;
&lt;p&gt;11&lt;/p&gt;
&lt;p&gt;12&lt;/p&gt;
&lt;p&gt;13&lt;/p&gt;
&lt;p&gt;14&lt;/p&gt;
&lt;p&gt;15&lt;/p&gt;
&lt;p&gt;16&lt;/p&gt;
&lt;p&gt;17&lt;/p&gt;
&lt;p&gt;18&lt;/p&gt;
&lt;p&gt;19&lt;/p&gt;
&lt;p&gt;20&lt;/p&gt;
&lt;p&gt;21&lt;/p&gt;
&lt;p&gt;22&lt;/p&gt;
&lt;p&gt;23&lt;/p&gt;
&lt;p&gt;24&lt;/p&gt;
&lt;p&gt;25&lt;/p&gt;
&lt;p&gt;26&lt;/p&gt;
&lt;p&gt;27&lt;/p&gt;
&lt;p&gt;28&lt;/p&gt;
&lt;p&gt;29&lt;/p&gt;
&lt;p&gt;30&lt;/p&gt;
&lt;p&gt;31&lt;/p&gt;
&lt;p&gt;32&lt;/p&gt;
&lt;p&gt;33&lt;/p&gt;
&lt;p&gt;34&lt;/p&gt;
&lt;p&gt;35&lt;/p&gt;
&lt;p&gt;36&lt;/p&gt;
&lt;p&gt;37&lt;/p&gt;
&lt;p&gt;38&lt;/p&gt;
&lt;p&gt;39&lt;/p&gt;
&lt;p&gt;40&lt;/p&gt;
&lt;p&gt;41&lt;/p&gt;
&lt;p&gt;42&lt;/p&gt;
&lt;p&gt;43&lt;/p&gt;
&lt;p&gt;44&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;32.5&quot;&gt;
&lt;div class=&quot;container&quot; readability=&quot;64&quot;&gt;
&lt;p&gt;&lt;code class=&quot;java keyword&quot;&gt;public&lt;/code&gt; &lt;code class=&quot;java keyword&quot;&gt;class&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;Test {&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;public&lt;/code&gt; &lt;code class=&quot;java keyword&quot;&gt;static&lt;/code&gt; &lt;code class=&quot;java keyword&quot;&gt;void&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;main(String[] args) {&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;int&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;N =&lt;/code&gt; &lt;code class=&quot;java value&quot;&gt;4&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;CyclicBarrier barrier  =&lt;/code&gt; &lt;code class=&quot;java keyword&quot;&gt;new&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;CyclicBarrier(N);&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;for&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;(&lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;int&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;i=&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;0&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;;i&amp;lt;N;i++) {&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;            &lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;new&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;Writer(barrier).start();&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;}&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;try&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;{&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;            &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;Thread.sleep(&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;25000&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;}&lt;/code&gt; &lt;code class=&quot;java keyword&quot;&gt;catch&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;(InterruptedException e) {&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;            &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;e.printStackTrace();&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;}&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;System.out.println(&lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;&quot;CyclicBarrier重用&quot;&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;);&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;for&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;(&lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;int&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;i=&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;0&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;;i&amp;lt;N;i++) {&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;            &lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;new&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;Writer(barrier).start();&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;static&lt;/code&gt; &lt;code class=&quot;java keyword&quot;&gt;class&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;Writer&lt;/code&gt; &lt;code class=&quot;java keyword&quot;&gt;extends&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;Thread{&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;private&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;CyclicBarrier cyclicBarrier;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;public&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;Writer(CyclicBarrier cyclicBarrier) {&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;            &lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;this&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;.cyclicBarrier = cyclicBarrier;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;}&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;java color1&quot;&gt;@Override&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;public&lt;/code&gt; &lt;code class=&quot;java keyword&quot;&gt;void&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;run() {&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;            &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;System.out.println(&lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;&quot;线程&quot;&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;+Thread.currentThread().getName()+&lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;&quot;正在写入数据...&quot;&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;            &lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;try&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;{&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;                &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;Thread.sleep(&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;5000&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;);     &lt;/code&gt; &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;                &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;System.out.println(&lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;&quot;线程&quot;&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;+Thread.currentThread().getName()+&lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;&quot;写入数据完毕，等待其他线程写入完毕&quot;&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;);&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;                &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;cyclicBarrier.await();&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;            &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;}&lt;/code&gt; &lt;code class=&quot;java keyword&quot;&gt;catch&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;(InterruptedException e) {&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;                &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;e.printStackTrace();&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;            &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;}&lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;catch&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;(BrokenBarrierException e){&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;                &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;e.printStackTrace();&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;            &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;            &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;System.out.println(Thread.currentThread().getName()+&lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;&quot;所有线程写入完毕，继续处理其他任务...&quot;&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;}&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;执行结果：&lt;/p&gt;
&lt;div&gt;
&lt;div&gt;
&lt;div id=&quot;highlighter_171306&quot; class=&quot;syntaxhighlighter notranslate java&quot;&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;3.5&quot;&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;p&gt;5&lt;/p&gt;
&lt;p&gt;6&lt;/p&gt;
&lt;p&gt;7&lt;/p&gt;
&lt;p&gt;8&lt;/p&gt;
&lt;p&gt;9&lt;/p&gt;
&lt;p&gt;10&lt;/p&gt;
&lt;p&gt;11&lt;/p&gt;
&lt;p&gt;12&lt;/p&gt;
&lt;p&gt;13&lt;/p&gt;
&lt;p&gt;14&lt;/p&gt;
&lt;p&gt;15&lt;/p&gt;
&lt;p&gt;16&lt;/p&gt;
&lt;p&gt;17&lt;/p&gt;
&lt;p&gt;18&lt;/p&gt;
&lt;p&gt;19&lt;/p&gt;
&lt;p&gt;20&lt;/p&gt;
&lt;p&gt;21&lt;/p&gt;
&lt;p&gt;22&lt;/p&gt;
&lt;p&gt;23&lt;/p&gt;
&lt;p&gt;24&lt;/p&gt;
&lt;p&gt;25&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;27&quot;&gt;
&lt;div class=&quot;container&quot; readability=&quot;53&quot;&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;线程Thread-&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;0&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;正在写入数据...&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;线程Thread-&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;1&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;正在写入数据...&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;线程Thread-&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;3&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;正在写入数据...&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;线程Thread-&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;2&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;正在写入数据...&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;线程Thread-&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;1&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;写入数据完毕，等待其他线程写入完毕&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;线程Thread-&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;3&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;写入数据完毕，等待其他线程写入完毕&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;线程Thread-&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;2&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;写入数据完毕，等待其他线程写入完毕&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;线程Thread-&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;0&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;写入数据完毕，等待其他线程写入完毕&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;Thread-&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;0&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;所有线程写入完毕，继续处理其他任务...&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;Thread-&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;3&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;所有线程写入完毕，继续处理其他任务...&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;Thread-&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;1&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;所有线程写入完毕，继续处理其他任务...&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;Thread-&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;2&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;所有线程写入完毕，继续处理其他任务...&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;CyclicBarrier重用&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;线程Thread-&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;4&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;正在写入数据...&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;线程Thread-&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;5&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;正在写入数据...&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;线程Thread-&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;6&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;正在写入数据...&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;线程Thread-&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;7&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;正在写入数据...&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;线程Thread-&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;7&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;写入数据完毕，等待其他线程写入完毕&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;线程Thread-&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;5&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;写入数据完毕，等待其他线程写入完毕&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;线程Thread-&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;6&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;写入数据完毕，等待其他线程写入完毕&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;线程Thread-&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;4&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;写入数据完毕，等待其他线程写入完毕&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;Thread-&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;4&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;所有线程写入完毕，继续处理其他任务...&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;Thread-&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;5&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;所有线程写入完毕，继续处理其他任务...&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;Thread-&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;6&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;所有线程写入完毕，继续处理其他任务...&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;Thread-&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;7&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;所有线程写入完毕，继续处理其他任务...&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;从执行结果可以看出，在初次的4个线程越过barrier状态后，又可以用来进行新一轮的使用。而CountDownLatch无法进行重复使用。&lt;/p&gt;
&lt;h2&gt;三.Semaphore用法&lt;/h2&gt;
&lt;p&gt;Semaphore翻译成字面意思为 信号量，Semaphore可以控同时访问的线程个数，通过 acquire() 获取一个许可，如果没有就等待，而 release() 释放一个许可。&lt;/p&gt;
&lt;p&gt;Semaphore类位于java.util.concurrent包下，它提供了2个构造器：&lt;/p&gt;
&lt;div&gt;
&lt;div id=&quot;highlighter_520498&quot; class=&quot;syntaxhighlighter notranslate java&quot;&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;2.5&quot;&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;p&gt;5&lt;/p&gt;
&lt;p&gt;6&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;container&quot; readability=&quot;14&quot;&gt;
&lt;p&gt;&lt;code class=&quot;java keyword&quot;&gt;public&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;Semaphore(&lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;int&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;permits) {         &lt;/code&gt; &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;sync =&lt;/code&gt; &lt;code class=&quot;java keyword&quot;&gt;new&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;NonfairSync(permits);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java keyword&quot;&gt;public&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;Semaphore(&lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;int&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;permits,&lt;/code&gt; &lt;code class=&quot;java keyword&quot;&gt;boolean&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;fair) {   &lt;/code&gt; &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;sync = (fair)?&lt;/code&gt; &lt;code class=&quot;java keyword&quot;&gt;new&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;FairSync(permits) :&lt;/code&gt; &lt;code class=&quot;java keyword&quot;&gt;new&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;NonfairSync(permits);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;}&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;下面说一下Semaphore类中比较重要的几个方法，首先是acquire()、release()方法：&lt;/p&gt;
&lt;div&gt;
&lt;div id=&quot;highlighter_550618&quot; class=&quot;syntaxhighlighter notranslate java&quot;&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;7&quot;&gt;
&lt;div class=&quot;container&quot; readability=&quot;13&quot;&gt;
&lt;p&gt;&lt;code class=&quot;java keyword&quot;&gt;public&lt;/code&gt; &lt;code class=&quot;java keyword&quot;&gt;void&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;acquire()&lt;/code&gt; &lt;code class=&quot;java keyword&quot;&gt;throws&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;InterruptedException {  }    &lt;/code&gt; &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java keyword&quot;&gt;public&lt;/code&gt; &lt;code class=&quot;java keyword&quot;&gt;void&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;acquire(&lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;int&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;permits)&lt;/code&gt; &lt;code class=&quot;java keyword&quot;&gt;throws&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;InterruptedException { }   &lt;/code&gt; &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java keyword&quot;&gt;public&lt;/code&gt; &lt;code class=&quot;java keyword&quot;&gt;void&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;release() { }         &lt;/code&gt; &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java keyword&quot;&gt;public&lt;/code&gt; &lt;code class=&quot;java keyword&quot;&gt;void&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;release(&lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;int&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;permits) { }   &lt;/code&gt; &lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;acquire()用来获取一个许可，若无许可能够获得，则会一直等待，直到获得许可。&lt;/p&gt;
&lt;p&gt;release()用来释放许可。注意，在释放许可之前，必须先获获得许可。&lt;/p&gt;
&lt;p&gt;这4个方法都会被阻塞，如果想立即得到执行结果，可以使用下面几个方法：&lt;/p&gt;
&lt;div&gt;
&lt;div id=&quot;highlighter_130022&quot;&gt;
&lt;div&gt;
&lt;div id=&quot;highlighter_268966&quot; class=&quot;syntaxhighlighter notranslate java&quot;&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;3.5&quot;&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;9&quot;&gt;
&lt;div class=&quot;container&quot; readability=&quot;17&quot;&gt;
&lt;p&gt;&lt;code class=&quot;java keyword&quot;&gt;public&lt;/code&gt; &lt;code class=&quot;java keyword&quot;&gt;boolean&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;tryAcquire() { };   &lt;/code&gt; &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java keyword&quot;&gt;public&lt;/code&gt; &lt;code class=&quot;java keyword&quot;&gt;boolean&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;tryAcquire(&lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;long&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;timeout, TimeUnit unit)&lt;/code&gt; &lt;code class=&quot;java keyword&quot;&gt;throws&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;InterruptedException { }; &lt;/code&gt; &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java keyword&quot;&gt;public&lt;/code&gt; &lt;code class=&quot;java keyword&quot;&gt;boolean&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;tryAcquire(&lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;int&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;permits) { };&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java keyword&quot;&gt;public&lt;/code&gt; &lt;code class=&quot;java keyword&quot;&gt;boolean&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;tryAcquire(&lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;int&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;permits,&lt;/code&gt; &lt;code class=&quot;java keyword&quot;&gt;long&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;timeout, TimeUnit unit)&lt;/code&gt; &lt;code class=&quot;java keyword&quot;&gt;throws&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;InterruptedException { };&lt;/code&gt; &lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;另外还可以通过availablePermits()方法得到可用的许可数目。&lt;/p&gt;
&lt;p&gt;下面通过一个例子来看一下Semaphore的具体使用：&lt;/p&gt;
&lt;p&gt;假若一个工厂有5台机器，但是有8个工人，一台机器同时只能被一个工人使用，只有使用完了，其他工人才能继续使用。那么我们就可以通过Semaphore来实现：&lt;/p&gt;
&lt;div&gt;
&lt;div id=&quot;highlighter_86434&quot; class=&quot;syntaxhighlighter notranslate java&quot;&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;4.5&quot;&gt;&lt;tr readability=&quot;9&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;p&gt;5&lt;/p&gt;
&lt;p&gt;6&lt;/p&gt;
&lt;p&gt;7&lt;/p&gt;
&lt;p&gt;8&lt;/p&gt;
&lt;p&gt;9&lt;/p&gt;
&lt;p&gt;10&lt;/p&gt;
&lt;p&gt;11&lt;/p&gt;
&lt;p&gt;12&lt;/p&gt;
&lt;p&gt;13&lt;/p&gt;
&lt;p&gt;14&lt;/p&gt;
&lt;p&gt;15&lt;/p&gt;
&lt;p&gt;16&lt;/p&gt;
&lt;p&gt;17&lt;/p&gt;
&lt;p&gt;18&lt;/p&gt;
&lt;p&gt;19&lt;/p&gt;
&lt;p&gt;20&lt;/p&gt;
&lt;p&gt;21&lt;/p&gt;
&lt;p&gt;22&lt;/p&gt;
&lt;p&gt;23&lt;/p&gt;
&lt;p&gt;24&lt;/p&gt;
&lt;p&gt;25&lt;/p&gt;
&lt;p&gt;26&lt;/p&gt;
&lt;p&gt;27&lt;/p&gt;
&lt;p&gt;28&lt;/p&gt;
&lt;p&gt;29&lt;/p&gt;
&lt;p&gt;30&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;26.5&quot;&gt;
&lt;div class=&quot;container&quot; readability=&quot;52&quot;&gt;
&lt;p&gt;&lt;code class=&quot;java keyword&quot;&gt;public&lt;/code&gt; &lt;code class=&quot;java keyword&quot;&gt;class&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;Test {&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;public&lt;/code&gt; &lt;code class=&quot;java keyword&quot;&gt;static&lt;/code&gt; &lt;code class=&quot;java keyword&quot;&gt;void&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;main(String[] args) {&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;int&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;N =&lt;/code&gt; &lt;code class=&quot;java value&quot;&gt;8&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;;           &lt;/code&gt; &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;Semaphore semaphore =&lt;/code&gt; &lt;code class=&quot;java keyword&quot;&gt;new&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;Semaphore(&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;5&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;);&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;for&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;(&lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;int&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;i=&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;0&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;;i&amp;lt;N;i++)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;            &lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;new&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;Worker(i,semaphore).start();&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;}&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;static&lt;/code&gt; &lt;code class=&quot;java keyword&quot;&gt;class&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;Worker&lt;/code&gt; &lt;code class=&quot;java keyword&quot;&gt;extends&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;Thread{&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;private&lt;/code&gt; &lt;code class=&quot;java keyword&quot;&gt;int&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;num;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;private&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;Semaphore semaphore;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;public&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;Worker(&lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;int&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;num,Semaphore semaphore){&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;            &lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;this&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;.num = num;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;            &lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;this&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;.semaphore = semaphore;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;}&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;java color1&quot;&gt;@Override&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;public&lt;/code&gt; &lt;code class=&quot;java keyword&quot;&gt;void&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;run() {&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;            &lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;try&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;{&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;                &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;semaphore.acquire();&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;                &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;System.out.println(&lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;&quot;工人&quot;&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;+&lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;this&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;.num+&lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;&quot;占用一个机器在生产...&quot;&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;                &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;Thread.sleep(&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;2000&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;                &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;System.out.println(&lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;&quot;工人&quot;&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;+&lt;/code&gt;&lt;code class=&quot;java keyword&quot;&gt;this&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;.num+&lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;&quot;释放出机器&quot;&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;                &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;semaphore.release();          &lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;            &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;}&lt;/code&gt; &lt;code class=&quot;java keyword&quot;&gt;catch&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;(InterruptedException e) {&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;                &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;e.printStackTrace();&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;            &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;        &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java spaces&quot;&gt;    &lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;}&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;执行结果：&lt;/p&gt;
&lt;div&gt;
&lt;div&gt;
&lt;div id=&quot;highlighter_897025&quot; class=&quot;syntaxhighlighter notranslate java&quot;&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;3.5&quot;&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;p&gt;5&lt;/p&gt;
&lt;p&gt;6&lt;/p&gt;
&lt;p&gt;7&lt;/p&gt;
&lt;p&gt;8&lt;/p&gt;
&lt;p&gt;9&lt;/p&gt;
&lt;p&gt;10&lt;/p&gt;
&lt;p&gt;11&lt;/p&gt;
&lt;p&gt;12&lt;/p&gt;
&lt;p&gt;13&lt;/p&gt;
&lt;p&gt;14&lt;/p&gt;
&lt;p&gt;15&lt;/p&gt;
&lt;p&gt;16&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;11&quot;&gt;
&lt;div class=&quot;container&quot; readability=&quot;21&quot;&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;工人&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;0&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;占用一个机器在生产...&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;工人&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;1&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;占用一个机器在生产...&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;工人&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;2&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;占用一个机器在生产...&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;工人&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;4&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;占用一个机器在生产...&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;工人&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;5&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;占用一个机器在生产...&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;工人&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;0&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;释放出机器&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;工人&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;2&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;释放出机器&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;工人&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;3&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;占用一个机器在生产...&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;工人&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;7&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;占用一个机器在生产...&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;工人&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;4&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;释放出机器&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;工人&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;5&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;释放出机器&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;工人&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;1&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;释放出机器&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;工人&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;6&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;占用一个机器在生产...&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;工人&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;3&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;释放出机器&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;工人&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;7&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;释放出机器&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;java plain&quot;&gt;工人&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;6&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;释放出机器&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;下面对上面说的三个辅助类进行一个总结：&lt;/p&gt;
&lt;p&gt;1）CountDownLatch和CyclicBarrier都能够实现线程之间的等待，只不过它们侧重点不同：&lt;/p&gt;
&lt;p&gt;CountDownLatch一般用于某个线程A等待若干个其他线程执行完任务之后，它才执行；&lt;/p&gt;
&lt;p&gt;而CyclicBarrier一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行；&lt;/p&gt;
&lt;p&gt;另外，CountDownLatch是不能够重用的，而CyclicBarrier是可以重用的。&lt;/p&gt;
&lt;p&gt;2）Semaphore其实和锁有点类似，它一般用于控制对某组资源的访问权限。&lt;/p&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;p&gt;《&lt;span class=&quot;wp_keywordlink&quot;&gt;&lt;a class=&quot;external&quot; title=&quot;Java编程思想(第4版) &quot; href=&quot;http://www.amazon.cn/gp/product/B0011F7WU4/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;amp;camp=536&amp;amp;creative=3200&amp;amp;creativeASIN=B0011F7WU4&amp;amp;linkCode=as2&amp;amp;tag=importnew-23&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;Java编程思想&lt;/a&gt;》&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&quot;external&quot; href=&quot;http://www.itzhai.com/the-introduction-and-use-of-a-countdownlatch.html&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;http://www.itzhai.com/the-introduction-and-use-of-a-countdownlatch.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&quot;external&quot; href=&quot;http://leaver.me/archives/3220.html&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;http://leaver.me/archives/3220.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&quot;external&quot; href=&quot;http://developer.51cto.com/art/201403/432095.htm&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;http://developer.51cto.com/art/201403/432095.htm&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&quot;external&quot; href=&quot;http://blog.csdn.net/yanhandle/article/details/9016329&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;http://blog.csdn.net/yanhandle/article/details/9016329&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&quot;external&quot; href=&quot;http://blog.csdn.net/cutesource/article/details/5780740&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;http://blog.csdn.net/cutesource/article/details/5780740&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&quot;external&quot; href=&quot;http://www.cnblogs.com/whgw/archive/2011/09/29/2195555.html&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/whgw/archive/2011/09/29/2195555.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 18 Feb 2019 03:15:00 +0000</pubDate>
<dc:creator>华丽D转身</dc:creator>
<og:description>在java 1.5中，提供了一些非常有用的辅助类来帮助我们进行并发编程，比如CountDownLatch，CyclicBarrier和Semaphore，今天我们就来学习一下这三个辅助类的用法。 以下</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/snake23/p/10394499.html</dc:identifier>
</item>
</channel>
</rss>