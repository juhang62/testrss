<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>WAF开放规则定义权：专家策略+用户自定义策略=Web安全 - 阿里云云栖社区</title>
<link>http://www.cnblogs.com/yunqishequ/p/10559059.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yunqishequ/p/10559059.html</guid>
<description>&lt;p data-spm-anchor-id=&quot;a2c4e.11153940.blogcont692887.i0.38141906gvMRNO&quot;&gt;在第一期“漫说安全”栏目中，我们用四格漫画的形式介绍了基于深度学习的阿里云WAF到底智能在哪里，能帮客户解决什么问题。&lt;/p&gt;
&lt;p&gt;在今天的这期栏目里，我们依然通过漫画这种通俗易懂的方式，与大家分享阿里云WAF的另一大特点—开放。开放的云WAF到底有什么好处，答案就在漫画里^_^&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1482139/201903/1482139-20190319153619244-1005229053.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;漫画看完，安全君依旧准备了问答环节哦&lt;/p&gt;
&lt;p&gt;**客户：云盾WAF具有哪些开放特征？&lt;br/&gt;安全小二：1.开放的OpenAPI接口支持；2.自定义规则组配置；3.基于大数据的全量日志实时存储、分析服务。&lt;/p&gt;
&lt;p&gt;**客户：OpenAPI接口带来的最主要价值是什么？&lt;br/&gt;安全小二：支持快速程序化配置和第三方平台调用和集成，助力客户自动化安全运营和统一平台运营，提高工作效率。&lt;/p&gt;
&lt;p&gt;**客户：规则开放后为日常防护带来什么好处？&lt;br/&gt;安全小二：云盾WAF是国内首个做到将规则定义权交付给客户的，客户可以在专家策略基础之上，基于对自身业务的理解为每个资产定制专家经验防护规则集，以达到最精准的业务安全防护效果。&lt;/p&gt;
&lt;p&gt;**客户：日志存储和分析服务适用于哪些业务场景？&lt;br/&gt;安全小二：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;满足不低于6个月全量日志存储要求及安全法律法规要求；&lt;/li&gt;
&lt;li&gt;支持基于日志的安全和业务事件自动化分析告警，安全态势仪表盘订阅等日常自动化运维；&lt;/li&gt;
&lt;li&gt;提供日常安全运维、业务运营以及运营中心的态势实时大屏展示。&lt;/li&gt;
&lt;/ol&gt;&lt;p data-spm-anchor-id=&quot;a2c4e.11153940.blogcont692887.i1.38141906gvMRNO&quot;&gt;如果大家对云盾WAF的开放特点还有其他问题欢迎留言哦，安全小二将为您一一解答^_^&lt;/p&gt;

&lt;p&gt;一站式开发者服务，海量学习资源0元起！&lt;br/&gt;阿里热门开源项目、机器学习干货、开发者课程/工具、小微项目、移动研发等海量资源；更有开发者福利Kindle、技术图书幸运抽奖，100%中--》https://www.aliyun.com/acts/product-section-2019/developer?utm_content=g_1000047140&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://yq.aliyun.com/articles/692887?utm_content=g_1000047400&quot; target=&quot;_blank&quot;&gt;原文链接&lt;/a&gt;&lt;br/&gt;本文为云栖社区原创内容，未经允许不得转载。&lt;/p&gt;
</description>
<pubDate>Tue, 19 Mar 2019 07:37:00 +0000</pubDate>
<dc:creator>阿里云云栖社区</dc:creator>
<og:description>在第一期“漫说安全”栏目中，我们用四格漫画的形式介绍了基于深度学习的阿里云WAF到底智能在哪里，能帮客户解决什么问题。 在今天的这期栏目里，我们依然通过漫画这种通俗易懂的方式，与大家分享阿里云WAF的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yunqishequ/p/10559059.html</dc:identifier>
</item>
<item>
<title>Elasticsearch大规模时序索引如何治理和规划 - 土豆的奥特之父</title>
<link>http://www.cnblogs.com/xguo/p/10558828.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xguo/p/10558828.html</guid>
<description>&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;
&lt;div class=&quot;image-view&quot; data-width=&quot;1774&quot; data-height=&quot;874&quot;&gt;&lt;br class=&quot;Apple-interchange-newline&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/57355/201903/57355-20190319150128831-1072988120.png&quot; alt=&quot;&quot;/&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;什么是时序索引？&lt;/p&gt;
&lt;p&gt;其主要特点体现在两个方面，&lt;/p&gt;
&lt;p&gt;一存，以时间为轴，数据只有增加，没有变更，并且必须包含timestamp（日期时间，名称随意）字段，其作用和意义要大于数据的id字段，常见的数据比如我们通常要记录的操作日志、用户行为日志、或股市行情数据、服务器CPU、内存、网络的使用率等；&lt;/p&gt;
&lt;p&gt;二取，一定是以时间范围为第一过滤条件，然后是其它查询条件，比如近一天、一周、本月等等，然后在这个范围内进行二次过滤，比如性别或地域等，查询结果中比较关注的是每条数据和timestamp字段具体发生的时间点，而非id。&lt;/p&gt;
&lt;p&gt;此类数据一般用于OLAP、监控分析等场景。&lt;/p&gt;
&lt;p&gt;最近的一个项目是风控过程数据实时统计分析和聚合的一个OLAP分析监控平台，日流量峰值在10到12亿上下，每年数据约4000亿条，占用空间大概200T，面对这样一个数据量级的需求，我们的数据如何存储和实现实时查询将是一个严峻的挑战，经过对Elasticsearch多方调研和超过几百亿条数据的插入和聚合查询的验证之后，总结出以下几种能够有效提升性能和解决这一问题的方案，包括从集群规划、存储策略、索引拆分、压缩、冷热分区等几个维度的优化方案，在本文中逐一介绍，希望对你有所帮助和启发。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;本文所使用的Elasticsearch版本为5.3.3。&lt;/em&gt;&lt;/p&gt;
&lt;h2&gt;一，集群部署规划&lt;/h2&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1260&quot; data-height=&quot;774&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/57355/201903/57355-20190319150142795-2012206313.png&quot; alt=&quot;&quot;/&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;我们都知道在Elasticsearch（下称ES）集群中有两个主要角色，Master Node和Data Node，其它如Tribe Node等节点可根据业务需要另行设立。为了让集群有更好的性能表现，我们应该对这两个角色有一个更好的规划，在Nodes之间做读取分离，保证集群的稳定性和快速响应，在大规模的数据存储和查询的压力之下能够坦然面对，各自愉快的协作：）&lt;/p&gt;
&lt;h3&gt;Master Nodes&lt;/h3&gt;
&lt;p&gt;Master Node，整个集群的管理者，负有对index的管理、shards的分配，以及整个集群拓扑信息的管理等功能，众所周知，Master Node可以通过Data Node兼任，但是，如果对群集规模和稳定要求很高的话，就要职责分离，Master Node推荐独立，它状态关乎整个集群的存活，Master的配置&lt;/p&gt;
&lt;pre class=&quot;hljs bash&quot;&gt;
&lt;code class=&quot;bash&quot;&gt;node.master: &lt;span class=&quot;hljs-literal&quot;&gt;true 
node.data: &lt;span class=&quot;hljs-literal&quot;&gt;false 
node.ingest: &lt;span class=&quot;hljs-literal&quot;&gt;false
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样Master不参与I、O，从数据的搜索和索引操作中解脱出来，专门负责集群的管理工作，因此Master Node的节点配置可以相对低一些。&lt;/p&gt;
&lt;p&gt;另外防止ES集群 split brain（脑裂），合理配置discovery.zen.minimum_master_nodes参数，官方推荐master-eligible nodes / 2 + 1向下取整的个数，这个参数决定选举Master的Node个数，太小容易发生“脑裂”，可能会出现多个Master，太大Master将无法选举。&lt;/p&gt;
&lt;p&gt;更多Master选举相关内容请参考：&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/5.3/modules-discovery-zen.html#master-election&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;modules-discovery-zen#master-election&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Data Nodes&lt;/h3&gt;
&lt;p&gt;Data Node是数据的承载者，对索引的数据存储、查询、聚合等操作提供支持，这些操作严重消耗系统的CPU、内存、IO等资源，因此，应该把最好的资源分配给Data Node，因为它们是真正干累活的角色，同样Data Node也不兼任Master的功能，配置：&lt;/p&gt;
&lt;pre class=&quot;hljs bash&quot;&gt;
&lt;code class=&quot;bash&quot;&gt;node.master: &lt;span class=&quot;hljs-literal&quot;&gt;false 
node.data: &lt;span class=&quot;hljs-literal&quot;&gt;true 
node.ingest: &lt;span class=&quot;hljs-literal&quot;&gt;false
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3&gt;Coordinating Only Nodes&lt;/h3&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;992&quot; data-height=&quot;732&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/57355/201903/57355-20190319150155578-2071505935.png&quot; alt=&quot;&quot;/&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;ES本身是一个分布式的计算集群，每个Node都可以响应用户的请求，包括Master Node、Data Node，它们都有完整的cluster state信息，正如我们知道的一样，在某个Node收到用户请求的时候，会将请求转发到集群中所有索引相关的Node上，之后将每个Node的计算结果合并后返回给请求方，我们暂且将这个Node称为查询节点，整个过程跟分布式数据库原理类似。那问题来了，这个查询节点如果在并发和数据量比较大的情况下，由于数据的聚合可能会让内存和网络出现瓶颈，因此，在职责分离指导思想的前提下，这些操作我们也应该从这些角色中剥离出来，官方称它是 &lt;em&gt;coordinating nodes&lt;/em&gt;，只负责路由用户的请求，包括读、写等操作，对内存、网络和CPU要求比较高，本质上，coordinating only nodes可以笼统的理解为是一个负载均衡器，或者反向代理，只负责读，本身不写数据，它的配置是：&lt;/p&gt;
&lt;pre class=&quot;hljs css&quot;&gt;
&lt;code class=&quot;css&quot;&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;node&lt;span class=&quot;hljs-selector-class&quot;&gt;.master: &lt;span class=&quot;hljs-selector-tag&quot;&gt;false 
&lt;span class=&quot;hljs-selector-tag&quot;&gt;node&lt;span class=&quot;hljs-selector-class&quot;&gt;.data: &lt;span class=&quot;hljs-selector-tag&quot;&gt;false 
&lt;span class=&quot;hljs-selector-tag&quot;&gt;node&lt;span class=&quot;hljs-selector-class&quot;&gt;.ingest: &lt;span class=&quot;hljs-selector-tag&quot;&gt;false 
&lt;span class=&quot;hljs-selector-tag&quot;&gt;search&lt;span class=&quot;hljs-selector-class&quot;&gt;.remote&lt;span class=&quot;hljs-selector-class&quot;&gt;.connect: &lt;span class=&quot;hljs-selector-tag&quot;&gt;false
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;增加coordinating nodes的数量可以提高API请求响应的性能，我们也可以针对不同量级的index分配独立的coordinating nodes来满足请求性能，那是不是越多越好呢，在一定范围内是肯定的，但凡事有个度，过了负作用就会突显，太多的话会给集群增加负担，在做Master选举的时候会先确保所有Node的cluster state是一致的，同步的时候会等待每个Node的acknowledgement确认，所以适量分配可以让集群畅快的工作。&lt;/p&gt;
&lt;p&gt;search.remote.connect是禁用跨集群查询，防止在进行集群之间查询时发生二次路由，&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-cross-cluster-search.html&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;modules-cross-cluster-search&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;二，Routing&lt;/h2&gt;
&lt;p&gt;类似于分布式数据库中的分片原则，将符合规则的数据存储到同一分片。ES通过哈希算法来决定数据存储于哪个shard，&lt;/p&gt;
&lt;p&gt;&lt;code&gt;shard_num = hash(_routing) % num_primary_shards&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;其中hash(_routing)得出一个数字，然后除以主shards的数量得到一个余数，余数的范围是0到number_of_primary_shards - 1，这个数字就是文档所在的shard。&lt;/p&gt;
&lt;p&gt;Routing默认是id值，当然可以自定义，合理指定Routing能够大幅提升查询效率，Routing支持GET、Delete、Update、Post、Put等操作。&lt;/p&gt;
&lt;p&gt;如：&lt;/p&gt;
&lt;pre class=&quot;hljs bash&quot;&gt;
&lt;code class=&quot;bash&quot;&gt;PUT my_index/my_type/1?routing=user1
{
  &lt;span class=&quot;hljs-string&quot;&gt;&quot;title&quot;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;This is a document&quot;
}

GET my_index/my_type/1?routing=user1
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不指定Routing的查询过程：&lt;/p&gt;
&lt;div class=&quot;image-package&quot; readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;image-container&quot; readability=&quot;8&quot;&gt;
&lt;div class=&quot;image-view&quot; data-width=&quot;922&quot; data-height=&quot;624&quot;&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/57355/201903/57355-20190319150912594-483217921.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;p&gt;简单的来说，一个查询请求过来以后会查询每个shard，然后做结果聚合，总的时间大概就是所有shard查询所消耗的时间之和。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;指定Routing以后:&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;2178&quot; data-height=&quot;792&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/57355/201903/57355-20190319150654242-1720784452.png&quot; alt=&quot;&quot;/&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;会根据Routing查询特定的一个或多个shard，这样就大大减少了查询时间，提高了查询效率，当然，如何设置Routing是一个难点，需要一点技巧，要根据业务特点合理组合Routing的值，来划分shard的存储，最终保持数据量相对均衡。&lt;/p&gt;
&lt;p&gt;可以组合几个维度做为Routing ，有点类似于hbase key，例如不同的业务线加不同的类别，不同的城市和不同的类型等等，如&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;_search?routing=beijing按城市&lt;/li&gt;
&lt;li&gt;_search?routing=beijing_user123按城市和用户&lt;/li&gt;
&lt;li&gt;_search?routing=beijing_android,shanghai_android按城市和手机类型等。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;数据不均衡？&lt;/p&gt;
&lt;p&gt;假如你的业务在北京、上海的数据远远大于其它二三线城市的数据，再例如我们的业务场景，A业务线的数据量级远远大于B业务线，有时候很难通过Routing指定个一个值保证数据在所有shards上均匀分布，会让部分shard变的越来越大，影响查询性能，怎么办？&lt;/p&gt;
&lt;p&gt;一种解决办法是单独为这些数据量大的渠道创建独立的index，如&lt;code&gt;http://localhost:9200/shanghai,beijing,other/_search?routing=android&lt;/code&gt;，这样可以根据需要在不同index之间查询，然而每个index中shards的数据可以做到相对均衡。&lt;/p&gt;
&lt;p&gt;另一种办法是指定index参数index.routing_partition_size，来解决最终可能产生群集不均衡的问题，指定这个参数后新的算法如下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;shard_num = (hash(_routing) + hash(_id) % routing_partition_size) % num_primary_shards&lt;/code&gt;，&lt;/p&gt;
&lt;p&gt;index.routing_partition_size 应具有大于1且小于 index.number_of_shards 的值，最终数据会在routing_partition_size几个shard上均匀存储，是哪个shard取决于hash(_id) % routing_partition_size的计算结果。&lt;/p&gt;
&lt;p&gt;指定参数index.routing_partition_size后，索引中的mappings必须指定_routing为&quot;required&quot;: true，另外mappings不支持parent-child父子关系。&lt;/p&gt;
&lt;p&gt;很多情况下，指定Routing后会大幅提升查询性能，毕竟查询的shard只有那么几个，但是如何设置Routing是个难题，可根据业务特性巧妙组合。&lt;/p&gt;
&lt;h2&gt;三，索引拆分&lt;/h2&gt;
&lt;p&gt;Index通过横向扩展shards实现分布式存储，这样可以解决index大数据存储的问题，但在一个index变的越来越大，单个shard也越来越大，查询和存储的速度也越来越慢，更重要的是一个index其实是有存储上限的（除非你设置足够多的shards和机器），如官方声明单个shard的文档数不能超过20亿（受限于Lucene index，每个shard是一个Lucene index），考虑到I、O，针对index每个node的shards数最好不超过3个，那面对这样一个庞大的index，我们是采用更多的shards，还是更多的index我们如何选择，index的shards总量也不宜太多，更多的shards会带来更多的I、O开销，其实答案就已经很明确，除非你能接受长时间的查询等待。&lt;/p&gt;
&lt;p&gt;Index拆分的思路很简单，时序索引有一个好处就是只有增加，没有变更，按时间累积，天然对索引的拆分友好支持，可以按照时间和数据量做任意时间段的拆分，ES提供的Rollover Api + Index Template可以非常便捷和友好的实现index的拆分工作，把单个index docs数量控制在百亿内，也就是一个index默认5个shards左右即可，保证查询的即时响应。&lt;/p&gt;
&lt;p&gt;简单介绍一下Rollover Api 和 Index Template这两个东西，如何实现index的拆分&lt;/p&gt;
&lt;h3&gt;Index template&lt;/h3&gt;
&lt;p&gt;我们知道ES可以为同一目的或同一类索引创建一个Index template，之后创建的索引只要符合匹配规则就会套用这个template，不必每次指定settings和mappings等属性。&lt;/p&gt;
&lt;p&gt;一个index可以被多个template匹配，那settings和mappings就是多个template合并后的结果，有冲突通过template的属性&quot;order&quot; : 0从低到高覆盖（这部分据说会在ES6中会做调整，更好的解决template匹配冲突问题）。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre class=&quot;hljs bash&quot;&gt;
&lt;code class=&quot;bash&quot;&gt;PUT _template/template_1
{
    &lt;span class=&quot;hljs-string&quot;&gt;&quot;index_patterns&quot; : [&lt;span class=&quot;hljs-string&quot;&gt;&quot;log-*&quot;],
    &lt;span class=&quot;hljs-string&quot;&gt;&quot;order&quot; : 0,
    &lt;span class=&quot;hljs-string&quot;&gt;&quot;settings&quot; : {
        &lt;span class=&quot;hljs-string&quot;&gt;&quot;number_of_shards&quot; : 5
    },
    &lt;span class=&quot;hljs-string&quot;&gt;&quot;aliases&quot; : {
        &lt;span class=&quot;hljs-string&quot;&gt;&quot;alias1&quot; : {}
    }
}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3&gt;Rollover Index&lt;/h3&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;658&quot; data-height=&quot;196&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/57355/201903/57355-20190319150939277-1669288615.png&quot; alt=&quot;&quot;/&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Rollover Index可以将现有的索引通过一定的规则，如数据量和时间，索引的命名必须是logs-000001这种格式，并指定aliases，示例：&lt;/p&gt;
&lt;pre class=&quot;hljs bash&quot;&gt;
&lt;code class=&quot;bash&quot;&gt;PUT /logs-000001 
{
  &lt;span class=&quot;hljs-string&quot;&gt;&quot;aliases&quot;: {
    &lt;span class=&quot;hljs-string&quot;&gt;&quot;logs_write&quot;: {}
  }
}

&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;先创建索引并指定别名logs_write，插入1000条数据，然后请求_rollover api并指定拆分规则，如果索引中的数据大于规则中指定的数据量或者时间过时，新的索引将被创建，索引名称为logs-000002，并根据规则套用index template，同时别名logs_write也将被变更到logs-000002。&lt;/p&gt;
&lt;p&gt;注意事项：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;索引命名规则必须如同：logs-000001&lt;/li&gt;
&lt;li&gt;索引必须指定aliases&lt;/li&gt;
&lt;li&gt;Rollover Index Api调用时才去检查索引是否超出指定规则，不会自动触发，需要手动调用，可以通过&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/client/curator/current/installation.html&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;Curator&lt;/a&gt;实现自动化&lt;/li&gt;
&lt;li&gt;如果符合条件会创建新的索引，老索引的数据不会发生变化，如果你已经插入2000条，拆分后还是2000条&lt;/li&gt;
&lt;li&gt;插入数据时一定要用别名，否则你可能一直在往一个索引里追加数据&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;技巧：&lt;/p&gt;
&lt;p&gt;按日期滚动索引&lt;/p&gt;
&lt;pre class=&quot;hljs bash&quot;&gt;
&lt;code class=&quot;bash&quot;&gt;PUT /&amp;lt;logs-{now/d}-1&amp;gt;
{
  &lt;span class=&quot;hljs-string&quot;&gt;&quot;aliases&quot;: {
    &lt;span class=&quot;hljs-string&quot;&gt;&quot;logs_write&quot;: {}
  }
}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;假如生成的索引名为logs-2017.04.13-1，如果你在当天执行Rollover会生成logs-2017.04.13-000001，次日的话是logs-2017.04.14-000001。&lt;/p&gt;
&lt;p&gt;这样就会按日期进行切割索引，那如果你想查询3天内的数据可以通过日期规则来匹配索引名，如：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;GET /&amp;lt;logs-{now/d}-*&amp;gt;,&amp;lt;logs-{now/d-1d}-*&amp;gt;,&amp;lt;logs-{now/d-2d}-*&amp;gt;/_search&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;到此，我们就可以通过Index Template和Rollover Api实现对index的任意拆分，并按照需要进行任意时间段的合并查询，这样只要你的时间跨度不是很大，查询速度一般可以控制在毫秒级，存储性能也不会遇到瓶颈。&lt;/p&gt;
&lt;h2&gt;四，Hot-Warm架构&lt;/h2&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1350&quot; data-height=&quot;484&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/57355/201903/57355-20190319150950335-1988391964.png&quot; alt=&quot;&quot;/&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;冷热架构，为了保证大规模时序索引实时数据分析的时效性，可以根据资源配置不同将Data Nodes进行分类形成分层或分组架构，一部分支持新数据的读写，另一部分仅支持历史数据的存储，存放一些查询发生机率较低的数据，即Hot-Warm架构，对CPU，磁盘、内存等硬件资源合理的规划和利用，达到性能和效率的最大化。&lt;/p&gt;
&lt;p&gt;我们可以通过ES的Shard Allocation Filtering来实现Hot-Warm的架构。&lt;/p&gt;
&lt;p&gt;实现思路：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;将Data Node根据不同的资源配比打上标签，如：host、warm&lt;/li&gt;
&lt;li&gt;定义2个时序索引的index template，包括hot template和warm template，hot template可以多分配一些shard和拥有更好资源的Hot Node&lt;/li&gt;
&lt;li&gt;用hot template创建一个active index名为active-logs-1，别名active-logs，支持索引切割，插入一定数据后，通过roller over api将active-logs切割，并将切割前的index移动到warm nodes上，如active-logs-1，并阻止写入&lt;/li&gt;
&lt;li&gt;通过Shrinking API收缩索引active-logs-1为inactive-logs-1，原shard为5，适当收缩到2或3，可以在warm template中指定，减少检索的shard，使查询更快&lt;/li&gt;
&lt;li&gt;通过force-merging api合并inactive-logs-1索引每个shard的segment，节省存储空间&lt;/li&gt;
&lt;li&gt;删除active-logs-1&lt;/li&gt;
&lt;/ol&gt;&lt;h3&gt;Hot，Warm Nodes&lt;/h3&gt;
&lt;p&gt;Hot Nodes&lt;/p&gt;
&lt;p&gt;拥有最好资源的Data Nodes，如更高性能的CPU、SSD磁盘、内存等资源，这些特殊的Nodes支持索引所有的读、写操作，如果你计划以100亿为单位来切割index，那至少需要三个这样的Data Nodes，index的shard数为5，每个shard支持20亿documents数据的存储&lt;/p&gt;
&lt;p&gt;为这类Data Nodes打上标签，以便我们在template中识别和指定&lt;/p&gt;
&lt;p&gt;启动参数：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;./bin/elasticsearch -Enode.attr.box_type=hot&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;或者配置文件：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;node.attr.box_type: hot&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Warm Nodes&lt;/p&gt;
&lt;p&gt;存储只读数据，并且查询量较少，但用于存储长多时间历史数据的Data Nodes，这类Nodes相对Hot Nodes较差的硬件配置，根据需求配置稍差的CPU、机械磁盘和其它硬件资源，至于数量根据需要保留多长时间的数据来配比，同样需要打上标签，方法跟hot nodes一样，指定为warm，box_type: warm。&lt;/p&gt;
&lt;h3&gt;Hot，Warm Template&lt;/h3&gt;
&lt;p&gt;Hot Template&lt;/p&gt;
&lt;p&gt;我们可以通过指定参数&quot;routing.allocation.include.box_type&quot;: &quot;hot&quot;，让所有符合命名规则索引的shard都将被分配到hot nodes上。&lt;/p&gt;
&lt;pre class=&quot;hljs bash&quot;&gt;
&lt;code class=&quot;bash&quot;&gt;PUT _template/active-logs
{
  &lt;span class=&quot;hljs-string&quot;&gt;&quot;template&quot;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;active-logs-*&quot;,
  &lt;span class=&quot;hljs-string&quot;&gt;&quot;settings&quot;: {
    &lt;span class=&quot;hljs-string&quot;&gt;&quot;number_of_shards&quot;:   5,
    &lt;span class=&quot;hljs-string&quot;&gt;&quot;number_of_replicas&quot;: 1,
    &lt;span class=&quot;hljs-string&quot;&gt;&quot;routing.allocation.include.box_type&quot;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;hot&quot;,
    &lt;span class=&quot;hljs-string&quot;&gt;&quot;routing.allocation.total_shards_per_node&quot;: 2
  },
  &lt;span class=&quot;hljs-string&quot;&gt;&quot;aliases&quot;: {
    &lt;span class=&quot;hljs-string&quot;&gt;&quot;active-logs&quot;:  {}
  }
}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Warm Template&lt;/p&gt;
&lt;p&gt;同样符合命名规则索引的shard会被分配到warm nodes上，我们指定了更少的shards数量和复本数，注意，这里的复本数为0，和best_compression级别的压缩，方便做迁移等操作，以及进行一些数据的压缩。&lt;/p&gt;
&lt;pre class=&quot;hljs bash&quot;&gt;
&lt;code class=&quot;bash&quot;&gt;PUT _template/inactive-logs
{
  &lt;span class=&quot;hljs-string&quot;&gt;&quot;template&quot;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;inactive-logs-*&quot;,
  &lt;span class=&quot;hljs-string&quot;&gt;&quot;settings&quot;: {
    &lt;span class=&quot;hljs-string&quot;&gt;&quot;number_of_shards&quot;:   1,
    &lt;span class=&quot;hljs-string&quot;&gt;&quot;number_of_replicas&quot;: 0,
    &lt;span class=&quot;hljs-string&quot;&gt;&quot;routing.allocation.include.box_type&quot;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;warm&quot;,
    &lt;span class=&quot;hljs-string&quot;&gt;&quot;codec&quot;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;best_compression&quot;
  }
}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;假如我们已经创建了索引active-logs-1 ，当然你可以通过_bulk API快速写入测试的数据，然后参考上文中介绍的rollover api进行切割。&lt;/p&gt;
&lt;h3&gt;Shrink Index&lt;/h3&gt;
&lt;p&gt;Rollover api切割以后，active-logs-1将变成一个冷索引，我们将它移动到warm nodes上，先将索引置为只读状态，拒绝任何写入操作，然后修改index.routing.allocation.include.box_type属性，ES会自动移动所有shards到目标Data Nodes上。&lt;/p&gt;
&lt;pre class=&quot;hljs bash&quot;&gt;
&lt;code class=&quot;bash&quot;&gt;PUT active-logs-1/_settings
{
  &lt;span class=&quot;hljs-string&quot;&gt;&quot;index.blocks.write&quot;: &lt;span class=&quot;hljs-literal&quot;&gt;true,
  &lt;span class=&quot;hljs-string&quot;&gt;&quot;index.routing.allocation.include.box_type&quot;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;warm&quot;
}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/master/cluster-health.html&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;cluster health API&lt;/a&gt;可以查看迁移状态，完成后进行收缩操作，其实相当于复制出来一个新的索引，旧的索引还存在。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;POST active-logs-1/_shrink/inactive-logs-1&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;我们可以通过Head插件查看整个集群索引的变化情况。&lt;/p&gt;
&lt;p&gt;关于shard的分配请参考&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/current/shard-allocation-filtering.html&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;Shard Allocation Filtering&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Forcemerge&lt;/p&gt;
&lt;p&gt;到目前为止我们已经实现了索引的冷热分离，和索引的收缩，我们知道每个shard下面由多个segment组成，那inactive-logs-1的shard数是1，但segment还是多个。&lt;/p&gt;
&lt;p&gt;这类索引不会在接受写入操作，为了节约空间和改善查询性能，通过Forcemerge Api将segment适量合并，&lt;/p&gt;
&lt;pre class=&quot;hljs bash&quot;&gt;
&lt;code class=&quot;bash&quot;&gt;PUT inactive-logs-1/_settings
{ &lt;span class=&quot;hljs-string&quot;&gt;&quot;number_of_replicas&quot;: 1 }
&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ES的Forcemerge过程是先创建新的segment删除旧的，所以旧segment的压缩方式best_compression不会在新的segment中生效，新的segment还是默认的压缩方式。&lt;/p&gt;
&lt;p&gt;现在inactive-logs-1的复本是还是0，如果有需要的话，可以分配新的复本数&lt;/p&gt;
&lt;pre class=&quot;hljs bash&quot;&gt;
&lt;code class=&quot;bash&quot;&gt;PUT inactive-logs-1/_settings
{ &lt;span class=&quot;hljs-string&quot;&gt;&quot;number_of_replicas&quot;: 1 }
&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后删除active-logs-1，因为我们已经为它做了一个查询复本inactive-logs-1，&lt;/p&gt;
&lt;p&gt;DELETE active-logs-1&lt;/p&gt;
&lt;p&gt;走到这里，我们就已经实现了index的Hot-Warm架构，根据业务特点将一段时间的数据放在Hot Nodes，更多的历史数据存储于Warm Nodes。&lt;/p&gt;
&lt;h2&gt;五，其它优化方案&lt;/h2&gt;
&lt;h3&gt;索引隔离&lt;/h3&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1664&quot; data-height=&quot;830&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/57355/201903/57355-20190319151004406-702768269.png&quot; alt=&quot;&quot;/&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;在多条业务线的索引共用一个ES集群时会发生流量被独吃独占的情况，因为大家都共用相同的集群资源，流量大的索引会占用大部分计算资源而流量小的也会被拖慢，得不到即时响应，或者说业务流量大的索引可以按天拆分，几个流量小的索引可以按周或月拆分。&lt;/p&gt;
&lt;p&gt;这种情况下我们可以将规模大的索引和其它相对小规模的索引独立存储，分开查询或合并查询，除了Master Nodes以外，Data Nodes和Coordinating Nodes都可以独立使用（其实如果每个索引的量都特别大也应该采用这种架构），还有一个好处是对方的某个Node挂掉，自己不受影响。&lt;/p&gt;
&lt;p&gt;同样利用ES支持Shard Allocation Filtering功能来实现索引的资源独立分配，先将nodes进行打标签，划分区域，类似于Hot-Warm架构node.attr.zone=zone_a、node.attr.zone=zone_b&lt;/p&gt;
&lt;p&gt;或者&lt;/p&gt;
&lt;p&gt;&lt;code&gt;node.attr.zone =zone_hot_a、node.attr.zone=zone_hot_b&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;等打标签的方式来区别对应不同的索引，然后在各自的index template中指定不同的node.attr.zone即可，如&quot;index.routing.allocation.include.zone&quot; : &quot;zone_a,zone_hot_a&quot;，&lt;/p&gt;
&lt;p&gt;或者排除法&quot;index.routing.allocation.exclude.size&quot;: &quot;zone_hot_b&quot;&lt;/p&gt;
&lt;p&gt;分配到zone_hot_b以外的所有Data Nodes上。&lt;/p&gt;
&lt;p&gt;更多用法可以参考Hot-Warm架构，或&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/current/shard-allocation-filtering.html&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;shard-allocation-filtering&lt;/a&gt;。&lt;/p&gt;
&lt;h3&gt;跨数据中心&lt;/h3&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1844&quot; data-height=&quot;974&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/57355/201903/57355-20190319151019591-581968250.png&quot; alt=&quot;&quot;/&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;如果你的业务遍布全国各地，四海八荒，如果你数据要存储到多个机房，如果你的index有几万个甚至更多（ index特别多，集群庞大会导致cluster state信息量特变大，因为cluster state包含了所有shard、index、node等所有相关信息，它存储在每个node上，这些数据发生变化都会实时同步到所有node上，当这个数据很大的时候会对集群的性能造成影响），这些情况下我们会考虑部署多个es cluster，那我们将如何解决跨集群查询的问题呢？目前es针对跨集群操作提供了两种方案Tribe node和Cross Cluster Search。&lt;/p&gt;
&lt;p&gt;Tribe node&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1850&quot; data-height=&quot;992&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/57355/201903/57355-20190319151030806-2094840448.png&quot; alt=&quot;&quot;/&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;需要一个独立的node节点，加入其它es cluster，用法有点类似于Coordinating Only Node，所不同的是tribe是针对多个es集群之间的所有节点，tribe node收到请求广播到相关集群中所有节点，将结果合并处理后返回，表面上看起来tribe node将多个集群串连成一个了一个整体，遇到同名index发生冲突，会选择其中一个index，也可以指定。&lt;/p&gt;
&lt;pre class=&quot;hljs css&quot;&gt;
&lt;code class=&quot;css&quot;&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;tribe:
  &lt;span class=&quot;hljs-selector-tag&quot;&gt;on_conflict: &lt;span class=&quot;hljs-selector-tag&quot;&gt;prefer_t1
  &lt;span class=&quot;hljs-selector-tag&quot;&gt;t1:
    &lt;span class=&quot;hljs-selector-tag&quot;&gt;cluster&lt;span class=&quot;hljs-selector-class&quot;&gt;.name: &lt;span class=&quot;hljs-selector-tag&quot;&gt;us-cluster
    &lt;span class=&quot;hljs-selector-tag&quot;&gt;discovery&lt;span class=&quot;hljs-selector-class&quot;&gt;.zen&lt;span class=&quot;hljs-selector-class&quot;&gt;.ping&lt;span class=&quot;hljs-selector-class&quot;&gt;.multicast&lt;span class=&quot;hljs-selector-class&quot;&gt;.enabled: &lt;span class=&quot;hljs-selector-tag&quot;&gt;false
    &lt;span class=&quot;hljs-selector-tag&quot;&gt;discovery&lt;span class=&quot;hljs-selector-class&quot;&gt;.zen&lt;span class=&quot;hljs-selector-class&quot;&gt;.ping&lt;span class=&quot;hljs-selector-class&quot;&gt;.unicast&lt;span class=&quot;hljs-selector-class&quot;&gt;.hosts: &lt;span class=&quot;hljs-selector-attr&quot;&gt;['usm1','usm2','usm3']
  &lt;span class=&quot;hljs-selector-tag&quot;&gt;t2:
    &lt;span class=&quot;hljs-selector-tag&quot;&gt;cluster&lt;span class=&quot;hljs-selector-class&quot;&gt;.name: &lt;span class=&quot;hljs-selector-tag&quot;&gt;eu-cluster
    &lt;span class=&quot;hljs-selector-tag&quot;&gt;discovery&lt;span class=&quot;hljs-selector-class&quot;&gt;.zen&lt;span class=&quot;hljs-selector-class&quot;&gt;.ping&lt;span class=&quot;hljs-selector-class&quot;&gt;.multicast&lt;span class=&quot;hljs-selector-class&quot;&gt;.enabled: &lt;span class=&quot;hljs-selector-tag&quot;&gt;false
    &lt;span class=&quot;hljs-selector-tag&quot;&gt;discovery&lt;span class=&quot;hljs-selector-class&quot;&gt;.zen&lt;span class=&quot;hljs-selector-class&quot;&gt;.ping&lt;span class=&quot;hljs-selector-class&quot;&gt;.unicast&lt;span class=&quot;hljs-selector-class&quot;&gt;.hosts: &lt;span class=&quot;hljs-selector-attr&quot;&gt;['eum1','eum2','eum3']
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Cross Cluster Search&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1796&quot; data-height=&quot;1004&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/57355/201903/57355-20190319151043113-533509289.png&quot; alt=&quot;&quot;/&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Cross Cluster Search可以让集群中的任意一个节点联合查询其它集群中的数据， 通过配置elasticsearch.yml或者API来启用这个功能，API示例&lt;/p&gt;
&lt;pre class=&quot;hljs bash&quot;&gt;
&lt;code class=&quot;bash&quot;&gt;PUT _cluster/settings
{
  &lt;span class=&quot;hljs-string&quot;&gt;&quot;persistent&quot;: {
    &lt;span class=&quot;hljs-string&quot;&gt;&quot;search&quot;: {
      &lt;span class=&quot;hljs-string&quot;&gt;&quot;remote&quot;: {
        &lt;span class=&quot;hljs-string&quot;&gt;&quot;cluster_one&quot;: {
          &lt;span class=&quot;hljs-string&quot;&gt;&quot;seeds&quot;: [
            &lt;span class=&quot;hljs-string&quot;&gt;&quot;127.0.0.1:9300&quot;
          ]
    ...
        }
      }
    }
  }
}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;提交以后整个集群所有节点都会生效，都可以做为代理去做跨集群联合查询，不过我们最好还是通过Coordinating Only Nodes去发起请求。&lt;/p&gt;
&lt;pre class=&quot;hljs bash&quot;&gt;
&lt;code class=&quot;bash&quot;&gt;POST /cluster_one:decision,decision/_search
{
    &lt;span class=&quot;hljs-string&quot;&gt;&quot;match_all&quot;: {}
}
&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对集群cluster_one和本集群中名为decision的索引联合查询。&lt;/p&gt;
&lt;p&gt;目前这个功能还在测试阶段，但未来可能会取代tribe node，之间的最大的差异是tribe node需要设置独立的节点，而Cross Cluster Search不需要，集群中的任意一个节点都可以兼任，比如可以用我们的Coordinating Only Nodes做为联合查询节点，另一个优点是配置是动态的，不需要重启节点，实际上可以理解为是一个ES集群之间特定的动态代理工具，支持所有操作，包括index的创建和修改，并且通过namespace对index进行隔离，也解决了tribe node之index名称冲突的问题。&lt;/p&gt;
&lt;h2&gt;小结&lt;/h2&gt;
&lt;p&gt;我们在文中介绍了几种方案用来解决时序索引的海量数据存储和查询的问题，根据业务特点和使用场景来单独或组合使用能够发挥出意想不到的效果，特别是nodes之间的读写分离、索引拆分、Hot-Warm等方案的组合应用对索引的查询和存储性能有显著的提升，另外routing在新版本中增加了routing_partition_size解决了shard难以均衡的问题，如果你的索引mapping中没有parent-child关联关系可以考虑使用，对查询的性能提升非常有效。&lt;/p&gt;
&lt;p&gt;本文参考内容：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/blog/hot-warm-architecture-in-elasticsearch-5-x&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;hot-warm-architecture-in-elasticsearch-5-x&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/blog/managing-time-based-indices-efficiently&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;managing-time-based-indices-efficiently&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/elasticon/conf/2017/sf/what-is-evolving-in-elasticsearch&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;what-is-evolving-in-elasticsearch&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Tue, 19 Mar 2019 07:19:00 +0000</pubDate>
<dc:creator>土豆的奥特之父</dc:creator>
<og:description>什么是时序索引？ 其主要特点体现在两个方面， 一存，以时间为轴，数据只有增加，没有变更，并且必须包含timestamp（日期时间，名称随意）字段，其作用和意义要大于数据的id字段，常见的数据比如我们通</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xguo/p/10558828.html</dc:identifier>
</item>
<item>
<title>kerberos环境下spark消费kafka写入到Hbase - 微信-大数据从业者</title>
<link>http://www.cnblogs.com/felixzh/p/10558674.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/felixzh/p/10558674.html</guid>
<description>&lt;h3&gt;一、准备环境： 创建Kafka Topic和HBase表&lt;/h3&gt;
&lt;h4&gt;1. 在kerberos环境下创建Kafka Topic&lt;/h4&gt;
&lt;p&gt;1.1 因为kafka默认使用的协议为PLAINTEXT，在kerberos环境下需要变更其通信协议： 在${KAFKA_HOME}/&lt;code&gt;config/producer.properties&lt;/code&gt;和&lt;code&gt;config/consumer.properties&lt;/code&gt;下添加&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
security.protocol=SASL_PLAINTEXT
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;1.2 在执行前，需要在环境变量中添加KAFKA_OPT选项，否则kafka无法使用keytab：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
export KAFKA_OPTS=&quot;$KAFKA_OPTS -Djava.security.auth.login.config=/usr/ndp/current/kafka_broker/conf/kafka_jaas.conf&quot;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中&lt;code&gt;kafka_jaas.conf&lt;/code&gt;内容如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
cat /usr/ndp/current/kafka_broker/conf/&lt;span&gt;kafka_jaas.conf

KafkaServer {
com.sun.security.auth.module.Krb5LoginModule required
useKeyTab&lt;/span&gt;=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
keyTab&lt;/span&gt;=&quot;/etc/security/keytabs/kafka.service.keytab&quot;&lt;span&gt;
storeKey&lt;/span&gt;=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
useTicketCache&lt;/span&gt;=&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
serviceName&lt;/span&gt;=&quot;kafka&quot;&lt;span&gt;
principal&lt;/span&gt;=&quot;kafka/hzadg-mammut-platform3.server.163.org@BDMS.163.COM&quot;&lt;span&gt;;
};
KafkaClient {
com.sun.security.auth.module.Krb5LoginModule required
useTicketCache&lt;/span&gt;=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
renewTicket&lt;/span&gt;=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
serviceName&lt;/span&gt;=&quot;kafka&quot;&lt;span&gt;;
};
Client {
com.sun.security.auth.module.Krb5LoginModule required
useKeyTab&lt;/span&gt;=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
keyTab&lt;/span&gt;=&quot;/etc/security/keytabs/kafka.service.keytab&quot;&lt;span&gt;
storeKey&lt;/span&gt;=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
useTicketCache&lt;/span&gt;=&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
serviceName&lt;/span&gt;=&quot;zookeeper&quot;&lt;span&gt;
principal&lt;/span&gt;=&quot;kafka/hzadg-mammut-platform3.server.163.org@BDMS.163.COM&quot;&lt;span&gt;;
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;1.3 创建新的topic：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
bin/kafka-topics.sh --create --zookeeper hzadg-mammut-platform2.server.163.org:2181,hzadg-mammut-platform3.server.163.org:2181 --replication-factor 1 --partitions 1 --topic spark-test
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;1.4 创建生产者：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
bin/kafka-console-producer.sh  --broker-list hzadg-mammut-platform2.server.163.org:6667,hzadg-mammut-platform3.server.163.org:6667,hzadg-mammut-platform4.server.163.org:6667 --topic spark-test --producer.config ./config/producer.properties
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;1.5 测试消费者：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
bin/kafka-console-consumer.sh --zookeeper hzadg-mammut-platform2.server.163.org:2181,hzadg-mammut-platform3.server.163.org:2181 --bootstrap-server hzadg-mammut-platform2.server.163.org:6667 --topic spark-test --from-beginning --&lt;span&gt;new&lt;/span&gt;-consumer  --consumer.config ./config/consumer.properties
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;2. 创建HBase表&lt;/h4&gt;
&lt;p&gt;2.1 kinit到hbase账号，否则无法创建hbase表&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
kinit -kt /etc/security/keytabs/hbase.service.keytab hbase/hzadg-mammut-platform2.server.163.org@BDMS.163.COM
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
 ./bin/&lt;span&gt;hbase shell
&lt;/span&gt;&amp;gt; create 'recsys_logs', 'f'
&lt;/pre&gt;&lt;/div&gt;

&lt;blockquote&gt;

&lt;/blockquote&gt;
&lt;pre class=&quot;hljs bash&quot;&gt;
&lt;/pre&gt;
&lt;h3&gt;二、编写Spark代码&lt;/h3&gt;
&lt;p&gt;编写简单的Spark Java程序，功能为: 从Kafka消费信息，同时将batch内统计的数量写入Hbase中，具体可以参考项目：&lt;/p&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://link.jianshu.com?t=https%3A%2F%2Fgithub.com%2FLiShuMing%2Fspark-demos&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;https://github.com/LiShuMing/spark-demos&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *    &lt;/span&gt;&lt;span&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/span&gt;&lt;span&gt;
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.netease.spark.streaming.hbase;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.netease.spark.utils.Consts;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.netease.spark.utils.JConfig;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.hadoop.conf.Configuration;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.hadoop.hbase.HBaseConfiguration;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.hadoop.hbase.client.HConnection;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.hadoop.hbase.client.HConnectionManager;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.hadoop.hbase.client.HTableInterface;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.hadoop.hbase.client.Put;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.hadoop.hbase.util.Bytes;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.kafka.clients.consumer.ConsumerRecord;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.kafka.common.serialization.StringDeserializer;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.spark.SparkConf;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.spark.api.java.JavaRDD;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.spark.api.java.function.Function;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.spark.api.java.function.VoidFunction;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.spark.streaming.Duration;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.spark.streaming.api.java.JavaDStream;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.spark.streaming.api.java.JavaInputDStream;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.spark.streaming.api.java.JavaStreamingContext;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.spark.streaming.kafka010.ConsumerStrategies;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.spark.streaming.kafka010.KafkaUtils;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.spark.streaming.kafka010.LocationStrategies;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.slf4j.Logger;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.slf4j.LoggerFactory;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.IOException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.text.SimpleDateFormat;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Arrays;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Date;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.HashMap;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.HashSet;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Map;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Set;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; JavaKafkaToHBaseKerberos {
  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Logger LOGGER = LoggerFactory.getLogger(JavaKafkaToHBaseKerberos.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);

  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; HConnection connection = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; HTableInterface table = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; openHBase(String tablename) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
    Configuration conf &lt;/span&gt;=&lt;span&gt; HBaseConfiguration.create();
    &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt; (HConnection.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;) {
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (connection == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
        connection &lt;/span&gt;=&lt;span&gt; HConnectionManager.createConnection(conf);
    }

    &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt; (HTableInterface.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;) {
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (table == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
        table &lt;/span&gt;= connection.getTable(&quot;recsys_logs&quot;&lt;span&gt;);
      }
    }
  }

  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; closeHBase() {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (table != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
      &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
        table.close();
      } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
        LOGGER.error(&lt;/span&gt;&quot;关闭 table 出错&quot;&lt;span&gt;, e);
      }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (connection != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
      &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
        connection.close();
      } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
        LOGGER.error(&lt;/span&gt;&quot;关闭 connection 出错&quot;&lt;span&gt;, e);
      }
  }

  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
    String hbaseTable &lt;/span&gt;=&lt;span&gt; JConfig.getInstance().getProperty(Consts.HBASE_TABLE);
    String kafkaBrokers &lt;/span&gt;=&lt;span&gt; JConfig.getInstance().getProperty(Consts.KAFKA_BROKERS);
    String kafkaTopics &lt;/span&gt;=&lt;span&gt; JConfig.getInstance().getProperty(Consts.KAFKA_TOPICS);
    String kafkaGroup &lt;/span&gt;=&lt;span&gt; JConfig.getInstance().getProperty(Consts.KAFKA_GROUP);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; open hbase&lt;/span&gt;
    &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
      openHBase(hbaseTable);
    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
      LOGGER.error(&lt;/span&gt;&quot;建立HBase 连接失败&quot;&lt;span&gt;, e);
      System.exit(&lt;/span&gt;-1&lt;span&gt;);
    }

    SparkConf conf &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; SparkConf().setAppName(&quot;JavaKafakaToHBase&quot;&lt;span&gt;);
    JavaStreamingContext ssc &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; JavaStreamingContext(conf, &lt;span&gt;new&lt;/span&gt; Duration(1000&lt;span&gt;));

    Set&lt;/span&gt;&amp;lt;String&amp;gt; topicsSet = &lt;span&gt;new&lt;/span&gt; HashSet&amp;lt;&amp;gt;(Arrays.asList(kafkaTopics.split(&quot;,&quot;&lt;span&gt;)));
    Map&lt;/span&gt;&amp;lt;String, Object&amp;gt; kafkaParams = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;&lt;span&gt;();
    kafkaParams.put(&lt;/span&gt;&quot;bootstrap.servers&quot;&lt;span&gt;, kafkaBrokers);
    kafkaParams.put(&lt;/span&gt;&quot;key.deserializer&quot;, StringDeserializer.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
    kafkaParams.put(&lt;/span&gt;&quot;value.deserializer&quot;, StringDeserializer.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
    kafkaParams.put(&lt;/span&gt;&quot;group.id&quot;&lt;span&gt;, kafkaGroup);
    kafkaParams.put(&lt;/span&gt;&quot;auto.offset.reset&quot;, &quot;earliest&quot;&lt;span&gt;);
    kafkaParams.put(&lt;/span&gt;&quot;enable.auto.commit&quot;, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在kerberos环境下，这个配置需要增加&lt;/span&gt;
    kafkaParams.put(&quot;security.protocol&quot;, &quot;SASL_PLAINTEXT&quot;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Create direct kafka stream with brokers and topics&lt;/span&gt;
    &lt;span&gt;final&lt;/span&gt; JavaInputDStream&amp;lt;ConsumerRecord&amp;lt;String, String&amp;gt;&amp;gt; stream =&lt;span&gt;
        KafkaUtils.createDirectStream(
            ssc,
            LocationStrategies.PreferConsistent(),
            ConsumerStrategies.&lt;/span&gt;&amp;lt;String, String&amp;gt;Subscribe(Arrays.asList(topicsSet.toArray(&lt;span&gt;new&lt;/span&gt; String[0&lt;span&gt;])), kafkaParams)
        );

    JavaDStream&lt;/span&gt;&amp;lt;String&amp;gt; lines = stream.map(&lt;span&gt;new&lt;/span&gt; Function&amp;lt;ConsumerRecord&amp;lt;String, String&amp;gt;, String&amp;gt;&lt;span&gt;() {
      &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; serialVersionUID = -1801798365843350169L&lt;span&gt;;

      @Override
      &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String call(ConsumerRecord&amp;lt;String, String&amp;gt;&lt;span&gt; record) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; record.value();
      }
    }).filter(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Function&amp;lt;String, Boolean&amp;gt;&lt;span&gt;() {
      &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; serialVersionUID = 7786877762996470593L&lt;span&gt;;

      @Override
      &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Boolean call(String msg) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; msg.length() &amp;gt; 0&lt;span&gt;;
      }
    });

    JavaDStream&lt;/span&gt;&amp;lt;Long&amp;gt; nums =&lt;span&gt; lines.count();

    nums.foreachRDD(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; VoidFunction&amp;lt;JavaRDD&amp;lt;Long&amp;gt;&amp;gt;&lt;span&gt;() {
      &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; SimpleDateFormat sdf = &lt;span&gt;new&lt;/span&gt; SimpleDateFormat(&quot;yyyyMMdd HH:mm:ss&quot;&lt;span&gt;);

      @Override
      &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; call(JavaRDD&amp;lt;Long&amp;gt; rdd) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        Long num &lt;/span&gt;= rdd.take(1).get(0&lt;span&gt;);
        String ts &lt;/span&gt;= sdf.format(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date());
        Put put &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Put(Bytes.toBytes(ts));
        put.add(Bytes.toBytes(&lt;/span&gt;&quot;f&quot;), Bytes.toBytes(&quot;nums&quot;&lt;span&gt;), Bytes.toBytes(num));
        table.put(put);
      }
    });

    ssc.start();
    ssc.awaitTermination();
    closeHBase();
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;三、 编译并在Yarn环境下运行&lt;/h3&gt;
&lt;h4&gt;3.1 切到项目路径下，编译项目：&lt;/h4&gt;
&lt;blockquote&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
mvn clean &lt;span&gt;package&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/blockquote&gt;
&lt;h4&gt;3.2 运行Spark环境&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;由于executor需要访问kafka，所以需要将Kafka授权过的kerberos用户下发至executor中；&lt;/li&gt;
&lt;li&gt;由于集群环境的hdfs也是kerberos加密的，需要通过spark.yarn.keytab/spark.yarn.principal配置可以访问Hdfs/HBase的keytab信息；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在项目目录下执行如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
/usr/ndp/current/spark2_client/bin/spark-&lt;span&gt;submit \
&lt;/span&gt;--files ./kafka_client_jaas.conf,./&lt;span&gt;kafka.service.keytab \
&lt;/span&gt;--conf &quot;spark.executor.extraJavaOptions=-Djava.security.auth.login.config=./kafka_client_jaas.conf&quot;&lt;span&gt; \
&lt;/span&gt;--driver-java-options &quot;-Djava.security.auth.login.config=./kafka_client_jaas.conf&quot;&lt;span&gt; \
&lt;/span&gt;--conf spark.yarn.keytab=/etc/security/keytabs/&lt;span&gt;hbase.service.keytab \
&lt;/span&gt;--conf spark.yarn.principal=hbase/hzadg-mammut-platform1.server.163.org@BDMS.163&lt;span&gt;.COM \
&lt;/span&gt;--&lt;span&gt;class&lt;/span&gt;&lt;span&gt; com.netease.spark.streaming.hbase.JavaKafkaToHBaseKerberos \
&lt;/span&gt;--&lt;span&gt;master yarn  \
&lt;/span&gt;--deploy-&lt;span&gt;mode client \
.&lt;/span&gt;/target/spark-demo-0.1.0-jar-with-dependencies.jar  
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中&lt;code&gt;kafka_client_jaas.conf&lt;/code&gt;文件具体内容如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;cat kafka_client_jaas.conf

KafkaClient {
com.sun.security.auth.module.Krb5LoginModule required
useKeyTab&lt;/span&gt;=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
renewTicket&lt;/span&gt;=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
keyTab&lt;/span&gt;=&quot;./kafka.service.keytab&quot;&lt;span&gt;
storeKey&lt;/span&gt;=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
useTicketCache&lt;/span&gt;=&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
serviceName&lt;/span&gt;=&quot;kafka&quot;&lt;span&gt;
principal&lt;/span&gt;=&quot;kafka/hzadg-mammut-platform1.server.163.org@BDMS.163.COM&quot;&lt;span&gt;;
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;3.2 执行结果&lt;/h4&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;2332&quot; data-height=&quot;980&quot;&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/49996-f1f6b211eb372c01.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/49996-f1f6b211eb372c01.png&quot; data-original-width=&quot;2332&quot; data-original-height=&quot;980&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;172048&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;2020&quot; data-height=&quot;418&quot;&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/49996-9a0a83bd661e70b1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/49996-9a0a83bd661e70b1.png&quot; data-original-width=&quot;2020&quot; data-original-height=&quot;418&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;241009&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;
</description>
<pubDate>Tue, 19 Mar 2019 06:52:00 +0000</pubDate>
<dc:creator>微信-大数据从业者</dc:creator>
<og:description>一、准备环境： 创建Kafka Topic和HBase表 1. 在kerberos环境下创建Kafka Topic 1.1 因为kafka默认使用的协议为PLAINTEXT，在kerberos环境下需</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/felixzh/p/10558674.html</dc:identifier>
</item>
<item>
<title>JDBC - 海嘉</title>
<link>http://www.cnblogs.com/chen-hai-jia/p/10558566.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chen-hai-jia/p/10558566.html</guid>
<description>&lt;h2&gt;1. &lt;span&gt;什么是JDBC&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　1. JDBC是java database connectivity的缩写，是SUN公司提供的一套操作数据库的标准规范。JDBC提供一些操作数据的API，开发者可以在java中使用这些API操作数据库，实现对表中数据的增删改查操作，JDBC相当于java和数据库之间的一座桥梁。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2. SUN公司制定了JDBC标准，各大数据库厂商会提供数据库驱动现这个标准，这样java才可以通过JDBC来操作实现了这个标准的数据库。如果将JDBC看做是接口的话，数据库厂商提供的数据库驱动就是这个接口的实现类。各个数据库厂商会将各自的数据库驱动打成jar包对外发布，开发者在使用时需要下载与当前数据库匹配的数据库驱动jar包。&lt;br/&gt;　　3. JDBC规范让Java程序和数据库驱动实现了松耦合，使切换不同的数据库变得更加简单。&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;jdbc-&quot;&gt;2. JDBC的四个核心接口&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;DriverManager：用于注册驱动并创建符合该驱动的数据库的连接。&lt;/li&gt;
&lt;li&gt;Connection：表示与数据库创建的连接对象，即一个connection对应着一个会话，相当于在mysql workbench中打开了一个连接。&lt;/li&gt;
&lt;li&gt;Statement：操作数据库sql语句的对象，有个两个实现类：Statement和PreparedStatement（常用）。&lt;/li&gt;
&lt;li&gt;ResultSet：从数据库中查询的结果集。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;基本上通过使用上面4个接口就能使用java实现对数据库的增删改查了。&lt;/p&gt;
&lt;h3 id=&quot;-jdbc-&quot;&gt;3. 使用JDBC开发的准备工作&lt;/h3&gt;
&lt;p&gt;JDBC规范在jdk中的 &lt;strong&gt;java.sql.&lt;/strong&gt;&lt;em&gt;;，&lt;/em&gt;&lt;strong&gt;javax.sql&lt;/strong&gt;.&lt;em&gt;;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;这两个包下面，不过这里面都是接口，要想使用JDBC的话，需要下载相关的数据库驱动jar包，这里咱们使用的是MySQL数据库，所以需要下载MySQL的数据库驱动：&lt;a href=&quot;http://pan.baidu.com/s/1hsJ1Rww&quot;&gt;http://pan.baidu.com/s/1hsJ1Rww&lt;/a&gt;&lt;br/&gt;，我传到网盘中了，直接通过上面的链接就可以下载。&lt;br/&gt;在MyEclipse中创建一个web project，之后将上面下载的数据库驱动解压，解压后将mysql-connector-java-5.1.43-bin.jar包拷贝到项目中的WebContent/WEB-INF/lib目录下。&lt;/p&gt;
&lt;p&gt;为了便于测试，先在数据库中创建下面的表并初始化数据，sql脚本：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;create&lt;/span&gt; &lt;span&gt;table&lt;/span&gt;&lt;span&gt; t_user(
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     id &lt;span&gt;int&lt;/span&gt; &lt;span&gt;primary&lt;/span&gt; &lt;span&gt;key&lt;/span&gt;&lt;span&gt; auto_increment,
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     name &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;40&lt;/span&gt;&lt;span&gt;),
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     password &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;40&lt;/span&gt;&lt;span&gt;),
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     email &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;60&lt;/span&gt;&lt;span&gt;),
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    birthday date
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; t_user(name,password,email,birthday) &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;tiger&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;123456&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;tiger@163.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1994-12-01&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;),
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;rabbit&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;123456&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;tiger@163.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1997-06-11&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;),
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;sheep&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;123456&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;sheep@163.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1995-07-15&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;-jdbc-&quot;&gt;4. 使用JDBC编程的步骤&lt;/h3&gt;
&lt;p&gt;　　一般情况下分为以下6步：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;注册驱动&lt;/li&gt;
&lt;li&gt;获取连接Connection&lt;/li&gt;
&lt;li&gt;得到执行sql语句的对象Statement&lt;/li&gt;
&lt;li&gt;执行sql语句，并返回结果&lt;/li&gt;
&lt;li&gt;处理结果&lt;/li&gt;
&lt;li&gt;关闭Connection&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.monkey1024.jdbc;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.sql.Connection;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.sql.DriverManager;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.sql.ResultSet;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.sql.Statement;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt; * 使用JDBC技术实现查询数据库数据，并显示在控制台中
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt; *
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; JDBC_Test01 {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;注册驱动&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;         Class.forName(&quot;com.mysql.jdbc.Driver&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取连接Connection&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;         Connection conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/monkey1024&quot;, &quot;root&quot;, &quot;monkey1024&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到执行sequel语句的对象Statement&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;         Statement stmt =&lt;span&gt; conn.createStatement();
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行sql语句，并返回结果&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;         ResultSet rs = stmt.executeQuery(&quot;select id,name,password,email,birthday from t_user&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;处理结果 &lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt;&lt;span&gt;(rs.next()){ 
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;             System.out.println(rs.getObject(&quot;id&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;             System.out.println(rs.getObject(&quot;name&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;             System.out.println(rs.getObject(&quot;password&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;             System.out.println(rs.getObject(&quot;email&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;             System.out.println(rs.getObject(&quot;birthday&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;             System.out.println(&quot;-----------------&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; 
&lt;span&gt;35&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭资源&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt; &lt;span&gt;        rs.close();
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;        stmt.close();
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;        conn.close();
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;    }    
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; 
&lt;span&gt;41&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id=&quot;junit-&quot;&gt;5. junit简介&lt;/h3&gt;
&lt;p&gt;junit是一个单元测试框架,之前的代码中只能运行main方法中的内容，使用junit之后，可以直接运行非main方法中的内容。&lt;br/&gt;要使用junit需要先导入相关jar包，可以去junit官网下载相关jar，也可以在eclipse中直接加入相关jar，这里使用eclipse直接加入jar包。&lt;br/&gt;在项目上右键—&amp;gt;properties—&amp;gt;java build path—&amp;gt;选择libraries一项—&amp;gt;点击add library—junit，导入相关junit的jar包即可。&lt;/p&gt;
&lt;h3 id=&quot;junit-&quot;&gt;unit的使用&lt;/h3&gt;
&lt;p&gt;在想要运行的方法上面加上@Test注解，右键run as—&amp;gt;junit test即可运行。&lt;br/&gt;注意：在@Test注解修饰的测试方法不能有返回值，不能有方法参数。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.monkey1024.jdbc;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.Test;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CaculateTest01 {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    @Test
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test1(){
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         System.out.println(&quot;monkey1024&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;junit-&quot;&gt;junit断言&lt;/h3&gt;
&lt;p&gt;junit中提供了Assert类，通过调用该类中的方法，可以测试一下方法运行的结果跟我们想要的结果是否一致，这种方式叫做断言。&lt;br/&gt;创建一个Caculate类，里面有两个方法分别计算两个数字相加和相除：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.monkey1024.jdbc;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt; * 计算器
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt; *
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Caculate {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; add(&lt;span&gt;int&lt;/span&gt; a, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; b){
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; a+&lt;span&gt;b;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; devide(&lt;span&gt;double&lt;/span&gt; a, &lt;span&gt;double&lt;/span&gt;&lt;span&gt; b){
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; a/&lt;span&gt;b;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;pre&gt;
使用junit的assert断言进行测试：
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.monkey1024.jdbc;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.Assert;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.Test;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; junit.framework.TestCase;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CaculateTest01 {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    @Test
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test1(){
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         System.out.println(&quot;monkey1024&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    @Test
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test2(){
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         Caculate c = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Caculate();
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         Assert.assertEquals(15, c.add(10, 5&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         TestCase.assertEquals(15, c.add(10, 5&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    @Test
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test3(){
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         Caculate c = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Caculate();
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;因为10除以3是除不尽的，0.4是允许的浮动范围&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;         Assert.assertEquals(3, c.devide(10, 3), 0.4&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Tue, 19 Mar 2019 06:40:00 +0000</pubDate>
<dc:creator>海嘉</dc:creator>
<og:description>1. 什么是JDBC 1. JDBC是java database connectivity的缩写，是SUN公司提供的一套操作数据库的标准规范。JDBC提供一些操作数据的API，开发者可以在java中使</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chen-hai-jia/p/10558566.html</dc:identifier>
</item>
<item>
<title>两篇文章带你走入.NET Core 世界：Kestrel+Nginx+Supervisor 部署上云服务器（二） - 路过秋天</title>
<link>http://www.cnblogs.com/cyq1162/p/10544615.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cyq1162/p/10544615.html</guid>
<description>&lt;p&gt;上一篇：&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/cyq1162/p/10540174.html&quot;&gt;两篇文章带你走入.NET Core 世界：CentOS+Kestrel+Ngnix 虚拟机先走一遍（一）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;已经交待了背景，这篇就省下背景了，这是第二篇文章了，看完就木有下篇了。&lt;/p&gt;
&lt;p&gt;直接进入主题：&lt;/p&gt;

&lt;p&gt;之前在虚拟机跑了一下，感觉还不够真实，于是，准备买台服务器，认真的跑一下。&lt;/p&gt;
&lt;p&gt;有阿里云，腾讯云，华为云，还有好多云，去哪买一个？&lt;/p&gt;
&lt;p&gt;之前做为华为云的云享专家去参加了一下活动，本来也准备写篇文章，不过相同游记文太多，&lt;/p&gt;
&lt;p&gt;这里就转一篇了：&lt;a href=&quot;https://bbs.huaweicloud.com/blogs/d6739e0940a711e9bd5a7ca23e93a891&quot; target=&quot;_blank&quot;&gt;让华为云MVP告诉你——在华为的一天可以做什么？&lt;/a&gt;，就当作我已经写了吧，哈。&lt;/p&gt;
&lt;p&gt;有人问我参加完华为云的活动后有什么感想，我想了想，就回了一句：华为好穷，别问我为什么。&lt;/p&gt;
&lt;p&gt;所以，考虑过华为云，不过在比较完三方的价格，以及域名备案的问题，&lt;/p&gt;
&lt;p&gt;还是挑了目前优惠力度最大的腾讯云，2.5折买的，记得我以前买的最便宜的是1.89折。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/17408/201903/17408-20190316224236677-1007831537.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;买完服务器，安装选的是CentOS7.2版本，比起跑虚拟机，这里就省掉了安装过程了。&lt;/p&gt;
&lt;p&gt;在控制台想登陆，发现：密码是啥？百了一下，密码要在控制台-更多-密码/密钥-重置密码。&lt;/p&gt;
&lt;p&gt;设置好密码就可以直接在控制台上，点登陆，ssh登陆上去了：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/17408/201903/17408-20190316224746876-891976546.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;依旧跟着微软的教程走：&lt;a href=&quot;https://www.microsoft.com/net/learn/get-started/linuxcentos&quot; target=&quot;_blank&quot;&gt;https://www.microsoft.com/net/learn/get-started/linuxcentos&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这里木有可视化，想要复制上传文件，没本地虚拟那么方便了，所以需要一款能连接敲命令行和上传文件的工具了。&lt;/p&gt;
&lt;p&gt;下载地址：https://www.portablesoft.org/securecrt-securefx-integrated/&lt;/p&gt;
&lt;p&gt;这里记录一下我遇到的坑：&lt;/p&gt;
&lt;p&gt;1、本地电脑，N年前就下载过SecureCRT，所以用上它了，但是木有SecureFX这个工具。&lt;/p&gt;
&lt;p&gt;2、于是想着，在服务器装个FTP啊，来啊，那就装个标配：vsftp了。&lt;/p&gt;
&lt;p&gt;对着教程：&lt;a href=&quot;https://www.centos.bz/2017/12/centos7%E9%83%A8%E7%BD%B2vsftpd%E6%9C%8D%E5%8A%A1/&quot; target=&quot;_blank&quot;&gt;https://www.centos.bz/2017/12/centos7%E9%83%A8%E7%BD%B2vsftpd%E6%9C%8D%E5%8A%A1/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;一顿操作猛如虎，感觉服务端配置的差不多，准备入坑了：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;flashFtp的坑：

本里机找了一个老旧的版本，结果连上去看不到东西，

以为是服务器权限没配置好，折腾半天，最后在工具的选项勾了某个&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;列表 -l显示”的选项后，连上去能看到目录了。&lt;/span&gt;
&lt;span&gt;
创建目录也正常了，结果不能上传文件，见鬼了，闹腾很久后，只能换工具了。

FileZilla的坑：

电脑重新装了这个工具，连上去，发现文件也能上传了，以为一切OK了。

结果，发现存在文件小的都上传不了，文件大的都能正常上传，我去，这是什么鬼。

又是折腾服务端配置，又是折腾路由器MTU值，情况依旧是小文件连接超时，传输失败。

后来，想起了SecureCRT标配的工具SecureFX，下载，重新运行它连上去，我X，一切都是这么顺畅。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 具体参考上一篇，不过有几个重点配置提一下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
proxy_cookie_domain ~.+$ aries.cyqdata.com;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将Set-Cookie中的Domain值，替换为指定的域名。&lt;/p&gt;
&lt;p&gt;Aries设置的Domain是IP属性，Nginx请求转给客户端时，需要转成域名，不设的话，拿到的是原始的IP，设不到Cookie。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/17408/201903/17408-20190317004001166-1874082802.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;网上对这块的说明都是仅有：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
proxy_cookie_domain a.com b.com;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;固定的把a.com替换成b.com，&lt;/p&gt;
&lt;p&gt;考虑到负载均衡一开，这个IP的值就不固定，所以Domain值必须是变量。&lt;/p&gt;
&lt;p&gt;难道你们设Cookie都不设置的Domain的啊，设了Domain都不考虑负载的啊。&lt;/p&gt;
&lt;p&gt;坑啊，最后还是官网的帮助文档能解决问题，自己写了个正则搞定。&lt;/p&gt;
&lt;p&gt;文档地址：&lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_cookie_domain&quot; target=&quot;_blank&quot;&gt;http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_cookie_domain&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;至于负载配置和动静态的配置比较简单：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;负载均衡：在http配置下增加upstream配置即可：

upstream nodes {
server &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;10.1&lt;/span&gt;:&lt;span&gt;8668&lt;/span&gt;&lt;span&gt;;
server &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;10.2&lt;/span&gt;:&lt;span&gt;8668&lt;/span&gt;&lt;span&gt;;
}

动静分离：#静态文件交给nginx处理
location &lt;/span&gt;~ .*\.(htm|html|gif|jpg|jpeg|png|bmp|swf|ioc|rar|zip|txt|flv|mid|doc|ppt|pdf|xls|mp3|&lt;span&gt;wma)$
{
root &lt;/span&gt;/&lt;span&gt;var&lt;/span&gt;/&lt;span&gt;www;
expires 30d;
}
#静态文件交给nginx处理
location &lt;/span&gt;~ .*\.(js|css)?&lt;span&gt;$ 
{
root &lt;/span&gt;/&lt;span&gt;var&lt;/span&gt;/&lt;span&gt;www; 
expires 1h; 
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;https 访问，参考：&lt;a href=&quot;https://www.cnblogs.com/tianhei/p/7726505.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/tianhei/p/7726505.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt; 当Kestrel跑起来后，第二天，发现它挂了，然后，就知道要装个守护进程，等它挂掉的时候，能自动启动。&lt;/p&gt;
&lt;p&gt;为了安装这个，一开始我也是入坑，网上的教程，又坑人不浅，最后找到最简单的yum安装，就两行命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
yum install epel-&lt;span&gt;release
yum install &lt;/span&gt;-y supervisor
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;默认配置文件：/etc/supervisord.conf 暂时可以不用管，如果要开启网页管理，则修改以下两行：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
[inet_http_server]         ; inet (TCP) server disabled by &lt;span&gt;default&lt;/span&gt;&lt;span&gt;
port&lt;/span&gt;=*:&lt;span&gt;5005&lt;/span&gt;        ; (ip_address:port specifier, *:port &lt;span&gt;for&lt;/span&gt;&lt;span&gt; all iface)
&lt;br/&gt;...

[supervisorctl]
;serverurl&lt;/span&gt;=unix:&lt;span&gt;///&lt;/span&gt;&lt;span&gt;var/run/supervisor/supervisor.sock ; use a unix:// URL  for a unix socket&lt;/span&gt;
serverurl=http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;*:5005 ; use an http:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; url to specify an inet socket&lt;p&gt;....&lt;/p&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;[include]&lt;br/&gt;files = supervisord.d/*.ini&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;设置开机启动：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;systemctl enable supervisor.service
systemctl daemon&lt;/span&gt;-reload
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;浏览的效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/17408/201903/17408-20190317012242948-1241197851.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;进程管理配置文件放到：/etc/supervisord.d/目录下即可：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/17408/201903/17408-20190317012452201-1701671314.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;如上图，我创建了两个进程配置文件：&lt;/p&gt;
&lt;p&gt;配置文件内容如下：&lt;/p&gt;
&lt;p&gt;taurus_mvc.ini&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[program:Taurus_MVC]
command&lt;/span&gt;=/bin/bash -c &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dotnet Taurus.View.dll&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
directory&lt;/span&gt;=/home/web/taurus/mvc/&lt;span&gt;
environment&lt;/span&gt;=ASPNETCORE__ENVIRONMENT=&lt;span&gt;Production 
user&lt;/span&gt;=&lt;span&gt;root 
stopsignal&lt;/span&gt;=&lt;span&gt;INT
autostart&lt;/span&gt;=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
autorestart&lt;/span&gt;=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
startsecs&lt;/span&gt;=&lt;span&gt;3&lt;/span&gt;&lt;span&gt;    
redirect_stderr&lt;/span&gt;=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
stderr_logfile&lt;/span&gt;=/&lt;span&gt;var&lt;/span&gt;/log/&lt;span&gt;taurus_mvc.err.log   
stdout_logfile&lt;/span&gt;=/&lt;span&gt;var&lt;/span&gt;/log/taurus_mvc.&lt;span&gt;out&lt;/span&gt;.log  
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;aries_mvc.ini&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[program:Aries_MVC]
command&lt;/span&gt;=/bin/bash -c &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dotnet Web.UI.dll&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
directory&lt;/span&gt;=/home/web/aries/mvc/&lt;span&gt;
environment&lt;/span&gt;=ASPNETCORE__ENVIRONMENT=&lt;span&gt;Production 
user&lt;/span&gt;=&lt;span&gt;root 
stopsignal&lt;/span&gt;=&lt;span&gt;INT
autostart&lt;/span&gt;=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
autorestart&lt;/span&gt;=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
startsecs&lt;/span&gt;=&lt;span&gt;3&lt;/span&gt;&lt;span&gt;    
redirect_stderr&lt;/span&gt;=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
stderr_logfile&lt;/span&gt;=/&lt;span&gt;var&lt;/span&gt;/log/&lt;span&gt;aries_mvc.err.log   
stdout_logfile&lt;/span&gt;=/&lt;span&gt;var&lt;/span&gt;/log/aries_mvc.&lt;span&gt;out&lt;/span&gt;.log
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;默认日志文件：/tmp/supervisord.log，可以查看进程的启动信息&lt;/p&gt;
&lt;p&gt;命令行输入：supervisorctl，可以查看状态：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/17408/201903/17408-20190317012833505-1911840287.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;更多的说明：https://www.linuxidc.com/Linux/2017-02/140417.htm&lt;/p&gt;

&lt;p&gt; 把这两篇文章的内容，走完一次，基本就进入NetCore的世界了。&lt;/p&gt;
&lt;p&gt; 不过，与其说是NetCore，不如说是走进Linux的世界。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;写代码的关键注意点：路径区分大小写及路径用“/”，而不是常用的&quot;\\&quot;。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 毕竟更多的时间与坑，都是花在Linux系统及软件安装使用上的。&lt;/p&gt;
&lt;p&gt;　　Aries on CentOS7：&lt;a href=&quot;http://mvc.aries.cyqdata.com/&quot; target=&quot;_blank&quot;&gt;mvc.aries.cyqdata.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　Taurus on CentOS7：&lt;a href=&quot;http://mvc.taurus.cyqdata.com/&quot; target=&quot;_blank&quot;&gt;mvc.taurus.cyqdata.com&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 19 Mar 2019 06:40:00 +0000</pubDate>
<dc:creator>路过秋天</dc:creator>
<og:description>走入.NET Core 世界：为了真实环境，特意买了台服务器，走了一遍，才与大伙分享过程〜〜〜〜</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cyq1162/p/10544615.html</dc:identifier>
</item>
<item>
<title>Java的自定义注解使用实例 - 农码关山北</title>
<link>http://www.cnblogs.com/dslx/p/10553478.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dslx/p/10553478.html</guid>
<description>&lt;h3&gt;概念&lt;/h3&gt;
&lt;p&gt;Java有五个元注解，自动继承&lt;strong&gt;java.lang.annotation.Annotation。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;什么是元注解，可以理解为其他普通注解进行解释说明&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;@Target &lt;/strong&gt;&lt;/strong&gt; 该注解的使用范围，限定应用场景。枚举类 ElemenetType 中&lt;strong&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;TYPE:类，接口&lt;/li&gt;
&lt;li&gt;FIELD:字段，枚举的常量&lt;/li&gt;
&lt;li&gt;METHOD:函数(方法)&lt;/li&gt;
&lt;li&gt;PARAMETER:参数&lt;/li&gt;
&lt;li&gt;CONSTRUCTOR:构造函数&lt;/li&gt;
&lt;li&gt;ANNOTATION_TYPE:注解类型&lt;/li&gt;
&lt;li&gt;LOCAL_VARIABLE:局部变量&lt;/li&gt;
&lt;li&gt;PACKAGE:包&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;&lt;strong&gt;@Retention &lt;/strong&gt;&lt;/strong&gt; 该注解的生存周期，相当于时间戳。枚举类型 RetentionPolicy 中&lt;strong&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;SOURCE:在源文件中有效，编译后会被丢弃（如@Override，@Deprecated）&lt;/li&gt;
&lt;li&gt;CLASS:在class文件中有效，在jvm丢弃&lt;/li&gt;
&lt;li&gt;RUNTIME:在运行时有效，class文件保留，jvm运行时保留(很多框架运用反射调用)&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;&lt;strong&gt;@Documented&lt;/strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;javadoc文档生成工具的使用&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;@Inherited&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;允许子类继承父类中的注解。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@Repeatable&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;同一种注解可多次使用&lt;/p&gt;
&lt;h3&gt;作用&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;注释，解释，通过代码的标识元数据生成doc文档；&lt;/li&gt;
&lt;li&gt;使用反射，通过代码标识的元数据对代码进行分析；&lt;/li&gt;
&lt;li&gt;编译检查，通过代码标识的元数据让编译器进行基本检查。&lt;/li&gt;
&lt;/ol&gt;&lt;h3&gt;实例&lt;/h3&gt;
&lt;p&gt;定义一个普通的注解，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; @&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Test
{

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用我们自定义的注解&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Test
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person
{
    @Test
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;

    @Test
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; age;

    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; say()
    {
        System.out.println(&lt;/span&gt;&quot;Hello,Java Annotation&quot;&lt;span&gt;);
    }
&lt;strong&gt;}&lt;/strong&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;@Target(ElementType.PACKAGE) 注解作用的目标&amp;gt;包&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个注解要理解什么是友好声明类和包常量，包中有很多的内部访问的类或常量，就可以统一的放到友好声明类中，这样就方便，而且集中管理，减少friendly类到处游走的情况。&lt;/p&gt;
&lt;p&gt;可以参考这个 &lt;a href=&quot;https://www.cnblogs.com/DreamDrive/p/5428573.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/DreamDrive/p/5428573.html&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.annotation.ElementType;&lt;/span&gt;&lt;span&gt;
@Target(ElementType.PACKAGE)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; @&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Test
{
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Test
&lt;/span&gt;&lt;span&gt;package&lt;/span&gt;&lt;span&gt; test;

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person
{

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;


    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; age;


    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; say()
    {
        System.out.println(&lt;/span&gt;&quot;Hello,Java Annotation&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;@Target(ElementType.CONSTRUCTOR) &lt;/strong&gt;注解作用的目标&amp;gt;构造函数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; test;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.annotation.ElementType;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.annotation.Target;
@Target(ElementType.CONSTRUCTOR)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; @&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Test
{

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; test;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person
{

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; age;
    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Person()
    {

    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; say()
    {
        System.out.println(&lt;/span&gt;&quot;Hello,Java Annotation&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其他范围就不一一列举，都是相同的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@Retention(RetentionPolicy.RUNTIME)   生存周期&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;代码运行时动态获取注解的信息&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; test;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.annotation.ElementType;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.annotation.Retention;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.annotation.RetentionPolicy;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.annotation.Target;
@Target(ElementType.CONSTRUCTOR)
@Retention(RetentionPolicy.RUNTIME)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; @&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Test
{

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; test;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person
{

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; age;&lt;br/&gt;@Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Person()
    {

    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; say()
    {
        System.out.println(&lt;/span&gt;&quot;Hello,Java Annotation&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 注解的属性--&amp;gt;成员变量&lt;/p&gt;
&lt;p&gt;方法名是成员变量的的名字，变量的类型是他的返回值。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package test;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME) 
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; @interface Test
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; age() &lt;span&gt;default&lt;/span&gt; &lt;span&gt;20&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String name() &lt;span&gt;default&lt;/span&gt; &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String className();
}&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; test;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.annotation.Annotation;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Field;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Method;

@Test(age &lt;/span&gt;= 15,name = &quot;zhangsan&quot;,className = &quot;高三(3)班&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person
{
 
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; age;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Person()
    {

    }

  
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; say()
    {
        System.out.println(&lt;/span&gt;&quot;Hello,Java Annotation&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;既然给了注解，我们要做的工作必然是要提取注解上面的内容，要拿到这些注解就要用到反射。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; test;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.annotation.Annotation;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Field;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Method;

@Test(age &lt;/span&gt;= 15,name = &quot;zhangsan&quot;,className = &quot;高三(3)班&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person
{&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; age;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Person()
    {

    }
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; say()
    {
        System.out.println(&lt;/span&gt;&quot;Hello,Java Annotation&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args)
    {
        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; hasAnnotation = Person.&lt;span&gt;class&lt;/span&gt;.isAnnotationPresent(Test.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (hasAnnotation)
        {
            Test test &lt;/span&gt;= Person.&lt;span&gt;class&lt;/span&gt;.getAnnotation(Test.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);

            System.out.println(&lt;/span&gt;&quot;age:&quot; +&lt;span&gt; test.age());
            System.out.println(&lt;/span&gt;&quot;name:&quot; +&lt;span&gt; test.name());
            System.out.println(&lt;/span&gt;&quot;className:&quot; +&lt;span&gt; test.className());
        }&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出结果&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
age:15&lt;span&gt;
name:zhangsan
className:高三(&lt;/span&gt;3)班
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对于类的属性和方法，都是同样的道理。&lt;/p&gt;
&lt;p&gt;成员注解&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; test;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.annotation.ElementType;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.annotation.Retention;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.annotation.RetentionPolicy;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.annotation.Target;

@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; @&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Field
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String name();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;函数注解&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; test;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.annotation.ElementType;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.annotation.Retention;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.annotation.RetentionPolicy;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.annotation.Target;

@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; @&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Method
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String say();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Person类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; test;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.annotation.Annotation;

@Test(age &lt;/span&gt;= 15,name = &quot;zhangsan&quot;,className = &quot;高三(3)班&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person
{
    @Field(name &lt;/span&gt;= &quot;lisi&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; age;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Person()
    {

    }
    @Method(say &lt;/span&gt;= &quot;hello&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; say()
    {
        System.out.println(&lt;/span&gt;&quot;Hello,Java Annotation&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args)
    {
        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; hasAnnotation = Person.&lt;span&gt;class&lt;/span&gt;.isAnnotationPresent(Test.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (hasAnnotation)
        {
            Test test &lt;/span&gt;= Person.&lt;span&gt;class&lt;/span&gt;.getAnnotation(Test.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);

            System.out.println(&lt;/span&gt;&quot;age:&quot; +&lt;span&gt; test.age());
            System.out.println(&lt;/span&gt;&quot;name:&quot; +&lt;span&gt; test.name());
            System.out.println(&lt;/span&gt;&quot;className:&quot; +&lt;span&gt; test.className());
        }

        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
        {
            java.lang.reflect.Field field &lt;/span&gt;= Person.&lt;span&gt;class&lt;/span&gt;.getDeclaredField(&quot;name&quot;&lt;span&gt;);

            field.setAccessible(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);

            Field check &lt;/span&gt;= field.getAnnotation(Field.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (check != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                System.out.println(&lt;/span&gt;&quot;check value:&quot; +&lt;span&gt; check.name());
            }

            java.lang.reflect.Method method &lt;/span&gt;= Person.&lt;span&gt;class&lt;/span&gt;.getDeclaredMethod(&quot;say&quot;&lt;span&gt;);  

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (method != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                Annotation[] ans &lt;/span&gt;=&lt;span&gt; method.getAnnotations();
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; ans.length; i++&lt;span&gt;)
                {
                    System.out.println(&lt;/span&gt;&quot;method annotation:&quot; +&lt;span&gt; ans[i].annotationType().getSimpleName());
                }
             }

        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (NoSuchFieldException e)
        {
            e.printStackTrace();
        }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e){
            e.printStackTrace();
        }

    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
age:15&lt;span&gt;
name:zhangsan
className:高三(&lt;/span&gt;3&lt;span&gt;)班
check value:lisi
method annotation:Method&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看出我们获取了注解上的值，现在都没有实际意义，我们可以用注解来做些什么?&lt;/p&gt;
&lt;p&gt;这些我没办法给出确切答案，只能说根据各人需求去合理利用注解。&lt;/p&gt;
&lt;h3&gt;实例&lt;/h3&gt;
&lt;p&gt;注解参数赋值&lt;/p&gt;
&lt;p&gt;@Test注解&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; test;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.annotation.ElementType;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.annotation.Retention;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.annotation.RetentionPolicy;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.annotation.Target;
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.FIELD})
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; @&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Test
{
    String value();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Person类属性赋值&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; test;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.poi.ss.formula.functions.T;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.annotation.Annotation;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Field;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Method;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person
{
    @Test(&lt;/span&gt;&quot;zhangsan&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;

    @Test(&lt;/span&gt;&quot;15&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; age;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Person()
    {

    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; say()
    {
        System.out.println(&lt;/span&gt;&quot;Hello,Java Annotation&quot;&lt;span&gt;);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString()
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;name = &quot; + name + &quot;\n&quot; + &quot;age = &quot; +&lt;span&gt; age;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args)
    {
        Person person &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Person();
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;取得成员变量的值&lt;/span&gt;
            Field field = Person.&lt;span&gt;class&lt;/span&gt;.getDeclaredField(&quot;name&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;打开权限&lt;/span&gt;
            field.setAccessible(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断属性是否有注解&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (field.isAnnotationPresent(Test.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;))
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取属性上的注解值&lt;/span&gt;
                Test test = field.getAnnotation(Test.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
                String name &lt;/span&gt;=&lt;span&gt; test.value();
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;赋值&lt;/span&gt;
&lt;span&gt;                field.set(person,name);
            }

            Field field1 &lt;/span&gt;= Person.&lt;span&gt;class&lt;/span&gt;.getDeclaredField(&quot;age&quot;&lt;span&gt;);
            field1.setAccessible(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (field1.isAnnotationPresent(Test.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;))
            {
                Test test &lt;/span&gt;= field1.getAnnotation(Test.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; age =&lt;span&gt; Integer.valueOf(test.value());
                field1.set(person,age);
            }
            System.out.println(person);

        }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e)
        {
            e.printStackTrace();
        }

    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
name =&lt;span&gt; zhangsan
age &lt;/span&gt;= 15
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;用注解去检查函数等等。。&lt;/p&gt;
&lt;p&gt;这哥们的注解讲得特别好(简单易懂)&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;%20https://blog.csdn.net/briblue/article/details/73824058&quot; target=&quot;_blank&quot;&gt; https://blog.csdn.net/briblue/article/details/73824058&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 19 Mar 2019 06:30:00 +0000</pubDate>
<dc:creator>农码关山北</dc:creator>
<og:description>概念 Java有五个元注解，自动继承java.lang.annotation.Annotation。 什么是元注解，可以理解为其他普通注解进行解释说明 @Target 该注解的使用范围，限定应用场景。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dslx/p/10553478.html</dc:identifier>
</item>
<item>
<title>一次与客户端合作的走坑之旅！ - 雨吻蝶</title>
<link>http://www.cnblogs.com/zengfp/p/10558470.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zengfp/p/10558470.html</guid>
<description>&lt;p&gt;  　　项目经理给客户端提出了个需求，加急做用户反馈界面，很急，安卓客户端项目开发就一个人，表示干不了，短时间内完成不了，于是商量了一番，把前端的我搅和进去了，让新增的用户反馈界面用H5开发。甩锅于前端，经理说赶紧做，当天要！于是那天临近午饭时间，通知这个事情让我干，我心里是真的不是滋味，心里mmp。随即给我UI，告诉我说UI会裁好图给我。这图一直到下午4点，离下班还有两个小时的时候才给我的。这种做事效率让人心塞啊！但是也顾不得抱怨了，三下五除二，使用vue+vue-router+vant足以满足需求开发了。最终在下班之前还是打包交给服务器端了。&lt;/p&gt;
&lt;p&gt;　　服务器端部署项目之后，打开界面，白屏界面不出来，而且还不报错！这就尴尬了，没报错那是真的难找问题。他们服务器的人也倒腾了半天，没效果，我就不信邪，我说我以前打包的项目都是这样的，没出现过这样的问题。我就把这个项目部署在了自己的阿里云服务器上，试试看，却能看到界面效果！这就摸不着头脑了，问题还是要解决的。试了几次，终于找到了问题，router的history模式导致的问题。因为我自己的服务器的nginx配置时对这个mode进行了处理的，所有是没有问题，而这个项目的服务器端时没有对这个模式进行匹配处理的。那就先来说说vue-router的history模式了。&lt;/p&gt;
&lt;p&gt;　　HTML5 History模式&lt;/p&gt;
&lt;p&gt;　　vue-router 默认 hash 模式 —— 使用 URL 的 hash 来模拟一个完整的 URL，于是当 URL 改变时，页面不会重新加载。如果不想要很丑的 hash，我们可以用路由的 history 模式，这种模式充分利用 history.pushState API 来完成 URL 跳转而无须重新加载页面。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
const Router = require('vue-router'&lt;span&gt;)
const router &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Router({
   mode:&lt;/span&gt;'history'&lt;span&gt;,
   routes: [...]  
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当使用history模式时，url就像正常的url如https://i.cnblogs.com/EditPosts.aspx?opt=1。不过这种模式要玩好，还需要后台配置支持。因为我们的应用是个单页客户端应用，如果后台没有正确的配置，当用户在浏览器直接访问 &lt;code&gt;http://oursite.com/user/id&lt;/code&gt; 就会返回 404，这就不好看了。所以呢，你要在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 &lt;code&gt;index.html&lt;/code&gt; 页面，这个页面就是你 app 依赖的页面。&lt;/p&gt;
&lt;p&gt;后台服务器nginx的配置需加上：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
location /&lt;span&gt; {
  try_files $uri $uri&lt;/span&gt;/ /index.html;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;完整的vue-router 的history模式可以点此学习：&lt;a href=&quot;https://router.vuejs.org/zh/guide/essentials/history-mode.html&quot; target=&quot;_blank&quot;&gt;https://router.vuejs.org/zh/guide/essentials/history-mode.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;由于当时服务器没有对这个history模式进行nginx配置，我只好把router处的mode:'history'去掉。后面那些路由不好看的啥子东西服务器那边配置的时候自行解决了。&lt;/p&gt;
&lt;p&gt;　　本以为都告一段落了，谁知这才刚刚开始。测试站测试人员提bug了。客户端测试人员用的安卓机，可不是正常的手机，是用那种低端机进行测试的，所以与我们在稍好一点的手机上看到的效果差别还是很明显的。测试人员说：进入H5页面会有闪屏出现，那个banner图片会闪一下再出来，体验很不好。&lt;/p&gt;
&lt;p&gt;我看了一下效果之后，我那是就有点底了，h5刚出来的时候，本应该是banner占据的位置，被下面的内容占据了，我心中一想可能是没有给图片的容器进行高度设置，才让这种闪屏出现。我觉得还应该对图片进行压缩处理，因为在移动端，对图片的压缩还是非常有必要的。虽然有时候有些损失图片的质量，但是其实在移动端，还是很难觉察到差别的。经过了对图片的高度设置和压缩之后，这种闪屏好了很多。&lt;/p&gt;
&lt;p&gt;　　解决了这个闪屏bug，满以为可以了。可是客户端的需求是不断改变的。客端户需要在无网络状态下，进入h5首页，然后连网之后，可以在页面上进行交互。&lt;/p&gt;
&lt;p&gt;　　我当时脑子是蒙的，我是拒绝的，我说这个应该是你们客户端解决的事情吧，客户端人员说需要三份代码，因为我们坐的这个用户反馈h5是有三种不同的语言的，中文、印尼语和英文，所以还是需要打包三份代码，用以针对三种不同语言的需求。以保存在客户端本地。打包好三份代码给客户端之后，客户端在无网络的情况下，打开用户反馈app，会自动调取本地存储的文件，这个时候问题就出来了，里面的icon图片位置有破图出现，而且点击进行交互没有反应，客户端显示的h5发起的请求地址居然是本地地址。这两个bug我是这样解决的：&lt;/p&gt;
&lt;p&gt;1、icon图片破图&lt;/p&gt;
&lt;p&gt;　　当图片不存在时，出触发onerror事件，这个时候我们就可以处理一下来让网页美观一些，有两个方法&lt;/p&gt;
&lt;p&gt;我使用的第二种方法，在vue中我们可以这样使用:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;data() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
         defaultImage: &lt;/span&gt;&quot;this.src=&quot;+require('./assets/error.png'&lt;span&gt;)
     }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;图片的url地址&quot;&lt;/span&gt;&lt;span&gt; alt&lt;/span&gt;&lt;span&gt;=&quot;图片XX&quot;&lt;/span&gt;&lt;span&gt; onerror&lt;/span&gt;&lt;span&gt;=&quot;defaultImage&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2、无网络状态下调用客户端本地的文件，之后打开网络后，进行页面交互发起的请求地址不对&lt;/p&gt;
&lt;p&gt;使用vue+webpack打包上线的的文件，是需要部署在线上服务器的，能够以http等协议进行访问，在项目里面进行api请求，在线上都是以域名进行访问请求的，比如域名是：&lt;a href=&quot;https://olqa.faceworld.top/olqa&quot; target=&quot;_blank&quot;&gt;https://olqa.faceworld.top/&lt;/a&gt;，进行的api请求就是 &lt;a href=&quot;https://olqa.faceworld.top/olqa&quot; target=&quot;_blank&quot;&gt;https://olqa.faceworld.top/&lt;/a&gt;api/getCatogryList/lang=zh#/。当使用客户端本地的文件时，进行的请求访问地址就变成了 file://XXX/api/getCatogryList/lang=zh#/，这样的请求交互当然是不生效的。后来服务器开发人员给了我一个建议，让我写绝对地址，就是在交互请求的地址上把域名加上去。如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35.924369747899&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　　　　　axios({
                    url: '&lt;a href=&quot;https://olqa.faceworld.top/olqa&quot; target=&quot;_blank&quot;&gt;https://olqa.faceworld.top&lt;/a&gt;/olqa/api/faq/getList.do',//把域名加上去
                    params: data,
                    method: 'POST',
                }).then(res =&amp;gt; {
                    if(res.status == 200 &amp;amp;&amp;amp; res.data.data.length &amp;gt; 0) {
                        this.page ++;
                        this.searchList = this.searchList.concat(res.data.data);
                    }else if(res.status != 200){
                        this.loading = false
                    }else {
                        console.log('没有结果');
                        this.finished = true;
                    }
                    this.loading = false
                }).catch(err =&amp;gt; {
                    console.log('net timeout');
                    this.loading =false;
                })&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;之后进行打包交给客户端存储在本地。这也算是一种解决方法吧。&lt;/p&gt;
&lt;p&gt;　　任何项目完成上线都不是一帆风顺的。这不，测试人员说在低端机上，h5的首屏加载时间有点长，让我去研究研究改善用户体验。vue的SPA页面都是通过打包后的js文件进行解析后生成dom进行页面渲染的，如果对于js文件的解析比较慢，是会导致首屏加载时间较长。想着如果进行预渲染，可能会有出奇效果。找到了一款插件：prerender-spa-plugin，&lt;/p&gt;
&lt;p&gt;可以把页面单独打包出来，而且打包出来的index.html文件可以直接访问打开，如果放在客户端本地的话，效果应该不错。于是就试试：&lt;/p&gt;
&lt;p&gt;1、安装&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
 npm install prerender-spa-plugin --save-dev
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 2、webpack.prod.conf.js增加部分代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
const PrerenderSPAPlugin = require('prerender-spa-plugin')   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;引用插件&lt;/span&gt;
const Renderer =&lt;span&gt; PrerenderSPAPlugin.PuppeteerRenderer
const webpackConfig &lt;/span&gt;=&lt;span&gt; merge(baseWebpackConfig, {
    plugins: [
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; vue-cli生成的配置中就已有这个了，不要动&lt;/span&gt;
        &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HtmlWebpackPlugin({
            filename: config.build.index,
            template: &lt;/span&gt;'index.html'&lt;span&gt;,
            inject: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
            minify: {
                removeComments: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
                collapseWhitespace: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
                removeAttributeQuotes: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
            },
            chunksSortMode: &lt;/span&gt;'dependency'&lt;span&gt;
        }),
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 配置PrerenderSPAPlugin&lt;/span&gt;
        &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PrerenderSPAPlugin({
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 生成文件的路径，也可以与webpakc打包的一致。&lt;/span&gt;
            staticDir: path.join(__dirname, '../dist'&lt;span&gt;),
            
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对应自己的路由文件，比如index有参数，就需要写成 /index/param1。&lt;/span&gt;
            routes: ['/', '/detail','/search'&lt;span&gt;],
           
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这个很重要，如果没有配置这段，也不会进行预编译&lt;/span&gt;
            renderer: &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Renderer({
                inject: {
                  foo: &lt;/span&gt;'bar'&lt;span&gt;
                },
                headless: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在 main.js 中 document.dispatchEvent(new Event('render-event'))，两者的事件名称要对应上。&lt;/span&gt;
                renderAfterDocumentEvent: 'render-event'&lt;span&gt;
            })
        })
    ]
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 3、在main.js中加入以下代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
  el: &lt;/span&gt;'#app'&lt;span&gt;,
  router,
  render: h &lt;/span&gt;=&amp;gt;&lt;span&gt; h(App),
  mounted () {
    document.dispatchEvent(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Event('render-event'&lt;span&gt;))
  }
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;4、使用npm run build打包，dist文件里面有每个路由对应的包 &lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1475852/201903/1475852-20190319142125691-957684915.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 而且这里面直接打开index.html文件能够进行访问。&lt;/p&gt;
&lt;p&gt;把这种打包后的文件给了客户端，确实让首屏的加载速度上去了。只是这样打包的文件要比以前打包的文件体积稍大一点，不过综合比较，觉得这样的体验稍好一些，因为都是本地资源，加载速度还是比较快的。&lt;/p&gt;
&lt;p&gt;与客户端合作之旅暂告一段落！&lt;/p&gt;
&lt;p&gt; 个人博客地址：&lt;a href=&quot;https://www.zengfanping.com/&quot; target=&quot;_blank&quot;&gt;https://www.zengfanping.com/&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 19 Mar 2019 06:28:00 +0000</pubDate>
<dc:creator>雨吻蝶</dc:creator>
<og:description>项目经理给客户端提出了个需求，加急做用户反馈界面，很急，安卓客户端项目开发就一个人，表示干不了，短时间内完成不了，于是商量了一番，把前端的我搅和进去了，让新增的用户反馈界面用H5开发。甩锅于前端，经理</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zengfp/p/10558470.html</dc:identifier>
</item>
<item>
<title>迭代器与生成器 中 - 最美的烟火</title>
<link>http://www.cnblogs.com/donghaoblogs/p/10558110.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/donghaoblogs/p/10558110.html</guid>
<description>&lt;p&gt;&lt;strong&gt;迭代器切片&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;问题&lt;/p&gt;
&lt;p&gt;&lt;code&gt;你想得到一个由迭代器生成的切片对象，但是标准切片操作并不能做到。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;解决方案&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;函数 itertools.islice() 正好适用于在迭代器和生成器上做切片操作。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; def count(n):
...     while True:
...         yield n
...         n += 1
...
&amp;gt;&amp;gt;&amp;gt; c = count(0)
&amp;gt;&amp;gt;&amp;gt; c[10:20]
Traceback (most recent call last):
    File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt;
TypeError: 'generator' object is not subscriptable

&amp;gt;&amp;gt;&amp;gt; # Now using islice()
&amp;gt;&amp;gt;&amp;gt; import itertools
&amp;gt;&amp;gt;&amp;gt; for x in itertools.islice(c, 10, 20):
...     print(x)
...
10
11
12
13
14
15
16
17
18
19
&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;迭代器和生成器不能使用标准的切片操作，因为它们的长度事先我们并不知道(并且也没有实现索引)。 函数 islice() 返回一个可以生成指定元素的迭代器，它通过遍历并丢弃直到切片开始索引位置的所有元素。 然后才开始一个个的返回元素，并直到切片结束索引位置。&lt;/p&gt;
&lt;p&gt;这里要着重强调的一点是 islice() 会消耗掉传入的迭代器中的数据。 必须考虑到迭代器是不可逆的这个事实。 所以如果你需要之后再次访问这个迭代器的话，那你就得先将它里面的数据放入一个列表中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;跳过可迭代对象的开始部分&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;问题&lt;/p&gt;
&lt;p&gt;&lt;code&gt;你想遍历一个可迭代对象，但是它开始的某些元素你并不感兴趣，想跳过它们。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;解决方案&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;itertools 模块中有一些函数可以完成这个任务。 首先介绍的是 itertools.dropwhile() 函数。使用时，你给它传递一个函数对象和一个可迭代对象。 它会返回一个迭代器对象，丢弃原有序列中直到函数返回Flase之前的所有元素，然后返回后面所有元素。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为了演示，假定你在读取一个开始部分是几行注释的源文件。比如：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; with open('/etc/passwd') as f:
... for line in f:
...     print(line, end='')
...
##
# User Database
#
# Note that this file is consulted directly only when the system is running
# in single-user mode. At other times, this information is provided by
# Open Directory.
...
##
nobody:*:-2:-2:Unprivileged User:/var/empty:/usr/bin/false
root:*:0:0:System Administrator:/var/root:/bin/sh
...
&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;如果你想跳过开始部分的注释行的话，可以这样做：

&amp;gt;&amp;gt;&amp;gt; from itertools import dropwhile
&amp;gt;&amp;gt;&amp;gt; with open('/etc/passwd') as f:
...     for line in dropwhile(lambda line: line.startswith('#'), f):
...         print(line, end='')
...
nobody:*:-2:-2:Unprivileged User:/var/empty:/usr/bin/false
root:*:0:0:System Administrator:/var/root:/bin/sh
...
&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个例子是基于根据某个测试函数跳过开始的元素。 如果你已经明确知道了要跳过的元素的个数的话，那么可以使用 itertools.islice() 来代替。比如：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; from itertools import islice
&amp;gt;&amp;gt;&amp;gt; items = ['a', 'b', 'c', 1, 4, 10, 15]
&amp;gt;&amp;gt;&amp;gt; for x in islice(items, 3, None):
...     print(x)
...
1
4
10
15
&amp;gt;&amp;gt;&amp;gt;
在这个例子中， islice() 函数最后那个 None 参数指定了你要获取从第3个到最后的所有元素， 如果 None 和3的位置对调，意思就是仅仅获取前三个元素恰恰相反， (这个跟切片的相反操作 [3:] 和 [:3] 原理是一样的)。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;排列组合的迭代&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;你想迭代遍历一个集合中元素的所有可能的排列或组合&lt;/p&gt;
&lt;p&gt;解决方案&lt;/p&gt;
&lt;p&gt;itertools模块提供了三个函数来解决这类问题。 其中一个是&lt;code&gt;itertools.permutations()&lt;/code&gt; ， 它接受一个集合并产生一个元组序列，每个元组由集合中所有元素的一个可能排列组成。 也就是说通过打乱集合中元素排列顺序生成一个元组，比如：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; items = ['a', 'b', 'c']
&amp;gt;&amp;gt;&amp;gt; from itertools import permutations
&amp;gt;&amp;gt;&amp;gt; for p in permutations(items):
...     print(p)
...
('a', 'b', 'c')
('a', 'c', 'b')
('b', 'a', 'c')
('b', 'c', 'a')
('c', 'a', 'b')
('c', 'b', 'a')
&amp;gt;&amp;gt;&amp;gt;
如果你想得到指定长度的所有排列，你可以传递一个可选的长度参数。就像这样：

&amp;gt;&amp;gt;&amp;gt; for p in permutations(items, 2):
...     print(p)
...
('a', 'b')
('a', 'c')
('b', 'a')
('b', 'c')
('c', 'a')
('c', 'b')
&amp;gt;&amp;gt;&amp;gt;
&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用 itertools.combinations() 可得到输入集合中元素的所有的组合。比如：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; from itertools import combinations
&amp;gt;&amp;gt;&amp;gt; for c in combinations(items, 3):
...     print(c)
...
('a', 'b', 'c')

&amp;gt;&amp;gt;&amp;gt; for c in combinations(items, 2):
...     print(c)
...
('a', 'b')
('a', 'c')
('b', 'c')

&amp;gt;&amp;gt;&amp;gt; for c in combinations(items, 1):
...     print(c)
...
('a',)
('b',)
('c',)
&amp;gt;&amp;gt;&amp;gt;```
对于 combinations() 来讲，元素的顺序已经不重要了。 也就是说，组合 ('a', 'b') 跟 ('b', 'a') 其实是一样的(最终只会输出其中一个)。

在计算组合的时候，一旦元素被选取就会从候选中剔除掉(比如如果元素’a’已经被选取了，那么接下来就不会再考虑它了)。 而函数 itertools.combinations_with_replacement() 允许同一个元素被选择多次，比如：

&amp;gt;&amp;gt;&amp;gt; for c in combinations_with_replacement(items, 3):
...     print(c)
...
('a', 'a', 'a')
('a', 'a', 'b')
('a', 'a', 'c')
('a', 'b', 'b')
('a', 'b', 'c')
('a', 'c', 'c')
('b', 'b', 'b')
('b', 'b', 'c')
('b', 'c', 'c')
('c', 'c', 'c')
&amp;gt;&amp;gt;&amp;gt;
&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;序列上索引值迭代&lt;/strong&gt;&lt;br/&gt;问题&lt;br/&gt;&lt;code&gt;你想在迭代一个序列的同时跟踪正在被处理的元素索引。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;解决方案&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;内置的 enumerate() 函数可以很好的解决这个问题：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;内置的 enumerate() 函数可以很好的解决这个问题：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; my_list = ['a', 'b', 'c']
&amp;gt;&amp;gt;&amp;gt; for idx, val in enumerate(my_list):
...     print(idx, val)
...
0 a
1 b
2 c&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了按传统行号输出(行号从1开始)，你可以传递一个开始参数：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; my_list = ['a', 'b', 'c']
&amp;gt;&amp;gt;&amp;gt; for idx, val in enumerate(my_list, 1):
...     print(idx, val)
...
1 a
2 b
3 c&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种情况在你遍历文件时想在错误消息中使用行号定位时候非常有用：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def parse_data(filename):
    with open(filename, 'rt') as f:
        for lineno, line in enumerate(f, 1):
            fields = line.split()
            try:
                count = int(fields[1])
                ...
            except ValueError as e:
                print('Line {}: Parse error: {}'.format(lineno, e))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;enumerate() 对于跟踪某些值在列表中出现的位置是很有用的。 所以，如果你想将一个文件中出现的单词映射到它出现的行号上去，可以很容易的利用 enumerate() 来完成：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;word_summary = defaultdict(list)

with open('myfile.txt', 'r') as f:
    lines = f.readlines()

for idx, line in enumerate(lines):
    # Create a list of words in current line
    words = [w.strip().lower() for w in line.split()]
    for word in words:
        word_summary[word].append(idx)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;同时迭代多个序列&lt;/strong&gt;&lt;br/&gt;问题&lt;br/&gt;&lt;code&gt;你想同时迭代多个序列，每次分别从一个序列中取一个元素。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;解决方案&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;为了同时迭代多个序列，使用 zip() 函数。比如&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; xpts = [1, 5, 4, 2, 10, 7]
&amp;gt;&amp;gt;&amp;gt; ypts = [101, 78, 37, 15, 62, 99]
&amp;gt;&amp;gt;&amp;gt; for x, y in zip(xpts, ypts):
...     print(x,y)
...
1 101
5 78
4 37
2 15
10 62
7 99
&amp;gt;&amp;gt;&amp;gt;
#zip(a, b) 会生成一个可返回元组 (x, y) 的迭代器，其中x来自a，y来自b。 一旦其中某个序列到底结尾，迭代宣告结束。 因此迭代长度跟参数中最短序列长度一致。

&amp;gt;&amp;gt;&amp;gt; a = [1, 2, 3]
&amp;gt;&amp;gt;&amp;gt; b = ['w', 'x', 'y', 'z']
&amp;gt;&amp;gt;&amp;gt; for i in zip(a,b):
...     print(i)
...
(1, 'w')
(2, 'x')
(3, 'y')
&amp;gt;&amp;gt;&amp;gt;
#如果这个不是你想要的效果，那么还可以使用 itertools.zip_longest() 函数来代替。比如：

&amp;gt;&amp;gt;&amp;gt; from itertools import zip_longest
&amp;gt;&amp;gt;&amp;gt; for i in zip_longest(a,b):
...     print(i)
...
(1, 'w')
(2, 'x')
(3, 'y')
(None, 'z')

&amp;gt;&amp;gt;&amp;gt; for i in zip_longest(a, b, fillvalue=0):
...     print(i)
...
(1, 'w')
(2, 'x')
(3, 'y')
(0, 'z')
&amp;gt;&amp;gt;&amp;gt;
&amp;gt;```
#最后强调一点就是， zip() 会创建一个迭代器来作为结果返回。 如果你需要将结对的值存储在列表中，要使用 list() 函数。比如：

&amp;gt;&amp;gt;&amp;gt; zip(a, b)
&amp;lt;zip object at 0x1007001b8&amp;gt;
&amp;gt;&amp;gt;&amp;gt; list(zip(a, b))
[(1, 10), (2, 11), (3, 12)]
&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Tue, 19 Mar 2019 05:42:00 +0000</pubDate>
<dc:creator>最美的烟火</dc:creator>
<og:description>迭代器切片 问题 解决方案 函数 itertools.islice() 正好适用于在迭代器和生成器上做切片操作。 迭代器和生成器不能使用标准的切片操作，因为它们的长度事先我们并不知道(并且也没有实现索</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/donghaoblogs/p/10558110.html</dc:identifier>
</item>
<item>
<title>Java内存溢出异常（上） - 技术小工</title>
<link>http://www.cnblogs.com/qianpangzi/p/10558040.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qianpangzi/p/10558040.html</guid>
<description>&lt;p&gt;上一篇文章我们讲了JVM运行时数据区域与内存溢出异常，其中对于内存溢出异常这部分将的不够详细，这篇文章将着重讲解Java内存溢出异常的相关知识。如果有没看过上一篇文章的小伙伴们，请点击&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/qianpangzi/p/10555612.html&quot;&gt;Java内存区域与内存溢出异常&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;Java的内存溢出异常主要分为两类：分别是内存溢出和栈溢出。在以下几种情况，会抛出内存异常：Java堆溢出、虚拟机栈和本地方法栈溢出、方法区和运行时常量池溢出、以及本机直接内存溢出，下面讲一一介绍这几类异常。&lt;/p&gt;
&lt;h4 id=&quot;Java堆溢出&quot;&gt;Java堆溢出&lt;/h4&gt;
&lt;p&gt;在Java内存区域与内存溢出异常中讲过，Java堆主要是用来存储对象实例的。这部分的内存区域的大小可以通过-Xms参数和-Xmx参数进行设置，通常将-Xms和-Xmx的值设置为相同的值，以减少内存扩展或者收缩时的开销。&lt;/p&gt;
&lt;p&gt;Java堆的空间是有限的，受到物理内存与虚拟机内存的双重限制（通常虚拟机内存的会设置成小于物理内存）。因此，如果对象实例的数量不断增加，而垃圾回收机制没有进行及时清理的时候，对象实例所占用的空间就会达到Java堆的空间最大值。此时，就会因为Java堆内存不足，导致无法为新的实例分配空间，从而抛出OutOfMemoryError异常。&lt;/p&gt;
&lt;p&gt;通过设置-Xms20m -Xmx20m运行以下代码可以模拟这一情况：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
/**
 * VM Args: -Xms20m -Xmx20m
 *
 * @author bdq
 */
public class HeapOOM {
    static class OOMObject {

    }

    public static void main(String[] args) {
        List&amp;lt;OOMObject&amp;gt; objects = new ArrayList&amp;lt;&amp;gt;();
        while (true) {
            objects.add(new OOMObject());
        }
    }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;运行结果：&lt;/p&gt;
&lt;div class=&quot;highlight-wrap&quot; readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
java.lang.OutOfMemoryError: Java heap space
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;这即是常见的OOM异常，针对这类异常，往往在打印异常信息的同时会进一步提示异常原因，如上图所示的”Java heap space”。当然，只靠这点信息不足以判断到底是内存容量设置小了，还是出现了内存泄漏（关于内存泄漏的知识将会在后面的文章中进行讲述）。因此我们还要辅以其他手段来进一步确定问题的根源，比如加上-XX:+HeapDumpOnOutOfMemoryError参数使得虚拟机在出现内存溢出异常时Dump出当前的内存堆转储快照，然后用相关的工具进行分析。这类知识，本篇文章暂不作过多的讲解，将会在后面的文章一一介绍。&lt;/p&gt;
&lt;h4 id=&quot;虚拟机栈和本地方法栈溢出&quot;&gt;虚拟机栈和本地方法栈溢出&lt;/h4&gt;
&lt;p&gt;为什么要把虚拟机栈和本地方法栈的溢出放在一起讨论呢，因为在HotSpot虚拟机中并不区分虚拟机栈和本地方法栈。对于HotSpot来说，虽然说-Xoss参数是用来设置本地方法栈大小，但实际上是无效的，栈的容量只由-Xss参数设定。&lt;/p&gt;
&lt;p&gt;在Java虚拟机规范中对虚拟机栈和本地方法栈描述了两种异常：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常。&lt;/li&gt;
&lt;li&gt;如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这种分类其实并不是很明确，因为内存太小或者已使用的栈空间太大都会导致栈空间无法继续分配。&lt;/p&gt;
&lt;p&gt;StackOverflowError的出现条件很简单，下面这段简单的代码就会出现栈溢出：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public class JavaVMStackSOF {
    private int stackLength = 1;

    public void stackLeak() {
        stackLength++;
        stackLeak();
    }

    public static void main(String[] args) {
        JavaVMStackSOF javaVMStackSOF = new JavaVMStackSOF();
        try {
            javaVMStackSOF.stackLeak();
        } catch (Throwable e) {
            System.out.println(&quot;Stack length:&quot; + javaVMStackSOF.stackLength);
            throw e;
        }
    }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;运行结果如下：&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
Stack length:18663
Exception in thread &quot;main&quot; java.lang.StackOverflowError
        at cn.bdqfork.jvm.JavaVMStackSOF.stackLeak(JavaVMStackSOF.java:12)
        at cn.bdqfork.jvm.JavaVMStackSOF.stackLeak(JavaVMStackSOF.java:12)
        at cn.bdqfork.jvm.JavaVMStackSOF.stackLeak(JavaVMStackSOF.java:12)
        at cn.bdqfork.jvm.JavaVMStackSOF.stackLeak(JavaVMStackSOF.java:12)
    ......
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;对上面的运行结果，不同的计算机Stack length的大小是不确定的，从输出的异常信息来看，是因为stackLeak方法递归调用层数过多导致的。在大多数情况下，栈深度在虚拟机默认参数下是够用的。&lt;/p&gt;
&lt;p&gt;OutOfMemoryError异常比较难以出现，一般发生在多线程环境下。当创建一个线程时，虚拟机会分配一个私有的栈空间给相应的线程，这个空间的大小可以用-Xss参数来设置。通过不断的创建新的进程，可以产生内存溢出异常。&lt;/p&gt;
&lt;p&gt;原因是这样的，当进程运行时，操作系统分配给进程的内存是有限的，Java堆和方法区这两部分占了大部分，忽略到程序计数器所占用的很小的一块内存，不计算虚拟机本身占用的内存，剩下的就由虚拟机栈和本地方法栈所占用。因此，创建的线程数量到达一定程度时，虚拟机栈和本地方法栈所占用的空间就会使得进程的内存空间不够用，从而抛出内存溢出异常。&lt;/p&gt;
&lt;p&gt;这部分的测试代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public class JavaVMStackOOM {
    private void dontStop() {
        while (true) {
            
        }
    }

    public void stackLeakByThread() {
        while (true) {
            Thread thread = new Thread(new Runnable() {
                @Override
                public void run() {
                    dontStop();
                }
            });
            thread.start();
        }
    }

    public static void main(String[] args) {
        JavaVMStackOOM javaVMStackOOM = new JavaVMStackOOM();
        javaVMStackOOM.stackLeakByThread();
    }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这段代码的运行有一定的风险，因为Java的线程并不是完全的用户级线程，有映射到操作系统的部分，所以可能会产生系统假死的现象，请谨慎运行。&lt;/p&gt;
&lt;p&gt;运行结果如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: unable to create new native thread
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;由此可以看出，我们在进行多线程开发时，对于线程的数量要有一定的把握，线程池的复用是很有必要的。&lt;/p&gt;
&lt;p&gt;受限于篇幅原因，剩余的知识点，将会在下一篇进行讲解。&lt;/p&gt;
</description>
<pubDate>Tue, 19 Mar 2019 05:30:00 +0000</pubDate>
<dc:creator>技术小工</dc:creator>
<og:description>这篇文章将着重讲解Java内存溢出异常的相关知识</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qianpangzi/p/10558040.html</dc:identifier>
</item>
<item>
<title>[深度概念]·K-Fold 交叉验证 (Cross-Validation)的理解与应用 - 小宋是呢</title>
<link>http://www.cnblogs.com/xiaosongshine/p/10557891.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaosongshine/p/10557891.html</guid>
<description>&lt;p&gt;&lt;a href=&quot;http://118.25.101.147/&quot; target=&quot;_blank&quot;&gt;我的网站&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;1.K-Fold 交叉验证概念&lt;/h2&gt;
&lt;p&gt;在机器学习建模过程中，通行的做法通常是将数据分为训练集和测试集。测试集是与训练独立的数据，完全不参与训练，用于最终模型的评估。在训练过程中，经常会出现过拟合的问题，就是模型可以很好的匹配训练数据，却不能很好在预测训练集外的数据。如果此时就使用测试数据来调整模型参数，就相当于在训练时已知部分测试数据的信息，会影响最终评估结果的准确性。通常的做法是在训练数据再中分出一部分做为验证(Validation)数据，用来评估模型的训练效果。&lt;/p&gt;
&lt;p&gt;验证数据取自训练数据，但不参与训练，这样可以相对客观的评估模型对于训练集之外数据的匹配程度。模型在验证数据中的评估常用的是交叉验证，又称循环验证。它将原始数据分成K组(K-Fold)，将每个子集数据分别做一次验证集，其余的K-1组子集数据作为训练集，这样会得到K个模型。这K个模型分别在验证集中评估结果，最后的误差MSE(Mean Squared Error)加和平均就得到交叉验证误差。交叉验证有效利用了有限的数据，并且评估结果能够尽可能接近模型在测试集上的表现，可以做为模型优化的指标使用。&lt;/p&gt;
&lt;h2&gt;2.举例说明&lt;/h2&gt;
&lt;p&gt;下面举一个具体的例子来说明K-Fold的过程，比如如下的数据&lt;/p&gt;
&lt;pre class=&quot;has cke_widget_element&quot; data-cke-widget-data=&quot;{&amp;amp;quot;code&amp;amp;quot;:&amp;amp;quot;[0.1, 0.2, 0.3, 0.4, 0.5, 0.6]\n&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;codeSnippet&quot;&gt;
[0.1, 0.2, 0.3, 0.4, 0.5, 0.6]
&lt;/pre&gt;

&lt;p&gt;分为K=3组后&lt;/p&gt;
&lt;pre class=&quot;has cke_widget_element&quot; data-cke-widget-data=&quot;{&amp;amp;quot;code&amp;amp;quot;:&amp;amp;quot;Fold1: [0.5, 0.2]\nFold2: [0.1, 0.3]\nFold3: [0.4, 0.6]\n&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;codeSnippet&quot;&gt;
Fold1: [0.5, 0.2]&lt;br/&gt;Fold2: [0.1, 0.3]&lt;br/&gt;Fold3: [0.4, 0.6]
&lt;/pre&gt;

&lt;p&gt;交叉验证的时会使用如下三个模型，分别进行训练和测试，每个测试集误差MSE加和平均就得到了交叉验证的总评分&lt;/p&gt;
&lt;pre class=&quot;has cke_widget_element&quot; data-cke-widget-data=&quot;{&amp;amp;quot;code&amp;amp;quot;:&amp;amp;quot;Model1: Trained on Fold1 + Fold2, Tested on Fold3\nModel2: Trained on Fold2 + Fold3, Tested on Fold1\nModel3: Trained on Fold1 + Fold3, Tested on Fold2&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;codeSnippet&quot;&gt;
Model1: Trained on Fold1 + Fold2, Tested on Fold3&lt;br/&gt;Model2: Trained on Fold2 + Fold3, Tested on Fold1&lt;br/&gt;Model3: Trained on Fold1 + Fold3, Tested on Fold2
&lt;/pre&gt;

&lt;h2&gt;3.应用讲解&lt;/h2&gt;

&lt;p&gt;1、 将全部训练集S分成k个不相交的子集，假设S中的训练样例个数为m，那么每一个子集有m/k个训练样例，相应的子集称作{&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;11&quot;&gt;&lt;a class=&quot;cke_widget_element&quot; href=&quot;http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103271150021876.png&quot; data-cke-saved-href=&quot;http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103271150021876.png&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103271150037731.png&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;clip_image024&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;68&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;21&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;&gt;&lt;img class=&quot;has&quot; src=&quot;https://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103271150037731.png&quot; alt=&quot;clip_image024&quot; width=&quot;68&quot; height=&quot;21&quot; data-cke-saved-src=&quot;https://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103271150037731.png&quot;/&gt;&lt;/a&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;}。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2、 每次从模型集合M中拿出来一个&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;10&quot;&gt;&lt;a class=&quot;cke_widget_element&quot; href=&quot;http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103271150039335.png&quot; data-cke-saved-href=&quot;http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103271150039335.png&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103271150037665.png&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;clip_image010[3]&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;16&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;21&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;&gt;&lt;img class=&quot;has&quot; src=&quot;https://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103271150037665.png&quot; alt=&quot;clip_image010[3]&quot; width=&quot;16&quot; height=&quot;21&quot; data-cke-saved-src=&quot;https://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103271150037665.png&quot;/&gt;&lt;/a&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;，然后在训练子集中选择出k-1个&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;{&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;9&quot;&gt;&lt;a class=&quot;cke_widget_element&quot; href=&quot;http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103271150035157.png&quot; data-cke-saved-href=&quot;http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103271150035157.png&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103271150032649.png&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;clip_image026&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;121&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;21&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;&gt;&lt;img class=&quot;has&quot; src=&quot;https://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103271150032649.png&quot; alt=&quot;clip_image026&quot; width=&quot;121&quot; height=&quot;21&quot; data-cke-saved-src=&quot;https://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103271150032649.png&quot;/&gt;&lt;/a&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;}（也就是每次只留下一个&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;8&quot;&gt;&lt;a class=&quot;cke_widget_element&quot; href=&quot;http://images.cnblogs.com/cnblogs_com/jerrylead/201103/20110327115004108.png&quot; data-cke-saved-href=&quot;http://images.cnblogs.com/cnblogs_com/jerrylead/201103/20110327115004108.png&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103271150049202.png&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;clip_image028&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;11&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;21&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;&gt;&lt;img class=&quot;has&quot; src=&quot;https://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103271150049202.png&quot; alt=&quot;clip_image028&quot; width=&quot;11&quot; height=&quot;21&quot; data-cke-saved-src=&quot;https://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103271150049202.png&quot;/&gt;&lt;/a&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;），使用这k-1个子集训练&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;7&quot;&gt;&lt;a class=&quot;cke_widget_element&quot; href=&quot;http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103271150047533.png&quot; data-cke-saved-href=&quot;http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103271150047533.png&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103271150051088.png&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;clip_image010[4]&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;16&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;21&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;&gt;&lt;img class=&quot;has&quot; src=&quot;https://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103271150051088.png&quot; alt=&quot;clip_image010[4]&quot; width=&quot;16&quot; height=&quot;21&quot; data-cke-saved-src=&quot;https://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103271150051088.png&quot;/&gt;&lt;/a&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;后，得到假设函数&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;6&quot;&gt;&lt;a class=&quot;cke_widget_element&quot; href=&quot;http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103271150053007.png&quot; data-cke-saved-href=&quot;http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103271150053007.png&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103271150059386.png&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;clip_image030&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;17&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;21&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;&gt;&lt;img class=&quot;has&quot; src=&quot;https://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103271150059386.png&quot; alt=&quot;clip_image030&quot; width=&quot;17&quot; height=&quot;21&quot; data-cke-saved-src=&quot;https://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103271150059386.png&quot;/&gt;&lt;/a&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;。最后使用剩下的一份&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;5&quot;&gt;&lt;a class=&quot;cke_widget_element&quot; href=&quot;http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103271150069353.png&quot; data-cke-saved-href=&quot;http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103271150069353.png&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103271150062908.png&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;clip_image028[1]&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;11&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;21&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;&gt;&lt;img class=&quot;has&quot; src=&quot;https://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103271150062908.png&quot; alt=&quot;clip_image028[1]&quot; width=&quot;11&quot; height=&quot;21&quot; data-cke-saved-src=&quot;https://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103271150062908.png&quot;/&gt;&lt;/a&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;作测试，得到经验错误&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;4&quot;&gt;&lt;a class=&quot;cke_widget_element&quot; href=&quot;http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103271150064304.png&quot; data-cke-saved-href=&quot;http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103271150064304.png&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103271150061795.png&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;clip_image032&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;42&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;21&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;&gt;&lt;img class=&quot;has&quot; src=&quot;https://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103271150061795.png&quot; alt=&quot;clip_image032&quot; width=&quot;42&quot; height=&quot;21&quot; data-cke-saved-src=&quot;https://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103271150061795.png&quot;/&gt;&lt;/a&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3、 由于我们每次留下一个&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;3&quot;&gt;&lt;a class=&quot;cke_widget_element&quot; href=&quot;http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103271150071762.png&quot; data-cke-saved-href=&quot;http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103271150071762.png&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103271150071729.png&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;clip_image028[2]&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;11&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;21&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;&gt;&lt;img class=&quot;has&quot; src=&quot;https://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103271150071729.png&quot; alt=&quot;clip_image028[2]&quot; width=&quot;11&quot; height=&quot;21&quot; data-cke-saved-src=&quot;https://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103271150071729.png&quot;/&gt;&lt;/a&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;（j从1到k），因此会得到k个经验错误，那么对于一个&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;2&quot;&gt;&lt;a class=&quot;cke_widget_element&quot; href=&quot;http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103271150071696.png&quot; data-cke-saved-href=&quot;http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103271150071696.png&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103271150071663.png&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;clip_image010[5]&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;16&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;21&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;&gt;&lt;img class=&quot;has&quot; src=&quot;https://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103271150071663.png&quot; alt=&quot;clip_image010[5]&quot; width=&quot;16&quot; height=&quot;21&quot; data-cke-saved-src=&quot;https://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103271150071663.png&quot;/&gt;&lt;/a&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;，它的经验错误是这k个经验错误的平均。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;4、 选出平均经验错误率最小的&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;1&quot;&gt;&lt;a class=&quot;cke_widget_element&quot; href=&quot;http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103271150081630.png&quot; data-cke-saved-href=&quot;http://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103271150081630.png&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103271150081597.png&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;clip_image010[6]&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;16&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;21&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;&gt;&lt;img class=&quot;has&quot; src=&quot;https://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103271150081597.png&quot; alt=&quot;clip_image010[6]&quot; width=&quot;16&quot; height=&quot;21&quot; data-cke-saved-src=&quot;https://images.cnblogs.com/cnblogs_com/jerrylead/201103/201103271150081597.png&quot;/&gt;&lt;/a&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;，然后使用全部的S再做一次训练，得到最后的&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;0&quot;&gt;&lt;a class=&quot;cke_widget_element&quot; href=&quot;http://images.cnblogs.com/cnblogs_com/jerrylead/201103/20110327115008692.png&quot; data-cke-saved-href=&quot;http://images.cnblogs.com/cnblogs_com/jerrylead/201103/20110327115008692.png&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://images.cnblogs.com/cnblogs_com/jerrylead/201103/20110327115009659.png&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;clip_image012[4]&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;12&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;21&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;&gt;&lt;img class=&quot;has&quot; src=&quot;https://images.cnblogs.com/cnblogs_com/jerrylead/201103/20110327115009659.png&quot; alt=&quot;clip_image012[4]&quot; width=&quot;12&quot; height=&quot;21&quot; data-cke-saved-src=&quot;https://images.cnblogs.com/cnblogs_com/jerrylead/201103/20110327115009659.png&quot;/&gt;&lt;/a&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;核心内容：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过上述1,2,3步进行模型性能的测试，取平均值作为某个模型的性能指标&lt;/p&gt;
&lt;p&gt;根据性能指标来挑选出最优模型，再进行上述第4步重新进行训练，获得最终模型&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;疑问解答：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.为什么不直接拆分训练集与数据集，来验证模型性能，反而采用多次划分的形式，岂不是太麻烦了？&lt;/p&gt;
&lt;p&gt;我们为了防止在训练过程中，出现过拟合的问题，通行的做法通常是将数据分为训练集和测试集。测试集是与训练独立的数据，完全不参与训练，用于最终模型的评估。这样的直接划分会导致一个问题就是测试集不会参与训练，这样在小的数据集上会浪费掉这部分数据，无法使模型达到最优（数据决定了程性能上限，模型与算法会逼近这个上限）。但是我们又不能划分测试集，因为需要验证网络泛化性能。采用K-Fold 多次划分的形式就可以利用全部数据集。最后采用平均的方法合理表示模型性能。&lt;/p&gt;
&lt;p&gt;2.为什么还要进行所有数据集重新训练，是否太浪费时间？&lt;/p&gt;
&lt;p&gt;我们通过K-Fold 多次划分的形式进行训练是为了获取某个模型的性能指标，单一K-Fold训练的模型无法表示总体性能，但是我们可以通过K-Fold训练的训练记录下来较为优异的超参数，然后再以最优模型最优参数进行重新训练，将会取得更优结果。&lt;/p&gt;
&lt;p&gt;3.何时使用K-Fold&lt;/p&gt;
&lt;p&gt;我的看法，数据总量较小时，其他方法无法继续提升性能，可以尝试K-Fold。其他情况就不太建议了，例如数据量很大，就没必要更多训练数据，同时训练成本也要扩大K倍（主要指的训练时间）。&lt;/p&gt;
&lt;h2&gt;4.参考&lt;/h2&gt;
&lt;p&gt;1.&lt;a href=&quot;https://www.jianshu.com/p/284581d9b189&quot; data-cke-saved-href=&quot;https://www.jianshu.com/p/284581d9b189&quot;&gt;K-Fold 交叉验证 (Cross-Validation)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2.&lt;a id=&quot;cb_post_title_url&quot; href=&quot;https://www.cnblogs.com/jerrylead/archive/2011/03/27/1996799.html&quot; data-cke-saved-href=&quot;https://www.cnblogs.com/jerrylead/archive/2011/03/27/1996799.html&quot;&gt;规则化和模型选择（Regularization and model selection）&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 19 Mar 2019 04:47:00 +0000</pubDate>
<dc:creator>小宋是呢</dc:creator>
<og:description>K-Fold 交叉验证 (Cross-Validation)的理解与应用 我的网站 1.K-Fold 交叉验证概念 在机器学习建模过程中，通行的做法通常是将数据分为训练集和测试集。测试集是与训练独立的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiaosongshine/p/10557891.html</dc:identifier>
</item>
</channel>
</rss>