<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>java 11 值得关注的新特性 - 西北野狼</title>
<link>http://www.cnblogs.com/androidsuperman/p/10347327.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/androidsuperman/p/10347327.html</guid>
<description>&lt;p&gt;JEP 181: Nest-Based Access Control 基于嵌套的访问控制&lt;/p&gt;
&lt;p&gt;JEP 309: Dynamic Class-File Constants 动态类文件&lt;/p&gt;
&lt;p&gt;JEP 315: Improve Aarch64 Intrinsics 改进 Aarch64 的效率&lt;/p&gt;
&lt;p&gt;JEP 318: Epsilon: A No-Op Garbage Collector 无任何操作的垃圾收集器Epsilon（实验性质）&lt;/p&gt;
&lt;p&gt;JEP 320: Remove the Java EE and CORBA Modules 删除Java EE 和CORBA模块&lt;/p&gt;
&lt;p&gt;JEP 321: HTTP Client (Standard) http客户端标准api&lt;/p&gt;
&lt;p&gt;JEP 323: Local-Variable Syntax for Lambda Parameters 局部变量的lambda表达式&lt;/p&gt;
&lt;p&gt;JEP 324: Key Agreement with Curve25519 and Curve448 新增Curve25519和Curve448加密算法&lt;/p&gt;
&lt;p&gt;JEP 327: Unicode 10&lt;/p&gt;
&lt;p&gt;JEP 328: Flight Recorder 飞行记录仪，记录虚拟机内部运作细节&lt;/p&gt;
&lt;p&gt;JEP 329: ChaCha20 and Poly1305 Cryptographic Algorithms 加密算法&lt;/p&gt;
&lt;p&gt;JEP 330: Launch Single-File Source-Code Programs 源程序直接执行&lt;/p&gt;
&lt;p&gt;JEP 331: Low-Overhead Heap Profiling 低成本的堆分析&lt;/p&gt;
&lt;p&gt;JEP 332: Transport Layer Security (TLS) 1.3 安全方面的更新&lt;/p&gt;
&lt;p&gt;JEP 333: ZGC: A Scalable Low-Latency Garbage Collector (Experimental)&lt;/p&gt;
&lt;p&gt;ZGC: 可扩展的低延迟垃圾收集器（实验性质）&lt;/p&gt;
&lt;p&gt;JEP 335: Deprecate the Nashorn JavaScript Engine Nashorn JavaScript废弃掉&lt;/p&gt;
&lt;p&gt;JEP 336: Deprecate the Pack200 Tools and API 压缩工具废弃&lt;/p&gt;
</description>
<pubDate>Fri, 01 Feb 2019 15:44:00 +0000</pubDate>
<dc:creator>西北野狼</dc:creator>
<og:description>JEP 181: Nest Based Access Control 基于嵌套的访问控制 JEP 309: Dynamic Class File Constants 动态类文件 JEP 315: Im</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/androidsuperman/p/10347327.html</dc:identifier>
</item>
<item>
<title>XGBoost小记 - 0xCAFE</title>
<link>http://www.cnblogs.com/0xcafe/p/10347304.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/0xcafe/p/10347304.html</guid>
<description>&lt;p&gt;//TODO&lt;/p&gt;

&lt;h2&gt;2.1输入&lt;/h2&gt;
&lt;p&gt;数据的特征分为两类，一类是连续型，比如：体重，一种是分类型，比如性别。&lt;/p&gt;
&lt;p&gt;在scikit-learn中的Glossary of Common Terms and API Elements有这么一段话：&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Categorical Feature&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;A categorical or nominal feature is one that has a finite set of discrete values across the population of data. These are commonly represented as columns of integers or strings. Strings will be rejected by most scikit-learn estimators, and integers will be treated as ordinal or count-valued. For the use with most estimators, categorical variables should be one-hot encoded. &lt;span&gt;Notable exceptions include tree-based models such as random forests and gradient boosting models that often work better and faster with integer-coded categorical variables.&lt;/span&gt; OrdinalEncoder helps encoding string-valued categorical features as ordinal integers, and OneHotEncoder can be used to one-hot encode categorical features. See also Encoding categorical features and the http://contrib.scikit-learn.org/categorical-encoding package for tools related to encoding categorical features.&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;大意是在利用基于树的模型训练时推荐使用数值编码而不是one-hot编码。&lt;/p&gt;
&lt;p&gt;详情：https://scikit-learn.org/stable/glossary.html#glossary&lt;/p&gt;
&lt;h2&gt;2.2输出&lt;/h2&gt;
&lt;p&gt;在这里只说两点：multi:softmax和multi:softprob，官方文档是这么说的：&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;span&gt;multi:softmax: set XGBoost to do multiclass classification using the softmax objective, you also need to set num_class(number of classes)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;multi:softprob: same as softmax, but output a vector of ndata * nclass, which can be further reshaped to ndata * nclass matrix. The result contains predicted probability of each data point belonging to each class.&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在这里略坑，建立model时无论填哪一个，在model fit之后，打印模型时参数却都是multi:softprob，但是predict的结果也和上述解释也不一致，结果是multi:softmax的结果，只有预测的标签，没有概率分布。&lt;/p&gt;
&lt;p&gt;官方代码如下：可见num_class也是不用设置的，objective被强制替换成了multi:softprob.最后若想输出概率分布请用predict_proba函数来预测.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
self.classes_ =&lt;span&gt; np.unique(y)
self.n_classes_ &lt;/span&gt;=&lt;span&gt; len(self.classes_)

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; self.n_classes_ &amp;gt; 2&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Switch to using a multiclass objective in the underlying XGB instance&lt;/span&gt;
            xgb_options[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;objective&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;multi:softprob&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
            xgb_options[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;num_class&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = self.n_classes_
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;//TODO&lt;/p&gt;
</description>
<pubDate>Fri, 01 Feb 2019 15:28:00 +0000</pubDate>
<dc:creator>0xCAFE</dc:creator>
<og:description>1.原理 //TODO 2.Python Package Scikit-Learn API 2.1输入 数据的特征分为两类，一类是连续型，比如：体重，一种是分类型，比如性别。 在scikit-lear</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/0xcafe/p/10347304.html</dc:identifier>
</item>
<item>
<title>微信为什么要搞一个小游戏？ - 石桥码农</title>
<link>http://www.cnblogs.com/sban/p/10347071.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sban/p/10347071.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/567788/201902/567788-20190201212425836-1341291777.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;众厂关于 H5 游戏市场的争夺，自 2014 年以来，一直就没有停止过。但一直也没有尘埃落定，最终花落谁家，鹿死谁手现在还不好讲。微信推出小程序，继而推出小游戏，只是腾讯数年来在 H5 市场企业战略的一环。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;微信为什么要自定义一套技术，起名为小程序？明明就是原来的 H5 技术，为什么 CSS 不叫 CSS，叫 WXSS；为什么 HTML 不叫 HTML，叫 WXML；为什么明明有 JS、TS，还要自主研发一个 WXS，并且声称“WXS 与 JS 是不同的语言，有自己的语法，并不和 JS 一致”、“在 iOS 设备上小程序内的 WXS 会比传统 JS 代码快 2 ~ 20 倍”。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;这一切固然有技术革新、提升效率的考量，但从商业竞争上考虑，也是为了获得话语权，以便掌握更多市场主动权。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;目录&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;一、关于H5&lt;/p&gt;
&lt;p&gt;1.1，H5兴起的原因&lt;/p&gt;
&lt;p&gt;1.2，H5游戏的技术缺陷&lt;/p&gt;
&lt;p&gt;二、关于H5的市场争夺，腾讯一直在做&lt;/p&gt;
&lt;p&gt;三、关于微信小程序/小游戏的兴起&lt;/p&gt;
&lt;p&gt;3.1，资本对小游戏的看法&lt;/p&gt;
&lt;p&gt;3.2，激烈竞争的小游戏生态&lt;/p&gt;
&lt;p&gt;3.3，第三方开发引擎对小游戏的支持&lt;/p&gt;
&lt;p&gt;3.4，微信对小游戏开发者的支持&lt;/p&gt;
&lt;p&gt;3.5，微信对小游戏开发者的限制&lt;/p&gt;
&lt;p&gt;四、个人应该开发什么类型的小程序？&lt;/p&gt;
&lt;p&gt;4.1，从《围住神经猫》看，轻度社交类是首选&lt;/p&gt;
&lt;p&gt;4.2，从2015年曾经火爆的产品来看，重度游戏难以持久&lt;/p&gt;
&lt;p&gt;4.3，后H5时代留下来的都是什么游戏类型&lt;/p&gt;
&lt;p&gt;4.4，适合个人开发的只有休闲社交游戏，但并不是所有都适合&lt;/p&gt;
&lt;p&gt;4.5，从哪里学习小游戏的创意&lt;/p&gt;
&lt;p&gt;五，企业应该开发什么类型的小程序？&lt;/p&gt;
&lt;p&gt;六、小游戏如何盈利？&lt;/p&gt;
&lt;p&gt;6.1，小游戏的盈利模式有哪些&lt;/p&gt;
&lt;p&gt;6.2，个人开发者的希望在哪里？&lt;/p&gt;
&lt;p&gt;七、小游戏如何推广？&lt;/p&gt;
&lt;p&gt;入、微信为什么不做一个小程序/小游戏应用中心？&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;hr/&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;一、关于 H5&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;一切都要从 H 5说起。H5 是 HTML5 的简称，HTML5 是 HTML 最新的修订版本，起订于 2013 年，于 2014 年正式颁布。H5 已经不是一门简单的标识性语言，而是一项综合技术，除了最基本的JS、CSS、HTML之外，还提供音频、视频、图像动画（包括硬件加速）、本地存储等各种浏览器宿主接口。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;1.1，H5 兴起的原因&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;H5 的兴起，不是哪个大厂独立策划和运营的效果，而是由众多平台、公司在全球互联网市场经济的相互作用下自然发展的结果。可以从以下四个方面总结H5 兴起的原因。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;（1）从市场角度看 H5 兴起&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;最早尝试新技术的公司，他们最先应用 H5 技术制作出了炫酷的互动页面。市场人员为了推广效果，在客户面前会将自家技术夸大，市场营销人员的吹嘘，促进了 H5 技术的传播。凡是看到过H5页面效果的客户，他们也会要求自家技术人员实现同样的效果。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;产品是最好的名片，效果是最好的宣传单。使用 H5 制作响应式互动页面，催生了一批 H5 制作公司，例如易企秀、人人秀、MAKA、百度H5、腾讯玉兔、腾讯风铃、搜狐快站、京东密享等。新的技术总是意味着新的机遇，就连百度、腾讯这样的大公司，也参与了新技术的角逐。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;（2）从原 App 的缺陷看 H5 兴起&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic3.zhimg.com/80/v2-e2197fe12771d543e1dc128012ee3702_hd.jpg&quot; alt=&quot;&quot; width=&quot;366&quot; height=&quot;244&quot; data-caption=&quot;&quot; data-size=&quot;small&quot; data-rawwidth=&quot;600&quot; data-rawheight=&quot;400&quot; data-original=&quot;https://pic3.zhimg.com/v2-e2197fe12771d543e1dc128012ee3702_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-e2197fe12771d543e1dc128012ee3702_b.jpg&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;经过 5 年的秘密研发，2007 年 1 月 9 日，乔布斯在 Macworld 发布会上宣布，“我们重新定义了手机”。乔布斯不但是重新定义了手机，还改变了人们进行电子娱乐的方式。在 iPhone 之前，人们在任天堂、索尼等游戏机上玩游戏，购买的是设备和介质；在 iPhone 之后，人们只需要花很少的钱，就可以随时随地玩无限多的游戏。手机内存虽然不是无限大，但可以删除、重新下载新游戏。iPhone 革的是传统游戏厂商的命。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;2008 年 7 月 11 日，App Store 上线。3 天后，App Store 就迎来了 800 个应用，和一千万人次的下载。在 iPhone 初期，所有风靡一时的好游戏都是单机版，例如《愤怒的小鸟》《水果忍者》等。因为那时候无线网络不发达，户外只有2G网络，Wifi 只存在于办公室、家里和街上少量的咖啡馆里。人们需要通过 Wifi 或通过 iTunes 软件在电脑上下载、安装 App。那个时候，下载和安装 App 并不是一件麻烦事，而且还是一件幸福的事。它帮用户节省了流量。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;但事情很快就发生了变化。2015 年，在国内伴随着国务院印发《关于加快宽带网络建设推进网络提速降费的指导意见》，4G网络很快在中国城市里得到了普及。原来只在单机版领域耕耘的游戏开发商，继而转战手机网游，这时期诞生了一批质量不错的手游，如网易的《阴阳师》、腾讯的《王者荣耀》等。大厂的杀入，意味着研发成本和推广成本的飙升。单用户获客成本，由原来的几块钱迅速上升到了几十块钱甚至一百多块。竞争如此白炽化，小公司已经没有机会进入了。创业团队和独立游戏开发者，只能另觅出路。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;这个时候，H5 进入了开发者的视野。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;早在 2011 年，国外 Mozilla 公司的沙利文就在一篇科技报道中预言，App 没有未来，Web App 才是未来。这里的 Web App，即使用 H5 技术开发的微站应用。沙利文的理由主要有以下三点：一、开发 App 要适配 Android、iOS 等多个系统，学习多门技术，这是反人类的；二，开发一个 Navtive App（相比Web App，原来的 App 称之为 Native App）的成本，可以开发 3 ~ 10 个 Web App；三，虽然 Web App 与 Native App 的体验还有些差距，但这只是时间问题。随着手机硬件性能的提升，差距会越来越小。沙利文预言，Web App 的真正爆发，只差一个合适而完备的商业模式。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;2014 年，手游和端游都已是红海，H5 游戏尚是蓝海。使用H5开发游戏成本低，做一个 App 手游的钱可以做 10 个 H5 游戏，创业者第一个试水项目都乐于从 H5 技术入手。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;2016 年，DCloud CEO 王安曾表示，在电商转化场景中 H5 具有天生的优势。例如，当用户看到一个电商广告，想下单购买。但需要扫码 -&amp;gt; 下载 App -&amp;gt; 安装 -&amp;gt; 注册 -&amp;gt; 付费，这个流程太繁琐了，成单率低。但如果是微页面，只需扫码 -&amp;gt; 秒开 H5 页面 -&amp;gt; 付费，流程就会顺畅许多，成单率高。这个想法，一年以后张小龙用微信小程序实现了，无须下载，扫码即用，用完即走。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;（3）从原 HTML 技术的缺陷看 H5 兴起&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;在 H5 之前，HTML 是没有办法播放视频和处理动画的，这一切都需要通过 Adobe 的 Flash 技术完成。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;2010 年，苹果 CEO 乔布斯发表了一篇文章：“Thoughts on Flash（对 Flash 的想法）”，将 Adobe Flash Player 的性能和潜在安全问题暴露在开发者面前。乔布斯给 Adobe CEO 打电话解决问题，被拒接。乔布斯认为 Adobe 根本没有解决软件工程问题的意愿，遂决定 iPhone 浏览器不再支持 Flash。后来的事实证明，乔布斯的决定是正确的。其它 Android 手机虽然支持 Flash，但性能表现不佳。当然当时 Android 手机的性能普遍表现不佳，某一点表现不佳并不明显。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;在当时音视频网站已经相当普及。2005 创立的 Youtube，在 2010 年每日视频浏览量已经达到了 20 亿次。这些视频都是以 Flash 技术播放的。包括其它使用 Flash 技术开发的页游、社游、视频直播网站等互联网产品形态，迫切需要有一个新技术替代 Flash。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;事实上 H5 新增的音视频功能，及 Canvas 绘图 Api 很好的替代了 Flash 技术在 PC 互联网时代扮演的角色。当下除了教育行业使用 AIR 研发教育产品，广告业公司使用 Flash CS 制作广告片之外，已经很少有开发者使用 Flash 技术了。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;（4）从 SaaS 的发展看 H5 兴起&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;Saas 是 Software as a Service 的缩写，中文软件即服务。这是一种通过 Internet 提供软件服务的模式，用户不用再购买软件，而改用向提供商租用基于 Web 的软件，来管理企业经营活动，且无需对软件进行日常维护。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;木疙瘩 CEO 王志认为，HTML5 真正会带来革命性变化的是它会让很多软件云端化。王志认为，90% 的软件以后不再是客户端软件了，将会变成服务在浏览器就可以使用。这个变化基于两点：一，H5 带来了这种能力，它允许开发者访问硬盘，允许调数据库、摄像头、地图等，它把浏览器的功能极大扩展了；二，云计算和 4G 网络的发展，催生了 SaaS 的发展。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;1.2，H5 游戏的技术缺陷&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;当然，H5 也不是没有缺点。自 2014年《围住神经猫》火爆以后，H5 游戏一直被寄予重望，期待其成为新风口。但几年过去了，H5 游戏一直不温不火。偶尔海面泛起的涟漪，撑不起一众游戏开发者海盗的野心。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;H5 游戏一般在手机 App 内或在浏览器内打开，网络不好时，加载页面需要十几秒，体验非常不好。并且 H5 游戏没有办法全屏，很多时候都要带一着多余的 App 导航条。有时候在横屏模式下，一个顶部导航占去了差不多 50% 的屏幕，很影响玩家体验。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;H5 游戏开发商普通认为，目前 H5 尚存在以下三个问题：一，兼容性。并不是所有手机都支持 WebGL 加速；二，安全性。所有页面源码都像在裸奔，精心打造的精致页面很容易被山寨团队抄袭；三、性能问题。虽然差距越来越小，但在某些 Android 低端机上，H5 页面还是会很卡顿。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;二、关于 H5 的市场争夺，腾讯一直在做&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;自 2015 年 H5 游戏市场爆出千万流水的产品之后，腾讯一直在布局 H5 市场，并且是内部多个部门同时在做。腾讯主要是以下三个平台：&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;（1）QQ 游戏中心&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;在移动 QQ 游戏中心中， 有一个独立类目，叫秒玩专区。该类目下所有产品均为 H5 游戏，目前共有 5 款：《欢乐消消消》、《保卫萝卜迅玩版》、《欢乐斗地主 H5》、《全民大乐斗》以及《爱消除乐园》。每款产品都堪称重磅，而《欢乐消消消》和《爱消除乐园》，均为休闲品类中用户量最大，接受最广泛的消除类产品。这些游戏无论是在美术品质、还是用户体验方面都堪称精品之作。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;为什么叫秒玩专区，因为单局时间短，符合网民时间日益碎片化的生活特点。消除类游戏虽然为都市青年喜爱，是最佳H5游戏类型，但腾讯做了，个人开发者和小微团队就不要做了。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;（2）QQ 厘米游戏平台&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;在 2016 年 7 月发布的厘米秀，已经推出过不少 H5 小游戏，包括腾讯自研的《厘米 Fly》，《厘米大乱斗》，《欢乐斗地主》等。其中《厘米 Fly》单产品存量用户已达 1.2 亿。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;腾讯在“厘米游戏开放平台发布会”上，称厘米游戏平台是一个互动平台。腾讯集团副总裁殷宇表示，“游戏正逐渐成为年轻人主流的一种社交方式”。由此可见，腾讯将“社交”作为 H5 游戏市场的突破点。在厘米平台上，游戏多为时长较短的轻度竞技游戏。这对开发者的启示是，在腾讯平台做游戏产品，互动是关键，社交是灵魂。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;（3）QQ 空间玩吧&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;在 2017 年 4 月召开的以“开放·成长”为主题的 QQ 空间 H5 游戏大会上，腾讯公司副总裁梁柱指出，QQ 空间 H5 小游戏整体运营向“轻量级、休闲类，容易上手方向”发展。QQ 空间玩吧接入的产品主要为休闲益智、策略经营，社交桌游，轻度 RPG 等四大类别，数量达几百款。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;在社交平台如何做 H5 游戏，想必开发者都没有腾讯系自家平台理解得深刻。单局时间短、易上手、休闲益智、轻度社交互动等等，如果只有这些类型的 H5 游戏才能腾讯系平台上赚钱，那么腾讯都做了，还需要开发者做什么？&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;三、关于微信小程序 / 小游戏的兴起&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;2017 年 1 月 9 日，在乔布斯发布 iPhone 一代整整十年之后，张小龙在微信公开课发布了小程序。小游戏是小程序的一个特别类目，两者的开发工具和运行环境都是相同的，一年后在微信 6.6.1 的版本更新中推出。如果小程序尚有 UI 框架的束缚（以使小程序产品保持队形整齐），那么小游戏完全可以自由驰骋创意。小程序和小游戏本质上都是 H5 技术的延伸。小游戏虽然名字中有“游戏”二字，但一切不适合用小程序实现的创意，都可以用小游戏实现。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;张小龙实现了 2011 年沙利文预想的合适的商业平台：&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;（1）获客成本低。&lt;/p&gt;
&lt;p&gt;（2）具有强大的跨平台特性。&lt;/p&gt;
&lt;p&gt;（3）具有良好的运行性能。目前与原生 App 尚有差距，但差距在慢慢缩小。&lt;/p&gt;
&lt;p&gt;（4）具有良好的 App 引流转化能力，从小程序中可以直接向 App 跳转。仅此一点，就可能革掉 4399、3366。&lt;/p&gt;
&lt;p&gt;（5）通过小软件包规定和使用离线缓存，解决了传统 Web App 的卡顿问题。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;2018 年 4 月 26 日，在 2018 微信朋友圈小游戏专场活动的现场，微信小游戏团队首次公布了开放后的最新成绩，已发布小游戏达 300 多款，数款小游戏实现总用户规模过亿，多款小游戏单月安卓端流水超千万。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;《跳一跳》是微信开屏推荐的第一款小游戏，从此“玩一个小游戏才是正经事”走入千家万户，原来从不玩游戏的小学生和退体老人也赶热闹，做一做这个正经事。《跳一跳》是 2018 年春节最受用户欢迎的小程序，最高同时在线 2800 万，日活跃用户达到 1.7 亿。美国著名运动品牌耐克在《跳一跳》中投了三天的植入广告，花了 2000 万人民币。《跳一跳》很好的为 H5 游戏开发商打了个样，但开发商如果想再造《跳一跳》的辉煌，几乎是不可能的。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;3.1，资本对小游戏的看法&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;2018 年，金沙江创投董事总经理朱啸虎几乎在其出席的每一场峰会上都要谈到他对“小程序”的看好。朱啸虎表示，“小游戏是最有潜力的领域之一”，“去年（2017年）小程序披露的投资是 7 亿，而今年（2018 年）到 4 月份，这个数字可能已经加了个零，达到了 70 亿”。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;3.2，激烈竞争的小游戏生态&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;据悉，包括腾讯互娱的自研工作室、飞鱼科技、第七大道、掌趣、电魂、三七互娱、西山居、盛大等众多大型游戏厂商都已经上线了自己的微信小游戏，或者处于马上上线和正在研发当中。以《最强弹一弹》《海盗来了》《欢乐球球》等小游戏为例，其日活都在千万级别。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;截至2018年3月，微信小程序的月活跃用户规模已经突破了 4 亿，小游戏数量已经达到了 300 多款，DAU 超过 1000 万的游戏有数款。头脑王者团队的《海盗来了》、腾讯的《欢乐斗地主》和《全民大乐斗》三款游戏月流水已经过千万。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;小游戏研发成本低，获客成本低，资本的鼓动，以及先行者的获利，让开发者们趋之若鹜，像飞蛾奔向小游戏战场。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;前飞鱼游戏的负责人张志斌表示，他正带领着一家小型游戏创业公司 All IN 小游戏，用他的话来说“这是千载难逢的巨大机会，怎么着也得杀进去”。除了手头已经开发了接近半年的休闲动作类小游戏，目前张志斌的团队还在同时进行着多款小游戏的研发，每个项目只有 2 ~ 3 个团队成员参与。对于很多游戏开发商特别是小微团队来说，不需要付出太多成本就可以在一个 10 亿用户的平台上上线新游戏，这在之前是“想都不敢想的事”。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;深圳一家小游戏开发端表示，他们整个办公楼层从事小游戏开发的就有近 20 家，很多时候自家的小游戏刚在微信平台审核通过，几天后就能在平台上看到很多类似的游戏。山寨问题，已经开始损害开发者的热情。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;在北上广深，换皮手游的成本在 80 ~ 150 万之间。这个成本可以做五六款小游戏，并且速度非常快，如果做出来量不错的话还可以给自己的 App 产品导流。对于自研团队，在成功研发多款小游戏后，研发周期与成本都会降低。这是山寨团队的生存之道。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;由于小程序开发门槛低，从事过软件开发的企业都能向这个方向转型，或同时拓展这项业务。做的团队多了，市场价格自然就低，利润被压保。1000 块可以做出一款小游戏，10000 块也可以做出一款小游戏。激烈的竞争，同质化，抄袭和山寨现象，让小游戏平台鱼目混杂，后进场者们感到彷徨，同时又担心错失良机。在欲望面前，大家一样浮躁。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;3.3，第三方开发引擎对小游戏的支持&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;第三方公司也纷纷推出工具套装，开始支持小游戏开发。在 H5 时代就已赫赫有名的三家游戏引擎，均已支持小游戏，它们是：&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;1，Layabox，开发速度快，软件包小，游戏画面品质略低；&lt;/p&gt;
&lt;p&gt;2，白鹭，可以保证品质和软件包大小适当；&lt;/p&gt;
&lt;p&gt;3，Cocos2d，软件包较大，游戏画面品质较高；&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;开发者使用最多的是白鹭。这款从 Adobe 时代进化而来的游戏引擎，在框架结构和 Api 风格上都与原 Adobe Flex 技术很像。该引擎的首席架构师是原 Adobe 平台技术经理马鉴，网名叫 7yue，老闪客都很熟悉这个名字。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;如果技术人员原来会 AS3 编程，开发过页游或社游，现在团队准备上小游戏战场做换皮游戏导游，无疑，白鹭引擎是首选。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;3.4，微信对小游戏开发者的支持&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;微信一直想办法促进开发者加入小游戏生态。自小游戏发布以来，微信每天都在紧锣密鼓地完善开发工具和类库，以给开发者提供更多、更方便的平台功能和技术接口。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;默认微信对所有小游戏的渠道技术费统一按 40% 比例收取。2018 年 4 月 19 日，微信在新一期的小游戏开发者扶持计划中宣布，在 2018 年内，每款小游戏每月安卓内购流水在 50 万元以下（包含 50 万）部分，腾讯收取的 40% 渠道技术服务费将反哺给小游戏开发者，即腾讯不收取此部分的渠道技术服务费 2019 年该反哺政策是否有效，到时再说。不过由于微信与苹果在游戏付费支付方面的条款还没谈妥，iOS 版本小游戏没有内购付费功能，所以微信的反哺计划只集中在 Android 端。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;针对抄袭、盗版等问题，微信官方已正式发布小游戏原创保护措施，将从名称保护，侵权投诉，技术以及运营等多方面来保护游戏开发者的权益。&lt;/p&gt;
&lt;p&gt;微信工作人员李卿表示，“微信小游戏目前还是一个新生事物，作为平台，还是希望能更多地激发开发者去创造，而不是想着去盈利。” 但是作为开发者，生存是第一要务，如果挣不到钱，哪有力气开发游戏呢。毕竟微信给微信员工发了薪资，并没有给开发者发了薪资。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;3.5，微信对小游戏开发者的限制&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;由于技术力量有限，许多小微团队对如何做出H5精品小游戏并没有太大热情，更多寄望于依赖社交网络的病毒传播效应一夜成名。为了促进用户分享，开发者们使用了“复活分享”等许多招术。“复活分享”即是当用户玩游戏没有能量时，将游戏分享至微信群或分享给好友，就可以获得一次重新玩游戏的机会。这一诱导传播的“复活”功能异常疯狂，尤其是 2018 年五一假期期间，复活分享在众多微信群内刷屏。很多微信用户不堪其扰。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;2018 年 5 月 9 日，微信官方发布公告，提醒小游戏拒绝“分享滥用”行为，违规情形将会受到处理。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;小游戏由于开发简单，更多依赖创意与模式取胜，一个好的小游戏被抄袭取代的概率很高。微信通过软件著作权法保护开发者的原创热情。但是只能开发小体量休闲游戏、并且是腾讯系工作室不感兴趣的休闲类型，如何才能保证获取足额的收入呢？申请软著虽然免费，但时间即成本。如果委托代理公司加急申请，也是一笔开支。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;四、个人应该开发什么类型的小程序？&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;4.1，从《围住神经猫》看，轻度社交类是首选&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic4.zhimg.com/80/v2-56d0a6bb8e8122afb5fd31a0ed63712f_hd.jpg&quot; alt=&quot;&quot; width=&quot;269&quot; height=&quot;418&quot; data-caption=&quot;&quot; data-size=&quot;small&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;1676&quot; data-original=&quot;https://pic4.zhimg.com/v2-56d0a6bb8e8122afb5fd31a0ed63712f_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-56d0a6bb8e8122afb5fd31a0ed63712f_b.jpg&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;2014 年，H5 游戏领域出现了一个现象级产品：《围住神经猫》。开发时间一天半，美术一人，程序一人。上线 48 小时，PV 达 1000 多万。3 天时间，500 万用户，1 亿总访问量。“自从得了神经病，整个人精神多了”。这是一款益智休闲小游戏，玩法非常简单，玩家单击 9 x 9 的棋盘，将猫围住中间即赢。玩家热衷在社交网络中分享自己的得分。当时业界凯歌高旋，称《围住神经猫》是中国 H5 游戏产业的转折点。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;2014 年之前，H5 开发的 Web APP 在安卓 4.4 以下版本无法流畅运行，用户体验很差。在当时的 iOS 版本手机中则不存在这种问题。究其原因，是Android 4.4 以下版本内置的 Webview 版本太低，不支持 WebGL 加速技术。从 2013 开始，Android 4.4 以下版本逐步减少，这对 H5 游戏的普及创造了有利条件。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;根据 H5 游戏的特点，哪些游戏更易获得自然传播？一，从网络流量上讲，游戏资源越丰富占用流量越多，限制了用户的使用环境；二，H5 游戏没有长驻桌面，用户留存率低，需要通过社交传播等方式弥补留存率的不足。所以资源包不大，玩法简单，单局时间短，有社交传播能力的游戏，是 H5 游戏的首先题材类型。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;《围住神经猫》就符合这个特点。对于个人开发者或小微团队来讲，如果一款游戏在 1 ~ 3 天内不能上线，这款游戏就不值得投入了。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;4.2，从 2015 年曾经火爆的产品来看，重度游戏难以持久&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;2014 年，据不完全统计，当时有数以百计的开发者纷纷启动H5游戏项目，再加上各大技术服务商、发行商和平台商，整个生态瞬间集中了百亿资本。当时有种说法是，H5 游戏将会是下一个像手游一样的风口。据报导，2015 年 H5 移动游戏市场用户规模达到 1.75 亿人，产品规模超过 3000 款。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;2015 年初，《传奇世界 H5》缔造了 H5 手游月流水 2 千万级的爆款。这款游戏使用白鹭引擎开发，无论付费率、ARPU 等多项数据都已向传统手游看齐。同年 3 月 22 日，全球首款 MMO 与 ARPG 深度结合的 H5 游戏《醉西游》开启首测，该游戏七日留存达 26.79 %。这款采用 Layabox 引擎开发，数据不仅问鼎 H5 游戏行业的数据巅峰，甚至超越绝大多数主流 APP 手游。同年 4 月 12 日，LayaBox曝出产业里程碑级的大作《梦幻家园》，这是首款裸跑性能比肩 App 的大型 H5 游戏，其次留数据为 36.84 %。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;在 2015 年，利益于浏览器中 WebGL 的硬件加速能力，Web App 性能就已经跑赢 Native App。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;不过可惜的是， H5 游戏并没有如约爆发，仍然不温不火。硬件不是问题，缺少一个合适的商业平台。大厂采用的洗量变现玩法终归难以持久。而在这艰苦探索的过程中，不少 H5 游戏厂商还没有迎来春天，就已经在一个个寒冬中夭折。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;传统赚钱的H5游戏，90%都是重度游戏。但短平快、过于轻量化的游戏很难让用户长期沉迷。以前 H5 现象级轻度游戏都会遇到这样的困境：传播链条短，用户会很快产生审美疲劳。但是，即使如此，腾讯几大 H5 游戏平台接入的游戏主要有三个特点：重社交、大IP、精品化。在玩法层面主要以轻度休闲，社交游戏，棋牌桌游为主，刻意避免了传统重度游戏。腾讯在以社交性，弥补 H5 游戏传播链条短、生命周期短、用户留存低的缺点。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;4.3，从后 H5 时代的游戏类型来看，轻度社交是关键&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;2015 年 H5 游戏爆发之后，大厂转去做 App 重度手游了，H5 游戏市场进入后 H5 时代。留下来继续在 H5 游戏市场耕耘的开发者，他们游戏作品有以下特点：&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;（1）时间短。游戏要 1 分钟甚至是 30 秒内可以玩完，神经猫，疯狂手指，数钞票都属于这类。疯狂手指甚至短到了 10 秒。&lt;/p&gt;
&lt;p&gt;（2）简单。能火的都是快餐类游戏，很多都为开发人员所不屑。传播量最大的都是不需要智商的弱智游戏。&lt;/p&gt;
&lt;p&gt;（3）有轻度竞技特征。这部分体现在分数，有的有排行榜。&lt;/p&gt;
&lt;p&gt;（4）蹭热点，拼创意。疯狂手指创意来自于一个工程师，另一工程师开发 1 个小时上线，第二天就快千万流量，创意爆款可遇不可求。房祖名，冰桶则是抓热点事件，通过疯狂手指，黑白格，找你妹等游戏变化得出。&lt;/p&gt;
&lt;p&gt;（5）大多需要种子流量拉动。没有种子流量能火，肯定是运气，神经猫是一个。疯狂手指是由种子流量带动的，大约带了10~20w的流量，这是火的前提。怎么找种子流量？可以找我们轻游戏的聚合平台合作。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;在后 H5 游戏时代，留下来一批小游戏平台公司，例如 4399、3366 等。这些平台通过小游戏向广告端的 App 导流，与开发者共享广告分成。仅靠这一种模式，平台养活了自身，也维系了众多小游戏开发端。但是在微信小游戏进入后，他们将面临没落，因为从小游戏向 App 导流，比之在 PC 上扫码导流方便多了。就流量而言，所有传统小游戏平台加起来，也没有微信的体量大。所以，对于那些仍然混 4399、3366 等小游戏平台的开发商，现在应该转攻微信小游戏了，如果还没行动的话。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;4.4，适合个人开发的只有休闲社交游戏，但并不是所有都适合&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;小游戏对游戏包限制是 4 Mb 以内，这种大小的游戏包只支持轻量游戏。在被问及什么品类的小游戏会表现更好时，微信工作人员李卿表示，玩法是基础，有一些玩法天然就是有很大的潜在用户人群的。游戏品类本身的玩法决定了游戏的用户规模。平台赋予游戏排行榜、关系链等能力，是放大游戏玩法的补充。李卿认为，有着基础玩法的三消类游戏，在获取玩家用户以及与社交属性挂钩上都有着极大优势。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;但是，传统三消类、棋牌类小游戏都在腾讯系工作室做遍了。所以这类游戏，并不建议开发者尝试。相册的游戏题材，即使有信心比腾讯团队做得更好，也要看一看微信发现 -&amp;gt; 游戏页面。在这个页面，列举的都是腾讯系自家游戏。在这个页面列出的游戏，开发者尤其是个人开发者均不需要尝试了。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;4.5，从哪里学习小游戏的创意&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;以下传统游戏平台，都可以经常上去看看，凡腾讯系工作室不感兴趣的、小众的、短期1~3天即可完成开发并上架的题材，都可以尝试。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;（1）爱微游、疯狂游乐场、9G，群黑游戏，1758 等&lt;/p&gt;
&lt;p&gt;（2）68 微，电魂，小伙伴），金榜游戏&lt;/p&gt;
&lt;p&gt;（3）4399，3366，游戏酱紫，7724，核弹头，2144&lt;/p&gt;
&lt;p&gt;（4）鲸鱼游戏，果子游戏，07073&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;五，企业应该开发什么类型的小程序？&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;张小龙说，微信不会做小程序应用商店。“我们不支持纯以分发为目标的第三方平台，不支持导流性质的小游戏（小程序）互跳。我们希望好的小游戏是因用户的认可而涌现，而不是流量运营的结果。”这是微信团队在《致小游戏开发者的一封信》中表明的态度。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;截止到 2018 年 7 月，微信上线的小游戏已经超过 2000 款，这些游戏目前依然分散在微信平台的各个角落，缺乏推广平台。那么，创业团队能不能做游戏盒子？能不能做流量分发平台，为小程序及小游戏做导流生意？答案至少暂时是可以的。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;当年在手游数量膨胀时，一批从业者率先建立了第三方应用商店，以此聚合大量应用。拇指玩、卓易市场、安智市场、机锋市场、应用汇、木蚂蚁等应用商店就是在当时应运而生的。做流量盒子，有成功先例。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;微信虽然一直宣称去中心化，但我们发现腾讯自家也推出了游戏盒子小程序：QQ 游戏盒子、腾讯爱玩盒子等。据悉，目前微信上现已出现 400 多个游戏盒子，并且还在不断增长之中。快乐游戏盒子、逗玩游戏盒子、爱微游游戏盒子、潘多拉游戏盒子、海盗游戏盒子是目前排名前五的微信小游戏游戏盒子。游戏盒子的宣传语是“无需下载、即点即玩的小游戏合集”，“合集”成为了游戏盒子的生存之道。在游戏盒子中，分享好友、收藏盒子等引导功能是普遍存在的，目的是进一步扩大盒子粘性。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;QQ 游戏盒子中分为“精选”、“发现”、“分类”三个大类，囊括了大量小游戏，数量庞大、种类齐全、排列有序，有榜单、有推荐，有热评度，有礼包中心，俨然应用商店。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;如果微信一直不做小程序/小游戏应用商店。对于创业团队，能不能做？可以做，但是不能只局限于小程序、小游戏的聚合分发，也不能只在微信生态下去做。小程序、小游戏的本质仍然是 H5，应该跳出微信的生态，囊括所有 H5 生态产品，支付宝小程序、百度小程序，快应用等，都应该囊括进来。在产品形态上，一定要有自己的 App，从小程序、小游戏中向自己的 App 引流，建立自己独立的品牌。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;如果微信坚持不做小游戏应用商店，那么像 4399、3366 那样，诞生一两个小游戏分发平台是合理的。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;六、小游戏如何盈利？&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;小游戏并没有很强的变现能力。目前大厂在坚持投入，无非是收入大于支出，待红利期过了，游戏开发商们自会转向别处。40% 的渠道费，作者认为太贵了。苹果 App Store 的分成，也仅有三成；并且苹果是允许个人开发者使用支付功能的，接口与企业开发者几无分别。但在小游戏中，个人开发者和企业开发者的权限分别，就大了去了。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;6.1，小游戏的盈利模式有哪些&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;微信小游戏的变现主要有以下4种：&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;（1）广告变现。无论是企业开发者还是个人开发者，都可以使用。&lt;/p&gt;
&lt;p&gt;（2）游戏内付费，这种模式只适合企业开发者，并且目前在 iOS 端尚不可用。&lt;/p&gt;
&lt;p&gt;（3）裂变回收，就是当用户将游戏分享出去时，带上其它产品，向自家产品导流，或打包将流量卖给第三方。&lt;/p&gt;
&lt;p&gt;（4）外包定制。&lt;/p&gt;
&lt;p&gt;（5）直接卖号。每款小游戏的生命周期大约有 6 ~ 8 个月。如果流量运营起来了，可以在第 3 个月的时候，将帐号卖给第三方。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;据悉，有公司在做从小游戏向 H5 游戏导量，已经做到了 3000 万流水。但导流对个人来讲，并不适合。广告模式和直接卖号，是适合个人开发者和小微团队的变现方式。据微信工作人员分享，广告收入会支撑住一个小团队自身的生存。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;6.2，个人开发者的希望在哪里？&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;对于个人开发者，如果能够开发出一款类似于《围住神经猫》那样的小游戏，并能创造 1000 万的 UV，那么结合微信广告平台千次展示的广告价格及平均单次单击价格和单击概念，保守估计，可以有 1 ~ 5 万的广告收入。&lt;/p&gt;
&lt;p&gt;而这样的小游戏，只可以花 1 ~ 3 天的时间开发，如果超过这个时间没有完成，说明游戏可能不适合这个平台。至于说每个开发者只能注册 5 个小游戏开发帐号的限制，有其它办法可以解决。例如使用亲友身份注册，或将成名卖给第三方。如果上架后没有火起来，甚至都可以推倒从新开发另一款。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;七、小游戏如何推广？&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;社交分享与排行榜是小游戏推广中的产品利器，但也不能滥用。在 2018 年 5 月过度使用“复活分享”的产品，都被微信勒令整顿了。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;在用户流量获取方面，在 2018 年 2 月份就已经有团队在用网盟买量。成本非常低，15 元可以覆盖 1000 个 2000 人大群，假设只有 1‰ 的转化率也有 2000 的转化。如果企业准备做游戏盒子，可以考虑做这方面的生意。但微信工作人员曾对媒体表示，未来微信有可能自己做买量市场。开发者交线，微信通过各种渠道给游戏导流，额满为止。听起来这不像微信的产品风格，如果微信真这样做，很快个人开发者就没有机会了。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;八、微信为什么不做一个小程序 / 小游戏应用中心？&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;张小龙在微信公开课上一再强调，微信坚持去中心化，微信不会做小程序或小游戏应用商店。为什么？&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;作者认为，微信是从微信整个商业生态上考虑的。微信是一个 App，它拥有朋友圈、公众号、看一看等生态领域，这些领域都是微信为第三方投放广告进行企业变现的地方。如果微信搞了一个小游戏应用商店，那么无疑这个商店就是开发者最大的流量入口，开发者就会争着在这个商店里获得推荐、获得靠前排名，谁还会去广告主平台投放广告呢？&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;做为一个平台，微信必须维持公正公平的基本原则，如果有这个商店，必然不能像百度那样通过竞价排名收费，后果只会造成第三方公司通过各种刷单手段，帮开发者争取高位排名。微信不但一分钱挣不到，还要投入更多的人力物力打击刷单行为。微信为什么要这么做？&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;有了这个商店，微信的广告收入会减少。并且一旦在商店内出现第三方非腾讯系的大流量产品，还面临着微信用户被第三方企业拉走的威胁，到时候以什么理由封杀第三方呢？&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;事实上，在微信 -&amp;gt; 发现导航页，有一个“游戏”分栏，这个页面列举的全是腾讯系游戏产品或与腾讯合作的游戏产品。微信并不是不做商店，是只做自己能完全控制的商店。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;从这点来看，微信的扁平化社交产品模式，比淘宝、京东的瀑布布分类产品模式，更胜一筹。没有情怀，所有的产品设计背后，都是血泪经验。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;微信推出小游戏，只是腾讯在多年H5游戏市场众多企业战略的一坏，相比其它腾讯系H5平台，这一次微信很多可能成功。微信推出小游戏平台，不但与腾讯的总战略契合，还有助于提高各个微信生态的用户粘性和变现能力。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;但是，当年乔布斯推出 iPhone，是重新定义了手机，众多游戏开发者在 App Store 上线游戏，是因为 iPhone 有其它地方没有的硬件能力。张小龙同样选择 1 月 9 日推出小程序，在没有额外的硬件能力加持的前提下，微信如何让开发者留在小游戏平台并保持平台活力？如果微信未来能推出一款微信VR手机，就另当别论了。否则，目前的小游戏平台和 2015 年一样，在火过一阵之后，大厂开发者会退出，留下小微团队和几个流量盒子坚守。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;个人开发者固然可以从中赚到一笔钱，但也不要抱实现财富自由的幻想。尝试做流量盒子的企业，莫要希翼自己一家独大；当微信不做这个生意时，这个生意就变成了一种类型，将被 N 多企业争相瓜分。做为流量盒子，谁也不会一家独大，和小游戏一样，竞争越激烈，从中渔利的只有微信。&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;2019年2月1日&lt;/p&gt;
&lt;p&gt;石桥码农&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt; &lt;/p&gt;
&lt;p&gt;本文首发于微信公众号「艺述思维」：&lt;a class=&quot; wrap external&quot; href=&quot;http://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s/Tqx0UcGpbT_ltbsRlfmBFA&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot; data-za-detail-view-id=&quot;1043&quot;&gt;微信为什么要搞一个小游戏？&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 01 Feb 2019 13:26:00 +0000</pubDate>
<dc:creator>石桥码农</dc:creator>
<og:description>众厂关于 H5 游戏市场的争夺，自 2014 年以来，一直就没有停止过。但一直也没有尘埃落定，最终花落谁家，鹿死谁手现在还不好讲。微信推出小程序，继而推出小游戏，只是腾讯数年来在 H5 市场企业战略的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sban/p/10347071.html</dc:identifier>
</item>
<item>
<title>【Go】优雅的读取http请求或响应的数据-续 - 戚银</title>
<link>http://www.cnblogs.com/thinkeridea/p/10347026.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/thinkeridea/p/10347026.html</guid>
<description>&lt;p&gt;原文链接：&lt;a href=&quot;https://blog.thinkeridea.com/201902/go/you_ya_de_du_qu_http_qing_qiu_huo_xiang_ying_de_shu_ju_2.html&quot; class=&quot;uri&quot;&gt;https://blog.thinkeridea.com/201902/go/you_ya_de_du_qu_http_qing_qiu_huo_xiang_ying_de_shu_ju_2.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;之前发布 &lt;a href=&quot;https://blog.thinkeridea.com/201901/go/you_ya_de_du_qu_http_qing_qiu_huo_xiang_ying_de_shu_ju.html&quot;&gt;【Go】优雅的读取http请求或响应的数据&lt;/a&gt; 文章，网友 “wxe” 咨询：“优化前后的请求耗时变化有多大”，之前只分析了内存分配，这篇文章用单元测试的方式分析优化前后的耗时情况，&lt;a href=&quot;https://github.com/thinkeridea/example/tree/master/iouitl_readall&quot;&gt;本文源码&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;非常感谢 “wxe” 网友的提问，让我在测试过程中发现一个 &lt;code&gt;json&lt;/code&gt; 序列化的问题。&lt;/p&gt;
&lt;p&gt;之前我们优化了两个部分，&lt;code&gt;json&lt;/code&gt; 与 &lt;code&gt;ioutil.ReadAll&lt;/code&gt;， 先对比 &lt;code&gt;ioutil.ReadAll&lt;/code&gt;, 这里测试的代码分成两个部分做对比，一部分单纯对比 &lt;code&gt;ioutil.ReadAll&lt;/code&gt; 和 &lt;code&gt;io.Copy&lt;/code&gt; + &lt;code&gt;sync.Pool&lt;/code&gt;，另一部分增加 &lt;code&gt;jsoniter.Unmarshal&lt;/code&gt; 来延迟 &lt;code&gt;pool.Put(buffer)&lt;/code&gt; 的执行, &lt;a href=&quot;https://github.com/thinkeridea/example/blob/master/iouitl_readall/io.go&quot;&gt;源码&lt;/a&gt;。&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;package iouitl_readall

import (
    &quot;bytes&quot;
    &quot;io&quot;
    &quot;io/ioutil&quot;
    &quot;sync&quot;

    jsoniter &quot;github.com/json-iterator/go&quot;
)

var pool = sync.Pool{
    New: func() interface{} {
        return bytes.NewBuffer(make([]byte, 4096))
    },
}

func IoCopyAndJson(r io.Reader) error {
    buffer := pool.Get().(*bytes.Buffer)
    buffer.Reset()
    defer pool.Put(buffer)

    res := Do(r)
    _, err := io.Copy(buffer, res)
    if err != nil {
        return err
    }

    m := map[string]string{}
    err = jsoniter.Unmarshal(buffer.Bytes(), &amp;amp;m)
    return err
}

func IouitlReadAllAndJson(r io.Reader) error {
    res := Do(r)
    data, err := ioutil.ReadAll(res)
    if err != nil {
        return err
    }

    m := map[string]string{}
    err = jsoniter.Unmarshal(data, &amp;amp;m)
    return err
}

func IoCopy(r io.Reader) error {
    buffer := pool.Get().(*bytes.Buffer)
    buffer.Reset()
    defer pool.Put(buffer)

    res := Do(r)
    _, err := io.Copy(buffer, res)
    if err != nil {
        return err
    }

    return err
}

func IouitlReadAll(r io.Reader) error {
    res := Do(r)
    data, err := ioutil.ReadAll(res)
    if err != nil {
        return err
    }
    _ = data
    return err
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试代码如下&lt;a href=&quot;https://github.com/thinkeridea/example/blob/master/iouitl_readall/io_test.go&quot;&gt;源码&lt;/a&gt;:&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;package iouitl_readall

import (
    &quot;bytes&quot;
    &quot;testing&quot;
)

var data = bytes.Repeat([]byte(&quot;ABCD&quot;), 1000)

func BenchmarkIouitlReadAll(b *testing.B) {
    b.RunParallel(func(pb *testing.PB) {
        for pb.Next() {
            err := IouitlReadAll(bytes.NewReader(data))
            if err != nil {
                b.Error(err.Error())
            }
        }
    })
}

func BenchmarkIoCopy(b *testing.B) {
    b.RunParallel(func(pb *testing.PB) {
        for pb.Next() {
            err := IoCopy(bytes.NewReader(data))
            if err != nil {
                b.Error(err.Error())
            }
        }
    })
}

func BenchmarkIouitlReadAllAndJson(b *testing.B) {
    b.RunParallel(func(pb *testing.PB) {
        for pb.Next() {
            err := IouitlReadAllAndJson(bytes.NewReader(data))
            if err != nil {
                b.Error(err.Error())
            }
        }
    })
}

func BenchmarkIoCopyAndJson(b *testing.B) {
    b.RunParallel(func(pb *testing.PB) {
        for pb.Next() {
            err := IoCopyAndJson(bytes.NewReader(data))
            if err != nil {
                b.Error(err.Error())
            }
        }
    })
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试结果如下:&lt;/p&gt;
&lt;pre class=&quot;txt&quot;&gt;
&lt;code&gt;goos: darwin
goarch: amd64
pkg: github.com/thinkeridea/example/iouitl_readall
BenchmarkIouitlReadAll-8              500000          2752 ns/op       14496 B/op          6 allocs/op
BenchmarkIoCopy-8                   20000000            65.2 ns/op        48 B/op          1 allocs/op
BenchmarkIouitlReadAllAndJson-8       100000         20022 ns/op       46542 B/op        616 allocs/op
BenchmarkIoCopyAndJson-8              100000         17615 ns/op       32102 B/op        611 allocs/op&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结论：&lt;/p&gt;
&lt;p&gt;可以发现 &lt;code&gt;IoCopy&lt;/code&gt; 方法是 &lt;code&gt;IouitlReadAll&lt;/code&gt; 方法效率的 40 倍，内存分配也很少，而 &lt;code&gt;IoCopyAndJson&lt;/code&gt; 和 &lt;code&gt;IouitlReadAllAndJson&lt;/code&gt; 的效率差异极小仅有 &lt;code&gt;2407ns&lt;/code&gt;，大约是 1.13倍，不过内存分配还是少了很多的，为什么会这样呢，这就是 &lt;code&gt;sync.Pool&lt;/code&gt; 的导致的，&lt;code&gt;sync.Pool&lt;/code&gt; 每次获取使用时间越短，命中率就越高，就可以减少创建新的缓存，这样效率就会大大提高，而 &lt;code&gt;jsoniter.Unmarshal&lt;/code&gt; 很耗时，就导致 &lt;code&gt;sync.Pool&lt;/code&gt; 的命中率降低了，所以性能下降极其明显.&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;io.Copy&lt;/code&gt; + &lt;code&gt;sync.Pool&lt;/code&gt; 表面上执行效率不会有很大提升，但是会大幅度减少内存分配，从而可以减少 &lt;code&gt;GC&lt;/code&gt; 的负担，在单元测试中我们并没有考虑 &lt;code&gt;GC&lt;/code&gt; 的问题，而 &lt;code&gt;GC&lt;/code&gt; 能带来的性能提升会更有优势。&lt;/p&gt;
&lt;p&gt;在看一下 &lt;code&gt;json&lt;/code&gt; 使用 &lt;code&gt;sync.Pool&lt;/code&gt; 的效果吧 &lt;a href=&quot;https://github.com/thinkeridea/example/blob/master/iouitl_readall/json.go&quot;&gt;源码&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;package iouitl_readall

import (
    &quot;bytes&quot;
    &quot;encoding/json&quot;

    jsoniter &quot;github.com/json-iterator/go&quot;
)

func Json(r map[string]string) error {
    data, err := json.Marshal(r)
    if err != nil {
        return err
    }

    _ = data
    return nil
}

func JsonPool(r map[string]string) error {
    buffer := pool.Get().(*bytes.Buffer)
    buffer.Reset()
    defer pool.Put(buffer)

    e := json.NewEncoder(buffer)
    err := e.Encode(r)
    if err != nil {
        return err
    }

    return nil
}

func JsonIter(r map[string]string) error {
    data, err := jsoniter.Marshal(r)
    if err != nil {
        return err
    }

    _ = data
    return nil
}

func JsonIterPool(r map[string]string) error {
    buffer := pool.Get().(*bytes.Buffer)
    buffer.Reset()
    defer pool.Put(buffer)

    e := jsoniter.NewEncoder(buffer)
    err := e.Encode(r)
    if err != nil {
        return err
    }

    return nil
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;性能测试代码&lt;a href=&quot;https://github.com/thinkeridea/example/blob/master/iouitl_readall/json_test.go&quot;&gt;源码&lt;/a&gt;:&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;package iouitl_readall

import (
    &quot;strconv&quot;
    &quot;strings&quot;
    &quot;testing&quot;
)

var request map[string]string

func init() {
    request = make(map[string]string, 100)
    for i := 0; i &amp;lt; 100; i++ {
        request[&quot;X&quot;+strconv.Itoa(i)] = strings.Repeat(&quot;A&quot;, i/2)
    }
}
func BenchmarkJson(b *testing.B) {
    b.RunParallel(func(pb *testing.PB) {
        for pb.Next() {
            err := Json(request)
            if err != nil {
                b.Error(err.Error())
            }
        }
    })
}

func BenchmarkJsonIter(b *testing.B) {
    b.RunParallel(func(pb *testing.PB) {
        for pb.Next() {
            err := JsonIter(request)
            if err != nil {
                b.Error(err.Error())
            }
        }
    })
}

func BenchmarkJsonPool(b *testing.B) {
    b.RunParallel(func(pb *testing.PB) {
        for pb.Next() {
            err := JsonPool(request)
            if err != nil {
                b.Error(err.Error())
            }
        }
    })
}

func BenchmarkJsonIterPool(b *testing.B) {
    b.RunParallel(func(pb *testing.PB) {
        for pb.Next() {
            err := JsonIterPool(request)
            if err != nil {
                b.Error(err.Error())
            }
        }
    })
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试结果如下:&lt;/p&gt;
&lt;pre class=&quot;txt&quot;&gt;
&lt;code&gt;goos: darwin
goarch: amd64
pkg: github.com/thinkeridea/example/iouitl_readall
BenchmarkJson-8                       100000         13297 ns/op       13669 B/op        207 allocs/op
BenchmarkJsonPool-8                   100000         13310 ns/op       10218 B/op        206 allocs/op
BenchmarkJsonIter-8                   500000          2948 ns/op        3594 B/op          4 allocs/op
BenchmarkJsonIterPool-8               200000          6126 ns/op        6040 B/op        144 allocs/op
PASS
ok      github.com/thinkeridea/example/iouitl_readall   12.716s&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里使用了两个 &lt;code&gt;json&lt;/code&gt; 包， 一个是标准库的，一个是 &lt;code&gt;jsoniter&lt;/code&gt; (也是社区反馈效率最高的)，对比两个包使用 &lt;code&gt;sync.Pool&lt;/code&gt; 和不使用之间的差异，发现标准库 &lt;code&gt;json&lt;/code&gt; 包使用后内存有少量减少，但是运行效率稍微下降了，差异不是很大，&lt;code&gt;jsoniter&lt;/code&gt; 包差异之所谓非常明显，发现使用 &lt;code&gt;sync.Pool&lt;/code&gt; 之后不仅内存分配更多了，执行效率也大幅度下降，差了将近3倍有余。&lt;/p&gt;
&lt;p&gt;是不是很奔溃，这是啥情况 &lt;code&gt;jsoniter&lt;/code&gt; 本身就使用了 &lt;code&gt;sync.Pool&lt;/code&gt; 作缓冲，我们使用 &lt;code&gt;jsoniter.NewEncoder(buffer)&lt;/code&gt; 创建一个序列化实例，但是其内部并没有直接使用 &lt;code&gt;io.Writer&lt;/code&gt; 而是先使用缓冲序列化数据，之后写入 &lt;code&gt;io.Writer&lt;/code&gt;, 具体代码如下：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;// Flush writes any buffered data to the underlying io.Writer.
func (stream *Stream) Flush() error {
    if stream.out == nil {
        return nil
    }
    if stream.Error != nil {
        return stream.Error
    }
    n, err := stream.out.Write(stream.buf)
    if err != nil {
        if stream.Error == nil {
            stream.Error = err
        }
        return err
    }
    stream.buf = stream.buf[n:]
    return nil
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样一来我们使用 &lt;code&gt;buffer&lt;/code&gt; 做 &lt;code&gt;json&lt;/code&gt; 序列化优化效果就大打折扣，甚至适得其反了。&lt;/p&gt;
&lt;p&gt;再次感谢 “wxe” 网友的提问，这里没有使用实际的应用场景做性能测试，主要发现在性能测试中使用 &lt;code&gt;http&lt;/code&gt; 服务会导致 &lt;code&gt;connect: can't assign requested address&lt;/code&gt; 问题，所以测试用使用了函数模拟，如果有朋友有更好的测试方法欢迎一起交流。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;转载：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文作者： 戚银（&lt;a href=&quot;https://blog.thinkeridea.com/&quot;&gt;thinkeridea&lt;/a&gt;）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文链接： &lt;a href=&quot;https://blog.thinkeridea.com/201902/go/you_ya_de_du_qu_http_qing_qiu_huo_xiang_ying_de_shu_ju_2.html&quot; class=&quot;uri&quot;&gt;https://blog.thinkeridea.com/201902/go/you_ya_de_du_qu_http_qing_qiu_huo_xiang_ying_de_shu_ju_2.html&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;版权声明： 本博客所有文章除特别声明外，均采用 &lt;a href=&quot;http://creativecommons.org/licenses/by/4.0/deed.zh&quot;&gt;CC BY 4.0 CN协议&lt;/a&gt; 许可协议。转载请注明出处！&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 01 Feb 2019 13:09:00 +0000</pubDate>
<dc:creator>戚银</dc:creator>
<og:description>原文链接：https://blog.thinkeridea.com/201902/go/you_ya_de_du_qu_http_qing_qiu_huo_xiang_ying_de_shu_ju_2</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/thinkeridea/p/10347026.html</dc:identifier>
</item>
<item>
<title>JAVA I/O（六）多路复用IO - 水木竹水</title>
<link>http://www.cnblogs.com/shuimuzhushui/p/10323011.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shuimuzhushui/p/10323011.html</guid>
<description>&lt;p&gt;在前边介绍Socket和ServerSocket连接交互的过程中，读写都是阻塞的。套接字写数据时，数据先写入操作系统的缓存中，形成TCP或UDP的负载，作为套接字传输到目标端，当缓存大小不足时，线程会阻塞。套接字读数据时，如果操作系统缓存没有接收到信息，则读线程阻塞。线程阻塞情况下，就不能处理其他事情。JDK1.4引入了通道和选择器的概念，以支持异步或多路复用的IO。&lt;/p&gt;
&lt;p&gt;Unix系统中的select()方法可以实现异步IO，可以给该Selector注册多个描述符（可读或可写），然后对这些描述符进行监控。在Java中，描述符即为套接字Socket。&lt;/p&gt;
&lt;p&gt;如&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/shuimuzhushui/p/10269216.html&quot;&gt;JAVA I/O（二）文件NIO&lt;/a&gt;中对选择器的介绍，在非阻塞模式下，用select()方法检测发生变化的通道，每个通道都关联一个Socket，用一个线程实现多个客户端的请求，从而实现多路复用。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1012728/201902/1012728-20190201170500349-845921177.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;h2&gt;1. 简单实例&lt;/h2&gt;
&lt;h3&gt;&lt;strong&gt;服务器端&lt;/strong&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.IOException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.net.InetSocketAddress;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.nio.ByteBuffer;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.nio.CharBuffer;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.nio.channels.SelectionKey;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.nio.channels.Selector;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.nio.channels.ServerSocketChannel;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.nio.channels.SocketChannel;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.nio.charset.Charset;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Iterator;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MultiJabberServer1 {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; PORT = 8080&lt;span&gt;;
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException{
        
        String encoding &lt;/span&gt;= System.getProperty(&quot;file.encoding&quot;&lt;span&gt;);
        Charset cs &lt;/span&gt;=&lt;span&gt; Charset.forName(encoding);
        ByteBuffer buffer &lt;/span&gt;= ByteBuffer.allocate(16&lt;span&gt;);
        SocketChannel ch &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Socket对应的channel
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1.创建ServerSocketChannel&lt;/span&gt;
        ServerSocketChannel ssc =&lt;span&gt; ServerSocketChannel.open();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2.创建选择器Selector&lt;/span&gt;
        Selector sel =&lt;span&gt; Selector.open();
        
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3.设置ServerSocketChannel通道为非阻塞&lt;/span&gt;
            ssc.configureBlocking(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;4.ServerSocketChannel关联Socket，用于监听连接，使用本地ip和port
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;注意：Socket也对通道进行了改造，直接调Socket.getChannel()将返回bull，除非通过下边与通道关联
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;the expression (ssc.socket().getChannel() != null) is true&lt;/span&gt;
            ssc.socket().bind(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; InetSocketAddress(PORT));
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;5.将通道注册到Selector，感兴趣的事件为  连接  事件&lt;/span&gt;
&lt;span&gt;            ssc.register(sel, SelectionKey.OP_ACCEPT);
            System.out.println(&lt;/span&gt;&quot;Server on port: &quot; +&lt;span&gt; PORT);
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;6.没有事件发生时，一直阻塞等待&lt;/span&gt;
&lt;span&gt;                sel.select();
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;7.有事件发生时，获取Selector中所有SelectorKey（持有选择器与通道的关联关系）。
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;由于基于操作系统的poll()方法，当有事件发生时，只返回事件个数，无法确定具体通道，故只能对所有注册的通道进行遍历。&lt;/span&gt;
                Iterator&amp;lt;SelectionKey&amp;gt; it =&lt;span&gt; sel.selectedKeys().iterator();
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;8.遍历所有SelectorKey，处理事件&lt;/span&gt;
                &lt;span&gt;while&lt;/span&gt;&lt;span&gt;(it.hasNext()) {
                    SelectionKey sKey &lt;/span&gt;=&lt;span&gt; it.next();
                    it.remove();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;防止重复处理
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;9.判断SelectorKey对应的channel发生的事件是否socket连接&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(sKey.isAcceptable()) {
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;10.与ServerSocket.accept()方法相似，接收到该通道套接字的连接，返回SocketChannel，与客户端进行交互&lt;/span&gt;
                        ch =&lt;span&gt; ssc.accept();
                        System.out.println(
                                &lt;/span&gt;&quot;Accepted connection from:&quot; +&lt;span&gt; ch.socket());
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;11.设置该SocketChannel为非阻塞模式&lt;/span&gt;
                        ch.configureBlocking(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;12.将该通道注册到Selector中，感兴趣的事件为OP_READ（读）&lt;/span&gt;
&lt;span&gt;                        ch.register(sel, SelectionKey.OP_READ);
                    }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;13.发生非连接事件，此处为OP_READ事件。SelectorKey获取注册的SocketChannel，用于读写&lt;/span&gt;
                        ch =&lt;span&gt; (SocketChannel)sKey.channel();
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;14.将数据从channel读到ByteBuffer中&lt;/span&gt;
&lt;span&gt;                        ch.read(buffer);
                        CharBuffer cb &lt;/span&gt;=&lt;span&gt; cs.decode((ByteBuffer)buffer.flip());
                        String response &lt;/span&gt;=&lt;span&gt; cb.toString();
                        System.out.print(&lt;/span&gt;&quot;Echoing : &quot; +&lt;span&gt; response);
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;15.再将获取到的数据会写给客户端&lt;/span&gt;
&lt;span&gt;                        ch.write((ByteBuffer)buffer.rewind());
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(response.indexOf(&quot;END&quot;) != -1&lt;span&gt;)
                            ch.close();
                        buffer.clear();
                    }
                }
            }
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(ch != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                ch.close();
            ssc.close();
            sel.close();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 如代码中注释标明，大致步骤包含：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;创建ServerSocketChannel和Selector，设置通道非阻塞，并与服务端的Socket绑定&lt;/li&gt;
&lt;li&gt;注册 ServerSocketChannel到Selector，感兴趣的事件为OP_CONNECT（获取连接）&lt;/li&gt;
&lt;li&gt;select()方法阻塞等待，直到有事件发生&lt;/li&gt;
&lt;li&gt;遍历Selector中的所有注册事件，通过SelectorKey维护Selector和Channel关联关系&lt;/li&gt;
&lt;li&gt;如果是连接事件，则调ServerSocketChannel.accept()方法获取SocketChannel，与客户端交互&lt;/li&gt;
&lt;li&gt;如果是读事件，则通过SelectorKey中获取SocketChannel，读写数据&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;运行结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
Server on port: 8080
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;strong&gt;客户端&lt;/strong&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.IOException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.net.InetAddress;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.net.InetSocketAddress;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.nio.ByteBuffer;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.nio.channels.SelectionKey;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.nio.channels.Selector;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.nio.channels.SocketChannel;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.nio.charset.Charset;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Iterator;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.test.socketio.JabberServer;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 采用这种方式，读与写是非阻塞的
 * 普通的读写是阻塞的，直到读完或写完&lt;/span&gt;&lt;span&gt;
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; JabberClient1 {
    
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; clPot = 8899&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException{
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1.创建SocketChannel&lt;/span&gt;
        SocketChannel sc =&lt;span&gt; SocketChannel.open();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2.创建Selector&lt;/span&gt;
        Selector sel =&lt;span&gt; Selector.open();
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            sc.configureBlocking(&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3.关联SocketChannel和Socket，socket绑定到本机端口&lt;/span&gt;
            sc.socket().bind(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; InetSocketAddress(clPot));
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;4.注册到Selector，感兴趣的事件为OP_CONNECT、OP_READ、OP_WRITE&lt;/span&gt;
            sc.register(sel, SelectionKey.OP_CONNECT | SelectionKey.OP_READ |&lt;span&gt; SelectionKey.OP_WRITE);
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i = 0&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; written = &lt;span&gt;false&lt;/span&gt;, done = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            String encoding &lt;/span&gt;= System.getProperty(&quot;file.encoding&quot;&lt;span&gt;);
            Charset cs &lt;/span&gt;=&lt;span&gt; Charset.forName(encoding);
            ByteBuffer buffer &lt;/span&gt;= ByteBuffer.allocate(16&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(!&lt;span&gt;done) {
                sel.select();
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;5.从选择器中获取所有注册的通道信息（SelectionKey作为标识）&lt;/span&gt;
                Iterator&amp;lt;SelectionKey&amp;gt; it =&lt;span&gt; sel.selectedKeys().iterator();
                &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt;(it.hasNext()) {
                    SelectionKey key &lt;/span&gt;=&lt;span&gt; it.next();
                    it.remove();
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;6.获取通道，此处即为上边创建的channel&lt;/span&gt;
                    sc =&lt;span&gt; (SocketChannel)key.channel();    
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;7.判断SelectorKey对应的channel发生的事件是否socket连接，并且还没有连接&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt;(key.isConnectable() &amp;amp;&amp;amp; !&lt;span&gt;sc.isConnected()) {
                        InetAddress addr &lt;/span&gt;= InetAddress.getByName(&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;连接addr和port对应的服务器&lt;/span&gt;
                        &lt;span&gt;boolean&lt;/span&gt; success = sc.connect(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; InetSocketAddress(addr, JabberServer.PORT));
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;success)
                            sc.finishConnect();
                    }
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;8.读与写是非阻塞的：客户端写一个信息到服务器，服务器发送一个信息到客户端，客户端再读&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt;(key.isReadable() &amp;amp;&amp;amp;&lt;span&gt; written) {
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(sc.read((ByteBuffer)buffer.clear()) &amp;gt; 0&lt;span&gt;) {
                            written &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                            String response &lt;/span&gt;=&lt;span&gt; cs.decode((ByteBuffer)buffer.flip()).toString();
                            System.out.println(response);
                            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(response.indexOf(&quot;END&quot;) != -1&lt;span&gt;)
                                done &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                        }
                    }
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(key.isWritable() &amp;amp;&amp;amp; !&lt;span&gt;written) {
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(i &amp;lt; 10&lt;span&gt;)
                            sc.write(ByteBuffer.wrap(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; String(&quot;howdy &quot; + i + &quot;\n&quot;&lt;span&gt;).getBytes()));
                        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(i == 10&lt;span&gt;){
                            sc.write(ByteBuffer.wrap(&lt;/span&gt;&quot;END&quot;&lt;span&gt;.getBytes()));
                        }
                        written &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                        i&lt;/span&gt;++&lt;span&gt;;
                    }
                }
            }
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            sc.close();
            sel.close();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;客户端与服务端类似，不同之处：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;创建SocketChannel通道，注册到选择器，刚兴趣的事件为OP_CONNECT、OP_READ、OP_WRITE&lt;/li&gt;
&lt;li&gt;调试发现，客户端sel.select()不会阻塞，对注册通道不断的遍历，并且每次都可写。&lt;strong&gt;原因是OP_WRITE事件会持续生效，即只要连接存在就可以写，不管服务端是否有返回&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;本例中，客户端发送一条数据，服务端接收一条，并返回给客户端；客户端接到服务端的消息后，才会发生下一条数据，主要通过written标识进行控制的。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;运行机制&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1012728/201902/1012728-20190201200931876-1886426926.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;运行结果&lt;/h3&gt;
&lt;p&gt;服务端&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
Server on port: 8080&lt;span&gt;
Accepted connection from:Socket[addr&lt;/span&gt;=/127.0.0.1,port=8899,localport=8080&lt;span&gt;]
Echoing : howdy &lt;/span&gt;0&lt;span&gt;
Echoing : howdy &lt;/span&gt;1&lt;span&gt;
Echoing : howdy &lt;/span&gt;2&lt;span&gt;
Echoing : howdy &lt;/span&gt;3&lt;span&gt;
Echoing : howdy &lt;/span&gt;4&lt;span&gt;
Echoing : howdy &lt;/span&gt;5&lt;span&gt;
Echoing : howdy &lt;/span&gt;6&lt;span&gt;
Echoing : howdy &lt;/span&gt;7&lt;span&gt;
Echoing : howdy &lt;/span&gt;8&lt;span&gt;
Echoing : howdy &lt;/span&gt;9&lt;span&gt;
Echoing : END&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;客户端&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
howdy 0&lt;span&gt;
howdy &lt;/span&gt;1&lt;span&gt;
howdy &lt;/span&gt;2&lt;span&gt;
howdy &lt;/span&gt;3&lt;span&gt;
howdy &lt;/span&gt;4&lt;span&gt;
howdy &lt;/span&gt;5&lt;span&gt;
howdy &lt;/span&gt;6&lt;span&gt;
howdy &lt;/span&gt;7&lt;span&gt;
howdy &lt;/span&gt;8&lt;span&gt;
howdy &lt;/span&gt;9&lt;span&gt;
END&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;2.核心类分析&lt;/h2&gt;
&lt;h3&gt;（1）通道（SelectableChannel）&lt;/h3&gt;
&lt;p&gt; 通道Channel继承体系如下，其中ServerSocketChannel和SocketChannel都继承自SelectableChannel。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1012728/201902/1012728-20190201192109054-1286209010.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;SelectableChannel通道可以通过Selector实现多路复用（multiplexed）。&lt;/li&gt;
&lt;li&gt;通道通过register(Selector,int,Object)方法注册到Selector中，并返回SelectorKey（代表注册到Selector上的注册信息）。&lt;/li&gt;
&lt;li&gt;在一个Selector中，同一个通道只能注册一份；是否可以注册到多个Selector中，由程序调用isRegistered()方法决定。&lt;/li&gt;
&lt;li&gt;SelectableChannel通道是线程安全的。&lt;/li&gt;
&lt;li&gt;SelectableChannel包含阻塞和非阻塞两种模式，只有非阻塞时才可以注册到Selector中。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;ServerSocketChannel&lt;/strong&gt;（A selectable channel for stream-oriented &lt;strong&gt;listening&lt;/strong&gt; sockets.），用于&lt;strong&gt;监听&lt;/strong&gt;Socket的基于流的可选通道。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SocketChannel&lt;/strong&gt;（A selectable channel for stream-oriented &lt;strong&gt;connecting&lt;/strong&gt; sockets.），用于&lt;strong&gt;连接&lt;/strong&gt;Socket的基于流额可选通道。&lt;/p&gt;
&lt;h3&gt;（2）选择器（Selector）&lt;/h3&gt;
&lt;p&gt;Selector是SelectableChannel的多路复选器，该类包含以下方法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1012728/201902/1012728-20190201195834278-1537359619.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;通过open()方法创建Selector&lt;/li&gt;
&lt;li&gt;包含三种SelectorKey Set：所有注册的SelectorKey、被选的SelectorKey（通道发生事件）、被取消的SelectorKey（不可直接访问）&lt;/li&gt;
&lt;li&gt;每次select()操作，都会从被选的SelectorKey集合中删除或新增，清楚被取消的SelectorKey中的SelectorKey&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;&lt;strong&gt;（3）选择建（SelectorKey）&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　选择键封装了特定的&lt;strong&gt;通道&lt;/strong&gt;与&lt;strong&gt;特定的选择器&lt;/strong&gt;的注册关系。选择键对象被SelectableChannel.register()返回并提供一个表示这种注册关系的标记。选择键包含了两个比特集(以整数的形式进行编码)，指示了该注册关系所关心的通道操作，以及通道已经准备好的操作。包括读、写、连接和接收操作，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; OP_READ = 1 &amp;lt;&amp;lt; 0&lt;span&gt;;
&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; OP_WRITE = 1 &amp;lt;&amp;lt; 2&lt;span&gt;;
&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; OP_CONNECT = 1 &amp;lt;&amp;lt; 3&lt;span&gt;;
&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; OP_ACCEPT = 1 &amp;lt;&amp;lt; 4;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;3.Reactor设计模式&lt;/h2&gt;
&lt;p&gt;基于Selector的多路复用IO，机制是采用Reactor设计模式，将一个或多个客户的服务请求分离（demultiplex）和事件分发器 （dispatch）给应用程序（&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/duanxz/p/3698530.html&quot;&gt;I/O模型之三：两种高性能 I/O 设计模式 Reactor 和 Proactor&lt;/a&gt;），即通过Selector阻塞等待事件发生，然后再分发给相应的处理器接口。详情可以参考该篇文章或更多的资料。&lt;/p&gt;
&lt;p&gt;摘自链接文章中的一幅图如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Reactor是调度中心，包含select()阻塞，等待事件发生，并分发不同的业务处理。&lt;/li&gt;
&lt;li&gt;客户端请求连接时，select()接收到事件后，会调acceptor，创建连接并与客户端交互。&lt;/li&gt;
&lt;li&gt;客户端写数据给服务端时，select()接收到事件后，调read操作，读取客户端数据，可以采用线程池对与客户端交互，对数据进行处理。&lt;/li&gt;
&lt;li&gt;服务端可也以发生数据给客户端。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1012728/201902/1012728-20190201172832793-283721133.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;4.总结&lt;/h2&gt;
&lt;p&gt;　　1. SelectableChannel（ServerSocketChannel和SocketChannel）可以注册到Selector中，并用选择键（SelectorKey）进行分装&lt;/p&gt;
&lt;p&gt;　　2. SelectorKey中包含选择器感兴趣的事件（读、写、连接和接收）&lt;/p&gt;
&lt;p&gt;　　3. Selector中select()方法阻塞，直到注册通道有事件发生，可以一个线程监控多个客户端，实现多路复用&lt;/p&gt;
&lt;p&gt;　　4. 基于Selector的多路复用采用Reactor设计模式，使得选择器与业务处理进行分离。&lt;/p&gt;
&lt;p&gt;　　5. Netty是异步基于事件的应用框架，其实现是基于Java NIO的，并对其进行了优化，可以进一步学习。&lt;/p&gt;
&lt;h2&gt;5. 参考&lt;/h2&gt;
&lt;p&gt;《Thinking in Enterprise Java》&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/duanxz/p/6782783.html&quot;&gt;Java NIO系列教程（六） 多路复用器Selector&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 01 Feb 2019 12:24:00 +0000</pubDate>
<dc:creator>水木竹水</dc:creator>
<og:description>在前边介绍Socket和ServerSocket连接交互的过程中，读写都是阻塞的。套接字写数据时，数据先写入操作系统的缓存中，形成TCP或UDP的负载，作为套接字传输到目标端，当缓存大小不足时，线程会</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shuimuzhushui/p/10323011.html</dc:identifier>
</item>
<item>
<title>VS2015编译GEOS的debug和release版本 - charlee44</title>
<link>http://www.cnblogs.com/charlee44/p/10346863.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/charlee44/p/10346863.html</guid>
<description>&lt;p&gt;目前GEOS最新的3.7.1版本支持camke进行编译。经过尝试发现通过cmake生成的工程在vs2015下面编译的时候还是存在问题，而且在中文网上也没找到解决方案。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1000410/201902/1000410-20190201194720805-241262921.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以还是采用了nmake进行编译。解压出geos-3.7.1文件夹，双击运行其中的autogen.bat。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1000410/201902/1000410-20190201194831089-67668947.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在目录中找到nmake.opt，这个文件控制着nmake编译的一些参数。记事本打开，找到如下片段：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;######################################################################
# Set WIN64=YES if you are building for 64-bit windows (x64).
# Alternatively, pass WIN64=YES as NMAKE command line argument.
######################################################################
!IFNDEF WIN64
WIN64 = NO
!ENDIF&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过注释知道这里控制编译出的是64位版本还是32位版本，我这里用的64版本，所以改为WIN64=YES。&lt;br/&gt;同样，再次找到如下片段：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# Set BUILD_DEBUG to YES if you want to make debug build
# and to prepare not optimized binaries.

!IFNDEF BUILD_DEBUG
BUILD_DEBUG = NO
!ENDIF&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同样通过注释知道这里控制编译出的是Release版本还是debug版本，我这里用的debug版本，所以改成BUILD_DEBUG=YES。&lt;br/&gt;修改好配置之后，找到VS2015的本机工具命令提示符，CD到geos-3.7.1文件夹，输入命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;nmake /f makefile.vc&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1000410/201902/1000410-20190201194902037-657059776.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后等待编译完成就可以了，最终的输出结果在geos-3.7.1文件夹的src文件夹里面。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1000410/201902/1000410-20190201194924420-1962278306.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果需要Release版本，那么可以修改对应的配置用同样的方式编译一边就可以了，它们是以_d后缀来区分的。&lt;/p&gt;
</description>
<pubDate>Fri, 01 Feb 2019 11:54:00 +0000</pubDate>
<dc:creator>charlee44</dc:creator>
<og:description>简要的介绍了再VS2015环境下编译GEOS的过程。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/charlee44/p/10346863.html</dc:identifier>
</item>
<item>
<title>强化学习(十六) 深度确定性策略梯度(DDPG) - 刘建平Pinard</title>
<link>http://www.cnblogs.com/pinard/p/10345762.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pinard/p/10345762.html</guid>
<description>&lt;p&gt;　　　　在&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/pinard/p/10334127.html&quot;&gt;强化学习(十五) A3C&lt;/a&gt;中，我们讨论了使用多线程的方法来解决Actor-Critic难收敛的问题，今天我们不使用多线程，而是使用和DDQN类似的方法：即经验回放和双网络的方法来改进Actor-Critic难收敛的问题，这个算法就是是深度确定性策略梯度(Deep Deterministic Policy Gradient，以下简称DDPG)。&lt;/p&gt;
&lt;p&gt;　　　　本篇主要参考了DDPG的&lt;a href=&quot;https://arxiv.org/pdf/1509.02971.pdf&quot; target=&quot;_blank&quot;&gt;论文&lt;/a&gt;和ICML 2016的&lt;a href=&quot;https://icml.cc/2016/tutorials/deep_rl_tutorial.pdf&quot; target=&quot;_blank&quot;&gt;deep RL tutorial&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;　　　　从DDPG这个名字看，它是由D（Deep）+D（Deterministic ）+ PG(Policy Gradient)组成。PG(Policy Gradient)我们在&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl02_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/pinard/p/10137696.html&quot;&gt;强化学习(十三) 策略梯度(Policy Gradient)&lt;/a&gt;里已经讨论过。那什么是确定性策略梯度(Deterministic Policy Gradient，以下简称DPG)呢？&lt;/p&gt;
&lt;p&gt;　　　　确定性策略是和随机策略相对而言的，对于某一些动作集合来说，它可能是连续值，或者非常高维的离散值，这样动作的空间维度极大。如果我们使用随机策略，即像DQN一样研究它所有的可能动作的概率，并计算各个可能的动作的价值的话，那需要的样本量是非常大才可行的。于是有人就想出使用确定性策略来简化这个问题。&lt;/p&gt;
&lt;p&gt;　　　　作为随机策略，在相同的策略，在同一个状态处，采用的动作是基于一个概率分布的，即是不确定的。而确定性策略则决定简单点，虽然在同一个状态处，采用的动作概率不同，但是最大概率只有一个，如果我们只取最大概率的动作，去掉这个概率分布，那么就简单多了。即作为确定性策略，相同的策略，在同一个状态处，动作是唯一确定的，即策略变成$$\pi_{\theta}(s) = a$$&lt;/p&gt;

&lt;p&gt;　　　　在看确定性策略梯度DPG前，我们看看基于Q值的随机性策略梯度的梯度计算公式：$$\nabla_{\theta}J(\pi_{\theta}) = E_{s\sim\rho^{\pi}, a\sim\pi_{\theta}}[\nabla_{\theta}log \pi_{\theta}(s,a)Q_{\pi}(s,a)]$$&lt;/p&gt;
&lt;p&gt;　　　　其中状态的采样空间为$\rho^{\pi}$, $\nabla_{\theta}log \pi_{\theta}(s,a)$是分值函数，可见随机性策略梯度需要在整个动作的空间$\pi_{\theta}$进行采样。'&lt;/p&gt;
&lt;p&gt;　　　　而DPG基于Q值的确定性策略梯度的梯度计算公式是：$$\nabla_{\theta}J(\pi_{\theta}) = E_{s\sim\rho^{\pi}}[\nabla_{\theta} \pi_{\theta}(s)\nabla_{a}Q_{\pi}(s,a)|_{a=\pi_{\theta}(s)}]$$&lt;/p&gt;
&lt;p&gt;　　　　跟随机策略梯度的式子相比，少了对动作的积分，多了回报Q函数对动作的导数。&lt;/p&gt;
&lt;p&gt;　　　　而从DPG到DDPG的过程，完全可以类比DQN到DDQN的过程。除了老生常谈的经验回放以外，我们有了双网络，即当前网络和目标网络的概念。而由于现在我们本来就有Actor网络和Critic两个网络，那么双网络后就变成了4个网络，分别是：Actor当前网络，Actor目标网络，Critic当前网络，Critic目标网络。2个Actor网络的结构相同，2个Critic网络的结构相同。那么这4个网络的功能各自是什么呢？&lt;/p&gt;

&lt;p&gt;　　　　DDPG有4个网络，在了解这4个网络的功能之前，我们先复习DDQN的两个网络：当前Q网络和目标Q网络的作用。可以复习&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl05_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/pinard/p/9778063.html&quot;&gt;强化学习（十）Double DQN (DDQN)&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;　　　　DDQN的当前Q网络负责对当前状态$S$使用$\epsilon-$贪婪法选择动作$A$，执行动作$A$,获得新状态$S'$和奖励$R$,将样本放入经验回放池，对经验回放池中采样的下一状态$S’$使用贪婪法选择动作$A'$，供目标Q网络计算目标Q值，当目标Q网络计算出目标Q值后，当前Q网络会进行网络参数的更新，并定期把最新网络参数复制到目标Q网络。&lt;/p&gt;
&lt;p&gt;　　　　DDQN的目标Q网络则负责基于经验回放池计算目标Q值,提供给当前Q网络用，目标Q网络会定期从当前Q网络复制最新网络参数。&lt;/p&gt;

&lt;p&gt;　　　　现在我们回到DDPG，作为DDPG，Critic当前网络，Critic目标网络和DDQN的当前Q网络，目标Q网络的功能定位基本类似，但是我们有自己的Actor策略网络，因此不需要$\epsilon-$贪婪法这样的选择方法，这部分DDQN的功能到了DDPG可以在Actor当前网络完成。而对经验回放池中采样的下一状态$S'$使用贪婪法选择动作$A'$，这部分工作由于用来估计目标Q值，因此可以放到Actor目标网络完成。&lt;/p&gt;
&lt;p&gt;　　　　基于经验回放池和目标Actor网络提供的$S',A'$计算目标Q值的一部分，这部分由于是评估，因此还是放到Critic目标网络完成。而Critic目标网络计算出目标Q值一部分后，Critic当前网络会计算目标Q值，并进行网络参数的更新，并定期将网络参数复制到Critic目标网络。&lt;/p&gt;
&lt;p&gt;　　　　此外，Actor当前网络也会基于Critic目标网络计算出的目标Q值，进行网络参数的更新，并定期将网络参数复制到Actor目标网络。&lt;/p&gt;

&lt;p&gt;　　　　有了上面的思路，我们总结下DDPG 4个网络的功能定位：&lt;/p&gt;
&lt;p&gt;　　　　1. Actor当前网络：负责策略网络参数$\theta$的迭代更新，负责根据当前状态$S$选择当前动作$A$，用于和环境交互生成$S',R$。&lt;/p&gt;
&lt;p&gt;　　　　2. Actor目标网络：负责根据经验回放池中采样的下一状态$S'$选择最优下一动作$A'$。网络参数$\theta '$定期从$\theta$复制。&lt;/p&gt;
&lt;p&gt;　　　　3. Critic当前网络：负责价值网络参数$w$的迭代更新，负责计算负责计算当前Q值$Q(S,A,w)$。目标Q值$y_i = R+\gamma Q'(S',A',w')$&lt;/p&gt;
&lt;p&gt;　　　　4. Critic目标网络：负责计算目标Q值中的$Q'(S',A',w')$部分。网络参数$w'$定期从$w$复制。&lt;/p&gt;
&lt;p&gt;　　　　DDPG除了这4个网络结构，还用到了经验回放，这部分用于计算目标Q值，和DQN没有什么区别，这里就不展开了。&lt;/p&gt;
&lt;p&gt;　　　　此外，DDPG从当前网络到目标网络的复制和我们之前讲到了DQN不一样。回想DQN，我们是直接把将当前Q网络的参数复制到目标Q网络，即$w'=w$, DDPG这里没有使用这种硬更新，而是使用了软更新，即每次参数只更新一点点，即：$$w' \gets \tau w+ (1-\tau)w'$$$$\theta' \gets \tau \theta+ (1-\tau)\theta'$$&lt;/p&gt;
&lt;p&gt;　　　　其中$\tau$是更新系数，一般取的比较小，比如0.1或者0.01这样的值。&lt;/p&gt;
&lt;p&gt;　　　　同时，为了学习过程可以增加一些随机性，增加学习的覆盖，DDPG对选择出来的动作$A$会增加一定的噪声$\mathcal{N}$,即最终和环境交互的动作$A$的表达式是：$$A = \pi_{\theta}(S) + \mathcal{N}$$&lt;/p&gt;
&lt;p&gt;　　　　最后，我们来看看DDPG的损失函数。对于Critic当前网络，其损失函数和DQN是类似的，都是均方误差，即：$$J(w) =\frac{1}{m}\sum\limits_{j=1}^m(y_j-Q(\phi(S_j),A_j,w))^2$$&lt;/p&gt;
&lt;p&gt;　　　　而对于 Actor当前网络，其损失函数就和之前讲的PG，A3C不同了，这里由于是确定性策略，原论文定义的损失梯度是：$$\nabla_J(\theta) = \frac{1}{m}\sum\limits_{j=1}^m[\nabla_{a}Q_(s_i,a_i,w)|_{s=s_i,a=\pi_{\theta}(s)}\nabla_{\theta} \pi_{\theta(s)}|_{s=s_i}]$$&lt;/p&gt;
&lt;p&gt;　　　　这个可以对应上我们第二节的确定性策略梯度，看起来比较麻烦，但是其实理解起来很简单。假如对同一个状态，我们输出了两个不同的动作$a_1$和$a_2$，从Critic当前网络得到了两个反馈的Q值，分别是$Q_1,Q_2$，假设$Q_1&amp;gt;Q_2$,即采取动作1可以得到更多的奖励，那么策略梯度的思想是什么呢，就是增加$a_1$的概率，降低$a_2$的概率，也就是说，Actor想要尽可能的得到更大的Q值。所以我们的Actor的损失可以简单的理解为得到的反馈Q值越大损失越小，得到的反馈Q值越小损失越大，因此只要对状态估计网络返回的Q值取个负号即可，即：$$J(\theta) =  -\frac{1}{m}\sum\limits_{j=1}^m Q_(s_i,a_i,w)$$&lt;/p&gt;

&lt;p&gt;　　　　这里我们总结下DDPG的算法流程&lt;/p&gt;
&lt;p&gt;　　　　输入：Actor当前网络，Actor目标网络，Critic当前网络，Critic目标网络,参数分别为$\theta, \theta',w,w'$,衰减因子$\gamma$,  软更新系数$\tau$,批量梯度下降的样本数$m$,目标Q网络参数更新频率$C$。最大迭代次数$T$。随机噪音函数\mathcal{N}&lt;/p&gt;
&lt;p&gt;　　　　输出：最优Actor当前网络参数$ \theta$,Critic当前网络参数$w$&lt;/p&gt;
&lt;p&gt;　　　　1. 随机初始化$\theta,w$, $w' = w$,$\theta' = \theta$。清空经验回放的集合$D$&lt;/p&gt;
&lt;p&gt;　　　　2. for i from 1 to T，进行迭代。&lt;/p&gt;
&lt;p&gt;　　　　　　a) 初始化$S$为当前状态序列的第一个状态, 拿到其特征向量$\phi(S)$&lt;/p&gt;
&lt;p&gt;　　　　　　b) 在Actor当前网络基于状态$S$得到动作$A =\pi_{\theta}(\phi(S)) + \mathcal{N} $&lt;/p&gt;
&lt;p&gt;　　　　　　c) 执行动作$A$,得到新状态$S'$,奖励$R$,是否终止状态%is\_end$&lt;/p&gt;
&lt;p&gt;　　　　　　d) 将$\{\phi(S),A,R,\phi(S'),is\_end\}$这个五元组存入经验回放集合$D$&lt;/p&gt;
&lt;p&gt;　　　　　　e) S=S'&lt;/p&gt;
&lt;p&gt;　　　　　　f) 从经验回放集合$D$中采样$m$个样本$\{\phi(S_j),A_j,R_j,\phi(S'_j),is\_end_j\}, j=1,2.,,,m$，计算当前目标Q值$y_j$：$$y_j= \begin{cases} R_j&amp;amp; {is\_end_j\; is \;true}\\ R_j + \gamma Q'(\phi(S'_j),\pi_{ \theta'}(\phi(S'_j)),w')&amp;amp; {is\_end_j\; is \;false} \end{cases}$$&lt;/p&gt;
&lt;p&gt;　　　　　　g)  使用均方差损失函数$\frac{1}{m}\sum\limits_{j=1}^m(y_j-Q(\phi(S_j),A_j,w))^2$，通过神经网络的梯度反向传播来更新Critic当前网络的所有参数$w$&lt;/p&gt;
&lt;p&gt;　　　　　　h)  使用$J(\theta) =  -\frac{1}{m}\sum\limits_{j=1}^m Q_(s_i,a_i,w)$，，通过神经网络的梯度反向传播来更新Actor当前网络的所有参数$\theta$&lt;/p&gt;
&lt;p&gt;　　　　　　i) 如果T%C=1,则更新Critic目标网络和Actor目标网络参数：$$w' \gets \tau w+ (1-\tau)w'$$$$\theta' \gets \tau \theta+ (1-\tau)\theta'$$&lt;/p&gt;
&lt;p&gt;　　　　　　j) 如果$S'$是终止状态，当前轮迭代完毕，否则转到步骤b)&lt;/p&gt;
&lt;p&gt;　　　　　　以上就是DDPG算法的主流程，要注意的是上面2.f中的$\pi_{ \theta'}(\phi(S'_j))$是通过Actor目标网络得到，而$Q'(\phi(S'_j),\pi_{ \theta'}(\phi(S'_j)),w')$则是通过Critic目标网络得到的。&lt;/p&gt;

&lt;p&gt;　　　　这里我们给出DDPG第一个算法实例，代码主要参考自莫烦的&lt;a href=&quot;https://github.com/MorvanZhou/Reinforcement-learning-with-tensorflow/blob/master/contents/9_Deep_Deterministic_Policy_Gradient_DDPG/DDPG_update.py&quot; target=&quot;_blank&quot;&gt;Github代码&lt;/a&gt;。增加了测试模型效果的部分，优化了少量参数。代码详见：&lt;a href=&quot;https://github.com/ljpzzz/machinelearning/blob/master/reinforcement-learning/ddpg.py&quot; target=&quot;_blank&quot;&gt;https://github.com/ljpzzz/machinelearning/blob/master/reinforcement-learning/ddpg.py&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　　　这里我们没有用之前的CartPole游戏，因为它不是连续动作。我们使用了Pendulum-v0这个游戏。目的是用最小的力矩使棒子竖起来，这个游戏的详细介绍参见&lt;a href=&quot;https://github.com/openai/gym/wiki/Pendulum-v0&quot; target=&quot;_blank&quot;&gt;这里&lt;/a&gt;。输入状态是角度的sin，cos值，以及角速度。一共三个值。动作是一个连续的力矩值。&lt;/p&gt;
&lt;p&gt;　　　　两个Actor网络和两个Critic网络的定义参见：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; _build_a(self, s, scope, trainable):
        with tf.variable_scope(scope):
            net &lt;/span&gt;= tf.layers.dense(s, 30, activation=tf.nn.relu, name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;l1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, trainable=&lt;span&gt;trainable)
            a &lt;/span&gt;= tf.layers.dense(net, self.a_dim, activation=tf.nn.tanh, name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, trainable=&lt;span&gt;trainable)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; tf.multiply(a, self.a_bound, name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;scaled_a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; _build_c(self, s, a, scope, trainable):
        with tf.variable_scope(scope):
            n_l1 &lt;/span&gt;= 30&lt;span&gt;
            w1_s &lt;/span&gt;= tf.get_variable(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;w1_s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, [self.s_dim, n_l1], trainable=&lt;span&gt;trainable)
            w1_a &lt;/span&gt;= tf.get_variable(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;w1_a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, [self.a_dim, n_l1], trainable=&lt;span&gt;trainable)
            b1 &lt;/span&gt;= tf.get_variable(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, [1, n_l1], trainable=&lt;span&gt;trainable)
            net &lt;/span&gt;= tf.nn.relu(tf.matmul(s, w1_s) + tf.matmul(a, w1_a) +&lt;span&gt; b1)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; tf.layers.dense(net, 1, trainable=trainable)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Q(s,a)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　Actor当前网络和Critic当前网络损失函数的定义参见：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
        td_error = tf.losses.mean_squared_error(labels=q_target, predictions=&lt;span&gt;q)
        self.ctrain &lt;/span&gt;= tf.train.AdamOptimizer(LR_C).minimize(td_error, var_list=&lt;span&gt;self.ce_params)

        a_loss &lt;/span&gt;= - tf.reduce_mean(q)    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; maximize the q&lt;/span&gt;
        self.atrain = tf.train.AdamOptimizer(LR_A).minimize(a_loss, var_list=self.ae_params)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　Actor目标网络和Critic目标网络参数软更新，Actor当前网络和Critic当前网络反向传播更新部分的代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; learn(self):
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; soft target replacement&lt;/span&gt;
&lt;span&gt;        self.sess.run(self.soft_replace)

        indices &lt;/span&gt;= np.random.choice(MEMORY_CAPACITY, size=&lt;span&gt;BATCH_SIZE)
        bt &lt;/span&gt;=&lt;span&gt; self.memory[indices, :]
        bs &lt;/span&gt;=&lt;span&gt; bt[:, :self.s_dim]
        ba &lt;/span&gt;= bt[:, self.s_dim: self.s_dim +&lt;span&gt; self.a_dim]
        br &lt;/span&gt;= bt[:, -self.s_dim - 1: -&lt;span&gt;self.s_dim]
        bs_ &lt;/span&gt;= bt[:, -&lt;span&gt;self.s_dim:]

        self.sess.run(self.atrain, {self.S: bs})
        self.sess.run(self.ctrain, {self.S: bs, self.a: ba, self.R: br, self.S_: bs_})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　其余的可以对照算法和代码一起学习，应该比较容易理解。&lt;/p&gt;

&lt;p&gt;　　　　DDPG参考了DDQN的算法思想吗，通过双网络和经验回放，加一些其他的优化，比较好的解决了Actor-Critic难收敛的问题。因此在实际产品中尤其是自动化相关的产品中用的比较多，是一个比较成熟的Actor-Critic算法。&lt;/p&gt;
&lt;p&gt;　　　　到此，我们的Policy Based RL系列也讨论完了，而在更早我们讨论了Value Based RL系列，至此，我们还剩下Model Based RL没有讨论。后续我们讨论Model Based RL的相关算法。&lt;/p&gt;

&lt;p&gt;（欢迎转载，转载请注明出处。欢迎沟通交流： liujianping-ok@163.com）&lt;/p&gt;
</description>
<pubDate>Fri, 01 Feb 2019 11:42:00 +0000</pubDate>
<dc:creator>刘建平Pinard</dc:creator>
<og:description>在强化学习(十五) A3C中，我们讨论了使用多线程的方法来解决Actor-Critic难收敛的问题，今天我们不使用多线程，而是使用和DDQN类似的方法：即经验回放和双网络的方法来改进Actor-Cri</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pinard/p/10345762.html</dc:identifier>
</item>
<item>
<title>shell脚本学习笔记 - 赵言文</title>
<link>http://www.cnblogs.com/luoyesiqiu/p/10346804.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/luoyesiqiu/p/10346804.html</guid>
<description>&lt;h2 id=&quot;shell脚本的格式&quot;&gt;shell脚本的格式&lt;/h2&gt;
&lt;p&gt;shell脚本默认文件扩展名为&lt;code&gt;.sh&lt;/code&gt;。在shell脚本中，你写入的内容，会默认当成一条命令来执行。&lt;br/&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#!/bin/bash
echo 'hello world'&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;第1行 指定shell脚本的默认解释器&lt;/li&gt;
&lt;li&gt;第2行 执行echo命令&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;将上面的代码存为test.sh，并将可执行权限赋予它&lt;code&gt;chmod +x test.sh&lt;/code&gt; ，执行&lt;code&gt;./test.sh&lt;/code&gt;运行脚本。&lt;/p&gt;
&lt;p&gt;上面的脚本将会输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;hello world&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;注释&quot;&gt;注释&lt;/h2&gt;
&lt;p&gt;和所有的编程语言一样，shell也有注释，在shell中，#号和它后面的内容来表示一个注释：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# Print a message
echo &quot;I'm a shell script.&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;输出内容&quot;&gt;输出内容&lt;/h2&gt;
&lt;p&gt;echo用于向输出流输出内容，例如:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;echo &quot;hello world&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;输入内容&quot;&gt;输入内容&lt;/h2&gt;
&lt;p&gt;read关键字用于输入一条内容：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;read input
echo $input&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的代码中，read关键字从输入流读取一个值并赋予input，然后将input的内容打印出来&lt;/p&gt;
&lt;h2 id=&quot;变量&quot;&gt;1. 变量&lt;/h2&gt;
&lt;h3 id=&quot;定义变量和赋值&quot;&gt;定义变量和赋值&lt;/h3&gt;
&lt;p&gt;变量的命名规则和C语言差不多，支持英文字母和下划线。shell中变量名前不需要声明类型，变量名后面不能有空格，例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var1='hello'
var2=90&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;读取变量&quot;&gt;读取变量&lt;/h3&gt;
&lt;p&gt;$后接变量名意为读取一个变量的值，例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var=&quot;hello&quot;
echo $var&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也可以用&lt;code&gt;${var}&lt;/code&gt;方式访问到变量值，例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var=&quot;hello&quot;
echo ${var}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;访问变量的时候&lt;code&gt;$var&lt;/code&gt;和&lt;code&gt;${var}&lt;/code&gt;是等效的，推荐后者来访问一个变量&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;变量作用域&quot;&gt;变量作用域&lt;/h3&gt;
&lt;h4 id=&quot;全局变量&quot;&gt;全局变量&lt;/h4&gt;
&lt;p&gt;没有任何关键字修饰的变量是一个全局变量，全局变量在同一个shell会话中都是有效的。可以跨文件&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function func(){
    a=90
}
func
echo $a&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;90&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;$ a=90
$ echo ${a}
$ bash 
$ echo ${a}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;90&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;空值&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;局部变量&quot;&gt;局部变量&lt;/h4&gt;
&lt;p&gt;local关键字用于声明一个局部变量&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function func(){
    local a=90
}
func
echo $a&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;空值&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;环境变量&quot;&gt;环境变量&lt;/h4&gt;
&lt;p&gt;用export关键字修饰的变量称为环境变量，在父shell会话中声明一个环境变量，子shell中都可以访问&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ export path=&quot;/system/bin&quot;
$ bash #创建一个新的shell会话
$ echo ${path}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;特殊变量&quot;&gt;特殊变量&lt;/h4&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;6.5&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;$0&lt;/td&gt;
&lt;td&gt;当前脚本的文件名&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;$n（n≥1）&lt;/td&gt;
&lt;td&gt;传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是 $1，第二个参数是 $2&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;$#&lt;/td&gt;
&lt;td&gt;传递给脚本或函数的参数个数&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;$*&lt;/td&gt;
&lt;td&gt;传递给脚本或函数的所有参数&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;$@&lt;/td&gt;
&lt;td&gt;传递给脚本或函数的所有参数&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;$?&lt;/td&gt;
&lt;td&gt;上个命令的退出状态，或函数的返回值&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;$$&lt;/td&gt;
&lt;td&gt;当前 Shell 进程 ID。对于 Shell 脚本，就是这些脚本所在的进程 ID&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4 id=&quot;和的区别&quot;&gt;$*和$@的区别&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;$*得到所有参数的字符串形式&lt;/li&gt;
&lt;li&gt;$@得到所有参数的数组形式，可以直接遍历&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;获取一条命令的执行结果&quot;&gt;2. 获取一条命令的执行结果&lt;/h2&gt;
&lt;h3 id=&quot;用-将一条命令包裹起来&quot;&gt;用 ` 将一条命令包裹起来&lt;/h3&gt;
&lt;p&gt;` 这个符号，在键盘上的位置是在Esc键的下方&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ret=${pwd}
echo ${ret}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 ` 包裹起来的命令中，也可以访问到变量&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;path='/'
ret=`ls -l ${path}`
echo ${ret}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;以command这种方式执行命令&quot;&gt;以$(command)这种方式执行命令&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;ret=$(pwd)
echo ${ret}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;用$(command)这种方式也可以访问到变量&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;path='/'
ret=$(ls -l ${path})
echo ${ret}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的例子中，如果想打印命令结果中的换行符，则：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;path='/'
ret=$(ls -l ${path})
echo &quot;${ret}&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;$(command)方式来执行命令更加直观，但是要注意，$() 仅在 Bash Shell 中有效，而反引号可在多种 Shell 中都可使用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;字符串&quot;&gt;3. 字符串&lt;/h2&gt;
&lt;p&gt;Shell有三种方式可以表示字符串&lt;/p&gt;
&lt;h3 id=&quot;字符串的表示&quot;&gt;字符串的表示&lt;/h3&gt;
&lt;h4 id=&quot;变量名后直接跟上字符&quot;&gt;(1)变量名后直接跟上字符&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;str=hello
echo ${str}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;hello&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;这种方式的字符串遇到空格，$等分隔符就会被终止&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;单引号&quot;&gt;(2)单引号&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;str=hello
echo '${str}'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;${str}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;单引号里的内容是字符串原始的样子，不存在转义&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;双引号&quot;&gt;(3)双引号&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;str=shell
echo &quot;${str}:\&quot;hello wolrd\&quot;&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;shell:&quot;hello world&quot;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;双引号中可以访问变量和转义&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;字符串的长度&quot;&gt;字符串的长度&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;str=&quot;hello&quot;
echo ${#str}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;字符串拼接&quot;&gt;字符串拼接&lt;/h3&gt;
&lt;p&gt;两个变量放在一起访问就可以拼接&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;a='hello'
b='world'
c=${a}${b}
echo ${c}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;helloworld&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;字符串截取&quot;&gt;字符串截取&lt;/h3&gt;
&lt;p&gt;(1) 从左边开始截取字符串，格式：&lt;code&gt;${string: start :length}&lt;/code&gt;,length可省略，省略时，是截取到字符串末尾&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;msg=&quot;hello world&quot;
echo ${msg: 6: 5}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;world&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;(2) 在指定位置截取字符&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;截取chars后面的字符：&lt;code&gt;${string#*chars}&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其中，string 表示要截取的字符，chars 是指定的字符（或者子字符串），&lt;em&gt;是通配符的一种，表示任意长度的字符串。&lt;/em&gt;chars连起来使用的意思是：忽略左边的所有字符，直到遇见 chars（chars 不会被截取）。&lt;/p&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;截取最后一次出现chars的位置后面的内容：&lt;code&gt;${string##*chars}&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;使用 % 截取左边字符&lt;br/&gt;使用%号可以截取指定字符（或者子字符串）左边的所有字符，具体格式如下：&lt;br/&gt;${string%chars*}&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;请注意 * 的位置，因为要截取 chars 左边的字符，而忽略 chars 右边的字符，所以 * 应该位于chars的右侧。其他方面%和#的用法相同&lt;/p&gt;
&lt;h2 id=&quot;运算符和流程控制&quot;&gt;4. 运算符和流程控制&lt;/h2&gt;
&lt;h3 id=&quot;基本运算&quot;&gt;基本运算&lt;/h3&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;7&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;加（需要结合expr命令使用）&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;减（需要结合expr命令使用）&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;乘（需要结合expr命令使用）&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;/&lt;/td&gt;
&lt;td&gt;除（需要结合expr命令使用）&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;%&lt;/td&gt;
&lt;td&gt;求余（需要结合expr命令使用）&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;=&lt;/td&gt;
&lt;td&gt;赋值&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;==&lt;/td&gt;
&lt;td&gt;判断数值是否相等，需要结合&lt;code&gt;[]&lt;/code&gt;使用&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;!=&lt;/td&gt;
&lt;td&gt;判断数值是否不相等，需要结合&lt;code&gt;[]&lt;/code&gt;使用&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;pre&gt;
&lt;code&gt;a=8
b=4
echo &quot;a=$a,b=$b&quot;
var=`expr ${a} + ${b}`
echo &quot;加法结果：${var}&quot;
var=`expr ${a} - ${b}`
echo &quot;减法结果：${var}&quot;
# 注意：乘号需要转义
var=`expr ${a} \* ${b}`
echo &quot;乘法结果：${var}&quot;
var=`expr ${a} / ${b}`
echo &quot;除法结果：${var}&quot;
var=`expr ${a} % ${b}`
echo &quot;求余结果：${var}&quot;
var=$[${a} == ${b}]
echo &quot;是否相等：${var}&quot;
var=$[${a} != ${b}]
echo &quot;是否不相等：${var}&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;a=8,b=4
加法结果：12
减法结果：4
乘法结果：32
除法结果：2
求余结果：0
是否相等：0
是否不相等：1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的例子中，调用expr命令和使用&lt;code&gt;[]&lt;/code&gt;，得到表达式的值，并将它们输出&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;请注意表达式两边的空格，shell中表达式两边要有空格&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;关系运算&quot;&gt;关系运算&lt;/h3&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;9&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;-eq&lt;/td&gt;
&lt;td&gt;全称：Equal,判断两个数是否相等&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;-ne&lt;/td&gt;
&lt;td&gt;全称：Not equal,判断两个数是否不相等&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;-gt&lt;/td&gt;
&lt;td&gt;全称：Greater than,判断前面那个数是否大于后面那个数&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;-lt&lt;/td&gt;
&lt;td&gt;全称：Less than,判断前面那个数是否小于后面那个数&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;-ge&lt;/td&gt;
&lt;td&gt;全称：Greater equal,判断前面那个数是否大于等于后面那个数&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;-le&lt;/td&gt;
&lt;td&gt;全称：Less than,判断前面那个数是否小于等于后面那个数&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;布尔运算&quot;&gt;布尔运算&lt;/h3&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;!&lt;/td&gt;
&lt;td&gt;非运算&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;-o&lt;/td&gt;
&lt;td&gt;或运算&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;-a&lt;/td&gt;
&lt;td&gt;并运算&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;逻辑运算&quot;&gt;逻辑运算&lt;/h3&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;&amp;amp;&amp;amp;&lt;/td&gt;
&lt;td&gt;逻辑并&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;&lt;code&gt;|&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;逻辑或&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;文件判断&quot;&gt;文件判断&lt;/h3&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;12&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;-e&lt;/td&gt;
&lt;td&gt;判断对象是否存在&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;-d&lt;/td&gt;
&lt;td&gt;判断对象是否存在，并且为目录&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;-f&lt;/td&gt;
&lt;td&gt;判断对象是否存在，并且为常规文件&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;-L&lt;/td&gt;
&lt;td&gt;判断对象是否存在，并且为符号链接&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;-h&lt;/td&gt;
&lt;td&gt;判断对象是否存在，并且为软链接&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;-s&lt;/td&gt;
&lt;td&gt;判断对象是否存在，并且长度不为0&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;-r&lt;/td&gt;
&lt;td&gt;判断对象是否存在，并且可读&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;-w&lt;/td&gt;
&lt;td&gt;判断对象是否存在，并且可写&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;-x&lt;/td&gt;
&lt;td&gt;判断对象是否存在，并且可执行&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;-O&lt;/td&gt;
&lt;td&gt;判断对象是否存在，并且属于当前用户&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;-G&lt;/td&gt;
&lt;td&gt;判断对象是否存在，并且属于当前用户组&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;-nt&lt;/td&gt;
&lt;td&gt;判断file1是否比file2新&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;-ot&lt;/td&gt;
&lt;td&gt;判断file1是否比file2旧&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;流程控制语句&quot;&gt;流程控制语句&lt;/h3&gt;
&lt;p&gt;(1) if语句&lt;/p&gt;
&lt;p&gt;if语句格式如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;if [ &amp;lt;condition&amp;gt; ]
then
    #do something
elif [ &amp;lt;condition&amp;gt; ]
then
    #do something
else
    #do something
fi&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果想把then和if放同一行&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;if [ &amp;lt;condition&amp;gt; ] ; then
    #do something
elif [ &amp;lt;condition&amp;gt; ] ; then
    #do something
else
    #do something
fi&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中elif和else可以省略&lt;/p&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;read file

if [ -f ${file} ] ; then
echo 'This is normal file.'
elif [ -d ${file} ] ; then
echo 'This is dir'
elif [ -c ${file} -o -b ${file} ] ; then
echo 'This is device file.'
else
echo 'This is unknown file.'
fi&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;逻辑判断也可以用test命令，它和&lt;code&gt;[]&lt;/code&gt;的作用是一样的&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;a=4
b=4
if test $[a+2] -eq $[b+2]
then
   echo &quot;表达式结果相等&quot;
else
   echo &quot;表达式结果不相等&quot;
fi&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;表达式结果不相等&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;(2) for 语句&lt;/p&gt;
&lt;p&gt;if语句格式如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;for [ &amp;lt;var&amp;gt; ] in [list] 
do
# do something
done&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;read input
for val in ${input} ; do
echo &quot;val:${val}&quot;
done&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输入：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1 2 3 4 5&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;val:1&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;val:2&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;val:3&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;val:4&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;val:5&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;(3) while 语句&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;while [ &amp;lt;condition&amp;gt; ]
do
    #do something
done&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;a=1
sum=0
while [ ${a} -le 100 ] ;do
sum=`expr ${sum} + ${a}`
a=`expr ${a} + 1`
done

echo ${sum}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;5050&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;函数&quot;&gt;5. 函数&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;用function关键字来定义一个函数&lt;/li&gt;
&lt;li&gt;直接写一个函数名来调用一个无参数的函数&lt;/li&gt;
&lt;li&gt;函数有参数，调用时，在函数名后面写上参数，多个参数用空格隔开&lt;/li&gt;
&lt;li&gt;调用函数时传递参数，在函数体内部，通过 $n的形式来获取参数的值，例如：$1表示第1个参数，$2表示第2个参数...&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;函数的结构&quot;&gt;函数的结构&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;function foo(){
# do everything...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;函数的用法示例&quot;&gt;函数的用法示例&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;function foo(){
    local name=$1
    local age=$2
    echo &quot;My name is: ${name},I'm ${age} years old.&quot;
}
foo &quot;luoye&quot; 26&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;My name is: luoye,I'm 26 years old.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;参考&quot;&gt;6. 参考&lt;/h2&gt;
&lt;p&gt;http://c.biancheng.net/shell/&lt;br/&gt;http://www.runoob.com/linux/linux-shell-process-control.html&lt;br/&gt;https://www.cnblogs.com/qlqwjy/p/8684630.html&lt;/p&gt;
</description>
<pubDate>Fri, 01 Feb 2019 11:24:00 +0000</pubDate>
<dc:creator>赵言文</dc:creator>
<og:description>shell脚本的格式 shell脚本默认文件扩展名为 。在shell脚本中，你写入的内容，会默认当成一条命令来执行。 例如： 第1行 指定shell脚本的默认解释器 第2行 执行echo命令 将上面的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/luoyesiqiu/p/10346804.html</dc:identifier>
</item>
<item>
<title>如何在ASP.NET Core程序启动时运行异步任务（1） - LamondLu</title>
<link>http://www.cnblogs.com/lwqlun/p/10346733.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lwqlun/p/10346733.html</guid>
<description>&lt;blockquote readability=&quot;2.7222222222222&quot;&gt;
&lt;p&gt;原文：&lt;a href=&quot;https://andrewlock.net/running-async-tasks-on-app-startup-in-asp-net-core-part-1/&quot;&gt;Running async tasks on app startup in ASP.NET Core (Part 1)&lt;/a&gt;&lt;br/&gt;作者：Andrew Lock&lt;br/&gt;译者：Lamond Lu&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201902/65831-20190201190335753-452686726.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;背景&quot;&gt;背景&lt;/h2&gt;
&lt;p&gt;当我们做项目的时候，有时候希望自己的ASP.NET Core应用在启动前执行一些初始化逻辑。例如，你希望验证配置是否合法，填充缓存数据，或者运行数据库迁移脚本。在本篇博客中，我将介绍几种可选的方案，并且通过展示一些简单的方法和扩展点来说明我想要解决的问题。&lt;/p&gt;
&lt;p&gt;开始我将先描述一下ASP.NET Core内置的解决方案，使用&lt;code&gt;IStartupFilter&lt;/code&gt;来运行同步任务。然后我将描述几种可选的执行异步任务的方案。你可以（但是可能不应该这样做）使用&lt;code&gt;IStartupFilter&lt;/code&gt;或者&lt;code&gt;IApplicationLifetime&lt;/code&gt;事件来执行异步任务。你也可以使用&lt;code&gt;IHostService&lt;/code&gt;接口来运行一次性任务且不会阻塞ASP.NET Core应用启动。最后唯一合理的方案是在&lt;code&gt;program.cs&lt;/code&gt;文件中手动运行任务。在下一篇博客中，我会展示一个可以简化这个流程的推荐方案。&lt;/p&gt;
&lt;h2 id=&quot;为什么我们需要在程序启动时运行异步任务&quot;&gt;为什么我们需要在程序启动时运行异步任务？&lt;/h2&gt;
&lt;p&gt;在程序启动，开始监听请求之前，运行一些初始化代码是非常普遍的。对于一个ASP.NET Core应用程序，启动前有许多任务需要运行，例如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;确定当前的托管环境&lt;/li&gt;
&lt;li&gt;从appsetting.json文件和环境变量中读取配置&lt;/li&gt;
&lt;li&gt;配置依赖注入容器&lt;/li&gt;
&lt;li&gt;构建依赖注入容器&lt;/li&gt;
&lt;li&gt;配置中间件管道&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以上几步都四发生在应用程序引导时。然而有些一次性任务需要在&lt;code&gt;WebHost&lt;/code&gt;启动，监听请求前运行。例如&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;检查强类型配置是否合法&lt;/li&gt;
&lt;li&gt;使用数据库或者API填充缓存&lt;/li&gt;
&lt;li&gt;运行数据库迁移脚本（这通常不是一个很好的方案，但是对于一些应用来说够用了）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;有些时候，一些任务并不是非要在程序启动，监听请求前运行。这里我们以填充缓存为例，如果它是设计的比较好的话，在程序启动前是否填充缓存数据是无关紧要的。但是，相对的，你肯定也希望在应用程序开始监听请求之前，迁移你的数据库！&lt;/p&gt;
&lt;p&gt;其实ASP.NET Core框架自己也需要运行一些一次性初始化任务。这个最好的例子就是数据保护，它常用来做数据加密，这个模块必须要在应用启动前初始化。为了实现初始化，它们使用了&lt;code&gt;IStartupFilter&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;使用istartupfilter来运行同步任务&quot;&gt;使用&lt;code&gt;IStartupFilter&lt;/code&gt;来运行同步任务&lt;/h2&gt;
&lt;p&gt;在之前的博客中，我已经介绍过&lt;code&gt;IStartupFilter&lt;/code&gt;, 它是一个自定义ASP.NET Core应用的强力接口。&lt;/p&gt;
&lt;p&gt;如果你是第一次接触Filter, 我建议你去我之前的博客,这里我只会提供一个简短的总结。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;IStartupFilter&lt;/code&gt;会在配置中间件管道的进程中被执行（通常在&lt;code&gt;Startup.Configure()&lt;/code&gt;中完成）。它们允许你通过插入额外的中间件，分叉或执行任何其他操作来自定义应用程序实际创建的中间件管道。例如下面代码展示的&lt;code&gt;AutoRequestServiceStartupFilter&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class AutoRequestServicesStartupFilter : IStartupFilter
{
    public Action&amp;lt;IApplicationBuilder&amp;gt; Configure(Action&amp;lt;IApplicationBuilder&amp;gt; next)
    {
        return builder =&amp;gt;
        {
            builder.UseMiddleware&amp;lt;RequestServicesContainerMiddleware&amp;gt;();
            next(builder);
        };
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这非常有用，但它与ASP.NET Core应用程序启动时运行一次性任务有什么关系呢？&lt;/p&gt;
&lt;p&gt;&lt;code&gt;IStartupFilter&lt;/code&gt;的主要功能是为开发人员提供了一个钩子(hook), 这个钩子触发的时机是在在应用程序配置完成并配置依赖注入容器之后，应用程序启动之前。这意味着，你可以在实现&lt;code&gt;IStartupFilter&lt;/code&gt;的类中使用依赖注入，这样你就可以在这里完成许多希望在应用程序启用前需要运行的任务。以ASP.NET Core内置的&lt;a href=&quot;https://github.com/aspnet/DataProtection/blob/2.2.0-preview3/src/Microsoft.AspNetCore.DataProtection/Internal/DataProtectionStartupFilter.cs&quot;&gt;DataProtectionStartupFilter&lt;/a&gt;为例，它会在程序启用前初始化整个数据保护模块。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;IStartupFilter&lt;/code&gt;提供的另外一个重要功能就是，它允许你通过向依赖注入容器注册服务来添加要执行的任务。这意味着如果你自己编写了一个Library, 你可以在应用程序启动时注册一个任务，而不需要应用程序显式调用它。&lt;/p&gt;
&lt;p&gt;问题是&lt;code&gt;IStartupFilter&lt;/code&gt;基本上是同步的。&lt;code&gt;Configure&lt;/code&gt;方法的返回值不是&lt;code&gt;Task&lt;/code&gt;，因此我们只能使用同步方式执行异步任务，这显然不是好的实现方案。 我稍后会讨论这个，但现在让我们先跳过它。&lt;/p&gt;
&lt;h2 id=&quot;为什么不用健康检查&quot;&gt;为什么不用健康检查？&lt;/h2&gt;
&lt;p&gt;ASP.NET Core 2.2中加入了一个新的健康检查功能，它通过暴露一个HTTP节点，让你可以查询当前应用的健康状态。当应用部署之后，像Kubernetes这样的编排引擎或HAProxy和NGINX等反向代理可以查询此HTTP节点以检查你应用是否已准备好开始接收请求。&lt;/p&gt;
&lt;p&gt;你可以使用健康检查功能来确保你的应用程序不会开始处理请求，直到所有必需的一次性初始化任务完成为止。然而，这有一些缺点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;WebHost和Kestrel本身将在执行一次性初始化任务之前启动，虽然他们不会收到可能存在问题的“真实”请求（仅健康检查请求）。&lt;/li&gt;
&lt;li&gt;这种方式会引入了额外的复杂度，除了添加运行一次性任务的代码之外，还需要添加运行状况检查以测试任务是否完成，并同步任务的状态。&lt;/li&gt;
&lt;li&gt;应用程序的启动会有延迟，因为需要等待所有任务完成，所以不太可能减少启动时间。&lt;/li&gt;
&lt;li&gt;如果任务失败，应用程序不会终止，而且健康检查也永远不会通过。这可能是可以接受的，但是我个人更喜欢让应用程序立刻终止。&lt;/li&gt;
&lt;li&gt;使用健康检查，并不能知道一次性任务运行的怎么样，你只能了解到任务是否完成。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在我看来，健康检查并不适合一次性任务的场景，他们可能对我描述的一些例子很有用，但我不认为它适用于所有情况。我真的希望能在&lt;code&gt;WebHost&lt;/code&gt;启动之前，运行一些一次性任务。&lt;/p&gt;
&lt;h2 id=&quot;运行异步任务&quot;&gt;运行异步任务&lt;/h2&gt;
&lt;p&gt;我已经花了很长的篇幅来讨论了所有不能完成我的目标的所有方法，那么哪些才是可行的方案！在这一节中，我将描述几种运行异步任务的方案（即方法返回&lt;code&gt;Task&lt;/code&gt;, 并且需要等待的），其中有一些较好的方案，也有一些需要规避的方案。&lt;/p&gt;
&lt;p&gt;这里为了更清楚的描述这些方案，我选用数据库迁移作为例子。在EF Core中，你可以在运行时调用&lt;code&gt;myDbContext.Database.MigrateAsync()&lt;/code&gt;来迁移数据库，其中&lt;code&gt;myDbContext&lt;/code&gt;是当前应用程序的数据库上下文实例。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;EF还提供了一个同步的数据库迁移方法&lt;code&gt;Database.Migrate()&lt;/code&gt;,但是这里我们不需要使用它。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;使用istartupfilter&quot;&gt;使用&lt;code&gt;IStartupFilter&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;我之前描述过如何使用&lt;code&gt;IStartupFilter&lt;/code&gt;在应用程序启动时运行同步任务。 不过，这里为了异步方法，我们使用了&lt;code&gt;GetAwaiter()&lt;/code&gt;和&lt;code&gt;GetResult()&lt;/code&gt;阻塞了线程, 将异步方法变成了一个同步方法。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;警告：这是一种非常不好的异步实践方式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class MigratorStartupFilter: IStartupFilter
{
    private readonly IServiceProvider _serviceProvider;
    public MigratorStartupFilter(IServiceProvider serviceProvider)
    {
        _serviceProvider = serviceProvider;
    }

    public Action&amp;lt;IApplicationBuilder&amp;gt; Configure(Action&amp;lt;IApplicationBuilder&amp;gt; next)
    {
        using(var scope = _seviceProvider.CreateScope())
        {
           
            var myDbContext = scope.ServiceProvider.GetRequiredService&amp;lt;MyDbContext&amp;gt;();

            
            myDbContext.Database.MigrateAsync()
                .GetAwaiter()  
                .GetResult();  
        }

        return next;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段代码可能不会引起任何问题，它会在应用程序启动且未开始监听请求时运行，所以不太可能出现死锁。但是坦率的说，我会尽可能不用这种方式。&lt;/p&gt;
&lt;h3 id=&quot;使用iapplicationlifetime-事件&quot;&gt;使用&lt;code&gt;IApplicationLifetime&lt;/code&gt; 事件&lt;/h3&gt;
&lt;p&gt;我之前还没有讨论过和这个事件相关的内容，但是当你的应用程序启动和关闭前，你可以使用&lt;code&gt;IApplicationLifetime&lt;/code&gt;接口接收到通知。这里我不会详细介绍它，因为使用它来实现我们的目的会有一些问题。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;IApplicationLifetime&lt;/code&gt;使用&lt;code&gt;CancellationTokens&lt;/code&gt;来注册回调，这意味着你只能同步执行回调。 这实际上意味着无论你做什么，你都会遇到同步异步模式。&lt;br/&gt;ApplicationStarted事件仅在WebHost启动后触发，因此任务在应用程序开始接受请求后运行。&lt;br/&gt;鉴于他们没有解决&lt;code&gt;IStartupFilter&lt;/code&gt;使用同步方式处理异步任务的问题，也没有阻止应用启动，所以我只是将它列出来仅供参考。&lt;/p&gt;
&lt;h3 id=&quot;使用ihostedservice运行异步事件&quot;&gt;使用&lt;code&gt;IHostedService&lt;/code&gt;运行异步事件&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;IHostService&lt;/code&gt;允许在ASP.NET Core应用程序生命周期内，以后台程序的方式执行长时间运行的任务。它有许多不同的用途，你可以使用它在计数器上运行定期任务，或者监听RabbitMQ消息。在ASP.NET Core 3.0中, Web Host也可能是使用&lt;code&gt;IHostService&lt;/code&gt;构建的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;IHostService&lt;/code&gt;本质上是异步的，他提供了&lt;code&gt;StartAsync&lt;/code&gt;和&lt;code&gt;StopAsync&lt;/code&gt;方法。这对我们来说非常的有用，它不再是使用同步方式处理异步任务了。使用&lt;code&gt;IHostService&lt;/code&gt;，我们的数据库迁移任务可以变成一个托管服务。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class MigratorHostedService: IHostedService
{
    private readonly IServiceProvider _serviceProvider;
    public MigratorStartupFilter(IServiceProvider serviceProvider)
    {
        _serviceProvider = serviceProvider;
    }

    public async Task StartAsync(CancellationToken cancellationToken)
    {
        using(var scope = _seviceProvider.CreateScope())
        {
            
            var myDbContext = scope.ServiceProvider.GetRequiredService&amp;lt;MyDbContext&amp;gt;();
            
            await myDbContext.Database.MigrateAsync();
        }
    }

    public Task StopAsync(CancellationToken cancellationToken)
    {
        return Task.CompletedTask;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不幸的是，&lt;code&gt;IHostedService&lt;/code&gt;并不是我们希望的灵丹妙药。 它允许我们编写真正的异步代码，但它有几个问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;IHostService&lt;/code&gt;的典型实现期望&lt;code&gt;StartAsync&lt;/code&gt;方法能够相对快速返回。对于后台任务来说，它希望你能够以异步分当时启动服务，但是大多数任务都是在启动代码之外。迁移数据库的任务会阻止其他&lt;code&gt;IHostService&lt;/code&gt;启动(这里我不太理解作者的意思，只是按字面意思翻译，后续会更新这里)。&lt;/li&gt;
&lt;li&gt;第二个问题是最大的问题，你的应用程序会在&lt;code&gt;IHostService&lt;/code&gt;运行数据库迁移之前开始接受请求，这显然不是我们想要的。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;在program.cs中手动运行任务&quot;&gt;在&lt;code&gt;Program.cs&lt;/code&gt;中手动运行任务&lt;/h4&gt;
&lt;p&gt;到现在为止，我们都没有提供一种完善的解决方案，他们或者是使用同步方式处理异步任务，或者是不能阻止程序启动。&lt;/p&gt;
&lt;p&gt;现在让我们停止尝试使用框架机制，手动来完成工作。&lt;/p&gt;
&lt;p&gt;ASP.NET Core模板中使用的默认&lt;code&gt;Program.cs&lt;/code&gt;在&lt;code&gt;Main&lt;/code&gt;函数的一个语句中构建并运行&lt;code&gt;IWebHost&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class Program
{
    public static void Main(string[] args)
    {
        CreateWebHostBuilder(args).Build().Run();
    }

    public static IWebHostBuilder CreateWebHostBuilder(string[] args) =&amp;gt;
        WebHost.CreateDefaultBuilder(args)
            .UseStartup&amp;lt;Startup&amp;gt;();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里你可能会发现在&lt;code&gt;Build()&lt;/code&gt;方法之后, &lt;code&gt;Run()&lt;/code&gt;方法之前，你可以添加一些自定义的代码，再加上C# 7.1中允许使用异步方式运行&lt;code&gt;Main&lt;/code&gt;方法，所以这里我们有了一个合理的方案。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class Program
{
    public static async Task Main(string[] args)
    {
        IWebHost webHost = CreateWebHostBuilder(args).Build();

        using (var scope = webHost.Services.CreateScope())
        {
            var myDbContext = scope.ServiceProvider.GetRequiredService&amp;lt;MyDbContext&amp;gt;();
           
            await myDbContext.Database.MigrateAsync();
        }

        await webHost.RunAsync();
    }

    public static IWebHostBuilder CreateWebHostBuilder(string[] args) =&amp;gt;
        WebHost.CreateDefaultBuilder(args)
            .UseStartup&amp;lt;Startup&amp;gt;();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个方案有以下优点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;我们使用的是真正的异步，而不是使用同步方式处理异步任务&lt;/li&gt;
&lt;li&gt;我们可以使用异步方式运行任务&lt;/li&gt;
&lt;li&gt;只有当我们的异步任务都完成之后，WebHost才会启动&lt;/li&gt;
&lt;li&gt;在这个时间点，依赖注入容易已经构建完成，我们可以使用它来创建服务&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;但是这种方法也存在一些问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;即使依赖注入容器构建完成，但是中间件管道却还没有完成构建。只有当你调用&lt;code&gt;Run()&lt;/code&gt;或者&lt;code&gt;RunAsync()&lt;/code&gt;方法之后，中间件管道才开始构建。当构建中间件管道时，&lt;code&gt;IStartupFilter&lt;/code&gt;才会被执行，然后程序启动。如果你的异步任务需要在以上任何步骤中配置，那你就不走运了。&lt;/li&gt;
&lt;li&gt;我们失去了通过向依赖注入容器添加服务来自动运行任务的能力。 我们只能手动运行任务。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果这些问题都不是问题，那么我认为这个最终选项提供了解决问题的最佳方案。 在我的下一篇文章中，我将展示一些方法，我们可以在这个例子的基础上构建，以使某些内容更容易使用。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;在这篇文章中，我讨论了在ASP.NET Core应用程序启动时执行异步运行任务的必要性。 我描述了这样做的一些问题和挑战。 对于同步任务，&lt;code&gt;IStartupFilter&lt;/code&gt;为ASP.NET Core应用程序启动过程提供了一个有用的钩子，但是需要使用同步方式运行异步任务，这通常是一个坏主意。 我描述了运行异步任务的一些可能的选项，我发现其中最好的是在&lt;code&gt;Program.cs&lt;/code&gt;中“手动”运行任务。 在下一篇文章中，我将介绍一些代码，使这个模式更容易使用。&lt;/p&gt;
</description>
<pubDate>Fri, 01 Feb 2019 11:21:00 +0000</pubDate>
<dc:creator>LamondLu</dc:creator>
<og:description>当我们做项目的时候，有时候希望自己的ASP.NET Core应用在启动前执行一些初始化逻辑。例如，你希望验证配置是否合法，填充缓存数据，或者运行数据库迁移脚本。在本篇博客中，我将介绍几种可选的方案，并</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lwqlun/p/10346733.html</dc:identifier>
</item>
<item>
<title>反正你们写的都是没有即时演示的教程，我为什么不去看官方文档？ - Conmajia</title>
<link>http://www.cnblogs.com/conmajia/p/in-article-js.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/conmajia/p/in-article-js.html</guid>
<description>&lt;img src=&quot;https://img2018.cnblogs.com/blog/407692/201902/407692-20190201144455557-1714361716.png&quot; class=&quot;noborder&quot; width=&quot;64&quot;/&gt;&lt;p&gt;我就拿Vue举个栗子。&lt;/p&gt;&lt;p&gt;Vue.js是什么，我想你多半知道，不然你也不会打开这篇文章。&lt;/p&gt;
&lt;p&gt;这几天看到写Vue教程的文章突然多起来了。不过，就我所见，在这里发表的&lt;em&gt;所有&lt;/em&gt;教程文章，&lt;em&gt;都不支持&lt;/em&gt;&lt;strong&gt;即时演示&lt;/strong&gt;，顶多有点儿自己画的图片之类的点缀一下。那么，请问您的文章和官网的交互式教程相比有什么优势？高级技巧或者独创的tricks就算了，那些写&lt;em&gt;基础教程&lt;/em&gt;的作者们，您的目标读者全是不看官方文档，&lt;em&gt;吃不下饼干非得您给嚼碎了再喂&lt;/em&gt;的那种蠢驴吗？&lt;/p&gt;
&lt;h2 id=&quot;但是&quot;&gt;但是！&lt;/h2&gt;
&lt;p&gt;看完这篇文章，你至少可以在你的教程里加入一些简单的Vue交互（或者别的骚东西）！就像这个被我搬过来的官方例子一样：&lt;/p&gt;
&lt;div class=&quot;panel&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;《进入/离开 &amp;amp; 列表过渡：列表的排序过渡》&lt;/p&gt;
&lt;div class=&quot;panel-body&quot;&gt;
&lt;p&gt;&lt;button v-on:click=&quot;add&quot; class=&quot;btn&quot;&gt;Add&lt;/button&gt; &lt;button v-on:click=&quot;remove&quot; class=&quot;btn&quot;&gt;Remove&lt;/button&gt; &lt;span v-for=&quot;item in items&quot; v-bind:key=&quot;item&quot; class=&quot;list-complete-item&quot;&gt;{{ item }}&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p class=&quot;with-padding text-danger&quot;&gt;▲ 点一下按钮&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;new Vue({&lt;br/&gt;el: '#list-complete-demo',&lt;br/&gt;data: {&lt;br/&gt;items: [1,2,3,4,5,6,7,8,9],&lt;br/&gt;nextNum: 10&lt;br/&gt;},&lt;br/&gt;methods: {&lt;br/&gt;randomIndex: function () {&lt;br/&gt;return Math.floor(Math.random() * this.items.length)&lt;br/&gt;},&lt;br/&gt;add: function () {&lt;br/&gt;this.items.splice(this.randomIndex(), 0, this.nextNum++)&lt;br/&gt;},&lt;br/&gt;remove: function () {&lt;br/&gt;this.items.splice(this.randomIndex(), 1)&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;})&lt;br/&gt;&lt;/p&gt;
&lt;h2 id=&quot;几个关键&quot;&gt;几个关键&lt;/h2&gt;
&lt;p&gt;给文章加上interactive内容，尤其是在第三方平台（比如BKY）发表的文章，没有插件功能，必须用到HTML权限。但是文章内的&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;已经被屏蔽了，直接写是不会解析的。所以为了让文章能&lt;strong&gt;交互&lt;/strong&gt;，你得绕过&lt;code&gt;script&lt;/code&gt;的屏蔽。&lt;/p&gt;
&lt;h3 id=&quot;简易代码执行器&quot;&gt;简易代码执行器&lt;/h3&gt;
&lt;p&gt;我在&lt;a href=&quot;https://www.cnblogs.com/conmajia/p/bypass-script-filtering.html&quot;&gt;《如何绕过BKY对 script 的屏蔽》&lt;/a&gt;里提供了一个简易的解决方案，我称为&lt;strong&gt;简易代码执行器&lt;/strong&gt;（ECE）。就目前的效果而言，正如你在这篇文章里看到的，它的效果还挺好的，至少够用了。通过每篇文章各自执行代码，你可以省去在全局设置里不断添加新代码的烦恼。相信我，当你写的文章越来越多，global maintenance会把你逼疯的。等到哪天不用这些代码了，直接删除文章就好，免去了在狭小的设置对话框的犄角旮旯里寻找作废代码的烦恼。&lt;/p&gt;
&lt;p&gt;ECE会读取文章里所有可识别的代码块，然后分别执行它们。对我这个博客来说，一个标准的&lt;strong&gt;文章内嵌代码块&lt;/strong&gt;是用 &lt;code&gt;run&lt;/code&gt; 或者 &lt;code&gt;runearly&lt;/code&gt; 标签包围的代码块：&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;run&amp;gt;
    &amp;lt;!-- some code --&amp;gt;
&amp;lt;/run&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;文章加载完毕后，ECE就会开始逐个执行代码块里的&lt;code&gt;some code&lt;/code&gt;。拿一个简单的Vue官方代码举例：&lt;/p&gt;
&lt;div class=&quot;panel&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;《介绍：处理用户输入》&lt;/p&gt;
&lt;div class=&quot;panel-body&quot;&gt;
&lt;div id=&quot;app-5&quot;&gt;
&lt;p&gt;{{ message }}&lt;/p&gt;
&lt;button v-on:click=&quot;reverseMessage&quot; class=&quot;btn&quot;&gt;逆转消息&lt;/button&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;var app5 = new Vue({&lt;br/&gt;el: '#app-5',&lt;br/&gt;data: {&lt;br/&gt;message: 'Hello Vue.js!'&lt;br/&gt;},&lt;br/&gt;methods: {&lt;br/&gt;reverseMessage: function () {&lt;br/&gt;this.message = this.message.split('').reverse().join('')&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;})&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;普通的博客文章（就是我吐槽的那些&lt;em&gt;基础教程&lt;/em&gt;）是没法做到上面这样真正使用Vue.js实现的交互效果的。如果不用别的招，它们只能在文章里干瘪地罗列出一堆代码，读者看了半天也是满头雾水，依然不知道这玩意儿到底是个什么样。有心的读者也许会按图索骥，摸到官网去看文档和交互演示，心中满是问号：为什么不从一开始就直接看官网。而意志薄弱的哥们儿，可能就此放弃阅读，关掉网页，顺便再骂上一句：辣鸡文章。&lt;/p&gt;
&lt;p&gt;如果用了内嵌代码块这种methodology，只需要在文章正文写上HTML代码：&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;div id=&quot;app-5&quot;&amp;gt;
    &amp;lt;p&amp;gt;{{ message }}&amp;lt;/p&amp;gt;
    &amp;lt;button v-on:click=&quot;reverseMessage&quot;&amp;gt;逆转消息&amp;lt;/button&amp;gt;
&amp;lt;/div&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后把Vue语句写到一个&lt;code&gt;run&lt;/code&gt;标签里&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;&amp;lt;run&amp;gt;
var app5 = new Vue({
    el: '#app-5',
    data: {
        message: 'Hello Vue.js!'
    },
    methods: {
        reverseMessage: function() {
            this.message = this.message.split('').reverse().join('')
        }
    }
})
&amp;lt;/run&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;文章正文内容加载完后，ECE会执行这些Vue代码，就能得到上面的交互效果。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;简易代码执行器&lt;/strong&gt;的实现很简单，它分为&lt;strong&gt;标准执行阶段&lt;/strong&gt;和&lt;strong&gt;推迟执行阶段&lt;/strong&gt;。由 &lt;code&gt;runearly&lt;/code&gt; 包裹的代码块在DOM加载完毕后就开始执行，相当于：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;$(function() {
    /* 代码 */
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;run&lt;/code&gt;里的代码需要等到文档全部载入后才执行，相当于：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;$(window).load(function() {
    /* 代码 */
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这很好理解，如果想不明白，看看我前面提到的那篇文章。&lt;/p&gt;
&lt;h3 id=&quot;多个代码块之间传递变量&quot;&gt;多个代码块之间传递变量&lt;/h3&gt;
&lt;p&gt;我的代码是用&lt;code&gt;eval&lt;/code&gt;执行的，这带来一个问题：多个&lt;code&gt;run&lt;/code&gt;代码块之间没法直接传递变量。比如我写：&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;run&amp;gt;
    var a = 1;
&amp;lt;/run&amp;gt;
&amp;lt;run&amp;gt;
    a = a + 1;
&amp;lt;/run&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第二个&lt;code&gt;run&lt;/code&gt;是没法执行的，浏览器会报错：&lt;/p&gt;
&lt;pre class=&quot;plain&quot;&gt;
&lt;code&gt;ReferenceError: a is not defined&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;a&lt;/code&gt;的生命周期只限于第一个&lt;code&gt;run&lt;/code&gt;内。为了解决这个问题，我在全局设置里增加了一个缓存变量和三个助手函数，分别用来读取／写入／删除需要共享的变量：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;var steady = new Array();

function getValue(name) {
    return steady[name];
}

function setValue(name, value) {
    steady[name] = value;
}

function removeValue(name) {
    steady.remove(name);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;steady&lt;/code&gt;因为是写在全局设置里的，它的生命周期是整个session。通过它，各个代码块之间就可以传递变量了，这样，你在写文章尤其是长文章时就能把代码块分开写在文章不同的位置，而不用把所有的代码都挤在一个&lt;code&gt;run&lt;/code&gt;里，影响写作思路。&lt;/p&gt;
&lt;p&gt;另外一种变量传递解决方案是使用cookie完成。Cookie优点在于可以在不同页面间传递值，这一点上面的方案是办不到的。但是它的缺点也和优点一样明显。Cookie没办法直接保存除了字符串和数字之外的变量，比如数组。好在大部分网页内容和变量都可以通过&lt;strong&gt;序列化&lt;/strong&gt;转换成JSON字符串进行保存／读取。Cookie的操作可以借用js-cookie完成，非常方便。&lt;/p&gt;
&lt;h2 id=&quot;其他的骚操作&quot;&gt;其他的骚操作&lt;/h2&gt;
&lt;p&gt;有了运行代码块的能力，你可以在讲解Vue的时候，引入其他的内容配合讲解。比如把Vue和ECharts结合起来，实现图文并茂的讲解和阐述。轻轻松松就可以画出精美的交互式图表，再搭配Vue的动态绑定插槽等等。这样装修之后文章自然完爆那些用着默认主题，呆板、无神的鸡肋文。下面这两张图都是可以点的，试试看：&lt;/p&gt;
&lt;p&gt;Loading...&lt;/p&gt;
▲ 数据演示
&lt;p&gt;&lt;br/&gt;function paintCanvas(canvas) {&lt;br/&gt;var myChart = echarts.init(document.getElementById(canvas));&lt;br/&gt;myChart.showLoading();&lt;br/&gt;var json_data = {&lt;br/&gt;&quot;name&quot;: &quot;flare&quot;,&lt;br/&gt;&quot;children&quot;: [{&lt;br/&gt;&quot;name&quot;: &quot;analytics&quot;,&lt;br/&gt;&quot;children&quot;: [{&lt;br/&gt;&quot;name&quot;: &quot;cluster&quot;,&lt;br/&gt;&quot;children&quot;: [{&lt;br/&gt;&quot;name&quot;: &quot;AgglomerativeCluster&quot;,&lt;br/&gt;&quot;value&quot;: 3938&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;CommunityStructure&quot;,&lt;br/&gt;&quot;value&quot;: 3812&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;HierarchicalCluster&quot;,&lt;br/&gt;&quot;value&quot;: 6714&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;MergeEdge&quot;,&lt;br/&gt;&quot;value&quot;: 743&lt;br/&gt;}]&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;graph&quot;,&lt;br/&gt;&quot;children&quot;: [{&lt;br/&gt;&quot;name&quot;: &quot;BetweennessCentrality&quot;,&lt;br/&gt;&quot;value&quot;: 3534&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;LinkDistance&quot;,&lt;br/&gt;&quot;value&quot;: 5731&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;MaxFlowMinCut&quot;,&lt;br/&gt;&quot;value&quot;: 7840&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;ShortestPaths&quot;,&lt;br/&gt;&quot;value&quot;: 5914&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;SpanningTree&quot;,&lt;br/&gt;&quot;value&quot;: 3416&lt;br/&gt;}]&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;optimization&quot;,&lt;br/&gt;&quot;children&quot;: [{&lt;br/&gt;&quot;name&quot;: &quot;AspectRatioBanker&quot;,&lt;br/&gt;&quot;value&quot;: 7074&lt;br/&gt;}]&lt;br/&gt;}]&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;animate&quot;,&lt;br/&gt;&quot;children&quot;: [{&lt;br/&gt;&quot;name&quot;: &quot;Easing&quot;,&lt;br/&gt;&quot;value&quot;: 17010&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;FunctionSequence&quot;,&lt;br/&gt;&quot;value&quot;: 5842&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;interpolate&quot;,&lt;br/&gt;&quot;children&quot;: [{&lt;br/&gt;&quot;name&quot;: &quot;ArrayInterpolator&quot;,&lt;br/&gt;&quot;value&quot;: 1983&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;ColorInterpolator&quot;,&lt;br/&gt;&quot;value&quot;: 2047&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;DateInterpolator&quot;,&lt;br/&gt;&quot;value&quot;: 1375&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;Interpolator&quot;,&lt;br/&gt;&quot;value&quot;: 8746&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;MatrixInterpolator&quot;,&lt;br/&gt;&quot;value&quot;: 2202&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;NumberInterpolator&quot;,&lt;br/&gt;&quot;value&quot;: 1382&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;ObjectInterpolator&quot;,&lt;br/&gt;&quot;value&quot;: 1629&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;PointInterpolator&quot;,&lt;br/&gt;&quot;value&quot;: 1675&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;RectangleInterpolator&quot;,&lt;br/&gt;&quot;value&quot;: 2042&lt;br/&gt;}]&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;ISchedulable&quot;,&lt;br/&gt;&quot;value&quot;: 1041&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;Parallel&quot;,&lt;br/&gt;&quot;value&quot;: 5176&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;Pause&quot;,&lt;br/&gt;&quot;value&quot;: 449&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;Scheduler&quot;,&lt;br/&gt;&quot;value&quot;: 5593&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;Sequence&quot;,&lt;br/&gt;&quot;value&quot;: 5534&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;Transition&quot;,&lt;br/&gt;&quot;value&quot;: 9201&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;Transitioner&quot;,&lt;br/&gt;&quot;value&quot;: 19975&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;TransitionEvent&quot;,&lt;br/&gt;&quot;value&quot;: 1116&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;Tween&quot;,&lt;br/&gt;&quot;value&quot;: 6006&lt;br/&gt;}]&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;data&quot;,&lt;br/&gt;&quot;children&quot;: [{&lt;br/&gt;&quot;name&quot;: &quot;converters&quot;,&lt;br/&gt;&quot;children&quot;: [{&lt;br/&gt;&quot;name&quot;: &quot;Converters&quot;,&lt;br/&gt;&quot;value&quot;: 721&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;DelimitedTextConverter&quot;,&lt;br/&gt;&quot;value&quot;: 4294&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;GraphMLConverter&quot;,&lt;br/&gt;&quot;value&quot;: 9800&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;IDataConverter&quot;,&lt;br/&gt;&quot;value&quot;: 1314&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;JSONConverter&quot;,&lt;br/&gt;&quot;value&quot;: 2220&lt;br/&gt;}]&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;DataField&quot;,&lt;br/&gt;&quot;value&quot;: 1759&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;DataSchema&quot;,&lt;br/&gt;&quot;value&quot;: 2165&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;DataSet&quot;,&lt;br/&gt;&quot;value&quot;: 586&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;DataSource&quot;,&lt;br/&gt;&quot;value&quot;: 3331&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;DataTable&quot;,&lt;br/&gt;&quot;value&quot;: 772&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;DataUtil&quot;,&lt;br/&gt;&quot;value&quot;: 3322&lt;br/&gt;}]&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;display&quot;,&lt;br/&gt;&quot;children&quot;: [{&lt;br/&gt;&quot;name&quot;: &quot;DirtySprite&quot;,&lt;br/&gt;&quot;value&quot;: 8833&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;LineSprite&quot;,&lt;br/&gt;&quot;value&quot;: 1732&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;RectSprite&quot;,&lt;br/&gt;&quot;value&quot;: 3623&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;TextSprite&quot;,&lt;br/&gt;&quot;value&quot;: 10066&lt;br/&gt;}]&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;flex&quot;,&lt;br/&gt;&quot;children&quot;: [{&lt;br/&gt;&quot;name&quot;: &quot;FlareVis&quot;,&lt;br/&gt;&quot;value&quot;: 4116&lt;br/&gt;}]&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;physics&quot;,&lt;br/&gt;&quot;children&quot;: [{&lt;br/&gt;&quot;name&quot;: &quot;DragForce&quot;,&lt;br/&gt;&quot;value&quot;: 1082&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;GravityForce&quot;,&lt;br/&gt;&quot;value&quot;: 1336&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;IForce&quot;,&lt;br/&gt;&quot;value&quot;: 319&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;NBodyForce&quot;,&lt;br/&gt;&quot;value&quot;: 10498&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;Particle&quot;,&lt;br/&gt;&quot;value&quot;: 2822&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;Simulation&quot;,&lt;br/&gt;&quot;value&quot;: 9983&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;Spring&quot;,&lt;br/&gt;&quot;value&quot;: 2213&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;SpringForce&quot;,&lt;br/&gt;&quot;value&quot;: 1681&lt;br/&gt;}]&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;query&quot;,&lt;br/&gt;&quot;children&quot;: [{&lt;br/&gt;&quot;name&quot;: &quot;AggregateExpression&quot;,&lt;br/&gt;&quot;value&quot;: 1616&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;And&quot;,&lt;br/&gt;&quot;value&quot;: 1027&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;Arithmetic&quot;,&lt;br/&gt;&quot;value&quot;: 3891&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;Average&quot;,&lt;br/&gt;&quot;value&quot;: 891&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;BinaryExpression&quot;,&lt;br/&gt;&quot;value&quot;: 2893&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;Comparison&quot;,&lt;br/&gt;&quot;value&quot;: 5103&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;CompositeExpression&quot;,&lt;br/&gt;&quot;value&quot;: 3677&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;Count&quot;,&lt;br/&gt;&quot;value&quot;: 781&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;DateUtil&quot;,&lt;br/&gt;&quot;value&quot;: 4141&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;Distinct&quot;,&lt;br/&gt;&quot;value&quot;: 933&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;Expression&quot;,&lt;br/&gt;&quot;value&quot;: 5130&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;ExpressionIterator&quot;,&lt;br/&gt;&quot;value&quot;: 3617&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;Fn&quot;,&lt;br/&gt;&quot;value&quot;: 3240&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;If&quot;,&lt;br/&gt;&quot;value&quot;: 2732&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;IsA&quot;,&lt;br/&gt;&quot;value&quot;: 2039&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;Literal&quot;,&lt;br/&gt;&quot;value&quot;: 1214&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;Match&quot;,&lt;br/&gt;&quot;value&quot;: 3748&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;Maximum&quot;,&lt;br/&gt;&quot;value&quot;: 843&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;methods&quot;,&lt;br/&gt;&quot;children&quot;: [{&lt;br/&gt;&quot;name&quot;: &quot;add&quot;,&lt;br/&gt;&quot;value&quot;: 593&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;and&quot;,&lt;br/&gt;&quot;value&quot;: 330&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;average&quot;,&lt;br/&gt;&quot;value&quot;: 287&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;count&quot;,&lt;br/&gt;&quot;value&quot;: 277&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;distinct&quot;,&lt;br/&gt;&quot;value&quot;: 292&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;div&quot;,&lt;br/&gt;&quot;value&quot;: 595&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;eq&quot;,&lt;br/&gt;&quot;value&quot;: 594&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;fn&quot;,&lt;br/&gt;&quot;value&quot;: 460&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;gt&quot;,&lt;br/&gt;&quot;value&quot;: 603&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;gte&quot;,&lt;br/&gt;&quot;value&quot;: 625&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;iff&quot;,&lt;br/&gt;&quot;value&quot;: 748&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;isa&quot;,&lt;br/&gt;&quot;value&quot;: 461&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;lt&quot;,&lt;br/&gt;&quot;value&quot;: 597&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;lte&quot;,&lt;br/&gt;&quot;value&quot;: 619&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;max&quot;,&lt;br/&gt;&quot;value&quot;: 283&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;min&quot;,&lt;br/&gt;&quot;value&quot;: 283&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;mod&quot;,&lt;br/&gt;&quot;value&quot;: 591&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;mul&quot;,&lt;br/&gt;&quot;value&quot;: 603&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;neq&quot;,&lt;br/&gt;&quot;value&quot;: 599&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;not&quot;,&lt;br/&gt;&quot;value&quot;: 386&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;or&quot;,&lt;br/&gt;&quot;value&quot;: 323&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;orderby&quot;,&lt;br/&gt;&quot;value&quot;: 307&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;range&quot;,&lt;br/&gt;&quot;value&quot;: 772&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;select&quot;,&lt;br/&gt;&quot;value&quot;: 296&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;stddev&quot;,&lt;br/&gt;&quot;value&quot;: 363&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;sub&quot;,&lt;br/&gt;&quot;value&quot;: 600&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;sum&quot;,&lt;br/&gt;&quot;value&quot;: 280&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;update&quot;,&lt;br/&gt;&quot;value&quot;: 307&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;variance&quot;,&lt;br/&gt;&quot;value&quot;: 335&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;where&quot;,&lt;br/&gt;&quot;value&quot;: 299&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;xor&quot;,&lt;br/&gt;&quot;value&quot;: 354&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;-&quot;,&lt;br/&gt;&quot;value&quot;: 264&lt;br/&gt;}]&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;Minimum&quot;,&lt;br/&gt;&quot;value&quot;: 843&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;Not&quot;,&lt;br/&gt;&quot;value&quot;: 1554&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;Or&quot;,&lt;br/&gt;&quot;value&quot;: 970&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;Query&quot;,&lt;br/&gt;&quot;value&quot;: 13896&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;Range&quot;,&lt;br/&gt;&quot;value&quot;: 1594&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;StringUtil&quot;,&lt;br/&gt;&quot;value&quot;: 4130&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;Sum&quot;,&lt;br/&gt;&quot;value&quot;: 791&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;Variable&quot;,&lt;br/&gt;&quot;value&quot;: 1124&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;Variance&quot;,&lt;br/&gt;&quot;value&quot;: 1876&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;Xor&quot;,&lt;br/&gt;&quot;value&quot;: 1101&lt;br/&gt;}]&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;scale&quot;,&lt;br/&gt;&quot;children&quot;: [{&lt;br/&gt;&quot;name&quot;: &quot;IScaleMap&quot;,&lt;br/&gt;&quot;value&quot;: 2105&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;LinearScale&quot;,&lt;br/&gt;&quot;value&quot;: 1316&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;LogScale&quot;,&lt;br/&gt;&quot;value&quot;: 3151&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;OrdinalScale&quot;,&lt;br/&gt;&quot;value&quot;: 3770&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;QuantileScale&quot;,&lt;br/&gt;&quot;value&quot;: 2435&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;QuantitativeScale&quot;,&lt;br/&gt;&quot;value&quot;: 4839&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;RootScale&quot;,&lt;br/&gt;&quot;value&quot;: 1756&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;Scale&quot;,&lt;br/&gt;&quot;value&quot;: 4268&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;ScaleType&quot;,&lt;br/&gt;&quot;value&quot;: 1821&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;TimeScale&quot;,&lt;br/&gt;&quot;value&quot;: 5833&lt;br/&gt;}]&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;util&quot;,&lt;br/&gt;&quot;children&quot;: [{&lt;br/&gt;&quot;name&quot;: &quot;Arrays&quot;,&lt;br/&gt;&quot;value&quot;: 8258&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;Colors&quot;,&lt;br/&gt;&quot;value&quot;: 10001&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;Dates&quot;,&lt;br/&gt;&quot;value&quot;: 8217&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;Displays&quot;,&lt;br/&gt;&quot;value&quot;: 12555&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;Filter&quot;,&lt;br/&gt;&quot;value&quot;: 2324&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;Geometry&quot;,&lt;br/&gt;&quot;value&quot;: 10993&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;heap&quot;,&lt;br/&gt;&quot;children&quot;: [{&lt;br/&gt;&quot;name&quot;: &quot;FibonacciHeap&quot;,&lt;br/&gt;&quot;value&quot;: 9354&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;HeapNode&quot;,&lt;br/&gt;&quot;value&quot;: 1233&lt;br/&gt;}]&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;IEvaluable&quot;,&lt;br/&gt;&quot;value&quot;: 335&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;IPredicate&quot;,&lt;br/&gt;&quot;value&quot;: 383&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;IValueProxy&quot;,&lt;br/&gt;&quot;value&quot;: 874&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;math&quot;,&lt;br/&gt;&quot;children&quot;: [{&lt;br/&gt;&quot;name&quot;: &quot;DenseMatrix&quot;,&lt;br/&gt;&quot;value&quot;: 3165&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;IMatrix&quot;,&lt;br/&gt;&quot;value&quot;: 2815&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;SparseMatrix&quot;,&lt;br/&gt;&quot;value&quot;: 3366&lt;br/&gt;}]&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;Maths&quot;,&lt;br/&gt;&quot;value&quot;: 17705&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;Orientation&quot;,&lt;br/&gt;&quot;value&quot;: 1486&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;palette&quot;,&lt;br/&gt;&quot;children&quot;: [{&lt;br/&gt;&quot;name&quot;: &quot;ColorPalette&quot;,&lt;br/&gt;&quot;value&quot;: 6367&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;Palette&quot;,&lt;br/&gt;&quot;value&quot;: 1229&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;ShapePalette&quot;,&lt;br/&gt;&quot;value&quot;: 2059&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;SizePalette&quot;,&lt;br/&gt;&quot;value&quot;: 2291&lt;br/&gt;}]&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;Property&quot;,&lt;br/&gt;&quot;value&quot;: 5559&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;Shapes&quot;,&lt;br/&gt;&quot;value&quot;: 19118&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;Sort&quot;,&lt;br/&gt;&quot;value&quot;: 6887&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;Stats&quot;,&lt;br/&gt;&quot;value&quot;: 6557&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;Strings&quot;,&lt;br/&gt;&quot;value&quot;: 22026&lt;br/&gt;}]&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;vis&quot;,&lt;br/&gt;&quot;children&quot;: [{&lt;br/&gt;&quot;name&quot;: &quot;axis&quot;,&lt;br/&gt;&quot;children&quot;: [{&lt;br/&gt;&quot;name&quot;: &quot;Axes&quot;,&lt;br/&gt;&quot;value&quot;: 1302&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;Axis&quot;,&lt;br/&gt;&quot;value&quot;: 24593&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;AxisGridLine&quot;,&lt;br/&gt;&quot;value&quot;: 652&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;AxisLabel&quot;,&lt;br/&gt;&quot;value&quot;: 636&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;CartesianAxes&quot;,&lt;br/&gt;&quot;value&quot;: 6703&lt;br/&gt;}]&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;controls&quot;,&lt;br/&gt;&quot;children&quot;: [{&lt;br/&gt;&quot;name&quot;: &quot;AnchorControl&quot;,&lt;br/&gt;&quot;value&quot;: 2138&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;ClickControl&quot;,&lt;br/&gt;&quot;value&quot;: 3824&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;Control&quot;,&lt;br/&gt;&quot;value&quot;: 1353&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;ControlList&quot;,&lt;br/&gt;&quot;value&quot;: 4665&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;DragControl&quot;,&lt;br/&gt;&quot;value&quot;: 2649&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;ExpandControl&quot;,&lt;br/&gt;&quot;value&quot;: 2832&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;HoverControl&quot;,&lt;br/&gt;&quot;value&quot;: 4896&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;IControl&quot;,&lt;br/&gt;&quot;value&quot;: 763&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;PanZoomControl&quot;,&lt;br/&gt;&quot;value&quot;: 5222&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;SelectionControl&quot;,&lt;br/&gt;&quot;value&quot;: 7862&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;TooltipControl&quot;,&lt;br/&gt;&quot;value&quot;: 8435&lt;br/&gt;}]&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;data&quot;,&lt;br/&gt;&quot;children&quot;: [{&lt;br/&gt;&quot;name&quot;: &quot;Data&quot;,&lt;br/&gt;&quot;value&quot;: 20544&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;DataList&quot;,&lt;br/&gt;&quot;value&quot;: 19788&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;DataSprite&quot;,&lt;br/&gt;&quot;value&quot;: 10349&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;EdgeSprite&quot;,&lt;br/&gt;&quot;value&quot;: 3301&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;NodeSprite&quot;,&lt;br/&gt;&quot;value&quot;: 19382&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;render&quot;,&lt;br/&gt;&quot;children&quot;: [{&lt;br/&gt;&quot;name&quot;: &quot;ArrowType&quot;,&lt;br/&gt;&quot;value&quot;: 698&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;EdgeRenderer&quot;,&lt;br/&gt;&quot;value&quot;: 5569&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;IRenderer&quot;,&lt;br/&gt;&quot;value&quot;: 353&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;ShapeRenderer&quot;,&lt;br/&gt;&quot;value&quot;: 2247&lt;br/&gt;}]&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;ScaleBinding&quot;,&lt;br/&gt;&quot;value&quot;: 11275&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;Tree&quot;,&lt;br/&gt;&quot;value&quot;: 7147&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;TreeBuilder&quot;,&lt;br/&gt;&quot;value&quot;: 9930&lt;br/&gt;}]&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;events&quot;,&lt;br/&gt;&quot;children&quot;: [{&lt;br/&gt;&quot;name&quot;: &quot;DataEvent&quot;,&lt;br/&gt;&quot;value&quot;: 2313&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;SelectionEvent&quot;,&lt;br/&gt;&quot;value&quot;: 1880&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;TooltipEvent&quot;,&lt;br/&gt;&quot;value&quot;: 1701&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;VisualizationEvent&quot;,&lt;br/&gt;&quot;value&quot;: 1117&lt;br/&gt;}]&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;legend&quot;,&lt;br/&gt;&quot;children&quot;: [{&lt;br/&gt;&quot;name&quot;: &quot;Legend&quot;,&lt;br/&gt;&quot;value&quot;: 20859&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;LegendItem&quot;,&lt;br/&gt;&quot;value&quot;: 4614&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;LegendRange&quot;,&lt;br/&gt;&quot;value&quot;: 10530&lt;br/&gt;}]&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;operator&quot;,&lt;br/&gt;&quot;children&quot;: [{&lt;br/&gt;&quot;name&quot;: &quot;distortion&quot;,&lt;br/&gt;&quot;children&quot;: [{&lt;br/&gt;&quot;name&quot;: &quot;BifocalDistortion&quot;,&lt;br/&gt;&quot;value&quot;: 4461&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;Distortion&quot;,&lt;br/&gt;&quot;value&quot;: 6314&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;FisheyeDistortion&quot;,&lt;br/&gt;&quot;value&quot;: 3444&lt;br/&gt;}]&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;encoder&quot;,&lt;br/&gt;&quot;children&quot;: [{&lt;br/&gt;&quot;name&quot;: &quot;ColorEncoder&quot;,&lt;br/&gt;&quot;value&quot;: 3179&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;Encoder&quot;,&lt;br/&gt;&quot;value&quot;: 4060&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;PropertyEncoder&quot;,&lt;br/&gt;&quot;value&quot;: 4138&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;ShapeEncoder&quot;,&lt;br/&gt;&quot;value&quot;: 1690&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;SizeEncoder&quot;,&lt;br/&gt;&quot;value&quot;: 1830&lt;br/&gt;}]&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;filter&quot;,&lt;br/&gt;&quot;children&quot;: [{&lt;br/&gt;&quot;name&quot;: &quot;FisheyeTreeFilter&quot;,&lt;br/&gt;&quot;value&quot;: 5219&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;GraphDistanceFilter&quot;,&lt;br/&gt;&quot;value&quot;: 3165&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;VisibilityFilter&quot;,&lt;br/&gt;&quot;value&quot;: 3509&lt;br/&gt;}]&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;IOperator&quot;,&lt;br/&gt;&quot;value&quot;: 1286&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;label&quot;,&lt;br/&gt;&quot;children&quot;: [{&lt;br/&gt;&quot;name&quot;: &quot;Labeler&quot;,&lt;br/&gt;&quot;value&quot;: 9956&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;RadialLabeler&quot;,&lt;br/&gt;&quot;value&quot;: 3899&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;StackedAreaLabeler&quot;,&lt;br/&gt;&quot;value&quot;: 3202&lt;br/&gt;}]&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;layout&quot;,&lt;br/&gt;&quot;children&quot;: [{&lt;br/&gt;&quot;name&quot;: &quot;AxisLayout&quot;,&lt;br/&gt;&quot;value&quot;: 6725&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;BundledEdgeRouter&quot;,&lt;br/&gt;&quot;value&quot;: 3727&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;CircleLayout&quot;,&lt;br/&gt;&quot;value&quot;: 9317&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;CirclePackingLayout&quot;,&lt;br/&gt;&quot;value&quot;: 12003&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;DendrogramLayout&quot;,&lt;br/&gt;&quot;value&quot;: 4853&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;ForceDirectedLayout&quot;,&lt;br/&gt;&quot;value&quot;: 8411&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;IcicleTreeLayout&quot;,&lt;br/&gt;&quot;value&quot;: 4864&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;IndentedTreeLayout&quot;,&lt;br/&gt;&quot;value&quot;: 3174&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;Layout&quot;,&lt;br/&gt;&quot;value&quot;: 7881&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;NodeLinkTreeLayout&quot;,&lt;br/&gt;&quot;value&quot;: 12870&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;PieLayout&quot;,&lt;br/&gt;&quot;value&quot;: 2728&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;RadialTreeLayout&quot;,&lt;br/&gt;&quot;value&quot;: 12348&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;RandomLayout&quot;,&lt;br/&gt;&quot;value&quot;: 870&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;StackedAreaLayout&quot;,&lt;br/&gt;&quot;value&quot;: 9121&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;TreeMapLayout&quot;,&lt;br/&gt;&quot;value&quot;: 9191&lt;br/&gt;}]&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;Operator&quot;,&lt;br/&gt;&quot;value&quot;: 2490&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;OperatorList&quot;,&lt;br/&gt;&quot;value&quot;: 5248&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;OperatorSequence&quot;,&lt;br/&gt;&quot;value&quot;: 4190&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;OperatorSwitch&quot;,&lt;br/&gt;&quot;value&quot;: 2581&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;SortOperator&quot;,&lt;br/&gt;&quot;value&quot;: 2023&lt;br/&gt;}]&lt;br/&gt;}, {&lt;br/&gt;&quot;name&quot;: &quot;Visualization&quot;,&lt;br/&gt;&quot;value&quot;: 16540&lt;br/&gt;}]&lt;br/&gt;}]&lt;br/&gt;};&lt;br/&gt;myChart.hideLoading();&lt;br/&gt;myChart.setOption(option = {&lt;br/&gt;tooltip: {&lt;br/&gt;trigger: 'item',&lt;br/&gt;triggerOn: 'mousemove'&lt;br/&gt;},&lt;br/&gt;series: [{&lt;br/&gt;type: 'tree',&lt;br/&gt;data: [json_data],&lt;br/&gt;top: '18%',&lt;br/&gt;bottom: '14%',&lt;br/&gt;layout: 'radial',&lt;br/&gt;symbol: 'emptyCircle',&lt;br/&gt;symbolSize: 7,&lt;br/&gt;initialTreeDepth: 3,&lt;br/&gt;animationDurationUpdate: 750&lt;br/&gt;}]&lt;br/&gt;});&lt;br/&gt;}&lt;br/&gt;paintCanvas('chart1');&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;或者为你强大的项目画个错综复杂秀破天际的类关系图：&lt;/p&gt;
&lt;p&gt;Loading...&lt;/p&gt;
▲ 类关系图
&lt;p&gt;&lt;br/&gt;function paintCanvas(canvas,data,title=''){var chart=echarts.init(document.getElementById(canvas));chart.setOption({title:{text:title},tooltip:{},legend:{data:['']},dataZoom:[{id:'dataZoomX',type:'slider',xAxisIndex:[0],filterMode:'filter'}],xAxis:{type:'category',&lt;a href=&quot;data:data.x&quot; class=&quot;uri&quot;&gt;data:data.x&lt;/a&gt;},yAxis:{scale:true},series:[{name:'',type:'bar',&lt;a href=&quot;data:data.y&quot; class=&quot;uri&quot;&gt;data:data.y&lt;/a&gt;}],grid:{top:10}})}&lt;br/&gt;paintCanvas('chart2',{x:[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99],y:[0.009999,0.0099791,0.0099851,0.010045,0.0099323,0.0100227,0.009973,0.0099823,0.0099812,0.0100117,0.0099555,0.0100219,0.0099808,0.0099235,0.0100256,0.0100195,0.0100347,0.0099649,0.0099957,0.0100012,0.0099983,0.0100443,0.0100185,0.0100028,0.0099762,0.0099998,0.010038,0.0099765,0.0100109,0.01005,0.01003,0.0100054,0.0099526,0.010001,0.0100172,0.0100067,0.0099779,0.0100547,0.0100519,0.009982,0.0100288,0.0100559,0.0100406,0.0099738,0.009963,0.0099715,0.0099753,0.0099745,0.0099862,0.0099928,0.0100211,0.009992,0.0100048,0.0099731,0.0100005,0.0100157,0.0100208,0.0099976,0.0099595,0.01004,0.0100246,0.0100253,0.0100169,0.0099769,0.0099607,0.0100206,0.010013,0.0099873,0.0099567,0.0099987,0.0099625,0.0100595,0.0099338,0.0100009,0.0100181,0.0099867,0.0100141,0.010015,0.0099953,0.0100089,0.0100287,0.0100257,0.0100045,0.0100001,0.0100012,0.0100357,0.0099458,0.0100448,0.0099926,0.0099496,0.0100401,0.0099849,0.0099666,0.0100041,0.0100289,0.0099873,0.009978,0.0099922,0.0099923,0.0100045]});&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;反正在网上写文章这种行为已经没什么节操可言了，为什么不用你脑中那些乱七八糟的JS知识，来让你的文章更骚一点呢？是你吗，秀儿？&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;本该耀眼的文章，你怎么好意思让它丑陋不堪，寡淡无味，泯然于众？！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The End. &lt;span class=&quot;math inline&quot;&gt;\(\Box\)&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 01 Feb 2019 11:05:00 +0000</pubDate>
<dc:creator>Conmajia</dc:creator>
<og:description>最近写 Vue 之类基础教程的有点多，绝大多数不支持文章内即时演示。那么，请问您的文章和官网的交互式教程相比有什么优势？看看本文，试试给你的文章加丶料。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/conmajia/p/in-article-js.html</dc:identifier>
</item>
</channel>
</rss>