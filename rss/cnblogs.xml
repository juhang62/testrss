<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Spring Cloud 系列之 Sleuth 链路追踪（一） - 哈喽沃德先生</title>
<link>http://www.cnblogs.com/mrhelloworld/p/sleuth1.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mrhelloworld/p/sleuth1.html</guid>
<description>&lt;p&gt;随着微服务架构的流行，服务按照不同的维度进行拆分，一次请求往往需要涉及到多个服务。互联网应用构建在不同的软件模块集上，这些软件模块，有可能是由不同的团队开发、可能使用不同的编程语言来实现、有可能布在了几千台服务器，横跨多个不同的数据中心。因此，就需要一些可以帮助理解系统行为、用于分析性能问题的工具，以便发生故障的时候，能够快速定位和解决问题。在复杂的微服务架构系统中，几乎每一个前端请求都会形成一个复杂的分布式服务调用链路。一个请求完整调用链可能如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mrhelloworld.com/resources/articles/spring/spring-cloud/sleuth/2062729-8d66b8b261c9c6b4.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　随着服务的越来越多，对调用链的分析会越来越复杂。它们之间的调用关系也许如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mrhelloworld.com/resources/articles/spring/spring-cloud/sleuth/2279594-4b7d1b6abe595390.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　随着业务规模不断增大、服务不断增多以及频繁变更的情况下，面对复杂的调用链路就带来一系列问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如何快速发现问题？&lt;/li&gt;
&lt;li&gt;如何判断故障影响范围？&lt;/li&gt;
&lt;li&gt;如何梳理服务依赖以及依赖的合理性？&lt;/li&gt;
&lt;li&gt;如何分析链路性能问题以及实时容量规划？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;　　而链路追踪的出现正是为了解决这种问题，它可以在复杂的服务调用中定位问题，还可以在新人加入后台团队之后，让其清楚地知道自己所负责的服务在哪一环。&lt;/p&gt;
&lt;p&gt;　　除此之外，如果某个接口突然耗时增加，也不必再逐个服务查询耗时情况，我们可以直观地分析出服务的性能瓶颈，方便在流量激增的情况下精准合理地扩容。&lt;/p&gt;

&lt;h2 id=&quot;什么是链路追踪&quot;&gt;什么是链路追踪&lt;/h2&gt;

&lt;p&gt;　　“链路追踪”一词是在 2010 年提出的，当时谷歌发布了一篇 Dapper 论文：&lt;a href=&quot;http://bigbully.github.io/Dapper-translation/&quot;&gt;Dapper，大规模分布式系统的跟踪系统&lt;/a&gt;，介绍了谷歌自研的分布式链路追踪的实现原理，还介绍了他们是怎么低成本实现对应用透明的。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;单纯的理解链路追踪，就是指一次任务的开始到结束，期间调用的所有系统及耗时（时间跨度）都可以完整记录下来。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　其实 Dapper 一开始只是一个独立的调用链路追踪系统，后来逐渐演化成了监控平台，并且基于监控平台孕育出了很多工具，比如实时预警、过载保护、指标数据查询等。&lt;/p&gt;
&lt;p&gt;　　除了谷歌的 Dapper，还有一些其他比较有名的产品，比如阿里的鹰眼、大众点评的 CAT、Twitter 的 Zipkin、Naver（著名社交软件LINE的母公司）的 PinPoint 以及国产开源的 SkyWalking（已贡献给 Apache） 等。&lt;/p&gt;

&lt;h2 id=&quot;什么是-sleuth&quot;&gt;什么是 Sleuth&lt;/h2&gt;

&lt;p&gt;　　Spring Cloud Sleuth 为 Spring Cloud 实现了分布式跟踪解决方案。兼容 Zipkin，HTrace 和其他基于日志的追踪系统，例如 ELK（Elasticsearch 、Logstash、 Kibana）。&lt;/p&gt;
&lt;p&gt;　　Spring Cloud Sleuth 提供了以下功能：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;链路追踪&lt;/code&gt;：通过 Sleuth 可以很清楚的看出一个请求都经过了那些服务，可以很方便的理清服务间的调用关系等。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;性能分析&lt;/code&gt;：通过 Sleuth 可以很方便的看出每个采样请求的耗时，分析哪些服务调用比较耗时，当服务调用的耗时随着请求量的增大而增大时， 可以对服务的扩容提供一定的提醒。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;数据分析，优化链路&lt;/code&gt;：对于频繁调用一个服务，或并行调用等，可以针对业务做一些优化措施。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;可视化错误&lt;/code&gt;：对于程序未捕获的异常，可以配合 Zipkin 查看。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;专业术语&quot;&gt;专业术语&lt;/h2&gt;

&lt;p&gt;　　点击链接观看：&lt;a href=&quot;https://video.zhihu.com/video/1238020793595924480&quot; target=&quot;_blank&quot;&gt;Sleuth 专业术语视频&lt;/a&gt;（获取更多请关注公众号「哈喽沃德先生」）&lt;/p&gt;

&lt;h3 id=&quot;span&quot;&gt;Span&lt;/h3&gt;

&lt;p&gt;　　基本工作单位，一次单独的调用链可以称为一个 Span，Dapper 记录的是 Span 的名称，以及每个 Span 的 ID 和父 ID，以重建在一次追踪过程中不同 Span 之间的关系，图中一个矩形框就是一个 Span，前端从发出请求到收到回复就是一个 Span。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mrhelloworld.com/resources/articles/spring/spring-cloud/sleuth/img2.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;开始跟踪的初始跨度称为&lt;code&gt;root span&lt;/code&gt;。该跨度的 ID 的值等于跟踪 ID。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　Dapper 记录了 span 名称，以及每个 span 的 ID 和父 span ID，以重建在一次追踪过程中不同 span 之间的关系。如果一个 span 没有父 ID 被称为 root span。所有 span 都挂在一个特定的 Trace 上，也共用一个 trace id。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mrhelloworld.com/resources/articles/spring/spring-cloud/sleuth/img3.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3 id=&quot;trace&quot;&gt;Trace&lt;/h3&gt;

&lt;p&gt;　　一系列 Span 组成的树状结构，一个 Trace 认为是一次完整的链路，内部包含 n 多个 Span。Trace 和 Span 存在一对多的关系，Span 与 Span 之间存在父子关系。&lt;/p&gt;
&lt;p&gt;　　举个例子：客户端调用服务 A 、服务 B 、服务 C 、服务 F，而每个服务例如 C 就是一个 Span，如果在服务 C 中另起线程调用了 D，那么 D 就是 C 的子 Span，如果在服务 D 中另起线程调用了 E，那么 E 就是 D 的子 Span，这个 C -&amp;gt; D -&amp;gt; E 的链路就是一条 Trace。如果链路追踪系统做好了，链路数据有了，借助前端解析和渲染工具，可以达到下图中的效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mrhelloworld.com/resources/articles/spring/spring-cloud/sleuth/1569484-20190414200750593-370575235.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;annotation&quot;&gt;Annotation&lt;/h3&gt;

&lt;p&gt;　　用来及时记录一个事件的存在，一些核心 annotations 用来定义一个请求的开始和结束。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;cs - Client Sent：客户端发起一个请求，这个 annotation 描述了这个 span 的开始；&lt;/li&gt;
&lt;li&gt;sr - Server Received：服务端获得请求并准备开始处理它，如果 sr 减去 cs 时间戳便可得到网络延迟；&lt;/li&gt;
&lt;li&gt;ss - Server Sent：请求处理完成（当请求返回客户端），如果 ss 减去 sr 时间戳便可得到服务端处理请求需要的时间；&lt;/li&gt;
&lt;li&gt;cr - Client Received：表示 span 结束，客户端成功接收到服务端的回复，如果 cr 减去 cs 时间戳便可得到客户端从服务端获取回复的所有所需时间。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;实现原理&quot;&gt;实现原理&lt;/h2&gt;

&lt;p&gt;　　首先感谢张以诺制作的实现原理图。&lt;/p&gt;
&lt;p&gt;　　如果想知道一个接口在哪个环节出现了问题，就必须清楚该接口调用了哪些服务，以及调用的顺序，如果把这些服务串起来，看起来就像链条一样，我们称其为调用链。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mrhelloworld.com/resources/articles/spring/spring-cloud/sleuth/1471773-20190614231653342-811888696.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　想要实现调用链，就要为每次调用做个标识，然后将服务按标识大小排列，可以更清晰地看出调用顺序，我们暂且将该标识命名为 spanid。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mrhelloworld.com/resources/articles/spring/spring-cloud/sleuth/1471773-20190614231705602-252587237.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　实际场景中，我们需要知道某次请求调用的情况，所以只有 spanid 还不够，得为每次请求做个唯一标识，这样才能根据标识查出本次请求调用的所有服务，而这个标识我们命名为 traceid。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mrhelloworld.com/resources/articles/spring/spring-cloud/sleuth/1471773-20190614231719802-1069090036.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　现在根据 spanid 可以轻易地知道被调用服务的先后顺序，但无法体现调用的层级关系，正如下图所示，多个服务可能是逐级调用的链条，也可能是同时被同一个服务调用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mrhelloworld.com/resources/articles/spring/spring-cloud/sleuth/1471773-20190614231728198-1530247525.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　所以应该每次都记录下是谁调用的，我们用 parentid 作为这个标识的名字。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mrhelloworld.com/resources/articles/spring/spring-cloud/sleuth/1471773-20190614231736945-875872485.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　到现在，已经知道调用顺序和层级关系了，但是接口出现问题后，还是不能找到出问题的环节，如果某个服务有问题，那个被调用执行的服务一定耗时很长，要想计算出耗时，上述的三个标识还不够，还需要加上时间戳，时间戳可以更精细一点，精确到微秒级。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mrhelloworld.com/resources/articles/spring/spring-cloud/sleuth/1471773-20190614231746507-1356982492.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　只记录发起调用时的时间戳还算不出耗时，要记录下服务返回时的时间戳，有始有终才能算出时间差，既然返回的也记了，就把上述的三个标识都记一下吧，不然区分不出是谁的时间戳。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mrhelloworld.com/resources/articles/spring/spring-cloud/sleuth/1471773-20190614231756180-1551132294.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　虽然能计算出从服务调用到服务返回的总耗时，但是这个时间包含了服务的执行时间和网络延迟，有时候我们需要区分出这两类时间以方便做针对性优化。那如何计算网络延迟呢？我们可以把调用和返回的过程分为以下四个事件。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Client Sent 简称 cs，客户端发起调用请求到服务端。&lt;/li&gt;
&lt;li&gt;Server Received 简称 sr，指服务端接收到了客户端的调用请求。&lt;/li&gt;
&lt;li&gt;Server Sent 简称 ss，指服务端完成了处理，准备将信息返给客户端。&lt;/li&gt;
&lt;li&gt;Client Received 简称 cr，指客户端接收到了服务端的返回信息。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://mrhelloworld.com/resources/articles/spring/spring-cloud/sleuth/1471773-20190614231805012-1235793153.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　假如在这四个事件发生时记录下时间戳，就可以轻松计算出耗时，比如 sr 减去 cs 就是调用时的网络延迟，ss 减去 sr 就是服务执行时间，cr 减去 ss 就是服务响应的延迟，cr 减 cs 就是整个服务调用执行的时间。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mrhelloworld.com/resources/articles/spring/spring-cloud/sleuth/1471773-20190614231813903-1860370592.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　其实 span 内除了记录这几个参数之外，还可以记录一些其他信息，比如发起调用服务名称、被调服务名称、返回结果、IP、调用服务的名称等，最后，我们再把相同 parentid 的 span 信息合成一个大的 span 块，就完成了一个完整的调用链。&lt;/p&gt;

&lt;h2 id=&quot;环境准备&quot;&gt;环境准备&lt;/h2&gt;

&lt;p&gt;　　&lt;code&gt;sleuth-demo&lt;/code&gt; 聚合工程。&lt;code&gt;SpringBoot 2.2.4.RELEASE&lt;/code&gt;、&lt;code&gt;Spring Cloud Hoxton.SR1&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;eureka-server&lt;/code&gt;：注册中心&lt;/li&gt;
&lt;li&gt;&lt;code&gt;eureka-server02&lt;/code&gt;：注册中心&lt;/li&gt;
&lt;li&gt;&lt;code&gt;gateway-server&lt;/code&gt;：Spring Cloud Gateway 服务网关&lt;/li&gt;
&lt;li&gt;&lt;code&gt;product-service&lt;/code&gt;：商品服务，提供了根据主键查询商品接口 &lt;code&gt;http://localhost:7070/product/{id}&lt;/code&gt; 根据多个主键查询商品接口 &lt;code&gt;http://localhost:7070/product/listByIds&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;order-service&lt;/code&gt;：订单服务，提供了根据主键查询订单接口 &lt;code&gt;http://localhost:9090/order/{id}&lt;/code&gt; 且订单服务调用商品服务。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://mrhelloworld.com/resources/articles/spring/spring-cloud/sleuth/image-20200208132104800.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;入门案例&quot;&gt;入门案例&lt;/h2&gt;

&lt;p&gt;　　点击链接观看：&lt;a href=&quot;https://video.zhihu.com/video/1238021018771914752&quot; target=&quot;_blank&quot;&gt;Sleuth 入门案例视频&lt;/a&gt;（获取更多请关注公众号「哈喽沃德先生」）&lt;/p&gt;

&lt;h3 id=&quot;添加依赖&quot;&gt;添加依赖&lt;/h3&gt;

&lt;p&gt;　　在需要进行链路追踪的项目中（服务网关、商品服务、订单服务）添加 &lt;code&gt;spring-cloud-starter-sleuth&lt;/code&gt; 依赖。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;!-- spring cloud sleuth 依赖 --&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-cloud-starter-sleuth&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;

&lt;h3 id=&quot;记录日志&quot;&gt;记录日志&lt;/h3&gt;

&lt;p&gt;　　在需要链路追踪的项目中添加 &lt;code&gt;logback.xml&lt;/code&gt; 日志文件，内容如下（logback 日志的输出级别需要是 DEBUG 级别）：&lt;/p&gt;
&lt;p&gt;　　注意修改 &lt;code&gt;&amp;lt;property name=&quot;log.path&quot; value=&quot;${catalina.base}/gateway-server/logs&quot;/&amp;gt;&lt;/code&gt; 中项目名称。&lt;/p&gt;
&lt;p&gt;　　日志核心配置：&lt;code&gt;%d{yyyy-MM-dd HH:mm:ss.SSS} [${applicationName},%X{X-B3-TraceId:-},%X{X-B3-SpanId:-}] [%thread] %-5level %logger{50} - %msg%n&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;!-- 日志级别从低到高分为TRACE &amp;lt; DEBUG &amp;lt; INFO &amp;lt; WARN &amp;lt; ERROR &amp;lt; FATAL，如果设置为WARN，则低于WARN的信息都不会输出 --&amp;gt;
&amp;lt;!-- scan: 当此属性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为true --&amp;gt;
&amp;lt;!-- scanPeriod: 设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。当scan为true时，此属性生效。默认的时间间隔为1分钟。 --&amp;gt;
&amp;lt;!-- debug: 当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。 --&amp;gt;
&amp;lt;configuration scan=&quot;true&quot; scanPeriod=&quot;10 seconds&quot;&amp;gt;
    &amp;lt;!-- 日志上下文名称 --&amp;gt;
    &amp;lt;contextName&amp;gt;my_logback&amp;lt;/contextName&amp;gt;
    &amp;lt;!-- name的值是变量的名称，value的值是变量定义的值。通过定义的值会被插入到logger上下文中。定义变量后，可以使“${}”来使用变量。 --&amp;gt;
    &amp;lt;property name=&quot;log.path&quot; value=&quot;${catalina.base}/gateway-server/logs&quot;/&amp;gt;
    &amp;lt;!-- 加载 Spring 配置文件信息 --&amp;gt;
    &amp;lt;springProperty scope=&quot;context&quot; name=&quot;applicationName&quot; source=&quot;spring.application.name&quot; defaultValue=&quot;localhost&quot;/&amp;gt;
    &amp;lt;!-- 日志输出格式 --&amp;gt;
    &amp;lt;property name=&quot;LOG_PATTERN&quot; value=&quot;%d{yyyy-MM-dd HH:mm:ss.SSS} [${applicationName},%X{X-B3-TraceId:-},%X{X-B3-SpanId:-}] [%thread] %-5level %logger{50} - %msg%n&quot;/&amp;gt;

    &amp;lt;!--输出到控制台--&amp;gt;
    &amp;lt;appender name=&quot;CONSOLE&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&amp;gt;
        &amp;lt;!--此日志appender是为开发使用，只配置最底级别，控制台输出的日志级别是大于或等于此级别的日志信息--&amp;gt;
        &amp;lt;filter class=&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;&amp;gt;
            &amp;lt;level&amp;gt;DEBUG&amp;lt;/level&amp;gt;
        &amp;lt;/filter&amp;gt;
        &amp;lt;encoder&amp;gt;
            &amp;lt;pattern&amp;gt;${LOG_PATTERN}&amp;lt;/pattern&amp;gt;
            &amp;lt;!-- 设置字符集 --&amp;gt;
            &amp;lt;charset&amp;gt;UTF-8&amp;lt;/charset&amp;gt;
        &amp;lt;/encoder&amp;gt;
    &amp;lt;/appender&amp;gt;

    &amp;lt;!-- 输出到文件 --&amp;gt;
    &amp;lt;!-- 时间滚动输出 level为 DEBUG 日志 --&amp;gt;
    &amp;lt;appender name=&quot;DEBUG_FILE&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&amp;gt;
        &amp;lt;!-- 正在记录的日志文件的路径及文件名 --&amp;gt;
        &amp;lt;file&amp;gt;${log.path}/log_debug.log&amp;lt;/file&amp;gt;
        &amp;lt;!--日志文件输出格式--&amp;gt;
        &amp;lt;encoder&amp;gt;
            &amp;lt;pattern&amp;gt;${LOG_PATTERN}&amp;lt;/pattern&amp;gt;
            &amp;lt;charset&amp;gt;UTF-8&amp;lt;/charset&amp;gt; &amp;lt;!-- 设置字符集 --&amp;gt;
        &amp;lt;/encoder&amp;gt;
        &amp;lt;!-- 日志记录器的滚动策略，按日期，按大小记录 --&amp;gt;
        &amp;lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&amp;gt;
            &amp;lt;!-- 日志归档 --&amp;gt;
            &amp;lt;fileNamePattern&amp;gt;${log.path}/debug/log-debug-%d{yyyy-MM-dd}.%i.log&amp;lt;/fileNamePattern&amp;gt;
            &amp;lt;timeBasedFileNamingAndTriggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&amp;gt;
                &amp;lt;maxFileSize&amp;gt;100MB&amp;lt;/maxFileSize&amp;gt;
            &amp;lt;/timeBasedFileNamingAndTriggeringPolicy&amp;gt;
            &amp;lt;!--日志文件保留天数--&amp;gt;
            &amp;lt;maxHistory&amp;gt;15&amp;lt;/maxHistory&amp;gt;
        &amp;lt;/rollingPolicy&amp;gt;
        &amp;lt;!-- 此日志文件只记录debug级别的 --&amp;gt;
        &amp;lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&amp;gt;
            &amp;lt;level&amp;gt;DEBUG&amp;lt;/level&amp;gt;
            &amp;lt;onMatch&amp;gt;ACCEPT&amp;lt;/onMatch&amp;gt;
            &amp;lt;onMismatch&amp;gt;DENY&amp;lt;/onMismatch&amp;gt;
        &amp;lt;/filter&amp;gt;
    &amp;lt;/appender&amp;gt;

    &amp;lt;!-- 时间滚动输出 level为 INFO 日志 --&amp;gt;
    &amp;lt;appender name=&quot;INFO_FILE&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&amp;gt;
        &amp;lt;!-- 正在记录的日志文件的路径及文件名 --&amp;gt;
        &amp;lt;file&amp;gt;${log.path}/log_info.log&amp;lt;/file&amp;gt;
        &amp;lt;!--日志文件输出格式--&amp;gt;
        &amp;lt;encoder&amp;gt;
            &amp;lt;pattern&amp;gt;${LOG_PATTERN}&amp;lt;/pattern&amp;gt;
            &amp;lt;charset&amp;gt;UTF-8&amp;lt;/charset&amp;gt;
        &amp;lt;/encoder&amp;gt;
        &amp;lt;!-- 日志记录器的滚动策略，按日期，按大小记录 --&amp;gt;
        &amp;lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&amp;gt;
            &amp;lt;!-- 每天日志归档路径以及格式 --&amp;gt;
            &amp;lt;fileNamePattern&amp;gt;${log.path}/info/log-info-%d{yyyy-MM-dd}.%i.log&amp;lt;/fileNamePattern&amp;gt;
            &amp;lt;timeBasedFileNamingAndTriggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&amp;gt;
                &amp;lt;maxFileSize&amp;gt;100MB&amp;lt;/maxFileSize&amp;gt;
            &amp;lt;/timeBasedFileNamingAndTriggeringPolicy&amp;gt;
            &amp;lt;!--日志文件保留天数--&amp;gt;
            &amp;lt;maxHistory&amp;gt;15&amp;lt;/maxHistory&amp;gt;
        &amp;lt;/rollingPolicy&amp;gt;
        &amp;lt;!-- 此日志文件只记录info级别的 --&amp;gt;
        &amp;lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&amp;gt;
            &amp;lt;level&amp;gt;INFO&amp;lt;/level&amp;gt;
            &amp;lt;onMatch&amp;gt;ACCEPT&amp;lt;/onMatch&amp;gt;
            &amp;lt;onMismatch&amp;gt;DENY&amp;lt;/onMismatch&amp;gt;
        &amp;lt;/filter&amp;gt;
    &amp;lt;/appender&amp;gt;

    &amp;lt;!-- 时间滚动输出 level为 WARN 日志 --&amp;gt;
    &amp;lt;appender name=&quot;WARN_FILE&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&amp;gt;
        &amp;lt;!-- 正在记录的日志文件的路径及文件名 --&amp;gt;
        &amp;lt;file&amp;gt;${log.path}/log_warn.log&amp;lt;/file&amp;gt;
        &amp;lt;!--日志文件输出格式--&amp;gt;
        &amp;lt;encoder&amp;gt;
            &amp;lt;pattern&amp;gt;${LOG_PATTERN}&amp;lt;/pattern&amp;gt;
            &amp;lt;charset&amp;gt;UTF-8&amp;lt;/charset&amp;gt; &amp;lt;!-- 此处设置字符集 --&amp;gt;
        &amp;lt;/encoder&amp;gt;
        &amp;lt;!-- 日志记录器的滚动策略，按日期，按大小记录 --&amp;gt;
        &amp;lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&amp;gt;
            &amp;lt;fileNamePattern&amp;gt;${log.path}/warn/log-warn-%d{yyyy-MM-dd}.%i.log&amp;lt;/fileNamePattern&amp;gt;
            &amp;lt;!-- 每个日志文件最大100MB --&amp;gt;
            &amp;lt;timeBasedFileNamingAndTriggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&amp;gt;
                &amp;lt;maxFileSize&amp;gt;100MB&amp;lt;/maxFileSize&amp;gt;
            &amp;lt;/timeBasedFileNamingAndTriggeringPolicy&amp;gt;
            &amp;lt;!--日志文件保留天数--&amp;gt;
            &amp;lt;maxHistory&amp;gt;15&amp;lt;/maxHistory&amp;gt;
        &amp;lt;/rollingPolicy&amp;gt;
        &amp;lt;!-- 此日志文件只记录warn级别的 --&amp;gt;
        &amp;lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&amp;gt;
            &amp;lt;level&amp;gt;WARN&amp;lt;/level&amp;gt;
            &amp;lt;onMatch&amp;gt;ACCEPT&amp;lt;/onMatch&amp;gt;
            &amp;lt;onMismatch&amp;gt;DENY&amp;lt;/onMismatch&amp;gt;
        &amp;lt;/filter&amp;gt;
    &amp;lt;/appender&amp;gt;

    &amp;lt;!-- 时间滚动输出 level为 ERROR 日志 --&amp;gt;
    &amp;lt;appender name=&quot;ERROR_FILE&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&amp;gt;
        &amp;lt;!-- 正在记录的日志文件的路径及文件名 --&amp;gt;
        &amp;lt;file&amp;gt;${log.path}/log_error.log&amp;lt;/file&amp;gt;
        &amp;lt;!--日志文件输出格式--&amp;gt;
        &amp;lt;encoder&amp;gt;
            &amp;lt;pattern&amp;gt;${LOG_PATTERN}&amp;lt;/pattern&amp;gt;
            &amp;lt;charset&amp;gt;UTF-8&amp;lt;/charset&amp;gt; &amp;lt;!-- 此处设置字符集 --&amp;gt;
        &amp;lt;/encoder&amp;gt;
        &amp;lt;!-- 日志记录器的滚动策略，按日期，按大小记录 --&amp;gt;
        &amp;lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&amp;gt;
            &amp;lt;fileNamePattern&amp;gt;${log.path}/error/log-error-%d{yyyy-MM-dd}.%i.log&amp;lt;/fileNamePattern&amp;gt;
            &amp;lt;timeBasedFileNamingAndTriggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&amp;gt;
                &amp;lt;maxFileSize&amp;gt;100MB&amp;lt;/maxFileSize&amp;gt;
            &amp;lt;/timeBasedFileNamingAndTriggeringPolicy&amp;gt;
            &amp;lt;!--日志文件保留天数--&amp;gt;
            &amp;lt;maxHistory&amp;gt;15&amp;lt;/maxHistory&amp;gt;
            &amp;lt;!-- 日志量最大 10 GB --&amp;gt;
            &amp;lt;totalSizeCap&amp;gt;10GB&amp;lt;/totalSizeCap&amp;gt;
        &amp;lt;/rollingPolicy&amp;gt;
        &amp;lt;!-- 此日志文件只记录ERROR级别的 --&amp;gt;
        &amp;lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&amp;gt;
            &amp;lt;level&amp;gt;ERROR&amp;lt;/level&amp;gt;
            &amp;lt;onMatch&amp;gt;ACCEPT&amp;lt;/onMatch&amp;gt;
            &amp;lt;onMismatch&amp;gt;DENY&amp;lt;/onMismatch&amp;gt;
        &amp;lt;/filter&amp;gt;
    &amp;lt;/appender&amp;gt;

    &amp;lt;!-- 对于类路径以 com.example.logback 开头的Logger,输出级别设置为warn,并且只输出到控制台 --&amp;gt;
    &amp;lt;!-- 这个logger没有指定appender，它会继承root节点中定义的那些appender --&amp;gt;
    &amp;lt;!-- &amp;lt;logger name=&quot;com.example.logback&quot; level=&quot;warn&quot;/&amp;gt; --&amp;gt;

    &amp;lt;!--通过 LoggerFactory.getLogger(&quot;myLog&quot;) 可以获取到这个logger--&amp;gt;
    &amp;lt;!--由于这个logger自动继承了root的appender，root中已经有stdout的appender了，自己这边又引入了stdout的appender--&amp;gt;
    &amp;lt;!--如果没有设置 additivity=&quot;false&quot; ,就会导致一条日志在控制台输出两次的情况--&amp;gt;
    &amp;lt;!--additivity表示要不要使用rootLogger配置的appender进行输出--&amp;gt;
    &amp;lt;logger name=&quot;myLog&quot; level=&quot;INFO&quot; additivity=&quot;false&quot;&amp;gt;
        &amp;lt;appender-ref ref=&quot;CONSOLE&quot;/&amp;gt;
    &amp;lt;/logger&amp;gt;

    &amp;lt;!-- 日志输出级别及方式 --&amp;gt;
    &amp;lt;root level=&quot;DEBUG&quot;&amp;gt;
        &amp;lt;appender-ref ref=&quot;CONSOLE&quot;/&amp;gt;
        &amp;lt;appender-ref ref=&quot;DEBUG_FILE&quot;/&amp;gt;
        &amp;lt;appender-ref ref=&quot;INFO_FILE&quot;/&amp;gt;
        &amp;lt;appender-ref ref=&quot;WARN_FILE&quot;/&amp;gt;
        &amp;lt;appender-ref ref=&quot;ERROR_FILE&quot;/&amp;gt;
    &amp;lt;/root&amp;gt;

&amp;lt;/configuration&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;

&lt;h3 id=&quot;访问&quot;&gt;访问&lt;/h3&gt;

&lt;p&gt;　　访问：&lt;a href=&quot;http://localhost:9000/order-service/order/1&quot;&gt;http://localhost:9000/order-service/order/1&lt;/a&gt; ，结果如下：&lt;/p&gt;
&lt;p&gt;　　服务网关打印信息：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;[gateway-server,95aa725089b757f8,95aa725089b757f8]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　商品服务打印信息&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;[product-service,95aa725089b757f8,e494e064842ce4e8]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　订单服务打印信息&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;[order-service,95aa725089b757f8,f4ee41a6dcf08717]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　通过打印信息可以得知，整个链路的 &lt;code&gt;traceId&lt;/code&gt; 为：&lt;code&gt;95aa725089b757f8&lt;/code&gt;，&lt;code&gt;spanId&lt;/code&gt; 为：&lt;code&gt;e494e064842ce4e8&lt;/code&gt; 和 &lt;code&gt;f4ee41a6dcf08717&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;　　查看日志文件并不是一个很好的方法，当微服务越来越多日志文件也会越来越多，查询工作会变得越来越麻烦，Spring 官方推荐使用 Zipkin 进行链路跟踪。Zipkin 可以将日志聚合，并进行可视化展示和全文检索。&lt;/p&gt;

&lt;h2 id=&quot;使用-zipkin-进行链路跟踪&quot;&gt;使用 Zipkin 进行链路跟踪&lt;/h2&gt;

&lt;h3 id=&quot;什么是-zipkin&quot;&gt;什么是 Zipkin&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://mrhelloworld.com/resources/articles/spring/spring-cloud/sleuth/zipkin_vertical_grey_gb.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;a href=&quot;https://zipkin.io/&quot;&gt;Zipkin&lt;/a&gt; 是 Twitter 公司开发贡献的一款开源的分布式实时数据追踪系统（Distributed Tracking System），基于 Google Dapper 的论文设计而来，其主要功能是聚集各个异构系统的实时监控数据。&lt;/p&gt;
&lt;p&gt;　　它可以收集各个服务器上请求链路的跟踪数据，并通过 Rest API 接口来辅助我们查询跟踪数据，实现对分布式系统的实时监控，及时发现系统中出现的延迟升高问题并找出系统性能瓶颈的根源。除了面向开发的 API 接口之外，它还提供了方便的 UI 组件，每个服务向 Zipkin 报告计时数据，Zipkin 会根据调用关系生成依赖关系图，帮助我们直观的搜索跟踪信息和分析请求链路明细。Zipkin 提供了可插拔数据存储方式：In-Memory、MySql、Cassandra 以及 Elasticsearch。&lt;/p&gt;
&lt;p&gt;　　分布式跟踪系统还有其他比较成熟的实现，例如：Naver 的 PinPoint、Apache 的 HTrace、阿里的鹰眼 Tracing、京东的 Hydra、新浪的 Watchman，美团点评的 CAT，Apache 的 SkyWalking 等。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mrhelloworld.com/resources/articles/spring/spring-cloud/sleuth/v2-a32471042408c726c7c944456f8e1e34_hd.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3 id=&quot;工作原理&quot;&gt;工作原理&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://mrhelloworld.com/resources/articles/spring/spring-cloud/sleuth/zipkin.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　共有四个组件构成了 Zipkin：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Collector&lt;/code&gt;：收集器组件，处理从外部系统发送过来的跟踪信息，将这些信息转换为 Zipkin 内部处理的 Span 格式，以支持后续的存储、分析、展示等功能。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Storage&lt;/code&gt;：存储组件，处理收集器接收到的跟踪信息，默认将信息存储在内存中，可以修改存储策略使用其他存储组件，支持 MySQL，Elasticsearch 等。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Web UI&lt;/code&gt;：UI 组件，基于 API 组件实现的上层应用，提供 Web 页面，用来展示 Zipkin 中的调用链和系统依赖关系等。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RESTful API&lt;/code&gt;：API 组件，为 Web 界面提供查询存储中数据的接口。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;　　Zipkin 分为两端，一个是 Zipkin 服务端，一个是 Zipkin 客户端，客户端也就是微服务的应用，客户端会配置服务端的 URL 地址，一旦发生服务间的调用的时候，会被配置在微服务里面的 Sleuth 的监听器监听，并生成相应的 Trace 和 Span 信息发送给服务端。发送的方式有两种，一种是消息总线的方式如 RabbitMQ 发送，还有一种是 HTTP 报文的方式发送。&lt;/p&gt;

&lt;h3 id=&quot;服务端部署&quot;&gt;服务端部署&lt;/h3&gt;

&lt;p&gt;　　服务端是一个独立的可执行的 jar 包，官方下载地址：&lt;a href=&quot;https://search.maven.org/remote_content?g=io.zipkin&amp;amp;a=zipkin-server&amp;amp;v=LATEST&amp;amp;c=exec%EF%BC%8C%E4%BD%BF%E7%94%A8&quot;&gt;https://search.maven.org/remote_content?g=io.zipkin&amp;amp;a=zipkin-server&amp;amp;v=LATEST&amp;amp;c=exec，使用&lt;/a&gt; &lt;code&gt;java -jar zipkin.jar&lt;/code&gt; 命令启动，端口默认为 &lt;code&gt;9411&lt;/code&gt;。我们下载的 jar 包为：zipkin-server-2.20.1-exec.jar，启动命令如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;java -jar zipkin-server-2.20.1-exec.jar
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;　　访问：&lt;a href=&quot;http://localhost:9411/&quot;&gt;http://localhost:9411/&lt;/a&gt; 结果如下：&lt;/p&gt;
&lt;p&gt;　　目前最新版界面。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mrhelloworld.com/resources/articles/spring/spring-cloud/sleuth/image-20200311151024323.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　之前旧版本界面。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mrhelloworld.com/resources/articles/spring/spring-cloud/sleuth/image-20200208183623587.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3 id=&quot;客户端部署&quot;&gt;客户端部署&lt;/h3&gt;

&lt;p&gt;　　点击链接观看：&lt;a href=&quot;https://video.zhihu.com/video/1238021287962451968&quot; target=&quot;_blank&quot;&gt;Zipkin 客户端部署视频&lt;/a&gt;（获取更多请关注公众号「哈喽沃德先生」）&lt;/p&gt;

&lt;h4 id=&quot;添加依赖-2&quot;&gt;添加依赖&lt;/h4&gt;

&lt;p&gt;　　在需要进行链路追踪的项目中（服务网关、商品服务、订单服务）添加 &lt;code&gt;spring-cloud-starter-zipkin&lt;/code&gt; 依赖。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;!-- spring cloud zipkin 依赖 --&amp;gt;
&amp;lt;dependency&amp;gt; 
    &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-cloud-starter-zipkin&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;

&lt;h4 id=&quot;配置文件&quot;&gt;配置文件&lt;/h4&gt;

&lt;p&gt;　　在需要进行链路追踪的项目中（服务网关、商品服务、订单服务）配置 Zipkin 服务端地址及数据传输方式。默认即如下配置。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yml&quot;&gt;spring:
  zipkin:
    base-url: http://localhost:9411/ # 服务端地址
    sender:
      type: web                      # 数据传输方式，web 表示以 HTTP 报文的形式向服务端发送数据
  sleuth:
    sampler:
      probability: 1.0               # 收集数据百分比，默认 0.1（10%）
&lt;/code&gt;
&lt;/pre&gt;

&lt;h4 id=&quot;访问-2&quot;&gt;访问&lt;/h4&gt;

&lt;p&gt;　　访问：&lt;a href=&quot;http://localhost:9000/order-service/order/1&quot;&gt;http://localhost:9000/order-service/order/1&lt;/a&gt; 结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mrhelloworld.com/resources/articles/spring/spring-cloud/sleuth/image-20200208195235916.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　新版操作如下：&lt;/p&gt;
&lt;p&gt;　　访问：&lt;a href=&quot;http://localhost:9411/&quot;&gt;http://localhost:9411/&lt;/a&gt; 根据时间过滤点击&lt;code&gt;搜索&lt;/code&gt;结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mrhelloworld.com/resources/articles/spring/spring-cloud/sleuth/image-20200311152641383.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　点击对应的追踪信息可查看请求链路详细。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mrhelloworld.com/resources/articles/spring/spring-cloud/sleuth/image-20200311152843827.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　通过依赖可以查看链路中服务的依赖关系。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mrhelloworld.com/resources/articles/spring/spring-cloud/sleuth/image-20200311153040971.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　旧版操作如下：&lt;/p&gt;
&lt;p&gt;　　访问：&lt;a href=&quot;http://localhost:9411/&quot;&gt;http://localhost:9411/&lt;/a&gt; 点击&lt;code&gt;查找&lt;/code&gt;结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mrhelloworld.com/resources/articles/spring/spring-cloud/sleuth/image-20200208194810973.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　点击对应的追踪信息可查看请求链路详细。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mrhelloworld.com/resources/articles/spring/spring-cloud/sleuth/image-20200208195010412.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　通过依赖可以查看链路中服务的依赖关系。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mrhelloworld.com/resources/articles/spring/spring-cloud/sleuth/image-20200208195125216.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　Zipkin Server 默认存储追踪数据至内存中，这种方式并不适合生产环境，一旦 Server 关闭重启或者服务崩溃，就会导致历史数据消失。Zipkin 支持修改存储策略使用其他存储组件，支持 MySQL，Elasticsearch 等。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;下一篇我们讲解 Sleuth 基于 Zipkin 存储链路追踪数据至 MySQL，Elasticsearch 以及使用 MQ 存储链路追踪数据至 MySQL，Elasticsearch，记得关注噢～&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://mrhelloworld.com/resources/articles/articles_bottom/end02.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　本文采用 &lt;a href=&quot;http://creativecommons.org/licenses/by-nc-nd/4.0/&quot; target=&quot;_blank&quot;&gt;&lt;code&gt;知识共享「署名-非商业性使用-禁止演绎 4.0 国际」许可协议&lt;/code&gt;&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;　　大家可以通过 &lt;a href=&quot;https://mrhelloworld.com/categories&quot; target=&quot;_blank&quot;&gt;&lt;code&gt;分类&lt;/code&gt;&lt;/a&gt; 查看更多关于 &lt;a href=&quot;https://mrhelloworld.com/categories/spring-cloud&quot; target=&quot;_blank&quot;&gt;&lt;code&gt;Spring Cloud&lt;/code&gt;&lt;/a&gt; 的文章。&lt;/p&gt;

&lt;p&gt;　　🤗 您的&lt;code&gt;点赞&lt;/code&gt;和&lt;code&gt;转发&lt;/code&gt;是对我最大的支持。&lt;/p&gt;
&lt;p&gt;　　📢 扫码关注 &lt;code&gt;哈喽沃德先生&lt;/code&gt;「文档 + 视频」每篇文章都配有专门视频讲解，学习更轻松噢 ~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mrhelloworld.com/resources/mrhelloworld/qrcode/OfficialAccounts500-500.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pic3.zhimg.com/80/v2-51a1c9ad66e46b45291744209d6e2c62_720w.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 27 Apr 2020 00:51:00 +0000</pubDate>
<dc:creator>哈喽沃德先生</dc:creator>
<og:description>随着微服务架构的流行，服务按照不同的维度进行拆分，一次请求往往需要涉及到多个服务。互联网应用构建在不同的软件模块集上，这些软件模块，有可能是由不同的团队开发、可能使用不同的编程语言来实现、有可能布在了</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mrhelloworld/p/sleuth1.html</dc:identifier>
</item>
<item>
<title>GitHub 热点速览 Vol.17：在？各家视频会员要不要？ - 削微寒</title>
<link>http://www.cnblogs.com/xueweihan/p/12783161.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xueweihan/p/12783161.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202004/759200-20200426230443599-1367729578.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;作者：HelloGitHub-&lt;strong&gt;小鱼干&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;摘要：经济实用，用作上周的 GitHub 热点的横批再合适不过。先不说 GitHub Trending 上不止一个的会员共享项目，免你找好友刷脸要会员，这项目实在太好用。也不说 TIL 利用你碎片化时间学习编程技术的项目，光是本周在 GitHub Trending 占有一席之地全靠实用的初学者实用项——CPlusPlusThings（该项目也被收录在 HelloGitHub 第 47 期月刊）打破 “C++ 不上” Trending 的魔咒，都说明了：实用、好用才是王道。当然说到实用，怎么能少了日常生活中高频使用的图片处理工具呢？本周热点主题收录了实用典范的抠图项，也有头像卡通花的 photo2cartoon。工具提升了我们的效率，同样的 CSS 框架 tailwindcss 也提升了前端开发者制作网站的效率。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以下内容摘录自微博&lt;a href=&quot;https://www.weibo.com/hellogithub/&quot;&gt;@HelloGitHub&lt;/a&gt; 的 GitHub Trending，选项标准：&lt;code&gt;新发布&lt;/code&gt; | &lt;code&gt;实用&lt;/code&gt; | &lt;code&gt;有趣&lt;/code&gt;，根据项目 release 时间分类，发布时间超过 30 天的项目一律称之为成熟稳重老项目，由于文章篇幅问题还有部分项目未能在本文展示，望周知 🌝&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;本文目录
&lt;ul&gt;&lt;li&gt;
&lt;ol&gt;&lt;li&gt;可怕 GitHub 新生&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;1.1 Bash 教程：bash-tutorial&lt;/li&gt;
&lt;li&gt;1.2 AI 外挂：PyBoy&lt;/li&gt;
&lt;li&gt;1.3 Linux 神器：bashtop&lt;/li&gt;
&lt;li&gt;1.4 后台管理：gin-vue-admin&lt;/li&gt;
&lt;li&gt;1.5 会员共享：Baidu-XunleiVIP&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;尚能星否 GitHub 老项目&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;2.1 分布式数据库中间件：shardingsphere&lt;/li&gt;
&lt;li&gt;2.2 今天你学了吗：TIL&lt;/li&gt;
&lt;li&gt;2.3 5s 语音克隆：Real-Time-Voice-Cloning&lt;/li&gt;
&lt;li&gt;2.4 C++ 初学者：CPlusPlusThings&lt;/li&gt;
&lt;li&gt;2.5 摆脱 CSS：tailwindcss&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;本周 GitHub Trending #图片处理#主题的主力军&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;3.1 人人都是抠图师：Background-Matting&lt;/li&gt;
&lt;li&gt;3.2 3D 照片修复：3d-photo-inpainting&lt;/li&gt;
&lt;li&gt;3.3 人像卡通化 (Photo to Cartoon)：photo2cartoon&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;推荐阅读&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;1-可怕-github-新生&quot;&gt;1. 可怕 GitHub 新生&lt;/h2&gt;
&lt;h3 id=&quot;11-bash-教程：bash-tutorial&quot;&gt;1.1 Bash 教程：bash-tutorial&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：400+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本教程介绍 Linux 命令行 Bash 的基本用法和脚本编程。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/wangdoc/bash-tutorial&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;12-ai-外挂：pyboy&quot;&gt;1.2 AI 外挂：PyBoy&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：1650+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;PyBoy 是用 Python 编写的 Game Boy 模拟器。和普通的模拟器不同，你可以基于该项目提供的组件开发自己的 AI 机器人，像是一个“游戏外挂”帮你通关经典游戏，例如：超级马里奥。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/Baekalfen/PyBoy&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202004/759200-20200426230456603-1303373953.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;13-linux-神器：bashtop&quot;&gt;1.3 Linux 神器：bashtop&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：300+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;bashtop 是一个 Linux 资源监视器，显示处理器、内存、磁盘、网络和进程的使用情况和状态。特征：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;易于使用，带有受游戏启发的菜单系统&lt;/li&gt;
&lt;li&gt;快速响应的 UI，带有 UP，DOWN 键可进行过程选择&lt;/li&gt;
&lt;li&gt;显示所选进程的详细统计信息&lt;/li&gt;
&lt;li&gt;可过滤流程&lt;/li&gt;
&lt;li&gt;在排序选项之间轻松切换&lt;/li&gt;
&lt;li&gt;将 SIGTERM，SIGKILL，SIGINT 发送到选定的进程&lt;/li&gt;
&lt;li&gt;可更改所有配置文件选项的 UI 菜单&lt;/li&gt;
&lt;li&gt;自动缩放图显示网络使用情况&lt;/li&gt;
&lt;li&gt;菜单直接显示是否有新版本可用&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/aristocratos/bashtop&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202004/759200-20200426230508294-1651192490.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;14-后台管理：gin-vue-admin&quot;&gt;1.4 后台管理：gin-vue-admin&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：600+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;gin-vue-admin 是一个基于 gin + vue 搭建的后台管理系统框架，集成 jwt 鉴权、权限管理、动态路由、分页封装、多点登录拦截、资源权限、上传下载、代码生成器、表单生成器等基础功能。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/flipped-aurora/gin-vue-admin&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;15-baidu-xunleivip&quot;&gt;1.5 Baidu-XunleiVIP&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：1400+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;该项目收录了百度网盘超级会员，迅雷会员、爱奇艺会员账号。每日分享，还有优酷、腾讯、芒果等 VIP，以及，百度网盘（百度云）不限速工具分享。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/VIP-Share/Baidu-XunleiVIP&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;2-尚能星否-github-老项目&quot;&gt;2. 尚能星否 GitHub 老项目&lt;/h2&gt;
&lt;h3 id=&quot;21-分布式数据库中间件：shardingsphere&quot;&gt;2.1 分布式数据库中间件：shardingsphere&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：400+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ShardingSphere 是一套开源的分布式数据库中间件解决方案组成的生态圈，它由 Sharding-JDBC、Sharding-Proxy 和 Sharding-Sidecar（计划中）这 3 款相互独立的产品组成。 他们均提供标准化的数据分片、分布式事务和数据库治理功能，可适用于如 Java 同构、异构语言、云原生等各种多样化的应用场景。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/apache/shardingsphere&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202004/759200-20200426230519761-554756216.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;22-今天你学了吗：til&quot;&gt;2.2 今天你学了吗：TIL&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：1700+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;TIL，全名：Today I Learned，收录了作者在开发、学习过程中零碎的编程技巧，包括：Chrome、CSS、运维、Git、GO 等等知识，如果你想利用碎片化的时间提高编程技术，不妨 🐎 下这个项目。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/jbranchaud/til&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;23-5s-语音克隆：real-time-voice-cloning&quot;&gt;2.3 5s 语音克隆：Real-Time-Voice-Cloning&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：1400+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Real-Time-Voice-Cloning 是一个可以在 5s 内克隆语音生成任意 一段语音的工具。项目基于 SV2TTS 这个三阶段的深度学习框架实现，它允许从几秒钟的音频中创建语音的数字表示，并使用它来调节经过训练的文本到语音模型，以推广到新的语音。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/CorentinJ/Real-Time-Voice-Cloning&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;24-c-初学者：cplusplusthings&quot;&gt;2.4 C++ 初学者：CPlusPlusThings&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：500+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这是一个适合初学者从入门到进阶的仓库，解决了面试者与学习者想要深入 C++ 及如何入坑 C++ 的问题。除此之外，本仓库拓展了更加深入的源码分析，多线程并发等的知识，是一个比较全面的 C++ 学习从入门到进阶提升的仓库。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/Light-City/CPlusPlusThings&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;25-摆脱-css：tailwindcss&quot;&gt;2.5 摆脱 CSS：tailwindcss&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：400+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Tailwind 是一款帮你摆脱 CSS，定制网站的 CSS 框架，它可帮助前端提升开发效率，便捷地修改样式和做自适应。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/tailwindcss/tailwindcss&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202004/759200-20200426230530994-1698354525.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;3-本周-github-trending-图片处理主题的主力军&quot;&gt;3. 本周 GitHub Trending #图片处理#主题的主力军&lt;/h2&gt;
&lt;p&gt;照片好看，3 分靠拍摄，7 分靠处理，本周小鱼干帮你从 GitHub Trending 中选了 3 个图片处理工具，可帮你一条龙完成抠图、二次处理、修复等操作。&lt;/p&gt;
&lt;h3 id=&quot;31-人人都是抠图师：background-matting&quot;&gt;3.1 人人都是抠图师：Background-Matting&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：600+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;图片背景处理器：Background-Matting 是一个基于背景抠图的工具，正如它的 slogan：The World is Your Green Screen 所说，只要你用 Background-Matting 即使你不会 ps 抠图，推理代码可以帮你更换图片中的背景。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/senguptaumd/Background-Matting&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202004/759200-20200426230541802-1991875777.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;32-3d-照片修复：3d-photo-inpainting&quot;&gt;3.2 3D 照片修复：3d-photo-inpainting&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：250+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;3d-photo-inpainting 是一种将单个 RGB-D 输入图像转换为 3D 照片的方法，即这是一种新的视图合成的多层表示，其中包含了原始视图中被遮挡区域的幻觉颜色和深度结构。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/vt-vl-lab/3d-photo-inpainting&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202004/759200-20200426230551670-716078268.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;33-人像卡通化-photo-to-cartoon：photo2cartoon&quot;&gt;3.3 人像卡通化 (Photo to Cartoon)：photo2cartoon&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：500+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;photo2cartoon 是一个人像卡通化探索项目。人像卡通风格渲染的目标是，在保持原图像 ID 信息和纹理细节的同时，将真实照片转换为卡通风格的非真实感图像。作者的思路是，从大量照片/卡通数据中习得照片到卡通画的映射。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/minivision-ai/photo2cartoon&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202004/759200-20200426230559775-1775707530.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;推荐阅读&quot;&gt;推荐阅读&lt;/h2&gt;
&lt;p&gt;以上为 2020 年第 17 个工作周的 GitHub Trending 🎉如果你 Pick 其他好玩、实用的 GitHub 项目，记得来 HelloGitHub issue 区和我们分享下哟 🌝&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;HelloGitHub 交流群现已全面开放，添加微信号：HelloGitHub 为好友入群，可同前端、Java、Go 等各界大佬谈笑风生、切磋技术~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202004/759200-20200406212426655-796625417.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 27 Apr 2020 00:31:00 +0000</pubDate>
<dc:creator>削微寒</dc:creator>
<og:description>作者：HelloGitHub 小鱼干 摘要：经济实用，用作上周的 GitHub 热点的横批再合适不过。先不说 GitHub Trending 上不止一个的会员共享项目，免你找好友刷脸要会员，这项目实在</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xueweihan/p/12783161.html</dc:identifier>
</item>
<item>
<title>用long类型让我出了次生产事故，写代码还是要小心点 - 一线码农</title>
<link>http://www.cnblogs.com/huangxincheng/p/12784230.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huangxincheng/p/12784230.html</guid>
<description>&lt;p&gt;昨天发现线上试跑期的一个程序挂了，平时都跑的好好的，查了下日志是因为昨天运营跑了一家美妆top级淘品牌店，会员量近千万，一下子就把128G的内存给爆了，当时并行跑了二个任务，没辙先速写一段代码限流，后面再做进一步优化。&lt;/p&gt;

&lt;h2 id=&quot;1-背景介绍&quot;&gt;1. 背景介绍&lt;/h2&gt;
&lt;p&gt;因为是自己写的代码，所以我知道问题出现在哪里，如果大家看过我之前写的文章应该知道我用全内存跑了很多模型对用户打标签，一个模型就是一组定向的筛选条件，而为了加速处理，我会原子化筛选条件，然后一边查询一边缓存原子化条件获取的人数，后面的模型如果命中了前面模型的原子化条件，那么可以直接从缓存中读取它的人数即可，这也是动态规划的思想~ ,如果不明白我来画张图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://huangxincheng.oss-cn-hangzhou.aliyuncs.com/img/20200426222550.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上面图可以看到，在计算模型2的时候，条件1的人数可以直接从模型1下的条件1处获取，模型三下的2，5的人数也可以直接从模型1和2处获取，这样就大大加速的处理速度。&lt;/p&gt;
&lt;h2 id=&quot;2-找原因&quot;&gt;2. 找原因&lt;/h2&gt;
&lt;p&gt;刚才提到了缓存人数，我也不知道为什么用了这么一个类型,如下代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;        /// &amp;lt;summary&amp;gt;
        /// 缓存原子人群
        /// key: 原子化条件
        /// value: 人数集合
        /// &amp;lt;/summary&amp;gt;
        public ConcurrentDictionary&amp;lt;string, List&amp;lt;long&amp;gt;&amp;gt; CachedCrowds { get; set; } = new ConcurrentDictionary&amp;lt;string, List&amp;lt;long&amp;gt;&amp;gt;();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我说的是里面的List&amp;lt;long&amp;gt;,我居然用了long类型存储customerID，可能是看了这个项目先祖原先定义的long才跟风成long，😄😄😄，谁家店有数不尽的客户，国家才14亿人呢，而一个long占用8个字节，明显是一种浪费。&lt;/p&gt;

&lt;h2 id=&quot;1-将long转成int&quot;&gt;1. 将long转成int&lt;/h2&gt;
&lt;p&gt;人都是懒的，能少改点代码就少改点，省的背锅，好事不出门，坏事传千里，所以这里用int表示就足够了，应该能省一半的空间对不对，接下来为了演示，在List&amp;lt;long&amp;gt; 和 List&amp;lt;int&amp;gt; 中分别灌入 500w 客户ID，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;
        public static void Main(string[] args)
        {
            var rand = new Random();

            List&amp;lt;int&amp;gt; intCustomerIDList = Enumerable.Range(1, 5000000).OrderBy(m =&amp;gt; rand.Next(0, 100000))
                                                  .Take(5000000).ToList();

            List&amp;lt;long&amp;gt; longCustomerIDList = Enumerable.Range(1, 5000000).OrderBy(m =&amp;gt; rand.Next(0, 100000))
                                                  .Take(5000000).Select(m =&amp;gt; (long)m).ToList();

            Console.WriteLine(&quot;处理完毕...&quot;);
            Console.Read();
        }

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来用windbg看一下他们在堆中各占多少内存。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;~0s -&amp;gt; !clrstack -l -&amp;gt; !dumpobj 从主线程找到List&amp;lt;int&amp;gt;和List&amp;lt;long&amp;gt; 的局部变量，然后查看size。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;
0:000&amp;gt; ~0s
ntdll!ZwReadFile+0x14:
00007ff8`fea4aa64 c3              ret
0:000&amp;gt; !clrstack -l
OS Thread Id: 0x5b70 (0)
        Child SP               IP Call Site
00000015c37feed0 00007ff889e60b9c ConsoleApp2.Program.Main(System.String[]) [C:\dream\Csharp\ConsoleApp1\ConsoleApp2\Program.cs @ 35]
    LOCALS:
        0x00000015c37fef90 = 0x0000014ad7c12d88
        0x00000015c37fef88 = 0x0000014ad7c13060
        0x00000015c37fef80 = 0x0000014ad7c33438

00000015c37ff1a8 00007ff8e9396c93 [GCFrame: 00000015c37ff1a8] 
0:000&amp;gt; !do 0x0000014ad7c13060
Name:        System.Collections.Generic.List`1[[System.Int32, mscorlib]]
MethodTable: 00007ff8e7aaa068
EEClass:     00007ff8e7c0b008
Size:        40(0x28) bytes
File:        C:\WINDOWS\Microsoft.Net\assembly\GAC_64\mscorlib\v4.0_4.0.0.0__b77a5c561934e089\mscorlib.dll
Fields:
              MT    Field   Offset                 Type VT     Attr            Value Name
00007ff8e7a98538  400189e        8       System.Int32[]  0 instance 0000014af02d1020 _items
00007ff8e7a985a0  400189f       18         System.Int32  1 instance          5000000 _size
00007ff8e7a985a0  40018a0       1c         System.Int32  1 instance          5000000 _version
00007ff8e7a95dd8  40018a1       10        System.Object  0 instance 0000000000000000 _syncRoot
00007ff8e7a98538  40018a2        0       System.Int32[]  0   shared           static _emptyArray
                                 &amp;gt;&amp;gt; Domain:Value dynamic statics NYI 0000014ad61166c0:NotInit  &amp;lt;&amp;lt;
0:000&amp;gt; !do 0000014af02d1020
Name:        System.Int32[]
MethodTable: 00007ff8e7a98538
EEClass:     00007ff8e7c05918
Size:        33554456(0x2000018) bytes
Array:       Rank 1, Number of elements 8388608, Type Int32 (Print Array)
Fields:
None

0:000&amp;gt; !do  0x0000014ad7c33438
Name:        System.Collections.Generic.List`1[[System.Int64, mscorlib]]
MethodTable: 00007ff8e7aad2a0
EEClass:     00007ff8e7c0bd70
Size:        40(0x28) bytes
File:        C:\WINDOWS\Microsoft.Net\assembly\GAC_64\mscorlib\v4.0_4.0.0.0__b77a5c561934e089\mscorlib.dll
Fields:
              MT    Field   Offset                 Type VT     Attr            Value Name
00007ff8e7aa6c08  400189e        8       System.Int64[]  0 instance 0000014a80001020 _items
00007ff8e7a985a0  400189f       18         System.Int32  1 instance          5000000 _size
00007ff8e7a985a0  40018a0       1c         System.Int32  1 instance          5000000 _version
00007ff8e7a95dd8  40018a1       10        System.Object  0 instance 0000000000000000 _syncRoot
00007ff8e7aa6c08  40018a2        0       System.Int64[]  0   shared           static _emptyArray
                                 &amp;gt;&amp;gt; Domain:Value dynamic statics NYI 0000014ad61166c0:NotInit  &amp;lt;&amp;lt;
0:000&amp;gt; !do 0000014a80001020
Name:        System.Int64[]
MethodTable: 00007ff8e7aa6c08
EEClass:     00007ff8e7c09e50
Size:        67108888(0x4000018) bytes
Array:       Rank 1, Number of elements 8388608, Type Int64 (Print Array)
Fields:
None


&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;仔细看上图，在主线程的堆栈中找到了三个变量，后两个变量就是我们的List&amp;lt;int&amp;gt; 和 List&amp;lt;long&amp;gt;,分别是&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Size: 33554456(0x2000018) bytes&lt;/code&gt; =&amp;gt; &lt;code&gt;33554456/1024/1024 = 32M&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Size:67108888(0x4000018) bytes&lt;/code&gt; =&amp;gt; &lt;code&gt;67108888/1024/1024 = 64M&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;以后可以跟别人吹牛了，我知道500w个int占用是32M内存，虽然内存空间优化了一半，但没有本质性的优化，还得继续往上挖，否则同时跑4个任务又要把内存给爆掉了。。。&lt;/p&gt;
&lt;h2 id=&quot;2-使用bitarray&quot;&gt;2. 使用bitarray&lt;/h2&gt;
&lt;p&gt;我们在学习数据结构的时候，相信很多人都学习过bitmap，刚好原子化的筛选条件获取的人数众多，使用bitmap刚好满足我的业务需求，如果不知道bitmap我简单解释一下。&lt;/p&gt;
&lt;h3 id=&quot;1-原理解释&quot;&gt;&amp;lt;1&amp;gt; 原理解释&lt;/h3&gt;
&lt;p&gt;我们都知道一个int是4个字节。也就是4byte，也就是32bit，画成图就是32个格子，如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://huangxincheng.oss-cn-hangzhou.aliyuncs.com/img/20200426232315.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;默认情况下32个格子表示一个int是不是有点浪费，其实32个格子可以放置32个数字(1-32)。比如1放在第一个格子里，3放在第三个格子里。。。32放在第32个格子里，那么两个int就可以存放1-64个数字，也就是说理想情况下可以优化空间32倍，思维一定要反转一下，把数字作为数组的下标，因为是bit，所以0，1两种状态刚好可以表示当前格子是否已经被设置了，1表示已设置，0表示未设置，好好品味一下，如果还是不明白，可以参考我八年前的文章：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/huangxincheng/archive/2012/12/06/2804756.html&quot;&gt;经典算法题每日演练——第十一题 Bitmap算法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在C#中已经帮我们设置好了一个BitArray类，结合我刚才讲得，大家好好品味一下bitarray如何向各自格子中设置值的，底层还是用m_array承载，它其实是一个int[]。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;
public void Set(int index, bool value)
{
        if (value)
        {
                m_array[index / 32] |= 1 &amp;lt;&amp;lt; index % 32;
        }
        else
        {
                m_array[index / 32] &amp;amp;= ~(1 &amp;lt;&amp;lt; index % 32);
        }
        _version++;
}

public bool Get(int index)
{
        return (m_array[index / 32] &amp;amp; (1 &amp;lt;&amp;lt; index % 32)) != 0;
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;2-查看内存占用&quot;&gt;&amp;lt;2&amp;gt; 查看内存占用&lt;/h3&gt;
&lt;p&gt;接下来把List&amp;lt;int&amp;gt; 中的数据灌入到bitArray中看看,先上一下代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;
        public static void Main(string[] args)
        {
            var rand = new Random();

            List&amp;lt;int&amp;gt; intCustomerIDList = Enumerable.Range(1, 5000000).OrderBy(m =&amp;gt; rand.Next(0, 100000))
                                                  .Take(5000000).ToList();

            BitArray bitArray = new BitArray(intCustomerIDList.Max() + 1);

            foreach (var customerID in intCustomerIDList)
            {
                bitArray[customerID] = true;
            }

            Console.WriteLine(&quot;处理完毕...&quot;);
            Console.Read();
        }

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后抓一下dump文件，用windbg看一下内存占用。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;
0:000&amp;gt; !do 0x0000026e4d0332b8
Name:        System.Collections.BitArray
MethodTable: 00007ff8e7a89220
EEClass:     00007ff8e7c01bc0
Size:        40(0x28) bytes
File:        C:\WINDOWS\Microsoft.Net\assembly\GAC_64\mscorlib\v4.0_4.0.0.0__b77a5c561934e089\mscorlib.dll
Fields:
              MT    Field   Offset                 Type VT     Attr            Value Name
00007ff8e7a98538  4001810        8       System.Int32[]  0 instance 0000026e5dfd9bd8 m_array
00007ff8e7a985a0  4001811       18         System.Int32  1 instance          5000001 m_length
00007ff8e7a985a0  4001812       1c         System.Int32  1 instance          5000000 _version
00007ff8e7a95dd8  4001813       10        System.Object  0 instance 0000000000000000 _syncRoot
0:000&amp;gt; !DumpObj /d 0000026e5dfd9bd8
Name:        System.Int32[]
MethodTable: 00007ff8e7a98538
EEClass:     00007ff8e7c05918
Size:        625028(0x98984) bytes
Array:       Rank 1, Number of elements 156251, Type Int32 (Print Array)
Fields:
None

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从图中可以看到，没错，就是bitArray类型，从Size中可以看到：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Size: 625028(0x98984) bytes&lt;/code&gt; =&amp;gt; &lt;code&gt;625028/1024/1024 = 0.59M&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;看到没有，这个就🐮👃了，由最初的64M优化到了0.6M，简直不要太爽，看到这么小的占用量，我感到枯燥而乏味，哈哈，这下并行跑几十家不怕了，这里要提醒一下，如果客户数少并且数字还大,就不要用bitArray啦，反而浪费空间，当然数据量小怎么用也无所谓。&lt;/p&gt;

&lt;p&gt;跑小店铺的时候代码怎么写都行，数据量大了到处都是坑，你的场景也总有优化的办法~&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;如您有更多问题与我互动，扫描下方进来吧&quot;&gt;如您有更多问题与我互动，扫描下方进来吧~&lt;/h3&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/huangxincheng/345039/o_200414062434170x170.jpg&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/huangxincheng/345039/o_200414065053baijiahao.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 26 Apr 2020 23:41:00 +0000</pubDate>
<dc:creator>一线码农</dc:creator>
<og:description>昨天发现线上试跑期的一个程序挂了，平时都跑的好好的，查了下日志是因为昨天运营跑了一家美妆top级淘品牌店，会员量近千万，一下子就把128G的内存给爆了，当时并行跑了二个任务，没辙先速写一段代码限流，后</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/huangxincheng/p/12784230.html</dc:identifier>
</item>
<item>
<title>[WPF] 考古Expression Web：微软当年最漂亮的WPF软件 - dino.c</title>
<link>http://www.cnblogs.com/dino623/p/Expression_Web.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dino623/p/Expression_Web.html</guid>
<description>&lt;h2 id=&quot;1-什么是expression-web&quot;&gt;1. 什么是Expression Web&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/38937/202004/38937-20200413223028642-1483530606.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Expression Studio是微软在2007年推出的一套针对设计师的套件，其中包含专业的设计工具和新技术，可以弹性且自由地将设计方案转为实际——无论设计的是标准的网站、拥有丰富用户经验的桌面应用，或是管理数字资产和内容。它包含以下部分：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Expression Blend 4 + SketchFlow&lt;/li&gt;
&lt;li&gt;Expression Web 4 + SuperPreview&lt;/li&gt;
&lt;li&gt;Exression Design 4&lt;/li&gt;
&lt;li&gt;Expression Encoder Pro&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;具体信息可以参考这里：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/jv9/archive/2010/06/08/1753638.html&quot;&gt;Expression Studio 4正式版发布 - jv9 - 博客园&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://baike.baidu.com/item/Expression%20Studio/4510198?fr=aladdin&quot;&gt;Expression Studio_百度百科&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;其中，Expression Web 是一个专业的设计工具，可用来建立现代感十足、且以标准为基础的网站，让您在 Web 上提供绝佳的质量。 透过使用强大的设计工具和工作窗格快速地合并 XML 数据，减少复杂度和简化数据整合。&lt;br/&gt;透过 Expression Web 和 Visual Studio 对于 XML、ASP.NET 和 XHTML 的绝佳支持，您可以顺畅地整合 Web 设计和开发团队。 透过复杂的 CSS 设计功能，释放您的创意点子，并替您的网站注入活力。可视化的设计工具、专门的工作窗格和工具列，让您精确地控制版面配置和格式。&lt;/p&gt;
&lt;p&gt;具体信息可以参考这里：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://baike.baidu.com/item/Expression%20Web/10960674?fr=aladdin&quot;&gt;Expression Web_百度百科&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可是Expression这个品牌十分短命，5年后就被微软放弃了，只剩下被整合进Visual Studio的Blend，具体可见当时的报道：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://livesino.net/archives/4935.live&quot;&gt;微软终止 Web、设计和媒体工具 Expression 套件，Web 和 Design 免费提供下载&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.ithome.com/html/it/33312.htm&quot;&gt;微软又嫌弃品牌多了，悄然砍掉Expression软件品牌&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;2-为什么是expression-web&quot;&gt;2. 为什么是Expression Web&lt;/h2&gt;
&lt;p&gt;最近打算写Blend的博客，突然来了兴致想看看很久没用过的Expression Studio，因为Expression Studio中的其它几个（Design，Encode）这两年时不时都还会用一下，所以就拿Web来怀旧。&lt;/p&gt;
&lt;p&gt;这篇文章为什么分类为WPF？因为Expression Studio的剩余价值不在于它开发Web的功能，而在于它本身是一个有趣WPF软件。&lt;/p&gt;
&lt;h2 id=&quot;3-expression-web的功能&quot;&gt;3. Expression Web的功能&lt;/h2&gt;
&lt;p&gt;最新版的Web可以在以下地址下载：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.microsoft.com/en-us/download/details.aspx?id=36179&quot;&gt;Download Microsoft Expression Web 4 (Free Version) from Official Microsoft Download Center&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/38937/202004/38937-20200413223052128-638497814.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/38937/202004/38937-20200413223056953-948111411.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;安装画面即使现在看来也还是很漂亮，好歹当年是主打设计功能的软件，它本身的设计也不能差。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/38937/202004/38937-20200413223202365-1438844948.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;安装完后在“About”窗口可以看到最后更新是2012年。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/38937/202004/38937-20200413223214195-1301159432.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这就是它的主界面，除了常用的Web设计功能，有两个功能我印象深刻，其中一个就是上图的Interactive Buttons，可以创建多个样式的按钮，并提供了这些按钮的图片。在当年我常常把这些图片拿去Silverlight上用。后来我写XAML越来越熟练，反而越来越觉得系统中的按钮应该越简洁越好，就再也不使用这种图片按钮了。&lt;/p&gt;
&lt;p&gt;另一个印象深刻的功能是Microsoft Expression Web SuperPreview，它是微软发布的最好的IE调试工具，它可以让我们在各个版本 IE 浏览器下调试网站，使得网站在各个版本 IE 浏览器下兼容。在当时IE占有率有绝对优势的时候，说它是微软发布的最好的浏览器调试工具也不为过。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/38937/202004/38937-20200413223238817-1128715962.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可是毕竟年代久远，在我的Windows 10电脑上已经运行不了IE6的部分，或许Windows 7 还可以试试吧。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/38937/202004/38937-20200413223245442-1641393244.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;4-web的遗产&quot;&gt;4. Web的遗产&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/38937/202004/38937-20200413223256512-1590594630.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面是正在被Visual Stuido 2019调试的Expression Web。在当时Expression Studio是微软发布的最漂亮的WPF软件，连右键菜单都经过精心设计，即使现在看来都很时髦（设计潮流又轮回了一次，最近微软又重新喜欢上了下面这种圆角设计）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/38937/202004/38937-20200413223309609-2046219424.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Web运行速度也很快，整体UI十分流畅。既然已经不更新了，开源才是它们最好的归宿，毕竟现在很多WPF软件做得还不如当年的微Expression Studio，可惜微软完全没这个打算。如果有兴趣的话可以反编译抄抄它的控件，其实很久以前已经有人做过这方面的工作，例如这个项目：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/DanPristupov/WpfExpressionBlendTheme&quot;&gt;WpfExpressionBlendTheme: A WPF theme which will make an application look like Expression Blend.&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;5-结语&quot;&gt;5. 结语&lt;/h2&gt;
&lt;p&gt;很多年前我还偶尔会用用Expression Web，前同事的设计师当年也常常夸Web好看又好用。另一个软件Design也很好用（10年前），有趣的是它的配色和最新的Adobe Illustrator 2020还很像，可以说微软难得前卫了一次：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/38937/202004/38937-20200413223317643-570814973.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/38937/202004/38937-20200413223323622-1598861737.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 26 Apr 2020 16:42:00 +0000</pubDate>
<dc:creator>dino.c</dc:creator>
<og:description>1. 什么是Expression Web Expression Studio是微软在2007年推出的一套针对设计师的套件，其中包含专业的设计工具和新技术，可以弹性且自由地将设计方案转为实际——无论设计</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/dino623/p/Expression_Web.html</dc:identifier>
</item>
<item>
<title>基于 HTML WebGL 的会展中心智能监控系统 - xhload3d</title>
<link>http://www.cnblogs.com/xhload3d/p/12769133.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xhload3d/p/12769133.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;随着近几年物联网、万物互联等诸多概念的大行其道，智慧城市的概念也早已经被人们耳熟能详，而作为城市的组成部分，&lt;strong&gt;智慧建筑&lt;/strong&gt;也是重中之重，智慧园区，智慧小区等也如雨后春笋般的相继出现。&lt;/p&gt;
&lt;p&gt;智慧建筑是指通过将建筑物的结构、系统、服务和管理根据用户的需求进行最优化组合，从而为用户提供一个高效、舒适、便利的人性化建筑环境，智慧建筑绝不仅仅只是智慧园区、智慧小区这种模式，这里我就通过 &lt;strong&gt;HT for Web&lt;/strong&gt; 制作了一个以&lt;strong&gt;会展中心&lt;/strong&gt;为主体的智慧建筑监控系统。&lt;/p&gt;
&lt;h2 id=&quot;效果预览&quot;&gt;&lt;strong&gt;效果预览&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496396/202004/1496396-20200421150139363-345431036.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496396/202004/1496396-20200421150159057-980567122.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496396/202004/1496396-20200421150215967-1063111252.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;代码实现&quot;&gt;&lt;strong&gt;代码实现&lt;/strong&gt;&lt;/h2&gt;
&lt;h3 id=&quot;场景呈现&quot;&gt;&lt;strong&gt;场景呈现&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;通过上面的效果预览，可以分辨出整个监控系统是分为 3 个层次的，分别是主体、楼内、展厅，如果是使用单个 &lt;code&gt;graph3dView&lt;/code&gt; 加载所有场景，通过 &lt;code&gt;dm.clear()&lt;/code&gt; 清除场景，&lt;code&gt;dm.deserieialize()&lt;/code&gt; 加载新场景这种切换方式必然会有一个极短的渲染时间，使切换时不连贯，所以我这里就使用了 3 个 &lt;code&gt;graph3dView&lt;/code&gt; ，去呈现各自的层级模型，通过 &lt;code&gt;notifier&lt;/code&gt; 事件通知器监听场景切换，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;notifier.add((event) =&amp;gt; {
    if (event.kind === 'sceneChange') {
        const oldSceneKey = event.oldScene,
            newSceneKey = event.newScene,
            oldScene = G[oldSceneKey],
            newScene = G[newSceneKey];

        oldScene.removeFromDOM();

        newScene.addToDOM();

        if (newScene.graph2d.isAnimed) {
            newScene.graph3d.animByList();
        } else {
            newScene.graph3d.animByList(newScene.graph2d.animByList, newScene.graph2d);
        }

    }
});
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中 &lt;code&gt;removeFromDOM&lt;/code&gt; 是自行封装的一个方法&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;removeFromDOM() {
    const g3d = this.g3d,
        view = g3d.getView();

    if (view.remove) {
        view.remove()
    } else {
        view.parentNode.removeChild(view)
    }

    this.notifier.fire({
        kind: 'reset',
    });
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是这样还是有一个问题，&lt;code&gt;graph3dView&lt;/code&gt; 默认如果不放到页面中，场景中的 &lt;code&gt;obj&lt;/code&gt; 等模型相关资源是不会请求和渲染的，这样对性能是十分友好的，但是当我第一次切换场景时，还是会有短暂的请求和渲染时间，所以这里我需要对资源进行预加载。&lt;/p&gt;
&lt;h3 id=&quot;资源预加载&quot;&gt;&lt;strong&gt;资源预加载&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;这里我通过在 &lt;code&gt;body&lt;/code&gt; 中添加一个不在窗口展示的与窗口等宽高的 &lt;code&gt;div&lt;/code&gt; 元素，通过把当前不展示的 &lt;code&gt;graph3dView&lt;/code&gt; 放到其中触发对相应 &lt;code&gt;obj&lt;/code&gt; 等模型资源的请求和渲染，完成预加载，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;const preloadDiv = document.createElement('div');
preloadDiv.style.position = 'absolute';
preloadDiv.style.bottom = '100%';
preloadDiv.style.width = '100%';
preloadDiv.style.height = '100%';
document.body.appendChild(preloadDiv);

scene2.addToDOM(preloadDiv);
scene3.addToDOM(preloadDiv);

&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;模型加载完成后再执行动画&quot;&gt;&lt;strong&gt;模型加载完成后再执行动画&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496396/202004/1496396-20200421150254770-784559626.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;web 页面加载是依赖网速的，会展中心模型 &lt;code&gt;obj&lt;/code&gt; 等资源文件是有一定大小的，可能对于不同带宽网速的用户所需要加载的时间也不尽相同，这里就需要判断下 &lt;code&gt;obj&lt;/code&gt; 是否全部加载完成，加载完成后再执行动画效果，通过 &lt;code&gt;ht.Default.handleModelLoaded&lt;/code&gt; 监控是否所有&lt;strong&gt;模型&lt;/strong&gt;都请求加载完成, 加载完成后开始执行动画，顺便释放之前预加载的 &lt;code&gt;graph3dView&lt;/code&gt; ，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;let modelSize = 0;
ht.Default.handleModelLoaded = (name, model) =&amp;gt; {
    modelSize++;
    if (modelSize === 62) {
        scene1.graph3d.enableShadow();
        scene3.graph3d.enableShadow();
        scene2.removeFromDOM();
        scene3.removeFromDOM();
        scene1.graph3d.animByList(scene1.graph2d.animByList, scene1.graph2d);
    }
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;动画依参数顺序执行&quot;&gt;&lt;strong&gt;动画依参数顺序执行&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496396/202004/1496396-20200421150417374-439953310.gif&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496396/202004/1496396-20200421150431395-162765189.gif&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496396/202004/1496396-20200421150447867-784271161.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我想要场景第一次加载时，视角拉近后左右两边的面板再一点一点的加载出来，动画效果是不完全线性顺序的去执行，所以我这里通过 &lt;code&gt;ht.Default.startAnim&lt;/code&gt; 方法封装了一套通过参数数组进行的动画的方法，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;animByList(callback, obj) {
    this.isAnimed = true;
    const animList = this.animList,
        self = this;

    let callAnim = (ind) =&amp;gt; {
        const param = animList.get(ind);

        param &amp;amp;&amp;amp; self.anim(param, () =&amp;gt; {
            callAnim(ind + 1);
            const lastParam = animList.get(ind + 1);
            lastParam || callback &amp;amp;&amp;amp; callback.call(obj || this);
        });

    };

    callAnim(0);
}

anim(animParam, callback) {
    const self = this,
        time = animParam['time'] || 1000,
        easing = animParam['easing'] || function (t) {
            return t * t;
        },
        func = animParam['func'];

    this.__animObj = ht.Default.startAnim({
        duration: time || 1000, 
        easing: easing,
        action: function (v, t) {
            const V = v,
                T = t;

            function animFunc(param) {
                let v = V,
                    t = T;
                if (param instanceof Function) {
                    param(v, t);
                } else {
                    const type = param['type'],
                        object = param['object'],
                        objectTag = param['objectTag'],
                        key = param['key'],
                        oldValue = param['oldValue'],
                        newValue = param['newValue'],
                        oneTime = param['time'],
                        scope = param['scope'];

                    if (scope) {
                        v = v &amp;lt; scope[0] ? 0 : v &amp;gt; scope[1] ? 1 : (v - scope[0]) / (scope[1] - scope[0]);
                    } else {
                        v = !oneTime || oneTime &amp;gt; time ? v : v * time / oneTime &amp;lt; 1 ? v * time / oneTime : 1;
                    }

                    let obj, value;

                    obj = object ? object : objectTag ? self.view.dm().getDataByTag(objectTag) : undefined;

                    if (!obj) return;

                    if (!isSameType(oldValue, newValue) || !isNumORNumArray(oldValue)) return;

                    if (oldValue instanceof Array) {
                        if (oldValue.length !== newValue.length) return;
                        const darr = newValue.map((n, i) =&amp;gt; {
                            return n - oldValue[i];
                        });

                        value = oldValue.map((n, i) =&amp;gt; {
                            return n + darr[i] * v;
                        });
                    } else {
                        const d = newValue - oldValue;

                        value = oldValue + d * v;
                    }

                    ht.Default.setPropertyValue(obj, type, key, value);
                }
            }
            if (animParam instanceof Array) {
                animParam.forEach(ele =&amp;gt; {
                    animFunc(ele);
                });
            } else {
                animFunc(animParam);
            }
        },
        finishFunc: function () {
            func &amp;amp;&amp;amp; func(func);
            callback &amp;amp;&amp;amp; callback();
        },
    });
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参数格式如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;// 视角移动
param = {
    object: g3d,
    type: undefined,
    key: 'eye',
    oldValue:  [-118, 5130, 15858],
    newValue: [-26, 1130, 3494],
    time: 1000,
}
 animList.add();
// 标题从左到右出现
param = {
    object: title,
    type: 'style',
    key: 'clip.percentage',
    oldValue: 0,
    newValue: 1,
    time: 1500,
};
animList.add(param);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;可点击部分高亮效果&quot;&gt;&lt;strong&gt;可点击部分高亮效果&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;为了突出可以点击的部分，我加了高亮效果，设置鼠标悬浮高亮模式，并通过 &lt;code&gt;g3d.getHighlightHelper().setFetchTargetFunc&lt;/code&gt; 方式筛选需要鼠标高亮的图元，代码如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496396/202004/1496396-20200421150619483-539777579.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;g3d.setHighlightMode('mouseover');

g3d.getHighlightHelper().setFetchTargetFunc(function (nodes) {
    let sortList = new ht.List(nodes);
    return sortList.toArray(node =&amp;gt; {
        return jumpList.contains(node);
    });
});
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;楼层视角跳转&quot;&gt;&lt;strong&gt;楼层视角跳转&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;因为整体的楼层比较大，而每个楼层中可选择的展区又比较小，所以这里我做了一个视角调整，可以使用单独移动视角到正视相应楼层的视角 &lt;code&gt;flyTo&lt;/code&gt;，这里除了采用右侧边栏选中移动，也做了鼠标移入相应楼层右键改变视角的处理，使用了新建的类 &lt;code&gt;messageView&lt;/code&gt; 做交互提示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496396/202004/1496396-20200421150637570-607035870.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;g3d.flyTo(floor, {
    animation: true,
    direction: [0, 1, 2],
    center: floor.p3().map((n, i) =&amp;gt; {
        return i !==1 ? n : n + floor.getTall() / 2;
    }),
    distance: distances[newFloor - 1],
});
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;总结&quot;&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;随着科技的井喷式发展，智慧建筑将如雨后春笋般崛起，其应用的场景也会不断拓展，应运而生的数据可视化管理系统也应该配套升级，为其把数字信息变为直观的、以图形图像信息表示的信息，清晰的展现在客户的面前，这将是无可阻挡的时代大趋势。&lt;/p&gt;
&lt;p&gt;还有更多的可视化案例可以参考：&lt;a href=&quot;https://www.hightopo.com/demos/index.html&quot;&gt;https://www.hightopo.com/demos/index.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 26 Apr 2020 15:51:00 +0000</pubDate>
<dc:creator>xhload3d</dc:creator>
<og:description>前言 随着近几年物联网、万物互联等诸多概念的大行其道，智慧城市的概念也早已经被人们耳熟能详，而作为城市的组成部分， 智慧建筑 也是重中之重，智慧园区，智慧小区等也如雨后春笋般的相继出现。 智慧建筑是指</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xhload3d/p/12769133.html</dc:identifier>
</item>
<item>
<title>GraphicsLab Project 之 Curl Noise - i_dovelemon</title>
<link>http://www.cnblogs.com/idovelemon/p/12775127.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/idovelemon/p/12775127.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/619936/202004/619936-20200425203708642-1438426938.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;作者：i_dovelemon&lt;/p&gt;
&lt;p&gt;日期：2020-04-25&lt;/p&gt;
&lt;p&gt;主题：Perlin Noise, Curl Noise, Finite Difference Method&lt;/p&gt;


&lt;p&gt;        最近在研究流体效果相关的模拟。经过一番调查，发现很多的算法都基于一定的物理原理进行模拟，计算量相对来说都比较高昂。最终寻找到一个基于噪音实现的，可在视觉上模拟流体效果的方法：Curl Noise。题图就是通过 Curl Noise 模拟的流体向量场控制的百万粒子的效果。&lt;/p&gt;


&lt;p&gt;        在讲解什么是 Curl Noise 之前，我们需要了解一些相关背景知识。&lt;/p&gt;

&lt;h2&gt;向量场（Vector Field）&lt;/h2&gt;
&lt;p&gt;        一个2D 或者 3D 的向量场，表示的是赋予空间中任意点一个 2D 或者 3D 向量的函数。公式表示如下所示：&lt;/p&gt;
&lt;p&gt;$\vec{F}\left(x,y \right)=P\left(x,y\right)\vec{i}+Q\left(x,y\right)\vec{j}$&lt;/p&gt;
&lt;p&gt;$\vec{F}\left(x,y,z \right)=P\left(x,y,z\right)\vec{i}+Q\left(x,y,z\right)\vec{j}+R\left(x,y,z\right)\vec{k}$&lt;/p&gt;
&lt;p&gt;        其中，$P$，$Q$，$R$ 各表示一个标量函数，即它们的返回值是一个标量；$\vec{i}$，$\vec{j}$，$\vec{k}$ 各表示一个基向量。（参考文献[1]）&lt;/p&gt;
&lt;p&gt;        上面数学的解释大家可能不熟悉，但是很多人或多或少的都看过向量场的图片形式，如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/619936/202004/619936-20200425220152165-757988081.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;散度和旋度（Curl and Divergence）&lt;/h2&gt;
&lt;p&gt;        首先，我们来定义一个 $\nabla$ 操作，如下所示：&lt;/p&gt;
&lt;p&gt;$\nabla=\frac{\partial }{\partial x}\vec{i}+\frac{\partial }{\partial y}\vec{j}+\frac{\partial }{\partial z}\vec{k}$&lt;/p&gt;
&lt;p&gt;        其中$\partial$表示的是偏导数符号，不熟悉的读者可以去复习下微积分或者参考文献[2]。有了这个操作符之后，我们定义旋度为：&lt;/p&gt;
&lt;p&gt;$curl\vec{F}=\nabla\times\vec{F}=(\frac{\partial R}{\partial y}-\frac{\partial Q}{\partial z},\frac{\partial P}{\partial z}-\frac{\partial R}{\partial x},\frac{\partial Q}{\partial x}-\frac{\partial P}{\partial y})$&lt;/p&gt;
&lt;p&gt;        其中$\times$为叉积操作符（参考文献[3]）。&lt;/p&gt;
&lt;p&gt;        有了旋度之后，我们再来定义散度，同样的，公式如下所示：&lt;/p&gt;
&lt;p&gt;$div\vec{F}=\nabla\cdot \vec{F}=\frac{\partial P}{\partial x}+\frac{\partial Q}{\partial y} + \frac{\partial R}{\partial z}$&lt;/p&gt;
&lt;p&gt;        特别的，散度和旋度之间有如下的一个关系：&lt;/p&gt;
&lt;p&gt;$div(curl\vec{F})=0$&lt;/p&gt;
&lt;p&gt;        以上内容，参考文献[4]。&lt;/p&gt;
&lt;p&gt;        根据上面的公式，我们可以知道，对于一个向量场的旋度场，它的散度为 0，即它是一个无源场（Divergence-Free）。而一个散度为 0 的向量场，表示这个场是不可压缩的流体，这对日常所见的流体来说是一个很重要的视觉性质，所以据此我们可以使用一个场的旋度场来模拟流体效果。&lt;/p&gt;


&lt;p&gt;        所谓 Curl Noise，即是对一个随机向量场，进行 Curl 操作之后得到的新场。因为满足散度为 0 的特性，所以这个场看上去就具有流体的视觉特性。如果用这个场作为速度去控制粒子，即可得到开头视频中流动的效果。&lt;/p&gt;

&lt;h2&gt;2D Curl Noise&lt;/h2&gt;
&lt;p&gt;        前面我们说过，需要一个随机的向量场。这里我们使用 Perlin Noise 来进行模拟，关于 Perlin Noise 网上一堆资料，这里就不再赘述。&lt;/p&gt;
&lt;p&gt;        我们假设 Perlin Noise 的函数为：&lt;/p&gt;
&lt;p&gt;$N(x,y)$&lt;/p&gt;
&lt;p&gt;        它的返回值是一个标量值。然后据此建立一个新的向量场：&lt;/p&gt;
&lt;p&gt;$\vec{F}(x,y) = (N(x,y), N(x,y))$&lt;/p&gt;
&lt;p&gt;        然后对这个新的向量场进行 Curl 操作，即可得到旋度场。&lt;/p&gt;
&lt;p&gt;        前面只说过 3D 情况下的 Curl 操作是怎么样的，这里给出 2D 版本的 Curl 操作：&lt;/p&gt;
&lt;p&gt;$curl\vec{F}(x, y) = (\frac{\partial N(x,y)}{\partial y}, -\frac{\partial N(x,y)}{\partial x})$&lt;/p&gt;
&lt;p&gt;        这里就只剩下了最后一个问题，那就是形如 $\frac{\partial N(x,y)}{\partial x}$ 这样的偏导数，该怎么计算。我们这里使用一个名为有限差分的方法(Finite Difference Method)来近似求解。&lt;/p&gt;

&lt;h3&gt;Finite Difference Method&lt;/h3&gt;
&lt;p&gt;        根据文献[2]中对于偏导数的描述，我们知道 $\frac{\partial N(x,y)}{\partial x}$ 只是一种表达方式，它的精确表示方法为：&lt;/p&gt;
&lt;p&gt;$\frac{\partial N(x,y)}{\partial x}= N_x(x,y) = \lim_{h\to0}{\frac{N(x + h,y)-N(x,y)}{h}}$&lt;/p&gt;
&lt;p&gt;        而后面极限的表达方式则给了我们近似计算这个偏导数的方法，只要给定一个较小的 $h$ 值，就能够近似的得到偏导数的结果。而这种计算方法即为：有限差分方法(Finite Difference Method)。&lt;/p&gt;
&lt;p&gt;        除了上面的极限表示方法之外，还有另外一种极限表示方法，如下所示：&lt;/p&gt;
&lt;p&gt;$\frac{\partial N(x,y)}{\partial x}= N_x(x,y) = \lim_{h\to0}{\frac{N(x,y)-N(x-h,y)}{h}}$&lt;/p&gt;
&lt;p&gt;        这两种差分方法分别称之为前向差分(Forward Difference)和逆向差分(Backward Difference)方法。我这里主要使用逆向差分方法。&lt;/p&gt;
&lt;p&gt;        有了计算偏导数的方法之后，我们就可以实际带到 2D Curl 操作的公式进行计算，如下是计算 2D Curl Noise 的伪代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
vec2 computeCurl(&lt;span&gt;float&lt;/span&gt; x, &lt;span&gt;float&lt;/span&gt;&lt;span&gt; y)
{
    &lt;/span&gt;&lt;span&gt;float&lt;/span&gt; h = &lt;span&gt;0.0001f&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;float&lt;/span&gt;&lt;span&gt; n, n1, n2, a, b;

    n &lt;/span&gt;=&lt;span&gt; N(x, y);
    n1 &lt;/span&gt;= N(x, y -&lt;span&gt; h);
    n2 &lt;/span&gt;= N(x -&lt;span&gt; h, y);
    a &lt;/span&gt;= (n - n1) /&lt;span&gt; h;
    b &lt;/span&gt;= (n - n2) /&lt;span&gt; h;

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; vec2(a, -&lt;span&gt;b);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;         知道怎么计算 2D Curl Noise 之后，我们用计算出来的 Curl Noise 作为速度场去控制粒子进行运动，如下是 2D Curl Noise 控制粒子运动的效果：&lt;/p&gt;


&lt;h2&gt;3D Curl Noise&lt;/h2&gt;
&lt;p&gt;        有了前面 2D Curl Noise 的实现，如法炮制的实现 3D Curl Noise 的推导。&lt;/p&gt;
&lt;p&gt;        3D Perlin Noise 函数定义为：&lt;/p&gt;
&lt;p&gt;$N(x,y,z)$&lt;/p&gt;
&lt;p&gt;        以此构造出来的 3D 向量场为：&lt;/p&gt;
&lt;p&gt;$\vec{F}(x,y,z)=(N(x,y,z),N(x,y,z)N(x,y,z))$&lt;/p&gt;
&lt;p&gt;        对这个场进行 Curl 操作，得到：&lt;/p&gt;
&lt;p&gt;$curl\vec{F}=(\frac{\partial N(x,y,z)}{\partial y}-\frac{\partial N(x,y,z)}{\partial z},\frac{\partial N(x,y,z)}{\partial z}-\frac{\partial N(x,y,z)}{\partial x},\frac{\partial N(x,y,z)}{\partial x}-\frac{\partial N(x,y,z)}{\partial y})$&lt;/p&gt;
&lt;p&gt;        据此，给出计算 3D Curl Noise 的伪代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
vec3 computeCurl(&lt;span&gt;float&lt;/span&gt; x, &lt;span&gt;float&lt;/span&gt;&lt;span&gt; y)
{
    vec3 curl;
    &lt;/span&gt;&lt;span&gt;float&lt;/span&gt; h = &lt;span&gt;0.0001f&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;float&lt;/span&gt;&lt;span&gt; n, n1, a, b;

    n &lt;/span&gt;=&lt;span&gt; N(x, y, z);

    n1 &lt;/span&gt;= N(x, y -&lt;span&gt; h, z);
    a &lt;/span&gt;= (n - n1) /&lt;span&gt; h;

    n1 &lt;/span&gt;= N(x, y, z -&lt;span&gt; h);
    b &lt;/span&gt;= (n - n1) /&lt;span&gt; h;
    curl.x &lt;/span&gt;= a -&lt;span&gt; b;

    n1 &lt;/span&gt;= N(x, y, z -&lt;span&gt; h);
    a &lt;/span&gt;= (n - n1) /&lt;span&gt; h;

    n1 &lt;/span&gt;= N(x -&lt;span&gt; h, y, z);
    b &lt;/span&gt;= (n - n1) /&lt;span&gt; h;
    curl.y &lt;/span&gt;= a -&lt;span&gt; b;

    n1 &lt;/span&gt;= N(x -&lt;span&gt; h, y, z);
    a &lt;/span&gt;= (n - n1) /&lt;span&gt; h;

    n1 &lt;/span&gt;= N(x, y -&lt;span&gt; h, z);
    b &lt;/span&gt;= (n - n1) /&lt;span&gt; h;
    curl.z &lt;/span&gt;= a -&lt;span&gt; b;

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; curl;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;        以下是根据得到的 3D Curl Noise，并一次控制粒子进行运动的效果：&lt;/p&gt;




&lt;p&gt;        Curl Noise 在游戏中有大量的运用，Unity 的粒子系统的 Noise Module 就内置了 Curl Noise 的实现。作为游戏开发的人员，很有必要了解下这个技术的原理，便于在实际开发中灵活运用。本文的主要原理来自于参考文献[5]，感兴趣的可以深入去了解。&lt;/p&gt;


&lt;p&gt;[1] &lt;a href=&quot;http://tutorial.math.lamar.edu/Classes/CalcIII/VectorFields.aspx&quot; target=&quot;_blank&quot;&gt;Section 5-1 : Vector Field&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[2] &lt;a href=&quot;http://tutorial.math.lamar.edu/Classes/CalcIII/PartialDerivatives.aspx&quot; target=&quot;_blank&quot;&gt;Section 2-2：Partial Derivatives&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[3] &lt;a href=&quot;http://tutorial.math.lamar.edu/Classes/CalcII/CrossProduct.aspx&quot; target=&quot;_blank&quot;&gt;Section 5-4：Cross Product&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[4] &lt;a href=&quot;http://tutorial.math.lamar.edu/Classes/CalcIII/CurlDivergence.aspx&quot; target=&quot;_blank&quot;&gt;Section 6-1：Curl And Divergence&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[5] &lt;a href=&quot;http://citeseer.ist.psu.edu/viewdoc/download;jsessionid=49DEC6DF2166469BCCBCFC31C31AB9B4?doi=10.1.1.93.3847&amp;amp;rep=rep1&amp;amp;type=pdf&quot; target=&quot;_blank&quot;&gt;Curl-Noise for Procedural Fluid Flow&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 26 Apr 2020 15:46:00 +0000</pubDate>
<dc:creator>i_dovelemon</dc:creator>
<og:description>作者：i_dovelemon 日期：2020-04-25 主题：Perlin Noise, Curl Noise, Finite Difference Method 引言 最近在研究流体效果相关的模拟</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/idovelemon/p/12775127.html</dc:identifier>
</item>
<item>
<title>python 异步Web框架sanic - 虫师</title>
<link>http://www.cnblogs.com/fnng/p/12783542.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fnng/p/12783542.html</guid>
<description>&lt;p&gt;我们继续学习Python异步编程，这里将介绍异步Web框架sanic，为什么不是tornado？从框架的易用性来说，Flask要远远比tornado简单，可惜flask不支持异步，而sanic就是类似Flask语法的异步框架。&lt;/p&gt;
&lt;p&gt;github：&lt;a href=&quot;https://github.com/huge-success/sanic&quot;&gt;https://github.com/huge-success/sanic&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;不过sanic对环境有要求：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;macOS/linux&lt;/li&gt;
&lt;li&gt;python 3.6+&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;不过，我在macOS上安装 sanic 还是踩了坑。依赖库&lt;code&gt;ujson&lt;/code&gt;一直安装失败。最后不得不卸载官方python，安装 miniconda（第三方Python安装包，集成了一些额外的工具）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;安装 sanic&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;&amp;gt; pip3 install sanic
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;sanic-开发第一个例子&quot;&gt;sanic 开发第一个例子&lt;/h2&gt;
&lt;p&gt;编写官方的第一个例子&lt;code&gt;hello.py&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-py&quot;&gt;from sanic import Sanic
from sanic.response import json
from sanic.exceptions import NotFound


app = Sanic(name=&quot;pyapp&quot;)

@app.route('/')
async def test(request):
    return json({'hello': 'world'})


if __name__ == '__main__':
    app.error_handler.add(
        NotFound,
        lambda r, e: sanic.response.empty(status=404)
    )
    app.run(host='0.0.0.0', port=8000)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行上面的程序：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;&amp;gt; python3 hello.py

[2020-04-21 23:12:02 +0800] [18487] [INFO] Goin Fast @ http://0.0.0.0:8000
[2020-04-21 23:12:02 +0800] [18487] [INFO] Starting worker [18487]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过浏览器访问:&lt;code&gt;http://localhost:8000/&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/311516/202004/311516-20200426233424199-1823572962.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;请求堵塞&quot;&gt;请求堵塞&lt;/h2&gt;
&lt;p&gt;针对上面的例子，假设&lt;code&gt;test()&lt;/code&gt; 视图函数的处理需要5秒钟，那么请求就堵塞了。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-py&quot;&gt;……

from time import sleep

app = Sanic(name=&quot;pyapp&quot;)

@app.route('/')
async def test(request):
    sleep(5)
    return json({'hello': 'world'})

……
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;重启服务，通过浏览器发送请求，我们发现请求耗时5秒，这显然对用户就不能忍受的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/311516/202004/311516-20200426233507541-170828431.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;异步非堵塞&quot;&gt;异步非堵塞&lt;/h2&gt;
&lt;p&gt;所以，我们要实现异步调用，修改后的完整代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-py&quot;&gt;import asyncio
from sanic import Sanic
from sanic.response import json
from sanic.exceptions import NotFound
from time import sleep, ctime

app = Sanic(name=&quot;pyapp&quot;)

async def task_sleep():
    print('sleep before', ctime())
    await asyncio.sleep(5)
    print('sleep after', ctime())


@app.route('/')
async def test(request):
    myLoop = request.app.loop
    myLoop.create_task(task_sleep())
    return json({'hello': 'world'})


if __name__ == '__main__':
    app.error_handler.add(
        NotFound,
        lambda r, e: sanic.response.empty(status=404)
    )
    app.run(host='0.0.0.0', port=8000)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;关于python异步的使用参考上一篇文章，重新启动服务。这次前端就不在堵塞了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/311516/202004/311516-20200426233521445-112558328.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果看 sanic 的运行日志：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;[2020-04-21 23:43:14 +0800] - (sanic.access)[INFO][127.0.0.1:57521]: GET http://localhost:8000/  200 17
sleep before Tue Apr 21 23:43:14 2020
sleep after Tue Apr 21 23:43:19 2020
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;他仍然在执行，但不会堵塞&lt;code&gt;test()&lt;/code&gt;视图函数的响应。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;思考：假如我的需求是：请求之后先告诉我已经处理了，然后默默的去处理，什么时候处理来再主动把处理的结果告诉。那么这就需要用到 websocket了。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sun, 26 Apr 2020 15:33:00 +0000</pubDate>
<dc:creator>虫师</dc:creator>
<og:description>python异步Web框架sanic</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/fnng/p/12783542.html</dc:identifier>
</item>
<item>
<title>基于两维语义的证据推理方法研究 - 郑瀚Andrew.Hann</title>
<link>http://www.cnblogs.com/LittleHann/p/12758954.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/LittleHann/p/12758954.html</guid>
<description>&lt;p&gt;由于问题的不同和证据处理人员知识背景及偏好的不同，同一个证据处理人员在对不同问题，不同的证据处理人员针对同一个问题，都可能构建多个不同的识别框架。这些识别框架中包含的元素的数目、元素含义等方面可能有所差异，识别框架之间的逻辑关系也可能不同。&lt;/p&gt;
&lt;p&gt;而证据推理方法需要在同一个识别框架下对多批证据进行融合，为此，需要对多个识别框架进行分类，并确定识别框架等价及其相互之间的转化方法。&lt;/p&gt;


&lt;h2&gt;&lt;span&gt;0x1：识别框架的分类&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;一般来说，&lt;strong&gt;识别框架的类型不同，信息处理方法也不同。每种识别框架就代表了一种看待目标对象的抽象视角。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;就单个识别框架来说，根据识别框架中元素的不同，可以将识别框架分为多种类型。&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;1、平行框架&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;设 Θ&lt;sub&gt;1&lt;/sub&gt;，Θ&lt;sub&gt;2&lt;/sub&gt;，.....，Θ&lt;sub&gt;n &lt;/sub&gt;为 n 个不同的识别框架，若这 n 个框架分别从不同的角度处理同一个问题，则称这 n 个框架为平行框架。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/532548/202004/532548-20200425192909340-163848646.png&quot; alt=&quot;&quot; width=&quot;260&quot; height=&quot;217&quot;/&gt;&lt;/p&gt;
&lt;p&gt;例如，在风险评估时，甲对某个指标比较熟悉，他对该指标所反映的风险程度构建识别框架：&lt;/p&gt;
&lt;p&gt;Θ&lt;sub&gt;甲&lt;/sub&gt; = {低、较低、中、较高、高} &lt;/p&gt;
&lt;p&gt;并给出了相应的信度函数。&lt;/p&gt;
&lt;p&gt;而乙对该指标的熟悉程度相对较弱，构建的风险程度识别框架为：&lt;/p&gt;
&lt;p&gt;Θ&lt;sub&gt;乙&lt;/sub&gt; = {低、中、高} &lt;/p&gt;
&lt;p&gt;也给出了相应的信度函数。&lt;/p&gt;
&lt;p&gt;可以看出，由于专家自身知识背景和个人偏好的不同，对同一个问题构造的识别框架也不同，此时的识别框架 Θ&lt;sub&gt;甲&lt;/sub&gt; 和 Θ&lt;sub&gt;乙&lt;/sub&gt; 为两个平行框架。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一般来说，平行框架是针对同一个问题不同方面，或不同信息源针对同一问题某个方面而构建的，其特性和概念是相容的，通常有公共的精细框架，故平行框架是相容框架&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;笔者思考&lt;/strong&gt;&lt;/span&gt;：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对于安全数据分析来说，一项基础工作就是所谓的日志采集，例如进程启动日志、进程网络外连日志、进程写文件日志、文件落盘日志。这些不同的日志代表了当前系统行为的一个描述切面。从识别框架的角度来看，基于不同的日志可以抽象为不同的离散状态集（集合中的每一个状态代表了一个系统状态描述）&lt;/strong&gt;。&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;2、递进框架&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;设 Θ&lt;sub&gt;1&lt;/sub&gt;，Θ&lt;sub&gt;2&lt;/sub&gt;，.....，Θ&lt;sub&gt;n &lt;/sub&gt;为 n 个不同的识别框架，若这 n 个框架中后一个识别框架中的元素用来修饰（说明）前一个识别框架中的元素。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第一层识别框架用于抽象描述待处理问题；&lt;/li&gt;
&lt;li&gt;第二层识别框架用于描述第一层识别框架的可信度；&lt;/li&gt;
&lt;li&gt;此后类推..&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;则称这 n 个框架为 n 维递进框架。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/532548/202004/532548-20200425195909523-243068723.png&quot; alt=&quot;&quot; width=&quot;337&quot; height=&quot;165&quot;/&gt;&lt;/p&gt;
&lt;p&gt;例如，在科学基金立项评审的同行评议表中，“综合评价”和“熟悉程度”可以看做一个两维递进识别框架。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;“综合评价”是第一层识别框架，Θ&lt;sub&gt;1&lt;/sub&gt; = {优、良、中、差} &lt;/li&gt;
&lt;li&gt;“熟悉程度”是第二层识别框架，Θ&lt;sub&gt;2&lt;/sub&gt;，用来修饰说明专家给出的“综合评价”的不确定程度 &lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;&lt;span&gt;3、混合框架&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;设 Θ&lt;sub&gt;1&lt;/sub&gt;，Θ&lt;sub&gt;2&lt;/sub&gt;，.....，Θ&lt;sub&gt;n &lt;/sub&gt;为 n 个不同的识别框架，若这 n 个框架中并列框架和递进框架并存，则称这 n 个框架为混合框架。&lt;/p&gt;
&lt;p&gt;例如，在科学基金立项评审的同行评议表中，“综合评价”、“资助意见”、“熟悉程度”三个框架本质上是一组混合框架，&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;“综合评价”、“资助意见”是两个平行框架&lt;/li&gt;
&lt;li&gt;“熟悉程度”是用来修饰“综合评价”和“资助意见”的&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;在多个识别框架的构建过程中，平行框架通常是针对决策问题属性的特点或决策者根据自己的知识背景和偏好而构建的；而递进框架通常是用来反映决策主体与决策过程特征信息的，往往反映了决策者给出的决策信息质量&lt;/strong&gt;。&lt;/p&gt;


&lt;h2&gt;&lt;span&gt;0x1：识别框架等价定义&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;为了便于将不同识别框架上的信息进行融合，一般要求将不同识别框架上的信息转化到同一个识别框架上，为此，需要对不同识别框架的等价性和评估等价的概念进行界定。&lt;/p&gt;
&lt;p&gt;设两个识别框架分别为 Θ = {θ&lt;sub&gt;n&lt;/sub&gt;，n=1,2,....,N&lt;sub&gt;1&lt;/sub&gt;} 和 Ω = {ω&lt;sub&gt;n&lt;/sub&gt;，n=1,2,....,N&lt;sub&gt;2&lt;/sub&gt;}，若对&lt;img src=&quot;https://img2020.cnblogs.com/blog/532548/202004/532548-20200425202343957-1571811725.png&quot; alt=&quot;&quot; width=&quot;51&quot; height=&quot;17&quot;/&gt;，都存在唯一的 ω&lt;sub&gt;n&lt;/sub&gt; 与之等价，记为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/532548/202004/532548-20200425202546108-1825362258.png&quot; alt=&quot;&quot; width=&quot;66&quot; height=&quot;26&quot;/&gt;&lt;/p&gt;
&lt;p&gt;反之，若对&lt;img src=&quot;https://img2020.cnblogs.com/blog/532548/202004/532548-20200425202618168-46938632.png&quot; alt=&quot;&quot; width=&quot;57&quot; height=&quot;19&quot;/&gt;，都存在唯一的 θ&lt;sub&gt;n&lt;/sub&gt; ∈ Θ 与之等价，则称&lt;strong&gt;识别框架 Θ 和 Ω 等价（一正一反都成立）&lt;/strong&gt;，记为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/532548/202004/532548-20200425202810987-1996903527.png&quot; alt=&quot;&quot; width=&quot;69&quot; height=&quot;22&quot;/&gt;&lt;/p&gt;
&lt;p&gt;例如，在对汽车的发动机的噪声进行评价时，存在两个识别框架，&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;识别框架 Θ = {非常吵、吵、一般、静、非常静}&lt;/li&gt;
&lt;li&gt;识别框架 Ω = {差、较差、中、良、优}&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;两个识别框架的元素，都彼此存在唯一的等价元素，则&lt;strong&gt;识别框架 Θ 和 Ω 等价&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;显然，&lt;strong&gt;若识别框架  Θ 和 Ω 等价，则有 N&lt;sub&gt;1&lt;/sub&gt; = N&lt;sub&gt;2&lt;/sub&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;设 Θ 和 Ω 为两个等价的识别框架，且在两个识别框架下的基本可信度分配分别为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/532548/202004/532548-20200425205115474-960042340.png&quot; alt=&quot;&quot; width=&quot;257&quot; height=&quot;66&quot;/&gt; &lt;/p&gt;
&lt;p&gt;则当且仅当 N1 = N2 且 β&lt;sub&gt;1,n&lt;/sub&gt; = γ&lt;sub&gt;2,n&lt;/sub&gt; 成立时（n=1,2,...,N&lt;sub&gt;1&lt;/sub&gt;），称&lt;strong&gt;两个基本可信度分配 m1 与 m2 等价&lt;/strong&gt;，记为&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/532548/202004/532548-20200425205402578-1195635899.png&quot; alt=&quot;&quot; width=&quot;91&quot; height=&quot;28&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;0x2：识别框架元素间概率等价&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;这里需要注意的是，实际情况中，完全等价的识别框架是比较少见的，而是彼此错位的，即彼此相容而又不完全一一对应（N&lt;sub&gt;1&lt;/sub&gt; ≠ N&lt;sub&gt;2&lt;/sub&gt;），且一个框架中的元素（θ ∈ Θ）并不一定恰好对应于另一个框架中的某个元素（ω ∈ Ω），而是以一定程度对应于另一框架中多个元素。&lt;/p&gt;
&lt;p&gt;为此，这里给出识别框架元素间概率等价的概念定义。&lt;/p&gt;
&lt;p&gt;若 θ&lt;sub&gt;1,n&lt;/sub&gt; ∈ Θ 以 α&lt;sub&gt;2,l&lt;/sub&gt;(l=1,2,....,N&lt;sub&gt;2&lt;/sub&gt;) 的程度对应于 ω&lt;sub&gt;l&lt;/sub&gt; ∈ Ω，其中&lt;/p&gt;
&lt;p&gt;0 ≤ α&lt;sub&gt;2,l&lt;/sub&gt; ≤ 1，&lt;img src=&quot;https://img2020.cnblogs.com/blog/532548/202004/532548-20200425210910267-484851488.png&quot; alt=&quot;&quot; width=&quot;69&quot; height=&quot;42&quot;/&gt;，即满足概率完备性&lt;/p&gt;
&lt;p&gt;则称&lt;strong&gt;框架 Θ 中的元素 θ&lt;sub&gt;1,n&lt;/sub&gt; 与框架 Ω 中的元素集 {(ω&lt;sub&gt;l&lt;/sub&gt;，α&lt;sub&gt;2,l&lt;/sub&gt;)，l=12,....,N&lt;sub&gt;2&lt;/sub&gt;} 以概率等价&lt;/strong&gt;，记为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/532548/202004/532548-20200425211111978-137348340.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在多属性群决策中，上述等价关系通常是由决策者提供的，其中意味着元素 θ&lt;sub&gt;1,n&lt;/sub&gt; ∈ Θ 的效用和 {(ω&lt;sub&gt;l&lt;/sub&gt;，α&lt;sub&gt;2,l&lt;/sub&gt;)，l=12,....,N&lt;sub&gt;2&lt;/sub&gt;} 的期望效用&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/532548/202004/532548-20200425211433723-1934937390.png&quot; alt=&quot;&quot; width=&quot;176&quot; height=&quot;53&quot;/&gt; &lt;/p&gt;
&lt;p&gt;相等。&lt;/p&gt;
&lt;p&gt;若对&lt;img src=&quot;https://img2020.cnblogs.com/blog/532548/202004/532548-20200425211514369-1274108764.png&quot; alt=&quot;&quot; width=&quot;178&quot; height=&quot;24&quot;/&gt;，均有&lt;img src=&quot;https://img2020.cnblogs.com/blog/532548/202004/532548-20200425211551397-1925362925.png&quot; alt=&quot;&quot; width=&quot;237&quot; height=&quot;24&quot;/&gt;；反过来，对&lt;img src=&quot;https://img2020.cnblogs.com/blog/532548/202004/532548-20200425211619760-1955044532.png&quot; alt=&quot;&quot; width=&quot;192&quot; height=&quot;22&quot;/&gt;，均有&lt;img src=&quot;https://img2020.cnblogs.com/blog/532548/202004/532548-20200425211637223-791603147.png&quot; alt=&quot;&quot; width=&quot;250&quot; height=&quot;23&quot;/&gt;，则称识别框架 Θ 和 Ω 以概率等价，记为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/532548/202004/532548-20200425211727614-460572385.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;0x3：识别框架之间等价关系的逻辑分类&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;因此，从逻辑关系上来说，识别框架可以分为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;平行框架&lt;/li&gt;
&lt;li&gt;递进框架&lt;/li&gt;
&lt;li&gt;混合框架&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;从转化关系（等价关系）来说，有&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;粗化 &lt;/li&gt;
&lt;li&gt;细化&lt;/li&gt;
&lt;li&gt;概率转化&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;传统的基于单层识别框架的决策在信息的表示上，未能反映决策者提供的决策信息的质量，因此信息对多个意见的合成具有重要作用，直接影响了决策质量。也就是所谓的训练样本的纯度和丰富度决定了模型的最终效果。&lt;/p&gt;
&lt;p&gt;因此，有必要增加一维信息反映专家决策知识和行为特征，并对原有决策信息进行修正，以更加精确有效地利用专家信息。&lt;/p&gt;
&lt;p&gt;我们本章来讨论两维语义信息的语义表示及集结方法。&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;0x1：两维语义信息的内涵&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;设 H&lt;sub&gt;n&lt;/sub&gt;(n=1,2,...,N) 和 S&lt;sub&gt;t&lt;/sub&gt;(t=1,2,...,T) 分别为预先定义好的语言评价集 H 和 S 中的第 n 个和第 t 个元素，其中 H&lt;sub&gt;n&lt;/sub&gt; 和 S&lt;sub&gt;t&lt;/sub&gt; 满足以下几个特性：&lt;/p&gt;
&lt;p&gt;对一个判决问题，决策者同时构建了两个识别框架（语言短语集）H = {H&lt;sub&gt;1&lt;/sub&gt;，H&lt;sub&gt;2&lt;/sub&gt;，....，H&lt;sub&gt;N&lt;/sub&gt;} 和 S = {S&lt;sub&gt;1&lt;/sub&gt;，S&lt;sub&gt;2&lt;/sub&gt;，....，S&lt;sub&gt;T&lt;/sub&gt;}，使用了一、二两个维度识别框架中的评价信息描述自己对于某一事物的评判。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;其中第一维识别框架中的评价信息 H&lt;sub&gt;n&lt;/sub&gt;(n=1,2,....,N) 是用来描述待决策对象属性的，是对决策对象属性的评价&lt;/li&gt;
&lt;li&gt;第二维识别框架中的评价信息 S&lt;sub&gt;t&lt;/sub&gt;(t=1,2,....,T) 是用来反映决策者知识证据的属性特征的，是对第一维评价信息 H&lt;sub&gt;n&lt;/sub&gt; 质量的评价&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这种由两个维度形成的语言评价信息 (H&lt;sub&gt;n&lt;/sub&gt;，S&lt;sub&gt;t&lt;/sub&gt;) 称为&lt;strong&gt;两维语义评价信息&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;例如，在国家自然科学基金立项评估中，同行评议意见表中预先构建了两个语言评估框架：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;专家科研项目质量的评价：H&lt;sub&gt;n&lt;/sub&gt; = {H&lt;sub&gt;4&lt;/sub&gt;(优)，H&lt;sub&gt;3&lt;/sub&gt;(良)，H&lt;sub&gt;2&lt;/sub&gt;(中)，H&lt;sub&gt;1&lt;/sub&gt;(差)}&lt;/li&gt;
&lt;li&gt;反映同行专家对自己给出质量评价 H&lt;sub&gt;n&lt;/sub&gt; 的评价：S = {S&lt;sub&gt;3&lt;/sub&gt;(熟悉)，S&lt;sub&gt;2&lt;/sub&gt;(较熟悉)，S&lt;sub&gt;1&lt;/sub&gt;(部分熟悉)}&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;同行评议专家提供评价信息 (H&lt;sub&gt;n&lt;/sub&gt;，S&lt;sub&gt;t&lt;/sub&gt;)(n=1,2,3,4; t=1,2,3) 即为两维语义评价信息。 &lt;/p&gt;
&lt;p&gt;在两维语义评价信息中，第二维评价信息是用来描述第一维评价信息质量的，通过第二维语义评价信息，不仅能够反映决策者评价信息的质量，同时也能反映决策信息的不确定和不完全程度。&lt;/p&gt;
&lt;p&gt;例如，同行评议专家提供评价信息 (优，较为熟悉) 即为两维语义信息的一个实例，&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第一维评价信息”优“是评议专家对科研项目的评价&lt;/li&gt;
&lt;li&gt;第二维评价信息”较熟悉“反映了评议专家对自己给出的评价”优“的不确定程度，同时也反映了评议专家对该科研项目的未知程度（不完全程度）&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;&lt;span&gt;0x2：两维语义信息的语义表示&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;由于两维语义信息不仅能够反映决策者评价信息的质量，同时也能反映决策信息的不确定和不完全程度。&lt;/p&gt;
&lt;p&gt;同时我们知道，证据理论用信度函数表示证据，信度函数满足半可加性，它比概率函数能更恰当表示信息中的”不确定性“和”不知性“。因此，两维语义信息的语义，可用信度函数来表示，即可用证据理论中的证据体来表示两维语义评价信息。&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;1、两维语义的点信度语义表示&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;设 H = {H&lt;sub&gt;1&lt;/sub&gt;，H&lt;sub&gt;2&lt;/sub&gt;，....，H&lt;sub&gt;N&lt;/sub&gt;} 和 S = {S&lt;sub&gt;1&lt;/sub&gt;，S&lt;sub&gt;2&lt;/sub&gt;，....，S&lt;sub&gt;T&lt;/sub&gt;} 分别为一、二两个维度上的语言集，将语言集 H 视为证据理论中的识别框架，则两维语义信息 (H&lt;sub&gt;n&lt;/sub&gt;，S&lt;sub&gt;t&lt;/sub&gt;) 的语义可通过映射 f 表示为证据体：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/532548/202004/532548-20200426163418781-798722051.png&quot; alt=&quot;&quot; width=&quot;490&quot; height=&quot;28&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中，β&lt;sub&gt;tk&lt;/sub&gt; 代表一个点信度，表示两维语义信息 (H&lt;sub&gt;n&lt;/sub&gt;，S&lt;sub&gt;t&lt;/sub&gt;) 支持 H&lt;sub&gt;k&lt;/sub&gt; ∈ H(k=1,2,...,N) 为真的置信度，且满足：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/532548/202004/532548-20200426163619431-648667596.png&quot; alt=&quot;&quot; width=&quot;79&quot; height=&quot;49&quot;/&gt;，即信度分配函数的完备性&lt;/p&gt;
&lt;p&gt;则称 &lt;strong&gt;f 为两维语义的点信度表示函数&lt;/strong&gt;。&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;2、两维语义的点信度语义规则&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;两维语义的点信度表示函数可由多个专家基于领域经验得出，也可以通过数据驱动的方式从大样本中得出（例如神经网络&lt;/strong&gt;）。&lt;/p&gt;
&lt;p&gt;一般来说，两维语义的点信度函数遵循以下规则：&lt;/p&gt;
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li&gt;不完全信息规则：第二维语义中对第一维信息质量的评价越高，决策者的评价信息中含有的不完全信息程度就越低，即若&lt;img src=&quot;https://img2020.cnblogs.com/blog/532548/202004/532548-20200426164805058-245373957.png&quot; alt=&quot;&quot; width=&quot;43&quot; height=&quot;18&quot;/&gt;，则&lt;img src=&quot;https://img2020.cnblogs.com/blog/532548/202004/532548-20200426164821902-557015224.png&quot; alt=&quot;&quot; width=&quot;98&quot; height=&quot;19&quot;/&gt;&lt;/li&gt;
&lt;li readability=&quot;8&quot;&gt;
&lt;p&gt;信度单峰规则：(H&lt;sub&gt;n&lt;/sub&gt;，S&lt;sub&gt;t&lt;/sub&gt;) 转化成的证据体 {(H&lt;sub&gt;k&lt;/sub&gt;，β&lt;sub&gt;tk&lt;/sub&gt;)，k=1,2,....,N}，其信度应以 H&lt;sub&gt;n&lt;/sub&gt; 为单峰，且距离 H&lt;sub&gt;n&lt;/sub&gt; 越远，其信度就越小。即对&lt;img src=&quot;https://img2020.cnblogs.com/blog/532548/202004/532548-20200426165214053-1226314781.png&quot; alt=&quot;&quot; width=&quot;155&quot; height=&quot;18&quot;/&gt;，有&lt;img src=&quot;https://img2020.cnblogs.com/blog/532548/202004/532548-20200426165240808-1933177138.png&quot; alt=&quot;&quot; width=&quot;203&quot; height=&quot;23&quot;/&gt;，且若 | i-n | &amp;lt; | j-n |，则有 βt(H&lt;sub&gt;i&lt;/sub&gt;) &amp;gt; βt(H&lt;sub&gt;j&lt;/sub&gt;)，其中 i,j ∈ {1,2,....,N}&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;&lt;span&gt;3、两维语义的区间信度表示&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;两维语义的点信度表示法要求给出两维语义支持各语言评价等级的精确置信度，这对决策者的领域知识或者有监督样本集的要求较高。&lt;/p&gt;
&lt;p&gt;但是由于客观事物的复杂性（相关性不明显，或者伪相关性）和人类自身知识的局限性，两维语义的区间信度比精确的点信度表示更容易获取。&lt;/p&gt;
&lt;p&gt;针对两维语义信息 (H&lt;sub&gt;n&lt;/sub&gt;，S&lt;sub&gt;t&lt;/sub&gt;) 的语义，假设专家用映射 g 表示区间信度：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/532548/202004/532548-20200426165853174-82339275.png&quot; alt=&quot;&quot; width=&quot;411&quot; height=&quot;32&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中，&lt;img src=&quot;https://img2020.cnblogs.com/blog/532548/202004/532548-20200426165910789-1767205015.png&quot; alt=&quot;&quot; width=&quot;77&quot; height=&quot;23&quot;/&gt;代表一个区间信度，表示两维语义信息 (H&lt;sub&gt;n&lt;/sub&gt;，S&lt;sub&gt;t&lt;/sub&gt;) 支持 H&lt;sub&gt;k&lt;/sub&gt; ∈ H(k=1,2,...,N) 为真的置信度，且满足：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/532548/202004/532548-20200426170013703-1488799202.png&quot; alt=&quot;&quot; width=&quot;91&quot; height=&quot;55&quot;/&gt;，同样需要满足信度分配函数的完备性 &lt;/p&gt;
&lt;p&gt;则称 &lt;strong&gt;g 为两维语义的区间信度表示函数&lt;/strong&gt;。 &lt;/p&gt;
&lt;p&gt;类似的，两维语义的区间信度表示法也同样遵循”不完全信息“和”信度单峰“语义规则。&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;0x3：两维语义信息的比较&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;由两位语义信息 (H&lt;sub&gt;n&lt;/sub&gt;，S&lt;sub&gt;t&lt;/sub&gt;) 的信度表示法可知，两维语义信息不仅反映了决策者对待处理问题的评价，同时反映了决策信息的质量（包括决策信息的不确定性和不完全性），因此对两维语义信息进行比较，关键是如何处理不确定和不完全信息。&lt;/p&gt;
&lt;p&gt;对于两维语义的点信度表示法，可以采用两种处理方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;点期望得分法&lt;/li&gt;
&lt;li&gt;区间期望得分法&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对于两维语义的区间信度语义表示法，可利用基于连续的有序加权平均算子（continuous ordered weighted averaging，C-OWA）算子的区间信度的点化法，将区间信度转化为点信度，再进行比较。&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;1、点期望得分法&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;点期望得分法将两维语义中的第一个维度上的语言短语量化为得分，通过两维语义的证据体表示中的信度计算两维语义信息的加权平均得分。&lt;/p&gt;
&lt;p&gt;设第一个维度上的语言集 H = {H&lt;sub&gt;1&lt;/sub&gt;，H&lt;sub&gt;2&lt;/sub&gt;，....，H&lt;sub&gt;N&lt;/sub&gt;}，且&lt;img src=&quot;https://img2020.cnblogs.com/blog/532548/202004/532548-20200426173448803-1903873958.png&quot; alt=&quot;&quot; width=&quot;55&quot; height=&quot;18&quot;/&gt;(i &amp;lt; j)，(H&lt;sub&gt;n&lt;/sub&gt;，S&lt;sub&gt;t&lt;/sub&gt;) 的点信度语义为&lt;img src=&quot;https://img2020.cnblogs.com/blog/532548/202004/532548-20200426173537163-508480275.png&quot; alt=&quot;&quot; width=&quot;163&quot; height=&quot;19&quot;/&gt;。假设语言短语 H&lt;sub&gt;i&lt;/sub&gt; 的得分为 h&lt;sub&gt;i&lt;/sub&gt;，满足 h&lt;sub&gt;i&lt;/sub&gt; &amp;lt; h&lt;sub&gt;j&lt;/sub&gt;(i &amp;lt; j)。与加权平均法类似，可定义两维语义信息的期望得分 E[(H&lt;sub&gt;n&lt;/sub&gt;，S&lt;sub&gt;t&lt;/sub&gt;)]：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/532548/202004/532548-20200426173817286-1763224069.png&quot; alt=&quot;&quot; width=&quot;257&quot; height=&quot;106&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由证据体表示的两维语义信息，通过期望得分化为得分值，从而可将多个两维语义信息进行比较、排序。这种方法计算简单，但缺点是处理过程有损失。&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;2、区间期望得分法&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;区间期望得分法首先也将两维语义中的第一个维度上的语言短语量化为得分，当 β&lt;sub&gt;t&lt;/sub&gt;(H)&amp;gt;0时，为了便于多个两维语义信息比较，将这部分信度分别赋予最小分值和最大分值，由此，产生一个得分区间。&lt;/p&gt;
&lt;p&gt;设第一个维度上的语言集 H = {H&lt;sub&gt;1&lt;/sub&gt;，H&lt;sub&gt;2&lt;/sub&gt;，....，H&lt;sub&gt;N&lt;/sub&gt;}，且&lt;img src=&quot;https://img2020.cnblogs.com/blog/532548/202004/532548-20200426173448803-1903873958.png&quot; alt=&quot;&quot; width=&quot;55&quot; height=&quot;18&quot;/&gt;(i &amp;lt; j)，(H&lt;sub&gt;n&lt;/sub&gt;，S&lt;sub&gt;t&lt;/sub&gt;) 的点信度语义为&lt;img src=&quot;https://img2020.cnblogs.com/blog/532548/202004/532548-20200426173537163-508480275.png&quot; alt=&quot;&quot; width=&quot;163&quot; height=&quot;19&quot;/&gt;。假设语言短语 H&lt;sub&gt;i&lt;/sub&gt; 的得分为 h&lt;sub&gt;i&lt;/sub&gt;，满足 h&lt;sub&gt;i&lt;/sub&gt; &amp;lt; h&lt;sub&gt;j&lt;/sub&gt;(i &amp;lt; j)。&lt;/p&gt;
&lt;p&gt;当&lt;img src=&quot;https://img2020.cnblogs.com/blog/532548/202004/532548-20200426174525547-2008938322.png&quot; alt=&quot;&quot; width=&quot;158&quot; height=&quot;36&quot;/&gt;时，说明由于人们对问题的不确知而将这一部分信度赋予了整个框架。为了便于比较，将这部分信度分别赋予 min(H&lt;sub&gt;1&lt;/sub&gt;，H&lt;sub&gt;2&lt;/sub&gt;，...，H&lt;sub&gt;N&lt;/sub&gt;) = H&lt;sub&gt;1&lt;/sub&gt;，max(H&lt;sub&gt;1&lt;/sub&gt;，H&lt;sub&gt;2&lt;/sub&gt;，...，H&lt;sub&gt;N&lt;/sub&gt;) = H&lt;sub&gt;1&lt;/sub&gt;。则两维语义信息 (H&lt;sub&gt;n&lt;/sub&gt;，S&lt;sub&gt;t&lt;/sub&gt;) 的最小、最大期望得分分别为： &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/532548/202004/532548-20200426175031540-707064156.png&quot; alt=&quot;&quot; width=&quot;326&quot; height=&quot;124&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从而可得两维语义信息 (H&lt;sub&gt;n&lt;/sub&gt;，S&lt;sub&gt;t&lt;/sub&gt;) 的期望得分区间：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;[minE[(H&lt;sub&gt;n&lt;/sub&gt;，S&lt;sub&gt;t&lt;/sub&gt;)]，maxE[(H&lt;sub&gt;n&lt;/sub&gt;，S&lt;sub&gt;t&lt;/sub&gt;)]]&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这种信度分配方法很容易理解，因为由于信息的不完全或人们认识能力的局限性，信度 β&lt;sub&gt;t&lt;/sub&gt;(H) 不知该分配到哪个评语上，但无论这部分信度如何分配，两维语义信息 (H&lt;sub&gt;n&lt;/sub&gt;，S&lt;sub&gt;t&lt;/sub&gt;) 的期望得分均落在上述区间中。&lt;/p&gt;
&lt;p&gt;显然，当 β&lt;sub&gt;1&lt;/sub&gt;(H) = 0 时，上述区间退化成一个点；而当 β&lt;sub&gt;t&lt;/sub&gt;(H) = 1 时，即当人们对问题完全无知时，该区间就退化为 [h&lt;sub&gt;1&lt;/sub&gt;，h&lt;sub&gt;N&lt;/sub&gt;]。&lt;/p&gt;
&lt;p&gt;根据区间数的可能度公式可对多个两维语义信息进行比较、排序。&lt;/p&gt;
&lt;p&gt;相比点期望得分法，得分区间法计算较复杂，但结果更精确，处理过程中信心损失较少。&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;0x4：两维语义信息的集结&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;根据两位语义信息的语义表示，对多个两维语义信息的集结转化成了对多条证据的集结。&lt;/p&gt;
&lt;p&gt;目前，证据的融合方法主要有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Dempster合成规则&lt;/li&gt;
&lt;li&gt;改进的冲突证据合成规则&lt;/li&gt;
&lt;li&gt;证据推理算子 &lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Dempster合成规则在处理高度冲突的证据时，其结果往往有悖常理，例如著名的&lt;a href=&quot;https://www.cnblogs.com/LittleHann/p/12730627.html#_lab2_0_0&quot; target=&quot;_blank&quot;&gt;Zadeh悖论&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;改进的冲突证据合成规则从不同的角度对Dempster合成规则进行了改善，并且在某些领域取得了较好的应用，但处理的冲突证据都有一定应用背景和使用哦范围限制，且在处理不同权重信息的证据方面也存在一定的困难。&lt;/p&gt;
&lt;p&gt;而证据推理方法是由Yang等人在1994年提出来的，后又对此进行了完善和发展。该方法应用权重修正证据源，并在合成过程中对未分配的信度进一步细分为由权重引起的不完全和由信息源给出的判断不完全两部分。证据推理合成规则在处理不同权重的多条证据的融合方面具有独特的优势，且能很好地处理高度冲突的证据合成问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;由于不同的两维语义信息的质量不同，其在信息融合的重要性也不相同，即不同两维语义信息的权重不同，且多个两维语义信息也存在高度冲突情况&lt;/strong&gt;。因此，我们通过引入证据推理算子对多个两维语义信息进行融合。&lt;/p&gt;
&lt;p&gt;设有 p 个信息源给出的两维语义评价信息为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/532548/202004/532548-20200426210715032-716410394.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其点信度语义表示为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/532548/202004/532548-20200426210746814-1283903953.png&quot; alt=&quot;&quot; width=&quot;405&quot; height=&quot;31&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中，&lt;img src=&quot;https://img2020.cnblogs.com/blog/532548/202004/532548-20200426210811661-691858717.png&quot; alt=&quot;&quot; width=&quot;199&quot; height=&quot;18&quot;/&gt;为第 i 个信息源 E&lt;sub&gt;i&lt;/sub&gt; 支持评价对象评为等级 H&lt;sub&gt;n&lt;/sub&gt; 的置信程度，且满足：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/532548/202004/532548-20200426211155987-1623064317.png&quot; alt=&quot;&quot; width=&quot;273&quot; height=&quot;51&quot;/&gt;&lt;/p&gt;
&lt;p&gt;假设权重向量为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/532548/202004/532548-20200426211222678-746427065.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;满足：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/532548/202004/532548-20200426211241121-365062530.png&quot; alt=&quot;&quot; width=&quot;238&quot; height=&quot;49&quot;/&gt;&lt;/p&gt;
&lt;p&gt;则可应用证据推理算子将多个两维语义信息进行集成。&lt;/p&gt;
&lt;p&gt;综合 p 个两维语义评价信息后，其集成结果仍为证据体，可以表示为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/532548/202004/532548-20200426211401486-1393172163.png&quot; alt=&quot;&quot; width=&quot;400&quot; height=&quot;31&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;0x5：算例分析&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;假设预先设定的针对评价对象的语言评价集 H = {H&lt;sub&gt;1&lt;/sub&gt;，H&lt;sub&gt;2&lt;/sub&gt;，H&lt;sub&gt;3&lt;/sub&gt;，H&lt;sub&gt;4&lt;/sub&gt;} = {差，中，良，优}，专家对评价对象的熟悉程度的语言评价集为 S = {S&lt;sub&gt;1&lt;/sub&gt;，S&lt;sub&gt;2&lt;/sub&gt;，S&lt;sub&gt;3&lt;/sub&gt;} = {熟悉，较熟悉，部分熟悉}。&lt;/p&gt;
&lt;p&gt;现有五位专家 E&lt;sub&gt;i&lt;/sub&gt;(i=1,2,3,4,5)，针对某一个评价对象给出的两维语义评价信息为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;E&lt;sub&gt;1&lt;/sub&gt; = (H&lt;sub&gt;1&lt;/sub&gt;，S&lt;sub&gt;2&lt;/sub&gt;)&lt;/li&gt;
&lt;li&gt;E&lt;sub&gt;2&lt;/sub&gt; = (H&lt;sub&gt;2&lt;/sub&gt;，S&lt;sub&gt;2&lt;/sub&gt;)&lt;/li&gt;
&lt;li&gt;E&lt;sub&gt;3&lt;/sub&gt; = (H&lt;sub&gt;2&lt;/sub&gt;，S&lt;sub&gt;3&lt;/sub&gt;)&lt;/li&gt;
&lt;li&gt;E&lt;sub&gt;4&lt;/sub&gt; = (H&lt;sub&gt;3&lt;/sub&gt;，S&lt;sub&gt;1&lt;/sub&gt;)&lt;/li&gt;
&lt;li&gt;E&lt;sub&gt;5&lt;/sub&gt; = (H&lt;sub&gt;2&lt;/sub&gt;，S&lt;sub&gt;2&lt;/sub&gt;)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;假设专家采用两维语义的点信度表示，且给出点信度语义表示如下表所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/532548/202004/532548-20200426212449205-826622624.png&quot; alt=&quot;&quot; width=&quot;740&quot; height=&quot;244&quot;/&gt; &lt;/p&gt;
&lt;p&gt;根据上表中两维语义的点信度表示，5位专家给出的两维语义评价信息的点信度可分别表示为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/532548/202004/532548-20200426212709916-701755008.png&quot; alt=&quot;&quot; width=&quot;336&quot; height=&quot;147&quot;/&gt; &lt;/p&gt;
&lt;p&gt;设5位专家的权重向量为（根据专家对专家的了解这一领域知识得出）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/532548/202004/532548-20200426213004392-727425347.png&quot; alt=&quot;&quot; width=&quot;235&quot; height=&quot;30&quot;/&gt;&lt;/p&gt;
&lt;p&gt;则由证据推理算子，将5位专家给出两维语义信息进行集结为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/532548/202004/532548-20200426213127722-93811078.png&quot; alt=&quot;&quot; width=&quot;651&quot; height=&quot;28&quot;/&gt;&lt;/p&gt;
&lt;p&gt;即综合5位专家的意见，认为该评价对象为”优“、”良“、”中“、”差“的可信度分别为：19.85%、35.21%、27.54%、1.26%、还有另外16.14%的信度不知道被评为哪个等级。 &lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;Relevant Link:&lt;/strong&gt;&lt;/strong&gt;  &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
《证据推理理论方法及其在决策评估中的应用》   
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;&lt;span&gt;0x1：基于两维语义的专家组合赋权法&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;影响专家评价准确性的因素主要有两个方面，&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一方面是专家对决策对象的熟悉程度（或了解程度），可通过专家对自己做出的评价进行自评价，其体现的是专家对所做评价信息可靠性的自我评估（简称自评）&lt;/li&gt;
&lt;li&gt;另一方面是专家的宽严尺度（评价标准），其体现了专家评价的主观偏好，需要与其他专家比较进行评估（简称他评）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;一般来说，专家对决策对象熟悉程度越高，评价的准确性就越高；对同一个决策对象的评价与其他专家评价的差异性越小，该专家对评价标准掌握的情况的情况可能就相对越好。&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;1、自评标准&lt;/span&gt;&lt;/h3&gt;
&lt;h3&gt;&lt;span&gt;2、他评标准&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;与其他专家评价的差异性，可以通过对同一个决策对象各专家评价信息的距离或相似度来度量。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;假设第一维度（对决策对象的评价）的评语集为 H&lt;sub&gt;1&lt;/sub&gt;，H&lt;sub&gt;2&lt;/sub&gt;，.....，H&lt;sub&gt;N&lt;/sub&gt;，分别赋值为 h&lt;sub&gt;1&lt;/sub&gt;，h&lt;sub&gt;2&lt;/sub&gt;，....，h&lt;sub&gt;N&lt;/sub&gt;，满足当 i ≥ j 时，h&lt;sub&gt;i&lt;/sub&gt; ≥ h&lt;sub&gt;j&lt;/sub&gt;，则评价信息 H&lt;sub&gt;i&lt;/sub&gt; 和 H&lt;sub&gt;j&lt;/sub&gt; 的距离可定义为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/532548/202004/532548-20200426215934787-140129527.png&quot; alt=&quot;&quot; width=&quot;271&quot; height=&quot;56&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;显然，d&lt;sub&gt;i,j&lt;/sub&gt; 满足距离的基本性质：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;0 ≤ d&lt;sub&gt;i,j&lt;/sub&gt; ≤ 1&lt;/li&gt;
&lt;li&gt;当且仅当 h&lt;sub&gt;i&lt;/sub&gt; = h&lt;sub&gt;j&lt;/sub&gt; 时，d&lt;sub&gt;i,j&lt;/sub&gt; = 0&lt;/li&gt;
&lt;li&gt;d&lt;sub&gt;i,j&lt;/sub&gt; = d&lt;sub&gt;j,i&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;d&lt;sub&gt;i,j&lt;/sub&gt; ≤ d&lt;sub&gt;i,k&lt;/sub&gt; + d&lt;sub&gt;k,j&lt;/sub&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;假设有 p 个专家对某一决策对象进行评价，则可以计算出专家们提供评价信息之间的两两距离，可用一个距离矩阵表示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/532548/202004/532548-20200426220256003-269881285.png&quot; alt=&quot;&quot; width=&quot;247&quot; height=&quot;124&quot;/&gt;&lt;/p&gt;
&lt;p&gt;定义评价信息 H&lt;sub&gt;i&lt;/sub&gt; 和 H&lt;sub&gt;j&lt;/sub&gt; 之间的相似性测度 Sim(H&lt;sub&gt;i&lt;/sub&gt;，H&lt;sub&gt;j&lt;/sub&gt;) 为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/532548/202004/532548-20200426220502537-1734831396.png&quot; alt=&quot;&quot; width=&quot;351&quot; height=&quot;34&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其结果可以用一个相似矩阵表示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/532548/202004/532548-20200426220525446-1021217861.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;两个评价信息距离越小，它们的相似性程度就越大，该评价系统中对评价信息 H&lt;sub&gt;i&lt;/sub&gt; 的支持度 Sup(H&lt;sub&gt;i&lt;/sub&gt;) 为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/532548/202004/532548-20200426220636942-1782463973.png&quot; alt=&quot;&quot; width=&quot;359&quot; height=&quot;51&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从公式中可以看出，支持度体现了某个专家的评价信息 H&lt;sub&gt;i&lt;/sub&gt; 在同行中的累计相似程度，通俗地说就是群体共识。&lt;/p&gt;
&lt;p&gt;将支持度归一化后可得评价信息 H&lt;sub&gt;i&lt;/sub&gt; 的可信度 Crd&lt;sub&gt;i&lt;/sub&gt;： &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/532548/202004/532548-20200426220717234-1043020453.png&quot; alt=&quot;&quot; width=&quot;268&quot; height=&quot;81&quot;/&gt; &lt;/p&gt;
&lt;p&gt;可将 Crd&lt;sub&gt;i&lt;/sub&gt; 作为专家 E&lt;sub&gt;i&lt;/sub&gt; 提供评价信息的一个权重 u&lt;sub&gt;i&lt;/sub&gt;，即权重 u&lt;sub&gt;i&lt;/sub&gt; 为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/532548/202004/532548-20200426220950397-1861201967.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;另外，第二维度的评价值 S&lt;sub&gt;t&lt;/sub&gt; 是对第一维评价信息质量的评价，可将第二维度的评价值 S&lt;sub&gt;t&lt;/sub&gt; 进行量化。假设专家 E&lt;sub&gt;i&lt;/sub&gt; 给出的第二维度的评语的量化值为 q&lt;sub&gt;t&lt;/sub&gt;，则可赋予该专家评价信息的另一个权重 v&lt;sub&gt;i&lt;/sub&gt; 为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/532548/202004/532548-20200426221140038-1298637239.png&quot; alt=&quot;&quot; width=&quot;234&quot; height=&quot;55&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为了全面反映专家评价信息的重要性，此处利用专家给出的两维语义评价信息，根据每个维度的评价信息分别对专家进行赋权，再采用乘法合成法对专家评价信息进行组合赋权，专家评价信息的最终权重 w&lt;sub&gt;i&lt;/sub&gt; 为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/532548/202004/532548-20200426221437739-377249601.png&quot; alt=&quot;&quot; width=&quot;223&quot; height=&quot;75&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;笔者提醒&lt;/strong&gt;&lt;/span&gt;：&lt;/p&gt;
&lt;p&gt;这和之前讨论的&lt;a href=&quot;https://www.cnblogs.com/LittleHann/p/12730627.html#_lab2_2_6&quot; target=&quot;_blank&quot;&gt;基于证据联盟的证据融合方式&lt;/a&gt;，其原理是类似的。&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;0x2：决策步骤&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;假设有 M 个备选方案 a&lt;sub&gt;j&lt;/sub&gt;&lt;span&gt;(j=1,2,...,M)，专家 E&lt;/span&gt;&lt;sub&gt;i&lt;/sub&gt;&lt;span&gt;对方案 &lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;sub&gt;j&lt;/sub&gt;&lt;span&gt;给出的两维语义评价信息为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/532548/202004/532548-20200426214732258-553757835.png&quot; alt=&quot;&quot; width=&quot;283&quot; height=&quot;31&quot;/&gt;&lt;/p&gt;
&lt;p&gt;针对多个专家给出的两维语义评价信息，可以根据以下步骤进行决策：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;步骤1，确定专家的权重。假设专家 i 给出的两维语义评价信息 E&lt;sub&gt;i&lt;/sub&gt; = (H&lt;sub&gt;k&lt;/sub&gt;&lt;sup&gt;i&lt;/sup&gt;，S&lt;sub&gt;t&lt;/sub&gt;&lt;sup&gt;i&lt;/sup&gt;)，对专家进行组合赋权，可得专家的权重 w&lt;sub&gt;i&lt;/sub&gt;(i=1,2,...,p)&lt;/li&gt;
&lt;li&gt;步骤2，给出两维语义信息的点信度或区间信度语义表示，在不完全信息规则和信息单峰规则的前提下，由多个专家经过反复斟酌（或者由数据驱动），给出两维语义信息的点信度或区间信度语义表示，将两维语义信息表示为证据体。&lt;/li&gt;
&lt;li&gt;步骤3，综合多个专家的两维语义信息，将转化为多个专家的两维语义信息进行集结，可得每个方案的综合评价结果，其结果仍表示为一个证据体。&lt;/li&gt;
&lt;li&gt;步骤4，对多个决策方案进行排序择优，应用两维语义比较方法，将多个方案进行排序择优。&lt;/li&gt;
&lt;/ul&gt;
</description>
<pubDate>Sun, 26 Apr 2020 14:27:00 +0000</pubDate>
<dc:creator>郑瀚Andrew.Hann</dc:creator>
<og:description>基于两维语义的证据推理方法研究</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/LittleHann/p/12758954.html</dc:identifier>
</item>
<item>
<title>Jmeter系列（6）- test plan测试计划详细讲解 - 小菠萝测试笔记</title>
<link>http://www.cnblogs.com/poloyy/p/12779353.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/poloyy/p/12779353.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;如果你想从头学习Jmeter，可以看看这个系列的文章哦&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/poloyy/category/1746599.html&quot;&gt;https://www.cnblogs.com/poloyy/category/1746599.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1896874/202004/1896874-20200426132012266-568870132.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;测试计划的作用&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;测试计划描述了Jmeter在执行时，一系列的步骤&lt;/li&gt;
&lt;li&gt;一个完整的测试计划包含了一个或多个【线程组、逻辑控制器、采样器、监听器、定时器、断言和配置元素】&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;测试计划添加or删除元件&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1896874/202004/1896874-20200426132704174-1329470436.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;通过右键点击树中的元件，选中要添加的元件&lt;/li&gt;
&lt;li&gt;也可以通过合并（merge）或打开（open）从文件中加载和添加元件&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;配置树中的元件&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;树中的每一个控件都能通过右边内容区显示&lt;/li&gt;
&lt;li&gt;树中的每一个控件都能在树中随意拖动&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;运行测试计划&lt;/h2&gt;
&lt;p&gt;可以通过ctrl+r运行测试计划&lt;/p&gt;
&lt;p&gt;通过右侧的数字：活动线程数/线程总数，这仅适用于本地运行的测试；使用客户端-服务器模式时，它们不包括在远程系统上启动的任何线程&lt;span&gt;&lt;strong&gt;【分布式压测时，master机不会显示所有远程salve机的线程总数】&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1896874/202004/1896874-20200426135000017-777407546.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;特别注意&lt;/h3&gt;
&lt;p&gt;仅在&lt;span&gt;&lt;strong&gt;调试&lt;/strong&gt;&lt;/span&gt;测试计划时，才应该使用上面的GUI模式&lt;span&gt;&lt;strong&gt;【界面模式】&lt;/strong&gt;&lt;/span&gt;，如果实际运行&lt;span&gt;&lt;strong&gt;负载测试&lt;/strong&gt;&lt;/span&gt;的时候，应该使用CLI模式&lt;span&gt;&lt;strong&gt;【命令行模式、无界面模式】&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;


&lt;h2&gt;暂停运行测试计划&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1896874/202004/1896874-20200426141238109-361881862.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;两种暂停方式&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;停止线程（ctrl + .）&lt;span&gt;&lt;strong&gt;【硬中断】&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;关闭线程（ctrl + ,）&lt;span&gt;&lt;strong&gt;【软中断】&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;stop threads&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;许多采样器（Samplers）都是可中断的，这意味着可以提前终止活动采样&lt;/li&gt;
&lt;li&gt;stop命令将检查所有线程是否已在默认超时（即5000 ms = 5秒）内停止&lt;/li&gt;
&lt;li&gt;如果有线程还没被停止，则会发送一条信息；此时可以再发送一次stop命令，但如果还是失败的话，就得退出Jmeter来清理&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;span&gt;特别注意&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;上述说的默认超时可以通过Jmeter属性来改变 &lt;span class=&quot;cnblogs_code&quot;&gt;jmeterengine.threadstop.wait&lt;/span&gt; &lt;strong&gt;【jmeter安装目录 / bin / jmeter.properties】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1896874/202004/1896874-20200426141246883-33813167.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;shutdown threads&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;线程会在当前运行任务结束后停止，&lt;span&gt;&lt;strong&gt;不会中断&lt;/strong&gt;&lt;/span&gt;活动线程正在执行的任务&lt;/li&gt;
&lt;li&gt;会出现一个【正在停止测试】的窗口（如下图），直到所有线程都停止了才会关闭&lt;/li&gt;
&lt;li&gt;如果停止时间太久，也可以直接发stop命令&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1896874/202004/1896874-20200426141455471-928434893.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;注意点&lt;/span&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;在Linux &lt;strong&gt;CLI&lt;/strong&gt;模式下，是没有快捷键来停止线程运行的，所以Jmeter CLi模式下会监听特定端口上的命令（默认端口4445，可以通过 &lt;span class=&quot;cnblogs_code&quot;&gt;jmeterengine.nongui.port&lt;/span&gt; 修改）&lt;/li&gt;
&lt;li&gt;如果4445端口被占用了（比如，另一个Jmeter实例用了），Jmeter会自动选择备用端口；&lt;/li&gt;
&lt;li&gt;Jmeter将尝试监听下一个更高的端口，直到到达Jmeter属性 &lt;span class=&quot;cnblogs_code&quot;&gt;jmeterengine.nongui.maxport&lt;/span&gt; 为止，该属性默认为4455&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;在CTI模式下，如何停止线程执行&lt;/h2&gt;
&lt;p&gt;在bin目录下，运行脚本&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;stoptest.cmd / stoptest.sh &lt;span&gt;&lt;strong&gt;【硬中断】&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;shutdown.cmd / shutdown.sh &lt;span&gt;&lt;strong&gt;【软中断】&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;注意，&lt;/strong&gt;&lt;/span&gt;只有在同一个host下运行的脚本，Jmeter才会接受&lt;/p&gt;

</description>
<pubDate>Sun, 26 Apr 2020 13:38:00 +0000</pubDate>
<dc:creator>小菠萝测试笔记</dc:creator>
<og:description>如果你想从头学习Jmeter，可以看看这个系列的文章哦 https://www.cnblogs.com/poloyy/category/1746599.html 测试计划的作用 测试计划描述了Jmet</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/poloyy/p/12779353.html</dc:identifier>
</item>
<item>
<title>【认证与授权】2、基于session的认证方式 - 黑米面包派</title>
<link>http://www.cnblogs.com/wujiwen/p/12782276.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wujiwen/p/12782276.html</guid>
<description>&lt;p&gt;用户认证通过以后，在服务端生成用户相关的数据保存在当前会话`（Session）`中，发给客户端的数据将通过`session_id `存放在`cookie`中。在后续的请求操作中，客户端将带上`session_id`，服务端就可以验证是否存在了，并可拿到其中的数据校验其合法性。当用户退出系统或`session_id`到期时，服务端则会销毁`session_id`。具体可查看上篇的基本概念了解。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;264.37618007334&quot;&gt;
&lt;p&gt;这一篇将通过一个简单的&lt;code&gt;web&lt;/code&gt;项目实现基于&lt;code&gt;Session&lt;/code&gt;的认证授权方式，也是以往传统项目的做法。&lt;br/&gt;&lt;em&gt;先来复习一下流程&lt;/em&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;用户认证通过以后，在服务端生成用户相关的数据保存在当前会话&lt;code&gt;（Session）&lt;/code&gt;中，发给客户端的数据将通过&lt;code&gt;session_id&lt;/code&gt; 存放在&lt;code&gt;cookie&lt;/code&gt;中。在后续的请求操作中，客户端将带上&lt;code&gt;session_id&lt;/code&gt;，服务端就可以验证是否存在了，并可拿到其中的数据校验其合法性。当用户退出系统或&lt;code&gt;session_id&lt;/code&gt;到期时，服务端则会销毁&lt;code&gt;session_id&lt;/code&gt;。具体可查看上篇的基本概念了解。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;1-创建工程&quot;&gt;1. 创建工程&lt;/h3&gt;
&lt;p&gt;本案例为了方便，直接使用&lt;code&gt;springboot&lt;/code&gt;快速创建一个&lt;code&gt;web&lt;/code&gt;工程&lt;/p&gt;
&lt;h4 id=&quot;pomxml&quot;&gt;pom.xml&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;
   &amp;lt;parent&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;2.2.5.RELEASE&amp;lt;/version&amp;gt;
        &amp;lt;relativePath/&amp;gt; &amp;lt;!-- lookup parent from repository --&amp;gt;
    &amp;lt;/parent&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;
    &amp;lt;artifactId&amp;gt;simple-mvc&amp;lt;/artifactId&amp;gt;
    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-thymeleaf&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;
&amp;lt;/project&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;12-实现认证功能&quot;&gt;1.2 实现认证功能&lt;/h3&gt;
&lt;p&gt;实现认证功能，我们一般需要这样几个资源&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;认证的入口（认证页面）&lt;/li&gt;
&lt;li&gt;认证的凭证（用户的凭证信息）&lt;/li&gt;
&lt;li&gt;认证逻辑（如何才算认证成功）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;em&gt;认证页面&lt;/em&gt;&lt;br/&gt;也就是我们常说的登录页&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;
      xmlns:sec=&quot;http://www.thymeleaf.org/thymeleaf-extras-springsecurity3&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;Login&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;form th:action=&quot;@{/login}&quot; method=&quot;post&quot;&amp;gt;
    &amp;lt;div&amp;gt;&amp;lt;label&amp;gt; User Name : &amp;lt;input type=&quot;text&quot; name=&quot;username&quot;/&amp;gt; &amp;lt;/label&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div&amp;gt;&amp;lt;label&amp;gt; Password: &amp;lt;input type=&quot;password&quot; name=&quot;password&quot;/&amp;gt; &amp;lt;/label&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div&amp;gt;&amp;lt;input type=&quot;submit&quot; value=&quot;登录&quot;/&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/form&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;页面控制器&lt;/em&gt;&lt;br/&gt;现在有了认证页面，那我如果才可以进入到认证页面呢，同时我点击登陆后，下一步该做什么呢？&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Controller
public class LoginController {
        // 认证逻辑处理
    @Autowired
    private AuthenticationService authenticationService;
  
                // 根路径直接跳转至认证页面
    @RequestMapping(&quot;/&quot;)
    public String loginUrl() {
        return &quot;/login&quot;;
    }

                // 认证请求
    @RequestMapping(&quot;/login&quot;)
    @ResponseBody
    public String login(HttpServletRequest request) {
   AuthenticationRequest authenticationRequest = new AuthenticationRequest(request);
        User user = authenticationService.authentication(authenticationRequest);
        return user.getUsername() + &quot;你好！&quot;;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过客户端传递来的参数进行处理&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class AuthenticationRequest {
    private String username;
    private String password;

    public AuthenticationRequest(HttpServletRequest request){
        username = request.getParameter(&quot;username&quot;);
        password = request.getParameter(&quot;password&quot;);
    }
    // 省略 setter getter
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同时我们还需要一个状态用户信息的对象User&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class User {
    private Integer userId;
    private String username;
    private String password;
    private boolean enable;

    public User(Integer userId, String username, String password, boolean enable) {
        this.userId = userId;
        this.username = username;
        this.password = password;
        this.enable = enable;
    }
                // 省略 setter getter
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有了用户了，有了入口了，接下来就是对这些数据的处理，看是否如何认证条件了&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Service
public class AuthenticationService{
                // 模拟数据库中保存的两个用户
    private static final Map&amp;lt;String, User&amp;gt; userMap = new HashMap&amp;lt;String, User&amp;gt;() {{
        put(&quot;admin&quot;, new User(1, &quot;admin&quot;, &quot;admin&quot;, true));
        put(&quot;spring&quot;, new User(2, &quot;spring&quot;, &quot;spring&quot;, false));
    }};

    private User loginByUserName(String userName) {
        return userMap.get(userName);
    }

    @Override
    public User authentication(AuthenticationRequest authenticationRequest) {
        if (authenticationRequest == null
                || StringUtils.isEmpty(authenticationRequest.getUsername())
                || StringUtils.isEmpty(authenticationRequest.getPassword())) {
            throw new RuntimeException(&quot;账号或密码为空&quot;);
        }
        User user = loginByUserName(authenticationRequest.getUsername());
        if (user == null) {
            throw new RuntimeException(&quot;用户不存在&quot;);
        }
        if(!authenticationRequest.getPassword().equals(user.getPassword())){
            throw new RuntimeException(&quot;密码错误&quot;);
        }
        if (!user.isEnable()){
            throw new RuntimeException(&quot;该账户已被禁用&quot;);
        }
        return user;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里我们模拟了两个用户，一个是正常使用的账号，还有个账号因为某些特殊的原因被封禁了，我们一起来测试一下。&lt;/p&gt;
&lt;p&gt;启动项目在客户端输入&lt;code&gt;localhost:8080&lt;/code&gt; 会直接跳转到认证页面&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/04/05/QeUvAE8Ipr3XD5W.png&quot; alt=&quot;login1.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们分别尝试不同的账户密码登录看具体显示什么信息。&lt;/p&gt;
&lt;p&gt;1、数据的密码不正确&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/04/05/au3GP5zgLIi42kp.png&quot; alt=&quot;error1.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2、账户被禁用&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/04/05/JheF8dISQmxjfsz.png&quot; alt=&quot;error2.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3、数据正确的用户名和密码&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/04/05/BjbwtXKDI7QN1eP.png&quot; alt=&quot;success1.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时我们的测试均已符合预期，能够将正确的信息反馈给用户。这也是最基础的认证功能，用户能够通过系统的认证，说明他是该系统的合法用户，但是用户在后续的访问过程中，我们需要知道到底是哪个用户在操作呢，这时我们就需要引入到会话的功能呢。&lt;/p&gt;
&lt;h3 id=&quot;13-实现会话功能&quot;&gt;1.3 实现会话功能&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://baike.baidu.com/item/%E4%BC%9A%E8%AF%9D/1657433&quot;&gt;会话&lt;/a&gt;是指一个终端用户与交互系统进行通讯的过程，比如从输入账户密码进入操作系统到退出操作系统就是一个会话过程。&lt;br/&gt;1、增加会话的控制&lt;/p&gt;
&lt;p&gt;&lt;em&gt;关于&lt;code&gt;session&lt;/code&gt;的操作，可参考&lt;code&gt;HttpServletRqeust&lt;/code&gt;的相关API&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;前面引言中我们提到了session_id的概念，与客户端的交互。&lt;br/&gt;定义一个常量作为存放用户信息的key，同时在登录成功后保存用户信息&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;privata finl static String USER_SESSION_KEY = &quot;user_session_key&quot;;
@RequestMapping(&quot;/login&quot;)
@ResponseBody
public String login(HttpServletRequest request) {
        AuthenticationRequest authenticationRequest = new AuthenticationRequest(request);
        User user = authenticationService.authentication(authenticationRequest);
        request.getSession().setAttribute(USER_SESSION_KEY,user);
        return user.getUsername() + &quot;你好！&quot;;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2、测试会话的效果&lt;/p&gt;
&lt;p&gt;既然说用户认证后，我们将用户的信息保存在了服务端中，那我们就测试一下通过会话，服务端是否知道后续的操作是哪个用户呢？我们添加一个获取用户信息的接口 &lt;code&gt;/getUser&lt;/code&gt;，看是否能后查询到当前登录的用户信息&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@ResponseBody
@RequestMapping(&quot;/getUser&quot;)
public String getUser(HttpServletRequest request){
  Object object = request.getSession().getAttribute(&quot;user_&quot;);
  if (object != null){
    User user = (User) object;
    return &quot;当前访问用户为：&quot; + user.getUsername();
  }
  return &quot;匿名用户访问&quot;;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们通过客户端传递的信息，在服务端查询是否有用户信息，如果没有则是匿名用户的访问，如果有则返回该用户信息。&lt;/p&gt;
&lt;p&gt;首先在不登录下直接访问&lt;code&gt;localhost:8080/getUser&lt;/code&gt; 返回&lt;code&gt;匿名用户访问&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;登陆后再访问返回&lt;code&gt;当前访问用户为：admin&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;此时我们已经可以看到当认证通过后，后续的访问服务端通过会话机制将知道当前访问的用户是说，这将便于我们进一步处理对用户和资源的控制。&lt;/p&gt;
&lt;h3 id=&quot;14-实现授权功能&quot;&gt;1.4 实现授权功能&lt;/h3&gt;
&lt;p&gt;既然我们知道了是谁在访问用户，接下来我们将对用户访问的资源进行控制。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;匿名用户针对部分接口不可访问，提示其认证后再访问&lt;/li&gt;
&lt;li&gt;根据用户拥有的权限对资源进行操作（资源查询/资源更新）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;1、实现匿名用户不可访问。&lt;/p&gt;
&lt;p&gt;前面我们已经可以通过&lt;code&gt;/getUser&lt;/code&gt;的接口示例中知道是否是匿名用户，那接下来我们就对匿名用户进行拦截后跳转到认证页面。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class NoAuthenticationInterceptor extends HandlerInterceptorAdapter {
    private final static String USER_SESSION_KEY = &quot;user_session_key&quot;;
    // 前置拦截，在接口访问前处理
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        Object attribute = request.getSession().getAttribute(USER_SESSION_KEY);
        if (attribute == null){
            // 匿名访问 跳转到根路径下的login.html
            response.sendRedirect(&quot;/&quot;);
            return false;
        }
        return true;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后再将自定义的匿名用户拦截器，放入到&lt;code&gt;web&lt;/code&gt;容器中使其生效&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Configuration
public class WebSecurityConfig implements WebMvcConfigurer {
    // 添加自定义拦截器,保护路径/protect 下的所有接口资源
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(new     NoAuthenticationInterceptor()).addPathPatterns(&quot;/protect/**&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们保护&lt;code&gt;/protect&lt;/code&gt; 下的所有接口资源，当匿名用户访问上述接口时，都将被系统跳转到认证页面进行认证后才可以访问。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@ResponseBody
@RequestMapping(&quot;/protect/getResource&quot;)
public String protectResource(HttpServletRequest request){
  return &quot;这是非匿名用户访问的资源&quot;;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里我们就不尽兴测试页面的展示了。&lt;/p&gt;
&lt;p&gt;2、根据用户拥有的权限对资源进行操作（资源查询/资源更新）&lt;/p&gt;
&lt;p&gt;根据匿名用户处理的方式，我们此时也可设置拦截器，对接口的权限和用户的权限进行对比，通过后放行，不通过则提示。此时我们需要配置这样几个地方&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;用户所具有的权限&lt;/li&gt;
&lt;li&gt;一个权限对比的拦截器&lt;/li&gt;
&lt;li&gt;一个资源接口&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;改造用户信息，使其具有相应的权限&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class User {
    private Integer userId;
    private String username;
    private String password;
    private boolean enable;
    // 授予权限
    private Set&amp;lt;String&amp;gt; authorities;

    public User(Integer userId, String username, String password, boolean enable,Set&amp;lt;String&amp;gt; authorities) {
        this.userId = userId;
        this.username = username;
        this.password = password;
        this.enable = enable;
        this.authorities = authorities;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;重新设置用户&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private static final Map&amp;lt;String, User&amp;gt; userMap = new HashMap&amp;lt;String, User&amp;gt;() {{
  Set&amp;lt;String&amp;gt; all =new HashSet&amp;lt;&amp;gt;();
  all.add(&quot;read&quot;);
  all.add(&quot;update&quot;);
  Set&amp;lt;String&amp;gt; read = new HashSet&amp;lt;&amp;gt;();
  read.add(&quot;read&quot;);

  put(&quot;admin&quot;, new User(1, &quot;admin&quot;, &quot;admin&quot;, true,all));
  put(&quot;spring&quot;, new User(2, &quot;spring&quot;, &quot;spring&quot;, false,read));
}};
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们将&lt;code&gt;admin&lt;/code&gt;用户设置最高权限，具有&lt;code&gt;read&lt;/code&gt;和&lt;code&gt;update&lt;/code&gt;操作，&lt;code&gt;spring&lt;/code&gt;用户只具有&lt;code&gt;read&lt;/code&gt;权限&lt;/p&gt;
&lt;p&gt;权限拦截器&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class AuthenticationInterceptor extends HandlerInterceptorAdapter {
    private final static String USER_SESSION_KEY = &quot;user_session_key&quot;;
    // 前置拦截，在接口访问前处理
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        Object attribute = request.getSession().getAttribute(USER_SESSION_KEY);
        if (attribute == null) {
            writeContent(response,&quot;匿名用户不可访问&quot;);
            return false;
        } else {
            User user = ((User) attribute);
            String requestURI = request.getRequestURI();
            if (user.getAuthorities().contains(&quot;read&quot;) &amp;amp;&amp;amp; requestURI.contains(&quot;read&quot;)) {
                return true;
            }
            if (user.getAuthorities().contains(&quot;update&quot;) &amp;amp;&amp;amp; requestURI.contains(&quot;update&quot;)) {
                return true;
            }
            writeContent(response,&quot;权限不足&quot;);
            return false;
        }
    }
    //响应输出
    private void writeContent(HttpServletResponse response, String msg) throws IOException {
        response.setContentType(&quot;text/html;charset=utf‐8&quot;); PrintWriter writer = response.getWriter(); writer.print(msg);
        writer.close();
        response.resetBuffer();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在分别设置两个操作资源的接口&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@ResponseBody
@RequestMapping(&quot;/protect/update&quot;)
public String protectUpdate(HttpServletRequest request){
  return &quot;您正在更新资源信息&quot;;
}

@ResponseBody
@RequestMapping(&quot;/protect/read&quot;)
public String protectRead(HttpServletRequest request){
  return &quot;您正在获取资源信息&quot;;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启用自定义拦截器&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Configuration
public class WebSecurityConfig implements WebMvcConfigurer {
    // 添加自定义拦截器
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(new NoAuthenticationInterceptor()).addPathPatterns(&quot;/protect/**&quot;);
        registry.addInterceptor(new AuthenticationInterceptor()).addPathPatterns(&quot;/protect/**&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时我们就可以使用不同的用户进行认证后访问不同的资源来进行测试了。&lt;/p&gt;
&lt;h3 id=&quot;2、总结&quot;&gt;2、总结&lt;/h3&gt;
&lt;p&gt;当然，这仅仅是最简单的实践，特别是权限处理这一块，很多都是采取硬编码的方式处理，旨在梳理流程相关信息。而在正式的生产环境中，我们将会采取更安全更灵活更容易扩展的方式处理，同时也会使用非常实用的安全框架进行企业级认证授权的处理，例如&lt;code&gt;spring security&lt;/code&gt;，&lt;code&gt;shiro&lt;/code&gt;等安全框架，在接下来的篇幅中，我们将进入到&lt;code&gt;sping security&lt;/code&gt;的学习。加油。&lt;/p&gt;
&lt;p&gt;（完）&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Sun, 26 Apr 2020 13:08:00 +0000</pubDate>
<dc:creator>黑米面包派</dc:creator>
<og:description>用户认证通过以后，在服务端生成用户相关的数据保存在当前会话`（Session）`中，发给客户端的数据将通过`session_id `存放在`cookie`中。在后续的请求操作中，客户端将带上`sess</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wujiwen/p/12782276.html</dc:identifier>
</item>
</channel>
</rss>