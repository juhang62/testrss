<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Linux:AWK基础 - 飞翔码农</title>
<link>http://www.cnblogs.com/feixiangmanon/p/12000517.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/feixiangmanon/p/12000517.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;AWK是一个强大的文本分析工具，算是Linux系统特别有用的命令了，在日志分析、文件内容分析中扮演特别重要的角色。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;awk说明&quot;&gt;AWK说明&lt;/h3&gt;
&lt;p&gt;简单来说awk就是把文件逐行的读入，以指定的分隔符将每行分割，分割后的部分再进行各种分析处理。&lt;br/&gt;先看下AWK的命令的说明&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;10&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;$0&lt;/td&gt;
&lt;td&gt;当前记录（这个变量中存放着整个行的内容）&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;$1 $n&lt;/td&gt;
&lt;td&gt;当前记录的第n个字段，字段间由FS分隔&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;FS&lt;/td&gt;
&lt;td&gt;输入字段分隔符 默认是空格或Tab&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;NF&lt;/td&gt;
&lt;td&gt;当前记录中的字段个数，就是有多少列&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;NR&lt;/td&gt;
&lt;td&gt;已经读出的记录数，就是多少行&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;FNR&lt;/td&gt;
&lt;td&gt;当前记录数，与NR不同的是，这个值会是各个文件自己的行号&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;RS&lt;/td&gt;
&lt;td&gt;输入的记录分隔符， 默认为换行符&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;OFS&lt;/td&gt;
&lt;td&gt;输出字段分隔符， 默认也是空格&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;ORS&lt;/td&gt;
&lt;td&gt;输出的记录分隔符，默认为换行符&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;FILENAME&lt;/td&gt;
&lt;td&gt;当前输入文件的名字&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;awk使用&quot;&gt;AWK使用&lt;/h3&gt;
&lt;p&gt;看下网站access.log。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;tail -f /home/wwwlogs/access.log
148.70.179.32 - - [15/Nov/2019:05:46:28 +0800] &quot;POST /wp-cron.php?doing_wp_cron=1573767987.5338680744171142578125 HTTP/1.1&quot; 200 31 &quot;http://www.test.com.cn/wp-cron.php?doing_wp_cron=1573767987.5338680744171142578125&quot; &quot;WordPress/5.0.7; http://www.test.com.cn&quot;
220.181.108.143 - - [15/Nov/2019:05:46:28 +0800] &quot;GET / HTTP/1.1&quot; 200 5596 &quot;-&quot; &quot;Mozilla/5.0 (Linux;u;Android 4.2.2;zh-cn;) AppleWebKit/534.46 (KHTML,like Gecko) Version/5.1 Mobile Safari/10600.6.3 (compatible; Baiduspider/2.0; +http://www.baidu.com/search/spider.html)&quot;
111.206.198.18 - - [15/Nov/2019:05:46:28 +0800] &quot;GET /wp-includes/css/dist/block-library/style.min.css?ver=5.0.7 HTTP/1.1&quot; 200 25658 &quot;http://www.test.com.cn/&quot; &quot;Mozilla/5.0 (iPhone; CPU iPhone OS 9_1 like Mac OS X) AppleWebKit/601.1.46 (KHTML, like Gecko) Version/9.0 Mobile/13B143 Safari/601.1 (compatible; Baiduspider-render/2.0; +http://www.baidu.com/search/spider.html)&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;打印下访问日志的IP列表&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;awk -F&quot; &quot; '{print $1}' /home/wwwlogs/access.log
148.70.179.32
91.228.8.210
1.119.148.54
121.51.40.28
1.119.148.54
1.119.148.54&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;给IP加上文件名行列号&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;awk -F&quot; &quot; '{print FILENAME&quot;|&quot;NR&quot;|&quot;NF&quot;|&quot;$0}' /home/wwwlogs/access.log
/home/wwwlogs/access.log|9979|12|150.109.77.71
/home/wwwlogs/access.log|9980|20|150.109.77.71
/home/wwwlogs/access.log|9981|20|150.109.77.71
/home/wwwlogs/access.log|9982|22|156.220.107.221
/home/wwwlogs/access.log|9983|22|138.204.135.251
/home/wwwlogs/access.log|9984|13|148.70.179.32
/home/wwwlogs/access.log|9985|18|148.70.243.161
/home/wwwlogs/access.log|9986|18|148.70.243.161
/home/wwwlogs/access.log|9987|18|148.70.243.161
/home/wwwlogs/access.log|9988|12|201.174.10.7
/home/wwwlogs/access.log|9989|13|148.70.179.32
/home/wwwlogs/access.log|9990|23|220.181.108.143
/home/wwwlogs/access.log|9991|31|111.206.198.18
/home/wwwlogs/access.log|10000|13|170.238.36.20&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;打印访问日志的HTTP状态码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;awk -F&quot; &quot; '{print $9}' /home/wwwlogs/access.log
404
404
404
301
200
200
200
301
200
301
301
200
200
301
200
404&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;来几个复杂点的，打印下状态码分布,并按照大小排序&lt;br/&gt;···&lt;br/&gt;wk -F&quot; &quot; '{print $9}' /home/wwwlogs/access.log | sort | uniq -c | sort -nr&lt;br/&gt;4939 404&lt;br/&gt;4497 200&lt;br/&gt;332 301&lt;br/&gt;120 499&lt;br/&gt;36 400&lt;br/&gt;32 &quot;-&quot;&lt;br/&gt;18 166&lt;br/&gt;16 403&lt;br/&gt;9 405&lt;br/&gt;···&lt;br/&gt;也可以看下IP访问TOP分布，分析是否有IP爬取网站&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;awk -F&quot; &quot; '{print $1}' /home/wwwlogs/access.log | sort | uniq -c | sort -nr | head -50
    913 111.231.201.221
    912 140.143.147.236
    908 106.13.83.26
    906 54.179.142.122
    668 185.234.217.115
    664 148.70.179.32
    275 125.76.225.11
    240 123.151.144.37
    110 61.241.50.63
    108 101.89.19.140
    102 59.36.132.240
     69 182.254.52.17
     42 61.162.214.195
     39 183.192.179.16
     39 148.70.46.47
     38 14.18.182.223
     38 103.119.45.49
     27 58.251.121.186
     26 68.183.147.213
     26 59.36.119.227
     26 51.83.234.51
     24 144.91.94.150&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过日志计算下每天访问的流量，预估将来需要的带宽&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;awk -F&quot; &quot; 'BEGIN {sum=0} {sum=sum+$10} END {print sum/1024/1024&quot;M&quot;}' /home/wwwlogs/access.log
38.7885M&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;AWK的BEGIN END 说明下，这个很好理解&lt;br/&gt;BEGIN{ 执行前的语句 }&lt;br/&gt;{处理每一行执行的语句}&lt;br/&gt;END {处理完所有的行后要执行的语句 }&lt;/p&gt;
&lt;p&gt;awk在系统日常维护中应该是使用最多的命令了。也特别简单，觉大多数场景下通过AWK分析access日志就能得到想要的分析结果。&lt;/p&gt;
</description>
<pubDate>Sat, 07 Dec 2019 00:16:00 +0000</pubDate>
<dc:creator>飞翔码农</dc:creator>
<og:description>AWK是一个强大的文本分析工具，算是Linux系统特别有用的命令了，在日志分析、文件内容分析中扮演特别重要的角色。 AWK说明 简单来说awk就是把文件逐行的读入，以指定的分隔符将每行分割，分割后的部</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/feixiangmanon/p/12000517.html</dc:identifier>
</item>
<item>
<title>使用HttpReports快速搭建API分析平台 - SpringLeee</title>
<link>http://www.cnblogs.com/myshowtime/p/12000522.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/myshowtime/p/12000522.html</guid>
<description>&lt;h3 id=&quot;简单介绍&quot;&gt;简单介绍&lt;/h3&gt;
&lt;p&gt;HttpReports 是 .Net Core下的一个Web组件，适用于 WebAPI 项目和 API 网关项目，通过中间件的形式集成到您的项目中, 通过HttpReports，可以让开发人员快速的搭建出一个 API 性能分析的基础报表网站。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/SpringLeee/HttpReportsWeb/master/HttpReports.Web/wwwroot/Content/img/git/a3.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;主要包含 HttpReports 中间件 和 HttpReports.Web 报表项目：&lt;/p&gt;
&lt;p&gt;HttpReports： &lt;a href=&quot;https://github.com/SpringLeee/HttpReports&quot; class=&quot;uri&quot;&gt;https://github.com/SpringLeee/HttpReports&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;HttpReports.Web： &lt;a href=&quot;https://github.com/SpringLeee/HttpReportsWeb&quot; class=&quot;uri&quot;&gt;https://github.com/SpringLeee/HttpReportsWeb&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;如何使用&quot;&gt;如何使用&lt;/h3&gt;
&lt;h5 id=&quot;运行-httpreports.web&quot;&gt;1.运行 HttpReports.Web&lt;/h5&gt;
&lt;p&gt;在github下载 HttpReports.Web 项目，项目地址：&lt;a href=&quot;https://github.com/SpringLeee/HttpReportsWeb&quot; class=&quot;uri&quot;&gt;https://github.com/SpringLeee/HttpReportsWeb&lt;/a&gt;, Web项目是.Net Core MVC 项目，使用三层实现。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/SpringLeee/HttpReportsWeb/master/HttpReports.Web/wwwroot/Content/img/git/a1.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下载完成后，在VS中打开，然后还原NuGet程序包，完成后首先 appsettings.json&lt;/p&gt;
&lt;h4 id=&quot;appsettings.json&quot;&gt;appsettings.json&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;{
  &quot;ConnectionStrings&quot;: {
    &quot;HttpReports&quot;: &quot;Max Pool Size = 512;server=.;uid=sa;pwd=123456;database=HttpReports;&quot;
  }, 
  &quot;HttpReportsConfig&quot;: {
    &quot;DBType&quot;: &quot;SqlServer&quot;,
    &quot;UserName&quot;: &quot;admin&quot;,
    &quot;Password&quot;: &quot;123456&quot;
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;主要参数：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;HttpReports：配置一个可用的连接字符串；&lt;/li&gt;
&lt;li&gt;DBType：数据库类型，支持SqlServer和MySql;&lt;/li&gt;
&lt;li&gt;UserName: Web项目的登录名；&lt;/li&gt;
&lt;li&gt;Password: Web项目的登录密码；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;假设我们使用的是SqlServer 数据库，需要先配置ConnectionStrings，然后手动创建数据库 HttpReports（Web项目会根据数据库自动创建表，并且在第一次运行的时候Mock一些数据 ），我们直接F5运行项目， 没有问题的话，会直接跳到登录页面，输入用户名密码 admin 123456，登录后，应该可以看到下面的页面&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/SpringLeee/HttpReportsWeb/master/HttpReports.Web/wwwroot/Content/img/git/a3.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在可以看到项目有 auth,payment，sms 三个服务节点，服务节点的定义如下：&lt;/p&gt;
&lt;p&gt;如果你的项目是单个WebAPI项目，那么服务节点只有一个 default，如果你的项目是 GateWay 网关项目，那么Web项目就可以读取到多个服务节点，比如 auth 认证，payment支付等。&lt;/p&gt;
&lt;h5 id=&quot;在api项目中使用&quot;&gt;2.在API项目中使用&lt;/h5&gt;
&lt;p&gt;首先要删除 Web 项目的Mock数据，打开数据库 HttpReports，打开表 RequestInfo,清空数据，执行Sql&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  Delete * From [HttpReports].[dbo].[RequestInfo]&lt;/code&gt;
&lt;/pre&gt;
&lt;h6 id=&quot;配置数据库连接字符串&quot;&gt;配置数据库连接字符串&lt;/h6&gt;
&lt;p&gt;HttpReports 适用单个API项目和网关项目，这里使用 Ocelot网关项目为例.&lt;/p&gt;
&lt;p&gt;我们打开appsetting.json, 配置数据库连接字符串，需要和Web项目一致&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/SpringLeee/HttpReportsWeb/master/HttpReports.Web/wwwroot/Content/img/git/a6.png&quot;/&gt;&lt;/p&gt;
&lt;h6 id=&quot;nuget引用httpreports&quot;&gt;Nuget引用HttpReports&lt;/h6&gt;
&lt;p&gt;安装nuget包 &lt;strong&gt;HttpReports&lt;/strong&gt; ，打开StartUp&lt;/p&gt;
&lt;p&gt;在ConfigureServices 方法下添加：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;services.AddHttpReportsMiddlewire();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果是MySql数据库，则添加：&lt;br/&gt;&lt;code&gt;csharp services.AddHttpReportsMiddlewire(options =&amp;gt;{ options.DBType = DBType.MySql; });&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;加入到 Configure 方法 ，需要放在 app.UseMVC() 或者 app.UseOcelot().Wait() 的前面，要不然不生效&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;app.UseHttpReportsMiddlewire();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ConnectionStrings 配置的连接字符串和数据库类型要一致，全部完成了以后，我们就可以使用 Web 项目了。&lt;/p&gt;
&lt;h3 id=&quot;项目环境基本要求&quot;&gt;项目环境基本要求&lt;/h3&gt;
&lt;p&gt;WebAPI或者网关项目支持的.Net Core 版本 2.2, 3.0, 3.1;&lt;/p&gt;
&lt;p&gt;HttpReports.Web 的core版本为 2.2&lt;/p&gt;
&lt;h3 id=&quot;性能事项&quot;&gt;性能事项&lt;/h3&gt;
&lt;p&gt;HttpReports 中间件是异步操作，所以对api接口请求的时间可以忽略，但是由于实质使用的是数据库存储，所以要注意直接请求到数据库的压力。&lt;/p&gt;
&lt;p&gt;下面是用PostMan做的一个简单测试：&lt;/p&gt;
&lt;p&gt;WebAPI内的方法：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;        public string Sql1()
        {
            SqlConnection con = new SqlConnection(
                &quot;Max Pool Size = 512;server=.;uid=sa;pwd=123456;database=HyBasicData;&quot;);

            var list1 =  con.Query(&quot; select * from [HyBasicData].[dbo].[Customers] &quot;);

            var list2 = con.Query(&quot; select * from [HyBasicData].[dbo].[Customers] &quot;);

            var list3 = con.Query(&quot; select * from [HyBasicData].[dbo].[Customers] &quot;); 

            return list1.Count().ToString();
        } &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;PostMan分别对添加中间件和不添加中间件的 API请求 1000次，每300ms请求一次&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;原生API&lt;/td&gt;
&lt;td&gt;1000&lt;/td&gt;
&lt;td&gt;32.535&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;使用中间件&lt;/td&gt;
&lt;td&gt;1000&lt;/td&gt;
&lt;td&gt;32.899&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;HttpReports 的实现原理并不复杂，如果你想给你的 WebAPI项目，快速的添加一套分析系统 ，那么使用HttpReports 是一个不错的选择&lt;/p&gt;
&lt;h3 id=&quot;联系作者&quot;&gt;联系作者&lt;/h3&gt;
&lt;p&gt;如果您在使用过程中遇到了什么问题或者有好的建议的话，可以添加我的微信，希望可以帮助到您&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/SpringLeee/HttpReportsWeb/master/HttpReports.Web/wwwroot/Content/img/git/a9.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 07 Dec 2019 00:06:00 +0000</pubDate>
<dc:creator>SpringLeee</dc:creator>
<og:description>HttpReports 简单介绍 HttpReports 是 .Net Core下的一个Web组件，适用于 WebAPI 项目和 API 网关项目，通过中间件的形式集成到您的项目中, 通过HttpRe</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/myshowtime/p/12000522.html</dc:identifier>
</item>
<item>
<title>告别编码5分钟，命名2小时！史上最全的Java命名规范参考！ - 浪人~</title>
<link>http://www.cnblogs.com/liqiangchn/p/12000361.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liqiangchn/p/12000361.html</guid>
<description>&lt;p&gt;简洁清爽的代码风格应该是大多数工程师所期待的。在工作中笔者常常因为起名字而纠结，夸张点可以说是编程5分钟，命名两小时！究竟为什么命名成为了工作中的拦路虎。&lt;/p&gt;
&lt;p&gt;每个公司都有不同的标准，目的是为了保持统一，减少沟通成本，提升团队研发效能。所以本文中是笔者结合阿里巴巴开发规范，以及工作中的见闻针对Java领域相关命名进行整理和总结，仅供参考。&lt;/p&gt;
&lt;h2 id=&quot;一java中的命名规范&quot;&gt;一，Java中的命名规范&lt;/h2&gt;
&lt;p&gt;好的命名能体现出代码的特征，含义或者是用途，让阅读者可以根据名称的含义快速厘清程序的脉络。不同语言中采用的命名形式大相径庭，Java中常用到的命名形式共有三种，既首字母大写的UpperCamelCase，首字母小写的lowerCamelCase以及全部大写的并用下划线分割单词的UPPER_CAMEL_UNSER_SCORE。通常约定，&lt;strong&gt;类一般采用大驼峰命名，方法和局部变量使用小驼峰命名，而大写下划线命名通常是常量和枚举中使用。&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;7&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;项目名&lt;/td&gt;
&lt;td&gt;全部小写，多个单词用中划线分隔‘-’&lt;/td&gt;
&lt;td&gt;spring-cloud&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;包名&lt;/td&gt;
&lt;td&gt;全部小写&lt;/td&gt;
&lt;td&gt;com.alibaba.fastjson&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;类名&lt;/td&gt;
&lt;td&gt;单词首字母大写&lt;/td&gt;
&lt;td&gt;Feature, ParserConfig,DefaultFieldDeserializer&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;变量名&lt;/td&gt;
&lt;td&gt;首字母小写，多个单词组成时，除首个单词，其他单词首字母都要大写&lt;/td&gt;
&lt;td&gt;password, userName&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;常量名&lt;/td&gt;
&lt;td&gt;全部大写，多个单词，用'_'分隔&lt;/td&gt;
&lt;td&gt;CACHE_EXPIRED_TIME&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;方法&lt;/td&gt;
&lt;td&gt;同变量&lt;/td&gt;
&lt;td&gt;read(), readObject(), getById()&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;二包命名&quot;&gt;二，包命名&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;包名&lt;/strong&gt;统一使用&lt;strong&gt;小写&lt;/strong&gt;，&lt;strong&gt;点分隔符&lt;/strong&gt;之间有且仅有一个自然语义的英文单词或者多个单词自然连接到一块（如 springframework，deepspace不需要使用任何分割）。包名统一使用单数形式，如果类命有复数含义，则可以使用复数形式。&lt;/p&gt;
&lt;p&gt;包名的构成可以分为以下几四部分【前缀】 【发起者名】【项目名】【模块名】。常见的前缀可以分为以下几种：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;11&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;5&quot;&gt;&lt;td&gt;indi（或onem ）&lt;/td&gt;
&lt;td&gt;indi.发起者名.项目名.模块名.……&lt;/td&gt;
&lt;td&gt;个体项目，指个人发起，但非自己独自完成的项目，可公开或私有项目，copyright主要属于发起者。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;pers&lt;/td&gt;
&lt;td&gt;pers.个人名.项目名.模块名.……&lt;/td&gt;
&lt;td&gt;个人项目，指个人发起，独自完成，可分享的项目，copyright主要属于个人&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;5&quot;&gt;&lt;td&gt;priv&lt;/td&gt;
&lt;td&gt;priv.个人名.项目名.模块名.……&lt;/td&gt;
&lt;td&gt;私有项目，指个人发起，独自完成，非公开的私人使用的项目，copyright属于个人。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;team&lt;/td&gt;
&lt;td&gt;team.团队名.项目名.模块名.……&lt;/td&gt;
&lt;td&gt;团队项目，指由团队发起，并由该团队开发的项目，copyright属于该团队所有&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;顶级域名&lt;/td&gt;
&lt;td&gt;com.公司名.项目名.模块名.……&lt;/td&gt;
&lt;td&gt;公司项目，copyright由项目发起的公司所有&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;三类命名&quot;&gt;三，类命名&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;类名使用大驼峰命名形式&lt;/strong&gt;，类命通常时&lt;strong&gt;名词或名词短语&lt;/strong&gt;，接口名除了用名词和名词短语以外，还可以使用形容词或形容词短语，如Cloneable，Callable等，表示实现该接口的类有某种功能或能力。对于测试类则以它要测试的类开头，以Test结尾，如HashMapTest。&lt;/p&gt;
&lt;p&gt;对于一些特殊特有名词缩写也可以使用全大写命名，比如XMLHttpRequest，不过笔者认为缩写三个字母以内都大写，超过三个字母则按照要给单词算。这个没有标准如阿里巴巴中fastjson用JSONObject作为类命，而google则使用JsonObjectRequest命名，对于这种特殊的缩写，原则是统一就好。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;9&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;抽象类&lt;/td&gt;
&lt;td&gt;Abstract 或者 Base 开头&lt;/td&gt;
&lt;td&gt;BaseUserService&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;枚举类&lt;/td&gt;
&lt;td&gt;Enum 作为后缀&lt;/td&gt;
&lt;td&gt;OSType&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;工具类&lt;/td&gt;
&lt;td&gt;Utils作为后缀&lt;/td&gt;
&lt;td&gt;StringUtils&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;异常类&lt;/td&gt;
&lt;td&gt;Exception结尾&lt;/td&gt;
&lt;td&gt;RuntimeException&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;接口实现类&lt;/td&gt;
&lt;td&gt;接口名+ Impl&lt;/td&gt;
&lt;td&gt;UserServiceImpl&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;领域模型相关&lt;/td&gt;
&lt;td&gt;/DO/DTO/VO/DAO&lt;/td&gt;
&lt;td&gt;正例：UserDAO 反例： UserDo， UserDao&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;设计模式相关类&lt;/td&gt;
&lt;td&gt;Builder，Factory等&lt;/td&gt;
&lt;td&gt;当使用到设计模式时，需要使用对应的设计模式作为后缀，如ThreadFactory&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;6&quot;&gt;&lt;td&gt;处理特定功能的&lt;/td&gt;
&lt;td&gt;Handler，Predicate, Validator&lt;/td&gt;
&lt;td&gt;表示处理器，校验器，断言，这些类工厂还有配套的方法名如handle，predicate，validate&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;测试类&lt;/td&gt;
&lt;td&gt;Test结尾&lt;/td&gt;
&lt;td&gt;UserServiceTest， 表示用来测试UserService类的&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;MVC分层&lt;/td&gt;
&lt;td&gt;Controller，Service，ServiceImpl，DAO后缀&lt;/td&gt;
&lt;td&gt;UserManageController，UserManageDAO&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;四方法&quot;&gt;四，方法&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;方法命名采用小驼峰的形式&lt;/strong&gt;，首字小写，往后的每个单词首字母都要大写。 和类名不同的是，方法命名一般为&lt;strong&gt;动词或动词短语&lt;/strong&gt;，与参数或参数名共同组成动宾短语，即动词 + 名词。一个好的函数名一般能通过名字直接获知该函数实现什么样的功能。&lt;/p&gt;
&lt;h3 id=&quot;返回真伪值的方法&quot;&gt;4.1 返回真伪值的方法&lt;/h3&gt;
&lt;p&gt;注：Prefix-前缀，Suffix-后缀，Alone-单独使用&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;6&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Prefix&lt;/td&gt;
&lt;td&gt;is&lt;/td&gt;
&lt;td&gt;对象是否符合期待的状态&lt;/td&gt;
&lt;td&gt;isValid&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Prefix&lt;/td&gt;
&lt;td&gt;can&lt;/td&gt;
&lt;td&gt;对象&lt;strong&gt;能否执行&lt;/strong&gt;所期待的动作&lt;/td&gt;
&lt;td&gt;canRemove&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;Prefix&lt;/td&gt;
&lt;td&gt;should&lt;/td&gt;
&lt;td&gt;调用方执行某个命令或方法是&lt;strong&gt;好还是不好&lt;/strong&gt;,&lt;strong&gt;应不应该&lt;/strong&gt;，或者说&lt;strong&gt;推荐还是不推荐&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;shouldMigrate&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Prefix&lt;/td&gt;
&lt;td&gt;has&lt;/td&gt;
&lt;td&gt;对象&lt;strong&gt;是否持有&lt;/strong&gt;所期待的数据和属性&lt;/td&gt;
&lt;td&gt;hasObservers&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Prefix&lt;/td&gt;
&lt;td&gt;needs&lt;/td&gt;
&lt;td&gt;调用方&lt;strong&gt;是否需要&lt;/strong&gt;执行某个命令或方法&lt;/td&gt;
&lt;td&gt;needsMigrate&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;用来检查的方法&quot;&gt;4.2 用来检查的方法&lt;/h3&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;ensure&lt;/td&gt;
&lt;td&gt;检查是否为期待的状态，不是则抛出异常或返回error code&lt;/td&gt;
&lt;td&gt;ensureCapacity&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;validate&lt;/td&gt;
&lt;td&gt;检查是否为正确的状态，不是则抛出异常或返回error code&lt;/td&gt;
&lt;td&gt;validateInputs&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;按需求才执行的方法&quot;&gt;4.3 按需求才执行的方法&lt;/h3&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Suffix&lt;/td&gt;
&lt;td&gt;IfNeeded&lt;/td&gt;
&lt;td&gt;需要的时候执行，不需要的时候什么都不做&lt;/td&gt;
&lt;td&gt;drawIfNeeded&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;Prefix&lt;/td&gt;
&lt;td&gt;might&lt;/td&gt;
&lt;td&gt;同上&lt;/td&gt;
&lt;td&gt;mightCreate&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Prefix&lt;/td&gt;
&lt;td&gt;try&lt;/td&gt;
&lt;td&gt;尝试执行，失败时抛出异常或是返回errorcode&lt;/td&gt;
&lt;td&gt;tryCreate&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Suffix&lt;/td&gt;
&lt;td&gt;OrDefault&lt;/td&gt;
&lt;td&gt;尝试执行，失败时返回默认值&lt;/td&gt;
&lt;td&gt;getOrDefault&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Suffix&lt;/td&gt;
&lt;td&gt;OrElse&lt;/td&gt;
&lt;td&gt;尝试执行、失败时返回实际参数中指定的值&lt;/td&gt;
&lt;td&gt;getOrElse&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Prefix&lt;/td&gt;
&lt;td&gt;force&lt;/td&gt;
&lt;td&gt;强制尝试执行。error抛出异常或是返回值&lt;/td&gt;
&lt;td&gt;forceCreate, forceStop&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;异步相关方法&quot;&gt;4.4 异步相关方法&lt;/h3&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Prefix&lt;/td&gt;
&lt;td&gt;blocking&lt;/td&gt;
&lt;td&gt;线程阻塞方法&lt;/td&gt;
&lt;td&gt;blockingGetUser&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;Suffix&lt;/td&gt;
&lt;td&gt;InBackground&lt;/td&gt;
&lt;td&gt;执行在后台的线程&lt;/td&gt;
&lt;td&gt;doInBackground&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Suffix&lt;/td&gt;
&lt;td&gt;Async&lt;/td&gt;
&lt;td&gt;异步方法&lt;/td&gt;
&lt;td&gt;sendAsync&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Suffix&lt;/td&gt;
&lt;td&gt;Sync&lt;/td&gt;
&lt;td&gt;对应已有异步方法的同步方法&lt;/td&gt;
&lt;td&gt;sendSync&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Prefix or Alone&lt;/td&gt;
&lt;td&gt;schedule&lt;/td&gt;
&lt;td&gt;Job和Task放入队列&lt;/td&gt;
&lt;td&gt;schedule, scheduleJob&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;Prefix or Alone&lt;/td&gt;
&lt;td&gt;post&lt;/td&gt;
&lt;td&gt;同上&lt;/td&gt;
&lt;td&gt;postJob&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Prefix or Alone&lt;/td&gt;
&lt;td&gt;execute&lt;/td&gt;
&lt;td&gt;执行异步方法（注：我一般拿这个做同步方法名）&lt;/td&gt;
&lt;td&gt;execute, executeTask&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;Prefix or Alone&lt;/td&gt;
&lt;td&gt;start&lt;/td&gt;
&lt;td&gt;同上&lt;/td&gt;
&lt;td&gt;start, startJob&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Prefix or Alone&lt;/td&gt;
&lt;td&gt;cancel&lt;/td&gt;
&lt;td&gt;停止异步方法&lt;/td&gt;
&lt;td&gt;cancel, cancelJob&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;Prefix or Alone&lt;/td&gt;
&lt;td&gt;stop&lt;/td&gt;
&lt;td&gt;同上&lt;/td&gt;
&lt;td&gt;stop, stopJob&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;回调方法&quot;&gt;4.5 回调方法&lt;/h3&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Prefix&lt;/td&gt;
&lt;td&gt;on&lt;/td&gt;
&lt;td&gt;事件发生时执行&lt;/td&gt;
&lt;td&gt;onCompleted&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;Prefix&lt;/td&gt;
&lt;td&gt;before&lt;/td&gt;
&lt;td&gt;事件发生前执行&lt;/td&gt;
&lt;td&gt;beforeUpdate&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Prefix&lt;/td&gt;
&lt;td&gt;pre&lt;/td&gt;
&lt;td&gt;同上&lt;/td&gt;
&lt;td&gt;preUpdate&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;Prefix&lt;/td&gt;
&lt;td&gt;will&lt;/td&gt;
&lt;td&gt;同上&lt;/td&gt;
&lt;td&gt;willUpdate&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Prefix&lt;/td&gt;
&lt;td&gt;after&lt;/td&gt;
&lt;td&gt;事件发生后执行&lt;/td&gt;
&lt;td&gt;afterUpdate&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;Prefix&lt;/td&gt;
&lt;td&gt;post&lt;/td&gt;
&lt;td&gt;同上&lt;/td&gt;
&lt;td&gt;postUpdate&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Prefix&lt;/td&gt;
&lt;td&gt;did&lt;/td&gt;
&lt;td&gt;同上&lt;/td&gt;
&lt;td&gt;didUpdate&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Prefix&lt;/td&gt;
&lt;td&gt;should&lt;/td&gt;
&lt;td&gt;确认事件是否可以发生时执行&lt;/td&gt;
&lt;td&gt;shouldUpdate&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;操作对象生命周期的方法&quot;&gt;4.6 操作对象生命周期的方法&lt;/h3&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;initialize&lt;/td&gt;
&lt;td&gt;初始化。也可作为延迟初始化使用&lt;/td&gt;
&lt;td&gt;initialize&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;pause&lt;/td&gt;
&lt;td&gt;暂停&lt;/td&gt;
&lt;td&gt;onPause ，pause&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;stop&lt;/td&gt;
&lt;td&gt;停止&lt;/td&gt;
&lt;td&gt;onStop，stop&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;abandon&lt;/td&gt;
&lt;td&gt;销毁的替代&lt;/td&gt;
&lt;td&gt;abandon&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;destroy&lt;/td&gt;
&lt;td&gt;同上&lt;/td&gt;
&lt;td&gt;destroy&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;dispose&lt;/td&gt;
&lt;td&gt;同上&lt;/td&gt;
&lt;td&gt;dispose&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;与集合操作相关的方法&quot;&gt;4.7 与集合操作相关的方法&lt;/h3&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;6&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;contains&lt;/td&gt;
&lt;td&gt;是否持有与指定对象相同的对象&lt;/td&gt;
&lt;td&gt;contains&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;add&lt;/td&gt;
&lt;td&gt;添加&lt;/td&gt;
&lt;td&gt;addJob&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;append&lt;/td&gt;
&lt;td&gt;添加&lt;/td&gt;
&lt;td&gt;appendJob&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;insert&lt;/td&gt;
&lt;td&gt;插入到下标n&lt;/td&gt;
&lt;td&gt;insertJob&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;put&lt;/td&gt;
&lt;td&gt;添加与key对应的元素&lt;/td&gt;
&lt;td&gt;putJob&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;remove&lt;/td&gt;
&lt;td&gt;移除元素&lt;/td&gt;
&lt;td&gt;removeJob&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;enqueue&lt;/td&gt;
&lt;td&gt;添加到队列的最末位&lt;/td&gt;
&lt;td&gt;enqueueJob&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;dequeue&lt;/td&gt;
&lt;td&gt;从队列中头部取出并移除&lt;/td&gt;
&lt;td&gt;dequeueJob&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;push&lt;/td&gt;
&lt;td&gt;添加到栈头&lt;/td&gt;
&lt;td&gt;pushJob&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;pop&lt;/td&gt;
&lt;td&gt;从栈头取出并移除&lt;/td&gt;
&lt;td&gt;popJob&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;peek&lt;/td&gt;
&lt;td&gt;从栈头取出但不移除&lt;/td&gt;
&lt;td&gt;peekJob&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;find&lt;/td&gt;
&lt;td&gt;寻找符合条件的某物&lt;/td&gt;
&lt;td&gt;findById&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;与数据相关的方法&quot;&gt;4.8 与数据相关的方法&lt;/h3&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;create&lt;/td&gt;
&lt;td&gt;新创建&lt;/td&gt;
&lt;td&gt;createAccount&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;new&lt;/td&gt;
&lt;td&gt;新创建&lt;/td&gt;
&lt;td&gt;newAccount&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;from&lt;/td&gt;
&lt;td&gt;从既有的某物新建，或是从其他的数据新建&lt;/td&gt;
&lt;td&gt;fromConfig&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;to&lt;/td&gt;
&lt;td&gt;转换&lt;/td&gt;
&lt;td&gt;toString&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;update&lt;/td&gt;
&lt;td&gt;更新既有某物&lt;/td&gt;
&lt;td&gt;updateAccount&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;load&lt;/td&gt;
&lt;td&gt;读取&lt;/td&gt;
&lt;td&gt;loadAccount&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;fetch&lt;/td&gt;
&lt;td&gt;远程读取&lt;/td&gt;
&lt;td&gt;fetchAccount&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;delete&lt;/td&gt;
&lt;td&gt;删除&lt;/td&gt;
&lt;td&gt;deleteAccount&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;remove&lt;/td&gt;
&lt;td&gt;删除&lt;/td&gt;
&lt;td&gt;removeAccount&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;save&lt;/td&gt;
&lt;td&gt;保存&lt;/td&gt;
&lt;td&gt;saveAccount&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;store&lt;/td&gt;
&lt;td&gt;保存&lt;/td&gt;
&lt;td&gt;storeAccount&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;commit&lt;/td&gt;
&lt;td&gt;保存&lt;/td&gt;
&lt;td&gt;commitChange&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;apply&lt;/td&gt;
&lt;td&gt;保存或应用&lt;/td&gt;
&lt;td&gt;applyChange&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;clear&lt;/td&gt;
&lt;td&gt;清除数据或是恢复到初始状态&lt;/td&gt;
&lt;td&gt;clearAll&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;reset&lt;/td&gt;
&lt;td&gt;清除数据或是恢复到初始状态&lt;/td&gt;
&lt;td&gt;resetAll&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;成对出现的动词&quot;&gt;4.9 成对出现的动词&lt;/h3&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;get获取&lt;/td&gt;
&lt;td&gt;set 设置&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;add 增加&lt;/td&gt;
&lt;td&gt;remove 删除&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;create 创建&lt;/td&gt;
&lt;td&gt;destory 移除&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;start 启动&lt;/td&gt;
&lt;td&gt;stop 停止&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;open 打开&lt;/td&gt;
&lt;td&gt;close 关闭&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;read 读取&lt;/td&gt;
&lt;td&gt;write 写入&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;load 载入&lt;/td&gt;
&lt;td&gt;save 保存&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;create 创建&lt;/td&gt;
&lt;td&gt;destroy 销毁&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;begin 开始&lt;/td&gt;
&lt;td&gt;end 结束&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;backup 备份&lt;/td&gt;
&lt;td&gt;restore 恢复&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;import 导入&lt;/td&gt;
&lt;td&gt;export 导出&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;split 分割&lt;/td&gt;
&lt;td&gt;merge 合并&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;inject 注入&lt;/td&gt;
&lt;td&gt;extract 提取&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;attach 附着&lt;/td&gt;
&lt;td&gt;detach 脱离&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;bind 绑定&lt;/td&gt;
&lt;td&gt;separate 分离&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;view 查看&lt;/td&gt;
&lt;td&gt;browse 浏览&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;edit 编辑&lt;/td&gt;
&lt;td&gt;modify 修改&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;select 选取&lt;/td&gt;
&lt;td&gt;mark 标记&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;copy 复制&lt;/td&gt;
&lt;td&gt;paste 粘贴&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;undo 撤销&lt;/td&gt;
&lt;td&gt;redo 重做&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;insert 插入&lt;/td&gt;
&lt;td&gt;delete 移除&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;add 加入&lt;/td&gt;
&lt;td&gt;append 添加&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;clean 清理&lt;/td&gt;
&lt;td&gt;clear 清除&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;index 索引&lt;/td&gt;
&lt;td&gt;sort 排序&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;find 查找&lt;/td&gt;
&lt;td&gt;search 搜索&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;increase 增加&lt;/td&gt;
&lt;td&gt;decrease 减少&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;play 播放&lt;/td&gt;
&lt;td&gt;pause 暂停&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;launch 启动&lt;/td&gt;
&lt;td&gt;run 运行&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;compile 编译&lt;/td&gt;
&lt;td&gt;execute 执行&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;debug 调试&lt;/td&gt;
&lt;td&gt;trace 跟踪&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;observe 观察&lt;/td&gt;
&lt;td&gt;listen 监听&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;build 构建&lt;/td&gt;
&lt;td&gt;publish 发布&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;input 输入&lt;/td&gt;
&lt;td&gt;output 输出&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;encode 编码&lt;/td&gt;
&lt;td&gt;decode 解码&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;encrypt 加密&lt;/td&gt;
&lt;td&gt;decrypt 解密&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;compress 压缩&lt;/td&gt;
&lt;td&gt;decompress 解压缩&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;pack 打包&lt;/td&gt;
&lt;td&gt;unpack 解包&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;parse 解析&lt;/td&gt;
&lt;td&gt;emit 生成&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;connect 连接&lt;/td&gt;
&lt;td&gt;disconnect 断开&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;send 发送&lt;/td&gt;
&lt;td&gt;receive 接收&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;download 下载&lt;/td&gt;
&lt;td&gt;upload 上传&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;refresh 刷新&lt;/td&gt;
&lt;td&gt;synchronize 同步&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;update 更新&lt;/td&gt;
&lt;td&gt;revert 复原&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;lock 锁定&lt;/td&gt;
&lt;td&gt;unlock 解锁&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;check out 签出&lt;/td&gt;
&lt;td&gt;check in 签入&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;submit 提交&lt;/td&gt;
&lt;td&gt;commit 交付&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;push 推&lt;/td&gt;
&lt;td&gt;pull 拉&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;expand 展开&lt;/td&gt;
&lt;td&gt;collapse 折叠&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;begin 起始&lt;/td&gt;
&lt;td&gt;end 结束&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;start 开始&lt;/td&gt;
&lt;td&gt;finish 完成&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;enter 进入&lt;/td&gt;
&lt;td&gt;exit 退出&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;abort 放弃&lt;/td&gt;
&lt;td&gt;quit 离开&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;obsolete 废弃&lt;/td&gt;
&lt;td&gt;depreciate 废旧&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;collect 收集&lt;/td&gt;
&lt;td&gt;aggregate 聚集&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;五变量常量命名&quot;&gt;五，变量&amp;amp;常量命名&lt;/h2&gt;
&lt;h3 id=&quot;变量命名&quot;&gt;5.1 变量命名&lt;/h3&gt;
&lt;p&gt;变量是指在程序运行中可以改变其值的量，包括成员变量和局部变量。变量名由多单词组成时，第一个单词的首字母小写，其后单词的首字母大写，俗称骆驼式命名法（也称驼峰命名法），如 computedValues，index、变量命名时，尽量简短且能清楚的表达变量的作用，命名体现具体的业务含义即可。&lt;/p&gt;
&lt;p&gt;变量名不应以下划线或美元符号开头，尽管这在语法上是允许的。变量名应简短且富于描述。变量名的选用应该易于记忆，即，能够指出其用途。尽量避免单个字符的变量名，除非是一次性的临时变量。pojo中的布尔变量，都不要加is(数据库中的布尔字段全都要加 is_ 前缀)。&lt;/p&gt;
&lt;h3 id=&quot;常量命名&quot;&gt;5.2 常量命名&lt;/h3&gt;
&lt;p&gt;常量命名CONSTANT_CASE，一般采用全部大写（作为方法参数时除外），单词间用下划线分割。那么什么是常量呢？&lt;/p&gt;
&lt;p&gt;常量是在作用域内保持不变的值，一般使用final进行修饰。一般分为三种，全局常量（public static final修饰），类内常量（private static final 修饰）以及局部常量（方法内，或者参数中的常量），局部常量比较特殊，通常采用小驼峰命名即可。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 一个demo
 *
 * @author Jann Lee
 * @date 2019-12-07 00:25
 **/
public class HelloWorld {

    /**
     * 局部常量(正例)
     */
    public static final long USER_MESSAGE_CACHE_EXPIRE_TIME = 3600;
    
      /**
     * 局部常量(反例，命名不清晰）
     */
    public static final long MESSAGE_CACHE_TIME = 3600;
    
    /**
     * 全局常量
     */
    private static final String ERROR_MESSAGE = &quot; error message&quot;;

    /**
     * 成员变量
     */
    private int currentUserId;

    /**
     * 控制台打印 {@code message} 信息
     * 
     * @param message 消息体，局部常量
     */
    public void sayHello(final String message){
        System.out.println(&quot;Hello world!&quot;);
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;常量一般都有自己的业务含义,&lt;strong&gt;不要害怕长度过长而进行省略或者缩写&lt;/strong&gt;。如，用户消息缓存过期时间的表示，那种方式更佳清晰，交给你来评判。&lt;/p&gt;
&lt;h2 id=&quot;通用命名规则&quot;&gt;通用命名规则&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;尽量不要使用拼音；杜绝拼音和英文混用。对于一些通用的表示或者难以用英文描述的可以采用拼音，一旦采用拼音就坚决不能和英文混用。&lt;br/&gt;正例： BeiJing， HangZhou&lt;br/&gt;反例： validateCanShu&lt;/li&gt;
&lt;li&gt;命名过程中尽量不要出现特殊的字符，常量除外。&lt;/li&gt;
&lt;li&gt;尽量不要和jdk或者框架中已存在的类重名，也不能使用java中的关键字命名。&lt;/li&gt;
&lt;li&gt;妙用介词，如for(可以用同音的4代替), to(可用同音的2代替), from, with，of等。&lt;br/&gt;如类名采用UserService4MySqlDAO，方法名getUserInfoFromRedis，convertJson2Map等。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;六代码注解&quot;&gt;六，代码注解&lt;/h2&gt;
&lt;h3 id=&quot;注解的原则&quot;&gt;6.1 注解的原则&lt;/h3&gt;
&lt;p&gt;好的命名增加代码阅读性，代码的命名往往有严格的限制。而注解不同，程序员往往可以自由发挥，单并不意味着可以为所欲为之胡作非为。优雅的注解通常要满足三要素。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Nothing is strange&lt;br/&gt;没有注解的代码对于阅读者非常不友好，哪怕代码写的在清除，阅读者至少从心理上会有抵触，更何况代码中往往有许多复杂的逻辑，所以一定要写注解，不仅要记录代码的逻辑，还有说清楚修改的逻辑。&lt;/li&gt;
&lt;li&gt;Less is more&lt;br/&gt;从代码维护角度来讲，代码中的注解一定是精华中的精华。合理清晰的命名能让代码易于理解，对于逻辑简单且命名规范，能够清楚表达代码功能的代码不需要注解。滥用注解会增加额外的负担，更何况大部分都是废话。&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 根据id获取信息【废话注解】
getMessageById(id)&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;Advance with the time&lt;br/&gt;注解应该随着代码的变动而改变，注解表达的信息要与代码中完全一致。通常情况下修改代码后一定要修改注解。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;注解格式&quot;&gt;6.2 注解格式&lt;/h3&gt;
&lt;p&gt;注解大体上可以分为两种，一种是javadoc注解，另一种是简单注解。javadoc注解可以生成JavaAPI为外部用户提供有效的支持javadoc注解通常在使用IDEA，或者Eclipse等开发工具时都可以自动生成，也支持自定义的注解模板，仅需要对对应的字段进行解释。参与同一项目开发的同学，尽量设置成相同的注解模板。&lt;/p&gt;
&lt;h4 id=&quot;类注接&quot;&gt;6.2.1 类注接&lt;/h4&gt;
&lt;p&gt;javadoc注解中，每个类都必须有注解。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
* Copyright (C), 2019-2020, Jann  balabala...
*
* 类的介绍：这是一个用来做什么事情的类，有哪些功能，用到的技术.....
*
* @author   类创建者姓名 保持对齐
* @date     创建日期 保持对齐
* @version  版本号 保持对齐
*/
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;属性注解&quot;&gt;6.2.2 属性注解&lt;/h4&gt;
&lt;p&gt;在每个属性前面必须加上属性注释，通常有一下两种形式，至于怎么选择，你高兴就好，不过一个项目中要保持统一。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/** 提示信息 */
private String userName;
/**
 * 密码
 */
private String password;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;方法注释&quot;&gt;6.2.3 方法注释&lt;/h4&gt;
&lt;p&gt;在每个方法前面必须加上方法注释，对于方法中的每个参数，以及返回值都要有说明。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
  * 方法的详细说明，能干嘛，怎么实现的，注意事项...
  *
  * @param xxx   参数1的使用说明， 能否为null
  * @return 返回结果的说明， 不同情况下会返回怎样的结果
  * @throws 异常类型   注明从此类方法中抛出异常的说明
  */&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;构造方法注释&quot;&gt;6.2.4 构造方法注释&lt;/h4&gt;
&lt;p&gt;在每个构造方法前面必须加上注释，注释模板如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
  * 构造方法的详细说明
  *
  * @param xxx   参数1的使用说明， 能否为null
  * @throws 异常类型   注明从此类方法中抛出异常的说明
  */&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而简单注解往往是需要工程师字节定义，在使用注解时应该注意一下几点：&lt;/p&gt;
&lt;ol readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;枚举类的各个属性值都要使用注解，枚举可以理解为是常量，通常不会发生改变，通常会被在多个地方引用，对枚举的修改和添加属性通常会带来很大的影响。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;保持排版整洁，不要使用行尾注释；双斜杠和星号之后要用1个空格分隔。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;int id = 1;// 反例：不要使用行尾注释
//反例：换行符与注释之间没有缩进
int age = 18;
// 正例：姓名
String name;
/**
 * 多行注释123
 * 2333333
 */
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;参考文献：&lt;/p&gt;
&lt;p&gt;《码出高效》&lt;/p&gt;
&lt;p&gt;https://www.cnblogs.com/wangcp-2014/p/10215620.html&lt;/p&gt;
&lt;p&gt;https://qiita.com/KeithYokoma/items/2193cf79ba76563e3db6&lt;/p&gt;
&lt;p&gt;https://google.github.io/styleguide/javaguide.html#s2.1-file-name&lt;/p&gt;
&lt;p&gt;&lt;code&gt;如果你想要在技术上有所成就，想要结识志同道合的朋友，可以关注笔者的wx公众号 cruder，大家一起进步&lt;/code&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1055780/201912/1055780-20191207013122697-2079009804.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 06 Dec 2019 17:31:00 +0000</pubDate>
<dc:creator>浪人~</dc:creator>
<og:description>简洁清爽的代码风格应该是大多数工程师所期待的。在工作中笔者常常因为起名字而纠结，夸张点可以说是编程5分钟，命名两小时！究竟为什么命名成为了工作中的拦路虎。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/liqiangchn/p/12000361.html</dc:identifier>
</item>
<item>
<title>伪共享 FalseSharing (CacheLine，MESI) 浅析以及解决方案 - csonezp</title>
<link>http://www.cnblogs.com/csonezp/p/11997194.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/csonezp/p/11997194.html</guid>
<description>&lt;p&gt;在阅读百度的发号器 &lt;a href=&quot;https://github.com/baidu/uid-generator&quot; target=&quot;_blank&quot;&gt;uid-generator&lt;/a&gt; 源码的过程中，发现了一段很奇怪的代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * Represents a padded {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; AtomicLong} to prevent the FalseSharing problem&amp;lt;p&amp;gt;
 * 
 * The CPU cache line commonly be 64 bytes, here is a sample of cache line after padding:&amp;lt;br&amp;gt;
 * 64 bytes = 8 bytes (object reference) + 6 * 8 bytes (padded long) + 8 bytes (a long value)
 * 
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; yutianbao
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; PaddedAtomicLong &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; AtomicLong {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; serialVersionUID = -3415778863941386253L&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; Padded 6 long (48 bytes) &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; &lt;span&gt;p1, p2, p3, p4, p5, p6&lt;/span&gt; = 7L&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Constructors from {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; AtomicLong}
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; PaddedAtomicLong() {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;();
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; PaddedAtomicLong(&lt;span&gt;long&lt;/span&gt;&lt;span&gt; initialValue) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(initialValue);
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里面有6个看上去毫无作用的volatile long变量（标红）。如果这是我自己写的代码，我肯定会认为是我自己手抖写多了。&lt;/p&gt;
&lt;p&gt;但是作为百度的发号器，开源了这么久，如果是手抖早被fix了。肯定还是有深意的。于是阅读了一些类注释，看到了这句话：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;pre&gt;
to prevent the FalseSharing problem
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt;果然，这几个变量不是毫无作用的，是为了解决FalseSharing问题。&lt;/p&gt;
&lt;p&gt;但是转念一想，我好像不知道什么是FalseSharing？解决了一个问题，又陷入了另一个更大的问题。&lt;/p&gt;
&lt;p&gt;于是就上网查了很多资料，阅读了很多博客，算是对FalseSharing有了一个初步的了解。在这里写出来也为了希望能帮到有同样困惑的人。&lt;/p&gt;

&lt;p&gt;要说清楚FalseSharing，不是一两句话能做到的事，有一些必须了解的背景知识需要补充一下。&lt;/p&gt;



&lt;h2&gt;计算机存储架构&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/424424/201912/424424-20191206190114942-308342973.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;上图展示的是不同层级的硬件和cpu之间的交互延迟。越靠近CPU，速度越快。&lt;/p&gt;
&lt;p&gt;计算机运行时，CPU是执行指令的地方，而指令会需要一些数据的读写。程序的运行时数据都是存放在主存的，而主存又特别慢（相对），所以为了解决CPU和主存之间的速度差异，现代计算机都引入了高速缓存（L1L2L3）。&lt;/p&gt;

&lt;p&gt;现代计算机对缓存/内存的设计一般如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/424424/201912/424424-20191206190414883-89128598.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;L1和L2由CPU的每个核心独享，而L3则被整个CPU里所有核心共享（仅指单CPU架构）。&lt;/p&gt;
&lt;p&gt;CPU访问数据时，按照先去L1，查不到去L2，再L3-&amp;gt;主存的顺序来查找。&lt;/p&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt;Cache Line&lt;/h2&gt;

&lt;p&gt;在上述CPU和缓存的数据交换过程中，并不是以字节为单位的。而是每次都会以Cache Line为单位来进行存取。&lt;/p&gt;
&lt;p&gt;Cache Line其实就是一段固定大小的内存空间，一般为64字节。&lt;/p&gt;

&lt;h2&gt;MESI&lt;/h2&gt;
&lt;p&gt;这个东西研究过 volatile的同学可能会比较熟悉，这个就是各个告诉缓存之间的一个一致性协议。&lt;/p&gt;
&lt;p&gt;因为L1 L2是每个核心自己使用，而不同核心又可能涉及共享变量问题，所以各个高速缓存间势必会有一致性的问题。MESI就是解决这些问题的一种方式。&lt;/p&gt;
&lt;p&gt;MESI大致原理如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/424424/201912/424424-20191206191549218-1249737943.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 我这里就摘抄一下网上搜到的解释：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;在MESI协议中，每个Cache line有4个状态，可用2个bit表示，它们分别是：&lt;br/&gt;M(Modified)：这行数据有效，数据被修改了，和内存中的数据不一致，数据只存在于本Cache中；&lt;br/&gt;E(Exclusive)：这行数据有效，数据和内存中的数据一致，数据只存在于本Cache中；&lt;br/&gt;S(Shared)：这行数据有效，数据和内存中的数据一致，数据存在于很多Cache中；&lt;br/&gt;I(Invalid)：这行数据无效。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;通俗一点说，就是如果Core0和Core1都在使用一个共享变量变量A，则0，1都会在自己的Cache里有一份A的副本，分布在不同的CacheLine。&lt;/p&gt;
&lt;p&gt;如果大家都没有修改A，则Core0和Core1里变量A所在的Cache Line的状态都是S。&lt;/p&gt;
&lt;p&gt;如果Core0修改了A的值，则此时Core0的Cache Line变为M，Core1 的Cache Line变为I。&lt;/p&gt;

&lt;p&gt;这样CPU就可以通过CacheLine的状态，来决定是删除缓存，还是直接读取什么的。&lt;/p&gt;


&lt;p&gt;背景知识介绍完毕了，这样再说伪共享就不会显得太难以理解了。&lt;/p&gt;

&lt;p&gt;先说一个场景：&lt;/p&gt;
&lt;p&gt;你的代码里需要使用一个volatile的Bool变量，当做多线程行为的一个开关：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; flag = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 10; i++&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt;&lt;span&gt; {
                Integer count &lt;/span&gt;= 0&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (flag) {
                    &lt;/span&gt;++&lt;span&gt;count;
                    System.out.println(Thread.currentThread().getName() &lt;/span&gt;+ &quot;:&quot; +&lt;span&gt; count);
                    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                        Thread.sleep(&lt;/span&gt;100&lt;span&gt;);
                    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }).start();
        }

        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                Thread.sleep(&lt;/span&gt;1000&lt;span&gt;);
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
                e.printStackTrace();
            }
            flag &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

        }).start();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这段代码会声明一个flag为true，然后有10个工作线程会在flag为true时没100ms对count做个自增操作，然后输出。当flag为false时，就会结束线程。&lt;/p&gt;
&lt;p&gt;还有一个线程A，会在1000ms后将flag置为false。&lt;/p&gt;
&lt;p&gt;这里就是volatile的一个经典用法，可以保证多个线程对flag的可见性，不会因为线程A修改了flag的值，但是工作线程读取到的不是最新值而额外执行一些工作。&lt;/p&gt;

&lt;p&gt;这段代码看起来是没有任何问题的，实际上跑起来也没有问题。&lt;/p&gt;
&lt;p&gt;但是结合之前的背景知识，考虑一下flag所在的cache line，肯定还会有其他的变量（cache line 64字节，bool无法完整填充一个CacheLine）。&lt;/p&gt;
&lt;p&gt;如果flag所在的CacheLine里还有一个频繁修改的共享变量，这时会发生什么？&lt;/p&gt;
&lt;p&gt;很简单，就是flag所在的CacheLine被频繁置为不可用，需要清除缓存重新读取。flag在工作状态并没有被修改，但是仍然会被其他频繁修改的共享变量所影响。&lt;/p&gt;
&lt;p&gt;这样就会带来一个问题，即使flag并没有被修改，但我们的工作线程很多时间都等于是在主存中读取flag的值，这样在高并发时会带来很大的效率问题。&lt;/p&gt;

&lt;p&gt;以上就是所谓的 “FalseSharing” 问题。&lt;/p&gt;



&lt;p&gt;FalseSharing对于普通业务应用，基本没什么实际影响。但是对于很多超高并发的中间件（例如发号器），可能就会带来一定的性能瓶颈。所以这类项目都是需要关注这个问题的。&lt;/p&gt;
&lt;p&gt;出现原因已经说清楚了，那么该如何解决呢？&lt;/p&gt;
&lt;p&gt;其实答案就在文章的开头，那6个看上去没有任何含义的volatile long变量，就是用来解决这个问题的。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;The CPU cache line commonly be 64 bytes, here is a sample of cache line after padding:64 bytes = 8 bytes (object reference) + 6 * 8 bytes (padded long) + 8 bytes (a long value)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt; 这行注释就说明了这6个变量是如何解决FalseSharing问题的：&lt;/p&gt;
&lt;p&gt;CacheLine一般是64字节，64 = 8（对象本身的属性信息）+ 6*8（long占用8个字节） + 8 （AtomicLong本身带有一个long） 。&lt;/p&gt;
&lt;p&gt;写了这6个看着无效的变量后，PaddedAtomicLong就会占用64个字节，正好填满一个CacheLine，这样就会被独自分配到一个CacheLine，这样就不存在FalseSharing问题了。&lt;/p&gt;

&lt;p&gt;需要注意的是本来AtomicLong仅占用不到20字节，但是为了解决FalseSharing做了填充之后就占用64字节了，这样就会导致空间会膨胀很多。所以即使用的时候也要做好取舍。&lt;/p&gt;

</description>
<pubDate>Fri, 06 Dec 2019 16:46:00 +0000</pubDate>
<dc:creator>csonezp</dc:creator>
<og:description>起因 在阅读百度的发号器&amp;#160;uid-generator&amp;#160;源码的过程中，发现了一段很奇怪的代码： 这里面有6个看上去毫无作用的volatile long变量（标红）。如果这是我自己写的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/csonezp/p/11997194.html</dc:identifier>
</item>
<item>
<title>【小作业】为NLog自定义LayoutRenderer - nodotnet</title>
<link>http://www.cnblogs.com/JulianHuang/p/12000310.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/JulianHuang/p/12000310.html</guid>
<description>&lt;h3&gt;长话短说&lt;/h3&gt;
&lt;p&gt;　　前文《&lt;a class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/JulianHuang/p/11982021.html&quot;&gt;解剖HttpClientFactory，自由扩展HttpMessageHandler&lt;/a&gt;》主要想讲如何扩展&lt;em&gt;HttpMessageHandler&lt;/em&gt;,  示例为在每个Http请求中的日志中显示TraceId，&lt;/p&gt;
&lt;p&gt;现在来完成课后的小作业： 将TraceId显示到Nlog的LayoutRenderer上。&lt;/p&gt;
&lt;p&gt;本次重新实现一个流畅简单的  LoggingHttpMessageHandler， 并添加到NLog LayoutRenderer。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt; 什么是Layout Renderer？&lt;/p&gt;
&lt;p&gt; nlog 日志上显示的特定字段，便于检索和分类。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;头脑风暴&lt;/h3&gt;
&lt;p&gt;先给出自定义Renderer，定义名为&lt;span&gt;eqid&lt;/span&gt;的自定义Renderer&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;# 截取自 nlog.config配置文件
&lt;/span&gt;&amp;lt;variable name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;format1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;${date:format=yy/MM/dd HH\:mm\:ss} [${level}].[${logger}].[${threadid}}].[${aspnet-request-url:IncludeScheme=false:IncludeHost=false}].[&lt;span&gt;&lt;strong&gt;${eqid}&lt;/strong&gt;&lt;/span&gt;]${newline}${message} ${exception:format=tostring}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;

&amp;lt;target name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bce-request&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
           xsi:type&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;File&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
           layout&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;${format1}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
           fileName&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;${logDir}/bce-request.log&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
           encoding&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;/&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;-------------------------------&lt;span&gt;1&lt;/span&gt;----------------------------&lt;/p&gt;
&lt;p&gt; Nlog 添加自定义LayOutRenderer, &lt;a href=&quot;https://github.com/NLog/NLog/wiki/How-to-write-a-custom-layout-renderer&quot;&gt;https://github.com/NLog/NLog/wiki/How-to-write-a-custom-layout-renderer&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　有简单的lambda方式，这里我们采用稍微灵活的自定义类方式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 [LayoutRenderer(&quot;eqid&quot;&lt;span&gt;)]
    public class&lt;span&gt;&lt;span&gt; EqidLayoutRenderer&lt;/span&gt; : LayoutRenderer
    {
        protected override void&lt;span&gt; Append(StringBuilder builder, LogEventInfo logEvent)
        {
            builder.Append(logEvent.Properties[&quot;EventId_Name&quot;&lt;span&gt;].ToString());
        }
    }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;关键点是实现 LayoutRenderer 的抽象方法 Append,  关键参数logevent由写入Logging时形成。&lt;/p&gt;
&lt;p&gt;从EventId.Name中为eqid renderer取值的原因如步骤2&lt;/p&gt;
&lt;p&gt;---------------------------------&lt;span&gt;2&lt;/span&gt;-----------------------------&lt;/p&gt;
&lt;p&gt;配合着，我们在写入日志时， 也在该property 中写入该Renderer的值：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AttachTraceIdScopeHttpMessageHandler : DelegatingHandler
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; ILogger _logger;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; AttachTraceIdScopeHttpMessageHandler(ILogger logger)
        {
            _logger &lt;/span&gt;= logger ?? &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ArgumentNullException(nameof(logger));
        }

        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;HttpResponseMessage&amp;gt;&lt;span&gt; SendAsync(HttpRequestMessage request,
            CancellationToken cancellationToken)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (request == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ArgumentNullException(nameof(request));
            }

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; stopwatch =&lt;span&gt; Stopwatch.StartNew();
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; eventName = request.RequestUri.LocalPath.Split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).LastOrDefault();

            _logger.Log(LogLevel.Information, &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; EventId(&lt;span&gt;100&lt;/span&gt;&lt;span&gt;, eventName),
                $&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Start processing HTTP request {request.RequestUri} {request.Method}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; response = &lt;span&gt;await&lt;/span&gt; &lt;span&gt;base&lt;/span&gt;&lt;span&gt;.SendAsync(request, cancellationToken);
            stopwatch.Stop();
            _logger.Log(LogLevel.Information, &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; EventId(&lt;span&gt;101&lt;/span&gt;&lt;span&gt;, eventName),
                $&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;End processing HTTP request after {stopwatch.Elapsed.TotalMilliseconds}ms - {response.StatusCode}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; response;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;EventId 中的Name属性，最后在 nlog的 EventLogInfo中被认定为 Property[EventId_Name], 所以我们有以上操作。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;按照上文方式，添加到 CustomHttpMessageHandlerFilter，并注册为 IHttpMessageHandlerFilter 实现。&lt;/p&gt;

&lt;p&gt;-------------------------------&lt;span&gt;-&lt;span&gt;3&lt;/span&gt;-&lt;/span&gt;-----------------------&lt;/p&gt;
&lt;p&gt;按照文档的要求，尽量早点注册自定义Nlog LayoutRenderer，&lt;/p&gt;
&lt;p&gt;因此我在 main函数开始的时候就注册了该Renderer, 注册名称是TraceId&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
{
            LayoutRenderer.Register&lt;/span&gt;&amp;lt;&lt;span&gt;EqidLayoutRenderer&lt;/span&gt;&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;eqid&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
......
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最终输出如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;19&lt;/span&gt;/&lt;span&gt;12&lt;/span&gt;/&lt;span&gt;07&lt;/span&gt; &lt;span&gt;00&lt;/span&gt;:&lt;span&gt;35&lt;/span&gt;:&lt;span&gt;42&lt;/span&gt; [Info].[System.Net.Http.HttpClient.bce-request.LogicalHandler].[&lt;span&gt;19&lt;/span&gt;&lt;span&gt;}].[].[&lt;span&gt;125aa91f0011426c000000045dea5ea0&lt;/span&gt;]
Start processing HTTP request http:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;localhost:5000/v1/eqid/125aa91f0011426c000000045dea5ea0 GET &lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;/&lt;span&gt;12&lt;/span&gt;/&lt;span&gt;07&lt;/span&gt; &lt;span&gt;00&lt;/span&gt;:&lt;span&gt;35&lt;/span&gt;:&lt;span&gt;44&lt;/span&gt; [Info].[System.Net.Http.HttpClient.bce-request.LogicalHandler].[&lt;span&gt;5&lt;/span&gt;&lt;span&gt;}].[].[&lt;span&gt;125aa91f0011426c000000045dea5ea0&lt;/span&gt;]
End processing HTTP request after &lt;/span&gt;&lt;span&gt;2178&lt;/span&gt;.9971ms - OK 
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;ok, 运行本文示例，请务必参阅 《&lt;a class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/JulianHuang/p/11982021.html&quot;&gt;解剖HttpClientFactory，自由扩展HttpMessageHandler&lt;/a&gt;》思路，本文主要目的是讲解 自定义Nlog LayoutRenderer.&lt;/p&gt;

</description>
<pubDate>Fri, 06 Dec 2019 16:38:00 +0000</pubDate>
<dc:creator>nodotnet</dc:creator>
<og:description>长话短说 前文《解剖HttpClientFactory，自由扩展HttpMessageHandler》主要想讲如何扩展HttpMessageHandler, 示例为在每个Http请求中的日志中显示Tr</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/JulianHuang/p/12000310.html</dc:identifier>
</item>
<item>
<title>python基础-并发编程part01 - 格桑_哈哈</title>
<link>http://www.cnblogs.com/xiaodan1040/p/12000239.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaodan1040/p/12000239.html</guid>
<description>&lt;h4 id=&quot;并发编程&quot;&gt;并发编程&lt;/h4&gt;
&lt;p&gt;操作系统发展史&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;穿孔卡片
&lt;ul&gt;&lt;li&gt;读取数据速度特别慢，CPU利用率极低&lt;/li&gt;
&lt;li&gt;单用户使用&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;批处理
&lt;ul&gt;&lt;li&gt;读取数据速度特别慢，CPU利用率极低&lt;/li&gt;
&lt;li&gt;联机使用&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;脱机批处理(现代操作系统的设计原理)
&lt;ul&gt;&lt;li&gt;读取数据速度提高&lt;/li&gt;
&lt;li&gt;CPU的利用率提高&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;多道技术（基于单核背景下产生的）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;单道（串行）：一个任务完完整整地运行完毕后，才能运行下一个任务&lt;/li&gt;
&lt;li&gt;多道技术：允许多个程序同时进入内存并运行。同时把多个程序放入内存，并允许它们交替在CPU中运行，它们共享系统中的各种硬、软件资源。当一道程序因I/O请求而暂停运行时，CPU便立即转去运行另一道程序。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;多道技术的实现是为了解决多个程序竞争或者说共享同一个资源的有序调度问题&lt;/strong&gt;，解决方式即&lt;strong&gt;多路复用&lt;/strong&gt;，多路复用分为时间上的复用和空间上的复用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;并发与并行&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;并发：是&lt;strong&gt;伪并行&lt;/strong&gt;，即看起来是同时运行。&lt;strong&gt;单个CPU+多道技术&lt;/strong&gt;就可以实现并发&lt;/li&gt;
&lt;li&gt;并行：同时运行，只有&lt;strong&gt;具备多个CPU才能实现并行&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;无论是并行还是并发，在用户看来都是“同时”运行的。不管是进程还是线程，都只是一个任务而已，真正工作的只有CPU。一个CPU同一时刻只能执行一个任务。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;程序、进程和线程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;程序：一系列代码文件组成&lt;/p&gt;
&lt;p&gt;进程：&lt;strong&gt;一个正在运行的程序的一个实例&lt;/strong&gt;。包括程序代码和当前的活动&lt;/p&gt;
&lt;p&gt;线程：&lt;strong&gt;CPU可使用的最基本单元。 也成为轻量级进程。线程是进程中的一个实体&lt;/strong&gt;。 线程是进程中的指令序列，其行为类似于进程。&lt;strong&gt;不同于进程是因为它没有自己的程序控制块&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;ps：通常，&lt;strong&gt;在进程中创建多线程。线程在进程内执行，进程在操作系统内核中执行&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;进程的三种状态&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;就绪态：具备运行的所有条件，逻辑上可以运行，等待CPU处理&lt;/p&gt;
&lt;p&gt;等待(阻塞)态：等待某一事件&lt;/p&gt;
&lt;p&gt;运行态：正在占用处理器运行&lt;/p&gt;
&lt;p&gt;进程调度&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;先来先服务调度算法。缺点：执行效率低&lt;/li&gt;
&lt;li&gt;短作业优先调度算法，执行时间越短，则优先调度。缺点：导致执行时间长的程序，需要等待所有时间短的程序执行完毕后，才能执行&lt;/li&gt;
&lt;li&gt;时间片轮转法&lt;/li&gt;
&lt;li&gt;多级反馈队列&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;同步与异步&lt;/strong&gt;？&lt;/p&gt;
&lt;p&gt;同步：？&lt;/p&gt;
&lt;p&gt;异步：？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;阻塞与非阻塞&lt;/strong&gt;？&lt;/p&gt;
&lt;p&gt;阻塞：凡是遇到IO都会阻塞&lt;/p&gt;
&lt;p&gt;非阻塞：除了IO都是非阻塞&lt;/p&gt;
</description>
<pubDate>Fri, 06 Dec 2019 16:00:00 +0000</pubDate>
<dc:creator>格桑_哈哈</dc:creator>
<og:description>并发编程 操作系统发展史 穿孔卡片 读取数据速度特别慢，CPU利用率极低 单用户使用 批处理 读取数据速度特别慢，CPU利用率极低 联机使用 脱机批处理(现代操作系统的设计原理) 读取数据速度提高 C</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiaodan1040/p/12000239.html</dc:identifier>
</item>
<item>
<title>【并发编程】Object的wait、notify和notifyAll方法 - 写代码的木公</title>
<link>http://www.cnblogs.com/54chensongxia/p/11995981.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/54chensongxia/p/11995981.html</guid>
<description>&lt;hr/&gt;&lt;p&gt;本博客系列是学习并发编程过程中的记录总结。由于文章比较多，写的时间也比较散，所以我整理了个目录贴（传送门），方便查阅。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/54chensongxia/p/11935423.html&quot;&gt;并发编程系列博客传送门&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;方法简介&quot;&gt;方法简介&lt;/h2&gt;
&lt;h3 id=&quot;wait方法&quot;&gt;wait方法&lt;/h3&gt;
&lt;p&gt;wait方法是Object类中的一个方法。调用这个方法会让调用线程进入waiting状态，直到另一个线程调用了当前对象上的notify()或者notifyAll()方法（当然，如果其他线程调用了该线程的interrupt（）方法，该线程抛出InterruptedException异常返回）。同时如果当前线程已经获取了锁资源，调用wait方法之后会释放这个锁资源。&lt;/p&gt;
&lt;p&gt;wait方法还有一个重载方法wait（long time）,这个方法会等待time时间，如果在这个时间内没有其他线程来唤醒它的话，这个线程会自己唤醒继续获得执行机会。&lt;/p&gt;
&lt;p&gt;另外需要注意的是，如果调用wait（）方法的线程没有事先获取该对象的监视器锁，则调用wait（）方法时调用线程会抛出IllegalMonitorStateException异常。&lt;/p&gt;
&lt;h3 id=&quot;notify方法&quot;&gt;notify方法&lt;/h3&gt;
&lt;p&gt;notify方法会唤醒等待对象监视器的单个线程，如果等待对象监视器的有多个线程，则选取其中一个线程进行唤醒到底选择唤醒哪个线程是任意的，由CPU自己决定。&lt;/p&gt;
&lt;p&gt;notify方法还有个兄弟方法notifyAll，这个方法会唤醒所有等待监视器对象的线程。&lt;/p&gt;
&lt;h2 id=&quot;wait-notify模式的典型应用&quot;&gt;wait-notify模式的典型应用&lt;/h2&gt;
&lt;p&gt;wait-notify模式的一个典型应用就是可以实现生产者-消费者模式。让我印象很深是我毕业那年阿里巴巴年校园招聘的一个笔试题：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;有一个苹果箱，有10个人向这个箱子中每次随机放入一个苹果，有10个人每次随机从这个箱子中随机拿走一个苹果，同时需要满足箱子中的苹果总数不能超过50个。请用代码实现上面的场景（不能使用并发集合框架）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;现在看来，这道题不就是为wait-notify模式量身打造的一道题目么。当时水平有限，又急急忙忙的，所以记得当时写的不太好。这边重新整理下这个代码&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
public class AppleBox {

    private int appleCount;

    public synchronized void putApple() {
        while (appleCount &amp;gt;= 50) {
            try {
                this.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        appleCount++;
        String name = Thread.currentThread().getName();
        System.out.println(&quot;[&quot; + name + &quot;]放入一个,当前盒子中苹果数:&quot; + appleCount);
        this.notifyAll();
    }


    public synchronized void takeApple() {
        while (appleCount &amp;lt;= 0) {
            try {
                this.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        appleCount--;
        String name = Thread.currentThread().getName();
        System.out.println(&quot;[&quot; + name + &quot;]拿走一个,当前盒子中苹果数:&quot; + appleCount);
        this.notifyAll();
    }

    private static class AppleTaker implements Runnable {

        private AppleBox appleBox;

        public AppleTaker(AppleBox appleBox) {
            this.appleBox = appleBox;
        }

        @Override
        public void run() {
            while (true) {
                appleBox.takeApple();
                try {
                    TimeUnit.MILLISECONDS.sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }


    private static class ApplePutter implements Runnable {

        private AppleBox appleBox;

        public ApplePutter(AppleBox appleBox) {
            this.appleBox = appleBox;
        }

        @Override
        public void run() {
            while (true) {
                appleBox.putApple();
                try {
                    TimeUnit.MILLISECONDS.sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }


    public static void main(String[] args) {
        AppleBox appleBox = new AppleBox();

        for (int i = 0; i &amp;lt; 20; i++) {
            Thread t = new Thread(new ApplePutter(appleBox));
            t.setName(&quot;ApplePutter:&quot; + i);
            t.start();
        }

        for (int i = 0; i &amp;lt; 20; i++) {
            Thread t = new Thread(new AppleTaker(appleBox));
            t.setName(&quot;AppleTaker:&quot; + i);
            t.start();
        }

    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
[ApplePutter:0]放入一个,当前盒子中苹果数:1
[ApplePutter:1]放入一个,当前盒子中苹果数:2
[ApplePutter:5]放入一个,当前盒子中苹果数:3
[ApplePutter:9]放入一个,当前盒子中苹果数:4
[ApplePutter:13]放入一个,当前盒子中苹果数:5
[ApplePutter:2]放入一个,当前盒子中苹果数:6
[ApplePutter:6]放入一个,当前盒子中苹果数:7
[ApplePutter:10]放入一个,当前盒子中苹果数:8
[ApplePutter:17]放入一个,当前盒子中苹果数:9
[ApplePutter:14]放入一个,当前盒子中苹果数:10
[ApplePutter:18]放入一个,当前盒子中苹果数:11
[ApplePutter:3]放入一个,当前盒子中苹果数:12
[ApplePutter:7]放入一个,当前盒子中苹果数:13
[ApplePutter:11]放入一个,当前盒子中苹果数:14
[ApplePutter:8]放入一个,当前盒子中苹果数:15
[ApplePutter:15]放入一个,当前盒子中苹果数:16
[ApplePutter:19]放入一个,当前盒子中苹果数:17
[ApplePutter:4]放入一个,当前盒子中苹果数:18
[AppleTaker:3]拿走一个,当前盒子中苹果数:17
[ApplePutter:12]放入一个,当前盒子中苹果数:18
[AppleTaker:1]拿走一个,当前盒子中苹果数:17
[AppleTaker:5]拿走一个,当前盒子中苹果数:16
[ApplePutter:16]放入一个,当前盒子中苹果数:17
[AppleTaker:0]拿走一个,当前盒子中苹果数:16
[AppleTaker:12]拿走一个,当前盒子中苹果数:15
[AppleTaker:8]拿走一个,当前盒子中苹果数:14
[AppleTaker:16]拿走一个,当前盒子中苹果数:13
[AppleTaker:7]拿走一个,当前盒子中苹果数:12
[AppleTaker:11]拿走一个,当前盒子中苹果数:11
[AppleTaker:19]拿走一个,当前盒子中苹果数:10
[AppleTaker:9]拿走一个,当前盒子中苹果数:9
[AppleTaker:13]拿走一个,当前盒子中苹果数:8
[AppleTaker:2]拿走一个,当前盒子中苹果数:7
[AppleTaker:6]拿走一个,当前盒子中苹果数:6
[AppleTaker:10]拿走一个,当前盒子中苹果数:5
[AppleTaker:14]拿走一个,当前盒子中苹果数:4
[AppleTaker:4]拿走一个,当前盒子中苹果数:3
[AppleTaker:15]拿走一个,当前盒子中苹果数:2
[AppleTaker:18]拿走一个,当前盒子中苹果数:1
[AppleTaker:17]拿走一个,当前盒子中苹果数:0
[ApplePutter:0]放入一个,当前盒子中苹果数:1
[ApplePutter:1]放入一个,当前盒子中苹果数:2
[ApplePutter:5]放入一个,当前盒子中苹果数:3
[ApplePutter:9]放入一个,当前盒子中苹果数:4
[ApplePutter:13]放入一个,当前盒子中苹果数:5
[ApplePutter:17]放入一个,当前盒子中苹果数:6
[ApplePutter:2]放入一个,当前盒子中苹果数:7
[ApplePutter:6]放入一个,当前盒子中苹果数:8
[ApplePutter:10]放入一个,当前盒子中苹果数:9
[ApplePutter:14]放入一个,当前盒子中苹果数:10
[ApplePutter:18]放入一个,当前盒子中苹果数:11
[ApplePutter:3]放入一个,当前盒子中苹果数:12
[ApplePutter:7]放入一个,当前盒子中苹果数:13
[ApplePutter:11]放入一个,当前盒子中苹果数:14
[ApplePutter:15]放入一个,当前盒子中苹果数:15
[ApplePutter:19]放入一个,当前盒子中苹果数:16
[AppleTaker:3]拿走一个,当前盒子中苹果数:15
[ApplePutter:4]放入一个,当前盒子中苹果数:16
[ApplePutter:8]放入一个,当前盒子中苹果数:17
[ApplePutter:12]放入一个,当前盒子中苹果数:18
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;wait-notify模式的经典写法&quot;&gt;wait-notify模式的经典写法&lt;/h2&gt;
&lt;p&gt;生产者和消费者的逻辑都可以统一抽象成以下几个步骤：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;step1：获得对象的锁；&lt;/li&gt;
&lt;li&gt;step2：循环判断是否需要进行生产活动，如果不需要进行生产就调用wait方法，暂停当前线程；如果需要进行生产活动，进行对应的生产活动；&lt;/li&gt;
&lt;li&gt;step3：通知等待线程&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;伪代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;synchronized(对象) {
    while(条件){
        对象.wait();
    }
    //进行生产或者消费活动
    doSomething();
    对象.notifyAll();
}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 06 Dec 2019 13:22:00 +0000</pubDate>
<dc:creator>写代码的木公</dc:creator>
<og:description>本博客系列是学习并发编程过程中的记录总结。由于文章比较多，写的时间也比较散，所以我整理了个目录贴（传送门），方便查阅。 '并发编程系列博客传送门' 方法简介 wait方法 wait方法是Object类</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/54chensongxia/p/11995981.html</dc:identifier>
</item>
<item>
<title>SSO单点登录思路 - 赐我白日梦</title>
<link>http://www.cnblogs.com/ZhuChangwu/p/11997499.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ZhuChangwu/p/11997499.html</guid>
<description>&lt;h3 id=&quot;sso-single-sign-on&quot;&gt;SSO (Single Sign On)&lt;/h3&gt;
&lt;h3 id=&quot;什么是单点登录&quot;&gt;什么是单点登录:&lt;/h3&gt;
&lt;p&gt;在大型的互联网公司中会有多个系统, 多个项目, 虽然这些项目都属于同一家公司, 但是项目本身其实都是独立的, 那多个系统可不可以实现共享同一份用户认证数据呢?&lt;/p&gt;
&lt;p&gt;SSO单点登录就是做这件事, 各个项目之间彼此相互信任, 在其中任意一个系统中进行登录, 用户的认证信息会被缓存在用户本地, 当用户去访问其他站点时, 可以复用这份认证信息,而免去了重新登录的麻烦, 提高用户体验感&lt;/p&gt;
&lt;h3 id=&quot;xxl单点登录实现的逻辑&quot;&gt;xxl单点登录实现的逻辑&lt;/h3&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;strong&gt;其实市面上的SSO框架还是挺多的, xxl是国人写的, 代码还是挺容易懂的, 对了解SSO的实现流程也是比较有帮助的&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;14&quot;&gt;
&lt;p&gt;&lt;strong&gt;第二点 : 这个项目中会有大量的操作 HttpServletRequest 以及 HttpServletResponse 的代码, 我们从中肯定能学习到编码的技巧, 再不济也能收获到大量跟 request , reponse, jedis 以及往浏览器写入cookie, 重定向等逻辑, 值得学习一下封装成工具类使用&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;xxl的官网是: &lt;a href=&quot;https://www.xuxueli.com/xxl-sso/&quot; class=&quot;uri&quot;&gt;https://www.xuxueli.com/xxl-sso/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;整体的实现思路就是URL+对Cookie或者是token的读写实现的跨域, 这时一种怎么样的实现方式呢? 这就和浏览器对cookie的处理有关了, 当我们使用浏览访问某个站点时, 后台的逻辑可能会往浏览器中写入cookie, 这个cookie的作用大家都知道, 就是一种身份标识, 当用户再次访问相同的站点时, 浏览器会&lt;strong&gt;自动的携带着&lt;/strong&gt;这个站点对应的域名下面的cookie&lt;/p&gt;
&lt;p&gt;就像下面的图中一样, 标识, 这个cookie属于 &lt;code&gt;xxlssoclient1.com&lt;/code&gt; 换句话说,就是用户访问其他站点时是不会携带这个cookie的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1496926/201912/1496926-20191206200105681-1140046418.png&quot; alt=&quot;url&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;从上面的分析中我们可以看出, 其实单点登录的局限性很明显,不能跨域浏览器,因为授权中心的凭证就是存放在用户的浏览器中的cookie&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;言归正传&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;用户请求登录页&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1496926/201912/1496926-20191206200104970-317335128.png&quot; alt=&quot;step1&quot;/&gt;&lt;/p&gt;
&lt;p&gt;服务端一启动首先会先初始化过滤器, 使用这个过滤器将过滤用户的所有的请求, 校验用户是否有权限访问当前系统, 如果没有权限的话, 就将用户的请求转发到授权中心, 转发的路径如下:&lt;/p&gt;
&lt;pre class=&quot;url&quot;&gt;
&lt;code&gt;http://xxlssoserver.com:8080/xxl-sso-server/login?redirect_url=http://xxlssoclient1.com:8081/xxl-sso-web-sample-springboot/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;添加&lt;code&gt;redirect_url&lt;/code&gt;参数的意图很明显,就是为了从授权中心还会重定向回来&lt;/p&gt;
&lt;p&gt;如果授权中心发现,当前访问的用户确实没有任何可用的信息, 就返回一个登录页面给用户&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;用户 登录&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;用户在登陆页面发送登陆的请求到授权中心，会经过如下的流程&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1496926/201912/1496926-20191206200104467-1991064696.png&quot; alt=&quot;step2&quot;/&gt;&lt;/p&gt;
&lt;p&gt;经过的流程我在上图中都标记出来了， 值得注意的是 第二步，会将用户的授权签名提前写回到用户的浏览器中， 因为用户向访问的Client中存在拦截器， 专门拦截用户的请求中是否携带合法的签名，在这里将用户的请求写入到浏览器中后， 下次用户在次访问Client时，就有合法的身份了&lt;/p&gt;
&lt;p&gt;第二个注意点就是 ，在授权中心发起了重定向的操作， 重定向的URL如下：&lt;/p&gt;
&lt;pre class=&quot;url&quot;&gt;
&lt;code&gt;http://xxlssoclient1.com:8081/xxl-sso-web-sample-springboot/?xxl_sso_sessionid=1000_e92ca0cb494b40eaa8e87a3aceb50279&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;url中会携带着sessionId, 目的是保证了这次请求,能顺利的经过Client中检验&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;用户访问彼此信任的其他应用是如何做到不用重复授权的, 如下图&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1496926/201912/1496926-20191206200103524-1373974517.png&quot; alt=&quot;step3&quot;/&gt;&lt;/p&gt;
&lt;p&gt;假设Client的URL是:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;http://xxlssoclient1.com:8081/xxl-sso-web-sample-springboot/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Client2的URL是&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;http://xxlssoclient2.com:8081/xxl-sso-web-sample-springboot/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果Client和Client2共享一个授权中心 , 那么我们在浏览器上先使用Client进行一次登录. 登录成功后返回登录页面&lt;/p&gt;
&lt;p&gt;然后我们在这个浏览器上继续访问Client2的URL, 大家可以看到,Client和Client2的URL中的区别: 就是域名不同, 当然我现在是在本地修改host名字进行模拟 , 实际生产上也是这个样子, 比如一个大型互联网公司, 它肯定有不同的项目 , 不同的项目就有自己不同的域名 , 然后我们现在就实现了访问不同的域名依然能够完成登录&lt;/p&gt;
&lt;p&gt;结合上图看, 用户去访问Client2时, 因为用户从来没有登录过, 所以被Client2的拦截器拦截下来了, 然后将用户的请求重定向到授权中心, &lt;strong&gt;但是这次重定向可是很特别的, 因为它会携带上第一次访问Client时,写入到用户浏览器的Cookie,&lt;/strong&gt; , 这就好办了, 授权是认识这个Cookie的, 于是授权中心拿着这个cookie从redis中取出了用户的信息, 然后将为用户生成的授权sessionId写回用户的浏览器中, 这些写回的授权id, 被浏览器存放在 &lt;code&gt;http://xxlssoclient2.com&lt;/code&gt; 域名下面, 然后再将这个请求重定向回Client2, 这次从定向回来的请求URL长成下面这样&lt;/p&gt;
&lt;pre class=&quot;url&quot;&gt;
&lt;code&gt;http://xxlssoclient2.com:8081/xxl-sso-web-sample-springboot/?xxl_sso_sessionid=1000_6966ea25ae264a28aa3ffe3b89ca7c9a&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;携带了sessionId, 整体一套流程走下来, 客户端也无需要进行重复登录... 实现了单点登录&lt;/p&gt;
&lt;h3 id=&quot;单点注销&quot;&gt;单点注销&lt;/h3&gt;
&lt;p&gt;注销就是删除redis缓存中用户的信息, (xxl的实现中, 授权中心和所有的Client之间共享一个Redis数据库) 这样看, 其实删除也就比较简单了, 只要我们&lt;strong&gt;保证能将redis中的缓存的用户的信息删除就ok&lt;/strong&gt;, &lt;strong&gt;用户浏览器中的 cookie删除与否其实意义不大&lt;/strong&gt;, 因为redis中没有和这个cookie中完全配对的cookie的话, 这个请求仍然会被框架打向登录页面&lt;/p&gt;
</description>
<pubDate>Fri, 06 Dec 2019 12:31:00 +0000</pubDate>
<dc:creator>赐我白日梦</dc:creator>
<og:description>SSO (Single Sign On) 什么是单点登录: 在大型的互联网公司中会有多个系统, 多个项目, 虽然这些项目都属于同一家公司, 但是项目本身其实都是独立的, 那多个系统可不可以实现共享同一</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ZhuChangwu/p/11997499.html</dc:identifier>
</item>
<item>
<title>Redis系列（五）：Redis的RESP协议详解 - toby.xu</title>
<link>http://www.cnblogs.com/toby-xu/p/11992730.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/toby-xu/p/11992730.html</guid>
<description>&lt;h2&gt;一、什么是RESP&lt;/h2&gt;
&lt;p&gt;　　Redis是Redis序列化协议，Redis客户端RESP协议与Redis服务器通信。Redis协议在以下几点之间做出了折衷：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;简单的实现&lt;/li&gt;
&lt;li&gt;快速地被计算机解析&lt;/li&gt;
&lt;li&gt;简单得可以能被人工解析&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;二、RESP协议描述&lt;/h2&gt;
&lt;p&gt;　　RESP协议在Redis 1.2中引入，但在Redis 2.0中成为与Redis服务器通信的标准方式。这个通信方式就是Redis客户端实现的协议。RESP实际上是一个序列化协议，它支持以下数据类型:简单字符串、错误、整数、大容量字符串和数组。&lt;/p&gt;
&lt;h3&gt;　　1、RESP在Redis中用作请求-响应协议的方式如下:&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;客户端将命令以批量字符串的RESP数组的形式发送到Redis服务器，如下：&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SET mykey myvalue
&lt;/span&gt;*3&lt;span&gt;
$&lt;/span&gt;3&lt;span&gt;
SET
$&lt;/span&gt;5&lt;span&gt;
mykey
$&lt;/span&gt;7&lt;span&gt;
myvalue

&lt;/span&gt;*3&lt;span&gt;：SET mykey myvalue 这数组的长度
$&lt;/span&gt;3&lt;span&gt;：表示下面的字符长度是3，这里是SET长度是
$&lt;/span&gt;5&lt;span&gt;：表示下面的字符的长度是5，这里是mykey的长度
$&lt;/span&gt;7：表示下面的字符的长度是7，这里是myvalue的长度
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;服务器根据命令实现使用其中一种RESP类型进行响应&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;　　2、在RESP中，某些数据的类型取决于第一个字节:&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;For &lt;strong&gt;Simple Strings&lt;/strong&gt; the first byte of the reply is &quot;+&quot;   简单字符串回复的第一个字节将是“+”&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　比如：向服务器发送&quot;set toby xu&quot;命令，实际上服务器的返回是:&quot;+OK\r\n&quot;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1761778/201912/1761778-20191206195928695-1344384166.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;For &lt;strong&gt;Errors&lt;/strong&gt; the first byte of the reply is &quot;-&quot;   错误消息，回复的第一个字节将是“-”&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　比如：向服务器发送&quot;add toby xu&quot;命令，实际上服务器的返回是:&quot;-ERR unknown command `add`, with args beginning with: `toby`, `xu`,\r\n&quot;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1761778/201912/1761778-20191206200025955-1936440572.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;For &lt;strong&gt;Integers&lt;/strong&gt; the first byte of the reply is &quot;:&quot;  整型数字，回复的第一个字节将是“:”&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　比如：向服务器发送&quot;incr count&quot;命令，实际上服务器的返回是:&quot;:6\r\n&quot;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1761778/201912/1761778-20191206200125197-1153873959.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;For &lt;strong&gt;Bulk Strings&lt;/strong&gt; the first byte of the reply is &quot;$&quot;  批量回复，回复的第一个字节将是“$”&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　比如：向服务器发送&quot;get toby&quot;命令，实际上服务器的返回是:&quot;$2\r\nxu\r\n&quot;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1761778/201912/1761778-20191206200225790-1714725738.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;For &lt;strong&gt;Arrays&lt;/strong&gt; the first byte of the reply is &quot;*&quot;  数组回复的第一个字节将是“*”&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　比如：向服务器发送&quot;hgetall toby_h&quot;命令，实际上服务器的返回是:&quot;*4\r\n$4\r\njava\r\n$3\r\n100\r\n$3\r\nc++\r\n$2\r\n80\r\n&quot;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1761778/201912/1761778-20191206200454054-499613373.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　示例RedisServerReplyTest代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * @desc: 测试服务器返回
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt;: toby
 * @date: 2019/12/5 23:07
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RedisServerReplyTest {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;(Socket socket = &lt;span&gt;new&lt;/span&gt; Socket(&quot;192.168.160.146&quot;,6379&lt;span&gt;);
            OutputStream os &lt;/span&gt;=&lt;span&gt; socket.getOutputStream();
            InputStream is &lt;/span&gt;=&lt;span&gt; socket.getInputStream()){
            os.write(assemblyCommandForArrays().getBytes());
            &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] bytes=&lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[4096&lt;span&gt;];
            is.read(bytes);
            System.out.println(&lt;/span&gt;&quot;服务器真实返回:&quot; + &lt;span&gt;new&lt;/span&gt;&lt;span&gt; String(bytes));
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
            e.printStackTrace();
        }
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * For Simple Strings the first byte of the reply is &quot;+&quot;
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; String assemblyCommandForSimpleStrings() {
        StringBuilder sb&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringBuilder();
        sb.append(&lt;/span&gt;&quot;*3&quot;).append(&quot;\r\n&quot;&lt;span&gt;);
        sb.append(&lt;/span&gt;&quot;$&quot;).append(&quot;set&quot;.length()).append(&quot;\r\n&quot;&lt;span&gt;);
        sb.append(&lt;/span&gt;&quot;set&quot;).append(&quot;\r\n&quot;&lt;span&gt;);
        sb.append(&lt;/span&gt;&quot;$&quot;).append(&quot;toby&quot;.length()).append(&quot;\r\n&quot;&lt;span&gt;);
        sb.append(&lt;/span&gt;&quot;toby&quot;).append(&quot;\r\n&quot;&lt;span&gt;);
        sb.append(&lt;/span&gt;&quot;$&quot;).append(&quot;xu&quot;.length()).append(&quot;\r\n&quot;&lt;span&gt;);
        sb.append(&lt;/span&gt;&quot;xu&quot;).append(&quot;\r\n&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; sb.toString();
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * For Errors the first byte of the reply is &quot;-&quot;
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; String assemblyCommandForErrors() {
        StringBuilder sb&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringBuilder();
        sb.append(&lt;/span&gt;&quot;*3&quot;).append(&quot;\r\n&quot;&lt;span&gt;);
        sb.append(&lt;/span&gt;&quot;$&quot;).append(&quot;set&quot;.length()).append(&quot;\r\n&quot;&lt;span&gt;);
        sb.append(&lt;/span&gt;&quot;add&quot;).append(&quot;\r\n&quot;&lt;span&gt;);
        sb.append(&lt;/span&gt;&quot;$&quot;).append(&quot;toby&quot;.length()).append(&quot;\r\n&quot;&lt;span&gt;);
        sb.append(&lt;/span&gt;&quot;toby&quot;).append(&quot;\r\n&quot;&lt;span&gt;);
        sb.append(&lt;/span&gt;&quot;$&quot;).append(&quot;xu&quot;.length()).append(&quot;\r\n&quot;&lt;span&gt;);
        sb.append(&lt;/span&gt;&quot;xu&quot;).append(&quot;\r\n&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; sb.toString();
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * For Integers the first byte of the reply is &quot;:&quot;
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; String assemblyCommandForIntegers() {
        StringBuilder sb&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringBuilder();
        sb.append(&lt;/span&gt;&quot;*2&quot;).append(&quot;\r\n&quot;&lt;span&gt;);
        sb.append(&lt;/span&gt;&quot;$&quot;).append(&quot;incr&quot;.length()).append(&quot;\r\n&quot;&lt;span&gt;);
        sb.append(&lt;/span&gt;&quot;incr&quot;).append(&quot;\r\n&quot;&lt;span&gt;);
        sb.append(&lt;/span&gt;&quot;$&quot;).append(&quot;count&quot;.length()).append(&quot;\r\n&quot;&lt;span&gt;);
        sb.append(&lt;/span&gt;&quot;count&quot;).append(&quot;\r\n&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; sb.toString();
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * For Bulk Strings the first byte of the reply is &quot;$&quot;
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; String assemblyCommandForBulkStrings() {
        StringBuilder sb&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringBuilder();
        sb.append(&lt;/span&gt;&quot;*2&quot;).append(&quot;\r\n&quot;&lt;span&gt;);
        sb.append(&lt;/span&gt;&quot;$&quot;).append(&quot;get&quot;.length()).append(&quot;\r\n&quot;&lt;span&gt;);
        sb.append(&lt;/span&gt;&quot;get&quot;).append(&quot;\r\n&quot;&lt;span&gt;);
        sb.append(&lt;/span&gt;&quot;$&quot;).append(&quot;toby&quot;.length()).append(&quot;\r\n&quot;&lt;span&gt;);
        sb.append(&lt;/span&gt;&quot;toby&quot;).append(&quot;\r\n&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; sb.toString();
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * For Arrays the first byte of the reply is &quot;*&quot;
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; String assemblyCommandForArrays() {
        StringBuilder sb&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringBuilder();
        sb.append(&lt;/span&gt;&quot;*2&quot;).append(&quot;\r\n&quot;&lt;span&gt;);
        sb.append(&lt;/span&gt;&quot;$&quot;).append(&quot;hgetall&quot;.length()).append(&quot;\r\n&quot;&lt;span&gt;);
        sb.append(&lt;/span&gt;&quot;hgetall&quot;).append(&quot;\r\n&quot;&lt;span&gt;);
        sb.append(&lt;/span&gt;&quot;$&quot;).append(&quot;toby_h&quot;.length()).append(&quot;\r\n&quot;&lt;span&gt;);
        sb.append(&lt;/span&gt;&quot;toby_h&quot;).append(&quot;\r\n&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; sb.toString();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt; 三、自定义简单的Redis Client&lt;/h2&gt;
&lt;p&gt;　　我们现在了解了Redis的RESP协议，并且知道网络层上Redis在TCP端口6379上监听到来的连接，客户端连接到来时，Redis服务器为此创建一个TCP连接。在客户端与服务器端之间传输的每个Redis命令或者数据都以\r\n结尾，那么接下来我们自定义一个简单的Client。 &lt;/p&gt;
&lt;h3&gt;　　（1）编解码器Coder：&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * @desc: 编解码器
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt;: toby
 * @date: 2019/12/6 19:33
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Coder {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[] encode(&lt;span&gt;final&lt;/span&gt;&lt;span&gt; String str) {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (str == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException(&quot;value sent to redis cannot be null&quot;&lt;span&gt;);
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; str.getBytes(RedisProtocol.CHARSET);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (UnsupportedEncodingException e) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RuntimeException(e);
        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String decode(&lt;span&gt;final&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[] data) {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; String(data, RedisProtocol.CHARSET);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (UnsupportedEncodingException e) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RuntimeException(e);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　（2）Redis协议RedisProtocol：&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * @desc: Redis协议
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt;: toby
 * @date: 2019/12/6 19:33
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RedisProtocol {&lt;br/&gt;&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String CHARSET = &quot;UTF-8&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt; DOLLAR_BYTE = '$'&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt; ASTERISK_BYTE = '*'&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt; PLUS_BYTE = '+'&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt; MINUS_BYTE = '-'&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt; COLON_BYTE = ':'&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt; CR_BYTE = '\r'&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt; LF_BYTE = '\n'&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * *3
     * $3
     * SET
     * $4
     * toby
     * $2
     * xu
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; os
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; command
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; args
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; sendCommand(&lt;span&gt;final&lt;/span&gt; OutputStream os, &lt;span&gt;final&lt;/span&gt; Command command, &lt;span&gt;final&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[]... args) {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            os.write(ASTERISK_BYTE);
            os.write(Coder.encode(String.valueOf(args.length &lt;/span&gt;+ 1&lt;span&gt;)));
            os.write(CR_BYTE);
            os.write(LF_BYTE);
            os.write(DOLLAR_BYTE);
            os.write(Coder.encode(String.valueOf(command.name().length())));
            os.write(CR_BYTE);
            os.write(LF_BYTE);
            os.write(Coder.encode(command.name()));
            os.write(CR_BYTE);
            os.write(LF_BYTE);
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;final&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[] arg : args) {
                os.write(DOLLAR_BYTE);
                os.write(Coder.encode(String.valueOf(arg.length)));
                os.write(CR_BYTE);
                os.write(LF_BYTE);
                os.write(arg);
                os.write(CR_BYTE);
                os.write(LF_BYTE);
            }
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RuntimeException(e);
        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt;&lt;span&gt; Command{
        SET, GET
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　（3）自定义Client RedisClient：&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * @desc: 自定义Client
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt;: toby
 * @date: 2019/12/6 19:31
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RedisClient {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String host;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; port;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; RedisClient(String host,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; port){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.host =&lt;span&gt; host;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.port =&lt;span&gt; port;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String set(String key,String value){
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt; (Socket socket = &lt;span&gt;new&lt;/span&gt; Socket(&lt;span&gt;this&lt;/span&gt;.host,&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.port);
             InputStream is &lt;/span&gt;=&lt;span&gt; socket.getInputStream();
             OutputStream os &lt;/span&gt;=&lt;span&gt; socket.getOutputStream()){
            RedisProtocol.sendCommand(os,RedisProtocol.Command.SET,Coder.encode(key),Coder.encode(value));
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; getReply(is);
        }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; e.getMessage();
        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String get(String key){
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt; (Socket socket = &lt;span&gt;new&lt;/span&gt; Socket(&lt;span&gt;this&lt;/span&gt;.host,&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.port);
             InputStream is &lt;/span&gt;=&lt;span&gt; socket.getInputStream();
             OutputStream os &lt;/span&gt;=&lt;span&gt; socket.getOutputStream()){
            RedisProtocol.sendCommand(os,RedisProtocol.Command.GET,Coder.encode(key));
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; getReply(is);
        }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; e.getMessage();
        }
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String getReply(InputStream is){
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] bytes = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[4096&lt;span&gt;];
            is.read(bytes);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Coder.decode(bytes);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
            e.printStackTrace();
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　（4）Redis Client 测试 RedisClientTest：&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * @desc: Redis Client 测试
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt;: toby
 * @date: 2019/12/6 19:35
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RedisClientTest {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        RedisClient client &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; RedisClient(&quot;192.168.160.146&quot;,6379&lt;span&gt;);
        System.out.println(client.set(&lt;/span&gt;&quot;toby_2&quot;,&quot;xu_2&quot;&lt;span&gt;));
        System.out.println(client.get(&lt;/span&gt;&quot;toby_2&quot;&lt;span&gt;));
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　运行结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1761778/201912/1761778-20191206201733017-426856052.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　至此自定义的简单的Redis Client完成！！！！！！&lt;/p&gt;
&lt;h2&gt;四、总结&lt;/h2&gt;
&lt;p&gt;　　通过本章的学习，了解了什么是Redis的RESP协议？Redis协议几个特点：简单的实现；快速地被计算机解析；简单得可以能被人工解析。有了协议，我们就可以通过自定义的Client想Redis服务端发起请求，从而进行操作Redis。对后面理解Redis客户端Jedis的实现原理有很大的帮助。&lt;/p&gt;
</description>
<pubDate>Fri, 06 Dec 2019 12:28:00 +0000</pubDate>
<dc:creator>toby.xu</dc:creator>
<og:description>一、什么是RESP Redis是Redis序列化协议，Redis客户端RESP协议与Redis服务器通信。Redis协议在以下几点之间做出了折衷： 简单的实现 快速地被计算机解析 简单得可以能被人工解</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/toby-xu/p/11992730.html</dc:identifier>
</item>
<item>
<title>mybatis精讲(五)--映射器组件 - 烟花散尽13141</title>
<link>http://www.cnblogs.com/zhangxinhua/p/11997434.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangxinhua/p/11997434.html</guid>
<description>[unable to retrieve full-text content][TOC] 前言 映射器之前我们已经提到了，是mybatis特有的组件： java+xml组合的方式。对于Java类和xml的编写也很简单。值得注意的是需要将Java编写的mapper注册到mybatis中来。之前的注册的方式通过xml。到后续通过spirng来管理通过@Mapper就很方便了。 标</description>
<pubDate>Fri, 06 Dec 2019 12:21:00 +0000</pubDate>
<dc:creator>烟花散尽13141</dc:creator>
<dc:identifier>http://www.cnblogs.com/zhangxinhua/p/11997434.html</dc:identifier>
</item>
</channel>
</rss>